


\documentclass[copyright]{eptcs}
\providecommand{\event}{DCFS 2010} \usepackage{breakurl}             
\usepackage{latexsym}
\usepackage[dvips]{graphics}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amssymb}
\setcounter{tocdepth}{3}
\begin{document}
\def\bbbn{{\rm I\!N}} \newcommand{\latex}{\LaTeX}
\newcommand{\tex}{\TeX}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\flor}[1]{\lfloor{#1}\rfloor}

\def \prend{\vrule depth-1pt height7pt width6pt}
\def \proof{\bigbreak\noindent{\bf Proof.\ \ }}
\def \endpf{{\ \ \prend \medbreak}}

\def\vs{\vspace{1mm}}

\newtheorem{theorem}{T\/heorem}[section]
\newtheorem{apptheo}{T\/heorem}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{applem}{Lemma}[section]
\newtheorem{example}{Example}[section]
    \newtheorem{appexample}{Example}[section]
\newtheorem{fact}{Fact}[section]
\newtheorem{claim}{Claim}[section]
\newtheorem{proposition}{Proposition}
\newtheorem{remark}{Remark}[section]
\newcommand{\propersubset}{\subset}
\newtheorem{problem}{Open problem}

\title{Operational State Complexity of\\
  Deterministic Unranked Tree Automata}


\author{Xiaoxue Piao \qquad\qquad Kai Salomaa
\institute{School of Computing, Queen's University\\
Kingston, Ontario K7L 3N6, Canada}
\email{\{piao, ksalomaa\}@cs.queensu.ca}
}
\def\titlerunning{Unranked Tree Automata}
\def\authorrunning{X. Piao \& K. Salomaa}


\maketitle

\begin{abstract}
    We consider  the state complexity of
basic operations on tree languages recognized by
deterministic unranked
     tree automata.
     For the operations of
     union and intersection the
upper and lower bounds of both weakly and strongly
 deterministic
     tree automata are obtained.
For tree concatenation we establish a tight upper bound that
is of a different order than the known state complexity
of concatenation of regular string languages.
We show that 
     vertical states are sufficient, and
necessary in the worst case, to recognize the concatenation
of tree languages recognized by  (strongly or
weakly) deterministic automata with, respectively,
      and  vertical states.\\
Keywords:
     operational state complexity, tree automata,
     unranked trees, tree operations
\end{abstract}


\section{Introduction}\label{s:in}

As XML \cite{dtddef} has  played increasingly important roles in
data representation and exchange through the web,  tree automata
have gained renewed interest, particularly tree automata operating
on unranked trees. XML documents can be abstracted as unranked
trees, which makes unranked tree automata a natural and
fundamental model for various XML processing tasks
\cite{CDG,MaN,Sc}. Both deterministic and nondeterministic
unranked tree automata have been studied.

One method to handle unranked trees is to encode them as ranked
trees and then use the classical
theory of ranked tree automata. However, the
encoding may result in trees of unbounded height since there is
no a priori restriction on the number of the children of a node in
unranked trees. Also depending on various applications, it may
be difficult to come up with a proper
 choice of the encoding method.

Descriptional complexity of finite automata and related
structures has been extensively studied
in recent years~\cite{GH,HK2,HK,Yu,Yu2}.
Here we consider operational state complexity of deterministic unranked
tree automata. Operational state complexity describes how the size
of an automaton varies under regularity preserving operations.
The corresponding results for string languages are well
known~\cite{galina,Yu,YuZhSa94},
however, very few results have been obtained for tree automata.
While   state complexity results for  tree automata
operating on ranked trees
 are often similar to corresponding
results on  regular string automata \cite{Yu}, the situation becomes
essentially different for automata operating on unranked trees.
An unranked tree automaton has two different types of states,
called horizontal and vertical states, respectively.
There are also other automaton models that
can be used to process  unranked trees, such
as nested word automata and stepwise tree automata. The state
complexity of these models has been studied
in~\cite{HS,mn,nestps}.

We study two different models of determinism for unranked
tree automata.
We call the usual deterministic unranked tree automaton \cite{CDG}
model where
the horizontal languages defining the transitions are specified by
DFAs (deterministic finite automata),
 a {\em weakly deterministic tree automaton} (or WDTA). For the
other variant of determinism for unranked tree automata,  we
refer to the corresponding automaton model as a
 {\em strongly deterministic unranked tree automaton} (or SDTA).
This model was introduced by Cristau, L\"oding and
Thomas~\cite{CLT}, see also
Raeymaekers and Bruynooghe~\cite{RB}.
SDTAs can be minimized efficiently and the
minimal automaton is unique~\cite{CLT}. On the other hand, the
minimization problem for WDTAs is NP-complete and the minimal
automaton need not be unique~\cite{mn}.

We give upper  and lower bounds for
the numbers of both vertical and
horizontal states for the operations of union and intersection.
The upper bounds for vertical states
are tight for both SDTAs and WDTAs. We also get upper bounds which
are almost tight for the number
of the horizontal states of SDTAs. Obtaining
a matching
lower bound for the horizontal states of WDTAs turns out to be
very problematic. This is mainly because the minimal WDTA may not
be unique and the minimization of WDTAs is intractable~\cite{mn}.
Also, the number of horizontal states of WDTAs can be reduced by
adding vertical states, i.e., there can be trade-offs between
the numbers of horizontal and vertical states, respectively.

The upper bounds for the number of
 vertical states for union
and intersection of WDTAs and SDTAs are,
as expected, similar to the upper
bound for the corresponding operation on ordinary string automata.
Already in the case of union and intersection,
the upper bounds for the numbers
horizontal states  are dramatically different for WDTAs and
SDTAs, respectively.
In an SDTA, the
horizontal language associated with label  is represented
with a single DFA  augmented with an output function
. The state assigned to a node labeled with  is
determined by the final state reached in  and .
On the other hand, in a WDTA, the horizontal languages associated
with a given label  and different states are represented
by distinct DFAs. The state assigned to a node labeled with 
depends on the choice of the DFA.

We consider also the state complexity of
 (tree)
concatenation of  SDTAs. It is well known
that  states are sufficient to accept the
concatenation of an  state DFA and an  state
DFA~\cite{YuZhSa94}. However, the tight upper bound to accept the
concatenation of
unranked tree automata,
with  and  vertical states respectively,
turns out to be . The
factor  is necessary here because the automaton accepting
the concatenation of two tree languages must keep track of the
computations where no concatenation has been done. For string
concatenation, there is only one path and the concatenation always
takes place  somewhere on that path.
For non-unary trees, there is no way
that the automaton can foretell on which branch the concatenation
is done and, consequently, the automaton for concatenation needs
considerably more states.
 It should be emphasized
that this phenomenon is not caused by any particular construction
used for the automaton to accept the concatenation of given tree
languages, and we have a matching lower bound result.

Since complementation is an ``easy'' operation for both strongly
and weakly deterministic tree automata, we do not investigate its
state complexity in this paper. Note that we do not require the
automaton models to be complete (i.e., some transitions may be
undefined). A (strongly or weakly) deterministic automaton
accepting the complement of a tree language recognized by the same
type of automaton would need at most one additional vertical state
and it is easy to see that this bound can be reached in the worst
case.

The  paper is organized as follows. Definitions of
unranked tree automata and other notations are given in
section~\ref{pre}. The upper bounds and corresponding
lower bounds  for union and
intersection of SDTAs are presented in section~\ref{sdta}. In
section~\ref{wdta}, the state complexity of union and
intersection of WDTAs is discussed. The tight bound for the
number of vertical
states for tree concatenation of SDTAs is
given in section~\ref{con}. The same construction works for
WDTAs.


\section{Preliminaries}\label{pre}

Here we briefly recall some notations and definitions concerning
trees and tree automata. A general reference on tree automata
is~\cite{CDG}.

Let  be the set of non-negative integers. A {\em tree
domain}  is a finite set of elements in  with the
following two properties: (i) If  and  is a prefix of
 then . (ii) If ,  and  then
. The nodes in an unranked tree  can be denoted by a
tree domain , and  is a mapping from  to the
set of labels . The set of -labeled trees is
.

For  and , 
denotes the tree obtained from  by replacing the subtree at
node  by . The concatenation of trees  and  is
defined as
.
The concatenation operation is extended in the
natural way to sets of trees , : 

We denote a tree , whose root is
labeled by  and leaves are labeled by ,
simply as . When , write
. By a slight abuse of notation, for a unary tree , we write  for abbreviation. When , we write 
for short. (In each case it should be clear from the context
whether  refers to a sequence of leaves or to a unary tree.)


Next we briefly recall the definitions of the two variants of
deterministic bottom-up tree automata considered here.
A {\em weakly deterministic unranked tree automaton} (WDTA) is a
4-tuple  where  is a finite set of
states,  is the alphabet,  is the set of
final states,  is a mapping from  to the
subsets of 
which satisfies the condition that, for each  is a regular language
and for each label  and every two states ,
. The
language  is called the {\em horizontal
language} associated with  and  and it is specified
by a DFA .

Roughly speaking, a WDTA operates as follows.
If  has reached the children of a
-labelled node  in states
 ,  ,..., , the
computation assigns state  to node  provided that
. In the sequence
 an element  is interpreted to
correspond to a leaf labeled by that symbol.
A WDTA is a deterministic
hedge automaton~\cite{CDG} where each horizontal language
is specified using a DFA.

Note that in the usual definition of~\cite{CDG} the
horizontal languages
are subsets of . In order to simplify some constructions,
 we allow also the use of symbols  of the
alphabet  in the horizontal languages, where
a symbol  occurring in a word of
a horizontal language is always interpreted to label
a leaf of the tree.
The convention does not
change the state complexity bounds in any
significant way because we use small
constant size alphabets and we can think that the tree automaton
assigns to each leaf labeled by  a particular
state that is not used anywhere else in the computation.

A {\em strongly deterministic unranked tree automaton} (SDTA) is a
4-tuple , where  are
similarly defined as for WDTAs. For each , the
horizontal languages , , are defined by a
single DFA augmented with an output function as follows. For  define  where  is a
DFA and  is a mapping . For all  and , the horizontal language 
is specified by  as the set . Intuitively, when  has
reached the children of a node  labelled by  in states  (an element  is interpreted as a
label of a leaf node), the state at  is determined (via the
function ) by the state that the DFA  reaches
after reading the word . More information on
SDTA's can be found in~\cite{CLT}.

Given a tree automaton , the states in 
are called {\em vertical states\/}. The DFAs recognizing
the horizontal languages are called {\em horizontal
DFAs\/} and their states
 are called horizontal states.
We define the {\em (state) size of ,}  , as a pair of integers , where
 is the sum of the sizes of all horizontal DFAs associated
with .





\section{Union and intersection}

We investigate the state complexity of union and intersection
operations on unranked tree automata. The upper bounds on the
numbers of vertical states are similar for SDTAs and WDTAs,
however the upper bounds on the numbers of horizontal states
differ between the two models.

\subsection{Strongly deterministic tree automata}\label{sdta}












The following result gives the upper bounds and the lower bounds
for the operations of union and intersection for SDTAs.

\begin{theorem}\label{xxx}
For any two arbitrary SDTAs ,
, whose transition function associated with  is
represented by a DFA , we have
\begin{description}
  \item[1] Any SDTA  recognizing  satisfies that 
  \item[2] Any SDTA  recognizing  satisfies that 
  \item[3] For integers  and relatively prime numbers
  , there exists
  tree languages  and  such that  and , respectively, can be
  recognized by SDTAs with  and  vertical states,
   and  horizontal states, and
\begin{description}
  \item[i] any SDTA recognizing  has at least
  vertical
  states and  horizontal states.
  \item[ii] any SDTA recognizing  has at least  vertical
  states and  horizontal states.
\end{description}
\end{description}
\end{theorem}


The upper bounds on vertical and horizontal states are obtained
from product constructions, and Theorem~\ref{xxx} shows that for
the operations of union and intersection on SDTAs the upper bounds
are tight for vertical states and almost tight for horizontal
states.


\subsection{Weakly deterministic automata}\label{wdta}

In this section, the upper bounds on the numbers of vertical and
horizontal states for the operations of union and intersection on
WDTAs are investigated, and followed by matching lower bounds on
the numbers of vertical states.






\begin{lemma}\label{union}
Given two WDTAs , , each
horizontal language  is represented by a DFA
.

The language  can be recognized by a WDTA
 with


The language  can be recognized by a WDTA
 with 
\end{lemma}
The theorem below shows that the upper bounds for the vertical
states are tight.

\begin{theorem}\label{dtadfa}
For any two WDTAs  and  with  and  vertical states
respectively, we have
\begin{itemize}
  \item[1] any WDTA recognizing  needs at
  most  vertical states,
  \item[2] any WDTA recognizing  needs at
  most  vertical states,
  \item[3] for any integers , there exist tree languages 
  and  such that  and  can be recognized by
  WDTAs with  and  vertical states respectively, and any WDTA
  recognizing  has at least  vertical
  states, and any WDTA recognizing  has at least  vertical
  states.
\end{itemize}
\end{theorem}


\begin{problem}
Are the upper bounds for the numbers of horizontal states given in
Lemma~\ref{union} tight?
\end{problem}
In the case of WDTAs we do not have
a general method to establish lower bounds on the number of the horizontal states.
It remains an open question to give (reasonably) tight lower
bounds on the number of horizontal states needed to recognize the
union or intersection of tree languages recognized by two WDTA's.
\section{Concatenation of strongly deterministic tree automata}\label{con}

We begin by  giving a construction of an SDTA recognizing the
concatenation of two tree languages recognized by given
 SDTAs.

\begin{lemma}\label{cons}
Let  and  be two arbitrary SDTAs.
, , transition function for
each  is represented by a DFA
 with an output
function .

The language  can be recognized by an SDTA 
with

\end{lemma}

\begin{proof}
Choose ,
where , , . Let .  is final if there exists
 such that .

The transition function  associated with each  is
represented by a DFA  with an output
function , where , ,
. Let , .  is final if  or there exists
 such that .  is
defined as below:

For any input ,

For any input , if ,


if ,


Write the computation above in an abbreviated form as , . When compute  and , if any
, , , , is not defined in , assign  to
 or . When compute , add nothing to  if any
 is not defined.

Let  denote the state assigned to the leaf in
 substituted by a tree in .  is
defined as: for any final state ,
, ,
\begin{itemize}
  \item[1] If 

\item[2] If ,

If , define . If
, define .
\end{itemize}
The state in  has three components .  is
used to keep track of 's computation where no concatenation
is done.  is computed by the first component  in the
state of .  traces the computation where the
concatenation takes place. In a state 
of ,  (or ) records there is (or is not)
a concatenation in the computation. The third component  keeps
track of the computation of . When a final state is reached
in , which means a concatenation might take place, an initial
state  is added to , which is achieved by the
 function in .

According to the definition of , when
,  is always in the
second component of the state. Exclude the cases when
, and  is not in the
second component of the state, and we do not require  be
complete.  has  vertical states in worst case.
\end{proof}
\endpf

Lemma~\ref{cons} gives an upper bound on both the numbers of
vertical and horizontal states recognizing the concatenation of
 and . In the following we give a matching lower
bound for the number of vertical states of any SDTA recognizing
.




For our lower bound construction we define tree languages
consisting of trees where, roughly speaking, each branch
belongs to the worst-case languages used for string concatenation
in~\cite{YuZhSa94} and, furthermore, the minimal DFA
reaches the same state at an arbitrary node  in computations starting
from any two leaves below . For technical reasons, all leaves
of the trees are labeled by a fixed symbol and the strings used to
define the tree language do not include the leaf symbols.

As shown in
Figure~\ref{f:dfa},  and  are the DFAs used in Theorem~1 of
\cite{YuZhSa94} except that a self-loop labeled by
an additional symbol  is added to
each state in .
We use the symbol  as an identifier of DFA ,
which always leads  to a dead state in the computations of .
This will be useful for establishing that all vertical states
of the SDTA constructed as in Lemma~\ref{cons} are needed
to recognize the concatenation of tree languages defined below.

\begin{figure}
\centering
\includegraphics[height=3cm]{dfaold.eps}
\caption{DFA  and }\label{f:dfa}
\end{figure}

Based on the DFAs  and  we define the tree languages
 and  used in our lower bound construction.
The tree language  consists of -labeled trees ,
, where:
\begin{enumerate}
\item All leaves are labeled
by  and if a node  has a child that is a leaf, then all the
children of  are leaves.
\item  accepts the string of symbols labeling
a path from any node of height one to the root.
\item The following
holds for any  and any nodes
  and 
 of height one below . If  is the string
of symbols labeling the path from  to , , then
 reaches the same state after reading strings  and .
\end{enumerate}
Intuitively, the above condition means that when, on a tree of
, the DFA  reads strings of symbols labeling paths
starting from nodes of height one upwards, the computations
corresponding to different paths ``agree'' at each node. This
property is used in the construction of an SDTA  for 
below.

Note that the computations of  above are started from the nodes
of height one and they ignore the leaf symbols. This is done for
technical reasons because in tree concatenation a leaf symbol is
replaced by a tree, i.e., the original symbol labeling the leaf
will not appear in the resulting tree.

 can be recognized by an SDTA  where  and .
The transition function is defined as:
\begin{itemize}
  \item[(1)] ,
  \item[(2)] ,
  \item[(3)] ,
  \item[(4)]  and
  ,
  \item[(5)] .
\end{itemize}

The tree language  and an SDTA  recognizing it are
defined similarly based on the DFA . Note that  has no
occurrences of the symbol  and  has no transitions defined
on .
The SDTAs  and  have  and 
vertical states, respectively.

An SDTA  recognizing tree language \ \
\footnote{Recall from section~\ref{pre} that 
consists of trees where in some tree of  a leaf is replaced
by a tree of .} is obtained from  and  using the
construction given in Lemma~\ref{cons}. The vertical states in 
are of the following form
 where if  then , and if 
then  and  can not both be true. The number of states
in~(\ref{state1}) is . State  (or
) denotes  (or ) in the construction of
lemma~\ref{cons}. We will show that  needs at least  vertical states. We prove this by showing
that each state in~(\ref{state1}) is reachable and all states are
pairwise inequivalent, or distinguishable. Here distinguishability
means that for any distinct states  and  there exists  such that the (unique deterministic) computation
of  on  leads to acceptance if and only if
the computation of  on  does not lead to
acceptance.

\begin{lemma}
All states of  are reachable.
\label{reach}
\end{lemma}

\begin{proof}
We introduce the following notation. For a unary tree
\\, we denote
. Note that 
consists of the sequence of labels of  from the node of height
one to the root, and the label of the leaf is not included.

We show that all the states in~(\ref{state1}) are reachable
by using induction on .

When , , ,  is reachable from  by reading tree  where
. State ,  is
reachable from  by reading tree 
where  and . State
 is reachable by reading symbol  from state
, . State ,
 is reachable from  by reading
tree  where  and
.

When , ,  is reachable
from  by reading tree  where
.

State , is reachable from  by
reading tree  where  and
.

State , ,  is
reachable from  by reading a sequence of unary
symbol .

State ,  is reachable from
 by reading tree  where
.

From  by reading subtree , state
 is reached. State  is reached
from  by reading a sequence of unary symbols
.

That is all the states , ,  are reachable.

Then state , , ,
 is reachable from 
by reading a sequence of unary symbols . For any integer
,

State , ,  is
reachable from  by reading a sequence of unary
symbols . State , ,  is reachable from  by
reading a unary symbol . State ,  is reachable from  by reading a unary symbol
.

That is all the states , , ,  are reachable.

Now assume that for , all the states ,
, , 
are reachable. And this is the inductive assumption.

We will show that any state , , ,  is reachable.

First consider the case where . Let  be the elements in . Let .

When , according to the inductive assumption,
state , is reachable. Then state
 is reachable from
 by reading a sequence of unary
symbols . State ,  is
reachable from  by
reading a sequence of unary symbols . State  is reachable from  by reading a sequence of unary symbols .

When , according to the inductive assumption, state , is reachable. Then state  is reachable
from  by reading a sequence of unary symbols .
,  is reachable from  by reading a sequence of unary symbols
. State  is reachable from  by reading a sequence of unary symbols
.

Now consider the case when . According to the definition of
(\ref{state1}), . According to the inductive assumption,
state  is reachable. Then state 
is reachable by reading a unary symbol .

Since  is an arbitrary state with , we have
proved that all the states , , ,  is reachable.

Thus, all the states in (\ref{state1}) are reachable.
\end{proof}\endpf

\begin{lemma}
All states of  are pairwise inequivalent. \footnote{Proof
omitted due to length restriction.} \label{inequi}
\end{lemma}

According to the upper bound in Lemma~\ref{cons} and
Lemmas~\ref{reach} and~\ref{inequi}, we have proved the following
theorem.

\begin{theorem}\label{ti}
For arbitrary SDTAs  and , where
, , any SDTA
 recognizing  satisfies
.

For any integers , there exists tree languages  and
, such that  and  can be recognized by  SDTAs
having  and  vertical states, respectively,
 and any SDTA recognizing
 needs at least 
vertical states.
\end{theorem}

We do not have a matching lower bound for the number of horizontal
states given by Lemma~\ref{cons}. With regards to the number of
vertical states, both the upper bound of Lemma~\ref{cons} and the
lower bound of Theorem~\ref{ti} can be immediately modified for
WDTAs. (The proof holds almost word for word.)  In the case of
WDTAs, getting a good lower bound for the number of horizontal
states would likely be very hard.

\section{Conclusion}

We have studied the operational state complexity of two variants
of deterministic unranked tree automata. For  union and
intersection, tight upper bounds on the number of vertical states
were established for both strongly and weakly deterministic
automata. An almost tight upper bound on the number of horizontal
states was obtained in the case of strongly deterministic unranked
tree automata. For weakly deterministic  automata,
lower bounds on the numbers of horizontal states are hard to
establish because there can be trade-offs between the numbers of
vertical and horizontal states.
This is indicated also by the fact that minimization of weakly
deterministic unranked tree automata is intractable and the
minimal automaton need not be unique~\cite{mn}.

As  ordinary
strings can be viewed as unary trees, it is easy to predict that
the state complexity of a given operation for tree automata should
be greater or equal to  the state complexity of the corresponding
operation on string languages.
As our main result, we showed that for
deterministic unranked tree automata, the
 state complexity of concatenation of an  state and
an  state automaton is at most 
and that this bound can be reached in the worst case.
The bound is
of a different order than the known state complexity 
of  concatenation of regular string languages.

\begin{thebibliography}{99}

{\small

\bibitem{dtddef}
T. Bray, J. Paoli, C.M. Sperberg-McQueen, ``Extensible Markup
Language (XML) 1.0 (5th Edition)'', W3C Recommendation, Nov. 2008,
http://www.w3.org/TR/2008/REC-xml-20081126/.


\bibitem{CDG}
H. Comon, M. Dauchet, R. Gilleron, F. Jacquemard, D. Lugiez, S.
Tison, M. Tommasi, Tree automata techniques and applications,
available on: http://www.grappa.univ-lille3.fr/tata, 1997, release
October 1st, 2002.

\bibitem{CLT}  J. Cristau, C. L\"oding, W. Thomas,
Deterministic automata on unranked trees, {\em Proc. of FCT'05,
Lect. Notes Comput. Sci. } 3623, Springer, 68--79 (2005)

\bibitem{HS} Y.-S. Han, K. Salomaa. Nondeterministic state
complexity of nested word autoamta.
{\em Theoret. Comput. Sci.} 410 (2009) 2961--2971.

\bibitem{GH} H. Gruber and M. Holzer,
Tight bounds for the descriptional complexity of regular
expressions. {\em Proc. of DLT'09}, Lect. Notes Comput.
Sci. 5583, (2009) 276--287.

\bibitem{HK2} M. Holzer and M. Kutrib,
Nondeterministic finite automata---Recent results on the
descriptional and computational complexity.
{\em Proc. of CIAA'08,} Lect. Notes Comput. Sci.
5148 (2008) 1--16.

\bibitem{HK} M. Holzer and M. Kutrib,
Descriptional and computational complexity of finite automata,
{\em Proc. of LATA'09,} Lect. Notes Comput. Sci. 5457, Springer,
23--42 (2009)

\bibitem{galina} G. Jiraskov\'a,
State complexity of some operations on
binary regular languages, {\em Theoretical Computer Science\/} 330
(2005) 287-298.


\bibitem{MaN}
W. Martens, F. Neven, Typechecking top-down uniform unranked tree
transducers, Lecture Notes in Computer Science, Volume 2572, pp.
64-78, 2003.

\bibitem{mn} W. Martens, J. Niehren, On the minimization of
XML schemas and tree automata for unranked trees, {\em J. Comput.
System Sci.} 73 (2007) 550--583.

\bibitem{nestps}
X. Piao, K.Salomaa. Operational state complexity of nested word
automata. {\rm Theoret. Comput. Sci.} 410, 3290-3302, 2009.

\bibitem{RB} S. Raeymaekers, M. Bruynooghe.
Minimization of finite unranked tree automata. Manuscript, 2004.


\bibitem{Sc}
T. Schwentick, Automata for XML-A survey, Journal of Computer and
System Sciences, Volume 73, pp. 289-315, 2007. \vspace*{-2mm}

\bibitem{Yu}  Yu, S.: Regular languages,
in:  Rozenberg, G.,  Salomaa, A. (eds.), {\em  Handbook of Formal
Languages,} vol. I, Springer, Berlin, pp.  41--110 (1997)

\bibitem{Yu2} S. Yu, State complexity: Recent results
and open problems. {\em Fundam. Inform.} 64 (2005) 471--481.

\bibitem{YuZhSa94}
S. Yu, Q. Zhuang, K. Salomaa: The state complexity of some basic
operations on regular languages, Theoretical Computer Science 125
(1994) 315-328
} 
\end{thebibliography}
\end{document}
