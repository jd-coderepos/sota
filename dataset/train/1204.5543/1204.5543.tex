\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{EPTCS 2011} \usepackage{breakurl}             

\usepackage{mytheorems}
\usepackage{amsmath}
\usepackage{mathrsfs}
\usepackage{amssymb}
\usepackage{latexsym} 
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{float}
\usepackage{url}
\usepackage{enumerate}
\usepackage{euscript}
\usepackage{subfigure}
\usepackage{floatflt}
\usepackage[all]{xy}


\title{Lazy AC-Pattern Matching for Rewriting}

\author{Walid Belkhir and Alain Giorgetti\\
 FEMTO-ST, University of Franche-Comt\'{e},\\
  16 route de Gray, 25030 Besan\c{c}on cedex, France\\
INRIA Nancy - Grand Est, CASSIS project, 54600 Villers-l\`es-Nancy,
France\\
\url{{walid.belkhir,alain.giorgetti}@femto-st.fr}\\
}
 \def\titlerunning{Lazy AC-matching for rewriting}
 \def\authorrunning{W. Belkhir \& A.Giorgetti}


\newcommand \NF[1]{#1_{\leadsto^{\star}}}
\newcommand \match[2]{#1 \ll #2}
\newcommand \matchth[3]{#1 {\ll}_{{ }_{#3}} {#2}}
\newcommand \matchAC[2]{\matchth{#1}{#2}{AC}}
\newcommand \rrule[2]{#1\rightarrow #2}
\newcommand \flaten[1]{\mathfrak{U}(#1)}
\newcommand \free[1]{\mathcal{V}(#1)}
\newcommand \surj[2]{\mathfrak{s}_{{#1},{#2}}}
\newcommand \surjs[1]{\mathfrak{#1}}
\newcommand \up {\uparrow}
\newcommand \set[1]{\{#1\}}

\newcommand \varset{\ensuremath{\mathcal{X}}}
\newcommand \symbolset{\ensuremath{F}}
\newcommand \termset{\ensuremath{T(\symbolset,\varset)}}
\newcommand \first[2]{\ensuremath{0_{#1,#2}}}
\newcommand \head[1]{\ensuremath{\textsf{hd}(#1)}}
\newcommand \queue[1]{\ensuremath{\textsf{tl}(#1)}}
\newcommand \term[3]{\ensuremath{#1_{#2_{#3}}}}
\newcommand \ACsymb{\ensuremath{+}}
\newcommand \unr[1]{\ensuremath{\mathcal{U}(#1)}}
\newcommand \trip[1]{\langle #1 \rangle}
\newcommand \lazy{}
\newcommand \Ronetwo{\ensuremath{\mathcal{R}_1\cup\mathcal{R}_2}} 
\newcommand \Rthree{\ensuremath{\mathcal{R}_3^{\downarrow}}} 


\newcommand \mycomment[1]{}
\newcommand \mynote[1]{\textbf{[[#1]]}}
\newcommand \llist[1]{\ensuremath{\textit{LList}(#1)}}
\newcommand \Eu[1]{\EuScript{#1}}

\newcommand \interp[1]{[#1]}
\newcommand \numberAC[1]{\sharp_{{}_{AC}}{(#1)}}
\newcommand \numberOf[2]{\sharp_{{}_{#1}} (#2)}

\newcommand \lland {\vec{\land}}
\newcommand \llor {\vec{\lor}}
 
\newtheorem{case}{Case}
\newtheorem{subcase}{Case}
\numberwithin{subcase}{case}


\begin{document}
\maketitle

\setlength{\abovecaptionskip}{-0.5cm}
\setlength{\belowcaptionskip}{-0.2cm}

\begin{abstract}
We define a lazy pattern-matching  mechanism  modulo associativity and commutativity. 
The solutions of a pattern-matching problem are stored in a lazy list composed of 
a first substitution at the head and  a non-evaluated object  that encodes  the
remaining  computations. We integrate the lazy AC-matching in a strategy language: 
 rewriting rule and strategy application produce a lazy list of terms.  
\end{abstract}

\section{Introduction}\label{Introduction:Sec}
Term rewriting modulo associativity and commutativity of some function symbols,
known as AC-rewri\-ting, is a key operation in many programming languages,
theorem provers and computer algebra systems. Examples of AC-symbols are  and
 for addition and multiplication in arithmetical expressions,  and
 for disjunction and conjunction in Boolean expressions, etc.
AC-rewriting performance mainly relies on that of its AC-matching algorithm. On
the one hand, the problem of deciding whether an AC-matching problem has a
solution is NP-complete \cite{Benanav:1985:CMP}. On the other hand, the number of
solutions to a given AC-matching problem can be exponential in the size of its
pattern. Thus many works propose optimizations for AC-matching. One can divide
optimized algorithms in two classes, depending on what they are designed for. In
the first class  some structural properties are imposed on the terms, and the
pattern falls into one of several forms for which efficient algorithms can be
designed. Examples are the depth-bounded patterns in the many-to-one matching
algorithm used by Elan~\cite{Kirchner:2001:Promoting:AC} and greedy matching
techniques adopted in Maude~\cite{MaudeBook07}. In the second class there is no
restriction on the structural properties of the terms. Algorithms in this class
are search-based, and use several techniques to collapse the search space, such
as constraint propagation on non linear variables \cite{gramlich-unif88},
recursive decomposition via bipartite graphs \cite{Bipartie-Eker95}, ordering
matching subproblems based on constraint propagation \cite{Fast-Eker96}
 and Diophantine techniques \cite{Single-Eker02}.
 

Formal semantics proposed so far for AC-rewriting enumerate all the possible
solutions of each matching problem. More precisely, the application modulo AC of
a rewrite rule  to a given term  usually proceeds in two steps.
Firstly, all the solutions (i.e. substitutions) , \ldots, 
() of the AC-matching problem whether the term  matches the pattern
 are computed and stored in a structure, say a set
. Secondly, this set is applied to  and the
result is the set . Other structures such
as multisets or lists can alternatively be used for other applications of the
calculus. Directly implementing this \emph{eager} semantics is clearly less
efficient than a lazy mechanism that only computes a first result of the
application of a rewrite rule and allows the computation by need of the remaining
results.  As far
as we know no work defines the AC-matching in a lazy way and integrates it in a
rewriting semantics.


Another motivation of this work lies in our involvement in the formulation of
the homogenization of partial derivative equations within a
 symbolic computation tool~\cite{EuroSim11,CFM11}.
For this purpose, we have designed and developed a rule-based language
 called \texttt{symbtrans} \cite{BGL-JSC10} for ``symbolic transformations''
 built on the computer algebra system Maple. Maple  pattern-matching procedures
 are not efficient and its rewriting kernel is very elementary. Besides, Maple
 is a strict language, it does not provide any laziness feature.
We plan to extend \texttt{symbtrans} with AC-matching.
 

In this paper we first specify a lazy AC-matching algorithm which computes
 the solutions of an AC-matching problem by need.
 Then we integrate the lazy AC-matching in a strategy
language. In other words we define a lazy semantics for rule and strategy
functional application. Our goal is to specify the lazy AC-matching and strategy
 semantics towards an implementation in a strict language, such as
Maple. We reach this goal by  representing  lazy lists by means of explicit
objects.
 


The paper is organized as follows. Section~\ref{Notations:Sec} introduces some
terminology and notations. Section~\ref{surj:sec} shows a connection between
AC-matching and surjective functions, used in the remainder of the paper.
Section~\ref{ac:match:sec} formally defines  a lazy semantics of AC-matching
(with rewrite rules). It states its main properties and shows how it differs
from an eager semantics.
Section~\ref{lazy:rewriting:sec} integrates the lazy AC-matching in the
operational semantics of a rule application on a term, first at top position,
and then at other positions, through classical traversal strategies.
Section~\ref{implem:sec} presents a prototypal implementation of lazy
AC-matching and some experimental results derived from it.
Section~\ref{conclusion:sec} concludes.


\section{Notation and preliminaries}
\label{Notations:Sec}
Let  denote the finite set of
positive integers  and let  denote the cardinality of
a finite set .  Thus, in particular, .

Familiarity with the usual first-order notions of signature, (ground) term,
arity, position and substitution is assumed. Let  be a countable set
of variables,  a countable set of function symbols, and
 the set of associative-commutative
function symbols. Let 
denote the set of terms built out of the symbols in  and the
variables in . Let  denote the set of substitutions
 with variables  in
 and terms  in . If  is a term
and  is a
 substitution then  denotes the term that results from the application
 of  to . Given a position , the subterm of  at position
  is denoted by . We shall write  for the
 symbol at the root of term , i.e. .

A term  in  is \emph{flat} if, for any
position  in ,  for some symbol  in
 implies that the root symbol  of each
direct subterm  () is not . We denote  by
 the number of AC-symbols in the term .

\paragraph{-Matching.}
For an equational theory  and any two terms  and   in
 we say that  matches  modulo  and write
 iff there exists a substitution  in
 s.t. . In this paper the theory
 is fixed. It is denoted  and axiomatizes the associativity and
commutativity of symbols in ,
i.e. it is the union of the sets of axioms 
when  ranges over .  


\paragraph{Rule-based semantics}
The following sections define the semantics of AC-matching, rule application and
strategy application by rewriting systems composed of labeled rewriting rules of
the form , where the rewrite relation
 should not be confused with the relation  of the rewriting
language. This semantics is said to be ``rule-based''.


\section{AC-matching and surjections}
\label{surj:sec}
Let  be some associative and commutative function
symbol. This section first relates a restriction of the pattern-matching problem
, where  ,
with the set  of surjective functions (\emph{surjections}, for short)
from  to .
Then a notation is provided  to replace surjections with their rank to simplify
the subsequent exposition.


\begin{definition}[Application of a surjection on a term]
\label{surj:arrang:def}
Let  be two positive integers,  be a term
 and  be a surjection from  to
 . The \emph{application of}
 \emph{on}  is defined by  where  if
 and  if  and   with 
.
\end{definition}

\begin{example}
\label{surj:appli:ex}
The application of the surjection  on the term , , ,  is
 .
\end{example}

The following proposition, whose proof is omitted, relates a subclass of
AC-matching problems with a set of surjections.
\begin{proposition}
\label{prop:matching:surj}
Let  and  be two flat terms with the same AC-symbol at the root and
containing no other AC-symbol than the one at the root. Let  (resp. ) be
the arity of the root of  (resp. ). Then the matching problem
 and the conjunction of matching problems  admit the same set of solutions.
\end{proposition}


For , an integer  in 
can be associated one-to-one to each surjection  in . It is called
the \emph{rank} of .  It will be used in the subsequent sections to iterate
over the set .
For each term  of arity , each , and each integer
 in , let  denote the surjection
with rank . The application of the integer  to the term , denoted by
, is defined by , where application of a
surjection to a term is defined by Def.~\ref{surj:arrang:def}.

\section{AC-matching}
\label{ac:match:sec}
This section defines an eager and a lazy semantics for pattern-matching modulo
associativity and commutativity. By ``eager'' we mean a rewriting system
specifying the computation of all the solutions to a given matching problem,
without any mechanism to delay the production of other solutions when a first one
is produced. The AC-matching execution steps are made explicit by introduction of
a syntactic representation of matching problems by matching constraints. They are
a generalization to AC-matching of the matching constraints defined e.g.
in~\cite{CFK07} for syntactic matching (i.e. for the empty theory). Both
semantics of AC-matching are given in terms of a conditional rewrite system on
these constraints. In what follows all the terms are assumed to be flat.

\subsection{Eager AC-matching}
Figure~\ref{Eager:Matching-AC} proposes a rule-based \emph{eager} semantics for
AC-matching. This system (named \textit{Eager}) reduces \emph{eager matching
constraints} inductively defined by the grammar .
This definition and the notations for matching constraints adapt and extend  the
ones from the -calculus with explicit matching~\cite{CFK07}. The
constraint \textbf{F} denotes
 an absence of solution (failure). The constraint \textbf{I} denotes the
 identity substitution resulting from an initial trivial matching problem. The
 expression  denotes the
elementary matching problem whether the term  matches the pattern  modulo
. The symbol  is the constructor of conjunctions of
 constraints. The symbol  is introduced to enumerate various solutions as
 lists of constraints. Its priority is lower than that of . Both are
 assumed associative. Then the notation  is used
 without ambiguity, and similarly for , for . The constraint
 \textbf{I} is a neutral element for . The constraint \textbf{F} is a
 neutral element for  and an absorbing element for .

 \begin{figure}[hbt!]
\setlength{\abovecaptionskip}{-0.2cm}
\setlength{\belowcaptionskip}{-0.1cm}

\caption{\textit{Eager} system of AC-matching rules \label{Eager:Matching-AC}}
\end{figure}

In Figure~\ref{Eager:Matching-AC}, the notation  stands for \textbf{I} if  and for  otherwise. The rule \texttt{E\_match\_AC}
corresponds to Proposition~\ref{prop:matching:surj} when , \ldots, ,
, \ldots,  contain no AC symbol, and generalizes it otherwise.  The
positive integer  iterates over surjection ranks. The rules \texttt{E\_match},
\texttt{E\_match\_fail}, \texttt{E\_fail\_gen}, and \texttt{E\_var\_clash} are
the same as in syntactic pattern-matching. With AC symbols, they are completed
with the rule \texttt{E\_match\_AC\_fail}. The rules \texttt{E\_DNF\_1} and
\texttt{E\_DNF\_2} correspond to the normalization of constraints into a
disjunctive normal form, DNF for short. A constraint is in DNF if it is of
the form , where  is a constraint not
containing  and .


It is standard to show that the system \textit{Eager} is terminating. The rules
\texttt{E\_DNF\_1} and \texttt{E\_DNF\_2} make it not confluent, but the
following post-processing reduces to a unique normal form all the irreducible
constraints it produces from a given pattern-matching problem. The
post-processing consists of \emph{(i)} replacing the trivial constraints of the
form  by \textbf{I}, \emph{(ii)} replacing each non-trivial
constraint  by the elementary substitution
 , \emph{(iii)} eliminating duplicated elementary substitutions by
 replacing each expression of the form  (with )
 by the set  that represents a
non-trivial substitution, then \emph{(iv)} replacing  by 
and finally \emph{(v)} replacing each disjunction  of
substitutions  with  by the set
, that represents a set of substitutions. A constraint in normal form can be either
\textbf{F}, if there is no solution to the initial matching problem, or a
non-empty set  of substitutions  which
corresponds to the set of all solutions of the matching problem. In particular
 may be , for some .


The theory for the associative symbols  and  deliberately excludes
commutativity, because they appear in the pattern of some rules of the
\textit{Eager} system. We now motivate  this design choice. 
Since the \textit{Eager} system  is terminating and confluent 
-- in the sense explained above -- we can consider
it  as an algorithm and implement it without
modification, in a programming language supporting pattern-matching modulo the
theory of constraint constructors. Thus it would be ill-founded to require that
the language supports AC-matching, in order to extend it precisely with an
AC-matching algorithm! In this aspect our approach differs from the one
of~\cite{rhoCalIGLP-I+II-2001}, whose more compact calculus handles ``result
sets'', i.e. the underlying theory includes associativity, commutativity and
idempotency, but matching with patterns
containing set constructors is implemented by explorations of set data
structures.
 

\subsection{Lazy AC-matching}
\label{ac:matching:sec}

We now define a lazy semantics for pattern-matching modulo associativity and
commutativity, as a rewriting system named \emph{Lazy}. It reduces constraints
defined as follows.


\begin{definition}
The set of \emph{delayed matching
constraints}, hereafter called \emph{constraints} for short, is inductively
defined by the grammar: 
\end{definition} 
The first five constructions have the same meaning as in eager matching
constraints. As in the eager case, the symbols  and  are
associative, the constraint \textbf{F} is an absorbing element for , and
the constraint \textbf{I} is a neutral element for  . However,  the
constraint \textbf{F} is no longer a neutral element for .
 The construction  serves to activate the delayed computations
 present in the constraint .
 When the terms  and  have the same AC symbol at the root, the constraint
  denotes
the delayed matching computations of the problem  starting with
the surjection 
with rank , and hence, the matching computations for all the
surjections 
with a rank  s.t.  have already been performed. The conditions
that  and  have the same AC symbol at the root and that the arities of 
and  correspond to the domain and codomain of 
the surjection with rank  are not made
explicit in the grammar, but it would be easy to check that they always hold by
inspecting the rules of the forthcoming system \emph{Lazy}.
Delayed matching constraints of the form  and satisfying these
conditions are more simply called \emph{triplets}.


Figure~\ref{Matching-AC} defines the first part of the lazy
semantics, a rewriting system named .
The rules \texttt{match\_AC\_fail}, \texttt{match},  \texttt{match\_fail}, 
 \texttt{var\_clash} and \texttt{fail\_gen} are standard and
already appeared  in the eager matching system.
The rule \texttt{match\_AC} activates the delayed matching computations starting from 
the first surjection. It is immediately followed by the rule
\texttt{match\_surj\_next} from the rewriting system  defined in
Figure~\ref{Next}.
 

\begin{figure}[htb!]

\caption{ system: AC-matching rules \label{Matching-AC}}
\end{figure}


\begin{figure}[hbt!]

\caption{ system: \textit{Next} rules \label{Next}}
\end{figure}
In  the rule \texttt{fail\_next} states that the presence of a
failure activates the delayed computations in the constraint . The other rules
propagate the activation of the delayed computations on the inductive structure
of constraints. The rule \texttt{next\_and}
 propagates the \textit{Next} constructor to sub-constraints. The rule
 \texttt{next\_or} propagates the  constructor to the
 head of a list of constraints, provided this head is not \textbf{F}.

When the constraint is , two cases have to be considered.  If the
surjection rank  is not the maximal one, then the rule
\texttt{match\_surj\_next} reduces the constraint
 to a set of matching constraints according to
the surjection with rank ,
 followed by  delayed computations that will
be activated from the next surjection, with rank .
In the final case when  (rule \texttt{match\_surj\_last}), there is
no delayed computations.
 
\begin{figure}[hbt!]

\caption{ system : DNF  rules \label{Simplify}}
\end{figure}

Rules for the reduction of constraints in DNF are the same as in the eager
system, but are defined in the separate rewrite system  given in
Figure~\ref{Simplify}.


Let us denote by  the
rewriting system  composed of the 
 rules of Figures~\ref{Matching-AC}, \ref{Next} and
 \ref{Simplify}, equipped with the evaluation strategy \emph{sat} that consists of 
the iteration of the following process:
\emph{(i)} Applying the rules of  until no
rule is applicable, then \emph{(ii)} applying the rules of 
until no rule is applicable.



\subsection{Termination of lazy AC-matching}
We prove the termination of the lazy AC-matching system 
modularly, by considering some of its sub-systems separately, in the following lemmas. 

\begin{lemma}\label{R2:termination:lemma}
The rewriting system  is terminating.
\end{lemma}
\begin{proof}
On the one hand, no rule in  produces the \textbf{F}
constraint. Thus, after replacing with  the occurrences of
 in the input constraint, the rule \texttt{fail\_next} is no longer used.
On the other hand, no rule in  can reduce the right side of the
rules \texttt{match\_surj\_next} and \texttt{match\_surj\_last}. 
Thus it is sufficient to prove the termination of 
, ,
 , , .
This is standard, using a recursive path ordering~\cite{Dersh_Ordering82}.
Intuitively, the termination of  is ensured by the fact that all the rules
in  push the  constructor down until reaching the leaves. 
\end{proof}

 Before proving the termination of
, we need to introduce a variant of
terms and triplets to prove a technical lemma about their occurrences in
derivations.
The \emph{marked term}  associated to the term  is obtained from  by
replacing each AC symbol  at some position  in  with . 
The
\emph{marked triplet} associated to the triplet  is defined to be
. The \emph{marked constraint} associated to the
constraint  is .
The \emph{marked variant}  (resp.
, ) of the  (resp.
, \textit{Lazy}) system is obtained from the latter by
replacing triplets with marked triplets, constraints with marked constraints and
 by  for any , in the pattern  of the rules
\texttt{match\_AC} and \texttt{match\_AC\_fail}. It is clear, and thus admitted,
that the derivations of  are the variants of the derivations
of , in a natural sense. 

 
\begin{lemma}\label{bounded:triplet:lemma}
Let  be a marked term with an AC symbol at the root and  be a term with
the same AC symbol at the root. Consider a derivation  with rules in . Then, the
 number of marked triplets in the sequence  is strongly bounded,
 in the following sense:
\emph{(i)} There is an upper bound for the number of marked triplets in each
 and \emph{(ii)} for each subterm  of  with an AC symbol at the root,
if a marked triplet built up on the marked subterm  (i.e. of the form
 for some  and ) is deleted from some  then
it never appears again in , for all .
\end{lemma}

\begin{proof}
(i) The variant of the rule \texttt{match\_AC} replaces an elementary matching
problem (between two terms with an AC symbol at the root) with a marked triplet.
It is the only rule of  that produces a
marked triplet whose first (marked) term is new. Then the variant of the rule
\texttt{match\_surj\_next} replaces a marked triplet whose first (marked) term is
the subterm  of  at some position  with a marked
triplet on the same terms, whose surjection rank is incremented. Thus
the number of marked triplets in a constraint is bounded above by the number of
positions of AC symbols in .

(ii) The only rule of  that deletes a
marked triplet whose first (marked) term is  is the variant of
\texttt{match\_surj\_last}. This marked triplet never appears again because the
variant of the rule \texttt{match\_surj\_next} just increments the surjection
rank of remaining triplets, whose first marked term  is another subterm of
, located at another position in  ( at least differs from  by the
name of its root symbol), and the other rules of  neither create new marked triplets nor duplicate existing
ones.
\end{proof}

\begin{lemma}\label{R12:termination:lemma}
The rewriting system  is terminating.
\end{lemma}

\begin{proof}
Notice that  is clearly
terminating since it is a subsytem of the eager one, which is known
to be terminating.  We deduce that  is terminating since no
rule in  reduces the right side of the rule 
\texttt{match\_AC}.
Since  and  are terminating, it remains to show
that there is no infinite  reduction that goes back and forth between
 and . Toward a contradiction, assume that there is
an infinite reduction  that goes back
and forth between  and , where 
 is a pattern-matching problem. In  the rule \texttt{match\_surj\_next}
is the only rule producing new redexes for the system , i.e.
pattern-matching problems. Then the rule \texttt{match\_surj\_next} should
appear infinitely often in this infinite reduction. Equivalently, we consider
the marked variant of this derivation, with the same notations. Since the
number of marked triplets in the sequence  is strongly bounded (by
Lemma~\ref{bounded:triplet:lemma}) there is a marked triplet  and
an infinite sub-sequence  of  such that
 and  for each .
This is a contradiction since the rank of surjections is upper bounded.
\end{proof}

\begin{theorem}
The  system  is terminating.
\label{termination:theorem}
\end{theorem}

\begin{proof}
On the one hand, the termination of   is proved
in Lemma \ref{R12:termination:lemma}. On the other hand, it is standard to show
that  the system   is terminating. It corresponds to the
normalization w.r.t. to the disjunctive normal  form. Therefore, it is sufficient
to  show  that there is no infinite  reduction that goes back and forth between
the saturation of  and the saturation of
. Let  be a reduction in
. Notice that each , where  is even, is of the form 
where  and each  is either a triplet or the
matching problem of a term with a variable. If there is no new redex
in  then the reduction   stops. Otherwise, by observing the right side of the rules of , we claim that if there is a new redex in  -- which is
 created by the system  -- then this redex is  necessarily of the form
 with , producing
 the \textbf{F} constraint. Let  be the smallest integer such that
 such a redex appears in . If  then  is reduced to
  and the reduction 
 terminates. Otherwise, 


The rules of   push the  constructor down, and all
the  constraints of the form   in  are
reduced to  by the rule \texttt{match\_surj\_next}, if
. To prove that the reduction
 terminates it is sufficient to prove that the system
 is
terminating, with the following rule definitions:

However the termination of  is ensured by the termination of  
the eager system. That is, we have just replaced the rule \texttt{E\_match\_AC}
of \textit{Eager} with the rules \texttt{match\_AC\_2} and
\texttt{always\_next} in .
\end{proof}

\subsection{Confluence of lazy AC-matching}
\label{confluence:sec}
The system \textit{Lazy} is not confluent, due to the non-confluence of
. In this section we argue that the system  is confluent, and we consider an evaluation strategy
for  to  get a confluent AC-lazy matching system, that we call \lazy.

\begin{proposition}
The system  is locally confluent.
\end{proposition}
\begin{proof}
It is straightforward to check that there is no critical  overlap between 
 any two redexes, i.e. the contraction of one redex does not destroy the others. 
It is worth mentioning that without the  condition  
  of the rule \texttt{next\_or} 
we could have non-convergent critical pairs, e.g.
 by the rule 
\texttt{fail\_next} and  
   
   .
\end{proof}

\begin{corollary}
The system 
is confluent. 
\end{corollary}

 The reason of the non-confluence of 
  is the non-commutativity 
of the operators  and .
It is classical to add a strategy to 
so that the resulting system becomes confluent.
\begin{definition}
Let   be the system  
 with the following strategy: 
\textit{(i)} When reducing a constraint of the 
form  with , first reduce
 , and 
\textit{(ii)}  reduce 
  to 
.
\end{definition}
\begin{proposition}(Admitted)
 is  confluent.
\end{proposition}
Now we are ready to define the lazy AC-matching.
\begin{definition}
\label{ac:conf:lazy:def}
The \emph{lazy AC-matching}, denoted by \lazy, is the
rewriting system  composed of the 
 rules of Figures~\ref{Matching-AC}, \ref{Next} and
 \ref{Simplify}, equipped with the evaluation strategy  
that consists of the iteration of the following process:
\emph{(i)} Applying the rules of  until no
rule is applicable, then \emph{(ii)} applying   
until no rule  is applicable.
\end{definition}

\begin{theorem}
\label{lazy:term:conf:th}
 \lazy is terminating  and confluent.
\end{theorem}
\begin{proof}
The termination of \lazy is a consequence of the one of \textit{Lazy}. The 
confluence of \lazy follows from the  confluence of  and .
\end{proof}

In what follows the normal form of a constraint  w.r.t. 
a system   will be denoted by , or just
 if  is \lazy.

\subsection{Normal forms and lazy lists}
\label{NF:subsec}
In this section we prove Theorem~\ref{NF:theorem} that characterizes  the normal forms
of the lazy AC-matching \lazy. They correspond basically to lazy lists. 
Roughly speaking, a lazy list is composed of a  substitution at the head
 and  a non-evaluated  object that represents the remaining substitutions.  
This characterization of the normal forms is of major importance since 
it guarantees   that  the  element at the head  is always a substitution. 
The formal definition of lazy lists follows.

\begin{definition}
\label{wfll:def}
A \emph{-substitution} is a conjunction of delayed matching constraints of
the form  where  is a variable. A -substitution is
\emph{irreducible} if it cannot be reduced by the rule \texttt{\emph{fail\_gen}}. A
constraint is called a \emph{lazy list} if it is \textbf{F}, \textbf{I}, an
irreducible -substitution or a constraint of the form 
where  is an irreducible -substitution and  
 is also a lazy list.
\end{definition}

In order to characterize the normal forms of \lazy we first characterize in Lemma
\ref{R12:NF:lemma} the normal forms  of the system . Then we characterize in Lemma
 \ref{R123:NF:lemma} the normal forms of 
when it has  the normal forms of  as input. Summing up these results,
we show in
 Proposition \ref{inviariance:FN:prop}
the invariance of the syntax of constraints after the composition of the
application of  and of . Finally, Theorem \ref{NF:theorem}
becomes an immediate consequence of Proposition \ref{inviariance:FN:prop}.

Let us begin by characterizing the normal forms of  and introduce for
this purpose the grammar .


\begin{lemma}
\label{R12:NF:lemma}
The normal form of an AC-matching problem by the system  is either \textbf{F} or follows the  grammar .
\end{lemma}
\begin{proof}
Let   be an AC-matching problem. When
,
 the normal form of the AC-matching problem is , since no
 rule rewrites . The other cases when  or  is a variable
 are also trivial: The matching problem is reduced to \textbf{I} or is irreducible.
 
It remains to consider the case when  and
 for some .
The proof is by induction on the number of symbols in .
If  is a constant, i.e. , then  and . The AC-matching
problem  is reduced to \textbf{I}, thus follows the  grammar
.
Otherwise, . Only one rule can be applied, \texttt{match\_AC} or
\texttt{match}, depending on the nature of the symbol  at the root of .

\noindent \emph{Case 1.} If  is an AC symbol, then  and
. We
prove more generally that the normal form of  by
  is \textbf{F} or follows the grammar
.  Let  and .

If , then . Otherwise, when
, .
In both cases, since each  contains less symbols than , the induction
hypothesis holds for each , and hence the normal form  of  is \textbf{F} or a constraint
which follows the grammar , since \textbf{F} is an absorbing element
for .

For this case the remainder of the proof is by induction on . The
basic case when  has already been treated. When ,
there are two cases. If  follows the grammar  then it obviously
also holds for . Otherwise,  is \textbf{F}
and .
Since , the  induction hypothesis gives that
 is \textbf{F} or follows the grammar
, hence also for .

\noindent \emph{Case 2.}
If  is not an AC symbol, then  and 
 
 .
By induction hypothesis, for each ,  is 
\textbf{F} or follows the grammar . If
 for some , then
, since \textbf{F} is an
absorbing element for . Otherwise,  follows
 for each , and then it
obviously  also holds for their conjunction, and for .
\end{proof}

\begin{lemma}
\label{stabl1:lemma}
Let  be an irreducible constraint w.r.t. 
 that follows  the grammar . Then, the normal form
of  by  is .
\end{lemma}

\begin{proof}
The proof is by induction on the grammar constructions of .
If  is \textbf{I} or a matching problem of the
form   where  is a variable, then the rules
\texttt{next\_id} and \texttt{next\_basic} ensure that .  If  then  and the induction hypothesis 
  
and  apply to show that
. 
If ,
then .
\end{proof}

We can generalize the previous lemma by the following one.
\begin{lemma}
\label{stabl2:lemma}
Let  be a constraint of the form , where each 
 is either a triplet or follows 
the grammar , such that  is irreducible w.r.t.  
.
Then, the normal form of  by 
is \textbf{F} or follows the  grammar .
\end{lemma}
\begin{proof}
By iterating application of the rule \texttt{next\_and} we get
.
 is irreducible w.r.t.   because  is
irreducible. If  follows the grammar , then
 by Lemma \ref{stabl1:lemma}. If  is a triplet  
then  by  Lemma \ref{R12:NF:lemma} the normal form of 
is \textbf{F} or follows . Therefore, the normal form of
  is \textbf{F} or follows  the  grammar
 .
\end{proof}

We define the grammar  for conjunctions of atomic constraints,
the grammar  for
constraints in DNF, the grammar  for -substitutions,
and the grammar  to formulate the following two lemmas. The first one is
about normal forms by  of inputs which are normal forms of .

\begin{lemma}
\label{R123:NF:lemma}
Let  be an irreducible  constraint w.r.t. 
 that follows  the grammar . Then, the normal form of  by the system
  follows the grammar .
\end{lemma}
\begin{proof}
On the one hand, since  follows the grammar , it is built
up on , , \textbf{I}, matching constraints of the form
 and triplets. On the other hand, the normal form of  by
  is in DNF. Therefore it is sufficient to show that
 is either \textbf{I} or of the
form , where  is either a -substitution or
\textbf{I}, and  follows  . The  proof is by   induction on the
grammar constructions of . If   is  or 
then the claim holds.
Otherwise, we distinguish two cases:

\noindent \emph{Case 1.} If   , then we only discuss the
non-trivial case when  or  is of the form .
Assume that  , the  other case
can be handled similarly.
In this case  can be \textbf{I},  or .
If  then 
. 
If , then 
. 
Finally, if , then  and the claim holds.

\noindent \emph{Case 2.} If , then  we apply the
induction hypothesis on , and the desired result follows. 
\end{proof}

The following lemma describes the syntax of the result of
 by the application of 
followed by the application of , when  is an irreducible
constraint in DNF.

\begin{lemma}
\label{invariance:next:lemma}
Let   
be an irreducible constraint
w.r.t.  that follows the grammar .
Then   
is either \textbf{F} or follows the grammar .
\end{lemma}
\begin{proof}
The proof is by induction on . If  then by Lemma \ref{stabl2:lemma}
 is \textbf{F} or
follows  . Therefore  is 
\textbf{F}, or  follows   by Lemma \ref{R123:NF:lemma}. If 
then .
 By  Lemma \ref{stabl2:lemma} again 

  is \textbf{F} or follows . 
  
  In the first case, we apply
  , and use the
  induction hypothesis that  follows .  In the second case, it
comes from Lemma \ref{R123:NF:lemma} that
 
follows . Hence  follows , since
 follows .
\end{proof}

Now we are ready to prove the following invariance proposition. It generalizes
the previous lemma by considering an arbitrary constraint following the grammar
.

\begin{proposition}(Invariance proposition)
\label{inviariance:FN:prop}
Let  be a constraint following the grammar .
  Then 
  		\linebreak
   is \textbf{F} or follows the grammar 
.
\end{proposition}
\begin{proof}
The case when  is a -substitution or \textbf{I} is trivial.
Otherwise, let , where  is \textbf{I} or a
-substitution and  follows  .
Notice that the only potential redexes in   w.r.t. 
the system  are of the form
 such that 
. In this case the rule \texttt{fail\_gen} is
applied. Let us call such redexes \emph{failure redexes.}
We  distinguish two cases. 

\noindent \textit{Case 1.} If there is no 
 failure redex in  (i.e.  is irreducible w.r.t. ) 
then we again distinguish two cases. 
If there is no failure redex in , then we are done.
Otherwise, 
,
and the result follows from Lemma \ref{invariance:next:lemma}.

\noindent \textit{Case 2.} If there are some failure redexes in  then assume
that , and let . Let us argue  that
  is either \textbf{F} or of the form  where either  or  for some . We propose an algorithm to construct
. Let  initially. (a) If , the expected form for
 is obtained with the current . Otherwise, if , let
 be the smallest integer in  such that  contains a failure redex.
Therefore we have .
Continue the elimination of the failure redexes in  by
iterating (a) with  instead of . Let  by the
resulting disjunction. If , then
let . Otherwise, if
, then let
 and continue the reduction on
 . 

Since   or , where ,
then  
\begin{enumerate}
  \item[(i)] 
  either follows  or
 follows  by   Lemma \ref{R123:NF:lemma}. 
Therefore,  is either 
\textbf{F} or follows  and  is either \textbf{F} or follows the grammar 
. 
\item[(ii)] In order to simplify the computations,  
let   and consider the renaming 
. 
We argue by induction on  that 
 
is either \textbf{F} or follows . 
If , then by Lemma \ref{stabl2:lemma} it follows that 
 is either \textbf{F} or 
 follows  and therefore, by Lemma \ref{R123:NF:lemma},
we have that  is either 
\textbf{F} or follows .
If , then 
.
If , then we apply the induction 
hypothesis to 
. Otherwise,
 follows , and hence 
 follows . On the other 
hand,  follows ,
by (i). Summing up, we get that  follows .
\end{enumerate}

Now we distinguish two cases for .  If there is no failure redex in
, then by (i) we get that 
is either a -substitution or follows . 
Otherwise, if there are some failure redexes in , then
 we get . From (ii)
it follows that  is  \textbf{F}
or follows .
 \end{proof}

\begin{theorem}
\label{NF:theorem}
The normal form of a pattern-matching constraint  by the system 
 \lazy  is a lazy list.
\end{theorem}
\begin{proof}
From  the termination of \lazy (Theorem~\ref{lazy:term:conf:th}) and
Proposition~\ref{inviariance:FN:prop}, we deduce that the normal form of \lazy is
either \textbf{F} or  follows the grammar  and does not contain any
failure redex. Such a normal form is of the form  or ,
where  is either \textbf{I} or an irreducible -substitution.
Therefore, it remains to show that  is a lazy list,
or, equivalently, that  follows .
But this holds by Lemma \ref{invariance:next:lemma}.
\end{proof}


\section{Lazy AC-rewriting with strategies}
\label{lazy:rewriting:sec}

In this section we integrate lazy AC-matching with strategy application.   
More details on strategy languages can be found in 
\cite{BKKR-IJFCS-2001,Vis01-rta,Marti-OlietMV05}.

 
Primitive strategies are rewrite rules  and the
\textsf{id} and \textsf{fail} strategies that respectively always and
never succeed. They are completed with the most
usual reduction strategies, namely the four traversal strategies
\textit{leftmost-outermost}, \textit{leftmost-innermost},
\textit{parallel-outermost} and \textit{parallel-innermost}~\cite[Definition
4.9.5]{Terese03} that control a rewrite system by selecting redexes according to
their position. For sake of simplicity we restrict their control to a single
rewrite rule. Let  be one of these four strategies. The application of  to
the rewrite rule  is denoted by . 
The sequential composition of two strategies  and  is denoted by .
The application of a strategy  to a term  is denoted by .



A strategy application produces a lazy list of terms, defined by the grammar
   
  .
 A list is usually defined by a constructor for an empty list and a constructor
adding one element at the head of another list. Then concatenation of two
lists is defined, with another notation. Here we equivalently introduce an
associative symbol  for concatenation of two lists of terms, and a symbol
 to denote an empty list of terms, which is a neutral
element for . We use the same conventions as for  in
Section~\ref{ac:match:sec}. Let  denote the set of lazy
lists of terms.

\begin{figure}[bht!]
\setlength{\abovecaptionskip}{-0.3cm}

\subfigure[\textsf{id}, \textsf{fail} and composition rules]{ 

 \label{primitive:tab}
}

\subfigure[Top rewriting]{

 \label{AC-rewriting:top}
}
\caption{AC-rewriting operational semantics}
\end{figure}


The operational semantics of the strategies \textsf{id} and \textsf{fail} and of
strategy composition are defined in Figure~\ref{primitive:tab} for any lazy list
of terms  and any two strategies  and . The operational semantics of
top rewriting is defined in Figure~\ref{AC-rewriting:top}. Let \texttt{LTR} be
the system composed of these five rules and the \lazy AC-matching. The rules
\texttt{rule1} and \texttt{rule2} reduce the application of a rewrite rule at the top of terms in a lazy list of
terms. In \texttt{rule2} the expression  is reduced to its
normal form by \lazy. The result is a lazy list of constraints.
 The rules
\texttt{subs\_fail}, \texttt{subs\_id} and \texttt{subs} reduce the application
of a lazy list of constraints on a term. In the right side of rule
\texttt{subs},  a -substitution  is applied to a term, in a
sense which is a simple extension of the standard definition of substitution
application. Equivalently -substitutions can be reduced to standard ones
by a transformation similar to the post-processing  defined for the eager
AC-matching.

 The application of the system
\texttt{LTR} to the expression  produces either
 or a non-empty lazy list of terms ,
where  is the first result of the application of the rewrite rule  at the top of the
term  and  is (a syntactic object denoting) the lazy list of the
other results. When applying on  the rewrite system defined in
Figure~\ref{Next:term},
 and then the system \texttt{LTR}, we get again
either  or a non-empty lazy list , where  is
the second result of the application of the rewrite rule  at the top of the
term  and  is again (a syntactic object denoting) a lazy list of
terms that represents the remaining results, and so on. 

\begin{figure}[hbt!]

\caption{\textit{Next} rules for lists of terms\label{Next:term}}
\end{figure}

The application of a traversal strategy on a lazy list of terms in
 is defined as follows:

 The rules

define the application of the traversal strategy  on the term  for the
rewrite rule  and the \textit{parallel-outermost} strategy constructor . 
The other traversal strategies can be handled similarly. We have seen that the
application of a rewrite rule at the top of a term yields a lazy list of terms in
. Here the application of a rule to a term at arbitrary
depth, via a traversal strategy, yields a \emph{decorated} term, which is a term
where some subterms are replaced by a lazy list of terms. This lazy list of
terms is abusively called a \emph{lazy subterm}, with the property that lazy
subterms are not nested. In other words, the positions of two lazy subterms are not comparable, for the
standard prefix partial order over the set of term positions. The operator 
is assumed to reduce a decorated term to a lazy list of terms. We
summarize its behavior as follows. A decorated term can be encoded by a
tuple  where  is the term before strategy application,  is the number of
decorated positions,  is a function from  to the domain of
 (i.e. its set of positions) which defines the decorated positions, such that
 and  are not comparable if , and  is the function
from  to  such that  is the
lazy list at position , . It is easy to construct an
iterator over the -tuples of positive integers (for instance in
lexicographical order), and to derive from it an iterator over tuples of terms
 with  in the list  for .
From this iterator and function  we derive an iterator producing the lazy
list  by replacing each subterm  by .





\section{Implementation and experiments}
\label{implem:sec}
We present here a prototypal implementation of lazy AC-matching and report about
its experimentation. Our implementation  is  a straightforward
translation of the \lazy system in the rule-based language
\texttt{symbtrans} \cite{BGL-JSC10} built on the computer algebra system Maple.

This prototype obviously does not claim
 efficiency in the usual sense of the number of solutions computed in a given
amount of time. But this section shows that our prototype optimises the standard
deviation of the time between two successive solutions. This performance
criterion corresponds to our initial motivations and can be measured on the
prototype. We consider the matching problem
, for 18 variables ,
\ldots,  and 18 constants , \ldots, . On this problem our
lazy prototype provides any two consecutive solutions in an average time of
 seconds, with a standard deviation of  seconds between the 100-th
first solutions. In comparison the computation time between two consecutive
solutions with the Maude function \texttt{metaXmatch} grows exponentially.
The experiment is done on an Intel core 2 Duo T6600@2.2GHz with 3.4Gb of
memory, under a x86\_64 Ubuntu Linux. 




Finally, it is worth mentioning the performance of the Maple standard matching
procedure \texttt{pat\-match(expr, pattern,'s')} that returns true if it is able
to match \texttt{expr} to \texttt{pattern}, and false otherwise. If the matching
is successful, then \texttt{s} is assigned a substitution such that .
This procedure runs out of memory if the arity of the AC symbols is large.
With Maple 14 this failure can be observed  when computing a solution of the
matching problem .


\section{Conclusion}
\label{conclusion:sec}
We presented a lazy AC-matching algorithm and a lazy evaluation semantics for
AC-rewriting and some basic strategies. The semantics is designed to be
implemented in a strict language by representing delayed matching
constraints and lazy lists of terms by explicit objects. We also described a
common principle for lazy traversal strategies. The potential benefits are
clear: performances are dramatically increased by avoiding unnecessary
computations. We are working on an implementation of lazy AC-matching and
AC-rewriting: first results show that our approach is  efficient when the arity
of AC symbols is high and when the number of solutions of the AC-matching
problem is large. However, we do not claim efficiency for the search of the
first solution by the AC-matching algorithm.


Here no neutral element is assumed for AC symbols. As a consequence the lazy
AC-matching relies on a surjection iterator. We plan to address the question of
its efficiency, and to extend the present work to AC symbols with a neutral
element. Our intuition is that our approach can easily be adapted to that
case.

\bibliographystyle{eptcs}


\begin{thebibliography}{10}
\providecommand{\bibitemdeclare}[2]{}
\providecommand{\urlprefix}{Available at }
\providecommand{\url}[1]{\texttt{#1}}
\providecommand{\href}[2]{\texttt{#2}}
\providecommand{\urlalt}[2]{\href{#1}{#2}}
\providecommand{\doi}[1]{doi:\urlalt{http://dx.doi.org/#1}{#1}}
\providecommand{\bibinfo}[2]{#2}

\bibitemdeclare{unpublished}{BGL-JSC10}
\bibitem{BGL-JSC10}
\bibinfo{author}{W.~Belkhir}, \bibinfo{author}{A.~Giorgetti} \&
  \bibinfo{author}{M.~Lenczner} (\bibinfo{year}{December 2010}):
  \emph{\bibinfo{title}{Rewriting and Symbolic Transformations for Multi-scale
  Methods}}.
\newblock \bibinfo{note}{Url: http://arxiv.org/abs/1101.3218v1. Submitted.}

\bibitemdeclare{inproceedings}{Benanav:1985:CMP}
\bibitem{Benanav:1985:CMP}
\bibinfo{author}{D.~Benanav}, \bibinfo{author}{D.~Kapur} \&
  \bibinfo{author}{P.~Narendran} (\bibinfo{year}{1985}):
  \emph{\bibinfo{title}{Complexity of matching problems}}.
\newblock In: {\sl \bibinfo{booktitle}{Proc. of the 1st Int. Conf. on Rewriting
  Techniques and Applications}}, {\sl \bibinfo{series}{LNCS}}
  \bibinfo{volume}{202}, \bibinfo{publisher}{Springer}, pp.
  \bibinfo{pages}{417--429}.
 \doi{10.1007/3-540-15976-2\_22}.  

\bibitemdeclare{article}{BKKR-IJFCS-2001}
\bibitem{BKKR-IJFCS-2001}
\bibinfo{author}{P.~Borovansk\'y}, \bibinfo{author}{C.~Kirchner},
  \bibinfo{author}{H.~Kirchner} \& \bibinfo{author}{C.~Ringeissen}
  (\bibinfo{year}{2001}): \emph{\bibinfo{title}{Rewriting with strategies in
  {{\sf ELAN}}: a functional semantics}}.
\newblock {\sl \bibinfo{journal}{{International Journal of Foundations of
  Computer Science}}} \bibinfo{volume}{12}(\bibinfo{number}{1}), pp.
  \bibinfo{pages}{69--98}. \doi{10.1142/S0129054101000412}.

\bibitemdeclare{article}{CFK07}
\bibitem{CFK07}
\bibinfo{author}{H.~Cirstea}, \bibinfo{author}{G.~Faure} \&
  \bibinfo{author}{C.~Kirchner} (\bibinfo{year}{2007}): \emph{\bibinfo{title}{A
  -calculus of explicit constraint application}}.
\newblock {\sl \bibinfo{journal}{Higher-Order and Symbolic Computation}}
  \bibinfo{volume}{20}, pp. \bibinfo{pages}{37--72}.
  \doi{10.1007/s10990-007-9004-2}.

\bibitemdeclare{article}{rhoCalIGLP-I+II-2001}
\bibitem{rhoCalIGLP-I+II-2001}
\bibinfo{author}{H.~Cirstea} \& \bibinfo{author}{C.~Kirchner}
  (\bibinfo{year}{2001}): \emph{\bibinfo{title}{The rewriting calculus ---
  {Part~I {\em and} II}}}.
\newblock {\sl \bibinfo{journal}{Logic Journal of the Interest Group in Pure
  and Applied Logics}} \bibinfo{volume}{9}(\bibinfo{number}{3}), pp.
  \bibinfo{pages}{427--498}.

\bibitemdeclare{proceedings}{MaudeBook07}
\bibitem{MaudeBook07}
\bibinfo{editor}{M.~Clavel}, \bibinfo{editor}{F.~Dur{\'a}n},
  \bibinfo{editor}{S.~Eker}, \bibinfo{editor}{P.~Lincoln},
  \bibinfo{editor}{N.~Mart\'{\i}-Oliet}, \bibinfo{editor}{J.~Meseguer} \&
  \bibinfo{editor}{C.~L. Talcott}, editors (\bibinfo{year}{2007}):
  \emph{\bibinfo{title}{All About Maude - A High-Performance Logical Framework,
  How to Specify, Program and Verify Systems in Rewriting Logic}}. {\sl
  \bibinfo{series}{LNCS}} \bibinfo{volume}{4350},
  \bibinfo{publisher}{Springer}.

\bibitemdeclare{article}{Dersh_Ordering82}
\bibitem{Dersh_Ordering82}
\bibinfo{author}{N.~Dershowitz} (\bibinfo{year}{1982}):
  \emph{\bibinfo{title}{Ordering for Term-Rewriting Systems}}.
\newblock {\sl \bibinfo{journal}{Theoretical Computer Science}}
  \bibinfo{volume}{17}, pp. \bibinfo{pages}{279--300}.
  \doi{10.1016/0304-3975(82)90026-3}.

\bibitemdeclare{article}{Bipartie-Eker95}
\bibitem{Bipartie-Eker95}
\bibinfo{author}{S.~Eker} (\bibinfo{year}{1995}):
  \emph{\bibinfo{title}{AC-Matching Via Bipartite Graph Matching}}.
\newblock {\sl \bibinfo{journal}{Comput. J.}}
  \bibinfo{volume}{38}(\bibinfo{number}{5}), pp. \bibinfo{pages}{381--399}.
\doi{10.1093/comjnl/38.5.381}.

\bibitemdeclare{article}{Fast-Eker96}
\bibitem{Fast-Eker96}
\bibinfo{author}{S.~Eker} (\bibinfo{year}{1996}): \emph{\bibinfo{title}{Fast
  matching in combinations of regular equational theories}}.
\newblock {\sl \bibinfo{journal}{ENTCS}} \bibinfo{volume}{4}, pp.
  \bibinfo{pages}{90--109}.

\bibitemdeclare{article}{Single-Eker02}
\bibitem{Single-Eker02}
\bibinfo{author}{S.~Eker} (\bibinfo{year}{2002}): \emph{\bibinfo{title}{Single
  Elementary AC-Matching}}.
\newblock {\sl \bibinfo{journal}{J. Autom. Reasoning}}
  \bibinfo{volume}{28}(\bibinfo{number}{1}), pp. \bibinfo{pages}{35--51}.
 \doi{10.1023/A:1020122610698}.
 
\bibitemdeclare{inproceedings}{gramlich-unif88}
\bibitem{gramlich-unif88}
\bibinfo{author}{B.~Gramlich} (\bibinfo{year}{1988}):
  \emph{\bibinfo{title}{Efficient {AC}-Matching using Constraint Propagation}}.
\newblock In: {\sl \bibinfo{booktitle}{Proc.\ 2nd Int.\ Workshop on
  Unification, Internal Report 89 R 38, CRIN}}, \bibinfo{address}{Val d'Ajol,
  France}.

\bibitemdeclare{article}{Kirchner:2001:Promoting:AC}
\bibitem{Kirchner:2001:Promoting:AC}
\bibinfo{author}{H.~Kirchner} \& \bibinfo{author}{P.-E. Moreau}
  (\bibinfo{year}{2001}): \emph{\bibinfo{title}{Promoting rewriting to a
  programming language: a compiler for non-deterministic rewrite programs in
  {AC}-theories}}.
\newblock {\sl \bibinfo{journal}{J. Funct. Program.}} \bibinfo{volume}{11}, pp.
  \bibinfo{pages}{207--251}.

\bibitemdeclare{article}{Marti-OlietMV05}
\bibitem{Marti-OlietMV05}
\bibinfo{author}{N.~Mart\'{\i}-Oliet}, \bibinfo{author}{J.~Meseguer} \&
  \bibinfo{author}{A.~Verdejo} (\bibinfo{year}{2005}):
  \emph{\bibinfo{title}{Towards a Strategy Language for {Maude}}}.
\newblock {\sl \bibinfo{journal}{Electr. Notes Theor. Comput. Sci.}}
  \bibinfo{volume}{117}, pp. \bibinfo{pages}{417--441}.
\doi{10.1016/j.entcs.2004.06.020}.

\bibitemdeclare{book}{Terese03}
\bibitem{Terese03}
\bibinfo{author}{Terese} (\bibinfo{year}{2003}): \emph{\bibinfo{title}{Term
  Rewriting Systems}}.
\newblock {\sl \bibinfo{series}{Cambridge Tracts in Theor. Comp.
  Sci.}}~\bibinfo{volume}{55}, \bibinfo{publisher}{Cambridge Univ. Press}.

\bibitemdeclare{inproceedings}{Vis01-rta}
\bibitem{Vis01-rta}
\bibinfo{author}{E.~Visser} (\bibinfo{year}{2001}):
  \emph{\bibinfo{title}{Stratego: {A} Language for Program Transformation based
  on Rewriting Strategies. {S}ystem Description of {Stratego} 0.5}}.
\newblock In: {\sl \bibinfo{booktitle}{Proc. of RTA'01}}, {\sl
  \bibinfo{series}{Lecture Notes in Computer Science}} \bibinfo{volume}{2051},
  \bibinfo{publisher}{Springer-Verlag}, pp. \bibinfo{pages}{357--361}.
 \doi{10.1007/3-540-45127-7\_27}.
 
\bibitemdeclare{inproceedings}{EuroSim11}
\bibitem{EuroSim11}
\bibinfo{author}{B.~Yang}, \bibinfo{author}{W.~Belkhir}, \bibinfo{author}{R.N.
  Dhara}, \bibinfo{author}{M.~Lenczner} \& \bibinfo{author}{A.~Giorgetti}
  (\bibinfo{year}{2011}): \emph{\bibinfo{title}{Computer--Aided Multiscale
  Model Derivation for {MEMS} Arrays}}.
\newblock In: {\sl \bibinfo{booktitle}{{EuroSimE 2011, 13-th Int. Conf. on
  Thermal, Mechanical and Multi-Physics Simulation and Experiments in
  Microelectronics and Microsystems}}}, \bibinfo{publisher}{IEEE Computer
  Society}, \bibinfo{address}{Linz, Austria}.
\newblock \bibinfo{note}{6 pages}. \doi{10.1109/ESIME.2011.5765784}.

\bibitemdeclare{inproceedings}{CFM11}
\bibitem{CFM11}
\bibinfo{author}{B.~Yang}, \bibinfo{author}{R.N. Dhara},
  \bibinfo{author}{W.~Belkhir}, \bibinfo{author}{M.~Lenczner} \&
  \bibinfo{author}{A.~Giorgetti} (\bibinfo{year}{2011}):
  \emph{\bibinfo{title}{Formal Methods for Multiscale Models Derivation}}.
\newblock In: {\sl \bibinfo{booktitle}{CFM 2011, 20th Congr\`es Fran\c{c}ais de
  M\'ecanique}}.
\newblock \bibinfo{note}{5 pages}.

\end{thebibliography}

\end{document}
