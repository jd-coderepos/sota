
\documentclass{article} \usepackage{iclr2021_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage[pdftex]{graphicx}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black,
    linktoc=all,
}

\usepackage{url}
\usepackage{multirow}
\usepackage{booktabs}       \usepackage{xcolor}
\usepackage{listings}
\usepackage{arydshln}
\usepackage{tablefootnote}
\usepackage{multirow}
\usepackage{subcaption}

\usepackage[titles]{tocloft} \setlength{\cftbeforesecskip}{5pt}
\setlength{\cftbeforesubsecskip}{2pt}
\setcounter{tocdepth}{2} 


\usepackage{color}
\definecolor{codegreen}{rgb}{0,0.5,0}
\definecolor{codeblue}{rgb}{0.25,0.5,0.5}
\definecolor{codegray}{rgb}{0.6,0.6,0.6}
\definecolor{comments}{RGB}{0,0,113}
\definecolor{red}{RGB}{160,0,0}
\definecolor{green}{RGB}{0,100,0}

\usepackage{listings}
\lstdefinestyle{codestyle}{
  backgroundcolor=\color{white},
  basicstyle=\fontsize{8.5pt}{9.5pt}\fontfamily{lmtt}\selectfont,
  columns=fullflexible,
  breaklines=true,
  captionpos=b,
  commentstyle=\fontsize{8pt}{9pt}\color{codegreen},
  keywordstyle=\fontsize{8pt}{9pt}\color{comments},
  stringstyle=\fontsize{8pt}{9pt}\color{red},
  showstringspaces=false,
  frame=tb,
  otherkeywords = {self},
}
\lstset{style=codestyle}

\title{LambdaNetworks: Modeling Long-Range \\
Interactions Without Attention}

\author{
    Irwan Bello \\
    Google Research, Brain team \\
    \texttt{ibello@google.com} \\
}

\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy
\begin{document}

\maketitle

\begin{abstract}
We present lambda layers -- an alternative framework to self-attention -- for capturing long-range interactions between an input and structured contextual information (e.g.\ a pixel surrounded by other pixels).
Lambda layers capture such interactions by transforming available contexts into linear functions, termed lambdas, and applying these linear functions to each input separately.
Similar to linear attention, lambda layers bypass expensive attention maps, but in contrast, they model both content and \emph{position-based} interactions which enables their application to large structured inputs such as images.
The resulting neural network architectures, \emph{LambdaNetworks}, significantly outperform their convolutional and attentional counterparts on ImageNet classification, COCO object detection and COCO instance segmentation, while being more computationally efficient.
Additionally, we design LambdaResNets, a family of hybrid architectures across different scales, that considerably improves the speed-accuracy tradeoff of image classification models.
LambdaResNets reach excellent accuracies on ImageNet while being \textbf{3.2 - 4.4x} faster than the popular EfficientNets on modern machine learning accelerators.
When training with an additional 130M pseudo-labeled images, LambdaResNets achieve up to a \textbf{9.5x} speed-up over the corresponding EfficientNet checkpoints\footnote{Code and model checkpoints will be available shortly}.
\end{abstract}
 \newpage
\tableofcontents
\newpage
\section{Introduction \label{sec:intro}}
Modeling long-range dependencies in data is a central problem in machine learning.
Self-attention~\citep{bahdanau2014neural,vaswani2017attention} has emerged as a popular approach to do so, 
but the costly memory requirement of self-attention hinders its application to long sequences and multidimensional data such as images\footnote{For example, applying a single multi-head attention layer to a batch of $128$ $64$x$64$ input images with $8$ heads requires $64$GB of memory, which is prohibitive in practice.
}.
\emph{Linear} attention mechanisms~\citep{katharopoulos2020transformers,choromanski2020rethinking} offer a scalable remedy for high memory usage but fail to model internal data structure, such as \emph{relative} distances between pixels or edge relations between nodes in a graph.


This work addresses both issues.
We propose \emph{lambda layers} which model long-range interactions between a query and a \emph{structured} set of context elements at a reduced memory cost.
Lambda layers transform each available context into a linear function, termed a \emph{lambda}, which is then directly applied to the corresponding query.
Whereas self-attention defines a similarity kernel between the query and the context elements, a lambda layer
instead summarizes contextual information into a fixed-size linear function (i.e.\ a matrix), thus bypassing the need for memory-intensive attention maps.
This difference is illustrated in Figure~\ref{fig:visual_example}.

\begin{figure}[h]
    \makebox[\textwidth][c]{\includegraphics[width=\textwidth]{figures/intro_figure.pdf}}
    \caption{\textbf{Comparison between self-attention and lambda layers}. 
    (\textbf{Left}) An example of 3 queries and their local contexts within a global context.
    (\textbf{Middle}) Self-attention associates each query with an attention distribution over its context.
    (\textbf{Right}) The lambda layer transforms each context into a linear function lambda that is applied to the corresponding query.}
    \label{fig:visual_example}
\end{figure}

Lambda layers are versatile and can be implemented to model both content-based and \emph{position-based} interactions in global, local or masked contexts.
The resulting neural networks, \emph{LambdaNetworks}, are computationally efficient, model long-range dependencies at a small memory cost and can therefore be applied to large structured inputs such as high resolution images.

We evaluate LambdaNetworks on computer vision tasks where works using self-attention are hindered by large memory costs~\citep{wang2018non,bello2019aacn}, suffer impractical implementations~\citep{ramachandran2019sasa}, or require vast amounts of data~\citep{dosovitskiy2020image}.
In our experiments spanning ImageNet classification, COCO object detection and COCO instance segmentation, LambdaNetworks significantly outperform their convolutional and attentional counterparts, while being more computationally efficient and faster than the latter.
We summarize our contributions:
\begin{itemize}
    \item Lambda layers, a class of layers, that model content-based and position-based interactions without materializing attention maps.
    Lambda layers are easily implemented with einsum operations and convolution kernels, operations with efficient implementations on modern machine learning accelerators.
    \item Lambda layers offer a unifying view of channel, spatial and linear attention. Some of our observations, such as the computational benefits of a multi-query formulation, extend to linear attention.
    \item Lambda layers significantly outperform their convolution and attention counterparts on the ImageNet classification task while being more computationally efficient. 
    For example, simply replacing the 3x3 convolutions in the bottleneck blocks of the ResNet-50 architecture~\citep{he2015deep} with lambda layers yields a \textcolor{blue}{+1.5\%} top-1 ImageNet accuracy improvement while reducing parameters by 40\%.
    \item Lambda layers achieve considerable computational benefits, both in latency and memory requirements, over multiple self-attention alternatives, including local and axial attention~\citep{ramachandran2019sasa,wang2020axialdeeplab}.
    \item A study of hybrid models as a means to maximize the speed-accuracy tradeoff of LambdaNetworks.
    \item Introduce LambdaResNets, a family of hybrid convolution-lambda models based on the training and scaling strategies recommended in~\cite{bello2021revisiting}.
    LambdaResNets achieve up to a \textbf{4.4x} speedup over EfficientNets on ImageNet, while being more memory-efficient.
    \item In a semi-supervised learning setting, training with an additional 130M pseudo-labeled images, LambdaResNets achieve up to a \textbf{9.5x} speedup over the EfficientNet NoisyStudent checkpoints~\citep{xie2020selftraining}.
    \item An evaluation of LambdaResNets on COCO object detection and instance segmentation using Mask-RCNN~\citep{he2017mask}. LambdaResNets yield consistent gains across all metrics on both tasks.
\end{itemize}
 \section{Modeling Long-Range Interactions\label{sec:preliminaries}}
\begin{table}[t]
  \begin{center}
  \small
  \begin{tabular}{l}
  \toprule
  A \textbf{content-based} interaction considers the content of the context but ignores the relation between \\
  the query position and the context (e.g.\ relative distance between two pixels). \\
  A \textbf{position-based} interaction considers the relation between the query position and the context position. \\
  \bottomrule
  \end{tabular}
  \caption{\textbf{Definition of content-based vs position-based interactions.}
  }
  \label{tab:content_position_interactions}
  \vspace{-0.4cm}
  \end{center}
\end{table}

In this section, we formally define queries, contexts and interactions.
We motivate keys as a requirement for capturing interactions between queries and their contexts and show that lambda layers arise as an alternative to attention mechanisms for capturing long-range interactions.

\vspace{-0.1cm}
\paragraph{Notation.} 
We denote scalars, vectors and tensors using lower-case, bold lower-case and bold upper-case letters, \textit{e.g.,} $n$, $\boldsymbol{x}$ and $\boldsymbol{X}$. 
We denote $|n|$ the cardinality of a set whose elements are indexed by $n$.
We denote $\boldsymbol{x}_n$ the $n$-th row of $\boldsymbol{X}$.
We denote $x_{ij}$ the $|ij|$ elements of $\boldsymbol{X}$.
When possible, we adopt the terminology of self-attention to ease readability and highlight differences.

\vspace{-0.1cm}
\paragraph{Defining queries and contexts.}
Let $\mathcal{Q}=\{(\boldsymbol{q}_n, n)\}$ and $\mathcal{C}=\{(\boldsymbol{c}_m, m)\}$ denote structured collections of vectors, respectively referred to as the \emph{queries} and the \emph{context}.
Each query $(\boldsymbol{q}_n, n)$ is characterized by its content $\boldsymbol{q}_n \in \mathbb{R}^{|k|}$ and \emph{position} $n$.
Similarly, each context element $(\boldsymbol{c}_m, m)$ is characterized by its \emph{content} $\boldsymbol{c}_m$ 
and its position $m$ in the context.
The $(n, m)$ pair may refer to any pairwise relation between structured elements, e.g.\ relative distances between pixels or edges between nodes in a graph.

\vspace{-0.1cm}
\paragraph{Defining interactions.}
We consider the general problem of mapping a query $(\boldsymbol{q}_n, n)$ to an output vector $\boldsymbol{y}_n \in \mathbb{R}^{|v|}$ given the context $\mathcal{C}$ with a function $\boldsymbol{F}: ((\boldsymbol{q}_n, n), \mathcal{C}) \mapsto \boldsymbol{y}_n$.
Such a function may act as a layer in a neural network when processing structured inputs.
We refer to $(\boldsymbol{q}_n, \boldsymbol{c}_m)$ interactions as \emph{content-based} and $(\boldsymbol{q}_n, (n, m))$ interactions as \emph{position-based}.
We note that while \emph{absolute} positional information is sometimes directly added to the query (or context element) content\footnote{This approach is often used in natural language processing tasks~\citep{vaswani2017attention} but has had limited success in the visual domain where relative position information between pixels is crucial~\citep{bello2019aacn}.}, we consider this type of interaction to be content-based as it ignores the \emph{relation} $(n, m)$ between the query and context element positions.

\vspace{-0.1cm}
\paragraph{Introducing keys to capture long-range interactions.}
In the context of deep learning, we prioritize fast batched linear operations and use dot-product operations as our interactions.
This motivates introducing vectors that can interact with the queries via a dot-product operation and therefore have the same dimension as the queries.
In particular, content-based interactions $(\boldsymbol{q}_n, \boldsymbol{c}_m)$ require a $|k|$-dimensional vector that depends on $\boldsymbol{c}_m$, commonly referred to as the key $\boldsymbol{k}_m$.
Conversely, position-based interactions $(\boldsymbol{q}_n, (n, m))$ require a relative position embedding $\boldsymbol{e}_{nm} \in \mathbb{R}^{|k|}$~\citep{shaw2018relative}.
As the query/key depth $|k|$ and context spatial dimension $|m|$ are not in the output $\boldsymbol{y}_n \in \mathbb{R}^{|v|}$, these dimensions need to be contracted as part of the layer computations.
\emph{Every layer capturing long-range interactions can therefore be characterized based on whether it contracts the query depth or the context positions first.}

\vspace{-0.1cm}
\paragraph{Attentional interactions.}
Contracting the query depth first creates a similarity kernel (the attention map) between the query and context elements and is known as the attention operation.
As the number of context positions $|m|$ grows larger and the input and output dimensions $|k|$ and $|v|$ remain fixed, one may hypothesize that computing attention maps become wasteful, given that the layer output is a vector of comparatively small dimension $|v| \ll |m|$.

\vspace{-0.1cm}
\paragraph{Lambda interactions.}
Instead, it may be more efficient to simply map each query to its output as $\boldsymbol{y}_n = F((\boldsymbol{q}_n, n), \mathcal{C}) = \boldsymbol{\lambda}(\mathcal{C}, n)(\boldsymbol{q}_n)$ for some \emph{linear} function $\boldsymbol{\lambda}(\mathcal{C}, n): \mathbb{R}^{|k|} \rightarrow \mathbb{R}^{|v|}$.
In this scenario, the context is aggregated into a fixed-size linear function $\boldsymbol{\lambda}_n = \boldsymbol{\lambda}(\mathcal{C}, n)$.
Each $\boldsymbol{\lambda}_n$ acts as a small linear function\footnote{
This mechanism is reminiscent of functional programming and $\lambda$-calculus which motivates the lambda terminology.} that exists independently of the context (once computed) and is discarded after being applied to its associated query $\boldsymbol{q}_n$. \section{Lambda Layers\label{sec:lambda_layer}}

\subsection{Lambda layer: transforming contexts into linear functions.}
A \emph{lambda layer} takes the inputs $\boldsymbol{X} \in \mathbb{R}^{|n|\times d_{in}}$ and the context $\boldsymbol{C} \in \mathbb{R}^{|m|\times d_c}$ as input and generates linear function lambdas that are then applied to the queries, yielding outputs $\boldsymbol{Y} \in \mathbb{R}^{|n|\times d_{out}}$.
Without loss of generality, we assume $d_{in}=d_c=d_{out}=d$.
As is the case with \emph{self}-attention, we we may have $\boldsymbol{C} = \boldsymbol{X}$.
In the rest of this paper, we focus on a \emph{specific instance of a lambda layer} and show that it captures long-range content and position-based interactions without materializing attention maps.
Figure~\ref{fig:lambda_layer_graph} presents the computational graph of the lambda layer.

We first describe the lambda layer when applied to a \emph{single query} ($\boldsymbol{q}_n, n)$.

\vspace{-0.1cm}
\paragraph{Generating the contextual lambda function.}
\begin{figure}[t]
    \begin{subfigure}{0.65\textwidth}
        \includegraphics[height=5cm,width=8.5cm]{figures/computational_graph.pdf}
        \label{fig:lambda_layer_computational_graph}
    \end{subfigure} \hspace{-0.05\textwidth}
    \begin{subfigure}{0.35\textwidth}
		\centering
        \tiny
        \begin{tabular}{ll}
        \toprule
        Name & Description \\
        \midrule
        $|k|$, $|v|$ & query, value depth \\
        \midrule
        $\boldsymbol{X} \in \mathbb{R}^{|n|\times d}$ & inputs \\
        $\boldsymbol{C} \in \mathbb{R}^{|m|\times d}$ & context \\
        \midrule
        $\boldsymbol{Q} = \boldsymbol{X}\boldsymbol{W}_Q \in \mathbb{R}^{|n|\times|k|}$ & queries \\
        $\boldsymbol{K} = \boldsymbol{C}\boldsymbol{W}_K \in \mathbb{R}^{|m|\times|k|}$ & keys \\
        $\boldsymbol{V}=\boldsymbol{C}\boldsymbol{W}_V \in \mathbb{R}^{|m|\times|v|}$ & values \\
$\sigma(\boldsymbol{K}) = \text{softmax}(\boldsymbol{K}, \text{axis=}m)$ & normalized keys \\
        \multirow{2}{*}{$\boldsymbol{E}_n \in \mathbb{R}^{|m|\times|k|}$} & relative position \\
        & embeddings \\
        \midrule
        $\boldsymbol{\lambda}^c = \bar{\boldsymbol{K}}^T \boldsymbol{V} \in \mathbb{R}^{|k|\times|v|}$ & \emph{content} lambda \\
        $\boldsymbol{\lambda}^p_n = \boldsymbol{E}_{n}^T \boldsymbol{V} \in \mathbb{R}^{|k|\times|v|}$ & \emph{position} lambdas \\
        $\boldsymbol{\lambda}_n = \boldsymbol{\lambda}^c + \boldsymbol{\lambda}^p_n \in \mathbb{R}^{|k|\times|v|}$ & lambdas \\
        \bottomrule
        \end{tabular}
        \label{tab:lambda_layer_quantities}
    \end{subfigure}
    \caption{
    \textbf{Computational graph of the lambda layer}. 
    Contextual information for query position $n$ is summarized into a lambda $\boldsymbol{\lambda}_n \in \mathbb{R}^{|k|\times|v|}$.
    Applying the lambda dynamically distributes contextual features to produce the output as $\boldsymbol{y}_n= \boldsymbol{\lambda}^T_n \boldsymbol{q}_n$.
    This process captures content-based and position-based interactions without producing attention maps.}
    \label{fig:lambda_layer_graph}
\end{figure}

We wish to generate a linear function $\mathbb{R}^{|k|} \rightarrow \mathbb{R}^{|v|}$, i.e.\ a matrix $\boldsymbol{\lambda_n} \in \mathbb{R}^{|k|\times|v|}$.
The lambda layer first computes \emph{keys} $\boldsymbol{K}$ and \emph{values} $\boldsymbol{V}$ by linearly projecting the context, and keys are normalized across context positions via a softmax operation yielding normalized keys $\bar{\boldsymbol{K}}$.
The $\boldsymbol{\lambda}_n$ matrix is obtained by using the normalized keys $\bar{\boldsymbol{K}}$ and position embeddings $\boldsymbol{E}_n$ to aggregate the values $\boldsymbol{V}$ as
\begin{equation}
\begin{split}
    \label{eq:generating_lambdas}
    \boldsymbol{\lambda}_n &= \sum_{m} (\bar{\boldsymbol{k}}_m + \boldsymbol{e}_{nm})
    \boldsymbol{v}_m^T = \underbrace{\bar{\boldsymbol{K}_{}}^T \boldsymbol{V}}_{\textrm{content}\:\textrm{lambda}}+ \underbrace{\boldsymbol{E}_n^T \boldsymbol{V}}_{\textrm{position}\:\textrm{lambda}}
    \in \mathbb{R}^{|k|\times|v|} \\
\end{split}
\end{equation}
where we also define the \emph{content lambda} $\boldsymbol{\lambda}^c$ and \emph{position lambda} $\boldsymbol{\lambda}_n^p$.
\begin{itemize}
    \item The \emph{content lambda} $\boldsymbol{\lambda}^c$ is shared across all query positions $n$ and is invariant to permutation of the context elements. It encodes how to transform the query $\boldsymbol{q}_n$ solely based on the context content.
    \item The \emph{position lambda} $\boldsymbol{\lambda}_n^p$ depends on the query position $n$ via the position embedding $\boldsymbol{E}_n$. It encodes how to transform the query $\boldsymbol{q}_n$ based on the context elements $\boldsymbol{c}_m$ and their \emph{relative positions} to the query $(n, m)$.
\end{itemize}

\vspace{-0.1cm}
\paragraph{Applying lambda to its query.}
The query $\boldsymbol{q}_n \in \mathbb{R}^{|k|}$ is obtained from the input $\boldsymbol{x}_n$ via a learned linear projection and the output of the lambda layer is obtained as
\begin{equation}
    \label{eq:applying_lambdas}
    \boldsymbol{y}_n = \boldsymbol{\lambda}_n^T \boldsymbol{q}_n = (\boldsymbol{\lambda}^c + \boldsymbol{\lambda}^p_n)^T \boldsymbol{q}_n \in \mathbb{R}^{|v|}.
\end{equation}

\vspace{-0.1cm}
\paragraph{Interpretation of lambda layers.}
The columns of the $\boldsymbol{\lambda}_n \in \mathbb{R}^{|k| \times |v|}$ matrix can be viewed as a fixed-size set of $|k|$ contextual features.
These contextual features are aggregated based on the context's content (content-based interactions) and structure (position-based interactions).
Applying the lambda then dynamically distributes these contextual features based on the query to produce the output as $\boldsymbol{y}_n=\sum_k q_{nk} \boldsymbol{\lambda}_{nk}$.
This process captures \emph{content and position-based interactions} without producing attention maps.

\vspace{-0.1cm}
\paragraph{Normalization.}
One may modify Equations~\ref{eq:generating_lambdas} and~\ref{eq:applying_lambdas} to include non-linearities or normalization operations.
Our experiments indicate that applying batch normalization~\citep{BatchNorm} after computing the queries and the values is helpful.

\subsection{A multi-query formulation to reduce complexity.}

\paragraph{Complexity analysis.}
For a batch of $|b|$ examples, each containing $|n|$ inputs, the number of arithmetic operations and memory footprint required to apply our lambda layer
are respectively $\Theta(bnmkv)$ and $\Theta(knm + bnkv)$.
We still have a quadratic memory footprint with respect to the input length due to the $\boldsymbol{e}_{nm}$ relative position embeddings.
However this quadratic term does not scale with the batch size as is the case with the attention operation which produces \emph{per-example} attention maps.
In practice, the hyperparameter $|k|$ is set to a small value (such as $|k|$=16) and we can process large batches of large inputs in cases where attention cannot (see Table~\ref{tab:memory_comparison}).
Additionally, position embeddings can be shared across lambda layers to keep their $\Theta(knm)$ memory footprint constant - whereas the memory footprint of attention maps scales with the number of layers\footnote{Attention maps typically need to be stored for back-propagation~\citep{kitaev2020reformer}.}.

\vspace{-0.1cm}
\paragraph{Multi-query lambda layers reduce time and space complexities.}
\begin{figure}[h]
\small
\begin{lstlisting}[language=python]
def lambda_layer(queries, keys, embeddings, values):
    """Multi-query lambda layer."""
    # b: batch, n: input length, m: context length,
    # k: query/key depth, v: value depth,
    # h: number of heads, d: output dimension.
    content_lambda = einsum(softmax(keys), values, 'bmk,bmv->bkv')
    position_lambdas = einsum(embeddings, values, 'nmk,bmv->bnkv')
    content_output = einsum(queries, content_lambda, 'bhnk,bkv->bnhv')
    position_output = einsum(queries, position_lambdas, 'bhnk,bnkv->bnhv')
    output = reshape(content_output + position_output, [b, n, d])
    return output
\end{lstlisting}
    \caption{
    \textbf{Pseudo-code for the multi-query lambda layer}.
    The position embeddings can be made to satisfy various conditions, such as translation equivariance, when computing positional lambdas (not shown).
    }
    \label{fig:lambda_layer_code}
    \vspace{-0.25cm}
\end{figure}

Recall that the lambda layer maps inputs $\boldsymbol{x}_n \in \mathbb{R}^d$ to outputs $\boldsymbol{y}_n \in \mathbb{R}^d$.
As presented in Equation~\ref{eq:applying_lambdas}, this implies that $|v|$=$d$.
Small values of $|v|$ may therefore act as a bottleneck on the feature vector $\boldsymbol{y}_n$ but larger output dimensions $|v|$ can incur an excessively large computational cost given our $\Theta(bnmkv)$ and $\Theta(knm + bnkv)$ time and space complexities.

We propose to decouple the time and space complexities of our lambda layer from the output dimension $d$.
Rather than imposing $|v|$=d, we create $|h|$ queries $\{\boldsymbol{q}^h_n\}$, apply the same lambda $\boldsymbol{\lambda}_n$ to each query $\boldsymbol{q}^h_n$, and concatenate the outputs as $\boldsymbol{y}_n = \textrm{concat}(\boldsymbol{\lambda}_n \boldsymbol{q}^1_n, \cdots, \boldsymbol{\lambda}_n \boldsymbol{q}^{|h|}_n)$.
We now have $|v|$=$d/|h|$, which reduces complexity by a factor of $|h|$.
The number of \emph{heads} $|h|$ controls the size of the lambdas $\boldsymbol{\lambda}_n \in \mathbb{R}^{|k|\times|d|/|h|}$ relative to the total size of the queries $\boldsymbol{q}_n \in \mathbb{R}^{|hk|}$.

We refer to this operation as a \emph{multi-query} lambda layer and present an implementation using einsum\footnote{
The einsum operation denotes general contractions between tensors of arbitrary dimensions.
It is numerically equivalent to broadcasting its inputs to share the union of their dimensions, multiplying element-wise and summing across all dimensions not specified in the output.
} in Figure~\ref{fig:lambda_layer_code}.
The lambda layer is robust to $|k|$ and $|h|$ hyperparameter choices (see Appendix~\ref{sec:kh_ablations}), which enables flexibility in controlling its complexity.
We use $|h|$=4 in most experiments.

We note that while this resembles the multi-head or multi-query~\citep{shazeer2019fast}\footnote{~\citep{shazeer2019fast} proposes a multi-query formulation to speed-up attention-based decoding.}
attention formulation, the motivation is different.
Using multiple queries in the attention operation increases representational power and complexity.
In contrast, using multiple queries in the lambda layer \emph{decreases} complexity and representational power (ignoring the additional queries).

\vspace{-0.1cm}
\paragraph{Extending the multi-query formulation to linear attention.}
Finally, we point that our analysis extends to linear attention which can be viewed as a \emph{content-only} lambda layer (see Appendix~\ref{sec:linear_attention} for a detailed discussion).
We anticipate that the multi-query formulation can also bring computational benefits to linear attention mechanisms.

\vspace{-0.1cm}
\subsection{Making lambda layers translation equivariant.}
Using relative position embeddings $\boldsymbol{e}_{nm}$ enables making explicit assumptions about the structure of the context.
In particular, translation equivariance (i.e.\ the property that shifting the inputs results in an equivalent shift of the outputs) is a strong inductive bias in many learning scenarios.
We obtain translation equivariance in position interactions by ensuring that the position embeddings satisfy $\boldsymbol{e}_{nm} = \boldsymbol{e}_{t(n)t(m)}$ for any translation $t$.
In practice, we define a tensor of \emph{relative} position embeddings $\boldsymbol{R} \in \mathbb{R}^{|r| \times |k|}$, where $r$ indexes the possible relative positions for all $(n, m)$ pairs, and reindex\footnote{We refer the reader to the code for more details.} it into $\boldsymbol{E} \in \mathbb{R}^{|n| \times |m| \times |k|}$ such that $\boldsymbol{e}_{nm} = \boldsymbol{r}_{r(n,m)}$.

\vspace{-0.1cm}
\subsection{Lambda convolution: modeling longer range interactions in local contexts.}
\begin{table}[h]
  \begin{center}
  \small
  \begin{tabular}{l|cccc}
    \toprule
    \multirow{2}{*}{Operation} & Head & \multirow{2}{*}{Interactions} & Time & Space \\
    & configuration & & complexity & complexity \\
    \midrule
    Attention & multi-head & content-only & $\Theta(bnm(hk+d))$ & $\Theta(\emph{bhnm})$ \\
    Relative attention & multi-head & content \& position & $\Theta(bnm(hk+d))$ & $\Theta(\emph{bhnm})$ \\
    Linear attention & multi-head & content-only & $\Theta(bnkd)$ & $\Theta(bkd)$ \\
    \midrule
    Lambda layer & multi-query & content \& position & $\Theta(bnmkd/h)$ & $\Theta(\emph{knm} + bnkd/h)$ \\
    Lambda convolution & multi-query & content \& position & $\Theta(bnrkd/h)$ & $\Theta(kr + bnkd/h)$ \\
    \bottomrule
  \end{tabular}
  \caption{
  \textbf{Alternatives for capturing long-range interactions.}
  The lambda layer captures content and \emph{position-based} interactions at a reduced memory cost compared to relative attention~\citep{shaw2018relative,bello2019aacn}.
  Using a multi-query lambda layer reduces complexities by a factor of $|h|$.
  Additionally, position-based interactions can be restricted to a local scope by using the lambda convolution which has linear complexity.
  \textcolor{blue}{$b$: batch size, $h$: number of heads/queries, $n$: input length, $m$: context length, $r$: local scope size, $k$: query/key depth, $d$: dimension output.}
  }
  \label{tab:interactions_alternatives}
  \vspace{-0.2cm}
  \end{center}
\end{table}

Despite the benefits of long-range interactions, locality remains a strong inductive bias in many tasks.
Using global contexts may prove noisy or computationally excessive.
It may therefore be useful to restrict the scope of position interactions to a \emph{local} neighborhood around the query position $n$ as is the case for local self-attention and convolutions.
This can be done by zeroing out the relative embeddings for context positions $m$ outside of the desired scope.
However, this strategy remains costly for large values of $|m|$ since the computations still occur - they are only being zeroed out.

\vspace{-0.1cm}
\paragraph{Lambda convolution}
In the case where the context is arranged in a multidimensional grid, we can equivalently compute \emph{positional lambdas} from local contexts by using a regular convolution.
We term this operation the \emph{lambda convolution}.
A n-dimensional lambda convolution can be implemented using an n-d depthwise convolution with channel multiplier or (n+1)-d convolution that treats the $v$ dimension in $\boldsymbol{V}$ as an \emph{extra spatial dimension}.
We present both implementations in Appendix~\ref{sec:complete_lambda_layer_code}.

As the computations are now restricted to a local scope, the lambda convolution obtains \emph{linear} time and memory complexities with respect to the input length\footnote{Number of floating point operations (time complexity) is not necessarily a good proxy for latency on specialized hardware such as TPUs/GPUs. Eventhough the lambda convolution has linear time and space complexities, it can be slower than than the global lambda layer in practice, especially when the convolution scope size is large. See Table~\ref{tab:memory_comparison} for an example.}.
The lambda convolution is readily usable with additional functionalities such as dilation and striding and enjoys optimized implementations on specialized hardware accelerators~\citep{nickolls2010gpu,jouppiTPU}.
This is in stark contrast to implementations of local self-attention that require materializing feature patches of overlapping query and context blocks~\citep{parmar2018image,ramachandran2019sasa}, increasing memory consumption and latency (see Table~\ref{tab:memory_comparison}). \section{Related Work\label{sec:related_work}}
Table~\ref{tab:interactions_alternatives} reviews alternatives for capturing long-range interactions and contrasts them with the proposed multi-query lambda layer.
We discuss related works in details in the Appendix~\ref{sec:additional_related_work}.

\vspace{-0.15cm}
\paragraph{Channel and linear attention} The lambda abstraction, i.e.\ transforming available contexts into linear functions that are applied to queries, is quite general and therefore encompasses many previous works.
Closest to our work are channel and linear attention mechanisms~\citep{hu2017squeeze,katharopoulos2020transformers,choromanski2020rethinking}.
Such mechanisms also capture long-range interactions without materializing attention maps and can be viewed as specific instances of a \emph{content-only} lambda layer.
Lambda layers formalize and extend such approaches to consider both content-based and \emph{position-based} interactions, enabling their use as a stand-alone layer on highly structured data such as images.
Rather than attempting to closely approximate an attention kernel as is the case with linear attention, we focus on the efficient design of contextual lambda functions and repurpose a multi-query formulation~\citep{shazeer2019fast} to further reduce computational costs.

\vspace{-0.15cm}
\paragraph{Self-attention in the visual domain}
In contrast to natural language processing tasks where it is now the de-facto standard, self-attention has enjoyed steady but slower adoption in the visual domain~\citep{wang2018non,bello2019aacn,ramachandran2019sasa,carion2020endtoend}.
Concurrently to this work,~\cite{dosovitskiy2020image} achieve a strong 88.6\% accuracy on ImageNet by pre-training a Transformer on sequences of image patches on a large-scale dataset of 300M images. \section{Experiments\label{sec:experiments}}
In subsequent experiments, we evaluate lambda layers on standard computer vision benchmarks:
ImageNet classification~\citep{deng2009imagenet},
COCO object detection and instance segmentation~\citep{lin2014microsoft}.
The visual domain is well-suited to showcase the flexibility of lambda layers since
\textbf{(1)} the memory footprint of self-attention becomes problematic for high-resolution imagery and
\textbf{(2)} images are highly structured, making position-based interactions crucial.

\vspace{-0.1cm}
\paragraph{LambdaResNets}
We construct LambdaResNets by replacing the 3x3 convolutions in the bottleneck blocks of the ResNet architecture~\citep{he2015deep}.
When replacing all such convolutions, we simply denote the name of the layer being tested (e.g.\ conv + channel attention or lambda layer).
We denote LambdaResNets the family of \emph{hybrid} architectures described in Table~\ref{tab:block_config_details} (Appendix~\ref{sec:architecture_details}).
Unless specified otherwise, all lambda layers use $|k|$=16, $|h|$=4 with a scope size of $|m|$=23x23 and are implemented as in Figure~\ref{fig:lambda_layer_code}.
Additional experiments and details can be found in the Appendix.

\vspace{-0.1cm}
\subsection{Lambda layers outperform convolutions and attention layers.}
We first consider the standard ResNet-50 architecture with input image size 224x224.
In Table~\ref{tab:resnet50}, we compare the lambda layer against 
\textbf{(a)} the standard convolution (i.e.\ the baseline ResNet-50)
\textbf{(b)} channel attention (squeeze-and-excitation) and
\textbf{(c)} multiple self-attention variants.
The lambda layer strongly outperforms all baselines at a fraction of the parameter cost and notably obtains a +0.8\% improvement over channel attention.

\begin{table}[ht!]
  \begin{center}
  \small
  \begin{tabular}{lccc}
    \toprule
    Layer & Params (M) & top-1 \\
    \midrule
    Conv~\citep{he2015deep}$^\dagger$ & 25.6 & 76.9 \\
    \midrule
    Conv + channel attention~\citep{hu2017squeeze}$^\dagger$ & 28.1 & $77.6$ (\textcolor{blue}{+0.7}) \\
    \midrule
    Conv + linear attention~\citep{chen2018double} & 33.0 & 77.0 \\ Conv + linear attention~\citep{shen2018efficient} & - & $77.3$ (\textcolor{blue}{+1.2}) \\ Conv + relative self-attention~\citep{bello2019aacn} & 25.8 & $77.7$ (\textcolor{blue}{+1.3}) \\
    \midrule Local relative self-attention~\citep{ramachandran2019sasa} & 18.0 & $77.4$ (\textcolor{blue}{+0.5}) \\
    Local relative self-attention~\citep{hu2019local} & 23.3 & $77.3$ (\textcolor{blue}{+1.0}) \\
    Local relative self-attention~\citep{zhao2020exploring} & 20.5 & $78.2$ (\textcolor{blue}{+1.3}) \\
    \midrule
    Lambda layer & $\textbf{15.0}$ & $\textbf{78.4}$ (\textbf{\textcolor{blue}{+1.5}}) \\
    Lambda layer ($|u|$=4) & $\textbf{16.0}$ & $\textbf{78.9}$ (\textbf{\textcolor{blue}{+2.0}}) \\
    \bottomrule
  \end{tabular}
  \caption{\textbf{Comparison of the lambda layer and attention mechanisms on ImageNet classification with a ResNet50 architecture.}
  The lambda layer strongly outperforms attention alternatives at a fraction of the parameter cost.
  All models are trained in mostly similar setups (see Appendix~\ref{sec:training_details}) and we include the reported improvements compared to the convolution baseline in parentheses.
  See Appendix~\ref{sec:lambda_layer_u} for a description of the $|u|$ hyperparameter.
  $^{\dagger}$ Our implementation.}
  \label{tab:resnet50}
  \vspace{-0.4cm}
  \end{center}
\end{table}

\vspace{-0.1cm}
\subsection{Computational benefits of lambda layers over self-attention.}
In Table~\ref{tab:memory_comparison}, we compare lambda layers against self-attention and present throughputs, memory complexities and ImageNet accuracies.
Our results highlight the weaknesses of self-attention:
self-attention cannot model global interactions due to large memory costs, axial self-attention is still memory expensive and local self-attention is prohibitively slow.
In contrast, the lambda layer can capture global interactions on high-resolution images and obtains a $+1.0\%$ improvement over local self-attention while being almost 3x faster\footnote{
Latencies for local self-attention were provided privately by~\cite{ramachandran2019sasa} based on an implementation that relies on query blocks and overlapping memory blocks~\citep{parmar2018image}. 
Specialized attention kernels may greatly speed up local self-attention, making it a promising avenue for future research.
}.
Additionally, positional embeddings can be shared across lambda layers to further reduce memory requirements, at a minimal degradation cost.
Finally, the lambda convolution has linear memory complexity, which becomes practical for very large images as seen in detection or segmentation.
We also find that the lambda layer outperforms local self-attention when controlling for the scope size\footnote{Note that the content-based lambda still captures global interactions.} (78.1\% vs 77.4\% for $|m|$=7x7), suggesting that the benefits of the lambda layer go beyond improved speed and scalability.

\begin{table}[h]
  \begin{center}
  \small
  \begin{tabular}{lccccc}
    \toprule
    Layer & Space Complexity & Memory (GB) & Throughput & top-1 \\
    \midrule
    Global self-attention & $\Theta(blhn^2)$ & 120 & OOM & OOM \\
    Axial self-attention & $\Theta(blhn\sqrt{n})$ & 4.8 & 960 ex/s & 77.5 \\
    Local self-attention (7x7) & $\Theta(blhnm)$ & - & 440 ex/s & 77.4 \\ \midrule
    Lambda layer & $\Theta(lkn^2)$ & 1.9 & 1160ex/s & \textbf{78.4} \\
    Lambda layer ($|k|$=8) & $\Theta(lkn^2)$ & 0.95 & \textbf{1640} ex/s & 77.9 \\
    Lambda layer (shared embeddings) & $\Theta(kn^2)$ & \textbf{0.63} & 1210 ex/s & 78.0 \\
    Lambda convolution (7x7) & $\Theta(lknm)$ & - & 1100 ex/s & 78.1 \\
    \bottomrule
  \end{tabular}
  \caption{\textbf{The lambda layer reaches higher ImageNet accuracies while being faster and more memory-efficient than self-attention alternatives.}
  Memory is reported assuming full precision for a batch of 128 inputs using default hyperparameters.
  The memory cost for storing the lambdas matches the memory cost of activations in the rest of the network and is therefore ignored.
  \textcolor{blue}{
  $b$: batch size, $h$: number of heads/queries, $n$: input length, $m$: context length, $k$: query/key depth, $l$: number of layers.}
  }
  \label{tab:memory_comparison}
  \vspace{-0.3cm}
  \end{center}
\end{table}

\iffalse
Example with batch_size=128, h=8, float32 (4 bytes/float)
Feature maps esolutions in resnet-50 for image size 224:
3 56x56 blocks, 4 28x28 blocks, 6 14x14 blocks, 3 7x7 blocks

Global self-attention
Mem = 128 * 8 * 4 * (3 * 56^4 + 4 * 28^4 + 6 * 14^4 + 3 * 7^4) / 2 ** 30
    = (3 * 56^4 + 4 * 28^4 + 6 * 14^4 + 3 * 7^4) / 2 ** 18
    ~ 108GB
  
Axial self-attention (row & column attention): 
Mem = 2 * 128 * 8 * 4 * (3 * 56^3 + 4 * 28^3 + 6 * 14^3 + 3 * 7^3) / 2 ** 30 
    = (3 * 56^3 + 4 * 28^3 + 6 * 14^3 + 3 * 7^3) / 2 ** 17 
    ~ 4.83GB

Lambda layer (k=16)
Mem = 16 * (3 * 56^4 + 4 * 28^4 + 6 * 14^4 + 3 * 7^4) * 4 / 2 ** 30
    = (3 * 56^4 + 4 * 28^4 + 6 * 14^4 + 3 * 7^4) / 2 ** 24
    = 1.9GB 

Lambda layer (k=8)
Mem = Mem(k=16) / 2 =  0.95GB

Lambda layer (k=16, sharing embeddings across stage)
Mem = 16 * (56^4 + 28^4 + 14^4 + 7^4) * 4 / 2 ** 30
    = (56^4 + 28^4 + 14^4 + 7^4) / 2 ** 24
    = 0.63GB
\fi

\subsection{Hybrids improve the speed-accuracy tradeoff of image classification.\label{sec:hybrid_lambdanetworks}}

\vspace{-0.1cm}
\paragraph{Studying hybrid architectures.}
In spite of the memory savings compared to self-attention, capturing global contexts with the lambda layer still incurs a quadratic time complexity (Table~\ref{tab:interactions_alternatives}), which remains costly at high resolution. 
Additionally, one may hypothesize that global contexts are most beneficial once features contain semantic information, i.e.\ after having been processed by a few operations, in which case using global contexts in the early layers would be wasteful.
In the Appendix~\ref{sec:hybrid_lambdanetworks}, we study hybrid designs that use standard convolutions to capture local contexts and lambda layers to capture global contexts.
We find that such convolution-lambda hybrids have increased representational power at a negligible decrease in throughput compared to their purely convolutional counterparts.

\vspace{-0.1cm}
\paragraph{LambdaResNets significantly improve the speed-accuracy tradeoff of ImageNet classification.}
We design a family of hybrid LambdaResNets across scales based on our study of hybrid architectures and the scaling/training strategies from~\cite{bello2021revisiting} (see Section~\ref{sec:architecture_details}).
Figure~\ref{fig:supervised_pareto_curve} presents the speed-accuracy Pareto curve of LambdaResNets compared to EfficientNets~\citep{tan2019efficientnet} on TPUv3 hardware.
In order to isolate the benefits of lambda layers, we additionally compare against the same architectures when replacing lambda layers by \textbf{(1)} standard 3x3 convolutions (denoted ResNet-RS wo/ SE) and \textbf{(2)} 3x3 convolutions with squeeze-and-excitation (denoted ResNet-RS w/ SE).
All architectures are trained for 350 epochs using \emph{the same regularization methods and evaluated at the same resolution they are trained at}.

\begin{figure}[ht]
    \begin{center}
    \includegraphics[width=0.7\columnwidth]{figures/train_pareto_curve.pdf}
    \end{center}
    \caption{
    \textbf{Speed-accuracy comparison between LambdaResNets and EfficientNets.}
    When matching the training and regularization setup of EfficientNets, LambdaResNets are 3.2 - 4.4x faster than EfficientNets and 1.6 - 2.3x faster than ResNet-RS with squeeze-and-excitation. 
    LambdaResNets are annotated with (depth, image size). 
    Our largest LambdaResNet, LambdaResNet-420 trained at image size 320, reaches a strong 84.9\% top-1 accuracy.
    }
    \label{fig:supervised_pareto_curve}
    \vspace{-0.2cm}
\end{figure}

LambdaResNets outperform the baselines across all scales on the speed-accuracy trade-off.
LambdaResNets are \textbf{3.2 - 4.4x} faster than EfficientNets and \textbf{1.6 - 2.3x} faster than ResNet-RS when controlling for accuracy, thus significantly improving the speed-accuracy Pareto curve of image classification\footnote{~\cite{ridnik2020tresnet} and ~\cite{zhang2020resnest} report high ImageNet accuracies while being up to 2x faster than EfficientNets on GPUs.}.
Our largest model, LambdaResNet-420 trained at image size 320, achieves a strong 84.9\% top-1 ImageNet accuracy, 
0.9\% over the corresponding architecture with standard 3x3 convolutions and
0.65\% over the corresponding architecture with squeeze-and-excitation.

\vspace{-0.1cm}
\paragraph{Scaling to larger datasets with pseudo-labels}
We train LambdaResNets in a semi-supervised learning setting using 130M pseudo-labeled images from the JFT dataset, as done for training the EfficientNet-NoisyStudent checkpoints~\citep{xie2020selftraining}.
Table~\ref{tab:pseudo_labels} compares the throughputs and ImageNet accuracies of 
a representative set of models with similar accuracies when trained using the JFT dataset.
LambdaResNet-152, trained and evaluated at image size 288, achieves a strong 86.7\% top-1 ImageNet accuracy while being more parameter-efficient and \textbf{9.5x} faster than the EfficientNet-NoisyStudent checkpoint with the same accuracy.

\begin{table}[h]
  \begin{center}
  \small
  \begin{tabular}{lcllc}
    \toprule
    Architecture & Params (M) & Train (ex/s) & Infer (ex/s) & ImageNet top-1 \\
    \midrule
    LambdaResNet-152 & \textbf{51} & \textbf{1620} & \textbf{6100} & 86.7 \\
    EfficientNet-B7 & 66 & 170 \textcolor{red}{(9.5x)} & 980 \textcolor{red}{(6.2x)} & 86.7 \\
    ViT-L/16 & 307 & 180 \textcolor{red}{(9.0x)} & 640 \textcolor{red}{(9.5x)} & \textbf{87.1} \\
    \bottomrule
  \end{tabular}
  \caption{
  \textbf{Comparison of models trained on extra data}.
  ViT-L/16 is pre-trained on JFT and finetuned on ImageNet at resolution 384x384, while EfficientNet and LambdaResNet are co-trained on ImageNet and JFT pseudo-labels.
  Training and inference throughput is shown for 8 TPUv3 cores.
  }
  \label{tab:pseudo_labels}
  \vspace{-0.3cm}
  \end{center}
\end{table}

\subsection{Object detection and instance segmentation results}
In Table~\ref{tab:detection}, we evaluate LambdaResNets as a backbone in Mask-RCNN ~\citep{he2017mask} on the COCO object detection and instance segmentation tasks.
Using lambda layers yields consistent gains across all object sizes, especially the small objects which are the hardest to locate.
This indicates that lambda layers are also competitive for more complex visual tasks that require localization information.

\begin{table}[ht!]
  \begin{center}
  \small
  \begin{tabular}{l|cc|cc}
    \toprule
    Backbone & AP$^{bb}_{coco}$ & AP$^{bb}_{s/m/l}$  & AP$^{mask}_{coco}$ & AP$^{mask}_{s/m/l}$ \\
    \midrule
    ResNet-101 & 48.2 & 29.9 \textcolor{codegray}{/ 50.9 / 64.9} & 42.6 & 24.2 \textcolor{codegray}{/ 45.6 / 60.0} \\
    ResNet-101 + SE & 48.5 & 29.9 \textcolor{codegray}{/ 51.5 / 65.3} & 42.8 & 24.0 \textcolor{codegray}{/ 46.0 / 60.2} \\
    LambdaResNet-101 & \textbf{49.4} & \textbf{31.7} 
    \textcolor{codegray}{/ \textbf{52.2} / \textbf{65.6}} & \textbf{43.5} & \textbf{25.9} \textcolor{codegray}{/ \textbf{46.5} / \textbf{60.8}} \\
    \midrule
    ResNet-152 & 48.9 & 29.9 \textcolor{codegray}{/ 51.8 / 66.0} & 43.2 & 24.2 \textcolor{codegray}{/ 46.1 / 61.2} \\
    ResNet-152 + SE & 49.4 & 30.0 \textcolor{codegray}{/ 52.3 / 66.7} & 43.5 & 24.6 \textcolor{codegray}{/ 46.8 / 61.8} \\
    LambdaResNet-152 & \textbf{50.0} & \textbf{31.8} \textcolor{codegray}{/ \textbf{53.4} / \textbf{67.0}} & \textbf{43.9} & \textbf{25.5} \textcolor{codegray}{/ \textbf{47.3} / \textbf{62.0}} \\
    \bottomrule
  \end{tabular}
  \caption{
  \textbf{COCO object detection and instance segmentation with Mask-RCNN architecture on 1024x1024 inputs}. 
  Mean Average Precision (AP) for small, medium, large objects (s/m/l). Using lambda layers yields consistent gains across all object sizes, especially small objects.
  }
  \label{tab:detection}
  \vspace{-0.3cm}
  \end{center}
\end{table}
 \section{Discussion}

\paragraph{How do lambda layers compare to the attention operation?} 
Lambda layers scale favorably compared to self-attention.
Vanilla Transformers using self-attention have $\Theta(blhn^2)$ memory footprint, whereas LambdaNetworks
have $\Theta(lkn^2)$ memory footprint (or $\Theta(kn^2)$ when sharing positional embeddings across layers).
This enables the use of lambda layers at higher-resolution and on larger batch sizes.
Additionally, the lambda convolution enjoys a simpler and faster implementation than its local self-attention counterpart.
Finally, our ImageNet experiments show that lambda layers outperforms self-attention, demonstrating that the benefits of lambda layers go beyond improved speed and scalability.

\vspace{-0.1cm}
\paragraph{How are lambda layers different than linear attention mechanisms?}
Lambda layers generalize and extend linear attention formulations to capture \emph{position-based} interactions, which is crucial for modeling highly structured inputs such as images (see Table~\ref{tab:content_vs_position} in Appendix~\ref{sec:content_vs_position}).
As the aim is not to approximate an attention kernel, lambda layers allow for more flexible non-linearities and normalizations which we also find beneficial (see Table~\ref{tab:normalization} in Appendix~\ref{sec:normalization}).
Finally, we propose multi-query lambda layers as a means to reduce complexity compared to the multi-head (or single-head) formulation typically used in linear attention works.
Appendix ~\ref{sec:linear_attention} presents a detailed discussion of linear attention.

\vspace{-0.1cm}
\paragraph{How to best use lambda layers in the visual domain?}
The improved scalability, speed and ease of implementation of lambda layers compared to global or local attention makes them a strong candidate for use in the visual domain.
Our ablations demonstrate that lambda layers are most beneficial in the intermediate and low-resolution stages of vision architectures when optimizing for the speed-accuracy tradeoff.
It is also possible to design architectures that rely exclusively on lambda layers which can be more parameter and flops efficient.
We discuss practical modeling recommendations in Appendix~\ref{sec:practical recommendations}.

\vspace{-0.1cm}
\paragraph{Generality of lambda layers.}
While this work focuses on static image tasks, we note that lambda layers can be instantiated to model interactions on structures as diverse as graphs, time series, spatial lattices, etc.
We anticipate that lambda layers will be helpful in more modalities, including multimodal tasks.
We discuss masked contexts and auto-regressive tasks in the Appendix~\ref{sec:masked_lambda_layer}.

\vspace{-0.1cm}
\paragraph{Conclusion.}
We propose a new class of layers, termed lambda layers, which provide a scalable framework for capturing structured interactions between inputs and their contexts.
Lambda layers summarize available contexts into fixed-size linear functions, termed lambdas, that are directly applied to their associated queries.
The resulting neural networks, LambdaNetworks, are computationally efficient and capture long-range dependencies at a small memory cost, enabling their application to large structured inputs such as high-resolution images.
Extensive experiments on computer vision tasks showcase their versatility and superiority over convolutional and attentional networks.
Most notably, we introduce LambdaResNets, a family of hybrid LambdaNetworks which reach excellent ImageNet accuracies and achieve up to 9.5x speed-ups over the popular EfficientNets, significantly improving the speed-accuracy tradeoff of image classification models. 
\subsubsection*{Acknowledgments}
The author would like to thank Barret Zoph and William Fedus for endless discussions, fruitful suggestions and careful revisions;
Jonathon Shlens, Mike Mozer, Prajit Ramachandran, Ashish Vaswani, Quoc Le, Neil Housby, Jakob Uszkoreit, Margaret Li, Krzysztof Choromanski for many insightful comments;
Hedvig Rausing for the antarctic infographics;
Zolan Brinnes for the OST;
Andrew Brock, Sheng Li for assistance with profiling EfficientNets;
Adam Kraft, Thang Luong and Hieu Pham for assistance with the semi-supervised experiments
and the Google Brain team for useful discussions on the paper.

\bibliography{main}
\bibliographystyle{iclr2021_conference}

\newpage
\appendix
\section{Practical Modeling Recommendations\label{sec:practical recommendations}}

\paragraph{I want to make it faster on TPUs/GPUs...}
Hybrid models reach a better speed-accuracy tradeoff.
Global contexts can be computationally wasteful, especially in the early high resolution layers where features lack semantic information, and can be replaced by lambda convolutions with smaller scopes (e.g. $|m|$=5x5 or 7x7) or the standard 3x3 convolution.
Additionally, using a hybrid can require less tuning when starting from a working model/training setup.

\paragraph{I want to make to minimize FLOPS (e.g.\ embedded applications)...}
Consider a hybrid with inverted bottlenecks, as done in Section~\ref{sec:mobilenets}.
To further reduce FLOPS, prefer lambda convolutions with smaller scopes (e.g. $|m|$=5x5 or 7x7).

\paragraph{I encounter memory issues...}
Memory footprint can be reduced by sharing position embeddings across layers (especially layers with the highest resolution).
Using the lambda convolution is more memory efficient.
Reducing the query depth $|k|$ or increasing the number of heads $|h|$ also decreases memory consumption.

\paragraph{I'm experiencing instability...}
We found it important to initialize the $\gamma$ parameter in the \emph{last} batchnorm layer of the ResNet's bottleneck blocks to 0 (this is the default in most codebases).
Normalizing the keys (i.e.\ with the softmax) along the context's length is important. 
Early experiments which employed 2 lambda layers sequentially in the same residual block were unstable, suggesting that using 2 lambda layers in sequence should be avoided.

\paragraph{Which implementation of the lambda convolution should I use?}
In our experiments using Tensorflow 1.x on TPUv3 hardware, we found both the n-d depthwise and (n+1)-d convolution implementations to have similar speed.
We point out that this can vary across software/hardware stacks.

\paragraph{What if my task doesn't require position-based interactions?}
Computational costs in the lambda layer are dominated by position-based interactions.
If your task doesn't require them, you can try the content-only lambda layer or any other linear attention mechanism.
We recommend using the \emph{multi-query} formulation (as opposed to the usual multi-head) and scaling other dimensions of the model. \newpage
\section{Additional Variants}

\subsection{Complete code with lambda convolution\label{sec:complete_lambda_layer_code}}
\begin{figure}[h]
\small
\begin{lstlisting}[language=python]
# b: batch, n: input length, m: context length, r: scope size, 
# k: query/key depth, v: value depth, h: number of heads, d: output dimension.
def compute_position_lambdas(embeddings, values, impl='einsum'):
    if impl == 'einsum':  # embeddings shape: [n, m, k]
        position_lambdas = einsum(embeddings, values, 'nmk,bmv->bnkv')
    else:  # embeddings shape: [r, k]
        if impl == 'conv':
            embeddings = reshape(embeddings, [r, 1, 1, k])
            values = reshape(values, [b, n, v, 1])
            position_lambdas = conv2d(values, embeddings) 
        elif impl == 'depthwise_conv':
            # Reshape and tile embeddings to [r, v, k] shape
            embeddings = reshape(embeddings, [r, 1, k])
            embeddings = tile(embeddings, [1, v, 1])
            position_lambdas = depthwise_conv1d(values, embeddings) 
        # Transpose from shape [b, n, v, k] to shape [b, n, k, v]
        position_lambdas = transpose(position_lambdas, [0, 1, 3, 2])
    return position_lambdas
    
def lambda_layer(queries, keys, embeddings, values, impl='einsum'):
    """Multi-query lambda layer."""
    content_lambda = einsum(softmax(keys), values, 'bmk,bmv->bkv')
    position_lambdas = compute_position_lambdas(embeddings, values, impl=impl)
    content_output = einsum(queries, content_lambda, 'bhnk,bkv->bnhv')
    position_output = einsum(queries, position_lambdas, 'bhnk,bnkv->bnhv')
    output = reshape(content_output + position_output, [b, n, d])
    return output
\end{lstlisting}
    \caption{
    \textbf{Pseudo-code for the multi-query lambda layer and the 1d lambda convolution.}
    A n-d lambda convolution can equivalently be implemented via a regular (n+1)-d convolution or a n-d depthwise convolution with channel multiplier.
    The embeddings can be made to satisfy various conditions (e.g.\ translation equivariance and masking) when computing positional lambdas with the einsum implementation.
    }
    \label{fig:complete_lambda_layer_code}
\end{figure}

\subsection{Generating lambdas from masked contexts\label{sec:masked_lambda_layer}}
In some applications, such as denoising tasks or auto-regressive training, it is necessary to restrict interactions to a sub-context $\mathcal{C}_n \subset \mathcal{C}$ when generating $\boldsymbol{\lambda}_n$ for query position $n$.
For example, \emph{parallel} auto-regressive training requires masking the future to ensure that the output $\boldsymbol{y}_n$ only depends on past context positions $m < n$.
Self-attention achieves this by zeroing out the irrelevant attention weights $\boldsymbol{a}_{nm'}=0$ $\forall m' \notin \mathcal{C}_n$,  thus guaranteeing that $\boldsymbol{y}_n = \sum_m \boldsymbol{a}_{nm} \boldsymbol{v}_m$ only depends on $\mathcal{C}_n$.

Similarly, one can block interactions between queries and masked context positions when generating lambdas by applying a mask before summing the contributions of context positions. 
As long as the mask is shared across all elements in the batch, computing masked lambdas does not require materializing per-example attention maps and the complexities are the same as for global context case.
See Figure~\ref{fig:masked_lambda_layer_code} for an implementation.

\lstset{style=codestyle}
\begin{figure}[h!]
\small
\begin{lstlisting}[language=python]
def masked_lambda_layer(queries, normalized_keys, embeddings, values, mask):
    """Masked multi-query lambda layer.
    Args:
      queries: a tensor with shape [b, h, n, k].
      normalized_keys: a tensor with shape [b, m, k].
      embeddings: a tensor with shape [k, n, m].
      values: a tensor with shape [b, m, v].
      mask: a tensor of 0 and 1s with shape [n, m].
    """
    # We show the general case but a cumulative sum may be faster for masking the future.
    # Note that each query now also has its own content_lambda since every query 
    # interacts with a different context.
    # Keys should be normalized by only considering the elements in their contexts.
    content_mu = einsum(normalized_keys, values, 'bmk,bmv->bmkv')
    content_lambdas = einsum(content_mu, mask, 'bmkv,nm->bnkv')
    embeddings = einsum(embeddings, mask, 'knm,nm->knm')  # apply mask to embeddings
    position_lambdas = einsum(embeddings, values, 'knm,bmv->bnkv')
    content_output = einsum(queries, content_lambda, 'bhnk,bnkv->bnhv')
    position_output = einsum(queries, position_lambdas, 'bhnk,bnkv->bnhv')
    output = reshape(content_output + position_output, [b, n, d])
    return output
\end{lstlisting}
    \vspace{-0.2cm}
    \caption{\textbf{Pseudo-code for \emph{masked} multi-query lambda layer.}}
    \label{fig:masked_lambda_layer_code}
\end{figure}

\subsection{Multi-head vs multi-query lambda layers}
In this section, we motivate using a multi-query formulation as opposed to the usual multi-head formulation used in self-attention.
Figure~\ref{fig:multihead_lambda_layer_code} presents the implementation of a multi-head lambda layer.
Table~\ref{tab:multihead_vs_multiquery} compares complexities for multi-head and multi-query lambda layers.
Using a multi-query formulation reduces computations by a factor of $|h|$ (the number of queries per lambda) compared to the multi-head formulation.
We also found in early experimentation that multi-query lambdas yield a better speed-accuracy trade-off.
Additionally, the multi-head lambda layer does not enjoy a simple local implementation as the lambda convolution.

\begin{figure}[h]
\small
\begin{lstlisting}[language=python]
def multihead_lambda_layer(queries, keys, embeddings, values, impl='einsum'):
    """Multi-head lambda layer."""
    content_lambda = einsum(softmax(keys), values, 'bhmk,bhmv->bhkv')
    position_lambdas = einsum(embeddings, values, 'hnmk,bhmv->bnhkv')
    content_output = einsum(queries, content_lambda, 'bhnk,bhkv->bnhv')
    position_output = einsum(queries, position_lambdas, 'bhnk,bnkv->bnhv')
    output = reshape(content_output + position_output, [b, n, d])
    return output
\end{lstlisting}
    \caption{
    \textbf{Pseudo-code for the \emph{multi-head} lambda layer.}
    This is only shown as an example as we recommend \emph{multi-query} lambdas instead.
    }
    \label{fig:multihead_lambda_layer_code}
\end{figure}

\begin{table}[h!]
  \begin{center}
  \small
  \begin{tabular}{l|cc}
    \toprule
    Operation & Time complexity & Space complexity \\
    \midrule
    Multi-head lambda layer & $\Theta(bnmkd)$ & $\Theta(knm + bnkd)$ \\
    Multi-query lambda layer & $\Theta(bnmkd/h)$ & $\Theta(hknm + bnkd/h)$ \\
    \bottomrule
  \end{tabular}
  \caption{
  \textbf{Complexity comparison between a multi-head and a multi-query lambda layer.} 
  Using a multi-query formulation reduces complexity by a factor $|h|$ (the number of queries per lambda) compared to the standard multi-head formulation.}
  \label{tab:multihead_vs_multiquery}
\end{center}
\end{table}

\subsection{Adding expressivity with an extra dimension\label{sec:lambda_layer_u}}
We briefly experiment with a variant that enables increasing the cost of \emph{computing} the lambdas while keeping the cost of \emph{applying} them constant.
This is achieved by introducing an additional dimension, termed the intra-depth with corresponding hyperparameter $|u|$, in keys, position embeddings and values.
Each key (or positional embedding) is now a $|k|\times|u|$ matrix instead of a $|k|$-dimensional vector.
Similarly, each value is now a $|v|\times|u|$ matrix instead of a $|v|$-dimensional vector.
The lambdas are obtained via summing over context positions \emph{and the intra-depth position $|u|$} and have  $|k|\times|v|$ shape similar to the default case.
See Figure~\ref{fig:lambda_layer_code_u} for an implementation and Table~\ref{tab:complexity_u} for the complexities.
Experiments (see Appendix~\ref{sec:additional_ablations}) demonstrate that this variant results in accuracy
improvements but we find that using $|u|$=1 (i.e.\ the default case) is optimal when controlling for speed on modern machine learning accelerators.

\begin{figure}[h]
\small
\begin{lstlisting}[language=python]
def compute_position_lambdas(embeddings, values, impl='einsum'):
    """Compute position lambdas with intra-depth u."""
    if impl == 'conv':
        # values: [b, n, v, u] shape
        # embeddings: [r, 1, u, k] shape
        position_lambdas = conv2d(values, embeddings) 
        # Transpose from shape [b, n, v, k] to shape [b, n, k, v]
        position_lambdas = transpose(position_lambdas, [0, 1, 3, 2])
    elif impl == 'einsum':
        # embeddings: [k, n, m, u] shape
        position_lambdas = einsum(embeddings, values, 'knmu,bmvu->bnkv')
    return position_lambdas
    
def lambda_layer(queries, keys, embeddings, values, impl='einsum'):
    """Multi-query lambda layer with intra-depth u."""
    content_lambda = einsum(softmax(keys), values, 'bmku,bmvu->bkv')
    position_lambdas = compute_position_lambdas(embeddings, values, lambda_conv)
    content_output = einsum(queries, content_lambda, 'bhnk,bkv->bnhv')
    position_output = einsum(queries, position_lambdas, 'bhnk,bnkv->bnhv')
    output = reshape(content_output + position_output, [b, n, d])
    return output
\end{lstlisting}
    \caption{
    \textbf{Pseudo-code for the multi-query lambda layer with intra-depth $|u|$}.
    Lambdas are obtained by reducing over the context positions and the intra-depth dimension.
    This variant allocates more computation for generating the lambdas while keeping the cost of applying them constant.
    The equivalent n-d lambda convolution can be implemented with a regular (n+1)-d convolution.
    }
    \label{fig:lambda_layer_code_u}
\end{figure}

\begin{table}[h]
  \begin{center}
  \small
  \begin{tabular}{l|cc}
    \toprule
    Operation & Time complexity & Space complexity \\
    \midrule
    Lambda layer ($|u|>$1) & $\Theta(bnmkud/h)$ & $\Theta(knmu + bnkv)$ \\
    \bottomrule
  \end{tabular}
  \caption{\textbf{Complexity for a multi-query lambda layer with intra-depth $|u|$}.}
  \label{tab:complexity_u}
  \end{center}
\end{table}
 \newpage
\section{Additional Related Work\label{sec:additional_related_work}}
In this section, we review the attention operation and related works on improving its scalability.
We discuss connections between lambda layers and channel, spatial or linear attention mechanisms and show how they can be cast as \emph{less flexible specific instances} of lambda layers.
We conclude with a brief review of self-attention in the visual domain and discuss connections with expert models.

\vspace{-0.1cm}
\subsection{Softmax attention}
\paragraph{Softmax attention}
Softmax-attention produces a distribution over the context for each query $\boldsymbol{q}_n$ as $\boldsymbol{a}_n = \textrm{softmax}(\boldsymbol{K} \boldsymbol{q}_n) \in \mathbb{R}^{|m|}$ where the keys $\boldsymbol{K}$ are obtained from the context $\boldsymbol{C}$.
The attention distribution $\boldsymbol{a}_n$ is then used to form a linear combination of values $\boldsymbol{V}$ obtained from the context as $\boldsymbol{y}_n = \boldsymbol{V}^T \boldsymbol{a}_n = \sum_m a_{nm}\boldsymbol{v}_m \in \mathbb{R}^{|v|}$.
As we take a weighted sum of the values\footnote{
Sometimes the attention operation is instead used to \emph{point} to specific context elements~\citep{vinyals2015pointer,bello2016nco}, which is not supported by lambda layers.}, we transform the query $\boldsymbol{q}_n$ into the output $\boldsymbol{y}_n$ and discard its attention distribution $\boldsymbol{a}_n$.
This operation captures content-based interactions, but not position-based interactions.

\vspace{-0.1cm}
\paragraph{Relative attention}
In order to model position-based interactions, relative attention~\citep{shaw2018relative} introduces a learned matrix of $|m|$ positional embeddings $\boldsymbol{E}_n \in \mathbb{R}^{|m|\times|k|}$ and computes the attention distribution as $\boldsymbol{a}_n = \textrm{softmax}((\boldsymbol{K}+\boldsymbol{E}_n) \boldsymbol{q}_n) \in \mathbb{R}^{|m|}$.
The attention distribution now also depends on the query position $n$ relative to positions of context elements $m$.
Relative attention therefore captures both content-based and position-based interactions.

\vspace{-0.1cm}
\subsection{Sparse attention~\label{sec:sparse_attention}}
A significant challenge in applying (relative) attention to large inputs comes from the \emph{quadratic} $\Theta(|bnm|)$ memory footprint required to store attention maps.
Many recent works therefore propose to impose specific patterns to the attention maps as a means to reduce the context size $|m|$ and consequently the memory footprint of the attention operation.
These approaches include \emph{local} attention patterns~\citep{dai2019xl,parmar2018image,ramachandran2019sasa}, \emph{axial} attention patterns~\citep{ho2019axial,wang2020axialdeeplab}, \emph{static sparse} attention patterns~\citep{child2019sparse,beltagy2020longformer} or \emph{dynamic sparse} attention patterns~\citep{kitaev2020reformer}.
See~\cite{tay2020efficient} for a review.
Their implementations can be rather complex, sometimes require low-level kernel implementations to get computational benefits or may rely on specific assumptions on the shape of the inputs (e.g., axial attention).

In contrast, lambda layers are simple to implement for both global and local contexts using simple einsum and convolution primitives and capture \emph{dense} content and \emph{position-based} interactions with no assumptions on the input shape.

\vspace{-0.1cm}
\subsection{Linear attention: connections and differences~\label{sec:linear_attention}}
Another approach to reduce computational requirements of attention mechanisms consists in approximating the attention operation in linear space and time complexity, which is referred to as linear (or efficient) attention.
Linear attention mechanisms date back to~\cite{debrebisson2016cheap,britz2017efficient} and were later introduced in the visual domain by~\cite{chen2018double,shen2018efficient}.
They are recently enjoying a resurgence of popularity with many works modifying the popular Transformer architecture for sequential processing applications~\citep{katharopoulos2020transformers,wang2020linformer,choromanski2020rethinking}.

\vspace{-0.1cm}
\paragraph{Linear attention via kernel factorization}
Linear attention is typically obtained by reinterpreting attention as a similarity kernel and leveraging a low-rank kernel factorization as
\begin{equation}
    \label{eq:kernel_attention}
    \textrm{Attention}(\boldsymbol{Q},\boldsymbol{K},\boldsymbol{V}) =  \textrm{softmax}(\boldsymbol{Q}\boldsymbol{K}^T)\boldsymbol{V} \sim \phi(\boldsymbol{Q})(\phi(\boldsymbol{K}^T)\boldsymbol{V})
\end{equation}
for some feature function $\phi$.
Computing $\phi(\boldsymbol{K}^T)\boldsymbol{V} \in \mathbb{R}^{|k|\times|v|}$ first bypasses the need to materialize the attention maps $\phi(\boldsymbol{Q})\phi(\boldsymbol{K}^T)$ and the operation therefore has \emph{linear} complexity with respect to the input length $|n|$.

Multiple choices for the feature function $\phi$ have been proposed.
For example,~\cite{katharopoulos2020transformers} use $\phi(\boldsymbol{x}) = \textrm{elu}(\boldsymbol{x}) + 1$, while~\cite{choromanski2020rethinking} use positive orthogonal random features to approximate the original softmax attention kernel.
In the visual domain, both~\cite{chen2018double} and ~\cite{shen2018efficient} use $\phi(\boldsymbol{x}) = \textrm{softmax}(\boldsymbol{x})$.
This choice is made to guarantee that the rows of the (non-materialized) attention maps $\phi(\boldsymbol{Q})\phi(\boldsymbol{K})^T$ sum to 1 as is the case in the regular attention operation.

We discuss the main differences between lambda layers and linear attention mechanisms.

\paragraph{1) Lambda layers extend linear attention to also consider position-based interactions.}
The kernel approximation from Equation~\ref{eq:kernel_attention} can be rewritten for a single query $\boldsymbol{q}_n$ as
\begin{equation}
    \label{eq:kernel_attention_single_query}
    \boldsymbol{y}_n = (\phi(\boldsymbol{K})^T \boldsymbol{V})^T\phi(\boldsymbol{q}_n)
\end{equation}
which resembles the output of the \emph{content lambda} $\boldsymbol{y}_n^c = (\boldsymbol{\lambda}^c)^T \boldsymbol{q}_n = (\boldsymbol{\bar{K}}^T \boldsymbol{V})^T \boldsymbol{q}_n$ from Equation~\ref{eq:generating_lambdas}.
Lambda layers extend linear attention mechanisms to also consider position-based interactions as
\begin{equation}
    \label{eq:lambda_complete}
    \boldsymbol{y}_n = \boldsymbol{\lambda}_n^T \boldsymbol{q}_n = (\boldsymbol{\lambda}^c + \boldsymbol{\lambda}_n^p)^T \boldsymbol{q}_n = ((\boldsymbol{\bar{K}}+\boldsymbol{E}_n)^T\boldsymbol{V})^T\boldsymbol{q}_n
\end{equation}
In the above equation, computing the position (or content) lambda has $\Theta(bmkv)$ time complexity.
As the position lambdas are not shared across query positions $n$, this cost is repeated for all $|n|$ queries, leading to a total time complexity $\Theta(bnmkv)$.
Unlike linear attention mechanisms, lambda layers have \emph{quadratic time complexity} with respect to the input length (in the global context case) because they consider position-based interactions.

\paragraph{2) Lambda layers do not necessarily attempt to approximate an attention kernel.}
While approximations of the attention kernel are theoretically motivated, we argue that they may be unnecessarily restrictive.
For example, the kernel approximation in Equation~\ref{eq:kernel_attention} requires the \emph{same} feature function $\phi$ on both $\boldsymbol{Q}$ and $\boldsymbol{K}$ and precludes the use of more flexible non-linearities and normalization schemes.
In contrast, lambda layers do not attempt to approximate an attention kernel.
This simplifies their design and allows for more flexible non-linearity and normalization schemes, which we find useful in our ablations (See Table~\ref{tab:normalization} in Appendix~\ref{sec:normalization}).
Considering the position embeddings independently of the keys notably enables a simple and efficient local implementation with the lambda convolution.
Approximating the \emph{relative} attention kernel would require normalizing the position embeddings with the keys (i.e., $\phi(\boldsymbol{K} + \boldsymbol{E}_n)$ instead of $\phi(\boldsymbol{K}) + \boldsymbol{E}_n$), which cannot be implemented in the local context case with a convolution.

\paragraph{3) The lambda abstraction reveals the computational benefits of the multi-query formulation.}
Finally, this work proposes to abstract the $\boldsymbol{\bar{K}}^T\boldsymbol{V}$ and $\boldsymbol{E}_n^T\boldsymbol{V}$ matrices as linear functions (the \emph{content} and \emph{position} lambdas) that are directly applied to the queries.
The lambda abstraction reveals the benefits of multi-query formulation (as opposed to the traditional multi-head attention formulation) as a means to reduce computational costs.

\vspace{-0.1cm}
\subsection{Casting channel and spatial attention as lambda layers.~\label{sec:channel_spatial_attention}}
We show that the lambda abstraction generalizes \emph{channel} and \emph{spatial} attention mechanisms, both of which can be viewed as specific instances of lambda layers.
This observation is consistent with our experiments which demonstrate that lambda layers outperform both channel and spatial attention while being more computationally efficient.

\paragraph{Channel attention}
\emph{Channel attention} mechanisms, such as Squeeze-and-Excitation (SE)~\citep{hu2017squeeze,hu2018gather} and FiLM layers~\citep{perez2017film}, recalibrate features via cross-channel interactions by aggregating signals from the entire feature map.
In particular, the SE operation can be written as $y_{nk} = w_k q_{nk}$ where $w_k$ is the excitation weight for channel $k$ in the query $\boldsymbol{q}_n$.
This can be viewed as using a \emph{diagonal} lambda which is \emph{shared across query positions} $\boldsymbol{\lambda}_n = diag(w_1 \cdots w_{|k|})$.
Channel attention mechanisms have proven useful to complement convolutions but cannot be used as a stand-alone layer as they discard spatial information.

\paragraph{Spatial attention}
Conversely, \emph{spatial attention} mechanisms, reweigh each position based on signals aggregated from all channels~\citep{xu2015show,park2018bam,woo2018cbam}.
These mechanisms can be written as $y_{nk} = w_n q_{nk}$ where $w_n$ is the attention weight for position $n$ in the input query $\boldsymbol{Q}$.
This can be viewed as using (position-dependent) scalar lambdas $\boldsymbol{\lambda_n} = w_n \mathbb{I}$ where $\mathbb{I}$ is the identity matrix.
Spatial attention has also proven helpful to complement convolutions but cannot be used as a stand-alone layer as it discards channel information.

\vspace{-0.1cm}
\subsection{Self-Attention in the visual domain~\label{sec:self_attention_vision}}
Self-attention has been used in a myriad of tasks in the visual domain.
These include
image classification~\citep{bello2019aacn,ramachandran2019sasa,cordonnier2019relationship,zhao2020exploring,wu2020visual,dosovitskiy2020image}; 
object detection and object-centric tasks~\citep{wang2018non,hu2018relation,carion2020endtoend,locatello2020objectcentric}; video tasks~\citep{sun2019videobert,liao2019videobased};
autoregressive/adversarial generative modeling~\citep{parmar2018image,zhang2019selfattention,brock2019large,chen2020igpt} and
multi-modal text-vision tasks~\citep{chen2020uniter,lu2019vilbert,li2019visualbert,radford2021clip}

The first use of self-attention in vision dates back to the non-local block~\citep{wang2018non}, which added a single-head global self-attention residual in the low resolution stages of a ConvNet for long-range dependency modeling. 
The non-local block has proven useful to complement convolutions but cannot be used as a stand-alone layer as it does not model position-based interactions.

\paragraph{\emph{Global} relative attention replaces convolutions at \emph{low} resolution.}
~\cite{bello2019aacn} introduced a 2d relative attention mechanism that proved competitive as a replacement to convolutions but gives even stronger results when used to concatenate convolutional features with self-attention features.
The spatial convolutions in the bottleneck block of the ResNet architecture were replaced with a \emph{global multi-head} self-attention mechanism with \emph{2d relative position embeddings}.
Due to the large memory constraints of global attention, this operation was restricted to low resolution feature maps and the proposed architecture was a \emph{conv-transformer} hybrid.

A similar hybrid design has recently been revisited by~\cite{srinivas2021bottleneck} using modern training and scaling techniques. 
\cite{srinivas2021bottleneck}, rather than concatenating convolutional feature maps, propose to use a stride of 1 in the last stage of the ResNet architecture for improved performance.

\paragraph{\emph{Local/axial} relative attention replaces convolutions at \emph{high} resolution.}
The large memory footprint of global attention was quickly solved by multiple works which proposed to limit the size of the attention contexts such as \emph{local} attention~\citep{ramachandran2019sasa,hu2019local} and \emph{axial} attention ~\citep{ho2019axial,wang2020axialdeeplab,shen2020global} (See Section~\ref{sec:sparse_attention}).
Such approaches enable using attention at higher resolution and facilitate fully-attentional models but can be slow due to the use of specialized attention patterns.

\paragraph{Scaling trumps inductive bias}
Concurrently to this work, ViT~\citep{dosovitskiy2020image} propose to simply apply attention on \emph{pixel patches} (as opposed to individual pixels) as a remedy to large memory requirements.
While patch-based attention does not maintain accurate positional information or translation equivariance, the loss of inductive bias is recovered by pre-training on large-scale datasets (e.g.\ 300M images).
Most remarkably, ViT achieves close to state-of-the-art accuracy when fine-tuned on the ImageNet dataset, while requiring less training compute that convolutional alternatives~\citep{kolesnikov2020big,xie2020selftraining}.
This result has reinvigorated interest in using self-attention in the visual domain with multiple follow-up works already building upon this approach~\citep{touvron2021training}\footnote{Most follow-up works advertise improvements over ViT on smaller datasets which is not the intended purpose of ViT.}.
In spite of the impressive image classification results, concerns remain as to whether the patch-based approach can scale to larger images and transfer to tasks that require precise localization such as detection.

We stress that reducing memory by working with pixel patches is orthogonal to the specific operation used
and we anticipate that lambda layers (or linear attention) can successfully be used complementary to pixel patches.

\vspace{-0.1cm}
\subsection{Connections to HyperNetworks and expert models}
LambdaNetworks generate their own computations, i.e.\ lambdas such that $\boldsymbol{y}_n=\boldsymbol{\lambda}_n \boldsymbol{q}_n$.
As such, they can alternatively be viewed as an extension of HyperNetworks~\citep{ha2016hypernetworks} that \emph{dynamically} generate their computations based on \emph{contextual information}.

Lastly, LambdaNetworks share some connections with sparsely-activated expert models~\citep{shazeer2017outrageously,fedus2021switch}.
Whereas sparsely-activated expert models \emph{select} the computation (i.e.\ the lambda) from a bank of weights based on the input query, LambdaNetworks \emph{generate} their computations based on contextual information (including the input query).
 \newpage
\section{Additional Experiments\label{sec:additional_experiments}}

\subsection{Ablation study~\label{sec:additional_ablations}}
We perform several ablations and validate the importance of positional interactions, long-range interactions and flexible normalization schemes.
Unless specified otherwise, all experimental results in this section report ImageNet accuracies obtained by training a LambdaNetwork architecture that replaces the spatial convolutions in the ResNet-50 with lambda layers.

\vspace{-0.1cm}
\paragraph{Varying query depth, number of heads and intra-depth.\label{sec:kh_ablations}}
Table~\ref{tab:ablations} presents the impact of the query depth $|k|$, number of heads $|h|$ and intra depth $|u|$ on performance (See Appendix~\ref{sec:lambda_layer_u} for a presentation of the intra-depth $|u|$).
Our experiments indicate that the lambda layer outperforms convolutional and attentional baselines for a wide range of hyperparameters, demonstrating the robustness of the method.

\begin{table}[h]
  \begin{center}
  \small
  \begin{tabular}{ccrrrrr}
    \toprule
    $|k|$ & $|h|$ & $|u|$ & Params (M) & top-1 \\
    \midrule
    \multicolumn{3}{c}{ResNet baseline} & 25.6 & 76.9 \\
    \midrule
    8 & 2 & 1 & 14.8 & 77.2 \\
    8 & 16 & 1 & 15.6 & 77.9 \\
    \midrule
    2 & 4 & 1 & 14.7 & 77.4 \\
    4 & 4 & 1 & 14.7 & 77.6 \\
    8 & 4 & 1 & 14.8 & 77.9 \\
    16 & 4 & 1 & 15.0 & 78.4 \\
    32 & 4 & 1 & 15.4 & 78.4 \\
    \midrule
    2 & 8 & 1 & 14.7 & 77.8 \\
    4 & 8 & 1 & 14.7 & 77.7 \\
    8 & 8 & 1 & 14.7 & 77.9 \\
    16 & 8 & 1 & 15.1 & 78.1 \\
    32 & 8 & 1 & 15.7 & 78.5 \\
    \midrule
    8 & 8 & 4 & 15.3 & 78.4 \\
    8 & 8 & 8 & 16.0 & 78.6 \\
    16 & 4 & 4 & 16.0 & 78.9 \\
    \bottomrule
  \end{tabular}
  \caption{
  \textbf{Ablations on the ImageNet classification task when using the lambda layer in a ResNet50 architecture.}
  All configurations outpeform the convolutional baseline at a lower parameter cost.
  As expected, we get additional improvements by increasing the query depth $|k|$ or intra-depth $|u|$. 
  The number of heads is best set to intermediate values such as $|h|$=4.
  A large number of heads $|h|$ excessively decreases the value depth $|v|=d/|h|$, while a small number of heads translates to too few queries, both of which hurt performance.
  }
  \label{tab:ablations}
  \end{center}
\end{table}

\vspace{-0.1cm}
\paragraph{Content vs position interactions\label{sec:content_vs_position}}
Table~\ref{tab:content_vs_position} presents the relative importance of content-based and position-based interactions on the ImageNet classification task.
We find that position-based interactions are crucial to reach high accuracies, while content-based interactions only bring marginal improvements over position-based interactions\footnote{This observation is challenged by concurrent work~\citep{dosovitskiy2020image} which demonstrates that content-based interactions can be sufficient for image classification when pre-training on large scale datasets (e.g.\ 300M images).}.

\begin{table}[h]
  \begin{center}
  \small
  \begin{tabular}{ccccc}
    \toprule
    Content & Position & Params (M) & FLOPS (B) & top-1 \\
    \midrule
    \checkmark & $\times$ & 14.9 & 5.0 & 68.8 \\
    $\times$ & \checkmark & 14.9 & 11.9 & 78.1 \\
    \checkmark & \checkmark & 14.9 & 12.0 & 78.4 \\
    \bottomrule
  \end{tabular}
  \caption{\textbf{Contributions of content and positional interactions}. As expected, positional interactions are crucial to perform well on the image classification task.}
  \label{tab:content_vs_position}
\end{center}
\end{table}

\vspace{-0.1cm}
\paragraph{Importance of scope size\label{sec:scope_ablations}}
The small memory footprint of LambdaNetworks enables considering global contexts, even at relatively high resolution.
Table~\ref{tab:scope_sizes} presents flops counts and top-1 ImageNet accuracies when varying scope sizes in a LambdaNetwork architecture.
We find benefits from using larger scopes, with a plateau around $|m|$=15x15, which validates the importance of longer range interactions compared to the usual 3x3 spatial convolutions used in the ResNet architecture.
In our main experiments, we choose $|m|$=23x23 as the default to account for experiments that use larger image sizes.

\begin{table}[h]
  \begin{center}
  \small
  \begin{tabular}{lrrrrrr}
    \toprule
    Scope size $|m|$ & 3x3 & 7x7 & 15x15 & 23x23 & 31x31 & global \\
    \midrule
    FLOPS (B) & 5.7 & 6.1 & 7.8 & 10.0 & 12.4 & 19.4 \\
    Top-1 Accuracy & 77.6 & 78.2 & 78.5 & 78.3 & 78.5 & 78.4 \\
    \bottomrule
  \end{tabular}
  \caption{
  \textbf{Impact of varying the scope size for positional lambdas on the ImageNet classification task}.
  We replace the 3x3 spatial convolutions in the \emph{last 2 stages} of a ResNet-50 with lambda layers (input image size is 224x224).
  Flops significantly increase with the scope size, however we stress that larger scopes do not translate to slower latencies when using the einsum implementation (see Figure~\ref{fig:lambda_layer_code}).
  }
  \label{tab:scope_sizes}
  \end{center}
\end{table}


\vspace{-0.1cm}
\paragraph{Normalization\label{sec:normalization}}
Table~\ref{tab:normalization} ablates normalization operations in the design of the lambda layer.
We find that normalizing the keys is crucial for performance and that other normalization functions besides the softmax can be considered.
Applying batch normalization to the queries and values is also helpful.

\begin{table}[h]
  \begin{center}
  \small
  \begin{tabular}{lr}
    \toprule
    Normalization & top-1 \\
    \midrule
    Softmax on keys (default) & 78.4 \\
    Softmax on keys \& Softmax on queries & 78.1 \\
    L2 normalization on keys & 78.0 \\
    No normalization on keys & 70.0 \\
    \midrule
    No batch normalization on queries and values & 76.2 \\
    \bottomrule
  \end{tabular}
  \caption{
  \textbf{Impact of normalization schemes in the lambda layer.}
  Normalization of the keys along the context spatial dimension $m$, normalization of the queries along the query depth $k$.
  }
  \label{tab:normalization}
  \end{center}
\end{table}

\subsection{Hybrid models study}
In this section, we study hybrid designs that use standard convolutions to capture local contexts and lambda layers to capture global contexts.\footnote{We could alternatively use the lambda convolution to capture local contexts.}

\vspace{-0.1cm}
\paragraph{Where are lambda layers most useful?}
Table~\ref{tab:hybrid_lambdanetworks} presents the throughputs and accuracies of hybrid LambdaNetwork architectures as a function of the location of convolutions and lambda layers in a ResNet-50 architecture.
We observe that lambda layers are most helpful in the last two stages (commonly referred to as \emph{c4} and \emph{c5}) when considering their speed-accuracy tradeoff.
We refer to architectures that replaces 3x3 convolutions in the last 2 stages of the ResNet with lambda layers as LambdaResNet-\textbf{C4}.

\begin{table}[h]
  \begin{center}
  \small
  \begin{tabular}{cccc}
    \toprule
    Architecture & Params (M) & Throughput & top-1 \\
    \midrule
    \textbf{C} $\rightarrow$ \textbf{C} $\rightarrow$ \textbf{C} $\rightarrow$ \textbf{C} & 25.6 & 7240 ex/s & 76.9 \\
    \textbf{L} $\rightarrow$ \textbf{C} $\rightarrow$ \textbf{C} $\rightarrow$ \textbf{C} & 25.5 & 1880 ex/s & 77.3 \\
    \textbf{L} $\rightarrow$ \textbf{L} $\rightarrow$ \textbf{C} $\rightarrow$ \textbf{C} & 25.0 & 1280 ex/s & 77.2 \\
    \textbf{L} $\rightarrow$ \textbf{L} $\rightarrow$ \textbf{L} $\rightarrow$ \textbf{C} & 21.7 & 1160 ex/s & 77.8 \\
    \midrule
    \textbf{L} $\rightarrow$ \textbf{L} $\rightarrow$ \textbf{L} $\rightarrow$ \textbf{L} & 15.0 & 1160 ex/s & 78.4 \\
    \textbf{C} $\rightarrow$ \textbf{L} $\rightarrow$ \textbf{L} $\rightarrow$ \textbf{L} & 15.1 & 2200 ex/s & 78.3 \\
    \textbf{C} $\rightarrow$ \textbf{C} $\rightarrow$ \textbf{L} $\rightarrow$ \textbf{L} & 15.4 & 4980 ex/s & 78.3 \\
    \textbf{C} $\rightarrow$ \textbf{C} $\rightarrow$ \textbf{C} $\rightarrow$ \textbf{L} & 18.8 & 7160 ex/s & 77.3 \\
    \bottomrule
  \end{tabular}
  \caption{
  \textbf{Hybrid models achieve a better speed-accuracy trade-off.} 
  Inference throughput and top-1 accuracy as a function of lambda (L) vs convolution (C) layers' placement in a ResNet50 architecture on 224x224 inputs.
  Lambda layers in the \emph{c5} stage incur almost no speed decrease compared to standard 3x3 convolutions.
  Lambda layers in the \emph{c4} stage are relatively slower than standard 3x3 convolutions but yield significant accuracy gains.
  }
  \label{tab:hybrid_lambdanetworks}
\end{center}
\end{table}

\begin{table}[h]
  \begin{center}
  \small
  \begin{tabular}{lcrrr}
    \toprule
    Config & Image size & Params (M) & Throughput & top-1 \\
\midrule
    ResNet-101 wo/ SE & 224 & 44.6 & 4600 ex/s & 81.3 \\
    ResNet-101 w/ SE & 224 & 63.6 & 4000 ex/s & 81.8 \\
    LambdaResNet-101 & 224 & 36.9 & \textbf{4040 ex/s} & \textbf{82.3} \\
    LambdaResNet-101-C4 & 224 & 26.0 & 2560 ex/s & 82.6 \\
\midrule
    ResNet-152 wo/ SE & 256 & 60.2 & 2780 ex/s & 82.5 \\
    ResNet-152 w/ SE & 256 & 86.6 & 2400 ex/s & 83.0 \\
    LambdaResNet-152 & 256 & 51.4 & \textbf{2400 ex/s} & \textbf{83.4} \\
    LambdaResNet-152-C4 & 256 & 35.1 & 1480 ex/s & 83.4 \\
    \bottomrule
  \end{tabular}
  \caption{
  \textbf{Impact of number of lambda layers in the c4 stage of LambdaResNets.} 
  Most benefits from lambda layers can be obtained by having a few lambda layers in the \emph{c4} stage. 
  Such hybrid designs maximize the speed-accuracy tradeoff.
  LambdaResNet-C4 architectures exclusively employ lambda layers in \emph{c4} and \emph{c5}.
  LambdaResNet block configurations can be found in Table~\ref{tab:block_config_details}.
  Models are trained for 350 epochs on the ImageNet classification task.
  }
  \label{tab:c4_hybrid}
\end{center}
\end{table}

\vspace{-0.1cm}
\paragraph{Further pushing the speed-accuracy Pareto frontier.}
In Table~\ref{tab:c4_hybrid}, we further study how throughput and accuracy are impacted by the number of lambda layers in the \emph{c4} stage.
Our results reveal that most benefits from lambda layers can be obtained by \textbf{(a)} replacing a few 3x3 convolutions with lambda layers in the \emph{c4} stage and \textbf{(b)} replacing all 3x3 convolutions in \emph{c5}.
The resulting hybrid LambdaResNets architectures have increased representational power at a virtually negligible decrease in throughput compared to their vanilla ResNet counterparts.
Table~\ref{tab:block_config_details} presents the detailed block configurations and placement of lambda layers for our family of LambdaResNets.

\paragraph{Comparing hybrid lambda vs attention models.}
The memory savings of lambda layers compared to attention are less significant in the aforementioned hybrid design, since the operations occur at lower resolution.
Therefore, it is natural to ask whether lambda layers still have benefits over self-attention when considering hybrid designs.
We consider our largest hybrid as an example (see Table~\ref{tab:block_config_details}).
LambdaResNet-420 is trained on 320x320 inputs, employs 8 lambda layers in \emph{c4} and can fit 32 examples per TPU-v3 core.
This adds up to a cost of 38.4MB for lambda layers (4.8MB if sharing positional embeddings), whereas using attention layers instead would incur 0.625GB.
The increase might not be significant in practice and it will be interesting to carefully benchmark the hybrid attention variants\footnote{We will benchmark such architectures in a future version of this draft.}.
We point that experiments from Table~\ref{tab:memory_comparison} suggest that the benefits of lambda layers go beyond improved scalability and stress that the memory savings are more pronounced for tasks that require larger inputs such as object detection.

\subsection{Computational efficiency results}
\subsubsection{Computational efficiency comparisons to large EfficientNets}
In Table~\ref{tab:parameter_efficient} and Table~\ref{tab:flops_efficient}, we showcase the parameter and flops-efficiency of LambdaNetworks.
We find that LambdaResNet-C4 which replaces the 3x3 convolutions in the last 2 stages of the ResNet architecture, where they incur the highest parameter costs, improves upon parameter and flops efficiency of large EfficientNets.
These results are significant because EfficientNets were specifically designed by neural architecture search~\citep{zoph2017neural} to minimize computational costs using highly computationally efficient depthwise convolutions~\citep{tan2019efficientnet}.

\begin{table}[h!]
    \begin{center}
    \small
    \begin{tabular}{lccc}
    \toprule
    Architecture & Image size & Params (M) & top-1 \\
    \midrule
    EfficientNet-B6 & 528x528 & 43 & 84.0 \\
    LambdaResNet-152-C4 & 320x320 & \textbf{35} & 84.0 \\
    LambdaResNet-200-C4 & 320x320 & 42 & \textbf{84.3} \\
    \bottomrule
    \end{tabular}
    \caption{
    \textbf{Parameter-efficiency comparison between LambdaResNet-C4 and EfficientNet-B6}.
    LambdaResNet-C4 is more parameter-efficient in spite of using a smaller image size.
    Increasing the image size would likely result in improved accuracy while keeping the number of parameters fixed. Models are trained for 350 epochs.}
    \label{tab:parameter_efficient}
    \end{center}
\end{table}

\begin{table}[h!]
    \begin{center}
    \small
    \begin{tabular}{lccc}
    \toprule
    Architecture & Image size & Flops (G) & top-1 \\
    \midrule
    EfficientNet-B6 & 528x528 & 38 & \textbf{84.0} \\
    LambdaResNet-270-C4 ($|m|$=7x7) & 256x256 & \textbf{34} & \textbf{84.0} \\
    \bottomrule
    \end{tabular}
    \caption{
    \textbf{Flops-efficiency comparison between LambdaResNet-C4 and EfficientNet-B6}.
    We use smaller local scopes ($|m|$=7x7) to reduce FLOPS in the lambda layers. Models are trained for 350 epochs.}
    \label{tab:flops_efficient}
    \end{center}
\end{table}

\subsubsection{Lambda layers in a resource constrained scenario \label{sec:mobilenets}}
Lastly, we briefly study lambda layers in a resource-constrained scenario using the MobileNetv2 architecture~\citep{sandler2018mobilenetv2}.
MobileNets~\citep{howard2017mobilenets,sandler2018mobilenetv2,howard2019searching} employ lightweight inverted bottleneck blocks which consist of the following sequence: 1) a pointwise convolution for expanding the number of channels, 2) a depthwise convolution for spatial mixing and 3) a final pointwise convolution for channel mixing.
The use of a depthwise convolution (as opposed to a regular convolution) reduces parameters and flops, making inverted bottlenecks particularly well-suited for embedded applications.

\paragraph{Lightweight lambda block.}
We construct a lightweight lambda block as follows.
We replace the depthwise convolution in the inverted bottleneck with a lambda convolution with small scope size $|m|$=5x5, query depth $|k|$=32, number of heads $|h|$=4.
We also change the first pointwise convolution to output the same number of channels (instead of increasing the number of channels) to further reduce computations.

\paragraph{Adding lambda layers in MobileNetv2.}
We wish to assess whether lambda layers can improve the flops-accuracy (or parameter-accuracy) tradeoff of mobilenet architectures.
We experiment with a simple strategy of replacing a few inverted bottlenecks with our proposed lightweight lambda block, so that the resulting architectures have similar computational demands as their baselines.
A simple procedure of replacing the 10-th and 16-th inverted bottleneck blocks with lightweight lambda blocks in the MobileNet-v2 architecture reduces parameters and flops by $\sim$10\% while improving ImageNet accuracy by 0.6\%.
This suggest that lambda layers may be well suited for use in resource constrained scenarios such as embedded vision applications~\citep{howard2017mobilenets,sandler2018mobilenetv2,howard2019searching}.

\begin{table}[h!]
  \begin{center}
  \small
  \begin{tabular}{lccc}
    \toprule
    Architecture & Params (M) & FLOPS (M) & top-1 \\
    \midrule
    MobileNet-v2 & 3.50 & 603 & 72.7 \\
    MobileNet-v2 with 2 lightweight lambda blocks & \textbf{3.21} & \textbf{563} & \textbf{73.3} \\
    \bottomrule
  \end{tabular}
  \caption{
  \textbf{Lambda layers improve ImageNet accuracy in a resource-constrained scenario.}
  Replacing the 10-th and 16-th inverted bottleneck blocks with lightweight lambda blocks in the MobileNet-v2 architecture reduces parameters and flops by $\sim$10\% while improving ImageNet accuracy by 0.6\%.
  }
  \label{tab:mobilenets}
  \end{center}
\end{table} \newpage
\section{Experimental Details\label{sec:experimental_details}}

\subsection{Architectural details\label{sec:architecture_details}}

\vspace{-0.1cm}
\paragraph{Lambda layer implementation details\label{sec:implementation_details}}
Unless specified otherwise, all lambda layers use query depth $|k|$=16, $|h|$=4 heads and intra-depth $|u|$=1.
The \emph{position} lambdas are generated with local contexts of size $|m|$=23x23 and the \emph{content} lambdas with the global context using the einsum implementation as described in Figure~\ref{fig:lambda_layer_code}.
Local positional lambdas can be implemented interchangeably with the lambda convolution or by using the \emph{global} einsum implementation and masking the position embeddings outside of the local contexts (Figure~\ref{fig:complete_lambda_layer_code}).
The latter can be faster but has higher FLOPS and memory footprint due to the $\Theta(knm)$ term (see Table~\ref{tab:interactions_alternatives}).
In our experiments, we use the convolution implementation only for input length $|n|>85^2$ or intra-depth $|u|>1$.
When the intra-depth is increased to $|u|>$1, we switch to the convolution implementation and reduce the scope size to $|m|$=7x7 to reduce flops.

Positional embeddings are initialized at random using the unit normal distribution $\mathcal{N}(0, 1)$.
We use fan-in initialization for the linear projections in the lambda layer.
The projections to compute $\boldsymbol{K}$ and $\boldsymbol{V}$ are initialized at random with the $\mathcal{N}(0,|d|^{-1/2})$ distribution.
The projection to compute $\boldsymbol{Q}$ is initialized at random with the $\mathcal{N}(0, |kd|^{-1/2})$ distribution (this is similar to the \emph{scaled} dot-product attention mechanism, except that the scaling is absorbed in the projection).
We apply batch normalization on $\boldsymbol{Q}$ and $\boldsymbol{V}$ and the keys $\boldsymbol{K}$ are normalized via a softmax operation.

\vspace{-0.1cm}
\paragraph{ResNets.}
We use the ResNet-v1 implementation and initialize the $\gamma$ parameter in the last batch normalization~\citep{BatchNorm} layer of the bottleneck blocks to $0$.
Squeeze-and-Excitation layers employ a squeeze ratio of 4.
Similarly to ResNet-RS~\citep{bello2021revisiting}, we use the ResNet-D~\citep{he2018bag} and additionally replace the max pooling layer in the stem by a strided 3x3 convolution.
Our block allocation and scaling strategy (i.e.\ selected resolution as a function of model depth) also follow closely the scaling recommendations from ResNet-RS~\citep{bello2021revisiting}.

\vspace{-0.1cm}
\paragraph{LambdaResNets.}
We construct our LambdaResNets by replacing the spatial 3x3 convolutions in the bottleneck blocks of the ResNet-RS architectures by our proposed lambda layer, with the exception of the stem which is left unchanged.
We apply 3x3 average-pooling with stride 2 after the lambda layers to downsample in place of the strided convolution.
Lambda layers are uniformly spaced in the \texttt{c4} stage and all bottlenecks in \texttt{c5} use lambda layers.
Table~\ref{tab:block_config_details} presents the exact block configuration and the location of the lambda layers for our hybrid LambdaResNets.
We do not use squeeze-and-excitation in the bottleneck blocks that employ a lambda layer instead of the standard 3x3 convolution.
    
\begin{table}[h]
    \begin{center}
    \small
    \begin{tabular}{l|cc}
    \toprule
    Model & Block Configuration & Lambda layers in \texttt{c4} \\
    \midrule
    LambdaResNet-50 & \texttt{[3-4-6-3]} & 3 \\
    LambdaResNet-101 & \texttt{[3-4-23-3]} & 6, 12, 18 \\
    LambdaResNet-152 & \texttt{[3-8-36-3]} & 5, 10, 15, 20, 25, 30 \\ 
    LambdaResNet-200 & \texttt{[3-24-36-3]} & 5, 10, 15, 20, 25, 30 \\ 
    LambdaResNet-270 & \texttt{[4-29-53-4]} & 8, 16, 24, 32, 40, 48 \\
    LambdaResNet-350 & \texttt{[4-36-72-4]} & 10, 20, 30, 40, 50, 60 \\
    LambdaResNet-420 & \texttt{[4-44-87-4]} & 10, 20, 30, 40, 50, 60, 70, 80 \\
    \bottomrule
    \end{tabular}
    \end{center}
    \caption{\textbf{Block configurations and lambda layers placement of LambdaResNets in the Pareto curves}.
    LambdaResNets use the block allocations from~\cite{he2015deep,bello2021revisiting}.}
    \label{tab:block_config_details} 
\end{table}

\begin{table}[h!]
\begin{center}
    \begin{tabular}{ccc|cc}
    \toprule
    Depth & Image size & Latency (s) & Supervised top-1 & Pseudo-labels top-1 \\
    \midrule
    50 & 128 & 0.058 & 77.4 & 82.1 \\
    50 & 160 & 0.089 & 79.2 & 83.4 \\
    101 & 160 & 0.14 & 80.8 & 84.7 \\
    101 & 192 & 0.20 & 81.9 & 85.4 \\
    152 & 192 & 0.28 & 82.5 & 86.1 \\
    152 & 224 & 0.38 & 83.2 & 86.5 \\
    152 & 256 & 0.49 & 83.8 & - \\
    152 & 288 & 0.63 & - & 86.7 \\
    270 & 256 & 0.91 & 84.2 & - \\
    350 & 256 & 1.16 & 84.4 & - \\
    350 & 288 & 1.48 & 84.5 & - \\
    350 & 320 & 1.91 & 84.7 & - \\
    420 & 320 & 2.25 & 84.9 & - \\
    \bottomrule
    \end{tabular}
\end{center}
\caption{
\textbf{Detailed LambdaResNets results}.
Latency refers to the time per training step for a batch size of 1024 on 8 TPU-v3 cores using \texttt{bfloat16} activations.
}
\label{tab:pareto_curve_details} 
\end{table}

\subsection{Training details\label{sec:training_details}}

\vspace{-0.1cm}
\paragraph{ImageNet training setups.}
We consider two training setups for the ImageNet classification task.
The 90 epochs training setup trains models for 90 epochs using standard preprocessing and allows for fair comparisons with classic works.
The 350 epochs training setup trains models for 350 epochs using improved data augmentation and regularization
and is closer to training methodologies used in modern works with state-of-the-art accuracies.

\vspace{-0.1cm}
\paragraph{Supervised ImageNet 90 epochs training setup with vanilla ResNet.}
In the 90 epoch setup, we use the \emph{vanilla} ResNet for fair comparison with prior works.
We used the default hyperparameters as found in official implementations without doing additional tuning.
All networks are trained end-to-end for 90 epochs via backpropagation using SGD with momentum 0.9.
The batch size $B$ is 4096 distributed across 32 TPUv3 cores~\citep{jouppiTPU} and the weight decay is set to 1e-4.
The learning rate is scaled linearly from 0 to 0.1B/256 for 5 epochs and then decayed using the cosine schedule~\citep{loshchilov2016sgdr}.
We use batch normalization with decay 0.9999 and exponential moving average with weight 0.9999 over trainable parameters and a label smoothing of 0.1.
The input image size is set to 224x224.
We use standard training data augmentation (random crops and horizontal flip with 50\% probability).

Most works compared against in Table~\ref{tab:resnet50} use a similar training setup and also replace the 3x3 spatial convolutions in the ResNet architecture by their proposed methods.
We note that ~\cite{ramachandran2019sasa} train for longer (130 epochs instead of 90) but do not use label smoothing which could confound our comparisons.

\vspace{-0.1cm}
\paragraph{Supervised ImageNet 350 epochs training setup.}
Higher accuracies on ImageNet are commonly obtained by training longer with increased augmentation and regularization~\citep{lee2020compounding,tan2019efficientnet}.
Similarly to~\cite{bello2021revisiting}, the weiht decay is reduced to 4e-5 and we employ RandAugment~\citep{cubuk2019randaugment} with 2 layers, dropout~\citep{JMLR:v15:srivastava14a} and stochastic depth~\citep{huang2016deep}.
See Table~\ref{tab:pareto_curve_hparams} for exact hyperparameters.
All architectures are trained for 350 epochs with a batch size B of 4096 or 2048 distributed
across 32 or 64 TPUv3 cores, depending on memory constraints.

We tuned our models using a held-out validation set comprising $\sim$2\% of the ImageNet training set (20 shards out of 1024).
We perform early stopping on the held-out validation set for the largest models, starting with LambdaResNet-350 at resolution 288x288, and simply report the final accuracies for the smaller models.

\begin{table}[h!]
\begin{center}
\begin{tabular}{cc|ccc}
    \toprule
    Depth & Image Size & RandAugment magnitude & Dropout & Stochastic depth rate \\
    \midrule
    50 & 128 & 10 & 0.2 & 0 \\
    50 & 160 & 10 & 0.2 & 0 \\
    101 & 160 & 10 & 0.3 & 0 \\
    101 & 192 & 15 & 0.2 & 0 \\
    152 & 192 & 15 & 0.3 & 0 \\
    152 & 224 & 15 & 0.3 & 0.1 \\
    152 & 256 & 15 & 0.3 & 0.1 \\
    152 & 288 & 15 & 0.3 & 0.1 \\
    270 & 256 & 15 & 0.3 & 0.1 \\
    350 & 256 & 15 & 0.3 & 0.2 \\
    350 & 288 & 15 & 0.3 & 0.2 \\
    350 & 320 & 15 & 0.3 & 0.2 \\
    420 & 320 & 15 & 0.3 & 0.2 \\
    \bottomrule
\end{tabular}
\end{center}
\caption{
\textbf{Hyperparameters used to train LambdaResNets}. We train for 350 epochs with RandAugment, dropout and stochastic depth.}
\label{tab:pareto_curve_hparams} 
\end{table}

\vspace{-0.1cm}
\paragraph{Semi-supervised learning with pseudo-labels.}
Our training setup closely follows the experimental setup from~\cite{xie2020selftraining}.
We use the same dataset of 130M filtered and balanced JFT images with pseudo-labels generated by an EfficientNet-L2 model with 88.4\% ImageNet accuracy.
Hyperparameters are the same as for the supervised ImageNet 350 epochs experiments.

\vspace{-0.1cm}
\paragraph{Latency measurements.}
Figure~\ref{fig:supervised_pareto_curve} reports training latencies (i.e.\ time per training step) to process a batch of 1024 images on 8 TPUv3 cores using mixed precision training (\i.e \texttt{bfloat16} activations).
Training latency is originally measured on 8 TPUv3 cores, starting with a total batch size of 1024 (i.e.\ 128 per core) and dividing the batch size by 2 until it fits in memory.
We then report the \emph{normalized} latencies in Figure~\ref{fig:supervised_pareto_curve}.
For example, if latency was measured with a batch size of 512 (instead of 1024), we normalize the reported latency by multiplying the measured latency by 2.
Table~\ref{tab:memory_comparison}, Table~\ref{tab:hybrid_lambdanetworks} and Table~\ref{tab:c4_hybrid} report \emph{inference} throughput on 8 TPUv3 cores using full precision (i.e.\ \texttt{float32} activations).
Latency for ViT~\citep{dosovitskiy2020image} was privately communicated by the authors.

\vspace{-0.1cm}
\paragraph{FLOPS count.}
We do not count zeroed out flops when computing positional lambdas with the einsum implementation from Figure~\ref{fig:lambda_layer_code}.
Flops count is highly dependent on the scope size which is rather large by default ($|m|$=23x23).
In Table~\ref{tab:scope_sizes}, we show that it is possible to significantly reduce the scope size and therefore FLOPS at a minimal degradation in performance.

\vspace{-0.1cm}
\paragraph{COCO object detection.}
We employ the architecture from the improved ImageNet training setup as the backbone in the Mask-RCNN architecture.
All models are trained on 1024x1024 images from scratch for 130k steps with a batch size of 256 distributed across 128 TPUv3 cores with synchronized batch normalization.
We apply multi-scale jitter of [0.1, 2.0] during training.
The learning rate is warmed up for 1000 steps from 0 to 0.32 and divided by 10 at steps 90, 95 and 97.5\% of training.
The weight decay is set to 4e-5.

\vspace{-0.1cm}
\paragraph{Mobilenet training setup.}
All mobilenet architectures are trained for 350 epochs on Imagenet with standard preprocessing at 224x224 resolution.
We use the same hyperparameters as~\cite{howard2019searching}.
More specifically, we use RMSProp with 0.9 momentum and a batch size of 4096 split across 32 TPUv3 cores.
The learning rate is warmed up linearly to 0.1 and then multiplied by 0.99 every 3 epochs.
We use a weight decay 1e-5 and dropout with drop probability of 0.2 
\end{document}
