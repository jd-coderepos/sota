\documentclass[fleqn]{fac}

\journal{Preprint for arXiv}

\usepackage{times}
\usepackage{color}
\usepackage{stmaryrd}
\usepackage{amssymb}\usepackage{amsmath}
\usepackage{ifthen}
\usepackage[pdftex]{graphicx}
\usepackage{imakeidx}
\makeindex
\usepackage{url}
\usepackage{calc}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\usepackage{laws}

\newcommand{\draftonly}[1]{}


\usepackage[colorinlistoftodos]{todonotes}
\newcommand{\backgroundintensity}{50}
\newcommand\notesb[4]{
  \todo[linecolor=red,backgroundcolor=#2!\backgroundintensity,size=\small]
  {#1: #3}{\color{blue}#4}
}
\newcommand{\iansb}[2]{\notesb{IJH}{yellow}{#1}{#2}}
\newcommand\notein[3]
{\todo[inline,linecolor=red,backgroundcolor=#2!\backgroundintensity]{#1 says: #3}
}
\newcommand{\ianin}[1]{\notein{IJH}{yellow}{#1}}
\newcommand\todobig[4]{\todo[inline,backgroundcolor=#2!\backgroundintensity,caption={#1 says: #3}]{ 
\begin{minipage}{\textwidth-4pt}#1 says: #3.\par #4\end{minipage}}}
\newcommand{\ianbig}[2]{\todobig{IJH}{yellow}{#1}{#2}}


\newenvironment{relational}{\it\pagebreak[1]\par\noindent\rule{\columnwidth}{0.5pt}\par\noindent}{\nopagebreak\rule{\columnwidth}{0.5pt}}

\newcommand{\figurerule}{\rule{\textwidth}{0.5pt}}

\renewenvironment{proof}{\noindent \textit{Proof.}}{\noindent\par}

\newcommand{\AxiomDef}[2]{(#1) \textit{#2}*}
\newcommand{\labelaxiom}[1]{\label{axiom-#1}\index{Axiom!#1|AxiomDef{\ref{axiom-#1}}}}
\makeatletter
\def\refaxiom{\@ifnextchar*{\@refaxiom}{\@@refaxiom}}
\def\@refaxiom*#1{\ref{axiom-#1}\index{Axiom!#1|LawUse}}
\def\@@refaxiom#1{axiom~(\ref{axiom-#1})\index{Axiom!#1|LawUse}}
\makeatother

\newcommand{\PropertyDef}[2]{(#1) \textit{#2}*}
\newcommand{\labelproperty}[1]{\label{property-#1}\index{Property!#1|PropertyDef{\ref{property-#1}}}}
\makeatletter
\def\refproperty{\@ifnextchar*{\@refproperty}{\@@refproperty}}
\def\@refproperty*#1{\ref{property-#1}\index{Property!#1|LawUse}}
\def\@@refproperty#1{property~(\ref{property-#1})\index{Property!#1|LawUse}}
\makeatother

\newcommand{\DefinitionDef}[2]{(#1) \textit{#2}*}
\newcommand{\labeldefinition}[1]{\label{def-#1}\index{Definition!#1|DefinitionDef{\ref{def-#1}}}}
\makeatletter
\def\refdefinition{\@ifnextchar*{\@refdefinition}{\@@refdefinition}}
\def\@refdefinition*#1{\ref{def-#1}\index{Definition!#1|LawUse}}
\def\@@refdefinition#1{definition~(\ref{def-#1})\index{Definition!#1|LawUse}}
\makeatother


\newcommand{\Pre}[1]{\{#1\}}
\newcommand{\Rely}{\mathop{\Keyword{rely}}}
\makeatletter
\def\rely{\@ifnextchar*{\@rely}{\@@rely}}
\def\@rely*#1#2#3{\Rely #2 \spot #3_{#1}}
\def\@@rely#1#2{\Rely #1 \spot #2}
\newcommand{\RelyPar}[4]{\Pre{#2}#3 \refsto_{r_x} #4 \parallel \interference{#1}\FinIter}
\def\RelyTerm{\@ifnextchar*{\@RelyTerm}{\@@RelyTerm}}
\def\@RelyTerm*#1#2#3{#2 \entails \Stopped(#3,r_x \lor #1))}
\def\@@RelyTerm#1#2#3{#2 \equiv \Stopped(#3,r_x \lor #1))}
\makeatother
\newcommand{\Seq}{\mathbin{;}}
\newcommand{\SSeq}{\,}
\newcommand{\cat}{\mathbin{\raise 0.8ex\hbox{}}}

\newcommand{\atomicrel}[1]{\langle#1\rangle}
\newcommand{\FinSkipIter}{^{\varoast}}
\newcommand{\FinGuar}[1]{\atomicrel{#1}\FinSkipIter}
\newcommand{\omegaskip}{\circledcirc}
\newcommand{\InfSkipIter}{^{\omegaskip}}
\newcommand{\InfGuar}[1]{\atomicrel{#1}\InfSkipIter}
\newcommand{\Nil}{\Keyword{nil}}

\newcommand{\id}{\mathsf{id}}
\newcommand{\sdefs}{\mathrel{\widehat=}}\newcommand{\spot}{\mathrel{{\cdot}}}\newcommand{\where}{\mathrel{|}}\renewcommand{\implies}{\mathrel{\Rightarrow}}\newcommand{\emptyrel}{\emptyset}
\newcommand{\universalrel}{\mathsf{univ}}
\newcommand{\relunion}{\cup}
\newcommand{\relint}{\cap}
\newcommand{\relcontained}{\subseteq}
\renewcommand{\iff}{\mathrel{\Leftrightarrow}}
\newenvironment{refine}{}
\newcommand{\Altx}{,~~}

\newcommand{\Command}{\mathit{Com}}
\newcommand{\refines}{\mathrel{\sqsupseteq}}\newcommand{\refsto}{\mathrel{\sqsubseteq}}
\newcommand{\nondet}{\mathbin{\sqcap}}
\newcommand{\Nondet}{\mathop{\textstyle\bigsqcap}}
\newcommand{\angelic}{\mathbin{\sqcup}}
\newcommand{\Angelic}{\mathop{\textstyle\bigsqcup}}
\newcommand{\finiterec}{\nu}
\newcommand{\infiniterec}{\mu}


\newcommand{\ifinv}[2]{#2}

\newcommand{\strictconjunction}{weak conjunction}
\newcommand{\Strictconjunction}{Weak conjunction}
\newcommand{\together}{\mathbin{\doublecap}}
\newcommand{\quotient}{\mathbin{/\!\!/}}
\newcommand{\fairquotient}{\mathbin{\quotient_f}}
\newcommand{\Env}{\Keyword{env}}
\newcommand{\envc}[1]{(\Env~#1)}
\newcommand{\assumeenv}[1]{\lceil\hspace{1pt}#1\hspace{1pt}\rceil}
\newcommand{\coerceenv}[1]{\lfloor\hspace{1pt}#1\hspace{1pt}\rfloor}
\newcommand{\AbortClose}[1]{#1_{\bot}}
\newcommand{\PrefixClose}[1]{\mathit{prefixes}(#1)}
\newcommand{\Trace}{\mathit{Trace}}

\newcommand{\Sat}[2]{#2 \in #1}
\newcommand{\NotSat}[2]{#2 \not\in #1}
\newcommand{\Sats}[1]{\Sat{#1}{\sigma}}
\newcommand{\Satps}{\Sat{p}{\sigma}}
\newcommand{\Satssp}[1]{\Sat{#1}{(\sigma,\sigma')}}
\newcommand{\traces}[1]{[\![#1]\!]}

\newcommand{\Keyword}[1]{\mathsf{\mathbf{#1}}}
\newcommand{\Magic}{\Keyword{\top}}
\newcommand{\Abort}{\Keyword{\bot}}
\newcommand{\botstate}{\bot}
\newcommand{\Chaos}{\Keyword{chaos}}
\newcommand{\Solo}{\Keyword{solo}}
\newcommand{\entails}{\Rrightarrow}
\newcommand{\entailed}{\Lleftarrow}
\newcommand{\FinIter}{^{\star}}
\newcommand{\itkleene}[1]{#1^{\star}}
\newcommand{\InfIter}{^{\infty}}
\newcommand{\itinfty}[1]{#1^{\infty}}
\newcommand{\FinOrInfIter}{^{\circ}}
\newcommand{\itomega}[1]{#1\FinOrInfIter}

\newcommand{\pstepl}[1]{\Pi(#1)}
\newcommand{\estepl}[1]{{\cal E}(#1)}
\newcommand{\termd}{\checkmark}
\newcommand{\terml}[1]{\termd\!(#1)}
\newcommand{\termls}{\terml{\sigma}}

\newcommand{\cpstepd}{\boldsymbol{\pi}}
\newcommand{\cestepd}{\boldsymbol{\epsilon}}
\newcommand{\cestepbotd}{\cestepd_{\botstate}}
\newcommand{\ctmtd}{\boldsymbol{\checkmark}}
\newcommand{\cpstep}[1]{\cpstepd(#1)}
\newcommand{\cestep}[1]{\cestepd(#1)}
\newcommand{\cestepbot}[1]{\cestepbotd(#1)}
\newcommand{\cgdd}{\boldsymbol{\tau}}
\newcommand{\cgd}[1]{\cgdd(#1)}

\newcommand{\While}{\mathop{\Keyword{while}}}
\newcommand{\Do}{\mathop{\Keyword{do}}}
\newcommand{\Od}{\mathop{\Keyword{od}}}
\newcommand{\If}{\mathop{\Keyword{if}}}
\newcommand{\Then}{\mathrel{\Keyword{then}}}
\newcommand{\Else}{\mathrel{\Keyword{else}}}
\newcommand{\Fi}{\mathrel{\Keyword{fi}}}
\newcommand{\Skip}{\Keyword{skip}}
\newcommand{\Term}{\Keyword{term}}
\newcommand{\Var}{\mathop{\Keyword{var}}}
\newcommand{\variable}[2]{\Var #1 \spot #2}
\newcommand{\False}{\mathsf{false}}
\newcommand{\True}{\mathsf{true}}

\makeatletter
\def\Spec{\@ifnextchar*{\@Spec}{\@@Spec}}
\def\@Spec*#1#2#3{\ifx\@empty#1\else#1\colon\fi
   [#2\ifx\@empty#2\else,~\fi#3]}
\def\@@Spec#1#2#3{\ifx\@empty#1\else
   \begin{array}{@{}l@{}}#1\colon\end{array}\!\!\fi \left[\begin{array}{@{}c@{}}#2\end{array}\ifx\@empty#2\else,~\fi
   \begin{array}{@{}c@{}}#3\end{array}\right]}
\newcommand{\RGSpec}[4]{[#1,#2,#3,#4]}
\newcommand{\Sspec}[3]{\llparenthesis #3 \rrparenthesis}


\newcommand{\ChainRel}[1]{\crcr \noalign{\penalty\interdisplaylinepenalty}
  \hspace*{-1em}#1
  \@ifnextchar*{\@ChainRelCommment}{}}
\newcommand{\ChainRelFormat}[1]{\mbox{~~~#1}}
\def\@ChainRelCommment*[#1]{\ChainRelFormat{#1}
  \crcr \noalign{\penalty\interdisplaylinepenalty}}
\newcommand{\StartRef}[1]{\hspace*{-1.5em}(\ref{#1}) \refsto
  \@ifnextchar[{\@StartRefCommment}{}}
\def\@StartRefCommment[#1]{\mbox{#1}
  \crcr \noalign{\penalty\interdisplaylinepenalty}}
\makeatother
\newcommand{\Implies}{\ChainRel{\implies}}
\newcommand{\IFF}{\ChainRel{\iff}}
\newcommand{\Entails}{\ChainRel{\entails}}
\newcommand{\Equiv}{\ChainRel{\equiv}}
\newcommand{\Because}{\ChainRel{\entailed}}
\newcommand{\ImpliedBy}{\ChainRel{\Leftarrow}}
\newcommand{\Refsto}{\ChainRel{\refsto}}
\newcommand{\Refines}{\ChainRel{\refines}}
\newcommand{\Equals}{\ChainRel{=}}

\edef\today{\number\day\ \ifcase\month\or
  January\or February\or March\or April\or May\or June\or
  July\or August\or September\or October\or November\or December\fi
  \ \number\year}
\newcounter{Hours}
\setcounter{Hours}{\time/60}\newcounter{Minutes}
\setcounter{Minutes}{\time-\value{Hours}*60}\newcommand{\CurrentTime}{\ifthenelse{\value{Hours}<10}{0}{}\theHours:\ifthenelse{\value{Minutes}<10}{0}{}\theMinutes}
\newcommand{\runningdate}{\draftonly{(\today\ DRAFT)}}

\begin{document}

\newcommand{\Reviewers}[1]{}


\title[Generalised rely-guarantee concurrency \runningdate]{Generalised rely-guarantee concurrency: An algebraic foundation}
\author[Ian J. Hayes \runningdate]{Ian J. Hayes \\
School of Information Technology and Electrical Engineering, The University of Queensland, Australia
}\correspond{Ian.Hayes@itee.uq.edu.au}\makecorrespond 

\maketitle 

\begin{abstract}
The rely-guarantee technique allows one to reason compositionally about concurrent programs.
To handle interference the technique makes use of rely and guarantee conditions,
both of which are binary relations on states.
A rely condition is an assumption that the environment performs
only atomic steps satisfying the rely relation
and a guarantee is a commitment that every atomic step 
the program makes satisfies the guarantee relation.
In order to investigate rely-guarantee reasoning more generally,
in this paper we allow interference to be represented by a 
process rather than a relation
and hence derive more general rely-guarantee laws.
The paper makes use of a \strictconjunction\ operator between processes,
which generalises a guarantee relation to a guarantee process,
and introduces a rely quotient operator, 
which generalises a rely relation to a process.
The paper focuses on the algebraic properties of the general 
rely-guarantee theory.
The Jones-style rely-guarantee theory can be interpreted  
as a model of the general algebraic theory
and hence the general laws presented here hold for that theory. 
\end{abstract}

\begin{keywords}
Concurrent programming; 
rely-guarantee concurrency; 
program verification;
program algebra;
concurrent Kleene algebra.
\end{keywords}





\section{Introduction}

\paragraph{Rely and guarantee conditions.}

The rely-guarantee technique of Jones \cite{Jones81d,jon83a,jones96a}
provides a compositional approach to reasoning about concurrent programs.
With hindsight, it is obvious that to achieve compositional handling of concurrency, 
it is necessary to have some way of recording information about interference.
This paper generalises the way that interference is recorded.
To allow reasoning about a process  in isolation,
Jones used a \emph{rely} condition ,
that is a binary relation on states.
Every atomic step of the environment of  is assumed to satisfy the rely condition 
between its before and after states.
Any process running in parallel with  also has a rely condition 
and hence process  will need to ensure every atomic program step it makes satisfies 
the rely conditions of all processes in its environment.
To represent this Jones uses a \emph{guarantee} condition ,
that is also a binary relation on states.
Every atomic step of  must satisfy 
and the relation  should be contained in the rely condition of every process
in the environment of .
Jones records a rely-guarantee specification by generalising the judgements of 
Hoare logic \cite{Hoare69a} to a quintuple of the form,

The process  satisfies the quintuple if, 
under the assumption that
the initial state satisfies  and 
every atomic step made by the environment satisfies  between its before and after states,
every possible execution of  
ensures that every atomic program step made by  satisfies , 
and the initial and final states of the overall execution of 
satisfy the relational postcondition .

\paragraph{Refinement calculus.}

This paper uses a refinement calculus approach \cite{Bac81a,BackWright98,TSS,Morgan94,ATBfSRatPC}
rather than Hoare logic because it allows for simpler presentation of algebraic laws of programming \cite{HoareHayesEtcFull87}.
Refinement of one command  by another  is written ``'' and 
is read `` is refined (implemented) by ''.
The refinement calculus introduces 
a postcondition specification command  in which the postcondition  is a binary relation on states,
and a precondition command  in which the precondition  is a set of states.
The refinement  means  achieves the postcondition  between
its before-state and after-state, provided its before-state satisfies .
As an abbreviation the sequential composition operator ``'' may be elided 
so that the above may be written .


\paragraph{Generalised rely-guarantee.}

The main contribution of this paper is to generalise a rely condition  to 
a process  specifying the assumed behaviour of interference from the environment.
The actual environment should satisfy (i.e.\ refine) the process specification .
Similarly, the guarantee condition  is generalised to a process 
to be ``guaranteed'' by the implementation.
The process that behaves as a process  as well as respecting the guarantee process 
is represented by their \strictconjunction\ ,
which is the process that behaves as both  and  unless one of them aborts.\footnote{Earlier publications referred to \strictconjunction\ as \emph{strict} conjunction
but the new name is preferred because the operator is weaker than the (strong) conjunction operator 
that requires both its operands to abort for it to abort.}
A Jones-style guarantee condition  on a terminating command  is represented by 
the process ,
where 
 represents a command that can perform a single atomic program step 
for which the before and after states satisfy 
and
 is the process 
that iterates the atomic step  any finite number
of times, zero or more.
An example of a guarantee process that cannot be expressed as a guarantee condition is
the sequential composition 
,
in which  is the identity relation.
It guarantees that a step satisfying  occurs exactly once but allows stuttering 
steps before and after.
The closest guarantee condition is  but that allows any number, zero of more, of steps satisfying .
Section~\ref{section:conjunction} explores the \strictconjunction\ operator and 
its relationship to Jones-style guarantee conditions~\cite{FACJexSEFM-14}.


\paragraph{Rely quotients.}

To specify a process that refines (implements) ,
while relying on its environment refining process ,
a rely quotient operator  is introduced.
The rely quotient  when run in parallel with  implements ,

The operator ``'' is chosen to be similar in appearance to the division operator, 
where in this context ``'' takes on a role similar to multiplication.
\label{division}Taking ``'' as the ceiling of their integer division  gives the best analogy:
.
A terminating process specification  with a Jones-style rely condition  
is represented by the quotient ,
where  represents the environment process,
all atomic steps of which satisfy .
Section~\ref{section:rely} explores the properties of the rely quotient operator.
Given the \strictconjunction\ and rely quotient operators, the Jones quintuple (\refproperty*{quintuple})
is equivalent to the following refinement.


\paragraph{Concurrency.}

The parallel introduction law of Jones makes use of both rely and guarantee conditions.
In the more general theory presented here, 
\strictconjunction\ takes on the role of a guarantee 
and the rely quotient takes on the role of a rely condition.
Both generalised operators are used 
to give a general version a law for introducing a parallel composition,
which has a surprisingly simple and elegant proof (see Section~\ref{section:parallel}).

\paragraph{Distribution laws.}

Section~\ref{section:rely-distribution} examines the distribution properties of 
the rely quotient operator over the other operators.
In some cases the general distribution laws for \strictconjunction\ and rely quotient
require provisos.
However, in the relational rely-guarantee model
the provisos are all valid and hence the distribution properties hold without proviso.
In the general theory the provisos are explicit and 
hence it is possible to explore alternatives to Jones-style rely-guarantee
that allow more expressive rely conditions.

\paragraph{Relationship to relational rely-guarantee.}

Exploring the theory more generally 
leads to simpler laws 
that can be specialised to the relational model.
As an example consider the nesting of two rely processes  and , i.e.\ . 
That corresponds to handling concurrent interference from both  and 
and is equivalent to ,
i.e.\ an effective rely process of .
A relational rely condition of  corresponds to a rely process of 
and the nesting of two such processes for rely conditions of  and 
corresponds to the rely process of 
,
however, 
this process is equivalent to ,
corresponding to a relational rely of .
This shows how the well known relational rely-guarantee rule, 
that the effective rely of nested relational rely conditions is their disjunction,
can be derived from the more general view that the effective rely process 
of nested rely processes is their parallel composition.

Section~\ref{section:Jones-rely} explores the relationship 
of the more general theory to the Jones-style relational guarantee and rely conditions.
The relational rely-guarantee theory of Jones \cite{jones96a}
is a model of the general algebraic theory presented in this paper
and hence the laws developed in the general theory are also valid for Jones' theory.


Section~\ref{section:fair-parallel} examines fair parallel and its impact on the rely quotient operator.

\paragraph{Contributions.}

The main contribution of this paper is to generalise rely and guarantee conditions from relations to
arbitrary processes.
In order to make our results as widely applicable as possible,
we have based our theory on a relatively small set of definitions and axioms.
Any model, such as the relational rely-guarantee model, that satisfies the axioms
can then make use of all the laws proved here.

Our core theory adds two specification operators, \strictconjunction\ and rely quotient,
to the operators of a simple parallel programming language.
The \strictconjunction\ operator allows guarantees to be imposed on a process \cite{HayesJonesColvin14TR}.
The rely quotient operator introduced in this paper allows rely conditions to be generalised to processes.
There are a number of advantages of exploring the more general operators.
Both \strictconjunction\ and rely quotient have simple algebraic properties
and this leads to simple and elegant proofs of laws involving these operators.
The approach leads to a nice separation of concerns 
because properties of \strictconjunction\ (guarantees) and rely quotient can
be developed separately
and then combined to give 
generalised equivalents of the main laws used for standard rely-guarantee refinements, 
which are more simply expressed and proven in the general theory.
Further, it is much simpler to devise new rely-guarantee refinement laws 
because the algebra gives a rich theory of properties which simplify discovering proofs.

As an example of the way in which the theory generalises rely and guarantee conditions,
in the relational model, as well as being able to express 
a relational rely condition via the process ,
one can express rely processes, such as the sequence ,
which cannot be expressed via a relational rely condition.
The closest rely condition is 
but that does not represent the fact that the rely transitions from  to  just once.











\section{Basic commands and refinement}\label{section:basics}

Our presentation separates a core algebraic theory of processes
from an instantiation of that theory as a relational model 
similar to that used by Jones \cite{CoJo07}.
Section~\ref{section:syntax} introduces the operators in our language.
Section~\ref{section:lattices} covers the theory of lattices on which the theory for the language is built.
Section~\ref{section:basic-algebra} gives the algebraic properties of basic commands.
Section~\ref{section:relational-model} gives the relational model 
to provide an intuition for the behaviour of basic commands.


\subsection{Operators and primitive commands}\label{section:syntax}

\begin{figure*}
\figurerule\\
Let  and  be commands,  be a set of commands and  a monotonic function on commands.
The following are the primitive operators and commands used in the algebra.

The precedence of binary operators ranges 
from ``'' on the left having the lowest precedence
to ``'' on the right having the highest precedence,
although ``'' and ``'' have equal precedence.
Unary operators have precedence over binary operators.
The sequential composition  is abbreviated as .

\figurerule
\caption{Operators and primitive commands}\label{figure:syntax}
\end{figure*}


The operators and primitive commands of the core language are given in Figure~\ref{figure:syntax}.
Typical 
commands are represented by , ,  and ;
sets of commands by  and ;
and
monotonic functions from commands to commands by .
The language includes non-deterministic choice, 
both binary  and over a set of commands , 
which form infima with respect to the refinement ordering,
and their duals  and ,
which form suprema.
Additional binary operators are 
parallel composition , 
sequential composition ,
a \strictconjunction\ operator  explained in Section \ref{section:conjunction},
and
a rely quotient operator  explained in Section~\ref{section:rely}.
Commands include least () and greatest () fixed points of monotonic functions over commands.
Primitive commands include:
the top element in the refinement lattice  
(called \emph{magic} in the refinement calculus);
the bottom element  
(called \emph{abort});
the command that terminates immediately, ,
which is the identity of sequential composition;
the command that does nothing but doesn't constrain its environment, ,
which is the identity of parallel composition;
and
the command that can do any non-aborting behaviour, ,
which is the identity of \strictconjunction.



\subsection{Lattices and fixed points}\label{section:lattices}


\begin{figure}
\figurerule\
  c_0 \nondet (c_1 \nondet c_2) & = & (c_0 \nondet c_1) \nondet c_2 \labelaxiom{infimum-associative}\\
  c_0 \nondet c_1 & = & c_1 \nondet c_0 \labelaxiom{infimum-commutes} \\
  c \nondet c & = & c \labelaxiom{infimum-idempotent} \\
  c_0 \angelic (c_1 \angelic c_2) & = & (c_0 \angelic c_1) \angelic c_2 \labelaxiom{supremum-associative}\\
  c_0 \angelic c_1 & = & c_1 \angelic c_0 \labelaxiom{supremum-commutes} \\
  c \angelic c & = & c \labelaxiom{supremum-idempotent} \\
  c_0 \nondet (c_0 \angelic c_1) & = & c_0 \labelaxiom{infimum-absorb-supremum} \\
  c_0 \angelic (c_0 \nondet c_1) & = & c_0  \labelaxiom{supremum-absorb-infimum}

  c \in C & \implies & \Nondet C \refsto c \labelaxiom{infimum-lower-bound} \\
  (\forall c \in C \spot d \refsto c) & \implies & d \refsto \Nondet C \labelaxiom{infimum-greatest-lower-bound} \\
  c \in C & ~\implies~ & c \refsto \Angelic C \labelaxiom{supremum-upper-bound} \\
  (\forall c \in C \spot c \refsto d) & ~\implies~ & \Angelic C \refsto d \labelaxiom{supremum-least-upper-bound}

  c \nondet (\Angelic D) & = & \Angelic \{ d \in D \spot c \nondet d \} \labelaxiom{infimum-distribute-supremum} 

  \mu f & = & f(\mu f)  \labelaxiom{least-fixed-point-unfold} \\
  f(x) \refsto x & \implies & \mu f \refsto x \labelaxiom{least-fixed-point-induction}

  \nu f & = & f(\nu f)  \labelaxiom{greatest-fixed-point-unfold} \\
  x \refsto f(x) & \implies & x \refsto \nu f  \labelaxiom{greatest-fixed-point-induction}

  c \refsto d ~\sdefs~ (c \nondet d) = c.
-1ex]
\begin{minipage}{0.48\textwidth}

\end{minipage}
\begin{minipage}{0.48\textwidth}

\end{minipage}
\item
The \ifinv{bottom}{top} element of the lattice is .
It is the identity of ``'' and an annihilator for ``''. \
  \Magic & \sdefs & \Nondet \{\} = \Angelic \Command

  c \nondet \Magic & =  c  = & \Magic \nondet c  \labelproperty{nondet-identity} \\
  c \angelic \Magic & = \Magic  = & \Magic \angelic c  \labelproperty{supremum-magic-zero} 

  (\forall d \in D \spot (\exists c \in C \spot c \refsto d)) & ~~\implies~~ & (\Nondet C) \refsto (\Nondet D).

   \FF(\mu \GG) ~\refsto~ \mu \HH  && \mbox{ provided } \FF \circ \GG ~\refsto~ \HH \circ \FF
        \mbox{ and } \FF \mbox{ distributes over arbitrary suprema}
     \labelproperty{fusion-lfp-leq}
\\
   \FF(\mu \GG) ~=~ \mu \HH  && \mbox{ provided } \FF \circ \GG ~=~ \HH \circ \FF
        \mbox{ and } \FF \mbox{ distributes over arbitrary suprema}
     \labelproperty{fusion-lfp-eq}
\\
  \FF(\nu \GG) ~\refines~ \nu \HH    && \mbox{ provided } \FF \circ \GG ~\refines~ \HH \circ \FF
        \mbox{ and } \FF \mbox{ distributes over arbitrary infima}
     \labelproperty{fusion-gfp-geq}
\\
  \FF(\nu \GG) ~=~ \nu \HH    && \mbox{ provided } \FF \circ \GG ~=~ \HH \circ \FF
        \mbox{ and } \FF \mbox{ distributes over arbitrary infima}
     \labelproperty{fusion-gfp-eq}
2ex]
\begin{minipage}{0.49\textwidth}
\textbf{Sequential}

\textbf{Parallel}

\end{minipage}
\quad
\begin{minipage}{0.48\textwidth}
\textbf{Identities}

\textbf{\Strictconjunction}

\end{minipage}
\begin{center}
\begin{minipage}{0.6\textwidth}
\textbf{Weak exchange axioms}

\end{minipage}
\end{center}
\figurerule

\caption{Axioms for core language of commands}\label{figure:axioms}
\end{figure}

 
\begin{definitionx}[concurrent-algebra]
The set of commands  satisfies the axioms given in Figure~\ref{figure:axioms}
in addition to the axioms of lattices from Figure~\ref{figure:lattices}.
\end{definitionx}
\begin{itemize}
\item
 forms a monoid with identity , i.e. axioms (\refaxiom*{sequential-associative}-\refaxiom*{sequential-identity-left}).
Note that the operator ``'' is elided, so that ``'' is written ``''. 
\item
Sequential composition distributes over finite non-deterministic choices on the left (\refaxiom*{sequential-distribute-nondet-left}) 
and arbitrary infima on the right (\refaxiom*{sequential-distribute-nondet-right}) and 
and hence it has a left annihilator of   (\refproperty*{sequential-magic-zero-left});
 is a left annihilator of sequential composition  (\refaxiom*{sequential-abort-zero-left}). 
 
\item
 forms a monoid with identity  in which ``'' is commutative, i.e.\ axioms 
(\refaxiom*{parallel-associative}--\refaxiom*{parallel-identity}).
Note that the identity of parallel composition is different to the identity of sequential composition;
that allows a wider range of models, included the relational model introduced in Section~\ref{section:relational-model}.
\item
Parallel distributes over non-deterministic choice of any set of commands
(\refaxiom*{parallel-distribute}),
and hence 
has an annihilator of .

\item
The identity of parallel composition, , sequentially composed with itself is equivalent to  (\refaxiom*{skip-skip})
and is refined by the identity of sequential composition,  (\refaxiom*{skip-nil}).

\item
 forms a monoid with identity  in which ``'' is commutative and idempotent, 
i.e.\ axioms (\refaxiom*{conjunction-associative}--\refaxiom*{conjunction-identity}).
\item
 allows any non-aborting behaviour including  (\refaxiom*{chaos-skip})
and  in parallel with itself doesn't make it any more (or less) chaotic (\refaxiom*{chaos-parallel-chaos}).
\item
\Strictconjunction\ distributes over the non-deterministic choice of non-empty sets of commands by \refaxiom{conjunction-distribute-infimum}
and hence it distributes over binary choices.

\item
\Strictconjunction\ distributes over arbitrary suprema \refaxiom{conjunction-distribute-supremum}
and hence
it has an annihilator of .

\item
\Strictconjunction\ does \emph{not} distribute through either parallel or sequential composition,
instead it satisfies the weak exchange axioms 
(\refaxiom*{conjunction-exchange-parallel}) and (\refaxiom*{conjunction-exchange-sequential}).
Note that \refaxiom{conjunction-exchange-parallel} is a refinement rather than an equality 
because, on the left, behaviour of  may synchronise with 
behaviour of either  or ,
whereas, on the right, it can only synchronise with behaviour of ;
\refaxiom{conjunction-exchange-sequential} is similar;
see Section~\ref{section:conjunction} for more details.
\end{itemize}
Note that the set of all commands that refine  forms a sub-lattice of all non-aborting commands.



The iteration operators are based on von Wright's refinement algebra \cite{Wright04}.
Kleene algebra provides the finite iteration operator ,
which iterates  zero or more times
but only a finite number of times \cite{conway71,Blikle78,kozen97kleene}.
A generalisation of this more appropriate for modelling programs is
the iteration operator, , 
that iterates  zero or more times, 
including the possibility of an infinite number of iterations \cite{Wright04}.
For both these operators the number of iterations they take is 
non-deterministic.
\begin{definitionx}[iteration]
The iteration operators are defined via least () and greatest () 
fixed point operators. \
  \itkleene{c} & ~\sdefs~ & (\finiterec x \spot \Nil ~\nondet~ c \SSeq x)
    \labeldefinition{kleene-iteration-skip} 

  \itomega{c}  & \sdefs & (\infiniterec x \spot \Nil ~\nondet~ c \SSeq x) 
    \labeldefinition{omega-iteration-skip} 
-1ex]
\begin{minipage}{0.5\textwidth}

\end{minipage}
\begin{minipage}{0.49\textwidth}

\end{minipage}
\end{lemmax}

\begin{lemmax}[induction]
The iteration induction properties follow from \Lemma{fusion} and 
fixed point induction (\refaxiom*{greatest-fixed-point-induction})  and (\refaxiom*{least-fixed-point-induction}).
\
  x ~\refsto~  d ~\nondet~ c \SSeq x & ~~\implies~~ & x ~\refsto~ \itkleene{c} \SSeq d
    \labelproperty{kleene-induction}

  d ~\nondet~ c \SSeq x ~\refsto~ x & ~~\implies~~ & \itomega{c} \SSeq d ~\refsto~ x 
    \labelproperty{omega-induction} 
-1ex]
\begin{minipage}{0.5\textwidth}

\end{minipage}
\begin{minipage}{0.49\textwidth}

\end{minipage}
\end{lawx}

\begin{proof}
Property (\refproperty*{nondet-monotonic}) holds because non-deterministic choice is associative, commutative and idempotent.
The proofs of (\refproperty*{parallel-monotonic}--\refproperty*{conjunction-monotonic}) follow from \Lemma{operator-monotonic} 
because ``'', ``'' and ``'' distribute non-deterministic choice in both their 
left and 
right arguments.
Properties (\refproperty*{kleene-monotonic}) and (\refproperty*{omega-monotonic})
can be shown by induction, respectively, (\refproperty*{kleene-induction}) and (\refproperty*{omega-induction}),
using (\refproperty*{kleene-unfold}) and (\refproperty*{omega-unfold}) (see \cite{Wright04}).
\end{proof}




\subsection{A relational model}\label{section:relational-model}


In this paper we focus on the algebraic laws satisfied by commands 
but it is useful to have a model to gain intuitions and ensure the algebra 
is consistent.
The model used corresponds to the rely-guarantee theory of Jones based on 
Aczel traces \cite{Aczel83,BoerHannemanDeRoever99,DeRoever01,HayesJonesColvin14TR}.
Typical
single-state predicates are represented by 
and
binary relations on states by ,  and .
The additional commands in the relational model are 

This set of commands is left open and may be extended with other commands,
for example, tests, assignments, conditionals and loops are added in \cite{HayesJonesColvin14TR}.

States () are modelled by a mapping from variable names to values.
The set of program states  is extended to include the undefined state ,
which is used to denote that the process has aborted.\footnote{The symbol  is overloaded between the undefined state and 
the bottom of the lattice of commands, which corresponds to the aborted process.
As usual their meaning is resolved by context.}
An \emph{Aczel trace} consists of an initial state  and a sequence of steps,
each of which is either a program step labelled  
or an environment step labelled ,
where  is the program state after the step.
In this paper the term ``step'' always means an atomic step
(either of a program or its environment).
A \emph{terminating} Aczel trace ends with a step labelled .
The step  is an aborting step of the program and
the step  allows an aborting step by the environment.
The special steps ,  and  can appear only as 
the last step of a (finite) trace.
The set  is the set of all valid Aczel traces.
The notation  stands for the sequence containing .

A set of traces  is \emph{prefix closed} if  for all 
and whenever  and  is a prefix of , .
A set of traces  is \emph{abort closed} if whenever ,
then for any valid trace , .
The set of all commands, , consists of all the prefix and abort closed subsets of . 

The command
 performs a single program step with its before and after states related by  and terminates (\refproperty*{semantics-program-step}),
 is similar but performs an environment step (\refproperty*{semantics-env-step}),
 represents an environment step that satisfies  or allows a parallel process to abort (\refproperty*{semantics-env-abort}),
 terminates from states satisfying  only (\refproperty*{semantics-guard}),
 aborts immediately and hence can do any behaviour whatsoever (\refproperty*{semantics-abort}),
 can make no steps whatsoever (\refproperty*{semantics-magic}),
and
 terminates immediately from any state (\refproperty*{nil}).
Recall that  stands for the set of values of  for all values of  in the set .\\
\begin{minipage}{0.55\textwidth}

\end{minipage}
\begin{minipage}{0.44\textwidth}

\end{minipage}
\
  match\_step(sc,sd,st) & ~\sdefs~ & \exists \sigma \in \Sigma_{\botstate} \spot \begin{array}[t]{l}
           sc = \pstepl{\sigma} \land sd = \estepl{\sigma} \land st = \pstepl{\sigma} \lor {} \\
           sc = \estepl{\sigma} \land sd = \pstepl{\sigma} \land st = \pstepl{\sigma} \lor {} \\
           sc = \estepl{\sigma} \land sd = \estepl{\sigma} \land st = \estepl{\sigma} \lor {} \\
           sc = \termd \land sd = \termd \land st = \termd
       \end{array} \\
  match\_trace((\sigma_c,t_c),(\sigma_d,t_d),(\sigma,t)) & ~\sdefs~ & 
       \begin{array}[t]{l}
           \sigma_c = \sigma_d = \sigma \land dom(t_c) = dom(t_d) = dom(t) \land {} \\
           (\forall i \in dom(t) \spot match\_step(t_c(i),t_d(i),t(i))
        \end{array} \\
  c \parallel d & ~\sdefs~ & abort\_close(\{ t \in \Trace \where \exists tc \in c, td \in d \spot match\_trace(tc,td,t) \})

  \Skip & \sdefs & (\cestepbot{\universalrel})\FinOrInfIter  \labelproperty{semantics-skip} \\
  \atomicrel{r} & \sdefs & \Skip \SSeq \cpstep{r} \SSeq \Skip  \labelproperty{semantics-atomicrel} 

  \Pre{p} & \sdefs & \cgd{p} \nondet (\cgd{\lnot p} \SSeq \Abort)  \labelproperty{semantics-precondition} \\
  \envc{r} & \sdefs & (\cpstep{\universalrel} \nondet \cestepbot{r})\FinOrInfIter \SSeq (\Nil \nondet \cestep{\bar{r}} \SSeq \Abort) \labelproperty{semantics-env}

  p_0 \relcontained p_1 & ~\iff~ & \Pre{p_0} \refsto \Pre{p_1} 
    \labelproperty{weaken-precondition} \\
  r_0 \relcontained r_1 & \iff & \envc{r_0} \refsto \envc{r_1}
    \labelproperty{weaken-environment}

  q_1 \relcontained q_0 & ~\iff~ & \atomicrel{q_0} \refsto \atomicrel{q_1}
    \labelproperty{strengthen-postcondition-atomic} 

  c_0 \together c_1 ~\refsto~ d~.

    c_0 \together c_1
  ~\refsto~
    d \together d
  ~=~
    d.

  c ~\refsto~ d_0 \together d_1~.

  c ~=~ c \together c ~\refsto~ d_0 \together d_1~.

  c ~\refsto~ c \together d~.

  c ~=~ c \together \Chaos ~\refsto~ c \together d~.

  c \together d \refsto c \angelic d~.

  c \together (d_0 \together d_1) & ~=~ & (c \together d_0) \together (c \together d_1)
    \labelproperty{conjunction-distribute-conjunction} \\
  c \together (d_0 \parallel d_1) & \refsto & 
                                                                     (c \together d_0) \parallel (c \together d_1) 
                                                                     \mbox{~~~~~~~~if } 
    \labelproperty{conjunction-distribute-parallel} \\
  c \together (d_0 \SSeq d_1) & \refsto &
                                                                (c \together d_0) \SSeq (c \together d_1) 
                                                                \mbox{~~~~~~~~~~~\,if }
    \labelproperty{conjunction-distribute-sequential} \\
  c\FinIter \together d\FinIter & \refsto &
                                                (c \together d)\FinIter 
    \labelproperty{conjunction-distribute-kleene} \\ 
  c\FinOrInfIter \together d\FinOrInfIter & \refsto &
                                                             (c \together d)\FinOrInfIter 
    \labelproperty{conjunction-distribute-omega} 

  c\FinIter \together d\FinIter & ~\refsto~ & \Nil \nondet (c \together d) \SSeq (c\FinIter \together d\FinIter),

  c\FinOrInfIter \together (\Nil \nondet d \SSeq x)   & ~\refsto~ & \Nil \nondet (c \together d) \SSeq (c\FinOrInfIter \together x)
    \labelproperty{fusion-property}

  c\FinSkipIter & \sdefs & c\FinIter \SSeq \Skip

  c\InfSkipIter & \sdefs & c\FinOrInfIter \SSeq \Skip

  c\InfSkipIter & \refsto & c\FinSkipIter \labelproperty{omega-to-kleene} \\
  c\InfSkipIter & \refsto & \Skip  \labelproperty{omega-skip} 

  c\InfSkipIter & \refsto & c\InfSkipIter \SSeq c\InfSkipIter ~~~~~\mbox{if }   \labelproperty{sequential-refines-omega} \\
  c\InfSkipIter & \refsto & (c\InfSkipIter)\FinIter                    ~~~~~\mbox{if } \labelproperty{omega-refsto-omega-kleene}

  c\InfSkipIter \together d\FinOrInfIter & \refsto & (c\InfSkipIter \together d)\FinOrInfIter 
    \labelproperty{conjunction-distribute-omega-omega}

  \atomicrel{g} \together \atomicrel{r} & = & \atomicrel{g \relint r}
    \labelproperty{atomic-conjoin-atomic} \\
  (\atomicrel{g} \SSeq c) \together (\atomicrel{r} \SSeq d) & = & \atomicrel{g \relint r} \SSeq (c \together d)
    \labelproperty{non-skip-conjoin-non-skip}

  \Skip \together (\atomicrel{g} \SSeq c) & = & \Skip \SSeq \Magic 
    \labelproperty{skip-conjoin-non-skip} 

  \Chaos & \sdefs & \InfGuar{\universalrel}  \labelproperty{semantics-chaos} 

  \Term   & \sdefs & \FinGuar{\universalrel}  \labelproperty{semantics-term} 
-2ex]
\begin{minipage}[t]{0.5\textwidth}

\end{minipage}
\begin{minipage}[t]{0.49\textwidth}

\end{minipage}\vspace{1ex}\\
Properties (\refproperty*{strengthen-postcondition-atomic-kleene}) and (\refproperty*{strengthen-postcondition-atomic-omega}) 
follow using (\refproperty*{strengthen-postcondition-atomic}) from 
(\refproperty*{kleene-monotonic}) and (\refproperty*{omega-monotonic}), respectively.

In the relational model 
a command  preconditioned by the state predicate  
is represented by  
.
If  holds initially,  behaves as 
and hence  behaves as 
but if  does not hold initially, the preconditioned command aborts.
A precondition distributes into both a \strictconjunction\ and into a parallel composition.
These laws follow from the definition of a precondition command (\refproperty*{semantics-precondition})
and distribution properties in the relational semantics.
\begin{lawx}[precondition-conjunction]~~~

\end{lawx}
\begin{lawx}[precondition-parallel]~~~

\end{lawx}

Morgan's specification command, , is refined by any program 
that terminates with its initial and final states related by 
provided there is no interference from the environment
\cite{TSS}.

The behaviour of  consists of terminating traces that start in some state 
and terminate in a state  such that .
It assumes all steps of its environment do not modify the state (i.e.\ satisfy the identity relation ).
Its behaviour includes finite infeasible traces starting from any state 
and traces ending in an infinite sequence of environment steps.
Conjoining two specifications achieves the conjunction of their postconditions. 





\subsection{Relationship to Jones-style guarantee}\label{section:guarantee-jones}

Jones introduced the idea of using a guarantee condition , 
a binary relation between states, 
to express the fact that every atomic program step a process makes is guaranteed 
to satisfy  between its before-state and after-state \cite{jon83a}.
The relation  is required to be reflexive so that stuttering steps are allowed.
A guarantee  on a terminating command  can be defined in terms of 
a \strictconjunction\ as .
The \strictconjunction\ with  restricts the behaviour  of  so that
every atomic program step satisfies .
The command  is used rather than 
so that zero iterations corresponds to  rather than 
and hence does not constrain environment steps in this case.
More generally, if  is not assumed to be terminating, 
a guarantee is represented by .
Possibly infinite iteration is used rather than finite iteration 
because \strictconjunction\ with finite iteration forces termination
and hence is too strong
\cite{HayesJonesColvin14TR}.
Termination of  depends only on 
whether  terminates if its traces are restricted to program steps satisfying .
The guarantee component  is non-aborting 
and hence any aborting behaviour can only arise from .
Using the supremum operator 
would be too strong a guarantee because  has only non-aborting
traces and hence would mask any aborting behaviour of .


A guarantee relation  in the style of Jones is represented here by 
an iterated atomic step satisfying the relation, either  or .
By treating guarantees as processes more expressive guarantee conditions can
be expressed, for example, the process 
represents a guarantee of  initially, followed at some point by a switch to a guarantee of .
As another example, the process 
represents a guarantee to perform a single step satisfying  surrounded by any finite number of
steps that don't modify any variables.
Neither of these guarantee processes can be represented as a single guarantee relation
unless additional variables that distinguish the phases of the guarantees are used.
It is possible to encode a sequence such as 
via the use of an additional boolean variable  which is initially false:
,
where it is assumed  is set to true for the transition from a guarantee of  to .


\subsection{Laws for guarantees}\label{section:guarantee-laws}

If , then a guarantee of  is stronger than a guarantee of .
\begin{lawx}[guarantee-strengthen]
For any command  and relations  and 
such that ,

\end{lawx}

\begin{proof}
By (\refproperty*{strengthen-postcondition-atomic-omega}), 
,
and hence the law follows by \Law{monotonic} part (\refproperty*{conjunction-monotonic}).
\end{proof}

\begin{lawx}[guarantee-introduce]~~~

\end{lawx}
\begin{proof}
The proof follows by \Law{conjoin-non-aborting} because by (\refproperty*{semantics-chaos})
 by (\refproperty*{strengthen-postcondition-atomic-omega}).
\end{proof}



\begin{lawx}[conjunction-atomic-iterated]~~~

\end{lawx}

\begin{proof}
The refinement from left to right follows 
by \Law{refine-conjunction} because by (\refproperty*{strengthen-postcondition-atomic-omega})
both  and  are refined by .
The refinement  from right to left can be proved using \Lemma{induction} part (\refproperty*{omega-induction})
using (\refproperty*{non-skip-conjoin-non-skip}) and (\refproperty*{skip-conjoin-non-skip}).
\end{proof}

\begin{lawx}[guarantee-nested]~~~

\end{lawx}

\begin{proof}
By \Law{conjunction-atomic-iterated}, 
.
\end{proof}




A guarantee distributes through 
non-deterministic choice, \strictconjunction, parallel and sequential composition,
and finite and infinite iterations.
\begin{lawx}[guarantee-distribute]

\end{lawx}

\begin{proof}
Property (\refproperty*{guarantee-distribute-nondet}) holds because \strictconjunction\ distributes over non-deterministic choice 
(\refaxiom*{conjunction-distribute-infimum}),
and (\refproperty*{guarantee-distribute-conjunction}--\refproperty*{guarantee-distribute-kleene}) 
hold by the corresponding properties (\refproperty*{conjunction-distribute-conjunction}--\refproperty*{conjunction-distribute-kleene}) of \Law{conjunction-distribute}.
For property (\refproperty*{guarantee-distribute-parallel}) the proviso holds 
because 
by (\refproperty*{parallel-atomic-omega1});
and
for property (\refproperty*{guarantee-distribute-sequential}) the proviso holds because

by (\refproperty*{sequential-refines-omega}).
Property (\refproperty*{guarantee-distribute-kleene}) holds by (\refproperty*{conjunction-distribute-kleene}) 
because  by (\refproperty*{omega-refsto-omega-kleene}).
Both (\refproperty*{sequential-refines-omega}) and (\refproperty*{omega-refsto-omega-kleene})
require the side condition ,
which holds by (\refproperty*{semantics-atomicrel}).
Property (\refproperty*{guarantee-distribute-omega}) follows from \Law{conjunction-distribute-guarantee}.
\end{proof}






\section{The rely quotient command}\label{section:rely}

Jones introduced the idea of a rely condition,
a reflexive relation assumed to be satisfied by 
every atomic step of the interference from the environment of a process \cite{jon83a}.
In essence it abstracts the environment by a process  
that executes steps satisfying the rely condition .
In the general algebra the environment is represented by an arbitrary process .
The rules of Jones then become a special case 
when  (see Section~\ref{section:Jones-rely}).
To handle relies in the general algebra, a rely quotient operator ``'' is introduced.
It is defined so that  in parallel with  implements ,
i.e.,

and furthermore for any process , if  then .
For example, because 
holds in the relational model,
one refinement of the quotient 
is .

The motivation for the rely quotient is similar to that for 
the weakest pre- and post-specifications of Hoare and He \cite{HoareHe86},
although they deal with residuals of sequential composition rather than parallel composition,
and
weakest environment of Chaochen and Hoare \cite{ChaochenHoare81,Chaochen:1982}.
The rely quotient  is defined as the non-deterministic choice over all commands
 satisfying the defining property of the rely quotient:
.
\begin{definitionx}[rely-quotient]~~~

\end{definitionx}
This definition is similar to defining division over the positive integers in terms of multiplication
and minimum ().

The only command  satisfying  might be the infeasible command ,
in which case  is infeasible.
In particular, taking the interference  to be the aborting process  gives,
,
unless , in which case .

Because the rely quotient operation is defined in terms of nondeterministic choice and parallel composition,
its instantiation in the relational model follows directly from its definition.
For completeness, an expansion of its definition in the relational model is given below,
in which  and  stand for the interpretations of these operators in the relational model;
recall that nondeterministic choice corresponds to set union and refinement to set containment.

A full appreciation of the utility of the rely quotient operator flows from its use in 
introducing a parallel composition in Section~\ref{section:parallel}
but first we examine a set of basic laws that it satisfies.


\subsection{Laws for rely quotients}

The following law shows that the rely quotient command satisfies its motivating property (\ref{rely-motivation}).
The law corresponds to  for positive integer division.
\begin{lawx}[rely-quotient]~~~

\end{lawx}

\begin{proof}
The notation  used below represents the set of values of the expression 
for  ranging over values that satisfy the predicate .
\begin{refine}
  c ~~\refsto~~ (c \quotient i) ~\parallel~ i
 \IFF*[by \Definition{rely-quotient}]
  c ~~\refsto~~ \Nondet \{ d \where (c ~\refsto~ d \parallel i) \} \parallel i
 \IFF*[distributing parallel over non-deterministic choice (\refaxiom*{parallel-distribute})]
  c ~~\refsto~~ \Nondet \{ d \where (c ~\refsto~ d \parallel i) \spot (d \parallel i) \}
 \ImpliedBy*[by \Lemma{non-deterministic-choice}]
  \forall d \in \{ d \where (c ~\refsto~ d \parallel i) \} ~\spot~ c \refsto (d \parallel i)
\end{refine}
\end{proof}


The following fundamental law shows that the rely quotient is the least command
satisfying its defining property.
It provides the basis for the proof of many of the
laws that follow 
and
shows the Galois connection between 
rely quotient 
and 
parallel composition 
\cite{Aarts92,Backhouse02}.
It corresponds to  for positive integer division.
\pagebreak[3]

\begin{lawx}[rely-refinement]~~~

\end{lawx}

\begin{proof}
For the proof from right to left assume .
\begin{refine}
  c \quotient i ~\refsto~ d
 \IFF*[by \Definition{rely-quotient}]
  \Nondet \{ d_1 \where (c ~\refsto~ d_1 \parallel i) \} ~\refsto~ d
 \ImpliedBy*[by \Lemma{non-deterministic-choice}]
  \exists d_0 \in \{ d_1 \where (c ~\refsto~ d_1 \parallel i) \} ~\spot~ d_0 \refsto d
 \ImpliedBy*[by assumption ]
  d \refsto d
\end{refine}
The proof from left to right assumes  and starts with \Law{rely-quotient}.
\begin{refine}
  c ~~\refsto~~ (c \quotient i) \parallel i
 \Implies*[by \Law{monotonic} part (\refproperty*{parallel-monotonic}) as ]
  c ~~\refsto~~ d \parallel i
\end{refine}\end{proof}
The property in \Law{rely-refinement} could be used as an alternative 
definition of the rely quotient operator.
From Galois theory, the rely quotient (lower adjoint) is uniquely defined by
the Galois connection provided parallel distributes over non-deterministic choice (\refaxiom*{parallel-distribute}).

Because  is the identity of parallel composition,
it is also the right identity of the rely quotient.
This is similar to 1 being the right identity of integer division ().
\begin{lawx}[rely-identity-right]~~~

\end{lawx}

\begin{proof}
The law holds by indirect equality if for all ,
,
which holds by \Law{rely-refinement} as follows:
  
\end{proof}


The following two laws correspond to
 
and

for positive integer division.
\begin{lawx}[rely-monotonic]~~~

\end{lawx}

\begin{proof}
By \Law{rely-refinement},  holds
if ,
which holds by the assumption  and \Law{rely-quotient} because

\end{proof}

\begin{lawx}[rely-weaken]~~~

\end{lawx}

\begin{proof}
By \Law{rely-refinement}  holds
if ,
which holds as follows.
\begin{refine}
    c 
  \Refsto*[by \Law{rely-quotient}] 
    (c \quotient i) \parallel i 
  \Refsto*[by \Law{monotonic} part (\refproperty*{parallel-monotonic}) as ]
    (c \quotient i) \parallel j
\end{refine}
\end{proof}

\begin{relational}[Italic text between horizontal lines partitions out material that applies only to the relational model.] \\
For relational rely conditions,
if 
,
then by (\refproperty*{strengthen-postcondition-atomic-kleene}),
,
and applying \Law{rely-weaken} gives
,
i.e. the relational rely condition can be weakened in a refinement. \\
\end{relational}
A nested rely  corresponds to implementing 
within environment , all within in environment ,
i.e.\  is implemented in environment .
The next law corresponds to 
for positive integer division.
\begin{lawx}[rely-nested]~~~

\end{lawx}

\begin{proof}
The law follows by indirect equality if for all , 
,
which is shown as follows.
\begin{refine}
  (c \quotient j) \quotient i \refsto x
 \IFF*[by \Law{rely-refinement}]
  c \quotient j \refsto x \parallel i
 \IFF*[by \Law{rely-refinement}]
  c \refsto x \parallel i \parallel j
 \IFF*[by \Law{rely-refinement}]
  c \quotient (i \parallel j) \refsto x
\end{refine}
\end{proof}
\noindent
Because parallel is commutative, 
it follows that


\begin{relational}For relational rely conditions
by property (\refproperty*{parallel-atomic-kleene}), 

and hence by \Law{rely-nested} 
nested relational relies of  and  give an effective rely of .
\end{relational}



\section{Parallel-introduction law}\label{section:parallel}

The prime motivation of Jones \cite{jon83a} for introducing rely and guarantee conditions
was to support reasoning about parallel compositions.
In the current paper 
a guarantee condition is generalised to a \strictconjunction\ with a process, 
and
a rely condition by a rely quotient by a process.
\Law{parallel-introduce} provides an general law for introducing a parallel composition.
The guarantee  of the first branch of the parallel corresponds to the rely of the second branch and vice versa for .
\begin{lawx}[parallel-introduce]~~~

\end{lawx}

\begin{proof}
By  \Law{rely-quotient} both 

and

and hence the proof follows using 
these two properties
in the first step.
\begin{refine}
  c \together d
 \Refsto*[by \Law{monotonic} part (\refproperty*{conjunction-monotonic}) and parallel is commutative (\refaxiom*{parallel-commutes})]
  ((c \quotient i) \parallel i) ~\together~ (j \parallel (d \quotient j))
 \Refsto*[exchanging \strictconjunction\ and parallel by \refaxiom{conjunction-exchange-parallel}]
  ((c \quotient i) \together j) ~\parallel~ (i \together (d \quotient j))
\end{refine}\end{proof}
The simplicity and elegance of the proof of this fundamental law for handling rely-guarantee
concurrency is an indication that \strictconjunction\ and rely quotient are well chosen abstractions.
The relationship to the parallel law of Jones is explored in Section~\ref{section:Jones-rely}
but first distribution properties of rely quotients need to be explored.






\section{Distribution of rely quotients}\label{section:rely-distribution}

\Law{parallel-introduce} introduces rely quotients of the form 
for some specification .
One way of refining such a quotient is to refine ,
for example,  may be refined to a sequential composition .
\Law{rely-monotonic} then gives that .
To further refine this it is useful to have a distribution law that allows the rely quotient
to be distributed over the sequential composition,
i.e.\ .
A proviso is needed for this refinement to be valid (see \Law*{rely-distribute-sequential} below).
This section investigates laws for distributing rely quotients over the other operators.
A rely quotient distributes straightforwardly over both
\strictconjunction\ and non-deterministic choice.
\begin{lawx}[rely-distribute-conjunction]~~~

\end{lawx}

\begin{proof}
By \Law{rely-refinement} the law is equivalent to 
.
\begin{refine}
  c \together d
 \Refsto*[by \Law{rely-quotient} twice]
  ((c \quotient i) \parallel i) ~\together~ ((d \quotient i) \parallel i)
 \Refsto*[exchanging \strictconjunction\ and parallel by \refaxiom{conjunction-exchange-parallel}]
  ((c \quotient i) \together (d \quotient i)) ~\parallel~ (i \together i)
 \Equals*[as ``'' is idempotent (\refaxiom*{conjunction-idempotent})]
  ((c \quotient i) \together (d \quotient i)) ~\parallel~ i 
\end{refine}\end{proof}


\begin{lawx}[rely-distribute-choice]~~~

\end{lawx}

\begin{proof}
By \Law{rely-refinement} the law is equivalent to 
.
\begin{refine}
  c \nondet d
 \Refsto*[by \Law{rely-quotient} twice]
  ((c \quotient i) \parallel i) ~\nondet~ ((d \quotient i) \parallel i)
 \Equals*[distributing parallel over non-deterministic choice (\refaxiom*{parallel-distribute})]
  ((c \quotient i) \nondet (d \quotient i)) ~\parallel~ i 
\end{refine}\end{proof}
Distribution of the rely quotient over parallel requires
a proviso on the interference  that .
That distribution law follows from a more general law with a parallel in both arguments of the quotient.
\begin{lawx}[rely-distribute-parallel]

\end{lawx}

\begin{proof}
By \Law{rely-refinement}, (\refproperty*{rely-distribute-parallel-a}) holds if 
,
which holds as follows.
\begin{refine}
  c \parallel d
 \Refsto*[by \Law{rely-quotient} twice]
  ((c \quotient i) \parallel i) \parallel ((d \quotient j) \parallel j)
 \Equals*[by associativity (\refaxiom*{parallel-associative}) and commutativity (\refaxiom*{parallel-commutes}) of parallel]
  (c \quotient i) \parallel (d \quotient j) \parallel i \parallel j
\end{refine}The proof of (\refproperty*{rely-distribute-parallel-b}) uses (\refproperty*{rely-distribute-parallel-a}) with  as follows.
\begin{refine}
  (c \parallel d) \quotient i
 \Refsto*[by \Law{rely-weaken} using assumption ] 
  (c \parallel d) \quotient (i \parallel i)
 \Refsto*[by part (\refproperty*{rely-distribute-parallel-a}) with ]
  (c \quotient i) ~\parallel~ (d \quotient i)
\end{refine}\end{proof}
\begin{relational}For a relational rely condition,
if  then by (\refproperty*{parallel-atomic-kleene}),

and hence the proviso for (\refproperty*{rely-distribute-parallel-b}) holds in this case.
The fact that the proviso for a relational rely condition holds
allows rely conditions to be distributed into any parallel composition.\\
\end{relational}
Distribution of a rely quotient of a process  over a sequential composition 
requires that separate occurrences of  running in parallel with each command in the sequence
can be refined to a single occurrence of  run in parallel with the sequence
as given by condition (\refproperty*{rely-distribute-sequential-assumption}).
\begin{lawx}[rely-distribute-sequential]
If for process , 

then~~~

\end{lawx}

\begin{proof}
By \Law{rely-refinement}, (\refproperty*{rely-distribute-sequential}) is equivalent to
.
\begin{refine}
    c \SSeq d
  \Refsto*[by \Law{rely-quotient} twice]
    ((c \quotient i) \parallel i) \SSeq ((d \quotient i) \parallel i)
  \Refsto*[by assumption (\refproperty*{rely-distribute-sequential-assumption}) with  and ]
    ((c \quotient i) \SSeq (d \quotient i)) \parallel i
\end{refine}
\end{proof}


\begin{relational}For a relational rely condition,
if  then 

holds for any ,  and  and hence proviso (\refproperty*{rely-distribute-sequential-assumption}) holds.
As with parallel, 
the use of a relational rely condition allows the rely to be distributed into any sequential composition.
In the general case, if proviso (\refproperty*{rely-distribute-sequential-assumption}) does not hold
the question arises as to what alternative approaches could be used -- as with \Law{rely-distribute-parallel}
these are likely to depend on the form of the interference.\\
\end{relational}


Distribution of the rely quotient over an iteration requires
the same side condition (\refproperty*{rely-distribute-sequential-assumption}) on distribution of the interference  over a sequential composition
as for \Law*{rely-distribute-sequential}.
The law uses the more general form .
This allows the law to be applied to a while loop ,
which can be defined in the form 
where  stands for the test of the while loop succeeding and  for it failing.
Just developing a law for  is problematic for the zero iterations case 
because this corresponds to  and  holds if and only if
, which only holds if  behaves as either  or .
\begin{lawx}[rely-distribute-iteration]
If 

holds for ,~~~

\end{lawx}

\begin{proof}
By \Law{rely-refinement} the law is equivalent to 

and by \Lemma{induction} it is sufficient to show,

which can be shown as follows.
\begin{refine}
  d \nondet c \SSeq (((c \quotient i)\FinOrInfIter \SSeq (d \quotient i)) \parallel i)
 \Refsto*[by \Law{rely-quotient} applied to each of the first  and ]
  ((d \quotient i) \parallel i) \nondet ((c \quotient i) \parallel i) \SSeq (((c \quotient i)\FinOrInfIter \SSeq (d \quotient i)) \parallel i)
 \Refsto*[by assumption (\refproperty*{rely-distribute-iteration-assumption}) with  and ]
  ((d \quotient i) \parallel i) \nondet (((c \quotient i) \SSeq (c \quotient i)\FinOrInfIter \SSeq (d \quotient i)) \parallel i)
 \Equals*[distributing parallel over non-deterministic choice (\refaxiom*{parallel-distribute})]
  ((d \quotient i) \nondet (c \quotient i) \SSeq (c \quotient i)\FinOrInfIter \SSeq (d \quotient i)) \parallel i
 \Equals*[factoring out  using (\refaxiom*{sequential-distribute-nondet-right})]
  ((\Nil \nondet (c \quotient i) \SSeq (c \quotient i)\FinOrInfIter) \SSeq (d \quotient i)) \parallel i
 \Equals*[folding using (\refaxiom*{least-fixed-point-unfold})]
  ((c \quotient i)\FinOrInfIter \SSeq (d \quotient i)) \parallel i
\end{refine}\end{proof}

\begin{relational}The proviso (\refproperty*{rely-distribute-iteration-assumption}) holds for a relational rely 
and hence \Law{rely-distribute-iteration} holds in this case.
\end{relational}



The following laws combine distribution properties with the introduction of a parallel composition.
\begin{lawx}[parallel-introduce-with-rely]~~

\end{lawx}

\begin{proof}\mbox{}
\begin{refine}
  (c \together d) \quotient i
 \Refsto*[by \Law{rely-distribute-conjunction}]
  (c \quotient i) ~\together~ (d \quotient i)
 \Refsto*[by \Law{parallel-introduce}]
  (j_1 \together ((c \quotient i) \quotient j_0)) ~\parallel~ (j_0 \together ((d \quotient i) \quotient j_1))
 \Equals*[by \Law{rely-nested} twice]
  (j_1 \together (c \quotient (j_0 \parallel i))) ~\parallel~ (j_0 \together (d \quotient (j_1 \parallel i)))
\end{refine}\end{proof}
In the right side of the above law one branch of the parallel guarantees  and the other guarantees ,
and hence their parallel combination guarantees .

\begin{lawx}[parallel-introduce-with-rely-guarantee]

\end{lawx}

\begin{proof}\mbox{}
\begin{refine}
  (j_1 \parallel j_0) ~\together~ ((c \together d) \quotient i)
 \Refsto*[by \Law{parallel-introduce-with-rely}]
  (j_1 \parallel j_0) ~\together~ ((j_1 \together (c \quotient (j_0 \parallel i))) ~\parallel~ (j_0 \together (d \quotient (j_1 \parallel i))))
 \Refsto*[exchanging \strictconjunction\ and parallel by \refaxiom{conjunction-exchange-parallel}]
  (j_1 \together j_1 \together (c \quotient (j_0 \parallel i))) ~\parallel~ (j_0 \together j_0 \together (d \quotient (j_1 \parallel i)))
 \Equals*[as \strictconjunction\ is idempotent (\refaxiom*{conjunction-idempotent})]
  (j_1 \together (c \quotient (j_0 \parallel i))) ~\parallel~ (j_0 \together (d \quotient (j_1 \parallel i)))
\end{refine}\end{proof}


\begin{relational}In the relational model by (\refproperty*{parallel-atomic-omega2}),

and hence if  and  the effective guarantee for \Law*{parallel-introduce-with-rely-guarantee}
is .\\
\vspace*{-2ex}\end{relational}




\section{Relationship to relational rely}\label{section:Jones-rely}

This section explores the relationship to the Jones-style rely condition.
Jones considered total correctness rules for handling the implementation of a
pre-post specification in a context satisfying a rely condition \cite{CoJo07}.
To instantiate the general theory presented here for Jones-style rely-guarantee rules,
termination needs to be handled.
For a terminating command, such as a specification , using a rely quotient of
 leads to an infeasible specification 
because by \Law{rely-quotient} this requires

but  is terminating and  has non-terminating behaviours
and hence  must rule out such infinite behaviours of its environment.
However, executable code cannot rule out behaviours of its environment and
hence using  for a rely quotient for a terminating command 
is not a feasible approach.
Therefore the terminating iteration  must be used.
Choosing  and  be the processes  and , respectively,
in \Law{parallel-introduce} gives the following.

Note that due to the use of a \strictconjunction\ to enforce a guarantee,
the first branch of the parallel composition is only required to maintain its guarantee condition 
as long as its environment maintains its rely condition .
If its environment does not maintain  the rely quotient can abort,
at which point the whole branch of the parallel is considered to have aborted
and hence the guarantee no longer needs to be maintained.


The parallel introduction rule of Jones \cite{jon83a} takes a postcondition of the form
 and introduces a parallel composition in which the two branches
ensure  and  respectively.
\begin{lawx}[parallel-specification]

\end{lawx}

\begin{proof}
Note that by (\refproperty*{spec-conjoin-spec}) 
a specification  is equivalent to .
\begin{refine}
    \Pre{p} \SSeq \Spec{}{}{q_0 \relint q_1} 
  \Equals*[by (\refproperty*{spec-conjoin-spec})]
    \Pre{p} \SSeq (\Spec{}{}{q_0} \together \Spec{}{}{q_1}) 
  \Refsto*[by \Law{parallel-introduce}]
    \Pre{p} \SSeq
    ((\FinGuar{g} \together (\Spec{}{}{q_0} \quotient \FinGuar{r})) ~\parallel~ 
     (\FinGuar{r} \together (\Spec{}{}{q_1} \quotient \FinGuar{g})))
  \Equals*[by \Law{precondition-parallel}]
    (\Pre{p} \SSeq (\FinGuar{g} \together (\Spec{}{}{q_0} \quotient \FinGuar{r}))) ~\parallel~ 
    (\Pre{p} \SSeq (\FinGuar{r} \together (\Spec{}{}{q_1} \quotient \FinGuar{g})))
\end{refine}
\end{proof}
The above corresponds to the Jones-style proof rule for introducing a parallel composition
although phrased in refinement calculus form rather than as a quintuple.






\section{Fair parallelism}\label{section:fair-parallel}


This section highlights the parts of the theory that are influenced by
the choice as to whether or not parallelism is assumed to be fair.
The semantics for parallel does not require fairness.
A fair semantics would rule out traces ending in an infinite sequence of
program steps of one process, if the other process could make a program step.
Most algebraic properties are independent of whether or not parallel 
is assumed to be fair.
Fair parallel is denoted by .
It refines the parallel operator used so far, which does not assume fairness.

If no fairness assumption is made about the parallel operator,
the notion of termination of a process is weak as it means 
a process terminates provided it is not permanently interrupted by its environment.
For the program
\begin{refine}
  x := 1;
  ((\While x \neq 0 \Do \Skip) \parallel x := 0)
\end{refine}the while loop will not terminate unless the 
is given a chance to set  to 0.
If parallelism is not assumed to be fair, 
the loop is not guaranteed to terminate even if it is not permanently interrupted;
in fact the problem comes if it is never interrupted by .
However, if parallel is assumed to be fair,
the right process will eventually set  to 0 and the loop will terminate.

Because the definition of the rely quotient operator depends on the parallel operator
there is different quotient operator corresponding to fair parallel.
\begin{definitionx}[fair-quotient]~~~

\end{definitionx}
From (\refproperty*{fair-refines-parallel}) it follows that 
,
that is, any implementation that handles any interference from process 
also handles fair interference from process .

In the relational model, the property

holds, but if parallel is fair (\refproperty*{parallel-atomic-omega3}) becomes a refinement 
because the left command allows an infinite sequence of steps satisfying 
(that do not satisfy ),
while the right command does not allow such a sequence if parallel is fair.
In proving the laws in this paper, we have relied on (\refproperty*{parallel-atomic-omega3}) only being a refinement, 
i.e.\ property (\refproperty*{parallel-atomic-omega2}),
and hence our laws also apply for fair parallel and fair quotient.



\section{Related work}

Dingel developed a refinement calculus for rely-guarantee concurrency \cite{DingelPhD,Dingel02}.
Like \cite{HayesJonesColvin14TR} it is based on relational rely and guarantee conditions
but unlike \cite{HayesJonesColvin14TR} and here, 
it makes use of a monolithic specification which is a four-tuple of pre, rely, guarantee and post conditions,
rather than our separate commands and operators.
The approach used here has the benefit of separating the different concepts 
and providing laws for each operator as well as combinations of operators.
The laws given here can be combined to derive laws similar to those of Dingel as well as many other laws.
The other major advance over Dingel is the generalisation to use processes 
for relies and guarantees.

Hoare {\it et al.}\ \cite{DBLP:journals/jlp/HoareMSW11} have developed a \emph{Concurrent Kleene Algebra (CKA)} 
and investigated its extension to a \emph{rely/guarantee CKA}.
Their algebra includes the axiom ,
which is not satisfied if  is either a non-terminating process or 
and hence they only consider partial correctness.
The rely/guarantee CKA includes a sub-algebra of commands called \emph{invariants},
in which an invariant  satisfies

because in their algebra  and hence 
(\refproperty*{invariant-refsto-parallel}) implies (\refproperty*{invariant-refsto-sequential}).
Properties (\refproperty*{invariant-refsto-parallel}) and (\refproperty*{invariant-refsto-sequential}) match
the properties 
used in \Law{conjunction-distribute} parts (\refproperty*{conjunction-distribute-parallel}) and (\refproperty*{conjunction-distribute-sequential}).
Properties (\refproperty*{invariant-refsto-nil}) and (\refproperty*{invariant-refsto-sequential}) together 
ensure that  and hence that 

matching \Law{conjunction-distribute} part (\refproperty*{conjunction-distribute-kleene}).
In a rely/guarantee CKA, for any  and  and any invariant , 

which matches our property (\refproperty*{rely-distribute-sequential-assumption}).
A rely/guarantee CKA does not require our property  
but \cite{DBLP:journals/jlp/HoareMSW11} does not consider an equivalent of \Law{rely-distribute-parallel}
for which this property is required.
In a rely/guarantee CKA 
a Jones-like rely-guarantee quintuple,
written  there, 
is defined in terms of a Hoare triple plus guarantee condition,
in which  and  are invariants (rather than relations).

Our ``equivalent'' of (\refproperty*{CKA-rg}) is of the form

although the two differ due to the different approaches taken.
Because  is an invariant 
the requirement  in (\refproperty*{CKA-rg}) reduces to ,
which is stronger than the requirement in (\refproperty*{gen-rg}). 
Firstly, in (\refproperty*{gen-rg})  is only required to satisfy the guarantee from initial states satisfying the precondition .
Secondly and more subtly,  may abort 
because its environment does not satisfy  and 
hence the left side of (\refproperty*{gen-rg}) aborts and so  no longer needs to maintain the guarantee.
This latter condition corresponds to Jones' requirement that the implementation only needs to maintain
the guarantee condition as long as its environment maintains the rely condition~\cite{jon83a}.
Our ability to use the weaker requirement comes from the use of the \strictconjunction\ operator,
which is not available in CKA.



\section{Conclusions}\label{section:conclusions}

The main contribution of this paper is to explore the essence of the rely-guarantee approach to concurrency.
Jones' guarantee condition is generalised from a relation to a process 
by making use of a \strictconjunction\ operator
and his rely condition from a relation to a process by introducing a rely quotient operator,
which forms a residual with respect to parallel composition (see \Law{rely-refinement}).
Both \strictconjunction\ and rely quotient have simple algebraic properties.
The \strictconjunction\ operator and parallel composition satisfy an exchange property
(\refaxiom*{conjunction-exchange-parallel})
which leads to a simple and elegant proof of \Law{parallel-introduce}, 
which is the key law for introducing a parallel composition in the generalised rely-guarantee theory.
Because our theory allows non-terminating processes,
it can handle total correctness properties as well as reasoning about non-terminating processes.

Generalising rely-guarantee theory so that guarantees and relies are arbitrary processes
rather than binary relations has highlighted the important algebraic properties of rely-guarantee theory.
In \Law{conjunction-distribute}, for a \strictconjunction\ of a command 
to distribute over a parallel composition one needs proviso (\refproperty*{c-to-c-parallel-c}); 
to distribute over a sequential composition one needs (\refproperty*{c-to-c-seq-c}); 
and
to distribute over finite 
iteration one needs 
(\refproperty*{c-to-c-seq-c}) and (\refproperty*{c-nil}).

Because all these properties hold if  is of the form  for any relation ,
the choice by Jones to represent interference by an (iterated atomic) relation,
rather than a general process,
means that \Law{guarantee-distribute} for the relational model 
does not require any provisos.

Even within the relational model more expressive guarantees are possible,
for example, a guarantee of  on 
may lead to the following refinement, in which  is refined sequentially to match the guarantees.
\begin{refine}
  \FinGuar{g_0} \SSeq \FinGuar{g_1} \together c
 \Refsto*[assuming ]
  \FinGuar{g_0} \SSeq \FinGuar{g_1} \together c_0 \SSeq c_1
 \Refsto*[exchanging \strictconjunction\ and sequential composition (\refaxiom*{conjunction-exchange-sequential})]
  (\FinGuar{g_0} \together c_0) \SSeq (\FinGuar{g_1} \together c_1)
\end{refine}

\Law{rely-distribute-parallel} has a proviso of (\refproperty*{i-parallel-i-to-i}),
and both \Law{rely-distribute-sequential} and \Law{rely-distribute-iteration} have a proviso of 
(\refproperty*{c-par-i-seq-d-par-i-to-c-seq-d-par-i}).

Because both these properties hold for  of the form  for any relation ,
the laws do not require any provisos for relational rely conditions
thus simplifying the process of distributing relational rely conditions.
Note that taking  and  to both be  in (\refproperty*{c-par-i-seq-d-par-i-to-c-seq-d-par-i})
gives .
An interesting question for future research is what other processes satisfy the
provisos required for the distribution properties to hold, 
or what other distribution properties can be used in their place.



In this paper we have considered an example model based on relational rely-guarantee. 
The model is similar to that used by others \cite{CoJo07,BoerHannemanDeRoever99,Dingel02,DeRoever01,HayesJonesColvin14TR}
but even within the relational model, guarantees and relies are treated more generally as processes.
Other possible models for future consideration are an event-based model
similar to that used with Concurrent Kleene Algebra \cite{DBLP:journals/jlp/HoareMSW11}
or a model that handles concurrency in a hybrid setting.






\section*{Acknowledgements}

The research reported here was supported by
Australian Research Council Grant DP130102901.
This paper has benefited from feedback from
Robert Colvin,
Cliff Jones,
Jo\~{a}o Ferreira,
Larissa Meinicke, 
Carroll Morgan,
Kim Solin,
Georg Struth,
Kirsten Winter
and the anonymous referees 
but the remaining errors are all courtesy of the author.
Special thanks go to Julian Fell and Andrius Velykis for mechanising the proofs of the laws in Isabelle/HOL.


\bibliographystyle{alpha}
\bibliography{absrg}

\newpage
{\small
\printindex
}


\end{document}
