\pdfoutput=1
\ifx\synctex\undefined\else\synctex=1\fi
\documentclass[final]{llncs}



\usepackage[utf8x]{inputenc}

\usepackage{microtype}


\usepackage{amsmath} 
\usepackage{amsxtra} 
\usepackage{amssymb}
\usepackage{mathabx}
\usepackage{mathtools}
\usepackage{textcomp}
\usepackage{bm}

\usepackage{url}

\let\Asterisk\relax
\let\Note\relax
\usepackage{commenting}

\usepackage{paralist}

\usepackage{graphicx} 




\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}
\usepackage{caption}


\spnewtheorem{ass}{Assumption}{\bfseries}{\itshape}
\spnewtheorem{fact}{Fact}{\bfseries}{\itshape}

\renewcommand{\iff}{\Leftrightarrow}


\newcommand{\rbr}{{\bf ]\!\!]}}
\newcommand{\lbr}{{\bf [\!\![}}
\newcommand{\sem}[1]{\lbr #1 \rbr}

\renewcommand{\vec}[1]{{\bf {#1}}}


\newcommand{\arrow}[2]{\xrightarrow{{\scriptscriptstyle #1}}}
\newcommand{\Arrow}[1]{\xRightarrow{{\scriptscriptstyle #1}}}
\newcommand{\xArrow}[2]{\xRightarrow[{\scriptscriptstyle #2}]{{\scriptscriptstyle #1}}}

\newcommand{\nat}{{\bf \mathbb{N}}}

\def\age#1{\left[#1\right]}
\def\set#1{{\left\{ #1 \right\}}}
\def\ntset#1{\mathbf{nt}(#1)}
\def\tuple#1{{\langle #1 \rangle}}
\def\nats{{\mathbb{N}}}
\def\zed{\mathbb{Z}}
\def\card#1{{|\!|{#1}|\!|}}
\def\len#1{{\vert{#1}\vert}}
\def\prod{\Delta}
\def\pat{{\mathbf{b}}}
\def\patt{{\widetilde{\mathbf{b}}}}
\def\patg{{\Gamma_\pat}}
\def\pattg{{\Gamma_\patt}}
\def\df#1{\scriptscriptstyle\mathbf{df}(#1)}
\def\fin#1{\mathop{\mathcal{F}}(#1)}
\def\nf#1{\mathop{n\!\mathcal{F}}(#1)}
\def\pr#1{\mathbf{pr}_{#1}}
\def\Sigmat{\ensuremath{\widetilde{\Sigma}}}
\def\Vars{\ensuremath{\Xi}}
\def\rank#1{\langle\!\langle#1\rangle\!\rangle}

\def\Bystar#1{\overset{\!\!\!\!(#1)}{=\!\Longrightarrow^\star}}
\def\By#1{\overset{(#1)}{\!\Longrightarrow}}

\def\cs#1{\texttt{\char`\\#1}}

\def\Varsi{\ensuremath{\Xi_{\widecheck{\text{\tiny 1..d}}}}}
\def\Varse{\ensuremath{\Xi_{\widehat{\text{\tiny 1..d}}}}}
\def\Varsil{\ensuremath{\Xi_{\widecheck{\text{\tiny ..r}}}}}
\def\Varsel{\ensuremath{\Xi_{\widehat{\text{\tiny ..r}}}}}
\def\Varsilj{\ensuremath{\Xi_{\widecheck{{\tiny j_1{.}{.}j_s}}}}}
\def\Varselj{\ensuremath{\Xi_{\widehat{{\tiny j_1{.}{.}j_s}}}}}

\newcommand{\cycles}[2]{\Omega_{{#1}}({#2})}
\newcommand{\cyclestar}[2]{(\Omega_{{#1}}({#2}))^*}

\def\bdwords{\Upsilon}

\renewcommand{\vec}[1]{{\mathbf {#1}}}

\def\proj{\mathbin{\downarrow}}

\def\foreach{\mathrm{REACH}_{\mathit{fo}}}

\declareauthor{ri}{Radu}{blue}
\declareauthor{pg}{Pierre}{red}
\declareauthor{er}{oldtext}{black!20!white}

\renewcommand{\proj}[2]{{#1}\mathclose{\downarrow}_{{#2}}}
\newcommand{\projpatt}[1]{{#1}\mathclose{\downdownarrows}_{{\patt}}}

\title{Interprocedural Reachability for Flat Integer Programs}
\author{Pierre Ganty\inst{1} \and Radu Iosif\inst{2}}
\institute{IMDEA Software Institute \quad  CNRS/VERIMAG, Grenoble, France}

\pagestyle{plain}

\begin{document}

\maketitle

\begin{abstract}
We study programs with integer data, procedure calls and arbitrary
call graphs. We show that, whenever the guards and updates are given
by octagonal relations, the reachability problem along control flow
paths within some language  over program
statements is decidable in \textsc{Nexptime}. To achieve this upper
bound, we combine a program transformation into the same class of
programs but without procedures, with an \textsc{Np}-completeness
result for the reachability problem of procedure-less
programs. Besides the program, the expression 
is also mapped onto an expression of a similar form but this time over
the transformed program statements. Several arguments involving
context-free grammars and their generative process enable us to give
tight bounds on the size of the resulting expression. The currently
existing gap between \textsc{Np}-hard and \textsc{Nexptime} can be
closed to \textsc{Np}-complete when a certain parameter of the
analysis is assumed to be constant.
\end{abstract}



\section{Introduction}

This paper studies the complexity of the reachability problem for a
class of programs featuring procedures and local/global variables
ranging over integers. In general, the reachability problem for this
class is undecidable \cite{minsky67}. Thus, we focus on a special case
of the reachability problem which restricts both the class of input
programs and the set of executions considered. The class of input
programs is restricted by considering that all updates to the integer
variables  are defined by \emph{octagonal constraints}, that
are conjunctions of atoms of the form , with
, where  denote the future values
of the program variables. The reachability problem is restricted by
limiting the search to program executions conforming to a regular
expression of the form  where the 's are
finite sequences of program statements.

We call this problem \emph{flat-octagonal reachability}
(fo-reachability, for short). Concretely, given:
\begin{inparaenum}[\upshape(\itshape i\upshape)]
\item a program  with procedures and local/global variables, 
      whose statements are specified by octagonal constraints, and
\item a bounded expression , where 's 
are sequences of statements of ,
\end{inparaenum}
the fo-reachability problem  asks:
can  run to completion by executing a sequence of program
statements  ?
Studying the complexity of this problem provides the theoretical
foundations for implementing efficient decision procedures, of
practical interest in areas of software verification, such as
bug-finding \cite{EsparzaG11}, or counterexample-guided abstraction
refinement \cite{KroeningLW13,HojjatIKKR12}.

Our starting point is the decidability of the fo-reachability problem
in the absence of procedures. Recently, the precise complexity of this
problem was coined to \textsc{Np}-complete \cite{bik14}. However, this
result leaves open the problem of dealing with procedures and local
variables, let alone when the graph of procedure calls has
cycles, such as in the example of
Fig. \ref{fig:running-example}~(a). Pinning down the complexity of the
fo-reachability problem in presence of (possibly recursive)
procedures, with local variables ranging over integers, is the
challenge we address here.

The decision procedure we propose in this paper reduces , from a program 
with arbitrary call graphs, to procedure-less programs as follows:
\begin{compactenum}
\item we apply a source-to-source transformation returning a procedure-less
      program , with statements also defined by
      octagonal relations, such that  is
      equivalent to the unrestricted reachability problem
      for , when no particular bounded expression is
      supplied.

\item we compute a bounded expression  over the statements
      of , such that  is
      equivalent to .
\end{compactenum}

The above reduction allows us to conclude that the fo-reachability
problem for programs with arbitrary call graphs is decidable and
in \textsc{Nexptime}. Naturally, the \textsc{Np}-hard lower
bound \cite{bik14} for the fo-reachability problem of procedure-less
programs holds in our setting as well.
Despite our best efforts, we did not close the complexity gap yet.
However we pinned down a natural parameter, called \emph{index},
related to programs with arbitrary call graphs, such that, when
setting this parameter to a fixed constant (like  in -SAT),
the complexity of the resulting fo-reachability problem for programs
with arbitrary call graphs becomes \textsc{Np}-complete. Indeed, when
the index is fixed, the aforementioned reduction computing
 runs in polynomial time. Then the
\textsc{Np} decision procedure for the fo-reachability of procedure-less
programs \cite{bik14} shows the rest.

The index parameter is better understood in the context of formal
languages. The control flow of procedural programs is captured
precisely by the language of a context-free grammar. A -index (
underapproximation of this language is obtained by filtering out the derivations 
containing a sentential form with  occurrences of nonterminals.
The key to our results is a toolbox of language theoretic
constructions of independent interest that enables to reason about the
structure of context-free derivations generating words into , that
is, words of the form  for some integers .

\begin{figure}[hbt]
\centering
\begin{picture}(0,0)\includegraphics{running-example.pdf}\end{picture}\setlength{\unitlength}{1973sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(9648,6348)(-32,-5851)
\put(7662,-5144){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3901,-91){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(9526,-3376){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(9526,-3601){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(9526,-3826){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(9526,-4051){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6128,-3392){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6203,-3167){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4126,-886){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4351,-1636){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4426,-211){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2401,-4186){\makebox(0,0)[b]{\smash{{\SetFigFont{5}{6.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2401,-5086){\makebox(0,0)[b]{\smash{{\SetFigFont{5}{6.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4726,-3961){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5101,-4636){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3901,-5086){\makebox(0,0)[b]{\smash{{\SetFigFont{5}{6.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5101,-5161){\makebox(0,0)[lb]{\smash{{\SetFigFont{5}{6.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1801,-3061){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(444,-3811){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1201,-4186){\makebox(0,0)[b]{\smash{{\SetFigFont{5}{6.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(699,-4118){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7876,-1936){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(c)}}}}}
\put(9601,-2836){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(9601,-4711){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7501,-4711){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6744,-3811){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4126,-1411){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4126,-511){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4876,-2161){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4876,314){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5626,-661){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5626,-916){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3826,-1786){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3976,-2011){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3301,-886){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3001,-1111){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3901,-4186){\makebox(0,0)[b]{\smash{{\SetFigFont{5}{6.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5401,-4186){\makebox(0,0)[b]{\smash{{\SetFigFont{5}{6.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(8026,-3436){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(8026,-3211){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7201,-586){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0} }}}}}
\put(7201,-886){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7201,-1186){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7201,-1486){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7403,-2829){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4501,-2536){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(b)}}}}}
\put(1051,-2536){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}The program }}}}}
\put(901,-2506){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(a)}}}}}
\put(601,239){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}int {\tt P}(int x) \{}}}}}
\put(601,-16){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}int z;}}}}}
\put(601,-361){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}1: assume();}}}}}
\put(601,-661){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}2: if ()}}}}}
\put(601,-961){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}3:\ \ \ \ z := P(x-1);}}}}}
\put(601,-1261){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}4:\ \ \ \ z := z+2;}}}}}
\put(601,-1861){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}6:\ \ \ \ z := 0}}}}}
\put(601,-2161){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}7: return z; \}}}}}}
\put(601,-1561){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}5: else}}}}}
\put(4951,-1186){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1726,-4261){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3226,-3961){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1201,-3286){\makebox(0,0)[b]{\smash{{\SetFigFont{5}{6.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2401,-3286){\makebox(0,0)[b]{\smash{{\SetFigFont{5}{6.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(966,-3526){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1785,-3586){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2451,-3575){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3066,-4896){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4954,-4917){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4100,-4546){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1371,-4726){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6477,-4486){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6422,-4261){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7314,-3821){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7283,-4036){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7454,-2487){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1830,-5720){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(d)}}}}}
\put(7265,-5734){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}(e)}}}}}
\put(7460,-5755){\makebox(0,0)[lb]{\smash{{\SetFigFont{8}{9.6}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}The program }}}}}
\put(8010,-2660){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7573,-5374){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7681,-4941){\makebox(0,0)[lb]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3901,164){\makebox(0,0)[b]{\smash{{\SetFigFont{6}{7.2}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture}\caption{ () are for
the input (output) values of  and , respectively. 
 provide extra copies.
 stands for
, and  for
.  }
\label{fig:running-example}
\end{figure}

To properly introduce the reader to our result, we briefly recall the
important features of our source-to-source transformation through an
illustrative example. We apply first our program
transformation \cite{gik13} to the program  shown in
Fig. \ref{fig:running-example} (a). The call graph of this program
consists of a single state  with a self-loop. The output
program  given Fig. \ref{fig:running-example} (e), has
no procedures and it can thus be analyzed using any existing
intra-procedural tool \cite{bik10,BFLP03}. The relation between the
variables  and  of the input program can be inferred from
the analysis of the output program. For instance, the input-output
relation of the program  is defined by , which
matches the precondition  of the
program . Consequently, any assertion such as
``\emph{there exists a value  such that }''
can be phrased as: ``\emph{there exist values  such
that  reaches its final state}''. While the former
can be encoded by a reachability problem on , by adding
an extra conditional statement, the latter is an equivalent
reachability problem for .

For the sake of clarity, we give several representations of the input program
 that we assume the reader is familiar with including the text of the
program in Fig.  \ref{fig:running-example} (a) and the corresponding control flow
graph in Fig.  \ref{fig:running-example} (b).


In this paper, the formal model we use for programs is based on context-free grammars.
The grammar for  is given at  Fig. \ref{fig:running-example} (c).
The r\^ole of the grammar is to define the set
of \emph{interprocedurally valid} paths in the control-flow graph of
the program . Every edge in the control-flow graph matches one or two
symbols from the finite alphabet
,
where  and  denote the
call and return, respectively. The set of nonterminals is
. Each edge
in the graph translates to a production rule in the grammar, labeled
 to .  For instance, the call edge
 becomes
. The language of the grammar of Fig.~\ref{fig:running-example} (c) (with axiom ) is
the set  of 
interprocedurally valid paths in the control-flow graph. Observe that
 is included in the language of the regular expression .

Our program transformation is based on the observation that the semantics of
 can be precisely defined on the set of \emph{derivations} of
the associated grammar. In principle, one can always represent this set of
derivations as a possibly infinite automaton (Fig. \ref{fig:running-example}
(d)), whose states are sequences of nonterminals annotated with priorities
(called ranks)\footnote{The precise definition and use of ranks will be
explained in Section~\ref{sec:dfkderiv}.}, and whose transitions are labeled
with production rules. Each finite path in this automaton, starting from
, defines a valid prefix of a derivation. Since , Luker \cite{Luker78} shows that it is sufficient to keep a finite
sub-automaton, enclosed with a dashed box in Fig.~\ref{fig:running-example} (d),
in which each state consists of a finite number of ranked nonterminals (in our
case at most .

Finally, we label the edges of this finite automaton with octagonal
constraints that capture the semantics of the relations labeling the
control-flow graph from Fig. \ref{fig:running-example} (b). We give
here a brief explanation for the labeling of the finite automaton in
Fig. \ref{fig:running-example} (e), in other words, the output
program  (see \cite{gik13} for more details). The idea
is to compute, for each production rule , a relation
, based on the constraints associated
with the symbols occurring in  (labels from
Fig. \ref{fig:running-example} (b)). For instance, in the transition
, the auxiliary variables store
intermediate results of the computation of  as
follows: . The guard of the transition can be understood by
noticing that  gives rise to the constraint
,  to , 
corresponds to the frame condition of the call, and 
copies all current values of  to the future ones.
It is worth pointing out that the constraints labeling the transitions
of the program  are necessarily octagonal if the
statements of  are defined by octagonal constraints.

An intra-procedural analysis of the program  in
Fig. \ref{fig:running-example} (e) infers the precondition
 which coincides with the input/output
relation of the recursive program  in
Fig. \ref{fig:running-example} (a), i.e.\ . The
original query  translates
thus into the satisfiability of the formula , which is clearly false.

The paper is organised as follows: basic definitions are given Section \ref{sec:prelim},
Section~\ref{sec:foreachpb} defines the fo-reachability problem, 
Section~\ref{sec:dfkderiv} presents an alternative program semantics based on derivations
and introduces subsets of derivations which are sufficient to decide reachability,
Section \ref{sec:bounded-control-sets} starts with on overview of our decision
procedure and our main complexity results and continues with the key steps of our algorithms. 
The appendix contains all the missing details.
\comment[pg]{Turn into ``A companion technical report \cite{} contains the missing details.''}

\section{Preliminaries}\label{sec:prelim}

Let  be a finite nonempty set of symbols, called
an \emph{alphabet}. We denote by  the set of finite words
over  which includes , the empty word. The concatenation
of two words  is denoted by  or .
Given a word , let  denote its length and
let  with  be the th symbol
of . Given  and , we
write  for the word obtained by deleting
from  all symbols not in , and sometimes we
write  for .
A {\em bounded expression}  over alphabet  is a regular
expression of the form , where  are nonempty words and its size is given by .  We use  to denote both the bounded expression and its
language. We call a language  \emph{bounded} when  for some bounded expression .

A \emph{grammar} is a tuple 
where  is a finite nonempty set
of \emph{nonterminals},  is an alphabet of \emph{terminals},
such that , and
 is a finite set
of \emph{productions}. For a production , often conveniently noted , we define its {\em
size} as , and  defines the size of .

Given two words , a production  and a position , we define
a \emph{step}  if and only if 
and . We omit  or  above the arrow when
clear from the context.
A \emph{control word} is a finite word  over the
alphabet of productions. A \emph{step sequence}  is a sequence  where .
If  is a nonterminal and  is a word
without nonterminals, we call the step sequence  a \emph{derivation}. When the control word  is not
important, we write  instead
of , and we chose to omit the grammar 
when clear from the context.


Given a nonterminal  and , i.e.\  is either a nonterminal or the empty word,
we define the set .  The set  is
  called the {\em language} of  produced by , and is denoted
   in the following. For a set  of
  control words (also called a \emph{control set}), we denote by
   the language generated by  using only control words from
. We also write  for 
.

Let  denote a nonempty finite set of integer variables,
and . A \emph{valuation} of
 is a function . The
set of all such valuations is denoted by . A formula
 is evaluated with respect to two valuations
, by replacing each occurrence of
 with  and each occurrence of 
with . We write  when the formula
obtained from these replacements is valid. A formula
 \emph{defines} a relation
 whenever for all , we have
 if{}f . The composition of
two relations  defined by formulae  and
, respectively, is the relation , defined by 
.
For a finite set , we denote its cardinality by .

\section{Interprocedural Flat Octogonal Reachability}\label{sec:foreachpb}

In this section we define formally the class of programs and
reachability problems considered. An \emph{octagonal relation}
 is a relation defined 
by a finite conjunction of constraints of the form
, where  and 
. The set of octagonal relations over the variables in 
 and  is denoted as . 
The \emph{size} of an octagonal relation , denoted  is
the size of the binary encoding of the smallest octagonal constraint
defining .

An \emph{octagonal program} is a tuple
, where  is a grammar
,  is an \emph{initial} 
location, and  is a mapping of
the words produced by the grammar , starting with the initial
location , to octagonal relations.  The alphabet 
contains a symbol  for each \emph{internal} program statement
(that is not a call to a procedure) and two symbols  for each \emph{call} statement . The grammar 
has three kinds of productions: \begin{inparaenum}[\upshape(\itshape
i\upshape)]
\item  if  is a statement leading from  to a return location, 
\item  if  leads from  to , and 
\item  if  is a call statement, 
 is the initial location of the callee, and  is the continuation of the call.
\end{inparaenum}
Through several program transformations, we may generate another
grammar with other kinds of productions. \comment[ri]{this sounds strange; I would remove it entirely}
The only property we need for our results is that every grammar 
with we deal with has each of its productions  satisfying:
 and 
where  and  are the terminals and nonterminals of , respectively.
Each edge  that is not a call has an associated octagonal
relation  and each matching
pair  has an associated \emph{frame
condition} , which equates
the values of the local variables, that are not updated by the call,
to their future values. The size of an octagonal program , with , is the
sum of the sizes of all octagonal relations labeling the productions
of , formally .

For example, the program in Fig. \ref{fig:running-example} (a,b) is
represented by the grammar in Fig. \ref{fig:running-example} (c).  The
terminals are mapped to octagonal relations
as: , , , 
and . The frame
condition is , as only  is
updated by the call .

\smallskip
\noindent {\bf Word-based semantics.} For each word , each occurrence of a
terminal  in  is matched by an occurrence
of , and the matching positions are nested\footnote{A
relation 
is said to be nested \cite{alur-jacm09} when no two pairs  and  cross each other, as in . }. The semantics of the word  is an octagonal
relation defined inductively\footnote{Octagonal relations are closed under intersections and compositions \cite{mine}.} on the
structure of :
\begin{inparaenum}[\upshape(\itshape i\upshape)]
\item , 
\item , and
\item ,
\end{inparaenum}
for all  such that  and  match. For instance, the
semantics of the word
, for the grammar  given in Fig. \ref{fig:running-example} (c), is 
. Observe that this word defines the effect of 
an execution of the program in Fig. \ref{fig:running-example} (a)
where the function  is called twice---the first call is
a top-level call, and the second is a recursive call (line 3).

\smallskip
\noindent {\bf Reachability problem.}
The semantics of a program  is
defined as . Consider, in addition, a bounded
expression , we
define .  The problem asking
whether 
for a pair  is called
the \emph{flat-octagonal reachability problem}.
We use   to denote
a particular instance. 


\section{Index-bounded depth-first derivations}\label{sec:dfkderiv}

In this section, we give an alternate but equivalent program semantics
based on derivations.  Although simple, the word semantics is defined
using a nesting relation that pairs the positions of a word labeled
with matching symbols  and . In contrast,
the derivation-based semantics just needs the control word.

To define our derivation based semantics, we first define structured
subsets of derivations namely the depth-first and bounded-index
derivations. The reason is two-fold:
\begin{inparaenum}[\upshape(\itshape a\upshape)]
\item the correctness proof of our program transformation \cite{gik13} 
      returning the procedure-less program  depends on
	bounded-index depth-first derivations, and
\item in the reduction of the  problem to
	that of , the computation
	of  depends on the fact that the control structure
	of  stems from a finite automaton recognizing
	bounded-index depth-first derivations.
\end{inparaenum}
Key results for our decision procedure are those of
Luker \cite{Luker78,Luker80} who, intuitively, shows that
if  then it is sufficient to consider
depth-first derivations in which no step contains more than 
simultaneous occurrences of nonterminals, for some 
(Theorem \ref{thm:luker}). 

\noindent {\bf Depth-first derivations.}
It is well-known that a derivation can be associated a unique parse
tree.  A derivation is said to be \emph{depth-first} if it corresponds
to a depth-first traversal of the corresponding parse tree.  More
precisely, given a step sequence , and two
integers  and
 such that  and  define
 to be the index  of the first word  of the step
sequence in which the particular occurrence of  appears.
A step sequence is \emph{depth-first} \cite{Luker80} if{}f for all , :
{\setlength\abovedisplayskip{4pt}
\setlength\belowdisplayskip{4pt}
}
For example,  is depth-first, whereas  is not. We
have  because  first appeared
at ,  because  first appeared
at ,  and  since . We denote by  a depth-first
step sequence and call it depth-first derivation when  and .


\noindent {\bf Depth-first derivation-based semantics.}
In previous work \cite{gik13}, we defined the semantics of a
procedural program based on the control word of the derivation instead of the produced words. We briefly
recall this definition here. Given a depth-first
derivation , the
relation 
is defined inductively on  as follows:
\begin{inparaenum}[\upshape(\itshape i\upshape)]
\item ,
\item  where
       , and
\item  where 
      and .
\end{inparaenum}
We showed \cite[Lemma 2]{gik13}
that, whenever , we have  if{}f .


\noindent {\bf Index-bounded derivations.}
A step  is
said to be -index ( if{}f 
neither  nor  contains  occurrences of nonterminals, i.e.
 and .
We denote by 
a -index step sequence and by
 a step
sequence which is both depth-first and -index.
For ,  and , we
define the -\emph{index language} , the -\emph{index
depth-first control set} . We write 
and  when , and drop  from
the previous notations, when the grammar is clear from the
context. For instance, for the grammar in
Fig. \ref{fig:running-example} (c), we have  
and .
\smallskip

\begin{theorem}[Lemma~2 \cite{Luker80}, Theorem~1 \cite{Luker78}]\label{thm:luker}
Given a grammar  and :
\begin{compactitem}
\item for all ,   if and only if
	;
\item if  for a bounded expression  over  then
	 where .
\end{compactitem}
\end{theorem}

The introduction of the notion of index naturally calls for an index
dependent semantics and an index dependent reachability problem. As we
will see later, we have tight complexity results when it comes to the
index dependent reachability problem. Given ,
let 
and let . Thus we define, for a constant 
not part of the input, the
problem , which asks
whether .


\noindent {\bf Finite representations of bounded-index depth-first control sets.}
It is known that the set of -index depth-first derivations of a
grammar  is recognizable by a finite
automaton \cite[Lemma~5]{Luker80}. Below we give a formal definition of this
automaton, that will be used to produce bounded control sets for
covering the language of . Moreover, we provide an upper bound on
its size, which will be used to prove an upper bound for the time
to compute this set (Section \ref{sec:bounded-control-sets}).

Given  and a grammar , we define a
labeled graph  such that its paths defines the set of
-index depth-first step sequences of .  To define the vertices and
edges of this graph, we introduce the notion of ranked words, where the rank
plays the same r\^ole as the value  defined previously. The advantage
of ranks is that only  of them are needed for -index depth-first
derivations whereas the set of  values grows with the length of
derivations. Since we restrict ourselves to -index
depth-first derivations, we thus only need  ranks, from  to .  
The rank based definition of depth-first derivations can be found in
Appendix~\ref{app:fsa-dfk}.
\comment[pg]{Turn into ``The rank based definition of depth-first derivations can be found in the technical report \cite{}.''}

For a -dimensional vector , we
write  for its th element (. A vector  is
said to be \emph{contiguous} if
, 
for some . 
Given an alphabet  define the ranked alphabet  
to be the set .
A ranked word is a word over a ranked alphabet. 
Given a word  of length  and an -dimensional
vector , the \emph{ranked
word}  is the sequence
, 
in which the th element of  annotates the th symbol of . We also denote  as a
shorthand. Let  be the
following labeled graph, where: 
{\setlength\abovedisplayskip{4pt}
\setlength\belowdisplayskip{4pt}
}
is the set of vertices, the edges are labeled by the set  of
productions of , and the edge relation is defined next. For all
vertices  and labels , we
have  if and only if
\begin{compactitem}
\item  for some , where  is the maximum rank in , and 
\item , 
where  and  
\end{compactitem}
We denote
by  the size (number of vertices)
of . In the following, we omit the subscript 
from , when the grammar is clear from the context. For
example, the graph  for the grammar from
Fig. \ref{fig:running-example} (c), is the subgraph of
Fig. \ref{fig:running-example} (d) enclosed in a dashed line.

\begin{lemma}\label{fsa-dfk}
Given , and , for each 
,  and , we have
 if and only if 
is a path in . Moreover, we have .
\end{lemma}

\section{A Decision Procedure for }
\label{sec:bounded-control-sets}

In this section we describe a decision procedure for the
problem  where  is an octagonal program, whose underlying grammar
is , and  is
a bounded expression over . The procedure follows the
roadmap described next. 

First, we compute, in time polynomial in the sizes of
 and , a set of programs
, 
such that ,
which implies .  The grammar  is
an automata-theoretic product between the grammar  and the bounded expression . For space
reasons, the formal definition of  is deferred to
Appendix \ref{sec:easy}, and we refer the reader to
Example \ref{ex:bounded-expression1}. 
\comment[pg]{Turn into ``Details are in the technical report \cite{} but an example of  is provided below.''}
Deciding 
reduces thus to deciding several
instances  of the
fo-reachability problem.

\begin{example}\label{ex:bounded-expression1}
  Let us consider the bounded expression . 
  Consider the grammar  with the following productions: 
  ,  
  ,
  ,
  ,
  ,
  . 
It is easy to check that .  
  Let  where 
  , 
  i.e.\ we have .  The following productions define a grammar : 
  {\small}
One can check . 
\end{example}

A bounded expression  over
alphabet  is said to be {\em -letter-bounded} (or simply
letter-bounded, when  is not important) when , for all
. A letter-bounded expression  is \emph{strict}
if all its symbols are distinct. A language  is
(strict, letter-)~bounded if{}f , for some (strict,
letter-)~bounded expression .

Second, we reduce the problem from  to the
strict letter-bounded case , by building a
grammar , with the same nonterminals as , such
that, for each 
\begin{inparaenum}[\upshape(\itshape i\upshape)]
\item ,
\item  if{}f 
	, for all 
\item\label{it:transposition} from each control set  that covers the language 
 for some , 
one can compute, in polynomial time, a control
set  that covers the
language .
\end{inparaenum}

\begin{example}[contd. from Example \ref{ex:bounded-expression1}]\label{ex:bounded-expression2}
  Let ,  and 
   be the homomorphism given 
  by  and . The grammar  
  results from deleting 's and 's in  and replacing 
   in  by ,  in  by  and  by .
  Then, it is easy to check that . \hfill 
\end{example}

Third, for the strict letter-bounded grammar , we compute
a control set  using the
result of Theorem \ref{thm:letter-bounded-control-set}, which yields
a set of bounded expressions , such
that . 
By applying the aforementioned transformation
({\itshape\ref{it:transposition}}) from 
to , we obtain
that .
Theorem \ref{thm:luker} allows to effectively compute value 
such that , for
all . Thus we obtain\footnote{Because
 .}
, for all .

The final step consists in building a finite
automaton  that recognizes the control
set  (Lemma \ref{fsa-dfk}). This yields a
procedure-less program , whose control structure is
given by , and whose labels are given by the semantics
of control words. We recall that, for every word  there exists a control
word  such
that  if{}f . We
have thus reduced each of the
instances  of the
fo-reachability problem to a set of
instances . The
latter problem, for procedure-less programs, is decidable in
\textsc{Nptime} \cite{bik14}. Next is our main result whose proof is in Appendix~\ref{app:fo-reachability}.
\comment[pg]{Turn into ``A detailed proof of the main result, stated next, is given in the technical report \cite{}''.}

\begin{theorem}\label{thm:fo-reachability}
Let  be an octagonal program,
where  is a grammar, and  is a
bounded expression over . Then the
problem  is decidable
in \textsc{Nexptime}, with a \textsc{Np}-hard lower bound.  If,
moreover,  is a constant,  is \textsc{Np}-complete.
\end{theorem}










The rest of this section describes the construction of the control
sets  and gives upper bounds on the time needed
for this computation. We use the following ingredients:
\begin{inparaenum}[\upshape(\itshape i\upshape)] 
\item Algorithm \ref{alg:constant-control-set} for building 
bounded control sets for -letter bounded languages, where  is a constant 
(in our case, at most ) (Section \ref{sec:constant-control-set}), and
\item a decomposition of -index depth-first derivations, that 
distinguishes between a prefix producing a word from the -letter
bounded expression , and a suffix producing two words
included in bounded expressions strictly smaller than 
(Section \ref{sec:bounded}). 
\end{inparaenum}
The decomposition enables the generalization from -letter bounded
languages where  is a constant to arbitrary letter bounded
languages. In particular, the required set of bounded
expressions  is built inductively over the
structure of this decomposition, applying at each step
Algorithm \ref{alg:constant-control-set} which computes bounded
control sets for 2-letter bounded languages. The main algorithm
(Algorithm \ref{alg:bounded-control-set}) returns a finite
set  of bounded expressions
. Below we abuse notation and
write 
for . The time needed to build each
bounded expression  is
 and does not depend of ,
whereas the time needed to build the entire set 
is . These arguments come in handy when
deriving an upper bound on the (non-deterministic) time complexity of
the fo-reachability problem for programs with arbitrary call graphs.
A non-deterministic version of Algorithm \ref{alg:bounded-control-set}
that choses one set , instead of
building the whole set , is used to establish the
upper bounds for the 
and  problems in the proof of
Theorem \ref{thm:fo-reachability}.

\subsection{Constant -Letter Bounded Languages}\label{sec:constant-control-set}

Here we define an algorithm for building
bounded control sets that are sufficient for covering a -letter
bounded language , when
 is a constant\footnote{In our case , but the
construction can be generalized to any constant . }, i.e.\
not part of the input of the algorithm. In the following, we consider
the labeled graph ,
whose paths correspond to the -index depth-first step sequences of
 (Lemma~\ref{fsa-dfk}). Recall that the number of vertices in this
graph is . 

Given , we denote by  the set of paths with
source  and destination . For a path , we denote
by  the sequence of edge labels on .
A path  is a \emph{cycle} if its endpoints coincide.
Furthermore, the path is said to be an \emph{elementary cycle} if it
contains no other cycle than itself.  Finally,  is acyclic if
it contains no cycle.  The word \emph{induced} by a path
in  is the sequence of terminal symbols generated by the
productions fired along that path. Observe that,
since , any word induced by a
subpath of some path  is
necessarily of the form , for
some .

Algorithm~\ref{alg:constant-control-set} describes the effective
construction of a bounded expression  over the productions
of  using the sets of elementary cycles of . The crux
is to find, for each vertex  of , a subset  of
elementary cycles having  at the endpoints, such that the set of
words induced by  is that of the entire set of elementary
cycles having  at endpoints. Since the only vertex occurring more
than once in an elementary cycle  is the endpoint , we
have that  is at most the number of
vertices , and each production rule generates at
most  terminal symbols, hence no word induced by a elementary cycle
is longer than . The number of
words  induced by elementary cycles
with endpoints  is thus bounded by the number of nonnegative
solutions of the inequality ,
which, in turn, is of the order of . So for
each vector  such that , it suffices to
include in  only one elementary cycle inducing the
word .
Thus it is sufficient to consider sets  of cardinality
, for all .

Lines (\ref{ln:h-start}--\ref{ln:h-end}) of Algorithm
\ref{alg:constant-control-set} build a graph 
with vertices , where 
is a vertex of  and  a solution to the
above inequality (line~\ref{ln:h-start}), hence  is a
finite and computable graph. There is an edge between two vertices
 and  in  if and only if  in
 and  for every , that is  is the
sum of  and the number of occurrences of 
produced by  (which is precisely captured by the
word  (line \ref{ln:h-trans}). The sets 
are computed by applying the Dijkstra's single source shortest path
algorithm\footnote{We consider all edges to be of weight .}  to
the graph  (line \ref{ln:dijkstra}) and retrieving
in  the paths , such that 
(line \ref{ln:cq}).

For a finite set of words , the function
 returns the bounded expression .
Algorithm \ref{alg:constant-control-set} uses this function to build a
bounded expression  that covers all words induced by paths
from . This construction relies on the
following argument: for each , there
exists another path , such that
their induced words coincide, and, moreover,  can be
factorizedas
,
where ,  and  for each  are acyclic paths,  are
elementary cycles with endpoints , respectively,
and . Thus we can cover each segment
 by a bounded expression 
(line \ref{ln:concat-prod}), and each segment  by the
bounded expression  (line \ref{ln:concat-cq}), yielding the required
expression . The following lemma proves the correctness of
Algorithm \ref{alg:constant-control-set} and gives an upper bound on its runtime.

\begin{lemma}\label{lem:ginsbook-d}
  Let  be a grammar
  and  is a strict -letter-bounded
  expression over , where  is a constant.
  Then, for each  there exists a bounded expression 
  over  such that, for all  and
  , we have , provided
  that . Moreover, 
  is computable in time .
\end{lemma}

\begin{algorithm}[thb]
{\scriptsize
\begin{algorithmic}[0]
\State {\bf input} A grammar , 

       \State \hspace*{7mm} a strict -letter-bounded expression  
       over , where  is a fixed constant,

       \State \hspace*{7mm} and 

  \State {\bf output} a bounded expression  over  such that
  
	for all  and , such that
	
\end{algorithmic}
\begin{algorithmic}[1]
  \Function{ConstantBoundedControlSet}{}

	\State  \label{ln:h-start}

        \State 
				\Comment{ are the vertices of , considering  suffices}

	\State A^{\df{k}}
        \label{ln:h-trans}

        \State \label{ln:h-end}

        \State 

        \State 
        \label{ln:dijkstra}

  \For{}\label{ln:b0-start}

	\State 
        \label{ln:cq}

	\State 
        \label{ln:concat-cq}

  \EndFor\label{ln:b0-end}

  \State  
  \label{ln:c-start}

  \For{}
           \State 
           \label{ln:concat-prod}
  \EndFor\label{ln:c-end}

  \State  

  \For{}\label{ln:pat-start}
  \State 
  \EndFor\label{ln:pat-end}

  \State 
  \State {\bf return} 
  \EndFunction
\end{algorithmic}
\caption{Control Sets for the Case of Constant Size Bounded Expressions}\label{alg:constant-control-set}
}
\end{algorithm}

\subsection{The General Case}\label{sec:bounded}

The key to the general case is a lemma decomposing derivations. 

\noindent {\bf Decomposition Lemma.} Our construction of a bounded control set that covers a strict
letter-bounded context-free language  is by induction on , and is inspired by a
decomposition of the derivations in , given by
Ginsburg \cite[Chapter 5.3, Lemma 5.3.3]{ginsburg}. Because
his decomposition is oblivious to the index or the depth-first policy,
it is too weak for our needs. Therefore, we give first a stronger
decomposition result for -index depth-first derivations. 


Without loss of generality, the decomposition lemma assumes the bounded
expression covering  to be \emph{minimal}: a strict letter-bounded
expression  is \emph{minimal} for a language  if{}f  and for every subexpression , resulting from deleting
some  from , we have .  Clearly,
each strict letter-bounded language has a unique minimal expression.

Basically, for every -index depth-first derivation with control
word , its productions can be rearranged into a -index
depth-first derivation, consisting of a prefix 
producing a word in , then a production  followed by two control words  and  that
produce words contained within two bounded expressions
 and , respectively, where
 (Lemma~\ref{lem:ginsbook-surgery}).
Let us first define the partition  of , as
follows: {\setlength\abovedisplayskip{4pt}
\setlength\belowdisplayskip{4pt}
}
Naturally, define .
Since the bounded expression  is, by assumption, 
minimal for , then  occurs in some word of 
and  occurs in some word of . Thus it is always the
case that , since . The
partition of nonterminals into  and  induces a
decomposition of the grammar . First, let , where:
{\setlength\abovedisplayskip{4pt}
\setlength\belowdisplayskip{4pt}
}
Then, for each production  such that  and , we define the grammar , where:
{\setlength\abovedisplayskip{4pt}
\setlength\belowdisplayskip{4pt}
}
The decomposition of derivations is formalized by the following lemma: 

\begin{lemma}\label{lem:ginsbook-surgery}
  Given a grammar , a nonterminal
   such that  for
  some , and , for every derivation
  , there exists a production  with
  ,  and
  , and
  control words ,
  , such
  that  is a
  permutation of 
  and: \begin{compactenum} 
  
  \item\label{item1:ginsbook-surgery}  is a step sequence in 
  with ;

  \item\label{item2:ginsbook-surgery}  and  are (possibly empty) derivations 
                in  (, for some integers , 
                such that  and ;

  \item\label{item3:ginsbook-surgery} 
  
	if , and
    
		if ;        

  \item\label{item4:ginsbook-surgery} ;
  \item\label{item5:ginsbook-surgery}  if , and  if , for some integers
    , such that .
  \end{compactenum}
\end{lemma}



Let us now turn to the general case, in which the size of the strict
letter-bounded expression  is not constant,
i.e.  is part of the input of the algorithm. The output of
Algorithm~\ref{alg:bounded-control-set} is a finite set of bounded
expressions  such that
. 
The construction of the set  by
Algorithm~\ref{alg:bounded-control-set} (function
\Call{LetterBoundedControlSet}{}) follows the structure 
of the decomposition of control words given by
Lemma \ref{lem:ginsbook-surgery}. For every -index depth-first derivation with 
control word , its productions can be rearranged into a -index 
depth-first derivation, consisting of
\begin{inparaenum}[\upshape(\itshape i\upshape)]
\item a prefix  producing a word in , then
\item a \emph{pivot} production  followed by two words  and  such that:
\item  and  produce words included in two
bounded expressions  and , respectively, where .
\end{inparaenum}
The algorithm follows this decomposition and builds bounded
expressions , , and the sets
 and  with the goal of capturing
, ,  and , respectively,
for all the control words such as .
Because  produces a word from ,
the bounded expression  is built calling
\Call{ConstantBoundedControlSet}{} (line~\ref{ln:gamma-sharp}). Since
 and  produce words within two sub-expressions of  with as many as  letters, these cases are handled by
two recursive calls to \Call{LetterBoundedControlSet}{}
(lines~\ref{line:rec-y} and \ref{line:rec-z}).

\begin{algorithm}[p]
{\scriptsize
\begin{algorithmic}[0]
  \State {\bf input} A grammar , a nonterminal ,
  \State \hspace*{7mm} a strict -letter-bounded expression  over , such that , and 

  \State {\bf output} a set  of bounded
  expressions over , such that 
	

\end{algorithmic}
\begin{algorithmic}[1]
  \Function{LetterBoundedControlSet}{}
  \State {\bf match}  {\bf with}  
  

		\State 
        \label{ln:minexpr}
	\Comment{}
  
	\If{}
	\State {\bf return} 
  \EndIf

	\State 
        \label{ln:partition}

  \State 
  
  \State 

	\State  
  \label{ln:gamma-sharp}

	\State 

  \For{ {\bf such that} , 
   and
  } 
  \label{line:for-begin}
  
  \If{}
  \label{line:inclusion}

  \State 

  \State 

  \If{}
	\State 
  \label{line:rec-y}
  \Else~  
  \Comment{ in this case}
  
  \EndIf

  \If{}
	\State 
  \label{line:rec-z}
  \Else~  
  \Comment{ in this case}
  \EndIf

	\State 
  \label{line:concatpattg}
  
  \EndIf \EndFor \label{line:for-end}

	\State {\bf return} 
\EndFunction
\end{algorithmic}
\begin{algorithmic}[1]
  \Function{minimizeExpression}{}
  \State 
  \For{}
  \If{}
		\State 
  \EndIf 
  \EndFor
  \State {\bf return} 
  \EndFunction
\end{algorithmic}
\begin{algorithmic}[1]
	\Function{partitionNonterminals}{}
  \State {\bf match}  {\bf with}  
  \State 
  \For{}
	\If{}
  \State 
  \EndIf
  \EndFor
  \State {\bf return} 
  \EndFunction
\end{algorithmic}
\caption{Control Sets for Letter-Bounded Grammars}\label{alg:bounded-control-set}
}
\end{algorithm}

\begin{theorem}\label{thm:letter-bounded-control-set}
Given a grammar ,
and , such that ,
where  is the minimal strict -letter bounded expression
for , for each , there exists a finite set 
of bounded expressions  over  such that 
.
Moreover,  can be constructed in
time  and each
 can be constructed in
time .
\end{theorem}
The next lemma shows that the worst-case exponential blowup in the value 
is unavoidable. 

\begin{lemma}\label{lem:optimality}
For every  there exists a
grammar  and
 such that  and
every bounded expression , such that
 
has length .
\end{lemma}


\section{Related Work} 
The programs we have studied feature unbounded control (the
call stack) and unbounded data (the integer variables). The
decidability and complexity of the reachability problem for such
programs pose challenging research questions. A long standing and still
open one is the decidability of the reachability problem for programs
where variables behave like Petri net counters and control paths are
taken in a context-free language.  A lower bound
exists \cite{Lazic__2012} but decidability remains
open. Atig and Ganty \cite{AG11} showed decidability when the
context-free language is of bounded index.  The complexity of
reachability was settled for branching VASS by Lazic and
Schmitz \cite{Lazi__2014}. When variables
updates/guards are given by gap-order constraints, reachability
is decidable \cite{Abdulla_2013,Revesz93}. It is in
PSPACE when the set of control paths is regular \cite{Bozzelli_2014}.  
More general updates and guard (like
octagons) immediately leads to undecidability. This explains the
restriction to bounded control sets. Demri \textit{et
al.} \cite{Demri_2012} studied the case of updates/guards of the
form . They show that LTL is \textsc{Np}-complete  on 
for bounded regular control sets, hence reachability is in \textsc{Np}.
Godoy and Tiwari \cite{GT09} studied the invariant checking problem for a class of procedural programs where all executions
conform to a bounded expression, among other restrictions.

\bibliographystyle{abbrv}
\begin{thebibliography}{10}

\bibitem{Abdulla_2013}
P.~A. Abdulla, M.~F. Atig, G.~Delzanno, and A.~Podelski.
\newblock Push-down automata with gap-order constraints.
\newblock In {\em FSEN'13}, volume 8161 of {\em LNCS}, page 199–216.
  Springer, 2013.

\bibitem{alur-jacm09}
R.~Alur and P.~Madhusudan.
\newblock Adding nesting structure to words.
\newblock {\em J. ACM}, 56(3):16:1--16:43, 2009.

\bibitem{AG11}
M.~F. Atig and P.~Ganty.
\newblock Approximating petri net reachability along context-free traces.
\newblock In {\em FSTTCS'11}, volume~13 of {\em LIPIcs}, pages 152--163.
  Schloss Dagstuhl, 2011.

\bibitem{BFLP03}
S.~Bardin, A.~Finkel, J.~Leroux, and L.~Petrucci.
\newblock {\sc Fast}: Fast acceleration of symbolic transition systems.
\newblock In {\em CAV'03}, volume 2725 of {\em LNCS}, pages 118--121.
  Springer, 2003.

\bibitem{BEF+ipl}
A.~Bouajjani, J.~Esparza, A.~Finkel, O.~Maler, P.~Rossmanith, B.~Willems, and
  P.~Wolper.
\newblock An efficient automata approach to some problems on context-free
  grammars.
\newblock {\em Information Processing Letters}, 74:221--227, 2000.

\bibitem{bik10}
M.~Bozga, R.~Iosif, and F.~Kone\v{c}n\'{y}.
\newblock Fast acceleration of ultimately periodic relations.
\newblock In {\em CAV'10}, volume 6174 of {\em LNCS}, pages 227--242.
  Springer, 2010.

\bibitem{bik14}
M.~Bozga, R.~Iosif, and F.~Kone\v{c}n\'{y}.
\newblock Safety problems are np-complete for flat integer programs with
  octagonal loops.
\newblock In {\em VMCAI'14}, volume 8318 of {\em LNCS}, 2014.

\bibitem{Bozzelli_2014}
L.~Bozzelli and S.~Pinchinat.
\newblock Verification of gap-order constraint abstractions of counter systems.
\newblock {\em Theoretical Computer Science}, 523:1–36, 2014.

\bibitem{Demri_2012}
S.~Demri, A.~K. Dhar, and A.~Sangnier.
\newblock Taming past ltl and flat counter systems.
\newblock In {\em IJCAR'12}, volume 7364 of {\em LNCS}, page 179–193.
  Springer, 2012.

\bibitem{EsparzaG11}
J.~Esparza and P.~Ganty.
\newblock Complexity of pattern-based verification for multithreaded programs.
\newblock In {\em POPL'11}, pages 499--510. ACM Press, 2011.

\bibitem{gik13}
P.~Ganty, R.~Iosif, and F.~Kone\v{c}n\'{y}.
\newblock Underapproximation of procedure summaries for integer programs.
\newblock In {\em TACAS'13}, volume 7795 of {\em LNCS}, pages 247--261.
  Springer, 2013.

\bibitem{ginsburg}
S.~Ginsburg.
\newblock {\em The Mathematical Theory of Context-Free Languages}.
\newblock McGraw-Hill, Inc., New York, NY, USA, 1966.

\bibitem{GT09}
G.~Godoy and A.~Tiwari.
\newblock Invariant checking for programs with procedure calls.
\newblock In {\em SAS'09}, volume 5673 of {\em LNCS}, pages 326--342.
  Springer, 2009.

\bibitem{HojjatIKKR12}
H.~Hojjat, R.~Iosif, F.~Kone\v{c}n\'{y}, V.~Kuncak, and P.~R\"ummer.
\newblock Accelerating interpolants.
\newblock In {\em ATVA'12}, 2012.

\bibitem{KroeningLW13}
D.~Kroening, M.~Lewis, and G.~Weissenbacher.
\newblock Under-approximating loops in {C} programs for fast counterexample
  detection.
\newblock In {\em CAV'13}, LNCS, pages 381--396. Springer, 2013.

\bibitem{LL10}
M.~Lange and H.~Lei{\ss}.
\newblock To \uppercase{CNF} or not to \uppercase{CNF}? {A}n efficient yet
  presentable version of the \uppercase{CYK} algorithm.
\newblock {\em Informatica Didactica}, 8, 2008-2010.

\bibitem{Lazic__2012}
R.~Lazic.
\newblock The reachability problem for vector addition systems with a stack is
  not elementary.
\newblock RP'12, 2012.

\bibitem{Lazi__2014}
R.~Lazic and S.~Schmitz.
\newblock Non-elementary complexities for branching {VASS}, {MELL}, and
  extensions.
\newblock In {\em CSL-LICS'14}. ACM, 2014.

\bibitem{ToThesis}
A.~W. Lin.
\newblock {\em Model Checking Infinite-State Systems: Generic and Specific
  Approaches}.
\newblock PhD thesis, School of Informatics, University of Edinburgh, August
  2010.

\bibitem{Luker78}
M.~Luker.
\newblock A family of languages having only finite-index grammars.
\newblock {\em Inf. and Control}, 39(1):14--18, 1978.

\bibitem{Luker80}
M.~Luker.
\newblock Control sets on grammars using depth-first derivations.
\newblock {\em Math. Systems Theory}, 13:349--359, 1980.

\bibitem{ls13}
M.~Luttenberger and M.~Schlund.
\newblock An extension of parikh's theorem beyond idempotence.
\newblock {\em CoRR}, abs/1112.2864, 2011.

\bibitem{mine}
A.~Min{\'{e}}.
\newblock The octagon abstract domain.
\newblock {\em Higher-Order and Symbolic Computation}, 19(1):31--100, 2006.

\bibitem{minsky67}
M.~Minsky.
\newblock {\em Computation: Finite and Infinite Machines}.
\newblock Prentice-Hall, 1967.

\bibitem{Revesz93}
P.~Z. Revesz.
\newblock A closed-form evaluation for datalog queries with integer (gap)-order
  constraints.
\newblock {\em Theoretical Computer Science}, 116(1):117 -- 149, 1993.

\bibitem{schrijver}
A.~Schrijver.
\newblock {\em Theory of Linear and Integer Programming}.
\newblock Wiley, 1998.

\end{thebibliography}



\clearpage
\appendix

\section*{Appendix}

The appendix is divided in two parts. Appendix~\ref{sec:easy} contains
easy results about context-free languages and have been included for the sake of being
self-contained. They are variations of classical constructions so as to
take into account index and depth-first
policy. To keep proofs concise, we assume that the grammars are in -normal form (NF for short).
A grammar is in NF if all its productions  satisfy .
Any grammar  can be converted into an equivalent NF grammar , such that ,
in time  \cite{LL10}. Note that NF is a special case of the general form we assumed
where each production  is such that  contains at most  terminals and  nonterminals.
Appendix~\ref{sec:hard} contains the rest of the proofs about
the combinatorial properties of derivations.

\section{From Bounded to Letter-bounded Languages}\label{sec:easy}

It is well-known that the intersection between a context-free and a regular
language is context-free. Below we define the grammar that generates the
intersection between the language of a given grammar  and a regular language given by a bounded expression
 over  where  denotes the
length of each . Let  be the
grammar generating the regular language of , where:
0.3cm]
\prod^{\pat} & = & \set{\textsc{q}^{(s)}_{i}\rightarrow (w_s)_{i}\, \textsc{q}^{(s)}_{i+1}\mid 1 \leq  s \leq  d \, \land \, 1 \leq  i < \ell_s} \; \cup\0.2cm]
& & \set{\textsc{q}_1^{(s)}\rightarrow \varepsilon \mid 1 \leq  s \leq  d}\enspace .
\end{array}\{w\mid \textsc{q}_1^{(i)}\Rightarrow^*
w \text{ for some } 1\leq i\leq d \}=\pat\pat\pat = a_1^* \ldots a_d^*G^{\pat}_1 =
(\Vars^{\pat}_1,\Sigma,\prod^{\pat}_1) \begin{array}{rcl}
\Vars_1^{\pat} & = & \set{\textsc{q}^{(s)} \mid 1\leq s\leq d} \cup \set{\textsc{q}_{\mathit{sink}}} \0.2cm]
& & \set{\textsc{q}^{(s)} \rightarrow b\, \textsc{q}_{\mathit{sink}} \mid b \in \Sigma \setminus \{a_s, a_{s+1}, \ldots, a_d\} }\; \cup\0.2cm]
& & \set{\textsc{q}_{\mathit{sink}} \rightarrow b\, \textsc{q}_{\mathit{sink}} \mid b \in \Sigma }
\end{array}L_{\textsc{q}^{(1)}}(G^{\pat}_1) = \patG^{\pat}_1\pat\overline{G^{\pat}_1}L_{\textsc{q}^{(1)}}(\overline{G^{\pat}_1}) = \Sigma^* \setminus
\pat\mathcal{O}(|G_1^{\pat}|) \textsc{q}^{(s)}\rightarrow \varepsilon,\,
1 \leq s \leq d\textsc{q}_{\mathit{sink}} \rightarrow
\varepsilonX\in\VarsG^{\cap} = \tuple {\Vars^{\cap},\Sigma,\prod^{\cap}}w\in\Sigma^*\prod^{\cap}
      [\textsc{q}^{(r)}_{s} X \textsc{q}^{(u)}_{v}]&\rightarrow w & \text{if } \textsc{q}^{(r)}_{s}\Rightarrow^* w \, \textsc{q}^{(u)}_{v}\enspace ;\label{eq:terminalsonly}
    \prod^{\cap}
      [\textsc{q}^{(r)}_{s} X \textsc{q}^{(u)}_v]&\rightarrow[\textsc{q}^{(r)}_{s} Y \textsc{q}^{(u)}_{v}] \enspace ;\label{eq:1var}
    \prod^{\cap}
      [\textsc{q}^{(r)}_{s} X \textsc{q}^{(u)}_v]&\rightarrow a \, [\textsc{q}^{(x)}_{y} Y \textsc{q}^{(u)}_v] & \text{if } \textsc{q}^{(r)}_{s}\rightarrow a\,\textsc{q}^{(x)}_{y} \in \prod^{\pat}\enspace ;\label{eq:gammavar} 
    \prod^{\cap}
      [\textsc{q}^{(r)}_{s} X \textsc{q}^{(u)}_v]&\rightarrow [\textsc{q}^{(r)}_{s} Y \textsc{q}^{(x)}_{y}] \, a & \text{if } \textsc{q}^{(x)}_{y}\rightarrow a\,\textsc{q}^{(u)}_{v} \in \prod^{\pat}\enspace ;\label{eq:vargamma}
    \prod^{\cap}
			[\textsc{q}^{(r)}_{s} X \textsc{q}^{(u)}_{v}] &\rightarrow [\textsc{q}^{(r)}_{s} Y \textsc{q}^{(x)}_y]\,[\textsc{q}^{(x)}_y Z \textsc{q}^{(u)}_v] \enspace ;\label{eq:2var}
    \prod^{\cap}\patX\in\Vars\textsc{q}_{s}^{(r)},\textsc{q}_{v}^{(u)} \in \Vars^{\pat}w\in\Sigma^*w\in\Sigma^*X \arrow{}{} Y\in\prodw_1\, w_2 = w \Sigmad\mathcal{A}\Vars^{\bowtie} = \Vars^{\cap}h^{-1}( L_{[\textsc{q}^{(s)}_{1} X \textsc{q}^{(x)}_{1}]}(G^{\cap}) ) \cap \patt = 
L_{[\textsc{q}^{(s)}_{1} X \textsc{q}^{(x)}_{1}]}(G^\bowtie)\enspace .\iota\colon \prod^{\cap}\mapsto\prod^{\bowtie} \iota([\textsc{q}^{(r)}_{s} X \textsc{q}^{(u)}_{v}] \rightarrow w) = [\textsc{q}^{(r)}_{s} X \textsc{q}^{(u)}_{v}] \rightarrow z\len{w}=0z=\varepsilon\len{w}=1\textsc{q}^{(r)}_{s}\Rightarrow_{G^\pat} w\, \textsc{q}^{(u)}_{v}z=a_rv=1z=\varepsilon\len{w}=2\textsc{q}^{(r)}_{s}\Rightarrow_{G^\pat} (w)_{1}\, \textsc{q}^{(y)}_{x} \Rightarrow_{G^\pat} (w)_{1} (w)_{2}\,  \textsc{q}^{(u)}_{v} x,yz = z'\cdot z''2 z'=a_rx=1z'=\varepsilonz''=a_yv=1z''=\varepsilon \iota([\textsc{q}^{(r)}_{s} X \textsc{q}^{(u)}_v] \rightarrow b \,
	[\textsc{q}^{(x)}_{y} Y \textsc{q}^{(u)}_v]) = [\textsc{q}^{(r)}_{s} X
	\textsc{q}^{(u)}_v] \rightarrow c \, [\textsc{q}^{(x)}_{y} Y
	\textsc{q}^{(u)}_v] c=a_ry=1c=\varepsilon \iota([\textsc{q}^{(r)}_{s} X \textsc{q}^{(u)}_v] \rightarrow
	[\textsc{q}^{(r)}_{s} Y \textsc{q}^{(x)}_y]\, b) = [\textsc{q}^{(r)}_{s} X
	\textsc{q}^{(u)}_v] \rightarrow [\textsc{q}^{(r)}_{s} Y
	\textsc{q}^{(x)}_y]\, cc=a_xv=1c=\varepsilon\iota(p)=p\gamma\in (\Delta^\cap)^*n\textsc{q}^{(r)}_{s}\textsc{q}^{(u)}_{v}G^{\pat}\textsc{q}_{u}^{(v)}=\textsc{q}_{z}^{(t)}y\neq 1\textsc{q}_{s}^{(r)}=\textsc{q}_{y}^{(x)}t\neq\ell_z\textsc{q}_{u}^{(v)}=\textsc{q}_{z}^{(t)}\textsc{q}_{s}^{(r)}=\textsc{q}_{y}^{(x)}y=1v=1G = \tuple{ \Vars, \Sigma, \prod }\pat = w_1^* \ldots w_d^*\SigmaX \in \Vars1 \leq s \leq x \leq dk
> 0L_{[\textsc{q}^{(s)}_1
    X \textsc{q}^{(x)}_{1}]}^{(k)}(G^{\bowtie}) = h^{-1}(L_{[\textsc{q}^{(s)}_1
    X \textsc{q}^{(x)}_{1}]}^{(k)}(G^\cap)) \cap \patt\Gamma \subseteq \left(\prod^\bowtie\right)^*L_{{[\textsc{q}^{(s)}_1 X \textsc{q}^{(x)}_{1}]}}^{(k)}(G^\bowtie) \subseteq \hat{L}_{[\textsc{q}^{(s)}_1
    X \textsc{q}^{(x)}_{1}]}(\Gamma, G^\bowtie)L_{{[\textsc{q}^{(s)}_1
    X \textsc{q}^{(x)}_{1}]}}^{(k)}(G^\cap) \subseteq \hat{L}_{{[\textsc{q}^{(s)}_1
    X \textsc{q}^{(x)}_{1}]}}(\iota^{-1}(\Gamma), G^\cap)G^{\bowtie} \mathcal{O}\bigl( \len{\pat}^3 \cdot \len{G} \bigr)  [\textsc{q}^{(s)}_1 X \textsc{q}^{(x)}_{1}] \xRightarrow{\gamma} \tilde{w}G^{\bowtie}\gamma\prod^{\bowtie}\tilde{w}\notin \pattp,p'p < p' (\tilde{w})_p = a_j  (\tilde{w})_{p'} = a_i i < j\iotaw\in L_{[\textsc{q}^{(s)}_1 X \textsc{q}^{(x)}_{1}]}(G^{\cap}) [\textsc{q}^{(s)}_1 X \textsc{q}^{(x)}_{1}] \xRightarrow{\iota^{-1}(\gamma)} wG^{\cap}w\in \patL_{[\textsc{q}^{(s)}_1 X \textsc{q}^{(x)}_{1}]}(G^{\cap})\subseteq\pat \textsc{q}^{(s)}_1 \Rightarrow^*_{G^{\pat}} w\, \textsc{q}^{(x)}_{1} \iotaa_rG^{\pat} \textsc{q}^{(r)}_s  \textsc{q}^{(u)}_1  [\textsc{q}^{(r)}_{s} X \textsc{q}^{(x)}_y] \rightarrow a_r \, [\textsc{q}^{(u)}_{1} Y \textsc{q}^{(x)}_y] \textsc{q}^{(u)}_1  \textsc{q}^{(r)}_s  [\textsc{q}^{(x)}_{y} X \textsc{q}^{(u)}_1] \rightarrow [\textsc{q}^{(x)}_{y} Y \textsc{q}^{(r)}_s]\, a_r\tilde{w}a_ja_i\textsc{q}^{(j)}_{\ell_j} \rightarrow (w_j)_{\ell_j}\, \textsc{q}^{(u)}_1u\geq j\textsc{q}^{(i)}_{\ell_i} \rightarrow (w_i)_{\ell_i}\, \textsc{q}^{(u')}_1u' \geq i\iota^{-1}(\gamma)j>iG^{\pat}\textsc{q}^{(j)}_{p_j}\textsc{q}^{(i)}_{p_i} p_i, p_j\textsc{q}^{(s)}_1 X \textsc{q}^{(x)}_{1}]
  \xRightarrow[(k)]{\gamma} w_1^{i_1} \ldots w_d^{i_d} ~\mbox{in }
	\text{ if and only if } [\textsc{q}^{(s)}_1 X \textsc{q}^{(x)}_{1}]
  \xRightarrow[(k)]{\iota(\gamma)} a_1^{i_1} \ldots a_d^{i_d} ~\mbox{in
  }\enspace .\tilde{w} = a_1^{i_1}\ldots a_d^{i_d}i_1,\ldots,i_d\in\natsw \in \hat{L}_{[\textsc{q}^{(s)}_1
X \textsc{q}^{(x)}_{1}]}(\iota^{-1}(\Gamma), G^\cap)dL_{\textsc{q}^{(1)}}(\overline{G^{\pat}_1})
  = \Sigma^* \setminus \pattL_X(G) \cap
  L_{\textsc{q}^{(1)}}(\overline{G^{\pat}_1}) \stackrel{?}{=} \emptyset\len{w_1}SI \subseteq \natsS^{I} = \{ s^{\tuple{i}} \mid s\in S,\, i\in I\}S^{I}S^{\tuple{i}}Iwnn\boldsymbol{\alpha}\in\nat^nw^{\boldsymbol{\alpha}}{(w)_1}^{\tuple{(\boldsymbol{\alpha})_1}}\ldots {(w)_n}^{\tuple{(\boldsymbol{\alpha})_n}}i\boldsymbol{\alpha}iww^{ \rank{c} } =
{(w)_1}^{\tuple{c}} \ldots {(w)_{\len{w}}}^{\tuple{c}}u
\Arrow{(Z,w)/j} v\boldsymbol{\alpha}\in\nat^{\len{u}}u^{\boldsymbol{\alpha}} \Arrow{(Z,w)/j} v^{\boldsymbol{\beta}}u)_j = Zv^{\boldsymbol{\beta}} = (u^{\boldsymbol{\alpha}})_1 \cdots
(u^{\boldsymbol{\alpha}})_{j-1} \, w^{\rank{m+1}} \,
(u^{\boldsymbol{\alpha}})_{j+1}\cdots
(u^{\boldsymbol{\alpha}})_{\len{u}} wm+1m = \max\left(\set{
(\boldsymbol{\alpha})_i \mid \exists i\colon 1 \leq i \leq \len{u},
i\neq j, (u)_i \in \Vars} \cup \set{-1} \right)u^{\boldsymbol{\alpha}}ju^{\boldsymbol{\alpha}} \xArrow{}{\textbf{df}}
v^{\boldsymbol{\beta}}j\mathbf{p_2}w_0 \Arrow{(\gamma)_1} w_1
\ldots w_{n-1} \Arrow{(\gamma)_{n}} w_nw_0 \xArrow{\gamma}{\mathbf{df}} w_n\boldsymbol{\alpha}_1 \in \nats^{\len{w_1}}, \ldots,
\boldsymbol{\alpha}_n \in \nats^{\len{w_n}}w_0^{\rank{0}} \xArrow{(\gamma)_1}{\mathbf{df}}
w_1^{\boldsymbol{\alpha}_1} \ldots w_{n-1}^{\boldsymbol{\alpha}_{n-1}} 
\xArrow{(\gamma)_{n}}{\mathbf{df}} w_{n}^{\boldsymbol{\alpha}_{n}}\bdwords^{(k)}
= \{w^{\boldsymbol{\alpha}} \mid \exists  u^{\boldsymbol{\beta}}\colon u^{\boldsymbol{\beta}} = \proj{(w^{\boldsymbol{\alpha}})}{\Vars^{\nats}}, \len{u^{\boldsymbol{\beta}}} \leq  k, \boldsymbol{\beta} \text{ is contiguous}, \max_{i} (\boldsymbol{\beta})_i \leq k-1\} k\bdwords^{(k)}\xRightarrow[\df{k}]{}w^{\boldsymbol{\alpha}}\in\bdwords^{(k)}\age{w^{\boldsymbol{\alpha}}} (\proj{w^{\boldsymbol{\alpha}}}{\Vars^{\tuple{0}}})\;
(\proj{w^{\boldsymbol{\alpha}}}{\Vars^{\tuple{1}}})
\ldots (\proj{w^{\boldsymbol{\alpha}}}{\Vars^{\tuple{k}}})\age{w^{\boldsymbol{\alpha}}}w\age{a^{\tuple{1}}Y^{\tuple{1}}Z^{\tuple{0}}} = Z^{\tuple{0}} Y^{\tuple{1}}QA^{\df{k}} = (Q,\prod,\rightarrow)Q = \{ w^{\boldsymbol{\alpha}} \mid w \in \Vars^{*}, \len{w}\leq k, \boldsymbol{\alpha} \text{ is contiguous},
(\boldsymbol{\alpha})_1 \leq \cdots \leq (\boldsymbol{\alpha})_{\len{w}} \} \age{\bdwords^{(k)}} = Q\rightarrowq,q' \in Q (X,w)\in \Deltaq \xrightarrow{(X,w)} q' q = u\, X^{\tuple{i}}\, vu,viq q'= u\, v\, (\proj{w}{\Vars})^{\rank{i'}} \len{u\, v\, (\proj{w}{\Vars})^{\rank{i'}}}\leq k i' = 
\begin{cases}
  0 & \text{if } u\, v = \varepsilon\\
	i & \text{else if } \proj{(u\, v)}{\Vars^{\tuple{i}}} = \varepsilon\\
	i+1 & \text{else}
\end{cases}q\in Qq\in \age{\bdwords^{(k)}}q \xrightarrow{(X,w)} q'w^{\boldsymbol{\eta}} \in \bdwords^{(k)}q \xRightarrow[\df{k}]{(X,w)}  w^{\boldsymbol{\eta}} \age{ w^{\boldsymbol{\eta}} } = q'u^{\boldsymbol{\alpha}} \xrightarrow{p} v^{\boldsymbol{\beta}}\exists w^{\boldsymbol{\eta}} \in \bdwords^{(k)}  \ldotp
u^{\boldsymbol{\alpha}} \xRightarrow[\df{k}]{p}
w^{\boldsymbol{\eta}} \land v^{\boldsymbol{\beta}}
= \age{w^{\boldsymbol{\eta}}}u^{\boldsymbol{\alpha}} \xRightarrow[\df{k}]{\gamma}
  w^{\boldsymbol{\beta}}u^{\boldsymbol{\alpha}} \in \bdwords^{(k)}k\len{\gamma}\geq 0\age{u^{\boldsymbol{\alpha}}}\xrightarrow{\gamma} \age{w^{\boldsymbol{\beta}}}A^{\df{k}}\len{\gamma}=0u^{\boldsymbol{\alpha}} = w^{\boldsymbol{\beta}}\age{u^{\boldsymbol{\alpha}}}=\age{w^{\boldsymbol{\beta}}}u^{\boldsymbol{\alpha}}\in\bdwords^{(k)}u^{\boldsymbol{\alpha}},w^{\boldsymbol{\beta}}\in\bdwords^{(k)}\age{u^{\boldsymbol{\alpha}}},\age{w^{\boldsymbol{\beta}}}\in\age{\bdwords^{(k)}}\len{\gamma}>0
  v^{\boldsymbol{\eta}} \xRightarrow[\df{k}]{p}
  w^{\boldsymbol{\beta}}  p \in \prod\gamma=\sigma \cdot p\sigma\in\prod^*A^{\df{k}}\age{u^{\boldsymbol{\alpha}}} \xrightarrow{\sigma} \age{v^{\boldsymbol{\eta}}}\age{v^{\boldsymbol{\eta}}}, \age{w^{\boldsymbol{\beta}}} \in \age{\bdwords^{(k)}} v^{\boldsymbol{\eta}} \xRightarrow[\df{k}]{p}
  w^{\boldsymbol{\beta}} \age{v^{\boldsymbol{\eta}}} \xrightarrow{p} \age{w^{\boldsymbol{\beta}}} \rightarrow \age{u^{\boldsymbol{\alpha}}} \xrightarrow{\gamma} \age{w^{\boldsymbol{\beta}}}U,W\in\age{\bdwords^{(k)}}\age{u^{\boldsymbol{\alpha}}} =
  U\age{w^{\boldsymbol{\beta}}} = Wu^{\boldsymbol{\alpha}} \xRightarrow[\df{k}]{\gamma}
  w^{\boldsymbol{\alpha}}U=WU\in\age{\bdwords^{(k)}}u^{\boldsymbol{\alpha}}\in \bdwords^{(k)}\age{u^{\boldsymbol{\alpha}}}=U=W\gamma = \sigma \cdot pp \in \prod\sigma \in \prod^*U=\age{u^{\boldsymbol{\alpha}}} \xrightarrow{\sigma} \age{v^{\boldsymbol{\eta}}} \xrightarrow{p}
  WA^{\df{k}}u^{\boldsymbol{\alpha}} \xRightarrow[\df{k}]{\sigma}
  v^{\boldsymbol{\eta}}k\age{v^{\boldsymbol{\eta}}} \xrightarrow{p} wv^{\boldsymbol{\eta}} \xRightarrow[\df{k}]{p}
  w^{\boldsymbol{\beta}}w^{\boldsymbol{\beta}}\in\bdwords^{(k)}\age{w^{\boldsymbol{\beta}}} = WA^{\df{k}}[0,k-1]G2A^{\df{k}}2Qki\in[0,k-1]\card{\Vars}^2i\patt=a_{1}^* \ldots
a_{s}^*ssu\, v
= \proj{\gamma}{a_{1}} \ldots \proj{\gamma}{a_{s}}u\, v = a_1^{(\boldsymbol{v})_1} \ldots a_s^{(\boldsymbol{v})_s}
\boldsymbol{v}\in\nats^s (\boldsymbol{v})_{\ell}
= \len{\proj{\gamma}{a_\ell}}\ell=1,\ldots,s\gamma\in\prod^{*}\projpatt{\gamma}
= \proj{\gamma}{a_1} \ldots \proj{\gamma}{a_s}A^{\df{k}}= \tuple{ Q, \prod, \rightarrow}NGQN \leq \len{G}^{2k}\varsigma_1 \in \Pi(q,q_{1})\varsigma_{\ell+1} \in \Pi(q_{\ell},q')\varsigma_{j} \in \Pi(q_{{j-1}},q_{{j}})1< j \leq \ell \len{\proj{\gamma}{a_{\ell}}} = \len{\proj{\gamma'}{a_{\ell}}} \ell=1,\ldots,s \projpatt{\gamma} = \projpatt{\gamma'} u\, v = u'\, v'L_{X,Y}(G) \subseteq \patt\patts\pi \in \cycles{}{q}\label{eq:binom}
	\card{ \{ \projpatt{\omega(\pi)} \mid \pi \in \cycles{}{q}\} } = \binom{s+2N}{s} = \mathcal{O}(N^s)\enspace .
qC_q \subseteq \cycles{}{q}\card{C_q}
= \mathcal{O}(N^{s})\pi\in\cycles{}{q}\pi' \in C_q\projpatt{\omega(\pi)} = \projpatt{\omega(\pi')}\Pi(X^{\tuple{0}},q) \neq \emptyset\Pi(q, Y^{\tuple{0}}) \neq \emptyset \set{C_q}_{q \in
Q}\mathit{concat}(\Gamma) = \gamma_1^* \cdots \gamma_n^*Q = \set{q_1, \ldots, q_N}A^{\df{k}} \set{B_i}_{i\geq 0}
	B_0 & =  \mathit{concat}(\{ \omega(\pi) \mid \pi \in C_{q_1}\}) \cdots \mathit{concat}(\{ \omega(\pi) \mid \pi \in C_{q_N}\}) \\
B_1 & = \mathit{concat}(\prod)^{N-1} \cdot B_0 \cdot \mathit{concat}(\prod)^{N-1}\\
B_i & =  \mathit{concat}(\prod)^{N-1} \cdot B_0 \cdot B_{i-1}, \text{ for all } i \geq 2
\shortintertext{Finally, let:}
\pattg & = B_N\enspace.
X\in \VarsY\in\Vars\cup\set{\varepsilon}k>0
X \xRightarrow[\df{k}]{\gamma} u \, Y \, v\gamma' \in \pattgX \xRightarrow[\df{k}]{\gamma'} u'\, Y\,
v'u\, v = u'\, v'\pi \in \Pi( X^{\tuple{0}}, Y^{\tuple{0}} ) \omega(\pi)X \xRightarrow[\df{k}]{\omega(\pi)} u\, Y\, v L_{X,Y}^{(k)}(G)\subseteq \patt\patts\rho \in \Pi( X^{\tuple{0}}, Y^{\tuple{0}} ) \omega(\rho) \in \pattg \projpatt{\omega(\pi)} = \projpatt{\omega(\rho)}\rho \in \Pi( X^{\tuple{0}}, Y^{\tuple{0}} )\varsigma_1     \in \Pi(X^{\tuple{0}},q_{i_1})\varsigma_{\ell+1} \in \Pi(q_{i_\ell}, Y^{\tuple{0}})\varsigma_{j}   \in \Pi(q_{i_{j-1}},q_{i_{j}})1< j \leq \ell\pattg\set{C_q}_{q\in Q}\pi\in\cycles{}{q}\pi' \in C_q\projpatt{\omega(\pi)}= \projpatt{\omega(\pi')}\Pi(X^{\tuple{0}},q) \neq \emptyset\Pi(q, Y^{\tuple{0}}) \neq \emptyset\mathit{Val} = \{a_1^{\ell_1} \ldots
a_s^{\ell_s} \in \patt \mid \sum_{j=1}^s \ell_{j} \leq 2N\}\card{\mathit{Val}} = \mathcal{O}(N^{s})A^{\df{k}}\tuple{q',a_1^{i_1}\ldots a_s^{i_s}} \arrow{(Z,z)}{}
	\tuple{q'', a_1^{j_1}\ldots a_s^{j_s}}q' \arrow{(Z,z)}{A^{\df{k}}} q''a^{j_{\ell}}_{\ell} = a^{i_\ell}_{\ell}\cdot \proj{z}{a_{\ell}}\ell\card{V}
\leq N^{2k} \cdot \binom{s+2N}{s} = \len{G}^{\mathcal{O}(k)}\pi \in \Pi_{\mathcal{H}}(\tuple{q,\varepsilon}, \tuple{q,a_1^{i_1}\ldots a_s^{i_s}})i_1,\ldots,i_s \in\nats \projpatt{\omega(\pi)} = a_1^{i_1}\ldots a_s^{i_s}q\in Q\mathcal{P}_{q}\mathcal{H}a_1^{i_1}\ldots a_s^{i_s}\in\mathit{Val}\tuple{q,\varepsilon}\tuple{q,a_1^{i_1}\ldots a_s^{i_s}}\mathit{Val}\card{\mathcal{P}_q} = \card{\mathit{Val}}
 = \mathcal{O}(N^s)\rho \in \cycles{}{q}\rhoA^{\df{k}}\pi\in\mathcal{P}_q 
 \projpatt{\omega(\rho)} = \projpatt{\omega(\pi)} = a_1^{i_1} \ldots a_s^{i_s}  \tuple{q,\varepsilon}  \tuple{q, a_1^{i_1} \ldots a_s^{i_s}} \pi\pattg\pattgsGXL_{Y}(G)\neq \emptysetY \in \VarsX\neq
YG (Y,v) Y\in\Varsiv\VarseZ \in \VarsevZ
  \in \Varsea_1L_{Z}(G)a_dL_Z(G)L_{Y}(G)a_1L_{Y}(G)a_dY\in\VarsiG \set{u \mid v
    \xRightarrow{}^* u} \neq \emptyset  \{u \mid Y \xRightarrow{(Y,v)} v \xRightarrow{}^* u\} a_1a_dZvQ(u,v)
\set{u'\in (\Vars\cup\mathcal{A})^* \mid u\Rightarrow^* u' } &\subseteq ( \set{a_1} \cup \Varsi)^*\\
\shortintertext{\textbf{and}}
\set{v'\in (\Vars\cup\mathcal{A})^* \mid v\Rightarrow^* v' } &\subseteq ( \set{a_d} \cup \Varsi)^*\enspace.
 Q(u,v)X_i \Rightarrow^* u\, X_j\, vX_i,X_j\in\Varseu'u \xRightarrow{}^* u'u' \notin ( \set{a_1}
\cup \Varsi)^*vu'a_\ell\ell>1u'Z \in \VarseG\set{u' \mid u \xRightarrow{}^* u'}
\neq \emptysetu' \Rightarrow^* u_1\, a_\ell\, u_2 \in \mathcal{A}^* \ell>1X_j\in\VarseX_j\, v
\Rightarrow^* a_1\, u_3 \in \mathcal{A}^*
X_i\Rightarrow^* u_1\, a_\ell\, u_2\, a_1\, u_3 L_X(G) \nsubseteq \pattGX_j
  \Rightarrow^* xX_j\in\Varsexu_1\, X_d\, u_2\, X_e\, u_3X_d,X_e\in \Varseu = u_1  v = u_2\, X_e\,
  u_3 u = u_1\, X_d\, u_2 v = u_3 (\ref{item:easyfact2})  Q(u,v)v\notin (\set{a_d}\cup \mathcal{A} \cup\Varsi)^* X \xRightarrow{\gamma}_G u\, X_i\,
  vGX_i\in\Varse\gamma\in\prod^* X \xRightarrow{\gamma}_{G^\sharp} u\,
  X_i\, vG^\sharpn=\len{\gamma} X = w_0
	\xRightarrow{(\gamma)_{1}}_G w_1 \cdots w_{n-1} \xRightarrow{(\gamma)_{n}}_G
  w_n = u\, X_i\, vn=0\gamma=\varepsilonX=X_i\in\Varseu=v=\varepsilonG^\sharp
	(\ref{item:easyfact1})  (w_{n-1})_{\ell} \in \Varse \ell X \xRightarrow{(\gamma)_{1}\ldots
    (\gamma)_{n-1}}_G w_{n-1} X
  \xRightarrow{(\gamma)_{1}\ldots (\gamma)_{n-1}}_{G^\sharp}
	w_{n-1}w_{n-1}\xRightarrow{(\gamma)_n} w_{n}w_{n-1}\xRightarrow{ (\gamma)_n / p} w_{n}p\neq \ell (\gamma)_n=(Y,t) Y\in \VarseX \Rightarrow^*_G w_{n-1}\ref{item:easyfact3}) (w_{n-1})_{\ell}  X \Varse\gamma)_n\in\prod^\sharp w_{n-1} \xRightarrow{(\gamma)_n}_{G^\sharp} w_n X \xRightarrow{\gamma}_{G^\sharp} u\, X_i\, vL_1,L_2 \subseteq \pattL_1\cdot L_2 \subseteq a_{\ell}^* \ldots a_r^*1
  \leq \ell \leq r \leq d\ell \leq q \leq rL_1 \subseteq a_{\ell}^* \ldots a_q^*L_2
  \subseteq a_{q}^* \ldots a_{r}^*qw_1 =
  a_{\ell}^{i_{\ell}}\ldots a_{r}^{i_r}\in L_1 w_2 =
  a_{\ell}^{j_{\ell}}\ldots a_{r}^{j_r} \in L_2p_1,p_2\ell\leq p_2 < p_1 \leq r
  i_{p_1}\neq 0  j_{p_2}\neq 0 a_iw_1 \cdot w_2 \notin a_{\ell}^* \ldots
  a_r^*\len{\gamma} = n\triangleleftY^{\tuple{a}}Z^{\tuple{b}}u^{\boldsymbol{\alpha}} \xRightarrow{(Y,t)/j} v^{\boldsymbol{\beta}} (u^{\boldsymbol{\alpha}})_{j} = Y^{\tuple{a}}  (v^{\boldsymbol{\beta}})_{\ell} = Z^{\tuple{b}} j\leq \ell \leq j-1+\len{t}\gammaX \in \Varsea,b\in \mathcal{A} \cup \set{\varepsilon}y,z \in \Varsi \cup 
  \set{\varepsilon}\gammay\in\Varsez\in\Varse (\gamma)_{\ell_p} \gamma)_{\ell_j} = (X_{i_j},a\, y_{m_j}\, b\, X_{i_{j+1}}) \in \prod (\gamma)_{\ell_j} = (X_{i_j}, a\, X_{i_{j+1}}\, b\, z_{m_j}) \in \prod a,b\in \mathcal{A}\cup\set{\varepsilon}X_{i_{\ell}}X_{i_{j+1}}y_{m_j} y_{m_j}  X_{i_{j+1}} bX_{i_j}
  (\ref{item:easyfact4})X
  \xRightarrow{\gamma^\sharp}_G u \, X_{i_p} \, vX, X_{i_p}\in \VarseX
  \xRightarrow{\gamma^\sharp}_{G^\sharp} u \, X_{i_p} \, vG^\sharpG\gamma^\sharpy_{m_j} \xRightarrow{\overline{\gamma_j}} w_{m_j}X_{i_{j+1}} y_{m_j} \xRightarrow{\overline{\gamma_j}} X_{i_{j+1}}
  w_{m_j}k+1X_{i_j}X \xRightarrow[(k+1)]{\gamma^\sharp} u \, X_{i_p} \, v X \xRightarrow[\df{k+1}]{\gamma^\sharp} u\,
  X_{i_p}\, v\gammanG\max(k_z,k_y)\leq k\min(k_z,k_y)\leq k-1 k_y \leq k-1\gamma^\sharp\cdot (\gamma)_{\ell_p}\cdots (\gamma)_n\gamma\gammaw = a_1^{i_1}\ldots
    a_d^{i_d}L_X(G)\subseteq \patt\pattdk\ref{item1:ginsbook-surgery})\ref{item2:ginsbook-surgery})\prod^\sharp \subseteq \prod X
    \xRightarrow{}^*_{G^\sharp} u\, X_{i_p}\, v  X
    \xRightarrow{}^*_{G} u\, X_{i_p}\, v  Q(u,v)  (\ref{item:easyfact2})  X, X_{i_p} \in \Varse  Q(u,v) \begin{array}{rcl}
    \set{u' \in (\Vars \cup \mathcal{A})^* \mid u\xRightarrow{}^* u' } & \subseteq & ( \set{a_1}
    \cup \Varsi)^* ~\mbox{and} \\ 
    \set{v' \in (\Vars\cup\mathcal{A})^* \mid v \xRightarrow{}^* v' } & \subseteq & 
    ( \set{a_d} \cup \Varsi)^*
    \end{array}GL_{X}(G)\subseteq\pattL_y(G_{i,a\, y\, b\, z})\cap (a_1\cdot\mathcal{A}^*) = \emptyset  L_z(G_{i,a\, y\, b\, z}) \cap (a_1\cdot\mathcal{A}^*) = \emptyset  L_y(G_{i,a\, y\, b\, z})\cdot L_z(G_{i,a\, y\, b\, z}) \subseteq a_2^* \ldots
			a_d^*\ell=2r=dL_y(G_{i,a\, y\, b\, z})\cap (\mathcal{A}^*\cdot a_d) = \emptyset  L_z(G_{i,a\, y\, b\, z}) \cap (\mathcal{A}^*\cdot a_d) = \emptyset
      L_y(G_{i,a\, y\, b\, z}) \cdot L_z(G_{i,a\, y\, b\, z}) \subseteq a_1^*
			\ldots a_{d-1}^*\ell=1r=d-1L_y(G_{i,a\, y\, b\, z})\cap (\mathcal{A}^*\cdot a_d) = \emptyset  L_z(G_{i,a\, y\, b\, z}) \cap (a_1\cdot \mathcal{A}^*) = \emptyset
       L_y(G_{i,a\, y\, b\, z}) \subseteq a_1^* \ldots
      a_{d-1}^*  L_z(G_{i,a\, y\, b\, z}) \subseteq a_2^* \ldots
			a_{d}^*\ell=1r=dq1\leq q\leq dL_y(G_{i,a\, y\, b\, z}) \subseteq a_1^* \ldots a_q^*L_z(G_{i,a\, y\, b\, z})
      \subseteq a_q^* \ldots a_d^* 1 < q < d q=1q=2L_z(G_{i,a\, y\, b\, z}) \subseteq a_2^*
      \ldots a_d^*q=dL_y(G_{i,a\, y\, b\, z}) \subseteq a_1^* \ldots a_{d-1}^* L_y(G_{i,a\, y\, b\, z})\cap (a_1\cdot \mathcal{A}^*) = \emptyset  L_z(G_{i,a\, y\, b\, z}) \cap (\mathcal{A}^*\cdot a_d) = \emptyset
      L_y(G_{i,a\, y\, b\, z})a_dL_{z}(G_{i,a\, y\, b\, z})a_1
      L_y(G_{i,a\, y\, b\, z})\cdot L_z(G_{i,a\, y\, b\, z}) \nsubseteq a_1^* \ldots
      a_d^*L_y(G_{i,a\, y\, b\, z}) \cap (\mathcal{A}^*\cdot a_d) \neq \emptysetL_z(G_{i,a\, y\, b\, z}) \subseteq a_d^*
        L_y(G_{i,a\, y\, b\, z}) \subseteq a_2^* \ldots a_{d}^* L_y(G_{i,a\, y\, b\, z}) \cap (a_1\cdot\mathcal{A}^*)=\emptysetL_z(G_{i,a\, y\, b\, z}) \cap (a_1\cdot \mathcal{A}^*) \neq
        \emptysetL_y(G_{i,a\, y\, b\, z}) \subseteq a_1^* L_z(G_{i,a\, y\, b\, z}) \subseteq a_1^* \ldots a_{d-1}^* L_z(G_{i,a\, y\, b\, z}) \cap (\mathcal{A}^*\cdot a_d) =
        \emptysetL_y(G_{i,a\, y\, b\, z}) \cap (\mathcal{A}^* \cdot a_d ) =
        \emptyset L_z(G_{i,a\, y\, b\, z}) \cap (a_1\cdot \mathcal{A}^*)
        = \emptyset L_y(G_{i,a\, y\, b\, z})\cdot L_z(G_{i,a\, y\, b\, z})
        \subseteq a_2^* \ldots a_{d-1}^*\ell=2r=d-11 < q < dL_y(G_{i,a\, y\, b\, z}) \subseteq a_2^*
        \ldots a_q^* L_z(G_{i,a\, y\, b\, z}) \subseteq a_q^* \ldots
        a_{d-1}^*\prod_{\mathit{pivot}} =
\set{(X_i,a\, y\, b\, z)\in\prod \mid X_i \in \Varse ~\mbox{and}~a,b \in \mathcal{A}\cup\set{\varepsilon},\ y,z \in \Varsi \cup \set{\varepsilon}}\enspace .\Delta_{i,aybz}\varepsilon\mathcal{S}^{\varepsilon}_{i \ldots j} = \set{\varepsilon}
\mbox{IH} & = \{(\ell,m,r) \mid 1 \leq \ell \leq m \leq r \leq d,~m - \ell < d - 1 \land r - m < d - 1\} \\
\mathcal{S}_\patt & = \{ \Gamma_{1,d}^{X,X_i} \cdot (X_i,a\, y\, b\, z)^* \cdot \Gamma' \cdot \Gamma'' 
\mid (X_i,a\, y\, b\, z) \in \prod_{\mathit{pivot}} \land \\
&\quad\quad L_{X,X_i}(G) \subseteq a_1^* a_d^* \land \Gamma'\in\mathcal{S}^y_{\ell \ldots m} \land \Gamma''\in\mathcal{S}^z_{m \ldots r} \land (\ell,m,r) \in IH\}
\gamma^\sharp \cdot (X_i,a\, y\, b\, z) \cdot \gamma_y \cdot \gamma_z\gammaX \xArrow{\gamma^\sharp}{\df{k+1}} u\, X_i\, v{G^\sharp}u, v\in \mathcal{A}^*y \xArrow{\gamma_{y}}{\df{k_y}} u_yz
		\xArrow{\gamma_{z}}{\df{k_z}} u_zG_{i,aybz}u_y\, u_z \in \mathcal{A}^* \max(k_y,k_z)\leq k\min(k_y,k_z)\leq k-1X \xArrow{\gamma^\sharp \cdot (X_i,aybz) \cdot \gamma_y \cdot \gamma_z}{\df{k+1}} w{G^\sharp}y \xArrow{\gamma_y}{\df{k-1}} u_y{G_{i,aybz}}X \xArrow{\gamma^\sharp \cdot (X_i,aybz) \cdot \gamma_z \cdot \gamma_y}{\df{k+1}} w{G^\sharp}z \xArrow{\gamma_z}{\df{k-1}} u_z{G_{i,aybz}}L_{X,X_i}(G^\sharp) \subseteq a_1^*a_d^*L_{y}(G_{i,aybz}) \subseteq a_{\ell}^* \ldots a_{m}^*y \in \VarsiL_{z}(G_{i,aybz}) \subseteq a_{m}^* \ldots a_{r}^*z \in \Varsi1\leq \ell \leq m \leq r \leq d m-\ell < d - 1 r-m < d - 1k_y \leq k-1\Gamma' \in \mathcal{S}^y_{\ell \ldots m}\Gamma'' \in \mathcal{S}^z_{m \ldots r}\gamma'\in\Gamma'\gamma''\in\Gamma''X \xArrow{\gamma^\sharp}{\df{k+1}} u \, X_i \, vk+1)G^\sharp
X \xArrow{\gamma^\sharp}{\df{k+1}} u \, X_i \, v 
\xArrow{(X_i,aybz)}{} u\, a\, y\, b\, z\, v
\xArrow{\gamma'}{\df{k_y+2}} u\, a\, u_y\, b\, z\, v
\xArrow{\gamma''}{\df{k_z+1}} u\, a\, u_y\, b\, u_z\, v = w\enspace .
 u\, a\, y\, b\, z\, v \xArrow{\gamma'}{\df{k_y+2}}
u\, a\, u_y\, b\, z\, va,b,u,v \in \mathcal{A}^*z \in \Vars
y \xArrow{\gamma'}{\df{k_y+1}} u_yk_y\leq k-1k_z\leq kk_y+2 \leq k+1k_z+1\leq
k+1 (\gamma^\sharp\,
(X_i,aybz)\, \gamma'\, \gamma'')k+1w\in \hat{L}_{X}(\bigcup\mathcal{S}_\patt\cap \Gamma_X^{\df{k+1}}, G)L^{(k)}_X(G) \subseteq \hat{L}_{X}(\bigcup\mathcal{S}_\patt\cap \Gamma_X^{\df{k+1}}, G)d T(d) = \len{G}^{\mathcal{O}(k)} + \len{G}( \mathcal{O}(\len{G}) + 2\, T(d{-}1))T(0)=\mathcal{O}(\len{G}) + \len{G}^{\mathcal{O}(k)} \Gamma\in\mathcal{S}_\patt\sigma\in\prod^*G\sigma\in\prod^*\Call{LetterBoundedControlSet}{G,X,a_s^* \ldots
a_t^*,k,\sigma}\sigma\sigmat-sd\Call{LetterBoundedControlSet}{}\mathcal{O}(\len{G})
+ \len{G}^{\mathcal{O}(k)}L_X(G) \subseteq \patt\patt\len{\patt} \leq \len{G}\Gamma\in\mathcal{S}_\pattd \cdot (\mathcal{O}(\len{G})
+ \len{G}^{\mathcal{O}(k)}) \leq \len{G}\cdot (\mathcal{O}(\len{G})
+ \len{G}^{\mathcal{O}(k)}) = \len{G}^{\mathcal{O}(k)}\enspace.k > 0G = \tuple{ \{ X_i \mid 0\leq i\leq k \}, \{ a\}, \{ X_i \rightarrow
X_{i-1}\, X_{i-1} \mid 1\leq i \leq k \}\cup \{ X_0 \rightarrow a \}
}\enspace .L_{X_k}(G) = \{ a^{2^k} \} \subseteq a^*\len{G} = \mathcal{O}(k)Gk+1i \in \set{1, \ldots, n}p_iX_i \rightarrow X_{i-1}\, X_{i-1}G_np_0X_0 \rightarrow a\gammaa^{2^k}X_k\Gamma = w_1^* \ldots w_d^*\gamma =
w_1^{i_1} \ldots w_d^{i_d}i_1, \ldots, i_d \geq
0j=1,\ldots,di_j \leq 2p_i\ell_1<\ell_2<\ell_3p_i (\gamma)_{\ell_1}=(\gamma)_{\ell_2}=(\gamma)_{\ell_3}=p_i\ell\ell_1\ell_3 (\gamma)_{\ell} = p_{i+1} X_{i+1}X_{i}w_j\Gammagw_ji_jw_jp_gi_j2L_{X^k}(G)2^k\len{\gamma} \geq 2^k\len{\Gamma}2^{k-1}\len{\Gamma}\leq (2^{k-1}-1)\gamma\Gamma\Gamma2 \cdot (2^{k-1}-1) = 2^{k}-22^k=\len{\gamma}\left\{\begin{array}{lcl}
  a_{11} \cdot k_1 + \ldots + a_{m1} \cdot k_m + c_1 & \leq & 0 \\
  & \cdots & \\
  a_{1n} \cdot k_1 + \ldots + a_{mn} \cdot k_m + c_n & \leq & 0 
  \end{array}\right.w\in L_{X_0}(G)\begin{array}{lcll}
  \rho_{\tau_0} & \equiv & \vec{x}'=0 \\
  \rho_{\tau_i} & \equiv & \vec{x}'=\vec{x} & \quad \mbox{for all } \\
  \rho_{\lambda_i} & \equiv & \vec{x}'=\vec{x}+\vec{a}_i &\quad \mbox{for all } \\ 
  \rho_{\tau_m} & \equiv & \vec{x}'=\vec{x}+\vec{c} \\ 
  \rho_{\tau_{m+1}} & \equiv & \vec{x} \leq \vec{0} 
  \end{array}\foreach(\mathcal{P}_{\mathrm{PILP}}, \patt_{\mathrm{PILP}})\foreach(\mathcal{P}, \pat)\mathcal{P} = \tuple{G,I,\sem{.}}G=\tuple{\Vars,\Sigma,\prod}\pat = w_1^* \ldots w_d^*G^\cap = \tuple{\Vars^\cap,\Sigma,\prod^\cap}\bigcup_{1\leq s\leq x\leq d} L_{[\textsc{q}^{(s)}_1
  I \textsc{q}^{(x)}_{1}]}(G^{\cap}) = L_I(G) \cap \pat\enspace.\mathcal{P}_{s,x}=\tuple{G^\cap, [\textsc{q}^{(s)}_1
  I \textsc{q}^{(x)}_{1}], \sem{.}}1 \leq
  s \leq x \leq dGG^\capGG^\cap\bigcup_{1\leq s\leq x\leq
  d} \sem{\mathcal{P}_{s,x}} = \sem{\mathcal{P}}_\pat\enspace.\sem{P}_\pat \neq \emptyset\sem{\mathcal{P}_{s,x}} \neq \emptyset1 \leq
  s \leq x \leq d\foreach(\mathcal{P},\pat)\mathcal{O}(\len{\pat}^2)\mathcal{O}(\len{\pat}^3 \cdot \len{G})1 \leq s \leq x \leq d\foreach(\mathcal{P}_{s,x},\pat)X =
  [\textsc{q}^{(s)}_1 I \textsc{q}^{(x)}_{1}]\mathcal{A} = \set{a_1,\ldots,a_d}\Sigma\patt=a_1^* \ldots a_d^*\pat=h(\patt)h: \mathcal{A} \rightarrow \Sigma^*h(a_i) = w_ii=1,\ldots,dG^\bowtie=\tuple{\Vars^\cap, \mathcal{A}, \prod^\bowtie}k >
  0L_X^{(k)}(G^{\bowtie}) =
        h^{-1}(L_X^{(k)}(G^\cap)) \cap \patt\Gamma \subseteq \left(\prod^\bowtie\right)^*L_X^{(k)}(G^\bowtie) \subseteq \hat{L}_X(\Gamma,
  G^\bowtie)L_X^{(k)}(G^\cap) \subseteq \hat{L}_X(\iota^{-1}(\Gamma),
  G^\cap)\len{G^\bowtie}
  = \mathcal{O}(\len{\pat}^3 \cdot \len{G})L_X^{(k)}(G^{\bowtie}) \subseteq \patt\mathcal{S}_\patt\prod^\bowtieL_X^{(k)}(G^\bowtie) \subseteq \hat{L}_X\left(\bigcup\mathcal{S}_\patt \cap \Gamma_X^{\df{k+1}}(G^\bowtie),
  G^\bowtie\right)\enspace.L_X^{(k)}(G^\cap) \subseteq \hat{L}_X\left(\iota^{-1}\left(\bigcup\mathcal{S}_\patt\right) \cap \Gamma_X^{\df{k+1}}(G^\cap),
  G^\cap\right)\enspace.\iota^{-1}(\Gamma_X^{\df{k+1}}(G^\bowtie))
  = \Gamma_X^{\df{k+1}}(G^\cap)L_X(G^\cap) \subseteq \patK=\mathcal{O}(\len{G^\cap})L_X(G^\cap) =
  L_X^{(K)}(G^\cap)K=\mathcal{O}(\len{\pat}^3 \cdot \len{G})L_X(G^\cap) \subseteq
  L_X^{(K)}(G^\cap) \subseteq \hat{L}_X\left(\iota^{-1}\left(\bigcup\mathcal{S}_\patt\right) \cap \Gamma_X^{\df{K+1}}(G^\cap),
  G^\cap\right) \subseteq L_X(G^\cap)L_X(G^\cap)
  = \hat{L}_X\left(\iota^{-1}\left(\bigcup\mathcal{S}_\patt\right) \cap \Gamma_X^{\df{K+1}}(G^\cap),
  G^\cap\right)\mathcal{S}_\patt
  = \set{\Gamma_1, \ldots, \Gamma_m}m>0\iota^{-1}(\Gamma_i)\widetilde{\Gamma}_iX \xRightarrow[\df{k+1}]{\gamma} wG^\cap\sem{w}=\emptyset\sem{\gamma}=\emptyset\sem{\mathcal{P}_{s,x}} \neq \emptyseti=1,\ldots,m\gamma \in \widetilde{\Gamma_i} \cap \Gamma_X^{\df{k+1}}(G^\cap)\sem{\gamma}\neq\emptyset\Gamma_i\len{G^\bowtie}^{\mathcal{O}(K)} =
  (\len{\pat}^3 \cdot \len{G})^{\mathcal{O}(K)} =
  (\len{\pat}^3 \cdot \len{G})^{\mathcal{O}(\len{\pat}^3 \cdot \len{G})}
  = 2^{\mathcal{O}(\len{\pat}^3 \cdot \len{G} \cdot (\log \len{\pat}
  + \log \len{G}))}\enspace.\len{G^\bowtie} = \mathcal{O}(\len{\pat}^3 \cdot \len{G})K = \mathcal{O}(\len{\pat}^3 \cdot \len{G})A^{\df{K+1}}_{G^\cap}\Gamma_X^{\df{K+1}}(G^\cap)\mathcal{G}^{\df{K+1}}L_{X^{\tuple{0}}}(\mathcal{G}^{\df{K+1}})
  = \Gamma_X^{\df{K+1}}(G^\cap)X^{\tuple{0}}A^{\df{K+1}}_{G^\cap}\mathcal{Q}
  = \tuple{\mathcal{G}^{\df{K+1}},X^{\tuple{0}},\sem{.}}\mathcal{G}^{\df{K+1}}\mathcal{P}\mathcal{Q}\foreach(\mathcal{P}_{s,x},\pat)\foreach(\mathcal{Q},\widetilde{\Gamma}_i)i=1,\ldots,m\mathcal{G}^{\df{K+1}}\len{\mathcal{G}^{\df{K+1}}} = \len{G^\cap}^{\mathcal{O}(K)} =
  (\len{\pat}^3 \cdot \len{G})^{\mathcal{O}(K)} =
  2^{\mathcal{O}(\len{\pat}^3 \cdot \len{G} \cdot (\log \len{\pat}
  + \log \len{G}))}\enspace.\foreach(\mathcal{Q},\widetilde{\Gamma}_i)2^{\mathcal{O}(\len{\pat}^3 \cdot \len{G} \cdot
  (\log \len{\pat} + \log \len{G}))}\mathcal{Q}\foreach(\mathcal{P}_{s,x},\pat)\foreach(\mathcal{P},\pat)\sem{P}=\sem{P}^{(k)}k>0G_k=\tuple{\Vars \times \set{0,\bar{0},\ldots,k,\bar{k}}, \Sigma, \prod_k}L_X(G)^{(k)} = L_{(X,k)}(G_k)\mathcal{P}_k
  = \tuple{G_k,(I,k),\sem{.}}\foreach(\mathcal{Q}_k,\widetilde{\Gamma}_i)\len{\pat}^3 \cdot \len{G_k})^{\mathcal{O}(k)} =
  (\len{\pat}^3 \cdot (k^2 \cdot\len{G}))^{\mathcal{O}(k)}. Since  is
  constant, we can solve this problem in \textsc{Nptime}, using
  an \textsc{Np} procedure \cite[Theorem 10]{bik14}. Since
  the \textsc{Np}-hard lower bound was proved above, the problem
  is \textsc{Np}-complete. \qed
\end{proof}

\end{document}
