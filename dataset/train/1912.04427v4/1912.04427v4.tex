\documentclass{article}
\clearpage{}\usepackage[final,nonatbib]{neurips_2020}
\usepackage{times}
\usepackage{enumitem}
\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    

\usepackage[colorlinks,citecolor=teal]{hyperref}       

\usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      

\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}
\newcommand{\blank}{{{}\cdot{}}}
\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 \usepackage{multirow}
\usepackage{algorithm,algorithmicx,algpseudocode}
\usepackage{amsmath}
\usepackage{pifont}
\usepackage{amsthm}
\usepackage{algorithm,algorithmicx,algpseudocode}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{comment}
\usepackage{float}
\usepackage{colortbl}
\usepackage[tableposition=top]{caption}
\usepackage{subcaption}
\usepackage{arydshln}

\usepackage{tikz}
\usetikzlibrary{spy,calc}

\usepackage{wrapfig}

\newcommand{\citep}[1]{\cite{#1}}
\newcommand{\citet}[1]{\cite{#1}}

\newcommand{\gb}[1]{\boldsymbol{#1}}


\newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}

\newcommand{\one}[1]{\left[\!\left[ #1 \right]\!\right]}




\newcommand{\FF}{\mathcal{F}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\GG}{\mathcal{G}}


\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{claim}{Claim}
\newtheorem{cor}{Corollary}
\newtheorem{rmk}{Remark}
\newtheorem{conj}{Conjecture}



\newcommand{\st}{\text{ s.t.} }
\newcommand{\Th}{\text{th} }
\newcommand{\ie}{\textit{i.e.,} }
\newcommand{\eg}{\textit{e.g.,} }
\newcommand{\etal}{\textit{et al.}}

\newcommand{\rank}{\operatorname{rank}}
\newcommand{\diag}{\operatorname{diag}}
\newcommand{\trace}{\operatorname{trace}}
\newcommand{\norm}[1]{\left\lVert{#1}\right\rVert}
\newcommand{\abs}[1]{\left\lvert{#1}\right\rvert}
\newcommand{\vnorm}[1]{\left\lVert{#1}\right\rVert} \newcommand{\mnorm}[1]{\left\lVert{#1}\right\rVert} \newcommand{\ip}[2]{\left\langle {#1}, {#2} \right\rangle}
\newcommand{\EE}{\ensuremath{\mathbb{E}}}
\newcommand{\iter}[1]{\left[{#1}\right]} \newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand*\Laplace{\mathop{}\!\mathbin\bigtriangleup}


\newcommand{\pnote}[1]{{\color{magenta}[Pedro: #1]}}
\newcommand{\dnote}[1]{{\color{blue}[David: #1]}}
\newcommand{\note}[1]{{\color{red}[Michael: #1]}}
\newcommand{\snote}[1]{{\color{green}[Sudarshan: #1]}}


\newcommand{\exmref}[1]{Example~\ref{#1}}
\newcommand{\thmref}[1]{Theorem~\ref{#1}}
\newcommand{\sthmref}[1]{Thm.~\ref{#1}}
\newcommand{\defref}[1]{Definition~\ref{#1}}
\newcommand{\remref}[1]{Remark~\ref{#1}}
\newcommand{\appref}[1]{Appendix~\ref{#1}}
\newcommand{\propref}[1]{Proposition~\ref{#1}}
\newcommand{\claimref}[1]{Claim~\ref{#1}}
\newcommand{\corref}[1]{Corollary~\ref{#1}}
\newcommand{\algoref}[1]{Algorithm~\ref{#1}}
\newcommand{\lemref}[1]{Lemma~\ref{#1}}
\renewcommand{\eqref}[1]{(\ref{#1})}

\newcommand{\currw}{w_t}
\newcommand{\nextw}{w_{t+1}}
\newcommand{\optw}{w^\star}
\newcommand{\wi}{w_i}
\newcommand{\currwi}{w_{t,i}}
\newcommand{\w}{w}

\newcommand{\fs}{f_s}

\newcommand{\prevg}{g_{t-1}}
\newcommand{\currg}{g_t}
\newcommand{\currgi}{g_{t,i}}

\newcommand{\prevm}{m_{t-1}}
\newcommand{\currm}{m_t}

\newcommand{\prevv}{v_{t-1}}
\newcommand{\currv}{v_t}
\newcommand{\prevvi}{v_{t-1,i}}
\newcommand{\currvi}{v_{t,i}}

\newcommand{\preve}{\eta_{t-1}}
\newcommand{\curre}{\eta_t}
\newcommand{\currei}{\eta_{t,i}}
\newcommand{\prevei}{\eta_{t-1,i}}

\newcommand{\preva}{\alpha_{t-1}}
\newcommand{\curra}{\alpha_t}

\newcommand{\normed}[1]{\left\lVert {#1} \right\rVert}
\newcommand{\dotp}[2]{\left\langle {#1}, {#2} \right\rangle}
\newcommand{\btwo}{\beta_2}
\newcommand{\bone}{\beta_1}
\newcommand{\btwot}{\beta_{2,t}}
\newcommand{\bonet}{\beta_{1,t}}
\newcommand{\avgreg}{\frac1T R_T}

\newcommand{\fdist}{D}
\newcommand{\smooth}{L}
\newcommand{\lowinf}{L_\infty}
\newcommand{\lowinft}{L_{t, \infty}}
\newcommand{\highinf}{H_\infty}
\newcommand{\highinft}{H_{t,\infty}}
\newcommand{\gradb}{G_2}

\newcommand{\loss}{\ell}

\newcommand{\supp}{\mathcal S}

\newcommand{\expec}[2]{\mathbb E_{#1} \left[ {#2} \right]}
\newcommand{\var}[2]{\mathrm{Var}_{#1} \left[ {#2} \right]}

\newcommand{\algrand}{\substack{s \sim \dist^T \\ t \sim \mathcal P(t|s)}}

\newcommand{\dist}{\mathcal D}
\newcommand{\cov}{\mathrm{Cov}}

\newcommand{\vones}{\vec 1}

\newcommand{\nrt}[2]{\sqrt[\leftroot{-3}\uproot{3}{#1}]{{#2}}}



\newcommand{\method}{Continuous Sparsification}
\newcommand{\methodacro}{CS}
\clearpage{}

\title{Winning the Lottery with \method}

\makeatletter
\newcommand{\printfnsymbol}[1]{\textsuperscript{\@fnsymbol{#1}}}
\makeatother

\author{Pedro Savarese\thanks{equal contribution} \\
    TTI-Chicago \\
    \texttt{savarese@ttic.edu} \\
    \And
    Hugo Silva\printfnsymbol{1} \\
    University of Alberta \\
    \texttt{hugoluis@ualberta.ca} \\
    \And
    Michael Maire \\
    University of Chicago \\
    \texttt{mmaire@uchicago.edu} \\
}

\begin{document}
\raggedbottom

\maketitle

\begin{abstract}
The search for efficient, sparse deep neural network models is most prominently performed by pruning: training a dense, overparameterized network and removing parameters, usually via following a manually-crafted heuristic. Additionally, the recent Lottery Ticket Hypothesis conjectures that, for a typically-sized neural network, it is possible to find small sub-networks which, when trained from scratch on a comparable budget, match the performance of the original dense counterpart. We revisit fundamental aspects of pruning algorithms, pointing out missing ingredients in previous approaches, and develop a method, Continuous Sparsification, which searches for sparse networks based on a novel approximation of an intractable  regularization. We compare against dominant heuristic-based methods on pruning as well as ticket search -- finding sparse subnetworks that can be successfully re-trained from an early iterate. Empirical results show that we surpass the state-of-the-art for both objectives, across models and datasets, including VGG trained on CIFAR-10 and ResNet-50 trained on ImageNet. In addition to setting a new standard for pruning, Continuous Sparsification also offers fast parallel ticket search, opening doors to new applications of the Lottery Ticket Hypothesis.
\end{abstract}

\section{Introduction}

Although deep neural networks have become ubiquitous in fields such as computer vision and natural language processing, extreme overparameterization is typically required to achieve state-of-the-art results, incurring higher training costs and hindering applications limited by memory or inference time. Recent theoretical work suggest that overparameterization plays a key role in network training dynamics \citep{overparamtraining} and generalization \citep{roleofoverparam}. However, it remains unclear whether, in practice, overparameterization is truly necessary to train networks to state-of-the-art performance.

Concurrently, empirical approaches have been successful in finding compact neural networks, either by shrinking trained models \citep{magnitudepruning, gmp, deepcompress} or through efficient architectures, yielding less overparameterized models that can be trained from scratch \citep{squeezenet}. Recently, combining these two strategies has lead to new methods which discover efficient architectures through optimization instead of design \citep{darts,implicitrecurrent}. Nonetheless, parameter efficiency is typically maximized by pruning an already trained network.

Despite the fact that the search for sparse solutions to optimization problems can be naturally described by  regularization, the vast majority of pruning methods rely on manually-designed strategies that are not based on the  penalty \cite{magnitudepruning, gmp, dnw, softweight}. The approaches that aim to approximate an -regularized problem in order to find sparse, less overparameterized networks are limited in number \cite{l0bernoulli, sparsityl0} and fail to perform competitively against heuristic-based pruning methods.

Prior work has shown that pruned networks are hard to train from scratch \citep{magnitudepruning}, suggesting that while overparameterization is not necessary for a model's capacity, it might be required for successful training. Frankle and Carbin~\citet{lth} put this idea into question by training heavily pruned networks from scratch, while achieving performance matching that of their original counterparts. A key finding is that the same initialization should be used when re-training the pruned network, or, equivalently, that better strategies -- depending on \emph{future weights} -- can result in trainable pruned networks.

More recently, Frankle~\etal~\cite{linearmode} show that although this approach can fail in large-scale settings, pruned networks can be successfully re-trained when parameters from very early training are used as initialization. Coupling a pruned network with a set of parameter values from initialization yields a \textit{ticket} -- a \textit{winning ticket} if it is able to match the dense model's performance when trained in isolation for a comparable number of iterations. These have already found applications in, for example, transfer learning \citep{generaltickets, transfertickets, transtickets2}, making \textit{ticket search} a problem of independent interest.

Iterative Magnitude Pruning (IMP) \citep{lth}, the first and currently only algorithm able to find winning tickets, consists of a repeating a two-stage procedure that alternates between training and pruning. IMP relies on a sensible choice for pruning strategy \cite{deconstructing} and can be costly: maximizing the performance of the found subnetworks typically requires multiple \textit{rounds} of training followed by pruning \cite{lth2}.

In this paper, we focus on two questions related to pruning and the Lottery Ticket Hypothesis. First, can we find sparse networks with competitive performance by approximating  regularization instead of relying on a heuristic pruning strategy and, if yes, what are the missing ingredients in previous approaches \cite{l0bernoulli, sparsityl0}? Second, would a method that relies on -regularization, rather than an ad-hoc heuristic, be able to find winning tickets, as IMP does?

We provide positive answers to both questions by proposing \method\footnote[1]{Code available at \url{https://github.com/lolemacs/continuous-sparsification}}, a new pruning method that relies on approximating the intractable  penalty and finds networks that perform competitively when either fine-tuned or re-trained. Unlike prior -based approaches, our approximation is \emph{deterministic}, providing insights and raising questions on how pruning and sparse regularization should be performed. The core of our method lies in constructing a smooth continuation path \cite{contmethods} connecting training of soft-gated parameters and the intractable -regularized objective.

\textbf{Contributions:}
\vspace{-5pt}
\begin{itemize}[leftmargin=*]
\item{We propose a novel approximation to  regularization, resulting in \method, a new pruning method with theoretical and empirical advantages over previous -based approaches. We show through experiments that the deterministic nature of our re-parameterization is key to achieving competitive results with  approximations.}
\item{We show that \method~outperforms state-of-the-art heuristic-based pruning methods. Our experiments include pruning of VGG-16~\cite{vgg} and ResNet-20~\cite{resnet1} trained on CIFAR-10~\citep{cifar}, and ResNet-50 trained on ImageNet~\citep{imagenet}.}
\item{Our method raises questions on how to do better ticket search -- producing subnetworks that can be re-trained from early iterates. We show empirically that \method~is capable of finding subnetworks of VGG-16, ResNet-20, and ResNet-50 that, when re-trained, outperform ones found by IMP. Moreover, the search cost of our method does not depend on the produced subnetwork's sparsity, making ticket search considerably more efficient when run in parallel.}
\end{itemize}

\section{Preliminaries}

Here we define terms used throughout the paper.

\textbf{Subnetwork:} For a network  that maps samples  and parameters  to , a subnetwork  of  is given by a binary mask , where a parameter component  is kept in  if  and removed otherwise \ie , with  denoting element-wise multiplication. For any configuration , the effective parameter space of the induced network  is  -- a -dimensional space, hence we say that the subnetwork  has  many parameters instead of .

\textbf{Matching subnetwork:} For a network  and randomly-initialized parameters , a matching subnetwork  of  is given by a configuration , such that  can be trained in isolation from , where  is the collection of parameter values obtained by training  from  for  iterations, where  is small. Moreover, to be a matching subnetwork,  needs to match the performance of a trained  given the same budget, when measured in terms of training iterations.

\textbf{Winning ticket:} For a network  and randomly-initialized parameters , a winning ticket is a matching subnetwork  of  that can be trained in isolation \textit{from initialization}, \ie . In other words, a winning ticket is a matching subnetwork such that  in the definition above.

\textbf{Ticket search} is the task of finding matching subnetworks given a network  and randomly-initialized parameters . We say that an algorithm  performs ticket search if , such that  induces a (possibly matching) subnetwork .
 \section{Related Work}
\subsection{Sparse Networks}
Classical pruning methods \citep{braindamage} follow a pre-defined strategy to remove weights, and generally operate by ranking parameters according to an easy-to-compute statistic like weight magnitude \citet{magnitudepruning}. Such methods rely on the assumption that the considered statistic is a sensible surrogate for how much each parameter affects a network's output, and typically select weights for removal once the dense model has been fully trained. Magnitude-based pruning, the most prominent heuristic pruning method, improves when given multiple \textit{rounds} of training followed by pruning \cite{magnitudepruning,stateofsparsity}.

Another approach consists of approximating an intractable -regularized objective which accounts for the number of non-zero weights in the model, yielding one-stage procedures that can be fully described in the optimization framework. More common in the literature are stochastic approximations, where a binary mask  over the weights is sampled from a distribution  at each training iteration, introducing new variables  which are optimized jointly with the weight parameters \cite{l0bernoulli, sparsityl0}.

Training the mask parameters  is done by estimating the gradients of the \emph{expected} loss w.r.t.~, \eg via the straight-through estimator \cite{straightthrough}, thus relying on estimated gradients which can be biased and have high variance. -based methods have the advantage of not relying on a heuristic to prune weights, and continuously sparsify the network \emph{during} training instead of at pre-defined steps.

\subsection{Lottery Ticket Hypothesis}
Frankle and Carbin~\cite{lth} show that, in some settings, sparse subnetworks can be successfully re-trained and yield better performance than their original dense networks, often also on a smaller compute budget for re-training. This observation leads to the Lottery Ticket Hypothesis \citep{lth}, which conjectures that for a reasonably-sized network  and randomly-initialized parameters , there exists a sparse subnetwork , given by a configuration , , that can be trained from  to perform comparably to a trained version of the original model .

The proposal of Iterative Magnitude Pruning (IMP; Algorithm \ref{alg:imp}) \citep{lth2} supports this hypothesis.  IMP is capable of finding such subnetworks, named winning tickets, in convolutional networks trained for image classification. IMP operates in multiple \textit{rounds}, sparsifying the network at discrete time intervals and producing subnetworks with increasing sparsity levels during execution. More specifically, each \textit{round} in IMP consists of: (1) training the weights  of a network, (2) pruning a fixed fraction of the weights with the smallest magnitude, and (3) \textit{rewinding}: setting the remaining weights back to their original initialization .

Following Frankle~\etal~\cite{lth2}, we consider a general form of IMP where step (3) is relaxed to rewind the weights to an early iterate  (for relatively small ) instead of the original initialization values . We refer to the process of searching for a sparse subnetwork and a set of early iterates  as ticket search, even though the produced subnetworks are truly only winning tickets when they perform comparably to the dense model when trained in isolation from , \ie .

The search for winning tickets has attracted attention due to their valuable properties. In small-scale settings, tickets can be trained \emph{faster} than their dense counterparts while yielding \emph{better} final performance~\cite{lth}. Moreover, they can be transferred between datasets \citep{transfertickets, transtickets2} and training methods \citep{generaltickets}. Zhou~\etal~\citet{deconstructing} attempt to better understand the Lottery Ticket Hypothesis through extensive experiments, showing that a stochastic approximation to  regularization can be used to perform ticket search with SGD, without ever training the weights (non-retroactive search).





 \begin{minipage}[t]{.49\textwidth}
\begin{algorithm}[H]
    \textbf{Input:} Pruning ratio , number of rounds ,\\iterations per round , rewind point 
    \caption{Iterative Magnitude Pruning \citep{lth2}}
    \begin{algorithmic}[1]
    \State Initialize , , 
    \State Minimize  for  iterations, producing 
    \State Remove  percent of the weights with smallest magnitude
    \State If , output 
    \State Otherwise, set ,  and go back to step 2, thereby starting a new round
    \end{algorithmic}
\label{alg:imp}
\end{algorithm}
\end{minipage}\hfill
\begin{minipage}[t]{.49\textwidth}
  \vspace{0pt}
\begin{algorithm}[H]
    \textbf{Input:} Mask init , penalty , number of rounds , iterations per round , rewind point 
    \caption{\method}
    \begin{algorithmic}[1]
    \vspace{1.25pt}
    \State Initialize , , , 
    \State Minimize  for  iterations while increasing , producing , , and 
    \State If , output 
    \State Otherwise, set , ,  and go back to step 2, thereby starting a new round
    \end{algorithmic}
\label{alg:ours}
\end{algorithm}
\vspace{0.5pt}
\end{minipage}

\section{Method}

Our goal is to design a method that can efficiently sparsify networks without causing performance degradation. Ideally, and in contrast to magnitude pruning, the time to produce a subnetwork should be independent of its sparsity. Unlike dominant pruning approaches \cite{magnitudepruning,gmp,dnw}, we rely on approximating  regularization, as it induces a clear trade-off between sparsity and performance, providing a way to maximize sparsity while maintaining performance. By continuously sparsifying the network during training, we do not require a heuristic to select which parameters to remove or when to remove them.

To avoid gradient estimators and to avoid having to \emph{commit} to a configuration for  to be used at inference -- obstacles that are inherent to stochastic approximations to the  objective -- we design a \emph{deterministic} approximation instead, as we describe below.

\subsection{Continuous Sparsification by Learning Deterministic Masks}



Given a network  that maps samples  to  using parameters , we first frame the search for sparse subnetworks as a loss minimization problem with  regularization:

where  denotes the loss incurred by the network  and  controls the trade-off between the loss and number of parameters . We restate the above minimization problem as

which uses the fact that  for binary . While the  penalty is amenable to subgradient descent, the combinatorial constraint  makes local search unsuited for the problem above.

As in most methods that approximate  regularization, we will circumvent the discrete space of  by re-parameterizing it as a function of a newly-introduced variable . In contrast to previous work \cite{sparsityl0,l0bernoulli}, we propose a re-parameterization that is fully \emph{deterministic}, hence avoiding biased and/or noisy training caused by gradient estimators \cite{straightthrough}.

Consider an intermediate and still intractable problem, given by defining , with  and  being the Heaviside step function applied element-wise, \ie  if  and  otherwise. This yields the following equivalent form for the problem in \eqref{eq:binarymaskobjective}:

Being equivalent to \eqref{eq:l0objective}, the above is still intractable: the step function  is discontinuous and its derivative is zero everywhere. We approximate  by constructing a set of functions indexed by  given by  where  is the sigmoid function  applied element-wise. This set can be seen as a \emph{path} parameterized by , and given any fixed , we have at one of its endpoints . Conversely, for  we have , the standard sigmoid activation function that is smooth and widely used in neural network models.

Using this family of functions to approximate  yields the re-parameterization . Controlling the inverse temperature  allows interpolation between the sigmoid activation , which assigns continuous values for , and the step function . Each  induces the objective


Note that if  is continuous in , then:

where the right-hand-side is equivalent to the -regularized objective. Therefore,  controls the computational hardness of the objective: as  increases from 1 to , the objective changes from , where a soft-gating  is applied to the weights, to , where weights are either removed or fully preserved. Increasing the hardness of the underlying objective during training stems from continuation methods \cite{contmethods} and can be successful in approximating intractable problems.

In terms of sparsification, every negative component of  will drive the corresponding component of  to  as , effectively pruning a weight. While analytically it is never the case that  regardless of how large  is, limited numerical precision has a fortunate side-effect of causing actual sparsification to the network during training as  becomes sufficiently large.

In a nutshell, our method consists of learning sparse networks by minimizing  for  parameter updates with gradient descent while jointly annealing : producing ,  and . Note that, in order to recover a binary mask  from our re-parameterization,  must be large enough such that, \emph{numerically}\footnote{In experiments, we observed that a final temperature of  is sufficient for iterates of  when training with SGD using -bit precision. The required temperature is likely to depend on how  is represented numerically, as our implementation relies on numerical imprecision rather than (alternatively) clamping after some threshold.}, . Alternatively, we can directly output  at the end of training, guaranteeing that the learned mask is indeed binary. We adopt an exponential schedule  for  during training, increasing it from  up to . Such a schedule has the advantage of only requiring us to tune , and has been successfully utilized in prior work \cite{gumbel}.

\subsection{Ticket Search through \method}

The method described above is essentially a pruning method, which we use to replace magnitude-based pruning as the backbone for ticket search. Note that searching for matching subnetworks requires produced masks to be binary: otherwise, the magnitude of the weights will also be learned. We guarantee that the final mask is binary regardless of numerical precision by outputting .

Similarly to IMP, our ticket search procedure operates in \emph{rounds}, where each round consists of training and sparsifying the network. At the beginning of a round, we set  back to 1 so that additional weights can be removed (otherwise  would be large throughout the round, causing a vanishing Jacobian of  w.r.t.~). Moreover, we reset the parameter  of each weight  that has not been suppressed by the optimizer during the round (\ie weights whose gating value has increased during training). This is achieved by setting , effectively resetting the soft mask parameters  for ``kept'' weights without interfering with weights that have been suppressed. Algorithm \ref{alg:ours} presents our method for ticket search, which does \textbf{not} rewind weights between rounds, in contrast to IMP \cite{lth2}.

\subsection{Comparison to Stochastic Approaches}

Prior works~\cite{l0bernoulli, sparsityl0} approximating the  objective adopt a stochastic re-parameterization  for some distribution  with parameters . During training, a new binary mask  is sampled from  at every forward pass of the network. Hence, outputs can change drastically from one pass to another due to variance in sampling. Such approaches have found limited success in pruning.

Gale~\etal~\cite{stateofsparsity} report that the stochastic approach from Louizos~\etal~\cite{sparsityl0} fails to sparsify a residual network without degrading its accuracy to random chance. Stochastic approximations introduce another problem: different behavior between training and inference. While a new mask is sampled at each training iteration, at inference it is common to use a deterministic mask, such as that with highest mass \cite{l0bernoulli} or an approximation for it \cite{sparsityl0}. This assures that the outputs at inference are consistent, but can introduce a gap in sparsity and performance between training and inference modes.

Conversely, \method~offers consistency in training mode -- outputs for a input are the same across forward passes -- and no gap between training and inference. In Section \ref{seq-pruning}, experimental comparisons with stochastic approximations show that these differences play a key role in attaining faster training, higher sparsity, and superior performance when pruning deep networks.











 \section{Experiments}

We compare methods on the tasks of pruning and finding matching subnetworks. We quantify the performance of ticket search by focusing on two specific subnetworks produced by each method:
\vspace{-7pt}
\begin{itemize}[leftmargin=*,itemsep=0pt]
    \item \textbf{Sparsest matching subnetwork}: the sparsest subnetwork that, when trained in isolation from an early iterate, yields performance no worse than that achieved by the trained dense counterpart.
    \item \textbf{Best performing subnetwork}: the subnetwork that achieves the best performance when trained in isolation from an early iterate, regardless of its sparsity.
\end{itemize}

We also measure the efficiency of each method in terms of total number of epochs to produce subnetworks, \emph{given enough parallel computing resources}. As we will see, \method~is particularly suited for parallel execution since it requires relatively few rounds to produce subnetworks regardless of sparsity. On the other hand, \methodacro~offers no explicit mechanism to control the sparsity of the found subnetworks, hence producing a subnetwork with a pre-defined sparsity level can require multiple runs with different hyperparameter settings. For this use case, IMP is more efficient by design, since a single run suffices to produce subnetworks with varying, pre-defined sparsity levels.

For \method, we set hyperparameters  and , based on analysis in Appendix \ref{app:analysis}, which studies how , , and  affect the sparsity of produced subnetworks. We observe that  has a major impact on sparsity levels, while  and  require little to no tuning.

We reiterate that \method~does not perform weight rewinding in the following experiments; rather, it maintains weights between rounds. Our experimental comparisons include a variant of IMP that also does not rewind weights between rounds, which we denote as ``continued'' IMP (IMP-C). Algorithms~\ref{alg:imp} and~\ref{alg:ours} provide more implementation details. Comparisons against a baseline inspired by Zhou~\etal~\cite{deconstructing}, and described in Appendix~\ref{app:iss}, on the tasks of learning a supermask and ticket search on a 6-layer CNN can be found in Appendices~\ref{app:supermask} and~\ref{app:ticket6cnn}.

\subsection{Ticket Search on Residual Networks and VGG}
\label{sec:resnet}

First, we evaluate how IMP and \methodacro~perform on the task of ticket search for VGG-16 \cite{vgg} and ResNet-20\footnote{We used the same network as Frankle and Carbin~\citet{lth} and Frankle~\etal~\citet{lth2}, who refer to it as ResNet-18.} \cite{resnet1} trained on the CIFAR-10 dataset, a setting where IMP can take over  rounds (850 epochs given 85 epochs per round \cite{lth2}) to find sparse subnetworks. We follow Frankle and Carbin's setup~\citet{lth}: in each round, we train with SGD, a learning rate of , and a momentum of , for a total of  epochs, using a batch size of  for VGG and  for ResNet. We decay the learning rate by a factor of  at epochs  and , and utilize a weight decay of .

For \methodacro, we do not apply weight decay to the mask parameters , since they are already suffer  regularization. Sparsification is performed on all convolutional layers, excluding the two skip-connections of ResNet-20 that have  kernels: for IMP, their parameters are not pruned, while for \methodacro~their weights do not have an associated learnable mask.

We evaluate produced subnetworks by initializing their weights with the iterates from the end of epoch 2, similarly to Frankle~\etal~\citet{lth2}, followed by re-training. IMP performs global pruning at a per-round rate of removing  of the remaining parameters with smallest magnitude. We run IMP for  iterations, yielding  tickets with varying sparsity levels (). To produce tickets of differing sparsity with \methodacro, we vary  across  values from  to , performing a run of 5 rounds for each setting. We repeat experiments 3 times, with different random seeds.

\begin{figure*}[!bt]
    \centering
    \begin{minipage}[l]{0.49\linewidth}
      \centering
      \tiny{\textsf{Ticket Search: VGG-16 on CIFAR-10}}
      \includegraphics[width=\linewidth]{newfigs/vgg.pdf}
    \end{minipage}
    \hfill
    \begin{minipage}[l]{0.49\linewidth}
      \centering
      \tiny{\textsf{Ticket Search: ResNet-20 on CIFAR-10}}
      \includegraphics[width=\linewidth]{newfigs/resnet.pdf}
    \end{minipage}
    \vspace{-5pt}
    \caption{Test accuracy and sparsity of subnetworks produced by IMP and \methodacro~after re-training from weights of epoch 2. Purple curves show individual runs of \methodacro, while the green curve connects tickets produced after 5 rounds of CS with varying . Iterative Magnitude Pruning (continued) refers to IMP without rewinding between rounds. Error bars depict variance across 3 runs.}
    \label{fig:tickets}
\end{figure*}

\begin{table}[!tb]
\setlength{\tabcolsep}{2pt}
\begin{minipage}[t]{0.21\linewidth}
\vspace{-7pt}
\caption{Test accuracy and sparsity of the sparsest matching and best performing subnetworks produced by \methodacro, IMP, and IMP-C (IMP without rewinding) for VGG-16 and ResNet-20 trained on CIFAR-10.}
\label{tab:ticket}
\end{minipage}
\hfill
\begin{minipage}[t]{0.77\linewidth}
\vspace{0pt}
\centering
\footnotesize
\begin{tabular}{@{}clcrrrcrrr@{}}
\toprule
\multicolumn{2}{c}{} && \multicolumn{3}{c}{VGG-16} && \multicolumn{3}{c}{ResNet-20}\-1pt]
\multicolumn{2}{c}{}                        &&                        & \multicolumn{1}{c}{Accuracy} & Remaining &&                        & \multicolumn{1}{c}{Accuracy} & Remaining\\
\midrule
\multicolumn{2}{c}{Dense Network} &&  1 & 92.35\%          & 100.0\%         && 1 & 90.55\%          & 100.0\%\\
\-8pt]
\multirow{1}{*}{Sparsest~}   & ~IMP   && 18 & 92.36\%          & 1.8\%           && 7 & 90.57\%          & 20.9\% \\
\multirow{1}{*}{Matching~}   & ~IMP-C && 18 & 92.56\%          & 1.8\%           && 8 & 91.00\%          & 16.7\% \\
\multirow{1}{*}{Subnetwork~}     & ~CS    &&  5 & 93.35\%          & \textbf{1.7\%}  && 5 & 91.43\%          & \textbf{12.3\%}\\
\-8pt]
\multirow{1}{*}{Best~}       & ~IMP   && 13 & 92.97\%          & 5.5\%           && 6 & 90.67\%          & 26.2\% \\
\multirow{1}{*}{Performing~} & ~IMP-C && 12 & 92.77\%          & 6.9\%           && 4 & 91.08\%          & 40.9\% \\
\multirow{1}{*}{Subnetwork~}     & ~CS    &&  4 & \textbf{93.45\%} & 2.4\%           && 5 & \textbf{91.54\%} & 16.9\% \-2pt]
\bottomrule
\end{tabular}
\end{minipage}
\end{table}

Figure~\ref{fig:tickets} shows the performance and sparsity of tickets produced by \methodacro~and IMP, including IMP without rewinding (continued). Purple curves show individual runs of \methodacro~for different values of , each consisting of 5 rounds, and the green curve shows the performance of subnetworks produced with different hyperparameters. Plots of individual runs are available in Appendix~\ref{app:additional}, but have been omitted here for the sake of clarity. Given a search budget of 5 rounds (\ie  epochs), \methodacro~successfully finds subnetworks with diverse sparsity levels. Notably, IMP produces tickets with superior performance when weight rewinding is not employed between rounds.

Table~\ref{tab:ticket} summarizes the performance of each method when evaluated in terms of the sparsest matching and best performing subnetworks. IMP-C denotes IMP without rewinding, \ie IMP (continued) from Figure~\ref{fig:tickets}. Sparsest matching subnetworks produced by \methodacro~are sparser than the ones found by IMP and IMP-C, while also delivering higher accuracy. \methodacro~also outperforms IMP and IMP-C when evaluating the best performing produced subnetworks. In particular, \methodacro~yields highly sparse subnetworks that outperform the original model by approximately  on both VGG-16 and ResNet-20.

If all runs are executed in parallel, producing all tickets presented in Figure~\ref{fig:tickets} takes \methodacro~a total of  training epochs, while IMP requires  epochs instead. Note that our re-parameterization results in approximately  longer training times on a GPU due to the mask parameters , therefore wall-clock time for \methodacro~is  higher per epoch. Sequential search takes  epochs for \methodacro~to produce all tickets in Figure~\ref{fig:tickets}, while IMP requires  epochs, hence \methodacro~is faster given sufficient parallelism, but slower if run sequentially. Appendix~\ref{app:seqcs} shows preliminary results of a variant of \methodacro~designed for sequential search.

\subsection{Pruning}
\label{seq-pruning}

Since \methodacro~is a general-purpose method to find sparse networks, we also evaluate it on the more standard task of network pruning, where produced subnetworks are fine-tuned instead of re-trained. We compare it against the prominent pruning methods AMC~\cite{amc}, magnitude pruning (MP)~\cite{magnitudepruning}, GMP~\cite{gmp}, and Network Slimming (Slim)~\cite{slim}, along with the -based method of Louizos~\etal~\cite{sparsityl0} (referred to as ``''), which, in contrast to ours, adopts a stochastic approximation for  regularization.

We train VGG-16 and ResNet-20 on CIFAR-10 for 200 epochs, with a initial learning rate of  which is decayed by a factor of  at epochs 80 and 120. The subnetwork is produced at epoch 160 and is then fine-tuned for 40 extra epochs with a learning rate of . More specifically, at epoch 160 the subnetwork structured is fixed: AMC, MP, GMP and Slim zero-out elements in the binary matrix  for the last time, while \methodacro~fixes  and stops training of the mask parameters .

Adopting the inference behavior suggested in Louizos~\etal~\cite{sparsityl0} for , \ie using the expected value of the uniform distribution to generate hard concrete samples, leads to poor results, including accuracy akin to random guessing at sparsity above ; this is also reported in Gale~\etal~\cite{stateofsparsity}. Instead, at epoch 160, we sample different masks and commit to the one that performs the best -- this strategy results in drastic improvements at high sparsity levels. This suggests that the gap between training and inference behavior introduced by stochastic approaches can be an obstacle. Although our modification improves results for , the method still performs poorly compared to alternatives.

Moreover, some methods required modifications as they were originally designed to perform structured pruning. For AMC, Slim, and  we replace a filter-wise mask by one that acts over weights. Since Network Slimming relies on the filter-wise scaling factors of batch norm, we introduce weight-wise scaling factors which are trained jointly with the weights. We observe that applying both  and  regularization to the scaling parameters, as done by Liu~\etal~\cite{slim}, yields inferior performance, which we attribute to over-regularization. A grid search over the penalty of each norm regularizer shows that only applying  regularization with a strength of  for ResNet-20 and  for VGG-16 improves results.

Figure~\ref{fig:pruning} displays one-shot pruning results. On VGG, only \methodacro~and Slim successfully prune over  of the weights without severely degrading the performance of the model, while on ResNet the best results are achieved by \methodacro~and GMP. Table~\ref{tab:pruning} shows the percentage of weights that each method can remove while maintaining a performance within  of the original, dense model. \methodacro~is capable of removing significantly more parameters than all competing methods on both networks: on ResNet-20, the pruned network found by \methodacro~contains  less parameters than the one found by GMP, when counting prunable parameters only. \methodacro~not only offers significantly superior performance compared to the prior -based method of Louizos~\etal~\cite{sparsityl0}, but also comfortably outperforms all other methods, providing a new state-of-the-art for network pruning.

\begin{figure*}[!bt]
    \centering
    \begin{minipage}[l]{0.49\linewidth}
      \centering
      \tiny\textsf{Pruning: VGG-16 on CIFAR-10}
      \includegraphics[width=\linewidth]{newfigs/pruning_vgg.pdf}
    \end{minipage}
    \hfill
    \begin{minipage}[l]{0.49\linewidth}
      \centering
      \tiny\textsf{Pruning: ResNet-20 on CIFAR-10}
      \includegraphics[width=\linewidth]{newfigs/pruning_resnet.pdf}
    \end{minipage}
    \caption{Performance of different methods when performing one-shot pruning on VGG-16 and ResNet-20, measured in terms of test accuracy and sparsity of produced subnetworks after fine-tuning.}
    \label{fig:pruning}
\end{figure*}

\begin{table}[!tb]
\setlength{\tabcolsep}{4pt}
\begin{minipage}{0.385\linewidth}
\vspace{-6pt}
\caption{Sparsity (\%) of the sparsest subnetwork within  test accuracy of the original dense model, for different pruning methods on CIFAR.}
\label{tab:pruning}
\end{minipage}
\hfill
\begin{minipage}{0.60\linewidth}
\vspace{0pt}
\footnotesize
\centering
\begin{tabular}{@{}lrrrrrc@{}}
\toprule
 & \citet{sparsityl0} & AMC & MP & GMP & NetSlim & CS \\ \cmidrule{2-7}
VGG-16 & 18.2\% & 86.0\% & 97.5\% & 98.0\% & 99.0\% & \textbf{99.6\%}  \\
ResNet-20 & 13.6\% & 50.0\% & 80.0\% & 86.0\% & 85.0\% & \textbf{94.4\%} \\ \bottomrule
\end{tabular}
\end{minipage}
\end{table}





\subsection{Residual Networks on ImageNet}
\label{sec:imagenet}

We perform pruning and ticket search for ResNet-50 trained on ImageNet~\cite{imagenet}. Following Frankle~\etal~\citet{lth2}, we train the network with SGD for 90 epochs, with an initial learning rate of  that is decayed by a factor of 10 at epochs  and . We use a batch size of 256 distributed across 4 GPUs and a weight decay of . We run \methodacro~for a single round due to the high computational cost of training ResNet-50 on ImageNet. Once the round is complete, we evaluate the performance of the produced subnetwork when fine-tuned (pruning) or re-trained from an early iterate (ticket search).

\newlength{\oldcolumnsep}
\newlength{\oldintextsep}
\setlength{\oldcolumnsep}{\columnsep}
\setlength{\oldintextsep}{\intextsep}
\setlength\columnsep{15pt}
\setlength\intextsep{-2pt}

\begin{wraptable}{r}{0.268\textwidth}
\vspace{-10pt}
\caption{Performance of found ResNet-50 subnetworks on ImageNet.}
\label{tab:imagenet}
\footnotesize
\begin{tabular}{@{}lrr@{}}
\toprule
 Method & \begin{tabular}[x]{@{}r@{}}Top-1\\Acc.\end{tabular} & Sparsity \\ \midrule
 GMP & 73.9\% & 90.0\%  \\ 
 DNW & 74.0\% & 90.0\%  \\ 
 STR & 74.3\% & 90.2\%  \\ \hdashline
 
 IMP & 73.6\% & 90.0\%  \\
 CS & \textbf{75.5\%} &  91.8\% \\ \midrule
 
 GMP & 70.6\% & 95.0\%  \\ 
 DNW & 68.3\% & 95.0\%  \\ 
 STR & 70.4\% & 95.0\%  \\ 
 CS & \textbf{72.4\%} &  95.3\% \\\hdashline
 
 IMP & 69.2\% & 95.0\%  \\ 
 CS & \textbf{71.1\%} &  95.3\% \\ \midrule
 
 STR & 67.2\% & 96.5\%  \\
 CS & \textbf{71.4\%} &  97.1\% \\ \hdashline
 
 CS & 69.6\% &  97.1\% \\ \midrule
 
 GMP & 57.9\% & 98.0\%  \\ 
 DNW & 58.2\% & 98.0\%  \\ 
 STR & 61.5\% & 98.5\%  \\
 CS & \textbf{70.0\%} &  98.0\% \\ \hdashline
 
 CS & 67.9\% &  98.0\% \\ \midrule
 
 GMP & 44.8\% & 99.0\%  \\ 
 STR & 54.8\% & 98.8\%  \\
 CS & \textbf{66.8\%} &  98.9\% \\ \hdashline
 
 CS & 64.9\% &  98.9\% \\ \bottomrule
\end{tabular}
\end{wraptable}
\setlength{\intextsep}{\oldintextsep}

We run \methodacro~with  yielding 5 subnetworks with varying sparsity levels. Table~\ref{tab:imagenet} summarizes the results achieved by \methodacro, IMP, and current state-of-the-art pruning methods GMP~\cite{gmp}, STR~\cite{softweight}, and DNW~\cite{dnw}. A  superscript denotes results of a re-trained, rather than fine-tuned, subnetwork. Differences in each technique's methodology -- for example, the adopted learning rate schedule and number of epochs -- complicate the comparison.

\methodacro~produces subnetworks that, when re-trained, outperform the ones found by IMP by a comfortable margin (compare CS and IMP). Moreover, when evaluated as a pruning method, \methodacro~outperforms all competing approaches, especially in the high-sparsity regime. Therefore, our method provides state-of-the-art results whether the network is fine-tuned (pruning) or re-trained (ticket search).
 \section{Discussion}

With Frankle and Carbin~\citet{lth}, we now realize that sparse subnetworks can indeed be successfully trained from scratch or an early iterate, putting in question whether overparameterization is required for proper optimization of neural networks. Such subnetworks can potentially decrease the required resources for training deep networks, as they are shown to transfer between different, but similar, tasks \citep{transfertickets, transtickets2}.

The \textit{search} for winning tickets is a poorly explored problem, with, prior to our work, Iterative Magnitude Pruning~\citep{lth} standing as the only algorithm suited for this task. It is unclear whether IMP's key ingredients -- post-training magnitude pruning and parameter rewinding -- are the correct choices. Here, we approach the problem of finding sparse subnetworks as an -regularized optimization problem, which we approximate through a smooth relaxation of the step function.

Our proposed algorithm, \method, relies on a deterministic approximation of  regularization, removes parameters automatically and continuously during training, and can be fully described by the optimization framework. We show empirically that, indeed, post-training pruning might not be the most sensible choice for ticket search, raising questions on how the search for tickets differs from standard network compression. In tasks such as pruning VGG and finding winning tickets in ResNets, our method offers improvements in terms of ticket search and resulting sparsity -- we can sparsify VGG to extreme levels, and speed up ticket search using an efficiently parallelizable framework. We hope to further motivate the problem of \textit{quickly} finding tickets in complex networks, as the task might be highly relevant to transfer learning and mobile applications.

At the same time, \method~serves as a practical network pruning method, outperforming modern competitors as measured by accuracy and sparsity of produced subnetworks. \method's principled formulation has the potential to open new avenues for research into neural network optimization and architecture search.
 
\begin{ack}
We thank the anonymous reviewers for providing extensive and extremely valuable feedback on earlier drafts of this work.

The University of Chicago CERES Center contributed to the financial support of Pedro Savarese.  The authors have no competing interests.
\end{ack}

\bibliography{lottery}
\bibliographystyle{neurips}

\appendix
\newpage

\section*{Appendix}

\section{Hyperparameter Analysis}
\label{app:analysis}

\subsection{\method}
\label{app:csanalysis}

In this section, we study how the hyperparameters of \method~affect its behavior in terms of sparsity and performance of the produced tickets. More specifically, we consider the following hyperparameters:

\begin{itemize}
    \item Final temperature : the final value for , which controls how close to the original -regularized problem the proxy objective  is.
    \item  penalty : the strength of the  regularization applied to the soft mask , which promotes sparsity.
    \item Mask initial value : the value used to initialize all components of the soft mask , where smaller values promote sparsity.
\end{itemize}

Our setup is as follows. To analyze how each of the 3 hyperparameters impact the performance of \method, we train ResNet-20 on CIFAR-10 (following the same protocol from Section~\ref{sec:resnet}), varying one hyperparameter while keeping the other two fixed. To capture how hyperparameters interact with each other, we repeat the described experiment with different settings for the fixed hyperparameters.

Since different hyperparameter settings naturally yield vastly distinct sparsity and performance for the found tickets, we report relative changes in accuracy and in sparsity.

In Figure~\ref{fig:hyper1}, we vary  between  and  for three different  settings: , , and . As we can see, there is little impact on either the performance or the sparsity of the found ticket, except for the case where  and , for which  yields slightly increased sparsity.

\begin{figure}[!htb]
    \centering
     \includegraphics[width=\linewidth]{newfigs/parameter_lmbda.pdf}
    \caption{Impact on relative test accuracy and sparsity of tickets found in a ResNet-20 trained on CIFAR-10, for different values of  and fixed settings for  and .}
    \label{fig:hyper1}
\end{figure}

Next, we consider the fixed settings , , , and proceed to vary the final inverse temperature  between 50 and 200. Figure~\ref{fig:hyper2} shows the results: in all cases, a larger  of  yields better accuracy. However, it decreases sparsity compared to smaller temperature values for the settings  and , while at the same time increasing sparsity for . While larger  appear beneficial and might suggest that even higher values should be used, note that, the larger  is, the earlier in training the gradients of  will vanish, at which point training of the mask will stop. Since the performance for temperatures between 100 and 200 does not change significantly, we recommend values around 150 or 200 when either pruning or performing ticket search.

\begin{figure}[t]
    \centering
     \includegraphics[width=\linewidth]{newfigs/parameter_temp.pdf}
    \caption{Impact on relative test accuracy and sparsity of tickets found in a ResNet-20 trained on CIFAR-10, for different values of  and fixed settings for  and .}
    \label{fig:hyper2}
\end{figure}

\begin{figure}[t]
    \centering
     \includegraphics[width=\linewidth]{newfigs/parameter_i_mask.pdf}
    \caption{Impact on relative test accuracy and sparsity of tickets found in a ResNet-20 trained on CIFAR-10, for different values of  and fixed settings for  and .}
    \label{fig:hyper3}
\end{figure}

Lastly, we vary the initial mask value  between  and , with hyperpameter settings , , and . Results are given in Figure~\ref{fig:hyper3}: unlike the exploration on  and , we can see that  has a strong and consistent effect on the sparsity of the found tickets. For this reason, we suggest proper tuning of  when the goal is to achieve a specific sparsity value. Since the percentage of remaining weights is monotonically increasing with , we can employ search strategies over values for  to achieve pre-defined desired sparsity levels (\eg binary search). In terms of performance, lower values for  naturally lead to performance degradation, since sparsity quickly increases as  becomes more negative.

\newpage

\subsection{Iterative Magnitude Pruning}
\label{app:impanalysis}

Here, we assess whether the running time of Iterative Magnitude Pruning can be improved by increasing the amount of parameters pruned at each iteration. The goal of this experiment is to evaluate if better tickets (both in terms of performance and sparsity) can be produced by more aggressive pruning strategies.

Following the same setup as the previous section, we train ResNet-20 on CIFAR-10. We run IMP for 30 iterations, performing global pruning with different pruning rates at the end of each iteration. Figure~\ref{fig:hyper4} shows that the performance of tickets found by IMP decays when the pruning rate is increased to . In particular, the final performance of found tickets is mostly monotonically decreasing with the number of remaining parameters, suggesting that, in order to find tickets which outperform the original network, IMP is not compatible with more aggressive pruning rates.

\begin{figure}[!t]
    \centering
    \footnotesize{\textsf{Ticket Search using IMP: ResNet-20 on CIFAR-10}}
    \includegraphics[width=0.9\linewidth]{newfigs/imp_vary_pruning.pdf}
    \caption{Performance of tickets found by Iterative Magnitude Pruning in a ResNet-20 trained on CIFAR-10, for different pruning rates.}
    \label{fig:hyper4}
\end{figure}

\section{Iterative Stochastic Sparsification}
\label{app:iss}

\begin{algorithm}
    \caption{Iterative Stochastic Sparsification (inspired by \citet{deconstructing})}
    \textbf{Input:} Mask init , penalty , number of rounds , iterations per round , rewind point 
    \label{alg:isp}
    \begin{algorithmic}[1]
    \State Initialize , 
    \State Minimize  for  iterations, producing  and 
    \State If , sample  and output 
    \State Otherwise, set ,  for components of  where ,  and go back to step 2, starting a new round
    \end{algorithmic}
\end{algorithm}

Besides comparing our proposed method to Iterative Magnitude Pruning (Algorithm~\ref{alg:imp}), we also design a baseline method, Iterative Stochastic Sparsification (ISS, Algorithm~\ref{alg:isp}), motivated by the procedure in Zhou~\etal~\citet{deconstructing} to find a binary mask  with gradient descent in an end-to-end fashion. More specifically, ISS uses a stochastic re-parameterization  with , and trains  and  jointly with gradient descent and the straight-through estimator~\citep{straightthrough}. Note that the method is also similar to the one proposed by Srinivas~\etal~\cite{l0bernoulli} to prune networks. The goal of this baseline and comparisons is to evaluate whether the deterministic nature of \methodacro's re-parameterization is advantageous when performing sparsification through optimization methods.

When run for multiple iterations, all components of the mask parameters  which have decreased in value from initialization are set to , such that the corresponding weight is permanently removed from the network. While this might look arbitrary, we observe empirically that ISS was unable to remove weights quickly without this step unless  was chosen to be large -- in which case the model's performance decreases in exchange for sparsity.

We also observe that the mask parameters  require different settings in terms of optimization to be successfully trained. In particular, Zhou~\etal~\cite{deconstructing} use SGD with a learning rate of 100 when training , which is orders of magnitude larger than the one used when training CNNs. Our observations are similar, in that typical learning rates on the order of 0.1 cause  to be barely updated during training, which is likely a side-effect of using gradient estimators to obtain update directions for . The following sections present experiments that compare IMP, \methodacro~ and ISS on ticket search tasks.

\section{Supermask Search on a 6-layer CNN}
\label{app:supermask}

\begin{figure*}[!t]
    \centering
    \begin{minipage}[l]{0.49\linewidth}
      \centering
      \includegraphics[width=\linewidth]{newfigs/supermask_acc_per_iteration.pdf}
    \end{minipage}
    \hfill
    \begin{minipage}[l]{0.49\linewidth}
      \centering
      \includegraphics[width=\linewidth]{newfigs/supermasks.pdf}
    \end{minipage}
    \caption{Learning a binary mask with weights frozen at initialization with Stochastic Sparsification (SS, Algorithm \ref{alg:isp} with one iteration) and \method~(\methodacro), on a 6-layer CNN on CIFAR-10. \textbf{Left:} Training curves with hyperparameters for which masks learned by SS and \methodacro~ were both approximately  sparse. \methodacro~ learns the mask significantly faster while attaining similar early-stop performance. \textbf{Right:} Sparsity and test accuracy of masks learned with different settings for SS and {\methodacro}: our method learns sparser masks while maintaining test performance, while SS is unable to successfully learn masks with over  sparsity.}
    \label{fig:supermaskconv6}
\end{figure*}

We train a neural network with 6 convolutional layers on the CIFAR-10 dataset~\citep{cifar}, following Frankle and Carbin~\citet{lth}. The network consists of three blocks of two resolution-preserving convolutional layers followed by  max-pooling, where convolutions in each block have , and  channels, a  kernel, and are immediately followed by ReLU activations. The blocks are followed by fully-connected layers with , and  neurons, with ReLUs in between. The network is trained with Adam~\citep{adam} with a learning rate of  and a batch size of .

As a first baseline, we consider the task of learning a ``supermask'' \citep{deconstructing}: a binary mask  that aims to maximize the performance of a network with randomly initialized weights once the mask is applied. This task is equivalent to pruning a randomly-initialized network since weights are neither updated during the search for the supermask, nor for the comparison between different methods.

We only compare ISS and \methodacro~for this specific experiment: the reason not to consider IMP is that, since the network weights are kept at their initialization values, IMP amounts to removing the weights whose initialization were the smallest. Hence, we compare ISS and \methodacro, where each method is run for a single round composed of  epochs. In this case, where it is run for a single round, ISS is equivalent to the algorithm proposed in Zhou~\etal~\citet{deconstructing} to learn a supermask, referred here as simply Stochastic Sparsification (SS). We control the sparsity of the learned masks by varying  and . All parameters are trained using Adam and a learning rate of , excluding the mask parameters  for SS, for which we adopted SGD with a learning rate of  -- following Zhou~\etal~\cite{deconstructing} and the discussion in the previous section.

Figure~\ref{fig:supermaskconv6} presents results: \methodacro~is capable of finding high performing sparse supermasks (\ie  or less remaining weights while yielding  test accuracy), while SS fails at finding competitive supermasks for sparsity levels above . Moreover, \methodacro~makes faster progress in training, suggesting that not relying on gradient estimators indeed results in better optimization and faster progress when measured in epochs or parameter updates.

\section{Ticket Search on a 6-layer CNN}
\label{app:ticket6cnn}

\begin{figure}[t]
    \centering
    \footnotesize{\textsf{Ticket Search: Conv-6 on CIFAR-10}}
    \includegraphics[width=0.9\linewidth]{newfigs/conv6.pdf}
    \caption{Accuracy and sparsity of tickets produced by IMP, ISS and \methodacro~after re-training, starting from initialization. Tickets are extracted from a Conv-6 network trained on CIFAR-10. Purple curves show individual runs of \methodacro, while green curve connects tickets produced after 4 rounds of CS with varying . Blue and red curves show performance and sparsity of tickets produced by IMP and ISS, respectively. Error bars depict variance across 3 runs.}
    \label{fig:conv6}
\end{figure}

In what follows we compare IMP, ISS and \methodacro~in the task of finding winning tickets on the Conv-6 architecture used in the supermask experiments in Appendix~\ref{app:supermask}. The goal of these experiments is to assess how our deterministic re-parameterization compares to the common stochastic approximations to -regularization~\cite{l0bernoulli, sparsityl0, deconstructing}. Therefore, we run \methodacro~\textbf{with weight rewinding} between rounds, so that we remove any advantages that might be caused by not performing weight rewinding -- in this case, we better isolate the effects caused by our re-parameterization. Following Frankle and Carbin~\cite{lth}, we re-train the produced tickets from their values at initialization (\ie  on each algorithm).

We run IMP and ISS for a total of 30 rounds, each consisting of 40 epochs. Parameters are trained with Adam~\citep{adam} with a learning rate of , following Frankle and Carbin~\citet{lth}. For IMP, we use pruning rates of  for convolutional/dense layers. We initialize the Bernoulli parameters of ISS with , and train them with SGD and a learning rate of , along with a  regularization of . For \methodacro, we train both the weights and the mask with Adam and a learning rate of . Each run of \methodacro~is limited to  rounds, and we perform a total of 16 runs, each with a different value for the mask initialization , from  up to . Runs are repeated with 3 different random seeds so that error bars can be computed.

Figure~\ref{fig:conv6} presents tickets produced by each method, measured by their sparsity and test accuracy when trained from scratch. Even when performing weight rewinding, \methodacro~produces tickets that are significantly superior than the ones found by ISS, both in terms of sparsity and test accuracy, showing that our deterministic re-parameterization is fundamental to finding winning tickets.

\section{Additional Plots for Ticket Search Experiments}
\label{app:additional}

In Section~\ref{sec:resnet}, we compare IMP and \methodacro~in the task of performing ticket search for ResNet-20 trained on CIFAR-10, where \methodacro~was run with 11 different values for  in order to produce tickets with diverse sparsity levels, each run consisting of 5 rounds.







Figures~\ref{fig:extra1} and~\ref{fig:extra2} contain the training curves for each of the 11 settings of  that produce tickets presented in Figure~\ref{fig:tickets} (left). Purple curves show the performance and sparsity of tickets produced after each of the 5 rounds. The accuracy for each ticket is computed by re-training from early-training weights (epoch 2). For each setting, we also execute IMP with a pruning rate per round matching \methodacro, which is presented a blue curve -- note that these runs of IMP are different than the ones in Section~\ref{sec:resnet}, where IMP had a fixed and pre-defined pruning ratio of  per round.

The plots show that \methodacro~not only adjusts the per-round pruning ratio automatically, but it is also superior in terms of what parameters are removed from the network. The bottom right plot of Figure~\ref{fig:extra2} shows curves connecting tickets that are presented in all other plots of Figure~\ref{fig:extra1} and~\ref{fig:extra2} (left), where we can see that \methodacro~produces superior tickets even when IMP adopts a dynamic pruning ratio that matches the one of \methodacro~at each round.

\begin{figure}[H]
\centering
    \begin{tikzpicture}[spy using outlines={rectangle,black,magnification=6.0,width=2.5cm, height=3.5cm, connect spies}]
    \node {\pgfimage[width=0.48\linewidth]{newfigs/icp_fix_resnet_1e-08_200_0.3.pdf}};
    \spy on (-2.7,1.0) in node [left] at (3,0);
    \node[align=center,font=\bfseries, yshift=0em] (title) 
    at (current bounding box.north)
    {};
    \end{tikzpicture}
    \hfill
    \begin{tikzpicture}[spy using outlines={rectangle,black,magnification=6.0,width=2.5cm, height=3.5cm, connect spies}]
    \node {\pgfimage[width=0.48\linewidth]{newfigs/icp_fix_resnet_1e-08_200_0.2.pdf}};
    \spy on (-2.7,1.1) in node [left] at (3,0);
    \node[align=center,font=\bfseries, yshift=0em] (title) 
    at (current bounding box.north)
    {};
    \end{tikzpicture}
    \hfill
    \begin{tikzpicture}[spy using outlines={rectangle,black,magnification=4.0,width=4.5cm, height=2.5cm, connect spies}]
    \node {\pgfimage[width=0.48\linewidth]{newfigs/icp_fix_resnet_1e-08_200_0.1.pdf}};
    \spy on (-2.3,1.1) in node [left] at (3,0.5);
    \node[align=center,font=\bfseries, yshift=0em] (title) 
    at (current bounding box.north)
    {};
    \end{tikzpicture}
    \hfill
    \begin{tikzpicture}[spy using outlines={rectangle,black,magnification=2.5,width=4.0cm, height=2.5cm, connect spies}]
    \node {\pgfimage[width=0.48\linewidth]{newfigs/icp_fix_resnet_1e-08_200_0.05.pdf}};
    \spy on (-2.0,1.1) in node [left] at (3.0,0.5);
    \node[align=center,font=\bfseries, yshift=0em] (title) 
    at (current bounding box.north)
    {};
    \end{tikzpicture}
    \hfill
    \begin{tikzpicture}[spy using outlines={rectangle,black,magnification=2.0,width=3.5cm, height=2.5cm, connect spies}]
    \node {\pgfimage[width=0.48\linewidth]{newfigs/icp_fix_resnet_1e-08_200_0.03.pdf}};
    \spy on (-1.8,1.1) in node [left] at (3,0.5);
    \node[align=center,font=\bfseries, yshift=0em] (title) 
    at (current bounding box.north)
    {};
    \end{tikzpicture}
    \hfill
    \begin{tikzpicture}[spy using outlines={rectangle,black,magnification=2.0,width=3.5cm, height=2.5cm, connect spies}]
    \node {\pgfimage[width=0.48\linewidth]{newfigs/icp_fix_resnet_1e-08_200_0.0.pdf}};
    \spy on (-1.4,1.1) in node [left] at (3,0.5);
    \node[align=center,font=\bfseries, yshift=0em] (title) 
    at (current bounding box.north)
    {};
    \end{tikzpicture}
\caption{Accuracy and sparsity of tickets produced by IMP and \methodacro~after re-training, starting from weights of epoch 2. Tickets were extracted from a ResNet-20 trained on CIFAR-10. Each plot corresponds to different value for the mask initialization  of \methodacro, ranging from  to , with IMP adopting the same pruning rate per round. Ticket performance is given by purple curves when produced by \methodacro, while blue shows performance of IMP and continued IMP (IMP without weight rewinding between rounds).}
\label{fig:extra1}
\end{figure}

\begin{figure}[H]
\centering 
    \begin{tikzpicture}[spy using outlines={rectangle,black,magnification=2.0,width=2.5cm, height=2.5cm, connect spies}]
    \node {\pgfimage[width=0.48\linewidth]{newfigs/icp_fix_resnet_1e-08_200_-0.03.pdf}};
    \spy on (-0.6,1.1) in node [left] at (3,0.5);
    \node[align=center,font=\bfseries, yshift=0em] (title) 
    at (current bounding box.north)
    {};
    \end{tikzpicture}
    \hfill
    \begin{tikzpicture}[spy using outlines={rectangle,black,magnification=2.0,width=2.5cm, height=2.5cm, connect spies}]
    \node {\pgfimage[width=0.48\linewidth]{newfigs/icp_fix_resnet_1e-08_200_-0.05.pdf}};
    \spy on (-0.6,1.1) in node [left] at (3,0.5);
    \node[align=center,font=\bfseries, yshift=0em] (title) 
    at (current bounding box.north)
    {};
    \end{tikzpicture}
    \hfill
    \begin{tikzpicture}[spy using outlines={rectangle,black,magnification=2.0,width=1.5cm, height=3.5cm, connect spies}]
    \node {\pgfimage[width=0.48\linewidth]{newfigs/icp_fix_resnet_1e-08_200_-0.1.pdf}};
    \spy on (0.1,0.9) in node [left] at (3,0.5);
    \node[align=center,font=\bfseries, yshift=0em] (title) 
    at (current bounding box.north)
    {};
    \end{tikzpicture}
    \hfill
    \begin{tikzpicture}[spy using outlines={rectangle,black,magnification=2.0,width=1.5cm, height=3.5cm, connect spies}]
    \node {\pgfimage[width=0.48\linewidth]{newfigs/icp_fix_resnet_1e-08_200_-0.2.pdf}};
    \spy on (1.1,0.3) in node [left] at (3,0.5);
    \node[align=center,font=\bfseries, yshift=0em] (title) 
    at (current bounding box.north)
    {};
    \end{tikzpicture}
    \hfill
    \begin{tikzpicture}[spy using outlines={rectangle,black,magnification=1.5,width=1.5cm, height=3.5cm, connect spies}]
    \node {\pgfimage[width=0.48\linewidth]{newfigs/icp_fix_resnet_1e-08_200_-0.3.pdf}};
    \spy on (2.2,-0.6) in node [left] at (1,0.5);
    \node[align=center,font=\bfseries, yshift=0em] (title) 
    at (current bounding box.north)
    {};
    \end{tikzpicture}
    \hfill
    \begin{tikzpicture}
    \node {\pgfimage[width=0.48\linewidth]{newfigs/Proc_icp.pdf}};
    \end{tikzpicture}
\caption{Accuracy and sparsity of tickets produced by IMP and \methodacro~after re-training, starting from weights of epoch 2. Tickets were extracted from a ResNet-20 trained on CIFAR-10. Each plot corresponds to different value for the mask initialization  of \methodacro, ranging from  to , with IMP adopting the same pruning rate per round. Ticket performance is given by purple curves when produced by \methodacro, while blue shows performance of IMP and continued IMP (IMP without weight rewinding between rounds). The bottom right plot shows performance of tickets produced during runs corresponding to all other plots in Figures \ref{fig:extra1} and \ref{fig:extra2}.}
\label{fig:extra2}
\end{figure}

\section{Sequential Search with \method}
\label{app:seqcs}

\begin{figure}[!t]
    \centering
    \footnotesize{\textsf{Ticket Search with Sequential \method: ResNet-20 on CIFAR-10}}
     \includegraphics[width=0.9\linewidth]{newfigs/sequential_cs.pdf}
    \caption{Accuracy and sparsity of tickets produced by IMP and Sequential \methodacro~after re-training, starting from weights of epoch 2. Tickets are extracted from a ResNet-20 trained on CIFAR-10.}
    \label{fig:sequential}
\end{figure}

There might be cases where the goal is either to find a ticket with a specific sparsity value or to produce a set of tickets with varying sparsity levels in a single run -- tasks that can be naturally performed with a single run of Iterative Magnitude Pruning. However, \method~has no explicit mechanism to control the sparsity of the produced tickets, and, as shown in Section~\ref{sec:resnet} and Appendix~\ref{app:additional}, \methodacro~quickly sparsifies the network in the first few rounds and then roughly maintains the number of parameters during the following rounds until the end of the run. In this scenario, IMP has a clear advantage, as a single run suffices to produce tickets with varying, pre-defined sparsity levels.

Here, we present a sequential variant of \methodacro, named Sequential \method, that removes a fixed fraction of the weights at each round, hence being better suited for the task described above. Unlike IMP, this sequential form of CS removes the weights with lowest mask values  -- note the difference from \methodacro, which, given a large enough temperature , removes \emph{all} weights whose corresponding mask parameters are negative.

Following the same experimental protocol from Section~\ref{sec:resnet}, we again perform ticket search on ResNet-20 trained on CIFAR-10.  We run Sequential \method~and Iterative Magnitude Pruning for a total of 30 rounds each, and with a pruning rate of  per round. Note that unlike the experiments with \method~(the non-sequential form), we perform a single run with , \ie no hyperparameters are used to control the sparsity of the produced tickets.

Figure~\ref{fig:sequential} shows the performance of tickets produced by Sequential \methodacro~and IMP, indicating that \methodacro~might be a competitive method in the sequential search setting. Note that the performance of the tickets produced by Sequential \methodacro~is considerably inferior to those found by \methodacro~(refer to Section \ref{sec:resnet}, Figure \ref{fig:tickets}). Although these results are promising, additional experiments would be required to more thoroughly evaluate the potential of Sequential \method~and its comparison to Iterative Magnitude Pruning.

\section{Learned Sparsity Structure}
\label{app:sparsities}

\begin{figure}[!t]
    \centering
    \footnotesize{\textsf{Learned Sparsity Patterns in VGG on CIFAR-10}}
     \includegraphics[width=1.0\linewidth]{newfigs/nowd_vggfinal.pdf}
    \caption{Sparsity patterns learned by \methodacro~and IMP for VGG-16 trained on CIFAR-10 -- each block consists of 2 non-overlapping consecutive layers of VGG.}
    \label{fig:learnedsparsities}
\end{figure}

To see how \methodacro~differs from magnitude pruning in terms of which layers are more heavily pruned by each method, we force the two to prune VGG to the same sparsity level in a single round. We first run \methodacro~with , yielding  sparsity, and then run IMP with global pruning rate of , producing a sub-network with the same number of parameters.

Figure~\ref{fig:learnedsparsities} shows the final sparsity of blocks consisting of two consecutive convolutional layers (8 blocks total since VGG has 16 convolutional layers). \methodacro~applies a pruning rate that is roughly twice as aggressive as IMP to the first blocks. Both methods heavily sparsify the widest layers of VGG (blocks 5 to 8), while still achieving over  test accuracy. More heavily pruning earlier layers in CNNs can offer inference speed benefits: due to the increased spatial size of earlier layers' inputs, each weight is used more times and has a larger contribution in terms of FLOPs.
 
\end{document}
