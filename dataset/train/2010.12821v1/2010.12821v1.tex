
\documentclass{article} \usepackage{iclr2021_conference,times}



\usepackage{amsmath,amsfonts,bm}
\usepackage{todonotes}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}

\usepackage{graphicx}

\usepackage{tabularx}

\usepackage{latexsym}
\usepackage{multirow}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{xspace}
\usepackage{amssymb}

\usepackage{booktabs}

\newcommand{\commentfn}[1]{}
\newcommand{\eout}{E_{\textrm{out}}}
\newcommand{\ein}{E_{\textrm{in}}}
\renewcommand{\commentfn}[1]{#1} \newcommand{\hwc}[1]{\textcolor{blue} {[\textsc{hwc}: #1]}}
\newcommand{\sr}[1]{\textcolor{olive} {[\textsc{sr}: #1]}}
\newcommand{\mj}[1]{\textcolor{orange} {[\textsc{mj}: #1]}}

\newcommand{\xtreme}{\textsc{xtreme}\xspace}

\title{Rethinking embedding coupling\\in pre-trained language models}



\author{Hyung Won Chung\thanks{equal contribution}\, \thanks{ Work done as a member of the Google AI Residency Program.} \\ Google Research \\ \texttt{hwchung@google.com} \And  Thibault F\'evry\footnotemark[1]\, \footnotemark[2] \\ \texttt{thibaultfevry@gmail.com} \hspace{101pt} \\
\And Henry Tsai \\ Google Research \\ \texttt{henrytsai@google.com} \And Melvin Johnson \\
Google Research \\
\texttt{melvinp@google.com} \\
\And
Sebastian Ruder \\
DeepMind \\
\texttt{ruder@google.com} \\
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
We re-evaluate the standard practice of sharing weights between input and output embeddings in state-of-the-art pre-trained language models. We show that decoupled embeddings provide increased modeling flexibility, allowing us to significantly improve the efficiency of parameter allocation in the input embedding of multilingual models. By reallocating the input embedding parameters in the Transformer layers, we achieve dramatically better performance on standard natural language understanding tasks with the same number of parameters during fine-tuning.
We also show that allocating additional capacity to the output embedding provides benefits to the model that persist through the fine-tuning stage even though the output embedding is discarded after pre-training. 
Our analysis shows that larger output embeddings prevent the model's last layers from overspecializing to the pre-training task and encourage Transformer representations to be more general and more transferable to other tasks and languages.
Harnessing these findings, we are able to train models that achieve strong performance on the \xtreme benchmark without increasing the number of parameters at the fine-tuning stage. 


\end{abstract}

\section{Introduction}

The performance of models in natural language processing (NLP) has dramatically improved in recent years, mainly driven by advances in transfer learning from large amounts of unlabeled data \citep{Howard2018,Devlin2019}. The most successful paradigm consists of pre-training a large Transformer \citep{Vaswani2017} model with a self-supervised loss and fine-tuning it on data of a downstream task \citep{ruder2019transfer}. Despite its empirical success, inefficiencies have been observed related to the training duration \citep{Liu2019roberta}, pre-training objective \citep{Clark2020electra}, and training data \citep{Conneau2020}, among others. In this paper, we reconsider a modeling assumption that may have a similarly pervasive practical impact: the coupling of input and output embeddings\footnote{Output embedding is sometimes referred to as ``output weights", i.e., the weight matrix in the output projection in a language model.} in state-of-the-art pre-trained language models.





State-of-the-art pre-trained language models \citep{Devlin2019,Liu2019roberta} and their multilingual counterparts \citep{Devlin2019,Conneau2020} have inherited the practice of embedding coupling from their language model predecessors \citep{Press2017,Inan2017}. However, in contrast to their language model counterparts, embedding coupling in encoder-only pre-trained models such as \citet{Devlin2019} is only useful during pre-training since output embeddings are generally discarded after fine-tuning.\footnote{We focus on encoder-only models, and do not consider encoder-decoder models like T5~\citep{Raffel2020} where none of the embedding matrices are discarded after pre-training. Output embeddings may also be useful for domain-adaptive pre-training \citep{Howard2018,Gururangan2020dontstop}, probing \citep{Elazar2019olmpics}, and tasks that can be cast in the pre-training objective \citep{amrami2019towards}.} In addition, given the willingness of researchers to exchange additional compute during pre-training for improved downstream performance \citep{Raffel2020,Brown2020} and the fact that pre-trained models are often used for inference millions of times \citep{Wolf2019transformers}, pre-training-specific parameter savings are less important overall.

On the other hand, tying input and output embeddings constrains the model to use the same dimensionality for both embeddings. 
This restriction limits the researcher's flexibility in parameterizing the model and can lead to allocating too much capacity to the input embeddings, which may be wasteful.
This is a problem particularly for multilingual models, which require large vocabularies with high-dimensional embeddings that make up between 47--71\% of the entire parameter budget (Table \ref{table:transformer_models_embedding_fraction}), suggesting an inefficient parameter allocation.


\begin{table*}[t]
\caption{Overview of the number of parameters in (coupled) embedding matrices of state-of-the-art multilingual (top) and monolingual (bottom) models with regard to overall parameter budget. : vocabulary size. , : number of parameters in total and in the embedding matrix respectively.
}
\label{table:transformer_models_embedding_fraction}
\begin{center}
\begin{tabular}{lrrrrr}
\toprule
\textbf{Model} &
\multicolumn{1}{c}{Languages} &
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{} &
\multicolumn{1}{c}{\%Emb.} \\
\midrule
mBERT \citep{Devlin2019} & 104 & 120k & 178M &  92M &  52\% \\
 \citep{Conneau2020} &   100 & 250k & 270M & 192M &  71\% \\
 \citep{Conneau2020} &   100 & 250k & 550M & 256M &  47\% \\
\midrule
 \citep{Devlin2019} & 1 & 30k & 110M & 23M & 21\% \\
 \citep{Devlin2019} & 1 &  30k & 335M &  31M &   9\% \\
\bottomrule
\end{tabular}
\end{center}
\end{table*}

In this paper, we systematically study the impact of embedding coupling on state-of-the-art pre-trained language models, focusing on multilingual models.
First, we observe that while na\"ively decoupling the input and output embedding \emph{parameters} does not consistently improve downstream evaluation metrics, decoupling their \emph{shapes} comes with a host of benefits. In particular, it allows us to independently modify the input and output embedding dimensions. We show that the input embedding dimension can be safely reduced without affecting downstream performance. Since the output embedding is discarded after pre-training, we can increase its dimension, which improves fine-tuning accuracy and outperforms other capacity expansion strategies. By reinvesting saved parameters to the width and depth of the Transformer layers, we furthermore achieve significantly improved performance over a strong mBERT \citep{Devlin2019} baseline on multilingual tasks from the \xtreme benchmark \citep{Hu2020}. Finally, we combine our techniques in a Rebalanced mBERT (RemBERT) model that outperforms XLM-R \citep{Conneau2020}, the state-of-the-art cross-lingual model while having been pre-trained on  fewer tokens and 10 more languages.






We thoroughly investigate reasons for the benefits of embedding decoupling. We observe that an increased output embedding size enables a model to improve on the pre-training task, which correlates with downstream performance. We also find that it leads to Transformers that are more transferable across tasks and languages---particularly for the upper-most layers. Overall, larger output embeddings prevent the model's last layers from over-specializing to the pre-training task \citep{Zhang2020,Tamkin2020}, which enables training of more general Transformer models.







































\section{Related work}
\label{sec:related_work}

\paragraph{Embedding coupling} Sharing input and output embeddings in neural language models was proposed to improve perplexity and motivated based on embedding similarity \citep{Press2017} as well as by theoretically showing that the output probability space can be constrained to a subspace governed by the embedding matrix for a restricted case \citep{Inan2017}. Embedding coupling is also common in neural machine translation models where it reduces model complexity \citep{Firat2016} and saves memory \citep{Johnson2017}, in recent state-of-the-art language models \citep{Melis2020mogrifier}, as well as all pre-trained models we are aware of \citep{Devlin2019,Liu2019roberta}.

\paragraph{Transferability of representations} Representations of large pre-trained models in computer vision and NLP have been observed to transition from general to task-specific from the first to the last layer \citep{yosinski2014transferable,Howard2018,Liu2019transferability}. In Transformer models, the last few layers have been shown to become specialized to the MLM task and---as a result---less transferable \citep{Zhang2020,Tamkin2020}.

\paragraph{Multilingual models} Recent multilingual models are pre-trained on data covering around 100 languages using a subword vocabulary shared across all languages \citep{Devlin2019,Pires2019,Conneau2020}. In order to achieve reasonable performance for most languages, these models need to allocate sufficient capacity for each language, known as the curse of multilinguality \citep{Conneau2020,Pfeiffer2020mad-x}. As a result, such multilingual models have large vocabularies with large embedding sizes to ensure that tokens in all languages are adequately represented. 

\paragraph{Efficient models} Most work on more efficient pre-trained models focuses on pruning or distillation \citep{Hinton2015}. Pruning approaches remove parts of the model, typically attention heads \citep{Michel2019,Voita2019} while distillation approaches distill a large pre-trained model into a smaller one \citep{Sun2020mobilebert}. Distillation can be seen as an alternative form of allocating pre-training capacity via a large teacher model. However, distilling a pre-trained model is expensive \citep{Sanh2019distilbert} and requires overcoming architecture differences and balancing training data and loss terms \citep{Mukherjee2020xtremedistil}. Our proposed methods are simpler and complementary to distillation as they can improve the pre-training of compact student models \citep{Turc2019well-read}.









\section{Experimental methodology}
\label{sec:experiments}

Efficiency of models has been measured along different dimensions, from the number of floating point operations \citep{Schwartz2019greenai} to their runtime \citep{Zhou2020hulk}. We follow previous work \citep{Sun2020mobilebert} and compare models in terms of their number of parameters during fine-tuning (see Appendix \ref{app:efficiency_comparison} for further justification of this setting). For completeness, we generally report the number of pre-training (PT) and fine-tuning (FT) parameters.







\paragraph{Baseline} Our baseline has the same architecture as multilingual BERT \citep[mBERT;][]{Devlin2019}. It consists of 12 Transformer layers with a hidden size  of 768 and 12. Input and output embeddings are coupled and have the same dimensionality  as the hidden size, i.e. . The total number of parameters during pre-training and fine-tuning is 177M (see Appendix \ref{app:baseline_model} for further details). We train variants of this model that differ in certain hyper-parameters but otherwise are trained under the same conditions to ensure a fair comparison.

\paragraph{Tasks} For our experiments, we employ tasks from the \xtreme benchmark~\citep{Hu2020} that require fine-tuning, including the XNLI \citep{Conneau2018xnli}, NER \citep{Pan2017}, PAWS-X \citep{Yang2019paws-x}, XQuAD \citep{artetxe2020cross}, MLQA \citep{Lewis2020mlqa}, and TyDiQA-GoldP \citep{Clark2020tydiqa} datasets. We provide details for them in Appendix \ref{app:xtreme_tasks}. We average results across three fine-tuning runs and evaluate on the dev sets unless otherwise stated. 

\section{Embedding decoupling revisited}
\label{sec:embedding_decoupling_revisited}











\paragraph{Na\"ive decoupling} Embeddings make up a large fraction of the parameter budget in state-of-the-art multilingual models (see Table \ref{table:transformer_models_embedding_fraction}). We now study the effect of embedding decoupling on such models. In Table~\ref{table:coupled_vs_decoupled}, we show the impact of decoupling the input and output embeddings in our baseline model with coupled embeddings. Na\"ively decoupling the output embedding matrix slightly improves the performance as evidenced by a 0.4 increase on average. However, the gain is not uniformly observed in all tasks.
Overall, these results suggest that decoupling the embedding matrices na\"ively while keeping the dimensionality fixed does not greatly affect the performance of the model. What is more important, however, is that decoupling the input and output embeddings decouples the \emph{shapes}, endowing significant modeling flexibility, which we investigate in the following.




\begin{table*}[t]
\caption{Effect of decoupling the input and output embedding matrices on performance on multiple tasks in \xtreme. PT: Pre-training. FT: Fine-tuning.}
\label{table:coupled_vs_decoupled}
\begin{center}
\resizebox{\textwidth}{!}{\begin{tabular}{lcccccccccc}
\toprule
 & \# PT & \# FT & & XNLI & NER & PAWS-X & XQuAD & MLQA & TyDi-GoldP & \multirow{2}{*}{Avg} \\
 & params & params & & Acc & F1 & Acc & EM/F1 & EM/F1 & EM/F1 \\
\midrule
Coupled & 177M & 177M & & 70.7 & \textbf{69.2} & \textbf{85.3} & 46.2/63.2 & \textbf{37.3/53.1} & 40.7/56.7 & 62.3 \\
Decoupled & 269M & 177M & & \textbf{71.3} & 68.9 & 85.0 & \textbf{46.9/63.8} & \textbf{37.3/53.1} & \textbf{42.8/58.1} & \textbf{62.7} \\
\bottomrule
\end{tabular}
}
\end{center}
\end{table*}



\paragraph{Input vs output embeddings} Decoupling input and output embeddings allows us to flexibly change the dimensionality of both matrices and to determine which one is more important for good transfer performance of the model. To this end, we compare the performance of a model with  to that of a model with \footnote{We linearly project the embeddings from  to  and from  to .}. During fine-tuning, the latter model has 43\% fewer parameters. We show the results in Table~\ref{table:input_vs_output_embeddings}. Surprisingly, the model pre-trained with a larger output embedding size slightly outperforms the comparison method on average despite having 77M fewer parameters during fine-tuning.\footnote{We observe the same trend if we control for the number of \emph{trainable parameters} during fine-tuning by freezing the input embedding parameters.}





Reducing the input embedding dimension saves a significant number of parameters at a noticeably smaller cost to accuracy than reducing the output embedding size. In light of this, the parameter allocation of multilingual models (see Table \ref{table:transformer_models_embedding_fraction}) seems particularly inefficient.
For a multilingual model with coupled embeddings, reducing the input embedding dimension to save parameters as proposed by \citet{Lan2020} is very detrimental to performance (see Appendix \ref{app:lan_comparison} for details). 






The results in this section indicate that the output embedding plays an important role in the transferability of pre-trained representations. For multilingual models in particular, a small input embedding dimension frees up a significant number of parameters at a small cost to performance. In the next section, we study how to improve the performance of a model by resizing embeddings and layers.

\begin{table*}[t]
\caption{Performance of models with a large input and small output embedding size and vice versa.}
\label{table:input_vs_output_embeddings}
\begin{center}
\resizebox{\textwidth}{!}{\begin{tabular}{lcccccccccc}
\toprule
 & \# PT & \# FT & & XNLI & NER & PAWS-X & XQuAD & MLQA & TyDi-GoldP & \multirow{2}{*}{Avg} \\
 & params & params & & Acc & F1 & Acc & EM/F1 & EM/F1 & EM/F1 \\
\midrule
 & 192M & 177M &  & 70.0 & \textbf{68.3} & 84.3 & 42.0/\textbf{60.8} & \textbf{34.7/50.9} & 35.2/\textbf{52.2} & 60.1 \\
 & 192M & 100M &  &\textbf{70.4} & 67.6 & \textbf{84.9} & \textbf{43.9}/60.0 & 34.6/49.5 & \textbf{37.8}/51.0 & \textbf{60.2} \\
\bottomrule
\end{tabular}
}
\end{center}
\end{table*}

































































\section{Embedding and layer resizing for more efficient fine-tuning}






\paragraph{Increasing the output embedding size}
In~\S\ref{sec:embedding_decoupling_revisited}, we observed that reducing  hurts performance on the fine-tuning tasks, suggesting  is important for transferability. Motivated by this result, we study the opposite scenario, i.e., whether increasing  beyond  improves the performance. We experiment with an output embedding size  in the range \{128, 768, 3072\} while keeping the input embedding size  and all other parts of the model the same.





We show the results in Table~\ref{table:effect_of_E_out}. In all of the tasks we consider, increasing  monotonically improves the performance. The improvement is particularly impressive for the more complex question answering datasets. It is important to note that during fine-tuning, all three models have \emph{the exact same sizes} for  and . The only difference among them is the output embedding, which is discarded after pre-training. These results show that the effect of additional capacity during pre-training persists through the fine-tuning stage even if the added capacity is discarded after pre-training. We perform an extensive analysis on this behavior in~\S\ref{sec:analysis}. We show results with an English  model in Appendix \ref{app:english_results}, which show the same trend. 




\begin{table*}[t]
\caption{Effect of an increased output embedding size  on tasks in \xtreme (). 
}
\label{table:effect_of_E_out}
\begin{center}
\resizebox{\textwidth}{!}{\begin{tabular}{lcccccccccc}
\toprule
 & \# PT & \# FT & & XNLI & NER & PAWS-X & XQuAD & MLQA & TyDi-GoldP & \multirow{2}{*}{Avg} \\
 & params & params & & Acc & F1 & Acc & EM/F1 & EM/F1 & EM/F1 \\
\midrule
 & 115M & 100M & & 68.1 & 65.2 & 83.3 & 38.6/54.8 & 30.9/45.2 & 32.2/44.2 & 56.6 \\
 & 192M & 100M & & 70.4 & 67.6 & 84.9 & 43.9/60.0 & 34.6/49.5 & 37.8/51.0 & 60.2 \\
 & 469M & 100M & & \textbf{71.1} & \textbf{68.1} & \textbf{85.1} & \textbf{45.3/63.3} & \textbf{37.2/53.1} & \textbf{39.4/54.7} & \textbf{61.8} \\
\bottomrule
\end{tabular}
}
\end{center}
\end{table*}







\paragraph{Adding capacity via layers} We investigate alternative ways of adding capacity during pre-training such as increasing the number of layers and discarding them after pre-training.
For a fair comparison with the  model, we add 11 additional layers (total of 23) and drop the 11 upper layers after pre-training. This setting ensures that both models have the same pre-training and fine-tuning parameters. We show the results in Table~\ref{table:additional_layer}. The model with additional layers performs poorly on the question answering tasks, likely because the top layers contain useful semantic information \citep{Tenney2019}. 
In addition to higher performance, increasing  relies only a more expensive dense matrix multiplication, which is highly optimized on typical accelerators and can be scaled up more easily with model parallelism~\citep{Shazeer2018} because of small additional communication cost.
We thus focus on increasing  to expand pre-training capacity and leave an exploration of alternative strategies to future work.




\begin{table*}[t]
\caption{Effect of additional capacity via more Transformer layers during pre-training ().}
\label{table:additional_layer}
\begin{center}
\resizebox{\textwidth}{!}{\begin{tabular}{lcccccccccc}
\toprule
 & \# PT & \# FT & & XNLI & NER & PAWS-X & XQuAD & MLQA & TyDi-GoldP & \multirow{2}{*}{Avg} \\
 & params & params & & Acc & F1 & Acc & EM/F1 & EM/F1 & EM/F1 \\
\midrule
 & 192M & 100M & & 70.4 & \textbf{67.6} & 84.9 & \textbf{43.9/60.0} & \textbf{34.6/49.5} & \textbf{37.8/51.0} & \textbf{60.2} \\
11 add. layers & 193M & 100M & & \textbf{71.2} & 67.3 & \textbf{85.0} & 38.8/55.5 & 31.4/46.6 & 31.3/45.5 & 58.0 \\
\bottomrule
\end{tabular}
}
\end{center}
\end{table*}

\paragraph{Reinvesting input embedding parameters} Reducing  from 768 to 128 reduces the number of parameters from 177M to 100M. We redistribute these 77M parameters for the model with  to add capacity where it might be more useful by increasing the width or depth of the model. Specifically, we 1) increase the hidden dimension  of the Transformer layers from 768 to 1024\footnote{We choose 1024 dimensions to optimize efficient use of our accelerators.} and 2) increase the number of Transformer layers () from 12 to 23 at the same  to obtain models with similar number of parameters during fine-tuning. 



Table~\ref{table:reinvest} shows the results for these two strategies. Reinvesting the input embedding parameters in both  and  improves performance on all tasks while increasing the number of Transformer layers  results in the best performance, with an average improvement of 3.9 over the baseline model with coupled embeddings and the same number of fine-tuning parameters overall.






\begin{table*}[t]
\caption{Effect of reinvesting the input embedding parameters to increase the hidden dimension  and number  of Transformer layers on \xtreme tasks.   model is included for an ablation study.}
\label{table:reinvest}
\begin{center}
\resizebox{\textwidth}{!}{\begin{tabular}{lcccccccccc}
\toprule
 & \# PT & \# FT & & XNLI & NER & PAWS-X & XQuAD & MLQA & TyDi-GoldP & \multirow{2}{*}{Avg} \\
 & params & params & & Acc & F1 & Acc & EM/F1 & EM/F1 & EM/F1 \\
\midrule
Baseline & 177M & 177M & & 70.7 & 69.2 & 85.3 & 46.2/63.2 & 37.3/53.1 & 40.7/56.7 & 62.3 \\ \midrule
 & 192M & 100M & & 70.4 & 67.6 & 84.9 & 43.9/60.0 & 34.6/49.5 & 37.8/51.0 & 60.2 \\
Reinvested in  & 260M & 168M & & 72.8 & 69.2 & 85.6 & 50.2/67.2 & 40.7/56.4 & 44.8/60.0 & 64.5 \\
Reinvested in  & 270M & 178M & & \textbf{73.6} & \textbf{71.0} & \textbf{86.7} & \textbf{51.7/68.8} & \textbf{42.4/58.2} & \textbf{48.2/62.9} & \textbf{66.2} \\
\bottomrule
\end{tabular}
}
\end{center}
\end{table*}









\paragraph{A rebalanced mBERT} We finally combine and scale up our techniques to design a rebalanced mBERT model that outperforms the current state-of-the-art unsupervised model, XLM-R \citep{Conneau2020}.
As the performance of Transformer-based models strongly depends on their number of parameters \citep{Raffel2020}, we propose a Rebalanced mBERT (RemBERT) model that matches XLM-R's number of fine-tuning parameters (559M) while using a reduced embedding size, resized layers, and more effective capacity during pre-training. The model has a vocabulary size of 250k, , , and 32 layers with 1152 dimensions and 18 attention heads per layer and was trained on data covering 110 languages. We provide further details in Appendix \ref{app:rembert}.

We compare RemBERT to XLM-R and the best-performing models on the \xtreme leaderboard in Table \ref{table:full_model} (see Appendix \ref{app:full_task_results} for the per-task results).\footnote{We do not consider retrieval tasks as they require intermediate task data \citep{phang2020english}.} The models in the first three rows use additional task or translation data for fine-tuning, which significantly boosts performance \citep{Hu2020}. XLM-R and RemBERT are the only two models that are fine-tuned using only the English training data of the corresponding task. XLM-R was trained with a batch size of  sequences each with  tokens and 1.5M steps (total of 6.3T tokens). In comparison, RemBERT is trained with  sequences of  tokens for 1.76M steps (1.8T tokens). Even though it was trained with  fewer tokens and has 10 more languages competiting for the model capacity, RemBERT outperforms XLM-R on all tasks we considered. This strong result suggests that our proposed methods are also effective at scale.
We will release the pre-trained model checkpoint and the source code for RemBERT in order to promote reproducibility and share the pre-training cost with other researchers.






\begin{table*}[t]
\caption{Comparison of our model to other models on the \xtreme leaderboard. Details about VECO are due to communication with the authors.}
\label{table:full_model_avg}
\begin{center}
\resizebox{\textwidth}{!}{\begin{tabular}{lcccccccccc}
\toprule
 & \multirow{3}{*}{\shortstack[l]{\# PT\\params}} & \multirow{3}{*}{\shortstack[l]{\# FT\\params}} & & \multirow{3}{*}{\shortstack[l]{Add.\\task\\data}} & \multirow{3}{*}{\shortstack[l]{Trans-\\lation\\data}} &  & Sentence-pair & Structured & Question & \\
 &  & & Langs & & & & Classification & Prediction & Answering & Avg \\
 & & & & & & & Acc & F1 & EM/F1 & \\
\midrule
\multicolumn{9}{l}{\emph{Models fine-tuned on translations or additional task data}} \\ \midrule
STiLTs \citep{phang2020english} & 559M & 559M & 100 & \checkmark & & & 83.9 & 69.4 & 67.2 & 73.5 \\
FILTER \citep{Fang2020filter}   & 559M & 559M & 100 & & \checkmark & & 87.5 & 71.9 & 68.5 & 76.0 \\
VECO \citep{anonymous2021veco}  & 662M & 662M & 50  & & \checkmark & & 87.0 & 70.4 & 68.0 & 75.1 \\ 
\midrule
\multicolumn{9}{l}{\emph{Models fine-tuned only on English task data}} \\ \midrule
XLM-R \citep{Conneau2020}       & 559M & 559M & 100 & & & & 82.8 & 69.0 & 62.3 & 71.4 \\
RemBERT (ours)                  & 995M & 575M & 110 & & & &\textbf{84.2} & \textbf{73.3} & \textbf{68.6} & \textbf{75.4} \\
\bottomrule
\end{tabular}
}
\end{center}
\end{table*}





\section{On the importance of the output embedding size}
\label{sec:analysis}

We carefully design a set of experiments to analyze the impact of an increased output embedding size on various parts of the model. 
We study the nature of the decoupled input and output representations (\textsection \ref{sec:weat}) and the transferability of the Transformer layers with regard to task-specific (\textsection \ref{sec:transferability}) and language-specific knowledge (\textsection \ref{sec:cross-lingual-transfer}).



\subsection{Nature of input and output embedding representations}
\label{sec:weat}



We first investigate to what extent the representations of decoupled input and output embeddings differ based on word embedding association tests~\citep{WEAT_tests}. Similar to~\citep{Press2017}, for a given pair of words, we evaluate the correlation between human similarity judgements of the strength of the relationship and the dot product of the word embeddings. We evaluate on MEN \citep{bruni2014multimodal}, MTurk771 \citep{halawi2012large}, Rare-Word \citep{luong2013better}, SimLex999 \citep{hill2015simlex}, and Verb-143 \citep{baker2014unsupervised}. As our model uses subwords, we average the token representations for words with multiple subwords.





We show the results in Table~\ref{table:weat}. In the first two rows, we can observe that the input embedding of the decoupled model performs similarly to the embeddings of the coupled model while the output embeddings have lower scores.\footnote{This is opposite from what \citet{Press2017} observed in 2-layer LSTMs. They find that performance of the output embedding is similar to the embedding of a coupled model. This difference is plausible as the information encoded in large Transformers changes significantly throughout the model \citep{Tenney2019}.} We note that higher scores are not necessarily desirable as they only measure how well the embedding captures semantic similarity at the lexical level. Focusing on the \textit{difference} in scores, we can observe that the input embedding learns representations that capture semantic similarity in contrast to the decoupled output embedding. At the same time, the decoupled model achieves higher performance in masked language modeling.

\begin{table*}[t]
\caption{Results on word embedding association tests for the input (I) and output (O) embeddings of models (left) and the models' masked language modeling performance (right). The first two rows show the performance of coupled and decoupled embeddings with the same embedding size . The last three rows show the performance as we increase the output embedding size with .}
\label{table:weat}
\begin{center}
\resizebox{5.5in}{!}{\begin{tabular}{lcccccccccc}
\toprule
 & \multicolumn{2}{c}{MEN} & \multicolumn{2}{c}{MTurk771} & \multicolumn{2}{c}{Rare-Word} & \multicolumn{2}{c}{Simlex999} & \multicolumn{2}{c}{Verb-143} \\
 & I & O & I & O & I & O & I & O & I & O \\
\midrule
Coupled & \multicolumn{2}{c}{40.8} & \multicolumn{2}{c}{37.5} & \multicolumn{2}{c}{25.0} & \multicolumn{2}{c}{20.1} & \multicolumn{2}{c}{56.0}\\
Decoupled & 39.2 & 27.7 & 37.5 & 24.3 & 24.0 & 12.2 & 17.6 & 16.1 & 59.4 & 43.9 \\
\midrule
 & 40.7 & 36.6 & 37.7 & 32.8 & 23.6 & 16.4 & 17.5 & 17.3 & 48.9 & 46.4 \\
 & 38.6 & 27.8 & 35.2 & 23.9 & 22.6 & 11.5 & 19.7 & 15.6 & 50.6 & 45.5 \\
 & 40.1 & 10.8 & 36.2 & 8.8 & 22.6 & -1.2 & 18.9 & 13.0 & 43.3 & 19.5 \\
\bottomrule
\end{tabular}
\quad
\begin{tabular}{lc}
\toprule
 & \multirow{2}{*}{MLM acc.} \\
 & \\
\midrule
Coupled & 61.1 \\
Decoupled & 61.6 \\
\midrule
 & 59.0 \\
 & 60.7 \\
 & 62.3 \\
\bottomrule
\end{tabular}
}
\end{center}
\end{table*}



The last three rows of Table~\ref{table:weat} show that as  increases, the difference in the input and output embedding increases as well. With additional capacity, the output embedding progressively learns representations that differ more significantly from the input embedding. We also observe that the MLM accuracy increases with . Collectively, the results in Table~\ref{table:weat} suggest that with increased capacity, the output embeddings learn representations that are worse at capturing traditional semantic similarity (which is purely restricted to the lexical level) while being more specialized to the MLM task (which requires more contextual representations). Decoupling embeddings thus give the model the flexibility to avoid encoding relationships in its output embeddings that may not be useful for its pre-training task.  As pre-training performance correlates well with downstream performance \citep{Devlin2019}, forcing output embeddings to encode lexical information can hurt the latter.











\subsection{Cross-task Transferability of Transformer layer representations}  \label{sec:transferability}



We investigate to what extent more capacity in the output embeddings during pre-training reduces the MLM-specific burden on the Transformer layers and hence prevents them from over-specializing to the MLM task.









\paragraph{Dropping the last few layers} We first study the impact of an increased output embedding size on the transferability of the last few layers. Previous work \citep{Zhang2020,Tamkin2020} randomly reinitialized the last few layers to investigate their transferability. However, those parameters are still present during fine-tuning. We propose a more aggressive pruning scheme where we completely remove the last few layers. This setting demonstrates more drastically whether a model's upper layers are over-specialized to the pre-training task by assessing whether performance can be improved with millions fewer parameters.\footnote{Each Transformer layer with  has about 7.1M parameters.}



We show the performance of models with 8--12 remaining layers (removing up to 4 of the last layers) for different output embedding sizes  on XNLI in Figure~\ref{fig:drop_last_layers}. For both  and , removing the last layer improves performance. In other words, the model performs better even with 7.1M fewer parameters. With , the performance remains similar when removing the last few layers, which suggests that the last few layers are not critical for transferability. 


As we increase , the last layers become more transferable. With , removing more than one layer results in a sharp reduction in performance. Finally when , every layer is useful and removing any layer worsens the performance. This analysis demonstrates that increasing  improves the transferability of the representations learned by the last few Transformer layers.







\paragraph{Probing analysis} We further study whether an increased output embedding size improves the general natural language processing ability of the Transformer. We employ the probing analysis of~\citet{Tenney2019} and the \texttt{mix} probing strategy where a 2-layer dense network is trained on top of a weighted combination of the 12 Transformer layers. We evaluate performance with regard to core NLP concepts including part-of-speech tagging (POS), constituents (Consts.), dependencies (Deps.), entities, semantic role labeling (SRL), coreference (Coref.), semantic proto-roles (SPR), and relations (Rel.). For a thorough description of the task setup, see~\citet{Tenney2019}.\footnote{The probing tasks are in English while our encoder is multilingual.}

\begin{figure}[!t]
    \centering
    \begin{minipage}[t]{0.466\linewidth}
        \centering
        \includegraphics[width=6.5cm]{Figures/drop_last_layers.pdf}
        \caption{XNLI accuracy with the last layers removed. Larger  improves transferability.}
        \label{fig:drop_last_layers}
    \end{minipage}
    \hspace{2mm}
    \begin{minipage}[t]{0.475\linewidth}
        \centering
        \includegraphics[width=6.5cm]{Figures/nn_acc.pdf}
\caption{Nearest-neighbor English-to-German translation accuracy of each layer.}
        \label{fig:nn_translation}
    \end{minipage}
\label{fig:invertible-adapter-variants}
\end{figure}

We show the results of the probing analysis in Table~\ref{table:probing}. As we increase , the model improves across all tasks, even though the number of parameters is the same. This demonstrates that increasing  enables the Transformer layers to learn more general representations.\footnote{In \citep{Tenney2019}, going from a BERT-base to a BERT-large model (with  more parameters) improves performance on average by 1.1 points, compared to our improvement of 0.5 points without increasing the number of fine-tuning parameters.}


\begin{table*}[t]
\caption{Probing analysis of~\citet{Tenney2019} with \texttt{mix} strategy.}
\label{table:probing}
\begin{center}
\resizebox{5.5in}{!}{\begin{tabular}{lcccccccccccccc}
\toprule
& \# PT params & \# FT params & & POS & Const. & Deps. & Entities & SRL & Coref. O & Coref. W & SPR1 & SPR2 & Rel. & Avg \\
\midrule
 & 115M & 100M & & 96.7 & 87.9 & 94.3 & 93.7 & 91.7 & 95.0 & 67.2 & 83.0 & 82.7 & 77.0 & 86.9 \\
 & 192M & 100M & & 96.7 & 87.9 & 94.4 & 94.0 & 91.8 & 95.0 & 67.0 & 83.1 & \textbf{82.8} & 78.6 & 87.1 \\
 & 469M & 100M & & \textbf{96.8} & \textbf{88.0} & \textbf{94.5} & \textbf{94.2} & \textbf{92.0} & \textbf{95.3} & \textbf{67.6} & \textbf{84.1} & 82.6 & \textbf{78.9} & \textbf{87.4} \\
\bottomrule
\end{tabular}}
\end{center}
\end{table*}

\subsection{Cross-lingual transferability of Transformer layer representations}
\label{sec:cross-lingual-transfer}

So far, our analyses were not specialized to multilingual models. Unlike monolingual models, multilingual models have another dimension of transferability: cross-lingual transfer, the ability to transfer knowledge from one language to another.

Previous work \citep{Pires2019,artetxe2020cross} has found that MLM on multilingual data encourages cross-lingual alignment of representations without explicit cross-lingual supervision. 
While it has been shown that multilingual models learn useful cross-lingual representations, over-specialization to the pre-training task may result in higher layers being less cross-lingual and focusing on language-specific phenomena necessary for predicting the next word in a given language.
To investigate to what extent this is the case and whether increasing  improves cross-lingual alignment, we evaluate the model's nearest neighbour translation accuracy \citep{Pires2019} on English-to-German translation (see Appendix \ref{app:nn_translation} for a description of the method). 



We show the nearest neighbor translation accuracy for each layer in Figure~\ref{fig:nn_translation}. As  increases, we observe that a) the Transformer layers become more language-agnostic as evidenced by higher accuracy and b) the language-agnostic representation is maintained to a higher layer as indicated by a flatter slope from layer 7 to 11. In all cases, the last layer is less language-agnostic than the previous one. The sharp drop in performance after layer 8 at  is in line with previous results on cross-lingual retrieval \citep{Pires2019,Hu2020} and is partially mitigated by an increased . In sum, not only does a larger output embedding size improve cross-task transferability but it also helps with cross-lingual alignment and thereby cross-lingual transfer on downstream tasks.














 



\section{Conclusion}
\label{sec:conclusion}

We have assessed the impact of embedding coupling in pre-trained language models. We have identified the main benefit of decoupled embeddings to be the flexibility endowed by decoupling their shapes. We showed that input embeddings can be safely reduced and that larger output embeddings and reinvesting saved parameters lead to performance improvements. Our rebalanced multilingual BERT (RemBERT) outperforms XLM-R with the same number of fine-tuning parameters while having been trained on  fewer tokens. Overall, we found that larger output embeddings lead to more transferable and more general representations, particularly in a Transformer's upper layers.


\bibliography{main}
\bibliographystyle{iclr2021_conference}

\appendix
\section{Appendix}

\subsection{Efficiency comparison based on parameter count during fine-tuning} \label{app:efficiency_comparison}

We compare the efficiency of models based on their number of parameters. We believe this to be a reasonable proxy for a model's efficiency as the performance of Transformer-based language models has been shown to improve monotonically with the number of parameters~\citep{Kaplan2020,Raffel2020,Lepikhin2020,Brown2020,Shoeybi2019,Aharoni2019m4}. As the number of parameters during pre-training and fine-tuning may differ\footnote{For encoder-only models such as BERT, parameters after the last Transformer layer (e.g. the output embeddings and the pooling layer) are discarded after pre-training.}, we compare models based on their number of parameters during the fine-tuning stage (without the task-specific head). We argue that this is the most practically relevant number as a model is generally pre-trained only once but may be fine-tuned or used for inference millions of times. 

\subsection{Baseline model details} \label{app:baseline_model}

Our baseline model has the same architecture as multilingual BERT \citep[mBERT;][]{Devlin2019}. It consists of 12 Transformer layers with a hidden size  of 768 and 12 attention heads with 64 dimensions each. Input and output embeddings are coupled and have the same dimensionality  as the hidden size, i.e. . The total number of parameters during pre-training and fine-tuning is 177M. We do not use dropout following the recommendation from~\citet{Lan2020}. We use the SentencePiece tokenizer~\citep{Kudo2018_SPM} and a shared vocabulary of 120k subwords. The model is trained on Wikipedia dumps in 104 languages following~\citet{Devlin2019} using masked language modeling (MLM). We choose this baseline as its behavior has been thoroughly studied~\citep{K2020,Conneau2020_emerging,Pires2019,Wu2019}. 


\subsection{Training details} \label{app:training_details}
For all pre-training except for the large scale RemBERT, we trained using 64 Google Cloud TPUs. We trained over 26B tokens of Wikipedia data. All fine-tuning experiments were run on 8 Cloud TPUs. For all fine-tuning experiments other than RemBERT, we use batch size of 32. We sweep over the learning rate values specified in Table~\ref{table:fine-tuning_hyperparameters}.

We used the SentencePiece tokenizer trained with unigram language modeling


\begin{table*}[t]
\caption{Fine-tuning hyperparameters for all models except RemBERT.}
\label{table:fine-tuning_hyperparameters}
\begin{center}

\begin{tabular}{lccc}
\toprule
 & Learning rate & Batch size & Train epochs \\
 \midrule
PAWS-X &  & 32 & 3 \\
XNLI &  & 32 & 3 \\
SQuAD &  & 32 & 3 \\
NER &  & 32 & 3 \\
\bottomrule
\end{tabular}

\end{center}
\end{table*}



\subsection{\xtreme tasks} \label{app:xtreme_tasks}

\begin{table*}[]
\centering
\caption{Statistics for the datasets in \xtreme, including the number of training, development, and test examples as well as the number of languages for each task.}
\resizebox{\textwidth}{!}{\begin{tabular}{l l r r r r l l l}
\toprule
Task & Corpus & Train & Dev & Test & Lang. & Task & Metric & Domain \\ \midrule
\multirow{2}{*}{Classification} & XNLI & 392,702 & 2,490 & 5,010 & 15 & NLI & Acc. & Misc.  \\
& PAWS-X & 49,401 & 2,000 & 2,000 & 7 & Paraphrase & Acc. & Wiki / Quora \\ \midrule
Structured & POS & 21,253 & 3,974 & 47-20,436 & 33 & POS & F1 & Misc. \\
prediction & NER & 20,000 & 10,000 & 1,000-10,000 & 40 & NER & F1 & Wikipedia \\
\midrule
\multirow{3}{*}{QA} & XQuAD & \multirow{2}{*}{87,599} & \multirow{2}{*}{34,726} & 1,190 & 11 & Span extraction & F1 / EM & Wikipedia \\
& MLQA &  &  & 4,517--11,590 & 7 & Span extraction & F1 / EM & Wikipedia \\ 
& TyDiQA-GoldP & 3,696 & 634 & 323--2,719 & 9 & Span extraction & F1 / EM & Wikipedia \\ \midrule
\multirow{2}{*}{Retrieval} & BUCC & - & - & 1,896--14,330 & 5 & Retrieval & F1 & Wiki / news \\
& Tatoeba & - & - & 1,000 & 33 & Retrieval & Acc. & misc. \\
\bottomrule
\end{tabular}}
\label{tab:xtreme}
\end{table*}

For our experiments, we employ tasks from the \xtreme benchmark~\citep{Hu2020}. We show statistics for them in Table \ref{tab:xtreme}. \xtreme includes the following datasets: The Cross-lingual Natural Language Inference \citep[XNLI;][]{Conneau2018xnli} corpus, the Cross-lingual Paraphrase Adversaries from Word Scrambling \citep[PAWS-X;][]{Yang2019paws-x} dataset, part-of-speech (POS) tagging data from the Universal Dependencies v2.5 \citep{nivre2018universal} treebanks, the Wikiann \citep{Pan2017} dataset for named entity recognition (NER), the Cross-lingual Question Answering Dataset \citep[XQuAD;][]{artetxe2020cross}, the Multilingual Question Answering \cite[MLQA;][]{Lewis2020mlqa} dataset, the gold passage version of the Typologically Diverse Question Answering \citep[TyDiQA;][]{Clark2020tydiqa} dataset, data from the third shared task of the workshop on Building and Using Parallel Corpora \citep[BUCC;][]{zweigenbaum2018overview}, and the Tatoeba dataset \citep{Artetxe2019massively}. We refer the reader to \citep{Hu2020} for more details. We average results across three fine-tuning runs and evaluate on the dev sets unless otherwise stated. 







\subsection{Comparison to \citet{Lan2020}} \label{app:lan_comparison}

Crucially, our finding differs from the dimensionality reduction in ALBERT \citep{Lan2020}. While they show that smaller embeddings can be used, their input and output embeddings are coupled and use a much smaller vocabulary (30k vs 120k). In contrast, we find that simultaneously decreasing both the input and output embedding size drastically reduces the performance of multilingual models.

In Table \ref{table:monolingual_vs_multilingual}, we show the impact of their factorized embedding parameterization on a monolingual and a multilingual model. While the English model suffers a smaller (0.8\%) drop in accuracy, the multilingual model's performance drops by 2.6\%. Direct application of a factorized embedding parameterization~\citep{Lan2020} is thus not viable for multilingual models.

\begin{table*}
\caption{Effect of reducing the embedding size  for monolingual vs. multilingual models on MNLI and XNLI performance respectively. Monolingual numbers are from~\citet{Lan2020} and have vocabulary size of 30k.}
\label{table:monolingual_vs_multilingual}
\begin{center}
\resizebox{\textwidth}{!}{\begin{tabular}{lcccc}
\toprule
English & \# PT params & \# FT params & & MNLI \\
\midrule
 & 110M & 110M & & 84.5 \\
 & 89M & 89M & & 83.7 \\
\bottomrule
\end{tabular}
\quad
\begin{tabular}{lcccc}
\toprule
Multilingual &\# PT params & \# FT params & & XNLI  \\
\midrule
 & 177M & 177M & & 70.7 \\
 & 100M & 100M & & 68.1 \\
\bottomrule
\end{tabular}
}
\end{center}
\end{table*}

\subsection{English monolingual results} \label{app:english_results}

So far, we have focused on multilingual models as the number of saved parameters when reducing the input embedding size is largest for them. We now apply the same techniques to the English 12-layer  with a 30k vocabulary \citep{Devlin2019}. Specifically, we decouple the embeddings, reduce  to 128, and increase the output embedding size or the number of layers during pre-training. We show the performance on MNLI \citep{Williams2018multinli} and SQuAD \citep{Rajpurkar2016squad} in Table \ref{table:monolingual_results}. By adding more capacity during pre-training, performance monotonically increases similar to the multilingual models. Interestingly, pruning a 24-layer model to 12 layers reduces performance, presumably because some upper layers still contain useful information.

\begin{table*}[t]
\caption{Effect of an increased output embedding size  and additional layers during pre-training  on English  ().}
\label{table:monolingual_results}
\begin{center}
\begin{tabular}{lccccc}
\toprule
 & \# PT & \# FT & & MNLI & SQuAD \\
 & params & params & & Acc & EM/F1 \\ \midrule
 (ours) & 110M & 110M & & 79.8 & 78.4/86.2\\ \midrule
 & 93M & 89M & & 75.9 & 75.5/84.2 \\ 
 & 112M & 89M & & 77.5 & 77.5/85.5 \\
 & 181M & 89M & & 79.5 & 78.4/86.2 \\
 & 114M & 89M & & 80.1 & 78.7/86.3 \\
 & 178M & 89M & & 79.0 & 77.8/85.5 \\
\bottomrule
\end{tabular}
\end{center}
\end{table*}

\subsection{RemBERT details} \label{app:rembert}

We design a Rebalanced mBERT (RemBERT) to leverage capacity more effectively during pre-training. The model has 995M parameters during pre-training and 575M parameters during fine-tuning. We pre-train on large unlabeled text using both Wikipedia and Common Crawl data, covering 110 languages. The details of hyperparameters and architecture are shown in Table~\ref{table:rembert_hparams}.

For each language , we define the empirical distribution as

where  is the number of sentences in 's pre-training corpus. Following \citet{Devlin2019}, we use an exponentially smoothed distribution, i.e., we exponentiaate  by  and renormalize to obtain the sampling distribution.

Hyperparameters and pre-training details are summarized in Table~\ref{table:rembert_hparams}. Hyperparameters used for the leaderboard submission are shown in Table~\ref{table:rembert_fine-tuning_hparams}.

\begin{table*}[t]
\caption{Hyperparameters for RemBERT architecture and pre-training.}
\label{table:rembert_hparams}
\begin{center}
\begin{tabular}{lr}
\toprule
Hyperparameter & RemBERT \\
\midrule
Number of layers & 32 \\
Hidden size & 1152 \\
Vocabulary size & 250,000 \\
Input embedding dimension & 256 \\
Output embedding dimension & 1536 \\
Number of attention heads & 18 \\
Attention head dimension & 64 \\
Dropout & 0 \\
Learning rate & 0.0002 \\
Batch size & 2048 \\
Train steps & 1.76M \\
Adam  & 0.9 \\
Adam  & 0.999 \\
Adam  &  \\
Weight decay & 0.01 \\
Gradient clipping norm & 1 \\
Warmup steps & 15000 \\
\bottomrule
\end{tabular}
\end{center}
\end{table*}



\begin{table*}[t]
\caption{Hyperparameters for RemBERT fine-tuning.}
\label{table:rembert_fine-tuning_hparams}
\begin{center}
\begin{tabular}{lccc}
\toprule
 & Learning rate & Batch size & Train epochs \\
 \midrule
PAWS-X &  & 128 & 3 \\
XNLI &  & 128 & 3 \\
SQuAD &  & 128 & 3 \\
POS &  & 128 & 3 \\
NER &  & 64 & 3 \\
\bottomrule
\end{tabular}
\end{center}
\end{table*}



\subsection{\xtreme task results} \label{app:full_task_results}

We show the detailed results for RemBERT and the comparison per task on the \xtreme leaderboard in Table \ref{table:full_model}. Compared to Table \ref{table:full_model_avg}, which shows the average across task categories, this table shows the average across tasks.

\begin{table*}[b]
\caption{Comparison of our model to other models on the \xtreme leaderboard. Details about VECO are due to communication with the authors.  is averaged over tasks whereas Avg is averaged over task categories just like Table~\ref{table:full_model_avg}.}
\label{table:full_model}
\begin{center}
\resizebox{\textwidth}{!}{\begin{tabular}{lcccccccccccc}
\toprule
 & \# PT & \# FT & & XNLI & POS & NER & PAWS-X & XQuAD & MLQA & TyDi-GoldP & \multirow{2}{*}{} & \multirow{2}{*}{Avg} \\
 & params & params & & Acc & F1 & F1 & Acc & EM/F1 & EM/F1 & EM/F1 \\
\midrule
\multicolumn{12}{l}{\emph{Models fine-tuned on translations or additional task data}} \\ \midrule
STiLTs \citep{phang2020english} & 559M & 559M & & 80.0 & 74.9 & 64.0 & 87.9 & 63.3/78.7 & 53.7/72.4 & 59.5/76.0 & 72.7 & 73.5 \\
FILTER \citep{Fang2020filter} & 559M & 559M & & 83.9 & 76.2 & 67.7 & 91.4 & 68.0/82.4 & 57.7/76.2 & 50.9/68.3 & 74.9 & 76.0\\
VECO \citep{anonymous2021veco} & 662M & 662M & & 83.0 & 75.1 & 65.7 & 91.1 & 66.3/79.9 & 54.9/73.1 & 58.9/75.0 & 74.1 & 75.1 \\ 
\midrule
\multicolumn{12}{l}{\emph{Models fine-tuned only on English task data}} \\ \midrule
XLM-R \citep{Conneau2020} & 559M & 559M & & 79.2 & 73.8 & 65.4 & 86.4 & 60.8/76.6 & 53.2/71.6 & 45.0/65.1  & 70.1 & 71.4\\
RemBERT (ours) & 995M & 575M & & \textbf{80.8} & \textbf{76.5} & \textbf{70.1} & \textbf{87.5} & \textbf{64.0/79.6} & \textbf{55.0/73.1} & \textbf{63.0/77.0} & \textbf{74.4} & \textbf{75.4} \\
\bottomrule
\end{tabular}
}
\end{center}
\end{table*}


\subsection{Nearest-neighbor translation computation} \label{app:nn_translation}

For an English-to-German translation, we sample  pairs of sentences from WMT16 \citep{bojar2016results}. For each sentence in each language, we obtain a representation  at each layer  by averaging the activations of all tokens (except the \texttt{[CLS]} and \texttt{[SEP]} tokens) at that layer. We then compute a translation vector from English to German by averaging the difference between the vectors of each sentence pair across all pairs: .







For each English sentence , we can now translate it with this vector: . We locate the closest German sentence vector based on  distance and measure how often the nearest neighbour is the correct pair.



\end{document}
