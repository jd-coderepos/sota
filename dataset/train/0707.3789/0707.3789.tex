\documentclass{LMCS}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{verbatim}
\usepackage[usenames]{color}
\usepackage{hyperref}

\newtheorem{la}[thm]{Lemma}
\newtheorem{coro}[thm]{Corollary}

\theoremstyle{definition}
\newtheorem{df}[thm]{Definition}
\newtheorem{ex}[thm]{Example}   
\newtheorem{rmk}[thm]{Remark}
\newtheorem{conn}[thm]{Convention}
\newtheorem{prov}[thm]{Proviso}
\newtheorem{term}[thm]{Terminology}
\newtheorem{red}[thm]{Reduction}

\newenvironment{eatab}
 {\bigskip\noindent\begin{minipage}{\textwidth}\upshape\ttfamily
  \begin{tabbing}mmm\=mmm\=mmm\=mmm\=mmm\=\kill}
 {\end{tabbing}\end{minipage}\bigskip}

\newenvironment{eqnum}{}
\newenvironment{eqsnum}{}
\newenvironment{eqs}{}
\newenvironment{eq}{}
\newenvironment{lsnum}{\begin{enumerate}}{\end{enumerate}}
\newenvironment{ls}{\begin{itemize}}{\end{itemize}}
\newenvironment{unn}[1]{\bigskip\noindent\textbf{#1}\quad}{\par\bigskip}

\newcommand{\arrow}{\longrightarrow}
\newcommand{\notarrow}{\kern .42em\not\kern -.42em\longrightarrow}
\newcommand{\ite}[3]{\ensuremath{\mathtt{if\ }#1\mathtt{\ then\ }
#2\mathtt{\ else\ }#3\mathtt{\ endif}}}
\newcommand{\dfa}[3]{\ensuremath{\mathtt{do\ forall}\
#1\in#2,\ #3 \ \mathtt{enddo}}}



\newcommand{\DD}{\Delta^+}
\newcommand{\E}{\mathrm{E}}
\newcommand{\Issued}{\text{Issued}}
\newcommand{\U}{\Upsilon}
\newcommand{\ans}{\dot}
\newcommand{\bbb}[1]{\ensuremath{\mathbb {#1}}}
\newcommand{\bld}[1]{\ensuremath{\mathbf {#1}}}
\newcommand{\but}[3]{\ensuremath{(#1\text{ but }#2\mapsto#3)}}
\newcommand{\dom}[1]{\ensuremath{{\text{Dom}}(#1)}}
\newcommand{\emp}{\varnothing}
\newcommand{\enexeq}{\unrhd}
\newcommand{\enex}{\rhd}
\newcommand{\eps}{\varepsilon}
\newcommand{\ger}[1]{\ensuremath{\mathfrak {#1}}}
\newcommand{\initeq}{\unlhd}
\newcommand{\init}{\lhd}
\newcommand{\inn}{\mbox{Mult}}
\newcommand{\kand}{\curlywedge}
\newcommand{\kor}{\curlyvee}
\newcommand{\mst}[1]{\ensuremath{\{\kern-0.33em\{#1\}\kern-0.33em\}}}
\newcommand{\nlet}{\ensuremath{\ttt{n}\text-\ttt{let}\ }}
\newcommand{\qval}[3]{\ensuremath{\text{q-Val}(#1,#2,#3)}}
\newcommand{\ran}[1]{\ensuremath{{\text{Range}}(#1)}}
\newcommand{\restr}{\mathop{\upharpoonright}}
\newcommand{\rhu}{\rightharpoonup}
\newcommand{\scr}[1]{\ensuremath{\mathcal {#1}}}
\newcommand{\seq}{\mathop{\ttt{seq}}}
\newcommand{\set}[2]{\ensuremath{\{#1:#2\}}}
\newcommand{\spt}{\text{supp}}
\newcommand{\sq}[1]{\ensuremath{\langle#1\rangle}}
\newcommand{\sym}[1]{\ensuremath{{\text{Sym}}(#1)}}
\newcommand{\ttt}[1]{\ensuremath{\mathtt {#1}}}
\newcommand{\val}[3]{\ensuremath{\text{Val}(#1,#2,#3)}}
\newcommand{\vlet}{\ensuremath{\ttt{v}\text-\ttt{let}\ }}

\renewcommand{\phi}{\varphi}
\renewcommand{\th}{\ensuremath{{}^{\text{th}}}}

\newenvironment{ab}{\noindent\color{blue}AB }{}
\newenvironment{yg}{\noindent\color[rgb]{.5, .148,.184}YG }{}

\newcommand{\mb}[1]{\mathbf{#1}}
\newcommand{\mbb}[1]{\mathbb{#1}}
\newcommand{\mc}[1]{\mathcal{#1}}
\newcommand{\mf}[1]{\mathfrak{#1}}
\newcommand{\mi}[1]{\mathit{#1}}
\newcommand{\mr}[1]{\mathrm{#1}}
\newcommand{\msf}[1]{\mathsf{#1}}
\newcommand{\ty}[1]{\text{\normalfont\ttfamily#1}}
\newcommand{\DDelta}{\mbox{}}
\newcommand{\F}{\mc{F}}

\def\doi{3 (4:4) 2007}
\lmcsheading {\doi}
{1--35}
{}
{}
{Jun.~11, 2007}
{Nov.~\phantom{0}5, 2007}
{}   

\begin{document}

\title[Interactive Small-Step Algorithms II]{Interactive Small-Step
  Algorithms II: Abstract State Machines and the Characterization
  Theorem} 
\author[A.~Blass]{Andreas Blass\rsuper a} 
\address{{\lsuper a}Mathematics Dept.,
  University of Michigan, Ann Arbor, MI 48109, U.S.A.}
\email{ablass@umich.edu} 
\thanks{{\lsuper a}Blass was partially supported by NSF
  grant DMS--0070723 and by a grant from Microsoft Research.}

\author[Y.~Gurevich]{Yuri Gurevich\rsuper b}
\address{{\lsuper b}Microsoft Research, One Microsoft Way, Redmond, WA 98052,
U.S.A.}
\email{gurevich@microsoft.com}

\author[D.~Rosenzweig]{Dean Rosenzweig\rsuper c} 
\address{{\lsuper c}University of Zagreb, FSB, I. Lu\v ci\'ca 5, 10000 Zagreb,
  Croatia}
\email{dean@math.hr}
\thanks{{\lsuper c}Rosenzweig was partially supported by the grant 0120048 from
  the Croatian Ministry of Science and Technology and by Microsoft
  Research.} 

\author[B.~Rossman]{Benjamin Rossman\rsuper d}
\address{{\lsuper d}Computer Science Dept., M.I.T., Cambridge, MA 02139, U.S.A.}
\email{brossman@mit.edu}

\keywords{Interactive algorithm, small-step algorithm, abstract state
machine, abstract state machine thesis, behavioral equivalence,
ordinary algorithms, query.}
\subjclass{F.1.1, F.1.2, F.3.1}

\begin{abstract}
In earlier work, the Abstract State Machine Thesis --- that
arbitrary algorithms are behaviorally equivalent to abstract state
machines --- was established for several classes of algorithms,
including ordinary, interactive, small-step algorithms.  This was
accomplished on the basis of axiomatizations of these classes of
algorithms. In a companion paper \cite{ga1} the axiomatisation was
extended to cover interactive small-step algorithms that are not
necessarily ordinary. This means that the algorithms (1)~can
complete a step without necessarily waiting for replies to all
queries from that step and (2)~can use not only the environment's
replies but also the order in which the replies were received.  In
order to prove the thesis for algorithms of this generality, we
extend here the definition of abstract state machines to incorporate
explicit attention to the relative timing of replies and to the
possible absence of replies. We prove  the characterization theorem
for extended ASMs with respect to general algorithms as axiomatised
in \cite{ga1}.
\end{abstract}

\dedicatory{While this paper was being revised, we received the sad
  news of the death of our co-author,\\ Dean Rosenzweig.  We dedicate
  this paper to his memory.\\
\hfill Andreas Blass, Yuri Gurevich, Benjamin Rossman}

\maketitle
\vfill

\section{Introduction}\label{intro}

Traditional models of computation, like the venerable Turing machine,
are, despite the Church-Turing thesis, rather distant intuitively from
many of the concerns of modern computing.  Graphical user interfaces,
parallel and distributed computing, communication and security
protocols, and various other sorts of computation do not easily fit
the traditional picture of computing from input strings to output
strings.  Abstract state machines (ASMs) were introduced for the
purpose of modeling algorithms at their natural level of abstraction,
as opposed to the far lower level of abstraction usually needed by a
Turing machine model.  That ASMs fulfill their purpose was at first an
empirical fact, supported by numerous case studies, not only of
algorithms in the usual sense but also of whole programming languages
and of hardware; see \cite{web} for many examples.  The Abstract State
Machine Thesis, first proposed in \cite{G64.5} and then
elaborated in \cite{G92,G103}, asserts that every algorithm is
equivalent, on its natural level of abstraction, to an abstract state
machine.  Beginning in \cite{seqth} and continuing in \cite{parth},
\cite{oa1}, \cite{oa2}, and \cite{oa3}, the thesis has been proved for
various classes of algorithms.  In each case, the class of algorithms
under consideration was defined by postulates describing, in very
general terms, the nature of the algorithms, and in each case the main
theorem was that all algorithms of this class are equivalent, in a
strong sense, to ASMs.

The thesis was proved first, in \cite{seqth}, for the class of
algorithms that are sequential (i.e., proceed in discrete steps and do
only a bounded amount of work per step) and do not interact with the
external environment within steps.  (The environment is allowed to
intervene between steps to change the algorithm's state.)  

Subsequent work extended the result in two directions.  Parallel
algorithms, in which a bound on work per step applies to each
processor but not to the algorithm as a whole, were treated in
\cite{parth} but still without intrastep interaction with the
environment.  In \cite{oa1, oa2, oa3}, intrastep interaction was added
to sequential computation, subject to a restriction to ``ordinary''
interaction, and the ASM thesis was proved for the resulting class of
algorithms.  In both of these directions, the standard syntax of ASMs,
as presented in \cite{G103}, was adequate, with only very minor
modifications.

In the present paper and its companion paper \cite{ga1}, we continue
this tradition, now removing the restriction to ordinary interaction.
That is, we propose the postulates in \cite{ga1} as a general
description of sequential algorithms interacting with their
environments, and we show in the present paper that all algorithms
that satisfy the postulates are behaviorally equivalent, in a strong
sense, to ASMs.

There is, however, an important difference between this work and the
earlier proofs of the ASM thesis.  The traditional ASM syntax and
semantics from \cite{G103} are no longer adequate.  They require a
significant extension, allowing an ASM program (1)~to refer to the
order in which the values of external functions are received from the
environment and (2)~to declare a step complete even if not all
external function values have been determined.  Neither of these two
possibilities was permitted by the postulates defining ``ordinary
algorithm'' in \cite{oa1}.  

In \cite{ga1}, we presented postulates that permit both of these
possibilities, and we argued that these postulates capture the general
concept of sequential, interactive algorithm.  In the present paper,
we extend the syntax and semantics of abstract state machines so that
non-ordinary algorithms become expressible.  The main contributions of
this paper are
\begin{ls}
\item syntax and semantics for ASMs incorporating interaction that need
  not be ordinary,
\item verification that ASMs satisfy the postulates of \cite{ga1}, and
\item proof that every algorithm satisfying the postulates is equivalent,
  in a strong sense, to an ASM.
\end{ls}

Most design decisions about the syntax and semantics of general
interactive ASMs were guided, and often forced, by the axiomatisation
of appropriate algorithms in the companion paper \cite{ga1}.
Sections~\ref{sec:asm} and \ref{asm-sem}, defining the syntax and semantics of
interactive ASMs are self-contained and could in principle be read
independently of \cite{ga1}, but we refer the reader to \cite{ga1},
and sometimes also to \cite{oa1,oa2,oa3}, for extensive discussion,
motivation and justification of some of the choices made, as well as
the relation to other work.  Sections \ref{sec:asms-are-algos} and
\ref{sec:thesis}, relating the ASMs of section \ref{sec:asm} to
algorithms as axiomatized in \cite{ga1}, use the definitions and
results of \cite{ga1}.  We presume that the reader has a copy of the
companion paper \cite{ga1} available, but, as an aid to intuition, we
summarize briefly the main content of the postulates.

The \emph{states} of an algorithm are structures for a finite
vocabulary , and certain states are designated as
\emph{initial states}.  The algorithm's interaction with the
environment (during a step) is given by a \emph{history}, which
consists of a function sending the algorithm's queries to the
environment's answers, together with a linear pre-order telling in
what order the answers were received.  The algorithm tells what
queries are to be issued, on the basis of the state and the past
history.  On the same basis, it also tells whether the current step is
ended; if so, it tells whether the step has succeedd or failed, and in
the case of success it tells how the state is to be updated.  The
updating changes the interpretations of some of the function symbols,
but it does not affect the base set.  All of the preceding aspects of
the algorithm are required to be invariant under isomorphism of
-structures.  Finally, the ``small-step'' property of the
algorithm is ensured by a postulate saying that the queries to be
issued, the decisions about ending the step and about success, and the
updates depend only on the history plus a specific finite part of the
state.  For the technical details of the formulation of the
postulates, we refer to \cite[Section~3]{ga1}.

\section{Interactive Small-Step ASMs: Syntax}   \label{sec:asm}

Ordinary interactive small-step ASMs are defined in \cite{oa2}.  In the
companion paper \cite{ga1}, we axiomatized general interactive
small-step algorithms.  In this and the next sections, we define general
interactive small-step ASMs.  This new ASM model is an extension of the
ASM model in \cite{oa2}.  The extension incorporates capabilities for
taking into account the order of the environment's replies and for ending
a step before all queries have been answered.  We repeat here, for the
sake of completeness, some definitions from \cite{oa2,ga1}, but we do not
repeat the detailed discussion and motivation for these definitions.  We
provide detailed discussion and motivation for those aspects of the
present material that go beyond what was in \cite{oa2,ga1}.

In this section we describe the syntax of ASM programs, accompanied
with some intuitive indications of their semantics.  Precise semantics
is given in the next section.

\subsection{Vocabularies}

An ASM has a finite vocabulary  complying with the following
convention, exactly as required for interactive small-step algorithms
in \cite{ga1}.

\begin{conn}   \label{vocab}
\mbox{}
  \begin{ls}
    \item A vocabulary  consists of function symbols with
    specified arities.
    \item Some of the symbols in  may be marked as
    \emph{static}, and some may be marked as \emph{relational}.
    Symbols not marked as static are called \emph{dynamic}.
    \item Among the symbols in  are the logic names: nullary
    symbols \ttt{true}, \ttt{false}, and \ttt{undef}; unary
    \ttt{Boole}; binary equality; and the usual propositional
    connectives.  All of these are static and all but \ttt{undef} are
    relational.
    \item An -structure consists of a nonempty base set and
      interpretations of all the function symbols as functions  on
      that base set.
    \item In any -structure, the interpretations of \ttt{true},
    \ttt{false}, and \ttt{undef} are distinct.
    \item In any -structure, the interpretations of relational
    symbols are functions whose values lie in
    .
  \item In any -structure , the interpretation of
    \ttt{Boole} maps  and  to
     and everything else to .
    \item In any -structure , the interpretation of
    equality maps pairs of equal elements to  and all
    other pairs to .
    \item In any -structure , the propositional connectives
    are interpreted in the usual way when their arguments are in
    , and they take the value
     whenever any argument is not in
    .
    \item We may use the same notation  for a structure and its
    base set.
\item We may omit subscripts , for example from \ttt{true} and
  \ttt{false}, when there is no danger of confusion.\qed
  \end{ls}
\end{conn}

In addition, the ASM
has an
\emph{external vocabulary} , consisting of finitely many
\emph{external function symbols}\footnote{The symbol  for the
external vocabulary is the Greek capital epsilon, in analogy with the
Greek capital upsilon  for the algorithm's vocabulary.}.
These symbols are used syntactically exactly like the symbols from
, but their semantics is quite different.  If  is an
-ary external function symbol and  is an -tuple of
arguments from a state , then the value of  at  is not
stored in the state but is obtained from the environment as the reply
to a query.

\begin{rmk}
The ASM syntax of \cite{oa2} included commands of the form

where  is a term and  is a so-called output
label.  These commands produced an outgoing message, regarded as a
query with an automatic reply ``OK.''  In the present paper, we shall
include commands for issuing the queries associated with external
function calls even when the reply might not be used in the evaluation
of a  term.  These \ttt{issue} commands subsume the older \ttt{Output}
commands, so we do not include the latter in our present syntax.  This
is why the preceding paragraph introduces only the external vocabulary
and not an additional set of output labels.  Note in this connection
that the simulation of ordinary interactive small-step algorithms by
ASMs in \cite{oa3} did not use \ttt{Output} rules.
\qed\end{rmk}

\begin{conn}
  Note that by Convention~\ref{vocab} only function symbols in
   admit two sorts of markings.   They can be either static
  or dynamic and they can be relational or not.  \emph{No such
  markings} are applied to the external function symbols.  All symbols
  in  are considered static and not relational.
\qed\end{conn}

\begin{rmk}
  In this convention, ``static'' does not mean that the values of
  external functions cannot change; it means that the algorithm cannot
  change them, although the environment can.  External functions
  cannot be the subject of updates in an ASM program, and in this
  respect they have the same syntax as static function symbols from
  .

We do not declare any external function symbols to be relational
because such a declaration would, depending on its semantical
interpretation, lead to one of two difficulties.

One possibility would be to demand that the queries resulting from
relational external functions get replies that are appropriate values
for such functions, namely only \ttt{true} and \ttt{false}.  This
imposes a burden on the environment, and a fairly complicated one,
since it may not be evident, by inspection of a query, what external
function symbol produced it (see the discussion of templates below).
We prefer in this paper to keep the environment unconstrained.

A second possibility for handling relational external functions is to
allow the environment to give arbitrary, not necessarily Boolean,
replies to the queries resulting from these symbols.  Then we could
have non-Boolean values for Boolean terms, and we would have to decide
how to handle this pathological situation, for example when it occurs
in the guard of a conditional rule.  In \cite[Section~5]{oa2}, this
approach was used, with the convention that this sort of pathology
would cause the conditional rule to fail.  In our present situation,
that convention no longer looks so natural, because the pathological
value might be one that the algorithm didn't really need.  (Recall
that in \cite{oa1,oa2,oa3} algorithms needed replies to all of their
queries.)  One can probably find a reasonable convention for dealing
with this pathology even for general interactive algorithms, but the
convention would appear somewhat arbitrary, and it seems simpler to
prohibit external function symbols from being relational.

It might appear that this prohibition could cause a problem in
programming.  Suppose, for example, that we know somehow that the
environment will provide a Boolean value for a certain nullary
external function symbol .  Then we might want to use  as the
guard in a conditional statement.  But we can't; since  isn't a
relational symbol, it is not a Boolean term, and so (according to the
definitions in the following subsections) it is ineligible to serve as
a guard.  Fortunately, this problem disappears when we observe that
 is a perfectly good guard (since equality is
relational) and it has the same value as  (since we allegedly know
that  gets a Boolean value).  If, on the other hand, we're not sure
that the environment will provide a Boolean value, then a particular
decision about how to handle a non-Boolean value can be built into the
program.  For example, the convention from \cite{oa2} would be given
by

  \begin{eatab}
     do in parallel\\
     \> if p = true then R1 endif\\
     \> if p = false then R2 endif\\
     \> if p  true and p  false then fail endif\\
     enddo.  \end{eatab}

If one wanted to adopt a convention such as this, not only in a
particular program but throughout some programming language, then
one could adjoin external relational symbols to our syntax and treat
them as syntactic sugar for pieces of code like that exhibited above.  
\end{rmk}

\subsection{Terms}

\begin{df}
  The set of \emph{terms} is the smallest set containing
   whenever it contains  and  is
  an -ary function symbol from .  (The basis of
  this recusive definition is, of course, given by the 0-ary function
  symbols.)
\qed\end{df}

This definition formalizes the assertion above that the external
function symbols in  are treated syntactically like those of the
state vocabulary .

Notice that the terms of ASMs do not involve variables.  In this
respect they differ from those of \cite{oa2}, those of first-order
logic, and those used in the bounded exploration witnesses of
\cite{ga1}. It may be surprising that we can get by without
variables while describing algorithms more general than those of
\cite{oa2} where we used variables.  Recall, however, that the
variables in the ASM programs of \cite{oa2} are bound by the
\ttt{let} construct, and that this construct is eliminable according
to \cite[Section~7]{oa3}.  In the present paper, we use \ttt{let}
only as syntactic sugar (see Subsection~\ref{sugar} below), and so
we do not need variables in our basic formalism.

\begin{df}
  A \emph{Boolean term} is a term of the form  where  is
  a relational symbol.
\qed\end{df}

\begin{conn}
  By -\emph{terms}, we mean terms built using the function
  symbols in  and variables.  These are terms in the usual
  sense of first-order logic for the vocabulary .  Terms as
  defined above, using function symbols from  but not
  using variables, will be called \emph{ASM-terms} when we wish to
  emphasize the distinction from -terms.  A term of the form
   where  will be called a \emph{query-term} or
  simply \emph{q-term}.
\end{conn}

The evaluation of an -term (in a given state with given values for
the variables) produces an element of the state, the value of the
term.  The same applies to q-terms, but there the situation is more
involved.  Consider a q-term  and suppose that 
has been evaluated to .  First the evaluation of 
produces a query, called the q-value of .  If and when a reply to
the query is received the evaluation of  is complete and we get the
actual value .  See details in section~\ref{asm-sem}.

\subsection{Guards}

In \cite{oa2}, the guards  in conditional rules \ttt{if} 
\ttt{then}  \ttt{else}  \ttt{endif} were simply Boolean
terms.  We shall need guards of a new sort to enable our ASMs to take
into account the temporal order of the environment's replies and to
complete a step even when some queries have not yet been answered.

We introduce timing explicitly into the formalism with the notation
, which is intended to mean that the replies needed to
evaluate the term  arrived no later than those needed to evaluate
.  It may seem that we are thereby just introducing a new
form of Boolean term, but in fact the situation is more complicated.

In the presence of
all the replies needed for both  and , the guard 
will have a truth value, determined by relative timing of replies.
At the other extreme, if neither  nor  can be
fully evaluated,
then  must, like  and
 themselves, have no value.  So far,  behaves like
a term.

Between the two extremes, however, there are situations where
the replies provided by the environment suffice for the evaluation
of one but not both of  and . If replies suffice for  but
not for , then  is true; if replies suffice for 
but not for , then  is false. Here, 
behaves quite differently from a term, in that it has a value even
when one of its subterms does not.

This behavior of  also enables an ASM to complete its
step while some of its queries remain unanswered.  The execution of a
conditional rule with  as its guard can proceed to the
appropriate branch as soon as it has received enough replies from the
environment to evaluate at least one of  and , without waiting
for the replies needed to evaluate the other.

We shall need similar behavior for more complicated guards, and for
this purpose we shall use the propositional connectives of Kleene's
strong three-valued logic, which perfectly fits this sort of situation
\cite[\S64]{Kleene}.  We use the notations  and  for the
conjunction and disjunction of this logic.  They differ from the
classical connectives  and  in that  has
the value false as soon as either of  and  does, even if
the other has no value, and  has the value true as soon
as either of  and  does, even if the other has no value.
In other words, if the truth value of one of the constituents 
and  suffices to determine the truth value of the compound
formula, regardless of what truth value the other constituent gets,
then this determination takes effect without waiting for the other
constituent to get any truth value at all.  (It is customary, in
discussions of these modified connectives, to treat ``unknown'' as a
third truth value, but it will be convenient for us to regard it as
the absence of a truth value.  Such absences occur anyway, even for
ordinary terms, when the
existing replies do not suffice for a complete
evaluation, and it seems superfluous to introduce another entity,
``unknown,'' to serve as a marker of this situation.)

For detailed formal definition of the semantics of guards see
section \ref{asm-sem} below.

\begin{df}
  The set of \emph{guards} is defined by the following recursion.
  \begin{ls}
    \item Every Boolean term is a guard.
    \item If  and  are terms, then  is a guard.
    \item If  and  are guards, then so are
    , , and .
  \end{ls}
\qed\end{df}

Notice that the first clause of this definition allows, in particular,
terms built by means of the ordinary, 2-valued connectives from other
Boolean terms.

\subsection{Rules}

Most of the definition of ASM rules is as in \cite{oa2}.  The
differences are in the use of \ttt{issue} rules in place of the
less general \ttt{Output} rules of \cite{oa2} and in the more general
notion of guard introduced above.

\begin{df}
The set of ASM \emph{rules} is defined by the following recursion.
\begin{ls}
\item If  is a dynamic -ary function symbol, if
   are terms, and if  is a term that is Boolean if
   is relational, then

is a rule, called an \emph{update} rule.
\item If  is an external -ary function symbol and if
   are terms, then

is a rule, called an \emph{issue} rule.
\item \ttt{fail} is a rule.
\item If  is a guard and if  and  are rules, then

is a rule, called a \emph{conditional} rule.   and  are its
\emph{true} and \emph{false branches}, respectively.
\item If  is a natural number (possibly zero) and if
   are rules then

is a rule, called a \emph{parallel combination} or \emph{block} with
the subrules  as its \emph{components}.
\end{ls}
\qed\end{df}

We may omit the end-markers \ttt{endif} and \ttt{enddo} when they are
not needed, for example in very short rules or in programs formatted
so that indentation makes the grouping clear.

\begin{ex} \label{ex:broker} In \cite{ga1} we have analyzed the
algorithm of a broker who offers a block of  shares of stock 
at price  to clients  by issuing queries ,
. The client whose reply reaches the broker first wins the
sale. We consider here a variant of the example in which every reply
from a client is considered to be positive, so that a client refuses
the offer by not answering at all. If both replies reach the broker
simultaneously then, for simplicity, client 0 is preferred. There is
a further timeout query , so that if no client replies by
timeout, the sale is canceled. Given that 
and  are some -terms, an equivalent ASM program
might be

\begin{eatab}
  \>\>\ttt{if\ }
  \ttt{\ then\ cancel}\\
  \>\>\ttt{else\ if\ }\ttt{\ then\ sell\ to\ }0\\
  \>\>\ttt{else\ sell\ to\ }1
\end{eatab}

\noindent where \texttt{cancel} and \texttt{sell to } stand for
some updates recording respectively canceling the sale or selling to
client  in the state.
\end{ex}


\subsection{Queries and templates}

We recall the query-reply model that is discussed at length in
\cite{oa1,oa2} and summarized in \cite{ga1}.  In addition to vocabulary
 and external vocabulary , an ASM has a set  of
\emph{labels}.

\begin{df}
A \emph{potential query} in -structure  is a finite
tuple of elements of .  A \emph{potential reply} in
 is an element of . \qed\end{df}

Here  is the disjoint union of  and .
So if they are not disjoint, then they are to be replaced by
disjoint isomorphic copies.  We shall usually not mention these
isomorphisms; that is, we write as though  and  were
disjoint.

The correspondence between external function calls on the one hand
and queries on the other hand is mediated by a template assignment,
defined as follows.

\begin{df}
For a fixed label set , a \emph{template} for -ary
  function symbols is any tuple in which certain positions are filled
  with labels from  while the rest are filled with the
  \emph{placeholders} , occurring once
  each.  We assume that these placeholders are distinct from all
  the other symbols under discussion ().
  If  is a template for -ary functions, then we write
   for the result of replacing each placeholder
   in  by the corresponding .
  \qed\end{df}

Thus if the  are elements of a state  then
 is a potential query in .

\begin{df}
For a fixed label set and external vocabulary, a \emph{template
assignment} is a function assigning to each -ary external
function symbol  a template  for -ary functions.
\qed\end{df}

The intention, which will be formalized in the semantic definitions
of the next section, is that when an ASM evaluates a term
 where , it first computes the
values  of the terms , then issues the query , and finally uses the answer to this query as the
value of .

Template assignments solve the problem whether two distinct syntactic
occurrences of the same function symbol with the same arguments refer
to the same query or denote distinct queries.  Sometimes it is
convenient to have it one way, and sometimes another.  For extensive
discussion of template assignments we refer the reader to \cite{oa2}.

\subsection{Programs} \label{sugar}

Now we are ready to define ASM programs.

\begin{df}   \label{asm-prog-def}
  An \emph{interactive, small-step, ASM program}  consists of
  \begin{ls}
    \item a finite vocabulary ,
    \item a finite set  of labels,
    \item a finite external vocabulary ,
    \item a rule , using the vocabularies  and
    , the \emph{underlying rule} of ,
    \item a template assignment with respect to  and .
  \end{ls}
\end{df}

This completes the definition of the syntax of ASMs.  It will, however, be
convenient notationally and suggestive conceptually to introduce
abbreviations, syntactic sugar, for certain expressions.  Specifically, we
adopt the following conventions and notations.



\begin{conn}
  We use \ttt{skip} for the parallel combination with no components,
  officially written \ttt{do\ in\ parallel\ enddo}.
\end{conn}

\begin{conn}
The parallel combination with  components  can
     be written as .
\end{conn}

Semantically, \ttt{par} is commutative and associative, that is, rules
that differ only by the order and parenthesization of parallel
combinations will have the same semantic behavior.  Thus, in contexts
where only the semantics matters, parentheses can be omitted in
iterated \ttt{par}s.

\begin{conn}
  We abbreviate \ttt{if}  \ttt{then}  \ttt{else\ skip\ endif}
  as \ttt{if}  \ttt{then}  \ttt{endif}.
\qed\end{conn}

\begin{conn}
  For any term , the Boolean term  is denoted by , read as
  `` bang.''
\qed\end{conn}

These bang terms may seem trivial, but they can be used to control
timing in the execution of an ASM.  If the term  involves external
function symbols, then the rule \ttt{if}  \ttt{then} 
\ttt{endif} differs from  in that it issues the queries needed for
the evaluation of  and waits for the replies before proceeding to
execute .

\begin{conn}
  We use the following abbreviations:

Parentheses may be omitted when no confusion results.
\qed\end{conn}

The final two items of syntactic sugar involve two ways of binding
variables to terms by \ttt{let} operators.  Our syntax so far does not
include variables, but it is easy to add them.

\begin{df}
  Fix an infinite set of variables.  ASM \emph{rules with variables}
  are defined exactly like ASM rules, with variables playing the role
  of additional, nullary, static symbols.
\qed\end{df}

\begin{conn}
  If  is a rule with distinct variables , and
  if  are terms then the \emph{let-by-name}
  notation
 means .  \qed\end{conn}

\begin{conn}
  If  is a rule with distinct variables , and
  if  are terms then the \emph{let-by-value}
  notation

abbreviates

\qed\end{conn}

For both \nlet and \vlet rules, the  are called the
\emph{variables} of the rule, the  its \emph{bindings}, and
 its \emph{body}.  Each of the variables  is
bound by this rule at its initial occurrence in the context 
and at any free occurrences in .  (Occurrences of
the variables  in the terms  are not bound by the \nlet or
\vlet construction, regardless of whether  or not.)

The let-by-name notation simply uses variables  as placeholders for
the terms .  The let-by-value notation, in contrast, first evaluates
all the  and only afterward proceeds to execute the rule .  In
this sense, the two forms of \ttt{let} correspond to call-by-name and
call-by-value in other situations.

\begin{ex} \label{ex:let} Let  be a term representing a query asking the
environment for a fresh object, like constructors in object-oriented
languages, so that distinct textual occurrences of  in a program
represent distinct queries with supposedly distinct replies.  Let 
be a rule with several syntactic occurrences of .  Then  provides just an abbreviation for  (if it is
indeed shorter than ), while  has a
completely different meaning: first ask the environment for a fresh
object, await the reply, and then use it repeatedly.
\end{ex}

\section{Interactive Small-Step ASMs: Semantics}   \label{asm-sem}

Throughout this section, we refer to a fixed structure .  We start by
recalling the notion of history introduced and motivated in the companion
paper \cite{ga1}.  Then we define the semantics of terms, guards, and
rules in the structure , relative to histories .  In each case, we
tacitly presume a template assignment.  (Unlike , the history 
will not remain fixed, because the meaning of a guard under history 
can depend on the meanings of its subterms under initial segments of
.)  In each case, the semantics will specify a causality relation.
In addition, for terms and guards the semantics may provide a value
(Boolean in the case of guards); for rules, the semantics may declare the
history final, successful, or failing, and may provide updates.


\subsection{Histories}

The notion of \emph{history} as a formal model of intrastep interaction of
an algorithm and its environment has been introduced and extensively
discussed in \cite{ga1}.  We recall the relevant definitions.

\begin{df}       \label{ans-fn}
An \emph{answer function} for a state  is a partial map from
potential queries to potential replies.  A \emph{history} for  is
a pair  consisting of an answer function
 together with a linear pre-order  of its domain.
By the \emph{domain} of a history , we mean the domain
\dom{\ans\xi} of its answer function component, which is also the
field of its pre-order component. \qed\end{df}

Recall that a \emph{pre-order} of a set  is a reflexive,
transitive, binary relation on , and that it is said to be
\emph{linear} if, for all ,  or .  The
equivalence relation defined by a pre-order is given by

The equivalence classes are partially ordered by

and this partial order is linear if and only if the pre-order was.

The \emph{length} of a linear pre-order is defined to be the order
type of the induced linear ordering of equivalence classes.  (We
shall use this notion of length only in the case where the number of
equivalence classes is finite, in which case this number serves as
the length.)

We also write  to mean  and .  (Because a
pre-order need not be antisymmetric,  is in general a stronger
statement than the conjunction of  and .)  When,
as in the definition above, a pre-order is written as , we
write the corresponding equivalence relation and strict order as
 and .  The same applies to other subscripts and
superscripts.

\begin{df}
Let  be a pre-order of a set .  An \emph{initial segment}
of  with respect to  is a subset  of  such that
whenever  and  then .  An \emph{initial
segment} of  is the restriction of  to an initial
segment of  with respect to .  An \emph{initial segment} of
a history \sq{{\ans\xi},\leq_\xi} is a history \sq{{\ans\xi}\restr
S,\leq_\xi\restr S}, where  is an initial segment of
\dom{\ans\xi}\ with respect to .  (We use the standard
notation  for the restriction of a function or a relation to
a set.)  We write  to mean that the history 
is an initial segment of the history . \qed\end{df}


\subsection{Terms}

The semantics of terms presumes not only an -structure  and a
template assignment but also a history .  The semantics is
essentially the same as in \cite{oa2}, except that we do not use variables
here.  In particular, the history  is involved only via the answer
function ; the pre-order is irrelevant.

The semantics of terms specifies, by induction on terms , the queries
that are caused by  under the associated causality relation
 and sometimes also a value .  In the case of
query-terms, the semantics may specify also a query-value .
An evaluation of a query-term  is intended to produce first a query,
called the q-value of  and denoted ; the reply, if any, to
the query is the actual value  of .

\begin{df}   \label{term-val-def}
  Let  be the term .
  \begin{ls}

   \item If \val{t_i}X\xi\ is undefined for at least one , then
    \val tX\xi\ is also undefined, and  if and only
    if  for at least one . If  then  is also undefined.

   \item If, for each ,  and if ,
    then , and no query  is
    caused by .

   \item If, for each , , and if , then
     is the query .

   \begin{ls}

    \item If , then , and no query is caused by .

    \item If , then  is
    undefined, and  is the unique query such that .
    \end{ls}
  \end{ls}
\qed\end{df}


We record for future reference three immediate consequences of this
definition; the proofs are routine inductions on terms.

\begin{la}   \label{df-noq-t}
  \val tX\xi\ is defined if and only if there is no query
 such that .
\end{la}

\begin{la}   \label{no-rep-t}
If  then .
\end{la}

\begin{la} \label{mon-t} If  (or even if merely
  ) and if \val tX\eta\ is defined, then
  \val tX\xi\ is also defined and these values are equal.  Similarly,
  if  is a q-term such that \qval tX\eta\ exists, then .

\end{la}



\subsection{Guards}

The semantics of guards, unlike that of terms, depends not only on the
answer function but also on the preorder in the history.  Another
difference from the term case is that the values of guards, when
defined, are always Boolean values.  Guards share with terms the
property that they produce queries if and only if their values are
undefined.

\begin{df}   \label{guard-sem-def}
Let  be a guard and  a history in an -structure
.
\begin{ls}
  \item If  is a Boolean term, then its value (if any) and
  causality relation are already given by
  Definition~\ref{term-val-def}.
  \item If  is  and if both  and  have values
  with respect to , then  if, for every
  initial segment  such that \val tX\eta\ is defined,
   is also defined.  Otherwise, .  Also declare that  for no
  .
  \item If  is  and if  has a value with respect
  to  but  does not, then define  to be
  \ttt{true}; again declare that  for no .
  \item If  is  and if  has a value with respect
  to  but  does not, then define  to be
  \ttt{false}; again declare that  for no .
  \item If  is  and if neither  nor  has a
  value with respect to , then  is undefined,
  and  if and only if  or
  .
  \item If  is  and both  have value
  \ttt{true}, then  and no query is
  produced.
  \item If  is  and at least one  has
  value \ttt{false}, then  and no query
  is produced.
  \item If  is  and one  has value
  \ttt{true} while the other, , has no value, then
   is undefined, and  if and only if
  .
  \item If  is  and neither  has a
  value, then \val\phi X\xi\ is undefined, and 
  if and only if  for some .
  \item The preceding four clauses apply with  in place of
   and \ttt{true} and \ttt{false} interchanged.
  \item If  is  and  has a value, then
   and no query is produced.
  \item If  is  and  has no value then
  \val\phi X\xi\ is undefined and  if and only
  if .
\end{ls}
\qed\end{df}

\begin{rmk}
An alternative, and perhaps more intuitive, formulation of the
definition of  in the case where both  and
 have values is to let  (resp.\ ) be the shortest
initial segment of  with respect to which  (resp.\ ) has a
value, and to define  to be \ttt{true} if
 and \ttt{false} otherwise.  This is equivalent, in
the light of Lemma~\ref{mon-t}, to the definition given above, but it
requires knowing that the shortest initial segments mentioned here,
 and , exist.  That is clearly the case if the partial
order associated to the preorder in  is a well-ordering, in
particular if it is finite.  Once we establish that ASMs satisfy the
Bounded Work Postulate, it will follow that we can confine our
attention to finite histories and so use the alternative explanation
of \val{(s\preceq t)}X\xi.  The formulation adopted in the definition
has the advantage of not presupposing that only finite histories
matter.
\qed\end{rmk}

\begin{ex}
The truth value of a timing guard  is defined in terms of
the syntactic objects  and , not in terms of their values.  As a
result, this truth value may not be preserved if  and  are replaced
by other terms with the same values (in the given history ), not even
if the replacement terms ultimately issue the same queries as the original
ones.  Here is an example of what can happen.  Suppose , , and 
are external function symbols,  being unary and the other two nullary.
Suppose further that 0 is a static nullary -symbol.  Consider a history
 with three queries in its domain, pre-ordered as , and with .  Then the
term  has a value already for the initial segment of  of length
1;  gets a value later, namely for the initial segment of length 2; and
 gets a value only for the whole history , of length 3.  Thus,
the guards  and  are true, even though
 and  have the same value and have, as the ultimate step in
their evaluation, the answer to the query .  \qed\end{ex}

Just as for terms, the following lemmas follow immediately, by
induction on guards, from the definition plus the corresponding lemmas
for terms.

\begin{la}   \label{df-noq-g}
  \val\phi X\xi\ is defined if and only if there is no query
 such that .
\end{la}

\begin{la}   \label{no-rep-g}
If  then .
\end{la}

\begin{la}   \label{mon-g}
If  and if \val\phi X\eta\ is defined, then \val\phi
  X\xi\ is also defined and these values are equal.
\end{la}

\begin{rmk}
  Given the semantics of guards, we can amplify the statement, in the
  Remark~3.10. of \cite{ga1}, that guards express descriptions like
  `` has reply  and  has no reply.''  In view of
  Lemma~\ref{mon-g}, it is more accurate to say that a guard expresses
  that such a description either is correct now or was so at some
  earlier time.  The lemma says that, once a guard is true, it remains
  true when the history is extended by adding new elements later in
  the preorder, whereas a property like `` has no reply'' need not
  remain true.  Thus, what a guard can really express is something
  like this: it either is now true or was once true that `` has
  reply  and  has no reply yet.''  This particular example
  would be expressed by the guard , where, for
  simplicity we have not introduced a separate notation for 0-ary
  symbols corresponding to the queries  and  and the element
  .
\end{rmk}

\subsection{Rules}

The semantics of a rule, for an -structure , an appropriate
template assignment, and a history , consists of a \emph{causality
relation}, declarations of whether  is \emph{final} and whether it
\emph{succeeds} or \emph{fails}, and a set of \emph{updates}.

\begin{df}
  Let  be a rule and  a history for the -structure .  In the
  following clauses, whenever we say that a history succeeds or that
  it fails, we implicitly also declare it to be final;
  contrapositively, when we say that a history is not final, we
  implicitly also assert that it neither succeeds nor fails.
  \begin{ls}
    \item If  is an update rule  and if all
    the  have values , then  succeeds for
    , and it produces the update set
     and no queries.
    \item If  is an update rule  and if some
     has no value, then  is not final for , it produces
    the empty update set, and  if and only if
     for some .
  \item If  is  and if all the 
  have values , then  succeeds for , it
  produces the empty update set, and  for the single
  query  provided ; if
   then no query is produced.
    \item If  is  and if some 
    has no value, then  is not final for , it produces the
    empty update set, and  if and only if
     for some .
  \item If  is \ttt{fail}, then  fails for
    ; it produces the empty update set and no queries.
    \item If  is a conditional rule  and if  has no value, then
 is not final for , and it produces the empty update set.
 if and only if .
     \item If  is a conditional rule  and if  has
value \ttt{true} (resp.\ \ttt{false}), then finality, success, failure,
updates, and queries are the same for  as for  (resp.\ ).
     \item If  is a parallel combination  then:
       \begin{ls}
     \item  if and only if 
     for some .
     \item The update set for  is the union of the update sets
     for all the components .  If this set contains two
     distinct updates at the same location, then we say that a
     \emph {clash} occurs (for , , and ).
     \item  is final for  if and only if it is final for
     all the .
     \item  succeeds for  if and only if it succeeds for
         all the  and no clash occurs.
     \item  fails for  if and only if it is final for 
     and either it fails for some  or a clash occurs.
       \end{ls}
  \end{ls}
\qed\end{df}

There is no analog for rules of Lemmas~\ref{df-noq-t} and
\ref{df-noq-g}.  A rule may issue queries even though it is final
(in the case of an \ttt{issue} rule) or produces updates (in the
case of parallel combinations) or both.  There are, however, analogs
for the other two lemmas that we established for terms and guards;
again the proofs are routine inductions.

\begin{la}   \label{no-rep-r}
If  then .
\end{la}

\begin{la}   \label{mon-r}
Let .
\begin{ls}
  \item If  is final for , then so is .
  \item If  succeeds for , then so does .
  \item If  fails for , then so does .
  \item The update set for  under  includes that under
  .
\end{ls}
\end{la}

The reader might find it useful at this point to work out the
semantic details of the examples \ref{ex:broker} and \ref{ex:let},
comparing the results with the intuitive explanations given in the
examples.

\begin{rmk}
  Issue rules are the only way an ASM can issue a query without
  necessarily waiting for an answer.  More precisely, if a history
  causes a rule to issue a query and is also final for that rule, then
  that rule either is an issue rule or contains a subrule with the
  same property.  Thus, we cannot eliminate \ttt{issue} from the
  syntax without reducing the power of ASMs.
\end{rmk}

\subsection{ASM definition}

If  is a successful, final history for a rule  over an
-structure , then  and  produce a successor for .
We need a preliminary lemma to ensure that this successor will be
well-defined.  Recall that, in the definition of the semantics of
parallel rules, we defined ``a clash occurs'' (for a rule, template
assignment, state, and history) to mean that the update set contains
two different updates of the same location.

\begin{la}   \label{no-clash}
  If an ASM rule with a template assignment is (final and) successful
  in a certain state with a certain history, then no clash occurs for
  this rule, template assignment, state, and history.  
\end{la}

\begin{proof}
Use induction on rules.  In the case of a parallel composition, the
semantics explicitly provided for failure if a clash occurs.  All
other cases are trivial thanks to the induction hypothesis.
\end{proof}

\begin{df} \label{asm-next_state}
Fix a rule  endowed with a template assignment, and let  be an
-structure and  be a history for .  If  is successful and
final for  over , and if  is the update set produced by
, , and , then the \emph{successor}  of  with
respect to  and  is the -structure  such that
\begin{ls}
  \item  has the same base set as ,
  \item  if , and
  \item otherwise  interprets function symbols exactly as  does.\qed
\end{ls}
\end{df}

Lemma~\ref{no-clash} ensures that the second clause of
the definition does not attempt to give  two different
values. 

Now we are ready to give a complete definition of ASMs.

\begin{df}   \label{asm-def}
  An \emph{interactive, small-step, ASM} consists of
  \begin{ls}
    \item an ASM program  in some vocabulary ,
    \item a nonempty set  of -structures called \emph{states}
    of the ASM, and
    \item a nonempty set  of \emph{initial states},
  \end{ls}
subject to the requirements that \scr S and \scr I are closed under
isomorphism and that \scr S is closed under transitions in the following
sense.  If , if  is a successful, final history for 
in , and if  is the update set produced by , , and
, then the successor  of  with respect to  and
 is also in \scr S.  The successor is the \emph{next state} for 
with respect to , endowed with the given template assignment, and to
.  \qed
\end{df}

\section{ASMs are Algorithms} \label{sec:asms-are-algos}

This section is devoted to checking that ASMs, as just defined, are
algorithms, as defined in \cite{ga1}. In this section (and in the
rest of the paper) we freely use the notions and results of
\cite{ga1}.

\subsection{Obvious postulates}

Much of this checking is trivial: Everything required by the States
Postulate of \cite{ga1} is in our definition of ASMs.  The causality
relation required by the Interaction Postulate of \cite{ga1} is
included in our semantics for ASMs. (Strictly speaking, the
causality relation defined for ASMs should be restricted to finite
histories, to comply with the statement of the Interaction
Postulate.)  The Isomorphism Postulate of \cite{ga1} is also
obvious, because everything involved in our ASM semantics is
invariant under isomorphisms.  So the only postulates requiring any
real checking are the Step and Bounded Work Postulates.

\subsection{Step Postulate}

The ASM semantics provides notions of finality, success, failure, and
updates.  In addition to these, the Step Postulate of \cite{ga1}
requires (in Part~C) a notion of next state and (in Part~A) assurance
that every complete, coherent history has a final initial
segment\footnote{We implicitly use the notions of coherent history and
  complete history as defined for algorithms in general in
  \cite[Section~3]{ga1}, with respect to the causality relation of the
  ASM program as defined in Section~\ref{asm-sem} above}.  The next
state is given by Definition~\ref{asm-next_state}, and it is
well-defined because of Lemma~\ref{no-clash}.

To show that every complete, coherent history has a final initial
segment, we actually show more, namely that every complete history is
final.  The main ingredient here is the following lemma.

\begin{la}
  If a history  is not final for a rule  in a state , then
   for some query .
\end{la}

\begin{proof}
  We proceed by induction on the rule , according to the clauses in
  the definition of the semantics for rules.  Since we are given that
   is not final, we can ignore those clauses that say  is
  final, and there remain the following cases.

If  is either an update rule  or an issue
rule  and some  has no value, then
by Lemma~\ref{df-noq-t} there is a query  such that
, and therefore .

If  is a conditional rule whose guard has no value, then the same
argument applies except that we invoke Lemma~\ref{df-noq-g} in place
of Lemma~\ref{df-noq-t}.

If  is a conditional rule whose guard has a truth value, then the
lemma for  follows immediately from the lemma for the appropriate
branch of .

Finally, suppose  is a parallel combination.  Since  is not
final for  in , there is a component  for which  is
not final.  By induction hypothesis,  for some
, and then we also have .
\end{proof}

To complete the verification of the Step Postulate, we observe that,
in the situation of the lemma,  and, by
Lemma~\ref{no-rep-r}, .  Thus,
, and so  is not complete for 
and .

\begin{rmk}
  Because we have promised to prove that every algorithm is equivalent
  to an ASM, one might think that every algorithm enjoys the property
  established for ASMs in the preceding proof, namely that all
  complete histories are final.  This is, however, not the case,
  because this property is not preserved by equivalence of algorithms.
  For a simple example, consider an algorithm where, for every state,
  the empty history is the only final history, and it causes one
  query, while all other histories cause no queries.  Since the empty
  history is an initial segment of every history, Part~A of the Step
  Postulate is satisfied, even though the complete histories, those in
  which the one query is answered, are not final.

Notice, however, that converting an arbitrary algorithm to an
equivalent one in which all complete histories are final is much
easier than converting it to an equivalent ASM.  Simply adjoin all
non-final, complete histories for any state to the set of final,
failing histories for that state.  None of the histories newly
adjoined here can be attainable, so the modified algorithm is
equivalent to the original.  \qed\end{rmk}

\subsection{Bounded Work Postulate}
We turn now to the Bounded Work Postulate of \cite{ga1}.  Its first
assertion, about the lengths of queries, is easy to check.  Since
the postulate refers only to coherent histories (actually to
attainable, final histories, but coherence suffices for the present
purpose), any query in the domain of such a history is caused by
some history.  By inspection of the definition of ASM semantics, all
queries that are ever caused are of the form 
and thus have the same length as the template  assigned to
some external function symbol.  As there are only finitely many
external function symbols, the lengths of the queries are bounded.

The next assertion of the Bounded Work Postulate, bounding the number
of queries issued by the algorithm, will be a consequence of the
following lemma.

\begin{la}
For any term , guard , or rule , there is a natural number
, , or  that bounds the number of queries caused
in a state  by initial segments of a history .  The bound
depends only on , , or , not on  or .
\end{la}

\begin{proof}
Go to the definition of the semantics of ASMs and inspect the clauses
that say queries are caused.  The result is that, first, we can define
the desired  for terms by

The sum here comes from the first clause in the definition of
semantics of terms, and the additional 1 comes from the last clause.
It is important here that, according to Lemma~\ref{mon-t}, all the
initial segments of any  that produce values for a  produce
the same value .  Thus, the last clause of the definition
produces at most one query .

Similarly, we obtain for guards  (other than the Boolean terms
already treated above) the estimates
\begin{eqs}
B((s\preceq t))&=&B(s)+B(t)\\
B(\psi_0\kand\psi_1)=B(\psi_0\kor\psi_1)&=&B(\psi_0)+B(\psi_1)\\
B(\neg\psi)&=&B(\psi).
\end{eqs}

For rules, we obtain
\begin{eqs}
B(f(t_1,\dots,t_n):=t_0)&=&\sum_{i=0}^nB(t_i)\\
B(\ttt{issue}f(t_1,\dots,t_n))&=&1+\sum_{i=1}^nB(t_i)\\
B(\ttt{fail})&=&0\\
B(\ttt{if\ }\phi\ttt{\ then\ }R_0\ttt{\ else\ }R_1)&=&
B(\phi)+B(R_0)+B(R_1)\\
B(\ttt{do\ in\ parallel\ }R_1,\dots R_k)&=&
\sum_{i=1}^kB(R_i).
\end{eqs}(In the bound for conditional rules, we could reduce 
to  by using the fact that all the initial
segments of any  that produce values for  produce
the same value.)
\end{proof}

Since  is the set of queries caused in state ,
under rule , by initial segments of , the lemma tells us that
, independently of  and .  This
verifies the second assertion of the Bounded Work Postulate.  (It
actually verifies more, since the proof applies to all histories
, not merely to attainable ones.)

To complete the verification of the Bounded Work Postulate, it remains
only to produce bounded exploration witnesses for all ASMs.  We shall
do this by an induction on rules, preceded by proofs of the analogous
results for terms and for guards.

\begin{la}
For every ASM-term  (without variables) there exists a finite set
 of -terms (possibly with variables) such that,
whenever  and  agree on , then:
\begin{ls}
  \item If  then .
  \item .
\end{ls}
\end{la}

Recall that ``agree on '' means that each term in  has the
same value in   and in  when the variables are given the same
values in \ran{\ans\xi}.  Recall also that an equation between
possibly undefined expressions like \val tX\xi\ means that if either
side is defined then so is the other and they are equal.

\begin{proof}
By a \emph{shadow} of an ASM-term , we mean a term 
obtained from  by putting distinct variables in place of the
outermost\footnote{``Outermost'' means ``maximal'' in the sense that
the occurrence in question is not properly contained in another such
occurrence.  In terms of the parse tree of , it means that, on the
path from the root of the whole tree to the root of the subtree given
by the occurrence in question, there is no other occurrence of an
external function symbol.} occurrences of subterms that begin
with external function symbols.  Thus,  is an
-term, and  can be recovered from  by a
suitable substitution of ASM-terms (that start with external function
symbols) for all the variables.

Notice that  fails to be uniquely determined
by  only because we have not specified which variables are to replace
the subterms.

We define, by recursion on ASM-terms , the set  of
-terms as follows.  If  is  then

where  is some shadow of . It follows immediately, by
induction on , that  is finite.  The verification that this
 satisfies the conclusion of the lemma is also by induction on
, following the clauses in the definition of the semantics of
terms.

Assume that  and  agree on .  Notice that
they also agree on each , because .

Suppose first that \val {t_i}X\xi\ is undefined for some .  By
induction hypothesis, \val{t_i}{X'}\xi\ is also undefined, so the same
clause of the semantics of terms applies in  and .  That clause
says that  has no value in either state and it issues those queries
that are issued by any of the .  Those are the same queries in
 as in  by the induction hypothesis.

{}From now on, suppose that  for each .  By
induction hypothesis, the same holds for , with the same 's.

So if  then  gets the value  in
 and the value  in , and we must check
that these values are the same.  Recall that  is obtained from its
shadow  by replacing each variable  in  with a
certain ASM-term .  Thus, the value  of
 in  is also the value of  in  when each variable
 is assigned the value  and similarly with
 in place of .  By induction hypothesis, these values assigned
to the variables are the same in  and .  (We use here that
 is a \emph{proper} subterm of , which is correct
because  begins with a function symbol from .)
Furthermore, since  begins with an external function
symbol, its value is in \ran{\ans\xi}.  Thus, the assumption that
 and  agree on , which contains ,
ensures that  has the same value in both  and .
Therefore  as required.
Since no queries are issued in this situation, we have completed the
proof in the case that .

There remains the case that  and, as before, the subterms
 have (the same) values  in  and .  If  then  gets the same value
 in both  and , no queries are
issued in either state, and the lemma is established in this case.

So assume that the query  is not in \dom{\ans\xi}.
Then this query is the unique query produced by  in either state,
and  has no value in either state, so again the conclusion of the
lemma holds.
\end{proof}

The preceding lemma easily implies the corresponding result for
guards.

\begin{la}
For every guard  there exists a finite set  of
-terms such that, whenever  and  agree on
, then:
\begin{ls}
  \item If  then .
  \item .
\end{ls}
\end{la}

\begin{proof}
We define  by induction on .  If  is a Boolean
term, then the preceding lemma provides the required .

If  is  then we define

To check that the conclusion of the lemma is satisfied, we apply the
previous lemma to see that, not only for the history  in question
but also for any , if either of \val sX\eta\ and \val
s{X'}\eta\ is defined then so is the other, and similarly for .
With this information and
with the knowledge that \ttt{true} and \ttt{false} denote the same
element in  and  (because of agreement on , which
contains \ttt{true} and \ttt{false}), one finds by inspection of the
relevant clauses in the semantics of guards that the conclusion of the
lemma holds.

If  is  or , then we set

Finally, we set

Again, inspection of the relevant clauses in the semantics of guards
shows that the conclusion of the lemma holds.
\end{proof}

Finally, we prove the corresponding result for rules.

\begin{la}
For every rule , there is a bounded exploration witness .
\end{la}

\begin{proof}
We define  by recursion on  as follows.

If  is an update rule , then


If  is , then


If  is \ttt{fail} then  is empty.

If  is a conditional rule , then


If  is a parallel combination  then


That  serves as a bounded exploration witness for  is proved
by induction on .  Every case of the inductive proof is trivial in
view of the previous lemmas and the definition of the semantics of
rules.
\end{proof}

\section{Algorithms are Equivalent to ASMs}   \label{sec:thesis}

In this section, we shall prove the Abstract State Machine Thesis for
interactive, small-step algorithms.  That is, we shall prove that
every algorithm (as defined in \cite[Section~3]{ga1}) is equivalent
(as defined in \cite[Section~4]{ga1}) to an ASM (as in
Definition~\ref{asm-def}).

Throughout this section, we assume that we are given an interactive,
small-step algorithm .  By definition, it has a set \scr S of
states, a set \scr I of initial states, a finite vocabulary
, a finite set  of labels, causality relations
, sets  of final histories, subsets 
and  of successful and failing final histories, and
update sets .  Here and throughout this section, 
ranges over states and  over histories for .  Furthermore,
 has, by the Bounded Work Postulate of \cite{ga1} and its
corollaries, a bound  for the number and lengths of the queries
issued in any state under any attainable history, and it has a
bounded exploration witness . Since  retains the property of
being a bounded exploration witness if more -terms are
added to it, we may assume that  is closed under subterms and
contains \ttt{true,\ false}, and some variable.

To define an ASM equivalent to , we must specify, according to
Definition~\ref{asm-def},
\begin{itemize}
\item its vocabulary,
\item its set of labels,
\item its external vocabulary,
\item its program,
\item its template assignment,
\item its set of states, and its set of initial states.
\end{itemize}

\subsection{Vocabulary, labels, states}

Some of these specifications are obvious, because the definition of
equivalence requires that the vocabulary, the labels, the states, and
the initial states be the same for our ASM as they are for the given
algorithm . It remains to define the external vocabulary, the
template assignment, and the program.

Before proceeding, we note that Definition~\ref{asm-def} requires \scr
S and \scr I to be closed under isomorphisms and requires \scr S to be
closed under the transitions of the ASM.  The first of these
requirements is satisfied by our choice of \scr S and \scr I because
 satisfies the Isomorphism Postulate.  That the second requirement
is also satisfied will be clear once we verify that the update sets
and therefore the transition functions of  and of our ASM agree (at
least on successful final histories), for the Step Postulate ensures
that \scr S is closed under the transitions of .

\subsection{External vocabulary and templates}
\label{sub:extvoc}

To define the external vocabulary  and the template assignment for
our ASM, we consider all templates, of length at most , for the
given set  of labels, in which the placeholders  occur
in order.  (Recall that  is an upper bound on the lengths of
queries issued by algorithm  in arbitrary states for arbitrary
attainable histories.)  These templates, which we call \emph{standard
templates}, can be equivalently described as the tuples obtained by
taking any initial segment of the list  of placeholders
and inserting elements of  into such a tuple, while keeping
the total length of the tuple .  We note that any potential
query of length  (over any state) is obtained from a unique
standard template by substituting elements of the state for the
placeholders.  We define the external vocabulary  and the template
assignment simultaneously by putting into  one function symbol 
for each standard template and writing  for the standard
template associated to .  Define an external function symbol  to
be -ary if  is a template for -ary functions.

\begin{rmk}
For many algorithms, the external vocabulary defined here is larger
than necessary; many symbols in  won't occur in the program .
One can, of course, discard such superfluous symbols once  is
defined.  We chose the present definition of  in order to make it
independent of the more complicated considerations involved in
defining .  
\qed\end{rmk}

\begin{rmk}
We have not specified --- nor is there any need to specify --- exactly
what entities should serve as the external function symbols 
associated to templates .  The simplest choice mathematically
would be to take the function symbols to be the standard templates
themselves, but even with this choice, which would make , it
would seem worthwhile to maintain the notational distinction between
, to be thought of as a function symbol, and , to be
thought of as a template.
\qed\end{rmk}

\subsection{Critical elements, critical terms, agreement}

The preceding discussion completes the easy part of the definition
of our ASM; the hard part that remains is to define the program
. Looking at the characterization in Lemma 4.3 of \cite{ga1},
we find that we have (trivially) satisfied the first requirement for
the equivalence of our ASM and the given  (agreement as to
states, initial states, vocabulary, and labels), and that we must
construct  so as to satisfy the remaining three requirements
(agreement as to queries issued, finality, success, failure, and
updates).  Notice that these three requirements refer only to
histories that are attainable for both algorithms.  This means that,
in constructing , we can safely ignore what  does with
unattainable histories.

As in the proofs of the ASM thesis for other classes of algorithms in
\cite{seqth, parth, oa3}, we use the bounded exploration witness to gain
enough control over the behavior of the algorithm  to match it with
an ASM.  The first step in this process is the following lemma, whose
basic idea goes back to \cite{seqth}.

\begin{df}
  Let  be a state and  a history for it.  An element 
  is \emph{critical} for  and  if there is a term  and
  there are values in  for the variables in  such
  that the resulting value for  is .
\qed\end{df}

\begin{la}[Critical Elements]    \label{crit-la}
Let  be a state,  a coherent history for it, and  an
element of . Assume that one of the following holds.
\begin{ls}
  \item There is a query  such that  and  is one
  of the components of the tuple .
  \item There is an update 
  such that  is one of the 's or .
\end{ls}
Then  is critical for  and .
\end{la}

\begin{proof}
The proof is very similar to the one in \cite[Propositions~5.23 and
5.24]{oa1}, so we shall be rather brief here.
We may assume, as an
induction hypothesis, that the lemma holds when  is replaced with
any proper initial segment of .  (This is legitimate because
initial segments inherit coherence from .)
Because  is coherent, every query in its domain is caused by
some proper initial segment.  So all components in  of such a query
are critical for that initial segment and therefore also critical for
.

Assume that  is not critical for  and ; we shall show that
neither of the two hypotheses about  can hold.

Form a new state , isomorphic to , by replacing  by a new
element .  Since  is not critical, it is neither a component of
a query in \dom{\ans\xi} nor an element of \ran{\ans\xi}.  Thus  is a
history for  as well as for .  Using again the assumption that
 is not critical, one finds that  and  agree on
.  As  is a bounded exploration witness for , and as  is
obviously neither a component of a query caused by  over  nor
a component in an update in  (because ), it
follows that  is neither a component of a query caused by 
over  nor a component in an update in .
\end{proof}

The construction of our ASM will be similar to that in
\cite[Section~5]{oa3}, but some additional work will be needed to
take into account the timing information in histories and the
possibility of incomplete but final histories.

The role played by element tags (or e-tags) and query tags (or q-tags)
in \cite{oa3} will now be played by ASM-terms, i.e., variable-free
terms over the vocabulary . Some of these terms, those
with outermost function-symbol in , will, by
Definition~\ref{term-val-def}, obtain two kinds of possible values:
the ordinary value which is an element of the state, and also a
query-value, which is a potential query.

\begin{df}[Critical Terms] Recall that an ASM-term is a
  closed term of the vocabulary .
  \begin{ls}
    \item A critical  term of \emph{level} 0 is a closed term in the
    bounded exploration witness .
    \item If  are critical terms with maximal level
     and  is a -ary function symbol in , then
     is a critical q-term of level .
    \item If  contains exactly the variables 
    and if  are critical q-terms with maximal level ,
    then the result of substituting  for  in , , is a critical term of level .
    \item By a \emph{critical  term} we mean a critical  term of some level.
  \end{ls}
\qed\end{df}

Because we arranged for  to contain a variable, the third clause of
the definition implies that every critical q-term is a critical term
(of the same level), so our terminology is consistent.

Since  and the external vocabulary  are finite, there are
only finitely many critical terms of any one level.

Notice that, although they are obtained from the -terms
in , our critical terms are ASM-terms.  That is, they
contain no variables, but they can contain external function
symbols.

The values of ASM-terms, including in particular critical terms, for
a given state  and history , as well as the query-values of
q-terms, were defined in Definition~\ref{term-val-def}.

Recall also that, according to Lemma~\ref{mon-t}, any term that has
a value in state  with respect to an initial segment of 
will have the same value with respect to  itself, and that the
same holds of query values. The next lemma records some related
facts for future reference. Recall that two pairs  of a
state and history are said to agree on  if the two histories are
the same and every term in  gets the same values (if any) in both
states when the variables are given values in the range of the
history.

\begin{la}[Invariance of Values]  \label{tag-val-invar}
\mbox{}
  \begin{ls}
    \item If  is an isomorphism,  is a history for
    , and  is any ASM-term, then .
    If  is a q-term, then also .
    \item If  and  agree on , then  for all critical terms , and
     for all critical q-terms .
  \end{ls}
\end{la}

\begin{proof}
  The first assertion is proved by induction on terms, using the
  Isomorphism Postulate.  The second is proved by induction on
  critical terms and critical q-terms, using the facts that all
  critical terms are, by definition, in the bounded exploration
  witness  and that the same history  is used on both sides of
  the claimed equations.
\end{proof}

\begin{rmk}
An approximation to the intuition behind critical terms is that critical
terms of level  represent (for a state  and history ) the
elements of  and the queries that can play a role in the computation of
our algorithm  during the first  rounds or phases of its interaction
with the environment.  This is based on the intuition that the bounded
exploration witness  represents all the things the algorithm can do,
with the environment's replies, to focus its attention on elements of .
At first, before receiving any information from the environment (indeed,
before even issuing any queries), the algorithm can focus only on the
values of closed terms from , i.e., the values of critical terms of
level 0.  Using these, it can formulate and issue queries; these will be
query-values of q-terms of level 1.  Once some replies are received to
those queries, the algorithm can focus on the values of non-closed terms
from  with the replies as values for the variables.  The replies are
the values for the q-terms of level 1 that denote the issued queries, and
so the elements to which the algorithm now pays attention are the values
of critical terms of level .  Using them, it assembles and issues
queries, query-values of q-terms of level . The replies, used as
values of the variables in terms from , give the new elements to which
the algorithm can pay attention, and these are the values of critical
terms of level .  The process continues similarly for later rounds
of the interaction with the environment and correspondingly higher level
terms.

One should, however, be careful not to assume too much about the
connection between levels of critical terms and rounds of
interaction. It is possible for a critical term  of level 1 to
acquire a value only after many rounds of interaction, if, for
example, the history happens to answer many other queries, one after
the other, before finally getting to one that is needed for evaluating
.  It is also possible for a critical term of high level to acquire
a value earlier than its level would suggest. Consider, for example, a
critical term of the form , where  is an external
function symbol and 0 is a constant symbol from .  If the
history  contains just one reply, giving the query 
the value , then this suffices to give  the value
.

The following lemma formalizes the part of this intuitive explanation
that we shall need later.
\qed\end{rmk}

\begin{la}[Critical Terms Suffice]  \label{tags-suff}
Let  be a state,  an attainable history for it, and  the
length of .
\begin{ls}
  \item Every query in \dom{\ans\xi}\ is the query-value (for  and ) of
some critical q-term of level .
   \item Every element of \ran{\ans\xi} is the value (for  and
   ) of some critical q-term of level .
   \item Every critical element for  and  is the value (for
    and ) of a critical term of level .
   \item Every query in  is the query-value (for  and
) of some critical q-term of level .
\end{ls}
\end{la}

\begin{proof}
We proceed by induction on the length  of the history . As
 is coherent, any query in its domain is issued by a proper
initial segment .  So, by induction hypothesis
(applied to the last clause), such a query is the query-value of a
q-term of level . This proves the
first assertion of the lemma.

The second follows, because, if a query in \dom{\ans\xi}\ is the
query-value of a q-term of level , then the reply given by
 is the value of the same term.

For the third assertion, consider any critical element, say the value
of a term  when the variables of  are given certain values
in \ran{\ans\xi}.  By the second assertion already proved, these
values of the variables are also the values of certain critical
q-terms of level . Substituting these terms for the variables
in , we obtain a critical term of level  whose value is the
given critical element.

For the final assertion, consider any query issued by .  It has
length at most  (by our choice of ), so it is obtained by
substituting elements of  for the placeholders in some standard
template.  That is, it has the form  for some
external function symbol  and some elements .  By
Lemma~\ref{crit-la}, each  is critical with respect to  and
.  By the third assertion already proved, each  is the value
of some critical term  of level .  Then our query  is the query-value of the critical q-term
 of level .
\end{proof}

As indicated earlier, we can confine our attention to attainable
histories.  The lengths of these are bounded by , and so we
may, by the lemma just proved, confine our attention to critical
terms of level at most .  In particular, only a finite set of
critical terms will be under consideration.

We have the following partial converse to the last statement of
Invariance of Values Lemma~\ref{tag-val-invar}.  We abbreviate the
phrase ``pair consisting of a state and an attainable history for it''
as ``attainable pair.''

\begin{la}[Agreement]\label{lemma:agree}
Let  be attainable pairs with  of length .
If they agree as to the values of all critical terms of level
, then they agree on .
\end{la}

\begin{proof}
Note that in the assumption we didn't mention agreement as to
query-values. But  and  will agree as to
query-values of critical q-terms of level  as soon as they agree as
to the values of critical terms of levels .

Let . We need to prove that it takes the same value in
 and  when all variables in  are given values
in . But values in  are, by the
Critical Terms Suffice Lemma~\ref{tags-suff}, the values of some
critical q-terms of level . Substituting these terms for the
variables in  gives us, by definition, a critical term of level
, where by assumption  and  agree.
\end{proof}

\subsection{Descriptions, similarity}

The following definitions are intended to capture all the information
about a state and history that can be relevant to the execution of our
algorithm .  That they succeed will be the content of the subsequent
discussion and lemmas.

\begin{df}
Let  be an attainable pair.  Let  be
the length of .  (Recall that  is finite and in fact .)  Define the \emph{truncation}  of  to be the initial
segment of  of length  (undefined if ).  The
\emph{description}  of  and  is the Kleene
conjunction of the following guards:
\begin{ls}
\item all equations  and negated equations  that have
  value \ttt{true} in , where  and  are critical terms
  of level , and
\item all timing inequalities  and  that
  have value \ttt{true} in , where  and  are critical
  q-terms of level , and where \qval vX\xi\ exists and is in
  .
\end{ls}
\qed\end{df}

Some comments may help to clarify the last clause here, about
timing inequalities.  First, recall that the strict inequality
 is merely an abbreviation of .

Second, although we explicitly require only  to have a query-value
in ,
the same requirement for  is included in the
requirement that  or  is true.  Indeed,
inspection of the definition of the semantics of timing guards (in
Definition~\ref{guard-sem-def}) shows that the q-term  must have a
value, and this is possible only if  has a query-value in
\dom{\ans\xi}.  Since  is coherent, it follows that \qval uX\xi\
must be in .

Third, if  then  is undefined, and as a result
 contains no timing inequalities.

Our definition of the description of  and  is not complete on
the syntactic level, for it does not specify the order or
parenthesization of the conjuncts in the Kleene conjunction.  That is,
it is complete only up to associativity and commutativity of .
The reader is invited to supply any desired syntactic precision; it
will never be used. The choice of order and parenthesization of
conjuncts makes no semantic difference; the Kleene conjunction and
disjunction are commutative and associative as far as truth values and
issued queries are concerned.

We shall sometimes refer to descriptions of attainable pairs as
\emph{attainable descriptions}, even though ``attainable'' is
redundant here because the descriptions have been defined only for
attainable pairs.

The following lemma and its corollary provide useful information about
the q-terms occurring in a description.

\begin{la}
Let  be an attainable pair,  the length of , and
 a q-term.  The following are equivalent.
\begin{lsnum}
\item  occurs in .
\item  occurs as one side of a timing inequality in
  .
\item  is a critical q-term of level  and it has a
  query-value  that is in .
\end{lsnum}
\end{la}

\begin{proof}
Since the implication from (2) to (1) is trivial, we prove that (3)
implies (2) and that (1) implies (3).

Suppose first that (3) holds.  Let  be any query in the last
equivalence class of the preorder in .  As  is attainable,
.  Also, by Lemma~\ref{tags-suff},  for some critical q-term 
of level .  Because  is in the
last equivalence class with respect to , \val uX\xi\ exists but
\val uX{\xi-} does not.  Now if , which is also , is in \dom{\ans\xi}, then \val vX\xi\ exists and so
 contains the conjunct .  Otherwise, \val
vX\xi\ does not exist, and so  contains the conjunct
.  In either case, (2) holds.

Finally, we assume (1) and deduce (3).  Inspection of the definition
of descriptions reveals that any q-term  that occurs in
 must be a sub-q-term either of some critical term of
level  that has a value with respect to  or of some
critical q-term of level  that either has a value with respect
to  or at least has a query-value that is issued with respect
to .  In any case it follows, thanks to the attainability
(and in particular the coherence) of , that (3) holds.
\end{proof}

\begin{coro}
  The q-terms that occur in the description of an attainable pair
   depend only on  and , not on the last equivalence
  class in the preorder of \dom{\ans\xi}.
\end{coro}

\begin{proof}
  Immediate from the third of the equivalent statements in the lemma.
\end{proof}

Clearly,  is a guard, and
.  The next lemma shows that
descriptions are invariant under two important equivalence relations
on attainable pairs .

\begin{la}[Invariance of Descriptions] \label{invar-descr}
Let  be an attainable pair.
\begin{itemize}
\item If  is an attainable pair (with the same )
agreeing with  on , then they have the same
descriptions.
\item If  is an attainable pair isomorphic to ,
then they have the same descriptions.
\end{itemize}
\end{la}

\begin{proof} To see that the first statement is true, use the second
  clause of Invariance of Values Lemma~\ref{tag-val-invar} to
  establish that the same critical terms occur in
 and  in the same roles. To see that the
second statement is true, use the first clause of the same lemma.
\end{proof}

Thus, each of agreement and isomorphism is a sufficient condition for
similarity in the sense of the following definition.  We shall see
later, in Corollary~\ref{agree-cor}, that the composition of agreement
and isomorphism is not only sufficient but also necessary for
similarity.

\begin{df} Two attainable pairs are \emph{similar} if they have the
  same descriptions.
\qed\end{df}

 The next lemma describes the other states and histories in which
 is true, and thus leads to a characterization of
similar attainable pairs.

\begin{la}   \label{agree-la}
Let  and  be attainable pairs.  Suppose
 has value \ttt{true} in .  Then
\begin{itemize}
\item the length of  is at least the length of ;
\item there is an attainable pair  isomorphic to ,
  such that  is an initial segment of  and 
  agrees with  on .
\end{itemize}
\end{la}

In other words, any  that satisfies the description of
 can be obtained from  by the following three-step
process.  First, replace  by an isomorphic copy .
Second, leaving the history  unchanged, replace  by a new
state  but maintain agreement on the bounded exploration witness
.  Third, extend the history  by adding new items strictly
after the ones in , so that  is an initial segment of
the resulting .

Notice that, by virtue of the isomorphism of  and
, we can describe  more specifically as the initial
segment of  of the same length as .

\begin{proof}
We proceed by induction on the length  of the history .

\smallskip\noindent\textbf{Length:  is not shorter than .}
Choose one query from each of the  equivalence classes in
\dom{\ans\xi}, say  from the  equivalence class.  Letting
 denote the initial segment of  of length , and
applying Lemma~\ref{tags-suff}, we express each  as the query-value,
with respect to , of some critical q-term  of level
.  Thus,  has a value  with respect to
 but not with respect to .  Thus,
 includes the conjuncts  for
 and also the conjunct .  So these conjuncts
must also be true in , which means that  has length at
least .

\medskip\noindent\textbf{Construction of .} Our next
step will be to define a certain isomorphic copy  of
.  Afterward, we shall verify that  has the other
properties required.

 We may assume, by replacing  with an isomorphic copy if
necessary, that  is disjoint from .  Next, obtain an isomorphic
copy  of  as follows.  For each critical term  of level , if \val tX\xi\ exists, then remove this element from  and put
in its place the element \val tY\eta\ of .  To see that this makes
sense, we must observe two things.  First, the equation  is one
of the conjuncts in  and is therefore true for  and
.  Thus, the replacement element \val tY\eta\ exists.  Second,
if the same element of  is also \val{t'}X\xi\ for another critical
term  of level , then the equation  is a conjunct in
 and is therefore true for  and .  Thus,
\val{t'}Y\eta=\val tY\eta, which means that the replacement element is
uniquely defined.

Let  be the obvious isomorphism from  to , sending each of
the replaced elements \val tX\xi\ to its replacement \val tY\eta\ and
sending all the other elements of  to themselves.  Let
; this is the history for  obtained by applying  to
all components from  in the queries in \dom{\ans\xi}\ and to all the
replies in \ran{\ans\xi}.  Because of the isomorphism, it is clear
that  is, like , an attainable pair and that
 has the same length  as .

\medskip\noindent\textbf{Values:  is a subfunction of .}  Consider any query 
and its reply .  Thus, , and
.  Furthermore, every element of
\dom{i(\ans\xi)} is  for some such .  By
Lemma~\ref{tags-suff}, all the  are values in  of
certain critical terms  of level , and so  is the value of
the critical term  of level .  In forming
, we replaced the elements  by the values  of the
's in , and we replaced  by , the value in
 of .  But this last value is, by
definition, the result of applying  to the query that is the
query-value of , namely the query .  That is, .  This
shows that, whenever  maps a query  to a reply
, then so does ; in other words,  is a
subfunction of .

\medskip\noindent\textbf{Order:  is a sub-preorder of
.} We next show that the preordering of  agrees with
that of .  Consider an arbitrary , and
suppose it is in the  equivalence class with respect to the
preorder given by .  So, as  is coherent,
, and so, by the last part of
Lemma~\ref{tags-suff}, we have a critical q-term  of level 
such that .  Note that \val
uX{\xi\restr(j-1)} does not exist, because
.

We wish to apply the induction hypothesis to .  To
do so, we observe that  is a subconjunction
of  and is therefore true in .  So we can
apply the induction hypothesis and find that  is
isomorphic to an attainable pair that agrees with
.  By Lemma~\ref{tag-val-invar},  has a
query-value but no value in .  Inspection of the
definitions shows that its query-value is .

If , i.e., if , then we can also apply the
induction hypothesis to , in which  has a value.
We conclude that  has a value in .  Since it had
a query-value but no value in , we conclude that
its query-value,  must be in exactly the  equivalence
class with respect to .

If, on the other hand, , i.e., if  is in the last equivalence
class with respect to , then this last application of the
induction hypothesis is not available.  Nevertheless, since
, we know that  has a value in , so
 contains the conjunct , so this conjunct is true
also in , and so  has a value in .  This means
that , the query-value of , is in .  We saw
earlier that it is not in , where now
.  So  is in the  equivalence class or later with
respect to .

What we have proved so far suffices to establish that if 
then  and that the same holds for non-strict
inequalities except in the case that both  and  are in the last
equivalence class with respect to .  In this exceptional case, we
know that  is the query-value, already existing in
, of  (as above), yet  has no value in
. This means that the smallest  for which \val
uY{\eta\restr m} exists is the  such that  is in the 
equivalence class with respect to .  Repeating the argument with
an analogously defined q-term  for , and using the fact that
 contains the conjuncts  and , which means that these conjuncts are also true in , we
find that  and  are in the same equivalence class with
respect to .

This completes the proof that  --- including both the answer
function and the pre-order --- is the restriction of  to some
subset of its domain.  In fact, we have shown more, namely that, for
,  maps the  equivalence class with respect to 
into the  equivalence class with respect to , and that it
maps the last () equivalence class with respect to  into a
single equivalence class --- possibly the  and possibly later
--- with repect to .

The next step is to show that  is an initial segment of
.  This will imply that, in the preceding summary of what was
already proved, both occurrences of ``into'' can be improved to
``onto'' and ``possibly the  and possibly later'' can be
improved to ``the ''.

\medskip\noindent\textbf{Initial segment:  is an initial
segment of .}  Suppose, toward a contradiction, that
\dom{\ans\eta'} is not an initial segment of \dom{\ans\eta} (with
respect to ).  So there exist some
 and some 
(and thus ) such that .
Among all such pairs , fix one for which  occurs as early as
possible in the preorder .  Since , we
can fix a critical q-term  of level  with
 and thus, by definition of ,
.  We record for future reference that, since
,  has a value with respect to
.

Consider the initial segment of  up to but not including . By
what we have already proved (and our choice of  as the earliest
possible), it is  for some proper initial segment  of
 --- proper because it doesn't contain .  In particular,
 has length at most , and so we know, by induction
hypothesis, that the lemma is true with  in place of .
(As before, the lemma can be applied because  is a
subconjunction of , which is true in .)  So
we conclude that  is isomorphic to an attainable pair that
agrees on  with .

Since  is the initial segment of  ending just before
, and since  is a coherent history, we know that
.  By the Critical Terms Suffice
Lemma~\ref{tags-suff},  is the query-value in , and
therefore also in , of some critical q-term  of level
. Thanks to the isomorphism between  and an
attainable pair agreeing with , we have that  also
has a query-value, say , in  and this value is in
 and, a fortiori, in .  By
definition of , . As  was chosen outside
, it follows that
. From this and , we
conclude that  is one of the conjuncts in 
and is therefore true in . Since  has a value in the
initial segment of  up to and including  (one equivalence
class beyond ), we infer that  must have a value in
.  That means that the query-value of , namely
 must be in the domain of , i.e., .
This contradicts the original choice of  and , and this
contradiction completes the proof that  is an initial segment
of .

\medskip\noindent\textbf{Agreement:  and  agree
  on .}
It remains to prove that the attainable pairs  and
 agree on .  We prove this in three steps.

First, we show that, if  is any critical term of level , then

This is almost the definition of , which says that .  Our task is to replace  on the right
side of this equation with .  That is, we must show that,
if \val zX\xi\ exists (and therefore \val zY\eta\ exists), then
\val zY{\eta'} exists, because then we shall have  by the monotonicity of values.  We proceed
by induction on the level of .
The only non-trivial case, i.e., the only case where changing
 to  could matter, is the case that  is a q-term.
The possibility that we must exclude is that  (which
is also \qval zY{\eta'} as the induction hypothesis applies to the
arguments of ) is in the domain of  but not in the domain
of . But  exists and is in the domain of 
(because \val zX\xi\ exists), and its image under  is, by
definition of , \qval zY\eta.  So this image is in the domain
of , as desired.

Second, we observe that, since  is an isomorphism from  to 
and sends  to , we have .
Combining this with the result established in the preceding paragraph,
we have

for all critical terms  of level .

Finally, an application of the Agreement Lemma~\ref{lemma:agree}
completes the proof that  and  agree on .
\end{proof}

\begin{coro}[Factorization]    \label{agree-cor}
Let  and  be similar attainable pairs.   Then
there is a state  such that  is an attainable history for
,  agrees with  on , and  is
isomorphic to .
\end{coro}

\begin{proof}
We can apply Lemma~\ref{agree-la} to  and  in
either order, since each satisfies the other's description.  Thus
 and  have the same length, and the  of the lemma is
simply .  The rest of the corollary is contained in the lemma.
\end{proof}

\begin{coro}[Similarity Suffices]    \label{descr-suff}
Let  and  be similar attainable pairs.   Let
 be the length of  (and of , by
Corollary~\ref{agree-cor}). Then
\begin{ls}
\item If  is a q-term of level  and 
  then .
\item If  is in  or , then  is in
   or , respectively.
\item If  contains an update \sq{f,\sq{a_1,\dots,a_k},a_0}
  where each  is  for a critical term  of level , then  contains the update
  \sq{f,\sq{a'_1,\dots,a'_k},a'_0} where each  is
  .
\end{ls}
\end{coro}

\begin{proof}
Apply the preceding corollary to get  such that 
agrees with  on  and is isomorphic to .
Because of the agreement on the bounded exploration witness ,
we have all the desired conclusions with  in place of
.  To complete the proof, we can replace  with
, thanks to the Isomorphism Postulate and the fact that
isomorphisms respect evaluation of terms.
\end{proof}

We shall also need the notion of a \emph{successor} of an attainable
description.  This corresponds to adjoining one new equivalence class
at the end of a history, while leaving the state unchanged. That is,
 is a successor of , and
 is the \emph{predecessor} of .

\begin{rmk}
To avoid possible confusion, we emphasize that a successor of
 need not be of the form  with
.  It could instead be of the form  for some
other pair  such that  is similar to ,
and there might be no way to extend  so as to obtain similarity
with .  For a simple example, suppose the bounded exploration
witness  contains only \ttt{true}, \ttt{false}, \ttt{undef}, and a
variable.  Let  be a structure containing only the three elements
that are the values of \ttt{true}, \ttt{false}, and \ttt{undef}, and
let  be like  but with one additional element .  Suppose
further that the algorithm is such that a single query , say
\sq{\ttt{true}}, is caused by the empty history  in every state.
Then  and  agree on , and  admits an
attainable history  with  and with
.  Then, since , we have that 
is a successor of .  But there is no
history  for  such that ; such
a  would have to map  to a value distinct from \ttt{true},
\ttt{false}, and \ttt{undef}, and  has no such element.
\qed\end{rmk}

The use of the definite article in ``the predecessor'' is justified by
the following observation, showing that  is completely
determined by .  Thus, ``predecessor'' is a
well-defined operation on attainable descriptions of non-zero length.
Of course the situation is quite different for successors; one
description can have many successors because there are in general many
ways to extend an attainable history by appending one more equivalence
class.

\begin{coro}
  Let  and  be similar attainable pairs,
  and assume the (common) length of  and  is
  not zero.  Then .
\end{coro}

\begin{proof}
By Corollary~\ref{agree-cor}, we have an isomorphism
 such that  agrees with 
on .  Since the isomorphism  must, in particular, respect the
pre-orderings, it follows immediately that  is also an isomorphism
from  to .  From the definition of agreement, it
follows immediately that  and  agree on .
Thus, by Lemma~\ref{invar-descr},  and  are
similar.
\end{proof}

The following information about successors will be useful when we
verify that the ASM that we produce is equivalent to the given
algorithm .

\begin{la}   \label{successor}
  Suppose  is an attainable pair and  is an
  attainable description that is a successor of .
  Then  for some attainable pair 
  such that
  \begin{ls}
    \item ,
    \item  and  agree on .
  \end{ls}
\end{la}

\begin{proof}
By definition of successor, we have an attainable pair 
such that  and
.  This last equality implies, by
Corollary~\ref{agree-cor}, that  and  agree on 
for some attainable pair  isomorphic to .  Use
the isomorphism to transport  to an attainable history 
for .  Then  because of
the isomorphism, and  is the image, under the isomorphism, of
, i.e., .
\end{proof}

\subsection{The ASM program}

We are now ready to describe the ASM program that will simulate our
given algorithm .  Its structure will be a nested alternation of
conditionals and parallel combinations, with updates, issue rules, and
\ttt{fail} as the innermost constituents.  The guards of the
conditional subrules will be attainable descriptions.  Recall that the
critical terms involved in attainable descriptions all have levels
, and there are only finitely many such terms and therefore
only finitely many attainable descriptions.  An attainable description
 will be said to have \emph{depth} equal to the length
of .  Lemma~\ref{agree-la} ensures that this depth depends only
on the description , not on the particular attainable
pair  from which it is obtained.  Notice that the definition
of descriptions immediately implies that any critical term occurring
in a description has level  the depth of the description.


We construct the program  for an ASM equivalent to the given
algorithm  as follows.   is a parallel combination, with one
component for each attainable description  of depth zero. We
describe the component associated to  under the assumption
that  is not final, by which we mean that, in the attainable
pairs  with description , the history  is not
final; we shall return later to the final case.  (Recall
that, by Corollary~\ref{descr-suff}, whether  is final in 
depends only on the description , so our case
distinction here is unambiguous.)

The component associated to a non-final  is a conditional rule
of the form , i.e., a
conditional whose guard is  itself.  The body  is a
parallel combination, with one component for each successor 
of .

When  is not final, the associated component is
a conditional rule .  The
body  here is a parallel combination, with one component
for each successor  of .

Continue in this manner until a final description  is reached.
Since the depth increases by one when we pass from a description to a
successor, and since all attainable histories have length (i.e., the
depth of their descriptions) at most , we will have reached final
descriptions after at most  iterations of the procedure.  The
component associated to a final description  is
, where  is
the parallel combination of the following:
\begin{ls}
\item \ttt{fail} if ,
\item  if  is a q-term of level at most one more
than the length of  (that is, the depth of ) and
, and
\item  if the  are critical terms of
level at most
  the length of  and they have values  such
  that .
\end{ls}
It is important to note that, although the attainable pair
 was used in the specification of these components, they
actually depend only on the description , by
Corollary~\ref{descr-suff}. This completes the definition of the
program .

\begin{rmk}
  As in previous work on the ASM thesis, this program  is
  designed specifically for the proof of the thesis.  That is, it
  works in complete generality and it admits a fairly simple, uniform
  construction.  For practical programming of specific algorithms,
  there will normally be ASM programs far simpler than the one
  produced by our general method.
\end{rmk}

\subsection{Equivalence}

It remains to show that the ASM defined by  is equivalent to the
given algorithm .  For brevity, we sometimes refer to this ASM as
simply .

\begin{thm}   \label{main-thm}
The ASM defined by  together with  \scr S, \scr I,
  , , , and the template assignment of
  subsection~\ref{sub:extvoc} is equivalent to algorithm .
\end{thm}

\begin{proof}
 Referring to Lemma 4.3 of \cite{ga1}, we see that it suffices to
show the following, for every pair  that is attainable for
both the algorithm  and our ASM.
\begin{lsnum}
\item  is the same for our ASM as for .
\item If  is in  or  with respect to one
  of  and our ASM,
  then the same is true with respect to the other.
\item If , then  is the same with
  respect to our ASM and with respect to .
\end{lsnum}

Consider, therefore, an attainable pair  (with respect to
) and the behavior of our ASM in this pair.

Let  be the length of , and for each  let  be the initial segment of  of length .  According to
Lemma~\ref{agree-la}, the only attainable descriptions satisfied by
 are those of the form , one of each
depth .

\medskip\noindent\textbf{Issuing Queries.}

We begin by analyzing the queries issued by our ASM in state 
with history .  (Parts of this analysis will be useful again
later, when we analyze finality, success, failure, and updates.)
For readability, our analysis will be phrased in terms of the ASM
performing various actions, such as issuing queries or passing
control to a branch of a conditional rule.  Of course, this could
be rewritten more formally in terms of the detailed  semantics of
ASMs, but the formalization seems to entail more costs, both for
the reader and for the authors, than benefits.

The ASM acting in state  with history  begins, since 
is a parallel combination, by executing all the components
associated with attainable descriptions of depth 0.  Recall that
these components are conditional rules whose guards are the
descriptions themselves. These descriptions contain only critical
terms of depth 0, so there are no external function symbols here.
Therefore, no queries result from the evaluation of the guards. By
Lemma~\ref{agree-la} the ASM finds exactly one of the guards to be
true, namely , and it proceeds to execute
the body  of this conditional rule.

Let us suppose, temporarily, that , so, as  is attainable,
 is not final.  (We shall return to the other case later.)
So  is a parallel combination, and our ASM
proceeds to execute its components.  These are conditionals, whose
guards  are the successors of .  So
these guards are  for attainable pairs  as in
Lemma~\ref{successor}.  In particular,  has length 1 and
.  (This last equation is redundant as both sides
are histories of length 0, but we include it to match what will occur
in later parts of our analysis.)  Inspection of the definition of
descriptions shows that every query issued during the evaluation of
such a guard is also issued by the algorithm  operating in the
attainable pair .  Since 
agrees with  on , these are queries issued by 
in .

The converse also holds.  If a query  is issued by  in
, then there is an attainable history  for
 in which  is in the first and only equivalence class of
; simply define  to give  an arbitrary reply
and to do nothing more.  By Lemma~\ref{tags-suff},  is the
query-value of some q-term  of level 1, and therefore
 contains the conjunct .  Thus, in evaluating
the guard , our ASM will issue .

Having evaluated the guards of depth 1, our ASM finds, according to
Lemma~\ref{agree-la}, that exactly one of them is true, namely
, so it proceeds to evaluate the corresponding
body .  Let us suppose, temporarily, that
, so, as  is attainable,  is not final.  So
 is a parallel combination, and our ASM
proceeds to execute its components.  These are conditionals, whose
guards  are the successors of .  So
these guards are  for attainable pairs  as
in Lemma~\ref{successor}.  In particular,  has length 2 and
.  Inspection of the definition of descriptions
shows that every query issued during the evaluation of such a guard is
also issued by the algorithm  operating in the attainable pair
.  Since  agrees with
 on , these are queries issued by  in
.

The converse also holds.  If a query  is issued by  in
, but not already in , then there is
an attainable history  for , which has  as an
initial segment, and in which  is in the second and
last equivalence class of ; simply define  by
extending  to give  an arbitrary reply, in a new,
second equivalence class, and to do nothing more.
By Lemma~\ref{tags-suff},  is the query-value of some critical term
 of level 2, and therefore  contains the conjunct
.  Thus, in evaluating the guard , our ASM will
issue .

The reader should, at this point, experience d\'ej\`a vu, since the
argument we have just given concerning the behavior of our ASM while
executing  is exactly parallel to the
previous argument concerning .  The same
pattern continues as long as the depths of the guards are  so that
we have not arrived at a final history.

Consider now what happens when the ASM evaluates
.  If the history 
is not final, then the same argument as before shows that the ASM will
issue, while evaluating the guards of the components of
, the same queries as the original algorithm .
Furthermore, the ASM will find none of the guards here to be true, for
these guards are descriptions of depth  and can, by
Lemma~\ref{agree-la}, be satisfied only with histories of length at
least .  So the execution of the ASM produces no additional
queries beyond those that we have already shown to agree with those
produced by .

There remains the situation that  is final for  and .  In
this case, the components of  are no longer
conditional rules, the evaluation of whose guards causes the
appropriate queries to be issued by the ASM.  Rather, the components
are issue rules, updates, or \ttt{fail}.  Only the issue rules here
will result in new queries; the queries involved in evaluating the
terms in update rules and in the issue rules have already been issued
during the evaluation of guards.  And the issue rules are chosen
precisely to issue the queries that  would issue in .

This completes the proof that our ASM and  agree as to issuing
queries.  They therefore agree as to which histories are coherent.

\medskip\noindent\textbf{Finality, Success, and Failure.}
We next consider which histories are declared final by our ASM.
Suppose first that  is final for  in .  Then, as the
preceding analysis of the ASM's behavior shows, the ASM will,
after evaluating a lot of guards, find itself executing
, which is a parallel combination of issue
rules, update rules, or \ttt{fail}.  The subterms of any update
rules here will already have been evaluated during the evaluation
of the guards, so  is final for these update rules.  The same
goes for the issue rules; their subterms have already been
evaluated, and so  is final.  Any history is final for
\ttt{fail}.  Thus  is final for all the components of
 and is therefore final for 
itself.  From the definition of the semantics of parallel combinations
and conditional rules, it follows that  is also final for ,
as required.

Now suppose that  is (attainable but) not final for  in
state .  There will be some queries that have been issued by
 but not answered, i.e., that are in
, for otherwise
 would be complete and attainable and therefore, by the Step
Postulate, final.  So our ASM will issue some queries whose
answers are needed for the evaluation of the guards of some
components of , but whose answers are not in
.  Therefore,  is not a final history for the ASM in
state .  This completes the proof that our ASM agrees with 
as to finality of histories.


We check next that a final history  succeeds or fails for our
ASM according to whether it succeeds or fails for . It fails
for our ASM if and only if, after evaluating all the guards and
while executing , it encounters either
\ttt{fail} or clashing updates (see the definition of failure for
parallel combinations).  By definition of our ASM, it encounters
\ttt{fail} if and only if  fails in . Furthermore, it
will not encounter clashing updates unless  fails, because, as
we shall see below, it encounters exactly the updates produced by
, and these cannot, by the Step Postulate, clash unless 
fails.

\medskip\noindent\textbf{Updates.} To complete the proof, we have to
 check what updates our ASM encounters.  Our
construction of  is such that update rules are encountered
only in the subrules  for final histories
. Furthermore, these update subrules are chosen to match the
updates performed by .  So our ASM and  produce the same
updates in any final history.

This completes the verification that our ASM is equivalent to the
given algorithm .
\end{proof}

\section{Concluding Remarks}

Theorem~\ref{main-thm} establishes the ASM thesis for small-step,
interactive algorithms, as defined by the postulates of \cite{ga1}.
This completes the program of proving the ASM thesis in the small-step
case.  The case of parallel algorithms, without intrastep interaction,
was treated in \cite{parth}, but the task of combining intrastep
interaction with parallelism remains for future work.  Beyond that,
there is the task of treating distributed algorithms.  

The ASM syntax and semantics presented in Sections~\ref{sec:asm} and
\ref{asm-sem} serve to describe just what has to be added to the
traditional ASM syntax and semantics of \cite{G103} in order to
accommodate non-ordinary interaction.  Essentially, one needs timing
guards and the Kleene connectives.  It remains to be seen whether
these additions will also suffice to model all interactive parallel
algorithms.  

\begin{thebibliography}{99}

\bibitem{parth} Andreas Blass and Yuri Gurevich, ``Abstract state machines
capture parallel algorithms,'' \emph{ACM Trans. Computational Logic},
4 (2003) 578--651.

\bibitem{oa1}
Andreas Blass and Yuri Gurevich, ``Ordinary Interactive Small-Step
Algorithms, I,'' \emph{ACM Trans. Computational Logic}, 7 (2006)
363--419. 

\bibitem{oa2}
Andreas Blass and Yuri Gurevich, ``Ordinary Interactive Small-Step
Algorithms, II,'' \emph{ACM Trans. Computational Logic}, to
appear.

\bibitem{oa3}
Andreas Blass and Yuri Gurevich, ``Ordinary Interactive Small-Step
Algorithms, III,'' \emph{ACM Trans. Computational Logic}, to
appear.

\bibitem{ga1} Andreas Blass, Yuri Gurevich, Dean Rosenzweig, and
Benjamin Rossman, ``Interactive Small-Step Computation I:
Axiomatization,'' in preparation.

\bibitem{composite} Andreas Blass, Yuri Gurevich, Dean Rosenzweig, and
Benjamin Rossman, ``Composite interactive algorithms'' (tentative
title), in preparation.

\bibitem{G64.5}
Yuri Gurevich, ``A new thesis,'' Abstract 85T-68-203,
\emph{Amer. Math. Soc. Abstracts} 6 (August, 1985) p.317.

\bibitem{G92}
Yuri Gurevich,
``Evolving Algebras: An Introductory Tutorial,''
Bull. EATCS 43 (February 1991), 264--284.
Reprinted with slight revisions in
\emph{Current Trends in Theoretical Computer Science: Essays and Tutorials},
G. Rozenberg and A. Salomaa (editors),
World Scientific, 1993, 266-292

\bibitem{G103}
Yuri Gurevich,
``Evolving algebra 1993: Lipari guide,''
in \emph{Specification and Validation Methods},
E. B\"orger (editor), Oxford Univ. Press (1995) 9--36.

\bibitem{seqth}
Yuri Gurevich, ``Sequential abstract state machines capture sequential
algorithms,'' \emph{ACM Trans. Computational Logic} 1 (2000) 77--111.

\bibitem{web} James K. Huggins, ASM Michigan web page,
\href{http://www.eecs.umich.edu/gasm}
    {\ttt{http://www.eecs.umich.edu/gasm}}

\bibitem{Kleene} Stephen Cole Kleene, \emph{Introduction to
  Metamathematics},  Van Nostrand, 1952.

\end{thebibliography}
\vskip-40 pt
\end{document}
