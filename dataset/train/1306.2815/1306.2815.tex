\documentclass{sig-alternate}

\pdfoutput=1

\usepackage{alltt}
\usepackage{cite}
\usepackage{color}
\usepackage{comment}
\usepackage{enumerate}
\usepackage{euscript}
\usepackage{graphicx}
\usepackage{ifthen}
\usepackage{microtype}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{url}
\usepackage{xspace}

\def\ttt{\texttt}


\def\hgap{\textrm{\hspace{1mm}}}
\def\thmvgap{\vspace{0mm}}



\def\tab{\hspace{3mm}}
\def\tabpos{\hspace{4mm} \= \hspace{4mm} \= \hspace{4mm} \= \hspace{4mm} \=
\hspace{4mm} \= \hspace{4mm} \= \hspace{4mm} \= \hspace{4mm} \= \hspace{4mm}
\kill}



\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{proposition}{Proposition}
\newtheorem{observation}{Observation}
\newtheorem{definition}{Definition}
\newtheorem{problem}{Problem}



\def\bm{\boldmath}
\def\defeq{:=}
\def\eps{\epsilon}
\def\fr{\frac}
\def\-{\mbox{-}}
\def\inte{\mathbb{N}}
\def\ovline{\overline}
\def\real{\mathbb{R}}

\def\lc{\lceil}
\def\lf{\lfloor}
\def\rc{\rceil}
\def\rf{\rfloor}

\def\nn{\nonumber}

\def\Pr{\mathbf{Pr}}
\def\expt{\mathbf{E}}
\def\var{\mathbf{var}}

\def\*{\star}

\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\polylg}{polylg}
\DeclareMathOperator*{\polylog}{polylog}
\DeclareMathOperator*{\intr}{\cap}







\newcommand{\red}[1]{\textcolor{red}{#1}}

\def\figcapup{\vspace{-1mm}}
\def\figcapdown{\vspace{-2mm}}
\def\extraspacing{\vspace{2mm} \noindent}
\def\vgap{\vspace{1mm}}

\def\high{\mathit{high}}
\def\highend{\mathit{highend}}
\def\MAX{\mathit{MAX}}
\def\lmax{\mathit{LMAX}}
\def\eps{\epsilon}
\def\fr{\frac}
\def\leftdom{\mathit{leftdom}}
\def\rmax{\mathit{RMAX}}
\def\intr{\cap}
\def\T{\mathcal{T}}


\newboolean{arxivversion}
\setboolean{arxivversion}{true}
\newcommand{\arxivexcl}[2]{\ifthenelse{\boolean{arxivversion}}{#1}{#2}}

\newboolean{confversion}
\setboolean{confversion}{false}
\ifthenelse{\boolean{confversion}}{\includecomment{confenv}}{\excludecomment{confenv}}
\newcommand{\confcmt}[1]{\ifthenelse{\boolean{confversion}}{#1}{}}


\newboolean{fullversion}
\setboolean{fullversion}{true}
\ifthenelse{\boolean{fullversion}}{\includecomment{fullenv}}{\excludecomment{fullenv}}
\newcommand{\fullcmt}[1]{\ifthenelse{\boolean{fullversion}}{#1}{}}


\newcommand{\front}{\text{front}}
\newcommand{\first}{\text{first}}
\newcommand{\records}{\text{records}}
\newcommand{\last}{\text{last}}
\newcommand{\rest}{\text{rest}}
\newcommand{\bigO}{\mathcal{O}}
\newcommand{\smallO}{o}
\newcommand{\nil}{\textit{nil}}
\newcommand{\iref}[1]{\ref{#1}} \newcommand{\attr}[1]{\widetilde{#1}}
\renewcommand{}{\right)}

\urldef{\arxivurl}\url{http://arxiv.org/abs/1207.2341}

\usepackage{xcolor}
\usepackage{transparent}
\usepackage{graphicx}
\usepackage{import}

\newcommand{\executeiffilenewer}[3]{
 \ifnum\pdfstrcmp{\pdffilemoddate{#1}}
 {\pdffilemoddate{#2}}>0
 {\immediate\write18{#3}}\fi
}

\newcommand{\inkfig}[7]{
  \begin{figure}[#1]
    \centering
    \def\svgwidth{#2}
\executeiffilenewer{./figure/#3.svg}{./figure/#3.pdf}
     {inkscape -z -D --file=./figure/#3.svg
     --export-pdf=./figure/#3.pdf --export-latex}
#6
    \arxivexcl{\import{.}{#3.pdf_tex}}
    {\import{./figure/}{#3.pdf_tex}}
    #7
    \caption{#5}
    \label{#4}
  \end{figure}
}

\newcommand{\inkgraphics}[2]{
    \def\svgwidth{#1}
\executeiffilenewer{./figure/#2.svg}{./figure/#2.pdf}
     {inkscape -z -D --file=./figure/#2.svg
     --export-pdf=./figure/#2.pdf --export-latex}
\arxivexcl{\import{.}{#2.pdf_tex}}
    {\import{./figure/}{#2.pdf_tex}}
}

\newcommand{\fig}[6]{
  \begin{figure}[#1] \centering
    \begin{minipage}{#2\linewidth}
      \centering
      \arxivexcl{\includegraphics[#3]{#4}}
      {\includegraphics[#3]{./figure/#4}}
      \caption{#6}
      \label{#5}
    \end{minipage}
  \end{figure}
}

\newcommand{\yufeigraphics}[2]{
  \arxivexcl
   {\includegraphics[#1]{./#2}}
   {\includegraphics[#1]{./figure/#2}}
}

\usepackage{pifont} \newcommand\todo[1]{
  \ding{56}\textcolor{darkgray}{#1}
}

\begin{document}
\conferenceinfo{PODS'13,} {June 22--27, 2013, New York, New York, USA.}
\CopyrightYear{2013}
\crdata{978-1-4503-2066-5/13/06}
\clubpenalty=10000
\widowpenalty = 10000

\fullcmt{\title{I/O-Efficient Planar Range Skyline \\and Attrition Priority
Queues\thanks{\scriptsize This is the full version of our PODS 2013 paper
with the same title.}}}

\confcmt{\title{I/O-Efficient Planar Range Skyline \\and Attrition Priority
Queues\thanks{\scriptsize The full version is found on http://arxiv.org
under the same title.}}}

\numberofauthors{1}
\author{
	\begin{tabular}{c}
      Casper Kejlberg-Rasmussen \hspace{5mm} Yufei Tao \hspace{5mm}
      Konstantinos Tsakalidis \3mm]
    \affaddr{MADALGO\thanks{\scriptsize MADALGO (Center for Massive Data
    Algorithmics -- a Center of the Danish National Research Foundation)},
  Aarhus University} \\
		\affaddr{Chinese University of Hong Kong} \\
		\affaddr{Korea Advanced Institute of Science and Technology} \\
		\affaddr{Hong Kong University of Science and Technology} \\
		\affaddr{Aristotle University of Thessaloniki}
	\end{tabular}
}

\date{}
\maketitle

\begin{confenv}
\begin{abstract}
We study the static and dynamic \emph{planar range skyline reporting problem} in
the external memory model with block size , under a linear space budget.  The
problem asks for an  space data structure that stores  points in the
plane, and supports reporting the  maximal input points (a.k.a.\
\emph{skyline}) among the points that lie within a given query rectangle . When  is \emph{3-sided},
i.e. one of its edges is grounded, two variants arise: \emph{top-open} for
 and \emph{left-open} for  (symmetrically
\emph{bottom-open} and \emph{right-open}) queries.

We present optimal static data structures for \emph{top-open} queries, for the
cases where the universe is , a  grid, and rank space
. We also show that \emph{left-open} queries are harder, as they
require  I/Os for , when only linear
space is allowed. We show that the lower bound is tight, by a structure that
supports 4-sided queries in matching complexities.  Interestingly, these lower
and upper bounds coincide with those of the {\em planar orthogonal range
reporting problem}, i.e., the skyline requirement does not alter the problem
difficulty at all!

Finally, we present the first dynamic linear space data structure that supports
top-open queries in  and updates in
 worst case I/Os, for .  This also
yields a linear space data structure for 4-sided queries with optimal query I/Os
and  amortized update I/Os.  We consider of independent
interest the main component of our dynamic structures, a new real-time
I/O-efficient and catenable variant of the fundamental structure {\em priority
queue with attrition} by Sundar.
\end{abstract}
\end{confenv}

\begin{fullenv}
\begin{abstract}
In the \emph{planar range skyline reporting problem}, the goal is to store a set
 of  2D points in a structure such that, given a query rectangle , the maxima (a.k.a.\
\emph{skyline}) of    can be reported efficiently. The query is
\emph{3-sided} if an edge of  is grounded, giving rise to two variants:
\emph{top-open} () and \emph{left-open} ()
(symmetrically \emph{bottom-open} and \emph{right-open}) queries.

This paper presents comprehensive results in external memory under the
 space budget ( is the block size), covering both the static and
dynamic settings:
\begin{itemize}
  \item For static , we give structures that answer {\em top-open} queries in
    , , and 
    I/Os when the universe is , a  grid, and a rank
    space grid , respectively (where  is the number of reported
    points). The query complexity is optimal in all cases.

  \item We show that the {\em left-open} case is harder, such that any
    linear-size structure must incur  I/Os to
    answer a query. In fact, this case turns out to be just as difficult as the
    general 4-sided queries, for which we provide a static structure with the
    optimal query cost .

  \item We present a dynamic structure that supports top-open queries in
     I/Os, and updates in
     I/Os, for any  satisfying . This result also leads to a dynamic structure for 4-sided
    queries with optimal query cost , and amortized
    update cost .
\end{itemize}

As a contribution of independent interest, we propose an I/O-efficient version
of the fundamental structure {\em priority queue with attrition} (PQA). Our PQA
supports \textsc{FindMin}, \textsc{DeleteMin}, and \textsc{InsertAndAttrite} all
in  worst case I/Os, and  amortized I/Os per operation.
Furthermore, it allows the additional \textsc{CatenateAndAttrite} operation that
merges two PQAs in  worst case and  amortized I/Os. The
last operation is a non-trivial extension to the classic PQA of Sundar, even in
internal memory.
\end{abstract}
\end{fullenv}

\category{F.2.2}{Analysis of algorithms and problem complexity}{Nonnumerical
Algorithms and Problems}[computations on discrete structures]
\category{H.3.1}{Information storage and retrieval}{Content analysis and
indexing}[indexing methods]

\keywords{Skyline, range reporting, priority queues, external memory, data
structures}



\section{Introduction} \label{sec:intro}


Given two different points  and  in , where
 denotes the real domain, we say that  \emph{dominates}~ if  and . Let  be a set of  points in . A
point  is \emph{maximal} if it is not dominated by any other point in
. The {\em skyline} of  consists of all maximal points of . Notice that
the skyline naturally forms an orthogonal staircase where increasing
-coordinates imply decreasing -coordinates. Figure~\ref{fig:intro-sky}a
shows an example where the maximal points are in black.

\begin{figure}[b]
	\centering
	\begin{tabular}{cc}
    \yufeigraphics{height=25mm}{sky}&
    \hspace{3mm}\yufeigraphics{height=25mm}{sky-4s} \\
		(a) Skyline &
		\hspace{3mm} (b) Range skyline
	\end{tabular}
	\figcapup
	\caption{Range skyline queries.} \label{fig:intro-sky}
	\figcapdown
\end{figure}

\begin{figure*}
	\centering
	\begin{tabular}{ccccccc}
    \yufeigraphics{height=15mm}{sky-top}&
    \hspace{-2mm} \yufeigraphics{height=15mm}{sky-right}&
    \hspace{-2mm} \yufeigraphics{height=15mm}{sky-down}&
    \hspace{-2mm} \yufeigraphics{height=15mm}{sky-left} &
    \hspace{-2mm} \yufeigraphics{height=15mm}{sky-dom} &
    \hspace{-2mm} \yufeigraphics{height=15mm}{sky-antidom}&
    \hspace{-2mm} \yufeigraphics{height=15mm}{sky-con} \\
		(a) Top-open &
		\hspace{-2mm} (b) Right-open &
		\hspace{-2mm} (c) Bottom-open &
		\hspace{-2mm} (d) Left-open &
		\hspace{-2mm} (e) Dominance &
		\hspace{-2mm} (f) Anti-dominance &
		\hspace{-2mm} (g) Contour
	\end{tabular}
	\figcapup
	\caption{Variations of range skyline queries (black points represent the query results).} \label{fig:intro-var}
	\figcapdown
\end{figure*}

Given an axis-parallel rectangle~, a \emph{range skyline query} (also known as a \emph{range maxima query}) reports the skyline of .  In Figure~\ref{fig:intro-sky}b, for instance,~ is the shaded rectangle, and the two black points constitute the query result. When~ is a 3-sided rectangle, a range skyline query becomes a {\em top-open}, {\em right-open}, {\em bottom-open} or {\em left-open} query, as shown in
Figures~\ref{fig:intro-var}a-\ref{fig:intro-var}d respectively. A {\em dominance} (resp.\ {\em anti-dominance}) query  is a 2-sided rectangle with both the top and right (resp.\ the bottom and left) edges grounded, as shown in Figure~\ref{fig:intro-var}e (resp.\ \ref{fig:intro-var}f). Another well-studied variation is the {\em contour} query, where  is a 1-sided rectangle that is the half-plane to the left of a vertical line (Figure~\ref{fig:intro-var}g).

This paper studies linear-size data structures that can answer range skyline
queries efficiently, in both the static and dynamic settings. Our analysis
focuses on the {\em external memory} (EM) model \cite{AV88}, which has become
the dominant computation model for studying I/O-efficient algorithms. In this
model, a machine has  words of memory, and a disk of an unbounded size. The
disk is divided into disjoint {\em blocks}, each of which is formed by 
consecutive words. An {\em I/O} loads a block of data from the disk to memory,
or conversely, writes  words from memory to a disk block. The space of a
structure equals the number of blocks it occupies, while the cost of an
algorithm equals the number of I/Os it performs. CPU time is for free.

By default, the data universe is . Given an integer , 
represents the set . All the above queries remain well
defined in the universe . Particularly, when , the
universe is called {\em rank space}. In general, for a smaller universe, it may
be possible to achieve better query cost under the same space budget. We consider that  is in general position, i.e., no two points in  have
the same - or -coordinate (datasets not in general position can be
supported by standard tie breaking). When the universe is , we make the
standard assumption that a machine word has at least  bits.

\subsection{Motivation of 2D Range Skyline} \label{sec:intro-motivation}

Skylines have drawn very significant attention (see \cite{BT11, AFGT97,
DGKASK12, FR90, J91, KDKS11, K00, OL81, BCP08, BKS01, CGGL05, KRR02, MPJ07,
PTFS05, SLNX09, SSK09, ST11} and the references therein) from the research
community due to their crucial importance to multi-criteria optimization, which
in turn is vital to numerous applications. In particular, the rectangle of a
range skyline query represents range predicates specified by a user. An
effective index is essential for maximizing the efficiency of these queries in
database systems \cite{KRR02, PTFS05}.

This paper concentrates on 2D data for several reasons. First, {\em planar range skyline reporting} (i.e., our problem) is a classic topic that has been extensively studied in theory  \cite{BT11, AFGT97, DGKASK12, FR90, J91, KDKS11, K00, OL81}. However, nearly all the existing results  apply to internal memory (as reviewed in the next subsection), while currently there is little understanding about the characteristics of the problem in I/O environments.

\begin{table*}
	\centering
\begin{tabular}{c|c|c|c|c|c}
		 & space & query & insertion & deletion & remark \\
		\hline
		top-open in  &  &  & - & - & optimal \\
		top-open in  &  &  & - & - & optimal \\
		top-open in  &  &  & - & - & optimal \\
		\hline
		anti-dominance in  &  &  & - & - & lower bound (indexability)\\
		4-sided in  &  &  & - & - & optimal (indexability) \\
		\hline
    top-open in  &  &  &  &  &
    for any constant  \\
		\hline
		4-sided in  &  &  &  &  & update cost is amortized
	\end{tabular}
\figcapup
	\caption{Summary of our range skyline results (all complexities are in the worst case by default).} \label{tab:intro-results}
	\figcapdown
\end{table*}

The second, more practical, reason is that many skyline applications are {\em inherently} 2D. In fact, the special importance of 2D arises from the fact that one often faces the situation of having to strike a balance between a pair of naturally contradicting factors. A prominent example is {\em price} vs.\ {\em quality} in product selection. A range skyline query can be used to find the products that are not dominated by others in both aspects, when the price and quality need to fall in specific ranges. Other pairs of naturally contradicting factors include {\em space} vs.\ {\em query time} (in choosing data structures), {\em privacy protection} vs.\ {\em disclosed information} (the perpetual dilemma in privacy preservation \cite{CRL07}), and so on.

The last reason, and maybe the most important, is that clearly range skyline
reporting cannot become easier as the dimensionality increases, whereas even for
two dimensions, we will prove a hardness result showing that the problem
(unfortunately) is already difficult enough to forbid sub-polynomial
query cost under the linear space budget! In other words, the ``easiest''
dimensionality of 2 is not so easy after all, which also points to the absence
of query-efficient structures in any higher dimension
when only linear space is permitted.

\subsection{Previous Results} \label{sec:intro-related}


\extraspacing {\bf Range Skyline in Internal Memory.} We first review the
existing results when the dataset  fits in main memory. Early research
focused on dominance and contour queries, both of which can be solved in
 time using a structure of  size, where  is the
number of points reported \cite{AFGT97, FR90, J91, K00, OL81}. Brodal and
Tsakalidis \cite{BT11} were the first to discover an optimal dynamic structure
for top-open queries, which capture both dominance and contour queries as
special cases. Their structure occupies  space, answers queries in
 time, and supports updates in  time. The
above structures  belong to the {\em pointer machine} model.  Utilizing features
of the RAM model, Brodal and Tsakalidis \cite{BT11} also presented an
alternative structure in universe , which uses  space, answers
queries in  time, and can be updated in
 time. In RAM, the static top-open problem can
be easily settled using an RMQ ({\em range minimum queries}) structure (see,
e.g., \cite{YA10}), which occupies  space and answers queries in
 time.

For general range skyline queries (i.e., 4-sided), all the known structures demand super-linear space. Specifically, Brodal and Tsakalidis \cite{BT11} gave a pointer-machine structure of  size,  query time, and  update time. Kalavagattu et al.\ \cite{KDKS11} designed a static RAM-structure that occupies  space and achieves query time . In rank space, Das et al.\ \cite{DGKASK12} proposed a static RAM-structure with  space and  query time.

The above results also hold directly in external memory, but they are far from being satisfactory. In particular, all of them incur  I/Os to report  points. An I/O-efficient structure ought to achieve  I/Os for this purpose.

\extraspacing {\bf Range Skyline in External Memory.} In contrast to internal
memory where there exist a large number of results, range skyline queries have
not been well studied in external memory. As a naive solution, we can first
scan the entire point set  to eliminate the points falling outside the query
rectangle , and then find the skyline of the remaining points by the fastest
skyline algorithm \cite{ST11} on non-preprocessed input sets. This expensive
solution can incur  I/Os.

Papadias et al.\ \cite{PTFS05} described a branch-and-bound algorithm when the
dataset is indexed by an R-tree \cite{G84}. The algorithm is heuristic and
cannot guarantee better worst case query I/Os than the naive solution mentioned
earlier. Different approaches have been proposed for skyline maintenance in
external memory under various assumptions on the updates
\cite{TP06,WAEA07,PTFS05,HLOT06}. The performance of those methods, however,
was again evaluated only experimentally on certain ``representative'' datasets.
No I/O-efficient structure exists for answering range skyline queries even in
sublinear I/Os under arbitrary updates.

\extraspacing {\bf Priority Queues with Attrition (PQAs).} Let  be a set of elements drawn from an ordered domain, and let  be the smallest element in .
A PQA on  is a data structure that supports the following operations:
\begin{itemize}
	\item \textsc{FindMin}: Return . \vspace{-2mm}

	\item \textsc{DeleteMin}: Remove and return . \vspace{-2mm}

	\item \textsc{InsertAndAttrite}: Add a new element  to  and remove from  all the elements at least .
	After the operation, the new content is .
    The elements  are {\em attrited}.
\end{itemize}
In internal memory, Sundar \cite{S89} described how to implement a PQA that supports all operations in  worst case time, and occupies  space after  \textsc{InsertAndAttrite} and  \textsc{DeleteMin} operations.

\subsection{Our Results} \label{sec:intro-ours}

This paper presents external memory structures for solving the planar range skyline reporting problem using only linear space. At the core of one of these structures is a new PQA that supports the extra functionality of catenation. This PQA is a non-trivial extension of Sundar's version \cite{S89}. It can be implemented I/O-efficiently, and is of independent interest due to its fundamental nature. Next, we provide an overview of our results.

\extraspacing {\bf Static Range Skyline.} When  is static, we describe several linear-size structures with the optimal query cost. Our structures also separate the hard variants of the problem from the easy ones.

For top-open queries, we present a structure that answers queries in optimal  I/Os (Theorem~\ref{thm:topopen-main}) when the universe is . To obtain the result, we give an elegant reduction of the problem to {\em segment intersection}, which can be settled by a {\em partially persistent B-tree} (PPB-tree) \cite{BGOSW96}. Furthermore, we show that this PPB-tree is (what we call) {\em sort-aware build-efficient} (SABE), namely, it can be constructed in linear I/Os, provided that  is already sorted by -coordinate (Theorem~\ref{thm:topopen-main}). The construction algorithm exploits several intrinsic properties of top-open queries, whereas none of the known approaches \cite{A03, BSW97, V08} for bulkloading a PPB-tree is SABE.

The above structure is {\em indivisible}, namely, it treats each coordinate as an atom by always storing it using an entire word. As the second step, we improve the top-open query overhead beyond the logarithmic bound when the data universe is small. Specifically, when the universe is  where  is an integer, we give a {\em divisible}  structure with optimal  query I/Os (Corollary~\ref{crl:div-rankmain}). In the rank space, we further reduce the query cost again optimally to  (Theorem~\ref{thm:div-rankmain}).

Clearly, top-open queries are equivalent to right-open queries by symmetry, and capture dominance and contour queries as special cases, so the results aforementioned are applicable to those variants immediately.

Unfortunately, fast query cost with linear space is impossible for the remaining variants under the well-known {\em indexability model} of \cite{HKMPS02} (all the structures in this paper belong to this model). Specifically, for anti-dominance queries, we establish a lower bound showing that every linear-size structure must incur  I/Os in the worst case (Theorem~\ref{thm:4sided-lower2}), where  can be an arbitrarily small constant. Furthermore, we prove that this is tight, by giving a structure to answer a 4-sided query in  I/Os (Theorem~\ref{thm:4sided-main}). Since 4-sided is more general than anti-dominance, these matching lower and upper bounds imply that they, as well as left- and bottom-open queries, have exactly the same difficulty.

The above 4-sided results also reveal a somewhat unexpected fact: planar range skyline reporting has precisely the same hardness as {\em planar range reporting} (where, given an axis-parallel rectangle , we want to find all the points in , instead of just the maxima; see \cite{ASV99, HKMPS02} for the matching  lower and upper bounds on planar range reporting). In other words, the extra skyline requirement does not alter the difficulty at all.

\extraspacing {\bf Dynamic Range Skyline.} The aforementioned static structures
cannot be updated efficiently when insertions and deletions occur in . For
top-open queries, we provide an alternative structure with fast worst case
update overhead, at a minor expense of query efficiency. Specifically, our
structure occupies linear space, is SABE, answers queries in
 I/Os, and supports updates in  I/Os, where  can
be any parameter satisfying  (Theorem~\ref{thm:3sided}).
Note that setting  gives a structure with query cost  and update cost .

The combination of this structure and our (static) 4-sided structure leads to a
dynamic 4-sided structure that uses linear space, answers queries optimally in
 I/Os, and supports updates in
 I/Os amortized (Theorem~\ref{thm:4sided-main}).
Table~\ref{tab:intro-results} summarizes our structures.

\extraspacing {\bf Catenable Priority Queues with Attrition.} A central
ingredient of our dynamic structures is a new PQA that is more
powerful than the traditional version of Sundar \cite{S89}. Specifically, besides  \textsc{FindMin},
\textsc{DeleteMin} and \textsc{InsertAndAttrite} (already reviewed in
Section~\ref{sec:intro-related}), it also supports:
\begin{itemize}
  \item \textsc{CatenateAndAttrite}: Given two PQAs on sets  and 
  respectively, the operation returns a single PQA on . In other words, the elements in  are attrited.
\end{itemize}
We are not aware of any previous work that addressed the above operation,
which turns out to be rather challenging even in internal
memory.

Our structure, named \emph{I/O-efficient catenable priority queue with
attrition} (I/O-CPQA), supports all operations in  worst case and
 amortized I/Os (the amortized bound requires that a constant
number of blocks be pinned in main memory, which is a standard and compulsory
assumption to achieve  amortized update cost of most, if not all,
known structures, e.g., the linked list). The space cost is  after
 \textsc{InsertAndAttrite} and \textsc{CatenateAndAttrite} operations, and
after  \textsc{DeleteMin} operations.

\confcmt{All the missing proofs of theorems, lemmata and corollaries can be found in the full version.}
\section{SABE Top-Open Structure} \label{sec:topopen}


In this section, we describe a structure of linear size to answer a top-open
query in  I/Os. The structure is SABE, namely, it can be
constructed in linear I/Os provided that the input set  is sorted by
-coordinate.

\subsection{Reduction to Segment Intersection} \label{sec:topopen-reduce}


We first describe a simple structure by converting top-open range skyline
reporting to the {\em segment intersection problem}: the input is a set  of
horizontal segments in ; given a vertical segment , a query reports
all the segments of  intersecting .

Given a point  in , denote by  the leftmost
point among all the points in  dominating . If such a point does not
exist,  \nil. We convert  to a horizontal segment
 as follows. Let . If  \nil, then
; otherwise,
. Define , i.e., the set of segments converted from the points of . See
Figure~\ref{fig:topopen-reduce}a for an example.

\begin{figure}[!h]
	\centering
	\begin{tabular}{cc}
    \yufeigraphics{height=30mm}{top-reduce}&
    \hspace{3mm}\yufeigraphics{height=30mm}{top-reduce1} \\
		(a) Data conversion &
		\hspace{3mm} (b) Converted query
	\end{tabular}
	\figcapup
	\caption{Reduction.} \label{fig:topopen-reduce}
	\figcapdown
\end{figure}

Now, consider a top-open query with rectangle . We answer it by performing segment intersection
on~. First, obtain  as the highest -coordinate of the
points in . Then, report all segments in  that intersect
the vertical segment . An example is shown in
Figure~\ref{fig:topopen-reduce}b. \confcmt{A proof of the correctness of the
algorithm can be found in the full version.}

\begin{fullenv}
\begin{lemma} \label{lmm:topopen-correct}
	The query algorithm is correct.
\end{lemma}

\begin{proof}
  Consider any point  and a top-open query with . We show that our algorithm reports  if
  and only if  satisfies the query.

  \vspace{2mm} {\em If direction:} As  satisfies the query, we know that , , and . The last fact
  suggests that  (if  \nil, define ). Hence,  intersects the vertical
  segment , and thus, will be reported by our
  algorithm.

  \vspace{2mm} {\em Only-if direction:} Let  be a point found by our
  algorithm, i.e.,  intersects , where  (if  does not exist, ). It follows that  and .

  Next, we prove . Recall that  is the -coordinate
  of the highest point  among all the points in . If ,
  then  clearly holds. Otherwise, we know ,
  which implies that . This is because if , then
   dominates , which (because ) contradicts
  the definition of . Now,  follows from .

  So far we have shown that  is covered by . It remains to prove that 
  is not dominated by any point in . This is true because  suggests that the leftmost point in  dominating  must be outside
  .
\end{proof}
\end{fullenv}

We can find  in  I/Os with a {\em range-max query} on
a B-tree indexing the -coordinates in . For retrieving the segments
intersecting , we store  in a
partially persistent B-tree (PPB-tree) \cite{BGOSW96}. As  has 
segments, the PPB-tree occupies  space and answers a segment
intersection query in  I/Os. We thus have obtained a
linear-size top-open structure with  query I/Os.

More effort, however, is needed to make the structure SABE. In particular, two challenges are to be overcome. First, we must generate  in linear
I/Os. Second, the PPB-tree on  must be built with asymptotically the same cost (note that the range-max B-tree is already SABE). We will tackle these challenges in the rest of this section.

\subsection{Computing {\large \boldmath}} \label{sec:topopen-genseg}


 is not an arbitrary set of segments. We observe:

\begin{lemma} \label{lmm:topopen-properties}
	 has the following properties:
	\begin{itemize}
    \item {\bf (Nesting)} for any two segments  and  in ,
    their -intervals are either disjoint, or such that one -interval
    contains the other.

    \item {\bf (Monotonic)} let  be any vertical line, and  the
    set of segments in  intersected by . If we sort the
    segments of  in ascending order of their -coordinates, the lengths of
    their -intervals are non-decreasing.
	\end{itemize}
\end{lemma}
\begin{fullenv}
\begin{proof}
  \extraspacing {\em Nesting:} Let  and  be the points such that  and . Assume without loss of generality
  that . Consider first the case . In
  this scenario, the -interval of  must terminate before 
  because  dominates . In other words,  and  have disjoint
  -intervals.

  We now discuss the case . If  does not
  exist, the -interval of  is , which clearly
  encloses that of . Consider, instead, that  exists.  If
   has -coordinate smaller than , then  and 
  have disjoint -intervals.  Otherwise,  also dominates
  , implying that the -interval of  contains that of .

  \vspace{2mm} {\em Monotonic:} Let  intersect the -axis at .
  Consider the contour query with rectangle , which is a special top-open query. By
  Lemma~\ref{lmm:topopen-correct}, the left endpoints of the segments in
   constitute the skyline of . Therefore, if we enumerate
  the segments of  in ascending order of -coordinates, their left
  endpoints' -coordinates decrease continuously. It thus follows from the
  nesting property that their -intervals have increasing lengths.
\end{proof}
\end{fullenv}

We are ready to present our algorithm for computing , after  has been sorted by -coordinates. Conceptually, we sweep a vertical line  from  to . At any time, the algorithm (essentially) stores the set  of segments in a stack, which are en-stacked in descending order of -coordinates (i.e., the segment that tops the stack has the lowest y-coordinate). Whenever a segment is popped out of the stack, its right endpoint is decided, and the segment is output. In general, the segments of  are output in non-descending order of their right endpoints' -coordinates.

Specifically, the algorithm starts by pushing the leftmost
point of  onto the stack. Iteratively, let  be the next point fetched
from , and  the point currently at the top of the stack. If , we know that . Hence, the algorithm pops
 off the stack, and outputs segment .
Then, letting  be the point that tops the stack currently, the algorithm
checks again whether , and if so, repeats the above steps. This
continues until either the stack is empty or . In either case, the
iteration finishes by pushing  onto the stack. It is clear that the algorithm generates  in  I/Os.

\subsection{Constructing the PPB-tree} \label{sec:topopen-pers}


Remember that we need a PPB-tree  on . The known algorithms for
PPB-tree construction require super-linear I/Os even after sorting \cite{A03,
BGOSW96, BSW97, V08}. Next, we show that the two properties of  in
Lemma~\ref{lmm:topopen-properties} allow building~ in linear I/Os. Let us
number the leaf level as {\em level 0}. In general, the parent of a level-
() node is at level . We will build  in a bottom-up manner,
i.e., starting from the leaf level, then level , and so on.

\extraspacing{\bf Leaf Level.} To create the leaf nodes, we need to first sort
the left and right endpoints of the segments in  together by
-coordinate. This can be done in  I/Os as follows. First, ,
which is sorted by -coordinates, gives a sorted list of the left endpoints.
On the other hand, our algorithm of the previous subsection generates
 in non-descending order of the right endpoints' -coordinates
(breaking ties by favoring lower points). By merging the two lists, we obtain
the desired sorted list of left and right endpoints combined.

Let us briefly review the algorithm proposed in \cite{BGOSW96} to build a
PPB-tree. The algorithm conceptually moves a vertical line  from  to . At any moment, it maintains a B-tree  on the
-coordinates of the segments in . We call  a {\em
snapshot B-tree}. To do so, whenever  hits the left (resp.\ right) endpoint of a
segment , it inserts (resp.\ deletes) the -coordinate of  in . The
PPB-tree can be regarded as a space-efficient union of all the snapshot
B-trees. The algorithm incurs  I/Os because (i) there are
 updates, and (ii) for each update,  I/Os are needed to
locate the leaf node affected.

When  is nesting and monotonic, the construction
can be significantly accelerated. A crucial observation is that any update to
 happens only {\em at the bottom} of . Specifically, whenever
 hits the left/right endpoint of a segment ,  must be
the lowest segment in . This implies that the leaf node of 
to be altered must be the leftmost\footnote{We adopt the convention that the leaf elements of a B-tree are ordered from left to right in ascending order.} one in . Hence, we can find this leaf
without any I/Os by buffering it in memory, in contrast to the 
cost originally needed.

The other details are standard, and are sketched below assuming the knowledge
of the classic algorithm in \cite{BGOSW96}. Whenever the leftmost leaf  of  is
full, we version copy it to , and possibly perform a split or merge, if
 strong-version overflows or underflows, respectively\footnote{Version copy, strong-version overflow and strong-version underflow are
concepts from the terminology of \cite{BGOSW96}.}. A version
copy, split, and merge can all be handled in  I/Os, and can happen
only  times.  Therefore, the cost of building the leaf level is
.

\extraspacing{\bf Internal Levels.} The level- nodes can be built by exactly
the same algorithm, but on a different set of segments  which are
generated from the leaf nodes of the PPB-tree. To explain, let us first review
an intuitive way \cite{BS96} to visualize a node in a PPB-tree. A node  can
be viewed as a rectangle  in , where  (resp.\ ) is the position of  when  is created (resp.\ version copied), and  represents the -range of  in all the snapshot B-trees where  belongs. See Figure~\ref{fig:topopen-mvb}.

\begin{figure}[!h]
	\centering
    \yufeigraphics{height=35mm}{mvb}
	\figcapup
	\caption{A node in a PPB-tree.}
	\label{fig:topopen-mvb}
	\figcapdown
\end{figure}

For each leaf node  (already created), we add the bottom edge of , namely , into . The next lemma points out a crucial fact.

\begin{lemma} \label{lmm:topopen-level1}
	 is both nesting and monotonic.
\end{lemma}
\begin{fullenv}
\begin{proof}
  We prove the lemma by induction on the position of . For this purpose,
  care must be taken to interpret the rectangles of the nodes currently in
  .  As these nodes are still ``alive'' (i.e., they have not been
  version copied yet), the right edges of their rectangles rest on , and
  move rightwards along with . Let set  include the
  bottom edges of the rectangles of all level-1 nodes already spawned so far,
  counting also the ones in . When we finish building all the level-1
  nodes,  becomes the final . We will show that
   is nesting and monotonic at all times. This is obviously
  true when  is at .

  Now, suppose that  is currently nesting and monotonic. We
  will prove that it remains so after the next update on . This is
  trivial if the update does not cause any version copy, i.e., the first leaf
  node  of  is not full yet. Consider instead that  is version
  copied to  when  is at . At this point,  is
  finalized. Because  is the lowest among the rectangles of the nodes in
  , its finalization cannot affect the nesting and monotonicity of
  . The version copy also creates . Note that the
  x-intervals of  and  are disjoint, because the former does not
  include , but the latter does. Furthermore,  has the same
  -interval as , and a zero-length -interval .
  Therefore, if no split/merge follows,  is still nesting and
  monotonic.

  Next, consider that  is split into  and . In this case,
   disappears from , and is replaced by  and
  , which are the bottom two among the rectangles of the nodes in
  . Furthermore, both  and  have zero-length
  -intervals. So  is still nesting and monotonic.

  It remains to discuss the case where  needs to merge with its sibling 
  in . When this happens, the algorithm first version copies  to
  , which finalizes . The -interval of  must contain that of
  , which is consistent with nesting and monotonicity because  is
  above . The merge of  and  creates a node , such that 
  has a zero-length -interval. Note that  is currently the lowest of
  the rectangles of the nodes in . So  remains nesting
  and monotonic.

  Finally,  may still need to be split one more time, but this case can be
  analyzed in the same way as the split scenario mentioned earlier. We thus
  conclude the proof.
\end{proof}
\end{fullenv}

Our algorithm (for building the leaf nodes) writes the left and right endpoints
of the segments in  in non-descending order of their -coordinates
(breaking ties by favoring lower endpoints). This, together with
Lemma~\ref{lmm:topopen-level1}, permits us to create the level- nodes using
the same algorithm in  I/Os (as ). We
repeat the above process to construct the nodes of higher levels. The cost
decreases by a factor of  each level up. The overall construction cost is
therefore . \confcmt{Leaving the other details to the full version,
we now conclude with the first main result:}

\begin{theorem} \label{thm:topopen-main}
  There is an indivisible linear-size structure on  points in , such
  that top-open range skyline queries can be answered in  I/Os, where  is the number of reported points. If all points have
  been sorted by -coordinates, the structure can be built in linear I/Os.
  The query cost is optimal (even without assuming indivisibility).
\end{theorem}
\begin{fullenv}
\begin{proof}
  We focus on the query optimality because the rest of the theorem follows from
  our earlier discussion directly.

  The term  is clearly indispensable. The term , on the
  other hand, is also compulsory due to a reduction from predecessor search.
  First, it is well-known (see, e.g., \cite{BKMT97}) that predecessor search
  can be reduced to top-open range reporting (note: {\em not} top-open range
  skyline), such that if a linear-size structure can answer a top-open range
  query in  time, the same structure also solves a
  predecessor query in  time. Interestingly, given a predecessor
  query, the converted top-open range query always returns only one point.
  Hence, the query can as well be interpreted as a top-open range skyline
  query. This indicates that the same reduction also works from predecessor
  search to top-open range skyline. Finally, any linear-size structure must
  incur  I/Os answering a predecessor query in the worst case
  \cite{PT06} (even without the indivisibility assumption). It thus follows that  also lower bounds the
  cost of a top-open range skyline query.
\end{proof}
\end{fullenv}

\section{Divisible Top-Open Structure} \label{sec:div}


The structure of the previous section obeys the indivisibility assumption. This section
eliminates the assumption, and unleashes the power endowed by bit manipulation.
As we will see, when the universe is small, it admits linear-size structures
with lower query cost.

In Section \ref{sec:div-ray}, we study a different problem called ray-dragging. Then, in Section \ref{sec:div-topopen}, our ray-dragging structure is deployed to develop a ``few-point structure'' for answering top-open queries on a small point set. Finally, in Section \ref{sec:div-final}, we combine our few-point structure with an existing structure \cite{BT11} to obtain the final optimal top-open structure.

\subsection{Ray Dragging} \label{sec:div-ray}


In the {\em ray dragging problem}, the input is a set  of  points in  where  is an integer. Given a vertical ray  where , a ray dragging query reports the first point in  to be hit by  when  moves left. The rest of the subsection serves as the proof for:

\begin{lemma} \label{lmm:div-ray}
  For , we can store  in a structure of size
   that can answer ray dragging queries in  I/Os.
\end{lemma}



\noindent {\bf Minute Structure.} Set . We first consider the scenario where  has very few points: . Let us convert  to a set  of points in an  grid. Specifically, map a point  to  such that  (resp.\ ) is the {\em rank} of  (resp.\ ) among the - (-) coordinates in .

Given a ray , we instead answer a query in  using a ray , where  (resp.\ ) is the rank of the predecessor of  (resp.\ ) among the - (resp.\ -) coordinates in . Create a {\em fusion tree} \cite{FW93, LP12} on the - (resp.\ -) coordinates in  so that the predecessor of~ (resp.\ ) can be found in  I/Os, which is thus also the cost of turning  into . The fusion tree uses  blocks.

We will ensure that the query with  (in ) returns an id from 1 to
 that uniquely identifies a point  in , if the result is non-empty. To
convert the id into the coordinates of , we store  in an array of
 blocks such that any point can be retrieved in one I/O by id.

The benefit of working with  is that
each coordinate in  requires fewer bits to represent (than in ),
that is,  bits. In particular, we need  bits in total to
represent a point's -, -coordinates, and id. Since , the
storage of the entire  demands  bits. If , then . On the other hand, if , then . In other words, we can always store the entire set  in 
 blocks. Given a query with , we simply load this block into
memory, and answer the query in memory with no more I/O.

We have completed the description of a structure that uses  blocks, and answers queries in constant I/Os when . We refer to it as a {\em minute structure}.

\extraspacing {\bf Proof of Lemma~\ref{lmm:div-ray}.} We store  in a B-tree that indexes the -coordinates of the points in . We set the B-tree's leaf capacity to  and internal fanout to . Note that the tree has a constant height.

Given a node  in the tree, define  as the highest point whose -coordinate is stored in the subtree of . Now, consider  to be an internal node with child nodes . Define . We store  in a minute structure. Also, for each point , we store an index indicating the child node whose subtree contains the -coordinate of . A child index requires  bits, which is no more than the length of a coordinate. Hence, we can store the index along with  in the minute structure without increasing its space by more than a constant factor. For a leaf node , define  to be the set of points whose -coordinates are stored in .

Since there are  internal nodes and each
minute structure demands  space, all the minute structures
occupy  blocks in total. Therefore, the overall structure consumes linear space.

We answer a ray-dragging query with ray  as follows. First, descend a root-to-leaf path  to the leaf node containing the predecessor of  among the -coordinates in~. Let  be the {\em lowest} node on  such that  has a point that can be hit by  when  moves left. For each node , whether  has such a point can be checked in  I/Os by querying the minute structure over . Hence,  can be identified in  I/Os where  is the height of the B-tree. If  does not exist, we return an empty result (i.e.,  does not hit any point no matter how far it moves).

If  exists, let  be the first point in  hit by  when it moves left. Suppose that the -coordinate of  is in the subtree of , where  is a child node of . The query result must be in the subtree of , although it may not necessarily be . To find out, we descend another path from  to a leaf. Specifically, we set  to , and find the first point  in  () that is hit by  when it moves left (notice that  has changed). Now, letting  be the child node of  whose subtree  is from, we repeat the above steps. This continues until  becomes a leaf, in which case the algorithm returns  as the final answer.
The query cost is . This completes the proof of Lemma~\ref{lmm:div-ray}. We will refer to the above structure as a {\em ray-drag tree}.


\subsection{Top-Open Structure on Few Points} \label{sec:div-topopen}


Next, we present a structure for answering top-open queries on small , called henceforth the {\em few-point structure}. Remember that  is a set of  points in  for some integer , and a query is a rectangle  where .

\begin{lemma} \label{lmm:div-skysmall}
  For , we can store  in a structure of  space
  that answers top-open range skyline queries  with output size  in 
  I/Os.
\end{lemma}
\begin{proof}
  Consider a query with . Let~
  be the first point hit by the ray  when
   moves left. If  does not exist or is out of  (i.e., ), the top-open query has an empty result. Otherwise,  must be
  the lowest point in the skyline of .

  The subsequent discussion focuses on the scenario where . We index
   with a PPB-tree , as in Theorem~\ref{thm:topopen-main}. Recall
  that the top-open query can be solved by retrieving the set  of segments
  in  intersecting the vertical segment , where  is the highest -coordinate of the points
  in . To do so in  I/Os, we utilize the next two
  observations. \confcmt{(see the full version for their proofs)}:
  \begin{observation}
    {\em All segments of  intersect .}
\end{observation}

  \fullcmt{\underline{\em Proof:}  is the lowest among the segments of 
    intersecting  (recall that  is the segment in 
    converted from ). Hence, a segment of  intersects  if
    and only if it intersects . On the other
    hand, a segment of  intersects 
    if and only if it intersects . To explain, let  be
    a segment in  intersecting . As
     is higher than , the -interval of  must contain that
    of  (due to the nesting and monotonicity properties of
    ), implying that  intersects . Similarly, one can also
    show that if  intersects , it also intersects .
  }

  \begin{observation}
    {\em Let  be the snapshot B-tree in  when  is at the
    position . Once we have obtained the leaf node in 
    containing , we can retrieve  in  I/Os without
    knowing the value of .}
  \end{observation}

  \fullcmt{
    \underline{\em Proof:} Each leaf node in  has a sibling pointer to
    its succeeding leaf node\footnote{Due to the nesting and monotonicity
    properties, every leaf node  in the PPB-tree  needs only one sibling
  pointer during the entire period when  is alive.}. Hence, starting from
  the leaf node storing , we can visit the leaves of  in
  ascending order of the -coordinates they contain. The effect is to report
  in the bottom-up order the segments of  that intersect . By the nesting and monotonicity properties, the left endpoint of a
  segment reported latter has a smaller -coordinate. We stop as soon as
  reaching a segment whose left endpoint falls out of . The cost is  because  segments are reported in each accessed leaf,
  except possibly the last one. \vspace{2mm}
  }

  We now elaborate on the structure of Lemma~\ref{lmm:div-skysmall}.
  Besides~, also create a structure of Lemma~\ref{lmm:div-ray} on .
  Moreover, for every point , keep a pointer to the leaf node of 
  that (i) is in the snapshot B-tree  when  is at , and
  (ii) contains . Call the leaf node the {\em host leaf} of . Store the
  pointers in an array of size  to permit retrieving the pointer of any
  point in one I/O.

  The query algorithm should have become straightforward from the above two
  observations. We first find in  I/Os the first point  hit by 
  when  moves left. Then, using~, we jump to the host leaf of .
  Next, by Observation 2, we retrieve  in  I/Os. The total query
  cost is .
\end{proof}

\subsection{Final Top-Open Structure} \label{sec:div-final}


We are ready to describe our top-open structure that achieves sub-logarithmic
query I/Os for arbitrary . For this purpose, we externalize an
internal-memory structure of \cite{BT11}. The structure of \cite{BT11}, however,
has logarithmic query overhead, which we improve with new ideas based on the
few-point structure in Lemma~\ref{lmm:div-skysmall}. \confcmt{Delegating the
details to the full version, we now state our main results in rank space and
universe :}

\begin{theorem} \label{thm:div-rankmain}
  There is a linear-size structure on  points in rank space such that
  top-open range skyline queries can be answered optimally in 
  I/Os, where  is the number of reported points.
\end{theorem}

\begin{fullenv}
\noindent {\bf Structure.} Let  be the length of each dimension. We assume, without loss of generality, that 
 is an integer. Divide the -dimension
of  into  consecutive intervals of length  each, except possibly the last interval.
Call each interval a {\em chunk}. Assign each point  to the unique
chunk covering . Note that some chunks may be empty.

Create a complete binary search tree  on the chunks. Let  be a node of
. We say that a point  is ``in the subtree of '' if it is assigned to
a chunk in the subtree of . Denote by  the set of points in the
subtree of . Define  as the set of  highest points in the
skyline of ; if the skyline of  has less than  points,
 includes all of them. Furthermore, if , let
 be the lowest point in ; otherwise, 
\nil. We store  along with .

Let  be any internal node such that  is not \nil. Denote by  the path from the leaf (a.k.a.\ chunk)  of  covering  to the child of  that is an ancestor of . Define  as the set of right siblings\footnote{If a node is the right child of its parent, it has no right sibling. Similarly, if a node is a left child, it has no left sibling.} of the nodes in . Let  be the skyline of the point set  We store  along with , and order the points in  by -coordinate (hence, also by -coordinate). In Figure~\ref{fig:div-max}, for example,  is the skyline of .

The above completes the externalization of the structure in \cite{BT11}. Next,
we describe new mechanisms for achieving query cost . First, we
index the points in each chunk  with a few-point structure of
Lemma~\ref{lmm:div-skysmall}. Moreover, for every  and every proper ancestor  of , we store two sets  and  defined as follows. Let
 be the path from  to the child of  that is an ancestor of
. Define  as the set of left siblings of the nodes on
, and conversely,  the set of right siblings of
those nodes. Then:
\begin{itemize}
  \item  is the skyline of 
  \item  is the skyline of .
\end{itemize}
For instance, in Figure~\ref{fig:div-max},  is the skyline of , whereas  is the skyline of . The points of both  and  are sorted by -coordinate.

\extraspacing {\bf Space.} Let  be the height of . We
analyze first the space consumed by the  internal nodes 
of . Clearly,  fits in  blocks, whereas  occupies
 blocks. All the internal nodes thus demand  blocks in total.

Now, let us focus on the  leaf nodes  of . As each
few-point structure uses linear space, all the few-point structures demand
 blocks altogether. Regarding ,  has at most  proper ancestors , while each 
requires  blocks. Hence, the  of all  and  occupy
 blocks in total. The case with
 is symmetric. The overall space consumption is therefore linear.

\extraspacing {\bf Query.} We need the following fact:

\begin{lemma} \label{lmm:div-half}
  Given a node  in  and a value , let  be the set of
  points in  with -coordinates greater than . We can report the skyline of
   in  I/Os where  is the number of points reported.
\end{lemma}

\begin{proof}
  If  is a leaf, find the skyline of  by issuing a top-open
  query with search rectangle  on the few-point
  structure of . The query time is  by
  Lemma~\ref{lmm:div-skysmall}.

  The rest of the proof adapts an argument in \cite{BT11} to external memory.
  Given an internal node , we find the skyline of  as follows.
  Load  into memory, and report the points therein with
  -coordinates above . If there are less than  such points, we
  have found the entire skyline of .

  Suppose instead that the entire  is reported. Let . It suffices to consider the points that
	\begin{itemize}
		\item[(i)] are in the subtrees of the nodes in , or

		\item[(ii)] share the same chunk as , but are to the right of .
	\end{itemize}
  Any other point of  must be either in  -- which is already
  found -- or dominated by .

  To find the skyline points in (i), first report the set  of points in
   whose -coordinates are above . Then, we explore the
  subtrees of certain nodes in . Specifically, let  be the nodes in  for some integer . For each , define ; if ,\footnote{This can
  be checked efficiently because the points of  are consecutive in
  .} the subtree of  can be pruned from further
  consideration\footnote{This means that either , or
   is dominated by a point in . In both cases, we have found
  all the result points from the subtree of .}. Otherwise (i.e., ), we recursively report the skyline of , where 
  is the -coordinate of the point just to the right of  in the
  staircase of ; if no such point exists, .

  The skyline points in (ii) can be retrieved with a top-open query on the
  few-point structure of the chunk  covering , where  can be
  identified in constant I/Os by dividing  by . Specifically, if
  , define  to be the -coordinate of the highest
  point in ; otherwise, define . The top-open query for 
  has rectangle .

  Now we analyze the query cost. If less than  points of  are
  reported, the algorithm finishes with  I/Os. Otherwise, the scan of
   takes  I/Os. If , we charge the  cost on the  points in ; otherwise, we
  charge the  cost on the points of . The top-open query on
  the few-point structure of  requires  I/Os if it returns
   points. If , we charge the  cost on
  the points of ; otherwise, charge the  I/Os on the
   points.

  It remains to discuss the I/Os spent on . For each , if , there is no cost on . Otherwise, we charge on the
   points of  the  I/Os spent on reading  before
  recursively reporting the skyline of . The rest of the I/Os
  performed by the recursion are charged in the same manner as explained above.
  In this way, every reported point is charged  I/Os overall. The
  total query time is therefore .
\end{proof}

To answer a top-open query with ,
where , we first identify the chunks 
and  that cover  and , respectively. This takes
 I/Os by dividing  and  by the chunk size
, respectively. If , the query can be solved by searching
the few-point structure of  in  I/Os
(Lemma~\ref{lmm:div-skysmall}). The subsequent discussion considers .

\begin{figure}
	\centering
    \yufeigraphics{height=45mm}{max-u}
	\figcapup
	\caption{\boldmath Illustration of , , and }
	\label{fig:div-max}
	\figcapdown
\end{figure}

Let  be the lowest common ancestor of  and  in . As  is a
{\em complete} binary tree,  can be determined in constant I/Os. The rest of
the algorithm proceeds in 4 steps:

\begin{enumerate}
  \item Use the few-point structure of  to report the skyline of . Let  be the set of points retrieved, and  the
    -coordinate of the highest point in . If ,
    .

  \item Report the set  of points in  whose -coordinates
    are above . Denote by  the nodes of  for some integer . For each , check whether
    . If not, the subtree of  can be
    eliminated. Otherwise, apply Lemma~\ref{lmm:div-half} to retrieve the
    skyline of , where  is the -coordinate of the
    point just to the right of  in the staircase of ; if no
    such point exists, . If , update
     to be the -coordinate of the highest point in .

  \item Find the set  of points in  whose -coordinates
    are above . Denote by  the nodes of
     for some integer . For each , if
    , apply Lemma~\ref{lmm:div-half} to retrieve
    the skyline of , where  is the -coordinate
    of the point just to the right of  in the staircase of
     (if no such point exists, ). If , set  to the -coordinate of the highest point in
    .

  \item Fetch the skyline of  from the few-point structure of .
\end{enumerate}
In the example of Figure~\ref{fig:div-qry},  and ; the algorithm
first obtains the result points from , then from the subtrees of , next from the subtrees of , and finally from .

\begin{figure}
	\centering
    \yufeigraphics{height=50mm}{const-tm-qry}
	\figcapup
	\caption{\boldmath Illustration of the query algorithm}
	\label{fig:div-qry}
	\figcapdown
\end{figure}

To analyze the cost, we focus on the first two steps because the other steps
are symmetric. By Lemma~\ref{lmm:div-skysmall}, Step 1 takes 
I/Os, where  is the number of points reported in this step. In Step 2, by
leveraging the ordering inside ,  can be found in  I/Os. We charge the second term on the points of . For each , if  has less than  points, the subtree of
 incurs no more cost. Otherwise, applying Lemma~\ref{lmm:div-half} takes
 I/Os if the application finds  points\footnote{Note that
 since the whole  is definitely reported.}; we charge
this cost on those  points. Overall, every reported point is charged
 I/Os. Steps 1-4 each necessitate  extra I/Os. The total
query cost is therefore .
\end{fullenv}

\begin{corollary} \label{crl:div-rankmain}
	There is a linear-size structure on a set of  points in  (where  is an integer) such that a top-open range skyline query can be
	answered optimally in  I/Os, when 
  points are reported.
\end{corollary}
\begin{fullenv}
\begin{proof}
  We simply create the same structure on the input set  of  points in, however, rank space
  . A query coordinate in  can be converted into  in
   I/Os by a standard linear-size structure for predecessor
  search \cite{PT06}. The overall query cost is therefore .

  The optimality follows directly from the reduction explained in the proof of
  Theorem~\ref{thm:topopen-main} and the  lower bound of
  predecessor search under the linear space budget \cite{PT06}.
\end{proof}
\end{fullenv}

\section{Dynamic Top-Open Structure} \label{sec:dynamic}


In this section, we present a dynamic data structure, which is SABE, that uses
linear space, and supports top-open queries in  I/Os and updates in  I/Os,
for any parameter~. We are inspired by the approach of
Overmars and van Leeuwen~\cite{OL81} for maintaining the planar skyline in the
pointer machine. As a brief review, a dynamic binary base tree indexes the
-coordinates of , and every internal node stores the skyline of the points
in its subtree using a secondary search tree. More specifically, the skyline of
an internal node is , where  (resp.\ ) is the
skyline of its left (resp.\ right) child node, and  is the set of points in
 dominated by the leftmost (and thus also highest) point of~.

Our approach is based on I/O-CPQAs, which are described in
Section~\ref{sec:iocpqa}.  We observe that attrition can be utilized to maintain
the internal node skylines in~\cite{OL81}, after mirroring the -axis. To
explain this, let us first map the input set  to its mirrored counterpart
. In the context of PQAs, we
will interpret each point  as an {\em
element} with ``key'' value  that is inserted at ``time''
. To formalize the notion of time, we define the -ordering of
two elements  to be , if
and only if  holds. It is easy to see that element
 is attrited by element , if and
only if point  is dominated by point . See
Figure~\ref{fig:AtrittionSkyline} for a geometric illustration of the mirroring
transformation and the effects of attrition.

\inkfig{htb}{0.6\linewidth}{AtrittionSkyline}{fig:AtrittionSkyline}{The skyline
problem (above) mirrored to the attrition problem (below). White points are
reported for the gray query area ,
while gray elements are attrited within .}{}{\vspace{-0.35cm}}

Thus, we index the -ordering of  in a -tree, for a parameter , and employ
I/O-CPQAs as secondary structures, such that the I/O-CPQA at an internal node
is simply the concatenation of its children's I/O-CPQAs. To obtain logarithmic
query and update I/Os, this sequence of consecutive \textsc{CatenateAndAttrite}
operations at an internal node must be performed in  I/Os
(Lemma~\ref{lem:seq_concats}). The presented I/O-CPQAs are \emph{ephemeral}
(not persistent), and thus the supported operations are \emph{destructive}, as
they destroy the initial configuration of the structure. This only allows
operating on the I/O-CPQA that is the final result of all concatenations and
resides at the root of the base tree. However, in order to support top-open
queries efficiently, accessing I/O-CPQAs at the internal nodes is required.
This is made possible by non-destructive operations. Therefore, we render the
I/O-CPQAs confluently persistent by merely replacing the catenable deques,
which are used as black boxes in our ephemeral construction, with real-time
purely functional catenable deques~\cite{KT99}. Since the imposed overhead is
 worst case I/Os, confluently persistent I/O-CPQAs ensure the same
I/O bounds as their ephemeral counterparts. Section~\ref{sec:skyline} describes
our dynamic data structure in detail.

\subsection{I/O-Efficient Catenable Attrition Priority Queues}
\label{sec:iocpqa}


Here we present ephemeral \emph{I/O-efficient catenable priority queues with
attrition (I/O-CPQAs)} that store a set of elements from a total order and
support all operations in~ I/Os. Also the operations take~
amortized I/Os, when a constant number of blocks are already loaded into main
memory for every root I/O-CPQA, for any parameter~. We call
these preloaded records \emph{critical records}. For the sake of simplicity, we
identify an element with its value. Denote by  an I/O-CPQA and by 
the smallest element stored in . We denote by  also the set of elements in
I/O-CPQA . Next, we re-state the supported operations in the context of
I/O-CPQAs:

\begin{itemize}
  \item \textsc{FindMin}() returns~.
\vspace{-2mm}
  \item \textsc{DeleteMin}() returns~ and removes it from~. The
  resulting I/O-CPQA is~, and~ is discarded.
\vspace{-2mm}
  \item \textsc{CatenateAndAttrite}()\footnote{
    \textsc{InsertAndAttrite}() corresponds to
  \textsc{CatenateAndAttrite}(), where  contains only element
  .} catenates I/O-CPQA  to the end of another I/O-CPQA~,
  removes all elements in~ that are larger than or equal to~
  (attrition), and returns the result as a combined I/O-CPQA . The old I/O-CPQAs  and  are
  discarded.
\end{itemize}

An I/O-CPQA~ consists of two sorted buffers, called the first buffer 
with  elements and the last buffer~ with  elements,
and~ deques of records, called the \emph{clean} deque~, the
\emph{buffer} deque~ and the \emph{dirty}
deques~, where~. A \emph{record}~ consists of a buffer~ of~ sorted elements and a pointer~ to
an I/O-CPQA. A record is \emph{simple} when its pointer~ is \nil. The
definition of I/O-CPQAs implies an underlying tree structure when pointers are
considered as edges and I/O-CPQAs as subtrees. We define the ordering of the
elements in a record~ to be all elements of its buffer~ followed by all
elements in the I/O-CPQA referenced by pointer~. We define the queue order of
I/O-CPQA~ to be~, ,~ and~ and
. It corresponds to an Euler tour over the tree structure. See
Figure~\ref{fig:Overview} for an overview of the structure.

\fullcmt{
\inkfig{htb}{\linewidth}{CPQAOverview}{fig:Overview}{The records in~
  and~ are simple, the records of~ may contain
  pointers to other I/O CPQAs. I/O-CPQAs imply a tree structure. Gray records
  are critical.}{}{\vspace{-0.75cm}}
}

\confcmt{
  \inkfig{htb}{\linewidth}{CPQAOverview}{fig:Overview}{I/O-CPQA . Critical
  records are shown in gray.}{}{\vspace{-0.75cm}}
}

Given a record , the minimum and maximum elements in the buffers
of~, are denoted by~ and~,
respectively. They appear respectively first and last in the queue order of~,
since the buffer of~ is sorted by value. Given a deque~, the first and the
last records are denoted by~ and~, respectively.
Also,~ denotes all records of the deque~ excluding the
record~. Similarly,~ denotes all records of the deque~
excluding the record~. The size  () of the buffer
 () is defined to be the number of elements in  (). The
size~ of a record~ is defined to be the number of elements in its
buffer. The size~ of a deque~ is defined to be the number of records it
contains. The size~ of the I/O-CPQA~ is defined to be the number of
elements (both attrited and non-attrited) that~ contains. For an I/O-CPQA 
we denote by  and , respectively the first and last records
out of all the records of all the deques  that exist in . For an I/O-CPQA~ we maintain the following
invariants:

\begin{enumerate}[label=I.\arabic*)]
  \item \label{in:records} For every record~ where pointer~
  references I/O-CPQA~,~ holds.

  \item \label{in:recordpairs} In all deques of~ where
    record~ precedes record :  holds.
  \item \label{in:queuevalues} \sloppypar{For the buffer  and deques
    :  holds.}

  \item \label{in:min}  Element~ is
    the smallest element in the dirty deques~ .

    \item  \label{in:smalltail} .

  \item \label{in:simple} All records in the deques~ and~ are
  simple.

  \item \label{in:ineq} .

  \item \label{in:small}  holds iff  holds.

  \item \label{in:noFinChild} If  is a child of another I/O-CPQA then  and  holds.
\end{enumerate}
\sloppypar{From
invariants~\iref{in:recordpairs},~\iref{in:queuevalues},~\iref{in:min}
and~\iref{in:smalltail}, we have that~.} We say that an
operation \textit{improves} or \textit{aggravates}  the inequality of
Invariant~\iref{in:ineq} by a parameter~ for I/O-CPQA~, when the
operation, respectively, increases or decreases by  the \textit{state} of
:


To argue about the~ amortized I/O bounds we need more definitions.
\confcmt{The \textit{critical records} of I/O-CPQA  are ,
   , ,  ,
   and , if it exists.
Otherwise  is critical.}
By~ we denote all records in~ and the records in the I/O-CPQAs
pointed to by  and its descendants. We call an I/O-CPQA~ \emph{large} if
 and \emph{small} otherwise. We define the following potential
functions for large and small I/O-CPQAs. In particular, for large I/O-CPQAs~
the potential~ is defined as

where

and


For small I/O-CPQAs~, the potential~ is defined as

The total potential  is defined as

where the first sum is the total potential of all I/O-CPQAs~ and the second
sum counts the number of large I/O-CPQAs~.

\extraspacing \textbf{Operations.} In the following, we describe the algorithms
that implement the operations supported by the I/O-CPQA~. Most of the
operations call the auxiliary operations \textsc{Bias} and
\textsc{Fill}, which we describe last. \textsc{Bias} improves the
inequality of~\iref{in:ineq} for~ by at least  if  contains any
records. \textsc{Fill} ensures \iref{in:small}.

\extraspacing \underline{\textsc{FindMin}()} returns the value .

\extraspacing \underline{\textsc{DeleteMin}()} removes element  from the first buffer , calls \textsc{Fill}() and returns
.

\extraspacing \underline{\textsc{CatenateAndAttrite}()} creates a new
I/O-CPQA  by modifying~ and~, and by calling
\textsc{Bias}(), \textsc{Bias}(), \textsc{Fill}() and
\textsc{Fill}().

If  holds, then  consists only of the first buffer .
Let  be the non-attrited elements of , under attrition by
. Prepend  onto the first buffer  of~. If
this prepend causes , then we take the last  elements out of
, make a new record out of them and we prepend it onto the deque
.

If~ holds, then  only consists of . If  then
we delete attrited elements in  and append  to . We now
assume that . We have three cases, depending on how much of~
is attrited by~. Let  and let .

\begin{enumerate}
  \item \label{it:Q1} : Delete . We now have four cases:
  \begin{enumerate}[label=\arabic*)]
    \item \label{it:Q1Cs} If  holds, we discard
      I/O-CPQA~ and set~.

    \item \label{it:Q1lastCs} Else if  holds, we
      prepend  onto , set , , ,  and .  We
      call \textsc{Bias}() once to restore \iref{in:ineq} and then call
      \textsc{Fill}() once to restore Invariant \iref{in:small}.

    \item \label{it:Bs} Else if  or  holds, we set 
      and  and set . If  holds, we set~, else we set .

    \item \label{it:Ds} Else, let  be the non-attrited elements under
      attrition by . If  then append
       to , else  so take the first
       elements of  and  and make into a new record in a
      new last dirty queue of , leave the rest in , set  and call \textsc{Bias} twice to restore
      \iref{in:ineq}.



  \end{enumerate}

  \item \label{it:Ls} Else if , we set  and
    .

  \item \label{it:Latts} Else : Let  be the
    non-attrited elements of , under attrition by ,
    and  be the non-attrited elements, under attrition by
    . If  holds, we do the following: if
     holds, we put the first  elements of
     and  into  along with . Moreover, if we
    still have more than  elements left in  and ,
    we put the first  elements into a new last record of
    . Finally, we leave the remaining elements in . If
    we added a new last record to , we also  call
    \textsc{Bias}() once.
\end{enumerate}

We have now entirely dealt with the cases where~ or 
holds, so in the following we assume that  and 
hold, i.e. any I/Os incurred in the cases (\ref{it:Q1C}--\ref{it:D}) below are
already paid for, since the total number of large I/O-CPQAs decreases by one.
Let .

\begin{enumerate}
  \item \label{it:Q1C} If  holds, we discard
    I/O-CPQA~ and set~.

  \item \label{it:Q1lastC} Else if  holds, we
    prepend  onto  and  onto . We remove the
    simple record  from~, set ,
    , , , , ,  and ,
    where~ points to~ if it exists. This gives~,
    thus we call \textsc{Bias} twice and \textsc{Fill}() once.

  \item \label{it:B} Else if  or  holds, we prepend  onto  and remove
    the simple record  from~, set
    , , , ,  and set~ to point to , if it exists. If  holds, we set~, else we set
    . This gives~ in the worst case, thus
    we call \textsc{Bias} twice.

  \item \label{it:D} Else let  be the non-attrited elements of
    , under attrition by . If 
    holds, then we make  and  into the first record of
    . Else we make them into the first two records of  of size
     and  each. We set , , , , remove  from
    . Moreover, we add  as a new single record in
    , where  points to the rest of , if it
    exists, and set . All this aggravates the inequality
    of~\iref{in:ineq} for~ by at most~, so we call
    \textsc{Bias} twice.
\end{enumerate}

\extraspacing \underline{\textsc{Fill}} restores Invariant \iref{in:small},
if it is violated. In particular, if  and , let . If  holds, then we take the  first
elements of  and append them to . Else  holds, so we append
 to , discard  and call \textsc{Bias} once.

\extraspacing \underline{\textsc{Bias}} improves the inequality
of~\iref{in:ineq} for~ by at least~ if  contains any records. It also
ensures that invariant \iref{in:small} is maintained. We distinguish two
basic cases with respect to , namely  and .

\begin{enumerate}
  \item \label{it:Blg0} : We have two cases depending on if  or .
    \begin{enumerate}[label=\arabic*)]
      \item : Let , if it exists. We remove the first
        record  from . Let~ be the
        non-attrited elements of~, under attrition by element~. If
         holds nothing is attrited, so we just add  at the end of .

        Else  holds, so we set . If  holds, then we make record  with buffer  into the new
        last record of . Else  holds, so if  also holds, we add  to  and discard . Else
         also holds, so we take the  first elements of
         and  and put them into , making it the new last record
        of .

      \item : Let . We remove the first
        record  from . Let~ be the
        non-attrited elements of~, under attrition by element~.

        If  or  holds, we just add  at the end of  and if  we set
        . Else  hold, we set ,
        let . If 
        holds, we discard  and prepend  onto  of . Else
         holds, so we take the first  elements of
         and  and put them in , making it the new last record of
        . If this causes , we
        discard all dirty queues.
    \end{enumerate}
    If  was discarded, then we have that  and we call
    \textsc{Bias} recursively, which will not invoke this case again. In
    all cases the inequality of~\iref{in:ineq} for~ is improved by~.

  \item \label{it:Beq0} : we have three cases depending on the
    number of dirty queues, namely cases ,  and .
    \begin{enumerate}[label=\arabic*)]
      \item \label{it:KQgt1} : If  holds, we set  and discard
        . This improves the inequality of~\iref{in:ineq} for~
        by at least~. Else let .

        If  holds, we remove the record
         from~. This improves the inequality
        of~\iref{in:ineq} for~ by~.

      If  holds,
      we remove record 
      from~, and let . We
      delete any elements in~ that are attrited by~, and let~
      denote the set of non-attrited elements. If 
      holds, we prepend  onto  of  and discard . Else
      we take the first  elements of
       and  and replace  of  with them. Finally,
      we concatenate  and  into a single deque. This
      improves the inequality of~\iref{in:ineq} for~ by at least~.

    Else  holds and we just concatenate the
    deques~ and~, which improves the inequality
    of~\iref{in:ineq} for~ by~.

  \item \label{it:KQeq1} : In this case~ contains only
    deques~ and~. Let . If
     holds, we discard
    all dirty queues, except for record  of .

    If  holds, we discard all the dirty deques and let
     be the non-attrited elements of . If  holds,
    we prepend  onto . Else  holds, so we take the
    first  elements of  and  and make them the new last record of
     and leave the rest in . This improves the inequality
    of~\iref{in:ineq} for~ by .

    Else  holds, so we remove~ and insert buffer~
    into a new record at the end of~. This improves the inequality
    of~\iref{in:ineq} for~ by at least~. If~ is not simple, let the
    pointer~ of~ reference I/O-CPQA~. We restore \iref{in:simple}
    for~ by \textit{merging} I/O-CPQAs~ and~ into one I/O-CPQA; see
    Figure~\ref{fig:Bias}. In particular, let~.

    We proceed as follows: If  holds, we discard~.
    \fullcmt{The inequality of~\iref{in:ineq} for~ remains unaffected.} Else
    if  holds, we set  and discard the rest of~. \confcmt{In both cases, t}\fullcmt{T}he
    inequality of~\iref{in:ineq} for~ remains unaffected.

    Else if  holds, we
    concatenate the deque~ at the end of~. If moreover
     holds, we set . Finally, we discard
    the rest of~. This improves the inequality of~\iref{in:ineq} for~
    by~.

    Else  holds. We concatenate the deque~ at
    the end of~, we set~, we set  as the first  dirty queues of~ and we
    set~ as the last dirty queue of~. This improves the inequality
    of~\iref{in:ineq} for~ by~, since~ satisfied
    Invariant \iref{in:ineq} before the operation.

  \item \label{it:KQeq0} : If all deques are empty,  and  hold, we take the first  elements of
     and append to . The inequality of~\iref{in:ineq} for~
    remains .
  \end{enumerate}
\end{enumerate}

\inkfig{htb}{\linewidth}{CPQABias}{fig:Bias}{Merging I/O-CPQAs  and .
This case can only occur when  and .}{}{\vspace{-0.75cm}}

\begin{theorem} \label{thm:iocpqa}
  An I/O-CPQA supports \textsc{FindMin}, \textsc{DeleteMin},
  \textsc{CatenateAndAttrite} and \textsc{InsertAndAttrite} in~ I/Os
  per operation. It occupies  blocks after calling
  \textsc{CatenateAndAttrite} and \textsc{InsertAndAttrite}~ times and
  \textsc{DeleteMin}~ times, respectively.

  All operations are supported by a set of  I/O-CPQAs in~
  amortized I/Os, when~, using  blocks of
  space, for any parameter .
\end{theorem}
\begin{proof}
The correctness follows by closely noticing that we maintain invariants
\iref{in:records}--\iref{in:noFinChild}, which in turn imply that
\textsc{DeleteMin} and \textsc{FindMin} always return the minimum
element of~.
The~ worst case I/O bound is trivial as every operation only
accesses~ records. Although \textsc{Bias} is recursive, notice that in
the case where , \textsc{Bias} only calls itself after making
, so it will not end up in this case again.
We elaborate on all the operations that modify the I/O-CPQA in order to argue
for the amortized bounds:

\begin{confenv}
\noindent \underline{\textsc{DeleteMin}}: If after the call 
holds, no I/Os are incurred and the amortized cost of  pays
for increasing the potential. Otherwise  pays for any
I/Os to call \textsc{Fill} and \textsc{Bias}.

\noindent \underline{\textsc{CatenateAndAttrite}}: : If  holds,  pays for any increase in potential.
Else the new record of  is paid for by  .

: In cases (1) and (2) the potential decreases.  In case (3), the
potential does not change if . If  and
 still contain  elements, the change in potential is paid for by
.

In the following cases, both  and  are large.  Since concatenating
them decreases by one  the number of large I/O-CPQA's, the potential decreases
by at least~, which is enough to pay for any other I/Os also incurred by
\textsc{Bias} and \textsc{Fill}. So we only need to argue that the potential
does not increase in any of the cases.  In fact, in cases (1 - 3) the potential
only decreases.  In case (4), if we make one record, it is paid for by
. Otherwise the second record is paid for by
 if moreover  holds, or by
 otherwise.

All I/Os in \textsc{Fill} and \textsc{Bias} have been paid for by a decrease in
potential caused by their caller. Thus, it suffices to argue that these
operations do not increase the potential.

\noindent \underline{\textsc{Fill}}: Indeed,  only decreases,
when  and  hold.

\noindent \underline{\textsc{Bias}}: Indeed, cases (1) and (2.1) do not create
new records.  Similarly for (2.2), unless  holds, where
 pays for increasing the potential by .  In (2.3)  or
 decreases.
\end{confenv}
\begin{fullenv}

\noindent \underline{\textsc{DeleteMin}}: If  holds after
deleting , then no I/Os are incurred and we only pay an amortized
cost of  for increasing the potential. Else 
holds, so  also holds, which pays for any I/Os in calling
\textsc{Fill} and \textsc{Bias}.

\noindent \underline{\textsc{CatenateAndAttrite}}: If  holds, then we
prepend the non-attrited elements  onto . So if  holds, then each element of  has a potential of ,
which is higher than the potential for each element in . Thus
 pays for any increase in potential. If instead  holds, then  holds, so
 \frac{3|F(Q_1)|}{b} + \Phi_F(|F(Q_2)|)  1+1 
which pays for making the new first record of .

If  holds, then we have three cases depending on how much of  is
attrited by . Let  and :
\begin{enumerate}
  \item : We discard  which releases
     potential and have the four cases:
    \begin{enumerate}[label=\arabic*)]
      \item If :
        The potential decreases, because we only discard records.

      \item Else if : We prepend  onto
         and discard records, which only decreases the potential, since
         when . Our calls to \textsc{Bias} and
        \textsc{Fill} are paid for as we discard .

      \item Else if  or : We set  and discard records,
        which only decreases the potential, since  for
        all .

      \item Else: If  we append  to
         and  pays. Else we make a new dirty queue with
        one new record, which costs 1 potential and 1 potential to cover the
        I/Os in \textsc{Bias}. The total potential difference is
        \frac{2(|L'(Q_1)| + |F(Q_2)|)}{b} + \frac{|F(Q_2)|}{b}
    \end{enumerate}

  \item : We set , which again only
    decreases the potential.

  \item : If  holds, then if
    furthermore  we put the first  elements of
    ,  and  into , with no change in potential. If there
    are still more than  elements left in  and , then we
    put the first  elements into a new last record of  for
    a cost of  in potential and call \textsc{Bias} for a cost of  for
    I/Os, and leave the remaining  elements in  for a cost of
    . All this is paid for, as the total decrease in potential is
     \Phi_L(|L(Q_1)|) + \Phi_F(|F(Q_2)|) 
\end{enumerate}
Both  and  are large in all the cases (\ref{it:Q1C}--\ref{it:D}),
hence when we concatenate them, we decrease the potential by at least~, since
the number of large I/O-CPQA's decreases by one, which is enough to pay for any
other I/Os incurred also in \textsc{Bias} and \textsc{Fill}. So we only need to
argue that the potential does not increase in any of the cases.
\begin{enumerate}
  \item If : the potential decreases, since we discard
    .

  \item Else if : we prepend  onto 
    and  onto , discard and move around records, which only
    decreases the potential, as  when .

  \item Else if : we prepend  onto
    , discard and move around records, which only decreases the
    potentials, as  when .

  \item Else: We make  and  into the first one or two records
    of . Since  is large,  holds, and hence we
    have that . If we only make one new record,
     pays for it. If we make two records, then  holds. So if  moreover holds, then
     pays for the other record. Else 
    holds, but then  also holds, so
    
    which pays for both new records.
\end{enumerate}

\noindent \underline{\textsc{InsertAndAttrite}}: The total cost is 
I/Os amortized, since creating a new I/O-CPQA with only one element and calling
\textsc{CatenateAndAttrite} only costs as much.

\noindent \underline{\textsc{Fill}}: Any I/Os incurred are prepaid by a decrease
in potential made in the procedure calling \textsc{Fill}, so we only need to
argue that the potential does not increase. If  and 
then we append at most  elements to , hence  will only
decrease.

\noindent \underline{\textsc{Bias}}: All I/Os have been paid for by a decrease
in potential caused by the caller of \textsc{Bias}. So we only need to argue
that the potential does not increase because of \textsc{Bias}.
\begin{enumerate}
  \item : We discard, move around and merge records, but we do not
    create new ones. Thus the potential will only decrease.

  \item : We follow the cases of \textsc{Bias}.
  \begin{enumerate}[label=\arabic*)]
    \item : We again discard and move around records, and rearrange
      their elements, but we do not create new records, so the potential will
      only decrease.

    \item : Let . If  holds, we might append  onto , but only if .  This will not increase the potential of  by more
      than , and  pays for that. For the rest of the case we discard and
      move around records and rearrange their elements, but we do not create new
      records, so the potential only decreases.

    \item : If we append the first  elements of  onto ,
      then  holds, so  can only decrease.
      Likewise, when taking at most  elements from , 
      will only decrease.
  \end{enumerate}
\end{enumerate}
\end{fullenv}
\end{proof}

\extraspacing\textbf{Catenating a set of I/O-CPQAs.} 
\fullcmt{Define the \textit{state}
of I/O-CPQA  to be  and the \textit{critical records} of  to
be the first three records of , , ,
,  and , if
it exists. Otherwise  is critical.} The following lemma
is required by the dynamic structure of the next section.

\begin{lemma} \label{lem:seq_concats}
  A set of I/O-CPQAs  for  can be concatenated into a
  single I/O-CPQA without any access to external memory, by calling only
  \textsc{CatenateAndAttrite} operations, provided that for all :
  \begin{enumerate}
    \item  holds, unless  contains only one
      record, in which case  or  contains only two
      records, in which case  suffices.

    \item The critical records of  are loaded in main memory.
  \end{enumerate}
\end{lemma}
\begin{fullenv}
\begin{proof}
In fact, the algorithm considers the I/O-CPQAs~ in decreasing index~
(from right to left). It first sets  and constructs the
temporary I/O-CPQA  by calling
\textsc{CatenateAndAttrite}(,). After the end of the
sequence of operations, the resulting I/O-CPQA~ is the concatenation of
all I/O-CPQAs~.

To avoid any I/Os during the sequence of \textsc{CatenateAndAttrite}s, we
ensure that~\textsc{Bias} and \textsc{Fill} are not called, and that no more
than the critical records need to be already loaded into memory. 
To avoid calling~\textsc{Bias} we maintain the following invariant during the
sequence of catenations.

\begin{enumerate}[label=I.\arabic*)]
  \setcounter{enumi}{9}
  \item \label{in:seq_cat} Each I/O-CPQAs  constructed
    during the sequence of catenations is in state at least  unless it
    consists only of the front buffer in which case it is in state .
\end{enumerate}

We prove the invariant inductively on the sequence of operations. Let the
invariant hold for  and let  be constructed by
\textsc{CatenateAndAttrite}(,). In the following, we parse the
cases of the \textsc{CatenateAndAttrite} algorithm assumming that
.

If  holds, then \textsc{Bias} is not invoked and the state of
 remains  or is increased by .

If  and  then we have to go through the three
respective cases.
\begin{enumerate}
  \item If : if record  exists then the state of  is
    increased by  and it becomes .
  \begin{enumerate}[label=\arabic*)]
    \item If : Since \textsc{Bias} is not called
      \iref{in:seq_cat} holds trivially.

    \item Else if :  is constructed as before
      and we then do the following. Since , we take
      out the the first two records of  which are critical since they
      came from  and . Then, we fill  with one of
      these records provided that no attrition was enforced by . In
      this case, the state of  is  and the invariant holds. If
      attrition took place then  is discarded and the at most two
      records of  and the record in  are combined (notice that
      all of them are critical) to make  consisting only of records in
       and  and thus \iref{in:seq_cat} holds.

    \item Else if  or : Since \textsc{Bias} is not called 
      \iref{in:seq_cat} holds trivially.

    \item Else: the state at the end is , since the state of  was
       by the induction hypothesis. To restore the invariant that the
      state of  should be  we check whether
       is attrited or not by the new dirty queue.
      Since both are critical this can be done with no I/Os and thus the state
      of  is increased to .
  \end{enumerate}

  \item Else if : since we do not call \textsc{Bias}
    \iref{in:seq_cat} holds trivially.

  \item Else : the state of  is only reduced by  which
    makes the state of  being  which is sufficient to maintain
    \iref{in:seq_cat}.
\end{enumerate}



Now we move to the more general case where  and .
\begin{enumerate}
  \item : we do not call \textsc{Bias} so 
    \iref{in:seq_cat} holds trivially.
    
  \item : To increase the state of  from 
    to  we do as follows. We extract the  records of , which
    incurs no I/Os since all four of them are critical (the first was from
     and the other three from the first  critical records of
    ). If no attrition was enforced by , then the state
    of  is . If attrition is enforced then there are not that many
    records in , then  is reconstructed (just prepend
     to  and then prepend the non-attritted records (at
    most  records) from  to  remaking . At the
    end of this process, the new CPQA  has state at least equal to
     which is  by induction and \ref{in:seq_cat} holds.

  \item  or : we
    will only consider the case where  before the concatenation,
    since otherwise the state of  will be equal or larger to the state of
    , which by the inductive hypothesis is . Since  must be
    in state , there are either at least three records in , in
    which case \iref{in:seq_cat} holds and the case is terminated. Otherwise,
    exactly two records exist in  and  is non-empty or there
    are less than two records in  (so the state of  is  or
    ) and  is empty. In the case where two records exist in 
    and  is non-empty: if  is not attritted by  we
    put this record into  and now the final I/O-CPQA  has state
    . Otherwise, we restructure  (as done in the previous case)
    and prepend the non-attrited elements of  onto  resulting in
    an I/O-CPQA with state at least  since this was the state of
    . We follow exactly the same approach in the latter case where
     contains less than two records and  is empty.

  \item Else: the algorithm works exactly as before with the following
    exception. At the end,  will be in state , since we added the
    deque  with a new record and the inequality of
    \iref{in:ineq} is aggrevated by . To restore the invariant we apply
    Case~\ref{it:Beq0}.  \ref{it:KQgt1} of~\textsc{Bias}. This step requires
    access to records~ and . These
    records are both critical, since the former corresponds to  and the latter to . In addition,
    \textsc{Bias} need not be called, since by the invariant,
     was in state  before the removal of .
    In this way, we improve the inequality for  by  and
    \iref{in:seq_cat} holds. 
\end{enumerate}
\end{proof}
\end{fullenv}

\subsection{Final Dynamic Top-Open Structure} \label{sec:skyline}


The data structure consists of a base tree, implemented as a dynamic -tree where the leaves store between  and  elements. We set  and , for a given .  The base
tree indexes the -ordering of , and is augmented with confluently
persistent I/O-CPQAs with buffer size  as secondary
structures. In particular, after constructing the base tree, we augment it with
secondary I/O-CPQAs in a bottom-up manner, as follows. For every leaf we make
one I/O-CPQA over its elements, and execute an appropriate amount of
\textsc{Bias} operations, such that the state of the I/O-CPQA satisfies
Lemma~\ref{lem:seq_concats}. We associate the I/O-CPQA with the leaf.  In a
second pass over the leaves, we gather its critical records into a
\textit{representative block} in its parent. The procedure continues one level
above. For every internal node , we access the representative blocks that
contain the critical records of the children I/O-CPQAs of , and
\textsc{CatenateAndAttrite} them into a new I/O-CPQA as implied by
Lemma~\ref{lem:seq_concats}. We execute \textsc{Bias} on the I/O-CPQA enough
times such that its state also satifies Lemma~\ref{lem:seq_concats}.  We
associate the I/O-CPQA with . After the level has been processed, we create
the representative blocks for I/O-CPQAs associated with the nodes of the level,
in the same way as described above. The augmentation ends at the root node of
the base tree. We will ensure that our algorithms access the I/O-CPQA associated
with a node through the representative block stored at the parent of the node.
Thus, it will suffice to explicitly store only the representative blocks in
every internal node and not its associated I/O-CPQA.

Since every leaf contains  elements, the base tree has 
leaves and thus also  internal nodes. Every internal node has
 children, each associated with an I/O-CPQA with 
critical records of size . Thus the representative blocks
stored in the internal node occupy  blocks of space. Thus the
structure occupies  blocks in total. Assume that  is
already sorted by the -ordering. The leaves' I/O-CPQAs  are created in
 I/Os, since they contain at most  elements. All
representative blocks are created in  I/Os. To create the internal
nodes' I/O-CPQAs, we need only  I/Os to access the representative
blocks and to execute \textsc{Bias} on the resulting I/O-CPQA. Its
representative blocks residing in memory thus are written on disk in 
I/Os. Thus the total preprocessing cost is  and the structure is
SABE.

\extraspacing\textbf{Updates.} To insert (resp. delete) a point  into (resp.
from)~, we insert (resp. delete)  in the
structure. In particular, we first find the leaf to insert (resp. delete) that
contains the predecessor of  (resp. contains ), by a
top-down traversal of the path from the root of the base tree. For every node
 on the path, we also discard the part of its representative block
corresponding to the child that the search path goes into, and 's associated
I/O-CPQA by executing in reverse the operations that created it. Next we insert
(resp. delete)  into (from) the accessed leaf, and rebalance the base
tree by executing the appropriate splits and merges on the nodes along the path
in a bottom-up manner. Moreover, we recompute the I/O-CPQA of every accessed
node on the path, as described above. The total update I/Os are
 in the worst case, since we spend 
I/Os to rebalance every accessed node and to recompute its secondary structures.

\extraspacing\textbf{Queries.} To report the skyline points of  that reside
within a given top-open query range , we first traverse top-down the two search paths  and  from the root of the base tree to
the leaves~ and~ that contain points of  whose
-ordering succeed and precede the query parameters  and
, respectively. Let node  be on the path , and
let  be the children nodes of  whose subtrees are fully contained
within . For every , we load its representative block
into memory in order to access the critical records of the I/O-CPQAs associated
with  and to \textsc{CatenateAndAttrite} them into a temporary I/O-CPQA,
as implied by Lemma~\ref{lem:seq_concats}. We consider the temporary I/O-CPQAs
of nodes  and the I/O-CPQAs of the leaves~ and~ from right to
left, and we \textsc{CatenateAndAttrite} them into one auxiliary I/O-CPQA. The
I/O-CPQAs for  and  are created only on the points within the
-range  in  I/Os.

To report the skyline points within the query range, we call \textsc{DeleteMin}
on the auxiliary I/O-CPQA. The procedure stops as soon as a point with
 is returned, or when the auxiliary I/O-CPQA becomes empty.

There are  nodes on  and we
spend  I/Os to access the representative block of each node. After
this, the construction of the auxiliary I/O-CPQA costs  I/Os. Reporting the  output points costs  I/Os. Therefore the query takes
 I/Os in total.  We
conclude that:

\begin{theorem} \label{thm:3sided}
  There is an indivisible linear-size dynamic data structure on  points in
   that supports top-open range skyline queries in~ I/Os when  points are
  reported, and updates in~ I/Os for any
  parameter~. The structure can be constructed in
   I/Os, assuming an initial sorting on the input points'
  -coordinates.
\end{theorem}

\section{General Range Skyline Queries} \label{sec:4sided}


We now move on to discuss the other variants of range skyline reporting that
are neither symmetric to nor subsumed by top-open queries. It would be nice if
they could be answered in  I/Os by a linear-size
structure. Unfortunately, we will prove its impossibility. In fact, even
sub-polynomial query cost is already unachievable for anti-dominance queries,
let alone left-open and 4-sided queries. In fact, anti-dominance, left-open and
4-sided are just as hard as each other. Next, we will formally establish these
facts. \confcmt{Refer to the full version for the proofs.}

\subsection{A Query Lower Bound}


By making a crucial observation on a variant of the low-discrepancy point set
proposed by Chazelle and Liu \cite{CL04}, we manage to prove the next geometric
fact:
\begin{lemma} \label{lmm:4sided-lower}
  For any integer  and , there is a set  of
   points in  and a set  of  anti-dominance queries such that (i) each query in 
  retrieves  points of , and (ii) at most one point in  is returned by
  two different queries in  simultaneously.
\end{lemma}
\begin{fullenv}
\begin{proof}
We first give some definitions in the context of Chazelle and
Liu~\cite{C90,CL04}. A query set~ is
-\textit{favorable} for a data set~, if  and . Let~ be a set of~
points in~. Let~ be a set of~ orthogonal 2-sided query ranges~. Query range
 is the subspace of  that dominates a given point~ in the positive - and - direction (the ``upper-right''
quadrant defined by~). Let  be the set of all points
in~ that lie in the range~. An \textit{inverse anti-dominance reporting
query}  contains the points of  that do not dominate any other point
in~. This problem is equivalent to the anti-dominance problem by inverting
the coordinates of all points and of the query.

We will now construct a -favorable query set  and its
corresponding point set , where . Without loss of generality, we
assume that , where , since this restriction
generates a countably infinite number of inputs and thus the lower bound is
general. Let us write  as~, where~ is the~-th digit of
number~ in base~. Then define

So~ is the integer obtained by writing~
using~ digits in base~, by first reversing the digits and then
taking their complement with respect to~. We define the points of~
to be the set .\fullcmt{
Figure~\ref{fig:lower} shows an example with  and .}

\fullcmt{
\inkfig{htb}{0.9\linewidth}{LowerBound}{fig:lower}{(Left) An example for  and , the point set  is shown with circles and the the
  queries  are shown with crosses. Two examples of queries are
  shown in red and blue. (Right) The corresponding trie that we used to generate
  the point set, here the red and blue queries are also shown, along with the
  internal node which generated the queries.}{\tiny}{\normalsize}
}

To define the query set~, we encode the set of points
 in a full trie structure of depth~.
Recall that . Notice that the trie structure is implicit
and it is used only for presentation purposes. Input points correspond to the
leaves of the trie and their  value is their label at the edges of the trie,
where the edges at the root have labels  and
the edges at the leafs of the trie have labels .
Let~ be an internal node at depth~ (namely~ has~ ancestors), whose
prefix~ corresponds to the path from the root~ of
the trie to~. We take all points in its subtree and sort them by~. From
this sorted list we construct groups of size~ by always picking
every~-th element starting from the smallest non-picked
element for each group. In this case, we say that the query is
\textit{associated} to node~. Each such group corresponds to the output of a
query.\fullcmt{ See Figure~\ref{fig:lower} for an example.}

A node at depth~ has~ points in its subtree and thus it
defines at most~ queries. Thus, the total number of
queries is:


In the following we prove that  is~-favorable. To
achieve that we need to prove that  and .

First we prove that we can construct the queries so that they have output size
. Assume that we take one of the groups of~ points associated
to node~ at depth~. Let the -coordinates of these points be
 in
increasing order. These have a common prefix of length~ since they all
belong to the subtree of . But we also choose these points so that
. This means that these numbers differ only at the -th
digit. By inversing the procedure to construct these -coordinates, the
corresponding -coordinates~ are determined. By
complementing we take the increasing sequence , where
 and
. By reversing the digits we finally
get the increasing sequence of -coordinates ,
since the numbers differ at only one digit. Thus, the -coordinate of the
group of~ points are decreasing as the -coordinates increase, and as
a result a query~ whose horizontal line is just below~
and the vertical line just to the left of~ will
certainly contain this set of points in the query. In addition, there cannot be
any other points between this sequence and the horizontal or vertical lines
defining query . This is because all points in the subtree of~ have been
sorted with respect to~, while the horizontal line is positioned just
below~, so that no other element lies in between. In the
same manner, no points to the left of~ exist, when
positioning the vertical line of~ appropriately. Thus, for each query~, it holds that~.

We now want to prove that for any two query ranges ,  holds. Assume that~ and~ are associated to
nodes~ and~, respectively, and that their subtrees are disjoint. That
is,~ is not a proper ancestor or descendant of~. In this case, 
and~ share no common point, since each point is used only once in the trie.
For the other case, assume without loss of generality that~ is a proper
ancestor of~ (). By the discussion in the previous paragraph, each
query contains~ numbers that differ at one and only one digit.
Since~ is a proper ancestor of~, the corresponding digits will be
different for the queries defined in~ and for the queries defined in~.
This implies that there can be at most one common point between these
sequences, since the digit that changes for one query range is always set to a
particular value for the other query range.
\end{proof}
\end{fullenv}

We use the term {\em -input} to refer to the point set 
obtained in Lemma~\ref{lmm:4sided-lower} after  and  have been
fixed. We deploy such input sets to derive:

\begin{lemma} \label{lmm:4sided-lower-detailed}
  Regarding anti-dominance queries on  points in , any structure
  (in the indexability model) of at most  blocks must incur
   I/Os to answer a query in the worst case,
  where  is a constant and  is the result size.
\end{lemma}

\begin{fullenv}
\begin{proof}
  Let us first review the {\em indexability theorem} of \cite[Theorem
  5.5]{HKMPS02}. Let  be a structure on a -input.
  Define the {\em access overhead} of  as the smallest value  that
  allows us to claim:  answers any query with output size  in
   I/Os. In the context of Lemma~\ref{lmm:4sided-lower}, the
  indexability theorem states:
	\begin{center}
    {\em if  and ,  must
    use at least  blocks.}
	\end{center}

  Next, we will argue that if a structure has query complexity
  , it must use strictly more than  blocks
  in the worst case. This implies that no structure of at most  blocks
  can guarantee the aforementioned query time, and hence, proving
  Lemma~\ref{lmm:4sided-lower-detailed}.

  Consider any structure with query time . Let
   be the structure's instance on an -input where
   and . The I/O cost of  answering a
  query with output size  is at most
	
  where  is a certain constant. It thus follows that  when  is sufficiently large.
  Therefore, by the indexability theorem, the structure must occupy at least
   blocks.
\end{proof}
\end{fullenv}



\begin{theorem} \label{thm:4sided-lower2}
  Regarding anti-dominance queries on  points, any linear-size structure
  under the indexability model must incur  I/Os
  answering a query in the worst case, where  can be an arbitrarily
  small constant, and  is the result size.
\end{theorem}

\confcmt{
   \noindent {\bf Remarks.} In the full version, we utilize
   Lemma~\ref{lmm:4sided-lower} to prove that any internal memory pointer-based
   data structure that supports anti-dominance queries in~ time requires  space. Thus, the
   dynamic structure of~\cite{BT11} for 4-sided queries occupies optimal space
   within a  factor, for the attained query time.
 }

\subsection{Query-Optimal Structure}


The above lower bound is tight. In fact, we are able to prove a stronger fact: a
{\em 4-sided} query can be answered in  I/Os by a
linear-size dynamic structure. \confcmt{Deferring the details to the full
version, we claim:}

\begin{theorem} \label{thm:4sided-main}
  There is an indivisible linear-size structure on  points in  such
  that, 4-sided range skyline queries can be answered in  I/Os, where  is the number of reported points. The query cost is
  optimal under the indexability model. The structure can be updated in
   amortized I/Os.
\end{theorem}
\begin{fullenv}
\begin{proof}
\extraspacing \textbf{Structure.} Create a weight-balanced B-tree
\cite{AV03}  on the -coordinates of the points in . Each leaf node of
 has capacity , and each internal node has  child nodes where
. The height  of  is thus .  For a node  in , let  be the set of points
whose -coordinates are in the subtree of .  We manage  using a
structure  of Theorem~\ref{thm:3sided} for answering right-open queries.
Specifically,  answers a right-open query and supports an update in
 I/Os. The right-open structures of all nodes at the
same level of  consume  space in total. As  has only constant
levels, the total space cost is .

\extraspacing \textbf{Query.} Given a 4-sided query with search
rectangle , we find in
 I/Os the leaf nodes  of 
containing the successor and predecessor of  and 
respectively, among the -coordinates indexed by . If , solve
the query by loading the  points in  into memory with  I/Os.

Consider now . Let  () be the path from the lowest
common ancestor of  and  to  (). Let  be the set of
child nodes  of the internal nodes on  such that the
-interval of  is fully contained in  (the
-interval of  tightly encloses the -coordinates in the subtree of
). The nodes of  have disjoint -intervals, and can be listed out in
descending order of their -intervals with 
I/Os. Also, .

Find the skyline of  in one I/O; let  be the
-coordinate of the highest point in this skyline. Next, we process the nodes
of  in descending order of their -intervals. For each , perform
a right-open query with  on
, and output all the points retrieved. If the query returns at least one
point, update  to the -coordinate of the highest point returned.
Finally, issue a 4-sided query with  on  in one I/O.

Since each right-open query costs  I/Os (plus linear output
time), all such queries on the nodes of  have total cost .

\extraspacing \textbf{Update}. To insert a point  into , first
descend a root-to-leaf path  to the leaf node  of  where 
should be placed. For each interval node  along , insert  to 
in  I/Os. Since  has  levels, the cost so
far is .

Next, update the base tree  by inserting . If an internal node  is
split, we construct  for each new node  from scratch by simply
inserting into  all the relevant points in 
I/Os. The cost can be charged on the  updates that have
occurred beneath  since its creation. Hence, each of those updates bears
 I/Os. Since an update needs to bear such cost only 
times, the total amortized cost is still .

A deletion can be handled in a similar manner. Finally, reconstruct the entire
structure after  updates to make sure that  does not change until
 is rebuilt next time. Standard analysis shows that the amortized update
overhead remains .
\end{proof}

\subsection{Pointer Machine Space Lower Bound}


In the pointer machine (PM) model, a data structure that stores a data set 
and supports range reporting queries for a query set , can be
modelled as a directed graph  of bounded out-degree with some nodes being
\emph{entry nodes}. In particular, every node in  may be assigned an element
of  or may contain some other useful information. For a query range , the algorithm navigates over the edges of  in order to locate
all nodes that contain the answer to the query. The algorithm may also traverse
other nodes. The time complexity of reporting the output of~ is at least
equal to the number of nodes accessed in graph~ for~.

Given a directed graph  modelling a data structure in the PM, Chazelle and
Liu~\cite{C90,CL04} define the graph~ to be
-\textit{effective}, if a query is supported in  time, where~ is the output size,~ is a multiplicative
factor for the output size ( for our purposes) and~
is the additive factor.  Moreover, a query set~ is
-\textit{favorable} for a data set~, if  and . Intuitively, the first part
of this property requires that the size of the output is large enough (at
least~) so that it dominates the additive factor of~ in the
time complexity. The second part requires that the query outputs have minimum
overlap, in order to force~ to be large without many nodes containing the
output of many queries. The following lemma exploits these properties to
provide a lower bound on the minimum size of~.

\begin{lemma}[From {\cite[Lemma 2.3]{CL04}}] \label{lem:lower}
  For an -effective graph~ for the data set~, and for an
  -favorable set of queries~, the graph 
  contains~ nodes, for constant~ and for
  any large enough~.
\end{lemma}

\begin{theorem} \label{thm:lower}
  The anti-dominance reporting problem in the Pointer Machine requires
   space, if the query is
  supported in~ time, where~ is the size of the
  answer to the query and parameter .
\end{theorem}
\begin{proof}
  Lemma~\ref{lmm:4sided-lower} allows us to apply Lemma~\ref{lem:lower}, when
  setting  and , for some constant
  . Thus the query time of , for output
  size~, can only be achieved at a space cost of
  .
\end{proof}
\end{fullenv}





\section*{ACKNOWLEDGEMENTS}

The work of Yufei Tao and Jeonghun Yoon was supported in part by (i) projects GRF 4166/10, 4165/11, and 4164/12 from HKRGC, and (ii) the WCU (World Class University) program under the National Research Foundation of Korea, and funded by the Ministry of Education, Science and Technology of Korea (Project No: R31-30007).

\bibliographystyle{abbrv}
\bibliography{References}

\end{document}
