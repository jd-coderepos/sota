
\documentclass{article} \usepackage{iclr2021_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 \usepackage[ruled,vlined]{algorithm2e}

\usepackage{latexsym}
\usepackage{amsmath}
\newcommand{\bs}[1]{\mathbfsymbol{#1}}
\newcommand{\tf}[1]{\textbf{#1}}
\usepackage{amssymb,amsmath,amsthm,enumitem}
\usepackage{comment}
\usepackage{multirow}
\usepackage{tablefootnote}
\usepackage{url}
\usepackage{graphics}
\usepackage{amsmath}
{
    \theoremstyle{plain}
    \newtheorem{assumption}{Assumption}
}
\SetKwInput{KwInput}{Input}                \SetKwInput{KwOutput}{Output}              \SetKwFunction{KWFunction}{Procedure}
\usepackage{times}
\usepackage{graphicx}
\usepackage{amsmath,amssymb,enumerate,bbm,color,alltt}
\usepackage{graphicx}
\usepackage{float}
\usepackage{stfloats}
\usepackage{subfig}
\usepackage{longtable}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{subfig}
\usepackage{url}


\usepackage{algpseudocode}





\usepackage{hyperref}
\usepackage{url}
\usepackage{tabularx}
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}
\usepackage{wrapfig,lipsum,booktabs}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{subfig}
\usepackage{adjustbox} 
\usepackage{caption}

\newcommand{\EE}{\mathbb{E}}


\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\title{Improving Self-supervised Pre-training \emph{via} a Fully-Explored Masked Language Model}


\author{Mingzhi Zheng$^{\mathbf{1*}}$, ~Dinghan Shen$^{\mathbf{1}}\thanks{~~Equal contribution.}~~$, ~Yelong Shen$^{\mathbf{1}}$, ~Weizhu Chen$^{\mathbf{1}}$, ~Lin Xiao$^{\mathbf{2}}$ \\
$^{\mathbf{1}}$ Microsoft Dynamics 365 AI~~~~
	$^{\mathbf{2}}$ Microsoft Research~~~ \\
{\tt \{mizheng, dishen, yeshe, wzchen, lin.xiao\}@microsoft.com} \\
}





\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}

\maketitle
\begin{abstract}
Masked Language Model (MLM) framework has been widely adopted for self-supervised language pre-training.  
In this paper, we argue that randomly sampled masks in MLM would lead to undesirably large gradient variance.
Thus, we theoretically quantify the gradient variance via correlating the gradient covariance with the Hamming distance between two different masks (given a certain text sequence).
To reduce the variance due to the sampling of masks, we propose a \emph{fully-explored} masking strategy, where a text sequence is divided into a certain number of \emph{non-overlapping} segments. 
Thereafter, the tokens within one segment are masked for training. 
We prove, from a theoretical perspective, that the gradients derived from this new masking schema have a smaller variance and can lead to more efficient self-supervised training. We conduct extensive experiments on both continual pre-training and general pre-training from scratch. Empirical results 
confirm that this new masking strategy can consistently outperform standard random masking.
Detailed efficiency analysis and ablation studies further validate the advantages of our \emph{fully-explored} masking strategy under the MLM framework.
\end{abstract}
\vspace{-2mm}
\section{Introduction} 
\vspace{-2mm}
Large-scale pre-trained language models have attracted tremendous attention recently due to their impressive empirical performance on a wide variety of NLP tasks.
These models typically abstract semantic information from massive unlabeled corpora in a self-supervised manner. Masked language model (MLM) has been widely utilized as the objective for pre-training language models. In the MLM setup, a certain percentage of words within the input sentence are masked out, and the model learns useful semantic information by predicting those missing tokens. 

Previous work found that the specific masking strategy employed during pre-training plays a vital role in the effectiveness of the MLM framework \citep{liu2019roberta, joshi2019spanbert, sun2019ernie}. 
Specifically, \citet{sun2019ernie} introduce entity-level and phrase-level masking strategies, which incorporate the prior knowledge within a sentence into its masking choice. 
Moreover, \citet{joshi2019spanbert} propose to mask out random contiguous spans, instead of tokens, since they can serve as more challenging targets for the MLM objective. 

Although effective, we identify an issue associated with the random sampling procedure of these masking strategies. 
Concretely, the difficulty of predicting each masked token varies and is highly dependent on the choice of the masking tokens. For example, predicting stop words such as ``\emph{the}'' or ``\emph{a}'' tends to be easier relative to nouns or rare words. As a result, with the same input sentence, randomly sampling certain input tokens/spans, as a typical masking recipe, will result in undesirable large variance while estimating the gradients. 
It has been widely demonstrated that large gradient variance typically hurts the training efficiency with stochastic gradient optimization algorithms \citep{zhang2019stochastic, xiao2014proximal, johnson2013accelerating}.
Therefore, we advocate that obtaining gradients with \emph{a smaller variance} has the potential to enable more sample-efficient learning and thus accelerate the self-supervised learning stage. 


In this paper, we start by introducing a theoretical framework to quantify the variance while estimating the training gradients. The basic idea is to decompose the total gradient variance into two terms, where the first term is induced by the data sampling process and the second one relates to the sampling procedure of masked tokens. Theoretical analysis on the second variance term demonstrates that it can be minimized by reducing the gradient covariance between two masked sequences.
Furthermore, we conduct empirical investigation on the correlation between the gradient's covariance while utilizing two masked sequences for training and the Hamming distance between these sequences. We observed that that the gradients' covariance tends to decrease monotonically \emph{w.r.t} the sequences' Hamming distance.   


Inspired by the observations above, we propose a \emph{fully-explored} masking strategy, which maximizes the Hamming distance between any of two sampled masks on a fixed text sequence. First, a text sequence is randomly divided into multiple \emph{non-overlapping} segments, where each token (\emph{e.g.} subword, word or span) belongs to one of them. 
While the model processes this input, several different training samples are constructed by masking out one of these segments (and leaving the others as the contexts). In this manner, the gradient \emph{w.r.t.} this input sequence can be calculated by averaging the gradients across multiple training samples (produced by the same input sequence). 
We further verify, under our theoretical framework, that the gradients obtained with such a scheme tend to have smaller variance, and thus can improve the efficiency of the pre-training process. 

We evaluate the proposed masking strategies on both continued pre-training \citep{gururangan2020don} and from-scratch pre-training scenarios. 
Specifically, Computer Science (CS) and News domain corpus \citep{gururangan2020don} are leveraged to continually pre-train RoBERTa models, which are then evaluated by fine-tuning on downstream tasks of the corresponding domain. 
It is demonstrated that the proposed fully-explored masking strategies lead to pre-trained models with stronger generalization ability. 
Even with only a subset of the pre-training corpus utilized in \citep{gururangan2020don}, our model consistently outperforms reported baselines across four natural language understanding tasks considered. 
Besides, we also show the effectiveness of our method on the pre-training of language models \emph{from scratch}. 
Moreover, the comparison between fully-explored and standard masking strategies in terms of their impacts on the model learning efficiency further validates the advantages of the proposed method.
Extensive ablation studies are further conducted to demonstrate the robustness of the proposed masking scheme.

\vspace{-3mm}
\section{Related Work}
\vspace{-2mm}
\paragraph{Self-supervised Language Pre-training} 
Self-supervised learning has been demonstrated as a powerful paradigm for natural language pre-training in recent years. Significant research efforts have been devoted to improve different aspects of the pre-training recipe, including training objective \citep{lewis2019bart, clark2019electra, bao2020unilmv2, liu2019roberta}, architecture design \citep{yang2019xlnet, he2020deberta}, the incorporation of external knowledge \citep{sun2019ernie, Zhang2019ERNIEEL}, \emph{etc}. The idea of self-supervised learning has also been extended to generation tasks and achieves great results \citep{Song2019MASSMS, dong2019unified}. 
Although impressive empirical performance has been shown, relatively little attention has been paid to the efficiency of the pre-training stage. ELECTRA \citep{clark2019electra} introduced a discriminative objective that is defined over all input tokens. Besides, it has been showed that incorporating language structures \citep{wang2019structbert} or external knowledge \citep{sun2019ernie, Zhang2019ERNIEEL} into pre-training could also help the language models to better abstract useful information from unlabeled samples. 

In this work, we approach the training efficiency issue from a different perspective, and argue that the masking strategies, as an essential component within the MLM framework, plays a vital role especially in efficient pre-training. Notably, our \emph{fully-explored} masking strategies can be easily combined with different model architectures for MLM training. Moreover, the proposed approach can be flexibly integrated with various tokenization choices, such as subword, word or span \citep{joshi2019spanbert}. A concurrent work \citet{chen2020variance} also shared similar motivation as this work, although they have a different solution and their method requires additional computation to generate the masks, and yet is outperformed by the proposed \emph{fully-explored} masking (see Table~\ref{tab:eval_1}).
\vspace{-2mm}
\paragraph{Domain-specific Continual Pre-training}
The models mentioned above typically abstract semantic information from massive, heterogeneous corpora. Consequently, these models are not tailored to any specific domains, which tends to be suboptimal if there is a domain of interest beforehand. \citet{gururangan2020don} showed that continual pre-training (on top of general-purpose LMs) with in-domain unlabeled data could bring further gains to downstream tasks (of that particular domain).
One challenge inherent in continual pre-training is that in-domain data are usually much more limited, compared to domain-invariant corpora. As a result, how to efficiently digest information from unlabeled corpus is especially critical while adapting large pre-trained language models to specific domains. 
To this end, we specifically consider the continual pre-training scenario to evaluate the effectiveness of our approach. 

\vspace{-2mm}
\section{Proposed Approach}
\vspace{-3mm}
In this section, we first review the MLM framework that is widely employed for natural language pre-training. Motivated by the gradient variance analysis of MLM in section \ref{sec:mlm_variance}, we present the \emph{fully-explored} masking strategy, which serves as a simple yet effective solution to reduce the gradient variance during training. Connections between our method and variance reduction theory are further drawn, which provides a theoretical foundation for the effectiveness of the proposed strategy. Finally, some specific implementation details are discussed. 

\begin{figure*}
	\centering
	\includegraphics[width=0.88\textwidth]{fig/fully-explored_masking}
	\vspace{-2mm}
	\caption{Illustration of the proposed fully-explored masking strategy with a specific example. In this case, the input sequence has been divided into $4$ exclusive segments, where different colors indicate which segment a certain token belongs to. }
	\vspace{-2mm}
	\label{fig:fully-explored_masking}
	\vspace{-2mm}
\end{figure*}

\vspace{-2mm}
\subsection{Background: the MLM framework}
\vspace{-2mm}
Let $V$ denote the token vocabulary and $\mathbf{x}=(x_1,\ldots,x_n)$ denote a sentence of $n$ tokens, where $x_i\in \mathcal{V}$ for $i=1,\ldots,n$.
Let $\mathbf{m}=(m_1,\ldots,m_n)$ denote a binary vector of length~$n$, where $m_i\in\{0,1\}$, representing the mask over a sentence. 
Specifically, $m_i=1$ means the token $x_i$ is masked and $m_i=0$ if $x_i$ is not masked.
We use $\mathbf{m}\circ\mathbf{x}$ to denote a masked sentence, that is,
\[
(\mathbf{m}\circ\mathbf{x})_i = \begin{cases} \texttt{[MASK]} & \mbox{if}~ m_i=1, \\ x_i & \mbox{if}~ m_i=0. \end{cases}
\]
In addition, let $\overline{\mathbf{m}}$ be the complement of $\mathbf{m}$; in other words, $\overline{m}_i=0$ if $m_i=1$ and $\overline{m}_i=1$ if $m_i=0$. Naturally, $\overline{\mathbf{m}}\circ\mathbf{x}$ denotes a sentence with the complement mask $\overline{\mathbf{m}}$. 

For a typical language model with parameters $\theta$, its loss function over a sentence $\mathbf{x}\in \mathcal{V}^n$ and a mask $\mathbf{m}\in\{0,1\}^n$ as
\begin{align}
\ell(\theta;\mathbf{x}, \mathbf{m}) 
= -\log P(\overline{\mathbf{m}}\circ\mathbf{x} \,|\, \theta,\mathbf{m}\circ \mathbf{x}) 
= -\sum_{i\,:\, m_i=1} \log P(x_i \,|\, \theta,\mathbf{m}\circ \mathbf{x}),
\end{align}
where $P(x_i \,|\, \theta,\mathbf{m}\circ \mathbf{x})$ is the probability of the model correctly predicting $x_i$ given the masked sentence $\mathbf{m}\circ\mathbf{x}$. If $m_i=0$, it always has $P(x_i \,|\, \theta,\mathbf{m}\circ \mathbf{x})=1$ as the ground-truth $x_i$ is not masked.   

We will focus on masks with a fixed length. Let $\tau$ be an integer satisfying $0\leq\tau\leq n$. The set of possible masks of length $\tau$ is defined as $\mathcal{M}(\tau)$ ,
\[
\mathcal{M}(\tau) = \bigl\{\mathbf{m}\in\{0,1\}^n~|~ \textstyle\sum_{i=1}^n m_i=\tau\bigr\},
\]
which has a cardinality $|\mathcal{M}(\tau)|=\binom{n}{\tau}=\frac{n!}{\tau!(n-\tau)!}$.
Therefore, the average loss function over a sentence $\mathbf{x}$ with masks of length~$\tau$ is,
\begin{align}
L(\theta;\mathbf{x}) 
= \EE_{\mathbf{m}\sim\mathrm{Unif}(\mathcal{M}(\tau))} \ell(\theta;\mathbf{x}, \mathbf{m}) 
=\frac{1}{\binom{n}{\tau}}\sum_{\mathbf{m}\in\mathcal{M}(\tau)}\ell(\theta;\mathbf{x}, \mathbf{m}) .
\end{align}
Let's consider $P_{\mathcal{D}}$ as the probability distribution of sentence in a corpus $\mathcal{D}\subset\mathcal{V}^n$. 
The overall loss function for training the masked language model over corpus $\mathcal{D}$ is
\begin{align}
L(\theta) \triangleq 
\EE_{\mathbf{x}\sim P_{\mathcal{D}}} L(\theta;\mathbf{x}) 
= \EE_{\mathbf{x}\sim P_{\mathcal{D}}} \EE_{\mathbf{m}\sim\mathrm{Unif}(\mathcal{M}(\tau))} \ell(\theta;\mathbf{x}, \mathbf{m}). 
\end{align}
During each step of the training process, it randomly samples a mini-batch of sentences $\mathcal{S}_t\subset\mathcal{D}$.
For each $\mathbf{x}\in\mathcal{S}_t$, we randomly pick a subset of masks $\mathcal{K}_t(\mathbf{x})\subset\mathcal{M}(\tau)$, independently across different~$x$. Thus, the mini-batch stochastic gradient is
\begin{align}
g_t(\theta) = \frac{1}{S}\sum_{\mathbf{x}\in\mathcal{S}_t} \frac{1}{K}\sum_{\mathbf{m}\in\mathcal{K}_t(\mathbf{x})}\nabla_{\!\theta}\ell(\theta;\mathbf{x},\mathbf{m}).
\label{eq:full_grad}
\end{align}

where $|\mathcal{S}_t|=S$ and $|\mathcal{K}_t(\mathbf{x})|=K$ for all $t$.
Clearly we have $\EE[g_t(\theta)] = \nabla L(\theta)$. In the
following sections, it first gives the variance of $g_t(\theta)$ which is an important factor to influence model training efficiency \citep{xiao2014proximal, zhang2019stochastic}, and then it presents the proposed \emph{fully-explored} masking strategy to help reduce the gradient variance of the masked language model.


\vspace{-2mm}
\subsection{Analysis: Gradient Variance of MLM}
\vspace{-2mm}
\label{sec:mlm_variance}
According to the law of total variance \citep{neil_acourse_in_probability}, the variance of the mini-batch stochastic gradient $\Var_{\mathcal{S}_t,\mathcal{K}_t}(g_t)$ can be decomposed as follows, 
\begin{align}
\Var_{\mathcal{S}_t,\mathcal{K}_t}(g_t) 
= \EE_{\mathcal{S}_t}\bigl[\Var_{\mathcal{K}_t}(g_t)\,|\,\mathcal{S}_t\bigr]
+\Var_{\mathcal{S}_t}\bigl(\EE_{\mathcal{K}_t}\left[g_t\,|\, \mathcal{S}_t)\right]\bigr),
\label{eqn:mini-batch-var}
\end{align}

where for simplicity $g_t$ indicates $g_t(\theta)$ as in eqn. \ref{eq:full_grad}, the first term captures the variance due to the sampling of masks, and the second term is the variance due to the sampling of mini-batch sentences.



In this work, we focus on the analysis of the first term in eqn. \ref{eqn:mini-batch-var}: the variance due to the sampling of masks. Denote
$g(\mathbf{m})=\nabla_{\!\theta} \ell(\theta;\mathbf{x},\mathbf{m})$ for any fixed sentence $\mathbf{x}$. Consider a subset of random masks
$(\mathbf{m}_1,\ldots,\mathbf{m}_K)$ and the $K$-masks gradient is defined as the average of them: 
\begin{align}
\label{eq:grad}
g(\mathbf{m}_1,\ldots,\mathbf{m}_K) = \frac{1}{K}\sum_{k=1}^K g(\mathbf{m}_k).
\end{align}

\begin{theorem}
\label{varmlm}
The Variance of $K$-masks gradient:  $\Var\bigl(g(\mathbf{m}_1,\ldots,\mathbf{m}_K)\bigr)$ is
\begin{align}
\label{var_k_mask}
\frac{1}{K} \Var\bigl(g(\mathbf{m}_1)\bigr) + \left(1-\frac{1}{K}\right)\Cov\bigl(g(\mathbf{m}_1),g(\mathbf{m}_2)\bigr).
\end{align}
\end{theorem}
where, 
\vspace{-6mm}
\begin{align}
\Cov\bigl(g(\mathbf{m}_1),g(\mathbf{m}_2)\bigr) 
= \EE\left[\bigl(g(\mathbf{m}_1) - \bar{g}\bigr)^T\bigl(g(\mathbf{m}_2) - \bar{g}\bigr)\right], 
\end{align}
and 
\vspace{-6mm}
\begin{align}
\bar{g}=\EE_{\mathbf{m}\sim\mathrm{Unif}(\mathcal{M}(\tau))} g(\mathbf{m})
=\frac{1}{\binom{n}{\tau}}\sum_{\mathbf{m}\in\mathcal{M}(\tau)} g(\mathbf{m}).
\end{align}
The detailed proof of Theorem \ref{varmlm} is given in Appendix \ref{appendix:1}. In the theorem \ref{varmlm}, it indicates that the variance of $K$-masks gradient can be reduced by decreasing the gradient covariance between different masks.
\vspace{-2mm}
\subsection{Variance Reduction: Fully-Explored Masking}
\vspace{-2mm}










Intuitively, if we consider the two random masks $\mathbf{m}_1$ and $\mathbf{m}_2$ are totally overlapped, the gradient covariance between them should be maximized. It motivates us to consider the correlation between gradient covariance and Hamming distance between these two masks. Thus, we have the following assumption:
\begin{assumption}\label{asmp:cov-hamming}
	The covariance $\Cov\bigl(g(\mathbf{m}_1),g(\mathbf{m}_2)\bigr)$ is monotone decreasing in term of the Hamming distance between $\mathbf{m}_1$ and $\mathbf{m}_2$.
\end{assumption}



To verify the Assumption \ref{asmp:cov-hamming}, we sample a small set of CS domain sentences from S2ORC dataset \citep{gururangan2020don} as the fixed mini-batch for our analysis, then calculate gradient covariance $\Cov\bigl(g(\mathbf{m}_1),g(\mathbf{m}_2)\bigr)$ of mask pairs $(\mathbf{m}_1,\mathbf{m}_2)$ with different Hamming distances $H(\mathbf{m}_1,\mathbf{m}_2)$ using this mini-batch. In Figure \ref{fig:variance-hamming-distr}, the center of gradient covariance distribution is shifting to left (lower value) as Hamming distance increases. In Figure \ref{fig:variance-hamming}, we also observe that the average gradient covariance is decreasing in term od Hamming distance. As shown in Figure \ref{fig:variance-hamming-distr}, \ref{fig:variance-hamming}, Assumption \ref{asmp:cov-hamming} holds for both RoBERTa-base model \citep{liu2019roberta} and RoBERTa-base model after continually pre-trained on CS domain corpus.

\begin{minipage}{\textwidth}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\includegraphics[width=0.98\textwidth]{fig/roberta-base.png} 
\vspace{-1mm}
\end{minipage}
\hfill
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\includegraphics[width=0.98\textwidth]{fig/roberta-base_s2orc-cs.png} 
\vspace{-1mm}
\end{minipage}
\captionof{figure}{The distributions of gradient covariance $\Cov\bigl(g(\mathbf{m}_1),g(\mathbf{m}_2)\bigr)$ for different Hamming distances $H(\mathbf{m}_1,\mathbf{m}_2)$ based on a small CS domain corpus. \underline{Left}: gradient covariance distribution of selected parameters in RoBERTa-base model; \underline{Right}: gradient covariance distribution of selected parameters in RoBERTa-base model after continually pre-trained on CS domain corpus.}
\label{fig:variance-hamming-distr}
\end{minipage}







\begin{minipage}{\textwidth}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\includegraphics[width=0.85\textwidth]{fig/hamming_1.pdf} 
\vspace{-2mm}
\end{minipage}
\hfill
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\includegraphics[width=0.85\textwidth]{fig/hamming_2.pdf} 
\vspace{-2mm}
\end{minipage}
\captionof{figure}{Empirical analysis of the correlation between gradient covariance $\Cov\bigl(g(\mathbf{m}_1),g(\mathbf{m}_2)\bigr)$ and Hamming distance $H(\mathbf{m}_1,\mathbf{m}_2)$ based on a small CS domain corpus. For a sequence of length 512, two masks $\mathbf{m}_1$, $\mathbf{m}_2$ are randomly sampled with $128$ masked tokens, their Hamming distance satisfying $0\leq H(\mathbf{m}_1,\mathbf{m}_2) \leq 256$. \underline{Left}: gradient covariance calculated based on RoBERTa-base model; \underline{Right}: gradient covariance calculated based on RoBERTa-base model after continually pre-trained on CS domain corpus.}
\label{fig:variance-hamming}
\end{minipage}

We propose the \emph{fully-explored} masking strategy which restricts masks sampled from $\mathcal{M}(\tau)$ to be non-overlapping, denoted as $\mathcal{M}_{\text{FE}}(\tau)$ for simplicity: 
\begin{align}
\label{non_overlap}
    \mathbf{m}_1,\ldots,\mathbf{m}_K \sim \mathcal{M}_{\text{FE}}(\tau), \forall_{i \neq j} H(\mathbf{m}_i, \mathbf{m}_j) = 2 \tau
\end{align}
With the \emph{fully-explored} masking strategy, it can be easily approved that expectation of gradient over $\mathcal{M}_{\text{FE}}(\tau)$ is an unbiased estimation of the expectation of gradient over $\mathcal{M}(\tau)$ as in the Lemma \ref{no_bias_lemma}.  In the Lemma \ref{variance_lemma}, it states that the Theorem \ref{varmlm} is still hold for \emph{fully-explored} masking strategy, which indicates that the variance of K-masks gradient can be reduced by restricting the masks sampling from $\mathcal{M}_{\text{FE}}(\tau)$.
\begin{lemma}
\label{no_bias_lemma}
The expectation of gradient over $\mathcal{M}_{\text{FE}}(\tau)$ equals to the expectation of gradient over $\mathcal{M}(\tau)$.
\begin{proof}
The joint distributions of $(\mathbf{m}_1,\ldots,\mathbf{m}_K)$ sampling from $\mathcal{M}_{\text{FE}}(\tau)$ is different from the i.i.d.\ case due to the non-overlapping restriction. However, the marginal distributions of $\mathbf{m}_k$ are still the same uniform distribution over $\mathcal{M}(\tau)$.
Therefore, we still have $\EE\bigl[g(\mathbf{m}_k)\bigr]=\bar{g}, \forall_{k=1,\ldots,K}$ and as a consequence $\EE\bigl[g(\mathbf{m}_1,\ldots,\mathbf{m}_K)\bigr]=\bar{g}$. 
\end{proof}
\end{lemma}
\begin{lemma}
\label{variance_lemma}
The derivation of $K$-masks gradient variance in Eqn.\ref{var_k_mask} holds for both $\mathcal{M}_{\text{FE}}(\tau)$ and $\mathcal{M}(\tau)$.
\end{lemma}
The detailed proof of Lemma \ref{variance_lemma} can be seen in Appendix \ref{sec:lemm3}.



\vspace{-2mm}
\subsection{Implementation Details}
\vspace{-2mm}
The details of \emph{fully-explored} masking algorithm is illustrated in Algorithm \ref{alg:msk}. In practice, a text sequence $\mathcal{S}_i$ is tokenized into subword pieces \citep{devlin2018bert} with the maximum sequence length $n$ set as $512$ in the experiments. To understand the performance of \emph{fully-explored} masking strategy at different granularity, the text sequence $\mathcal{S}_i$ is masked at both subword level \citep{devlin2018bert,liu2019roberta} and span level \citep{joshi2019spanbert,wang2019structbert}. The details about other hyperparameters, i.e., masking-ratio and number of splits $K$ will be discussed in experiment section.      
 



\begin{algorithm}[H]
\SetAlgoLined
\KwInput{Language corpus ${\mathcal{D} = \{ \mathcal{S}_1, ..., \mathcal{S}_T \}}$, $|\mathcal{S}_i| = n$; Masking ratio $\frac{\tau}{n}$;  Number of sampling masks $K$, where $K * \frac{\tau}{n} \leq 1$;  Initial model parameters $\theta_0$;  }
\KwOutput{model parameters $\theta^*$}
\ForEach {$\mathcal{S}_i \in \mathcal{S} $} 
 { \hspace{0.0cm}Sample K split masking vectors $(\vm_1, ..., \vm_K)$ from $\mathcal{M}_{{\text{FE}}}(\tau)$ as in Eqn.\ref{non_overlap}. \\Calculate the gradient $g(\vm_1, ..., \vm_K)$ as in Eqn. \ref{eq:grad}. \\Update model parameters $\theta_{i+1} = \text{Optimizer}(\theta_i, g(\vm_1, ..., \vm_K))$ }\
{return $\theta^* = \theta_T$}
\label{alg:msk}
\caption{Fully-explored Masking Language Model}
\end{algorithm}


















\vspace{-2mm}
\section{Experiments}
\vspace{-3mm}
In this section, we evaluate the proposed \emph{fully-explored} masking strategy for natural language pre-training in two distinct settings: 
\emph{\romannumeral1}) continual pre-training, where a given pre-trained model is further adapted leveraging domain-specific unlabeled corpus;
\emph{\romannumeral2}) pre-training from scratch, where large-scale corpus such as Wikipedia and BookCorpus are employed to pre-train a model from the beginning.
We also compare the training efficiency of FE-MLM and MLM frameworks to validate our theoretical findings.
Ablation studies and analysis are further conducted regarding the proposed approach.

\vspace{-4mm}
\subsection{Experimental Settings}
\vspace{-3mm}
For the continual pre-training scenario, we consider unlabeled corpus from two different domains, \emph{i.e.}, computer science (CS) papers and news text from RealNews, introduced by \cite{gururangan2020don}. As to the downstream tasks, ACL-ARC citation intent \cite{Jurgens2018MeasuringTE} and SciERC relation classification \cite{Luan2018MultiTaskIO} are utilized for the CS domain. While for the News domain, HyperPartisan news detection \cite{kiesel2019semeval} and AGNews \cite{zhang2015character} are employed to facilitate the comparison with \cite{gururangan2020don}. 

Following \citep{gururangan2020don} for a fair comparison, RoBERTa \cite{liu2019roberta} is leveraged as the initial model for continual pre-training, where the same training objective is optimized on the domain-specific corpus. We choose a batch size of $48$, and the model is trained using Adam \cite{kingma2014adam}, with a learning rate of $1 \times 10^{-4}$. It is worth noting that we observe, in our initial experiments, that downsampling only $72$k documents from the total of $2.22$M used by \cite{gururangan2020don} can result in similar performance on downstream tasks. This happens in the News domain as well, where we randomly sample $623$k documents out of 11.90M. The model is continually pre-trained for around $40$k and $20$k steps on the CS and News domain, respectively. One important hyerparameter under the FE-MLM framework is the number of split the input sequence is divided into, where we use $4$ as the default setting. The sensitivity of the proposed algorithm \emph{w.r.t} this hyperparameter is further investigated (see Figure~\ref{fig:efficiency_split}).

For the general pre-training experiments, we employ BERT as the baseline model. Wikiepdia and BookCorpus \citep{zhu2015aligning} are used as the pre-training corpus, with a total size of $16$G. We adopt the same tokenization (\emph{i.e.}, WordPiece embeddings) as BERT, which consists of 30,522 tokens in the vocabulary. The model is optimized using Adam with the learning rate set as $1 \times 10^{-4}$. A batch size of $256$ is employed, and we train the model for $1$M step. 
The resulting model is evaluated on the GLUE benchmark \citep{wang2018glue}, which comprises $9$ natural language understanding (NLU) tasks such as textual entailment (MNLI, RTE), question-answer entailment (QNLI), question paraphrase (QQP), paraphrase (MRPC), sentimnt analysis (SST-2), linguistic acceptability (CoLA) and textual similarity (STS-B). The HuggingFace codebase\footnote{https://github.com/huggingface/transformers} is used in our implementation for both settings.

\begin{table*}[ht!]
	\centering
	\begin{small}
		\vspace{0mm}
		\setlength{\tabcolsep}{5pt}
		\def\arraystretch{1.0}
		\begin{tabular}{c||c|c|c|c}
			\toprule[1.2pt]
			\tf{Model} & \tf{ACL-ARC} & \tf{SciERC}    & \tf{HyperPartisan} & \tf{AGNews} \\
			\hline
RoBERTa \citep{gururangan2020don}  & $63.0\pm5.8$ & $77.3\pm1.9$ & $86.6\pm0.9$ & $93.9\pm0.2$ \\
			DAPT \citep{gururangan2020don}  & $75.4\pm2.5$ & $80.8\pm1.5$ & $88.2\pm5.9$ &  $93.9\pm0.2$ \\
			\hline
			MLM + Subword (our implementation) & $75.34\pm2.54$ & $81.51\pm1.05$ & $91.00\pm2.66$ & $94.05\pm0.16$ \\
			FE-MLM + Subword & $76.24\pm1.86$ & \tf{82.40}$\pm0.86$ & $92.35\pm3.49$ & $94.02\pm0.09$ \\
			\hline
			MLM + Span (our implementation) & $76.63\pm1.65$ & $81.33\pm1.16$ & $91.72\pm3.26$ &  $93.94\pm0.05$ \\
			FE-MLM + Span & \tf{78.06}$\pm2.31$ & $81.99\pm0.79$ & \tf{93.22}$\pm3.31$  &  \tf{94.13}$\pm0.04$ \\
			\bottomrule[1.2pt]
		\end{tabular}\caption{The empirical results on continual pre-training setting, where RoBERTa and DAPT (RoBERTa continually pre-trained with the standard MLM objective) is leveraged as our baseline to facilitate comparison with \citep{gururangan2020don}. Specifically, ACL-ARC and SciERC are evaluated with the continually pre-trained model with CS domain corpus, while HyperPartisann and AGNews are based upon models trained with News domain corpus.}
		\label{tab:eval_2}
	\end{small}
	\vspace{-2mm}
\end{table*}
\vspace{-1mm}
\subsection{Experimental Results}
\vspace{-2mm}
\paragraph{Continual Pre-training Evaluation}  We applied our \emph{fully-explored} MLM framework to both subword and span masking scenarios.
The results for the RoEBRTa model continually pre-trained on the CS and News domains are presented in Table~\ref{tab:eval_2}.
It can be observed that the continual pre-training stage can benefit the downstream tasks on both domains(compared with fine-tuning the RoBERTa model directly).
Besides, the baseline numbers based on our implementation is on par with or even better than those reported in \cite{gururangan2020don}, even though we downsample the original unlabeled corpus (as described in the previous section). 

More importantly, in the subword masking case, our FE-MLM framework consistently exhibits better empirical results on the downstream tasks.
Note that to ensure fair comparison, the same computation is taken for both MLM and FE-LMLM training.
This indicates that the models pre-trained using the FE-MLM approach have been endowed with stronger generalization ability, relative to standard MLM training. 
Similar trend is also observed in the span masking experiments, demonstrating that the proposed method can be naturally and flexibly integrated with different masking schemes.
Besides, we found that subword masking tends to work better than span masking in the CS domain, whereas the opposite is true as to the News domain. This may be attributed to the different nature of the unlabeled corpus from two domains.

\begin{table*} [t]
	\centering
	\begin{small}
		\vspace{0mm}
		\setlength{\tabcolsep}{5pt}
		\def\arraystretch{1.0}
		\begin{tabular}{c||c|c|c|c|c|c|c|c}
			\toprule[1.2pt]
			\tf{Model} & \tf{MNLI-m/mm}  & \tf{SST-2} & \tf{QNLI}    & \tf{QQP} & \tf{RTE} & \tf{MRPC}  & \tf{CoLA} & \tf{STS-B} \\
			\hline
			BERT (MLM)  & 84.37/\tf{84.85} & 92.78 & \tf{91.01}  & 91.09  & 63.54 & 87.01 & 59.65 & 87.89 \\
			BERT (FE-MLM) & \tf{85.09}/84.63 & \tf{93.23} & \tf{91.01} & \tf{91.16} & \tf{68.59} & \tf{87.99} & \tf{61.32} & \tf{89.51} \\			 
			\bottomrule[1.2pt]
		\end{tabular}\caption{The results on the dev sets of GLUE benchmarks, where MLM and FE-MLM are compared with the BERT-base model as the testbed.}
		\label{tab:eval_1}
	\end{small}
	\vspace{-4mm}
\end{table*}
\vspace{-2mm}

\begin{wraptable}{R}{6.8cm}
	\vspace{-2mm}
	\setlength{\tabcolsep}{6pt}
	\def\arraystretch{1.0}
	\begin{small}
		\begin{tabular}{c||c}
			\toprule[1.2pt]
			\textbf{Model}  & \textbf{Avg. Score} \\
			\hline
			ELMo, \citep{peters2018deep} & 71.2 \\
			GPT, \citep{radford2018improving} &  78.8 \\
			BERT-base, \citep{devlin2018bert} & 82.2 \\
			BERT-base (ReEval) & 82.5   \\
			MAP-Net, \citep{chen2020variance} & 82.1 \\
			\hline
			BERT-base (FE-MLM) & \textbf{83.6}   \\
			\bottomrule[1.2pt]
		\end{tabular}
	\end{small}
	\caption{The comparison between the FE-MLM model with several baseline methods, based on the averaged score (on the dev set) across different tasks from the GLUE benchmark. }\label{tab:average}
	\vspace{-3mm}
\end{wraptable}
\paragraph{General Pre-training Evaluation} We also evaluate the FE-MLM framework on the pre-training experiments with general-purpose unlabeled corpus. Specifically, we follow the same setting as BERT, except that the proposed \emph{fully-explored} masking strategy is applied (the same amount of computation is used for the baseline and our method). The corresponding results are shown in Table~\ref{tab:eval_1}. 
It can be found that the FE-MLM approach, while fine-tuned on the GLUE benchmark, exhibits better results on $7$ out of $9$ NLU datasets than the MLM baseline. This demonstrates the wide applicability of the proposed FE-MLM framework across different pre-training settings.

We further compare the averaged score over $9$ GLUE datasets with other methods, and the numbers are summarized in Table~\ref{tab:average}. It is worth noting that the BERT-based (ReEval) baseline is obtained by fine-tuning the BERT model released by \cite{devlin2018bert} on each GLUE datasets, with the results on the dev sets averaged. Another BERT-base number is reported by \cite{clark2019electra}, which is pretty similar our re-evaluation one. MAsk proposal network (MAP-Net) is proposed by \cite{chen2020variance}, which shares the same motivation of reducing the gradient variance during the masking stage. However, we approach the problem with a distinct strategy based upon extensive theoretical analysis. We found that BERT-base model improved with the FE-MLM training significantly outperform BERT-base model and Mask Proposal Network, further demonstrating the effectiveness of proposed approach. 

\vspace{-3mm}
\subsection{Ablation Studies and Analysis}
\vspace{-2mm}
\begin{minipage}{\textwidth}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\includegraphics[width=0.98\textwidth]{fig/efficiency.pdf} 
\vspace{-2mm}
\end{minipage}
\hfill
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\includegraphics[width=0.9\textwidth]{fig/split_baseline_2.pdf} 
\vspace{-3mm}
\end{minipage}
\captionof{figure}{\underline{Left}: the efficiency comparison between the standard MLM and \emph{fully-explored} MLM approach. Specifically, the RoBERTa-base model and continual pre-training setting (on the CS domain) are employed. The corresponding models are evaluated on the ACL-ARC dataset (at different training steps). \underline{Right}: the effect of split number (under the FE-MLM framework) on the generalization ability of pre-trained models, evaluated on two datasets in the CS domain.}
\vspace{-1mm}
\label{fig:efficiency_split}
\end{minipage}

\vspace{-1mm}
\paragraph{Training Efficiency} Although previous results has demonstrated that our model at the end of pre-training process exhibits stronger generalization ability, it is still unclear how the proposed FE-MLM framework influence the training efficiency during training. In this regard, we examine the intermediate models obtained with both MLM and FE-MLM training by fine-tuning and evaluating them on the ACL-ARC dataset. Specifically, the RoBERTa-base setting is used here, which is continually pre-trained on the unlabeled corpus from the CS domain. As shown on the left side of Figure~\ref{fig:efficiency_split}, FE-MLM beats MLM at different steps of pre-training. More importantly, the performance of the FE-MLM model improves much faster at the early stage (\emph{i.e.}, less than around 15,000 steps), indicating that the model is able to extract useful semantic information (from unlabeled corpus) more efficiently with the proposed masking strategy. This observation further highlights the advantage and importance of reducing gradient variance under the MLM framework.
\vspace{-2mm}
\paragraph{The Effect of Masking Split Number} The number of masking split the input sentence is divided into is a vital hyperparameter for the FE-MLM approach. Therefore, we investigate its impact on the performance of resulting models. Concretely, the setting of continual pre-training on the CS domain is employed, where the RoBERTa model is pre-trained with the  FE-MLM objective. Different split number is explored, including $2, 4, 6, 8$, and $12.5\%$ of all the tokens are masked within each split. The results are visualized on the right side of Figure~\ref{fig:efficiency_split}. We found that the downstream task performance (on both ACL-ARC and SciERC datasets) is fairly stable \emph{w.r.t.} different split numbers. This may relate to our non-overlapping sampling strategy, which helps the model to explore various position in the sentence as efficiently as possible, so that the model exhibits strong performance even with only two splits.
\vspace{-4mm}
\section{Conclusion}
\vspace{-3mm}
In this paper, we identified that under the MLM framework, the procedure of randomly sampling masked tokens will give rise to undesirably large variance while estimating the training gradients.
Therefore, we introduced a theoretical framework to quantify the gradient variance, where the connection between gradient covariance and the Hamming distance between two different masked sequences are drawn.
Motivated by these observations, we proposed a \emph{fully-explored} masking strategy, where a text sequence is divided into multiple non-overlapping segments. During training, all tokens in one segment are masked out, and the model is asked to predict them with the other segments as the context. 
It was demonstrated theoretically that the gradients obtained with such a novel masking strategy have a smaller variance, thus enabling more efficient pre-training. 
Extensive experiments on both continual pre-training and general pre-training from scratch showed that the proposed masking strategy consistently outperforms standard random masking.


\nocite{araci2019finbert}
\nocite{yang2020finbert}
\nocite{lee2020biobert}
\nocite{beltagy2019scibert}
\nocite{gururangan2020don}
\nocite{zhang2015character}
\nocite{kiesel2019semeval}
\nocite{Luan2018MultiTaskIO}
\nocite{Jurgens2018MeasuringTE}
\nocite{zellers2019defending}
\nocite{lo2020s2orc}
\nocite{brown2020language}
\nocite{radford2019language}
\nocite{srivastava2014dropout}
\nocite{vaswani2017attention}
\nocite{wang2013variance}
\nocite{raffel2019exploring}
\nocite{lan2019albert}
\nocite{wang2018glue}
\nocite{alain2015variance}
\nocite{gu2020train}
\nocite{radford2018improving}
\nocite{peters2018deep}
\nocite{chen2020variance}
\nocite{Ahmed2017WeightedTN}
\nocite{Song2019MASSMS}
\nocite{dong2019unified}
\nocite{Zhang2019ERNIEEL}
\nocite{wang2019structbert}
\nocite{he2020deberta}
\nocite{lewis2019bart}
\nocite{clark2019electra}
\nocite{sun2019ernie}
\nocite{joshi2019spanbert}
\nocite{bao2020unilmv2}
\nocite{yang2019xlnet}
\nocite{kingma2014adam}
\nocite{zhu2015aligning}
\nocite{neil_acourse_in_probability}
\nocite{johnson2013accelerating}
\nocite{zhang2019stochastic}
\nocite{xiao2014proximal}
\nocite{liu2019roberta}
\nocite{devlin2018bert}

\bibliography{iclr2021_conference}
\bibliographystyle{iclr2021_conference}

\newpage

\appendix
\section{Appendix}
\subsection{Dataset Statistics}
\label{ap:data}
The statistics of the datasets within the GLUE benchmark are summarized in Table~\ref{tab:data}.

\begin{table}[h]
    \centering
    	\setlength{\tabcolsep}{6pt}
	\def\arraystretch{1.05}
    \begin{tabular}{c||c|c|c|c|c|c} \hline
        \toprule[1.2pt]
        \textbf{Corpus} & \textbf{Task} & \textbf{\#Train} & \textbf{\#Dev} & \textbf{\#Test} & \textbf{\#Class} & \textbf{Metrics} \\ \hline
        MNLI & NLI  & 393k & 20k & 20k & 3 & Accuracy \\ \hline
        QQP & Paraphrase  & 364k & 40k & 391k & 2 & Accuracy/F1 \\ \hline
        QNLI & QA/NLI  & 108k & 5.7k & 5.7k & 2 & Accuracy \\ \hline
        SST & Sentiment & 67k & 872 & 1.8k & 2 & Accuracy \\ \hline
        MRPC & Paraphrase & 3.7k & 408 & 1.7k & 2 & Accuracy/F1 \\ \hline
        CoLA & Acceptability & 8.5k & 1k & 1k & 2 & Matthews corr \\ \hline
        RTE & NLI & 2.5k & 276 & 3k & 2 & Accuracy \\ \hline
        STS-B & Similarity & 7k & 1.5k & 1.4k & - & Pearson/Spearman corr \\ 
        \bottomrule[1.2pt]
    \end{tabular}
    \caption{GLUE benchmark dataset statistics summary.}
    \label{tab:data}
\end{table}

\subsection{Proof of Theorem 1}
\label{appendix:1}
\begin{proof}
\begin{align}
	\Var\bigl(g(\mathbf{m}_1,\ldots,\mathbf{m}_K)\bigr) 
	&= \EE\left[\|g(\mathbf{m}_1,\ldots,\mathbf{m}_K)-\bar{g}\|^2\right] \nonumber \\
	&= \EE\left[\left\|\textstyle\frac{1}{K}\sum_{k=1}^K g(\mathbf{m}_k)-\bar{g}\right\|^2\right] \nonumber \\
	&= \frac{1}{K^2} \EE\left[\left\|\textstyle\sum_{k=1}^K\bigl(g(\mathbf{m}_k)-\bar{g}\bigr)\right\|^2\right] \nonumber \\
	&= \frac{1}{K^2} \EE\left[\sum_{k=1}^K\|g(\mathbf{m}_k)-\bar{g}\|^2 + \sum_{k\neq l}\bigl(g(\mathbf{m}_k) - \bar{g}\bigr)^T\bigl(g(\mathbf{m}_l) - \bar{g}\bigr)\right] \nonumber \\
	&= \frac{1}{K^2} \left(\sum_{k=1}^K \Var\bigl(g(\mathbf{m}_k)\bigr) + \sum_{k\neq l}^K \Cov\bigl(g(\mathbf{m}_k),g(\mathbf{m}_l)\bigr)\right)
	\label{eqn:mb-var-derivation} 
	\end{align}
	
	

where for each pair $k\neq l$, 
\begin{align}
\Cov\bigl(g(\mathbf{m}_k),g(\mathbf{m}_l)\bigr) 
= \EE\left[\bigl(g(\mathbf{m}_k) - \bar{g}\bigr)^T\bigl(g(\mathbf{m}_l) - \bar{g}\bigr)\right], \nonumber
\end{align}

Since $\mathbf{m}_1,\ldots,\mathbf{m}_K$ are i.i.d.\ samples from the uniform distribution over $\mathcal{M}(\tau)$, we have 
\begin{equation}\label{eqn:same-var}
\Var\bigl(g(\mathbf{m}_1)\bigr)=\cdots=\Var\bigl(g(\mathbf{m}_K)\bigr) 
\end{equation}
\begin{equation}\label{eqn:same-cov}
\Cov\bigl(g(\mathbf{m}_k),g(\mathbf{m}_l)\bigr) 
=\Cov\bigl(g(\mathbf{m}_1),g(\mathbf{m}_2)\bigr), \forall\,k\neq l. 
\end{equation}
Therefore we have the following variance decomposition:
\begin{align}
\label{var_decomp}
\Var\bigl(g(\mathbf{m}_1,\ldots,\mathbf{m}_K)\bigr) 
= \frac{1}{K} \Var\bigl(g(\mathbf{m}_1)\bigr) + \left(1-\frac{1}{K}\right)\Cov\bigl(g(\mathbf{m}_1),g(\mathbf{m}_2)\bigr). 
\end{align}
\end{proof}

\subsection{Proof of Lemma 3}
\label{sec:lemm3}
\begin{proof}
The joint distribution of the pairs $(\mathbf{m}_k,\mathbf{m}_l)$ sampling from $\mathcal{M}_{\text{FE}}(\tau)$ are different from the i.i.d.\ case, it can be shown (by symmetry) that the identity~\eqref{eqn:same-cov} also holds.
Considering the fact that the derivation in~\eqref{eqn:mb-var-derivation} holds for any sampling strategy, we conclude that the variance decomposition in~\eqref{var_decomp} still holds. 
\end{proof}

\end{document}
