\chapter{Connected Components}\label{sec:conncomp}
The main results given in this chapter are an efficient algorithm for \pWMEE{}~(\pWMEEs{}) with running time in~ and the parameterized equivalence of \pWMEEs{} parameterized by~ and \pCBM{}. Here,~ is the number of components and~ is the sum of all positive balances in the input graph, that is for the input graph~, it is~ The equivalence to the matching problem also yields an algorithm for a restricted form of \pWMEEs{} with~~running time. The latter result represents some partial progress to answer the question of whether \pWMEEs{} is fixed-parameter tractable with respect to the parameter~.

We first make some observations about \EE s in \autoref{sec:trails} which expose that every \EE{} corresponds to a specific structure that has an intimate relationship to the connected components of the input graph. This then leads to a modified problem derived from \pWMEEs{} in \autoref{sec:advice}. There we consider the problems \pWMEEA{} (\pWMEEAs{}) and \pWMEECA{} (\pWMEECAs) where the structure of the sought \EE s is made explicit in the input. These restricted problems seem to be easier to tackle and we derive an algorithm with~~running time for \pWMEECAs{}. Using observations about the relationship between \pWMEEs{} and \pWMEECAs{} we derive an algorithm for \pWMEEs{} running in~~time.

In \autoref{sec:matching} we introduce \pCBM{}~(\pCBMs{}) and show that it is tractable on some restricted graph classes. We give parameterized reductions from \pWMEEs{} to \pCBMs{} and from \pCBMs{} to \pWMEEs{} using some intermediary problems that we introduce in \autoref{sec:advice}. This then yields the parameterized equivalence of \pCBMs{} and \pWMEEs{}. As simple corollaries, we derive fixed-parameter tractability of \pWMEEs{} with respect to parameter~ on some restricted input instances. The reductions also yield some results for intermediary problems, for example a problem kernel for \pWMEECAs{} that has size polynomial in~ and~.

Consult \autoref{fig:reduction-schematic} and \autoref{tab:tractresults} for an overview on the reductions given in this chapter and the tractability results obtained.
\begin{figure}\begin{center}
    \includegraphics{reduction-schematic.1}
    \caption{Schematic overview on the reductions given in this chapter. The label~``pT'' indicates a parameterized Turing reduction, the label~``pt-pp-m'' indicates a polynomial time polynomial parameter many-one reduction, and the label~``pt-m'' indicates a classical polynomial time many-one reduction. The reductions from and to \pWMEEs{} are covered in \autoref{sec:advice}. The reductions from and to \pCBMs{} are given in \autoref{sec:matching}.}
    \label{fig:reduction-schematic}
  \end{center}
\end{figure}\begin{table}
  \begin{minipage}{\linewidth}
  \centering
  \begin{tabularx}{\textwidth}{X l X l X l X} \toprule
    & \multicolumn{5}{c}{Tractability results} & \\
& \multicolumn{1}{c}{Problem} && \multicolumn{1}{c}{Result} && \multicolumn{1}{c}{Proposition} & \\
\midrule
    & \pCBMs{}\footnote{When the input graph is a forest.}  &&  && \autoref{cor:cbmlintimeonforests} \\
    & \pCBMs{}\footnote{When the bipartite input graph has maximum degree two in one of its cells.} &&  && \autoref{lem:cbmmaxdeg2tractable}  \\
    & \pWMEECAs{} &&  && \autoref{the:kcalgwmeea} \\
    & \pWMEEAs{} &&  vertex kernel && \autoref{cor:eecaprobkernel} \\
    & \pWMEEs{}\footnote{When the allowed arcs ``resemble'' a forest.} &&  && \autoref{cor:wmeetractableforests}  \\
    & \pWMEEs{}\footnote{When the allowed arcs ``resemble'' a vertex-disjoint union of cycles.} &&  && \autoref{cor:wmeetractablecycles}  \\
    & \pWMEEs{} &&  && \autoref{cor:wmeefptbc}  \\
    \bottomrule
  \end{tabularx}
  \caption{Overview on tractability results given in this chapter. All values in big-O notation. Here,~ denotes the parameter ``join set size'' in \pCBMs{} instances. This parameter corresponds to the parameter ``number of components'' in \pWMEEs{} instances in reductions we give in this chapter.}
  \label{tab:tractresults}
\end{minipage}
\end{table}


\section{Structure of Eulerian Extensions}
\label{sec:trails}

In this section, we show that we can assemble a minimum-weight \EE{} for a graph~ using trails that are of restricted structure, and bound the length and number of ``long'' trails by polynomials in the number of components in~. To this end, we consider trails in \EE s. 
\begin{figure}
  \begin{center}
    \includegraphics{euleriantrails.1}
    \caption{Examples of a closed maximum length trail (left, solid arcs) and an open maximum length trail (right, solid arcs) in an \EE{} (solid arcs). Arcs belonging to the input graph are dashed. Observe that the vertex~ is the only vertex in~ and the vertex~ is the only vertex in~.}
    \label{fig:pmetrails}
  \end{center}
\end{figure}

We investigate preprocessing routines for instances of \pWMEEs{}---namely, we split vertices (\autoref{trans:sb}) and use shortest-path preprocessing (\autoref{trans:spp})---that allow us to modify any valid \EE s such that we can make assumptions about their trails without increasing the weight of the extensions. In this section, we frequently use the component graph~ of a graph~ and the mapping~ of trails~ in~ to trails in~. These are defined on page~\pageref{def:meta} in \autoref{sec:prelim}. The main result of this section is as follows.
\newcommand{\eestructuretheorem}{Let~ be a directed multigraph with~ connected components. Let~ and the weight function~ constitute an instance of \pWMEE{} that is preprocessed using \autoref{trans:sb} and \autoref{trans:spp}. Then, there is a set~ of pairwise edge-disjoint paths and cycles each in the graph~ such that
  \begin{lemenum}
  \item  is an \EE{} of minimum weight for~,\label{enu:ees5}
\item each~ contains at most~ vertices,\label{enu:ees2}
  \item in~ there are at most~ paths and cycles containing more than one arc,\label{enu:ees3}
  \item the number of paths in~ is at most~,\label{enu:ees4}
  \item for~ of length at least two~, and~ are edge-disjoint,\label{enu:ees7}
  \item the graph defined by the union of all trails~ without their initial vertices does not contain a cycle. \label{enu:ees6}
  \end{lemenum}
}
\begin{theorem}\label{the:eestructure}
  \eestructuretheorem
\end{theorem}
In this section, let  be a directed multigraph, let  be an \EE{} for ---that is  is Eulerian---and let the function~ be a weight function.
\begin{observation}
  \label{obs:walkdichotomy}
  A maximum-length trail in an \EE{} for a graph~ either is closed or starts in~ and ends in~.
\end{observation}
\begin{proof}
  Consider the initial vertex~ and terminal vertex~ of a trail~ in the \EE~. The vertices~ and~ are balanced in~. 

  Assume that~ is not balanced in~. Every time~ traverses~, it uses one arc in~ that enters~ and one that leaves it. This implies that~ because~ is balanced in~ and thus there is an odd number of arcs in~ incident to~ (recall that~ is of maximum length). Since~ ends in~, this also implies that~. Analogously we get that~.
  
  Now assume that~ is balanced in~. Since~ cannot be extended, it already uses every arc incident to~ and~. However, if~ is not equal to~, there are more arcs entering~ than leaving~ in~. This means that~ is not balanced in~ which is a contradiction.
\end{proof}
\autoref{fig:pmetrails} illustrates \autoref{obs:walkdichotomy}.

\paragraph{Preprocessing Routines.}
There is a preprocessing routine introduced by~\citet{DMNW10} that ensures that every vertex has balance between~ and~. This later helps to give a bound on very short trails in \EE s.
\begin{transformation}[Splitting Vertices]
  \label{trans:sb}
  Let the graph , the weight function~ and the maximum weight~ constitute an instance of \pWMEEs{}. Compute a new instance as follows: Search for a vertex~ with~, introduce a new vertex~. If~, choose an arbitrary arc~, delete it and add the arc~. Proceed analogously, if~. Add the arcs~. Finally, define a new weight function~ for each pair of vertices~ as follows.

\end{transformation}
\begin{lemma}
  \label{lem:smallbalancepp}
  \autoref{trans:sb} is correct, that is, it maps yes-instances and only yes-instances to yes-instances. Also, \autoref{trans:sb} can be applied exhaustively in~~time. When applied exhaustively, the resulting instance contains only vertices~ with~.
\end{lemma}
\begin{proof}
  The last statement of the lemma is clear. Concerning the running time, we can iterate over every vertex~~(~time), check if it has high absolute balance~(~time) and, if so, perform the weight function update~(~time) and perform the local modifications~(~time) for every ``excess arc'' incident to~~(there are at most~ many). In total, this is~~time.

  To prove the correctness, we only have to examine one application of \autoref{trans:sb}: Let~ be an instance of \pWMEEs{} where \autoref{trans:sb} has been applied once at vertex~ yielding the new vertex~. Given an \EE{} for the input graph~, we can obtain an \EE{} for~ of the same weight by modifying an arc~ incident to~ appropriately such that it starts or ends in~. If we are given an \EE{} for~, at least one arc in it has to be incident to~ and thus we can obtain an \EE{} for~ by modifying it to start or end in~.
\end{proof}


We can apply a further preprocessing routine to make some further observations about trails in \EE s:
\begin{transformation}[Shortest-Path Preprocessing]
  \label{trans:spp}
  For an input instance of \pWMEEs{} consisting of the graph~, the weight function~ and the maximum weight~, derive a new instance by computing a new weight function~ as follows:
  
\end{transformation}
\begin{lemma}\label{lem:spp}
  \autoref{trans:spp} is correct---that is, it maps yes-instances and only yes-instances to yes-instances---and can be applied in~~time.
\end{lemma}
\begin{proof}
  It is clear that for any \EE{}~ of~ it holds that~, making any feasible \EE{} in the original instance also one for the modified instance. Now let~ be an \EE{} for~ with~. We get an \EE{}~ for~ with~ by exchanging every arc~ with~ by the set of arcs of a shortest path from~ to~ in the graph~ with respect to the weight function~.

Using Dijkstra's algorithm we can compute in~~time the weights of the shortest paths between one vertex~ and any other in~ and update the weight function accordingly. Doing this for every vertex in~ takes~~time.
\end{proof}
Shortest-path preprocessing and splitting vertices enables us to make a range of useful observations regarding trails in \EE s. In the following we assume any instance of \WMEE{} to be preprocessed using \autoref{trans:sb} and \autoref{trans:spp}. In the subsequent sections, we use this preprocessing in parameterized algorithms and reductions. Thus, we need to know whether it is parameter-preserving. This is the case, as the following observation shows. \begin{observation}\label{obs:sbsppinvariants}
  The number of components and the sum of all positive balances of vertices in an instance of \pWMEEs{} are invariant under \autoref{trans:sb} and \autoref{trans:spp}.
\end{observation}

\paragraph{Shortcutting Trails in \Eu Extensions.}Using \autoref{trans:spp}, we can define the following transformation that operates on trails of an \EE .\begin{transformation}\label{trans:shortcut}
  Let~ be an \EE{} of , let~ be a trail in the graph~ and let~ be a subtrail of~ where~ has the initial vertex~ and the terminal vertex~. Obtain a new trail~ by substituting the edge~ for~ in~ and derive a new arc set~ by substituting~ for~ in~. Define~.
\end{transformation}
\autoref{fig:shortcut} illustrates \autoref{trans:shortcut}.
\begin{figure}
  \begin{center}
    \includegraphics{euleriantrails.2}
    \caption{Example of an application of \autoref{trans:shortcut}. Solid arcs and dotted arcs belong to~, dotted arcs to~ and the dashed arc is substituted for the dotted arcs in~.}
    \label{fig:shortcut}
  \end{center}
\end{figure}
\begin{lemma}\label{lem:shortcut}
  Let  where the trail~ has initial vertex~ and terminal vertex~. The following statements hold:
  \begin{lemenum}
  \item . \label{enu:ls1}
  \item Every vertex in~ is balanced in~. \label{enu:ls4}
  \item If every vertex of  except  and  is contained in a connected component of  that also contains a vertex of , then the arc set  is an \EE{} for~. \label{enu:ls2}
\end{lemenum}
\end{lemma}
\begin{proof}
  Statement \enuref{enu:ls1} is trivial because of the implicitly transformed weight function (\autoref{trans:spp}).
  
  By substituting  for~, every vertex on~ except~ and~ looses one indegree and one outdegree. Hence, augmenting~ with~ results in a graph without unbalanced vertices (statement~\enuref{enu:ls4}).

  For statement~\enuref{enu:ls2} it remains to show that the graph  is connected: If every vertex of~ except~ and~ is contained in a connected component of~ that also contains another vertex of , then augmenting~ with~ results in a connected graph, making  an \EE{} for~ (\autoref{the:eulerian}).
\end{proof}
\begin{observation}
  \label{obs:simpletrails}
  For any \EE{}  of~ there is an \EE{}~ of at most the same weight such that any trail with arcs in~ visits every vertex at most once.
\end{observation}
\begin{proof}
  Assume that in the \EE{}~ there is a trail~ that visits~ more than once. Then there is a subtrail~ of~ with~. Let~. By \autoref{lem:shortcut},~ is an \EE{} for~ because ~still visits~ (one time less than~). If we recursively  edges in trails in~ until every such trail visits any vertex at most once, we obtain an \EE{}~. By \autoref{lem:shortcut},~.
\end{proof}
\autoref{obs:simpletrails} allows us to assume trials in \EE s to be cycles when they are closed and paths otherwise.


\begin{observation}
  \label{obs:shorttrails}
  For any \EE{}  of , there is an \EE~ of at most the same weight such that for any path~ and any cycle~ in~ such that~ and~ are edge-disjoint and have length at least two the following statements hold: 
  \begin{lemenum}
  \item  and  do not successively visit two vertices contained in exactly one connected component of~. \label{enu:osht1}
  \item  and  do not visit one connected component of~ twice except for the initial and terminal vertex. \label{enu:osht2}
  \item  and  have length at most the number of connected components of~. \label{enu:osht3}
  \end{lemenum}
\end{observation}
\begin{proof}
The proof for \enuref{enu:osht1} and~\enuref{enu:osht2} is similar to the proof of the observation above.  Again we can  edges and obtain an \EE{} of at most the same weight. Statement~\enuref{enu:osht3} directly follows from~\enuref{enu:osht1} and~\enuref{enu:osht2}.
\end{proof}




\paragraph{Shortcutting and Component Graphs.}We can further extend our observations by looking at component graphs~ and the mapping of trails~ in~ to trails~ in~. Recall these definitions stated on page~\pageref{def:meta} in \autoref{sec:prelim}. The following lemma is a generalization of statement~\enuref{enu:ls2} in \autoref{lem:shortcut}.
\begin{lemma}
  \label{lem:metashortcut}
  Let~ be an \EE{} of~, let~ be trails in the directed multigraph~ such that the trails~ and~ are not vertex-disjoint. Furthermore, let~ be a subtrail of~ in the directed multigraph~ such that~ is a subtrail of~. Let~ be a subtrail of~ such that~ is a subtrail of~ and~ traverses exactly one vertex less than~. Set~. Then~ is an \EE{} for~.
\end{lemma}
\begin{proof}
  \autoref{lem:shortcut} shows that the vertices in~ are balanced. It remains to show that the resulting graph is connected: Any connected component that is traversed by~ is also traversed by~. The trails~ and  still share a vertex and thus~ is connected.
\end{proof}
\autoref{lem:metashortcut} leads to the following \autoref{obs:metaedgedisjoint}, which is illustrated in \autoref{fig:shortcutcomponents}.\begin{figure}
  \begin{center}
    \includegraphics{euleriantrails.4}
    \caption{Gray objects represent components of~. Shown are two trails~ (top) and~ (bottom, solid and dashed arcs) in an \EE . The trails~ share two vertices. The dashed arcs represent a subtrail~ of~ as in \autoref{lem:metashortcut} and thus we can obtain a path~ (bottom, solid and dotted arcs) replacing~, while maintaining connectedness and balance of all vertices.}
    \label{fig:shortcutcomponents}
  \end{center}
\end{figure}\begin{observation}
  \label{obs:metaedgedisjoint}
  For any \EE{}~ of~ there is an \EE{}~ of at most the same weight such that for any two edge-disjoint trails~ in~ it holds that~ either are vertex-disjoint, share at most one vertex, or share only their initial and terminal vertices.
\end{observation}
\begin{proof}
This follows directly from \autoref{lem:metashortcut} by shortcutting subtrails that are shared by two such trails in~.
\end{proof}
We can improve this even to the following.
\begin{observation}\label{obs:metanocycle}
  For any \EE{}~ of~ there is an \EE{}~ of at most the same weight such that for any set of edge-disjoint trails~ in~ it holds that the edge-induced graph~ does not contain a cycle as subgraph, where~ is~ without the initial vertex.
\end{observation}
\begin{proof}
  By \autoref{obs:simpletrails} we may assume that~ are paths or cycles. Assume that~ contains a cycle~ and that~ is minimal with respect to this property. Let~ be an arbitrary edge on~. There is a subtrail~ of~ such that~ traverses~ and at least one edge not belonging to~---recall that~ is~ without the initial vertex. Shortcutting~ maintains balance of every vertex (statement~\enuref{enu:ls4}, \autoref{lem:shortcut}) and connectedness, because afterwards~ is not vertex-disjoint from~. Since an edge is removed from~, it is a path after shortcutting~.

  Iterating the shortcutting for every cycle in the graph~ eventually removes every cycle after a finite amount of steps, because obviously the statement of the lemma holds true, if~ have length one, and because in every step the number of arcs in~ decreases by at least one.
\end{proof}
We use \autoref{obs:metanocycle} in forthcoming \autoref{sec:wmeeslasha} to efficiently derive the structure of a suitable \EE{} for a given graph. We are now ready to prove \autoref{the:eestructure}.
\newtheorem*{rep}{\autoref{the:eestructure}}
\begin{rep}
  \eestructuretheorem
\end{rep}
\begin{proof}We simply take an \EE~ of minimum weight for the directed multigraph~ and successively remove maximum-length paths from~ to obtain a set of trails~. The sought properties of the trails follow from the observations we made in this section: Statement~\enuref{enu:ees5} is trivial. From \autoref{obs:simpletrails} we can assume that each~ either is a path or a cycle. The maximum-length~ of maximum-length cycles and paths~(statement~\enuref{enu:ees2}) can be assumed because, by \autoref{obs:shorttrails}, we can assume that each trail traverses at most one vertex in each component except the terminal vertex. Statement~\enuref{enu:ees7} follows directly from \autoref{obs:metaedgedisjoint}. The maximum number of maximum-length paths~ and cycles~ of length at least two~(statement~\enuref{enu:ees3}) can be assumed because we can assume that~ use two edges~(\autoref{obs:shorttrails}), they are edge-disjoint~(\autoref{obs:metaedgedisjoint}) and there are at most~ edges in~. The upper bound~ on the number of maximum-length paths~(statement~\enuref{enu:ees4}) can be assumed because every vertex~ has~ (\autoref{lem:smallbalancepp}) and each such path starts and ends in an unbalanced vertex (\autoref{obs:walkdichotomy}). Finally, statement~\enuref{enu:ees6} follows directly from \autoref{obs:metanocycle}.
\end{proof}



\section{Simplification through Advice}\label{sec:advice}

In \autoref{sec:trails} we observed that any \EE{} can be modified to conform to a restricted structure with respect to the connected components in the input graph. We will observe in \autoref{sec:incompress}, that this structure cannot be determined within polynomial time---unless~, which seems unlikely. There, we implicitly use that fact, that it is not clear how components are connected through an \EE{} in order to obtain lower bounds for problem kernels. An obvious question is, whether the structure of an \EE{} can be determined using fixed-parameter algorithms whose super-polynomial-time portion depends only on the connected components of the input graph. This question is considered in the following sections.

We consider the general problem \pWMEE{} (\pWMEEs{}), and investigate its connection to the problem \pWMEEA{} (\pWMEEAs{}) in which the structure of allowed \EE s may be given by the input. In order to get a grasp at the structure of \EE s, we introduce the notion of hints and advice:
\begin{definition}
  Let~ be a directed multigraph. A \emph{hint} for~ is an undirected path or cycle~ of length at least one in the component graph~ together with the information that~ shall form a cycle of a path in an \EE{} of~.\footnote{The extra information is necessary because a hint to a path may be a cycle in~.} We call the corresponding hints \emph{cycle hints} and \emph{path hints}, respectively. We say a set of hints~ is an \emph{advice} to the graph~ if the hints are edge-disjoint.\footnote{Note that there is a difference between advice in our sense and the notion of advice in computational complexity theory. There a piece of advice applies to every instance of a specific length.} We say that a path~ in the graph~ \emph{realizes} a path hint~ if~ and the initial vertex of~ has positive balance and the terminal vertex has negative balance in~. We say that a cycle~ in the graph~ realizes a cycle hint~ if~. We say that an \EE~ \emph{heeds the advice~} if it contains paths and cycles that realize all hints in~.
\end{definition}
Now consider the following restricted version of \pWMEEs{}:
\decprob{\pWMEEA~(\pWMEEAs{})}{A directed multigraph~ with a weight function~ and advice~.}{Is there an \EE{}~ of~ that is of weight at most~ and heeds the advice~?}
\begin{figure}
  \begin{center}
    \includegraphics{wmeeslasha.3}
    \caption{An instance of \pWMEEAs{} comprising the vertices~ through~ and the solid arcs. Gray objects represent components of the input graph~ and the the dashed lines are a hint~ that forms a piece of advice~ for~. The dotted arcs form an \EE{}~ of~. Both the paths traversing the vertices~ and~ realize~. Thus,~ heeds~.}
    \label{fig:wmeeaexample}
  \end{center}
\end{figure}For an example of an instance of \pWMEEAs{}, see \autoref{fig:wmeeaexample}. The \pWMEEAs{} problem may be interesting in practical applications where the structure of a sought \EE{} is partly known. However, our intent is to use this problem to make the complete structure of the \EE{} explicit. We derive efficient algorithms that guess the structure as advice and then realize each hint.

In \autoref{sec:remcycle}, we simplify \pWMEEAs{} and gather a useful tool for its analysis. Then, in \autoref{sec:wmeeslasha}, we look at the relationship of \pWMEEs{} and \pWMEEAs{}. We introduce a variant of \pWMEEAs{} that seems to be easier to tackle than \pWMEEs{}. In \autoref{sec:multivariatealg}, we give an efficient algorithm for this variant that also transfers over to \pWMEEs{}. 

In the following sections, we assume all instances of \pWMEEs{} and \pWMEEAs{} to be preprocessed using \autoref{trans:sb} (``splitting vertices'') and \autoref{trans:spp} (``\SPP{}'') as introduced in \autoref{sec:trails}. We give parameterized reductions that use the parameters number of components and sum of all positive balances of vertices in the input graph. For these one can assume without loss of generality that the instances are preprocessed using the two transformations, because of \autoref{obs:sbsppinvariants}. 


\subsection{Computing Realizations of Hints}\label{sec:remcycle}
In this subsection, we introduce the ~function, which calculates minimum-weight paths that consist of allowed arcs and traverse connected components in a specific order. Using this function, we show that \pWMEEAs{} and the problem \pWMEECLA{} (\pWMEECLAs{}) are equivalent under polynomial-time many-one reductions. That is, a minimum-weight realization for any hint to a cycle can be found in polynomial time. We use this equivalence in the forthcoming sections to derive algorithms more conveniently, and to simplify reductions from and to \pWMEEAs{}.

\subsubsection{The  Function}
On many occasions we need to find a minimum-weight realization of a path-hint in an advice that starts and terminates in some specified vertices. Hence we need to compute a minimum-weight path that traverses vertices of components in the order given by the hint. The~ function defined below finds such paths.
\begin{definition}\label{def:minpath}
  Let the directed multigraph~ and the weight function~ constitute an instance of \pWMEEs{}. Let~ be a path in~ and let~ be a vertex in the component of~ that corresponds to the initial vertex of~ and~ a vertex in the component that corresponds to the terminal vertex of~. Define~ as the shortest path~ from~ to~ in the complete graph~ such that~.
\end{definition} Recall that we have made \SPP{} (\autoref{trans:spp}) implicit at the start of this section. Thus, by \autoref{obs:shorttrails}, we may assume that any shortest path in~ with respect to the weight function~ does not successively visit two vertices of one connected component of~. This gives the following strategy to compute :

Orient the path~ to obtain a directed path~. Initialize a new weight function~ that assigns every arc in~ the weight~. Iterate over the arcs of . For any such arc~ let~ be the corresponding components. For every arc~ set~. Now, using the weight function , compute a shortest path~ from~ to~ in the graph~. Return~. See also the pseudocode in \autoref{alg:minpath}.
\begin{algorithm}
  \LinesNumbered
  
  \KwIn{A directed multigraph~, a weight function~, a path~ in~, and vertices~ in the components~ corresponding to the initial and terminal vertices of~, respectively.}
  \KwOut{A minimum-weight path~ from~ to~ in~ such that~.}

  \SetKwData{npath}{Path}

  \BlankLine
  \tcc{Orient the path .}
   a path that is an orientation of~ and starts in the vertex corresponding to~ and terminates in the vertex corresponding to~\;

  \tcc{Initialize a modified weight function .}
  \lFor{}{\;}
  \For{}{
     connected component of  corresponding to \;
     connected component of  corresponding to \;
    \lFor{}{\;}
  }
   a shortest path from  to  in the complete directed graph with the vertices of  and with weight function \;
  
  \Return{\npath\;}
    
  \SetAlgoRefName{Min\-Path}
  \caption{Finding minimum-weight paths that traverse components in a specified order.}
  \label{alg:minpath}
\end{algorithm}
\begin{lemma}
  \label{lem:minpath}
  \autoref{alg:minpath} computes the function~ in~~time.
\end{lemma}
\begin{proof}
  Consider . This path retains its weight under the weight function~. It follows that the output~ of \autoref{alg:minpath} has at most the weight of~. However, since in any vertex of a component of~ only arcs that lead to the next component according to~ may have weight~, we may assume that~ and thus~.

  The dominating running time portion is in the computation of a shortest path in line 7, which is possible in~~time using Dijkstra's algorithm (there are no negative weights in~).
\end{proof}
Using the~ function, we can formulate a fact about \EE s that we use in reductions involving \pWMEEAs{}.
\begin{observation}\label{obs:minpathinee}
  Let  be an \EE{} for the multigraph~ that heeds the advice~, let~ contain a path-hint~ and let~ be a weight function~. There is an \EE{}~ such that the following statements hold:
  \begin{lemenum}
  \item ~heeds the advice~,
  \item , and 
  \item .
  \end{lemenum}
  Here,~ are vertices contained in the connected components of~ that correspond to the initial and terminal vertices of~, respectively.
\end{observation}
\begin{proof}
  \autoref{obs:minpathinee} is easy to prove: Simply remove the realization~ of~ from~ and add the edges of~ where~ are the initial and terminal vertices of~, respectively.
\end{proof}

\subsubsection{Removing Cycles from an Advice}
Now regarding hints to cycles, we may proceed as in \autoref{alg:findcycle2} (see page~\pageref{alg:findcycle2}): First we introduce a new component~ that is a copy of an arbitrary component~ visited by the given cycle hint~ (lines~1 and~2). Then we extend the weight-function~ such that any arc in~ that contains a vertex~ of~ is assigned the same weight as the arc that contains the original vertex in~ (lines~3 to~5). We then split the cycle~ to a path~ that goes from~ to~ (lines~6 to~9). Then for every vertex~ we compute~ and  where~ is the copy of~ in~. This is done in lines~11 to~18. The shortest path found in this procedure is modified such that the vertex it contains in~ is replaced by its original in~. This modified path is returned.
\begin{algorithm}
  \LinesNumbered
  
  \KwIn{A directed multigraph~, a weight function~ and a cycle~ in~.}
  \KwOut{A minimum-weight cycle in  that occurs in an \EE{} of  that heeds an advice containing~.}

  \SetKwData{spath}{CurrentShortestPath}
  \SetKwData{npath}{Path}
  \SetKwData{npath'}{Path'}

  \BlankLine
  \tcc{Introduce a new component to split the cycle.}
   an arbitrary component of  that is visited by \;
    with an additional copy  of \;
  \For{}{
     the copy of  in \;
    \;
  }
   the vertex in~ that corresponds to \;
   the vertex in~ that corresponds to \;
   an edge in  that is incident to \;
   \;
  \tcc{Probe vertices for shortest cycles.}
  \spath  empty list\;
  \For{}{
     the copy of  in \;
    \;
    \;
    \If{}{\;}
    \If{}{\;}
  }
  
  \Return{\spath with every vertex in  replaced by its original in~\;}
  
  \SetAlgoRefName{Determine\-Cycle}
  \caption{Finding minimum-weight cycles with advice.}
  \label{alg:findcycle2}
\end{algorithm}


\begin{lemma}\label{lem:findcycle}
  The output returned by \autoref{alg:findcycle2} is a cycle that is contained in a minimum-weight \EE{}~ for~ that heeds an advice~ such that  contains the input cycle~. The algorithm runs in~~time.
\end{lemma}
\begin{proof}
  It is easy to see that the output is a cycle: The algorithm computes a path from~ to its copy . However, ~is replaced by~ in the final step in line~19.

  Since the \EE{}~ heeds some advice that contains the cycle-hint~, it contains a number of closed trails that all visit the components whose corresponding vertices in~ are contained in~. Let~ be a trail that is of minimum-weight among those trails. Because of \SPP{} and \autoref{obs:shorttrails} we may assume that~ is a cycle that contains exactly one vertex of every component it visits. By copying an arbitrary component~ this cycle visits and modifying the cycle so that it starts in one vertex~ of~ and ends in the copy of~, we obtain a path of the same weight. That is, the path found by \autoref{alg:findcycle2} has at most the weight of~. However, it may not find a cycle that is of lower weight than~, otherwise~ is not of lowest weight.
  
  Regarding the running time, lines~1 and~2 can be carried out in~~time. Extending the weight function in lines~3 to~5 is possible in~~time. Lines~6 to~9 take time at most~ using list-implementations of paths. The loop in line~11 is executed at most ~times and every iteration takes~~time using \autoref{alg:minpath}. Summing up, we get a bound of~~time.
\end{proof}
\autoref{lem:findcycle} yields the following theorem:
\begin{theorem} 
  \label{obs:redwmeeatocla}
  \pWMEEA{} and \pWMEECLA{} are equivalent under polynomial-parameter polynomial-time many-one reductions when parameterized by the number of connected components and/or the sum of positive balances of all vertices.
\end{theorem}
\begin{proof}
  Since \pWMEECLAs{} is a subset of \pWMEEAs{} this direction is trivial. To reduce \pWMEEAs{} to \pWMEECLAs{} simply use \autoref{alg:findcycle2} for every cycle-hint in the advice and add the corresponding cycle to the input graph. This is a polynomial-time many-one reduction, because it can be carried out in~~time and it is correct because of \autoref{lem:findcycle}. Also, by carrying out the reduction the number of components does not increase and the balance of all vertices stays the same. As a consequence, this is a polynomial-parameter polynomial-time reduction for these parameters.
\end{proof}
\autoref{obs:redwmeeatocla} enables us to simplify reductions and algorithms for \pWMEEAs{} by using the equivalence of \pWMEEAs{} and \pWMEECLAs{} and by considering the simpler problem of \pWMEECLAs{} instead.

\subsection{The Impact of Advice}\label{sec:wmeeslasha}

In this section we investigate the relationship of \pWMEEs{} and \pWMEEAs{}. For this, we consider the following restricted form of advice and corresponding problem \pWMEECA{} (\pWMEECAs{}).
\begin{definition}
  Let~ be a directed multigraph and let~ be an advice for~. We call the advice~ \emph{connecting}, if the hints in~ connect every vertex in~.
\end{definition}
\decprob{\pWMEECA}{A directed multigraph~ with a weight function~ and minimal connecting advice~.}{Is there an \EE{}~ of~ that is of weight at most~ and heeds the advice~?} \label{def:pWMEECA}

We show that \pWMEEs{} is parameterized Turing-reducible to \pWMEECAs{} when parameterized by the number~ of components in the input graph or the combined parameter of~ and the sum~ of all positive balances of vertices in the input graph. And we also give a polynomial-time polynomial-parameter many-one reduction from \pWMEEAs{} to \pWMEEs{} with respect to the parameter number of connected components in this section. 

Since in \autoref{sec:incompress} we will show that a polynomial-size problem kernel for \pWMEEs{} would imply~ and since in \autoref{sec:releecbm} we will give a polynomial-size problem kernel for \pWMEECAs{}, we cannot hope to replace the Turing reduction with a polynomial-time polynomial-parameter many-one reduction. Otherwise we could derive a polynomial-size problem kernel for \pWMEEs{} using this reduction. 

In terms of classical complexity theory, the parameterized Turing reduction is a very powerful tool, and thus, one could hope for \pWMEECAs{} being polynomial-time solvable. This, however, is unlikely. Although the reductions given in this section do not imply a hardness result for \pWMEECAs{}, we gather \NPhs{} as a simple corollary (\autoref{cor:eecanph}) in \autoref{sec:releecbm}. Nevertheless, the reductions given in this section are of high value to us, because we can use the Turing reduction to derive an efficient algorithm for \pWMEEs{} in \autoref{sec:multivariatealg} and together with the second reduction, we can restate \pWMEEs{} as a matching problem in \autoref{sec:matching}.

\paragraph{Simple Observations Regarding \pWMEECAs{}.}
For running time analysis, we sometimes need to know the maximum number of hints in an advice in \pWMEECAs{}. Here, the following observation is helpful.
\begin{observation} \label{obs:hintsinadvice}
  Let~ be a directed multigraph with~ connected components and let~ be a minimal connecting advice for~. The advice~ contains at most~ hints.
\end{observation}
\begin{proof}
  Since a hint is a path or cycle of length at least one, it connects at least two vertices in~. We consider the graph~ and the procedure of successively adding hints~ that form a minimal connecting advice. It is clear that every hint~, must connect two connected components of the graph~. Otherwise we could remove~ and still connect every vertex in~ using the remaining hints. Thus, adding~ hints connects every vertex in~ and there are at most~ hints in~.
\end{proof}
It is also easy to see, that we can realize every cycle hint in a minimal connecting advice to obtain a cycle-free minimal connecting advice.
\begin{observation}\label{obs:redwmeecatoccla}
  \pWMEECA{} is equivalent to \pWMEECCLA{} (\pWMEECCLAs{}) under polynomial-parameter polynomial-time many-one reductions with respect to the parameters number of connected components and sum of all positive balances of vertices.
\end{observation}
\begin{proof}
  See \autoref{obs:redwmeeatocla}.
\end{proof}




\subsubsection{Reducing \pWMEEs{} to \pWMEECAs{}} To reduce \pWMEEs{} to \pWMEECAs{} the obvious idea of trying pieces of advice yields a Turing reduction. We make use of the observations in \autoref{sec:trails} to assume certain restrictions on the pieces of advice we have to guess.
\begin{lemma}\label{lem:adstructure}
Let~ be a directed multigraph and let~ be a minimum-weight \EE{} with respect to a weight function~ for~. There is a minimal connecting advice~ such that
\begin{lemenum}
\item  heeds~, and
\item the graph defined by the union of all trails~ without their initial vertices does not contain a cycle.
\end{lemenum}
\end{lemma}
\begin{proof}
  This is mainly based on \autoref{the:eestructure}. By the theorem, there is a decomposition of~ into paths and cycles~ such that the graph defined by the union of all trails~ without their initial vertices does not contain a cycle. We greedily take paths~ of length at least one into~ that connect new vertices in~.
\end{proof}
Using this restriction, we can guess all forests of~ and try all possibilities to extend them to an advice:
\begin{lemma}\label{lem:redwmeetowmeea}
  \pWMEE{} is parameterized Turing-reducible to \pWMEECA{} when parameterized by the number~ of components in the input graph or the combined parameter of~ and the sum of all positive balances of vertices in the input graph. The reduction can be carried out in~~time.
\end{lemma}
\begin{proof}
  Let the directed multigraph~ and the weight function~ constitute an instance of \pWMEEs{} and let~ be the number of connected components in~. We give an algorithm that decides \pWMEEs{} using an oracle for \pWMEECAs{} in time~.

We simply generate all possible pieces of advice and apply the oracle to the resulting instances. If one of the oracle calls accepts the advice-instance, then, clearly, the original instance is a yes-instance. Also, for every yes-instance of \pWMEEs{}, there is an advice derivable from a solution to the instance because of \autoref{lem:adstructure}. Clearly, the number of components and the sum of all positive balances remain the same in the instances passed to the oracle.

Concerning the generation of the pieces of advice, by \autoref{lem:adstructure} we may assume that the hints without their initial vertices form a forest in~. Thus, we may simply enumerate all forests contained in~, partition their edges into at most~ hints and try all possibilities to add the initial vertex back onto the hints.

To enumerate all forests, we first partition the vertices into at most~ cells (there are~ many such partitions), then enumerate all spanning trees in each cell (in each cell there are~ spanning trees~\cite{Cay89}). This is possible in~~time~\cite{KR95}. 

We then partition the edges into at most~ hints (there are~ partitions), extend every hint by adding an initial vertex (in total, there are~ possibilities) and check if this yields a valid advice---that is, whether the hints are paths or cycles and whether the advice is connecting. This procedure can be carried out in~~time allowing~ for the validity check.

For every guessed advice, we have to pass the instance to the oracle in linear time and, since~, we can derive the running time bound of~.
\end{proof}




\subsubsection{Reducing \pWMEEAs{} to \pWMEEs{}} Here, we will see that there is only a polynomial number of optimal ways to realize a hint in an advice. Each of these realizations will be modeled by a pair of imbalanced vertices. These pairs will reside in a new component and this component then can only be connected to the rest of the graph by taking arcs into an \EE{} that also connect each component corresponding to inner vertices of the hint. 


For convenience, we give a reduction from \pWMEECLAs{} (see \autoref{sec:remcycle}) instead of \pWMEEAs{}. This is without loss of generality because of \autoref{obs:redwmeeatocla}. We first give an intuitive description, followed by detailed construction and then a correctness proof. The construction uses the  function introduced on page~\pageref{def:minpath} in \autoref{sec:remcycle}.

\paragraph{Intuitive Description.} We look at the hints present in an \pWMEECLAs{} instance and eliminate them one at a time: For every hint~, first, a connected component is introduced (vertex set~, arc sets~ in the construction below) and copied for every inner vertex of the hint (vertex sets~, arc sets~ for~). Each copy is connected to the component corresponding to its vertex in the hint (by the arc-set~). The new component and its copies consist of interconnected imbalanced pairs of vertices. In the construction below, these are the vertices~ contained in the~-th component. Each pair corresponds to a pair of vertices~ forming the endpoints of a path that realizes the currently considered hint~.

 A new weight function gives meaning to the construction and ensures that adding an arc~ or an arc~ to an \EE{} has the same weight as a minimum-weight realization of the hint that goes from~ to~ or from~ to~, respectively. Notice that the superscript~``''corresponds to paths in one direction and the superscript~``'' to paths in the opposite direction. The weight function also ensures that if such an arc is present in an \EE{}, then the connected components traversed by the hint are connected to each other.

\begin{construction}\label{cons:redwmeeatowmee}
  Let the directed multigraph~, the weight-function~, and the advice~ constitute an instance~ of \pWMEECLAs. Let~ be the elements of~ and let~ be the connected components of~.



  For every~, inductively define~ and~ as follows: Let~ be the components of~ that correspond to the vertices traversed by~, ordered according to an arbitrary path orientation of~. For every~ introduce the vertex set

Set~. Make all these vertices imbalanced via the arc set

Let~ be the vertices in~. For each~, interconnect these vertices via a cycle, using the following arc set

Furthermore, for each~, choose~ and~ arbitrarily and add the following arc set connecting~ to~:

Now set~ and create a new weight function as follows:


The graph~, the weight function~ and the number~ constitute an instance~ of \pWMEEs{}.
\end{construction}
\begin{figure}
  \begin{center}
    \subfloat[\pWMEECLAs{} instance]{
      \includegraphics{wmeeslasha.1}
      \label{fig:redwmeeatowmeea}
    } \\
    \subfloat[\pWMEEs{} instance]{
      \includegraphics{wmeeslasha.2}
      \label{fig:redwmeeatowmeeb}}
    \caption{Example for \autoref{cons:redwmeeatowmee} explained in \autoref{ex:redwmeeatowmee}.}
    \label{fig:redwmeeatowmee}
  \end{center}
\end{figure}
\begin{example}\label{ex:redwmeeatowmee}
  Have a look at \autoref{fig:redwmeeatowmee}. At the top, an instance~ of \pWMEECLAs{} is shown. It comprises three connected components and an advice consisting of a single hint~ represented by the dashed edges. Below, there is an instance~ of \pWMEEs{} produced by \autoref{cons:redwmeeatowmee}. The dotted arcs represent the only arcs incident to the new vertices with weight potentially lower than~. 

In the new instance the hint~ is removed and a new component~ is introduced. A copy~ of the vertex set~ is introduced and connected to the component that corresponds to the inner vertex of~. The induced subgraphs of~ consist of pairs~ of vertices that are made imbalanced via a direct arc and that are connected via a directed cycle. Each of the vertices~---the ``sources''---has balance~ and can either be connected to a vertex~---the ``targets''---inside the same component or to another component. Analogously, targets can only accept at most one arc from either inside the same component or from outside. 

Consider a solution~ to~ that also contains the arcs~ as realization of~. We may remove these arcs and add the arcs~ to~, and add arcs from all remaining sources to their corresponding targets that reside in the same component to obtain a solution to~. Also, every solution to~ has to connect the connected component~ to the rest of the graph. This is only possible by adding an arc from a source to outside its component, for example at~. Then the vertex~ has to fetch an arc from~ in the \EE{} in order to become balanced. This means that then also the arc~ has to be included in an \EE{} for~ and thus we can include the path from vertex~ to vertex~ that realizes~ computed by the~ function.
\end{example}
\paragraph{Correctness.} We first prove that \autoref{cons:redwmeeatowmee} is polynomial-time computable and that the parameter in the reduced instance is polynomial in the original parameter. We then proceed to show the soundness of the construction.
\begin{observation}\label{obs:redwmeeatowmeepoly}
  \autoref{cons:redwmeeatowmee} is polynomial-time computable. There are~ components in~.
\end{observation}
\begin{proof}
  We first look at the running time of the construction: The size of~ and the arc sets~ is at most~. It holds that~ and there are at most~ hints in an advice (recall that hints in an advice are edge-disjoint). Hence, at most~ vertices and edges are added. This can be done in time linear in the number of  added vertices and edges. Thus, the new weight-function can be computed in~~time and this yields a polynomial-time algorithm for \autoref{cons:redwmeeatowmee}.

  Since there are at most~ hints in an advice and for every hint, there is exactly one new component (the component with vertex-set~) in the reduced instance, the new parameter is in~.
\end{proof}
\begin{lemma}
  \autoref{cons:redwmeeatowmee} is a polynomial-parameter polynomial-time reduction.
\end{lemma}
\begin{proof}
  By \autoref{obs:redwmeeatowmeepoly} it only remains to show that \autoref{cons:redwmeeatowmee} is correct. For this, first consider an \EE{}~ that is a solution to~. For every hint~ the set~ contains a set of paths that realize that hint. Without loss of generality we may assume that among those paths is~ for suitable vertices~ in the components that~ starts and ends, respectively (see \autoref{obs:minpathinee}). Thus, in order to connect the component~ to the rest of the graph, we may remove~ from~ and add the arcs

This does not increase the weight of~. To balance all vertices~ with~, we may add the corresponding arcs  and analogously for vertices in~, again without increasing the weight. Thus, doing this for every hint yields an \EE{} for~ of the same weight.

Now consider an \EE{}~ that is a solution to~. The set~ has to connect the component~ to the rest of the graph for every hint~. Thus, without limitation of generality, there is an arc~ for some vertices~ in the components that correspond to the endpoints of~. For every vertex~ all arcs with weight lower than~ end in it, and since it has balance~, there is exactly one arc incident to it in~. The same is true for vertices~ since all arcs with weight lower than~ start at them and they have balance~. Hence the arc~ is present in~, by induction also~, and finally also~. Thus we can remove these arcs from~, add~, and repeat this for all hints to obtain an \EE{} for~ that heeds the advice~ and has weight at most~.
\end{proof}
\begin{theorem}\label{the:redwmeeatowmee}
  \pWMEEA{} is polynomial-time polynomial-parameter many-one reducible to \pWMEE{} when parameterized by the number of components in the input graph.
\end{theorem}

\subsection{An Efficient Multivariate Algorithm for \pWMEECAs{}}\label{sec:multivariatealg}
In this section we consider~\pWMEECAs{} parameterized by both the number of components~ in the input graph and the sum~ of all positive balances of vertices in the input graph. A simple idea is used to obtain an efficient algorithm that solves \pWMEECAs{}. We prove the following theorem:

\begin{theorem}\label{the:kcalgwmeea}
  \pWMEECA{} is solvable in~~time, where~ is the number of components in the input graph and where~ is the sum of all positive balances of vertices in the input graph.
\end{theorem}

In a simple corollary, we also obtain an efficient algorithm for \pWMEEs{}, proving that this problem is fixed-parameter tractable with respect to the combined parameter~. We deem parameterizing with both~ and~ to be a good choice: The reduction we use to show \NPhs{} for \pWMEEs{} in \autoref{sec:relhcwmee} creates instances where~ implying that parameterizing only with~ does not suffice to obtain efficient algorithms. Also, the question whether \pWMEEs{} is fixed-parameter tractable with respect to parameter~ is a long-standing open question dating back to \citet{Fre77}. We reflect on the parameter~ in \autoref{sec:matching} and it seems hard to answer this question. 
 


To obtain an algorithm for \pWMEECAs{}, we use the fact that minimum-weight \EE s for connected multigraphs can be found in~~time~\cite{DMNW10}. To derive a connected instance of \pWMEEs{} from an instance of \pWMEECAs{}, we realize all hints in the given minimal connecting advice. The parameter~ helps to bound the number of possible ways we have to try to realize each hint. An algorithm that achieves the running time given in \autoref{the:kcalgwmeea} can simply try each combination of optimal realizations of each hint in the given advice and then solve the resulting instance comprising a connected multigraph via the polynomial-time algorithm given by \citet{DMNW10}. We denote a call to this algorithm by~, where~ is a connected multigraph and~ is a weight function. 

\paragraph{Solution Algorithm.} For convenience, we give an algorithm that solves \pWMEECCLAs{} which we then generalize to an algorithm for \pWMEECAs{} using \autoref{obs:redwmeecatoccla}. In \autoref{alg:kcalgwmeecla} a description of the solution algorithm is shown in pseudo code. It is invoked with an instance of \pWMEECCLAs{} and an empty set~. The set~ is then successively extended to a minimum-weight \EE . This is done by iterating over every local-optimal realization of each hint in lines~9 and~10 and recursing for every of them. When each hint is realized, that is~ in line~1, the resulting instance is solved in polynomial time.

\begin{algorithm}
  \LinesNumbered
  
  \KwIn{A directed multigraph~, a weight function~, a cycle-less advice~ and an arc-set~.}
  \KwOut{A minimum-weight \EE{} for~ that heeds the advice~.}

  \SetKwFunction{solve}{SolveEECA}
  \SetKwFunction{detcycle}{DetermineCycle}
  \SetKwData{minee}{MinEE}
  \SetKwData{found}{found\_solution}
  \SetKwData{act}{ActEE}

  \BlankLine
  \eIf{}{\Return{}\;}{
     a hint in~\;
     initial vertex of~\;
     connected component of~ corresponding to~\;
     terminal vertex of~\;
     connected component of~ corresponding to~\;
    \minee \;
    \found \;
    \For{ such that  or vice versa}{
      \;
      \act  \solve{}\;
      \If{}{
        \found \;
        \minee  \act\;
      }
    }
    \Return{\minee\;}
  }
  
  \SetAlgoRefName{Solve\-EECA}\caption{Solving \pWMEECCLAs{}.}
  \label{alg:kcalgwmeecla}
\end{algorithm}
\begin{proof}[Proof of \autoref{the:kcalgwmeea}]
  The theorem is mainly based on \autoref{alg:kcalgwmeecla}: Given an instance of \pWMEECAs{} we compute an equivalent instance of \pWMEECCLAs{} using the reduction in \autoref{obs:redwmeeatocla} that uses \autoref{alg:findcycle2}. Then, we apply \autoref{alg:kcalgwmeecla} solving the instance of \pWMEECLAs{}. We first look at the correctness of \autoref{alg:kcalgwmeecla} and then analyze the overall running time.

  Consider the return value~ of \autoref{alg:kcalgwmeecla} when called with an initially empty arc set~ and an instance of \pWMEECLAs{} consisting of the multigraph~, the weight function~, and minimal connecting advice~. For every hint in~ there is realization in~, that is,~ connects all connected components of~. Because of the call to~ the set~ also makes every vertex in~ balanced. Hence~ is an \EE{} for~ that heeds~. Also,~ is of minimum weight among all \EE s for~ that heed the advice~, because of the weight-minimality of~ and because, by \autoref{obs:minpathinee}, we may assume that in a minimum-weight \EE{} all path hints~ are realized by~ for appropriate vertices~ in the components of~ corresponding to the initial and terminal vertices of~.

Concerning the running time of the overall procedure, we have to preprocess the input instance using \autoref{trans:sb} and \autoref{trans:spp} (we have made this preprocessing implicit at the start of the section). By Lemmas~\ref{lem:smallbalancepp} and~\ref{lem:spp} this takes~~time. Next, the given instance of \pWMEECAs{} has to be converted to an instance of \pWMEECCLAs{}. By \autoref{lem:findcycle} this is possible in~~time. Finally, we apply \autoref{alg:kcalgwmeecla}: Obviously its recursion depth is at most~. Because of~, every call of \autoref{alg:kcalgwmeecla} yields at most~ recursive calls. This means the sum of all calls is~. The running-time of one call is dominated by either the computation of~ -instances which takes~~time (\autoref{lem:minpath}) or the computation of  which takes~~time~\cite{DMNW10}. Thus, \autoref{alg:kcalgwmeecla} can be computed in 
Because of~\autoref{obs:hintsinadvice},~ and thus we can derive that the running-time bound of the overall procedure is in~

\end{proof}

\begin{corollary}\label{cor:wmeefptbc}
  \pWMEE{} is solvable in~
\end{corollary}
\begin{proof}
  By \autoref{lem:redwmeetowmeea} there is a Turing reduction from \pWMEEs{} to \pWMEECAs{} with running time of~ and at most~ oracle calls. Replacing the oracle with the algorithm for \pWMEECAs{} given in \autoref{the:kcalgwmeea} we obtain an algorithm for \pWMEEs{} with~~running time: The algorithm first preprocesses the input using \autoref{trans:sb} and \autoref{trans:spp}, guesses the advice and then, instead of invoking the oracle, reduces the resulting instance of \pWMEECAs{} to an instance of \pWMEECCLAs{}. This instance is then solved using \autoref{alg:kcalgwmeecla}.
\end{proof}



\section{From Eulerian Extension to Matching and back}\label{sec:matching}

The observations in \autoref{sec:trails} suggest the following intuition for making multigraphs Eulerian: To balance every vertex in the given multigraph, we have to add paths from vertices with lower outdegree to vertices with lower indegree. This implies that we have to match these vertices such that adding paths between them leads to a minimum-size \EE. In this section we prove that this intuition is correct and restate \pWMEEs{} as the newly introduced \pCBM{}~(\pCBMs{}).

In previous work by \citet{DMNW10} a similar approach that involves matchings yields polynomial-time algorithms for some restricted \EE{} problems. Of course polynomial-time solvability would be very surprising for \pWMEEs{} because this problem is \NPh ; and we will see that the corresponding matching problem~\pCBMs{} indeed is also \NPh . However, we deem the matching representation to be more accessible in terms of fixed-parameter complexity. In this regard, we show that \pCBMs{} is fixed-parameter tractable on restricted input graphs for a parameter that translates over to the number of components in \pWMEEs{}. Using this we make partial progress to answering the question whether \pWMEEs{} is fixed-parameter tractable with the parameter number of connected components by showing that it indeed is fixed-parameter tractable in a restricted form. We also gather a polynomial-size problem kernel for \pWMEECAs{} as a simple corollary using the matching formulation.

In \autoref{sec:cbm} we introduce \pCBMs{}, show that it is \NPh{}, and derive that it is fixed-parameter tractable on special input graphs. In \autoref{sec:releecbm} we investigate the relationship between \pWMEEs{} and \pCBMs{}, and show that they are parameterized equivalent. Using this equivalence, we derive fixed-parameter tractability results for \pWMEEs{} as simple corollaries.

\subsection{\pCBM{}}\label{sec:cbm}

In this section we introduce \pCBM{} (\pCBMs{})---a variant of minimum-weight perfect bipartite matching. We show that this problem is \NPh{} and fixed-parameter tractable on a restricted graph class.

\begin{definition}
  Let  be a bipartite graph,\footnote{Note that~ is undirected.} let~ be a matching of the vertices in~ and let~ be a vertex-partition with the cells~. We call an unordered pair~ of integers~ a \emph{join} and a set~ a \emph{join set} with respect to~ and~ if~.  
We say that a join~ is \emph{satisfied} by the matching~ of~ if there is at least one edge~ with~ and~. We say that a matching~ of~ is \emph{-conjoining} with respect to a join set~ if all joins in~ are satisfied by~. If the join set is clear from the context, we simply say that~ is conjoining.
\end{definition}
\decprob{\pCBM{} (\pCBMs{})}{A bipartite graph  with a weight function~, a partition~ of the vertices in~ and a join set~.}{Is there a matching~ of the vertices of~ such that~ is perfect,~ is conjoining and~ has weight at most~?}
\begin{figure}
  \begin{center}
    \includegraphics{cbmexample.3}
    \caption{An instance of \pCBMs{} comprising a bipartite graph with the vertices~ through~ and the solid edges, a vertex partition represented by the gray objects, and a join set consisting of a single join that is represented by the dashed line. The weight function is ignored here. The shown instance has a perfect matching, for example~. However, it does not have a perfect and conjoining matching: The vertex~ has to be matched to~ in any perfect matching. Thus, the vertices~ and~ cannot be matched. Since~ is already matched, the vertex~ has to be matched to~. This means that the vertices~ and~ cannot be matched. Thus, no edge that satisfies the single join present can be contained in a perfect matching.}
    \label{fig:cbmexample}
  \end{center}
\end{figure}For an example of an instance of \pCBMs{}, see \autoref{fig:cbmexample}.
\begin{example}
  \pCBMs{} models a variant of the assignment problem with additional constraints. In this variant, an assignment of workers to tasks is sought such that each worker is busy and each task is being processed. Furthermore, every worker must be qualified for its assigned task. Both the workers and the tasks are grouped and the additional constraints are of the form ``At least one worker from group A must be assigned a task in group B''. An assignment that satisfies such additional constraints may be favorable in the following scenario. 

A company wants to create working groups, each working on a distinct project consisting of multiple tasks. However, every working group shall have a very creative member, a very social and a very methodical member. Here, we assume that extreme creativity, sociality and methodicality are mutually exclusive. 

This scenario can be modeled in \pCBMs{} by defining a bipartite graph that has a vertex for every worker and task, and that has an edge between a worker and a task, if the worker is qualified for the task. The additional constraints can be modeled by first partitioning the tasks into the projects~ and partitioning the workers into the creative ones~, the social ones~ and the methodical ones~. Then, creating a join set~ ensures that every working group is assigned at least one creative, social, and methodical member. 

The edge weights can be ignored in our scenario. However, as we will see in the forthcoming section, the problem of \pCBMs{} is \NPh{} even in the unweighted case.

\end{example}

\subsubsection{\NPHs}

We reduce from the well-known \ptSATs{} problem~\cite{Kar72}. For this, we briefly recapitulate some related definitions.
\begin{definition}
Consider the boolean variables~. \emph{Positive literals} over~ are~ and \emph{negative literals} are~ with~. A \emph{boolean formula~ in conjunctive normal form} over the variables~ is of the form~, where~. Here~,~ are literals over~. The subformulas~,~, are called \emph{clauses}. If it holds that~, then we say that~ is in \emph{-conjunctive normal form}. A \emph{truth assignment}~ for the variables~ is a function~. A truth assignment is said to be \emph{satisfying} for a boolean formula~ if~ evaluates to  when substituting~ for every variable~ occuring in~.
\end{definition}

 In \ptSATs{}, a boolean formula~ in 3-conjunctive normal form is given and it is asked whether there is a truth-assignment of the variables in~ that satisfies~. We use the fact that, in \pCBMs{}, connected components that form cycles have exactly two perfect matchings because every cycle in a bipartite graph has even length. Thus, we model variables as cyclic connected components and the two possible matchings will correspond to the two possible truth values for the variables. Clauses will be modeled by cells in the input partition and a join that forces one of the corresponding variable-cycles into one of the two possible matchings in order to satisfy the clause. 

In the following, we regard clauses of boolean formulas in 3-conjunctive normal form over the variables~ as subsets of~ where~~() in the clause~ implies that~ is in the clause~ as a positive (negative) literal.

First, we give an intuitive description of the reduction, we then go into the details. After that, we give an example and prove the correctness of the reduction.

\paragraph{Intuitive Description.} Let~ be a boolean formula in 3-conjunctive normal form with~ variables and~ clauses. For every variable~ we introduce a cycle consisting of~~vertices (vertex set~ and edge set~ in the below construction). For every such cycle, we fix an ordering of the edges~ according to the order in which they are traversed by the cycle. In a perfect matching of the cycle either all edges~ with odd~ are matching edges or all edges~ with even~ are matching edges. These two matchings will correspond to assigning~ the value  or , respectively.

 Next, for every clause~ we define a cell~ in order to derive a partition of the vertices in the cycles. For every positive literal~ contained in~, we choose an edge~ such that~ is even and such that its vertices have not been assigned to a cell yet, and put both endpoints of~ into~. Analogously, for every negative literal~ we choose an edge~ such that~ is odd and such that its endpoints have not been assigned yet, and put them into~. Finally, all vertices that have not been assigned to a cell yet, are added to the cell~ and for every cell~ we add the join~ to the designated join set.
\begin{construction}\label{cons:red3sattocbm}
  Let~ be a boolean formula in 3-conjunctive normal form with the variables~ and the clauses~.

  For every variable~, introduce a cycle with~ edges consisting of the vertex set~ and the edge set~
Define the graph~, define the weight function~ by~ for any~, and define~.

Inductively define the vertex partition~ of~ and the join set~ as follows: Let~ and let~. For every clause~ introduce the cell

Define~ and~.

Finally, define~. The graph~, the weight function~, the vertex partition~ and the join set~ constitute an instance of \pCBMs{}.
  
\end{construction}
\begin{figure}
  \begin{center}
    \includegraphics{cbmexample.1}
    \caption{Example of \autoref{cons:red3sattocbm} explained in \autoref{ex:red3sattocbm}.}
    \label{fig:red3sattocbm}
  \end{center}
\end{figure}
\begin{example}\label{ex:red3sattocbm}
  \autoref{fig:red3sattocbm} shows an instance of \pCBMs{} produced from the formula~ by \autoref{cons:red3sattocbm}. For simplicity, we chose a formula in 2-conjunctive normal form. The instance comprises the graph~ that consists of two directed cycles (solid edges and dotted edges, respectively), three cells~ forming a partition of~ (shaded in gray), and a join set with two joins represented by the dashed lines.

  \autoref{cons:red3sattocbm} introduces the solid-edge cycle for variable~ and the dotted-edge cycle for variable~. The cycle corresponding to~ has exactly the two perfect matchings

The cell~ models the clause~ and the vertices are chosen such that only edges of~ and edges of~ connect the cells~ and~. Analogously, only edges of~ and edges of~ connect the cells~ and~.

  There is a correspondence between the clauses a variable~ satisfies using a particular truth assignment and the joins that are satisfied by matching the cycle that corresponds to~ using one of the two available matchings. For example, the variable~ satisfies both clauses in~ when assigned  and no clause when assigned . Accordingly, the matching~ satisfies both the joins~, and~ and the matching~ satisfies no join. This holds true analogously for~ and thus finding a perfect conjoining matching in~ is equivalent to satisfying~.
\end{example}
\begin{lemma}
  \pCBMs{} is \NPh{}, even in the unweighted case, even when for every cell~ in the given vertex-partition of the input graph~ it holds that~ and even when~ has maximum degree two.
\end{lemma}
\begin{proof}
  We prove that \autoref{cons:red3sattocbm} is a polynomial-time many-one reduction from \ptSATs{} to \pCBMs{}. Notice that in instances created by \autoref{cons:red3sattocbm} any matching has weight lower than~ and, thus, the soundness of the reduction implies that \pCBMs{} is hard even without the additional weight constraint. Also, since the cells in the instances of \pCBMs{} are disjoint unions of edges, every cell in the partition~ contains the same number of vertices from each cell of the graph bipartition. 

  Concerning \autoref{cons:red3sattocbm}, it is easy to check that it is polynomial-time computable. For the correctness we first need the following definition: For every variable~ let

Observe that all perfect matchings in~ are of the form~, where~ is some function~. We show that the matching~ is a conjoining matching for~ with respect to the join set~ if and only if the truth assignment that assigns each~ the value~ is a satisfying truth assignment for~. For this, it suffices to show that for every variable~ it holds that

We only show that \autoref{eq:matchvalequiv1} holds; \autoref{eq:matchvalequiv2} can be proven analogously. Assume that~. By \autoref{cons:red3sattocbm}~ and thus, since  the matching~ satisfies the join~. Now assume that~, that is, either 
\begin{inparaenum}
\item both~ \label{enu:mnph1} or
\item . \label{enu:mnph2}
\end{inparaenum}
In case~\enuref{enu:mnph1} we have that~ and~ are disjoint and, thus, no matching in~ can satisfy the join~. In case~\enuref{enu:mnph2} the only edges in~ that can satisfy the join~ are~ and~. However, both these edges are not in~ and, thus, this matching cannot satisfy the join~.
\end{proof}
\begin{observation}\label{obs:cbminnpwp}
  \pCBMs{} is contained in \claNP{} and in \claW{P} when parameterized by the size of the join set.
\end{observation}\begin{proof}
  Observe that a minimal matching~ that satisfies all joins is a certificate for a yes-instance. Note that~ not necessarily has to be perfect. A minimum-weight perfect conjoining matching~, if it exists, can then be found in polynomial time by removing the incident vertices of edges in~ from the graph and computing a minimum-weight perfect matching of the remaining vertices. Finding this matching is possible in~~time~\cite{EK72} and it follows that \pCBMs{} is in~\claNP. Also, generating all minimal matchings that satisfy all joins can be done using a polynomial-time Turing machine using at most~~nondeterministic steps, where~ is the size of the join set: For every join, simply guess an edge that satisfies it. Hence, \pCBMs{} is in~\claW{P}.
\end{proof}
Now we can deduce the following theorem:
\begin{theorem}\label{the:cbmnph}
  \pCBM{} is \NPc .
\end{theorem}

\subsubsection{Tractability on Restricted Graphs}

In this section we use data reduction rules to show that \pCBMs{} is fixed-parameter tractable on some restricted classes of input graphs. In particular, we prove that \pCBMs{} is linear-time decidable on forests (\autoref{cor:cbmlintimeonforests}) and the following theorem:
\begin{theorem}\label{the:cbmmaxdeg2tractable}
  \pCBM{} is solvable in~~time, where~ is the size of the join set and when in the bipartite input graph~ each vertex in~ has maximum degree two.
\end{theorem}
Using this theorem and a reduction from \pWMEE{} to \pCBMs{}, we show that \pWMEE{} is tractable on some restricted instances in \autoref{sec:tractislands}. The tractable instances are the preimages of the degree-restricted instances of \pCBMs{} defined in \autoref{the:cbmmaxdeg2tractable}.

To prove the \autoref{the:cbmmaxdeg2tractable}, we use data reduction rules and an observation about matchings in such bipartite graphs as in \autoref{the:cbmmaxdeg2tractable}. We first give some simple reduction rules and then turn our attention to bipartite graphs with maximum degree two. For these graphs we give a slightly more intricate reduction rule restricting the number of cycles they comprise by some function depending only on the join set size~. These reduced instances are then solved via a search-tree procedure which yields fixed-parameter tractability for \pCBMs{} on graphs with maximum degree two. A further observation about matchings in bipartite graphs where each vertex in one cell of the bipartition has maximum degree two is then used to generalize the tractability result to \autoref{the:cbmmaxdeg2tractable}.

In the following, let~ be a bipartite graph, let~ be a weight function, let~ be a vertex partition of~ and let~ be a join set with respect to~ and~.

\paragraph{Simple Data Reduction Rules.}

\begin{rrule}\label{rr:deg1}
  If there is an edge~ such that~, then remove both~ and~ from~, and remove any join~ from~, where~. Decrease~ by~.
\end{rrule}
\begin{observation}\label{obs:deg1runtime}
  \autoref{rr:deg1} is correct and can be applied exhaustively in~~time.
\end{observation}
\begin{proof}
  It is clear that \autoref{rr:deg1} is correct because the sought matching is perfect and thus has to match~ with~. It can be applied in linear time by first listing all vertices with degree one in linear time and then applying the rule in a depth-first manner outgoing from the degree-one vertices.
\end{proof}
\begin{corollary}\label{cor:cbmlintimeonforests}
  \pCBMs{} is linear-time solvable on forests.
\end{corollary}
\begin{rrule}\label{rr:compincell}
  If there is a connected component~ of~ such that~ for some~, then compute a minimum-weight perfect matching~ in~, remove~ from~ and decrease~ by~.
\end{rrule}
\begin{observation}\label{obs:compincellruntime}
  \autoref{rr:compincell} is correct and can be applied exhaustively in~~time.
\end{observation}
\begin{proof}
  The correctness of \autoref{rr:compincell} is easy to prove, since for any perfect conjoining matching~ for~ we can derive a matching of at most the weight~ by matching the vertices in~ according to~. Hence we can derive a matching of weight at most~ in the graph with~ removed. Obtaining a matching for~ from a matching in the graph~ with~ removed is trivial.

  Applying \autoref{rr:compincell} exhaustively can be done by first finding all connected components~ that are contained in one cell in linear time and then computing a minimum-weight perfect matching in the graph~ in~~time~\cite{EK72}. Then, deleting the affected vertices is possible in linear time.
\end{proof}

\paragraph{Reduction Rule for Maximum Degree Two.}Now let~ be a bipartite graph with maximum degree two of an instance of \pCBMs{} that is preprocessed with \autoref{rr:deg1} and \autoref{rr:compincell}. In this graph, any degree-one vertices have been deleted and thus each vertex has degree two. It follows that~ consists of connected components each of which is a cycle of even length---because~ is bipartite. Thus every connected component has exactly two perfect matchings. To describe a third reduction rule, we need the following definitions:
\begin{definition}
  For every connected component, that is, every cycle~ contained in~, denote by~ a minimum-weight perfect matching of~ with respect to~ and denote by~, that is, the other perfect matching of~. Furthermore, define

and the \emph{signature}~ of~ as~. We say that two signatures~ are \emph{equal} and we write~, if

\end{definition}
\begin{rrule}\label{rr:signature}
  Let~ be a maximal set of connected components of~ such that~ and~. Let~, let~ such that~ is minimum and let~.\begin{lemenum}
  \item If the matching~ is conjoining for the join set~, then remove each component in~ from~, remove each join in~ from the join set~, and reduce~ by~.
  \item If the matching~ is not conjoining for the join set~ remove each component in~ from~, remove any join in~ from the join set~, and reduce~ by~. 
  \end{lemenum}

  In either case, update the partition~ accordingly.
\end{rrule}\begin{lemma}
  \autoref{rr:signature} is correct.
\end{lemma}
\begin{proof}
  Let~ be a graph with maximum degree two, let ~ be a weight function, let~ be a vertex partition of~ and let~ be a join set with respect to~ and~. The objects~,~,~,~, and~ constitute an instance~ of \pCBMs{}. Furthermore, let the graph~, the weight function~, the maximum weight~, the vertex partition~, and the join set~ with respect to~ and~ constitute the instance~ that is obtained from~ by applying \autoref{rr:signature} with the set~ as defined there.

  Let~ be a perfect~-conjoining matching for~ with~ and assume that the matching~ is conjoining for the join set~. Then either~, or we can obtain another perfect~-conjoining matching with weight at most~ that satisfies this property. Without loss of generality assume that~. Then~ is a perfect~-conjoining matching for~ with weight~. 

Now assume that~ is not conjoining for the join set~. Then either
\begin{asparaenum}
\item  or \label{enu:sig11}
\item there is an integer~ such that~. \label{enu:sig12}
\end{asparaenum}
We first show that, in case~\enuref{enu:sig12}, we may assume without loss of generality that~ is unique and that~ as in \autoref{rr:signature}. Otherwise we can find another perfect~-conjoining matching with weight at most~ that satisfies this property: Since~ is not conjoining for the join set~, it holds that

because all signatures of the components in~ are equal by prerequisite of \autoref{rr:signature}. If~ is not unique, there are~ such that~. However, by definition~ and if we substitute~ for~ in~, the resulting matching has at most the same weight and is still~-conjoining because~. Hence we can assume that~ is unique. We can also assume that~ because by definition of~~ and thus we can substitute~ for~ and~ for~ in the matching~ to obtain a perfect~-conjoining matching of at most the same weight. Consider the matching~. Both in case~\enuref{enu:sig11} and in case~\enuref{enu:sig12}, when assuming that~ is unique,~ is a perfect~-conjoining matching for~ of weight~.

  We now have that if~ is a yes instance then~ is a yes instance. For the other way round, assume that~ is a perfect~-conjoining matching for~ of weight~. Assume that each component in~ of~ has been removed in~ by \autoref{rr:signature}. Then the matching~ for~ is perfect,~-conjoining and of weight~. Now assume only the component~ of the components in~ is still present in~. Then, the matching~ is a perfect~-conjoining matching for~ of weight~.
\end{proof}
\begin{lemma}\label{lem:signatureruntime}
  \autoref{rr:signature} can be applied exhaustively in~~time.
\end{lemma}
\begin{proof}
  To apply \autoref{rr:signature} once, we can first search for a set of components~ as defined there by first finding all connected components in linear time. Then we find out the signature of each connected component. For this, we first compute a minimum-weight perfect matching for every connected component in overall~~time by simply iterating over the edges in each component, alternatingly summing up the edge weights and choosing the lower one of the two values. We annotate every edge with whether it is contained in the minimum-weight matching or not and which join it satisfies, if any, in~~time. We then iterate over every edge and add the information saved in the annotation to the signature of the connected component it is contained in. 

Having computed the signatures, we create a map in~~time that maps every signature present to the list of connected components that have this signature. We then simply iterate over every list present in the map to obtain a maximal list of components that have the same signature or decide that there is no such list with at least two elements. This is possible in~~time. 

The removal of the connected components and joins, the update of~ and the partition~ is then possible in linear time, because the matchings for each component have already been computed and thus the overall running time is~. Observe that in graphs with exactly degree two~ and thus we can derive a running time bound in~.
  
In any application either no set~ is found and thus the procedure terminates, or at least~4 vertices are deleted---this is the minimum size of a connected component. Hence the procedure can be applied at most~ times and exhaustively applying \autoref{rr:signature} takes~~time.
\end{proof}
\begin{observation}
  When \autoref{rr:signature} cannot be applied anymore, the input graph contains at most~ components, where~ is the size of the join set.
\end{observation}
\begin{proof}
  When there are~ joins in a join set, then there are at most~ signatures. For each signature, there is at most one connected component when \autoref{rr:signature} is not applicable.
\end{proof}
\begin{lemma}\label{lem:cbmmaxdeg2tractable}
  \pCBMs{} is solvable in~~time on graphs with maximum degree two, where~ is the size of the join set.
\end{lemma}
\begin{proof}
  This follows from exhaustively applying \autoref{rr:deg1}, \autoref{rr:compincell}, and \autoref{rr:signature} and then invoking a search tree algorithm. The algorithm chooses one join, branches into choosing any component that contains an edge that satisfies the join, matches the component accordingly and then recurses until every join is satisfied. Since there are at most~ components in the preprocessed graph, every branching-step invokes at most~ recursive calls. The recursion depth is obviously at most~. In every call at most~~time is spent finding components satisfying the chosen join and thus we can derive a running time bound of~ for the search tree algorithm. The preprocessing rules take~~time by \autoref{obs:deg1runtime}, \autoref{obs:compincellruntime}, \autoref{lem:signatureruntime}, and by the fact that~ in graphs with degree at most two. Thus the overall running time bound is~.
\end{proof}
\paragraph{Perfect Matchings in Graphs with Maximum Degree Two.} Now let~ be a bipartite graph where each vertex in~ has maximum degree two. We show that if~ has a perfect matching, it will be preprocessed by \autoref{rr:deg1} such that each vertex has degree exactly two.
\begin{lemma}\label{lem:perfmatchatmostonecycle}
  If~ has a perfect matching, every connected component of~ contains at most one cycle as subgraph.
\end{lemma}
\begin{proof}
  We show that if~ contains a connected component that contains two cycles~ as subgraphs, then~ does not have a perfect matching. First assume that~ are vertex-disjoint. Then, there is a path~ from a vertex~ to a vertex~ such that~ is vertex-disjoint from~ and~ except for~. It is clear that both~ because they have degree three. Consider the vertices~ and the set~. The set~ is the set of neighbors of vertices in~, because they have degree two and thus have neighbors only within~,~, and~. It is~ since neither of these paths and cycles overlap in a vertex in~. However, it is~ because~ and~ overlap in~ and~ and~ overlap in~. This is a violation of Hall's condition---recall the definition of Hall's condition in \autoref{the:hallscondition}---and thus~ does not have a perfect matching.

  The case where~ and~ share vertices can be proven analogously. (Observe that then there is a subpath of~ that is vertex-disjoint from~ and contains an even number of edges.)
\end{proof}

\begin{proof}[Proof of \autoref{the:cbmmaxdeg2tractable}]
Consider applying \autoref{rr:deg1} to a graph~ such that each vertex in~ has maximum degree two and such that~ has a perfect matching. This has to yield a graph that is a collection of vertex-disjoint cycles because in every connected component there is at most one cycle as subgraph (\autoref{lem:perfmatchatmostonecycle}). Hence, every component consists of a cycle with a collection of pairwise vertex-disjoint paths incident to it. These paths are completely reduced by \autoref{rr:deg1} and all that remains is either the cycle or nothing. Thus, in order to cope with graphs~ as above, we can modify the algorithm from \autoref{lem:cbmmaxdeg2tractable}: If the application of \autoref{rr:deg1} does not yield a graph that is a collection of vertex-disjoint cycles, we can abort the procedure because it cannot yield a perfect matching. This can be checked in linear time and thus, \autoref{the:cbmmaxdeg2tractable} now directly follows. (Notice that the running time bound of \autoref{lem:cbmmaxdeg2tractable} does not increase, since in graphs~ as above that have a perfect matching it also holds that~.)
\end{proof}



\subsection{The Relationship between Eulerian Extension and Matching} \label{sec:releecbm}

In this section we show that \pCBMs{} parameterized by the size of the join set and \pWMEEs{} parameterized by the number of connected components in the input graph are parameterized equivalent. To this end, we first give a reduction from \pWMEECAs{} to \pCBMs{}. This reduction also yields an efficient algorithm for a restricted variant of \pWMEEs{}. Second, we give a reduction from \pCBMs{} to \pWMEEAs{}. The equivalence of \pWMEEs{} and \pCBMs{} then follows from the reductions given in \autoref{lem:redwmeetowmeea} and \autoref{the:redwmeeatowmee} in \autoref{sec:wmeeslasha}.



\subsubsection{Reducing \pWMEECAs{} to \pCBMs{}}
We first reduce \pWMEECAs{} to \pCBMs{}. In order to simplify our reduction, we reduce from \pWMEECCLAs{} instead (see page~\pageref{def:pWMEECA} in \autoref{sec:wmeeslasha}). We know that \pWMEECCLAs{} and \pWMEECAs{} are equivalent from \autoref{obs:redwmeecatoccla}.

As we have observed in \autoref{obs:walkdichotomy} we have to draw paths between unbalanced vertices in order to make them balanced and to ultimately make the input graph Eulerian. These paths also have to connect all components of the input graph. The basic structure of these paths is made explicit by the advice in \pWMEECCLAs{} and thus we do not have to concern ourselves with finding a suitable order of components for these paths. We simply have to realize every hint to connect the graph and then balance all remaining vertices.

\paragraph{Reduction Outline.}
The basic ideas of our reduction are to use vertices of positive balance and negative balance in an instance of \pWMEECCLAs{} as the two cells of the graph bipartition in a designated instance of \pCBMs{}. Edges between vertices in the new instances represent shortest paths between them that consist of allowed extension arcs in the original instance. Every connected component in the original instance is represented by a cell in the vertex partition in the matching instance and hints are basically modeled by joins.

We proceed with an intuitive description of the reduction and then go into the details in \autoref{con:redwmeeatocbm}. The construction is then followed by a correctness proof. For the descriptions, we first need the following definition.
\begin{definition}
  Let~ be a directed multigraph with the connected components~ and let~ be a cycle-free advice for~. For every hint~ we define~, where~ are the components corresponding to the initial and terminal vertices of~.
\end{definition}
\paragraph{Intuitive Description.}
First, consider an instance~ of \pWMEECCLAs{} that consists of the graph~, the weight function~ and a cycle-free minimal connecting advice~ that contains only hints of length one. We will deal with longer hints later. We create an instance~ of \pCBMs{} by first defining~ as a bipartite graph. Here, the set~ consists of all edges~ such that~,~, and~. This serves the purpose of modeling the structure of allowed arcs in the matching instance---we come back to this in \autoref{sec:tractislands}. Second, we derive a vertex partition~ of~ by intersecting the connected components of~ with~. The vertex-partition obviously models the connected components in the input graph, and the need of connecting them according to the advice~ is modeled by an appropriate join-set~, defined as~. Finally, we make sure that matchings also correspond to \EE s weight-wise, by defining the weight function~ for every~ as~ with~.

By \autoref{obs:shorttrails} we may assume that every hint in~ of length one is realized by a single arc. Since the advice connects all connected components, by the same observation, we may assume that all other trails in a valid \EE{} have length one (\autoref{obs:shorttrails} also holds for the connected graph obtained by adding the realizations of all hints to the input graph). Finally, by \autoref{lem:smallbalancepp}, we may assume that every vertex has at most one incident incoming or outgoing arc in the extension and, hence, we get an intuitive correspondence between the matchings and \EE s. 

\begin{figure}
  \begin{center}
    \subfloat[\pWMEECLAs{} instance]{
      \includegraphics{wmeeslasha.1}
      \label{fig:redwmeeatocbma}
    } \\
    \subfloat[Long-hint gadget in \pCBMs{} instance]{
      \includegraphics{wmeecbm.1}
      \label{fig:redwmeeatocbmb}}
    \caption{Example for the long-hint gadget used in \autoref{con:redwmeeatocbm}, explained in the corresponding intuitive description.}
    \label{fig:redwmeeatocbm}
  \end{center}
\end{figure}
To model hints of length at least two, we utilize gadgets similar to the one shown in \autoref{fig:redwmeeatocbm}. On the top, an instance~ is shown, consisting of a graph with three connected components and an advice that contains a single hint~ (dashed lines). Below in \autoref{fig:redwmeeatocbmb} a part of an instance of \pCBMs{} is shown, which comprises the cells that correspond to the initial and terminal vertices of~ and a gadget to model~. The gadget consists of some new vertices which are put into a new cell which is connected by two joins (dashed and dotted lines) to the cells corresponding to the initial and terminal vertices of~.

The gadget comprises two vertices ( and ) for every pair~ of vertices with one vertex in the component the hint starts and one in the component the hint ends. The vertices~ and  are adjacent and each of these two vertices is connected with one vertex of the pair it represents. The edge~ is weighted with the cost it takes to connect~ with a path~ such that~ that is, a path that realizes~. The other edges have weight~. Intuitively these three edges in the gadget represent one concrete realization of~. If~ and~ are matched, this means that this specific path does not occur in a designated \EE{}. However, by adding the vertices of the gadget as cell to the vertex partition and by extending the join set to the gadget, we enforce that there is at least one outgoing edge that is matched. If~ is matched with~, then~ must be matched with~ and vice versa, otherwise the matching could not be perfect. This introduces an edge to the matching that has weight corresponding to a path that realizes~.

\begin{construction}
  \label{con:redwmeeatocbm}
  Let the directed multigraph~, the weight function~ and the advice~ constitute an instance of \pWMEECCLAs . Let~ be the connected components of~.
  
  Let  be the set of hints of length one in~ and let~ be the set of hints in~ that have length at least two. Define~ by the set~. Let~,~, and let~ be a bipartite graph where~ Define~,~, and~ where~.

  Let  be the hints in~. Inductively define~,~,~ and~,~, as follows: Let~. Introduce the vertex sets 

and~. Introduce the edge sets

Set~, and set the graph

set~, set~ and the weight-function as follows:  

Then the graph~, the weight function~, the vertex partition~ and the join set~ constitute an instance of \pCBMs .\end{construction}

For the remainder of this section, let the directed multigraph~, the weight function~ and the cycle-free minimal connecting advice~ constitute an instance of \pWMEECCLAs{} and let the bipartite graph~, the weight function~ with the maximum weight~, the vertex partition~ and the join set~ as in \autoref{con:redwmeeatocbm} constitute an instance of \pCBMs{}.

\begin{lemma}
  \label{lem:redwmeeatocbmtransfer}
  Let~ be an \EE{} for~ that heeds the advice~. Then there is a perfect conjoining matching~ for~ with .
\end{lemma}
\begin{proof}
  We construct the matching successively by first looking at every long-path gadget in~ and then matching the remaining vertices.

  Consider the cell~ for . There are two joins~ and~ in~. Thus, there is a path hint~ from~ to~ in~. This means that, there is a path~ in~ that starts in a vertex~ in the component~ and ends in a vertex~ in~. The weight~ is at least~ (\autoref{obs:minpathinee}). Thus we may match~ with~,  with~ (this costs weight~) and every other pair~ and~ in~ with each other (this costs weight~). Matching like this, we obtain a matching for the long-hint gadget of~ that fulfills its two joins and is perfect. The weight of the matching is at most the realization of~ in~. 

Because of \SPP{} (\autoref{trans:spp}) and \autoref{obs:metaedgedisjoint} we may assume that there is a set of paths in~ that is edge-disjoint and realizes all hints in~ (otherwise we may obtain an \EE{} of at most the same weight that has this property). Because of this, we may find a matching~ for~ that satisfies the joins of every long-hint gadget and is perfect with respect to the vertex set of each long-hint gadget---as in the previous paragraph, iterated for every gadget. Furthermore,~ is lower than the weight of all paths in~ that realize hints of length at least two in~. 

Now it is easy to extend~ to a conjoining matching~ for~ and~ just by adding matching edges between vertices that realize hints of length one in~. We may assume by \autoref{obs:shorttrails} that each hint of length one is realized by a single arc in~. The weight of matching edges is exactly the cost of the direct arc between the corresponding vertices. Because of this, we maintain that ~is at most the weight of all paths in~ that realize hints. 

Finally, we have to extend~ to a perfect matching~ by matching the remaining non-gadget vertices. We can do this by looking at paths in~ that start and end in the vertices in~, corresponding to still unmatched vertices in~. A set of such paths must exist, because each such vertex has at least one incident arc in~ and because, by \autoref{obs:walkdichotomy}, maximal-length open trails in \EE s start and end in unbalanced vertices. The edges between initial and terminal vertices of those paths in~ have at most the weight of such a path (because of \SPP{} and because they have weight corresponding to the direct arc). Thus, we can add those edges to~, obtaining an edge set~. This set is a matching for~ that is perfect, conjoining and~.
\end{proof}
\begin{lemma}
  \label{lem:redwmeeatocbmbacktransfer}
  Let  be a perfect conjoining matching for~. We can construct an \EE{}~ for~ that heeds the advice~ such that~.
\end{lemma}
\begin{proof}
  We simply look at every matching edge that has non-zero weight and add a corresponding path to a designated \EE{}~ of~: For non-gadget matching edges (edges that match vertices in~) the corresponding path is the direct arc between the two vertices in~. For edges that match a vertex~ in a cell~,~ and a vertex~,~, where~, the corresponding path is~. Here, ~is the path in~ that lead to the introduction of~ in \autoref{con:redwmeeatocbm}.



  We immediately see that~. Also, it is clear that every hint of length one in~ is realized in~ because every hint~ of length one leads to the pair~ in~. Hints~ of length two are also realized, because every such path leads to a cell~,~ and also leads to the corresponding joins~ and~ in~, where~. Thus,~ heeds the advice~. Since~ is a perfect matching, every unbalanced vertex in~ is the initial or terminal vertex of exactly one path added to~ in the above paragraph. By \autoref{lem:smallbalancepp} we may assume that this suffices to make every vertex in~ balanced. Also, ~is connected, because~ heeds the advice~.
\end{proof}
\begin{lemma}
  \label{con:redwmeeatocbmruntime}
  \autoref{con:redwmeeatocbm} is computable in~~time.
\end{lemma}
\begin{proof}
  Computing~ takes~~time. To compute~ one needs~~time by iterating over every path in~. Computing the initial partition~ takes~~time and the initial weight function~ can also be computed within this time. Hence, creating the initial instance is possible in~~time.
 
  Regarding adding the gadget for one path in~, to compute the sets~ and~,~~time is suffices, because~ instances of~ have to be computed, each taking~~time (\autoref{lem:minpath}). There are only three edges in the gadget for every vertex~, thus computing the edge sets does not increase the running time bound. For the weight function we can reuse the values of~ computed for every pair of vertices~ and thus we can conclude an overall running time bound of~.
\end{proof}
Now the following theorem follows:
\begin{theorem}\label{the:redwmeecatocbm}
  \pWMEECA{} is polynomial-time many-one reducible to \pCBM . The corresponding reduction function is a parameterized reduction with respect to the parameters number of components in the graph of \pWMEECAs{} and join set size in \pCBMs{}.
\end{theorem}
\begin{proof}
  By \autoref{obs:redwmeecatoccla}, there is a polynomial-time many-one reduction from \pWMEECAs{} to \pWMEECCLAs{}. This reduction at most decreases the number of components in the input graph. By \autoref{lem:redwmeeatocbmtransfer} and \autoref{lem:redwmeeatocbmbacktransfer} there is a many-one reduction from \pWMEECCLAs{} to \CBMs{} . Since the construction is polynomial-time computable (\autoref{con:redwmeeatocbmruntime}), since for every hint in the advice there are at most two joins, and since the number of hints is bounded by the number of components in the input graph to \pWMEECAs{} (\autoref{obs:hintsinadvice}) it follows that \autoref{con:redwmeeatocbm} is a parameterized polynomial-time many-one reduction.
\end{proof}
\begin{corollary}
  \pWMEE{} is parameterized Turing reducible to \pCBM{} with respect to the parameters number of components in input graph and join set size.
\end{corollary}
\begin{proof}
  The statement follows from \autoref{lem:redwmeetowmeea} and \autoref{the:redwmeecatocbm}.
\end{proof}

\subsubsection{Islands of Tractability for  \pWMEEs}\label{sec:tractislands}
Using the reduction given in \autoref{con:redwmeeatocbm}, we can gather the fruit of our work in \autoref{sec:cbm} where we showed restricted fixed-parameter tractability of \pCBMs{} with respect to the join set size.
\begin{corollary}\label{cor:wmeetractableforests}
  Let the graph~ and the weight function~ constitute an instance~ of \pWMEEs{}. Let~ be the number of connected components in~. Furthermore, 
\begin{lemenum}
\item let the set~ of allowed arcs with respect to~ not contain a path or cycle of length at least two,
\item let the underlying graph of the directed graph~ be a forest, and
\item let~ contain only vertices with balance between~ and~.
\end{lemenum}
Then, it is decidable in~~time whether~ is a yes-instance.
\end{corollary}
\begin{proof}
  Observe that such instances are invariant under \autoref{trans:sb} and \autoref{trans:spp}. Thus, we may directly apply the reduction from \pWMEEs{} to \pWMEECAs{} given in \autoref{lem:redwmeetowmeea} that runs in time~. Also, there is no valid advice that contains hints of length two for such graphs. Thus, we can apply \autoref{con:redwmeeatocbm}---running in~~time by \autoref{con:redwmeeatocbmruntime}---to map the instances of \pWMEECAs{} to instances of \pCBMs{} that comprise bipartite graphs that are forests. By \autoref{cor:cbmlintimeonforests}, these instances are solvable in linear time.
\end{proof}
\begin{corollary}\label{cor:wmeetractablecycles}

  Let the graph~ and the weight function~ constitute an instance~ of \pWMEEs{}. Let~ be the number of connected components in~. Furthermore, 
\begin{lemenum}
\item let the set of allowed arcs with respect to~ not contain a path or cycle of length at least two,
\item let~ contain only vertices with balance between~ and~,
\item let every vertex in~~(every vertex in~) have only outgoing allowed arcs (incoming allowed arcs),
\item for every connected component~ of~, let either all vertices in~ have at most two incident allowed arcs or let all vertices in~ have at most two incident allowed arcs.
\end{lemenum}
Then, it is decidable in~~time whether~ is a yes-instance.
\end{corollary}
\begin{proof}
  The proof is analogous to \autoref{cor:wmeetractableforests} by substituting the algorithm we gave in \autoref{the:cbmmaxdeg2tractable} for \autoref{cor:cbmlintimeonforests}. This leads to a running time bound of~.
\end{proof}

\subsubsection{Reducing \pCBMs{} to \pWMEEAs{}}
To reduce \pCBMs{} to \pWMEEAs{} we first observe that for every instance of \pCBMs{} there is an equivalent instance such that every cell in the input vertex-partition contains equal numbers of vertices from both cells of the graph bipartition. This observation enables us to model cells as connected components and vertices in the bipartite graph as unbalanced vertices in the designated instance of \pWMEEAs{}.

We first need the following auxiliary observations: 
\begin{observation}\label{obs:surplussum}
  Let~ be a bipartite graph such that~ and let the set~ be a partition of the vertices in~. It holds that 
\end{observation}
\begin{proof}
  Observe that the equation holds if and only if~: Without loss of generality we may assume that there are no cells~ with~ because these do contribute summands to the equation. Then we can transpose the equation such that the left-hand side reads as follows 
This is equal to~. Analogously, the left-hand side in the transposed formula is equal to~.
\end{proof}

\begin{lemma}\label{lem:cbmlegalized}
  For every instance of \pCBMs{} there is an equivalent instance comprising the bipartite graph~, the vertex partition~ and the join set~, such that
\begin{lemenum}
\item for every~ it holds that~, and\label{enu:cl11}
\item the graph~ is connected.\label{enu:cl12}
\end{lemenum}
Furthermore, this equivalent instance contains at most one cell more than the original instance.
\end{lemma}
\begin{proof}
  We first prove that there is an equivalent instance corresponding to statement~\enuref{enu:cl11} and then turn to statement~\enuref{enu:cl12}.
  Let the bipartite graph~, the weight function~, the vertex partition~ and the join set~ constitute an instance~ of \pCBMs{}. First observe that if~ is a yes-instance then~, otherwise there could not be a perfect matching. Thus, if~ we may simply output a trivial no-instance for which the statement of the lemma holds. Otherwise, by \autoref{obs:surplussum}, the following procedure can be carried out: Add a new cell~ to~ with~ vertices in~ and the same number of vertices in~, and modify the graph~ and each cell~ with~ as follows: Add the new vertices~ to~ and to the cell~, and add an edge from~ to a vertex in~ for every~ and such that every vertex in~ gets at most one incident edge. Proceed analogously for cells~ with~ by adding vertices to~ and adding corresponding edges to~. Finally, expand the weight function~ to the new edges by giving each of them weight~0.

This construction is obviously correct, since each new vertex can only be matched to its corresponding vertex in~.

Concerning statement~\enuref{enu:cl12}, assume that the statement does not hold for a instance that contains the vertex partition~ and a join set~. We greedily choose two cells~ that are in different connected components in the ``cell-join graph''~, remove them from~, add the cell~ and update~ accordingly---that is, we replace every join~ where~ by the join~. This is correct because all joins satisfied by any solution~ for the new instance are also satisfied by~ in the original instance and vice versa. Iterating the merging of cells in differ ent connected components makes the cell-join graph connected and the statement follows.
\end{proof}
\paragraph{Description of the Reduction.}
To reduce instances of \pCBMs{} that conform to statement~\enuref{enu:cl11} and~\enuref{enu:cl12} of \autoref{lem:cbmlegalized} to instances of \pWMEEAs{} we use the simple idea of modelling every cell as connected component, vertices in~ as vertices with balance~, vertices in~ as vertices with balance~, and joins as hints.
\begin{construction}\label{cons:redcbmtoeea}
  Let the bipartite graph~, the weight function~, the vertex partition~ and the join set~ constitute an instance~ of \pCBMs{} such that~ corresponds to \autoref{lem:cbmlegalized}\enuref{enu:cl11} and~\enuref{enu:cl12}.

  Let~ be a sequence of all vertices chosen alternatingly from~ and~. Define the graph~ where the arc sets~ and~ are defined as follows: . For every~ let~, set~ and define~. Define a new weight function~ for every pair of vertices~ by

Finally, derive an advice~ for~ by adding a length-one hint~ to~ for every join~ such that~ consists of the edge that connects vertices in~ that correspond to the connected components~, and~.

The graph~, the weight function~, the maximum weight~ and the advice~ constitute an instance~ of \pWMEEAs{}.
\end{construction}
\begin{theorem}\label{the:redcbmtowmeea}
  \pCBM{} is polynomial-parameter polynomial-time many-one reducible to \pWMEEA{} with respect to the parameters join set size and connected components in the input graph.
\end{theorem}
\begin{proof}
  We show that the application of \autoref{lem:cbmlegalized} and \autoref{cons:redcbmtoeea} is such a reduction. It can easily be checked that it can be carried out in polynomial time. Also, by \autoref{lem:cbmlegalized} and the definition of~ it follows that the instances of \pWMEEAs{} generated in this way have a number of connected components that is at most the size of the join set plus one.

  Assume that there is a perfect conjoining matching~ with weight at most~ for the instance~ as in \autoref{cons:redcbmtoeea}. Then, we derive an \EE{}~ for~ that heeds the advice with the same weight by simply choosing~. By the definition of~,~. Every hint is realized by~ because for every join there is an edge in~ that satisfies it. Most importantly,~ is an \EE{} for~: Since~ is perfect, every vertex in~ has exactly one arc incident in~. Since every vertex in~ has balance~ or~ (due to the definition of~), this suffices to make all vertices balanced. By \autoref{lem:cbmlegalized}\enuref{enu:cl12}, the advice~ is a connecting advice and thus~ is connected.

  Now assume that there is an \EE{}~ for~ that heeds the advice~ and has weight at most~. Choosing~ yields a perfect conjoining matching of the same weight: It holds the~, because all extension arcs that do not correspond to an edge in~ have weight~. The matching~ is perfect, because every vertex in~ (in~) has balance~ (balance~), has only incoming (outgoing) allowed arcs and thus has exactly one arc incident in~. The matching~ is conjoining, because~ heeds the advice~.
\end{proof}
The reduction given above gives rise to the following parameterized equivalence.
\begin{theorem}\label{the:cbmwmeeequiv}
  \pCBM{} and \pWMEE{} are parameterized equivalent with respect to the parameters join set size and connected components in the input graph. 
\end{theorem}
\begin{proof}
  By \autoref{lem:redwmeetowmeea} there is a parameterized reduction from \pWMEEs{} to \pWMEECAs{} with respect to the parameter number of connected components. By \autoref{the:redwmeecatocbm} there is a parameterized reduction from \pWMEECAs{} to \pCBMs{} with respect to the parameters connected components and join set size.

The other direction follows from the reduction from \pCBMs{} to \pWMEEAs{} given above in \autoref{the:redcbmtowmeea} with respect to the parameters join set size and connected components and the reduction from \pWMEEAs{} to \pWMEEs{} given in \autoref{the:redwmeeatowmee}.
\end{proof}
We also can finally prove \NPhs{} for \pWMEECAs{} which we have deferred up to now.
\begin{corollary}\label{cor:eecanph}
  \pWMEECAs{} is \NPh .
\end{corollary}
\begin{proof}
  We have proven in \autoref{the:cbmnph} that \pCBMs{} is \NPh{} via a reduction from \ptSATs{}. Observe that reducing the instances produced by the corresponding \autoref{cons:red3sattocbm} to instances of \pWMEEAs{} by \autoref{cons:redcbmtoeea} yields instances with minimal connecting advice. Thus there is a reduction from \ptSATs{} to \pWMEECAs{}.
\end{proof}
It turns out that reducing from \pWMEECAs{} to \pCBMs{} and back from \pCBMs{} to \pWMEEAs{} can be interpreted as preprocessing procedure for \pWMEECAs{}:
\begin{observation}\label{obs:redbackpreprocess}
  Successively applying \autoref{con:redwmeeatocbm} and \autoref{cons:redcbmtoeea} to an instance of \pWMEECAs{} yields an equivalent instance of \pWMEECAs{}.
\end{observation}
\begin{proof}
  Recall that in \autoref{con:redwmeeatocbm} connected components are directly modeled by cells in the vertex partition, hints of length one are directly modeled by joins and hints of length at least two by a gadget comprising of a new cell and two joins, both involving the new cell and one of the endpoints of the hint. Thus, in the corresponding instance of \pCBMs{} no join can be removed without ``disconnecting'' one of the cells from the others. Since in \autoref{cons:redcbmtoeea} cells are directly modeled by connected components and joins are directly modeled by hints, it follows that the resulting instance has minimal connecting advice.
\end{proof}
This yields the following two results.
\begin{corollary}\label{cor:eecaprobkernel}
  \pWMEECAs{} has a problem kernel with~~vertices, where~ is the sum of all positive balances and~ is the number of connected components.
\end{corollary}
\begin{proof}
  This follows by simply using \autoref{con:redwmeeatocbm} and \autoref{cons:redcbmtoeea} as preprocessing routines. Since both of them have been proven to be polynomial-time reductions in \autoref{the:redwmeecatocbm} and \autoref{the:redcbmtowmeea} they are correct. Observe that \autoref{con:redwmeeatocbm} disposes of all balanced vertices; for every hint of length at least two there are~ new vertices, which gives the bound of~~vertices in the matching instance. \autoref{cons:redcbmtoeea} does not increase the number of vertices and the statement follows.
\end{proof}
\begin{corollary}
  For every instance of \pWMEECAs{} there is an equivalent instance in which every hint has length one.
\end{corollary}
\begin{proof}
  This trivially follows from \autoref{obs:redbackpreprocess}.
\end{proof}

\section{Discussion}
We now briefly recapitulate the results of this chapter, we note what we could not achieve and we give some directions for further research.

Our considerations in this chapter originally were started with the goal in mind to find out whether \pWMEE{}~(\pWMEEs{}) is fixed-parameter tractable with respect to the parameter number~ of connected components.
Unfortunately, this aim has not been achieved yet. However, we have learned much about the structure of \EE s in \autoref{sec:trails}, and could use this knowledge to derive an efficient algorithm for \pWMEEs{} in \autoref{sec:multivariatealg}. 

In further research, a useful tool for the analysis of \pWMEEs{} with respect to the parameter~ could be the parameterized equivalent matching formulation \pCBM{}~(\pCBMs{}) we derived in this chapter, the final theorems of which are proven in \autoref{sec:releecbm}. We deem that in this formulation the sought solution is more concisely defined. This observation is partly justified by the work laid out in Sections~\ref{sec:trails} through~\ref{sec:wmeeslasha} in order to catch the structure of \EE s, which was necessary to finally derive efficient algorithms and arrive at~\pCBMs{}. Also, only considering the structure of the input graph in \pWMEEs{} may be misleading since, for instance, balanced vertices also take part in the combinatorial explosion of possible paths in \EE s. Balanced vertices, however, do not have equivalents in the corresponding matching instance. The matching formulation makes clear that the structure of allowed extension arcs defined by the weight function is of much greater importance. This is also shown in \autoref{sec:tractislands} where we showed that \pWMEEs{} is actually tractable with respect to the parameter~ for some restricted structure in the allowed arcs. There we used the fact that this structure is precisely captured by the bipartite graph in the matching instance.

Of course we did not stop when we arrived at the matching formulation. We tried multiple approaches for either showing that \pCBMs{} is fixed-parameter tractable or likely intractable with respect to the parameter join set size. However, this has not been crowned with success yet. For instance, we tried to show \claW{1}-hardness via parameterized reductions from \textsc{Multicolored Clique}~\cite{FHRV09} where a graph~, an integer~, and a coloring of the vertices is given and it is asked whether there is a clique~ with at least~ vertices in~ such that each vertex of~ has a distinct color. Here it seemed difficult to copy over the information that one vertex is in the clique from one entity representing this vertex to at least~ of the vertices' neighbors. Reductions from the well-known \textsc{Independent Set} problem suffered from a similar flaw since there it is necessary to copy the information that one vertex is in the independent set over to every neighbor. We also tried reductions from several \claM{1}-complete problems (see, for instance, \citet{FG06}) without much success. 

This led us to the assumption that the bipartite graph in \pCBMs{} and matchings in this graph are too weak to model the relationships of entities in presumably fixed-parameter intractable problems. Thus, we tried to apply some of the well-known techniques to show fixed-parameter tractability. However, we were not able to circumvent running times in the order of~ where~ is the size of the join set in these approaches. Subsuming, we are not confident with giving a conjecture on whether or not \pCBMs{} is fixed-parameter tractable. 








