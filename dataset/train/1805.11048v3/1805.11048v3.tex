\documentclass[sigconf]{acmart}

\usepackage{booktabs} 

\usepackage{algcompatible}
\usepackage{float}
\usepackage{amssymb,amsmath,amsthm,amsfonts}
\newtheorem{theorem}{Theorem}
\newtheorem{cor}{Corollary}
\newtheorem{assump}{Assumption}
\newtheorem{definition}{Definition}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{subcaption}
\usepackage{algorithm}
\usepackage{algcompatible}
\usepackage{xcolor}
\usepackage[bbgreekl]{mathbbol}
\usepackage{balance}


\newcommand{\Blue}[1]{{\color{blue}#1}}
\newcommand{\Red}[1]{{\color{red}#1}}
\newcommand{\Magenta}[1]{{\color{magenta}#1}}   
\newcommand{\R}{\mathbb{R}}
\newcommand{\W}{\mathcal{W}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\1}{\boldsymbol{1}}
\newcommand{\bb}{\boldsymbol{b}}
\newcommand{\bx}{\boldsymbol{x}}
\newcommand{\bv}{\boldsymbol{v}}
\newcommand{\bu}{\boldsymbol{u}}
\newcommand{\bz}{\boldsymbol{z}}
\newcommand{\omegab}{\boldsymbol{\omega}}
\newcommand{\phib}{\boldsymbol{\phi}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\WMD}{\text{WMD}}
\newcommand{\softmin}{\mathit{softmin}}
\newcommand{\softmax}{\mathit{softmax}}
\newcommand{\T}{\mathsf{T}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\bX}{\mathbf{X}}
\newcommand{\bW}{\mathbf{W}}
\newcommand{\bD}{\mathbf{D}}
\newcommand{\bL}{\mathbf{L}}
\newcommand{\bZ}{\mathbf{Z}}
\newcommand{\bU}{\mathbf{U}}
\newcommand{\bV}{\mathbf{V}}
\newcommand{\bI}{\mathbf{I}}
\newcommand{\bM}{\mathbf{M}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\bUh}{\widehat{\bU}}
\newcommand{\bMh}{\widehat{\bM}}
\newcommand{\cMh}{\widehat{\cM}}
\newcommand{\bK}{\mathbf{K}}
\newcommand{\bPhi}{\mathbf{\Phi}}
\newcommand{\tr}{\textnormal{trace}}
\newcommand{\cC}{\mathcal{C}}

\newcommand{\bdelta}{\boldsymbol{\delta}}
\newcommand{\bphi}{\boldsymbol{\phi}}
\newcommand{\phibar}{\bar{\phi}}
\newcommand{\bphibar}{\boldsymbol{\bar{\phi}}}
\newcommand{\z}{\boldsymbol{z}}
\newcommand{\zb}{\bar{\boldsymbol{z}}}
\newcommand{\0}{\boldsymbol{0}}















\begin{document}
\title{Scalable Spectral Clustering Using Random Binning Features}




\author{Lingfei Wu}
\affiliation{\institution{IBM Research AI}}
\email{wuli@us.ibm.com}

\author{Pin-Yu Chen}
\affiliation{\institution{IBM Research AI}}
\email{pin-yu.chen@ibm.com}

\author{ Ian En-Hsu Yen}
\affiliation{\institution{Carnegie Mellon University}}
\email{eyan@cs.cmu.edu}

\author{Fangli Xu }
\affiliation{\institution{College of William and Mary}}
\email{fxu02@email.wm.edu}

\author{Yinglong Xia}
\affiliation{\institution{Huawei Research}}
\email{yinglong.xia.2010@ieee.org}

\author{Charu Aggarwal}
\affiliation{\institution{IBM Research AI}}
\email{charu@us.ibm.com}

\renewcommand{\shortauthors}{Lingfei Wu, Pin-Yu Chen, Ian En-Hsu Yen, et al.}


\begin{abstract}
Spectral clustering is one of the most effective clustering approaches that capture hidden cluster structures in the data. However, it does not scale well to large-scale problems due to its quadratic complexity in constructing similarity graphs and computing subsequent eigendecomposition. Although a number of methods have been proposed to accelerate spectral clustering, most of them compromise considerable information loss in the original data for reducing computational bottlenecks. In this paper, we present a novel scalable spectral clustering method using \emph{Random Binning features} (RB) to simultaneously accelerate both similarity graph construction and the eigendecomposition. Specifically, we  implicitly approximate the graph similarity (kernel) matrix by the inner product of a large sparse feature matrix generated by RB. Then we introduce a state-of-the-art SVD solver to effectively compute eigenvectors of this large matrix for spectral clustering. Using these two building blocks, we reduce the computational cost from quadratic to linear in the number of data points while achieving similar accuracy. Our theoretical analysis shows that spectral clustering via RB converges faster to the exact spectral clustering than the standard Random Feature approximation. Extensive experiments on 8 benchmarks show that the proposed method either  outperforms or matches the state-of-the-art methods in both accuracy and runtime. Moreover, our method exhibits linear scalability in both the number of data samples and the number of RB features.
\end{abstract}

\copyrightyear{2018} 
\acmYear{2018} 
\setcopyright{acmlicensed}
\acmConference[KDD '18]{The 24th ACM SIGKDD International Conference on Knowledge Discovery \& Data Mining}{August 19--23, 2018}{London, United Kingdom}
\acmBooktitle{KDD '18: The 24th ACM SIGKDD International Conference on Knowledge Discovery \& Data Mining, August 19--23, 2018, London, United Kingdom}
\acmPrice{15.00}
\acmDOI{10.1145/3219819.3220090}
\acmISBN{978-1-4503-5552-0/18/08}

\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10010147.10010178</concept_id>
<concept_desc>Computing methodologies~Artificial intelligence</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10010147.10010257</concept_id>
<concept_desc>Computing methodologies~Machine learning</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10010147.10010257.10010258.10010260</concept_id>
<concept_desc>Computing methodologies~Unsupervised learning</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10010147.10010257.10010258.10010260.10003697</concept_id>
<concept_desc>Computing methodologies~Cluster analysis</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computing methodologies~Artificial intelligence}
\ccsdesc[500]{Computing methodologies~Machine learning}
\ccsdesc[500]{Computing methodologies~Unsupervised learning}
\ccsdesc[500]{Computing methodologies~Cluster analysis}

\keywords{Spectral clustering; Graph Construction; Random Binning Features; Large-Scale Graph; PRIMME}

\maketitle

\section{Introduction}
Clustering is one of the most fundamental problems in machine learning and data mining tasks. In the past two decades, spectral clustering (SC) \cite{shi2000normalized,ng2002spectral,von2007tutorial,chen2017revisiting} has shown great promise for learning hidden cluster structures from data. The superior performance of SC roots in exploiting non-linear pairwise similarity between data instances, while traditional methods like K-means heavily rely on Euclidean geometry and thus place limitations on the shape of the clusters \cite{fowlkes2004spectral,yan2009fast,chen2016phase}. However, SC methods are typically not the first choice for large-scale clustering problems since modern datasets exhibit great challenges in both computation and memory consumption for computing the pairwise similarity matrix , where  denotes the number of data points. In particular, given a data matrix  whose underlying data distribution can be represented as   weakly inter-connected clusters, it requires  space to store the matrix and  complexity to compute , and at least takes  or  complexity to compute  eigenvectors of the corresponding graph Laplacian matrix , depending on whether an iterative or a direct eigensolver is used. To accelerate SC, many efforts have been devoted to address the following computational bottlenecks: 1) pairwise similarity graph construction of  from the raw data , and 2) eigendecomposition of  the graph Laplacian matrix . 

A number of methods have been proposed to accelerate the eigendecomposition, e.g.,  randomized sketching and power method \cite{gittens2013approximate,lin2010power},  sequential reduction algorithm toward an early-stop strategy \cite{chen2006fast,liu2007fast}, and graph filtering of random signals \cite{tremblay2016compressive}. However,  these approaches only partially reduce the computation cost of the eigendecomposition, since the construction of similarity graph matrix  still requires quadratic complexity for both computation and memory consumption. 

Another family of research is the use of Landmarks or representatives to jointly improve the computation efficiency of the similarity matrix  and the eigendecomposition of . One strategy is performing random sampling or K-means on the dataset to select a small number of representative data points and then employing SC on the reduced dataset \cite{yan2009fast,shinnou2008spectral}. Another strategy \cite{sakai2009fast,chen2011large,liu2013large,li2016scalable} is approximating the similarity matrix  by a low rank affinity matrix , which is computed via either random projection or a bipartite graph between all data points and selected anchor points \cite{liu2010large}. Furthermore, a heuristic that only selects a few nearest anchor points has been applied to build a KNN-based sparse graph similarity matrix. Despite promising results in accelerating SC, these approaches disregard considerable information in the raw data and may lead to degrading clustering performance. More importantly, there is no guarantee that these heuristic methods can approach the results of standard SC.

Another line of research \cite{fowlkes2004spectral,chitta2012efficient,chitta2011approximate,wu2018d2ke,wu2018random} focuses on leveraging various kernel approximation techniques such as Nystr{\"o}m  \cite{williams2001using}, Random Fourier \cite{rahimi2008random,wu2016revisiting,chen2016efficient}, and random sampling to accelerate similarity matrix construction and the eigendecomposition at the same time. The pairwise similarity (kernel) matrix  (a weighted fully-connected graph) is then directly approximated by an inner product of the feature matrix  computed from the raw data. Although a KNN-based graph construction allows efficient sparse representation, pairwise method takes full advantage of more complete information in the data and takes into account the long-range connections \cite{fowlkes2004spectral,chen2011parallel}. The drawback of pairwise methods is the high computational costs in requiring the similarity between every pair of data points. Fortunately, we present an approximation technique applicable to SC that significantly alleviates this computational bottleneck. As our work focuses on enabling the scalability of SC using RB, the case of robust spectral clustering on noisy data, such as \cite{bojchevski2017robust}, 
could be applied but is beyond the scope of this paper.

In this paper, inspired by recent advances in the fields of kernel approximation and numerical linear algebra \cite{rahimi2008random,wu2016revisiting,wu2015preconditioned,wu2017primme_svds,chen2018incremental}, we present a scalable spectral clustering method and theoretic analysis to circumvent the two computational bottlenecks of SC in large-scale datasets. We highlight the following main contributions:

\begin{enumerate}
\item  We present for the first time the use of \emph{Random Binning features} (RB) \cite{rahimi2008random,wu2016revisiting} for scaling up the graph construction of similarity matrix in SC, which is implicitly approximated by the inner product of the RB sparse feature matrix  derived from the raw dataset, where each row has . To this end, we reduce the computational complexity of the pairwise graph construction from  to  and memory consumption from  to . 

\item We further show how to make full use of state-of-the-art near-optimal eigensolver PRIMME \cite{stathopoulos2010primme,wu2017primme_svds} to  efficiently compute the eigenvectors of the corresponding graph Laplacian  without explicit formulation. As a result, the computational complexity of the eigendecomposition is reduced from  to , where  is the number of iterations of the underlying eigensolver.  

\item We extend existing analysis of random features to SC from the optimization perspective \cite{wu2016revisiting}, showing a number {} of RB features suffices for the uniform convergence to  precision of the exact SC.

\item In our extensive experiments on 8 benchmark datasets evaluated by 4 different clustering metrics, the proposed technique either outperforms or matches the state-of-the-art methods in both accuracy and computational time. 

\item We corroborate the scalability of our method under two cases: varied number of data samples  and varied number of RB features . In both cases, our method exhibits linear scalability with respect to  or .

\end{enumerate}




\section{Spectral Clustering and Random Binning}
We briefly introduce the SC algorithms and then illustrate RB, an important building block to our proposed method. Here are some notations we will use throughout the paper.

\subsection{Spectral Clustering}
Given a set of  data points , with  , the SC algorithm constructs a similarity matrix  representing an affinity matrix , where the node  represents the data point  and the edge  represents the similarity between   and . 

The goal of SC is to use  to partition  into  clusters. There are several variants of SC. Without lose of generality, we consider the widely used \emph{normalized spectral clustering} \cite{ng2002spectral}. To fully utilize complete similarity information, we consider a fully connected graph instead of a KNN-based graph for SC. An example similarity (kernel) function is the Gaussian Kernel:

where  is the bandwidth parameter. The normalized graph Laplacian matrix  is defined as: 

where  is the degree matrix with each diagonal element . The objective function of normalized SC can be defined as \cite{shi2000normalized}:

where  denotes the matrix trace,
 denotes the identity matrix, and the constraint  implies orthonormality on the columns of . We further denote  as the optimizer of the minimization problem in (\ref{eq:sc_trace_min}), where the columns of  are the  smallest eigenvectors of . Finally, the K-means method is applied on the rows of  to obtain the clusters. The high computational costs of the similarity matrix  and the eigendecomposition  make SC   hardly scalable to large-scale problems. 

\subsection{Random Binning Features}
RB features are first introduced in \cite{rahimi2008random} and rediscovered in \cite{wu2016revisiting} to yield a faster convergence compared to other \emph{Random Features} methods for scaling up large-scale kernel machine. It considers a feature map of the form

where a set of bins  defines a random grid that are determined by  drawn from a distribution , and  represents \emph{width} and \emph{bias} in the -th dimension of a grid. Then for any bin , the feature vector  has
 
if the data point  locates in the bin . Since a data point can only locate in one bin,  for any other bins. 
Note for each grid  the number of bins  is countably infinite, therefore  has infinite dimensions but only  non-zero entry (at the bin  lies in). 
Figure \ref{fig:RB_gen} illustrates an RB example when the data dimension .
When two data points ,  fall in the same bin, the \emph{collision probability} for this to happen is proportional to the kernel value . Note that for a given grid multiple non-empty bins (features) can be produced and thus RB essentially generates a large sparse binary matrix (for more details, please refer to \cite{wu2016revisiting}). 


In practice, in order to obtain a good kernel approximation matrix , a simple Monte Carlo method is often leveraged to approximate \eqref{RB_feature_map} by averaging over  grids , where each grid's parameter  is drawn from . Algorithm \ref{alg:RB} summarizes the procedure for generating a number  of RB features from the original dataset . The resulting feature matrix , where  is determined jointly by both the number of grids  and the kernel parameter . However, for each row the number of nonzero entries  and thus the total number of , which is the same as other random feature methods \cite{wu2016revisiting}.


\begin{figure}
    \centering
    \includegraphics[scale=0.28]{graphs/RB2.pdf}
\caption{Example of generating  RB features when .}
    \label{fig:RB_gen}
\end{figure}

\begin{algorithm}[t]
    \caption{ RB Features Generation}
    \label{alg:RB}
    \begin{algorithmic}[1]
    \STATEx {\bf Input:}  Given a kernel function . Let  be a distribution over .
    \STATEx {\bf Output:} RB feature matrix  for raw data 
    \FOR {}
        \STATE Draw  from  and , for  
        \STATE Compute feature values  as the indicator vector of bin index , for .
    \ENDFOR
    \STATE , for 
    \end{algorithmic}
\end{algorithm}


\section{Scalable Spectral Clustering Using RB Features} \label{sec: scalable sc_rb}
In this section, we introduce our proposed scalable SC method, called SC\_RB, based on RB and a state-of-the-art sparse eigensolver (PRIMME) to effectively tackle the two computational bottlenecks: 1) Pairwise graph construction; and 2) Eigendecomposition of the graph Laplacian matrix.

\subsection{Pairwise graph construction}
The first step of SC is to build a similarity graph. A fully connected graph entailing complete similarity information of the original data offers great flexibility in the underlying kernel function to define the affinities between data points. However, constructing a pairwise graph essentially computes a similarity (kernel) matrix between each pair of samples, which is computationally intensive due to its quadratic complexity . Thus, we propose to use RB features  to approximate the pairwise kernel matrix , resulting in the following approximate spectral clustering objective:

where 

and  is a large sparse  matrix generated from Algorithm \ref{alg:RB}. To apply RB to SC, it is necessary to compute the degree matrix , the row sum of . Luckily, we can compute it without explicitly computing  since
 
where  is a diagonal matrix with the vector  on its main diagonal, and  represents a column vector of ones. Therefore, we can simply compute  by two matrix-vector multiplication without the explicit form of . With , we define  and thus we approximate the graph Laplacian matrix with  in linear complexity.  

\subsection{Effective eigendecomposition using PRIMME}
After constructing the pairwise graph implicitly using , we compute the largest left singular vectors of , which is equivalent to computing the smallest eigenvectors of  in Equation \eqref{eq:sc_rb}, satisfying 

where the singular values are labeled in descending order, . The matrices  and  are the left and right singular vectors respectively, where  is the low-dimensional embedding associated with  clusters. 

However, , a weighted RB feature matrix of , is a very large sparse matrix of the size , making it a challenging task for any standard SVD solver. Specifically, one has to resort to a powerful iterative sparser eigensolver that is capable to handle two difficulties for large-scale matrix: 1) slow convergence of eigenvalues when the eigenvalue gaps are not well separated, a common case when  is large; 2) low memory footprint yet near-optimal convergence for seeking a small number of eigenpairs. 

To overcome these challenges, we leverage current state-of-the-art eigenvalue and SVD solver \cite{stathopoulos2010primme,wu2017primme_svds}, named PReconditioned Iterative MultiMethod Eigensolver (PRIMME). It implements two near-optimal eigenmethods GD+K and JDQMR that are default methods for seeking a small portion of extreme eigenpairs under limited memory. Unlike Lanczos methods (like Matlab svds function), these eigenmethods are in the classes of Generalized Davidson, which enjoy benefits for advanced subspace restarting and preconditioning techniques to accelerate the convergence.   

Once the left singular vectors  are obtained, following  \cite{ng2002spectral}, we obtain  by normalizing each row of  to unit norm. Then K-means method is applied to the rows of  to obtain the final  clusters and the binary membership matrix . 

\begin{algorithm}[t]
    \caption{ Scalable SC method based on RB}
    \label{alg:sc_rb}
    \begin{algorithmic}[1]
    \STATEx {\bf Input:}  Data matrix ,  number of clusters , number of girds , kernel parameter .
    \STATEx {\bf Output:} K clusters and membership matrix 
    \STATE Construct a fully connected graph using a sparse feature matrix  generated by RB using Algorithm \ref{alg:RB}.
    \STATE Compute degree matrix  using Equation \ref{eq:sc_rb_computeD} and obtain  using Equation \ref{eq:sc_rb}.
    \STATE Compute  largest left singular vectors  of  using state-of-the-art iterative sparse SVD solver  (e.g., PRIMME).
    \STATE Obtain the matrix  from  by row normalization.
    \STATE Cluster the rows of  into  clusters using K-means and obtain the corresponding membership matrix .
    \end{algorithmic}
\end{algorithm}

\textbf{Computation analysis.} Algorithm \ref{alg:sc_rb} summarizes the procedure for the proposed scalable SC method based on RB and PRIMME. Using these two important building blocks, the computational complexity has been substantially reduced from  to  for computing the feature matrix  from RB in pairwise graph construction, and from at least  to  for the subsequent SVD computation, where  is the number of iterations of the underlying SVD solver. At the same time, the memory consumption has been reduced from  to . In addition to these two key steps, the final K-means also takes , where  is the number of iterations of K-means. Therefore, the total computational complexity and memory consumption are  and . The linear complexity in the number  of data points render SC scalable to large-scale problems.


\section{Theoretical Analysis}
The convergence of Random Feature approximation has been studied since it was first proposed in \cite{rahimi2008random}, where a sampling approximation analysis was employed to show the convergence of the approximation to exact kernel. Such analysis was adopted by most of its follow-up works. More recently, a new approach of analysis based on infinite-dimensional optimization is proposed in \cite{yen2014sparse}, which achieves a faster convergence rate than the previous approach, and was employed further in \cite{wu2016revisiting} to explain the superior convergence of \emph{Random Binning Features} than other types of random features in the context of classification.

Here we further adapt the analysis in \cite{wu2016revisiting} to study the convergence of Spectral Clustering under RB approximation. We first recall the well-known connection between \emph{SC} and \emph{kernel -means} \cite{dhillon2004kernel}, stating the equivalence of \eqref{eq:sc_trace_min} to the following objective

where  is a possibly infinite-dimensional feature map in \eqref{RB_feature_map} from the normalized kernel,  is the matrix of \emph{means} with  columns, each of which has the same dimension to the feature map . Dropping constants that are neither related to  nor related to , the objective \eqref{kernel_K-means} becomes

Let  be the clustering from the RB approximation:

Let  be the exact minimizer of \eqref{kernel_output}. Our goal is to show that 

as long as the number of Random Binning grids satisfies , where  is an estimate of the number of non-empty bins per grid. The quantity  is crucial in the our analysis, as under the same computational budget, RB generates  more features in expectation and converges \emph{-times faster} than other types of random features. Note the computational cost is not -times more because of the sparse structure of RB---only one of  features is non-zero for each sample . The formal definition of  is as follows.

\begin{definition}\label{def:collision_prob}
Define the collision probability of data  on bin  as: 

Let  be an upper bound on \eqref{collision_prob}, and  be a lower bound on the number of non-empty bins of grid . Then

is the expected number of non-empty bins.
\end{definition}

The proof of \eqref{result} contains two parts. In the first part, we show that  for any given . This is obtained from the insight that the RB approximation  (from Algorithm \ref{alg:RB}) is a subset of coordinates from the feature map . Therefore,  can be interpreted as a solution obtained from  iterations of \emph{Randomized Block Coordinate Descent} on  w.r.t. , which results in  non-zero blocks of rows in .

\begin{theorem}\label{thm:RBconverge}
Let  be the number of grids generated by Algorithm \ref{alg:RB}. For any given , let  and  be the minimizers of \eqref{kernel_K-means} and \eqref{alg_output} respectively. We have

for , where  is a small constant.
\end{theorem}
\begin{proof}
Let . Given  that satisfies , the objective  can be written as

where  is defined as

In other words, given ,  can be separated as  independent subproblems, each solving a column of . Let the first term of \eqref{ERM} be the loss function and the second term be the regularizer. Then \eqref{ERM} satisfies the form of a convex, smooth empirical loss minimization problem studied in \cite{wu2016revisiting}. By Theorem 1 of \cite{wu2016revisiting}, the minimizer of \eqref{ERM} satisfies

with . Summing \eqref{result_per_k} over , we have

where .
\end{proof}

Theorem \ref{thm:RBconverge} implies that  for

As noted by the earlier work \cite{wu2016revisiting}, this convergence rate is  times faster than that of other Random Features under the same analysis framework. More specifically, if applying Theorem 2 of \cite{yen2014sparse} instead of Theorem 1 of \cite{wu2016revisiting} in the proof of Theorem \ref{thm:RBconverge}, one would have obtained a -times slower convergence rate for a general Random Feature method that generates a single feature at a time, which requires

number of features to guarantee an  suboptimality. This is owing to RB's ability to generate a block of  expected number of features at a time. 

In the second part of the proof, we show that the spectral clustering  obtained from the RB approximation converges to  in the objective.

\begin{theorem}\label{thm:SCconverge}
Let  be the number of grids generated by Algorithm \ref{alg:RB}, and let ,  be the spectral clusterings obtained from \eqref{kernel_K-means}, \eqref{alg_output} respectively. We have

for

where  is a small constant (defined in Theorem \ref{thm:RBconverge}).
\end{theorem}
\begin{proof}
Note the problem \eqref{alg_output} can be solved with global optimal guarantee by finding minimum eigenvalues and eigenvectors of \eqref{eq:sc_rb}. Therefore, let ,  be the minimizers of \eqref{alg_output} under ,  respectively. We have

by the optimality of  under the approximate feature map . In addition, from Theorem \ref{thm:RBconverge} we have

for . Combining \eqref{thm2_tmp1} and \eqref{thm2_tmp2} leads to the result.
\end{proof}


\section{Experiments}
We conduct experiments to demonstrate the effectiveness and efficiency of the proposed method, and compare against 8 baselines on 8 benchmarks. Our code \footnote{https://github.com/IBM/SpectralClustering\_RandomBinning} is implemented in Matlab and we use C Mex functions for computationally expensive components of RB \footnote{https://github.com/teddylfwu/RandomBinning} and of PRIMME eigensolver \footnote{https://github.com/primme/primme}. All computations are carried out on a linux machine with Intel Xeon CPU at 3.3GHz for a total of 16 cores and 500 GB main memory. 
\begin{table}[htbp]
\centering
\caption{Properties of the datasets.} 
\vspace{0mm}
\label{tb: info of datasets}
\begin{center}
    \begin{tabular}{ c c c c}
    \hline
    Name 		 & : Classes & : Features & : Samples \\ \hline 
    pendigits 	 & 10  & 16  & 10,992 \\
    letter       & 26 & 16 & 15,500 \\
    mnist        & 10 & 780 & 70,000  \\ 
    acoustic     & 3  & 50 & 98,528  \\ 
    ijcnn1 		 & 2  & 22  & 126,701 \\ 
    cod\_rna     & 2  & 8  & 321,054  \\
    covtype-mult & 7  & 54 & 581,012 \\ 
    poker        & 10 & 10 & 1,025,010 \\ \hline
    \end{tabular}
\end{center}
\end{table}

\textbf{Datasets.} As shown in Table 1, we choose 8 datasets from LibSVM \cite{chang2011libsvm}, where 5 of them overlap with the datasets used in \cite{yan2009fast,li2016scalable,chen2011large}. We summarize them as follows:

1) \textbf{pendigits.} A collection of handwritten digit data set consisting of 250 samples from 44 writers where sampled coordination information are used to generate 16 features per sample;

2) \textbf{letter.} A collection of images for 26 capital letters in the English alphabet where 16 character image features are generated; 

3) \textbf{minst.} A popular collection of handwritten digit data set distributed by Yann LeCun, where each image is represented by a 784 dimensional vector; 

4) \textbf{acoustic.} A collection of time-series data from various sensors in the moving vehicles for measuring the acoustic modality where a 50 dimensional feature vector is generated by using FFT for each time-series; 

5) \textbf{ijcnn1.} A collection of time-series data from IJCNN 2001 Challenge, where 22 attributes are generated as a feature vector; 

6) \textbf{cod\_rna.} A collection of non-coding RNA sequences, where the total 8 features are generated by counting the frequencies of 'A', 'U', 'C' of sequences 1 and 2 as well as the length of the shorter sequence and deltaG\_total value;

7) \textbf{covtype-mult.} A collection of samples for predicting the forest cover type from cartographic variables, where the total 54 feature vector is generated for representing a sample;

8) \textbf{poker.} A collection of poker record samples where each hand consisting of five playing cards drawn from a standard deck of 52 generates a feature vector of 10 attributes.

\begin{table*}[t]
\centering
\caption{Average rank scores comparing SC\_RB against others methods using .}
\vspace{0mm}
\label{tb:ave_rank_alldata}
\newcommand{\Bd}[1]{\textbf{#1}}
\begin{center}
    \begin{tabular}{ c c c c c c c c c c}
    \hline
    Dataset & K-means & SC & KK\_RS & KK\_RF & SV\_RF & SC\_LSC & SC\_Nys & SC\_RF & SC\_RB \\ \hline 
    pendigits  & 3.00 & 4.75 & 2.00 & 7.75 & 8.5 & \Bd{1.00} & 4.75 & 7.25 & 5.00 \\ 
    letter	 & 8.50 & 5.75 & 5.50 & 7.50 & 4.75 & 3.25 & 4.75 & 3.75 & \Bd{1.25} \\ 
    mnist	& 5.00 & 4.25 & 5.00 & 9.00 & 8.00 & \Bd{1.00} & 3.25 & 6.75 & 2.75 \\ 
    acoustic  & 4.75 & -- & 4.25 & 6.25 & 5.75 & 3.50  & 4.75 & 5.75 & \Bd{1.00} \\ 
    ijcnn1  & 4.50 & -- & 5.75 & 2.00 & 4.00 & 6.75  & 4.75 & 7.25 & \Bd{1.00} \\ 
    cod\_rna  & 5.75 & -- & 3.50 & 5.00 & 7.75 & 5.50 & 4.00 & 2.75 & \Bd{1.75} \\ covtype-mult  & 3.75 & -- & 5.25 & 5.75 & 6.50 & 2.50 & 4.75 & 5.75 & \Bd{1.75} \\ poker  & 4.33 & -- & 4.00 & \Bd{3.33} & 4.67 & 5.67 & 5.00 & 4.33 & 4.67  \\ \hline
    \end{tabular}
\end{center}
\end{table*}


\begin{table*}[t]
\centering
\caption{Computational time (seconds) comparing SC\_RB against others methods using .}
\vspace{0mm}
\label{tb:runtime_alldata}
\newcommand{\Bd}[1]{\textbf{#1}}
\begin{center}
    \begin{tabular}{ c c c c c c c c c c}
    \hline
    Dataset & K-means & SC & KK\_RS & KK\_RF & SV\_RF & SC\_LSC & SC\_Nys & SC\_RF & SC\_RB \\ \hline 
    pendigits  & 0.8 & 25.0 & 10.7 & 10.4 & 1.0 & 7.6 & 2.5 & 1.4 & 1.8 \\ 
    letter	 & 5.9 & 171.4 & 17.1 & 36.9 & 8.9 & 27.1 & 14.6 & 10.0 & 7.7 \\ 
    mnist	& 278.1 & 2661 & 79.1 & 312.4 & 22.6 & 25.5 & 31.0 & 20.5 & 25.9 \\ 
    acoustic  & 10.2 & -- & 34.7 & 83.7 & 6.3 & 16.7  & 20.1 & 7.0 & 10.7 \\ 
    ijcnn1  & 4.2 & -- & 44.2 & 89.6 & 5.1 & 9.9  & 18.5 & 5.5 & 34.7 \\ 
    cod\_rna  & 6.7 & -- & 88.2 & 190.0 & 8.6 & 8.9 & 46.8 & 13.0 & 24.2 \\ 
    covtype-mult  & 60.7 & -- & 180.2 & 220.0 & 40.5 & 181.1 & 99.1 & 41.5 & 1593 \\ 
    poker  & 102.4 & -- & 363.1 & 5812 & 254.5 & 337.4 & 340.6 & 293.3 & 538.4  \\ \hline
    \end{tabular}
\end{center}
\end{table*}


\textbf{Baselines.} We compare against 8 random feature based SC or approximation SC methods:

1) \textbf{SC\_Nys} \cite{fowlkes2004spectral}: a fast SC method based on Nystr{\"o}m method; 

2) \textbf{SC\_LSC} \cite{chen2011large}: approximate SC for KNN-based bipartite graph between raw data and anchor points selected by K-means;

3) \textbf{SV\_RF} \cite{chitta2012efficient}: fast kernel K-means using singular vectors of the RF feature matrix (approximating similarity matrix ); 

4) \textbf{SC\_RF}: we modify SV\_RF method to become a fast SC method based on RF feature matrix (approximating Laplacian matrix ); 

5) \textbf{KK\_RF} \cite{chitta2012efficient}: another kernel K-means approximation method directly using the RF feature matrix; 

6) \textbf{KK\_RS} \cite{chitta2011approximate}: an approximate Kernel K-means by a random sampling approach; 

7) \textbf{SC} \cite{ng2002spectral}: Exact SC method; 

8) \textbf{K-means} \cite{hartigan1979algorithm}: standard K-means method applied on original dataset. 

\textbf{Evaluation metrics.} We use 4 commonly used clustering metrics for cluster quality evaluation, which has been advocated and discussed in \cite{zaki2014data}.
Let   and  denote the   clusters found by a clustering algorithm and the true cluster labels, respectively. The considered clustering metrics are: 

1) \textbf{Normalized mutual information (NMI)}: 
 
where  is the mutual information between  and , and  is the entropy of clusters.

2) \textbf{Rand index (RI)}: 
 
where , ,  and  represent true positive, true negative, false positive, and false negative decisions, respectively. 

3) \textbf{F-measure (FM)}: 
 
where , and  and  are the precision and recall values for cluster .

4) \textbf{Accuracy (Acc)}: 

where  is the total number of samples and the best mapping function  is the delta function that equals 1 if  and equals 0 otherwise between cluster labels  and the true labels  for each sample. 

These metrics are all scaled between 0 and 1, and higher value means better clustering.

\textbf{Average rank score.} To combine multiple clustering metrics for performance evaluation of different SC methods, we adopt the methodology proposed in \cite{yang2015defining} and use the average rank score of all clustering metrics as the final performance metric. Therefore, lower average rank score means better clustering performance.

\textbf{Parameter selection.} We use the RBF kernel for all similarity (Kernel) based methods on all datasets, where the kernel parameter  is obtained through cross-validation within typical range [0.01 100]. All methods use the same kernel parameters to promote a fair comparison. For other parameters, we use the recommended settings in the literature. 


\subsection{Clustering accuracy and computational time on all datasets}

\textbf{Setup.} We first compare against 8 aforementioned baselines in terms of both average rank score and computational time. We use the methodology proposed in \cite{yang2015defining} to compute the average ranking score among 4 different metrics NMI, RI, FM, and Acc. Although the rank  has different meanings in each method but similar effects on the performance, we choose  for all methods to promote a fair comparison. In addition, we use PRIMME\_SVDS to accelerate SVD decomposition for all methods except SC\_LSC. For the final step of SC, we use Matlab's internal K-means function with 10 replicates. All methods use same random seeds so the difference caused by randomness is minimized. 

\textbf{Results.} Table \ref{tb:ave_rank_alldata} shows that SC\_RB consistently outperforms or matches state-of-the-art SC methods in terms of average ranking score on 5 out of 8 datasets (except pendigits, mnist, poker). The first highlight in the table is that SC\_LSC has quite good performance in the majority of datasets, especially for pendigits and mnist, owing to the sparse low rank approximation using AnchorGraph technique \cite{liu2010large}. However, we would like to point out that in SC\_LSC the similarity matrix is built on a KNN-based graph, which is essentially different from other SC methods which use a fully connected graph. This explains why SC\_LSC has even better performance than the exact SC method in these two datasets. For poker, all methods have very close numbers in four different metrics, which leads to quite similar average ranking score for all methods. Secondly, the SC type methods such as SC\_Nys, SC\_RF, and SC\_RB generally achieve better ranking scores compared to similarity-based on methods such as KK\_RF and SV\_RF. This is because the SC type methods are built on a Normalized Cuts formulation that yields a better performance guarantee in terms of the graph clustering. Finally, the improved performance of SC\_RB in the majority of datasets stems from the fact that it directly approximate a pairwise similarity matrix, which utilizes all information from the raw data. Its faster convergence allows it to retrieve more information with a similar rank  compared to other methods. 

Table \ref{tb:runtime_alldata} illustrates that SC\_RB can achieve similar computational time to the other methods despite of a very large sparse matrix generated from RB, due to an important factor - near-optimal eigensolver PRIMME.
One should not be surprised that the empirical runtime of various scalable SC methods has relatively large range of differences. It is because that the constant factor in the computation complexity may vary with different datasets but the total computational costs are still bounded by . This constant factor typically depends on different characteristics of various datasets and specific method. For instance, KK\_RF often needs more computational time than other methods since it needs firstly compute a dense feature matrix  of  size and applied K-means directly on . When  is relatively large, the computation of K-means requiring  complexity may start dominating the total complexity, which is observed in the Table \ref{tb:runtime_alldata}. Similarly, the computational time on covtype-mult with SC\_RB is substantially heavier than those of other methods since the eigenvalues of the corresponding Laplacian matrix is very clustered making the number of iterations  much more than the usual (typically 10 - 100 iterations) in other cases. Nevertheless, both complexity analysis and empirical runtime corroborate that SC\_RB is computationally as efficient as other random features based SC methods and approximation Kernel K-means methods in most of cases. 


\subsection{Effects of RB on runtime and convergence}

\begin{figure}[!htb]
\centering
	  \begin{subfigure}[b]{0.23\textwidth}
      \includegraphics[width=\textwidth]{graphs/Accu_runtime_varyingR/mnist_SC_Accu_VaryingR2.pdf}
      \caption{Accuracy (Acc)}
      \label{fig:Accu_varyingR_mnist}
      \end{subfigure}
	  \begin{subfigure}[b]{0.23\textwidth}
      \includegraphics[width=\textwidth]{graphs/Accu_runtime_varyingR/mnist_SC_Runtime_VaryingR2.pdf}
      \caption{Runtime}
      \label{fig:Runtime_varyingR_mnist}
      \end{subfigure}
\caption{Clustering accuracy and runtime when varying  on mnist for random features based SC methods.}
 \vspace{0mm}
\label{fig:Accu_runtime_varyingR_mnist}
\end{figure}

\begin{figure}[!htb]
\centering
	  \begin{subfigure}[b]{0.23\textwidth}
      \includegraphics[width=\textwidth]{graphs/primmesvds_vs_svds/covtype-mult_SC_Accu_VaryingR_PRIMMESVDS_SVDS2.pdf}
      \caption{Accuracy (Acc)}
      \label{fig:Accu_varyingR_covtype-mult}
      \end{subfigure}
	  \begin{subfigure}[b]{0.23\textwidth}
      \includegraphics[width=\textwidth]{graphs/primmesvds_vs_svds/covtype-mult_SC_Runtime_VaryingR_PRIMMESVDS_SVDS2.pdf}
      \caption{Runtime}
      \label{fig:Runtime_varyingR_covtype-mult}
      \end{subfigure}
\caption{Clustering accuracy and runtime when varying  on covtype-mult using PRIMME\_SVDS and Matlab SVDS.}
 \vspace{0mm}
\label{fig:Accu_runtime_varyingR_covtype-mult}
\end{figure}

\textbf{Setup.} 
The first goal here is to investigate the scalability of SC\_RB over the vanilla SC method in terms of runtime while achieving the similar performance. The second goal is to study the behavior of various scalable SC and approximate Kernel K-means methods based on different random features. We limit our comparisons among two random features (RF and RB) based SC or Kernel K-means type methods.  
We choose the mnist dataset since it has been widely studied for  convergence analysis of approximation in the literature \cite{chitta2012efficient,chen2011large,li2016scalable}. We report runtime and commonly used Accuracy (Acc) as our measurement metric when varying the rank  from 16 to 4096 (except SC\_RB from 16 to 1024).

\textbf{Results.}
We investigate how the performance of different methods changes when the number  of random features (RF and RB) increases from 16 to 4096. 
Fig. \ref{fig:Runtime_varyingR_mnist} illustrates that despite a large sparse feature matrix generated by RB, the computational time of SC\_RB is orders of magnitudes less expensive compared to that of exact SC, and is comparable to other SC methods based on RF features. This is the desired feature of SC\_RB that it can achieve higher accuracy than other efficient SC methods without comprising the computation time. 
As shown in Fig. \ref{fig:Accu_varyingR_mnist}, we can see that the clustering accuracy (Acc) of all methods generally converge to that of exact SC but with different convergence rates. More importantly, SC\_RB yields faster convergence compared to other scalable SC methods based on RF features, which confirms our analysis in Theorem \ref{thm:SCconverge}. For instance, SC\_RB with  has already reached the same accuracy as the exact SC method while SC\_RF converges relatively slower to the exact SC and get close to SC with . Interestingly, SV\_RF and KK\_RF are not competitive in Accuracy, indicating that approximating the graph Laplacian matrix  is more beneficial than these that approximating the similarity matrix  in some cases.

\subsection{Effects of SVD solvers on runtime}

\begin{figure}[!htb]
\centering
	  \begin{subfigure}[b]{0.23\textwidth}
      \includegraphics[width=\textwidth]{graphs/Scalability_varyingN/poker_SC_RB_varyingNS2.pdf}
      \caption{Size of Poker (1M)}
      \label{fig:scalability_varyingN_poker}
      \end{subfigure}
	  \begin{subfigure}[b]{0.23\textwidth}
      \includegraphics[width=\textwidth]{graphs/Scalability_varyingN/SUSY_SC_RB_varyingNS2.pdf}
      \caption{Size of SUSY (4M)}
      \label{fig:scalability_varyingN_susy}
      \end{subfigure}
\caption{Linear scalability of SC\_RB when varying the number of samples . Linear and quadratic complexity are also plotted for easy comparisons.}
\label{fig:scalability_varyingN}
\end{figure}

\begin{figure*}[!htb]
\centering
	  \begin{subfigure}[b]{0.23\textwidth}
      \includegraphics[width=\textwidth]{graphs/Scalability_varyingR/pendigits_SC_AllRuntime_VaryingR2.pdf}
      \caption{pendigits}
      \label{fig:scalability_varyingR_pendigits}
      \end{subfigure}
	  \begin{subfigure}[b]{0.23\textwidth}
      \includegraphics[width=\textwidth]{graphs/Scalability_varyingR/letter_SC_AllRuntime_VaryingR2.pdf}
      \caption{letter}
      \label{fig:scalability_varyingR_letter}
      \end{subfigure}
      \begin{subfigure}[b]{0.23\textwidth}
      \includegraphics[width=\textwidth]{graphs/Scalability_varyingR/acoustic_SC_AllRuntime_VaryingR2.pdf}
      \caption{acoustic}
      \label{fig:scalability_varyingR_acoustic}
      \end{subfigure}
       \begin{subfigure}[b]{0.23\textwidth}
      \includegraphics[width=\textwidth]{graphs/Scalability_varyingR/ijcnn1_SC_AllRuntime_VaryingR2.pdf}
      \caption{ijcnn1}
      \label{fig:scalability_varyingR_ijcnn1}
      \end{subfigure}
\caption{Scalability of SC\_RB and other methods on 4 datasets when varying the number of latent features .}
\label{fig:scalability_varyingR}
\end{figure*}


\textbf{Setup.} We perform experiments to study the effects of various SVD solvers on runtime for SC\_RB. We choose the covtype-mult dataset due to two reasons: 1) RB generates a very large sparse matrix  having the size of half millions in the number of data points and tens of millions in the number of sparse features, which challenges any existing SVD solver in a single machine; 2) the convergence of iterative eigensolver largely depends on the well-separation of the desired eigenvalues. Unfortunately, the gap between the largest eigenvalues of covtype-mult is very small , making it a difficult eigenvalue problem. We compare PRIMME\_SVDS with Matlab SVDS function, a widely used SVD solver routine in the research community. We also set stopping tolerance \texttt{1E-5} to yield faster convergence for both solvers. We vary  for SC\_RB from 16 to 128 and record the Accuracy (Acc) and Runtime (in Seconds) as our performance metrics for this set of experiment. 

\textbf{Results.} 
Fig. \ref{fig:Accu_runtime_varyingR_covtype-mult} shows how the accuracy (Acc) and runtime changes for SC\_RB using these two different SVD solvers when varying the rank  on covtype-mult dataset. Interestingly, SC\_RB with PRIMME\_SVDS delivers more consistent accuracy than that with SVDS. This may be because Matlab SVDS function has a difficult time to converge to multiple very close singular values, showing an warning message "reach default maximum iterations". However, as shown in Fig. \ref{fig:Runtime_varyingR_covtype-mult}, less accurate singular triplets (from Matlab SVDS) takes significantly more computational time compared to PRIMME\_SVDS, especially when  increases. In contrast, the computational time of eigendecomposition using PRIMME\_SVDS changes slowly with increased . Thanks to the power of PRIMME, the proposed SC\_RB could achieve good clustering performance based on high-quality singular vectors while managing attractable computational time for very large sparse matrices. 


\subsection{Scalability of SC\_RB when varying the number of data samples }

\textbf{Setup.} Our goal in this experiment is to assess the scalability of SC\_RB when varying the number of data samples  on poker dataset and another large dataset SUSY \footnote{SUSY is a large dataset in the LIBSVM data collections \cite{chang2011libsvm}.}. 
We vary the number of data samples in the range of  on poker and  on the synthetic dataset.
We use the same hyperparameters as the previous experiments and fix . Since RB can be easily parallelized, we accelerate its computation using 4 threads. Matlab also automatically parallelize the matrix-vector operations for other solvers. We report the runtime for generating random binning feature matrix, computing partial eigendecomposition using state-of-the-art eigensolver \cite{stathopoulos2010primme,wu2017primme_svds}, performing K-means, and the overall runtime, respectively.

\textbf{Results.} Figure \ref{fig:scalability_varyingN} clearly shows that SC\_RB indeed scales linearly with the increase in the number of data samples.
Note that even for large datasets consisting of millions of samples, the computation time of SC\_RB is still less than 500 seconds. These results suggest that: (i) SC\_RB exhibits linear scalability in  and is comtenant of handling large datasets in a reasonable time frame; (ii) with the state-of-the-art eigensolver \cite{wu2017primme_svds}, the complexity of computing a few of eigenvectors for spectral clustering is indeed linearly proportional to the matrix size . 

The key factor that contributes to the competitive computation time and linear scalability of  SC\_RB in the data size  is that we take into account the end-to-end spectral clustering pipeline consisting of the build blocks, RB generation, eigensolver and K-means, and our approach ensures each component takes a similar (linear) computation complexity, as analyzed in Section \ref{sec: scalable sc_rb}.


\subsection{Scalability of SC\_RB when varying the number of RB features }

\textbf{Setup.} We further investigate the scalablity of various random-feature-based, sampling-based SC methods and approximate Kernel K-means methods when varying the latent feature size . One of our goal is to investigate whether the latent matrix rank  is linearly proportional to . If this is true, then the total complexity of an approximation method is still bounded by , which is an unfavorable property for large-scale data. Therefore, we study the computational time of 8 baselines when varying  from 16 to 1024 on 4 datasets. The other settings are same as before. 

\textbf{Results.} Figure \ref{fig:scalability_varyingR} shows that the computation of SC\_RB is as efficient as other approximation methods. There are several comments worth making here. First, compared to the quadratic complexity of exact SC in Figures \ref{fig:scalability_varyingR_pendigits} and \ref{fig:scalability_varyingR_letter}, various approximation methods except KK\_RF require much less computational time. It means that the total complexity of various methods are respecting to  where  could be somehow treated as a constant as long as  is significantly smaller than . Remarkably, Figures \ref{fig:scalability_varyingR_acoustic} and \ref{fig:scalability_varyingR_ijcnn1} show that most of approximation methods including SC\_RB can even behave as efficient as K-means on the original dataset. Obviously, most of these methods exhibit clear linear relation with , indicating that these methods are not tightly associated with . In other words, if the low rank  in any method is respecting with , then the total complexity of the method is proportional to , which should yield non-linear scalability respecting to . The only exception is the KK\_RF method, which consistently requires much more runtime compared to other methods, making it less attractable than other methods.   



\section{Conclusion}
In this paper, we have presented a scalable end-to-end spectral clustering method based on RB features (SC\_RB) for overcoming two computational bottlenecks - similarity graph construction and eigendecomposition of the graph Laplacian. By leveraging RB features, the pairwise similarity matrix can be approximated implicitly by the inner product of the RB feature matrix, which significantly reduces the computational complexity from quadratic to linear in terms of the number of data samples. We further show how to effectively and directly apply SVD  on the weighted RB feature matrix and introduce a state-of-the-art sparse SVD solver to efficiently manage the SVD computation for a very large sparse matrix. Our theoretical analysis shows that by drawing  grids with at least  number of non-empty bins per grid, SC\_RB can guarantee convergence to exact spectral clustering with a rate of  under the same pairwise graph construction process, which is much faster than other Random Features based SC methods.
Our extensive experiments on 8 benchmarks over 4 performance metrics demonstrate that SC\_RB either outperforms or matches 8 baselines in both accuracy and computational time, and corroborate that SC\_RB indeed exhibits linear scalability in terms of the number of data samples and the number of RB features.




 
\bibliographystyle{ACM-Reference-Format}
\bibliography{myrefs,RWS,SC_RB}
\end{document}
