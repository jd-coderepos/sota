\documentclass[a4paper]{article}

\title{An encoding of array verification problems into array-free Horn clauses\thanks{The research leading to these results has received funding from the \href{http://erc.europa.eu/}{European Research Council} under the European Union's Seventh Framework Programme (FP/2007-2013) / ERC Grant Agreement nr.~306595 \href{http://stator.imag.fr/}{\mbox{``STATOR''}}.}}

\author{David Monniaux\\
{\small Univ. Grenoble Alpes, VERIMAG, F-38000 Grenoble}\\
{\small CNRS, VERIMAG, F-38000 Grenoble, France}
\and Laure Gonnord\\
{\small LIP, Univ. Lyon-1, France}
}

\usepackage{paralist}

\usepackage{amsmath,amsfonts,amsthm,galois,proof}

\usepackage{tikz}
\usetikzlibrary{arrows,automata,shapes}

\usepackage{listings}
\lstdefinelanguage{imp}[]{C}{morekeywords={assume,assert}}
\lstdefinelanguage{SMT}[]{Lisp}{}
\lstset{basicstyle={\rm\fontfamily{ppl}\selectfont\small},language=imp,mathescape=true,breaklines=true}

\usepackage[natbib=true,backend=bibtex]{biblatex}
\bibliography{arrays_Horn}

\usepackage[pdftitle={An encoding of array verification problems into array-free Horn clauses},pdfauthor={David Monniaux and Laure Gonnord}]{hyperref}

\newcommand{\ve}[1]{\mathbf{#1}}
\newcommand{\vx}{\ve{x}}
\newcommand{\vy}{\ve{y}}
\newcommand{\vz}{\ve{z}}
\newcommand{\f}{\ve{f}}

\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\arraytype}[2]{\mathit{Array}\left(#1,#2\right)}

\newcommand{\abstr}[1]{#1^\sharp}
\newcommand{\parts}[1]{\mathcal{P}\left(#1\right)}
\newcommand{\abstraction}[2][]{\alpha_{#1}\left(#2\right)}
\newcommand{\concretization}[2][]{\gamma_{#1}\left(#2\right)}
\newcommand{\hash}{\#}
\DeclareMathOperator{\card}{card}

\newcommand{\soft}[1]{\textsc{#1}}
\newcommand{\true}{\mathsf{true}}
\newcommand{\false}{\mathsf{false}}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{algo}{Algorithm}
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{example}{Example}
\newtheorem*{example*}{Example}
\newtheorem{remark}{Remark}

\newcommand{\rulespacing}{\
\forall \vx,~ \vx \in S_{i_0} \implies \vx \in I_{i_0} \label{clause:init} \\
\forall \vx,\vx'~ \vx \in I_i \land (\vx,\vx') \in \tau_{i,j}
  \implies \vx' \in I_j \label{clause:inductive}

\forall n \in \ZZ~ \mathit{loop}(n, 0, 1)\\
\forall n,i,j \in \ZZ~
  \mathit{loop}(n, i, j) \land i < n \implies
  \mathit{incr}_i(n, i, j)\\
\forall n,i,j \in \ZZ~
  \mathit{loop}(n, i, j) \land i \geq n \implies
  \mathit{exit}(n, i, j)\\
\forall n,i,j \in \ZZ~
  \mathit{incr}_i(n, i, j) \implies
  \mathit{incr}_j(n, i+1, j)\\
\forall n,i,j \in \ZZ~
  \mathit{incr}_j(n, i, j) \implies
  \mathit{loop}(n, i, j+2)

\forall n,i,j\in \ZZ~ \mathit{exit}(n,i,j) \land n\geq 0 \implies i=n
\label{formula:query}

\forall n,i,j\in \ZZ~ \mathit{exit}(n,i,j) \implies i=n

\forall n,i,j\in \ZZ~ \mathit{exit}(n,i,j) \land n\geq 0 \implies j \leq 2+3n

\begin{aligned}
\forall n\in\ZZ~ \forall a\in\arraytype{\ZZ}{\ZZ}~ n>0 \implies
  \mathit{loop}(n,0,a)
\end{aligned} \label{equ:array_fill1_arrays_begin}\\
\begin{aligned}
\forall n,i\in\ZZ~ \forall a\in \arraytype{\ZZ}{\ZZ}~
  i<n \land \mathit{loop}(n,i,a) \\
  \implies \mathit{loop}(n,i+1,\mathit{store}(a,i,42))
\end{aligned}\rulespacing
\begin{aligned}
\forall n,i\in\ZZ~ \forall a\in \arraytype{\ZZ}{\ZZ}~
  i\geq n \land \mathit{loop}(n,i,a)\\
  \implies \mathit{end}(n,a)
\end{aligned}\rulespacing
\begin{aligned}
\forall n\in\ZZ~ \forall a\in \arraytype{\ZZ}{\ZZ}~
  0 \leq x < n \land \mathit{end}(n,a) \\
  \implies a[x] = 42
\end{aligned} \label{equ:array_fill1_arrays_end}

0 \leq i \leq n \land (\forall k~ 0 \leq k < i \implies a[k] = 42)
\label{rule:read1_different}
\begin{aligned}
\forall \vx \in \chi~ \forall i \in \iota~ \forall a_i \in \beta~
  \forall k \in \iota~ \forall a_k \in \beta\\
  k \neq i \land \abstr{I}_1\big((\vx,i),(k,a_k)\big) \land
                 \abstr{I}_1\big((\vx,i),(i,a_i)\big) \\ \implies
  \abstr{I}_2\big((\vx,a_i,i),(k,a_k)\big)
\end{aligned}\rulespacing\label{rule:read1_same}
\begin{aligned}
\forall \vx \in \chi~ \forall i \in \iota~ \forall a_i \in \beta~
  \forall k \in \iota~ \forall a_k \in \beta\\
  \abstr{I}_1\big((\vx,i),(i,a_i)\big) \implies
  \abstr{I}_2\big((\vx,a_i,i),(i,a_i)\big)
\end{aligned}

\begin{aligned}
\forall \vx \in \chi~ \forall i \in \iota~ \forall v \in \beta~
  \forall k \in \iota~ \forall a_k \in \beta\\
  \abstr{I}_1\big((\vx,i,v),(k,a_k)\big) \land i\neq k \implies
  \abstr{I}_2\big((\vx,v,i),(k,a_k)\big)
\end{aligned}\label{rule:write1_different}\rulespacing
\begin{aligned}
\forall \vx \in \chi~ \forall i \in \iota~ \forall v \in \beta~
  \forall k \in \iota~ \forall a_k \in \beta\\
  \abstr{I}_1\big((\vx,i,v),(i,a_k)\big) \implies
  \abstr{I}_2\big((\vx,v,i),(i,v)\big)
\end{aligned}\label{rule:write1_same}

\begin{aligned}
\forall \vx \in \chi~ \forall k \in \iota~ \forall a_k \in \beta~
  \abstr{I}_1(\vx) \implies
  \abstr{I}_2(\vx,k,a_k)
\end{aligned}

\begin{aligned}
\forall \vx \in \chi~ \forall k \in \ZZ~ \forall a_k \in \beta~
  \abstr{I}_1(\vx) \land 0 \leq k < n \\ \implies
  \abstr{I}_2(\vx,k,a_k)
\end{aligned}

\begin{aligned}
\forall \vx \in \chi~ \forall k \in \iota~ \forall a_k \in \beta\\
  \abstr{I}_1(\vx,k,a_k) \land \vx \rightarrow_s \vx'
  \implies \abstr{I}_2(\vx',k,a_k)
\end{aligned}

\forall x,y,k,a_k~ \abstr{I}_1(x,y,k,a_k) \land x \neq y \implies
                    \abstr{I}_2(x,y,k,a_k)

\concretization{\abstr{I}} = \{ (\vx,a) \mid
  \forall i\in\iota~ (\vx,i,a[i]) \in \abstr{I} \}

\abstraction{I} = \{ (\vx,i,a[i]) \mid x \in \chi, i \in \iota \}

 \parts{\chi \times \arraytype{\iota}{\beta}}
 \galois{\alpha}{\gamma} \parts{\chi \times (\iota \times \beta)}.

\begin{aligned}
\forall n,k,a_k \in \ZZ~ 0 \leq k < n \implies \mathit{loop}(n,0,k,a_k)
\end{aligned}\label{rule:array_fill1_begin}\\
\begin{aligned}
\forall n,i,k,a_k \in \ZZ~ 0 \leq k < n \land i < n \land
\mathit{loop}(n,i,k,a_k)\\ \implies \mathit{write}(n,i,k,a_k)
\end{aligned}\rulespacing
\begin{aligned}
\forall n,i,k,a_k \in \ZZ~ 0 \leq k < n \land i \neq k \land
\mathit{write}(n,i,k,a_k)\\ \implies \mathit{incr}(n,i,k,a_k)
\end{aligned}\rulespacing
\begin{aligned}
\forall n,i,a_k \in \ZZ~ \land
\mathit{write}(n,i,i,a_k)\\ \implies \mathit{incr}(n,i,i,42)
\end{aligned}\rulespacing
\begin{aligned}
\forall n,i,k,a_k \in \ZZ~ 0 \leq k < n \land
\mathit{incr}(n,i,k,a_k)\\ \implies \mathit{loop}(n,i+1,k,a_k)
\end{aligned}\rulespacing
\begin{aligned}
\forall n,i,k,a_k \in \ZZ~ 0 \leq k < n \land i \geq n \land
\mathit{loop}(n,i,k,a_k)\\ \implies \mathit{end}(n,k,a_k)
\end{aligned}\label{rule:array_fill1_end}

\begin{aligned}
\forall n,k,a_k \in \ZZ~ 0 \leq k < n \land
\mathit{end}(n,i,k,a_k) \implies a_k = 42
\end{aligned}

\begin{aligned}
\forall n,k,a_k,l,b_l \in \ZZ~
   \mathit{init}(n,k,a_l,l,b_l) \\\implies \mathit{loop}(n,0,k,a_k,l,b_l)
\end{aligned}\rulespacing
\begin{aligned}
\forall n,i,k,a_k,l,b_l \in \ZZ~
   \mathit{loop}(n,i,k,a_k,l,b_l) \\ \land i< n-i-1 \implies
   \mathit{read}_1(n,i,k,a_k,l,b_l)
\end{aligned}\rulespacing
\begin{aligned}
\forall n,i,v_1,v_2,k,a_k,l,b_l \in \ZZ~
   \mathit{read}_1(n,i,k,a_k,l,b_l) \\ \land i \neq k \land
   \mathit{read}_1(n,i,i,v_1,l,b_l) \\ \implies
   \mathit{read}_2(n,i,v_1,k,a_k,l,b_l)
\end{aligned}\rulespacing
\begin{aligned}
\forall n,i,v_1,v_2,k,l,b_l \in \ZZ~
   \mathit{read}_1(n,i,i,v_1,b_l) \\ \implies
   \mathit{read}_2(n,i,v_1,i,v_1,l,b_l)
\end{aligned}\rulespacing
\begin{aligned}
\forall n,i,v_1,v_2,k,a_k,l,b_l \in \ZZ~
   \mathit{read}_2(n,i,v_1,v_2,k,a_k,l,b_l) \\\land n-1-i \neq k \land
   \mathit{read}_2(n,i,v_1,n-i-1,v_2,l,b_l)\\ \implies
   \mathit{write}_1(n,i,v_1,v_2,k,a_k,l,b_l)
\end{aligned}\rulespacing
\begin{aligned}
\forall n,i,v_1,v_2,l,b_l \in \ZZ~
   \mathit{read}_2(n,i,v_1,v_2,n-1-i,v_2,l,b_l) \\ \implies
   \mathit{write}_1(n,i,v_1,v_2,n-1-i,v_2,l,b_l)
\end{aligned}\rulespacing
\begin{aligned}
\forall n,i,v_1,v_2,k,a_k,l,b_l \in \ZZ~
   \mathit{write}_1(n,i,v_1,v_2,k,a_k,l,b_l) \\ \land i\neq k \implies
   \mathit{write}_2(n,i,v_1,k,a_k,l,b_l)
\end{aligned}\rulespacing
\begin{aligned}
\forall n,i,v_1,v_2,k,a_k,l,b_l \in \ZZ~
   \mathit{write}_1(n,i,v_1,v_2,k,a_k,l,b_l) \\\implies
   \mathit{write}_2(n,i,v_1,i,v_2,l,b_l)
\end{aligned}\rulespacing
\begin{aligned}
\forall n,i,v_1,k,a_k,l,b_l \in \ZZ~
   \mathit{write}_2(n,i,v_1,k,a_k,l,b_l) \\\land n-1-i\neq k \implies
   \mathit{incr}(n,i,k,a_k,l,b_l)
\end{aligned}\rulespacing
\begin{aligned}
\forall n,i,v_1,k,a_k,l,b_l \in \ZZ~
   \mathit{write}_2(n,i,v_1,k,a_k,l,b_l) \\\implies
   \mathit{incr}(n,i,n-1-i,v_1,l,b_l)
\end{aligned}\rulespacing
\begin{aligned}
\forall n,i,k,a_k,l,b_l \in \ZZ~
   \mathit{incr}(n,i,k,a_k,l,b_l) \\\implies
   \mathit{loop}(n,i+1,k,a_k,l,b_l)
\end{aligned}\rulespacing
\begin{aligned}
\forall n,i,k,a_k,l,b_l \in \ZZ~
   i\geq n-i-1 \land \mathit{loop}(n,i,k,a_k,l,b_l) \\\implies
   \mathit{end}_1(n,k,a_k,l,b_l)
\end{aligned}

\forall n,k,a_k \in \ZZ~ 0 \leq k < n \implies \mathit{init}(n,k,a_k,k,a_k)\\
\begin{aligned}
\forall n,k,a_k,l,a_l \in \ZZ~ 0 \leq k < n \land 0 \leq l < n \land k \neq l
  \\\implies \mathit{init}(n,k,a_k,l,b_l)
\end{aligned}

\begin{aligned}
\forall n,i,a_k,b_j \in \ZZ~ 0 \leq i < n \land
  \mathit{end}(n, i, a_k, n-1-k, b_j)\\
  \implies a_k = b_j
\end{aligned}

\begin{aligned}
\forall l,h,p,b,a_p~ \mathit{end}(l,h,p,b,p,a_p) \implies b = a_p
   \label{formula:find_minimum:found}
\end{aligned} \\
\begin{aligned}
\forall l,h,p,b,k,a_p,a_k~
  l \leq k < h \land \mathit{end}(l,h,p,b,k,a_k) \\ \implies b \leq a_k
   \label{formula:find_minimum:is_minimum}
\end{aligned}

\forall k~ 0 \leq 2k < n \implies a[2k] = 0\\
\forall k~ 0 \leq 2k+1 < n \implies a[2k+1] = 1

\forall k~ \mathit{end}(n,2k,a_x) \implies a_x = 0\\
\forall k~ \mathit{end}(n,2k+1,a_x) \implies a_x = 1

\forall x \in \QQ~ \mathit{init}(x, 0)\\
\forall x \in \QQ~ \forall a_x \in \ZZ~
  \mathit{init}(x, a_x) \land x\neq 1 \implies \mathit{w}_1(x, a_x)\\
\forall a_x \in \ZZ~
  \mathit{init}(1, ax) \implies \mathit{w}_1(1, 10)\\
\forall x \in \QQ~ \forall a_x \in \ZZ~
  \mathit{w}_1(x, a_x) \land x\neq 2 \implies \mathit{w}_2(x, a_x)\\
\forall a_x \in \ZZ~
  \mathit{w}_1(2, ax) \implies \mathit{w}_2(2, 20)\\
\forall x \in \QQ~ \forall a_x \in \ZZ~
  \mathit{w}_2(x, a_x) \land x\neq 3 \implies \mathit{exit}(x, a_x)\\
\forall a_x \in \ZZ~
  \mathit{w}_2(3, ax) \implies \mathit{exit}(3, 30)

\begin{aligned}
\forall m,n,x,y,a_{xy} \in \ZZ~
  0 \leq x < m \land 0 \leq y < n \\ \implies
  \mathit{init}(m, n, x, y, a_{xy})
\end{aligned}\rulespacing
\begin{aligned}
\forall m,n,x,y,a_{xy} \in \ZZ~
  \mathit{init}(m, n, x, y, a_{xy}) \\ \implies
  \mathit{loop}_i(m, n, 0, x, y, a_{xy})
\end{aligned}\rulespacing
\begin{aligned}
\forall m,n,i,x,y,a_{xy} \in \ZZ~
  \mathit{loop}_i(m, n, i, x, y, a_{xy}) \land i<m \\ \implies
  \mathit{loop}_j(m, n, i, 0, x, y, a_{xy})
\end{aligned}\rulespacing
\begin{aligned}
\forall m,n,i,x,y,a_{xy} \in \ZZ~
  \mathit{loop}_i(m, n, i, x, y, a_{xy}) \land i\geq m \\ \implies
  \mathit{exit}(m, n, x, y, a_{xy})
\end{aligned}\rulespacing
\begin{aligned}
\forall m,n,i,j,x,y,a_{xy} \in \ZZ~
  \mathit{loop}_j(m, n, i, j, x, y, a_{xy}) \land j<n \\ \implies
  \mathit{write}(m, n, i, j, x, y, a_{xy})
\end{aligned}\rulespacing
\begin{aligned}
\forall m,n,i,j,x,y,a_{xy} \in \ZZ~
  \mathit{loop}_j(m, n, i, j, x, y, a_{xy}) \land j\geq n \\ \implies
  \mathit{incr}_i(m, n, i, x, y, a_{xy})
\end{aligned}\rulespacing
\begin{aligned}
\forall m,n,i,j,x,y,a_{xy},a_{ij} \in \ZZ \\
  \mathit{write}(m, n, i, j, x, y, a_{xy})  \land
  \mathit{write}(m, n, i, j, i, j, a_{ij}) \\ \land
  \land (i\neq x \lor j\neq y) \implies
  \mathit{incr}_j(m, n, i, j, x, y, a_{xy})
\end{aligned}\rulespacing
\begin{aligned}
\forall m,n,i,j,a_{ij} \in \ZZ~
  \mathit{write}(m, n, i, j, i, j, a_{ij}) \\ \implies
  \mathit{incr}_j(m, n, i, j, i, j, 42)
\end{aligned}\rulespacing
\begin{aligned}
\forall m,n,i,j,x,y,a_{xy} \in \ZZ~
  \mathit{incr}_j(m, n, i, j, x, y, a_{xy}) \\ \implies
  \mathit{loop}_j(m, n, i, j+1, x, y, a_{xy})
\end{aligned}\rulespacing
\begin{aligned}
\forall m,n,i,x,y,a_{xy} \in \ZZ~
  \mathit{incr}_i(m, n, i, x, y, a_{xy}) \\ \implies
  \mathit{loop}_i(m, n, i+1, x, y, a_{xy})
\end{aligned}

\concretization[2]{\abstr{I}} = \{ (\vx,a) \mid
  \forall k_1,k_2\in\iota~ (\vx,k_1,a[k_1],k_2,a[k_2]) \in \abstr{I} \}

\abstraction[2]{I} = \{ (\vx,k_1,a[k_1],k_2,a[k_2]) \mid x \in \chi, k_1,k_2 \in \iota \}

 \parts{\chi \times \arraytype{\iota}{\beta}}
 \galois{\alpha_2}{\gamma_2} \parts{\chi \times (\iota \times \beta)^2}.

\concretization[2\leq]{\abstr{I}} = \{ (\vx,a) \mid
  \forall k_1 \leq k_2\in\iota~ (\vx,k_1,a[k_1],k_2,a[k_2]) \in \abstr{I} \}

\abstraction[2\leq]{I} = \{ (\vx,k_1,a[k_1],k_2,a[k_2]) \mid x \in \chi, k_1 \leq k_2 \in \iota \}

 \parts{\chi \times \arraytype{\iota}{\beta}}
 \galois{\alpha_{2\leq}}{\gamma_{2\leq}}\\
 \parts{\{(x,k_1,v_1,k_2,v_2) \mid x \in \chi,~ k_1 \leq k_2 \in \iota,~ v_1, v_2 \in \beta \}}.

\begin{aligned}
\forall \vx \in \chi~ \forall i,k_1,k_2\in\iota~ \forall v,a_{k_1},a_{k_2} \in \beta\\
  \abstr{I}_1(\vx, i, k_1, a_{k_1}, k_2, a_{k_2}) \land
  \abstr{I}_1(\vx, i, i, v, k_2, a_{k_2}) \\ \land
  k_1 \neq i \land i < k_2 \implies
  \abstr{I}_2(\vx, i, v, k_1, a_{k_1}, k_2, a_{k_2})
\end{aligned} \label{rule:read2_begin}\\
\begin{aligned}
\forall \vx \in \chi~ \forall i,k_1,k_2\in\iota~ \forall v,a_{k_1},a_{k_2} \in \beta \\
  \abstr{I}_1(\vx, i, k_1, a_{k_1}, k_2, a_{k_2}) \land
  \abstr{I}_1(\vx, i, k_1, a_{k_1}, i, v) \\ \land
  k_2 \neq i \land k_1 < i \implies
  \abstr{I}_2(\vx, i, v, k_1, a_{k_1}, k_2, a_{k_2})
\end{aligned}\rulespacing
\begin{aligned}
\forall \vx \in \chi~ \forall i,k_2\in\iota~ \forall v,a_{k_2} \in \beta \\
  \abstr{I}_1(\vx, i, i, v, k_2, a_{k_2}) \land i < k_2 \implies
  \abstr{I}_2(\vx, i, i, v, k_2, a_{k_2})
\end{aligned}\rulespacing
\begin{aligned}
\forall \vx \in \chi~ \forall i,k_1\in\iota~ \forall v,a_{k_1} \in \beta \\
  \abstr{I}_1(\vx, i, k_1, a_{k_1}, i, v) \land k_1 \leq i \implies
  \abstr{I}_2(\vx, i, k_1, a_{k_1}, i, v)
\end{aligned}\label{rule:read2_end}

\begin{aligned}
\forall \vx \in \chi~ \forall i,k_1,k_2\in\iota~ \forall v,a_{k_1},a_{k_2} \in \beta\\
  \abstr{I}_1(\vx, i, v, k_1, a_{k_1}, k_2, a_{k_2})
  \land i \neq k_1 \land i \neq k_2 \\ \implies
  \abstr{I}_2(\vx, i, v, k_1, a_{k_1}, k_2, a_{k_2})
\end{aligned}\rulespacing
\begin{aligned}
\forall \vx \in \chi~ \forall i, k_2\in\iota~
  \forall v,a_{k_1},a_{k_2} \in \beta~~ \land i \neq k_2 \\
  \land \abstr{I}_1(\vx, i, v, i, a_{k_1}, k_2, a_{k_2})
  \implies
  \abstr{I}_2(\vx, i, v, i, v, k_2, a_{k_2})
\end{aligned}\rulespacing
\begin{aligned}
\forall \vx \in \chi~ \forall i,k_1\in\iota~
  \forall v,a_{k_1},a_{k_2} \in \beta`~ \land i \neq k_1 \\
  \land \abstr{I}_1(\vx, i, v, k_1, a_{k_1}, i, a_{k_2})
  \implies
  \abstr{I}_2(\vx, i, v, k_1, a_{k_1}, i, v)
\end{aligned}\rulespacing
\begin{aligned}
\forall \vx \in \chi~ \forall i\in\iota~ \forall v,a_k \in \beta\\
  \abstr{I}_1(\vx, i, v, i, a_k, i, a_k)
  \implies
  \abstr{I}_2(\vx, i, v, i, v, i, v)
\end{aligned}

\begin{aligned}
\forall \vx \in \chi~ \forall k_1, k_2\in\iota~ \forall \beta_1,\beta_2 \in \beta\\
  \abstr{I}_1(\vx, k_1, a_{k_1}) \land \abstr{I}_1(\vx, k_2, a_{k_2}) 
  \land k_1 < k_2
  \\ \implies
  \abstr{I}_2(\vx, k_1,  a_{k_1}, k_2, a_{k_2})
\end{aligned}\rulespacing
\begin{aligned}
\forall \vx \in \chi~ \forall k \in\iota~ \forall \beta \in \beta\\
  \abstr{I}_1(\vx, k) \implies
  \abstr{I}_2(\vx, k,  a_k, k, a_k)
\end{aligned}

\begin{aligned}
\forall \vx \in \chi~ \forall n \in \ZZ~ \forall k_1, k_2\in\ZZ~ \forall \beta_1,\beta_2 \in \beta\\
  0 \leq k_1 < k_2 < n \land
  \abstr{I}_1(\vx) \implies
  \abstr{I}_2(\vx, k_1,  a_{k_1}, k_2, a_{k_2})
\end{aligned}\rulespacing
\begin{aligned}
\forall \vx \in \chi~ \forall k \in\ZZ~ \forall \beta \in \beta\\
  0 \leq k < n \land
  \abstr{I}_1(\vx) \implies  \abstr{I}_2(\vx, k,  a_k, k, a_k)
\end{aligned}

\forall l_0 \leq k_1 < k_2 < h~~ a[k_1] \leq a[k_2]

\begin{aligned}
\forall l_0,h,k_1,a_{k_1},k_2,a_{k_2}~
  l_0 \leq k < k_2 < h \\ \land \mathit{exit}(l_0, h, k_1, a_{k_1}, k_2, a_{k_2})
  \implies a_{k_1} \leq a_{k_2}
\end{aligned}

\forall k_1,k_2~ l_0 \leq k_1 < l \land k_1 \leq k_2 < h
\implies a[k_1] \leq a[k_2]

\begin{aligned}
\forall l_0,l,h,k_1,a_{k_1},k_2,a_{k_2} \in \ZZ~
  l_0 \leq k_1 < l \land k_1 \leq k_2 < h \\ \land
  \mathit{outerloop}(l_0,l,h,k_1,a_{k_1},k_2,a_{k_2})
  \implies a_{k_1} \leq a_{k_2}
\end{aligned}\label{formula:outerloop_invariant}

\forall \vx \in \chi~ \forall k \in \iota~
  \abstr{I}_1(\vx, k, a_k, b_k, c_k) \implies
  \abstr{I}_2(\vx, k, b_k \lor c_k, b_k, c_k)

\forall \vx \in \chi~ \forall k \in \iota~
  \abstr{I}_1(\vx, k, a_k, b_k, c_k) \implies
  \abstr{I}_2(\vx, k, b_k \land c_k, b_k, c_k)
\label{formula:array_multiset_write_sequence}
\hash a(a[i]) := \hash a(a[i])-1;~ a[i]:=v;~ \hash a(v) := \hash a(v)+1

\concretization[\hash]{\abstr{I}} = \Big\{ (\vx,a) \mid
  \forall i\in\iota~ \forall v \in \beta~\\
  \big(\vx,(i,a[i]),
  (v,\card \{ j \in \iota \mid a[j] = v \})\big) \in \abstr{I} \Big\}

\abstraction[\hash]{I} = \Big\{ \big(\vx,(i,a[i]),(v,\card \{ j \in \iota \mid a[j] = v \})\big)\\ ~\Big|~ x \in \chi, i \in \iota \Big\}

 \parts{\chi \times \arraytype{\iota}{\beta}}
 \galois{\alpha_{\hash}}{\gamma_{\hash}}
  \parts{\chi \times (\iota \times \beta) \times (\beta \times \NN)}.

\begin{aligned}
\forall \vx \in \chi~ \forall i \in \iota~ \forall v \in \beta~
  \forall k \in \iota~ \forall a_k,z \in \beta~ \forall a_{\hash z} \in \NN\\
  k \neq i \land \abstr{I}_1\big((\vx,i),(k,a_k),(z,a_{\hash z})\big) \\ \land
                 \abstr{I}_1\big((\vx,i),(i,v),(z,a_{\hash z})\big) \implies
  \abstr{I}_2(\vx,v,i,k,a_k)
\end{aligned}\rulespacing
\begin{aligned}
\forall \vx \in \chi~ \forall i \in \iota~ \forall v \in \beta \\
  \abstr{I}_1\big((\vx,i),(i,v),(z,a_{\hash z})\big) \implies
  \abstr{I}_2\big((\vx,v,i),(i,v),(z,a_{\hash z})\big)
\end{aligned}

\begin{aligned}
\forall \vx \in \chi~ \forall i,k \in \iota~ \forall a_i,a_k,v,z \in \beta~
\forall a_{\hash z}\in \NN~ a_i \neq z  \land \\
\abstr{I}_1\big((\vx, v, i), (k, a_k), (z, a_{\hash z})\big) \land
\abstr{I}_1\big((\vx, v, i), (i, a_i), (z, a_{\hash z})\big) \\ \implies
\abstr{I}_a\big((\vx, v, i), (k, a_k), (z, a_{\hash z})\big)
\end{aligned}\rulespacing
\begin{aligned}
\forall \vx \in \chi~ \forall i,k \in \iota~ \forall a_i,a_k,v \in \beta~
\forall a_{\hash z}\in \NN \\
\abstr{I}_1\big((\vx, v, i), (k, a_k), (a_i, a_{\hash z})\big) \land
\abstr{I}_1\big((\vx, v, i), (i, a_i), (a_i, a_{\hash z})\big) \\ \implies
\abstr{I}_a\big((\vx, v, i), (k, a_k), (a_i, a_{\hash z}-1)\big)
\end{aligned}\rulespacing
\begin{aligned}
\forall \vx \in \chi~ \forall i,k \in \iota~ \forall a_i,a_k,v,z \in \beta~
\forall a_{\hash z}\in \NN \\ v \neq z \land
\abstr{I}_a\big((\vx, v, i), (k, a_k), (z, a_{\hash z})\big) \land
\abstr{I}_a\big((\vx, v, i), (i, a_i), (z, a_{\hash z})\big) \\ \implies
\abstr{I}_b\big((\vx, v, i), (k, a_k), (z, a_{\hash z})\big)
\end{aligned}\rulespacing
\begin{aligned}
\forall \vx \in \chi~ \forall i,k \in \iota~ \forall a_i,a_k,v \in \beta~
\forall a_{\hash z}\in \NN \\
\abstr{I}_a\big((\vx, v, i), (k, a_k), (v, a_{\hash z})\big) \land
\abstr{I}_a\big((\vx, v, i), (i, a_i), (v, a_{\hash z})\big) \\ \implies
\abstr{I}_b\big((\vx, v, i), (k, a_k), (v, a_{\hash z}+1)\big)
\end{aligned}\rulespacing
\begin{aligned}
\forall \vx \in \chi~ \forall i \in \iota~ \forall v \in \beta~
  \forall x \in \iota~ \forall a_k \in \beta~~  i\neq k \land \\
  \abstr{I}_1\big((\vx,i,v),(k,a_k), (z, a_{\hash z})\big)
  \implies
  \abstr{I}_2\big((\vx,v,i),(k,a_k), (z, a_{\hash z})\big)
\end{aligned}\rulespacing
\begin{aligned}
\forall \vx \in \chi~ \forall i \in \iota~ \forall v \in \beta~
  \forall k \in \iota~ \forall a_k \in \beta\\
  \abstr{I}_1\big((\vx,i,v),(i,a_k), (z, a_{\hash z})\big)  \implies
  \abstr{I}_2\big((\vx,v,i),(i,v), (z, a_{\hash z})\big)
\end{aligned}

\begin{aligned}
\forall l_0,h,k,a_k,z,a_{\hash z},a^0_{\hash z}~
\mathit{exit}(l_0,h,k,a_k,z,a_{\hash z},a^0_{\hash z}) \\
\implies a_{\hash z} = a^0_{\hash z}
\end{aligned}

\forall k,a_k \in \ZZ~ r_1(k, a_k) \rulespacing
\begin{aligned}
\forall v_1,k,a_k \in \ZZ~
  r_1(k,a_k) \land r_1(1,v_1) \land k\neq 1\\
  \implies r_2(v_1, k, a_k)
\end{aligned}\rulespacing
\forall v_1~ r_1(1,v_1) \implies r_2(v_1,1,v_2) \label{rule:counterexample_r1b}\\
\begin{aligned}
\forall v_1,v_2,k,a_k \in \ZZ~
  r_2(v_1,k,a_k) \land r_2(v_1,2,v_2) \land k\neq 2\\ 
  \implies \mathit{cmp}(v_1,v_2,k,a_k)
\end{aligned} \label{rule:counterexample_r2a}\rulespacing
\forall v_1,v_2 \in \ZZ~ r_2(v_1,2,v_2) \implies \mathit{cmp}(v_1,v_2,2,v_2) \rulespacing
\forall v,k,a_k \in \ZZ~
  \mathit{cmp}(v,v,k,a_k) \implies r_3(k,a_k)  \label{rule:counterexample_cmp} \rulespacing
\begin{aligned}
\forall v_1,k,a_k \in \ZZ~
  r_3(k,a_k) \land r_3(1,v_1) \land k\neq 1\\
 \implies  r_4(v_1, k, a_k)
\end{aligned} \rulespacing
\forall v_1~ r_3(1,v_1) \implies r_4(v_1,1,v_1)  \label{rule:counterexample_r3b} \rulespacing
\begin{aligned}
\forall v_1,v_2,k,a_k \in \ZZ~
  r_4(v_1,k,a_k) \land r_4(v_1,2,v_2) \land k\neq 2\\
  \implies \mathit{end}(v_1,v_2,k,a_k)
\end{aligned}  \label{rule:counterexample_r4a} \rulespacing
\forall v_1,v_2 \in \ZZ~ r_4(v_1,2,v_2) \implies \mathit{end}(v_1,v_2,2,v_2) \rulespacing
\forall v_1,v_2,a_1 \in \ZZ~ \mathit{end}(v_1,v_2,1,a_1) \implies v_1=v_2

\forall \dots~
  \abstr{I}_1\big(\dots, (k,a_k)\big) \land \dots \land \abstr{I}_1(\dots,\dots) \implies
  \abstr{I}_2\big(\dots, (k,a_k)\big) 

\begin{aligned}
\forall \vx \in \chi~ \forall i \in \iota~ \forall v \in \alpha~
  \forall k \in \iota~ \forall a_k \in \alpha\\
  i \neq k \land \abstr{I}_1(\vx,i,k,a_k) \implies
  \abstr{I}_2(\vx,v,i,k,a_k)
\end{aligned}\rulespacing
\begin{aligned}
\forall \vx \in \chi~ \forall i \in \iota~ \forall v \in \alpha~
  \forall k \in \iota~ \forall a_k \in \alpha\\
  \abstr{I}_1(\vx,i,i,v) \implies
  \abstr{I}_2(\vx,v,i,i,v)
\end{aligned}

\begin{aligned}
  \left(\forall k'_1~ \left(k'_1 \leq k_2 \implies \exists a_{k'_1} \abstr{I}_1(\vx, k'_1, a_{k'_1}, k_2, a_{k_2})\right) \right) \\ \land
  \abstr{I}_1(\vx, k_1, a_{k_1}, k_2, a_{k_2}) \implies
  \abstr{I}_2(\vx, k_1, a_{k_1}, k_2, a_{k_2})
\end{aligned}

\tau_0(\vx_0,\vx_1) \land \dots \land \tau_{n-1}(\vx_{n-1},\vx_n)

I_i(\vx_i) \land \tau_0(\vx_i,\vx_{i+1}) \implies I_{i+1}(\vx_{i+1})

and .
Such  are known as \emph{Craig interpolants} \cite{DBLP:conf/apn/McMillan05,McMillan06,McMillan11} and are typically obtained by reprocessing the proof of unsatisfiability from the SMT solver.
One difficulty with that approach is that not all interpolants are equally interesting: one seeks interpolants that not only prove that an individual sequence of statements leading to a bad state is infeasible, but that generalize well and can be used in a proof that many sequences of statements leading to a bad state are infeasible, hopefully leading to a proof that no sequence can lead to a bad state.

Generating good interpolants from purely arithmetic problems is already a difficult problem, and generating good universally quantified interpolants on array properties has proved even more challenging \cite{JhalaM07,AlbertiBGRS14,Alberti_Monniaux_SAC-SVT2015}.

\subsection{Acceleration}
It is possible to compute exactly the transitive closure of some transition relations, and thus to summarize some loop exactly. The class of transition relations supported is however restricted.

\citet{BozgaHIKV09} have proposed a method for accelerating certain transition relations involving actions over arrays, which outputs the transitive closure in the form of a \emph{counter automaton}.
Translating the counter automaton into a first-order formula expressing the array properties however results in a loss of precision.



\section{Conclusion and perspectives}
\label{sec:conclusion}
We have proposed a generic approach to abstract programs and universal properties over arrays (and, more generally, arbitrary maps) by syntactic transformation into a system of Horn clauses without arrays, which is then sent to a solver.
This transformation is powerful enough that it can be used to prove, fully automatically and within minutes, that the output of selection sort is sorted and is a permutation of the input.

While some solvers have difficulties with the kind of Horn systems that we generate, some (e.g. \soft{Spacer}) are capable of solving them quite well.
We have used the stock version of the solvers, without help from their designers or special tuning, thus higher performance is to be expected in the future.
Indeed, we feel the kind of systems we generate would make good benchmarks for Horn solvers.
If the solver cannot find the invariants on its own, it can be helped by partial invariants from the user.
Also, if it finds a counterexample in the abstraction, we propose a method for reconstructing a concrete counterexample (Sec.~\ref{sec:counterexample}) or triggering a refinement.

\paragraph{Existentials}
Our approach can be used, \emph{a fortiori}, to prove or infer quantifier-free properties, but not existentials. Future work could include quantifier instantiation heuristics for existentials.

\paragraph{Backward analysis}
Our rules are for ``forward analysis'': they express that if configuration is possible at one step during one execution, then some configuration may be possible at the next step during that execution.
We thus define a super-set of all states reachable from program initialization, and the desired property is proved if this set is included in the property.

An alternative approach is ``backward analysis'': find a super-set of the set of all states reachable from a property violation, such that this set has empty intersection with the initial states.
A possible research direction would be to derive backward rules and compare their efficiency to that of forward rules.

\paragraph{Procedures}
One approach to procedures is to consider a call to a procedure as jump to the first node of the callee and a return as a jump back to each possible caller node.
Because this mixes together all calls to the same procedure, it can lose a lot of precision; some tracking variables, abstracting the stack (in the simplest case, the topmost call site), may be added to avoid precision loss.
Such an approach may be immediately combined with ours.

In contrast, some other approaches encode procedures (or other program fragments, such as the loop bodies) as binary input/output relations over the variable state --- or, rather, the fragment of the state that may be read or written by the procedure. This maps well to Horn clauses: in the solution of the solver, the predicate associated to a procedure summarizes its action.
How to combine this vision with our approach is a topic for future research.

\paragraph{High-level maps and sets}
Many programming languages provide libraries for finite maps and (multi)sets. In this article, we have explained how to abstract some, but not all of their features (Sec.~\ref{sec:simple_sets}) --- for instance we do not provide an iterator for non-integer set element types.
Future work should include reviewing their features and common usage in order to design suitable abstractions.

\paragraph{Query-less analysis} One advantage of some of earlier approaches (the abstract interpretation ones from Sec.~\ref{sec:related_absint} and the program transformation from \citet{Monniaux_Alberti_SAS2015}) is that they are capable of inferring what a program does, or at least a meaningful abstraction of it (e.g. ``at the end of this program all cells in the array  contains '')  as opposed to merely proving a property supplied by the user.
Our approach can achieve this as well, \emph{provided it is used with a Horn clause solver that does not require queries} and still provides some interesting solution (a query-less Horn problem has a trivial, uninteresting solution: ``true'' to all predicates).

This Horn clause solver should however be capable of generating disjunctive properties (e.g. ); thus a simple approach by abstract interpretation of the Horn clauses in, say, a sub-class of the convex polyhedra, will not do.
We know of no such Horn solver; building one is an interesting research challenge.
Maybe certain partitioning approaches used in sequential program verification \cite{DBLP:journals/toplas/RivalM07,HenryMM12} may be transposed to Horn clauses.

We have expressed an abstraction of the semantics of programs with array reads and writes into a system of Horn clauses on scalar variables.
Another approach would be to directly work from Horn clauses on array variables, and over-approximate the rules and under-approximate the queries into an array-free Horn problem.
\smallskip

\paragraph{Objects} We have considered simple programs operating over arrays or maps, as opposed to a real-life programming language with objects, references or, horror, pointer arithmetic. Yet, our approach can be adapted to such languages.
\lstset{language=Java}
One can indeed see each object field name in a language such as Java (e.g. \lstinline|String x;|) as a map from object references to values (here, of type \lstinline|String|).
The reference may be an index (perhaps  if the object is the -th object allocated) or a more complex record of the site of allocation.

\paragraph{Pointers} Languages with pointers, pointer arithmetic and, worse, access to an object of a type through a pointer of an incompatible type (not uncommon in traditional C programming), can be handled by seeing the memory as an array of bytes, but this leads to impractically inefficient analysis.
It is however often possible to segment the memory into independent variables (never accessed through pointers, or at least accessed only through pointers at known locations) and a number of disjoint arrays.
Our analysis can then be used over these arrays.

\printbibliography

\newpage
\appendix

\section{Horn clause problems}
\lstinputlisting[language=SMT,caption={Array fill 1D},label=Horn:array_fill1]{examples/array_fill1/array_fill1_abstracted.smt2}

\lstinputlisting[language=SMT,caption={Array fill 1D, even-odd},label=Horn:array_fill1_even_odd]{examples/array_fill1_even_odd/array_fill1_even_odd_abstracted.smt2}

\lstinputlisting[language=SMT,caption={Array reverse},label=Horn:array_reverse_once1]{examples/array_reverse_once1/array_reverse_once1_abstracted.smt2}

\lstinputlisting[language=SMT,caption={Real-index maps},label=Horn:real_indexed_maps]{examples/real_indexed_maps.smt2}

\lstinputlisting[language=SMT,caption={Array fill 2D},label=Horn:array_fill2]{examples/array_fill2/array_fill2_abstracted.smt2}

\lstinputlisting[language=SMT,caption={Find minimum},label=Horn:find_minimum]{examples/find_minimum/find_minimum_abstracted1.smt2}

\lstinputlisting[language=SMT,caption={Selection sort: sortedness},label=Horn:selection_sort_sortedness]{examples/selection_sort/selection_sort_abstracted2.smt2}

\lstinputlisting[language=SMT,caption={Selection sort: permutation},label=Horn:selection_sort_multiset]{examples/selection_sort/selection_sort_multiset.smt2}

\end{document}