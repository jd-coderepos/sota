\documentclass[11pt]{article}

\usepackage{fullpage}
\usepackage{amsmath,amssymb,authblk}
\usepackage{graphicx}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{algorithmic}
\usepackage{tabularx}



\newtheorem{theorem}{Theorem}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{conjecture}{Conjecture}
\newtheorem{cor}[theorem]{Corollary}
\newtheorem{prop}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{sublemma}[theorem]{Sublemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{definition}{Definition}
\newtheorem{openq}{Open Question}
\newtheorem{proof}[theorem]{Proof}

\newcommand{\junk}[1]{}



\newcommand {\proofsketch} {{\sc Proof Sketch: }}

\newcommand{\eat}[1] {}
\newcommand{\disjoint}{{distinct}}

\newcommand{\untouched}{\mathrm{UNTOUCHED}}
\newcommand{\rest}{\mathrm{REST}}
\newcommand{\order}{\mathrm{ORDER}}
\newcommand{\num}{\mathrm{num}}
\newcommand{\self}{\mathrm{self}}
\newcommand{\borrowed}{\mathrm{borrowed}}
\newcommand{\qed} {\hfill}

\newcommand{\inc}[1]{(\protect\refstepcounter{#1}\arabic{#1})}


\newcommand{\abs}[1]{\left| #1 \right|}

\newcommand{\ceiling}[1]{{{\lceil {#1} \rceil}}}
\newcommand{\floor}[1]{{{\lfloor {#1} \rfloor}}}





\newcommand{\delminus}[1]{{\delta^{-}({#1})}}
\newcommand{\delplus}[1]{{\delta^{+}({#1})}}
\newcommand{\eps}{\varepsilon}

\newcommand{\boa}{\mathrm{BOA}}
\newcommand{\bopa}{\mathrm{BOPA}}
\newcommand{\mbdst}{\mathrm{MBDST}}
\newcommand{\lp}{\mathrm{LP}}
\newcommand{\ip}{\mathrm{IP}}
\newcommand{\bfs}{\mathrm{BFS}}
\newcommand{\DAG}{\mathrm{DAG}}
\newcommand{\np}{\mathrm{NP}}
\newcommand{\pcp}{\mathrm{PCP}}
\newcommand{\sndp}{\mathrm{SNDP}}
\newcommand{\negr}{{\mathrm{NEG}_r}}

\newcommand{\knp}{{\mathrm{Knapsack}}}
\newcommand{\umkp}{{\mathrm{UMK}}}
\newcommand{\yes}{{\mathrm{YES}}}

\newcommand{\negra}{{\mathrm{NEG}_{r1}}}
\newcommand{\negrb}{{\mathrm{NEG}_{r2}}}
\newcommand{\opt}{{\mathrm{OPT}}}
\newcommand{\sol}{{\mathrm{SOL}}}

\newcommand{\poly}{{\tt poly}}
\newcommand{\mst}{\mathrm{MST}}
\newcommand{\T}{{\cal T}}
\newcommand{\U}{{\cal U}}
\newcommand{\J}{{\cal J}}
\newcommand{\reminc}{{\mathrm{REMOVE-INCOMING}}}

\newcommand{\gres}{G_{\rm res}}
\newcommand{\gresprime}{G'_{\rm res}}

\newcommand{\eplus}{E_{+}}
\newcommand{\eminus}{E_{-}}
\newcommand{\ezero}{E_0}
\newcommand{\eplusminus}{E_{\pm}}


\newcommand{\delminusargs}[2]{{\delta^{-}_{#2}({#1})}}
\newcommand{\delplusargs}[2]{{\delta^{+}_{{#2}}({#1})}}

\newcommand{\ocgs}{{\mathrm{oc}(G-S)}}
\newcommand{\Ocgs}{{\mathrm{OC}(G-S)}}
\newcommand{\igs}{{\mathrm{i}(G-S)}}
\newcommand{\Igs}{{\mathrm{I}(G-S)}}
\newcommand{\cgs}{{\mathrm{c}(G-S)}}

\newcommand{\gbip}{G_{\mathrm{bip}}}
\newcommand{\fracES}{{\frac{|E(S)|}{|S|}}}
\newcommand{\fracOcgs}{{\frac{\ocgs}{|S|}}}
\newcommand{\fracIgs}{{\frac{\igs}{|S|}}}
\newcommand{\fracCgs}{{\frac{\cgs}{|S|}}}
\newcommand{\dirDensity}{{\max_{S, T} \frac{|E(S,T)|}{\sqrt{|S||T|}}}}
\newcommand{\undirDensity}{{\max_S \fracES}}

\newcommand{\fracEST}{{\frac{|E(S,T)|}{\sqrt{|S||T|}}}}

\newcommand{\mis}{{\tt Maximum Independent Set}}
\newcommand{\scover}{{\tt Set Cover}}

\newcommand{\minstaff}{{\tt {MinStaff}}}
\newcommand{\maxstaff}{{\tt {MaxStaff}}}
\newcommand{\bicriteriamaxstaff} {{\tt {Bicriteria MaxStaff}}}
\newcommand{\linmaxstaff}{{\tt {Lin-MaxStaff}}}
\newcommand{\concavemaxstaff}{{\tt {Concave-MaxStaff}}}
\newcommand{\avl}{{\alpha}}
\newcommand{\len}{{l}}
\newcommand{\I}{{\cal I}}
\newcommand{\E}{{\cal E}}
\newcommand{\A}{{\cal A}}
\newcommand{\Opt}{{\cal O}}
\renewcommand{\S}{{\cal S}}
\newcommand{\optval}{{\tt opt}}
\newcommand{\profit}{{\tt profit}}
\newcommand{\lt}{{\tt left}}
\newcommand{\rt}{{\tt right}}
\renewcommand{\O}{{\cal O}}
\newcommand{\round}{{\tt Round}}
\newcommand{\tum}{\mathrm{TUM}}
\newcommand{\ResAll} {{\sc ResAll}}
\newcommand{\ZeroOneResAll} {{\sc (0-1)-ResAll}}
\newcommand{\MultiResAll}{{\sc MultiResAll}}
\newcommand{\PResAll}{{\sc PartialResAll}}
\newcommand{\PCResAll}{{\sc PrizeCollectingResAll}}
\newcommand{\CResAll} {{\sc CostResAll}}
\newcommand{\lspc}{{\sc LSPC}}
\newcommand{\smfc}{{\sc SMFC}}

\newcommand{\calI} {{\cal R}}
\newcommand{\calO} {{\cal O}}

\newcommand{\cO} {{\calO}}
\newcommand{\cT} {{\cal T}}

\newcommand{\cL}{{\cal L}}
\newcommand{\cM}{{\cal M}}
\newcommand{\cR}{{\cal R}}
\newcommand{\cC}{{\cal C}}
\newcommand{\cJ}{{\cal J}}

\newcommand{\OptSol}{{\sc Opt}}
\newcommand{\lptr}{{\em l-ptr}}
\newcommand{\rptr}{{\em r-ptr}}
\newcommand{\ljob}{{\em l-job}}
\newcommand{\rjob}{{\em r-job}}
\newcommand{\comment}[1]{}
\newcommand{\prof}{\mathrm{prof}}

\newcommand{\sh} {{\rm sh}}
\newcommand{\calL} {{\cal L}}
\newcommand{\calT} {{\cal T}}
\newcommand{\calM} {{\cal M}}
\newcommand{\cA} {{\cal A}}
\newcommand{\calA} {\cA}
\newcommand{\cB} {{\cal B}}
\newcommand{\DP} {{\rm DP}}
\newcommand{\ceil}[1] {\lceil #1 \rceil}
\newcommand{\wh}[1] {\widehat{#1}}
\newcommand{\wt}[1] {\widetilde{#1}}


\title{Scheduling Resources for Executing a Partial Set of Jobs}

\author[1]{Venkatesan T. Chakaravarthy}
\author[2]{Arindam Pal}
\author[1]{Sambuddha Roy}
\author[1]{Yogish Sabharwal}
\affil[1]{IBM Research Lab, New Delhi, India\\
  \texttt{\{vechakra,sambuddha,ysabharwal\}@in.ibm.com}
}
\affil[2]{Indian Institute of Technology, New Delhi.\\
\texttt{arindamp@cse.iitd.ernet.in}
}

\begin{document}

\maketitle

\begin{abstract}
In this paper, we consider the problem of choosing a minimum cost set of resources for executing
 a specified set of jobs. 
 Each input job is an interval, determined by its start-time and end-time. Each resource is also an interval determined by its start-time and end-time; moreover, every resource has a capacity and a cost associated with it. 
We consider two versions of this problem. 

In the partial covering version, 
we are also given as input a number , specifying the number of jobs that must be performed. The goal is to choose  jobs and find a minimum cost set of resources to perform the chosen  jobs (at any point of time the capacity of the chosen set of resources should be sufficient to execute the jobs active at that time). We present an -factor approximation algorithm for this problem. 

We also consider the prize collecting version, wherein every job also has a penalty 
associated with it. The feasible solution consists of a subset of the jobs, and a set of resources, 
to perform the chosen subset of jobs. The goal is to find a feasible solution that minimizes the 
sum of the costs of the selected resources and the penalties of the jobs that are not selected. 
We present a constant factor approximation algorithm for this problem.
\end{abstract}

\section{Introduction}
\label{sec:intro}
We consider the problem of allocating resources to schedule jobs. 
Each job is specified by its start-time, end-time and its demand requirement.
Each resource is specified by its start-time, end-time, the capacity it offers and its associated cost. 
A feasible solution is a set of resources satisfying the constraint that at any timeslot, 
the sum of the capacities offered by the resources is at least the demand required by
the jobs active at that timeslot, i.e., the selected resources must cover the jobs.
The cost of a feasible solution is the sum of costs of the resources picked in the solution.
The goal is to pick a feasible solution having minimum cost.
We call this the Resource Allocation problem ({\ResAll}).

The above problem is motivated by applications in cloud and grid computing.
Consider jobs that require a common resource such as network bandwidth or storage.
The resource may be available under different plans; for instance, it is common for network bandwidth to be priced
based on the time of the day to account for the network usage patterns during the day. 
The plans may offer different capacities of the resource at different costs.
Moreover, It may be possible to lease multiple units of the resource under some plan by paying a cost
proportional to the number of units.

Bar-Noy et al. \cite{Bar-Noy} presented a -approximation algorithm for the {\ResAll} problem
(See Section 4 therein).
We consider two variants of the problem.
The first variant is the partial covering version. In this problem, the input also specifies a number  and
a feasible solution is only required to cover  of the jobs.
The second variant is the prize collecting version wherein each job has a penalty associated with it;
for every job that is not covered by the solution, the solution incurs an additional cost, 
equivalent to the penalty corresponding to the job.
These variants are motivated by the concept of service level agreements (SLA's), 
which stipulate that a large fraction of the client's jobs are to be completed. 
We study these variants for the case where the demands of all the jobs are uniform (say  unit)
and a solution is allowed to pick multiple copies of a resource by paying proportional cost.
We now define our problems formally.

\subsection{Problem Definition}
We consider the timeline  to be uniformly divided into discrete intervals ranging from  to .
We refer to each integer  as a {\it timeslot}.
The input consists of a set of  {\em jobs} , and a set of {\em resources} .

Each job  is specified by an interval , where  and  are the {\em start-time} and {\em end-time}
of the job . We further assume that  and  are integers in the range  for every job .
While the various jobs may have different intervals associated with them, we consider all the jobs to have
{\em uniform} demand requirement, say  unit. 

Further, each resource  is specified
by an interval , where  and  are the {\em start-time} and the {\em end-time}
of the resource ; we assume that  and  are integers in the range . 
The resource  is also associated with a {\em capacity}  and a cost ; we
assume that  is an integer. 
We interchangeably refer to the resources as {\em resource intervals}.
A typical scenario of such a collection of jobs and resources is shown in Figure~\ref{fig:cc}.


\begin{figure*}[t]
\begin{center}
\fbox{
\includegraphics[scale=0.25]{fig3.pdf}
}
\end{center}
\caption{Illustration of the input}
\label{fig:cc}
\end{figure*}

We say that a job  (resource ) is {\it active} at a timeslot , 
if  (); we  denote this as  ().
In this case, we also say that  (or ) {\em spans} .



We define a {\em profile}  to be a mapping that assigns an integer value 
to every timeslot. For two profiles,  and ,  is said to {\em cover} , 
if  for all .
Given a set  of jobs, the profile  of  is defined to be the mapping determined by 
the cumulative demand of the jobs in , i.e. .
Similarly, given a multiset  of resources, its profile is: 
(taking copies of a resource into account). 
We say that  {\em covers}  if  covers . 
The cost of a multiset of resources  is defined to be the sum of the costs of all the resources 
(taking copies into account).

We now describe the two versions of the problem.
\begin{itemize}
\item  {\PResAll}: In this problem, the input also specifies a number  (called the {\em partiality parameter})
       that indicates the 
	number of jobs to be covered. A feasible solution is a pair  where  is a multiset of resources
	and  is a set of jobs such that  covers  and .
	The problem is to find a feasible solution of minimum cost.
\item  {\PCResAll}: In this problem, every job  also has a penalty  associated with it.
	A feasible solution is a pair  where  is a multiset of resources
	and  is a set of jobs such that  covers .
	The cost of the solution is the sum of the 
	costs of the resources in  and the penalties of the jobs not in .
	The problem is to find a feasible solution of minimum cost.
\end{itemize}
Note that in both the versions, multiple copies of the same resource can be picked
by paying the corresponding cost as many times.





\subsection{Related Work and Our Results}
Our work belongs to the space of {\em partial} covering problems, which are a 
natural variant of the corresponding full cover problems. There is a significant body of work 
that consider such problems in the literature, for instance, see \cite{Garg05,Bar01,JV01,KPS11,GKS04}.

In the setting where resources and jobs are embodied as intervals, the objective of finding a minimum cost collection of
resources that fulfill the jobs is typically called the {\em full cover} problem. Full cover problems in the interval context have 
been dealt with earlier, in various earlier works \cite{Bar-Noy,bhatia07,cgk10}. Partial cover 
problems in the interval context have been considered earlier in \cite{esa2011}.
\begin{quote}
{\bf Our Main Result}.
We present an  approximation for the {\PResAll} problem, where
 is the number of jobs and  is the number of resources respectively.
\end{quote}
The work in existing literature that is closest in spirit to our result is that of
Bar-Noy et al.\cite{Bar-Noy}, and Chakaravarthy et al.\cite{esa2011}.
In \cite{Bar-Noy}, the authors consider the full cover version, and present 
a -approximation algorithm. In this case, all the jobs are to be covered, 
and therefore the demand profile to be covered is fixed. The goal is to find the 
minimum cost set of resources, for covering this profile. 
In our setting, 
we need to cover only  of the jobs. 
A solution needs to select  jobs to be covered in such a manner 
that  the resources required to cover the resulting demand profile has minimum cost.  

In \cite{esa2011}, the authors consider a scenario, wherein the 
timeslots have demands and a solution must satisfy the demand for at least  of the timeslots. 
In contrast, in our setting, a solution needs to satisfy  {\em jobs}, wherein 
each job can span multiple timeslots. 
A job may not be completely spanned by any resource, and thus may require
{\em multiple} resource intervals for covering it.  

We also show a constant factor approximation algorithm for the {\PCResAll} problem, by reducing it 
to the zero-one version of the {\ResAll} problem. 
Jain and Vazirani \cite{JV01} provide a general framework for achieving approximation algorithms for partial 
covering problems, wherein the prize collecting version is considered. In this framework, under suitable conditions, 
a constant factor approximation for the prize collecting version implies a constant factor approximation
for the partial version as well. However, their result applies only when the prize collecting algorithm has a
 certain strong property, called the {\em Lagrangian Multiplier Preserving} (LMP) property. 
While we are able to achieve a constant factor approximation for the {\PCResAll} problem, 
our algorithm does not have the LMP property. Thus, the Jain-Vazirani framework does not apply 
to our scenario. 

\section{Outline of the Main Algorithm}
\label{sec:overview}
In this section, we outline the proof of our main result:

\begin{theorem}
\label{thm:xAAA}
There exists an -approximation algorithm for the {\PResAll} problem,
where  is the number of jobs and  is the number of resources.
\end{theorem}

The proof of the above theorem goes via the claim that the input set of jobs can be 
partitioned into a logarithmic number of {\em mountain ranges}. 
A collection of jobs  is called a {\em mountain} if there exists a timeslot , such that
all the jobs in this collection span the timeslot ; the specified timeslot where the jobs 
intersect will be called the {\em peak} timeslot of the mountain (see Figure~\ref{fig:aa};
jobs are shown on the top and the profile is shown below).
The justification for this linguistic convention is that if we look at the profile of such a 
collection of jobs, the profile forms a bitonic sequence, increasing in height until the peak, and 
then decreasing. 
The {\em span} of a mountain is the interval of timeslots where any job in the mountain is active.  
A collection of jobs  is called a {\em mountain range}, if the jobs can be partitioned into 
a sequence  such that each  is a mountain and the spans of any two mountains 
are non-overlapping (see Figure \ref{fig:bb}).
The decomposition lemma below shows that the input set of jobs can be partitioned into a logarithmic number
of mountain ranges.  For a job  with 
start- and end-times  and , let its {\em length} be ). 
Let   be the shortest job length, and  the longest job length. 
The proof of the lemma is inspired by the algorithm for the Unsplittable Flow Problem on 
a line, due to Bansal et al.~\cite{BansalFKS09}, and it is given in Appendix \ref{sec:DDD}.

\begin{figure}[t!]
\begin{minipage}{0.4\linewidth}
\centering
\includegraphics[width=1in]{figa.pdf}
\caption{
A Mountain 
}
\label{fig:aa}
\end{minipage}
\centering
\begin{minipage}{0.55\linewidth}
\includegraphics[width=2.5in]{figb.pdf}
\caption{
A Mountain Range 
}
\label{fig:bb}
\end{minipage}
\end{figure}

\begin{lemma}
\label{lem:XXX}
The input set of jobs can be partitioned into groups, , such that 
each  is a mountain range and .
\end{lemma}

Theorem~\ref{thm:xCCC} (see below) provides a -approximation algorithm (where  is a constant) for the special
case where the input set of jobs form a single mountain range. 
We now prove Theorem \ref{thm:xAAA}, assuming Lemma \ref{lem:XXX} and Theorem \ref{thm:xCCC}. 

\par\noindent
{\bf Proof of Theorem~\ref{thm:xAAA}.}
Let  be the input set of jobs,  be the input set of resources and  be the partiality parameter.
Invoke Lemma \ref{lem:XXX} on the input set of jobs  and obtain a partitioning of 
into mountain ranges , where .
Theorem \ref{thm:xCCC} provides a -approximation algorithm  for the {\PResAll} problem wherein
the input set of jobs form a single mountain range, where  is some constant.
We shall present a -approximation algorithm for the {\PResAll} problem.

For  and , let  denote the 
cost of the (approximately optimal) solution returned by the algorithm in Theorem \ref{thm:xCCC}
with  as the input set of jobs,  as the input set of resources and 
as the partiality parameter.
Similarly, let  denote the cost of the optimal solution for covering  of the jobs in the 
mountain range . Theorem~\ref{thm:xCCC} implies that .

The algorithm employs dynamic programming. 
We maintain a -dimensional DP table . 
For each  and ,
the entry  would 
store the cost of a (near-optimal) feasible solution
covering  of the jobs from .
The entries are calculated as follows.


The above recurrence relation considers covering  jobs from the mountain , 
and the remaining   jobs from the mountain ranges .
Using this dynamic program, we compute a feasible solution to the original problem instance 
(i.e., covering  jobs from all the mountain ranges );
the solution would correspond to the entry .
Consider the optimum solution  to the original problem instance. 
Suppose that  covers  jobs from the mountain range  (for ), 
such that . 
Observe that 

where the first statement follows from the construction of the dynamic programming table
and the second statement follows from the guarantee given by algorithm .
However the maximum of  (over all ) is a lower bound for 
(we cannot say anything stronger than this since  might 
use the same resources to cover jobs across multiple subsets ). 
This implies that . This proves
the -approximation ratio. 

\begin{theorem}
\label{thm:xCCC}
There exists a constant factor approximation algorithm for the special case of the {\PResAll} problem,
wherein the input set of jobs form a single mountain range .
\end{theorem}

The first step in proving the above theorem is to design an algorithm for handling the special case where the input set of jobs
form a single mountain. This is accomplished by the following theorem. The proof is given in 
Section \ref{sec:mountain}.

\begin{theorem}
\label{thm:xDDD}
There exists an -approximation algorithm for the special case of the {\PResAll} problem
wherein the input set of jobs for a single mountain .
\end{theorem}

We now sketch the proof of Theorem \ref{thm:xCCC}. 
Let the input mountain range be  consisting of mountains .
The basic intuition behind the algorithm is to ``collapse'' each mountain  into a single timeslot. 
A resource interval  is said to intersect a mountain  if the interval  and the span of 
 overlap; the resource  is said to {\em fully span} the mountain , if 
the span of  is contained in the interval ; the resource  is said to
be contained in the mountain , if the interval  is contained in the span of .
It may be possible that for a resource interval  and a mountain ,
neither  fully spans  nor is  contained in .
However, at a factor three loss in the approximation ratio, we can transform an input instance into an instance
satisfying the following property. The resource intervals in the modified instance can be 
classified into two categories: (1) {\em narrow} resources  having the property
that the interval  is contained in the span of a specific single mountain ;
(2) {\em wide} resources  having the property that 
if  intersects any mountain , then it fully spans the mountain. 

The notion of collapsing mountains into timeslots is natural when the input instance 
consists only of wide resources. 
This is because we can collapse the mountains  into timeslots .  
Furthermore, for each wide resource , consider the sequence of mountains 
 (for some ) that are fully spanned by the resource ;
then we represent  by an interval that spans the timeslots . 
However, the case of narrow resources is more involved
because a narrow resource does not fully span the mountain containing it. 
Based on the above intuition, we define a problem called the {\em Long Short Partial Cover} (\lspc).
The algorithm for handling a mountain range goes via a reduction to the {\lspc} problem.

{\it  Problem Definition (\lspc):} 
We are given a demand profile over a range , 
which specifies an integral demand  at each timeslot .
The input resources are of two types, {\em short} and {\em long}. 
A short resource spans only one timeslot, whereas a long resource can span one or more timeslots.
Each resource  has a cost  and a capacity . 
The input also specifies a {\em partiality parameter} . 
A feasible solution  consists of a multiset of resources  and a coverage profile.
A {\em coverage profile} is a function that assigns
an integer  for each timeslot  satisfying .
The solution should have the following properties: 
(i) ;
(ii) at any timeslot , the sum of capacities of the resource intervals from  active at  is at least ;
(iii) for any timeslot , at most one of the short resources spanning the timeslot  
is picked (however, multiple copies of a long resource may be included). 
The objective is to find a feasible solution having minimum cost. 
See Figure~\ref{fig:dd} for an example (in the figure, short resources are shaded).

\begin{figure*}[t]
\begin{center}
\fbox{
\includegraphics[width=1.5in]{fig4.pdf}
}
\end{center}
\caption{The {\lspc} problem}
\label{fig:dd}
\end{figure*}

The advantage with the {\lspc} problem is that the demands are restricted to single timeslots; in contrast,
in the {\PResAll} problem, the demands or jobs can span multiple timeslots.
Theorem \ref{thm:xEEE} (see below) shows that the {\lspc} problem can be approximated within a factor of .
The reduction from the {\PResAll} problem restricted to a single mountain range 
(as in Theorem \ref{thm:xCCC}) to the {\lspc} problem goes by representing each mountain in the input mountain
range  by a single timeslot in the {\lspc} instance; 
the wide resources will correspond to long resources in the {\lspc} instance.
The reduction handles the narrow resources using the short resources; the
constraint (iii) in the {\lspc} problem definition is crucially employed in this process.
The reduction from the case of single mountain range to the {\lspc} problem 
shown in Appendix~\ref{app:red} and Theorem~\ref{thm:xCCC} is proved there.





\begin{theorem}
\label{thm:xEEE}
There exists a -approximation algorithm for the {\lspc} problem.
\end{theorem}

The algorithm claimed in the above theorem is inspired by the work of \cite{esa2011}. In that paper, the authors
study a variant of the problem; in that variant,
there are only long resources and a solution  must satisfy a set of 
timeslots , where a timeslot 
is satisfied, if the sum of capacities of the resources in  active at 
is at least the demand ; a solution is allowed to pick multiple copies of any resource (both long and short). 
The {\lspc} problem differs in two ways: first, a solution can satisfy the demand at a timeslot partially
and secondly, only one copy of a short resource can be picked.
These two differences give rise to complications and as a result, our algorithm is more involved.
The algorithm is provided in Section \ref{sec:lspc}.\\

\noindent
{\bf Organization of the paper:}
Lemma~\ref{lem:XXX} is proved in Appendix~\ref{sec:DDD}.
Theorem~\ref{thm:xDDD} and Theorem~\ref{thm:xEEE} are
proved in Section~\ref{sec:mountain} and Section~\ref{sec:lspc} respectively.
Assuming Theorem~\ref{thm:xEEE}, we prove Theorem~\ref{thm:xCCC} 
in Appendix~\ref{app:red}. 

\section{A Single Mountain: Proof of Theorem~\ref{thm:xDDD}}
\label{sec:mountain}
In this section, we give an -factor approximation algorithm for the case of the {\PResAll} problem,
where the input jobs form a single mountain. 

The basic intuition is as follows. Given the structure of the jobs, we will show that there is a
{\em near-optimal} feasible solution that exhibits a nice property: 
the jobs discarded from the solution are extremal either in their
start-times or their end-times. 

\begin{lemma}
\label{BBB}
Consider the {\PResAll} problem for a single mountain.
Let  be the input set of jobs.
Let  be a feasible solution such that  covers the set of jobs  with . 
Let  denote its cost.
Let  denote the jobs in increasing order of their start-times.
Similarly, let  denote the jobs in decreasing order of their end-times.
Then, there exists a feasible solution  having cost at most  such that

for some  where .
\end{lemma}
\begin{proof}
We give a constructive proof to determine the sets  and .


We initialize the set =. At the end of the algorithm, 
the set  will be the desired set of jobs covered by the solution.
The idea is to remove the jobs that extend most to the right or the left from the consideration of .
The most critical aspect of the construction is to ensure that whenever we exclude any job from consideration
of  that is already part of , we do so in pairs of the leftmost and rightmost extending jobs of 
that are still remaining in . 
We terminate this process when the size of  equals the size of , i.e., .
We also initialize the set . 
At the end of the algorithm, this set will contain the set of jobs removed from  that belonged to 
while constructing .

We now describe the construction of  formally.
We maintain two pointers {\lptr} and {\rptr}; {\lptr} indexes the jobs in the sequence  
and {\rptr} indexes the jobs in the sequence .
We keep incrementing the pointer {\lptr} and removing the corresponding job from  
(if it has not already been removed) until either the size of  reaches  
or we encounter a job (say {\ljob}) in  that belongs to ;  we do not yet remove the job {\ljob}.
We now switch to the pointer {\rptr} and start incrementing it and removing the corresponding job from  
(if it has not already been removed) until either the size of  reaches  
or we encounter a job (say {\rjob}) in  that belongs to ;  we do not yet remove the job {\rjob}.
If the size of  reaches , we have the required set . 

Now suppose that .
Note that both {\lptr} and {\rptr} are pointing to jobs in .
Let {\ljob} and {\rjob} be the jobs pointed to by {\lptr} and {\rptr} respectively (note that 
these two jobs may be same).

We shall remove one or both of {\ljob} and {\rjob} from  and put them in . 
We classify these jobs into three categories: {\em single}, {\em paired} and {\em artificially paired}.

Suppose that .
In this case, we have to delete at least 2 more jobs; so we delete both {\ljob} and {\rjob} and add them to 
as {\em paired} jobs.
In case {\ljob} and {\rjob} are the same job, we just delete this job and add it to  as a {\em single} job.
We also increment the {\lptr} and {\rptr} pointers to the next job indices in their respective sequence.
We then repeat the same process again, searching for another pair of jobs.

Suppose that .
In case {\ljob} and {\rjob} are the same job, we just delete this job and get the required set  of size ;
We add this job to the set  as a {\em single} job.
On the other hand, if {\ljob} and {\rjob} are different jobs,
we remove {\ljob} from  and add it to  as {\em artificially paired} with
its pair as the job {\rjob} ; note that we do not remove {\rjob} from .

This procedure gives us the required set .
We now construct  by simply doubling the resources of ; meaning, that for each 
resource in , we take twice the number of copies in . 
Clearly .
It remains to argue that  covers .
For this, note that  and hence  (because ).
We create an arbitrary bijection .
Note that  can be obtained from  by deleting the jobs in  and adding the jobs of .

We now make an important observation:
\begin{observation}
\label{obs1}
For any {\em paired} jobs or {\em artificially paired} jobs ,  added to , 
all the jobs in  are contained within the
span of this pair, i.e., for any  in ,  and .
Similarly for any {\em single} job  added to , all jobs in  are contained in the span of .
\end{observation}

For every {\em paired} jobs, , , Observation~\ref{obs1} implies that taking 2 copies of the 
resources covering  suffices to cover .
Similarly, for every {\em single} job , the resources covering  suffice to cover .
Lastly for every {\em artificially paired} jobs  where  and , taking 2 copies
of the resources covering  suffices to cover .

Hence the set  obtained by doubling the resources  (that cover ) suffices to cover the jobs in .
\end{proof}

Recall that Bar-Noy et al.~\cite{Bar-Noy} presented a -approximation algorithm for 
the {\ResAll} problem (full cover version). Our algorithm for handling a single mountain works
as follows. 
Given a mountain consisting of the collection of jobs  and the number , 
do the following for all possible pairs of numbers  such that the set 
 defined as per Equation~\ref{eqn:aa} in Lemma~\ref{BBB} has size .
For the collection of jobs , consider the issue of selecting a minimum cost set of 
resources to cover these jobs; note that this is a full cover problem. Thus, the -approximation
of \cite{Bar-Noy} can be applied here. 
Finally, we output the best solution across 
all choices of .  Lemma~\ref{BBB} shows that this is an -factor approximation
to the {\PResAll} problem for a single mountain. 

\section{{\lspc} Problem: Proof of Theorem \ref{thm:xEEE}}
\label{sec:lspc}
Here, we present a -approximation algorithm for the {\lspc} problem.

We extend the notion of profiles and coverage to ranges contained within . 
Let  contained in  be a timerange. 
By a profile over , we mean a function  that assigns a value  to each timeslot . 
A profile  defined over a range  is said to be {\em good}, if for all timeslots ,
 (where  is the input demand at ).
In the remainder of the discussion, we shall only consider good profiles and so, we shall simply write
``profile'' to mean a ``good profile''.
The {\em measure} of  is defined to be the sum  .

Let  be a multiset of resources and let  be a profile over a range of timeslots .
We say that  is {\em good}, if it includes at most one short resource active at any timeslot .
We say that  covers the profile , 
if for any timeslot , the sum of capacities of resources
in  active at  is at least . 
Notice that  is a feasible solution to the input problem instance,
if there exists a profile  over the entire range  such that 
 has measure  and  is a cover for .
For a timeslot , let 
denote the capacity of the unique short resource from  active at , if one exists; otherwise, 
.

Let  be a good multiset of resources and let  be a profile over a range of timeslots . 
For a long resource , let  denote the number of copies of  included in .
The multiset  is said to be a {\em single long resource assignment cover} (SLRA cover) for ,
if for any timeslot , there exists a long resource  such that
 (intuitively, the resource  can cover the residual demand by itself,
even though other long resources in  may be active at ).

We say that a good multiset of resources  is an {\em SLRA solution} to the input {\lspc} problem instance,
if there exists a profile  over the range  having measure  such that  is an SLRA cover for .
The lemma below shows that near-optimal SLRA solutions exist.

\begin{lemma}
\label{lem:SLRA}
Consider the input instance of the {\lspc} problem.
There exists an SLRA solution having cost at most 16 times the cost of the optimal solution.
\end{lemma}

The lemma follows from a similar result proved in \cite{esa2011} and
the proof is deferred to Appendix~\ref{sec:lspcdetails}.
Surprisingly, we can find the {\em optimum} SLRA solution  in polynomial time, 
as shown in Theorem~\ref{thm:xGGG} below.
Lemma \ref{lem:SLRA} and Theorem \ref{thm:xGGG} imply that 
 is a -factor approximation to the optimum solution.
This completes the proof of Theorem~\ref{thm:xEEE}.

\begin{theorem}
\label{thm:xGGG}
The optimum SLRA solution  can be found in time polynomial in the number of resources,
number of timeslots and , where .
\end{theorem}

The rest of the section is devoted to proving Theorem~\ref{thm:xGGG}.
The algorithm goes via dynamic programming.
The following notation is useful in our discussion.
\begin{itemize}
\item
Let  be a good set consisting of only short resources, and let  be a range.
For a profile  defined over , 
  is said to be an {\em -free cover} for , if for any ,
.
The set  is said to be an {\em -free -cover} for ,
if there exists a profile  over   such that  has measure  and 
is a -free cover for .
\item 
Let  be a good multiset of resources and let  be a range.
For a profile  defined over , 
the multiset  is said to be an {\em -free SLRA cover} for , 
if for any timeslot  satisfying , 
there exists a long resource  such that .
For an integer , we say  is an {\em -free SLRA -cover} for the range ,
if there exists a profile  over  such that  has measure  and 
is a -free SLRA cover for .
\end{itemize}
Intuitively,  denotes the demand covered by long resources already selected (and their cost accounted for)
in the previous stages of the algorithm; thus, 
 timeslots whose residual demand is at most  can be ignored.
The notion of ``-freeness'' captures this concept.

We shall first argue that any -free SLRA cover  for a profile  over a timerange  exhibits 
certain interesting decomposition property.
Intuitively, in most cases, the timeline can be partitioned into two parts (left and right),
and  can be partitioned into two parts  and  such that 
 can cover the left timerange and  can cover the right timerange
(even though resources in  may be active in the right timerange and those in 
may be active in the left timerange).
In the cases where the above decomposition is not possible,
there exists a long resource spanning almost the entire range.
The lemma is similar to a result proved in \cite{esa2011} (see Lemma 4 therein).
The proof is deferred to Appendix~\ref{sec:lspcdetails}.

\begin{lemma}
\label{lem:decomp}
Let  be any timerange,  be a profile over  and let  be an integer.
Let  be a good set of resources providing an -free SLRA-cover for .
Then, one of the following three cases holds:
\begin{itemize}
\item
The set of short resources in  form a -free cover for Q.
\item 
{\it Time-cut: } There exists a timeslot  and a partitioning of  into  and 
such that  is an -free SLRA-cover for  and  is an -free SLRA-cover for ,
where  and  profiles obtained by restricting  to  and , respectively.
\item
{\it Interval-cut:}
There exists a long resource 
such that the set of short resources in  forms a -free cover for both  and , where
 and   are the profiles obtained by restricting  to  and   
respectively.
\end{itemize}
\end{lemma}

We now discuss our dynamic programming algorithm.
Let  be the maximum of  the input demands. 
The algorithm maintains a table  with an entry for each triple ,
where ,  and .
The entry  stores the cost of the optimum -free SLRA -cover for the range ;
if no solution exists, then  will be .
Our algorithm outputs the solution corresponding to the entry  ; notice that 
this is optimum SLRA solution .

In order to compute the table , we need an auxiliary table .
For a triple ,  and , let  be the optimum -free -cover for ,
(using only the short resources); if no solution exists  is said to be .
We first describe how to compute the auxiliary table . 
For a triple consisting of ,  and
, define  as follows.
If , set .
Consider the case where .
If , set .
Otherwise, let  be the minimum cost short resource active at  such that ;
set ; if no such short resource exists, set .

Then, for a triple , the entry  is governed
by the following recurrence relation. Of the demand  that need to be covered,
the optimum solution may cover a demand   from the timeslot , and a demand  from the  range .
We try all possible values for  and choose the best:

It is not difficult to verify the correctness of the above recurrence relation.


\begin{figure*}
\fbox{
\begin{minipage}{0.95\textwidth}

\end{minipage}
}
\caption{Recurrence relation for }
\label{fig:formula}
\end{figure*}

We now describe how to compute the table . 
Based on the decomposition lemma (Lemma \ref{lem:decomp}), we can develop a recurrence relation 
for a triple ,  and . 
We compute  as the minimum over three quantities ,  and  corresponding to the three cases
of the lemma. Intuitive description of the three quantities is given below and precise formulas are provided
in Figure \ref{fig:formula}. In the figure,  is the set of all long resources\footnote{The input demands
 are used in computing the table }.
\begin{itemize}
\item 
{\it Case 1: } 
No long resource is used and so, we just use the 
corresponding entry of the table . 
\item
{\it Case 2: } There exists a time-cut . We consider all possible values
of . For each possible value, we try all possible ways in which  can be divided between the left and right ranges.
\item
{\it Case 3: }
There exists a long resource  such that the timeranges to the left of and to the right of
 can be covered solely by short resources.
We consider all the long resources  and also the number of copies  to be picked.
Once  copies of  are picked,  can cover all timeslots with residual demand at most
 in an SLRA fashion, and so the subsequent recursive calls can ignore these timeslots.
Hence, this value is passed to the recursive call.
We also consider different ways in which  can be split into three parts - left, middle and right.
The left and right parts will be covered by the solely short resources and the middle part will use both 
short and long resources.
Since we pick  copies of , a cost of  is added.
\end{itemize}
We set . For the base case: for any , if  or ,
then the entry is set to zero.

We now describe the order in which the entries of the table are filled.
Define a partial order  as below.
For pair of triples  and ,
we say that , if one of the following properties is true:
(i); 
(ii)  and ; 
(iii) ,  and .
Construct a directed acyclic graph (DAG)  where the triples
are the vertices and an  edge is drawn from a triple  to a triple ,
if . Let  be a topological ordering of the vertices in .
We fill the entries of the table  in the order of appearance in .
Notice that the computation for any triple  only refers to triples appearing
earlier than  in .


Using Lemma \ref{lem:decomp}, we can argue that the above recurrence relation correctly computes
all the entries of . 
For the sake of completeness, a proof is included in Appendix~\ref{sec:recur-proof}.

\section{The {\PCResAll} problem}
\label{app:pcresall}
In this section, we consider the {\PCResAll} problem. We prove the following:

\begin{theorem}
\label{DDD}
There is a -factor approximation algorithm for the {\PCResAll} problem. 
\end{theorem}
The proof proceeds by exhibiting a reduction from the {\PCResAll} problem to 
the following full cover problem.

\noindent
{\it  Problem Definition:} We are given a demand profile which specifies an integral demand  at each timeslot .
The input resources are of two types, called S-type (short for single) and M-type (short for multiple).  
A resource  has 
a capacity , and cost . A valid solution consists of a multiset of resources such that
it includes at most  copy of any S-type resource; however arbitrarily many copies of any M-type resource may be picked. A feasible solution  is a valid solution such that at any timeslot , the total 
capacity of the resources in , active at the timeslot , is at least the demand  of the timeslot.
The objective is to find a feasible solution having minimum cost. 

Call this problem the Single Multiple Full Cover ({\smfc}) problem.

The full cover problem, {\ZeroOneResAll} is considered in \cite{esa2011}. 
The {\ZeroOneResAll} problem specifies demands for 
timeslots, and feasible solutions consist of a set of resources such that every timeslot is 
fulfilled by the cumulative capacity of the resources active at that timeslot. The main 
qualification is that in this problem setting, any resource may be picked up {\em at most
once}. In \cite{esa2011},  it is shown that this problem admits a -factor
approximation algorithm. The {\smfc} problem easily reduces to the {\ZeroOneResAll} problem:
{\em S-type} resources may be picked up at most once, and keep copies of the {\em M-type}
resources so that it suffices to select any one of the copies. 
Thus the algorithm and the performance guarantee claimed in \cite{esa2011} also implies the following:
\begin{theorem}\label{EEE}
There is a -factor approximation to the {\smfc} problem. 
\end{theorem} 

We proceed to exhibit our reduction from the {\PCResAll} problem to the {\smfc} problem. 
Given an instance  of the {\PCResAll} problem, we will construct an instance  of the 
{\smfc} problem, such that any optimal solution  can be converted (at no extra
cost) into an optimal solution  for the instance . Consider any job 
in the instance ; we will create a S-type resource  in the instance  corresponding to
. The resource  will have the same length, start- and end-times as the job , and will 
have a cost  (the penalty associated with job ). The resources in instance  
will be labeled as M-type resources in the instance . The other parameters, such as 
demands at timeslots, are inherited by  from the instance . 

We show that 
any feasible solution  to the {\PCResAll} problem corresponds to a feasible solution  (of the same cost) for the {\smfc} problem. Let  denote the set of jobs that are not covered by the 
solution  (thus, the solution pays the penalty for each of the jobs in ).

The multiset of resources in  consists of the (M-type) resources that exist in the solution , and 
the S-type resources  in  corresponding to every job  in . 
Any job  that is actually covered by the set of resources in  is also covered
in the solution , and the resources utilized to cover the job are the same. A job  that is 
not covered by the resources in  pays a penalty  in the solution ; however this 
job  in  can be covered by the S-type resource  in the solution 
. Thus, the solution  is a feasible solution to the instance , and has cost 
equal to the cost of the solution . 

In the reverse direction, suppose we are given a solution  to the instance . 
We will convert the solution into a {\em standard} form, i.e. a solution in which if a 
S-type resource  (for some job ) is included, then this resource is used to 
cover job . Suppose job  is covered by some other resources in the solution 
, while resource  covers some other jobs (call this set ). We can clearly {\em exchange}
the resources between job  and the set of jobs  so that job  is covered by
resource . So we may assume that the solution  is in standard form. 
But now, given a standard form solution , we can easily construct a 
feasible solution  for the {\PCResAll} instance : if a job  in  
is covered by the S-type resource , then in , this job will not be 
covered (and a penalty  will be accrued); all jobs  in  that are 
covered by M-type resources will be covered by the corresponding resources
in .

This completes the reduction, and the proof of Theorem~\ref{EEE}.

\bibliographystyle{plain}
\bibliography{papers}

\appendix
\section{Proof of Lemma \ref{lem:XXX}}
\label{sec:DDD}
We first categorize the jobs according to their  lengths into  categories , , , where 
.
The category  consists of all the jobs with lengths in the range .
Thus all the jobs in any single category have comparable lengths: 
any two jobs  and  in the category satisfy , where 
 and  are the lengths of  and  respectively.

Consider any category  and let the lengths of the jobs in  lie in the range .
We claim that the category  can be partitioned into  groups , such that 
each  is a mountain range. 
To see this, 
partition the set of jobs  into classes  where  consists of the jobs
active at timeslot .
Note that every job belongs to some class since all the jobs have
length at least ; if a job belongs to more than one class, assign it to any one class arbitrarily.
Clearly each class  forms a mountain. 
For , let  be the union of the classes  satisfying .
Since each job has length at most , each  is a mountain range.
Thus, we get a decomposition of the input jobs into  mountain ranges.
\qed

\section{Single Mountain Range: Proof of Theorem~\ref{thm:xCCC}}
\label{app:red}
In this section, we prove Theorem~\ref{thm:xCCC} via a reduction to {\lspc}. 
The reduction proceeds in two steps. 

\subsection{First Step}
Let the input instance be , wherein the input set of jobs form a mountain range . We will transform the instance  to an instance , with some nice properties:
(1) the input set of jobs in  also form a mountain range;
(2) every resource  in the instance  is either narrow or wide (see Section~\ref{sec:overview} for the definitions);
(3) the cost of the optimum solution for the instance  is at most  times the optimal cost for
the instance ;
(4) given a feasible solution to , we can construct a feasible solution to  preserving the cost. 

Consider each resource  in  and let  (where ) be the sequence of mountains that  intersects. Clearly,  fully spans the mountains . 
We will split the resource  into at most  new resources ; we say that ,  and  
are {\em associated with} .
The resource  will fully span the mountains .
The span of the resource  is the intersection of the span of   with the mountain . Likewise, the span of the resource  is the intersection of the span of  with the 
mountain .
The capacities and the costs of ,  and  are declared to be the same as that 
of . We include  in . 
The input set of jobs and the partiality parameter , in  are identical to that of . 
This completes the reduction.

It is easy to see that the first two properties are satisfied by .
Let us now consider third property .
Given any solution  for the instance , we can construct a solution  for  as follows. 
For each copy of resource  picked in , include a single copy of ,  and  in . 
Clearly, the cost of the solution  is at most thrice that of the cost of .
Regarding the fourth property, given a solution  to , we can construct a solution  to 
as follows. Consider any resource  in  and let ,  and  be the resources in 
associated with . Let  be the number of copies of  picked by solution .
Let . Include  copies of the resource  in the solution .
It is easy to see that  is a feasible solution to  and that the cost of  is
at most the cost of .

\subsection{Second Step}
In this step we reduce the problem instance  to an {\lspc} instance , with the following properties:
(1) the cost of the optimum solution for the instance  is at most  times the optimal cost for
the instance ; 
(2) Given a feasible solution to , we can construct a feasible solution to  preserving the cost. 

\subsubsection*{Reduction}
In the instance ,  retain only the peak timeslots of the various mountains in the instance 
so that the number of timeslots in  is the same as the number of mountains  in . 
For any  peak timeslot  in the instance , let  be the number of jobs in  that are
active at the timeslot ; we assign the demand  to timeslot  in the instance . 
 For any wide resource  in , fully spanning mountains , 
create a long resource  in  with the span . The cost and capacity of  are
the same as that of . 

The narrow resources in the instance  are used to construct the short resources in the instance  
as follows.
Consider any specific mountain  in the instance  along with the collection of narrow resources  that are 
contained in the span of , and let  be the peak timeslot of . For any integer  (), 
we will apply the algorithm implied in Theorem~\ref{thm:xDDD} for the single mountain , with  as the 
partiality parameter, and the set of narrow resources  as the only resources. 
Then, Theorem~\ref{thm:xDDD} gives us a solution of cost  consisting of a multiset  of some resources in , 
that covers  of the jobs in the mountain . Corresponding to each , we will include a short 
resource  in the instance  with capacity , and cost .  
We will call the (multi)set of narrow resources  in the instance  
as {\em associated} with the short resource .  This completes the description of the instance  
of the {\lspc} problem.

\subsubsection*{Validity of the reduction}
We will now argue the validity of the reduction. 
Let us consider the first property:
the cost of the optimum solution to the instance  has cost at most  times
the cost of the optimum solution to the instance .
The following lemma is useful for this purpose.

\begin{lemma}
\label{lem:LLL}
Let  be a subset of jobs and  be multiset of resources in the instance 
such that  covers  (note that  contains only narrow or wide resources and  forms a mountain range).
Let  and  be narrow and wide resources in . Let  be a multiset 
constructed by picking twice the number of copies of each resource in .
Then,  can be partitioned into two sets  and  such that  is solely covered by the resources in 
and  is solely covered by the resources in .
\end{lemma}
\begin{proof}
For now, we assume that the mountain range comprises of a single mountain.

Let  denote the profile of the resources in  and  respectively.
Note that  is a uniform bandwidth profile having uniform height, say .
Let  be the first  jobs among all the jobs in  sorted in ascending ordered by their start-times. 
Similarly, 
let  be the first  jobs among all the jobs in  sorted in descending order by their left end-times.
Intuitively,  and  correspond to the  left-most and the  right-most jobs in the mountain. 


Let  and  denote the  left-most and  right-most jobs in the job profile  respectively
(these sets may not be disjoint). Let  and .
Let ,  and  denote the profiles of the jobs in ,  and  respectively.

Note that the profile  has height  throughout the span of the mountain whereas the profile 
 has height at most  at any timeslot. Thus  covers .

We will now show that  covers .
Note that .
We partition the timeslots into two parts:  and .
For the timeslots in , there are no jobs remaining in  for  to cover. 
For the timeslots in , we note that 
(because  comprises of the left-most  and right-most  jobs of the mountain).
Also note that the profile .
Since,  covers , this implies that  is sufficient to cover .

The proof can easily be extended to a mountain range as the mountains within a mountain range are disjoint.
\end{proof}

Let  denote the optimal solution for the problem instance ,
where  is the set of jobs picked by the solution and  is the set of resources covering  (we have ).
Let  and  be the set of narrow and wide resources in .
Apply Lemma \ref{lem:LLL} for the solution  and obtain a partition of  into  and 
along with  (covering ) and  (covering ).
Let  be the input mountain range in the instance  with peak timeslots
, respectively. Consider any mountain .
Let  be the number of jobs picked in  from the mountain .
Let  be the set of (narrow) resources from  contained within the span of .
Thus, the set of resources  cover the set of jobs in  and let .
Corresponding to the value , we would have included a short resource, say 
in the instance ; cost of  is at most  times the cost of  
(as guaranteed by Theorem \ref{thm:xDDD}).
The set of long resources in  cover at least  jobs within the mountain .

Construct a solution to the instance  by including ; 
and for each copy of a wide resource  in ,
include a copy of its corresponding long resource. Notice that this is a feasible solution to the instance .
The cost of the short resources  is at most  times the cost of 
and the cost of the long resources is the same as that of , which is at most twice that of .
Cost of  is the sum of costs of  and .
Hence, cost of the constructed solution is at most  times the cost of .

We now prove the second property:
Let  be a given a solution to the instance  of the {\lspc} problem of cost ;
the solution also provides a coverage profile,  for each timeslot  (such that ).
We produce a feasible solution  to the instance  with the same cost . 
For each long resource picked by , we retain the corresponding
wide resource in  (maintaining the number of copies).
Consider any timeslot  in the {\lspc} instance and let  be the corresponding mountain in the instance .
The solution  contains at most one short resource  active at  of capacity .
Consider the multiset of short resources  in the instance  associated with the resource .
The multiset  covers a set of  jobs contained in the mountain .
Include all these  jobs in . Choose any other  jobs contained in 
and add these to ; notice that the wide resources retained in  can cover these jobs.
This way we get a solution  for the instance .
Cost of the solution  is at most the cost of .
\\

\noindent
{\it Proof of Theorem \ref{thm:xCCC}: }
By composing the reductions given the two steps,
we get a reduction from the {\PResAll} problem on a single mountain range to the {\lspc} problem. 
The first step and the second step incur a loss in approximation of  and , respectively.
Thereby, the combined reduction incurs a loss of .
Theorem \ref{thm:xEEE} provides a -approximation algorithm for the {\lspc} problem.
Combining the reduction and the above algorithm, we get an algorithm for the {\PResAll} for a single mountain
range with an approximation ratio of .

\section{Details for {\lspc} Algorithm}
\label{sec:lspcdetails}\
In this section, we present proofs and other details omitted in the main body of the paper.

\subsection{Proof of Lemma \ref{lem:SLRA}}
The following lemma is a reformulation of Theorem 1 {in} \cite{esa2011}.
For a multiset of resources , let  denote its cost.
\begin{lemma}
\label{lem:esa-SLRA}
Let  be a multiset of long resources covering a profile  over a timerange .
Then, there exists a multiset of long resources  such that  is a SLRA cover for 
and . 
\end{lemma}

Let  be the optimum solution and let  be the profile of measure  covered by .
Let  and  be the multiset of long and short resources contained in , respectively.
Define  to be the residual profile over : .
The multiset  covers the profile . 
Invoke Lemma \ref{lem:esa-SLRA} on  and  (taking  and )
and obtain a multiset of long resources  which forms a SLRA cover for . 
Construct a new multiset , by taking the union of  and . 
Notice that  is a SLRA solution.  The cost  of  is at most 16 times the cost of .
So,  has cost at most 16 times the cost of .


\subsection{Proof of Lemma \ref{lem:decomp}}
We first extend the notion of SLRA covers to subsets of timeslots.
Let  be a set of timeslots and let  be a profile over the set .
A good multiset of resources  is said to be a SLRA cover for , 
if for any timeslot , there exists a long resource  such that 
.
The following lemma is a reformulation of a result in \cite{esa2011} (see Section 2.2 therein).

\begin{lemma}
\label{lem:esa-timecut}
Let  be a multiset consisting of only long resources. 
Let  be a profile over a non-empty set of timeslots ,
for some  and . 
Suppose  is a SLRA cover for . Then one of the following properties is true:
\begin{itemize}
\item
There exists a timeslot  and a partition of  into  and  such that
 is a SLRA cover for  and  is a SLRA cover for ,
where  and  are the profiles obtained by restricting 
to the timeslots in  and , respectively.
\item
There exists a resource  spanning all timeslots in .
\end{itemize}
\end{lemma}

We now prove Lemma \ref{lem:decomp}. 
Consider a good multiset of resources  forming a -free SLRA cover for a profile  over a range .
Define the set of timeslots :

If  is empty, then  is a -free cover for ; 
this corresponds to the first case of Lemma \ref{lem:decomp}.
So, assume .
Define a profile  over the timeslots in : for any ,
let .
Notice that  is a SLRA cover for the profile . 
Invoke Lemma \ref{lem:esa-timecut} (with )
Let us analyze the two cases of the above lemma. 
Consider the first case in Lemma~\ref{lem:esa-timecut}. 
In this case, there exists a timeslot  and a partitioning of  into  and ,
with the stated properties.
In this case, we see that  and  are -free SLRA covers
for  and , respectively. This corresponds to the second case of Lemma \ref{lem:decomp}.
Consider the second case in Lemma~\ref{lem:esa-timecut}. In this case, there exists a long resource  such that  spans
all the timeslots in . This means that any  or ,
. This corresponds to the third case of Lemma \ref{lem:decomp}.
\qed

\subsection{Correctness of the Recurrence Relation (Figure \ref{fig:formula})}
\label{sec:recur-proof}
We prove the lemma by induction on the position in which a triple appears in the topological ordering .
The base case corresponds to triples that do not have a parent in . The lemma is trivially true in this case.

Consider any triple . Let  be the optimum -free SLRA -cover for .
There exists a profile  over  such that  has measure  and  is a -free SLRA cover
for . Let us invoke Lemma \ref{lem:decomp} and consider its three cases.

Suppose the first case of the lemma is true.
Let  be the set of short resources contained in . 
Then,  is a -free cover for . Therefore .

Suppose the second case of the lemma is true.
Let  be the timeslot and  and  be the partition given by the lemma.
Let  and  be the profiles obtained by restricting  to the timeranges  and ,
respectively. Let the measures of  and  be  and , respectively.
Then  is a -free -cover for  and  is a -free -cover for .
Therefore, by induction,  
and .
In computing the quantity , we try all possible ways of partitioning the range  and dividing the number .
Hence, . Since , we see that .

Suppose the third case of lemma is true.
Let  be the long resource given by the lemma.
Let  be the set of short resources contained in  that are active at a timeslot .
Similarly, let  be the set of short resources contained in  that are active at a timeslot .
Let  be the multiset of long resources contained in  and the set of short resources contained in 
that are active at a timeslot .
Let ,  and  be the profiles obtained by restricting  to the ranges ,
 and , respectively.
The lemma guarantees that  and  are -free covers for  and  respectively.
Let ,  and  be the measures of ,  and , respectively.
We see that  and .
Let  be the number of copies of  present in .
Notice that if , then  is not a useful resource,
because  will be covering only timeslots in  with residual demands at most ;
but all such timeslots are free and need not be covered.
So, without loss of generality, assume that .
Since  spans the entire range , 
the resource  can cover all timeslots in the above range with residual demands at most .
Let . Notice that  is a -free SLRA cover for the profile .
Therefore,  is a -free -cover for the range .
Hence, by induction, .
Therefore, .

The quantity ; so 
. The proof is now complete.
\qed
\end{document}
