

\documentclass[english,runningheads,11pt]{llncs}
\usepackage{tabularx,booktabs,multirow,delarray,array}
\usepackage{graphicx,amssymb,amsmath,amssymb}
\usepackage{latexsym}

\usepackage[in]{fullpage}




\def\etal{\textsl{et~al. }}
\def\calP{\mathcal{P}}
\def\calM{\mathcal{M}}
\def\calR{\mathcal{R}}
\def\calS{\mathcal{S}}
\def\calF{\mathcal{F}}
\def\calQ{\mathcal{Q}}
\def\calD{\mathcal{D}}
\def\calV{\mathcal{V}}
\def\bay{bay(\overline{cd})}
\def\canal{canal(x,y)}
\def\st{-}
\newcommand{\Tri}{\mbox{}}
\newcommand{\hd}{\mbox{}}

\newenvironment{proof}{\noindent {\textbf{Proof:}}\rm}{\hfill \rm}
\newtheorem{observation}{Observation}



\begin{document}

\title{Two-Point  Shortest Path Queries in the Plane\thanks{A preliminary version appeared in the 30th Annual
Symposium on Computational Geometry (SoCG 2014).}}

\author{Danny Z. Chen\inst{1}\thanks{D.Z.~Chen's research was supported in part by NSF
under Grant CCF-1217906.}
\and Rajasekhar Inkulu\inst{2}\thanks{R.~Inkulu's research was supported in part by IITG startup grant.}
\and
Haitao Wang\inst{3}\thanks{Corresponding author. H.~Wang's research was supported in part by NSF under Grant CCF-1317143.}
}

 \institute{
 Department of Computer Science and Engineering\\
 University of Notre Dame, Notre Dame, IN 46556, USA\\
 \email{dchen@nd.edu}
 \and
Department of Computer Science and Engineering \\
 Indian Institute of Technology Guwahati, Guwahati 781039, Assam, India \\
\email{rinkulu@iitg.ac.in}\\
\and
  Department of Computer Science\\
  Utah State University, Logan, UT 84322, USA\\
  \email{haitao.wang@usu.edu}
}

\maketitle

\pagenumbering{arabic}
\setcounter{page}{1}



\begin{abstract}
Let  be a set of  pairwise-disjoint polygonal
obstacles with a total of  vertices in the plane.  We consider the problem of
building a data structure that can quickly compute an  shortest obstacle-avoiding
path between any two query points  and .
Previously, a data structure of
size  was constructed in  time that
answers each two-point query in  time, i.e., the
shortest path length is reported in  time and an
actual path is reported in additional  time, where  is the
number of edges of the output path. In this paper, we build a new data structure
of size  in
 time that
answers each query in  time. Note that

for any constant . (In contrast, for the Euclidean version of this two-point
query problem, the best known algorithm uses  space to achieve an 
query time.) In addition, we construct a data structure of
size  in  time that answers each query in
 time, and a data structure of size 
in  time that answers each query in
 time.  Further, we extend our techniques to the
weighted rectilinear version in which the ``obstacles" of  are rectilinear regions
with ``weights" and allow  paths to travel through them with weighted costs.
Previously,  a data structure of
size  was built in  time that
answers each query in  time.
Our new algorithm answers each query in  time with a
data structure of size  that
is built in  time
(note that  for any constant ).
\end{abstract}


\section{Introduction}
\label{sec:intro}
Let  be a set of  pairwise-disjoint polygonal obstacles in the
plane with a total of  vertices. We consider two-point shortest obstacle-avoiding
path queries for which the path lengths are measured in the  metric.
The plane minus the interior of
the obstacles is called the {\em free space}. Our goal is to build a
data structure to quickly compute an  shortest path
in the free space between any two query points  and .
Previously, Chen \etal \cite{ref:ChenSh00} constructed a data structure of
size  in  time that computes the
length of the  shortest \st\ path in  time and an
actual path in additional  time,
where  is the number of edges of the output path. Throughout this paper,
unless otherwise stated,
when we say that the query time of a data structure is  (which
may be a function of both  and ), we
mean that the shortest path length can be reported in
 time and an actual path can be found in additional time
linear in the number of edges of the output path. Hence, the query
time of the data structure in \cite{ref:ChenSh00} is .

In this paper, we build a new data structure of size
 in
 time, with 
query time.  Note that  for any constant . Hence, comparing with
the results in \cite{ref:ChenSh00}, we reduce the query
time by a logarithmic factor, and use less preprocessing time and
space when  is small, e.g.,  for any constant .
In addition, we can also build a data structure of size 
in  time, with an  query time,
and another data structure of size 
in  time, with an  query
time.

Further, we extend our techniques to the {\em weighted rectilinear
version} in which each ``obstacle"  is a region with a nonnegative
weight  and the edges of the obstacles in  are all axis-parallel;
a path intersecting the interior of  is charged a cost
depending on . For this problem, Chen \etal \cite{ref:ChenSh00}
constructed a data structure of
size  in  time that answers each
two-point shortest path query in  time.
We build a new data structure of size  in  time that answers each query in  time.
Note that  for any constant .


\subsection{Related Work}

The problems of computing shortest paths among obstacles in the plane
have been studied extensively (e.g.,
\cite{ref:ChenCo13,ref:ChenSh00,ref:ChenA11ESA,ref:ChenCo12arXiv,ref:ChenCo13SoCG,ref:ChenL113STACS,ref:ElGindyOr94,ref:GuibasOp89,ref:GuibasLi87,ref:HershbergerA91,ref:HershbergerAn88,ref:HershbergerCo94,ref:HershbergerAn99,ref:HershbergerA13,ref:InkuluPl09,ref:InkuluA10,ref:KapoorAn97,ref:LeeEu84,ref:LeeSh91,ref:MitchellAn89,ref:MitchellA91,ref:MitchellL192,ref:MitchellSh96}).
There are three main types of such problems:
{\em finding a single shortest - path} (both  and  are
given as part of the input and the goal is to find a single shortest \st\ path),
{\em single-source shortest path queries} ( is given as part of the input
and the goal is to build a data structure to
answer shortest path queries for any query point ), and
{\em two-point shortest path queries} (as defined and considered in this
paper). The distance metrics can be the Euclidean (i.e., ) or .
Refer to \cite{ref:MitchellGe00} for a comprehensive
survey on this topic.

For the simple polygon case, in which  is a single simple polygon,
all three types of problems have been solved optimally
\cite{ref:GuibasOp89,ref:GuibasLi87,ref:HershbergerA91,ref:HershbergerCo94,ref:LeeEu84},
in both the Euclidean and  metrics. Specifically, an -size data structure
can be built in  time that answers each
two-point Euclidean shortest path query in  time
\cite{ref:GuibasOp89,ref:HershbergerA91}.
Since in a simple polygon a Euclidean shortest path is also an  shortest path
\cite{ref:HershbergerCo94}, the results in \cite{ref:GuibasOp89,ref:HershbergerA91}
hold for the  metric as well.

The polygonal domain case (or ``a polygon with holes''), in which  has  obstacles as
defined above, is more difficult. For the Euclidean
metric, Hershberger and Suri \cite{ref:HershbergerAn99} built a {\em single source
shortest path map} of size  in  time that answers each
query in  time.
For the  metric, Mitchell
\cite{ref:MitchellAn89,ref:MitchellL192} built an -size single source shortest
path map in  time that answers each
query in  time. Later, Chen and Wang
\cite{ref:ChenA11ESA,ref:ChenCo12arXiv,ref:ChenL113STACS}
built an  single source shortest path map of size  in  time, with an
 query time, for a triangulated free
space (the current best triangulation algorithm takes
 time for any constant 
\cite{ref:Bar-YehudaTr94}).
For two-point  shortest path queries, Chen \etal \cite{ref:ChenSh00}
gave the previously best solution, as
mentioned above; for a special case where the obstacles are rectangles, ElGindy and Mitra \cite{ref:ElGindyOr94} gave an  size data structure that supports  time queries.
For two-point queries in the Euclidean metric,
Chiang and Mitchell \cite{ref:ChiangTw99}
constructed a data structure of size  that answers each
query in  time, and alternatively, a data
structure of size  with an  query time; other data structures
with trade-off between preprocessing and query time were also given in
\cite{ref:ChiangTw99}. If the query points  and  are both restricted
to the boundaries of the obstacles of , Bae and Okamato
\cite{ref:BaeQu12} built a data structure of size 
that answers each query in  time, where
 is a polylogarithmic factor.
Efficient algorithms were also given for the case when
the obstacles have curved boundaries
\cite{ref:ChenCo13,ref:ChenCo13SoCG,ref:ChewPl85,ref:HershbergerAn88,ref:HershbergerA13}.

For the weighted region case, in which
the ``obstacles" allow paths to pass through their
interior with weighted costs, Mitchell and Papadimitriou \cite{ref:MitchellTh91} gave an
algorithm that finds a weighted Euclidean shortest path in a time of 
times a factor related to the precision of the problem instance.
For the weighted rectilinear case, Lee \etal \cite{ref:LeeSh91}
presented two algorithms for finding a weighted 
shortest path, and Chen \etal \cite{ref:ChenSh00} gave an improved algorithm with
 time and  space. Chen
\etal \cite{ref:ChenSh00} also presented a data structure for
two-point weighted  shortest path queries among
weighted rectilinear obstacles, as mentioned above.

\subsection{Our Approaches}

Our first main idea is to propose an enhanced graph model based on the
scheme in \cite{ref:ChenSh00,ref:ClarksonRe87,ref:ClarksonRe88}, to reduce the query
time from  to . In \cite{ref:ChenSh00,ref:ClarksonRe87,ref:ClarksonRe88},
to build a graph, a total of  vertical lines (called ``cut-lines'') are created recursively in  levels.
Then, each obstacle vertex  is projected to  cut-lines (one cut-line per level) to create ``Steiner points'' if  is horizontally visible to such cut-lines.
For any two query points  and , to report an  shortest \st\ path, the algorithm in \cite{ref:ChenSh00} finds  Steiner points (called ``gateways'') on  cut-lines for each of  and , such that there must be a shortest \st\ path containing a gateway of  and a gateway of . Consequently, a shortest path is obtained in  time using the  gateways of  and .


We propose an enhanced
graph  by adding more Steiner points onto the cut-lines such that
we need only  gateways for any query points,
and consequently, computing the shortest path length takes  time. More
specifically, for each obstacle vertex, instead of projecting it to a single vertical
cut-line at each level, we project it to  cut-lines in
every 
consecutive levels (thus creating  Steiner points); in fact,
these cut-lines form a binary tree structure of height  and they are carefully chosen to ensure that  gateways are sufficient for any query point.
Hence, the size
of the graph  is .


To improve the data structure construction so that its time and space bounds
depend linearly on , we utilize the extended corridor
structure \cite{ref:ChenA11ESA,ref:ChenCo12arXiv,ref:ChenL113STACS},
which partitions the free space of  into an ``ocean'' , and
multiple ``bays'' and ``canals''. We build a graph 
of size  on  similar to ,
such that if both query points are in , then the query can be answered in
 time. It remains to deal with the general case when at least one query
point is not in . This is a major difficulty in our problem and our algorithm for
this case is another of our main contributions. Below, we use a bay as an example to
illustrate our main idea for this algorithm.

For two query points  and , suppose  is in a bay  and  is outside .
Since  is a simple polygon, any shortest \st\ path must cross the ``gate''  of ,
which is a single edge shared by  and . We prove that there exists a shortest
\st\ path that must contain one of three special points ,
, and , where  is in  and the other
two points are on  (and thus in ). For the case
when a shortest \st\ path contains either  or ,
we can use the graph  to find such a shortest
path. For the other case, we build another graph  based on the
horizontal projections of the vertices of  on , and use  to find
such a shortest path (along with a set of interesting observations) by a merge of
 and . Intuitively,  plays the role of connecting the shortest
path structure inside  with those in .

The case when a query point is in a canal can be handled similarly in spirit,
although it is more complicated because each canal has two gates.



The rest of the paper is organized as follows. In Section
\ref{sec:pre}, we introduce some notations and sketch the previous results
that will be needed by our algorithms. In Section
\ref{sec:newgraph}, we
propose our enhanced graph  that helps reduce the query time to . In
Section \ref{sec:obstacle}, we further reduce
the preprocessing time and space by using the extended corridor
structure. In Section \ref{sec:weighted}, we
extend our techniques in Section \ref{sec:newgraph} to the weighted
rectilinear case.


Henceforth, unless otherwise stated, ``shortest paths'' always refer
to  shortest paths and ``distances'' and ``lengths'' always refer to 
distances and lengths. To distinguish from graphs, the vertices/edges of
 are always referred to as obstacle vertices/edges,
and graph vertices are referred to as ``nodes''. For
simplicity of discussion, we make a general position assumption that
no two obstacle vertices have the same - or
-coordinate except for the weighted rectilinear case.


\section{Preliminaries}
\label{sec:pre}

A path in the plane is {\em -monotone} (resp., {\em -monotone})
if its intersection with any
vertical (resp., horizontal) line is either empty or connected. A
path is {\em -monotone} if it is both {\em -monotone} and {\em
-monotone}. It is well-known that any -monotone path is an
 shortest path.

A point  is {\em visible} to another point  if the line segment
 entirely is in the free space.
A point  is {\it horizontally} {\it visible} to a line  if
there is a point  on  such that 
is horizontal and is in the free space.
For a line  and a point , the point  is the {\em horizontal}
{\it projection} of  on  if  is horizontal, and we denote it by .
Let  denote the boundaries
of all obstacles in . For a point  in the free space of
, if we shoot a horizontal ray from  to the left, the first point on
 hit by the ray is called the {\em leftward projection} of  on
, denoted by ; similarly, we define the
{\em rightward, upward}, and {\em downward} projections of  on
, denoted by , , and , respectively.

We sketch the graph in \cite{ref:ChenSh00}, denoted by ,
for answering two-point queries, which was originally proposed in
\cite{ref:ClarksonRe87,ref:ClarksonRe88} for computing a single
shortest path. To define , two types of
{\em Steiner points} are specified, as follows.
For each obstacle vertex , its
four projections on , i.e., , and , are {\em type-1}
Steiner points. Clearly, there are  type-1 Steiner points in total.

The {\em type-2 Steiner points} are on {\em cut-lines}. In
order to facilitate an explanation on our new graph model in Section
\ref{sec:newgraph}, we organize the cut-lines in a binary tree structure,
called the {\em cut-line tree} and denoted by . The tree  is defined as follows.
For each node  of , a set  of obstacle vertices
and a cut-line  are associated with , where  is a
vertical line through the median of the -coordinates of the
obstacle vertices in . For the root  of ,
 is the set of all obstacle vertices of . For the left
(resp., right) child  of ,  consists of the obstacle
vertices of  on the left (resp., right) of .
Since the number of vertices of  is , the height of
 is . For every node  of
, for each vertex , if  is horizontally visible to
, then the point , i.e., the horizontal projection of  on
, is a type-2 Steiner point. Since each obstacle vertex defines
a type-2 Steiner point on at most one cut-line at each level of ,
there are  type-2 Steiner points.

The node set of  consists of all obstacle vertices of 
and all Steiner points thus defined.

The edges of  are defined as follows. First, for every obstacle vertex ,
there is an edge  in  for each . Second, for every obstacle edge  of ,  may contain
multiple type-1 Steiner points, and these Steiner points and the two endpoints
of  are the nodes of  on ;
the segment connecting each pair of consecutive graph nodes on  defines an
edge in . Third, for each cut-line , any two
consecutive type-2 Steiner points on  define an edge in  if
these two points are visible to each other.
Finally, for each obstacle vertex , if  defines a type-2
Steiner point  on a cut-line, then  defines an
edge in .  Clearly,  has  nodes and
 edges.




It was shown in \cite{ref:ClarksonRe87,ref:ClarksonRe88} that
 contains a shortest path between any two obstacle vertices.
Chen \etal \cite{ref:ChenSh00} used  to answer two-point
queries by ``inserting'' the query points  and  into  so that shortest
\st\ paths are ``controlled'' by only  nodes of ,
called ``gateways''. The gateways of  are defined as follows.
Intuitively, the gateways of  are those nodes of  that would be
adjacent to  if we had built  by treating  as an obstacle vertex.
Let  be the set of gateways of , which we further
partition into two subsets  and
. We first define , whose size is
. For each , let 
and  be the two graph nodes adjacent to  on the obstacle edge
containing ; then  and  are in , and the
paths  and
 are the {\em gateway edges} from
 to  and , respectively. Next, we define
, recursively, on the cut-line tree .
Let  be the root of .
Suppose  is
horizontally visible to the cut-line . Let  be the Steiner point
on  immediately above (resp., below) the projection point ;
if  is visible to , then  is in 
and the path  is the gateway
edge from  to . We also call  a {\em projection cut-line}
of  if  is horizontally visible to .
We proceed to the left (resp., right) child of  in  if 
is to the left (resp., right) of .
We continue in this way until reaching a leaf of
. Therefore,  contains 
type-2 Steiner points on  projection cut-lines.

The above defines the gateway set , and each
gateway  is associated with a gateway edge between  and . Henceforth,
when we say ``a path from  contains a gateway '', we
implicitly mean that the path contains the corresponding gateway edge as well.
The above also defines  projection cut-lines for , which will
be used later in Section \ref{sec:newgraph}.
It was shown in \cite{ref:ChenSh00} that for any obstacle vertex ,
there is a shortest - path using  that contains a gateway of .

Similarly, we define the gateway set   for .
Assume that there is a shortest \st\ path containing an obstacle
vertex. Then, there must be a shortest \st\ path that contains a gateway
, a gateway , and a
shortest path from  to  in the graph  \cite{ref:ChenSh00}. Based on
this result, a {\em gateway graph}  is built for the query
on  and , as follows. The node
set of  is .
Its edge set consists of all gateway edges and the edges 
for each  and each ,
where the weight of   is the length of a shortest path
from  to  in . Hence,  has  nodes and
 edges, and if we know the weights of all edges ,
then a shortest \st\ path in  can be found in
 time. To obtain the weights of all edges , we
compute a single source shortest path tree in  from each node of 
in the preprocessing. Then, the weight of each such edge 
is obtained in  time. Further, suppose we find a shortest
\st\ path in  that contains a gateway  and a gateway ; then we can
report an actual shortest \st\ path in time linear to the
number of edges of the output path by using the shortest path tree from 
in  (which has been computed in the preprocessing).


As discussed in \cite{ref:ChenSh00},
it is possible that no shortest \st\ path contains any
obstacle vertex.
For example, consider
a projection point  of  and a projection point  of . If
 intersects , say at a point , then
 is a shortest \st\ path; otherwise, if  and
 are both on the same obstacle edge, then  is a shortest \st\ path. We call
such shortest \st\ paths {\em trivial shortest paths}. Similarly, trivial shortest
\st\ paths can also be defined by other projection points in 
and .
It was shown in \cite{ref:ChenSh00} that if there is no trivial
shortest \st\ path, then there exists a shortest \st\ path that
contains an obstacle vertex. If we know 
and , then we can determine whether there exists
a trivial shortest \st\ path in  time. For any query points  and ,
their projection points can be computed easily in  time by using
the horizontal and vertical visibility decompositions of , as shown in
\cite{ref:ChenSh00}.


\section{Reducing the Query Time Based on an Enhanced Graph}
\label{sec:newgraph}

In this section, we propose an ``enhanced graph''  that allows us to reduce
the query time to , although
 has a larger size than . We
first define , and then show how to answer two-point queries by using .


\subsection{The Enhanced Graph }

On the nodes of , first, every node of  is also a node
in . In addition, 
contains the following {\em type-3} Steiner points as nodes.
To define the type-3 Steiner points, we introduce the concepts of ``levels'' and
``super-levels'' on  the cut-line tree  defined in Section
\ref{sec:pre}.
 has  levels. We
define the level numbers recursively: The root 
is at the first level, and its {\em level number} is denoted by   ;
for any node  of , if  is a child of , then .
We further partition the  levels of  into  {\em super-levels}: For any , , the -th super-level contains the levels from
 to .


\begin{figure}[t]
\begin{minipage}[t]{\linewidth}
\begin{center}
\includegraphics[totalheight=2.0in]{type3.eps}
\caption{\footnotesize Illustrating , i.e., the portion of the tree in the dotted box, where . }
\label{fig:type3}
\end{center}
\end{minipage}
\vspace*{-0.15in}
\end{figure}

Consider the -th super-level.
Let  be any node at the highest level (i.e., the level with the smallest level number) of this super-level. Let
 denote the subtree of  rooted at  without including
any node outside the -th super-level (e.g., see Fig.~\ref{fig:type3} and its corresponding cut-lines and level numbers in Fig.~\ref{fig:levelno}). Since  has
 levels,  has
 nodes. Recall that  is associated with a
subset  of obstacle vertices and a vertical cut-line , and for any vertex 
in , if  is horizontally visible to
, then its projection point  is a type-2 Steiner
point. Each point  defines the following type-3 Steiner points. For
each node  in , if  is horizontally visible to
, then its projection point  is a type-3 Steiner
point (e.g., see Fig.~\ref{fig:levelno}; note that if , then the Steiner point is also a type-2 Steiner point).
Hence,  defines  type-3 Steiner
points in the -th super-level of . Let  be the set of all
type-2 and type-3 Steiner points on the cut-lines of the subtree
 induced by , and let  also contain . In the order of the
points in  from left to right, we put an edge in
 connecting every two consecutive points in  (e.g., see Fig.~\ref{fig:levelno}).
Since the total number of obstacle vertices in  for all nodes 
at the same level of  is , the number of type-3
Steiner points thus defined in each super-level is , and the total number of type-3 Steiner points on all cut-lines
in  is . The number of edges
thus added to  is also .


Hence, the total number of nodes in  is , which is dominated by the number of type-3
Steiner points.
We have also defined above some edges in . The rest of
edges in  are defined similarly as in . Specifically,
first, as in , for every obstacle vertex ,
there is an edge  in  for each . Second, as in ,
for each obstacle edge ,  may contain
multiple type-1 Steiner points;
the segment connecting each pair of consecutive graph nodes on  defines an
edge in . Third, for each cut-line , every pair of
consecutive Steiner points (type-2 or type-3)
on  defines an edge in  if
these two points are visible to each other.
Clearly, the total number of edges in  is .


\begin{figure}[t]
\begin{minipage}[t]{\linewidth}
\begin{center}
\includegraphics[totalheight=2.0in]{levelno.eps}
\caption{\footnotesize Illustrating the cut-lines and level numbers of the subtree  in Fig.~\ref{fig:type3}, where  is the level number  of the node .  is an obstacle vertex. If  is visible to all cut-lines, then the red points are type-2 and type-3 Steiner points defined by  and the (red) dotted segments are the corresponding graph edges. }
\label{fig:levelno}
\end{center}
\end{minipage}
\vspace*{-0.15in}
\end{figure}


This finishes the definition of our enhanced graph , which has
 nodes and 
edges. The following lemma gives an algorithm for computing .

\begin{lemma}\label{lem:10}
The enhanced graph  can be constructed
in  time.
\end{lemma}
\begin{proof}
First of all, all type-1 Steiner points are
computed easily in  time, e.g., by using the vertical and horizontal visibility decompositions of . The edges of  connecting the obstacle vertices and their
corresponding type-1 Steiner points can also be computed. For each obstacle
edge , we sort all graph nodes on  and then
compute the edges of  connecting the consecutive nodes on . Since
there are  type-1 Steiner points, computing these
edges takes  time.

Next, we compute both the type-2 and type-3 Steiner points and their adjacent
edges. For this, we need to use the two projection
points  and  for each obstacle vertex  of , which have been computed as type-1 Steiner points.
Consider an obstacle vertex  in  for a
node  at the highest level of a super-level. For each node  in
, we need to determine whether  is horizontally
visible to , which can be done in  time since 
and  are already known. We also need to have a sorted order of all
cut-lines in  from left to right, and this ordered list
can be obtained by an in-order traversal of  in linear
time. Therefore, the edges of  connecting the Steiner points defined by  on
consecutive cut-lines in this super-level can be computed in time linear to the number of nodes in .
Since there are  type-2 and type-3
Steiner points, computing all such edges takes  time.

It remains to compute the graph edges on all cut-lines connecting consecutive Steiner
points (if they are visible to each other).
This step is done in  time by a
sweeping algorithm, as follows. For each cut-line , we sort
the Steiner points on  by their -coordinates, and
determine whether every two consecutive Steiner points on  are visible to
each other. For this, we sweep a vertical line  from left to right.
During the sweeping, we use a balanced binary search tree  to maintain
the maximal intervals of  that are in the free space of  (there are  such intervals).
At each obstacle vertex, we
update  in  time. At each (vertical) cut-line ,
for every two consecutive Steiner points, we determine whether they
are visible to each other in  time by checking whether they
are in the same maximal interval maintained by . Since
there are  pairs of consecutive
Steiner points on all cut-lines, computing all edges of  on the cut-lines takes
totally  time. Another
approach for computing these edges in  time is to perform vertical ray-shootings from all Steiner
points (we omit the details).

In summary, the enhanced graph  can be computed in
 time.
\end{proof}

\subsection{Reducing the Query Time}

We use the enhanced graph  to reduce the query time to .
Consider two query points  and . One of our key ideas is: We
define a new set of gateways for , denoted by , which
contains  nodes of , such that
for any obstacle vertex  of , there
exists a shortest path from  to  through a gateway of
. The set  can be divided into two subsets  and
, where  (of size ) is exactly the same as
 defined on  in Section \ref{sec:pre}. Below,
we define the subset .

Recall that  has  projection cut-lines, as defined in
Section \ref{sec:pre}. By definition,  is horizontally visible to all its
projection cut-lines. Since  has more Steiner points than , the intuition is that we do not have to include gateways in each projection cut-line of . More specifically, we only need to include gateways in two projection cut-lines in each super-level (one to the left of  and the other to the right of ). The details are given below.

 We define the {\em relevant projection
cut-lines} of , as follows. Let  be the set of projection cut-lines of
 to the right of .  Consider a cut-line 
and suppose  is associated with a node  in the -th super-level
of the cut-line tree  for some . Then  is a {\em relevant
projection cut-line} of  if  (i.e., their level
numbers) for every node  with  in the
-th super-level of 
such that the cut-line  of  is also in . In other words,
 is a relevant projection cut-line of  if  has the largest distance
in  from the root
among all nodes  in the -th super-level of  whose
cut-lines  are in . For example, in Fig.~\ref{fig:type3} and Fig.~\ref{fig:levelno}, suppose  is between the cut-lines  and  and both  and  are horizontally visible to ; then among the cut-lines of all nodes in , only  and  are in , but only  is the relevant projection cut-line of .  The relevant projection cut-lines
of  to the left of  are defined similarly.  Since  has  projection cut-lines and any two of them are at different levels
of , the number of relevant projection cut-lines of  is
, i.e., at most two from each super-level of
 (one to the left of  and the other to the right of ). For each relevant projection cut-line  of , the Steiner point 
(if any) immediately above (resp., below) the projection point  of  on  is in
 if  is visible to . Thus,
.

 thus defined is of size
. We also define the gateway edge for
each gateway of  and  in the same way as in Section \ref{sec:pre}.
Below, when we say a shortest path from  containing a gateway, we
mean the path containing the corresponding gateway edge as well.

\begin{lemma}\label{lem:20}
For any obstacle vertex  of , there exists a shortest path
from  to  using  that contains a gateway of  in .
\end{lemma}
\begin{proof}
Recall that  is the gateway set of  defined on
 in Section \ref{sec:pre}, and by \cite{ref:ChenSh00}, there exists a
shortest path  from  to  using 
that contains a point .

By the definition of , if any edge  of  connecting two nodes  and  is not an edge of , then 
can be viewed as being ``divided" into many edges in  such that the concatenation
of these edges is a path from  to  in  with the same length
as . Hence,  is still a shortest path
along .
For any point  that is on a shortest - path, we call
it a {\it via point}.
If any via point  is in , then  is in 
since , and we are done.
Otherwise, all via points must be in . If any such via point  is also in
, then we are done as well. It remains to prove for the
case that for every via point ,  and  hold. Recall that every node of , including each via point
, is also a node of .
Below, we find an -monotone path from  to such a via point  along  that
contains a gateway . Since any -monotone path
is a shortest path, this gives a shortest - path (through )
containing a gateway  of  in , thus proving the lemma.

Without loss of generality, we assume that  is to the right of  and
above  (i.e.,  is to the northeast of , see
Fig.~\ref{fig:gatewayproof}). Suppose  is on the cut-line  of a node  in
the -th super-level of .
If  is a relevant cut-line of , then there must be a gateway  of  in 
lying in the vertical segment  on  (possibly ), and thus
we are done.  Otherwise,  is not a relevant cut-line of , and
there exists a relevant cut-line  of 
to the right of  such that  is in the -th super-level of 
and .
Next, we show that the sought gateway  lies on .

It was shown in \cite{ref:ChenSh00} (Lemma 3.4) that the level numbers of the
projection cut-lines of  to the right of ,
in the left-to-right order, are decreasing.
This observation can also be seen easily by considering the projection cut-lines of  in a top-down manner. Hence,
 is to the left of  (see Fig.~\ref{fig:gatewayproof}). Let  be the obstacle vertex that
defines the Steiner point  on . By our definition of
Steiner points,  must be in  for the
node  that is the highest ancestor of  (and ) in the -th
super-level. Therefore, if  is horizontally visible to
, then  also defines a Steiner point on . We now show
that  is horizontally visible to , and for this,
it suffices to prove
that  is horizontally visible to  since  is horizontally visible to .
Because  and no via point is in ,
it was shown in \cite{ref:ChenSh00} that
 must be horizontally visible to the vertical line through . Since
 is between  and ,  is also horizontally
visible to .

\begin{figure}[t]
\begin{minipage}[t]{\linewidth}
\begin{center}
\includegraphics[totalheight=1.2in]{gatewayproof.eps}
\caption{\footnotesize Illustrating the proof of Lemma \ref{lem:20}:
 is the obstacle vertex that defines the Steiner point ; 
is between  and .}
\label{fig:gatewayproof}
\end{center}
\end{minipage}
\vspace*{-0.15in}
\end{figure}

Thus,  defines a Steiner point on , i.e., the point
 (see Fig.~\ref{fig:gatewayproof}).
By the definition of , the
lowest Steiner point  on  above  must be a gateway in
. Note that  may or may not be , but 
cannot be higher than . Thus, the concatenation of the
gateway edge from  to , , and
, which is an -monotone path from  to
 using , contains the gateway  of .
The lemma thus follows.
\end{proof}

Similarly, we define the gateway set  for  in .
The similar result for  as Lemma \ref{lem:20} for  also holds. Thus, we have
the following corollary.

\begin{corollary}\label{cor:10}
If there exists a shortest \st\ path through an obstacle vertex of
, then there exists a shortest \st\ path through a gateway of
 in  and a gateway of  in .
\end{corollary}

Next, we give an algorithm for computing the two gateway sets  and
.


\begin{lemma}\label{lem:30}
With a preprocessing of  time
and  space,
we can compute the gateway sets  and
  in  time for any query points  and .
\end{lemma}
\begin{proof}
We only discuss the case for computing  since  can be
computed similarly.

To compute , it suffices to determine the four
projection points  of  on , which can be computed in
 time by using the horizontal and vertical
visibility decompositions of . These two visibility decompositions can be built in
 time by standard sweeping algorithms.
After that, we also need to build a point location
data structure \cite{ref:EdelsbrunnerOp86,ref:KirkpatrickOp83} on each of the
two decompositions in additional  time.

To compute , it might be possible to modify the approach in
\cite{ref:ChenSh00}. However, to explain the approach in
\cite{ref:ChenSh00}, we may have to review a number of observations given
in \cite{ref:ChenSh00}. To avoid a tedious discussion, we propose
the following algorithm that is simple.


We first obtain the set  of all relevant projection cut-lines of . This can be
done in  time by following the cut-line tree 
from the root and using  and  to determine the horizontal visibility of .
Note that the cut-lines of  are at some
nodes on a path from the root to a leaf. To obtain
, for each cut-line , we need to: (1) find the
Steiner point  on  immediately above (resp., below) , and (2)
determine whether  is visible to .

Consider a cut-line . Let  and  be the two
gateways of  on  (if any) such that  is above
. That is,  (resp., ) is the Steiner
point on  immediately above (resp., below)  and visible to .
If we maintain a sorted list of all Steiner
points on , then  and  can be found by binary
search  on the sorted list. However, there are two issues with this
approach. First, if we do binary search on each cut-line of , since
, it takes  time
on all cut-lines of . Second, even if we find  and
, we still need to check whether  is visible to them. To
resolve these two issues, we take the following approach.



For every Steiner point  on the cut-line , suppose we associate with  its upward and
downward projection points  and  on . Then once we
find the Steiner point  on  immediately above (resp., below) , we can
determine easily whether  is visible to  using  and ; if
 is visible to , then  (resp., ), or else 
(resp., ) does not exist.
For any Steiner point  on ,  and  can be found in  time by using the vertical visibility decomposition of .
Since there are  Steiner points  on all cut-lines of ,
their projection points  and 
can be computed in totally  time.

Next, for each cut-line , we sort all Steiner points on . With this, one can compute all gateways of
 in  time by doing binary search on each relevant projection cut-line of .
To reduce the query time to , we make use of the fact that all relevant projection cut-lines of  are at the nodes on a path of  from the root to a leaf.
We build a fractional cascading structure \cite{ref:ChazelleFr86}
on the sorted lists of Steiner points on all cut-lines along , such that the searches on all cut-lines at the nodes on any path of  from the root to a leaf take  time.
Hence, all gateways of  can be computed in  time. Since the total number of Steiner points
in the sorted lists of all cut-lines of  is , the fractional cascading structure can be built in  space and   time.
The lemma thus follows.
\end{proof}

\begin{theorem}\label{theo:10}
We can build a data structure of size  in  time that can
answer each two-point  shortest path query in  time (i.e., for
any two query points  and , the length of a shortest \st\ path can be found in 
time and an actual path can be reported in additional time linear to the number of edges of the output path).
\end{theorem}
\begin{proof}
In the preprocessing, we first build the graph . Then, for each node  of , we compute a shortest path tree in  from . We also maintain a shortest path length table such that
for any two nodes  and , the shortest - path length in  can be obtained in  time. Since  is of a size , computing and
maintaining all these shortest
path trees in  take  space and
 time.
We also do the preprocessing for Lemma \ref{lem:30}.

Given any two query points  and , we first check whether there
is a trivial shortest \st\ path, as discussed in Section
\ref{sec:pre}, in  time by using the algorithm
in \cite{ref:ChenSh00} (with an  time preprocessing). If
there is a trivial shortest \st\ path, then we are done.
Otherwise, there must be a shortest \st\ path that contains an
obstacle vertex of . Then, we first compute the gateway sets
 and  in  time by Lemma
\ref{lem:30}. Finally, we determine the shortest - path length
by using the gateway graph as discussed in Section \ref{sec:pre}, in
 time, since there are  gateways and thus
the gateway graph has  nodes and  edges.

We can also report an actual shortest \st\ path in additional time linear to the number of edges of the output path by using the shortest path trees of .
This proves the theorem.
\end{proof}



\section{Reducing the Time and Space Bounds of the Preprocessing}
\label{sec:obstacle}

In this section, we improve the preprocessing
 in Theorem \ref{theo:10} to  space and  time,
while maintaining the  query time. For this, we shall make use
of the extended corridor data structure
\cite{ref:ChenA11ESA,ref:ChenCo12arXiv,ref:ChenL113STACS,ref:KapoorAn97}, and more importantly, explore
a number of new observations, which may be interesting in their own right.

The corridor structure has been used to solve shortest path problems (e.g., \cite{ref:InkuluPl09,ref:KapoorEf88,ref:KapoorAn97}), and new concepts like ``ocean'', ``bays'', and ``canals'' have been introduced \cite{ref:ChenA11ESA,ref:ChenCo12arXiv,ref:ChenCo12ICALP,ref:ChenCo13SoCG,ref:ChenL113STACS,ref:ChenVi13WADS}, which we refer to as the ``extended corridor structure''.
This structure is a subdivision of the free space on which algorithms for specific problems
rely.  While the extended corridor structure itself is relatively simple, the main difficulty is to design
efficient algorithms to exploit it. In some sense, the role played by the extended corridor structure is similar to that of triangulations for many geometric algorithms.
We briefly review the extended corridor structure in Section \ref{subsec:extended}, since our
presentation uses many notations introduced in it.

\subsection{The Extended Corridor Structure}
\label{subsec:extended}

For simplicity of discussion, we assume that the obstacles of  are all contained in a
rectangle .
Let  denote the free space in , and
 denote a triangulation of  (see Fig.~\ref{fig:triangulation}). The line segments of  that are not obstacle edges are referred to as {\em diagonals}.



Let  denote the dual graph of ,
i.e., each node of  corresponds to a
triangle of  and each edge connects two nodes
corresponding to two triangles sharing a diagonal of .
Based on , we
compute a planar 3-regular graph, denoted by  (the degree of every node in  is three),
possibly with loops and multi-edges,
as follows. First, we remove each degree-one node from 
along with its incident edge; repeat this process until no
degree-one node remains in the graph. Second, remove every degree-two node from
 and replace its two incident edges by a single edge;
repeat this process until no degree-two node remains. The
resulted graph is  (see Fig.~\ref{fig:triangulation}), which has
 faces, nodes, and  edges \cite{ref:KapoorAn97}. Every node of
 corresponds to a triangle in , called a
{\em junction triangle} (see Fig.~\ref{fig:triangulation}).
The removal of the nodes for all junction triangles from  results in 
{\em corridors}, each of which corresponds to an edge of .




The boundary of each corridor  consists of four parts (see
Fig.~\ref{fig:corridor}): (1) A boundary portion of an obstacle
, from a point  to a point ; (2) a diagonal of a
junction triangle from  to a point  on an obstacle
 ( is possible); (3) a boundary portion of
the obstacle  from  to a point ; (4) a diagonal of a
junction triangle from  to .
The corridor  is a simple polygon.
Let  (resp., ) be the Euclidean shortest path from  to 
(resp.,  to ) in . The region  bounded by
, , and
 is called an {\em hourglass}, which is {\em open} if
 and {\em closed} otherwise (see
Fig.~\ref{fig:corridor}). If  is open, then both  and
 are convex chains and are called the {\em sides} of
; otherwise,  consists of two ``funnels" and a path
 joining the two apices of the two
funnels, and  is called the {\em corridor path} of .
The two funnel apices (e.g.,  and  in Fig.~\ref{fig:corridor})
are called {\em corridor path terminals}.
Each side of a funnel is also a convex chain.



\begin{figure}[t]
\begin{minipage}[t]{0.47\linewidth}
\begin{center}
\includegraphics[totalheight=1.2in]{triangulation.eps}
\caption{\footnotesize \cite{ref:ChenCo12arXiv,ref:ChenCo12ICALP} Illustrating a triangulation of the free
space among two obstacles and the corridors (indicated by red solid curves).
There are two junction triangles marked by a large dot inside
each of them, connected by three solid (red) curves. Removing the two
junction triangles results in three corridors.}
\label{fig:triangulation}
\end{center}
\end{minipage}
\hspace*{0.04in}
\begin{minipage}[t]{0.52\linewidth}
\begin{center}
\includegraphics[totalheight=1.2in]{corridor.eps}
\caption{\footnotesize \cite{ref:ChenCo12arXiv,ref:ChenCo12ICALP} Illustrating an open hourglass (left) and a
closed hourglass (right) with a corridor path connecting the apices
 and  of the two funnels. The dashed segments are diagonals.
The paths  and  are shown with thick solid
curves. A bay  with gate  (left)
and a canal  with gates  and 
(right) are also indicated.} \label{fig:corridor}
\end{center}
\end{minipage}
\vspace*{-0.15in}
\end{figure}

Let  be the union of the  junction triangles, open
hourglasses, and funnels.  Then .
We call  the {\em ocean}.
Since the sides of open hourglasses and funnels
are all convex, the boundary
 of  consists of  convex chains with
a total of  vertices; also, there are  reflex vertices on ,
which are corridor path terminals.
We further partition the free space  into regions called {\em
bays} and {\em canals}, as follows.

Consider the hourglass  of a corridor .
If  is open, then 
has two sides. Let  be one side of .
The obstacle vertices on  all lie on the same
obstacle, say . Let  and  be any two consecutive
vertices on  such that  is
not an edge of  (e.g., see the left figure in
Fig.~\ref{fig:corridor}, with ). The free region enclosed
by  and the boundary portion of  between  and
 is called a {\em bay}, denoted by
. We call
 the {\em gate} of , which is
an edge shared by  and .
If  is closed, let  and  be the two apices
of its two funnels. Consider two consecutive vertices  and  on
a side of any funnel such that  is not an obstacle
edge. If neither  nor  is a funnel apex, then  and  must
lie on the same obstacle and the segment  also
defines a bay with that obstacle. However, if  or  is a funnel
apex (say, ), then  and  may lie on different obstacles.
If they lie on the same obstacle, then they also define a bay;
otherwise, we call  the {\em canal gate} at 
(see Fig.~\ref{fig:corridor}). Similarly, there is a canal gate
at the other funnel apex , say . Let  and
 be the two obstacles bounding the hourglass . The
region enclosed by , ,
, and  that contains the corridor path
of  is called a {\em canal}, denoted by .



Every bay or canal is a simple polygon.
The ocean, bays, and canals together
constitute the free space . While the
total number of all bays is , the total number of all canals is
.











\subsection{Queries in the Ocean }

For any two points  and  in the ocean , it has been
proved that there exists an  shortest \st\ path in the free space of the union of 
and all corridor paths \cite{ref:ChenA11ESA,ref:ChenCo12arXiv,ref:ChenL113STACS}.
Let  be the union of 
and all corridor paths. Thus, if  and  are both in , then there is a shortest \st\ path in .

In this subsection, we will first construct a graph  of
size  on
, in a similar fashion as  in
Section \ref{sec:newgraph}. Using the graph  and with
additional  space, for any query points  and  in , the
shortest path query can be answered in  time.


Let . Note that  is .
Hence,  consists of  convex chains with totally  vertices,
and  also contains  reflex vertices that are
corridor path terminals. Since  has  obstacles,
 contains at most  connected components and each
obstacle of  is contained in a component of .
For any point  in , in this subsection, let ,
, and  denote the leftward, rightward,
upward, and downward projection points of  on , respectively.

An obstacle vertex  on  is said to be {\em extreme} if both its
incident edges on  are on the same side of the vertical or horizontal line through . Let  denote the set of all extreme vertices and corridor
path terminals of . Since  consists of 
convex chains and  reflex vertices that are corridor path
terminals, .  We could build a graph
on  with respect to  in a similar way as we built
 on the obstacle vertices of  in Section \ref{sec:newgraph},
and then use this graph to answer queries when both query points are in
. However, in order to handle the general queries (in
Section \ref{subsec:general}) for which at least one query point is not in
, we need to consider more points for building the graph.
Specifically, let , i.e., in addition to ,
 also contains the four projections of all points in
 on .
Since , .



For each connected component  of
, let  denote the set of points of  on .
Consider any two points  and  of  that are consecutive on the
boundary  of . By the definition of  and
, the boundary portion of  between  and  that
contains no other points of  must be an -monotone
path (similar results were also given in
\cite{ref:ChenA11ESA,ref:ChenCo12arXiv,ref:ChenL113STACS,ref:InkuluPl09}), and we
call it an {\em elementary curve} of . Hence, for any two
points on an elementary curve, the portion of the curve between the
two points is a shortest path between the two points.

Our goal is to build a graph, denoted by , on 
with respect to 
in a similar way as we built  in Section \ref{sec:newgraph}, and use it to
answer queries. To argue the correctness of our approach, we
also define a graph  on  and  in a
similar way as  on . Again,
 is only for showing the correctness of our approach
based on  (recall that we use  to show the
correctness of using ). Below, we define  and
 simultaneously.



We first define their node sets. Each point of  defines a
node in both graphs. In addition,  has type-1 and
type-2 Steiner points as nodes;  has type-1,
type-2, and type-3 Steiner points as nodes. Such Steiner points are
defined using  in a similar way as before, but with respect to .
Specifically, for
each point , its four projections
, and  on 
are type-1 Steiner points. Let  be the cut-line tree
defined on the points of , similar to .
Each node  of  is associated
with a subset  and a vertical cut-line
 through the median of the -coordinates of the points in .
Since ,  has
 levels and  super-levels.
For every node , for each point ,
if  is horizontally visible to , then the projection of 
on  is a type-2 Steiner point.
Also, there are  type-3 Steiner
points on the cut-lines of , which are defined in
a similar way as in Section \ref{sec:newgraph}, and we omit the details.

The edge sets of the two graphs are defined similarly as
those in  and . We only point out the differences here.
One big difference is that for each corridor path, since its two terminals
define two nodes in both  and ,  has
an edge connecting these two nodes in both graphs whose weight
is the length of the corridor path.
Another subtle difference is as follows.
In  and , for each obstacle edge  of , both
graphs have an edge connecting each pair of consecutive graph nodes
on . In contrast, here we consider
each individual elementary curve of  instead of each
individual edge of  because not every vertex of
 defines a node in  and .
Specifically, consider each elementary curve  of . Note that
the two endpoints of  must be in  and thus define two nodes
in both graphs. For each pair of consecutive graph nodes along , we put an edge
in both  and  whose weight is the
length of the portion of  between these two points.
We then have the following lemma.

\begin{lemma}\label{lem:40}
For any two points  and  in ,
a shortest path from  to  in  (resp., )
corresponds to a shortest path from  to  in the plane.
\end{lemma}
\begin{proof}
We first show that a shortest path from  to  in
 corresponds to a shortest
path from  to  in the plane, and then show a shortest path from  to  in
 corresponds to a shortest path from  to  in
. This will prove the lemma.


To show a shortest path from  to  in
 corresponds to a shortest
path from  to  in the plane, we will build a new graph  and
prove the following: (1) a shortest path from  to  in 
corresponds to a shortest path from  to  in ,
and (2) a shortest path from  to  in  corresponds to a
shortest path from  to  in the plane. Below, to define the
graph , we first review some observations that have been discovered
before.


\begin{figure}[t]
\begin{minipage}[t]{\linewidth}
\begin{center}
\includegraphics[totalheight=1.2in]{core.eps}
\caption{\footnotesize Illustrating an ear bounded by  and an elementary curve .}
\label{fig:core}
\end{center}
\end{minipage}
\vspace*{-0.15in}
\end{figure}

Let  be any connected component of . Consider an elementary curve  of
 with endpoints  and . By
the definition of elementary curves, the line segment 
must be inside  (similar results were given in
\cite{ref:ChenA11ESA,ref:ChenCo12arXiv,ref:ChenL113STACS}). We call
the region enclosed by  and  an {\em ear} of ,
 the {\em base} of the ear, and  the elementary curve of the ear.
It is possible that  is , in which case
the ear is . It is easy to see that the bases of all
elementary curves of  do not intersect except at their endpoints
\cite{ref:ChenA11ESA,ref:ChenCo12arXiv,ref:ChenL113STACS}. Hence, if
we connect the bases of its elementary curves, we obtain a simple
polygon that is contained in ; we call this simple polygon the
{\em core} of , denoted by . Clearly, the union of
 and all the ears of  is . Denote by  the set of
cores of all components of . Note
that the vertex set of  is  and the edges of
 are the bases of all ears of .
Thus,  has  vertices and edges.
By the results in
\cite{ref:ChenA11ESA,ref:ChenCo12arXiv,ref:ChenL113STACS}, for any
two points in , in particular, any two vertices  and  in ,
there is a shortest - path in the plane that avoids all
cores of  and possibly contains corridor paths. More
specifically, there exists a shortest path  from  to 
that contains a sequence of vertices of ,
, in this order, with  and , such that for
any two consecutive vertices  and , , if
 and  are terminals of the same corridor path, then the
entire corridor path is contained in , or else 
contains the line segment  which does not
intersect the interior of any core in .




We build a graph  on  with
respect to the cores of , in the same way as  on  in
\cite{ref:ChenSh00,ref:ClarksonRe87,ref:ClarksonRe88}, with the only
difference that if two nodes of  are terminals of the same corridor
path, then there is an extra edge in  connecting these two nodes whose
weight is the length of the corridor path. Note that
 and  define two nodes in . Based on the above discussion,
we claim that the shortest path  defined above must correspond to a
shortest path from  to  in . Indeed, for any , , if  and  are terminals of the same corridor
path, then recall that  contains the entire corridor path and
there is an edge in  connecting  and  whose weight
is the length of that corridor path; otherwise, 
contains the segment  and by the proof in
\cite{ref:ClarksonRe87,ref:ClarksonRe88}, there must be a path in
 whose length is equal to that of
 since  is visible to  with
respect to the cores of . This proves that there is a shortest
- path in  whose length is equal to that of .

Next, we prove that a shortest - path in  must
correspond to a shortest - path in .
To make the paper self-contained we give some details below; for complete details, please refer to \cite{ref:InkuluPl09,ref:ChenA11ESA,ref:ChenCo12arXiv}.
Both  and  are built on 
in the same way, with
the only difference that  is built
with respect to  while  is built
with respect to . A useful fact is that for
any two points  and  on any elementary curve , the length of the portion of  between
 and  is equal to that of the segment  because  is -monotone.
Note that the space outside  is the union
of the space outside  and all ears of .
Since both graphs have extra edges to connect corridor
path terminals, to prove that a shortest - path in 
corresponds to a shortest - path in ,
based on the analysis in \cite{ref:ClarksonRe87,ref:ClarksonRe88}, we
only need to show the following: For any two vertices  and  of
 visible to each other with respect to  such
that no other vertices of  than  and  are in
the axis-parallel rectangle  that has  as a diagonal,
there must be an -monotone path between  and  in
. Note that  may not be visible to  with respect
to .

By the construction of the graph 
\cite{ref:ClarksonRe87,ref:ClarksonRe88}, there must be an -monotone path from  to  in , for which there are two possible cases. Below, we
prove in each case there is also an -monotone path from 
to  in . Without loss of generality, we assume  is
to the northeast of .

\begin{enumerate}
\item
{\bf Case 1}.
If any core of  intersects the interior of the
rectangle , then as shown in
\cite{ref:ClarksonRe87,ref:ClarksonRe88}, either the rightward projection
of  on  and the downward projection of  on
 are both on the same edge of 
that intersects  (e.g., see Fig.~\ref{fig:case1}),
or the upward projection
of  on  and the leftward projection of  on
 are both on the same edge of  that intersects
.  Here, we assume that the former case
occurs. Let  be the rightward projection
of  on  and  be the downward projection of  on
, and  be the edge of  that
contains both  and .
By the construction of , there is an
-monotone path from  to  consisting of
. Below, we show
that there is also an -monotone path from  to  in
.

Let  be the ear of  whose base is
. Let  be the elementary curve of
. Since no vertex of  is in 
and all extreme points of  are in , the rightward
projection of  on  and the downward projection of
 on  must be both on  (e.g., see
Fig.~\ref{fig:case1new}); we denote these two
projection points by  and , respectively. By the
construction of , there must be an -monotone path
from  to  in  that is a concatenation of
, the portion of  between  and , and
 (note that  is a type-1 Steiner point defined by  and  is a type-1
Steiner point defined by  in ).


\begin{figure}[t]
\begin{minipage}[t]{0.49\linewidth}
\begin{center}
\includegraphics[totalheight=1.2in]{case1.eps}
\caption{\footnotesize Illustrating the proof of Lemma \ref{lem:40}:
 is the rightward projection of  on  and 
is the downward projection of  on .}
\label{fig:case1}
\end{center}
\end{minipage}
\hspace*{0.04in}
\begin{minipage}[t]{0.49\linewidth}
\begin{center}
\includegraphics[totalheight=1.2in]{case1new.eps}
\caption{\footnotesize Illustrating the proof of Lemma \ref{lem:40}:
 is the rightward projection of  on  and 
is the downward projection of  on . Both  and
 must be on the same elementary curve .}
\label{fig:case1new}
\end{center}
\end{minipage}
\vspace*{-0.15in}
\end{figure}

\item
{\bf Case 2}.
If no core of  intersects the interior of the rectangle
, then by the construction of , there must be
a cut-line  between  and  such that on ,  defines a Steiner point
 and  defines a Steiner point  (e.g., see
Fig.~\ref{fig:case2}). Thus, there is an
-monotone path from  to  in  consisting of
. Below, we show that
there is also an -monotone path from  to  in
.


\begin{figure}[h]
\begin{minipage}[t]{0.49\linewidth}
\begin{center}
\includegraphics[totalheight=1.2in]{case2.eps}
\caption{\footnotesize Illustrating the proof of Lemma \ref{lem:40}:
 is the rightward projection of  on  and 
is the leftward projection of  on .}
\label{fig:case2}
\end{center}
\end{minipage}
\hspace*{0.04in}
\begin{minipage}[t]{0.49\linewidth}
\begin{center}
\includegraphics[totalheight=1.2in]{case2new.eps}
\caption{\footnotesize Illustrating the proof of Lemma \ref{lem:40}:
 is the rightward projection of  on  and 
is the downward projection of  on . Both  and
 must be on the same elementary curve .}
\label{fig:case2new}
\end{center}
\end{minipage}
\vspace*{-0.15in}
\end{figure}

Since both  and  are built on , they have the same cut-line tree.
Hence, the cut-line  still exists in . If
both  and  are horizontally visible to , then they still
define Steiner points on  and consequently there is also
an -monotone path from  to  in . Otherwise, we
assume that  is not horizontally visible to . Let  be the
rightward projection of  on  (see
Fig.~\ref{fig:case2new}). Hence,  must be
between  and . Let  be the elementary curve that contains
. Thus,  intersects the lower edge of  at .
Since  does not contain any point of ,
the two endpoints of  are not in
 and thus the downward projection of  on ,
denoted by , must be on  as well. By the
construction of , there must be an -monotone path
from  to  in  that is the concatenation of
, the portion of  between  and , and
.
\end{enumerate}

The above arguments prove that a shortest path from  to  in
 corresponds to a shortest path from  to  in the
plane.

It remains to show
that a shortest - path in  corresponds
to a shortest - path in . This can be
seen easily since for any edge  in ,
if  is not
in , then  is ``divided" into many edges in  such
that their concatenation is a path from  to .

The lemma thus follows.
\end{proof}

The next lemma gives an algorithm for computing the graph .

\begin{lemma}\label{lem:50}
The graph  can be computed in
 time.
\end{lemma}
\begin{proof}
The algorithm for constructing  is similar to that for  in Lemma \ref{lem:10}.
As a preprocessing, the free space  can be triangulated in
 time for any constant 
\cite{ref:Bar-YehudaTr94}, after which computing the extended corridor
structure, in particular, takes  time
\cite{ref:ChenA11ESA,ref:ChenCo12arXiv,ref:ChenL113STACS}.
Consequently, we obtain
 and the vertex set . All corridor paths are also available.

First, we compute the four projections of each point of
 on  as type-1 Steiner points, which can be
done after we compute the vertical and horizontal visibility
decompositions of  in  time
\cite{ref:Bar-YehudaTr94}. The graph edges for connecting each point
of  to its four projection points on  can
be obtained as well.

Next, we compute the type-2 and type-3 Steiner points and the corresponding graph edges
connecting these Steiner points. Since , the
cut-line tree  can be computed in  time.
Then, we determine the Steiner points on the cut-lines by traversing the tree  from top to bottom in a similar way as in Lemma \ref{lem:10}. Since we have obtained the four projection points for each point of , computing all Steiner
points on the cut-lines takes 
time. Their corresponding edges can be computed in  time.

It remains to compute the graph edges of  connecting consecutive
graph nodes on each elementary curve of  and the graph edges connecting
every two consecutive Steiner points (if they are visible to each other)
on each cut-line.

On each connected component  of , we could compute a sorted
list of all Steiner points and the points of 
by sorting all these points and all obstacle
vertices of  along . But that would take  time
in total because there are  obstacle vertices on all components
of . To do better, we take the following approach. For
each elementary curve , we sort all Steiner points on  by either their
-coordinates or -coordinates. Since  is -monotone,
such an order is also an order along . Then, we merge
the Steiner points thus ordered with the obstacle vertices on ,
in linear time. Since there are  Steiner points on
, it takes totally  time to sort the
Steiner points and obstacle vertices on all elementary curves of
. After that, the edges of  on all elementary
curves can be computed immediately.

We now compute the graph edges on the cut-lines connecting consecutive
Steiner points. We first sort all Steiner points on each cut-line. This
sorting takes  time for all
cut-lines. For each pair of consecutive Steiner points  and  on
every cut-line, we determine whether  is visible to  by
checking whether the upward projections of  and  on
 are equal, and these upward projections can be
performed in  time using the vertical visibility
decomposition of . Hence, the graph edges on all cut-lines are
computed in  time.

In summary, we can compute the graph  in  time. Note that . The
lemma thus follows.
\end{proof}


Consider any two query points  and  in the ocean
. We define the gateway sets
 for  and  for  on ,
as follows. We only discuss ;
 is similar. The definition of
 is very similar to that of , with only
slight differences. Specifically,  has two subsets
 and .
 is defined in the same way as
, and thus .
 is defined with respect to the elementary
curves of , as follows. Let  be the rightward projection point of 
on . Suppose  is on the elementary curve  and
 and  are the two
nodes of  on  adjacent to . Then  and 
are in , and for each , we define a gateway edge from  to  consisting of
 and the portion of  between  and . Similarly,
for each of the leftward, upward, and downward projections of  on
, there are at most two gateways in .

The next lemma shows that the gateways of 
``control'' the shortest paths from  to all points of .

\begin{lemma}\label{lem:60}
For any point  of , there exists a shortest path from
 to  using  that contains a gateway of  in
.
\end{lemma}
\begin{proof}
We define a gateway set  for  on the graph
, as follows. The set 
has two subsets  and
. The first subset 
is exactly the same as , and the second subset
 contains gateways on the cut-lines of
, which are defined similarly as  on
 and , discussed in Section \ref{sec:pre}. Note
that the gateways in  are exactly those nodes
of  that are adjacent to  if we ``insert'' 
into the graph  (similar arguments were used for
 in \cite{ref:ChenSh00}). Hence, there exists a
shortest path from  to  using  that contains a
gateway of  in .

Since the graph  is defined analogously as  and
 is defined analogously as , by using a similar
analysis as in the proof of Lemma \ref{lem:20}, we can show that there
exists a shortest path from  to  using  that contains a
gateway of  in . We omit the details. The
lemma thus follows.
\end{proof}

Similar results also hold for the gateway set  of .
We have the following corollary.

\begin{corollary}\label{cor:20}
If there exists a shortest \st\ path through a point of
, then there exists a shortest \st\ path through a gateway of
 in  and a gateway of  in .
\end{corollary}

The following lemma gives an algorithm for computing the gateways.

\begin{lemma}\label{lem:70}
With a preprocessing of  time and
 space,
the gateway sets 
and  can be computed in
 time for any two query points  and  in .
\end{lemma}
\begin{proof}
The algorithm is similar to that for Lemma \ref{lem:30}; we only point
out the differences. We discuss our algorithm only for computing
; the case for  is similar.

To compute , we build the horizontal and vertical
visibility decompositions of .
Then, the four projections of  on  can be determined
in  time. Consider
any such projection  of . Suppose  is on an elementary curve . We need to
determine the two nodes of  on  adjacent to ,
which are gateways of .
We maintain a sorted list of all nodes of  on , and
do binary search to find these two gateways of  on  in
this sorted list by using only the -coordinates (or the
-coordinates) of the nodes since  is
-monotone. Also, since  is -monotone, for any two points
 and  on , the length of the portion of  between  and
 is equal to the length of . Hence, after these
two gateways of  on  are found, the lengths of the two gateway
edges from  to them can be
computed in constant time. Since  has 
gateways,  can be computed in  time.

To compute , we take the same approach as for Lemma \ref{lem:30}.
In the preprocessing, for every cut-line , we maintain a sorted list of all Steiner points
on , and associate with each such Steiner point its upward and downward projections
on .
Computing these projections for each Steiner point takes  time.
Then we build a fractional cascading data structure \cite{ref:ChazelleFr86} for
the sorted lists of Steiner points on all cut-lines along the cut-line tree
. Using this fractional cascading data structure, the gateway set
 can be computed in  time.

The preprocessing takes totally  time and
 space.
Note that
.
The lemma thus follows.
\end{proof}

We summarize our algorithm in Lemma
\ref{lem:80} below for the case when both query points are in .

\begin{lemma}\label{lem:80}
With a preprocessing of  time and
 space,
each two-point query can be answered in 
time for any two query points in the ocean .
\end{lemma}
\begin{proof}
In the preprocessing, we build the graph , and for each node
 of , compute a shortest path tree in 
from . We maintain a shortest path length table such that for
any two nodes  and  in , the shortest path length
between  and  can  be found in  time. Since
 has  nodes and edges, computing and maintaining
all shortest path trees in  take  space and
 time.


To report an actual shortest path in the plane in time linear to the number of edges of
the output path, we need to maintain additional information. Consider an elementary curve
 of . Let  and  be two consecutive nodes of  on .
By our definition of , there is an edge 
in . If the edge  is contained in our output path, we
need to report all obstacle vertices and edges of  between  and
. For this, on each elementary curve , we explicitly
maintain a list of obstacle edge between each pair of consecutive nodes of
 along . Since the total number of nodes of 
on all elementary curves is  and the total number of obstacle
vertices of  is , maintaining such {\em edge lists} for
all elementary curves takes  space.

In addition, we also perform the preprocessing for Lemma \ref{lem:70}.

The overall preprocessing takes  time and
 space.


Now consider any two query points  and  in . As
for Theorem \ref{theo:10}, we first check whether there
exists a trivial shortest \st\ path. But trivial shortest paths
here are defined with respect to the elementary curves of  instead of the obstacle
edges of . For example, consider  (i.e., the rightward projection of
 on ) and . If 
intersects , then there is a trivial shortest \st\
path , where ; otherwise, if  and  are both on the same
elementary curve  of , then there is a trivial shortest
\st\ path which is the concatenation of , the
portion of  between  and , and .
Similarly, trivial shortest \st\ paths are also defined by other
projections of  and  on .

We can determine whether there exists a trivial shortest \st\ path in
 time by using the vertical and horizontal decompositions of
 to compute the four projection points of  and
 on . If yes, we find such a shortest path in
additional time linear to the number of edges of the output path. Note
that for the case, e.g., when  and  are both on the same elementary curve
, the output path may not be of  size since there
may be multiple obstacle vertices on the portion of  between 
and ; but we can still output such a path in linear time by using the
edge lists we maintain on each elementary curve.
Below, we assume there is no trivial shortest \st\ path.

By using the cores of  in the proof of Lemma \ref{lem:40} and
a similar analysis as in \cite{ref:ChenSh00}, we can show that
there must be a shortest \st\
path that contains at least one point of . By
Corollary \ref{cor:20}, there exists a shortest \st\ path through a
gateway of  and a gateway of  in . Using Lemma \ref{lem:70}, we
compute the two gateway sets  and
. By building a gateway graph for  and  as
in Theorem \ref{theo:10}, we can compute the length of a
shortest \st\ path in  time since
,
, and thus
the gateway graph has  nodes and  edges.
An actual path can then be reported in additional time linear
to the number of edges of the output path, by using the shortest path
trees of  and the edge lists maintained on the elementary
curves, as discussed above.
The lemma thus follows.
\end{proof}




\subsection{The General Queries}
\label{subsec:general}

In this section, we show how to handle the general queries in which at least one query point
is not in . Without loss of generality, we assume that  is in
a bay or a canal, denoted by . We first focus on the case when
 is a bay. The case when  is a canal can be handled by similar
techniques although it is a little more complicated since each canal
has two gates. The point  can be in , ,
or another bay or canal, and we discuss these three cases below.
Let  denote the gate of .

As an overview of our approach, we characterize the different possible ways that a
shortest \st\ path may cross the gate , show how to find
such a possible path for each way, and finally compute all possible ``candidate"
paths and select the one with the smallest path length as our solution.

\subsubsection{The Query Point  is in }

When the query point  is in , we have the following lemma.

\begin{lemma}\label{lem:90}
If  is a bay and , then there exists a shortest \st\ path in .
\end{lemma}
\begin{proof}
Let  be any shortest \st\ path in the plane. If  is in , then we are
done. Otherwise,  must intersect the only gate  of ; further, since both  and
 are in , if  exits from  (through ), then it must enter  again
(through  as well).  Let  be the first point on  encountered as
going from  to  along  and let  be the last such
point on . Let  be the \st\ path obtained by replacing the portion of 
between  and  by . Note that  is in .
Since  is a
shortest path from  to ,  is also a shortest \st\ path.
The lemma thus follows.
\end{proof}

To handle the case of , in the preprocessing,
we build a data structure for two-point Euclidean shortest path queries
in , denoted by ,
in  time and space \cite{ref:GuibasOp89}.
Since a Euclidean shortest path in any simple polygon is also an 
shortest path and  is a simple polygon, for , we can use  to
answer the shortest \st\ path query in  in  time.


\subsubsection{The Query Point  is in }

If the query point  is in , then a shortest \st\ path must cross the gate  of
. A main difficulty for answering the general queries is to deal with this case.
More specifically, we already have a graph  on ,
and our goal is to design a mechanism to connect the bay  with
 through the gate , so that it can
capture the shortest path information in the union of  and  (recall that  is the union of  and all corridor paths).




We begin with some
observations on how a shortest \st\ path may cross . Without
loss of generality, we assume that  has a positive slope and
the interior of  on  is above .
Let  and  be the two endpoints of  such that 
is higher than  (see Fig.~\ref{fig:funnel2}).
Let  (resp., ) be the Euclidean shortest path in  from  to
 (resp., ).
Let  be the farthest point from  on 
(possibly ). Let  (resp., )
be the subpath of  (resp., )
between  and  (resp., ).
It is well known that both  and
 are convex chains \cite{ref:GuibasLi87,ref:LeeEu84}, and
the region enclosed by , , and  in  is a
``funnel'' with  as the {\em apex} and  as the {\em base} (see
Fig.~\ref{fig:funnel2}).  Let 
denote this funnel and  denote its boundary.

We define four special points , and  (see Fig.~\ref{fig:funnel2}).
Suppose we move along  from ; let  be the first point on 
we encounter that is {\em horizontally} visible to . Similarly, as
moving along  from , let  be the first point on  encountered
that is {\em vertically} visible to .
Note that in some cases  (resp., ) can be , , or .
Let  be the horizontal projection
of  on  and  be the vertical projection of
 on   (see Fig.~\ref{fig:funnel2}).


\begin{figure}[t]
\begin{minipage}[t]{\linewidth}
\begin{center}
\includegraphics[totalheight=1.7in]{funnel2.eps}
\caption{\footnotesize Illustrating the definitions of
, and . In (a),  is tangent to  (at ); in (b),  is tangent to .}
\label{fig:funnel2}
\end{center}
\end{minipage}
\vspace*{-0.15in}
\end{figure}




The points  and  are particularly useful.
We first have the following observation.

\begin{observation}\label{obser:10}
The point  is above , i.e., the -coordinate of  is no smaller than that of .
\end{observation}
\begin{proof}
If  is either  or , then by their definitions, we have  and
the observation trivially holds. Suppose  is neither  nor . If , then
the observation also holds since  is the highest point on . We assume ,
which implies .

Let  be the portion of  between  and . Note that the
``pseudo-triangular'' region enclosed by , , and  does not contain any point of  in its interior.
For any point  in the interior of ,
since  is convex and  is horizontal,  must be vertically
visible to , say, at a point . Clearly,  is not .
Hence, the line containing  cannot be tangent to  at ,
implying that  is not . Therefore, the point  must be strictly above . Since  is an arbitrary point in the interior of ,  must be above . The observation thus follows.
\end{proof}


\begin{lemma}\label{lem:100}
For any point , there is a shortest path from  to  that
contains ; likewise,
for any point , there is a shortest
path from  to  that contains .
\end{lemma}
\begin{proof}
We only prove the case of  since the other case of
 is symmetric. It suffices to show that there exists a shortest
path from  to  that contains .

Recall that  is the horizontal projection of  on . Let  be the portion of  between  and .
Consider the ``pseudo-triangular'' region  enclosed by ,
, and . Since  is convex, every point on
 is horizontally visible to .

We claim that there exists a shortest path  from  to  that intersects . Indeed, if , then the claim is trivially true. Otherwise, since  is the first point on  that is horizontally visible to  if we go from  to  along ,  cannot be horizontally visible to , and thus,  is not in . Note that  partitions the funnel  into two parts, one of which is . Also,
the funnel  contains a shortest path  from  to . Since  and , the path  must intersect . The claim is proved.

Suppose  intersects  at a point . Since  is -monotone (and thus is a shortest path), we can obtain another shortest path from  to  that contains  by replacing the portion of  between  and  by . The lemma thus follows.
\end{proof}

For the case of ,
Lemma \ref{lem:100} implies the following: If a shortest \st\ path
crosses  at a point on  (resp.,
), then there must be a shortest \st\ path that is a
concatenation of a shortest path  (resp., ) from  to  (resp., ) in
 and a shortest path  from  (resp.,  from ) to  in .
The path  can be found using the data structure 
and  can be found by Lemma \ref{lem:80} since both  and  are in .
Hence, such a shortest \st\ path query is answered in  time, provided that
we can find  and  in  time (as to be shown in Lemma \ref{lem:170}).

In the following, we assume every shortest \st\ path crosses the interior of , and in other words, no shortest \st\ paths cross .

Let  denote the
intersection of the horizontal line containing  and the
vertical line containing  (see Fig.~\ref{fig:funnel2}).
The point  is useful as shown by the next lemma.

\begin{lemma}\label{lem:110}
The point  is in the funnel , and for any point , there is a shortest path
from  to  that contains .
\end{lemma}
\begin{proof}
We first prove . For this, it suffices to prove that the interior of the triangle
 does not contain any point on the boundary of .
Let  denote the interior of .

Assume to the contrary that  intersects . Let  be any point in
 that is horizontally visible to . Such a point 
always exists if . Note that  is on either 
or .
Without loss of generality, assume  is on .
Observe that  is -monotone since  is horizontally visible to .
Because  is also horizontally visible to , by the definition of ,  must be
on . Since  is in ,  must be strictly below . Since  is no
lower than ,  is also no lower than . Thus, when following the path
 from  to , we have to strictly go down (through ) and then go up
(to ), which contradicts with that the fact the path  is
-monotone. Hence,  cannot contain any point on  and  must be in .

Consider any point . Below we prove that there is a shortest path from
 to  containing . It suffices to show that there exists a shortest path from 
to  containing . If , then  and we are done. Below we assume
, which implies  since otherwise  by Observation
\ref{obser:10}; similarly, . Note that  also implies
.

Let  be a shortest path in  from  to . Let  be the horizontal line containing  and  be the vertical line containing .

In the following, we first prove that  is a line segment and it must intersect the path .
Consider the line segment . Depending on whether  is tangent
to  at , there are two possible cases (e.g., see Fig.~\ref{fig:funnel2}).

\begin{enumerate}
\item
If  is tangent to  at  (see Fig.~\ref{fig:funnel2}(a)), then we extend
 horizontally leftwards until it hits , say, at a point . Since  is convex,  is above the line  and  is on . Since  is also convex and  is above , we obtain .

Observe that  partitions  into two sub-polygons such that  and
 are in different sub-polygons. Hence, the path  must intersect
, which is a line segment.

\item
If  is not tangent to  at , then depending on whether , there are two subcases.

\begin{enumerate}
\item
If , then due to the convexity of  and , we have . Since , it is trivially true that  intersects .

\item
If  (see Fig.~\ref{fig:funnel2}(b)), then we claim that  must be tangent to  at a point, say, . Suppose to the contrary that this is not
the case. Then, since , , and  is not tangent to  at , we can move  downwards by an infinitesimal value such that the new  intersects
 at a point  and intersects  at a point  such that  is horizontally visible to . Clearly,  is on  between  and .
But this contradicts with the definition of , i.e.,  is the first point on  horizontally visible to  if we go from  to  along . The claim is thus proved.

By the above claim and the convexity of ,  is below . Also by the
convexity of , we have . Further, observe that  partitions  into two sub-polygons such that  and  are in different sub-polygons. Hence, the path  must intersect .

Therefore,  is a line segment that intersects .
\end{enumerate}
\end{enumerate}

The above arguments prove that  is a line segment that intersects the path , say, at a point . By using a
similar analysis, we can also show that  is a line segment that intersects , say, at a point . Note that this implies that  is on the intersection of the segment  and the segment .
Since  is -monotone (and thus is a shortest path),
if we replace the subpath of  between  and 
by  to obtain another path
 from  to , then  is still a shortest path. Since  contains , the lemma follows.
\end{proof}

If there is a shortest \st\ path crossing  at a point on ,
then by Lemma \ref{lem:110}, there is a shortest \st\ path that is a
concatenation of a shortest path from  to  in  and a
shortest path from  to  (which crosses ). A shortest - path in
 can be found by using the data structure  in  time,
provided that we can compute  in 
time. It remains to show how to compute a shortest - path that
crosses  at a point on . Note that
such a shortest - path either does or does not cross a point in
, where  is the set of
points of  lying on 
( is possible).
For the former case (when  holds), we shall
build a graph  inside  and merge it with the graph  on  so that
the merged graph allows to find a shortest - path crossing a point in
. Next, we introduce the graph .

Let . The graph  is defined on the points
of  in a similar manner as  in Section \ref{sec:newgraph}. One big difference is that  is built inside  and uses vertical {\em cut-segments} in 
instead of cut-lines. Also, no type-1 Steiner point is needed for .
Specifically, we define a {\em cut-segment tree}  as follows. The root  of  is associated with a point set . Each node  of  is also associated with a vertical {\em cut-segment}
, defined as follows. Let  be the point of  that has the median -coordinate among all
points in . Note that  is on . We extend a vertical line
segment from  upwards into the interior of  until it hits ; this segment is the cut-segment .
The left (resp., right) child of  is defined recursively on the points of  to the left (resp., right) of .

Clearly,  has  levels and 
super-levels. We define the type-2 and type-3 Steiner points on the cut-segments of 
in the same way as in Section \ref{sec:newgraph}.
Consider a super-level and let  be any node at the highest level of this super-level. For
every , for each cut-segment  in the subtree  of  in the same super-level,
if  is horizontally visible to , then the horizontal projection  of  on  is defined as a Steiner point on ; we order the Steiner points defined by  from left to right,
and put an edge in  connecting every two such consecutive Steiner points.
Hence, there are  Steiner points on all cut-segments
of . The above process also defines  edges in .

The node set of  consists of all points of  and all Steiner points on the
cut-segments of . In addition to the graph edges defined above, for each cut-segment ,
a graph edge connects every two consecutive graph nodes on 
(note that here every two such graph nodes are visible to each other).
Clearly,  has  nodes and   edges.

Let  denote the number of obstacle vertices of the bay .
Note that  is sorted along .

\begin{lemma}\label{lem:120}
The graph  can be constructed in
 time.
\end{lemma}
\begin{proof}
To compute the cut-segments of , for each point , we need to
compute the first point on the boundary of  hit by extending a
vertical line segment from  upwards.
For this, we first compute the vertically visible region of  from the segment 
using the linear time algorithms in \cite{ref:JoeCo87,ref:LeeVi83}, and then
find all such cut-segments from the points of , in  time.
The cut-segment tree  can then be computed in
 time.

To compute the Steiner points on the cut-segments, for each point
, we find the first point  on the boundary of 
horizontally visible from .
The points  for all  can be computed in totally
 time by using the algorithms in \cite{ref:JoeCo87,ref:LeeVi83}.

Next, we compute the Steiner points on the cut-segments of .
Determining whether a point  is
horizontally visible to a cut-segment  (and if yes, put a
corresponding Steiner point on ) takes  time using
, as follows. We first check whether the -coordinate of  is between the
-coordinate of the lower endpoint of  and that of the upper
endpoint of ; if yes, we check whether  is between  and
 (if yes, then  is horizontally visible to );
otherwise,  is not horizontally visible to .
Thus, all Steiner
points can be obtained in  time.

For each cut-segment , to compute the edges between consecutive graph nodes
on , it suffices to sort all Steiner points on
. The sorting on all cut-segments takes  time.

Hence, the total time for building the graph  is .
The lemma thus follows.
\end{proof}



We define a gateway set  for  on  such that
for any point ,
there is a shortest path from  to
 using  containing a gateway of .
 is defined similarly as  in Section \ref{sec:newgraph},
but only on the Steiner points in the triangle 
(because  contains a shortest path
from  to any point in ). Specifically, for each
{\em relevant projection cut-segment}   (defined similarly as the
relevant projection cut-lines in Section \ref{sec:newgraph})
of  to the right of , if  is horizontally visible
to , then the node of  on  immediately below the horizontal projection
point of  on  is in . Thus,
.

\begin{lemma}\label{lem:130}
For any point ,
there is a shortest path from  to
 in  using  that contains a gateway of  in .
\end{lemma}
\begin{proof}
Consider a point . Note that
 defines a node in . Let  be the cut-segment
through . Since the triangle  and
,  is horizontally visible to .

If there is no other cut-segment of  strictly
between  and , then  must be a relevant projection
cut-segment of . Let  be the gateway of  on , i.e., the
graph node on  immediately below the horizontal
projection  of  on .
Note that the path
 is a shortest path from 
to  since it is -monotone. Clearly, this path contains
the gateway .

If there is at least one cut-segment strictly between  and ,
then if  is a relevant cut-segment of , we can prove the
lemma by a similar analysis as above; otherwise,
there is at least one node  in  such that
 is a relevant projection cut-segment of  between  and 
and  defines a Steiner point on  (this can be seen
from the definition of the graph ; we omit the
details). Let  be the horizontal projection
of  on  and  be the horizontal projection
of  on . The path
 is a
shortest path from  to  since it is -monotone. Because
 is a Steiner point on , this
path must contain a gateway of  on  (this gateway must be
on ).
The lemma thus follows.
\end{proof}

Since , each
point of  is also a node of . We merge
the two graphs  and  into one graph, denoted by ,
by treating the two nodes in these two graphs
defined by the same point in  as a single node.
By Lemmas \ref{lem:60} and
\ref{lem:130}, we have the following result.


\begin{lemma}\label{lem:140}
If a shortest \st\ path contains a point in ,
then there is a shortest \st\ path along  containing
a gateway of  in  and a gateway of  in
.
\end{lemma}
\begin{proof}
Let  be a point of  that is
contained in a shortest \st\ path. By Lemma \ref{lem:110}, there is a
shortest path from  to  that contains . By Lemma
\ref{lem:130}, there is a shortest path from  to  that contains
a gateway of  in . On the other hand, since both 
and  are in the ocean  and ,
by Lemma \ref{lem:60}, there exists
a shortest path from  to  that contains a gateway of  in
.  This proves the lemma.
\end{proof}

By Lemma \ref{lem:140}, if there is a shortest path from  to 
that contains a
point of , then we can use the gateways
of both  and  to find a shortest path along the graph .
By using a similar algorithm as that for Lemma \ref{lem:30}, we can
compute the gateways of  on .

\begin{lemma}\label{lem:150}
With a preprocessing of  time and
 space,  we
can compute the gateway set  of  in  time.
\end{lemma}
\begin{proof}
The algorithm is similar to that in Lemma \ref{lem:30} for computing
. One main difference is that here every two graph
nodes on any cut-segment of  are visible to each other.
As the preprocessing, we build a sorted list of the graph nodes on each
cut-segment of , and construct a fractional cascading data
structure \cite{ref:ChazelleFr86} along  for the sorted lists of all
cut-segments. Then for a point
,  can be computed in  time.
\end{proof}

So far, we have shown how to find a shortest \st\ path if such a path
contains a point in .
It remains to handle the case when
no shortest \st\ path contains a point in
 (including the case of
), i.e.,
no shortest path from  to  contains a point in
.
Lemma \ref{lem:160} below shows that in this case,  must be horizontally
visible to  and thus there is a trivial shortest
path from  to .

\begin{lemma}\label{lem:160}
If no shortest path  contains a point in
 (this includes the case of ), then
 must be horizontally visible to .
\end{lemma}
\begin{proof}
Let the points of  be
 ordered along  from  to
, and let  and . Under the condition of this lemma, since
, there exists a shortest path
 from  to  that crosses  once, say, at a point  in
the interior of ,
for some  with  (see Fig.~\ref{fig:visibility}).
For any two points  and 
on , let  denote the subpath of  between
 and . Hence,  is in  and  is outside . Then
 is in  (i.e.,  is the union of  and all corridor paths).


\begin{figure}[t]
\begin{minipage}[t]{\linewidth}
\begin{center}
\includegraphics[totalheight=1.5in]{visibility.eps}
\caption{\footnotesize Illustrating a shortest path (the red dashed curve) from
 to  crossing the interior of  at .}
\label{fig:visibility}
\end{center}
\end{minipage}
\vspace*{-0.15in}
\end{figure}



We extend a horizontal line segment from  (resp., ) to the right until
hitting the first point on , denoted by  (resp., );
if  and  are not on the same elementary curve of
 (in which case
one or both of  and  are extremes on different
elementary curves),
then we keep moving one or both of  and  horizontally
to the right until hitting the next point on .
By the definitions of  and , in this way,
we can always put both  and  on the same
elementary curve of , say  (see Fig.~\ref{fig:visibility}); let
 denote the
portion of  between  and . Let  denote the
region enclosed by , ,
, and . Note that for
any point ,  is horizontally visible to
 and thus is horizontally visible to
.
In the following, we will show that  must be in , which proves the lemma.


Suppose to the contrary . We then show that
the path  must intersect  or
, which implies that
there is a shortest - path containing a point in
,
a contradiction (recall that we have an assumption that no shortest \st\ paths cross ). Indeed, if  intersects 
(resp., ), say, at a point , then we can obtain a new
- path  by replacing 
with an -monotone path 
(resp., ), and  is
a shortest - path containing
a point in .
Below, we show that  must intersect  or
. Note that  may
overlap with a gate of a canal. Depending on whether 
overlaps with any canal gate, there are two possible cases.

\begin{enumerate}
\item
If  does not overlap with any canal gate, then
since , , , and , if we go
from  to , we must enter .  The only place on the boundary of  we can cross to
enter  is either  or
. Hence,  must intersect  or
.


\item
If  overlaps with a canal gate, say , then one may wonder
that  could enter the interior of  through  without
crossing any of  and .
Since  is a canal gate, one of 's endpoints, say, , must be a corridor path
terminal, and  may or may not be on .
If  is on , then since  is in ,
 cannot be in the interior of  and can only be at an endpoint
of . Let  be the canal that has  as a
gate, and  be the corridor path of . If 
enters the interior of  through , then it must travel through the canal ,
implying that  contains the corridor path .
Since  is on ,  contains .
If  is on  (and thus is an endpoint of ),
then  is one of  or ; hence,  intersects  or
.
Suppose now  is not on .  Then an endpoint of ,
say, , lies on  (but ). Further,  goes through , and then
enters , but without intersecting any of 
and .  Thus,  must cross some point  of 
to enter .  We can then replace the portion  of  by the segment
 to obtain a new shortest - path.
Since  divides  into two parts, one outside  and
containing  and the other intersecting  and containing , the segment
 contains .  Hence, the new shortest - path
intersects .


\end{enumerate}

The lemma thus follows.
\end{proof}

By Lemma \ref{lem:160}, if the condition of the lemma
holds, then we can always find a trivial shortest path from  to
 by shooting vertical and horizontal rays from  and , respectively.


We have finished all possible cases for finding a shortest \st\ path
when  and .
The next lemma is concerned with computing the special
points , and  for any point  in .


\begin{lemma}\label{lem:170}
With a preprocessing of  time and space,
the three special points , , and
 can be found in  time for any query point  in , where .
\end{lemma}
\begin{proof}
Consider any query point . To determine , , and
, based on our previous discussions, it suffices to compute the two points  and .
We only show how to design a data structure for computing  since the solution for finding  is similar.
Note that .

In the preprocessing, for each vertex  of , we find whether  is horizontally
visible to , and if yes, mark  as an {\em h-vertex}. All h-vertices of  can be marked
by computing the horizontal visibility of  from  in  time \cite{ref:JoeCo87,ref:LeeVi83}.
Also, in  time, we compute the Euclidean shortest path
tree  from  to all vertices of  and the corresponding shortest path map
 in  \cite{ref:GuibasLi87}; similarly, we compute the shortest path
tree  from  and the corresponding shortest path map .

For each vertex , we associate  with two special vertices:
 and , defined as follows. The vertex  is the first
h-vertex on the path in  from  to  and  is the child
vertex of  on the path in  from  to ; if ,
then  does not exist and we set . Note that  is
not an h-vertex if it exists. The  vertices for all vertices in  can be computed in  time by a depth-first search on  starting at .
For each vertex , we compute only one special vertex for , , which
is the first h-vertex on the path in  from  to . The  vertices for all vertices of  can also be computed in  time.

This finishes our preprocessing, which takes  time in total.

Below we find the point  in  time.
Let  and  be the Euclidean shortest paths in 
from  to  and , respectively. For any point , let  denote its -coordinate.

By using the shortest path map , we find the vertex, denoted by , which directly connects
to  on . Likewise, we find the vertex  that directly connects to  on
 using . Both  and  are found in  time. Depending on whether , there are two main cases.

\begin{enumerate}
\item
If , then clearly . Let  and . Note that 
and  are available once we find  and . Depending on whether , we further have two subcases.

\begin{enumerate}
\item If , then we claim . Indeed, since  is the last common vertex
of  and  if we move on them from , no vertex on
 can be horizontally visible to  except possibly .
Because ,  must be on . Since  is
horizontally visible to ,  must hold.

    By the definition of , the above claim implies .

\item If , then an easy observation is . Let . Note that due to  and ,  exists.

    If , then the horizontal visibility of  to  is ``blocked'' by the
path  (e.g., see Fig.~\ref{fig:funnel2}(a)). Thus we obtain .

    If , then the horizontal visibility of  to  is ``blocked'' by
the path  (e.g., see Fig.~\ref{fig:funnel2}(b)). Thus we obtain that  is
the horizontal projection of  on the line segment , which can be computed in  time.
\end{enumerate}

\item
If , then .
If  is horizontally visible to  (which can be determined in  time
using the horizontal visibility decomposition of ), then .  Otherwise,
let  and . Depending on whether , we further have two subcases.

\begin{enumerate}
\item If , then  exists and we let .
Note that  is a convex chain.


    Similar to the above discussion, if , then we have ; otherwise,  is the horizontal projection of  on .

\item
If , then  connects directly to  on .
Similar to the above discussion, if , then we have ; otherwise,  is the horizontal projection of  on .
\end{enumerate}
\end{enumerate}

Therefore, we can find the point  in  time. The lemma thus follows.
\end{proof}


We have discussed all possible cases of finding a shortest \st\ path
when  is in a bay  and  is in the ocean , and in each case,
we can obtain a shortest path in  time.

\subsubsection{The Point  is in Another Bay}

Let  be the bay containing  with gate , and
 be the bay containing  with gate .
In this case, any shortest \st\ path must cross both  and . The
algorithm for this case is similar to the one for the case of . Again, we need to
consider different cases of how a shortest \st\ path may cross
different portions of both the gates  and .

We define the points , , and  in  for  in the
same way as
before, but denote them by , , and  instead.
Similarly, we define the corresponding three points ,
, and  in  for . Based on our previous
discussions, we have the following cases.

\begin{enumerate}
\item
There is a shortest \st\ path containing a point  in
 and a point  in .
Note that both  and  are on their bay gates and thus are in .

In this case, there must be a shortest \st\ path that is a
concatenation of a shortest path  from  to  in
, a shortest path  from  to  in ,
and a shortest path  from  to  in . The path
 can be found by using , i.e., the Euclidean
two-point shortest path query data structure on 
\cite{ref:GuibasOp89}, and similarly,  can be found by
using . The path  can be found by using our data
structure for  in Lemma \ref{lem:80}.

\item
There is a shortest \st\ path that contains 
and a point  in .

In this case, there must be a shortest \st\ path that is a
concatenation of a shortest - path  in
, a shortest - path , and a shortest - path
 in .
The path  (resp., ) can be found by using 
(resp., ), and the path
 can be found by using similar algorithms
as discussed above since  is in .

\item
There is a shortest \st\ path that contains 
and a point  in .

This case is solved by using the similar approach as for Case 2 above.

\item
There is a shortest \st\ path that contains  and .

In this case, there must be a shortest \st\ path that is a concatenation of a shortest path
 from  to  in
, a shortest path  from  to ,
and a shortest path  from  to  in .
The path  (resp., ) can be found by using 
(resp., ).  It remains to show how to compute  below.
\end{enumerate}

Recall that we have defined a graph  in  on the points of
, which consists of all points of  lying on . We
also find a gateway set  for  on . Similarly,
for  and its gate , we define , , and
. Let  be the graph formed by merging
, , and .
A shortest path from  to  can be found based on Lemmas \ref{lem:180} and \ref{lem:190}
below, which are similar to Lemmas \ref{lem:140} and \ref{lem:160}, respectively.

\begin{lemma}\label{lem:180}
If there is a shortest path from  to  containing a point in  and a point in ,
then there is a shortest path from  to  along  that contains
a gateway of  in  and a gateway of  in
.
\end{lemma}
\begin{proof}
Suppose there is a shortest - path containing a point  in  and a point  in .
Then by Lemma \ref{lem:130}, there is a shortest - path  along 
containing a gateway of  in  and there is a shortest -
path  along  containing a gateway of  in .
Since both  and  are in , by Lemma \ref{lem:40}, there exists a shortest
- path  along .

The concatenation of , , and  is a shortest - path,
which is along the graph  and contains a gateway of  and a gateway of .
\end{proof}



\begin{lemma}\label{lem:190}
If no shortest - path contains any point of
, then
 must be horizontally visible to ;
similarly, if no shortest - path contains any
point of , then  must be horizontally visible
to .
\end{lemma}
\begin{proof}
We prove only the case when no shortest -
path contains any point of ,
 must be horizontally visible to 
(the other case is similar).


Let  be a shortest - path that intersects
 at a point  and intersects  at a point  (see
Fig.~\ref{fig:vispath}).  Let  denote
the subpath of  between any two points  and  on . We assume
, , and
, since such a path  always exists.

Let the points of  on  be
 ordered along  from  to
, and let  and .
Suppose  is in the interior of
, for some  with .
We define , , , and  in the same way
as in the proof of Lemma \ref{lem:160}.

Since  is in , by the proof of Lemma \ref{lem:160}, 
must be in the region . Further, since  is on ,  is on . Thus,
 is not empty. Since  is a line segment,
 is also a line segment.
Let .
Thus, .

Recall that  is visible to  and
 is horizontal. Hence, to prove that
 is horizontally visible to , it
suffices to prove that  is horizontally visible to
. For this, it suffices to prove that  must
be on  since every point on
 is horizontally visible to
. In the following, we prove .


\begin{figure}[t]
\begin{minipage}[t]{\linewidth}
\begin{center}
\includegraphics[totalheight=1.5in]{vispath.eps}
\caption{\footnotesize Illustrating a possible shortest path (the red dashed curve) from
 to  crossing . If this happens, we can
find another shortest path , which contains . In this example, 
and .}
\label{fig:vispath}
\end{center}
\end{minipage}
\vspace*{-0.15in}
\end{figure}

Suppose to the contrary  (see
Fig.~\ref{fig:vispath}).
Without loss of generality, we assume  is closer to 
than . Since , .
This implies that  is not an endpoint of , and thus
 must be an endpoint of  (i.e., one of
 or ) since
; assume .
We extend  horizontally into the bay  until
hitting a point, say , on the boundary of  (see
Fig.~\ref{fig:vispath}). The horizontal segment
 partitions  into two sub-polygons such that  and
 are in different sub-polygons. Since  is
horizontal,  and  are also in different sides of
, implying
that the path  must intersect
 since  is in .
Let  be the intersection of  and  (see
Fig.~\ref{fig:vispath}).
Then, the concatenation of  , ,
and  is also a shortest path from  to  since
 is -monotone.
But this means that there is a shortest
- path containing , contradicting
with the lemma condition that no shortest - path contains any point of
.

The above arguments prove that  is on .
The lemma thus follows.
\end{proof}

By Lemmas \ref{lem:180} and \ref{lem:190}, we can find a shortest
- path by either using the gateways of  and
 in the merged graph
 or shooting horizontal and vertical rays from
 and . We have finished all possible cases for finding a
shortest \st\ path when the two query points are in different bays.
For each case, we compute a ``candidate" shortest \st\ path, and take
the one with the smallest length among all these cases (there are only a
constant number of them).

It remains to solve the canal case, i.e., when the query points are
in canals. The algorithm is similar to that for the bay case; the only
difference is that we have to take care of two gates for each
canal. Specifically, suppose  is in a canal  and  is
in a canal . If , then there must be a shortest \st\ path
 that intersects a gate of  at a point  and intersects a gate of
 at a point  such that the subpath  is in ,
the subpath  is in , and the subpath 
is in . Hence, we can use a similar approach as for the bay case to
find a shortest \st\ path by considering all four gate pairs of  and
. If , while we can treat this case in the same way as for
the case of , we need to consider one more possible situation when
a shortest \st\ path may be contained entirely in , which is easy since 
is a simple polygon. If one of  or  is a bay, the case can be handled
in a similar fashion.

We summarize the whole algorithm in the proof of the following theorem.

\begin{theorem}\label{theo:20}
We can build a data structure of size  in  time that can
answer each two-point  shortest path query in  time (i.e., for
any two query points  and , the length of a shortest \st\ path can be found in 
time and an actual path can be reported in additional time linear to the number of edges of the output path).
\end{theorem}
\begin{proof}
Our preprocessing algorithm consists of the following major steps.

\begin{enumerate}
\item
Compute a triangulation of the free space  in
 time
\cite{ref:Bar-YehudaTr94,ref:ChazelleTr91}. Then produce
all bays, canals, corridor paths, , and  in
 time
\cite{ref:ChenA11ESA,ref:ChenCo12arXiv,ref:ChenL113STACS}.
\item
Compute the vertical and horizontal visibility decompositions of 
in  time \cite{ref:Bar-YehudaTr94,ref:ChazelleTr91}.
Build a point location data structure \cite{ref:EdelsbrunnerOp86,ref:KirkpatrickOp83}
for each of the two decompositions in  time, which is used for
performing any vertical or horizontal ray-shooting in 
time.
\item
Construct the graph  of size  in   time
by Lemma \ref{lem:50}.

\item
Perform the preprocessing of Lemma \ref{lem:70} in
 time and
 space.

\item
Perform the preprocessing of Lemma \ref{lem:80} in
 time and
 space.

\item
Compute a two-point Euclidean shortest path
query data structure  in each bay or canal . Since the
total number of vertices of all bays and canals is , this
step takes  time.

\item
Construct the graph  for the gate  of every bay or canal by Lemma
\ref{lem:120}. The total space for all such graphs is  and the total time for building all these graphs
is , as proved below.
First, each point of  can be on at most one
bay or canal gate. Thus, the sum of 's in Lemma \ref{lem:120} over all
gates  is , which is . Second, the total number
of obstacle vertices of all bays and canals  is , and each canal has two
gates. Hence, the sum of 's in Lemma \ref{lem:120} over all
bay and canals  is .


\item
Perform the preprocessing of Lemma \ref{lem:150} for the graphs  of
all gates , which can be done in totally  time and
 space.

\item
Merge the graph  and the graphs  for all gates
 into a single graph , which takes  time since there are  points in
.
Thus, the size of  is .

\item
For each node  of , compute a shortest path tree rooted at  in
. Maintain a shortest path length
table such that for any two nodes  and
 of , the length of a shortest path between  and
 in  can be obtained in  time. This step takes
 space and  time.

\item
Perform the preprocessing of Lemma \ref{lem:170} for each bay and canal,
which takes  space and  time in total.
\end{enumerate}

In summary, the total preprocessing space and time are
 and , respectively.

Consider any two query points  and .
Next, we discuss our query algorithm that computes the
length of a shortest \st\ path in  time and reports an
actual path in additional time linear to the number of edges of the output
path. We will not explicitly discuss how to report an
actual path (which is similar to that in Lemma \ref{lem:80} and is easy).

First of all, as discussed in Section \ref{sec:pre},
we determine whether there exists a trivial shortest
\st\ path by shooting horizontal and vertical rays from  and ,
which can be done in  time. In the following, we assume
that there is no trivial shortest \st\ path.
Depending on whether the query points are in the bays, canals, or the
ocean , there are several possible cases.

\begin{description}
\item[Both query points are in .]

In this case, we use the
algorithm for Lemma \ref{lem:80} to find a shortest \st\ path in
 time.

\item[Only one query point is in .]

Without loss of generality, we assume that  is in a bay or a canal  and
 is in . Further, we assume that  is a canal since the
case that  is a bay can be considered as a special case.

Let  and  be the two gates of . We define three points
, ,
and  for  in  with respect to the gate  in the same way as we
defined , , and  before. Similarly, we define , ,
and  for  in  with respect to the gate .  These points
can be computed in  time by Lemma \ref{lem:170}. Then, we
compute the lengths of the following ``candidate'' shortest \st\ paths and
return the one with the smallest length.

\begin{enumerate}
\item
For each point ,
the path which is a concatenation of a shortest path  from  to 
in  and a shortest path  from  to  in .

The path  can be found in  time by using the data structure
 on , and the path  can be found in
 time by Lemma \ref{lem:80}.

\item
For each point , the path which is a
concatenation of a shortest path  from  to 
in  and a particular path  from  to .

The path  can be found in  time by using the data structure
 on . The path  is determined as follows.
First, based on Lemma \ref{lem:160} (although  is a bay in
Lemma \ref{lem:160}, the result also holds for canals because the lemma
was proved with respect to a gate regardless of whether it is a gate of
a bay or a canal), we check whether there exists a
path from  to  consisting of only two line segments, by performing
horizontal and vertical ray-shootings. If yes, then such a path is
. Otherwise, by Lemmas \ref{lem:140} and \ref{lem:160}, we
find a shortest path from  to  along the merged graph 
by using the gateways of  and the gateways of , which can be obtained in 
time by Lemmas \ref{lem:150} and \ref{lem:70}, respectively.
Since both  and  have
 gateways, a shortest - path can be determined
in  time using the gateway graph as discussed at the end of
Section \ref{sec:newgraph}.
\end{enumerate}

\item[Neither query point is in .] Let  be the
bay or canal that contains  and  be the bay or canal that contains .

If  and  is a bay, then by Lemma \ref{lem:90}, we can find a shortest \st\ path
by using the data structure  in  time.

Suppose . Then we assume both  and  are canals since
the other cases are just special cases of this case. Let  and  be
the two gates of  and  and  be
the two gates of . Similarly as before, we define the points ,
, and  for  with respect to ,
and , , and  for  with respect to , for
. These points
can all be determined in  time by Lemma \ref{lem:170}. Then we
compute the lengths of the following ``candidate'' shortest \st\ paths and
return the one with the smallest length.

\begin{enumerate}
\item
For each pair of points  and  such that  and ,
the path which is a concatenation of a shortest path  from  to 
in , a shortest path from  to  in , and a shortest path  from  to  in .

The paths  and  can be found in
 time by using  and , respectively.
The path  can be obtained in
 time by Lemma \ref{lem:80}.

\item
For each point  and each point , the path
which is a concatenation of a shortest path from  to  in ,
a particular path  from  to , and a shortest
path from  to  in .

The paths  and  can be found in
 time by using  and , respectively.
Since  is in ,
the particular path  is defined similarly as
the path  in the second subcase of
the above case when only one query point  is in 
and thus can be obtained by the similar approach.

\item
For each point  and each point
, the path which is a concatenation
of a shortest path from  to  in , a particular path
 from  to , and a shortest path from  to
 in .

This subcase is symmetric to the subcase immediately above and can be handled similarly.

\item
For each point  and each point , the path
which is a concatenation of a shortest path from  to  in , a particular path  from  to , and a shortest path from  to  in .

The paths  and  can be found in
 time by using  and , respectively.
The particular path  is determined similarly as the path
 in the second subcase of the above case when only
one query point  is in , but based on Lemmas \ref{lem:180} and
\ref{lem:190} instead. Note that although  and  are bays in
these lemmas, the results also hold for canals (actually, they
are proved with respect to two gates regardless of whether they are gates of
bays or canals). Specifically, we determine  as follows.
Based on Lemma \ref{lem:190}, we first check whether there exists a
path from  to  consisting of only two line segments, by
horizontal and vertical ray-shootings. If yes, then such a path is
. Otherwise, by Lemmas \ref{lem:180} and \ref{lem:190}, we
find a shortest - path along the merged graph 
by using the gateways of  and the gateways of , which
can be computed in  time by Lemma \ref{lem:150}.
Since both  and  have
 gateways, a shortest - path can be obtained
in  time using the gateway graph as discussed in Section \ref{sec:newgraph}.
\end{enumerate}

\end{description}


Finally, if  and  is a canal, then the algorithm is similar as for
the above case with the difference that we must consider an additional
``candidate'' path that is a shortest \st\ path inside , which
can be found in  time by using the data structure .

Hence, in any case, we find a shortest \st\ path in  time.
The theorem thus follows.
\end{proof}

If we replace all enhanced graphs, e.g.,  and  for
every gate , by the corresponding graphs similar to  in \cite{ref:ChenSh00}
as discussed in Section \ref{sec:pre}, then we obtain the following results.

\begin{corollary}
We can build a data structure in  time and space,
such that each two-point shortest path query is answered in
 time; alternatively,
we can build a data structure in  time and
 space, such that each two-point shortest path query is
answered in  time.
\end{corollary}
\begin{proof}
If we replace all the enhanced graphs  and  for every gate  of the
bays and canals by the graphs similar to  in \cite{ref:ChenSh00}
as discussed in Section \ref{sec:pre}, then the size of the new merged graph,
denoted by , becomes  instead of
.
Hence, the data structure for Theorem \ref{theo:20}
needs  space and can be built in 
time by using the approach in \cite{ref:ChenSh00}.
However, using the new graph , each query for any two points in
 can be answered in  time because there are  gateways for each query point. Therefore, any general two-point
shortest path query can be answered in  time, by
using a similar query algorithm as in Theorem \ref{theo:20}. We omit the details.

In the result above,
we compute a shortest path tree rooted at each node in the merged graph .
Alternatively, we can compute a shortest path map in the free space  for
each node  of , such that given any query point
, the length of a shortest path from  to  can be found in
 time and an actual path can be reported in additional
time linear to the number of edges of the output path.
Each such shortest path map is of size  and can be computed in
 time
\cite{ref:ChenA11ESA,ref:ChenCo12arXiv,ref:ChenL113STACS} (after
the free space  is triangulated). Since the size
of  is , the overall preprocessing time
and space are  and , respectively. For querying, since
a query point may have
 gateways and for each gateway , we can determine the
shortest path from  to the other query point in  time,
the total query time is . We omit the details.
\end{proof}



\section{The Weighted Rectilinear Case}
\label{sec:weighted}

In this section, we extend our techniques in Section
\ref{sec:newgraph} to the weighted rectilinear case. In the
weighted rectilinear case, every polygonal obstacle  is
{\it rectilinear} and {\it weighted}, i.e., each edge of  is
either horizontal or vertical and  has a weight
 ( is possible). If a line segment  is in ,
then the {\em weighted length} of  is , where  is the  length of
. Any polygonal path  can be divided into a sequence of maximal
line segments such that each segment is contained in the same obstacle
or in the free space ; the {\em weighted length} of  is the
sum of the weighted lengths of all maximal line segments of .


Consider a vertex  of any rectilinear obstacle  such that the interior angle
of  at  is . We define the {\em
internal projections} of  on the boundary  of  as follows.
Suppose  and  are the two edges of
 incident to . We extend  into the interior of
 along the direction from  to  until we hit 
at the first point, which is an {\em internal projection} of ; similarly,
we define another interval projection of   by extending
. Internal projections are used to control shortest
paths that pass through the interior of obstacles.

The ``visibility'' in the weighted case is defined in a slightly
different way: Two points  and  are {\em visible} to each other
if  is entirely in either  or an obstacle.


Let  be the set of all obstacle vertices of , their internal
projections, and all type-1 Steiner points. Then .
We build a graph  on  similar to the one presented in
Section \ref{sec:newgraph}, with the following differences.
(1) The visibility here is based on the new definition above.
(2) Since a path can travel through
the interior of any obstacle, for each cut-line , an edge
in  connects every two consecutive Steiner points on
, whose weight is the weighted length of the line segment
connecting the two points.
(3) In addition to the vertical
cut-lines, there are also horizontal cut-lines, which are defined
similarly and have type-2 and type-3 Steiner points defined on them similarly
to those on the vertical cut-lines.
Thus,  has  nodes and edges.





\begin{lemma}\label{lem:200}
The graph of  can be built in 
time.
\end{lemma}
\begin{proof}
We obtain all internal projections of  by computing the
horizontal and vertical visibility decompositions of every
obstacle in . We find the four projection points on  (i.e., ,
and ) for all obstacle vertices  of  in  time by
computing the horizontal and vertical visibility decompositions of .
These can be all done in totally  time.

Then we compute the vertical and horizontal cut-line trees, which takes
 time since . Next, we compute
the Steiner points and the graph edges. Below, we only show how to compute those
related to the vertical cut-lines; those related to the horizontal
cut-lines can be computed in a similar way.
Let  denote the vertical cut-line tree.

As in Lemma \ref{lem:10}, we can compute the type-2 and type-3 Steiner
points on all cut-lines of  by traversing  in a top-down
manner. Since the internal projections and  for
each obstacle vertex  have been obtained, we can compute all
 such Steiner points in  time; the corresponding horizontal graph
edges connecting these Steiner points and the points of  can
also be computed.


It remains to compute the graph edges connecting every pair of consecutive Steiner points
on each cut-line of , which takes  time by a
plane sweeping algorithm, as follows. We first sort all Steiner points on each cut-line.
We then sweep a vertical line  from left to
right and use a balanced binary search tree  to maintain the
intervals between the obstacle edges of  intersecting . By standard
techniques, we augment  to also maintain the weighted length
information along  such that for any two points  and  on
, the weighted length of  can
be obtained in  time using . During the sweeping,
when  encounters a cut-line , for every two consecutive Steiner
points  and  on , we use  to determine in  time the weighted
length of the edge connecting  and .
Since there are  pairs of consecutive Steiner points on all cut-lines, it takes
 time to compute all these graph edges.

Hence, we can build the graph  in  time.
\end{proof}

Consider any two query points  and . For simplicity of discussion, we assume that both  and  are
in  (the general case can also be handled similarly). With a preprocessing of 
time and space, a shortest \st\ path that does not
contain any vertex of  can be found in  time \cite{ref:ChenSh00}. Thus in the
following, we focus on finding a shortest \st\ path containing at lease one
vertex of .

Let  be the set of  and
the four projections of  on , i.e., ;
similarly, let . It was shown in
\cite{ref:ChenSh00} that it suffices to find a shortest path
from  to  containing a vertex of  for every  and every .
With a little abuse of notation,
we let  be any point in  and  be any point in . Our
goal is to find a shortest \st\ path that contains at lease one vertex of .
Unless otherwise indicated, any shortest \st\ path
mentioned below refers to a shortest \st\ path that contains a vertex of .

In \cite{ref:ChenSh00}, similar to the discussions in Section \ref{sec:pre},
 gateways for  and  gateways for  were defined,
such that any shortest \st\ path must contain a gateway of  and a
gateway of . Hence by using the gateway graph, a shortest \st\ path can be
found in  time.


Based on our enhanced graph , as in Section \ref{sec:newgraph},
we define a new gateway set  of size  for
 and a new gateway set  of size  for .
The gateway set  contains   Steiner points on the
vertical cut-lines defined in the same way as those in  in Section \ref{sec:newgraph}; similarly,  also contains   Steiner points on the
horizontal cut-lines.  The gateway set  is defined similarly.
Using a similar proof as for Lemma \ref{lem:20}, we can show that
there exists a shortest \st\ path containing a gateway of  in  and a
gateway of  in . Next, we show how to compute the two gateway sets and
(the weights of) their gateway edges. Below, we discuss only the case for .

The fractional cascading approach \cite{ref:ChazelleFr86} used in
Section \ref{sec:newgraph} can still compute the gateway
set  in  time, but it cannot compute the weights of the
gateway edges in  time for the following reasons.
Consider a gateway , say on a vertical cut-line . Then
there is a gateway edge  that consists of two line segments
 and  (recall that  is the horizontal projection of  on ). Hence, the weighted length
of the edge  is the sum of the weighted lengths of these two line segments.
It was shown in \cite{ref:ChenSh00} that  must be in the free
space (since  is in ); thus, the weighted length of
 is easy to compute. However, the vertical segment
 may intersect multiple
obstacles \cite{ref:ChenSh00}. We give an algorithm to compute in
 time the gateways and the weights of the
gateway edges for  in the next lemma.





\begin{lemma}\label{lem:210}
With a preprocessing of  time and  space,
the gateways of  for  and their weighted edges
can be computed in  time.
\end{lemma}
\begin{proof}
We discuss only how to
compute the gateways of  that are on the vertical cut-lines
since those on the horizontal cut-lines can be computed similarly.
Further, for simplicity of discussion, we only compute the gateways of
 above  (i.e., above the horizontal line through ) since those
below  can be computed similarly.
Below, with a little abuse of notation, we let  refer to the
set of its gateways on the vertical cut-lines and above .



We follow the terminology in Section \ref{sec:newgraph}.
Recall that  has  projection cut-lines in the vertical cut-line tree .
Let  be the set of all projection cut-lines of  in .
For each projection cut-line , let  be the Steiner
point on  immediately above the horizontal projection  of  on .
Let . By their definitions,
 is a subset of  (since each gateway of 
is on a {\it relevant} projection cut-line of  in ).
Hence, to compute  and their gateway
edges, it suffices to compute the set  and the weighted lengths of
 for all projection cut-lines .
Since  is in
 for any projection cut-line  of  \cite{ref:ChenSh00} (because ), it suffices to compute the weighted length of
. Below, for any line segment , let 
denote the weighted length of . Let .

We use fractional cascading \cite{ref:ChazelleFr86}
to obtain  in  time,
with a similar approach as for Lemma \ref{lem:30}.
To compute the weighted lengths of the segments in , we need to build another fractional
cascading data structure in the preprocessing.

For every cut-line  of , we compute the intersections of  with all
obstacle edges of ; let  be the set of such intersections.
Clearly, . We sort these intersections and the Steiner points on  to obtain a
sorted list . For all  cut-lines of ,
this takes totally  time,
because the total number of Steiner points is  (which is ) and the total number of
intersections between the cut-lines and the obstacle edges is .

Consider the sorted set  for any cut-line  of . For
any two consecutive points  and  in , the entire segment
 is either in  or in the same
obstacle. From top to bottom in , for each point ,
we compute the weighted length  and associate it with
, where  is the highest point in .  Further, for each point ,
we maintain a weight , defined as follows: Suppose  is the point in
 immediately below ; if the interior of  is
contained in an obstacle, then  is the weight of that obstacle, and
 otherwise.
Since  is sorted, computing such information in  takes  time.
With such information, for any query point
 on , suppose  is the point in  that is
immediately above ; then we have
.
Hence, once we know the point  for ,
  can be computed in  time; further,
for any point  in  above , we have , which
is computed in  time since the value  is already stored at .

In the preprocessing, we build another fractional cascading data structure on 
and the sorted lists  for all cut-lines  of , which takes  space and  time.

For any query point , we first use a similar approach as for Lemma \ref{lem:30} to compute
the set  in  time. For each projection cut-line , let 
be the point in  immediately above . Note that  is between 
and . We can use the above fractional cascading data structure to compute the points
 for all  in  time (since the cut-lines of  are at the nodes
of a path from the root to a leaf in ). Then for each , to compute
, as discussed above, we have  , where  is the highest
point in  and .
Since both  and  have been computed,  is obtained
in  time. Hence, the weighted lengths of all segments in  are computed in  time.

The lemma thus follows.
\end{proof}

The following theorem summarizes our algorithm for the weighted rectilinear case.

\begin{theorem}\label{theo:30}
For the weighted rectilinear case, we can build a data structure of
size  in  time that can answer each query in  time (i.e., for
any two query points  and , the weighted length of a shortest \st\ path can be found in 
time and an actual path can be reported in additional time linear to the number of edges of the output path).
\end{theorem}
\begin{proof}
In the preprocessing, we compute the graph  by Lemma \ref{lem:200}. For each node
 of , we compute a shortest path tree rooted at  in . We maintain
a shortest path length table such that for any two nodes  and  in , the
(weighted) length of the shortest path from  to  in  is obtained in  time.
Computing all shortest path trees in  takes
 space and  time. We also
perform the preprocessing for Lemma \ref{lem:210}. Hence, the preprocessing takes
 space and  time in total.

Consider any two query points  and . First, we use the approach in \cite{ref:ChenSh00}
to find a shortest \st\ path that does not contain any obstacle vertex of  (if any),
after a preprocessing of  time and space. Below, we focus on finding a shortest \st\
path containing an obstacle vertex of , which must contain a gateway of  in
 and a gateway of  in . By Lemma \ref{lem:210}, we
can compute both  and  in  time. Then, a
shortest \st\ path can be found by building a gateway graph (as discussed in
Section \ref{sec:newgraph}) in  time since the sizes of both 
and  are . As in \cite{ref:ChenSh00}, after the shortest
\st\ path length is computed, an actual shortest \st\ path can be reported by using the shortest
path trees of the nodes in , in time linear to the number of edges of the output path.

The theorem thus follows.
\end{proof}




\bibliographystyle{plain}

\begin{thebibliography}{10}

\bibitem{ref:BaeQu12}
S.W. Bae and Y.~Okamato.
\newblock Querying two boundary points for shortest paths in a polygonal
  domain.
\newblock {\em Computational Geometry: Theory and Applications}, 45:284--293,
  2012.

\bibitem{ref:Bar-YehudaTr94}
R.~Bar-Yehuda and B.~Chazelle.
\newblock Triangulating disjoint {Jordan} chains.
\newblock {\em International Journal of Computational Geometry and
  Applications}, 4(4):475--481, 1994.

\bibitem{ref:ChazelleTr91}
B.~Chazelle.
\newblock Triangulating a simple polygon in linear time.
\newblock {\em Discrete and Computational Geometry}, 6:485--524, 1991.

\bibitem{ref:ChazelleFr86}
B.~Chazelle and L.~Guibas.
\newblock Fractional cascading: {I. A} data structuring technique.
\newblock {\em Algorithmica}, 1(1):133--162, 1986.

\bibitem{ref:ChenCo13}
D.Z. Chen, J.~Hershberger, and H.~Wang.
\newblock Computing shortest paths amid convex pseudodisks.
\newblock {\em SIAM Journal on Computing}, 42(3):1158--1184, 2013.

\bibitem{ref:ChenSh00}
D.Z. Chen, K.S. Klenk, and H.-Y.T. Tu.
\newblock Shortest path queries among weighted obstacles in the rectilinear
  plane.
\newblock {\em SIAM Journal on Computing}, 29(4):1223--1246, 2000.

\bibitem{ref:ChenA11ESA}
D.Z. Chen and H.~Wang.
\newblock A nearly optimal algorithm for finding {} shortest paths among
  polygonal obstacles in the plane.
\newblock In {\em Proc. of the 19th European Symposium on Algorithms (ESA)},
  pages 481--492, 2011.

\bibitem{ref:ChenCo12arXiv}
D.Z. Chen and H.~Wang.
\newblock Computing {} shortest paths among polygonal obstacles in the
  plane.
\newblock arXiv:1202.5715v1, 2012.

\bibitem{ref:ChenCo12ICALP}
D.Z. Chen and H.~Wang.
\newblock Computing the visibility polygon of an island in a polygonal domain.
\newblock In {\em Proc. of the 39th International Colloquium on Automata,
  Languages and Programming (ICALP)}, pages 218--229, 2012.

\bibitem{ref:ChenCo13SoCG}
D.Z. Chen and H.~Wang.
\newblock Computing shortest paths among curved obstacles in the plane.
\newblock In {\em Proc. of the 29th ACM Symposium on Computational Geometry
  (SoCG)}, pages 369--378, 2013.

\bibitem{ref:ChenL113STACS}
D.Z. Chen and H.~Wang.
\newblock {} shortest path queries among polygonal obstacles in the plane.
\newblock In {\em Proc. of 30th Symposium on Theoretical Aspects of Computer
  Science (STACS)}, pages 293--304, 2013.

\bibitem{ref:ChenVi13WADS}
D.Z. Chen and H.~Wang.
\newblock Visibility and ray shooting queries in polygonal domains.
\newblock In {\em Proc. of the 13rd International Symposium on Algorithms and
  Data Structures (WADS)}, pages 369--378, 2013.

\bibitem{ref:ChewPl85}
L.P. Chew.
\newblock Planning the shortest path for a disc in {} time.
\newblock In {\em Proc. of the 1st Annual ACM Symposium on Computational
  Geometry (SoCG)}, pages 214--220, 1985.

\bibitem{ref:ChiangTw99}
Y.-J. Chiang and J.S.B. Mitchell.
\newblock Two-point {Euclidean} shortest path queries in the plane.
\newblock In {\em Proc. of the Annual ACM-SIAM Symposium on Discrete Algorithms
  (SODA)}, pages 215--224, 1999.

\bibitem{ref:ClarksonRe87}
K.~Clarkson, S.~Kapoor, and P.~Vaidya.
\newblock Rectilinear shortest paths through polygonal obstacles in {} time.
\newblock In {\em Proc. of the 3rd Annual Symposium on Computational Geometry
  (SoCG)}, pages 251--257, 1987.

\bibitem{ref:ClarksonRe88}
K.~Clarkson, S.~Kapoor, and P.~Vaidya.
\newblock Rectilinear shortest paths through polygonal obstacles in {} time.
\newblock Manuscript, 1988.

\bibitem{ref:EdelsbrunnerOp86}
H.~Edelsbrunner, L.~Guibas, and J.~Stolfi.
\newblock Optimal point location in a monotone subdivision.
\newblock {\em SIAM Journal on Computing}, 15(2):317--340, 1986.

\bibitem{ref:ElGindyOr94}
H.A. ElGindy and P.~Mitra.
\newblock Orthogonal shortest route queries among axis parallel rectangular
  obstacles.
\newblock {\em International Journal of Computational Geometry and
  Application}, 4:3--24, 1994.

\bibitem{ref:GuibasOp89}
L.J. Guibas and J.~Hershberger.
\newblock Optimal shortest path queries in a simple polygon.
\newblock {\em Journal of Computer and System Sciences}, 39(2):126--152, 1989.

\bibitem{ref:GuibasLi87}
L.J. Guibas, J.~Hershberger, D.~Leven, M.~Sharir, and R.E. Tarjan.
\newblock Linear-time algorithms for visibility and shortest path problems
  inside triangulated simple polygons.
\newblock {\em Algorithmica}, 2(1-4):209--233, 1987.

\bibitem{ref:HershbergerA91}
J.~Hershberger.
\newblock A new data structure for shortest path queries in a simple polygon.
\newblock {\em Information Processing Letters}, 38(5):231--235, 1991.

\bibitem{ref:HershbergerAn88}
J.~Hershberger and L.~Guibas.
\newblock An {} shortest path algorithm for a non-rotating convex body.
\newblock {\em Journal of Algorithms}, 9(1):18--46, 1988.

\bibitem{ref:HershbergerCo94}
J.~Hershberger and J.~Snoeyink.
\newblock Computing minimum length paths of a given homotopy class.
\newblock {\em Computational Geometry: Theory and Applications}, 4(2):63--97,
  1994.

\bibitem{ref:HershbergerAn99}
J.~Hershberger and S.~Suri.
\newblock An optimal algorithm for {Euclidean} shortest paths in the plane.
\newblock {\em SIAM Journal on Computing}, 28(6):2215--2256, 1999.

\bibitem{ref:HershbergerA13}
J.~Hershberger, S.~Suri, and H.~Y{\i}ld{\i}z.
\newblock A near-optimal algorithm for shortest paths among curved obstacles in
  the plane.
\newblock In {\em Proc. of the 29th Annual Symposium on Computational Geometry
  (SoCG)}, pages 359--368, 2013.

\bibitem{ref:InkuluPl09}
R.~Inkulu and S.~Kapoor.
\newblock Planar rectilinear shortest path computation using corridors.
\newblock {\em Computational Geometry: Theory and Applications},
  42(9):873--884, 2009.

\bibitem{ref:InkuluA10}
R.~Inkulu, S.~Kapoor, and S.N. Maheshwari.
\newblock A near optimal algorithm for finding {Euclidean} shortest path in
  polygonal domain.
\newblock In {\em arXiv:1011.6481v1}, 2010.

\bibitem{ref:JoeCo87}
B.~Joe and R.B. Simpson.
\newblock Corrections to {Lee's} visibility polygon algorithm.
\newblock {\em BIT}, 27:458--473, 1987.

\bibitem{ref:KapoorEf88}
S.~Kapoor and S.N. Maheshwari.
\newblock Efficient algorithms for {Euclidean} shortest path and visibility
  problems with polygonal obstacles.
\newblock In {\em Proc. of 4th Annual ACM Symposium on Computational Geometry
  (SoCG)}, pages 172--182, 1988.

\bibitem{ref:KapoorAn97}
S.~Kapoor, S.N. Maheshwari, and J.S.B. Mitchell.
\newblock An efficient algorithm for {Euclidean} shortest paths among polygonal
  obstacles in the plane.
\newblock {\em Discrete and Computational Geometry}, 18(4):377--383, 1997.

\bibitem{ref:KirkpatrickOp83}
D.~Kirkpatrick.
\newblock Optimal search in planar subdivisions.
\newblock {\em SIAM Journal on Computing}, 12(1):28--35, 1983.

\bibitem{ref:LeeVi83}
D.T. Lee.
\newblock Visibility of a simple polygon.
\newblock {\em Computer Vision, Graphics, and Image Processing}, 22(2):1983,
  207--221.

\bibitem{ref:LeeEu84}
D.T. Lee and F.P. Preparata.
\newblock Euclidean shortest paths in the presence of rectilinear barriers.
\newblock {\em Networks}, 14(3):393--410, 1984.

\bibitem{ref:LeeSh91}
D.T. Lee, C.D. Yang, and T.H. Chen.
\newblock Shortest rectilinear paths among weighted obstacles.
\newblock {\em International Journal of Computational Geometry and
  Applications}, 1(2):109--124, 1991.

\bibitem{ref:MitchellAn89}
J.S.B. Mitchell.
\newblock An optimal algorithm for shortest rectilinear paths among obstacles.
\newblock Abstracts of the {\em 1st Canadian Conference on Computational
  Geometry (CCCG)}, 1989.

\bibitem{ref:MitchellA91}
J.S.B. Mitchell.
\newblock A new algorithm for shortest paths among obstacles in the plane.
\newblock {\em Annals of Mathematics and Artificial Intelligence},
  3(1):83--105, 1991.

\bibitem{ref:MitchellL192}
J.S.B. Mitchell.
\newblock {} shortest paths among polygonal obstacles in the plane.
\newblock {\em Algorithmica}, 8(1):55--88, 1992.

\bibitem{ref:MitchellSh96}
J.S.B. Mitchell.
\newblock Shortest paths among obstacles in the plane.
\newblock {\em International Journal of Computational Geometry and
  Applications}, 6(3):309--332, 1996.

\bibitem{ref:MitchellGe00}
J.S.B. Mitchell.
\newblock {\em {\em Geometric shortest paths and network optimization, in}
  Handbook of Computational Geometry, {\em J.-R Sack and J. Urrutia (eds.)}},
  pages 633--702.
\newblock Elsevier, Amsterdam, the Netherlands, 2000.

\bibitem{ref:MitchellTh91}
J.S.B. Mitchell and C.H. Papadimitriou.
\newblock The weighted region problem: Finding shortest paths through a
  weighted planar subdivision.
\newblock {\em Journal of the ACM}, 38:18--73, 1991.

\end{thebibliography}

\end{document}
