\documentclass{article}



\usepackage{iclr2020_conference,times}

\usepackage[T1]{fontenc}    \usepackage{booktabs}       \usepackage{multirow}
\usepackage{dsfont}
\usepackage{amsfonts,amsmath,amssymb, stmaryrd}
\usepackage{bm}
\usepackage{tikz}
\usepackage{amsthm}
\usepackage{nicefrac}       \usepackage{microtype}      

\usepackage[ruled]{algorithm2e}
\usepackage{algpseudocode}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}

\usepackage{subcaption}

\newcommand{\theHalgorithm}{\arabic{algorithm}}
\usepackage{hyperref}
\usepackage{url}
\usepackage{xfunctions}

\usepackage{siunitx}
\sisetup{output-exponent-marker=\ensuremath{\mathrm{e}}}


\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{theorem}{Theorem}
\newtheorem{remark}{Remark}

\newcommand\eqdef{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\tiny\sffamily def}}}{=}}}

\newcommand{\twonorm}[1]{\norm{#1}_2}
\newcommand{\atomicnorm}[1]{\norm{#1}_{\mathcal{A}}}
\newcommand{\fronorm}[1]{\norm{#1}_{F}}
\newcommand{\infnorm}[1]{\norm{#1}_{\infty}}
\newcommand{\tinorm}[1]{\norm{#1}_{2, \infty}}
\newcommand{\maxnorm}[1]{\norm{#1}_{max}}
\newcommand{\trnorm}[1]{\norm{#1}_{\Sigma}}
\newcommand{\tensors}{\mathcal{T}}
\newcommand{\fu}{\tilde{\mathcal{V}}_{\mathcal{U}}(A^{m})}
\newcommand{\funorm}[1]{\norm{#1}_{\fu}}

\newcommand{\canmn}{{\tt CAN}}
\newcommand{\kranmn}{{\tt KRAN}}

\newcommand{\tprod}{\otimes}
\newcommand{\mlprod}[1]{\times_{#1}}

\newcommand{\vect}[1]{{\bm #1}}

\newcommand{\mat}[1]{{#1}}

\newcommand{\tensor}[1]{{\bm #1}}
\newcommand{\tensT}{{\bm T}}
\newcommand{\tensX}{{\bm X}}
\newcommand{\tpm}{\mathcal{T}_{\pm}}

\newcommand{\column}[2]{#1_{\cdot, #2}}
\newcommand{\row}[2]{#1_{#2, \cdot}}
\newcommand{\model}[1]{{\tt #1}}

\DeclareMathOperator*{\conv}{conv}

\newcommand{\comments}[1]{{#1}}
\newcommand{\tim}[1]{\comments{\color{blue}[TL:~#1]}}
\newcommand{\nico}[1]{\comments{\color{blue}[NU:~#1]}}
\newcommand{\gui}[1]{\comments{\color{blue} [GO:~#1]}}
\newcommand{\joan}[1]{\comments{\color{blue} [JB:~#1]}}
\newcommand{\wrong}[1]{\comments{\color{red} [WRONG:~#1]}}




\newcommand{\zoloss}{\ell_\infty}
\newcommand{\gammaloss}{\ell_\gamma}

\newcommand{\ball}[2]{\mathcal{B}_{#1, #2}}
\newcommand{\atoms}{\mathcal{A}}

\newcommand{\identity}{\mathds{1}}
\newcommand{\indicator}{\mathds{1}}

\newcommand{\entities}{\mathcal{E}}
\newcommand{\relations}{\mathcal{R}}

\newtheorem*{proposition*}{Proposition}

\newcommand{\embs}{U}
\newcommand{\embsV}{V}
\newcommand{\embsW}{W}

\newcommand{\embvec}{u}
\newcommand{\embvecu}{u}
\newcommand{\embvecv}{v}
\newcommand{\embvecw}{w}

\newcommand{\truex}{X}
\newcommand{\empx}{\hat{X}}

\newcommand{\ii}{j}
\renewcommand{\ij}{k}
\newcommand{\ik}{l}

\newcommand{\im}{i}

\newcommand{\nbigdims}{R}



\newcommand{\missingcomp}{link prediction\xspace}
\newcommand{\zerocomp}{ratings prediction\xspace}
\newcommand{\nation}{{NATION}\xspace}
\newcommand{\umls}{{UMLS}\xspace}
\newcommand{\kinship}{{KINSHIP}\xspace}

\newcommand{\CP}{{CP}\xspace}
\newcommand{\RESCAL}{{RESCAL}\xspace}
\newcommand{\complex}{{ComplEx}\xspace}
\newcommand{\distmult}{{DistMult}\xspace}
\newcommand{\conve}{{ConvE}\xspace}
\newcommand{\transe}{{TransE}\xspace}

\newcommand{\Ldeux}{$L_2$\xspace}
\newcommand{\Ltrois}{$L_3$\xspace}
\newcommand{\ProxMax}{{\tt $\infty$-nuclear}\xspace}
\newcommand{\auc}{{AUC}\xspace}
\newcommand{\mse}{{MSE}\xspace}
\newcommand{\fb}{{FB15K}\xspace}
\newcommand{\fbd}{{FB15K-237}\xspace}
\newcommand{\wn}{{WN18}\xspace}
\newcommand{\wnrr}{{WN18RR}\xspace}
\newcommand{\yago}{{YAGO3-10}\xspace}
\newcommand{\wikidata}{{Wikidata}\xspace}
\newcommand{\svo}{{SVO}\xspace}
\newcommand{\nuctrois}{nuclear $3$-norm\xspace}
\newcommand{\nucinf}{nuclear $\infty$-norm\xspace}
\newcommand{\sgd}{{SGD}\xspace}
\newcommand{\adagrad}{{ADAGRAD}\xspace}
\DeclareMathOperator{\sign}{{\text{sign}}}


\newcommand{\dotp}[2]{\langle #1, #2 \rangle}
\def\w{\omega}
\def\RR{\mathbb{R}}
\def\CC{\mathbb{C}}
\def\diag{\text{diag}}
\def\Diag{\text{Diag}}
\def\gt{{g^{(t)}}}
\def\Gt{{G^{(t)}}}
\def\gtt{{\tilde{g}^{(t)}}}
\def\Gtt{{\tilde{G}^{(t)}}}
\def\ttheta{\tilde{\theta}}




\newcommand{\p}[1]{P_{#1}}
\newcommand{\tens}[1]{\tensor{#1}}
\newcommand{\tensi}[2]{\tensor{#1}_{#2}}
\newcommand{\tensc}[2]{\tensor{#1}_{:,#2,:}}
\newcommand{\mati}[2]{\mat{#1}_{#2}}
\newcommand{\matr}[2]{{\mat{#1}_{#2,:}}}
\newcommand{\matk}[2]{\mat{#1}^{(#2)}}
\newcommand{\nrows}{n}
\newcommand{\ncols}{m}
\newcommand{\nfronts}{p}
\newcommand{\rkv}{r}
\newcommand{\rk}{R}
\newcommand{\dv}{d}

\newcommand{\adaimp}{{Ada$^{imp}$}\xspace}
\newcommand{\adarow}{{Ada$^{row}$}\xspace}
\newcommand{\adaimpr}{{Ada$^{approx}$}\xspace}
\newcommand{\pcpf}{{PCP}\xspace}
\newcommand{\pcpl}{{CPT}\xspace}
\newcommand{\PCplx}{{PComplEx}\xspace}
\newcommand{\proj}[1]{\Pi^{(#1)}}

\newcommand{\nents}{N}
\newcommand{\nrels}{L}
\newcommand{\ndims}{d}


\newcommand{\noise}{\xi}
\newcommand{\obs}{y}
\newcommand{\unkn}{X}
\newcommand{\pred}{\hat{\unkn}}
\newcommand{\tgt}{Y}
\newcommand{\vau}{U}
\newcommand{\vav}{V}
\newcommand{\vae}{U}
\newcommand{\var}{R}
\newcommand{\indices}{{\cal S}}
\newcommand{\indecesz}{{|\indices|}}
\newcommand{\regul}{\Omega\xfunction}

\newcommand{\loss}{\ell}

\newcommand{\tnorm}[1]{\norm{#1}_{*}}
\newcommand{\fnorm}[1]{\norm{#1}_{\rm F}}
\newcommand{\npnorm}[1]{\norm{#1}_{*,p}}

\newcommand{\conjugate}[1]{\overline{#1}}
\newcommand{\realpart}[1]{Re(#1)}
\newcommand{\Co}{\mathbb{C}}

\newcommand{\facv}[2]{u^{(#1)}_{#2}}
\newcommand{\weightv}[1]{w_{\indices}^{(#1)}}
\newcommand{\weightvi}[1]{w_{\indices, i}^{(#1)}}


\newcommand{\nv}[1]{{n_{#1}}}

\newcommand{\allfaccp}{\mathcal{U}_R(\tens{\unkn})}
\newcommand{\nallfaccp}[1]{\overline{\mathcal{U}}^{#1}_R(\tens{\unkn})}
\newcommand{\allfacc}{\mathcal{U}_R^{\mathbb{C}}(\tens{\unkn})}


\newcommand{\opnorm}[1]{{\left\vert\kern-0.25ex\left\vert\kern-0.25ex\left\vert #1 
    \right\vert\kern-0.25ex\right\vert\kern-0.25ex\right\vert}}
    
    \DeclareMathOperator{\Tr}{Tr}

\newcommand{\brck}[1]{[\![#1]\!]}



\newtheorem{question}{Question}

\newcommand\restr[2]{{\left.\kern-\nulldelimiterspace #1 \vphantom{\big|} \right|_{#2} }}
 
\setlength{\heavyrulewidth}{1.5pt}
\setlength{\abovetopsep}{4pt}





\title{Tensor Decompositions for\\ Temporal \mbox{Knowledge} Base Completion}

\author{
Timothee Lacroix\textsuperscript{1,2}, Guillaume Obozinski\textsuperscript{3}, Nicolas Usunier\textsuperscript{1} \\
\textsuperscript{1} Facebook AI Research~~\textsuperscript{2} ENPC\thanks{Université Paris-Est, Equipe Imagine, LIGM (UMR8049) Ecole des Ponts ParisTech, Marne-la-Vallée}~~
\textsuperscript{3} Swiss Data Science Center, EPFL \& ETH Zürich\\
\texttt{timothee.lax@gmail.com}\quad\texttt{guillaume.obozinski@epfl.ch}\\
\texttt{usunier@fb.com}\\
}

\iclrfinalcopy

\begin{document}

\maketitle

\begin{abstract}




    Most algorithms for representation learning and link prediction in relational data have been designed for static data. However, the data they are applied to usually evolves with time, such as friend graphs in social networks or user interactions with items in recommender systems. This is also the case for knowledge bases, which contain facts such as (US, has president, B. Obama, [2009-2017]) that are valid only at certain points in time. For the problem of link prediction under temporal constraints, i.e., answering queries such as (US, has president, ?, 2012), we propose a solution inspired by the canonical decomposition of tensors of order $4$.  
    We introduce new regularization schemes and present an extension of ComplEx \citep{trouillon_complex_2016} that achieves state-of-the-art performance. Additionally, we propose a new dataset for knowledge base completion constructed from Wikidata, larger than previous benchmarks by an order of magnitude, as a new reference for evaluating temporal and non-temporal link prediction methods. 
\end{abstract}





\section{Introduction}
Link prediction in relational data has been the subject of interest, given the widespread availability of such data and the breadth of its use in bioinformatics \citep{Zitnik2018}, recommender systems \citep{koren_matrix_2009} or Knowledge Base completion \citep{nickel_review_2016}. Relational data is often temporal, for example, the action of buying an item or watching a movie is associated to a timestamp. Some medicines might not have the same adverse side effects depending on the subject's age. The task of \emph{temporal} link prediction is to find missing links in graphs at precise points in time.


In this work, we study temporal link prediction through the lens of temporal knowledge base completion, which provides varied benchmarks both in terms of the underlying data they represent, but also in terms of scale. A knowledge base is a set of facts (subject, predicate, object) about the world that are known to be true. Link prediction in a knowledge base amounts to answer incomplete queries of the form (subject, predicate, ?) by providing an accurate ranking of potential objects. In temporal knowledge bases, these facts have some temporal metadata attached. For example, facts might only hold for a certain time interval, in which case they will be annotated as such. Other facts might be event that happened at a certain point in time. Temporal link prediction amounts to answering queries of the form (subject, predicate, ?, timestamp). For example, we expect the ranking of queries (USA, president, ?, timestamp) to vary with the timestamps.





As tensor factorization methods have proved successful for Knowledge Base Completion \citep{nickel_review_2016, trouillon_complex_2016, lacroix2018canonical}, we express our Temporal Knowledge Base Completion problem as an order $4$ tensor completion problem. That is, timestamps are discretized and used to index a $4$-th mode in the binary tensor holding (subject, predicate, object, timestamps) facts.

First, we introduce a ComplEx \citep{trouillon_complex_2016} decomposition of this order $4$ tensor, and link it with previous work on temporal Knowledge Base completion. This decomposition yields embeddings for each timestamps. A natural prior is for these timestamps representation to evolve slowly over time. We are able to introduce this prior as a regularizer for which the optimum is a variation on the nuclear $p$-norm. In order to deal with heterogeneous temporal knowledge bases where a significant amount of relations might be non-temporal, we add a non-temporal component to our decomposition.

Experiments on available benchmarks show that our method outperforms the state of the art for similar number of parameters. We run additional experiments for larger, regularized models and obtain improvements of up to $0.07$ absolute Mean Reciprocal Rank (MRR).  

Finally, we propose a dataset of $400k$ entities, based on Wikidata, with $7M$ train triples, of which $10\%$ contain temporal validity information. This dataset is larger than usual benchmarks in the Knowledge Base completion community and could help bridge the gap between the method designed and the envisaged web-scale applications.





\section{Related Work}
Matrices and tensors are upper case letters. The $i$-th row of $U$ is denoted by $u_i$ while it's $j-th$ column is denoted by $U_{:, j}$. The tensor product of two vectors is written $\otimes$ and the hadamard (elementwise) product $\odot$.

\paragraph{Static link prediction methods}
Standard tensor decomposition methods have lead to good results \citep{yang_embedding_2014, trouillon_complex_2016, lacroix2018canonical, balavzevic2019tucker} in Knowledge Base completion. The Canonical Polyadic (CP) Decomposition \citep{hitchcock_expression_1927} is the tensor equivalent to the low-rank decomposition of a matrix. A tensor $X$ of canonical rank $R$ can be written as:
\begin{equation}
    X = \sum_{r=1}^R U_{:,r} \otimes V_{:,r} \otimes W_{:,r} = \brck{U,V,W} ~~\iff ~~\forall (i,j,k), ~ X_{i,j,k} = \sum_{r=1}^R u_{i,r}v_{j,r}w_{k,r} = \langle u_i, v_j, w_k \rangle
    \label{eq:CP}
\end{equation}
Setting $U=W$ leads to the Distmult \citep{yang_embedding_2014} model, which has been successful, despite only being able to represent symmetric score functions. In order to keep the parameter sharing scheme but go beyond symmetric relations, \citet{trouillon_complex_2016} use complex parameters and set $W$ to the complex conjugate of $U$, $\overline{U}$. Regularizing this algorithm with the variational form of the tensor nuclear norm as well as a slight transformation to the learning objective (also proposed in \citet{kazemi2018simple}) leads to state of the art results in \citet{lacroix2018canonical}. 



Other methods are not directly inspired from classical tensor decompositions. For example, TransE \citep{bordes_translating_2013} models the score as a distance of the translated subject to an object representation. This method has lead to many variations \citep{ji2015knowledge, nguyen2016stranse, wang2014knowledge}, but is limited in the relation systems it can model \citep{kazemi2018simple} and does not lead to state of the art performances on current benchmarks. Finally \citet{schlichtkrull2018modeling} propose to generate the entity embeddings of a CP-like tensor decomposition by running a forward pass of a Graph Neural Network over the training Knowledge Base. The experiments included in this work did not lead to better link prediction performances than the same decomposition (Distmult) directly optimized \citep{kadlec_knowledge_2017}.

\paragraph{Temporal link prediction methods}
\citet{sarkar2006dynamic} describes a bayesian model and learning method for representing temporal relations. The temporal smoothness prior used in this work is similar to the gradient penalty we describe in Section~\ref{sec:grad_penalty}. However, learning one embedding matrix per timestamp is not applicable to the scales considered in this work. \citet{bader2007temporal} uses a tensor decomposition called ASALSAN to express temporal relations. This decomposition is related to RESCAL \citep{nickel_three-way_2011} which underperforms on recent benchmarks due to overfitting \citep{nickel_holographic_2015}.

For temporal knowledge base completion, \citet{goel2019diachronic} learns entity embeddings that change over time, by masking a fraction of the embedding weights with an activation function of learned frequencies. Based on the Tucker decomposition, ConT \citep{ma2018embedding} learns one new core tensor for each timestamp. Finally, viewing the time dimension as a sequence to be predicted, \citet{garcia2018learning} use recurrent neural nets to transform the embeddings of standard models such as TransE or Distmult to accomodate the temporal data. 

This work follows \citet{lacroix2018canonical} by studying and extending a regularized CP decomposition of the training set seen as an order 4 tensor. We propose and study several regularizer suited to our decompositions.

\section{Model}
\begin{table}[t]
\centering
\begin{tabular}{lc}
\toprule
DE-SimplE & $2r\left((3\gamma + (1-\gamma))|E|+ |P|\right)$ \\
TComplEx & $2r(|E|+|T|+2|P|)$ \\
TNTComplEx & $2r(|E|+|T|+4|P|)$ \\
\bottomrule
\end{tabular}
\caption{Number of parameters for each models considered}
\label{tab:n_params}
\end{table}
In this section, we are given facts (subject, predicate, object) annotated with timestamps, we discretize the timestamp range (eg. by reducing timestamps to years) in order to obtain a training set of $4$-tuple (subject, predicate, object, time) indexing an order $4$ tensor. We will show in Section~\ref{sec:exp} how we reduce each datasets to this setting. Following \citet{lacroix2018canonical}, we minimize, for each of the train tuples $(i,j,k,l)$, the instantaneous multiclass loss : 
\begin{equation}
    \ell(\empx;(i,j,k,l)) = - \empx_{i,j,k,l} + \log\left(\sum_{k'}\exp\left(\empx_{i,j,k',l}\right)\right).
    \label{eq:inst_loss}
\end{equation}
Note that this loss is only suited to queries of the type (subject, predicate, ?, time), which is the queries that were considered in related work. We consider another auxiliary loss in Section~\ref{sec:auxiliary} which we will use on our Wikidata dataset.
For a training set $S$ (augmented with reciprocal relations \citep{lacroix2018canonical, kazemi2018simple}), and parametric tensor estimate $\empx(\theta)$, we minimize the following objective, with a \emph{weighted} regularizer $\Omega$:
\begin{equation}
    \mathcal{L}(\empx(\theta)) = \frac{1}{|S|}\sum_{(i,j,k,l)\in S}\left[\ell(\empx(\theta);(i,j,k,l)) + \lambda\Omega(\theta; (i,j,k,l))\right].
\end{equation}

The ComplEx \citep{trouillon_complex_2016} decomposition can naturally be extended to this setting by adding a new factor $T$, we then have:
\begin{equation}
    \empx(U, V, T) = \operatorname{Re}\left(\brck{U,V,\overline{U}, T} \right)\iff \empx(U,V,T)_{i,j,k,l} = \operatorname{Re}\left(\langle u_i, v_j, \overline{u_k}, t_l\rangle\right)
    \label{eq:complex}
\end{equation}

We call this decomposition TComplEx. Intuitively, we added timestamps embedding that modulate the multi-linear dot product. Notice that the timestamp can be used to equivalently modulate the objects, predicates or subjects to obtain time-dependent representation:
\begin{equation}
    \langle u_i, v_j, \overline{u_k}, t_l\rangle = \langle u_i \odot t_l, v_j, \overline{u_k}\rangle = \langle u_i, v_j\odot t_l, \overline{u_k}\rangle = \langle u_i, v_j, \overline{u_k}\odot t_l\rangle.
    \label{eq:equivalent_subject_object}
\end{equation}

Contrary to DE-SimplE \citep{goel2019diachronic}, we do not learn temporal embeddings that scale with the number of entities (as frequencies and biases), but rather embeddings that scale with the number of timestamps. The number of parameters for the two models are compared in Table~\ref{tab:n_params}.





\subsection{Non-Temporal predicates}
Some predicates might not be affected by timestamps. For example, Malia and Sasha will always be the daughters of Barack and Michelle Obama, whereas the ``has occupation'' predicate between two entities might very well change over time. In heterogeneous knowledge bases, where some predicates might be temporal and some might not be, we propose to decompose the tensor $\empx$ as the sum of two tensors, one temporal, and the other non-temporal: 

\begin{equation}
    \empx = \operatorname{Re}\left(\brck{U,V^t,\overline{U}, T} + \brck{U,V,\overline{U}, \mathbf{1}}\right)\iff \empx_{i,j,k,l} = Re\left(\langle u_i, v^t_j\odot t_l + v_j, \overline{u_k}\rangle\right)
    \label{eq:tntcomplex}
\end{equation}

We call this decomposition TNTComplEx. \citet{goel2019diachronic} suggests another way of introducing a non-temporal component, by only allowing a fraction $\gamma$ of components of the embeddings to be modulated in time. By allowing this sharing of parameters between the temporal and non-temporal part of the tensor, our model removes one hyperparameter. Moreover, preliminary experiments showed that this model outperforms one without parameter sharing. 

\subsection{Regularization}
\label{sec:reg}
Any order $4$ tensor can be considered as an order $3$ tensor by \emph{unfolding} modes together. For a tensor $X \in \RR^{N_1\times N_2 \times N_3 \times N_4}$, unfolding modes $3$ and $4$ together will lead to tensor $\tilde{X}\in \RR^{N_1\times N_2\times N_3N_4}$ \citep{kolda_tensor_2009}.

We can see both decompositions (\eqref{eq:complex} and \eqref{eq:tntcomplex}) as order $3$ tensors by unfolding the temporal and predicate modes together. Considering the decomposition implied by these unfoldings (see Appendix~\ref{app:unfolding}) leads us to the following weighted regularizers \citep{lacroix2018canonical}:
\begin{align}
    \Omega^{3}(U, V, T; (i,j,k,l)) &= \frac{1}{3}\left(\|u_i\|_3^3 + \|u_k\|_3^3 + \|v_k\odot t_l\|_3^3\right) \label{eq:4_as_3}\\
    \Omega^{3}(U, V^t, V, T; (i,j,k,l)) &= \frac{1}{3}\left(2\|u_i\|_3^3 + 2\|u_k\|_3^3 + \|v_j^t\odot t_l\|_3^3 + \|v_j\|_3^3\right)
\end{align}
The first regularizer weights objects, predicates and pairs (predicate, timestamp) according to their respective marginal probabilities. This regularizer is a variational form of the weighted nuclear $3$-norm on an order $4$ tensor (see subsection~\ref{sec:variational} and Appendix~\ref{app:n3_for_4} for details and proof).
The second regularizer is the sum of the nuclear $3$ penalties on tensors $\brck{U,V^t, \overline{U}, T}$ and $\brck{U,V, \overline{U}}$.

\subsection{Smoothness of temporal embeddings}
\label{sec:grad_penalty}
We have more a priori structure on the temporal mode than on others. Notably, we expect smoothness of the application $i \mapsto t_{i}$. In words, we expect neighboring timestamps to have close representations. Thus, we penalize the norm of the discrete derivative of the temporal embeddings :
\begin{equation}
    \Lambda_p(T) = \frac{1}{|T| - 1}\sum_{i=1}^{|T|-1}\|t_{i+1} - t_i\|_p^p.
    \label{eq:temporal_reg}
\end{equation}
We show in Appendix~\ref{app:temporal_nuclear} that the sum of $\Lambda_p$ and the variational form of the nuclear $p$ norm~\eqref{eq:variational} lead to a variational form of a new tensor atomic norm.

\subsection{Nuclear $p$-norms of tensors and their variational forms}
\label{sec:variational}
As was done in \citet{lacroix2018canonical}, we aim to use tensor nuclear $p$-norms as regularizers. The definition of the nuclear $p$-norm of a tensor \citep{friedland_nuclear_2014} of order $D$ is:
\begin{equation}
    \|X\|_{p*} = \inf_{\alpha, R, U^{(1)}, \dots, U^{(D)}}\left\{
    \|\alpha\|_1~|~X=\sum_{r=1}^R \alpha_r U^{(1)}_{:, r} \otimes \dots \otimes U^{(D)}_{:, r}, \forall r,d~\|U^{(d)}_{:,r}\|_p=1
    \right\}.
\end{equation}
This formulation of the nuclear $p$-norm writes a tensor as a sum over \emph{atoms} which are the rank-$1$ tensors of unit $p$-norm factors.  The nuclear $p$-norm is NP-hard to compute \citep{friedland_nuclear_2014}. Following \citet{lacroix2018canonical}, a practical solution is to use the equivalent formulation of nuclear $p$-norm using their \emph{variational form}, which can be conveniently written for $p=D$:
\begin{equation}
    \|X\|_{D*} = \frac{1}{D}\inf_{X=\brck{U^{(1)}, \dots, U^{(D)}}}\sum_{d=1}^D\sum_{r=1}^R\|U^{(d)}_{:, r}\|_D^D.
    \label{eq:variational}
\end{equation}
For the equality above to hold, the infimum should be over all possible $R$. The practical solution is to fix $R$ to the desired rank of the decomposition. Using this variational formulation as a regularizer leads to state of the art results for order-3 tensors \citep{lacroix2018canonical} and is convenient in a stochastic gradient setting because it separates over each model coefficient.

In addition, this formulation makes it easy to introduce a weighting as recommended in \citet{srebro_collaborative_2010, foygel_learning_2011}. In order to learn under non-uniform sampling distributions, one should penalize the weighted norm : $\|\left(\sqrt{M^{(1)}}\otimes\sqrt{M^{(2)}}\right)\odot X\|_{2*}$, where $M^{(1)}$ and $M^{(2)}$ are the empirical row and column marginal of the distribution. The variational form~\eqref{eq:variational} makes this easy, by simply penalizing rows $U^{(1)}_{i_1}, \dots, U^{(D)}_{i_D}$ for observed triple $(i_1,\dots,i_D)$ in stochastic gradient descent. More precisely for $D=2$ and $N^{(d)}$ the vectors holding the observed count of each index over each mode $d$:
\begin{equation}
    \frac{1}{|S|}\sum_{(i,j)\in S}\|u_i\|_2^2+\|v_j\|_2^2 = \sum_{i} \frac{N^{(1)}_i}{S}\|u_i\|_2^2 + \sum_{j} \frac{N^{(2)}_j}{S}\|v_j\|_2^2 = \sum_{i} M^{(1)}_i\|u_i\|_2^2 + \sum_{j} M^{(2)}_j\|v_j\|_2^2.
\end{equation}

In subsection~\ref{sec:grad_penalty}, we add another penalty in Equation~\eqref{eq:temporal_reg} which changes the norm of our atoms.In subsection~\ref{sec:reg}, we introduced another variational form in Equation~\eqref{eq:4_as_3} which allows to easily penalize the nuclear $3$-norm of an order $4$ tensor. This regularizer leads to different weighting. By considering the unfolding of the timestamp and predicate modes, we are able to weight according to the joint marginal of timestamps and predicates, rather than by the product of the marginals. This can be an important distinction if the two are not independent.

\subsection{Experimental impact of the regularizers}
We study the impact of regularization on the ICEWS05-15 dataset, for the TNTComplEx model. For details on the experimental set-up, see Section~\ref{sec:exp}. The first effect we want to quantify is the effect of the regularizer $\Lambda_p$. We run a grid search for the strength of both $\Lambda_p$ and $\Omega^{3}$ and plot the convex hull as a function of the temporal regularization strength. As shown in Figure~\ref{fig:ablation}, imposing smoothness along the time mode brings an improvement of over $2$ MRR point.

The second effect we wish to quantify is the effect of the choice of regularizer $\Omega$. A natural regularizer for TNTComplEx would be : 
\begin{equation}
    \Delta^p(U, V, T; (i,j,k,l)) = \frac{1}{p}\left(2\|u_i\|_p^p + 2\|u_k\|_p^p + \|v^t_j\|_p^p + \|t_l\|_p^p + \|v_j\|_p^p\right).
\end{equation}
We compare $\Delta^4$, $\Delta^3$ and $\Delta^2$ with $\Omega^3$. The comparison is done with a temporal regularizer of $0$ to reduce the experimental space.

$\Delta^2$ is the common weight-decay frequently used in deep-learning. Such regularizers have been used in knowledge base completion \citep{nickel_three-way_2011, nickel_holographic_2015, trouillon_complex_2016}, however, \citet{lacroix2018canonical} showed that the infimum of this penalty is non-convex over tensors.

$\Delta^3$ matches the order used in the $\Omega^3$ regularizer, and in previous work on knowledge base completion \citep{lacroix2018canonical}. However, by the same arguments, its minimization does not lead to a convex penalty over tensors.

$\Delta^4$ is the sum of the variational forms of the Nuclear $4$-norm for the two tensors of order $4$ in the TNTComplEx model according to equation~\eqref{eq:variational}.

Detailed results of the impact of regularization on the performances of the model are given in Figure~\ref{fig:ablation}. The two regularizers $\Delta^4$ and $\Omega^3$ are the only regularizers that can be interpreted as sums of tensor norm variational forms and perform better than their lower order counterparts.

There are two differences between $\Delta^4$ and $\Omega^3$. First, whereas the first is a variational form of the nuclear $4$-norm, the second is a variational form of the nuclear $3$-norm which is closer to the nuclear $2$-norm. Results for exact recovery of tensors have been generalized to the nuclear $2$-norm, and to the extent of our knowledge, there has been no formal study of generalization properties or exact recovery under the nuclear $p$-norm for $p$ greater than two. 

Second, the weighting in $\Delta^4$ is done separately over timestamps and predicates, whereas it is done jointly for $\Omega^3$. This leads to using the joint empirical marginal as a weighting over timestamps and predicates. The impact of weighting on the guarantees that can be obtained are described more precisely in \citet{foygel_learning_2011}.

The contribution of all these regularizers over a non-regularized model are summarized in Table~\ref{tab:ablation}. Note that careful regularization leads to a $0.05$ MRR increase.

\begin{figure}[t]
\centering
    \begin{subfigure}[b]{0.48\textwidth}
      \centering \includegraphics[width=0.9\textwidth]{cont_reg.eps}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.48\textwidth}
      \centering \includegraphics[width=0.9\textwidth]{emb_reg.eps}
    \end{subfigure}
    \caption{Impact of the temporal (left) regularizer and embeddings (right) regularizer on a TNTComplEx model trained on ICEWS05-15. 
}
    \label{fig:ablation}
\end{figure}




\section{A new dataset for Temporal and non-Temporal Knowledge Base Completion}

A dataset based on Wikidata was proposed by \citet{garcia2018learning}. However, upon inspection, this dataset contains numerical data as entities, such as ELO rankings of chess players, which are not representative of practically useful link prediction problems. 
Also, in this dataset, temporal informations is specified in the form of ``OccursSince'' and ``OccursUntil'' statements appended to triples, which becomes unwieldy when a predicate holds for several intervals in time. Moreover, this dataset contains only $11k$ entities and $150k$ which is insufficient to benchmark methods at scale.

The GDelt dataset described in \citet{ma2018embedding, goel2019diachronic} holds many triples ($2M$), but does not describe enough entities ($500$). In order to adress these limitations, we created our own dataset from Wikidata, which we make available along with the code for this paper at \url{https://github.com/facebookresearch/tkbc}.


Starting from Wikidata, we removed all entities that were instance of scholarly articles, proteins and others. We also removed disambiguation, template, category and project pages from wikipedia. Then, we removed all facts for which the object was not an entity. We iteratively filtered out entities that had degree at least $5$ and predicates that had at least $50$ occurrences. With this method, we obtained a dataset of $432715$ entities, $407$ predicates and $1724$ timestamps (we only kept the years). Each datum is a triple (subject, predicate, object) together a timestamp range (begin, end) where begin, end or both can be unspecified. Our train set contains $7M$ such tuples, with about $10\%$ partially specified temporal tuples. We kept a validation and test set of size $50k$ each.

At train and test time, for a given datum (subject, predicate, object, [begin, end]), we sample a timestamp (appearing in the dataset) uniformly at random, in the range [begin, end]. For datum without a temporal range, we sample over the maximum date range. Then, we rank the objects for the partial query (subject, predicate, ?, timestamp).

\section{Experimental Results}
\subsection{Experimental Set-Up}
\label{sec:exp}
We follow the experimental set-up in \citet{garcia2018learning, goel2019diachronic}. We use models from \citet{garcia2018learning} and \citet{goel2019diachronic} as baselines since they are the best performing algorithms on the datasets considered. We report the filtered Mean Reciprocal Rank (MRR) defined in \citet{nickel_holographic_2015}. In order to obtaiqn comparable results, we use Table~\ref{tab:n_params} and dataset statistics to compute the rank for each (model, dataset) pair that matches the number of parameters used in \citet{goel2019diachronic}. We also report results at ranks $10$ times higher. This higher rank set-up gives an estimation of the best possible performance attainable on these datasets, even though the dimension used might be impractical for applied systems. All our models are optimized with Adagrad \citep{duchi_adaptive_2011}, with a learning rate of $0.1$, a batch-size of $1000$. More details on the grid-search, actual ranks used and hyper-parameters are given in Appendix~\ref{app:grid_search}.

We give results on $3$ datasets previously used in the litterature : ICEWS14, ICEWS15-05 and Yago15k. The ICEWS datasets are samplings from the  Integrated Conflict Early Warning System (ICEWS)\citep{icewsdataset}\footnote{More information can be found at \url{http://www.icews.com}}.\citet{garcia2018learning} introduced two subsampling of this data, ICEWS14 which contains all events occuring in 2014 and ICEWS05-15 which contains events occuring between 2005 and 2015. These datasets immediately fit in our framework, since the timestamps are already discretized.

The Yago15K dataset \citep{garcia2018learning} is a modification of FB15k \citep{bordes_translating_2013} which adds ``occursSince'' and ``occursUntil'' timestamps to each triples. Following the evaluation setting of \citet{garcia2018learning}, during evaluation, the incomplete triples to complete are of the form (subject, predicate, ?, {occursSince | occursUntil}, timestamp) (with reciprocal predicates). Rather than deal with tensors of order $5$, we choose to unfold the (occursSince,  occursUntil) and the predicate mode together, multiplying its size by two.

Some relations in Wikidata are highly unbalanced (eg. (?, InstanceOf, Human)). For such relations, a ranking evaluation would not make much sense. Instead, we only compute the Mean Reciprocal Rank for missing right hand sides, since the data is such that highly unbalanced relations happen on the left-hand side. However, we follow the same training scheme as for all the other dataset, including reciprocal relations in the training set. The cross-entropy loss evaluated on $400k$ entities puts a restriction on the dimensionality of embeddings at about $d=100$ for a batch-size of $1000$. We leave sampling of this loss, which would allow for higher dimensions to future work.


\subsection{Results}


\begin{table*}[t]
\begin{minipage}{0.7\linewidth}
\centering
\begin{tabular}{lccc}
\toprule
{} &  ICEWS14 & ICEWS15-05 & Yago15k\\
TA & $0.48$ & $0.47$ & $0.32$ \\
DE-SimplE & $0.53$ & $0.51$ & - \\
ComplEx & $0.47$ ($0.47$) & $0.49$ ($0.49$) & $\mathbf{0.35}$ ($0.36$) \\
\midrule
TComplEx & $\mathbf{0.56}$ ($0.61$)& $0.58$ ($0.66$)& $\mathbf{0.35}$ ($0.36$) \\
TNTComplEx & $\mathbf{0.56}$ ($\mathbf{0.62}$)& $\mathbf{0.60}$ ($\mathbf{0.67}$) & $\mathbf{0.35}$ ($\mathbf{0.37}$)\\
\bottomrule
\end{tabular}
\caption{Results for TA \citep{garcia2018learning} and DE-SimplE \citep{goel2019diachronic} are the best numbers reported in the respective papers. Our models have as many parameters as DE-SimplE. Numbers in parentheses are for ranks multiplied by $10$.\label{tab:res}}
\end{minipage}
\hfill
\begin{minipage}{0.25\linewidth}
\centering
\begin{tabular}{c|c}
\toprule
Reg. & MRR\\ \midrule
No regularizer &  $0.62$ \\
$\Delta^2$ & $0.63$ \\
$\Delta^3$ &  $0.63$ \\
$\Delta^4$ & $0.64$\\
$\Omega^3$ & $0.65$\\
$\Omega^3+\Lambda_4$ & $ {\bf 0.67}$\\
\bottomrule
\end{tabular}
\caption{Impact of regularizers on ICEWS05-15 for TNTComplEx.\label{tab:ablation}}
\end{minipage}
\end{table*}

\begin{table*}[b]
\centering
\begin{tabular}{lccc}
\toprule
{} &  MRR & NT-MRR & T-MRR \\
ComplEx & $\mathbf{0.45}$ & $\mathbf{0.48}$ & $0.29$\\
\midrule
TComplEx & $0.42$ & $0.45$ & $0.30$ \\
TNTComplEx & $0.44$ & $0.47$ & $\mathbf{0.32}$ \\
\bottomrule
\end{tabular}
\caption{Results on wikidata for entity dimension $d=100$.}
\label{tab:res_wikidata}
\end{table*}



We compare ComplEx with the temporal versions described in this paper. We report results in Table~\ref{tab:res}. Note that ComplEx has performances that are stable through a tenfold increase of its number of parameters, a rank of $100$ is enough to capture the static information of these datasets. For temporal models however, the performance increases a lot with the number of parameters. It is always beneficial to allow a separate modeling of non-temporal predicates, as the performances of TNTComplex show. Finally, our model match or beat the state of the art on all datasets, even at identical number of parameters. Since these datasets are small, we also report results for higher ranks ($10$ times the number of parameters used for DE-SimplE).

On Wikidata, $90\%$ of the triples have no temporal data attached. This leads to ComplEx outperforming all temporal models in term of average MRR, since the Non-Temporal MRR (NT-MRR) far outweighs the Temporal MRR (T-MRR). A breakdown of the performances is available in table~\ref{tab:res_wikidata}. 
TNTComplEx obtains performances that are comparable to ComplEx on non-temporal triples, but are better on temporal triples. Moreover, TNTComplEx can minimize the temporal cross-entropy~\eqref{eq:time_loss} and is thus more flexible on the queries it can answer.

Training TNTComplEx on Wikidata with a rank of $d=100$ with the full cross-entropy on a Quadro GP 100, we obtain a speed of $5.6k$ triples per second, leading to experiments time of $7.2$ hours. This is to be compared with $5.8k$ triples per second when training ComplEx for experiments time of $6.9$ hours. The additional complexity of our model does not lead to any real impact on runtime, which is dominated by the computation of the cross-entropy over $400k$ entities.



\section{Qualitative study}
\label{sec:auxiliary}
The instantaneous loss described in equation~\eqref{eq:inst_loss}, along with the timestamp sampling scheme described in the previous section only enforces correct rankings along the ``object'' tubes of our order-$4$ tensor. In order to enforce a stronger temporal consistency, and be able to answer queries of the type (subject, predicate, object, ?), we propose another cross-entropy loss along the temporal tubes:
\begin{equation}
    \tilde{\ell}(\empx;(i,j,k,l)) = - \empx_{i,j,k,l} + \log\Big(\sum_{l'}\exp\big(\empx_{i,j,k,l'}\big)\Big).
    \label{eq:time_loss}
\vspace{-0.2cm}
\end{equation}
We optimize the sum of $\ell$ defined in Equation~\ref{eq:inst_loss} and $\tilde{\ell}$ defined in Equation~\ref{eq:time_loss}. Doing so, we only lose $1$ MRR point overall. However, we make our model better at answering queries along the time axis. The macro area under the precision recall curve is $0.92$ for a TNTComplEx model learned with $\ell$ alone and $0.98$ for a TNTComplEx model trained with $\ell+\tilde{\ell}$.

We plot in Figure~\ref{fig:qualitative} the scores along time for train triples (president of the french republic, office holder, \{Jacques Chirac | Nicolas Sarkozy | François Hollande | Emmanuel Macron\}, $[1980,2020]$). The periods where a score is highest matches closely the ground truth of start and end dates of these presidents mandates which is represented as a colored background. This shows that our models are able to learn rankings that are correct along time intervals despite our training method only ever sampling timestamps within these intervals.
\vspace{-3mm}
\begin{figure}[t]
    \centering
    \begin{subfigure}[b]{0.7\textwidth}
      \centering \includegraphics[width=\textwidth]{temporal_presidents.eps}
    \end{subfigure}
    \caption{Scores for triples (President of the French republic, office holder, \{Jacques Chirac | Nicolas Sarkozy | François Hollande | Emmanuel Macron\}, $[1980,2020]$)}
    \label{fig:qualitative}
\vspace{-3mm}    
\end{figure}

\section{Conclusion}
Tensor methods have been successful for Knowledge Base completion. In this work, we suggest an extension of these methods to Temporal Knowledge Bases. Our methodology adapts well to the various form of these datasets : point-in-time, beginning and endings or intervals. We show that our methods reach higher performances than the state of the art for similar number of parameters. For several datasets, we also provide performances for higher dimensions. We hope that the gap between low-dimensional and high-dimensional models can motivate further research in models that have increased expressivity at lower number of parameters per entity. Finally, we propose a large scale temporal dataset which we believe represents the challenges of large scale temporal completion in knowledge bases. We give performances of our methods for low-ranks on this dataset. We believe that, given its scale, this dataset could also be an interesting addition to non-temporal knowledge base completion.


\newpage
\bibliographystyle{iclr2020_conference}
\bibliography{paper}

\clearpage

\section{Appendix}
\subsection{Unfolding and the CP decomposition}
\label{app:unfolding}
Let $X=\brck{U,V,W,T}$, that is $X_{i,j,k,l}=\langle u_i, v_j, w_k, t_l\rangle$. Then according to \citet{kolda_tensor_2009}, unfolding along modes $3$ and $4$ leads to an order three tensor of decomposition $\tilde{X}=\brck{U,V,W \circ T}$. Where $\circ$ is the Khatri-Rao product \citep{smilde2005multi}, which is the column-wise Kronecker product : $W\circ T = (W_{:,1}\otimes T_{:, 1}, \dots, W_{:,R}\otimes T_{:, R})$.

Note that for a fourth mode of size $L$: $\left(W \circ T\right)_{L(k-1)+l} = w_k \odot t_l$. This justifies the regularizers used in Section~\ref{sec:reg}.

\subsection{Temporal regularizer and Nuclear norms}
\label{app:temporal_nuclear}
Consider the penalty:
\begin{equation}
    \Omega(U,V,W,T) = \frac{1}{4}\left(\|U\|_4^4 + \|V\|_4^4 + \|W\|_4^4 + \|T\|_4^4 + \alpha\|T_{1:}-T_{:-1}\|_4^4\right)
\end{equation}
Let us define a new norm on vectors:
\begin{equation}
    \|t\|_{\tau 4} = \left(\|t\|_4^4+\alpha\|t_{1:}-t_{:-1}\|_4^4\right)^{1/4}
\end{equation}
$\|\cdot\|_{\tau 4}$ is a norm and lets us rewrite:
\begin{equation}
    \Omega(U,V,W,T) = \sum_{r=1}^R\frac{1}{4}\left(\|u_r\|_4^4 + \|v_r\|_4^4 + \|w_r\|_4^4 + \|t_r\|_{\tau 4}^4\right).
\end{equation}
Following the proof in \citet{lacroix2018canonical} which only uses homogeneity of the norms, we can show that $\Omega(U,V,W,T)$ is a variational form of an atomic norm with atoms :
$$\mathcal{A}=\left\{u\otimes v\otimes w\otimes t~|~\|u\|_4, \|v\|_4, \|w\|_4 \leq 1~\textrm{and}~\|t\|_{\tau 4}\leq 1\right\}$$

\subsection{Nuclear norms on unfoldings}
\label{app:n3_for_4}
We consider the regularizer :
\begin{equation}
\Omega^{N3}(U, V, T; (i,j,k,l)) = \frac{1}{3}\left(\|u_i\|_3^3 + \|u_k\|_3^3 + \|v_k\odot t_l\|_3^3\right).
\end{equation}
Let $D^{\textrm{subj}}$ (resp. obj, pred/time) the diagonal matrix containing the cubic-roots of the marginal probabilities of each subject (resp. obj, pred/time) in the dataset. We denote by $\circ$ the Kathri-Rao product between two matrices (the columnwise Kronecker product). Summing over the entire dataset, we obtain the penalty:
\begin{equation}
\frac{1}{|S|}\sum_{(i,j,k,l)\in S}\Omega^{N3}(U, V, T; (i,j,k,l)) = \frac{1}{3}\left(\|D^{\textrm{subj}}U\|_3^3 + \|D^{\textrm{obj}}U\|_3^3 + \|D^{\textrm{pred/time}}(V \circ T)\|_3^3\right).
\end{equation}

Dropping the weightings to simplify notations, we state the equivalence between this regularizer and a variational form of the nuclear $3$-norm of an order $4$ tensor:

\begin{equation}
    \inf_{[U_1, U_2, U_3, U_4]=X}\frac{1}{3}\left(\sum_{r=1}^R \|u_r^{(1)}\|_3^3 + \|u_r^{(2)}\|_3^3 + \|u_r^{(3)} \otimes u_r^{(4)}\|_3^3\right) = \inf_{[U_1, U_2, U_3, U_4]=X}\frac{1}{3}\left(\sum_{r=1}^R \prod_{d=1}^4\|u_r^{(d)}\|_3\right).
    \label{eq:n3_n4}
\end{equation}
The proof follows \citet{lacroix2018canonical}, noting that $\|u_r^{(3)} \otimes u_r^{(4)}\|_3^3 = \|u_r^{(3)}\|_3^3\| u_r^{(4)}\|_3^3$. Note that for $D^{\textrm{pred/time}}=D^{\textrm{pred}}D^{\textrm{time}}$, there would also be equality of the weighted norms. However, in the application considered, time and predicate are most likely not independent, leading to different weightings of the norms.
\newpage

\subsection{Dataset statistics}
\label{app:statistics}
Statistics of all the datasets used in this work are gathered in Table~\ref{tab:stats}.
\begin{table}[h]
    \centering
    \begin{tabular}{lcccc}
        \toprule
         {} & ICEWS14 & ICEWS05-15 & Yago15k & Wikidata\\
         Entities & $6869$ & $10094$ & $15403$ & $432715$ \\
         Predicates &$460$&$502$&$102$ & $814$  \\
         Timestamps & $365$&$4017$&$170$ & $1726$ \\
         |S| & $72826$&$368962$&$110441$ & $7224361$\\
         \bottomrule
    \end{tabular}
    \caption{Dataset statistics}
    \label{tab:stats}
\end{table}

\subsection{Detailed results}
\begin{table}[h]
\begin{small}
\begin{tabular}{l|p{0.45cm}p{0.45cm}p{0.45cm}p{0.7cm}|p{0.45cm}p{0.45cm}p{0.45cm}p{0.65cm}|p{0.45cm}p{0.45cm}p{0.45cm}p{0.7cm}}
\toprule
{} &  \multicolumn{4}{c}{ICEWS14} & \multicolumn{4}{c}{ICEWS15-05} & \multicolumn{4}{c}{Yago15k}\\
{} & MRR & H@1 & H@3 & H@10 & MRR & H@1 & H@3 & H@10 & MRR & H@1 & H@3 & H@10 \\
TA & $0.48$ & 0.37 & - & 0.69 & $0.47$ & 0.35 & - & 0.73 & $0.32$ & 0.23 & - & 0.51  \\
DE-SimplE & $0.53$ & 0.42 & 0.59 & 0.73 & $0.51$ & 0.39 & 0.58 & 0.75 & - & - & - & -\\
ComplEx & $0.47$& 0.35 & 0.53 & 0.70 & $0.49$& 0.37 & 0.55 & 0.72 & $\mathbf{0.35}$& $\mathbf{0.28}$ & $\mathbf{0.35}$ & $\mathbf{0.52}$ \\
\midrule
TComplEx & $\mathbf{0.56}$ & $\mathbf{0.47}$ & $\mathbf{0.61}$ & 0.73 & $0.58$& 0.49 & 0.64 & 0.76 & $\mathbf{0.35}$& 0.27 & $\mathbf{0.36}$ & $\mathbf{0.52}$\\
TNTComplEx & $\mathbf{0.56}$ &0.46 &$\mathbf{0.61}$ &$\mathbf{0.74}$ & $\mathbf{0.60}$ & $\mathbf{0.50}$ & $\mathbf{0.65}$ & $\mathbf{0.78}$ & $\mathbf{0.35}$ & $\mathbf{0.28}$ & 0.35 & $\mathbf{0.52}$\\
\midrule
ComplEx (x10) & $0.47$ & 0.35 & 0.54 & 0.71 & $0.49$ & 0.37 & 0.55 & 0.73 & $0.36$ & $\mathbf{0.29}$ & 0.36 & $\mathbf{0.54}$ \\
TComplEx (x10) & $0.61$ & $\mathbf{0.53}$ & $\mathbf{0.66}$ & $\mathbf{0.77}$ & $0.66$ & $\mathbf{0.59}$ & $\mathbf{0.71}$ & 0.80 & $0.36$ & 0.28 & 0.38 & $\mathbf{0.54}$ \\
TNTComplEx (x10) & $\mathbf{0.62}$ & 0.52 & $\mathbf{0.66}$ & 0.76 & $\mathbf{0.67}$ & $\mathbf{0.59}$ & $\mathbf{0.71}$ & $\mathbf{0.81}$ & $\mathbf{0.37}$ & $\mathbf{0.29}$ & $\mathbf{0.39}$ & $\mathbf{0.54}$\\
\bottomrule
\end{tabular}
\caption{Results for TA \citep{garcia2018learning} and DE-SimplE \citep{goel2019diachronic} are the best numbers reported in the respective papers.}
\end{small}
\end{table}
\subsection{Standard deviations}
We give the standard deviations for the MRR computed over 5 runs of TNTComplEx on all datasets:
\begin{tabular}{lccccc}
\toprule
{} &  ICEWS14 & ICEWS15-05 & Yago15k & Wikidata (T) & Wikidata (NT)\\
TNTComplEx & 0.0016 & 0.0011 & 0.00076 & 0.0035 & 0.0012\\
\bottomrule
\end{tabular}

\subsection{Grid Search}
\label{app:grid_search}
For ICEWS14, ICEWS05-15 and Yago15k, we follow the grid-search below :

Using Table~\ref{tab:n_params} to compute the number of parameters and the dataset statistics in Table~\ref{tab:stats}, we use the following ranks to match the number of parameters of DE-SimplE in dimension $100$:
\begin{table}[h]
    \centering
    \begin{tabular}{lccc}
        \toprule
         {} & ICEWS14 & ICEWS05-15 & Yago15k \\
         DE-SimplE & 100 & 100 & 100\\
         \midrule
         ComplEx &$182$&$186$&$196$ \\
         TComplEx &$174$&$136$&$194$  \\
         TTComplEx & $156$&$128$&$189$\\
         \bottomrule
    \end{tabular}
    \label{tab:ranks}
\end{table} 
\end{document}