\documentclass{article}

\usepackage[final]{neurips_2021}
\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{xcolor}         \usepackage{graphicx}
\usepackage{multirow}
\usepackage{array}
\usepackage{subfigure}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{bbding}


\usepackage{amsmath}

\usepackage{graphicx}
\usepackage[linesnumbered,ruled]{algorithm2e}


\clearpage{}

\usepackage{amsmath,amsfonts,bm}

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\rvX{{\mathbf{X}}}
\def\rvU{{\mathbf{U}}}
\def\rvV{{\mathbf{V}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\vX{{\bm{X}}}
\def\vU{{\bm{U}}}
\def\vV{{\bm{V}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} \let\ab\allowbreak
\clearpage{}

\usepackage{amssymb}\usepackage{pifont}\newcommand{\cmark}{\ding{51}\xspace}\newcommand{\cmarkg}{\textcolor{lightgray}{\ding{51}}\xspace}\newcommand{\xmark}{\ding{55}\xspace}\newcommand{\xmarkg}{\textcolor{lightgray}{\ding{55}}\xspace}

\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsthm}
\usepackage[misc]{ifsym}
\newtheorem{theorem}{Theorem}
\renewcommand\qedsymbol{$\blacksquare$}
\hyphenpenalty=500

\newcommand{\app}{\raise.17ex\hbox{$\scriptstyle\sim$}}
\makeatletter\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}
  {.495em \@plus1ex \@minus.2ex}{-.5em}{\normalfont\normalsize\bfseries}}\makeatother

\makeatletter
\DeclareRobustCommand\onedot{\futurelet\@let@token\@onedot}
\def\@onedot{\ifx\@let@token.\else.\null\fi\xspace}

\def\eg{\emph{e.g}\onedot} \def\Eg{\emph{E.g}\onedot}
\def\ie{\emph{i.e}\onedot} \def\Ie{\emph{I.e}\onedot}
\def\cf{\emph{c.f}\onedot} \def\Cf{\emph{C.f}\onedot}
\def\etc{\emph{etc}\onedot} \def\vs{\emph{vs}\onedot}
\def\wrt{w.r.t\onedot} \def\dof{d.o.f\onedot}
\def\etal{\emph{et al}\onedot}
\makeatother

\newcolumntype{x}[1]{>{\centering\arraybackslash}p{#1pt}}
\newlength\savewidth\newcommand\shline{\noalign{\global\savewidth\arrayrulewidth\global\arrayrulewidth 1pt}\hline\noalign{\global\arrayrulewidth\savewidth}}
\newcommand{\tablestyle}[2]{\setlength{\tabcolsep}{#1}\renewcommand{\arraystretch}{#2}\centering\footnotesize}


\title{Are Transformers More Robust Than CNNs? }
\author{
Yutong Bai\textsuperscript{1} \quad
Jieru Mei\textsuperscript{1} \quad
Alan Yuille\textsuperscript{1} \quad
Cihang Xie\textsuperscript{2} \vspace{.3em}\\
\textsuperscript{1}Johns Hopkins University \qquad\qquad \textsuperscript{2} University of California, Santa Cruz \vspace{.2em}\\
\texttt{\{ytongbai, meijieru, alan.l.yuille, cihangxie306\}@gmail.com}
}


\begin{document}
\maketitle
\begin{abstract}
Transformer emerges as a powerful tool for visual recognition. In addition to demonstrating competitive performance on a broad range of visual benchmarks,  recent works also argue that Transformers are much more robust than Convolutions Neural Networks (CNNs). Nonetheless, surprisingly, we find these conclusions are drawn from unfair experimental settings, where Transformers and CNNs are compared at different scales and are applied with distinct training frameworks. In this paper, we aim to provide the first \textbf{fair \& in-depth} comparisons between Transformers and CNNs, focusing on robustness evaluations. 

With our unified training setup, we first challenge the previous belief that Transformers outshine CNNs when measuring \emph{adversarial robustness}. More surprisingly, we find CNNs can easily be as robust as Transformers on defending against adversarial attacks, if they properly adopt Transformers' training recipes. While regarding \emph{generalization on out-of-distribution samples}, we show pre-training on (external) large-scale datasets is not a fundamental request for enabling Transformers to achieve better performance than CNNs. Moreover, our ablations suggest such stronger generalization is largely benefited by the Transformer's self-attention-like architectures per se, rather than by other training setups. We hope this work can help the community better understand and benchmark the robustness of Transformers and CNNs. The code and models are publicly available at \url{https://github.com/ytongbai/ViTs-vs-CNNs}. 
\end{abstract}



\section{Introduction}
Convolutional Neural Networks (CNNs) have been the widely-used architecture for visual recognition in recent years \cite{Krizhevsky2012,Simonyan2015,Szegedy2015a,He2016,huang2017densely}. It is commonly believed the key to such success is the usage of the convolutional operation, as it introduces several useful inductive biases (\eg, translation equivalence) to models for benefiting object recognition. Interestingly, recent works alternatively suggest that it is also possible to build successful recognition models without convolutions \cite{ramachandran2019stand,Zhao_2020_CVPR,bello2019attention}. The most representative work in this direction is Vision Transformer (ViT) \cite{dosovitskiy2020image}, which applies the pure self-attention-based architecture to sequences of images patches and attains competitive performance on the challenging ImageNet classification task \cite{Russakovsky2015} compared to CNNs. Later works \cite{liu2021swin,wang2021pyramid} further expand Transformers with compelling performance on other visual benchmarks, including COCO detection and instance segmentation \cite{lin2014microsoft}, ADE20K semantic segmentation \cite{zhou2017scene}.
   
The dominion of CNNs on visual recognition is further challenged by the recent findings that Transformers appear to be \emph{much more robust} than CNNs. For example, Shao \etal \cite{shao2021adversarial} observe that the usage of convolutions may introduce a negative effect on models' adversarial robustness, while migrating to Transformer-like architectures (\eg, the Conv-Transformer hybrid model or the pure Transformer) can help secure models' adversarial robustness. Similarly, Bhojanapalli \etal \cite{bhojanapalli2021understanding} report that, if pre-trained on sufficiently large datasets, Transformers exhibit considerably stronger robustness than CNNs on a spectrum of out-of-distribution tests (\eg, common image corruptions \cite{Hendrycks2018}, texture-shape cue conflicting stimuli \cite{Geirhos2018}).  

Though both \cite{bhojanapalli2021understanding} and \cite{shao2021adversarial} claim that Transformers are preferable to CNNs in terms of robustness, we find that such conclusion cannot be strongly drawn based on their existing experiments. Firstly, Transformers and CNNs are not compared at the same model scale, \eg, a small CNN, ResNet-50 (\app25 million parameters), by default is compared to a much larger Transformer, ViT-B (\app86 million parameters), for these robustness evaluations. Secondly, the training frameworks applied to Transformers and CNNs are distinct from each other (\eg, training datasets, number of epochs, and augmentation strategies are all different), while little efforts are devoted on ablating the corresponding effects. In a nutshell, due to these inconsistent and unfair experiment settings, \emph{it remains an open question whether Transformers are truly more robust than CNNs}.

To answer it, in this paper, we aim to provide the first benchmark to fairly compare Transformers to CNNs in robustness evaluations. We particularly focus on the comparisons between Small Data-efficient image Transformer (DeiT-S) \cite{touvron2020training} and ResNet-50 \cite{He2016}, as they have similar model capacity (\ie, \app22 million parameters \vs \app25 million parameters) and achieve similar performance on ImageNet (\ie, 76.8\% top-1 accuracy \vs 76.9\% top-1 accuracy\footnote{Here we apply the general setup in \cite{pmlr-v139-touvron21a} for the ImageNet training. We follow the popular ResNet's standard to train both models for 100 epochs. Please refer to Section \ref{sec:settings:vit} for more  training details.}). Our evaluation suite accesses model robustness in two ways: 1) adversarial robustness, where the attackers can actively and aggressively manipulate inputs to approximate the worst-case scenario; 2) generalization on out-of-distribution samples, including common image corruptions (ImageNet-C \cite{Hendrycks2018}), texture-shape cue conflicting stimuli (Stylized-ImageNet \cite{Geirhos2018}) and natural adversarial examples (ImageNet-A \cite{hendrycks2021nae}).

With this unified training setup, we present a completely different picture from previous ones \cite{shao2021adversarial,bhojanapalli2021understanding}. Regarding adversarial robustness, we find that Transformers actually are no more robust than CNNs---if CNNs 
are allowed to properly adopt Transformers' training recipes, then these two types of models will attain similar robustness on defending against both perturbation-based adversarial attacks and patch-based adversarial attacks.
While for generalization on out-of-distribution samples, we find Transformers can still substantially outperform CNNs even without the needs of pre-training on sufficiently large (external) datasets. Additionally, our ablations show that adopting Transformer's self-attention-like architecture is the key for achieving strong robustness on these out-of-distribution samples, while tuning other training setups will only yield subtle effects here. We hope this work can serve as a useful benchmark for future explorations on robustness, using different network architectures, like CNNs, Transformers, and beyond \cite{tolstikhin2021mlp,liu2021pay}.



\section{Related Works}
\paragraph{Vision Transformer.}
Transformers, invented by Vaswani \etal in 2017 \cite{Vaswani2017}, have largely advanced the field of natural language processing (NLP). With the introduction of self-attention module, Transformer can effectively capture the non-local relationships between all input sequence elements, achieving the state-of-the-art performance on numerous NLP tasks \cite{yang2019xlnet, dai2019Transformer, brown2020language, devlin2018bert, radford2018improving, radford2019language}.

The success of Transformer on NLP also starts to get witnessed in computer vision. The pioneering work, ViT \cite{dosovitskiy2020image}, demonstrates that the pure Transformer architectures are able to achieve exciting results on several visual benchmarks, especially when extremely large datasets (\eg, JFT-300M \cite{sun2017revisiting}) are available for pre-training. This work is then subsequently improved by carefully curating the training pipeline and the distillation strategy to Transformers \cite{touvron2020training}, enhancing the Transformers' tokenization module \cite{yuan2021tokens}, building multi-resolution feature maps on Transformers \cite{liu2021swin,wang2021pyramid}, designing parameter-efficient Transformers for scaling \cite{zhai2021scaling,touvron2021going,xue2021go}, \etc. In this work, rather than focusing on furthering Transformers on standard visual benchmarks, we aim to provide a fair and comprehensive study of their performance when testing out of the box.

\paragraph{Robustness Evaluations.}
Conventional learning paradigm assumes training data and testing data are drawn from the same distribution. This assumption generally does not hold, especially in the real-world case where the underlying distribution is too complicated to be covered in a (limited-sized) dataset. To properly access model performance in the wild, a set of robustness generalization benchmarks have been built, \eg, ImageNet-C \cite{Hendrycks2018},  Stylized-ImageNet \cite{Geirhos2018}, ImageNet-A \cite{hendrycks2021nae}, \etc. Another standard surrogate for testing model robustness is via adversarial attacks, where the attackers deliberately add small perturbations or patches to input images, for approximating the worst-case evaluation scenario \cite{Szegedy2014,Goodfellow2015}. In this work, both robustness generalization and adversarial robustness are considered in our robustness evaluation suite.

Concurrent to ours, both Bhojanapalli \etal \cite{bhojanapalli2021understanding} and Shao \etal \cite{shao2021adversarial} conduct robustness comparisons between Transformers and CNNs. Nonetheless, we find their experimental settings are unfair, \eg, models are compared at different capacity \cite{bhojanapalli2021understanding,shao2021adversarial} or are trained under distinct frameworks \cite{shao2021adversarial}. In this work, our comparison carefully align the model capacity and the training setups, which draws completely different conclusions from the previous ones.



\section{Settings}
\label{Sec:settings}
\subsection{Training CNNs and Transformers}
\label{sec:settings:vit}
\paragraph{Convolutional Neural Networks.}
ResNet \cite{He2016} is a milestone architecture in the history of CNN. We choose its most popular instantiation, \emph{ResNet-50} (with \app25 million parameters), as the default CNN architecture. To train CNNs on ImageNet, we follow the standard recipe of \cite{goyal2017accurate,radosavovic2020designing}. Specifically, we train all CNNs for a total of 100 epochs, using momentum-SGD optimizer; we set the initial learning rate to 0.1, and decrease the learning rate by 10$\times$ at the 30-th, 60-th, and 90-th epoch; no regularization except weight decay is applied.

\paragraph{Vision Transformer.} 
ViT \cite{dosovitskiy2020image} successfully introduces Transformers from natural language processing to computer vision, achieving excellent performance on several visual benchmarks compared to CNNs. In this paper, we follow the training recipe of DeiT \cite{touvron2020training}, which successfully trains ViT on ImageNet without any external data, and set \emph{DeiT-S} (with \app22 million parameters) as the default Transformer architecture. Specifically, we train all Transformers using AdamW optimizer \cite{loshchilov2017decoupled}; we set the initial learning rate to 5e-4, and apply the cosine learning rate scheduler to decrease it; besides weight decay, we additionally adopt three data augmentation strategies (\ie, RandAug \cite{Cubuk2019}, MixUp \cite{Zhang2017a} and CutMix \cite{yun2019CutMix}) to regularize training (otherwise DeiT-S will attain significantly lower ImageNet accuracy due to overfitting \cite{chen2021vision}).

Note that different from the standard recipe of DeiT (which applies 300 training epochs by default), we hereby train Transformers only for a total of 100 epochs, \ie, same as the setup in ResNet. We also remove \{Erasing, Stochastic Depth, Repeated Augmentation\}, which were applied in the original DeiT framework, in this basic 100 epoch schedule, for preventing over-regularization in training. Such trained DeiT-S yields 76.8\% top-1 ImageNet accuracy, which is similar to the ResNet-50's performance (76.9\% top-1 ImageNet accuracy).

\subsection{Robustness Evaluations}
Our experiments mainly consider two types of robustness here, \ie,  robustness on adversarial examples and robustness on out-of-distribution samples. 

\textbf{Adversarial Examples}, which are crafted by adding human-imperceptible perturbations or small-sized patches to images, can lead deep neural networks to make wrong predictions. In addition to the very popular PGD attack \cite{Madry2018}, our robustness evaluation suite also contains: A) AutoAttack \cite{croce2020reliable}, which is an ensemble of diverse attacks (\ie, two variants of PGD attack, FAB attack \cite{croce2020minimally} and Square Attack \cite{andriushchenko2020square}) and is parameter-free; and B) Texture Patch Attack (TPA) \cite{yang2020patchattack}, which uses a predefined texture dictionary of patches to fool deep neural networks. 

Recently, several benchmarks of \textbf{out-of-distribution samples} have been proposed to  evaluate how deep neural networks perform when testing out of the box. Particularly, our robustness evaluation suite contains three such benchmarks: A) ImageNet-A \cite{hendrycks2021nae}, which are real-world images but are collected from challenging recognition scenarios (\eg, occlusion, fog scene); B) ImageNet-C \cite{Hendrycks2018}, which is designed for measuring model robustness against 75 distinct common image corruptions; and C) Stylized-ImageNet \cite{Geirhos2018}, which creates texture-shape cue conflicting stimuli by removing local texture cues from images while retaining their global shape information.



\section{Adversarial Robustness}
\label{sec:adv_robustness}
In this section, we investigate the robustness of Transformers and CNNs on defending against adversarial attacks, using ImageNet validation set (with 50,000 images). We consider both perturbation-based attacks (\ie, PGD and AutoAttack) and patch-based attacks (\ie, TPA) for robustness evaluations.

\subsection{Robustness to Perturbation-Based Attacks}
Following \cite{shao2021adversarial}, we first report the robustness of ResNet-50 and DeiT-S on defending against AutoAttack. We verify that, when applying with a small perturbation radius $\epsilon$ = 0.001, DeiT-S indeed achieves higher robustness than ResNet-50, \ie, 22.1\% \vs 17.8\% as shown in Table \ref{fig:cleanautoattack}.

However, when increasing the perturbation radius to 4/255, a more challenging but standard case studied in previous works \cite{ali2019free_adv_train,wong2020fast,xie2020smooth}, \emph{both models will be circumvented completely}, \ie, 0\% robustness on defending against AutoAttack. This is mainly due to that both models are not adversarially trained \cite{Goodfellow2015,Madry2018}, which is an effective way to secure model robustness against adversarial attacks, and we will study it next.


\begin{table}[h!]
\caption{Performance of ResNet-50 and DeiT-S on defending against AutoAttack, using ImageNet validation set. We note both models are completely broken  when setting perturbation radius to 4/255.}
\centering
\footnotesize
\begin{tabular}{c|c|c|c}
\shline
                     & \multirow{2}{*}{Clean}                & \multicolumn{2}{c}{Perturbation Radius}                                              \\ \cline{3-4}
                     &                   & 0.001                &   4/255                   \\ \shline
ResNet-50            &     76.9                 &      17.8                &      0.0                                  \\ DeiT-S     &  76.8   &           22.1            &                     0.0            \\ \hline
\end{tabular}
\label{fig:cleanautoattack}
\end{table}



\subsubsection{Adversarial Training} 
Adversarial training \cite{Goodfellow2015,Madry2018}, which trains models with adversarial examples that are generated on-the-fly, aims to optimize the following min-max framework:
\begin{align}
\label{eq:adv_training}
\argmin_{\theta}
\mathbb{E}_{(x, y) \sim \mathbb{D}}
\Bigl[ 
\max_{\epsilon \in \mathbb{S}}
L(\theta, x + \epsilon, y)
\Bigr],
\end{align}
where $\mathbb{D}$ is the underlying data distribution,  $L(\cdot, \cdot, \cdot)$ is the loss function, $\theta$ is the network parameter, $x$ is a training sample with the ground-truth label $y$, $\epsilon$ is the added adversarial perturbation, and $\mathbb{S}$ is the allowed perturbation range.  Following \cite{Xie2019a,wong2020fast}, the adversarial training here applies \emph{single-step PGD} (PGD-1) to generate adversarial examples (for lowering training cost), with the constrain that maximum per-pixel change $\epsilon=4/255$.

\paragraph{Adversarial Training on Transformers.} We apply the setup above to adversarially train both ResNet-50 and DeiT-S. However, surprisingly, this default setup works for ResNet-50 but will collapse the training with DeiT-S, \ie, the robustness of such trained DeiT-S is merely \app4\% when evaluating against PGD-5. We identify the issue is over-regularization---when combining strong data augmentation strategies (\ie, RangAug, Mixup and CutMix) with adversarial attacks, the yielded training samples are too hard to be learnt by DeiT-S. 


\begin{figure}[h!]
\centering
    \subfigure[Epoch = 0]{
    \includegraphics[width=0.27\textwidth]{66_1.jpg}}
    \subfigure[Epoch = 4]{
    \includegraphics[width=0.27\textwidth]{66_2.jpg}}
    \subfigure[Epoch = 9]{
    \includegraphics[width=0.27\textwidth]{66_3.jpg}}
\caption{The illustration of the proposed augmentation warm-up strategy.  At the beginning of adversarial training (from epoch=0 to epoch=9), we progressively increase the augmentation strength.}
    \label{fig:warmupaug}
\end{figure}


To ease this observed training difficulty, we design a curriculum of the applied augmentation strategies. Specifically, as shown in  Figure \ref{fig:warmupaug}, at the first 10 epoch, we progressively enhance the augmentation strength (\eg, gradually changing the distortion magnitudes in RandAug from 1 to 9) to warm-up the training process. Our experiment verifies this curriculum enables a successful adversarial training---DeiT-S now attains \app44\% robustness (boosted from \app4\%) on defending against PGD-5.

\paragraph{Transformers with CNNs' Training Recipes.}
Interestingly, an alternative way to address the observed training difficulty is directly adopting CNN's recipes to train Transformers \cite{shao2021adversarial}, \ie, applying M-SGD with step decay learning rate scheduler and removing strong data augmentation strategies (like Mixup). Though this setup can stabilize the adversarial training process, it significantly hurts the overall performance of DeiT-S---the clean accuracy drops to 59.9\% (\textbf{-6.6\%}), and the robustness on defending against PGD-100 drops to 31.9\% (\textbf{-8.4\%}). 

One reason for this degenerated performance is that strong data augmentation strategies are not included in CNNs' recipes, therefore Transformers will be easily overfitted during training \cite{chen2021vision}. 
Another key factor here is the incompatibility between the SGD optimizer and Transformers. As explained in \cite{liu2020understanding}, compared to SGD, adaptive optimizers (like AdamW) are capable of assigning different learning rates to different parameters, resulting in consistent update magnitudes even with unbalanced gradients. This property is crucial for enabling successful training of Transformers, given the gradients of attention modules are highly unbalanced. 

\paragraph{CNNs with Transformers' Training Recipes.}
As shown in Table \ref{tab:activation}, adversarially trained ResNet-50 is less robust than adversarially trained DeiT-S, \ie, 32.26\% \vs 40.32\% on defending against PGD-100. It motivates us to explore whether adopting Transformers' training recipes to CNNs can enhance CNNs' adversarial training.  Interestingly, if we directly apply AdamW to ResNet-50, the adversarial training will collapses. We also explore the possibility of adversarially training ResNet-50 with strong data augmentation strategies (\ie, RandAug, Mixup and CutMix). However, we find ResNet-50 will be overly regularized in adversarial training, leading to very unstable training process, sometimes may even collapse completely.

Though Transformers' optimizer and augmentation strategies cannot improve CNNs' adversarial training, we find \emph{Transformers' choice of activation functions matters}. Unlike the widely-used activation function in CNNs is ReLU, Transformers by default use GELU \cite{hendrycks2016gaussian}. As suggested in \cite{xie2020smooth}, ReLU significantly weakens adversarial training due to its non-smooth nature; replacing ReLU with its smooth approximations (\eg, GELU, SoftPlus) can strengthen adversarial training. We verify that by replacing ReLU with Transformers' activation function (\ie, GELU) in ResNet-50. As shown in Table \ref{tab:activation}, adversarial training now can be significantly enhanced, \ie,  ResNet-50 + GELU  substantially outperforms its ReLU counterpart  by 8.01\% on defending against PGD-100. Moreover, we note the usage of GELU enables ResNet-50 to match DeiT-S in adversarial robustness, \ie, 40.27\% \vs 40.32\% for defending against PGD-100, and 35.51\% \vs 35.50\% for defending against AutoAttack, \emph{challenging the previous conclusions \cite{bhojanapalli2021understanding,shao2021adversarial}  that Transformers are more robust than CNNs on defending against adversarial attacks}. 


\setlength{\tabcolsep}{3pt}
\begin{table}[!ht]
\vspace{-0.25em}
\caption{The performance of ResNet-50 and DeiT-S on defending against adversarial attacks (with $\epsilon=4$). After replacing ReLU with DeiT's activation function GELU in ResNet-50, its robustness can match the robustness of DeiT-S.} 
\footnotesize
\centering
\begin{tabular}{c|c|c|c|c|c|c|c}
\shline
                            & Activation & Clean Acc & PGD-5 & PGD-10 & PGD-50 &PGD-100 & AutoAttack \\ \shline
\multirow{2}{*}{ResNet-50}  & ReLU    &    66.77  &  38.70    &   34.19    &   32.47     &   32.26 & 26.41   \\ 
                            & GELU     &   67.38     &   44.01         &   40.98         &   40.28       & 40.27    & 35.51   \\ \hline
DeiT-S & GELU      & 66.50       &   43.95    &   41.03     &   40.34     &  40.32 & 35.50 \\ \hline
\end{tabular}
\label{tab:activation}
\end{table}



\subsection{Robustness to Patch-Based Attacks} 
We next study the robustness of CNNs and Transformers on defending against patch-based attacks. We choose Texture Patch Attack (TPA) \cite{yang2020patchattack} as the attacker. Note that different from typical patch-based attacks which apply monochrome patches, TPA additionally optimizes the pattern of the patches to enhance attack strength. By default, we set the number of attacking patches to 4, limit the largest manipulated area to 10\% of the whole image area, and set the attack mode as the non-targeted attack. For ResNet-50 and DeiT-S, we do not consider adversarial training here as their vanilla counterparts already demonstrate non-trivial performance on defending against TPA.


\begin{table}[!b]
\vspace{-1.25em}
\caption{Performance of ResNet-50 and DeiT-S on defending against Texture Patch Attack.} 
\footnotesize
\centering
\begin{tabular}{c|c|c}
\shline
Architecture & Clean Acc & Texture Patch Attack \\ \hline
ResNet-50                     &     76.9            &    19.7            \\ 
DeiT-S                    &      76.8              &   \textbf{47.7}              \\ \hline
\end{tabular}
\label{tab:patchattack}
\end{table}



Interestingly, as shown in Table \ref{tab:patchattack}, though both models attain similar clean image accuracy, DeiT-S substantially outperforms ResNet-50 by 28\% on defending against TPA. We conjecture such huge performance gap is originated from the differences in training setups; more specifically, it may be resulted by the fact DeiT-S by default use strong data augmentation strategies while ResNet-50 use none of them. The augmentation strategies like CutMix already na\"ively introduce occlusion or image/patch mixing during training, therefore are potentially helpful for securing model robustness against patch-based adversarial attacks.

To verify the hypothesis above, we next ablate how strong augmentation strategies in DeiT-S (\ie, RandAug, Mixup and CutMix) affect ResNet-50's robustness. We report the results in Table \ref{tab:ResNetpatchattack}. Firstly, we note all augmentation strategies can help ResNet-50 achieve stronger TPA robustness, with improvements ranging from +4.6\% to +32.7\%. Among all these augmentation strategies, CutMix stands as the most effective one to secure model's TPA robustness, \ie, CutMix alone can improve TPA robustness by 29.4\%. Our best model is obtained by using both CutMix and RandAug, reporting 52.4\% TPA robustness, which is even stronger than DeiT-S (47.7\% TPA robustness). This observation still holds by using stronger TPA with 10 patches (increased from 4), \ie, ResNet-50 now attains 34.5\% TPA robustness, outperforming DeiT-S by 5.6\%.  \emph{These results suggest that Transformers are also no more robust than CNNs on defending against patch-based adversarial attacks}.


\begin{table}[h]
\vspace{-0.3em}
\caption{Performance of ResNet-50 trained with different augmentation strategies on defending against Texture Patch Attack. We note 1) all augmentation strategies can improve model robustness, and 2) CutMix is the most effective augmentation strategy to secure model robustness.}
\footnotesize
\centering
\begin{tabular}{ccc|c|c}
\shline
\multicolumn{3}{c|}{Augmentations} & \multirow{2}{*}{Clean Acc} & \multirow{2}{*}{Texture Patch Attack} \\ \cline{1-3}
RandAug      & MixUp      & CutMix      &                           &                               \\ \shline
\xmarkg        &    \xmarkg        &     \xmarkg        & 76.9                     & 19.7                         \\ \hline
\cmark         &      \xmarkg      &     \xmarkg        & 77.5                     & 24.3 \textcolor{red}{(+4.6)}                         \\ 
 \xmarkg        &\cmark            &     \xmarkg        & 75.9                     & 31.5 \textcolor{red}{(+11.8)}                        \\ 
   \xmarkg      &     \xmarkg       &\cmark             & 77.2                     & 49.1 \textcolor{red}{(+29.4)}                        \\ \hline
\cmark         &    \cmark        &    \xmarkg         & 75.7                     & 31.7 \textcolor{red}{(+12.0)}                        \\ 
\cmark         &    \xmarkg        &  \cmark           & 76.7                     & \textbf{52.4} \textbf{\textcolor{red}{(+32.7)}}                        \\ 
 \xmarkg        &\cmark            &\cmark             & 77.1                     & 39.8 \textcolor{red}{(+20.1)}                        \\ \hline
\cmark         &     \cmark       &    \cmark         & 76.4                    & 48.6 \textcolor{red}{(+28.9)}                        \\ \hline
\end{tabular}
\vspace{-0.4em}
\label{tab:ResNetpatchattack}
\end{table}




\section{Robustness on Out-of-distribution Samples}
In addition to adversarial robustness, we are also interested in comparing the robustness of CNNs and Transformers on out-of-distribution samples. We hereby select three datasets, \ie, ImageNet-A, ImageNet-C and Stylized ImageNet, to capture the different aspects of out-of-distribution robustness.

\subsection{Aligning Training Recipes}
\label{sec:gene:align}
We first provide a direct comparison between ResNet-50 and DeiT-S with their default training setup. As shown in Table \ref{exp:orisetting}, we observe that, \emph{even without pretraining on (external) large scale datasets},  DeiT-S still significantly outperforms ResNet-50 on ImageNet-A (+9.0\%), ImageNet-C (+9.9) and Stylized-ImageNet (+4.7\%). It is possible that such performance gap is caused by the differences in training recipes (similar to the situation we observed in Section \ref{sec:adv_robustness}), 
which we plan to ablate next.


\begin{table}[h!]
\vspace{-0.3em}
\caption{DeiT-S shows stronger robustness generalization than ResNet-50 on ImageNet-C, ImageNet-A and Stylized-ImageNet. Note the results on ImageNet-C is measured by mCE (lower is better). }
\footnotesize
\centering
\begin{tabular}{c|c|c|c|c}
\shline
 Architecture & ImageNet \textcolor{red}{$\uparrow$} & ImageNet-A \textcolor{red}{$\uparrow$}& ImageNet-C \textcolor{red}{$\downarrow$}& Stylized-ImageNet \textcolor{red}{$\uparrow$} \\ \shline 
ResNet-50  &  76.9        &   3.2        &    57.9       &    8.3     \\ 

 ResNet-50*  &   76.3     &    4.5        &     55.6       &      8.2     \\ \hline 
 DeiT-S &  76.8        &   \textbf{12.2}         &     \textbf{48.0}       &   \textbf{13.0}    \\ \hline 
\end{tabular}
\label{exp:orisetting}
\vspace{-0.2em}
\end{table}



\paragraph{A fully aligned version.}
A simple baseline here is that we completely adopt the recipes of DeiT-S to train ResNet-50, denoted as ResNet-50*. Specifically, this ResNet-50* will be trained with AdamW optimizer, cosine learning rate scheduler and strong data augmentation strategies. Nonetheless, as reported in Table \ref{exp:orisetting}, ResNet-50* only marginally improves ResNet-50 on ImageNet-A (+1.3\%) and ImageNet-C (+2.3), which is still much worse than DeiT-S on robustness generalization.

It is possible that completely adopting the recipes of DeiT-S overly regularizes the training of ResNet-50, leading to suboptimal performance. To this end, we next seek to discover the ``best'' setups to train ResNet-50, by ablating learning rate scheduler (step decay \vs cosine decay), optimizer (M-SGD \vs AdamW) and augmentation strategies (RandAug, Mixup and CutMix) progressively.

\paragraph{Step 1: aligning learning rate scheduler.} 
It is known that switching learning rate scheduler from step decay to cosine decay improves model accuracy on clean images \cite{bello2021revisiting}. We additionally verify that such trained ResNet-50 (second row in Table \ref{tab:optimizer}) attains slightly better performance on ImageNet-A (+0.1\%), ImageNet-C (+1.0) and Stylized-ImageNet (+0.1\%). Given the improvements here, we will use cosine decay by default for later ResNet training.


\paragraph{Step 2: aligning optimizer.} 
We next ablate the effects of optimizers. As shown in the third row in Table \ref{tab:optimizer}, switching optimizer from M-SGD to AdamW weakens ResNet training, \ie, it not only decreases ResNet-50's accuracy on ImageNet (-1.0\%), but also hurts ResNet-50's robustness generalization on ImageNet-A (-0.2\%), ImageNet-C (-2.4) and Stylized-ImageNet (-0.3\%). Given this degenerated performance, we stick to M-SGD for later ResNet-training.


\begin{table}[!ht]
\caption{The robustness generalization of ResNet-50 trained with different learning rate schedulers and optimizers. Nonetheless, compared to DeiT-S, all the resulted ResNet-50 show worse generalization on out-of-distribution samples.}
\footnotesize
\centering
\begin{tabular}{c|c|c|c|c|c}
\shline
                            & Optimizer-LR Scheduler & ImageNet \textcolor{red}{$\uparrow$}& ImageNet-A \textcolor{red}{$\uparrow$} & ImageNet-C \textcolor{red}{$\downarrow$}& Stylized-ImageNet \textcolor{red}{$\uparrow$}\\ \shline \multirow{3}{*}{ResNet-50}  & SGD-Step       &   76.9        &   3.2        &    57.9       &    8.3     \\ 
                            & SGD-Cosine       &   77.4      &   3.3      &    56.9       &    8.4    \\ 
                            & AdamW-Cosine     &    76.4      &    3.1        &     59.3       &     8.1    \\ \hline 
DeiT-S & AdamW-Cosine     &  76.8        &  \textbf{12.2}         &   \textbf{48.0}        &     \textbf{13.0}     \\ \hline 
\end{tabular}
\label{tab:optimizer}
\end{table}



\paragraph{Step 3: aligning augmentation strategies.} 
Compared to ResNet-50, DeiT-S additionally applied RandAug, Mixup and CutMix to augment training data. We hereby examine whether these augmentation strategies affect robustness generalization. The performance of ResNet-50 trained with different combinations of augmentation strategies is reported in Table \ref{tab:cleanaug}. Compared to the vanilla counterpart, nearly all the combinations of augmentation strategies can improve ResNet-50's generalization on out-of-distribution samples. The best performance is achieved by using RandAug + Mixup, outperforming the vanilla ResNet-50 by 3.0\% on ImageNet-A, 4.6 on ImageNet-C and 2.4\% on Stylized-ImageNet. 


\setlength{\tabcolsep}{3pt}
\begin{table}[!ht]
\caption{The robustness generalization of ResNet-50 trained with different combinations of augmentation strategies. We note applying RandAug + Mixup yields the best ResNet-50 on out-of-distribution samples; nonetheless, DeiT-S still significantly outperforms such trained ResNet-50.}
\footnotesize
\centering
\begin{tabular}{c|ccc|c|c|c|c}
\shline
\multirow{2}{*}{Architecture} & \multicolumn{3}{c|}{Augmentation Strategies}      & \multirow{2}{*}{ImageNet \textcolor{red}{$\uparrow$}} & \multirow{2}{*}{ImageNet-A \textcolor{red}{$\uparrow$}}& \multirow{2}{*}{ImageNet-C \textcolor{red}{$\downarrow$}}& \multirow{2}{*}{Stylized-ImageNet\textcolor{red}{$\uparrow$}}\\ \cline{2-4} 
& RandAug & MixUp & CutMix &&&& \\ \shline
 \multirow{5}{*}{ResNet-50}   & \xmarkg  & \xmarkg& \xmarkg& 77.4      &   3.3      &    56.9       &    8.4    \\ 
   & \cmark & \cmark&\xmarkg        &    75.7        &     \textbf{6.3}       &   \textbf{52.3 }        &  \textbf{10.8}  \\ 
  & \cmark&\xmarkg &\cmark         &    76.7        &   6.3         & 56.3           & 7.1 \\ 
&\xmarkg &\cmark&\cmark         &  77.1          &      6.1      &    55.1       &  8.8 \\
 & \cmark &\cmark&\cmark        &    76.4        &     5.5       &   54.0       &     9.1 \\ 
 \hline     
DeiT-S & \cmark&\cmark&\cmark  &  \textbf{76.8}        &   \textbf{12.2}         &     \textbf{48.0}       &  \textbf{ 13.0} \\ \hline
\end{tabular}
\label{tab:cleanaug}
\end{table}



\paragraph{Comparing ResNet with the ``best'' training recipes to DeiT-S.}
With the ablations above, we can conclude that the ``best'' training recipes for ResNet-50 (denoted as ResNet-50-Best) is by applying M-SGD optimizer, scheduling learning rate using cosine decay, and augmenting training data using RandAug and Mixup. As shown in the second row of Table \ref{tab:cleanaug}, ResNet-50-Best attains 6.3\% accuracy on ImageNet-A, 52.3 mCE on ImageNet-C and 10.8\% accuracy on Stylized-ImageNet.

Nonetheless, interestingly, we note DeiT-S still shows much stronger robustness generalization on out-of-distribution samples than our ``best'' ResNet-50, \ie,  +5.9\% on ImageNet-A, +4.3 on ImageNet-C and +2.2\% on Stylized-ImageNet. \emph{These results suggest that the differences in training recipes (including the choice of optimizer, learning rate scheduler and augmentation strategies) is not the key for leading the observed huge performance gap between CNNs and Transformers on out-of-distribution samples}. 

\paragraph{Model size.}  
To further validate that Transformers are indeed more robust than CNNs on out-of-distribution samples, we hereby extend the comparisons above to other model sizes. Specifically, we consider the comparison at a smaller scale, \ie ResNet-18 (\app12 million parameters) \vs DeiT-Mini (\app 10 million parameters, with embedding dimension = 256 and number of head = 4). For ResNet training, we consider both the fully aligned recipe version (denoted as ResNet*) and the ``best'' recipe version (denoted as ResNet-Best). Figure \ref{fig:trend}  shows the main results. Similar to the comparison between ResNet-50 and DeiT-S, DeiT-Mini also demonstrates much stronger robustness generalization than ResNet-18* and ResNet-18-Best. 

We next study DeiT and ResNet at a more challenging setting---comparing DeiT to a much larger ResNet on robustness generalization. Surprisingly, we note in both cases, DeiT-Mini \vs ResNet-50 and DeiT-S \vs ResNet-101, DeiTs are able to show similar, sometimes even superior, performance than ResNets. For example, DeiT-S beats the nearly $2\times$ larger ResNet-101* (\app22 million parameters \vs \app45 million parameters) by 3.37\% on ImageNet-A, 1.20 on ImageNet-C and 1.38\% on Stylized-ImageNet. All these results further corroborate that Transformers are much more robust than CNNs on out-of-distribution samples. 


\begin{figure}[!ht]
\centering
\vspace{-0.3em}
\subfigure[ImageNet-A]{
\includegraphics[width=0.32\textwidth]{a_3.pdf}}
    \subfigure[ImageNet-C]{
\includegraphics[width=0.32\textwidth]{c_2.pdf}}
    \subfigure[Stylized-ImageNet]{
\includegraphics[width=0.32\textwidth]{b_2.pdf}}
    \vspace{-0.3em}
    \caption{By comparing models at different scales, DeiT consistently outperforms ResNet* and ResNet-Best by a large margin on ImageNet-A, ImageNet-C and Stylized-ImageNet.}
    \label{fig:trend}
\end{figure}



\subsection{Distillation} 
\label{sec:distill}
In this section, we make another attempt to bridge the robustness generalization gap between CNNs and Transformers---we apply knowledge distillation to let ResNet-50 (student model) directly learn from DeiT-S (teacher model). Specifically, we perform soft distillation \cite{hinton2015distilling}, which minimizes the Kullback-Leibler divergence between the softmax of the teacher model and the softmax of the student model; we adopt the training recipe of DeiT during distillation.

\paragraph{Main results.} 
We report the distillation results in Table \ref{tab:distillation}. Though both models attain similar clean image accuracy, the student model ResNet-50 shows much worse robustness generalization than the teacher model DeiT-S, \ie, the performance is decreased by 7.0\% on ImageNet-A, 6.2 on ImageNet-C and 3.2\% on Stylized-ImageNet. This observation is counter-intuitive  as student models typically achieve higher performance than teacher models in  knowledge distillation.

However, interestingly, if we switch the roles of DeiT-S and ResNet-50, the student model DeiT-S is able to significantly outperforms the teacher model ResNet-50 on out-of-distribution samples. As shown in the third row and the fourth row in  Table \ref{tab:distillation}, the improvements are 6.4\% on ImageNet-A, 6.3 on ImageNet-C and 3.7\% on Stylized-ImageNet. \emph{These results arguably suggest that the strong generalization robustness of DeiT is rooted in the architecture design of Transformer that cannot be transferred to ResNet via neither training setups or knowledge distillation}.


\begin{table}[!ht]
\vspace{-0.3em}
\caption{The robustness generalization of ResNet-50, DeiT-S and their distilled models.}
\footnotesize
\centering
\begin{tabular}{c|c|c|c|c|c}
\shline
 Distillation & Architecture & ImageNet \textcolor{red}{$\uparrow$}& ImageNet-A \textcolor{red}{$\uparrow$}& ImageNet-C \textcolor{red}{$\downarrow$}& Stylized-ImageNet \textcolor{red}{$\uparrow$}\\ \shline
 Teacher & DeiT-S &  76.8        &   12.2         &     48.0       &   13.0           \\  
  Student & ResNet-50*-Distill  &   76.7     &    5.2 (\textcolor{blue}{-7.0})        &   54.2  (\textcolor{blue}{+6.2})     &      9.8 (\textcolor{blue}{-3.2})     \\ 
  \shline
 Teacher & ResNet-50*  &   76.3     &    4.5        &     55.6       &      8.2       \\  
 Student & DeiT-S-Distill &  76.2       &   10.9 (\textcolor{red}{+6.4})         &     49.3 (\textcolor{red}{-6.3})      &   11.9 (\textcolor{red}{+3.7})     \\
 \hline
\end{tabular}
\label{tab:distillation}
\end{table}



\subsection{Hybrid Architecture} 
Following the discussion in Section \ref{sec:distill}, we hereby ablate whether incorporating Transformer's self-attention-like architecture into model design can help robustness generalization. Specifically, we create a hybrid architecture (named Hybrid-DeiT) by directly feeding the output of res\_4 block in ResNet-18 into DeiT-Mini, and compare its robustness generalization to ResNet-50 and DeiT-Small. Note that under this setting, these three models are at the same scale, \ie, hybrid-DeiT (\app 21 million parameters) \vs ResNet-50 (\app 25 million parameters) \vs DeiT-S (\app 22 million parameters). We apply the recipe of DeiT to train these three models.

\paragraph{Main results.}
We report the robustness generalization of these three models in Figure \ref{fig:hybrid}. Interestingly, with the introduction of Transformer blocks, Hybrid-DeiT is able to achieve better robustness generalization than ResNet-50, \ie, +1.1\% on ImageNet-A and +2.5\% on Stylized-ImageNet, \emph{suggesting Transformer's self-attention-like architectures is essential for boosting performance on out-of-distribution samples}. We additionally compare this hybrid architecture to the pure Transformer architecture. As expected, Hybrid-DeiT attains lower robustness generalization than DeiT-S, as shown in Figure \ref{fig:hybrid}.


\begin{figure}[h!]
\centering
\vspace{-0.3em}
\subfigure[ImageNet-A]{
\includegraphics[width=0.32\textwidth]{hybrid_a.pdf}}
    \subfigure[ImageNet-C]{
\includegraphics[width=0.32\textwidth]{hybrid_c.pdf}}
    \subfigure[Stylized-ImageNet]{
\includegraphics[width=0.32\textwidth]{hybrid_b.pdf}}
\vspace{-0.5em}
    \caption{The robustness generalization of ResNet-50, DeiT-S and Hybrid-DeiT. We note introducing Transformer blocks into model design benefits generalization on out-of-distribution samples.}
    \label{fig:hybrid}
    \vspace{-0.2em}
\end{figure}



\subsection{300-Epoch Training}
As mentioned in Section \ref{sec:settings:vit}, we by default train all models for only 100 epochs. This is a standard setup in training CNNs \cite{goyal2017accurate,radosavovic2020designing}, but not typical in training Transformers \cite{pmlr-v139-touvron21a,liu2021swin}. To rule out the possibility of introducing negative effects in shortening training length, we lastly ablate the 300-epoch setup, \ie, we directly borrow the default  setup in \cite{pmlr-v139-touvron21a} to train both ResNet and DeiT.

As reported in Table \ref{tab:same}, DeiT-S substantially outperforms ResNet-50 by 10.4\% on ImageNet-A, 7.5 on ImageNet-C and 5.6 on Stylized-ImageNet. Nonetheless, we argue that such comparison is less interesting and even unfair---DeiT-S already beats ResNet-50 by 1.8\% on ImageNet classification, therefore it is expected that DeiT-S will also show stronger performance than ResNet-50 on ImageNet-A, ImageNet-C and Stylized-ImageNet.


\begin{table}[!ht]
\footnotesize
\centering
\vspace{-0.4em}
\caption{The robustness generalization of ResNet-50 and DeiT-S under the 300-epoch training setup. We note DeiT-S shows stronger performance than ResNet-50 on both clean images and out-of-distribution samples.}
\begin{tabular}{c|c|c|c|c}
\shline
 Architecture & ImageNet \textcolor{red}{$\uparrow$} & ImageNet-A \textcolor{red}{$\uparrow$}& ImageNet-C \textcolor{red}{$\downarrow$}& Stylized-ImageNet \textcolor{red}{$\uparrow$}\\ 
 \shline
 ResNet-50  &  78.1	& 8.8	& 50.3	& 9.5   \\  
 DeiT-S &  79.9	& \textbf{19.2} & 	\textbf{42.8} & 	\textbf{15.1}    \\ \hline 
\end{tabular}
\vspace{-0.1em}
\label{tab:same}
\end{table}



To make the setup fairer (\ie, comparing the robustness of models that have similar accuracy), we now compare DeiT-S to the much larger ResNet-101 (\ie, \app22 million parameters \vs \app45 million parameters). The results are shown in Table \ref{tab:scaleacc}. We observer that though both models achieve similar accuracy on ImageNet, DeiT-S demonstrates much stronger robustness generalization than ResNet-101. This observation can also holds for bigger Transformers and CNNs, \eg, DeiT-B can consistently outperforms ResNet-200 on ImageNet-A, ImageNet-C and Stylized- ImageNet, despite they attain similar clean image accuracy (\ie, 81.8\% \vs 82.1\%). 


\begin{table}[!ht]
\caption{The robustness generalization of ResNet and DeiT under the 300-epoch training setup. Though both models attain similar clean image accuracy, DeiTs show much stronger robustness generalization than ResNets.}
\footnotesize
\centering
\begin{tabular}{c|c|c|c|c}
\shline
 Architecture & ImageNet \textcolor{red}{$\uparrow$} & ImageNet-A \textcolor{red}{$\uparrow$}& ImageNet-C \textcolor{red}{$\downarrow$}& Stylized-ImageNet \textcolor{red}{$\uparrow$}\\ \shline 
ResNet-101	  &  80.2 &	17.6&	45.8&	11.9  \\ 

 DeiT-S &  79.9	& \textbf{19.2} &	\textbf{42.8} &	\textbf{15.1}    \\ \shline 

ResNet-200	  &  82.1 &	23.8 &	40.8 &	13.6 \\ 

 DeiT-B &  81.8 &	\textbf{27.9} &	\textbf{38.0} &	\textbf{17.9}    \\ \hline 
\end{tabular}
\vspace{-1em}
\label{tab:scaleacc}
\end{table}



In summary, in this 300 training epoch setup, we can draw the same conclusion as the 100-epoch setup, \ie, Transformers are truly much more robust than CNNs on out-of-distribution samples.



\section{Conclusion}
With the recent success of Transformer in visual recognition, researchers begin to study its robustness compared with CNNs. While recent works suggest that Transformers are much more robust than CNNs, their comparisons are not fair in many aspects, \eg, training datasets, model scales, training strategies, \etc. This motivates us to provide a fair and in-depth comparisons between CNNs and Transformers, focusing on adversarial robustness and robustness on out-of-distribution samples. With our unified training setup, we found that Transformers are no more robust than CNNs on adversarial robustness. By properly adopting Transformer's training recipes, CNNs can achieve similar robustness as Transformers on defending against both perturbation-based adversarial attacks and patch-based adversarial attacks. While regarding generalization on out-of-distribution samples (\eg, ImageNet-A, ImageNet-C and Stylized ImageNet), we find Transformer's self-attention-like architectures is the key.  We hope this work would shed lights on the understanding of Transformer, and help the community to fairly compare robustness between Transformers and CNNs.



\section*{Acknowledgements}
This work was partially supported by the ONR N00014-20-1-2206, ONR N00014-18-1-2119 and Institute for Assured Autonomy at JHU with Grant IAA 80052272. Cihang Xie was supported by a gift grant from Open Philanthropy. 



\bibliographystyle{plain}

{\footnotesize
	\bibliography{egbib}
}
\end{document}
