

\documentclass[preprint,authoryear,12pt]{elsarticle}







\usepackage{amssymb}
\usepackage{amsmath}

\usepackage{psfrag}












\DeclareMathOperator{\cost}{cost} \DeclareMathOperator{\dist}{dist}
\newcommand{\floor}[1]{\lfloor #1 \rfloor}
\newcommand{\ceil}[1]{\lceil #1 \rceil}
\newcommand{\abs}[1]{\lvert #1 \rvert}
\newcommand{\norm}[1]{\lVert #1 \rVert}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newproof{proof}{Proof}


\journal{Computational Geometry: Theory and Applications}

\begin{document}

\begin{frontmatter}





\title{Integer Point Sets Minimizing Average Pairwise
  ~Distance:
What is the Optimal Shape of a Town?}



\author[MIT]{Erik D. Demaine}
\author[TUBS]{S\'andor P. Fekete}
\author[FUB]{G\"{u}nter Rote}
\author[TUBS]{Nils Schweer}
\author[FUB]{\hspace{.45cm}Daria Schymura}
\author[GUF]{Mariano Zelke}

\address[MIT]{Computer Science and Artificial Intelligence Lab, MIT, USA.}
\address[TUBS]{Algorithms Group, Braunschweig University of Technology, Germany.}
\address[FUB]{Institut f\"ur Informatik, Freie Universit\" at Berlin, Germany.}
\address[GUF]{Institut f\"ur Informatik, Goethe-Universit\"at, Frankfurt am Main, Germany.}


\begin{abstract}
An {\em -town}, , is a group of  buildings,
each occupying a distinct position on a 2-dimensional integer grid.
If we measure the distance between two buildings along the
axis-parallel street grid, then an -town has optimal shape if the
sum of all pairwise Manhattan distances is minimized. This problem
has been studied for {\em cities}, i.e., the limiting case of very
large . For cities, it is known that the optimal shape can be
described by a differential equation, for which no closed-form
solution
is known. We show that optimal -towns
can be computed in  time. This is also practically
useful,
as it allows us to compute optimal solutions up to . \end{abstract}

\begin{keyword}
Manhattan distance \sep average pairwise distance \sep integer
points \sep dynamic programming
\end{keyword}

\end{frontmatter}







\section{Introduction}\label{sec:introduction}
Selecting an optimal set of locations is a fundamental problem, not
just in real estate, but also in many areas of computer science.
Typically, the task is to choose  sites from a given set
of candidate locations; the objective is to pick a set that minimizes
a cost function, e.g., the average distance
between sites. As described below, there is a large variety of related results,
motivated by different scenarios.

In general, problems of this type are hard, even
to approximate, as the problem of finding a clique of given size is a special case. Some of the
natural settings have a strong geometric flavor, so it is conceivable
that more positive results can be achieved by exploiting additional
structures and properties.
However, even seemingly easy
special cases are still surprisingly difficult. Until now, there was no
complexity result (positive or negative) for the scenario in which
the candidate locations correspond to the full integer grid, with distances measured
by the Manhattan metric (an \emph{-town}).
Indeed, for the shape of area~1 with minimum
average  distance (the ``optimal shape of a city'', arising
for the limit case of  approaching infinity), no simple
closed-form solution is known, suggesting that finding sets of  distinct
grid points (the ``optimal shapes of towns'') may not be an easy task.
This makes the problem mathematically challenging; in addition,
the question of choosing  grid positions with minimum
average  distance comes up naturally in grid computing, so
the problem is of both practical and theoretical interest.

In this paper, we give the first positive result by describing
an  algorithm for computing sets of  distinct grid points
with minimum average  distance. Our method is based on dynamic programming,
and (despite of its relatively large exponent) for the first time allows computing optimal
towns up to .

\subsection{Related Work}
\paragraph{Grid Computing}
In grid computing, allocating a task requires selecting  processors from
a given grid,
and the average communication overhead corresponds to
the average Manhattan distance between processors;
\cite{mache96,mache97} and \cite{leung02}
propose various metrics for
measuring the quality of a processor allocation, including the
average number of communication hops between processors.
\cite{leung02} considered the problem of allocating processors
 on Cplant, a Sandia National Labs
supercomputer;
they applied and evaluated a scheme
based on space-filling curves, and
 they concluded that the average pairwise Manhattan
distance between processors is an effective metric to optimize.

\paragraph{The Continuous Version}
Motivated by the problem of storing records in a 2-dimensional
array, \cite{KarpMW75} studied strategies that minimize
average access time between successive queries; among other results,
they described an optimal solution for the continuous version of our
problem: What shape of area  minimizes the average Manhattan
distance between two interior points? Independently,
\cite{Bender03whatis} solved this problem in the setting of a city,
inspiring the subtitle of this paper. The optimal solution is
described by a differential equation, and no closed-form solution is
known.


\begin{figure}[tb]
\begin{center}
  \includegraphics[width=.73\columnwidth]{smalloptsols.eps}
  \caption{Optimal towns for .  All optimal solutions
    are shown, up to symmetries; the numbers indicate the total
    distance between all pairs of points. The picture for  also
    contains the symmetry axes from Lemma~\ref{lem:symmetry}. }
\label{fig:smalltowns}
\end{center}
\end{figure}

\paragraph{Selecting  points out of }
\cite{krumke97} consider the discrete problem of selecting a subset
of  nodes from a network with  nodes to minimize their average
pairwise distance. They prove a -approximation for metric
distances and prove hardness of approximation for arbitrary
distances.
\cite{bender08} solve the geometric version
of this problem, giving an efficient processor allocator for the Cplant setting
described above, and a polynomial-time approximation scheme (PTAS) for minimizing the
average Manhattan distance.
For the reverse problem of {\em maximizing} the
average Manhattan distance, see~\cite{fm-mdgmwc-04}.


\paragraph{The -median Problem}
Given two sets  and , the -median problem asks to choose a
set of  points from  to minimize the average distance to the
points in . For  this is the classical {\em Fermat-Weber
problem}.
\cite{Fekete00,fmb-cfwp-05} considered the city-center problem: for
a given city, find a point that minimizes the average Manhattan
distance.
They proved NP-hardness for general  and
gave efficient algorithms for some special cases.

\paragraph{The Quadratic Assignment Problem}
Our problem is a special case of the quadratic assignment problem
(QAP): Given  facilities,  locations, a matrix containing the
amount of flow between any pair of facilities, and a matrix
containing the distances between any pair of locations. The task is
to assign every facility to a location such that the cost function
which is proportional to the flow between the facilities multiplied
by the distances between the locations is minimized. For a survey
see \cite{loiola07}. The cost function in our problem and in the
QAP are the same if we define the distances as the Manhattan
distances between grid points and if we define all flows to be one.
The QAP can not be approximated within any polynomial factor unless
; see~\cite{sahni76}.
\cite{hls-amqap-09}
considered the metric version of this problem with the flow matrix
being a 0/1 incidence matrix of a graph. They state some
inapproximability results as well as a constant-factor approximation
for the case in which the graph has vertex degree two for all but
one vertex.


\paragraph{The Maximum Dispersion Problem}
The reverse version of the discrete problem, where the goal is to
maximize the average distance between points, has also been studied:
In the maximization version, called the \emph{maximum dispersion
problem}, the objective is to pick  points from a set of size 
so that the pairwise distance is maximized. When the edge weights
need not obey the triangle inequality, \cite{kp-cds-93} give an -approximation. \cite{aitt-gfds-00} improve this guarantee to a constant factor in
the special case when  and \cite{akk-ptasd-99} give a PTAS when  and
.

When the edge weights obey the triangle inequality, \cite{rrt-hscad-94} give a -approximation that runs in 
time and \cite{hrt-aamd-97} give a -approximation that runs in
 time. For points in the plane and Euclidean
distances, \cite{rrt-hscad-94} give an approximation with performance bound
arbitrarily close to . For Manhattan distances,
\cite{fm-mdgmwc-04} give an optimal algorithm for fixed  and a
PTAS for general . Moreover, they provide a
-Approximation for Euclidean distances.



\paragraph{The Min-Sum -Clustering Problem}
Another related problem is called \emph{min-sum -clustering} or
\emph{minimum -clustering sum}. The goal is to separate a graph
into  clusters to minimize the sum of pairwise distances between
nodes in the same cluster.  For general graphs,
\cite{sahni76} show that this problem is NP-hard to approximate
within any constant factor for . In a metric space the
problem is easier to approximate:
\cite{guttmannbeck98} give a -approximation,
\cite{indyk99} gives a PTAS for , and
\cite{bartal01} give an
-approximation for general .


\subsection{Our Results} We solve the -town problem with an
-time dynamic-programming algorithm.
Our algorithm is based on some properties of an optimal town:
an optimal -town is \emph{convex} in the sense that it contains
all grid points within its convex hull (Lemma~\ref{lem:convex}).
It lies symmetric with respect to a horizontal and a vertical
symmetry axis within a tolerance of  that is due to parity
issues
 (Lemma~\ref{lem:symmetry}).
Furthermore, it fits in an  square
 (Lemma~\ref{bounded-width}).
 We also present
computational results and discuss the relation between
the optimum continuous cities and their discretized counterparts
(-towns, and -block cities).




\section{Properties of Optimal Towns}\label{sec:prelim}
We want to find a set of  distinct points from the integer grid
 such that the sum of all pairwise
Manhattan distances is minimized. A set  of cardinality  is an \emph{-town}. An -town
 is \emph{optimal} if its \emph{cost} 
is minimum.
Figure~\ref{fig:smalltowns} shows solutions for small  and their
cost, and Table~\ref{table:smalltowns} in Section~\ref{sec:results}
 shows optimal cost values
 for .
 We define the \emph{-cost}  as
, where  is the
-coordinate of ; \emph{-cost}  is the sum of all
-distances, and . For two
sets  and , we define . If  consists of a single point , we write
 instead of  for convenience. A town  is
\emph{convex} if the set of grid points in the convex hull of 
equals .


















In proving various properties of optimal towns, we will often make a
local modification by moving a point  of a town to a different
place~. The next lemma expresses the resulting cost change.


\begin{lemma}\label{lem:changecostfunc}
Let  be a town,  and . Then,

\end{lemma}
\begin{proof}
Let  be a point in . Then, its distance to  is 
and the distance to  is . Hence, the change in the
cost function is . We need to subtract
 from the sum over all points in  because  is
removed from~.
\qed
\end{proof}


\begin{lemma}\label{lem:convex}
An optimal -town is convex.
\end{lemma}


The following proof holds in any dimension and with any norm for measuring
the distance between points.
\begin{proof}
We prove that a nonconvex -town  cannot be optimal.
Take a grid point  in the convex hull of .
Then there are points  such that
 for some
 with . Because every norm is a convex function, and the sum of convex
functions is again convex, the function  is convex. Therefore,  which implies  for some . Using Lemma~\ref{lem:changecostfunc} we
get

This means that  is not optimal.
\qed
\end{proof}


Obviously, if we translate every point from an -town by the same
vector, the cost of the town does not change. We want to distinguish
towns because of their shape and not because of their position
inside the grid and, therefore, we will only consider optimal towns
that are placed around the origin. Lemma~\ref{lem:symmetry} makes
this more precise:
an optimal -town is roughly
symmetric with respect to a vertical and a horizontal symmetry line,
see Fig.~\ref{fig:dynamicprogram} for an illustration.
Perfect symmetry is not possible
since some rows or columns may have odd length and others even length.

We need some notation before: For an -town
, the -th \emph{column} of  is the set  and the -th \emph{row} of  is the set
.


\begin{lemma}[Symmetry]
\label{lem:symmetry}
In every optimal -town , the centers of all rows of odd length
lie on a common vertical grid line . The centers of all rows of even
length lie on a common line  that has distance  from
. A corresponding statement holds for the centers of odd and
even columns that lie on horizontal lines  and  of
distance~. Moreover, without changing its cost, we can
place  such that  and  are mapped onto the -axis and
-axis, respectively, and  and  lie in the negative
halfplanes.
\end{lemma}



\begin{proof}
For a row  and , let  be
the row  horizontally translated by . If two rows  and 
are of the same parity, a straightforward calculation
(using Lemma~\ref{lem:changecostfunc}) shows that
the cost  is minimal if
and only if the centers of  and  have the same -coordinate. If the parities differ,  is
minimized with centers having -coordinates of distance 1/2.
The total cost is

If we translate every row  of  horizontally by some
,  does not change. The solutions that minimize
 for all 
simultaneously are exactly those that align the centers of all rows
of even length on a vertical line  and the centers of all rows
of odd length on a vertical line  at offset  from
. The existence of the lines  and  follows
analogously.


We can translate  such that  and  are mapped onto the
- and the -axis and rotate it by a multiple of 
degrees such that  and  lie in the negative halfplanes.
These operations do not change . \qed
\end{proof}


{From} the convexity statement in Lemma~\ref{lem:convex} (together
with Lemma~\ref{lem:symmetry}) we know that  is the largest
column, and the column lengths decrease to both sides, and similarly
for the rows.
Our algorithm will only be based on this weaker property
(\emph{orthogonal convexity}); it will not make use of convexity
\emph{per se}.
We will, however, use convexity one more time to prove that the
lengths of the columns are , in order to reduce the
running time.




In the following we assume the symmetry property of the last lemma.
For an -town , let the \emph{width} of  be
 and the \emph{height} of  be
. We will now show that the width
and the height cannot differ by more than a factor of~2.
Together with convexity, this will imply that they are bounded by
 (Lemma~\ref{bounded-width}).

\begin{lemma}
\label{relative-bound-width} For every optimal -town ,

\end{lemma}

\begin{proof}
Let  be an -town, , and , and assume
 .
 Let  be the
topmost and  be the rightmost point of ,
with

and
. Let .
We show that ,
and
thus,  is not optimal.
By Lemma~\ref{lem:changecostfunc},
 the change in cost is .
We show that  by
 calculating this difference column by column.
This proves then that replacing  with  yields a gain
of at least , and we are done.
Let us calculate the difference
  for a column  of height :

\qed
\end{proof}

\begin{lemma}
\label{bounded-width} For every optimal -town we have

\end{lemma}

\begin{proof}
Let  and . Assume without loss of generality
that .
We know from Lemma
\ref{relative-bound-width} that .
By Lemma \ref{lem:symmetry}, we choose a topmost, a rightmost,
a bottommost, and a leftmost point of  such that the convex hull
of these four points is a quadrilateral with a vertical and horizontal diagonal,
approximately diamond-shaped.
Let  be the set of all grid points contained in this quadrilateral.
The area of the quadrilateral equals , and its boundary
contains at least 4 grid points.
Pick's theorem says that the area of a simple grid polygon equals
the number of its interior grid points  plus half of the number of
the grid points  on its boundary minus 1.
This implies .
Because of Lemma~\ref{lem:convex}, all points in  belong to .
Since  consists of at most  points, we have
 Solving the equation
  shows that

\end{proof}

\section{Computing Optimal Solutions}\label{sec:optimal}
\begin{figure}[tb]
\begin{center}
\includegraphics[height=6cm]{dynamicprogram.eps} \caption{The
lines , , , and  from Lemma~\ref{lem:symmetry}.
The rectangle  and the set of points above and below it with
cardinality  and , respectively. The gray points are the
corner points of . In this example, the height  of column
 is set to .} \label{fig:dynamicprogram}
\end{center}
\end{figure}

We will now describe a dynamic-programming algorithm for computing
optimal towns. A program for this algorithm is listed
in~\ref{code}.

We denote by  the number of selected points in column 
and by  and  the row index of the topmost and
bottommost selected point in , respectively. We have ; see Fig.~\ref{fig:dynamicprogram}.


\begin{lemma}\label{lem:rectangle}
Let  be an optimal -town \textup(placed as described in
Lemma~\ref{lem:symmetry}\textup) containing the points  and
, for . Then all points inside the rectangle
 belong to .

Similarly, if  contains
the points  and , for , then it contains all
points in the rectangle
.
\end{lemma}
\begin{proof}
If  and  are contained in  then, by
Lemma~\ref{lem:symmetry},  and  belong
to  as well. By Lemma~\ref{lem:convex} all points inside the
convex hull of these four points are contained in . The same
arguments hold for the second rectangle.  \qed
\end{proof}

Now we describe the dynamic program. It starts with the initial
empty grid and chooses new columns alternating from the set of
columns with nonnegative and with negative column index, i.e.,
in the order
. Let  be the index of the currently
chosen column and fix  to a value~. We describe the dynamic
program for columns with nonnegative index; columns with negative
index are handled similarly.
(In the program that is described in the appendix, we use a trick to
avoid dealing with negative columns: they are mapped to columns with positive
index by reflecting everything at the -axis, with a proper
adjustment to take into account that the placement of
Lemma~\ref{lem:symmetry} is not invariant under this transformation.)


We know from Lemma~\ref{lem:rectangle} that in every optimal
solution, every point inside the rectangle  is selected.
We define

as the minimum cost of a town
with columns  of height  for 
and  where  points lie above the rectangle , having
a total distance  and
 to the upper-left and upper-right corner of
, respectively, and  points lie below , having a
total distance  and 
to the lower-left and lower-right corner of . For a given ,
we are looking for the -town with minimum cost where . Next we show that
 can be
computed recursively.

Consider the current column  with . The cost from all
points in this column to all points above , in , and below
 can be expressed as

We can transform this into

which, obviously, depends only on the parameters , ,
, , , and
 (the two parameters ,
 are needed if we consider a column with
negative index). We denote the expression \eqref{eq:dist} by  and
state the recursion for the cost function:

By Lemma~\ref{lem:rectangle} it suffices to consider only previous
solutions with . In the step before, we considered the
rectangle . Hence, the
parameters with index  can be computed from the parameters with
index  as follows:

The parameters  and
 can be computed analogously and the cost
function is initialized as follows:

The bound on  has been shown in Lemma \ref{bounded-width}.

\begin{theorem}
\label{running}
An optimal -town can be computed by dynamic programming in
 time.
\end{theorem}
\begin{proof}
  We have to fill an eight-dimensional array
  
  .  Let
   denote the maximum number of occupied rows and columns in
  an optimum solution.  By Lemma~\ref{bounded-width}, we know that
  .

  The indices  and  range over an interval of size
  . Let us consider a solution for some fixed 
  and .  The parameters  and  range between 0 and~.  However,
  we can restrict the difference between  and  that we have to
  consider: If we reflect the rectangle
  about its horizontal
  symmetry axis, the  points above  and the  points below 
  will not match exactly, but in each column, they differ by at most
  one point, according to Lemma~\ref{lem:symmetry}. It follows that .  (If the difference is larger, such a
  solution can never lead to an optimal -town, and hence we need
  not explore those choices.)  In total, we have to consider
  only  pairs .

  The same argument helps to reduce the number of quadruples
   .
  Each -variable
  can range between 0 and .
  However, when reflecting around the horizontal symmetry axis of , each of the
at most  differing points contributes at most  to the difference between the distance sums
   and . Thus we have
  , and similarly,
  .

By a similar argument, reflecting about
 the vertical symmetry axis of , we conclude that
   and
. In summary, the
total number of quadruples
  
that the algorithm has to consider is . In total, the algorithm processes

8-tuples. For each 8-tuple, the recursion~\eqref{eq:recursion} has
to consider at most  values , for a
total running time of .  \qed
\end{proof}

\section{\boldmath -Towns, Cities, and -Block Cities}\label{sec:townscitiesblockcities}
 For large values of ,
 -towns converge
towards the continuous weight distributions of {\em cities}.
However, the arrangement of buildings in many cities are discretized
in a different sense: An {\em{-block city}} is the
union of  axis-aligned unit squares (``city blocks''),
see Fig.~\ref{disctown} below. In the following,
we discuss -block cities, and
we discuss the relation between -towns and -block
cities.








For a planar region , let  be the integral of Manhattan distances between all point pairs in :

  When  has
area 1, this is the expected distance between two random points
in~.
Scaling a shape  by a factor of  increases the total cost by a
factor of , i.e., by a factor of  for an area of .
This motivated \cite{Bender03whatis} to use the expression
 as a scale-independent measure for the
quality of the shape of a city. For example, a square  of any side length  gets the same
value

A circle  yields  and
the optimal shape achieves a value of 

We will consider -block cities  consisting of unit
squares (``blocks'') centered
at a set of  grid points .
We denote a unit square centered at point
 by , and then we have

The average distance  of an -block city can be decomposed
into average distances between blocks:

Using the notation

we can express this as

The average distance  between two square
blocks at an offset  can be expressed as follows: If the two blocks
don't lie in the same row or column ( and ), the
average distance is simply the distance  between the
centers, since positive and negative
deviations from the block centers average out.
When two blocks lie in the same column, then the -distances
average out to the -distance between the centers, but the average -distance is not the
-distance between the centers (which would be 0), but
.
Similarly, for two blocks in the same row, we must add  to
the distance  between the centers. Finally, for two
identical blocks, we have already seen that the average distance is
. We can express this compactly as

where the notation  is 1 if the predicate
 holds and 0 otherwise.
With these conventions, the expression
\eqref{eq:c'}
for the cost  of an -block city 
looks very similar
to
\eqref{eq:c}
for the cost  of a town ,
except for
the correction terms  in the summands and for the factor
.
The factor  accounts for the fact that in the sum  of a
town, each {pair} of (distinct) points is counted once, whereas in the
integral , each pair of points is considered twice, as two
ordered pairs.
To make these expressions better comparable, we introduce the factor
 and define 

The new ``distance''  is not a norm (for example, ),
but the properties from Section~\ref{sec:prelim} remain true for this
new objective function.  Thus, the dynamic programming formulation of
Section~\ref{sec:optimal} can be adapted to compute optimal -block
cities.
As we shall now demonstrate,
all lemmas of Section~\ref{sec:prelim} hold verbatim
for -block cities, except that the formula for
the change incurred by moving a single block to a different place
(Lemma~\ref{lem:changecostfunc}) must be adapted:
\begingroup
\renewcommand\thetheorem{\ref{lem:changecostfunc}}
\begin{lemma}
  Let 
be the set of centers of an -block city,  and . Then,

where
.
\end{lemma}
\endgroup
The proof is the same as for
Lemma~\ref{lem:changecostfunc}. One can easily check
that the distance  from  to itself
and the distance from  to itself
are correctly accounted for.
\qed

Convexity of the optimum solution (Lemma~\ref{lem:convex}) holds
true for -block cities. The proof goes through almost verbatim.
The expression  is not a norm, but it is a convex function of
, and this is all that is needed.
Approximate symmetry of the optimal solution (Lemma~\ref{lem:symmetry})
remains true. The calculations (which have not been shown in detail
anyway), are modified, but the conclusion is the same.


When comparing an -town  and a corresponding -block city
, we have to add 1/6 for each pair of blocks that are in the
same column, and for each pair of blocks that are in the same row.
 Using the notation  and  of Section~\ref{sec:optimal}
for row and column lengths,
and writing
 instead of  for improved clarity,
 we get thus:

This {\em adjustment term} accounts for the discretization effect.
For example, a -town has an average distance of 0, as all the weight is
concentrated in a single point, while a -block city has
an average distance of ,
just like any other square,
 (and a  value of ).



Using this expression, it is easy to show that the bound of 2 on the
 aspect ratio holds for -block cities in the same form as in
 Lemma~\ref{relative-bound-width}.
The proof of Lemma~\ref{relative-bound-width} establishes that
 decreases when a top-most point  from the
longest column of height  is added to the right of the
 longest row of length .
For an -block city, the
adjustment term
 decreases by at least  when  is removed,
and it increases by  when  is added.
Under the assumption of the proof (), the total change
of 
is negative, and the modified solution is an improvement also when
 is regarded as an -block city.

From Lemma~\ref{relative-bound-width} we conclude that the bound of
 on the height and width of optimal -block cities
(Lemma~\ref{bounded-width}) holds as well.  (The argument of the proof
of Lemma~\ref{bounded-width} is purely geometric: it is based on
convexity and does not use the objective function.)


Thus, we conclude that the adjustment term~\eqref{eq:lambda} is
asymptotically bounded by .

When considering the continuous weight distributions of -block
cities, we have to account twice for each pair of discrete block
centers; hence, the appropriate measure for the quality of an
-town is . The measure for the
corresponding -block city is
. Thus, the relative
difference is .

\begin{figure}[t]
\begin{center}
\begin{picture}(0,0)\includegraphics{discretetown.pstex}\end{picture}\setlength{\unitlength}{1579sp}\begingroup\makeatletter\ifx\SetFigFontNFSS\undefined \gdef\SetFigFontNFSS#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(12024,9624)(289,-9073)
\put(8701,-1561){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(6301,-1561){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(11101,-1561){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(3901,-1561){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(11101,-8761){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(1501,-1561){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(8701,-3886){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(1501,-3886){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(3901,-3886){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(6301,-3886){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(6301,-6361){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(1501,-6361){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(3901,-6361){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(11101,-6361){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(11101,-3886){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(8701,-6361){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(8701,-8761){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(6301,-8761){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(3901,-8761){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\put(1501,-8761){\makebox(0,0)[b]{\smash{{\SetFigFontNFSS{6}{7.2}{\rmdefault}{\mddefault}{\updefault}}}}}
\end{picture}  \caption
{Values of  and  for optimal -block cities
 for .  All optimal solutions
    are shown, up to symmetries.
These are simultaneously shapes of optimal -towns,
 but for , there are additional
 -towns that are tied for the optimum
(with the same value ), cf.~Figure~\ref{fig:smalltowns}.
}
 \label{disctown}
\end{center}
\end{figure}




\begin{figure}[t]
\begin{center}
  \includegraphics[width=.73\columnwidth]{72.eps}
  \caption{The optimal -town and the two optimal -block cities for .}
\label{fig:72}
\end{center}
\end{figure}







In Figure~\ref{disctown}, we show the corresponding values for the
small examples from Figure~\ref{fig:smalltowns}.
Figure~\ref{optsols} shows results for some larger values .
One can observe how  and  converge from below and above
towards the optimal city value  of about 0.650\,245\,952\,951. Note that convergence is not monotone, neither for  nor for .



\section{Computational Results}
\label{sec:results}

Optimal -towns and optimal -block cities do not necessarily
have the same shape. For , a comparison of
Figures~\ref{fig:smalltowns} and~\ref{disctown} shows that, while
not all optimal -towns are optimal -block cities, every
optimal -block city is simultaneously an optimal -town.
However, this is not always true. In fact, for , there are two shapes for
 optimal -block cities, none of which is optimal for an -town,
see Figure~\ref{fig:72}.
This is the only instance of this phenomenon up to , but we
surmise it will be more and more frequent for larger~.
We have more comments on this phenomenon at the end of this section.


We have calculated the optimal costs
 and
 up to  points. The results are shown in
Table~\ref{table:smalltowns}. When there are several optimal solutions
(except symmetries), this is indicated by a star,
together with the multiplicity.

\begingroup
\let\oldarrarystretch = \arraystretch
\renewcommand{\arraystretch}{1.065}
\begin{table}
\centering
{\footnotesize
\begin{tabular}{|r|rr|rr|r||r|rr|rr|r|}
\hline
& & \  & & \ \ \  & 
& & & \ \  & & \ \ \ \ \  & 
\\\hline
         1 &     0  &&      0\rlap{}& &
& 41 &  3446  &&   3530\rlap{}& &
\\
 2 &     1  &&      2\rlap{}& &
\\
 3 &     4\rlap{}&&      5\rlap{}& &
& 43 &  3886  &&   3976\rlap{}& &
& 46 &  4612\rlap{}&&   4712\rlap{}& &
\\
 7 &    38  &&     44\rlap{}& &
\\
 9 &    72  &&     81\rlap{}& &
\\
\hline
11 &   124\rlap{}&&    135\rlap{}& &
& 51 &  5960  &&   6076\rlap{}& &
\\
12 &   152  &&    165\rlap{}& &
& 52 &  6248  &&   6368\rlap{}& &
& 53 &  6568  &&   6691\rlap{}& &
\\
14 &   227  &&    244\rlap{}& &
\\
17 &   374\rlap{}&&    396\rlap{}& &
& 57 &  7896  &&   8033\rlap{}& &
\\
18 &   433\rlap{}&&    457\rlap{}& &
& 58 &  8243  &&   8384\rlap{}& &
\\
19 &   496\rlap{}&&    522\rlap{}& &
& 59 &  8604  &&   8749\rlap{}& &
\\
20 &   563  &&    591\rlap{}& &
& 60 &  8968  &&   9117\rlap{}& &
\\
\hline
21 &   632  &&    663\rlap{}& &
& 64 & 10556  &&  10719\rlap{}& &
\\
25 &   992  &&   1032\rlap{}& &
& 65 & 10972  &&  11139\rlap{}& &
\\
26 &  1091  &&   1134\rlap{}& &
& 67 & 11836\rlap{}&&  12011\rlap{}& &
\\
28 &  1318  &&   1365\rlap{}& &
& 68 & 12280  &&  12460\rlap{}& &
& 69 & 12728  &&  12912\rlap{}& &
\\
30 &  1570  &&   1622\rlap{}& &
& 70 & 13209  &&  13396\rlap{}& &
\\
\hline
31 &  1704  &&   1759\rlap{}& &
& 71 & 13700\rlap{}&&  13891\rlap{}& &
& 73 & 14690  &&  14888\rlap{}& &
& 75 & 15712  &&  15918\rlap{}& &
\\
36 &  2486  &&   2554\rlap{}& &
& 76 & 16232  &&  16442\rlap{}& &
\\
37 &  2656  &&   2727\rlap{}& &
& 77 & 16780  &&  16995\rlap{}& &
\\
40 &  3241  &&   3322\rlap{\bar c_{\textrm{city}} :=
\lfloor 3\psi n^{5/2}/2 + 0.345\cdot n^{3/2}\rceil/3\bar c_{\textrm{town}} := \lfloor \psi n^{5/2}/2 - 0.205\cdot n^{3/2}\rceil
is shown in
Table~\ref{table:smalltowns}.

Finally, we look at
the difference between  and .
For a given point set , it is the quantity 
defined in~\eqref{eq:lambda}.  It is estimated as .
The table shows the error
 .
Apart from the rounding,  would equal .

One can see that the error  is much smaller than one might
expect from the random-looking fluctuations of  and .
This can be explained by the fact that the expression~\eqref{eq:lambda}
 for 
is apparently not so sensitive to small deviations of the shape .




\begin{figure}[t]
\begin{center}
\includegraphics[width=0.8\columnwidth]{optsols.eps} \caption{Optimal
-towns for ; these are simultaneously the shapes of
the optimal -block cities.}
\label{optsols}
\end{center}
\end{figure}

Accordingly, Table~\ref{table:smalltowns} exhibits the tendency
that the deviations of  and 
``above'' and ``below average'' occur for the same values of~:
-towns and -block cities with the same number  suffer
equally from the effects of discretization.
A glance at the optimal solutions (Figures~\ref{fig:smalltowns}
and~\ref{disctown})
shows that
the costs are
below average when the shapes are highly symmetric, for example
, 12, 21, but also   (Figure~\ref{optsols}).
On the other hand, when there is no unique ``very good'' shape, one
can expect a greater variation of different solutions that try to come
close to the optimal continuous shape.  Indeed, larger values of 
and  in Table~\ref{table:smalltowns} tend to go hand in hand with
a greater multiplicity of optimal solutions. The worst values of 
and  occur for ; this is the first value of  where optimal
-block cities and optimal -towns differ (Figure~\ref{fig:72}).
This is probably no coincidence:
when there is a greater variety of solutions that can compete for being
best, the distinction of the objective function between -block
cities and -towns is more likely to make a difference.

\section{Outlook}
\label{sec:outlook}

We have shown that optimal -towns can be computed
in time . This is of both theoretical and practical
interest, as it yields a method polynomial in  that also allows extending
the limits of the best known solutions; however,
there are still some ways how the result could be improved.

Strictly speaking, the method is only pseudo-polynomial, as
the input size is . It is not clear how
the corresponding output could be described in polylogarithmic
space; any compact encoding would
lead to
 a good and compact
approximation of the optimal (continuous) city curve, for which there is
only a description by a differential equation with no known closed-form solution.
For this reason we are sceptical that a polynomial solution
is possible.



We are more optimistic about lowering the number of parameters
in our dynamic program, and thus the exponent, by exploiting
convexity or
stronger symmetry properties. This may also make it possible to compute
optimal solutions for larger .
One possible avenue could arise if partial solutions
would satisfy some monotonicity property; however,
the unique optimal 9-town is not contained in the unique optimal 12-town.
Thus, there is no way for a town to organically grow
and remain optimal at all times.
Generally,
an optimal -town does not necessarily contain an optimal
 -town.
(The smallest example occurs for ,
no optimal 35-town contains an optimal 34-town.)

As discussed in the last section, there is still a variety of questions
regarding the convergence of optimal solutions for growing ,
approaching the continuous solution in the limit.
As indicated, we have a pretty good idea how this continuous value is
approximated from below and above by -towns and -block cities;
however, we do not have a formal proof of the lower bound property
of -block cities.

It is easy to come up with good and fast approximation methods:
In the continuous case, even a square is within 2.5\% of the optimal
shape; a circle reaches 0.02\%; consequently, simple greedy heuristics
will do very well. Two possible choices are iteratively adding points
to minimize the total cost, or (even faster) as close as possible to
a chosen center.

As mentioned in the introduction, a closely related, but harder
problem arises when  locations are to be chosen from a given set of
 points, instead of the full integer grid. This was studied by \cite{bender08},
who gave a PTAS, but were unable to decide the complexity.
It is conceivable that a refined dynamic-programming approach may
yield a polynomial solution; however, details can expected
to be more involved, so we leave this for future work.
The same holds for other metrics.

Finally, one can consider the problem
in higher dimensions.
A crucial property of our dynamic-programming solution
is that the \emph{interface} between the points in
the columns that have already been constructed and
the points to be added in the future can be characterized by
a few parameters.
A similar property does not hold in three dimensions,
and therefore one cannot extend our
 dynamic-programming approach to higher dimensions.
For the same reason, the Euclidean distance version
cannot be solved by our method, since, unlike in the Manhattan
case, the effect of the  points on the upper
side of the current rectangle on the distance to points that are
inserted in the future cannot be summarized in the parameters

and
.
Moreover, in higher dimensions, there is no known solution for the
continuous case; the corresponding calculus-of-variations problem
will be harder to solve than in two dimensions.

\paragraph{Acknowledgements}
We thank the reviewers for their careful reading and their helpful comments.






\bibliographystyle{elsarticle-harv}
\bibliography{lib}













\appendix

\begin{figure}
  \centering
{\small
\footnotesize
\begin{verbatim}
n_target = 40 # run up to this value of n
\end{verbatim}
\vspace{-1,6\baselineskip}
\begin{verbatim}
cost_array = {} # initialize data for "array"
from math import sqrt
width_limit = int(2*sqrt(n_target)+5)
for w in range(0,width_limit+2):
 for cc in range(width_limit,0,-1):
  cost_array[w,cc]={}
MAX = n_target**3 # "infinity", trivial upper bound on cost
opt = (n_target+1)*[MAX] # initialize array for optimal values

cost_array[0,width_limit][0,0,0,0,0,0]=0 # starting "town" with no columns
for w in range(0,width_limit+1):
 for cc in range(width_limit,0,-1):
  for (D_up_right, D_down_right, D_up_left, D_down_left,
       n_up, n_down), cost in cost_array[w,cc].items():
\end{verbatim}
\vspace{-1,7\baselineskip}
\begin{verbatim}
    D_up_left   += n_up # add 1 horizontal unit to all left-distances
    D_down_left += n_down
\end{verbatim}
\vspace{-1,7\baselineskip}
\begin{verbatim}
    for c in range(cc,-1,-1): # decrease size c of new column one by one
      n = n_up+n_down + (w+1)*c # (w = previous value of w)
      if n <= n_target: # total number of occupied points so far
        new_cost = cost + ( (D_up_left + D_down_left) * c +
                            (n_up + n_down) * c*(c-1)/2 +
                            (c+1)*c*(c-1)/6 * (2*w+1) +
                            c*c * w*(w+1)/2 )
        if c==0: # a completed town
          opt[n] = min( new_cost, opt[n] )
        else: # store cost of newly constructed partial town
          ind = (D_up_left, D_down_left, D_up_right, D_down_right,
                 n_up, n_down) # exchange left and right when storing
          cost_array[w+1, c][ind] = min ( new_cost,
          cost_array[w+1, c].get(ind, MAX) )
      # decrease c by 1:
      if (cn_up += w
          D_up_left  += n_up + w*(w+1)/2
          D_up_right += n_up + w*(w-1)/2
      else: # remove from the bottom
          n_down += w
          D_down_left  += n_down + w*(w+1)/2
          D_down_right += n_down + w*(w-1)/2
\end{verbatim}
\vspace{-1,6\baselineskip}
\begin{verbatim}
for n in range(1,n_target+1): print n, opt[n]
\end{verbatim}
}

  \caption{\textsc{Python} program for computing optimal -towns}
  \label{fig:program}
\end{figure}

\section{Program for Computing Optimal Towns}
\label{code}
Figure~\ref{fig:program} shows a short program in the programming language \textsc{Python} that
implements our algorithm.
The program calculates and prints the costs of optimal -towns for
all values of 
up to the specified limit .
  Instead of an 8-dimensional array, the
costs are stored as a \emph{dictionary} in the variable
{\tt
\verb:cost_array:[\verb:w:,\verb:cc:][\verb:D_up_right:, \verb:D_down_right:, \verb:D_up_left:, \verb:D_down_left:,
       \verb:n_up:, \verb:n_down:]}.
This makes the program a lot simpler, since we don't have to worry about
allocating arrays with explicit limits, and
 incurs little overhead, since internally, \textsc{Python} dictionaries
are implemented as hash tables, providing constant expected access time.

Instead of adding rows alternately on the left and on the right, the
program always adds a new row on the left side, but (implicitly) reflects
the town about the -axis when storing a cost value, achieving the
same effect.

The main loop of the program does not use the recursion in the
form~\eqref{eq:recursion}, which calculates the optimum cost of a
configuration from all partial solution that lead to it when a column
is added.  Instead, it makes a ``forward'' transfer, generating
all successor configurations of a given configuration.  This has the
advantage that certain ``impossible'' parameter sets are automatically
excluded.  For example, in the running time analysis for
Theorem~\ref{running}, we argued that parameter pairs  with
 need not be considered.
(The parameters  and  correspond to the variables \verb:n_up: and \verb:n_down:.)
 Since the program only
adds columns which are (approximately) balanced about the -axis,
it will never generate solutions with such parameters.

The program can be adapted for computing optimal -block
\emph{cities}. Then the additional cost 
{from}~\eqref{eq:lambda}
 between blocks in the same row or column must be
taken into account.  One simply has to extend the last line in the
computation of \verb:new_cost::
{\small
\begin{verbatim}
             c*c * w*(w+1)/2 )
\end{verbatim}
}\noindent to
{\small
\begin{verbatim}
             c*c * w*(w+1)/2 ) * 6  + c*c + (cc-c)*w*w
\end{verbatim}
\noindent}The resulting cost is scaled by a factor of~6, but the
end result is then always even, so we could divide it by~2
(cf.~Table~\ref{table:smalltowns}: all values  are multiples
of~).

For , the program takes a few seconds, but for  it takes
hours.
For larger  the space becomes a more severe bottleneck than
the running time; thus it is important to release
 storage when it is no longer needed, for
example by resetting {\tt \verb:cost_array:[\verb:w:,\verb:cc:]=\verb:{}:}
after each outer loop.
There are several possibilities to speed up the program.
The cost of some approximately circular solution can be taken as an
initial upper bound.  With this upper bound, one can then derive a
stronger bound \verb:width_limit: on the maximum height and width by
{ad-hoc} methods.  During the calculation, one can also prune cost
values that are so large that they cannot possibly lead to a better
solution.  The given program computes only the optimum cost. We have
extended it to also remember the optimal solutions. This program has
133 lines and was used to produce the data of
Table~\ref{table:smalltowns}.


\end{document}
