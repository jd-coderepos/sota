\documentclass[10pt,journal,compsoc]{IEEEtran}
\IEEEoverridecommandlockouts       

\usepackage{epsfig} \usepackage{amsmath} \usepackage{amssymb}  \usepackage{amsthm}

\usepackage{cite}      \usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{url}       


\usepackage{verbatim}   \usepackage{color}
\usepackage{tabulary}
\usepackage{booktabs}

\newcommand{\HIGH}[1]{{\color{black}{#1}}}
\newcommand{\high}[1]{{\color{black}{#1}}}




\usepackage{algorithm}
\usepackage{algorithmic} 


\usepackage{bbold}
\usepackage{multirow}

\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}

\title{Node-based Service-Balanced Scheduling 
for Provably Guaranteed Throughput and Evacuation Time Performance
}



\author{Yu~Sang,
Gagan~R.~Gupta, 
and Bo~Ji~\IEEEmembership{Member,~IEEE} 
\thanks{This work was supported by the NSF under Grant CNS-1651947.
\HIGH{A preliminary version of this work was presented at the IEEE INFOCOM,
San Francisco, CA, April 10 -- 15, 2016 \cite{ji16infocom}.}}
\thanks{Yu Sang (yu.sang@temple.edu) and Bo Ji (boji@temple.edu) are with Dept. of CIS at Temple University. 
Gagan R. Gupta (gagan.gupta@iitdalumni.com) is with AT\&T Labs.
Bo Ji is the corresponding author.}
}









\newtheorem{theorem}{\it Theorem}
\newtheorem{proposition}{\it Proposition}
\newtheorem{lemma}{\it Lemma}
\newtheorem{corollary}{\it Corollary}
\newtheorem{definition}{\it Definition}
\newtheorem{conjecture}{\it Conjecture}

\newcommand{\ChromaticIndex}{\mathcal{X}^{\prime}}
\newcommand{\Graph}{G}
\newcommand{\Vertex}{V}
\newcommand{\Edge}{E}
\newcommand{\Matching}{\mathcal{M}}

\newcommand{\Odd}{\mathcal{O}}
\newcommand{\xr}{{x_r}}
\newcommand{\xrj}{{x_{r_j}}}
\newcommand{\DIFF}{{\textstyle \frac{D^+}{dt^+}}}
\newcommand{\diff}{{\textstyle \frac{d}{dt}}}
\newcommand{\Expect}{\operatorname{E}}
\newcommand{\Var}{\operatorname{Var}}
\newcommand{\mT}{\mathcal{T}}
\newcommand{\mC}{\mathcal{C}}
\newcommand{\mH}{\mathcal{H}}

\newcommand{\argmax}{\operatornamewithlimits{argmax}}

\DeclareGraphicsExtensions{.pdf,.eps}






\IEEEtitleabstractindextext{\begin{abstract}
This paper focuses on the design of \emph{provably efficient online} link scheduling algorithms for multi-hop 
wireless networks. We consider single-hop traffic and the one-hop interference model. The objective is twofold: 
1) \emph{maximizing the throughput} when the flow sources continuously inject packets into the network, and
2) \emph{minimizing the evacuation time} when there are no future packet arrivals. 
The prior work mostly employs the link-based approach, which leads to throughput-efficient algorithms 
but often does not guarantee satisfactory evacuation time performance. In this paper, 
\HIGH{we propose a novel Node-based Service-Balanced (NSB) online scheduling algorithm.
NSB aims to give scheduling opportunities to heavily congested nodes in a balanced manner, by maximizing
the total weight of the scheduled nodes in each scheduling cycle, where the weight of a node is 
determined by its workload and whether the node was scheduled in the previous scheduling cycle(s).}
We rigorously prove that NSB guarantees to achieve an efficiency 
ratio no worse (or no smaller) than  for the throughput and an approximation ratio no worse 
(or no greater) than  for the evacuation time. It is remarkable that NSB is both throughput-optimal 
and evacuation-time-optimal if the underlying network graph is bipartite. Further, we develop a lower-complexity 
NSB algorithm, called LC-NSB, which provides the same performance guarantees as NSB.
Finally, we conduct numerical experiments to elucidate our theoretical results.

\end{abstract}

\begin{IEEEkeywords}
Wireless scheduling, node-based approach, service-balanced, throughput, evacuation time, provable performance guarantees.
\end{IEEEkeywords}}

\maketitle






\section{Introduction} \label{sec:intro}
Resource allocation is an important problem in wireless networks. Various functionalities
at different layers (transport, network, MAC, and PHY) need to be carefully designed so as to 
efficiently allocate network resources and achieve optimal or near-optimal network performance. 
Among these critical functionalities, link scheduling at the MAC layer, which, at each time decides 
which subset of non-interfering links can transmit data, is perhaps the most challenging component
and has attracted a great deal of research effort in the past decades (see \cite{georgiadis06,lin06c} 
and references therein).

In this paper, we focus on the design of \emph{provably efficient online} link scheduling algorithms 
for multi-hop wireless networks with \emph{single-hop} traffic under the \emph{one-hop} 
interference model\footnote{The packets of single-hop traffic traverse only one link before leaving 
the system. \HIGH{The one-hop interference model is also called the node-exclusive or the primary 
interference model, where two links sharing a common node cannot be active at the same time.
This model can properly represent practical wireless networks based on Bluetooth or FH-CDMA 
technologies \cite{hajek88,sarkar05,lin06,lin06c,joo09}.}}.
While throughput is widely shared as the first-order performance metric, which characterizes the long-term 
average traffic load that can be supported by the network, 
\HIGH{evacuation time is also of critical importance due to the following reasons.
First, draining all existing packets within a minimum amount of time is a major concern in the settings 
without future arrivals.
One practical example is environmental monitoring using wireless sensor networks, 
where all measurement data periodically generated by different nodes at the same time, 
need to be transmitted to one or multiple sinks for further processing.
Second, evacuation time is also highly correlated with the delay performance in the settings with arrivals. 
For example, evacuation-time optimality is a necessary condition for the strongest delay notion 
of sample-path optimality \cite{guptathesis}.
Third, it is quite relevant to timely transmission of delay-sensitive data traffic (e.g., deadline-constrained 
packet delivery) \cite{soldati09,singh16}.}

However, these different metrics may lead to conflicting scheduling decisions -- an algorithm designed 
for optimizing one metric may be detrimental to the other metric (see \cite{guptathesis} for such examples). 
Therefore, it is challenging to design an efficient scheduling algorithm that can provide provably guaranteed 
performance for both metrics at the same time. 

While throughput has been extensively studied since the seminal work by Tassiulas and Ephremides 
\cite{tassiulas92} and is now well understood, evacuation time is much less studied. In the no-arrival 
setting, the minimum evacuation time problem \high{is equivalent} to the \emph{multigraph\footnote{In 
a multigraph, more than one edge, called multi-edge, is allowed between two nodes.} edge coloring problem}
\HIGH{due to the following: each multi-edge corresponds to a packet waiting to be transmitted over the link 
between the nodes of the multi-edge; each color corresponds to a feasible schedule (or a matching); finding 
the chromatic index (i.e., the minimum number of colors such that, each multi-edge is assigned a color and 
two multi-edges sharing a common node cannot have the same color) is equivalent to minimizing the time 
for evacuating all the packets by finding a matching at a time.}
Since edge-coloring is a classic NP-hard problem \cite{holyer81}, a rich body of research has focused on 
developing approximation algorithms (see \cite{stiebitz12} for a good survey). 
These algorithms employ a popular recoloring technique that requires computing the colors all at once, 
and yield a complexity that depends on the number of multi-edges. This, however, renders them 
unsuitable for application in a network with arrivals. This is because the complexity would become 
impractically high when there are a large number of packets (or multi-edges) in the network.
Therefore, it is desirable to have an \emph{online} scheduling algorithm that at each time quickly 
computes one schedule (or color) based on the current network state (e.g., the queue lengths) and 
yields a complexity that only depends on the node count  and/or the link count .

Most existing online scheduling algorithms either make scheduling decisions based on the link load (such as 
Maximum Weighted Matching (MWM) \cite{tassiulas92} and Greedy Maximal Matching (GMM) \cite{lin06,joo09}) 
or are load agnostic (such as Maximal Matching (MM) \cite{lin06,wu07}). While these algorithms are throughput-efficient, 
none of them can guarantee an approximation ratio better (or smaller) than  for the evacuation time \cite{guptathesis}. 
In contrast, several prior work \cite{mekkittikul98,tabatabaee09,guptathesis,ji15ciss} proposes algorithms based 
on the node workload (i.e., packets to transmit or receive), such as the Lazy Heaviest Port First (LHPF) 
algorithms, which are both throughput-optimal and evacuation-time-optimal in input-queued switches (which 
can be described as bipartite graphs) \cite{guptathesis}. The \emph{key intuition} behind the node-based 
approach is that the minimum evacuation time is lower bounded by the largest workload at the nodes and 
the odd-size cycles, and this lower bound is asymptotically tight \cite{kahn96}.
\high{Hence, giving a higher priority to scheduling nodes with heavy workload leads to better evacuation time performance,
while the link-based approach that fails to respect this crucial fact results in unsatisfactory evacuation time performance.}

While the node-based approach seems quite promising, the scheduling performance of the node-based algorithms 
is not well understood, and the existing studies are mostly limited to bipartite graphs \cite{mekkittikul98,tabatabaee09,guptathesis}. 
Very recent work of \cite{ji15ciss} considers general network graphs and shows that the Maximum Vertex-weighted 
Matching (MVM) algorithm can guarantee an approximation ratio no worse (or no greater) than  for the evacuation 
time. However, throughput performance of MVM remains unknown. 

There is several other related work. In \cite{georgiadis15}, the authors study the connection between 
throughput and (expected) minimum evacuation time, but no algorithms with provable performance 
guarantees are provided. The work of \cite{tassiulas95,tassiulas99,soldati09} considers the minimum 
evacuation time problem for multi-hop traffic in some special scenarios (e.g., special network topologies 
or wireline networks without interference).

In this paper, \emph{the goal is to develop efficient online link scheduling algorithms that can provide 
provably guaranteed performance for both throughput and evacuation time.} We summarize our 
contributions as follows.

First, we propose a Node-based Service-Balanced (NSB) scheduling algorithm that makes scheduling 
decisions based on the node workload and whether the node was scheduled in the previous time-slot(s). 
NSB has a complexity of .
We rigorously prove that NSB guarantees to achieve an approximation ratio no worse (or no greater) 
than  for the evacuation time and an efficiency ratio no worse (or no smaller) than  for the 
throughput. It is remarkable that NSB is both throughput-optimal and evacuation-time-optimal if the underlying 
network graph is bipartite. The \emph{key novelty} of NSB is that it takes a node-based approach and 
gives balanced scheduling opportunities to the bottleneck nodes with heavy workload. A novel application 
of \emph{graph-factor theory} is adopted to analyze how NSB schedules the heavy nodes (Lemma~\ref{lem:existence}).

Second, from the performance analysis for NSB, we learn that in order to achieve the same performance guarantees, 
what really matters is the priority or the ranking of the nodes, rather than the exact weight of the nodes. 
Using this insight, we develop the Lower-Complexity NSB (LC-NSB) algorithm. We show that LC-NSB 
can provide the same performance guarantees as NSB, while enjoying a lower complexity of .

In Table~\ref{tab:com}, we summarize the guaranteed performance of NSB and LC-NSB as well as 
several most relevant online algorithms in the literature. 
\emph{As can be seen, none of the existing algorithms strike a more balanced performance
guarantees than NSB and LC-NSB in both dimensions of throughput and evacuation time.}
Finally, we conduct numerical experiments to validate our theoretical results and compare the empirical
performance of various algorithms.



\begin{table}
\scriptsize
\centering
\begin{tabular}{|c|c|c|c|c|c|}\hline
  \multirow{2}{*}{Algorithm} & \multirow{2}{*}{Complexity} & \multicolumn{2}{|c|}{ (Throughput)} & \multicolumn{2}{|c|}{ (Evacuation time)}  \\ \cline{3-6}
  & & General & Bipartite & General & Bipartite \\ \hline
  MWM &  & 1 & 1 & 2 & 2 \\ \hline
  GMM &  &  &  & 2 & 2\\ \hline
  MM &  &  &  & 2 & 2 \\ \hline
MVM &  & ? & 1 &  & 1 \\ \hline
  \textbf{NSB} &  &  & 1 &  & 1 \\ \hline
  \textbf{LC-NSB} &  &  & 1 &  & 1 \\ \hline
\end{tabular}
\caption{Performance comparison of NSB and LC-NSB with several most relevant online algorithms in the literature.
	     The efficiency ratio  and the approximation ratio  are used for comparing the performance 
	     of throughput and evacuation time, respectively. (See formal definitions of  and  in 
	     Section~\ref{sec:model}.) For both  and , a value closer to 1 is better.
	     The complexity provided here is for making a scheduling decision at each time.
}
\label{tab:com}
\end{table}



The remainder of this paper is organized as follows. First, we describe the system model and 
the performance metrics in Section~\ref{sec:model}. Then, we propose the NSB algorithm and 
analyze its performance in Section~\ref{sec:nsb}. A lower-complexity NSB algorithm with the 
same performance guarantees is developed in Section~\ref{sec:lc-nsb}. Finally, we conduct 
numerical experiments in Section~\ref{sec:sim} and make concluding remarks in Section~\ref{sec:con}.
\high{Some detailed proofs are provided in Section~\ref{sec:proofs}.}


\section{System Model} \label{sec:model}


We consider a multi-hop wireless network described as an undirected graph , 
where  denotes the set of nodes and  denotes the set of links. The node count 
and the link count are denoted by  and , respectively. 
Nodes are wireless transmitters/receivers and links are wireless channels between two nodes. 
The set of links touching node 
 is defined as . 
We assume a time-slotted system with a single frequency channel. We also assume unit link 
capacities, i.e., a link can transmit at most one packet in each time-slot when active. However, 
our analysis can be extended to the general scenario with heterogeneous link capacities by 
considering the workload defined as . 
We consider the \emph{one-hop} interference model, under which a feasible schedule corresponds 
to a \emph{matching} (i.e., a subset of links, , that satisfies that no two links in  share a common node). 
A matching is called \emph{maximal}, if no more links can be added to the matching without 
violating the interference constraint. We let  denote the set of all matchings over . 


\HIGH{As in several previous work (e.g., \cite{lin06,joo09c,leconte11,ni12,li17}), 
we focus on link scheduling at the MAC layer, and thus we only consider single-hop traffic.}
We let  denote the cumulative amount of workload (or packet) arrivals at 
link  up to time-slot  (including time-slot ). By slightly abusing the notations,
we let  denote the cumulative amount of workload arrivals 
at node  up to time-slot  (including time-slot ). (Indices  and  correspond 
to links and nodes, respectively; similar for other notations.) We assume that the arrival process 
 satisfies the strong law of large numbers (SLLN): with probability one,

for all links , where  is the mean arrival rate of link .
Let  denote the arrival rate vector. 
We assume that the arrival processes are independent across links. Note that 
the process  also satisfies SLLN: with probability one,

for all nodes , where  is 
the mean arrival rate for node . 


Let  be the queue length of link  in time-slot , and let  be the 
cumulative number of packet departures at link  up to time-slot . We assume that
there are a finite number of initial packets in the network at the beginning of time-slot 
0. Let  be the amount of workload at node 
 (i.e., the number of packets waiting to be transmitted to or from node 
) in time-slot , and let  be the amount 
of cumulative workload served at node  up to time-slot . We also call 
 and  as the queue length and the cumulative departures at node  
in time-slot , respectively. 

Without loss of generality, we assume that only links with a non-zero queue length can be 
activated. Let  if matching  contains link , and  
otherwise. Let  be the number of time-slots in which  is selected 
as a schedule up to time-slot . We set by convention that  and 
for all  and for all . The queueing equations of the system are as follows:



Next, we define system stability as follows.
\begin{definition}
\label{def:stab}
The network is rate stable if with probability one,

for all  and for any arrival processes satisfying Eq.~(\ref{eq:slln_l}).
\end{definition}

Note that we consider \emph{rate stability} for ease of presenting our main ideas.
Strong stability can similarly be derived if we make stronger assumptions on the 
arrival processes \cite{andrews04}.

We define the \emph{throughput region} of a scheduling algorithm as the set of arrival rate
vectors for which the network remains rate stable under this algorithm. Further, we define the 
\emph{optimal throughput region}, denoted by , as the union of the throughput 
regions of all possible scheduling algorithms. A scheduling algorithm is said to have an 
\emph{efficiency ratio}  if it can support any arrival rate vector  strictly 
inside . Clearly, we have . In particular, a scheduling 
algorithm with an efficiency ratio  is \emph{throughput-optimal}, i.e., it can stabilize 
the network under any feasible load. We also define another important region  by considering
bottlenecks formed by the nodes:

Clearly, we have  because at most one packet can be transmitted 
from or to a node in each time-slot. 
\HIGH{
Similarly, any odd-size cycle  could also be a bottleneck because at most  
out of the  links of the odd-size cycle can be scheduled at the same time. 
For example, the total arrival rate summed over all edges of a triangle must not exceed 
 because at most one out of the
three links of the triangle can be scheduled in each time-slot.
For the theoretical analyses, we consider bottlenecks formed only by the nodes, which is
sufficient for deriving our analytical results. We provide more discussions about 
odd-size cycles in Sections~\ref{subsec:bipartite} and \ref{subsec:throughput}.
}

As we mentioned earlier, in the settings without future packet arrivals, the performance metric 
of interest is the evacuation time, defined as the time interval needed for draining all the initial 
packets. Let  denote the evacuation time of scheduling algorithm , and let 
 denote the minimum evacuation time over all possible algorithms. 
A scheduling algorithm is said to have an \emph{approximation ratio}  if it has an 
evacuation time no greater than  in any network graph with any finite 
number of initial packets. Clearly, we have . In particular, a scheduling algorithm 
with an approximation ratio  is \emph{evacuation-time-optimal}.

In this paper, the goal is to develop efficient online link scheduling algorithms that can 
simultaneously provide provably good performance in both dimensions of throughput and 
evacuation time, measured through the efficiency ratio (i.e., the larger the value of , 
the better) and the approximation ratio (i.e., the smaller the value of , the better), respectively. 
\HIGH{Note that the throughput performance has been extensively studied under quite general models
in the literature (see \cite{lin06c,georgiadis06} and references therein), where multi-hop traffic, 
general interference models, and time-varying channels (which can model mobility and fading) 
have been considered. However, the evacuation time performance is much less understood. 
As we have mentioned earlier, even in the setting we consider (assuming single-hop traffic, 
the one-hop interference model, and fixed link capacities), the minimum evacuation time problem 
is already very challenging (i.e., NP-hard). 
Considering multi-hop traffic adds another layer of difficulty. 
This is mainly because of the dependence between the upstream and downstream queues, 
since the arrival process to an intermediate queue is no longer exogenous, but instead, it is 
the departure process of its previous-hop queue. In addition to link scheduling, we also need
to decide which flow's packets will be transmitted when a link is activated. This further complicates
the minimum evacuation time problem.
}


\HIGH{
For quick reference, we summarize the key notations of this paper in Table~\ref{tab:notations}.
}

\begin{table}[!t]
\begin{tabular}{ c p{7cm}}
\toprule 
Symbol  & Meaning  \\
\hline 
   &  Network topology as an undirected graph       \\
   &  Set of nodes      \\
   &  Set of links     \\
   &  Number of nodes     \\
  &  Number of links     \\
    &  Set of links touching node       \\
    & A matching over  \\
    & Set of all the matchings over       \\
   &   Mean arrival rate of link    \\
   &  Mean arrival rate of node    \\
    &   Optimal throughput region    \\
   &   An outer bound of ; see Eq.~\eqref{eq:psi}   \\
    &  Efficiency ratio (for throughput performance)      \\
    &   Evacuation time of scheduling algorithm     \\
    &   Minimum evacuation time  \\
    &    Approximation ratio (for evacuation time performance)       \\  
     &    Cumulative arrivals at link  up to time-slot     \\
     &    Cumulative arrivals at node  up to time-slot   \\
    &  Cumulative departures at link  up to time-slot      \\
    &  Cumulative departures at node  up to time-slot    \\
    &    Queue length at link  in time-slot    \\ 
    &  Workload at node  in time-slot     \\
    &   Number of time-slots in which matching  is selected as a schedule up to time-slot    \\
    &  Largest node workload in time-slot \\
       &   Set of critical nodes in time-slot      \\
   	   &   Set of heavy nodes in time-slot       \\
   &  Whether node  is matched in time-slot  or not      \\
   &  See Eq.~(\ref{eq:U})     \\
     &    Weight of node  in time-slot    \\
 & Weight of matching    \\
\hline
\end{tabular}
\caption{\HIGH{Summary of notations.}}\label{tab:sys}
\label{tab:notations}
\end{table}


\section{Node-based Service-Balanced Algorithm} \label{sec:nsb}
In this section, we propose a novel Node-based Service-Balanced (NSB) scheduling algorithm and 
analyze its performance. Specifically, we prove that NSB guarantees an approximation ratio no worse 
(or no greater) than  for the evacuation time (Subsection~\ref{subsec:nsb_et}) and an efficiency 
ratio no worse (or no smaller) than  for the throughput (Subsection~\ref{subsec:nsb_throughput}). 
Further, we show that NSB is both throughput-optimal and evacuation-time-optimal in bipartite graphs 
(Subsection~\ref{subsec:bipartite}). To the best of our knowledge, none of the existing algorithms strike 
a more balanced performance guarantees than NSB in both dimensions of throughput and evacuation time.

\subsection{Algorithm} \label{subsec:nsb_alg}



\begin{algorithm}[!t]
\caption{Node-based Service-Balanced (NSB)}
\begin{algorithmic}[1]
\label{alg:nsb}
\STATE In each time-slot :
\FOR{each node }
\STATE Assign node weight  based on Eq.~\eqref{eq:weight}
\ENDFOR
\STATE Exclude links  with 
\STATE Find an MVM  over  with node weight 's, i.e., 

\FOR{each link }
\IF{}
\STATE Transmit one packet over link 
\ELSE
\STATE No transmission over link 
\ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm} 

We start by introducing Maximum Vertex-weighted Matching (MVM)~\cite{spencer84,guptathesis}, 
which will be a key component of the NSB algorithm. Let  denote the weight of node . 
We will later describe how to assign the node weights. Also, let  
denote the weight of matching , i.e., the sum of the weight of the nodes matched by . A matching  is called 
an MVM if it has the maximum weight among all the matchings, i.e., . 
In \cite{spencer84}, a very useful property of MVM is proven.
We restate it in Lemma~\ref{lem:path}, which will be frequently used in 
the proofs of our main results.

\begin{lemma}[Lemma~6 of \cite{spencer84}]
\label{lem:path}
For any positive integer , suppose that there exists a matching that matches the  
heaviest nodes. Then, an MVM matches all of these  nodes too.
\end{lemma}

Now, \high{we consider frames each consisting of three consecutive time-slots and} describe the 
operations of the NSB algorithm. We first give some additional definitions and notations. 
Recall that  denotes the workload of node  in time-slot . 
Let  denote the largest node queue length in time-slot .
A node  is called \emph{critical} in time-slot  if it has the largest queue length, 
i.e., ; a node  is called \emph{heavy} 
in time-slot  if its queue length is no smaller than . (Our results also hold 
if we replace  with any .) It will later become clearer why 
such a threshold is chosen. We use  and  to denote the set of critical nodes and 
the set of heavy nodes in time-slot , respectively. Let  denote 
whether node  is matched in time-slot  or not, and define 

\high{where  is the frame index. 
Note that  is either 1 or 0 and will be used in Eq.~\eqref{eq:weight} to determine whether 
a node needs to get a higher scheduling priority in time-slot  or not. Specifically, the weight of a heavy node  
is doubled if  (i.e., this heavy node  did not receive enough service in the previous time-slot(s)) 
such that node  has a higher priority of being scheduled in time-slot .}

\begin{figure*}[t!]
        \centering
        \begin{subfigure}[b]{0.23\linewidth}
                \includegraphics[width=\textwidth]{Figs/nsb0}
                \caption{Time-slot 0}
                \label{fig:nsb0}
        \end{subfigure}\begin{subfigure}[b]{0.23\linewidth}
                \includegraphics[width=\textwidth]{Figs/nsb1}
                \caption{Time-slot 1}
                \label{fig:nsb1}
        \end{subfigure}
\begin{subfigure}[b]{0.23\linewidth}
\includegraphics[width=\textwidth]{Figs/nsb2}
                \caption{Time-slot 2}
                \label{fig:nsb2}
        \end{subfigure} 
\begin{subfigure}[b]{0.23\linewidth}
                \includegraphics[width=\textwidth]{Figs/nsb3}
                \caption{Time-slot 3}
                \label{fig:nsb3}
        \end{subfigure}\caption{\HIGH{An illustration of the operations of NSB in four time-slots. The network setting is presented in Fig.~\ref{fig:nsb0}, 
        			where there are seven nodes . In each subfigure, the number above each link denotes the number of 
			packets waiting to be transmitted over that link at the beginning of each time-slot. 
			For simplicity, we assume no future packet arrivals in this example.
			The node degree (i.e., the sum of queue lengths over all the links touching the node) and the node weight (in the parenthese) 
			are both labeled after the node name; however, the node weight is not labeled if it is equal to the node degree. 
			The heavy nodes are highlighted in blue.
			Take Fig.~\ref{fig:nsb1} for example: the heavy nodes are , , , and ;
			node  has a degree of 3 and has a weight of 6; 
			node  has a degree and a weight both equal to 3. 
			Note that although both nodes  and  are heavy nodes in time-slot 1, 
			the weight of  equals twice the node degree because it was not scheduled in time-slot 1 (i.e., ).
			The thick red lines denote the links activated in each time-slot.
			}
			}
        \label{fig:nsb}
\end{figure*}

\begin{figure*}[t!]
        \centering
        \begin{subfigure}[b]{0.21\linewidth}
                \includegraphics[width=\textwidth]{Figs/mwm0}
                \caption{Time-slot 0}
                \label{fig:mwm0}
        \end{subfigure}\quad
        \begin{subfigure}[b]{0.21\linewidth}
                \includegraphics[width=\textwidth]{Figs/mwm1}
                \caption{Time-slot 1}
                \label{fig:mwm1}
        \end{subfigure}
	\quad
	\begin{subfigure}[b]{0.21\linewidth}
\includegraphics[width=\textwidth]{Figs/mwm2}
                \caption{Time-slot 2}
                \label{fig:mwm2}
        \end{subfigure} 
        \quad
        \begin{subfigure}[b]{0.21\linewidth}
                \includegraphics[width=\textwidth]{Figs/mwm3}
                \caption{Time-slot 3}
                \label{fig:mwm3}
        \end{subfigure}\caption{\HIGH{An illustration of the operations of MWM in four time-slots. The labels are similar to that in Fig.~\ref{fig:nsb}. 
       			The node degree and the node weight are not labeled because they are irrelevant under MWM.
			}
			}
        \label{fig:mwm}
\end{figure*}

Then, in time-slot , we assign a weight to node  as

The NSB algorithm finds an MVM~\cite{spencer84} based on the assigned node weight 's in each time-slot. 
Note that links with a zero queue length will not be considered when MVM is computed. According to 
Eq. (\ref{eq:weight}), the nodes are divided into two groups: the heavy nodes that were not scheduled 
in the previous time-slot(s) have a weight twice their workload, and all the other nodes have a weight 
equal to their workload. Within each group, a node with a larger workload has a larger weight. 
\high{To help illustrate the operations of the NSB algorithm, we provide its pseudo code in Algorithm~\ref{alg:nsb}.}

\HIGH{
In addition, to help the reader better understand the operations of the NSB algorithm, we also present a simple example
in Fig.~\ref{fig:nsb}, which demonstrates the system evolution within four time-slots. Note that a certain tie-breaking rule 
is applied in this example. Using a different tie-breaking rule, different schedules could be selected. For instance, 
in time-slot 0 we may activate link  
instead of link  along with links  and . However, tie-breaking rules do not affect our analysis.
As can be seen from Fig.~\ref{fig:nsb}, NSB drains all initial packets by the end of time-slot 3.
For comparison, using the same example, in Fig.~\ref{fig:mwm} we also demonstrate the system evolution under the 
MWM algorithm. Similarly, we observe that after time-slot 3, MWM needs two more time-slots to completely drain all
initial packets. In the next subsection, we will use a similar example to show that a link-based algorithm like MWM needs 
about twice as much time as that of a node-based algorithm like NSB to evacuate all initial packets in the network.
}





\subsection{Evacuation Time Performance} \label{subsec:nsb_et}
In this subsection, we analyze the evacuation time performance of NSB in the settings without 
arrivals. The main result is presented in Theorem~\ref{thm:nsb_et}.

\begin{theorem}
\label{thm:nsb_et}
The NSB algorithm has an approximation ratio no greater than  for the evacuation time performance. 
\end{theorem}

\begin{proof}
Recall that for a given network with initial packets waiting to be transmitted, 
denotes the minimum evacuation time, and  denotes the evacuation time of NSB. 
We want to show . 
Recall that  denotes the maximum node queue length in time-slot .
If , this is trivial as .
Now, suppose . Then, the result follows immediately from 1) Proposition~\ref{pro:nsb}
(stated after this proof): 
under NSB, the maximum node queue length decreases by at least two within \high{each frame}, i.e., 
, and 2) an obvious fact: it takes at least  time-slots 
to drain all the packets over the links incident to a node with maximum queue length, i.e., . 
\end{proof}

Next, we state a key proposition (Proposition~\ref{pro:nsb}) used for proving Theorem~\ref{thm:nsb_et}.

\begin{proposition}
\label{pro:nsb}
\high{Consider any frame.}
Suppose the maximum node queue length \high{is no smaller than two at the beginning of a frame}. 
Under the NSB algorithm, the maximum node queue length decreases by at least two \high{by the 
end of the frame}.
\end{proposition}

\HIGH{
We provide the detailed proof of Proposition~\ref{pro:nsb} in Section~\ref{sec:pro:nsb}
and give a sketch of the proof below.
Note that in any time-slot, the network together with the present packets can be 
represented as a loopless multigraph, where each multi-edge corresponds to a packet 
waiting to be transmitted over the link connecting the end nodes of the multi-edge.
We use  to denote the multigraph at the beginning of time-slot , 
and use  to denote the matching found by the NSB algorithm in time-slot . 
Hence, the degree of node  in  is equivalent to the node queue length 
, and the maximum node degree of  is equal to .
Now, consider any frame  consisting of three consecutive time-slots 
, where . 
Suppose that the maximum node queue length is no smaller than two at the beginning of 
frame , i.e.,  at the beginning of time-slot .
Then, we want to show that under the NSB algorithm, the maximum degree will be 
at most  at the end of time-slot .
We proceed the proof in two steps: 
1) we first show that the maximum degree will decrease by at least one in the first 
two time-slots  and  (i.e., the maximum degree will be at most 
at the end of time-slot ),
and then, 2) show that if the maximum degree decreases by exactly one in the first 
two time-slots (i.e., the maximum degree is  at the end of time-slot ), 
then the maximum degree must decrease by one in time-slot , and becomes 
 at the end of time-slot . 
}







\high{\emph{Remark:} The key intuition that the NSB algorithm can provide provable evacuation time performance 
is that all the critical nodes are ensured to be scheduled at least twice within each frame (Proposition~\ref{pro:nsb}). 
This comes from the following properties of NSB: 
1) it results in the desired priority or ranking of the nodes by assigning the node weights according to Eq.~(\ref{eq:weight}); 
2) it finds an MVM based on the assigned node weights, and if a critical node was not scheduled in the first time-slot of the frame,
then in the second time-slot of the frame, MVM guarantees to match all such critical nodes (Lemma~\ref{lem:path}); 
3) similarly, if a critical node was not scheduled in both of the first two time-slots of the frame, 
then MVM guarantees to match all such critical nodes in the third time-slot of the frame.} 

\HIGH{In addition, we use an example to illustrate why a link-based algorithm like MWM could result in a bad evacuation time performance.
Consider the network topology presented in Fig.~\ref{fig:graphN}. Since MWM aims to maximize the total weight summed over all scheduled
links in each time-slot, it will choose the matching consisting of all the edges with  packets. This pattern repeats until all links have one packet
(after  time-slots). Then, it takes additional  or  time-slots to drain all the remaining packets, depending on the tie-breaking rule.
This results in inefficient schedules that consist of one link only about half the time, and thus, requires a total of  or  time-slots. 
Another link-based algorithm GMM performs similarly.
On the other hand, as we will show in Section~\ref{subsec:bipartite}, NSB is evacuation-time-optimal 
in this example and needs only  time-slots since the graph is bipartite. 
The system evolution under NSB and MWM for a special case of  can be found in Figs.~\ref{fig:nsb} and \ref{fig:mwm}, respectively.
}

\begin{figure}[t!]
  \centering
    \includegraphics[width=0.25\textwidth]{Figs/evacuation}
  \caption{\high{A network with  nodes, where  is a positive integer. 
  			The number above each link denotes the number of initial packets waiting to be transmitted over that link.
}}
  \label{fig:graphN}
\end{figure}





\subsection{Throughput Performance} \label{subsec:nsb_throughput}
Next, we analyze the throughput performance of NSB in the settings with arrivals. The main 
result is presented in Theorem~\ref{thm:nsb_throughput}.

\begin{theorem}
\label{thm:nsb_throughput}
The NSB algorithm has an efficiency ratio no smaller than  for the throughput performance. 
\end{theorem}

\high{We will employ fluid limit techniques \cite{dai95,dai00,andrews04} to prove Theorem~\ref{thm:nsb_throughput}. 
Fluid limit techniques are useful for two main reasons: 
(i) it removes irrelevant randomness in the original stochastic system such that the considered
system becomes deterministic and thus, the analysis can be simplified;
(ii) the algorithm exhibits some special properties in the fluid limit (e.g., Lemma~\ref{lem:2in3}), 
which do not exist in the original stochastic system.

Before proving Theorem~\ref{thm:nsb_throughput}, we construct the fluid model and 
state some definitions and a lemma that will be used in the proof. 
First, we extend the process  to continuous time  by setting .
Hence, , , , and  are right continuous with left limits.
Then, using the techniques of \cite{dai00}}, we can show that for almost 
all sample paths and for all positive sequences , there exists a 
subsequence  with  as  such that the 
following convergence holds uniformly over compact (\emph{u.o.c.}) intervals of time :

\HIGH{Since the proof of the above convergence is standard, we provide the proof in the appendix for completeness.}

Next, we present the fluid model equations as follows:

Any such limit  is called a \emph{fluid limit}. Note that  and 
 are absolutely continuous functions and are differentiable at almost all times 
 (called \emph{regular} times). Taking the derivative of both sides of (\ref{eq:qqld})
and substituting (\ref{eq:dd}) into it, we obtain




Borrowing the results of \cite{dai00}, we give the definition of \emph{weak stability} 
and state Lemma~\ref{lem:weak2rate}, which establishes the connection between rate stability 
of the original system and weak stability of the fluid model.

\begin{definition}
\label{def:weak}
The fluid model of a network is weakly stable if for every fluid model solution  
with , one has  for all regular times .
\end{definition}

\begin{lemma}[\high{Theorem 3 of \cite{dai00}}]
\label{lem:weak2rate}
A network is rate stable if the associated fluid model is weakly stable.
\end{lemma}

We are now ready to prove Theorem~\ref{thm:nsb_throughput}.

\begin{proof}[Proof of Theorem~\ref{thm:nsb_throughput}]
We want to show that given any arrival rate vector  strictly inside , 
the system is rate stable under the NSB algorithm. Note that  is also strictly inside 
 (i.e.,  for all ) since . 
We define . Clearly, we must have . 

To show rate stability of the original system, it suffices to show weak stability of the fluid model 
due to Lemma~\ref{lem:weak2rate}. We start by defining the following Lyapunov function:

\HIGH{For any regular time , we define the drift of  as its derivative, denoted by .}
Since  is a non-negative function, given , in order to show  and 
thus  for all regular times , it suffices to show that if  for , 
then  has a negative drift.
\high{This is due to a simple result in Lemma 1 of \cite{dai00}.} 
Therefore, we want to show that for all regular times , if , then .

We first fix time  and let . Define the set of 
critical nodes in the fluid limits at time  as

Also, let  be the largest queue length in the fluid limits among the remaining 
nodes, i.e., . Since the number of 
nodes is finite, we have . Choose  small enough such that 
 and . Our choice of  
implies the following:


Recall that  is absolutely continuous. Hence, there exists a small  such that the 
queue lengths in the fluid limits satisfy the following condition for all times  
\HIGH{and for all nodes :

This further implies that the following conditions hold:

(C1)  for all ;

(C2)  for all ,

\noindent where (C2) is from Eq.~\eqref{eq:qtau} and  for all .
}

Let  be a positive subsequence for which the convergence to the fluid limit holds.
Consider a large enough  such that  
for all .
Considering the interval  around time , we define a set of consecutive
time-slots in the original system as
,
which corresponds to the scaled time interval  in the fluid limits.

Lemma~\ref{lem:2in3} states that NSB, all the critical nodes at scaled time  in the fluid 
limits will be scheduled at least twice within \high{each frame of interval }. 

\begin{lemma}
\label{lem:2in3}
Under the NSB algorithm, all the nodes in  will be scheduled at least twice within 
\high{each frame of interval }.
\end{lemma}

We provide the proof of Lemma~\ref{lem:2in3} in Section~\ref{sec:lem:2in3}.
For now, we assume that Lemma~\ref{lem:2in3} holds. \high{Note that interval  
contains at least  complete frames.}
Then, from Lemma~\ref{lem:2in3}, we have that for all ,

and therefore, we have

where  is from the convergence in Eq.~\eqref{eq:fluid_h} and  is from Eq.~\eqref{eq:beta}. 
Then, it follows from Eq. (\ref{eq:diff}) that for all , we have .

Also, from conditions (C1) and (C2), every node  has a queue length strictly smaller 
than that of a critical node in  for the entire duration . Thus, we have
, which implies that the fluid model is weakly stable. Then, we complete 
the proof by applying Lemma~\ref{lem:weak2rate}.
\end{proof}

\emph{Remark:} The key intuition that the NSB algorithm can provide provable throughput performance 
is that all the critical nodes in the fluid limit are ensured to be scheduled at least twice within each frame of 
interval  (Lemma~\ref{lem:2in3}). Similar to the provable evacuation time performance, this comes from 
the desired weight assignment (Eq.~(\ref{eq:weight})) and an important property of MVM (Lemma~\ref{lem:path}).

As we mentioned earlier, the proof of Lemma~\ref{lem:2in3} is provided in Section~\ref{sec:lem:2in3}. 
However, we want to emphasize that the proof relies on a novel application of graph-factor theory, 
which is stated in Lemma~\ref{lem:existence}.
Lemma~\ref{lem:existence} is of critical importance in proving the guaranteed
throughput performance of the NSB algorithm in general graphs. Moreover, it will play a key 
role in establishing both throughput optimality and evacuation time optimality for NSB in bipartite 
graphs (see Section~\ref{subsec:bipartite}).

Next, we give some additional notations that are needed to state Lemma~\ref{lem:existence}.
By slightly abusing the notations, we also use  to denote a multigraph,
which is possibly not loopless. 
Let  be the degree of node  in , where a loop associated with node  counts 2 
towards the degree of . 
Also, let  denote the subgraph of  induced by a subset of nodes . 

\begin{lemma}
\label{lem:existence}
Let  be a multigraph with maximum degree .
Consider a subset of nodes .
Suppose that the following conditions are satisfied: 
(i) all the nodes of  are heavy nodes, i.e., , 
and (ii)  is bipartite. Then, there exists a matching of  that matches every node of .
\end{lemma}


\begin{proof}
We first introduce some additional notations.
Let  and  be vectors of positive integers satisfying

A -factor is a subgraph  of  with

Note that if vectors ,  satisfy  for all ,
then the edges of a -factor form a matching of . 
Let  denote the subgraph of  induced by nodes  for which ,
and let . We restate a result of \cite{anstee90} in Lemma~\ref{lem:gf}, 
which will be used in the proof.

\begin{lemma}[Theorem~1.3 of \cite{anstee90}, Property I]
\label{lem:gf}
Let multigraph  and vectors ,  be given. Suppose that  is bipartite. 
Then,  has a -factor if and only if for all node subsets ,

\end{lemma}

\begin{figure}[t!]
  \centering
    \includegraphics[width=0.3\textwidth]{Figs/fg_factor}
  \caption{An illustration for the relationship of the sets in the proof of Lemma~\ref{lem:existence}.}
  \label{fig:set}
\end{figure}



We are now ready to prove Lemma~\ref{lem:existence}. 
Suppose that (i) all the nodes of  are heavy nodes and (ii)  is bipartite. 
We construct vectors ,  by setting  for node  and ,  otherwise. 
With our constructed vectors  and , not only a -factor forms a matching of graph , 
but this matching also matches every node of .
Therefore, it suffices to show that  has a -factor.

Next, we apply Lemma~\ref{lem:gf} to show that  has a -factor.
Note that  and  is bipartite.
Then, it remains to show that Eq.~(\ref{eq:gf}) is satisfied for any subset of nodes . 
Let  be the complementary set of . Let 
, and let  all 
the neighboring nodes of  are in . The relationship of these sets is illustrated in 
Fig.~\ref{fig:set}. Clearly, we have  as  for 
all . Also, a little thought gives 
. This is because 
any node  must belong to one of the following three cases:
\begin{enumerate}
\item If , then , and thus, ; 

\item If , then  and , 
which implies ;

\item If , then  and , which implies .
\end{enumerate}

Hence, in order to show Eq.~(\ref{eq:gf}), it remains to show 
.
We prove it by contradiction. Suppose .
Since  and  are disjoint, we have 
, and thus, . 
We let  denote the total degree of a subset 
of nodes  in . Then, we state three obvious facts:

(F1) ;

(F2) ;

(F3) .

\noindent Note that (F1) is from the fact that every node of  has a degree no smaller than 
, (F2) is trivial, and (F3) is from the definition of  
that all of its neighboring nodes belong to . Then, by combining the above facts, we obtain

This further implies ,
as . Hence, we must have ,
because . Substituting this back into Eq.~(\ref{eq:sh})
gives . This implies ,
and thus , which contradicts the fact that 
. (We assume  to avoid trivial discussions.)

Therefore, we have , and thus, Eq.~(\ref{eq:gf})
is satisfied. Then, Lemma~\ref{lem:gf} implies that graph  has a -factor, which forms 
a matching of graph  that matches every node of . This completes the proof.
\end{proof}

















\subsection{Optimality in Bipartite Graphs} \label{subsec:bipartite}
\high{As we have explained in the introduction, the minimum evacuation time is lower 
bounded by the largest workload at the nodes and the odd-size cycles. Hence, both the nodes 
and the odd-size cycles could be bottlenecks. Ideally, it would be best to consider the workload 
of both the nodes and the odd-size cycles when making scheduling decisions. However, this may 
render the algorithm very complex because it is much more difficult to explicitly consider all the 
odd-size cycles in a graph. Hence, we have focused on designing the node-based algorithms 
(such as the NSB algorithm) that do not explicitly handle the odd-size cycles. 
Without considering all the bottlenecks, these algorithms may not be able to achieve the best 
achievable performance in general. However, the theoretical results of Theorems~\ref{thm:nsb_et} 
and \ref{thm:nsb_throughput} are quite remarkable in the sense that even without considering the 
odd-size cycles (which could also be bottlenecks), the NSB algorithm can guarantee an 
approximation ratio no greater than  for the evacuation time and an efficiency ratio 
no smaller than  for the throughput.
We believe that NSB will perform better if odd-size cycles do not form bottlenecks. 
This is also observed from our simulation results in Section~\ref{sec:sim}.}

In this subsection, we will show that NSB is both throughput-optimal and evacuation-time-optimal in bipartite 
graphs, \high{where there are no odd-size cycles}. This result is stated in Theorem~\ref{thm:nsb_opt},
whose proof needs to apply Lemmas~\ref{lem:existence} and \ref{lem:path} and follows 
a similar line of analysis to that of Theorems~\ref{thm:nsb_et} and \ref{thm:nsb_throughput} for general graphs.
\HIGH{The detailed proof is provided in the appendix for completeness.}


\begin{theorem}
\label{thm:nsb_opt}
The NSB algorithm is both throughput-optimal and evacuation-time-optimal in bipartite graphs. 
\end{theorem}





\emph{Remark:} The NSB algorithm has a complexity of , as the complexity of finding 
an MVM is  \cite{spencer84}. One important question is whether we can develop 
lower-complexity algorithms that provide the same performance guarantees. We answer this question in the next section.

\begin{figure*}[t!]
        \centering
        \begin{subfigure}[b]{0.3\linewidth}
                \includegraphics[width=\textwidth]{Figs/triangle_top}
                \caption{Triangular Mesh}
                \label{fig:triangle_top}
        \end{subfigure}\qquad
        \begin{subfigure}[b]{0.3\linewidth}
                \includegraphics[width=\textwidth]{Figs/grid_top}
                \caption{44 grid}
                \label{fig:grid_top}
        \end{subfigure}
	\qquad
	\begin{subfigure}[b]{0.3\linewidth}
\includegraphics[width=\textwidth]{Figs/n100}
                \caption{Random topology}
                \label{fig:random_top}
        \end{subfigure}  
        \caption{Simulation Topologies.}
        \label{fig:topologies}
\end{figure*}

\begin{figure*}[t!]
        \centering
        \begin{subfigure}[b]{0.3\linewidth}
                \includegraphics[width=\textwidth]{Figs/n30triangle-poisson}
                \caption{Triangular Mesh}
                \label{fig:triangle_result}
        \end{subfigure}\quad
        \begin{subfigure}[b]{0.3\linewidth}
                \includegraphics[width=\textwidth]{Figs/grid-poisson}
                \caption{44 grid}
                \label{fig:grid_result}
        \end{subfigure}
	  \quad
	    \begin{subfigure}[b]{0.3\linewidth}
\includegraphics[width=\textwidth]{Figs/n100a005random-poisson}
                \caption{Random topology}
                \label{fig:random_result}
        \end{subfigure}  
        \caption{Simulation results for Poisson arrivals.}
        \label{fig:results_poi}
\end{figure*}

\begin{figure*}[t!]
        \centering
        \begin{subfigure}[b]{0.3\linewidth}
                \includegraphics[width=\textwidth]{Figs/n30triangle-file01}
                \caption{Triangular Mesh}
                \label{fig:triangle_result_file}
        \end{subfigure}\quad
        \begin{subfigure}[b]{0.3\linewidth}
                \includegraphics[width=\textwidth]{Figs/grid-file01}
                \caption{44 grid}
                \label{fig:grid_result_file}
        \end{subfigure}
	  \quad
	    \begin{subfigure}[b]{0.3\linewidth}
\includegraphics[width=\textwidth]{Figs/n100a005random-file01}
                \caption{Random topology}
                \label{fig:random_result_file}
        \end{subfigure}  
        \caption{\HIGH{Simulation results for file arrivals, where the file arrival probability is  and the file size follows Poisson distribution with mean .}}
        \label{fig:results_file}
\end{figure*}

\begin{figure*}[t!]
        \centering
        \begin{subfigure}[b]{0.3\linewidth}
                \includegraphics[width=\textwidth]{Figs/n30triangle-zipf3}
                \caption{Triangular Mesh}
                \label{fig:triangle_result_zipf}
        \end{subfigure}\quad
        \begin{subfigure}[b]{0.3\linewidth}
                \includegraphics[width=\textwidth]{Figs/grid-zipf3}
                \caption{44 grid}
                \label{fig:grid_result_zipf}
        \end{subfigure}
	  \quad
	    \begin{subfigure}[b]{0.3\linewidth}
\includegraphics[width=\textwidth]{Figs/n100a005random-zipf3}
                \caption{Random topology}
                \label{fig:random_result_zipf}
        \end{subfigure}  
        \caption{\HIGH{Simulation results for Zipf arrivals with a support of .}}
        \label{fig:results_zipf}
\end{figure*}


\section{A Lower-Complexity NSB Algorithm} \label{sec:lc-nsb}
Through the analysis for the NSB algorithm, we obtain the following important insights:
In order to achieve the same performance guarantees as NSB, what really matters is the priority or 
the ranking of the nodes, rather than the exact weight of the nodes. 
\high{This insight comes from the following:
Note that under the NSB algorithm, the weight of each node is only used in the MVM component
(line 6 of Algorithm~\ref{alg:nsb}). In the performance analysis of NSB (i.e., Theorems~\ref{thm:nsb_et}, 
\ref{thm:nsb_throughput}, and \ref{thm:nsb_opt}), the only property of MVM we use is Lemma~\ref{lem:path}, 
which is concerned about the  heaviest nodes (i.e., the  highest ranking nodes) rather than 
about the exact weight of the nodes.}
Hence, if we assign the node weights in a way such that, the weights are bounded integers and the nodes 
still have the desired priority or ranking as in the NSB algorithm, then we can develop a new algorithm 
with a lower complexity. Thanks to the results of 
\cite{huang12,pettie12}, an -complexity implementation\footnote{This can be done 
by setting the weight of an edge to the sum of the weight of its two end nodes and finding an MWM 
based on the new edge weights using the techniques developed in \cite{huang12,pettie12}.} of MVM 
can be derived if the maximum node weight is a bounded integer independent of  and . 

Next, we propose such an algorithm, called the Lower-Complexity NSB (LC-NSB). 
\high{Similarly as in NSB, we consider frames each consisting of three consecutive time-slots.}
Recall that  indicates whether node  was matched in the previous time-slot (or in both of the previous two time-slots),
as defined in Eq.~(\ref{eq:U}). Also, recall that  and  denote the set of critical nodes and 
the set of heavy nodes in time-slot , respectively. In time-slot , we assign a weight to node  as



Then, the LC-NSB algorithm finds an MVM based on the assigned node weight 's in every time-slot. 
Note that LC-NSB has a very similar way of assigning the node weights as NSB. However, the key difference 
is that we now divide all the nodes into five priority groups by assigning the node weights only based on 
whether it is a heavy (or critical) node and whether it was scheduled in the previous time-slot(s), while in 
the NSB algorithm, the actual workload is used in the weight assignments. This slight yet crucial change 
leads to a lower-complexity algorithm with the same performance guarantees. Note that in Eq.~(\ref{eq:weight_lc}), 
we give a higher priority to the critical nodes in order to guarantee the evacuation time performance.
\HIGH{The proof follows a similar line of analysis to that for the NSB algorithm and is provided in the appendix for completeness.}

\begin{theorem}
\label{thm:lc_nsb}
The LC-NSB algorithm has an approximation ratio no greater than  for the evacuation time and has an 
efficiency ratio no smaller than  for the throughput. 
Moreover, the LC-NSB algorithm is both throughput-optimal and evacuation-time-optimal in bipartite graphs.
\end{theorem}



\emph{Remark:} Although the LC-NSB algorithm can provide the same performance guarantees as NSB, 
we would expect that LC-NSB may have (slightly) worse empirical performance compared to NSB, since 
NSB has a more fine-grained priority differentiation among all the nodes. We indeed make such observations 
in our simulation results in Section~\ref{sec:sim}. In order to improve the empirical performance, we can 
introduce more priority groups for the non-heavy nodes under LC-NSB rather than all being in the same 
priority group (of weight 1 as in Eq.~(\ref{eq:weight_lc})). As long as the number of priority groups is 
a bounded integer independent of  and , the complexity remains .




\section{Numerical Results} \label{sec:sim}
In this section, we conduct numerical experiments to elucidate our theoretical results. We also compare the empirical 
performance of our proposed NSB and LC-NSB algorithms with several most relevant algorithms as listed in Table~\ref{tab:com}.

\subsection{Throughput Performance}\label{subsec:throughput}
\high{To evaluate the throughput performance, we run the simulations on three different network topologies as shown in Fig.~\ref{fig:topologies}.}
We first focus on a randomly generated triangular mesh topology with 30 nodes and 79 links as shown in Fig.~\ref{fig:triangle_top}. 
The simulations are implemented using C++. We assume that the arrivals are \emph{i.i.d.} over all the links with unit capacity. 
The mean arrival rate of each link is , and the instantaneous arrivals to each link follow a Poisson distribution in each 
time-slot. In Fig.~\ref{fig:triangle_result}, we plot the average total queue length in the system against the arrival rate . 
We consider several values of  as indicated in Fig.~\ref{fig:triangle_result}. For each value of , the average 
total queue length is an average of 10 independent simulations. Each individual simulation runs for a period of  time-slots. 
We compute the average total queue length by excluding the first  time-slots in order to remove the impact of the 
initial transient state. Note that this network topology contains odd-size cycles. Hence, our proposed NSB and LC-NSB only 
guarantee to achieve  of the optimal throughput. However, the simulation results in Fig.~\ref{fig:triangle_result} show 
that NSB and LC-NSB algorithms both empirically achieve the optimal throughput performance. 
\HIGH{
This is because the odd-size cycles (i.e., all the triangles in this case) do not form the bottlenecks in this setting. 
For example, a triangle requires  because at most one of its three links can be scheduled in each time-slot.
However, in Fig.~\ref{fig:triangle_top} there exists a node touched by seven links, which requires . 
As the load  increases, such a node will become congested sooner than any triangle and thus forms a scheduling bottleneck.
}



\high{We also conduct simulations for a 44 grid topology with 16 nodes and 24 links (Fig.~\ref{fig:grid_top}) 
and a randomly generated dense topology with 100 nodes and 248 links (Fig.~\ref{fig:random_top}).
All the other simulation settings are the same as that for the triangular mesh topology.  
The simulation results are presented in Fig.~\ref{fig:results_poi}.
}
The observations we make are similar to that for the triangular 
mesh topology, except that in the grid topology, LC-NSB has higher delays when the mean arrival rate approaches 
the boundary of the optimal throughput region. This is due to the following two reasons: 1) Under LC-NSB, all the 
non-heavy nodes are in the same priority group of weight 1, so a non-heavy node with a large workload would have
a similar chance of getting scheduled as a non-heavy node with a small workload; 2) In the grid topology, the bottleneck
nodes (i.e., the four nodes in the center) are all adjacent. Note that in most cases, at least one of the bottleneck nodes
is the critical node and will have the highest priority. If another bottleneck node is adjacent to the critical node but is not
a heavy node, this bottleneck node will get a lower chance of being scheduled, since the critical node could be matched
with other node. This inefficiency does not occur under NSB, since the node weights of the non-heavy nodes are their
workload and are more fine-grained. Hence, a non-heavy node with a large workload will have a higher priority than a 
non-heavy node with a small workload.

\HIGH{
In order to evaluate the throughput performance under different arrival patterns,
we also run simulations for file arrivals. Specifically, the arrivals have the following pattern: in each time-slot, there 
is a file arrival with probability , and no file arrival otherwise; the file size follows Poisson distribution with mean .
The simulation results for  are presented in Fig.~\ref{fig:results_file}.
Similar observations to that for Poisson arrivals can be made, except that all the algorithms have larger delays due to 
a more bursty arrival pattern. 
In addition, we also consider more realistic arrival patterns where the arrivals in each time-slot follow the Zipf law, 
which is commonly used to model the Internet traffic \cite{feldmann04}. We assume a support of \HIGH{} 
for the Zipf distribution. 
The power exponent of the Zipf distribution is determined based on the mean arrival rate . 
The simulation results are presented in Fig.~\ref{fig:results_zipf}. 
The overall observations are again similar to that for the previous arrival patterns.

Finally, it is remarkable that in all simulation settings we consider, our proposed node-based algorithm NSB empirically 
achieves the best delay performance. When the traffic load is high, NSB even results in a significant reduction (10\%-30\%) 
in the average delay performance compared to the link-based algorithms such as MWM (e.g., in Fig.~\ref{fig:random_result_zipf} 
for a random topology with Zipf arrivals, the delay reduction is about 30\% when ).
Although NSB ties with another node-based algorithm MVM for the empirical delay performance, as we discussed in the introduction, 
the throughput performance of MVM is not well understood yet.
}










\high{
\subsection{Evacuation Time Performance}
In this subsection, we evaluate the evacuation time performance of our proposed algorithms.
As we discussed in the introduction, the minimum evacuation time problem is equivalent to 
the classic multigraph edge coloring problem, for which there are common benchmarks.
Therefore, we run simulations for six DIMACS benchmark instances~\cite{dimacs} for the graph coloring problem. 
In addition, we also run simulations for three regular multigraphs, \HIGH{three random multigraphs,} and one special graph 
(Fig.~\ref{fig:graphN} with ).

The evacuation time performance for each of the considered algorithms under each graph is presented 
in Table~\ref{tab:benchmark}. 
The simulation results show that all the algorithms have very similar evacuation time performance for the 
considered benchmark graphs and regular multigraphs, although they have different theoretical guarantees.
For the special graph in Fig.~\ref{fig:graphN}, we can observe that the node-based algorithms exhibit a much 
better evacuation time performance compared to the link-based algorithms \HIGH{(e.g., MWM and GMM)}. 
Specifically, the link-based algorithms require about twice as much time as that of the node-based algorithms 
to evacuate all initial packets in the network.
}








\section{Conclusion} \label{sec:con}
In this paper, we studied the link scheduling problem for multi-hop wireless networks 
and focused on designing efficient online algorithms with provably guaranteed throughput and evacuation 
time performance. We developed two node-based service-balanced algorithms and showed that none of 
the existing algorithms strike a more balanced performance guarantees than our proposed algorithms in 
both dimensions of throughput and evacuation time. 
\HIGH{An important future direction is to consider more general models (which, e.g., allow for multi-hop traffic, 
general interference models, and time-varying channels). In such scenarios, it becomes much more challenging 
to provide provably good evacuation time performance.}

\begin{table}[t!]
\centering
\begin{tabular}{c|c c c c c c }
\hline
Graph & MWM  & GMM & MVM & NSB & LC-NSB &  \rule{0pt}{2ex}\rule[-1ex]{0pt}{0pt}\\ 
\hline
dsjc125.1 &	23&	23&	23&	23&	23&	23 \\
dsjc125.5 &	76&	75&	75&	75&	75	&	75\\
dsjc125.9 &	140&	120&	120&	120&	120 &	120\\
dsjc250.1 &	38&	40&	38&	38&	38	&	38\\
dsjc250.5 &	147&	153&	147&	147&	147 &	147\\
dsjc250.9 &	234&	234&	234&	234& 234&	234\\
\hline
regm50.20 &	20&	 25&	 20&	 20&	 20&	 20 \\
regm50.50 & 	50&	 55&	 51&	 51&	 51&	 50 \\
regm50.80 &	80&	 84&  80&	 80&	 80&	 80 \\
\hline
rand100.50 &	366&	 366& 366&  366&  366&  366 \\
rand100.100 & 	813&	 813&  813&  813&  813&  813 \\
rand100.250 &	2161&  2161&  2161&  2161&  2161&  2161 \\
\hline
Fig.~\ref{fig:graphN} &  199& 199& 101& 101& 101& 101 \\
\hline 
\end{tabular}
\centering
\caption{Evacuation time performance for six DIMACS benchmark graphs~\cite{dimacs}, three regular multigraphs,
and one special graph (Fig.~\ref{fig:graphN} with ). In the table,  denotes the maximum node degree,
dsjcX.Y denotes the label of the DIMACS benchmark graphs, regmX.Y denotes a regular mutigraph with X nodes and 
node degree Y, \HIGH{and randX.Y denotes a random topology in Fig.~\ref{fig:random_top} with X nodes and the number 
of multi-edges at each link being uniformly distributed over the interval [0,Y].}}
\label{tab:benchmark}
\end{table}





\section{Proofs} \label{sec:proofs}




\subsection{Proof of Proposition~\ref{pro:nsb}}\label{sec:pro:nsb}
We first restate a useful result of \cite{anstee96} in Lemma~\ref{lem:delta}, which will be used 
in the proof of Proposition~\ref{pro:nsb}. \high{Throughout the paper, we assume that the multigraph
is loopless (i.e., there is no edge connecting a node to itself) unless explicitly mentioned.}

\begin{lemma}[Theorem~1 of \cite{anstee96}]
\label{lem:delta}
Let  be a loopless multigraph with maximum degree . Let  denote 
the subgraph of  \high{induced\footnote{\high{An induced subgraph of a graph is formed from 
a subset of the nodes of the graph and all of the edges whose endpoints are both in this subset.}}}
by all the nodes having maximum degree. If  
is bipartite, then there exists a matching over  that matches every node of maximum degree.
\end{lemma}

Now, we are ready to prove Proposition~\ref{pro:nsb}. 


\begin{proof}[Proof of Proposition~\ref{pro:nsb}]
First, note that in any time-slot, the network together with the present packets can be 
represented as a loopless multigraph.
Recall that  denotes the multigraph at the beginning of time-slot  and 
 denotes the matching found by the NSB algorithm in time-slot . Also, recall 
that the degree of node  in  is equivalent to the node queue length 
, and the maximum node degree of  is equal to .
\high{Now, consider any frame  consisting of three consecutive time-slots 
, where . 
Suppose that the maximum node queue length is no smaller than two at the beginning of 
frame , i.e.,  at the beginning of time-slot .}
Then, we want to show that under the NSB algorithm, the maximum degree will be 
at most  at the end of time-slot .
We proceed the proof in two steps: 
1) we first show that the maximum degree will decrease by at least one in the first 
two time-slots  and  (i.e., the maximum degree will be at most 
at the end of time-slot ),
and then, 2) show that if the maximum degree decreases by exactly one in the first 
two time-slots (i.e., the maximum degree is  at the end of time-slot ), 
then the maximum degree must decrease by one in time-slot , and becomes 
 at the end of time-slot . 

We start with step 1). It is a trivial case if the maximum degree decreases by one in time-slot . 
Therefore, suppose the maximum degree does not decrease in time-slot . Then, it suffices to 
show that all the nodes having maximum degree  in  must be scheduled in 
time-slot  under the NSB algorithm. Note that matching  must be a maximal matching 
over  for every time-slot . Since  is a maximal matching, the nodes having 
maximum degree must form an independent set over  at the beginning of time-slot 
. We prove this by contradiction. 
\high{Note that if there is only one node having maximum degree at the beginning of time-slot , 
then it is trivial that the subgraph induced by this single node must consist of this node itself only and 
thus forms an independent set.} 
So we consider the case where there are at 
least two nodes having maximum degree at the beginning of time-slot . Suppose node  
and node  are two adjacent nodes having maximum degree  at the beginning of time-slot 
. Then, none of the edges incident to either  or  was in matching . This implies 
that the edge between  and  can be added to matching  in time-slot , which, however, 
contradicts the fact that  is a maximal matching. Therefore, the nodes having maximum degree 
must form an independent set at the beginning of time-slot . 
\high{Clearly, the subgraph induced by all the nodes having maximum degree forms an independent set 
and thus has no edges. In this case, it is trivial that this induced subgraph is bipartite}. 
Then, by Lemma~\ref{lem:delta}, there exists a matching \high{over } that matches all the 
nodes having maximum degree 
in time-slot . Note that  is an MVM over  with the assigned node weights 
(as in Eq.~(\ref{eq:weight})) under the NSB algorithm. It is also easy to see that all the nodes with 
maximum degree  are among the ones with the heaviest weight, as they have a weight of 
 and the weight of all the other nodes is less than . Hence, it implies from 
Lemma~\ref{lem:path} that matching  also matches all the nodes having maximum degree, 
i.e., the maximum degree decreases by one in time-slot . This completes the proof of step 1).

Now, we prove step 2).
Clearly, the maximum degree becomes  at the beginning of time-slot . Recall
that  denotes the set of critical nodes. We want to show that all the nodes in 
 will be matched in time-slot . We first show that all the nodes in  
are among the ones with the heaviest weights at the beginning of time-slot . This is true 
due to the following. It is easy to see that for any node , it was matched at most 
once in time-slots  and . Hence, according to the weight assignments in Eq. (\ref{eq:weight}), 
node  has a weight of , while all the nodes in  must 
have a degree less than  and thus have a weight less than . Therefore, 
all the nodes in  are among the ones with the heaviest weights.

Let  denote the subgraph of  induced by all the nodes in 
. If  is bipartite, then again by Lemmas~\ref{lem:path} 
and \ref{lem:delta}, following the same argument as in step 1), we can show that matching 
 matches all the nodes in  in time-slot . Therefore, it 
remains to show that  is bipartite. We prove this by contradiction. 
Suppose  contains an odd cycle, say . Then, no two adjacent nodes 
of  were matched by  in time-slot . This is true due to the following. 
Suppose there exist two adjacent nodes of , say  and , matched by . 
Since  and  are in  (i.e., their degree is  in time-slot ), then
they both have maximum degree  at the beginning of time-slot . However, given 
that  and  are adjacent in  (and are thus adjacent in  as well), 
this contradicts what we have shown earlier -- the nodes of degree  in  
form an independent set. Therefore, no two adjacent nodes of  were matched by  
in time-slot . This, along with the fact that cycle  is of odd size, implies that cycle  
must contain two adjacent nodes that were not matched by  in time-slot . This 
further implies that the edge between these two adjacent nodes can be added to , 
which contradicts the fact that  is a maximal matching over . Therefore, 
the induced subgraph  must be bipartite. This completes the proof of step 2), 
as well as the proof of Proposition~\ref{pro:nsb}.
\end{proof}






\subsection{Proof of Lemma~\ref{lem:2in3}} \label{sec:lem:2in3}
\begin{proof}
Recall that  is the set of critical nodes in the fluid limits at scaled time  (Eq.~(\ref{eq:critical})).
We want to show that under the NSB algorithm, all the nodes in  will be scheduled at least 
twice within \high{each frame of interval }.

First, recall that  is large enough such that 
 for all times
. Hence, from condition (C1) and (C2), the queue lengths 
in the original system satisfy the following conditions for all time-slots : 

(C1*)  for all ;

(C2*)  for all .

\noindent On account of condition (C1*) and Eq.~(\ref{eq:heavy}), all the 
nodes in  are heavy nodes in all the time-slots of , i.e., 
 for all  and for all .

Note that in any time-slot, the network together with the present packets can be mapped to a 
multigraph, where each multi-edge corresponds to a packet. Recall that we use  to 
denote the multigraph at the beginning of time-slot . Note that if there are no packets waiting 
to be transmitted over a link, no multi-edge connecting the end nodes of this link will appear in 
. Also, recall that  denotes the matching found by the NSB algorithm in time-slot . 
\high{Now, consider any frame  of interval  consisting of three consecutive time-slots 
, where .} 
We want to show that under the NSB algorithm, every node in 
 will get scheduled in at least two time-slots of . We proceed the proof in 
two steps: 1) we first show that all the nodes in  will be scheduled at least once in the first 
two time-slots  and , and 2) then show that all the nodes in  that were scheduled 
exactly once in the first two time-slots, will get scheduled in time-slot . 

We start with step 1). Let  denote the set of nodes in  that were not 
scheduled in time-slot . It is a trivial case if . Therefore, 
suppose , i.e., there exists at least one node in  that 
was not scheduled in time-slot . Then, it suffices to show that all the nodes in  
must be scheduled in time-slot  under the NSB algorithm. Note that matching  
must be a maximal matching over  for every time-slot . Since  is 
a maximal matching, the nodes in  must form an independent set at the 
beginning of time-slot , excluding the multi-edges corresponding to the new packet 
arrivals at the beginning of time-slot . 

Note that it is a trivial case if . So we consider the case of 
 and prove it by contradiction. Suppose there exist two 
adjacent nodes . Then, none of the edges incident to either  or 
 was in matching . This implies that the multi-edge between  and  could 
be added to matching  in time-slot , which, however, contradicts the fact that 
 is a maximal matching. Therefore, the nodes in  must form an 
independent set at the beginning of time-slot . 
\high{Clearly, the subgraph induced by all the nodes in  forms an independent set 
and thus has no edges. In this case, it is trivial that this induced subgraph is bipartite.} 
Note that conditions (C1*) and (C2*) still hold even without accounting for the new packet arrivals. 
Then, by Lemma~\ref{lem:existence}, there exists a matching that matches all the nodes 
in  at the beginning of time-slot  before new packet arrivals. Clearly, 
such a matching still exists even if the multi-edges corresponding to the newly arrived 
packets in time-slot  are added to the grpah. Note that  is an MVM over 
 with the assigned weights (as in Eq.~(\ref{eq:weight})). Now, if all the 
nodes in  are among the ones with the heaviest weights, then it implies 
from Lemma~\ref{lem:path} that matching  also matches all the nodes in 
. This is indeed true due to conditions (C1*) and (C2*), as well as the 
weight assignments in Eq.~(\ref{eq:weight}): every node in  was not 
scheduled in time-slot , and thus has a weight larger than , 
while any node in  cannot have a weight larger than 
.

Now, we prove step 2).
Let  denote the set of nodes in  that were scheduled exactly 
once in time-slots  and . We want to show that all the nodes in  
will get scheduled in time-slot . Note that all the nodes in  are 
among the ones with the heaviest weights. This is true due to conditions (C1*) and (C2*), 
as well as the weight assignments in Eq.~(\ref{eq:weight}): every node in  
was scheduled exactly once in time-slots  and , and thus has a weight larger than 
, while any node in  cannot 
have a weight larger than . Further, 
let  denote the subgraph induced by all the nodes in 
 at the beginning of time-slot , excluding all the multi-edges 
corresponding to the packets that arrived in time-slot  and . 
If  is bipartite, then again by Lemmas~\ref{lem:existence} 
and \ref{lem:path}, following the same argument as in step 1), we can show that all the 
nodes in  are matched by  in time-slot . Therefore, 
it remains to show that  is bipartite. 

Next, we prove that  is bipartite by contradiction. Suppose 
 contains an odd cycle, say . Then, no two adjacent 
nodes of  were matched by  in time-slot . This is true due to the following. 
Suppose there exist two adjacent nodes of , say  and , matched by . 
Since  and  are in , both of them were matched exactly once in 
time-slots  and  from the definition of . This implies that both 
 and  were not matched in time-slot , i.e., we have . However,
given that  and  are adjacent, this contradicts what we have shown earlier -- the nodes 
in  form an independent set. Therefore, no two adjacent nodes of  were 
matched by  in time-slot . This, along with the fact that cycle  is of odd size, 
implies that cycle  must contain two adjacent nodes that were not matched by  
in time-slot . This further implies that the multi-edge between these two adjacent nodes 
can be added to , which contradicts the fact that  is a maximal matching 
over . Therefore, the induced subgraph  must 
be bipartite. This completes the proof of step 2) and that of Lemma~\ref{lem:2in3}.
\end{proof}














\bibliographystyle{IEEEtran}
\bibliography{nsb}

\begin{IEEEbiography}{Yu Sang}
received his B.E. degree in Electronic Information Engineering from
University of Science and Technology of China in 2014. He is currently
a Ph.D. student in the CIS department at Temple University. His research
interests are in wireless networks and cloud computing systems.
\end{IEEEbiography}

\begin{IEEEbiography}{Gagan R. Gupta}
received the Bachelor of Technology degree in Computer Science and 
Engineering from the Indian Institute of Technology, Delhi, India in 
2005. He received the M.S. degree in Computer Science from University 
of Wisconsin, Madison in 2006. He received his Ph.D. degree from Purdue 
University, West Lafayette, Indiana in 2009 for his dissertation titled 
``delay efficient control policies for wireless networks." His research 
interests are in performance modeling and optimization of communication 
networks and parallel computing. He is currently working in the telecommunications 
industry.
\end{IEEEbiography}

\begin{IEEEbiography}{Bo Ji}(S'11-M'12)
received his B.E. and M.E. degrees in Information Science and Electronic 
Engineering from Zhejiang University, China in 2004 and 2006, respectively. 
He received his Ph.D. degree in Electrical and Computer Engineering from 
The Ohio State University in 2012. He is currently an assistant professor of 
the CIS department at Temple University, Philadelphia, PA, and is also a 
faculty member of the Center for Networked Computing (CNC). Prior to joining 
Temple University, he was a Senior Member of Technical Staff with AT\&T Labs, 
San Ramon, CA, from January 2013 to June 2014. His research interests are 
in the modeling, analysis, control, and optimization of complex networked systems, 
such as communication networks, information-update systems, cloud/datacenter 
networks, and cyber-physical systems.
Dr. Ji received National Science Foundation (NSF) CAREER Award and 
NSF CISE Research Initiation Initiative (CRII) Award both in 2017.
\end{IEEEbiography}

\clearpage

\appendices

\section{Existence of Fluid Limits (Eqs.~\eqref{eq:fluid_a}-\eqref{eq:fluid_h})} \label{sec:fluid}
\begin{proof}
The proof follows a similar line of analysis in \cite{dai00}. Consider a fixed sample path . 
For notational simplicity, in the following proof we omit the dependency on .
Recall that a sequence of functions  converges to  uniformly 
on compact (\emph{u.o.c.}) intervals if for every , it is satisfied that 
.

First, for each , we define the following:

Note that in each time-slot, only one matching can be chosen, and each node is scheduled at
most once. Hence, both  and  are a uniformly bounded sequence 
of functions with bounded Lipschitz constant. Specifically, for any  and , 
the following is satisfied:

and similarly,

Then, the Arzela-Ascoli Theorem (e.g., see \cite{resnick13}) implies that for any positive sequence , 
there exists a subsequence  with  as  and continuous
functions  and  such that for any ,

Also, it is easy to see that 

for all the sample paths that satisfy the SLLN assumption (i.e., Eq.~\eqref{eq:slln_l}).
By combining Eqs.~\eqref{eq:uoc_d} and \eqref{eq:uoc_a}, we have that, for almost all sample 
paths (i.e., those that satisfy the SLLN assumption) and for any positive sequence , 
there exists a subsequence  with  as 
and continuous function  such that for any , 

and Eqs.~\eqref{eq:uoc_h} and \eqref{eq:uoc_d} hold.
This completes the proof of the convergence in Eqs.~\eqref{eq:fluid_a}-\eqref{eq:fluid_h}.
\end{proof}



\section{Proof of Theorem~\ref{thm:nsb_opt}} \label{sec:thm:nsb_opt}
\begin{proof}
Suppose that the underlying network graph is bipartite.
We first show that NSB achieves evacuation time optimality. Recall that for a given network 
with initial packets waiting to be transmitted,  denotes the maximum node degree at the 
very beginning, and  denotes the minimum evacuation time. If the underlying network is bipartite, 
there are no odd-size cycles, and we have  (e.g., see \cite{konig16,kapoor00,guptathesis}). 
Hence, if the maximum degree decreases by one in every time-slot, the minimum evacuation time can be achieved. 
Therefore, we want to show that in every time-slot, all the critical nodes are matched under NSB.


Consider any time-slot . Since the underlying network graph is bipartite, it is obvious that the subgraph
induced by all the heavy nodes is also bipartite. By Lemma~\ref{lem:existence}, we have that there exists 
a matching that matches all the heavy nodes. Due to the weight assignment rule in Eq.~\eqref{eq:weight},
we have  for any  and any . This is because
the weight of any heavy node is equal to either its queue length or twice its queue length, which is at least 
, i.e.,  for any , and the weight of 
any non-heavy node is equal to its queue length, which is less than , i.e., 
 for any . 
Then, due to Lemma~\ref{lem:path}, NSB matches all the heavy nodes, including all the critical nodes.
Therefore, NSB is evacuation-time-optimal.

Next, we show that NSB is throughput-optimal.
The analysis follows a similar line of argument as in the proof of Theorem~\ref{thm:nsb_throughput} 
for general graphs. We now want to show that for any given arrival rate vector  strictly inside 
, the system is rate stable under the NSB algorithm. Note that  is also strictly 
inside  (i.e.,  for all ) since .
(In fact, we have  for bipartite graphs.) 
We define . Clearly, we must have . 

Similarly, we proceed the proof using the fluid limit technique. 
Recall that existence of fluid limits (i.e., Eqs.~\eqref{eq:fluid_a}-\eqref{eq:fluid_h}) has been shown 
in Section~\ref{sec:fluid}. We also have the fluid model equations (i.e., Eqs.~\eqref{eq:qqld}-\eqref{eq:diff}).
Then, to show rate stability of the original system, it suffices to show weak stability of the fluid model 
due to Lemma~\ref{lem:weak2rate}. Recall that the Lyapunov function is defined as 
.
We want to show that if  for , then  has a negative drift. 
Specifically, we want to show that for all regular times , if , we have .

Recall that  is the set of critical nodes in the fluid limits at scaled time  (Eq.~(\ref{eq:critical})),
 denotes a positive subsequence for which the convergence to the fluid limit holds,
and  denotes 
a set of consecutive time-slots in the original system corresponding to the scaled time interval  
in the fluid limits, where  is a small enough positive number. Now, if we can show that under 
the NSB algorithm, all the nodes in  will be scheduled in every time-slot of interval , i.e.,
for all , we have , then we can show  (similar to Eq.~\eqref{eq:dh}),
and thus, it follows from Eq. (\ref{eq:diff}) that for all , we have .

We know from the proof of Lemma~\ref{lem:2in3} that all the nodes in  are heavy nodes in 
every time-slot of . Then, following our earlier proof of evacuation time optimality and using 
Lemmas~\ref{lem:existence} and \ref{lem:path}, we can show that all the nodes in  will be 
scheduled in every time-slot of interval . This completes the proof of Theorem~\ref{thm:nsb_opt}.
\end{proof}



\section{Proof of Theorem~\ref{thm:lc_nsb}} \label{sec:thm:lc_nsb}
\begin{proof}
The proof is almost the same as that of Theorems~\ref{thm:nsb_et}, \ref{thm:nsb_throughput}, 
and \ref{thm:nsb_opt} for the NSB algorithm.
Hence, in the following we mainly focus on explaining the key differences of the proof and omit the details.

We first want to show that the LC-NSB algorithm has an approximation ratio no greater than  
for the evacuation time. From the proof of Theorem~\ref{thm:nsb_et}, it is not difficult to see that 
the result follows exactly if Proposition~\ref{pro:lc_nsb} (similar to Proposition~\ref{pro:nsb} 
for NSB) holds.

\begin{proposition}
\label{pro:lc_nsb}
Consider any frame.
Suppose the maximum node queue length is no smaller than two at the beginning of a frame. 
Under the LC-NSB algorithm, the maximum node queue length decreases by at least two 
by the end of the frame.
\end{proposition}

The proof of Proposition~\ref{pro:lc_nsb} is the same as that of Proposition~\ref{pro:nsb},
except that we need to replace both  and  in the proof 
of Proposition~\ref{pro:nsb} with 5. This is due to the new way of assigning the 
node weights in Eq.~\eqref{eq:weight_lc} under the LC-NSB algorithm.

Next, we want to show that the LC-NSB algorithm has an efficiency ratio no smaller than  for the throughput.
From the proof of Theorem~\ref{thm:nsb_throughput}, it is not difficult to see that the result follows exactly 
if Lemma~\ref{lem:2in3_lc} (similar to Lemma~\ref{lem:2in3} for NSB) holds.
Recall that  is the set of critical nodes in the fluid limits at scaled time  (Eq.~(\ref{eq:critical})).

\begin{lemma}
\label{lem:2in3_lc}
Under the LC-NSB algorithm, all the nodes in  will be scheduled at least twice within 
\high{each frame of interval }.
\end{lemma}

The proof of Lemma~\ref{lem:2in3_lc} is the same as that of Lemma~\ref{lem:2in3},
except that we need to replace both  and  
in the proof of Lemma~\ref{lem:2in3} with 3. This is due to the new way of assigning the 
node weights in Eq.~\eqref{eq:weight_lc} under the LC-NSB algorithm.
 
Finally, we want to show that the LC-NSB algorithm is both throughput-optimal 
and evacuation-time-optimal in bipartite graphs.
The proof of this part is the same as that of Theorem~\ref{thm:nsb_opt},
except that we need to replace  in the proof 
of Theorem~\ref{thm:nsb_opt} with 2. This is because the weight of any heavy 
node is at least 2 and the weight of any non-heavy node is equal to 1 in all time-slots,
due to the new way of assigning the node weights in Eq.~\eqref{eq:weight_lc} under the LC-NSB algorithm. 
\end{proof}

\end{document}
