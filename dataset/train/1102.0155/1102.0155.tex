
\documentclass[11pt,aslarticle,xperspectives,bibay3]{asl}
\usepackage{listings}
\usepackage{bk0,bk1,bm}
\usepackage[mathscr]{euscript}
\usepackage[matrix,arrow]{xy}
\xyoption{curve}
\CompileMatrices
\usepackage[english]{babel}
\usepackage{geometry}   
\geometry{a4paper}    
\usepackage{epic}
\usepackage{graphicx}
\usepackage{proof}
\usepackage{color}
\usepackage{color}
\usepackage{robustmultind}

\newcommand\redalpha{\mathrel{\rightarrow_{\alpha}}}
\newcommand\redmu{\mathrel{\rightarrow_{\mu}}}
\newcommand\redmucl{\mathrel{\rightarrow_{[\mu]}}}
\newcommand\redmualpha{\mathrel{\rightarrow_{\mu/\alpha}}}
\newcommand\redmualphastar{\mathrel{\rightarrow^{\ast}_{\mu/\alpha}}}
\newcommand\redmua{\mathrel{\rightarrow_{\mu'}}}
\newcommand\redmustar{\mathrel{\rightarrow^{\ast}_{\mu}}}
\newcommand\redmuastar{\mathrel{\rightarrow^{\ast}_{\mu'}}}
\newcommand\tamua{\type_{\mu'}}
\newcommand\tamucl{\type_{[\mu]}}
\newcommand\tmua{\type_{\mu'}}
\newcommand\prmua{\vdash_{\mu'}}
\newcommand\prmuacl{\vdash_{[\mu']}}
\newcommand\weakmualphaeq{=_{\mu/\alpha}}
\newcommand\weakeqcl{=_{[\mu]}}
\newcommand\redst{\mathrel{\rightarrow^{\ast}_{st}}}
\newcommand\redstl{\mathrel{\leftarrow^{\ast}_{st}}}
\newcommand\alphaarrow{\vec{\alpha}}
\newcommand\alphaiarrow{\vec{\alpha_i}}
\newcommand\alphaeenarrow{\vec{\alpha_1}}
\newcommand\alphatweearrow{\vec{\alpha_2}}
\newcommand\betaiarrow{\vec{\beta_i}}
\newcommand\betaeenarrow{\vec{\beta_1}}
\newcommand\betatweearrow{\vec{\beta_2}}
\newcommand\betaarrow{\vec{\beta}}
\newcommand\restricted{\!\!\upharpoonright\!\!}
\newcommand\eqalpha{\mathrel{=_{\alpha}}}
\newcommand\SC{{\mbox {SC}}} 
\begin{document}
\newcount\mscount
\renewcommand\labelx[1]{\label{#1}}
\renewcommand\refx[2]{\ref{#1}}
\renewcommand\partt[1]{\part{#1}}
\renewcommand\ldots\cdots
\renewcommand\hb[1]{{#1}}
\renewcommand\Red[1]{{#1}}
\renewcommand\bchh{{}}
\renewcommand\echh{{}}
\renewcommand\hbweg[1]{{}}
\pagenumbering{arabic}

{

\renewcommand{\TT}{{\cal A}}
\renewcommand{\SS}{{\cal B}}

\newcommand{\testo}[1]{~\mbox{#1}~}
\newcommand{\profinites}{\mathcal{CU}}    \newcommand{\TypesOver}[1]{\mathcal{S}(#1)}
\newcommand{\TATypes}{{\sf T} \!\!\! {\sf T}}
\newcommand{\assstrongapp}{\vdash_{\lambda \mu^{\star\infty}}}  \newcommand{\strongapp}{{\lambda \mu^{\star\infty}}}


\newcommand{\ato}{\to}
\newcommand{\primeset}[1]{||#1||}
\newcommand{\notrel}{\not\!\!\rel}
\newcommand{\subty}{{\cal S}}
\newcommand\solstar[1]{\cour{sol}^{\star}({#1})}
\def\T{\type}


\renewcommand{\to}{\! \rightarrow \!}
\def\Tcons{{\sf C} \! \! {\sf C}}     

\def\types{\type}
\newcommand{\Types}{{\type}^{\!\mu}}
\newcommand\typems{\type^{\star}_\mu}
\newcommand{\Typesplus}{{\type}_{\mu}^+}
\newcommand{\SimpleTypes}{\type}
\newcommand{\ATypes}[1]{{\type}_{\small #1}}
\newcommand{\CTypes}[1]{{\type}_{c_1,\ldots,c_{#1}}}
\newcommand{\contrTypes}{{\type}^{\mu c}}
\newcommand{\reg}{\rm{\hb{R}}}
\newcommand{\mt}[2]{\mu #1 . #2}
\newcommand{\mtu}[2]{#2[#1:=\mu #1.#2]}
\newcommand{\GTypes}{{\sf T \!\! \! T}}
\newcommand{\atset}{{\bf A}}
\newcommand{\undef}{\bottom}

\newcommand{\stc}{\EE}                     

\newcommand{\srcr}{{\cal R}^\diamond}

\newcommand{\inv}[1]{{#1}^{\rm inv}} \newcommand{\simple}[1]{{\inv{#1}}^-}

\newcommand{\sre}[1]{(#1)^{\star}}
\newcommand{\princ}[1]{\overline{#1}}

\newcommand{\Pstc}[1]{\stc_{#1}}
\newcommand{\PG}[1]{\Gamma_{#1}}
\newcommand{\PT}[1]{a_{#1}}




\newcommand{\Kcomb}{\mbox{\bf K}}
\def\two{\mbox{\bf two}}
\newcommand{\auto}{\lambda x . x  x}
\newcommand{\Tauto}[2]{\mt{#1}{(#1 \to #2)}}
\newcommand{\fauto}[1]{\lambda x . #1 (x  x)}
\newcommand{\fixpoint}{\lambda f.(\fauto{f})(\fauto{f})}
\newcommand{\Tdelta}{T_{\Delta}}
\newcommand{\typeof}[1]{\tau(#1)}
\newcommand{\fail}{\mbox{FAIL}}
\renewcommand{\int}{\mbox{\bf int}}







\newcommand{\prfmuw}{\vdash_{\mu}}
\newcommand{\prfmus}{\vdash_{\mu^{\star}}}
\newcommand{\prfCw}[1]{\vdash_{#1}}
\newcommand{\prfCs}[1]{\vdash_{#1}^{\star}}
\newcommand{\prfCsAK}{\vdash_{\mu^{\star} {\AK}}}
\newcommand{\prfCwinv}[1]{\vdash_{#1}^{\rm inv}}

\newcommand{\eqmu}{\vdash_{\mu}}   \newcommand{\eqC}[1]{\vdash_{#1}}
\newcommand{\eqmuw}{\vdash_{\mu\sim}}
\newcommand{\eqCw}[1]{\vdash_{#1}}
\newcommand{\eqCwinv}{\vdash^{\star}_{\sim}}
\newcommand{\eqmus}{\vdash_{{\rm BH}}}
\newcommand{\eqmusAK}{\vdash_{\mu^{\star} {\AC}}}
\newcommand{\eqCs}{\vdash_{\approx}}

\newcommand{\weqsys}[1]{\vdash_{#1}}
\newcommand{\seqsys}[1]{\vdash_{{#1}^{\star}}}




\newcommand{\assR}{\vdash_{\lambda\mu^{\sharp}}}
\newcommand{\assmu}{\vdash_{\lambda\mu^-}}
\newcommand{\asseq}{\assweak}
\newcommand{\assweak}{\vdash_{\lambda\mu}}
\newcommand{\assweakplus}{\vdash_{\lambda\mu +}}
\newcommand{\assstrong}{\vdash_{\lambda\mu^{\star}}}


\newcommand{\assTA}[1]{\vdash_{#1}}

\newcommand{\assCR}[1]{\vdash_{\lambda {#1}^{\sharp}}}
\newcommand{\assCeq}[1]{\assCweak{#1}}
\newcommand{\assCweak}[1]{\vdash_{\lambda #1}}
\newcommand{\assCstrong}[1]{\vdash_{\lambda {#1}^{\sharp}}}
\newcommand{\assCgen}{\vdash_{\lambda \geneq}}


\newcommand{\assChTA}[1]{\vdash_{\lambda {#1}^{\rm Ch}}}
\newcommand{\assCh}{\vdash_{\lambda_\mu^{\rm Ch}}}
\newcommand{\assChweak}{\vdash_{\lambda_\mu{\rm Ch}}}
\newcommand{\assChweako}{\vdash_{\lambda\mu{\rm Ch}_0}}
\newcommand{\assChstrong}{\vdash_{\lambda\mu^{\star} {\rm Ch}}}
\newcommand{\assChR}{\vdash_{\lambda\relmu{\rm Ch}}}
\newcommand{\assCCh}[1]{\vdash_{\lambda{\rm Ch}{\Ceq{#1}}}}
\newcommand{\assCChweak}[1]{\vdash_{\lambda{\rm Ch}{\weakCeq{#1}}}}
\newcommand{\assCChstrong}[1]{\vdash_{\lambda{\rm Ch}{\strongCeq{#1}}}}

\newcommand{\assdBTA}[1]{\vdash_{\lambda {#1} \text{-dB}}}
\newcommand{\assdB}{\vdash_{\lambda\mu{\rm dB}}}
\newcommand{\assdBweak}{\vdash_{\lambda\mu{\rm dB}}}
\newcommand{\assdBweako}{\vdash_{\lambda\mu{\rm dB}_0}}
\newcommand{\assdBstrong}{\vdash_{\lambda\mu^{\star} {\rm dB}}}
\newcommand{\assdBR}{\vdash_{\lambda\relmu{\rm dB}}}
\newcommand{\assCdB}[1]{\vdash_{\lambda{\rmdB}{\Ceq{#1}}}}
\newcommand{\assCdBweak}[1]{\vdash_{\lambda{\rm dB}{\weakCeq{#1}}}}
\newcommand{\assCdBstrong}[1]{\vdash_{\lambda{\rm dB}{\strongCeq{#1}}}}




\newcommand{\Equiv}{\mbox{(equal)}}
\newcommand{\ruleCweak}{\mbox{()}}
\newcommand{\ruleCstrong}{\mbox{()}}

\newcommand{\rulefold}{\mbox{(fold)}}
\newcommand{\ruleunfold}{\mbox{(unfold)}}
\newcommand{\ruleweak}{\mobx{()}}
\newcommand{\rulestrong}{\mobx{()}}
\def\ax{\mbox{(axiom)}}
\newcommand{\const}{\mbox{(const)}}
\newcommand{\eqaxmu}{\mbox{(-eq)}}
\newcommand{\eqaxsr}{\mbox{(-eq)}}
\newcommand{\eqaxC}{\mbox{(eq)}}
\newcommand{\ident}{\mbox{(ident)}}
\newcommand{\reflex}{\mbox{(symm)}}
\newcommand{\trans}{\mbox{(trans)}}
\newcommand{\rarrow}{\mbox{(-cong)}}
\newcommand{\rmu}{\mbox{(-cong)}}
\newcommand{\drmu}{\mbox{(-cong)}}
\newcommand{\intro}{\mbox{(I)}}
\newcommand{\muintro}{\mbox{(I)}}
\newcommand{\invert}{\mbox{(inv)}}
\newcommand{\elim}{\mbox{(E)}}
\newcommand{\fullrule}[4]{{\textstyle (#1)}~{\frac{\textstyle #2}
                          {\textstyle #3}}~\mboxrm{#4}}
\newcommand{\myrule}[3]{{\textstyle (#1)}~{\frac{\textstyle #2}
                          {\textstyle #3}}}
\newcommand{\srule}[2]{\bpt #1\hence #2 \ept}
\newcommand{\rulemuuno}{(R_{\EE}^{\rm uf})}
\newcommand{\rulemudue}{(R_{\EE}^{\rm fu})}






\def\lm{\l\mu}
\newcommand{\lambdamuR}{\lambda  \relmu}
\newcommand{\lambdamuweak}{\lambda \mu}
\newcommand{\lambdamuweakplus}{\lambda \mu^+}
\newcommand{\lambdamustrong}{\lambda \mu^{\star}}

\newcommand{\lambdaCR}[1]{(\lambda {#1}^{\sharp})}
\newcommand{\lambdaCeq}{\lambdaCweak{?}}
\newcommand{\lambdaCweak}[1]{\lambda #1}
\newcommand{\lambdaCstrong}[1]{\lambda {#1}^{\star}}
\newcommand{\lambdaCgen}{\lambda \geneq}

\newcommand{\lambdaTA}[1]{(\lambda #1)}



\newcommand{\ChurchTA}[1]{\lambda^{#1\mbox{-}\ch}}
\newcommand{\lmuChurch}{\lambda_\mu^{\ch_0}}
\newcommand{\lmuChweak}{\lambda_\mu^{\ch}}
\newcommand{\lAChurch}{\lambda^{\AA\mbox{-}\ch_0}}
\newcommand{\lAChweak}{\lambda^{\AA\mbox{-}\ch}}
\newcommand{\lmuChstrong}{\lambda_{\mu^{\star}}^{\ch}}
\newcommand{\lmuChurchR}{\lambda_\relmu^\ch}

\newcommand{\lCChurch}[1]{(\lambda^\ch\Ceq{#1})}
\newcommand{\lCChurchweak}[1]{(\lambda^\ch\weakCeq{#1})}
\newcommand{\lCChurchstrong}[1]{(\lambda^\ch\strongCeq{#1})}

\newcommand{\dBTA}[1]{\bl_=^{#1,\db}}
\newcommand{\lmudB}{(\lambda\mu \mbox{-} \mbox{dB}_0)}
\newcommand{\lmudBweak}{(\lambda\mu \mbox{-}  \mbox{dB})}
\newcommand{\lmudBstrong}{(\lambda\mu^{\star}  \mbox{-} \mbox{dB})}
\newcommand{\lmudBurchR}{(\lambda\relmu \mbox{-} \mbox{dB})}

\newcommand{\lCdB}[1]{(\lambda\mbox{dB}\Ceq{#1})}
\newcommand{\lCdBweak}[1]{(\lambda\mbox{dB}\weakCeq{#1})}
\newcommand{\lCdBstrong}[1]{(\lambda\mbox{dB}\strongCeq{#1})}



\newcommand{\eqmuwsys}{(\mu)}
\newcommand{\eqmussys}{{\rm (BH)}}
\newcommand{\eqCwsys}[1]{(#1)}
\newcommand{\eqCssys}[1]{({#1}^{\star})}

\newcommand{\eqmusAKsys}{(\mu ^{\star}_{\rm AC})}

\newcommand{\eqCwinvsys}[1]{({#1}^{\rm inv})}
\newcommand{\inveq}[1]{=_{#1}^{\rm inv}}





\newcommand{\weakeq}{\sim}
\newcommand{\strongeq}{{=_{\mu}^{\star}}}
\newcommand{\weakCeqinv}[1]{=_{#1}^{\rm inv}}
\newcommand{\strongCeq}[1]{=_{#1}^{{\star}}}
\newcommand{\geneq}{\simeq}
\newcommand\tr[1]{#1^{{\star}}}

\newcommand{\relmu}{\mu^{\sharp}}
\newcommand{\relC}[1]{{#1}^{\sharp}}

\newcommand{\wec}{=}
\newcommand{\vwec}{=}

\newcommand{\Cwequiv}{\sim}




\newcommand{\TAold}[1]{\corners{#1}}
\newcommand{\TA}[1]{\corners{#1,\to}}
\newcommand{\STAE}[1]{\type_{#1}}
\newcommand{\TAE}[1]{\TT_{#1}}

\newcommand{\Qset}[2]{{#1}/_{\! {#2}}}
\newcommand{\Eqclass}[2]{[#1]_{#2}}




\newcommand{\imply}{\Longrightarrow}
\newcommand{\subgen}[4]{[#1_{#3} := #2_{#3}, \ldots, #1_{#4} := #2_{#4}]}
\newcommand{\redbeta}{\longrightarrow_{\beta}}
\newcommand{\redeta}{\longrightarrow_{\eta}}
\newcommand{\redbetaeta}{\longrightarrow_{\beta\eta}}
\newcommand{\ded}{{\sf D}}

\newcommand{\union}{\cup}
\newcommand{\ih}{induction hypothesis}
\newcommand{\bottom}{\perp}
\renewcommand{\sp}{~}
\def\sep{\sp | \sp}
\newcommand{\SAT}{{\tt SAT}}
\newcommand{\semto}{\Rightarrow}

\newcommand{\ec}{\! = \!}

\newcommand{\calY}{{\cal Y}}
\newcommand{\calc}{{\cal C}}
\newcommand{\calI}{{\cal H}}
\newcommand{\calE}{{\cal E}}
\newcommand{\calA}{{\cal A}}
\newcommand{\calK}{{\cal K}}


\newcommand{\bfA}{{\bf A}}
\newcommand{\bfI}{{\bf I}}



\newcommand{\simrec}{simultaneous recursion}
\newcommand{\acapo}{\newline \noindent}



\newcommand{\assume}{\mbox{(hyp)}}
\newcommand{\coind}{\mbox{(coind)}}
\newcommand{\noncontract}{\mbox{(triv)}}
\newcommand{\AK}{\mbox{({\rm AC*})}}
\def\AC{\mbox{(AC)}}
\newcommand{\deruno}{\mbox{(der1)}}
\newcommand{\derdue}{\mbox{(der2)}}
\def\k{{\kappa}}
\newcommand{\semeqC}[2]{=^{#1}_{#2}}
\newcommand{\semeq}[1]{=_{#1}}
\newcommand{\clos}{{\cal SC}}
\def\redstar{\to^{\star}}
\newcommand{\trs}[1]{{\rm TRS}^{-1}(#1)}
\newcommand{\trscr}[1]{\mbox{TRS}^\diamond(#1)}
\newcommand{\trsplus}{\trscr}            \newcommand\trsi{\mbox{Trs}^{-1}}
\newcommand{\ov}{\overline}




\newcommand{\eqCsys}{(=)}
\newcommand{\eqmusys}{??}
\newcommand{\lambdamueq}{\lambdamuweak}
\newcommand{\mueq}{\weakeq}




\newcommand{\valof}[2]{{\cal I}\sem{#1}_{#2}}
\newcommand{\paramvalof}[3]{{\cal I}^{#3}\sem{#1} #2}
\newcommand{\valoftree}[2]{{\cal T}\sem{#1}_{#2}}
\newcommand{\valofterm}[2]{\sem{#1}_{#2}}
\newcommand{\valoftype}[2]{{\sem{#1}_{#2}}}
\newcommand{\emb}{\lhd}
\renewcommand{\into}{\rightarrow}
\renewcommand{\dom}{{\rm dom}}
\newcommand{\eqdef}{\eqdf}
\newcommand{\supremum}{{\bf sup}}
\renewcommand{\lmu}{\lambda\mu}
\newcommand{\image}[1]{{\rm im}(#1)}
\newcommand{\universe}{{\bf V}}
\newcommand{\fix}{{\bf fix}}
\renewcommand{\bm}[1]{\mbox{\boldmath }}
\newcommand{\fold}[1]{{\it fold}_{#1}}
\newcommand{\unfold}[1]{{\it unfold}_{#1}}
\newcommand{\lub}{\bigsqcup}
\newcommand{\sierpinski}{{\sf O}}
\newcommand{\appvalof}[3]{{\cal I}^{#1}\sem{#2}_{#3}}
\newcommand{\rappvalof}[3]{{\cal T}^{#1}\sem{#2}_{#3}}
\newcommand{\nskip}[1]{}
\newcommand{\Pomega}{{\cal P}\omega}
\newcommand{\finsets}[1]{{\cal P}_{\scriptstyle\rm fin}(#1)}
\newcommand{\typecarrier}[1]{\mathcal{M}(#1)}
\newcommand{\grph}{{\bf graph}}
\newcommand{\unk}[1]{{\rm Dom}(#1)}     \newcommand{\cald}{{\cal D}}
\newcommand{\cale}{{\cal E}}
\newcommand{\height}[1]{\| #1 \|}
\newcommand{\length}[1]{\left| #1 \right|}
\newcommand{\truncation}[2]{{#1}_{| #2}}
\newcommand{\rattreeOmega}{{\bf Tr}^R_{\Omega}}
\newcommand{\inftreeOmega}{{\bf Tr}^{\rm inf}_{\Omega}}
\newcommand{\metalambda}{\lambda \! \! \! \lambda}
\newcommand{\closures}{\mathcal{V}}

\newcommand\Tover[1]{\type({#1})}
\newcommand\typeplus{\type_{1,+,\times}}
\newcommand\typea{\Tover{\Tatom}}
\newcommand\ise{=_{\EE}}
\newcommand\isr{=_{\sr}}
\newcommand\XX{{\mathcal X}}
\newcommand\tterm[2]{\cour{texp}_{#1}[#2]}
\newcommand\defdby{\:\:\!=}
\newcommand\wordt{\:\!=}
\newcommand\TTT{\widetilde{\TT}}
\newcommand\Diag[1]{\cour{Diag}_{#1}}
\newcommand\hn{h^{\natural}}
\newcommand\LTT{{\cal L_{\TT}}}
\newcommand\rat{\comb{Q}}
\newcommand\aap[1]{#1}


\def\change{\renewcommand\newblock{\\}}
\newcommand{\inftree}{\inftrees}
\newcommand\neutral{\natural}



\newcommand\TQE[2]{#1/#2}
\newcommand{\weakCeq}[1]{=_{#1}}
\newcommand\TTA{\widetilde{\types}}




\newcommand\sol[1]{\cour{sol}({#1})}
\newcommand\sols[1]{\cour{sol}^{\star}({#1})}
\newcommand\hnat{h^{\natural}}


\newcommand\TTC{\TT_{\CC}}
\newcommand\SSC{\SS_{\CC}}
\newcommand{\ext}[2]{{#1[#2]}}
\newcommand{\extp}[2]{{#1[#2]}}
\newcommand{\exts}[2]{#1(#2)^{\star}}
\renewcommand{\mod}[2]{{#1}/{#2}}
\newcommand{\dd}[1]{}
\newcommand{\less}{\sqsubseteq}
\renewcommand{\strongCeq}[1]{=^{\star}_{#1}}
\newcommand{\trunc}[2]{(#1)_{#2}}
\newcommand{\trunx}[2]{\left. {#1}\right|_{#2}}
\newcommand{\vc}[2]{{#1}_1,\ldots,{#1}_{#2}}
\newcommand{\vecX}{{\vec{X}}}
\newcommand{\vecY}{{\vec{Y}}}
\newcommand\fto\to
\renewcommand\TTO{\type_o}

\renewcommand{\Types}{{\type_{\mu}}}
\renewcommand{\weakeq}{{\; =_{\mu} \,}}
\newcommand{\nweakeq}{{\; \neq_{\mu} \,}}
\newcommand{\nstrongeq}{{\neq_{\mu}^{\star}}}
\newcommand{\tamu}{\T_{\mu}}    \newcommand{\tamustar}{\TT_{\mu}^{\star}}

\newcommand\weq\weakCeq
\newcommand\treq{\tr{=}}
\newcommand\streq[1]{{\;\treq_{#1}\;}}
\newcommand\sreq[1]{{{=}^{\star}_{#1}}}

\newcommand\appeq[1]{{\; =_{\mu}^{#1} \,}}
\newcommand\srmin{\sr^{\!^-}}
\newcommand{\tmax}[2]{{(#1)}^{{\star}}_{#2}}
\newcommand{\tmap}[2]{{(#1)}^{\star}_{#2}}
\newcommand\stmu[1]{(#1)^{\star}_\mu}






\newcommand{\old}[1]{}
\newcommand{\new}[1]{#1}
\renewcommand{\T}  {\type}    \newcommand{\sta}[2]{#1/\!#2}
\newcommand{\idrel}{=}
\renewcommand{\TTO}{\T_\om}
\newcommand{\Tvars}{{\mathbb V}}   \newcommand{\muT}{\Types}     \newcommand{\mutypes}{\Types}
\renewcommand{\Atoms}{\Tatom}
\newcommand{\ccn}[1]{{\color{blue}{#1}}}   \newcommand{\simplecenter}[1]{\bsub\item[]\begin{center} #1 \end{center}\esub}

\newcommand{\scent}[1]{\simpecenter{#1}}

\newcommand{\ata}{\struct{|\AA|,\to}}






\newif\ifmarc\marctrue


\definecolor{newc}{rgb}{0,.5,.5}
\newcommand{\mar}[1]
{\ifmarc{\color{newc}{#1}}\else{#1}\fi}
\newcommand{\marc}[1]{\ifmarc{\footnote{{\mar{Mario's comm.:#1}}} }\else\fi}
\newcommand{\mc}[1]{\begin{color}{red} {#1} \end{color}}

\newcommand\KD{\KK(\dD)}

\newcommand{\restr}{\upharpoonright}
\newcommand{\inl}{\mathtt{inl}}
\newcommand{\inr}{\mathtt{inr}}
\newcommand{\arrow}[3]{
#1 \stackrel{#2}{\longrightarrow} #3}

\newcommand\lAs{{\bl\AA}}
\newcommand\laes{{\bl\AA}}
\newcommand{\lR}{{\bl_=^{\sr}}}
\newcommand{\lRs}{{\bl{\sr}}}
\newcommand\lrel{{\bl_=^{\type/\rel}}}
\newcommand\lrels{{\bl\rel}}
\newcommand\lE{{\bl_=^{\type/\EE}}}
\newcommand\lEst{{\bl_=^{\type/{\EE\st}}}}
\newcommand\lEsts{{\bl{\EE\st}}}

\newcommand\lEs{{\bl\EE}}

\newcommand\pra{\mathbin{\pr_{\AA}}\,}
\newcommand\prel{\mathbin{\pr_{\type/\rel}}\,}
\newcommand\prE{\mathbin{\pr_{\bl\EE}}\,}
\newcommand\prsr{\mathbin{\pr_{\type[\sr]}}\,}
\newcommand\prmu{\mathbin{\pr_{\type_\mu}}\,}



\newcommand\eqrule{\mbox{(equiv)}}
\newcommand{\Lta}{{\L_=^{\AA,\ch}}}
\newcommand\laech{{\bl_=^{\AA,\ch}}}
\newcommand\laecho{{\bl_=^{\AA,\ch_0}}}
\newcommand\LAch{{\L_=^{\AA,\ch}}}
\newcommand\LAcho{{\L_=^{\AA,\ch_0}}}
\newcommand\we{\weakeq}
\newcommand\ismu{{=_\mu^*}}
\newcommand{\tmu}[1]{\ttmap{#1}{\mu}}

\def\ln{\ar@{-}} \def\ld{\ar@{.}}

\newcommand\tamum{\tamu/\!=_\mu}
\newcommand\typamu{\typam/\!=_\mu}
 \title {Weak -equality is decidable}
\author{Wil Dekkers, Radboud University, Nijmegen, The Netherlands}
\maketitle
\newenvironment{Abstract} {\begin{center}\textbf{Abstract}\end{center} \begin{quote}} {\end{quote}}
\begin{Abstract}
In this paper we consider the set  of -types, an extension of the set  of simple types freely generated from a set  of atomic types and the type constructor  , by a new operator , to explicitly denote solutions of recursive equations like  We show that this so-called weak -equality for -types is decidable by defining a derivation system for weak -equality based on standard reduction for -types such that the number of nodes in a derivation tree for  is bounded as a function of  We give two proofs. One for decidability of  for -equivalence classes of -types and one for decidability of  for -types themselves. Both proofs are straightfroward and elementary.
\end{Abstract}
\newenvironment{Introduction} {\begin{center}\textbf{Introduction}\end{center} \begin{quote}} {\end{quote}}
\begin{Introduction}
In Cardone and Coppo[1] a proof method is given to show decidability of weak -equality, using standard reduction and a special purpose proof system. It turned out recently that their treatment of -conversion was not completely correct. Nethertheless their result is correct and  in Endrullis, Grabmayer, Klop and van Oostrom[2] three proofs for the decidability are given. Two of the given proofs are inspired by the Cardone-Coppo proof strategy. The third proof uses the theory of regular languages and is totally different. This paper is based on the first two proofs of Endrullis et al. These proofs are ingenuous but they are also technical and intricate. Our aim is to give simpler and more straightforward proofs.
\newline In their first proof Endrullis et al. work with -types themselves, not with -equivalence  classes of -types. The proof constructs a decision procedure for equality of types based on standard reduction for types. In that proof they need the theory of -avoiding developed by van Oostrom[3]. In the second proof they work with -equivalence classes  and the corresponding reduction relation  for classes and they show the decidability of . Our proof is more or less the other way round. Based on the first proof of Endrullis et al. of decidabiliy of equality for types we give a proof of decidability of  for classes of types and then from that proof we derive a first order proof of decidability of equality for types where the theory of -avoiding is not needed. Both proofs are straightforward and elementary.
\newline So in our first proof  is he set of -equivalence classes of types and   stand for classes of types. We start by defining a set , containing , of so-called annotated ( classes of ) -types and a reduction  :  that is closely related with standard reduction on . Then we define a derivation system  for equality of elements of  such that for  one has 

We show for  that  is bounded as a function in  and also that for  occurring in a derivation tree for  we have  and  So  the number of nodes occurring in a derivation tree for   is bounded as a function in  So  is decidable and hence  is decidable, because of  the fact that 


Then in part 2 from this result we derive easily that  on  types themselves can be decided by first order means via a decision procedure for  on types. 

\end{Introduction}
\section{ A decision procedure for weak -equality via -equivalence classes of types}
\bdf[Of  and ]\label{tamu and redmu}
\bsub\firstitem  Let  be an infinite set of type
atoms   considered as type variables for the purpose of binding and
substitution.The set of -types, notation , is defined as follows.

\item On  we define the notion of
-reduction and -conversion via the contraction rule
 The relation  is the least
compatible relation containing  and  is  the least congruence containing
. 
\item Define on  a notion of -reduction via the contraction rule 
 The relation  is the compatible closure of  That is
\beqn
&&A_1\redmu B_1\imp\mu\beta.A_1\redmu\mu\beta.B_1;\\
&&A_1\redmu A'_1\imp (A_1\to A_2)\redmu (A'_1\to A_2);\\
&&A_2\redmu A'_2\imp (A_1\to A_2)\redmu (A_1\to A'_2).
\eeqn
\item  denotes zero or more  steps and  is the least congruence containing 
\item In this first part we work with -equivalence classes of types and we asume that all bound and free variables are different. Especially in  all  are different. 
 \esub \edf

\bdf Let  denote the -equivalence class of A and let  denote the set of -equivalence classes.  and  can easily be lifted to relations  and  on  In part 2 of this paper we will consider  and  but in this part 1 we work with  and  and we simply write   and  Also we write  for  
\edf

\bdf\label{standardreduction}[Of standard reduction ]\\
 (a) \\
(b) If  then the composition  is a standard reduction.\\
(c) If  then the induced reduction  is a standard reduction.\\
(d) If  and   then each reduction  generated by interleaving is a standard reduction.
\edf


\begin{example}\label{streductions}
\bsub\fit Let  Then  is a standard reduction.
\item Let  Then  is a standard reduction.
\item Let  Then  is not a standard reduction. 
\esub
\end{example} 

\brem\label{facts} We have the well known facts.
\bsub \item The relation  is Church Rosser (CR);
\item If  then there is a standard reduction 
\esub
\erem

We illustrate (ii) in the above remark by an example.
\begin{example}\label{examplestreduction}
Let  Here  is a so-called context. The variables  and  can occur several times in it. Now let  Then

We can make this two-step reduction into a standard reduction as follows.

and now reduce each occurrence of  to , from left to right.
\end{example}

Let for the moment  denote that  and  have a common standard reduct. Our aim is to show that  is decidable. By (ii) of the above remark we are ready if we show that  is decidable. However a direct proof of that is not so easy because in general a type  may have infinitely many standard reducts as is shown by (i) and (ii) of Example \ref{streductions}.

We remedy the two problems given by the example by changing the notion of standard reduction (and also the set of types)  roughly as follows. In clause (c) of the notion of standard reduction we add the condition  Then the number of  as in (i) of the  example  is bounded . Moreover clause (d) is changed into  to remedy the problem shown in (ii).

This is formalised as follows.

\bdf[Of the set of annotated types ]\label{annotatedtypestmua}
\bsub\fit The set of annotated types  is defined by

\item We consider the annotated types modulo -equivalence as follows \\
   And implicitly   
\esub\edf

\brem\label{overtmua}
\bsub\fit In Endrullis et al.[2] a set AnnTer is defined by AnnTer So they don't have the conditions  and  if 
Moreover they don't work modulo -conversion.
\item The intuition for  is that it stands for  where the  at the root are frozen. This will become clear in Definition \ref{redmua}.
\item Note that  
\esub
\erem

\bnnot\labelx{shorthand}
\bsub\fit We denote  simply as  and mostly we write 
\item denote elements of  and as before  stand for elements of 
\item If  is a sequence of (different) type variables then  denotes the sequence that arises from  by omitting the variables that do not occur freely in   Similarly for \\
 stands for \\
If  then 
\item If  then  stands for the number of elements of 
\item  stands for the set of variables occurring in  When we write  we always assume   for 
\esub
\ennot

\bdf\label{redmua}(0f  and )\bsub\item The reduction relation  is defined as follows.
\beqn
(\mu\alphaarrow)\mu\beta.A_1&\redmua& (\mu\alphaarrow\beta)A_1\mbox{    if }\beta\in FV((A_1);\\
(\mu\alphaarrow)\mu\beta.A_1&\redmua& (\mu\alphaarrow)A_1[\beta :=\mu\beta.A_1];\\
(\mu\alphaarrow)(A_1\to A_2)&\redmua&(\mu\alphaarrow)\Box A_i\;\;\;\; i=1,2;
\eeqn
\item 
\esub\edf

\brem\label{notcompatible}
\bsub\fit Note that  is not compatible with  or . So for example we do not have 
\item Now the outline of the decidability proof is as follows.\\
--We define a derivation system  for types , closely connected with the reduction relation  and we show for :

Hence we have  \\
-- We note that for all nodes  occurring in a derivation tree for  we have  and \\
-- We show that  is bounded as a function in . Hence the number of different nodes in a derivation tree for  is bounded as a function in \\
-- We conclude that  is decidable and hence so is .
\esub\erem

We start by defining the derivation system  for  We give the definition via representatives, types instead of -equivalence classes of types, and we show that it is invariant under -conversion. Hence this defines in fact  a relation on the set of -equivalence classes.

\bdf\label{prmua} (Of  for )
1em]
{\mbox{(left }}\mu{\mbox{-step)}}& \Ruled {(\mu\alphaarrow)A_1[\gamma :=\mu\gamma.A_1] = (\mu\betaarrow)B}{(\mu\alphaarrow)\mu\gamma.A_1 = (\mu\betaarrow)B} 
\2em]

(\mu{\mbox{-freezing)}} & \Ruled{(\mu\alphaarrow\gamma)A_1=(\mu\betaarrow\delta)B_1}{(\mu\alphaarrow)\mu\gamma.A_1=(\mu\betaarrow)\mu\delta.B_1} \2em]

\hline
\earA\eqalpha A'\;\Rightarrow\;(\mu\alpha_1).....(\mu\alpha_n)A'\eqalpha(\mu\alpha'_1).....(\mu\alpha'_n)A'[\alpha_i :=\alpha'_i]\;\;(\alpha'_i\notin \FV(A).\prmua a=b\;\Rightarrow\;\prmua a'=b'.\bar[b]{|ll|}
\hline\hoog{1.5em}{} 
\mbox{{(axiom)}}& {\textstyle {a=a} }\2em]
 {\mbox{(right }}\mu{\mbox{-step)}}  & \Ruled{(\mu\alphaarrow)A = (\mu\alphaarrow)B_1[\beta :=\mu\beta.B_1]}{(\mu\alphaarrow)A = (\mu\alphaarrow)\mu\beta.B_1} \2em]

 &\{\alphaarrow\}\subseteq\FV(A_1\to A_2)\;\; \alphaarrow\restricted A_1=\alphaeenarrow,  \alphaarrow\restricted A_2=\alphatweearrow \\
{\rm(decomposition)} &\Ruled{(\mu\alphaeenarrow)A_1=(\mu\alphaeenarrow)B_1\;\;\;\;(\mu\alphatweearrow)A_2=(\mu\alphatweearrow)B_2}
{(\mu\alphaarrow)A_1\to A_2=(\mu\alphaarrow)B_1\to B_2}\
\edf

The following is an example of a derivation of  We reason backwards, so we write down  and using the rules upside down we hope to finish with only axioms.

\begin{example}\label{derivationofprmua}
\bceqn
\mu\alpha\beta\gamma.((\mu\delta.\alpha)\to\gamma)&=&\mu\alpha\beta.(\alpha\to(\mu\gamma.\alpha\to\gamma))\\
&\Downarrow&\mu\rm{-freezing}\\
(\mu\alpha)\mu\beta\gamma.((\mu\delta.\alpha)\to\gamma)&=&(\mu\alpha)\mu\beta.(\alpha\to(\mu\gamma.\alpha\to\gamma))\\
&\Downarrow&\mbox{left and right } \mu\rm{-step}\\
(\mu\alpha)\mu\gamma.((\mu\delta.\alpha)\to\gamma)&=&(\mu\alpha)(\alpha\to(\mu\gamma.\alpha\to\gamma))\\
&\Downarrow&\mbox{left }\mu\rm{-step}\\
(\mu\alpha)((\mu\delta.\alpha)\to\mu\gamma.((\mu\delta.\alpha)\to\gamma))&=&(\mu\alpha)(\alpha\to(\mu\gamma.\alpha\to\gamma))\\
&\Downarrow&\rm{decomposition}\\
(\mu\alpha)(\mu\delta.\alpha)=(\mu\alpha)\alpha&&(\mu\alpha)\mu\gamma.((\mu\delta.\alpha)\to\gamma)=(\mu\alpha)(\mu\gamma.\alpha\to\gamma)\\
\mbox{left }\mu\rm{-step}~ \Downarrow~~~~~~~~~~&&~~~~~~~~~~~~~~~~~~~~~~~~~~~~\Downarrow{\rm{\mu-freezing}}\\
(\mu\alpha)\alpha=(\mu\alpha)\alpha&&~~(\mu\alpha\gamma)((\mu\delta.\alpha)\to\gamma)=(\mu\alpha\gamma)(\alpha\to\gamma)&\\
&&~~~~~~~~~~~~~~~~~~~~~~~~~~~~\Downarrow{\rm{decomposition}}\\
&&~~~(\mu\alpha)\mu\delta.\alpha=(\mu\alpha)\alpha~~~~~~~(\mu\gamma)\gamma=(\mu\gamma)\gamma\\
&&~~~~~~~~~~~~~~~~\Downarrow\mbox{left }\mu\rm{-step}\\
&&~~~~~~(\mu\alpha)\alpha=(\mu\alpha)\alpha
\eceqn
\end{example}

\brem\label{otherproofs}
Let  and  In the example above we gave a proof of   In fact one could try other proofs. For example one could start with a left -step and a right -step. Then one encounters at some stage again a node  So one could go on for ever and the result would be an infinite tree. But of course one should stop developing the sub branch at that node.\\
In general if in a derivation of  we arrive at a node  that we encountered already higher up in the branch from the root to that node then we stop at that node. Further on we will show that the number of nodes in the resulting tree is bounded as a function of \\But first we will show in the next proposition that  iff  and  have a common standard reduct.
\erem

\bprop\label{prmuaiscommstred}
The following two assertions are equivalent
\bsub\item ;
\item  and  have a common standard reduct.
\esub
\eprop
\bpf (i)(ii). By induction on the derivation of \1em]
(left -step)    \1em]
(right -step)      Similarly. \1em]
By the induction hypothesis  and  have a common standard reduct, hence the same holds for  and \1em]
By the induction hypothesis  and  have a common standard reduct and the same holds for  and . So it also holds for  and \1em]
Case (a) for both  and \\
 Then  and we have  by axiom.\1em]
Case (c) for  an for .\\
 Now  and  and therefore\\ \\
Note that  by Lemma \ref{freevariables}(ii)
We distinguish two subcases\1em]
Subcase (c)  \\
Now we have by the induction hypothesis , hence we get by (left -step) and (right -step) 
\1em]
Now we have treated all cases. If we have Case (c) for  and Case (a) for  then in fact we have Case (c) for both  and  If we have Case (d) for  and Case (a) for  then in fact we have Case (d) for both  and 
Finally Case (c) for  and Case (d) for   (or vice versa) cannot occur at the same time. \qed
\epf

Now we will finish the proof of decidability of  by showing that the number of different nodes  occurring in a derivation tree of  is bounded as a function in \\
Note that for all these nodes  we have . (See Definition \ref{redmua})\\
We start by showing that  is bounded as a function in 

\blem\label{mualpharestricted}  
\elem
\bpf  Immediate. Note that by the variable convention  and  have no variables in common. \qed
\epf

\blem\label{SC} 
\\
\\
\\

\elem
\bpf By induction on the structure of  using the preceding lemma. Note that the second clause also holds for  because then  by Lemma \ref{freevariables}(iii). \qed
\epf

Now  could be intricate but we will show in Lemma \ref{SCsimple} that we have in fact 

\blem\label{onredmua} If  then we have either
\bsub\item This reduction is 
\item This reduction is a  instance of     (So ).
\esub
\elem
\bpf By induction on the length of the reduction .\\
If the length is zero then we have (ii). Else we have . The induction hypothesis for  gives that we have either (i) or (ii) as follows\1em] 
(ii) The reduction  is a  instance of     So   We distinguish subcases for  as follows.\1em]
(iib)   or   These cases cannot occur because then  is in nf.\1em]
(iic1)            ()\\
Then , hence also  because  by the variable convention. So () is a   instance of . In total we have that  is an instance of  and we are in Case (ii). \1em]
(iid)  Then  and . Now we are in case (ii) again.
\epf

\blem\label{SCsimple}   
\elem
\bpf Let  be a reduction path of minimal length.\\
If the length is zero then  Now let the length be bigger then zero. We distinguish two cases.\1em]
Case(ii)  \\
We distinguish two subcases according to Lemma \ref{onredmua} \\
(iia)   This cannot occur because it is not a reduction of minimal length.\\
(iib)  is a  instance of  Now  hence  \qed
\epf

\bdf\label{length} \bceqn
l(\alpha)&=&1;\\
l(A_1\to A_2)&=&1 + l(A_1) + l(A_2);\\
l(\mu\beta.A_1)&=&1 + l(A_1);\\
l((\mu\alphaarrow).A)&=&l(A).\eceqn
\edf

\blem\label{lengthSC} 
\elem
\bpf By Lemmas \ref{SC} and \ref{SCsimple}. \qed
\epf

\blem\label{numberofnodes} Let  be the number of different nodes in a complete derivation treee for  Then 

\elem
\bpf Easy. Note that each node in the derivation tree has at most three daughters. \qed
\epf

\bcor\bsub\fit  is decidable.
\item  is decidable. \qed
\esub
\ecor

\bcor  is decidable.
\ecor

\bpf  By Remark \ref{facts} and Proposition \ref{prmuaiscommstred}. \qed
\epf

\section {A decision procedure of weak -equality  for types themselves}

In this subsection we work with the -types themselves instead of their -equivalence classes. On this set of types  is the reduction relation on the set of types  generated by  and . We show that the relation  on  is decidable via the first order decision procedure of Definition \ref{prmua} for types.

\bdf  is the reduction relation on the set of types  generated by  and \\  is the transitive, symmetric, reflexive closure of 
  denotes zero or more  steps.
\edf

We will show 

where  derives equations between types in , as given in Definition \ref{prmua} and moreover that this relation is decidable.\\
From now on  -quivalence classes in  and  are denoted by  and   stands for equality on the set  of -equivalence classes  and 
 denotes the derivation system of Definition \ref{prmuaforclasses} for classes  where 

\blem\label{prmuaisprmuacl}  and both derivations can be done by the "same" steps. Equivalently they have the same length.
\elem
\bpf Immediate \qed
\epf

\blem\label{eqmualphaiseqmu} 
\elem
\bpf Immediate \qed
\epf

Combining Remark \ref{facts}, Proposition \ref{prmuaiscommstred} and Lemmas \ref{prmuaisprmuacl} and \ref{eqmualphaiseqmu} we get

\bcor   \qed
\ecor

Finally by Lemma \ref{prmuaisprmuacl} we have that  is decidable. In fact there is a bijection from the derivation tree for  on the derivation tree for  So we have the following

\bth  is decidable via the first order decision procedure  \qed
\eth

\brem In this part 2 we do not have Lemma \ref{SCsimple} for types. It only holds modulo -equivalence.
\erem

\newenvironment{References} {\begin{center}\textbf{References}\end{center} \begin{quote}} {\end{quote}}
\begin{References}
[1] Felice Cardone and Mario Coppo. Decidability Properties of Recursive Types. In C. Blundo and C. Laneve, editors, {\it ICTCS 2003} volume 2841 of {\it LNCS,} pages 242-255. Springer, 2003.\1em]
[3] V. van Oostrom. FD \`a la Melli\`es. February 1997. Free  University Amsterdam.
\end{References}
\end{document}
