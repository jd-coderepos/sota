\documentclass{article}
\pdfoutput=1





\usepackage[preprint,nonatbib]{neurips_2019}





\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{graphicx}
\usepackage{floatrow}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{floatrow}
\usepackage{floatrow}
\floatsetup[table]{capposition=top}

\newfloatcommand{capbtabbox}{table}[][\FBwidth]


\newcommand{\name}{Ekar}
\newcommand{\xhdr}[1]{{\noindent\bfseries #1}.}
\DeclareMathOperator{\E}{\mathbb{E}}
\usepackage[flushleft]{threeparttable}
\usepackage{multirow}

\title{Explainable Knowledge Graph-based Recommendation via Deep Reinforcement Learning}



\author{Weiping Song, Zhijian Duan, Ziqing Yang, Hao Zhu, Ming Zhang, Jian Tang \\
Peking University, Mila - Quebec AI Institute, \\
CIFAR AI Research Chair, HEC MontrÃ©al \\
{\small \texttt{\{weiping.song,zjduan,yangziqing,hzhu1998,mzhang\_cs\}@pku.edu.cn}} \\
{\small \texttt{jian.tang@hec.ca}}
}

\begin{document}



\maketitle

\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\footnotetext[1]{This work was done when the first author was visiting Mila.}
\renewcommand{\thefootnote}{\arabic{footnote}}


\begin{abstract}


This paper studies recommender systems with knowledge graphs, which can effectively address the problems of data sparsity and cold start. Recently, a variety of methods have been developed for this problem, which generally try to learn effective representations of users and items and then match items to users according to their representations. Though these methods have been shown quite effective, they lack good explanations, which are critical to recommender systems. In this paper, we take a different path and propose generating recommendations by finding meaningful paths from users to items.
Specifically, we formulate the problem as a sequential decision process, where the target user is defined as the initial state, and the walks on the graphs are defined as actions. We shape the rewards according to existing state-of-the-art methods and then train a policy function with policy gradient methods.
Experimental results on three real-world datasets show that our proposed method not only provides effective recommendations but also offers good explanations
.  



\end{abstract}

\section{Introduction}




Recommender systems are essential to a variety of online applications such as e-Commerce Websites and social media platforms by providing the right items or information to the users. One critical problem of recommender systems is data sparsity, i.e., some items are purchased, rated, or clicked by only a few users or no users at all. Recently, there is an increasing interest in knowledge graph-based recommender systems, since knowledge graphs can provide complementary information to alleviate the problem of data sparsity and have been proved quite useful~\cite{Cao_2019,Ma_2019,wang2018ripplenet,wang2018dkn,zhang2016collaborative,zhang2018explainable}. 




Generally, existing knowledge graph-based recommendation methods try to learn effective representations of users and items according to the user-item interaction graphs and item-entity knowledge graphs, and then match the items to the users according to learned representations. For example, Zhang et al.~\cite{zhang2016collaborative} learn item representations by combining their representations in user-item graphs and knowledge-graphs. 
Zhang et al.~\cite{zhang2018learning} learn user and item representations on the integrated user-item-entity graphs based on knowledge graph embedding (KGE) method like TransE~\cite{bordes2013translating}. Wang et al.~\cite{Wang_2019} and Cao et al.~\cite{Cao_2019} jointly optimize the recommendation and knowledge graph embedding tasks in a multi-task learning setting via sharing item representations. These methods have been proved quite effective by integrating information from both user behaviors and knowledge graphs.



Although these methods are very effective, they lack good explanations. Intuitively, if the recommender system can give an explanation of a recommendation, the users would have more interest and trust in the recommended item~\cite{herlocker2000explaining, lu2018like,zhang2018explainable,zhang2014explicit}. 
Indeed, there is some existing work that aims to provide such explanations for the recommendation results. For example, the RippleNet~\cite{wang2018ripplenet} aims to explain the recommendations by analyzing the attention scores. However, their method relies on the post analysis of the soft attention scores, which may not always be trustworthy. 





In this paper, we take a different route and propose to generate a path from the target user to relevant items in the integrated user-item-entity graph. Take the movie recommendation in Figure~\ref{fig:example} as an example. For the target user , a path (the red dashed lines) is generated to the item "Romeo and Juliet" since 1) user  watched movie ``Titanic''; 2) ``Titanic'' is starred by ``Leonardo DiCaprio''; and 3) ``Leonardo DiCaprio'' also stars in ``Romeo and Juliet''. We can see that such a path
offers good explanations of the recommendations in addition to provide meaningful recommendations.




\begin{figure}
\floatbox[{\capbeside\thisfloatsetup{capbesideposition={right,top},capbesidewidth=4.2cm}}]{figure}[\FBwidth]
{\caption{Explainable recommendation via reasoning over the integrated user-item-entity graph. Our \name\ generates the recommendation (i.e., ``Romeo and Juliet'') by inferring a preference path ``''.}\label{fig:example}}
{\includegraphics[width=8.3cm]{figures/kgrec_example_v6.pdf}}
\end{figure}




However, finding meaningful paths on the large user-item-entity graph is challenging. One may enumerate all paths between user-item pairs and then use a classification/ranking model to select the most meaningful paths~\cite{Wang2018ExplainableRO}. Nevertheless, enumerating paths between users and items is intractable due to the exponentially large path space in the user-item-entity graph. Although sampling a certain number of paths via breadth-first-search can be a practical substitution to enumerating, it has no assurance on the meaningfulness of sampled paths. In this paper, we formulate the generation of meaningful user-to-item paths as a sequential decision process. Specifically, the recommender agent starts from target users and extends its paths to relevant items by sequentially selecting walks on the user-item-entity graph. During training, we assign each path a positive reward if the starting user and terminal entity constitute an observation in recommendation data. Considering that the reward could be extremely sparse at the beginning due to the huge exploration space, we further augment the reward signals by reward shaping~\cite{ng1999policy}, where a soft reward function is first learned using state-of-the-art knowledge graph embedding methods. We use the REINFORCE~\cite{williams1992simple} algorithm to maximize the expected rewards of our recommender agent. Finally, we verify the effectiveness and the explainability of the proposed method on three real-world datasets. Quantitative results demonstrate that our proposed \name: 1) significantly outperforms existing state-of-the-art KG-based recommendation methods, 2) offers clear and convincing explanations in the form of meaningful paths from users to recommended items.


%
 \section{Related Work}
Our work is conceptually related to the explainable recommendation, knowledge graph-based recommendation, and recent advancements in applying reinforcement learning into relational reasoning.

\xhdr{Explainable Recommendation} 
As a widespread concern in the AI community, explainability has been widely discussed in recommender systems.
According to Zhang and Chen~\cite{zhang2018explainable}, most of the existing explainable recommendation methods typically provide explanations via identifying users' preference on item features~\cite{bauman2017aspect,wang2018explainable,zhang2014explicit}, understanding latent factors with topic modeling~\cite{mcauley2013hidden, wu2015flame,zhao2015sar}, or ranking over the user-item-aspect graph~\cite{he2015trirank}. However, these methods require external information (e.g., reviews) about items, which may be difficult to collect. Some recent advancements utilize the
attention mechanism~\cite{li2017neural,song2019session} to provide explanations, but they need extra efforts to explore attention scores.
Since knowledge graphs (KG) provide common knowledge about our world, many recent works use knowledge graphs~\cite{Cao_2019,wang2018ripplenet,wang2018dkn,zhang2016collaborative} to provide explainable recommendations, which will be further discussed in the following paragraph.


\xhdr{KG-based Recommendation} Our work is closely related to KG-based recommendation, which utilizes general knowledge graphs (e.g., DBpedia, YAGO, and Satori) to improve recommender systems. Existing KG-based recommendation methods can be roughly divided into two classes: embedding-based methods and path-based methods. In embedding-based methods, users and items are represented by low-dimensional vectors, where entities' embeddings from the knowledge graph are used to enhance corresponding items' representations~\cite{Cao_2019,wang2018dkn,Wang_2019,zhang2016collaborative}. Although these methods perform well, it's hard to explain the recommendation results because representations are in a latent space.In path-based methods, meta-paths and meta-graphs are commonly used to extract various semantic dependencies between users and items~\cite{yu2014personalized,zhao2017meta}. However, it is almost
computationally infeasible to enumerate all the useful meta-paths or meta-graphs. Moreover, the meta-paths and meta-graphs need to be manually defined and cannot generalize to new datasets. Instead of pre-defining specific paths, the RippleNet~\cite{wang2018ripplenet} directly propagates users' preferences along edges in KG via the attention mechanism and then interprets the recommendations according to the attention scores, which however might not be trustworthy.The most recent work KPRN~\cite{Wang2018ExplainableRO} uses LSTM to model the paths between users and items. However, sampling paths via breadth-first-search (BFS) is inefficient and may miss meaningful paths.
Different from KPRN, our method defines the path finding problem as a sequential decision problem. We train an agent to automatically generate a meaningful path between a user and his/her relevant item via policy gradient methods.


\xhdr{Relational Reasoning with Reinforcement Learning} Our work is also related to recent work on knowledge graph reasoning with reinforcement learning~\cite{das2017go,lin2018multi,xiong2017deeppath}, which aims to train an agent to walk on knowledge graphs to predict the missing facts. However,
their goal is different from ours. We focus on the problem of recommendation with knowledge graphs and aim at finding meaningful paths for explaining the recommendation results while they focus on facts prediction.


%
 \section{Proposed Method: \name }
In this section, we first formally define our problem and then introduce our proposed \textbf{E}xplainable \textbf{k}nowledge \textbf{a}ware \textbf{r}ecommendation (\name) model in detail.


\subsection{Problem definition}
We formally denote the interactions between users and items as a bipartite graph , where  is the set of users, and  is the set of items. Besides, we also have access to an open knowledge graph , where  is the entity set and  is the relation set. Each triplet  indicates there exists a relation  from head entity  to tail entity . For example,  reflects the fact that ``Titanic'' is directed by ``James Cameron''. 
As some items/entities are shared between  and , we merge the user-item bipartite graph  and the knowledge graph  into an integrated user-item-entity graph , where . For the user-item interaction graph , we assume all the edges belong to the relation ``Interact'', and therefore . 




Given a user , our goal is to generate a path from  to a relevant item  on the user-item-entity graph . Such a path not only allows to find the relevant item but also offers good explanations. 




\subsection{Formulating recommendation as a Markov Decision Process}\label{subsec::mdp}
There are some existing methods~\cite{Wang2018ExplainableRO} trying to find meaningful paths between users and items. These methods first sample a collection of paths with breadth-first or depth-first search strategy and then measure the meaningfulness of the paths with a classification or ranking model. However, the number of possible paths between a user and an item could be exponentially large, and sampling a few of them could miss the meaningful ones. 
Moreover, the paths sampled through BFS or DFS strategy may not always be meaningful. 
In this paper, we take a different route and formulate the problem as a sequential decision making problem on the user-item-entity graph . We aim to train an agent to walk on  to find relevant items.
Starting from a target user , the agent sequentially selects the next neighbor on the integrated user-item-entity graph  until it reaches the predefined maximum number of steps .
Formally, we define the states, actions, transition, and rewards of the Markov Decision Process as follows:

\xhdr{States} We represent the state as the sequence of traversed relations and entities so far, i.e., , where  and  are relations and entities respectively. 
The initial state  represents the target user, and  is an artificially introduced relation to be consistent with other  pairs.


\xhdr{Actions} When the agent is under state , it can choose an outgoing edge of entity  as its next action.
Formally, we define the possible actions under state  as .

\xhdr{Transition} For the state transition , we adopt a deterministic strategy and simply extend the current state  by adding the new action  as the next state, i.e., .


\xhdr{Rewards} No intermediate reward is provided for . The final reward depends on whether or not the agent correctly finds interacted items of the user .
Given the terminal entity , the final reward  is  if user  has interacted with ,  if  is an item but user  has not interacted with it and  if  is not an item-type entity.


\subsection{Solving recommendation MDP with policy gradient}

We further parameterize the above MDP with deep neural networks and optimize it with policy gradient methods.

\xhdr{Parameterizing MDP with Deep Neural Networks} Since there are usually millions of entities and hundreds of relations in user-item-entity graph , it is almost impossible to utilize discrete states and actions directly, the number of which is exponential to the number of symbolic atoms in  and  respectively. We, therefore, choose to represent entities and relations in  with low-dimensional embeddings. Each action  is represented as the concatenation of relation and entity embeddings, i.e., . The state  is encoded by an LSTM~\cite{hochreiter1997long}:
where  is a zero vector and  is the low-dimensional representation of state . 


According to our initial definition of rewards, the agent gets a positive reward if and only if it successfully finds the target item. However, this might be problematic for a few reasons: First, for a large user-item-entity graph , it is very difficult for the agent to reach the correct items due to the huge search space, especially at the beginning of training~\cite{xiong2017deeppath}. In other words, the rewards will be very sparse. As a result, the learning process of the agent could be very inefficient and take a long time to converge. Second, the goal of recommender systems is to infer new items that users are likely to interact with in the future, rather than repeating users' historical items. However, receiving positive rewards only from historical items discourages the agent to explore new paths and items, which should be the target of recommender systems. To accelerate the training process and meanwhile encourage the agent to explore items that have not been purchased or rated by the target user, 
we propose to shape the rewards~\cite{ng1999policy} in the following way: 

where  is the sigmoid function and  represents the relation ``Interact''.
 is the score function that measures the correlation between user  and the searched item . In our study,  is pre-trained by maximizing the likelihood of all triplets in graph  and can be the score function of any state-of-the-art knowledge graph embedding models~\cite{dettmers2018convolutional,yang2014embedding}. Different from the original rewards defined in Section~\ref{subsec::mdp}, items that the target user has not interacted with now receive positive rewards, which are determined by the pre-trained knowledge graph embeddings.



\xhdr{Policy Network}
In this paper, we use the policy gradient method to solve the proposed recommendation MDP.
Based on parameterized state  and parameterized action , we calculate the probability distribution over possible action  as follows:

where \{\} and \{\} are weight matrices and weight vectors of a two-layer fully-connected neural network,  is the non-linear activation function and  is the probability of taken action  under state .

\xhdr{Optimization} During training, the agent starts with an initial state , where  is the target user, and sequentially extends its path to a maximum length of . We then use the reward function (i.e., Eq.~\ref{eq:reward}) to assign the trajectory  a final reward. Formally, we define the expected rewards over all traversed paths of all users as:

which is maximized via gradient ascent, and the gradients of all parameters  are derived by the REINFORCE~\cite{williams1992simple} algorithm, i.e.,

 \section{Further Constraints on Actions}
The current action space under state  (i.e., ) is defined as the set of outgoing edges of current entity . This could be problematic for two reasons. First, for , if entity  is already the correct item (i.e., ), the agent should stop and not continue to walk to other entities. Second, since the REINFORCE algorithm tends to encourage the agent to repeat historical experiences which receive high rewards~\cite{Guu_2017}, the algorithm may discourage the agent from exploring new paths and items, which could be relevant to the target user. We address the two problems in the following ways:

\xhdr{Stop Action} As the length of paths may vary for different user-item pairs, we should provide the agent an option to automatically terminate when it believes that it has found the right items ahead of .
Following Lin et al.~\cite{lin2018multi}, we add a special link from each node to itself. In this way, we allow the agent to stay at the ground truths, which can be understood as a stop action. We show the impact of using stop action in Section~\ref{subsec:ablation} by setting different path length .

\xhdr{Action Dropout} To prevent the agent from repeating historical high-reward paths and encourage it to explore more possibilities, we propose to use action dropout~\cite{lin2018multi} during the training. Specifically, instead of sampling an action from original , we use a mask upon  to randomly drop some actions. In addition, action dropout can also help alleviate the problem of irrelevant paths between a user and an item since these paths may be found coincidentally at the beginning of training. \section{Experiments}
In this section, we evaluate \name\ on three real-world datasets. Compared to other state-of-the-art methods, our proposed approach has the following advantages:
1) \textbf{Effectiveness}. \name\ significantly outperforms existing state-of-the-art KG-based recommendation methods in terms of recommendation accuracy. 2) \textbf{Explainability}. Case studies on generated paths demonstrate that \name\ can offer good explanations for recommended items.





\subsection{Data and Experiment Settings}



\xhdr{Data}
We test \name\ on three benchmark datasets for KG-based recommendation: 1) \textit{Last.FM}.
This dataset contains a set of music artist listening information from a popular online music system Last.Fm. 2) \textit{MovieLens-1M}.
MovieLens-1M provides users' ratings towards thousands of movies. For these two datasets, we convert the explicit ratings into implicit feedback where each observed rating is treated as ``1'', and unobserved ratings are marked as ``0''s. Following \cite{Wang_2019}, we use Microsoft Satori to construct knowledge graphs for Last.FM and MovieLens-1M datasets respectively. 3) \textit{DBbook2014}.
This dataset provides users' reading history in the book domain. Its supporting knowledge graph is extracted from DBpedia.
As we focus on KG-based recommendation, we remove items that have no matching entities in the corresponding knowledge graph. The statistics of processed datasets are presented in Table~\ref{tab::dataset}. Following \cite{Cao_2019,wang2018ripplenet,Wang2018ExplainableRO}, we randomly split the interactions of each user into training, validation, and test set with ratio 6:2:2.



\begin{table}[]
\caption{Statistics of evaluation datasets and corresponding knowledge graphs.}
\centering
\scalebox{0.98}
{
\begin{tabular}{lccccccc} 
\toprule
\multirow{2}{*}{Data} & \multicolumn{4}{c}{User-Item Interaction} & \multicolumn{3}{c}{Knowledge Graph}\\\cmidrule(r{1em}l{1em}){2-5}\cmidrule(r{1em}l{1em}){6-8}
    & \# Users & \# Items & \# Events & Sparsity & \# Entities & \# Relations & \# Triplets  \\
\midrule
Last.FM & 1,872 & 3,846 & 21,173 & 99.71\% & 9,366 & 60 & 15,518 \\
MovieLens-1M & 6,040 & 2,347 & 656,462 & 95.37\% & 7,008 & 7 & 20,782 \\
DBbook2014 & 5,576 & 2,598 & 65,445 & 99.55\% & 10,149 & 13 & 135,580 \\
\bottomrule
\end{tabular}\label{tab::dataset}
}
\end{table}


\xhdr{Baseline Methods} 
We compare \name\ with two kinds of methods: 
1) Classical similarity-based methods including:  
\textbf{ItemKNN}, which recommends items that are most similar to target user's historical items; 
\textbf{BPR-MF}~\cite{yu2014personalized}, which is a widely-used matrix factorization method using Bayesian Personalized Ranking (BPR) loss. 
2) KG-based recommendation methods including: 
\textbf{RippleNet}~\cite{wang2018ripplenet}, which propagates users' interests over knowledge graph with attention mechanism;  
\textbf{CFKG}~\cite{zhang2018learning}, which learns users' and items' representations by applying TransE~\cite{bordes2013translating} on the graph ; 
\textbf{MKR}~\cite{Wang_2019}, which learns both user-item matching task and knowledge graph embedding task under multi-task learning framework; 
\textbf{KTUP}~\cite{Cao_2019}, which is a state-of-the-art KG-based recommender that jointly learns translation-based recommendation~\cite{he2017translation} and translation-based knowledge graph embedding;
\textbf{ConvE-Rec}, which learns users' and items' embeddings based on integrated graph  with ConvE~\cite{dettmers2018convolutional}. As we use ConvE model for reward shaping, we treat ConvE-Rec as a special recommender.  


\xhdr{Evaluation Metrics} Following~\cite{Cao_2019,he2015trirank,song2019session}, we adopt \textit{Hit Ratio} (HR) and \textit{Normalized Discounted Cumulative Gain} (NDCG) to evaluate the effectiveness of proposed \name\ and baseline methods. We use the same definition of HR and NDCG in \cite{he2015trirank}, where HR measures whether test items are present in the recommendation list and NDCG assesses the ranking quality of test items respectively.
In our study, we always report the averaged HR@K and NDCG@K scores across all users over five runs.



\xhdr{Implementation Details} First of all, we add  into  if a triplet  exists to enhance the connectivity of graph, where  is the inverse of relation .
Following~\cite{Cao_2019}, we only preserve those triplets that are directly connected to items in each supporting knowledge graph.
We implement \name\ with Pytorch~\cite{paszke2017automatic}. 
Entity and relation embeddings are pre-trained by applying ConvE
\footnote{We also use DistMult~\cite{yang2014embedding} model to initialize entity/relation embeddings and to shape reward. It turns out that ConvE performs better. Please see the appendix for the comparison of using two models in detail.}
on graph ,
and the embedding size is set to 32 for all methods except for ItemKNN, which has no latent representations. Meanwhile, we use the score function of ConvE to compute augmented rewards (i.e., Equation~\ref{eq:reward}). 
From Figure~\ref{fig:example}, we can see path patterns ``User->Item->Entity->item'' and ``User->Item->User->Item'' are more probable to be meaningful, so we empirically set the maximum path length  to 3 as our default setting. We select action dropout rate from \{0.1-0.9\}, dropout rate for entity/relation embeddings from \{0.1-0.9\} using grid search.
Meanwhile, grid search is also applied to select the optimal dropout rate for other baseline methods.
For training, we use Adam~\cite{kingma2014adam} optimizer for all neural models with batch size of 512.  During recommendation, we use beam search with beam size 64 to generate paths for target users. For duplicate paths leading to the same item, we keep the one with the highest probability. 
Finally, we adopt two different ranking strategies to generate final top-K recommendation list: (1) ranks the searched items according to the path probabilities and we denote it as \name, 2) ranks the searched items based on ``rewards'' defined by  in Equation~\ref{eq:reward} and we denote it as \name*.




\begin{table}[t!]
\centering\caption{Recommendation results of different models on three datasets.
}\label{tab::comparision}
\vspace{-3pt}
\scalebox{0.93}
{
    \begin{tabular}{lcccccc}
    \toprule
    \multirow{2}{*}{Model} & \multicolumn{2}{c}{Last.FM} & \multicolumn{2}{c}{MovieLens-1M} &  \multicolumn{2}{c}{DBbook2014} \\
    & HR@10 & NDCG@10 & HR@10 & NDCG@10 & HR@10 & NDCG@10 \\
    \midrule
ItemKNN & 0.0605 & 0.0511 & 0.0738 & 0.2273 & 0.0702 & 0.0665 \\
BPR-MF & 0.1199 & 0.0916 & 0.0895 & 0.1914 & 0.0829 & 0.0565 \\
\midrule
    RippleNet & 0.1008 & 0.0641 & 0.1269 & 0.2516 & 0.0763 & 0.0571 \\
    CFKG & 0.1781 & 0.1226 & 0.1393 & 0.2512 & 0.1428 & 0.1036 \\
    MKR & 0.1447 & 0.0850 & 0.1073 & 0.2245 & 0.0863 & 0.0575 \\
    KTUP & 0.1891 & 0.1566 & 0.1579 & 0.3230 & 0.1761 & 0.1299 \\\vspace{3pt}
    ConvE-Rec & 0.2426 & 0.1742 & 0.1993 & 0.3676 & 0.1850 & 0.1357 \\


\name & 0.2201 & 0.1552 & 0.1889 & 0.3543 & 0.1716 & 0.1266\\
    \name* & \textbf{0.2483} & \textbf{0.1766} & \textbf{0.1994} & \textbf{0.3699} & \textbf{0.1874} & \textbf{0.1371}\\
\midrule
Gain over KTUP & 31.31\% & 13.41\% & 26.28\% & 14.52\% & 6.41\% & 5.54\%\\  \bottomrule 
    \end{tabular}
}
\end{table}

\subsection{Analysis of Recommendation Performance}
We report the recommendation accuracy of different methods in Table~\ref{tab::comparision}. We can see that KG-based recommendation methods consistently outperform classical similarity-based methods, which indicates that knowledge graphs indeed help to alleviate the problem of data sparsity in the recommendation. Among KG-based recommendation methods, the RippleNet performs worst, which may be attributed to representing users with multi-hop away entities. KTUP performs strongly because it takes the advantages of both translation-based recommendation and multi-task learning. Note that the only difference between ConvE-Rec and CFKG is the used knowledge graph embedding methods; however, ConvE-Rec achieves much better performance. The reason behind this is that ConvE is a state-of-the-art knowledge graph embedding method, which outperforms TransE used in CFKG. By using pre-trained ConvE embeddings to augment rewards, our \name\ and \name* significantly outperform existing state-of-the-art KG-based recommendation methods in most cases and perform comparably to ConvE-Rec, which shows that our proposed methods are quite effective.  



\begin{figure}
\begin{floatrow}
\ffigbox{\includegraphics[width=0.43\textwidth]{figures/case_movie.pdf}}{\caption{
Recommendations and explanations for user \#2685 in MovieLens-1M dataset. ``Airplane!'' is recommended because it shares the same movie genre (i.e., Comedy) with ``Edge of Seventeen'', which the target user watched before.  
  }\label{fig::case}
}
\capbtabbox{\scalebox{0.85}
  {
  \begin{tabular}{cc}
  \toprule
  Explainable preference paths & Pct. (\%)  \\ 
  \midrule
  \text{U}\text{M}\text{U}\text{M} & 94.4 \\
  \text{U}\text{M}\text{G}\text{M} & 1.5 \\
   \midrule
   \text{U}\text{B}\text{U}\text{B} & 29.6 \\
   \text{U}\text{B}\text{WP}\text{B} & 27.4 \\
    \text{U}\text{B}\text{G}\text{B} & 25.4 \\
   \bottomrule
  \end{tabular}
  }
}{\caption{Most frequent path patterns during recommendation on MovieLens-1M (top) and DBbook2014 (bottom) datasets. ``U'', ``M'', ``G'', ``B'' and ``WP'' represent User, Movie, Genre, Book and WikiPage respectively.}
  \label{tab::case}
}
\end{floatrow}
\vspace{-3pt}
\end{figure}



\subsection{Analysis of Explainability}
After demonstrating the effectiveness of \name, we now illustrate its explainability, which is the main contribution of this work to recommender systems. As introduced in previous sections, \name\ provides recommendations by generating meaningful paths from users to items, where paths serve as explanations for recommended items. To give you an intuitive example, we randomly select a real user from MovieLens-1M dataset and search preference paths for her/him with \name. As shown in Figure~\ref{fig::case}, we can easily understand that ``Airplane!'' is recommended because it shares the same genre (i.e., comedy) with ``Edge of Seventeen'', which the user watched before. The second recommendation ``Raiders of the Lost Ark'' can be explained with the well-known rule ``Users who like A also like B''. 



Beyond explanations for an individual user, we are also interested in global preference path patterns discovered by \name. More specifically, we try to figure out what are the typical path patterns w.r.t. different datasets.
From Table~\ref{tab::case}, we can see that \name\ heavily relies on the path pattern ``UserMovieUserMovie'' on MovieLens-1M data. Additionally, \name\ learns more diverse path patterns such as ``UserBookWikiPageBook'' and ``UserBookGenrebook'', which lead to new books that share the same WikiPage or Genre with users' historical books respectively. The reason behind the discrepancy of path patterns on two datasets may be two folds. First, note that the average number of interactions for each user in MovieLens-1M data is about 100 while this number is 12 in DBbook2014 data. Therefore it is easier to find a user sharing similar movie preference in MovieLens-1M data than to find a user with similar reading taste in DBbook2014 data. 
Second, the size of supporting knowledge graph for DBbook2014 data is much larger than the number of user-item interactions, so our \name\ learns to make more use of external knowledge in this case.






\iffalse
\begin{table}
\centering\caption{Performance w.r.t. variants of our model.  is the full model, and [-] means removing that component from . We omit the similar results of .}\label{tab::ablation}
\begin{tabular}{lcccccc}
\toprule
\multirow{2}{*}{Model} & \multicolumn{2}{c}{Last.FM} & \multicolumn{2}{c}{MovieLens-1M} & \multicolumn{2}{c}{DBbook2014} \\
& HR@10 & NDCG@10 & HR@10 & NDCG@10 & HR@10 & NDCG@10 \\
\midrule \vspace{3pt}
 & 0.2504 & 0.1812 & 0.1994 & 0.3699 & 0.1874 & 0.1371 \\
-KG & 0.2193 & 0.1553 & 0.1983 & 0.3634 & 0.0924 & 0.0626 \\
-rs & 0.0673 & 0.0380 & 0.0338 & 0.0645 & 0.0514 & 0.0284 \\
-AD & 0.1976 & 0.1482 & 0.1953 & 0.3639 & 0.1814 & 0.1340 \\ 
(T=5) & 0.2322 & 0.1703 & 0.1986 & 0.3696 & 0.1707 & 0.1275 \\
\bottomrule
\end{tabular}
\end{table}
\fi



\begin{table}
\centering\caption{Performance w.r.t. model variants, where [-] means removing that component from the \name.}\label{tab::ablation}
\vspace{-3pt}
\scalebox{0.93}
{
\begin{tabular}{lcccccc}
\toprule
\multirow{2}{*}{Model} & \multicolumn{2}{c}{Last.FM} & \multicolumn{2}{c}{MovieLens-1M} & \multicolumn{2}{c}{DBbook2014} \\
& HR@10 & NDCG@10 & HR@10 & NDCG@10 & HR@10 & NDCG@10 \\
\midrule \vspace{3pt}
\name\ & 0.2201 & 0.1552 & 0.1889 & 0.3543 & 0.1716 & 0.1266 \\
\name-KG & 0.2061 & 0.1466 & 0.1869 & 0.3489 & 0.0802 & 0.0525 \\
\name-RS & 0.0614 & 0.0349 & 0.0654 & 0.1132 & 0.1174 & 0.0867 \\
\name-AD & 0.1350 & 0.0827 & 0.1715 & 0.3217 & 0.1449 & 0.1083 \\ 
\name\ (T=5) & 0.2108 & 0.1505 & 0.1859 & 0.3500 & 0.1524 & 0.1125 \\
\bottomrule
\end{tabular}
}
\end{table}

\iffalse
\begin{table}
\centering\caption{Ablation study. }\label{tab::ablation}
\begin{tabular}{lcccccc}
\toprule
\multirow{2}{*}{Model} & \multicolumn{2}{c}{Last.FM} & \multicolumn{2}{c}{MovieLens-1M} & \multicolumn{2}{c}{DBbook2014} \\
& HR@10 & NDCG@10 & HR@10 & NDCG@10 & HR@10 & NDCG@10 \\
\midrule \vspace{3pt}
\name T5-R & 0.2530 & 0.1826 & 0.1998 & 0.3704 &  0.1773 & 0.1312  \\
\name T5-R-KG & 0.2138 & 0.1520 & 0.1990 & 0.3633 & 0.0825 & 0.0571 \\
\name T5-R-RS & 0.0217 & 0.0127 & 0.0116 & 0.0264 & 0.0149 & 0.0083 \\
\name T5-R-AD & 0.1997 & 0.1440 & 0.1930 & 0.3618 & 0.1696 & 0.1248 \\ 
\bottomrule
\end{tabular}
\end{table}
\fi



\subsection{Ablation Study}\label{subsec:ablation}
In this section, we compare different variants of \name\ to show the influences of some essential components such as KG, reward shaping, action dropout and maximum path length , which are denoted as \name-KG, \name-RS, \name-AD and \name\ (T=5) respectively in Table~\ref{tab::ablation}. 
We find the influence of KG is very significant on Last.FM and DBbook2014 datasets. This is because these two datasets are extremely sparse, while the MovieLens-1M data is relatively dense. 
Removing reward shaping leads to a severe performance drop on all datasets because \name\ without reward shaping assigns zero rewards to all items that a user has not interacted with. In this way, the agent is penalized for exploring potential items that are of interest to users and therefore cannot effectively generate recommendations.
Besides reward shaping, we also use action dropout to further encourage the agent to explore diverse paths, and we can see that \name-AD performs worse than the full model \name. 
At last, we try a larger maximum path length  to enable the agent to explore longer paths. We find that \name\ (T=5) performs worse than \name\ on all datasets.
This is because long paths may introduce more noise and thus be less meaningful. However, thanks to the stop mechanism, the performance drop is not significant. 
The details about path patterns of \name\ (T=5), which further shows the role of stop action,
are included in the appendix.


\subsection{Convergence Analysis}
We present the running time of \name\ in Figure~\ref{fig::time_reward}. As can be seen, \name\ converges fast on MovieLens-1M dataset with less than ten minutes, while it takes longer to converge on the other two datasets. The reason for different convergence behaviors is that it is easier to walk to correct items on dense datasets (e.g., MovieLens-1M) than on sparse datasets (e.g., DBbook2014). Overall, our \name\ is efficient because we initialize entity/relation embeddings with pre-trained knowledge graph embeddings, and we use reward shaping to augment reward signals.


\begin{figure}
\includegraphics[width=0.9\textwidth]{figures/time_reward.pdf}
\caption{Results of running time with batch size of 512 and maximum path length of 3. The x-axis is the training time in minutes, and the y-axis is the average rewards over training samples.
}\label{fig::time_reward}
\end{figure}
 \section{Conclusion}
In this paper, we introduced a novel approach to provide explanations for recommendation with knowledge graphs.
Our proposed \name\ generates meaningful paths from users to relevant items by learning a walk policy on the user-item-entity graph.
Experimental results show that \name\ outperforms existing KG-based recommendation methods and is quite efficient. Furthermore, we demonstrate the explainability of \name\ via insightful case studies on different datasets. Future work includes incorporating domain knowledge to design proper reward functions for recommendation task and developing a distributed version of \name\ for even larger datasets.
%
 \subsubsection*{Acknowledgments}
The authors would like to thank Meng Qu and Zafarali Ahmed for providing useful feedback on initial versions of the manuscript. We also thank Yue Dong and Zhaocheng Zhu for editing the manuscript. WS and MZ are partially supported by Beijing Municipal Commission of Science and Technology under Grant No. Z181100008918005 as well as the National Natural Science Foundation of China (NSFC Grant Nos.61772039 and 91646202). WS also acknowledges the financial support by Chinese Scholarship Council. JT is supported by the Natural Sciences and Engineering Research Council of Canada, as well as the Canada CIFAR AI Chair Program.

 
\bibliographystyle{plain}
\bibliography{reference}
\newpage
\appendix
\section{Appendix}
\subsection{\name\ with Different KGE Methods}\label{sec::distmult}



Our proposed \name\ is independent of the knowledge graph embedding methods, which are utilized to pre-train entity/relation embeddings for initialization and reward shaping.
Therefore we also test our model with another widely-used knowledge graph embedding method DistMult. The score functions of DistMult and ConvE are presented in Table~\ref{tab::score_func}. For a fair comparison, we use the same experimental settings and just substitute DistMult for ConvE in our experiments. Following ConvE-Rec, we denote recommendation with DistMult as DistMult-Rec.


The results of using different knowledge graph embedding methods are presented in Table~\ref{tab::distmult}. First, we can see that ConvE-Rec outperforms DistMult-Rec on all datasets. This is because ConvE has proven more effective than DistMult for knowledge graph embedding, as a result of which our \name\ with ConvE also outperforms \name\ with DistMult. Second, \name\ (DistMult) and \name* (DistMult) outperform DistMult-Rec on Last.FM and MovieLens-1M datasets and perform comparably to DistMult-Rec on DBbook2014 dataset, which is consistent with the observations of \name\ (ConvE) and \name* (ConvE). 



\begin{table}[ht]
    \centering
    \begin{tabular}{cc}
    \toprule
        Model & Score function   \\
        \midrule
        DistMult &  \\
        ConvE &  \\
    \bottomrule
    \end{tabular}
    \caption{Score functions w.r.t. different KGE methods, where  denotes generalized inner product of three vectors,  denotes a 2D shaping of vectors,  is the convolution operator,  denotes filters in convolutional layers,  is a non-linear activation function and \cdot converts a tensor to a vector. ,  and  are embeddings of user , entity  and relation ``Interact'' respectively.}
    \label{tab::score_func}
\end{table}



\begin{table}[ht]
\centering\caption{Effectiveness comparison of using different knowledge graph methods for entity/relation initialization and reward shaping.}\label{tab::distmult}
\begin{tabular}{lcccccc}
\toprule
\multirow{2}{*}{Model} & \multicolumn{2}{c}{Last.FM} & \multicolumn{2}{c}{MovieLens-1M} & \multicolumn{2}{c}{DBbook2014} \\
& HR@10 & NDCG@10 & HR@10 & NDCG@10 & HR@10 & NDCG@10 \\
\midrule 
ConvE-Rec & 0.2426 & 0.1742 & 0.1993 & 0.3676 & 0.1850 & 0.1357 \\\vspace{3pt}
DistMult-Rec & 0.1730 & 0.1174 & 0.1773 & 0.3341 & 0.1535 & 0.1090 \\
\name\ (ConvE) & 0.2201 & 0.1552 & 0.1889 & 0.3543 & 0.1716 & 0.1266\\\vspace{3pt}
\name\ (DistMult) & 0.1999 & 0.1397 & 0.1761 & 0.3352 & 0.1367 & 0.0958 \\
\name* (ConvE) & {0.2438} & {0.1766} & {0.1994} & {0.3699} & {0.1874} & {0.1371}\\
\name* (DistMult) & 0.1887 & 0.1265 & 0.1774 & 0.3343 & 0.1482 & 0.1061 \\
\bottomrule
\end{tabular}
\end{table}

\newpage
\subsection{Further Analysis of \name\ (T=5)}\label{app::t5}
In the previous experiments, we see that \name\ (T=5) performs a little worse than \name because long paths may not be meaningful and thus lead to bad recommendations. Now we present the path patterns of \name\ (T=5) on dense dataset MovieLens-1M and sparse dataset Last.FM.

We have two observations from Table~\ref{tab::T5_case}. First, there are many paths of length five, which means that our agent is recommending items that have high-order similarity to users' historical items. Second, as the Last.FM dataset is very sparse, items with high-order similarity may be less relevant. Therefore our \name\ learns to take stop actions within 11.2\% paths.







\begin{table}[ht]
\centering\caption{Most frequent path patterns during recommendation on MovieLens-1M (top) and Last.FM (bottom) datasets. ``U'', ``M'', `C`, ``G'' and ``A'' represent User, Movie, Country, Genre and Artist respectively.}\label{tab::T5_case}
  \begin{tabular}{cc}
  \toprule
  Explainable preference paths & Pct. (\%)  \\ 
  \midrule
  \text{U}\text{M}\text{U}\text{M}UM & 60.6 \\
  \text{U}\text{M}\text{U}\text{M}\text{C}\text{M} & 19.5 \\  
  \text{U}\text{M}\text{U}\text{M}\text{G}\text{M} & 12.4 \\
   \midrule
  \text{U}\text{A}\text{U}\text{A}UA & 87.5 \\
 \text{U}\text{A}UAAA & 11.2 \\

   \bottomrule
  \end{tabular}
\end{table}
 
\end{document}
