\documentclass{sig-alternate-2013}
\makeatletter
\def\ps@headings{\def\@oddhead{\mbox{}\scriptsize\rightmark \hfil \thepage}\def\@evenhead{\scriptsize\thepage \hfil \leftmark\mbox{}}\def\@oddfoot{}\def\@evenfoot{}}
\makeatother
\pagestyle{headings}
 
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{amsmath} \usepackage{graphicx}
\usepackage{subfigure}
\usepackage{bbm}
\usepackage{bm}
\usepackage{overpic}
\usepackage[hidelinks]{hyperref}


\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{example}{Example}
\newtheorem{proposition}{Proposition}

\newcommand{\capp}{\operatorname{cap}}
\newcommand{\lex}{\operatorname{lex}}



\makeatletter
\def\@copyrightspace{\relax}
\makeatother

\begin{document}


\title{Loop-Free Backpressure Routing \\ Using Link-Reversal Algorithms}
\numberofauthors{4}
\author{
\alignauthor
Anurag Rai\\
       \affaddr{LIDS, MIT}\\
       \affaddr{Cambridge, MA, USA}\\
       \email{rai@mit.edu}
\alignauthor
Chih-ping Li\\
	\affaddr{Qualcomm Research}\\
	\affaddr{San Diego, CA, USA}\\
	\email{cpli@qti.qualcomm.com}
\and
\alignauthor
Georgios Paschos\\
	\affaddr{Mathematical and Algorithmic Sciences Lab}\\
	\affaddr {France Research Center}\\
	\affaddr{Huawei Technologies Co., Ltd.}\\
	\email{georgios.paschos@huawei.com}
\alignauthor
Eytan Modiano\\
       \affaddr{LIDS,MIT}\\
       \affaddr{Cambridge, MA, USA}\\
       \email{modiano@mit.edu}
}

\maketitle
\begin{abstract}
The backpressure routing policy is known to be a throughput optimal policy that supports any feasible traffic demand in data networks, but may have poor delay performance when packets traverse loops in the network. In this paper, we study loop-free backpressure routing policies that forward packets along directed acyclic graphs (DAGs) to avoid the looping problem. These policies use link reversal algorithms to improve the DAGs in order to support any achievable traffic demand.

For a network with a single commodity, we show that a DAG that supports a given traffic demand can be found after a finite number of iterations of the link-reversal process. We use this to develop a joint link-reversal and backpressure routing policy, called the loop free backpressure (LFBP) algorithm. This algorithm forwards packets on the DAG, while the DAG is dynamically updated based on the growth of the queue backlogs. We show by simulations that such a DAG-based policy improves the delay over the classical backpressure routing policy. We also propose a multicommodity version of the LFBP algorithm, and via simulation we show that its delay performance is better than that of backpressure.


\end{abstract}
\section{Introduction}
Throughput and delay are the two major  metrics used to evaluate the performance of communication networks.
For networks that exhibit high variability, such as mobile ad~hoc networks, the dynamic backpressure routing policy  \cite{tassiulas} 
is a highly desirable solution,  known to maximize  throughput in a wide range of settings. 
However,  the delay performance of backpressure is  poor \cite{srikant}.
 The high delay is attributed to  a property of  backpressure that allows the packets to loop within the network instead of moving towards the destination. 
 In this paper we  improve the delay performance of backpressure routing by constraining the data routing along loop free paths.

 
To eliminate  loops in the network, we assign directions to the links such that the network becomes a directed acyclic graph (DAG). 
Initially, we generate an  arbitrary DAG and use backpressure routing over it.
If the initial DAG has max-flow smaller than  the traffic demand, parts of the network become overloaded. 
By reversing the direction of the links that point from non-overloaded to overloaded nodes a new DAG with a lower overload is obtained. 
Iterating over this process, our distributed algorithm gradually converges to a DAG that supports any  traffic demand  feasible in the network. Hence the loop-free property is achieved without the loss of throughput.


Prior work  identifies  looping as a main cause for high delays in backpressure routing and proposes delay-aware backpressure techniques. 
Backpressure enhanced with hop count bias is first proposed  in \cite{neely_enhanced} to drive packets through  paths with smallest hop counts when the load is low.  
An alternative backpressure modification that utilizes shortest path information is proposed in \cite{ying}. 
A different line of works proposes to learn the network topology using backpressure and then use this information to enhance routing decisions. In \cite{atilla} backpressure is constrained to a subgraph which is discovered by running unconstrained backpressure for a time period and computing the average number of  packets routed over each link. Learning is  effectively used in scheduling \cite{huang} and utility optimization \cite{longbo} for wireless networks.
In our work we aim to eliminate loops by restricting backpressure to a DAG, while we dynamically improve the DAG by reversing links.

The link-reversal algorithms were introduced in \cite{gafni_bertsekas} as a means to maintain connectivity in networks with volatile links.  These distributed algorithms react to any topological changes to obtain a DAG such that each node has a loop-free path  to the destination.  In \cite{tora}, one of the link-reversal algorithms was used to design a routing protocol (called TORA) for multihop wireless networks. Although these algorithms provide loop free paths and guarantee connectivity from the nodes to the destination, they do not maximize throughput. Thus, the main goal of this paper is to create a new link-reversal algorithm and combine it with the backpressure algorithm to construct a distributed throughput optimal algorithm with improved delay performance.


The main contributions of this paper are as follows:
\begin{itemize}
\itemsep0em 
\item  For a DAG with a single commodity, we study the  lexicographic optimization of the queue growth rate.
We develop a novel link-reversal algorithm that reverses link direction based on overload conditions to form a new DAG
with lexicographically smaller queue growth rates. 
\item We show that the queue backlog information from backpressure routing can be used to perform the link reversals. We develop loop free backpressure (LFBP) algorithm, a  distributed routing scheme  that eliminates loops and  retains the throughput optimality property.
\item Our simulation results of LFBP show a significant delay improvement over backpressure in static and dynamic networks. 
\item We extend the LFBP algorithm to networks with multiple commodities, and provide a simulation result to show its delay improvement over backpressure.
 \end{itemize}









\section{System Model and Definitions}
\subsection{Network model}
We consider the problem of routing single-commodity data packets in a network. The network is represented by a graph , where  is the set of nodes and  is the set of undirected links  with capacity . Packets arrive at the source node  at rate   and are destined for a receiver node .  Let  denote the maximum flow from node  to   in the network .
The quantity  is the maximally achievable throughput at the destination node . 


To avoid unnecessary routing loops, we restrict forwarding along a directed acyclic graph (DAG) embedded in the graph . 
An optimal DAG exists to support the max-flow  and can be found by: 
(i) computing a feasible flow allocation  that yields the max-flow  in   (e.g.~using \cite{FordFulkerson}); 
(ii) trimming any positive flow on  directed cycles; 
(iii) defining an embedded DAG by assigning  a direction for each link  according to the direction of the flow  on that link. 
Since backpressure achieves the max-flow of a constrained graph \cite{neely_georgiadis}, performing backpressure routing over the optimal DAG supports .



This centralized approach is unsuitable for mobile ad-hoc networks, which are based on wireless links with  time-varying  capacities and may undergo frequent topology changes. 
In such situations,  the  optimal embedded DAG  also changes with time, which  requires  constantly repeating the above offline process.
Instead, 
it is possible to use a distributed  adaptive mechanism that   reverses the direction of links until  a DAG that supports the current traffic demand is found.
In this paper we propose  an  algorithm that  reacts to the traffic conditions by changing the directions of some links. 
 To understand the properties of 
the link-reversing operations, we first study the fluid level behavior of a network under overload conditions.

\subsection{Flow equations}

Consider an embedded DAG  in the network graph , where  is the set of network nodes and  is the set of directed links.\footnote{The notation  of an embedded DAG is useful in the paper; it will denote the DAG that is formed after the th iteration of the link-reversal algorithm.} For each link , either  or  belongs to  (but not both). Each directed link  has the capacity of the undirected counterpart , which is .
Let  be the maximum flow of the DAG  from the source node  to the destination node .
Any embedded DAG has smaller or equal max-flow with respect to ,   

For two disjoint subsets  and  of nodes in , we define  as the total capacity of the directed links going from  to , i.e.,




A cut 
is 
a partition of nodes  such that  and . A cut  is 
a min-cut if 
it minimizes the expression  over all cuts. 
By the max-flow min-cut theorem , where  is the min-cut of the DAG .
We remark that a cut in a DAG is also a cut in  or another DAG.
However, the value of  depends on the graph considered (see summation in (\ref{eq:202})).


We consider the network as a time-slotted system, where slot  refers to the time interval , . Each network node  maintains a queue , where  also denotes the queue backlog at time . We have  for all  since the destination node  does not buffer packets. Let  be the number of exogenous packets arriving at the source node  in slot . Under a routing policy that forwards packets over the directed links defined by the DAG , let  be the number of packets that are transmitted over the directed link  in slot ; the link capacity constraint states that  for all . The queues  are updated over slots according to

where  is an indicator function. 

To study the overload behavior of the system we define
the queue overload (i.e., growth) rate at node  as

Additionally, define the exogenous packet arrival rate  and  the flow  over a directed link   as

where the above limits are assumed to exist almost surely (see \cite{georgiadis} for details). Using the recursion (\ref{eq:101}), taking time averages and letting , we have the fluid-level equation:

Equations~\eqref{eq:105} and~\eqref{eq:106} are the flow conservation and link capacity constraints, respectively. A network node  is said to be overloaded if its queue growth rate  is positive, which implies that  as  (see~\eqref{eq:104} and~\cite{Nee10book}). Summing~\eqref{eq:105} over  yields

where  denotes the throughput received at the destination  .
Therefore, equation~\eqref{eq:107} states that the received throughput 
is equal to the exogenous arrival rate  less the sum of queue growth rates  in the network.

\subsection{Properties of queue overload vector}

If the traffic arrival rate  is strictly larger than the maximum flow  of the DAG , then some network nodes will be overloaded. It is because, from~\eqref{eq:107}, we have

which implies that  for some node . Let  be the queue overload vector. A queue overload vector  is feasible in the DAG  if there exist overload rates  and flow variables  that satisfy~\eqref{eq:105} and~\eqref{eq:106}. Let  be the set of all feasible queue overload vectors in . We are interested in the \emph{lexicographically smallest} queue overflow vector in set . Formally, given a vector , let  be the th maximal component of . We say that a vector  is \emph{lexicographically smaller} than a vector , denoted by , if  or  for all  and  for some . If  for all , then the two vectors are lexicographically equal, represented by .\footnote{As an example, the two vectors  and  satisfy  because , , and .} 
The above-defined vector comparison induces a total order on the set  , and hence the existence of a lexicographically smallest vector is always   guaranteed \cite{georgatsos}. 


\begin{lemma}[\cite{georgiadis}] \label{lem:201}
Let  be the lexicographically smallest vector in the queue overload region  of the DAG . We have the following properties:
\begin{enumerate}
\itemsep0em 
\item The vector  exists and is unique in the set .
\item The vector  minimizes the sum of queue overload rates, i.e., it is a solution to the optimization problem:

(direct consequence of Theorem 1 in \cite{georgiadis}). Due to~\eqref{eq:107}, the corresponding throughput is maximized.
\item  A feasible flow allocation vector  induces  if and only if over each link  the following holds:
 
\end{enumerate}

\end{lemma}

In general, there are many flow allocations that yield the maximum throughput. Focusing on those that additionally induce  has two advantages. First, as  shown next, these allocations lead to link-reversal operations that improve the max-flow of the DAG . Second, the backpressure algorithm can be used to preform the same reversals and improve the max-flow; we will use this observation in Section~\ref{dynamic algorithm} to combine link-reversal algorithms with backpressure routing.



\section{Link-Reversal Algorithms} \label{sec:link_reversal}

The link-reversal algorithms given in \cite{gafni_bertsekas} were designed to maintain a path from each node in the network to the destination. One algorithm relevant to this paper is  the \emph{full reversal method}. This algorithm is triggered when some nodes  lose all of their outgoing links. At every iteration of the algorithm, nodes , that have no outgoing link, reverse the direction of all their incoming links. This process is repeated until all the nodes other than the destination have at least one outgoing link. When the process stops these nodes are guaranteed to have a path to the destination.
The example in Figure \ref{fig:gb_example}, taken from \cite{gafni_bertsekas}, illustrates this algorithm at work. 
\begin{figure}[h!]
\centering
\subfigure[]{
\begin{overpic}[scale=.42]	{figures/gafni_bertsekas_eg0_nostate.pdf}
	\put (45,4) {\small }
\end{overpic}
\label{fig:gb0}
}
\subfigure[]{
\begin{overpic}[scale=.42]	{figures/gafni_bertsekas_eg1_nostate.pdf}
	\put (45,4) {\small }
\end{overpic}
\label{fig:gb1}
}
\subfigure[]{
\begin{overpic}[scale=.42]	{figures/gafni_bertsekas_eg2_nostate.pdf}
	\put (45,4) {\small }
\end{overpic}
\label{fig:gb2}
}
\subfigure[]{
\begin{overpic}[scale=.42]	{figures/gafni_bertsekas_eg3_nostate.pdf}
	\put (45,4) {\small }
\end{overpic}
\label{fig:gb3}
}
\subfigure[]{
\begin{overpic}[scale=.42]	{figures/gafni_bertsekas_eg4_nostate.pdf}
	\put (45,4) {\small }
\end{overpic}
\label{fig:gb4}
}
\caption{Illustration of the full reversal method of \cite{gafni_bertsekas} when the dashed link in Figure \ref{fig:gb0}  is lost. At every iteration, the algorithm reverses all the links incident to the nodes with no outgoing link.}
\label{fig:gb_example}
\end{figure}


Although the full reversal algorithm guarantees connectivity, the resulting throughput may be significantly lower than the maximum possible. Hence, in this paper we shift the focus from connectivity to maximum throughput. Specifically, we propose a novel link-reversal algorithm that produces a DAG which supports the traffic demand , assuming . We do this by quickly constructing an initial DAG and improving upon it in multiple iterations.

\subsection{Initial DAG}  \label{sec: initial dag}
We assume that each node in the network has a unique ID. These IDs give a topological ordering to the nodes. So, the initial DAG can be created simply by directing each link to go from the node with the lower ID to the node with the higher ID. If the unique IDs are not available, the initial DAG can be created by using a strategy such as the one given in \cite{tora}.



\subsection{Overload detection}

Given a DAG , , we suppose that there is a routing policy  that yields the lexicographically minimal queue overload vector . \footnote{Such a policy  can simply solve an optimization problem offline to compute the required flow allocation. In Section~\ref{dynamic algorithm}, we develop a distributed algorithm using backpressure that does not require the computation of the lexicographically optimal overload vector. We use this vector only to prove the properties of our link-reversal algorithm.} 
Then we use the vector 
to detect node overload and decide whether a link should be reversed.

If the data arrival rate  is less than or equal to the maximum flow  of the DAG , then there exists a flow allocation  that supports the traffic demand and yields zero queue overload rates  at all nodes . By  the second property of Lemma~\ref{lem:201} and nonnegativity of the overload vector,
the queue overload vector  is zero.
 Thus, the throughput under policy  is    according to~\eqref{eq:107}, and the current DAG   supports ; no link-reversal operations are needed. 

On the other hand, if the arrival rate  is strictly larger than the maximum flow , 
by the second property in Lemma~\ref{lem:201}  
the maximum throughput is  and
the queue overload vector  is nonzero because we have  from~\eqref{eq:201} that

We may therefore detect the event ``DAG   supports '' by testing whether  the overload vector 
 is zero or  non-zero.

The next lemma shows that if DAG   does not support  then it contains at least one  under-utilized link (our link-reversal algorithm will reverse the direction of such links to improve network throughput).
\begin{lemma}\label{lem: backward link}
Suppose that the traffic demand  satisfies

where  is the max-flow of the DAG  and  is the max-flow of the undirected network .
Then 
there exists a link  such that  and .
\end{lemma}

\begin{proof}[of Lemma~\ref{lem: backward link}]
Let  be the set of overloaded nodes  under a flow allocation that induces the lexicographically minimal overload vector  in the DAG ; the set  is nonempty due to  and~\eqref{eq:201}. It follows that the partition  is a min-cut of  (see Lemma~\ref{MIN-CUT} in the Appendix).\footnote{The set  contains the destination node  and is nonempty.} By the max-flow min-cut theorem, the capacity of the min-cut  in  satisfies .

The proof is by contradiction. Let us assume that there is no directed link that goes from the set  to  in the DAG . It follows that  is the sum of capacities of all undirected links between the sets  and , i.e., 

which is equal to the value of the cut  in graph .
Since the value of any cut is larger or equal to the min-cut, applying the max-flow min-cut theorem on  we have

which contradicts the assumption that .
\end{proof}


\subsection{Link reversal}

Lemma~\ref{lem: backward link} shows that if the DAG  has insufficient capacity to support the traffic demand , then there exists a directed link from an underloaded node  to an overloaded one  under the lexicographically minimum overflow vector . 
Because of property \eqref{property1}, we may infer that this link is not utilized. Next we show that reversing the direction of this link provides a strictly improved DAG.

We consider the link-reversal algorithm (Algorithm \ref{alg: link reversal}) that reverses all such links that satisfy the property in Lemma~\ref{lem: backward link}. This reversal yields a new directed graph .
\begin{algorithm}[h!] 
\caption{Link-Reversal Algorithm}
\label{alg: link reversal}
\begin{algorithmic}[1]
	\ForAll {}
		\If{} 
			\State 
		\Else
			\State 
		\EndIf
	\EndFor
\end{algorithmic}
\end{algorithm}

\begin{lemma} \label{lem: graph is dag}
The directed graph  is acyclic.
\end{lemma}
\begin{proof}[of Lemma~\ref{lem: graph is dag}]
Recall that   is the set of overloaded nodes in the DAG  under the lexicographically minimum queue overload vector . Let  be the set of undirected links between  and . Algorithm~\ref{alg: link reversal} 
changes the link direction in a subset of . More precisely, it 
enforces the direction of all links in  to go from  to .

We complete the proof by construction in two steps. First, we remove all links in  from the DAG , resulting in two disconnected subgraphs that are DAGs themselves. Second, consider that we add a link in  back to the network with the direction going from  to . This link addition does not create a cycle because there is no path from  to , and the resulting graph remains to be a DAG. We can add the other links in  one-by-one back to the graph with the direction from  to ; similarly, these link additions do not create cycles. The final directed graph is , and it is a DAG. See Fig.~\ref{fig:reversal} for an illustration.
\end{proof}

\begin{figure}[h]
\centering
\subfigure[The DAG  with .]{
\begin{overpic}[scale=.42]	{figures/before_reversal.pdf}
	\put (4.5,36) {\small }
	\put (32,64) {\small 2}
	\put (62,64) {\small 3}
	\put (91,35) {\small 5}
	\put (32,5) {\small 1}
	\put (62,5) {\small }

	\put (0,55) {\small  = 3}
	\put (20,44) {\small 2}
	\put (20,26) {\small 1}

	\put (72,44) {\small 1}
	\put (72,26) {\small 1}

	\put (37,35) {\small 1}
	\put (55,35) {\small 1}

	\put (45,59) {\small 2}
	\put (45,10) {\small 1}
\end{overpic}
\label{fig:before}
}
\subfigure[Two disconnected DAGs formed by removing all links between  and .]{
\begin{overpic}[scale=.42]	{figures/links_removed.pdf}
	\put (4.5,36) {\small }
	\put (32,64) {\small 2}
	\put (62,64) {\small 3}
	\put (91,35) {\small 5}
	\put (32,5) {\small 1}
	\put (62,5) {\small }
\end{overpic}
\label{fig:separated}
}
\subfigure[The DAG  formed by adding all links in  back to the graph with the direction going from  to .]{
\begin{overpic}[scale=.42]	{figures/after_reversal.pdf}
	\put (4.5,36) {\small }
	\put (32,64) {\small 2}
	\put (62,64) {\small 3}
	\put (91,35) {\small 5}
	\put (32,5) {\small 1}
	\put (62,5) {\small }

	\put (0,55) {\small  = 3}
	\put (20,44) {\small 2}
	\put (20,26) {\small 1}

	\put (72,44) {\small 1}
	\put (72,26) {\small 1}

	\put (37,35) {\small 1}
	\put (55,35) {\small 1}

	\put (45,59) {\small 2}
	\put (45,10) {\small 1}
\end{overpic}
\label{fig:after}
}
\caption{Illustration for the proof of Lemma~\ref{lem: graph is dag}.}
\label{fig:reversal}
\end{figure}

The next lemma shows that the new DAG  supports a lexicographically \emph{smaller} optimal overload vector (and therefore potentially better throughput) than the DAG .
\begin{lemma} \label{lem: monotonicity}
Let  be a DAG with the maximum flow . The DAG , obtained by performing  Algorithm~\ref{alg: link reversal} over , has the lexicographically minimum queue overload vector satisfying .
\end{lemma}
\begin{figure}[h]
\centering
\subfigure[Link  before the link reversal.]{
\centering
\begin{overpic}[scale=.45, trim=0in 0in 0in .1in]	{figures/link_before_reversal.pdf}
	\put (16,8) {\small }
	\put (81,8) {\small }

	\put (5,25) {\small }
	\put (70,25) {\small }

	\put (40,15) {\small }
\end{overpic}
}
\subfigure[Link  after the link reversal.]{
\centering

\begin{overpic}[scale=.45, trim=0in 0in 0in .1in]{figures/link_after_reversal.pdf}
	\put (16,8) {\small }
	\put (81,8) {\small }

	\put (5,25) {\small }
	\put (65,25) {\small }

	\put (40,15) {\small }
\end{overpic}
}

\caption{A link  in the network in Fig.~\ref{fig:reversal} before and after link reversal. Before the reversal, the flow  is zero on .  After the reversal, an  flow can be sent over  so that , while the rest of the flow allocation remains the same.}
\label{fig: monotonicity}
\end{figure}
\begin{proof}[of Lemma~\ref{lem: monotonicity}]
Consider a link  such that  and  ; this link exists by Lemma~\ref{lem: backward link}. From the property (\ref{property1}), any feasible flow allocation  that yields the lexicographically minimum overload vector  must have  over link . The link-reversal algorithm reverses the link  so that  in the DAG . Consider the following feasible flow allocation  on the DAG :

where  is a sufficiently small value. In other words, the flow allocation  is formed by reversing links and keeping the previous flow allocation  except that we forward an -amount of overload traffic from node  to . Let  be the resulting queue overload vector. We have

Therefore,  (see Fig.~\ref{fig: monotonicity} for an illustration). Let  be the lexicographically minimal overload vector in . It follows that , completing the proof.
\end{proof}























\begin{theorem} \label{thm: main}
Suppose the traffic demand is feasible in , i.e., , and the routing policy induces the overload vector  at every iteration . Then, the link-reversal algorithm will find a DAG whose maximum flow supports  in a finite number of iterations.
\end{theorem}
\begin{proof}[of Theorem~\ref{thm: main}]
The link-reversal algorithm creates a sequence of DAGs  in which a strict improvement in the lexicographically minimal overload vector is made after each iteration, i.e.,

The lexicographically minimal overload vector is unique in a DAG by Lemma~\ref{lem:201}, the DAGs  must all be distinct. Since there are a finite number of unique DAGs in the network, the link-reversal algorithm will find a DAG  that has the lexicographically minimal overload vector  and the maximum flow  in a finite number of iterations; this DAG  exists because the undirected graph  has the maximum flow .
\end{proof}

\subsection{Arrivals outside stability region}
We show that even when , the link reversal algorithm will stop reversing the links in a finite number of iterations, and it will obtain the DAG that supports the maximum throughput . We begin by examining the termination condition of our algorithm and show that if the algorithm stops at iteration , then the DAG  supports the max-flow of the network. 

\begin{lemma}
Consider the situation when . If there  is no link  such that  and , then  and . That is, if there are no links to reverse at iteration , and , then the throughput of  is equal to .
\end{lemma}
\begin{proof}
Let  be the set of overloaded nodes under a flow allocation that induces the lexicographically minimal overload vector  in the DAG . We know that  is a min-cut of the network from Lemma~\ref{MIN-CUT} (in the appendix), so 

Suppose the link reversal algorithm stops after iteration , i.e. at iteration  there are no links to reverse. In this situation, there  is no link  such that  and , so by property (9), all the links between  and  go from  to . The capacity of the cut  is given by 

This is equal to the capacity of the cut  in the undirected network . So . Because  cannot be greater than , . By assumption , so .
\end{proof}

When , this lemma shows that the link reversal algorithm stops only when the DAG achieves the maximum throughput of the network.  Hence, if the DAG doesn't support the maximum throughput, then there exists a link that can be reversed. After each reversal, Lemma \ref{lem: graph is dag} holds, so the directed graph obtained after the reversal is acyclic. We can modify Lemma \ref{lem: monotonicity} to show that every reversal produces a DAG that supports  an improved lexicographically optimal overload vector. We can combine these results to prove the following theorem.
\begin{theorem}
Suppose the traffic demand is not feasible in , i.e., , and the routing policy induces the overload vector  at every iteration . Then, the link-reversal algorithm will find a DAG whose maximum flow supports  in a finite number of iterations.
\end{theorem}


\section{Distributed Dynamic Algorithm} \label{dynamic algorithm}

In the previous sections we developed a link reversal algorithm based on the assumption that we had a routing policy that lexicographically minimized the overload vector . The algorithm reversed all the links that went from the set of all the non-overloaded nodes  to the set of overloaded nodes . We showed that repeating this process for some iterations results in a DAG that supports the arrival rate . 

The goal of this paper is to develop a link reversal algorithm based on backpressure. To achieve this goal, we develop a threshold based algorithm that identifies the cut  using the queue backlog information of backpressure. We can use this cut to perform the same link reversals as in Section \ref{sec:link_reversal} without computing the lexicographically minimum overload vector. Hence, this algorithm generates the same sequence of DAGs as the link reversal algorithm described in the previous section. So, all the previous theorems hold, and the new algorithm will obtain the DAG that supports the arrival rate  (when possible). We will call this algorithm the loop free backpressure (LFBP) algorithm.





We begin by creating an initial DAG  using 
 the method presented in Section \ref{sec: initial dag}. Then, we use the backpressure algorithm to route the packets from the source to the destination over .
 Let  be the queue length  at node  in slot . The backpressure algorithm can be written as in Algorithm \ref{alg: backpressure}. It simply sends packets on a link  if node  has more packets than .

\begin{algorithm} [h]
\caption{Backpressure algorithm (BP)}
\label{alg: backpressure}
\begin{algorithmic}[1]
\ForAll{} 
	\If{}
		\State Transmit  packets from   to 
\EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

Since backpressure is throughput optimal \cite{tassiulas}, if the arrival rate is less than  , then all queues are stable.
If the arrival rate is larger than , the system is unstable and the queue length  grows at some nodes. In this case, the next lemma shows that if we were using a routing policy that produced the optimal overload vector , the set of all the overloaded nodes  and the non-overloaded nodes   form the smallest min-cut of the DAG .

\begin{definition}\label{def:smallest min-cut}
We define the smallest min-cut  in the DAG  as the min-cut with the smallest number of nodes in the source side of the cut, i.e.,  solves

\end{definition}

\begin{lemma}\label{SMALLEST MIN-CUT}
Let   the set of overloaded nodes under a flow allocation  that induces the lexicographically minimum overload vector in the DAG . If , then  is the unique smallest min-cut in .
\end{lemma}
\begin{proof}[of Lemma~\ref{SMALLEST MIN-CUT}]
The proof is in Appendix~\ref{app:B}.
\end{proof}



Essentially, at every iteration, the link reversal algorithm of Section \ref{sec:link_reversal} discovers the smallest min-cut  of the DAG  and reverses the links that go from  to . Now the following theorem shows that the backpressure algorithm can be augmented with some thresholds to identify the smallest min-cut.

\begin{theorem} \label{BP_THRESHOLD_PROOF}
Assume that  is the smallest min-cut for DAG  with a cut capacity of . If packets are routed using the backpressure routing algorithm, then there exist finite constants  and  such that the following happens:
\begin{enumerate}
\item For some ,  for all , and
\item For all ,  for .
\end{enumerate}
\end{theorem}

\begin{proof}
We will prove the two claims separately. To prove the first claim we will use the fact that the network is overloaded and bottlenecked at the cut . We will prove the second claim using the fact that the number of packets that arrive into  in each time-slot is upper-bounded by , and any cut in the network has a capacity larger than or equal to . The detailed proofs for both claims are given in the Appendix \ref{app:bpThresholdProof}.
\end{proof}


 Each node  has a threshold-based smallest min-cut detection mechanism.
When we start using a particular DAG , in each time-slot, we check whether the queue crosses a prespecified threshold . Any queue that crosses the threshold gets marked as overloaded. After using the DAG  for  timeslots, all the nodes that have their queue marked overloaded form the set . When the time  and threshold  are large enough, the cut  is the smallest min-cut as proven in Theorem \ref{BP_THRESHOLD_PROOF}. After determining the smallest min-cut, an individual node can perform a link reversal by comparing its queue's overload status with its neighbor's. All the links that go from a non-overloaded node to an overloaded node are reversed to obtain  . The complete LFBP algorithm is given in Algorithm \ref{alg: lfbp}.

\begin{algorithm}[h] 
\caption{LFBP (Executed by node )}
\label{alg: lfbp}
\begin{algorithmic}[1]
\State Input: sequences , unique ID 
\State Generate initial DAG  by directing each link  to  if , to  if .
\State Mark the queue  as not overloaded
\State Initialize , 
\While {true}
	\State Use BP to send/recive packets on all links of node 
	\If {} \State {Mark  as overloaded.} \EndIf
	\State 
\State	
	\State 
	\If {} 
		\State Reverse all links  such that  is not overloaded and  is overloaded.
		\State 
		\State Mark  as not overloaded
	\EndIf
	
\EndWhile
\end{algorithmic}
\end{algorithm}

\begin{corollary}
Suppose the traffic demand is feasible in , i.e., . Then, the LFBP algorithm (Algorithm 3) will find a DAG, whose maximum flow supports , in a finite number of iterations.
\end{corollary}
\begin{proof}
Theorem 3 shows that LFBP identifies the smallest min-cut  for the DAG . Lemma 6 shows that  is the set of overloaded nodes, and  is the set of non-overloaded nodes in a flow allocation that induces the lexicographically minimal overload vector. LFBP reverses the links going from  to , which is also the reversals performed by the link reversal algorithm (Algorithm 1). Hence, by Theorem 1, LFBP obtains the DAG that supports .
\end{proof}

Good choices for the thresholds  and  are topology dependent. When the value of  is too small, nodes that are not overloaded might cross the threshold producing a false positive. If the value of  is large but  is small, the overloaded nodes might not have enough time to develop the backlog to cross  which produces false negatives. Hence, a good strategy is to choose a large  so that the non-overloaded nodes don't (or rarely) cross this threshold, then chose a large  such that the overloaded nodes have enough time to build the backlog to cross . Optimizing these thresholds requires further research. Note that our algorithm performance degrades graciously with false positives/negatives. Even when it detects the smallest min-cut incorrectly, the actions of the algorithm preserve the acyclic structure. Thus, in the subsequent iterations the algorithm can improve the DAG again. 




\subsection{Algorithm modification for topology changes}
In this section we consider networks with time-varying topologies, where several links of graph  may appear or disappear over time. Although the DAG that supports  depends on the topology of , our proposed policy LFBP can adapt to the topology changes and efficiently track the optimal solution.Additionally, the loop free structure of a DAG is preserved under link removals. Thus, if some of the links in the network disappear, we may continue using LFBP on the new network. 

To handle the appearance of new links in the network smoothly, we will slightly extend LFBP to guarantee the  loop free structure.
 For a DAG , every node  stores a unique state  representing its position in the topological ordering of the DAG . The states are maintained such that they are unique and all the links go from a node with the lower state to a node with the higher state. When a new link  appears we can set its direction to go from  to  if  and from  to  otherwise. Since this assignment of direction to the new link is in alignment with the existing links in the DAG, the loop-free property is preserved.

The state for each node  can be initialized using the unique node ID during the initial DAG creation, i.e. . Then whenever a reversal is performed the state of node  can be updated as follows: 

Here,  is some constant chosen such that . Note that this assignment of state is consistent with the way the link directions are assigned by the link reversal algorithm. The states for the non-overloaded nodes are unchanged, so the links between these nodes are unaffected. Also, the states for all the overloaded nodes are decreased by the same amount , so the direction of the links between the overloaded nodes is also preserved. Furthermore, the quantity  is less than the lowest possible state before the th iteration, so the overloaded nodes have a lower state than the non-overloaded nodes. Hence, the links between the overloaded and non-overloaded nodes go from the overloaded nodes to the non-overloaded nodes. 

In this scheme, the states  decrease unboundedly as more reversals are preformed. In order to prevent this, after a certain number of reversals, we can rescale the states by dividing them by a large positive number. This decreases the value of the state while maintaining the topological ordering of the DAG. The number of reversals  can be reset to 0, and a new  can be chosen such that it is greater than the largest difference between the rescaled states.



\section{Complexity analysis} \label{sec:complexity}
To understand the number of iteration the link-reversal algorithm takes to obtain the optimal DAG, we analyze the time complexity of the algorithm. 
\begin{theorem}\label{thm:complexity}
Let  be a vector of  the capacities of all the links in , and let  be the set of indices .  Define  to be the smallest positive difference between the capacity of any two cuts. Specifically,  is the solution  of the following optimization problem

The number of iterations taken by the link reversal algorithm before it stops is upper bounded by  , where  is the max-flow of the undirected network.
\end{theorem}
\begin{proof}
After each iteration of the link-reversal algorithm, either the max-flow of the DAG  increases, or the max-flow stays the same and the number of nodes in the source side of the smallest min-cut increases (see Lemma \ref{BIGGER CUT} in the Appendix). We can bound the number of consecutive iterations such that there is no improvement in the max-flow. In particular, every such iteration will add at least one node to the source set. So, it is impossible to have more than  such iteration. Hence, every  iterations we are guaranteed to have at least one increase in the max-flow.

Max-flow is equal to the min-cut capacity, and min-cut capacity is defined as the sum of link capacities. Say, the max-flow of DAG  is greater than that of . Let  be the set of indices (in the capacity vector ) of the links  in the min-cut of  , and  be the set of indices of the links in the min-cut of . This choice of A and B forms a feasible solution to the optimization problem given in the theorem statement. Since the optimal solution  lower bounds all the feasible solutions in the minimization problem, the increase in the max-flow must be greater than or equal to . 

Every  iteration the max-flow increases at least by . Hence, the DAG supporting the max-flow  is formed within  iterations.
\end{proof}

\begin{corollary} \label{cor:integer}
In a network where all the link capacities are rational with the least common denominator , the number of iterations is upper bounded by .
\end{corollary}
\begin{proof}
Since the capacities are rational we can write the capacity of the  link as , where  is a natural number. From the definition of  in Theorem \ref{thm:complexity}, we get  to be the value of the following optimization problem:

All the  are integers, so to satisfy the constraint we must have the difference . Hence . Using this value of  in Theorem \ref{thm:complexity}, we can see that the number of iterations is upper bounded by .
\end{proof}

\begin{corollary}
In a network with unit capacity links, the number of iterations the link-reversal algorithm takes to obtain the optimal DAG is upper bounded by .
\end{corollary}
\begin{proof}
The max-flow . So, by Corollary \ref{cor:integer}, the number of iterations is upper bounded by .
\end{proof}

We conjecture that these upper bounds are not tight, and finding a tighter bound will be pursued in the future research. We simulated the link reversal algorithm in 50,000 different Erdos-Renyi networks () of sizes 10 to 50 with randomly assigned link capacities. The link reversal algorithm started with a random initial DAG. We found that it took less than 2 iterations on average to find the optimal DAG.

A worst case lower bound for the number of iteration is . This lower bound can be achieved in a line network where the initial DAG has all of its links in the wrong direction.







\section{Simulation Results} \label{simulations}
We compare the delay performance of the LFBP algorithm and the BP algorithm via simulations. 
We will see that the network with the LFBP routing has a smaller backlog on average under the same load. This shows that the LFBP algorithm has a better delay performance. 
We consider two types of networks for the simulations: a simple network with fixed topology, and a network with grid topology where the links appear and disappear randomly. 


\subsection{Fixed topology}
We consider a network with the topology shown in Figure \ref{fig: network_topology}. The edge labels  represent the link capacities. The undirected network has the maximum throughput of 15 packets per time slot. Figure \ref{fig: dag0} shows the initial DAG . Instead of running the initial DAG algorithm of Section~\ref{sec: initial dag}, here we choose a zero throughput DAG to test the worst-case performance of LFBP. The arrivals to the network are Poisson with rate  , where we vary . For the LFBP algorithm, we set the overload detection threshold to  for all . To choose this parameter, we observed that the backlog buildup in normal operation rarely raises above 60. We also choose the detection period  and  for all . This provides enough time for buildup, which improve the accuracy of the overload detection mechanism.

We simulate both algorithms for one million slots, using the same arrival process sample path. Figures \ref{fig: dag1} - \ref{fig: dag3} show the various DAGs that are formed by the LFBP algorithm at iterations . We can see that the nodes in the smallest min-cut get overloaded and the link reversals gradually improve the DAG until the throughput optimal DAG is reached.


\begin{figure}[h!]
\centering
\subfigure[Network topology.]{
\begin{overpic}[scale=.42]{figures/example_network.pdf}
	\put (4.5,36) {\small }
	\put (32,64) {\small 2}
	\put (62,64) {\small 3}
	\put (91,35) {\small }
	\put (32,5) {\small 1}
	\put (62,5) {\small 4}

	\put (20,44) {\small 15}
	\put (20,26) {\small 5}

	\put (72,44) {\small 15}
	\put (72,26) {\small 5}

	\put (37,35) {\small 5}
	\put (55,35) {\small 5}

	\put (45,59) {\small 5}
	\put (45,10) {\small 10}
\end{overpic}
\label{fig: network_topology}
}
\subfigure[The initial DAG chosen so that LFBP requires several iteration to reach the optimal.]{
\begin{overpic}[scale=.42]{figures/example_dag0.pdf}
	\put (4.5,36) {\small }
	\put (32,64) {\small 2}
	\put (62,64) {\small 3}
	\put (91,35) {\small }
	\put (32,5) {\small 1}
	\put (62,5) {\small 4}
\end{overpic}
\label{fig: dag0}
}
\subfigure[After 1st reversal.]{
\begin{overpic}[scale=.42]{figures/example_dag1.pdf}
	\put (4.5,36) {\small }
	\put (32,64) {\small 2}
	\put (62,64) {\small 3}
	\put (91,35) {\small }
	\put (32,5) {\small 1}
	\put (62,5) {\small 4}
\end{overpic}
\label{fig: dag1}
}
\subfigure[After 2nd reversal.]{
\begin{overpic}[scale=.42]{figures/example_dag2.pdf}
	\put (4.5,36) {\small }
	\put (32,64) {\small 2}
	\put (62,64) {\small 3}
	\put (91,35) {\small }
	\put (32,5) {\small 1}
	\put (62,5) {\small 4}
\end{overpic}
\label{fig: dag2}
}
\subfigure[The optimal DAG.]{
\begin{overpic}[scale=.42]{figures/example_dag3.pdf}
	\put (4.5,36) {\small }
	\put (32,64) {\small 2}
	\put (62,64) {\small 3}
	\put (91,35) {\small }
	\put (32,5) {\small 1}
	\put (62,5) {\small 4}
\end{overpic}
\label{fig: dag3}
}
\caption{Figure (a) depicts the original network. Figures (b)-(e) are the various stages of the DAG. The red nodes represent the overloaded nodes, and the dashed line shows the boundary of the overloaded and the non-overloaded nodes.}
\end{figure}

Figure \ref{fig: fixed_topology_delay} compares the total average backlog in the network for  BP  and  LFBP, which is indicative of the average delay.
A significant delay improvement is achieved by LFBP, for example at load  the average delay is reduced by 
We observe that the gain in the delay performance is more pronounced when the load is low.
 In low load situations, the network doesn't have enough ``pressure'' to drive the packets to the destination and so under BP  the packets go in loops.
 
\begin{figure}[h!]
\centering
\includegraphics[scale=.8]{figures/fixed_topology_delay.pdf}
\caption{Average backlog in the network (Fig. \ref{fig: network_topology})  with fixed topology for the Loop Free Backpressure (LFBP) and the Backpressure (BP) algorithms.} 
\label{fig: fixed_topology_delay}
\end{figure}

\subsection{Randomly changing topology}
To understand the delay performance of the LFBP algorithm on networks with randomly changing topology, we consider a network where 16 nodes are arranged in a  grid. All the links are taken to be of capacity six. For the LFBP algorithm, we choose a random initial DAG with zero throughput shown in Figure \ref{fig: grid_initial_dag}. The source is on the upper left corner (node 1) and the destination is on the bottom right (node 16).

\begin{figure}[h!]
\centering
\begin{overpic}[scale=.7]{figures/dag0_grid.pdf}
\put(4,83){\small }
\put(33,83){\small }
\put(62,83){\small }
\put(91,83){\small 13}

\put(4,57){\small }
\put(33,57){\small }
\put(61,57){\small }
\put(91,57){\small 14}

\put(4,30){\small }
\put(32,30){\small }
\put(61,30){\small }
\put(91,30){\small 15}

\put(4,3){\small }
\put(33,3){\small }
\put(61,3){\small }
\put(91,3){\small 16}
\end{overpic}
\caption{Initial DAG for the LFBP algorithm chosen so that the LFBP needs several iterations to reach the optimal DAG. All the links have capacity six.}
\label{fig: grid_initial_dag}
\end{figure}

In the beginning of the simulations  all 24 network links are activated. At each time slot an active link fails with a probability  and an inactive link is activated with a probability . The maximum throughput of the undirected network without any link failures is 12. Clearly on average, each link is ``on'' a fraction  of the time, and thus the average maximum throughput of the undirected network with these link failure rates is . 
The arrivals to the networks are Poisson with rate , where . For the LFBP algorithm, the detection threshold is set to  and the detection period is   for all . These parameters were chosen so that there are several reversals before a topology change occurs in the undirected network. The simulation was carried out for a million slots. 

Figure \ref{fig: changing_topology_delay} compares the average backlog of LFBP and BP. In the low load scenarios  LFBP reduces delay significantly (by 85\% for load = 0.1) even though the topology changes challenge the convergence of the link-reversal algorithm. As the load increases, both the algorithms begin to obtain a similar delay performance.

\begin{figure}[h]
\centering
\includegraphics[scale=.75]{figures/changing_topology_delay.pdf}
\caption{Average backlog in the network with random link failures (Fig. \ref{fig: grid_initial_dag}) for the Loop Free Backpressure algorithm and the Backpressure algorithm.}
\label{fig: changing_topology_delay}
\end{figure}


\section{Multicommodity simulation}
We extend of the link reversal algorithm to the networks with multiple commodities. The multi-commodity algorithm is identical to the single commodity algorithm, with the exception that we now use the multicommodity backpressure of \cite{tassiulas}. Each node  maintains a queue  for each commodity . Each commodity is assigned its own initial DAG. A pseudocode for the multicommodity LFBP that we used is given in Algorithm \ref{alg:mlfbp}. An important direction for future research is to determine whether the claims proven for a single commodity in the previous sections extend to the multicommodity case.

\begin{algorithm}[h] 
\caption{Multicommodity LFBP (Executed by )}
\label{alg:mlfbp}
\begin{algorithmic}[1]
\State Input: sequences , unique ID 
\State For each commodity , generate initial DAG  by directing  to  if , to  if .
\State Mark all queues  as not overloaded
\State Initialize , 
\While {true}
	\State Use Multicommodity BP to send/recive packets on all links of node 
	\ForAll {}	
		\If {} \State {Mark this  as overloaded.} \EndIf
	\EndFor
	\State 
\State	
	\State 
	\If {} 
		\ForAll {}
			\State Reverse links  in  if  is not overloaded and  is overloaded.
		\EndFor
		\State 
		\State Mark all queues as not overloaded
	\EndIf
	
\EndWhile
\end{algorithmic}
\end{algorithm}

For the simulation, we consider a network arranged in a  grid as shown in Figure \ref{fig: grid_initial_dag}. Each link has a capacity of 6 packets per time-slot. There are three commodities in the network defined by the source destination pairs (1,16), (4,13) and (5,8). For the LFBP algorithm, each commodity starts with the same initial DAG given in Figure \ref{fig: grid_initial_dag}. 

We use the arrival rate vector , which is a max-flow vector for this network computed by solving a linear program. We scale this vector by various load factors  ranging from 0.1 to 0.9. The arrivals for each commodity  is Poisson with rate . In the beginning of the LFBP simulation,  dummy packets are added to the source of each commodity. This is helpful in low load cases because it forces the algorithm to find a DAG with high throughput, and avoids stopping at a DAG that only supports the given (low) load.  was chosen to be  and  for all . The simulation was executed for 500,000 time-steps.

Figure \ref{3commodity_plot} shows the average backlog in the network for different loads under backpressure and multicommodity LFBP. We can see that the LFBP algorithm has a significantly improved delay performance compared to backpressure.

\begin{figure}[h!]
\centering
\includegraphics[scale=.7]{figures/grid3commodity_result}
\caption{Average backlog in a multicommodity network with fixed topology for LFBP and BP algorithms.}
\label{3commodity_plot}
\end{figure}


\section{Conclusion}
Backpressure routing and link reversal algorithms have been separately proposed for mobile wireless networks applications. In this paper we show that these two distributed schemes can be successfully combined to yield good throughput and delay performance.We develop the Loop-Free Backpressure Algorithm which jointly routes packets in a constrained DAG and reverses the links of the DAG to improve its throughput. We show that the algorithm ultimately results in  a DAG that yields the maximum throughput. Additionally, by restricting the routing to this DAG we eliminate loops, thus reducing the average delay. 
Future investigations involve optimization of the overload detection parameters  and studying the performance of the scheme on the networks with  multiple commodities.

\begin{thebibliography}{99}
\bibitem{tassiulas}
	L. Tassiulas and A. Ephremides, ``Stability properties of constrained queueing systems and scheduling for maximum throughput in multihop radio networks,'' \emph{IEEE Transactions~on Automatic Control}, vol. 37, no. 12, pp. 1936-1949, December 1992.
	
\bibitem{srikant}
L.~X.~Bui, R.~Srikant and A.~Stolyar, ``A novel architecture for reduction of delay and queueing structure complexity in the back-pressure algorithm,'' \emph{IEEE/ACM Transactions on Networking}, vol.~19, no.~6, pp.~1597-1609, December~2011.

\bibitem{neely_enhanced} M. J. Neely, E. Modiano and C. E. Rohrs, ``Dynamic power allocation and routing for time varying wireless networks,'' \emph{IEEE Journal on Selected Areas in Communications}, Special Issue on Wireless Ad-hoc Networks, vol. 23, no. 1, pp. 89-103, January 2005.

\bibitem{gafni_bertsekas} 
	E. Gafni and D. Bertsekas, ``Distributed algorithms for generating loop-free routes in networks with frequently changing topology,'' \emph{IEEE Transactions on Communications}, vol. 29, no. 1, pp. 11-18, January 1981.
\bibitem{tora}
	V.D. Park and M.S. Corson, ``A highly adaptive distributed routing algorithm for mobile wireless networks,'' INFOCOM, 1997.
\bibitem{georgiadis}
	L. Georgiadis and L. Tassiulas, ``Optimal overload response in sensor networks.'' \emph{IEEE Transactions on Information Theory}, vol.52, no. 6, pp. 2684-2696, June 2006.
\bibitem{atilla}
	H. Xiong, R. Li, A. Eryilmaz and E. Ekici, ``Delay-aware cross-layer design for network utility maximization in multi-hop networks.'' \emph{IEEE Journal on Selected Areas in Communications}, vol. 29, no. 5, pp. 951-959, May 2011.
\bibitem{ying}
	L. Ying, S. Shakkottai, A. Reddy and S. Liu, ``On combining shortest-path and backpressure routing over multihop wireless networks,'' \emph{IEEE/ACM Transactions on Networking}, vol. 19, no. 3, pp. 841-854, June 2011.
	
\bibitem{huang}
P.-K. Huang, X. Lin, and C.-C. Wang, ``A low-complexity congestion control and scheduling algorithm for multihop wireless networks with order-optimal per-flow delay,'' \emph{IEEE/ACM Trans.~on Networking}, vol.~21, no.~2, pp. 2588-2596, April~2013.

\bibitem{Nee10book}
M. J. Neely, ``Stochastic network optimization with application to communication and queueing systems,'' Morgan \& Claypool, 2010.

\bibitem{FordFulkerson}
L.~R.~Ford and D.~R.~Fulkerson, ``Maximal flow through a network,'' \emph{Canadian Journal of Mathematics}, 8: 399, 1956.

\bibitem{georgatsos} L.~Georgiadis, P.~Georgatsos, K.~Floros, and S.~Sartzetakis, ``Lexicographically optimal balanced networks,'' \emph{IEEE/ACM Transactions on Networking}, vol.
10, no. 6, pp. 818-829, December 2002.

\bibitem{longbo} L. Huang and M. J. Neely, ``Delay reduction via Lagrange multipliers in stochastic network optimization,'' \emph{IEEE Transactions on Automatic Control}, vol. 56, no. 4, pp. 842-857, April 2011.

\bibitem{neely_georgiadis} L.~Georgiadis, M.~J.~Neely and L.~Tassiulas, ``Resource allocation and cross-layer control in wireless networks,'' 
Foundations and trends in networking, Now Publishers Inc, 2006.



\end{thebibliography}



\appendix

\section{Lemma \ref{MIN-CUT}}\label{app:A}
\begin{lemma}\label{MIN-CUT}
Consider a DAG  with source node , destination node , and arrival rate . Let  be the set of overloaded nodes under the flow allocation  that yields the lexicographically minimum overload vector. If , then  is a min-cut of the DAG .
\end{lemma}
\begin{proof}[Proof of Lemma~\ref{MIN-CUT}]
First we show that  is a cut, i.e., the source node   and the destination node . The destination node  has zero queue overload rate  because it does not buffer packets; hence . We show  by contradiction. Assume .  The property~\eqref{property1} shows that there is no flow going from  to , i.e., 

The flow conservation equation applied to the collection  of nodes yields

which contradicts the assumption that the network is overloaded (i.e., ). Note that in the above equation  does not appear because of the premise .

By the max-flow min-cut theorem, it remains to show that the capacity of the cut  is equal to the maximum flow  of the DAG . Under the flow allocation  that induces the lexicographically minimal overload vector, the throughput of the destination node  is the maximum flow  (see Lemma~\ref{lem:201}). It follows that

where~\eqref{eq:21011} uses \eqref{eq:201} and  for all nodes ,~\eqref{eq:212} follows the flow conservation law over the node set , and~\eqref{eq:213} uses the property~\eqref{property2} in Lemma~\ref{lem:201}.
\end{proof}

\section{Proof of Lemma \ref{SMALLEST MIN-CUT}}\label{app:B}
\begin{proof}[of Lemma~\ref{SMALLEST MIN-CUT}]
Lemma \ref{MIN-CUT} shows that  is a min cut of the DAG . It suffices to prove that if there exists another min-cut , i.e.,  and , then . The proof is by contradiction. Let us assume that there exists another min-cut  such that . We have the source node  and the destination node . Consider the partition  of the network nodes such that , ,  and  (see Fig.~\ref{partitions}). Since  and , we have . Also, we have  and .
\begin{figure}[ht]
\centering
\begin{overpic}[scale=.8]{figures/partitions.pdf}
	\put (8,55) {\small }
	\put (80,55) {\small }
	\put (20,35) {\small }
	\put (45,35) {\small }
	\put (70,35) {\small }
	\put (85,7) {\small }
\end{overpic}
\caption{A partition of the node set  where  and .}
\label{partitions}
\end{figure}
Let  be a flow allocation that yields the lexicographically minimum overload vector in . Properties~\eqref{property1} and~\eqref{property2} show that 

The capacity of the cut  in the DAG , defined in~\eqref{eq:202}, satisfies

where . Under the flow allocation , we have

Applying the flow conservation equation to the collection of nodes in  yields

In~\eqref{eq:203}, the first term is the sum of incoming flows into the set ; notice that there is no incoming flow from  to  because of the flow property~\eqref{eq:205}. The second term is the sum of queue overload rates in . The last term is a partial sum of outgoing flows leaving the set , not counting flows from  to ; hence the inequality~\eqref{eq:203}. From the flow property~\eqref{eq:204}, the outgoing flows from the set  to  satisfy

Combining~\eqref{eq:206}-\eqref{eq:208} yields

where the second inequality follows that all nodes in  are overloaded and  for all . Inequality~\eqref{eq:209} shows that there exists a cut  that has a smaller capacity, contradicting that  is a min-cut in the DAG . Finally, we note that the 
partition
  is unique because the lexicographically minimal overload vector is unique by Lemma~\ref{lem:201}.
\end{proof}



\section{Proof of Theorem \ref{BP_THRESHOLD_PROOF}}\label{app:bpThresholdProof}
\begin{proof}[of the first claim]
First we will show that the queue at the source  crosses any arbitrary threshold . We know that for some node ,  as  because the external arrival rate to the source  is larger than the rate of departure from set , i.e. . The backpressure algorithm sends packets on a link (i,j) only if . Hence, at any time-slot if a node  has a large backlog, then one of its parents  must also have a large backlog.  can be slightly smaller than  because  might also receive packets from other nodes at the same time-slot. Specifically, . Performing the induction on the parent of  we can see that the source node must have a high backlog when any node in  develops a high backlog. Note that the network is a DAG and the node  received packets form the source to develop its backlog, so the induction much reach the source node. Hence, when ,  for some .



Now we will show that every node in  crosses the threshold . Let  be the set of nodes such that  for some time . We showed that . We will show that when , there exists some set , such that  (i) , and (ii) for every node ,  for some . Here,  and  are large thresholds.

Assume . Let , i.e all nodes in  haven't crossed the threshold  until time . 
Let  be the total capacity of the links going from  to , and  be the total capacity of the links going from  to . We have  because  is the smallest min-cut (see Figure \ref{fig:OverloadedSubset}). When the backlogs of the nodes of  are much larger than the nodes of , the nodes in  receive packets from  at the rate of  packets per time-slot, and no packets are sent in the reversed direction. The rate of packets leaving the nodes in  is upper bounded by  which is smaller than the incoming rate. Hence, at least one node  must collect a large backlog, say larger than . So, each node in the set  have a backlog larger than  at some finite time .


\begin{figure}[ht]
\centering
\begin{overpic}[scale=.8]{figures/smc_partition.pdf}
	\put (25,55) {\small }
	\put (35,30) {\small }
	\put (60,30) {\small }
	\put (90,65) {\small }
\end{overpic}
\caption {Let  be the smallest min-cut. We showed that . Say,  then the cut  has the capacity of . This contradicts the assumption that  is the smallest min-cut. So, . }
\label{fig:OverloadedSubset}
\end{figure}

Now using induction we can see that for  where ,  and all the nodes in  cross a threshold  by time .
\end{proof}


\begin{proof}[of the second claim]
We will use the following fact to prove this claim: for any subset of nodes , if the number of packets entering  is lower than or equal to the number of packets leaving  on every time-slot, then the total backlog in  doesn't grow. So, the backlog in each node of S is bounded.

Assume a node  develops a backlog . Here  is a chosen such that 
Consider a subset  of  such that for every node  and , . The sets  and  must be nonempty because  is large and  is zero, that is  and . Note that backpressure doesn't send any data from  to . 

\begin{figure}[ht]
\centering
\begin{overpic}[scale=.8]{figures/smc_partitionAc.pdf}
	\put (46,35) {\small }
	\put (5,30) {\small }
	\put (90,30) {\small }
\end{overpic}
\caption {Let  be the smallest min-cut. We showed that . Say,   then the cut  has the capacity of . This contradicts the assumption that  is the smallest min-cut. So, . }
\label{fig:NonOverloadedSet}
\end{figure}

Let  be the capacity of the links going from  to , and let  be the capacity of the links going from  to . So, the number of packets entering  at timeslot  is upper bounded by . The number of packets leaving  is equal to . Since  is the smallest min-cut,  (see Figure \ref{fig:NonOverloadedSet}). Hence, the number of packets entering  is less than or equal to the number of packets leaving it at time . 

Therefore as soon as one of the nodes crosses threshold , the sum backlog becomes bounded. We can choose a threshold  such that this threshold is never crossed by any nodes in .

\end{proof}

\section{Lemma \ref{BIGGER CUT}}
\begin{lemma}\label{BIGGER CUT}
Consider the case when . The link reversal algorithm is applied on DAG  to obtain . Let  and  be the smallest min-cuts of  and  respectively. Then, either , or  and 
\end{lemma}
\begin{proof}
\begin{figure}[ht]
\centering
\begin{overpic}[scale=.8]{figures/partitions.pdf}
	\put (8,55) {\small }
	\put (82,55) {\small }
	\put (1,39){\small }
	\put (1,25){\small }
	\put (27,39){\small }
	\put (27,25){\small }
	\put (63,39){\small }
	\put (63,25){\small }
	\put (88,39){\small }
	\put (88,25){\small }
	\put (45,65){\small }
	\put (45,5){\small }
	\put (60,18){\small }
	\put (25,53){\small }
\end{overpic}
\caption{Here  represents the sum of the capacities of the links going from one partition to the next in the DAG , and  represents the sum of the link capacities in the DAG . For example,  and  represent the links that go from  to  in DAGs  and  respectively.}
\label{partitions2}
\end{figure}
Consider the partitioning of the nodes as shown in Figure \ref{partitions2}. For ,  represents the sum of the capacities of the links going from one partition to the next in the DAG , and  represents the sum of the link capacities in the DAG . The capacities of the smallest min-cut, before and after the reversal are given by   respectively. Note that only the links that are coming into  are different in  and . So 

Because of the reversal there are no links coming into  in the DAG :

After the reversal, the incoming links to  become outgoing from ,

(Corresponding equations for  and  are omitted because they are not necessary for the proof). Since  is a min-cut, 

This is true because otherwise the cut   in the DAG  has a smaller capacity then the min cut . Specifically, let us assume . Then, we get the contradiction: 


First we will show that if , then the capacity of the DAG must have increased. The proof is by contradiction. 

Let us assume that the throughput didn't increase. So, 

(\ref{eq5}) is follows from (\ref{eq1}) and (\ref{eq2}), and (\ref{eq6}) follows from (\ref{eq4}). Since  by assumption, . This leads to a contradiction, because in DAG  the cut  is smaller than the smallest min-cut . Hence, .

Next, we will consider the case . Using (\ref{eq4}),
 In this situation, we again have two cases.
First, if  we know that  and . Hence, . 

Second, if , then  and  

Using (\ref{eq1}) and (\ref{eq8}) .
\end{proof}


\end{document}