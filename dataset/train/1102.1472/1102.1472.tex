\pdfoutput=1
\documentclass[11pt]{article}

\oddsidemargin 0.0in
\textwidth 6.5in
\topmargin -0.5in
\textheight 9.0in
\renewcommand{\baselinestretch}{0.93}
\usepackage{graphicx}

\usepackage{epsfig,
amssymb,amsmath,amsthm,float
}
\newtheorem{theorem}{Theorem}
\newtheorem{prop}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{corollary}[theorem]{Corollary}

\def\reals{\mathbb{R}}
\def\T{\mathcal{T}}
\def\E{\mathbb{E}}
\def\R{\reals}
\def\sph{\mathbb{S}}
\def\suchthat{\;:\;}
\def\psd{\succcurlyeq}
\def\eps{\epsilon}
\def\diam{\mathrm{D_{K}}}

\newcommand{\ball}[2]{#2\mathbb{B}_{#1}}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\norm}[1]{\left\|#1\right\|}
\newcommand{\sqnorm}[1]{\left\|#1\right\|^{2}}
\newcommand{\size}[1]{\left|#1\right|}
\newcommand{\prob}[1]{{\sf Pr}\left(#1\right)}
\newcommand{\eigmin}[1]{\lambda_{\min}(#1)}
\newcommand{\eigmax}[1]{\lambda_{\max}(#1)}
\newcommand{\vol}[1]{\operatorname{vol}\left(#1\right)}
\newcommand{\var}[1]{{\sf Var}\left(#1\right)}
\newcommand{\cov}[1]{{\sf Cov}\left(#1\right)}

\def\final{1}  \def\iflong{\iffalse}
\ifnum\final=1  \newcommand{\knote}[1]{[{\tiny karthik: \bf #1}]\marginpar{*}}
\newcommand{\snote}[1]{[{\tiny Santosh: \bf #1}]\marginpar{*}}
\newcommand{\sidecomment}[1]{}
\else \newcommand{\knote}[1]{}
\newcommand{\snote}[1]{}
\newcommand{\sidecomment}[1]{}
\fi  


\begin{document}




\title{\Large Algorithms for Implicit Hitting Set Problems}
\author{Karthekeyan Chandrasekaran \thanks{Georgia Institute of Technology. Supported in part by NSF awards AF-0915903 and AF-0910584. Email: {\tt karthe@gatech.edu,vempala@cc.gatech.edu}. }\\
\and Richard Karp \thanks{University of California, Berkeley. Email: {\tt karp@icsi.berkeley.edu}}\\
\and Erick Moreno-Centeno \thanks{Texas A\&M University. Email: {\tt e.moreno@tamu.edu}}\\
\and Santosh Vempala \footnotemark[1]}
\date{}

\maketitle

\begin{abstract}
A hitting set for a collection of sets is a set that has a non-empty intersection with each set in the collection; the hitting set problem is to find a hitting set of minimum cardinality. Motivated by instances of the hitting set problem where the number of sets to be hit is large, we introduce the notion of \emph{implicit hitting set problems}. In an implicit hitting set problem the collection of sets to be hit is typically too large to list explicitly; instead, an oracle
is provided which, given a set , either determines that  is a hitting set or returns a set that  does not hit. We show a number of examples of classic implicit hitting set problems, and give a generic algorithm for solving such problems optimally. The main contribution of this paper is to show that this framework is valuable in developing approximation algorithms. We illustrate this methodology by presenting a simple on-line algorithm for the minimum feedback vertex set problem on random graphs. In particular our algorithm gives a feedback vertex set of size  with probability at least  for the random graph  (the smallest feedback vertex set is of size ). We also consider a planted model for the feedback vertex set in directed random graphs. Here we show that a hitting set for a polynomial-sized subset of cycles is a hitting set for the planted random graph and this allows us to exactly recover the planted feedback vertex set.
\end{abstract}

\section{Introduction}

In the classic Hitting Set problem, we are given a universe  of elements and a collection  of subsets  of ; the objective is to find a subset  of minimum cardinality so that every subset  in  contains at least one element from . The problem is NP-hard \cite{karp-np-complete}, approximable to within  using a greedy algorithm, and has been studied for many interesting special cases.

There are instances of the hitting set problem where the number of subsets  to hit is exponential in the size of the universe. Consequently, obtaining a hitting set with approximation factor  using the greedy algorithm which examines all subsets is unreasonable for practical applications. Our motivation is the possibility of algorithms that run in time polynomial in the size of the universe. In this paper, we introduce a framework that could be useful in developing efficient approximation algorithms for instances of the hitting set problem with exponentially many subsets to hit.

We observe that in many combinatorial problems,  has a succinct
representation that allows efficient verification of whether a candidate set
hits every subset in . Formally, in an implicit hitting set problem, the
input is a universe  and a polynomial-time {\it oracle} that, given a set
, either determines that  is a hitting set or returns a subset that is
not hit by . Thus, the collection  of subsets to hit is not specified
explicitly. The objective is to find a small hitting set by making at most
polynomial() queries to the oracle. In Section 1.1, we show several
well-known problems that can be formulated as implicit hitting set problems.



We present a generic algorithm to obtain the optimal solution of implicit hitting set problems in Section 2. As this algorithm solves optimally the NP-hard (classic) hitting set problem as a subroutine, its worst-case running time is exponential as a function of . The main purpose of stating the generic algorithm is to develop an intuition towards using the oracle. It suggests a natural way to use the oracle: first (1) propose a candidate hitting set , then (2) use the oracle to check if the candidate set hits all the subsets, and if not obtain a subset  that has not been hit, and finally (3) refine  based on  and repeat until a hitting set is found. 

The generic algorithm for the implicit hitting set problem is in fact a generalization of online algorithms for hitting set problems. Here, the ground set is specified in advance as before and the subsets to be hit arrive online. On obtaining a subset, the algorithm has to decide which new element to include in the hitting set and commit to the element. Thus, the online algorithm is restricted in that the refinement procedure can only add elements.  Moreover, only those subsets that have not been hit by the candidate set are revealed online thereby saving the algorithm from having to examine all subsets in . This is similar to the mistake bound learning model \cite{littlestone88}.



We apply the implicit hitting set framework and specialize the generic
algorithm to the \emph{Minimum Feedback Vertex Set} (FVS) problem: given a
graph , find a subset  of smallest cardinality so that
every cycle in the graph contains at least one vertex from . Although the
number of cycles could be exponential in the size of the graph, one can
efficiently check whether a proposed set  hits all cycles ({\it i.e.,} is a
feedback vertex set) or find a cycle that is not hit by  using a
breadth-first search procedure after removing the subset of vertices  from
the graph. The existence of a polynomial time oracle shows that it is an
instance of the implicit hitting set problem.

The main focus of this paper is to develop algorithms that find nearly optimal hitting sets in random graphs or graphs with planted feedback vertex sets, by examining only a polynomial number of cycles. For this to be possible, we need the oracle to pick cycles that have not yet been hit in a natural yet helpful manner. If the oracle is adversarial, this could force the algorithm to examine almost all cycles. We consider two natural oracles: one that picks cycles in breath-first search (BFS) order and another that picks cycles according to their size.

We prove that if cycles in the random graph  are obtained in a breadth-first search ordering, there is an efficient algorithm that examines a polynomial collection  of cycles to build a nearly optimal feedback vertex set for the graph. The algorithm builds a solution iteratively by (1) proposing a candidate for a feedback vertex set in each iteration, (2) finding the next cycle that is not hit in a breadth-first ordering of all cycles, (3) augmenting the proposed set and repeating. A similar result for directed random graphs using the same algorithm follows by ignoring the orientation of the edges. Our algorithm is an online algorithm i.e., it commits to only adding and not deleting vertices from the candidate feedback vertex set.

It is evident from our results that the size of the feedback vertex set in both directed and undirected random graphs is close to , for sufficiently large . This motivates us to ask if a smaller planted feedback vertex set in random graphs can be recovered by using the implicit hitting set framework. This question is similar in flavor to the well-studied planted clique problem \cite{jerrumClique92,sudakov98,frieze08}, but posed in the framework of implicit hitting set problems. We consider a natural planted model for the feedback vertex set problem in directed graphs. In this model, a subset of  vertices, for some constant , is chosen to be the feedback vertex set. The subgraph induced on the complement is a random directed acyclic graph (DAG) and all the other arcs are chosen with probability  independently. The objective is to recover the planted feedback vertex set. We prove that the optimal hitting set for cycles of bounded size is the planted feedback vertex set. Consequently, ordering the cycles according to their sizes and finding an approximately optimal hitting set for the small cycles is sufficient to recover the planted feedback vertex set. This also leads to an online algorithm when cycles are revealed in increasing order of their size with ties broken arbitrarily.


We conclude this section with some well-known examples of implicit hitting set problems.

\subsection{Implicit Hitting Set Problems}


An {\it implicit hitting set problem} is one in which, for each instance, the
set of subsets is not listed explicitly but instead is specified implicitly by
an {\it oracle}: a polynomial-time algorithm which, given a set ,
either certifies that  is a hitting set or returns a subset that is not hit
by .

\noindent Each of the following is an implicit hitting set problem:
\begin{itemize}
\item {\bf Feedback Vertex Set in a Graph or Digraph}\\
Ground Set: Set of vertices of graph or digraph .\\
Subsets: Vertex sets of simple cycles in .


\item {\bf Feedback Edge Set in a Digraph}\\
Ground Set: Set of edges of digraph .\\
Subsets: Edge sets of simple cycles in .


\item {\bf Max Cut}\\
Ground Set: Set of edges of graph .\\
Subsets: Edge sets of simple odd cycles in .


\item {\bf k-Matroid Intersection}\\
Ground Set: Common ground set of  matroids.\\
Subsets: Subsets in the  matroids.

\item {\bf Maximum Feasible Set of Linear Inequalities}\\
Ground Set: A finite set of linear inequalities.\\
Subsets: Minimal infeasible subsets of the set of linear inequalities.


\item {\bf Maximum Feasible Set of Equations of the Form }\\
This example is motivated by the Unique Games Conjecture.

\item {\bf Synchronization in an Acyclic Digraph}\\
Ground Set: A collection  of pairs of vertices drawn from the vertex set of
an acyclic digraph .\\
Subsets: Minimal collection  of pairs from  with the property that, if
each pair in  is contracted to a single vertex, then the resulting digraph
contains a cycle.
\end{itemize}



\noindent {\bf Organization.} In Section 2, we present a generic algorithm for the optimal solution of implicit hitting set problems. Then, we focus on specializing this algorithm to obtain small feedback vertex sets in directed and undirected random graphs. We analyze the performance of this algorithm in Section 3. We then consider a planted model for the feedback vertex set problem in directed random graphs. In Section 4, we give an algorithm to recover the planted feedback vertex set by finding an approximate hitting set for a polynomial-sized subset of cycles. We prove a lower bound for the size of the feedback vertex set in random graphs in Section 5. We state our results more precisely in the next section.

\subsection{Results for Feedback Vertex Set Problems}
We consider the feedback vertex set problem for the random graph , a graph on  vertices in which each edge is chosen independently with probability . Our main result here is that a simple augmenting approach based on ordering cycles according to a breadth-first search (Algorithm Augment-BFS described in the next section) has a strong performance guarantee.

\begin{theorem}\label{theorem:undirected-MFVS}
For , such that , there exists a polynomial time algorithm that produces a feedback vertex set of size at most  with probability at least .
\end{theorem}
Throughout,  is with respect to . We complement our upper bound with a lower bound on the feedback vertex set for  obtained using simple union bound arguments.
\begin{theorem}\label{theorem:undirected-FVSlowerbound}
Let . If , then every subgraph induced by any subset of  vertices in  contains a cycle with high probability.
\end{theorem}

This gives an upper bound of  on the maximum induced acyclic subgraph of . So, the size of the minimum feedback vertex set for  is at least . A result of Fernandez de la Vega \cite{delavega96} shows that  has an induced tree of size at least , when . This gives the best possible existential result: there exists a feedback vertex set of size at most  with high probability in , when . We note that this result is not algorithmic; Fernandez de la Vega gives a greedy algorithm to obtain the largest induced tree of size  in \cite{delavega86}. This algorithm is based on growing the induced forest from the highest labeled vertex and does not fall in the implicit hitting set framework (when the graph is revealed as a set of cycles). In contrast, our main contribution to the FVS problem in random graphs is showing that a simple breadth-first ordering of the cycles is sufficient to find a nearly optimal feedback vertex set. We also note that our algorithm is an online algorithm with good performance guarantee when the cycles are revealed according to a breadth-first ordering. Improving on the size of the FVS returned by our algorithm appears to require making progress on the long-standing open problem of finding an independent set of size  in . Assuming an optimal algorithm for this problem leads to an asymptotically optimal guarantee matching Fernandez de la Vega's existential bound.

Next, we turn our attention to the directed random graph  on  vertices. The directed random graph  is obtained as follows: choose a set of undirected edges joining distinct elements of  independently with probability . For each chosen undirected edge , orient it in one of the two directions  in  with equal probability.

The undirected graph  obtained by ignoring the orientation of the edges in  is the random graph . Moreover, a feedback vertex set in  is also a feedback vertex set for . Therefore, by ignoring the orientation of the arcs, the Augment-BFS algorithm as applied to undirected graphs can be used to obtain a feedback vertex set of size at most  with probability at least . A theorem of Spencer and Subramanian \cite{spencer-subramanian} gives a nearly matching lower bound on the size of the feedback vertex set in .
\begin{theorem}\cite{spencer-subramanian}\label{theorem:directed-FVSlowerbound}
Consider the random graph , where , for some fixed constant . Let . Every subgraph induced by any subset of  vertices in  contains a cycle with high probability.
\end{theorem}

It is evident from the results above that the feedback vertex set in a random graph contains most of its vertices when . This motivates us to ask if a significantly smaller ``planted'' feedback vertex set in a random graph can be recovered with the implicit hitting set framework. In order to address this question, we present the following planted model.

The planted directed random graph  on  vertices for  is obtained as follows: Choose  vertices arbitrarily to be the planted subset . Each pair  where , is adjacent independently with probability  and the corresponding edge is oriented in one of the two directions  in  with equal probability. The arcs between vertices in  are obtained in the following manner to ensure that the subgraph induced on  is a DAG: Pick an arbitrary permutation of the vertices in . With the vertices ordered according to this permutation, each forward arc is present with probability  independently; no backward arcs occur according to this ordering.

\begin{figure}[H]
\label{fig:planted-model}
\begin{center}
\psfig{file=planted-model-2.jpg,width=1.6in,height=1.6in}
\end{center}
\caption{Planted Model}
\end{figure}

We prove that for graphs , for large enough , it is sufficient to hit cycles of small size to recover the planted feedback vertex set. For example, if  for some absolute constant , then it is sufficient to find the best hitting set for triangles in . This would be the planted feedback vertex set. We state the theorem for cycles of length .
\begin{theorem}\label{theorem:planted-directedFVS}
Let  be a planted directed random graph  with planted feedback vertex set , where  for some constant  and . Then, with high probability, the smallest hitting set for the set of cycles of size  in  is the planted feedback vertex set .
\end{theorem}
Thus, in order to recover the planted feedback vertex set, it is sufficient to obtain cycles in increasing order of their sizes and find the best hitting set for the subset of all cycles of size . Moreover, the expected number of cycles of length  is at most  for the mentioned range of  and constant . Thus, we have a polynomial-sized collection  of cycles, such that the optimal hitting set for  is also the optimal hitting set for all cycles in .

However, finding the smallest hitting set is NP-hard even for triangles. We give an efficient algorithm to recover the planted feedback vertex set using an \emph{approximate} hitting set for the small cycles.
\begin{theorem}\label{theorem:algorithm-planted-directedFVS}
Let  be a planted directed random graph  with planted feedback vertex set , where  for some constant  and , . Then, there exists an algorithm to recover the planted feedback vertex set  with high probability; this algorithm has an expected running time of .
\end{theorem}

\section{Algorithms}
In this section, we mention a generic algorithm for implicit hitting set problems. We then focus on specializing this algorithm to the feedback vertex set problems in directed and undirected graphs.

\subsection{A Generic Algorithm}
We mention a generic algorithm for solving instances of the implicit hitting
set problem optimally with the aid of an oracle and a subroutine for the exact solution of (explicit) hitting set problems. The guiding principle is to build up a short list of important subsets that dictate the solution, while limiting the number of times the subroutine is invoked, since its computational cost is
high.

A set  is called {\it feasible} if it is a hitting set for the
implicit hitting set problem, and {\it optimal} if it is feasible and of
minimum cardinality among all feasible  hitting sets. Whenever the  oracle reveals
that a set  is not feasible, it returns  , a subset that H does not
hit. Each generated subset  is added to a growing list
 of subsets. A set  is called -feasible if it hits every
subset in  and -optimal if it is -feasible and of
minimum cardinality among all -feasible subsets. If a -optimal set 
is feasible then it is necessarily optimal since  is a valid hitting set for the implicit hitting set problem which contains subsets in , and  is the minimum hitting set for subsets in . Thus the goal of the algorithm is to construct a feasible -optimal set. 

\noindent {\bf Generic Algorithm}\\
\noindent Initialize .
\begin{enumerate}
\item Repeat:
\begin{enumerate}
\item .
\item Repeat while there exists a -feasible set  such that , :
	\begin{enumerate}
	\item If  is feasible then ; else .
	\end{enumerate}
\item Construct a -optimal set .
\item If  then return  and halt ( is optimal); if  is feasible then return  and halt ( is optimal); else .
\end{enumerate}
\end{enumerate}

\noindent {\bf Remark 1}. Since the generic algorithm solves optimally an NP-hard problem as a subroutine, its worst-case execution time is exponential in . Its effectiveness in practice depends on the choice of the missed subset that the oracle returns.

A companion paper \cite{km} describes successful computational experience with
an algorithm that formulates a multi-genome alignment problem as an implicit
hitting set problem, and solves it using a specially tailored variant of the 
generic algorithm.

\begin{center}
\fbox{\parbox{6.7in}{
\begin{minipage}{6.5in}
\begin{tt}

\noindent {\bf Algorithm Augment-BFS}
\begin{enumerate}
\item Start from an arbitrary vertex as a surviving vertex. Initialize i=1.
\item Repeat:
\begin{enumerate}
\item Obtain cycles induced by one step BFS-exploration of the surviving vertices at depth i. Delete vertices at depth i+1 that are present in these cycles. Declare the remaining vertices at depth i+1 as surviving vertices.
\item If no vertices at depth i+1 are surviving vertices, terminate and output the set of all deleted vertices.
\item i=i+1.
\end{enumerate}
\end{enumerate}


\end{tt}
\end{minipage}
}}
\end{center}


\subsection{Algorithm Augment-BFS}
In this section, we give an algorithm to find the feedback vertex set in both undirected and directed graphs. Here, we use an oracle that returns cycles according to a breadth-first search ordering. Instead of the exact algorithm for the (explicit) hitting set problem, as suggested in the generic algorithm, we use a simpler strategy of picking a vertex from each missed cycle. Essentially, the algorithm considers cycles according to a breadth-first search ordering and maintains an induced tree on a set of vertices denoted as surviving vertices. The vertices deleted in the process will constitute a feedback vertex set. Having built an induced tree on surviving vertices up to a certain depth , the algorithm is presented with cycles obtained by a one-step BFS exploration of the surviving vertices at depth . For each such cycle, the algorithm picks a vertex at depth  to delete. The vertices at depth  that are not deleted are added to the set of surviving vertices, thereby leading to an induced tree on surviving vertices up to depth .

\noindent {\bf Remark 2}. Although a very similar algorithm can be used for other variants of the feedback set problem, we note that these problems in random graphs turn out to be easy. For example, the feedback edge set problem is equivalent to the maximum spanning tree problem, while the feedback arc set problem has tight bounds for random graphs using very simple algorithms.


\section{Feedback Vertex Set in Random Graphs}
In this section, we show that Augment-BFS can be used to find a nearly optimal feedback vertex set in the undirected random graph . Our main contribution is a rigorous analysis of the heuristic of simple cycle elimination in BFS order. We say that a vertex  is a {\bf \emph{unique}} neighbor of a subset of vertices  if and only if  is adjacent to exactly one vertex in .

In Algorithm Augment-BFS, we obtain induced cycles in BFS order having deleted the vertices from the current candidate FVS . We refine the candidate
FVS  precisely as follows to obtain an induced BFS tree with unit increase in height: Consider the set  of cycles obtained by one-step BFS exploration from the set of vertices at current depth. Let  denote the set of unexplored vertices in the cycles in  ( is a subset of the vertices obtained by one-step BFS exploration from the set of vertices at current depth). Among the vertices in  include all non-unique neighbors of the set of vertices at current depth into . Find a large independent set in the subgraph induced by the unique neighbors  of the set of vertices at current depth. Include all vertices in  that are not in the independent set into . This iterative refinement process is a natural adaptation of the idea behind the generic algorithm to the feedback vertex set problem where one collects a subset of cycles to find a hitting set  for these cycles and proposes  as the candidate set to obtain more cycles that have not been hit.

\begin{figure}[H]
\label{fig:bfs-exploration}
\begin{center}
\psfig{file=bfs-exploration.jpg,width=3in,height=2.2in}
\end{center}
\caption{BFS Exploration}
\end{figure}

Essentially, the algorithm maintains an induced BFS tree by deleting vertices to remove cycles. The set of deleted vertices form a FVS. Consequently at each level of the BFS exploration, one would prefer to add as many vertices from the next level  as possible maintaining the acyclic property. One way to do this is as follows: Delete all the non-unique neighbors of the current level from  thus hitting all cycles across the current and next level. There could still be cycles using an edge through the unique neighbors. To hit these, add a large independent set from the subgraph induced by the unique neighbors and delete the rest. Observe that this induced subgraph is a random graph on a smaller number of vertices. However, even for random graphs, it is open to find the largest independent set efficiently and only a factor  approximation is known.

In our analysis, instead of using the two approximate algorithm for the independent set problem, we use the simple heuristic of deleting a vertex for each edge that is present in the subgraph to find an independent set at each level. In order to lower bound the size of the induced tree, it suffices to consider growing the BFS-tree up to a certain height  using this heuristic and then using the -approximate algorithm for independent set at height  to terminate the algorithm. The size of the induced tree obtained using Algorithm Augment-BFS is at least as large as the one produced by the process just described. To simplify our analysis, it will be useful to restate the algorithm as Algorithm Grow-induced-BFS.

\begin{center}
\fbox{\parbox{6.6in}{
\begin{minipage}{6.4in}
\begin{tt}
\noindent {\bf Algorithm Grow-induced-BFS}
\begin{enumerate}
\item Start from an arbitrary vertex  at level , set . Mark  as exposed. Fix .
\item Explore levels , where  in BFS order as follows:
\begin{enumerate}
\item Let  be the subset of neighbors of  among the unexposed vertices, where  is the set of surviving vertices at level .
\item Mark the vertices in  as exposed.
\item Let  be the subset of vertices in  that are {\bf \emph {unique}} neighbors of .
\item For every edge  that is present between vertices , add either  or  to .
\item Set .\\
 \emph{(The set of surviving vertices at level , namely  is an independent set in the subgraph induced by .)}
\end{enumerate}
\item On obtaining , set  = {\bf \emph{unique}} neighbors of  among the unexposed vertices. In the subgraph induced by , find an independent set  as follows.
\begin{enumerate}
\item Fix an arbitrary ordering of the vertices of . Repeat while :
\begin{itemize}
\item Add the next vertex  to . Let = neighbors of  in . Set .
\end{itemize}
\end{enumerate}
\item Return  as the feedback vertex set.
\end{enumerate}
\end{tt}
\end{minipage}
}}
\end{center}
\noindent 

We remark that improving the approximation factor of the largest independent set problem in  would also improve the size of the FVS produced. Our analysis shows that most of the vertices in the induced BFS tree get added at depth  as an independent set.
Moreover, the size of this independent set is close to . Consequently, any improvement on the approximation factor of the largest independent set problem in  would also lead to improving the size of the independent set found at depth . This would increase the number of vertices in the induced BFS tree and thereby reduce the number of vertices in the feedback vertex set.

Observe that Algorithm Grow-induced-BFS can be used for the directed random graph  by ignoring the orientation of the edges to obtain a nearly optimal feedback vertex set. Such a graph obtained by ignoring the orientation of the edges is the random graph . Further, a FVS in such a graph is also a FVS in the directed graph. Consequently, we have the following theorem.
\begin{theorem}\label{directed-FVS}
For , there exists a polynomial time algorithm that produces a FVS of size at most  with probability at least .
\end{theorem}
By Theorem \ref{theorem:directed-FVSlowerbound}, we see that the algorithm is nearly optimal for directed random graphs.

Next, we analyze Algorithm Grow-induced-BFS to find the size of the FVS that it returns. For , let
 be the set of surviving vertices at level  with ,
 be the set of \emph{unique} neighbors of  with , and
 be the set of unexposed vertices of the graph after  levels of BFS exploration with . Observe that .


We will need the following theorem due to Frieze \cite{frieze-ind-set}, about the size of the independent set.
\begin{theorem}\cite{frieze-ind-set} \label{theorem:large-ind-set}
Let  and  be fixed. Suppose  for some sufficiently large fixed constant . Then, almost surely, the size of the independent set in  is at least

\end{theorem}


\subsection{Large Set of Unique Neighbors}
The following lemma gives a concentration of the number of surviving vertices, unexposed vertices and unique neighbors to survivors at a particular level. It shows that upon exploring  levels according to the algorithm, the number of surviving vertices at the -th level, , is not too small while the number of unexposed vertices, , is large. It also shows a lower bound on the number of unique neighbors  to a level of survivors. This fact will be used in proving Theorem \ref{theorem:undirected-MFVS}.
\begin{lemma}\label{lemma:largesurvivors}
Let  and  be the largest integer that satisfies .
Then, with probability at least , ,
\begin{enumerate}
\item

\item

\item

\end{enumerate}
\end{lemma}

Now, we are ready to prove Theorem \ref{theorem:undirected-MFVS}.

\subsection{Proof of main theorem}
\begin{proof} [Proof of Theorem \ref{theorem:undirected-MFVS}]
Our objective is to use the fact that the size of the surviving set of vertices is large when the algorithm has explored  levels. Moreover, the number of unexposed vertices is also large. Thus, there is a large independent set among the \emph{unique} neighbors of the surviving vertices. This set along with the surviving vertices up to level  will form a large induced tree. We will now prove that the size of the independent set among the \emph{unique} neighbors of  is large.

By Theorem \ref{theorem:large-ind-set}, if  for some constant  and , then there exists an independent set of size . It suffices to prove that  is large and is such that .

Note that the choice of  used in the algorithm satisfies the hypothesis of Lemma \ref{lemma:largesurvivors}. Therefore, using Lemma \ref{lemma:largesurvivors}, with probability at least , we have

for sufficiently large  since


Consequently, by Theorem \ref{theorem:large-ind-set}, there exists an independent set of size at least . Moreover, step 3 of the algorithm finds a -approximate independent set (see \cite{grimmett-diarmid-1975,diarmid-1984}). Therefore, the size of the independent set found in step 3 is at least , which is greater than

Note that this set gets added to the tree obtained by the algorithm which increases the number of vertices in the tree while maintaining the acyclic property of the induced subgraph. Hence, with probability at least , the induced subgraph has  vertices. Consequently, the FVS obtained has size at most  with probability at least .

\end{proof}


\section{Planted Feedback Vertex Set Problem}
We prove Theorems \ref{theorem:planted-directedFVS} and \ref{theorem:algorithm-planted-directedFVS} in this section.

The proof of Theorems \ref{theorem:planted-directedFVS} and \ref{theorem:algorithm-planted-directedFVS} are based on the following fact formalized in Lemma \ref{lemma:cycle-through-every-vertex}: if  is a subset of vertices of size at least , then with high probability, every vertex  induces a -cycle with vertices in . Consequently, a small hitting set  for the -cycles should contain either all vertices in  or most vertices from . If some vertex  is not present in , then the size of  will be large since it should contain most vertices from . This contradicts the fact that  is a small hitting set. Thus  should contain the planted feedback vertex set . This fact is stated in a general form based on the size of  in Lemma \ref{lemma:small-hitting-set-contains-P}.

For Theorem \ref{theorem:planted-directedFVS},  is the smallest hitting set. By the previous argument , and we are done since no additional vertex  will be present in  (in fact,  is a hitting set for all cycles since it is a feedback vertex set). We formalize these arguments in this section.

\begin{lemma}\label{lemma:cycle-through-every-vertex}
Let  be a planted directed random graph where  for some constants . Then, with high probability, for every vertex , there exists a cycle of size  through  in the subgraph induced by  in  if  is a subset of  of size at least .
\end{lemma}

We give a proof of this lemma by the second moment method later. It leads to the following important consequence which will be used to prove Theorems \ref{theorem:planted-directedFVS} and \ref{theorem:algorithm-planted-directedFVS}. It states that every sufficiently small hitting set for the -cycles in  should contain every vertex from the planted feedback vertex set.
\begin{lemma}\label{lemma:small-hitting-set-contains-P}
Let  be a hitting set for the -cycles in  where  for some constants . If  where , then .
\end{lemma}

\begin{proof}
Suppose  and . Then  should contain at least  vertices from , else  by Lemma \ref{lemma:cycle-through-every-vertex}, there exists a -cycle involving  and some  vertices among the  vertices that  does not contain contradicting the fact that  hits all cycles of length . Therefore,  by the choice of . Thus, the size of  is greater than , a contradiction.
\end{proof}

\begin{proof}[Proof of Theorem \ref{theorem:planted-directedFVS}]
We will first show that the smallest hitting set for the -cycles in  is of size exactly .
By Lemma \ref{lemma:cycle-through-every-vertex} there exists a -cycle through every vertex  and some  if  and .
\begin{lemma}\label{lemma:lower-bound-HS}
If a subset  hits all cycles of length  in , then .
\end{lemma}
\begin{proof}[Proof of Lemma \ref{lemma:lower-bound-HS}]
If  contains all vertices in , then we are done. Suppose not. Let  and . Then  should contain at least  vertices from , else by Lemma \ref{lemma:cycle-through-every-vertex}, there exists a -cycle involving  and some  vertices among the  vertices that  does not contain. This would contradict the fact that  hits all cycles of length . Therefore,  since .
\end{proof}

Therefore, every hitting set for the subset of -cycles should be of size at least . Also, we know that  is a hitting set for the -cycles since  is a feedback vertex set in . Thus, the optimum hitting set for the -cycles is of size exactly .

Let  be the smallest hitting set for the -cycles. Then . It is easily verified that  satisfies the conditions of Lemma \ref{lemma:small-hitting-set-contains-P} if . Therefore, . Along with the fact that , we conclude that .
\end{proof}

\subsection{Algorithm to Recover Planted Feedback Vertex Set}
In this section, we give an algorithm to recover the planted feedback vertex set in  thereby proving Theorem \ref{theorem:algorithm-planted-directedFVS}. Theorem \ref{theorem:planted-directedFVS} suggests an algorithm where one would obtain all cycles of length  and find the best hitting set for these set of cycles. Even though the number of -cycles is polynomial, we do not have a procedure to find the best hitting set for -cycles. However, by repeatedly taking all vertices of a cycle into the hitting set and removing them from the graph, we do have a simple greedy strategy that finds a -approximate hitting set. We will use this strategy to give an algorithm that recovers the planted feedback vertex set.

\noindent {\bf Algorithm Recover-Planted-FVS()}
\begin{enumerate}
\item Obtain cycles in increasing order of size until all cycles of length  are obtained. Let  be the subset of cycles. Let  be the empty set.
\item While there exists a cycle  such that  does not hit ,
\begin{enumerate}
\item Add all vertices in  to .
\end{enumerate}
\item Return , where  -cycle through  in the subgraph induced by .
\end{enumerate}

The idea behind the algorithm is the following: The set  obtained at the end of step  in the above algorithm is a -approximate hitting set and hence is of size at most . Using Lemma \ref{lemma:small-hitting-set-contains-P}, it is clear that  contains  - indeed, if  does not contain all vertices in , then  should contain most of the vertices in  contradicting the fact that the size of  is at most . Further, owing to the choice of , it can be shown that  does not contain at least  vertices from .  Therefore, by Lemma \ref{lemma:cycle-through-every-vertex}, every vertex  induces a -cycle with some subset of vertices from . Also, since  is a DAG no vertex  induces cycles with any subset of vertices from . Consequently, a vertex  induces a -cycle with vertices in  if and only if . Thus, the vertices in  are identified exactly.

\begin{proof}[Proof of Theorem \ref{theorem:algorithm-planted-directedFVS}]
We use Algorithm Recover-Planted-FVS to recover the planted feedback vertex set from the given graph . Since we are using the greedy strategy to obtain a hitting set  for , it is clear that  is a -approximate hitting set. Therefore . It is easily verified that  satisfies the conditions of Lemma \ref{lemma:small-hitting-set-contains-P} if . Thus, all vertices from the planted feedback vertex set  are present in the subset  obtained at the end of step 2 in the algorithm.

By the choice of , it is true that . Hence, .

Since , the subset of vertices  does not contain any vertices from the planted set. Also, the number of vertices in  is at least . Consequently, by Lemma \ref{lemma:cycle-through-every-vertex}, each vertex  induces at least one -cycle with vertices in . Since  is a DAG, none of the vertices  induce cycles with vertices in . Therefore, a vertex  induces a -cycle with vertices in  if and only if . Hence, the subset  output by Algorithm Recover-Planted-FVS is exactly the planted feedback vertex set .

Next we prove that the algorithm runs in polynomial time in expectation. The following lemma shows an upper bound on the expected number of cycles of length . It is proved later by a simple counting argument.

\begin{lemma}\label{lemma:expected-no-of-cycles}
The expected number of cycles of length  in  is at most .
\end{lemma}
Since the expected number of cycles obtained by the algorithm is  by Lemma \ref{lemma:expected-no-of-cycles}, the algorithm uses -sized storage memory. Finally, since the size of  is , steps 2 and 3 of the algorithm can be implemented to run in expected  time.
\end{proof}

\section{Proofs}
\subsection{Lower Bound for FVS in Random Graphs}
In this section, we prove the lower bound for the Feedback Vertex Set in random graphs. We consider the dual problem - namely the maximum induced acyclic subgraph.

We will need the following bound on the number of ways to partition a positive integer  into  positive integers.
\begin{theorem}\label{theorem:partition-function}\cite{wladimir-partition-function}
Let  denote the number of ways to partition  into exactly  parts. Then there exists an absolute constant  such that

where  and  for .
\end{theorem}
\noindent {Remark 3.} Since we will not need such a tight bound, we will use  for some constants .

We prove Theorem \ref{theorem:undirected-FVSlowerbound} now based on simple counting arguments. We observe that the proof of Theorem \ref{theorem:directed-FVSlowerbound} given by Spencer and Subramanian is also based on similar counting arguments while observing that if a directed graph is acyclic, then there exists an ordering of the vertices such that each arc is in the forward direction.
\begin{proof}[Proof of Theorem \ref{theorem:undirected-FVSlowerbound}]
First note that every induced subgraph on  vertices is a graph from the family . We bound the probability that a graph  is a forest.\\



which tends to zero when .
\end{proof}

\subsection{Feedback Vertex Set in Random Graphs}
We will use the following Chernoff bound for the concentration of the binomial distribution.
\begin{lemma} \label{lemma:chernoff}
Let  where  are i.i.d. Bernoulli random variables with . Then

\end{lemma}

\begin{proof}[Proof of Lemma \ref{lemma:largesurvivors}]
We prove the lemma by induction on . We will prove the stronger induction hypothesis that every ,  for  satisfy their respective concentration bounds with probability at least

We will prove the concentration of  as a consequence of  and  satisfying their respective concentration bounds. We will in fact show that the failure probability of  satisfying its concentration bound conditioned on  and  satisfying their respective concentration bounds will be at most . It immediately follows that with failure probability at most , every ,  and , for  satisfies its respective concentration bound leading to the conclusion of the lemma.

For the base case, consider . It is clear that  and  satisfy the concentration bounds with probability . For the induction step, the induction hypothesis is the following: With probability at least , the concentration bounds are satisfied for  and  for every . We will bound the probability that  or  fails to satisfy its corresponding concentration bound conditioned on the event that  for  satisfy their respective concentration bounds.

\noindent 1. To prove the concentration bound for , observe that  is a binomial distribution with  trials and success probability . Indeed,  is the number of vertices among  which are not neighbors of vertices in . For each vertex , xL_t.

Therefore, by Lemma \ref{lemma:chernoff}, we have that


with . Hence, with probability at least ,


Now, using the bounds on  and , 
since ,


Hence, 

Therefore, 

which proves the lower bound. The upper bound is obtained by proceeding similarly:


Thus,  satisfies the concentration bound with failure probability at most  conditioned on the event that  for  satisfy their respective concentration bounds.

\noindent 2. Next we address the failure probability of  not satisfying its concentration bound conditioned on the event that  for  satisfy their respective concentration bounds. Lemma \ref{lemma:lowerbound-R} proves that the number of {\bf \emph{unique}} neighbors  is concentrated around its expectation.

\begin{lemma}\label{lemma:lowerbound-R}
Let . With probability at least  
when .
\end{lemma}
\begin{proof}[Proof of Lemma \ref{lemma:lowerbound-R}]
Observe that  is a binomially distributed random variable with  trials and success probability . Indeed,  is the number of vertices among  which are adjacent to exactly one vertex in . For each , uL_t.

Using , by Lemma \ref{lemma:chernoff}, we have that


Hence, with probability at least ,


Lemma \ref{lemma:lowerbound-qu} proves the concentration of the expected number of unique neighbors of  conditioned on the event that  for  satisfy their respective concentration bounds. This in turn helps in proving that  is concentrated.
\begin{lemma}\label{lemma:lowerbound-qu}
For , if  and  satisfy their respective concentration bounds, then
\begin{enumerate}
\item ,
\item \\
.
\end{enumerate}
\end{lemma}
\begin{proof}[Proof of Lemma \ref{lemma:lowerbound-qu}]
Recall that . Hence, 
using Lemma \ref{lemma:handler1} and

For the upper bound:


\end{proof}

Consequently, using Lemma \ref{lemma:lowerbound-qu}, 
since, when ,


Hence, by inequalities \ref{ineq:r-lowerbound} and \ref{ineq:r-upperbound}, with probability at least , 
when . This concludes the proof of Lemma \ref{lemma:lowerbound-R}
\end{proof}
Lemmas \ref{lemma:lowerbound-R} and \ref{lemma:lowerbound-qu} together show that  satisfies the concentration bounds with failure probability at most  conditioned on the event that  and  satisfy their respective concentration bounds.

\noindent 3. Finally we address the failure probability of  satisfying its concentration bound conditioned on the event that  for  satisfy their respective concentration bounds. By Step 2(e) of the algorithm, the number of surviving vertices in level  is , where  denotes the number of edges among the vertices in . In Lemma \ref{lemma:lowerbound-R}, we showed that the number of {\bf \emph{unique}} neighbors  is concentrated around its expectation. Lemma \ref{lemma:upperbound-M} proves a concentration which bounds the number of edges among the vertices in . These two bounds will immediately lead to the induction step on . Thus, the probability that  does not satisfy its concentration bound will at most be the probability that either  or  does not satisfy its respective concentration bound.

\begin{lemma}\label{lemma:upperbound-M}
 with probability at least .
\end{lemma}

\begin{proof}[Proof of Lemma \ref{lemma:upperbound-M}]
Recall that  denotes the number of edges among the vertices in . Since the algorithm has not explored the edges among the vertices in ,  is a random variable following the Binomial distribution with  trials and success probability . By Markov's inequality, we have that for ,

Hence,  with probability at least , .
\end{proof}

Recollect that . The upper bound of the induction step follows using Lemma \ref{lemma:lowerbound-qu}:


For the lower bound, we use Lemmas \ref{lemma:lowerbound-R} and \ref{lemma:upperbound-M} conditioned on the event that  and  satisfy their respective concentration bounds. With failure probability at most

we have that 


proving the induction step of the lower bound for .

Thus,  satisfies the concentration bounds with failure probability at most  conditioned on the event that  for  satisfy their respective concentration bounds.

Finally, by the union bound, with probability at most , either  or  does not satisfy its respective concentration bounds conditioned on the event that  for  satisfy their respective concentration bounds. By induction hypothesis, the failure probability of some  for  not satisfying their respective concentration bound is at most . Hence, the probability that   satisfy their respective concentration bound for every  is at least . Therefore, with probability at least , every  for  satisfy their respective concentration bounds. This proves the stronger induction hypothesis.

To complete the proof of Lemma \ref{lemma:largesurvivors}, recollect that we showed that the failure probability of  satisfying its concentration bound conditioned on  and  satisfying their respective concentration bounds is at most . By the union bound argument, it immediately follows that with failure probability at most , every ,  and , for  satisfies its respective concentration bound. This concludes the proof of Lemma \ref{lemma:largesurvivors}.
\end{proof}

\begin{lemma} \label{lemma:handler1}
For ,
\begin{enumerate}
\item

\item 

\end{enumerate}
\end{lemma}
\begin{proof} [Proof of Lemma \ref{lemma:handler1}]
We prove the first part of the Lemma by induction. For the base case, we need to prove that

which is true.
For the induction step, we need to prove that


Now, LHS

Hence, it is sufficient to prove that

which is true for large enough  when .

For the second part of the Lemma, we need to prove that


i.e., 

i.e.,

which is true since  for large  and the rest of the terms are less than  when .

\end{proof}

\subsection{Planted Feedback Vertex Set}
We prove Lemma \ref{lemma:cycle-through-every-vertex} by the second moment method.
\begin{proof}[Proof of Lemma \ref{lemma:cycle-through-every-vertex}]
Let , , . Let  denote the number of cycles of size  through  in the subgraph induced by . Then, . Using Chebyshev's inequality, we can derive that

To compute the variance of , we write , where the random variable  is  when the vertices in  induce a cycle of length  with  and  otherwise.


Now, for any fixed subsets ,  and ,  and the number of such subsets is at most . Therefore,


as  if  for some sufficiently large constant  since each term in the summation tends to  and the summation is over a finite number of terms. Thus

Therefore,

and hence

as  if  for some large constant .
\end{proof}

Finally, we prove Lemma \ref{lemma:expected-no-of-cycles} by computing the expectation.
\begin{proof}[Proof of Lemma \ref{lemma:expected-no-of-cycles}]
k


\end{proof}

\section{Conclusion}
Several well-known combinatorial problems can be reformulated as hitting set problems with an exponential number of subsets to hit. However, there exist efficient procedures to verify whether a candidate set is a hitting set and if not, output a subset that is not hit. We introduced the implicit hitting set as a framework to encompass such problems. The motivation behind introducing this framework is in obtaining efficient algorithms where efficiency is determined by the running time as a function of the size of the ground set. We initiated the study towards developing such algorithms by showing an algorithm for a combinatorial problem that falls in this framework -- the feedback vertex set problem on random graphs. It would be interesting to extend our results to other implicit hitting set problems mentioned in Section 1.1.


\bibliographystyle{amsalpha}
\bibliography{references}
\end{document}