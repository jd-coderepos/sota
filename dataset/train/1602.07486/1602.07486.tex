\documentclass[preprint,11pt]{elsarticle}

\usepackage{amsfonts, amsmath, amssymb, amsthm, pbox, graphicx}
\usepackage{longtable}
\usepackage{hyperref}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{example}{Example}[section]
\theoremstyle{remark}
\newtheorem{remark}{Remark}



\oddsidemargin=13pt
\topmargin = 0cm
\textheight = 20cm
\textwidth = 15cm

\journal{Logic Journal of the IGPL}


\begin{document}

\begin{frontmatter}

\title{A Complete Logic for Database Abstract State Machines}

\author[1]{Qing Wang}
\author[2]{Flavio Ferrarotti}
\author[2]{Klaus-Dieter Schewe}
\author[2]{Loredana Tec}
 
\address[1]{Research School of Computer Science, The Australian National University, Australia, \textrm{qing.wang@anu.edu.au}}
\address[2]{Software Competence Center Hagenberg, Austria, \textrm{[flavio.ferrarottiloredana.tec]@scch.at},\textrm{kdschewe@acm.org}}








\begin{abstract}
In database theory, the term \emph{database
transformation} was used to refer to a unifying treatment for
computable queries and updates.
Recently, it was shown that non-deterministic
database transformations can be captured exactly by a variant of
ASMs, the so-called Database Abstract State Machines (DB-ASMs). In
this article we present a logic for DB-ASMs,  extending the logic of Nanchen and St\"ark for ASMs. In particular, we
develop a rigorous proof system for the logic for DB-ASMs, which is
proven to be sound and complete. The most
difficult challenge to be handled by the extension is a proper
formalisation capturing non-determinism of database transformations
and all its related features such as consistency,
update sets or multisets associated with DB-ASM rules. As the database part of a state of database transformations is a
finite structure and DB-ASMs are restricted by allowing quantifiers only over
the database part of a state, we resolve this problem by taking update sets explicitly into the logic, i.e. by using an additional modal operator , where  is interpreted as an update set 
generated by a DB-ASM rule. The DB-ASM logic provides a powerful
verification tool to study properties of database transformations.\0.2cm]
- \textsc{City}, \textsc{Route}, \textsc{Visited}, \textsc{Result}, c, \textsc{True}, \textsc{False}, \textsc{Initial} ;\0.2cm]
- \textsc{Val}, \textsc{Dist} ; and \0.2cm]
\\*
\hspace*{0.8cm}\0.2cm]


\end{enumerate}
\end{example}


\begin{figure}[!ht]
\small
1\hspace{0.2cm}\textbf{par}

2\hspace{0.7cm}\textbf{if} \textsc{Initial} \textbf{then}

3\hspace{1.2cm}\textbf{par}

4\hspace{1.7cm}\textbf{forall}  \textbf{with} 

5\hspace{2.2cm}\textbf{par}



6\hspace{2.7cm}\textbf{if}  \textbf{then}  := \textsc{Zero} \textbf{endif}

7\hspace{2.7cm}\textbf{if}  \textbf{then}  := \textsc{Infinity} \textbf{endif}

8\hspace{2.2cm}\textbf{endpar}

9\hspace{1.70cm}\textbf{enddo}

10\hspace{1.55cm}

11\hspace{1.05cm}\textbf{endpar}

12\hspace{0.55cm}\textbf{endif}

13\hspace{0.55cm}\textbf{if}  \textbf{then}

14\hspace{1.05cm}\textbf{seq}

15\hspace{1.55cm}\textbf{let}  \textbf{in}

16\hspace{2.05cm}\textbf{forall}  \textbf{with}  \textbf{do}

17\hspace{2.55cm}

18\hspace{2.05cm}\textbf{enddo}

19\hspace{1.55cm}\textbf{endlet}

20\hspace{1.55cm}\textbf{choose}  \textbf{with}  \textbf{do}

21\hspace{2.05cm}\textbf{par}

22\hspace{2.55cm}

23\hspace{2.55cm}\textbf{forall}  \textbf{with} 

24\hspace{5.1cm} \textbf{do}

25\hspace{3.05cm}\textbf{par}

26\hspace{3.55cm}

27\hspace{3.55cm}

28\hspace{3.55cm}\textbf{forall}  \textbf{with}  \textbf{do}

29\hspace{4.05cm}

30\hspace{3.55cm}\textbf{enddo}

31\hspace{3.05cm}\textbf{endpar}

32\hspace{2.55cm}\textbf{enddo}

33\hspace{2.05cm}\textbf{endpar}

34\hspace{1.55cm}\textbf{enddo}

35\hspace{1.05cm}\textbf{endseq}

36\hspace{0.55cm}\textbf{endif}

37\hspace{0.1cm}\textbf{endpar}
\caption{A DB-ASM}
\label{exa:DBASM-code}
\end{figure}


















\section{Meta-finite Structures as States}\label{sec:states}

Meta-finite structures were originally studied by Gr{\"a}del and Gurevich in order to extend the methods of finite model theory beyond finite structures \cite{graedel:infcomp1998}. In a nutshell, a meta-finite structure consists of (a) a
primary part, which is a finite structure, (b) a secondary part, which is a (usually
infinite) structure, and
(c) a set of functions mapping from the primary part into the second part. Typical examples of meta-finite structures are finite objects arising in many areas of computer science, which usually consist of both structures and
numbers. For example, graphs with weights on the edges, where a graph may be representable by a finite structure but its weights on the edges may be reals from an infinite domain, and arithmetical operations performed on these weights may not be any a \emph{priori} fixed finite subdomain \cite{graedel:infcomp1998}. Another example is relational databases in which each relation contains only a finite number of tuples. Although theoretically a relational database is viewed as a finite structure, attribute domains of a relation are often assumed to be countably infinite. In particular, such domains may be infinite mathematical structures, e.g., the natural numbers with arithmetic, rather than merely plain sets, and such infinite mathematical structures are widely used by aggregate queries in many real-life database applications.


In \cite{Gurevich-New-Thesis} Gurevich argued that ASMs provide a model of computation that is more powerful and more universal than other standard models of computation such as Turing machines, in the sense that any algorithm, however abstract, can be simulated step-for-step by an ASM. This is because a state of an ASM is abstract, which may include any real world objects and functions at a chosen level of abstraction. Let us consider for example algorithms that work with graphs. The conventional computation models require a string representation of the given graph or similar,  even in those cases when the algorithm is independent of the graph representation. In particular, a same database might have different representations, but the meaning of the data should not change. Database query languages are supposed to reflect only representation-independent properties. 

In ASMs, states are viewed as first-order structures, whereas in DB-ASMs we consider states as meta-finite structures
\cite{schewe:Axiomatization}. Conceptually, each state of a DB-ASM has a finite
\emph{database part} and a possibly infinite \emph{algorithmic part}, which are
linked via \emph{bridge functions} such that actual database entries
are treated merely as surrogates for the real values. This permits
a database to remain finite while allowing database entries to be
interpreted in possibly infinite domains such as the natural numbers
with arithmetic operations. A signature  of states
comprises (i) a sub-signature  for the database part, (ii) a
sub-signature  for the algorithmic part and (iii) a finite set
 of bridge function names. The \emph{base set} of a
state  is a nonempty set of values , where
 is finite, and  contains natural numbers, i.e., . Function
symbols  in  and , respectively, are
interpreted as functions  over  and , and the
 interpretation of a k-ary function symbol 
defines a function  from  to . For every state
over , the restriction to  results in a
finite structure.


Since the states of DB-ASMs are defined as meta-finite structures, we now need to define a matching logic so that it can be used in the conditional statements of DB-ASMs. That is, we need a  logic of meta-finite structures as introduced in~\cite{graedel:infcomp1998}. Logics of meta-finite structures distinguish among two types of terms. The first type, which we call \emph{database terms}, denote elements of the primary (finite) part of the meta-finite structure. The second type, which we call \emph{algorithmic terms}, denote elements of the secondary (possibly infinite) part of the meta-finite structure. 

\begin{definition}\label{termsOfLFO}
Let  be a signature of meta-finite states. Fix a countable set  
of first-order variables, denoted with standard lowercase letters , that range over the primary database part of the meta-finite states (i.e., the finite set ). The set of \emph{database terms}  is defined as the closure of the set  of variables under the application of function symbols in . We assume that  always include a function symbol for equality. In turn, the set of \emph{algorithmic terms}  is defined inductively as follows:
\begin{itemize}
\item If  are database terms in  and  is an -ary bridge function symbol in , then  is an algorithmic term in . 
\item If  are algorithmic terms in  and  is an -ary function symbol in , then  is an algorithmic term in .
\item Nothing else is an algorithmic term in . 
\end{itemize}
We set .
\end{definition}


In this context, a \emph{variable assignment} (or \emph{valuation})  is a function which assigns to every variable in  a value in the base set of the database part  of the meta-finite state . The  value of a term  in a state  under a valuation , denoted , is defined as usual in first-order logic, i.e., using the classical Tarski's semantics.


The \emph{logic of meta-finite states}  which we use in the formalization DB-ASMs is defined as the first-order logic with equality which is built up from equations between terms in  by using the standard connectives and first-order quantifiers. Its semantics is defined in the standard way. The truth value of a formula of meta-finite states  in  under the valuation  is denoted as .



\section{Database Abstract State Machines}\label{sec:adtm}

Our work in this paper concerns the model of \emph{Database Abstract State Machine} (DB-ASM) that captures the class of database transformations defined by the postulates in the DB-ASM thesis \cite{schewe:Axiomatization,DBLP:wangphdbook}. Accordingly, we assume that states of DB-ASMs are meta-finite structures which include a minimum background of computation as required by the background postulate in the axiomatization of database transformations in~\cite{schewe:Axiomatization,DBLP:wangphdbook} (note that this is essentially the same background that is required in the parallel ASM thesis \cite{blass:tocl2003, GurevichParallelCorrection08, FerrarottiSTW16}). That is, every state of a DB-ASM includes:
\begin{itemize} 
\item An infinite reserve of values not used in a current state, but available to be added to the active domain in any state transition.
\item Boolean values ( and ), Bolean operations (, ,  and ), and the undefinedness value (). 
\item A pairing constructor and a multiset constructor together with necessary operators on tuples and multisets. 
\end{itemize}

The bounded exploration postulate in the DB-ASM thesis~\cite{schewe:Axiomatization,DBLP:wangphdbook}, as well as the bounded exploration postulates in Gurevich's sequential ASM thesis~\cite{gurevich:tocl2000} and in the new parallel ASM thesis~\cite{FerrarottiSTW16} (which simplifies the parallel ASM thesis of Blass and Gurevich~\cite{blass:tocl2003, GurevichParallelCorrection08}), are motivated by the \emph{accessibility principle}, which can be defined as the prerequisite that each location of a state must be uniquely identifiable. In fact, unique identifiability also applies to databases as emphasised by Beeri and Thalheim in~\cite{beeri:fomlado1998}, and has to be claimed for the basic updatable units in a database, for example, objects in~\cite{schewe:actacyb1993}. The accessibility principle is also a fundamental assumption used in the characterization proofs of the DB-ASM thesis as well as of the sequential and parallel ASM thesis. We therefore assume that it holds for every state of the DB-ASMs. 

As explained in~\cite{gurevich:tocl2000}, an algorithm  can access an element  of a state by using formulae  and  such that  is a sentence and  is the only free variable in , and the equation  has a unique solution in every state  satisfying . If this information is available, then  can evaluate  at a given state , and provided that  holds in , point to the unique solution  of the equation . To bridge the gap between the formula  and the element , a new nullary function symbol  is introduced, where  is interpreted as the unique solution of the equation  if  holds and as  otherwise. Using this approach, any given algorithm  (database transformation or DB-ASM for that matter) can be formalized so that it can access any location of its states, and therefore satisfies the accessibility principle. We avoid the formal details here as this is a well known fact in the ASM community. For the remainder of this paper, we simply assume that every element  of a state  can be accessed by producing an appropriate nullary function symbol . 


\subsection{Syntax of Rules}
For simplicity, we consider function arguments as tuples. That is, if  is an -ary function and  are arguments for , we write  where  is a term which evaluates to the tuple .
Let  and  denote terms in ,  a dynamic function symbol in  and let  denote an -formula of vocabulary . The set of {\em DB-ASM rules} over  is inductively defined as follows:


\begin{itemize}

\item {\em assignment rule}: update the content of  at the argument  to
;

\hspace{3cm}

\item {\em conditional rule}: execute the rule  if  is true; otherwise, do
nothing;

\hspace{3cm}\textbf{if}  \textbf{then}  \textbf{endif}

\item {\em forall rule}: execute the rule  in parallel for each  satisfying
;

\hspace{3cm}\textbf{forall}  \textbf{with} 
\textbf{do}  \textbf{enddo}

\item {\em choice rule}: choose a value of  that satisfies  and then execute the rule ;

\hspace{3cm}\textbf{choose}  \textbf{with} 
\textbf{do}  \textbf{enddo}

\item {\em parallel rule}: execute the rules  and  in
parallel;

\hspace{3cm}\textbf{par}   \textbf{endpar}

\item {\em sequence rule}: first execute the rule  and then execute the rule
;

\hspace{3cm}\textbf{seq}   \textbf{endseq}

\item {\em let rule}: aggregates, using the location operator , all updates to the location  yielded by  (see definition of location and location operator in Section~\ref{usetsandmultisets} next);

\hspace{3cm}\textbf{let}  \textbf{in}
 \textbf{endlet}

\end{itemize}
Notice that all variables appearing in a DB-ASM rule are \emph{database
variables} that must be interpreted by values in . A rule
 is {\em closed} if all variables of  are bounded by forall and
choice rules.








\subsection{Update Sets and Multisets}\label{usetsandmultisets}
In the ASM literature \cite{boerger:2003}, locations, updates, update sets and update multisets are the key concepts used to formalise the dynamics of computations. Thus, similar to ASMs \cite{boerger:2003}, DB-ASMs can be understood as an extension of finite state machines which proceed by transitions from states to successor states through updates. In a state of a DB-ASM, updatable dynamic functions are called locations, which are distinguished from static functions that cannot be updated. Informally, such locations represent the abstract concept of basic object containers, such as memory units. During each transition step, a DB-ASM produces a set or multiset of updates that are used to change location contents in a state, and location contents in a DB-ASM can only be changed by such updates.

Let  be a state over ,  be a dynamic function symbol of
arity  and  be elements in  or  depending on whether  or , respectively.
Then  is called a {\em location} of . An
\emph{update} of  is a pair , where  is a
location and  or , depending on whether  or , respectively, is the \emph{update value} of . To simplify notations, we write  for the update  with the location . The
interpretation of  in  is called the \emph{content} of
 in , denoted by . An \emph{update set}
 is a set of updates; an \emph{update multiset}
 is a multiset of updates. A \emph{location operator}
 is a multiset function that returns a
single value from a multiset of values, e.g. \textsc{Average},
\textsc{Count}, \textsc{Sum}, \textsc{Max} and \textsc{Min} used in
SQL. An update set  is called \emph{consistent} if it does
not contain conflicting updates, i.e., for all  we have . Likewise, we say that an update multiset  is \emph{consistent} if its corresponding update set , obtained by setting the multiplicity of each element (update) in  to , is a consistent update set. Otherwise, we say that  is \emph{inconsistent}.
If  is a consistent update set, then
there exists a unique state  resulting from
updating  with . We have

If  is not consistent, then  is undefined.

To illustrate the concepts of location operator, update sets and update multisets, we provide the following example in which parallel computations are synchronised by using a let rule.

\begin{example}\label{exa:DBASM-let}

Consider the relation \textsc{Route} in Fig.~\ref{fig:DBASM-Route} and the two DB-ASMs presented in Fig.~\ref{fig:tworules}.


\begin{figure}[!htbp]
{\centering
\begin{tabular}{|c|c|c|}
  \hline
  FromCid & ToCid & Distance \\\hline\hline
   &  &  \\
   &  &  \\
   &  &  \\
   &  &  \\
  \hline
\end{tabular}\caption{A relation
\textsc{Route}}\label{fig:DBASM-Route}}
\end{figure}


\begin{figure}[!htbp]
 \hspace{3cm}\textbf{let}  \textbf{in}

\hspace{3.5cm}\textbf{forall}  \textbf{with}
 \textbf{do}

\hspace{4cm} 

\hspace{3.5cm}\textbf{enddo}

\hspace{3cm}\textbf{endlet}

\smallskip
\hspace{4cm}(a) First DB-ASM

\bigskip
\hspace{3cm}\textbf{forall}  \textbf{with}
 \textbf{do}

\hspace{3.5cm} 

\hspace{3cm}\textbf{enddo}

\smallskip
\hspace{4cm}(b) Second DB-ASM

\caption{Two DB-ASMs}
\label{fig:tworules}
\end{figure}

The first DB-ASM in Fig. \ref{fig:tworules}.(a) computes the total number of
routes in the relation \textsc{Route}. Here \textsc{sum} is a
location operator assigned to the location . In a state containing the
relation \textsc{Route} in Fig.\ref{fig:DBASM-Route}, 
the forall sub-rule yields the update multiset  and the update set . In turn the let rule (and thus the DB-ASM) yields the corresponding update set , which results from the aggregation produced by the location operator \textsc{sum} of the four updates to the location  that appear in the multiset produced by the forall rule. Since the second DB-ASM in Fig. \ref{fig:tworules}.(b) has no location operator associated with the location  and  the forall rule yields the same update multiset and update set as before, this second DB-ASM produces the update set  instead.
\end{example}


\subsection{Semantics of Rules}
The semantics of DB-ASM rules is defined in terms of update
multisets and update sets. More specifically, each DB-ASM rule is
associated with a set of update multisets, which then ``collapses'' to a set of
update sets. Thus, if  is a DB-ASM rule of
signature  and  is a state of , then we
associate a set  of update sets and a set
 of update multisets with  and ,
respectively, where  is a variable assignment.

Let  denote the variable assignment which coincides with  except that it assigns the value  to .
We formally define the sets of update sets and sets of update
multisets yielded by DB-ASM rules in Fig.~\ref{fig:set} and Fig.~\ref{fig:multiset}, respectively. Assignment rules create
updates in update sets and multisets.  Choice rules introduce
non-determinism. Each choice rule generates a \emph{set of update sets} and a corresponding set of update multisets which contain all the different update sets and multisets, respectively, corresponding to all possible choices. Let rules aggregate updates to the same location
into a single update by means of location operators. All other rules
only rearrange updates into different update sets and multisets.


\begin{figure}[!htb]
\fbox{\parbox{14.8cm}{
\begin{itemize}

\item   where  and \\

\item
\\

\item
 \\
\hspace*{3cm} , \\
\hspace*{3cm} where \\

\item
\\
\hspace*{4cm}  \\

\item
\\
\hspace*{4.2cm}  \\

\item
 \\
\hspace*{1cm}  \\
\hspace*{1cm} ,\\
\hspace*{1cm} where \\

\item
\\

\hspace{6.3cm}where 

\end{itemize}}}\caption{Update sets of DB-ASM rules}\label{fig:set}
\end{figure}

\begin{figure}[h!]
\fbox{\parbox{14.8cm}{
\begin{itemize}


\item   where  and \\

\item 

\item
\\
\hspace*{3cm} , \\
\hspace*{3cm} where \\


\item
\\
\hspace*{4cm} \\

\item
\\
\hspace*{4.2cm} \\

\item
\\
\hspace*{1cm}  \\
\hspace*{1cm} , \\
\hspace*{1cm} where \\


\item
\\

\hspace{6.3cm}where 

\end{itemize}}}\caption{Update multisets of DB-ASM rules}\label{fig:multiset}
\end{figure}






\begin{lemma}\label{lem-finiteness}

For each state , each DB-ASM rule  and each variable assignment  from  to the base set  of the database part of , the following holds:

\begin{enumerate}

\item  and  are finite sets.

\item Each  is a finite update set.

\item Each  is a finite update multiset.

\end{enumerate}

\end{lemma}

\begin{proof}(Sketch). We use structural induction on . The case of the assignment rule is obvious, as a single update will be created.

The conditional rule either produces exactly the same update sets and multisets as before or a single empty update set and multiset, respectively. For the forall rule the set  is finite, because  ranges over the finite set . The stated finiteness then follows by induction, as  and  are finite sets, all  and all  are finite, and the new update sets and update multisets are built by set and multiset unions, respectively, that range over the finite set .

For all other rules, the individual update sets and multisets are built by , ,  and aggregation with location operators applied to finite update sets and multisets, which gives the statements 2 and 3. Furthermore, the sets of update sets and update multisets, respectively, are built by comprehensions that range over finite sets. Hence they are finite as well, which gives statement 1 and completes the proof.

\end{proof}


A {\em Database Abstract State Machine} (DB-ASM)  over signature
 consists of

\begin{itemize}

\item a set  of states over , non-empty subsets  of initial states and  of final states,

\item a closed DB-ASM rule  over , and

\item a binary successor \emph{relation}  over  determined by , i.e.



\end{itemize}
where the set  ( is omitted from
 since  is closed) of update sets yielded by
rule  over the state  defines the successor relation  of . A {\em
run} of  is a finite sequence  of states with
, ,  for , and  for
all .


\section{A Logic for DB-ASMs}\label{sec:dtc}

In this section we introduce a logic for DB-ASMs. This logic for DB-ASMs, which we denote as , is built as an extension of the logic  of meta-finite structures used in the formalization of DB-ASMs (see Section~\ref{sec:states}). 

We start with an informal introduction which highlights the main characteristics of  and provides some illustrative examples. Then we proceed to introduce its formal syntax and semantics. 

Same as in the logic of meta-finite structures , in  we distinguish between \emph{database terms} which are interpreted in the finite primary part of the states of DB-ASMs, and \emph{algorithmic terms} which are interpreted in the possible infinite secondary part. The set  of algorithmic terms needs however to be extended with first-order variables which range over the secondary part of the state and with a new kind of term (the -terms). 

\emph{-terms} are terms of the form  where  is a multiset operator,  is a term in ,  is a variable which ranges either over the primary or secondary part of the state, and  is a  formula.  They are interpreted by the value resulting of applying the multiset operator  to the multiset resulting of collecting the values of  under all valuations that satisfy . The need for -terms arises from the fact that DB-ASMs are able to collect updates yielded in parallel computations under the multiset semantics, i.e., update multisets, and then aggregate updates in an update multiset to an update set by using location operators.  

\begin{example}\label{exa:logic-syntax-term}
Consider the relation \textsc{Route} in
Fig.~\ref{fig:initialstate}. The following aggregate
queries are expressible by means of -terms.

\begin{itemize}
  \item Q: Calculate the total number of direct routes.

\begin{center}
    
\end{center}

In an SQL database, Q can be expressed by the following SQL
statement:\smallskip

    \begin{center}
    SELECT (*) FROM \textsc{Route}
    \end{center}

  \item Q: Find the maximum number of direct connections of any city in the database.

\begin{center}
    
\end{center}

In a similar way, Q can be expressed by the following SQL
statement:

\bigskip
          \hspace{1.5cm}SELECT (NumofConnections)

          \hspace{1.5cm}FROM (SELECT Cid, (*) as NumofConnections

                \hspace{2.85cm}FROM \textsc{Route}

                \hspace{2.85cm}GROUP BY Cid)


\end{itemize}

\end{example}

Due to the importance of non-determinism for enhancing the expressive power of database transformations, DB-ASMs include a non-deterministic choice rule. Consequently, it is no longer enough to consider the individual updates associated to the \emph{unique} update set produced by a rule of a deterministic ASM, as it is the case in the logic for ASMs~\cite{RobertLogicASM} of Nanchen and St\"ark. Instead, the logic  needs to be able to describe properties of the different update sets (and multisets) which can be associated to a given DB-ASM rule. That is, the logic  should allow us to handle multiple update sets, since a non-deterministic DB-ASM rule can produce a possible different update set for each of the possible choices.

 A natural and concise way of handling update sets (and multisets) is by means of second-order variables and second-order quantification. We therefore include both in the language of , albeit with a Henkin's semantics instead of the standard Tarski's semantics, so that we can avoid the well known incompleteness result of second-order logic.  
For the same reason we additionally include the multi-modal operator , where  is a second-order variable of arity . The intended meaning of a formula  is that  is true in the state obtained by applying the updates in  to the current state. In turn, to express that  is the update set produced by a rule , we also include atomic formulae of the form  to the language of .  

In order to encode update sets into second-order variables, we need to make some assumptions more precise.

\begin{definition}\label{extendedState}
Given a DB-ASM of some schema , we extend the sub-schema  of the algorithmic part with a new nullary and static function symbol (constant)  for each dynamic function . We assume that in every state , these new constant symbols are interpreted by arbitrary, but pairwise different values. That is, if  and  are among the new constant symbols, then .    

\smallskip

Let  be a state of this extended signature , let  be a variable assignment into , let  be a second-order variable of arity  and let . We say  \emph{represents}  if  constitutes an update set for  and  iff  for some dynamic function  and . 
\end{definition}


As noted earlier, the multiset semantics allows DB-ASMs to collect updates yielded in parallel computations, i.e., update multisets. This multiset semantics is handled via the inclusion of atomic formulae of the form . In this case, the intended meaning is that  is true if  is a second-order variable of arity  which represents an update multiset yielded by the rule . We say that  represents an update multiset  iff for every update  with multiplicity  there are \emph{exactly}  distinct  such that  and vice versa. 

\begin{example}\label{exa:syntaxformulae}
Consider Example~\ref{exa:DBASM-db} and the corresponding DB-ASM depicted in Fig.~\ref{exa:DBASM-code}. Let  denote the main rule of the DB-ASM and  denote one of its states.
The following formulae illustrate how the logic  can be used to express desirable properties of this DB-ASM. 

\begin{description}

\item [1.] If the rule  over  yields an update set  containing an update , then for every neighbour city  of , the (current) shortest distance in state  (calculated by the algorithm) between  and  is no longer \textsc{Infinity}. Representing  by the second-order variable , we obtain:

 \\
\hspace*{5cm}\0.1cm]

\item [3.] If the current state  is not an initial nor a final state and  is an update set yielded by the rule  in , then the value of  in the successor state  equals the distance between  and the closest unvisited (by the algorithm in state ) city. Representing  by the second-order variable  and using a -term with location operator , we obtain:

\\
\hspace*{2.8cm} \val_{S,\zeta}(t)= \rho(\{\!\!\{val_{S,\zeta[v\mapsto a_i]}(t') \mid a_i \in D \text{ and } [\![\varphi]\!]_{S,\zeta[v \mapsto a_i]}=true \}\!\!\}),\{\bar{a} \in A^n \mid [\![\varphi]\!]_{S,\zeta[a_1 \mapsto x_1, \ldots, a_n \mapsto x_n]} = \textit{true}\} \in D_n.S \models \forall X (\mathrm{upd}(r_1,X)\leftrightarrow \mathrm{upd}(r_2,X)).\label{conr}
\text{con}(r,X)\equiv\mathrm{upd}(r,X)\wedge\mathrm{conUSet}(X)
\label{con}
\mathrm{conUSet}(X)\equiv\bigwedge\limits_{c_f\in \mathcal{F}_{\mathit{dyn}} \wedge f \in \Upsilon_{db}} \forall x y z ((X(c_f,x,y) \wedge X(c_f, x, z)) \rightarrow y=z) \wedge \\
\bigwedge\limits_{c_f\in \mathcal{F}_{\mathit{dyn}} \wedge f \in \Upsilon_{a}} \forall \mathtt{x} \mathtt{y} \mathtt{z} ((X(c_f,\mathtt{x},\mathtt{y}) \wedge X(c_f, \mathtt{x}, \mathtt{z})) \rightarrow \mathtt{y}=\mathtt{z}) \wedge \nonumber\\
\bigwedge\limits_{c_f\in \mathcal{F}_{\mathit{dyn}} \wedge f \in {\cal F}_b} \forall x \mathtt{y} \mathtt{z} ((X(c_f,x,\mathtt{y}) \wedge X(c_f, x, \mathtt{z})) \rightarrow \mathtt{y}=\mathtt{z}) \nonumber
\label{wcon}
  \text{wcon}(r)\equiv \exists X (\mathrm{con}(r,X))
\label{scon}
  \text{scon}(r)\equiv \forall X (\text{upd}(r,X)\rightarrow\mathrm{conUSet}(X))

\mathrm{isUSet}(X) \equiv& \forall \mathtt{x}_1 x_2 x_3 \Big(X(\mathtt{x}_1, x_2, x_3) \rightarrow \bigvee_{c_f \in {\cal F}_\mathit{dyn} \wedge f \in \Upsilon_{db}} \mathtt{x}_1 = c_f\Big) \wedge&\\
&\forall \mathtt{x}_1 \mathtt{x}_2 \mathtt{x}_3 \Big(X(\mathtt{x}_1, \mathtt{x}_2, \mathtt{x}_3) \rightarrow \bigvee_{c_f \in {\cal F}_\mathit{dyn} \wedge f \in \Upsilon_{a}} \mathtt{x}_1 = c_f\Big) \wedge&\\
&\forall \mathtt{x}_1 x_2 \mathtt{x}_3 \Big(X(\mathtt{x}_1, x_2, \mathtt{x}_3) \rightarrow \bigvee_{c_f \in {\cal F}_\mathit{dyn} \wedge f \in {\cal F}_{b}} \mathtt{x}_1 = c_f\Big) \wedge&\\
&\forall \mathtt{x}_1 \mathtt{x}_2 x_3( \neg X(\mathtt{x}_1, \mathtt{x}_2, x_3)) \wedge&\\
&\forall x_1 x_2 x_3( \neg X(x_1, x_2, x_3)) \wedge \forall x_1 \mathtt{x}_2 x_3( \neg X(x_1, \mathtt{x}_2, x_3)) \wedge&\\
&\forall x_1 x_2 \mathtt{x}_3( \neg X(x_1, x_2, \mathtt{x}_3)) \wedge \forall x_1 \mathtt{x}_2 \mathtt{x}_3( \neg X(x_1, \mathtt{x}_2, \mathtt{x}_3))&

\textbf{U1.1: } & \text{If} \; f \; \text{is a database function symbol in} \; \Upsilon_{db} \; \text{then}&\\  
&\mathrm{upd}(f(t) := s, X) \leftrightarrow \mathrm{isUSet}(X) \wedge X(c_f, t, s) \wedge&\\
&\qquad \qquad \qquad \qquad \quad \forall \mathtt{x}_1 x_2 x_3 (X(\mathtt{x}_1,x_2,x_3) \rightarrow \mathtt{x}_1 = c_f \wedge x_2 = t \wedge x_3 = s) \wedge&\\
&\qquad \qquad \qquad \qquad \quad \forall \mathtt{x}_1 \mathtt{x}_2 \mathtt{x}_3 (\neg X(\mathtt{x}_1,\mathtt{x}_2,\mathtt{x}_3)) \wedge \forall \mathtt{x}_1 x_2 \mathtt{x}_3 (\neg X(\mathtt{x}_1,x_2,\mathtt{x}_3)) 

\textbf{U1.2: } & \text{If} \; f \; \text{is an algorithmic function symbol in} \; \Upsilon_{a} \; \text{then}&\\  
&\mathrm{upd}(f(t) := s, X) \leftrightarrow \mathrm{isUSet}(X) \wedge X(c_f, t, s) \wedge &\\
&\qquad \qquad \qquad \qquad \quad \forall \mathtt{x}_1 \mathtt{x}_2 \mathtt{x}_3 (X(\mathtt{x}_1,\mathtt{x}_2,\mathtt{x}_3) \rightarrow \mathtt{x}_1 = c_f \wedge \mathtt{x}_2 = t \wedge \mathtt{x}_3 = s) \wedge&\\
&\qquad \qquad \qquad \qquad \quad \forall \mathtt{x}_1 x_2 x_3 (\neg X(\mathtt{x}_1,x_2,x_3)) \wedge \forall \mathtt{x}_1 x_2 \mathtt{x}_3 (\neg X(\mathtt{x}_1,x_2,\mathtt{x}_3)) 

\textbf{U1.3: } & \text{If} \; f \; \text{is a bridge function symbol in} \; {\cal F}_b \; \text{then}&\\  
&\mathrm{upd}(f(t) := s, X) \leftrightarrow \mathrm{isUSet}(X) \wedge X(c_f, t, s) \wedge &\\
&\qquad \qquad \qquad \qquad \quad \forall \mathtt{x}_1 x_2 \mathtt{x}_3 (X(\mathtt{x}_1,x_2,\mathtt{x}_3) \rightarrow \mathtt{x}_1 = c_f \wedge x_2 = t \wedge \mathtt{x}_3 = s) \wedge&\\
&\qquad \qquad \qquad \qquad \quad \forall \mathtt{x}_1 x_2 x_3 (\neg X(\mathtt{x}_1,x_2,x_3)) \wedge \forall \mathtt{x}_1 \mathtt{x}_2 \mathtt{x}_3 (\neg X(\mathtt{x}_1,\mathtt{x}_2,\mathtt{x}_3))& 

\textbf{U2: } \mathrm{upd}(\textbf{if} \, \varphi \, \textbf{then}\, r \, \textbf{endif}, &X) \leftrightarrow (\varphi \wedge \mathrm{upd}(r,X)) \vee &\\
& \big(\neg \varphi \wedge \mathrm{isUSet}(X) \wedge \forall \mathtt{x}_1 x_2 x_3 (\neg X(\mathtt{x}_1,x_2,x_3)) \wedge &\\
&\quad \forall \mathtt{x}_1 \mathtt{x}_2 \mathtt{x}_3 (\neg X(\mathtt{x}_1,\mathtt{x}_2,\mathtt{x}_3)) \wedge \forall \mathtt{x}_1 x_2 \mathtt{x}_3 (\neg X(\mathtt{x}_1,x_2,\mathtt{x}_3))\big) &

\textbf{U3: } &\mathrm{upd}(\textbf{forall} \, x \, \textbf{with} \, \varphi \, \textbf{do} \, r \, \textbf{enddo},X) \leftrightarrow \mathrm{isUSet}(X)\wedge&\\
&\exists Y \big(\forall \mathtt{z} y_1 y_2 (X(\mathtt{z},y_1,y_2) \leftrightarrow \exists x (Y(\mathtt{z},y_1,y_2,x))) \wedge&\\
& \hspace*{0.65cm} \forall \mathtt{z} \mathtt{y}_1 \mathtt{y}_2 (X(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2) \leftrightarrow \exists x(Y(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2,x))) \wedge&\\
& \hspace*{0.65cm} \forall \mathtt{z} y_1 \mathtt{y}_2 (X(\mathtt{z},y_1,\mathtt{y}_2) \leftrightarrow \exists x (Y(\mathtt{z},y_1,\mathtt{y}_2,x))) \wedge&\\
& \hspace*{0.65cm} \forall x \big( (\varphi \rightarrow \exists Z (\mathrm{upd}(r,Z) \wedge&\\
&\qquad\qquad\qquad\qquad \forall \mathtt{z} y_1 y_2 (Z(\mathtt{z},y_1,y_2) \leftrightarrow Y(\mathtt{z},y_1,y_2,x)) \wedge&\\
&\qquad\qquad\qquad\qquad \forall \mathtt{z} \mathtt{y}_1 \mathtt{y}_2 (Z(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2) \leftrightarrow Y(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2,x)) \wedge&\\
&\qquad\qquad\qquad\qquad \forall \mathtt{z} y_1 \mathtt{y}_2 (Z(\mathtt{z},y_1,\mathtt{y}_2) \leftrightarrow Y(\mathtt{z},y_1,\mathtt{y}_2,x)))) \wedge&\\
& \hspace*{1.3cm} (\neg \varphi \rightarrow \forall \mathtt{z} y_1 y_2 (\neg Y(\mathtt{z},y_1,y_2,x)) \wedge&\\
&\quad\qquad\qquad\qquad \forall \mathtt{z} \mathtt{y}_1 \mathtt{y}_2 (\neg Y(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2,x)) \wedge&\\
&\quad\qquad\qquad\qquad \forall \mathtt{z} y_1 \mathtt{y}_2 (\neg Y(\mathtt{z},y_1,\mathtt{y}_2,x)))\big)\big)

\textbf{U4: } \mathrm{upd}(\textbf{par} \, r_1 \; r_2 \,& \textbf{endpar}, X) \leftrightarrow \mathrm{isUSet}(X) \wedge&\\
&\exists Y_1 Y_2 \big(\mathrm{upd}(r_1,Y_1) \wedge \mathrm{upd}(r_2,Y_2) \wedge&\\
&\qquad \quad \forall \mathtt{z} y_1 y_2 (X(\mathtt{z},y_1,y_2) \leftrightarrow (Y_1(\mathtt{z},y_1,y_2) \vee Y_2(\mathtt{z},y_1,y_2))) \wedge&\\
&\qquad \quad \forall \mathtt{z} \mathtt{y}_1 \mathtt{y}_2 (X(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2) \leftrightarrow (Y_1(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2) \vee Y_2(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2))) \wedge&\\
&\qquad \quad \forall \mathtt{z} y_1 \mathtt{y}_2 (X(\mathtt{z},y_1,\mathtt{y}_2) \leftrightarrow (Y_1(\mathtt{z},y_1,\mathtt{y}_2) \vee Y_2(\mathtt{z},y_1,\mathtt{y}_2))) \big)&

\textbf{U5: }&\mathrm{upd}(\textbf{choose}\, x \, \textbf{with} \, \varphi \, \textbf{do} \, r \, \textbf{enddo}, X) \leftrightarrow \exists x (\varphi \wedge \mathrm{upd}(r,X))&

\textbf{U6: }&\mathrm{upd}(\textbf{seq} \, r_1 \; r_2 \, \textbf{endseq}, X) \leftrightarrow \big(\text{upd}(r_1,X) \wedge \neg\mathrm{conUSet}(X)\big) \vee&\\
& \big( \mathit{isUSet}(X) \wedge &\\
& \exists Y_1 Y_2 (\mathrm{upd}(r_1,Y_1) \wedge \mathrm{conUSet}(Y_1) \wedge [Y_1]\mathrm{upd}(r_2,Y_2) \wedge&\\
& \hspace*{0.3cm} \forall \mathtt{z} y_1 y_2 (X(\mathtt{z},y_1,y_2) \leftrightarrow ( (Y_1(\mathtt{z},y_1,y_2) \wedge \forall x (\neg Y_2(\mathtt{z}, y_1, x))) \vee Y_2(\mathtt{z},y_1,y_2))) \wedge&\\
& \hspace*{0.3cm} \forall \mathtt{z} \mathtt{y}_1 \mathtt{y}_2 (X(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2) \leftrightarrow ( (Y_1(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2) \wedge \forall \mathtt{x} (\neg Y_2(\mathtt{z}, \mathtt{y}_1, \mathtt{x}))) \vee Y_2(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2))) \wedge&\\
& \hspace*{0.3cm} \forall \mathtt{z} y_1 \mathtt{y}_2 (X(\mathtt{z},y_1,\mathtt{y}_2) \leftrightarrow ( (Y_1(\mathtt{z},y_1,\mathtt{y}_2) \wedge \forall \mathtt{x} (\neg Y_2(\mathtt{z}, y_1, \mathtt{x}))) \vee Y_2(\mathtt{z},y_1,\mathtt{y}_2))) )\big)

\textbf{U7.1: } & \text{If} \; f \; \text{is an algorithmic function symbol in} \; \Upsilon_a \; \text{then}&\\  
& \mathrm{upd}(\textbf{let} \, (f,t)\!\rightharpoonup\!\rho \, \textbf{in} \, r \,\textbf{endlet},X) \leftrightarrow \mathrm{isUSet}(X) \wedge \exists Y \big(\mathrm{upm}(r,Y) \wedge&\\
&\forall \mathtt{x}_1 \mathtt{x}_2 \mathtt{x}_3 \big(X(\mathtt{x}_1,\mathtt{x}_2,\mathtt{x}_3) \leftrightarrow \big(((\mathtt{x}_1 \neq c_f \vee t \neq \mathtt{x}_2) \wedge \exists \mathtt{z} (Y(\mathtt{x}_1,\mathtt{x}_2,\mathtt{x}_3,\mathtt{z}))) \vee &\\
&\hspace*{3.1cm}(\mathtt{x}_1 = c_f \wedge \mathtt{x}_2 = t \wedge \mathtt{x}_3=\rho_{\mathtt{y}}(\mathtt{y}|\exists \mathtt{z} (Y(\mathtt{x}_1,\mathtt{x}_2,\mathtt{y},\mathtt{z}))))\big)\big) \wedge&\\
&\forall \mathtt{x}_1 x_2 \mathtt{x}_3 \big(X(\mathtt{x}_1,x_2,\mathtt{x}_3) \leftrightarrow \exists \mathtt{z} (Y(\mathtt{x}_1,x_2,\mathtt{x}_3,\mathtt{z}))\big) \wedge &\\
&\forall \mathtt{x}_1 x_2 x_3 \big(X(\mathtt{x}_1,x_2,x_3) \leftrightarrow \exists \mathtt{z} (Y(\mathtt{x}_1,x_2,x_3,\mathtt{z}))\big)\big) &

\textbf{U7.2: } & \text{If} \; f \; \text{is a bridge function symbol in} \; {\cal F}_b \; \text{then}&\\  
& \mathrm{upd}(\textbf{let} \, (f,t)\!\rightharpoonup\!\rho \, \textbf{in} \, r \,\textbf{endlet},X) \leftrightarrow \mathrm{isUSet}(X) \wedge \exists Y \big(\mathrm{upm}(r,Y) \wedge&\\
&\forall \mathtt{x}_1 x_2 \mathtt{x}_3 \big(X(\mathtt{x}_1,x_2,\mathtt{x}_3) \leftrightarrow \big(((\mathtt{x}_1 \neq c_f \vee t \neq x_2) \wedge \exists \mathtt{z} (Y(\mathtt{x}_1,x_2,\mathtt{x}_3,\mathtt{z}))) \vee &\\
&\hspace*{3.1cm}(\mathtt{x}_1 = c_f \wedge x_2 = t \wedge \mathtt{x}_3=\rho_{\mathtt{y}}(\mathtt{y}|\exists \mathtt{z} (Y(\mathtt{x}_1,x_2,\mathtt{y},\mathtt{z}))))\big)\big) \wedge&\\
&\forall \mathtt{x}_1 \mathtt{x}_2 \mathtt{x}_3 \big(X(\mathtt{x}_1,\mathtt{x}_2,\mathtt{x}_3) \leftrightarrow \exists \mathtt{z} (Y(\mathtt{x}_1,\mathtt{x}_2,\mathtt{x}_3,\mathtt{z}))\big) \wedge &\\
&\forall \mathtt{x}_1 x_2 x_3 \big(X(\mathtt{x}_1,x_2,x_3) \leftrightarrow \exists \mathtt{z} (Y(\mathtt{x}_1,x_2,x_3,\mathtt{z}))\big)\big) &

\mathrm{is\ddot{U}Set}(X) \equiv& \forall \mathtt{x}_1 x_2 x_3 \mathtt{x}_4 \Big(X(\mathtt{x}_1, x_2, x_3, \mathtt{x}_4) \rightarrow \bigvee_{c_f \in {\cal F}_\mathit{dyn} \wedge f \in \Upsilon_{db}} \mathtt{x}_1 = c_f\Big) \wedge&\\
&\forall \mathtt{x}_1 \mathtt{x}_2 \mathtt{x}_3 \mathtt{x}_4 \Big(X(\mathtt{x}_1, \mathtt{x}_2, \mathtt{x}_3, \mathtt{x}_4) \rightarrow \bigvee_{c_f \in {\cal F}_\mathit{dyn} \wedge f \in \Upsilon_{a}} \mathtt{x}_1 = c_f\Big) \wedge&\\
&\forall \mathtt{x}_1 x_2 \mathtt{x}_3 \mathtt{x}_4 \Big(X(\mathtt{x}_1, x_2, \mathtt{x}_3, \mathtt{x}_4) \rightarrow \bigvee_{c_f \in {\cal F}_\mathit{dyn} \wedge f \in {\cal F}_{b}} \mathtt{x}_1 = c_f\Big) \wedge&\\
&\forall \mathtt{x}_1 \mathtt{x}_2 x_3 \mathtt{x}_4(\neg X(\mathtt{x}_1, \mathtt{x}_2, x_3, \mathtt{x}_4)) \wedge \forall \mathtt{x}_1 \mathtt{x}_2 x_3 x_4(\neg X(\mathtt{x}_1, \mathtt{x}_2, x_3, x_4)) \wedge&\\
&\forall x_1 x_2 x_3 \mathtt{x}_4 ( \neg X(x_1, x_2, x_3, \mathtt{x}_4)) \wedge \forall x_1 \mathtt{x}_2 x_3 \mathtt{x}_4( \neg X(x_1, \mathtt{x}_2, x_3, \mathtt{x}_4)) \wedge&\\
&\forall x_1 x_2 x_3 x_4 ( \neg X(x_1, x_2, x_3, x_4)) \wedge \forall x_1 \mathtt{x}_2 x_3 x_4( \neg X(x_1, \mathtt{x}_2, x_3, x_4)) \wedge&\\
&\forall x_1 x_2 \mathtt{x}_3 \mathtt{x}_4 ( \neg X(x_1, x_2, \mathtt{x}_3, \mathtt{x}_4)) \wedge \forall x_1 \mathtt{x}_2 \mathtt{x}_3 \mathtt{x}_4 ( \neg X(x_1, \mathtt{x}_2, \mathtt{x}_3, \mathtt{x}_4))\wedge&\\
&\forall x_1 x_2 \mathtt{x}_3 x_4 ( \neg X(x_1, x_2, \mathtt{x}_3, x_4)) \wedge \forall x_1 \mathtt{x}_2 \mathtt{x}_3 x_4 ( \neg X(x_1, \mathtt{x}_2, \mathtt{x}_3, x_4))&

\mathbf{\ddot{U}1.1}\textbf{: } & \text{If} \; f \; \text{is a database function symbol in} \; \Upsilon_{db} \; \text{then}&\\  
&\mathrm{upm}(f(t) := s, X) \leftrightarrow \mathrm{is\ddot{U}Set}(X) \wedge \exists \mathtt{z} \big(X(c_f, t, s, \mathtt{z}) \wedge &\\
&\qquad \forall \mathtt{x}_1 x_2 x_3 \mathtt{x}_4 (X(\mathtt{x}_1,x_2,x_3, \mathtt{x}_4) \rightarrow \mathtt{x}_1 = c_f \wedge x_2 = t \wedge x_3 = s \wedge \mathtt{x}_4 = \mathtt{z})\big) \wedge&\\
&\qquad \forall \mathtt{x}_1 \mathtt{x}_2 \mathtt{x}_3 \mathtt{x}_4 (\neg X(\mathtt{x}_1,\mathtt{x}_2,\mathtt{x}_3,\mathtt{x}_4)) \wedge \forall \mathtt{x}_1 x_2 \mathtt{x}_3 \mathtt{x}_4(\neg X(\mathtt{x}_1,x_2,\mathtt{x}_3,\mathtt{x}_4)) 

\mathbf{\ddot{U}1.2}\textbf{: } & \text{If} \; f \; \text{is an algorithmic function symbol in} \; \Upsilon_{a} \; \text{then}&\\  
&\mathrm{upm}(f(t) := s, X) \leftrightarrow \mathrm{is\ddot{U}Set}(X) \wedge \exists \mathtt{z} \big(X(c_f, t, s, \mathtt{z}) \wedge &\\
&\qquad \forall \mathtt{x}_1 \mathtt{x}_2 \mathtt{x}_3 \mathtt{x}_4 (X(\mathtt{x}_1,\mathtt{x}_2,\mathtt{x}_3,\mathtt{x}_4) \rightarrow \mathtt{x}_1 = c_f \wedge \mathtt{x}_2 = t \wedge \mathtt{x}_3 = s \wedge \mathtt{x}_4 = \mathtt{z})\big) \wedge&\\
&\qquad \forall \mathtt{x}_1 x_2 x_3 \mathtt{x}_4 (\neg X(\mathtt{x}_1,x_2,x_3,\mathtt{x}_4)) \wedge \forall \mathtt{x}_1 x_2 \mathtt{x}_3 \mathtt{x}_4 (\neg X(\mathtt{x}_1,x_2,\mathtt{x}_3,\mathtt{x}_4)) 

\mathbf{\ddot{U}1.3}\textbf{: }  & \text{If} \; f \; \text{is a bridge function symbol in} \; {\cal F}_b \; \text{then}&\\  
&\mathrm{upm}(f(t) := s, X) \leftrightarrow \mathrm{is\ddot{U}Set}(X) \wedge \exists \mathtt{z} \big(X(c_f, t, s, \mathtt{z}) \wedge&\\
&\qquad \forall \mathtt{x}_1 x_2 \mathtt{x}_3 \mathtt{x}_4 (X(\mathtt{x}_1,x_2,\mathtt{x}_3,\mathtt{x}_4) \rightarrow \mathtt{x}_1 = c_f \wedge x_2 = t \wedge \mathtt{x}_3 = s \wedge \mathtt{x}_4 = \mathtt{z})\big) \wedge&\\
&\qquad \forall \mathtt{x}_1 x_2 x_3 \mathtt{x}_4 (\neg X(\mathtt{x}_1,x_2,x_3,\mathtt{x}_4)) \wedge \forall \mathtt{x}_1 \mathtt{x}_2 \mathtt{x}_3 \mathtt{x}_4 (\neg X(\mathtt{x}_1,\mathtt{x}_2,\mathtt{x}_3,\mathtt{x}_4))& 

\mathbf{\ddot{U}2}\textbf{: } \mathrm{upm}(\textbf{if} \, \varphi \,& \textbf{then} \, r \, \textbf{endif}, X) \leftrightarrow (\varphi \wedge \mathrm{upm}(r,X)) \vee &\\
& \big(\neg \varphi \wedge \mathrm{is\ddot{U}Set}(X) \wedge \forall \mathtt{x}_1 x_2 x_3 \mathtt{x}_4 (\neg X(\mathtt{x}_1,x_2,x_3, \mathtt{x}_4)) \wedge &\\
&\quad \forall \mathtt{x}_1 \mathtt{x}_2 \mathtt{x}_3 \mathtt{x}_4 (\neg X(\mathtt{x}_1,\mathtt{x}_2,\mathtt{x}_3, \mathtt{x}_4)) \wedge \forall \mathtt{x}_1 x_2 \mathtt{x}_3 \mathtt{x}_4(\neg X(\mathtt{x}_1,x_2,\mathtt{x}_3, \mathtt{x}_4))\big) &

\mathbf{\ddot{U}3}\textbf{: } &\mathrm{upm}(\textbf{forall} \, x \, \textbf{with} \, \varphi \, \textbf{do} \, r \, \textbf{enddo},X) \leftrightarrow \mathrm{is\ddot{U}Set}(X)\wedge&\\
&\exists Y F \big(\text{`` is a bijection from  to ''} \wedge &\\
&\qquad \quad \forall \mathtt{z} y_1 y_2 \mathtt{y}_3 \mathtt{z}' y_1' y_2' \mathtt{y}_3' x (F(\mathtt{z},y_1,y_2,\mathtt{y}_3, \mathtt{z}',y_1',y_2',\mathtt{y}_3',x) \rightarrow&\\
& \hspace*{7cm} (\mathtt{z} = \mathtt{z}' \wedge y_1 = y_1' \wedge  y_2 = y_2')) \wedge&\\
& \qquad \quad \forall \mathtt{z} \mathtt{y}_1 \mathtt{y}_2 \mathtt{y}_3 \mathtt{z}' \mathtt{y}_1' \mathtt{y}_2' \mathtt{y}_3' x (F(\mathtt{z}, \mathtt{y}_1, \mathtt{y}_2, \mathtt{y}_3, \mathtt{z}', \mathtt{y}_1', \mathtt{y}_2', \mathtt{y}_3', x) \rightarrow&\\
& \hspace*{7cm} (\mathtt{z} = \mathtt{z}' \wedge \mathtt{y}_1 = \mathtt{y}_1' \wedge  \mathtt{y}_2 = \mathtt{y}_2')) \wedge&\\
& \qquad \quad \forall \mathtt{z} y_1 \mathtt{y}_2 \mathtt{y}_3 \mathtt{z}' y_1' \mathtt{y}_2' \mathtt{y}_3' x (F(\mathtt{z}, y_1, \mathtt{y}_2, \mathtt{y}_3, \mathtt{z}', y_1', \mathtt{y}_2', \mathtt{y}_3', x) \rightarrow&\\
& \hspace*{7cm} (\mathtt{z} = \mathtt{z}' \wedge y_1 = y_1' \wedge  \mathtt{y}_2 = \mathtt{y}_2')) \wedge&\\
& \qquad \quad \forall x \big( (\varphi \rightarrow \exists Z (\mathrm{upm}(r,Z) \wedge&\\
&\quad\qquad\qquad\qquad\qquad \forall \mathtt{z} y_1 y_2 \mathtt{y}_3 (Z(\mathtt{z},y_1,y_2,\mathtt{y}_3) \leftrightarrow Y(\mathtt{z},y_1,y_2,\mathtt{y}_3,x)) \wedge&\\
&\quad\qquad\qquad\qquad\qquad \forall \mathtt{z} \mathtt{y}_1 \mathtt{y}_2 \mathtt{y}_3 (Z(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2, \mathtt{y}_3) \leftrightarrow Y(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2, \mathtt{y}_3, x)) \wedge&\\
&\quad\qquad\qquad\qquad\qquad \forall \mathtt{z} y_1 \mathtt{y}_2 \mathtt{y}_3 (Z(\mathtt{z},y_1,\mathtt{y}_2,\mathtt{y}_3) \leftrightarrow Y(\mathtt{z},y_1,\mathtt{y}_2,\mathtt{y}_3,x)))) \wedge&\\
& \qquad \qquad \quad (\neg \varphi \rightarrow \forall \mathtt{z} y_1 y_2 \mathtt{y}_3 (\neg Y(\mathtt{z},y_1,y_2,\mathtt{y}_3,x)) \wedge&\\
&\qquad\qquad\qquad\qquad\; \forall \mathtt{z} \mathtt{y}_1 \mathtt{y}_2 \mathtt{y}_3 (\neg Y(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2,\mathtt{y}_3,x)) \wedge&\\
&\qquad\qquad\qquad\qquad\; \forall \mathtt{z} y_1 \mathtt{y}_2 \mathtt{y}_3 (\neg Y(\mathtt{z},y_1,\mathtt{y}_2,\mathtt{y}_3, x)))\big)\big)

\mathbf{\ddot{U}4}\textbf{: } &\mathrm{upm}(\textbf{par} \, r_1 \; r_2 \, \textbf{endpar}, X) \leftrightarrow \mathrm{is\ddot{U}Set}(X) \wedge&\\
&\exists Y_1 Y_2 \big(\mathrm{upm}(r_1,Y_1) \wedge \mathrm{upm}(r_2,Y_2) \wedge&\\
&\quad \qquad\forall \mathtt{z} y_1 y_2 \mathtt{y}_3 \mathtt{z}' y_1' y_2' \mathtt{y}_3' (Y_1(\mathtt{z},y_1,y_2, \mathtt{y}_3) \wedge Y_2(\mathtt{z}',y_1',y_2',\mathtt{y}_3') \rightarrow \mathtt{y}_3 \neq \mathtt{y}_3') \wedge&\\
&\quad \qquad\forall \mathtt{z} \mathtt{y}_1 \mathtt{y}_2 \mathtt{y}_3 \mathtt{z}' \mathtt{y}_1' \mathtt{y}_2' \mathtt{y}_3' (Y_1(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2, \mathtt{y}_3) \wedge Y_2(\mathtt{z}',\mathtt{y}_1',\mathtt{y}_2',\mathtt{y}_3') \rightarrow \mathtt{y}_3 \neq \mathtt{y}_3') \wedge&\\
&\quad \qquad\forall \mathtt{z} y_1 \mathtt{y}_2 \mathtt{y}_3 \mathtt{z}' y_1' \mathtt{y}_2' \mathtt{y}_3' (Y_1(\mathtt{z},y_1,\mathtt{y}_2, \mathtt{y}_3) \wedge Y_2(\mathtt{z}',y_1',\mathtt{y}_2',\mathtt{y}_3') \rightarrow \mathtt{y}_3 \neq \mathtt{y}_3') \wedge&\\
&\qquad \quad \forall \mathtt{z} y_1 y_2 \mathtt{y}_3 (X(\mathtt{z},y_1,y_2, \mathtt{y}_3) \leftrightarrow (Y_1(\mathtt{z},y_1,y_2, \mathtt{y}_3) \vee Y_2(\mathtt{z},y_1,y_2,\mathtt{y}_3))) \wedge&\\
&\qquad \quad \forall \mathtt{z} \mathtt{y}_1 \mathtt{y}_2 \mathtt{y}_3 (X(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2, \mathtt{y}_3) \leftrightarrow (Y_1(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2, \mathtt{y}_3) \vee Y_2(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2, \mathtt{y}_3))) \wedge&\\
&\qquad \quad \forall \mathtt{z} y_1 \mathtt{y}_2 \mathtt{y}_3 (X(\mathtt{z},y_1,\mathtt{y}_2, \mathtt{y}_3) \leftrightarrow (Y_1(\mathtt{z},y_1,\mathtt{y}_2, \mathtt{y}_3) \vee Y_2(\mathtt{z},y_1,\mathtt{y}_2, \mathtt{y}_3))) \big)&

\mathbf{\ddot{U}5}\textbf{: }&\mathrm{upm}(\textbf{choose}\, x \, \textbf{with} \, \varphi \, \textbf{do} \, r \, \textbf{enddo}, X) \leftrightarrow \exists x (\varphi \wedge \mathrm{upm}(r,X))&

\mathbf{\ddot{U}6}\textbf{: }&\mathrm{upm}(\textbf{seq} \, r_1 \; r_2 \, \textbf{endseq}, X) \leftrightarrow \big(\text{upm}(r_1,X) \wedge \neg\mathrm{con\ddot{U}Set}(X)\big) \vee&\\
& \big( \mathrm{is\ddot{U}Set}(X) \wedge &\\
& \exists Y_1 Y_1' Y_2 \big(\mathrm{upm}(r_1,Y_1) \wedge \mathrm{con\ddot{U}Set}(Y_1) \wedge \textrm{isUSet}(Y_1') \wedge [Y_1']\mathrm{upm}(r_2,Y_2) \wedge&\\
& \forall \mathtt{z} y_1 y_2 (Y_1'(\mathtt{z},y_1,y_2) \leftrightarrow \exists \mathtt{y}_3 (Y_1(\mathtt{z},y_1,y_2,\mathtt{y}_3))) \wedge&\\
& \forall \mathtt{z} \mathtt{y}_1 \mathtt{y}_2 (Y_1'(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2) \leftrightarrow \exists \mathtt{y}_3 (Y_1(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2, \mathtt{y}_3))) \wedge&\\
& \forall \mathtt{z} y_1 \mathtt{y}_2 (Y_1'(\mathtt{z},y_1,\mathtt{y}_2) \leftrightarrow \exists \mathtt{y}_3 (Y_1(\mathtt{z},y_1,\mathtt{y}_2, \mathtt{y}_3))) \wedge &\\
& \forall \mathtt{z} y_1 y_2 \mathtt{y}_3(X(\mathtt{z},y_1,y_2,\mathtt{y_3}) \leftrightarrow ( (Y_1(\mathtt{z},y_1,y_2,\mathtt{y}_3) \wedge \forall x_1 \mathtt{x}_2 (\neg Y_2(\mathtt{z}, y_1, x_1, \mathtt{x}_2))) \vee&\\
&\hspace*{4.6cm} Y_2(\mathtt{z},y_1,y_2, \mathtt{y}_3))) \wedge&\\
& \forall \mathtt{z} \mathtt{y}_1 \mathtt{y}_2 \mathtt{y}_3 (X(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2, \mathtt{y}_3) \leftrightarrow ( (Y_1(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2, \mathtt{y}_3) \wedge \forall \mathtt{x}_1 \mathtt{x}_2 (\neg Y_2(\mathtt{z}, \mathtt{y}_1, \mathtt{x}_1, \mathtt{x}_2))) \vee &\\
&\hspace*{4.6cm} Y_2(\mathtt{z},\mathtt{y}_1,\mathtt{y}_2, \mathtt{y}_3))) \wedge&\\
& \forall \mathtt{z} y_1 \mathtt{y}_2 \mathtt{y}_3 (X(\mathtt{z},y_1,\mathtt{y}_2,\mathtt{y}_3) \leftrightarrow ( (Y_1(\mathtt{z},y_1,\mathtt{y}_2,\mathtt{y}_3) \wedge \forall \mathtt{x}_1 \mathtt{x}_2 (\neg Y_2(\mathtt{z}, y_1, \mathtt{x}_1, \mathtt{x}_2))) \vee&\\
& \hspace*{4.6cm} Y_2(\mathtt{z},y_1,\mathtt{y}_2, \mathtt{y}_3))) \big)\big)

\mathbf{\ddot{U}7.1}\textbf{: } & \text{If} \; f \; \text{is an algorithmic function symbol in} \; \Upsilon_a \; \text{then}&\\  
& \mathrm{upm}(\textbf{let} \, (f,t)\!\rightharpoonup\!\rho \, \textbf{in} \, r \,\textbf{endlet},X) \leftrightarrow \mathrm{is\ddot{U}Set}(X) \wedge \exists Y \mathtt{z} \big(\mathrm{upm}(r,Y) \wedge&\\
&\forall \mathtt{x}_1 \mathtt{x}_2 \mathtt{x}_3 \mathtt{x}_4 \big(X(\mathtt{x}_1,\mathtt{x}_2,\mathtt{x}_3,\mathtt{x}_4) \leftrightarrow \big(((\mathtt{x}_1 \neq c_f \vee t \neq \mathtt{x}_2) \wedge Y(\mathtt{x}_1,\mathtt{x}_2,\mathtt{x}_3,\mathtt{x}_4)) \vee &\\
&\hspace*{1.6cm}(\mathtt{x}_1 = c_f \wedge \mathtt{x}_2 = t \wedge \mathtt{x}_3=\rho_{\mathtt{y}}(\mathtt{y}|\exists \mathtt{x}_0 (Y(\mathtt{x}_1,\mathtt{x}_2,\mathtt{y},\mathtt{x}_0))) \wedge \mathtt{x}_4 = \mathtt{z})\big)\big) \wedge&\\
&\forall \mathtt{x}_1 x_2 \mathtt{x}_3 \mathtt{x}_4 \big(X(\mathtt{x}_1,x_2,\mathtt{x}_3, \mathtt{x}_4) \leftrightarrow Y(\mathtt{x}_1,x_2,\mathtt{x}_3,\mathtt{x}_4)\big) \wedge &\\
&\forall \mathtt{x}_1 x_2 x_3 \mathtt{x}_4 \big(X(\mathtt{x}_1,x_2,x_3, \mathtt{x}_4) \leftrightarrow Y(\mathtt{x}_1,x_2,x_3,\mathtt{x}_4)\big)\big) &

\mathbf{\ddot{U}7.2} \textbf{: } & \text{If} \; f \; \text{is a bridge function symbol in} \; {\cal F}_b \; \text{then}&\\
& \mathrm{upm}(\textbf{let} \, (f,t)\!\rightharpoonup\!\rho \, \textbf{in} \, r \,\textbf{endlet},X) \leftrightarrow \mathrm{is\ddot{U}Set}(X) \wedge \exists Y \mathtt{z} \big(\mathrm{upm}(r,Y) \wedge&\\
&\forall \mathtt{x}_1 x_2 \mathtt{x}_3 \mathtt{x}_4 \big(X(\mathtt{x}_1,x_2,\mathtt{x}_3,\mathtt{x}_4) \leftrightarrow \big(((\mathtt{x}_1 \neq c_f \vee t \neq x_2) \wedge Y(\mathtt{x}_1,x_2,\mathtt{x}_3,\mathtt{x}_4)) \vee &\\
&\hspace*{1.6cm}(\mathtt{x}_1 = c_f \wedge x_2 = t \wedge \mathtt{x}_3=\rho_{\mathtt{y}}(\mathtt{y}|\exists \mathtt{x}_0 (Y(\mathtt{x}_1,x_2,\mathtt{y},\mathtt{x}_0))) \wedge \mathtt{x}_4 = \mathtt{z})\big)\big) \wedge&\\
&\forall \mathtt{x}_1 \mathtt{x}_2 \mathtt{x}_3 \mathtt{x}_4 \big(X(\mathtt{x}_1,\mathtt{x}_2,\mathtt{x}_3, \mathtt{x}_4) \leftrightarrow Y(\mathtt{x}_1,\mathtt{x}_2,\mathtt{x}_3,\mathtt{x}_4)\big) \wedge &\\
&\forall \mathtt{x}_1 x_2 x_3 \mathtt{x}_4 \big(X(\mathtt{x}_1,x_2,x_3, \mathtt{x}_4) \leftrightarrow Y(\mathtt{x}_1,x_2,x_3,\mathtt{x}_4)\big)\big) &
\label{ASM1}
[r]\varphi \equiv \forall X (\text{upd}(r,X)\rightarrow[X]\varphi).
\label{ASM2}
\langle r\rangle\varphi \equiv\exists
X (\text{upd}(r,X)\wedge[X]\varphi).
0.2cm]
The update multiset is collapsed into the update set , whereas without the \textbf{let} rule we would obtain .

\end{example}

Following the approach of defining the predicate joinable in
\cite{RobertLogicASM}, we define the predicate joinable over two
DB-ASM rules. As DB-ASM rules are allowed to be nondeterministic,
the predicate joinable means that there exists a pair of
update sets without conflicting updates, which are yielded by rules
 and , respectively. Then, based on the use of predicate
joinable, the properties in Lemma \ref{lem-soundness-consistency}
are all derivable.



\begin{lemma}\label{lem-soundness-consistency}
The following properties for weak consistency are derivable in the
logic of DB-ASMs.
\begin{description}
  \item[(i)] 

  \item[(j)] 

  \item[(k)] \\
    \hspace*{4.5cm}
\item[(l)] 
  \item[(m)] 
  \item[(n)] 
  \item[(o)] If  is a bridge function symbol: \\
\\
\hspace*{1.3cm}\\
\hspace*{2cm}   
\end{description}
\end{lemma}
We omit the proof of the previous lemma as well as the proof of the remaining lemmas in this section, since they are lengthy but relatively easy exercises. Furthermore, most of them are similar to the proofs of the analogous results in Nanchen's thesis \cite{Nanchen07}. 

\begin{lemma}\label{lem-soundness-rule}The following properties for the formula  are derivable in the logic for DB-ASMs.
\begin{description}
  \item[(p)] \smallskip
  \item[(q)] \smallskip
\end{description}
\end{lemma}
\iffalse
\begin{proof} They can be proven as follows.
\begin{itemize}
  \item (p): By Equation~\ref{ASM1}, . Then by Axiom
  \textbf{U2}, we have [\textbf{if}  \textbf{then} 
  \textbf{endif}]upd(.
  By , we have [\textbf{if}  \textbf{then} 
  \textbf{endif}]upd(.
  \item (q): Using the same approach as in the
  proof for (p), by Equation \ref{ASM1}, we have [\textbf{choose}  \textbf{with}  \textbf{do} 
  \textbf{enddo}]upd(\textbf{choose}  \textbf{with}  \textbf{do} 
  \textbf{enddo},. Then by Axiom
  \textbf{U5}, we have [\textbf{choose}  \textbf{with}  \textbf{do} 
  \textbf{enddo}](def(\textbf{choose}
 \textbf{with}  \textbf{do} 
  \textbf{enddo})  upd. Then by Axiom
  \textbf{D5}, we have [\textbf{choose}  \textbf{with}  \textbf{do} 
  \textbf{enddo}] upd. Then by the axiom schemes \textbf{P1}- \textbf{P3} from classical logic, we would have  and can thus prove that [\textbf{choose}  \textbf{with}  \textbf{do} 
  \textbf{enddo}].
\end{itemize}
\end{proof}
\fi
Lemma \ref{lem-soundness-composition} states that a parallel
composition is commutative and associative while a sequential
composition is associative.

\begin{lemma}\label{lem-soundness-composition}The following properties for parallel and sequential compositions are derivable in the logic for DB-ASMs.
\begin{description}
  \item[(r)] \textbf{par}  \textbf{endpar}  \textbf{par}  \textbf{endpar}\smallskip
  \item[(s)] \textbf{par} (\textbf{par}  \textbf{endpar})  \textbf{endpar}  \textbf{par}  (\textbf{par} 
  \textbf{endpar}) \textbf{endpar}\smallskip
  \item[(t)] \textbf{seq} (\textbf{seq}  \textbf{endseq})  \textbf{endseq}  \textbf{seq}  (\textbf{seq} 
  \textbf{endseq}) \textbf{endseq}\smallskip
\end{description}
\end{lemma}

\begin{lemma}The extensionality axiom for transition rules in the logic for ASMs~\cite{RobertLogicASM} is derivable in the logic for DB-ASMs.
\begin{description}

\item[(u)] 
\end{description}
\end{lemma}

\section{Completeness}\label{sec:completeness}

In this section we prove the completeness of the proof system of the logic  for DB-ASMs which we introduced in the previous section.

In the following,  denotes an arbitrary Henkin meta-finite structure of signature (of meta-finite states)  (recall Definition~\ref{HenkinStructure}. As before,  denotes the base set (domain) of individual of , where  and  are the base sets of the database and algorithmic parts, respectively, and  the universe of -ary relations. 

Clearly, we cannot axiomatize an arbitrary set  of location operators. Note that even if we just take a simple location operator such as  and axiomatize it, that leads us outside linear arithmetic and thus to an incomplete theory. 
As a compromise solution for this problem, we treat location (multiset) operators as standard non-axiomatized functions as follows. 

\begin{definition}\label{multisetOpAsFunc}
We assume that  further includes a subset  of static function symbols, where each  is interpreted in  by a corresponding function  defined as follows:   
\end{definition}

We then assume that the formulae of  do not include any -term of the form . This does not affect the expressive power of  since every formula  can be translated (under the assumption made in Definition~\ref{multisetOpAsFunc}) into an equivalent formula  which does not use any -term. We can proceed as follows. Let  be the -terms which appear in an atomic sub-formula  of . Let  be the following formula:

where  are variables which do not appear free in ,  and  are obtained by recursively applying this procedure to every atomic sub-formula of  and to , respectively, and  is obtained by replacing  in  by , respectively.  Then the formula  can be defined as the formula obtained by replacing every atomic sub-formula  of  by .

We can now proceed with proving the completeness of . The strategy is to show that  (with -terms conveniently replaced by functions as explained above) is a syntactic variant of a complete first-order theory of types. 

Let  be a signature of Henkin meta-finite structures. Assume w.l.o.g. that , ,  and  are pairwise disjoint. Let  be the signature formed by:
\begin{itemize}
\item The function symbols of . 
\item Unary relations  and .
\item For each  a -ary relation symbol . 
\item For each  a -ary relation symbol . 
\end{itemize} 
 and  are intended to state that  is an individual belonging to the database part and to the algorithmic part, respectively. Likewise,  is intended to state that  is a relation of arity . Finally,  is intended to state that the tuple  belongs to the relation .  

A Henkin meta-finite structure  of signature  \emph{determines} a unique first-order structure  of vocabulary  as follows:

\begin{itemize}
\item The domain of  is , where  and  denote the base sets of the database and algorithmic parts of , respectively, and  denotes the universe of -ary relations of . 
\item The interpretation in  of the function symbols in  is the same as their interpretation in  for arguments in  and it is extended arbitrarily to arguments in . Likewise, the interpretation in  of the function symbols in  is the same as their interpretation in  for arguments in  and it is extended arbitrarily to arguments in .
\item The interpretation in  of function symbols in  is as per Definition~\ref{multisetOpAsFunc} for arguments in  and it is extended arbitrarily to arguments in . 
\item  is interpreted as  and  as .
\item For every ,  is interpreted as  and  as set membership restricted to -tuples.
\end{itemize}

Each -formula  of signature  can be rewritten as a first-order formula  of signature , where  is obtained from  by applying the following steps:
\begin{enumerate}
\item Replace each atomic formula of the form  and  by their corresponding definitions using the Axioms~-- and~--, respectively. 
\item Bring all remaining atomic formulae into the form ,  or  (where each  denotes an appropriate first-order variable  or  depending on the context) by applying the following equivalences:

\item Eliminate all modal operators by applying the following equivalences (again where each  denotes an appropriate first-order variable  or  depending on the context):

\item Replace each atomic formula of the form  by , and relativise quantifiers over individuals in  to , quantifiers over individuals in  to , and quantifiers over -ary relations in  for some  to . More precisely,  is obtained by the recurrent application of the following rules to the formula  obtained after applying steps --. 

\end{enumerate}  

It is then relatively easy to prove:

\begin{lemma}\label{translationLemma}
A -formula  is true in  iff  is true in .
\end{lemma}

Thus, if  is valid, then  is true in all Henkin meta-finite structures. Note that the converse does not always holds. For example,  is true in all Henkin meta-finite structure (note that by the Background Postulate  is not empty), but  is not valid. In general, \emph{not every} -structure is an  structure for some Henkin meta-finite -structure .  Indeed, each -structure  which \emph{does} correspond to some Henkin meta-finite structure  satisfies the following properties (cf.~\cite{Leivant94}):
\begin{enumerate}
\item -correctness: 
\begin{itemize}
\item  for every , 
\item  for every ,
\item  for every ,
\item  for every . 
\end{itemize}
\item Non-emptiness: .
\item Disjointness:  for every  such that  .
\item Elementhood:  for every .
\item Extensionality:  for every .
\item Comprehension:  for every  and  non-free in .  
\end{enumerate}
  
\begin{lemma}\label{hasHenkinS}
If  is a first-order structure of signature  which satisfies properties~1--6 above and  is the sub-structure of  generated by the elements of , then  for some Henkin meta-finite structure  of signature  and corresponding first-order structure  of signature  determined by . 
\end{lemma}

\begin{proof}
Given  with domain , we define  as follows:
\begin{itemize}
\item  is the base set of the database part of .
\item  is the base set of the algorithmic part of .
\item For each , the universe  of -ary relations consists of the sets  for all . 
\item The interpretation of each function symbol  is the same as in  but restricted to arguments from ,  or  depending on whether  belongs to ,  or , respectively.
\end{itemize}    
By the -correctness, non-emptiness and comprehension properties of , we get that  is a Henkin meta-finite structure. 

We claim that  is isomorphic to  via  where 

First, we get that  is well defined by the disjointness property and by the fact that, by definition of  and , every element  in  is in . That  is surjective follows from the definition of  from  and the fact that  is the restriction of  to . By the extensionality property, we get that  is injective. By definition we get that  preserves the function symbols in  as well as the relation symbols ,  and  for every . Finally, for every , we get that  preserves  by the elementhood property.  
\end{proof}

Let  be the set of formulae listed under properties 1--6 above. We then get the following Henkin style completeness theorem.

\begin{theorem}\label{HenkinCompleteness}
A -formula  is true in all Henkin meta-finite structures iff  is derivable in first-order logic from  (i.e., iff ).
\end{theorem}

\begin{proof}
Assume that , and let  be a Henkin meta-finite structure. Then  and therefore . By Lemma~\ref{translationLemma}, we get that . 

Conversely, assume that  is true in all Henkin meta-finite structures. Towards showing , let us assume that , and let  be its substructure generated by the elements of . Then by Lemma~\ref{hasHenkinS},  for some first-order structure  determined by a Henkin meta-finite structure . Since by assumption we have that , it follows from Lemma~\ref{translationLemma} that  and therefore . But each quantifier in  is relativised to ,  or  for some , and then we also have that .  We have shown that , and then, by the completeness theorem of first-order logic, we get that .
\end{proof}

We know from Theorem~\ref{c5-theoremsoundness} that the deductive calculus  introduced in Section~\ref{sub:AxiomsRules} is sound. Thus, if  is a -formula derivable in , then  is true in all Henkin meta-finite structures. It is then immediate from Theorem~\ref{HenkinCompleteness} that  is derivable in first-order logic from . On the other hand, it can be proven by an easy but lengthy induction on the length of the derivations that if  is derivable in first-order from , then  is derivable in . 

\begin{lemma}\label{derivabilityLemma}
 is derivable in first-order from  iff  is derivable in .
\end{lemma}

Finally, Theorem~\ref{HenkinCompleteness} and Lemma~\ref{derivabilityLemma} immediately imply that the logic  is complete to reason about DB-ASMs.  

\begin{theorem} \label{thm-adtm-completeness-FOL}
Let  be a -formula and  be a set of -formulae. If , then .
\end{theorem}














\iffalse

As DB-ASMs are a variation of hierarchical ASMs, which do not have
recursive rule declarations, we adopt G. Renardel de Lavalette's
approach to prove the completeness of the logic for DB-ASMs, i.e. we will show that the logic for DB-ASMs is a definitional extension of a complete logic. This
approach was also used in \cite{RobertLogicASM} to prove the
completeness of the logic for hierarchical ASMs. However, the logic for hierarchical ASMs in~\cite{RobertLogicASM} is a definitional extension of the first-order logic. In the case of the logic for DB-ASMs, things are more complicated since we have to deal with second-order formulae and -terms. The key idea is to show instead that the logic for DB-ASMs is a
\emph{definitional extension} of first-order logic extended with a finite number of membership predicates with respect to finite sets, which in turn constitutes itself a complete logic.

\subsection{: A logic with set membership predicates}

In the remaining of this section, we will use  to denote the logic for DB-ASM as introduced in Section~\ref{sec:dtc} and  to denote the following first-order logic extended with set membership predicates.

\begin{definition}\label{LinDef}
The logic  is defined over many sorted first-order structures which have:
\begin{itemize}
\item a \emph{finite individual sort} with variables  which range over a finite domain ,
\item an \emph{individual sort} with variables , which range over a (possibly infinite) domain , and
\item seven \emph{predicate sorts}, where for every , the predicate sort  has variables  which range over the a domain  formed by all finite subsets (relations) on
\begin{itemize}
\item 
\item 
\item 
\item 
\item 
\item 
\item 
\end{itemize}
depending on whether  is  or , respectively.
\end{itemize}
A signature  of the logic  comprises a finite set  of names for functions on , a finite set  of names for functions on , a finite set  of names for functions which take arguments from  and return values on , and a finite set  of names for unary functions from the first predicate sort  to .

We define terms of   by induction. Variables  are terms of the first individual sort. Variables  are terms of the second individual sort. Every variable of the -th predicate sort is a term of the -th predicate sort. If  is an -ary function name in  and  are terms of the first individual sort, then  is a term of the first individual sort. If  is an -ary function name in  and  are terms of the second individual sort, then  is a term of the second individual sort. If  is an -ary function name in  and  are terms of the first individual sort, then  is a term of the second individual sort.
If  is a function name in  and  is a term of the first predicate sort, then  is a term of the second individual sort. Nothing else is a term.

 The formulae of  are those generated by the following grammar:

where ,  denotes a variable of the predicate sort , ,  and  denote terms of the first individual sort, ,  and  denote terms of the second individual sort,  and  denote terms of either the first or the second individual sorts, and .

The interpretation of terms and the semantic of the formulae are defined in the standard way. This includes equality which is used under a fixed interpretation and only between terms of the same individual sort. Each  for  is interpreted as a membership predicate where the first argument is of the predicate sort  and the remaining arguments are of the appropriate individual sorts, i.e.,

where  is a many sorted first-order structure as per Definition~\ref{LinDef},  a valuation for the variables of , , and  denote terms of the appropriate individual sorts.
\end{definition}


Let us define the theory of  as the theory obtained by taking the union of a set of sound and complete axioms and rules for first-order logic and the set of sound and complete axioms and rules in the axiomatisation of the properties of finite sets introduced in \cite{agotness:ljigpl2008}. It is not difficult to see that such theory of  is a conservative extension of the first-order theory, in the sense that if  is a set of pure first-order formulae and  is a pure first-order formula (not containing subformulae of the form ) and  holds in the theory of , then there already exists a derivation using the sound and complete axioms and rules for first-order logic. Indeed, due to the soundness of the axioms and rules in the theory of , we obtain , which is a pure statement about models for first-order logic. Thus the known completeness for first-order logic gives  in an axiomatisation for first-order logic, hence the claimed conservativism of the extension. Since then the theory of  proves no new theorems about first-order logic and all the new theorems belong to the theory of properties of finite sets and thus can be derived by using the sound and complete axioms and rules from \cite{agotness:ljigpl2008} (which also form part of the set of axioms and rules in the theory of ), we get the following important result.

\begin{theorem}\label{CompletenessLin}
Let  be a formula and  be a set of formulae in the language of . If , then .
\end{theorem}

\subsection{Completeness of the logic  for DB-ASMs}

In order to show that the logic  for DB-ASMs is actually a definitional extension of the complete first-order logic extended with set membership predicates ,
i.e., that we can translate formulae  of  into formulae  of  such that: (a)  is derivable in  and (b)   is derivable in  whenever  is derivable , we need first to redefine the syntax, semantics and models (states) of  in a way which is compatible with the syntax, semantics and models of .

Since  meta-finite states are just a special kind of two sorted first-order structures in which one of the sorts is finite, we can identify every meta-finite state  of  with a corresponding many sorted first-order structure  of the class used in Definition~\ref{LinDef}. This can be done by taking the domains  and  of the individual sorts of  to be the base sets  and  of , respectively, the sets ,  and  of function names of the signature  of  to be the sets ,  and  of the signature  of , respectively, and the interpretation in  of the function names in  to coincide with the interpretation in  of the corresponding function symbols in .

In addition, we treat location (multiset) operators as standard non-axiomatized functions since clearly we cannot axiomatize an arbitrary set  of location operators. Note that even if we just take a simple location operator such as  and axiomatize it, that leads us outside linear arithmetic and we would end up with an incomplete theory. Thus. we identify every location operators  in  with a function name  in  and define its interpretation in  as  where  is an element in the domain of the first predicate sort  of .

\begin{remark}
Recall that the finiteness condition on the database part of every state , and thus also on ,  implies that the cardinality of every multiset
 used in the interpretation of a -term of the form  is always finite. Since in addition  and , we can clearly represent every finite multiset  of this type by a corresponding element  of the first predicate sort  such that  iff  and .
\end{remark}

We can now redefine the logic  for DB-ASM by simply replacing in Definition~\ref{def:logicsyntaxformulae} the second-order quantifications of the form , , , , ,  and  by firs-order quantification of the form , , , ,, and , respectively, and by replacing formulae of the form , , , , , , , ,  and  by formulae of the form , , , , , ,  , ,  and , respectively.

Regarding -terms  of the form  which can appear in an atomic (sub)formulae , we replace them by a (sub)formula of the form


It is quite clear that this redefinition of the logic  for DB-ASMs has at least the same expressive power than the original one. Notice that the identification between meta-finite states and many sorted first-order structures, plus the proposed redefinition of , implies that there is a total function  from the set of meta-finite states of  to the class of many sorted first-order structures used in Definition~\ref{LinDef} as well a total function  from the formulae in the original definition of  to the formulae in the redefinition of ,  respectively, such that for every meta-finite state  and formula  in the original definition of ,  iff .

Finally, we need to show that all the formulae in the (redefined) logic  for DB-ASMs which are not formulae of  can be translated into formulae of  based on derivable equivalences in the theory of the (redefined) logic  for DB-ASMs.

First, we reduce the general atomic formulae in the (redefined) logic  for DB-ASMs to atomic formulae of the form
\0.2cm]
, , , \0.2cm] where ,  and  denote variables from either the first or the second individual sort depending on whether  is a function name in  or , respectively. This can be done by using the following equivalences.

The translation of modal formulae into  distributes over negation, Boolean connectives and quantifiers. For eliminating the atomic formulae of the form  and  we use Axioms~\textbf{U1}-\textbf{U7} and Axioms~\textbf{UM1}-\textbf{UM7}, respectively. For eliminating the modal operator in  formulae of the form , where  is a formula that was already translated to , we use the following equivalences which are derivable in the (redefined) logic  for DB-ASMs. \0.2cm]
 \0.2cm]
\0.2cm]
 \0.2cm]
 \0.2cm]
 \0.2cm]
\hspace*{0.5cm} \vdots \hspace*{1cm} \vdots \hspace*{0.8cm} \vdots\0.2cm]

It is not difficult to prove that the described translation from formulae of the (redefined) logic  for DB-ASMs to formulae of  satisfies the properties required for  to be a definitional extension of . This fact together with Theorem~\ref{CompletenessLin} implies our main completeness result.

\begin{theorem} \label{thm-adtm-completeness-FOL}

Let  be a formula and  a set of formulae in the logic 
for DB-ASMs. If , then .

\end{theorem}
\fi

\section{Conclusions}\label{sec:conclusion}

This article presents a logic for DB-ASMs. In accordance with the
result that DB-ASMs and database transformations are behaviourally
equivalent, it thus represents a logical characterisation for
database transformations in general.

The logic for DB-ASMs is built upon the logic of
  meta-finite structures. The formalisation of
  multiset operations is captured by the notion of -term.
The use of -terms greatly enhances the
  expressive power of the logic for DB-ASMs since aggregate computing
  in database applications can be easily expressed by using -terms.
On the other hand, -terms can easily lead to incompleteness if we try to axiomatize them in the proof system. We avoid this problem by considering them as non-interpreted functions. In this way, we cannot reason about properties of -terms themselves, but we can still use them in the formulae of our complete proof system to express meaningful properties of DB-ASMs.


As discussed in~\cite{RobertLogicASM} and~\cite{[BS03]}, the non-determinism accompanied with the use of
  choice rules poses a further challenging problem. In this work, we realized that the update sets produced by non-deterministic DB-ASMs rules are 
  definable in a variant of second-order logic in which the second-order quantifiers are interpreted using a Henkin semantics, thus becoming part of the specification of a model rather than an invariant through all models as in the case of the classical second-order semantics. 
Base on these definitions, we use the  modal operator  where  is a second-order variable that represents an update set  generated by a
 (possibly non-deterministic) DB-ASM rule . By introducing  into the logic for DB-ASMs, it is shown that nondeterministic database
  transformations can also be captured.

The use of a Henkin semantics in the definition of the logic  for DB-ASMs allowed us to show that  is actually a syntactic variant of a complete first-order theory of types. In turn, this allowed us to establish a sound and complete proof system for the logic for DB-ASMs, which can
be turned into a tool for reasoning about database transformations. However, this is restricted to reasoning about steps, not full runs, but no complete logic for reasoning about runs can be expected.
In the future we will continue to investigate how the logic for
DB-ASMs can be tailored towards different classes of database
transformations such as XML data transformations and used for
verifying the properties of database transformations in practice.

\bibliographystyle{plain}
\bibliography{DBTsLogic}

\end{document}
