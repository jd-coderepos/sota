

We mostly use the notation from~\cite{baader-nipkow}, with some additions from~\cite{Lopez-FraguasRS09-RTA09}. 
We consider a first order signature , where  and  are two disjoint
sets of \emph{constructor} and defined \emph{function} symbols respectively, all of them with associated
arity. We use  for constructors,  for functions and  for variables of a
numerable set  . The notation  stands for tuples of any kind of syntactic objects. 
The set  of {\it total expressions} is defined as , where 
,  and . The set  of
{\it total constructed terms}
(or {\it  c-terms}) is defined like , but with  restricted to  (so ).
The intended meaning is that  stands for evaluable expressions, i.e., expressions that can contain 
function symbols, while  stands for data terms representing {values}. 
We will write  for expressions and  for c-terms. 
We say that an expression  is \emph{ground} iff no variable appears in . 
We will frequently use \emph{one-hole contexts}, defined as . 


\begin{example}\label{ex:clerks}
We will use a simple example throughout this section to illustrate these definitions. Assume we want to represent
the staff of a shop, so we have 
  ,
where  will be the constructor for employees and  the constructor for pairs, and
.
Using this signature, we can build the set   . From this set, we have ,
while the ground terms are  .
Finally, a possible one-hole context is .
\end{example}

We also consider the extended signature , where  is a new -arity constructor symbol that 
does not appear in programs and which stands for the undefined value. Over this signature 
we define the sets  and  of {\it partial} expressions and c-terms, respectively.
The intended meaning is that  and  stand for 
partial expressions and values, respectively.  
Partial expressions are ordered by the {\em approximation} ordering  defined as the least
partial ordering satisfying  and 
for all .
The {\it shell}  of an expression  represents the outer constructed part
of  and is defined as: ; ; . \longtxt{It is trivial to check that for any expression  we have , that any total expression is maximal w.r.t.\ , and that as consequence if  is total then  implies .} 

\begin{example}
Using the signature from Example~\ref{ex:clerks}, we have
,
, and
.
\end{example}

{\em Substitutions}  are finite mappings , extending naturally to .  \longtxt{We write  for the identity (or empty) substitution.} 
We write  to apply of  to , and 
for the composition, defined by . 
\longtxt{The domain and  variable range of  are defined as  and .}
\shorttxt{The domain of  is defined as .}
By  we denote a substitution  such that  and .  \longtxt{If , their disjoint union  is defined by , if  for some ;  otherwise.}
\longtxt{Given 
we write  for the restriction of  to , i.e.\  if , and  otherwise; we use  as a shortcut for .} 
\emph{C-substitutions}
 verify that  for all . \longtxt{We say a substitution  is ground  iff , i.e.\  we have that  is ground.}\shorttxt{We say that a substitution is ground when no variable appears in its range.} The sets  and  of partial substitutions and partial c-substitutions are the sets of finite mappings from variables to partial expressions and partial c-terms, respectively. 


\begin{example}
Using the signature from Example~\ref{ex:clerks}, we can define the C-substitutions
, ,
and . We can define the restrictions 
 and
.
Finally, given the expression  we have

and
.
\end{example}

A {left-linear constructor-based term rewriting system} or just \emph{constructor system} (\emph{\ctrs}) or \emph{program}  is a set of c-rewrite rules of the form  where ,  and  is a linear -tuple of c-terms, where linearity means that variables occur only once in . Notice that we allow  to contain so called \emph{extra variables}, i.e., variables not occurring in . 
\longtxt{To be precise, we say that  is an extra variable in the rule 
iff , and by} \shorttxt{By}  we denote
the set of extra variables in a program rule . 
We assume that every \ctrs\ contains the rules , defining the behavior of , used in infix mode\shorttxt{ and right-associative}, and that those are the only rules for . \longtxt{Besides,  is right-associative so  is equivalent to .} For the sake of conciseness we will often omit\longtxt{ these rules when presenting a \ctrs}.  A consequence of this is that we only consider non-confluent programs. Given a \trs\ , its associated \emph{term rewriting relation}  is defined as:

for any context , rule  and . We write  for the reflexive and
transitive closure of the relation . We will usually omit the reference to  or denote it by  and .  

\begin{example}\label{ex:rules}
Using the signature from Example~\ref{ex:clerks}, we can describe the following
program:

In this example, the function symbol  defines the different branches of the
company,  defines the employees in each branch (built with the constructor
symbol ), and  returns a pair of names, built with the constructor symbol .
Note that several different notations are possible; for example, it is possible to define
the employees of one branch by using just one rule and the  operator or just several
different rules with the same lefthand side. 
\end{example}



\subsection{A proof calculus for constructor systems with extra variables}
In~\cite{Lopez-FraguasRS09-RTA09} an adequate semantics for reachability of c-terms by term rewriting in
\ctrss\ was presented. The key idea there was using a suitable notion of value, in this case
the notion of s-cterm.
 is the set of s-cterms, which are 
\emph{finite} sets of elemental s-cterms, while the set  of elemental s-cterms is defined as 
 for , , 
. We extend this \longtxt{idea} to expressions obtaining 
the sets  of s-expressions or just s-exp, and  of elemental s-expressions, which are defined 
the same but now using any symbol in  in applications instead of just constructor symbols. Note 
that the s-expression  corresponds to , so s-exps are partial by default. The approximation
preorder  is defined for s-exps as the least preorder such that 
iff  such that , 
for any , and  
iff .


\begin{example}
Using the signature from Example~\ref{ex:clerks}, and given the s-cterm
  ,
we have , while .
Similarly, given the es-exp
  we have 
and . Finally, we have that .
\end{example}

The sets  and  of s-substitutions and s-csubstitutions (or just s-csubst) \longtxt{consist of finite mappings from variables to s-exps or s-cterms, respectively}\shorttxt{are substituions with s-exps or s-cterms in their range, respectively}.  \longtxt{We extend  s-substs to be applied to  and  as  defined by }\shorttxt{To apply  s-substs to s-exp we use }
, \longtxt{; and  defined by }\shorttxt{, }. \longtxt{The approximation preorder  is defined for s-substs as  iff .
 For any nonempty and finite set  we define  as .}
 
\begin{example}
Using the signature from Example~\ref{ex:clerks}, we can define the s-csubstitution

. Hence, given
 we have that
  .
\end{example}

\longtxt{We obtain the denotation of an expression  as }\shorttxt{The denotation of an expression is }the denotation of its associated s-expression, assigned by the operator , defined as ;  for any ;  for any \longtxt{. The operator  is}\shorttxt{, } extended to s-substitutions as , for . \longtxt{It is easy to check that  (see~\cite{Lopez-FraguasRS09-RTA09}).} Conversely, we can flatten \longtxt{an s-expression } \shorttxt{s-exps }to obtain the set  of expressions ``contained'' in it, so \longtxt{ and }\shorttxt{, } if , \longtxt{ where the flattening of elemental s-exps is defined as} \longtxt{ ; }\shorttxt{, }. 
\longtxt{\begin{figure}[tb]
\begin{center}
\framebox{
\begin{minipage}{.9\textwidth}
\begin{center}
\begin{tabular}{l@{~~}cl}
 \textbf{\crule{E}} &  \.15cm]
\textbf{\crule{DC}} &  & if  \.15cm]
\textbf{\crule{Less}} &  & \
\begin{scriptsize}
\infer[\textbf{\crule{ROR}}]{\etose{f} = \{f\} \clto \{(\{0\}, \{1\})\} = \etose{(0,1)}}
{
\infer[\textbf{\crule{DC}}]{\etose{(X, X)}[X/\{0,1\}] = \{(\{0,1\}, \{0,1\})\} \clto \{(\{0\}, \{1\})\}}
{
\infer[\textbf{\crule{Less}}]{\{0,1\}  \clto \{0\}}
		{\infer[\textbf{\crule{DC}}]{\{0\} \clto \{0\}}{}} &
\infer[]{~\{0,1\}  \clto \{1\}}{\ldots}
 }
}
\end{scriptsize}
}

But in fact this is not very surprising, and it has to do with the relation between non-determinism and
extra variables~\cite{AntoyH06Extra}, but adapted to the run-time choice semantics~\cite{hussmann93,rodH08}
induced by term rewriting.  As a consequence of this we assume that all the programs contain the function , so we only consider 
non-confluent \trss. We admit that this is a limitation of our setting, but we also conjecture that 
for confluent \trss\ a simpler semantics could be used, for which the packing of alternatives of c-terms
would not be needed. However, the important point to bear in mind is that
having  at one's disposal is enough to express the non-determinism of any program~\cite{Han05TR}, so
we can use it to define the transformation  from s-exp and elemental s-exp to partial 
expressions that, contrary to , now takes care of the keeping the nested set structure by means 
of uses of the  function. Then  is defined by 
, ; and 
 is defined by , 
 for , where in the 
case for  we use some fixed arbitrary order on terms in the line of 
Prolog~\cite{SterlingShapiro86} for arranging the arguments of . This operator is also overloaded 
for substitutions as  as 
.
Thanks to the power of  to express non-determinism, that transformation preserves the semantics from
Figure~\ref{fig:semCRW}, and we can use it to prove the following new result about the adequacy of the
semantics for programs with extra variables---see~\cite{generatorsProofs} for a detailed proof.

\begin{theorem}[Adequacy of ] 
For all : \\
\textbf{Soundness } and  implies  for some  such that . Therefore,  implies 
 for some  such that . Besides, in any of the previous cases, if  is total then .\\
\textbf{Completeness}  implies . Hence, if  is total then  implies . 
\end{theorem}
\longtxt{
\begin{figure}[bt]
\begin{center}
\framebox[\textwidth]{
\begin{tabular}[t]{c|c}

 &

\end{tabular}
}
 \end{center}
\vspace{-.5cm}
    \caption{Domination relation}
    \label{fig:DomRel}
\end{figure}
}
We refer the interested reader to~\cite{Lopez-FraguasRS09-RTA09} and~\cite{LRS09ReportFully}
(Theorems 2 and 3) for more properties of  like compositionality or monotonicity, some of which are used in the
proofs for the results in the present paper.
\longtxt{There is another characterization of  closer to term rewriting which is based of the  \emph{domination relation } presented in Figure~\ref{fig:DomRel} (we will omit the prefix ``'' when it is implied by the context).}
\longtxt{With this relation we try to transfer to the rewriting world the finer distinction between sets of values that the structured representation of  allows us to perform.  We extend the relation  to  by  iff . As can be seen in~\cite{LRS09ReportFully}, this relation is a key ingredient to prove the soundness of , and its equivalence to  is stated in the following result. 
\begin{lemma}[Domination]\label{TMrelvsSem}\label{lemDenSubstMrel1}For all ,  iff . Besides, regarding substitutions, for all ,  we have that  iff .
\end{lemma}}


%
