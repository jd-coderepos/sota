\documentclass{llncs}
\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage{times}
\usepackage{latexsym,amsmath,epsfig,amssymb,graphics,tabularx}
\usepackage{color,graphicx}



\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\usetikzlibrary{shapes}
\usetikzlibrary{positioning}
\tikzset{
    pshape/.style={
           rectangle,
           rounded corners,
           draw=black, very thick,
           minimum height=2em,
           inner sep=2pt,
           text centered,
           },
}

\tikzset{
    dshape/.style={
           rectangle,
           draw=black, very thick,
           minimum height=2em,
           inner sep=2pt,
           text centered,
           },
}




\lstdefinelanguage{isa} {alsoletter={\#, \&, \rightarrow\Rightarrow\Rightarrow\forall\exists\exists\& \&\forall\exists\lambda\sqcap\vdash\equiv\Rightarrow\neg\neq}{{\do}}1
}

\lstnewenvironment{isaenv} {
  \lstset{extendedchars=true,columns=flexible}
  \lstset{language=isa,deletestring=[b]', basicstyle=\footnotesize}} {}
\newcommand{\isa}[1]{{\lstinline[language=isa, basicstyle={\footnotesize \tt} ]+#1+}}


\newcommand{\wslcomment}[1]{{\color{blue}#1}}
\newcommand{\pskip}{\textmd{skip}}
\newcommand{\pwait}{\textmd{wait}}
\newcommand{\evolution}[3]{\langle \mathcal{#1}(\dot{#2},#2)=0 \& #3\rangle}
\newcommand{\bexempt}[3]{#1 \unrhd #2 \rightarrow #3}
\newcommand{\exempt}[4]{#1 \unrhd \talloblong_{#2} #3 \rightarrow #4}
\newcommand{\leadm}[1]{\xrightarrow{#1}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\pstop}{\epsilon}
\newcommand{\now}{now}
\newcommand{\Define}{\stackrel{\mbox{\small\rm def}}{=}}
\newcommand{\fracN}[2]{\frac{\small \textstyle #1}{\small \textstyle #2}}
\newcommand{\seman}[1]{[\![#1 ]\!]}
\newcommand{\la}{\ensuremath{\langle}}
\newcommand{\ra}{\ensuremath{\rangle}}
\newcommand{\ptrue}{true}
\newcommand{\pfalse}{false}
\newcommand{\ltrue}{\textmd{True}}
\newcommand{\chan}{\textbf{Chan}}
\newcommand{\dom}{\textrm{dom}}
\newcommand{\righte}{\textit{right}}
\newcommand{\lefte}{\textit{left}}
\newcommand{\chop}{\smallfrown}

\newcommand{\typeb}[2]{\vdash #1 \blacktriangleright #2}
\newcommand{\typeba}[2]
{\begin{array}{l}
  \vdash #1 \blacktriangleright \\ #2
\end{array}}
\newcommand{\typep}[2]{\vdash #1 @ #2}
\newcommand{\typepo}[3]{#1\vdash #2 @\ #3}
\newcommand{\soundb}[2]{\models #1 \blacktriangleright #2}
\newcommand{\soundpo}[3]{#1\models #2 @\ #3}
\newcommand{\soundp}[2]{\models #1 @ #2}
\newcommand{\semant}[1]{[\!\{#1\}\!]}
\newcommand{\rec}[1]{\langle\!|(#1)|\!\rangle}
\newcommand{\combine}[2]{Par(#1, #2)}
\newcommand{\inference}[3]{\{#1\} \ #2\ \{#3\}}
\newcommand{\dceil}[1]{\lceil #1 \rceil}

\newcommand{\vars}[1]{\textbf{Var}(#1)}
\newcommand{\inchan}[1]{\textbf{InChan}(#1)}
\newcommand{\outchan}[1]{\textbf{OutChan}(#1)}
\newcommand{\close}[1]{cl(#1)}
\newcommand{\before}[1]{\mathit{at}(#1)}


\newcommand{\Pre}{\varphi}
\newcommand{\Post}{\psi}
\newcommand{\HF}{HF}



\newcommand{\oomit}[1]{}




\begin{document}

\title{A Framework for Hybrid Systems with Denial-of-Service Security Attack}
\author{Shuling Wang\inst{1} \and Flemming Nielson\inst{2}
\and Hanne Riis Nielson \inst{2}
  }
   \institute{
 State Key Laboratory of Computer Science,
 Institute of Software \\
 Chinese Academy of
 Sciences, China
 \and DTU Informatics,
 Technical University of Denmark, Denmark}



\maketitle

\begin{abstract}
Hybrid systems are integrations of discrete computation and continuous physical evolution. The physical components of such systems
introduce safety requirements, the achievement of which asks for the correct monitoring and
control from the discrete controllers. However, due to denial-of-service security attack,
the expected information from the controllers is not received and
as a consequence the physical systems may fail to behave as expected. This paper
proposes a formal framework for expressing denial-of-service  security attack
 in hybrid systems.  As a virtue, a physical system is able to
plan for reasonable behavior in case the ideal control fails due to unreliable communication,
 in such a way that the safety of the system upon denial-of-service is still guaranteed.
 In the context of the modeling language, we develop an inference system
for verifying safety of hybrid systems, without putting any assumptions on how the environments behave.
Based on the inference system, we implement an interactive theorem prover and have applied
it to check an example taken from train control system.
\end{abstract}
\keywords Hybrid systems,  Denial-of-service,  Safety verification, Inference system
\section{Introduction}

Hybrid systems, also known as cyber-physical systems, are dynamic systems
with interacting continuous-time physical systems and discrete controllers.
The physical systems evolve continuously with respect to time, such as
aircrafts, or  biological cell growth,  while
the computer controllers, such as autopilots, or biological control circuits, monitor and control
the behavior of the systems to meet the given design requirements. One design requirement is safety, which
includes time-critical constraints,  or invariants etc.,  for the example of train control systems,
the train should arrive at the stops on time, or
the train must always move with a velocity within a safe range.

However, due to the uncertainty in the environment, the potential errors in wireless communications between
the interacting components will make the safety of the system very hard to guarantee.
For the sake of safety, when the controllers fail to behave as expected because of absence of expected communication and thus become unreliable,
the physical systems should provide feedback control,
to achieve safety despite errors in communication. 



\paragraph{\textbf{A Motivating Example}}

We illustrate our motivation by an example taken from train control system,
that is depicted in Fig.~\ref{fig:idea}.
It consists of three inter-communicating components:
Train, Driver and on board vital computer (VC).
We assume that the train owns arbitrarily long
movement authority, within which the train is allowed to move only,
 and must conform to a safety requirement, i.e.
the velocity must be non-negative and cannot exceed a maximum limit.
The train acts as a continuous plant, and moves with a given acceleration;
both the driver and the VC act as controllers, in such a way that,
either of them observes the velocity of the train periodically, and then according to the safety requirement,
computes the new acceleration for the train to follow in the next period.
According to the specification of the system, the message from the VC always takes high priority over the one from the driver.
\vspace{-2em}



\begin{figure}[htbp]
\centering
\small


\def\pnode[#1,#2]#3{
\node[pshape,
 text width=1.2cm,
 anchor=center] at #2 (#1)
{#3};
}

\begin{picture}(158,77)(0,0)

\begin{tikzpicture}[->,>=stealth']


\tikzstyle{every node}=[font=\small]

\pnode[Train,(0,0)] {Train};
\pnode[Driver,(-1.5,1.5)] {Driver};
\pnode[VC,(1.5,1.5)] {VC};

\path
(-0.51,0.31)			edge  node[bend left,left]{trd} (-1.35,1.15)
(Driver)		    	edge  node[anchor=south,right]{dr} (Train)
(VC)			edge  node[anchor=south,left]{vc} (Train)
(0.51,0.31)			edge  node[anchor=south,right]{trv} (1.35,1.15);

\end{tikzpicture}

\end{picture}
 \caption{The structure of train control example}
\label{fig:idea}
\end{figure}

\vspace{-1.5em}
However, the expected monitoring and control from VC or driver may fail due to denial-of-service security attack, e.g.
if the driver falls asleep, or if the VC
gets malfunction, and as a consequence, the  train may get no response from any of them within a duration of time.
The safety requirement of the train will then be violated very easily.
This  poses the problem of how to build a safe hybrid system in the presence of this sort of
denial-of-service security attack  from the environment.












The contribution of this paper includes the following aspects:
\begin{itemize}
  \item a programming notation, for formally modeling hybrid systems and meanwhile being able to express
          denial-of-service due to unreliable communications, and an assertion language, for describing safety as
          annotations in such programs;
  \item a deductive inference system, for reasoning about whether the program satisfies the annotated safety property, and a subsequent
           interactive theorem prover.
\end{itemize}
As a direct application, we are able to build a safe system for the example such that:
\begin{itemize}
\item[(F1)] the error configurations where neither driver nor VC is available are not reachable;
\item[(F2)] the velocity of the train keeps always in the safe range, although in the presence of denial-of-service
attack from the driver or the VC.
\end{itemize}
Furthermore, when the behavior of the environments (i.e. driver and VC) is determined,
e.g. by defining some constraints among the constants of the whole system, we can learn
 more precise behavior of the train.




In Section~\ref{sec:syntax} and Section~\ref{sec:semantics}, we
present the syntax and semantics for the formal modeling language. It is a combination of
Hybrid CSP (HCSP)~\cite{Jifeng:1994,Zhou:1996}, a process algebra based modeling language for describing hybrid systems,  and the binders
from Quality Calculus~\cite{RNV12}, a process calculus that allows one to take measures in case of unreliable communications.
With the introducing of binders, the modelling language is capable of programming
a safe system that executes in an open environment
that does not always live up to expectations.


In Section~\ref{sec:inference}, we define an inference system for reasoning about HCSP with binders.
For each construct , the specification is of the form ,
where  and  are the pre-/post-condition recording the initial and terminating states of
 respectively,  and  the history formula recording the whole
execution history of  (thus able to specify global invariants).
As a direct application, the (un-)reachability analysis
can be performed
by identifying the points corresponding
to the error configurations by logical formulas and then checking the (un-)satisfiability of the formulas.
In  Section~\ref{sec:application}, we have applied a theorem prover we have implemented to verify properties (F1) and (F2) of the train control example.
At last, we conclude the paper and address some future work.

\paragraph{\textbf{Related Work} }

There have been numerous work on formal modeling and verification of hybrid systems, e.g., \cite{Alur:1992,Manna93,Henzinger96,LSVW96,LPY02}, the most popular of which is {\em hybrid automata}~\cite{Alur:1992,Manna93,Henzinger96}. For
 automata-based approaches, the verification of hybrid systems is reduced to computing reachable sets,
 which is conducted either by model-checking~\cite{Alur:1992} or by the decision procedure of Tarski algebra~\cite{LPY02}. However,
  hybrid automata, analogous to state machines, has
  little support for structured description; and meanwhile,
   the verification of it based on reachability computation is not scalable and
   only applicable to some specific linear hybrid systems,  as
   it heavily depends on the decidability of the problems to be solved.
Applying abstraction or (numeric) approximation \cite{EClarke03,ADI06,ABDM00}  can improve the scalability,
but as a pay we have to sacrifice the precision.



 In contrast, deductive methods increasingly attract more attention in the verification
   of hybrid systems as it can scale up to complex systems.
  A differential-algebraic dynamic logic for hybrid programs \cite{Platzer10} was proposed by extending
dynamic logic with continuous statements, and has been applied for safety checking of European Train Control
System~\cite{PQ09}. However, the hybrid programs there can be considered as a textual encoding of hybrid automata,
with no support for communication and concurrency.
In~\cite{LLQZ10,ZWZictac}, the Hoare logic is extended to hybrid systems
modeled by Hybrid CSP~\cite{Jifeng:1994,Zhou:1996}, and then used for safety checking of
Chinese Train Control System. But the logic lacks compositionality.

All the work mentioned above focus on safety without considering denial-of-service security attacks from
the environment.
Quality Calculus~\cite{RNV12,HNN13} for the first time proposed a programming notation for expressing
denial-of-service in communication systems, but is currently limited to discrete time world.



\section{Syntax}
\label{sec:syntax}
 We first choose Hybrid CSP (HCSP)~\cite{Jifeng:1994,Zhou:1996} as the modelling language
 for hybrid systems.
 HCSP inherits from CSP the explicit communication model and concurrency, thus is expressive enough for describing
  distributed components and the interactions between them. Moreover, it extends CSP with differential
equations for representing continuous evolution, and provides several forms of interrupts to continuous evolution for
realizing communication-based discrete control.
On the other hand, Quality Calculus~\cite{RNV12,HNN13} is recently proposed to programming software components and their interactions in the presence
of unreliable communications. With the help of  \emph{binders} specifying the success or failure of communications and then the
communications to be performed before continuing,
it becomes natural in Quality Calculus to plan for reasonable behavior  in case the ideal
behavior fails due to unreliable communication and thereby to increase the quality of  the system.

In our approach, we will extend HCSP further with the notion of binders from Quality Calculus,
for modelling hybrid systems in the presence of denial-of-service because of unreliable communications.
The overall modelling language is given by the following syntax:
\vspace{-0.5em}
 

Expressions  are used to construct data elements and consist of constants ,
data variables , and function application .

Binders  specify the inputs and outputs to be performed before continuing.
The output   expects to send message  along channel , with
 being the acknowledgement in case the communication succeeds, and the
dual input  expects to receive a message from  and assigns it to variable , with
  being the acknowledgement similarly. We call both  and  \emph{acknowledgment variables}, and
assume in syntax that for each input or output statement, there exists a unique acknowledgement variable attached to it.
In the sequel, we will
use  and  to represent the set of data variables and acknowledgement variables respectively,
 and they are disjoint.
For the general form , the quality predicate  specifies the sufficient communications
among
   for the following process to proceed. In syntax,  is a logical
combination of quality predicates corresponding to , ,  recursively (denoted by  respectively below).
For example, the quality predicates for  and
 are boolean formulas  and .
There are two special forms of quality predicates, abbreviated as  and , with the definitions:
 and .
More forms of quality predicates can be found in~\cite{RNV12}.

\example For the train example, define binder  as
,
the quality predicate
of which amounts to .
It expresses that,
the train is waiting for the acceleration from the driver and the VC, via \textsf{dr} and \textsf{vc} respectively,
and
as soon as one of the communications succeeds (i.e., when the quality predicate becomes true),
the following process will be continued without waiting for the other. 

  define processes. The
 and assignment  are defined as usual, taking no time to complete.
Binders  are explained above.
The continuous evolution , where  represents a vector of continuous variables and
 the corresponding  first-order derivative of ,
forces   to evolve according to the differential equations  as long as ,
a boolean formula of  that  defines the {\em domain of }, holds, and terminates when  turns false. The communication interrupt  behaves as  first,
and if  occurs before the continuous terminates,  the continuous  will be preempted  and
 will be executed instead.

The rest of the  constructs define compound processes. The parallel composition 
behaves as if  and  run independently
except that the communications along the common channels connecting  and  are to be synchronized.
In syntax,  and  in parallel are restricted not to
share variables, nor input or output channels.
The sequential composition  behaves as  first, and if it terminates, as  afterwards.
The conditional  behaves as  if  is true, otherwise terminates immediately. The condition  can be used for 
checking the status of data variables or acknowledgement, thus in syntax,
it is a boolean formula on data and acknowledgement variables (while for
the above continuous evolution,   is a boolean formula on only data variables). The
repetition  executes  for arbitrarily finite number of times.

It should be noticed that, with the addition of binders, it is able to derive a number of other
known constructs of process calculi, e.g., internal
and external choice~\cite{RNV12}.



\example
Following Example 1,  the following model

denoted by , expresses that, the train moves with velocity  and acceleration , and as soon as  occurs within  time units, i.e.
 the train succeeds to receive a new acceleration from either the driver or the VC,
 then its acceleration  will be updated by case analysis. It can be seen that the acceleration from VC will be used in priority.
For later reference we have annotated the program with labels (e.g. 1, 2, etc.). 










  \section{Transition Semantics}
\label{sec:semantics}
We first introduce a variable  to record the global time during process execution, and then
define the set .
A state, ranging over ,  assigns a value to each variable in
, and we will use  to represent the set of states.
A flow, ranging over , defined on a closed time interval  with ,
or an infinite interval  with some ,
assigns a state in  to each point in the interval.
Given a state , an expression  is evaluated to a value under , denoted by  below.



Each transition relation has the form ,
where  is a process,  are states,  is a flow, and  is an event. It represents that
starting from initial state ,  evolves into  and ends with state  and flow , while
performing event . When the above transition takes no time, it produces a point flow,
i.e.  and
, and we will call the transition \emph{discrete} and write

instead without losing any information.
The label  represents
events, which can be a discrete internal event,
like skip, assignment, evaluation of boolean conditions, or termination of a continuous evolution etc.,
uniformly denoted by , or an external communication, like output  or input ,
or an internal communication , or a time delay  for some positive .
We call the events but the time delay \emph{discrete events}, and will use  to range over them.


The transition relations for binders are defined in Table~\ref{semantic:binder}.
The input  may perform an external communication
,  and as a result   will be
bound to  and  set to , or
it may keep waiting for   time. For
the second case, a flow  over  is produced, satisfying that
 for any  in the domain, , i.e. no variable but the clock  in 
is changed during the waiting period. Similarly, there are two rules for output . Here
  is an abbreviation for .


Before defining the semantics of general binders,
we introduce two auxiliary functions. Assume
 is
an intermediate tuple of binders that occurs during execution (thus some of s might contain
),  a quality predicate, and  a state. The function
 defines the truth value of  under , which is
calculated by replacing each sub-predicate  corresponding to  in  by  respectively;
and  function  returns a state
that fully reflects the failure or success of binders , and can be
constructed from  by setting
the acknowledgement variables
corresponding to the failing inputs or outputs among  to be .
Based on these definitions, binder
 may keep waiting for  time, if  is false under
, or perform a discrete event  that is enabled for some , or perform a  transition and
 terminate if  is true under . Notice that when  becomes true, the enabled discrete events  can still be performed, as indicated by the second rule.
\begin{table}[t]
\small
\centering
\begin{tabular}{c}
\hline \\
 \0.5em]
 \0.5em]
\0.5em]
\0.5em]
\hline\\
\1.2em]
\-0.52em]
\end{tabular}
\caption{The transition relations for binders and the auxiliary functions}
\label{semantic:binder}
\end{table}

\example
Starting from  , the execution of  in Example 1
may lead to three possible states at termination:
\begin{itemize}
\item
, indicating that the train succeeds to receive
 from the driver after  time units have passed, but fails for the VC;
\item , for the opposite case of the first;
\item , indicating that
the train succeeds to receive messages from the driver as well as the VC after  time. 
\end{itemize}



\begin{table}[p]
\small
\centering
\begin{tabular}{c}
\hline \\
\multicolumn{1}{l}{\textbf{Skip, Assignment and Idle} 
}\\


\2em]
[0, \delta]S(0) = \sigma(s)
\1.3em]

\1.3em]

\1.3em]

\1.3em]

 
\1.6em]
\hline
 \end{tabular}
\caption{The transition relations for processes}
\label{semantic:process}
\end{table}


The transition relations for other processes are defined in Table~\ref{semantic:process}. The rules
for skip and assignment can be defined as usual. The idle rule represents that
the process can stay at the terminating state  for arbitrary 
time units, with nothing changed but only the clock progress.
 For continuous evolution, for any ,
it evolves for  time units according to 
if  evaluates to true within this period (the right end exclusive).
A flow    over  will then be produced, such that
 for any  in the domain,
 , where
  is the solution as defined in the rule.
 Otherwise, the continuous evolution
terminates at a point if  evaluates to false at the point, or if  evaluates to false
 at a positive open interval right to the point.


For communication interrupt, the process may evolve for  time units if both the continuous evolution and
the binder can progress for  time units, and then reach the same state and flow as the continuous evolution does.
It may perform a discrete event over , and if the resulting binder  is not
, then the continuous evolution is kept, otherwise,
the continuous evolution will be interrupted and  will be followed to execute, and for both cases,
will reach the same state and flow as the binder does.
Finally, it may perform a  event and terminate immediately
 if the continuous evolution terminates with a  event but  not.
Notice that  the final state  needs to be reconstructed from 
 by resetting the acknowledgement variables of those unsuccessful  binders occurring in 
 to be .

Before defining the semantics of  parallel composition, we need to introduce some notations.
Two states 
and  are \emph{disjoint}, iff  and . For two disjoint states 
and ,   is defined as a state over
, satisfying that
 is   if  , otherwise
  if  .
We lift this definition to flows  and  satisfying
, and define  to be a flow such that
.
For , assume  and    represent the initial states for
 and  respectively and are disjoint.
The process  will perform a communication along a common channel of  and , if
 and  get ready to synchronize with each other along the channel.
Otherwise, it will
perform a discrete event, that can be , an internal
communication of , or an external communication along some non-common channel of  and ,
if   can progress separately
on this event (and the symmetric rule for  is left out here). When
neither internal communication nor  event is enabled for , it
may evolve for  time units if both  and  can evolve for  time units. Finally,
 the process will perform a  event and terminate as soon as
both the components terminate.


At last, the rules for conditional, sequential,  and repetition are defined as usual.

\example
Starting from state , the execution
of  in Example 2 leads to the following cases (let  denote  below):
\begin{itemize}
\item  terminates without the occurrence of ,
the final state is ;
\item  occurs after  time units for some , and as a result  executes to location 2, with state , where  , ,  and  have 3 possible evaluations as defined in Example 3,  and then depending on the values of  and , executes to location 3 or 4  respectively, and finally terminates after a corresponding acceleration update. 
\end{itemize}

\paragraph{\textbf{Flow of a Process}}
Given two flows  and  defined on  and  (or )
respectively, we define the concatenation   as the
flow defined on  (or ) such that  is equal to  if , otherwise
. Given a process  and an initial state , if we have the following sequence of transitions:

then we define  as the \emph{flow} from  to  with respect to the initial state ,
and furthermore, write

to represent the whole transition sequence (and for simplicity, the label sequence can be omitted sometimes).
When  is , we call  a \emph{complete flow} of  with respect to  .


\section{Inference System}
\label{sec:inference}

In this section, we define an inference system for reasoning about both discrete and continuous properties of HCSP with binders,
which are considered for an isolated time point and a time interval respectively.


\paragraph{\textbf{History Formulas}}
In order to describe the interval-related properties,
we  introduce history formulas,  that are defined by duration calculus (DC)~\cite{ZHR91,ZH04}.
DC is a first-order interval-based
real-time logic with one binary modality known as chop . History formulas  are defined
by the following subset of DC:

where  is a temporal variable denoting the length
of the considered interval,  is a relation,   a non-negative real,
and   a first-order state formula over process variables. For simplicity, we will write
 as an abbreviation for .

 can be interpreted over flows and intervals. We define the judgement  to
represent that  holds under  and , then we have

 As defined above,
 indicates the length of the considered interval;
  asserts that
   holds almost everywhere in the considered interval;
and  asserts that the interval can be divided into two sub-intervals such that
 holds for the first and  for the second. The first-order connectives  and
 can be explained as usual.

All  axioms and inference rules for DC presented in~\cite{ZH04} can be applied here,  such as


\paragraph{\textbf{Specification}}
The specification for process  takes form
,
where  the pre-/post-condition  and , defined by FOL,
specify properties of
variables that hold at the beginning  and termination of the execution of  respectively,
 and the history formula , specifies properties of  variables
 that hold throughout the execution interval of . The specification of  is
 defined with no dependence on
the behavior of its environment.
The specification is \emph{valid}, denoted by
,
iff for any state , if , then  implies
 and .

 \paragraph{\textbf{Acknowledgement of Binders }}
In order to define the inference rules for binders , we first define
an auxiliary typing judgement ,
where  the first-order formula  describes the acknowledgement corresponding to successful passing of ,
and is defined without dependence on the precondition of .
We say  \emph{valid},
denoted by ,  iff
given any state , if , then
 holds.


The typing judgement for binders is defined as follows:

As indicated above, for input , the successful passing of it gives rise to formula , and similarly for
output ; for binder , it gives rise to
formula , which encodes the effect of quality
predicate  to the sub-formulas  corresponding to  respectively.

\example
For binder  in Example 1, we have
,
indicating that, if the location after  is reachable, then at least one of the communications with the driver or the VC succeeds. 


\subsection{Inference Rules}

\begin{table}[t]
\small
\centering
\begin{tabular}{c}
\hline \\
 \0.6em]

\0.8em]

\1.3em]

\quad
 \1.3em]
\hline\\
\end{tabular}
\caption{An inference system for processes}
\label{inferencesystem}

\end{table}


We first introduce an auxiliary  function
, which given a binder , returns the variables that may be modified by . It can be defined directly  by structural induction on  and we omit the details.
The inference rules for deducing the
 specifications of all constructs are presented in Table~\ref{inferencesystem}.



Statements  and assignment are defined as in classical Hoare Logic, plus
 in the history formula, indicating that they both take zero time to complete.
For each form of the binders , the postcondition is the conjunction of
the quantified precondition  over variables in
 and  the acknowledgement corresponding to the successful
passing of . The binders  may occur without waiting any time,
indicated by  as one disjunctive clause of each history formula.
For both  and , if the waiting time is greater than
0, then   will hold almost everywhere in the waiting interval
 (the only possible exception is the right endpoint, at which the communication occurs and variables might be changed correspondingly). For
 ,  only the quantified   over  variables in
 is guaranteed to hold almost everywhere throughout the waiting interval, since
some binders s that make  true might occur at sometime during the interval
and as a consequence variables in  might get changed.




For continuous evolution, the notion of differential invariants is used instead of explicit solutions.
A \emph{differential invariant} of 
for given initial values of  is a first-order formula of , which is satisfied by the initial values and also by all the values
reachable by the trajectory of  defined by  within the domain .
A method on generating differential invariants for polynomial differential equations was
proposed in~\cite{LZZ11}.
Here we assume  is a differential invariant with respect to precondition  for the continuous evolution (more details on using
 are shown in the later example proof). For the postcondition,
the quantified  over  the only
modified variables , the closure of , and the closure of
 hold. The closure   extends the domain defined by the corresponding formula to include the boundary.
For the history formula,  the execution interval may be 0, or otherwise, the quantified  over ,  and  holds almost everywhere throughout the
 interval.

For communication interrupt,
if  fails to occur before the continuous evolution terminates,
the effect of the whole statement is almost equivalent to  the continuous  evolution,
except that some variables in  may get changed because of occurrences of some communications
during the execution of the continuous  evolution.
Otherwise, if  succeeds within the termination of the continuous  evolution,
the continuous evolution will be interrupted and  will start to execute from the interrupting point.
At the interrupting point, the acknowledgement of  holds, and moreover,
because   and  variables in  may have been modified,
  holds (the closure here is to
include the case when the interrupting point is exactly the termination point of the continuous  evolution).
For the second case, the postcondition
is  defined as the one for , and the history formula as the chop of the one for
the continuous evolution before interruption and the one for  afterwards.
Finally, as indicated by the rule, the postcondition and history formula for the whole statement are defined as the disjunction of the above two cases.



The rule for  is defined by conjunction, however, because
 and  may terminate at different time,
the formula  is added to the end of the history formula with short time interval to make
the two intervals equal. For , the history formula is defined by the concatenation of the ones
of  and . The rule for  includes two cases depending on whether
 holds or not.
At last, for , we need to find the invariants, i.e.  and ,  for both the postcondition and history formula.

The general inference rules that are applicable to all constructs, like monotonicity, case analysis etc.,
can be defined as usual and are omitted here.

We have proved the following soundness theorem:
\begin{theorem}
Given a process , if  can be deduced from the inference rules,
then .
\end{theorem}
 \textsc{proof}.
We need to prove that, for any state , if , then  implies
 and . The proof is given by structural induction on  as follows.
  \begin{itemize}
    \item The proof for   and  is trivial.

    \item Cases binders : For ,  according to the transition system, there exist some  and  such
    that
     and 
    defined on  satisfies that  for
    each  in  and .
    Thus, from , 
    and  must hold (notice that  does not occur
    in assertions). The case for 
    can be proved similarly.

  For , according to the transition system,
    there must exist some  such that , and
    for each  evolving to  at termination, there must be , and
    for any variable  that is not , for any
    , . Thus
     and  hold. And, from , where  represent the final form of  during the execution of , we have  proved.

    \item Case : According to the transition system,
    there must exist  such that   and
     defined over \\
     satisfies that
    for any  in the domain,  , where
     is the solution of the continuous with respect to  as defined in the rule.
   Moreover, for any ,
    , and  or there exists  such that
    for any ,
    ,
    where
     is the solution of the continuous with respect to  as defined in the rule.
    Obviously, . According to the definition
    of , then for any ,
    , thus
     and 
     hold.
    Plus the fact that 
    , the result is proved.

    \item Case : According to the transition system, there are two
    cases for termination, by applying the fourth and the third transition rules for it respectively.
    For the first case, there must exist  such that ,
    and for any variable  except for  and the ones in , 
    and for any , . Plus the semantics of
    continuous, we have
    
    and 
     proved.
    For the second case, there must exist  such that ,
    and for any variable  except for  and the ones in , 
    and for any , , and
    , and , and
    . The fact is proved based on the inductive hypothesis on .

    \item Cases ,  and : According to the transition
    system, for , suppose  and  terminate at the same time, then
    there must exist ,  and  such that
    , ,
     and .
    The fact is proved by induction hypothesis on  and .  The other cases can be proved
    easily.

    Similarly, the rules for  and  can be proved by induction hypothesis, and we omit
    the details here.

    \item Case : According to the transition system,
  we have 
  or there exist an integer  such that
    , , and a sequence of
    transitions as follows:
    
    For the first case, the fact holds trivially. For the second case,
    suppose the fact holds when  for some , next we prove  that
    the fact holds for . According to the transition rule,
    we have
    
    By induction hypothesis on ,
     and 
     must hold. Then
    
    , plus ,
    we have  proved.
  \end{itemize}




\subsection{Application: Reachability Analysis}
\label{subsection:reachability}
The inference system can be applied directly for reachability analysis.
Given a labelled process  (a process annotated with integers denoting locations), a precondition  and a location  in , by applying the inference system,
we can deduce a property   such that if  reaches ,  must hold at , denoted by
. In another word, If   and  is not satisfiable, then 
will not be reachable in   with respect to .
We have the following facts based on the structural induction of :
\begin{itemize}
  \item for any process ,  and  provided ;
  \item .
   (denoted by ), if   holds.   if  and   hold;
 \item  if  and  hold.
  if ,   and  hold;
     \item   .  if  and ;
  \item , if ,  and  hold.
\end{itemize}
Obviously, the monotonicity  holds: if  and , then .



\example
Consider  in Example 2. Given precondition  , we have
,
denoted by . Moreover,
, the formula  is un-satisfiable, thus location 5 is not reachable.
Other locations can be considered similarly. 


\paragraph{\textbf{Implementation}}
We have mechanized the whole framework  in Isabelle/HOL and implemented an interactive theorem prover for
reasoning about hybrid systems modeled using HCSP with binders \footnote{The prover, plus the models and proofs related to the train control example in next section,  can be found at \url{https://github.com/wangslyl/hcspwithbinders}.}.




\section{Train Control Example}
\label{sec:application}
We apply our approach to the train control system  depicted in Fig.~\ref{fig:idea}: firstly, we
construct the formal model for the whole system, especially the train;
secondly,  prove for the train that it is safe against denial-of-service security attack  with respect
to properties (F1) and (F2); finally, explore  the constraints that
relate the constants of different components and learn more precise behavior of
the train.
Assume for the train that
its acceleration ranges over  for some , and the maximum speed
is  .

\begin{table}[t]
\small
\centering

\caption{The model of \textbf{train}}
\label{trainmodell}
\end{table}

\begin{table}[t]
\small
\begin{minipage}{0.5\linewidth}
\centering

\end{minipage}
\begin{minipage}{0.5\linewidth}
\centering

\end{minipage}
\caption{The models of \textbf{driver} and \textbf{VC}}
\label{driverevc}
\end{table}



\paragraph{\textbf{Models}}
The model of the train is given in Table~\ref{trainmodell}. There are two auxiliary processes:
given a clock variable  and  time  ,
 defines that the train moves with velocity  and acceleration 
for up to  time units;
and  defines the feedback control of the train when the services from
the driver or the VC fail: it performs
an emergency brake by setting
   to be  ,  and
as soon as  is reduced to , resets  to be , thus the train keeps still finally.
The main process \textsf{TR}
models the movement of a train. The train first moves for at most  time units,
during which it is always ready to
send  to the driver as well as the VC along \textsf{trd} and \textsf{trv} respectively.
If neither of them responses within , indicated by ,
the self control is performed.
Otherwise, if at least one communication occurs,
the movement is interrupted and a sequence of
case analysis is followed to execute.


The first case, indicated by  and ,
represents that the driver as well as the VC succeed to receive .
The train will wait for at most  time units
for
the new acceleration from the  driver or the VC along \textsf{dr} and \textsf{vc} respectively, and during the waiting time, it
continues to move with the original acceleration. The new acceleration is expected to satisfy a
 safety condition :
 \vspace{-0.5em}
 
which implies the boundaries for setting  to be positive or negative and is necessary for keeping the velocity always in
, otherwise, it will be rejected by the train.
If both the driver and the VC fail to response within , indicated by ,
 the self control is performed.
 Otherwise, the following case analysis is taken:
 If the train receives a value (i.e. ) from  VC,
 indicated by , then sets 
 to be the acceleration if it satisfies ,
otherwise, performs self control; if the train receives a value (i.e. ) from the driver but not from
the VC, updates the acceleration similarly as above; if
the train receives no value from both (in fact never reachable), the skip is performed.





The  other three cases, indicated by , , and ,
can be considered similarly.








One possible implementation for driver and VC is given in Table~\ref{driverevc}, in which
process  for  is an abbreviation for
. In process
, the driver asks the velocity of the train every  time units, and as soon as
it receives , indicated by , it computes the new acceleration as follows:
 if  is almost reaching  (by the offset ), then chooses a negative
in  randomly; if
 is almost reaching 0, then chooses a non-negative in   randomly;
otherwise, chooses one in  randomly.
 The train then sends the value being chosen (i.e. ) to the train, and if it fails to reach the train
within  (i.e. the period of the clock), it will give up. The auxiliary process
\textsf{clock} is introduced to prevent deadlock caused by the situation when the driver succeeds to receive velocity  from the train but fails to send acceleration  to the train within a reasonable time (i.e.  here).
\textsf{VC}  and  have very similar structure, except that
\textsf{VC} has a different period , and it
will choose  or  as the acceleration for the first two critical cases mentioned above.

Finally, the train control system can be modeled
as the  parallel composition:
.
By using ,  each component will be executed repeatedly.

\paragraph{\textbf{Proofs of Train}}
\label{subsec:proof}
First of all,
we  define the precondition of , denoted by , to be
, which indicates that
in the initial state,  and  satisfy the safety condition and are both well-defined.

Secondly, we need to calculate the differential invariants for differential equations occurring in \textsf{TR}.
Consider the equation in ,
the precondition of it with respect to , denoted by , can be simply calculated, which is , then
by applying the method proposed in~\cite{LZZ11}:

denoted by , constitutes a differential invariant of the continuous with respect to .
It is a conjunction of three parts, indicating that:
(1)  is always in the range ;  (2) if  is negative, 
must be greater or equal than  plus  a positive value (i.e. ), and meanwhile ;
and (3) if  is positive,
  must be less or equal than  plus a negative value (i.e. ), and meanwhile .
This invariant is strong enough for guaranteeing   after the continuous escapes no matter what 
is in .
Similarly, we can calculate the invariant of the continuous occurring in , which is

denoted by . This invariant is strong enough for guaranteeing  after the continuous escapes.
Finally, the invariant of the differential equation of  is , and we denote it by .

Next, to prove (F1) and (F2), we can prove the following facts instead:
\begin{itemize}
\item Locations 1, 2, 3, 4 are not reachable for ;
\item Throughout the execution of ,
the invariant  always holds.
\end{itemize}
First we consider one loop of execution .
For location 1, we can deduce that \footnote{For simplicity, we use the boldface of an acknowledgment  variable to represent the corresponding
  formula, e.g.,  for .}
, which
is not satisfiable, thus location 1 is never  reachable.
Similarly, we can deduce that locations 2, 3, 4 are not reachable as well.  Furthermore, by applying the inference system, we can deduce the  specification
.
After one loop  of execution of the train,  still holds at termination. Thus,
all the above reachability  results obtained for  still hold for ,  whose execution
is equivalent to some  finite number of executions of  .
Finally, plus that  is idempotent over chop, we
can deduce
, denoted by (\textbf{TrainSpec}),
which
implies that  is an invariant for the train.

By applying  our interactive theorem prover, the fact (\textbf{TrainSpec}) is proved as a theorem, and
the above reachability results can be implied from the lemmas proved for corresponding processes, according to
the method introduced in Section~\ref{subsection:reachability}.

We can see that, most of the proofs need to be performed in an interactive way,
mainly because of the following reasons: firstly, we need to provide the differential invariants by ourselves during proof
of continuous evolution; and
secondly, we need to conduct the proof of DC formulas by telling
which axiom or inference rule of DC should be applied.  For the first problem, we will consider
the integration of the prover to a differential invariant generator that can be implemented based on the method
proposed in~\cite{LZZ11}. For the second, we will consider  the decidability
of DC and design algorithms for solving the decidable subsets, or as an alternative approach,
consider translating DC formulas into HOL formulas in a semantic way and
applying the existing automatic solvers for HOL instead. Both of these will be our future work.

\paragraph{\textbf{Constraints of Constants}}

We can further analyze the behavior of the whole system . By defining the constraints relating
 different constants, the behavior of communications between
the three components can be determined.
Consider the first loop of execution of each component, based on reachability analysis, we have the following facts:
for locations 0, 5, 6,  ,  and  hold respectively, and
for locations 7, 8, 9, ,  and  hold respectively.
The synchronization points have four possibilities: ,  ,  , or none. For the first case,
i.e. the train succeeds to communicate with the driver but not with the VC,
there must be , and if  and  hold, this case will occur.
The second one is exactly the contrary case.
For the third case, there must be , and if
 holds, this case will occur. Finally, if both
 and  hold, the last case occurs, i.e., locations 7, 8 and 9 are not reachable, and thus
the train fails to communicate with both the driver and the VC.
Following this approach,  more precise behavior of the communications of the train
can be obtained.


\section{Conclusion and Future Work}
\label{sec:conclusion}


This paper proposes a formal modeling  language, that is a combination of hybrid CSP and binders from quality calculus,
 for expressing denial-of-service due to unreliable communications in hybrid systems.
With the linguistic support, it is able to build a safe hybrid system that behaves in a reasonable manner
in the presence of denial-of-service security attack. 
The idea is that, when the service from the controllers  fails, the physical
system itself needs to provide feedback control, in order to meet the safety requirements.
The paper also develops an inference system for reasoning about  such systems,
with no dependence on the behavior of the environment, and furthermore  implements an interactive theorem prover.
We illustrate our approach by considering an example taken from train control system.


The investigation of our approach to more
complex hybrid systems is one of our future work. Meanwhile, for facilitating practical applications, we will consider
to achieve more support of automated reasoning in the theorem prover.


\bibliographystyle{plain}
\bibliography{reference}







\end{document}
