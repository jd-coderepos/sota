\documentclass[preprint]{elsarticle} 
\usepackage{proof} 
\usepackage{amssymb}
\usepackage{url}
\usepackage{abbrevs}
\usepackage[margin=1in]{geometry}
\bibliographystyle{plain}

\def\Ascr{{\mathcal A}}
\def\Bscr{{\mathcal B}}
\def\Cscr{{\mathcal C}}
\def\Dscr{{\mathcal D}}
\def\Escr{{\mathcal E}}
\def\Fscr{{\mathcal F}}
\def\Gscr{{\mathcal G}}
\def\Hscr{{\mathcal H}}
\def\Iscr{{\mathcal I}}
\def\Jscr{{\mathcal J}}
\def\Kscr{{\mathcal K}}
\def\Lscr{{\mathcal L}}
\def\Mscr{{\mathcal M}}
\def\Nscr{{\mathcal N}}
\def\Oscr{{\mathcal O}}
\def\Pscr{{\mathcal P}}
\def\Qscr{{\mathcal Q}}
\def\Rscr{{\mathcal R}}
\def\Sscr{{\mathcal S}}
\def\Tscr{{\mathcal T}}
\def\Uscr{{\mathcal U}}
\def\Vscr{{\mathcal V}}
\def\Wscr{{\mathcal W}}
\def\Xscr{{\mathcal X}}
\def\Yscr{{\mathcal Y}}
\def\Zscr{{\mathcal Z}}

\newcommand\ndef[1]{{\rm def}(#1)}
\newcommand\ncontr[1]{{\rm contr}(#1)}
\newcommand\nnew[1]{{\rm new}(#1)}
\newcommand\ncoin[1]{{\omega}(#1)}
\newcommand\rank[1]{\mid #1 \mid}
\newcommand{\Momega}{\mathcal{M}_{\omega}}

\newcommand\excl[2]{{#1} \setminus \{#2\}}

\newcommand{\FOL   }{FO\lambda}
\newcommand{\FOLD  }{\FOL^{\Delta}}
\newcommand{\FOLDN }{\FOL^{\Delta\N}}
\newcommand{\FOLDNb}{\FOL^{\Delta\nabla}}
\newcommand{\FOLNb }{\FOL^{\nabla}}
\newcommand{\FOLDCo}{\FOL^{\Delta\omega}}
\newcommand{\FOLDIn}{\FOL^{\Delta{\cal I}}}
\newcommand{\FOLDCoIn}{\FOL^{\Delta{\cal CI}}}
\newcommand{\Linc}{{\rm Linc}^-}
\newcommand{\fLinc}{{\rm Linc}}
\newcommand{\Judg}[2]{#1 \triangleright #2}
\newcommand{\Ll}{L_\lambda}
\newcommand{\N}{{\rm I} \! {\rm N}}
\newcommand{\Seq}[2]{#1\longrightarrow #2}
\newcommand{\botL}{\bot{\cal L}}
\newcommand{\bulletL}{\bullet{\cal L}}
\newcommand{\bulletR}{\bullet{\cal R}}
\newcommand{\cL}{\hbox{\sl c}{\cal L}}
\newcommand{\circL}{\circ{\cal L}}
\newcommand{\circR}{\circ{\cal R}}
\newcommand{\cut}{\hbox{\sl cut}}
\newcommand{\defL}{\hbox{\sl def}{\cal L}}
\newcommand{\defR}{\hbox{\sl def}\/{\cal R}}
\newcommand{\defc}[5]{{\rm dfn}(#1,#2,#3,#4,#5)}
\newcommand{\defcp}[4]{{\rm dfn}(#1,#2,#3,#4)}
\newcommand{\defeq}{\stackrel{\scriptscriptstyle\triangle}{=}}
\newcommand{\defmu}{\stackrel{\mu}{=}}
\newcommand{\defnu}{\stackrel{\nu}{=}}
\newcommand{\defind}{\stackrel{\mu}{=}} 
\newcommand{\defcoind}{\stackrel{\nu}{=}} 
\newcommand{\dom}[1]{{\rm dom}(#1)}
\newcommand{\eqL}{{\rm eq}{\cal L}}
\newcommand{\eqR}{{\rm eq}{\cal R}}
\newcommand{\existsL}{\exists{\cal L}}
\newcommand{\existsR}{\exists{\cal R}}
\newcommand{\false}{\hbox{\sl false}}
\newcommand{\forallL}{\forall{\cal L}}
\newcommand{\forallR}{\forall{\cal R}}
\newcommand{\formula}{\hbox{\sl formula}}
\newcommand{\fst}{\rho}
\newcommand{\fv}[1]{{\rm fv}(#1)}
\newcommand{\indR}{{\rm I}{\cal R}}
\newcommand{\indRP}{{\rm I}{\cal R}_p}
\newcommand{\indL}{{\rm I}{\cal L}}
\newcommand{\indm}[1]{{\rm indm}(#1)}
\newcommand{\coindR}{{\rm CI}{\cal R}}
\newcommand{\coindL}{{\rm CI}{\cal L}}
\newcommand{\coindLP}{{\rm CI}{\cal L}_p}

\newcommand{\init}{\hbox{\sl init}}
\newcommand{\landL}{\land{\cal L}}
\newcommand{\landR}{\land{\cal R}}
\newcommand{\level}[1]{{\rm lvl}(#1)}
\newcommand{\lorL}{\lor{\cal L}}
\newcommand{\lorR}{\lor{\cal R}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\lub}[1]{{\rm lub}(#1)}
\newcommand{\mc}{\hbox{\sl mc}}
\newcommand{\measure}[1]{{\rm ht}(#1)}
\newcommand{\natL}{\hbox{\sl nat}{\cal L}}
\newcommand{\natR}{\hbox{\sl nat}{\cal R}}
\newcommand{\nat}[1]{\hbox{\sl nat} \; #1}
\newcommand{\nt}{\hbox{\sl nt}}
\newcommand{\oimpL}{\oimp{\cal L}}
\newcommand{\oimpR}{\oimp{\cal R}}
\newcommand{\oimp}{\supset}
\newcommand{\oo}{\hbox{\sl o}}
\newcommand{\ra}{\to}
\newcommand{\suc}[1]{\hbox{\sl s} \; #1}
\newcommand{\term}{\hbox{\sl term}}
\newcommand{\tm}{\hbox{\sl tm}}
\newcommand{\topR}{\top{\cal R}}
\newcommand{\true}{\hbox{\sl true}}
\newcommand{\tup}[1]{\langle #1 \rangle}
\newcommand{\wL}{\hbox{\sl w}{\cal L}}
\newcommand{\restrict}[2]{#1\!\upharpoonright \! #2}



\def\RED{{\mathbf{RED}}}
\def\NM{{\mathbf{NM}}}
\def\idrv{{\mathrm{Id}}}




\newtheorem{thm}{Theorem}
\newdefinition{definition}{Definition }
\newproof{proof}{Proof}
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{corollary}[thm]{Corollary}
\newdefinition{remark}{Remark }
\def\qed{}

\newenvironment{lemmacp}[1]{\noindent {\bf Lemma~\ref{#1}.} \em}{}

\newcommand{\conc}[2]{#1\!::\!#2}
\newcommand{\append}[3]{{\rm app}~#1~#2~#3}
\newcommand{\coappend}[3]{{\rm coapp}~#1~#2~#3}
\newcommand{\nil}{{\rm nil}}





\long\def\ednote#1{\footnote{[{\it #1\/}]}\message{ednote!}}
\newenvironment{metanote}{\begin{quote}\message{note!}[\begingroup\it}{\endgroup]\end{quote}}
\long\def\ignore#1{}
\newlength{\infwidthi}
\newlength{\infwidthii}
\journal{Journal of Applied Logic}
\begin{document}

\begin{frontmatter}


\title{Cut Elimination for a Logic with Induction and Co-induction}

\author{Alwen Tiu\corref{cor1}}

\ead{Alwen.Tiu@anu.edu.au }
\address{Logic and Computation Group\\
College of Engineering and Computer Science\\
The Australian National University}

\author{Alberto Momigliano\fnref{f1}}
\ead{amomigl1@inf.ed.ac.uk}
\address{Laboratory for Foundations of Computer Science\\
School of Informatics\\ The University of Edinburgh}

\cortext[cor1]{{Corresponding author. The Australian National
    University, Canberra, ACT 0200, Australia.  Phone: +61 (0)2 6125
    5992.  Fax: +61 (0)2 6125 8645}}

\fntext[f1]{Present address: Dipartimento di Scienze
  dell'Informazione, Universit\`{a} degli Studi di Milano, Italy.}





\begin{abstract}
  Proof search has been used to specify a wide range of computation
  systems.  In order to build a framework for reasoning about such
  specifications, we make use of a sequent calculus involving
  induction and co-induction.  These proof principles are based on a
  proof theoretic (rather than set-theoretic) notion of
  \emph{definition}~\cite{PID,eriksson91elp,schroeder-heister93lics,mcdowell00tcs}.
  Definitions are akin to logic programs, where the left and right
  rules for defined atoms allow one to view theories as ``closed'' or
  defining fixed points.  The use of definitions and free equality
  makes it possible to reason intentionally about syntax.  We add in a
  consistent way rules for pre and post fixed points, thus allowing
  the user to reason inductively and co-inductively about properties
  of computational system making full use of higher-order abstract
  syntax.  Consistency is guaranteed via cut-elimination, where we
  give the first, to our knowledge, cut-elimination procedure in the
  presence of general inductive and co-inductive definitions.
\end{abstract}


\begin{keyword}
logical frameworks\sep  (co)-induction\sep higher-order abstract syntax\sep
cut-elimination\sep parametric reducibility.
\end{keyword}
\end{frontmatter}

\section{Introduction}
\label{sec:intro}

A common approach to specifying computation systems is via deductive
systems. Those are used to specify and reason about various logics, as
well as aspects of programming languages such as operational
semantics, type theories, abstract machines \etc.  Such specifications
can be represented as logical theories in a suitably expressive formal
logic where \emph{proof-search} can then be used to model the
computation.  A logic used as a specification language is known as a
\emph{logical frameworks}~\cite{pfenning01handbook}, which comes
equipped with a representation methodology.  The encoding of the
syntax of deductive systems inside formal logic can benefit from the
use of \emph{higher-order abstract syntax} (HOAS) a high-level and declarative treatment of object-level bound variables
and substitution. At the same time, we want to use such a logic to
reason over the \emph{meta-theoretical} properties of object
languages, for example type preservation in operational
semantics~\cite{mcdowell02tocl}, soundness and completeness of
compilation~\cite{Momigliano03fos} or congruence of bisimulation in
transition systems~\cite{mcdowell03tcs}. Typically this involves
reasoning by (structural) induction and, when dealing with infinite
behavior, co-induction~\cite{Jacobs97}.

The need to support both inductive and co-inductive reasoning and some
form of HOAS requires some careful design decisions, since the two are
prima facie notoriously incompatible. While any meta-language based on
a -calculus can be used to specify and animate HOAS
encodings, meta-reasoning has traditionally involved (co)inductive
specifications both at the level of the syntax and of the judgements
--- which are of course unified at the type-theoretic level. The first
provides crucial freeness properties for datatypes constructors, while
the second offers principles of case analysis and (co)induction. This
is well-known to be problematic, since HOAS specifications may lead to
non-monotone (co)inductive operators, which by cardinality and
consistency reasons are not permitted in inductive logical
frameworks. Moreover, even when HOAS is weakened so as to be made
compatible with standard proof assistants~\cite{despeyroux94lpar} such
as HOL or Coq, the latter suffer the fate of allowing the existence of
too many functions and yielding the so called \emph{exotic}
terms. Those are canonical terms in the signature of an HOAS encoding
that do not correspond to any term in the deductive system under
study. This causes a loss of adequacy in HOAS specifications, which is
one of the pillar of formal verification, and it undermines the trust
in formal derivations. On the other hand, logics such as
LF~\cite{harper93jacm} that are weak by design in order to support this style of syntax are not directly endowed with
(co)induction principles.




The contribution of this paper lies in the design of a new logic,
called  (for a logic with -terms, induction and
co-induction),\footnote{The ``minus'' in the terminology refers to the
  lack of the -quantifier \wrt the eponymous logic in Tiu's
  thesis~\cite{tiu04phd}.} which carefully adds principles of
induction and co-induction to a higher-order intuitionistic logic
based on a proof theoretic notion of \emph{definition}, following on
work (among others) by Lars Halln{\"{a}}s~\cite{PID}, Eriksson
\cite{eriksson91elp}, Schroeder-Heister~\cite{schroeder-heister93lics}
and McDowell and Miller~\cite{mcdowell00tcs}.  Definitions are akin to
logic programs, but allow us to view theories as ``closed'' or
defining fixed points.  This alone permits to perform case analysis
independently from induction principles.  Our approach to formalizing
induction and co-induction is via the least and greatest solutions of
the fixed point equations specified by the definitions. 
The proof rules for induction and co-induction make use of the notion
of \emph{pre-fixed points} and \emph{post-fixed points}
respectively. In the inductive case, this corresponds to the induction
invariant, while in the co-inductive one to the so-called simulation.
Judgements are encoded as definitions accordingly to their informal
semantics, either inductive or co-inductive.


The simply typed language and the notion of free equality underlying
, enforced via (higher-order) unification in an inference rule,
make it possible to reason \emph{intensionally} about syntax.
In fact, we can support HOAS encodings of constants
and we can \emph{prove} the freeness properties of those constants,
namely injectivity, distinctness and case exhaustion, although they
cannot be the constructors of a (recursive)
datatype.  




 can be proved to be a conservative extension of
~\cite{mcdowell00tcs} and a generalization (with a term
language based on simply typed -calculus) of Martin-L\"of
first-order theory of iterated inductive
definitions~\cite{martin-lof71sls}. Moreover, to the best of our
knowledge, it is the first sequent calculus with a syntactical
cut-elimination theorem for co-inductive definitions.  In recent
years, several logical systems have been designed that build on the
core features of . In particular, one interesting, and
orthogonal, extension is the addition of the
-quantifier~\cite{miller05tocl,tiu04phd,Tiu07,gacek08lics},
which allows one to reason about the intentional aspects of
\emph{names and bindings} in object syntax specifications (see,
e.g.,~\cite{AbellaSOS,TiuMillerpi}).  The cut elimination
proof presented in this paper can be used as a springboard towards cut
elimination procedures for more expressive (conservative) extensions
of . 

In fact, the possibility of adapting the cut elimination proof for
 to various extensions of  with  is one of the
main reasons to introduce a \emph{direct} syntactic cut elimination
proof.  We note that there are at least a couple of indirect methods
to prove cut elimination in a logic with inductive and/or co-inductive
definitions.  The first of such methods relies on encodings of
inductive and co-inductive definitions as second-order (or
higher-order) formulae. This approach is followed in a recent work by
Baelde and Miller~\cite{baelde07lpar} where a  logic similar to 
is considered. Cut elimination in their work is proved indirectly via
an encoding into higher-order linear logic. However, in the presence
of , the existence of such an encoding is presently unknown.
The second approach is via semantical methods. This approach is taken
in a recent work by Brotherston and Simpson~\cite{BrotherstonS07},
which provide a model for
a classical first-order logic with inductive definitions, hence, cut
elimination follows  by the semantical completeness of the cut
free fragment.  It is not obvious how such semantical methods can be
adapted to prove cut elimination for extensions of  with
.  This is 
because the semantics of  itself is not yet
very well understood, although there have been some recent attempts,
see~\cite{Miculan05FOSSACS,Schoepp07LFMTP,GabbayFL}.


The present paper is an extended and revised version
of~\cite{Momigliano03TYPES}.  In the conference paper, the co-inductive
rule had a technical side condition that is restrictive and
unnatural. The restriction was essentially imposed by the particular
cut elimination proof technique outlined in that paper.  This
restriction has been removed in the present version, and the
(co-)induction rules have been generalized. For the latter, the
formulation of the rules is inspired by a second-order encoding of
least and greatest fixed points.  Consequently, we now develop a new
cut elimination proof, which is radically different from the previous
proof, using a reducibility-candidate technique, which is influenced
by Girard's strong normalisation proof for System
F~\cite{girard89book}.  This paper is concerned only with the cut
elimination proof of .  For examples and applications of
 and its extensions with , we refer the interested reader
to~\cite{tiu04phd,Bedwyr,gacek08lics,Abella,AbellaSOS,TiuMillerpi}.



The rest of the paper is organized as follows. Section~\ref{sec:linc}
introduces the sequent calculus for the logic.  Section~\ref{sec:drv}
presents two transformations of derivations that are essential to the
cut reduction rules and the cut elimination proof in subsequent
sections. Section~\ref{sec:cut-elim} is the heart of the paper: we
first (Subsection~\ref{sec:reduc}) give a (sub)set of reduction rules
that transform a derivation ending with a cut rule to another
derivation. The complete set of reduction can be found in
Appendix~\ref{app:reduc}. We then introduce the crucial notions of
\emph{normalizability} (Subsection~\ref{sec:norm}) and of
\emph{parametric reducibility} after Girard
(Subsection~\ref{sec:red}). Detailed proofs of the main lemma related
to reducibility candidates are in Appendix~\ref{app:red}.  The
central result of this paper, i.e., cut elimination, is proved in
details in Subsection~\ref{sec:ceproof}. Section~\ref{sec:lrel} surveys the related work and
concludes the paper.

\section{The Logic }
\label{sec:linc}


\begin{figure}

\dotfill\\\paragraph{Equality rules}

\dotfill\\\paragraph{Induction rules}


\dotfill\
\infer[\coindL, p\,\vec x \defnu B\,p\,\vec x]
{\Seq{p\,\vec{t}, \Gamma}{C}} {\Seq{B\,X^p\,\vec{t}, \Gamma}{C} }
\qquad\qquad \infer[\coindLP, p\,\vec x \defnu B\,p\,\vec x]
{\Seq{X^p\,\vec{t}, \Gamma}{C}} {\Seq{B\,X^p\,\vec{t}, \Gamma}{C} }

\infer[\coindR, p\,\vec x \defnu B\,p\,\vec x]
{\Seq{\Gamma}{p\,\vec{t}}} {\Seq{\Gamma}{S\,\vec{t}} &
  \Seq{S\,\vec{y}}{B\,S\,\vec{y}} }

s, t ::= x_\tau \mid (\lambda x_\tau.\ t) \mid (s~t)

  \tau \mathrel{::= }   k \mid \tau \rightarrow \tau\\

\begin{array}{rcl}
  F &\mathrel{::= } &  X^p\,\vec t \mid s =_\tau t \mid p\,\vec t   \mid 
  \bot \mid \top \mid F \land F \mid F \lor F \mid F \oimp T
  \mid \forall_\tau x. F \mid \exists_\tau x. F.
\end{array}

\infer[\forallR] {\Seq {} {\forall x.\ z = (s~x) \oimp \bot}} {
  \infer[\oimpR] {\Seq{}{z = (s~y) \oimp \bot}} {\infer[\eqL] {\Seq
      {z = (s~y)} {\bot}} {} } }

\forall \vec x.\ p\,\vec x \defeq B\,p\,\vec x
ev~x \defmu (x = z) \lor (\exists y.\ x = (s~(s~y)) \land ev~y)

p \defmu B\,p \qquad \leadsto \qquad \forall p. (B\,p \oimp p) \oimp p

p \defnu B\,p \qquad \leadsto \qquad \exists p. p \land (p \oimp
B\,p).

\infer[\indR, p \defmu B\,p] {\Seq{\Gamma}{p} } {\Seq{B\,X^p \oimp
    X^p, \Gamma}{X^p} }

\infer[\indR', p\,\vec x \defmu B\,p\,\vec x] {\Seq{\Gamma}{p\,\vec
    t}} {\Seq{\Gamma}{B\,p\,\vec t} }

\infer[mc] {\Seq{\Gamma}{p\,\vec t}} {\Seq{\Gamma}{B\,p\,\vec t} &
  \infer[\indR] {\Seq{B\,p\,\vec t}{p\,\vec t}} {\infer[]
    {\Seq{B\,p\,\vec t}{B\,X^p\,\vec t}} {\deduce{\vdots} {
        \infer[\indL] {\Seq{p\,\vec u}{X^p\,\vec u}} {\infer[\indRP]
          {\Seq{B\,X^p\,\vec x}{X^p\,\vec x}} {\infer[init]
            {\Seq{B\,X^p\,\vec x}{B\,X^p\,\vec x}} {} } & \infer[init]
          {\Seq{X^p\,\vec u}{X^p\,\vec u}}{} } } } } }

\forall x.\ ev~x \defmu (x = z) \lor (\exists y. x = (s~y) \land (ev~y
\oimp \bot))

\infer[subst.]
{\Seq{\Gamma}{C}}
{
\{ \Seq{\Gamma\theta}{C\theta}\}_\theta
}

\infer[mc]
{\Seq{\Gamma}{C}}
{
\infer[\eqR]
{\Seq{}{t=t}}{}
&
\infer[\eqL]
 {\Seq{t=t,\Gamma}{C}}
 {
  \{\Seq{\Gamma\theta}{C\theta}\}_\theta
 }
}

\infer[subst]
{\Seq{\Delta}{B}}
{
\left\{
\raisebox{-1.3ex}{
\deduce{\Seq{\Delta\theta}{B\theta}}{\Pi^\theta}
}
\right\}_\theta
}

      \infer[\eqL]{\Seq {s = t,\Gamma'}{C} }
      {\left\{\raisebox{-1.5ex}
          {\deduce{\Seq{\Gamma'\rho}{C\rho}}
            {\Pi^{\rho}}}
        \right\}_{\rho}}
      \enspace 
    
      \infer[\eqL]{\Seq{s\theta = t\theta,\Gamma'\theta}{C\theta}}
      {\left\{\raisebox{-1.5ex}
          {\deduce{\Seq{\Gamma'\theta\rho'}{C\theta\rho'}}
            {\Pi^{\theta\circ\rho'}}}
	\right\}_{\rho'}}
      \enspace ,
    
\Theta(X^p) = (\Pi_S, S)

supp(\Theta) = \{X^p \mid \Theta(X^p) \hbox{ is defined} \}.

[(\Pi_1,S_1)/X^{p_1}, \ldots, (\Pi_n, S_n)/ X^{p_n}]

C[S_1/X^{p_1}, \ldots, S_n/X^{p_n}].

\infer[\indRP] 
{\Seq \Gamma {X^p \vec t}} 
{\deduce{\Seq \Gamma {B\,X^p \vec t}}{\Pi'}}
\qquad
\infer[mc] {\Seq {\Gamma\Theta}{S\,\vec t}} { \deduce{\Seq
    {\Gamma\Theta}{B\,S\,\vec t}}{\Pi'\Theta} & \deduce{\Seq
    {B\,S\,\vec t}{S\,\vec t}}{\Pi_S[\vec t/\vec x]} }

\infer[\coindLP] {\Seq {X^p \vec t, \Gamma'}{C}} {
  \deduce{\Seq{B\,X^p\vec t, \Gamma'}{C}}{\Pi'} }

\infer[mc] {\Seq{S\,\vec t, \Gamma'\Theta}{C\Theta}} { \infer[mc]
  {\Seq {S\,\vec t}{B\,S\,\vec t}} { \infer[init] {\Seq {S\,\vec
        t}{S\,\vec t}}{} & \deduce{\Seq {S\,\vec t}{B\,S\,\vec
        t}}{\Pi_S[\vec t/\vec x]} } & \deduce{\Seq{B\,S\,\vec t,
      \Gamma'\Theta}{C\Theta}}{\Pi'\Theta} }

\infer[mc.]  {\Seq {S\,\vec t}{B\,S\,\vec t}} { \infer[init] {\Seq
    {S\,\vec t}{S\,\vec t}}{} & \deduce{\Seq {S\,\vec t}{B\,S\,\vec
      t}}{\Pi_S[\vec t/\vec x]} }

\infer[mc] {\Seq {B\,S\,\vec t}{S\,\vec t}} { \deduce{\Seq {B\,S\,\vec
      t}{S\,\vec t}}{\Pi_S[\vec t/\vec x]} & \infer[init] {\Seq
    {S\,\vec t}{S\,\vec t}}{} }

\infer[\mc] {\Seq{\Delta, \Gamma}{C} } { \infer[\indR]
  {\Seq{\Delta}{p\,\vec t}} { \deduce{\Seq{\Delta}{B\,X^p\,\vec t}}{\Pi_1} } &
  \infer[\indL] {\Seq{p\,\vec t, \Gamma}{C}} {
    \deduce{\Seq{B\,S\,\vec y}{S\,\vec y}}{\Pi_B} & \deduce{\Seq{S\,\vec t,
        \Gamma}{C}}{\Pi} } }

\infer[mc] {\Seq{\Delta_1, \ldots, \Delta_n, \Gamma }{C}} {
  \deduce{\Seq {\Delta_1}{B_1}}{\Pi_1} & \cdots & \deduce{\Seq
    {\Delta_n}{B_n}}{\Pi_n} & \deduce{\Seq {\Gamma}{C}}{\Pi} }
\enspace

\infer[init]
{\Seq {B}{B}}{}

    \infer[\mc]{\Seq{\Delta_1,\ldots,\Delta_n,\Gamma}{C}}
    {\deduce{\Seq{\Delta_1}{B_1}}
      {\Pi_1}
      & \cdots
      & \deduce{\Seq{\Delta_n}{B_n}}
      {\Pi_n}
      & \deduce{\Seq{B_1,\ldots,B_n,\Gamma}{C}}
      {\Pi}}
    \enspace 
  
    \infer[\eqR]{\Seq{\Delta_1}{s = t}}
    {}
    \qquad\qquad\qquad
    \infer[\eqL]{\Seq{s=t,B_2,\ldots,B_n,\Gamma}{C}}
    {\left\{\raisebox{-1.5ex}
        {\deduce{\Seq{B_2\rho,\ldots,B_n\rho,\Gamma\rho}
            {C\rho}}
          {\Pi^\rho}}
      \right\}_\rho}
    \enspace 
  
  \infer=[\wL]
  {\Seq{\Delta_1,\Delta_2,\ldots,\Delta_n,\Gamma}{C}}
  {\deduce{\Seq{\Delta_2,\ldots,\Delta_n,\Gamma}{C}}{\Xi_1}}
  
\infer[\indR]
{\Seq {\Delta_1}{p\,\vec t}}
{
 \deduce{\Seq{\Delta_1}{D\,X^p\,\vec t}}{\Pi_1'}
}
\qquad
\infer[\indL] {\Seq{p\,\vec{t}, B_2,\dots,B_n,\Gamma}{C}} {
  \deduce{\Seq{D\,S\,\vec{y}}{S\,\vec{y}}}{\Pi_S} &
  \deduce{\Seq{S\,\vec{t}, B_2,\dots,B_n, \Gamma} {C}}{\Pi'} }

mc(mc(\Pi_1'p[(\Pi_S,S)/X^p], \Pi_S[\vec t/\vec y]), \Pi_2,\ldots,\Pi_n,\Pi').

\infer[\coindR] 
{\Seq{\Delta_1}{p\,\vec{t}}} 
{
  \deduce{\Seq{\Delta_1}{S\,\vec{t}}}{\Pi_1'} &
  \deduce{\Seq{S\,\vec{y}}{D\,S\,\vec{y}}}{\Pi_S} 
} 
\qquad \qquad
\infer[\coindL] 
{\Seq{p\,\vec{t}, \dots, \Gamma}{C}}
{
  \deduce{\Seq{D\,X^p\,\vec{t},\dots, \Gamma}{C}}{\Pi'}
}

mc(mc(\Pi_1', \Pi_S[\vec t/\vec y]), \Pi_2,\ldots,\Pi_n,\Pi'[(\Pi_S,S)/X^p]).

\infer[\indL] {\Seq{p\,\vec{t}, \Delta_1'}{B_1}} {
  \deduce{\Seq{D\,S\,\vec{y}}{S\,\vec{y}}}{\Pi_S} &
  \deduce{\Seq{S\,\vec{t}, \Delta_1'}{B_1}}{\Pi_1'} }

\infer[\indL] {\Seq{p\,\vec{t}, \Delta_1',\dots,\Delta_n}{C}} {
  \deduce{\Seq{D\,S\,\vec{y}}{S\,\vec{y}}}{\Pi_S} &
  \deduce{\Seq{S\,\vec{t}, \Delta_1',\dots,\Delta_n,\Gamma}{C}}{\Xi_1}
}

\infer[\indL] {\Seq{B_1,\dots,B_n, p\,\vec{t},\Gamma'} {C}} {
  \deduce{\Seq{D\,S\,\vec{y}}{S\,\vec{y}}}{\Pi_S} &
  \deduce{\Seq{B_1,\dots,B_n, S\,\vec{t}, \Gamma'}{C}}{\Pi'} }
\enspace ,

\infer[\indL] {\Seq{\Delta_1,\dots,\Delta_n, p\,\vec{t},\Gamma'}{C}} {
  \deduce{\Seq{D\,S\,\vec{y}}{S\,\vec{y}}}{\Pi_S} &
  \deduce{\Seq{\Delta_1,\dots,\Delta_n, S\,\vec{t}, \Gamma'}{C}}{\Xi_1}
} \enspace 

\infer[\coindR] {\Seq{B_1,\dots,B_n,\Gamma}{p\,\vec{t}}} {
  \deduce{\Seq{B_1,\dots,B_n,\Gamma} {S\,\vec{t}}}{\Pi'} &
  \deduce{\Seq{S\,\vec{y}}{D\,S\,\vec{y}}}{\Pi_S} } \enspace ,

\infer[\coindR] {\Seq{\Delta_1,\dots,\Delta_n,\Gamma}{p\,\vec{t}}} {
  \deduce{\Seq{\Delta_1,\dots,\Delta_n,\Gamma} {S\,\vec{t}}}{\Xi_1} &
  \deduce{\Seq{S\,\vec{y}}{D\,S\,\vec{y}}}{\Pi_S} } \enspace

nd(\Pi) = 1 + \lub {\{nd(\Pi') \mid \Pi' \hbox{is a predecessor of
    }\}}

\Sscr\,\vec u = \{\Pi \in \Sscr \mid \hbox{ has type 
} \}

\NM_S = \{\Pi \mid \Pi\in\NM\ \hbox{and is of type  for
  some } \}.

\Theta(X^p) = (\Pi, S) \ \hbox{iff } \Omega(X^p) = (\Rscr, \Pi, S) \
\hbox{for some }.

\{\RED_C[\Omega] \}_{C \in \Fscr_k}

    \infer[\oimpR] 
          {\Seq \Gamma {B\Omega \oimp D\Omega}} 
          {\deduce{\Seq{\Gamma, B\Omega}{D\Omega}}{\Pi'} }
    
    \infer[\indR, \hbox{where }]
    {\Seq \Gamma {p\,\vec t} }
    {\deduce{\Seq \Gamma {B\,X^p\,\vec t}}{\Pi'}}
    
    \Pi_I[\vec u/ \vec y] \in (\RED_{(B\,X^p\,\vec u)}[\Omega, (\Sscr,
    \Pi_I, I)/X^p] \Rightarrow \Sscr~\vec u) 
    mc(\Pi'[(\Pi_I,I)/X^p], \Pi_I[\vec t/\vec y])  \in \Sscr\,\vec t
  \infer[\coindR, \hbox{where  }]
  {\Seq \Gamma {p\,\vec t} }
  {
    \deduce{\Seq \Gamma {I\,\vec t}}{\Pi'}
    &
    \deduce{\Seq {I\,\vec y}{B\,I\,\vec y}}{\Pi_I}
  }
  
  \Pi_I[\vec u/ \vec y] \in (\Sscr\,\vec u \Rightarrow
  \RED_{B\,X^p\,\vec u}[\Omega, (\Sscr, \Pi_I, I)/X^p]) \ \hbox{for every
    .  }
  
    \infer[\indR, \hbox{where }]
    {\Seq \Gamma {p} }
    {\deduce{\Seq \Gamma {B\,X^p}}{\Pi'}}
    \RED_{B\,X^p}[\Omega, (\Sscr, \Pi_I, I)/X^p] \Rightarrow \Sscr
\Rscr = \{\Pi \mid \Pi \in \RED_{F\,\vec u}[\Omega] \ \hbox{for some } \}

\Rscr = \{\Pi \mid \Pi \in \RED_{S\,\vec u}[\Omega] \ \hbox{for some } \}.

\RED_{C[S/X^p]}[\Omega] = \RED_C[\Omega, (\Rscr, \Psi, S\Omega)/X^p].

\Pi_S[\vec u/\vec x] \in \RED_{B\,X^p\,\vec u}\, [\Omega] \Rightarrow
\Rscr\,\vec u.

\Pi_S[\vec u/\vec x] \in \Rscr\,\vec u \Rightarrow \RED_{B\,X^p\,\vec
  u}\, [\Omega].
\Pi_S[\vec u/\vec x] \in \RED_{B\,X^p\,\vec u}\, [\Omega] \Rightarrow
\Rscr\,\vec u
\Pi_I[\vec t/\vec x] \in \RED_{B\,Y^q\,\vec t}\, [\Omega] \Rightarrow
\Sscr\,\vec t

\Pi_I[\vec t/\vec x] \in \RED_{B\,Y^q\,\vec t}\, [\Omega'] \Rightarrow
\Sscr\,\vec t
\Pi_S[\vec u/\vec x] \in \Rscr \,\vec u \Rightarrow
\RED_{B\,X^p\,\vec u}\, [\Omega]
\deduce{\Seq{\Delta_1}{B_1\Omega}}{\Pi_1}, \quad \ldots
\quad,~\deduce{\Seq{\Delta_n}{B_n\Omega}}{\Pi_n} 

  \infer[\mc]{\Seq{\Delta_1,\ldots,\Delta_n,\Gamma\Omega}{C\Omega}}
  {\deduce{\Seq{\Delta_1}{B_1\Omega}}
    {\Pi_1}
    & \cdots
    & \deduce{\Seq{\Delta_n}{B_n\Omega}}
    {\Pi_n}
    & \deduce{\Seq{B_1\Omega,\ldots,B_n\Omega,\Gamma\Omega}{C\Omega}}
    {\Pi\Omega}}

\Mscr(\Xi) = \langle \measure{\Pi}, \sum_{i=1}^n |B_i|,
ND(\Xi) \rangle

\infer[\coindLP.]  {\Seq {Y^q\,\vec u, \Gamma}{C}} { \deduce{\Seq
    {D\,Y^q\,\vec u, \Gamma}{C}}{\Pi'} }

\left\{ \hbox{} \right\}_{i \in  I}

\infer[\indRP] {\Seq{\Gamma}{X^p\vec t}} { \deduce{\Seq \Gamma
    {D\,X^p\,\vec t}}{\Pi'} }

\infer[\oimpR] {\Seq \Gamma {C_1 \oimp C_2}} { \deduce{\Seq {\Gamma,
      C_1}{C_2}}{\Pi'} }
\qquad
\infer[\oimpR] {\Seq {\Gamma\Omega} {C_1\Omega \oimp C_2\Omega}} {
  \deduce{\Seq {\Gamma\Omega, C_1\Omega}{C_2\Omega}}{\Pi'\Omega} }

  \label{eq:ce1}
  \Pi'\Omega\theta \in \RED_{C_1\theta}[\Omega] \Rightarrow \RED_{C_2\theta}[\Omega] 

\infer[\indR] {\Seq{\Gamma}{p\,\vec t}} { \deduce{\Seq \Gamma
    {D\,X^p\,\vec t}}{\Pi'} }
\qquad
\infer[\indR] {\Seq{\Gamma\Omega}{p\,\vec t}} { \deduce{\Seq
    {\Gamma\Omega}{D\,X^p \,\vec t}}{\Pi'\Omega} }

  \label{eq:caseI3-a}
  mc((\Pi'\Omega)[(\Pi_S,S)/X^p], \Pi_S[\vec t/\vec x]) \in \Rscr\,\vec t

  \label{eq:caseI3-b}
  \Pi_S[\vec u/\vec x] \in \RED_{D\,X^p\,\vec u}\, [\Omega, (\Rscr,\Pi_S,S)/X^p]
  \Rightarrow \Rscr\,\vec u
  \hbox{ for every .}

  \label{eq:caseI3-c}
  mc(\Pi'\Omega', \Pi_S[\vec t/\vec x]) \in \Rscr\,\vec t. 

\infer[\coindR] {\Seq \Gamma {p\,\vec t}} { \deduce{\Seq \Gamma
    {S\,\vec t}}{\Pi'} & \deduce{\Seq {S\,\vec x}{D\,S\,\vec
      x}}{\Pi_S} }
\qquad
\infer[\coindR] {\Seq {\Gamma\Omega} {p\,\vec t}} { \deduce{\Seq
    {\Gamma\Omega}{S'\,\vec t}}{\Pi'\Omega} & \deduce{\Seq {S'\vec
      x}{D\,S'\,\vec x}}{\Pi_S\Omega} }

\Pi_S\Omega[\vec u/\vec x] \in \RED_{S\,\vec u}\, [\Omega] \Rightarrow
\RED_{D\,S\,\vec u}\, [\Omega].

\Pi_S\Omega[\vec u/\vec x] \in \Rscr\,\vec u \Rightarrow
\RED_{D\,S\,\vec u}\, [\Omega].

\infer[\oimpR] {\Seq{\Delta_1}{B_1'\Omega \oimp B_1''\Omega}} {
  \deduce{\Seq{\Delta_1,B_1'\Omega}{B_1''\Omega}}{\Pi_1'} } \qquad
\infer[\oimpL.]  {\Seq{B_1'\oimp B_1'',B_2,\dots, B_n,\Gamma}{C}} {
  \deduce{\Seq{B_2,\dots,\Gamma}{B_1'}}{\Pi'} &
  \deduce{\Seq{B_1'',B_2,\dots,\Gamma}{C}}{\Pi''} }

\Pi_1' \in \RED_{B_1'}[\Omega] \Rightarrow \RED_{B_1''}[\Omega]

  \infer=[\cL]
  {\Seq{\Delta_1,\ldots,\Delta_n,\Gamma\Omega}{C\Omega}}
  {
    \deduce
    {\Seq{\Delta_1,\ldots, \Delta_n,\Gamma\Omega,
        \Delta_2,\ldots, \Delta_n,\Gamma\Omega}
      {C\Omega}
    }
    {\Xi_3}
  }

\infer[\forallR] {\Seq{\Delta_1}{\forall x.B_1'\Omega}} {
  \deduce{\Seq{\Delta_1}{B_1'\Omega[y/x]}}{\Pi_1'} } \qquad \qquad
\infer[\forallL] {\Seq{\forall x.B_1',B_2,\dots,B_n,\Gamma}{C}} {
  \deduce{\Seq{B_1'[t/x],B_2,\dots,B_n,\Gamma}{C}}{\Pi'} }

\Xi' = mc(\Pi_1'[t/y], \Pi_2, \ldots, \Pi_n, \Pi'\Omega).
\Pi_1'[t/y] \in \RED_{B_1'[t/x]}[\Omega]
\infer[\eqR] {\Seq{\Delta_1}{s = t}} {} \qquad \qquad \infer[\eqL]
{\Seq{s = t,\dots,B_n,\Gamma}{C}} {\left\{\raisebox{-1.5ex} {
      \deduce{\Seq{B_2\rho,\dots,B_n\rho,\Gamma\rho}{C\rho}}
      {\Pi^\rho} } \right\}_\rho }

\infer[subst]
{\Seq{B_2,\ldots,B_n,\Gamma}{C}}
{
\left\{
\raisebox{-1.3ex}{
\deduce{\Seq{B_2\rho,\ldots,B_n\rho,\Gamma\rho}{C\rho}}{\Pi^\rho}
}
\right\}_\rho
}

\infer=[\wL]
{\Seq{\Delta_1,\Delta_2,\ldots,\Delta_n,\Gamma}{C}}
{
\deduce{\Seq{\Delta_2,\ldots,\Delta_n,\Gamma}{C}}{\Xi_1}
}

\infer[\indR] {\Seq {\Delta_1} {p\,\vec t}} { \deduce{\Seq
    {\Delta_1}{D\,X^p\,\vec t}}{\Pi_1'} } \qquad \infer[\indL]
{\Seq{p\,\vec{t}, \Gamma}{C}} {
  \deduce{\Seq{D\,S\,\vec{x}}{S\,\vec{x}}}{\Pi_S} &
  \deduce{\Seq{S\,\vec{t}, \Gamma}{C}}{\Pi'} }

\infer[\indL] {\Seq{p\,\vec{t}, \Gamma\Omega}{C\Omega}} {
  \deduce{\Seq{D\,S'\,\vec{x}}{S'\,\vec{x}}}{\Pi_S\Omega} &
  \deduce{\Seq{S'\,\vec{t}, \Gamma\Omega}{C\Omega}}{\Pi'\Omega} }

\Xi' = mc(\Xi_1,\Pi_2,\ldots,\Pi_n, \Pi'\Omega).

  \label{eq:caseII.1-a}
  \Pi_S\Omega[\vec u/\vec x] \in \RED_{D\,S\,\vec u}\, [\Omega] \Rightarrow \RED_{S\,\vec u}\, [\Omega].

\RED_{D\,S\,\vec u}\, [\Omega] = \RED_{D\,X^p\,\vec u}\, [\Omega, (\Rscr,
\Pi_S\Omega,S')/X^p].

  \label{eq:caseII.1-b}
  \Pi_S\Omega[\vec u/\vec x] \in \RED_{D\,X^p\,\vec u}\, [\Omega, (\Rscr, \Pi_S\Omega,S')/X^p] \Rightarrow \Rscr \,\vec u

\Pi_I[\vec u/\vec x] \in \RED_{D\,X^p\,\vec u}\, [\Omega, (\Sscr,
\Pi_I,I)/X^p] \Rightarrow \Sscr\,\vec u \hbox{ for every , }

mc(\Pi_1'[(\Pi_I,I)/X^p], \Pi_I[\vec t/\vec x]) \in \Sscr\,\vec t.

\Xi_1 = mc(\Pi_1'[(\Pi_S\Omega,S')/X^p], \Pi_S\Omega[\vec t/\vec x])
\in \Rscr\,\vec t = \RED_{S\,\vec t}\, [\Omega].

\infer[\coindR] {\Seq{\Delta_1}{p\,\vec{t}}} {
  \deduce{\Seq{\Delta_1}{S\,\vec{t}}}{\Pi_1'} &
  \deduce{\Seq{S\,\vec{x}}{D\,S\,\vec{x}}}{\Pi_S} } \qquad \qquad
\infer[\coindL] {\Seq{p\,\vec{t}, B_2, \dots, \Gamma}{C}}
{\deduce{\Seq{D\,X^p\,\vec{t},B_2,\dots, \Gamma}{C}}{\Pi'}}

\infer[\coindL.]  {\Seq{p\,\vec{t}, B_2\Omega, \dots,
    \Gamma\Omega}{C\Omega}}
{\deduce{\Seq{D\,X^p\,\vec{t},B_2\Omega,\dots,
      \Gamma\Omega}{C\Omega}}{\Pi'\Omega}}

\Pi_S[\vec u/\vec x] \in \Rscr\,\vec u \Rightarrow \RED_{D\,X^p\,\vec
  u}\, [\Omega, (\Rscr,\Pi_S,S)/X^p)].

\Xi' = mc(\Xi_1,\Pi_2,\ldots,\Pi_n,\Pi'\Omega').

\Pi_i \in \RED_{B_i}[\Omega] = \RED_{B_i}[\Omega']

\Xi' \in \RED_C[\Omega'].

\Xi' \in \RED_C[\Omega].

\infer[\oimpL] {\Seq{D_1 \oimp D_2,\Delta_1'}{B_1\Omega}} {
  \deduce{\Seq{\Delta_1'}{D_1}}{\Pi_1'} &
  \deduce{\Seq{D_2,\Delta_1'}{B_1\Omega}}{\Pi_1''} }

  \infer[\oimpL]
  {\Seq{D_1 \oimp D_2,\Delta_1',\Delta_2,\ldots,\Gamma\Omega}{C\Omega}}
  {
    \infer=[\wL]
    {\Seq{\Delta_1',\ldots,\Gamma\Omega}{D_1}}
    {
      \deduce{\Seq{\Delta_1'}{D_1}}{\Pi_1'} 
    }
    &
    \deduce{\Seq{D_2,\Delta_1',\Delta_2,\ldots,\Gamma\Omega}{C\Omega}}
    {\Xi_1}
  }

\infer[\eqL]{\Seq{s=t,\Delta_1'}{B_1\Omega}} {\left\{\raisebox{-1.5ex}
    {\deduce{\Seq{\Delta_1'\rho}{B_1\Omega\rho}} {\Pi^{\rho}}}
  \right\}_{\rho}}
\qquad
\infer[\eqL]
{\Seq{s=t,\Delta_1',\Delta_2,\dots,\Gamma\Omega}{C\Omega}}
{\left\{\raisebox{-1.5ex}
    {\deduce{\Seq{\Delta_1'\rho,\dots,\Gamma\Omega\rho}{C\Omega\rho}}
      {\Xi^{\rho}}} \right\}_{\rho}}

\infer[\indL.]  {\Seq{p\,\vec{t}, \Delta_1'}{B_1\Omega}} {
  \deduce{\Seq{D\,S\,\vec{x}}{S\,\vec{x}}}{\Pi_S} &
  \deduce{\Seq{S\,\vec{t}, \Delta_1'}{B_1\Omega}}{\Pi_1'} }

mc(\Pi_1',\Pi_2,\ldots,\Pi_n,\Pi\Omega).

\infer[\indL] {\Seq{p\,\vec{u},\Delta_1',
    \dots,\Delta_n,\Gamma\Omega}{C\Omega}} {
  \deduce{\Seq{D\,S\,\vec{x}}{S\,\vec{x}}}{\Pi_S} &
  \deduce{\Seq{S\,\vec{u},\Delta_1',
      \ldots,\Delta_n,\Gamma\Omega}{C\Omega}}{\Xi_1} }

\infer[\coindLP] {\Seq{X^p\,\vec t, B_2, \ldots, B_n, \Gamma}{C}} {
  \deduce{\Seq{D\,X^p\,\vec t, B_2,\ldots, B_n, \Gamma}{C}}{\Pi'} }

\Xi_2 = mc(mc(\Pi_1,\idrv_{S\,\vec t}), \Pi_S[\vec t/\vec x]).

\infer[\indRP] {\Seq{B_1,\ldots,B_n,\Gamma}{X^p\,\vec t}} {
  \deduce{\Seq{B_1,\ldots,B_n,\Gamma}{D\,X^p\,\vec t}}{\Pi'} }

\Xi' = mc(mc(\Pi_1,\ldots,\Pi_n,\Pi'\Omega), \Pi_S[\vec t/\vec x]).

\infer[\indR] {\Seq{B_1,\ldots,B_n,\Gamma}{p\,\vec t}} {
  \deduce{\Seq{B_1,\ldots,B_n,\Gamma}{D\,X^p\,\vec t}}{\Pi'} }

\infer[\indR .]  {\Seq{\Delta_1,\ldots,\Delta_n,\Gamma\Omega}{p\,\vec
    t}} {
  \deduce{\Seq{\Delta_1,\ldots,\Delta_n,\Gamma\Omega}{D\,X^p\,\vec
      t}}{\Xi_1} }

\Xi_2 = mc(\Xi_1[(\Pi_S,S)/X^p], \Pi_S[\vec t/\vec x]) \in \Rscr\,\vec
t

  \label{eq:II.7.a.1}
  \Pi_S[\vec u/\vec x] \in \RED_{D\,X^p\,\vec u}\, [\Omega, (\Rscr,\Pi_S,S)/X^p] \Rightarrow \Rscr\,\vec u,
  \hbox{ for every .}

\Xi_1[(\Pi_S,S)/X^p] = mc(\Pi_1,\ldots,\Pi_n,\Pi'\Omega') \in
\RED_{D\,X^p\,\vec t}\, [\Omega'].

\infer[\coindLP] {\Seq{B_1,\ldots,B_n, X^p\,\vec t, \Gamma'}{C}} {
  \deduce{\Seq{B_1,\ldots,B_n, D\,X^p\,\vec t, \Gamma'}{C}}{\Pi'} }

mc(mc(\idrv_{S\,\vec t}, \Pi_S[\vec t/\vec x]),\Pi'\Omega).

mc(\Xi_1,\Pi_1,\ldots,\Pi_n,\Pi'\Omega)

\infer[\coindR] {\Seq{B_1,\dots,B_n,\Gamma}{p\,\vec{t}}} {
  \deduce{\Seq{B_1,\dots,B_n,\Gamma}{S\,\vec{t}}}{\Pi'} &
  \deduce{\Seq{S\,\vec{x}}{D\,S\,\vec{x}}}{\Pi_S} } \enspace 

\infer[\coindR]
{\Seq{B_1\Omega,\dots,B_n\Omega,\Gamma\Omega}{p\,\vec{t}}} {
  \deduce{\Seq{B_1\Omega,\dots,B_n\Omega,\Gamma\Omega}{S'\,\vec{t}}}{\Pi'\Omega}
  & \deduce{\Seq{S'\,\vec{x}}{D\,S'\,\vec{x}}}{\Pi_S\Omega} }

\infer[\coindR .]
{\Seq{\Delta_1,\dots,\Delta_n,\Gamma\Omega}{p\,\vec{t}}} {
  \deduce{\Seq{\Delta_1,\dots,\Delta_n,\Gamma\Omega}{S'\,\vec{t}}}{\Xi_1}
  & \deduce{\Seq{S'\,\vec{x}}{D\,S'\,\vec{x}}}{\Pi_S\Omega} }

      \infer[\landR]{\Seq{\Delta_1}{B_1' \land B_1''}}
      {\deduce{\Seq{\Delta_1}{B_1'}}
        {\Pi_1'}
	& \deduce{\Seq{\Delta_1}{B_1''}}
        {\Pi_1''}}
      \qquad\qquad
      \infer[\landL]{\Seq{B_1' \land B_1'',B_2,\ldots,B_n,\Gamma}{C}}
      {\deduce{\Seq{B_1',B_2,\ldots,B_n,\Gamma}{C}}
        {\Pi'}}
      \enspace ,
    
      \infer[\lorR]{\Seq{\Delta_1}{B_1' \lor B_1''}}
      {\deduce{\Seq{\Delta_1}{B_1'}}
        {\Pi_1'}}
      \quad
      \infer[\lorL]{\Seq{B_1' \lor B_1'',B_2,\ldots,B_n,\Gamma}{C}}
      {\deduce{\Seq{B_1',B_2,\ldots,B_n,\Gamma}{C}}
        {\Pi'}
	& \deduce{\Seq{B_1'',B_2,\ldots,B_n,\Gamma}{C}}
        {\Pi''}}      
    
      \infer[\oimpR]{\Seq{\Delta_1}{B_1' \oimp B_1''}}
      {\deduce{\Seq{B_1',\Delta_1}{B_1''}}
        {\Pi_1'}}
      \qquad
      \infer[\oimpL]{\Seq{B_1' \oimp B_1'',B_2,\ldots,B_n,\Gamma}{C}}
      {\deduce{\Seq{B_2,\ldots,B_n,\Gamma}{B_1'}}
        {\Pi'}
	& \deduce{\Seq{B_1'',B_2,\ldots,B_n,\Gamma}{C}}
        {\Pi''}}
      \enspace 
    
      \infer=[\cL]
      {\Seq{\Delta_1,\ldots,\Delta_n,\Gamma}{C}}
      {
        \infer[\mc]
        {\Seq{\Delta_1,\ldots,\Delta_n,\Gamma, \Delta_2,\ldots,\Delta_n,\Gamma}{C}}
        {
          \raisebox{-2.5ex}{\deduce{\Seq{\ldots}{B_1''}}{\Xi_1}}
          & 
          \left\{\raisebox{-1.5ex}{\deduce{\Seq{\Delta_i}{B_i}}{\Pi_i}}\right\}_{i \in \{2..n\}}
          & \raisebox{-2.5ex}{\deduce{\Seq{B_1'',\{B_i\}_{i \in \{2..n\}},\Gamma}{C}}{\Pi''}}
        }
      }
      \enspace 
    
      \infer[\forallR]{\Seq{\Delta_1}{\forall x.B_1'}}
      {\deduce{\Seq{\Delta_1}{B_1'[y/x]}}
        {\Pi_1'}}
      \qquad\qquad\qquad
      \infer[\forallL]{\Seq{\forall x.B_1',B_2,\ldots,B_n,\Gamma}{C}}
      {\deduce{\Seq{B_1'[t/x],B_2,\ldots,B_n,\Gamma}{C}}
        {\Pi'}}
      \enspace ,
    
      \infer[\existsR]{\Seq{\Delta_1}{\exists x.B_1'}}
      {\deduce{\Seq{\Delta_1}{B_1'[t/x]}}
        {\Pi_1'}}
      \qquad\qquad\qquad
      \infer[\existsL]{\Seq{\exists x.B_1',B_2,\ldots,
          B_n,\Gamma}{C}}
      {\deduce{\Seq{B_1'[y/x],B_2,\ldots,B_n,
	    \Gamma}{C}}
        {\Pi'}}
      \enspace ,
    
\infer[\indR]
{\Seq {\Delta_1}{p\,\vec t}}
{
 \deduce{\Seq{\Delta_1}{D\,X^p\,\vec t}}{\Pi_1'}
}
\qquad
\infer[\indL] {\Seq{p\,\vec{t}, B_2,\dots,B_n,\Gamma}{C}} {
  \deduce{\Seq{D\,S\,\vec{y}}{S\,\vec{y}}}{\Pi_S} &
  \deduce{\Seq{S\,\vec{t}, B_2,\dots,B_n, \Gamma} {C}}{\Pi'} }

mc(mc(\Pi_1'p[(\Pi_S,S)/X^p], \Pi_S[\vec t/\vec y]), \Pi_2,\ldots,\Pi_n,\Pi').

\infer[\coindR] 
{\Seq{\Delta_1}{p\,\vec{t}}} 
{
  \deduce{\Seq{\Delta_1}{S\,\vec{t}}}{\Pi_1'} &
  \deduce{\Seq{S\,\vec{y}}{D\,S\,\vec{y}}}{\Pi_S} 
} 
\qquad \qquad
\infer[\coindL] 
{\Seq{p\,\vec{t}, \dots, \Gamma}{C}}
{
  \deduce{\Seq{D\,X^p\,\vec{t},\dots, \Gamma}{C}}{\Pi'}
}

mc(mc(\Pi_1', \Pi_S[\vec t/\vec y]), \Pi_2,\ldots,\Pi_n,\Pi'[(\Pi_S,S)/X^p]).

    \infer[\eqR]{\Seq{\Delta_1}{s = t}}
    {}
    \qquad\qquad\qquad
    \infer[\eqL]{\Seq{s=t,B_2,\ldots,B_n,\Gamma}{C}}
    {\left\{\raisebox{-1.5ex}
        {\deduce{\Seq{B_2\rho,\ldots,B_n\rho,\Gamma\rho}
            {C\rho}}
          {\Pi^\rho}}
      \right\}_\rho}
    \enspace 
  
  \infer=[\wL]
  {\Seq{\Delta_1,\Delta_2,\ldots,\Delta_n,\Gamma}{C}}
  {\deduce{\Seq{\Delta_2,\ldots,\Delta_n,\Gamma}{C}}{\Xi_1}}
  
    \infer[\bulletL]
          {\Seq{\Delta_1}{B_1}}
          {\left\{\raisebox{-1.5ex}{\deduce{\Seq{\Delta_1^i}{B_1}}
              {\Pi_1^i}}\right\}_i
          }
    \qquad
    \infer[\bulletL]
          {\Seq{\Delta_1,\Delta_2,\ldots,\Delta_n,\Gamma}{C}}
          {
            \left\{
            \raisebox{-1.3ex}{
              \deduce{\Seq{\Delta_1^i,\Delta_2,\ldots,\Delta_n,\Gamma}{C}}{\Xi^i}
            }
            \right\}_i
          }
  
    \infer[\oimpL]{\Seq{D_1' \oimp D_1'',\Delta_1'}{B_1}}
    {\deduce{\Seq{\Delta_1'}{D_1'}}
      {\Pi_1'}
      & \deduce{\Seq{D_1'',\Delta_1'}{B_1}}
      {\Pi_1''}}
    \enspace 
  
    \infer[\oimpL]
    {\Seq{D_1' \oimp D_1'',\Delta_1',\Delta_2,\ldots,\Delta_n,\Gamma}{C}}
    {
      \infer=[\wL]
      {\Seq{\Delta_1',\Delta_2,\ldots,\Delta_n,\Gamma}{D_1'}}
      {\deduce{\Seq{\Delta_1'}{D_1'}}{\Pi_1'} }
      & 
      \deduce{\Seq{D_1'',\Delta_1',\Delta_2,\ldots,\Delta_n,\Gamma}{C}}{\Xi_1}
    }
    \enspace 
  
\infer[\indL] {\Seq{p\,\vec{t}, \Delta_1'}{B_1}} {
  \deduce{\Seq{D\,S\,\vec{y}}{S\,\vec{y}}}{\Pi_S} &
  \deduce{\Seq{S\,\vec{t}, \Delta_1'}{B_1}}{\Pi_1'} }

\infer[\indL] {\Seq{p\,\vec{t}, \Delta_1',\dots,\Delta_n}{C}} {
  \deduce{\Seq{D\,S\,\vec{y}}{S\,\vec{y}}}{\Pi_S} &
  \deduce{\Seq{S\,\vec{t}, \Delta_1',\dots,\Delta_n,\Gamma}{C}}{\Xi_1}
}

    \infer[\eqL .]{\Seq{s=t,\Delta_1'}{B_1}}
    {\left\{\raisebox{-1.5ex}
        {\deduce{\Seq{\Delta_1'\rho}{B_1\rho}}
          {\Pi_1^{\rho}}}
      \right\}}
    \qquad
    \infer[\eqL .]
        {\Seq{s=t,\Delta_1',\Delta_2,\ldots,\Delta_n,\Gamma}{C}}
        {
          \left\{
          \raisebox{-1.3ex}{
          \deduce{\Seq{\Delta_1'\rho,\Delta_2\rho,\ldots,\Delta_n\rho,\Gamma\rho}{C\rho}}{\Xi^\rho}
          }
          \right\}
        }
  subst(\{mc(\Pi_1^\rho,\Pi_2\rho,\ldots,\Pi_n\rho,\Pi\rho)\}_\rho
    \infer[\circL]{\Seq{B_1,\ldots,B_n,\Gamma}{C}}
    {\left\{\raisebox{-1.5ex}{\deduce{\Seq{B_1,\ldots,B_n,\Gamma^i}{C}}
          {\Pi^i}}\right\}_i}
    \qquad
    \infer[\circL]
          {\Seq{\Delta_1,\ldots,\Delta_n,\Gamma}{C}}
          {
            \left\{
            \raisebox{-1.3ex}{
              \deduce{\Seq{\Delta_1,\ldots,\Delta_n,\Gamma^i}{C}}{\Xi^i}
            }
            \right\}_i
          }
  
    \infer[\oimpL]{\Seq{B_1,\ldots,B_n, D' \oimp D'',\Gamma'}{C}}
    {\deduce{\Seq{B_1,\ldots,B_n,\Gamma'}{D'}}
      {\Pi'}
      & \deduce{\Seq{B_1,\ldots,B_n,D'',\Gamma'}{C}}
      {\Pi''}}
    \enspace 
  
    \infer[\oimpL]{\Seq{\Delta_1,\ldots,\Delta_n,D' \oimp D'',\Gamma'}{C}}
    {\deduce{\Seq{\Delta_1,\ldots,\Delta_n,\Gamma'}{D'}}
      {\Xi_1}
      & \deduce{\Seq{\Delta_1,\ldots,\Delta_n,D'',\Gamma'}{C}}
      {\Xi_2}}
    \enspace 
  
\infer[\indL] {\Seq{B_1,\dots,B_n, p\,\vec{t},\Gamma'} {C}} {
  \deduce{\Seq{D\,S\,\vec{y}}{S\,\vec{y}}}{\Pi_S} &
  \deduce{\Seq{B_1,\dots,B_n, S\,\vec{t}, \Gamma'}{C}}{\Pi'} }
\enspace ,

\infer[\indL] {\Seq{\Delta_1,\dots,\Delta_n, p\,\vec{t},\Gamma'}{C}} {
  \deduce{\Seq{D\,S\,\vec{y}}{S\,\vec{y}}}{\Pi_S} &
  \deduce{\Seq{\Delta_1,\dots,\Delta_n, S\,\vec{t}, \Gamma'}{C}}{\Xi_1}
} \enspace 

    \infer[\eqL]{\Seq{B_1,\ldots,B_n,s=t,\Gamma'}{C}}
    {\left\{\raisebox{-1.5ex}
        {\deduce{\Seq{B_1\rho,\ldots, B_n\rho,\Gamma'\rho}{C\rho}}
          {\Pi^{\rho}}}\right\}}
    \qquad
    \infer[\eqL]
    {\Seq{\Delta_1,\ldots,\Delta_n,s=t,\Gamma'}{C}}
    {
      \left\{
      \raisebox{-1.3ex}
      {
        \deduce{\Seq{\Delta_1\rho,\ldots,\Delta_n\rho,\Gamma'\rho}{C\rho}}{\Xi^\rho}
      }
      \right\}
    }
  
    \infer[\circR]{\Seq{B_1,\ldots,B_n,\Gamma}{C}}
    {\left\{\raisebox{-1.5ex}{
          \deduce{\Seq{B_1,\ldots,B_n,\Gamma^i}{C^i}}
          {\Pi^i}}\right\}_i}
    \qquad
    \infer[\circR]
          {\Seq{\Delta_1,\ldots,\Delta_n,\Gamma}{C}}
          {
            \left\{
            \raisebox{-1.3ex}{
              \deduce{\Seq{\Delta_1,\ldots,\Delta_n,\Gamma^i}{C^i}}{\Xi^i}
              }
            \right\}_i
          }
  
\infer[\coindR] {\Seq{B_1,\dots,B_n,\Gamma}{p\,\vec{t}}} {
  \deduce{\Seq{B_1,\dots,B_n,\Gamma} {S\,\vec{t}}}{\Pi'} &
  \deduce{\Seq{S\,\vec{y}}{D\,S\,\vec{y}}}{\Pi_S} } \enspace ,

\infer[\coindR] {\Seq{\Delta_1,\dots,\Delta_n,\Gamma}{p\,\vec{t}}} {
  \deduce{\Seq{\Delta_1,\dots,\Delta_n,\Gamma} {S\,\vec{t}}}{\Xi_1} &
  \deduce{\Seq{S\,\vec{y}}{D\,S\,\vec{y}}}{\Pi_S} } \enspace

    \infer[\mc]{\Seq{B_1,\ldots,B_n,\Gamma^1,\ldots,\Gamma^m,\Gamma'}{C}}
    {\left\{\raisebox{-1.5ex}{\deduce{\Seq{\{B_i\}_{i \in I^j},\Gamma^j}{D^j}}
          {\Pi^j}}\right\}_{j \in \{1..m\}}
      & \raisebox{-2.5ex}{\deduce{\Seq{\{D^j\}_{j \in \{1..m\}},\{B_i\}_{i \in I'},\Gamma'}{C}}
        {\Pi'}}}
    \enspace ,
  
    \infer[\mc]{\Seq{\{\Delta_i\}_{i \in I^j},\Gamma^j}{D^j}}
    {\left\{\raisebox{-1.5ex}{\deduce{\Seq{\Delta_i}{B_i}}
          {\Pi_i}}\right\}_{i \in I^j}
      & \raisebox{-2.5ex}{\deduce{\Seq{\{B_i\}_{i \in I^j},\Gamma^j}{D^j}}
        {\Pi^j}}}
    \enspace 
  
    \infer[\mc]{\Seq{\Delta_1,\ldots,\Delta_n,\Gamma^1,\ldots\Gamma^m,\Gamma'}{C}}
    {\left\{\raisebox{-1.5ex}{\deduce{\Seq{\ldots}{D^j}}
          {\Xi^j}}\right\}_{j \in \{1..m\}}
      & \left\{\raisebox{-1.5ex}{\deduce{\Seq{\Delta_i}{B_i}}
          {\Pi_i}}\right\}_{i \in I'}
      & \raisebox{-2.5ex}{\deduce{\Seq{\ldots}{C}}
        {\Pi'}}}
    \enspace 
  
    \infer[\cL]{\Seq{B_1,B_2,\ldots,B_n,\Gamma}{C}}
    {\deduce{\Seq{B_1,B_1,B_2,\ldots,B_n,\Gamma}{C}}
      {\Pi'}}
    \qquad
    \infer=[\cL]
    {\Seq{\Delta_1,\Delta_2,\ldots,\Delta_n,\Gamma}{C}}
    {
      \deduce{\Seq{\Delta_1,\Delta_1,\Delta_2,\ldots,\Delta_n,\Delta_n,\Gamma}{C}}{\Xi_1}
    }
  
    \infer[\wL]{\Seq{B_1,B_2,\ldots,B_n,\Gamma}{C}}
    {\deduce{\Seq{B_2,\ldots,B_n,\Gamma}{C}}
      {\Pi'}}
    \qquad
    \infer[\wL]
    {\Seq{\Delta_1,\Delta_2,\ldots,\Delta_n,\Gamma}{C}}
    {
      \deduce{\Seq{\Delta_2,\ldots,\Delta_n,\Gamma}{C}}{\Xi_1}
    }
  
\infer[mc]
{\Seq{\Delta_1, \Delta_2, \Gamma}{C} }
{
\infer[\eqR]
{\Seq{\Delta_1}{t = t}}{}
&
\deduce{\Seq{\Delta_2}{B}}{\Pi_2}
& 
\infer[\eqL]
{\Seq{t=t, B, \Gamma}{C}}
{
\left\{
\raisebox{-1.5ex}{ \deduce{\Seq{B\rho, \Gamma\rho}{C\rho}}{\Pi^\rho} }
\right\}_\rho
}
}

\infer[mc]
{\Seq{\Delta_1\theta,\Delta_2\theta, \Gamma\theta}{C\theta} }
{
\infer[\eqR]
{\Seq{\Delta_1\theta}{t\theta = t\theta}}{}
& 
\deduce{\Seq{\Delta_2\theta}{B\theta}}{\Pi_2\theta}
&
\infer[\eqL]
{\Seq{t\theta=t\theta, B\theta, \Gamma\theta}{C\theta}}
{
\left\{
\raisebox{-1.5ex}{ \deduce{\Seq{B\theta\rho', \Gamma\theta\rho'}{C\theta\rho'}}{\Pi^{(\theta\circ \rho')} }}
\right\}_{\rho'}
}
}

\infer=[\wL]
{\Seq{\Delta_1\theta, \Delta_2\theta, \Gamma\theta}{C\theta}}
{
\deduce{\Seq{\Delta_2\theta,\Gamma\theta}{C\theta}}{\Psi}
}

\infer=[\wL]
{\Seq{\Delta_1, \Delta_2, \Gamma}{C}}
{
\deduce{\Seq{\Delta_2,\Gamma}{C}}{\Psi'}
}

\label{eq:param1}
\Pi'\theta \in (\RED_{B\theta}[\Omega] \Rightarrow \RED_{D\theta}[\Omega])

\infer[\oimpR]
{\Seq{\Gamma}{B\Omega \oimp D\Omega}}
{
 \deduce{\Seq{\Gamma, B\Omega}{D\Omega}}{\Pi'}
}

\Pi'\rho \in (\RED_{B\rho}[\Omega] \Rightarrow \RED_{D\rho}[\Omega])

\Pi'\rho \in (\RED_{B\rho}[\Omega'] \Rightarrow \RED_{D\rho}[\Omega'])

\infer[\indR]
{\Seq {\Gamma} {q\,\vec t}}
{\deduce{\Seq \Gamma {D\,Y^q\,\vec t}}{\Pi'}}

\label{eq:vac1}
\Pi_I[\vec u/\vec y] \in (
\RED_{(D\,Y^q\,\vec u)}[\Omega', (\Sscr,\Pi_I, I)/Y^q] \Rightarrow \Sscr
\,\vec u) 
mc(\Pi'[(\Pi_I,I)/Y^q], \Pi_I[\vec t/ \vec y]) \in \Sscr\,\vec t
\RED_{(D\,Y^q\,\vec u)}[\Omega', (\Sscr,\Pi_I, I)/Y^q] 
=
\RED_{(D\,Y^q\,\vec u)}[\Omega, (\Sscr,\Pi_I, I)/Y^q] 

\Pi_I[\vec u/\vec y] \in (
\RED_{(D\,Y^q\,\vec u)}[\Omega, (\Sscr,\Pi_I, I)/Y^q] \Rightarrow \Sscr \,\vec u)

mc(\Pi'[(\Pi_I,I)/Y^q], \Pi_I[\vec t/ \vec y]) \in \Sscr\,\vec t

\infer[\coindR]
{\Seq \Gamma {q\,\vec t}}
{
  \deduce{\Seq \Gamma {I\,\vec t}}{\Pi'}
  &
  \deduce
  {\Seq {I\,\vec y}{B\,I\,\vec y}}
  {\Pi_I}
}

\label{eq:vac2}
\Pi'[\vec u/\vec y] \in (\Sscr\,\vec u \Rightarrow 
\RED_{B\,Y^q\,\vec u}[\Omega, (\Sscr,\Pi_I,I)/Y^q])

\Pi'[\vec u/\vec y] \in (\Sscr\,\vec u \Rightarrow 
\RED_{B\,Y^q\,\vec u}[\Omega', (\Sscr,\Pi_I,I)/Y^q])
\RED_{B\,Y^q\,\vec u}[\Omega, (\Sscr,\Pi_I,I)/Y^q]
= \RED_{B\,Y^q\,\vec u}[\Omega', (\Sscr,\Pi_I,I)/Y^q]
\Rscr = \{\Pi \mid \Pi \in \RED_{S\,\vec u}[\Omega] \ \hbox{for some } \}.

\RED_{C[S/X^p]}[\Omega] = \RED_C[\Omega, (\Rscr, \Psi, S\Omega)/X^p].
\RED_C[\Omega, (\Rscr, \Psi,S\Omega)/X^p] = \Rscr\,\vec u = \RED_{S\,\vec u}[\Omega]
\RED_{C[S/X^p]}[\Omega] = \RED_C[\Omega]=\RED_C[\Omega, (\Rscr, \Psi, S\Omega)/X^p].

\infer[\oimpR]
{\Seq \Gamma {B[S/X^p]\Omega \oimp D[S/X^p]\Omega}}
{
  \deduce{\Seq {\Gamma, B[S/X^p]\Omega}{D[S/X^p]\Omega}}{\Pi'}
}

\Pi'\rho \in (\RED_{B[S/X^p]\rho}[\Omega] \Rightarrow \RED_{D[S/X^p]\rho}[\Omega])

\Pi'\rho \in (\RED_{B\rho}[\Omega'] \Rightarrow \RED_{D\rho}[\Omega'])

hence . 

\item The converse, i.e., 
implies , can be proved analogously.
\end{itemize}
\qed
\end{proof}







\end{document}
