\documentclass{LMCS}

\def\dOi{10(4:5)2014}
\lmcsheading {\dOi}
{1--29}
{}
{}
{Jun.~28, 2013}
{Dec.~\phantom04, 2014}
{}

\ACMCCS{[{\bf Software and its engineering}]: Software notations and
  tools---General programming languages---Language types---Concurrent
  programming languages; [{\bf Theory of computation}]: Semantics and
  reasoning---Program reasoning---Program verification}

\subjclass{D.1.3 Concurrent Programming,
  D.2.4 Software/Program Verification -- Formal methods.}

\usepackage{mathtools}
\usepackage{amssymb,amsmath}
\usepackage{xspace}
\usepackage{colortbl}
\usepackage{stmaryrd}
\usepackage{hyperref}

\usepackage{listings}
\usepackage{xspace}
\usepackage{courier}
\renewcommand{\ttdefault}{pcr}


\newcommand{\ftt}[1]{\xspace{\footnotesize\tt #1}}


\lstdefinelanguage{Actor}
{morekeywords={method, fields, actor, var, self, void, int, boolean, if, else, for, case, and, or, type},
sensitive=true,
morecomment=[l]{//},
morecomment=[s]{/*}{*/},
morestring=[b]",
literate={--}{{}}2 {==}{{}}2 {epsilon}{{}}1 {neg}{{}}1
}

\lstset{
mathescape,numbersep=5pt,numberblanklines=false,basicstyle=\scriptsize,lineskip=2.5pt,xleftmargin=15pt,framexleftmargin=12pt,xrightmargin=4pt,tabsize=4,
language=Actor
}


\newcommand{\cal}{\mathcal}

\theoremstyle{plain}\newtheorem{proposition}[thm]{Proposition}
\theoremstyle{plain}\newtheorem{lemma}[thm]{Lemma}
\theoremstyle{plain}\newtheorem{theorem}[thm]{Theorem}
\theoremstyle{plain}\newtheorem{corollary}[thm]{Corollary} 
\newif\iftype \typefalse
\newif\ifconf \conffalse
\newif\ifcamera \camerafalse

\newcommand{\Sched}{{\it Sched}}
\newcommand{\bigcupdot}{ \mathrel{ \offinterlineskip \bigcup \hspace{-2.97mm} \bullet \hspace{1.3mm}}}
\newcommand{\bigcupcat}{ \mathrel{ \offinterlineskip \bigcup \hspace{-2.97mm} \overset{::}{} \hspace{1.3mm}}}
\newcommand{\cupdot}{\mathrel{\offinterlineskip {\cup \hspace{-1.6mm} \overset{\centerdot}{} \hspace{.6mm}}}}
\newcommand{\cupcat}{\mathrel{\offinterlineskip {\cup \hspace{-1.95mm} \overset{::}{} \hspace{.95mm}}}}

\renewcommand{\P}{\mathbb{P}}
\newcommand{\List}{{\it List}}

\newcommand{\bigfract}[2]{\frac{^{\textstyle #1}}{_{\textstyle #2}}}
\newcommand{\rulename}[1]{{\sc(#1)}}
\newcommand{\rulenamex}[1]{\mbox{\scriptsize\sc(#1)}}

\def \mathrule #1#2#3{\begin{array}{l} 
                       {\rulenamex{#1}}
                       \\ \bigfract{#2}{#3}
                      \end{array}}

\def \mathax #1#2{\begin{array}{l} 
                   {\mbox{\scriptsize {{\sc (#1)}}} } 
                   \\ #2
                  \end{array}}

\newcommand{\subst}[2]{[\raisebox{.5ex}{\footnotesize}  /
                        \raisebox{-.5ex}{\footnotesize} ]}

\newcommand{\combinator}[2]{\begin{array}{c}{\small #1} \\ {\small #2} \end{array}}

\newcommand{\pinull}{{\tt 0}}
\newcommand{\invk}{\mbox{\tt !}}
\newcommand{\prefix}{\mbox{\tt .}}
\newcommand{\newact}[1]{{\tt new} \; #1}
\newcommand{\NEW}[1]{{\tt NEW}(#1)}
\newcommand{\letin}[3]{{\tt let} \; #1 = #2 \; {\tt in} \; #3}

\newcommand{\State}{{\tt S}}
\newcommand{\StateT}{{\tt T}}
\newcommand{\lred}[1]{\stackrel{#1}{\longrightarrow}}
\newcommand{\lleadsto}[1]{\stackrel{#1}{\leadsto}}

\newcommand{\eqdef}{\stackrel{{\it def}}{=}}

\newcommand{\f}{{\tt f}}
\newcommand{\g}{{\tt g}}
\newcommand{\ite}{\mbox{{\tt ;}}}
\newcommand{\false}{{\it f\hspace{-3pt}f}}
\newcommand{\true}{{\it t\hspace{-2.3pt}t}}


\newcommand{\upd}{\mapsfrom~}

\newcommand{\var}[1]{{\it var}(#1)}
\newcommand{\fresh}[1]{{\it fresh}(#1)}
\newcommand{\free}[1]{{\it free}(#1)}
\newcommand{\fields}[1]{{\it fields}(#1)}
\newcommand{\pred}[1]{{\it Pred}(#1)}
\newcommand{\Succ}[1]{{\it Succ}(#1)}
\newcommand{\dom}[1]{{\it dom}(#1)}

\newcommand{\proj}[2]{{#1\!\!\downharpoonright_{#2}}}

\newcommand{\wt}[1]{\widetilde{#1}}
\newcommand{\adef}[1]{{\tt #1}}

\newcommand{\semantics}[1]{[\![ #1 ]\!]}

\newcommand{\xbar}{\wt{x}}
\newcommand{\eqdot}{\stackrel{\bullet}{=}}

\newcommand{\Cosimo}[1]{\marginpar{{\bf C}: #1}}
\newcommand{\Gigio}[1]{\marginpar{{\bf G}: #1}}

\newcommand{\actor}{}
\newcommand{\actro}{}
\newcommand{\actba}{}
\newcommand{\actroba}{}
\newcommand{\actsl}{}







\begin{document}

\title[Decidability Problems for Actor Systems]
      {Decidability Problems for Actor Systems\rsuper*}

\author[F.~S.~de Boer]{Frank S.~de Boer\rsuper a}
\address{{\lsuper a}CWI/LIACS,  The Netherlands}
\email{{\tt f.s.de.boer@cwi.nl}}
\thanks{{\lsuper{a-d}}This work has been has been supported by the HATS Project No.~FP7-231620 
(Highly Adaptable and Trustworthy Software using Formal Models) and by the
ENVISAGE Project No.~FP7-610582 (Engineering Virtualized Services) of the EC}

\author[M.~M.~Jaghoori]{Mohammad Mahdi Jaghoori\rsuper b}
\address{{\lsuper b}Leiden University, The Netherlands}
\email{{\tt jaghoori@cwi.nl}}



\author[C.~Laneve]{Cosimo Laneve\rsuper c}
\address{{\lsuper{c,d}}Department of Computer Science and Engineering, University of Bologna, INRIA Focus, Italy}
\email{\{cosimo.laneve,gianluigi.zavattaro\}@unibo.it}


\author[G.~Zavattaro]{Gianluigi Zavattaro\rsuper d}


\keywords{Actors, RESTful services, decidability problems, 2-Counter
  Machines, well-structured transition systems, embedding relation.}

\titlecomment{{\lsuper*}This paper is a full version of an extended
  abstract that appears in~\cite{DJLZ2012}. With respect to the
  conference paper, this one contains examples and discussions, see
  Section~\ref{sec.examples}, and complete proofs of statements.}

\begin{abstract}
We introduce a nominal actor-based language and study its expressive power.
We have identified the presence/absence of fields as a crucial feature:
the dynamic creation of  names
in combination with fields gives rise to Turing completeness.
On the other hand, restricting  to stateless actors 
gives rise to systems  for which properties such as termination are decidable.
This decidability result still holds for actors with states when
the number of actors is bounded and the state is read-only.





\end{abstract}


\maketitle              

\ifcamera
\else
\pagestyle{plain}
\fi



\section{Introduction}

Since their introduction in~\cite{Hewitt69}, actor languages have  evolved as a powerful computational model for defining distributed and concurrent
systems~\cite{Agha90,Agha97}. 
Languages based on actors have been also designed for modelling embedded systems \cite{LeeLN09,LeeACtorEmbedded03}, 
wireless sensor networks \cite{CheongSensor05,RazaviBSKSS10}, multi-core programming \cite{KarmaniSA09}, and web services \cite{Chang-web-sac2007,Chang-DAIS07}.
The underlying concurrent model of actor languages also forms the basis of the   programming languages
Erlang \cite{Armstrong10Erlang} and Scala \cite{haller09tcs} that have recently gained in popularity, in part due to their support for scalable concurrency.

In actor languages~\cite{Agha90,Hewitt69,Sirjani06}, actors use a queue
for storing the invocations to their methods in a FIFO manner. The queued invocations
are processed sequentially by executing the corresponding method bodies.
The encapsulated memory of an actor is represented by a finite number of \emph{fields}
that can be read and set by its methods
and as such exist throughout  its life time.

In this paper we introduce a nominal actor-based language and study its expressive power. This language,  besides dynamic creation of actors, also supports
the dynamic creation of variable names that can be stored in fields and 
communicated in method calls.
As such our nominal actor-based language gives rise to unboundedness in
(1) internal queues of the actors, (2) dynamic actor creation/activation and (3) dynamic creation of variable names.

\emph{Statelessness} has recently been adopted as a basic principle 
of service oriented computing, in particular by RESTful services. 
Such services are designed to be stateless, and contextual information should be added to messages, so a service can customize replies simply by looking at the received request messages. 
In service oriented computing read-only fields (which are initialized upon activation)  are used to provide configuration/deployment information that distinguishes the distinct instances of the same service.
We have identified the presence/absence of fields as a crucial  feature
of our language:
 (1) and (3) in combination with fields gives rise to a Turing complete calculus.
On the other hand, restricting to stateless actors gives rise to systems for which properties such as termination 
\ifconf
\else
and process reachability 
\fi
are decidable. In order to preserve this decidability
result to actors with states we have to restrict the number of actors to be finite and the state to be read-only.

More specifically,  we model a system  consisting of finitely many actors with 
read-only fields as a  well-structured transition system \cite{Finkel:2001} -- 
henceforth \ifconf
termination.
\else
termination and process reachability are decidable.
\fi
Further, we show that an
abstraction of  systems of unboundedly many stateless actors 
(i.e., actors without fields) which preserves
termination and process reachability
is also an instance of well-structured transition system.
It turns out that, in the context of unbounded actor creation, 
this restriction to stateless actors is necessary by
a reduction to the halting problem for 2 Counter Machines.

To the best 
of our knowledge, the technique we use to establish the decidability results
for the above languages
is original since (\emph{i})  these systems respectively admit the creation of unboundedly many variables
 and actor names; (\emph{ii}) actors in general
are sensitive to the identity of names because of the presence of a name-match operator. 
In particular, in the case of finitely many actors with read-only fields,
we define an equivalence on process instances in terms of 
renamings of the variables that \emph{generate the same partition}.
This equivalence allows us to compute an upper bound to the
instances of method bodies, which is the basic argument for the model being a
well-structured transition system.
In case of systems with unboundedly many stateless actors, 
the reasonable extensions of this equivalence on process
instances have been unsuccessful because of the required abstraction of
the identity of actor names. Therefore we decided to apply our
arguments to an abstract operational model where messages
may be enqueued in every actor of the same class. The above equivalence can be  successfully used in this  model, thus yielding again the
upper bounds for the number of method body instances.  Further, the  abstract
model still provides enough information to derive
decidable properties of the language.


\paragraph{\bf Related Works.}
There exists a vast body of  related work on decidability of infinite-state systems 
(see  \cite{abdulla:96}).
However, to the best of our knowledge, the specific characteristics of 
the pure  asynchronous mechanism of queued and dequeued method calls in actor-based languages
has not been addressed.
It is interesting to observe that the most expressive known fragment of the  pi-calculus for which interesting verification problems are still decidable is the depth-bounded 
fragment~\cite{meyer08}. 
In~\cite{wies10} the theory of well-structured transition
systems is applied to prove the decidability of coverability problems for bounded depth pi-calculus.
Our nominal actor language also features the creation and communication of  new names. In our decidable fragments however, differently from the
depth-bounded pi-calculus fragment, 
we do not restrict the creation and communication of names. For instance, in the queue of an actor we might have 
unboundedly many messages (representing process continuations) where each message shares one name with the previous message in the queue.
\ifcamera
\else
Decidability of asynchronous communication via a shared data space, 
read operation and non-blocking test operators on the shared space
of the coordination language Linda has been studied in \cite{Busi20009}.
In \cite{BouajjaniFQ07} the authors introduce an algorithm for reachability analysis of multithreaded object-oriented programs.
This algorithm requires both a bound on the number of context switches (between the threads) and the visible heap.
Further their approach is specific to object-oriented programs and is not applicable to  actor-based languages,
which are based on a different concurrency model.
As another final example, a system composed of finitely many actors  can be easily modeled
as a communicating finite state machine \cite{Brand83}, a formalism that is 
known to be Turing complete \cite{Brand83,Memmi85}.
However, this modelling does not scale to infinite actors and does not
display the execution model of actors.
\fi
Recent work on  actor-based language focusses on deadlock analysis:
In \cite{GiachinoL11}, a technique for the deadlock analysis has been introduced for a version of Featherweight Java
which features asynchronous method invocations and a synchronization mechanism based on futures variables.
The approach followed in \cite{deBoer2012} 
for detecting deadlock in an actor-like subset of Creol \cite{Johnsen07} is based on suitable over-approximations.












\section{The language {\actor}}
\label{sec.thelanguage}
Four disjoint infinite sets of names are used:
\emph{actor classes}, ranged over by , , ,
\emph{method names}, ranged over by , , , , , 
\emph{field names}, ranged over by , , , 
and \emph{variables}, ranged over by , , , .
For notational convenience, we use  when we refer to a list of variables  (and similarly for other kinds of terms).


The syntax of the language {\actor} uses \emph{expressions}  and 
\emph{processes}  defined by the rules

An expression  either  denotes 
a value stored in a field , or a variable ,
or a new actor of class  with fields initialized to the values of
.
A process may be either the terminated one, denoted by , or a field update 
, or the assignment  of a value to a variable, or an invocation 
 of a method  of the actor 
with arguments , or a check  of the identity of 
expressions
with positive and negative continuations, or, finally  a nondeterministic process . 
We never write the tailing  in processes; for example 
 will be always shortened into .
We will also shorten  into .
Following the tradition of process calculi like CCS~\cite{Mil89},
we model sequences of actions by exploiting the 
so-called prefix notation (like, e.g., in ). 

The operation  is a binder of the occurrences of the
variable  in the process  that are not already bound by a nested
 operation of ; the occurrences of  in  are \emph{free}.
Let  be the set of variables of  that are not bound. 
As usual, we identify processes  and  that are equal up-to 
\emph{alpha-conversion} of bound names, written .
The 
substitution operation  returns the process  where the
free occurrences of  are replaced by . 
The 
substitution operation  returns the process  where the
free occurrences of  are \emph{simultaneously} replaced by . In case,
alpha-renaming is required for avoiding name clashes. For example 
 returns
.

In the following examples and
encodings we shorten  into 
 (we have preferred the simpler syntax to ease
the descriptions).

A \emph{program} is a \emph{main process}  and a finite set of \emph{actor class 
definitions} , where  may contain the special 
variable  (which can be seen as an implicit formal parameter of each method). In the following we restrict to programs that are
\begin{enumerate}
\item
\emph{unambiguous}, namely, every pair ,  has at most one definition;
\item
\emph{correct}, namely, let  be
a map that associates a tuple of 
field names to every actor class. Then, 
(\emph{i}) in every expression , the length of the 
tuples  and  are the same;
(\emph{ii}) in every definition , the field names 
occurring in  are in the tuple  .
\end{enumerate}
In this paper, we abstract from types and type-correctness because we are
only interested in expressive power issues. However, it is 
straightforward to equip the above language with a type discipline.

\ifcamera
\else
\subsection{Examples}
\label{sec.examples}
To illustrate the features of the actor language we discuss four
examples.

\begin{exa}
The \emph{merger} service is an application that forwards 
to a back office server the values carried by two invocations of 
clients to methods  and . The \emph{merger}
freezes the forward as long as there is no invocation of either  
 or  -- in the process calculi community,
the \emph{merger} is modelled by a join pattern~\cite{FG96}.
In our actor language the \emph{merger} is modelled by a class actor
 with six fields:  and  storing the  values \emph{true} and \emph{false}, respectively;  and 
storing \emph{true} or \emph{false} according to the method 
 and  have been invoked or not, respectively;
 storing the  argument of the invocation;  storing the
actor name of the back office server.

The class actor  
includes the following three methods:
{\small

}The method  manifests a basic feature of our actor language: 
the creation of new variables. In particular,  and  are free
variables in the method definition of . When  will be invoked, they 
will be replaced by two different fresh variables
(said in pi-calculus jargon~\cite{PIC}, we are 
assuming an implicit - at the beginning of the method body). These 
variables are stored in the fields  and , respectively and they 
will be used to 
update the fields  and  appropriately
.
The merger forwards two messages to the server, which is stored in the field 
. These messages have been received through invocations of {\it first} and {\it second}.
No forward occurs if one of the two methods has not been invoked. In particular,
{\it first} (the method {\it second} behaves in a similar way) performs the
forward if {\it second} has been evaluated \emph{and} its message has not
been already forwarded  (field  equal to ); in this case
the parameter of the invocation of {\it second} has been stored into . Otherwise, if there is no
previous invocation to {\it first}, still to be forwarded, (field  equal 
to ) then  is set to  and the parameter stored into .
There is a possibility that {\it first} is evaluated and a previous evaluation 
of {\it first} has still to be forwarded (field  equal 
to ). In this case,  the invocation is bounced back (it is enqueued in the 
actor queue -- see the operational semantics). 
  



\end{exa}
\fi

\ifconf
\else
\begin{exa}
\newcommand{\username}{{\tt username}}
\newcommand{\password}{{\tt password}}
\newcommand{\auth}{{\tt auth}}
\newcommand{\ctoken}{{\tt ctoken}}
\newcommand{\atoken}{{\tt atoken}}
\newcommand{\server}{{\tt server}}
\newcommand{\sfield}{{\tt server}}
As a second example we model the
OpenID authentication protocol~\cite{openID}.
Three actors are considered: a {\it client}, a {\it server},
and an {\it  authProvider}.
The {\it client} sends a {\it login} request to the {\it server}.
The {\it server} generates two secure tokens {\it clientToken}
and {\it authToken}, used for secure communication with the 
{\it client} and the {\it  authProvider}, respectively,
and then sends the two tokens to the corresponding actors.
Subsequently, the {\it client} sends an {\em authentication}
message to the {\it  authProvider} that (after
checking the correctness of the username and password)
communicates to the {\it server} whether the authentication
{\it succeeds} or {\it fails}.
In the following, we abstract from the management of username
and password and we simply assume that they are stored in the
fields  and  of the {\it client} 
when it sends the {\it authenticate} message
to the {\it authServer}.

The class  of the {\it client}
includes the following two definitions:


The class  of the {\it server}
includes the following four definitions:


The class  of the {\it authServer}
includes the following two definitions (we leave unspecified
the check of the correctness of username and password):



The main program that instantiates the {\it client},
the {\it server} and the {\it authProvider} is as follows:

\end{exa}

\begin{exa}
We illustrate the modeling of a register that stores natural numbers and supports the
operations of increment and decrement, when its value is positive.
In the absence of data-types in our nominal actor language, we model a register by an actor
and implement the value of the register by the
number of invocations of the method  stored in its  queue.
Below we describe the corresponding class , assuming a class  which encodes the control of the register machine.
When an  operation
is performed, the register replies with an invocation , where  is a suitable continuation. 
The continuation is unique when the increment is invoked; the 
decrement has two possible continuations: a positive one, in case of success, and
a negative one (the register was 0, no decrement is performed).



\medskip

\; {\tt //  has a field called} \ , \quad {\tt  is an actor
in the context}

Method  simply gives rise to the storage of a new message   and 
a trigger of the continuation.
Executing a message , amounts to bouncing the invocation back if the 
value of the field  is false. In this case the invocation is enqueued again. 
Otherwise the invocations is ``consumed'' because there was a pending 
decrement to perform (see below) and  is set to true (indicating that there is no pending decrement
anymore). Method  is the tricky one: it sets  to true
and add an invocation of  (we are assuming that the register queue
always contains at most one invocation of ). That is, we are postponing the
triggering of the continuation to the evaluation of   that will
occur \emph{after} the evaluation of any other method in the queue of the register.
When  will be evaluated either (i) the  field is true,
this means that the register did not contained any  message -- its
value was 0 -- and the continuation  is triggered; or (ii) 
the  field is false, that is the register has been decremented and 
the  continuation  is triggered.

A refinement of the above register is used in Theorem~\ref{thm.undecidablestatefull} 
to demonstrate the Turing completeness of a sublanguage of {\actor}.
\end{exa}

\begin{exa}\label{ex:taskManager}
In Sections~\ref{sec.decidability} and~\ref{sec.stateless}
we will respectively prove decidability results for two fragments of our actor language:
in the first fragment only the main program can create new actors (so 
boundedly many actors can be created) and fields are read-only, while in the
second fragment actors have an empty state.
To illustrate these two fragments we show how they can be used to model
a system in which
 workers are used to execute  distinct tasks indicated by a client.

In the fragment with bounded actors and read-only fields the model can be described 
by considering a class  for the client with an {\it init}
method responsible for invoking the task manager, passing him the description
of the  tasks to be executed:

\; {\tt //  has no fields} 


The task manager is an instance of a class providing a method called
{\it tasksExec} able to pass to the workers the description of their 
relative tasks:

\; {\tt //  has  fields called} \ ,


Finally, a worker is an instance of a class  with one method
{\it exec} able to execute the passed task (we leave this method
unspecified):

\; {\tt //  has no fields and one method } 

The main program first instantiates the {\it workers},
then the {\it task manager} by storing in its state the reference
to the workers, and finally the {\it client}; after the {\it init}
method of the client is invoked passing him a reference to the
task manager:


In the fragment with stateless actors we present an alternative specification
of the system in which the classes for the client and the workers are
as above, while the task manager is defined as follows:

\; {\tt //  has no fields} 
Upon reception of the  tasks to be executed, the 
task manager passes the task descriptions to the method
{\it nextTask}. This method instantiates one new
worker, passes to it the corresponding task, and then
recursively invokes itself to continue with
worker instantiations. In order to execute exactly  recursive calls,
 additional parameters are considered: in the first
call all such parameters are distinct excluding the first
and the last one, at every call the parameters are
circularly shifted, and when the first two parameters coincide
the chain of calls is terminated.
\end{exa}


\fi

\iftype
For simplicity in presentation, usually the method definitions and fields associated to an actor are collected together and referred to as the actor definition.
A program is then a collection of actor definitions.
We may use the syntax exemplified in Fig. \ref{fig:actor_def} to give the definition of an actor (on top of the syntax defined above for method definitions).
This figure defines an actor , with fields  and , and methods  and .
Method  takes two variables  and  as its formal parameters, while  has no parameters.\footnote{Assuming bounded or unbounded variables has not effect on the decidability results.}.\sidenote{Does having unbounded variables affect the decidable results?} 
 and  represent the definitions of the methods.

\begin{figure}
\begin{lstlisting}[frame=single]
actor  {
	fields { ,  }
	method (, ) = 
	method () = 
}
\end{lstlisting}
\caption{An actor defined as the set of its fields and method definitions.}\label{fig:actor_def}
\end{figure}
\else

\fi

\ifconf
\paragraph{The operational semantics.}
\else
\subsection{The operational semantics}
\fi
The operational semantics of the language {\actor} will use an infinite set of 
\emph{actor names}, ranged over , , . This set
is partitioned by the actor classes in such a way that every partition retains 
infinitely many actor names. We write  to say that  
belongs to the partition of .
In the following, the (\emph{run-time}) expressions 
will also include actor names and, with an abuse of notation, this extended
set of expressions
will be ranged over by . The set of terms that are variables or 
actor names, called \emph{values}, will be addressed by , , .
Similarly for processes that, at run-time, may also have actor names. The extended
set will be addressed by . We notice that , when  belongs to this
extended set, may returns variables \emph{and} actor names. We will also apply
 to tuples of (extended) expressions:  returns
the set of variables and actor names in  .

The semantics is defined in terms of a \emph{transition relation}
, where , , called \emph{configurations}, are
 sets of terms  with 
 being an actor name,
, the \emph{state} of , being a map from  to values, 
where ,
and  being a queue of terms . 
The empty queue will be denoted with .
Configurations contain at most one 
for each actor name . As usual, let  be the transitive closure of 
 and  be .



The operational semantics of {\actor} is defined in 
Table~\ref{tab.trans}, where the \emph{evaluation function} 
 is used (defined in Table~\ref{tab.eval}). This function 
takes an expression  and a
store  and returns a value  and a possibly empty configuration 
of terms . These 
terms represent actors  created during the evaluation -- the names  are \emph{fresh} --
and  records the initial values of the fields of .
The auxiliary function  used in the evaluation function
takes a class actor and returns an actor name of that class that is fresh.
In order to have a finitely branching transition system (see the remark
at the end of this section), we assume actor names 
in classes are totally ordered and  always
returns the first unused name of the class . In this way,
fresh names are selected in a deterministic manner.  
The same auxiliary function is used in rule \rulename{inst} 
 on a tuple of variables. In this case it returns a 
tuple of the same length of variables that are fresh. Also in this case, we
assume a total order of variables and , where  has length , returns the least  unused variables.  
For notational convenience, we  always
omit the standard curly brackets in the set notation
and we use  both to separate elements inside 
sequences and for set union (the actual meaning is made
clear by the context).
\begin{table} 

\caption{\label{tab.eval} The evaluation relation }
\end{table}


\begin{table} 

\caption{\label{tab.trans} The transition relation }
\end{table}


The initial configuration of a program with main process   is
, where  is a
name of the \emph{root}, an actor of a class
without fields and methods. We assume that the class of  does not
belong to the classes of the program. 
Note that the root actor is guaranteed to terminate because its queue remains empty
(no method invocation may be enqueued) and the main process (as any other
one) terminates.

We finally remark that transition systems of the language {\actor} are 
\emph{finitely branching} (every state has a finite number of successor states)
because the choices of fresh actor names (in the evaluation of 
) and of fresh variables (in the instantiation of the bodies
of methods) are deterministic. 


\subsection{Relevant sublanguages}
We will consider the following fragments of {\actor}
whose relevance has been already discussed in the Introduction:
\begin{itemize}[label=\actba]
\item[{\actba}] is the sublanguage where the  expression 
only occurs in the main process (the number of actor names that it is
possible to create is bounded).
\item[{\actro}] is the sublanguage without the field
update operation  (fields are read-only 
as they cannot be modified after the
initialization). 
\item[{\actroba}] is the intersection of {\actba} and {\actro}.
\item[{\actsl}] is the sublanguage with classes without fields
(objects are stateless).
\end{itemize}

\section{Undecidability results for {\actba} and {\actro}}
\label{sec.undecidability}
In this section we establish the main undecidability results 
for the actor language in Section~\ref{sec.thelanguage}.
In particular, we will prove the undecidability of \emph{termination}
and \emph{process reachability}. 

\begin{defi}
\label{def.termandreach}
Consider an actor program.
The \emph{termination problem} is to decide whether it has no infinite computation;
the \emph{process reachability problem} is to decide,
given a process , whether there exists  a computation of the program
traversing a configuration having a term 
with  being equal
to  up-to renaming of variables and actor names.
\end{defi}



We will use a reduction technique 
from a Turing-complete model to our actor model.
In particular, the Turing-complete models we consider are the 2 Counter Machines 
(2CMs)~\cite{Minsky67}
and a faulty variation of them.
A 2CM  is a machine with \emph{two registers} 
 and  holding arbitrary large natural numbers and a 
\emph{program}  consisting of a finite sequence of numbered 
instructions of the following type:
\begin{itemize}
 \item : increments  
 and goes to the instruction ;
 \item : if the content of  is not 
 zero, then decreases it by 1 and goes to the instruction , otherwise jumps to the instruction ;
 \item : stops the computation and returns the value in 
 the register .
\end{itemize}
A state of the machine is given by a tuple  where 
 indicates the next instruction to execute (the program counter)
and  and  are the contents of the two registers. The
user has to provide the initial state of the machine. 
The transition relation of the 2CM will be denoted by .


The faulty variation of the 2CM we use are the
``two Faulty Towers Machine'' (2FTM, for short)~\cite{FTM}. These machines have
\emph{two faulty registers} 
 and  holding either arbitrary large natural numbers or the \emph{faulty value} 
. The program of a 2FTM is a finite sequence of numbered instructions that are 
the same of those in 2CMs. However, in contrast with 2CMs, 2FTMs from a state
 may
\emph{nondeterministically} evolve into a faulty state  or 
 or
. If an instruction  is an {\sf Inc}/{\sf DecJump} that refers to
the register  (respectively, ) then  (respectively, 
) evolves to  (respectively, ).
In 2FTMs, the instruction numbered 0 is always assumed to be {\sf Halt}.
Let  be the transition relation of the  2FTMs.

By definition, every 2CM program with a 0-numbered instruction {\sf Halt} is 
a 2FTM program and conversely. If we restrict to 2CM with a 0-numbered instruction {\sf Halt},
it is easy to verify that every 
such machine has an infinite computation with a 2CM-semantics if and only if it
has an infinite computation with a 2FTM-semantics. Similarly for instruction reachability,
if we consider any non 0-numbered instruction.

In the sequel, we consider 2FTMs and 2CMs whose initial state is .





\subsection{The language {\actba}}
\label{ssec.finiteactors}


We encode the value  stored in a register as 
 messages (of the same type) that are enqueued in an actor -- see 
Figure~\ref{fig:2CM_actor}. 
Namely, let  and  be two actors of class  and let 
the number of messages  in  and  be 
their value. 
\begin{figure}[t]
 \iftype
 \begin{lstlisting}[frame=single]
 actor  {
 	fields { dec }
 	method one() =  dec    ( [dec = ]   one())
 	method inc(pc) =   one()  Ctrl  run(pc)
 	method decJump(pc, pc') = 
 		dec      checkZero(pc, pc')
 	method checkZero(pc, pc') =
 		[dec = ] Ctrl  run(pc')  Ctrl  run(pc)
 	method init() = dec  
 }
 actor Ctrl {
 	method run(pc) =
 		[pc = 1]  
 		. . . 
 		[pc = n]   
 	method init() =   init()    init()  Ctrl  run(1)
 }
 \end{lstlisting}
 \else


\bigskip

\begin{itemize}
\item[] \hspace{-1.2cm}
\quad \quad where  is equal to

\medskip
 \item[--]
 \qquad if 
 ;
 \item[--]
 
 \qquad if 
 ;
 \item[--]
 \qquad if 
 .
 \end{itemize}

\bigskip
 
\begin{itemize}
\item[]
\hspace{-1.2cm}
\quad\quad
The main process is 

\medskip

  .
\end{itemize}
 \fi
 \caption{Encoding a 2FTM in {\actba} (``'' denotes an irrelevant initialization
 parameter)}\label{fig:2CM_actor}
 \end{figure}



The instruction {\sf Inc} is  implemented by inserting 
one    message in the queue of the corresponding register. 
In our formalism, this is done by invoking the method 
 whose execution has two possible outcomes: (i) 
the invocation is enqueued again; (ii) the invocation is discarded because
we are in the presence of a residual of a {\sf DecJump} operation, as described next.

In case (i), to avoid an infinite sequence of  dequeues and 
enqueues, we introduce fields  and  which are  initialized to {\it false} and set to {\it true}
by the {\it bottom} method in case the queue contains only {\it item} messages.
This has as effect that the stored {\it item} messages are subsequently purged from the queue of the register. 
Note that differently from the example in Section~\ref{sec.thelanguage} we have encoded the boolean values
as fields (so that we do not need to pass them around).



In case (ii), registers have a field   that is set to  by 
a  method execution. This field means that the actual decrement
of the register is delayed to the next execution of . Since in 
(ii)  is not enqueued, then the register is actually decremented and
the field   is set to . When 
 will be executed, since 
  then the next instruction of the 2CM is simulated.
On the contrary, when   is executed with 
then the decrement has not been performed (the register is 0) and the simulation 
jumps.

The {\sf Halt} instruction is simulated by invoking a method {\it halt} that does nothing.

\ifconf
Booleans
\else
As in the examples of Section~\ref{sec.thelanguage}, booleans
\fi
are implemented by two variables 
-- see the method  -- that are distributed during the invocations. 
With a similar machinery, in the actor class ,   the
labels of the instructions are represented 
by the variables , 
which are stored in the fields  of .

\begin{thm}
\label{thm.undecidablestatefull}
Termination and process reachability 
are undecidable in {\actba}.
\end{thm}
The undecidability of termination in {\actba} follows by the
property that a 2FTM  diverges if and only if the corresponding actor program
has an infinite computation. As regards process reachability, we need a smooth
refinement of the encoding in Figure~\ref{fig:2CM_actor} where the {\sf Halt}
instruction is simulated by a specific process. 


\ifconf
\else
\proof
Let us assume to have a fixed 2FTM and let  be defined in Figure~\ref{fig:2CM_actor}. 
Let also

where 
\begin{itemize}
\item[--] 
;

\item[--] 
;

\item[--] 
;

\item[--]
.
\end{itemize}
(the definitions of  and 
 and 
follow the same patterns).

We first observe that , where  is the main process in 
Figure~\ref{fig:2CM_actor}.
Then we demonstrate the following properties:
\begin{enumerate}
\item[(1)]
if  then 
;

\item[(2)]
if  has an infinite computation then 
the computation has infinitely many configurations like


\item[(3)]
if

is a computation with every intermediate configuration having the process of
the actor  equal to  then there are two computations

and

where the actor  never moves such that

\end{enumerate}

\noindent The proof of (1) is a straightforward case analysis on the 
type of instruction .

The proof of (2) uses an argument by contradiction. Assume that there are 
finitely many configurations like~\ref{eq.one}. Then, there is an infinite
suffix of this computation in which the actor  does not perform actions.
This means that at least one actor  performs infinitely many actions
by executing the methods {\it item} and {\it bottom}. But this is not possible
because {\it bottom} blocks the actor if it is invoked twice without
executing update actions on the register in between.

The proof of (3) simply considers two possible cases: either some
fields {\tt stop} is set to  during the computation or not.
In the first case the corresponding register of the 2FTM enters a faulty state
. In the second case the instruction has been correctly
executed.





The property (1) guarantees that if a 2FTM has an infinite computation
then also the corresponding encoding has an infinite computation.
The opposite follows from (1) and (2): if the encoding has an infinite
computation, it traverses infinitely many configurations representing
configurations of the corresponding 2FTM, thus it also has an infinite 
computation.
The undecidability result can be easily extended
to the process reachability problem. It suffices to
modify the process modeling an  (not numbered with 0)
by replacing  with 
a process  different from all the other processes in
Figure~\ref{fig:2CM_actor}. We have that
 is reachable if and only if the 2CM with the same program of
the given 2FTM terminates.
\qed
\fi



\subsection{The language {\actro}}
\label{ssec.readonly}
We show that {\actro}
is Turing-complete by means of an encoding of a 2CM
-- see Figure~\ref{fig:2CM_actor2}. 
In this encoding the two registers
are represented by two disjoint stacks of actors linked by the  field.
The top elements of the two stacks are passed as parameters  and  
of the {\it run} method
of the controller. As before, this actor encodes the control of the 2CM.

The instruction {\sf Inc} is implemented by pushing an element on top of the
corresponding stack. This element is an actor of class  
storing in its field 
the old pointer of the stack. The new pointer, \emph{i.e.} the new actor name,
is
passed to the next invocation of the {\it run} method.


The instruction {\sf DecJump} is implemented by popping the corresponding
stack. In particular, the method  of the controller is invoked with the
field  of the register being decreased. This pop operation is
performed provided the register that is argument of  is different
from . Otherwise a jump is performed.
Note that the other top of the stack  () and the next instruction
to be executed are simply passed around and therefore they do not need
to be stored in updatable fields.

\begin{thm}
\label{thm.undecidablestateless}
Termination and process reachability 
are undecidable in {\actro}.
\end{thm}

\ifconf
\else

\proof
It is easy to verify that if a 2CM has a computation

then there is a computation

where  is the main process of Figure~\ref{fig:2CM_actor2},
 are defined in 
Figure~\ref{fig:2CM_actor2},
,  and  are
stacks of register actors whose length is  and , respectively. For
instance,  of length  is

The configurations  only contain register  terms  and represent \emph{garbage} (they are
inactive).

In contrast with Theorem~\ref{thm.undecidablestatefull}, the converse 
implication (every computation of the  {\actro} program in Figure~\ref{fig:2CM_actor2}
may be split in subcomputations of finite lengths that correspond to 
2CM transitions) is not difficult because the program of Figure~\ref{fig:2CM_actor2}
is deterministic.

The above correspondence guarantees that the 
computation of the actor system
terminates if and only if 
a  instruction is reached.
The undecidability of process reachability
is proved by using the same arguments
of Theorem~\ref{thm.undecidablestatefull}.
\qed
\fi

\begin{figure}[t]
\iftype
\begin{lstlisting}[frame=single]
actor  {
	fields { dec }
	method one() = ( [dec = ]   one()  skip )  dec  
	method inc(pc) =   one()  Ctrl  run(pc)
	method decJump(pc, pc') = 
		dec      checkZero(pc, pc')
	method checkZero(pc, pc') =
		[dec = ] Ctrl  run(pc')  Ctrl  run(pc)
	method init() = dec  
}
actor Ctrl {
	method run(pc) =
		[pc = 1]  
		. . . 
		[pc = n]   
	method init() =   init()    init()  Ctrl  run(1)
}
\end{lstlisting}
\else


\bigskip

\leftline{where  is equal to}
\begin{itemize}[label=--]
\item[--]

\qquad if 
;

\medskip

\item[--]

\qquad if 
;

\medskip

\item[--]
 \\
\hfill
if  ;

\medskip

\item[--]
\\
\hfill
if  ;

\medskip

\item[--]
 \qquad if 
.
\end{itemize}\medskip

\leftline{The main process is 
.}
\fi
\caption{Encoding a 2CM in {\actro}}\label{fig:2CM_actor2}
\end{figure}


\section{Decidability results for {\actroba}}
\label{sec.decidability}




We demonstrate that programs in {\actroba}
are well-structured transition systems~\cite{abdulla:96,Finkel:2001}.  This
will allow us to decide a number of properties, such as termination.
We begin with some background on well-structured transition systems.

A reflective and transitive relation is called \emph{quasi-ordering}.
A \emph{well-quasi-ordering} is a quasi-ordering  such that, for every infinite sequence  
, there exist  with  and .

\begin{defi}A \emph{well-structured transition system} is a finitely branching transition system  where  is a quasi-ordering relation on states such that 
\begin{enumerate}
\item 
 is a well-quasi-ordering
\item 
 is upward compatible with , i.e., for every  and  , there exists  such that .
\end{enumerate}
\end{defi}

\noindent Given a state  of a well-structured transition system, 
denotes the set of immediate predecessors of  (i.e., )
while  denotes the set of states greater than  (i.e., ). With abuse of notation we will denote with 
also its natural extension to sets of states.


According to the theory of well-structured transition systems~\cite{abdulla:96,Finkel:2001},
we have that several properties are decidable for such transition systems
(under some conditions discussed below).
We will consider the following properties. 
\begin{defi}
\label{def.otherproblems}
Consider a well-structured transition system .
Given  the \emph{termination problem} is to 
decide whether  has an infinite computation;
the \emph{control-state reachability} problem is to decide,
given , whether there is  
such that .
\end{defi}
In well-structured transition systems termination is decidable when
the transition relation  and the ordering  are
effectively computable. When it is also possible to effectively compute
a finite-basis for the set of states  we have that 
control-state reachability is decidable as well. 

In the following we assume given an actor program with its 
main process and its set of actor class definitions.
The first relation we convey is  that relates renamings,
ranged over by , , 
that are functions mapping variables \emph{that are
not free in the main process} into either actor names or variables.
Let 
{\small
 }
Namely, two renamings are in the relation  if they identify the 
same variables, regardless the value they associate when such a value is a 
variable.
For example, 
and . However  and .
In general, if  and  are injective renamings that 
always return variables then . 
The requirements of  are stronger for actor names:
in this case the two renamings should be identical.
By definition, renamings in relation according to 
never apply to free variables of the main process.
This because these variables are possibly stored in fields of actors and their
renaming might change the behaviours of actors in a way that breaks the 
upward compatibility of the following relation  and 
(\emph{c.f.} proof of Theorem~\ref{thm.decidablestatelessandfinite}, part 
{\bf (2)}). From this also follows that the above renamings \emph{do not change the
main process} (because they do not apply to its free variables).

Let  be the domain of the renaming . 
We denote by  the result of , where 
 is a tuple containing the variables in  
(without repetitions) and .


Next, let  be the least relation on terms  and on processes such that
{\small

}
For example, it is easy to verify that  and that
. On the contrary 
. The rationale behind  is that it
identifies  processes that ``behave in similar ways'', namely they
enqueue ``similar invocations'' in the same actor queue. Method invocations
 of a given actor 
are identified if the processes they trigger
 ``behave in similar ways''.


\begin{lem}
\label{prop.finteterms}
Let  be either a method invocation  or a process of a program in {\actba} (and therefore in {\actroba}).
Let  be
such that  implies . 
Then  is finite.
\end{lem}

\ifconf
\else
\proof
 We demonstrate the lemma for processes, the argument is similar for 
method invocations. So, let   be a process. It is possible to count the 
number of renamings  on  that are different according to
. In fact, the values of renamings on variables that are 
different from   do not play any role in the definition of .

The basic remark is that a renaming  generates a \emph{partition} of the
set : two variables  and  are in the same partition if and only
if . If we restrict to renamings that map variables to
variables (and not actor names), then they are different according to 
 if they
yield different partitions. The number of such renaming is the 
\emph{Bell number} of the cardinality of , let it be
, where  is the cardinality of . In 
addition, in our case, renamings may map a variable 
to an actor name into a finite set . In this case
the identity of the actor name is relevant. If  then 
 is an upper bound to the different renamings according . If  then
the upper bound is . In any case
the number of different renamings according to  is finite.

Henceforth the set  is finite as well.
\qed
\fi


The well-quasi-ordering relation on configurations relies on an (almost standard) 
\emph{embedding relation}  on queues (except the part about , it 
is the one in~\cite{Finkel:2001}):
{\small

}
Then, let
{\small

}
It is worth noticing that the relation  constraints corresponding
elements  and  to have the same states. In fact these states are defined by
the main process using either its free variables or the actor names that it
has created. For this reason there are finitely many of them and the relation
 is parametric with respect to them.

\begin{thm}
\label{thm.decidablestatelessandfinite}
Let  be a transition system of a program
of {\actroba}. 
Then  is a well-structured transition system.
\end{thm}

\ifconf
\else
\proof
{\bf (1)} \emph{ is a well-quasi-ordering}. 
To prove that  is a well-quasi-ordering, we reason by contradiction.
Let  be 
an infinite sequence of states in  such that, for every ,  . 
Let ,, be a sequence of variables not free in the main process.
Consider:

The set  is finite, but all the --possibly infinitely many-- processes
that can be executed
(or the messages that can be received)  
by an actor of class  are renamings  (or ) 
of these terms.
Notice that by Lemma~\ref{prop.finteterms}, the number of terms  
(and ) which are different 
according to  is finite as well. 
It is thus possible to extract 
a subsequence  from 
 such that, for every , in the
elements  and 
of  and , respectively, we have that . Moreover, as we are considering {\actroba} the actor state cannot
be modified, hence .

As we are considering {\actroba}, the set of actor is bound.
Let  be such actor names.
Due to the above arguments, the sequence  may be represented as a sequence of tuples
of queues:

such that  if and only if 
, where  is the 
coordinatewise order defined by

( is the above embedding relation).

We are finally reduced to an infinite sequence of tuples of queues 
such that every tuple cannot be in relation according to 
with any of the subsequent ones.
This fact contradicts the 
\begin{itemize}
\item[] \emph{Higman's Lemma \cite{HigmanLemma}:
if  is a well-quasi-ordering and  is the set of finite 
-sequences ordered by the embedding 
relation  defined using  as pointwise ordering, 
then  is a  well-quasi-ordering.}
\end{itemize}
More precisely, the contradictions follows from the following
consequence of the Higman's Lemma:
\begin{itemize}
\item 
if  is a finite set and  is the set of finite -sequences 
ordered by the embedding 
relation, then  is a  well-quasi-ordering.
\end{itemize}
and from the following statement
\begin{itemize}
\item 
if  is a well-quasi-ordering then  is a well-quasi-ordering.
\end{itemize}



\medskip

{\bf (2)} \emph{ is upward compatible with }.
A state  is \emph{normed}, if, for every field ,  is 
either a free variable in the main process or an actor name.
A configuration is \emph{normed} if the states of the actors are normed.
We observe that the initial configuration is 
 normed.
We also let  whenever .

We first demonstrate that, if 
with  normed, then

\begin{enumerate}[label=(exp-\roman*)]
\item if   and  then
 and 
;

\item if  (respectively ) only contain  free variables in the main process 
and actor names
then  (respectively ) implies
 (respectively ) 
and  implies that  contain  free variables in the main process and actor names and  is normed.
\end{enumerate}

\noindent {(exp-i)} is proved by induction on the hight of the proof-tree of 
. There are two basic cases:
(1)  and (2) . As regards (1),  and the property is
immediate by the hypothesis that . As regards (2),  because
; henceforth the property (because  is evaluated in the state 
 as well). There is one inductive case (because the case of 
is not possible, otherwise  cannot be empty), which is immediate.

{(exp-ii)} is an immediate consequence of the definition of  and
.

\bigskip

\noindent Let . We demonstrate that 

\begin{enumerate}[label=(\roman*)]
\item if  is normed then  is normed as well
(this means that the transition system  of a program
of {\actroba} has normed configurations because the initial state is normed);

\item if  then there exists  such that .
\end{enumerate}
As regards \emph{(i)}, it follows by remarking that in programs of {\actroba},
there is no field update and the unique process
that may create states is the one of  (the main process). Then 
\emph{(i)} derives from the property \emph{(exp-ii)}.

As regards \emph{(ii)}, its proof is a case analysis on the proof-tree of 
 where the cases correspond to the unique rule appearing
in the tree that is not an instance of \rulename{context}. 
Let . Since  then 
 such that, for every
, 
 and . 
The cases are discussed in order.

\begin{enumerate}
\item
 contains an instance of \rulename{let}, namely
 
where . 
By  ,
 must contain  such that  (without loss of 
generality, we are assuming the two bound variables are the same) and .
There are two subcases: (1.1)
 and (1.2) . In (1.1), By \emph{(exp-ii)}, 
this is possible provided  and . It is easy to verify that
 and 
because their unique difference with  and 
is due to the two processes  and .
In (1.2),  because no  can occur in .
Additionally, by definition of ,  and .
Let . By \emph{(exp-i)} we have  and it is easy to verify that .
Henceforth  and 
because their unique difference with  and 
is due to the two processes  and .

\item
 contains an instance of \rulename{invk-s}, namely

Since  then  contains  with
, , and . 
We observe that  and if  and  then
 by \emph{(exp-i)}. Therefore   and  with  because their unique difference with  and 
is due to the two terms 
 and 
.

\item
 contains an instance of \rulename{invk},
namely 
 
There are two subcases: either  or . When 
the proof is similar to the above case (1.1); when  the proof is 
similar to case (2).

\item
 contains an instance of \rulename{inst}, namely

where ,  being the class of ,
 and .
Therefore  and . 
Since  then  and 
 and  and . By the operational semantics rules, we get
 
by performing transitions of the actor , with  
and, by definition, . At this stage, we notice that . We notice that

and

and
.
Therefore 

which implies that  and 
because their unique difference with  and 
is due to the two above processes.

\item
 contains an instance of \rulename{match}, namely

We discuss the case  because the other one is similar to (1.1).
There are three subcases (5.1) both  and  are variables;
(5.2)  is a variable and  is a field; (5.3)  and  are
both fields. In case (5.1), let . Since , then  must contain  with  and . Therefore we may use \rulename{match} to derive
 with .
In case (5.2), let  and .
There are two subcases: (5.2.1)  is a variable or (5.2.2)  is an actor name.
In (5.2.1),  has to be a free variable in the main process because we are
using \rulename{match} ( may contain either such variables or actor names, additionally, renamings never return free variables in the main process). Therefore, by 
, we have that  contains  with  and . The consequence is that
 with  
because their unique difference with  and 
is due to the two either the pair of processes , 
or , .
Similarly for (5.2.2). 
The case (5.3) is obvious. 

\item
 contains an instance of \rulename{mmatch}. Similar to (5).

\item
 contains an instance of \rulename{plus-l} or of 
\rulename{plus-r}. Straightforward.
\qed
\end{enumerate}
\fi


We notice that the well-structured transition system  
has decidable algorithms for computing  and for computing the next states. 
Then decidability of termination directly follows from the above mentioned
results of the theory of well-structured transition systems that we have
previously recalled.
\ifcamera
Then decidability of termination follows.
\else
\fi

\ifcamera
\else
\fi

\begin{thm}
\ifcamera
In {\actroba} termination is decidable.
\else
In programs of {\actroba}
the termination
problem is decidable.
\fi
\end{thm}

We now move to the definition of an appropriate algorithm for the
computation of a finite basis for the predecessors of a given configuration,
so to conclude also the decidability of control-state reachability.

\begin{lem}
\label{lem.pred}
Let  be a well-structured transition system 
of a program in {\actroba}, and let . Then there is a finite set  
such that, for every , there is 
with .  can be effectively computed.
\end{lem}

\ifconf
\else

\proof
We show how to compute . Let . The \emph{predecessor processes} of  are the following ones:
(\emph{i}) , with , for some 
 and some ;
(\emph{ii}) ;
(\emph{iii}) ;
(\emph{iv}) ;
(\emph{v}) ;
(\emph{vi}) ;
(\emph{vii})  is an instance of a method body of the actor class of .
If  is of actor class  then we take all the method bodies of
 with a suffix matching one of the cases (\emph{i})--(\emph{vi}) 
above (in this case, the expressions in (\emph{ii}) are either variables or
actor names). If  then we look for a matching suffix of the 
main process. The above six cases are demonstrated 
in the presence of such suffixes.

We only discuss case (\emph{i}), the other ones are similar.
In case (\emph{i}), if  is of actor class , then 
, for some . If  then   contains the configuration
 with 
. Otherwise  contains the configuration
, for  and for a unique .
When  then  may be  (orherwise the 
argument is as before). 
If  and  with 
then   contains the configuration

(and this for every possible  such that
 is in ).
\qed
\fi

Lemma~\ref{lem.pred} and the above mentioned results
on well-structured transition systems
allow us to decide the 
\ifcamera
 \emph{control-state
reachability problem}:
given two states  and  of a well-structured transition system with well-quasi-ordering
, decide
whether there is  such that .
\else
 \emph{control-state
reachability problem}.
\fi

\begin{thm}
\label{thm.cs-reachability}
\ifcamera
In {\actroba} process reachability is decidable.
\else
In programs of {\actroba}
the control-state reachability problem is decidable.
\fi
\end{thm}

\ifconf
\else
\proof
Let . Let also
. 
By definition of , . Therefore 
, where  is the finite set of Lemma~\ref{lem.pred}
that is effectively computable. 
\qed
\fi

Next we discuss the process reachability problem -- 
see Definition~\ref{def.termandreach} -- in {\actroba}. To this aim, we use a 
simpler version of the (classical) diamond property.

\begin{prop}
\label{prop:simpleDiamond}
Let  be a transition system of a program
of {\actroba} and let

( does not move) and 

with  ( moves).
Then there exists  such that
.
\end{prop}
It is worth noticing that the language {\actor} also owns the more classical 
diamond property:
if in a configuration there are two transitions inferred by two
distinct actors, then it is possible to perform them in any order
reaching the same configurations \emph{up-to bijective renaming}.
We omit the formalization of this property since it is not needed
in the rest of the paper.

\begin{cor}
The process reachability problem
is decidable in {\actroba}.
\end{cor}

\begin{proof}
In order to verify whether a configuration 

is reachable with  equal to  up-to renaming of variables and \emph{actor names},
we  proceed as follows.

First, by Proposition~\ref{prop:simpleDiamond}
it is not restrictive to consider the set of configurations 
reachable by completely executing the actor  only.
The cardinality of  is bounded by , where  is the maximal nesting
of  in the main process. 
If one of the processes in the configurations reached by executing  is
equal to , up-to renaming of variables and \emph{actor names}, then we are done.
Otherwise, let  be the free variables in the main process.
For each of 
 in ,
we check control-state reachability
from 
 to at least one of the states
in the following finite set:

Then the corollary follows by Theorem~\ref{thm.cs-reachability}.
\end{proof}

We conclude this section by recalling that 
we have already proved
the undecidability of termination in programs with unboundedly many 
actors and read-only fields.
Note that 
if we remove from {\actroba} the constraint on bounded actor names
then  the relation  is no longer a well-quasi-ordering.
Consider, for instance, an actor (with empty state) having a method 
that first creates a new instance of the same class and then invokes 
on this new instance the same method. Among the reachable configurations
it is possible to select a sequence 
 such that
the configuration  is defined as follows:

It is easy to see that, 
for every ,  . 



\iffalse
\subsection{The sublanguage without variables}
Let us restrict to the sublanguage where method definitions 
are terms , namely the tuple of variables is empty. Therefore,
by correctness, method invocations have shape .


Consider the following \emph{embedding relation} on queues~\cite{Finkel:2001}:

Then we define the following relation on states:




\begin{thm}
Let  be a transition system of a program. 
Then  is a well-structured transition system.
\end{thm}

\ifconf
\else
\proof {\bf (1)} \emph{ is a well-quasi-ordering}. It is easy to prove that 
 is a quasi-ordering.
In order to prove that  is a well-quasi-ordering, we reason by contradiction.
Let  be 
an infinite sequence such that, for every ,  . It is possible to restrict the argument to the following subcases:
\begin{description}
\item[(1.a)] 
the sequence is such that for every ,   (all the states are incomparable).
\item[(1.b)] 
the sequence is such that for every ,   and 
 (there exists an infinite strictly decreasing sequence).
\end{description}
[Otherwise, it is possible to extract infinite subsequences matching either with 
{\bf (1.a)} or {\bf (1.b)}.]

As regards subcase {\bf (1.a)}, since actor names  have finitely
many  such that  belong to some configuration of ,
it is possible to extract 
a subsequence  from 
 such that, for every , elements  and 
in  and , respectively, have .

Due to the above arguments, the sequence  may be represented as a sequence of tuples of 
queues 

such that  if and only if 
, where  is the 
coordinatewise order defined by

where  is the above embedding relation.

Therefore, we are finally reduced to an infinite sequence of tuple of queues 
that are pairwise incomparable according to . This fact contradicts:
\begin{itemize}
\item 
\emph{Higman's Lemma} \cite{HigmanLemma} that states: if  is a finite set and  is the set of finite X-sequences ordered by the embedding 
relation, then  is a  well-quasi-ordering;

\item 
if  is a well-quasi-ordering then  is a well-quasi-ordering.
\end{itemize}

As regards {\bf (1.b)} it is easy to verify that it is not possible.

\medskip

{\bf (2)} \emph{ is upward compatible with }. The proof is a case analysis on .
The interesting case is when  is produced by the axiom 
,
with . Therefore  and 
.
Let . 
By definition of ,
 with  and , for every .

We demonstrate a stronger property. Namely, 
\begin{quote}
\emph{if the above  has a generic process , then  and }. 
\end{quote}
We notice that,
strictly speaking  because  may be 
not . The
proof is by double induction on the 
structure of  and on the length of the queue .

The base case is when  and  is empty. This is trivial. 
The inductive cases are (i)  is either
 or  or
, and (ii)  and .
Both in case (i) and in case (ii) it is easy to verify that  and  matches the inductive hypotheses.
\qed
\fi

\bigskip

We notice that the well-structured transition system  has transitive and stuttering compatibility (see \cite{Finkel:2001}, pp 9, 10). Additionally,  has decidable algorithms for 
computing  and for computing the next states. Then, by Theorems 4.6
and 4.8 in~\cite{Finkel:2001}:

\begin{thm}
\begin{enumerate}
\item
Termination is decidable in .
\item
The control-state maintainability problem and the inevitability problem are decidable in .
\end{enumerate}
\end{thm}
\fi

\section{Decidability results for {\actsl}}
\label{sec.stateless}

\newcommand{\name}[1]{{\it name}(#1)}
\newcommand{\abseval}[1]{\lleadsto{#1}_\alpha}
\newcommand{\absred}[1]{\stackrel{#1}{\longrightarrow_{\mathsf a}}}
\newcommand{\abst}[1]{\Omega(#1)}
\newcommand{\rearrange}{\bowtie}
\newcommand{\shuffle}[2]{\it shuffle(#1,#2)}
\newcommand{\shuffleq}[2]{\it [\!\![ #1 ]\!\!]_{#2}}
\newcommand{\mulset}{\mathcal M}
\newcommand{\trans}[2]{\ensuremath{\xrightarrow{#1}}}
\newcommand{\abtrans}[2]{\ensuremath{\xrightarrow{#1}}_{\mathsf a}}
\newcommand{\code}[1]{\ensuremath{\mathcal{Q}(#1)}}







We prove that in {\actsl}
termination and process reachability are decidable, too.
As discussed at the end of Section~\ref{sec.decidability},
the ordering defined for {\actroba} is not appropriate for {\actsl}
because in the latter it is possible to dynamically produce unboundedly many actors.
Therefore, in order to compute an upper bound to
the instances of method bodies, which is the basic argument for the model of
Section~\ref{sec.decidability} to be a well-structured transition system, 
we need to abstract
from the identity of these names -- as we have done with variables.
However, in case of actor names, the abstractions we have devised all break the
delivering of messages. 
Therefore we decided to apply our arguments to an abstraction of the operational model where the delivery of messages is inexact: it may be enqueued in every actor of the same class. 
Yet, this abstract model allows us
to derive decidability of termination and process reachability for the original language. 

\begin{table}[t]
The \emph{decorated evaluation relation} : 

The \emph{decorated transition relation} :

\caption{\label{tab.decopsem} The decorated operational semantics of the language {\actsl}}
\end{table}

In order to formalize the correspondence between the concrete and the abstract 
operational semantics, we need to add decorations to processes and transitions
at the concrete level. Such decorations are used to keep track of the causal
dependencies among processes.
The decorated syntax adds a sequence of natural numbers in front of the
process of an actor, namely, we use 
where  has the following meaning: if , then  
identifies the action of emission of the message that caused the method instantiation
from which  was generated, and  is a counter indicating that  is actually 
generated by the method instantiation after  steps.
Notice that for the main process executed by the actor  the sequence
 is empty, and that when a method is instantiated the counter
 is initialized to 0. 
In order to transfer the sequence from the message emitter to the 
receiving actor, we add  at the end of messages.
Namely, messages are now denoted with .
The decorated operational semantics  
is defined in Table~\ref{tab.decopsem}, where the label  can be
either a sequence  or a pair  where the
second element identifies the message issued during the transition.
The decorated operational semantics increments the last number of the 
sequence of a process every time it performs an action, adds to messages
the current sequence of the emitter, and use the sequences
inside messages to initialize the sequence of the method instantiations
(by extending it with 0).

It is trivial to see that the operational semantics in Table~\ref{tab.decopsem}
and the decorated semantics coincide, in the sense that given
one configuration  of {\actsl} we have 
if and only if there exist a label 
and two decorations  and  of  and , respectively,
such that .

As discussed at the beginning of this Section, 
we need a more abstract semantics with inexact message deliveries.
This is obtained by 
changing the operational semantics in Table~\ref{tab.decopsem} by decoupling
the evaluation of the body of a method from
the actor name of that method.
Let  be the \emph{abstract transition relation}
 defined as
 in Table~\ref{tab.decopsem} except the two
rules \rulename{invk-s} and \rulename{invk} for method invocation and the
rule \rulename{inst} for the instantiation of method bodies, which are replaced by 
those in Table~\ref{tab.abstrules}.
\begin{table}[t]
{\small

}
\caption{\label{tab.abstrules} Abstract transition rules for method invocations and
instantiations}
\end{table}
In the abstract transition relation, a message is added in a queue
of an actor \emph{nondeterministically selected}
among those belonging to the
same class of the target actor. The item  is enqueued 
with an additional argument -- the actor name of the target actor. 
This additional argument is used when the method body is instantiated. In fact
it replaces the variable , thus making the execution
of a body invariant regardless the actor that actually performs it.














As an example, consider the task manager specified
in {\actsl} in the Example~\ref{ex:taskManager}.
Also under the abstract semantics  distinct workers
are instantiated, but it is possible for two distinct
tasks to be delivered to the same worker.

We now introduce few notations:
\vspace{-1mm}
\begin{itemize}
\item[--]
Let  be a map
from ``concrete'' to ``abstract'' configurations:
given a configuration , we denote with
 the configuration
obtained from 
by replacing each of its
actors 
with 
where  is obtained from  by adding 
to each method invocation the parameter .
\item[--] Given a decorated configuration  and a label
, such that  or ,
we use  to denote
the process decorated with  in :
 if  contains the actor
, for some
 and .
\item[--] Let  be the following relation 
on variable renamings (not applied to variables that are free
in the main process) 
\vspace{-3mm}
 
Differently from
the definition of ,  does not care of the 
identity of actor names (it is sufficient that
they belong to the same class). \item[--]
Let  be the relation defined as  in Section~\ref{sec.decidability}, with 
instead of . We extend it
to messages containing sequences and actor names as follows:
 iff ,
 and there exists  such that .
We extend it also to labels: 
and  iff 
and there exists  such that .
\end{itemize}


\ifconf
\else

\noindent The following Proposition formalizes the correspondence 
between  and : 
\emph{1.} all  transitions are present also in 
(up-to application of the abstraction 
function  to configurations) and
\emph{2.} all the abstract computations  have a corresponding concrete computation

in which they can be embedded.
\begin{proposition}
\label{prop:abssemantics}
Let  and  be a decorated configuration
and an initial 
decorated configuration 
of {\actsl}, respectively.
\begin{enumerate}
\item
If  then 
;
\item
if  then there exists a computation
 and an injection  
such that, for all , 
we have  and 
.
\end{enumerate}
\end{proposition}

\begin{proof}
The first item trivially holds because the new
rules used in the definition of 
are (strictly) more general than the corresponding
rules used in the definition of .

The second item is proved by induction on the length of the computation 
.

If  then 
with  or  
and , where 
is an immediate derivative of the main process .
It is trivial to see that the same transition
is present in the concrete decorated semantics:
namely,  with 
 and 
.

If 
we consider . 
The inductive hypothesis guarantees the existence of the concrete computation 
 and of the injection  
such that, for all , 
we have  and 
.
We now proceed by case analysis on the last number of the sequence
in .

If the number is 0, then  and the transition is obtained
by applying rule \rulename{inst}
on a message .
The presence of this message in one of the queues in 
guarantees the existence of 
such that .
In the concrete computation we have .
This means that the same message (up-to ) is in the 
queue of an actor  such that  in the concrete state .
We have two subcases: either such method invocation
is instantiated by the actor  during the concrete
computation 
or not. In the first case, there exists  such that 
 that instantiates
the method. The thesis is proved simply by extending the injection
 with  and observing that .
If the method invocation was not instantiated, it is in the
queue of the actor  in the configuration . It is sufficient
to apply the same reasoning on an extension of the concrete computation
that consumes the messages in front of the method invocation with sequence 
and that finally instantiates it.
Such extension exists because processes are finite and non-blocking.

If the number is not 0, we discuss only the case in which 
(with )
because the case  is treated similarly.
In the computation  is guaranteed the presence of a label
containing , i.e.
there exists  such that 
the label  contains .
The process  is the process
that has just performed the action labeled with 
and that performs the action in the transition 
because .
By inductive hypothesis 
hence a process ready to execute an action labeled with the sequence 
occurs also in the concrete state .
We now consider two subcases.
\begin{itemize}
\item
There exists no label 
containing .
In this case 
the process 
still occurs in .
Hence it is possible to extend the computation 

with 
in such a way that .
The thesis is proved simply by extending the injection
 with .
\item
There exists 
such that  contains .
In this case it is not guaranteed
that , due to
nondeterminism. For this reason we construct from 

another concrete computation
that satisfies our thesis.
The first transformation that we apply to 
consists of the cancellation
of the transition  and of all the other transitions
that depends on it. Namely, there are two kinds of transitions that 
must be removed: (i) those labeled with a sequence having a prefix  such that
 and (ii) those causally dependent on the instantiation of messages
that are in  inside the queue of the actor containing the process
decorated with .
Let

be the concrete computation obtained after this elimination of transitions.
We now extend such computation 
by letting the process labeled with 
to execute the expected action labeled with .
Namely, we add
the transition 
such that .
Then, we extend the computation by performing at least
all the transitions removed for the reason (ii) above.
This extension exists because all processes are finite and
nonblocking and because the considered transitions causally depend on
messages that are in  inside the queue of the actor
containing the process decorated with .
Let

be the obtained computation.
The thesis is proved by considering this last concrete
computation, a rearrangement of the injection 
that maps to their new positions the transitions in its codomain
that belong to the group (ii), and by extending it with .\qedhere
\end{itemize}
\end{proof}

\noindent As a direct consequence we have that the abstract semantics preserves
both termination and 
control-state reachability.
\fi
\ifconf
\fi
It remains to prove that termination and process reachability is
decidable for the abstract semantics. To this aim, we consider
a transition system  obtained by removing the 
labels from the transitions .
On this transition system we 
define  as
a variant of the ordering
 defined in the previous section
in such a way that 
turns out to be a well-structured transition system (for configurations 
of stateless programs). 
Let:
\begin{itemize}
\item[--]
Let  be the following relation on message queues:


{\small

}

\item[--]
Let  be the ordering:



\end{itemize}

Next, we observe that Lemma~\ref{prop.finteterms}
can be adapted to the case of unbounded actors
by using  instead of .
Namely, let  be either a process or a method invocation 
of a stateless program and
let  be
such that  implies . 
Proceeding as in the proof of Lemma~\ref{prop.finteterms},
we prove that
 is finite.


\begin{theorem}
\label{thm.decidableforunbounded}
Given a stateless program 
we have that  is a well-structured transition system.
\end{theorem}

\ifconf
\else

\begin{proof}
The proof is as in Theorem~\ref{thm.decidablestatelessandfinite}
with few differences that are discussed below.

In part {\bf (1)} the unique difference is in the 
last part where the coordinatewise order 
on sequences (of length ) of queues of terms 
is used. As we now consider configurations with an unbounded 
number of actors, instead of configurations with a bounded
number  of actors, we need to resort to the 
embedding  defined as follows:

The final contradiction of part {\bf (1)}
is now reached by observing that by Highman's lemma, 
also  is a well-quasi-ordering, as a consequence
of the well-quasi-ordering .

In part {\bf (2)} the unique difference
is for the monotonicity 
transitions due to rules \rulename{invk-a} and \rulename{invk-sa}. The greater configuration
is guaranteed to have a program ready to perform
a corresponding method invocation, but this could 
be addressed to a different actor.
In fact, the ordering 
does not preserve actor names as it was for  
in the proof of Theorem~\ref{thm.decidablestatelessandfinite}. 
But  preserves at least actor
classes. As the abstract transition
system  allows a term  to be
introduced in the queue of any of the actor 
belonging to the same class of ,
the method invocation executed by the greater
configuration can be introduced in the 
queue of the actor corresponding to the target
of the method invocation executed by the
smaller configuration.
\end{proof}
\fi
In the light of the results on well-structured transition
systems recalled at the beginning of Section~\ref{sec.decidability},
this theorem proves the decidability of termination for the abstract semantics.
To prove the decidability of process reachability
we need to prove that a finite basis for predecessors
is effectively computable.


\begin{lemma}
\label{lem.predunbounded}
Let  be a 
well-structured transition system 
of a program in {\actsl}, and let . Then there is a finite set 
such that, for every  and 
, there is 
with .  can be effectively computed.
\end{lemma}

\ifconf
\else

\begin{proof}
The computation of  must extend the 
construction presented in the proof of Lemma~\ref{lem.pred}
in two ways.

The first extension derives from the fact that, 
differently from the ordering  considered 
in Lemma~\ref{lem.pred}, if  
it could be possible for  to have strictly
more actors than .
In these case, it is possible that the predecessor
differs from its successor  for actors
that are not present in .
We can cope with this problem
by applying the procedure described in the proof
of Lemma~\ref{lem.pred} not only to the configuration
, but to all the configurations that can be obtained
by extending  with
one or two additional actors belonging to one of the
finite classes of the considered program. 
In fact, at most two actors are modified by one transition.
Each of these additional actors executes a process obtained
by applying a renaming  to a suffix of 
one of the method definitions
of the corresponding class. As observed
above, there are finitely many processes that can 
be obtained up-to .
Finally, the additional actors
have a queue including at most one
method invocation (in fact, at most one message
can be consumed in one transition). Also in this
case, by considering the 
method definitions of the actor class,
it is easy to see that there are finitely
many different method invocations up-to .

The second extension is trivial and deals with the fact
that in the abstract semantics a method invocations can 
be introduced in the queue of any of the actors
belonging to the same class of the expected target actor.
So the procedure of the proof of Lemma~\ref{lem.pred} for computing
 must be extended to consider also this kind
of transitions.
\end{proof}
\fi

\ifconf
It turns out that 
control-state reachability
is decidable for the
abstract transition system of {\actsl}.
\else
From Theorem~\ref{thm.decidableforunbounded}, this last Lemma 
and the results on well-structured transition
systems recalled at the beginning of Section~\ref{sec.decidability},
we can conclude that also control-state reachability,
besides termination as already commented above,
is decidable for the abstract semantics. From Proposition~\ref{prop:abssemantics}
we have already concluded that the abstract semantics preserves
termination and control-state reachability w.r.t. the concrete 
semantics. Hence, we have that termination and 
control-state reachability are decidable for
stateless actor program. 
\fi

The decidability of control-state reachability entails the decidability of
process reachability.
In fact,
given a process , 
the reachability of a configuration

with  equal to  up-to renaming
 of variables and actor names
can be solved in the abstract transition
system simply by checking the control-state
reachability of at least one 
of the following states.
Let 
be the actor classes of the considered actor system
and let 
 
be such that .
We consider the following finite set of states:

\ifcamera
Note that 
control-state reachability 
is not preserved by the abstract semantics.
In fact, the abstract transition system is guaranteed to 
execute the same method invocations, but this can 
be done in a different order and also by different 
actors.
\else

\fi








 




\section{Conclusions} \label{sec.conclusions}
To the best of our knowledge this paper contains a first systematic study on the computational power of Actor-based languages.
We have focussed on the  pure asynchronous FIFO queueing and dequeuing of method calls between actors in the context of a nominal calculus 
which features the dynamic creation of variable names that can be passed around.
The results proved in this paper can be summarized as follows:
\begin{itemize}
\item
we identified two small but Turing powerful fragments of our Actor language:
the fragment in which only boundedly many actors can be created,
and the fragment in which fields cannot be updated;
\item
we have proved that the fragment obtained as intersection of the 
two above sublanguages is not Turing complete, as properties like
termination and control-state reachability turn out to be decidable;
\item
if Actors are stateless, the language has decidable termination
and control-state reachability even if we consider unboundedly many
Actors. 
\end{itemize}

\noindent We conclude by mentioning 
relevant lines
for future research. Recent work have identified more expressive Actor interaction
mechanisms based an asynchronous method calls implemented by means of the so-called
future variables \cite{BoerCJ07}: we plan to investigate the impact of this
Actor-based synchronization mechanism on our (un)decidability results.
We also plan to extend our study of expressiveness to 
primitives like the release statements in \cite{Johnsen07}. 
These statements support the so-called cooperative shceduling
of method invocations:
method executions can release the 
control of the Actor in such a way that other method executions
can be instantiated or resumed.







\bibliographystyle{abbrv}
\bibliography{Mmajid}

\end{document}
