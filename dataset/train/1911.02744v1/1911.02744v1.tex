\documentclass{article}

\PassOptionsToPackage{numbers, compress}{natbib}






\usepackage[final]{neurips_2019}



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      

\usepackage{graphicx}
\usepackage{bbm}
\usepackage{CJK}
\usepackage{threeparttable}
\usepackage{algpseudocode}
\usepackage{graphics}
\usepackage{epsfig}
\usepackage{multirow}
\usepackage{color}
\usepackage{mathrsfs}
\usepackage{amsmath}
\usepackage{dsfont}
\usepackage{amssymb}
\usepackage{subfigure}
\usepackage{wrapfig}
\usepackage{changes}

\newcommand*\eg{\textit{e.g.}}
\newcommand*\ie{\textit{i.e.}}




\title{PointDAN: A Multi-Scale 3D Domain Adaption Network for Point Cloud Representation}



\author{
    Can Qin\footnotemark[1], Haoxuan You\footnotemark[1], Lichen Wang, C.-C. Jay Kuo, Yun Fu \\
    Department of Electrical \& Computer Engineering, Northeastern University\\
    Department of Computer Science, Columbia University\\
    Department of Electrical and Computer Engineering, University of Southern California\\
    Khoury College of Computer Science, Northeastern University\\
    \texttt{qin.ca@husky.neu.edu, haoxuan.you@columbia.edu, }\\ \texttt{wanglichenxj@gmail.com, cckuo@sipi.usc.edu, yunfu@ece.neu.edu}\\
}
\begin{document}

\maketitle

\begin{abstract}

Domain Adaptation (DA) approaches achieved significant improvements in a wide range of machine learning and computer vision tasks (\ie, classification, detection, and segmentation). However, as far as we are aware, there are few methods yet to achieve domain adaptation directly on 3D point cloud data. The unique challenge of point cloud data lies in its abundant spatial geometric information, and the semantics of the whole object is contributed by including regional geometric structures.  Specifically, most general-purpose DA methods that struggle for global feature alignment and ignore local geometric information are not suitable for 3D domain alignment. In this paper, we propose a novel 3D Domain Adaptation Network for point cloud data (PointDAN). PointDAN jointly aligns the global and local features in multi-level. For local alignment, we propose Self-Adaptive (SA) node module with an adjusted receptive field to model the discriminative local structures for aligning domains. To represent hierarchically scaled features, node-attention module is further introduced to weight the relationship of SA nodes across objects and domains. For global alignment, an adversarial-training strategy is employed to learn and align global features across domains. Since there is no common evaluation benchmark for 3D point cloud DA scenario, we build a general benchmark (\textit{i.e.}, PointDA-10) extracted from three popular 3D object/scene datasets (\textit{i.e.}, ModelNet, ShapeNet and ScanNet) for cross-domain 3D objects classification fashion. Extensive experiments on PointDA-10 illustrate the superiority of our model over the state-of-the-art general-purpose DA methods.\footnote{The PointDA-10 data and official code are uploaded on \url{https://github.com/canqin001/PointDAN}}
\end{abstract}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\footnotetext[1]{Equal Contribution.}


\section{Introduction}\label{intro}
3D vision has achieved promising outcomes in wide-ranging real-world applications (\ie, autonomous cars, robots, and surveillance system). Enormous amounts of 3D point cloud data is captured by depth cameras or LiDAR sensors nowadays. Sophisticated 3D vision and machine learning algorithms are required to analyze its content for further exploitation. Recently, the advent of Deep Neural Network (DNN) has greatly boosted the performance of 3D vision understanding including tasks of classification, detection, and segmentation\cite{qi2017pointnet,feng2018gvcnn,  you2019pvrnet,zhou2018voxelnet}. Despite its impressive success, DNN requires massive amounts of labeled data for training which is time-consuming and expensive to collect. This issue significantly limits its promotion in the real world.

Domain adaptation (DA) solves this problem by building a model utilizing the knowledge of label-rich dataset, \textit{i.e.}, source domain, which generalizes well on the label-scarce dataset, \textit{i.e.}, target domain. However, due to the shifts of distribution across different domains/datasets, a model trained on one domain usually performs poorly on other domains. Most DA methods address this problem by either mapping original features into a shared subspace or minimizing instance-level distances, such as MMD, CORAL~\textit{etc.}, to mix cross-domain features~\cite{borgwardt2006integrating,long2013transfer,sun2016deep}. Currently, inspired by Generative Adversarial Network (GAN)~\cite{goodfellow2014generative}, adversarial-training DA methods, like DANN, ADDA, MCD~\textit{etc.}, have achieved promising performance in DA and drawn increasing attentions~\cite{ganin2014unsupervised,tzeng2017adversarial,saito2018maximum}. They deploy a zero-sum game between a discriminator and a generator to learn domain-invariant representations. However, most of the existing DA approaches mainly target on 2D vision tasks, which globally align the distribution shifts between different domains.  While for 3D point cloud data, the geometric structures in 3D space can be detailedly described, and different local structures also have clear semantic meaning, such as legs for chairs, which in return combine to form the global semantics for a whole object. As shown in Fig.~\ref{f1}, two 3D objects might be weak to align in global, but would have similar 3D local structures, which are easier to be aligned. So it is urgently desired for a domain adaptation framework to focus on local geometric structures in 3D DA scenario. 

To this end, this paper introduces a novel point-based Unsupervised Domain Adaptation Network (PointDAN) to achieve unsupervised domain adaptation (UDA) for 3D point cloud data. The key to our approach is to jointly align the multi-scale, \textit{i.e.}, global and local, features of point cloud data in an end-to-end manner. Specifically, the Self-Adaptive (SA) nodes associated with an adjusted receptive field are proposed to dynamically gather and align local features across domains. Moreover, a node attention module is further designed to explore and interpret the relationships between nodes and their contributions in alignment. Meanwhile, an adversarial-training strategy is deployed to globally align the global features. Since there are few benchmarks for DA on 3D data ( \textit{i.e.}, point cloud) before, we build a new benchmark named PointDA-10 dataset for 3D vision DA. It is generated by selecting the samples in 10 overlapped categories among three popular datasets (\ie, ModelNet~\cite{wu20153d}, ShapeNet~\cite{chang2015shapenet} and ScanNet~\cite{dai2017scannet}). In all, the contributions of our paper could be summarized in three folds:
\begin{itemize}

\item We introduce a novel 3D-point-based unsupervised domain adaptation method by locally and globally align the 3D objects' distributions across different domains.
\item For local feature alignment, we propose the Self-Adaptive (SA) nodes with a node attention to utilize local geometric information and dynamically gather regional structures for aligning local distribution across different domains.
\item We collect a new 3D point cloud DA benchmark, named PointDA-10 dataset, for fair evaluation of 3D DA methods. Extensive experiments on PointDA-10 demonstrate the superiority of our model over the state-of-the-art general-purpose DA methods.
\end{itemize}


\begin{figure*}[t]
\centering
\scalebox{1}{\includegraphics[width=0.95\linewidth]{f1_3.pdf}}\\

\caption{Comparison between 2D-based and 3D-based DA approaches.}\label{f1}

\end{figure*}

\section{Related Works}\label{related}

\subsection{3D Vision Understanding}

Different from 2D vision, 3D vision has various data representation modalities:  multi-view, voxel grid, 3D mesh and point cloud data. Deep networks have been employed to deal with the above different formats of 3D data~\cite{su2015multi,maturana2015voxnet,you2018pvnet, feng2019meshnet}. Among the above modalities, point cloud, represented by a set of points with 3D coordinates , is the most straightforward representation to preserve 3D spatial information. Point cloud can be directly obtained by LiDAR sensors, which brings a lot of 3D environment understanding applications from scene segmentation to automatic driving. PointNet \cite{qi2017pointnet} is the first deep neural networks to directly deal with point clouds, which proposes a symmetry function and a spatial transform network to obtain the invariance to point permutation. However, local geometric information is vital for describing object in 3D space, which is ignored by PointNet. So recent work mainly focuses on how to effectively utilize local feature. For instance, in PointNet++ \cite{qi2017pointnet++}, a series of PointNet structures are applied to local point sets with varied sizes and local features are gathered in a hierarchical way. PointCNN \cite{li2018pointcnn} proposes -Conv to aggregate features in local pitches and applies a bottom-up network structure like typical CNNs. In 3D object detection tasks, \cite{zhou2018voxelnet} proposes to divide a large scene into many voxels, where features of inside points are extracted respectively and a 3D Region Proposal Network (RPN) structure is followed to obtain detection prediction.

In spite of the broad usage, point cloud data has significant drawbacks in labeling efficiency. During labeling, people need to rotate several times and look through different angles to identify an object. In real-world environment where point cloud data are scanned from LiDAR, it also happens that some parts are lost or occluded (\eg{tables lose legs}), which makes efficient labeling more difficult. Under this circumstance, a specific 3D point-based unsupervised domain adaptation method designed to mitigate the domain gap of source labeled data and target unlabeled data is extremely desired.


\subsection{Unsupervised Domain Adaptation (UDA)}

The main challenge of UDA is that distribution shift (\textit{i.e.,} domain gap) exists between the target and source domain. It violates the basic assumption of conventional machine learning algorithms that training samples and test samples sharing the same distribution. To bridge the domain gap, UDA approaches match either the marginal distributions~\cite{sugiyama2008direct,pan2010domain,gong2013connecting,Seg_Lichen_TIP18} or the conditional distributions~\cite{zhang2013domain,courty2017joint} between domains via feature alignment. It addresses this problem by learning a mapping function  which projects the raw image features into a shared feature space across domains. Most of them attempt to maximizing the inter-class discrepancy, while minimize the intra-class distance in a subspace simultaneously. Various methods, such as Correlation Alignment (CORAL) \cite{sun2016deep}, Maximum Mean Discrepancy (MMD)~\cite{borgwardt2006integrating,long2013transfer}, or Geodesic distance~\cite{gopalan2011domain} have been proposed. 



Apart from the methods aforementioned, many DNN-based domain adaptation methods have been proposed due to their great capacity in representation learning~\cite{he2016deep,simonyan2014very,krizhevsky2012imagenet}. The key to these methods is to apply DNN to learn domain-invariant features through an end-to-end training scenario. Another kind of approach utilizes adversarial training strategy to obtain the domain invariant representations~\cite{ganin2014unsupervised,tzeng2017adversarial,Dong_2019_ICCV, Qin_2019_ICCV_Workshops}. It includes a discriminator and a generator where the generator aims to fool the discriminator until the discriminator is unable to distinguish the generated features between the two domains. Such approaches include Adversarial Discriminative Domain Adaptation (ADDA)~\cite{tzeng2017adversarial}, Domain Adversarial Neural Network (DANN)~\cite{ganin2014unsupervised}, Maximum Classifier Discrepancy (MCD)~\cite{saito2018maximum}~\textit{etc.} 

\label{method}
\begin{figure*}[t]
\centering
\scalebox{1}{ \includegraphics[width=\linewidth]{f2_5.pdf}}\\

\caption{Illustration of PointDAN which mainly consists of local-level and global-level alignment. }\label{f2}

\end{figure*}

Most of UDA methods are designed for 2D vision tasks and focus on the alignment of global image features across different domains. While in 3D data analytical tasks, regional and local geometry information is crucial for achieving good learning performance. Zhou et al.~\cite{zhou2018unsupervised} firstly introduced UDA on the task of 3D keypoint estimation relying on the regularization of multi-view consistency term. However, this method cannot be extended to more generalized tasks, \ie, classification. In \cite{saleh2019domain, wu2019squeezesegv2}, point cloud data are first projected into 2D images (bird-eye view or front view), and 2D DA methods are applied, which would lose essential 3D geometric information.  To this end, we propose a generalized 3D point-based UDA framework. It well preserves the local structures and explores the global correlations of all local features. Adversarial training strategies are further employed to locally and globally align the distribution shifts across the source and target domains.


\section{Proposed Model}

\subsection{Problem Definition and Notation}

In 3D point-based UDA, we have the access to labeled source domain  where  with  annotated pairs and target domain  of  unlabeled data points. The inputs are point cloud data usually represented by 3-dimensional coordinates  where , , where  is the number of sampling points of one 3D object, with the same label space . It is further assumed that two domains are sampled from the distributions  and  respectively while the i.i.d. assumption is violated due to the distribution shift . The key to UDA is to learn a mapping function  that projects raw inputs into a shared feature space  spreadable for cross-domain samples.










\subsection{Local Feature Alignment}

The local geometric information plays an important role in describing point cloud objects as well as domain alignment. As illustrated in Fig.~\ref{f1}, given the same “table” class, the one from ScanNet misses parts of legs due to the obstacles through LiDAR scanning. The key to align these two “tables” is to extract and match the features of similar structures, \textit{i.e.,} plains, while ignoring the different parts. To utilize the local geometric information, we propose to adaptively select and update key nodes for better fitting the local alignment.

\textbf{Self-Adaptive Node Construction:} Here we give the definition of \textit{node} in point cloud. For each point cloud, we represent its  local geometric structures as  point sets , where the -th region  contains a node  and its surrounding  nearest neighbor points . The location of a node decides where the local region is and what points are included.

To achieve local features, directly employing the farthest point sampling or random sampling to get the center node is commonly used in previous work~\cite{qi2017pointnet++,li2018pointcnn}. These methods guarantee full coverage over the whole point cloud. However, for domain alignment, it is essential to make sure that these nodes cover the structures of common characteristics in 3D geometric space and drop the parts unique to certain objects. In this way, the local regions sharing similar structures are more proper to be aligned, while the uncommon parts would bring a negative transfer influence.

Inspired by deformable convolution in 2D vision~\cite{dai2017deformable}, we propose a novel geometric-guided shift learning module, which makes the input nodes self-adaptive in receptive field for network. Different from Deformable Convolution where semantic features are used for predicting offset, we utilize the local edge vector as a guidance during learning. As show in Fig.~\ref{f2}, our module transforms semantic information of each edge into its weight and then we aggregate the weighted edge vectors together to obtain our predicted offset direction. Intuitively, the prediction shift is decided by the voting of surrounding edges with different significance. We first initialize the location of node by the farthest point sampling over the point cloud to get  nodes, and their  nearest neighbor points are collected together to form  regions. For the -th node, its offset is computed as:

where  and  denote location of node and its neighbor point, so  means the edge direction.  and  are their mid-level point feature extracted from the encoder  and  is the weight from one convolution layer for transforming feature. We apply the bottom 3 feature extraction layers of PointNet as the encoder .  is the predicted location offset of the -th node.

After obtaining learned shift , we achieve the self-adaptive update of nodes and their regions by adding shift back to node  and finding their  nearest neighbor points:




Then the final node features  is computed by gathering all the point features inside their regions:

where  is the weight of one convolution layer for gathering point features in which , and the output node features are employed for local alignment. For better engaging SA node features, we also interpolate them back into each point following the interpolation strategy in \cite{qi2017pointnet++} and fuse them with the original point features from a skip connection. The fused feature is input into next-stage generator for higher-level processing.

\textbf{SA Node Attention: }Even achieving SA nodes, it is unreasonable to assume that every SA node contributes equally to the goal of domain alignment. The attention module, which is designed to model the relationship between nodes, is necessary for weighting the contributions of different SA nodes for domain alignment and capturing the features in larger spatial scales. Inspired by the channel attention \cite{zhang2018rcan}, we apply a node attention network to model the contribution of each SA nodes for alignment by introducing a bottleneck network with a residual structure \cite{he2016deep}:

where  indicates the mean of the -th node feature.  and  represent the ReLU function~\cite{nair2010rectified} and Sigmoid function respectively.  is the weight set of a convolutional layer with  kernels, which reduces the number of channels with the ratio . The channel-upscaling layer , where , increases the channels to its original number with the ratio .






\textbf{SA Node Feature Alignment:} 
The optimization of both offsets and network parameters for local alignment are sensitive to the disturbance of gradients, which makes GAN-based methods perform unstable. Therefore, we minimize the MMD~\cite{borgwardt2006integrating,long2013transfer} loss to align cross-domain SA node features as:

where  is a kernel function and we apply the Radial Basis Function (RBF) kernel in our model.

\subsection{Global Feature Alignment}

After having the features  corresponding to the -th sample by a generator network, the global feature alignment attempts to minimize the distance between features across different domains. In difference of local feature alignment, global feature alignment process is more stable due to the invariance of receptive field of inputs, which provides more options for choosing GAN-based methods. In this paper, we apply Maximum Classifier Discrepancy (MCD)~\cite{saito2018maximum} for global feature alignment due to its outstanding performance in general-purpose domain alignment.



The encoder  designed for SA node feature extraction is also applied for extracting raw point cloud features:  over the whole object. And the point features are concatenated with interpolated SA-node features as  to capture the geometry information in multi-scale. Then, we feed the  to the generator network  which is the final convolution layer (\ie, conv4) of PointNet attached with a global max-pooling to achieve high-level global feature  , where  represents the global feature of the -th sample. And  is usually assigned as 1,024. The global alignment module attempts to align domains with two classifier networks  and  to keep the discriminative features given the support of source domain decision boundaries. The two classifiers  and  take the features  and classify them into  classes as , where  is the -dimensional probabilistic softmax results of classifiers.












To train the model, the total loss is composed of two parts: the task loss and discrepancy loss. Similar as most UDA methods, the object of task loss is to minimize the empirical risk on source domain , which is formulated as follows:




The discrepancy loss is calculated as the  distance between the softmax scores of two classifiers:





\subsection{Training Procedure}

We apply the Back-Propagation~\cite{rumelhart1986learning} to optimize the whole framework under the end-to-end training scenario. The training process is composed of two steps in total:


 Firstly, it is required to train two classifiers  and  with the discrepancy loss  in Eq.~\eqref{e10} and classification loss  obtained in Eq.~\eqref{e9}. The discrepancy loss, which requires to be maximized, helps gather target features given the support of the source domain. The classification loss is applied to minimize the empirical risk on source domain. The objective function is as follows:

 In this step, we train the generator , encoder , the node attention network  and transform network  by minimizing the discrepancy loss, classification loss and MMD loss to achieve discriminative and domain-invariant features. The objective function in this step is formulated as:

where both  and  are hyper-parameters which manually assigned as 1.



\subsection{Theoretical Analysis}

In this section, we analyze our method in terms of the - distance theory~\cite{proof_conver1}. The -distance is defined as 

which represents the discrepancy between the target and source distributions,  and , with regard to the hypothesis class . According to [1], the error of classifier  on the target domain  can be bounded by the sum of the source domain error , the - distance and a constant  which is independent of , \ie,

The relationship between our method and the - distance will be discussed in the following. The - distance can also be denoted as below:


As the term  would be very small if  and  can classify samples over  correctly. In our case,  and  correspond to  and  respectively, which agree on their predictions on source samples . As a result,  can be  approximately calculated by , which is the supremum of  in our problem. If decomposing the hypothesis  into  and , and  into  and , and fix , we can get

Further, we replace  with , and attempt to minimize (\ref{sup}) with respect to :


\begin{table*}[t]
\begin{center}
\caption{Number of samples in proposed datasets. }\label{t2}
\label{tab:dataset}
\scalebox{0.75}{
\centering
\begin{tabular}{c cccccc cccccc}\toprule
\multicolumn{2}{c}{Dataset}&\multicolumn{1}{c}{Bathtub}  &\multicolumn{1}{c}{Bed}&\multicolumn{1}{c}{Bookshelf}&\multicolumn{1}{c}{Cabinet}
&\multicolumn{1}{c}{Chair}  &\multicolumn{1}{c}{Lamp}&\multicolumn{1}{c}{Monitor}&\multicolumn{1}{c}{Plant}&\multicolumn{1}{c}{Sofa}&\multicolumn{1}{c}{Table}&\multicolumn{1}{c}{Total}\\
\midrule
\multirow{2}{*}{\textbf{M}}&Train&106 &515 &572 &200 &889&124 &465 &240&\multicolumn{1}{c}{680}&\multicolumn{1}{c}{392}  &\multicolumn{1}{c}{4, 183}\\
&Test&50 &100 &100  &86 &100&20 &100 &100 &\multicolumn{1}{c}{100}&\multicolumn{1}{c}{100}&\multicolumn{1}{c}{856}\\
\toprule
\multirow{2}{*}{\textbf{S}}&Train&\multicolumn{1}{c}{599} &\multicolumn{1}{c}{167} &\multicolumn{1}{c}{310}  &\multicolumn{1}{c}{1, 076} &\multicolumn{1}{c}{4, 612}&\multicolumn{1}{c}{1, 620} &\multicolumn{1}{c}{762}  &\multicolumn{1}{c}{158} &\multicolumn{1}{c}{2, 198}&\multicolumn{1}{c}{5, 876}  &\multicolumn{1}{c}{17, 378}\\
&Test&\multicolumn{1}{c}{85} &\multicolumn{1}{c}{23} &\multicolumn{1}{c}{50}  &\multicolumn{1}{c}{126} &\multicolumn{1}{c}{662}&\multicolumn{1}{c}{232} &\multicolumn{1}{c}{112}  &\multicolumn{1}{c}{30} &\multicolumn{1}{c}{330}&\multicolumn{1}{c}{842}  &\multicolumn{1}{c}{2, 492}\\
\toprule
\multirow{2}{*}{\textbf{S*}}&Train&\multicolumn{1}{c}{98} &\multicolumn{1}{c}{329} &\multicolumn{1}{c}{464}  &\multicolumn{1}{c}{650} &\multicolumn{1}{c}{2, 578}&\multicolumn{1}{c}{161} &\multicolumn{1}{c}{210}  &\multicolumn{1}{c}{88} &\multicolumn{1}{c}{495}&\multicolumn{1}{c}{1, 037}  &\multicolumn{1}{c}{6, 110}\\
&Test&\multicolumn{1}{c}{26} &\multicolumn{1}{c}{85} &\multicolumn{1}{c}{146}  &\multicolumn{1}{c}{149} &\multicolumn{1}{c}{801}&\multicolumn{1}{c}{41} &\multicolumn{1}{c}{61}  &\multicolumn{1}{c}{25} &\multicolumn{1}{c}{134}&\multicolumn{1}{c}{301}  &\multicolumn{1}{c}{1, 769}\\
\bottomrule \end{tabular}

}
\end{center}
\end{table*}


Problem (\ref{minmax}) is similar to the problem (\ref{e11},\ref{e12}) in our method. Consider the discrepancy loss , we first train classifiers ,  to maximize  on the target domain and next train generator  to minimize , which matches with problem (\ref{minmax}). Although we also need consider the source loss  and MMD loss , we can see from~\cite{proof_conver1} that our method still has a close connection to the - distance. Thus, by iteratively train  and , we can effectively reduce , and further lead to the better approximate  by .


\newpage
\section{PointDA-10 Dataset}

\begin{wrapfigure}{l}{0.6\textwidth}
\includegraphics[width=0.6\textwidth]{Dataset_vis1.pdf}
\caption{Samples of PointDA-10 dataset.} 
\label{fig:dataset_vis}

\end{wrapfigure}
As there is no 3D point cloud benchmark designed for domain adaptation, we propose three datasets with different characteristics, \ie, ModelNet-10, ShapeNet-10, ScanNet-10, for the evaluation of point cloud DA methods. To build them, we extract the samples in 10 shared classes from  ModelNet40~\cite{wu20153d}, ShapeNet~\cite{chang2015shapenet} and ScanNet~\cite{dai2017scannet} respectively. The statistic and visualization are shown in Table \ref{tab:dataset} and Fig. \ref{fig:dataset_vis}. Given the access to the three subdatasets, we organize six types of adaptation scenarios which are \textbf{M  S}, \textbf{M  S*}, \textbf{S  M}, \textbf{S  S*}, \textbf{S*  M} and \textbf{S*  S} respectively.







\textbf{ModelNet-10 (M):} ModelNet40 contains clean 3D CAD models of 40 categories. To extract overlapped classes, we regard 'nightstand' class in ModelNet40 as 'cabinet' class in ModelNet-10, because these two objects almost share the same structure. After getting the CAD model, we sample points on the surface as~\cite{qi2017pointnet++} to fully cover the object.

\textbf{ShapeNet-10 (S):} ShapeNetCore contains 3D CAD models of 55 categories gathered from online repositories. ShapeNet contains more samples and its objects have larger variance in structure compared with ModelNet. We apply uniform sampling to collect the points of ShapeNet on surface, which, compared with ModelNet, may lose some marginal points.

\textbf{ScanNet-10 (S*):} ScanNet contains scanned and reconstructed real-world indoor scenes. We isolate 10 classes instances contained in annotated bounding boxes for classification. The objects often lose some parts and get occluded by surroundings. ScanNet is a challenging but realistic domain.






\section{Experiments}

\subsection{Experiments Setup}

In this section, we evaluate the proposed method under the standard protocol~\cite{gong2013connecting} of unsupervised domain adaptation on the task of point cloud data classification.

\textbf{Implementation Details: }We choose the PointNet~\cite{qi2017pointnet} as the backbone of Encoder  and Generator  and apply a two-layer multilayer perceptron (MLP) as  and . The proposed approach is implemented on PyTorch with Adam~\cite{kingma2014adam} as the optimizer and a NVIDIA TITAN GPU for training. The learning rate is assigned as 0.0001 under the weight decay 0.0005. All models have been trained for 200 epochs of batch size 64. We extract the SA node features from the third convolution layer (\ie, conv3) for local-level alignment and the number of SA node is assigned as 64. 

\textbf{Baselines:} We compare the proposed method with a serial of general-purpose UDA methods including: Maximum Mean Discrepancy (\textbf{MMD})~\cite{long2013transfer}, Adversarial Discriminative Domain Adaptation (\textbf{ADDA})~\cite{tzeng2017adversarial}, Domain Adversarial Neural Network (\textbf{DANN})~\cite{ganin2014unsupervised}, and Maximum Classifier Discrepancy (\textbf{MCD})~\cite{saito2018maximum}. During these experiments, we take the same loss and the same training policy. \textbf{w/o Adapt} refers to the model trained only by source samples and \textbf{Supervised} means fully supervised method.

\textbf{Ablation Study Setup: }To analyze the effects of each module, we introduce the ablation study which is composed of four components: global feature alignment, \textit{i.e.,} \textbf{G}, local feature alignment, \textit{i.e.,} \textbf{L}, SA node module (including adpative offset and attention), \textit{i.e.,} \textbf{A}, and the self-training~\cite{zou2018unsupervised}, \textit{i.e.,} \textbf{P}, to finetune the model with 10\% pseudo target labels generated from the target samples with the highest softmax scores. 

\textbf{Evaluation: } Given the labeled samples in source domain and unlabeled samples from target domain for training, all the models would be evaluated on the test set of target domain. All the experiments have been repeated three times and we then report the average top-1 classification accuracy in all tables.  

\begin{table*}[t]
\begin{center}
\caption{Quantitative classification results (\%) on PointDA-10 Dataset. }\label{t1}
\scalebox{0.85}{
\begin{threeparttable}
 \centering
  \begin{tabular}{ccccc ccccc cc}\toprule \multicolumn{1}{c}{}&\multicolumn{1}{c}{G} &\multicolumn{1}{c}{L}  &\multicolumn{1}{c}{A}&\multicolumn{1}{c}{P} &\multicolumn{1}{c}{MS}  &\multicolumn{1}{c}{MS*}&\multicolumn{1}{c}{SM}&\multicolumn{1}{c}{SS*}&\multicolumn{1}{c}{S*M}&\multicolumn{1}{c}{S*S}&\multicolumn{1}{c}{Avg}\\
\toprule
\multicolumn{1}{c}{w/o Adapt} &{}  &\multicolumn{1}{c}{}  &\multicolumn{1}{c}{} &\multicolumn{1}{c}{} &\multicolumn{1}{c}{42.5} &\multicolumn{1}{c}{22.3} &\multicolumn{1}{c}{39.9}  &\multicolumn{1}{c}{23.5} &\multicolumn{1}{c}{34.2} &\multicolumn{1}{c}{46.9}  &\multicolumn{1}{c}{34.9}\\
\toprule  
\multicolumn{1}{c}{MMD~\cite{long2013transfer}} &{}  &\multicolumn{1}{c}{}  &\multicolumn{1}{c}{} &\multicolumn{1}{c}{} &\multicolumn{1}{c}{57.5} &\multicolumn{1}{c}{27.9} &\multicolumn{1}{c}{40.7}  &\multicolumn{1}{c}{26.7} &\multicolumn{1}{c}{47.3} &\multicolumn{1}{c}{54.8}  &\multicolumn{1}{c}{42.5}\\
\multicolumn{1}{c}{DANN~\cite{ganin2014unsupervised}} &{}  &\multicolumn{1}{c}{}  &\multicolumn{1}{c}{} &\multicolumn{1}{c}{} &\multicolumn{1}{c}{58.7} &\multicolumn{1}{c}{29.4} &\multicolumn{1}{c}{42.3}  &\multicolumn{1}{c}{30.5} &\multicolumn{1}{c}{48.1} &\multicolumn{1}{c}{56.7}  &\multicolumn{1}{c}{44.2}\\
\multicolumn{1}{c}{ADDA~\cite{tzeng2017adversarial}} &{}  &\multicolumn{1}{c}{}  &\multicolumn{1}{c}{} &\multicolumn{1}{c}{} &\multicolumn{1}{c}{61.0} &\multicolumn{1}{c}{30.5} &\multicolumn{1}{c}{40.4}  &\multicolumn{1}{c}{29.3} &\multicolumn{1}{c}{48.9} &\multicolumn{1}{c}{51.1}  &\multicolumn{1}{c}{43.5}\\
\multicolumn{1}{c}{MCD~\cite{saito2018maximum}} &{}  &\multicolumn{1}{c}{}  &\multicolumn{1}{c}{} &\multicolumn{1}{c}{} &\multicolumn{1}{c}{62.0} &\multicolumn{1}{c}{31.0} &\multicolumn{1}{c}{41.4}  &\multicolumn{1}{c}{31.3} &\multicolumn{1}{c}{46.8} &\multicolumn{1}{c}{59.3}  &\multicolumn{1}{c}{45.3}\\
\toprule
\multicolumn{1}{c}{ } &{}  &\multicolumn{1}{c}{}  &\multicolumn{1}{c}{} &\multicolumn{1}{c}{} &\multicolumn{1}{c}{62.5} &\multicolumn{1}{c}{31.2} &\multicolumn{1}{c}{41.5}  &\multicolumn{1}{c}{31.5} &\multicolumn{1}{c}{46.9} &\multicolumn{1}{c}{59.3}  &\multicolumn{1}{c}{45.5}\\
\multicolumn{1}{c}{Ours} &{}  &\multicolumn{1}{c}{}  &\multicolumn{1}{c}{} &\multicolumn{1}{c}{} &\multicolumn{1}{c}{63.7} &\multicolumn{1}{c}{32.1} &\multicolumn{1}{c}{44.5}  &\multicolumn{1}{c}{33.7} &\multicolumn{1}{c}{48.2} &\multicolumn{1}{c}{63.0}  &\multicolumn{1}{c}{47.5}\\
\multicolumn{1}{c}{ } &{}  &\multicolumn{1}{c}{}  &\multicolumn{1}{c}{} &\multicolumn{1}{c}{} &\multicolumn{1}{c}{\textbf{64.2}} &\multicolumn{1}{c}{\textbf{33.0}} &\multicolumn{1}{c}{\textbf{47.6}}  &\multicolumn{1}{c}{\textbf{33.9}} &\multicolumn{1}{c}{\textbf{49.1}} &\multicolumn{1}{c}{\textbf{64.1}}  &\multicolumn{1}{c}{\textbf{48.7}}\\
\toprule
\multicolumn{1}{c}{Supervised} &{}  &\multicolumn{1}{c}{}  &\multicolumn{1}{c}{} &\multicolumn{1}{c}{} &\multicolumn{1}{c}{90.5} &\multicolumn{1}{c}{53.2} &\multicolumn{1}{c}{86.2}  &\multicolumn{1}{c}{53.2} &\multicolumn{1}{c}{86.2} &\multicolumn{1}{c}{90.5}  &\multicolumn{1}{c}{76.6}\\
\bottomrule  \end{tabular}
\renewcommand{\labelitemi}{}
\end{threeparttable}
}
\end{center}

\end{table*}

\subsection{Classification Results on PointDA-10 Dataset}

The quantitative results and comparison on PointDA-10 dataset are summarized in Table~\ref{t1}. The proposed methods outperform all the general-purpose baseline methods on all adaptation scenarios. Although the largest domain gap appears on \textbf{M  S*} and \textbf{S  S*}, ours exhibit the large improvement which demonstrates its superiority in aligning different domains. In comparison to the baseline methods, MMD, although defeated by GAN-based methods in 2D vision tasks, is only slightly inferior and even outperforms them in some domain pairs. The phenomenon could be explained as global features limit the upper bound due to its weakness in representing diversified geometry information. In addition, there still exists a great margin between supervised method and DA methods.



The Table~\ref{t2} represents the class-wise classification results on the domain pair \textbf{M  S}. Local alignment helps boost the performance on most of the classes, especially for Monitor and Chair.  However, some of the objects, \textit{i.e.,} sofa and bed, are quite challenging for recognition under the UDA scenario where the negative transfer happens as the performance could drop on these classes. Moreover, we observed that the imbalanced training samples do affect the performance of our model and other domain adaptation (DA) models, which makes Table~\ref{t2} slightly noisy. Chair, Table, and Sofa (easily confusing with Bed) cover more than 60\% samples in M-to-S scenario which causes the drop of certain classes (e.g., Bed and Sofa). 

\begin{table*}[t]
\caption{Class-wise classification results (\%) on ModelNet to ShapeNet. }\label{t2}
\scalebox{0.700}{
\begin{threeparttable}
 \centering
  \begin{tabular}{ccccc ccccc cccccc}\toprule \multicolumn{1}{c}{}&\multicolumn{1}{c}{G} &\multicolumn{1}{c}{L}  &\multicolumn{1}{c}{A}&\multicolumn{1}{c}{P} &\multicolumn{1}{c}{Bathtub}  &\multicolumn{1}{c}{Bed}&\multicolumn{1}{c}{Bookshelf}&\multicolumn{1}{c}{Cabinet}
&\multicolumn{1}{c}{Chair}  &\multicolumn{1}{c}{Lamp}&\multicolumn{1}{c}{Monitor}&\multicolumn{1}{c}{Plant}&\multicolumn{1}{c}{Sofa}&\multicolumn{1}{c}{Table}&\multicolumn{1}{c}{Avg}\\
\toprule
\multicolumn{1}{c}{w/o Adapt} &{}  &\multicolumn{1}{c}{}  &\multicolumn{1}{c}{} &\multicolumn{1}{c}{} &\multicolumn{1}{c}{59.4} &\multicolumn{1}{c}{1.0} &\multicolumn{1}{c}{18.4}  &\multicolumn{1}{c}{7.4} &\multicolumn{1}{c}{55.7}&\multicolumn{1}{c}{43.5} &\multicolumn{1}{c}{84.8}  &\multicolumn{1}{c}{60.0} &\multicolumn{1}{c}{3.4}&\multicolumn{1}{c}{39.7}  &\multicolumn{1}{c}{37.3}\\
\toprule
\multicolumn{1}{c}{MMD~\cite{long2013transfer}} &{}  &\multicolumn{1}{c}{}  &\multicolumn{1}{c}{} &\multicolumn{1}{c}{} &\multicolumn{1}{c}{77.1} &\multicolumn{1}{c}{0.7} &\multicolumn{1}{c}{20.0}  &\multicolumn{1}{c}{1.6} &\multicolumn{1}{c}{63.6}&\multicolumn{1}{c}{58.4} &\multicolumn{1}{c}{88.8}  &\multicolumn{1}{c}{83.4} &\multicolumn{1}{c}{0.5}&\multicolumn{1}{c}{\textbf{87.6}}  &\multicolumn{1}{c}{48.2}\\

\multicolumn{1}{c}{DANN~\cite{ganin2014unsupervised}} &{}  &\multicolumn{1}{c}{}  &\multicolumn{1}{c}{} &\multicolumn{1}{c}{} &\multicolumn{1}{c}{82.6} &\multicolumn{1}{c}{0.4} &\multicolumn{1}{c}{20.1}  &\multicolumn{1}{c}{1.5} &\multicolumn{1}{c}{72.1}&\multicolumn{1}{c}{52.6} &\multicolumn{1}{c}{90.2}  &\multicolumn{1}{c}{86.7} &\multicolumn{1}{c}{1.0}&\multicolumn{1}{c}{80.2}  &\multicolumn{1}{c}{48.6}\\

\multicolumn{1}{c}{ADDA~\cite{tzeng2017adversarial}} &{}  &\multicolumn{1}{c}{}  &\multicolumn{1}{c}{} &\multicolumn{1}{c}{} &\multicolumn{1}{c}{84.5} &\multicolumn{1}{c}{1.0} &\multicolumn{1}{c}{\textbf{22.9}}  &\multicolumn{1}{c}{2.4} &\multicolumn{1}{c}{66.7}&\multicolumn{1}{c}{62.8} &\multicolumn{1}{c}{83.6}  &\multicolumn{1}{c}{70.1} &\multicolumn{1}{c}{1.8}&\multicolumn{1}{c}{86.8}  &\multicolumn{1}{c}{48.3}\\

\multicolumn{1}{c}{MCD~\cite{saito2018maximum}} &{}  &\multicolumn{1}{c}{}  &\multicolumn{1}{c}{} &\multicolumn{1}{c}{} &\multicolumn{1}{c}{84.8} &\multicolumn{1}{c}{\textbf{4.4}} &\multicolumn{1}{c}{18.4}  &\multicolumn{1}{c}{\textbf{7.7}} &\multicolumn{1}{c}{74.9}&\multicolumn{1}{c}{62.0} &\multicolumn{1}{c}{85.6}  &\multicolumn{1}{c}{80.0} &\multicolumn{1}{c}{1.6}&\multicolumn{1}{c}{82.2}  &\multicolumn{1}{c}{50.2}\\
\toprule
\multicolumn{1}{c}{ } &{}  &\multicolumn{1}{c}{}  &\multicolumn{1}{c}{} &\multicolumn{1}{c}{} &\multicolumn{1}{c}{84.6} &\multicolumn{1}{c}{0.8} &\multicolumn{1}{c}{19.2}  &\multicolumn{1}{c}{1.6} &\multicolumn{1}{c}{75.6}&\multicolumn{1}{c}{61.2} &\multicolumn{1}{c}{\textbf{92.7}}  &\multicolumn{1}{c}{\textbf{86.3}} &\multicolumn{1}{c}{0.9} &\multicolumn{1}{c}{83.4}  &\multicolumn{1}{c}{50.6}\\

\multicolumn{1}{c}{Ours} &{}  &\multicolumn{1}{c}{}  &\multicolumn{1}{c}{} &\multicolumn{1}{c}{} &\multicolumn{1}{c}{\textbf{85.7}} &\multicolumn{1}{c}{2.4} &\multicolumn{1}{c}{20.4}  &\multicolumn{1}{c}{1.0} &\multicolumn{1}{c}{79.0}&\multicolumn{1}{c}{\textbf{64.2}} &\multicolumn{1}{c}{90.1}  &\multicolumn{1}{c}{83.3} &\multicolumn{1}{c}{\textbf{3.6}} &\multicolumn{1}{c}{83.0}  &\multicolumn{1}{c}{\textbf{51.3}}\\

\multicolumn{1}{c}{ } &{}  &\multicolumn{1}{c}{}  &\multicolumn{1}{c}{} &\multicolumn{1}{c}{} &\multicolumn{1}{c}{84.7} &\multicolumn{1}{c}{1.6} &\multicolumn{1}{c}{19.0}  &\multicolumn{1}{c}{1.3} &\multicolumn{1}{c}{\textbf{81.9}}&\multicolumn{1}{c}{63.3} &\multicolumn{1}{c}{90.5}  &\multicolumn{1}{c}{82.3} &\multicolumn{1}{c}{2.2} &\multicolumn{1}{c}{82.9} &\multicolumn{1}{c}{51.0}\\
\toprule
\multicolumn{1}{c}{Supervised} &{}  &\multicolumn{1}{c}{}  &\multicolumn{1}{c}{} &\multicolumn{1}{c}{} &\multicolumn{1}{c}{88.9} &\multicolumn{1}{c}{88.6} &\multicolumn{1}{c}{47.8}  &\multicolumn{1}{c}{88.0} &\multicolumn{1}{c}{96.6}&\multicolumn{1}{c}{90.9} &\multicolumn{1}{c}{93.7}  &\multicolumn{1}{c}{57.1} &\multicolumn{1}{c}{92.7} &\multicolumn{1}{c}{91.1}  &\multicolumn{1}{c}{83.5}\\
\bottomrule  \end{tabular}
\renewcommand{\labelitemi}{}
\end{threeparttable}
}

\end{table*}


\subsection{Quantitative Analysis}\label{QA}

\textbf{Ablation Study: } We further analyze the effect of four components proposed in our model (\textit{i.e.,} \textbf{G}, \textbf{L}, \textbf{S}, \textbf{A}). From the Table~\ref{t1}, we find that together with SA node, adding local alignment will bring significant improvement, but only local alignment with fixed node wouldn't improve a lot. Above results substantially validate the effectiveness of our SA nodes that attributes to its self-adapt in region receptive field and significant weight. And an interesting phenomenon in Table~\ref{t2} is that the full version method is defeated by \textbf{G+L+A} in class-wise accuracy. It means that inference of pseudo labels is easily influenced by imbalance distribution of samples in different classes where certain classes would dominate the process of self-training and cause errors accumulation.



\textbf{Convergence: }We evaluate the convergence of proposed methods as well as baseline methods on ModelNet-to-ShapeNet in Fig.~\ref{fig:d}. Compared with baselines methods, local alignment helps accelerate the convergence and makes them more stable since being convergent.

\textbf{SA Node Feature Extraction Layer: } The influence of different layers for mid-level feature extraction is analyzed in Fig.~\ref{fig:c} on \textbf{M  S} and \textbf{S*  M}. Compared with conv1 and conv2 whose features are less semantical, conv3 contains the best mid-level feature for local alignment.

\subsection{Results Visualization}

We visualize the top contributed SA nodes for local alignment of two cross-domain objects to interpret the effectiveness of local feature alignment in Fig.~\ref{fig:a}-\ref{fig:b}. The matched nodes are selected from the elements with the highest values from the matrix  obtained from Eq.~\ref{e3}. It is easily observed that the SA nodes representing similar geometry structure, \ie, legs, plains, contribute most to local alignment no matter they are between same objects or different objects across domains. It significantly demonstrates the common knowledge learned by SA nodes for local alignment.
\begin{figure}[t!]
\centering
\subfigure[]
{
\includegraphics[width=30mm]{align_vis2_2.pdf}\label{fig:a}
}
\subfigure[]
{
\includegraphics[width=30mm]{align_vis1_2.pdf}\label{fig:b}
}
\subfigure[]
{
\includegraphics[width=33mm]{bar_n1.pdf}\label{fig:c}
}
\subfigure[]
{
\includegraphics[width=33mm]{curve_n1.pdf}\label{fig:d}
}

\caption{(a)-(b) Matched SA nodes for aligning cross-domain objects. (c) Analysis of different feature extraction layers for local feature alignment, and (d) convergence analysis.}\label{f3} 

\end{figure}




\section{Conclusion}
In this paper, we propose a novel 3D Unsupervised Domain Adaptation Network on Point Cloud Data (PointDAN). PointDAN is a specifically designed framework based on multi-scale feature alignment. For local feature alignment, we introduce Self-Adaptive (SA) nodes to represent common geometry structure across domains and apply a GAN-based method to align features globally. To evaluate the proposed model, we build a new 3D domain adaptation benchmark. In the experiments, we have demonstrated the superiority of our approach over the state-of-the-art domain adaptation methods.

\textbf{Acknowledgements}

We thank Qianqian Ma from Boston University for her helpful theoretical insights and comments for our work.

\bibliographystyle{abbrv}
\bibliography{ref}

\end{document}
