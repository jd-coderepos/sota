\documentclass{tlp}




\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}




\newcommand{\theHalgorithm}{\arabic{algorithm}}
\usepackage{hyperref}

\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{example}{Example}
\newtheorem{proposition}{Proposition}

\newcommand{\coloneq}{\mbox{ :- }}
\newcommand{\val}{\simeq\!\!}

\DeclareSymbolFont{bbold}{U}{bbold}{m}{n}
\DeclareSymbolFontAlphabet{\mymathbb}{bbold}

\begin{document} 

\title{The Magic of Logical Inference in Probabilistic Programming}

\author[B.~Gutmann, I.~Thon, A.~Kimmig, M.~Bruynooghe, L.~De~Raedt]{Bernd Gutmann,
            Ingo Thon, Angelika Kimmig, Maurice Bruynooghe and Luc De~Raedt \\
            Department of Computer Science, Katholieke Universiteit Leuven,\\
            Celestijnenlaan 200A - bus 2402, 3001 Heverlee, Belgium\\
            \{firstname.lastname\}@cs.kuleuven.be}

 \maketitle

\begin{abstract} 
  Today, many different probabilistic programming languages exist and
  even more inference mechanisms for these languages.  Still, most
  logic programming based languages use backward reasoning based on
  SLD resolution for inference. While these methods are typically
  computationally efficient, they often can neither handle infinite
  and/or continuous distributions, nor evidence.  To overcome these
  limitations, we introduce distributional clauses, a variation and
  extension of Sato's distribution semantics. We also contribute a
  novel approximate inference method that integrates forward reasoning
  with importance sampling, a well-known technique for probabilistic
  inference. To achieve efficiency, we integrate two logic programming
  techniques to direct forward sampling. Magic sets are used to focus
  on relevant parts of the program, while the integration of backward
  reasoning allows one to identify and avoid regions of the sample
  space that are inconsistent with the evidence.
\end{abstract}


\section{Introduction} 
The advent of statistical relational learning
\cite{Getoor07,DeRaedtAPRIL08} and probabilistic programming
\cite{NIPSWorkshop} has resulted in a vast number of different languages and systems such as
PRISM~\cite{SatoKameya:01}, ICL~\cite{Poole08},
ProbLog~\cite{DeRaedt07-IJCAIa}, Dyna~\cite{Eisner05},
BLPs~\cite{Kersting08}, CLP()~\cite{clpbn},
BLOG~\cite{Milch05}, Church~\cite{Goodman08}, IBAL~\cite{Pfeffer01},
and MLNs~\cite{Richardson:06}. While inference in these languages
generally involves evaluating the probability distribution defined by
the model, often conditioned on evidence in the form of known truth
values for some atoms, this diversity of systems has led to a variety
of inference approaches.  Languages such as IBAL, BLPs, MLNs and
CLP() combine knowledge-based model construction to
generate a graphical model with standard inference techniques for such
models.  Some probabilistic programming languages, for instance BLOG
and Church, use sampling for approximate inference in generative
models, that is, they estimate probabilities from a large number of
randomly generated program traces. Finally, probabilistic logic
programming frameworks such as ICL, PRISM and ProbLog, combine
SLD-resolution with probability calculations.

So far, the second approach based on sampling has received little
attention in logic programming based systems.  In this paper, we
investigate the integration of sampling-based approaches into
probabilistic logic programming frameworks to broaden the
applicability of these.  Particularly relevant in this regard are the
ability of Church and BLOG to sample from continuous distributions and
to answer conditional queries of the form  where  is the
evidence.  To accommodate (continuous and discrete) distributions, we
introduce \emph{distributional clauses}, which define random variables
together with their associated distributions, conditional upon logical
predicates.  Random variables can be passed around in the logic
program and the outcome of a random variable can be compared with
other values by means of special built-ins.  To formally establish the
semantics of this new construct, we show that these random variables
define a basic distribution over facts (using the comparison
built-ins) as required in Sato's distribution
semantics~\cite{Sato:95}, and thus induces a distribution over least
Herbrand models of the program. This contrasts with previous instances
of the distribution semantics in that we no longer enumerate the
probabilities of alternatives, but instead use arbitrary densities and
distributions. 

From a logic programming perspective, BLOG~\cite{milch:aistats2005}
and related approaches perform \emph{forward reasoning}, that is, the
samples needed for probability estimation are generated starting from
known facts and deriving additional facts, thus generating a
\emph{possible world}. PRISM and related approaches follow the
opposite approach of \emph{backward reasoning}, where inference starts
from a query and follows a chain of rules backwards to the basic
facts, thus generating \emph{proofs}. This difference is one of the
reasons for using sampling in the first approach: exact forward
inference would require that all possible worlds be generated, which
is infeasible in most cases.  Based on this observation, we contribute
a new inference method for probabilistic logic programming that
combines sampling-based inference techniques with forward
reasoning. On the probabilistic side, the approach uses rejection
sampling~\cite{KollerFriedman09}, a well-known sampling technique that
rejects samples that are inconsistent with the evidence.  On the logic
programming side, we adapt the \emph{magic set}
technique~\cite{bancilhon} towards the probabilistic setting, thereby
combining the advantages of forward and backward
reasoning. Furthermore, the inference algorithm is improved along the
lines of the \emph{SampleSearch}
algorithm~\cite{Gogate09samplesearch:importance}, which avoids choices
leading to a sample that cannot be used in the probability estimation
due to inconsistency with the evidence. We realize this using a
heuristic based on backward reasoning with limited proof length, the
benefit of which is experimentally confirmed.  This novel approach to
inference creates a number of new possibilities for applications of
probabilistic logic programming systems, including continuous
distributions and Bayesian inference.

This paper is organized as follows: we start by reviewing the basic
concepts in Section~\ref{sec:prelim}.  Section~\ref{sec:semantics}
introduces the new language and its semantics,
Section~\ref{sec:algorithms} a novel forward sampling algorithm for
probabilistic logic programs. Before concluding, we evaluate our
approach in Section~\ref{sec:experiments}.


\section{Preliminaries}
\label{sec:prelim}
\subsection{Probabilistic Inference} 
\label{sec:probinf}

A discrete probabilistic model defines a probability
distribution~ over a set~ of basic outcomes, that
is, value assignments to the model's random variables. This
distribution can then be used to evaluate a conditional probability
distribution , also called
\emph{target distribution}.  Here,  is a query involving random
variables, and  is the \emph{evidence}, that is, a partial value
assignment of the random variables\footnote{If  contains
  assignments to continuous variables,  is zero. Hence, evidence
  on continuous values has to be defined via a probability density
  function, also called a sensor model.}.  Evaluating this target
distribution is called \emph{probabilistic
  inference}~\cite{KollerFriedman09}. In probabilistic logic
programming, random variables often correspond to ground atoms,
and~ thus defines a distribution over truth value
assignments, as we will see in more detail in Sec.~\ref{sec:ds} (but
see also~\citeNP{NIPSWorkshop}). Probabilistic inference then asks for
the probability of a logical query being true given truth value
assignments for a number of such ground atoms.

In general, the probability~ of a query~ is in the
discrete case the sum over those outcomes  that are
consistent with the query.  In the continuous case, the sum is
replaced by an (multidimensional) integral and the
distribution~ by a (product of) densities
 That is,

where  if  and 
otherwise.  As common (e.g.~\cite{wasserman04allof}) we will use for
convenience the notation  as unifying notation for both
discrete and continuous distributions.

As  is often very large or even infinite, exact inference
based on the summation in~\eqref{eq:exact} quickly becomes infeasible,
and inference has to resort to approximation techniques based on
\emph{samples}, that is, randomly drawn outcomes . Given a large set of such samples  drawn
from~, the probability~ can be estimated as the
fraction of samples where  is true. If samples are instead drawn
from the target distribution , the latter can directly be
estimated as


However, sampling from~ is often highly inefficient or
infeasible in practice, as the evidence needs to be taken into
account. For instance, if one would use the standard definition of
conditional probability to generate samples from , all
samples that are not consistent with the evidence do not contribute to
the estimate and would thus have to be discarded or, in sampling
terminology, \emph{rejected}.

More advanced sampling methods therefore often resort to a so-called
\emph{proposal distribution} which allows for easier sampling. The
error introduced by this simplification then needs to be accounted for
when generating the estimate from the set of samples.  An example for
such a method is \emph{importance sampling}, where each sample~
has an associated \emph{weight}~. Samples are drawn from an
\emph{importance distribution}~, and weights are
defined as . The true target
distribution can then be estimated as

where  is a normalization constant. The simplest
instance of this algorithm is \emph{rejection sampling} as already
sketched above, where the samples are drawn from the prior
distribution~ and weights are  for those samples
consistent with the evidence, and  for the others. Especially for
evidence with low probability, rejection sampling suffers from a very
high rejection rate, that is, many samples are generated, but do not
contribute to the final estimate. This is known as the \emph{rejection
  problem}. One way to address this problem is \emph{likelihood
  weighted sampling}, which dynamically adapts the proposal
distribution during sampling to avoid choosing values for random
variables that cause the sample to become inconsistent with the
evidence. Again, this requires corresponding modifications of the
associated weights in order to produce correct estimates.

\subsection{Logical Inference} 
\label{sec:forward}

A (definite) clause is an expression of the form , where  is called head and
 is the body.  A program consists of a set of
clauses and its semantics is given by its least Herbrand model.  There
are at least two ways of using a definite clause in a logical
derivation.  First, there is \emph{backward chaining}, which states
that to prove a goal  with the clause it suffices to prove
; second, there is \emph{forward chaining},
which starts from a set of known facts  and
the clause and concludes that  also
holds~(cf.~\cite{nilsson:book}).  Prolog employs backward chaining
(SLD-resolution) to answer queries.  SLD-resolution is very efficient
both in terms of time and space. However, similar subgoals may be
derived multiple times if the query contains recursive
calls. Moreover, SLD-resolution is not guaranteed to always terminate
(when searching depth-first).  Using forward reasoning, on the other
hand, one starts with what is known and employs the immediate
consequence operator  until a fixpoint is reached. This fixpoint
is identical to the least Herbrand model.

\begin{definition}[ operator]
  \label{def:tpop}
  Let  be a logic program containing a set of definite clauses and
   the set of all ground instances of these clauses.
  Starting from a set of ground facts  the  operator returns
  
\end{definition}


\subsection{Distribution Semantics}
\label{sec:ds}

Sato's distribution semantics~\cite{Sato:95} extends logic programming
to the probabilistic setting by choosing truth values of basic facts
randomly.  The core of this semantics lies in splitting the logic
program into a set  of \emph{facts} and a set  of
\emph{rules}. Given a probability distribution  over the facts,
the rules then allow one to extend  into a distribution over
least Herbrand models of the logic program. Such a Herbrand model is
called a \emph{possible world}.

More precisely, it is assumed that  is ground and
denumerable, and that no atom in  unifies with the head of a rule
in . Each truth value assignment to  gives rise to a unique
least Herbrand model of . Thus, a probability distribution 
over  can directly be extended into a distribution  over
these models. Furthermore, Sato shows that, given an enumeration
 of facts in ,  can be constructed from a
series of finite distributions 
provided that the series fulfills the so-called compatibility
condition, that is,


\section{Syntax and Semantics}
\label{sec:semantics} 

Sato's distribution semantics, as summarized in Sec.~\ref{sec:ds},
provides the basis for most probabilistic logic programming languages
including PRISM~\cite{SatoKameya:01}, ICL~\cite{Poole08},
CP-logic~\cite{Vennekens09} and ProbLog~\cite{DeRaedt07-IJCAIa}.  The
precise way of defining the basic distribution  differs among
languages, though the theoretical foundations are essentially the
same. The most basic instance of the distribution semantics, employed
by ProbLog, uses so-called \emph{probabilistic facts}.  Each ground
instance of a \emph{probabilistic fact} directly corresponds to an
independent random variable that takes either the value ``true'' or
``false''. These probabilistic facts can also be seen as binary
switches, cf.~\cite{Sato:95}, which again can be extended to multi-ary
switches or choices as used by PRISM and ICL. For switches, at most
one of the probabilistic facts belonging to the switch is ``true''
according to the specified distribution. Finally, in CP-logic, such
choices are used in the head of rules leading to the so-called
\emph{annotated disjunction}.

Hybrid ProbLog~\cite{gutmann10ilp} extends the distribution semantics
with continuous distributions.  To allow for exact inference, Hybrid
ProbLog imposes severe restrictions on the distributions and their
further use in the program.  Two sampled values, for instance, cannot
be compared against each other. Only comparisons that involve one
sampled value and one number constant are allowed. Sampled values may
not be used in arithmetic expressions or as parameters for other
distributions, for instance, it is not possible to sample a value and
use it as the mean of a Gaussian distribution. It is also not possible
to reason over an unknown number of objects as BLOG~\cite{Milch05}
does, though this is the case mainly for algorithmic reasons.

Here, we alleviate these restrictions by defining the basic
distribution  over probabilistic facts based on both discrete and
continuous random variables.  We use a three-step approach to define
this distribution. First, we introduce explicit random variables and
corresponding distributions over their domains, both denoted by
terms. Second, we use a mapping from these terms to terms denoting
(sampled) outcomes, which, then, are used to define the basic
distribution  on the level of probabilistic facts. For instance,
assume that an urn contains an unknown number of balls where the
number is drawn from a Poisson distribution and we say
that this urn contains many balls if it contains at least 
balls. We introduce a random variable , and we define
 Here,
 is the Herbrand term denoting the sampled
value of , and 
is a probabilistic fact whose probability of being true is the
expectation that this value is actually greater than . This
probability then carries over to the derived atom  as
well.  We will elaborate on the details in the following.

\subsection{Syntax}
\label{sec:syntax}

In a logic program, following Sato, we distinguish between
probabilistic facts, which are used to define the basic distribution,
and rules, which are used to derive additional atoms.\footnote{A rule
  can have an empty body, in which case it represents a deterministic
  fact.} Probabilistic facts are not allowed to unify with any rule
head.  The distribution over facts is based on random variables, whose
distributions we define through so called distributional clauses.

\begin{definition}[Distributional clause]
  \label{def:disclause}
  A \emph{distributional clause} is a definite clause with an atom
   in the head where  is a binary
  predicate used in infix notation.
\end{definition}

For each ground instance  with  being a substitution
over the Herbrand universe of the logic program, the distributional
clause defines a random variable  and an associated
distribution . In fact, the distribution is only
defined when  is true in the
semantics of the logic program.  These random variables are terms of
the Herbrand universe and can be used as any other term in the logic
program.  Furthermore, a term  constructed from the reserved
functor  represents the outcome of the random variable
. These functors can be used inside calls to special predicates in
.  We assume that there is a fact for each of the ground
instances of these predicate calls. These facts are the
\emph{probabilistic facts} of Sato's distribution semantics. Note that
the set of probabilistic facts is enumerable as the Herbrand universe
of the program is enumerable. A term  links the random
variable  with its outcome. The probabilistic facts compare the
outcome of a random variable with a constant or the outcome of another
random variable and succeed or fail according to the probability
distribution(s) of the random variable(s).


\begin{example}[Distributional clauses]
  \label{ex:probrules}

  

  The defined distributions depend on the following logical clauses:
  

  The distributional clause~\eqref{lbl:ex1} models the number of balls
  as a Poisson distribution with mean 6. The distributional
  clause~\eqref{lbl:ex2} models a discrete distribution for the random
  variable color(B). With probability 0.7 the ball is blue and green
  otherwise. Note that the distribution is defined only for the values
  B for which  succeeds. Execution of
  calls to the latter give rise to calls to probabilistic facts that
  are instances of  and
  .  Similarly, the distributional
  clause~\eqref{lbl:ex3} defines a gamma distribution that is also
  conditionally defined. Note that the conditions in the distribution
  depend on calls of the form 
  with  a value returned by between/3. Execution of this call
  finally leads to calls  and
  .
\end{example} 

It looks feasible, to allow  terms everywhere and to have a
simple program analysis insert the special predicates in the
appropriate places by replacing , , , 
predicates by  facts.  Though extending unification is a
bit harder: as long as a  term is unified with a free
variable, standard unification can be performed; only when the other
term is bound an extension is required.  In this paper, we assume that
the special predicates , ,
, , and
 are used whenever the outcome of a random
variable need to be compared with another value and that it is safe to
use standard unification whenever a  term is used in
another predicate.

For the basic distribution on facts to be well-defined, a program has
to fulfill a set of validity criteria that have to be enforced by the
programmer.

\begin{definition}[Valid program]
  \label{def:validprog}
  A program  is called \emph{valid} if: 

 \begin{description}
  \item[(V1)] In the relation  that holds
    in the least fixpoint of a program, there is a functional
    dependency from  to , so there is a
    unique ground distribution  for each ground random
    variable .

  \item[(V2)] The program is \emph{distribution-stratified}, that is,
    there exists a function  that maps ground atoms to
    and that satisfies the following properties: (1)
    for each ground instance of a distribution clause  holds
     (for all
    ).  (2) for each ground instance of another program clause:
     holds
     (for all ).  (3) for
    each ground atom  that contains (the name of) a random
    variable ,  (with  the head of the
    distribution clause defining ).

  \item[(V3)] All ground probabilistic facts or, to be more precise,
    the corresponding indicator functions are
    \emph{Lebesgue-measurable}.

  \item[(V4)] Each atom in the least fixpoint can be derived from a
    finite number of probabilistic facts (\emph{finite support
      condition}~\cite{Sato:95}).
  \end{description}
\end{definition}

Together, (V1) and (V2) ensure that a single basic distribution 
over the probabilistic facts can be obtained from the distributions of
individual random variables defined in .  The requirement (V3) is
crucial.  It ensures that the series of distributions 
needed to construct this basic distribution is well-defined.  Finally,
the number of facts over which the basic distribution is defined needs
to be countable. This is true, as we have a finite number of constants
and functors: those appearing in the program.

\subsection{Distribution Semantics}
\label{sec:distributionsemantics}

We now define the series of distributions  where we fix an
enumeration  of probabilistic facts such that  where  is a
\emph{ranking function} showing that the program is
distribution-stratified.  For each predicate , we define an \emph{indicator function} as follows:


Furthermore, we set .
We then use the expected value of the indicator function to define
probability distributions  over finite sets of ground facts
. Let  be the set of random
variables these  facts depend on, ordered such that if
, then  (cf.~(V2) in
Definition~\ref{def:validprog}).  Furthermore, let , , and . The latter replaces all
evaluations of random variables on which the  depend by variables
for integration.

\begin{example}[Basic Distribution]
Let . The second distribution in the
series then is
 
\end{example}

By now we are able to prove the following proposition.

\begin{proposition}
  \label{prop:adm}
  Let  be a valid program.   defines a probability measure 
  over the set of fixpoints of the  operator.  Hence,  also
  defines for an arbitrary formula  over atoms in its
  Herbrand base the probability that  is true.
\end{proposition}

\begin{proof}[Proof sketch] 
  It suffices to show that the series of distributions 
  over facts (cf.~\eqref{eq:series}) is of the form that is
  required in the distribution semantics, that is, these are
  well-defined probability distributions that satisfy the
  compatibility condition, cf.~\eqref{eq:compat}. This is a direct
  consequence of the definition in terms of indicator functions and
  the measurability of the underlying facts required for valid
  programs.
\end{proof}


\subsection{ Semantics}
\label{sec:tp}

In the following, we give a procedural view onto the semantics by
extending the  operator of Definition~\ref{def:tpop} to deal with
probabilistic facts . To do so, we
introduce a function \textsc{ReadTable} that keeps track of
the sampled values of random variables to evaluate probabilistic
facts. This is required because interpretations of a program only
contain such probabilistic facts, but not the underlying outcomes of
random variables. Given a probabilistic fact
, \textsc{ReadTable} returns the truth
value of the fact based on the values of the random variables  in
the arguments, which are either retrieved from the table or sampled
according to their definition  as included
in the interpretation and stored in case they are not yet available.

\begin{definition}[Stochastic  operator]
  \label{def:stp}
  Let  be a valid program and  the set of all ground
  instances of clauses in .  Starting from a set of ground facts
   the  operator returns
  
\end{definition}

\textsc{ReadTable} ensures that the basic facts are sampled from their
joint distribution as defined in Sec.~\ref{sec:distributionsemantics} during the
construction of the standard fixpoint of the logic program. Thus, each
fixpoint of the  operator corresponds to a possible
world whose probability is given by the distribution semantics.
 

\section{Forward sampling using Magic Sets and backward reasoning}
\label{sec:algorithms} 

In this section we introduce our new method for probabilistic forward
inference.  To this aim, we first extend the magic set transformation
to distributional clauses. We then develop a rejection sampling scheme
using this transformation. This scheme also incorporates backward
reasoning to check for consistency with the evidence during sampling
and thus to reduce the rejection rate.

\subsection{Probabilistic magic set transformation}
\label{sec:magic}

The disadvantage of forward reasoning in logic programming is that the
search is not goal-driven, which might generate irrelevant atoms.  The
\emph{magic set} transformation~\cite{bancilhon,nilsson:book} focuses
forward reasoning in logic programs towards a goal to avoid the
generation of uninteresting facts. It thus combines the advantages of
both reasoning directions.

\begin{definition}[Magic Set Transformation]
  \label{def:magicsets}
  If  is a logic program, then we use  to denote the
  smallest program such that if  then
  \begin{itemize}
  \item  and
  \item for each : 
  \end{itemize}
\end{definition}

The meaning of the additional  atoms (c=call) is that
they ``switch on'' clauses when they are needed to prove a particular
goal. If the corresponding switch for the head atom is not true, the
body is not true and thus cannot be proven.  The magic transformation
is both sound and complete. Furthermore, if the SLD-tree of a goal is
finite, forward reasoning in the transformed program terminates. The
same holds if forward reasoning on the original program terminates.

We now extend this transformation to distributional clauses. The idea
is that the distributional clause for a random variable  is
activated  when there is a call to a probabilistic fact
 depending on .

\begin{definition}[Probabilistic Magic Set Transformation]
  \label{def:pmagicsets}
  For program , let  be  without distributional clauses.
   is the smallest program s.t.   and for each  and :
  \begin{itemize}
  \item .
  \item .
  \end{itemize}
   Then  consists of:
  \begin{itemize}
  \item a clause  for each
    built-in predicate (including  for
    ) used in
    .

 \item a clause  for each clause   where  if  uses a built-in
    predicate and else .
  \end{itemize}
\end{definition}

Note that every call to a built-in  is replaced by a call
to ; the latter predicate is defined by a clause that
is activated when there is a call to the built-in ()
and that effectively calls the built-in.  The transformed program
computes the distributions only for random variables whose value is
relevant to the query. These distributions are the same as those
obtained in a forward computation of the original program. Hence we
can show:

\begin{lemma}
 Let  be a program and  its probabilistic
  magic set transformation extended with a seed .  The
  distribution over  defined by  and by  is
  the same.
\end{lemma}

\begin{proof}[Proof sketch]
  In both programs, the distribution over  is determined by the
  distributions of the atoms ,
  , , , and
   on which  depends in a forward computation of
  the program . The magic set transformation ensures that these
  atoms are called in the forward execution of .
  In , a call to such an atom activates the
  distributional clause for the involved random variable. As this
  distributional clause is a logic program clause, soundness and
  completeness of the magic set transformation ensures that the
  distribution obtained for that random variable is the same as in
  .  Hence also the distribution over  is the same for both
  programs.
\end{proof}


\subsection{Rejection sampling with heuristic lookahead}

As discussed in Section~\ref{sec:probinf}, sampling-based approaches
to probabilistic inference estimate the conditional probability
 of a query  given evidence  by randomly generating a
large number of samples or possible
worlds~(cf.~Algorithm~\ref{alg:sampling}). The algorithm starts by
preparing the program  for sampling by applying the \textsc{PMagic}
transformation.  In the following, we discuss our choice of subroutine
\textsc{STPMagic} (cf.~Algorithm~\ref{alg:rejection}) which realizes
likelihood weighted sampling.  It is used in
Algorithm~\ref{alg:sampling}, line~\ref{line:callWeightedsample}, to
generate individual samples. It iterates the stochastic consequence
operator of Definition~\ref{def:stp} until either a fixpoint is
reached or the current sample is inconsistent with the
evidence. Finally, if the sample is inconsistent with the evidence, it
receives weight 0.

\begin{algorithm}[t]
  \caption{Main loop for sampling-based inference to calculate the
    conditional probability  for query , evidence  and
    program . }
  \label{alg:sampling}
\begin{algorithmic}[1]
\Function{\textsc{Evaluate}}{, , , }
\State \textsc{PMagic}
\State  \hspace{1cm} 
\While{Not converged}
\State \textsc{STPMagic}\label{line:callWeightedsample}
\State \textbf{if}  \textbf{then}  
\textbf{else}   
\EndWhile
\State \Return 
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[t]
  \caption{Sampling one interpretation; used in
    Algorithm~\ref{alg:sampling}. }
  \label{alg:rejection}
  \begin{algorithmic}[1]
    \Function{STPMagic}{}
    \State , , , , 
    \Repeat 
\State 
\ForAll{}
\State split body in  (prob. facts) and  (the rest)
\ForAll{grounding substitution  such that }
\State , 
\While {}
\State select and remove  from 
\State \textsc{ReadTable} \label{line:samplehead} 
\State  \hspace{1cm}  
\EndWhile
\If {} \If {} \Return 
\Comment{check negative evidence }\EndIf
\State  \hspace{1cm} 
\EndIf
\EndFor
\EndFor
     \Until {} \Comment{Fixpoint or
      impossible evidence}
\If {} \Return  \Comment{check
  positive evidence} \Else \ \Return \EndIf
       \EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[ht]
  \caption{Evaluating a probabilistic fact ; used in
    Algorithm~\ref{alg:rejection}. \textsc{ComputePF}
    computes the truth value and the probability of  according to
    the information in .}
  \label{alg:likelihoodweighting}
  \begin{algorithmic}[1]
    \Function{ReadTable}{}
\If{}
\ForAll {random variable  occurring in  where }
\If{}  \Return   \EndIf
\If {not \Call{Sample}{}}  \Return
 \label{line:sample} \EndIf
\EndFor
\State  \Call{ComputePF}{,} 
\If {}\State\Return  \Comment{inconsistent with evidence}\EndIf
\State extend  with 
\EndIf
\State\Return  as stored in  for 
    \EndFunction
\Procedure{Sample}{}
  \State ,    \Comment{Initial
    weight, temp. distribution}
  \If{} \Comment{finite distribution}
 \For{ where } \Comment{remove neg.~evidence}
  \State , \hspace{1cm}
 \EndFor
\If { and }
\State , \hspace{1cm}  \EndIf

 \For{} \Comment{remove choices that make
    impossible}
 \If{: not \Call{MaybeProof}{}  \textbf{or}\\
 \hspace{1.8cm} : not \Call{MaybeFail}{}
}
  \State , \hspace{1cm}
\EndIf
 \EndFor
\EndIf
 \State \textbf{if} {} \Return false
 \State Sample  according to , extend  with  and \Return true
\EndProcedure
  \end{algorithmic}
\end{algorithm}


Algorithm~\ref{alg:likelihoodweighting} details the procedure used in
line~\ref{line:samplehead} of Algorithm~\ref{alg:rejection} to sample
from a given distributional clause. The function \textsc{ReadTable}
returns the truth value of the probabilistic fact, together with its
weight. If the outcome is not yet tabled, it is computed. Note that
\texttt{false} is returned when the outcome is not consistent with the
evidence. Involved distributions, if not yet tabled, are sampled in
line~\ref{line:sample}. In the infinite case, \textsc{Sample} simply
returns the sampled value. In the finite case, it is directed towards
generating samples that are consistent with the evidence. Firstly, all
possible choices that are inconsistent with the negative evidence are
removed. Secondly, when there is positive evidence for a particular
value, only that value is left in the distribution. Thirdly, it is
checked whether each left value is consistent with all other
evidence. This consistency check is performed by a simple
depth-bounded meta-interpreter. For positive evidence, it attempts a
top-down proof of the evidence atom in the original program using the
function \textsc{MaybeProof}. Subgoals for which the depth-bound is
reached, as well as probabilistic facts that are not yet tabled are
assumed to succeed. If this results in a proof, the value is
consistent, otherwise it is removed. Similarly for negative evidence:
in \textsc{MaybeFail}, subgoals for which the depth-bound is reached,
as well as probabilistic facts that are not yet tabled are assumed to
fail. If this results in failure, the value is consistent, otherwise
it is removed. The  parameter allows one to trade the
computational cost associated with this consistency check for a
reduced rejection rate.

Note that the modified distribution is normalized and the weight is
adjusted in each of these three cases. The weight adjustment takes
into account that removed elements cannot be sampled and is necessary
as it can depend on the distributions sampled so far which elements
are removed from the distribution sampled in \textsc{Sample} (the
clause bodies of the distribution clause are instantiating the
distribution).

\section{Experiments}
\label{sec:experiments}

We implemented our algorithm in YAP Prolog and set up experiments to
answer the questions
\begin{itemize}
\item[\textbf{Q1}] Does the lookahead-based sampling improve the
  performance?
\item[\textbf{Q2}] How do rejection sampling and likelihood weighting compare?
\end{itemize}

To answer the first question, we used the distributional program in
Figure~\ref{fig:experimentnogreen}, which models an urn containing a
random number of balls. The number of balls is uniformly distributed
between 1 and 10 and each ball is either red or green with equal
probability. We draw 8 times a ball with replacement from the urn and
observe its color. We also define the atom
 to be true if and only if we did not
draw any green ball in draw 1 to .  We evaluated the query
 for .  Note that the
evidence implies that the first drawn ball is red, hence that the
probability of the query is 1; however, the number of steps required
to proof that the evidence is inconsistent with drawing a green first
ball increases with D, so the larger is D, the larger Depth is
required to reach a 100\% acceptance rate for the sample as
illustrated in Figure ~\ref{fig:experimentnogreen}.  It is clear that
by increasing the depth limit, each sample will take longer to be
generated. Thus, the  parameter allows one to trade off
convergence speed of the sampling and the time each sample needs to be
generated. Depending on the program, the query, and the evidence there
is an optimal depth for the lookahead.

\begin{figure}[ht]
  \centering
  \begin{minipage}{0.40\textwidth}
    
  \end{minipage}
  \begin{minipage}{0.42\textwidth}
    \includegraphics[scale=0.44]{pics/experimentgreen}
  \end{minipage}
  \vspace{-0.5cm}
  
  \caption{ The program modeling the urn (left); rate of accepted
    samples (right) for evaluating the query
    
     for  and for
     using Algorithm~\ref{alg:sampling}. The
    acceptance rate is calculated by generating 200 samples using our
    algorithm and counting the number of sample with weight larger
    than 0.}
  \label{fig:experimentnogreen}
\end{figure}

To answer \textbf{Q2}, we used the standard example for
BLOG~\cite{Milch05}.  An urn contains an unknown number of balls where
every ball can be either green or blue with . When drawing a
ball from the urn, we observe its color but do not know which ball it
is.  When we observe the color of a particular ball, there is a 
chance to observe the wrong one, e.g. green instead of blue. We have
some prior belief over the number of balls in the urn. If 10 balls are
drawn with replacement from the urn and we saw 10 times the color
green, what is the probability that there are  balls in the urn? We
consider two different prior distributions: in the first case, the
number of balls is uniformly distributed between 1 and 8, in the
second case, it is Poisson-distributed with mean .

\begin{figure}[t]
  \centering
  \includegraphics[scale=0.49]{pics/uniform_std}
  \includegraphics[scale=0.49]{pics/poisson_std}
  \caption{Results of urn experiment with forward reasoning. 10 balls
    with replacement were drawn and each time green was
    observed. Left: Uniform prior over \# balls, right: Poisson prior
    .}
  \label{fig:urnproblog}
\end{figure}

One run of the experiment corresponds to sampling the number  of
balls in the urn, the color for each of the  balls, and for each of
the ten draws both the ball drawn and whether or not the color is
observed correctly in this draw. Once these values are fixed, the
sequence of colors observed is determined. This implies that for a
fixed number  of balls, there are  possible
proofs.  In case of the uniform distribution, exact PRISM inference
can be used to calculate the probability for each given number of
balls, with a total runtime of  seconds for all eight cases. In
the case of the Poisson distribution, this is only possible up to 13
balls, with more balls, PRISM runs out of memory.  For inference using
sampling, we generate 20,000 samples with the uniform prior, and
100,000 with Poisson prior. We report average results over five
repetitions.  For these priors, PRISM generates 8,015 and 7,507
samples per second respectively, ProbLog backward sampling 708 and
510, BLOG 3,008 and 2,900, and our new forward sampling (with
rejection sampling) 760 and 731.  The results using our algorithm for
both rejection sampling and likelihood weighting with  are
shown in Figure~\ref{fig:urnproblog}. As the graphs show, the standard
deviation for rejection sampling is much larger than for likelihood weighting.



\section{Conclusions and related work}
\label{sec:conclusions}

We have contributed a novel construct for probabilistic logic
programming, the distributional clauses, and defined its semantics.
Distributional clauses allow one to represent continuous variables and
to reason about an unknown number of objects. In this regard this
construct is similar in spirit to languages such as BLOG and Church,
but it is strongly embedded in a logic programming context.  This
embedding allowed us to propose also a novel inference method based on
a combination of importance sampling and forward reasoning. This
contrasts with the majority of probabilistic logic programming
languages which are based on backward reasoning (possibly enhanced
with tabling \cite{SatoKameya:01,Mantadelis10iclp}).  Furthermore,
only few of these techniques employ sampling, but see \cite{Kimmig11}
for a Monte Carlo approach using backward reasoning.  Another key
difference with the existing probabilistic logic programming
approaches is that the described inference method can handle
evidence. This is due to the magic set transformation that targets the
generative process towards the query and evidence and instantiates
only relevant random variables.  

P-log~\cite{Baral09} is a probabilistic language based on Answer Set
Prolog (ASP). It uses a standard ASP solver for inference and thus is
based on forward reasoning, but without the use of sampling.  Magic
sets are also used in probabilistic Datalog~\cite{Fuhr00}, as well as
in Dyna, a probabilistic logic programming language \cite{Eisner05}
based on rewrite rules that uses forward reasoning. However, neither
of them uses sampling. Furthermore, Dyna and PRISM require that the
exclusive-explanation assumption.  This assumption states that no two
different proofs for the same goal can be true simultaneously, that
is, they have to rely on at least one basic random variable with
different outcome. Distributional clauses (and the ProbLog language)
do not impose such a restriction.  Other related work includes
MCMC-based sampling algorithms such as the approach for
SLP~\cite{cussensmc}.  Church's inference algorithm is based on MCMC
too, and also BLOG is able to employ MCMC.  At least for BLOG it seems
to be required to define a domain-specific proposal distribution for
fast convergence.  With regard to future work, it would be interesting
to consider evidence on continuous distributions as it is currently
restricted to finite distribution. Program analysis and transformation
techniques to further optimize the program w.r.t. the evidence and
query could be used to increase the sampling speed.  Finally, the
implementation could be optimized by memoizing some information from
previous runs and then use it to more rapidly prune as well as sample.


\section*{Acknowledgements} 

Angelika Kimmig and Bernd Gutmann are supported by the Research
Foundation-Flanders (FWO-Vlaanderen). This work is supported by the
GOA project 2008/08 Probabilistic Logic Learning and by the European
Community's Seventh Framework Programme under grant agreement
First-MM-248258.



\newpage 

\bibliographystyle{acmtrans}
\bibliography{bibtex}

\end{document}
