
\documentclass{article} \usepackage{iclr2020_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}

\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      


\usepackage{microtype}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{booktabs} 


\usepackage{relsize} 
\usepackage{mathtools,xparse}
\usepackage{url}
\usepackage{soul}
\usepackage{multicol} 
\usepackage{multirow}
\usepackage{colortbl} 
\usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{amsmath}
\usepackage{multirow}
\usepackage{amsthm}
\usepackage{ulem}
\usepackage{color}

\usepackage{tikz-cd}
\usepackage{tabulary}
\usepackage{booktabs}
\usepackage[english]{babel}
\usepackage{enumitem}





\usepackage{amssymb}
\usepackage{wasysym}
\makeatletter
\def\oversortoftilde#1{\mathop{\vbox{\m@th\ialign{##\crcr\noalign{\kern3\p@}\sortoftildefill\crcr\noalign{\kern3\p@\nointerlineskip}$\hfil\displaystyle{#1}\hfil$\crcr}}}\limits}

\def\sortoftildefill{$\m@th \setbox\z@\hbox{$\braceld$}\braceld\leaders\vrule \@height\ht\z@ \@depth\z@\hfill\braceru$}

\makeatother

\newtheorem{theorem}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}{Lemma}



\usepackage{array}
\usepackage{bytefield}  






\newcommand{\overbar}[1]{\mkern 1.5mu\overline{\mkern-1.5mu#1\mkern-1.5mu}\mkern 1.5mu}
\newcommand{\ignore}[2]{\hspace{0in}#2}
\newcommand{\xhdr}[1]{{\noindent\bfseries #1}.}

\usepackage{tabulary}
\newcolumntype{K}[1]{>{\centering\arraybackslash}p{#1}}
\usepackage{makecell}

\newcommand{\PP}{\mathbb{P}}
\newcommand{\EE}{\mathbb{E}}



\def\method{InfoGraph}


\title{\method{}: Unsupervised and Semi-supervised Graph-Level Representation Learning via Mutual Information Maximization}



\author{Fan-Yun Sun$^{1,2}$, Jordan Hoffmann$^{2,4}$, Vikas Verma $^{2,3}$, Jian Tang$^{2,5,6}$\\
$^1$National Taiwan University, \\
$^2$Mila-Quebec Institute for Learning Algorithms, Canada \\
$^3$Aalto University, Finland \\
$^4$Harvard University, USA \\
$^5$HEC Montreal, Canada \\
$^6$CIFAR AI Research Chair\\\\
\texttt{b04902045@ntu.edu.tw}\\
\texttt{jhoffmann@g.harvard.edu}\\
\texttt{vikas.verma@aalto.fi}\\
\texttt{jian.tang@hec.ca}
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
This paper studies learning the representations of whole graphs in both unsupervised and semi-supervised scenarios. Graph-level representations are critical in a variety of real-world applications such as predicting the properties of molecules and community analysis in social networks. Traditional graph kernel based methods are simple, yet effective for obtaining fixed-length representations for graphs but they suffer from poor generalization due to hand-crafted designs. There are also some recent methods based on language models (e.g. graph2vec) but they tend to only consider certain substructures (e.g. subtrees) as graph representatives. Inspired by recent progress of unsupervised representation learning, in this paper we proposed a novel method called \method{} for learning graph-level representations. We maximize the mutual information between the graph-level representation and the representations of substructures of different scales (e.g., nodes, edges, triangles).
By doing so, the graph-level representations encode aspects of the data that are shared across different scales of substructures.
Furthermore, we further propose \method{}*, an extension of \method{} for semi-supervised scenarios. \method{}* maximizes the mutual information between unsupervised graph representations learned by \method{} and the representations learned by existing supervised methods.
As a result, the supervised encoder learns from unlabeled data while preserving the latent semantic space favored by the current supervised task. 
Experimental results on the tasks of graph classification and molecular property prediction 
show that \method{} is superior to state-of-the-art baselines and \method{}* can achieve performance competitive with state-of-the-art semi-supervised models.
\end{abstract}

\section{Introduction}


Graphs have proven to be an effective way to represent very diverse types of data including social networks \cite{newman2004finding}, biological reaction networks\cite{pavlopoulos2011using}, protein-protein interactions \cite{krogan2006global}, the quantum mechanical properties of individual molecules \cite{xie2018crystal,jin2018junction}, and many more.  
Graphs provide explicit information about the coupling between individual units in a larger part along with a well defined framework for assigning properties to the nodes and the edges connecting them. 
There has been a significant amount of previous work done studying many aspects of graphs including link prediction \cite{gao2011temporal,wang2011community} and node prediction \cite{blei2003latent}. 
Due to its flexibility, graph-like data structures can capture rich information which is critical in many applications.


At the lowest level, much work has been done on learning node representations-- low-dimensional vector embeddings of individual nodes \cite{perozzi2014deepwalk,tang2015line, node2vec}. 
Another field that has attracted a large amount of attention recently is learning representations of entire graphs. Such a problem is critical in a variety of applications such as predicting the properties of molecular graphs in both drug discovery and material science \cite{chen2019utilizing,chen2019graph}.
There has been some recent progress based on neural message passing algorithms \cite{gilmer2017neural,xie2018crystal}, which learn the representations of entire graphs in a supervised way. These methods have been shown achieving state-of-the-art results on a variety of different prediction tasks \cite{kipf2018neural,xie2018crystal,gilmer2017neural,chen2019graph}.








However, one of the most difficult obstacles for supervised learning on graphs is that it is often very costly or even impossible to collect annotated labels. For example, in the chemical domain labels are typically produced with a costly Density Functional Theory (DFT) calculation. One option is to use semi-supervised methods which combine a small handful of labels with a larger, unlabeled, dataset. In real-world applications, partially labeled datasets are common, making tools that are able to efficiently utilize the present labels particularly useful. 

Coming up with methods that are able to learn unsupervised representations of an entire graph, as opposed to nodes, is an important step in working with unlabeled or partially labeled graphs \cite{narayanan2017graph2vec,hu2019pre,nguyen2017semi}. For example, there exists work that explores pre-training techniques for graphs to improve generalization \cite{hu2019pre}. Another common approach to unsupervised representation learning on graphs is through graph kernels \cite{prvzulj2007biological,kashima2003marginalized,orsini2015graph}. However, many of these methods do not provide explicit graph embeddings which many machine learning algorithms operate on. Furthermore, the handcrafted features of graph kernels lead to high dimensional, sparse or non-smooth representations and thus result in poor generalization performance, especially on large datasets \cite{narayanan2017graph2vec}.

Unsupervised learning of latent representations is also an important problem in other domains, such as image generation \cite{kingma2013auto,kim2018disentangling} and natural language processing \cite{mikolov2013efficient}. 
A recent work introduced Deep Infomax, a method that maximizes the mutual information content between the input data and the learned representation \cite{hjelm2018learning}. This method outperforms other methods on many unsupervised learning tasks.
Motivated by Deep InfoMax \cite{hjelm2018learning}, we aim to use mutual information maximization for unsupervised representation learning 
on the entire graph. Specifically, our objective is to maximize the mutual information between the representations of entire graphs and the representations of substructures of different granularity. We name our model \textbf{\method{}}.







We also propose a semi-supervised learning model which we name \textbf{\method{}*}. We employ a student-teacher framework similar to Mean-Teacher method \cite{tarvainen2017mean}. We maximize the mutual information between intermediate representations of the two models so that the student model learns from the teacher model. The student model is trained on the labeled data using a supervised objective function while the teacher model is trained on unlabeled data with \textbf{\method{}}. Using \textbf{\method{}*}, we achieve performance competitive with state-of-the-art methods on molecular property prediction.






We summarize our contributions as follows:
\begin{itemize}

 \item We propose \method{}, an unsupervised graph representation learning method based on Deep InfoMax (DIM)~\cite{hjelm2018learning}.
 
  \item We show that \method{} can be extended to semi-supervised prediction tasks on graphs.
  


\item We empirically show that \method{} surpasses state-of-the-art performance on graph classification tasks with unsupervised learning and obtains performance comparable with state-of-art methods on molecular property prediction tasks using semi-supervised learning.




\end{itemize} \section{Related work}

Representation learning for graphs has mainly dealt with supervised learning tasks. Recently, however, researchers have proposed algorithms that learn graph-level representations in an unsupervised manner \cite{narayanan2017graph2vec,sub2vec}.

Concurrently to this work, information maximizing graph neural networks (IGNN) was introduced which uses mutual information maximization between edge states and transform parameters to achieve state-of-the-art predictions on a variety of supervised molecule property prediction tasks \cite{chen2019utilizing}. In this work, our focus is on unsupervised and semi-supervised scenarios. 

\xhdr{Graph Kernels}
Constructing graph kernels is a common unsupervised task in learning graph representations. These kernels are typically evaluated on node classification tasks. In graph kernels, a graph $G$ is decomposed into (possibly different) $\{G_{s}\}$ sub-structures. The graph kernel $K(G_1,G_2)$  is defined based on the frequency of each sub-structure appearing in $G_1$ and $G_2$ respectively. Namely, $K(G_1,G_2)=\langle f_{G_{s_1}},f_{G_{s_2}}\rangle$, where $f_{G_{s}}$ is the vector containing  frequencies of  $\{G_{s}\}$ sub-structures, and $\langle,\rangle$ is an inner product in an appropriately normalized vector space. Much work has been devoted to deciding which sub-structures are more suitable than others (refer to appendix A.1). Instead of defining hand crafted similarity measures between substructures, \method{} adopts a more principled metric -- mutual information.

\xhdr{Contrastive methods}
An important approach for unsupervised  representation learning  is to train an encoder to be \emph{contrastive} between representations that capture statistical dependencies of interest and those that do not. For example, a contrastive approach may employ a \emph{scoring function}, training the encoder to increase the score on ``real'' input (a.k.a, positive examples) and decrease the score on ``fake'' input (a.k.a., negative samples). For more detailed discussion, refer to appendix A.2.

\textit{Deep Graph InfoMax} (DGI) \cite{velivckovic2018deep} also belongs to this category, which aims to train a \emph{node} encoder that maximizes mutual information between node representations and the pooled global graph representation. Although we built upon a similar methodology, our aim is different than theirs as our goal is to obtain embeddings at the whole graph level for unsupervised and semi-supervised learning whereas DGI only evaluates node level embeddings. In order to differentiate our method with Deep Graph Infomax (\cite{velivckovic2018deep}), we term our model \method{}.



\xhdr{Semi-supervised Learning} 
A comprehensive overview of semi-supervised learning (SSL) methods is out of the scope of this paper. We refer readers to Appendix B for a short overview or  \cite{zhu2003semi,chapelle2006semi,oliver2018realistic} for more comprehensive discussions. Here, we discuss a state-of-the-art method applicable for regression tasks -- Mean Teacher~\cite{tarvainen2017mean}.Mean Teacher adds a loss term which encourages the distance between the original network's output and the teacher's output to be small. The teacher's predictions are made using an exponential moving average of parameters from previous training steps. Inspired by the ``student-teacher'' framework in Mean Teacher model, our semi-supervised model (\method{}*) deploys two separate encoders but instead of explicitly encouraging the output of the student model to be similar to the teacher model's output, we enable the student model to learn from the teacher model by maximizing mutual information between intermediate representations learned by two models.
 
%
 

\section{Methodology}

Most recent work on graphs focus on supervised learning tasks or learning node representations. However, many graph analytic tasks such as graph classification, regression, and clustering require representing entire graphs as fixed-length feature vectors. Though graph-level representations can be obtained through the node-level representations implicitly, explicitly extracting the graph can be more straightforward and optimal for graph-oriented tasks. 

Another scenario that is important, yet attracts comparatively less attention in the graph related literature is semi-supervised learning. One of the biggest challenges in prediction tasks in biology~\cite{yan2017detecting,yang2014egonet} or molecular machine learning~\cite{duvenaud2015convolutional,gilmer2017neural,jia2017adversarial} is the extreme scarcity of labeled data. Therefore, semi-supervised learning, in which a large number of unlabeled samples are incorporated with a small number of labeled samples to enhance accuracy of models, will play a key role in these areas.



In this section, we first formulate an unsupervised whole graph representation learning problem and a semi-supervised prediction task on graphs. Then, we present our method to learn graph-level representations. Afterwards we present our proposed model for the semi-supervised learning scenario.  

\subsection{Problem Definition}

\xhdr{Unsupervised Graph Representation Learning} 
Given a set of graphs $\mathbb{G} = \{G_1, G_2,...\}$ and a positive integer $\delta$ (the expected embedding size), our goal is to learn a $\delta$-dimensional distributed representation of every graph $ G_i \in \mathbb{G} $. We denote the number of nodes in $G_i$ as $\left| G_i \right|$. We denote the matrix of representations of all graphs as $ \Phi \in \mathbb{R}^{|\mathbb{G}| \times \delta} $.

\xhdr{Semi-supervied Graph Prediction Tasks} Given a set of labeled graphs $\mathbb{G}^{L}=\{G_{1}, \cdots , G_{|\mathbb{G}^{L}|}\}$ with corresponding output $\{o_{1}, \cdots ,o_{|\mathbb{G}^{L}|}\}$, and a set of unlabeled samples $\mathbb{G}^{U}= \{ G_{|\mathbb{G}^{L}| + 1}, \cdots, G_{|\mathbb{G}^{L}| + |\mathbb{G}^{U}|} \}$, our goal is to learn a model that can make predictions for unseen graphs. Note that in most cases $|\mathbb{G}^{U}| \gg |\mathbb{G}^{L}|$.








 














\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{images/InfoGraph.png}
    \caption{Illustration of \method{}. N.A. denotes neighborhood aggregation. An input graph is encoded into a feature map by graph convolutions and jumping concatenation. The discriminator takes a (global representation, patch representation) pair as input and decides whether they are from the same graph. \method{} uses a batch-wise fashion to generate all possible positive and negative samples. For example, consider the toy example with 2 input graphs in the batch and 7 nodes (or patch representations) in total. For the global representation of the blue graph, there will be 7 input pairs to the discriminator and same for the red graph. Thus, the discriminator will take 14 (global representation, patch representation) pairs as input in this case.}
    \label{fig:gnn-infomax}
\end{figure}
\subsection{\method{}}


We focus on graph neural networks (GNNs)---a flexible class of embedding architectures which generate node representations by repeated aggregation over local node neighborhoods. The representations of nodes are learned by aggregating the features of their neighborhood nodes, so we refer to these as patch representations. GNNs utilize a READOUT function to summarize all the obtained patch representations into a fixed length graph-level representation.

Formally, the $k$-th layer of a GNN is 
\begin{align}
    h_v^{(k)}   = \text{COMBINE}^{(k)} \left( h_v^{(k-1)},\text{AGGREGATE}^{(k)} \left( \left\lbrace \left(h_v^{(k-1)}, h_u^{(k-1)}, e_{uv} \right)  : u \in \mathcal{N}(v) \right\rbrace \right) \right),
\end{align}
where $h_v^{(k)}$ is the feature vector of node $v$ at the $k$-th iteration/layer (or patch representation centered at node $i$), $e_{uv}$ is the feature vector of the edge between $u$ and $v$, and $\mathcal{N}(v)$ are neighborhoods to node $v$. $h_v^{(0)}$ is often initialized as node features. READOUT can be a simple permutation invariant function such as averaging or a more sophisticated graph-level pooling function~\cite{ying2018hierarchical,zhang2018end}.



We seek to obtain graph representations by maximizing the mutual information between graph-level and patch-level representations. By doing so, the graph representations can learn to encode aspects of the data that are shared across all substructures. Assume that we are given a set of training samples $\mathbf{G} := \{G_j \in \mathbb{G}\}_{j=1}^N$ with empirical probability distribution $\PP$ on the input space. 
Let $\phi$ denote the set of parameters of a $K$-layer graph neural network. After the first $k$ layers of the graph neural network, the input graph will be encoded into a set of patch representations $\{h_{i}^{(k)}\}^{N}_{i=1}$. Next, we summarize feature vectors \emph{at all depths} of the graph neural network into a single feature vector that captures patch information at different scales centered at every node. Inspired by \cite{xu2018representation}, we use concatenation. That is,
\begin{align}
h_{\phi}^{i} = \text{ CONCAT}(\{h_{i}^{(k)}\}_{k=1}^{K})\\
H_{\phi}(G) = \text{READOUT}(\{h_{\phi}^{i}\}^{N}_{i=1})
\end{align}
where $h_{\phi}^{i}$ is the summarized patch representation centered at node $i$ and $H_{\phi}(G)$ is the global representation after applying READOUT. Note that here we slightly abuse the notation of $h$.


We define our mutual information (MI) estimator on global/local pairs, maximizing the estimated MI over the given dataset $\mathbf{G} := \{G_j \in \mathbb{G}\}_{j=1}^N$:


\begin{align}
    \hat{\phi}, \hat{\psi}
    &= \argmax_{\phi, \psi} \sum_{G \in \mathbf{G}} \frac{1}{\left| G \right|} 
    \sum_{u \in G}
    I_{\phi,\psi}(\vec{h}_{\phi}^{u};H_{\phi}(G)).
    \label{eq:objective}
\end{align}

$I_{\phi,\psi}$ is the mutual information estimator modeled by discriminator $T_{\psi}$ and parameterized by a neural network with parameters $\psi$.
We use the Jensen-Shannon MI estimator
~(following the formulation of \cite{nowozin2016f}),
\begin{align}
 I_{\phi, \psi}(h_{\phi}^{i}(G); H_{\phi}(G)) &:=  \nonumber \\ 
 \EE_{\PP}&[-\text{sp}(-T_{\phi, \psi}(\vec{h}_{\phi}^{i}(x), H_{\phi}(x)))] 
    - \EE_{\PP \times \tilde{\PP}}[\text{sp}(T_{\phi, \psi}(\vec{h}_{\phi}^{i}(x'), H_{\phi}(x)))]
    \label{eq:objective1}
\end{align}
where $x$ is an input sample, $x'$ (negative sample) is an input sampled from $\tilde{\PP} = \PP$, a distribution identical to the empirical probability distribution of the input space, and $\text{sp}(z) = \log(1 + e^z)$ is the softplus function. In practice, we generate negative samples using all possible combinations of global and local patch representations across all graph instances in a batch.

Since $H_{\phi}(G)$ is encouraged to have high MI with patches that contain information at all scales, this favours encoding aspects of the data that are shared across patches and aspects that are shared across scales. The algorithm is illustrated in Fig.~\ref{fig:gnn-infomax}. 

It should be noted that our model is similar to Deep Graph Infomax (DGI) \cite{velivckovic2018deep}, a model proposed for learning unsupervised node embeddings. 
However, there are important design differences due to the different problems that we are focusing on. First, in DGI they use random sampling to obtain negative samples due to the fact that they are mainly focusing on learning node embeddings on a graph. However, contrastive methods require a large number of negative samples to be competitive \cite{hjelm2018learning}, thus the use of batch-wise generation of negative samples is crucial as we are trying to learn graph embeddings given many graph instances. Second, the choice of graph convolution encoders is also crucial. We use GIN \cite{xu2018powerful} while DGI uses GCN \cite{kipf2016semi} as GIN provides a better inductive bias for graph level applications. Graph neural network designs should be considered carefully so that graph representations can be discriminative towards other graph instances. For example, we use sum over mean for READOUT and that can provide important information regarding the size of the graph.
\begin{figure}[t]
    \centering
    \includegraphics[width=1.0\linewidth]{images/InfoGraph_semi.png}
    \caption{Illustration of the semi-supervised version of \method{} (\method{}*). There are two separate encoders with the same architecture, one for the supervised task and the other trained using both labeled and unlabeled data with an unsupervised objective (eq.~\eqref{eq:objective}). We encourage the mutual information of the two representations learned by the two encoders to be high by deploying a discriminator that takes a pair of representation as input and determines whether they are from the same input graph.}
    \label{fig:semi-gnn-infomax}
\end{figure}
\subsection{Semi-supervised \method{}}



Based on the previous unsupervised model, a straightforward way to do semi-supervised property prediction on graphs is to combine the purely supervised loss and the unsupervised objective function which acts as a regularization term. In doing so, the model is trained to predict properties for the labeled dataset while keeping a rich discriminative intermediate representation learned from both the labeled and the unlabeled dataset. That is, we try to minimize the following objective function:

\begin{align}
L_{\text{total}} = 
\sum_{i=1}^{|\mathbb{G}^{L}|}  L_{\text{supervised}}(y_{\phi}(G_i), o_i) + \lambda \sum_{j=1}^{|\mathbb{G}^{L}| + |\mathbb{G}^{U}|} L_{\text{unsupervised}}(h_{\phi}(G_j); H_{\phi}(G_j))   
\label{eq:combine-objective}
\end{align}

where ${L_{\text{supervised}}}(y_{\phi}(G_i), o_i)$ is defined as the loss function of graph $G_i$ that measures the discrepancy between the classifier output $y_{\phi}(G_i)$ and the true output $o_{i}$. $L_{\text{unsupervised}}(h_{\phi}(G_j); H_{\phi}(G_j)$ is the unsupervised \method{} loss term as defined in eq.~\eqref{eq:objective} that can be optimized using both labeled and unlabeled data. The hyper-parameter $\lambda$ controls the relative weight between the purely supervised and the unsupervised loss. The intuition behind this is that the model will benefit from learning a good representation from the large amount of unlabeled data while learning to predict the corresponding supervised label.



However, supervised tasks and unsupervised tasks may favor different information or a different semantic space. Simply combining the two loss functions using the same encoder may lead to ``negative transfer''~\footnote{We slightly abuse this term in this paper as it usually refers to transferring knowledge from a less related source and thus may hurt the target performance.} \citep{pan2009survey,rosenstein2005transfer}. We propose a simple way to alleviate this problem: we deploy two encoder models: the encoder on the labelled data (supervised encoder) and the encoder on the unlabelled data (unsupervised encoder). For transferring the learned representations from the unsupervised encoder to the supervised encoder, we define a  loss term that encourages the representations learned by the two encoders to have high mutual information, \textit{at all levels of representations} (third term of Eq. \ref{eq:semi}).  Formally, let $\varphi$ denote the set of parameters of another $K$-layered graph neural network, identical to the one parameterized by $\phi$, and let $\lambda$ be a tunable hyper-parameter, $H_{\phi}^{k}(G)$, $H_{\varphi}^{k}(G)$ be global encoder representations of the graph $G$ at encoder layer $k$,  then total loss function can be defined as follows:

\begin{align}
L_{\text{total}} = 
\sum_{i=1}^{|\mathbb{G}^{L}|}  {L_{\text{supervised}}}(y_{\phi}(G_i), o_i) & + \sum_{j=1}^{|\mathbb{G}^{L}| + |\mathbb{G}^{U}|} {L_{\text{unsupervised}}}(h_{\varphi}(G_j); H_{\varphi}(G_j)) \\
    &- \lambda \sum_{j=1}^{|\mathbb{G}^{L}| + |\mathbb{G}^{U}|} \frac{1}{\left| G_j \right|}\sum_{k=1}^{K}  I(H_{\phi}^{k}(G_j);H_{\varphi}^{k}(G_j).
    \label{eq:semi}
\end{align}



Notice that this formulation can be seen as a special instance of the \textit{student-teacher} framework. However, unlike the recent \textit{student-teacher} methods for semi-supervised learning \citep{laine2016temporal,tarvainen2017mean, ict}, which enforce the predictions of the student model to be similar to the teacher model, we enforce the transfer of knowledge from the teacher model to the student model via mutual-information maximization at various levels of representations. In practice, to reduce the computation overhead introduced by the third term of Eq \ref{eq:semi}, instead of enforcing the mutual-information maximization over all the layers of the encoders, at each training update, we enforce mutual-information maximization on a randomly chosen layer of the encoder \citep{manifold_mixup}.

In our semi-supervised experiments, we refer to the naive method using the objective function given in eq.~\eqref{eq:combine-objective} as \method{}. We refer to the method that uses two separate encoders and employ the objective function given in eq.~\eqref{eq:semi} as \method{}*. \method{}* is fully summarized in Figure \ref{fig:semi-gnn-infomax}.























 

\section{Experiments}
We evaluate the effectiveness of the graph-level representation learned by \method{} on downstream graph classification tasks and on semi-supervised molecular property prediction tasks.

\subsection{Datasets}
For graph classification, we conduct experiments on 6 well-known benchmark datasets: MUTAG, PTC, REDDIT-BINARY, REDDIT-MULTI-5K, IMDB-BINARY, and IMDB-MULTI (\cite{yanardag2015deep}).
For semi-supervised learning tasks, we use the publicly available QM9 dataset \cite{ramakrishnan2014quantum}. 
Additional details of the datasets can be found in Appendix B.



\subsection{Baselines}

For graph classification, we used 6 state-of-the-art graph kernels for comparison: Random Walk (RW) \cite{gartner2003graph}, Shortest Path Kernel (SP) \cite{borgwardt2005shortest}, Graphlet Kernel (GK) \cite{shervashidze2009efficient}, Weisfeiler-Lehman Sub-tree Kernel (WL) \cite{shervashidze2011weisfeiler}, Deep Graph Kernels (DGK) \cite{yanardag2015deep}, and Multi-Scale Laplacian Kernel (MLG) \cite{kondor2016multiscale}. Aside from graph kernels, we also compare with 3 unsupervised graph-level representation learning methods: node2vec \cite{node2vec}, sub2vec \cite{sub2vec}, and graph2vec \cite{narayanan2017graph2vec}. Node2vec is a neural embedding framework that learns feature representations of individual nodes in graphs and we aggregate node embeddings to obtain graph embeddings.

For semi-supervised tasks, aside from comparing the results with the fully supervised results, we also compare our results with a state-of-the-art semi-supervised method: Mean Teachers~\cite{tarvainen2017mean}.

\subsection{Experiment Configuration}
For graph classification tasks, we adopt the same procedure of previous works \cite{niepert2016learning,verma2017hunt,yanardag2015deep,zhang2018end} to make a fair comparison and used 10-fold cross validation accuracy to report the classification performance. Experiments are repeated 5 times. We report results from previous papers with the same experimental setup if available. If results are not previously reported, we implement them and conduct a hyper-parameter search according to the original paper. For node2vec~\cite{node2vec}, we took the result from \cite{narayanan2017graph2vec} but we did not run it on all datasets as the implementation details are not clear in the paper. For Deep Graph Kernels, we report the best result out of Deep WL Kernels, Deep GK Kernels, and Deep RW Kernels. For sub2vec, we report the best result out of its two variants: \textit{sub2vec-N} and \textit{sub2vec-S}. For all methods, the embedding dimension is set to 512 and parameters of downstream classifiers are independently tuned using cross validation on training folds of data. The best average classification accuracy is reported for each method. The classification accuracies are computed using \textsc{LIBSVM} \cite{chang2011libsvm}, and the $C$ parameter was selected from $\{10^{-3}, 10^{-2}, \dotsc, 10^{2},$ $10^{3}\}$.



The QM9 dataset has 130462 molecules in it. We adopt similar experimental settings as traditional semi-supervised methods \cite{tarvainen2017mean,laine2016temporal,miyato2018virtual}. We randomly chose 5000 samples as labeled samples for training and another 10000 as validation samples, 10000 samples for testing, and use the rest as unlabeled training samples. Note that we use the exact same split when running the supervised model and the semi-supervised model. We use the validation set to do model selection and we report scores on the test set. All targets were normalized to have mean 0 and variance 1. We minimize the mean squared error between the model output and the target, although we evaluate mean absolute error.

\subsection{Model Configuration}
For the unsupervised experiments, we use the Graph Isomorphism Network (GIN) \cite{xu2018powerful}. For the semi-supervised experiments, we adopt the same model as in \cite{gilmer2017neural} (enn-s2s). As recommended in \cite{oliver2018realistic}, we use the exact same underlying model architecture when comparing semi-supervised learning approaches as our goal is not to produce state-of-the-art results, but instead to provide a rigorous comparative analysis in a common framework. In both scenarios, models were trained using SGD with the Adam optimizer. We use Pytorch \cite{paszke2017automatic} and the Pytorch Geometric \cite{fey2019fast} libraries for all our experiments. For detailed hyper-parameter settings and architecture detail of the discriminator, see Appendix C.





\renewcommand{\arraystretch}{1.1}
\begin{table*}[t!]
	\centering
	\fontsize{7}{8}\selectfont
	
	
	\begin{tabular}{ @{} >{\raggedright}p{2cm} |  K{1.6cm}  !{\vrule width0.8pt} K{1.6cm}  !{\vrule width0.8pt} K{1.6cm} !{\vrule width0.8pt} K{1.6cm}   !{\vrule width0.8pt} K{1.6cm}   !{\vrule width0.8pt}K{1.6cm}   !{\vrule width0.8pt} K{1.6cm} | }
		
		\multirow{1}{*}{\textbf{Dataset}} &      \multicolumn{1}{c!{\vrule width0.8pt}}{MUTAG} &	\multicolumn{1}{c!{\vrule width0.8pt}}{PTC-MR}  &  \multicolumn{1}{c!{\vrule width0.8pt}}{RDT-B} &  \multicolumn{1}{c!{\vrule width0.8pt}}{RDT-M5K} &	 \multicolumn{1}{c!{\vrule width0.8pt}}{IMDB-B} &	 \multicolumn{1}{c!{\vrule width0.8pt}}{IMDB-M} \\


		{\textbf{(No. Graphs)}} &     {$188$} &	 {$344$}  &  {$2000$} & 	 {$4999$} &	 {$1000$} &	 {$1500$} \\  
		
		\multirow{1}{*}{\textbf{(No. classes)}} &    {$2$} &	 {$2$}  &  {$2$} & 	 {$5$} &	 {$2$} &	 {$3$} \\  
		
		\multirow{1}{*}{\textbf{(Avg. Graph Size)}}    &  {$17.93$} &
		{$14.29$}  &  {$429.63$} & 	 {$508.52$} &	 {$19.77$} &	 {$13.00$} \\  \Xhline{2\arrayrulewidth}


		\end{tabular}	
	
		
	\begin{center}
		Graph Kernels
	\end{center}
	
	\begin{tabular}{ @{} >{\raggedright}p{2cm} |    K{1.6cm}  !{\vrule width0.8pt}  K{1.6cm}  !{\vrule width0.8pt} K{1.6cm} !{\vrule width0.8pt} K{1.6cm}   !{\vrule width0.8pt} K{1.6cm}   !{\vrule width0.8pt}K{1.6cm}   !{\vrule width0.8pt} K{1.6cm} | }	 
		\hline
RW  & $83.72 \pm 1.50$ & $57.85 \pm 1.30$ & OMR & OMR & $50.68 \pm 0.26$ & $34.65 \pm 0.19$  \\  \hline
		SP   &$85.22 \pm 2.43$ & $58.24 \pm 2.44$ & $64.11 \pm 0.14$ & $39.55 \pm 0.22$ & $55.60 \pm 0.22$ & $37.99 \pm 0.30$ \\  \hline
		GK     &$81.66 \pm 2.11$ & $57.26 \pm 1.41$ & $77.34 \pm 0.18$ & $41.01 \pm 0.17$ & $65.87 \pm 0.98$ & $43.89 \pm 0.38$ \\  \hline
		WL  &$80.72 \pm 3.00$ & $57.97 \pm 0.49$ & $68.82 \pm 0.41$ & $46.06 \pm 0.21$ & $72.30 \pm 3.44$ & $46.95 \pm 0.46$ \\  \hline
		DGK   &$87.44 \pm 2.72$ & $60.08 \pm 2.55$ & $78.04 \pm 0.39$ & $41.27 \pm 0.18$ & $66.96 \pm 0.56$ & $44.55 \pm 0.52$ \\  \hline
		MLG       & $87.94 \pm 1.61$ & $\mathbf{63.26 \pm 1.48}$ & > 1 Day & > 1 Day & $66.55 \pm 0.25$ & $41.17 \pm 0.03$ \\  \hline
	\end{tabular}
	
    \begin{center}
		Other Unsupervised Methods
	\end{center}
	
	\begin{tabular}{ @{} >{\raggedright}p{2cm} |    K{1.6cm}  !{\vrule width0.8pt} K{1.6cm}  !{\vrule width0.8pt} K{1.6cm} !{\vrule width0.8pt} K{1.6cm}   !{\vrule width0.8pt} K{1.6cm}   !{\vrule width0.8pt}K{1.6cm}   !{\vrule width0.8pt} K{1.6cm} | }	 
		\hline
		node2vec       &  $72.63 \pm 10.20$ & $58.58 \pm 8.00$ & - & - & - & - \\  \hline sub2vec     &$61.05 \pm 15.80$ & $59.99 \pm 6.38$ & $71.48 \pm 0.41$ & $36.68 \pm 0.42$ & $55.26 \pm 1.54$ & $36.67 \pm 0.83$ \\  \hline
		graph2vec  &$83.15 \pm 9.25$ & $60.17 \pm 6.86$ & $75.78 \pm 1.03$ & $47.86 \pm 0.26$ & $71.1 \pm 0.54$ & $\mathbf{50.44 \pm 0.87}$ \\  \hline
		\textbf{\method{}}     &$\mathbf{89.01 \pm 1.13}$ & $61.65 \pm 1.43$ & $\mathbf{82.50 \pm 1.42}$ & $\mathbf{53.46 \pm 1.03}$ & $\mathbf{73.03 \pm 0.87}$ & $49.69 \pm 0.53$
 \\  \hline


\end{tabular}
	

	\caption{Classification accuracy on 6 datasets. The result in \textbf{bold} indicates the  best reported classification accuracy. The top half of the table compares results  with various graph kernel approaches while bottom half compares results with other state-of-the-art unsupervised graph representation learning methods. `$>1$ day' represents that the computation exceeds $24$ hours. `OMR' is out of memory error.} \label{table:results}
	
\end{table*}
 
\renewcommand{\arraystretch}{1.2}
\begin{table}[]
\centering
\scalebox{.65}{
\begin{tabular}{ccccccccccccc}
\hline
\multicolumn{1}{|c|}{Target}          & \multicolumn{1}{c|}{Mu (0)}        & \multicolumn{1}{c|}{Alpha (1)}     & \multicolumn{1}{c|}{HOMO (2)}      & \multicolumn{1}{c|}{LUMO (3)}      & \multicolumn{1}{c|}{Gap (4)}       & \multicolumn{1}{c|}{R2 (5)}        & \multicolumn{1}{c|}{ZPVE(6)}       & \multicolumn{1}{c|}{U0 (7)}        & \multicolumn{1}{c|}{U (8)}         & \multicolumn{1}{c|}{H (9)}         & \multicolumn{1}{c|}{G(10)}         & \multicolumn{1}{c|}{Cv (11)}       \\ \hline
\multicolumn{1}{|c|}{MAE}  & \multicolumn{1}{c|}{0.3201}        & \multicolumn{1}{c|}{0.5792}        & \multicolumn{1}{c|}{0.0060}        & \multicolumn{1}{c|}{0.0062}        & \multicolumn{1}{c|}{0.0091}        & \multicolumn{1}{c|}{10.0469}       & \multicolumn{1}{c|}{0.0007}        & \multicolumn{1}{c|}{0.3204}        & \multicolumn{1}{c|}{0.2934}        & \multicolumn{1}{c|}{0.2722}        & \multicolumn{1}{c|}{0.2948}        & \multicolumn{1}{c|}{0.2368}        \\ \hline
                                      &                                    &                                    &                                    &                                    &                                    &                                    &                                    &                                    &                                    &                                    &                                    &                                    \\ \hline
\multicolumn{1}{|c|}{Semi-Supervised} & \multicolumn{12}{c|}{Error Ratio}                                                                                                                                                                                                                                                                                                                                                                                                                         \\ \hline
\multicolumn{1}{|c|}{Mean-Teachers}   & \multicolumn{1}{c|}{1.09}          & \multicolumn{1}{c|}{1.00}          & \multicolumn{1}{c|}{\textbf{0.99}} & \multicolumn{1}{c|}{1.00}          & \multicolumn{1}{c|}{\textbf{0.97}} & \multicolumn{1}{c|}{0.52} & \multicolumn{1}{c|}{0.77} & \multicolumn{1}{c|}{1.16}          & \multicolumn{1}{c|}{0.93}          & \multicolumn{1}{c|}{0.79} & \multicolumn{1}{c|}{0.86}          & \multicolumn{1}{c|}{0.86} \\ \hline
\multicolumn{1}{|c|}{\method{}}     & \multicolumn{1}{c|}{1.02}          & \multicolumn{1}{c|}{0.97}          & \multicolumn{1}{c|}{1.02}          & \multicolumn{1}{c|}{\textbf{0.99}} & \multicolumn{1}{c|}{1.01}          & \multicolumn{1}{c|}{0.71}          & \multicolumn{1}{c|}{0.96}          & \multicolumn{1}{c|}{0.85}          & \multicolumn{1}{c|}{0.93}          & \multicolumn{1}{c|}{0.93}          & \multicolumn{1}{c|}{0.99}          & \multicolumn{1}{c|}{1.00}          \\ \hline
\multicolumn{1}{|c|}{\method{}*}    & \multicolumn{1}{c|}{\textbf{0.99}} & \multicolumn{1}{c|}{\textbf{0.94}} & \multicolumn{1}{c|}{\textbf{0.99}} & \multicolumn{1}{c|}{\textbf{0.99}} & \multicolumn{1}{c|}{0.98}          & \multicolumn{1}{c|}{\textbf{0.49}}          & \multicolumn{1}{c|}{\textbf{0.52}}          & \multicolumn{1}{c|}{\textbf{0.44}} & \multicolumn{1}{c|}{\textbf{0.58}} & \multicolumn{1}{c|}{\textbf{0.57}}          & \multicolumn{1}{c|}{\textbf{0.54}} & \multicolumn{1}{c|}{\textbf{0.83}}          \\ \hline

\end{tabular}
}
\vspace{2mm}
	\caption{Results of semi-supervised experiments on QM9 dataset. The result in \textbf{bold} indicates the  best performance. The top half of the table shows the mean absolute error (MAE) of the supervised model. The bottom half shows the error ratio (with respect to supervised result) of the semi-supervised models using the same underlying model. Lower scores are better and values less than 1.0 indicate better performance than the supervised baseline.}
    \label{table:semi-results}
	
\end{table}
%
 
 
\section{Results}
The results of evaluating unsupervised graph level representations using downstream graph classification tasks are presented in Table \ref{table:results}. 
We show results from six methods including three state-of-the-art graph kernel methods: WL \cite{shervashidze2011weisfeiler}, DGK \cite{yanardag2015deep}, and MLG \cite{kondor2016multiscale}.
While these kernel methods perform well on individual datasets, none of them are competitive across all of the datasets. Additionally, MLG suffers from a long run time and take more than 24 hours to run on the two larger benchmark datasets. 
We find that \method{} outperforms all of these baselines on 4 out of 6 of the datasets. In the other 2 datasets, \method{} still has very competitive performance. 



The results of the semi-supervised learning experiments on the molecular property prediction task are presented in Table \ref{table:semi-results}. We observe that by simply combining the supervised objective with the unsupervised infomax objective (\method{}) obtains better performance compared to the purely supervised models on 7 out of 12 of the targets. However, in 1 out of 12 targets it does not obtain better performance and in 4 out of 12 targets, it results in poorer performance. This ``negative transfer'' effect may be caused by the fact that the supervised objective and the unsupervised objective favor different information or different latent semantic space. 
This effect is alleviated with \method{}*, our modified version of \method{} for semi-supervised learning.
\method{}* improves over the supervised model in all the 12 targets. \method{}* obtains the best result on 11 targets while the Mean Teacher method obtains the best results on 2 targets (with one overlap). However, the Mean Teacher model yields worse performance on 2 targets when compared to the supervised result. 


\section{Conclusion and Future work}
In this paper, we propose \method{} to learn unsupervised graph-level representations and \method{}* for semi-supervised learning. We conduct experiments on graph classification and molecular property prediction tasks to evaluate these two methods. Experimental results show that \method{} and \method{}* are both very competitive with state-of-the-art methods. There are many research works on semi-supervised learning on image data, but few of them focus on semi-supervised learning for graph structured data. In the future, we aim to explore semi-supervised frameworks designed specifically for graphs.



\bibliography{iclr2020_conference}
\bibliographystyle{iclr2020_conference}

\newpage
\appendix
\section{Related Work}

\subsection{Graph Kernels}
Popular graph kernels are  graphlets~\cite{prvzulj2007biological,shervashidze2009efficient}, random walk and shortest path kernels~\cite{kashima2003marginalized,borgwardt2005shortest}, and the Weisfeiler-Lehman subtree kernel~\cite{shervashidze2011weisfeiler}. Furthermore, deep graph kernels~\cite{yanardag2015deep}, graph invariant  kernels~\cite{orsini2015graph}, optimal assignment graph kernels~\cite{kriege2016valid}  and  multiscale Laplacian graph kernels~\cite{kondor2016multiscale} have been proposed with the goal to redefine kernel functions to appropriately capture sub-structural similarity at different levels. Another line of research in this area focuses on efficiently computing these kernels either through exploiting certain structural dependencies, or via approximations/randomization~\cite{feragen2013scalable,de2013fast,neumann2012efficient}.

\subsection{Contrastive Methods}
Contrastive methods are central many popular word-embedding methods~\cite{collobert2008unified, mnih2013learning, mikolov2013distributed}. Word2vec \cite{mikolov2013efficient} is an unsupervised algorithm which obtains word representations by using the representations to predict context words (the words that surround it). Doc2vec~\cite{le2014distributed} is an extension of the continuous Skip-gram model that predicts representations of words from that of a document containing them. Researchers extended many of these unsupervised language models to learn representations of graph-structured input \cite{sub2vec,narayanan2017graph2vec}. For example,  \textit{graph2vec} \cite{narayanan2017graph2vec} extends Doc2vec to arbitrary graphs. Intuitively, for graph2vec a graph and the rooted subgraphs in it correspond to a document and words in a paragraph vector, respectively. One of the technical contributions of the paper is using the Weisfeiler-Lehman relabelling algorithm \cite{weisfeiler1968reduction,shervashidze2011weisfeiler} to enumerate all rooted subgraphs up to a specified depth. AWE (Anonymous Walk Embeddings) \cite{ivanov2018anonymous} is another method based on CBOW framework.  instead of using rooted subgraphs as words like graph2vec, AWE considers anonymous walk embeddings for the same source node as co-occurring words. InfoGraph has the two advantages when compared with these methods.
First, InfoGraph learns representations directly from data instead of utilizing hand-crafted procedures (i.e. Weisfeiler-Lehman relabelling algorithm in graph2vec and random walkw in AWE). Second, InfoGraph has a clear objective that can be easily combined with other objectives. For example, InfoGraph*, the semi-supervised method that we proposed.

\section{Semi-Supervised Learning}
Here we discuss the most common class of SSL methods which involve adding an additional loss term to the training of a neural network as they are pragmatic and are currently the state-of-the-art on image classification datasets.

\textbf{Entropy Minimization (EntMin):}
EntMin \cite{grandvalet2005semi} adds a loss term applied that encourages the network to make ``confident'' (low-entropy) predictions for all unlabeled examples, regardless of their class.

\textbf{Pseudo-Labeling:}
Pseudo-labeling \cite{lee2013pseudo} proceeds by producing ``pseudo-labels'' for unlabeled input data points using the prediction function itself over the course of training. Pseudo-labels which have a corresponding class probability that is larger than a predefined threshold are used as targets for a the standard supervised loss function.

\textbf{$\Pi$-Model:}
Neural networks can produce different outputs for the same input while common regularization techniques such as data augmentation, dropout, and adding noise are applied. $\Pi$-Model \cite{laine2016temporal,sajjadi2016mutual} adds a loss term which encourages the distance between a network's output for different passes of unlabeled data through the network to be small.

\textbf{Virtual Adversarial Training:} Instead of relying on the built-in stochasticity as in $\Pi$-Model, Virtual Adversarial Training (VAT) \cite{miyato2018virtual} directly approximates a tiny perturbation to add to the input which would most significantly affect the output of the prediction function. This pertubation can be approximated with an extra back-propagation for each optimization step.

\textbf{Mean Teacher:}
A difficulty with the $\Pi$-model approach is that it relies on a potentially unstable ``target'' prediction, namely the second stochastic network prediction which can rapidly change over the course of training. As a result, \cite{tarvainen2017mean} proposed to obtain a more stable target output for unlabeled data by setting the target to predictions made using an exponential moving average of parameters from previous training steps.

\section{Datasets}

\subsection{Graph Classification Datasets}
MUTAG contains 188 mutagenic aromatic and heteroaromatic nitro compounds with 7 different discrete labels. 
PTC is a dataset of 344 different chemical compounds that have been tested for carcinogenicity in male and female rats. This dataset has 19 discrete labels. IMDB-BINARY and IMDB-MULTI are movie collaboration datasets. Each graph corresponds to an ego-network for each actor/actress, where nodes correspond to actors/actresses and an edge is drawn between two actors/actresses if they appear in the same movie. Each graph is derived from a pre-specified genre of movies, and the task is to classify the genre graph it is derived from. REDDIT-BINARY and REDDIT-MULTI5K are balanced datasets where each graph corresponds to an online discussion thread and nodes correspond to users. An edge was drawn between two nodes if at least one of them responded to anothers comment. The task is to classify each graph to the community or subreddit that it belongs to.

\subsection{QM9}
All molecules in the dataset consist of Hydrogen (H), Carbon (C), Oxygen (O), Nitrogen (N), and Flourine (F) atoms and contain up to 9 non-Hydrogen atoms. In all, this results in about 134,000 drug-like organic molecules that span a wide range of chemical compositions and properties. A total of 12 interesting and fundamental chemical properties are pre-computed for each molecule. For a detailed description of the properties in the QM9 dataset, see section 10.2 of \cite{gilmer2017neural}.


\section{Model Configuration}
For the unsupervised experiments, we use the Graph Isomorphism Network (GIN) \cite{xu2018powerful}. GNN layers are chosen from $\{4, 8, 12\}$. Initial learning rate is chosen from the set $\{10^{-2}, 10^{-3}, 10^{-4}\}$. The number of epochs are chosen from $\{10, 20, 100\}$. The batch size is set to 128.

For the semi-supervised experiments, the number of set2set computations is set to 3. Model were trained with an initial learning rate 0.001 for 500 epochs with a batch size 20. For the supervised case, the weight decay is chosen from $\{0, 10^{-3}, 10^{-4}\}$. For \method{} and \method{}*, $\lambda$ is chosen from $\{10^{-3}, 10^{-4}, 10^{-5}\}$.

The discriminator scores global-patch representation pairs by passing two representations to different non-linear transformations and then takes the dot product of the two transformed representations. Both non-linear transformations are parameterized by 3-layered feed-forward neural networks with jumping connections. Following each linear layer is a ReLU activation function. 

\newpage
\section{Convergence Plot}
To prove that the objective Eq.\ref{eq:semi} with multiple loss terms can be optimized, we provide a convergence plot of InfoGraph*. We can see that the three loss terms all converge after around 150 epochs of training.
\begin{figure}[h]
    \centering
    \includegraphics[width=.8\linewidth]{images/convergence.png}
    \caption{Convergence plot of InfoGraph* on QM9 target 7.}
    \label{fig:semi-gnn-infomax}
\end{figure} 

\end{document}
