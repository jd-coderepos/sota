\documentclass{LMCS}

\usepackage{color}
\usepackage{pstricks}
\usepackage{pst-node}
\usepackage{pst-tree}


\usepackage{amsmath}
\usepackage[amsfonts]{logic-thm}
\usepackage{enumerate,hyperref}

\theoremstyle{plain}\newtheorem{remark}{Remark}
\theoremstyle{plain}\newtheorem{lemma}[thm]{Lemma}
\renewcommand{\Aa}{\mathcal{A}}
\renewcommand{\Bb}{\mathcal{B}}
\renewcommand{\Pp}{\mathcal{P}}
\renewcommand{\Cc}{\mathcal{C}}

\newcommand{\dar}{\!\downarrow}
\newcommand{\vecs}{\vec s}
\newcommand{\vecsp}{\vec{s'}}
\newcommand{\vecspp}{\vec{s''}}
\newcommand{\vect}{\vec t}
\newcommand{\vecu}{\vec u}
\newcommand{\vecv}{\vec v}
\newcommand{\vecw}{\vec w}
\newcommand{\vAa}{\Aa_1\otimes\dots\otimes\Aa_n}
\newcommand{\vAaa}{\Aa'_1\otimes\dots\otimes\Aa'_n}
\newcommand{\vAap}{\Aa'_1\otimes\Aa''_1\dots\otimes\Aa'_n\otimes\Aa''_n}

\newcommand{\trans}[1]{\stackrel{#1}{\longrightarrow}}
\newcommand{\choice}{\zeta}
\newcommand{\cchoice}{\mathit{choice}}






\def\doi{4 (2:5) 2008}
\lmcsheading {\doi}
{1--14}
{}
{}
{Sep.~21, 2007}
{May~15, 2008}
{}   
\begin{document}

\title{A lower bound on web services composition}
\author[A.~Muscholl]{Anca Muscholl\rsuper a}
\address{{\lsuper a}LaBRI, Universit{\'e} Bordeaux\\
351, Cours de la Lib\'eration\\
F-33 405, Talence cedex, France}
\email{anca@labri.fr}

\author[I.~Walukiewicz]{Igor Walukiewicz\rsuper b}
\address{{\lsuper b}CNRS LaBRI, 351, Cours de la Lib\'eration,
F-33 405, Talence cedex, France}
\email{igw@labri.fr}

\thanks{{\lsuper{a,b}}Work supported by the projects
    ANR DOCFLOW (ANR-06-MDCA-005) and ANR DOTS (ANR-06-SETI-003).}

\keywords{Automata simulation, complexity, web services
composition.}

\subjclass{F.1.2, F.3.1}




\begin{abstract}
 	

A web service is modeled here as a finite state machine.  A composition
problem for web services is to decide if a given web service can be
constructed from a given set of web services; where the construction
is understood as a simulation of the specification by a fully asynchronous 
product of the given services. We show an EXPTIME-lower bound for this problem, 
thus matching the known upper bound.  Our result
also applies to richer models of web services, such as the Roman 
model.

\end{abstract}

\maketitle

\section{Introduction}

Inherently distributed applications such as web services~\cite{ACKM04}
increasingly get into the focus of automated verification
techniques. Often, some basic e-services are already implemented, but
no such simple service can answer to a more complex query. For
instance, a user interested in hiking Mt.~Everest will ask a travel
agency for information concerning weather forecast, group travels,
guides etc. The travel agency will contact different e-services,
asking for such information and making appropriate reservations, if
places are available. In general, single services such as weather
forecast or group reservations, are already available and it is
important to be able to reuse them without any change. The task of the
travel agency is to compose basic e-services in such a way that the
user's requirements are met (and eventually some constraints wrt.~the
called services, such as avoiding unreliable ones). Thus, one main
objective is to be able to check automatically that the composition of
basic e-services satisfies certain desirable properties or realizes
another complex e-service.

In this paper we study a problem that arises in the \emph{composition}
of e-services as considered in \cite{BCGLM03,BCGHM05,vldb05}. The
setting is the following: we get as input a specification (goal)
, together with  available services . Then
we ask whether the composition of the services  can simulate
the behavior of the goal . This problem is known as
\emph{composition synthesis}. It amounts to synthesize a so-called
\emph{delegator}, that tells at any moment which service must perform
an action. In essence, a delegator implements a simulation relation of
the goal service  by the composition of the available services
.  In the most general setting, as considered for instance in
\cite{hbcs03,fbs04,dsv06}, services are modeled by communicating state
machines \cite{bz83}, that have access to some local data. In this
paper, we reconsider the simplified setting of the so-called Roman
model~\cite{BCGLM03} where services are finite state processes with no
access to data and no mutual synchronization. This restriction is
severe, however sufficient for our purposes, since our primary
motivation is to obtain a complexity lower bound for the composition
synthesis problem.


In this paper we study the complexity of the composition synthesis
problem in the very simple setting where the composition of the finite
state machines  is fully asynchronous (in particular there is
no communication). This case is interesting for two reasons. It is
known to be decidable in \EXPTIME~\cite{BCGLM03}, contrary to some
richer frameworks where it is undecidable~\cite{BCGHM05}. It is also
probably the simplest setting where the problem can be formulated,
thus the complexity of this variant gives a lower bound on the
complexity of any other variants of the synthesis problem.  A related
problem arises when instead of simulation one considers bisimulation.
This is sometimes called \emph{orchestration problem}, where the issue
is to find a communication architecture of the available services,
that is equivalent to the goal, modulo bisimulation. In our setting,
this problem amounts to checking if the asynchronous composition of
finite state machines is bisimilar to a given machine.


The main result of this paper is the \EXPTIME\ lower bound for the
composition synthesis problem. We also show that the same question can
be solved in polynomial time if we assume that the sets of actions of
the available machines are pairwise disjoint, i.e., each request can
be handled by precisely one service. Note that in the latter case, the
set of actions depends on the number of processes, whereas for the
first result we show that the case where the set of actions is fixed
is already \EXPTIME-hard. We also show that the orchestration
(bisimulation) problem
is \NLOGSPACE\ complete, independently of whether the sets of actions
of the components are disjoint or not\footnote{This problem is easier
  than checking bisimulation between a BPP and a finite state
  automaton, which is P-complete. The reason is that the finite-state
automaton is deterministic in our setting.}. This result, however, is less
interesting the context of service composition. The bisimulation
requirement means that that the client (goal automaton) should be
prepared to admit all possible interleavings in the composition, which
usually makes the specification too complex.

Similar kinds of questions were also considered by the verification
community. There is a large body of literature on the complexity of
bisimulation and simulation problems for different kinds of process
calculi (for a survey see \cite{Srba}). A result that is most closely
related to ours is the 
\EXPTIME\ completeness of simulation and bisimulation between non-flat
systems~\cite{LarSch00}. The main difference to our setting is that
there both a system and services are given as composition of finite state
machines using (binary) \emph{synchronization} on actions, i.e., an
action can synchronize two services. In a sense this paper shows that
the lower bound for the simulation holds even without any
synchronization.  

This paper is an extended version of the conference
publication~\cite{mw07}. In particular, the
characterization of the complexity of the bisimulation problem is new.


\section{Notations}
We denote throughout this paper tuples of states (i.e., global states
of a product automaton)  by bold characters
. Unless otherwise stated, the
components of  vector  are .

An \emph{asynchronous} product of  deterministic automata 

 is a nondeterministic automaton:

where: ; ; 
; and  is defined by:
\begin{quote}
   iff for some ,  and for all 
   
  we have .
\end{quote}

Observe that the product automaton can be non deterministic because the alphabets  are not necessarily disjoint.

We define a \emph{simulation relation} on nondeterministic automata in
a standard way. Take two nondeterministic automata
 and
 over the same
alphabet. The simulation relation  is the
biggest relation such that if  then for every 
and every  there is  such that
. We write  if .

\paragraph{Problem:} Given  deterministic automata
 and a deterministic automaton  decide if
.

We will show that this problem is \EXPTIME-complete. It is clearly in
\EXPTIME\ as one can construct the product 
explicitly and calculate the biggest simulation relation with
. The rest of this paper will contain the proof of
\EXPTIME-hardness. We will start with the \PSPACE-hardness, as this will
allow us to introduce the method and some notation.

\section{A \PSPACE\  lower bound}

We will show \PSPACE-hardness of the problem by reducing it
to the  existence of a looping computation of a linearly space bounded
deterministic Turing machine. The presented proof of the \PSPACE\ bound 
has the advantage to generalize to the encoding of
alternating machines that we will present in the following section. 

Fix a deterministic Turing machine  working in space bounded by the
size of its input. We want to decide if on a given input the
computation of the machine loops. Thus we do not need any accepting
states in the machine and we can assume that there are no transitions
from rejecting states. We denote by  the states of  and by 
the tape alphabet of . A \emph{configuration} of  is a word over
 with exactly one occurrence of a letter from
. A configuration is of size   if it is a word of
length . Transitions of  will be denoted as ,
where  are the old/new state,  the old/new tape symbol and
 the left/right head move (w.l.o.g.~we assume that 
moves the head in each step). 

Suppose that the input is a word  of size . We will construct
automata  and  such that 
 
iff the computation of  on  is infinite. 

We start with some auxiliary alphabets. For every  let

We will write  instead of  for elements of . Let also
.

The automaton  is defined as follows:
\begin{enumerate}[]
\item The set of states is , 
and the alphabet of the automaton is .

\item We have transitions: 
  \begin{enumerate}[]
  
  \item  , for all  and ,

  \item , for  the 
    transition of  on  (there is at most one).

  \item From , transitions on letters in  go to . Similarly, from  transitions on
     go to  if there
    is a transition of  on ; if not, then  has
    no outgoing transitions. From  there are self-loops on
    all letters from .

  \end{enumerate}
\item For  the initial state of  is , the
  -th letter of ; for  the initial state is ,
  i.e., the initial state of  and the first letter of .
\end{enumerate}
Figure \ref{f:psp} shows a part of :
\vspace{1ex}

\begin{figure}[hbt]  
\centerline{\psset{nodesep=3pt,xunit=5cm,yunit=3cm,arrows=->}
\begin{pspicture}(2,1) 
  \cnodeput(0,0){t}{}
  \cnodeput(1,0){q}{}
  \cnodeput(1,1){a}{}
  \cnodeput(2,1){b}{}
  \ncline{a}{q}\naput{}
  \ncline{a}{t}\nbput[nrot=:D]{}
  \ncline{q}{t}\naput{}
  \ncline{q}{b}\nbput{}
  \nccircle[angleA=90,arrows=<-]{t}{.6cm}\naput{}
\end{pspicture}}
\vspace{2ex}
\caption{Part of }
         \label{f:psp}    
\end{figure}

The idea is classical: automaton  controls the -th tape
symbol, whereas automaton  defined below is in charge of the control part of
. The challenge is to do this without using any synchronization
between adjacent automata .
Next, we introduce an automaton  that will be used to define
 (see also Figure \ref{f:K}). The set of states of  is
; the initial state is  and the final one ;
the alphabet is ; the transitions are defined by:
\begin{enumerate}[]

\item  for , whenever we have a
  transition  in  for some state  and some letter ;
\item  for , whenever we
  have a transition  in  for some state  and some
  letter ; 

\item  and 
  for all .
\end{enumerate}
Figure \ref{f:K} presents a schema of the
automaton .  We define  as the deterministic automaton
recognizing , that is obtained by gluing together the states
 and .

\vspace{3ex}

\begin{figure}[htb]
\centerline{\psset{nodesep=3pt,xunit=5cm,yunit=3cm,arrows=->}
\begin{pspicture}(2,1)
\cnodeput(0,0.5){s}{}
\cnodeput(2,0.5){e}{}
\cnodeput(1,0){l}{}
\cnodeput(1,1){r}{}
\ncline{s}{l}\nbput{}
\ncline{s}{r}\naput{}
\ncline{l}{e}\nbput{}
\ncline{r}{e}\naput{}
\end{pspicture} 
} 
\vspace{2ex}


\caption{Automaton }\label{f:K}
\end{figure}

\begin{remark}
  All  and  are deterministic automata of size polynomial in . 
The input alphabets of the   are almost pairwise disjoint: the only 
states with common labels on outgoing transitions are the  states.
\end{remark}

\begin{defi}
  We say that a configuration  of size  of  \emph{corresponds} to a
  global state  of  iff  for ; in
  other words, if the state of  is the same as the -th letter of
  .
\end{defi}

\begin{defi}
  We say that a global state  of  is \emph{proper} when
  there is no -state in . 
\end{defi}

\begin{lemma}
  If  is a proper state, then for every letter  the
  automaton  has in state  at most one outgoing
  -transition.  Once the automaton enters a state that is not
  proper, it stays in non proper states.
\end{lemma}
 It is easy to see that from a non proper state,  can simulate 
any state of . The reason is that from ,
 any move on letters from  is possible.


\begin{lemma} \label{l:step}
Suppose that  is in a state  that corresponds to a
  configuration  of .
  \begin{enumerate}[]
  \item If  is a configuration with no successor,
    then there is a word  that cannot be simulated by
     from .

  \item Otherwise, the successor configuration  exists,
    and there is a unique word  such that
     and  is proper. Moreover 
    corresponds to . All other words from  lead from 
    to non
    proper states of . 
  \end{enumerate}
\end{lemma}

\begin{proof}

  For the first claim, assume that  corresponds to a configuration, 
thus there is exactly one 
  such that  is in a state from . The other
  automata are in states from . 
  
  If  is terminal then  is in a state  which has
  no  outgoing transition. This means that this state can
  simulate no  move on letters , for   and  (and
  such a move exists in , as the machine  must have a move to the
  right if it is nontrivial). All other automata are also not capable
  to simulate  as they can do only moves on letters  for
  .

  Now suppose that . To avoid special, but simple, cases
  suppose that the position  of the state is neither the first nor
  the last. Let  and suppose also that  is the
  move of  on . The case when the move is to the left is
  similar.

  The only possible move of  from  which will put 
  into a proper state is . This makes  to change the
  state to  and it makes  to change the state to . From
  this latter state the only possible move of  is on letters
   for arbitrary . Suppose that  is in the
  state , then all moves of  on  with 
  can be matched with a move to  of . On 
 the automaton  goes to  and automaton  goes to
  . This way the state in the configuration is changed and
  transmitted to the right. We have that the new state of 
  corresponds to the configuration . 


\end{proof}

\begin{lemma}
  We have  iff the computation of  on  is
  infinite. 
\end{lemma}

\begin{proof}
  Recall that  is a deterministic automaton recognizing
  , and has initial state .  
The initial state of  corresponds to the initial
  configuration  of  on . We show now for every state 
 corresponding to a configuration  of :   iff the 
computation of  starting in  is infinite.

From a configuration , the machine  has only one computation: either
infinite, or a finite one that is blocking. Suppose that the computation
from  has at least one step and let  be the successor
configuration. By Lemma~\ref{l:step} from state  there is exactly
one word  such that  in ,
and  is proper.  Moreover 
corresponds to . On all other words from , the product
 reaches non proper states and from there it can simulate any
future behaviour of .  If  has no successor configuration
then, again by Lemma~\ref{l:step}, there is a word in  that
cannot be simulated by  from . If  has a successor
then we repeat the whole argument. Thus the behaviour of  from 
can be simulated by  from the state corresponding to 
iff the machine  has an infinite computation starting from .

\end{proof}

\medskip

One can note that the construction presented in this section uses
actions that are common to several processes in a quite limited way:
the only states that have common outgoing labels are the  states
from which all behaviours are possible. This observation motivates the
question about the complexity of the problem when the
automata  have pairwise disjoint alphabets. With
this restriction, the simulation problem can be solved efficiently:

\begin{thm}
The following question can be solved in polynomial time:

\emph{Input:}  deterministic automata
 over pairwise disjoint input alphabets, 
and a deterministic automaton .

\emph{Output:} decide if
.
\end{thm}

\begin{proof}
  Let  be a automaton with a single state , and with
  self-loops on every letter from the alphabet  of . We
  write  for the asynchronous product of all , , and of . Similarly,  will denote 
with all components but  replaced by .  Suppose now that 
is a state of , and  a state of .  We write  if  is simulated by  in .
 Notice that since  and  are both deterministic,
we can decide if  in logarithmic space (hence in
polynomial time), by guessing simultaneously a path in  and one
in .

  We show now that  in  iff  for
  all .

  If , then all the more , since  can simulate  for all .
  Conversely, assume that 
  for all , but  . This means that
  there exist computations  in ,
   in  and a letter  for some , such that  has an outgoing
  -transition, but  does not (in ). Clearly, we
  also have a computation  in . Since  has no outgoing
  -transition, so neither does , which contradicts .
\end{proof}



\section{The complexity of simulation}

This time we take an alternating Turing machine  working in space
bounded by the size of the input. We want to decide if  has an
infinite computation.  This means that the machine can make choices of
existential transitions in such a way that no matter what are the
choices of universal transitions the machine can always
continue. Clearly, one can reduce the word problem to this problem,
hence it is \EXPTIME-hard (see \cite{cks81}; for more details on
complexity see any standard textbook).

We will assume that  has always a choice between two transitions,
i.e., for each non blocking state/symbol pair  there will be precisely two 
distinct tuples
,  such that  and . If  is existential then it is up to the machine to choose
a move; if  is universal then the choice is made from 
outside. To simplify the presentation we will assume that ,
i.e., both moves go in the same direction.  Every machine can be
transformed to an equivalent one with this property. We will also
assume that the transitions are ordered in some way, so we will be able
to say that  is the first transition and 
is the second one.


Take the input word is  of size . We will construct
automata  and  such that 
is simulated by  iff there is an infinite alternating
computation of  on . The main idea is that automata  and  
control the -th tape symbol, as in the previous section, and each one is in charge 
of one of the two possible transitions (if any) when the input head is
at position  in an existential state (universal moves are simpler).

We will modify a little the alphabets that we use. Let

We then put , , 
 and .

The automaton  is defined as follows:
\begin{enumerate}[]
\item The set of states is , the alphabet of the automaton is
  ; where  is a new letter common
  to all  automata.

\item We have the following transitions: 
  \begin{enumerate}[]
  \item  for all  and ,

  \item  and  if  is
    an universal state and ,  are the two
    transitions from . We have also transitions to  on all
    the letters from .

  \item  and
     if  is an existential state and
    ,  are the first and the second
    transitions from , respectively. We have also transitions to
     on all the letters from . 
     From  all transitions
    on  go to .


  \item From , transitions on letters in  go to .  If  is terminal then there are no
    outgoing transitions from .  From  there are self-loops
    on all letters from .
  \end{enumerate}

\item The initial state of  is , the -th letter
  of  except for  whose initial state is , the
  initial state of  and the first letter of .
\end{enumerate}
Figure~\ref{fig:Aprim} below presents parts of  corresponding to
universal and existential states.
\vspace{2ex}

\begin{figure}[htb]
  \centering
{
\psset{nodesep=3pt,xunit=5.6cm,yunit=3cm,arrows=->}
\begin{pspicture}(1.9,1)
  \cnodeput(0,0){t}{}
  \cnodeput(1,0){q}{}
  \cnodeput(1,1){a}{}
  \cnodeput(1.9,1){bp}{}
  \cnodeput(1.4,1){bpp}{}
  \ncline{a}{q}\naput{}
  \ncline[arrows=<-]{t}{a}\naput[nrot=:U]{}
  \ncline{q}{t}\naput{}
\psset{arcangle=-20}
  \ncarc{q}{bp}\nbput[nrot=:U]{}
  \ncarc{q}{bpp}\nbput[nrot=:U]{}
  \nccircle[angleA=90,arrows=<-]{t}{.5cm}\naput{}
\end{pspicture}
}\vspace{6ex}

{\psset{nodesep=3pt,xunit=5.6cm,yunit=3cm,arrows=->}
\begin{pspicture}(1.9,1)
  \cnodeput(0,0){t}{}
  \cnodeput(1,0){q}{}
  \cnodeput(1.5,.4){c}{}
  \cnodeput(1,1){a}{}
  \cnodeput(1.9,1){bp}{}
  \cnodeput(1.4,1){bpp}{}
  \cnodeput(2,0){tp}{}
  \ncline{a}{q}\naput{}
  \ncline[arrows=<-]{t}{a}\naput[nrot=:U]{}
  \ncline{q}{t}\naput{}
  \psset{arcangle=-20}
  \ncarc{q}{c}\nbput[nrot=:U]{}
  \ncarc{c}{bp}\nbput[nrot=:U]{}
  \ncarc{q}{bpp}\nbput[nrot=:U]{}
  \nccircle[angleA=90,arrows=<-]{t}{.5cm}\naput{}
  \ncline{c}{tp}\nbput[nrot=:U]{}
\end{pspicture}
}
\vspace{3ex}

\caption{Parts of the automaton  corresponding to universal
  and existential states , respectively. The alphabet  is
  .}
  \label{fig:Aprim}
\end{figure}


The automaton  is the same as  with the difference
that we replace every label  by ,
every  by  (notice the change of primes and double
primes), every   by  and  by . Moreover,
state labels  and  are exchanged, and state  is
relabeled . 


Next, we define a new automaton  that will be used to define new
automaton . The states of  are

plus some auxiliary states to implement transitions on two letters at
a time. We will write transitions with two letters on them for
readability. The initial state is  and the final one is . The
alphabet is . The transitions are defined by (cf.\
Figure~\ref{fig:autK}):
\begin{enumerate}[]

\item ;

\item  whenever we have a
  transition  in  for some universal state  and 
some letter , and
  similarly from  instead of  when  is existential;

\item  whenever we
  have a transition  in  for some universal state 
  and some letter , and similarly from  instead of 
  when  is existential;

\item  and 
  for all . 
\end{enumerate}
We define  as the deterministic automaton recognizing
 that is obtained by gluing together states  and .
\vspace{2ex}

\begin{figure}[htb]
  \centering {\psset{nodesep=3pt,xunit=5.4cm,yunit=3cm,arrows=->}
  \begin{pspicture}(2,2)
  \cnodeput(0,1){l}{} 
  \cnodeput(2,1){r}{} 
  \cnodeput(1,2){s}{}  
  \cnodeput(1,1){c}{}  
  \cnodeput(1,0){e}{}  
  \ncline{s}{l}\nbput[nrot=:D]{}
  \ncline{s}{r}\naput[nrot=:U]{}
  \ncline{c}{l}\nbput[nrot=:D]{}
  \ncline{c}{r}\naput[nrot=:U]{}
  \ncline{s}{c}\nbput[nrot=:L]{}
  \ncline{l}{e}\nbput[nrot=:U]{}
  \ncline{r}{e}\naput[nrot=:D]{}
  \end{pspicture}
}
  
  \caption{Automaton }
  \label{fig:autK}
\end{figure}

\begin{remark}
  All ,  and  are deterministic and of size
  polynomial in .
\end{remark}


\begin{defi}\label{df:cor}
  A configuration  of size  \emph{corresponds} to a global state
     of  if   for ;
    in other words, if the states of  and  are the
    same as the -th letter of .
\end{defi}

\begin{defi}
  We say that a global state  of  is \emph{proper}
  when  does not appear in .
\end{defi}

It is easy to see that from a non proper state,  can simulate 
any state of . The reason is that from ,
 any move on letters from  is possible.

\begin{lemma}\label{lemma:mainexp}
  Suppose that  is in a state  corresponding to a
  configuration  of . If  has no successor configuration
  then there is a word  that cannot be simulated by   from . Otherwise,  has two
  successor configurations  and . We have two cases:
  \begin{enumerate}[]

  \item If  is universal then there are two words  and  in
    : each leading from  to a unique state  and
    , respectively. These two states are proper and
    correspond to  and , respectively. On all other words
    from , non proper states can be reached from .

  \item If  is existential, then on the letter  exactly
    two states are reachable from , call them  and
    . There is a word  such that 
    and on  from  a unique state is reachable. This state
    is proper and corresponds to . Similarly there is a word 
    for  and . On all words from  that are different from  and , non proper states can be reached from
    .
  \end{enumerate}
\end{lemma}

\begin{proof}
  As  corresponds to the configuration , there is some 
  such that both automata  and  are in state ,
  for some  and , and all other automata are in
  states from .

  If  is a configuration without successor, then the state  in
   and  does not have any outgoing transition. Thus
  these automata cannot simulate the  transition of  from
  . No other automaton , or  can simulate the
   transition either, as they are all in states from .

  Suppose that  is an universal configuration with two possible
  transitions to the right,  and . The
  case when the moves are to the left is similar. In  from the
  state  we have a transition on  leading to  and on
   leading to . Similarly for , but on
   and . These transitions can simulate both
  transitions  and 
  that are possible from  in . (All other transitions from  in
   lead from  to a non proper state of .) Let us focus
  only on the first case, when  is executed in 
  and the state  is reached. From this state only 
  transitions  are possible, for all . Suppose that  and  are in state
  . Transition  of  is simulated by moves
  to  in both  and .  This way the new
  state is transferred to the right.  Transitions 
  where  are simulated in  by moves of 
  and  to . 

  Suppose that  is an existential configuration, with possible
  transitions  and . The case when moves
  are to the left is similar.  Consider first the transition of 
  from  that corresponds to the letter .  Both 
  and  can simulate this transition: the first goes to state
  , and the second goes to . Assume that it is the
  transition of  that is taken; the other case is
  symmetric. We get to the position when  is in the state
  ,  is in the state  and  in the
  state . From , automaton  can do
   that can be simulated by the transitions of
   and  (every other transition of  can be
  simulated by a move of  to a non proper state).  Both
  automata reach the state . Automaton  is now in state
   from where it can do  for any . The
  result of simulating these transitions while reaching a proper state
  is the transfer of the state to the right, in the same way as in the
  case of the universal move. Finally, it remains to see what happens
  if  makes a move from  that is different from .  In
  this case, at least one of the automata ,  can
  simulate the corresponding transition on , 
  respectively, by going to state , since we suppose that in any
  configuration of , the two outgoing transitions are
  distinct. Hence, a non proper state can be reached.
\end{proof}

\begin{thm} \label{th:main}
  The following problem is \EXPTIME-complete:

\emph{Input:} deterministic automata
  and a deterministic automaton .

\emph{Output:} decide if
.

\end{thm}
\begin{proof}
  The problem is clearly in \EXPTIME\ as the state space of 
  can be constructed in \EXPTIME. For \EXPTIME\ hardness, we take an
  alternating machine  as at the beginning of this section and use
  the construction presented above together with
  Lemma~\ref{lemma:mainexp}. Recall, that  is a deterministic
  automaton obtained from the automaton  by gluing states  and
   (cf.\ Figure~\ref{fig:autK}). We also have that the initial
  state of  corresponds to the initial configuration of  (in
  a way required by Definition~\ref{df:cor}). We will show that for
  every state  corresponding to a configuration  of :  iff  has an infinite alternating computation from .

  Consider a game of two players: Computer and Environment. Positions
  of the game are configurations of . In existential configurations
  Computer chooses a successor configuration (with respect to the
  transition table of ). In universal configurations Environment
  makes a choice. Having an infinite alternating computation from 
  is equivalent to saying that in this game Computer has a strategy to
  avoid being blocked. At the same time, not having such a computation
  from  is equivalent to saying Environment has a strategy to reach
  a configuration with no successors. As this is a reachability game,
  for each such  there is a bound  (distance) on the number of
  steps in which Environment can force Computer into a blocking
  configuration. This distance is  if  is blocking; it is one
  plus the maximum over distances for two successor configurations if
   is existential, and it is one plus the minimum over the
  distances of successor configurations if  is universal. (Here we
  assume that the distance is  if Environment cannot win from
  .).

  Going back to the proof of the theorem, consider first the case when
   does not have an infinite alternating computation from . Let
   be the state of  corresponding to .  We show that
   by induction on the distance . There are
  three possible cases:
  \begin{enumerate}[]
  \item If  then is no transition possible from . In this case 
    Lemma~\ref{lemma:mainexp} gives us an execution of  from  that
    cannot be simulated by  from .
  \item If  is universal, there is a successor  such that
    . We take the word  given by
    Lemma~\ref{lemma:mainexp}. The only way to simulate this word from
     leads to the proper state  corresponding to
    . By induction hypothesis .
  \item If  is existential, then for both successor configurations,
     and , the distance is smaller. We make  execute
     and then, depending how it was matched by  , a
    word forcing the automaton to go to a proper state corresponding
    either to  or to . Using the induction hypothesis we get that
    the simulation is not possible from  and the obtained states.
  \end{enumerate}

  The case when  has an infinite alternating computation from 
  is very similar. In this case . The means that if  is
  an existential computation then one of the successor configurations
  has distance equal to . By Lemma~\ref{lemma:mainexp} we can
  match  so that we go to the state corresponding to that
  configuration. If  is universal then both successor
  configurations have distance equal to . Once again
  Lemma~\ref{lemma:mainexp}, tells us how to match every word from
  .
\end{proof}

We conclude the section by showing that Theorem \ref{th:main} still
holds under the assumption that the alphabet of the automata 
and  is of
constant size.

\begin{thm} \label{th:mainc} Let  be a fixed alphabet of at
  least  letters. The following problem is \EXPTIME-complete:

\emph{Input:} deterministic automata
  and a deterministic automaton  over
the input alphabet .

\emph{Output:} decide if
.

\end{thm}

\begin{proof}
  We reduce directly from Theorem \ref{th:main}. Suppose that
  the input alphabet of all automata  is , for some . Moreover,
  let  be the set of states of  and let  be the set of global states of .

  In each automaton ,  we replace every transition  by a sequence of transitions with labels from \}} t

The  states  are new. Let 
be the automata obtained from  , , with state space  and ,
respectively.

Take , the largest simulation relation from 
to . We show how to extend  to 
such that  is a simulation relation from 
to  (not necessarily the largest one). Let  be the union of  with 
the set of all pairs , where 
, , and
such that:

\begin{enumerate}[]
\item  and  for some ,
   and  such that
  , ,

\item there is some  with , and  for
  .
\end{enumerate}
It is immediate to check that  is a simulation relation.
First, (old) states from  can only be simulated by (old) states
from .  Second, a new state  of  can be simulated only
by states . It can be shown easily that the
largest simulation relation from  to  coincides with
 (hence with ) on the set  of pairs of old
states. 

\end{proof}

\section{The complexity of bisimulation}


Till now we  wanted to decide if an asynchronous product of
deterministic automata  can simulate a
deterministic automaton . An evident question is to consider what
happens if we consider bisimulation instead  of simulation. To be
bisimilar to an asynchronous product,  must satisfy some 
structural constraints. In this section we prove the following theorem,
which shows that indeed, the bisimulation problem is easier. 

\begin{thm}
  The following question can be solved in logarithmic space:

  \emph{Input:}  deterministic automata  and a
  deterministic automaton .

  \emph{Output:} decide if  and  are bisimilar.
\end{thm}

The proof of the theorem will occupy the rest of the section. We fix
 and . Without loss of generality we assume
that  is minimal with respect to bisimulation: no two different
states of  are bisimilar (if  is not minimal we can
minimize it on-the-fly in logarithmic space).  This
assumption also has a very pleasant consequence. If two states 
and  of  are bisimilar to the same global state of ,
then .

As we aim to obtain a logarithmic space algorithm we cannot even allow
ourselves to explore the state space of  at random, as we cannot
store the tuples of states. This is why the following definition is
crucial for the construction.

\begin{defi}
  A sequence of transitions of  is
  \emph{banal} if it can be decomposed into a, possibly empty,
  sequence of transitions of , followed by one of ,
  and so on, up to .
\end{defi}

Observe that thanks to the lack of synchronization every state of
 is reachable by a run that is a banal sequence. Another
pleasant property is that banal sequences can be explored in
logarithmic space: we need only to remember the current state of the
unique process that is active. We call \emph{configuration} a pair
 consisting of a state  of  and a global state  of
. For convenience, we say that a configuration  is
reachable by some sequence  of transitions of  if  leads
to  from the initial state of , and if  is reached 
in  from the initial state by the sequence of actions associated
with  (this is well-defined since  is deterministic).  Note
also that we can explore any configuration
 that is reachable by some banal sequence in
logarithmic space.  Let us call such pairs \emph{banally-reachable
  configurations}.

The first necessary condition for  being bisimilar to
 is that for every banally-reachable
configuration  the same actions are possible from  and
. This can be checked in logarithmic space as it is  easy to
verify its negation within this bound.

The second necessary condition is that every reachable configuration
is banally-reachable. Indeed, if  is reachable by a
sequence that is not banal then the banal sequence  obtained by
ordering the transitions process-wise also reaches
. If a bisimulation exists then we are
guaranteed that  reaches  in .  This is because the state
reached by  must be bisimilar to , and  is minimal with
respect to bisimulation.

To show that one can check in logarithmic space that every reachable
configuration is banally-reachable, we consider
the negation of this property. We can then use the fact that
\LOGSPACE\ is closed under complement. We want to find a reachable
configuration that is not banally-reachable. If one exists then we can
look at one that is reachable in a shortest number of steps. This
means that there must exist a banally-reachable configuration
, an action  and a process  such that
 is not banally-reachable, where 
and  is obtained from  by taking transition  of
process . This can be checked as follows. One produces on-the-fly a
banal sequence, when the part of process  is finished an extra
transition with letter  is taken. This way we have two states, one
before taking  and one after. We then continue constructing banal
sequences from the two states with transitions of processes  up
to . This way we have obtained two sequences which differ by the
action  of process , and we check that the two states reached by
 are different.

Together, the two conditions above are also sufficient for  and
 being bisimilar, hence the result.



\section{Conclusion}

We have shown an \EXPTIME\ lower bound for the composition of
services that are described as a fully asynchronous product of finite state
machines. Thus, we answer the question left open in \cite{BCGLM03}. 
Since our lower bound holds for the simplest parallel composition
operation one can think of (no synchronization at all), it also
applies to richer models, such as products with synchronization on
actions as in \cite{LarSch00} or communicating finite-state machines
(CFSM) as in \cite{hbcs03,fbs04}. It is easy to see that the
simulation of a finite-state machine by a CFSM  with bounded
message queues is in \EXPTIME, since the state space of  is
exponential in this case. Hence, this problem, as well as any of its
variants with some restricted form of communication, is
\EXPTIME-complete as well.

An interesting open question  is what happens if we allow in the
asynchronous product arbitrary many copies of each finite state
machine. That is, we suppose that an available service can be used
by an arbitrary number of peers. This question reduces to a bounded
variant  of the simulation of a finite state machine by a BPP, and its
decidability status is open.

\medskip

\emph{Acknowledgement:} We thank the anonymous referees  for interesting
comments and suggestions for improvement.




\begin{thebibliography}{1}

\bibitem{ACKM04}
G.~Alonso, F.~Casati, H.~Kuno, and V.~Machiraju.
\newblock {\em Web Services. Concepts, Architectures and Applications}.
\newblock Springer, 2004.

\bibitem{BCGLM03}
D.~Berardi, D.~Calvanese, G.~De~Giacomo, M.~Lenzerini, and M.~Mecella.
\newblock Automatic composition of e-services that export their behavior.
\newblock In {\em Proc. of the 1st Int. Conf. on Service Oriented Computing
  (ICSOC 2003)}, LNCS 2910, pp.~43--58, 2003.

\bibitem{BCGHM05}
D.~Berardi, D.~Calvanese, G.~D. Giacomo, R.~Hull, and M.~Mecella.
\newblock Automatic composition of web services in Colombo.
\newblock In {\em SEBD 2005}, pages 8--15, 2005.

\bibitem{vldb05}
D.~Berardi, D.~Calvanese, G.~D. Giacomo, R.~Hull, and M.~Mecella.
\newblock Automatic composition of web services with messaging.
\newblock In {\em VLDB 2005}, pages 613--624, 2005.

\bibitem{bz83}
D.~Brand and P.~Zafiropulo.
\newblock On communicating finite-state machines.
\newblock {\em J.\ ACM} 30(2):323--342, 1983.

\bibitem{cks81}
A.~K.~Chandra, D.~Kozen and L.~J.~Stockmeyer.
\newblock Alternation. 
\newblock \emph{J.\ ACM} 28(1):114--133, 1981.

\bibitem{dsv06}
A.~Deutsch, L.~Sui, V.~Vianu, and D.~Zhou.
\newblock Verification of communicating data-driven web services.
\newblock In {\em Symposium on Principles of Database Systems (PODS)},
pp.~90-99, 2006.

\bibitem{fbs04}
X.~Fu, T.~Bultan, and J.~Su.
\newblock Conversation protocols: a formalism for specification and 
verification of reactive electronic services. 
\newblock In \emph{Theor. Comput. Sci.} 328(1-2):19--37, 2004.

\bibitem{hbcs03}
R.~Hull, M.~Benedikt, V.~Christophides, J.~Su.
\newblock E-services: a look behind the curtain. 
\newblock In \emph{Symposium on Principles of Database Systems
    (PODS)}, pp.~1-14, 2003.

\bibitem{LarSch00}
F.~Laroussinie and {\relax Ph}.~Schnoebelen.
\newblock The state explosion problem from trace to bisimulation equivalence.
\newblock In {\em FoSSaCS 2000}, LNCS 1784, pp.~192--207, 2000.

\bibitem{mw07}
A.~Muscholl and I.~Walukiewicz. 
\newblock A lower bound on Web services composition.
\newblock In \emph{Proc. of FoSSaCS'07}, LNCS 4423, pp.~274-286, 2007.

\bibitem{Srba}
J.~Srba.
\newblock Roadmap of infinite results.
\newblock \emph{Bulletin of the EATCS} 78, pages 163-175, 2002. See
also \texttt{ http://www.brics.dk/srba/roadmap}.



\end{thebibliography}














































\end{document}
