\documentclass[a4paper,10pt]{article}
\usepackage{latexsym}
\usepackage{theorem}
\usepackage{color,graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{txfonts}
\usepackage{enumitem}
\usepackage{fullpage}

\usepackage{theorem}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{proposition}{Proposition}[section]

\usepackage{algorithmic}
\usepackage{algorithm,caption}
\newtheorem{observation}{Observation}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\renewcommand{\thealgorithm}{}
\floatname{algorithm}{Procedure}


\newcommand{\view}[1][]{\if!#1!\mathcal{V}\else\mathcal{V}^{#1}\fi}
\newcommand{\cQ}{\mathcal{Q}}
\newcommand{\partition}[1]{\Pi_{#1}}
\newcommand{\viewPath}[3][]{\if!#1! P(#2,#3)\else P(#2,#1,#3)\fi}  \newcommand{\ourColor}{\alpha}
\newcommand{\st}{\hspace{0.1cm}\bigl|\bigr.\hspace{0.1cm}}
\newcommand{\card}[1]{|#1|}
\newcommand{\levelInView}[2]{\textup{lev}_{#2}(#1)}   \newcommand{\diam}{D}
\newcommand{\commonTime}[1]{\xi_{#1}}
\newcommand{\commonTimeMax}{\Xi}
\newcommand{\modulo}{\,\textup{mod}\,}
\newcommand{\nodeA}[2]{a_{#2}(#1)}
\newcommand{\nodeB}[2]{b_{#2}(#1)}
\newcommand{\nats}{\mathbb{N}}

\newcommand{\ints}{\mathbb{N}}
\newcommand{\algorithmLE}{\textup{\texttt{LeaderElection}}}
\newcommand{\algorithmTR}{\textup{\texttt{TopologyRecognition}}}
\newcommand{\algorithmMain}{\textup{\texttt{Solve-LE-and-TOP}}}
\newcommand{\algorithmQuotient}{\textup{\texttt{ComputeQuotientGraph}}}
\newcommand{\algorithmView}{\textup{\texttt{ComputeView}}}
\newcommand{\algorithmTest}{\textup{\texttt{TestRepetition}}}

\newcommand{\returnTrue}{\texttt{true}}
\newcommand{\returnFalse}{\texttt{false}}
\newcommand{\returnFailure}{\texttt{{unsolvable}}}
\newcommand{\communicate}{\texttt{communicate}}

\newcommand{\problemLE}{\textup{LE}}
\newcommand{\problemTOP}{\textup{TOP}}

\newcommand{\cV}{{\cal V}}
\newcommand{\qed}{\hfill  \smallbreak}
\newenvironment{proof}[1][Proof]
{\par\noindent{\bf #1:} }{\hspace*{\fill}\nolinebreak{}\bigskip\par}



\begin{document}

\title{Topology Recognition and Leader Election in Colored Networks}

\author{Dariusz Dereniowski\thanks{Faculty of Electronics, Telecommunications and Informatics, Gda{\'n}sk University of Technology, Narutowicza 11/12, 80-233 Gda\'{n}sk, Poland. Email: deren@eti.pg.gda.pl. Partially supported by National Science Centre grant DEC-2015/17/B/ST6/01887.}
\and
Andrzej Pelc\thanks{D\'epartement d'informatique, Universit\'e du Qu\'ebec en Outaouais, Gatineau, Qu\'ebec J8X 3X7, Canada. Email: pelc@uqo.ca. Partly supported by the NSERC discovery grant 8136 -- 2013 and by the Research Chair in Distributed Computing at the Universit\'e du Qu\'ebec en Outaouais.}
}

\date{}
\maketitle



\begin{abstract}
Topology recognition and leader election are fundamental tasks in distributed computing in  networks. The first of them requires each node to find a labeled isomorphic copy of the network, while the result of the second one consists in a single node adopting the label 1 (leader), with all
other nodes adopting the label 0 and learning a path to the leader. We consider both these problems in networks whose nodes 
are equipped with not necessarily distinct labels called {\em colors}, and ports at each node of degree  are arbitrarily numbered . Colored networks are generalizations both of labeled networks, in which nodes have distinct labels, and of anonymous 
networks, in which nodes do not have labels (all nodes have the same color). 

In colored networks, topology recognition and leader election are not always feasible. Hence we study two more general problems.
Consider a colored network and an input  given to its nodes.
The aim of the problem , for this colored network and for , is to solve topology recognition in this network, if this is possible under input , and to have all nodes answer ``unsolvable'' otherwise.
Likewise, the aim of the problem  is to solve leader election in this network, if this is possible under input , and to have all nodes answer ``unsolvable'' otherwise. 

We show that nodes of a network can solve problems  and , if they are given, as input ,
an upper bound  on the number of nodes of a given color, called the {\em size} of this color.
On the other hand we show that, if the nodes are given an input that does not bound the size of any color, then the answer to  and  must be ``unsolvable'', even for the class of rings.

Under the assumption that nodes are given an upper bound  on the size of a given color, we study the time of solving problems  and  in the  model in which, during each round, each node can exchange arbitrary messages with all its neighbors and perform arbitrary local computations.
We give an algorithm to solve each of these problems in arbitrary networks in time , where  is the diameter
of the network and  is its size. We also show that this time is optimal, by exhibiting
classes of networks in which every algorithm solving problems  or  must use time
.
\end{abstract}

\textbf{Keywords:} topology recognition, leader election, colored network, local model

\section{Introduction} \label{sec:intro}

\subsection{The model and the problem} \label{subsec:model}

Topology recognition and leader election are fundamental tasks in distributed computing in  networks. The goal of topology recognition is for each node of the network to acquire a faithful map of it (an isomorphic
copy of the underlying network with all nodes having distinct identifiers), with the position of the node marked in the map. If nodes can solve this problem, any other 
distributed task, such as leader election \cite{HS,P}, minimum weight spanning tree construction \cite{A}, 
renaming \cite{ABDKPR}, etc. can be performed by them using
only local computations. Thus topology recognition converts all distributed problems to centralized ones, 
in the sense that nodes can solve any distributed problem simulating a central monitor.

Leader election, first stated in \cite{LL}, is likewise of fundamental importance.
Each node of the network has a Boolean variable initialized to 0 and, after the election, exactly one node,
called the {\em leader}, should change this value to 1. All other nodes should know which one becomes the leader by discovering a path to it.
Notice that the above two problems are equivalent: having a map of the network with distinct node labels, nodes can elect the node with the smallest
label as the leader, and conversely, knowing a leader, nodes can construct a map of the network using the leader as a stationary token, cf. \cite{CDK}.

It should be noted that formulations of the leader election problem vary across the literature (cf. \cite{Ly}). In a weak formulation, every node should only know if it is the leader or not. (In \cite{MP}, this task was called selection, by contrast to election). In a strong formulation, every node should moreover get to know who is the leader. We adopt the latter formulation of the leader election problem. When nodes have distinct identities, knowing who is the leader means outputting its identity. In our scenario distinct identities need not exist, hence knowing who is the leader means that every node outputs a path to the leader, coded as a sequence of ports. This formulation of leader election was used, e.g., in \cite{GMP} for anonymous networks.   


A network is modeled as a simple undirected connected graph. As commonly done in the literature, cf., e.g. \cite{YK3} {or  model in \cite{AGPV}}, we assume that
ports at a node of degree  have arbitrary fixed labelings  .
We do not assume any coherence between port labelings at various nodes.
As for nodes, we assume that they are equipped with not necessarily distinct labels called {\em colors}.  In applications, colors may be types of the devices interconnected by the network, 
such as workstations, servers, laptops, or mobile phones.
Networks with colored nodes are generalizations both of labeled networks in which nodes have distinct labels, and of anonymous 
networks, in which nodes do not have labels (all nodes have the same color). 
Nodes communicate by exchanging arbitrary messages along links. A node sending a message
through a given port appends the port number to the message, and a node receiving a message
through a port is aware of the port number by which the message is received.

If nodes have distinct identities, both topology recognition and leader election are easily accomplished in any network. By contrast, it is well known that, in the absence of distinct node labels, these tasks are often impossible, if no additional information about the network is provided to nodes. In fact, even the less demanding task of reconstructing an unlabeled isomorphic copy of the
network is sometimes impossible. 
For example, in an anonymous ring whose each edge has port numbers 0 and 1 at its
endpoints, not only topology recognition and leader election cannot be achieved but even 
the size of the ring cannot be learned by nodes. Providing the size of the network as input is not a remedy
either: the authors of \cite{YK3} give examples of two (anonymous) non-isomorphic graphs of size 6 whose
nodes cannot decide in which of these two graphs they are.

Due to these impossibilities, we consider two problems more general than topology recognition
and leader election, respectively.
Consider a colored network and an input  given to its nodes.
The aim of the problem , for this colored network and for , is to solve topology recognition in this network, if this is possible under input , and to have all nodes answer ``unsolvable'' otherwise.
Likewise, the aim of the problem  is to solve leader election in this network, if this is possible under input , and to have all nodes answer ``unsolvable'' otherwise. 

Our goal is to find out what type of input has to be given to the nodes of a colored network in order to enable them to solve problems  and , and what is the minimal time in which they can solve these problems, if this input is provided.
To investigate time, we use the extensively studied  model \cite{Pe}.
In this model, communication proceeds in synchronous rounds and all nodes start simultaneously.
In each round each node can exchange arbitrary messages with all its neighbors and perform arbitrary local computations. 
The time of completing a task is the number of rounds it takes.






\subsection{Our results} \label{subsec:our_results}


We first show that nodes of a network can solve problems  and , if they are given
an upper bound  on the number of nodes of a given color, called the {\em size} of this color.
This means that, if such an upper bound is known to all nodes (even if they do not know any upper bound on the total number of nodes
or on the number of colors), then they can correctly decide if leader election and topology recognition
are feasible in the given network, and if so, they can perform these tasks. 
On the other hand, if the nodes are given an input that does not bound the size of any color, then the answer to  and  must be ``unsolvable'', even for the class of rings.

Hence, providing all nodes with an upper bound on the size of some color is the weakest assumption under which problems  and  can be meaningfully solved. 
This justifies the use of this assumption in our algorithms.


Next, assuming that all nodes have an upper bound  on the size of a given color,
we study the time of solving problems  and  in the  model. We give an 
algorithm to solve each of these problems in arbitrary networks in time , where  is the diameter
of the network and  is its size. We also show that this time is optimal, by exhibiting
classes of networks in which every algorithm solving problems  or  must use time
.



\subsection{Related work} \label{subsec:related_work}
Early studies of leader election in networks mostly concerned the scenario where all nodes have distinct labels.
This task was first studied for rings.
A synchronous algorithm, based on comparisons of labels, and using
 messages was given in \cite{HS}. It was proved in \cite{FL} that
this complexity is optimal for comparison-based algorithms. On the other hand, the authors showed
an algorithm using a linear number of messages but requiring very large running time.
An asynchronous algorithm using  messages was given, e.g., in \cite{P} and
the optimality of this message complexity was shown in \cite{B}. Deterministic leader election in radio networks has been studied, e.g., 
in \cite{JKZ,KP,NO} and randomized leader election, e.g., in \cite{Wil}. In \cite{HKMMJ} the leader election problem is
approached in a model based on mobile agents for networks with labeled nodes.

Many authors \cite{An,ASW,AtSn,BV,DKMP,Kr,KKV,Saka,YK,YK3} studied leader election
and other computational problems
in anonymous networks. In particular, \cite{BSVCGS,YK3} characterize message passing networks in which
leader election can be achieved when nodes are anonymous. 
The authors assume that nodes know an upper bound on the size of the network. In \cite{YK2} the authors study
the problem of leader election in general networks, under the assumption that labels are
not unique. They characterize networks in which this can be done and give an algorithm
which performs election when it is feasible. They assume that the number of nodes of the
network is known to all nodes. In
 \cite{FKKLS}  the authors
study feasibility and message complexity of sorting and leader election in rings with
nonunique labels, while in \cite{DoPe} the authors provide algorithms for the
generalized leader election problem in rings with arbitrary labels,
unknown (and arbitrary) size of the ring, and for both
synchronous and asynchronous communication. 
Characterizations of feasible instances for leader election and naming problems have been provided in~\cite{C,CMM,CM}.
Memory needed for leader election in unlabeled networks has been studied in \cite{FP}. 
In \cite{FP1}, the authors investigated the time of leader election in anonymous networks
by characterizing this time in terms of the size and diameter of the network, and of an additional
parameter, called level of symmetry, which measures how deeply nodes have to inspect the network to notice differences in their views of it.
In \cite{DP1}, the authors studied feasibility of leader election among anonymous agents that
navigate in a network in an asynchronous way.


Feasibility of topology recognition for anonymous networks with adversarial port labelings was studied in~\cite{YK3},
under the assumption that nodes know an upper bound on the size of the network.
The problem of efficiency of map construction by a mobile agent, equipped with a token and exploring an anonymous network,  has
been studied in \cite{CDK}. In \cite{DP}, the authors investigated the minimum size of advice
that has to be given to a mobile agent, in order to enable it to reconstruct  the topology of an anonymous network or to construct its spanning tree.
In \cite{FPR},
tradeoffs between time of topology recognition and the size of advice given to nodes were studied
in the  communication model.  



\section{Preliminaries} \label{sec:feasibility}


In this section we introduce some basic terminology and provide preliminary  results known from the literature. Let  be a simple connected undirected network with the set of nodes , and let  be a positive integer.
Consider any surjective function .
The couple  is called a {\em colored network}, the function  is called a
{\em coloring} of this network, and  is called the {\em color} of node . 



We will use the following notion from \cite{YK3}. Let  be a network and  a node of .  We first define, for any ,  the {\em truncated view}
 at depth , by induction on .  is a tree consisting of a single node . 
If  is defined for any node  in the network, then  is the port-labeled tree
rooted at  and defined as follows.
For every node , , adjacent to , 
there is a child  of  in  such that the port number at  corresponding to edge  is the same as the port number 
at  corresponding to edge ,
and the port number at  corresponding to edge  is the same as the port number at  corresponding to edge .  We say that the node  {\em represents} node .
Now node , for  becomes 
the root of the truncated view .   
 The {\em view} of  is the infinite rooted tree  with labeled ports, such that  is its truncation to depth , for each .

We will also use a notion similar to that of the view but corresponding to colored networks (cf. \cite{Norris}). Consider a colored network . Let  be any node of . 
Let  be the function defined as follows:
, where   is a node of  representing node .
The couple  is called the {\em colored view} of node .
Thus, the colored view of a node additionally marks colors of nodes represented in it.
The couple , where  is the truncation of  to , is called a 
{\em truncated  colored view} of node .

For the (truncated) views of a node  we will often omit the node  in the notation,
thus writing  instead of  and  instead of , if the node , called
the {\em root} of the view, is clear from the context. The same convention applies to 
colored (truncated) views. The \emph{level}  of a view , denoted , is the set of all its nodes at distance  (in ) from the root of the view. For nodes  and  in the truncated view , we denote by  the unique path in  from  to ,
defined as a sequence of nodes in this truncated view. We denote by  the unique path from the root of the view to . For such a path , we denote by  the length of this path,
defined as the number of edges in it. For a truncated view  and a node  in this view,
we denote by  the subtree of   rooted at .


The following proposition was proved in \cite{H}.
\begin{proposition}\label{trunc}
For a -node network of diameter ,
, if and only if ,
for some .
\qed\end{proposition}

The following proposition that follows from \cite{DKP} shows that the truncation level  from Proposition \ref{trunc}
is the smallest possible, up to constant factors.

\begin{proposition}\label{trunc-lower}
For any integers , there exists a network  of size  and diameter , with nodes  and , both with unique views,
such that  but ,
for some .
Moreover, there exists a network  having the same size and diameter as that of , with a node , such that .
 \qed\end{proposition}
 
Propositions \ref{trunc} and \ref{trunc-lower} remain valid, when views are replaced by colored views.

Define the following equivalence relations on the set of nodes of a colored network .
{Let}  if and only if , and {let also}  if and only if .
Let  be the partition of all nodes into equivalence classes of , and  the corresponding partition for  .
It follows from \cite{YK3} that all equivalence classes in  are of equal size . In view of Proposition \ref{trunc}
this is also the case for , for some . On the other hand, for smaller , equivalence classes in  
may be of different sizes.  
Every equivalence class in   is a union of some equivalence classes in  , for .  
The following result was proved in \cite{Norris}. It says that if the sequence of partitions  stops changing at some point, it will never change again. 

\begin{proposition}\label{stop}
If , then .
\qed\end{proposition}

The following proposition, easily proved by induction on , implies that if  for some nodes  and , and all nodes are given the same information about the network, then any algorithm solving  or  in time at most  must give the same output, when executed by  and by .
\begin{proposition} \label{prop:algoView}
Let  be a node in a colored network  and  a node in a colored network .
Suppose that initially all nodes of  and  have the same input.
Let  be a positive integer and assume that .
For any , let  be the message received by  through port  in round .
Then, message  is received by  through port  in round .
\qed
\end{proposition}

Next, we define the notion of a {\em colored quotient graph}, which is a generalization of the
notion of quotient graph introduced in  \cite{YK3}. Given a colored network , its colored quotient
graph  is defined as follows.  Nodes of  are equivalence classes of the above defined relation . If  and  are two such classes, there is an edge joining  and 
in , with port number  at  and  at , if and only if there is an edge joining nodes  and
 in , with port number  at  and  at , where  belongs to the class  and  belongs to the class . (Hence, unlike , the graph  can have self-loops and multiple
edges.) The function  is defined on all nodes of  by the formula
, where  belongs to the class . 

Finally, we give the formal definitions of the main problems  and  considered in this paper. Both these problems are to be solved in an unknown colored graph.
For each of these problems, all nodes are given some common input .
In order to solve the problem , every node has to output a sequence of port numbers leading from this node to a single node, called the leader, if this task is possible to perform using input ;
otherwise, all nodes must output the answer ``unsolvable''. In order to solve the problem , every node  has to output an isomorphic copy  of the underlying graph, with all nodes labeled by distinct identifiers, and the node  correctly marked in ,  if this task is possible to perform using input ;
otherwise, all nodes must output the answer ``unsolvable''.


\section{The algorithm and its analysis}  \label{sec:algorithm}

In this section we describe and analyze an algorithm for solving the problems  and , assuming that some bound  on the size of one of the colors is known.
This color will be denoted by .
Recall that, by definition, there exists at least one node with color  in the network.

The algorithm aims at computing the colored quotient graph.
Once this is achieved, the solutions to  and  will follow easily.
The task of computing the colored quotient graph is divided into three procedures called ,  and .
Procedure  computes the truncated colored view of the executing node up to a certain depth .
This depth  depends on the answers returned by several calls to  in procedure .
Finally, procedure  uses the view and, by further extending it to an appropriate depth, obtains the colored quotient graph.
We now give the detailed description of the above procedures.
They are all formulated for an executing node .
We write  and  instead of  and , respectively.

\medskip
Procedure  uses the following notion of distance between colors and nodes.
Given a truncated colored view  and a node  belonging to it, the \emph{distance from  to color } is the length of the shortest path in  that connects  with some node with color .
Given a view  and a node  belonging to it, we say that  has a \emph{copy in} , , if there exists  in  such that  and  represent the same node of the network.
Additionally, if , then we say that  has a \emph{high copy} in .

Before giving the pseudocode of procedure , we describe its high-level idea.
Given a truncated colored view  and a node  in it as an input, the goal of this procedure is to return  if  has a high copy in .
This is done by exploiting the only tool available to the algorithm: counting nodes in  of color .
Namely, for each node  in , the procedure computes the distance from  to color  in  and then it takes the maximum over all such distances, denoted by .
If no node with the color  is observed in , then  is set to  which results in  and the procedure returns .
As proven below (cf. Lemma~\ref{lem:test:bound}) checking whether the distance from the root to  in  is at least  is sufficient for procedure  to return .
Note that there exist networks such that  is smaller than  but  still has a high copy in .
However, in such cases the procedure  is unable to certify that and, thanks to later calls to  in our algorithm, several descendants of  will be recognized to have high copies.





\begin{algorithm} \caption{}
\begin{algorithmic}
\REQUIRE Truncated colored view , , a node  in .
\ENSURE  or .

\FORALL{ in }
   \STATE  distance from  to color  in ;
   \STATE (Possibly  if  does not appear in .)
\ENDFOR
\STATE 
\IF{  }
   \RETURN 
\ELSE
   \RETURN 
\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{lemma} \label{lem:test:bound}
Let  be an upper bound on the size of the color  in the network {and let  be a node in the network}.
Let  be the maximum distance from a node  to color  in  taken over all nodes  in .
If , then  has a high copy in .
\end{lemma}

\begin{proof}
Find an ancestor  of  in  such that the length of the path from the root to  is exactly .
Let  be such nodes in the path  that  is at distance  from the root.
Note that .
For each , let  be a node with color  at distance at most  from  in .
Such a node  exists by definition of  and by the fact that , {for any} .
The latter follows from .

Since the size of color  is at most , there exist , , such that  and  represent the same node of the network.
Consider the sequence of ports that is a concatenation of the sequences of ports of the following paths:  and .
This sequence of ports gives a valid path from the root to some node  in the colored view , since  and  represent the same node of the network.
We bound the length  of  as follows.
Note that the first part of  of length  equals .
Thus, the length of this first part is at most

The length of the second part, i.e., the length of  is {at most}

Therefore, since , we obtain

Thus,  belongs to , or in other words, the node  that belongs to level  of  has a high copy in .
Since either  or  is an ancestor of , we obtain that  has a high copy in , as required.
\end{proof}

\begin{corollary} \label{cor:test:bound}
Consider a truncated colored view  and a node  in this view.
If procedure  returns  for input  and , then  has a high copy in .
\qed
\end{corollary}

We have proved that if procedure  returns , then this guarantees that the input node  has a high copy.
However, for the correctness of our final algorithm we need to ensure that each infinite simple path in  originating from the root contains a node  that has a high copy, and that this fact will be detected by procedure .
Moreover, in order to bound the time of our final algorithm, we need to estimate the distance from such  to the root, which is done in the next lemma.
\begin{lemma} \label{lem:test:finite}
Let  be a truncated colored view and let  be a node in it.
If  and  belongs to level  of , then procedure  executed for  and  returns .
\end{lemma}
\begin{proof}
For each node  of the path , the node of the network represented by it is at distance at most  (in the network) from some node with color .
This implies that  for each such node .
Thus, .
We obtain that

which implies that procedure  returns true.
\end{proof}




\medskip
Before describing the next procedure, we introduce some more notation.
A truncated colored view  \emph{covers the network} if, for each node  of the network, there exists a node  of  such that  represents .
We define procedure  which sends the currently acquired truncated colored view  to all neighbors and receives the messages containing currently acquired colored views of the same depth  from all neighbors.
Note that after all nodes have performed   times, each node can compute its truncated colored view .

We now describe procedure .
Again, we start with an informal description.
In each iteration, the `while' loop increments the depth of the view currently stored at the executing node.
This is done by communicating with each neighbor.
The crucial part is to decide when to stop.
At some point, procedure  detects that the currently possessed truncated colored view  covers the network and this view is then returned.
The above is achieved (see Lemma~\ref{lem:covered} below for a proof) by maintaining a set , that is initially empty, consisting of nodes having high copies.
Procedure  stops when each leaf of  is in , which guarantees that  covers the network, as required.
\begin{algorithm} \caption{}
\begin{algorithmic}
\REQUIRE None.
\ENSURE Truncated colored view .

\STATE 
\STATE 
\WHILE{there exists a leaf in  that is not in }
   \FORALL{ in }
      \IF{ returns }
         \STATE Add to  the node  and all its descendants in .
      \ENDIF
   \ENDFOR
   \STATE ~ \COMMENT{This extends  to .}
   \STATE 
\ENDWHILE
\RETURN 
\end{algorithmic}
\end{algorithm}

\begin{lemma} \label{lem:covered}
Procedure  returns the truncated colored view  of the executing node, such that  covers the network and .
\end{lemma}
\begin{proof}
Lemma~\ref{lem:test:finite} implies that there exists  such that all leaves of  are in  and hence the number of iterations of the `while' loop of procedure  is at most .
The latter relies on the fact that if a node having a high copy is detected by procedure , then procedure  adds to  this node with all its descendants in the current truncated view.

Consider the view  of the executing node, and let  be any node in .
We argue that  has a copy in .
Suppose for a contradiction that this is not the case and select  to be a node that does not have a copy in  and is closest to the root in .
Let  be the level of  in .
(Clearly .)
Since , there exists an ancestor  of  such that , , and procedure  returns  when executed for  and .
By Corollary~\ref{cor:test:bound},  has a copy  in .
Thus,  has a copy  in .
But then, by the minimality of ,  has a copy in , which is also a copy of .
This is a contradiction because, by definition,  and  represent the same node of the network.
\end{proof}



\medskip
Procedure  computes the colored quotient graph  of the network, provided that a colored view  that covers the network is given as an input.
This is done by finding the minimum index  such that .
Note that this requires that each node learn its colored view till depth , by exchanging messages with its neighbors.
\begin{algorithm} \caption{}
\label{alg:ComputeQuotientGraph}
\begin{algorithmic}
\REQUIRE Truncated colored view , .
\ENSURE  The colored quotient graph .

\STATE 
\STATE 
\STATE 
\WHILE{}
   \STATE 
   \STATE 
   \STATE Compute 
\ENDWHILE
\STATE Compute the labeled quotient graph  using  and 
\RETURN 
\end{algorithmic}
\end{algorithm}

We prove the following.
\begin{lemma} \label{lem:computeQG}
Let  be the truncated colored view  computed by procedure .\\
Procedure  called for  correctly computes the colored quotient graph of the network.
\end{lemma}
\begin{proof}
By Lemma~\ref{lem:covered},  covers the network.
Thus,  contains all nodes of the network.
By Proposition~\ref{stop}, the partition  obtained in the last iteration of the `while' loop of procedure  equals .
Hence, this partition  is the set of all nodes of the colored quotient graph.
This implies that the quotient graph can be computed on the basis of  and  as follows.
The color of a node of the quotient graph is set to the color of its elements in the truncated colored view.
The edges and port numbers are added as in the definition of the quotient graph.
\end{proof}


In the formulation of our main algorithm we will use the following integer that each node can compute once it has the colored quotient graph .
For any node  of the quotient graph, let  be the sum of running times of procedures  and , where  is computed by .
Let  be the maximum of  over all nodes  of the quotient graph.

We are ready to state our main algorithm for solving the problems  and .
We formulate it as a single procedure, since all steps leading to the computation of the colored quotient graph are identical in both cases.

\floatname{algorithm}{Algorithm}
\begin{algorithm} \caption{}
\begin{algorithmic}
\REQUIRE An upper bound  on the size of color .
\ENSURE  For  --- a sequence of port numbers leading from the executing node to the leader, or , if leader election is impossible.
         For  --- the topology of the network, or , if topology recognition is impossible.

\STATE 
\STATE 
\STATE Perform   times.
\IF{the number of nodes with color  in  is at most  and  is not a tree}
   \RETURN 
\ELSE
   \STATE For  --- return a sequence of port numbers of the path , where  (which is the leader) corresponds to the node of  whose colored view is lexicographically smallest (if the executing node is the leader, then the path is empty).
   \STATE For  --- return .
\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{theorem} \label{thm:main}
If a bound  on the size of a given color  is provided as an input, then Algorithm  correctly solves problems  and  in time , where  is the size of the network and  is its diameter.
\end{theorem}
\begin{proof}
First note that Algorithm  correctly computes the colored quotient graph.
Indeed, by Lemma~\ref{lem:computeQG}, Algorithm  obtains the colored quotient graph  as a result of the call to procedure .
This is ensured by the fact that each node performs at least  calls to  and therefore every node  can compute , which is enough to compute the colored quotient graph, by definition of .

Once the colored quotient graph is computed by all nodes of the network, the correctness of Algorithm  essentially follows from \cite{YK3}.
For completeness we include the short argument.

Assume that the colored quotient graph has at most  nodes with color  and it is not a tree (i.e., a graph {that has} cycles, multiple edges or self-loops).
Then, topology recognition cannot be solved since there exist two non-isomorphic networks of size  having  as a quotient graph.
Any potential topology recognition algorithm in these networks must have the same execution for each pair of nodes with the same colored views and thus such an algorithm must be incorrect.
Hence, Algorithm  correctly returns  for the problem .
For the problem of leader election, take any network of size  having  as a quotient graph.
Two distinct nodes  and  in this network have the same colored view.
Thus, any potential leader election algorithm incorrectly elects at least two leaders in this network.
Hence, Algorithm  correctly returns  for the problem  as well.


Otherwise, i.e., if the colored quotient graph has more than  nodes with color  or it is a tree, then the network is isomorphic to  and hence Algorithm  gives a correct solution to the problem .
As for leader election, each node has a unique colored view under this assumption.
Hence, the node with the lexicographically smallest colored view is unambiguously elected as the leader by each node.

It remains to bound the time of computation.
It is at most , where  and  are the numbers of iterations of the `while' loop of procedure  and , respectively.
By Lemma~\ref{lem:test:finite} and the formulation of procedure , .
By Proposition~\ref{trunc}, .
Thus, by definition, , which completes the proof.
\end{proof}


\begin{corollary} \label{cor:main}
Let  be a colored network and let  be a bound on the size of color .
If all nodes of  have pairwise different colored views and the size of color  is strictly greater than , then topology recognition and leader election are possible in .
\qed
\end{corollary}


\section{Negative results}

In this section we present our negative results. The first of them {is an impossibility result indicating} that if no upper bound on the size of any color is given to nodes, then problems  and  must have answer ``unsolvable'', even if other restrictions on the possible sizes of colors are known. In order to express this result in full generality, we formalize such possible restrictions as a set , where  denotes the set of positive integers and  is the number of colors.
We translate the property that no upper bound on the size of any color is known, to the statement
that for any point  there exists a point   in the restriction set , such that , for all .
Such a set  will be called \emph{unbounded}.
(An example of an input defining an unbounded restriction set is: there are three colors and the sizes of all of them are prime integers.)
To make the impossibility result even stronger, we prove that it holds even for a very simple class of networks: on rings. 

\begin{proposition}
Let  be any colored ring.
Consider an input  defining an unbounded restriction set .
Then, problems  and  must have answer ``unsolvable''.
\end{proposition}
\begin{proof}
Take any algorithm, call it , that correctly solves problem  or problem  in any colored ring under input .
Let  be the number of different colors that appear in the network, and let  be the size of color , .
Denote the nodes of  by , where  and  is adjacent to , for each .
\begin{figure}[htb]
\begin{center}
\includegraphics[scale=0.9]{fig-ring.pdf}
\caption{(a) an example of a ring  obtained from , ; (b) the corresponding ring  constructed for  and , .}
\label{fig:ring}
\end{center}
\end{figure}

Let  be any node of .
Let  be the time after which  produces the answer.
Since the restriction set  is unbounded, there exists  such that  for each .
We construct a colored ring  on  nodes  such that:
\begin{itemize}
 \item  is adjacent to , ,
 \item the port numbers of the edge  at  and  are equal to the port numbers of the edge  at  and , respectively, , in ,
 \item the port numbers of the remaining edges are set arbitrarily in a way that guarantees proper port labeling.
\end{itemize}
Moreover, the colors are assigned to the nodes of  as follows:

and the remaining nodes, i.e., the ones in , receive colors in any way that ensures that the size of color  in  is .
See Figure~\ref{fig:ring} for an example of the construction of .
The colored view of depth  of  in  is the same as the colored views of depth  of  and of  in  because .

Consider the problem .
If the answer produced by  in  is ``unsolvable'', then the lemma follows.
Hence, we may assume that  returns the topology of .
By Proposition \ref{prop:algoView}, the algorithm  executed by  in  stops after time  and produces the same answer as for  in .
Thus,  must also return the topology of  when executed by  in .
Since  and  are of different sizes, we obtain a contradiction, as required.

Next consider the problem .
If the answer produced by  in  is ``unsolvable'', then the lemma follows.
Hence, we may assume that  elects a leader in .
By Proposition \ref{prop:algoView}, the algorithm  executed by  and  in  stops after time  and produces the same answer as in .
Thus, these two nodes elect different leaders --- a contradiction.
\end{proof}


We next turn attention to the issue of time needed to solve problems  and , assuming that an upper bound  on the size of some color is given to all nodes.  We give a lower bound showing that the time
 of our algorithm is optimal.
We first construct a class of networks, for which
time  cannot be improved.

 
\begin{proposition}\label{first-lb}
Let  be arbitrary positive integers.
There exists a network of size  and diameter , whose nodes, if they are given as input an upper bound  on the size of one color  and have no other information on the network, need time   to solve the problems  and .
\end{proposition}
\begin{proof}
For any  and , we define a -node graph  (called a chordal ring).
Denote by  the nodes of .
For each  and , let  be an edge of , where the port number of this edge at  is  and the port number at  is .
Note that the diameter of  is .

Since our result {holds asymptotically}, we may assume that  and .
Consider an algorithm  for solving problem  or  in any network.
Let .
(Note that  implies , as required in the construction of .)
Let  be any node of .
Let  be the colored network in which , and all other nodes of  have the same color , different from .
Note that the diameter of  is .
We run the algorithm  in the colored network .
We argue that  should run for time .
Suppose for a contradiction that  stops and produces an answer in round .

Consider the network  on the set of nodes .
Construct a network  by adding a pendant edge to the node  of , i.e., add an extra node of degree  and attach it to .
Let .
Let  be a colored network in which  for each , while all other nodes of this network have color .
By construction of , the distance between  and  in  is greater than .
Thus, the truncated colored view  in  is the same as the truncated colored view  in .
Now, we run  in the colored network .

Suppose that  is an algorithm solving the problem .
By Proposition \ref{prop:algoView},  executed on  and  produces the same answer to problem  in  and , respectively.
If the answer on  is the topology of , then we immediately have a contradiction since the two networks are not isomorphic.
On the other hand, if the answer is ``unsolvable'', then this answer is incorrect for .
The latter is due to Corollary \ref{cor:main}.

Let now  be an algorithm solving the problem .
Let .
The distance from  to  in  is at least  for .
Thus, .
By Proposition \ref{prop:algoView},  produces the same output at  and  after time .
By Corollary \ref{cor:main}, the algorithm  cannot output ``unsolvable'' because all nodes of  have unique views and the size of color  is  in .
Thus,  and  elect different leaders --- a contradiction.
\end{proof}

The other part of our lower bound follows from \cite{DKP}.
\begin{proposition}\label{second-lb}
Let  be arbitrary positive integers. There exists a network of size 
 and diameter , whose nodes need time at least  to solve problems  and , even if all nodes have the same color and they are given the size and the diameter of the 
 network.
\end{proposition}
\begin{proof}
By Proposition \ref{trunc-lower}, there exists a network  of size  and diameter , with nodes  and , both with unique views,
such that  but , for some .
Thus, by Proposition \ref{prop:algoView}, any algorithm  that stops after at most  steps and produces an answer to problem , gives the same answer at  and .
Thus, this answer must be ``unsolvable''.
(Otherwise, two distinct leaders would be elected.)
However, since the nodes of  have pairwise different views and the size of the network is known, Corollary~\ref{cor:main} implies that leader election is possible in this network.
Thus, any algorithm solving problem  needs time  in .


Now consider the problem  and let  be any algorithm solving this problem.
Suppose for a contradiction that  stops after at most  steps. 
By Proposition~\ref{trunc-lower}, there exists a network , different than , with the same size and diameter as , with a node , such that .
Thus, by Proposition~\ref{prop:algoView},  returns the same answer at  and .
Since  and  are different, this answer must be ``unsolvable''.
Since all nodes in  have pairwise different views, by Proposition~\ref{prop:algoView} (where  is {taken} to be the size of ),  is possible in  --- a contradiction.
\end{proof}

Theorem \ref{thm:main}, together with Propositions \ref{first-lb} and \ref{second-lb}, imply the following corollary showing that our algorithm is time-optimal.

\begin{corollary}
The optimal time to solve problems  and  on -node networks with diameter ,
assuming that nodes know only an upper bound  on the size of a given color, is .  
\end{corollary} 

\section{Conclusion}

We showed that nodes of a colored network can solve problems  and , if they are given an upper bound on the number of nodes of a given color, and we studied the time
of solving these problems in the   model, under this assumption. 

Notice that the synchronous behavior of the   model can be easily reproduced in an asynchronous network, by defining, for each node  separately, an asynchronous round  consisting of the following actions of this node: node  performs local computations, then sends messages stamped with integer  to all its neighbors, and waits for messages stamped  from all neighbors.
In order to implement this, every node must send a message with all consecutive stamps, until termination, some of the messages possibly empty.
Our results concerning time of solving problems  and  can be translated for asynchronous networks by replacing ``the number of rounds''  by ``the maximum number of asynchronous rounds, over all nodes''.

Let  be the diameter of the network.
If nodes have distinct labels, then time  in the   model is enough to solve any problem solvable on a given network, as after this time all nodes solve topology recognition.
By contrast, in our scenario of colored nodes, time  is often not enough, for example to elect a leader, or to perform topology recognition, even if these tasks are feasible.
This is due to the fact that after time  each node may learn only all colored paths of length  originating at it.
Acquiring this information does not imply getting a picture of the radius  colored neighborhood of the node.
This is because a node  may not know if two paths originating at it have the same other endpoint or not.
We showed that these ambiguities may force time much larger than  to solve problems  and .

As it is always assumed in the  model, we allowed arbitrarily large messages to be sent in each round. Bounding the size of messages to logarithmic in the size of the network, as
it is assumed in the alternative  model, would likely have an important impact on the time of solving problems  and . Hence an interesting open question is
to establish the best time of solving these problems in the latter model.


\bibliographystyle{plain}
\begin{thebibliography}{99}

\bibitem{An}
D.~Angluin, Local and Global Properties in Networks of Processors,
{\em Proc. 12th Annual ACM Symposium on Theory of Computing} (STOC 1980), 82--93.

\bibitem{ABDKPR}
H. Attiya, A. Bar-Noy, D. Dolev, D. Koller, D. Peleg, R. Reischuk,
Renaming in an Asynchronous Environment, {\em Journal of the ACM} 37 (1990), 524--548.

\bibitem{ASW}
H. Attiya, M. Snir, M. Warmuth,
Computing on an Anonymous Ring,
{\em Journal of the ACM} 35 (1988), 845-875.

\bibitem{AtSn}
H. Attiya, M. Snir,
Better Computing on the Anonymous Ring,
{\em Journal of Algorithms} 12 (1991), 204-238.

\bibitem{A}
B. Awerbuch, Optimal Distributed Algorithms for Minimum Weight Spanning Tree, 
Counting, Leader Election and Related Problems,
{\em Proc. 19th Annual ACM Symposium on Theory of Computing} (STOC 1987), 230-240.

\bibitem{AGPV}
B. Awerbuch, O. Goldreich, D. Peleg, R. Vainish,
A Trade-Off between Information and Communication in Broadcast Protocols,
{\em J. {ACM}} 37 (1990), 238-256.

\bibitem{BSVCGS}
P. Boldi, S. Shammah, S. Vigna, B. Codenotti, P. Gemmell, J. Simon,
Symmetry Breaking in Anonymous Networks: Characterizations,
{\em Proc. 4th Israel Symposium on Theory of Computing and Systems} (ISTCS 1996), 16-26.

\bibitem{BV}
P. Boldi, S. Vigna,
Computing Anonymously with Arbitrary Knowledge,
{\em Proc. 18th ACM Symp. on Principles of Distributed Computing} (PODC 1999), 181-188.

\bibitem{B}
J.E. Burns, A Formal Model for Message Passing Systems,
{\em Tech. Report TR-91}, Computer Science Department,
Indiana University, Bloomington, September 1980.

\bibitem{C}
J. Chalopin,
Local Computations on Closed Unlabelled Edges: The Election Problem and the Naming Problem,
{\em Proc. 31st Conference on Current Trends in Theory and Practice of Computer Science} (SOFSEM 2005), 82-91.

\bibitem{CDK}
J. Chalopin, S. Das, A. Kosowski, 
Constructing a Map of an Anonymous Graph: Applications of Universal Sequences,
{\em Proc. 14th International Conference on Principles of Distributed Systems} (OPODIS 2010), 119-134.

\bibitem{CMM}
J. Chalopin, A.W. Mazurkiewicz, Y. M\'etivier, Labelled (Hyper)Graphs, Negotiations and the Naming Problem,
{\em Proc. 4th International Conference on Graph Transformations} (ICGT 2008), 54-68.

\bibitem{CM}
J. Chalopin, Y. M\'etivier,
Election and Local Computations on Edges,
{\em Proc. Foundations of Software Science and Computation Structures} (FoSSaCS 2004), 90-104.

\bibitem{DKP}
D. Dereniowski, A. Kosowski, D. Pajak, Distinguishing Views in Symmetric Networks: A Tight Lower Bound,
{\em Theoretical Computer Science} 582 (2015) 27-34.

\bibitem{DP}
D. Dereniowski, A. Pelc, Drawing Maps with Advice,  {\em Journal of Parallel and Distributed Computing} 72 (2012), 132-143. 

\bibitem{DP1}
D. Dereniowski, A. Pelc, Leader Election for Anonymous Asynchronous Agents in Arbitrary Networks, {\em Distributed Computing} 27 (2014), 21-38. 

\bibitem{DKMP}
K. Diks, E. Kranakis A. Malinowski, A. Pelc,
Anonymous Wireless Rings,
{\em Theoretical Computer Science} 145 (1995), 95-109.

\bibitem{DoPe}
S. Dobrev, A. Pelc, 
Leader Election in Rings with Nonunique Labels, {\em Fundamenta Informaticae} 59 (2004), 333-347. 

\bibitem{FKKLS}
P. Flocchini, E. Kranakis, D. Krizanc, F.L. Luccio, N. Santoro,
Sorting and Election in Anonymous Asynchronous Rings,
{\em Journal of Parallel and Distributed Computing} 64 (2004), 254-265.

\bibitem{FL}
G.N. Fredrickson, N.A. Lynch,
Electing a Leader in a Synchronous Ring,
{\em Journal of the ACM} 34 (1987), 98-115.

\bibitem{FP}
E. Fusco, A. Pelc, How Much Memory is Needed for Leader Election, {\em Distributed Computing} 24 (2011), 65-78. 

\bibitem{FP1}
E. Fusco, A. Pelc, Knowledge, Level of Symmetry, and Time of Leader Election,
{\em Proc. 20th Annual European Symposium on Algorithms} (ESA 2012), LNCS 7501, 479-490. 

\bibitem{FPR}
E. Fusco, A. Pelc, R. Petreschi, Use Knowledge to Learn Faster: Topology Recognition with Advice,
{\em Proc. 27th International Symposium on Distributed Computing} (DISC 2013), LNCS 8205, 31-45. 

\bibitem{GMP}
C. Glacet, A. Miller, A. Pelc, Time vs. information tradeoffs for leader election in anonymous trees, Proc. 27th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA 2016), 600-609.




\bibitem{HKMMJ}
M.A. Haddar, A.H. Kacem, Y. M\'{e}tivier, M. Mosbah, M. Jmaiel, Electing a Leader in the Local Computation Model using Mobile Agents,
{\em Proc.  6th ACS/IEEE International Conference on Computer Systems and Applications} (AICCSA 2008), 473-480.

\bibitem{H}
J. Hendrickx, Views in a Graph: To Which Depth Must Equality Be Checked?,
{\em IEEE Transactions on Parallel and Distributed Systems} 25 (2014) 1907-1912.


\bibitem{HS}
D.S. Hirschberg, J.B. Sinclair,
Decentralized Extrema-Finding in Circular Configurations of Processes,
{\em Communications of the ACM} 23 (1980), 627-628.

\bibitem{JKZ}
T. Jurdzinski, M. Kutylowski, J. Zatopianski, 
Efficient Algorithms for Leader Election in~Radio Networks,
 {\em Proc., 21st ACM Symp. on Principles of Distributed Computing} (PODC 2002), 51-57.

\bibitem{KP}
D. Kowalski, A. Pelc, Leader Election in Ad Hoc Radio Networks: A Keen Ear Helps, 
{\em Proc. 36th International Colloquium on Automata, Languages and Programming} (ICALP 2009), LNCS 5556, 521-533. 


\bibitem{Kr}
E. Kranakis,
Symmetry and Computability in Anonymous Networks: A Brief Survey,
{\em Proc. 3rd Int. Conf. on Structural Information and Communication Complexity}, (1997), 1-16.

\bibitem{KKV}
E. Kranakis, D. Krizanc, J. van der Berg,
Computing Boolean Functions on Anonymous Networks,
{\em Information and Computation} 114 (1994), 214-236.

\bibitem{LL}
G. Le Lann,
Distributed Systems - Towards a Formal Approach,
{\em Proc. IFIP Congress}, North Holland, (1977), 155-160.

\bibitem{Ly}
N.A. Lynch, 
Distributed Algorithms,
Morgan Kaufmann Publ., Inc., 1996.


\bibitem{MP}
A. Miller, A. Pelc: Election vs. selection: Two ways of finding the largest node in a graph,
CoRR abs/1411.1319 (2014).

\bibitem{NO}
K. Nakano, S. Olariu, Uniform Leader Election Protocols for Radio Networks,
{\em IEEE Transactions on Parallel and Distributed Systems} 13
(2002), 516-526.

\bibitem{Norris}
N. Norris, Universal Covers of Graphs: Isomorphism to Depth  Implies Isomorphism to All Depths,
{\em Discrete Applied Mathematics} 56 (1995), 61-74.
               
\bibitem{Pe}D. Peleg,
Distributed Computing, A Locality-Sensitive Approach,
SIAM Monographs on Discrete Mathematics and Applications, Philadelphia 2000.

\bibitem{P}
G.L. Peterson, An  Unidirectional Distributed Algorithm for the Circular Extrema Problem,
{\em ACM Transactions on Programming Languages and Systems} 4 (1982), 758-762.

\bibitem{Saka}
N. Sakamoto,
Comparison of Initial Conditions for Distributed Algorithms
on Anonymous  Networks,
{\em Proc. 18th ACM Symp. on Principles of Distributed Computing} (PODC 1999), 173-179.

\bibitem{Wil}
D.E. Willard, 
Log-logarithmic Selection Resolution Protocols in a Multiple Access Channel,
{\em SIAM J. on Computing} 15 (1986), 468-477. 

\bibitem{YK}
M. Yamashita, T. Kameda,
Computing on Anonymous Networks,
{\em Proc. 7th ACM Symp. on Principles of Distributed Computing} (PODC 1988), 117-130.

\bibitem{YK2}
M. Yamashita, T. Kameda,
Electing a Leader when Procesor Identity Numbers are not Distinct,
{\em Proc. 3rd Workshop on Distributed Algorithms} (WDAG 1989), LNCS 392, 303-314.

\bibitem{YK3}
M. Yamashita and T. Kameda,
Computing on Anonymous Networks: Part I - Characterizing the Solvable Cases,
{\em IEEE Trans. Parallel and Distributed Systems} 7 (1996), 69-89. 

\end{thebibliography}

\end{document}
