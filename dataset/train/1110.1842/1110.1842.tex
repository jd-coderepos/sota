

\documentclass[10pt, conference, compsocconf]{IEEEtran}
\usepackage{epic,eepic,amsmath,latexsym,amssymb,color}
\usepackage{ifthen,graphics,epsfig}
\usepackage[english]{babel}
\usepackage{times}
\usepackage{amssymb,amsthm,amscd}
\usepackage{graphicx}

\bibliographystyle{plain}





\usepackage{times}
\usepackage{amssymb}
\usepackage{listings}

\newtheorem{definition}{Definition}
\newtheorem{property}{Property}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}  
\newtheorem{observation}{Observation}  
\newcommand{\toto}{xxx}
\newenvironment{proofT}{\noindent{\bf
Proof }} {\hspace*{\fill}\par\vspace{3mm}}
\newenvironment{proofL}{\noindent{\bf
Proof }} {\hspace*{\fill}\par\vspace{3mm}}
\newenvironment{proofC}{\noindent{\bf
Proof }} {\hspace*{\fill}\par\vspace{3mm}}



\newenvironment{packed_itemize}{
\begin{itemize}
   \setlength{\itemsep}{1pt}
   \setlength{\parskip}{0pt}
   \setlength{\parsep}{0pt}
}{\end{itemize}}

\newenvironment{packed_description}{
\begin{description}
   \setlength{\itemsep}{1pt}
   \setlength{\parskip}{0pt}
   \setlength{\parsep}{0pt}
}{\end{description}}

\newcommand{\tightparagraph}[1]{\smallskip \noindent \textbf{#1} \hspace{1ex}}



\newcounter{linecounter}
\newcommand{\linenumbering}{\ifthenelse{\value{linecounter}<10}{(0\arabic{linecounter})}{(\arabic{linecounter})}}
\newcommand{\ligne}[1]{\refstepcounter{linecounter}\label{#1}\linenumbering}
\newcommand{\resetligne}[1]{\setcounter{linecounter}{0}#1}
\renewcommand{\thelinecounter}{\ifnum \value{linecounter} > 9\else 0\fi \arabic{linecounter}}


\lstset{
numbers=left,
numbersep=4pt,
columns=fullflexible,
tabsize=2,
basicstyle=\footnotesize,
identifierstyle=\rmfamily, mathescape=true,
morekeywords={Init,procedure,let,send,until,foreach,for, exit, loop,each,repeat,stop,while,forever,every,time,start,and,function,init,upon,do,if,then,else,return,starts,task,Task,reception,for_each,expiration,invocation,round,end,module,delete,wait,halt},
literate={:=}{{ }}1 {->}{{}}1 {<=}{{}}1
}
\lstset{escapeinside={('}{')}}

\newcommand{\OO}{{\Omega}}
\newcommand{\HO}{{H\Omega}}
\newcommand{\MO}{{M\Omega}}
\newcommand{\AO}{{A\Omega}}
\newcommand{\HS}{{H\Sigma}}
\newcommand{\AS}{{A\Sigma}}
\newcommand{\HP}{{ \Diamond H\overline{P}}}
\newcommand{\AP}{{ \mathit{AP}}}
\newcommand{\NAP}{{ \overline{\mathit{AP}}}}
\newcommand{\C}{{\mathit{Correct}}}
\newcommand{\trusted}{{\mathit{h\_trusted}}}
\newcommand{\leader}{{\mathit{h\_leader}}}
\newcommand{\mleader}{{\mathit{m\_leader}}}
\newcommand{\multiplicity}{{\mathit{h\_multiplicity}}}
\newcommand{\cardinality}{{\mathit{m\_cardinality}}}
\newcommand{\quora}{{\mathit{h\_quora}}}
\newcommand{\labels}{{\mathit{h\_labels}}}

\newcommand{\tup}[1]{\langle{#1} \rangle}



{\title{\bf  Failure Detectors in Homonymous Distributed Systems\\ 
(with an Application to Consensus)}}
\vspace{-0.5cm}
{\author{
           Sergio   {\sc Ar\'evalo} 
           ~ Antonio  {\sc Fern\'andez Anta} 
           ~ Damien   {\sc Imbs} \\
           ~ Ernesto  {\sc Jim\'enez}
           ~ Michel   {\sc Raynal} \\~\\
 EUI, Universidad Polit\'ecnica de Madrid, 28031 Madrid, Spain\\
 Institute IMDEA Networks, 28918 Madrid, Spain\\
  Institut Universitaire de France\\
 IRISA, Campus de Beaulieu, 35042 Rennes Cedex, France \\
}
}
\date{}

\begin{document}

\maketitle  


\vspace{-0.5cm}
\begin{abstract}
This paper is on homonymous  distributed 
systems where processes are prone to crash failures and have no initial 
knowledge of the  system membership (``homonymous'' means that several 
processes  may have the same identifier).  
New classes of failure detectors suited to these systems are first defined.
Among them,  the classes  and  are introduced 
that are the homonymous counterparts of the classes  and  , 
respectively. (Recall that the pair  
defines the weakest failure detector to solve consensus.)
Then, the paper  shows how  and  can be implemented in homonymous 
systems without membership knowledge (under different synchrony 
requirements). Finally,  two algorithms are presented that use these 
failure detectors to solve consensus in homonymous asynchronous systems
where there is no initial knowledge of the membership. One algorithm 
solves consensus with , while the other 
uses only , but needs a majority of correct processes. 

Observe that the systems with unique identifiers and anonymous 
systems are extreme cases of homonymous systems from which follows that
 all these results also apply to these systems.  Interestingly, the new
failure detector class  can be implemented with partial synchrony, 
while the analogous class  defined for anonymous systems 
can not be implemented (even in synchronous systems). Hence, the paper
provides us with the first proof showing that consensus can be solved in 
anonymous systems with only partial synchrony 
(and a majority of correct processes).
\end{abstract}
\begin{IEEEkeywords}
Agreement problem, Asynchrony, Consensus,  Distributed computability, 
failure detector, Homonymous system, 
Message-passing, Process crash.  
\end{IEEEkeywords}


\section{Introduction}

\tightparagraph{Homonymous systems}
Distributed computing is on mastering uncertainty created by adversaries. 
The  first  adversary  is  of  course  the fact  that  the  processes are
geographically distributed which makes impossible to instantaneously obtain a
global state of the system. An  adversary can be static (e.g., synchrony 
or anonymity) or dynamic (e.g., asynchrony, mobility, etc.).  The  net 
effect of asynchrony and failures is the  most studied pair of adversaries.  
 
This paper is on agreement in  crash-prone  message-passing  distributed
systems. While  this topic  has been deeply  investigated in  the past
in the context of asynchrony and process failures 
(e.g., \cite{L96,R10}), we additionally consider here that 
several  processes can have  the  same identity,  i.e.,  the  
additional static adversary  that is {\it homonymy}. 
A motivation for homonymous processes in distributed 
systems can be found in \cite{DFGKRT11} where, for example, 
users keep their privacy taking their domain as their identifier 
(the same identifier is then
assigned to all the users of the same domain). Observe that 
homonymy is a generalization
of two cases: (1) having unique identifiers and 
(2) having the same identifier for all the processes (anonymity), 
which are the two extremes of homonymy.


We also assume  that the distributed system has to face
another static adversary, which is the fact that, initially, 
each process only 
knows its own identity. We say that the system has to work 
\emph{without initial knowledge of the membership}. 
This static adversary has been recently identified 
as of significant relevance in certain distributed contexts
\cite{DBLP:journals/ipl/JimenezAF06}.


\tightparagraph{How to face adversaries}
It is well-known that lots of problems cannot be solved in 
presence of some adversaries 
(e.g., \cite{DBLP:conf/stoc/Angluin80,DBLP:journals/jacm/AttiyaSW88,
DBLP:journals/jacm/FischerLP85,DBLP:journals/tpds/YamashitaK96}). 
When  considering  process  crash  failures,  the  
{\it  failure  detector} approach introduced in 
\cite{DBLP:journals/jacm/ChandraHT96,DBLP:journals/jacm/ChandraT96} 
(see  \cite{R09}   for an 
introductory presentation) has  proved to be very attractive.  
It allows to enrich an otherwise too poor distributed  system 
to solve a given problem ,  in order to obtain a more powerful system 
in which  can be solved. 

A failure detector is a  distributed oracle  that provides processes with
additional information related to  failed processes, and can consequently be
used to enrich the computability power of asynchronous  send/receive 
message-passing systems.
According to the  type (set  of process  identities, integers,
etc.) and  the quality  of  this  information,  several failure  detector
classes have been proposed. 
We refer the reader to  \cite{R10} where classes of 
failure detectors  suited to  agreement and communication
problems, corresponding failure detector-based algorithms, and 
additional behavioral assumptions that (when satisfied) allow 
these failure detectors to be implemented are presented.
It is interesting to observe that none of the original failure detectors
introduced in \cite{DBLP:journals/jacm/ChandraT96} can be implemented
without initial knowledge of the 
membership \cite{DBLP:journals/ipl/JimenezAF06}.


\tightparagraph{Aim of the paper}
Agreement problems are  central as soon as one wants  to capture the essence
of distributed computing. (If processes do not have to agree in one way
or another,  the problem we  have to solve  is not a  distributed computing
problem!)  
The  aim  of  this  paper   is  consequently  to  understand  the  type  of
information  on failures   that  is needed  when   one has    to solve   an
agreement  problem in  presence of asynchrony, process crashes,  
homonymy, and lack of initial knowledge of the membership. 
As consensus is the most central agreement problem we focus on it. 



\tightparagraph{Related work}
As far as we know, consensus in anonymous networks has been addressed 
first in~\cite{DBLP:conf/wdag/BonnetR09,DFT09} 
(\cite{DFT09} considers different synchrony assumptions while 
\cite{DBLP:conf/wdag/BonnetR09} considers systems enriched with
failure detectors). Connectivity requirements for agreement 
in anonymous networks is addressed in~\cite{GT07}. 


To the best of  our knowledge, up to now agreement  in  homonymous systems 
has been addressed  only  in \cite{DFGKRT11} and \cite{janus-opodis2011}.
In the former paper the  authors consider
that,  among the   processes,  up to   of  them can  commit Byzantine
failures.  The system is homonymous in the sense that there are , 
,  different authenticated identities,  each process 
has one identity, and several processes can share the same identity. 
It is  shown in that paper that    and   
are   necessary and sufficient conditions for solving consensus in synchronous 
systems and  partially synchronous systems, respectively.
The latter paper \cite{janus-opodis2011} mainly explores consensus
in a shared memory system with anonymous processes, and bounds
the complexity (namely, individual write and step complexities) of
solving consensus with the aid of an anonymous leader elector  
(see below).
They show that if the system is homonymous instead of purely anonymous
these bounds can be improved.

The consensus problem in anonymous asynchronous crash-prone message-passing 
systems  has been  recently addressed  in \cite{DBLP:conf/wdag/BonnetR09} 
(for the first time to our knowledge).  
In such systems, processes have no identity at 
all\footnote{They must also execute the same program, 
because otherwise they could use the program
(or a hash of it) as their identity. 
We consider that it is the same if processes have no identity 
or they have the same identity for all processes, 
since a process that lacks an identity can choose
a default value (e.g., ) as its identifier.}.
This paper introduces an  anonymous counterpart\footnote{In this paper,
when we say that a failure detector  is the  {\it counterpart} 
of  a  failure   detector    we  mean  that,   in  a classical  
asynchronous system  (i.e., where each process  has its own identity) 
enriched    with  a  failure  detector of  class ,  it  is  possible  to
design  an  algorithm that builds  a failure detector  of the class  
and vice-versa  by exchanging   and .  Said differently,   and 
have the same computability power in a classical crash-prone asynchronous 
system.}  (denoted  later in \cite{DBLP:conf/wdag/BonnetR10})  
of  the   perfect  failure detector  
introduced in \cite{DBLP:journals/jacm/ChandraT96}. A failure detector
of class  returns an upper bound (that eventually becomes tight)
of the current number of alive processes. The paper then
shows that  there  is  an inherent  price  associated with anonymous
consensus,  namely,  while the lower bound on the number of rounds in 
a non-anonymous system enriched with   is  (where  is 
the maximum number of faulty processes), it is   
in an anonymous system enriched with  .
The algorithm proposed assumes knowledge of the parameter .

More general failure detectors suited to anonymous  distributed systems are
presented in \cite{DBLP:conf/wdag/BonnetR10}. 
Among other results,  this paper introduces the anonymous counterpart 
of the quorum  failure detector  class 
 \cite{DBLP:journals/jacm/Delporte-GalletFG10} and the 
anonymous counterpart  of the eventual leader  failure detector 
class  \cite{DBLP:journals/jacm/ChandraHT96}. It also presents
the failure detector class  which is the complement of .
An important result of \cite{DBLP:conf/wdag/BonnetR10} 
is the fact that  relations linking  failure detector classes 
are  not the same in non-anonymous systems   and anonymous systems. 
This is also the case
if processes do not know the number  of processes in the system 
(unknown membership in anonymous systems). 
If  is unknown, the equivalence between
 and , 
shown in \cite{DBLP:conf/wdag/BonnetR10}, does not hold anymore.

Regarding implementability, it is stated 
in \cite{DBLP:conf/wdag/BonnetR10} that  is not \emph{realistic}
(i.e., it can not be implemented in an anonymous  synchronous system 
\cite{DBLP:conf/dsn/Delporte-GalletFG02}). If the membership is
unknown, it is not hard to show that  is not realistic either, 
applying similar techniques as those in
\cite{DBLP:journals/ipl/JimenezAF06}. On the other hand, 
while  can be implemented in an anonymous  
synchronous system, it is easy to show that it cannot be 
implemented in most partially synchronous systems 
(e.g., in particular, in those with all links eventually timely).



\tightparagraph{Contributions}
As mentioned, we explore the consensus problem in homonymous systems. 
Additional adversaries considered are
asynchrony, process crashes, and lack of initial knowledge of the membership. 
We can summarize the main contributions of this paper as follows.

First, the paper defines new classes  of failure detectors suited  
to homonymous
systems. These classes, denoted  and  , 
are shown to be homonymous counterparts of   and  , 
respectively.
The interest on the latter classes is motivated by the fact that  
 is the weakest failure detector 
to solve consensus in crash prone asynchronous message-passing systems 
for any  number of  process failures  
\cite{DBLP:journals/jacm/Delporte-GalletFG10}.  
The paper also investigates the relations linking , 
 and  , and shows that both 
 and   can be obtained
from  in asynchronous anonymous systems. 
As a byproduct, we also introduce a new
failure detector class denoted  ,
that is the homonymous counterpart of  
(the complement of     \cite{DBLP:journals/jacm/ChandraT96}),
which we consider of independent interest.

Then, the paper explores the implementability of these classes 
of failure detectors.
It presents an implementation of   in  homonymous message-passing  
systems  with  partially synchronous processes  and eventually timely  links.
This algorithm does  not require that the processes know the system
 membership. 
Since  can be trivially implemented from  without communication,
 is realistic and can also be implemented in a partially synchronous 
homonymous system without membership knowledge. The paper also presents 
an implementation of  
in  a  synchronous homonymous message-passing  system
without membership knowledge.

Finally, the paper presents two consensus algorithms for asynchronous 
homonymous systems enriched with . Both algorithms are derived
from consensus algorithms for anonymous systems proposed in 
\cite{DBLP:conf/aina/BonnetR10} and
\cite{DBLP:conf/wdag/BonnetR10}, respectively. 
The main challenge, and hence, the main contribution
of our algorithms, is to modify the original algorithms that 
used  to use  instead.
In the second algorithm, also the use of  has been 
replaced by the use of .

The first algorithm assumes that each process knows the value 
and that a majority of processes is correct in 
all executions\footnote{The knowledge of  can be replaced 
by the knowledge of a
parameter  such that,  and, in all executions, 
at least  processes are correct.}. Since, as mentioned,
 can be implemented with partial synchrony, the combination of the
algorithms presented (to implement  and to solve consensus with )
form a distributed algorithm that solves consensus in any homonymous system
with partially synchronous processes, eventually timely  links, and 
a majority of correct processes. Applied to anonymous systems,
this result relaxes the known conditions to solve consensus, since previous
algorithms were based on unrealistic failure 
detectors () or failure  detectors that require
a larger degree of synchrony ().

The second consensus algorithm presented works for any number of process 
crashes, and does not need to know , but assumes that 
the system is  enriched with the pair of failure detectors 
.
This algorithm, combined with the algorithms to implement 
 and , shows that the consensus problem 
can be solved in \emph{synchronous} homonymous systems subject to
any number of crash failures without the initial knowledge neither of 
the parameter   nor  of the membership.
Applied to anonymous systems, this result relaxes the known conditions to 
solve consensus under any number of failures, 
since previous algorithms used unrealistic detectors
() or required to know  or an upper bound on it.



This second consensus algorithms also forces us to restate 
the conjecture of which could be the weakest failure detector to solve
consensus in asynchronous anonymous systems. The algorithm solves 
consensus in anonymous systems with a pair of detectors 
,
and we describe how it can be modified to solve consensus 
with a pair . Additionally, as mentioned,
it is shown here that  can be obtained from , and both
 and  can be obtained from . 
The conjecture issued in \cite{DBLP:conf/wdag/BonnetR10} was that
 \footnote{ represents 
a form of composition in which the resulting failure detector 
outputs  for a finite time until it behaves at all processes 
as  one -and the same- of the two detectors  that are combined.} 
could be the weakest failure detector. 
Then, using the same algorithm described in \cite{DBLP:conf/wdag/BonnetR10} 
to combine the
consensus algorithms for  and  
, the new candidate  to be the 
 weakest failure detector for consensus despite anonymity is  now 
.

\tightparagraph{Roadmap}
The   paper  is   made   up  of   \ref{sec:FDs-based-consensus}  sections.   
Section \ref{sec:model} presents the system model. Section 
\ref{sec:FDs-defintions} introduces failure  detector classes suited 
to homonymous
systems, and explores their relation with other classes and their 
implementability.
Finally, Section \ref{sec:FDs-based-consensus} presents  failure 
detector-based homonymous consensus algorithms.




\section{System Model}
\label{sec:model} 

\tightparagraph{Homonymous processes} 
Let  denote the set of processes with  .
 We use   to denote the identity  of process  .  
Different processes may  have the
same  identity,  i.e. .  Two
processes with the same identity are said to be \emph{homonymous.}   
Let  be any subset of processes. We  define  as the
\emph{multiset} (sometimes also called {\it bag}) of process identities  
in ,  . Let us remember that, differently
from a set, an element of a multiset can appear more than once. 
Hence, as   may contain several  times the same   identity, 
we always have .  
The  \emph{multiplicity}   (number  of   instances)  of
identity       in    a    multiset    is  denoted   
. When  is clear from the context we will use simply
.      is used to denote
the  processes whose  identity is in the multiset , i.e., 
. 
Every  process    knows  its   own identity
. Unless  otherwise stated, a process   does not  know the system
membership , nor the system size , nor any upper bound  on the 
number of faulty processes. Observe that the set  is
a formalization tool that is not known by the set of processes of the system. 


Processes are  asynchronous, unless otherwise  stated. We assume  that time
advances at discrete  steps. We assume a global clock  whose values are the
positive natural numbers, but processes cannot access it. 
Processes can  fail by  crashing, i.e.,   stop taking steps. 
A process that  crashes in a run is said to  be \emph{faulty} and a
process that is not  faulty in a run is said to  be \emph{correct}. 
The set of correct processes is denoted by . 


\tightparagraph{Communication}
The processes can invoke the primitive  to send a message
 to all  processes of the system (including  itself). This communication
primitive is modeled in the following way. The network is assumed to have a
directed link  from process  to  process  for each  pair of processes
  ( does  not  need  to  be  different from  ).  Then,
 invoked at  process  sends one copy  of message  along
the link  from  to , for  each .  Unless otherwise stated,
links are asynchronous and reliable,  i.e., links neither lose messages nor
duplicate messages nor corrupt  messages nor generate spurious messages. If
a process crashes while broadcasting a message, the message is received
by an arbitrary  subset of processes.  


\tightparagraph{Notation and  time-related definitions}
The  previous  model is  denoted   (Homonymous
Asynchronous System). 
We  use    to  denote a  homonymous  system  where
processes  are partially  synchronous and  links are  eventually  timely. 
A
process is  \emph{partially synchronous} if the  time to execute  a step is
bounded, but  the bound is unknown.  A link is  \emph{eventually timely} if
there  is  an unknown  global  stabilization  time  (denoted )
 after  which  all
messages sent  across the  link are delivered  in a bounded   time,
where   is  unknown.  Messages sent  before   can  be lost  or
delivered after an arbitrary (but finite) time. 

 denotes the  classical asynchronous  system with
unique identities  and  reliable channels. Finally,  denotes
the  Anonymous  Asynchronous   System model  \cite{DBLP:conf/wdag/BonnetR10}.  
Observe  that    and   are  special  cases
(actually extreme cases with respect to homonymy) of 
 (an anonymous system can be seen 
as a homonymous system where
all  processes  have the  same default identifier ).


\section{Failure Detectors}
\label{sec:FDs-defintions}

In this section we define failure detectors previously proposed and the 
ones proposed here for homonymous systems. Then, relationships between 
these detectors are derived, and their implementability is explored.

\tightparagraph{Failure detectors for classical and anonymous systems}
We briefly describe here some failure detector previously proposed. 
We start with the classes that have been defined for .

\emph{A failure detector of class } 
\cite{DBLP:journals/jacm/Delporte-GalletFG10} 
provides each process  
 with a variable  which contains a set of process 
identifiers. The properties that are satisfied by these sets are 
[Liveness]  , and
[Safety] .
 
\emph{A failure detector of class }
 \cite{DBLP:journals/jacm/ChandraHT96}
provides each process   with a variable  such that 
[Election] eventually all these variables contain the same process 
identifier of a correct process.


The following failure detector classes have been defined for
 anonymous systems .
 
\emph{A failure detector of class } \cite{DBLP:conf/wdag/BonnetR10}
provides each process  with a variable , such 
that [Election] there is a time after which, permanently, (1) there is 
a correct process whose Boolean variable is true,
 and (2) the Boolean variables of the other correct processes are false.
 
\emph{A failure detector of class } \cite{DBLP:conf/wdag/BonnetR09}
provides each process   with a variable  such that, 
if  and  denote the value of this variable and 
the number of alive processes at time , respectively, then [Safety]
 , 
and [Liveness]
 .

\emph{A failure detector of class } \cite{DBLP:conf/wdag/BonnetR10}
provides each process   with a variable  that 
contains a set of pairs of the form . The parameter  is a 
label provided by the failure detector, and  is an integer. 
Let us denote  the value of variable  at 
time . 
Let .
Any failure detector of class  must satisfy the following properties: 

\begin{itemize}
\item
Validity.  No set  ever contains simultaneously two pairs 
with the same label. 
\item Monotonicity. 
.
\item
Liveness.
 .
\item
Safety.
.
\end{itemize}



\tightparagraph{Failure detectors for homonymous systems}
Classical failures detectors output a set of processes' identifiers. 
Our failures detectors extend this output to 
a multiset of processes' identifiers, due to the homonymy nature of the system.
The following are the new failure detectors proposed for homonymous systems. 


\emph{A failure detector of class } eventually 
outputs forever the multiset with the 
identifiers of the correct processes. More formally,
a failure detector of class  provides each process   
with a variable , such that [Liveness]
, 
. This failure detector  is the 
counterpart of .

\emph{A failure detector of class } 
eventually outputs the same identifier 
and number  at all processes, such that  is the identifier of 
some correct process, and  is the number of correct processes that 
have this identifier . More formally,
a failure detector of class  provides each process   
with two variables  and , such that 
[Election] , , 
and .

Any correct process  such that  is called a \emph{leader}.
Note that this failure detector does not choose only one leader, like 
in  or in , but a set of leaders with the same identifier. 
When all identifiers are different, the class  is equivalent to . 
Furthermore, a failure detector of class  can be obtained from any 
detector  of class  without any communication (for instance, 
setting at each process  periodically  to the smallest 
element in , and 
).



\emph{A failure detector of class } 
provides each process  
with two variables  and , where  is a set 
of pairs of the form  ( is a label, and  is a multiset such 
that ) and  is a set of labels. 
Roughly speaking, each pair  determines a set of quora, and the set 
 of a process  determines in which of these sets it 
participates. More formal,
let us denote  and   the values of 
variables  and  at time , respectively.
Let .
Any failure detector of class  must satisfy the following properties: 
\begin{itemize}
\item
Validity.  No set  ever contains simultaneously two pairs 
with the same label.
\item
Monotonicity.
: 
(1) , and 
(2) .
\item
Liveness. .
\item
Safety. .
\end{itemize}
Comparing  and , one can observe that  has pairs  
in which  is a multiset of identifiers, while  uses pairs  
in which  is an integer. However,
a more important difference is that, in , each process has two variables.
 Then, the labels that a process  has in  can be disconnected 
from those it has in
. This allows for additional flexibility in .


\tightparagraph{Reductions between failure detectors}
\label{red-FD}
In this section we claim that it can be shown, via reductions, 
the relation of the newly defined failure detector classes with 
the previously defined classes.
We use the standard form of comparing the relative power of failure 
detector classes of \cite{DBLP:journals/jacm/ChandraT96}.
A failure detector class  is \emph{stronger} than class  in 
system  if there is an algorithm  that emulates the 
output of a failure detector of class  in  
(i.e., system  enhanced with a failure detector  
of class ). We also say that  can be obtained from  
in . Two classes are equivalent if this property 
can be shown in both directions.

We only present here the main results. 
The proofs and additional details can be found in the Appendix.
The first result shows that, 
in classical systems with unique identifiers, , , 
and  are equivalent.

\begin{theorem}
\label{thm:equivalent}
Failure detector classes , , and  are equivalent 
in . Furthermore,
the transformations between  and  do not require 
initial knowledge of the membership.
\end{theorem}



In anonymous systems we have the following properties. Recall that 
an anonymous system is assumed to be a homonymous system 
in which every process has a default identifier \footnote{Note that this
differs from the assumption used in \cite{DBLP:conf/wdag/BonnetR10}.}.

\begin{theorem}
\label{thm:astohs}
Class  can be obtained from class  in 
 without communication.
\end{theorem}

\begin{theorem}
\label{thm:nap}
Classes  and  can be obtained from class  
in  without communication.
\end{theorem}

\begin{figure}[htbp]
\begin{center}
\begin{picture}(0,0)\includegraphics{FD-relations-latex.pstex}\end{picture}\setlength{\unitlength}{3158sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(4658,2269)(769,-2409)
\put(4055,-1169){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2481,-1147){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5149,-1165){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1838,-422){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2659,-428){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1009,-428){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2714,-1834){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1894,-1834){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1074,-1842){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1544,-1159){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(1931,-2331){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0} system model}}}}}
\put(3533,-360){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4469,-362){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4689,-1905){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4572,-2317){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0} system model}}}}}
\end{picture} \caption{Relations   between  failure  detector   classes  in   the  models
  and . 
There  is  an  arrow from  class    to    if   is  stronger  that
. Solid arrows are 
relations       shown       by       Bonnet       and       Raynal       in
\cite{DBLP:conf/wdag/BonnetR10}. Dashed arrows are 
relations shown here, while dotted arrows are trivial relations.}
\label{default}
\end{center}
\end{figure}



\section{Implementing Failure Detectors in  Homonymous Systems}
\label{appendix:FDs-implementation}

In this section, we show that there are algorithms that implement 
the failure detectors classes  and  in 
 (homonymous partially synchronous system). We also implement the 
failure detector  in  (homonymous synchronous system).
 In all cases they do not need to know initially the membership. 






\begin{figure}
\begin{lstlisting}
Init
	 := ;  // multiset of process identifiers
	 := ; // set of process identifiers
	 := 1;
	 := 1;
	start Tasks T1 and T2;

Task T1
	repeat forever (' \label{f1-9}')
		broadcast ;
		wait  time;
		 := ; //  is an auxiliary multiset
		for each  received 
		             with  do (' \label{f1-13}')
			add one instance of  to ;
		end for; (' \label{f1-15} ')
		 := ; (' \label{f1-16}')
		 := ; (' \label{f1-17}')
	end repeat; (' \label{f1-18}')

Task T2	
	upon reception of  do (' \label{f1-21} ')
		if  then (' \label{f1-22} ')
			 := ;
			create ;
			 := 0;
		end if; (' \label{f1-26} ')
		if  then (' \label{f1-27}')
		  broadcast   ; (' \label{f1-28} ')
		end if;  (' \label{f1-29} ')
		 := ;  (' \label{f1-30} ')
	
	upon reception of  with () do (' \label{f1-32} ')
		 := ; (' \label{f1-33} ')
		
	

\end{lstlisting}		
\caption{Algorithm that implements  (code for process ).}
\label{Fig-HP}
\end{figure}




\subsection{Implementation of  and }
The algorithm of Figure \ref{Fig-HP} implements  (and  
with trivial changes) in  where processes 
are partially synchronous, links are eventually timely, and membership 
is not known. 

\tightparagraph{Brief description of the algorithm:} 
It is a polling-based algorithm that executes in rounds. 
At every round , the Task 1 of each process  broadcasts 
 messages. After a time , 
it gathers in the variable  (and, hence, also in ) 
a multiset with the senders' identifiers  of processes from 
 messages received with .

Task 2 is related with the reception of  and  
messages. When a process  receives a  message from 
process , process  has to respond with as many  
as process  needs to receive up to round , and not 
previously sent by process  (Lines~\ref{f1-27}-\ref{f1-29}). 
Note that the  
messages are piggybacked in only one message (Line~\ref{f1-28}). 
Also note that is in variable  where  holds the 
latest round broadcast to . 
If it is the first time that process  receives a  
message from a process with identifier 
, then variable  is created and initialized to 
zero (Lines~\ref{f1-22}-\ref{f1-26}).

It is important to remark that, for each different identifier , 
only one  
message is broadcast by each process . So, if processes  and 
 with  broadcast two  messages, 
then each process  only broadcast one  
message with  . Note that eventually (at least after 
GST time) each   
message sent by any process has to be received by all correct processes. 
Hence, eventually processes  and  
will receive all   messages generated due to  messages.

Finally, Lines~\ref{f1-32}-\ref{f1-33} of Task 2 allow process  
to adapt the variable 
 to the communication latency and process speed. 
When process  receives an outdated  
message (i.e., a message with round  less than current round ), 
then it increases its variable .


\begin{lemma}
\label{l-faulty}
Given processes  and , there is a round  
such that  does not receive any 
 message from 
 with .
\end{lemma}
\begin{proof}
There is a time  at which  stops taking steps. If  ever 
sent a  message, 
consider the largest 
such that  sent message . 
Otherwise, let . Then, the claim holds for .
\end{proof}

\begin{lemma}
\label{l-correct}
Given processes , there is a round  such that, for all 
rounds , 
when  executes the loop of Lines~\ref{f1-13}-\ref{f1-15} 
with , it has received 
a message 
 from  with 
.
\end{lemma}
\begin{proof}
Observe that, since  is correct, it will repeat forever the loop of 
Lines~\ref{f1-9}-\ref{f1-18}, with the value of  
increasing in one unit at each iteration.
Hence,  will be sending forever messages  
after  with increasing round numbers, that will eventually
 be received by . Then,  eventually will send infinite 
 messages after , 
with increasing round numbers. 
Let  be the first such 
message sent by  after . Then, for each round number , 
there is some message  
sent by  with , and these messages are delivered at
  at most  time after being sent. 


Now, assume for contradiction that for each round , 
there is a round  such that, when  executes the loop 
of Lines~\ref{f1-13}-\ref{f1-15} with , 
it has not received the message 
 from  with 
. But, every time this happens, when the message 
is finally received,
 has been incremented in Line~\ref{f1-17} and, hence, 
 
is incremented (in Lines~\ref{f1-32}-\ref{f1-33}). 
Then, eventually, by some round , 
the value of  will be greater than , 
where  is the maximum time that  takes 
to execute Lines~\ref{f1-21}-\ref{f1-30}. 
Then,  will receive 
message  
with  before executing the loop of 
Lines~\ref{f1-13}-\ref{f1-15} 
with , for all . We have reached a contradiction 
and the claim of the lemma follows.
\end{proof}

\begin{theorem}
The algorithm of Figure \ref{Fig-HP} implements a failure detector of 
the class  in a system  (homonymous 
system where processes are partially synchronous and links are eventually 
timely), even if the membership is not known initially.
\end{theorem}
\begin{proof}
Consider a correct process . From Lemma~\ref{l-faulty}, there is a 
round  such that  does not receive any 
 message with
  from any faulty process. From Lemma~\ref{l-correct}, 
there is a round  such that for all rounds , when 
 executes the loop of Lines~\ref{f1-13}-\ref{f1-15} 
with , it has 
received a  message with 

from each correct process. Hence, for every round  
when the Line~\ref{f1-16} is executed with , 
the variable  
is updated with the multiset .
\end{proof}

We can obtain  from the algorithm of Fig.~\ref{Fig-HP} without 
additional communication. This can be done by simply including, 
immediately after Line~\ref{f1-16},   
(i.e., the smallest identifier in ) and .
 
\begin{corollary}
The algorithm of Figure \ref{Fig-HP} can be changed to implement a 
failure detector of the class  in a system  
(homonymous system where processes are partially synchronous and links 
are eventually timely), even if the membership is not known initially.
\end{corollary}





\subsection{Implementation of }
Figure \ref{Fig-HS} implements  in ] 
where processes are synchronous, links are timely, and
membership is not known. 

\tightparagraph{Brief description of the algorithm} 
It runs in synchronous steps. In each step every process  
broadcasts a  message. Then, process  waits for
 messages sent through reliable links 
in this synchronous step by alive processes. Process  
gathers in the multiset variable  the 
identifiers  of all  messages received. 
At the end of this step, variables  and  
are updated with the value of . 
Note that for process  the label  of a quorum  is formed by the 
multiset  (i.e, ).

   
\begin{theorem}
The algorithm of Figure \ref{Fig-HS} implements a failure detector 
of the class  in a system  (homonymous 
synchronous systems), even if the membership is not known initially.
\end{theorem}
\begin{proof}
From the definition of , it is enough to prove the following properties.

\emph{Validity.}
Since  is a set, and the elements included in it are of the 
form  (see Line~\ref{f2-7} in Figure \ref{Fig-HS}) there cannot 
be two pairs with the same label.
   
\emph{Monotonicity.}
The monotonicity of  in Figure \ref{Fig-HS} holds because 
 is initially empty, and 
each step,  either grows or remains the same 
(see Line~\ref{f2-8} in Figure \ref{Fig-HS}). 
Similarly, the monotonicity of  in Figure \ref{Fig-HS} 
follows from the fact that  is 
initially empty, and any element  included in it is 
never removed (see Line~\ref{f2-7} in Figure \ref{Fig-HS}).

\emph{Liveness.}
Let  be the synchronous step in which the last faulty process crashed. 
Then, in every step  after  only correct processes will execute. 
Consider any process . In step  will receive messages 
from all correct 
processes, and, hence, . 
Then, process  includes  in , and  in  
. Therefore, each correct process  is in . 
So, after step , for each correct process , the pair  
is in , and . 
 
\emph{Safety.}
Consider two pairs  and 
, 
for any  and any . 

Let  be the set of processes from which  received 
 messages in the synchronous step in which
  was inserted for the first time in  . 
Observe that . 
Furthermore, any process  must also be in  
(i.e., ). Also, , and,  
hence, . Therefore, the only set  
such that  is .  We define  similarly, 
and conclude that the only set  such that 
 is . Since
, the safety property holds. 
\end{proof}


\begin{figure}
\begin{lstlisting}
  ;
  ;
  for each synchronous step do
    broadcast ;
    wait for the messages sent in this synchronous step; 
     multiset of identifiers received in  messages;
     ('\label{f2-7}')
    ; ('\label{f2-8}')
  end for;
\end{lstlisting}		
\caption{Algorithm to implement  without knowledge of membership 
(code for process )}
\label{Fig-HS}
\end{figure}



\section{Solving  Consensus in Homonymous Systems}
\label{sec:FDs-based-consensus}




\begin{figure}
\begin{lstlisting}
operation propose(): 
   := ; :=; ('\label{f3-2}')
  start Tasks T1 and T2;
  
Task T1
  repeat forever
    :=;  ('\label{f3-8}')
    // Leaders' Coordination Phase
    broadcast ; ('\label{f3-10}')
    wait until ( ('\label{f3-11a}')
      ( messages  received); ('\label{f3-11b}')
    if (some message  received) then 
       :=
                          received  end if;  ('\label{f3-13}')
    // Phase 0
    wait until  received); ('\label{f3-15}')
    if ( received) then  := end if; ('\label{f3-16}')
    broadcast; ('\label{f3-17}')
    // Phase 1
    broadcast;
    wait until  received from  processes;
    if (the same estimate  received from  processes) then 
       := ('\label{f3-22}')
    else
       := ('\label{f3-24}')
    end if;
    // Phase 2
    broadcast;
    wait until  received from  processes;
    let  message  received ;
    if  then 
      broadcast ; return() end if; ('\label{f3-30}')
    if  then  :=  end if; ('\label{f3-31}')
    if  then skip  end if;
  end repeat;

Task T2
  upon reception of  do
    broadcast ; return()
\end{lstlisting}
\caption{Consensus algorithm in 
(code for process ).
It uses detector .
}
\label{Fig-Cons-HOmega}
\end{figure}



We present in this section two algorithms. One algorithm implements 
Consensus in , that is,
in an homonymous asynchronous system with reliable links, using the failure
detector ,  
and when a majority of processes are correct. 
The other algorithm implements Consensus in , that is,
in an homonymous asynchronous system with reliable links, using the failure
detector  and .  


\subsection{Implementing Consensus in }
Let us  consider  where  membership is unknown,
but the number of processes is known (that is, ). 
Let us assume a majority of correct processes (i.e., ).
We say  that a process   is a leader, if  it is correct  and, after some
finite  time,    permanently  for each  correct  process
. By definition of , there has to be at least one leader. 

The algorithm of Figure \ref{Fig-Cons-HOmega} is derived from the algorithm
in  Figure  4 of  \cite{DBLP:conf/aina/BonnetR10},  proposed for  anonymous
systems. This algorithm has been adapted for homonymous  
systems.  The  algorithm of  Figure  \ref{Fig-Cons-HOmega}  uses a  failure
detector  of class   (instead of  ), and  a new  initial leaders'
coordination phase has been added. The  purpose of this initial phase is to
guarantee that, after a given round,  all leaders propose the same value in
each round. 

The  algorithm  works   in  rounds,  and  it  has   four  phases  (Leaders'
Coordination Phase, Phase 0, Phase 1 and Phase 2).  
Every  process  begins  the Leaders'  Coordination phase  broadcasting a
 message. 
If process  considers itself a leader (querying the failure detector 
of class ), it has to wait 
 until  to   receive    messages  sent   by  all  its
homonymous  processes (also  querying  the failure  detector   of  class
) (Lines~\ref{f3-11a}-\ref{f3-11b}).  After that, process   updates
its estimate  with the minimal value  
proposed among all its homonymous.  Note that eventually all its homonymous
will be leaders too. Hence, eventually  
all leaders will also choose the same minimal value in . 

In Phase 0, if process   considers itself a leader (querying the failure
detector  of class ) (Line~\ref{f3-15}), 
it   broadcast   a      message  with   its   estimate   in
. Otherwise, process  has to update its  waiting until a
 message is received from  one of the leaders processes 
(Lines~\ref{f3-15}-\ref{f3-16}).  
Note that after the Leaders' Coordination Phase, eventually each leader 
broadcast  messages with the same value in . 





The  rest of  the algorithm  is similar  to the  algorithm in  Figure  4 of
\cite{DBLP:conf/aina/BonnetR10}.  We  omit  further  details due  to  space
restrictions. 
The following lemmas are the key  of the correctness of the algorithm. They
show that, even having multiple  leaders, these will eventually converge to
propose the same value at each round. 
 
\begin{lemma} 
\label{no-block}
No correct process blocks forever in the Leaders' Coordination Phase.
\end{lemma} 
\begin{proof}
The only line in  which processes can block in Lines~\ref{f3-8}-\ref{f3-13}
is in Lines~\ref{f3-11a}-\ref{f3-11b}. A correct process that is not leader
does not  block permanently  in these lines,  because eventually  the first
part of  
the wait  condition is  satisfied. Let us  assume, for  contradiction, that
some leader  blocks permanently in  Line~\ref{f3-11b}. Let us  consider the
smallest round   in which some leader  blocks.  By definition of ,
each leader   eventually reaches  round , and  (even if it  blocks in
)   broadcasts  ,  where   ,  in
Line~\ref{f3-10}. (Observe that all processes send  messages  
in Line~\ref{f3-10}, even  if they do not consider  themselves as leaders.)
Eventually, all these messages are delivered to   
and   is permanently the  number of leaders.  Hence, the
second part  of the wait condition (Line~\ref{f3-11b})  is satisfied. Thus,
 is not blocked anymore, and, therefore, we reach a contradiction. 
\end{proof}


\begin{lemma} 
\label{same-value}
There  is a  round   such  that  at every  round  all  leaders
broadcast the same value in Phase 0 of round . 
\end{lemma} 
\begin{proof}
Eventually all leaders  broadcast the same value because  after some round,
all leaders start Phase 0 with the same value in . 
Consider  a time   when  all faulty  processes have  crashed  and the
failure detector  is stable (i.e.,  
, ,
 being , and ). 
Let  be  the largest round reached by any process  at time . Then,
for any round , all 
leaders  have the same estimate  at the beginning of the Phase 0
of round  (Line ~\ref{f3-15}), or  there has been a decision in a round
smaller than . To prove this, let us assume that no decision is reached
in a round smaller than . 
Then, since  the leaders do  not block forever  in any round  (see previous
paragraph  1),  they execute  Line~\ref{f3-10}  in  round  . Since  the
failure detector is stable, they also  wait for the second part of the wait
condition of  Lines~\ref{f3-11a}-\ref{f3-11b} (since the first  part is not
satisfied). 
When any  leader  executes the  Leaders' Coordination Phase  of , it
blocks    in     Lines~\ref{f3-11a}-\ref{f3-11b}    until    it    receives
 messages  from the other  leaders. By the  stability of
the   failure  detector,   is the  exact  number of
leaders. Also,  from the  definition of   and , no  faulty process
with  identifier   is alive  and  all the  messages they  sent
correspond to rounds smaller than . 
Hence, each  leader  will  wait to receive  messages from all  the other
leaders and  will set  to the  minimum from the same  set of values
(Line~\ref{f3-13}). 
\end{proof}



\begin{theorem}
\label{thm:consensus1}
The algorithm of Figure~\ref{Fig-Cons-HOmega} 
solves consensus in .
\end{theorem}
\begin{proof}
From the definition of Consensus, 
it is enough to prove the following properties.

\emph{Validity.} 
The variable   is  initialized with a  value proposed by  its process
(Line~\ref{f3-2}). The value of   may be updated in Lines~\ref{f3-13}
or ~\ref{f3-16} with  values of  broadcasted by  other processes. The
variable  is initialized  and updated with   (Line~\ref{f3-22})
or    (Line~\ref{f3-24}). The  value  of    may be  updated  in
Line~\ref{f3-31} with values of   (different from ) broadcasted
by other processes.  The value decided in Line~\ref{f3-30}  is the value of
  that was  broadcasted by  some process.  As it  is not  possible to
decide the value   (Line~\ref{f3-30}), then the value  decided has to
be  one  of the  values  proposed by  the  processes.  Then,  the  validity
property holds.   

\emph{Agreement.} 
Identical to the agreement property of 
Figure 4 of \cite{DBLP:conf/aina/BonnetR10},

\emph{Termination.}
From Lemmas \ref{no-block} and  \ref{same-value}, after some round , all
leaders  
hold the  same value   in   when they  start executing Phase  0 of
round   (Line~\ref{f3-15}),  and  they broadcast  this  same value  
(Line~\ref{f3-17}). Note that it is the same situation as having only  
one leader with value  stored  in  when Phase 0 is reached. Hence,
as Phase 0 starts in the same conditions as in the algorithm of Figure 4 of
\cite{DBLP:conf/aina/BonnetR10}, the  same proof can  be used to  prove the
termination property. 
\end{proof}

\subsection{Implementing Consensus in }
Figure      \ref{Fig-Cons-HO-Sigma}       implements      Consensus      in
. Note  that it is  a variation of the  algorithm of
Figure  3 of  \cite{DBLP:conf/wdag/BonnetR10} where,  like in  the previous
case, we have  added a preliminary phase as a  barrier such that homonymous
leaders  eventually  ``agree"  in  the  same  estimation  value    to
propose. Once  this issue has been  solved (as was proven  for the previous
algorithm), the use that this algorithm makes of the 
failure detector  is very similar to the use the algorithm of Figure 3
of \cite{DBLP:conf/wdag/BonnetR10} makes of the  failure detector.  

















\begin{figure}
\begin{lstlisting}
operation propose():
   := ;  := ;
  start Tasks T1 and T2;
  
  Task T1
   repeat forever
    :=; 
    // Leaders' Coordination Phase
    broadcast ;
    wait until ( 
      ( messages  received);
    if (some message  received) then 
      := 
                       received  end if;
    // Phase 0
    wait until  received);
    if ( received) then  := end if; 
    broadcast;
    // Phase 1
    := ;  := ; 
    broadcast ;
    repeat             ('\label{f4-20}')
      if ( received) then 
         := ; exit inner repeat loop end if;              ('\label{f4-21}')
      if               ('\label{f4-22}')
          set  of messages , such that, 
         
          then             ('\label{f4-23}')
         if (all msgs in  contain the same estimate ) then 
             := else := end if;
         exit inner repeat loop;
      else if (             ('\label{f4-26}')
             received with ) then
            :=; :=; 
            broadcast 
          end if             ('\label{f4-29}')
      end if
    end repeat;             ('\label{f4-31}')
    // Phase 2 
    :=; :=;  
    broadcast ;                ('\label{f4-34}')
    repeat              ('\label{f4-35}')
      if ( received) then 
         exit inner repeat loop end if;
      if               ('\label{f4-37}')
          set  of messages , such that, 
         
          then             ('\label{f4-38}')
         let  = the set of estimates contained in ;
         if ()  () then 
           broadcast ; return(v) end if;             ('\label{f4-40}')
         if (  () then := end if;
         if ) then skip end if;
         exit inner repeat loop
      else if 
              received with  then
             :=; :=; 
             broadcast               ('\label{f4-46}')
          end if
      end if
    end repeat              ('\label{f4-49}')
  end repeat;
     
  Task T2
   upon reception of  do 
     broadcast ; return(v)
\end{lstlisting}
\caption{Consensus algorithm in  (code for process ). It uses detectors  and .}
\label{Fig-Cons-HO-Sigma}
\end{figure}    

\begin{lemma}
\label{no-block-repeats}
No correct process blocks forever in the repeat loops of Phases 1 and 2.
\end{lemma}
\begin{proof}
Note that if a correct  process decides (Line~\ref{f4-40}), then the claims
follows.  
Consider the repeat loop of Phase 1 (Lines~\ref{f4-20}-\ref{f4-31}). Let us
assume that some correct process is blocked forever in  
this loop.  Then, let us  consider the first  round  in which  a correct
process  blocks forever  in .  Hence, all  correct processes  must block
forever in the same loop in  round . Otherwise some process broadcasts a
message  
, and from Line~\ref{f4-21} no correct process would block
forever in this loop of round . 
Let us consider a correct process , and the pair  that guarantees
the liveness property for . Then, there 
is a time in which  and every correct process  in
 has . 
Note that, from Lines~\ref{f4-26}-\ref{f4-29}, every change in the variable
 of  a process creates a  new sub-round, and  that all processes
broadcast   their    current   value   of       in   each   new
sub-round. Therefore,  
eventually,   will receive  messages  from  all these
processes   such    that   .   Hence,    the   condition   of
Lines~\ref{f4-22}-\ref{f4-23} is  satisfied, and  will exit  the loop of
Phase 1. The argument for the repeat loop of  
Phase 2 is verbatim.
\end{proof}

\begin{lemma}
\label{no-different-dec}
No two processes decide different values in the same round.
\end{lemma}
\begin{proof}
Let us assume that processes   and  decide values  and 
in sub-rounds   and  , respectively, of  the same round   (in
Line~\ref{f4-40}).   Let     and     be   the  pair   in
 and  the set  of messages that  satisfy the  condition of
Lines~\ref{f4-37}-\ref{f4-38} for . Since for each message 
,  it holds that , if  is
the set  of senders of the messages  in , we have  that . Additionally, . 
We can define  and   analogously for . Then, from the
Safety Property of , . Let .   Then,   process      must   have   broadcast   messages
        and        
(Lines~\ref{f4-34}  and \ref{f4-46}).  Since the  estimate   of
   does   not   change   between   sub-rounds   (inner   repeat   loop,
Lines~\ref{f4-35}-\ref{f4-49}),  it  must  hold  that .  From  the
condition of  Line~\ref{f4-40},  in  sub-round  and
 in sub-round ,  and both processes decide the same
value. Hence, no two processes decide different values in the same round. 
\end{proof}

 \begin{theorem}
 \label{thm:consensus2}
The  algorithm   of  Figure~\ref{Fig-Cons-HO-Sigma}  solves   consensus  in
 . 
\end{theorem}
\begin{proof}
The  proof  of this  theorem  is  similar to  the  proof  of  Theorem 5  of
 \cite{TR-DBLP:conf/wdag/BonnetR10}         (full         version        of
 \cite{DBLP:conf/wdag/BonnetR10}), with the following changes. Observe that
 the Leaders' Coordination Phase and  
 Phase   0  of   the  algorithms   in  Figures   \ref{Fig-Cons-HOmega}  and
 \ref{Fig-Cons-HO-Sigma}  are the  same. Hence,  Lemmas  \ref{no-block} and
 \ref{same-value}    also    apply    to    the   algorithm    of    Figure
 \ref{Fig-Cons-HO-Sigma}.  Then,  
 the  termination  property   can  be  proven  in  a   similar  way  as  in
 \cite{TR-DBLP:conf/wdag/BonnetR10} (Lemmas  1 and 2), but  using those two
 Lemmas   \ref{no-block}   and   \ref{same-value}   together   with   Lemma
 \ref{no-block-repeats}.  The  proof  of  the agreement  property  is  also
 similar to  Lemma 3 of \cite{TR-DBLP:conf/wdag/BonnetR10}  but using Lemma
 \ref{no-different-dec}. 
\end{proof}



The algorithm of Figure~\ref{Fig-Cons-HO-Sigma} can be easily transformed into an algorithm that solves consensus in 
 (an anonymous system with detectors  and ).
For that, given a failure detector , it is enough to remove the Leaders' Coordination Phase, 
and in Phase~0 to replace  by . The resulting Phase~0 is the same as Phase~1 in the algorithm of Figure 3 of \cite{DBLP:conf/wdag/BonnetR10}, and has the same properties.













\begin{thebibliography}{10}\setlength{\itemsep}{0in}

{\small 



\bibitem{DBLP:conf/stoc/Angluin80}
D. Angluin,
\newblock Local and global properties in networks of processors (extended
  abstract).
\newblock In {\em STOC}, pages 82-93. ACM Press, 1980.




\bibitem{DBLP:journals/jacm/AttiyaSW88}
H. Attiya, M. Snir, and M. Warmuth,
\newblock Computing on an anonymous ring.
\newblock {\em J. ACM}, 35(4):845--875, 1988.





\bibitem{DBLP:conf/wdag/BonnetR09}
F. Bonnet and M. Raynal,
\newblock The price of anonymity: Optimal consensus despite asynchrony, crash
  and anonymity.
\newblock {\em DISC}, volume 5805 of {\em LNCS}, pp. 341-355. Springer, 2009.

\bibitem{DBLP:conf/wdag/BonnetR10}
F.  Bonnet and M. Raynal,
\newblock Anonymous asynchronous systems: The case of failure detectors.
\newblock {\em DISC},
  volume 6343 of {\em LNCS}, pages 206-220. Springer, 2010.

\bibitem{TR-DBLP:conf/wdag/BonnetR10}
F. Bonnet and M. Raynal,
\newblock Anonymous asynchronous systems: The case of failure detectors.
\newblock Technical Report PI 1945, IRISA, Rennes, France, January 2010.

\bibitem{DBLP:conf/aina/BonnetR10}
F.  Bonnet and M. Raynal,
\newblock Consensus in anonymous distributed systems: Is there a weakest
  failure detector?
\newblock In {\em AINA}, pp. 206-213, IEEE Computer Society, 2010.

\bibitem{janus-opodis2011}
Z. Bouzid, P. Sutra, and C. Travers,
\newblock Anonymous agreement: the janus algorithm.
\newblock To appear,  {\em OPODIS}, 2011.

\bibitem{DBLP:journals/jacm/ChandraHT96}
T.D. Chandra, V. Hadzilacos, and S. Toueg,
\newblock The weakest failure detector for solving consensus.
\newblock {\em J. ACM}, 43(4):685-722, 1996.

\bibitem{DBLP:journals/jacm/ChandraT96}
T.D. Chandra and S. Toueg,
\newblock Unreliable failure detectors for reliable distributed systems.
\newblock {\em J. ACM}, 43(2):225-267, 1996.




\bibitem{DBLP:conf/dsn/Delporte-GalletFG02}
C. Delporte-Gallet, H. Fauconnier, and R. Guerraoui,
\newblock A realistic look at failure detectors.
\newblock In {\em DSN}, pages 345-353. IEEE Computer Society, 2002.

\bibitem{DBLP:journals/jacm/Delporte-GalletFG10}
C. Delporte-Gallet, H. Fauconnier, and R. Guerraoui,
\newblock Tight failure detection bounds on atomic object implementations.
\newblock {\em J. ACM}, 57(4), 2010.


\bibitem{DFGKRT11}
C. Delporte-Gallet, H. Fauconnier, R. Guerraoui , A.-M. Kermarrec, 
E. Ruppert   and H. Tran-The,
\newblock Byzantine agreement with homonymous.
\newblock In {\em PODC}, 2011.


\bibitem{DFT09}
C. Delporte-Gallet, H. Fauconnier and A. Tielmann,
\newblock Fault-toleranr consensus in Unknown and anonymous networks. 
\newblock In {\em ICDCS}, pages 368-375, IEEE Computer Society, 2009.



\bibitem{DBLP:journals/jacm/FischerLP85}
M. Fischer, N.  Lynch  and M.  Paterson,
\newblock Impossibility of distributed consensus with one faulty process.
\newblock {\em J. ACM}, 32(2):374-382, 1985.


\bibitem{GT07}
F. Greve and S. Tixeuil,
Knowledge  connectivity   vs  synchrony  requirements   for  fault-tolerant
agreement in unknow networks. 
In {\em DSN}, pp. 82-91, IEEE Computer Society, 2007.


\bibitem{DBLP:journals/ipl/JimenezAF06}
E. Jim{\'e}nez, S. Ar{\'e}valo, and A. Fern{\'a}ndez,
\newblock Implementing unreliable failure detectors with unknown membership.
\newblock {\em Inf. Process. Lett.}, 100(2):60--63, 2006.

\bibitem{L96}
N. Lynch,
\newblock {\em Distributed Algorithms}.
\newblock Morgan Kaufmann Pub., San Francisco (CA), 1996.

\bibitem{R09}
M.  Raynal,
\newblock Failure detectors for asynchronous distributed systems: an
  introduction.
\newblock In {\em Wiley Encyclopedia of Computer Science and Engineering},
  volume~2, pages 1181-1191. 2009.

\bibitem{R10}
M. Raynal,
\newblock {\em Communication and Agreement Abstractions for Fault-Tolerant
  Asynchronous Distributed Systems}. 250 pages, 
\newblock Morgan \& Claypool Publishers, 2010.

\bibitem{DBLP:journals/tpds/YamashitaK96}
M. Yamashita and T.  Kameda,
\newblock Computing on anonymous networks: Part i-characterizing the solvable
  cases.
\newblock {\em IEEE Trans. Parallel Distributed  Systems}, 7(1):69-89, 1996.

\bibitem{DBLP:conf/podc/Zielinski08}
P. Zielinski,
\newblock Anti-omega: the weakest failure detector for set agreement.
\newblock {\em PODC}, pp.    55-64. ACM Press, , 2008.

}

\end{thebibliography}


\newpage
\appendix



\subsection{Reductions between Failure Detectors}
\label{appendixred-FD}

\subsubsection{From  to }

\begin{figure}
\begin{lstlisting}
Init
  ;			('\label{a1-l2}')
  ;											('\label{a1-l3}')
  repeat forever
    ; 												('\label{a1-l5}')
    ;								('\label{a1-l6}')
  end repeat; 
\end{lstlisting}		
\caption{Algorithm to transform  to  with initial knowledge of membership (code for process ).}
\label{Fig-S-to-HS-si-mship}
\end{figure}


\begin{figure}
\begin{lstlisting}
Init
  ;					('\label{a2-l2}')
  ;					('\label{a2-l3}')
  ;					('\label{a2-l4}')
  start tasks T1 and T2;
Task T1
  repeat forever
    broadcast ;				('\label{a2-l8}')
    ; 						('\label{a2-l9}')
    ;		('\label{a2-l10}')
  end repeat;

Task T2	
  upon reception of  do
    
    ;  
\end{lstlisting}		
\caption{Algorithm to transform  to  without initial knowledge of membership (code for process ).}
\label{Fig-S-to-HS-no-mship}
\end{figure}

We prove that, if identifiers are unique, a detector of class  can be obtained from any detector  of class .

\begin{theorem}
\label{HS-Sigma}
A failure detector of class  can be obtained from any detector  of class  in a system with unique identifiers, under either one of the following conditions:
\begin{enumerate} 
\item without any communication if every process initially knows the membership , or 
\item in system  (the membership does not need to be known initially). 
\end{enumerate} 
\end{theorem}
\begin{proof}
Let  be the variable of  failure detector  at process . 
Figures \ref{Fig-S-to-HS-si-mship} and \ref{Fig-S-to-HS-no-mship} present the algorithms to transform  into a 
failure detector of class  in Cases 1 and 2, respectively.
In both cases, at each process  initially
, and infinitely often this variable is updated with the following sentences: 
, and . In Case 1, initially every process  sets 
 and it never changes it in the run. In Case 2, every process 
initially sets , and repeatedly broadcasts a message . Process  also has a variable  initially set
to . After receiving a message , process  updates 
, and . 

We prove now the properties of :

\begin{itemize}
\item Validity.
Since  is a set, and the elements included in it are of the form  (see Line 5 in Figure \ref{Fig-S-to-HS-si-mship}, and Line 10 in Figure \ref{Fig-S-to-HS-no-mship}) there can not be two pairs with the same label.

\item Monotonicity.
The monotonicity of  in Figure \ref{Fig-S-to-HS-si-mship} is obvious because it is initialized in Line 2 and never changes. With respect to Figure \ref{Fig-S-to-HS-no-mship},  is initially empty, and it is related with the set , such that if  grows then  either grows or remains the same. Hence  never decreases because  never decreases (see Line 15 in Figure \ref{Fig-S-to-HS-no-mship}). 
The monotonicity of  in Figures \ref{Fig-S-to-HS-si-mship} and \ref{Fig-S-to-HS-no-mship} follows from the fact that  is initially empty, and any element  included in it is never removed.

\item Liveness.
Consider any correct process . In Figure \ref{Fig-S-to-HS-no-mship},  eventually,  permanently (from the exchange of  messages and Line 15 of Figure \ref{Fig-S-to-HS-no-mship}). Then, in both algorithms eventually 
 permanently (from Line 2 in Figure \ref{Fig-S-to-HS-si-mship}, and Line 16 in Figure \ref{Fig-S-to-HS-no-mship}). Hence, there is a time  after which, for every set ,  and .

The Liveness property of  guarantees that, at some time , the variable  is assigned  a set   that contains only correct processes and  will be included in  after that. Therefore, there is a time after which  contains  permanently (from monotonicity).  Since , the property follows.
 
\item Safety.
Consider two pairs  and , for any  and any . From the management of the  variables (Lines \ref{a1-l3}, \ref{a1-l5}, and \ref{a1-l6} in Figure \ref{Fig-S-to-HS-si-mship}, and Lines \ref{a2-l3}, \ref{a2-l9}, and \ref{a2-l10} in Figure \ref{Fig-S-to-HS-no-mship}), we have that  and  are values taken from  and , respectively. Hence, the sets  and  must intersect from the Safety property of the  failure detector . Then, if  and  , given that we are in a system with unique identifiers,  and  must intersect.
\end{itemize}
\end{proof}

\subsubsection{From  to }

\begin{figure}
\begin{lstlisting}
Init
   empty list;
  start Tasks T1 and T2;
Task T1
  repeat forever
    broadcast ;
  end repeat;

Task T2	
  upon reception of  do
    if  then move  to the first position of 
    else insert  in the first position of 
    end if;
\end{lstlisting}		
\caption{Algorithm to implement a failure detector of class  without initial knowledge of membership in AS[] (code for process ).}
\label{Fig-Xi}
\end{figure}

\begin{figure*}
\begin{lstlisting}
Init
  start Tasks T1 and T2;
Task T1
  repeat forever
    broadcast ;
    if  has been created then
      let  has been created;
       any  with smallest ;
    end if;
  end repeat;

Task T2	
  upon reception of  do
    foreach  do 
      if  has not been created then create  end if;
      ;
    end foreach;
\end{lstlisting}		
\caption{Algorithm to transform  to  in a system with unique identifiers, but without initial knowledge of membership (code for process ). The algorithm uses a failure detector  of class .}
\label{Fig-HS-to-S-no-mship}
\end{figure*}


We define now a new class of failure detector that will be used for reductions between the above failure detector classes.
While the service provided by this detector has been already used \cite{DBLP:conf/podc/Zielinski08,DBLP:conf/wdag/BonnetR10}, it was never formally
defined. The new failure detector class, denoted , will only be defined for systems with unique identifiers, i.e., non homonymous.

\begin{definition}
A failure detector of class  provides each process  , in a system with unique process identifiers, with a variable  which contains a (sorted) list of process identifiers. 
Any failure detector of class  must satisfy the following property:
\begin{itemize}
\item Liveness.
 Eventually, the identifiers of the correct processes 
are permanently in the first positions of . More formally,
 let  denote the position (starting from ) of process identifier  in  
 (with  if ). Then,
 
 \end{itemize}
\end{definition}

Observe that 
the position of the same identifier can be different at different processes, and can vary over time in the same process.
From the algorithm of Figure~\ref{Fig-Xi}, we obtain the following lemma.

\begin{lemma}
\label{l-Xi}
A failure detector of class  can be implemented in AS[] (an asynchronous system with unique identifiers), even when the membership is not known initially.
\end{lemma}
\begin{proof}
For each process , eventually some message  will be received at each process . Then  will be included in  and never removed after that. Given any faulty process ,  will stop receiving messages from  by some time . Then, after  process  will never receive a message  and  will never be moved to (inserted in) the first position of . However, after , eventually  will receive messages  from each process , and each identifier  will be moved to (or inserted in) the first position of . Then, there is some time  such that, at all times , . Since this holds for all  and all , the claim follows.
\end{proof}

We now show, using the algorithm of  Figure~\ref{Fig-HS-to-S-no-mship}, that  can be obtained from  without initial knowledge of the membership. 

\begin{theorem}
\label{Sigma-HS}
A failure detector of class  can be obtained from any detector  of class  in AS[] (an asynchronous system with unique identifiers), even when the membership is not known initially.
\end{theorem}
\begin{proof}
From Lemma~\ref{l-Xi}, we can have a failure detector of class  in an asynchronous system. The logic of the algorithm of Figure~\ref{Fig-HS-to-S-no-mship} is somewhat similar to that of the algorithm in Figure 2 in \cite{DBLP:conf/wdag/BonnetR10}. The condition in Line~6 guarantees that the variable  is assigned a set of identifiers  only if  is in , and every process  whose identifier is in  has  in its set  (from the management of the sets ). Combining this condition with the safety property of  we guarantee the safety property of . The liveness property of  holds from the liveness property of , the choice of  done in Line~8, and the properties of the failure detector class  as follows. If , from the liveness of , eventually every time Line~8 is executed, there is some  with only correct processes. If the failure detector  of class  has already
all the correct processes in the lowest ranks of  (which eventually happens from its liveness property), then any set  in , whose largest rank in  is minimal, contains only correct processes (which yields the liveness of ).
\end{proof}


\tightparagraph{Theorem~\ref{thm:equivalent}}
\emph{Failure detector classes , , and  are equivalent in . Furthermore,
the transformation between  and  do not require initial knowledge of the membership.}

\tightparagraph{Proof of Theorem~\ref{thm:equivalent}}
From Theorems~\ref{HS-Sigma} and~\ref{Sigma-HS} we have that  and  are equivalent.  The equivalence between  and  was shown in \cite{DBLP:conf/wdag/BonnetR10}. 







\subsubsection{From  to }

We show now how to obtain a failure detector of class  from a detector of class .

\tightparagraph{Theorem~\ref{thm:astohs}}
\emph{Class  can be obtained from class  in  without communication.}


\tightparagraph{Proof of Theorem~\ref{thm:astohs}}
Let  be a detector of class .
The transformation can be done as follows. Let  be the ``default" identifier. Let us denote with  a multiset of  identifiers . Each process  periodically does as follows. For each pair , the label  is included in  and the pair  is included in  (replacing any pair  that  may contain). The properties of  follow trivially from the properties of .

   
\subsubsection{From  to  and }

We show here how failure detectors of the classes  and  can be obtained for a failure detector of class  without communication.

\begin{lemma}
A failure detector of class  can be obtained from any detector  of class  in  (an anonymous asynchronous system) without communication.
\end{lemma}
\begin{proof}
The transformation can be done as follows. Let  be the ``default" identifier. Each process  
periodically updates  to a multiset of  identifiers . The liveness property of  guarantees the liveness property of .
\end{proof}

\begin{lemma}
A failure detector of class  can be obtained from any detector  of class  in  (an anonymous asynchronous system) without communication.
\end{lemma}
\begin{proof}
The transformation can be done as follows. Let  be the ``default" identifier. Let us denote with  a multiset of  identifiers . 
Each process  periodically does as follows. After obtaining a value  from , the label  is included in  and the pair  is included in . The Validity and Monotonicity of  hold trivially. Liveness follows since, from the safety of , only correct processes see an output of , and from the liveness property all of them do it. Then, every correct process  eventually inserts  in  and  in , and only those processes. Safety of  comes from the safety property of : if, for any  and  with ,  and  (none can be larger), then .
\end{proof}

\tightparagraph{Theorem~\ref{thm:nap}}
\emph{Classes  and  can be obtained from class  in  without communication.}

\tightparagraph{Proof of Theorem~\ref{thm:nap}}
The proof of Theorem~\ref{thm:nap} follows from the two previous lemmas.

 




\end{document}
