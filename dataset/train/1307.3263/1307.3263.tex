\documentclass{LMCS}

\def\doi{9(3:6)2013}
\lmcsheading {\doi}
{1--31}
{}
{}
{Feb.~25, 2012}
{Aug.~28, 2013}
{}

\usepackage[T1]{fontenc}

\usepackage{ucs} 
\usepackage[utf8x]{inputenc} 
\usepackage{amsmath} 
\usepackage{amssymb} 
\usepackage{mathrsfs} 
\usepackage[all]{xy} 
\usepackage[normalem]{ulem} 
\usepackage{ bbold } 
\usepackage{hyperref,enumerate}

\newdir{ >}{{}*!/-10pt/@{>}} \newcommand\mto{\rightarrowtail}

\setlength{\marginparwidth}{1.2in}
\newcommand\comment[1]{\-\marginpar[\raggedright\footnotesize #1]{\raggedright\footnotesize #1}}

\newcommand\wa{}
\newcommand{\ra}{\rightarrow}
\newcommand{\Set}{\mbox{Set}}
\newcommand{\Fam}{\mbox{Fam}}
\newcommand{\hash}{\dagger}
\newcommand{\mcal}[1]{\mathcal{#1}}
\newcommand{\C}{\mcal{C}}
\newcommand{\cech}[1]{\check{#1}}
\newcommand\waw[1]{\comment{\wa} \wa #1 \wa }
\newcommand{\proofrule}[2]{\ensuremath{
  \begin{array}[t]{@{}c@{}}
    \begin{array}[t]{lllll} 
      #1
    \end{array}\\
  \hline 
     #2
  \end{array}}}

\newcommand\ldia[2][-1pc]{
  \SelectTips{eu}{}                   
  \def\objectstyle{\scriptstyle}      
  \def\labelstyle{\scriptstyle}       
  \vcenter{                           
    \xymatrix 
    @#1                         
    {#2}             
  }}
\newcommand\ldiaf[1]{\ldia[-1pc@C=2pc]{#1}}
\newcommand\ldiam[1]{\ldia[-0.3pc@C=1.7pc]{#1}}
\newcommand\ldiap[2][]{\ldia[-1pc#1]{#2}}
\newcommand\darr[3]{\ldia{#1\ar[d]^{#2}\\#3}}

\newcommand\iso[2]{\begin{array}{c} #1\\ \hline\hline#2\end{array}}

\newcommand{\pullbackcorner}[1][dr]{\save*!/#1+1.2pc/#1:(1,-1)@^{|-}\restore}
\newcommand{\pushoutcorner}[1][dr]{\save*!/#1-1.2pc/#1:(-1,1)@^{|-}\restore}
\newcommand\pbc[1][dr]{\save*!/#1-1.8pc/#1:(-1,1)@^{|-}\restore}
\newcommand\lpbc[1][dr]{\save*!/#1-1.2pc/#1:(-1,1)@^{|-}\restore}

\newcommand\E{{\mathcal E}}
\newcommand\B{{\mathcal B}}
\newcommand\A{{\mathcal A}}
\newcommand\D{{\mathcal D}}
\newcommand\Pc{{\mathcal P}}
\newcommand\Cp{{\mathcal C}}
\newcommand\Ps{\mathscr{P}}
\newcommand\Pfi{\Ps\!\!{}_{\mathit{fin}}}
\newcommand\IB{[I,\B]}
\newcommand\IE{[I,\E]}
\newcommand\da{\!\downarrow\!}
\newcommand\one{\mathbb{1}}
\newcommand\ascl{\mathrm{ASub}(\cl)}
\newcommand\arcl{\mathrm{ARel}(\cl)}
\newcommand\as[2]{(#1\subseteq #2)}
\newcommand\setq[2]{{}^{#1}\!/\!{}_{#2}}
\newcommand\byi[1]{\setq{#1}{I}}
\newcommand\byoi[1]{\setq{#1}{1I}}
\newcommand\Lam{\mathit{Lam}}
\newcommand\Fin{\mathit{Fin}}
\newcommand\Nat{\mathit{Nat}}
\newcommand\cl{\mathit{CL}}

\newcommand\alg{\mathit{Alg}}
\newcommand\dalg{\mbox{-}\!\alg}
\newcommand\coalg{\mathit{CoAlg}}
\newcommand\dcoalg{\mbox{-}\!\coalg}
\newcommand\pr{{\mathcal Prop}}

\newcommand\hl{\begin{center}\line(1,0){250}\end{center}}
\newcommand\ti{\!\times\!}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}

\title{Indexed Induction and Coinduction,
  Fibrationally\vspace*{-0.15in}} 

\author[N.~Ghani]{Neil Ghani\rsuper a} \address{{\lsuper{a,c}}University of Strathclyde,
  Glasgow G1 1XH, UK} \email{\{neil.ghani, clement.fumex\}@strath.ac.uk}

\author[P.~Johann]{Patricia Johann\rsuper b} \address{{\lsuper b}Appalachian State University, Boone,
  NC 28608, USA} \email{johannp@cs.appstate.edu}

\author[C.~Fumex]{Cl\'ement Fumex\rsuper c} 
 \address{\vskip-6 pt}

\begin{document}

\begin{abstract}
  This paper extends the fibrational approach to induction and
  coinduction pioneered by Hermida and Jacobs, and developed by the
  current authors, in two key directions. First, we present a dual to
  the sound induction rule for inductive types that we developed
  previously. That is, we present a sound coinduction rule for any
  data type arising as the carrier of the final coalgebra of a
  functor, thus relaxing Hermida and Jacobs' restriction to polynomial
  functors. To achieve this we introduce the notion of a
  \emph{quotient category with equality} (QCE) that i) abstracts the
  standard notion of a fibration of relations constructed from a given
  fibration; and ii) plays a role in the theory of coinduction dual to
  that played by a comprehension category with unit (CCU) in the
  theory of induction. Secondly, we show that inductive and
  coinductive indexed types also admit sound induction and coinduction
  rules. Indexed data types often arise as carriers of initial
  algebras and final coalgebras of functors on slice categories, so we
  give sufficient conditions under which we can construct, from a CCU
  (QCE) , a fibration with base  that models
  indexing by  and is also a CCU (resp., QCE). We finish the paper
  by considering the more general case of sound induction and
  coinduction rules for indexed data types when the indexing is
  itself given by a fibration.
\end{abstract}

\keywords{induction, coinduction, fibrations}
\subjclass{D.3.1, F.3.2}
\ACMCCS{[{\bf Theory of computation}]: Semantics of reasoning---Program semantics---Categorical semantics}

\maketitle

\section{Introduction}

Iteration operators provide a uniform way to express common and
naturally occurring patterns of recursion over inductive 
types. Expressing recursion via iteration operators makes code easier
to read, write, and understand; facilitates code reuse; guarantees
properties of programs such as totality and termination; and supports
optimising program transformations such as fold fusion and short cut
fusion.  Categorically, iteration operators arise from the initial
algebra semantics of data types: the constructors of an inductive 
type are modelled as a functor , the data type itself is modelled
as the carrier  of the initial -algebra , and the iteration operator  for  is the map sending each -algebra  to the unique -algebra morphism from  to
.

Initial algebra semantics therefore provides a comprehensive theory of
iteration that is i) {\em principled}, in that it ensures that
programs have rigorous mathematical foundations that can be used to
give them meaning; ii) {\em expressive}, in that it is applicable to
{\em all} inductive types --- i.e., all types that are carriers of
initial algebras --- rather than just to syntactically defined classes
of data types such as polynomial ones; and iii) {\em sound}, in that
it is valid in any model --- set-theoretic, domain-theoretic,
realisability, etc. --- in which data types are interpreted as the
carriers of initial algebras.

Final coalgebra semantics gives an equally comprehensive understanding
of coinductive types. The destructors of a coinductive type are
modelled as a functor , the data type itself is modelled as the
carrier  of the final -coalgebra , and the coiteration operator  for  is the map sending each -coalgebra
 to the unique -coalgebra morphism from  to
.  Final coalgebra semantics thus provides a theory of
coiteration that is as principled, expressive, and sound as that for
induction.

Since induction and iteration are closely linked, we might expect
initial algebra semantics to give a principled, expressive, and sound
theory of induction as well. But most theories of induction for a data
type , where , are sound only under significant
restrictions on the category , the functor , or the form and
nature of the property to be established. Recently, however, a
conceptual breakthrough in the theory of induction was made by Hermida
and Jacobs~\cite{hj98}. They first showed how to lift an arbitrary
functor  on a base category  of types to a functor  on
a category of properties over those types. Then, taking the premises
of an induction rule for  to be an -algebra, their
main theorem shows that such a rule is sound if the lifting 
preserves truth predicates. Hermida and Jacobs work in a fibrational,
and hence axiomatic, setting and treat {\em any} notion of property
that can be suitably fibred over . Moreover, they place no
stringent requirements on . Thus, they overcome two of the
aforementioned limitations. But since they give sound induction rules
only for polynomial data types, the limitation on the functors treated
remains in their work. The current authors~\cite{gjf10} subsequently
removed this final restriction to give sound induction rules for all
inductive types under conditions commensurate with those
in~\cite{hj98}.

In this paper, we extend the existing body of work in three key
directions. First, Hermida and Jacobs developed a fibrational theory
of coinduction to complement their theory of induction. But this
theory, too, is sound only for polynomial data types, and so does not
apply to final coalgebras of some key functors, such as the finite
powerset functor. In this paper, we derive a sound fibrational
coinduction rule for {\em every} coinductive type. Secondly, data
types arising as initial algebras of functors are fairly simple. More
sophisticated data types --- e.g., untyped lambda terms and red-black
trees --- are often modelled as inductive indexed types arising as
initial algebras of functors on slice categories, presheaf categories,
and similar structures. In this paper, we derive sound induction rules
for such inductive indexed types.  We do this by considering first the
special case of indexing via slice categories, and then the general
case where indexing is itself given by a suitable fibration.  Finally,
since we can derive sound induction rules for inductive types and
inductive indexed types, and sound coinduction rules for coinductive
types, we might expect to be able to derive sound coinduction rules
for coinductive indexed types, too. In this paper, we confirm that
this is the case and, again, consider first the special case of
indexing via slice categories and then the general situation.

We now describe the structure of the rest of this paper. After
describing the results in each section, we give a concrete example of
a widely-used data type and a corresponding logic for which the
results of that section can derive a sound induction or coinduction
rule, as appropriate, but for which such a rule cannot be derived from
previously known techniques of comparable generality. We thus show
that our framework not only facilitates an abstract conceptualisation
that reveals the essence of induction and coinduction, but also
significantly advances the state-of-the-art by being instantiable to a
larger class of data types and logics than ever before.  The rest of
this paper is structured as follows.

\begin{iteMize}{}

\item In Section 2, we recall the fibrational approach to induction
  pioneered in~\cite{hj98} and extended in~\cite{gjf10}. We also
  present a number of fibrations, each of which captures a different
  logic of interest. Finally, we recall conditions under which the
  fibrational induction rule we derive in~\cite{gjf10} can be
  instantiated to give a sound concrete induction rule for {\em any}
  inductive data type with respect to {\em any} such logic.

\item In Section~\ref{sec:coind} we extend the fibrational approach to
  coinduction from~\cite{hj98} to derive a coinduction rule that can
  be instantiated to give a sound concrete coinduction rule for {\em
    any} coinductive data type. We illustrate this by deriving a sound
  coinduction rule for the coinductive data type determined by the
  finite powerset functor. This functor is fundamental in the theory
  of bisimulation and labelled transition systems, but it is not a
  polynomial functor and so cannot be handled using the techniques of
  Hermida and Jacobs.

\item In Section~\ref{sec:indind} we use slice categories to model
  indexing of data types, and thus to give sound concrete induction
  rules for {\em all} inductive indexed data types. We apply this
  result to derive a sound induction rule for inductive type
  determined by indexed containers with respect to the families
  fibration, and then further specialise this rule to the inductive
  indexed data type of untyped lambda terms. The data type of untyped
  lambda terms is not determined by a polynomial functor, so the sound
  induction rule we derive for it is not simply an instantiation of
  Hermida and Jacobs' results.

\item In Section~\ref{sec:indcoind} we use slice categories again,
  this time to give sound concrete coinduction rules for {\em all}
  coinductive data types. We apply our results to derive sound
  coinduction (i.e., bisimulation) rules for coinductive types
  determined by indexed containers. These coinductive types are
  equivalent to Hancock and Hyvernat's interaction
  structures~\cite{hh06}. However, since they are not determined by
  polynomial functors, the coinduction rules we derive for them are
  not simply instantiations of Hermida and Jacobs' results.

\item In Section~\ref{sec:fibind} we study fibrational indexed
  induction by generalising the indexing of data types from slice
  categories to fibrations. We derive an induction rule that extends
  the one in Section~\ref{sec:indind} and show how it can be
  instantiated to give sound induction rules for set-indexed data
  types. Set-indexing occurs, for example, in mutually recursive
  definitions of data types.

\item In Section~\ref{sec:fibcoind} we similarly study fibrational
  indexed coinduction, derive a coinduction rule that extends the one
  in Section~\ref{sec:indcoind}, and point out that this rule can be
  instantiated to give sound coinduction rules for set-indexed data
  types.

\item In Section~\ref{sec:conc} we summarise our conclusions and
  discuss related work and possibilities for future research.
\end{iteMize}

\noindent This paper is a revised and expanded version of the conference
paper~\cite{fgj11}. Whereas the conference paper covers only indexing
modelled by slice categories, this paper also treats general
indexing. Accordingly, the material in Sections~\ref{sec:fibind}
and~\ref{sec:fibcoind} is entirely new.


\section{Induction in a Fibrational Setting}\label{sec:ind}

Fibrations support a uniform axiomatic approach to induction and
coinduction that is widely applicable and abstracts over the specific
choices of the category in which types are interpreted, the functor on
that category giving rise to the data type whose rules are to be
constructed, and the predicate those rules may be used to establish.
This is advantageous because i) the semantics of data types in
languages involving recursion and other effects usually involves
categories other than ; ii) in such circumstances, the standard
set-based interpretations of predicates are no longer germane; iii) in
any setting, there can be more than one reasonable notion of
predicate; and iv) fibrations allow induction and coinduction rules
for many classes of data types to be obtained by the instantiation of
a single generic theory, rather than developed on an {\em ad hoc}
basis. The genericness supported by fibrations provides a predictive
power that is the hallmark of any good scientific theory.

\subsection{Fibrations in a Nutshell}\label{sec:nutshell} 

We begin with fibrations. More details can be found in,
e.g.,~\cite{jac99,pav90}.
\begin{definition}
  Let  be a functor. A morphism  in 
  is {\em cartesian} above a morphism  in  if\,  and, for every  in  with  for
  some , there exists a unique  in 
  such that  and .
\end{definition}

\noindent
A fibration is simply a functor  that guarantees a large
supply of cartesian morphisms. The exact definition is as follows:

\begin{definition}
  Let  be a functor. Then  is a {\em fibration} if
  for every object  of  and every morphism  in
  , there is a cartesian morphism above  with codomain . 
\end{definition}
If  is a fibration, we call  the {\em base
  category} of  and  its {\em total category}. Objects of 
are thought of as properties, objects of  are thought of as types,
and  is thought to map each property  in  to the type 
about which it is a property. An object  in  is said to be
\emph{above} its image  under , and similarly for
morphisms. For any object  of , we write  for the {\em
  fibre above }, i.e., for the subcategory of  comprising
objects above  and morphisms above the identity morphism  on
. Morphisms within a fibre are said to be {\em vertical}.

If  is a fibration,  is an object of , and , we write  for the cartesian morphism above  with
codomain .  We omit the subscript  when it can be inferred from
context. As with all entities defined via universal properties,
 is defined up to isomorphism; we write  for the domain
of . If  is a morphism in the base of a
fibration, then the function mapping each object  of  to
 extends to a functor  called the {\em
  reindexing functor induced by }. If we think of  as performing
type-level substitution, then  can be thought of as lifting 
to perform substitution of types into predicates.

\begin{example}\label{ex:famfib}
  The category  has as objects pairs  with  a
  set and . We call  the {\em domain} of 
  and write  for  when convenient. A morphism from  to  is a pair  of functions
   and . The functor  mapping  to
   is called the {\em families fibration}. Here, the cartesian
  morphism associated with the object  in 
  and the morphism  in  is the morphism 
  in  from  to .

\end{example}
\begin{example}\label{ex:cod}
  The {\em arrow category} of , denoted , has morphisms of
   as its objects. A morphism from  to  in
   is a pair  of morphisms in  such
  that the following diagram commutes:

\noindent
  The codomain functor  maps an object
   of  to the object  of . If  has
  pullbacks, then  is a fibration, called the {\em
    codomain fibration over }. Indeed, given an object  in the fibre above  and a morphism  in , the
  pullback of  along  gives the cartesian morphism above .
  Similarly, the domain functor  is a
  fibration, called the {\em domain fibration over }. No
  conditions on  are required.
\end{example}

A useful restriction of the previous fibration considers (equivalence
classes of) monic maps only:

\begin{example} 
\label{ex:subfib}
Let  be a category with pullbacks. Let  be the category
of subobjects of , i.e., let the objects of  be
equivalence classes of monos (where  and  are equivalent iff they are isomorphic in the slice
category ). The {\em subobject fibration over } is the
fibration  that sends an equivalence class
 to the codomain of . Reindexing is well-defined because the
pullback of a mono along any morphism is again a mono. Note that every
fibre  is a preorder, and thus that  is a fibred
preorder. Fibred preorders can be thought of logically as modelling
just provability, rather than proofs themselves.
\end{example}

The following fibration appears as Example 4.8.7 (iii) in~\cite{jac99}:

\begin{example}\label{ex:CL}
  Let  be the category of complete lattices with functions
  preserving all joins between them. If  is a complete lattice,
  then a subset  is {\em admissible} if  is closed
  under joins in . We write  for the category whose
  objects are pairs , where  is a complete lattice and 
  is an admissible subset of , and whose morphisms from  to
   are morphisms  in  such that  implies .  Admissible subsets of complete lattices
  form a fibration . Indeed, if 
  is an object in , if  in , and if we
  define , then
   is actually an object of  since  preserves
  joins. Moreover, a cartesian morphism  is given by  itself.
\end{example}

\subsubsection{Bifibrations}

We will later need the generalisation of the notion of a fibration to
that of a bifibration. Since bifibrations are defined in terms of
opfibrations, we begin by defining these. Abstractly, 
is an opfibration if  is a fibration. This
characterisation has the merit of allowing us to use duality to
establish properties of opfibrations from properties of fibrations,
but a more concrete definition can be obtained by unwinding the
characterisation above.

\begin{definition}
  Let  be a functor. A morphism  in 
  is {\em opcartesian} above a morphism  in  if  and, for every  in  with  for
  some , there exists a unique  in 
  such that  and .
\end{definition}
\noindent
Just as a fibration is simply a functor that has a plentiful supply
of cartesian morphisms in its domain, so an opfibration is a functor
that has a plentiful supply of opcartesian morphisms in its
domain. We have:

\begin{definition}
  If  is a functor, then  is an {\em opfibration} if
  for every object  of  and every morphism  in
   there is an opcartesian morphism in  above  with domain
  .  A functor  is a {\em bifibration} if it is simultaneously a
  fibration and an opfibration.
\end{definition}
If  is an opfibration,  is an object of  and 
is a morphism of , then we denote the opcartesian morphism above
 with domain  by  and note that, as with cartesian
morphisms, this is defined up to isomorphism. We write  for
the codomain of  and omit the superscript  when it can be
inferred from context.  If  is a morphism in the base of an
opfibration, then the function mapping each object  of  to
 extends to a functor  called
the {\em opreindexing functor induced by }. The following useful
result is from~\cite{jac93}:
\begin{lemma}\label{lem:bifdef}
  Let  be a fibration. Then  is a bifibration iff,
  for every morphism  in ,  has a left adjoint
  .
\end{lemma}

Both the families fibration and the codomain fibration are
opfibrations, and thus bifibrations. In the families fibration, if
 is a function, and  is an object of
 above , then the associated opcartesian morphism has
as codomain the function from  to  that maps  to the
disjoint union . The first
component of the opcartesian morphism is , and its second component
maps  and  to the pair .  In the codomain
fibration, if  is a morphism in the base category and  is above , then we can construct the opcartesian morphism
consisting of the pair of morphisms  from  to . In
general, the subobject fibration over  is not an opfibration, and
hence not a bifibration. However, as shown in Lemma~4.4.6
of~\cite{jac99}, if  is a regular category then it is.







\subsubsection{Beck-Chevalley Conditions and Fibred Adjunctions}    

Beck-Chevalley conditions are used to guarantee that reindexing
satisfies desirable commutativity properties. See~\cite{jac99} for an
expanded treatment of the following discussion.

\begin{definition}\label{def:beckcc}
  Let  be a bifibration. We say that  \emph{satisfies
    the Beck-Chevalley condition (for opreindexing)} if for any
  pullback square
   in , the canonical natural transformation  defined as  is an
  isomorphism. Here,  is the unit of the adjunction
   and  is the counit of the
  adjunction .
\end{definition}
\noindent 
It is easy to check that the families fibration, the codomain
fibration, and the fibration of admissible subsets of complete
lattices satisfy the Beck-Chevalley condition. In addition, the
subobject fibration over  satisfies the Beck-Chevalley condition
if  is regular. In addition, we have:

\begin{lemma}\label{lem:bcmono}
  Let  be a bifibration that satisfies the Beck-Chevalley
  condition. Then for any mono  in ,
  \begin{enumerate}[\em(1)]
  \item the functor  is full and faithful, and
  \item any opcartesian morphism above  is also cartesian.
  \end{enumerate}
\end{lemma}

Given that fibrations are the fundamental structures used in this
paper, it is natural to ask what morphisms between such structures
might be. In general, we can consider this question in a setting where
the fibrations can have different base categories. However, for our
purposes we only need consider the special case where the base
categories of the fibrations involved are the same. In this situation
we have the following definition:

\begin{definition}
  Let  be a category. Given two fibrations  and
   with base category , a {\em fibred functor} from
   to  above  is a functor  such that 
  preserves cartesian morphisms and the following diagram commutes:
  
\end{definition}

One of the key points about fibred functors is that they allow us to
define fibred adjunctions, and thus to lift standard categorical
structures to the fibred setting. In the special case when the base
categories of the fibrations are the same, a fibred adjunction is
defined as follows:

\begin{definition}
  Let  be a category and  and  be
  fibrations. Given two fibred functors  and 
  above , we say that  is a {\em fibred right adjoint} of 
  above  iff  is right adjoint to  and the unit (or,
  equivalently, counit) of the adjunction  is vertical.  We
  say that the adjunction  is a {\em fibred adjunction}
  above .
\end{definition}
\noindent
Henceforth, we speak only of fibred functors and fibred adjunctions,
and leave implicit the fact they are above a particular category. 

The definition of a fibred adjunction can be given an alternative form
in terms of a collection of adjunctions between corresponding fibres
of fibrations and a coherence property linking these adjunctions
together. To see this, we first introduce the following helpful
notation.  Given fibrations  and , a
fibred functor , and an object  of , we denote by
 the restriction of  to the fibre . We
know the image of  lies within  because  is fibred. We
have:

\begin{lemma}\label{lem:fibadj}
  Let  be a category, let  and  be
  fibrations, and let  be a fibred functor. Then  has a
  fibred left adjoint iff the following two conditions hold:
\begin{enumerate}[\em(1)]
\item for any  in ,  has a left adjoint , and
\item for every morphism  in  with associated reindexing
  functors  and  with respect to and ,
  respectively, the canonical natural transformation from
   to  obtained as the transpose\footnote{If
    , then the transpose of a morphism
     is  and the transpose of a
    morphism  is , where  and  are
    the unit and counit, respectively, of the adjunction .} of  is an isomorphism. Here,  arises from the fact that
  , and hence , preserves cartesian morphisms.
\end{enumerate}
\end{lemma}

\noindent
Suppose  is in  and  is in  in the setting of
Lemma~\ref{lem:fibadj}. Then , and if  is the unit of
 and  is the unit of , then
.

We conclude this section with a lemma about (non-fibred) adjunctions
and the preservation of cartesian and opcartesian morphisms.
\begin{lemma}\label{lem:adjandcart}
  Let  and  be fibrations. Further, let
   and  be adjoint functors  with
  vertical unit (or equivalently, counit) such that 
  and . Then the functor  preserves opcartesian
  morphisms and the functor  preserves cartesian morphisms.
\end{lemma}
\begin{proof}
  We prove only that  preserves cartesian morphisms; the second
  result is then obtained by dualising. Let  be a morphism
  in  and let  be the cartesian morphism above  in
  . We will prove that  is cartesian above  in . To
  do this, let  be a morphism in  above  for some
   in . Then the transpose  of  is above  in  because the counit  of the adjunction  is vertical. We then have a unique morphism  in
   above  such that  since  is
  cartesian. Because  is vertical, this gives us a unique
  morphism  in  above  such that .
\end{proof}

\subsection{Fibrational Induction in Another Nutshell}

At the heart of Hermida and Jacobs' approach to induction is the
observation that if  is a fibration and  is
a functor, then  can be lifted to a functor  and
the premises of the induction rule for  can be taken to be an
-algebra. Hermida and Jacobs observed that, crucially, this
lifting must be truth-preserving. We define these terms now.

\begin{definition}\label{def:multi}
  Let  be a fibration and  be a
  functor.  A {\em lifting} of  with respect to  is a functor
   such that .  If each
  fibre  has a terminal object, and if reindexing preserves
  terminal objects, then we say that  {\em has fibred terminal
    objects}. In this case, the map assigning to every  in  the
  terminal object in  defines a full and faithful functor 
  that is called the {\em truth functor} for  and is right adjoint
  to . We omit the subscript on  when this can be inferred. A
  lifting  of  is said to be {\em truth-preserving} if .
\end{definition}

The families fibration has fibred terminal objects: the terminal
object in the fibre above  is the function mapping each 
to the one-element set. The codomain fibration  also has
fibred terminal objects: the terminal object in the fibre above  is
. The subobject fibration has fibred terminal objects:
the terminal object in the fibre above  is the equivalence class of
.  A truth-preserving lifting  of  with
respect to  is given by the action of  on morphisms.
Truth-preserving liftings of functors with respect to the families
fibration and the subobject fibration over a regular category can be
obtained from the results of this section.

As mentioned in the introduction, in the fibrational approach to
induction the premises of an induction rule for a data type 
are taken to be an -algebra . But what
about the conclusion of such an induction rule? Since its premises are
an -algebra, it is reasonable to expect its conclusion to be
the unique mediating morphism from the initial -algebra to
.  But this expectation is thwarted because an initial
-algebra is not, in general, guaranteed to exist. We
therefore seek conditions ensuring that, for every functor  on the
base category of a fibration , its lifting  has an initial
algebra. Moreover, our examples below suggest that the carrier of this
initial -algebra should be , where  is the truth
functor for .  Fortunately, we already know that any
truth-preserving lifting  of  defines a functor  mapping an -algebra  to the -algebra .  Soundness of the induction rule thus turns out to be
equivalent to requiring that applying  to the initial
-algebra gives the initial -algebra. We capture this
discussion formally as follows:

\begin{definition}\label{def:ind}
  Let  be a fibration with truth functor  and
  let  be a functor whose initial algebra has carrier . We say that a truth-preserving lifting  of 
  \emph{defines a sound induction rule for  in } if the
  functor  preserves initial objects.
\end{definition}
\noindent
We will omit explicit reference to  when it is clear from context.
In the situation of Definition~\ref{def:ind}, the generic fibrational
induction rule is given by

and its soundness ensures that if  is above
, then  is above .

To see how the above categorical definition of an induction rule
corresponds to our intuitive understanding, we look at an example
before returning to the general discussion of fibrational induction.

\begin{example}
  The data type  of natural numbers is , where
   is the functor on  defined by . A lifting
   of  from  to  is given by

An -algebra with carrier  can
be given by  and .  Since  and , we see that  consists of an
element  and a function .  These are exactly the premises
of the standard induction rule we learn on the playground. As for the
conclusion of the induction rule, we first note that , so that the induction rule has as its conclusion a morphism
of predicates from  to  whose first component is
. The second component will be a function with type
, i.e., a function that gives,
for , a proof in . This is exactly as expected.
\end{example}

Definition~\ref{def:ind} naturally leads us to ask for conditions on a
fibration  guaranteeing that a truth-preserving lifting of a
functor  defines a sound induction rule for . Hermida
and Jacobs' key theorem states that a sufficient condition is that 
be a comprehension category with unit. 

\begin{definition}
  A {\em comprehension category with unit} (CCU) is a fibration  with a truth functor  that has a right adjoint
  . In this case,  is called the {\em comprehension
    functor} for .
\end{definition}
\noindent
We omit the subscript on  when this can be inferred from
context. 

The families fibration is a CCU: the comprehension functor maps a
predicate  to the set .  The
fibration  is the canonical CCU: the comprehension
functor is the domain functor  mapping
 in  to . The subobject fibration over a
category  is a CCU: the comprehension functor maps an equivalence
class to the domain of a (chosen) representative. As shown
in~\cite{hj98}, truth-preserving liftings for CCUs define sound
induction rules. That is,

\begin{theorem}\label{thm:ind}
  Let  be a CCU and  be a functor whose initial
  algebra has carrier . Then every truth-preserving lifting
   of  with respect to  defines a sound induction rule
  for .
\end{theorem}

The proof of this theorem is conceptually simple: Hermida and Jacobs
show that under the assumptions of the theorem, each functor 
has a right adjoint and therefore preserves all colimits, including
the initial object. This very elegant theorem shows that fibrations
provide just the right structure to derive sound induction rules for
inductive types whose underlying functors have truth-preserving
liftings. And it's amazing to see such structure captured so smoothly
as the existence of a pair of adjoints to the fibration
itself. However, there is still one missing ingredient, namely, a set
of conditions under which functors are guaranteed to have
truth-preserving liftings. Hermida and Jacobs~\cite{hj98} provided
truth-preserving liftings, and thus sound induction rules, only for
polynomial functors. This situation was rectified in~\cite{gjf10},
where it was shown that every functor has a truth-preserving lifting
with respect to every CCU that is also a bifibration. Such CCUs are
called {\em Lawvere categories}.

\begin{definition}
  A fibration  is a {\em Lawvere category} if
  it is a CCU that is also a bifibration.
\end{definition}

If  is the counit of the adjunction  for a
CCU , then  defines a natural transformation
. 
Moreover,  extends to a functor  in the obvious way.

\begin{lemma}\label{lem:deflifting}
  Let  be a Lawvere category. Then  has a
  left adjoint  defined by .
\end{lemma}
\noindent
For any functor , the composition  defines a truth-preserving lifting with respect to the
Lawvere category ~\cite{gjf11}. Here,  is the lifting
given after Definition~\ref{def:multi} of  to the total category of
the codomain fibration. Concretely, . Thus, if  is a Lawvere category and  has an initial
algebra , then Theorem~\ref{thm:ind} guarantees that 
defines a sound induction rule for . Indeed, we have:

\begin{theorem}\label{thm:inda}
If  is a Lawvere category and  is a
functor whose initial algebra has carrier , then there exists a
sound induction rule for  in .
\end{theorem}
\noindent
If  has pullbacks, so that the functor  is actually
a fibration, then the following diagram establishes that we have
actually given a uniform modular construction of a lifting with
respect to any Lawvere category by factorisation through the lifting
for :



\section{Coinduction}\label{sec:coind}

In~\cite{hj98}, Hermida and Jacobs augmented their sound fibrational
induction rules for carriers of initial algebras of polynomial
functors with a sound coinduction rule for carriers of final
coalgebras of polynomial functors. The goals of this section are to
recall the results of Hermida and Jacobs, and to extend them to give
sound coinduction rules for carriers of final coalgebras of functors.

Hermida and Jacobs begin by observing that coinduction is concerned
with relations. Given a fibration  whose total category is thought
of as a category of predicates, they therefore construct a new
fibration  whose total category is thought of as a category of
relations.

\begin{definition}\label{def:cob}
  Let  be a fibration where  has products, and let
   be the diagonal functor sending an object  to
  . Then the fibration  is obtained
  by the pullback of  along . We call  the {\em
    relations fibration} for .
\end{definition}

That the pullback of a fibration along any functor is a fibration is
well-known~\cite{jac94}, and the process of pulling back a fibration
along a functor  to obtain a new fibration is called {\em change of
  base} along . Since an opfibration from  to  is a
fibration from  to , change of base preserves
opfibrations as well as fibrations, and therefore preserves
bifibrations. Below we denote the pullback of {\em any} functor  along a functor  by . The
objects of  are pairs  such that , and 
maps the pair  to the object .  We write  for  in
 when convenient.

If  is a bifibration, then change of base along a
natural transformation  induces an adjunction
between  and . We have:

\begin{lemma}\label{lem:natadj}
  For  a bifibration and  a natural
  transformation with . There is an adjunction
  
  with
  
Furthermore, if  satisfies the Beck-Chevalley condition 
and the components of  are monos, then  is full
and faithful.
\end{lemma}
\begin{proof}
  Straightforward from the definitions of  and
   and Lemmas~\ref{lem:bifdef} and~\ref{lem:bcmono}.
\end{proof}

Definition~\ref{def:cob} entails that the fibre of  above 
is the fibre . A morphism from  to 
in  consists of a pair of morphisms  and
 such that . Change
of base is well-known to preserve fibred terminal
objects~\cite{her93b}. It therefore preserves truth functors, so that
 has a truth functor whenever  does. This is given by
.

\begin{example}
Let  be the families fibration. Then the fibre of  above a
set  consists of functions . These are, as
intended, just (set-valued) relations. The truth functor for 
maps a set  to the relation  that maps
each pair  to the one-element set.
\end{example}

In the inductive setting, truth-preserving liftings were needed. In
the coinductive setting, we need equality-preserving liftings, where
the equality functor is defined as follows:

\begin{definition}\label{def:eq-fun}
  Let  be a bifibration where  has products, and let
   be the truth functor for . Let  be the diagonal natural transformation for  with
  components , and let  be the functor mapping an object  above  to
  the object . Note that  is
  above  in  and above  in . The {\em
    equality functor} for  is the functor 
  defined by . The functor  maps each
  morphism  to the unique morphism above  induced by
  the naturality of  at  and the opcartesian morphism
  . If  has a left adjoint , then 
  is called the {\em quotient functor} for .
\end{definition}
\noindent
We suppress the subscripts on  and  when convenient. The
notion of an equality-preserving lifting of a functor is then defined
as follows:

\begin{definition}
  Let  be a bifibration where  has products, suppose
   has a truth functor, and let  be a functor. A
  lifting  of  with respect to  is said to be
  {\em equality-preserving} if .
\end{definition}

Just as truth-preserving liftings are the key to defining induction
rules, equality-preserving liftings are the key to defining
coinduction rules. The following definition is pleasantly dual to
Definition~\ref{def:ind}:

\begin{definition}\label{def:coind}
  Let  be a bifibration where  has products, suppose
   has a truth functor, and let  be a functor whose
  final coalgebra has carrier . We say that an -preserving
  lifting  of  \emph{defines a sound coinduction rule for
     in } if the functor  sending each -coalgebra  to the
  -coalgebra  preserves terminal objects.
\end{definition}

\noindent
As before, we omit explicit reference to  when it is clear from context.

As in~\cite{hj98}, there is a simple condition under which
-preserving liftings define sound coinduction rules, namely, that
 has a quotient functor. Note the duality: in the inductive setting
the truth functor  must have a right adjoint, whereas in the
coinductive setting the equality functor  must have a left
adjoint.

\begin{theorem}\label{thm:coind}
  Let  be a bifibration where  has products, suppose
   has a truth functor and a quotient functor, and let  be a functor whose final coalgebra has carrier . Then
  every equality-preserving lifting  of  with respect to
   defines a sound coinduction rule for .
\end{theorem}

As before, Hermida and Jacobs' proof is conceptually simple: If 
has a quotient functor, then each functor  has a left
adjoint and hence preserves all limits, including the terminal
object. As a result, the carrier of the final -coalgebra is
obtained by applying  to the final -coalgebra, and the generic
fibrational coinduction rule is therefore given by
 
\noindent
Soundness of the rule ensures that if  is
above , then  is above .

As was the case for induction, Hermida and Jacobs provided
-preserving liftings only for polynomial functors, and thus sound
coinduction rules only for carriers of their final coalgebras.  The
outstanding issue is then to establish a set of conditions under which
functors are guaranteed to have equality-preserving liftings.

\subsection{Generic Coinduction For All Coinductive Types}

The first contribution of this paper is to give a sound coinduction
rule for every coinductive type, i.e., for every data type that
is the carrier  of the final coalgebra for a functor . This
entails determining conditions sufficient to guarantee that functors
have equality-preserving liftings.  To do this, we step back a little
and show how to construct liftings that can be instantiated to give
both the truth-preserving liftings required for deriving sound
induction rules and, by duality, the equality-preserving liftings
required for deriving sound coinduction rules.

\begin{lemma}\label{lem:coindlift}
  Define a {\em quotient category with equality} (QCE) to be a
  fibration  with a full and faithful functor 
  such that  and  has a left adjoint  with
  unit . Let  be a functor, and define functors
  , , and  by

Then  (i.e.,  is a lifting of ) and
.
\end{lemma}
\begin{proof}
  To prove , note that the morphisms  each
  have domain , that , and
  that . Together these give .  To prove , we first
  assume that i) for every  in ,  is an isomorphism
  in , and ii) for every isomorphism  in , . Then since , we have that
  i) and ii) imply that . To discharge
  assumption i), note that the counit  of  is a natural isomorphism because  is full and faithful. We
  thus have that  is also a natural isomorphism and, using
  the equality , that  is a
  natural isomorphism as well. As a result,  is a
  natural isomorphism.
To discharge ii), let  be an isomorphism in . Since cartesian
morphisms above isomorphisms are isomorphisms, we have .
Here, the first isomorphism is witnessed by  and the second by
  .
\end{proof}

Although it is not needed in our work, we observe that if  is a QCE,
then  is left adjoint to . The proof is a straightforward
application of the universal property of reindexing; see Lemma~2.2.10
in~\cite{fum12}. The lifting  has as its dual the lifting
 given in the following lemma.

\begin{lemma}\label{lem:indlift}
  Let  be an opfibration, let  a full and
  faithful functor such that , and let  be a
  right adjoint to  with counit . Let  be
  a functor, and define functors , , and  by

Then  (i.e.,  is a lifting of ) and .
\end{lemma}
\begin{proof}
  By dualisation of Lemma~\ref{lem:coindlift}. The setting on the left
  below with  an opfibration is equivalent to the setting on the
  right with  a fibration.
  
\end{proof}

We can instantiate Lemmas~\ref{lem:coindlift} and~\ref{lem:indlift} to
derive both the truth-preserving lifting for all functors
from~\cite{gjf10} (presented above) and an equality-preserving lifting
for all functors. The latter gives the sound induction rules for
inductive types presented in~\cite{gjf10}, and the former gives our
sound coinduction rules for all coinductive types. To obtain the
lifting for induction, let  be a Lawvere category,  be
the truth functor for , and  be the comprehension functor for
. Since a Lawvere category is an opfibration,
Lemma~\ref{lem:indlift} ensures that any functor  lifts
to a truth-preserving lifting . This is exactly the
lifting of~\cite{gjf10}. To obtain the lifting for coinduction, let
 be a bifibration satisfying the Beck-Chevalley
condition, let  have products, and let  be a truth functor for
. Now, consider the relations fibration  for , and let
 be the equality functor for . Since  is a mono, since
, and since both  and 
are full and faithful, Lemma~\ref{lem:bcmono} ensures that  is
full and faithful. Moreover, since, for every  in ,  is
in the fibre of  above , we have . We can therefore take  to be  in
Lemma~\ref{lem:coindlift} provided  has a left adjoint .  In
this case, every functor  has an equality-preserving
lifting , and so if  has a final
coalgebra , then  has a sound coinduction rule. We
record this in the following theorem. Henceforth, we call a QCE of the
form  obtained by change of base of  along  by the
above construction, and for which the functor  is thus the equality
functor for , a {\em relational QCE}.

\begin{theorem}\label{thm:coinda}
If  is a relational QCE obtained from a
fibration , and if  is a functor whose
final coalgebra has carrier , then there exists a sound
coinduction rule for  in U.
\end{theorem}

Just as  is the canonical CCU, if  is the
canonical QCE. Indeed, if  is , if
 is the functor mapping each  in  to , and if
 is , then  is exactly
. Thus, just as the lifting  with respect to an
arbitrary fibration  satisfying the hypotheses of
Lemma~\ref{lem:indlift} can be modularly constructed from the specific
lifting  with respect to ~\cite{gjf10}, so the
lifting  with respect to an arbitrary fibration 
satisfying the hypotheses of Lemma~\ref{lem:coindlift} can be
modularly constructed from the specific lifting  with respect
to .

What we have seen is that  plays a role in the
coinductive setting similar to that played by  in the
inductive one. We think of a morphism  in the total
category of  as a predicate on  whose proofs
constitute . Intuitively,  maps each  in  to the element
 in  about which it is a proof. Similarly, we think of a
morphism  in the total category of  as a
relation on , the quotient of  by which has equivalence classes
comprising . Intuitively,  maps each  in  to its
equivalence class in that quotient.

The following two examples of relational QCEs appear in
Propositions~4.8.6 and~4.8.7(iii) in~\cite{jac99}.

\begin{example}
  Let  be a regular category. The relations fibration for the
  subobject fibration  is a relational QCE iff 
  has coequalisers. In this case, the equality functor maps an object
   of  to the equivalence class of  in
  . The quotient functor maps an equivalence class ,
  with , to the codomain
   of the coequaliser  of  and :
  
  \end{example}
  
  \begin{example}
    Consider the fibration  of admissible subsets of
    complete lattices and its associated relations fibration
    .  We have that  is a relational
    QCE. Indeed, the equality functor  maps a
    complete lattice  to the admissible subset .  The quotient functor
       maps an admissible subset  to the complete lattice .
  \end{example}

\begin{example}\label{ex:famrel}
  As we have seen, if  is the families fibration, then the fibre
  above  in  consists of functions . We think of these functions as constructive relations, with
   giving the set of proofs that  is related to . In
  Lemma~\ref{lem:coindlift} we can take  to be the families
  fibration,  to map each set  to the relation  defined by
   if  and  otherwise, and
   to map each relation  to the quotient
   of  by the least equivalence relation containing . We
  can then instantiate Lemma~\ref{lem:coindlift} by taking  to map a relation  to the
  quotient map , taking  to
  map  to the relation  mapping  to  if
   and to  otherwise, and taking  to be given by .
\end{example}

The following example demonstrates that our approach goes beyond the
current state-of-the-art. We derive the coinduction rule for finitary
hereditary sets in the relations fibration for the families
fibration. Finitary hereditary sets are elements of the carrier of the
final coalgebra of the functor  mapping a set to its finite
powerset. Since  is not polynomial, it lies outside the scope of
Hermida and Jacobs' work~\cite{hj98}. In fact, as far as we aware, the
coinduction rule for finitary hereditary sets that we derive in the
next example is more general than any appearing elsewhere in the
literature; indeed, the relations in  are not required to be
equivalence relations. The functor  is, however, important, not
least because a number of canonical coalgebras are built from it. For
example, a finitely branching labelled transition system with state
space  and labels from an alphabet  is a coalgebra with carrier
 for the functor .

\begin{example}\label{ex:coind}
  By Example~\ref{ex:famrel}, the lifting  maps a
  relation  to the relation  defined by . Thus, if  and  are finite subsets of , then  iff . Since
  the action of  on a morphism  maps any subset of the domain
  of  to its image under ,  iff
  , where
   is the least equivalence relation
  containing . From  we have that the resulting
  coinduction rule has as its premises a -coalgebra,
  i.e., a function  and a function . If we regard  as a transition
  function, i.e., if we define  iff , then
   is a bisimulation whenever  is an equivalence
  relation. In this case, the coinduction rule thus asserts that any
  two bisimilar states have the same interpretation in the final
  coalgebra.  However, when  is not an equivalence relation,
   is slightly weaker since it only requires
  transitions to map -related elements -related
  elements.  Since it is easier to prove that two elements are -related than it is to prove them -related, our coinduction
  rule is slightly stronger than might be expected at first glance.
\end{example}

\section{Indexed Induction}\label{sec:indind}

Data types arising as initial algebras and final coalgebras on
traditional semantic categories such as  and 
are of limited expressivity. More sophisticated data types arise as
initial algebras of functors on their indexed versions. To build
intuition about the resulting {\em inductive indexed types}, first
consider the inductive type  of lists of . It is
clear that defining  for some particular type 
does not require any reference to  for . That is, each type  is inductive all on its
own. We call  an {\em indexed inductive type} to
reflect the fact that it is a family of types, each of which is
inductive. By contrast, for each  in , let 
be the data type of -element sets, and consider the inductive
definition of the -indexed type  of
untyped -terms up to -equivalence with free variables
in . This type is given by

Unlike , the type  cannot be defined in
isolation using only the elements of  that have already been
constructed. Indeed, the third inference rule above shows that
elements of  are needed to construct elements of . In effect, then, all of the types  must be inductively
constructed simultaneously. We call  an {\em inductive indexed
  type} to reflect the fact that it is an indexed type that is defined
inductively.

There is considerable interest in inductive and coinductive indexed
types. If types are interpreted in a category , and if  is a
set of indices considered as a discrete category, then an inductive
-indexed type can be modelled by the initial algebra of a functor
on the functor category . Alternatively, indices can be
modelled by objects of , and inductive -indexed types can be
modelled by initial algebras of functors on slice categories
. Coinductive indexed types can similarly be modelled by final
coalgebras of functors on slice categories.

Initial algebra semantics for inductive indexed types has been
developed extensively~\cite{dyb94,ma09}. Pleasingly, no fundamentally
new insights were required: the standard initial algebra semantics
needed only to be instantiated to categories such as . By
contrast, the theory of induction for inductive indexed types has
received comparatively little attention. The second contribution of
this paper is to derive sound induction rules for inductive indexed
types by similarly instantiating the fibrational treatment of
induction to appropriate categories.  The key technical question to be
solved turns out to be the following: Given a Lawvere category of
properties fibred over types, can we construct a new Lawvere category
fibred over indexed types from which sound induction rules for
inductive indexed types can be derived? To answer this question, we
first make the simplifying assumption that the inductive indexed types
of interest arise as initial algebras of functors on slice categories,
i.e., functors , where  is an object of . We
treat the general case in Section~\ref{sec:fibind}.

We conjecture that the total category of the fibration with base
 that we seek should be a slice category of . We therefore
make the canonical choice to slice over , where  is the truth
functor for . We then define  by . Here,  really is
 because .

We first show that  is indeed a bifibration. We do this by
proving a more general result that we can reuse in
Section~\ref{sec:indcoind}. 

\begin{lemma}\label{lem:slbif}
  Let  be a fibration (bifibration) with a functor
   and  such that . This, of course,
  uniquely determines . For any  in , the functor
   is a fibration (resp., bifibration).
\end{lemma}
\begin{proof}
  Let  and  be objects of , and
  let  be a morphism in  from  to ,
  i.e., let  be such that . Let  be an object of  such that , and
  let  be the cartesian morphism in  above
   with respect to . Then  is a morphism in
   with domain  and codomain , and it is
  cartesian above  with respect to . Thus,  is a
  fibration if  is. Now, let  be an object of 
  such that , and let  be the opcartesian morphism in  above  with
  respect to . Since , the opcartesianness of
   ensures that there is a unique morphism  in  above  such that . Then
   is a morphism in  with domain  and codomain
  , and it is opcartesian above  with respect to . Thus,
   is an opfibration if  is. Combining these results gives
  that if  is a bifibration then so is .
\end{proof}

We can now show that  is a bifibration as desired.

\begin{lemma}\label{lem:bif}
  If  is a fibration (bifibration) with a truth functor 
  and  is an object of , then  is a fibration (resp.,
  bifibration).
\end{lemma}
\begin{proof}
This follows from Lemma~\ref{lem:slbif} by taking  to be the truth
functor  for  and  to be , and then observing
that, for this instantiation,  is precisely the fibration 
defined before Lemma~\ref{lem:slbif}.
\end{proof}

There is an alternative characterisation of  that both
clarifies the conceptual basis of our treatment of indexed induction
and simplifies our calculations. The next lemma is the key observation
underlying this characterisation.
\begin{lemma}\label{lem:simindex}
  Let  be a fibration with truth functor , let 
  be an object of , and let . Then
  .
\end{lemma}
\begin{proof}
  One half of the isomorphism maps the object  of
   to . For the other half, note that since truth
  functors map objects to terminal objects, and since reindexing
  preserves terminal objects, we have that  is terminal
  in . Thus, for any object  above , we get a morphism
  from  to  by composing  and the unique
  morphism  from  to . Since  is vertical and
   is above , this composition is above
  . Thus each object  in  maps to an object of
  . It is routine to verify that these maps
  constitute an isomorphism.
\end{proof}
By Lemma~\ref{lem:simindex} we can identify objects (morphisms) of
 and objects (resp., morphisms) of .  This
gives our abstract characterisation of :
\begin{lemma}\label{lem:U/Icob}
  Let  be a fibration with a truth functor and let 
  be an object of .  Then  can be obtained by change of base
  of  along .
\end{lemma}
\begin{proof}
  As noted in Section~\ref{sec:coind}, the pullback of a fibration
  along a functor is a fibration. The objects (morphisms) of the fibre
  above  of the pullback of  along 
  are the objects (resp., morphisms) of . By
  Lemma~\ref{lem:simindex}, the pullback of  along 
  is therefore .
\end{proof}

As observed just after Definition~\ref{def:cob}, pulling back a
fibration along a functor preserves fibred terminal objects so, by
Lemma~\ref{lem:U/Icob},  has fibred terminal objects if 
does. Concretely, the truth functor  maps an
object  to . To see that  is a Lawvere
category if  is, we must also show that  has a right
adjoint if  does. For this, we use an abstract theorem due to
Hermida~\cite{her93} to transport adjunctions across pullbacks along
fibrations.

\begin{lemma}\label{lem:claudio}
  Let  be an adjunction with counit ,
  and let  be a fibration. Then the functor  has a right adjoint  mapping each object
   to the object .
\end{lemma}

\begin{lemma}\label{lem:pb-pres}
  Change of base along a fibration preserves CCUs, i.e., if  is a CCU and  is a fibration, then the pullback
   is a CCU.
\end{lemma}
\begin{proof}
  We already have that  is a fibration with fibred terminal
  objects. To see that  has a right adjoint, consider the
  pullback of  along .  This pullback is given by ,
  , and . Note that
   is a fibration since it is obtained by pulling  back
  along . Lemma~\ref{lem:claudio} then ensures that, since 
  has a right adjoint, so does . Thus  is a CCU.
\end{proof}

If  is a fibration,  is an object of , and 
is , then the comprehension functor for
 --- i.e., for  --- maps an object  to . Combining Lemma~\ref{lem:pb-pres} and the fact
that change of base preserves bifibrations, we have:

\begin{lemma}\label{lem:coblwfib}
  Let  be a Lawvere category and  be a
  fibration. Then  --- i.e.,  --- is a Lawvere category.
\end{lemma}
\noindent

\begin{theorem}\label{thm:iinda}
Let  be a Lawvere category, let  be an object of
, and let  be a functor whose initial algebra
has carrier . Then there exists a sound induction rule for  in .
\end{theorem}

We can use Theorem~\ref{thm:iinda} to derive a sound induction rule
for the indexed containers of Morris and Altenkirch~\cite{ma09}.

\begin{example}\label{ex:indind}
  If  is a set, then the {\em category of -indexed sets} is the
  fibre . An {\em -indexed set} is thus a function
  , and a morphism  from  to , written , is a function of type . Morris and Altenkirch denote this category  and
  define an {\em -indexed container} to be a pair  with  and . An
  -indexed container defines a functor  by .  Thus, if , then  is of the form
  . If  is a morphism of -indexed sets, then
   maps a pair  to .

  If , then we can think of  as a collection of
  operators that produce data of sort , and we can think of  as
  assigning to every  and every operator producing data of sort 
  an -indexed collection of positions in which data is stored. That
  is,  is the set of positions associated with the
  operator  where data of sort  must be stored. This {\em shapes
    and positions metaphor} is also reflected in the functor
  associated with an indexed container, since we can think of  as containing terms of sort  produced by  whose input
  data is drawn from . Such a term consists of an operator 
  producing data of sort  and, for each position storing data of
  sort , an element of  of sort .

  The initial algebra of  is denoted .  Since  is equivalent to , we
  can use the results of this section to extend those of~\cite{ma09}
  by giving sound induction rules for data types of the form
  . A predicate over an -indexed set  is a function .  To simplify notation, this is written
  . The lifting  of  maps each
   to the predicate  defined by .  Altogether, this gives the following sound induction rule for
  :


\vspace*{0.15in}

While admittedly rather dense in its type-theoretic formulation, the
above induction rule is conceptually clear. The premise says that, for
any term  in , we must be able to
prove that a property  holds at
 if  is assumed to hold of all the immediate
subterms of . The conclusion of the rule says
that  holds for all terms. Of course this is what we naturally
expect, and our point is precisely that we can {\em derive it in a
  principled manner} from the fibrational approach to induction rather
than simply having to postulate that it is reasonable.

We can instantiate the above induction rule for  for the data
type of untyped lambda terms from the beginning of this section. The
resulting induction rule cannot be derived using Hermida and Jacobs'
techniques because the data type of untyped lambda terms is not the
initial algebra of a polynomial functor. The resulting rule is
precisely what we expect. For any predicate :


\end{example}

\section{Indexed Coinduction}\label{sec:indcoind}

We now present our third contribution, namely sound coinduction rules
for coinductive indexed types. Examples of such types are infinitary
versions of inductive indexed types, such as infinitary untyped lambda
terms and interaction structures. Following the approach of
Section~\ref{sec:indind}, we consider indexing by slice categories in
this section. In more detail, we show that for any relational QCE over
a base category  and for any object  of , change of base
along  yields a relational QCE over .

Recall that if  has products and  is a bifibration
that satisfies the Beck-Chevalley condition and has truth functor ,
then the equality functor  for  is given by . Let  be a relational QCE, so
that  has a left adjoint . To define a relational QCE over
 we must first see that  has products. But the product of
 and  in  is determined by their pullback: if , , and  give the pullback of  and , then their
product in  is the morphism  or, equivalently, . Below,
we write  for the product of  with itself in 
and  for the domain of . Now, if  has pullbacks, then
we can construct the relations fibration 
from the pullback of  along the product functor  mapping  to . Concretely, an object of 
above  is an object of  above  with respect to
. This is, in turn, equivalent to an object of  above 
with respect to .

\subsection{The Equality Functor for }\label{sec:eqU/I}

In Section~\ref{sec:indind} we showed that if  is a bifibration
where  has products, and  has a truth functor , then for any
object  of ,  is a bifibration that has a truth functor
whose action is also that of , and so is denoted  as
well. Furthermore, we have just seen that if  has pullbacks, then
 also has products.  Thus, by Definition~\ref{def:eq-fun}, 
has an equality functor . To define this functor concretely,
note that the component of the diagonal natural transformation
 at  is the
mediating morphism in the diagram below on the left.  Thus, 
maps an object  of  to the unique morphism above
 in the diagram on the right induced by the opcartesian morphism
 above :
 
Note that if  satisfies the Beck-Chevalley condition, so that
opreindexing for  defines a full and faithful functor, then the
fact that the action of opreindexing for  is the same as
opreindexing for  means that opreindexing for  defines a full
and faithful functor as well.
Since truth functors are always full and
  faithful, so is .

\subsection{The Quotient Functor for }

Whereas defining the equality functor for  was straightforward,
defining its quotient functor is actually tricky.  To do so, for each
object  of , we we write 
for the fibration obtained as the instantiation of
Lemma~\ref{lem:slbif} in which  plays the role of
 and  plays the role of . Concretely, the objects of
 above  are morphisms , for some object  of , such that . Our first result identifies conditions under which  is a
QCE.

\begin{lemma}\label{lem:lift-qce}
  Let  be a fibration, let  have pullbacks, let 
  be an object of , and let  be a
  relational QCE. Then  is a QCE.
\end{lemma}
\begin{proof}
  Let  and  be the equality
  and quotient functors for , respectively. We construct a full and
  faithful functor  such that , and a left adjoint  for , as
  follows. Take  to be . Then  is full and faithful since
   is. Moreover, for any ,
  Definition~\ref{def:eq-fun} ensures that  is above  with respect to , so , and thus
  . Finally, we define  to map each
  object  of  to its transpose
   under the adjunction . That  follows directly from .
\end{proof}

We can now define the quotient functor for  using the
functor  from the proof of Lemma~\ref{lem:lift-qce}. The key step
is to use Lemma~\ref{lem:natadj} to define an adjunction  such that the following diagram commutes:
 

\vspace*{0.1in}

\noindent
Then if  and  are the functors witnessing the fact that
 is a QCE, compositionality of adjoints ensures that
 and  give equality and quotient functors for
, respectively.

\vspace*{0.1in}

\begin{lemma}\label{lem:tausigma}
  The above adjunction  holds. 
\end{lemma}
\begin{proof}
  In order to prove this lemma, we first instantiate
  Lemma~\ref{lem:slbif}, with  playing the role of  and
   playing the role of , to obtain the fibration
  . We then have the following three
  changes of base:
  
  Here, the functor  maps  to
  , and  maps  to . The square on the left is a pullback square by
  definition of , and the one on the right is a pullback
  square by direct calculation. To see that the middle square is a
  pullback square, first observe that since every morphism
   is a mono, Lemma~\ref{lem:bcmono} ensures
  that each opcartesian morphism  is also
  cartesian.  For any , the fibre above  of the pullback
  of  along  consists of all
  morphisms of the form  such that . Similarly, the fibre of  above  consists of all
  morphisms of the form  such that . The
  universal property of  considered as a cartesian
  morphism ensures that these two fibres are isomorphic, and thus that
   is indeed the pullback of  along .

  Now, let  be a morphism in , and let  and  be
  the projections for the pullback square defining . The
  universal property of the product  ensures the existence
  of a morphism  such that 
  and .  Moreover, by the universal property of the
  pullback of  along itself,  is a mono. In fact, it is easy
  to check that there is a natural transformation  whose component at any  is given by
  .  Finally,  extends to a natural transformation . Indeed, for any
  , the fact that  for  ensures that the diagram
  
  commutes by the universal property of the product .  By
  Lemma~\ref{lem:natadj},  induces the desired adjunction.
\end{proof}

Recall that our candidate for the quotient functor  for
 is . To see that , we need
only verify that  is . It is routine to check
that , from which 
follows. We therefore have that , together with 
 and  as defined above, form a relational
QCE. Thus, by Theorem~\ref{thm:coinda}, we have 

\begin{theorem}\label{thm:icoinda}
  Let , where  has products and pullbacks, be a
  bifibration that satisfies the Beck-Chevalley condition. Suppose 
  has a truth functor. Let  be an object of  and  be a functor whose final coalgebra has carrier . Then
  there exists a sound coinduction rule for  in .
\end{theorem}

We can use the results of this section to give a sound coinduction rule
for final coalgebras of indexed containers that is dual to the
sound induction rule of Example~\ref{ex:indind}.

\begin{example}\label{ex:coindcont}
  Let  be an -indexed container with final coalgebra
  . A relation above an
  -indexed set  is an -indexed family of relations
   on . The relational lifting of  maps a relation
   above an -indexed set  to the relation  above the
  -indexed set  that relates  and  iff  and, for all  and ,  is related to  in the least
  equivalence relation containing . This gives the following
  notion of bisimulation for -coalgebras .
  Let  and . Then if , then  iff  and, for
  all  and , we have that
  .  As in
  Example~\ref{ex:coind}, the coinduction rule thus asserts that any
  two bisimilar states have the same interpretation in the final
  coalgebra.
\end{example}

Stepping back, we see that the above coinduction rule is as
expected. To understand it, we think of a term  as being
part of a transition system whose terms are the subterms of 
(including  itself), and suppose there is a transition from every
subterm to each of the immediate subterms of that term. Then two terms
are bisimilar iff they share the same root operator and each of their
subterms are bisimilar. The point is, of course, that the fibrational
approach to coinduction derives the rule in a principled manner rather
than simply having to postulate it. 

\section{Fibred Induction}\label{sec:fibind}

In Section~\ref{sec:indind} we saw how the fibrational approach to
induction can be instantiated to derive sound induction rules for
inductive indexed types when the indexing is given using slice
categories. Although it provides a good example of how to exploit the
abstract power of fibrations, this instantiation suffers from two
limitations:

\vspace*{0.1in}

\begin{iteMize}{}
\item First, the instantiation successfully treats indexing that is
  modelled by slice categories, but neither it nor its abstract
  generalisation can successfully handle more general forms of
  indexing. Indeed, in Section~\ref{sec:indind}, the fact that the
  comprehension functor  is a fibration was critical to
  showing that  is a Lawvere category, but the abstract
  generalisation of this result does not hold because, in general, a
  comprehension functor need not be a fibration. To handle general
  forms of indexing, we therefore need a genuinely new idea.

\item Secondly, in Section~\ref{sec:indind} we handle -indexed
  types by deriving from a Lawvere category  a Lawvere
  category  with base category . But this is inelegant
  because it requires the construction of a new Lawvere category for
  every possible index , and because the uniformity over  that
  connects the different fibrations  is completely ignored.
  Indeed, if we think of fibrations as modelling logics over types,
  then the results of Section~\ref{sec:indind} ostensibly choose
  entirely different logics for different indices. A better approach
  would formalise the uniformity of the fibrations  over the
  indices .
\end{iteMize}

\vspace*{0.1in}

\noindent In this section we extend the work of Section~\ref{sec:indind} to
derive sound induction rules for general indexed types. This is
accomplished by adding an abstraction layer that models the way types
are indexed, and thus allows us to treat indexing modelled by
structures other than slice categories. More specifically, we consider
indexed types to be given by a second fibration , so that
the objects of  are types indexed by the objects of . Of
course, the logical layer still forms a fibration  over
types, so we get the following basic picture, which captures the move
from a single fibration  to a fibration  above a fibration :
 

\vspace{0.1in}

\noindent
Note that  is a fibration because the composition of two
fibrations is again a fibration. Taking  to be the
category with one object and one morphism, the sound induction rules
in the unindexed setting will be recoverable from the sound induction
rules for general indexed types that we develop in this section; see
Example~\ref{ex:sec2} below. The sound induction rules in the indexed
setting of Section~\ref{sec:indind} will similarly be recoverable by
taking  to be the codomain fibration; see
Lemma~\ref{lem:canlwfiba}.  In addition, taking  to be the families
fibration, we will be able to derive the sound induction rules for
carriers of initial algebras of indexed containers directly, rather
than deriving them indirectly, as we did in Example~\ref{ex:indind},
using the equivalence of the families fibration and the codomain
fibration.

Let  and  be two fibrations. Then an
{\em inductive indexed type} with index , where  is an object of
, is the carrier  of the initial algebra of an endofunctor
, where  is the fibre of  above . To
derive a sound induction rule for  using
Theorem~\ref{thm:inda}, we will ultimately need a Lawvere category
with base ; indeed, by the discussion immediately following
Lemma~\ref{lem:deflifting}, this will ensure the existence of a
lifting of  to the total category of that Lawvere category. So,
what might we take as that Lawvere category? Since  has domain
 rather than all of , we cannot expect  to lift to the
whole of . On the other hand,  does restrict to a fibration
, where  is the fibre of  above .  As
we will see in Corollary~\ref{cor:iind} below,  is precisely the
Lawvere category we seek.

We begin by establishing the properties of  that we will
need. The following lemma uses change of base to deduce several of
them.

\begin{lemma}\label{lem:fibredfib}
  Let  and  be two fibrations. For any object
   in , the fibration  restricts to a fibration
  , where  is the fibre above  of the
  fibration . Similarly, if  is an opfibration or a
  bifibration, then so is . Finally, if  has a truth functor,
  then so does .
\end{lemma}
\begin{proof}
  The fibration  arises by change of base of 
  along the inclusion functor :
 
Pulling back an opfibration along a functor produces an opfibration,
so  is an opfibration if  is. As a result,  is a
bifibration if  is. Moreover, change of base preserves truth
functors, so  has a truth functor if  does. Indeed, the truth
functor for  is just the restriction of the truth functor for 
to .
\end{proof}
\noindent
We write  for the truth functor for . Note that while a
truth functor always restricts to a subfibration , the existence
of a truth functor  for every  does not necessarily imply
that  itself has a truth functor. For this to be the case,
reindexing must preserve truth functors from one subfibration to
another. Of course, if  is a bifibration, then reindexing is a
right adjoint, so it preserves terminal objects, and in this case the
individual truth functors  actually do collectively define a
truth functor for .

Our interest in the above results is that they show that the basic
structure of a logic (reindexing, opreindexing, and truth functors)
over a fibration of indexed types restricts to a corresponding logic
over types with a specific index. We may therefore consider
truth-preserving (i.e., -preserving) liftings of functors , and ask when such a lifting defines a sound induction rule
for .  From Theorem~\ref{thm:ind} we know the answer: this
occurs when the fibration  is a CCU. But now we
face a choice. Is it enough to simply ask that, for every object 
of ,  is a CCU? Or should we require that these different
CCUs, when taken collectively, ensure that  is a CCU?

While the former choice is indeed possible, we believe that the latter
choice better highlights the uniformity connecting the different
fibrations . In fact, we have already implicitly made the latter
choice when we started with a single fibration  and constructed
from it the collection of individual fibrations . Unfortunately,
asking that each fibration  is a CCU does not ensure that 
itself is a CCU.
On the other hand, we cannot simply require  to be a CCU either,
since that is not enough to guarantee that each  is a CCU. But if
we require  to be a fibred CCU in the sense of Definition~4.4.5 of
\cite{jac91}, then  will indeed be a CCU whose restriction to each
subfibre  is also a CCU. We have:

\begin{definition}\label{def:ccua}
  Let  and  be two fibrations, and let
   the truth functor for . We say that  is a
  \emph{fibred CCU above } if  has a fibred right adjoint
  : 
\end{definition}
\noindent
That  is a fibred functor follows from the fact that  is also a fibred functor (see Lemma~1.8.8
of~\cite{jac99}). A first consequence of Definition~\ref{def:ccua} is
that, if a fibration  is a fibred CCU above  then  is
a CCU. Furthermore, from Lemma~\ref{lem:fibadj} we have that if 
is a fibred CCU above , then each fibration  is a CCU. In
fact, we have the following correspondence: 

\begin{lemma}\label{lem:ccuafibadj}
  Let  and  be fibrations. The fibration  is
  a fibred CCU above  with fibred adjunction  iff
   is a CCU with truth functor  and comprehension
  functor  and, for each  in , the fibration
   is a CCU with comprehension functor
   given by restricting  to .
\end{lemma}

\begin{proof}
  Let  be a CCU with truth functor  and comprehension
  functor .  Further, suppose that, for every  in
  , the fibration  is a CCU whose comprehension
  functor  is given by restricting  to
  .  Then, by Lemma~\ref{lem:adjandcart}, we have that 
  is fibred from  to . Moreover, since the adjunction
   restricts to the adjunctions ,
  the unit of  is vertical with respect to .  The
  other direction of the equivalence is straightforward.
\end{proof}

\noindent
We have thus shown that a fibred CCU  above  is just the right
structure for deriving sound induction rules when indexing of types is
described by . We wanted a structure to guarantee that each 
is a CCU and that these individual CCUs collectively ensure that 
is also a CCU. Lemma~\ref{lem:ccuafibadj} shows that a fibred CCU
above  guarantees exactly this --- no more, no less.

Definition~\ref{def:ccua} straightforwardly extends to Lawvere
categories as follows:

\begin{definition}\label{def:lwfiba}
  Let  and  be fibrations. We say that  is a
  {\em fibred Lawvere category above } if  is a fibred CCU above  
  and  is a bifibration.
\end{definition}

\noindent
The next two corollaries are immediate.

\begin{corollary}\label{cor:lwfaadj}
  Let  and  be fibrations. Then  is a fibred
  Lawvere category above  iff  is a Lawvere category and, for
  every  in ,  is a Lawvere category whose
  unit and comprehension are given by the restrictions of the unit and
  comprehension, respectively, of  to .
\end{corollary}

\begin{corollary}\label{cor:iind}
  Let  be a fibred Lawvere category above . For
  any object  of  and functor , any
  -preserving lifting  of  defines a
  sound induction rule for . In particular, the canonical
  -preserving lifting from Section~\ref{sec:ind} defines a sound
  induction rule for .
\end{corollary}

Our first example shows that fibred induction is applicable in
situations in which indexed induction is not.

\begin{example}
Consider the mutually recursive data type

\vspace*{-0.05in}



\vspace*{0.1in}

\noindent
If we model types in a category , then we can model the
-indexed data type of  and  using the initial algebra
of the functor  defined by .
However, we may wish to index data types by sets other than .
The codomain fibration  defines a
fibred Lawvere category over the families fibration.  We therefore
have the following induction rule in the families fibration for any
predicates  and :


\end{example}

\vspace*{0.1in}

We can also see the induction rule of Theorem~\ref{thm:inda} as an
instance of fibred induction:

\begin{example}\label{ex:sec2}
  Let  be a Lawvere category. If  is the category with
  one object and one morphism, then  is a fibred Lawvere category
  above the fibration . Moreover, the treatment of
  induction from Section~\ref{sec:ind} is equivalent to the treatment
  of induction for this fibred Lawvere category.
\end{example}

And we can see indexed induction as an instance of fibred induction:

\begin{lemma}\label{lem:canlwfiba}
  Let  be a Lawvere category. The fibration
   obtained by the change of base
   is a fibred Lawvere category above the codomain fibration and,
  for any  in , .
\end{lemma}
\begin{proof}
  Consider the following setting:
   By Lemma~\ref{lem:coblwfib},  is a
  Lawvere category because it arises by change of base along the
  fibration . Moreover, for any object  of , the fibration
   can be obtained by the change of base
  

\vspace*{0.05in}

\noindent
  where  is the inclusion functor. Thus  arises as the
  pullback of  along the composition of  and
  . But this composition is simply , so it is clearly a fibration. Thus,  is a Lawvere
  category, and  is itself a fibred Lawvere category above the
  codomain fibration. Finally,  by construction.
\end{proof}

\section{Fibred Coinduction}\label{sec:fibcoind}

In this section we extend the methodology of Section~\ref{sec:fibind}
to give sound coinduction rules for coinductive indexed types in the
case when the indexing is not modelled by slice categories. As in
Section~\ref{sec:fibind}, we consider a fibration , where
we think of the objects of  as being indexed by the objects of
, and a fibration  that we think of as a logic over
. Our aim is to derive sound coinduction rules for final
coalgebras of functors , where  is any object of
.

Our experience from Section~\ref{sec:coind} suggests that a minimal
requirement for deriving a sound coinduction rule for a functor
 is that the fibration  is a QCE.  As in
Section~\ref{sec:fibind}, we want to highlight the uniformity
connecting the different fibrations  but, unfortunately,
requiring that each fibration  is a QCE does not automatically
imply that  is a QCE. On the other hand, if we define a
\emph{(full) section} of a functor  to be a (resp., full
and faithful) functor  such that  then, for
fibrations  and , a (full) section 
of  straightforwardly restricts to a (resp., full) section
 of  for any object  of . Then, by
contrast with the situation in the inductive case, requiring that each
fibration  is a QCE with section  actually does ensure that
 is a QCE with section , provided  preserves cartesian
morphisms. Indeed, observing that the notion of a cartesian morphism
and the notion of a fibre both make sense for arbitrary functors
whether or not they are fibrations, and extending our notation for
fibres of fibrations to fibres of functors, we have the following:

\begin{lemma}\label{lem:weakfibadj}
  Let  be a fibration, and let  and 
  be functors such that . The functor  has a left adjoint
   with vertical unit (or, equivalently, counit) iff 
  preserves cartesian morphisms and, for each object  in , the
  restriction  of  has a left adjoint .
\end{lemma}
\begin{proof}
  Suppose  preserves cartesian morphisms, let  be
  a collection of left adjoints to the restrictions 
  of , and let  be the unit of .  We will
  prove that, for each  in  and  in , the morphism
   is universal from  to  (and not just to
  ). By part (ii) of Theorem~2 of Chapter 4 of~\cite{mac71}, this
  gives an adjunction . The unit of this adjunction is
  vertical because it comprises the various units .

  To this end, consider a morphism  in  above  in .  Then  is above , and so there is a cartesian
  morphism  above  with respect to . Because
   preserves cartesian morphisms, we know that  is
  cartesian above  with respect to . Thus  for
  a unique vertical morphism  with respect to
  . Now, since  is in , we can use the universal property
  of  to deduce a unique morphism  in 
  such that . Therefore, we have a unique morphism
   such that .

  Conversely, suppose  is left adjoint to  with vertical unit.
  Then  preserves cartesian morphisms by
  Lemma~\ref{lem:adjandcart}, and the adjunction 
  restricts to adjunctions  because the unit of  is vertical and .
\end{proof}

We can now give the central definitions we need to state our sound
coinduction rules for coinductive indexed types.

\begin{definition}\label{def:qcea}
  Let  and  be two fibrations, and let
   a full section of . We say that  is a \emph{QCE
    above } if  has a left adjoint  and the
  adjunction  is fibred above :
   

\vspace*{0.1in}

\noindent
Note that, in this case, both  and  are necessarily fibred.  A
{\em weak QCE above } is similar to a QCE above , except that
the left adjoint to  need not be fibred (although  itself must
still be).
\end{definition}
\noindent

With this definition in place, we have the following analogue of
Corollary~\ref{cor:lwfaadj}: 

\begin{lemma}
Let  and  be fibrations. Then  is a weak
QCE above  iff  is a QCE and, for any object  of ,
 is a QCE whose full section and quotient functors
are given by the restrictions of the full section and quotient
functors, respectively, of  to .
\end{lemma}

\begin{proof}
If  is a weak QCE above , then the fact that  and the
fibrations  are QCEs is straightforward. For the other direction,
we observe that the unit (equivalently, counit) of  is
vertical. Lemma~\ref{lem:adjandcart} therefore guarantees that 
preserves cartesian morphisms, i.e., is fibred.
\end{proof}

\begin{corollary}\label{cor:icoind}
  Let  be a weak QCE above . For any object 
  of  and functor , any -preserving lifting
   of  defines a sound coinduction rule for
  . In particular, the canonical -preserving lifting from
  Section~\ref{sec:coind} defines a sound coinduction rule for .
\end{corollary}

We can see Theorem~\ref{thm:coinda} as a special case of 
Corollary~\ref{cor:icoind}.

\begin{example}\label{ex:sec3}
  Let  be a relational QCE. If  is the category with
  one object and one morphism, then  is a weak QCE above the
  fibration . Moreover, the treatment of coinduction from
  Section~\ref{sec:coind} is equivalent to the treatment of
  coinduction for this weak QCE above .
\end{example}

\noindent
We can also see Theorem~\ref{thm:icoinda} as a special case of
Corollary~\ref{cor:icoind}. This entails constructing, from the data
assumed in Lemma~\ref{lem:lift-qce}, a weak QCE above the codomain
fibration .  To do this, we first define an analogue of
a relational QCE in the setting where we are working above a fibration
. We have the following definition:

\begin{definition}\label{def:relqceabover}
  Let  be a bifibration with truth functor , let
   be a fibration, and assume that  has fibred cartesian
  products, i.e., products in the fibres that are preserved by
  reindexing. Let  be the fibred diagonal functor
  mapping each object  in  to the product with itself in
  .  Then, the {\em relations fibration above } is defined to
  be the fibration  above  that is
  obtained by change of base of  along . If
   is the diagonal natural transformation
  for , then the {\em equality functor for  above } is
  defined to be the functor  that maps an object
   of  to .  Furthermore, if  has a
  left adjoint , then  is called the {\em quotient functor
    for  above }.  A {\em relational QCE above } is a QCE
  above  obtained via this construction. A {\em weak relational QCE
    above } is similar to a relational QCE above , except that
  the left adjoint to the fibred equality functor need not be fibred.
\end{definition}

The main difficulty in constructing a weak relational QCE  above a
fibration  is proving that the equality functor for  is
fibred. If  has pullbacks and  is the codomain
fibration, then  has fibred products given by pullbacks.  In this
case, we write  for the functor mapping
an object  in  to the product  of  with itself
in the fibre . We denote the diagonal natural
transformation for  by .


\begin{lemma}\label{lem:carts}
Let  be a bifibration with a truth functor, and suppose
 satisfies the Beck-Chevalley condition. Furthermore, assume that
 has products and pullbacks. Let  be obtained
from  by change of base along the fibration , and let
 be obtained from  by change of base
along :
 
Finally, let  be the functor
that maps an object  of  to the object
 of . Then
 is a fibred functor from  to
.
\end{lemma}


\begin{proof}
Let  be an object of , let  be a
morphism of , and consider the pullback  of  along .  Then the cartesian morphism above  with
codomain  is the morphism  in . We must show that the morphism  is cartesian.

We begin by considering the morphism  in
. The fact that  is a pullback means that
 is cartesian. Because  is fibred, we know that
 is cartesian. Thus, if , then  is the pullback of 
along .
From part b of Exercise 8 on page 72 of~\cite{mac71},
together with the facts that  and  are pullbacks, we have that  is
the pullback of  along . The Beck-Chevalley
condition thus ensures that  is
isomorphic to .  Letting  stand for
, we therefore have that  is . Since  is
cartesian with respect to  by definition, and since  is
cartesian with respect to , we have that
 is cartesian with respect to
, as required.
\end{proof}

\begin{lemma}\label{lem:wqcer}
  Let  be a bifibration such that the Beck-Chevalley
  condition holds and  has pullbacks.  Let 
  be the relational QCE derived from , with equality functor
   and quotient functor .  Then the
  bifibration  obtained from the following
  change of base
  
  is a weak QCE above . In addition, for any  in ,
  .
\end{lemma}
\begin{proof}
  We have the following situation:
  
  Let  be an object of . First, by the same reasoning as in the
  proof of Lemma~\ref{lem:canlwfiba} we have that . Now,
  note that if  is the inclusion functor, then
  . Thus,  is obtained by change
  of base of  along the functor , i.e., the fibrations
   and  coincide.  Moreover, the equality functor
   is defined by
  , where  is the truth functor for
  . Then  restricts to the equality functor 
  since  is the restriction of  to the
  corresponding fibres. This ensures that the equality functors for
   and  coincide.  Finally, because adjoints are
  defined up to isomorphism, the quotient functors for  and
   coincide. Putting this all together, we have that
   and  are in fact the same QCE.  Now, each
  restriction  of  has a left adjoint .
  Moreover,  preserves cartesian morphisms because 
  preserves cartesian morphisms by construction, and
  Lemma~\ref{lem:carts} ensures that  preserves
  cartesian morphisms. By Lemma~\ref{lem:weakfibadj}, we have that
   is a left adjoint to , and thus that  is a
  weak QCE above .
\end{proof}

The coinduction rule for the mutually recursive data type of {\em
  odds} and {\em evens} in the families fibration shows that fibred
coinduction is applicable in situations where indexed coinduction is
not.

\section{Conclusions, Related Work, and Future Work}\label{sec:conc} 

In this paper, we have extended the fibrational approach to induction
and coinduction pioneered by Hermida and Jacobs, and further developed
by the current authors, in three key directions: we have given sound
coinduction rules for all (unindexed) coinductive types, and we have
extended our results from the unindexed setting to the indexed one to
derive sound induction and coinduction rules for all inductive and
coinductive indexed types. We derived our rules for indexed types
first in the case when indexing is modelled by the codomain fibration,
and then in the case when it is modelled by an arbitrary fibration.

The work of Hermida and Jacobs is most closely related to ours, but
there is, of course, a large body of work on induction and coinduction
in a broader setting. In dependent type theory, for example, data
types are usually presented along with elimination rules that are
exactly induction rules. Along these lines,~\cite{pm89} has heavily
influenced the development of induction in Coq. Another important
strand of related work concerns inductive families and their induction
rules~\cite{dyb94}. On the coinductive side, papers such
as~\cite{am89,rut00,tr98} have had immense impact in bringing
bisimulation into the mainstream of theoretical computer science.

There are several directions for future work. First, we would like to
explore more applications of the results in Sections~\ref{sec:fibind}
and~\ref{sec:fibcoind}.  More generally, we would like to exploit the
predictive power of our theory to provide induction and coinduction
rules for advanced data types --- such as inductive recursive types
--- for which these rules are not discernible by sheer intuition. In
such circumstances, our generic fibrational approach should provide
rules whose use is justified by their soundness proofs. In a different
direction, we would like to see our induction and coinduction rules
for advanced data types incorporated into implementations such as Agda
and Coq.

\vspace*{0.1in}

\noindent
{\bf Acknowledgement} We thank the reviewers for their helpful
comments and suggestions.

\bibliographystyle{plain}
\begin{thebibliography}{99999}

\bibitem{am89} P.\ Aczel and P.\ Mendler. A Final Coalgebra
  Theorem. {\em Proceedings, Category Theory and
    Computer Science}, pp. 357--365, 1989.

\bibitem{dyb94}
P.\ Dybjer. Inductive Families.
{\em Formal Aspects of Computing} 6(4), pp. 440--465, 1994.

\bibitem{fum12} C.\ Fumex. Induction and Coinduction Schemes in
  Category Theory. PhD Thesis. University of Strathclyde, 2012.

\bibitem{fgj11} C.\ Fumex, N.\ Ghani, and P.\ Johann. Indexed
  Induction and Coinduction, Fibrationally.  {\em Proceedings,
    Conference on Algebra and Coalgebra on Computer Science},
    pp. 176--191, 2011.

\bibitem{gjf10} N.\ Ghani, P.\ Johann, and C.\ Fumex.
Fibrational Induction Rules for Initial Algebras. {\em Proceedings,
  Computer Science Logic}, pp. 336--350, 2010. 

\bibitem{gjf11} N.\ Ghani, P.\ Johann, and C.\ Fumex. Generic
  Fibrational Induction. {\em Logical Methods in Computer
    Science} 8(2), 2012. 

\bibitem{her93} 
C.\ Hermida.  Some properties of Fib as a Fibred 2-Category.  {\em
  Journal of Pure and Applied Algebra} 134(1), pp. 83--109, 1993. 

\bibitem{her93b}
C.\ Hermida. Fibrations, Logical Predicates and Related
Topics. Dissertation, University of Edinburgh, 1993.

\bibitem{hj98} 
C.\ Hermida and B.\ Jacobs. Structural Induction and Coinduction in a
Fibrational Setting. {\em Information and Computation} 145,
pp. 107--152, 1998.  

\bibitem{hh06} P.\ G.\ Hancock and P.\ Hyvernat. Programming
  Interfaces and Basic Topology.  {\em Annals of Pure and Applied
    Logic} 137(1-3), pp. 189--239, 2006.

\bibitem{jac91}
B. Jacobs, Categorical Type Theory. PhD Thesis, University of
Nijmegen, 1991.  

\bibitem{jac99} 
B.\ Jacobs. \emph{Categorical Logic and Type Theory}. Studies in Logic
and the Foundations of Mathematics, Volume 141, 1999. 

\bibitem{jac93} 
B.\ Jacobs. Comprehension Categories and the Semantics of Type
Dependency. {\em Theoretical Computer Science} 107, pp. 169--207,
1993. 

\bibitem{jac94} 
B.\ Jacobs. Quotients in Simple Type Theory. Mathematics
Institute, 1994.  

\bibitem{mac71} S.\ Mac Lane. {\em Categories for the Working
  Mathematician}. Springer-Verlag, 1971.

\bibitem{ma09} P.\ Morris and T.\ Altenkirch.  Indexed
  Containers. {\em Proceedings, Logic in Computer Science},
  pp. 277--285, 2009.

\bibitem{pm89}
Frank Pfenning and C.\ Paulin-Mohring. 
Inductively Defined Types in the Calculus of Constructions. {\em
  Proceedings, Mathematical Foundations of Programming
  Semantics}, pp. 209--228, 1989. 

\bibitem{pav90}
D.\ Pavlovi\v{c}. {\em Predicates and Fibrations}. Dissertation,
University of Utrecht, 1990.

\bibitem{rut00} J.\ Rutten. Universal Coalgebra: A Theory of
  Systems. {\em Theoretical Computer Science} 249(1), pp. 3--80, 2000.

\bibitem{tr98}
D.\ Turi and J.\ Rutten. On the Foundations of Final Coalgebra
Semantics. {\em Mathematical Structures in Computer Science} 8(5),
pp. 481--540, 1998.

\end{thebibliography}

\end{document}
