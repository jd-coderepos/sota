

\documentclass[a4paper]{easychair}
\usepackage{times}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage[english]{babel}
\usepackage{listings,url}
\usepackage{verbatim}
\usepackage{mathpartir}
\usepackage{epsfig}
\usepackage{proof}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{paralist}
\usepackage{ifdraft}
\usepackage{usefuldefs}
\usepackage[utf8]{inputenc}
\usetikzlibrary{arrows,automata,patterns,calc}
\urldef{\mailsa}\path|{schwmart,seidl}@in.tum.de|
\urldef{\mailsb}\path|thomas.martin.gawlitza@uni-oldenburg.de|
\renewcommand{\qed}{\hfill\mbox{\rule[0pt]{1.3ex}{1.3ex}}}
\newcommand{\condop}[3]{\ensuremath{({#1}) \mathrel{?} {#2} \mathrel{:} {#3}}}
\newcommand{\doml}{\ensuremath{\D_L}}
\newcommand{\domg}{\ensuremath{\D_G}}
\newcommand{\accs}[1]{\ensuremath{{\SEM{#1}_{\mathit{acc}}}}}
\newcommand{\accss}[1]{\ensuremath{{\SEM{#1}\sh_{\mathit{acc}}}}}
\newcommand{\tfs}[1]{\ensuremath{\mathit{tf_{#1}}}}
\newcommand{\Gob}{Goblint}
\newcommand{\symb}[1]{\text{\ttfamily\bfseries #1}}
\newcommand{\ass}{\>\symb{:=}\;}
\newcommand{\startnode}{{\mathit{st}}}
\newcommand{\startnodes}{\vec\startnode}
\newcommand{\prot}[2]{\ensuremath{\mathsf{prot}_{#1}{(#2)}}}
\newcommand{\globs}{\ensuremath{G}}
\newcommand{\csemsymb}{\ensuremath{\mathbf C}}
\newcommand{\csem}[1]{\ensuremath{\csemsymb[{#1]}}}
\newcommand{\acc}{\mathit{acc}}
\newcommand{\lockset}{\mathit{ls}}
\newcommand{\globallock}{\Lambda}

\newcommand{\threads}{\ensuremath{\mathcal T}}
\newcommand{\mutexes}{\ensuremath{\mathcal M}}
\newcommand{\dinter}{\csemsymb}
\newcommand{\dinv}{S}

\newcommand{\fcon}{\circ}
\newcommand{\icon}{\bullet}
\newcommand{\CRUNS}{{\bf C}}
\newcommand{\proj}{{\sf proj}}
\newcommand{\Pres}{\mathcal{R}}

\newcommand{\Acc}{Acc}
\newcommand{\Pry}{\mathcal{P}}
\newcommand{\Use}{\mathcal{U}}
\newcommand{\Gam}{\mathrm{\Gamma}}
\DeclareMathOperator{\cupdot}{\mathaccent\cdotp\cup}
\newcommand{\sd}{\text{ s.t. }}
\newcommand{\DD}{\mathbb{D}}
\newcommand{\GG}{\mathbb{G}}
\newcommand{\BB}{\mathbb{B}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\ZzZ}{\overline{\mathbb Z}}
\newcommand{\PP}{\mathbb{P}}
\newcommand{\FF}{\mathcal{F}}
\newcommand\hp[1]{\mathrm{hp}#1}
\newcommand{\eqv}{\Longleftrightarrow}
\newcommand{\cmd}{{\sf cmd}}
\newcommand{\cmda}{s}

\newenvironment{mtx}{\left[ \begin{smallmatrix}}{\end{smallmatrix} \right]}
\newenvironment{mtx*}{\begin{smallmatrix}}{\end{smallmatrix}}

\newcommand{\State}{{\sf S}} \newcommand{\Task}{{\sf Task}}
\newcommand{\Prog}{{\sf Prog}}
\def\task#1#2{\Gamma_{\pair{#1,#2}}}
\newcommand{\Irpt}{{\sf Irpt}}
\newcommand{\Fun}{{\sf Func}}
\newcommand{\Qs}{{\sf Queue}}

\newcommand{\locals}{\rho}
\newcommand{\globals}{\gamma}
\newcommand{\res}{R} \newcommand{\AD}{\cramped{2^{2^\Res}}}
\newcommand{\state}{\delta}
\newcommand{\QQ}{\text{Q}}
\newcommand{\stateZero}{\pair{\res,\vars}}

\DeclareMathOperator{\entry}{\mathit{entry}}
\DeclareMathOperator{\comb}{\mathsf{H}}
\DeclareMathOperator{\retvar}{\mathtt{rv}}

\DeclareMathOperator{\spawn}{\mathsf{spawn}}
\DeclareMathOperator{\activ}{\mathsf{activate}}
\DeclareMathOperator{\term}{\mathsf{kill}}
\DeclareMathOperator{\getr}{\mathsf{get}}
\DeclareMathOperator{\relr}{\mathsf{rel}}
\DeclareMathOperator{\ISRoff}{\mathsf{disableIRPT}}
\DeclareMathOperator{\ISRon}{\mathsf{enableIRPT}}
\DeclareMathOperator{\sched}{\mathsf{schedule}}
\DeclareMathOperator{\add}{\mathit{add}}
\DeclareMathOperator{\push}{\mathit{push}}
\DeclareMathOperator{\hd}{\mathit{hd}}
\DeclareMathOperator{\tl}{\mathit{tl}}
\DeclareMathOperator{\combine}{\mathit{combine}}
\DeclareMathOperator{\enter}{\mathit{enter}}
\DeclareMathOperator{\apply}{\mathit{apply}}
\DeclareMathOperator{\sync}{\mathit{sync}}

\newcommand{\comp}{\circ}
\newcommand{\tw}{\textstyle\bigwedge}
\newcommand{\pow}[1]{2^{#1}}
\newcommand{\OO}{\mathcal O}

\newcommand{\intt}{\text{\bf int}}
\newcommand{\floatt}{\text{\bf float}}
\newcommand{\mutext}{\text{\bf mutex}}
\newcommand{\ptr}[1]{\ensuremath{#1*}}

\newcommand{\true}{{\sf true}}
\newcommand{\false}{{\sf false}}
\newcommand{\SEM}[1]{{\llbracket{#1}\rrbracket}}
\newcommand{\CSEM}[1]{{\llbracket{#1}\rrbracket^C}}
\newcommand{\TSEM}[1]{[\![{#1}]\!]^{\sf T}}
\newcommand{\FSEM}[1]{[\![\![{#1}]\!]\!]}
\newcommand{\Sss}{{\mathbb S}}
\newcommand{\alphH}{\alpha}

\newcommand{\tr}{^{\sf T}}
\newcommand{\sh}{^{\sharp}}
\newcommand{\cache}{\mathit{c}}

\newcommand{\vektor}[1]{{\left(
       \begin{array}{c}
         #1
      \end{array}
      \right)}}

\newcommand{\zero}{{\bf 0}}
\newcommand{\Stmt}{{\sf Stmt}}
\newcommand{\Funct}{{\sf Funct}}

\newcommand{\st}{{\sf st}}


\newcommand{\WHILE}{{\bf while}}
\newcommand{\IF}{{\bf if}}
\newcommand{\FORALL}{{\bf forall}}
\newcommand{\WITH}{{\bf with}}
\newcommand{\CASE}{{\bf case}}
\newcommand{\SWITCH}{{\bf switch}}
\newcommand{\BREAK}{{\bf break}}

\newcommand{\tp}{{\rm t}}  \newcommand{\Tp}{{\!\sf T}}  \newcommand{\D}{{\mathbb D}}
\newcommand{\Hom}{{\bf Hom}}
\newcommand{\Sub}{{\bf Sub}}
\newcommand{\Span}{{\bf Span}}
\newcommand{\scp}[1]{{\langle{#1}\rangle}}
\newcommand{\Proc}{{\sf Proc}}
\newcommand{\Lab}{{\sf Lab}}
\newcommand{\Base}{{\sf Base}}
\newcommand{\Act}{{\sf Act}}
\newcommand{\Call}{{\sf Call}}
\newcommand{\call}{{\sf call}}
\newcommand{\ret}{{\sf ret}}
\newcommand{\READ}{{\sf read}}
\newcommand{\RRUNS}{{\bf R}}
\newcommand{\SRUNS}{{\bf S}}
\newcommand{\WP}{{\bf WP}}
\newcommand{\VALUES}{{\bf V}}
\newcommand{\Values}{V}
\newcommand{\start}{{\sf st}}
\newcommand{\Main}{{\it main}}
\newcommand{\eps}{\varepsilon}
\newcommand{\sig}{\sigma}
\newcommand{\Single}{{\sf Single}}
\newcommand{\dom}[1]{{\sf dom} ({#1})}
\newcommand{\cp}{\mathop{;}}     \newcommand{\sat}{\models}
\newcommand{\Runs}{{\sf Runs}}
\newcommand{\HH}{{\cal H}}
\newcommand{\W}{{\cal W}}
\newcommand{\pt}{p_{\rm t}}
\newcommand{\Gt}{G_{\rm t}}
\newcommand{\ttrans}[1]{\stackrel{\mbox{}}{\Longrightarrow}}
\newcommand{\affineHull}{{\sf aff}}
\newcommand{\Gfin}{G_{\rm fin}}

\newcommand{\rank}{{\sf rank}}
\newcommand{\reduce}{{\sf reduce}}
\DeclareMathOperator*{\sub}{\dot{--}}
\DeclareMathOperator*{\eq}{\dot{\,=\,}}
\newcommand{\rt}{{\sf rt}}

\newcommand{\power}[1]{\ensuremath{\mathcal{P}(#1)}}
\newcommand{\bracks}[1]{\left\llbracket #1 \right\rrbracket}
\newcommand{\pair}[1]{\langle #1 \rangle}
\newcommand{\angl}[1]{\left\langle #1 \right\rangle}
\newcommand{\concat}{\mathrel{+\hspace{-1em}+}}

\newcommand{\Bot}{\underline{\bot}}


\newcommand\justification[1]{\quad[\mbox{#1}]}



\catcode`\@=11        \def\ignoretrue{\global\@ignoretrue}
\catcode`\@=12        

\def\defrelations{
   \def\better{\etc{\geq}}         \def\worse {\etc{\leq}}         \def\equals{\etc{=}}            \def\equivals{\etc{\equiv}}     \def\lesseq{\etc{\leq}}         \def\greateq{\etc{\geq}}        \def\subseteqwithoutwhy{\etc{\subseteq}}
   \def\superseteq{\etc{\supseteq}}    \def\inwithoutwhy{\etc{\in}}    \def\iff{\etc{\mbox{iff}}}      \def\betterwhy##1{\etcwhy{\geq}{##1}}
   \def\worsewhy##1{\etcwhy{\leq}{##1}}
   \def\equalswhy##1{\etcwhy{=}{##1}}
   \def\equivalswhy##1{\etcwhy{\equiv}{##1}}
   \def\lesseqwhy##1{\etcwhy{\leq}{##1}}
   \def\greateqwhy##1{\etcwhy{\geq}{##1}}
   \def\subseteqwhy##1{\etcwhy{\subseteq}{##1}}
   \def\supseteqwhy##1{\etcwhy{\supseteq}{##1}}
   \def\sqsubseteqwhy##1{\etcwhy{\sqsubseteq}{##1}}
   \def\sqsupseteqwhy##1{\etcwhy{\sqsupseteq}{##1}}
   \def\iffwhy##1{\etcwhy{\mbox{iff}}{##1}}
   \def\implieswhy##1{\etcwhy{\Rightarrow}{##1}}
   \def\inwhy##1{\etcwhy{\in}{##1}}
   \def\LHS{{\rm LHS}}              \def\RHS{{\rm RHS}}              }



\newenvironment{calc}{  \def\termskip{1ex}             \def\commentskip{0.5ex}        \def\nlspace{0.3ex}            \def\etc##1{\cr\noalign{\vspace{\termskip}}##1&}
   \def\etcwhy##1##2{\cr\noalign{\vspace{\termskip}}##1&\justification{##2}\cr\noalign{\vspace*{\commentskip}}&}
   \def\nl{\cr\noalign{\vspace{\nlspace}}&}  \bgroup
    \defrelations
    \tabskip=1em
    \egroup\ignoretrue}



\newenvironment{linecalc}{  \def\tabsign{&}
   \def\signspace{\ \ }  \def\etc##1{\tabsign\signspace ##1\signspace\tabsign\def\tabsign{}}
   \def\etcwhy##1##2
       { \tabsign\signspace
         \begin{array}[t]{@{}c@{}}
           ##1 \3em]\qquad\def\tabsign{&}}  \def\nlwithout{\ \begin{array}[t]{@{}l@{}c@{}l@{}}}{     \end{array} \renewcommand{\arraystretch}{1.2}
   \begin{array}{l@{~~~}l@{~}c@{~}l@{~~}l}}{  \end{array}
	& x = {\bf p}_1;	\;
	{\bf while}\;(x<{\bf p}_2)	\;
	x = x+1;
	
	{\bf x} = e_{\bf x}\;,\qquad{\bf x}\in{\bf X}
	
x + \neginfty &= \neginfty + x = \neginfty	&&\forall x\in\ZzZ	\\
x + \infty    &= \infty + x 	= \infty	&&\forall x\in\ZzZ\backslash\{\neginfty\}\\
c\cdot(\neginfty) &= \neginfty		&&\forall c\geq 0	\\
0\cdot\infty	&= 0			&&\\
c\cdot\infty	&= \infty			&&\forall c> 0	

e\;{::=}\; a\mid{\bf p}\mid-{\bf p}\mid{\bf x}\mid e_1\wedge e_2\mid e_1 + e_2\mid e_1\,;\;e_2\mid c\cdot e_1

\sem{a}_\pi\,\xi &= a	  &
\sem{{\bf x}}_\pi\,\xi &= \xi({\bf x})	\\
\sem{{\bf p}}_\pi\,\xi &= \pi({\bf p})	&
\sem{e_1\,\Box\,e_2}_\pi\,\xi &= \sem{e_1}_\pi\,\xi\;\Box\;\sem{e_2}_\pi\,\xi	\\
\sem{-{\bf p}}_\pi\,\xi &= -\pi({\bf p})	&
\sem{c\cdot e}_\pi\,\xi &= c\cdot\sem{e}_\pi\,\xi

  \xi^*({\bf x}) = \sem{e_1}_\pi\,\xi^*\vee\ldots\vee\sem{e_r}_\pi\,\xi^*

    \Xi \; \pi \; \mathbf x &= 
      \begin{cases} 
        \pi(\mathbf p_1) & \text{if } \pi(\mathbf p_1) \geq \pi(\mathbf p_2) \\
        \pi(\mathbf p_2) & \text{if } \pi(\mathbf p_1) < \pi(\mathbf p_2) \\
      \end{cases}
  
  (\phi_1\;\Box^*\;\phi_2)(\pi) &= \phi_1(\pi)\,\Box\,\phi_2(\pi) 

\sem{{\bf p}_i}\;\rho &= {\sf proj}_i	&
\sem{{\bf -p}_i}\;\rho &= {\sf -proj}_i	\\
\sem{a}\;\rho  &= {\sf const}_a   &
\sem{{\bf x}}\;\rho &= \rho({\bf x})  \\
\sem{e_1\,\Box\,e_2}\;\rho &= \sem{e_1}\,\rho\;\Box\;\sem{e_2}\,\rho  &
\sem{c\cdot e}\;\rho &= c\cdot\sem{e}\;\rho    

\Xi\;\pi\;{\bf x} = \rho^*{\bf x}\;\pi 

{\sf select}\;\phi\;(v_0,\ldots,v_r)\;\pi &= v_{\phi(\pi)}\,\pi

\rho: {\bf X}\to\ZzZ\qquad\sigma:{\bf X}\to\NN

-2{\bf p}_1 + {\bf p}_2	&\leq -2	&
-{\bf p}_1 - {\bf p}_2	&\leq -6	&
-{\bf p}_1 - {\bf p}_2	&\leq -2	

\begin{array}{lll}
{\sf align}	&:&	{'}a\;{\sf tree}\to {'}b\;{\sf tree}\to({'}a*{'}b)\;{\sf tree}
\end{array}

{\bf x}_i &= {\bf x}_{i+1} \vee -2^i + {\bf x}'_{i+1}	&
{\bf x}_m &= {\bf x} \vee -2^m + {\bf x}' &
{\bf x} &= {\bf p} \wedge -{\bf p}	   \\
{\bf x}'_i &= {\bf x}'_{i+1} \wedge 2^i + {\bf x}_{i+1}	&
{\bf x}'_m &= {\bf x}' \wedge 2^m + {\bf x}	&
{\bf x}' &= -{\bf p} \vee {\bf p}	

\rho^*\;{\bf x}_1\; p =
	\left\{
 	\begin{array}{rll}
 	-p - 2^m	&\quad\text{if}\;& p \leq -2^m -1	\\
 	0		&\quad\text{if}\;& -2^m\leq p\leq 2^m,\; p\;\text{even}	\\
 	-1		&\quad\text{if}\;& -2^m\leq p\leq 2^m,\; p\;\text{odd}	\\
 	p - 2^m		&\quad\text{if}\;& 2^m +1\leq p	\\
 	\end{array}\right.

{\bf x}_1^- &= {\bf p}_1 \vee {\bf x}_3^-        &
        {\bf x}_2^- &= ({\bf x}_1^+ +\infty);({\bf x}_1^-+{\bf p}_2 -1);({\bf x}_1^-\wedge\infty)      \\
        {\bf x}_3^- &= {\bf x}_2^- + (-1)           &
        {\bf x}_4^- &= ({\bf x}_1^+ +(-{\bf p}_2));({\bf x}_1^-+\infty);({\bf x}_1^- \wedge -{\bf p}_2)      \\
{\bf x}_1^+ &= {\bf p}_1 \vee {\bf x}_3^+        &
        {\bf x}_2^+ &= ({\bf x}_1^+ +\infty);({\bf x}_1^-+{\bf p}_2 -1);({\bf x}_1^+\wedge {\bf p}_2 -1)      \\
        {\bf x}_3^+ &= {\bf x}_2^+ +1           &
        {\bf x}_4^+ &= ({\bf x}_1^+ +(-{\bf p}_2));({\bf x}_1^-+\infty);({\bf x}_1^+ \wedge \infty)    
      
\xi({\bf x}_4^-) &= {\it if}\; -{\bf p}_1 + {\bf p}_2\leq 0\;{\it then}\;-{\bf p}_1\; {\it else}\;-{\bf p}_2	\\
\xi({\bf x}_4^+) &= {\it if}\; -{\bf p}_1 + {\bf p}_2\leq 0\;{\it then}\;{\bf p}_1\; {\it else}\;{\bf p}_2
	
\begin{array}{l}
0\leq {\bf p}_1 \wedge {\bf p}_1 \leq {\bf p}_2 
\end{array}

should hold. Then the analyzer takes 
only considers values less or equal to the tree
in Fig.\ \ref{f:top}.
\begin{figure}
\begin{center}
\scalebox{0.6}{\begin{picture}(0,0)\includegraphics{top.pdf}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(2994,1554)(3229,-883)
\put(4246,-203){\makebox(0,0)[b]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5183,427){\makebox(0,0)[b]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4816,-788){\makebox(0,0)[b]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5806,-158){\makebox(0,0)[b]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3601,-788){\makebox(0,0)[b]{\smash{{\SetFigFont{12}{14.4}{\rmdefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }
\caption{\label{f:top}The topmost value under the assumption
	.}
\end{center}
\end{figure}

One implementation based on lists, deals with the one-parameter case only, while the other implementation, 
which is based on region trees, can deal with multiple parameters.
The total ordering  used by our analyzer orders according to the number of variables,
where the lexicographical ordering on the vector of coefficients is used for constraints with the 
same number of variables.
For deciding satisfiability of conjunctions of inequalities, we generally rely on Fourier-Motzkin elimination
(with integer tightening).
Only in the very end, when it comes to produce the final result, we purge regions containing no integer points
by means of an integer solver.
We have tried our implementations on the rate limiter example from \cite{monniaux09} as well as 
on several small (about 20 interval unknowns) but intricate systems of equations
in order to evaluate the impact of the number of parameters as well as 
the impact of the chosen method for checking emptiness of integer polyhedrons
on the practical performance.
The tests have been executed on an Intel(R) Core(TM) i5-3427U CPU running Ubuntu.
On that machine, parametric interval analysis of the rate limiter example 
terminated after less than 5s.
The remaining benchmarks are based on programs where interval analysis according to the
standard widening/narrowing approach fails to compute the least solution.
For each example equation system, we successively introduce parameters for
the constants used, e.g., in conditions and initializers.
The system of equations \texttt{nested} is derived from a program with two independent nested loops.
The systems \texttt{amato} correspond to three example programs presented in
\cite{DBLP:conf/sas/AmatoS13}.
The system \texttt{rupak} corresponds to an example program by
Rupak Majumdar presented at MOD'11.
Both \texttt{amato} and \texttt{rupak} do not realize a plain interval analysis
but additionally track differences of variables.


Interestingly, the number of required strategy improvements does \emph{not} depend
on the number of parameters --- with the notable exception \texttt{amato0} where for three and four parameters,
the number increases from 8 to 9. Generally, the number of iterations is always significantly lower than the
number of unknowns in the system of equations.


\begin{figure*}[hbt]\centering
\fbox{
\includegraphics{main-figure0.pdf}
\hspace{4pt}
}
\caption{Fragmentation.}
\label{fig:regions}
\end{figure*}



\noindent
Figure~\ref{fig:regions} shows the number of regions in the results with different behavior. 
For the 0 parameter case this is always 1.
As expected, the fragmentation increases with the number of parameters --- but not as excessively
as we expected. In case of \texttt{rupak}, the number of regions even \emph{decreased} for three and four parameters.
The reason is that by introducing fresh parameters, also the ordering on inequalities changes.
The ordering on the other hand may have a significant impact onto fragmentation.




\begin{figure*}[hbt] \centering
\fbox{
\includegraphics{main-figure1.pdf}
}
\caption{Execution time in (s).}
\label{fig:time}
\end{figure*}


Figure~\ref{fig:time} shows the running times of the benchmarks on a logarithmic scale. 
We visualize the run-times for 0 through 4 parameters each. The filled and outlined bars correspond to
Fourier-Motzkin elimination and integer satisfiability for testing emptiness of regions, respectively.
The inscribed red bars in the single parameter case represent the run-time 
obtained by using linear lists instead of region trees.
The bottom-line case without parameters is fast and the 
dedicated implementation for single parameters increases the run-time only by a 
factor of approximately 1.4. 
Using region trees clearly incurs an extra penalty, which increases significantly
with the number of parameters. 
While replacing Fourier-Motzkin elimination for testing emptiness of regions 
with an enhanced algorithm for integer satisfiability increases the run-time 
only by an extra factor of about 1.5.
When considering absolute run-times, however, it turns out that the solver even for four parameters 
together with full integer satisfiability
is not prohibitively slow (a few seconds only for all benchmark equation systems).
Details on experimental results can be found at \url{www2.in.tum.de/~seidl/psi}.











\section{Related Work}\label{s:related}

Parametric analysis of linear numerical program properties has been advocated by Monniaux 
\cite{monniaux09,monniaux10} by compiling the abstract program semantics to real linear 
arithmetic and then use quantifier elimination to determine the parametric invariants.
We have conducted experiments with Monniaux' tool {\sc Mjollnir},
by which we tried to solve real relaxations of parametric integer equations.
Since {\sc Mjollnir} has no native support for positive or negative infinities 
these values had to be encoded through formulas with extra propositional variables.
This approach, however, did not scale to the sizes we needed.
Our conjecture is that the high Boolean complexity of the formulas causes severe problems.
Beyond that, fewer calls to quantifier elimination for formulas with many variables (as required
by {\sc Mjollnir}) may be more expensive than many calls to an integer solver for formulas
with few variables (namely, the parameters as in our approach).
All in all, since our integer tool  and {\sc Mjollnir}
tackle slightly different problems, a precise comparison is difficult. 
Still, our experiments indicates that our
approach behaves better than a quantifier elimination-based approach for applications where 
the control-flow is complex with multiple control-flow points, but where few parameters are of interest.

Since long, relational program analyses, e.g., by means of polyhedra have been around
\cite{DBLP:conf/popl/CousotH78,DBLP:journals/scp/BagnaraHZ08} which also allow to infer
linear relationships between parameters and program variables. 
The resulting invariants, however, are convex and thus do not allow to differentiate
between different linear dependencies in different regions.
In order to obtain invariants as precise as ours, one would have to combine polyhedral domains
with some form of trace partitioning \cite{mauborgne05trace}.
These kinds of analysis, though, must rely on widening and narrowing to enforce termination,
whereas our algorithms avoid widening and narrowing completely and directly compute 
least solutions, i.e., the best possible parametric invariants.

Parametric analysis of a different kind has also been proposed by Reineke \cite{Reineke14}
in the context of worst-case execution time (WCET). 
They rely on parametric linear programming as implemented by the PIP tool \cite{pip}
and infer the dependence of the WCET on architecture parameters such as the chache size 
by means of black box sampling of the WCETs obtained for different parameter settings.

Our data structure of region trees is a refinement of the tree-like data-structure {\sc Quast}
provided by the PIP tool \cite{pip}. Similar data-structures are also used by Monniaux \cite{monniaux09} to represent
the resulting invariants, and by Mihaila et al.\ \cite{mihaila13widening} to differentiate
between different phases of a loop iteration.
In our implementation, we additionally enforce a total ordering on the 
constraints in the tree nodes and allow arbitrary values at the leaves. 
Total orderings on constraints have also been proposed for linear decision diagrams \cite{DBLP:conf/fmcad/ChakiGS09}.
Variants of LDDs later have been used to implement non-convex linear program invariants 
\cite{Gurfinkel10,Ghorbal12} and in \cite{Gurfinkel11} for representing linear arithmetic formulas when
solving predicate abstraction queries.
In our application, sharing of subtrees is not helpful, since
each node  represents a \emph{satisfiable} conjunction of the inequalities which is constituted by the path
reaching  from the root of the data-structure.
Moreover, our application requires that the leaves of the data-structure are not just annotated with
a Boolean value (as for LDDs), but with values from various sets, namely strategic choices, affine functions 
or even pairs thereof.

\section{Conclusion} \label{s:conc}

Solving systems of \emph{parametric integer equations}
allows to solve also systems of \emph{parametric interval equations},
and thus to realize parametric program analysis
for programs using integer variables.
To solve parametric integer equations,
we have presented parametric strategy iteration. 
Instead of solving integer optimization and satisfiability problems
involving all unknowns of the problem formulation (as an approach
based on quantifier elimination),
our algorithm is a smooth generalization of ordinary
strategy iteration, which applies
integer satisfiability to inequalities involving 
parameters only.
Our prototypical implementation indicates that this
approach indeed has the potential to deal with nontrivial problems ---
at least when only few parameters are involved.
Introducing further parameters significantly increases the analysis costs.
Surprisingly, the number of strategies required 
as well as the fragmentation observed in our examples increased only moderately.
Accordingly, the required running times were quite decent.





More experiments are necessary, though, to obtain a deeper understanding of parametric strategy iteration.
Also, we are interested in exploring the practical potential of sensitivity and mode
analysis enabled by this new algorithm, e.g., for automotive and avionic
applications.



\smallskip

\noindent
\emph{Acknowledgement.}
We thank Stefan Barth (LMU) for Example \ref{e:exp}, and
Jan Reineke (Universit\"at des Saarlandes) for useful discussions.



\bibliographystyle{plain}
\bibliography{martin}

\end{document}
