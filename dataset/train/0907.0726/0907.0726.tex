\documentclass[11pt]{article}

\usepackage{verbatim,url,enumerate,color,paralist,cite}
\usepackage{amsmath,amsfonts,nicefrac}
\usepackage{epsfig,amssymb,amstext,xspace}
\usepackage{algorithm}
\usepackage{algorithmicx,algpseudocode}
\usepackage{fullpage}


\newcommand{\qed}{\hspace*{\fill}}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{fact}[theorem]{Fact}




\newenvironment{proof}[1][Proof. ]{\noindent {\bf #1 }}{\qed}
\newenvironment{proofof}[1]{\medskip \noindent {\bf{Proof of #1. }}}{\qed}


\newcommand{\argmin}{{\rm argmin}}
\newcommand{\argmax}{{\rm argmax}}

\begin{document}

\title{\Large Asymmetric Traveling Salesman Path and\\ Directed Latency Problems\footnote{A preliminary 
version of this paper appeared in the Proceedings of 21st Annual ACM-SIAM Symposium on 
Discrete Algorithms}}
\author{
Zachary Friggstad\thanks{Supported by NSERC and iCORE scholarships} \hspace{12mm}
Mohammad R. Salavatipour\thanks{Supported by NSERC and an Alberta Ingenuity New Faculty award} \hspace{12mm}
Zoya Svitkina\thanks{Supported by Alberta Ingenuity}\\
\\
\small{Department of Computing Science}\\ 
\small{University of Alberta}\\
\small{Edmonton, Alberta T6G 2E8, Canada}
}

\date{June 1, 2010}
\maketitle


\begin{abstract} 

We study integrality gaps and approximability of two closely related problems on directed graphs. 
Given a set  of  nodes in an underlying asymmetric metric and two
specified nodes  and , both problems ask to find an - path visiting all other nodes. In 
the {\em asymmetric traveling salesman path problem} (ATSPP), the objective is to minimize the total cost of this path. In the {\em directed latency problem}, the objective is to minimize the sum of distances on this path from  to each node.  Both of these problems are NP-hard. 
The best known approximation algorithms for ATSPP had 
ratio  \cite{chekuri:pal:atspp,feige:singh} until the very recent result that improves it to  \cite{asadpour:atsp,feige:singh}. However, only a bound of  for the integrality gap of its linear programming relaxation has been known. For directed latency, the best previously known approximation algorithm has a guarantee 
of , for any constant  \cite{nagarajan:ravi:latency}. 


We present a new algorithm for the ATSPP problem that has an approximation ratio of , 
but whose analysis also bounds the integrality gap of the standard LP relaxation of ATSPP by the same factor. This solves an open problem posed in \cite{chekuri:pal:atspp}.  We then pursue
a deeper study of this linear program and its variations, which leads to an algorithm for the -person ATSPP (where  - paths of minimum total length are sought) and an -approximation for the directed latency problem.  


\end{abstract}

\section{Introduction}
Let  be a complete directed graph on a set of  nodes and let 
 be a cost function
satisfying the directed triangle inequality  for
all .  However,  is not necessarily symmetric: it may be that
 for some nodes .
In the metric Asymmetric Traveling Salesman Path Problem (ATSPP), we are also given
two distinct nodes .  The goal is to find a path

that visits all the nodes in  while minimizing the sum .
ATSPP can be used to model scenarios such as minimizing the total cost of travel
for a person trying to visit a set of cities on the way from a starting point to a destination. 
This is a variant of the classical Asymmetric Traveling Salesman Problem (ATSP), where the goal is to find a minimum-cost \emph{cycle} visiting all nodes.
In the -person ATSPP, given an integer , the goal is to find  paths from  to  such that every node is contained in at least one path and the sum of path lengths is minimized.


Related to ATSPP is the directed latency problem.  
On the same input, the goal is to find a 
path  that minimizes the sum of latencies of the nodes.  Here, the latency of node  in the path
is defined as .
The objective can be thought of as minimizing the total waiting time of clients or
the average response time.
There are possible variations in the problem definition, such as asking for a cycle instead of a path, or specifying only  but not , but they easily reduce to the version that we consider. 
Other names used in the literature for this problem are the {\em deliveryman problem}
\cite{minieka} and the {\em traveling repairman problem} \cite{afrati}.


\subsection{Related work}~
Both ATSPP and the directed latency problem are closely
related to the classical Traveling Salesman Problem (TSP), 
which asks to find the cheapest Hamiltonian cycle in a complete undirected graph with edge costs \cite{lawler:lenstra,gutin}.
In general weighted graphs, TSP is not approximable. However, in most practical settings it can be assumed
that edge costs satisfy the triangle inequality
(i.e.\ ).
Though metric TSP is still NP-hard, the well-known algorithm of 
Christofides \cite{christofides} has an approximation ratio of \nicefrac{3}{2}.
Later the analysis in \cite{shmoys:williamson,wolsey:heuristic} showed that this approximation algorithm actually bounds the integrality
gap of a linear programming relaxation for TSP known as the Held-Karp LP.
This integrality gap is also known to be 
at least .  Furthermore, for all
, approximating TSP within a factor of  is NP-hard \cite{papadimitriou:vempala}.
Christofides' heuristic was adapted to the problem of finding the cheapest Hamiltonian path
in a metric graph with an approximation guarantee of \nicefrac{3}{2} if at most one endpoint is specified or \nicefrac{5}{3} if both endpoints are given \cite{hoogeveen}.

In contrast to TSP, no constant-factor approximation for its asymmetric version is known. The current best approximation for ATSP is the very recent result of Asadpour et al.\ \cite{asadpour:atsp}, which gives an -approximation algorithm. It also upper-bounds the integrality gap of the asymmetric Held-Karp LP relaxation by the same factor. 
Previous algorithms guarantee a solution of cost within   factor 
of optimum \cite{frieze:galbiati,kleinberg:williamson,kaplan,feige:singh}. The 
algorithm of Frieze et al.\ \cite{frieze:galbiati} is shown to
upper-bound the  Held-Karp integrality gap by  in \cite{williamson:msthesis}, and a different proof that bounds the integrality gap of a slightly weaker LP is obtained in 
\cite{nagarajan:ravi:polylog}. The best known lower bound on the Held-Karp integrality gap is essentially 2 \cite{charikar:goemans:karloff}, and tightening these bounds remains an important open problem. ATSP is NP-hard to approximate 
within  \cite{papadimitriou:vempala}.

The path version of the problem, ATSPP, has been studied much less than ATSP, but there are some recent results concerning its approximability.
An  approximation algorithm for it was given by Lam and 
Newman \cite{lam:newman}, which 
was subsequently improved to  by Chekuri and Pal \cite{chekuri:pal:atspp}. 
Feige and Singh \cite{feige:singh} improved upon this guarantee by a constant factor and also showed that the 
approximability of ATSP and \mbox{ATSPP} are within a constant factor of each other, i.e.\ an -approximation for one implies an -approximation for the other. Combined with the result of \cite{asadpour:atsp}, this implies an  approximation for ATSPP. 
However, none of these algorithms bound the integrality gap of the LP relaxation for ATSPP. This integrality gap was considered by Nagarajan and 
Ravi \cite{nagarajan:ravi:latency}, who showed that it is at most .
To the best of our knowledge, the asymmetric path version of the -person problem has not been studied previously. However, some work has been done on its symmetric version, where the goal is to find  rooted cycles of minimum total cost (e.g., \cite{frieze:kperson}).


The metric minimum latency problem is NP-hard for both the undirected and directed versions since an exact algorithm for either of these could be used to efficiently solve the Hamiltonian Path problem.
The first constant-factor approximation for minimum latency  on undirected graphs was 
developed by Blum et al.\ \cite{blum:chalasani}. This was subsequently improved in 
a series of papers from 144 to 21.55 \cite{goemans:kleinberg}, then to 7.18 \cite{archer:levin:williamson} and ultimately to 3.59 \cite{chaudhuri}. 
Blum et al.\ \cite{blum:chalasani} also observed that
there is some constant  such that there
is no -approximation for  minimum latency unless P = NP.
For directed graphs, Nagarajan and Ravi \cite{nagarajan:ravi:latency}
gave an  approximation algorithm that runs in time ,
where  is the integrality gap of an LP relaxation for ATSPP.
Using their  upper bound on , they 
obtained a guarantee of , which is the best approximation ratio known for this problem before our present results.


\subsection{Our results}~
In this paper we study both the ATSPP and the directed latency problem.
\begin{figure}[ht]

\end{figure}
The natural LP relaxation for ATSPP is (\ref{alphalp}) with , where  denotes the set of outgoing edges from a vertex or a set of vertices, and  denotes the set of incoming edges. A variable  indicates that edge  is included in a solution.
Let us refer to this linear program as LP(), 
as we study it for different values of  in constraints~(\ref{alp-sc}). 
We begin in Section \ref{sec:atspp-ig} by proving that the integrality gap of LP() is .


\begin{theorem}\label{thm:ig}
If  is the cost of a feasible solution to LP (\ref{alphalp})
with , then one can find, in polynomial time,
a Hamiltonian path from  to  with cost at most
.\footnote{All logarithms in this paper are base 2.}
\end{theorem}

We note that, despite bounding the integrality gap, our algorithm is actually combinatorial and does not require solving the LP. 
We strengthen the result of Theorem \ref{thm:ig} by extending it to any 
 with . 
This captures the LP of \cite{nagarajan:ravi:latency}, which has , and is also used in our algorithm for the directed latency problem.
We prove the following theorem in Section \ref{sec:atspp-alpha1}.

\begin{theorem}\label{thm:a-ig}
If  is the cost of a feasible solution to LP (\ref{alphalp})
with , then one can find, in polynomial time,
a Hamiltonian path from  to  with  cost at most .
\end{theorem}

It is worth observing that this theorem, together with the results of \cite{nagarajan:ravi:latency}, imply a polylogarithmic approximation algorithm for the directed latency problem which runs in quasi-polynomial time, as well as a polynomial-time -approximation.
However, that approach relies on guessing a large number of intermediate vertices of the path, and thus does not yield an algorithm that has both a polynomial running time and a polylogarithmic approximation guarantee. 
So, to obtain a polynomial-time approximation, we use a different approach. 
For that we consider LP() for values of  that include .
If we allow  then LP(),
as a relaxation of ATSPP, can be shown to have an unbounded integrality gap.
However, we prove the following theorem in Section \ref{sec:atspp-alpha2}.


\begin{theorem}\label{thm:kpath}
If  is the cost of a feasible solution to 
LP (\ref{alphalp}) with
, for integer , then one can find, in polynomial time,
a collection of at most  paths from  to , such 
that each vertex of  appears on at least one path,
and the total cost of all these paths is at most .
\end{theorem}

Next, we study another generalization of the ATSPP, namely the -person asymmetric traveling salesman path problem. In Section \ref{sec:kperson} we prove the following theorem:

\begin{theorem}\label{thm:kperson}
There is an  approximation algorithm for the -person ATSPP. 
Moreover, the integrality gap of its LP relaxation is bounded by the same factor.
\end{theorem}

Given these results concerning LP(), we study a particular
LP relaxation for the directed latency problem in Section \ref{sec:latency}.
We improve upon the -approximation of \cite{nagarajan:ravi:latency} substantially by proving the following:

\begin{theorem} \label{thm:lat}
A solution to the directed latency problem can be found in polynomial time
that has cost no more than , where  is the value 
of LP relaxation (\ref{lp:lat}), which is also a lower bound on the integer optimum.
\end{theorem}

We note that this seems to be the first time that 
a bound is placed on the integrality gap of any LP relaxation for the minimum latency problem, even in the undirected case.


\section{Integrality gap of ATSPP} \label{sec:atspp-ig}

We show that LP relaxation (\ref{alphalp}) of ATSPP with  has integrality gap of .
Let  be its optimal fractional solution, and let  be its cost.
We define a \emph{path-cycle cover} on a subset of vertices  containing  and  to be the union of one - path and zero or more cycles, such that each  occurs in exactly one of these subgraphs. The cost of a path-cycle cover is the sum of costs of its edges.

Our approach is an extension of the algorithm by Frieze et al.\,\cite{frieze:galbiati}, analyzed by Williamson\,\cite{williamson:msthesis} to bound the integrality gap for ATSP. That algorithm finds a minimum-cost cycle cover on the current set of vertices, chooses an arbitrary representative vertex for each cycle, deletes other vertices of the cycles, and repeats, at the end combining all the cycle covers into a Hamiltonian cycle. As this is repeated at most  times, and the cost of each cycle cover is at most the cost of the LP solution, the upper bound of  on the integrality gap is obtained.  In our algorithm for ATSPP, the analogue of a cycle cover is a path-cycle cover (also used in \cite{lam:newman}), whose cost is at most the cost of the LP solution (Lemma \ref{lem:pathcyc}). At the end we combine the edges of  path-cycle covers to produce a Hamiltonian path. However, the whole procedure is more involved than in the case of ATSP cycle. For example, we don't choose arbitrary representative vertices, but use an amortized analysis to ensure that each vertex only serves as a representative a bounded number of times.

We note that a path-cycle cover of minimum cost can be found by a combinatorial algorithm, using a reduction to minimum-cost perfect matching, as explained in \cite{lam:newman}.  
In the proof of Lemma \ref{lem:pathcyc} below, we make use of the following splitting-off theorem, as also done in \cite{nagarajan:ravi:polylog}, where splitting off edges  and  refers to replacing these edges with the edge  (unless , in which case the two edges are just deleted). 

\begin{theorem}[Frank \cite{frank} and Jackson \cite{jackson}] \label{thm:so}
Let  be a Eulerian directed graph and . There exists an edge  such that splitting off  and  
does not reduce the directed connectivity from  to  for any .
\end{theorem}
This theorem also applies to weighted Eulerian graphs, i.e.\ ones in which the weighted out-degree of every vertex is equal to its weighted in-degree, since weighted edges can be replaced by multiple parallel edges, producing an unweighted Eulerian multigraph.

\begin{lemma} \label{lem:pathcyc}
For any subset  that includes  and , there is 
a path-cycle cover of  of cost at most .
\end{lemma}
\begin{proof}
Consider the graph  obtained from  by assigning capacities  to edges  and adding a dummy edge from  to  with unit capacity. From constraints (\ref{flcon})-(\ref{con3}) of LP() it follows that this is a weighted Eulerian graph. Constraints (\ref{alp-sc}) and the max-flow min-cut theorem imply that for any , the directed connectivity from  to  in  is at least .

We apply the splitting-off operation on , as guaranteed by Theorem \ref{thm:so}, to vertices in  until all of them are disconnected from the rest of the graph. Let  be the resulting graph on  and let  be its edge capacities except for the dummy edge  (which was unaffected by the splitting-off process).
By Theorem \ref{thm:so}, the directed connectivity from  to any  does not decrease from the splitting-off operations, which means that in  it is still at least . This ensures that  satisfies constraints (\ref{alp-sc}) for all sets  with  and 
, and is a feasible solution to LP() on the subset  of vertices. Furthermore, the triangle inequality implies that the cost of  is no more than that of , namely .

Now we make the observation that if we remove from LP() constraints (\ref{alp-sc}) for all but singleton sets, the resulting LP is equivalent to a circulation problem, and thus has an integer 
optimal solution. Since there is a feasible solution to LP() on the set  of cost at most  (namely ), and removing a 
constraint can only decrease the optimal objective value, it means that there is an integer solution to the following program that costs no more than :

In principle, this integer solution can have  
for some nodes . In this case, we find a Euler tour of each component of the resulting graph (with dummy edge  added in) and shortcut it over any repeated vertices. This ensures that  for all  without increasing the cost. 
But such a solution is precisely a path-cycle cover of .
\end{proof}

\medskip




\begin{algorithm*}[ht]
  \caption{~Asymmetric Traveling Salesman Path} \label{alg:ig} 
\begin{algorithmic}[1] 
\State Let a set ; integer labels  for all ; flow  and circulation   \label{line:one}
\For { iterations} \label{line:iter}
\State Find the minimum-cost - path-cycle cover  on  
\label{line:findflow}
\State  \label{line:addf}
\Comment  is acyclic before this operation
\State Find a path-cycle decomposition of , with cycles  and paths , such that  is acyclic
\For {each connected component  of } \label{line:finda}
\Comment  is a circulation
\State For each vertex , let  be the in-degree of  in 
\State Find a ``representative'' node  minimizing  \label{line:findv}
\State 
\Comment subtract flows
\State {\bf for} each , , and for each path  
\State ~~~~~{\bf if}  {\bf then} modify  by shortcutting  over 
\State Remove all nodes in , except , from  \label{line:delw}
\Comment Note: they don't participate in  anymore
\State 
\Comment add circulations
\State 
\EndFor
\EndFor \label{line:endfor}
\State Let  be an - path consisting of nodes in  in the order found by  	topologically sorting  \label{line:findp} \newline \mbox{}
\Comment  is an acyclic flow on the nodes 
\For {every connected component  of  of size } \label{line:cyc}
\State Find a Euler tour of , shortcut over nodes that appear more than once \label{line:euler}
\State Incorporate the resulting cycle into  using a shared node \label{line:inc}
\EndFor \label{line:endcyc}
\State {\bf return} 
\Comment  is a Hamiltonian - path
\end{algorithmic}
\end{algorithm*}



We consider Algorithm~\ref{alg:ig}. Roughly speaking, the idea is to find a path-cycle cover, select a representative node for each cycle, delete the other cycle nodes, and repeat. Actually, a representative is selected for a component more general than a simple cycle, namely a union of one or more cycles. We ensure that each vertex is selected as a representative at most  times, which means that after  iterations, each surviving vertex has participated in the acyclic part of the path-cycle covers at least  times. This allows us at the end to find an - path which spans all the surviving vertices, , and consists entirely of edges in the acyclic part, , of the union of all the path-cycle covers, using a technique of \cite{nagarajan:ravi:latency}. Then we insert into it the subpaths obtained from the cyclic part, , of the union of path-cycle covers, connected through their representative vertices. 
We occasionally treat subgraphs satisfying appropriate degree constraints as flows or circulations.



\begin{lemma} \label{lem:label}
During the course of the algorithm, no label  exceeds the value .
\end{lemma}

The idea of the proof is, as the algorithm proceeds, to maintain a forest on the set of nodes , such that the number of leaves in a subtree rooted at any node  is at least . The lemma then follows because the total number of leaves is at most . 
We first prove an auxiliary claim.

\begin{claim} \label{claim:xy}
In each component  found by  Algorithm \ref{alg:ig} on line \ref{line:finda}, there are two distinct nodes  and  such that .
\end{claim}
\begin{proof}
Let  be the value of  at the start of the current iteration of the outside loop, 
i.e. before  is added to it on line \ref{line:addf}.  is acyclic, because during 
the course of the loop, all cycles of  are subtracted from it. So  is a union of cycles, 
formed from the sum of an acyclic flow  and a path-cycle cover , which sends exactly 
one unit of flow through each vertex. 

Consider a topological ordering of nodes based on the flow , and let  and  be 
the first and last nodes of , respectively, in this ordering. As  always contains at least 
two nodes,  and  are distinct. Since  and  participate in some cycle(s) in , their 
in-degrees are at least 1. We now claim that the in-degree of  in  is at most 1.  Indeed, 
since all other nodes of  are later than  in the topological ordering, it cannot have any 
flow coming from them in . So the only incoming flow to  can be in .  But since 
 sends a flow of exactly one unit through each vertex, the in-degree of  in  is at most 
one.  A symmetrical argument can be made for , showing that its out-degree in  is at most 
one.  But since  is a union of cycles, every node's in-degree is equal to its out-degree, and 
the in-degree of  is also at most 1.
\end{proof}



\begin{proofof}{Lemma \ref{lem:label}}
As the algorithm proceeds, let us construct a forest on the set of nodes . Initially, each 
node is the root of its own tree. We maintain the invariant that  is the set of tree roots 
in this forest. For each component  that the algorithm considers, and the node  found 
on line \ref{line:findv}, we attach the nodes of , except , as children of . Note 
that the invariant is maintained, as these nodes are removed from  on line \ref{line:delw}. 
The set of nodes of each component  found on line \ref{line:finda} is always 
a subset of , and thus our construction indeed produces a forest. 

We show by induction on the steps of the algorithm that if a node has label , then its 
subtree contains at least  leaves. Thus, since there are  nodes total, no label can 
exceed . At the beginning of the algorithm, all labels are 0, and all trees have 
one leaf each, so the base case holds. Now consider some iteration in which the label of 
vertex  is increased from  to . By Claim  \ref{claim:xy}, there are 
nodes  (possibly one of them equal to ) with . Since  minimizes 
 among all vertices  , we have that  and 
, and thus  and . 
Thus, by the induction hypothesis, the trees rooted at  and  each have at least 
 leaves. Because we update the forest in such a way that 's new tree 
contains all the leaves of trees previously rooted at  and , this tree now has at 
least  leaves. 
\end{proofof}



\begin{lemma} \label{lem:amtflow}
At the end of the algorithm's main loop, the flow in  passing through any node  
is equal to , and thus (by Lemma \ref{lem:label}) is at least .
\end{lemma}
\begin{proof}
There are  iterations, each of which adds one unit of flow through each vertex . 
We now claim that for a vertex , the amount of flow removed from it is equal to its label, 
. Flow is removed from  only if  becomes part of some component . Now, if it is ever 
part of , but not chosen as a representative on line , then it is removed 
from . Thus, we are only concerned about vertices that are chosen as representatives every 
time that  they are  part of . Such a vertex has flow  going through it in , which 
is the amount subtracted from . But since this is also the amount by which its label increases, 
the lemma follows.
\end{proof}

\medskip



We now show that Algorithm \ref{alg:ig} returns a Hamiltonian - path of cost at most .



\begin{proofof}{Theorem \ref{thm:ig}}
At the end of the main loop, all nodes of  are part of either  or  or both. So when 
all components of  are incorporated into the path , all nodes of  become part of the path. 
We bound the cost of all the edges used in the final path by the total cost of all the path-cycle covers found on 
line \ref{line:findflow} of the algorithm. We note that at the end of the algorithm, the cost of 
the flow  is no more than this total.

We claim that when the - path  is found on line \ref{line:findp},   contains flow on 
every edge between consecutive nodes of . 
This is similar to an argument used in \cite{nagarajan:ravi:latency}.
First, since  is acyclic, it has a topological ordering. Suppose we find a flow decomposition of  into paths. There are at most  
such paths, and, by Lemma \ref{lem:amtflow}, each vertex of  participates in at least 
, or more than half, of them.  This means that any two vertices  must 
share a path, say , in this decomposition. In particular, suppose that  immediately 
follows  in the path . This means that  appears later than  in the topological 
order, so on   comes after . Moreover, we claim that on ,  will be the immediate 
successor of . If not, suppose that there is a node  that appears between  and  in . 
But this means that in the topological ordering (and thus in ),  will appear after  and 
before , which contradicts the fact that they are consecutive in . So we conclude that there 
is an edge with flow in  between any two consecutive nodes of , and thus the path  costs 
no more than the flow . 

Regarding , we note that it is a sum of cycles, and thus Eulerian. So it is possible to find a 
Euler tour of each of its components, using only edges with flow in . The subsequent shortcutting 
can only decrease the cost. Thus, the total cost of cycles found on line \ref{line:euler} is no more 
than the cost of the flow . To describe how these cycles are incorporated into the path , we 
show that each of them (or, equivalently, each connected component of ) shares exactly one node with  (and thus with ). Note that every  component  added to  contains only 
nodes that are in  at that time. Moreover, when this is done, all but one nodes of  are 
expelled from . So when several components of  are connected by the addition of , the 
invariant is maintained that there is one node per component that is shared with . Now, 
suppose that  is the vertex shared by the cycle obtained from component  and the path . 
On line \ref{line:inc}, we incorporate the cycle into the path by following the path up to , 
then following the cycle up to the predecessor of , then connecting it to the successor of  
on the path. By triangle inequality, the resulting longer path costs no more than the sum of costs 
of the old path and the cycle.
\end{proofof}




\section{Integrality gap for relaxed ATSPP LP} \label{sec:atspp-alpha1}

Consider LP() 
with , and say that it has cost . We bound its integrality gap for ATSPP. 
As in the proof of Lemma \ref{lem:pathcyc}, we can apply splitting-off to obtain a feasible solution 
to LP(), of cost at most , on a graph induced by a subset of vertices . 
Let  be such a solution. Lemma \ref{lem:tr} below shows how to use  to find a feasible fractional 
solution to LP (\ref{intlp}) on , of cost within a constant factor of , namely . 
Since LP (\ref{intlp}) has integer optimum, there is an integer solution to  LP (\ref{intlp}) on , and thus a path-cycle cover,  
of cost at most . Then we can proceed as in Section \ref{sec:atspp-ig}, applying Algorithm \ref{alg:ig} to bound the cost of the resulting ATSPP solution by  times the path-cycle cover cost. This shows that LP() has integrality gap at most 
, proving Theorem \ref{thm:a-ig}.


\begin{lemma} \label{lem:tr}
Given a solution  to LP(), with , on a subset , with cost at most , a feasible solution to LP (\ref{intlp}) on  of cost at most  can be found.
\end{lemma}
\begin{proof}
Multiply  by . Now it constitutes a flow  of  units from  to . 
Constraints (\ref{alp-sc}), restricted to sets of size 1, imply that each node  now has at 
least one unit of flow going through it. Find a flow decomposition of  into paths and cycles, 
so that the union of the paths is acyclic. Let , where  is the sum of flows on 
the paths in our decomposition, and  is the sum of flows on the cycles. 

Choose some  such that . For any node  such that the 
amount of  flow going through  is less than , shortcut any flow decomposition 
paths that contain , so that there is no more  flow going through . Let  
be the set of vertices still participating in the  flow. Then each vertex in  has at least 
 units of  flow going through it, and each vertex in  has at least 
 units of  flow going through it.  

We find a topological ordering of vertices in  according to  (which is acyclic), and 
let  be an - path that visits the nodes of  in this topological order. We claim 
that the cost of  is within a constant factor of the cost of .
The argument for this is similar to one in the proof of Theorem \ref{thm:ig}.
Out of  units of flow 
going from  to  in , each vertex  carries  units, which is more than half of the total amount 
(as ). So for any two such vertices  and , there must be shared flow paths that carry flow of at least  units. 
In particular, for every 
two consecutive nodes ,  must contain such shared paths in which  immediately follows .  So the cost of  is at most  times the cost of .

We now define  as a flow equal to one unit of - flow on the path  plus 
 times the flow .  We claim that  is a feasible solution 
to LP (\ref{intlp}): there is exactly one unit of flow from  to  (as  consists of 
cycles not containing  or ); there is flow conservation at all nodes except  and ; 
each vertex in  (and thus in ) has at least one unit of flow going through it; and each 
vertex in  has at least one unit of flow going through it (as it had at least 
 units of  flow).  The cost of this solution is at most 

If we set , which satisfies , 
we see that the cost of  is at most .
\end{proof}



\section{Relaxed ATSPP LP with } \label{sec:atspp-alpha2}

Consider LP (\ref{alphalp}) with  for some integer . 
It can be shown that, as a relaxation for the ATSPP problem, this LP has unbounded integrality gap.
For example, let  be an arbitrarily large value and consider the shortest path metric obtained from
the graph in Figure \ref{fig:badgap}. One can verify that the following assignment of -values
to the arcs is feasible for LP (\ref{alphalp}) with .
Assign a value of \nicefrac{1}{2} to arcs , , , , , 
and  and a value of 1 to arcs  and .
Every other arc is assigned a value of 0. This assignment is feasible for the linear program and
has objective function value 5. On the other hand, any Hamiltonian path
from 1 to 6 has cost at least .


\begin{figure}
\begin{center}
\includegraphics[scale=0.45]{badgap.eps}
\caption{Bad gap example for LP (\ref{alphalp}) with . Here,  is an arbitrarily large integer.}\label{fig:badgap}
\end{center}
\end{figure}

Let  be the cost of the optimal solution to LP(). We show 
how to find  paths from  to , such that each node of  appears on at least 
one path, and the total cost of all these paths is at most . Let us define a 
-path-cycle cover to be a set of  disjoint 
paths from  to  and zero or more cycles, which together cover all nodes. 
Like a path-cycle cover, the minimum-cost -path-cycle cover can be found by a combinatorial algorithm
by creating  copies of both  and  and using the matching algorithm described in \cite{lam:newman}.

\begin{lemma} \label{lem:kpathcyc}
For any subset  that includes  and , there is a 
-path-cycle cover of  with total cost at most .
\end{lemma}
\begin{proof}
As in the proof of Lemma \ref{lem:pathcyc}, we apply splitting-off to a solution of LP() to get a solution to LP() on a subset  of vertices, of 
no greater cost. Now, if we multiply this solution by , we get a feasible solution to 
LP (\ref{intlp}) with constraints (\ref{amtfl}) replaced with 

The cost of this solution is no more than . 
But this LP has an integer optimum, which, possibly after shortcutting, is exactly a -path-cycle cover. 
\end{proof}



\begin{proofof}{Theorem \ref{thm:kpath}}
We start with  and repeat the following until : 
\begin{compactenum}
\item
Find a -path-cycle cover  of  of cost at most , as guaranteed by Lemma \ref{lem:kpathcyc}.
\item
Remove from  all nodes (except  and ) that participate in paths of .
\item
For each cycle  of , choose a representative node , and remove from  all nodes of  except .
\end{compactenum}

\noindent
Let us say that the procedure terminates after  iterations. As the size of  halves in each iteration, 
 is at most . In the last iteration, all elements of  must have participated in the paths, 
as otherwise there would be a node  that remains in  after this iteration. This implies that the graph 
 is connected. It also has total cost at most , and, if we add  edges from  to 
, becomes Eulerian. This means that we can construct 
 paths from  to , covering all nodes of , out of edges of . 
\end{proofof}

\section{Algorithm for -person ATSPP}\label{sec:kperson}
In this section we consider the 
-person asymmetric traveling salesman path problem. 
The LP relaxation for this problem is similar to LP (\ref{alphalp}), but with 
 for constraint (\ref{con2}) and  for constraint (\ref{alp-sc}). 
Arguments similar to those in Section \ref{sec:atspp-ig} show that a -path-cycle cover on any subset  is a 
lower bound on the value of the LP relaxation for the -person ATSPP. Our algorithm constructs a solution that 
uses each edge of  -path-cycle covers at most  times, proving a bound of  on the  approximation ratio and the integrality gap.

Our algorithm starts by running lines \ref{line:one}-\ref{line:endfor} of Algorithm \ref{alg:ig}, except 
with  iterations of the loop and finding minimum-cost -path-cycle covers instead of 
the path-cycle covers on line \ref{line:findflow}. Then it finds  - paths in the resulting acyclic
 graph , satisfying conditions of Lemma~\ref{lem:kpaths} below. The algorithm concludes by incorporating each 
component of the circulation  into one of the obtained paths, similarly to lines \ref{line:cyc}-\ref{line:endcyc} 
of Algorithm \ref{alg:ig}. 

\begin{lemma} \label{lem:kpaths}
After lines \ref{line:one}-\ref{line:endfor} of Algorithm \ref{alg:ig} are executed with  iterations of the 
loop on line \ref{line:iter} and finding minimum-cost -path-cycle covers on line \ref{line:findflow}, there 
exist  - paths in the resulting acyclic graph , such that each edge of  is used at most  times, 
and every node of  is contained in at least one path. Moreover, these paths can be found in polynomial time.
\end{lemma}
\begin{proof}
We prove the existence result first. 
We note that the graph  can support  units of flow from  to . This is because in each of the  
iterations,  - paths were added to the graph, whereas the removal of cycles does not decrease the 
amount of flow supported. So  can be decomposed into  edge-disjoint paths from  to . Moreover,
 each node of  participates in at least  of these paths by Lemma \ref{lem:amtflow}.

Let  be the comparability graph obtained from . Namely,  has the same set of nodes as , and there
 is an undirected edge between nodes  and  in  if  contains a directed path either from  to 
 or from  to . We claim that the nodes of  can be partitioned into at most  cliques. As comparability
 graphs are perfect graphs \cite{golumbic}, the minimum number of cliques that  can be partitioned into is
 equal to the size of the maximum independent set in . So suppose, for the sake of contradiction, that  
contains an independent set  of size . Then no nodes in  must share any of the paths in our decomposition
 of . Since each appears on at least  paths, there must be at least  paths total 
in the decomposition. However, this is a contradiction, 
since .

Given the set of  cliques in , we can convert each of them into an - path in . For each
 such clique , order the nodes of  in a way consistent with a topological ordering of . Then
  contains a path from each node  of  to the next node : the existence of a  edge in 
 shows that there is a path between these nodes in , and the topological ordering guarantees that this
 path goes in the correct direction. There must also be paths from  to the first node of  as well as
 from the last node of  to , since  is the only source and  is the only sink of . Furthermore,
 the acyclicity of  shows that each edge of  is used at most once for connecting nodes in . As there
 are  cliques, each edge is used at most  times in total. If the number of cliques is smaller than ,
 then we can add arbitrary paths from  to our collection to obtain exactly  paths. 

To find the required paths algorithmically, we construct the following bipartite graph  from  with bipartitions  and . For each , add nodes  to  and  to  (note that ). Now, for each ordered pair of nodes  such that there is a directed path from  to  in , add an edge from  to . Let  be the directed graph obtained from  by orienting each edge  according to flow . It is easy to see that any collection of  disjoint cliques covering  corresponds to a covering of  by  vertex-disjoint paths and vice-versa. We claim that there is a covering of  by  disjoint paths if and only if there is a matching in  that leaves only  nodes in  and  nodes in  unmatched.

Consider a covering of  by  vertex-disjoint paths . Form a matching .
Since  is a collection of vertex-disjoint paths, each node has indegree and outdegree at most one in , so
 is a valid matching. Furthermore, since  covers the nodes of  with  paths, then exactly  nodes
have indegree 0 and exactly  nodes have outdegree 0. Thus, in  exactly  nodes of  and  nodes of  are unmatched.
Conversely, let  be a matching of  that leaves exactly  nodes of  unmatched. For each unmatched node ,
form a directed path in  starting at  by the following process. If  is matched to, say, , then add arc 
to the path. Continue this process from  until the corresponding node in  is not matched. This will
form  vertex-disjoint paths in  that cover all nodes.

As noted earlier, we know that  can be covered by at most  disjoint cliques. Therefore, there is a matching in  that
leaves at most  nodes in  and  nodes in  unmatched. Compute such a matching and map it to the corresponding paths
in . Finally, extend these at most  paths to  paths by adding an arc from  to the start of each path and an arc
from the end of each path to . Again, since the only source in  is  and the only sink in  is , these arcs correspond
to edges in .
\end{proof}

\begin{proofof}{Theorem \ref{thm:kperson}}
Let  be the cost of a linear programming relaxation for the problem. 
The edges of  as well as the edges used to connect the eulerian components of  to the paths come from the union of  -path-cycle covers on subsets of , and thus cost at most . However, the algorithm may use each edge of  up to  times in the paths of Lemma \ref{lem:kpaths}, which makes the total cost of the produced solution at most .
\end{proofof}





\section{Approximation algorithm for Directed Latency} \label{sec:latency}
We introduce LP relaxation (\ref{lp:lat}) for the directed latency problem.
The use of  and  variables in an integer programming formulation for directed latency was proposed by Mendez-Diaz et al.\ \cite{mendez-diaz}, who do a computational evaluation of the strength of its LP relaxation. However, our LP formulation uses a different set of constraints than the one in \cite{mendez-diaz}.

In LP (\ref{lp:lat}), a variable  indicates
that node  appears before node  on the path. Similarly,  for three distinct nodes , ,  indicates that they appear in this order on the path. For every node ,
we send one unit of flow from  to , and we call it the -flow. 
Then  is the amount of -flow going through edge , and  is the latency of node .
To show that this LP is a relaxation of the directed latency problem, given a solution path , 
we can set  whenever the edge  is in  and  occurs later than  in , 
and  otherwise. So  is one unit of flow from  to  along the path .
Also setting the ordering variables  and  to 0 or 1 appropriately and setting  to the latency of  in , we get a feasible solution to LP (\ref{lp:lat}) of the same cost as the total latency of .

\begin{figure}[ht]

\end{figure}


Constraints (\ref{vflcon}) are the flow conservation constraints for -flow at node .
 Constraints (\ref{fvus-const}) ensure that no -flow enters  or leaves . 
Constraints (\ref{fx-const}) say that -flow passes through  if and only if  occurs before . 
Since the -flow goes through every vertex, when all the variables are in , it defines an - path.
We can think of the -flow as the universal flow
and Constraints (\ref{univ-const}) ensure that every  -flow follows an edge which
has a universal flow on it. 
Constraints (\ref{lat-set-const}), in an integer solution, ensure that if a set  contains some node 
 that comes before  (i.e.\ ), then at least one unit of -flow enters . 

We note 
that a min-cut subroutine can be used to detect violated constraints of type (\ref{lat-set-const}), allowing us to solve 
 LP (\ref{lp:lat}) using the ellipsoid method. 
Our analysis does not actually use 
Constraints (\ref{univ-const}), so we can drop them from the LP. Although without these
constraints the corresponding integer program may not be an exact formulation
for the directed latency problem,
we can still find a solution whose cost is within factor  of this relaxed LP.



\begin{lemma}\label{lem:scale}
Given a feasible solution to LP (\ref{lp:lat}) with objective value
, we can find another solution of value at most  in which the ratio of
the largest to smallest latency  is at most .
\end{lemma}
\begin{proof}
Let  be a feasible solution with value , with  the largest latency value in this solution. Note that .
Define a new feasible solution  by .
The total increase in the objective function is at most  as there are  nodes in total. Thus, the objective value of this new solution is at most .
\end{proof}

\medskip



Using Lemma \ref{lem:scale} and scaling the edge lengths (if needed), 
we can assume that we have a solution  satisfying the following:

\begin{corollary} \label{cor:lstar}
There is a feasible solution 
in which the smallest latency is 1 and the largest latency is at most  and whose cost is at most  times the optimum LP solution.
\end{corollary}

\noindent
Let  be the value (i.e. total latency) of this solution.

The idea of our algorithm is to construct - paths for several nodes , such that together they cover all vertices of , and then to ``stitch'' these paths together to obtain one Hamiltonian path. We use our results for ATSPP to construct these paths.  For this, we observe that parts of a solution to the latency  LP (\ref{lp:lat}) can be transformed to obtain feasible solutions to different instances of 
LP().  For example, we can construct a Hamiltonian - path of total length  as follows. From a solution to LP (\ref{lp:lat}), take the -flow defined by the variables , and notice that it constitutes a feasible solution to LP(). In particular, since  for all , constraints (\ref{lat-set-const}) of LP (\ref{lp:lat}) for   imply that the set constraints (\ref{alp-sc}) of LP (\ref{alphalp}) are satisfied.  The objective function value for LP (\ref{alphalp}) of this solution is at most . Thus, by Theorem \ref{thm:ig}, we can find the desired path. Of course, this path is not yet a good solution for the latency problem, as even nodes  with  can have latency in this path close to .  Our algorithm constructs several paths of different lengths, incorporating most nodes  into paths of length , and then combines these paths to obtain the final solution.



\begin{algorithm*}[ht]
  \caption{~Directed Latency} \label{alg:latency} 
\begin{algorithmic}[1] 
\State Let  be a solution to LP (\ref{lp:lat}). Let  be the path .
\State Partition the nodes into 
sets  with  if .
\For { to }\label{stp:forloop}
\For { to }
\If {}

\State Let  \label{step:vij}
\Comment this maximizes the size of  below

\State Let 
\State Let 
\Comment 

\State Find an - path , containing , of cost ; append  to . \label{stp:pij}

\State Find  - paths , containing , of total cost at most 
; append  to . \label{stp:pijs}

\State  \label{stp:decv}
\Comment size of  is at least halved

\EndIf
\EndFor
\State Let  \label{stp:move-nodes}
\Comment remaining nodes are carried over to the next set

\EndFor
\State Construct an - path , containing , of cost at most .  Append  to . \label{stp:pst}
\State Shortcut  over the later copies of repeated nodes. Output .

\end{algorithmic}
\end{algorithm*}

\subsection{Constructing the paths}~
Algorithm \ref{alg:latency} finds an approximate solution to the directed latency problem, and we now explain how some of its steps are performed. The algorithm maintains a path , initially containing only the source, and gradually adds new parts to it. This is done through operation \emph{append} on lines \ref{stp:pij}, \ref{stp:pijs}, and \ref{stp:pst}. To append a path  to  means to extend  by connecting its last node to the first node of  that does not already appear in , and then following until the end of . For example, if  and , the result is . Step \ref{stp:pijs} appends a set of paths to . This just means sequentially appending all paths in the set, in arbitrary order, to .


Next we describe how to build paths  and  in Steps \ref{stp:pij} and \ref{stp:pijs}. We described above how to use Theorem \ref{thm:ig} to build a Hamiltonian - path  of length , which is used on line \ref{stp:pst} of the algorithm.  The idea behind building paths  and  with their corresponding length guarantees is similar.

To construct , we do the following.
Since each node  has ,  the amount of -flow
that goes through  is at least . We apply splitting-off on this flow to nodes outside of  , and obtain a total of one unit of - flow over the nodes in , of cost no larger than . This flow satisfies all the constraints of LP(), including the set constraints (\ref{alp-sc}), which are implied by the set constraints (\ref{lat-set-const}) of the latency LP (\ref{lp:lat}), as  for .
Thus, using Theorem \ref{thm:a-ig}, we can find a path from  to , spanning
all the nodes of , whose cost is at most  for some constant .

To obtain the set of paths , we look at the -flow going through each node of , whose amount is at least . After splitting-off all nodes outside of , we get a feasible solution of cost at most  to LP(). 
By Theorem \ref{thm:kpath}, we can find 
 paths, each going from  to , which together cover all the nodes of , and whose total cost is at most .

\subsection{Connecting the paths}~
We now bound the lengths of edges introduced by the append operation in the different cases. For a path ,
let  be the length of the edge used for appending  to the path  in the algorithm.

\begin{lemma} \label{lem:app-p}
For any , , and path , . Also, .
\end{lemma}
\begin{proof}
Let  be the last node of the path  before the append operation,  be the last node of , and  be the first node of  that does not appear in . We need to bound , the distance from  to . 

We observe that . If , this is trivial. Otherwise,  is the endpoint of some path constructed in an earlier iteration. Note that   and   by our assumption that , which means that . So, if we had , then  would be included in the set  and in the path , and thus be already contained in , which is a contradiction.

Consequently, . 
This means that the amount of -flow that goes through  is at least . Since this flow has to reach  after visiting , it has to cover a distance of at least , thus adding at least  to , the latency of . Thus, , and . Now, if , it must be in , which, by definition, means that , and therefore . So . If , then .
\end{proof}

\medskip



To bound the cost of appending a path  to , we need an auxiliary lemma.

\begin{lemma} \label{lem:ijk}
For any , if , then .
\end{lemma}
\begin{proof}
Using Constraint (\ref{xijk-const}) we have:


On the other hand, , 
using again Constraint (\ref{xijk-const}), then Constraint (\ref{xij-const}), and the assumption of the lemma.
Therefore,  , i.e. .  
Then the claim follows using Constraint (\ref{lk-const}).
\end{proof}

\begin{lemma} \label{lem:app-pij}
For any  and , .
\end{lemma}
\begin{proof}
Let , , and  be as in the proof of Lemma \ref{lem:app-p}.
To bound , we consider two cases.

{\bf Case 1:} If , we apply the same proof as for Lemma \ref{lem:app-p} and conclude that .

{\bf Case 2:} If , let  be an earlier iteration of the algorithm in which node  was added to . Since , it must be that , and thus . On the other hand, since , it must be that . Because , we have

Using Lemma \ref{lem:ijk}, we get that 
. 
\end{proof}



\begin{lemma}\label{lem:Pi-late}
Suppose that a node  is first added to path  in iteration  of the outer loop of the algorithm. Then the latency of  in  is at most , for some constant .
\end{lemma}
\begin{proof}
Let  denote the length of a path .  The latency of node  on  is at most:

\end{proof}

\medskip



Suppose that  is the number of nodes that are originally placed into the set  . Since a node  is originally placed in  if , the value of the LP solution  can be bounded by:



Let  denote the size of  at the beginning of iteration  of the outer loop. Note that  may be larger than  since some nodes may have been moved to  in Step \ref{stp:move-nodes} of the previous iteration.

\begin{claim} \label{cl:cov}
For any , the size of the set  at the end of iteration  is at most .
\end{claim}
\begin{proof}
Consider the iteration .  Note that the vertex  is chosen precisely to maximize the number of nodes  in  with , which is the size of the set . If we imagine a directed graph  on the set of vertices , in which an edge  exists whenever , then  is the vertex with highest in-degree in this graph. Now, from  Constraint (\ref{xij-const}), it's not hard to see that some vertex in  will have in-degree at least . So the number of nodes removed from  in step \ref{stp:decv} of the algorithm is at least , and size of  decreases at least by a factor of two. Similarly, at least half of the remaining nodes of  are removed in the iteration , so overall the size of  decreases at least by a factor of four.
\end{proof}

\medskip




We now show that the total latency of the final solution  
is at most .



\begin{proofof}{Theorem \ref{thm:lat}}
From Claim \ref{cl:cov}, it follows that at most
a  fraction of the  nodes that are in  at the beginning of iteration  are moved to the set  at the end of this iteration. Thus, for any ,~ . This implies that .

Now we claim that the total latency of the solution  is at most
.
This is because at most  nodes are added to  in iteration , and each such node has latency
at most  (using Lemma \ref{lem:Pi-late}). 
Therefore, the total latency of the solution is at most:

using the bound on , re-ordering the summation, and using inequality (\ref{eqn:opt-lower}). Combined with Corollary \ref{cor:lstar}, this proves the theorem.
\end{proofof}








\subsection{Extensions}
The above algorithm can be easily extended to the more general setting in which every node of the graph comes with a weight  and the goal is to find a Hamiltonian - path to minimize the total {\em weighted} latency, where the weighted latency of a node  is equal to 
. 
This requires changing the objective function of LP (\ref{lp:lat}) to  and changing the definition of  on line \ref{step:vij} of Algorithm \ref{alg:latency} to maximize the total weight, instead of the number, of vertices in .

We also note that our approximation guarantee for directed latency is of the form , where  is the integrality gap of ATSPP. So an improvement of the bound on  would not immediately lead to an improvement for directed latency. 

\section*{Acknowledgements} This work was partly done while the second author was visiting Microsoft Research New England; he thanks MSR for hosting him. We also thank the anonymous referees for helpful comments.



\bibliographystyle{plain}
\bibliography{../../bib/names,../../bib/conferences,../../bib/bibliography}


\end{document}
