\documentclass[12pt]{article}

\usepackage[dvips]{epsfig}
\usepackage{latexsym}
\usepackage{color}


\usepackage{subfig}

\def\a{\alpha}
\def\b{\beta}
\def\e{\epsilon}

\def\c{\mathrm{\raisebox{.07cm}{}}}
\def\opt{\text{\sc opt}}
\newcommand{\nba}{{\sc nba}}
\def\poly{\mathrm{polylog} n}


\newtheorem{exam}{Example}[section] \newtheorem{thm}{Theorem}[section]
\newtheorem{prop}{Proposition}[section]
\newtheorem{prob}{Problem}[section] \newtheorem{lemma}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{rem}{Remark}[section]
\newtheorem{fact}{Fact}[section]
\newtheorem{claim}{Claim}[section]
\newtheorem{con}{Conjecture}[section]
\newtheorem{alg}{Algorithm}[section]
\newtheorem{ex}{Exercise}[section]
\newtheorem{notn}{Notation}[section]
\newcommand{\proof}{\bf Proof: \rm}
\newcommand{\weeskip}{\vspace*{.3cm}}

\setlength{\textwidth}{6.7in}
\setlength{\evensidemargin}{-.1in}
\setlength{\oddsidemargin}{-.1in}
\setlength{\topmargin}{0in}
\setlength{\textheight}{8in}
\newcommand{\CG}{Chva\'tal-Gomory}
\newcommand{\uncon}{{\sc unifmincongest}}
\newcommand{\undemp}{{\sc unifmaxdemand}}
\newcommand{\conp}{{\sc mincongest}}
\newcommand{\maxconf}{{\sc max-conf}}
\newcommand{\maxufp}{{\sc max-ufp}}
\newcommand{\ufp}{{\sc ufp}}
\newcommand{\conf}{{\sc conf}}
\newcommand{\ssufp}{Single-Sink {\sc max-ufp}}
\newcommand{\ssconf}{Single-Sink {\sc max-conf}}
\newcommand{\ssanf}{Single-Sink {\sc anf}}
\newcommand{\ncap}{\mu}
\newcommand{\fn}{\footnotesize}
\newcommand{\qed}{}
\newcommand{\mod}[1]{{\mbox{\scriptsize (mod )}}}
\newcommand{\Kconf}{K_{conf}}
\newcommand{\bin}{5}
\newcommand{\Xij}{\Kconf \log^{\bin j + 5}(n)}
\newcommand{\medp}{{\sc MEDP}}
\newcommand{\congestionresults}[1]{}
\newcommand{\capp}[1]{c_{#1}}

\begin{document}
\bibliographystyle{plain}






\title{The Inapproximability of Maximum Single-Sink\\ Unsplittable, Priority and Confluent Flow Problems}
\author{F. Bruce Shepherd \and Adrian Vetta}

\maketitle


\begin{abstract}
We consider the  single-sink network flow problem.
An instance consists of a capacitated graph (directed or undirected),
a sink node  and a set of demands that we want to send to the
sink. Here demand  is located at a node  and
requests an amount  of flow capacity in order to route successfully.
Two standard objectives are to maximise
(i) the number of demands (cardinality) and (ii) the total demand (throughput)
that can be routed subject to the capacity constraints. Furthermore, we examine these maximisation
problems for three specialised types of network flow: unsplittable, confluent and priority flows.

In the {\em unsplittable flow} problem, we have edge capacities, and the demand for  must be
routed on a single path. In the {\em confluent flow} problem, we have node capacities, and the final
flow must induce a tree.
Both of these problems have been studied extensively, primarily in the
single-sink setting. However, most of this work imposed the {\em no-bottleneck assumption}
(that the maximum demand  is at most the minimum capacity ).
Given the no-bottleneck assumption, there is a factor -approximation algorithm due to Dinitz et al.~\cite{Dinitz99}
for the unsplittable flow problem. Under the even stronger assumption of uniform capacities,
there is a factor -approximation algorithm due to Chen et al.~\cite{Chen07} for the confluent flow problem.
However, unlike the unsplittable flow problem, a constant factor approximation algorithm cannot
be obtained for the single-sink confluent flow problem even {\bf with} the no-bottleneck assumption.
Specifically, we prove that it is hard in that setting to approximate single-sink confluent flow to
within , for any .
This result applies for both cardinality and throughput objectives even in undirected graphs.

The remainder of our results focus upon the setting {\bf without} the no-bottleneck assumption.
There, the only result we are aware of is an  inapproximability
result of Azar and Regev~\cite{azar2001strongly} for cardinality single-sink unsplittable flow in directed graphs.
We prove this lower bound applies to undirected graphs, including planar networks.
This is the first super-constant hardness known for undirected single-sink unsplittable flow,
and apparently the first polynomial hardness for undirected unsplittable flow even for general (non-single sink)
multiflows.
We show the lower bound also applies to the cardinality single-sink confluent flow
problem.

Furthermore, the proof of Azar and Regev requires exponentially large demands.
We show that polynomial hardness continues to hold without this restriction, even if all demands
and capacities lie within an arbitrarily small range , for . This lower bound applies
also to the throughput objective.
This result is very sharp since if ,  then we have an instance of the single-sink maximum
edge-disjoint paths problem which can be solved exactly via a maximum flow algorithm.
This motivates us to study an intermediary problem, {\em priority flows}, that models
the transition as . Here we have unit-demands, each with a priority level.
In addition, each edge has a priority level and a routing path for a
demand is then restricted to use edges with at least the same priority level.
Our results imply a polynomial lower bound for the maximum priority flow problem, even for
the case of uniform capacities.

Finally, we present greedy algorithms that provide upper bounds which (nearly) match
the lower bounds for unsplittable and priority flows. These upper bounds also apply for
general multiflows.
\end{abstract}






















\section{Introduction}
In this paper we improve known lower bounds (and upper bounds) on the approximability
of the maximization versions of the {\em single-sink unsplittable flow}, {\em single-sink priority flow}
and {\em single-sink confluent flow} problems.
In the single-sink network flow problem, we are given
a directed or undirected graph  with  nodes and  edges that has edge capacities  or
node capacities . There are a collection of demands
that have to be routed to a unique destination {\em sink} node .
Each demand  is located at a {\em source} node  (multiple demands could share the same source)
and requests an amount  of flow capacity in order to route.
We will primarily focus on the following two well-known versions of the single-sink network flow problem:
\begin{itemize}
\item {\tt Unsplittable Flow}: Each demand  must be sent along a unique path  from
 to .
\item {\tt Confluent Flow}: Any two demands that meet at a node must then traverse identical paths
to the sink.  In particular, at most one edge out of each node  is allowed to carry flow.
Consequently, the support of the flow is a tree in the
undirected graphs, and an arborescence rooted at  in directed graphs.
\end{itemize}
Confluent flows were introduced to study the effects of next-hop routing \cite{Chen05}.
In that application, routers are capacitated and, consequently, nodes
in the confluent flow problem are assumed to have capacities but not edges.
In contrast, in the unsplittable flow problem it is the edges that are assumed to
be capacitated. We follow these conventions in this paper.
In addition, we will also examine a third network flow problem called {\tt Priority Flow} (defined in Section \ref{sec:results}).
In the literature, subject to network capacities, there are two standard maximization objectives:



\begin{itemize}
\item {\tt Cardinality}: Maximize the total number of demands routed.
\item {\tt Throughput}: Maximize satisfied demand, that is, the total flow carried by the routed demands.
\end{itemize}
These objectives can be viewed as special cases of the
{\em profit-maximisation} flow problem. There each demand  has
a profit  in addition to its demand . The goal is to route a subset
of the demands of maximum total profit. The cardinality model then corresponds to the
unit-profit case,  for every demand ; the throughput model is the case .
Clearly the lower bounds we will present also apply to the more general
profit-maximisation problem.





\subsection{Previous Work}\label{sec:previous}
The unsplittable flow problem has been extensively studied since its
introduction by Cosares and Saniee \cite{cosares1994optimization} and Kleinberg~\cite{Kleinberg96}. However, most positive results
have relied upon the {\em no-bottleneck assumption} (\nba)
where the maximum demand is at most the minimum
capacity, that is, .
Given the no-bottleneck assumption, the best known result is a factor -approximation
algorithm due to Dinitz, Garg and Goemans \cite{Dinitz99} for the maximum throughput objective.






The confluent flow problem was first examined by Chen, Rajaraman and Sundaram~\cite{Chen05}.
There, and in variants of the problem \cite{Chen07, donovan2007degree, shepherd2009single},  the focus
was on  uncapacitated graphs.\footnote{An exception concerns the analysis of
graphs with constant treewidth \cite{dressler2010capacitated}.}
The current best result for maximum confluent flow is a factor -approximation
algorithm for maximum  throughput in uncapacitated networks \cite{Chen07}.

Observe that uncapacitated networks  (i.e. graphs with uniform capacities) trivially also satisfy
the no-bottleneck assumption. Much less is known about networks where the
no-bottleneck assumption does {\bf not} hold. This
is  reflected by the dearth of progress for the case of multiflows (that is, multiple sink)
without the \nba.
It is known that a constant factor approximation algorithm exists for the case in which
 is a path \cite{bonsma2011constant}, and that a poly-logarithmic approximation algorithm exists for the
case in which  is a tree \cite{chekuri2009unsplittable}.
The extreme difficulty of the unsplittable flow problem is suggested by the following
result of Azar and Regev~\cite{azar2001strongly}.
\begin{thm}[\cite{azar2001strongly}]\label{thm:ar}
If  then, for any , there is no -approximation algorithm for the cardinality objective
of the single-sink unsplittable flow problem in directed graphs.
\end{thm}
This is the first (and only) super-constant lower bound for the maximum single-sink unsplittable flow problem.








\subsection{Our Results}\label{sec:results}
The main focus of this paper is on single-sink flow problems where the no-bottleneck assumption
does not hold. It turns out that the hardness of approximation bounds are quite severe
even in the (often more tractable) single-sink setting.
In some cases they  match the worst case bounds for PIPs (general packing integer programs).
In particular, we strengthen Theorem~\ref{thm:ar} in four ways.
First, as noted by Azar and Regev, the proof of their result relies critically
on having directed graphs.
We prove it holds for undirected graphs, even {\em planar} undirected graphs.
Second, we show the result also applies to the confluent
flow problem.
\begin{thm}
\label{thm:extended}
If  then, for any , there is no -approximation algorithm
for the cardinality objective of the single-sink unsplittable and confluent flow problems in undirected graphs.
Moreover for unsplittable flows, the lower bound holds even when we restrict to planar inputs.
\end{thm}

Third, Theorems \ref{thm:ar} and \ref{thm:extended} rely
upon the use of exponentially large demands -- we call this the {\em large demand regime}. A second
demand scenario that has received attention in the literature is the {\em polynomial demand regime} -- this regime
is studied in \cite{guruswami2003near}, basically to the exclusion of the large demand regime.
We show that strong hardness results apply in the polynomial demand regime; in fact,
they apply to the {\em small demand regime} where the {\em demand spread}
 , for some ``small'' .
(Note that  and so the demand spread of an instance is at least
the {\em bottleneck value} .)
Fourth, by considering the case where  is arbitrarily small we obtain
similar hardness results for the throughput objective for the single-sink unsplittable
and confluent flow problems.
Formally, we show the following -inapproximability result. We
note however that the hard instances have a linear number of edges (so one may prefer to
call this an -inapproximability result).

\begin{thm}
\label{thm:hard} Neither cardinality nor throughput can be approximated to
within a factor of , for any
, in the single-sink unsplittable and confluent flow problems.
This holds for  undirected and directed graphs even
when instances are restricted to have demand spread
, where  is arbitrarily small.
\end{thm}
Again for the unsplittable flow problem this hardness result applies even in planar graphs.
Theorems \ref{thm:extended} and \ref{thm:hard} are the first super-constant hardness for any undirected
version of the single-sink unsplittable flow problem, and any directed version with small-demands.
We also remark that the extension to the small-demand regime is significant as suggested by the sharpness of the result.
Specifically, suppose  and, thus, the demand spread is one. We may then scale to assume that .
Furthermore, we may then round down all capacities to the nearest integer as any fractional capacity cannot be used.
But then the single-sink unsplittable flow problem can be solved easily in polynomial time by a max-flow algorithm!

To clarify what is happening in the change from  to , we introduce
and examine an intermediary problem, the {\em maximum priority flow problem}.
Here, we have a graph  with a sink node , and demands from nodes  to .
These demand are unit-demands, and thus . However, a demand may not traverse every edge.
Specifically, we have a partition of  into priority classes . Each demand also has a {\em priority}, and
a demand of priority  may only use edges of priority  or better (i.e., edges in ).
The goal is to find a maximum routable subset of the demands. Observe that, for this unit-demand problem, the
throughput and cardinality objectives are identical.
Whilst various priority network design problems have been considered in the literature (cf. \cite{charikar2004resource,chuzhoy2008approximability}),
we are not aware of existing results on maximum priority flow. Our results immediately imply the following.
\begin{cor}
\label{cor:priority}
The single-sink maximum priority flow problem
cannot be approximated to within a factor of , for any , in planar
directed or undirected graphs.
\end{cor}


The extension of the hardness results for single-sink unsplittable flow to undirected graphs is also significant since
it appears to have been left unnoticed even
for  general multiflow instances.
In \cite{guruswami2003near}: ``...{\em the hardness of undirected edge-disjoint paths remains an
interesting open question. Indeed, even the hardness of
edge-capacitated unsplittable flow remains open''}\footnote{In \cite{guruswami2003near}, they do however establish
an inapproximability bound of , for any ,
on {\em node-capacitated} {\sf USF} in undirected graphs.}  Our result resolves this question by showing
polynomial hardness (even for single-sink instances). We emphasize that this is not the first
super-constant hardness for general multiflows however.
  A polylogarithmic  lower bound appeared in \cite{andrews2006logarithmic} for the maximum
  edge-disjoint paths (MEDP) problem (this was subsequently extended to the regime where edge congestion is
  allowed \cite{andrews2010inapproximability}).
Moreover,  a polynomial lower bound for MEDP seems less likely given the recent -congestion polylog-approximation
algorithms \cite{chuzhoy2012routing,chuzhoy2012polylogarithimic}.
In this light, our hardness results for single-sink
unsplittable flow again highlight the sharp threshold involved with the no-bottleneck assumption.
That is, if we allow some slight
variation in demands and capacities within a tight range   we immediately jump from (likely)
polylogarithmic approximations for MEDP to  (known) polynomial hardness of the corresponding maximum
unsplittable flow instances.



We next note that Theorems \ref{thm:ar} and \ref{thm:extended} are stronger than Theorem \ref{thm:hard}
in the sense that they have exponents of  rather than . Again, this extra boost is due to their
use of exponential demand sizes. One can obtain
a more refined picture as to how the hardness of cardinality single-sink unsplittable/confluent flow varies with
 the demand sizes, or more precisely how it varies on the bottleneck
 value .\footnote{This seems likely connected to  a footnote in \cite{azar2001strongly}
 that a lower bound of the
 form  exists for maximum unsplittable flow in
 directed graphs. Its proof was omitted however.}
Specifically, combining the approaches used in Theorems \ref{thm:extended} and \ref{thm:hard} gives:
\begin{thm}
\label{thm:harder} Consider any fixed  and  .
It is NP-hard to approximate cardinality single-sink unsplittable/confluent flow
to within a factor of 
in undirected or directed graphs. For unsplittable flow, this remains true for planar graphs.
\end{thm}




Once again we see the message that there is a sharp cutoff for   even in the
large-demand regime. This is because
 if the bottleneck value is at most , then the
no-bottleneck assumption holds and, consequently, the single-sink unsplittable flow problem
admits a constant-factor approximation (not  hardness).
We mention that a similar hardness bound cannot hold   for the maximum throughput objective, since one can
always reduce to the case where  is small with a polylogarithmic loss, and hence the lower
bound becomes at worst . We feel the preceding hardness bound is all the more
interesting since known greedy techniques
yield almost-matching  upper bounds, even for general multiflows.
\begin{thm}
\label{thm:upper}
There is an  approximation algorithm
for cardinality unsplittable flow and an  approximation algorithm
for throughput unsplittable flow, in both directed and undirected graphs.
\end{thm}


We next present one hardness result for confluent flows assuming the no-bottleneck-assumption.
Again, recall that for the maximum single-sink unsplittable flow problem
there is a constant factor approximation algorithm given the no-bottleneck-assumption.
We prove this is not the case for the single-sink confluent flow problem by providing a super-constant lower bound.
Its proof is more complicated but builds on the techniques used for our previous results.
\begin{thm}\label{thm:hardnba}
Given the no-bottleneck assumption, the single-sink confluent flow problem
cannot be approximated to within a factor , for any , unless .
This holds for both the maximum cardinality and maximum throughput objectives
in undirected and directed graphs.
\end{thm}




Finally, we include a hardness result for the congestion minimization problem for confluent flows.
That is, the problem of finding the minimum value  such that all demands can be routed confluently if all node capacities are multiplied by .
This problem has two plausible variants.


An  {\em -congested}  routing is an unsplittable flow for the demands where the total load on any node is at most  times its associated capacity.
A {\em strong congestion} algorithm is one where  the resulting flow must route on a tree  such that for  any demand  the nodes on its path in  must have capacity at least . A  {\em weak congestion} algorithm does not require this extra constraint on the tree capacities.
 Both variants are of possible interest. If the motive for congestion is to route all demands in some limited number  of rounds of admission, then each round should be feasible on  - hence strong congestion is necessary.  On the other hand, if the objective is to simply augment network capacity so that all demands can be routed, weak congestion is the right notion.
In Section~\ref{sec:congestion} we show that it is hard to approximate strong congestion to within polynomial factors.
 \begin{thm}
 \label{thm:strongcongestion}
 It is NP-hard to approximate the minimum (strong) congestion problem for single-sink confluent flow instances
 (with polynomial-size demands) to factors of at most  for any .
 \end{thm}




\subsection{Overview of Paper}
At the heart of our reductions are gadgets based upon the {\em capacitated} -disjoint paths problem.
We discuss this problem in Section \ref{sec:two-disjoint-paths}.
In Section~\ref{sec:lower}, we prove the  hardness of maximum single-sink unsplittable/confluent
flow in the small demand regime (Theorem \ref{thm:hard}); we give a similar hardness for single-sink priority flow
(Corollary \ref{cor:priority}).
Using a similar basic construction, we prove, in Section~\ref{sec:confwithNBA}, the logarithmic hardness
of maximum single-sink confluent flow
even given the no-bottleneck assumption (Theorem \ref{thm:hardnba}).
In Section~\ref{sec:stronger}, we give lower bounds
on the approximability of the cardinality objective for general demand
regimes (Theorems \ref{thm:extended} and \ref{thm:harder}).
Finally, in Section~\ref{sec:upper}, we present an almost matching upper bound for unsplittable flow (Theorem \ref{thm:upper}).
and priority flow.


\section{The Two-Disjoint Paths Problem}\label{sec:two-disjoint-paths}

Our hardness reductions require gadgets based upon the {\em capacitated} -disjoint paths problem.
Before describing this problem, recall the classical -disjoint paths problem:\\

\noindent {\tt 2-Disjoint Paths (Uncapacitated):} Given a graph  and node pairs 
and . Does  contain paths  from  to 
and  from  to  such that  and  are disjoint?\\

Observe that this formulation incorporates four distinct problems
because the graph  may be directed or undirected and the desired paths
may be edge-disjoint or node-disjoint.
In undirected graphs the -disjoint paths problem, for both edge-disjoint and node disjoint paths,
can be solved in polynomial time
-- see  Robertson and Seymour~\cite{RS95}.
In directed graphs, perhaps surprisingly, the problem is NP-hard. This is the
case for both edge-disjoint and node disjoint paths, as shown
by  Fortune, Hopcroft and Wyllie~\cite{FHW80}.

In general, the unsplittable and confluent flow problems concern capacitated graphs.
Therefore, our focus is on the capacitated version of the -disjoint paths problem. \\


\noindent {\tt 2-Disjoint Paths (Capacitated):} Let  be a graph whose edges have
capacity either  or , where .
Given node pairs 
and , does  contain paths  from  to 
and  from  to  such that:\\
(i)  and  are disjoint.\\
(ii)  may only use edges of capacity . (
may use both capacity  and capacity  edges.) \\


For directed graphs, the result of Fortune et al.~\cite{FHW80} immediately implies that the capacitated version is
hard -- simply assume every edge has capacity . In undirected graphs, the case of node-disjoint paths
was proven to be hard by Guruswami et al.~\cite{guruswami2003near}. The case of edge-disjoint paths was recently
proven to be hard by Naves, Sonnerat and Vetta~\cite{naves2010maximum}, even in
planar graphs where terminals lie on the outside face (in an interleaved order, which will be important for us). These results are summarised in Table \ref{table:hardness}.
\begin{table}[h]
      \centering
          \begin{tabular}{|c|cc|}
          \hline
& Directed & Undirected \\
\hline
Node-Disjoint  &    NP-hard \cite{FHW80} & NP-hard \cite{guruswami2003near} \\
Edge-Disjoint  & NP-hard \cite{FHW80} & NP-hard  \cite{naves2010maximum} \\
\hline
   \end{tabular}
\caption{Hardness of the Capacitated 2-Disjoint Paths Problem}\label{table:hardness}
\end{table}

Recall that the unsplittable flow problem has capacities on edges, whereas
the confluent flow problem has capacities on nodes.
Consequently, our hardness reductions for
unsplittable flows  require gadgets based upon
the hardness for edge-disjoint paths \cite{naves2010maximum};
for confluent flows we  require gadgets based upon
the hardness for node-disjoint paths \cite{guruswami2003near}.







\section{Polynomial Hardness of Single-Sink Unsplittable,\\ Confluent and Priority Flow}
\label{sec:lower}


In this section, we establish that the single-sink maximum unsplittable and confluent flow problems
are hard to approximate within polynomial factors for both the cardinality and throughput objectives.
We will then show how these hardness results extend to the single-sink maximum priority flow problem.
We begin with the small demand regime by proving Theorem~\ref{thm:hard}.
Its proof introduces some core ideas that are used in later sections
in the proofs of Theorems \ref{thm:harder} and \ref{thm:hardnba}.






\subsection{-Hardness in the Small Demand Regime}
\label{sec:hardness}



Our approach uses a grid routing structure much as in the hardness proofs of Guruswami et al.~\cite{guruswami2003near}.
Specifically:

(1) We introduce a graph  that has the following properties.
There is a set of pairwise crossing paths that can route demands of total value,
.  On the other hand, any collection of pairwise non-crossing
paths can route at most  units of the total demand. For a given   we
choose  to be small enough so that .

(2) We then build a new network  by replacing each node of  by
an instance of the capacitated -disjoint paths problem. This routing problem is chosen
because it induces the following properties.  If it is a YES-instance, then a maximum unsplittable (or confluent) flow on
 corresponds to routing demands in  using pairwise-crossing paths. In contrast, if it is a
NO-instance, then a maximum unsplittable or confluent flow on   corresponds to routing
demands in  using pairwise non-crossing paths.

Since  contains  nodes, it follows that an approximation algorithm with guarantee better than
  allows us to distinguish between YES- and NO-instances of our
routing problem, giving an inapproximability lower bound of .
Furthermore, at all stages we  show how this reduction can be applied using
only undirected graphs.  This will prove Theorem \ref{thm:hard}.



\subsubsection{A Half-Grid Graph }

\begin{figure}[th]
\begin{center}
\includegraphics[height=12cm]{halfgrid.pdf}
\caption{\label{fig.grid} A Half-Grid .}
\end{center}
\end{figure}


Let's begin by defining the graph .  There are  rows (numbered from
top to bottom) and  columns (numbered from left to right). We call the leftmost node in the  row , and
the bottom node in the  column . There is a demand of size   located at .
Recall, that  is chosen so that all demands and capacities
lie within a tight range  for fixed  small. All the edges
in the  row and all the edges in the  column have capacity
.  The  row extends as far as the  column and vice
versa; thus, we obtain a ``half-grid" that is a weighted version of the
network considered by Guruswami et al. \cite{guruswami2003near}.  Finally we add a sink .
There is an edge of capacity  between  to . The
complete construction is shown in Figure~\ref{fig.grid}.

For the unsplittable flow problem we have edge capacities. We explain later how the node capacities
are incorporated for the confluent flow problem. We also argue about the undirected and directed reductions together.
For directed instances we always enforce  edge directions to be downwards
and to the right.


Note that there is a unique  path  consisting only of edges of
capacity , that is, the hooked path that goes from  along the
 row and then down the  column to . We call this the {\em canonical} path
for demand .

\begin{claim}\label{cl:cross}
Take two feasible paths  and  for demands  and .
If , then the paths must cross on row , between columns  and .
\end{claim}
\noindent{\bf Proof.}
Consider demand  originating at . This demand cannot
use any edge in columns  to  as it is too large.
Consequently, any feasible path  for demand  must include all of row .
Similarly,  must contain all of row . Row  cuts off  from the sink , so
 must meet  on row .
Demand  cannot use an edge in row  as demand  is already using up all the capacity along that row.
Thus  crosses  at the point they meet. As above, this meeting cannot occur
in columns  to . Thus the crossing point must occur on some column between  and 
(by construction of the half-grid, column  only goes as high as row  so the crossing cannot be there).
\qed


By Claim \ref{cl:cross}, if we are forced to route using pairwise non-crossing paths, then only one demand
can route. Thus we can route at most a total of  units of demand.

\subsubsection{The Instance }
We build a new instance  by replacing each degree  node in  with an instance
of the ~-~disjoint paths problem.
For the unsplittable flow problem in undirected graphs we use gadgets  corresponding to
the capacitated edge-disjoint paths problem. Observe that a
node at the intersection of column  and row  (with ) in  is incident to two edges of capacity
 and to two edges of weight .  We
construct   by replacing each such node of degree four with
the routing graph . We do this in such a way that the capacity 
edges of  are incident to  and , and the  
edges are incident to  and .
We also let  and .

For the confluent flow problem in undirected graphs we now have node capacities. Hence we use gadgets  corresponding to
the node-capacitated 2-paths problem discussed above.
Again  and  are given
capacity  whilst  and  have capacity .

For directed graphs, the mechanism is simpler as the gadgets may now come from the
uncapacitated disjoint paths problem. Thus the hardness comes from the directedness and not from the capacities.
Specifically, we may set the edge capacities to be . Moreover, for unsplittable flow we may
perform the standard operation of splitting each node in  into two, with
 the new induced arc having capacity of . It follows that if there are two flow paths through , each carrying at
 least  flow, then they must be from  to  and  to .
 These provide a solution to the node-disjoint directed paths problem in .















The hardness result will follow once we see how this construction relates to
crossing and non-crossing collections of paths.

\begin{lemma}\label{lem:yes}
If  is a YES-instance, then the maximum unsplittable/confluent flow in
 has value at least .  For a NO-instance the
maximum unsplittable/confluent flow has value at most .
\end{lemma}
\noindent{\bf Proof.}  If  is a YES-instance, then we can use its paths to produce
paths in , whose images in ,   are free to cross at any node.
Hence we can produce paths in  whose images are
the canonical paths  in .
This results in   a flow of value greater than
.  Note that  in the confluent case, these paths yield
 a confluent flow as they only  meet at the root .

Now suppose  is a NO-instance.
Take any flow and consider two paths  and  in  for demands  and , where .
These paths also induce two feasible paths  and  in the half-grid .
By Claim \ref{cl:cross}, these paths cross on row  of the half-grid (between columns  and ).
In the directed case (for unsplittable or confluent flow) if they cross at a grid-node , then the paths they induce in the copy of  at 
must be node-disjoint. This is not possible in the directed case since
such paths do not exist for  and .

In the undirected confluent case, we must also have node-disjoint paths through this copy of .
 As we are in row  and a column between column  and ,
we have  and . Thus, demand  can only use the -edges of .
This contradicts the fact that  is a NO-instance. For the undirected case of unsplittable flow the two
paths through  need to be edge-disjoint, but now we obtain a contradiction as
our gadget was derived from the
capacitated edge-disjoint paths problem.

It follows that no such pair  and  can exist and, therefore, the confluent/unsplittable flow routes at
most one demand and, hence, routes a total demand of at most .
\qed

We then obtain our hardness result. \\

{{\noindent\bf Theorem~\ref{thm:hard}.} \itshape
Neither cardinality nor throughput can be approximated to
within a factor of , for any
, in the single-sink unsplittable and confluent flow problems.
This holds for  undirected and directed graphs even
when instances are restricted to have bottleneck value
 where  is arbitrarily small.\\
}

\noindent{\bf Proof.} It follows that if we could
approximate the maximum (unsplittable) confluent flow problem in  to a
factor better than , we could determine whether the optimal solution is
at least  or at most . This in turn would allow us to determine whether  is a YES-
or a NO-instance.

Note that  has  edges, where . If we
take , where  is an (arbitrarily)
small constant, then  and so
.   A precise lower bound of  is obtained for
 sufficiently small, when  is sufficiently large.
\qed



\subsubsection{Priority Flows and Congestion}
\label{sec:congestion}

We now show the hardness of priority flows. To do this,
we use the same half-grid construction, except we must replace the
capacities by priorities. This is achieved in a straight-forward manner:
priorities are defined by the magnitude of the original demands/capacities.
The larger the demand or capacity in the original instance, the higher its priority in the
new instance. (Given the priority ordering we may then assume all demands and
capacities are set to .)
In this setting, observe that Claim~\ref{cl:cross} also applies for priority flows.
\begin{claim}
Consider  two feasible paths  and  for demands  and  in the priority flow problem.
If , then the paths must cross on row , between columns  and .
\end{claim}
\noindent{\bf Proof.}
Consider demand  originating at . This demand cannot
use any edge in columns  to  as they do not have high enough priority.
Consequently, any feasible path  for demand  must include all unit capacity edges  of row .
Similarly,  must contain all of row . Row  cuts off  from the sink , so
 must meet  on row .
Demand  cannot use an edge in row  as demand  is already using up all the capacity along that row.
Thus  crosses  at the point they meet. As above, this meeting cannot occur
in columns  to . Thus the crossing point must occur on some column between  and .
\qed

Repeating our previous arguments, we obtain the following hardness result for priority flows.
(Again, it applies to both throughput and cardinality objectives as they coincide for priority flows.)

{{\noindent\bf Corollary~\ref{cor:priority}.} \itshape
The maximum single-sink priority flow problem
cannot be approximated to within a factor of , for any , in planar
directed or undirected graphs. \qed
}

\vspace*{.2cm}
We close the section by establishing   Theorem~\ref{thm:strongcongestion}. Consider  grid instance  built from
 a YES instance of the 2 disjoint path problem. As before we may find a routing of all demands with  congestion at most .
Otherwise, suppose that the grid graph is built from  a NO instance and consider a tree  returned by a strong congestion algorithm.
As it is a strong algorithm, the demand in row  must follow its canonical path horizontally to the right as far as it can.
As it is a confluent flow, all demands from rows  must accumulate at this rightmost node in row .
Inductively this implies that the total load at the rightmost node in row 1 has load .
As before, for any  we may choose  sufficiently large so that . Hence
we have a YES instance of 2 disjoint paths if and only if the output from a -approximate strong congestion algorithm
returns a solution with congestion .



\section{Logarithmic Hardness of Single-Sink Confluent Flow with the No-Bottleneck Assumption}
\label{sec:confwithNBA}

We now prove the logarithmic hardness of the confluent flow problem given
the no-bottleneck assumption.
A similar two-step plan is used as for Theorem~\ref{thm:hard} but the analysis is
more involved.

(1) We introduce a planar graph  which has the same structure as our previous half-grid, except
that its edge weights are changed. As before we  have demands associated with the 's, but we assume these demands
are tiny -- this  guarantees that the no-bottleneck assumption holds.
We thus refer to the demands located at an  as the {\em  packets} from .
We define  to ensure that there is a
collection of pairwise crossing ``trees'' (to be defined) that can route
packets of total value equal to the harmonic number .
On the other hand, any collection of pairwise non-crossing trees can route at
most one unit of packet demand.


(2) We then build a new network  by replacing each node of  by
an instance of the -disjoint paths problem. Again, this routing problem is chosen
because it induces the following properties. If it is a YES-instance, then we can find a routing that
corresponds to pairwise crossing trees. Hence we are able to route  demand.
In contrast, if it is a NO-instance, then a maximum confluent flow on  is forced to route using a non-crossing
structure and this forces the total flow to be at most .


It follows that an approximation algorithm with guarantee better than
logarithmic would allow us to distinguish between YES- and NO-instances of our
routing problem, giving a lower bound of . We will see that
this bound is equal to .





\subsection{{An Updated Half-Grid Graph.}}\ \\
Again we take the graph  with  rows (now numbered from
 bottom to top) and  columns (now numbered from right to left).  All the edges
in the  row and all the edges in the  column have capacity
.  The  row extends as far as the  column and vice
versa; thus, we obtain a half-grid similar to our earlier construction but with updated  weights.
 Then we add a sink .
There is an edge of capacity  to  from the bottom node (called ) in column .
Finally, at the leftmost node (called ) in row  there is a collection of packets (``sub-demands'')
whose total weight is . These packets are very small. In particular,
they are much smaller than , so they satisfy the no-bottleneck assumption.
The complete construction is shown in Figure \ref{fig.grid2}.
In the directed setting, edges are oriented to the right and downwards.


\begin{figure}[h]
\begin{center}
\includegraphics[height=10cm]{halfgrid2.pdf}
\caption{\label{fig.grid2} An Updated \nba \ Half-Grid .}
\end{center}
\end{figure}

Again, there is a unique  path  consisting only of edges of
weight , that is, the hooked path that goes from  along the
th row and then down the  column to .
Moreover, for , the path  intersects  precisely once.
If we route packets along the paths
, then we obtain a  flow of total value .  Since every edge incident to  is used in
 with its maximum capacity, this solution is a maximum single-sink flow.
Clearly, each  is a tree, so this routing corresponds to our notion of routing on ``crossing trees''.

We then build  as before by replacing the degree four nodes in the grid by our
disjoint-paths gadgets. Our first objective is to analyze the maximum flow possible in the case
where our derived instance  is made from NO-instances. Consider a confluent flow in .
If we contract the pseudo-nodes, this results in some {\em leaf-to-root} paths in the subgraph .
We define  as the union of all such leaf-to-root paths terminating at .
If we have a NO-instance, then  the resulting collection   forms non-crossing subgraphs.
That is, if , then there do not exist leaf-to-root paths  and 
which cross in the standard embedding of .
Since we started with a confluent flow in , the flow paths within each  are {\em edge-confluent}.
That is, when two flow paths share an {\bf edge}, they must thereafter follow the same path to .
Note that they could meet and diverge at a node if they
use different incoming and outgoing edges.
In the following,
we identify the subgraph  with its edge-confluent flow.


The {\em capacity} of a  is the maximum flow from its leaves
to . The capacity of a collection  is then the sum of these capacities.
We first prove that the maximum value of a flow (i.e., capacity) is significantly reduced if we require a
non-crossing collection of edge-confluent flows.
One should note that as our demands are tiny, we may essentially route any partial
amount  from a node ;
we cannot argue as though we route the whole . On the other hand, any
packets from  must route on the same path, and in particular  lies in a unique   (or none at all).
Another subtlety in the proof is to handle the fact that we cannot apriori assume
that there is at most one leaf  in a .
 Hence such a flow does not just correspond to a maximum uncrossed unsplittable flow. In fact, because the packets are tiny,
 it is easy to verify that all the packets may  be routed unsplittably (not confluently) even if they are required to use non-crossing paths.





\begin{lemma}\label{lemma.maxflow}
The maximum capacity of a non-crossing edge-confluent flow  in  is at most .
\end{lemma}
\noindent{\bf Proof.}
Let  be the roots of the subgraphs  which support
the edge-confluent flow, where wlog . We argue inductively about the
topology of where these supports live in .
For  we define a subgrid  of  induced by columns and rows whose
indices lie in the range .
For instance, the rightmost column of  has capacity  and  the
leftmost column ; similarly, the lowest row of  has capacity  and  the
highest row .

Obviously all the 's route in  where we define .
Consider the topologically highest path  in ,
 and let  be the highest row number where this path intersects column .
We define  and  and consider the subgrid .
Observe that in the undirected case it is possible that  routes through the
subgrid ; see Figure \ref{fig:upperT}(b). In the directed case this cannot happen;
see Figure \ref{fig:upperT}(a).

\begin{figure}[h]\centering
    \subfloat[]{\includegraphics[width=8cm]{loggrid.pdf} }\qquad
    \subfloat[]{\includegraphics[width=8cm]{loggridB.pdf}}\caption{}\label{fig:upperT}\end{figure}

In addition, it is possible that  completely avoids routing through the subgrid .
But, for this to happen, it must have a cut-edge (containing all its flow) in column ;
consequently, its total flow is then at most . It is also possible that it has some flow which
avoids  and some that does not.
Since  also has maximum flow at most , it follows that in
every case the total flow is at most  plus the
maximum size of a confluent flow in the subproblem . Note that in this subproblem,
its ``first'' rooted subgraph may be at  or  depending on which of the two cases
above occurred for .


If we iterate this process, at a general step  we have a edge-confluent flow in the subgrid 
whose lower-left corner is in row  and column  (hence ). Note that these triangular grids
are in fact nested.
Let  be its subgraph rooted at a  with  maximized (that is, furthest to the left on bottom row).
As before, the total flow in this sub-instance is at most  plus
a maximum edge-confluent flow in some . Since each new sub-instance
has at least one less rooted flow,
this process ends after at most  steps.  Note that for  we have
 and for  we have .
The latter inequality follows since for each  we have .

Now by construction we have the grids are nested and so
(recall that columns are ordered increasingly from
right to left). Since , we may inductively deduce that
 for all . Thus  for all .
The total flow in our instance is then at most

The lemma follows.
\qed








We can now complete the proof of the approximation hardness. Observe that any
node of degree four in  is incident to two edges of weight
 and to two edges of weight , for some . Again, we
construct a graph  by replacing each node of degree four with
an instance  of the  node-disjoint paths problem,
where the weight 
edges of  are incident to  and , and the weight 
edges are incident to  and .
In the undirected case we require capacitated node-disjoint paths
and set  and .
More precisely, since we are dealing with node capacities in confluent flows,
we actually subdivide each edge of  and the new node
inherits the edge's capacity.
The nodes  and  also have capacity  whilst the nodes
 and  have capacity  in order to simulate the edge capacities of .




\begin{lemma}\label{lem:yes2}
If  is a YES-instance, then the maximum single-sink confluent flow in
 has value .  If  is a NO-instance, then the maximum
confluent flow in  has value at most .
\end{lemma}
\noindent{\bf Proof.}  It is clear that if  is a YES-instance, then the two feasible paths
in  can be used to allow paths in  to cross at any node
without restrictions on their values. This means we obtain a confluent flow of value
 by using the canonical paths .

Now  suppose that  is a NO-instance and
consider how a confluent
flow  routes packets through the gadgets.
As it is a NO-instance,
the image of the  trees (after contracting the 's to single nodes) in  yields a non-crossing edge-confluent flow.
The capacity of this collection in  is at least that in .
By Lemma~\ref{lemma.maxflow}, their capacity is at most , completing the proof.
\qed

\ \\
{{\noindent\bf Theorem~\ref{thm:hardnba}.} \itshape
Given the no-bottleneck assumption, the single-sink confluent flow problem
cannot be approximated to within a factor , for any , unless .
This holds for both the maximum cardinality and maximum throughput objectives
in undirected and directed graphs.\\
}

\noindent{\bf Proof.}  It follows that if we could
approximate the maximum confluent flow problem in  to a
factor better than , we could determine whether the optimal solution is
 or . This in turn would allow us to determine whether  is a YES-
or a NO-instance.

Note that  has  edges, where . If we
take , where  is a
small constant, then . For  sufficiently large,
this is .  This gives a
lower bound of .  \qed

Similarly, if we are restricted to consider only flows that decompose into 
disjoint trees then it is not hard to see that:
\begin{thm}
Given the no-bottleneck assumption, there is a  hardness of
approximation, unless , for the problem of finding a maximum confluent flow that
decomposes into at most  disjoint trees. \qed
\end{thm}








\section{Stronger Lower Bounds for Cardinality Single-Sink Unsplittable Flow with Arbitrary Demands}\label{sec:stronger}

In the large demand regime even stronger lower bounds can be achieved for the cardinality objective.
To see this, we explain the technique of Azar and Regev \cite{azar2001strongly} (used to prove Theorem~\ref{thm:ar})
in Section \ref{sec:expo-demands} and show how to extend it to undirected graphs and to confluent flows.
Then in Section \ref{sec:refine}, we combine their construction with the half-grid graph
to obtain lower bounds in terms of the bottleneck value (Theorem~\ref{thm:harder}).

\subsection{ Hardness in the Large-Demand Regime}\label{sec:expo-demands}



{{\noindent\bf Theorem~\ref{thm:extended}.} \itshape
If  then, for any , there is no -approximation algorithm
for the cardinality objective of the single-sink unsplittable/confluent flow problem in undirected graphs.\\
}

\noindent{\bf Proof.}
We begin by describing the construction of Azar and Regev for directed graphs.
They embed instances of the uncapacitated -disjoint paths problem into a directed path.
Formally, we start with a directed path   where
   forms our sink destination for all demands. In addition, for each , there are two parallel edges
 from  to . One of these has capacity  and the other has a smaller capacity of .
 There is a demand  from each ,  to  of size .
 Note that this unsplittable flow instance is feasible as follows. For each demand , we may follow the high capacity edge
 from  to  (using up all of its capacity) and then use low capacity edges on the
 path . Call these the {\em canonical paths} for the demands.
The total demand on the low capacity edge from  is then , as desired.

Now replace each node , , by an instance  of the uncapacitated directed -disjoint paths problem.
 Each edge in  is given capacity . Furthermore:\\
 (i) The tail of the high capacity edge out of  is identified with the node . \\
 (ii)  The tail of the low capacity edge out of  is identified with .\\
 (iii) The heads of both edges into  (if they exist) are identified with .\\
 (iv) The node  becomes the starting point of the demand  from . \\
This construction is shown in Figure \ref{fig:line}.

\begin{figure}[h]
\begin{center}
\includegraphics[width=16cm,height=11cm]{line.pdf}\\
\vspace{-6cm}
\caption{\label{fig:line} An Azar-Regev Path}
\end{center}
\end{figure}


Now if we have a YES-instance of the -disjoint paths problem,
we may then simulate the canonical paths in the standard way. The demand in  uses  the directed path
from  to  in ; it then follows the high capacity edge from  to the -node in the
 next instance . All the total demand arriving from upstream 's entered  at its node  and
 follows the directed path from  to . This total demand is at most  and thus fits into the low
 capacity edge from  into .
Observe that this routing is also confluent in our modified instance because the paths in the 's are node-disjoint.
 Hence, if we have a YES-instance
 of the -disjoint paths problem, both the unsplittable and confluent flow problems have a solution routing all of the demands.

 Now suppose that we have a NO-instance, and consider a solution to the unsplittable (or confluent) flow problem.
 Take the highest value  such that
 the demand from  is routed. By construction, this demand must use a path  from  to . But this
 saturates the high capacity edge from . Hence  any demand from ,  must pass from  to  while
 avoiding the edges of . This is impossible, and so we route at most one demand.

 This gives a gap of  for the cardinality objective. Azar-Regev then choose 
to obtain a hardness of .

Now consider undirected graphs. Here we use an
undirected instance of the capacitated -disjoint paths problem.
We plug this instance into each , and use the two capacity values of
 and .
A similar routing argument then gives the lower bound. \qed




We remark that it is easy to see why this approach does not succeed for the throughput objective.
The use of exponentially growing demands implies that high throughput is achieved simply
by routing the largest demand.


\subsection{Lower Bounds for Arbitrary Demands}\label{sec:refine}

By combining paths and half-grids we are able to refine the lower
bounds in terms of the bottleneck value (or demand spread).\\

{{\noindent\bf Theorem~\ref{thm:harder}.} \itshape
Consider any fixed  and  .
It is NP-hard to approximate cardinality single-sink unsplittable/confluent flow
to within a factor of 
in undirected or directed graphs. For unsplittable flow, this remains true for planar graphs.\\
}

\noindent{\bf Proof.}
We start with two parameters  and . We create  copies of
the Azar-Regev path
 and attach them to a  half-grid, as shown in Figure~\ref{fig:gridline}.

\begin{figure}[h]
\begin{center}
\includegraphics[width=16cm,height=11cm]{gridline.pdf}\\
\vspace{-2.5cm}
\caption{\label{fig:gridline}}
\end{center}
\end{figure}

 Now take the  Azar-Regev path, for each . The path
 contains  supply nodes with demands of sizes . (Supply node  has
 demand .) Therefore the total demand on path  is . The key point is that
{\em the total demand of path  is less than the smallest demand in path }.
Note that we have  demands, and thus demand sizes from  up to .
Consequently the demand spread is . We set  and thus


 It remains to prescribe capacities to the edges of the half-grid.
To do this every edge in th canonical hooked path has capacity  (not ). These capacity assignments,
in turn, induce corresponding capacities in each of the disjoint paths gadgets.
It follows that if the each gadget on the paths and half-grid correspond to a YES-instance gadget then we may
route all  demands.

Now suppose the gadgets correspond to a NO-instance. It follows that we may route at most one demand along each Azar-Regev path.
But, by our choice of demand values, any demand on the th path is too large to fit into any column  in the half-grid.
Hence we have the same conditions required in Theorem~\ref{thm:hard} to show that at most one demand in total can feasibly route.
It follows that we cannot approximate the cardinality objective to better than a factor .

Note that the construction contains at most  edges, where  is the size of the -disjoint paths instance.
Now we select  and  such that  and .
Then, for some constant , we have

Therefore, since we cannot approximate to within , we cannot
approximate the cardinality objective to better than a factor . \qed





























\section{Upper Bounds for Flows with Arbitrary Demands}\label{sec:upper}

In this section we present upper bounds for maximum flow problems with arbitrary demands.

\subsection{Unsplittable Flow with Arbitrary Demands}\label{sec:upper-unsplittable}

One natural approach for the cardinality unsplittable flow problem is used repeatedly in the
literature  (even for general multiflows). Group the demands
into at most  bins, and then consider
each bin separately. This approach can also be applied to the throughput objective (and to the
more general profit-maximisation model).
This immediately incurs a lost factor relating to the number of bins, and this
feels slightly artificial. In fact, given the no-bottleneck assumption regime, there is no need to lose this extra factor:
Baveja et al~\cite{baveja2000approximation} gave
an  approximation for profit-maximisation when .
On the other hand, our lower bound in Theorem~\ref{thm:harder} shows that if   we do need to
lose some factor dependent on . But how large does this need to be?
The current best upper bound is  by Guruswami et al.~\cite{guruswami2003near},
and this works for the general profit-maximisation model.\footnote{Actually, they state the bound as  because
exponential size demands are not considered in that paper.}
For the cardinality and throughput objectives, however, we can obtain a better upper bound.
The proof combines analyses from \cite{baveja2000approximation} and \cite{kolliopoulos2004approximating}
(which focus on the no-bottleneck assumption case). We emphasize that the following theorem
applies to all multiflow problems not just the single-sink case.\\





{{\noindent\bf Theorem~\ref{thm:upper}.} \itshape
There is an  approximation algorithm
for cardinality unsplittable flow and an  approximation algorithm
for throughput unsplittable flow, in both directed and undirected graphs. \\
}

\noindent{\bf Proof.}
We apply a result from \cite{guruswami2003near} which shows that for cardinality
unsplittable flow, with ,
the greedy algorithm yields a  approximation.  Their proof is a technical extension
of the greedy analysis of Kolliopoulos and Stein \cite{kolliopoulos2004approximating}.
We first find an approximation for the sub-instance consisting of the demands at most . This
satisfies the no-bottleneck assumption and an -approximation is known for general profits \cite{baveja2000approximation}.
Now, either this sub-instance gives half the optimal profits, or we focus on demands of at least .
In the remaining demands, by losing a  factor, we may assume , for some .
The greedy algorithm above then gives the desired guarantee for the cardinality problem.
The same approach applies for the throughput objective, since all demands within the same bin
have values within a constant factor of each other. Moreover, we require only  bins
as demands of  at most  may be discarded as they are not necessary for
obtaining high throughput.
\qed








\vspace*{.3cm}
As alluded to earlier, this  upper bound  is not completely satisfactory as pointed out in \cite{chekuri2003edge}. Namely,
all of the lower bound instances have a linear number of edges .
Therefore, it is possible that there exist upper bounds dependent on .
Indeed, for the special case of \medp \ in undirected graphs and directed acyclic graphs
-approximations have been developed  \cite{chekuri2006n,nguyen2007disjoint}.
Such an upper bound is
not known for general directed \medp \ however;
the current best approximation is .



\subsection{Priority Flow with Arbitrary Demands}\label{sec:upper-priority}
Next we show that the lower bound for the maximum priority flow problem is tight.
\begin{thm}
Consider an instance of the maximum priority flow problem with  priority classes.
There is a polytime algorithm that approximates the maximum flow to within a factor of .
\end{thm}
\begin{proof}
 First suppose that . Then for each class ,
we may find the optimal priority flow by solving a maximum flow problem in the subgraph induced by all edges of
priority  or better. This yields a -approximation.
Next consider the case where . Then we may apply Lemma \ref{lem:greedy-priority}, below,
which implies that the greedy algorithm yields
a -approximation. The theorem follows.
\qed
\end{proof}

 The following proof for uncapacitated networks follows ideas from the greedy analysis of Kleinberg \cite{Kleinberg96},
 and Kolliopoulos and Stein \cite{kolliopoulos2004approximating}. One may also design an -approximation
 for general edge capacities using more intricate ideas from \cite{guruswami2003near}; we omit the details.
\begin{lemma}\label{lem:greedy-priority}
A greedy algorithm yields a -approximation to the  maximum priority flow problem.
\end{lemma}
\begin{proof}
We now run the greedy algorithm as follows. On each iteration, we find the demand  which has a shortest feasible path
 in the residual graph. Let  be the associated path, and delete
its edges. Let the greedy solution have cardinality .
 Let  be the optimal maximum priority flow and
let  be those demands which are satisfied in some optimal
solution but not by the greedy algorithm.
We aim to upper bound the size of .

Let  be a path used in the optimal solution satisfying some demand in .
Consider any edge  and the greedy path using it.
 We say that 
{\em blocks} an optimal path  if  is the least index such
that  and  share a common edge .
Clearly such an  exists or else we could still route on .

Let  denote the length of  .
Let  denote the number of optimal paths  (corresponding to
demands in  ) that are blocked by . It follows that
. But, by the definition of the greedy algorithm,
we have that each such blocked path must have length at least 
 at the time when  was packed.
Hence it used up at least  units of capacity in the optimal solution.
Therefore the total capacity used by the unsatisfied demands from the
optimal solution is at least .
As the total capacity is at most  we obtain




\noindent
where the first inequality is by the Chebyshev Sum Inequality.
Since , we obtain
. One may verify that if  then this inequality implies
 and, so, routing a single demand yields the desired approximation.
\qed
\end{proof}



\section{Conclusion}
It would be interesting to improve the upper bound in Theorem~\ref{thm:upper} to be in terms of 
 rather than .
Resolving the discrepancy with Theorem~\ref{thm:harder}
between  and  would also
clarify the complete picture.

\ \\
\noindent{\bf Acknowledgments.}
The authors thank Guyslain Naves for his careful reading and precise and helpful comments.
The authors gratefully acknowledge support from the NSERC Discovery Grant Program. 

\bibliography{conf}

\end{document}
