\documentclass{llncs}
\pdfoutput=1

\usepackage{paralist,amsmath,amssymb,url,graphicx}

\newcommand{\cobasa}[0]{\textsf{CoBaSA}}
\newcommand{\inez}[0]{\textsf{Inez}}
\newcommand{\comment}[1]{}
\newcommand{\ie}[0]{\emph{i.e.}, }
\newcommand{\eg}[0]{\emph{e.g.}, }

\newcommand\none[0]{\ensuremath{\mathtt{None}}}
\newcommand\unsat[0]{\ensuremath{\mathtt{Unsat}}}

\newcommand{\tr}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\ttr}[1]{\ensuremath{T\text{-}\mathtt{#1}}}

\newcommand{\smtenc}[1]{\ensuremath{\mathtt{#1}}}

\newcommand{\state}[2]{\ensuremath{#1\ \|\ #2}}
\newcommand{\statenone}[1]{\state{#1}{\none}}
\newcommand{\subp}[2]{\ensuremath{\langle#1, #2\rangle}}

\newcommand{\boxstate}[2]{\makebox[100pt][l]{#1\ \|\ #2}}
\newcommand{\Z}[0]{\ensuremath{\mathcal{Z}}}
\newcommand{\ZT}[0]{\ensuremath{\mathcal{Z} \cup T}}
\newcommand{\SigmaZ}[0]{\ensuremath{\Sigma_{\mathcal{Z}}}}
\newcommand{\SigmaT}[0]{\ensuremath{\Sigma_{T}}}
\newcommand{\SigmaZT}[0]{\ensuremath{\SigmaZ{} \cup \Sigma}}
\newcommand{\modelsz}[0]{\ensuremath{ \models_{\Z} }}
\newcommand{\modelst}[0]{\ensuremath{ \models_{T} }}
\newcommand{\modelszt}[0]{\ensuremath{ \models_{\Z \cup T} }}

\newcommand{\set}[2]{\ensuremath{\{#1\ |\ #2\}}}
\newcommand{\setsp}[2]{\ensuremath{\{ \subp{#1}{#2} \}}}

\newcommand{\trans}[0]{\ensuremath{ \longrightarrow }}
\newcommand{\transplus}[0]{\ensuremath{ \longrightarrow^{+} }}
\newcommand{\transstar}[0]{\ensuremath{ \longrightarrow^{*} }}
\newcommand{\transannot}[1]{\underset{\tr{#1}}{\longrightarrow}}

\newcommand{\transd}[0]{\ensuremath{ \longrightarrow_D }}
\newcommand{\transdplus}[0]{\ensuremath{ \longrightarrow^{+}_D }}
\newcommand{\transdstar}[0]{\ensuremath{ \longrightarrow^{*}_D }}

\newcommand{\transi}[0]{\ensuremath{ \longrightarrow_I }}
\newcommand{\transiplus}[0]{\ensuremath{ \longrightarrow^{+}_I }}
\newcommand{\transistar}[0]{\ensuremath{ \longrightarrow^{*}_I }}
\newcommand{\transiannot}[1]{
  \ensuremath{ \underset{\tr{#1}}{\longrightarrow_I} }}
\newcommand{\transitannot}[1]{
  \ensuremath{ \underset{\ttr{#1}}{\longrightarrow_I} }}
\newcommand{\transiannotplus}[1]{
  \ensuremath{ \underset{\tr{#1}}{\longrightarrow^{+}_I} }}
\newcommand{\transiannotstar}[1]{
  \ensuremath{ \underset{\tr{#1}}{\longrightarrow^{*}_I} }}

\newcommand{\cd}{\subp{C}{D}}
\newcommand{\cdprime}{\subp{C'}{D'}}

\newcommand{\pa}{\state{P}{A}}
\newcommand{\paprime}{\state{P'}{A'}}

\newcommand{\bct}[0]{\ensuremath{\operatorname{BC}(T)}}
\newcommand{\bctplus}[0]{}

\newcommand{\dpllt}[0]{DPLL()}

\newcommand{\translate}[1]{\ensuremath{\llbracket #1 \rrbracket}}

\newtheorem{fact}{Fact}

\newcommand{\obj}[1]{\ensuremath{\operatorname{\mathsf{obj}}(#1)}}
\newcommand{\lb}[1]{\ensuremath{\operatorname{\mathsf{lb}}(#1)}}
\newcommand{\ub}[1]{\ensuremath{\operatorname{\mathsf{ub}}(#1)}}
\newcommand{\lpsolve}[1]{\ensuremath{\mathsf{lp\_solve}(#1)}}

\DeclareMathOperator{\aread}{\mathsf{read}}
\DeclareMathOperator{\awrite}{\mathsf{write}}

\DeclareMathOperator{\intf}{\mathsf{intf}}
\DeclareMathOperator{\intfz}{\mathsf{intf}_{\Z}}
\DeclareMathOperator{\intfsigma}{\mathsf{intf}_{\Sigma}}
\DeclareMathOperator{\maxc}{\mathsf{maxc}}
\DeclareMathOperator{\zatoms}{\mathsf{atoms_{\Z}}}
\DeclareMathOperator{\bounds}{\mathsf{bounds}}
\DeclareMathOperator{\zvars}{\mathsf{vars_{\Z}}}

\begin{document}

\author{Panagiotis Manolios and Vasilis Papavasileiou}

\institute{Northeastern University \\
  \email{\texttt{\{pete,vpap\}@ccs.neu.edu}}}

\title{ILP Modulo Theories}

\maketitle

\begin{abstract}
  We present Integer Linear Programming (ILP) Modulo Theories
  (IMT). An IMT instance is an Integer Linear Programming instance,
  where some symbols have interpretations in background theories.  In
  previous work, the IMT approach has been applied to industrial
  synthesis and design problems with real-time constraints arising in
  the development of the Boeing 787. Many other problems ranging from
  operations research to software verification routinely involve
  linear constraints and optimization. Thus, a general ILP Modulo
  Theories framework has the potential to be widely applicable.  The
  logical next step in the development of IMT and the main goal of
  this paper is to provide theoretical underpinnings.  This is
  accomplished by means of \bct{}, the Branch and Cut Modulo 
  abstract transition system. We show that \bct{} provides a sound and
  complete optimization procedure for the ILP Modulo  problem, as
  long as  is a decidable, stably-infinite theory. We compare a
  prototype of \bct{} against leading SMT solvers.
\end{abstract}






\section{Introduction}

The primary goal of this paper is to present the theoretical
underpinnings of the Integer Linear Programming (ILP) Modulo Theories
(IMT) framework for combining ILP with background theories. The
motivation for developing the IMT framework comes from our previous
work, where we used an ILP-based synthesis tool, \cobasa{}
(Component-Based System Assembly), to algorithmically synthesize
architectural models using the actual production design data and
constraints arising during the development of the Boeing 787
Dreamliner~\cite{hmp11}. According to Boeing engineers, previous
methods for creating architectural models required the
\emph{``cooperation of multiple teams of engineers working over long
  periods of time.''} We were able to synthesize architectures in
minutes, directly from the high-level requirements. What made this
possible was the combination of ILP with a custom decision procedure
for hard real-time constraints~\cite{hmp11}, \ie an instance of IMT.

ILP has been the subject of intensive research for more than five
decades~\cite{gomory63}. ILP solvers~\cite{cplex,scip} are routinely
used to solve practical optimization problems from a diverse set of
fields including operations research, industrial engineering,
artificial intelligence, economics, and software verification. Based
on our successful use of the IMT approach to solve architectural
synthesis problems and the widespread applicability of ILP and
optimization, we hypothesize that IMT has the potential to enable
interesting new applications, analogous to what is currently happening
with Satisfiability Modulo
Theories~\cite{barrett02,demoura02,dpllt,z3}.

We introduce the theoretical underpinnings of IMT via the \bct{}
framework (Branch and Cut Modulo ). \bct{} can be thought of as the
IMT counterpart to the \dpllt{} architecture for lazy
SMT~\cite{dpllt}. \bct{} models the branch-and-cut family of
algorithms for integer programming as an abstract transition system
and allows plugging in theory solvers. Building on classical results
on combining decision procedures~\cite{no79,noproof,combiningdp}, we
show that \bct{} provides a sound and complete optimization procedure
for the combination of ILP with stably-infinite theories. As a
side-product of our theoretical study of IMT, we show how to bound
variables while preserving optimality modulo the combination of Linear
Integer Arithmetic and a stably-infinite theory.

The rest of the paper is organized as follows. In
Section~\ref{sec:bct}, we formally define IMT and provide an abstract
\bct{} architecture for solving IMT problems. IMT can be seen as SMT
with a more expressive core than propositional logic.  We elaborate on
the relationship between IMT and SMT in Section~\ref{sec:smt}.  We
have implemented \bct{}, using the SCIP MIP solver~\cite{scip} as the
core solver. We carried out a sequence of experiments, as outlined in
Section~\ref{sec:experiments}. The first experiment shows that for our
synthesis problems, ILP solvers~\cite{cplex,scip} outperform the Z3
SMT solver~\cite{z3}.  In the second experiment, we compared our
prototype implementation with state-of-the-art SMT
solvers~\cite{z3,mathsatlia} on SMT-LIB benchmarks. An analysis of the
results suggests that \bct{} is an interesting future alternative to
the \dpllt{} architecture.  We provide an overview of related work in
Section~\ref{sec:related} and conclude with
Section~\ref{sec:conclusions}.

\section{\bct{}}
\label{sec:bct}

In this section, we formally define IMT. We also provide a general
\bct{} architecture for solving IMT problems. We describe \bct{} by
means of a \emph{transition system}, similar in spirit to
\dpllt{}~\cite{dpllt}. The \bct{} architecture allows one to obtain a
solver for ILP Modulo  by combining a branch-and-cut ILP solver
with a background solver for .

\subsection{Formal Preliminaries}
\label{sec:def}

\comment{We assume a fixed set of variable symbols .}

An \emph{integer linear expression} is a sum of the form  for integer constants  and variable symbols
. An \emph{integer linear constraint} is a constraint of the form
, where  is an integer linear expression,  is an
integer constant, and  is one of the relations , ,
, , and . An \emph{integer linear formula} is a set of
(implicitly conjoined) integer linear constraints. We will use
propositional connectives over integer linear constraints and formulas
as appropriate and omit  when this does not cause ambiguity
(\ie juxtaposition will denote conjunction). An \emph{integer linear
  programming (ILP) instance} is a pair , where  is an
integer linear formula, and the \emph{objective function}  is an
integer linear expression. Our goal will always be \emph{minimizing}
the objective function.

We assume a fixed set of variables . An \emph{integer
  assignment}  is a function ,
where  is the set of integers. We say that an assignment
 \emph{satisfies} the constraint  (where  is one of the relations , ,
, , , and every  is in ) if .  An assignment  satisfies a formula 
if it satisfies every constraint .  A formula  is
\emph{integer-satisfiable} or \emph{integer-consistent} if there is an
assignment  that satisfies . Otherwise, it is called
\emph{integer-unsatisfiable} or \emph{integer-inconsistent}.

A signature  consists of a set  of constant symbols,
a set  of function symbols, a set  of predicate
symbols, and a function  that assigns a non-zero natural number (the arity) to
every function and predicate symbol. A -formula is a
first-order logic formula constructed using the symbols in .
A -theory  is a closed set of -formulas (\ie 
contains no free variables). We will write theory in place of
-theory when  is clear from the context (similarly for
terms and formulas).

\begin{example}
  Let  be a signature that contains a binary
  function , a ternary function , no constants, and
  no predicate symbols. The theory  of arrays
  (without extensionality) is defined by the following
  formulas~\cite{mc62}:
  
\end{example}

A formula  is -satisfiable or -consistent if  is
satisfiable in the first-order sense (\ie there is an interpretation
that satisfies it). A formula  is called -unsatisfiable or
-inconsistent if it is not -satisfiable. For formulas  and
,  -entails  (in symbols ) if  is -inconsistent.

\begin{definition}
  Let \SigmaZ{} be a signature that contains the constant symbols    , a binary function symbol , a unary
  function symbol , and a binary predicate symbol . The
  theory of Linear Integer Arithmetic, which we will denote by ,
  is the \SigmaZ{}-theory defined by the set of closed
  \SigmaZ{}-formulas that are true in the standard model (an
  interpretation whose domain is , in which the symbols in
  \SigmaZ{} are interpreted according to their standard meaning over
  \Z{}).
\end{definition}

We will use relation symbols like  that do not appear in \SigmaZ{},
and also multiplication by a constant (which is to be interpreted as
repeated addition); these are only syntactic shorthands. We will
frequently view an integer assignment  as the set of formulas
, where  is viewed as a
\SigmaZ{}-term. An integer assignment  viewed as a set of formulas
is always -consistent. If  is an integer assignment and 
satisfies an integer linear formula , it is also the case that .  If  is an integer assignment,  is a theory and 
is a formula, we will say that  is a -model of  if  is
-consistent and . Note that a -model is not a
first-order model.

\comment{Whenever convenient, we will be viewing first-order models as
  integer assignments; this is possible, because for every first-order
  model  of \Z{} and for every variable symbol , there is a
  unique integer constant  such that .}

A \emph{-interface atom} is a -atomic formula (\ie the
application of a predicate symbol or equality), possibly annotated
with a variable symbol, \eg . The meaning of a
-interface atom with no annotation remains the same. An
annotated -interface atom  denotes . A set of -interface atoms will often
be used to denote their conjunction. \comment{We will assume that for
  every interface atom of the form  or  where ,
  , and  are variable symbols, at most one of  and 
  appears in integer linear constraints; the opposite would defy the
  purpose of interface atoms.}

\begin{definition}[ILP Modulo  Instance]
  An \emph{ILP Modulo (Theory)  instance}, where the signature
   of  is disjoint from \SigmaZ{}, is a triple of the form
  , where  is an integer linear formula,  is a set of
  -interface atoms, and  is an objective function. The
  variables that appear in both  and  are called interface
  variables.
  \label{def:imtinstance}
\end{definition}

An ILP Modulo  instance can be thought of as an integer linear
program that contains terms which have meaning in . In
Definition~\ref{def:imtinstance}, the interface atoms (elements of
) are separated from the linear constraints, \ie there are no
-terms embedded within integer linear constraints.  This is
not a restriction, because every set of -atomic formulas can be written in separate
form~\cite[``Variable Abstraction'']{combiningdp}.

\begin{example}
  Let  be a signature that contains the unary function symbol
  . The formula  (where  and  are
  variable symbols) can be written in separate form as  and .  is an integer linear formula;  is a
  set of -interface atoms; and  is disjoint from
  \SigmaZ{}. Variable abstraction introduced new variables, .  and  only share variable symbols.

  Let  be the assignment . Clearly . However, , where  stands for the \emph{theory
    of uninterpreted functions} (also called the empty theory, because
  it has an empty set of formulas). The reason is that  but
  . In contrast, the assignment  is a -model of
   per our definition, as it is -consistent and
  .
\label{ex:abstraction}
\end{example}

\subsection{Transition System}

\begin{definition}[Difference Constraint]
  A difference constraint is a constraint of the form  or
  , where  and  are integer variables and
   is an integer constant.
\end{definition}

\begin{definition}[Subproblem]
  A subproblem is a pair of the form \cd{}, where  is a set of
  constraints and  is a set of difference constraints.
\end{definition}

In a subproblem \cd{}, we distinguish between the arbitrary
constraints in  and the simpler constraints in  in order to
provide a good interface for the interaction between the core ILP
solver and background theory solvers that only understand difference
logic, \ie a limited fragment of . It is the responsibility of the
core solver to notify the theory solver about the difference
constraints that hold. Difference constraints are clearly a special
case of integer linear constraints.

\begin{definition}[State]
  A state of \bct{} is a tuple {\pa}, where  is a set of
  subproblems, and  is either the constant \none, or an assignment.
  If  is an assignment, it can optionally be annotated with the
  superscript .
\end{definition}

Our abstract framework maintains a list of open subproblems, because
it is designed to allow different branching strategies. This is in
contrast to an algorithm like CDCL that does not keep track of
subproblems explicitly. There, subproblems are implicit, \ie
backtracking can reconstruct them. ILP solvers branch over non-Boolean
variables in arbitrary ways, thus mandating that we explicitly record
subproblems.

In a state \pa{}, the assignment  is the best known
(-consistent) solution so far, if any. It has a superscript
 if it satisfies all the constraints, but is not optimal
because the IMT instance admits solutions with arbitrarily low
objective values. If this is the case, it is useful to provide an
assignment and to also report that no optimal assignment exists.

The interface atoms  and the objective function  are not part of
the \bct{} states because they do not change over time.  
denotes the value of the objective function  under assignment :
if , then . The
objective function itself is not an argument to
 because it will be clear from the
context which objective function we are referring to. For convenience,
we define  and . Function  returns a lower bound for the possible
values of the objective function  for the subproblem \cd{}: by
definition, there is no  such that  satisfies  and
.

Figure~\ref{fig:bct-trans} defines the \emph{transition relation}
 of \bct{} (a binary relation over states). In the
rules,  and  always denote integer linear constraints and
difference constraints.  (possibly subscripted) denotes an integer
linear formula (set of integer linear constraints), while  denotes
a set of difference constraints.  stands for the set union , under the implicit assumption that ;
similarly for .  and  are always well-formed sets, \ie
they contain no syntactically duplicate elements.  and  stand
for sets of syntactically distinct subproblems, while  and  are
integer assignments.   denotes the union , under
the implicit assumption that the two sets are disjoint. \comment{
  stands for a -formula, where  is
  the signature of .} The intuitive meaning of the different \bct{}
rules is the following:

\begin{figure}[t!]
  8pt]
    \tr{Learn}\ \ &
    \begin{aligned}
      & \state{P \uplus \{ \cd \}}{A} \trans
      \state{P \cup \{ \subp{C\ c}{D} \}}{A} \\
      & \text{if }
    \end{aligned} \8pt]
    \tr{Propagate}\ \ &
    \begin{aligned}
      & \state{P \uplus \{ \cd \}}{A} \trans
      \state{P \cup \{ \subp{C}{D\ d} \}}{A} \\
      & \text{if }
    \end{aligned} \8pt]
    \tr{Drop}\ \ &
    \begin{aligned}
      & \state{P \uplus \{ \cd \}}{A} \trans \pa \\
      & \text{if  is integer-inconsistent}
    \end{aligned} \8pt]
    \tr{Retire}\ \ &
    \begin{aligned}
      & \state{P \uplus \{ \cd \}}{A} \trans \state{P}{A'} \\
      & \text{if }
      \left\{
        \begin{array}{l}
          A' \text{ is a -model of } C \wedge D \wedge I \\
          \obj{A'} < \obj{A} \\
          \text{for any -model  of , } \\
\end{array}
      \right.
    \end{aligned} \
  \caption{The \bct{} Transition System}
  \label{fig:bct-trans}
\end{figure}

\begin{description}
\item[\tr{Branch}] \hfill \\
  Case-split on a subproblem \cd{}, by replacing it with two or more
  different subproblems . If there is a satisfying
  assignment for , this assignment will also satisfy  for some , and conversely.
\item[\tr{Learn}, \ttr{Learn}, \tr{Propagate}] \hfill \\
  Add an entailed constraint (in the case of \tr{Learn} and
  \ttr{Learn}) or difference constraint (\tr{Propagate}) to a
  subproblem. \ttr{Learn} takes the theory  into
  account. \ttr{Learn} is strictly more powerful than \tr{Learn}. We
  retain the latter as a way to denote transitions that do not involve
  theory reasoning.
\item[\tr{Forget}] \hfill \\
  Remove a constraint entailed by the remaining constraints of a
  subproblem.
\item[\tr{Drop}, \tr{Prune}] \hfill \\
  Eliminate a subproblem either because it is unsatisfiable
  (\tr{Drop}), or because it cannot lead to a solution better than the
  one already known.
\item[\tr{Retire}, \tr{Unbounded}] \hfill \\
  The solution to a subproblem becomes the new incumbent solution, as
  long as it improves upon the objective value of the previous
  solution. If there are solutions with arbitrarily low objective
  values, we don't need to consider other subproblems.
\end{description}

The observant reader will have noticed that the \ttr{Learn} rule is
very powerful, \ie it allows for combined \ZT{}-entailment. This is in
pursuit of generality. Our completeness strategy
(Theorem~\ref{thm:complete}) will not depend in any way on performing
combined arithmetic and theory reasoning, but only on extracting
equalities and disequalities from the difference
constraints. Entailment modulo \ZT{} is required if we want to learn
clauses, because they are represented as linear
constraints. Interesting implementations of \bct{} may go beyond
clauses and apply \ttr{Learn} for theory-specific cuts.

We define the binary relations  and  over
\bct{} states as follows:  if , or there
exists some state  such that  and .  if  or . When convenient, we
will annotate a transition arrow between two \bct{} states with the
name of the rule that relates them, for example .

A \emph{starting state} for \bct{} is a state of the form
, where  is the set of integer
linear constraints of an ILP Modulo  instance. A \emph{final state}
is a state of the form \state{\emptyset}{A} ( can also be \none{},
or an assignment annotated with ).

\subsection{Soundness and Completeness}
\label{subsec:soundness}

Throughout this Section, we assume an IMT instance with objective
function  and a set of interface atoms
. Theorems~\ref{thm:sound-sat} and~\ref{thm:sound-unsat}
characterize \bct{} soundness. Theorem~\ref{thm:complete} relies upon
classical results for combining decision
procedures~\cite{no79,noproof,combiningdp} and shows that~\bct{} can
be applied in a complete way.

\begin{lemma}
  \label{lemma:l1}
  For states \pa{} and \paprime{} such that , if
  there is an assignment  such that  is a -model of  for some , then one of the following
  conditions holds: either
  \begin{inparaenum}[(i)]
  \item\label{cond:l1:i} , or
  \item\label{cond:l1:ii}  is a -model of  for some .
  \end{inparaenum}
\end{lemma}
\begin{proof}
  Assume that there is a subproblem  and an assignment
   such that  is a -model of . If , then~(\ref{cond:l1:ii}) holds trivially. If , then
  the transition cannot possibly be \tr{Drop} (we cannot apply
  \tr{Drop} on {\cd} because  is an assignment that satisfies ). For the other rules:
  \begin{itemize}
  \item \tr{Branch}: There are subproblems , ,
     in  such that .  Thus,  is a -model of  for some  (). , therefore~(\ref{cond:l1:ii}) holds.
  \item \tr{Prune}: . Condition~(\ref{cond:l1:i}) holds.
  \item \tr{Retire}, \tr{Unbounded}: ,
    therefore~(\ref{cond:l1:i}) holds.
  \item \tr{Learn}, \tr{Forget}, \tr{Propagate}, \ttr{Learn}: there is
    a subproblem  such that , and therefore  is a -model of .
  \end{itemize}
\end{proof}

\begin{lemma}
  \label{lemma:assignlt}
  For states {\pa} and {\paprime} such that ,
  .
\end{lemma}
\begin{proof}
  The only rules that modify the assignment are \tr{Retire} and
  \tr{Unbounded}; the conditions under which we can apply them imply
  .  For any other rule, .
\end{proof}

\begin{lemma}
  \label{lemma:assigndiff}
  For states {\pa} and {\paprime} such that , if
   then  is a -model of  for
  some .
\end{lemma}
\begin{proof}
  The conditions of \tr{Retire} and \tr{Unbounded} guarantee that 
  is a -model of  for some . No
  other rule modifies the assignment.
\end{proof}

\begin{lemma}
  \label{lemma:l2}
  For states {\pa} and {\paprime} such that ,
  if there is an assignment  such that  is a -model of  for some , then one of the following
  conditions holds: , or  is a -model of
   for some .
\end{lemma}
\begin{proof}
  We induct on the length  of the sequence of transitions.

  \begin{itemize}
  \item Induction base: . ; obvious.
  \item Induction step: assume that the property holds for any
    sequence of  transitions, where . We will prove
    that it holds for any sequence of transitions .  Assume there is an assignment  such that
     is a -model of  for some
    . By the induction hypothesis, one of the
    two following conditions holds:
    \begin{itemize}
    \item : then  from
      Lemma~\ref{lemma:assignlt}.
    \item  is a -model of 
      for some subproblem :
      our proof obligation follows from Lemma~\ref{lemma:l1} applied
      to the transition .
    \end{itemize}
  \end{itemize}

\end{proof}

\begin{lemma}
  \label{lemma:entails}
  For states {\pa} and {\paprime} such that ,
  .
\end{lemma}
\begin{proof}
  We case-split on the \bct{} transitions.
  \begin{itemize}
  \item The rules \tr{Prune}, \tr{Drop}, and \tr{Retire} can only make
    the disjunction of the subproblems in  stronger, because a
    subproblem is eliminated and the rest of the subproblems remain
    intact.
  \item For \tr{Unbounded}, ; .
  \item The rules \tr{Learn}, \tr{Forget}, and \tr{Propagate} and
    substitute a subproblem for a -equivalent one.
  \item The rule \ttr{Learn} adds a constraint to a subproblem, and
    therefore makes the disjunction in  stronger.
  \item The rule \tr{Branch} replaces a subproblem \cd{} with a set of
    subproblems whose disjunction is -equivalent to .
  \end{itemize}
\end{proof}

\begin{lemma}
  \label{lemma:entailsstar}
  For states {\pa} and {\paprime} such that ,
  .
\end{lemma}
\begin{proof}
  Induction on the length of the sequence of transitions and
  application of Lemma~\ref{lemma:entails}.
\end{proof}

\begin{theorem}
  \label{thm:sound-sat}
  For a formula  and an assignment , if
  
  where , then
  \begin{inparaenum}[(a)]
  \item  is a -model of , and
  \item there is no assignment  such that  is a -model of  and .
  \end{inparaenum}
\end{theorem}
\begin{proof}
  \begin{enumerate}[(a)]

  \item The sequence of transitions from
    \statenone{\setsp{C}{\emptyset}} to \state{\emptyset}{A} has to be
    of the following form:
    
    
    
    There is at least one \tr{Retire} or \tr{Unbounded} step, as these
    are the only rules that can modify the assignment. Consider the
    last such step. The conditions on \tr{Retire} and \tr{Unbounded}
    steps require that  is a -model of . From Lemma~\ref{lemma:entailsstar},
    . Therefore, 
    is a -model of . \vspace{6pt}

  \item Follows from Lemma~\ref{lemma:l2}.
  
  \end{enumerate}
\end{proof}

\begin{theorem}
  \label{thm:sound-unsat}
  For a formula , if , then  is \ZT{}-unsatisfiable.
\end{theorem}
\begin{proof}
  Assume that there is an assignment  such that  is a -model
  of . Then, from Lemma~\ref{lemma:l2} either there exists
   such that  is a -model of  (which cannot possibly be true), or  (contradiction, because  has to
  be finite).
\end{proof}

\begin{definition}[Stably-Infinite Theory]
  A -theory  is called stably-infinite if for every
   -satisfiable quantifier-free -formula  there exists an
   interpretation satisfying  whose domain is infinite.
 \end{definition}

 \begin{definition}[Arrangement]
   Let  be an equivalence relation over a set of variables . The
   set
   
   is the arrangement of  induced by .
\end{definition}

Note that  is a stably-infinite theory. We build upon the
following result on the combination of signature-disjoint
stably-infinite theories:

\begin{fact}[Combination of Stably-Infinite
  Theories~\cite{no79,noproof,combiningdp}]
  Let  be a stably-infinite -theory, for ,
  and let . Also, let 
  be a conjunction of  literals.  is
  -satisfiable iff there exists an equivalence
  relation  of the variables shared by  and 
  such that  is -satisfiable, for .
  \label{thm:no}
\end{fact}

Decidability for the combination of  and another
stably-infinite theory follows trivially, as we can pick an
arrangement over the variables shared by the two sets of literals
non-deterministically and perform two -satisfiability checks.

\begin{theorem}[Completeness]
  \label{thm:complete}
  \bct{} provides a complete optimization procedure for the ILP Modulo
   problem, where  is a decidable stably-infinite theory.
\end{theorem}
\begin{proof}[Sketch]
  Let  be an ILP Modulo  instance. Assume that
  
  and that for every  the following conditions hold:
  \begin{inparaenum}[(a)]
  \item there is an equivalence relation  over the set of
    interface variables  of the ILP Modulo  instance, such that
    , and
  \item either  or  for every
     that appears as the annotation of an interface atom in .
  \end{inparaenum}
  Then we can solve the IMT instance to optimality as follows. For
  every subproblem , ~~ \ZT{}-entails
  the following set of literals:
  
  If the set of literals is -unsatisfiable, then  is \ZT{}-unsatisfiable. If it is -satisfiable, any integer
  solution for  will be a -model. For the
  -unsatisfiable subproblems, we apply \ttr{Learn} to learn an
  integer-infeasible constraint (\eg ) and subsequently apply
  \tr{Drop}. If all the subproblems are -unsatisfiable, we reach a
  final state \state{\emptyset}{A}. If there are -satisfiable
  subproblems, it suffices to let a (complete) branch-and-cut ILP
  algorithm run to optimality, as we have already established
  -consistency. The basic steps of such algorithms can be described
  by means of \bct{} steps. Note that unbounded objective functions do
  not hinder completeness: it suffices to recognize an unbounded
  subproblem~\cite{unboundedip} and apply \tr{Unbounded}.

  A systematic branching strategy can guarantee that after a finite
  number of steps, the difference constraints of every subproblem
  entail an arrangement. For every pair of interface variables  and
   and every subproblem, we apply the \tr{Branch} rule to obtain
  three new subproblems, each of which contains one of the constraints
  , , and . The \tr{Propagate} rule
  then applies to all three subproblems. Similarly, we branch to
  obtain a truth value for  for every  that appears as the
  annotation of an interface atom.
\end{proof}

\section{SMT as IMT}
\label{sec:smt}

In Section~\ref{sec:bct}, we provided a sound and complete
optimization procedure for the combination of ILP and a
stably-infinite theory (Theorems~\ref{thm:sound-unsat},
\ref{thm:sound-sat}, and \ref{thm:complete}). We will now demonstrate
how to deal with propositional structure, so that we can use this
procedure for SAT Modulo \ZT{} problems, where  is stably-infinite.
In essence, our goal is to flatten propositional structure into linear
constraints.

\subsection{Bounding \ZT{} Instances}

As a prerequisite for dealing with propositional structure, we show
how to bound integer terms in quantifier-free formulas while
preserving \ZT{}-satisfiability.  We build upon well-known results for
ILP~\cite{combopt}. Similar ideas have been applied
to~\Z{}~\cite{lauclid}. Our results go beyond the bounds for~\Z{}, in
that we take into account background theories and objective functions.

Our starting point is known bounds for ILP instances of the form

where , , and  are matrices of integers (, , and  respectively), and  is an
-vector of integer variables.

\begin{fact}[{\cite[Corollary of Theorem 13.5]{combopt}}]
  \label{lemma:pap}
  If an ILP instance of the form~(\ref{eq:ilpformorig}) has a finite
  optimum, then it has an optimal solution  such that  for , where .
\end{fact}

In what follows, it will be more convenient to work with the following
form:

where , , ,  and  are matrices of integers (, , ,  and 
respectively), and  is an -vector of integer variables.

\begin{lemma}
  If an ILP instance I of the form~(\ref{eq:ilpform}) has a finite
  optimum, then it has an optimal solution  such that
   for , where .
  \label{lemma:ilpbounds}
\end{lemma}

\begin{proof}
  We reduce  to an equisatisfiable instance over a vector
   of  variables constrained to be non-negative
  (). We achieve this by replacing each variable
   with . In the resulting matrices , 
  and ,  appears with the same coefficients as ;  appears with the coefficients multiplied by . The
  resulting ILP instance  has  constraints and 
  variables. We replace inequalities with equalities by introducing
   slack variables and obtain an equisatisfiable instance 
  over a vector  of  variables (the last  of
  which are the slack variables) and  constraints.

  The chain of transformations preserves the maximum absolute
  coefficients. We can translate solutions of  to solutions of
   and vice versa via the equalities ,
  for ; an optimal assignment in either side
  corresponds to an optimum in the other.   has a finite optimum
  because  does. By Lemma~\ref{lemma:pap},  has an optimal
  solution  such that . For the corresponding solution  to ,
  we have , which concludes our proof.
\end{proof}

We will say that a term is -rooted if (at its root) it is an
application of a function symbol from the signature . Let
 and  be signatures such that . Given a -formula ,
we will refer to the -rooted terms that appear directly
under predicate and function symbols from  as the
-interface terms in . Interface terms are the ones for
which variable abstraction (Example~\ref{ex:abstraction}) introduces
fresh variables.

Let  be a signature such that , and  be a quantifier-free -formula. We
denote by  and  the sets of
-interface terms and -interface terms in , and by
 the union . Let 
be the set of atomic formulas in  that are applications of ;
without loss of generality, we will assume that formulas contain no
arithmetic equalities or other kinds of inequalities. Also, let
 be the maximum absolute value among integer coefficients in
 plus one, and  be the set of variable symbols that
appear directly under predicate and function symbols from
\SigmaZ{}. By  we denote the interpretation of linear expression
 under the first-order model . We finally define , for positive integers .

\begin{lemma}
  \label{lemma:ztbounds}
  Let  be a signature such that , and  be a stably-infinite -theory.
  Furthermore, let  be a finite set of \SigmaZT{} literals, and 
  an objective function. Let
  
  If there is a first-order model  such that  and  is a finite optimum for  with respect to
   (\ie there is some integer constant  such that  and there is no model  such that  and ), then  is \ZT{}-satisfiable.
\end{lemma}

\begin{proof}
  We perform variable abstraction on  (as demonstrated by
  Example~\ref{ex:abstraction}) and obtain a set of \SigmaZ{} literals
   and a set of  literals .  Let  be the set of
  variables shared by  and  (). Let  be the equivalence relation on  induced by
  . Clearly,  is \Z{}-satisfiable and  is -satisfiable.   contains 
  equalities,  possibly negated inequalities, and
   variables. We eliminate any negations in
   by rewriting  to  and obtain
  a set of inequalities .

  We order the variables  so that  is before  if . (This is slight abuse of notation;  in fact models an
  inequality between the corresponding terms in .) We obtain a
  sequence of variables , . Let
  

  Minimizing  subject to  is an ILP
  instance  of the form~(\ref{eq:ilpform}). The maximum absolute
  value among coefficients in the matrices representing  is
  . Lemma~\ref{lemma:ilpbounds} applies to . In the worst
  case,  is empty and ,
  \ie we have  equalities and  inequalities. Thus, 
  has an optimal assignment  such that for every variable ,
  . Therefore,  is \Z{}-satisfiable. Since
  , , and
  ,  is \Z{}-satisfiable. Because it is
  also the case that  is -satisfiable, it
  follows from Theorem~\ref{thm:no} that  is \ZT{}-satisfiable. Thus,  is \ZT{}-satisfiable.
\end{proof}

\begin{theorem}
  \label{thm:ztbounds}
  Let  be a signature such that  and  be a stably-infinite -theory. Let  be
  a quantifier-free -formula and  an objective
  function. Let , , and . Finally, let
  
  If there is a first-order model  such that  and  is a finite optimum for  with respect to
   (\ie there is some integer constant  such that  and there is no model  such that  and ), then  is \ZT{}-satisfiable.
\end{theorem}
\begin{proof}
   satisfies some literals in , and falsifies the rest. Let 
  be the set . 
  is a finite optimum for  with respect to : if it was not, it
  would not be a finite optimum for  which contradicts our
  assumptions. For any first-order model  such that , it will also be the case that  (because  and  assign the same truth
  values to the literals that appear in , and the propositional
  structure does not change). By Lemma~\ref{lemma:ztbounds},  is \ZT{}-satisfiable, \ie there is
  some model  that satisfies it (and also satisfies \ZT{}). 
  also satisfies , which
  concludes our proof.
\end{proof}

Intuitively, given a quantifier-free \SigmaZT{}-formula  and an
objective function , Theorem~\ref{thm:ztbounds} allows us to bound
the integer terms of  while preserving (finite)
optimality.~\footnote{A solver that relies on
  Theorem~\ref{thm:ztbounds} for bounding can detect unboundedness by
  imposing the additional constraint , re-computing bounds,
  and solving the resulting instance. If the updated instance is
  satisfiable, the original is unbounded.}

\subsection{Propositional Structure}
\label{sec:smt:prop}

Let  be a signature such that  and  be a stably-infinite -theory. Throughout
this Section,  will be a quantifier-free -formula and 
will be an objective function. We show how to encode  as the
conjunction of a set  of integer linear constraints and a set 
of -interface atoms, while preserving optimality with respect
to . We apply a Tseitin-like algorithm, \ie we recursively
introduce -constrained variables for subformulas of .

The most interesting part is dealing with predicate symbols from
 and \SigmaZ{}. For the former we simply introduce annotated
-interface atoms, \eg . For , we can assume
that we are only confronted with inequalities of the form , because other relations can be
expressed in terms of  and the propositional connectives. Also,
we only have to deal with sums over variable symbols, because variable
abstraction takes care of terms that involve . We define a
variable  such that  as
follows. By bounding all variables as per Theorem~\ref{thm:ztbounds},
we compute  and  such that 
always holds.  The direction  can be
expressed as ; for the opposite direction we have .

With atomic formulas taken care of, what remains is propositional
connectives; we encode them by using clauses in the standard
fashion. Clauses appear as part of our collection of ILP constraints:
 is equivalent to . (For translating a
clause to a linear expression, a negative literal  appears
as  while a positive literal remains intact.)

Note that the (possibly astronomical) coefficients we compute only
serve the purpose of representing formulas as sets of linear
constraints. Their magnitude does not necessarily have algorithmic
side-effects. In the worst case, the initial continuous relaxation
will be weak, but relaxations will become stronger once we start
branching on the Boolean variables. This is no worse than Lazy SMT,
where linear constraints are only applicable once the SAT core assigns
the corresponding Boolean variables.

\comment{Modern ILP solvers provide an alternative called
  \emph{indicator constraints}~\footnote{\url{http://j.mp/NdkZZl}
    (CPLEX); \url{http://j.mp/NdlmDs} (SCIP)}, \ie natively supported
  constraints of the form , where  is a  variable. \bct{} does not
  explicitly provide indicator constraints, in order to stay within
  the standard formulation of ILP. }

\section{Implementation and Experiments}
\label{sec:experiments}

IMT first appeared in the context of architectural synthesis for
aerospace systems~\cite{hmp11}. Our approach combined an ILP solver
with a custom decision procedure for real-time constraints. We
implemented the combination in the \cobasa{} tool. The \cobasa{}
manifestation of IMT predates \bct{}. More recently, we implemented a
\bct{}-based solver, which we call \inez{}.

Our experimental evaluation is twofold. First, we show that an ILP
core is essential for the practicality of our synthesis approach. This
part of the evaluation does not deal with \bct{} in any way, but it
nevertheless provides evidence that IMT enables new
applications. Second, we compare our \bct{} prototype against
Z3~\cite{z3} and MathSAT~\cite{mathsatlia} using benchmarks from the
SMT-LIB.

\subsection{Motivation}

\begin{figure}[t]
\includegraphics[trim=0 14pt 0 18pt]{z3_vs_scip.pdf}
\includegraphics[trim=0 14pt 0 18pt]{z3_vs_cplex.pdf}
\caption{Z3 versus SCIP and CPLEX (Synthesis Instances)}
\label{fig:synthesis}
\end{figure}

In the past, we applied \cobasa{} to solve the architectural synthesis
problem for the real, production data from the 787, which was provided
to us by Boeing~\cite{hmp11}. We have made available a family of 60
benchmark instances derived from Boeing problems, 47 of which are
unsatisfiable.~\footnote{\url{http://www.ccs.neu.edu/home/vpap/benchmarks.html}}
We will use these instances to evaluate the suitability of SMT and ILP
solvers as the core of a combination framework for synthesis, which is
a key application area for IMT.

We briefly describe the synthesis problem that gives rise to our
benchmarks. The basic components for this problem are cabinets
(providing resources like CPU time, bandwidth, battery backup,
and memory), software applications (that consume resources), and
global memory spaces (that also consume resources). Applications
and memories have to be mapped to cabinets subject to various
constraints, \eg resource allocation and fault
tolerance. Applications communicate via a publish-subscribe
network. Messages are aggregated into virtual links that are
multicast. The network and messages are subject to various
constraints, \eg bandwidth and scheduling constraints.  The
instances differ in the numbers of different components, the
amounts of different resources, and the collection of structural
and scheduling requirements they encode.

The instances are -ILP (also known as Pseudo-Boolean). There
are multiple ways to encode -ILP problems as SMT-LIB
instances. A direct translation led to SMT problems that Z3 could not
solve, so we tried several encodings, most of which yielded similar
results. One encoding was significantly better than the rest, and it
works as follows. Some of the linear constraints are clauses, \ie of
the form  for literals . It makes sense to help
SMT solvers by encoding such constraints as disjunctions of literals
instead of inequalities. To do this, we declare all variables to be
Boolean. Since almost all variables also appear in arithmetic contexts
where they are multiplied by constants greater than 1, we translate
such constraints as demonstrated by the following example: the linear
constraint  becomes \texttt{(>= (+ (ite x 1 0)
  (ite y 1 0) (ite z 2 0)) 2)}.



Figure~\ref{fig:synthesis} visualizes the behavior of Z3 versus SCIP
and CPLEX. SCIP solves all instances, while CPLEX solves all but 3. Z3
solves 5 out of 13 satisfiable and 30 out of 47 unsatisfiable
instances. Strictly speaking, the only theory involved is
\Z{}. However, the instances do contain collections of scheduling
theory lemmas~\cite{hmp11} recorded by \cobasa{} in the process of
solving synthesis problems.  Therefore, our setup simulates the kinds
of queries a core solver would be confronted with, when coupled with
our scheduling solver. With suitability for synthesis as the
evaluation criterion, this is the most rigorous comparison we can
perform without implementing and optimizing the combination of SMT
with scheduling. Both ILP solvers significantly outperform Z3,
demonstrating the potential of a general ILP-based combination
framework.

\comment{Recall that with the direct encoding of the ILP problems, Z3
  failed to solve any of the instances above. It was only after we
  experimented with several encodings that we found an encoding that
  allowed Z3 to solve some of the problems. The ILP solvers did not
  require special encodings.}

\subsection{\bct{} Implementation}
\label{ssec:implementation}

\inez{} is implemented as an unobtrusive extension of SCIP.  Namely,
we have extended SCIP with a congruence closure procedure
(\emph{constraint handler} in SCIP terms), and also provide an SMT-LIB
frontend. The overall architecture of SCIP matches \bct{}. Subproblems
(called \emph{nodes}) are created by branching (\tr{Branch}) and
eliminated by operations semantically very similar to \tr{Drop},
\tr{Prune}, \tr{Retire}, and \tr{Unbounded}. SCIP employs various
techniques for cut generation (\tr{Learn}).

Like most modern MIP solvers, SCIP relies heavily on linear
relaxations. While not explicitly mentioned in \bct{}, linear
relaxations fit nicely:
\begin{inparaenum}[(a)]
\item  relies on continuous relaxations,
  as the best integral solution can be at most as good as the best
  non-integral solution.
\item Solutions to relaxations frequently guide branching, \eg if a
  solution assigns a non-integer value  to variable , it makes
  sense to branch around  ( or ).
\item If some relaxation is infeasible, then the corresponding
  subproblem is infeasible and \tr{Drop} applies, while
\item \tr{Retire} or \tr{Unbounded} applies to -consistent integer
  solutions.
\end{inparaenum}

\bct{} proposes difference constraints as a channel of communication
with theory solvers (\tr{Propagate} rule). \inez{} implements
\tr{Propagate} as follows. For every pair of variables  and 
whose (dis)equality is of interest to the theory solver, \inez{}
introduces a variable  and imposes the constraint . When SCIP fixes the lower bound of  to , the
theory solver is notified of the difference constraint 
(similarly for the upper bound). We generally need quadratically many
such auxiliary variables. This is not necessarily a practical issue,
because most pairs of variables are irrelevant.

Our congruence closure procedure takes offsets into
account~\cite{ccoffsets}. In addition to standard propagation based on
congruence closure, \inez{} applies techniques specific to the integer
domain. Notably, if  is bounded between  and , and for every
value of  in ,  is bounded between  and , it
follows that , \ie we can impose bounds on
.  and  do not have to be constants, \eg it may be the
case that  and  are bounded. We apply this idea dynamically (to benefit from local
bounds) and not just as preprocessing.

\bct{} does not preclude techniques that target special classes of
linear constraints. For example, an implementation can use the
two-watched-literal scheme to accelerate Boolean Constraint
Propagation on clauses.  SCIP implements such techniques. Note that
IMT does not strive to replace propositional reasoning, but rather to
shift a broader class of constraints to the core solver.

\comment{SCIP performs floating-point arithmetic, and can thus provide
  wrong answers. \inez{} inherits this deficiency. For many applications,
  numerical inaccuracies are not a concern, \eg the noise in the model
  overshadows the floating point error intervals. \comment{or an
    answer close enough to the theoretical optimal suffices.}
  Floating-point arithmetic for linear programming is a well-studied
  trade-off. \bct{} can be laid out on top of an exact solver, if the
  application domain dictates accuracy.}

\subsection{\bct{} on SMT-LIB}

\begin{figure}[t]
\includegraphics[trim=0 14pt 0 18pt]{mathsat_vs_simt.pdf}
\includegraphics[trim=0 14pt 0 18pt]{z3_vs_simt.pdf}
\caption{\inez{} versus Z3 and MathSAT (SMT-LIB Instances)}
\label{fig:smtlib}
\end{figure}

We experimentally evaluate \inez{} against MathSAT and Z3, based on
the most relevant SMT-LIB category, which is \texttt{QF\_UFLIA}
(Quantifier-Free Linear Integer Arithmetic with Uninterpreted
Functions). Z3 and MathSAT solve all 562 benchmarks, and so does
\inez{}. While \inez{} is generally slower than the more mature SMT
solvers, the majority of the benchmarks (338) require less than a
second, 462 benchmarks require less than 10 seconds, and 528 less than
100 seconds. The integer-specific kind of propagation outlined in
Section~\ref{ssec:implementation} is crucial; we only solve 490
instances with this technique disabled.  Figure~\ref{fig:smtlib}
visualizes our experiments.

Interestingly, the underlying SCIP solver learns no cutting planes
whatsoever for 362 out of the 562 instances. For the remaining
instances the number of cuts is limited. Namely, 126 instances lead to
a single cut, 61 lead to 2 cuts, and the remaining 13 instances lead
to 9 cuts or less. Based on this observation, the branching part of
\inez{}'s branch-and-cut algorithm is being stressed here. We have
not yet tried to optimize branching heuristics, so there is plenty of
room for improvement. More importantly, the instances are not
representative of arithmetic-heavy optimization problems, where we
would expect more cuts.

A final observation is that SCIP performs floating-point (FP)
arithmetic, which may lead to wrong answers. Interestingly, \inez{}
provides no wrong answers for the benchmark set in question, \ie the
instances do not pose numerical difficulties. The fact that we learn
very few cutting planes partially explains why. There is little room
for learning anything at all, let alone for learning something
unsound.

\section{Related Work}
\label{sec:related}

\paragraph{Branch-and-Cut:} 
Branch-and-cut algorithms~\cite{branchandcut-handbook} combine
branch-and-bound with cutting plane techniques, \ie adding violated
inequalities (cuts) to the linear formulation. Different cut
generation methods have been studied for general integer programming
problems, starting with the seminal work of
Gomory~\cite{gomory63}. Cuts can also be generated in a
problem-specific way, \eg for TSP~\cite{gh91}. Problem-specific cuts
are analogous to theory lemmas in IMT.

\paragraph{Nelson-Oppen:} 
The seminal work of Nelson and Oppen~\cite{no79} provided the
foundations for combining decision procedures. Tinelli and
Harandi~\cite{noproof} revisit the Nelson-Oppen method and propose a
non-deterministic variant for non-convex stably-infinite
theories. Manna and Zarba provide a detailed survey of Nelson-Oppen
and related methods~\cite{combiningdp}.\comment{On a fundamental
  level, IMT combines  and a theory , so this line of results
  directly applies to our framework.}

\paragraph{SMT:}
ILP Modulo Theories resembles Satisfiability Modulo Theories, with ILP
as the core formalism instead of SAT.  SMT has been the subject of
active research over the last
decade~\cite{barrett02,demoura02,dpllt,z3}. Nieuwenhuis, Oliveras and
Tinelli~\cite{dpllt} present the abstract \dpllt{} framework for
reasoning about lazy SMT. Different fragments of Linear Arithmetic
have been studied as background theories for
SMT~\cite{ladpllt,mathsatlia}. Extensions of SMT support
optimization~\cite{smtopt,smtcosts,laqcost}.

\comment{
  \paragraph{Decomposition:} Another family of linear programming
  techniques that bears resemblance to IMT is Benders
  decomposition~\cite{benders62}. The linear programming problem is
  split into a master problem (which has only a subset of the original
  variables) and a subproblem. The master problem is solved first, and
  then the subproblem is solved with the values of the master problem
  fixed (``trial'' values). If the ``trial'' values are unacceptable,
  a cut is derived and added to the master problem. Logic-based
  Benders Decomposition~\cite{logicbenders} generalizes the strategy
  so that the master problem, the subproblem, or both are not
  necessarily linear programs. In IMT, the problem is ``decomposed''
  into a core ILP instance and background theory problems.  }

\paragraph{Generalized CDCL:} A family of solvers that generalize
CDCL-style search to richer logics recently
emerged~\cite{cutsat,naturalsmt,richerdpll,mcsat}. This research
direction can be viewed as progress towards SMT with a
non-propositional core. Our work is complementary, in the sense that
we do not focus on the core solver, but rather provide a way to
combine a non-Boolean core with theories.



\paragraph{Inexact Solvers:} Linear and integer programming solvers
generally perform FP (and thus inexact) calculations. Faure et
al. experiment with the inexact CPLEX solver as a theory
solver~\cite{inexact}\comment{They observe that it does not handle
  well the small, incremental queries that an SMT solver performs,}
and observe wrong answers. For many applications, numerical
inaccuracies are not a concern, \eg the noise in the model overshadows
the floating point error intervals. \comment{or an answer close enough
  to the theoretical optimal suffices.} However, accuracy is often
critical. Recent work~\cite{safeboundsmip,exactrational} proposes
using FP arithmetic as much as possible (especially for solving
continuous relaxations) while preserving safety. \comment{that cutting
  planes, infeasibility certificates, and bounds obtained from
  relaxations are safe.} IMT solvers can be built on top of both exact
and inexact solvers.

\section{Conclusions and Future Work}
\label{sec:conclusions}

We introduced the ILP Modulo Theories (IMT) framework for describing
problems that consist of linear constraints along with background
theory constraints.  We did this via the \bct{} transition system that
captures the essence of branch-and-cut for solving IMT problems. We
showed that \bct{} is a sound and complete optimization procedure for
the combination of ILP with stably-infinite theories. We conducted a
detailed comparison between SMT and IMT.

Many interesting research directions now open up. We could try to
relax requirements on the background theory (\eg stably-infiniteness,
signature disjointness) while preserving soundness and
completeness. We anticipate interesting connections between IMT and
other paradigms, \eg SMT, constraint programming, cut generation, and
decomposition. Additionally, the \bct{} architecture seems to allow
for significant parallelization. Finally, we believe that IMT has the
potential to enable interesting new applications.

\section*{Acknowledgements}

We would like to thank Harsh Raju Chamarthi, Mitesh Jain, and the
anonymous reviewers for their valuable comments and suggestions.

\bibliographystyle{abbrv}
\bibliography{cav_2013}

\end{document}
