\documentclass[letterpaper,11pt,abstracton]{scrartcl}

\RequirePackage{fullpage}

\RequirePackage{enumerate}
\RequirePackage[latin1]{inputenc}
\RequirePackage{amsmath}
\RequirePackage{amssymb}



\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}


\usepackage{amsmath,amsfonts}
\usepackage{epsfig}
\newcommand{\NP}{NP}
\newcommand{\diam}{{\rm diam}}
\newcommand{\rad}{{\rm rad}}
\newcommand{\dom}{\mbox{}}
\newcommand{\ndom}{\mbox{}}
\newcommand{\sdom}{\mbox{}}
\newcommand{\nsdom}{\mbox{}}
\newcommand{\qed}{\hfill}
\newcommand{\pf}{{\textbf Proof: }}
\newtheorem{theorem}{Theorem}[section]
\newcommand{\ra}{\rangle}
\newcommand{\la}{\langle}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{tm}[theorem]{Theorem}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{obs}[theorem]{Observation}
\newtheorem{cor}[theorem]{Corollary}
\newtheorem{prp}[theorem]{Proposition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{dfn}[theorem]{Definition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{example}[theorem]{Example}
\newcommand{\beq}{}


\begin{document}

\title{Ordering with precedence constraints and budget minimization}


\author{Akbar Rafiey \thanks{Simon Fraser University email : arafiey@sfu.ca} \and 
Jeff Kinne \thanks{Indiana State University email : jkinne@cs.indstate.edu Supported by Indiana State University COMPETE grant} \and
J\'an Ma\v nuch \thanks{University of British Columbia email : jmanuch@cs.ubc.ca  Supported by NSERC Canada} \and
Arash Rafiey \thanks{Indiana State University and Simon Fraser University email :  
arash.rafiey@indstate.edu Supported by Indiana State University COMPETE grant} \footnote{Names of the last three authors appear alphabetically}
}


\date{}
\maketitle




\begin{abstract}
We introduce a variation of the scheduling with precedence
constraints problem that has applications to molecular folding and
production management. We are given a bipartite graph
.  Vertices in  are thought of as goods or services that must be
\emph{bought} to produce items in  that are to be \emph{sold}.  An
edge from  to  indicates that the production of
 requires the purchase of .  Each vertex in  has a cost, and
each vertex in  results in some gain.  The goal
is to obtain an ordering of  that respects the precedence
constraints and maximizes the minimal net profit encountered as the vertices
are processed.  We call this optimal value the \emph{budget} or
\emph{capital} investment required for the bipartite graph, and refer to our
problem as \emph{the bipartite graph ordering problem}.

The problem is equivalent to a version of an NP-complete molecular folding problem
that has been studied recently \cite{MTSC09}. Work on
the molecular folding problem has focused on heuristic algorithms and
exponential-time exact algorithms for the un-weighted problem where costs
are  and when restricted to graphs arising from RNA folding.

The present work seeks exact algorithms for solving the bipartite
ordering problem.  We demonstrate an algorithm that computes
the optimal ordering in time  when  is the number of vertices
in the input bipartite graph. We give non-trivial polynomial time algorithms for finding
the optimal solutions for bipartite permutation graphs, trivially perfect bipartite graphs, co-bipartite graphs.

We introduce a general strategy that can
be used to find an optimal ordering in polynomial time for bipartite graphs
that satisfy certain properties. One of our ultimate goals is to completely characterize
the classes of graphs for which the problem can be solved exactly
in polynomial time.




\end{abstract}


\section{Motivation and Introduction}\label{sec:intro}

\paragraph{Job Scheduling with Precedence Constraints}
The setting of job scheduling with precedence constraints is a natural
one that has been much studied (see, e.g., \cite{CS05,MMS04}).  A number of
variations of the problem have been studied; we begin by stating one.
The problem is formulated as a directed acyclic graph where
the vertices are jobs and arcs between the vertices impose precedence
constraints.  Job  must be executed after job  is completed if
there is an arc from  to .  Each job  has a weight  and
processing time .  A given ordering of executing the jobs results
in a completion time  for each job.  Previous work has focused on
minimizing the weighted completion time .
This can be done in the single-processor or multi-processor setting,
and can be considered in settings where the precedence graph is from
a restricted graph class.  The general problem of finding an ordering that
respects the precedence constraints and minimizes the weighted
completion time is NP-complete.  Both approximation algorithms and
hardness of approximation results are known \cite{AMMS11,AMS07,MMS04,woginger1}.



\paragraph{Our Problem -- Optimizing the Budget}
In the present work, we consider a different objective than previous
works.  In our setting, each job  has a net profit (positive or
negative) .  Our focus is on the \emph{budget} required to
realize a given ordering or schedule, and we disregard the processing
time.  We imagine that the jobs are divided between those with negative
, jobs  that must be \emph{bought}, and jobs with a non-negative
, jobs  that are \emph{sold}.   could consist of raw inputs
that must be purchased in bulk in order to produce goods  that
can be sold.  A directed graph
 encodes the precedence constraints inherent in the
production: an arc from  to  implies that item 
must be bought before item  can be produced and sold.
At each step  of the process, let  be the jobs processed
thus far, and let  be the total budget
up to this point.  Our goal is an ordering that respects the precedence
constraints and keeps the minimal value of  as high as possible.
One can view (the absolute value of) this optimal value as the \emph{capital} investment required
to realize the production schedule.



In this work we assume  is a bipartite graph with all arcs from
 to .  This models the situation where each item to be produced and
sold depends on certain inputs that must be purchased.
We call this the problem of \emph{ordering with precedence
  constraints and budget minimization on bipartite graphs} but refer
to the problem as the \emph{bipartite graph ordering problem}.

\paragraph{Applications}
The bipartite graph ordering problem is a natural variation of scheduling with
precedence constraints problems.  As described above the problem can be used
to model the purchase of supplies and production of goods when purchasing in
bulk.  Another way to view the problem is that the items in  are training sessions that employees must complete before employees (vertices in ) can
begin to work.

We began studying the problem as a generalization of an optimization
problem in molecular folding.  The folding problem asks for the energy
required for secondary RNA structures to be transformed from a given
initial folding configuration  into a given final folding
configuration  \cite{GFWT08,MH98,TMRM09}. The bipartite graph ordering problem models
this situation as follows: vertices in  are folds that are to be
removed from , vertices in  are folds that are to be
added, and an edge from  to  indicates that fold  must be
removed before fold  can be added.  The price  of a vertex is set
according to the net energy that would result from allowing the given
fold to occur, with folds that must be broken requiring a positive
energy and folds that are to be added given a negative energy.  The
goal is to determine a sequence of transformations that respects these
constraints and still keeps the net energy throughout at a minimum
\footnote{Note that the molecular folding problem is a minimization problem,
  and can be made a maximization problem by negating the energies.
}.
Figure \ref{fig:1} shows how an instance of the RNA folding problem is
transformed into the bipartite graph ordering problem.


\paragraph{Previous Work}
The molecular folding problem has been studied only in the
setting of unit prices and most attention has been devoted to graph classes corresponding to typical
folding patterns (in particular for so-called circle bipartite graphs).
\cite{MTSC09} shows that the molecular folding problem is NP-complete
even when restricted to circle bipartite graphs; thus the bipartite graph ordering
problem is NP-complete as well when restricted to circle bipartite graphs
\footnote{ A graph  is called a \emph{circle graph} if the vertices
  are the chords of a circle and two vertices are adjacent if their
  chords intersect.  The circle bipartite graphs can be represented as two
  sets  where the vertices in  are a set of non-crossing arcs
  on a real line and the vertices in  are a set of non-crossing
  arcs from a real line; there is an edge between a vertex in  and
  a vertex in  if their arcs cross.  The top graph in Figure
  \ref{fig:1} is a circle bipartite graph shown with this representation.}.

Previous work on the folding problem has focused on exact algorithms that
take exponential time and on heuristic algorithms \cite{FHMS01}.

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.5]{graphnew.pdf}
\caption{
\footnotesize{
  The top graph is an instance of the RNA folding problem, with folds , ,
  and  to be removed (bought), folds , , and  to be added (sold); an edge cannot
  be added until edges that cross it are removed. A budget of two is needed and an optimal ordering is , , , , , .
}
}
\label{fig:1}
\end{center}
\end{figure}




There has been considerable study of scheduling with precedence constraints,
but to our knowledge there has not been any work by that community on the
objective function we propose (budget minimization).

\subsection{Our Results}

We introduce the bipartite graph ordering problem, which is equivalent to a
generalization of a molecular folding problem.  We initiate the study
of which graph classes admit polynomial-time exact solutions. We also
give the first results for the weighted version of the problem; previous
work on the molecular folding problem assumed unit costs for all folds.

\paragraph{Exponential-time Exact Algorithm}
We first give an exact algorithm for arbitrary bipartite graphs.
\begin{tm}\label{thm:exp}
  Given a bipartite graph , the bipartite graph ordering problem on  can be
  solved in (a) time and space , and (b) time  and polynomial
  space, where .
\end{tm}
The previous best exact algorithm for the molecular folding
problem on circle bipartite graphs has running time , where  is the optimal budget
\cite{TMRM09}.

We observe that  can be  when vertex prices
are  (and can be much larger when vertex prices can be arbitrary), as follows.
Let  be a projective plane of order  with  prime.  The projective plane of order  consists of  lines each consisting of
precisely  points, and  points which each are intersected by precisely 
lines.  We construct a bipartite graph with each vertex in  corresponding
to a line from the projective plane, each vertex in  corresponding
to a point from the projective plane, and a connection from  to
 if the projective plane point corresponding to  is contained in
the line corresponding to .  Vertices in  are given weight -1, and
vertices in  are given weight 1.
Note that the degree of each vertex in  is . One can observe that the neighbourhood of every set of  vertices in  is at
least . This implies
that in order to be able to sell the first  vertices in  the budget decreases by at least .


\paragraph{Polynomial-time Cases}


We develop algorithms for solving  a number of bipartite graph classes.
These bipartite graph classes are briefly defined after the theorem statement and
discussed further in Sections \ref{sec:poly-TP-CB} and \ref{sec:poly-permutation}.

\begin{tm}\label{thm:main}
  Given a bipartite graph , the bipartite graph ordering problem on  can be
  solved in polynomial time if  is one of the following:
  a bipartite permutation graph, a trivially perfect bipartite graph, a co-bipartite graph or a tree.
\end{tm}

The bipartite graphs we consider here have been considered for other types of optimization problems.
In particular \emph{bipartite permutation graphs} also known as proper interval bipartite graphs
(those for which there exists an ordering of the vertices in  where the neighborhood of each vertex in  is a set of consecutive vertices (interval) and the intervals can be chosen
so that they are inclusion free) are of interest in graph homomorphism problems \cite{GHRY08} and also
in energy production applications where resources (in our case bought vertices) can be assigned (bought) and used (sold) within a number of
successive time steps \cite{KKRS13,MS12}.
There are recognition algorithms for bipartite permutation graphs \cite{GHRY08,SBS98}.
A bipartite graph is called \emph{trivially perfect} if it is obtained from a union of two trivially perfect bipartite graphs  or by joining every sold vertex in trivially perfect bipartite graph
 to every bought vertex in trivially perfect bipartite graph . A single vertex is also a trivially perfect bipartite graph.
These bipartite graphs have been considered in \cite{CEM13,EKLT12,MMS04}.  \emph{Co-bipartite graphs} have a similar definition
with a slightly different join operation. See Section \ref{sec:poly-TP-CB} for the precise definitions.

For trivially perfect bipartite graphs and co-bipartite graphs, due to the recursive nature
of the definition of these graphs it is natural to attempt a divide and conquer strategy.
However, a simple approach of solving sub-problems and using these to build up to a solution of the whole
problem fails because one may need to consider all possible orderings of combining the sub problems.

In section \ref{sec:general-strategy} we develop a general approach that can be applied to the graph classes
mentioned.





\paragraph{Arbitrary Vertex Weights}
Each of our results holds where the weights on vertices can be
arbitrary (not only  as considered by previous work on the
molecular folding problem) except for trees. 

\section{Some Simple Classes of bipartite graphs}\label{sec:simple}
In this section we state some simple facts about the bipartite graph ordering
problem and give a simple self-contained proof that the problem can be
solved for trees.  We provide this section to assist the reader in
developing an intuition for the problem.

\paragraph{\textbf{Bicliques}}
First we note that if  is a biclique with  then  (the
budget required to process ) is .

As a next step, consider a disjoint union of bicliques  where each  is a biclique between bought vertices  and
sold vertices .  Intuition suggests that we should first process
those  such that .  This is indeed correct and
is formalized in Lemma \ref{lm:minpos} in Section \ref{sec:main} (the
reader is encouraged to take this intuition for granted while
initially reading the present section).  After processing  with
, which we call \emph{positive} (formally defined in
generality in Section \ref{sec:main}), we are left with bicliques
 where . Up to this point we may have
built up some positive budget.

In processing the remaining  the budget steadily goes down --
because the  are bicliques and disjoint, and the remaining sets
are not positive.  As we shall see momentarily, we should process those  with largest 
first. Suppose on the contrary that  but an optimal
strategy  processes  right before .  If  is the
budget before this step we first have that 
because otherwise there would not be sufficient budget after
processing  to process .  Since we assumed that  we have . Thus, we could first process
 and then .  We have thus given a method to compute an
optimal strategy for a disjoint union of bicliques: first process
positive sets, and then process bicliques in decreasing order of
.

\paragraph{\textbf{Paths and Cycles}}
We next consider a few even easier cases.  Note that a simple
path can be processed with a budget of at most 2, and a simple
cycle can be processed with a budget of .

\paragraph{\textbf{Trees and Forests}}
Next we assume the input graph is a tree and the weights are 
(for vertices in  and , respectively).  Let  be a tree, or in
general a forest. Note that any leaf has a single neighbor (or none,
if it is an isolated vertex).  We can thus immediately process any
sold leaf  by processing its parent in the tree and then processing
.  This requires an initial budget of only 1.  After repeating the
process to process all sold leaves in , we are left with a forest
where all leaves are bought vertices in .  We can first remove from
consideration any disconnected bought vertices in  (these can, without
loss of generality, be processed last).
We are left with a forest .

We next take a sold vertex  (which is not a leaf because all sold
leaves in  have already been processed) and process all of its neighbours.  After processing
 we can process  and return 1 unit to the budget.  Note that because
 is a forest, the neighbourhood of  has intersection at most 1 with the
neighbourhood of any other sold vertex in .  Because we have already processed all
sold leaves from , we know that only  can be processed after processing
its neighbours.

After processing , we may be left with some sold leaves in .  If so,
we deal with these as above.  We note that if removing the neighbourhood of
 does create any sold leaves, then each of these has at least one
bought vertex in  that is its neighbour and is not the neighbour of any of the other
sold leaves in .  When no sold leaves remain, we pick a
sold vertex  and deal with it as we did .

This process is repeated until all of  is processed.  We note that after initially
dealing with all sold leaves in , we gain at most a single sold leaf at a time.
That is, the budget initially increases as we process sold vertices and process their
parents in the tree, and then the budget goes down progressively, only ever
temporarily going up by a single unit each time a sold vertex is processed.
Note that the budget initially increases, and then once it is decreasing
only a single sold vertex is processed at a time.  This implies that the budget required
for our strategy is , the best possible budget for a graph with
 weights.






\section{An Exponential-time Exact Algorithm}\label{sec:exp}
In this section we prove Theorem \ref{thm:exp}.

The authors in \cite{BFKKT} show that any vertex ordering problem on
graphs of a certain form can be solved in both (a) time and space
, and (b) time  and polynomial space, where  is
the number of vertices in the graph and  is shorthand for
.  We show that the ordering
problem can be seen to have the form needed to apply this result.

A vertex ordering on graph  is a bijection .
Note that orderings we consider here respect the precedence
constraints given by edges of bipartite graph .
For a vertex
ordering  and , we denote by  the
set of vertices that appear before  in the ordering.  More
precisely, .

Let  be the set of all permutations of a set  and  be a
function that maps each couple consisting of a graph  and a
vertex set  to an integer as
follows:

\begin{center}
.
\end{center}
Note that the function  is polynomially computable. Now, if we
restrict the weights of vertices to be  (vertices in  have
weight -1 and vertices in  have weight 1) we can express the
bipartite graph ordering problem as follows:

\begin{center}
.
\end{center}

The right hand side of this equation is the form required to apply the result of
\cite{BFKKT}, proving Theorem \ref{thm:exp} for the case of  weights.
The result for arbitrary weights , with  negative for  and
 non-negative for , follows by modifying  to be
.



\section{Definitions and Concepts} \label{sec:main}

In this section we define key terms and concepts that are relevant to
algorithms that solve the bipartite graph ordering problem on general bipartite graph.  We use the graph in Figure \ref{fig:2} as an example to
demonstrate each of our definitions.  The reader is encouraged to
consult the figure while reading this section.  Recall that bipartite graph
 encodes the precedence constraints inherent in the
production: an arc from  to  implies that item 
must be bought before item  can be produced and sold.
At each step  of the process, let  be the jobs processed
thus far, and let  be the total budget used
up to this point.  Our goal is an ordering that respects the precedence
constraints and keeps the maximal value of  as small as possible.


Let  be a set of vertices.  refers to the cardinality of set
.  When applying our arguments to weighted graphs, with vertex 
having price , we let  to be .
Each of our results holds for weighted graphs by letting  refer
to the weighted sum of prices of vertices in  in all definitions and
arguments.

We use  to denote the budget or capital available to process an
input bipartite graph.  As vertices are processed, we let  denote the current
amount of capital available for the rest of the graph.

\begin{dfn}\label{def:Nstar}
  Let  be a bipartite graph. For a subset  of bought vertices in ,
  let {} be the set of all vertices in  whose entire neighborhood lie in .
\end{dfn}

\begin{dfn}\label{def:prime}
  We say a set  is {\em prime} if  is non-empty and
  for every proper subset ,  is empty.
\end{dfn}

Note that the bipartite graph induced by a prime set  and  is a bipartite clique.
For any strategy to process an input bipartite graph , we look at the
budget at each step of the algorithm. Suppose our initial
budget is . Knowing which subsets of  are prime, one can see that every optimal strategy can be 
modified to start with processing a prime subset 
(Lemma \ref{first-prime}). This
leaves a budget of  to process the rest of the bipartite graph.
An example for prime sets is given in Figure \ref{fig:2}. For the given graph prime sets are ,
 , ,  with , , , and .

\begin{lemma}\label{first-prime}
There is an optimal strategy for \textsc{Bipartite Ordering Problem} on bipartite graph  without isolated vertex, 
that starts with a prime set.
\end{lemma}
\pf Let  be an optimal strategy that does not start with a prime set. Suppose  is the first position in  where  and
 . Let set  be the smallest set with . Note that such a set  exists since all the adjacent vertices to  are among vertices in . Observe that changing the processing order on vertices in  does not harm optimality. Therefore, we can change  by processing vertices in  at first, without changing the budget. In addition, we can process  immediately after processing .
\qed \\

Our algorithm will generally try to first process subsets  that
increase (or at least, do not decrease) the budget.  We call such
subsets \emph{positive}, and call  \emph{negative} if processing it
would decrease the budget.

\begin{dfn}\label{def:budget-for-prime}
  A budget of  is the minimum budget  needed to process , denoted by  .
  For simplicity we write  if  is clear from the context.
\end{dfn}

\begin{dfn}\label{def:positive} A set
   is called \emph{positive} if  and it is \emph{negative} if .
  For a given budget ,  is called \emph{positive minimal} (with respect to budget ) if it is positive,  has budget at most
  ,  and every other positive  subset of  has budget more than . In
  other words,  is  smallest among all the subsets of  that is positive and has
  budget at most .
\end{dfn}

For the given graph in Figure \ref{fig:2},  is the only positive minimal set and  contains  vertices. Note that, in general, there can be more than one positive minimal set.
Positive minimal sets are key in our algorithms for computing the budget
because these are precisely the sets that we can process
first, as can be seen from Lemma \ref{lm:minpos}.  In the graph of Figure \ref{fig:2}, the positive set 
would be the first to be processed.

\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.4]{closure.pdf}
\caption{ A bipartite permutation graph that we use as an example for
    the definitions related to our algorithm.  Each bold line shows a
    complete connection, i.e. the induced sub-graph by  is a biclique. The numbers in
    the boxes are the number of vertices.  The sets 
    are the items  to be bought, with each vertex having weight
    -1.  The sets  are the items  to be sold,
    with each vertex having weight 1. }
\label{fig:2}
\end{center}
\end{figure}




\begin{lemma} \label{lm:minpos}
  Let  be a bipartite graph that can be processed with budget at most .
If  contains a positive minimal set (with respect to ) then there is a strategy for  with budget  
  that begins by processing a positive minimal
  subset  such that for all  we have .
\end{lemma}
\pf Let  be a positive minimal set in . Suppose the optimal process  does not process  all together and hence processes the sequence
 of disjoint subsets of  where
  is a positive minimal set and , . Note that according to 
for all ,  we have  in graph  
where .
First consider the case when . 
Let . 
For this case we have

Therefore  in graph  is at most .
Together with , we conclude that, there is another optimal process that considers  
first and then  next and then following . 

Now consider the case when . 
Note that since  is a positive minimal set then processing  
needs budget more than  as otherwise  contradicts the minimality of . On the other hand,  processes  
with budget at most . Therefore, during processing  there exists a  such 
that  is a positive set. Minimum such  gives us a positive minimal set.
This completes the proof.
\qed 


\begin{lemma}\label{correctness}
Suppose that  is a positive subset with 
and  is a negative subset where  and .
If  then  forms a positive subset.
\end{lemma}
\pf Let . By the assumption that  can be processed after processing
 we have . On the other hand, since , we have
. From these two we conclude that:\\


Moreover, because  is a positive set then .
By (\ref{eq}),  being positive, and the fact that
 for any  and , we have
, i.e.,  is a positive subset.
\qed \\


Given a bipartite graph , Lemma \ref{lm:minpos} suggests a basic strategy,
if there are positive sets, find a positive minimal subset , process it.  When a given subset  is processed, we
would consider the remaining bipartite graph and again try to find a positive
minimal subset to process, if one exists. Note that
 may have positive sets even if  does not.
For example, in the graph of Figure \ref{fig:2},
 has no positive set,
but  is positive in .  When a
subset  is processed we generally would like to process
any sets that are positive in the remaining bipartite graph.  That is,
we would like to process , defined below.
For our purpose we order all the prime sets lexicographically, by assuming some ordering on the vertices of .

\begin{dfn}\label{def:closure}
  Given current budget  and given , let  where each ,
   is the lexicographically first
   positive minimal subset in
   
   () such that in  we have .  Here  is the number of times the process of processing a positive minimal
set can be repeated after processing .
\end{dfn}
When the initial budget  is clear from context, we use  rather than .
Note that  could be only , in this case . For instance consider Figure \ref{fig:2}. In the graph induced by  we have  with respect to any current budget  at least .




\section{Polynomial Time Algorithm for Trivially Perfect Bipartite and Co-bipartite Graphs}\label{sec:poly-TP-CB}

In this section we define trivially perfect bipartite graphs and co-bipartite graphs,
and discuss the key properties that are used in our algorithm for solving
the bipartite graph ordering problem in these bipartite graphs.  In particular, it is
possible to enumerate the prime sets of these graphs by looking at a way
to construct the graphs with a tree of graph join and union operations.

The subclass of trivially perfect bipartite graphs called {\em laminar family bipartite graphs} were considered in \cite{MSW10} to obtain a
polynomial time approximation
scheme (PTAS) for special instances of a job scheduling problem. Each instance of the problem in \cite{MSW10} is a bipartite graph
 where  is a set of jobs and  is a set of machines. For every pair of jobs  the set of machines that can process
 are either disjoint or one is a subset of the other. The trivially perfect bipartite graphs also play an important role in
studying the list homomorphism problem. The authors of \cite{EKLT12} showed that for these
bipartite graphs, the list homomorphism problem can be
solved in logarithmic space. They were also considered in the fixed parametrized version of the list homomorphism problem
in \cite{CEM13}.

We call these bipartite graphs ``trivially perfect
bipartite graphs'' because the definition mirrors one of the equivalent
definitions for trivially perfect graphs.

\begin{dfn}[trivially perfect bipartite graph, co-bipartite graph]
  \label{def:tp}
  A bipartite graph  is called \emph{trivially perfect} , respectively
  a \emph{co-bipartite graph} if it can be constructed by applying the
  following operations.
  \begin{itemize}

  \item A bipartite graph with one vertex is both trivially perfect and a co-bipartite graph.
  \item If  and  are trivially perfect then the disjoint union of  and  is trivially perfect.

    Similarly, the disjoint union of co-bipartite graphs is also a co-bipartite graph.
  \item If  and  are trivially perfect then by joining
every sold vertex in  to every bought vertex in , the resulting bipartite graph is trivially
    perfect.

    If  and  are co-bipartite graphs, their \emph{complete} join---where every sold
    vertex in  is joined to every bought vertex in  and every bought vertex in  is
    joined to every sold vertex in ---is a
    co-bipartite graph.
  \end{itemize}
\end{dfn}

An example of each type of graph is given in Figure \ref{fig:sibling}. In the left figure (trivially perfect)  and  are prime sets.
On the right figure (co-bipartite graph) prime sets are  are prime
sets.

\begin{figure}[htbp]
 \begin{center}
\includegraphics[scale=0.4]{sibling.pdf}
\caption{
Each bold line shows a complete connection, i.e. the induced sub-graph
by  is a biclique.
}
    \label{fig:sibling}
  \end{center}
 \end{figure}
These two classes of bipartite graphs can be classified by forbidden obstructions, as follows.

\begin{lemma}[\cite{EKLT12,GV97}] \label{lm:obstruct}
   is trivially perfect if and only if it does not contain any of the
  following as an induced sub-graph: , .

   is a co-bipartite graph if and only if it does not have any of the
  followings as an induced sub-graph 

\begin{figure}[htbp]
 \begin{center}
\includegraphics[scale=0.7]{bi-cograph.pdf}
\caption{
\footnotesize{Forbidden constructions for co-bipartite graphs.
 }
}
  \end{center}
 \end{figure}
\end{lemma}
Our algorithm to solve  for trivially perfect bipartite graphs and co-bipartite graphs
centers around constructing  as in Definition \ref{def:tp}.  We view this
construction as a tree of operations that are performed to build up the final
bipartite graph, and where the leaves of the tree of operations are \emph{bicliques}.
If  is not connected then the root operation in the tree is a disjoint
union, and each of its connected components is a trivially perfect
bipartite graph (respectively co-bipartite graph).  If  is connected, then the root operation is a
join. The following lemma shows how to find such a decomposition tree for given trivially perfect bipartite graph in polynomial time. For co-bipartite graph  a polynomial time algorithm to compute decomposition tree is given in \cite{GV97}.



\begin{lemma}\label{lm:make-tree}
  Given a trivially perfect bipartite graph  with  vertices, there exists an algorithm that finds a decomposition tree for  in 
  time .
\end{lemma}
\pf If  is not connected then the root of tree  is  and
two children  are chosen such that  contains all the connected components  of  where  (if there is any)
and  contains all the other connected components. The root has a label "union". Note that if there exists only one such  then .
If for every connected component of  the size of its bought vertices is smaller than the size of its sold vertices then one of them would be in  and the rest lie in .

If  is connected then we proceed as follows.
Let  be a maximum integer such that the following test passes.
Let  be the set of vertices in  which have degree at least  and let . Let  be the set of all vertices in 
that are common-neighborhood of all the vertices in . If  then the test fails. Moreover, if there exists a vertex  such that  then
the tests fails. If the test passes then let  and let the root of  be  with label "join" and the
left child of  is  and the
right child of the root is . Note that by the definition of trivially perfect bipartite graphs.
If the test fails for every  then  is not trivially perfect.

We continue the same procedure from each node of the tree until  each node becomes a biclique. Node that  has at most  nodes. For a particular , checking all the conditions of the test takes
. Therefore the whole procedure takes .
 \qed \\

\begin{figure}[htbp]
 \begin{center}
\includegraphics[scale=0.7]{decomposition.pdf}
\caption{
Decomposition tree associated to the graphs in Figure \ref{fig:sibling}.
}
    \label{fig:decomposition}
  \end{center}
 \end{figure}



Algorithm \ref{budget-poly} shows that how we traverse a decomposition tree in bottom-up manner and for each node of the tree we do a binary search to find the optimal budget for the graph associated to that node. Note that we assume for the graph associated to a particular node of tree the optimal budgets for its children have been computed and stored.
\begin{algorithm}[H]
\begin{algorithmic}[1]
\State \textbf{Input:} Trivially perfect bipartite (resp.) graph , its decomposition tree \;
\State \textbf{Output:} \;
\State Start from leaves of  and traverse  in bottom-up manner:\;
\State Let  be the associated graph to node  of \;
\State\Comment{Assume optimal strategies for children of  are already computed}
\State  and 
\While{  }
	\If{\textsc{BudgetTriviallyPerfect} (resp. BudgetCo-Bipartite) is True}
    	\State  \;
        \Else
        	\State 
    \EndIf
\EndWhile
\Return l\;
\end{algorithmic}
\caption{{\textsc{BudgetTPC}} ( )}
\label{budget-poly}
\end{algorithm}

If the graph is constructed by union operation it requires a merging function. Such a function is given
in Algorithm \ref{combine}. \textsc{Combine} function takes optimal solutions of two trivially perfect (respectively co-bipartite)
graphs and return an optimal strategy for the union of them. In what follows, we give the  description of our algorithm and prove its correctness.

Recall that we assume eavery vertex in  has at least one neighbor. 







\begin{algorithm}[H]
\begin{algorithmic}[1]
\State \textbf{Input:} Trivially perfect bipartite graph  and budget \;

\Comment We assume decomposition tree  of  is given.

\State \textbf{Output:} "True" if we can process  with budget at most , otherwise "False".\;
\If{ and  } \Return True\;
\EndIf

\If{ is a bipartite clique and  } 
process  by ordering vertices in  first and then ordering vertices in  after and \Return True\;
\EndIf
\If { is constructed by join operation between  and }\label{if-join}

\Comment  already computed and assume  and  induce a bipartite clique.

\If { } \Return False;
\ElsIf {} \Return False;
\Else {}  first process  then process  and \Return True,
\EndIf
\EndIf \label{if-join-end}

\If{ is constructed by union of  and }

 \If { a positive minimal subset  with } \State Process (),
     \State \Return call \textsc{BudgetTriviallyPerfect}
     \;
\EndIf \If{a positive set  with the smallest budget has  }
\Return False\;
\EndIf \label{lastIF}







 \If{  OR  }
  \Return False\;



 \Else {} \Return \textsc{Combine}()
 \EndIf

\EndIf

\end{algorithmic}
\caption{{\textsc{BudgetTriviallyPerfect}} ()}
\label{alg:trivially-perfect}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\State \textbf{Input:} Optimal strategies for  and budget \;
\State \textbf{Output:} "True" if we can process  with budget at most , otherwise "False".\;

\State Let  be the first prime set in  and  be the first prime set in .

\If { OR  }
	\State Process  and 
       \State Call .


\Else{}  \State Process  and ,
         \State Call \textsc{Combine} .

\EndIf

\end{algorithmic}
\caption{{\textsc{Combine}} ( )}
\label{combine}
\end{algorithm}

\begin{tm}\label{thm:poly-TP-CB}
  For trivially perfect bipartite graphs  with  vertices the \textsc{BudgetTriviallyPerfect} algorithm runs in
   and correctly decides if  can be processed with budget  (Algorithm \ref{alg:trivially-perfect}).
\end{tm}
\pf The correctness of lines 3,4 is obvious. It is clear that if  is obtained from  and  by join operation then 
the any optimal strategy must starts with .
Therefore the Lines 5--8 are correct.

Suppose  is obtained from  by union operation. Let  be a positive minimal set and let  be the induced sub-graph
of  by . If  is not connected then there is at least one connected component of 
that is positive, a contradiction to minimality of . Thus we may assume  is connected. According to the decomposition of  there are
 and  such that  and  are trivially perfect bipartite graph.
Suppose every bought vertex in  is adjacent to every sold vertex in .
 Observe that  any positive set must include either a positive part of  or all  together with a positive part of .
In the former case, we search in  for a positive set. In the later one, we search for a positive set  in 
so that . In either case, we repeat the same procedure and
traverse the decomposition tree to find a positive set. This takes . The correctness of Lines 10-12 is followed by Lemma 
\ref{first-prime} and \ref{lm:minpos}. 
Suppose line 13 is incorrect and all positive subsets would have budget above .
Let  be one such subset. Then there would be a
way to process  with budget at most  in . In that case, we would process some negative set
 which somehow reduces the budget of processing ; this can
only be so if . In this case the Lemma
\ref{correctness} states that 
is itself a positive set with budget at most , a contradiction.\\





We continue our argument by assuming that  is constructed form  and  by "union" operation.
We proceed by showing the correctness of \textsc{Combine} function. Let  be the first
prime set in  and  be the first prime set in . 



\begin{obs}
 Let  and  be two disjoint trivially perfect bipartite graphs (). Suppose optimal
strategies for computing the budget for  and  are provided.  If  are the first prime sets in  then there is an optimal
ordering for  such that either  or  is processed first. 
\end{obs}



To complete the proof for correctness of \textsc{Combine} function, it remains to show that the Combine function correctly chooses
between  and , the first prime set to process in . Suppose we have   and .
We claim there exists an optimal strategy for  that starts processing  first. Let  be the optimal strategy that process  first.
Let  be the prime subsets in  that are processed by  before starting  in  (note that by Observation above
 starts processing  in  first). We note that . Because we assume that there is no positive set
in . Therefore we have
 and hence we obtain a strategy  that starts
with  first and then it processes  from  and then it follows . Observe that under ,  does not increases.

Note that finding  takes  and it can be determined according to join or union operation as follows.  
 
Suppose  is associated to a
node of the decomposition tree and it is constructed from  and  either by union or join operation.
Without loss of generality, we assume there is no positive minimal set in , as otherwise, we process them first.
Let . First, if the operation is union then  does not change. Second, suppose the operation is join and every sold vertex in
 is adjacent to every bought vertex in . If  is the entire  then  is  plus all positive minimal sets in .
If  then it does not change in .
Therefore, updating  at each step takes at most  time. These would imply that the overall running time would be . 
\qed \\


In what follows we show that there is a subclass of trivially perfect bipartite graphs that are also circle bipartite graphs.
A bipartite graph  is called a \textit{chain graph} if the neighborhoods of vertices in  form a chain, i.e, if there is an ordering of vertices in , say , such that .

It is easy to see that the neighborhoods of
vertices in  also form a chain. \textit{Chain graphs} are subsets of
both \textit{trivially perfect bipartite graphs} and \textit{circle bipartite graphs}.
Any \textit{chain graph} can be visualized as what is
depicted in Figure \ref{fig:4}(a), and the corresponding RNA model for the bipartite graph ordering problem looks like Figure \ref{fig:4}(b).


\begin{figure}[htbp]
\begin{center}
\includegraphics[scale=0.7]{chain.pdf}
\caption{
: Each bag  and  contains at least one vertex, for .
A line between  and  means that vertices in  induce a complete bipartite graph for .
 :
Each  and  arc represents a collection of arcs; the number of arcs which are represented by each  and  arc is equal to the number of
vertices in bag  and , for .
}
\label{fig:4}
\end{center}
\end{figure}


Next we present a polynomial time algorithm for co-bipartite graphs. Our algorithm for this class of graphs is quite similar to Algorithm \ref{alg:trivially-perfect}. The main difference is in the way we deal with co-bipartite graph  when it is constructed from two co-bipartite graphs  and  by join operation. Recall that in join operation for co-bipartite graphs,  and  are bipartite cliques. Observe that in this case there are two possibilities for processing :
\begin{itemize}
\item first process entire  then solve the problem for  with budget , and at the end process , or
\item first process entire  then solve the problem for  with budget , and at the end process .
\end{itemize}

For the case when  is constructed from  and  by union operation we call \textsc{Combine} function (Algorithm \ref{combine}). The description of our algorithm is given in Algorithm \ref{alg:co-bipartite}. The proof of correctness of Algorithm \ref{alg:co-bipartite} is almost identical to the proof of Theorem \ref{thm:poly-TP-CB}.

\begin{tm}
Algorithm \ref{alg:co-bipartite} in polynomial times decides if co-bipartite graph  can be processed with budget at most .
\end{tm}



\begin{algorithm}[H]
\begin{algorithmic}[1]
\State \textbf{Input:}  Co-bipartite graph  constructed from
 and , , , its decomposition tree , and budget \;
\State \textbf{Output:} "True" if we can process  with budget at most , otherwise "False".\;
\If{ and  OR  is a bipartite clique and } \label{firstIF-co}
 process  and \Return True\;
\EndIf
\If { is constructed by join operation between  and }
	\If{  }
    	\Return True and process , process  with
    	
    	\hspace{3mm}  budget , and process \;
    	
    \ElsIf {  }
    	\Return True and process , process  with
    	
    	\hspace{3mm} budget , process \;
    \Else {} \Return False\;
    \EndIf
\EndIf 

\If{ is constructed by union of  and }

 \If { a positive minimal subset  with } \State Process  and ,
     \State \Return call \textsc{BudgetCo-Bipartite}
     \;
\EndIf \If{a positive set  with the smallest budget has  }
\Return False\;
\EndIf


\If{  OR }
\Return False\;
\Else {} \Return \textsc{Combine}( )
\EndIf
\EndIf
\end{algorithmic}
\caption{{\textsc{BudgetCo-Bipartite}} ()}
\label{alg:co-bipartite}
\end{algorithm}



\section{Polynomial Time Algorithm for Bipartite Permutation Graphs}\label{sec:poly-permutation}
A bipartite graph  is called permutation graph (proper interval bipartite graph) if there exists an ordering 
of the vertices in  such that the neighborhood of each vertex in  consists of consecutive vertices in . Moreover, for any two
vertices  if  then the last neighbor of  and the last neighbor of  are the same.
These bipartite graphs were exactly those bipartite graph for which  the  minimum cost homomorphism problem can be solvaled in polynomial time \cite{GHRY08}. 
They are also studied  in job scheduling problems \cite{KKRS13,MS12}. 


We refer to a set of consecutive vertices in such an ordering as an \textit{interval}. Figure
\ref{fig:2} is an example of a bipartite permutation
graph.

Note that the class of circle bipartite graphs , for which
obtaining the optimal budget is NP-complete, contains the class of
bipartite permutation graphs.

We obtain an ordering  for vertices in  by setting  if the first neighbor of
 is before the first neighbor of  in  as therwise . Let  and  be the orderings of  and 
respectively. If  and  are edges of  and  and  then . 
Such an ordering is called {\em min-max} ordering \cite{GHRY08}.

 Let  denote the interval of vertices 
. In the Algorithm \ref{alg:permutation} we compute the optimal budget for every . In order to compute  we assume that the optimal 
strategy starts with some sub-interval  of 
 and it processes . Then we are left with two disjoint instances  (this is because of property of the min-max ordering). We then argue
how to combine the optimal solutions of  and  and obtain an optimal strategy for . We need to consider every
possible prime interval  in range  and take the minimum budget.  



\begin{algorithm}[H]
\begin{algorithmic}[1]

\State \textbf{Input:} Bipartite permutation graph  with ordering  on vertices in 
i.e. \;
\State \textbf{Output:} Computing the budget for  and optimal strategy\;

\For {  to  }

\For {  to } 

 \State Let  
 
 \State Let  be the minimum number s.t. Optimal-Budget() is True. 
 
 \State Set  and let process of  be according to Optimal-Budget() 
 


   \State Let  ( is the set of vertices who have neighbors in both )   

    \State Let  be the minimum number s.t. Optimal-Budget() is True. 
    
    \State Set  and let process of  be according to Optimal-Budget()
    


 


   \State Let  ( is the set of vertices who have neighbors in both )

    \State Let  be the minimum number s.t. Optimal-Budget() is True. 
    
    \State Set  and let process of  be according to Optimal-Budget()
    


\EndFor

\EndFor 

\Statex 
\Function{Optimal-Budget}{, } 
\State \textbf{Input:} Bipartite permutation graph  with ordering  on vertices in 
\State \textbf{Output:} Process  with budget at most , otherwise "False".\;
\If{ and  OR  is a bipartite clique and }
\Return Process \;
\EndIf
\If {there is a positive minimal subset  with }
     process  and 
     
     \State \Return \textsc{BudgetPermutation} \;
\EndIf

\If{  for all prime }
\Return False\;
\EndIf
\If{a positive set  with the smallest budget has  }
\Return False\;
\EndIf

\For{ every prime interval  of  }
\State Let  and  where  and 

 \hspace{2mm}  is the first vertex of  and  is the last vertex of  in the ordering 

\State Let ,   be the set of vertices in  that have neighbors in 
\Comment{}\;

\State Set Flag=Combine().

 \If { Flag=True}

 \State Process of  be  together with process of  by Combine

 \State return

 \EndIf
\EndFor

 \EndFunction



\end{algorithmic}
\caption{{\textsc{BudgetPermutation}} ( )}
\label{alg:permutation}
\end{algorithm}



\begin{algorithm}[H]
\begin{algorithmic}[1]
\State \textbf{Input:} Optimal strategies for  and budget \;
\State \textbf{Output:} "True" if we can process  with budget at most , otherwise "False".\;

\State Let  be the first prime set in  and  be the first prime set in .

\If { OR  }
	\State Process  and 
       \State Call .


\Else{}  \State Process  and ,
         \State Call \textsc{Combine} .

\EndIf


\end{algorithmic}
\caption{{\textsc{Combine}} ( )}
\label{combine}
\end{algorithm}

\begin{tm}\label{thm:poly-permutation}
Algorithm \ref{alg:permutation} solves the \textsc{Bipartite Ordering Problem} on a bipartite permutation graph with 
 vertices in time . 
\end{tm}
\pf Let  be a bipartite permutation graph with an ordering on its vertices
as described above. We use a dynamic programming table which keeps track of the the subgraph  induced by  and 
 is an interval in . In the table we also keeps track of the subgraph  where  is a sub-interval of 
and  consists of vertices  together with vertices of  that are not initially in  but are initially in 
 where  for some sub-interval  of . This instances appears after removing  for some prime 
intervals  of . The number of such sub-instance is at most  for each interval  of . 

Now we show that Function Optimal-Budget correctly compute the budget for a given instance. 
The line 19 of the function is obvious. The correctness of lines 20-23 follow from Lemmas \ref{first-prime}, \ref{lm:minpos}, and 
Lemma \ref{correctness}.  



We show how to find an optimal ordering for  following the rules of Function Optimal-Budget.
First, we need to find all positive minimal sets. For bipartite permutation graphs, prime sets, the closure of a prime set (), 
and any positive minimal set is an interval.  

Note that computing  takes  and it is a straightforward procedure. Once  is removed from  there are two 
unique prime intervals (one on the right of  and one in the left of ) that could potentially become positive and it can be added into .  


When we consider processing a positive minimal set,  we not that according to Definition \ref{def:positive},
it does not have any proper positive subset. Therefore, it is the same as the case when we have
a bipartite permutation graph without any positive prime interval and no positive closure set
(Definition \ref{def:closure}).

Now suppose there is no positive prime interval. The optimal strategy starts with some prime interval  
and then it process the closure of that interval. After removing  and 
we end up with two instances  and  where they are disjoint.
Note that no vertex  is adjacent to any vertex in  as otherwise the vertices in  must be adjacent to 
 (because of the min property of the min-max ordering ) which are not adjacent. No vertex  is adjacent to any vertex  as otherwise
the vertices in  must be adjacent to  (because of the max property of min-max ordering) which are not adjacent. 

Now by similar argument as in the proof of Theorem \ref{thm:poly-TP-CB} we conclude that Combine
obtain an optimal strategy for , given the optimal strategy for  and .
Observe that in the algorithm we consider every possible interval  therefore we obtain an optimal strategy to compute .
For a prime set , computing the  takes . Combine algorithm takes  to obtain the strategy
for  (because at each steps it computes ,  for the primes intervals in ).




For each interval  of  we call the Function Optimal-Budget at most three times. 
In Function Optimal-Budget we call the Combine function at most  times (there are at most  prime intervals). Therefore the running time of
Function Optimal-Budget is  and it is at most . There are at most  intervals. 
Therefore the running time of Algorithm \ref{alg:permutation} is . The term  is because we should binary search to obtain the optimial value  
in lines 9,12. 



\qed



\section{General Strategy}\label{sec:general-strategy}
It may not always be the case that all positive sets can be identified
in polynomial time. But, if positive sets can be identified, the
following is a general strategy for processing an input bipartite graph 
and given budget .

1. If there exist positive sets in , process a positive minimal
set , set , update  to   and repeat step 1.

2. If no positive set exists, choose in some way the next prime
set  to process, set , update  to be  and go to step 1.

Note that each time a prime set  is processed, we end up processing
.  Even if we can identify the prime and positive sets, it
remains to determine in the second step the method for choosing the next
prime to process.  We address this issue and give the full algorithm and
proof for Theorem \ref{thm:main} in the next subsection.  Note that Lemma
\ref{lm:minpos} implies that without loss of generality we can assume that
when a prime set  is processed the remainder of  is processed
next, as it is stated in the next corollary.

\begin{cor}
  Let  be a bipartite graph that can be processed with budget
  at most  with an ordering that processes prime set  first. Then
  there is a strategy for  that processes  first and uses budget
  at most .
\end{cor}


\subsection{Algorithm and Correctness of Proof for Theorem \ref{thm:main}}\label{sec:main-pf}

In this section we give the algorithm and proof for Theorem \ref{thm:main}, that
we can solve the bipartite graph ordering problem for some classes of graphs. From the previous section it remains to determine how to choose
which prime set to process first when there are no positive sets that can be
processed.

\begin{dfn} \label{dfn:pre-order}
Let  be prime subsets. We say that  is {\em potentially after}  for current budget  if

\begin{enumerate}

 \item , or
\item
  
\end{enumerate}
\end{dfn}



Definition \ref{dfn:pre-order} is a first attempt at choosing which
prime set to process first. The idea is to consider whether it is
possible to process  before .  Item 2 in the definition states
that  could not be processed immediately after .  However, this
formula is not sufficient in general because we must consider
orderings that do not process  and  consecutively, and we must
take into account that for whatever ranking we define on the prime
sets the ranking may change as the algorithm processes prime sets.
For clarification we have singled out the case when  and  are
processed consecutively in the proof of correctness of the algorithm.

If two prime sets  and  are not processed consecutively by the
 strategy, we should adapt Item 2 of Definition
\ref{dfn:pre-order} to take into account all vertices that would be
processed in between by our algorithm.  We call this set of vertices
the ``Superset'' of  with respect to , defined precisely by the recursive
Definitions \ref{dfn:superset} and \ref{dfn:order}.




\begin{dfn} \label{dfn:superset}


Let  and  be two prime subsets. For current budget , the \emph{Superset of  with respect to , denoted as ,} is defined as follows.
 contains  and at each step a set  is added into  from  where  is first according to the lexicographical order of prime sets such that no prime set is before    according to the ordering in Definition \ref{dfn:order}.
We stop once  lies in .

\end{dfn}



\begin{dfn}\label{dfn:order}
For current budget , we say prime subset  is {\em after} prime subset  if
\begin{enumerate}
\item , or


\item  

 \end{enumerate}
\end{dfn}

Definition \ref{dfn:order} states that  is after  if it is too
large for the current budget (Item 1) or cannot be processed before
 using the ordering implied by Definitions \ref{dfn:superset} and
\ref{dfn:order} (Item 2).
Note that if  is processed right after  then Item 2 in Definition \ref{dfn:order} agrees with
Definition \ref{dfn:pre-order}. In the graph induced by  in Figure \ref{fig:2}, we have  with respect to any current budget  at least 12.

We point out that Definitions \ref{dfn:superset} and \ref{dfn:order} are
recursive, and a naive computation of the ranking would not be efficient.
We describe how to efficiently compute the ranking for the classes of graphs of Theorem \ref{thm:main} using
dynamic programming in Sections \ref{sec:poly-TP-CB} and \ref{sec:poly-permutation}. The main description of our general strategy is given in Algorithm \ref{fig:alg}.


\begin{algorithm}[H]
\begin{algorithmic}[1]
\State \textbf{Input:}  and budget \;
\State \textbf{Output:} "True" if we can process  with budget at most , "False" otherwise.\;
\If { and }\label{Alg-general-firstIF}
 \Return True\;
\EndIf \label{Alg-gnr-end-firstif}
\If{  for all prime } \label{Alg-general-secondIF}
\Return False\;
\EndIf \label{Alg-gnr-end-secondif}
\If {there is a positive minimal subset  with } \label{Alg-general-thirdIF}
     \Return \textbf{Budget} \;
\EndIf \label{Alg-gnr-end-thirdif}
\If{a positive set  with the smallest budget has  }  \label{Alg-general-fourthIF}
\Return False\;
\EndIf \label{Alg-gnr-end-fourthif}
\State Let  be the lexicographically first prime subset with no other prime set before it according to ordering in Definition \ref{dfn:order}.

\If {no such  exists} \label{Alg-general-fifthIF}
    \Return False
\Else {}
     \Return \textbf{Budget} \;
\EndIf \label{Alg-gnr-end-fifthif}
\end{algorithmic}
\caption{{\textbf Budget } ( , )}
\label{fig:alg}
\end{algorithm}

The algorithm determines whether . Note that the exact
optimal value can be obtained by using binary search, and since the
optimal value is somewhere between 0 and  the exact computation
is polynomial if the decision problem is polynomial.

Before considering the running time for the graph classes of Theorem \ref{thm:main} we
first demonstrate that the algorithm in Algorithm \ref{fig:alg} decides correctly,
though possibly in exponential time, for any instance .

\begin{lemma}\label{lm:optimal}
  For any  and bipartite graph , the Budget algorithm  (Algorithm \ref{fig:alg}) correctly
  decides if  or not.
\end{lemma}
\pf We show that if  then there exists an optimal solution  with
budget  in which subset  as described in the algorithm is processed
first. We use induction on the size of , meaning we assume that for smaller instances,
there is an optimal process that considers the prime subsets according to the rules of our algorithm.

Correctness of Lines 3 is clear and the correctness of line 4 follows from Lemma \ref{first-prime}.
The correctness of steps 5 follows from Lemma \ref{lm:minpos}. Suppose Line 6 were incorrect. Then
all positive subsets would have budget above . Let  be one such subset and yet if 
Line were incorrect there would be a way to process  with budget at most  in . In that case, we would process some negative set
 which somehow reduces the budget of processing ; this can
only be so if .  In this case the Lemma
\ref{correctness} states that 
is itself a positive set with budget at most , a contradiction to
the premise of step 6.


We are left to verify Lines 7-9, so we continue by assuming there are
no positive subsets. Let  be the first prime set according to Definition \ref{dfn:order}.
Suppose for the sake of contradiction that the optimal solution  processes
prime subset  before . In what follows we show that we can modify  and process  as the first prime set. Note that, since there is no positive subset at the beginning,  processes  after .\\




Suppose that by induction hypothesis (rules of our algorithm) the 
would place  first in . In this case 
is just , and in this case Definitions \ref{dfn:pre-order} and
\ref{dfn:order} coincide.


We show that we can modify  to process  first and then
 next while still using budget at most . Suppose this is not the
case. Now we have the following

\begin{itemize}


\item [(a)] 

\end{itemize}



The inequality (a) follows from the assumption that we cannot process  first and then immediately processing
. However, this is a contradiction to the fact that  is before  according to Definition \ref{dfn:order}.

We also note that since , we can also process
the entire  after processing . Therefore we can exchange processing  with  and follow the
 in the remaining. \\



We are left with the case that  is processed first by , and the rules
of the algorithm (second item in Definition \ref{dfn:order}) would process some prime subset  different from  next.
This would imply that there is some prime subset  that is considered before the last remaining part of  in .
By induction hypothesis we may assume that the  processes the prime subsets according to the second item in Definition \ref{dfn:order}.
These would imply  is in .  At some point  or the remaining part of  becomes the first set to process according to
the rules of the algorithm and this happens at the last step of the definition of  .
However, since there is no other prime subset before  according to Definition \ref{dfn:order} we have
. Therefore  we can process   first and next
 and then follow .

It remains to show that if  then there exists a prime subset 
that is the lexicographically first prime subset with no other
prime set before it according to the ordering in Definition \ref{dfn:order}.
Suppose there exists an ordering for  with budget at most
 as follows: .
By induction assume that the Budget Algorithm returns ``true'' for
instance  with
budget  and the output ordering is
. Therefore, by Definition
\ref{dfn:superset},  for
. Observe that  is not after any prime subset
by Definition \ref{dfn:order} which leads us to have  as a valid
``first'' prime subset in  for the algorithm.
\qed \\



A naive implementation of the algorithm would consider all possible
orderings of prime sets to determine the ordering in step 4 of the algorithm, and
in the worst-case an exponential number of sets may need to be considered to
identify the prime and positive minimal sets.  A careful analysis can be taken
to show that the running time of the algorithm in the general case is
exponential.  In the next two sections we show that for the graph classes
of Theorem \ref{thm:main} the running time is polynomial.







\section{Future Work and Open Problems} \label{sec:future}

We have defined a new scheduling or ordering problem that is
natural and can be used to model processes with precedence
constraints.  As with any optimization problem there are many avenues
of attack.  In this work we have focused on determining for which
classes of graphs the bipartite graph ordering problem can be solved in
polynomial time.  Our ultimate goal in this direction is a dichotomy
classification of polynomial cases and NP-complete cases.  The algorithm
in the proof of Theorem \ref{thm:main} finds the optimal budget for
all graphs , and the algorithm was shown to run in polynomial time
for the classes of graphs mentioned in Theorem \ref{thm:main}.  We pose the
question whether the algorithm can be the basis of a dichotomy theorem:
are there classes of graphs which can be solved in polynomial time but
for which our algorithm does not run in polynomial time?


As with all optimization problems the bipartite graph ordering problem can
also be studied from a number of other angles, including approximation
and hardness of approximation, fixed parameter algorithms, and faster
exponential-time algorithms.
A particular graph class to consider in
each of these areas is that of circle bipartite graphs, because these graphs are
of particular interest in the application to molecular folding \cite{GFWT08,MH98,TMRM09}.




\paragraph{\textbf Acknowledgments}
We would like to thank
Pavol Hell, Ladislav Stacho, Jozef Hale\u{s}, Cedric Chauve and Geoffrey Exoo for many useful
discussions.

\vspace{-3mm}

{\small \begin{thebibliography}{999}




\bibitem[1]{AMMS11} C. Amb\"uhl, M. Mastrolilli, N. Mutsanas, O. Svensson:
On the approximability of single-machine scheduling with precedence constraints. {\em Math. Oper. Res.} 36(4): 653--669 (2011).

\bibitem[2]{AMS07} C. Amb\"uhl, M. Mastrolilli, and O. Svensson.
Inapproximability results for sparsest cut, optimal linear arrangement, and precedence constrained scheduling.
In {\em Proceedings of FOCS} : 329--337 (2007).

\bibitem[3]{BFKKT} H. L.Bodlaender, F. V. Fomin, A. M.C.A. Koster, D. Kratsch and
D.M. Thilikos. A note on exact algorithms for vertex ordering problems on graphs.
\emph{Theory Comput. Syst} 50(3):420--432 (2012).

\bibitem[4]{CEM13} R. H. Chitnis, L. Egri, and D. Marx.
List H-coloring a graph by removing few vertices. In
{\emph Proceedings of ESA } 313--324 (2013).


\bibitem[5]{CS05} J. R. Correa, A. S. Schulz.
Single-machine scheduling with precedence constraints. {\em Math. Oper. Res.} 30(4):
1005--1021 (2005).

\bibitem[6]{EKLT12}
L. Egri, A. d Krokhin, B. Larose and D.Tess.
The Complexity of the list homomorphism problem for graphs.
\emph{Theory of Computing Systems}, 51(2):143--178 (2012).


\bibitem[7]{FHMS01}
C. Flamm, I. L. Hofacker, S. Maurer-Stroh, P. F. Stadler and M. Zehl,.
Design of multistable RNA molecules.
\emph{RNA} 7 (02), 254--265 (2001).



\bibitem[8]{GFWT08}
M. Geis, C. Flamm, M. T. Wolfinger, A. Tanzer, I. L. Hofacker, M. Middendorf, C. Mandl, P. F. Stadler and
C. Thurner.
Folding kinetics of large RNAs.
\emph{J. Mol. Biol}. 379(1), 160--173 (2008).

\bibitem[9]{GV97}
V. Giakoumakis, J.M. Vanherpe.
Bi-complement reducible graphs.
\emph{Adv. Appl. Math.} 18:389--402 (1997).

\bibitem[10]{GHRY08} G. Gutin, P. Hell, A. Rafiey and A. Yeo.
	A dichotomy for minimum cost graph homomorphisms.
	\emph{European J. Combin.} 29: 900 -- 911 (2008).



\bibitem[11]{KKRS13} K. Khodamoradi, R. Krishnamurti, A. Rafiey, G. Stamoulis.
PTAS for Ordered Instances of Resource Allocation Problems. \emph{Proceeding of   FSTTCS}  461--473 (2013).



\bibitem[12]{MTSC09}
J. Manuch, C. Thachuk, L. Stacho and A. Condon.
NP-completeness of the direct energy barrier problem without pseudoknots.
In \emph{Proceedings of the 15th Intl. Meeting on DNA Computing and
Molecular Programming (DNA15)}, 106--115 (2009).


\bibitem[13]{MS12}
M. Mastrolilli, and G. Stamoulis.
Restricted Max-Min Fair Allocations with Inclusion-Free
               Intervals.  COCOON 2012.


\bibitem[14]{MH98}
S. R. Morgan and P. G. Higgs.
Barrier heights between ground states in a model of RNA secondary structure.
\emph{J. Phys. A: Math. Gen.} 31(14), 3153 (1998).


\bibitem[15]{MMS04} R. H. M\"ohring, M. Skutella, F. Stork:
Scheduling with AND/OR precedence constraints. \emph{SIAM J. Comput.} 33(2): 393--415 (2004).


\bibitem[16]{MSW10} G. Muratore, U. M. Schwarz, and G. J. Woeginger. Parallel machine scheduling with nested
job assignment restrictions. \emph{Oper. Res. Lett.}, 38(1):47--50 (2010).


\bibitem[17]{SBS98} J.P.Spinrad, A.Brandst{\"{a}}dt, and L. Stewart.
Bipartite permutation graphs. \emph{Discrete Applied Mathematics }, 18 (3) : 279--292 (1987).


\bibitem[18]{TMRM09}
C. Thachuk, J. Manuch, A. Rafiey, L. Mathieson, L. Stacho and A. Condon.
An algorithm for the energy barrier problem without pseudoknots and
temporary arcs.
In {\em Pacific Symposium on Biocomputing}, 15:108--119 (2009).


\bibitem[19]{woginger1} G. J. Woeginger. On the approximability of average completion time
scheduling under precedence constraints. \emph{Discrete Applied Mathematics},
131(1):237--252 (2003).

\end{thebibliography}
}


\end{document}
