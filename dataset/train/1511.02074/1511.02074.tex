\documentclass{siamart190516}

\usepackage{amsmath,amsfonts}
\usepackage{xspace}

\headers{Dynamic Balanced Graph Partitioning}{C.~Avin, M.~Bienkowski, A.~Loukas, M.~Pacut, and S.~Schmid}

\title{Dynamic Balanced Graph Partitioning\thanks{A preliminary version of this paper appeared as 
``Online Balanced Repartitioning'' in the proceedings of the
30th International Symposium on DIStributed Computing (DISC 2016).
\funding{Research supported by the German-Israeli Foundation for Scientific Research
(GIF) Grant I-1245-407.6/2014, the Polish National Science Centre grants
2016/22/E/ST6/00499 and 2016/23/N/ST6/03412, and ERC Consolidator project AdjustNet grant agreement No.~864228.}}}

\author{
Chen~Avin\thanks{School of Electrical and Computer Engineering, Ben Gurion University of the Negev, Israel} \and
Marcin~Bienkowski\thanks{Institute of Computer Science, University of Wroclaw, Poland} \and
  Andreas~Loukas\thanks{EPFL, Switzerland} \and
  Maciej~Pacut\thanks{Faculty of Computer Science, University of Vienna, Austria} \and
  Stefan~Schmid\footnotemark[5]
}

\ifpdf
\hypersetup{
  pdftitle={Dynamic Balanced Graph Partitioning},
  pdfauthor={C.~Avin, M.~Bienkowski, A.~Loukas, M.~Pacut, and S.~Schmid}
}
\fi

\newcommand{\ONL}{\textsc{Onl}\xspace}
\newcommand{\ONLreq}{\textsc{Onl}^\textnormal{req}\xspace}
\newcommand{\ONLmig}{\textsc{Onl}^\textnormal{mig}\xspace}
\newcommand{\GREEDY}{\textsc{Greedy}\xspace}
\newcommand{\MGREEDY}{M^\textsc{GR}}
\newcommand{\MOPT}{M^\textsc{OPT}}
\newcommand{\OFF}{\textsc{Off}\xspace}
\newcommand{\OPT}{\textsc{Opt}\xspace}
\newcommand{\ALG}{\textsc{Alg}\xspace}
\newcommand{\CREP}{\textsc{Crep}\xspace}
\newcommand{\DET}{\textsc{Det}\xspace}
\newcommand{\CREPreq}{\CREP^\textnormal{req}}
\newcommand{\CREPmig}{\CREP^\textnormal{mig}}
\newcommand{\ovr}{\textsc{ovr}}
\newcommand{\T}{\mathcal{T}}
\newcommand{\eps}{\ensuremath{\epsilon}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\cut}{\textsc{cut}}
\newcommand{\eold}{e^\textrm{old}}
\newcommand{\enew}{e^\textrm{new}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\optmig}{\textsc{opt-mig}}
\newcommand{\spl}{\textsc{sp}}
\newcommand{\final}{\textsc{fin}}
\newcommand{\size}{\textsc{size}}
\newcommand{\comm}{\textsc{comm}}
\newcommand{\Phiinit}{\Phi^\textrm{S}}
\newcommand{\winit}{w^\textrm{S}}
\newcommand{\set}{\mathcal{S}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\F}{\mathcal{F}}




\begin{document}

\maketitle

\begin{abstract}
This paper initiates the study of the classic balanced graph partitioning
problem from an online perspective: Given an~arbitrary sequence of pairwise
communication requests between~~nodes, with patterns that may change over
time, the objective is~to~service these requests efficiently by partitioning
the nodes into~ clusters, each of size~, such that frequently
communicating nodes are located in the same cluster. The partitioning can be
updated dynamically by \emph{migrating} nodes between clusters. The goal is to
devise online algorithms which jointly minimize the amount of inter-cluster
communication and migration cost.

The problem features interesting connections to other well-known online
problems. For example, scenarios with~ generalize online paging, and
scenarios with~ constitute a~novel online variant of maximum matching. We
present several lower bounds and algorithms for settings both with and without
cluster-size augmentation. In particular, we prove that any deterministic
online algorithm has a competitive ratio of at least~, even with
\emph{significant} augmentation. Our main algorithmic contributions are
an~-competitive deterministic algorithm for the general setting
with constant augmentation, and a constant competitive algorithm for the
maximum matching variant.
\end{abstract}

\begin{keywords}
clustering, graph partitioning, competitive analysis, cloud computing
\end{keywords}

\begin{AMS}
68W01,   68W05,   68W40,   68Q25    \end{AMS}




\section{Introduction}

Graph partitioning problems, like minimum graph bisection or minimum balanced
cuts, are among the most fundamental problems in theoretical computer science.
They are intensively studied also due to their numerous practical
applications, e.g., in communication networks, parallel processing, data
mining and community discovery in social networks. Interestingly however, not
much is known today about how~to~\emph{dynamically} partition nodes that
interact or communicate in a~time-varying fashion.

This paper initiates the study of a natural model for \emph{online graph
partitioning}. We are given a~set of~ nodes with time-varying pairwise
communication patterns, which have to be partitioned into~~clusters of
equal size~. Intuitively, we would like to minimize inter-cluster
interactions by mapping frequently communicating nodes to the same cluster.
Since communication patterns change over time, partitions should be
readjusted dynamically, that is, the nodes should be \emph{repartitioned}, in
an online manner, by \emph{migrating} them between clusters. The objective is
to jointly minimize inter-cluster communication and repartitioning costs,
defined respectively as the number of communication requests ``served
remotely'' and the number of times nodes are migrated from one cluster to
another.

This fundamental online optimization problem has many applications. For
example, in the context of~cloud computing,  may represent virtual machines
or containers that are distributed across~ physical servers, each having
 cores: each server can host  virtual machines. We would like to
(dynamically) distribute the virtual machines across the servers, so that
datacenter traffic and migration costs are minimized.


\subsection{The Model}

Formally, the online \emph{Balanced RePartitioning} problem (BRP) is defined as
follows. There is a set of  nodes, initially distributed arbitrarily
across ~clusters, each of size~. We call two nodes~
\emph{collocated} if they are in the same cluster.

An input to the problem is a sequence of communication requests  , where pair  means that
the nodes  exchange a fixed amount of data. For succinctness of later descriptions,
we assume that a request  occurs at time . At any time~, an online algorithm needs to serve the~communication
request~. Right before serving the request, the online algorithm
can \emph{re}partition the nodes into new clusters. We assume that
a~communication request between two collocated nodes costs 0. The cost of a
communication request between two nodes located in different clusters is
normalized to~1, and the cost of migrating a node from one cluster to another
is~, where  is a parameter (an integer). For any
algorithm \ALG, we denote its total cost (consisting of communication plus
migration costs) on sequence  by .

The description of some algorithms (in particular the ones in \cref{sec:upper}
and \cref{sec:crep}) is more natural if they first serve a request and then
optionally migrate. Clearly, this modification can be implemented at no extra cost by
postponing the migration to the next step.

We are in the realm of competitive worst-case analysis and compare the
performance of an online algorithm to the performance of an optimal offline
algorithm. Formally, let~, resp.~, be the cost
incurred by an online algorithm \ONL, resp.~by an optimal offline
algorithm \OPT, for a given~. In contrast to \ONL, which learns the~requests one-by-one as
it serves them, \OPT has a complete knowledge of the entire request
sequence~ \emph{ahead of~time}. The goal is to design online repartitioning
algorithms that provide worst-case guarantees. In particular,  is said
to be \emph{-competitive} if there is a constant , such that for any
input sequence~ it holds that

Note that  cannot depend on input  but can depend on other
parameters of the problem, such as the number of nodes or the number of clusters.
The minimum  for which  is -competitive is called the 
\emph{competitive ratio} of . 

We consider two different settings:

\begin{description}

\item[Without augmentation:] The nodes fit perfectly into the clusters,
i.e.,~. Note that in this setting, due to cluster capacity
constraints, a node can never be migrated alone, but it must be \emph{swapped}
with another node at a cost of~. We also assume that when an
algorithm wants to migrate more than two nodes, this has to be done using
several swaps, each involving two nodes.

\item[With augmentation:] An online algorithm has access to additional space
in each cluster. We say that an algorithm is~-augmented if the size of
each cluster is~, whereas the total number of nodes
remains~. As usual in competitive analysis,
the augmented online algorithm is compared to the optimal offline algorithm
with cluster capacity~.
\end{description}

An online repartitioning algorithm has to cope with the following issues:

\begin{description}

\item[Serve remotely or migrate (``rent or buy'')?] For just a brief communication, it may not be worthwhile to collocate the nodes: the migration cost might
be too large in comparison to communication costs.

\item[Where to migrate, and what?]
If an algorithm decides to collocate nodes  and~, the question becomes
how. Should  be migrated to the cluster holding , ~to the one holding
, or should both nodes be migrated to a new cluster?

\item[Which nodes to evict?]
There may not exist sufficient space in the desired destination cluster. In
this case, the~algorithm needs to decide which nodes to ``evict'' (migrate to
other clusters), to free up space.

\end{description}


\subsection{Our Contributions}

This paper introduces the online Balanced RePartitioning problem (BRP),
a fundamental \emph{dynamic} variant of the classic graph clustering problem. 
We show that BRP features some interesting connections to other well-known
online graph problems. For , BRP can simulate the online paging problem,
and for , BRP is a~novel online version of maximum matching.
We consider deterministic algorithms and make the following technical
contributions:

\begin{description}

\item[Algorithms for General Variant:]
For the non-augmented variant, in \cref{sec:upper}, we first present a~simple
-competitive algorithm. Our main technical contribution
is an -competitive deterministic algorithm
 for a setting with -augmentation (\cref{sec:crep}).
We emphasize that this bound does not depend on~. This is interesting,
as in many application domains of this problem,  is small: for example, in
our motivating virtual machine collocation problem, a server typically hosts
only a small number of virtual machines (e.g., related to the constant number
of cores on the server).

\item[Algorithms for Online Rematching:]
For the special case of online rematching (, but arbitrary~), in
\cref{sec:k-two}, we prove that a variant of a greedy algorithm is
7-competitive. We also demonstrate a lower bound of 3 for any deterministic
algorithm.

\item[Lower Bounds:]
By a reduction to online paging, in \cref{sec:paging}, we show that
for two clusters, no deterministic algorithm can obtain a better bound than
. While this shows an~interesting link between BRP and paging, in
\cref{sec:lower-bounds}, we present a stronger bound. Namely, we
show that for  clusters, no deterministic algorithm can beat the
bound of  even with an~arbitrary amount of augmentation, as~long~as~the
algorithm cannot keep all nodes in a~single cluster. In contrast, online
paging is known to~become constant-competitive with constant
augmentation~\cite{SleTar85}.

\end{description}


\subsection{A Practical Motivation}

There are many applications to the dynamic graph clustering problem.
To give just one example, we consider server virtualization in
datacenters. Distributed cloud applications, including batch processing
applications such as MapReduce, streaming applications such as Apache Flink or
Apache Spark, and scale-out databases and key-value stores such as Cassandra,
generate a~significant amount of network traffic and a considerable fraction
of their runtime is due to network activity~\cite{MogPop12}. For example,
traces of jobs from a Facebook cluster reveal that network transfers on
average account for 33\% of the execution time~\cite{ChZMJS11}. In such
applications, it is desirable that frequently communicating virtual machines
are \emph{collocated}, i.e., mapped to the same physical server: 
communication across the network (i.e., inter-server communication) induces
network load and latency. However, migrating virtual machines between servers
also comes at a price: the state transfer is bandwidth intensive, and may even
lead to short service interruptions. Therefore the goal is to design online
algorithms that find a good trade-off between the inter-server communication
cost and the migration cost.




\section{Related Work}\label{sec:relwork}

The static offline version of our problem, i.e., a problem variant where
migration is not allowed, where all requests are known in advance, and where
the goal is to find best node assignment to  clusters, is known as the
-balanced graph partitioning problem. The problem is 
NP-complete, and cannot even be approximated within any finite factor unless P
= NP~\cite{AndRae06}. The static variant where  corresponds to a
maximum matching problem, which is polynomial-time solvable. The static
variant where  corresponds to the minimum bisection problem, which
is already NP-hard~\cite{GaJoSt76}. Its approximation was studied in a long
line of work~\cite{SarVaz95,ArKaKa99,FeKrNi00,FeiKra02,KraFei06,Raec08} and
the current best approximation ratio of  was given by
R{\"{a}}cke~\cite{Raec08}. The -approximation given by
Krauthgamer and Feige~\cite{KraFei06} can be extended to~general , but
the running time becomes exponential in~.

The inapproximability of the static variant for general values of 
motivated research on the bicriteria variant, which can be seen as the offline
counterpart of our cluster-size augmentation approach. Here, the~goal
is~to~develop -balanced graph partitioning, where the graph has
to be partitioned into  components of~size less than  and the cost of the cut is compared to the optimal (non-augmented)
solution where all components are of size . The variant where
 was considered in
\cite{LeMaTr90,SimTen97,EvNaRS00,EvNaRS99,KrNaSc09}. So far the best result is
an -approximation by Krauthgamer et
al.~\cite{KrNaSc09}, which builds on ideas from the -approximation algorithm for balanced cuts by Arora et al.~\cite{ArRaVa09}.
For smaller values of , i.e., when  with a fixed
, Andreev and R{\"{a}}cke gave an 
approximation~\cite{AndRae06}, which was later improved to  by
Feldmann and Foschini ~\cite{FelFos15}.

The BRP problem considered in this paper was not previously studied. However,
it bears some resemblance to the classic online problems; below we highlight
some of them.

Our model is related to online
paging~\cite{SleTar85,FKLMSY91,McGSle91,AcChNo00}, sometimes also referred to
as online caching, where requests for data items (nodes) arrive over time and
need to be served from a cache of finite capacity, and where the number of
cache misses must be minimized. Classic problem variants usually boil down to
finding a smart eviction strategy, such as Least Recently Used (LRU). In our
setting, requests can be served remotely (i.e., without fetching the
corresponding nodes to a single cluster). In this light, our model is more
reminiscent of caching models \emph{with
bypassing}~\cite{EpImLN11,EpImLN15,Irani02}. Nonetheless, we show that BRP is
capable of emulating online paging.

The BRP problem is an example of a non-uniform problem~\cite{KaMaMO94}: the
cost of changing the state is higher than the cost of serving a single
request. This requires finding a~good trade-off between serving requests
remotely (at a low but repeated communication cost) or migrating nodes into a
single cluster (entailing a potentially high one-time cost). Many
online problems exhibit this so called \emph{rent-or-buy} property, e.g., ski
rental problem~\cite{KaMaMO94,LoPaRa08}, relaxed metrical task
systems~\cite{BaChIn01}, file migration~\cite{BaChIn01,BiByMu17}, distributed
data management~\cite{BaFiRa95,AwBaFi93,AwBaFi98}, or rent-or-buy network
design~\cite{AwAzBa04,Umboh15,FeWiLe16}.

There are two major differences between BRP and the problems listed above.
First, these problems typically maintain some configuration of servers or
bought infrastructure and upon a new request (whose cost typically depends on
the distance to the infrastructure), decide about its reconfiguration (e.g.,
server movement or purchasing additional links). In contrast, in our model,
\emph{both} end-points of a communication request are subject to optimization.
Second, in the BRP problem a request reveals only very limited information
about the optimal configuration to serve it: There exist relatively long
sequences of requests that can be served with zero cost from a fixed
configuration. Not only can the set of such configurations be very large, but
such configurations may also differ significantly from each other.

Since the initial conference publication of this paper~\cite{disc16}, two
relaxations of the model were considered. First, Avin et al.~\cite{computing18}
studied a variant where requests are chosen randomly according to a probability
distribution fixed by an adversary. Under some additional assumptions, they gave
an algorithm which achieves logarithmic competitive ratio with high probability.
Second, Henzinger et al.~\cite{sigmetrics19learn} considered a~``learning''
variant, where requests correspond to edges of a graph that can be perfectly
partitioned (without inter-cluster edges). Note that for such setting, there
exists a static partitioning of zero cost, and thus the goal of an algorithm is
to ``learn'' such partitioning. The authors presented a distributed online
algorithm whose cost is asymptotically almost optimal, and show how to apply
this solution to a distributed union-find problem. 




\section{A Simple Upper Bound}
\label{sec:upper}

As a warm-up and to present the model, we start with a straightforward -competitive deterministic algorithm \DET. At any time, \DET
serves a request, adjusts its internal structures (defined below)
accordingly and then possibly migrates some nodes. \DET operates in phases, and each
phase is analyzed separately. The first phase starts with the first request.

In a single phase, \DET maintains a helper structure: a complete graph on all
 nodes, with an edge present between each pair of nodes. We say
that a communication request is \emph{paid} (by \DET) if it occurs between
nodes from different clusters, and thus entails a cost for \DET. For each edge
between nodes  and , we define its weight~ to be the number of
paid communication requests between  and~ since the beginning of~the~current phase.

Whenever an edge weight reaches , it is called \emph{saturated}. If a
request causes the corresponding edge to~become saturated,
\DET computes a new placement of nodes (potentially for all of them), so that all
saturated edges are inside clusters (there is only one new saturated edge). If
this is not possible, node positions are not changed, the~current phase ends
with the current request, and a new phase begins with the next request. Note
that all edge weights are reset to zero at the beginning of a phase.


\begin{theorem}
\DET is -competitive.
\end{theorem}

\begin{proof}
We bound the costs of \DET and \OPT in a single phase. First, observe that
whenever an~edge weight reaches , its endpoint nodes will be collocated 
until the end of the phase, and therefore its weight is not
incremented anymore. Hence the weight of any edge is at most .

Second, observe that the graph induced by saturated edges always constitutes 
a~forest. Suppose that, at a time ,
two nodes  and~, which are not
connected by a saturated edge, become connected by a path of saturated edges.
From that time onward, \DET stores them in a single cluster. Hence, the
weight~ cannot increase at subsequent time points, and  may
not become saturated. The forest property implies that the number of saturated
edges is smaller than .

The two observations above allow us to bound the cost of \DET in a single
phase. The number of reorganizations is at most the number of saturated edges,
i.e., at most~. As the cost associated with a single
reorganization is , the total cost of all node
migrations in a single phase is at most .
The communication cost itself is equal to the total weight of all edges, and
by the first observation, it is at most . Hence, for any phase  (also
for the last one), it holds that .

Now we lower-bound the cost of \OPT on any phase  but the last one. If \OPT
performs a node swap in , it pays . Otherwise its assignment of
nodes to clusters is fixed throughout . Recall that at the end of , \DET
failed to reorganize the nodes. This means that for any static mapping of the
nodes to clusters (in particular the one chosen by \OPT), there is a
saturated inter-cluster edge. The communication cost over such an~edge incurred
by \OPT is at least  (it can be also strictly greater than~ as
the edge weight only counts the communication requests paid by \DET).

Therefore, the -to- cost ratio in any phase but the last one is at
most  and the cost of \DET on the last phase is at
most . Hence,
 for any input .
\end{proof}




\section{Algorithm {\sc Crep}}
\label{sec:crep}

In this section, we present the main result of this paper, a
\emph{Component-based REPartitioning algorithm (\CREP)} which achieves a
competitive ratio of  with augmentation
, for any~ (i.e., the augmented cluster
is of size at least ). For technical convenience, we assume that 
. This assumption is without loss of generality: if the augmentation 
is , \CREP~simply uses each cluster only up to capacity .

\CREP maintains a similar graph structure as the
simple deterministic -competitive algorithm \DET from the
previous section, i.e., it keeps counters denoting how many times it paid for a
communication between two nodes. Similarly, at any time~,
\CREP serves the current request, adjusts its internal structures, and then
possibly migrates nodes. Unlike \DET, however, the execution of \CREP is
\emph{not} partitioned into global phases: the reset of counters to zero can
occur at different times.


\subsection{Algorithm Definition}

We describe the construction of \CREP in two stages. The first stage uses
an~intermediate concept of \emph{communication components}, which are groups of at
most  nodes. In the second stage, we show how components are assigned to
clusters, so that all nodes from any single component are always stored in a
single cluster.


\subsubsection{Stage 1: Maintaining Components}

Roughly speaking, nodes are grouped into components if they communicated a lot
recently. At the very beginning, each node is in a singleton component. Once
the cumulative communication cost between nodes distributed across 
components exceeds ,  merges them into a~single
component. If a resulting component size exceeds , it becomes split
into singleton components.

More precisely, the algorithm maintains a time-varying \emph{partition of all
nodes into components}. As a helper structure, \CREP keeps a complete graph on
all  nodes, with an edge present between each pair of nodes. For
each edge between nodes  and~, \CREP maintains its weight . We
say that a communication request is \emph{paid} (by \CREP) if it occurs
between nodes from different clusters, and thus entails a~cost for \CREP. If
 and  belong to the same component, then . Otherwise,
 is equal to the number of paid communication requests between 
and~ since the last time when they were placed in \emph{different components} 
by \CREP. It is worth emphasizing that during an~execution of \CREP, it is
possible that  even when  and  belong to~the~same cluster.

For any subset of components  (called
\emph{component-set}), by~ we denote the total weight of all edges
between nodes of . Note that positive weight edges occur only between
different components of~. We call a component-set \emph{trivial} if it
contains only one component;  in this case.

Initially, all components are singleton components and all edge weights are
zero. At time , upon a~communication request between a pair of nodes 
and , if  and  lie in the same cluster, the corresponding cost is~
and \CREP does nothing. Otherwise, the cost entailed to \CREP is , nodes
 and  lie in different clusters (and hence also in different
components), and the following updates of weights and components are
performed.

\begin{enumerate}

\item \emph{Weight increment.} Weight  is incremented.

\item \emph{Merge actions.} We say that a non-trivial component-set  is \emph{mergeable} if . If a mergeable component-set  exists, then all its
components are merged into a single one. If multiple mergeable component-sets
exist, \CREP picks the one with maximum number of components, breaking ties
arbitrarily. Weights of all intra- edges are reset to zero, and thus
intra-component edge weights are always zero. A mergeable set  induces
a~sequence of  \emph{merge actions}:
\CREP iteratively replaces two arbitrary components 
from~ by a component being their union (this constitutes a single merge
action).

\item \emph{Split action.} If the final component resulting from merge action(s)
has more than  nodes, it is split into singleton
components. Note that weights of edges between these singleton components are
all zero as they have been reset by the preceding merge actions.

\end{enumerate}

We say that merge actions are \emph{real} if they are not followed
by a split action (at the same time point) and \emph{artificial} otherwise. 



\subsubsection{Stage 2: Assigning Components to Clusters}

At time , \CREP processes a communication request and recomputes components
as described in the first stage. Recall that we require that nodes of a single
component are always stored in a~single cluster. To maintain this property for
artificial merge actions, no actual migration is necessary. The property may
however be violated by real merge actions. Hence, in the following, we assume
that in the first stage \CREP found a mergeable component set  that triggers  merge actions not 
followed by a split action.

\CREP consecutively processes each real merge action by migrating some nodes.
We describe this process for a single real merge action involving two
components  and . As a split action was not executed, , where  denotes the number of component  nodes.
Without loss of generality, .

We may assume that  and  are in different clusters as otherwise
\CREP does nothing. If the cluster containing  has  free space,
then  is migrated to this cluster. Otherwise, \CREP finds a cluster that
has at~most  nodes, and moves both  and  there. We call the
corresponding actions \emph{component migrations}. By an~averaging argument,
there always exists a cluster that has at most  nodes, and hence, with
-augmentation, component migrations are always feasible.


\subsection{Analysis: Structural Properties}

We start with a structural property of components and edge weights.
The property states that immediately after \CREP merges (and
possibly splits) a component-set, no other component-set is~mergeable. This
property holds independently of the actual placement of components in
particular clusters.

\begin{lemma}
\label{lem:wS_bound}
At any time , after \CREP performs all its actions,
 for any non-trivial component-set .
\end{lemma}

\begin{proof}
We prove the lemma by an induction on steps. Clearly, the lemma holds before an
input sequence starts as then  for any non-trivial set . We assume that it holds at time 
and show it for time .

At time , only a single weight, say , may be incremented. If after
the increment, \CREP does not merge any component, then clearly  for any non-trivial set . Otherwise, at time , \CREP
merges a~component-set  into a new component , and then possibly
splits  into singleton components. We show that
the lemma statement holds then for any non-trivial component-set . We
consider three cases.

\begin{enumerate}

\item Component-sets  and  do not share any common node. Then,  and
 consist only of components that were present already right before time~
and they are all disjoint. The edge~ involved in~communication at time
 is contained in~, and hence does not contribute to the weight of
. By the inductive assumption, the inequality 
 held right
before time . As  is not affected by \CREP's actions at step , the
inequality holds also right after time .

\item \CREP does not split  and . Let . Let  denote the total weight of all edges with one endpoint
in  and another in~. Recall that
\CREP always merges a~mergeable component-set with maximum number of components. 
As \CREP merged component-set~ and did not merge
(larger) component-set ,  was mergeable (), while  was not, i.e., . Therefore,  right after weight  is incremented at time~. Observe
that when component-set  is merged and all intra- edges have their weights 
reset to zero, neither  nor  is affected.
Therefore after \CREP merges  into , .

\item \CREP splits  into singleton components  
and some of these components belong to~set . This time, we define  to be
the subset of  not containing these components ( might be also an empty set). In~the
same way as in the previous case, we may show that  after \CREP performs all its operations at time . Hence, at this
time .
The last inequality follows as  has strictly more components than .
\qed
\end{enumerate}
\end{proof}

Since only one request is given at a time, and since all weights and 
are integers, \cref{lem:wS_bound} immediately implies the following
result.

\begin{corollary}
\label{cor:mergeable_sets} Fix any time  and consider weights right after
they are updated by \CREP, but before \CREP performs merge actions. Then,
 for any component-set . In particular,
 for a mergeable component-set~.
\end{corollary}


\subsection{Analysis: Overview}

In the remaining part of the analysis, we fix an~input sequence  and
consider a set  of all components that are split by \CREP, i.e.,
components that were created by merge actions, but because of their size they
were immediately split into singleton components. Our goal is to compare both
the cost of \OPT and \CREP to . 
Below, we provide the main intuitions for our approach.

For each component , we may track the history of how it was
created. This history corresponds to a tree  whose root is , the leaves are the singleton components containing nodes of , and the internal nodes correspond
to components that are created by merging their children. Note that for any
two sets in  their trees contain disjoint subsets of components.
Hence, for any , we want to relate the costs of \OPT and
\CREP due to processing, 
to the requests related to the components of . (Some
components may not belong to any tree, but the related cost can be universally
bounded by a constant independent of input .)

In \cref{sec:opt_lower}, we lower-bound the cost of \OPT. Assume first that \OPT
does not migrate nodes. Fix any component . As its size is
greater than , it spans  clusters in the solution of \OPT. Note
that \cref{cor:mergeable_sets} lower-bounds the number of requests between
siblings in . Then, for any assignment of nodes of  to 
the clusters,  requests are between clusters.
Additionally, if \OPT migrates nodes, then the amount of
request-related cost that \OPT saves, is dominated by the migration cost. In total,
the cost of \OPT related to~ is at least .

In \cref{sec:crep_upper} and \cref{sec:crep_ratio}, we upper-bound the cost of
\CREP. Its request cost is asymptotically dominated by its migration cost, and
hence it is sufficient to bound the latter. If \CREP was always able to migrate
the smaller component to the cluster holding the larger component, then the
total migration cost related to components from  could be bounded by
. (This bound is easy to observe when
 is a fully balanced binary tree and all merged components are of equal
size.) Unfortunately, \CREP may sometimes need to migrate both components. 
However, if such migrations are expensive, then the
distribution of nodes in clusters becomes significantly more even. Consequently, 
the cost of expensive migrations can be charged to the cost of other migrations,
at the expense of an~extra  factor in the cost.
In total, the (amortized) cost of \CREP related to  is at most
.

Finally, comparing bounds on \CREP and \OPT yields the desired bound on the
competitive ratio.



\subsection{Analysis: Lower Bound on OPT}
\label{sec:opt_lower}

In our analysis, we conceptually
replace any swap of two nodes performed by \OPT into two migrations of~the~corresponding nodes.

For any component  maintained by \CREP, let  be the time of its
creation. A~non-singleton component~ is created at  by the merge
of a component-set, henceforth denoted by~. For a singleton component,
 is the time when the component that previously contained the sole
node of  was split;  if  existed at the beginning of
input~. We use time  as an artificial time point that occurred
before an actual input sequence.

For a non-singleton component , we 
define  as the set of the following (node, time) pairs:

Intuitively,  tracks the history of all nodes of  from the time 
(exclusively) they started belonging to some previous component , until the time 
(inclusively) they become members of . Note that for any two components 
, sets~ and  are disjoint.
The union of all  (over all components ) 
cover all possible node-time pairs (except for time zero). 

For a given component , we say that a communication request between nodes
 and  at time~ \emph{is contained} in  if both 
and . Note that only the requests contained in~
could contribute towards later creation of~ by \CREP. In fact, by
\cref{cor:mergeable_sets}, the number of these requests that
entailed an~actual cost to~\CREP is exactly .

We say that a migration of node  performed by \OPT at time  \emph{is
contained} in~ if . For any component , we define
 as the cost incurred by \OPT due to requests contained in~, 
plus the cost of~\OPT migrations contained in~. The total cost of \OPT
can then be lower-bounded by the sum of  over all components .
(The cost of \OPT can be larger as  does not account for 
communication requests not contained in  for any component~.)

\begin{lemma}
\label{lem:merge_action_cut}
Fix any component  and partition  into a set of  disjoint
component-sets . The number of communication requests
in  that are between sets  is at least .
\end{lemma}

\begin{proof}
Let  be the weight measured right after its increment at time .
Observe that the number of all communication requests from  that were
between sets  and that \emph{were paid} by \CREP is . It suffices to show that this amount is at least . By \cref{cor:mergeable_sets},  and . Therefore, .
\end{proof}

For any component  maintained by \CREP, let  denote the set of clusters
containing nodes of  in the solution of \OPT after \OPT performs its
migrations (if any) at time~. In particular, if , then
 consists of only one cluster that contained the sole node of  
at the beginning of an input sequence.

\begin{lemma}
\label{lem:opt_recursive_bound}
For any non-trivial component , it holds that .
\end{lemma}

\begin{proof}
Fix a component  and any node . Let  be the
number of \OPT migrations of~node  at times . Furthermore, let  be the set of clusters that
contained  at some moment of a~time  (in the solution of \OPT). We extend these notions to components:
 and .
Observe that .
We say that  are the clusters that were \emph{touched} by component  
(in the solution of \OPT).

By \cref{cor:mergeable_sets}, the number of communication requests between
components of~ is . However, 
includes the cost only due to these requests that are between different clusters.
Hence, to lower-bound , we aggregate components of~ into
component-sets called \emph{bundles}, so that any two bundles have their nodes
always in disjoint clusters. This way, any communication between nodes from
different bundles incurs a cost to \OPT.

The bundles with the desired property can be created by a natural iterative 
process. We start from  bundles, each containing just a single 
component from~. Then, we iterate over all clusters touched 
by any component of , i.e., over all clusters from .
For each such cluster , let  be the set 
of all components of  that touched . We then aggregate all bundles 
containing any component from  into a single bundle.

On the basis of this construction, we may lower-bound the number of 
bundles. Initially, we have  bundles. When we process a cluster , we aggregate at most  bundles, and thus
the total number of bundles drops at most by . Therefore, the final number of bundles 
is 

where the second inequality follows as .

By \cref{lem:merge_action_cut}, the number of communication requests in
 that are between different bundles is at least ,
and each of these requests is paid by \OPT.
Additionally,  involves  node migrations in , and therefore .
\end{proof}



\begin{lemma}
\label{lem:opt_lower_bound}
For any input , .
\end{lemma}

\begin{proof}
Fix any component . Recall that  is a tree
describing how  was created: the leaves of  are singleton
components containing nodes of , the root is  itself, and each internal
node corresponds to a~component created at a~specific time, by merging its
children.

We now sum  over all components  from , including 
the root  and the leaves . The~lower bound given 
by \cref{lem:opt_recursive_bound} sums telescopically, i.e.,

where the equality follows as any  is a singleton component,
and therefore . As  has  nodes, it has to span at least
 clusters of \OPT, and therefore , where the second inequality follows because  and
thus .

The proof is concluded by observing that, for any two components 
and~ from~, the corresponding trees~ and  do not share common
components, and therefore .
\end{proof}


\subsection{Analysis: Upper Bound on CREP}
\label{sec:crep_upper}

To bound the cost of \CREP, we fix any input  and introduce the following 
notions. Let~ be the sequence of merge actions 
(real and artificial ones) performed by \CREP. 
For any real merge action , by
 we denote the size of the smaller component that was
merged. For an~artificial merge action, we set .

Let  be the set of all components that exist when \CREP finishes
sequence~. Note that  is the total weight of all
edges after processing . We split 
 into two parts: the cost of serving requests, , 
and the cost of node migrations, . 

\begin{lemma}
\label{lem:crep_req}
For any input , .
\end{lemma}

\begin{proof}
The proof follows by an induction on all requests of . Whenever \CREP
pays for the communication request, the corresponding edge weight is incremented
and both sides increase by . At a time when  components are merged, 
merge actions are executed and, by \cref{cor:mergeable_sets}, the sum of all
edge weights decreases exactly by . Then, the value of both
sides remain unchanged.
\end{proof}

\begin{lemma}
\label{lem:crep_mig}
For any input , with -augmentation, 
.
\end{lemma}

\begin{proof}
If  has more than  nodes in cluster  (for ), then we call the excess  the \emph{overflow} of ;
otherwise, the overflow of  is zero. We denote the overflow of cluster
 measured right after processing sequence~ by .
It is sufficient to show the following relation for any sequence :

As the second summand of \eqref{eq:crep_migrations} is always non-negative,
\eqref{eq:crep_migrations} will imply the lemma. 
In other words, the lemma will be shown using amortized analysis, where
the amount  serves 
as a potential function.

The proof of \eqref{eq:crep_migrations} follows by an induction on all
requests in . Clearly, \eqref{eq:crep_migrations} holds trivially at the
beginning, as there are no overflows, and thus both sides of
\eqref{eq:crep_migrations} are zero. Assume that \eqref{eq:crep_migrations}
holds for a~sequence  and we show it for sequence ,
where  is some request.

We may focus on a request  which triggers the migration of
component(s), as otherwise
\eqref{eq:crep_migrations} holds trivially. Such a migration is triggered by a
real merge action  of two components  and . We assume that , and hence . Note that ,
as otherwise the resulting component would be split and no migration would
be performed.

Let  and  denote the cluster that held components  and ,
respectively, and  be the destination cluster for  and  (it is
possible that ). For any cluster~, we denote the change in 
its overflow by . 
It suffices to show that the
change of the left hand side of \eqref{eq:crep_migrations} is at most
the~increase of its right hand side, i.e.,

For the proof, we consider three cases.

\begin{enumerate}
\item 
 had at least  empty slots. In this case, \CREP simply migrates
 to  paying . Then, ,
, , and thus \eqref{eq:crep_mig_inc}
follows.

\item 
 had less than  empty slots and .
\CREP migrates both  and  to~component  and the incurred cost is 
. 
It remains to show that the second summand of \eqref{eq:crep_mig_inc} is~at~most . 
Clearly,  and . 
Furthermore, the number of 
nodes in  was at~most~ before the migration by the definition of \CREP,
and thus is at~most  after the migration.
This implies that .

\item 
 had less than  empty slots and .
As in the previous case, \CREP migrates  and  to~component , 
paying .
This time,  can be much larger than the right hand side 
of~\eqref{eq:crep_mig_inc}, and thus we resort to showing that 
the second summand~of~\eqref{eq:crep_mig_inc} is at most .

As in the previous case,  and . 
Observe that .
As the migration of  to  was not possible, the initial number
of nodes in  was greater than ,
i.e., . 
As component  was migrated out of , the number of overflow nodes in  changes by

In the inequality above, we used .
Therefore, the second summand of~\eqref{eq:crep_mig_inc} is at most 
 as desired.
\end{enumerate}
\end{proof}



\subsection{Analysis: Competitive Ratio}
\label{sec:crep_ratio}

In the previous two subsections, we related  to the total
size~of components that are split by \CREP
(cf.~\cref{lem:opt_lower_bound}) and  to , where the latter amount is related to the merging
actions performed by \CREP (cf.~\cref{lem:crep_mig}). Now we link
these two amounts. Note that each split action corresponds to preceding
merge actions that led to the creation of the split component.

\begin{lemma}
\label{lem:bounding_merges}
For any input , it holds that 
,
where all logarithms are binary.
\end{lemma}

\begin{proof}
We prove the lemma by an induction on all requests of . At the very
beginning, both sides of the lemma inequality are zero, and hence the induction
basis holds trivially. We assume that the lemma inequality is preserved for a
sequence  and we show it for sequence , where 
is an arbitrary request. We may assume that  triggers some merge actions,
otherwise the claim follows trivially.

First, assume  triggered a sequence of real merge actions. We show that the
lemma inequality is preserved after processing each merge action. Consider a
merge action and let  and  be the components that are merged, with
sizes  and , where  without loss of generality.
Due to the merge action, the right hand side of the lemma inequality increases
by

As~the~left hand side of the inequality changes exactly by , the inductive
hypothesis holds.

Second, assume  triggered a sequence of artificial merge actions (i.e., followed by a
split action) and let  denote components that were
merged to create a component  that was immediately split. Then, the right
hand side of the lemma inequality changes by .
As~the~left hand side of the lemma inequality is unaffected by artificial
merge actions, the inductive hypothesis follows also in this case.
\end{proof}


\begin{theorem}
With augmentation at least , \CREP is~-competitive.
\end{theorem}

\begin{proof}
Fix any input sequence . 
By \cref{lem:crep_req} and \cref{lem:crep_mig}, 


Regarding a bound for , we observe the following. First, if \CREP
executes artificial merge actions, then they are immediately followed by a
split action of the resulting component . The number of artificial merge
actions is clearly at most , and thus the total number of all
artificial actions in  is at most .
Second, if  executes a real merge action , then
. Combining these two bounds yields . We use this inequality 
and later apply \cref{lem:bounding_merges} to~bound  obtaining

By \cref{lem:opt_lower_bound}, . This yields

To bound , observe that the component-set 
contains at most  components, and hence
by~\cref{lem:wS_bound}, . Furthermore, the maximum of  is achieved when all nodes in a specific cluster constitute a single
component. Thus, .
In total, , 
i.e., it can be upper-bounded by a constant independent of input sequence ,
which concludes the proof.
\end{proof}





\section{Online Rematching}
\label{sec:k-two}

Let us now consider the special case where clusters are of size two (,
arbitrary~). This can be viewed as an online maximal (re)matching problem:
clusters of size two contain (``match'') exactly one pair of nodes, and
maximizing pairwise communication within each cluster is equivalent to
minimizing inter-cluster communication. 


\subsection{Greedy Algorithm}

We define a natural greedy online algorithm~, parameterized by a real
positive number . Similarly to our other algorithms,
\GREEDY  maintains an edge weight for each pair of nodes. 
The weights of all edges are initially zero. Weights of intra-cluster edges
are always zero and weights of inter-cluster edges are related to the number
of paid communication requests between edge endpoints. 

When facing an inter-cluster request between nodes 
and~,  increments the weight , where . Let 
and  be the nodes collocated with  and~, respectively. If after the
weight increase, it holds that ,  performs a swap: it places  and  in one
cluster and  and~ in another; afterwards, it resets the weights of
edges  and  to 0. Finally, \GREEDY pays for the request
between  and . Note that if the request triggered a migration, then
\GREEDY does not pay its communication cost.


\subsection{Analysis}

We use  to denote the set of all edges.
Let  () denote the set of all edges , such 
that  and  are collocated by \GREEDY (\OPT). 
Note that  and  are perfect matchings on the set of all nodes.

To estimate the total cost of \GREEDY, we use amortized analysis with 
an appropriately defined potential function. First, 
we associate the following edge-potential with any edge :

where  is a constant that will be defined later. 

The union of  and  constitutes a set of alternating cycles:
an alternating cycle of length~ (for some ) consists of 
nodes,  edges from  and ~edges from , interleaved. The
case  is~degenerate: such a cycle consists of a single edge from , but we still count it as a cycle of length . 
It turns out that the number of these alternating cycles is a good measure of 
similarity between matchings of \GREEDY and \OPT (when these matchings are 
equal, the number of cycles is maximized). We define the
cycle-potential as

where  is the number of all alternating cycles and  is a constant that will
be defined later.

To simplify the analysis, we slightly modify the way weights are increased by
\GREEDY. The modification is~applied only when the weight increment triggers 
a~node migration. Recall that this happens when there is an inter-cluster
request between nodes  and . The corresponding weight  is then
increased by . After the~increase, it holds that . (Nodes  and  are those collocated with  and ,
respectively.) Instead, we increase  possibly by a~smaller amount, so
that  becomes \emph{equal} to . This
modification allows for a more streamlined analysis and is local: before and
after the modification, \GREEDY performs a migration and right after that, 
it resets weight  to zero.

We split the processing of a communication request  into three stages. In
the first stage, \OPT performs an~arbitrary number of migrations. In the
second stage, the weight  is increased accordingly and both \OPT and
\GREEDY serve the request. It is possible that the weight increase triggers a
node swap of \GREEDY, in which case its serving cost is zero. Finally, in the
third stage, \GREEDY may perform a node swap.

We show that for an appropriate choice of ,  and , for all
three stages described above the following inequality holds:

Here,  and  denote the increases of \GREEDY's and
\OPT's cost, respectively.  and  are the changes
of the potentials  and . The 7-competitiveness then immediately
follows from summing \eqref{eq:rematch_bound} and bounding the initial and
final values of the potentials. 

\begin{lemma}
\label{lem:opt_swap}
If , then \eqref{eq:rematch_bound}
holds for the first stage.
\end{lemma}

\begin{proof}
We consider any node swap performed by \OPT. Clearly, for such an event
 and . The number of cycles
decreases at most by one, and thus .

We now upper-bound the change in the edge-potentials. Let  and
 be the edges that were removed from  by the swap and let
 and  be the edges added to . For any ,  as the initial value of
 is at least  and the final value of  is at
most . Similarly,  as the
initial value of  is at least  and the final value
of  is at most .

Summing up,  as the weight of each edge
is at most . By combining the bounds above and using the
lemma assumption, we obtain .
\end{proof}


\begin{lemma}
\label{lem:rematch_req}
If , then \eqref{eq:rematch_bound} holds for the second stage.
\end{lemma}

\begin{proof}
In this stage, both \GREEDY and \OPT serve a communication request between
nodes  and . Let . As neither \GREEDY nor \OPT migrates any
nodes in this stage, the structure of alternating cycles remains
unchanged, i.e., . Furthermore, only edge~ may change its
weight, and therefore, among all edges, only the edge-potential of  may
change. We consider two cases.
\begin{enumerate}

\item If , then  and . As
 is unchanged, , and therefore 
. 

\item If , then let  denote the increase 
of the weight of edge~. Note that : 
either no migration is triggered and 
or a migration is triggered and then \GREEDY does not pay for the request.

If , then  and .
Thus, . Otherwise, 
, in which case 
. Furthermore, ,
and thus .
\end{enumerate}

Therefore, in the second stage, ,
which implies \eqref{eq:rematch_bound} as we assumed .
\end{proof}


\begin{lemma}
\label{lem:greedy_swap}
If , 
then  \eqref{eq:rematch_bound} holds for the third stage.
\end{lemma}



\begin{proof}
In the third stage (if it is present),  performs a swap. Clearly, for
such an event  and . 

There are four edges involved in a swap: let  and  be the
edges that were in  before the swap and let  and  be
the new edges in  after the swap. Note that 
before and after the swap. By the definition of \GREEDY and our modification
of weight updates,  before the swap, and after the swap these weights are reset to
zero.

For any edge , let  and  denote the weight and the
edge-potential of~ right before the swap. By~the~bounds above, , and hence to show
\eqref{eq:rematch_bound} it suffices to show that the latter amount is at most
. We consider three cases.

\begin{figure}
\centering
\includegraphics[width=0.95\textwidth]{fig_rematch}
\caption{Three cases in the analysis of the third stage (a swap performed by
\GREEDY). Solid edges denote edges that were removed from  because
of the swap, dashed ones denote the ones that were added to . Dotted
paths denote the remaining parts of the involved alternating cycle(s).}
\label{fig:rematch}
\end{figure}

\begin{enumerate}

\item
Assume that edges  and  were in different alternating
cycles before the swap, see \cref{fig:rematch}a. Then the number
of~alternating cycles decreases by one, and hence . Let  be the cycle that contained edge~. Node  is adjacent
to an edge from  that belongs to . (It is possible that this edge is
; this occurs in the degenerate case when  is of length~.) As
 is a matching, . Analogously, . Therefore, . Using the lemma assumption,
.

\item
Assume that edges  and  belonged to the same cycle and
it contained the nodes in the order ,
see~\cref{fig:rematch}b. In this case, it holds that 
, since 
the number of alternating cycles is unaffected by the swap. By similar
reasoning as in the previous case, neither  nor  belong to
, and thus again, . In this case, .

\item 
Assume that edges  and  belonged to the same cycle and
it contained the nodes in the order ,
see~\cref{fig:rematch}c. When the swap is performed, the number of
alternating cycles decreases, and thus . Unlike
the previous cases, here it is possible that  belonged to .
(This happens when  and  were adjacent on the alternating cycle.)
Similarly, it is possible that . 
But even in such a case, we may lower-bound the initial values of the
corresponding edge-potentials: . Using the lemma
assumption, .
\end{enumerate}

\end{proof}




\begin{theorem}
\label{thm:rematching}
For ,  is -competitive.
\end{theorem}

\begin{proof}
We choose  and . The chosen values of ,  and 
satisfy the conditions of \cref{lem:opt_swap}, \cref{lem:rematch_req},
and \cref{lem:greedy_swap}. Summing these
inequalities over all stages occurring while serving an input sequence~
yields

where  and  denote the final
values of the potentials and  and
 their initial values. We observe that all the
potentials occurring in the inequality above are lower-bounded and
upper-bounded by values that are independent of the input sequence .
That is,  (as the number of~alternating cycles is at most ) and
 (as all edge weights are always 
at most ). The number of edges is exactly , and therefore

This concludes the proof.
\end{proof}




\section{Lower Bounds}
\label{sec:lower}

In order to shed light on the optimality of the presented online algorithm, we
next investigate lower bounds on the competitive ratio achievable by any
(deterministic) online algorithm. We start by showing a reduction of the BRP
problem to online paging, which will imply that already for two clusters the
competitive ratio of the problem is at least . We strengthen this bound,
providing a lower bound of  that holds for any amount of augmentation, as
long as the augmentation does not allow to put all nodes in a single 
cluster. The proof uses the averaging argument. We refine this approach for a
special case of online rematching ( without augmentation), for which we
present a~lower bound of .


\subsection{Lower Bound by Reduction to Online Paging}
\label{sec:paging}

\begin{theorem}
Fix any . If there exists a -competitive deterministic algorithm 
for BRP for two clusters, each of~size~, then there exists a
-competitive deterministic algorithm  for the paging problem with 
cache size  and where the number of different pages is .
\end{theorem}

\begin{proof}
The pages are denoted by . Without loss of generality, we
assume that the initial cache is equal to . We fix any
input sequence  for the
paging problem, where  denotes the -th accessed page. We show
how to construct, an online algorithm  for the paging
problem that proceeds in the following online manner. 
The algorithm internally runs the algorithm~, 
starting on the initial assignment of nodes to clusters that will be
defined below. For a requested page , it creates a subsequence
of~communication requests for the BRP problem, runs  on them, and serves
 on the basis of 's responses.

We use the following  nodes for the BRP problem: paging nodes , auxiliary nodes  , and a special node
. We say that the node clustering is \emph{well aligned} if one cluster
contains the node  and  paging nodes, and the other cluster contains
one paging node and all auxiliary nodes. There is a natural bijection between
possible cache contents and well aligned configurations: the cache consists of
the  paging nodes that are in the same cluster as node . (Without loss
of generality, we may assume that the cache of any paging algorithm is always
full, i.e., consists of  pages.) If the configuration  of a BRP
algorithm is well aligned,  denotes the corresponding cache
contents.

The initial configuration for the BRP problem is the well aligned
configuration corresponding to the initial cache (pages
 in the cache).

For any paging node , let  be a subsequence of communication
requests for the BRP problem, consisting of the request , followed by
 requests to all pairs of auxiliary nodes. Given an input
sequence  for online paging, we construct the input sequence
 for the BRP problem in the following way: For a request
, we repeat a~subsequence  till the node
clustering maintained by  becomes well aligned and  becomes
collocated with . Note that  must eventually achieve such a node
configuration: otherwise its cost would be arbitrarily large while a sequence
of repeated  subsequences can be served at~a~constant
cost---the competitive ratio of~ would then be unbounded. We denote the
resulting sequence of  subsequences by
.

To construct the response to the paging request , the algorithm
 runs  on . Right after processing
, the node configuration  of  is well aligned and
 is collocated with~. Hence,  may change its cache
configuration to : such a response is feasible, because
since  is collocated with , it is included by  in the cache.
Furthermore, we may relate the cost of  to the cost of~: If  modifies
the cache contents, the corresponding cost is , as exactly one page has to
be fetched. Such a change occurs only if  changed the clustering 
(at a~cost of at least ). Therefore, , which,
summed over all requests from sequence , yields .

Now we show that there exists an (offline) solution \OFF to , whose
cost is exactly . Recall that, for a
paging request ,  contains the~corresponding sequence
. Before serving the first request
of~, \OFF changes its state to a well aligned
configuration corresponding to the cache of  right after serving paging
request . This ensures that the subsequence 
is free for \OFF. Furthermore, the cost of node migration of \OFF is  (two paging nodes are swapped) if  performs a fetch, and 0 if
 does not change its cache contents. Therefore,
, which
summed over the entire sequence  yields .

As  is -competitive for the BRP problem, there exists a constant
, such that for any sequence  and the corresponding sequence
, it holds that . Combining this inequality with the inequalities between  and 
and between \OFF and \OPT yields

and therefore  is -competitive.
\end{proof}

As any deterministic algorithm for the paging problem with cache size 
has a competitive ratio of~at~least ~\cite{SleTar85}, we obtain the
following result.

\begin{corollary}
The competitive ratio of the BRP problem on two clusters is at least . 
\end{corollary}


\subsection{Additional Lower Bounds}
\label{sec:lower-bounds}

\begin{theorem}\label{thm:loweraugmk}
No~-augmented deterministic online algorithm \ONL
can achieve a competitive ratio smaller than~, as long as~.
\end{theorem}

\begin{proof}
In our construction, all nodes are numbered from  to . All
presented requests are edges in~a~ring graph on these nodes with edge 
defined as  for~. At any time,
the adversary gives a communication request between an arbitrary pair of nodes
not collocated by \ONL. As , \ONL cannot fit the entire ring in
a single cluster, and hence such a pair always exists. Such a request
entails a cost of~at~least~ for \ONL. This way, we may define an~input
sequence  of~arbitrary length, such that .

Now we present  offline algorithms , such
that, neglecting an initial node reorganization they perform before
the input sequence starts, the sum of their total costs on  is exactly
. Toward this end, for any , we define a
set~. For any~, set  defines a
natural partitioning of all nodes into clusters, each containing  nodes.
Before processing , the algorithm  first migrates its nodes
(paying at most ) to the clustering defined by  and
then never changes the node placement.

As all sets  are pairwise disjoint, for any request ,
exactly one algorithm  pays for the request, and thus . Therefore, taking the initial node reorganization into
account, we obtain that . By the averaging argument, there exists an offline
algorithm , such that .
Thus, .
The~theorem follows because the additive constant 
becomes negligible as the length of  grows.
\end{proof}


\begin{theorem}
No deterministic online algorithm \ONL can achieve a competitive ratio 
smaller than~ for the case  (without augmentation).
\end{theorem}

\begin{proof} As in the previous proof, we number the nodes from  to
. We distinguish three types of node clusterings. Configuration A:
 collocated with ,  collocated with , other nodes
collocated arbitrarily; configuration B:  collocated with , 
collocated with , other nodes collocated arbitrarily; configuration C:
all remaining clusterings.

Similarly to the proof of \cref{thm:loweraugmk}, the adversary always
requests a communication between two nodes not collocated by \ONL.
This time the exact choice of such nodes is relevant: \ONL receives request to
 in configuration A, and to  in configurations B and C.

We define three offline algorithms. They keep nodes
 in the first two clusters and the remaining nodes in the
remaining clusters (the remaining nodes never change their clusters). 
More concretely,  keeps nodes  always in
configuration A and  always in configuration B. Furthermore, we define
the third algorithm  that is in configuration B if \ONL is in
configuration A, and is in configuration A if \ONL is in configuration B or C.

We split the cost of  into the cost for serving requests, , and
the cost paid for its migrations, . Observe that, for~any~request
, .
Moreover, as  does not pay for any request and migrates only when 
\ONL does, . Summing up,
 for any request .
Taking into account the initial reconfiguration of nodes in  solutions
(which involves at~most one swap of cost ), we obtain that
. Hence, by the
averaging argument, there exists , such that . This concludes the proof, as  becomes
negligible as the length of  grows.
\end{proof}

\section{Conclusion}
\label{sec:conclusion}

This paper initiated the study of a natural dynamic partitioning problem which
finds applications, e.g., in the context of virtualized distributed systems
subject to changing communication patterns. We derived upper and lower bounds,
both for the general case as well as for a special case, related to a dynamic
matching problem. The natural research direction is to develop better
deterministic algorithms for the non-augmented variant of the general case,
improving over the straightforward -competitive algorithm
given in \cref{sec:upper}. While the linear dependency on  is
inevitable (cf.~\cref{sec:lower}), it is not known whether
an~algorithm whose competitive ratio is independent of~ is possible. We
resolved this issue for the -augmented variant, for which we gave an
-competitive algorithm.

\bibliographystyle{siamplain}
\bibliography{references}

\end{document}
