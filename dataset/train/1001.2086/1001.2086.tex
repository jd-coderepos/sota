\documentclass[envcountsame]{llncs}
\usepackage{ifpdf}
\ifpdf
\usepackage{pdfsync}
\fi
\usepackage{a4wide}
\usepackage[tbtags]{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{mathrsfs}
\usepackage{enumerate}
\usepackage{gastex}
\usepackage{graphics}
\usepackage{xcolor}
\usepackage{latexsym}
\usepackage{ifthen}
\usepackage{url}

\newtheorem{observation}[theorem]{Observation}

\newcommand{\A}{\mathcal A}
\newcommand{\Bad}{\mathrm{Bad}}
\newcommand{\B}{\mathcal B}
\newcommand{\C}{\mathcal C}
\newcommand{\D}{\mathcal D}
\newcommand{\unfold}{\mathrm{unfold}}
\newcommand{\E}{\mathcal E}
\newcommand{\F}{\mathcal F}
\newcommand{\first}{\mathrm{first}}
\newcommand{\FO}{\mathsf{FO}}
\newcommand{\FOTh}{\mathsf{FOTh}}
\newcommand{\G}{\mathcal G}
\newcommand{\Good}{\mathrm{Good}}
\renewcommand{\H}{\mathcal H}
\newcommand{\Img}{\mathrm{Img}}
\renewcommand{\L}{\mathcal L}
\newcommand{\lex}{\mathrm{lex}}
\newcommand{\Loop}{\mathrm{loop}}
\newcommand{\N}{\mathbb N}
\newcommand{\M}{\mathcal M}
\renewcommand{\L}{\mathcal L}
\newcommand{\K}{\mathcal K}
\renewcommand{\P}{{\mathbb P}}
\newcommand{\Q}{\mathbb Q}
\newcommand{\R}{\mathcal R}
\newcommand{\Run}{\mathrm{Run}}
\renewcommand{\S}{\mathcal S}
\newcommand{\Shuf}{\mathrm{Shuf}}
\newcommand{\T}{\mathcal T}
\newcommand{\Z}{\mathbb Z}

\hyphenation{Khoussainov}
\setcounter{secnumdepth}{4}

\begin{document}
\title{The Isomorphism Problem On Classes of Automatic Structures}
\author{Dietrich Kuske\inst{1} \and Jiamou Liu\inst{2} \and  Markus Lohrey\inst{2,}
\thanks{The second and third author are supported by the DFG  research project GELO.}
\institute{
Centre national de la recherche scientifique (CNRS)
  and Laboratoire Bordelais de Recherche en Informatique
  (LaBRI), Bordeaux, France
\and
Universit\"at
Leipzig, Institut f\"ur Informatik, Germany
\\
\email{kuske@labri.fr, liujiamou@gmail.com,
lohrey@informatik.uni-leipzig.de}}}

\maketitle
\pagestyle{plain}

\begin{abstract}
Automatic structures are finitely presented structures
where the universe and all relations can be recognized by finite automata.
It is known that
the isomorphism problem for automatic structures is complete for ;
the first existential level of the analytical hierarchy.
Several new results on isomorphism problems for automatic structures are shown in this paper:
(i) The isomorphism problem for automatic equivalence relations is complete for 
(first universal level of the arithmetical hierarchy).
(ii) The isomorphism problem for automatic trees of height  is
 -complete.
(iii) The isomorphism problem for automatic linear orders is not arithmetical.
This solves some open questions of Khoussainov, Rubin, and Stephan. 
\end{abstract}


\section{Introduction}

The idea of an automatic structure goes back to B\"uchi and Elgot who
used finite automata to decide, e.g., Presburger
arithmetic~\cite{Elg61}. Automaton decidable theories~\cite{Hod82}
and automatic groups~\cite{EpsCHLPT92} are similar concepts. A
systematic study was initiated by Khoussainov and Nerode~\cite{KhoN95}
who also coined the name ``{\em automatic structure}''.
In essence, a structure is automatic if the elements of the universe can be
represented as strings from a regular language and every relation of the structure
can be recognized by a finite state automaton with several heads that
proceed synchronously.  Automatic structures received
increasing interest over the last
years~\cite{BarKR08,BluG04,IsKhRu02,KhoNRS07,KhoRS05,KusLo09JSL,Rub08}.
One of the main motivations for investigating automatic structures is that
their first-order theories can be decided uniformly (i.e., the input
is an automatic presentation and a first-order sentence).

Automatic structures form a subclass of recursive (or computable) structures.
A structure is recursive, if its domain as well as all relations are recursive
sets of finite words (or naturals). A well-studied problem for
recursive structures is the isomorphism problem, where it is asked whether
two given recursive structures over the same signature
(encoded by Turing-machines for the domain
and all relations) are isomorphic. It is well known that the isomorphism
problem for recursive structures is complete for the first level of the analytical hierarchy
. In fact, -completeness holds for many subclasses
of recursive structures, e.g., for linear orders, trees, undirected graphs, Boolean
algebras, Abelian -groups, see \cite{CaKni06,GonKn02}.
-completeness of the isomorphism problem for a class of recursive
structures implies non-existence of a good classification
(in the sense of \cite{CaKni06}) for that class \cite{CaKni06}.

In \cite{KhoNRS07}, it was shown that also for automatic structures the
isomorphism problem is -complete. By a direct interpretation,
it follows that for the following classes the isomorphism problem is
still -complete \cite{Nie07}: automatic successor trees, automatic undirected
graphs, automatic commutative monoids, automatic partial orders, automatic
lattices of height 4, and automatic 1-ary functions.
On the other hand, the isomorphism problem is decidable for automatic ordinals
\cite{KhoRS05} and automatic Boolean algebras \cite{KhoNRS07}.
An intermediate class is the class of all locally-finite automatic graphs, for
which the isomorphism problem is complete for  (third level
of the arithmetical hierarchy\footnote{For background on the arithmetical 
hierarchy see, e.g., \cite{Rogers}.}) \cite{Rub04}.

For many interesting classes of automatic structures, the exact status of the isomorphism problem
is open. In the recent survey \cite{Rub08} it was asked for instance, whether
the isomorphism problem is decidable for automatic equivalence relations and
automatic linear orders.
For the latter class, this question was already asked in \cite{KhoRS05}.
In this paper, we answer these questions.
Our main results are:
\begin{itemize}
\item The isomorphism problem for  automatic equivalence relations
is -complete.
\item The isomorphism problem for automatic successor trees of finite height
 (where the height of a tree is the maximal number of edges along
a maximal path) is -complete.
\item The isomorphism problem for automatic linear orders is
hard for every level of the arithmetical hierarchy.
\end{itemize}
Most hardness proofs for automatic structures, in particular the
-hardness proof for the isomorphism problem of automatic
structures from \cite{KhoNRS07}, use transition graphs of
Turing-machines (these graphs are easily seen to be automatic). This
technique seems to fail for inherent reasons, when trying to prove our
new results. The reason is most obvious for equivalence relations and
linear orders. These structures are transitive but the transitive
closure of the transition graph of a Turing-machine cannot be
automatic in general (it's first-order theory is undecidable in
general). Hence, we have to use a new strategy. Our proofs are based
on the undecidability of Hilbert's  problem. Recall that
Matiyasevich proved that every recursively enumerable set of natural
numbers is Diophantine \cite{Mat93}. This fact was used by Honkala to
show that it is undecidable whether the range of a rational power
series is  \cite{Hon06}.  Using a similar encoding, we
show that the isomorphism problem for automatic equivalence relations
is -complete. Next, we extend our technique in order to show
that the isomorphism problem for automatic successor trees of height
 is -complete. In some sense, our result
for equivalence relations makes up the induction base .
Finally, using a similar but
technically more involved reduction, we can show that the isomorphism
problem for automatic linear orders is hard for every level of the
arithmetical hierarchy. In fact, since our proof is uniform on the
levels in the arithmetical hierarchy, it follows that
the isomorphism problem for automatic linear orders is at least
as hard as true arithmetic (the first-order theory of
).  
At the moment it remains open whether the isomorphism problem for
automatic linear orders is -complete.



\section{Preliminaries} \label{sec:prelim}

Let . Let 
be a polynomial with non-negative integer coefficients.
We define

If  is not the zero-polynomial, then .

Details on the arithmetical hierarchy can be found for instance
in \cite{Rogers}. With  we denote the 
(existential) level of the arithmetical hierarchy; it is the class
of all subsets  such that
there exists a recursive predicate 
with

where  () for  odd (even).
The set of complements of -sets is denoted
by . By fixing some effective encoding of strings
by natural numbers, we can talk about -sets and 
-sets of strings over an arbitrary alphabet.
A typical example of a set, which does not belong
to the arithmetical hierarchy is {\em true arithmetic}, i.e., 
the first-order theory of , which we denote 
by . 

We assume basic terminologies and notations in automata theory 
(see, for example, \cite{HoUl79}).
For a fixed alphabet , a {\em non-deterministic finite automaton} is a
tuple  where  is the set of states,

is the transition relation, 
is a set of initial states, and  is the set of accepting states.
A {\em run} of  on a word  ()
is a word over  of the form ,
where . If moreover , then   is an {\em accepting run} of  on .
We will only apply these definitions in case , i.e., we will only speak of (accepting)
runs on non-empty words.

Given two automata  and  over the same alphabet 
, we use  to denote the automaton obtained 
by taking the disjoint union of  and . Note that for any word , the number of 
accepting runs of  on  is equal to the sum of the numbers of accepting runs of  and   on .
We use  to denote the Cartesian product of  and .
It is the automaton , where

Then, clearly, the number of accepting runs of  on a word 
 is the product of the numbers of accepting runs 
of  and   on .
In particular, if  is deterministic, then 
the number of accepting runs of 
 on  is the same as the number of accepting runs of  on .
In the following, if  is a non-deterministic automaton 
and  is a regular language, we write
 (resp. )
for the automaton  (resp. ), where 
 is some deterministic automaton for the language .


We use {\em synchronous -tape automata} to recognize 
-ary relations. Such automata have  input tapes, each of which
contains one of the input words. The  tapes are read in parallel until all input words are processed.
Formally, let  where . For words , their {\em convolution} is a word
 with length , and the  symbol of
 is  where
 is the  symbol of  if , and
 otherwise. An -ary relation  is
\emph{FA recognizable} if the set of all convolutions of tuples
 is a regular
language.

A {\em relational structure}  consists of a {\em domain}  and
atomic relations on the set~. We will only consider structures with
countable domain. If  and  are two structures over the
same signature and with disjoint domains, then we write  for the union of the two structures. Hence, when writing , we implicitly express that the domains of  and
 are disjoint. More generally, if  is a
class of pairwise disjoint structures over the same signature, then we
denote with  the union of these
structures. A structure  is called {\em automatic} over 
if its domain is a regular subset of  and each of its atomic
relations is FA recognizable; any tuple~ of automata that accept
the domain and the relations of  is called an \emph{automatic
  presentation of }; in this case, we write  for . If
an automatic structure  is isomorphic to a structure , then
 is called an {\em automatic copy} of  and  is {\em
  automatically presentable}. In this paper we sometimes abuse the
terminology referring to  as simply automatic and calling an
automatic presentation of  also automatic presentation
of~. We also simplify our statements by saying ``given/compute an
automatic structure '' for ``given/compute an automatic
presentation  of a structure ''. The structures  and  are both automatic structures. On the other hand,
 and  have no automatic copies (see
\cite{KhMi08,Rub08} and \cite{Tsankov}).

Consider , the first-order
logic extended by the quantifiers  (there exist infinitely
many) and  (there exist finitely many and the exact number
is congruent  modulo , where ). The
following theorem from \cite{BluGrae00,Hod82,KhoN95,Rub04}
lays out the main motivation for investigating automatic structures.

\begin{theorem}\label{thm:extFOaut} 
  From an automatic presentation  and a formula  in the signature of
  , one can compute an automaton whose language consists of
  those tuples  from  that make  true. In
  particular, the  theory of any
  automatic structure  is (uniformly) decidable. 
\end{theorem}
Let  be a class of automatic structures closed under
isomorphism. The {\em isomorphism problem} for~ is the set of
pairs  of automatic presentations with
. The isomorphism problem for the class 
of all automatic structures is complete for  --- the first level
of the analytical hierarchy \cite{KhoNRS07} (this holds already for
automatic successor trees). However, if one restricts to special subclasses of
automatic structures, this complexity bound can be reduced. For
example, for the class of automatic ordinals and also the class of
automatic Boolean algebras, the isomorphism problem is decidable.
Another interesting result is that the isomorphism problem for locally
finite automatic graphs is -complete~\cite{Rub04}.
All these classes of
automatic structures have the nice property that one can decide
whether a given automatic presentation describes a structure from
this class. Theorem~\ref{thm:extFOaut} implies that this property
also holds for the classes of equivalence relations, trees of
height at most , and linear orders, i.e., the classes considered
in this paper.


\section{Automatic Equivalence Structures}\label{sec:equiv}

An equivalence structure is of the form  where  is an
equivalence relation on .
In this section, we prove that the isomorphism problem for automatic
equivalence structures is -complete. This result can
be also deduced from our result for automatic trees (Section~\ref{sec:tree}).
But the case of equivalence structures is a good starting point for
introducing our techniques.

Let  be an automatic equivalence structure. Define the function
 such that
for all ,  equals the number of
equivalence classes (possibly infinite) in  of size . Note
that for given , the value  can be
computed effectively: one can define in  the set
of all -least elements\footnote{ denotes the
  length-lexicographical order on words.} that belong to an
equivalence class of size .

Given two automatic equivalence structures  and
, deciding if  amounts to checking if
. Therefore, the isomorphism problem for automatic
equivalence structures is in .

For the  lower bound, we use a reduction from
Hilbert's  problem: Given a polynomial
, decide whether the equation
 has a solution in  (for technical reasons,
it is useful to exclude  in solutions).
This problem is well-known to be
undecidable, see e.g. \cite{Mat93}. In fact, Matiyasevich constructed
from a given (index of a) recursively enumerable set
 a polynomial 
such that for all :
 if and only if .
Hence, the following set is -complete:

For a symbol , let  denote the alphabet

and let  denote the  component of .
For , write
 for the word

For a language , we write  for the language


\begin{lemma}\label{lm:equiv-runs}
  There exists an algorithm that, given a non-zero polynomial
   in  variables, constructs a
  non-deterministic automaton  on the alphabet
   with  such that
  for all :  has exactly
   accepting runs on input .
\end{lemma}

\begin{proof}
  The automaton  is build by induction on the
  construction of the polynomial , the base case is provided by the
  polynomials  and .

  Let  be a deterministic automaton accepting .
  Next, suppose  for some . Let
  ,  and . Define  as
  
  When the automaton  runs on an
  input word , it has exactly  many times the
  chance to move from state  to the final state .  Therefore
  there are exactly  many accepting runs on
  .

  Let  and  be polynomials in
  . Assume as inductive hypothesis that there are
  two automata  and
   such that for  the number of accepting runs of  on
   equals .

  For , set
  .  Then, the number of accepting runs of
   on  is .

  For , let
  .  Then, the number of accepting runs of
   on  is .  \qed
\end{proof}

\noindent
Let  be a non-deterministic finite automaton with
alphabet . We define an automaton 
with alphabet  and

Let  be the projection morphism with
.
The following lemma is immediate from the definition.

\begin{lemma}
  For  we have:  if and only if 
  forms an accepting run of  on  (which in particular
  implies ).
\end{lemma}
This lemma implies that for all words ,  equals the number of accepting runs of  on .
Note that this does not hold for .

Consider a non-zero polynomial . Let the automaton 
satisfy the properties guaranteed by Lemma~\ref{lm:equiv-runs} and let
 be as defined above. Define an automatic equivalence
structure  whose domain is .  Moreover,
two words  are equivalent
if and only if . By definition and
Lemma~\ref{lm:equiv-runs}, a natural number  belongs to
 if and only if there exists a word  with
precisely  accepting runs, if and only if  contains an
equivalence class of size .

It is well known that the function  with

is injective ( defines a pairing function, see e.g. \cite{Hon06}).  In the
following, let  denote the countably infinite equivalence
structure with


\begin{proposition}\label{P-equiv}
  The set of automatic presentations  with  is
  hard for .
\end{proposition}

\begin{proof}
  For non-zero polynomials , define the following three (non-zero)
  polynomials from  (with ):
  
  Let , , and  be the automatic equivalence
  structures corresponding to these polynomials according to the above
  definition. Finally, let  be the disjoint union of
   many copies of these three equivalence structures.

  If  for some , then there is  such that .
  Therefore in  there is an equivalence class of size  and
  no such equivalence class exists in . Hence .

  Conversely, suppose that  for
  all .  For all ,  contains
  an equivalence class of size  if and only if 
  belongs to , if and
  only if , if and only if  contains an equivalence
  class of size . Therefore, for any ,  contains
  an equivalence class of size  if and only if  contains
  an equivalence class of size . Hence .

  In summary, we have reduced the -hard problem 
  
  to the set of automatic presentations of .
  Hence the proposition is proved.
\qed
\end{proof} 

\begin{theorem}\label{thm:equiv}
  The isomorphism problem for automatic equivalence structures is
  -complete.
\end{theorem}

\begin{proof}
  At the beginning of this section, we already argued that the
  isomorphism problem is in~; hardness follows immediately
  from Proposition~\ref{P-equiv}, since  is necessarily automatic.
\qed
\end{proof}

\section{Automatic Trees}\label{sec:tree}

A {\em tree} is a structure , where  is a
partial order with a least element, called the {\em root}, and such
that for every , the order  restricted to the set
 of ancestors of  is a finite linear order.
The {\em level} of a node  is
. The {\em height} of
 is the supremum of the levels of all nodes in ; it may be
infinite, but this paper deals with trees of finite height only.
One may also view a tree as a directed graph , where there is
an edge  if and only if  is the largest element in .  The edge relation  is FO-definable in
. In this paper, we assume the partial order definition for
trees, but will quite often refer to them as graphs for
convenience.  We use  to denote the class of automatic trees with height at most
. Let  be fixed. Then the tree order  is FO-definable in
 and this holds even uniformly for all trees from . Moreover,
it is decidable whether a given automatic graph belongs to 
(since the class of trees of height  can be axiomatized in
first-order logic). 

As a corollary to Proposition~\ref{P-equiv}, we get immediately that the
isomorphism problem for automatic trees of height at most  is
undecidable:

\begin{corollary}\label{crl:tree2}
  There exists an automatic tree  of height  such that the set of
  automatic presentations~ with  is
  -hard. Hence, the isomorphism problem for the class 
  of automatic trees of height at most  is -hard.
\end{corollary}

\begin{proof}
  Let  be an automatic equivalence structure.
  Now build the tree  as follows:
  \begin{itemize}
  \item the set of nodes is \leq_{\text{llex}} where  and
     are two new letters
  \item  is the root, its children are the words starting with ,
    and the children of  are the words from .
  \end{itemize}
  Then it is clear that  is a tree of height at most  and
  that an automatic presentation for  can be computed from one
  for~. Furthermore,  if and only if . Hence, indeed, the statement follows from
  Proposition~\ref{P-equiv}.\qed
\end{proof}
The hardness statement of Theorem~\ref{thm:tree} below is a
generalization of this corollary to all the classes  for
. But first, we prove an upper bound for the isomorphism
problem for :

\begin{proposition}
\label{prop:tree_membership}
  The isomorphism problem for the class  of automatic trees of
  height at most  is
  \begin{itemize}
  \item decidable for  and
  \item in  for all .
  \end{itemize}
\end{proposition}

\begin{proof}
  We first show that  is decidable for automatic trees
   of height at most~: It suffices to compute
  the cardinality of  () which is possible since
  the universes of  and  are regular languages.

  Now let  and consider .
  Let , w.l.o.g. , and , .  For any node  in , let
   denote the subtree (of either  or ) rooted at 
  and let  be the set of children of .  For
  , we will define inductively a
  -predicate  for . This predicate expresses that  provided
   and  belong to level at least .  The result will follow since
   if and only if  holds, where  is
  the root of .

  For , the trees  and  have height at most 
  and we can define  as follows:
  
  In other words: for every , 
  and  have the same number of children with exactly 
  children. Since  is uniformly decidable for
  automatic structures, this is indeed a -sentence (note that
   for ). For , we define
   inductively as follows:
  
  By quantifying over all , we quantify over
  all isomorphism types of trees that occur as a subtree rooted at a
  child of  or . For each of these isomorphism types ,
  we express that  and  have the same number of children~
  with  of type .  Since by induction,
   and  are
  -statements,  is a
  -statement.  \qed
\end{proof}
The rest of this section is devoted to proving that the isomorphism
problem for the class  of automatic trees of height at most
 is also -hard (and therefore complete). So let
 be a -predicate.
In the following lemma and its proof, all quantifiers with 
unspecified range run over .
\begin{lemma}\label{lem:normalform}
  For , there are -predicates
   such that
  \begin{enumerate}
  \item[(i)]  is logically equivalent to
    
    for  and
  \item[(ii)] 
    implies ,
  \end{enumerate}
  where .
\end{lemma}

\begin{proof}
  The predicates  are constructed by induction, starting with
   down to  where the construction of  does not
  assume that (i) or (ii) hold true for .

  So let  such that  is a
  -predicate. Then there exists a
  -predicate  such that
   is logically equivalent to
  
  But this is logically equivalent to
  
  Let  be
  
  Then for any ,
  
  Since  is a bounded quantifier, the
  formula  belongs to 
  (see for example \cite[p. 61]{Soa87}).  Thus there is a
  -predicate  such that
  
  Therefore (\ref{eqt:tree_k}) (and therefore )
  is logically equivalent to
  .
  Moreover,
   
 This shows (ii).  \qed
\end{proof}
Let us fix the predicates  for the rest of Section~\ref{sec:tree}.
By induction on , we will construct the following trees:
\begin{itemize}
\item test trees  for  (which depend on ) and
\item trees  for  (we assume the standard order on ).
\end{itemize}
The idea is that  if and only if
. We will not prove this equivalence, but
the following simpler consequences for any :
\begin{description}
\item[(P1)]  holds if and only if
  .
\item[(P2)]  does not hold if and only if
   for some .
\end{description}
The first property is certainly sufficient for proving
-hardness (with ), the second property and
therefore the trees  for  are used in the inductive
step. We also need the following property for the construction.
\begin{description}
\item[(P3)] No leaf of any of the trees  or
   is a child of the root.
\end{description}
In the following section, we will describe the trees
 and  of height at
most  and prove~(P1) and (P2). 
Condition (P3) will be obvious from the construction.
The subsequent section is then devoted to
prove the effective automaticity of these trees.


\subsection{Construction of trees}
\label{Construction of trees}

We start with a few definitions: 
A forest is a disjoint union of trees. 
Let  and  be two forests.
The forest  is the disjoint union of countably many copies
of . Formally, if , then 
with  if and only if  and . We write
 for .
Then  if they are formed, up to isomorphism, by
the same set of trees (i.e., any tree is isomorphic to some connected
component of  if and only if it is isomorphic to some connected component of
). 
If  is a forest and  does not belong to the domain of
, then we denote with  the tree that
results from adding  to  as new least element.

\subsubsection{Induction base: construction of  and
  }\label{sss:base}

For notational simplicity, we write  for . 
Hence,  is a -ary predicate. By
Matiyasevich's theorem, we find two non-zero polynomials
, , , such that for any :

For two numbers , let  denote the tree of height
 with exactly  leaves, where  is the injective polynomial function 
from (\ref{function-C}).  Then define the following forests:

Note that . Moreover, the forests 
() are pairwise non-isomorphic, since 
is injective.

The trees  and , resp.,
are obtained from  and , resp., by
taking countably many copies and adding a root:

see Figure~\ref{fig:tree1}.

\begin{figure}[t]
\begin{center}
\setlength{\unitlength}{1mm}
\begin{picture}(20,35)(0,5)
\gasset{Nadjustdist=0.8,Nadjust=wh,Nframe=n,Nfill=n,AHnb=0,ELdist=0.5,linewidth=.2}
   \put(-28,-2){The tree }
   \node(root)(-20,40){}
 \gasset{Nw=1,Nh=1,Nframe=y,Nfill=y,Nadjust=n}
   \node(a)(-35,23){}
    \node(a'')(-5,23){}
   \drawedge[ELside=r](root,a){}
   \put(-41,30){\text{\scriptsize }}
   \put(-41,33){\text{\scriptsize }}
    \drawedge[ELside=l,ELpos=60,ELdist=0](root,a''){}
    \put(-13,33){\text{\scriptsize }}
    \put(-11,30){\text{\scriptsize }}

   \drawpolygon[Nframe=y,Nfill=n](-35,23)(-45,8)(-25,8)
   \put(-45,5){\text{\scriptsize }}
   \put(-42.1,2){\text{\scriptsize }}
\drawpolygon[Nframe=y,Nfill=n](-5,23)(-15,8)(5,8)
   \put(-10,5){\text{\scriptsize }}



\gasset{Nadjustdist=0.8,Nadjust=wh,Nframe=n,Nfill=n,AHnb=0,ELdist=0.5,linewidth=.2}
   \put(32,-2){The tree }
   \node(root)(40,40){}
\gasset{Nw=1,Nh=1,Nframe=y,Nfill=y,Nadjust=n}
   \node(a)(25,23){}
    \node(a'')(55,23){}
   \drawedge[ELside=r](root,a){}
   \put(23,33){\text{\scriptsize }}
    \drawedge[ELside=l,ELpos=60,ELdist=0](root,a''){}
    \put(47,33){\text{\scriptsize }}
    \put(49,30){\text{\scriptsize }}
   \drawpolygon[Nframe=y,Nfill=n](25,23)(15,8)(35,8)
   \put(20,5){\text{\scriptsize }}
\drawpolygon[Nframe=y,Nfill=n](55,23)(45,8)(65,8)
   \put(50,5){\text{\scriptsize }}

\end{picture}
\end{center}
\caption{\label{fig:tree1} The tree  and }
\end{figure}

The following lemma (stating (P1) for the -predicate~ ,
i.e., for ) can be proved in a similar way as
Theorem~\ref{thm:equiv}.

\begin{lemma}\label{lem:tree_2_good}
  For any , we have:
  
\end{lemma}

\begin{proof}
  By (\ref{def-tree-from-forest-2}),
  it suffices to show the first equivalence. So first
  assume  holds. We have to prove that the forests
   and  contain the same trees (up to
  isomorphism). Clearly, every tree from  is contained in .
  For the other direction, let  and
  . Then the tree  occurs in
  . Since  holds, we have
   and
  therefore . Hence this tree also occurs in
  .

  Conversely suppose  and let
  . Then the tree  occurs in
   and therefore in . Hence
  . Since  was chosen arbitrarily, this
  implies~.\qed
\end{proof}
Now consider the forest  once more.
If it contains a tree of the form  for some  
(necessarily ), then it contains all 
trees  for . Hence,  for some , which implies
 for some .
Thus, with Lemma~\ref{lem:tree_2_good} we get:

Hence we proved the following lemma, which states
(P2) for the -predicate~, i.e., for .

\begin{lemma}\label{lem:tree_2_bad}
  For any , we have:
  
\end{lemma}
This finishes the construction of the trees  and
 for , and the verification
of properties~(P1) and (P2).
Clearly, also (P3) holds for  and
 (all maximal paths have length 2).

\subsubsection{Induction step: construction of 
and  } \label{sec-induction-trees}

For notational simplicity, we write again  for  such
that  is a -ary predicate and  a -ary one.


We now apply the induction hypothesis. For any
, , 
let  and
 be trees of height at most~
such that:
\begin{itemize}
\item  holds if and only if
  .
\item  does not hold if and only if
   for some .
\end{itemize}
In a first step, we build the trees  and
 () from 
and , resp., by adding  leaves as
children of the root. This ensures

since, by property~(P3), no leaf of any of the trees  or  is a child of the
root. Next, we collect these trees into forests as follows:

The trees  and , resp., are then obtained from
the forests  and , resp., by
taking countably many copies and adding a root:

see Figure~\ref{fig:tree2}.

\begin{figure}[t]
\begin{center}
\setlength{\unitlength}{1mm}
\begin{picture}(20,35)(0,5)
\gasset{Nadjustdist=0.8,Nadjust=wh,Nframe=n,Nfill=n,AHnb=0,ELdist=0.5,linewidth=.2}
   \put(-33,-2){The tree }
   \node(root)(-25,40){}
\gasset{Nw=1,Nh=1,Nframe=y,Nfill=y,Nadjust=n}
   \node(a)(-40,23){}
    \node(a'')(-10,23){}
   \drawedge[ELside=r](root,a){}
   \put(-48,30){\text{\scriptsize }}
    \drawedge[ELside=l,ELpos=60,ELdist=0](root,a''){}
    \put(-16,30){\text{\scriptsize }}
   \drawpolygon[Nframe=y,Nfill=n](-40,23)(-50,8)(-30,8)

   \node(c)(-57,16){}
   \node(c')(-50,16){}
   \drawedge(a,c){}
   \drawedge(a,c'){}
   \put(-55,16){}
   \put(-57,16){}
   \put(-43,5){\text{\scriptsize }}




   \drawpolygon[Nframe=y,Nfill=n](-10,23)(-20,8)(0,8)

   \node(d)(0,16){}
   \node(d')(7,16){}
   \drawedge(a'',d){}
   \drawedge(a'',d'){}
   \put(2,16){}
   \put(0,16){}
   \put(-12,5){\text{\scriptsize }}





\gasset{Nadjustdist=0.8,Nadjust=wh,Nframe=n,Nfill=n,AHnb=0,ELdist=0.5,linewidth=.2}
   \put(37,-2){The tree }
   \node(root)(45,40){}
\gasset{Nw=1,Nh=1,Nframe=y,Nfill=y,Nadjust=n}
   \node(a)(30,23){}
    \node(a'')(60,23){}
   \drawedge[ELside=r](root,a){}
   \put(21,30){\text{\scriptsize }}
    \drawedge[ELside=l,ELpos=60,ELdist=0](root,a''){}
    \put(54,30){\text{\scriptsize }}

   \drawpolygon[Nframe=y,Nfill=n](30,23)(20,8)(40,8)
   \node(c)(13,16){}
   \node(c')(20,16){}
   \drawedge(a,c){}
   \drawedge(a,c'){}
   \put(15,16){}
   \put(13,16){}
   \put(28,5){\text{\scriptsize }}
\drawpolygon[Nframe=y,Nfill=n](60,23)(50,8)(70,8)
   \node(d)(70,16){}
   \node(d')(77,16){}
   \drawedge(a'',d){}
   \drawedge(a'',d'){}
   \put(72,16){}
   \put(70,16){}
   \put(58,5){\text{\scriptsize }}

\end{picture}
\end{center}
\caption{\label{fig:tree2} The tree  and }
\end{figure}


Note that the height of any of these trees is one more than the height
of the forests defining them and therefore at most . Since none
of the connected components of the forests  and  is a
singleton, none of the trees in (\ref{def-tree-from-forest-i+1}) has a leaf that is a
child of the root and therefore (P3) holds.

\begin{lemma}\label{lem:tree_main1}
  For all  we have
  
\end{lemma}

\begin{proof}
  Again, we only have to prove the first equivalence.

  First assume  and let
   be arbitrary. We have to exhibit some  such that
   holds. Note that  belongs to
   and therefore to . Since
   for any , this
  implies the existence of  with
  . By (\ref{eqt:tree_U'}), this is
  equivalent with  and . Now the
  induction hypothesis implies that  holds. Since
   was chosen arbitrarily, we can deduce .

  Conversely suppose . Let  belong to
  . By the induction hypothesis, it is one of
  the trees  for some , . In
  any case, it also belongs to . Hence it remains to
  show that any tree of the form  belongs to
  . So let . Then, by , there exists  with . By the
  induction hypothesis, we have 
  and therefore  (which belongs
  to  by the very definition).  \qed
\end{proof}

\begin{lemma}\label{lem:tree_main1a}
  For all  there exists
   such that
  .
\end{lemma}

\begin{proof}
It suffices to prove that
 for some
.
Choose  as the smallest value in 
such that

holds. By property (ii) from
Lemma~\ref{lem:normalform} for , we get

By the induction hypothesis, we get

It follows that  contains, apart from the
trees in , exactly
the trees from . Hence,
.
\qed
\end{proof}
Lemma~\ref{lem:tree_main1} and \ref{lem:tree_main1a} immediately imply:

\begin{lemma}\label{lem:tree_main2}
  For all  we have
  
\end{lemma}
In summary, we obtained the following:

\begin{proposition}\label{P-for-hardness}
  Let  and let  be a -predicate. Then, for
  any , we have
  
\end{proposition}
To infer the -hardness of the isomorphism problem for
 from this proposition, it remains to be shown that the trees
 and  are effectively automatic -- this is the
topic of the next section.

\subsection{Automaticity}

For constructing automatic presentations for the trees
from the previous section, it is actually easier to work
with {\em dags} ({\em directed acyclic graphs}).
The {\em height} of a dag  is the length (number of edges)
of a longest directed path in . We only consider dags
of finite height. A {\em root} of a dag is a node without incoming edges. A dag  can be unfolded into
a forest  in the usual way:
Nodes of  are directed paths in 
that cannot be extended to the left (i.e., the initial node
of the path is a root) and there is an edge
between a path  and a path  if and only if  extends
 by one more node. For a node  of , we define
the tree  as follows: First we restrict
 to those nodes that are reachable from  and then
we unfold the resulting dag.
We need the following lemma.

\begin{lemma}\label{from dags to trees}
  From given  and an automatic dag  of height at
  most , one can construct effectively an automatic
  presentation~ with .
\end{lemma}

\begin{proof}
  The universe for our automatic copy of  is the
  set  of all convolutions , where  is a root and  for all . Since  has height at most , we have .
  Since the edge relation of  is automatic and since the set of all
  roots in  is first-order definable and hence regular,  is
  indeed a regular set.  Moreover, the edge relation of 
  becomes clearly FA recognizable on .  \qed
\end{proof}
For , let us consider the following forest:

Technically, this section proves by induction over  the following
statement:
\begin{proposition}\label{P:forest-automatic}
  For , there exists an automatic copy  of
   and an isomorphism  that maps
  \begin{enumerate}
  \item the root of the tree  to 
    (for all ),
  \item the root of the tree  to , and
  \item the root of the tree  to  (for all
    ).
  \end{enumerate}
\end{proposition}
This will give the desired result since  is then
isomorphic to the connected component of  that contains
the word  (and similarly for ).  Note
that this connected component is automatic by
Theorem~\ref{thm:extFOaut}, since the forest  has
bounded height. Moreover, an automatic presentation for 
the connected component containing  can be computed from .

By Lemma~\ref{from dags to trees}, it suffices to construct an
automatic dag  such that there is an isomorphism
 that is the identity on
the set of roots of .

\subsubsection{Induction base: the automatic dag }

Recall the definitions of
, ,
and  from Section~\ref{sec:equiv}.


\begin{lemma}\label{L1}
  From , , and
  a symbol , one can compute an automatic
  forest of height  over an alphabet
   such that
  \begin{itemize}
  \item the roots are the words from ,
  \item the leaves are words from , and
  \item the tree rooted at  is
    isomorphic to .
  \end{itemize}
\end{lemma}

\begin{proof}
  Set 
  and recall the definition of the automata  and 
  from Section~\ref{sec:equiv}.  Recall also that we let  be the
  projection with  for a transition  of .
  Then let
  
  Then  is regular and
   is FA recognizable, i.e., the pair 
  is an automatic graph. It is actually a forest of height , the
  words from  form the roots, and the tree rooted
  at  has precisely
   leaves, i.e., it is isomorphic to
  .\qed
\end{proof}
{}From now on, we use the notations from Section~\ref{sss:base}.
Using Lemma~\ref{L1}, we can compute automatic forests 
and  over alphabets
 and
, respectively, such that
\begin{enumerate}[(a)]
  \item the roots of  are the words from
    ,
  \item the roots of  are the words from ,
  \item the leaves of  are words from  (),
  \item the tree rooted at 
    is isomorphic to  for , ,
  \item the tree rooted at  is isomorphic to
     for .
\end{enumerate}
We can assume that the alphabets , ,
, and  are mutually disjoint.
Let  be the disjoint union of 
and ; it is effectively automatic.

The universe of the automatic dag  is the 
regular language 

where u,v \in V_{\mathcal F}\ is connected to ^n
  \otimes vm=n(u,v) \in E_{\mathcal F}\aleph_0\mathcal{F}a^{\overline c}\. By point (d) and (e) above, this means that
 the tree  has  many subtrees isomorphic to
  for ,  and  for , . 
 Hence, .

\item  is connected to all words from ^* \otimes \{b^{e_1 e_2} \mid e_1 \neq e_2 \}\unfold(\mathcal D^2, \varepsilon)\aleph_0T[e_1,e_2]e_1,e_2 \in \N_+e_1 \neq e_2\unfold(\mathcal D^2, \varepsilon) \cong U^2_\omegab^mm \in \N_+\. By (e) above,
 this means that the tree  has  many subtrees isomorphic to
  for all  with  or 
 . Hence, .
\end{itemize}
Thus,  and the roots are as 
required in Proposition~\ref{P:forest-automatic}, see Figure~\ref{fig:auto_tree1}.
Moreover, it is clear that  is automatic.


\begin{figure}[t]
\begin{center}
\setlength{\unitlength}{1mm}
\begin{picture}(20,40)(0,0)
\gasset{Nadjustdist=0.8,Nadjust=wh,Nframe=n,Nfill=n,AHnb=0,ELdist=0.5,linewidth=.2}
   \drawpolygon[Nframe=y,Nfill=n](-5,23)(-15,8)(5,8)
    \drawpolygon[Nframe=y,Nfill=n](-35,23)(-45,8)(-25,8)
   \put(-34,-2){}
   \node(root)(-20,40){}
   \node[fillcolor=white](a)(-35,23){\scriptsize ^m \otimes a^{\overline{c}\overline{x}}a^{\overline{c}}\otimes \}
   \drawedge[ELside=r](root,a){}
   \put(-41,30){\text{\scriptsize }}
   \put(-41,33){\text{\scriptsize }}
    \drawedge[ELside=l,ELpos=60,ELdist=0](root,a''){}
    \put(-13,33){\text{\scriptsize }}
    \put(-11,30){\text{\scriptsize }}
\gasset{Nw=1,Nh=1,Nframe=y,Nfill=y,Nadjust=n}
   \put(-45,5){\text{\scriptsize }}
   \put(-42.1,2){\text{\scriptsize }}
\put(-10,5){\text{\scriptsize }}





\gasset{Nadjustdist=0.8,Nadjust=wh,Nframe=n,Nfill=n,AHnb=0,ELdist=0.5,linewidth=.2}
   \drawpolygon[Nframe=y,Nfill=n](25,23)(15,8)(35,8)
   \put(12,-2){}
   \node(root)(25,40){}
   \node[fillcolor=white](a)(25,23){\text{\scriptsize ^m \otimes b^{e_1e_2}\forall m, e_1,e_2e_1\neq e_2T[e_1,e_2]\unfold(\mathcal{D}^2,b^m)\cong U^2_{m}b^mb^m\otimes \}
    \drawedge[ELside=l,ELpos=60,ELdist=0](root,a''){}
    \put(47,33){\text{\scriptsize }}
    \put(46,30){\text{\scriptsize  or}}
    \put(44,27){\text{\scriptsize }}
\gasset{Nw=1,Nh=1,Nframe=y,Nfill=y,Nadjust=n}
   \put(55,5){\text{\scriptsize }}

\end{picture}
\end{center}
\caption{\label{fig:auto_tree1} Automatic presentation of  and }
\end{figure}

\subsubsection{Induction step: the automatic dag }
\label{sec-induction-automatic-trees}

Suppose  is such that  is as described in Proposition~\ref{P:forest-automatic}.

We use the notations from Section~\ref{sec-induction-trees}. We first
build another automatic dag , whose unfolding will comprise (copies
of) all the trees  (, ) and  (, ).
Recall that the set of roots of  is
.
The universe of  consists of the regular language

where , and  are new symbols.
We have the following edges in :
\begin{itemize}
\item All edges from  except those with an initial node in 
are present in .
\item  is connected to all words of the form
 for , and .
This ensures that the subtree rooted at  gets  new leaves,
which are children of the root. Hence .
\item  for  and 
 is connected  to (i) all nodes to which  is connected
in  and  to (ii) all nodes from  for .
This ensures that  in case  and .
\end{itemize}
In summary,  is a dag, whose unfolding
consists of (a copy
of)  rooted at ,  ()
rooted at , and  rooted at
.

{}From the automatic dag , we now build in a final step
the automatic dag . This is very similar to the
constructions of  and  above.
Let  be the universe of .
The universe of  is the regular language

The edges are as follows:
\begin{itemize}
\item For , ^m \otimes u\ 
 if and only if  and  is an edge of .
 This generates  many copies of .
\item  is connected to every word from 
 ^* \otimes (\{ a^{\overline c x y} \mid x,y \in \N_+ \} \cup (\sharp^+ \otimes b^+))\unfold(\mathcal D^{i+1}, a^{\overline c})\aleph_0T'_{\overline cxy}x,y \in \N_+U'_{m,x}x,m \in \N_+\unfold(\mathcal D^{i+1}, a^{\overline c}) \cong T^{i+1}_{\overline{c}}\varepsilon\. Hence, the tree  has
 many subtrees isomorphic to 
 for all  and . 
Thus, .

\item  () is connected to all words from ^* \otimes
  ((\sharp^+ \otimes b^+) \cup \{\sharp^x \otimes\varepsilon \mid 1 \leq x < m\})\unfold(\mathcal D^{i+1}, b^m)\aleph_0U'_{m,x}m,x \in \N_+U'_{\omega,x}1 \leq x < m\unfold(\mathcal D^{i+1}, b^m) \cong U^{i+1}_m\unfold(\mathcal{D}^{i+1},a^{\overline{c}}) \cong T^{i+1}_{\overline{c}}a^{\overline{c}}a^{\overline{c}}\otimes \}
    \node[fillcolor=white](a'')(-10,23){\scriptsize ^m \otimes \sharp^x \otimes b^n\forall m,x,y\forall m,n,x1\leq i\leq x\ldots\underbrace{\makebox(7,0){}}_{}a^{\overline{c}}\otimes \}
   \put(-50,5){\text{\scriptsize ^m\otimes T^i_{\overline{c}xy}1\leq i\leq x\ldots\underbrace{\makebox(7,0){}}_{}a^{\overline{c}}\otimes \}

   \put(-20,5){\text{\scriptsize ^m\otimes \sharp^x\otimes U^i_{n}T^{i+1}_{\overline{c}}\unfold(\mathcal{D}^{i+1},\varepsilon) \cong U^{i+1}_{\omega}\varepsilon\varepsilon\otimes \}
    \node[fillcolor=white](a'')(-10,23){\scriptsize ^m \otimes \sharp^x \otimes b^n\forall m,x\forall m,n,x1\leq i\leq x\ldots\underbrace{\makebox(7,0){}}_{}\varepsilon\otimes \}
   \put(-50,5){\text{\scriptsize ^m\otimes \sharp^x \otimes U^i_{\omega}1\leq i\leq x\ldots\underbrace{\makebox(7,0){}}_{}\varepsilon \otimes \}

   \put(-20,5){\text{\scriptsize ^m\otimes \sharp^x\otimes U^i_{n}U^{i+1}_{\omega}\unfold(\mathcal{D}^{i+1},b^m) \cong U^{i+1}_{m}b^mb^m\otimes \}
    \node[fillcolor=white](a'')(-10,23){\scriptsize ^n \otimes \sharp^x \otimes b^h\forall n \forall 1\leq x<m\forall n,x,h1\leq i\leq x\ldots\underbrace{\makebox(7,0){}}_{}b^m\otimes \}
   \put(-50,5){\text{\scriptsize ^n\otimes \sharp^x\otimes  U^i_{\omega}1\leq i\leq x\ldots\underbrace{\makebox(7,0){}}_{}b^m \otimes \}
   \put(-20,5){\text{\scriptsize ^n\otimes \sharp^x\otimes U^i_{h}U^{i+1}_{m}n\ge2n\Pi^0_{2n-3}\FOTh(\N; +, \times)\Pi^0_{2n-3}P_n\subseteq\N_+\Pi^0_{2n-3}c\in\N_+\mathcal F^nnT^n_cU^n_\omega\mathcal F^na^c\varepsilonP_n(c)nT_1, T_2T_1 \cong T_2n \geq 2\Pi^0_{2n-3}P_{2n-3} \subseteq \N_+\F^nn\Pi^0_{2n-3}c \in \N_+a^c\F^n\varepsilon\F^nn \geq 1n\Pi^0_{2n}n=1T_1T_21k \geq 0kT_1kT_2\Pi^0_21\Pi^0_2\Pi^0_2MT(M)1T(M)ML(M)T(M)1L(M)m \in \NT(M)1mn \geq 1\omega(\N;\leq)\mathbf{n}nI = (D_I;\leq_I)\L=\{L_i\mid i\in D_I\}L_i=(D_i;\leq_i)i\in D_I\sum \L( \{ (x,i) \mid i\in D_I, x \in D_i\};\leq)i,j\in D_Ix\in D_iy\in D_jL_1+L_2\sum \{L_i\mid i\in \mathbf{2}\}L_1\cdot L_2\sum \{L^i_1\mid i\in L_2\}L^i_1\cong L_1i\in L_2L= (D;\leq)I\subseteq Dx,y\in Ix< z< yz\in I\leq_{\lex}D\leq_{\lex}<\SigmaDw,w'\in Dww'w<_{\lex} w'ww'x,y,z\in
\Sigma^*\sigma, \tau\in \Sigmaw=x\sigma yw'=x\tau z\sigma< \tauw\leq_{\lex} w'w=w'w<_{\lex} w'\leq_{\lex}\leq_{\lex}\FOTh(\N;+,\times)n\Sigma^0_nn10^{th}\Pi^0_1\Pi^0_{2i-1}\Sigma^0_{2i}\Sigma^0_{2i}\Pi^0_{2i+1}n\ge1P_n(x_0)\Sigma^0_n1\leq i< nP_i(x_0, \ldots, x_{n-i})\Pi^0_i\Sigma^0_iP_{i+1}(x_0,
\ldots, x_{n-i-1})Q x_{n-i}:
P_i(x_0,\ldots, x_{n-i})Q=\existsiQ=\foralli1\leq i\leq n\overline{c}\in \N_+^{n-i+1}L^i_{\overline{c}}K^i\M^i\M^1=\{M^1_m\mid m\in \N_+\}\M^i\{M^i\}i>1P_i(\overline c)L^i_{\overline c} \cong K^iP_i(\overline c)L^i_{\overline{c}}\cong MM\in \M^i\omega\cdot \mathbf{i}L^i_{\overline{c}}, K^i, MM\in \M^iL^i_{\overline{c}}K^i\M^i\Pi^0_i\Pi^0_{i+2}\Pi^0_{2n-3}n \geq 2\Pi^0_ii\Sigma^0_{i+1}\Sigma^0_{i+1}\Pi^0_{i+2}II\Qc:\Q\rightarrow Ix,y\in \Qx<yi\in Ix<z<yc(z)=i\L=\{L_i\mid i\in I\}Ic:\Q\rightarrow II\Q\L\Shuf(\L)\sum_{x\in \Q} L_{c(x)}\sum_{x\in \Q}
L_{c(x)}Ic\Shuf(\L)\L_1\L_2L\in\L_1\L_1L\L_1\subseteq\L_2\forall L_1\in\L_1\;\exists
  L_2\in\L_2:L_1\cong L_2\L_1=\L_2\L_1\subseteq\L_2\subseteq\L_1L^1_{\overline{c}}K^1M^1_mC(x,y)=(x+y)^2+3x+yn_1, n_2 \in \N_+L[n_1, n_2]C(n_1, n_2)p_1(\overline{x}), p_2(\overline{x})\in \N[\overline{x}]\ell\ell>n\overline{c}\in \N_+^{n}\Pi^0_1P_1(\overline{c})\overline{c}\in \N^n_+m\in \N_+L^1_{\overline{c}}K^1M^1_m\Pi^0_1P_1\L_1\L_2\Shuf(\L_1)\omega\L_1=\L_2\Shuf(\L_1) \cong
  \Shuf(\L_2)f\Shuf(\L_1)\Shuf(\L_2)\L_1=\L_2\L_1 \subseteq
  \L_2i\in \{1,2\}\Shuf(\L_i)q\in \QL^i_q\L_iq\in \Qf(L^1_q)L^2_pL^2_{p'}p<p'f(L^1_q)fL^1_qL^2_pp\in \Qff^{-1}f^{-1}L^2_pL^1_qL^1_q \cong L^2_pL\in \L_1L'\in \L_2L\cong
  L'\L_1 \subseteq \L_2x_1<x_2<\cdots\Shuf(\L_1)p<p'\Qk<\ell\N_+x_k\in L^1_px_\ell\in
  L^1_{p'}[x_k,x_\ell]\Shuf(\L_1)\omegai=1\overline{c}\in \N^n_+P_1(\overline{c}) \text{ holds } \ \Longleftrightarrow \ L^1_{\overline{c}} \cong K^1P_1(\overline{c}) \text{ does not hold } \ 
\Longleftrightarrow \ \exists m\in \N_+:  L^1_{\overline{c}} \cong M^1_m.L_{\overline c}^1K^1M^1_mP_iP_{i+1}ii\geq 1kn-iP_{i+1}kP_i(k+1)\overline{c}\in \N^k_+P_{i+1}(\overline{c})\exists x: P_i(\overline{c},x)\overline{c}\in \N^{k}_+x\in \N_+L^i_{\overline{c}x}K^i\M^iP_i(\overline{c},x)L^i_{\overline{c}x}\cong K^iP_i(\overline{c},x)L^i_{\overline{c}x}
  \cong MM\in \M^i\omega\cdot \mathbf{i}L^i_{\overline{c}x}K^iMM\in \M^i\overline{c}\in \N^k_+L^{i+1}_{\overline{c}}K^{i+1}M^{i+1}\M^ii > 1M^i\L_1\L_2L\in \L_1\cup \L_2\omega\cdot \mathbf{i} + K\omega\cdot
  \mathbf{i}K\Shuf(\L_1)\omega\cdot(\mathbf{i+1})K\omega\cdot(\mathbf{i+1})+K\in\L_1\L_1=\L_2\Shuf(\L_1)\cong
  \Shuf(\L_2)f\Shuf(\L_1)\Shuf(\L_2)\L_1=\L_2\L_1\subseteq \L_2\L_j=\{L_{j,s}\mid s\in \N \}j\in \{1,2\}j\in \{1,2\}\Shuf(\L_j)q\in \QL(j,q)\cong
  L_{j,c(q)}c\Nq\in
  \Qf(L(1,q))L(2,p)L(2,p')p,p'\in \Qp<p'f(L(1,q))\omega\cdot
  \mathbf{i}L(1,q)fL(1,q)L(2,p)p\in \Qf(L(1,q)) \varsubsetneq L(2,p)f^{-1}(L(2,p))x\notin L(1,q)ff^{-1}f(L(1,q))=L(2,p)L\in \L_1L'\in \L_2L\cong L'I\cong\omega\cdot(\mathbf{i+1})\Shuf(\L_1)p<r\QIL(1,p)L(1,r)L(1,q)\subseteq Ip<q<r(\Q,\le)I\cong\omega\cdot(\mathbf{i+1})q\in\QI\subseteq L(1,q)\in\L_1KL(1,q)=\omega\cdot\mathbf{i}+K\omega\cdot\mathbf{i}\omega\cdot(\mathbf{i+1})KI\omega\cdot\mathbf{i}L(1,q)\omegaKL(1,q)=\omega\cdot(\mathbf{i+1})+K'K'\omega\cdot \mathbf{(i+1)}L^{i+1}_{\overline{c}}K^{i+1}M^{i+1}L^i_{\overline{c}x}K^iM \in \M^i\omegai+1i+1iP_iP_{i+1}ii \geq 1\Pi^0_{i+1}P_{i+1}kn-i\overline{c}\in \N^{k}_+P_{i+1}(\overline{c})\forall x: P_i(\overline{c},x)ii \geq 2\M^iM^i\overline{c}\in \N^{k}_+\L^{i+1}_1(\overline{c})\L^{i+1}_2\L^{i+1}_3L^{i+1}_{\overline{c}}K^{i+1}M^{i+1}\omega\cdot \mathbf{(i+1)}L^{i+1}_{\overline{c}}K^{i+1}M^{i+1}i+1i+1i\overline{c} = (c_1,\ldots,c_k) \in \N_+^kaa^{\overline{c}}p(\overline{x})\in \N[\overline{x}]k\A[p(\overline{x})]a^{\overline{c}}p(\overline{x})\in \N[\overline{x}]k\A[p(\overline{x})]\{a,\sharp\}L(\A[p(\overline{x})]) = (a^+\sharp)^k\overline{c}\in \N^k_+:\A[p(\overline{x})]p(\overline{c})a^{\overline{c}}p(x_1,\ldots,x_k)x_ii\in \{1,\ldots,k\}\A[x_i](S,I,\Delta,F)S=\{q_0,q_1,\ldots q_k,q'_i\}I=\{q_0\}F=\{q_k\}\DeltaL(\A[x_i]) = (a^+\sharp)^k\A[x_i]c_ia^{\overline{c}}\overline{c}\in \N^k_+\A[p(\overline{x})]\A\Sigma\Delta\A\Run_\A\pi : \Delta^*
\to \Sigma^*\Run_\A\Delta\leq_{\lex}\Sigma^*\Delta^*\sqsubseteqL(\Run_\A)w,w'\in L(\Run_\A)\Sigma_i\{\sharp, \_{i-1}, \. 
Fix the order  on  such that
 
For any automaton  over , fix an arbitrary order on the transition relation
 of . Let  be the lexicographic orders on  and  defined with respect to these orders, 
respectively. From now on, we will always let 
 be the linear order as defined in (\ref{eqt:lo_sqsubseteq}) with respect to .
For a regular language  let . 
For , we use  to
denote the language . 
Technically, in this section we prove by induction on  the following statement:

\begin{proposition}\label{prop:lo_automaticity} We can compute automata  
over  such that:
\begin{enumerate}[(1)]
\item  RR \subseteq \Sigma_1^+i>1L(\A^i) = ( (a^+\sharp)^{n-i+1} \cup b_1 \sharp \cup b_2\sharp)\ 
for some regular language 
\item  for 
\item  for 
\item   for 
\item 
\end{enumerate}
Moreover, in (1) and (2) we have . 
\end{proposition}

\subsubsection{Effective automaticity of shuffle sums} 

This section shows that we can construct an automatic presentation of
the shuffle sum of a class of automatic linear orders that are
presented in some specific way. For a regular language  over an
alphabet, which does neither contain  nor , let .

\begin{lemma}\label{lem:lo_aut_shuf}
Let  be an automaton such that  FE,D \subseteq \{a,b_1,b_2,b_3,\sharp\}^*F \subseteq \Sigma^*_i1\leq i\leq n\sigma(\A, E)L(\sigma(\A,E)) = E\ Fu\in E \sigma(D)\ F) \cap L(\Run_{\A}); \sqsubseteq) \mid v\in D\}).

\A' = (S\times\{1,2,\Loop\}, I\times \{1\},\Delta', S_f\times \{2\}).

    \Delta'  &=& \{((q,1),\alpha,(p,1)) \mid (q,\alpha,p)\in \Delta, \alpha\in\Gamma \} \cup \\
             & & \{((q,1),\\A'\AS\times \{1\}S\times \{2\}\A'\A\ in the
input.  If so, it goes out of  and continues the simulation
in the second copy of  and accepts the input word if the run stops
at a final state.  If the guess was not correct and there is another
 before the second u_1,u_2\in \Gamma^*v\in (\Gamma\cup\{0,1\})^* 1u_3\in F\A'u_1\ u_3\Au_1 u_2 \, i.e.,

Let 

Note that  \sigma(D) \. Also, for any , 
, , and , the number of accepting runs of 
 on  vu_2\ equals the number of accepting runs of  on 
 v u_2 \, which is, by (\ref{eqt:lo_same run}), equal to the number of accepting runs of  on  u_3vu_2 \ u_3)|.
\label{eqt:lo_shuf}
    (\pi^{-1}(u_1\ F)\cap L(\Run_{\sigma(\A,E)}) ; \sqsubseteq) \cong (\pi^{-1}(u_1 u_2 \u\in FL(u)=(\pi^{-1}(u_1 u_2 \. 
Note that this is a finite linear order.
Consider the linear order .
By definition of ,

By (\ref{eqt:lo_same run2}),  v u_2 \. By definition of  again,

This proves Claim~1.

\medskip

\noindent
Let  be the function such that
 
{\em Claim 2.}  and the function  is a dense -coloring of .

\medskip

\noindent
First, for every  with  and , we have

Hence,  does not have a smallest or largest element. 
It remains to show that the linear order  is densely 
-colored by  (this implies that  is dense and 
hence, by Cantor's theorem, isomorphic to ). Consider two words 
 such that . There are two cases.

\medskip

\noindent Case 1. ,  for 
 and  
such that . In this case, for all , we have


\noindent Case 2.  for some . Since 
, we have . Say  for some , 
 and . 
We must have . Since every symbol
from this set is larger than  (see (\ref{def-alph-order})) we must have .
Then for all , we have

Hence  is indeed densely colored by . This proves Claim~2.

\medskip

\noindent
Since <\Sigma_iu\in Ev,v'\in \sigma(D)w,w'\in F v \ v'\ \sigma(D) \ v \ F) \cap L(\Run_{\A}); \sqsubseteq) \\
     & \stackrel{\text{Claim 2}}{\cong} & \Shuf(\{(\pi^{-1}(u v\L^1_{\overline{c}},
  K^1M^1_mD\AD \A\A_DD\A(q,a,p)q\A_D(q,a,q')\A_Dq'\A_Dp\AL (D \A) = D L(\A)D L(A)u \in D L(A)u = u_1 u_2u_1 \in Du_2 \in L(A)\ADD L(A)u_1 \in Du_2 \in L(\A)D \Au_1u_2\Au_2q_1(\overline{x}),q_2(\overline{x})\in
\N[\overline{x}]k\A[q_1,q_2]\{a,\#,\ such that
\begin{itemize}
\item \overline{c}\in \N_+^k(\pi^{-1}(a^{\overline{c}}\.
\end{itemize}
\end{lemma}
\begin{proof}
We construct  by taking a copy of
 (see Lemma~\ref{lem:lo_runs}), 
adding a new state }(q_f, \})q_f\A[C(q_1(\overline{x}),q_2(\overline{x}))]q_{\ the only accepting state of .
Note that for any , the number of accepting runs of  
on \A[C(q_1(\overline{x}),q_2(\overline{x}))]a^{\overline{c}}C(q_1(\overline{c}), q_2(\overline{c}))(\pi^{-1}(a^{\overline{c}}\ 
forms a copy of  and the lemma is proved.
\qed
\end{proof}
By Lemma~\ref{lem:lo_poly}, we can construct automata
,
where , over the alphabet
\}\A_2=\A[x_1+x_2,x_1+x_2]\{b_1,
\sharp, \,  over the alphabet \}\A_4=\A[x_1,x_1+x_2]\{b_3,\sharp, \ such that:

Define the following automata:

Note that

Hence, applying Lemma~\ref{lem:lo_aut_shuf} (with ), 
we can effectively construct automata  () as follows:

For all  we get:
2mm]
& \qquad \Shuf(\{(\pi^{-1}(a^{\overline{c}} v \) \cap
                  L(\Run_{\A^0_1}); \sqsubseteq) \mid \overline{e} \in
                  \N_+^{\ell-n+1} \} \; \cup \\
& \qquad \phantom{\Shuf(} \{(\pi^{-1}(a^{\overline{c}} b_2^{e_1}\sharp b_2^{e_2}\sharp \) \cap
                  L(\Run_{\A^0_1}); \sqsubseteq) \mid e_1,e_2 \in \N_+ \})\stackrel{\text{Lemma~\ref{lemma-unambiguous}}}{\cong}  \2mm]
& \qquad \Shuf(\{ L[p_1(\overline{c}, \overline{e})+e_{\ell+1}, 
   p_2(\overline{c},\overline{e})+e_{\ell+1}] \mid \overline{e} \in
                  \N_+^{\ell-n}, e_{\ell+1} \in \N_+ \} \; \cup \\
& \qquad \phantom{\Shuf(} \{ L[e_1+e_2,e_1]  \mid e_1,e_2 \in \N_+ \} \; \cup
\; \{ L[e_1, e_1+e_2]  \mid e_1,e_2 \in \N_+ \}) \stackrel{\text{(\ref{class-L_1})--(\ref{class-L_4})}}{=} \
Similar calculations yield:

Let . It is easy to see that  
 RR \subseteq \Sigma_1^+\first(R)
\subseteq \{0,1\}\A^1L^{i+1}_{\overline{c}}K^{i+1}M^{i+1}ii\geq 1kn-i\A^iL(\A^i) =
((a^+\sharp)^{k+1} \cup \beta\sharp \cup b_2 \sharp) \ for some regular 
language  where  if , 
and  otherwise. Furthermore,  and the following hold for :

For any , let _1^+\cup \cdots \cup \.
It is easy to see that

Define the automata , , and  as 

By (\ref{def-alph-order}), (\ref{eq-L^i})--(\ref{order on S_j}), 
and the fact that , we have

Now construct the automata , and  as follows:

We have

Hence, we can apply Lemma~\ref{lem:lo_aut_shuf} to , , and
 (with ) to define the following automata:

For all  we get:
2mm]
& \qquad \Shuf(\{(\pi^{-1}(a^{\overline{c}} v \ (S_i \cup R)) \cap
                  L(\Run_{\C^i_1}); \sqsubseteq) \mid e \in \N_+ \} \; \cup \\
& \qquad \phantom{\Shuf(} \{(\pi^{-1}(a^{\overline{c}} u \sharp \ (S_i \cup R)) \cap
                  L(\Run_{\B^i_1}); \sqsubseteq) \mid e \in \N_+ \} \; \cup \\
& \qquad \phantom{\Shuf(} \{(\pi^{-1}(u \sharp \\A^{i+1} =  \A^{i+1}_1\uplus \A^{i+1}_2 \uplus \A^{i+1}_3L(\A^{i+1}) = ((a^+\sharp)^{k} \cup
b_1\sharp \cup b_2\sharp) \ 
for some regular language  with . 
Hence  satisfies the statement in Proposition~\ref{prop:lo_automaticity}.


\subsubsection{Second inductive step: automatic presentations for
  , ,  for  even}


Using the same technique,  we can construct 
automatic presentations for   (), , and  in case  is even.
We first define the automata , , and 
as in (\ref{B^i_1})--(\ref{B^i_3}), with  this time.
Then we construct

We define the following automata by applying Lemma~\ref{lem:lo_aut_shuf}:

By Lemma~\ref{lem:lo_aut_shuf}, it is easy to check the following:

Let . 
It is easy to see that  R'R' \subseteq \Sigma_{i+1}^+\first(R') \subseteq \{0,1\}\A^{i+1}\FOTh(\N;+,\times)(L,\leq)x,y \in L[x,y]\FOTh(\N;+,\times)(L,\le)(K,\le)= ((-1,0]+[1,2)) \cdot (L,\le)L(-1,0]\cup[1,2)(K,\le)01(\mathbb{Q},\leq)(L,\le)x\in
  K\exists z > x \; \forall y : (x<y\le z \to
  y=z)(L,\le)\cong(L',\le')((-1,0]+[1,2)) \cdot (L,\le) \cong ((-1,0]+[1,2)) \cdot (L',\le')n\in \N\Pi^0_1\Pi^0_{2n-3}\FOTh(\N;+,\times)\FOTh(\N;+,\times)n\Pi^0_{2n}fL_1L_2\Sigma^0_k\{ (x,f(x)) \mid x \in L_1\}\Sigma^0_kk\in \N\Sigma^0_kT_1=(D_1;E_1)T_2=(D_2;E_2)P_1(x,y), P_2(x,y),\ldots\Sigma^0_ke \geq 1\Sigma_k(\N;+,\times)P_e(x,y)\text{iso}(T_1,T_2,k)P_e\Sigma^0_k\Sigma^0_{k+2}\Sigma_k^0T_1T_2n\T_nn\Sigma_{k+3}T_1,T_2\in \T_nT_1\cong T_2\Sigma^0_kT_1T_2\T_n\Sigma^0_k\Sigma^0_{k+2}T_1,T_2\in \T_nT_1\cong T_2\Sigma^0_k\text{iso}(T_1,T_2,k)(x_1,x_2)\in E_1 \leftrightarrow (y_1,y_2)\in E_2x_1 <_1 x_2 \leftrightarrow y_1 <_2 y_2<_1<_2T_1T_2'NN$}.
\newblock {\em Fund. Inform.}, 73(1-2):127--132, 2006.

\bibitem{HoUl79}
J.~E. Hopcroft and J.~D. Ullman.
\newblock {\em Introduction to automata theory, languages and computation}.
\newblock Addison--Wesley, Reading, MA, 1979.

\bibitem{IsKhRu02}
H.~Ishihara, B.~Khoussainov, and S.~Rubin.
\newblock Some results on automatic structures.
\newblock In {\em Proceedings of LICS 2002}, pages 235--244. {IEEE}
  {C}omputer {S}ociety {P}ress, 2002.

\bibitem{KhMi08}
B.~Khoussainov and M.~Minnes.
\newblock Model theoretic complexity of automatic structures.
\newblock In {\em Proceedings of TAMC 2008}, number 4978 in Lecture Notes in
  Computer Science, pages 514--525. Springer, 2008.

\bibitem{KhoN95}
B.~Khoussainov and A.~Nerode.
\newblock Automatic presentations of structures.
\newblock In {\em LCC: International Workshop on Logic and Computational
  Complexity}, number 960 in Lecture Notes in Computer Science, pages 367--392,
  1995.

\bibitem{KhoNRS07}
B.~Khoussainov, A.~Nies, S.~Rubin, and F.~Stephan.
\newblock Automatic structures: richness and limitations.
\newblock {\em Log. Methods Comput. Sci.}, 3(2):2:2, 18 pp.
  (electronic), 2007.

\bibitem{KhoRS05}
B.~Khoussainov, S.~Rubin, and F.~Stephan.
\newblock Automatic linear orders and trees.
\newblock {\em ACM Trans. Comput. Log.}, 6(4):675--700, 2005.

\bibitem{KusLo09JSL}
D.~Kuske and M.~Lohrey.
\newblock Some natural decision problems in automatic graphs.
\newblock {\em J. Symbolic Logic}, 2009.
\newblock to appear.

\bibitem{Mat93}
Y.~V. Matiyasevich.
\newblock {\em Hilbert's Tenth Problem}.
\newblock MIT Press, Cambridge, Massachusetts, 1993.

\bibitem{Nie07}
A.~Nies.
\newblock Describing groups.
\newblock {\em Bull. Symbolic Logic}, 13(3):305--339, 2007.

\bibitem{Rogers}
H.~Rogers.
\newblock {\em Theory of Recursive Functions and Effective Computability}.
\newblock McGraw-Hill, 1968.

\bibitem{Ros82}
J.~Rosenstein.
\newblock {\em Linear Ordering}.
\newblock Academic Press, 1982.

\bibitem{Rub04}
S.~Rubin.
\newblock {\em Automatic Structures}.
\newblock PhD thesis, University of Auckland, 2004.

\bibitem{Rub08}
S.~Rubin.
\newblock Automata presenting structures: A survey of the finite string case.
\newblock {\em Bull. Symbolic Logic}, 14:169--209, 2008.

\bibitem{Soa87}
R.~I. Soare.
\newblock {\em Recursively enumerable sets and degrees}.
\newblock Perspectives in Mathematical Logic. Springer, 1987.

\bibitem{Tsankov}
T.~Tsankov.
\newblock The additive group of the rationals does not have an automatic
  presentation.
\newblock \url{http://arxiv.org/abs/0905.1505}

\end{thebibliography}


\end{document}
