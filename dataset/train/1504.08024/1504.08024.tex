\documentclass[oneside,letterpaper]{scrartcl} \usepackage{macros} 




\newcommand{\eps}{\epsilon}
\newcommand{\mcard}{q}\newcommand{\nmat}{q}

\newcommand{\mindex}{\ell} 

\newcommand{\pmatchoid}{\matchoid^p} \newcommand{\defpmatchoid}{\pmatchoid = (\groundset,\independents)} \newcommand{\matroidI}{\matroid_{\mindex}} \newcommand{\groundsetI}{\groundset_{\mindex}} \newcommand{\independentsI}{\independents_{\mindex}} \newcommand{\defmatroidI}{\matroidI = (\groundsetI,\independentsI)} \newcommand{\offlineratio}{\gamma_p} \newcommand{\optset}{T^*} 


\begin{document}

\title{Streaming Algorithms for \\Submodular Function Maximization} \author{ Chandra Chekuri\thanks{ Work on this paper supported in part by NSF grant
    CCF-1319376.  } \and Shalmoli Gupta\thanks{Work on this paper supported in part by NSF grant
    CCF-1319376.  }\and Kent Quanrud\thanks{Work on this paper supported in part by NSF grants CCF-1319376,
    CCF-1421231, and CCF-1217462.  } \and
  \\
  Dept.\ of Computer Science, Univ.\ of Illinois, Urbana IL 61801, USA \\
  \email{\{chekuri,sgupta49,quanrud2\}@illinois.edu} } 

\maketitle

\begin{abstract}
  We consider the problem of maximizing a nonnegative submodular set
  function  subject to a
  -matchoid constraint in the single-pass streaming
  setting. Previous work in this context has considered streaming
  algorithms for modular functions and monotone submodular
  functions. The main result is for submodular functions that are {\em
    non-monotone}. We describe deterministic and randomized algorithms
  that obtain a -approximation using -space, where  is an upper bound on the cardinality of the
  desired set. The model assumes value oracle access to  and
  membership oracles for the matroids defining the -matchoid
  constraint.
\end{abstract}

\section{Introduction}


Let  be a set function defined
over a ground set .  is \newterm{submodular} if it
exhibits decreasing marginal values in the following sense: if  is any element, and  with  are any two nested sets, then . The gap  is called the \newterm{marginal
  value} of  with respect to  and , and denoted . An
equivalent characterization for submodular functions is that for any
two sets , . 

Submodular functions play a fundamental role in classical
combinatorial optimization where rank functions of matroids, edge
cuts, coverage, and others are instances of submodular functions (see
\cite{Schrijver_book,Fujishige_book}). More recently, there is a large
interest in constrained submodular function optimization driven both
by theoretical progress and a variety of applications in computer
science. The needs of the applications, and in particular the sheer
bulk of large data sets, have brought into focus the development of
fast algorithms for submodular optimization. Recent work on the
theoretical side include the development of faster worst-case
approximation algorithms in the traditional sequential model of
computation \cite{bv-famsf-14,ijbICML-13,ChekuriTV15}, algorithms in
the streaming model \cite{bmkk-sso-14,ck-smms-14} as well as in the
map-reduce model of computation \cite{kmvv-13}.




In this paper we consider constrained submodular function
\emph{maximization}. The goal is to find  where  is a
\newterm{downward-closed} family of sets; i.e., 
and  implies .  is
also called an \newterm{independence family} and any set  is called an \newterm{independent set}. Submodular
maximization under various independence constraints has been
extensively studied in the literature. The problem can be easily seen
to be NP-hard even for a simple cardinality constraint as it
encompasses standard NP-hard problems like the Max--cover
problem. Constrained submodular maximization has found several new
applications in recent years. Some of these include data summarization
\cite{hb-11,sssj-12,dkr-13}, influence maximization in social networks
\cite{kkt-03,cyy-09,ccy-10,gfl-11,ss-13}, generalized
assignment\cite{ccpv-07}, mechanism design \cite{bik-07}, and network
monitoring \cite{lkgfvg-07}.

In some of these applications, the amount of data involved is much
larger than the main memory capacity of individual computers. This
motivates the design of space-efficient algorithms which can process
the data in \textit{streaming} fashion, where only a small fraction of
the data is kept in memory at any point. There has been some recent
work on submodular function maximization in the streaming model,
focused on \emph{monotone} functions (i.e. , whenever
). This assumption is restrictive from both a
theoretical and practical point of view.

\begin{wrapfigure}{r}{.45\textwidth}
\centering
  \includegraphics[width=.45\textwidth]{constraints.pdf}
\caption{Hierarchy of set systems}
  \labelfigure{constraints}
\end{wrapfigure}
In this paper we present streaming algorithms for non-monotone
submodular function maximization subject to various combinatorial
constraints, the most general being a \refterm{-matchoid}.
\refterm[-matchoid]{-matchoid's} generalize many basic
combinatorial constraints such as the cardinality constraint, the
intersection of  matroids, and matchings in graphs and
hyper-graphs.  A formal definition of a \refterm{-matchoid} is given in
\refsection{preliminaries}. We consider the abstract
\refterm{-matchoid} constraint for theoretical reasons, and most
constraints in practice should be simpler. We explicitly consider the
cardinality constraint and obtain an improved bound.

We now describe the problem formally. We are presented a groundset of
elements , with no assumption
made on the order or the size of the datastream. The goal is to select
an independent set  (where independence is
defined by the \refterm[-matchoid]{-matchoid}), which maximizes
a nonnegative submodular function  while using as little space as
possible. We make the following assumptions: (i) the function  is
available via a value oracle, that takes as input a set  and returns the value ; (ii) the independence family
 is available via a membership oracle with some
additional information needed in the \refterm{-matchoid} setting;
and (iii) the constraints specify explicitly, and a priori, an upper
bound  on the number of elements to be chosen. We discuss these in
turn.  The availability of a value oracle for  is a reasonable and
standard assumption in the sequential model of computation, but needs
some justification in restrictive models of computation such as
streaming where the goal is to store at any point of time only a small
subset of the elements of . Can  be evaluated
without having access to all of ? This of course depends
on . \cite{bmkk-sso-14} gives several examples of interesting and
useful functions where this is indeed possible. The second assumption
is also reasonable if, as we remarked, the \refterm{-matchoid}
constraint is in practice going to be a simple one that combines basic
matroids such as cardinality, partition and laminar matroid
constraints that can be specified compactly and implicitly. Finally,
the third assumption is guided by the fact that an abstract model of
constraints can in principle lead to every element being chosen. In
many applications the goal is to select a small and important subset
of elements from a much larger set; and it is therefore reasonable to
expect knowledge of an upper bound on how many can be chosen.
Submodular set functions are ubiquitous and arise explicitly and
implicitly in a variety of settings. The model we consider in this
paper may not be useful directly in some important scenarios of
interest. Nevertheless, the ideas underlying the analysis in the
streaming model that we consider here may still be useful in speeding
up existing algorithms and/or reduce their space usage.


As is typical for streaming algorithms, we measure performance in four
basic dimensions: (i) the approximation ratio , where 
is the output of the algorithm and  is the value of an optimal
solution; (ii) the space usage of the algorithm; (iii) the update time
or the time required to process each stream element; and (iv) the
number of passes the algorithm makes over the data stream.


\begin{table}[t]
  \begingroup
  \footnotesize \def\arraystretch{1.6}
  \newcolumntype{C}{>{\centering\arraybackslash}X}\newcolumntype{D}[1]{>{\hsize=#1\hsize\centering\arraybackslash}X}\begin{tabularx}{\textwidth}{ | D{.9} | D{1} | D{1.2} | D{.8} |
      D{1.1} | }
    \cline{2-5} \multicolumn{1}{ c| }{} & \multicolumn{2}{ |c| }{offline} & \multicolumn{2}{ |c| }{streaming} \\
    \hline constraint & monotone & nonnegative & monotone & nonnegative \\
    \hline cardinality &  \cite{nwf-mssf1-78} &  \cite{bfns-smcc-14} &  &  (R,)\\
\hline matroid &  (R) \cite{ccpv-11} &  (R) \cite{fns-ucga-11} &  \cite{ck-smms-14} &  (R,) \\ \hline matchings &  \cite{fnsw-iakes-11}&  \cite{fnsw-iakes-11}&  \cite{ck-smms-14}&  (R,) \\
    \hline -matchings &  \cite{fnsw-iakes-11} &  \cite{fnsw-iakes-11} &  () &  (R,)\\ \hline rank  \mbox{hypergraph} -matching &  (R) \cite{fnsw-iakes-11} &  \cite{fnsw-iakes-11} &  () &  (R,)
    \\
    \hline intersection of \mbox{ matroids} &  \cite{lsv-smmm-10} &  \cite{lsv-smmm-10}&  \cite{ck-smms-14} &  (R,)
    \\
    \hline -matchoids &  \cite{fnw-mssf2-78,ccpv-11} &  (R)
\cite{fns-ucga-11,cvz-mrcrs-11}&  () &  (R,)
    \\
    \hline \end{tabularx}
  \endgroup
  \vspace{1ex}
  \caption{Best known approximation bounds for submodular
    maximization. Bounds for randomized algorithms that hold in
    expectation are marked (R). For hypergraph -matchings
    and matroid intersection,  is fixed. In the results for
    -matchoids,  goes to zero as  increases. New bounds
    attained in this paper are marked (). All new bounds except
    for the cardinality constraint are the first bounds for their
    class. The best previous bound for the cardinality constraint is
    about .0893, by \cite{bfs-osmp-15}.}
  \labeltable{results}
\end{table}

\paragraph{Our results.} We develop randomized and deterministic
algorithms that yield an -approximation for maximizing a
non-negative submodular function under a \refterm{-matchoid}
constraint in the one-pass streaming setting. The space usage is , essentially matching recent algorithms for the simpler
setting of maximizing a monotone submodular function subject to a
cardinality constraint \cite{bmkk-sso-14}. The randomized algorithm
achieves better constants than the deterministic algorithm. As far as
we are aware, we present the first streaming algorithms for
non-monotone submodular function maximization under constraints beyond
cardinality.  We give an improved bound of  for
the cardinality constraint.  For the monotone case our bounds match
those of Chakrabarti and Kale \cite{ck-smms-14} for a single pass; we
give a self-contained algorithm and analysis. \reftable{results}
summarizes our results for a variety of constraints.

\iffalse
\subsection{Our Results}
We give a simple and efficient streaming algorithm for submodular
maximization subject to a \refterm{-matchoid} constraint, which
generalizes a wide class of independence constraints. Detailed
definition of the constraints are presented in
\refsection{preliminaries}.
\begin{itemize}
\item We give an -approximation for maximizing
  nonnegative submodular function subject to
  \refterm{-matchoid}s. The algorithm makes a single pass over the
  datastream and uses  memory where 
  is an upper bound on the rank of the
  \refterm{-matchoid}. \refterm{-matchoid}s generalizes
  intersection of -matroids, and -matching in hypergraph of rank
  . Thus the result extends to these special cases as well. In
  particular for a single matroid we get -approximation in a single pass. Refer
  \refsection{nonnegative-matchoid}.

\item As a corollary of the technique developed in this paper we get a
   approximation in the monotone case, which matches the existing
  result of Chakrabarti and Kale \cite{ck-smms-14}, and is
  conceptually much simpler.

\end{itemize}
\fi



\paragraph{A brief overview of techniques.} Streaming algorithms for constrained modular and submodular function
optimization are usually clever variations of the greedy algorithm,
which picks elements in iterations to maximize the gain in each
iteration locally while maintaining feasibility.  For monotone
functions, in the offline setting, greedy gives a
-approximation for the \refterm{-matchoid} constraint and
a -approximation for the cardinality constraint
\cite{fnw-mssf2-78}. The offline greedy algorithm cannot be directly
implemented in streams, but we outline two different strategies that
are still greedy in spirit. For the cardinality constraint, Badanidiyuru \etal \cite{bmkk-sso-14}
designed an algorithm that adds an element to its running solution 
only if the marginal gain is at least a threshold of about
. Although the quantity  is not known a priori, they
show that it lies in a small and identifiable range, and can be
approximated with  well-spaced guesses. The algorithm then
maintains  solutions in parallel, one for each
guess. Another strategy from Chakrabarti and Kale \cite{ck-smms-14},
based on previous work for matchings \cite{fkmsz-gpssm-05,m-fgmds-05}
and matroid constraints \cite{abv-11} with modular weights, will
consider deleting elements from  when adding a new element to 
is infeasible. More specifically, when a new element  is
encountered, the algorithm finds a subset  such that
 is feasible, and compare the gain  to a quantity representing the value that
 adds to . In the modular case, this may be the sum of weights
of elements in ; for monotone submodular functions, Chakrabarti and
Kale used marginal values, fixed for each element when the element is
added to , as proxy weights instead.



The non-monotone case is harder because marginal values can be
negative even when  is non-negative. The natural greedy algorithm
fails for even the simple cardinality constraint, and the best offline
algorithms for nonnegative submodular maximization are uniformly
weaker (see \reftable{results}).  To this end, we adapt techniques
from the recent work of Buchbinder \etal \cite{bfns-smcc-14} in our
randomized algorithm, and techniques from Gupta \etal \cite{grst-10}
for the deterministic version. Buchbinder \etal randomized the
standard greedy algorithm (for cardinality) by repeatedly gathering
the top (say)  remaining elements, and then randomly picking only
one of them. We adapt this to the greedy setting by adding the top
elements to a buffer  as they appear in the stream, and randomly
adding an element from  to  only when  fills up. What remains
of  at the end of the stream is post-processed by an offline
algorithm. Gupta \etal gave a framework for adapting any monotone
submodular maximization algorithm to nonnegative submodular functions,
by first running the algorithm once to generate one independent set
, then running the algorithm again on the complement of  to
generate a second set , and running an unconstrained maximization
algorithm on  to produce a third set , finally returning the
best of , , and . Our deterministic streaming algorithm
is a natural adaptation, piping the rejected elements of one instance
of a streaming algorithm directly into a second instance of the same
algorithm, and post-processing all the elements taken by the first
streaming instance. Both of our algorithms require that we limit the
number of elements ever added to , which then limits the size of
the input for the post-processor. This limit is enforced by the idea
of additive thresholds from \cite{bmkk-sso-14} and a simple but subtle
notion of value that ensures the properties we desire.



\iffalse ; if  is the current feasible solution at the beginning of
iteration and  is the set of
elements that can be added to  while maintaining feasibility,
greedy picks the element .  A special
case that illustrates the main ideas is the simple cardinality
constraint where the goal is to solve . In the
offline setting the greedy algorithm picks in each iteration the
element that \fi


\paragraph{Related work.}
\labelsection{sec:reltd_result}


There is substantial literature on constrained submodular function
optimization, and we only give a quick overview.  Many of the basic
problems are NP-Hard, so we will mainly focus on the development of
approximation algorithms.  The (offline) problem  for various constraints has been extensively
explored starting with the early work of Fisher, Nemhauser, Wolsey on
greedy and local search algorithms
\cite{nwf-mssf1-78,fnw-mssf2-78}. Recent work has obtained many new
and powerful results based on a variety of methods including variants
of greedy \cite{grst-10,bfns-smcc-14,bfjs-12}, local search
\cite{LeeMNS10,lsv-smmm-10,FilmusW14}, and the multilinear relaxation
\cite{ccpv-11,KulikST13,BansalKNS12,cvz-mrcrs-11}. Monotone submodular
functions admit better bounds than non-monotone functions (see
\reftable{results}).  For a \refterm{-matchoid} constraint, which
is our primary consideration, an -approximation can be
obtained for non-negative functions. Recent work has also obtained new
lower bounds on the approximation ratio achievable in the oracle model
via the so-called symmetery gap technique \cite{Vondrak13}; this also
yields lower bounds in the standard computational models \cite{dv-12}.

Streaming algorithms for submodular functions are a very recent
phenomenon with algorithms developed recently for monotone submodular
functions \cite{bmkk-sso-14,ck-smms-14}. \cite{bmkk-sso-14} gives a
 approximation for monotone functions under cardinality
constraint using  space. \cite{ck-smms-14} focuses
on more general constraints like interesctions of -matroids and
rank  hypergraphs, giving an approximation of  using a single
pass. Their algorithm extends to multiple passes, with an
approximation bound of  with  passes.  The main focus of \cite{kmvv-13} is on the map-reduce
model although they claim some streaming results as well.

Related to the streaming models are two {\em online} models where
elements arrive in an online fashion and the algorithm is required to
maintain a feasible solution  at all times; each element on arrival
has to be processed and any element which is discarded from  at any
time cannot be added back later. Strong lower bounds can be shown in
this model and two relaxations have been considered.  In the
\newterm{secretary model}, the elements arrive according to a random
permutation of the ground set and an element added to  cannot be
discarded later. In the secretary model, constant factor algorithms
are known for the cardinality constraint and some special cases of a
single matroid constraint \cite{grst-10,bhz-13}.  These algorithms
assume the stream is randomly ordered and their performance degrades
badly against adversarial streams; the best competitive ratio for a
single general matroid is  (where  is the rank of the
matroid).  Recently, Buchbinder \etal \cite{bfs-osmp-15} considered a
different relaxation of the online model where \newterm{preemptions}
are allowed: elements added to  can be discarded later. Algorithms
in the preemptive model are usually streaming algorithms, but the
converse is not true (although the one-pass algorithms in
\cite{ck-smms-14} are preemptive). For instance, the algorithm in
\cite{bmkk-sso-14} maintains multiple feasible solutions and our
algorithms maintain a buffer of elements neither accepted nor
rejected. The space requirement of an algorithm in the online model is
not necessarily constrained since in principle an algorithm is allowed
to keep track of all the past elements seen so far. The main result in
\cite{bfs-osmp-15}, as it pertains to this work, is a randomized
-competitive algorithm for cardinality constraints using
-space. As \reftable{results} shows, we obtain a
-competitive algorithm for this case using -space.

\iffalse
\begin{itemize}
\item \textit{Offline Submodular Maximization.} The (offline)
  submodular optimization problem has been very well studied. For
  monotone functions, the seminal works of Fisher, Nemhauser, and
  Wolsey \cite{nwf-mssf1-78} showed that greedy algorithm gives 
  approximation for arbitrary matroid and -approximation for
  cardinality constraint. They also generalized the analysis to show a
  bound of  for -matroids and -independence system. In
  fact this simple greedy algorithm is tight for the case of
  cardinality constraint in the value oracle model. This special case
  already captured the Max--Cover problem, and as Feige \cite{f-98}
  showed, that  is the best approximation possible unless
  . This raised the natural question, whether the results for
  matroid constraint can be made tight. And it was answered
  affirmitively in the highly influential paper by Chekuri et
  al. \cite{ccpv-11}. They gave an -approximation for matroid
  constraint using multilinear relaxation and continuous greedy
  approach.

  Most of these results were concerned with monotone submodular
  function and little was known for non-monotone functions. Note that
  for non-monotone functions, even the unconstrained problem is
  NP-Hard as the well-known MaxCut problem is a special
  case. Buchbinder \etal \cite{bfjs-12} gave randomized algorithm
  which achieves a tight  approximation for the unconstrained
  problem. Later they extended the result for the cardinality case,
  achieveing a tight  approximation, when 
  \cite{bfns-smcc-14}. Gupta et al. \cite{grst-10} adapted the
  classical greedy algorithm for montone functions to give an
  -approximation for non-monotone function subject to a
  p-independence system.

  \textit{Knapsack Constraint.} Sviridenko extended the greedy
  algorithm with partial enumeration to give an 
  approximation for maximizing monotone submodular function with
  knapsack constraint. Kulik et al. \cite{kst-11} generalized the
  result for -knapsack constraints. Later Lee et al. \cite{lmns-09}
  further extended the result for non-monotone functions to give a
  local search based  approximation for -knapsack
  constraints. Gupta et al. \cite{grst-10} showed that even the greedy
  algorithm can be adapted to give a constant factor for this problem.

\item \textit{Online Submodular Maximization.} The subject of online
  submodular maximization is relatively new. For monotone submodular
  function under cardinality constraint Gomes et al. \cite{gk-10} gave
  a simple greedy algorithm, where at any point of time the algorithm
  maintains a set of  elements, and whenever a new element comes,
  if swaping in this element with some other element already in
  solution improves the solution value, then such a swap is
  performed. However as shown by Ashwinkumar et
  al. \cite{bmkk-sso-14}, the performance of the algorithm can be as
  bad as . In the same paper, they gave the first efficient
  algorithm for the cardinality case, which requires only a single
  pass over the data, uses  memory and
  gives a  approximation.  Their algorithm is based on
  the idea, that if  is known then, making greedy choices with
  respect to  is highly effective. They further gave the novel
  idea that  can be estimated using lazy evaluation. Kumar et
  al. \cite{kmvv-13} considered the problem subject to knapsack and
  -independence system constraints in both parallel and streaming
  setting. Although their algorithm in streaming model performs only a
  single pass on the data and gives an approximation bound of  for cardinality constraint, but the space requirement
  depends on the datastream size. For the case of modular function
  maximization subject to -matroid constraints, Ashwinkumar
  \cite{abv-11} gave a one-pass -approximation algorithm. They also gave a matching lower bound
  when the algorithm is only allowed to store a feasible
  solution. Chakrabarti et al. extended the result for monotone
  submodular function to get a -approximation in single pass and
  -approximation in  passes
  for the special case of -partition matroids.

\item \textit{Secretary Problems.} Another model in which the problem
  has been studied is the secretary model. In this model also, the
  elements are processed in streaming fashion. However now the stream
  is \textit{randomly ordered}, and there is a stronger requirement
  any algorithm must irrevocably commit or permanently discard an
  element. There is a string of work for the constrained submodular
  maximization problem in this model
  \cite{bik-07,bdgit-09,kp-09,grst-10}. However the algorithms
  strongly assume the random order of stream and performance degrades
  arbitrarily for adversarial order.
\end{itemize}
\fi

\paragraph{Paper organization.} \refsection{preliminaries} reviews
combinatorial definitions and introduces the notion of incremental
values. \refsection{streaming-greedy} analyzes an algorithm that works
for monotone submodular functions, and
\refsection{randomized-streaming-greedy} adapts this algorithm to the
non-monotone case. In \refsection{iterated-streaming-greedy}, we give
a deterministic streaming algorithm with slightly weaker guarantees.

\section{Preliminaries}
\labelsection{preliminaries}










\paragraph{Matroids.}
A \newterm{matroid} is a finite set system , where  is a set and
 is a family of subsets
such that:\begin{inline_properties}
\item ,
\item If , and , then ,
\item If  and , then there is an
  element  such that .
\end{inline_properties}
In a matroid ,  is
called the \newterm{ground set} and the members of  are
called \newterm{independent sets} of the matroid. The bases of
 share a common cardinality, called the \newterm{rank} of
.







\paragraph{Matchoids.}
Let  be  matroids over
overlapping groundsets. Let  and

The finite set system  is a \newterm{-matchoid} if
for every element ,  is a member of
 for at most  indices .
-matchoids generalizes matchings and intersections of matroids,
among others (see \reffigure{constraints}).




\paragraph{Maximizing submodular functions under a -matchoid
  constraint.}


Let  be a set of elements,  a nonnegative submodular function on , and
 a -matchoid for some integer . We want to approximate .
There are several polynomial-time approximation algorithms that give
an -approximation for this problem, with better bounds
for simpler constraints (see \reftable{results}).
These algorithms are used as a black box called \newalgo{Offline},
with approximation ratio denoted by : if \refalgo{Offline}
returns , then 
(possibly without expectation, if \refalgo{Offline} is deterministic).





\paragraph{Incremental Value.}

\newcommand{\incvalue}{\nu}
\newcommand{\incrementalvalueof}[3]{\incvalue\parof{#1,#2,#3}}
\newcommand{\incvalueof}{\incrementalvalueof}


Let  be a ground set, and let  be a submodular function. For a set  and an element , what is the value that  adds
to ? One idea is to take the margin  of adding  to . However, because  is not necessarily
modular, we can only say that 
without equality. It is natural to ask for a different notion of value
where the values of the parts sum to the value of the whole.

Let  be an \emph{ordered} set and  be a set function.  For a set  and element , the
\newterm{incremental value} of  in , denoted
, is defined as

The key point of incremental values is that they capture the entire
value of a set. The following holds for \emph{any} set function.
\begin{lemma}\labellemma{sum-incremental-values}Let  be an ordered set,  a set function, and  a set. Then
  
  \begin{proof}
    Enumerate  in order, and let  denote the first  elements in . We
    have,
    
  \end{proof}
\end{lemma}
When  is submodular, we have decreasing incremental values
analogous (and closely related) to decreasing marginal returns of
submodular function.
\begin{lemma}\labellemma{decreasing-incremental-values}
  Let  be two nested subsets of an
  ordered set , let 
  be submodular, and let . Then
  
  \begin{proof}
    Let  and . Since , clearly . We have,
    
    where the inequality follows by submodularity.
  \end{proof}
\end{lemma}
The following is also an easy consequence of submodularity.
\begin{lemma}
  \labellemma{marginal-incremental-values-ineq}
  Let  be an ordered set of elements, let  be a submodular function,  two sets, and . Then
  
  \begin{proof}
    Let  and . By submodularity, we have,
    
  \end{proof}
\end{lemma}
\FloatBarrier
\section{Streaming Greedy}\labelsection{streaming-greedy}

\newcommand{\finalset}{\tilde{S}}\newcommand{\setbefore}[1]{S_{#1}^-} \newcommand{\setafter}[1]{S_{#1}^+} \newcommand{\takens}{U}\newcommand{\taken}{u} \newcommand{\candidates}{C}
\newcommand{\candidatesfor}[1]{\candidates_{#1}}
\newcommand{\gain}{\delta} \newcommand{\gainof}[1]{\delta_{#1}} \newcommand{\deleted}{d} \newcommand{\deleteds}{\takens \setminus \finalset} 




\begin{figure}[t]
  \centering
  \begin{minipage}{6.9cm}
    \begin{framed}
      \begin{pseudocode}
        \begin{routine}{Streaming-Greedy}{,}
          \\
          while (stream is not empty) \+\\
           next element in the stream\\
          Se \\\commentcode{ satisfies }\\
          if  \\
          \>  \\
          \< end while \- \\
          return 
        \end{routine} \end{pseudocode}
      \vspace{.2ex}
    \end{framed}
  \end{minipage}
  \qquad
  \begin{minipage}{6.4cm}
    \begin{framed}
      \begin{pseudocode}
        \begin{routine}{Exchange-Candidates}{,}
          \\
          for  \\
          \> if  and \\
          \> \> \\
          \> \> \\
          \> \> \commentcode{ is a circuit}\\
          \> \> \\
          \> \>  \\
          \> end if \\
          end for\\
          return 
        \end{routine}
      \end{pseudocode}
    \end{framed}
  \end{minipage}
\end{figure}



Let  be a -matchoid and  a submodular
function. The elements of  are presented in a stream, and
we order  by order of appearance. We assume value oracle
access to , that given , returns the value
. We also assume membership oracles for each of the 
matroids defining : given , there
is an oracle for  that returns whether or not .



We first present a deterministic streaming algorithm
\refalgo{Streaming-Greedy} that yields an
-{\allowbreak}approximation for monotone submodular
functions, but performs poorly for non-monotone functions. The primary
motivation in presenting \refalgo{Streaming-Greedy} is as a building
block for a randomized algorithm \refalgo{Randomized-Streaming-Greedy}
presented in \refsection{randomized-streaming-greedy}, and a
deterministic algorithm \refalgo{Iterated-Streaming-Greedy} presented
in \refsection{iterated-streaming-greedy}. The analysis for these
algorithms relies crucially on properties of
\refalgo{Streaming-Greedy}.

\refalgo{Streaming-Greedy} maintains an independent set ; as an element arrives in the stream, it is either
discarded or added to  in exchange for a well-chosen subset of .
The threshold for exchanging is tuned by two nonnegative parameters
 and .  At the end of the stream,
\refalgo{Streaming-Greedy} outputs .

The overall strategy is similar to previous algorithms developed for
matchings \cite{fkmsz-gpssm-05,m-fgmds-05} and intersections of
matroids \cite{abv-11} when  is modular, and generalized by
\cite{ck-smms-14} to monotone submodular functions.  There are two
main differences. One is the use of the additive threshold
. The second is the use of the incremental value . By
using incremental value, the value of an element  is not
fixed statically when  is first added to , and increases over
time as other elements are dropped from . These two seemingly minor
modifications are crucial to the eventual algorithms for non-monotone
functions.



We remark that \refalgo{Streaming-Greedy} also fits the online
preemptive model.


\newcommand{\replacement}{e(\deleted)} 

\paragraph{Outline of the analysis:} Let  be some
fixed feasible set (we can think of  as an optimum set).  In the
offline analysis of the standard greedy algorithm one can show that
, where  is the output of greedy; for
the monotone case this implies that .  The
analysis here hinges on the fact that each element of 
is available to greedy when it chooses each element.  In the streaming
setting, this is no longer feasible and hence the need to remove
elements in favor of new high-value elements.  To relate ,
the final output, to , we consider , the set of all elements
ever added to . The analysis proceeds in two steps.

First, we upper bound  by  as 
Second, we upper bound  as 
For , we obtain , which yields  when  is monotone (for ); this gives
the same bound as \cite{ck-smms-14}.  The crucial difference is that
we are able to prove an upper bound on the size of , namely,
; hence, if we choose the threshold
 to be  for some parameter  we have . This will play a critical role in analyzing the non-monotone
case in the subsequent sections that use 
as a black box. The upper bound on  is achieved by the definition
of  and the threshold ; we stress that this is not
as obvious as it may seem because the function  can be non-monotone
and the marginal values can be negative.



\iffalse In the preceding literature for similar offline algorithms, a
competing independent set  is typically compared
directly to the output set . In the offline case, the
elements of  and the elements of  are evaluated in the
same view, and the algorithm's decision to take an element in
 over an element in  speaks to their relative
values. Such direct comparisons between  and  are
unavailable in the streaming setting, where an element in  may be
rejected long before any element in  has appeared, with no
direct comparison ever made.

Instead, we try to relate  to  by way of the set
. First, in \refsection{takens-vs-final-set}, we bound  (hiding dependencies on ). Then, in
\refsection{takens-and-competition-vs-takens}, we bound  (hiding dependencies on ,
, and the rank of ). Together, these two
inequalities bound  by . If  is
monotone, then , so in
\refsection{monotone-competition-vs-final-set}, we combine the two
relations to bound  by .  \fi

\paragraph{Some notation for the analysis:}
\begin{itemize}
\item  denotes the final set returned by
  \refalgo{Streaming-Greedy}.
\item For each element ,  denotes the
  set held by  just before  is processed, and  the
  set held by  just after  is processed. Note that if  is
  rejected, then .
\item  denotes the set of all elements added to  at any
  point in the stream. Note that .
\item For , \setbefore{e}e denotes the set of elements that
   considers exchanging for . Observe
  that  forms a
  partition of .
\item For ,  denotes the {\em gain} from processing . Note
  that  for all ,
  and .
\end{itemize}

\subsection{Relating  to }
\labelsection{takens-vs-final-set}
\newcommand{\exitvalueof}{\chi\parof}

When \refalgo{Streaming-Greedy} adds an element  to , it only
compares the marginal  to the incremental values in its
exchange candidates , and does not directly evaluate the gain  realized by the exchange. The first lemma
derives a lower bound for this gain.
\begin{lemma}\labellemma{gain-over-incremental-value-lost}
  Let  be added to  when processed by
  \refalgo{Streaming-Greedy}. Then
  
\end{lemma}
\begin{proof}
  Since  replaced , by design of
  \refalgo{Streaming-Greedy}, we have,
  
  which, after rearranging, gives
  
  To prove the lemma, it suffices to show that
  
  Let . Note that  and . We have,
  
  as desired.
\end{proof}
One basic consequence of \reflemma{gain-over-incremental-value-lost}
is that every element in  adds a positive and significant
amount  to the value to . This will be crucial later, when
taking  proportional to  limits the size of .
\begin{lemma}\labellemma{size-of-tokens} For all ,  and hence
  .
\end{lemma}
\begin{proof}
  We claim that at any point in the algorithm,  for all , from which the lemma follows
  \reflemma{gain-over-incremental-value-lost} immediately.

  When an element  is added to , it has incremental
  value
  
  As the algorithm continues, elements preceding  in  may be
  deleted while elements after  are added, so
   can only increase with time.
\end{proof}
Returning to the original task of bounding , the difference
 is the set of deleted elements, and the
only handle on these elements is their incremental value at the point
of deletion. For , let  be the
element that  was exchanged for; that is, 
and . For deleted elements , the \newterm{exit value}  of
 is the incremental value of  evaluated when
 is removed from , defined formally as

Here we bound the sum of exit values of .
\begin{lemma}
  \labellemma{sum-exit-values}
  
\end{lemma}
\begin{proof}
  Indeed,
  
\end{proof}
Now we bound .
\begin{lemma}
  \labellemma{takens-bound}
  
\end{lemma}
\begin{proof}
  Recall, for each element  ,
   denotes the element added in exchange of
  . We have,
  
\end{proof}
\begin{remark}
  The preceding lemmas relating  and  do not
  rely on the structure of .
\end{remark}
\subsection{Upper bounding }
\labelsection{takens-and-competition-vs-takens} Let  be any feasible solution. The goal is to
upper bound . Here we use the fact that 
is a -matchoid to frame an exchange argument between  and .


\begin{lemma}\labellemma{nn-submodular-streaming-exchange-lemma}
  Let  be a feasible solution \emph{disjoint}
  from . There exists a mapping  such that
  \begin{results}
  \item Every  appears in the set  for at
    most  choices of .
  \item Every  appears in the set 
    for at most  choices of .
  \item For each ,
    
  \end{results}
\end{lemma}

\begin{proof}
  The high level strategy is as follows. For each matroid
   in the -matchoid , we construct a
  directed acyclic graph  on , where a
  subset of  forms the source vertices and arrows preserve
  \refequation[inequality]{matchoid-exchange-inequality}. Applying
  \reflemma{graphical-span-matching} we get an injection from a subset
  of  into . With care, the union of these
  injections will produce the mapping we seek.

  Let us review and annotate the subroutine
  Se. For each matroid
   in which  spans  (i.e., ), we assemble a subset
   that spans  in
  . Of these, we choose the element  with the smallest incremental value with respect to
  .

  Fix a matroid . Let
  
  be the set of elements in  obstructed by , so to
  speak. For each , add a directed edge
   from  to . Observe that for all ,  spans .

  Let
  
  be the elements deleted specifically for .  Observe that
  . For , the set  spans
  , and for all ,
  
  For each , add the directed edge
   from  to . Observe that for all
  ,
   spans .

  Clearly,  is a directed acyclic graph. The elements
  of  are sources in , and the elements of
   are never sinks. By
  \reflemma{graphical-span-matching}, there exists an injection
   from  to  such that for each , there is a path in  from  to
  . If we write out the path , we have  and
  

  After constructing  for each matroid ,
  define  by
  
  For each , we have
  
  Each  belongs to at most  matroids, so each
   appears in  for at most  values
  of .  Since  covers , and
   avoids , each  appears in  at most  times.
\end{proof}
\begin{remark}
  A similar exchange lemma is given by Badanidiyuru for the
  intersection of  matroids with modular weights \cite{abv-11}, and
  used implicitly by Chakrabarti and Kale in their extension to
  submodular weights. Here we extend the argument to -matchoids and
  frame it in terms of incremental values.
\end{remark}

Now we bound .
\begin{lemma}
  Let  be an independent set. Then
  
\end{lemma}
\begin{proof}
  Let . By submodularity, we have,
  
  Since each  is rejected, and , we have
  
  Apply \reflemma{nn-submodular-streaming-exchange-lemma} to generate
  a mapping . We have,
  
  To bound , we have,
  
  as desired.
\end{proof}

\subsection{A bound for the monotone case}
\labelsection{monotone-competition-vs-final-set} If  is monotone, then  for any set
. If we take  to be the set  achieving , , and , we obtain the followings.
\begin{corollary}\labelcorollary{monotone-bounds}Let  be a -matchoid of rank , and let  be a nonnegative monotone
  submodular function. Given a stream over ,
  \refalgo{Streaming-Greedy}{,} is an online algorithm that
  returns a set  such that
  
\end{corollary}
\begin{remark}
  Although these bounds match those of Chakrabarti and Kale for the
  intersection of  matroids \cite{ck-smms-14},
  \refalgo{Randomized-Greedy} requires more calls to the submodular
  value oracle as the incremental value of an element in  updates
  over time. That said, the number of times a taken element 
  reevaluates its incremental value is proportional to the number of
  times an element in  is deleted, which is at most the
  rank of  and generally considered small compared to the
  size of the stream.  Furthermore, by taking  proportional to
   (a procedure for which is discussed in
  \refsection{estimating-threshold}), we can limit the size of  and
  thereby the number of additional oracle calls generated by shifting
  incremental values.
\end{remark}



\section{Randomized Streaming Greedy}
\labelsection{randomized-streaming-greedy}

\newcommand{\buffer}{B}\newcommand{\bufferlimit}{K}\newcommand{\instance}{G}\newcommand{\finalbuffer}{\tilde{B}}\newcommand{\bestset}{\hat{S}}

\refalgo{Randomized-Streaming-Greedy} adapts
\refalgo{Streaming-Greedy} to nonnegative submodular functions by
employing a randomized buffer  to limit the probability that
any element is added to the running solution .  Like
\refalgo{Streaming-Greedy}, \refalgo{Randomized-Streaming-Greedy}
maintains the invariant . However, when a
``good'' element would have been added to  by
\refalgo{Streaming-Greedy}, it is instead placed in . Once
the number of elements in  hits a limit , we pick one
element in  uniformly at random and add it to  just as
\refalgo{Streaming-Greedy} would.

\begin{figure}
\centering
  \begin{minipage}{6.9cm}
    \begin{framed}
      \begin{pseudocode}
        \begin{routine}{Randomized-Streaming-Greedy}
          ,  \\ while (stream is not empty) \\
          \>  next element in the stream\\
          \> if Se then  \\
          \> if  then \+ \\
          \>  uniformly random from  \\
          \> Se \\\> ,  \\
          \> for all  \\
          \> \> unless \refalgo{Is-Good}{,}\\
          \> \> \> \\
          end if \\
          \< end while \- \\
          \buffer \\
          return 
        \end{routine}
      \end{pseudocode}
    \end{framed}
  \end{minipage}
\qquad
  \begin{minipage}{6.8cm}
    \begin{framed}
      \begin{pseudocode}
        \begin{routine}{Is-Good}{,}
          Se\\
          if  \\
          \> return TRUE\\
          else return FALSE
        \end{routine}
      \end{pseudocode}
    \end{framed}
  \end{minipage}
\end{figure}




Modifying  may break the invariant that the buffer only contains
good elements. Since  is submodular, the incremental value
 of each  may increase if a preceding
element is deleted. Furthermore, the marginal value  of each
buffered element  may decrease as elements are added to
. Thus, after modifying , we reevaluate each  and
discard elements that are no longer good.


Let  be the set of elements remaining in the buffer
 when the stream ends.  We process  with an
offline algorithm to produce a second solution , and finally
return the set  which is the better of  and .

\paragraph{Outline of the analysis.}

Let  be an arbitrary independent set. Let  be the portion fully processed by the online
portion and  the remainder left over in the
buffer and processed offline.

In \refsection{reduction-to-streaming-greedy}, we first show that the
analysis for  largely reduces to that of
\refsection{streaming-greedy}. In particular, this gives us a bound on
. In \refsection{online-plus-offline}, we combine this
with a bound on , guaranteed by the offline algorithm, to
obtain an overall bound on  by . In
\refsection{competition-vs-competition-and-takens}, we finally bound
 with respect to , leveraging the fact that the buffer
limits the probability of elements being added to . In
\refsection{competition-vs-final-set}, we tie together the analysis to
bound  by  for fixed  and .

The analysis reveals that the optimal choice for  is 1, and
that  should be chosen in proportion to , where  is
the rank of the . Since  is not known a priori, in
\refsection{estimating-threshold}, we leverage a technique by
Badanidiyuru \etal \cite{bmkk-sso-14} that efficiently guesses the
 to within a constant factor of the target value. The final
algorithm is then  copies of
\refalgo{Randomized-Streaming-Greedy} run in parallel, each instance
corresponding to a ``guess'' for . One of these guesses is
approximately correct, and attains the bounded asserted in
\reftheorem{final-randomized-greedy-algorithm}.


\begin{theorem}
  \labeltheorem{final-randomized-greedy-algorithm}
  Let  be a -matchoid of
  rank , let  a nonnegative
  submodular function over , and let  be
  fixed. Suppose there exists an algorithm for the offline instance of
  the problem with approximation ratio . Then there exists a
  streaming algorithm using total space
   that, given a stream over , returns a set  such that
  
\end{theorem}




\paragraph{Some notation for the analysis}

\begin{itemize}
\item Let  be the state of  at the end of the stream.
\item Let  be the set of all elements to pass through 
  during the stream.
\item Let  be the set held by  at the end of
  the stream.
\item Let  be
  the set output by \refalgo{Randomized-Streaming-Greedy}.
\end{itemize}
, , and  are random sets depending
on the random selection process from .  is a random
variable depending on , , and the offline
algorithm's own internal randomization.


\subsection{Reducing to \refalgo{Streaming-Greedy}}
\labelsection{reduction-to-streaming-greedy}

If we set the buffer limit  to 1, eliminating the role of the
buffer , then \refalgo{Randomized-Streaming-Greedy} reduces
to the deterministic \refalgo{Streaming-Greedy} algorithm from
\refsection{streaming-greedy}. In
\reffigure{randomized-streaming-greedy-reduced}, we refactor
\refalgo[Randomized-Streaming-Greedy]{Randomized-{\allowbreak}Streaming-{\allowbreak}Greedy}
as a buffer placed upstream from a running instance of
\refalgo{Streaming-Greedy}. The buffer only filters and reorders the
stream, and the analysis of \refalgo{Streaming-Greedy} holds with
respect to this scrambled stream.  More precisely, if  denotes the
random bits dictating , then for any fixed , the analysis
of \refsection{streaming-greedy} still applies. We recap the preceding
analysis for \refalgo{Streaming-Greedy} as it applies here.

\begin{figure}[t]
  \centering
  \begin{minipage}{13.2cm}
    \begin{framed}
      \begin{pseudocode}
        \begin{routine}{Randomized-Streaming-Greedy}{,} Let  be an instance of \alpha\beta \\
          Let  refer to the set  maintained by . \\
           \commentcode{ is a buffer of size
            }\\
          while (stream is not empty) \\
          \>  next element in the stream \\
          \> if \refalgo{Is-Good}{,} then 
          \commentcode{buffers the ``good'' elements}\\
          \> else send  downstream to 
          \commentcode{ will reject }\\
          \> if  then \\
          \> \>  an element from  picked uniformly
          at random \commentcode{ is ``good''}\\
          \> \> \\
          \> \> send  downstream to  \commentcode{ will add  to }\\
          \> \> for all  such that (not \refalgo{Is-Good}{,}))\\
          \> \> \> \\
          \> \> \> send  downstream to  \commentcode{ will reject }\\
          \> \> end for \\
          \> end if\\
          end while\\
          \buffer\\
          Return 
        \end{routine}
      \end{pseudocode}
    \end{framed}
    \caption{\refalgo{Randomized-Streaming-Greedy} rewritten with the
      deterministic portion reduced to \refalgo{Streaming-Greedy}.}
    \labelfigure{randomized-streaming-greedy-reduced}
  \end{minipage}
\end{figure}


\begin{lemma}\labellemma{pointwise-streaming-greedy}
  Let  be fixed parameters. For any , we have
  
  Furthermore, .
\end{lemma}

\subsection{Upper bounding  by }
\labelsection{online-plus-offline}

To bound , where  is any independent
set, we split  into the portion  that escapes the buffer, and the remainder
 captured by the buffer. We bound the
former with \reflemma{pointwise-streaming-greedy} and the latter by
guarantees for \refalgo{Offline} to obtain the following.

\begin{lemma}
  \labellemma{nn-submodular-upper-bound-1}
  For any , we have
  
\end{lemma}
\begin{proof}
  For ease of exposition, let  denote the random bits that dictate
  the random selections from , and let us subscript variables by
   to highlight their dependence.  Let  and . For any fixed ,
  we have,
  
  Here, the expectation surrounding  is generated by the
  offline algorithm , which may be randomized (see,
  for example, \reftable{results}).  Taking expectations of both sides
  over , we have
  
  as desired.
\end{proof}


\subsection{Upper bounding  by }
\labelsection{competition-vs-competition-and-takens}

The remaining challenge is to bound  from below by
some fraction of . The following technical lemma, used similarly
by Buchbinder \etal, gives us a handle on .
\begin{lemma}[\cite{bfns-smcc-14}] \labellemma{bfns-ev-14}Let  be a nonnegative
  submodular function. Suppose  is a random set according to a
  distribution  on  where no element  is picked with probability more than . Then
  . Moreover, for any set
  , .
\end{lemma}

In this case,  is a random set, and we want to upper bound
the probability of an element  appearing in
. Intuitively, taking  large limits the
probability of an element being selected from the buffer, while by
\reflemma{pointwise-streaming-greedy}, taking  large decreases
the number of elements in .
\begin{lemma}\labellemma{probability-taken}
  For any element ,
  
\end{lemma}
\begin{proof}
  An element is added to  (and therefore ) if and only if
  it is selected from  when  reaches
  . By \reflemma{pointwise-streaming-greedy}, we select
  from  at most  times, and each selection is
  made uniformly and independently at random from 
  elements.
\end{proof}

With this, we apply \reflemma{bfns-ev-14} to give the following.
\begin{lemma}\labellemma{nn-submodular-upper-bound-2} Let 
  be a fixed independent set. Then
  
\end{lemma}
\begin{proof}
  By \reflemma{probability-taken}, for all ,
  . The claim then
  follows \reflemma{bfns-ev-14}.
\end{proof}

\subsection{Overall Analysis}
\labelsection{competition-vs-final-set}

Tying together \reflemma{nn-submodular-upper-bound-1} and
\reflemma{nn-submodular-upper-bound-2}, we have the following.
\begin{lemma}\labellemma{nn-submodular-overall-upper-bound} For any , we have
  
\end{lemma}
\begin{proof}
  Composing \reflemma{nn-submodular-upper-bound-1} and
  \reflemma{nn-submodular-upper-bound-2}, we have,
  
  By Bernoulli's inequality,
  
  and the claim follows.
\end{proof}

\subsection{A bound for approximate }
\labelsection{relaxed-competition-vs-final-set} \labelsection{relaxed-competition-vs-final-set} We would like to fix  as a constant fraction of . For
example, taking , where ,
and plugging into \reflemma{nn-submodular-overall-upper-bound} gives
the cleaner bound,

However, the algorithm does not know , and instead we will try
to estimate  approximately. Let us lay out the bound when
 is within a factor of 2 of .
\begin{lemma}
  Let  be a fixed parameter.  If , then
  
  In particular, for , we have
  
\end{lemma}

\subsection{Efficiently estimating }
\newcommand{\thresholds}{\mathcal{A}}
\labelsection{estimating-threshold}

Badanidiyuru \etal showed how to ``guess''  space-efficiently
and in a single pass \cite{bmkk-sso-14}. Let . Clearly, , and by submodularity
of ,

Fix , and suppose we run a parallel copy of
\refalgo{Randomized-Streaming-Greedy} for each  in

and at the end of the stream return the best solution among the  copies. For some , we have

where we get the approximation guarantee in
\reflemma{nn-submodular-overall-upper-bound}.

This strategy requires two passes: one to identify , and the second
running  copies of
\refalgo[Randomized-Streaming-Greedy]{Randomized-{\allowbreak}Streaming-{\allowbreak}Greedy}
in parallel.  We can reduce the number of passes to 1 by updating 
and  on the fly. Enumerate the stream ,
and for for each , let

be the single element maximizing  among the first  elements seen
thus far.  shifts up over through the stream as
 is updated. At each step , we maintain parallel solutions for
each choice of , deleting instances with
 below  and instantiating new instances with
larger values of .

To ensure correctness, it suffices to show that when we instantiate an
instance of
\refalgo[Randomized-Streaming-Greedy]{Randomized-{\allowbreak}Streaming-{\allowbreak}Greedy}
for a new threshold , we haven't skipped over any elements
that we would want to include. Let , i.e.\ . If
 for some , then

a contradiction.

\FloatBarrier
\subsection{Simpler algorithm and better bound for cardinality
  constraint}
\labelsection{cardinality}

\begin{figure}
\centering
  \begin{minipage}{7.15cm}
    \begin{framed}
      \begin{pseudocode}
        \begin{routine}[Randomized-Streaming-Greedy-cardinality]
          {Randomized-Streaming-Greedy}{,}
          ,  \\
          while (stream is not empty) \\
          \>  next element in the stream \\
          \> if  and  then \\
          \> \>  \\
          \> if  then \\
          \> \>  uniformly random from   \\
          \> \> ,  \\
          \> \> for all  s.t.\  \\
          \> \> \> \\
          \> end if \\
          end while \\
          \\
          return 
        \end{routine}
      \end{pseudocode}
    \end{framed}
    \vspace{.5em}
\caption{}
    \labelfigure{randomized-streaming-greedy-cardinality}


  \end{minipage}
\end{figure}

When the -matchoid is simply a cardinality constraint with rank
, we can do better. If we set  in
\refalgo{Randomized-Streaming-Greedy}{,}, then the
algorithm will only try to add to  without exchanging while
, effectively halting once we meet the cardinality
constraint . In
\reffigure{randomized-streaming-greedy-cardinality}, we rewrite
\refalgo{Randomized-Streaming-Greedy}{,} with the
unnecessary logic removed.


\newcommand{\sizeoffinalset}{|\finalset|}
\begin{lemma} \labellemma{full-set-cardinality-bound} If , then .
\end{lemma}

\begin{lemma}
  \labellemma{unfull-set-cardinality-bound} If , then for any set ,
  
\end{lemma}
\begin{proof}
  Fix , and let 
  be the set held by  when  is processed. Since  is
  rejected, and , we have
  
  Summed over all , we have
  
  Finally, we write
   to attain the desired bound.
\end{proof}

\begin{lemma}
  \labellemma{cardinality-constraint-bound}
  For , and  such that , we have
  
\end{lemma}
\begin{proof}
  Let  be an optimal set with 
  and .

  If , then the claim follows
  \reflemma{full-set-cardinality-bound}.  Otherwise,  and by \reflemma{unfull-set-cardinality-bound}, we have
  
  By \reflemma{bfns-ev-14}, we also have
  
  Finally, by the bound for \refalgo{Offline}, we have,
  
  Together, we have
  
  Solving for  and plugging in  and
  , we have
  
  as desired.
\end{proof}

The preceding analysis reveals that the appropriate choice for
 is , where  is the maximum value attainable by a set of 
elements, and that a sufficiently large choice for  is
. As in \refsection{estimating-threshold}, we can
efficiently approximate  by guessing  in increasing
powers of , maintaining at most  instances of
\refalgo[Randomized-Streaming-Greedy-cardinality]{Randomized-Streaming-Greedy}{,}
at any instant. The resulting bound is stronger than previously
derived for a 1-matchoid.

\begin{theorem}
  Let  be a nonnegative submodular
  function over a ground set , and let  be
  fixed. Then there exists a streaming algorithm using total space
   that, given a stream over , returns a set 
  such that  and
  , where  is the maximum value attainable by a set of  elements.
\end{theorem}





\FloatBarrier
\section{A Deterministic Algorithm via Iterated Greedy}
\labelsection{iterated-streaming-greedy}
\labelsection{iterated-streaming-greedy}
\begin{figure}[t]
  \centering
  \begin{minipage}{7.5cm}
\begin{framed}
      \begin{pseudocode}
        \begin{routine}{Iterated-Streaming-Greedy}{,,}
          \commentcode{run \refalgo{Streaming-Greedy} over }\\
          \alpha\beta\groundset
          \\
          \commentcode{ denotes the set  in
            \refsection{streaming-greedy}.}
          \\
          0\beta\groundset
            \setminus U_1\\
          U_1\\
          return 
        \end{routine}
      \end{pseudocode}
    \end{framed}
\end{minipage}
\end{figure}

Gupta \etal gave a framework that takes an offline algorithm for
maximizing a monotone submodular functions and, by running the
algorithm as a black box multiple times over different groundsets,
produces an algorithm for the nonnegative case \cite{grst-10}. Here we
adapt the framework to the streaming setting, employing
\refalgo{Streaming-Greedy} as the blackbox for the monotone case.




We first present \refalgo{Iterated-Streaming-Greedy} as an algorithm
making two passes over . In the first pass we run
\refalgo{Streaming-Greedy}{,} over  as
usual.  Let  denote the set output, and  the set of all
elements added to  at any intermediate point of the algorithm, as
per \refsection{streaming-greedy}. In the second pass, we run
\refalgo{Streaming-Greedy}{,} over the set  of elements that were immediately rejected in the first
pass to produce another independent set . Lastly, we run our
choice of offline algorithm over  to produce a third independent
set . At the end, return the best set among
, , and .

If we pipeline the two instances of \refalgo{Streaming-Greedy}, then
\refalgo{Iterated-Streaming-Greedy} becomes a true streaming algorithm
with only one pass over . When the first instance rejects
an element  outright,  is sent downstream to the second instance
of \refalgo{Streaming-Greedy}. Note that the running time of
\refalgo{Offline} depends on the size of its input , which by
\reflemma{size-of-tokens} is at most .


\begin{lemma}
  Let  be any independent set. Then
  
  Furthermore, if \refalgo{Offline} is a deterministic algorithm, then
  \refalgo{Iterated-Streaming-Greedy} is deterministic and the above
  holds without taking expectations.
\end{lemma}
\begin{proof}
  By submodularity, we have
  
  and
  
  By nonnegative of  and \refequation[equations]{ig1}
  and\refequation[]{ig2}, we have,
  
  By \refcorollary{monotone-bounds}, we have  and
  , and  by assumption. Plugging into the above, and noting
  that  gives the bounds we
  seek.
\end{proof}
\begin{corollary}
  Let  be given. If ,
  then
  
  and the inequality holds without taking expectations if
  \refalgo{Offline} is a deterministic algorithm.
\end{corollary}


The appropriate value of  is guessed efficiently exactly as
described in \refsection{estimating-threshold}. Here, if
 grows too large in an instance of
\refalgo{Iterated-Streaming-Greedy}{,} for some fixed
, then  must be too small and we can terminate the
instance immediately.

\begin{theorem}
  Let  be a -matchoid of rank , let  be a nonnegative submodular
  function over , let  be fixed. Suppose
  there exists an offline algorithm for finding the largest value
  independent set in -matchoid with approximation ratio .
  Then there exists a streaming algorithm using total space
   that, given a stream of , returns a set  such that
  
  If the offline algorithm is deterministic, then the claimed
  algorithm is deterministic and the above bound holds without
  expectation.
\end{theorem}




\bibliographystyle{alpha}\bibliography{submodular_maximization_in_streams}

\appendix





\section{Exchange lemmas for matroids}

\begin{lemma}
  \labellemma{transitivity-span}
  Let  be a matroid, let  be
  two subsets, and let  be two elements.  If 
  spans , and  spans , then  spans .
\end{lemma}
\begin{proof}
  It suffices to assume that  and  are independent sets.

  Extend  to a base  in . Since  extends
  ,  spans , and  is a base in . Since  spans ,  spans .
\end{proof}


Let  be a directed graph. For , let
 denote the set of outgoing neighbors of ,
and  the set of incoming neighbors of .

The following lemma is implicit in Badanidiyuru \cite{abv-11}.
\begin{lemma}\labellemma{graphical-span-matching}
  Let  be a matroid, and  a directed acyclic
  graph over  such that for every non-sink vertex , the outgoing neighbors  of 
  {span} . Let  be an independent set such that no path
  in  goes from one element in  to another. Then
  there exists an injection from  to sink vertices in
   such that each  maps into an element
  reachable from .
\end{lemma}
\begin{proof}
  Restricting our attention to elements reachable from  in
  , let us assume that the elements of  are sources
  (i.e., have no incoming neighbors) in . Let us call an
  element  an ``internal'' element if its is neither
  a sink nor a source in .

  We prove by induction on the number of internal vertices reachable
  from . In the base case, the outgoing neighbors of each  are all sinks, and  is bipartite. For any
  subset ,  spans .
   is independent, so we have . Thus, by Hall's matching
  theorem, there exists an injection  such that each  maps
  into .

  In the general case, let  be an
  internal vertex in . Consider the graph  removing
   and preserving all paths through , defined by,
  
   has one less internal vertex than , the same sink
  vertices as , and a vertex  is
  reachable from  in  iff it is reachable from
   in . For any vertex  that had an outgoing arc into , we
  have
  
  which spans  by \reflemma{transitivity-span}. Since any other
  vertices has the same outgoing arcs, we conclude that
   spans  for any non-sink vertex
  of .

  By induction, there exists an injection from  into the
  sinks of  such that every  is mapped to a
  sink vertex reachable from  in . By construction, these
  vertices are also reachable sinks in , as claimed.
\end{proof}



\end{document}
