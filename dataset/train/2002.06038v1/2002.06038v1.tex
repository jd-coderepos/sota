
\documentclass{article} \usepackage{iclr2020_conference,times}

\iclrfinalcopy


\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}

\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{color}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{xcolor}
\usepackage{array}
\usepackage{longtable}
\usepackage{subfigure}

\newcommand{\pablo}[1]{\textcolor{red}{Pablo: #1}}
\newcommand{\adria}[1]{\textcolor{blue}{Adria: #1}}

\title{Never Give Up: Learning Directed \\Exploration Strategies}



\author{Adri\`a Puigdom\`enech Badia\thanks{Equal contribution.} \quad
  Pablo Sprechmann\footnotemark[1] \quad
  Alex Vitvitskyi\quad
  Daniel Guo\And
  Bilal Piot\quad
  Steven Kapturowski\quad
  Olivier Tieleman\quad
  Mart\'in Arjovsky \And
  Alexander Pritzel \quad
  Andew Bolt\quad
  Charles Blundell \\ \\
  DeepMind
  \texttt{\{adriap, psprechmann, avlife, danielguo,} \\
  \quad \quad \quad \quad \quad \texttt{piot, skapturowski, tieleman,} \\
  \quad \quad \quad \quad \quad \texttt{apritzel, abolt, cblundell\}@google.com} \\
}



\begin{document}

\maketitle

\begin{abstract}
We propose a reinforcement learning agent to solve hard exploration games by learning a range of directed exploratory policies. We construct an episodic memory-based intrinsic reward using k-nearest neighbors over the agent's recent experience to train the directed exploratory policies, thereby encouraging the agent to repeatedly revisit all states in its environment.
A self-supervised inverse dynamics model is used to train the embeddings of the nearest neighbour lookup, biasing the novelty signal towards what the agent can control. We employ the framework of Universal Value Function Approximators (UVFA) to simultaneously learn many directed exploration policies with the same neural network, with different trade-offs between exploration and exploitation.
By using the same neural network for different degrees of exploration/exploitation, transfer is demonstrated from predominantly exploratory policies yielding effective exploitative policies.
The proposed method can be incorporated to run with modern distributed RL agents that collect large amounts of experience from many actors running in parallel on separate environment instances.
Our method doubles the performance of the base agent in all hard exploration in the Atari-57 suite while maintaining a very high score across the remaining games, obtaining a median human normalised score of 1344.0\%. Notably, the proposed method is the first algorithm to achieve non-zero rewards (with a mean score of 8,400) in the game of \textit{Pitfall!} without using demonstrations or hand-crafted features.
\end{abstract}

\section{Introduction}
\label{intro}
The problem of exploration remains one of the major challenges in deep reinforcement learning.  In general, methods that guarantee finding an optimal policy require the number of visits to each state–action pair to approach infinity. Strategies that become greedy after a finite number of steps may never learn to act optimally; they may converge prematurely to suboptimal policies, and never gather the data they need to learn. Ensuring that all state-action pairs are encountered infinitely often is the general problem of maintaining exploration \citep{franccois2018introduction,sutton2018reinforcement}. 
The simplest approach for tackling this problem is to consider stochastic policies with a non-zero probability of selecting all actions in each state, e.g. -greedy or Boltzmann exploration. While these techniques will eventually learn the optimal policy in the tabular setting, they are very inefficient and the steps they require grow exponentially with the size of the state space. Despite these shortcomings, they can perform remarkably well in dense reward scenarios \citep{mnih2015human}. In sparse reward settings, however, they can completely fail to learn, as temporally-extended exploration (also called deep exploration) is crucial to even find the very few rewarding states \citep{osband2016deep}.

Recent approaches have proposed to provide intrinsic rewards to agents to drive exploration, with a focus on demonstrating performance in non-tabular settings. These intrinsic rewards are proportional to some notion of saliency quantifying how different the current state is from those already visited \citep{bellemare2016unifying, haber2018learning,houthooft2016vime,oh2015action,ostrovski2017count,pathak2017curiosity,stadie2015incentivizing}. 
As the agent explores the environment and becomes familiar with it, the exploration bonus disappears and learning is only driven by extrinsic rewards. This is a sensible idea as the goal is to maximise the expected sum of extrinsic rewards. While very good results have been achieved on some very hard exploration tasks, these algorithms face a fundamental limitation: after the novelty of a state has vanished, the agent is not encouraged to visit it again, regardless of the downstream learning opportunities it might allow \citep{bellemare2016unifying, ecoffet2019go, stanton2018deep}.
Other methods estimate predictive forward models \citep{haber2018learning,houthooft2016vime,oh2015action,pathak2017curiosity,stadie2015incentivizing} and use the prediction error as the intrinsic motivation.
Explicitly building models like this, particularly from observations, is expensive, error prone, and can be difficult to generalize to arbitrary environments.
In the absence of the novelty signal, these algorithms reduce to undirected exploration schemes, maintaining exploration in a non-scalable way. To overcome this problem, a careful calibration between the speed of the learning algorithm and that of the vanishing rewards is required \citep{ecoffet2019go,ostrovski2017count}.

The main idea of our proposed approach is to jointly learn separate exploration and exploitation policies derived from the same network, in such a way that the exploitative policy can concentrate on maximising the extrinsic reward (solving the task at hand) while the exploratory ones can maintain exploration without eventually reducing to an undirected policy. 
We propose to jointly learn a family of policies, parametrised using the UVFA framework \citep{schaul2015universal}, with various degrees of exploratory behaviour. 
The learning of the exploratory policies can be thought of as a set of auxiliary tasks that can help build a shared architecture that continues to develop even in the absence of extrinsic rewards \citep{jaderberg2016reinforcement}.
We use reinforcement learning to approximate the optimal value function corresponding to several different weightings of intrinsic rewards.

We propose an intrinsic reward that combines per-episode and life-long novelty to explicitly encourage the agent to repeatedly visit all controllable states in the environment over an episode.
Episodic novelty encourages an agent to periodically revisit familiar (but potentially not fully explored) states over several episodes, but not within the same episode.
Life-long novelty gradually down-modulates states that become progressively more familiar across many episodes.
Our episodic novelty uses an episodic memory filled with all previously visited states, encoded using the self-supervised objective of \citet{pathak2017curiosity} to avoid uncontrollable parts of the state space.
Episodic novelty is then defined as similarity of the current state to previously stored states.
This allows the episodic novelty to rapidly adapt within an episode: every observation made by the agent potentially changes the per-episode novelty significantly.
Our life-long novelty multiplicatively modulates the episodic similarity signal and is driven by a Random Network Distillation error \citep{burda2018exploration}.
In contrast to the episodic novelty, the life-long novelty changes slowly, relying upon gradient descent optimisation (as opposed to an episodic memory write for episodic novelty).
Thus, this combined notion of novelty is able to generalize in complex tasks with large, high dimensional state spaces in which a given state is never observed twice, and maintain consistent exploration both within an episode and across episodes.

This paper makes the following contributions: \emph{(i)} defining an exploration bonus combining life-long and episodic novelty to learn exploratory strategies that can maintain exploration throughout the agent's training process (to \emph{never give up}), \emph{(ii)} to learn a family of policies that separate exploration and exploitation using a conditional architecture with shared weights, \emph{(iii)} experimental evidence that the proposed method is scalable and performs on par or better than state-of-the-art methods on hard exploration tasks.
Our work differs from \citet{savinov2018episodic} in that it is not specialised to navigation tasks, our method incorporates a long-term intrinsic reward and is able to separate exploration and exploitation policies. Unlike \citet{stanton2018deep}, our work relies on no privileged information and combines both episodic and non-episodic novelty, obtaining superior results.
Our work differs from \citet{beyer2019mulex} in that we learn multiple policies by sharing weights, rather than just a common replay buffer, and our method does not require exact counts and so can scale to more realistic domains such as Atari.
The paper is organized as follows. In Section \ref{learning_exploratory} we describe the proposed intrinsic reward. In Section \ref{agent_description}, we describe the proposed agent and general framework. In Section \ref{experiments} we present experimental evaluation.

\section{The never-give-up intrinsic reward}
\label{learning_exploratory}
We follow the literature on curiosity-driven exploration, where the extrinsic reward is augmented with an intrinsic reward (or exploration bonus).
The augmented reward at time  is then defined as , where  and  are respectively the extrinsic and intrinsic rewards, and  is a positive scalar weighting the relevance of the latter.
Deep RL agents are typically trained on the augmented reward , while performance is measured on extrinsic reward  only.
This section describes the proposed intrinsic reward .

Our intrinsic reward  satisfies three properties: \emph{(i)} it rapidly discourages revisiting the same state within the same episode, \emph{(ii)} it slowly discourages visits to states visited many times across episodes, \emph{(iii)} the notion of state ignores aspects of an environment that are not influenced by an agent's actions.

\begin{figure}[t!]
\centering
\includegraphics[page=2,width=0.3\textwidth,clip=true,trim=220 20 220 50]{diagrams_letters.pdf}
\hfill
\vline
\hfill
\includegraphics[page=1,width=0.68\textwidth,clip=true,trim=50 10 30 20]{diagrams_letters.pdf}
\caption{(left) Training architecture for the embedding network (right) NGU's reward generator.}
\label{overview_fig}
\vspace{-2ex}
\end{figure}

We begin by providing a general overview of the computation of the proposed intrinsic reward. Then we provide the details of each one of the components.
The reward is composed of two blocks: an \emph{episodic novelty module} and an (optional) \emph{life-long novelty module}, represented in red and green respectively in Fig.~\ref{overview_fig} (right).
The episodic novelty module computes our episodic intrinsic reward and is composed of an episodic memory, , and an embedding function , mapping the current observation to a learned representation that we refer to as controllable state. At the beginning of each episode, the episodic memory starts completely empty. At every step, the agent computes an episodic intrinsic reward, , and appends the controllable state corresponding to the current observation to the memory .
To determine the bonus, the current observation is compared to the content of the episodic memory. Larger differences produce larger episodic intrinsic rewards. 
The episodic intrinsic reward  promotes the agent to visit as many different states as possible within a single episode. This means that the notion of novelty ignores inter-episode interactions: a state that has been visited thousands of times gives the same intrinsic reward as a completely new state as long as they are equally novel given the history of the current episode.

A life-long (or inter-episodic) novelty module provides a long-term novelty signal to statefully control the amount of exploration across episodes. 
We do so by multiplicatively modulating the exploration bonus  with a life-long curiosity factor, . Note that this modulation will vanish over time, reducing our method to using the non-modulated reward. Specifically, we combine   with  as follows (see also Fig.~\ref{overview_fig} (right)):

where   is a chosen maximum reward scaling (we fix  for all our experiments). Mixing rewards this way, we leverage the long-term novelty detection that  offers, while  continues to encourage our agent to explore all the controllable states.

{\bf Embedding network:}
 maps the current observation to a -dimensional vector corresponding to its controllable state.
Consider an environment that has a lot of variability independent of the agent's actions, such as navigating a busy city with many pedestrians and vehicles. An agent could visit a large number of different states (collecting large cumulative intrinsic rewards) without taking any actions. This would not lead to performing any meaningful form of exploration. 
To avoid such meaningless exploration, given two consecutive observations, we train a Siamese network \citep{bromley1994signature,koch2015siamese}  to predict the action taken by the agent to go from one observation to the next \citep{pathak2017curiosity}. Intuitively, all the variability in the environment that is not affected by the action taken by the agent would not be useful to make this prediction.
More formally, given a triplet  composed of two consecutive observations,  and , and the action taken by the agent , we parameterise the conditional likelihood as 

where  is a one hidden layer MLP followed by a softmax. The parameters of both  and  are trained via maximum likelihood. This architecture can be thought of as a Siamese network with a one-layer classifier on top, see Fig.~\ref{overview_fig} (left) for an illustration. For more details about the architecture, see App.~\ref{embedding_network}, and hyperparameters, see App.~\ref{hyperparameters}.

{\bf Episodic memory and intrinsic reward:} The episodic memory  is a dynamically-sized slot-based memory that stores the controllable states in an online fashion \citep{pritzel2017neural}. 
At time , the memory contains the controllable states of all the observations visited in the current episode, .
Inspired by theoretically-justified exploration methods turning state-action counts into a bonus reward \citep{strehl2008analysis}, we define our intrinsic reward as

where  is the counts for the visits to the abstract state . We approximate these counts  as the sum of the similarities given by a kernel function , over the content of . In practice, pseudo-counts are computed using the -nearest neighbors of  in the memory , denoted by . The constant  guarantees a minimum amount of ``pseudo-counts'' (fixed to  in all our experiments). Note that when  is a Dirac delta function, the approximation becomes exact but consequently provides no generalisation of exploration required for very large state spaces. Following \citet{blundell2016model,pritzel2017neural}, we use the inverse kernel for ,

where  is a small constant (fixed to  in all our experiments),  is the Euclidean distance and  is
a running average of the squared Euclidean distance of the -th nearest neighbors. This running average is used to make the kernel more robust to the task being solved, as different tasks may have different typical distances between learnt embeddings. A detailed computation of the episodic reward can be found in Alg.~\ref{reward_algorithm} in App.~\ref{app:reward_algorithm}.

{\bf Integrating life-long curiosity:} In principle, any long-term novelty estimator could be used as a basis for the modulator . 
We found Random Network Distillation~\citep[RND]{burda2018exploration} worked well, is simple to implement and easy to parallelize. The RND modulator  is defined by introducing a random, untrained convolutional network , and training a predictor network  that attempts to predict the outputs of  on all the observations that are seen during training by minimizing  with respect to the parameters of , .
We then define the modulator  as a normalized mean squared error, as done in \citet{burda2018exploration}:

where  and  are running standard deviation and mean for .
For more details about the architecture, see App.~\ref{rnd_network}, and hyperparameters, see App.~\ref{hyperparameters}.

\section{The Never-give-up agent}
\label{agent_description}
In the previous section we described an episodic intrinsic reward for learning policies capable of maintaining exploration in a meaningful way throughout the agent's training process.
We now demonstrate how to incorporate this intrinsic reward into a full agent that maintains a collection of value functions, each with a different exploration-exploitation trade-off.

Using intrinsic rewards as a means of exploration subtly changes the underlying Markov Decision Process (MDP) being solved: if the augmented reward  varies in ways unpredictable from the action and states, then the decision process may no longer be a MDP, but instead be a Partially Observed MDP (POMDP).
Solving PODMPs can be much harder than solving MDPs, so to avoid this complexity we take two approaches: firstly, the intrinsic reward is fed directly as an input to the agent, and secondly, our agent maintains an internal state representation that summarises its history of all inputs (state, action and rewards) within an episode.
As the basis of our agent, we use Recurrent Replay Distributed DQN~\citep[R2D2]{r2d2} as it combines a recurrent state, experience replay, off-policy value learning and distributed training, matching our desiderata.

Unlike most of the previously proposed intrinsic rewards (as seen in Section~\ref{intro}), the never-give-up intrinsic reward does not vanish over time, and thus the learned policy will always be partially driven by it.
Furthermore, the proposed exploratory behaviour is directly encoded in the value function and as such it cannot be easily turned off. 
To overcome this problem, we proposed to jointly learn an explicit exploitative policy that is only driven by the extrinsic reward of the task at hand.


{\bf Proposed architecture:} We propose to use a universal value function approximator (UVFA)  to simultaneously approximate the optimal value function with respect to a family of augmented rewards of the form .
We employ a discrete number  of values  including the special case of  and  where  is the maximum value chosen. In this way, one can turn-off exploratory behaviour simply by acting greedily with respect to .
Even before observing any extrinsic reward, we are able to learn a powerful representation and set of skills that can be quickly transferred to the exploitative policy.
In principle, one could think of having an architecture with only two policies, one with  and one with . The advantage of learning a larger number of policies comes from the fact that exploitative and exploratory policies could be quite different from a behaviour standpoint. Having a larger number of policies that change smoothly allows for more efficient training. For a detailed description of the specific values of  we use in our experiments, see App.\ref{evaluation_setup}. 
We adapt the R2D2 agent that uses the dueling network architecture of \citet{wang2015dueling} with an LSTM layer after a convolutional neural network. We concatenate to the output of the network a one-hot vector encoding the value of , the previous action , the previous intrinsic reward  and the previous extrinsic reward . We describe the precise architecture in App.~\ref{r2d2_network} and hyperparameters in App.~\ref{hyperparameters}.


{\bf RL Loss functions:} As a training loss we use a transformed Retrace double Q-learning loss. In App.~\ref{app:retrace} we provide the details of the computation of the Retrace loss~\citep{munos2016safe}. In addition, we associate for each  a , with , and . We remark that the exploitative policy  is associated with the highest discount factor  and the most exploratory policy  with the smallest discount factor . We can use smaller discount factors for the exploratory policies because the intrinsic reward is dense and the range of values is small, whereas we would like the highest possible discount factor for the exploitative policy in order to be as close as possible from optimizing the undiscounted return. For a detailed description of the specific values of  we use in our experiments, see App. \ref{evaluation_setup}. 

{\bf Distributed training:}
Recent works in deep RL have achieved significantly improved performance by running on distributed training architectures that collect large amounts of experience from many actors running in parallel on separate environment instances \citep{andrychowicz2018learning, barth2018distributed,  burda2018exploration,espeholt2018impala, horgan2018distributed, r2d2,silver2016mastering}.
Our agent builds upon the work by \cite{r2d2} to decouple learning from acting,
with actors (256 unless stated otherwise) feeding experience into a distributed replay buffer and the learner training on randomly sampled batches from it in a prioritized way \citep{PrioritizedReplay}.
Please refer to App. \ref{evaluation_setup} for details.


\section{Experiments}
\label{experiments}

We begin by analyzing the exploratory policy of the Never Give Up (NGU) agent with a single reward mixture. We perform such analysis by using a minimal example environment in Section \ref{embedding_representation}. We observe the performance of its learned policy, as well as highlight the importance of learning a representation for abstract states.
In Section \ref{montezuma_learned}, we analyze the performance of the full NGU agent, evaluating its effectiveness on the Arcade Learning Environment (ALE; \cite{bellemare2013arcade}). We measure the performance of the agent against baselines on hard exploration games, as well as dense reward games.
We expand on the analysis of the NGU agent by running it on the full set of Atari games, as well as showing multiple ablations on important choices of hyperparameters of the model.

\subsection{Controlled Setting Analysis}
\label{embedding_representation}

In this section we present a simple example to highlight the effectiveness of the exploratory policy of the NGU agent, as well as the importance of estimating the exploration bonus using a controllable state representation.
To isolate the effect of the exploratory policy, we restrict the analysis to the case of a single exploratory policy (, with ).
We introduce a gridworld environment, \emph{Random Disco Maze}, implemented with the pycolab game engine \citep{pycolab}, depicted in Fig. \ref{fig_disco_maze} (left). At each episode, the agent finds itself in a new randomly generated maze of size x. 
The agent can take four actions left, right, up, down, moving a single position at a time. The environment is fully observable. If the agent steps into a wall, the episode ends and a new maze is generated. Crucially, at every time step, the color of each wall fragment is randomly sampled from a set of five possible colors, enormously increasing the number of possible states. 
This irrelevant variability in color presents a serious challenge to algorithms using exploration bonuses based on novelty, as the agent is likely to never see the same state twice.
This experiment is purely exploratory, with no external reward. The goal is to see if the proposed model can learn a meaningful directed exploration policy despite the large visual distractions providing a continual stream of observation novelty to the agent. 
Fig.~\ref{fig_disco_maze} shows the percentage of unique states (different positions in the maze) visited by agents trained with the proposed model and one in which the mapping  is a fixed random projection (i.e.  is untrained).
The proposed model learns to explore any maze sampled from the task-distribution. The agent learns a strategy that resembles depth-first search: it  explores as far as possible along each branch before backtracking (often requiring backtracking a few dozen steps to reach an unexplored area).
The model with random projections, as well as our baseline of RND, do not show such exploratory behaviour\footnote{See video of the trained agent here: \url{https://youtu.be/9HTY4ruPrHw}}. Both models do learn to avoid walking into walls, doing so would limit the amount of intrinsic reward it would receive. However, staying alive is enough: simply oscillating between two states will produce different (and novel) controllable states at every time step.
\begin{figure}[!tbp]
  \centering
  \includegraphics[clip,width=0.2\textwidth]{disco_maze_1.png}
  \hspace{1ex}
  \includegraphics[clip,width=0.2\textwidth]{disco_maze_2.png}
  \hspace{2ex}
    \includegraphics[width=0.35\textwidth]{disco_maze_states.png}
\vspace{-1ex}
    \caption{(Left and Center) Sample screens of Random Disco Maze. The agent is in green, and pathways in black. The colors of the wall change at every time step. (Right) Learning curves for Random projections vs. learned controllable states and a baseline RND implementation.}
    \label{fig_disco_maze}
\vspace{-3ex}
\end{figure}

\subsection{Atari Results}
\label{montezuma_learned}
In this section, we evaluate the effectiveness of the NGU agent on the Arcade Learning Environment (ALE; \citep{bellemare2013arcade}).
We use standard Atari evaluation protocol and pre-processing as described in Tab.~\ref{table_hyper_atari} of App.~\ref{atari_hypers}, with the only difference being that we do not use frame stacking.
We restrict NGU to using the same setting and data consumption as R2D2, the best performing algorithm on Atari \citep{r2d2}.
While we compare our results with the best published methods on this benchmark, we note that different baselines use very different training regimes with very different computational budgets.
Comparing distributed and non-distributed methods is in general difficult.
In an effort to properly assess the merits of the proposed model we include two additional baselines: as NGU is based on R2D2 using the Retrace loss (instead of its n-step objective) we include this as a baseline, and since we use RND as a reward modulator, we also include R2D2 with Retrace using the RND intrinsic reward.
These methods are all run for  billion frames using the same protocol as that of R2D2 \citep{r2d2}.
We detail the use of compute resources of the algorithms in App.~\ref{computation_comparison}. We report the return averaged over  different seeds.

{\bf Architecture:} We adopt the same core architecture as that used by the R2D2 agent to facilitate comparisons. There are still a few choices to make, namely: the size of the learned controllable states, the clipping factor  in (\ref{eq:clipping}), and the number of nearest neighbours to use for computing pseudo-counts in  (\ref{eq:reward_computation}).
We selected these hyperparameters by analysing the performance of the single policy agent, NGU(), on two representative exploration games: \textit{Montezuma's Revenge} and \textit{Pitfall!}. We report this study in App.~\ref{app:single_mixture_ablations}. We used the same fixed set of hyperparameters in all the remaining experiments.


{\bf NGU agent:} We performed further ablations in order to better understand several major design choices of the full NGU agent on a set of  Atari games: the set of  dense reward games chosen to select the hyperparameters of \citet{mnih2015human}, as well as  hard exploration games (\textit{Montezuma's Revenge}, \textit{Pitfall!}, and \textit{Private Eye}). For a detailed description of the results on these games as well as results on more choices of hyperparameters, please see App.\ref{app:ablations}.
The ablations we perform are on the number of mixtures , the impact of the off-policy data used (referred to as CMR below), the maximum magnitude of  (by default  if not explicitly mentioned), the use of RND to scale the intrinsic reward, and the performance of the agent in absence of extrinsic rewards. 
We denote by Cross Mixture Ratio (CMR) the proportion in the training batches of experience collected using different values of  from the one being trained. A CMR of  means training each policy only with data produced by the same , while a CMR of  means using equal amounts of data produced by  and . Our base agent NGU has a CMR of .


The results are shown in Fig.~\ref{fig_ablations}. Several conclusions can be extracted from these results: 
Firstly, sharing experience from all the actors (with CMR of ) slightly harms overall average performance on hard exploration games. This suggests that the power of acting differently for different conditioning mixtures is mostly acquired through the shared weights of the model rather than shared data.
Secondly, we observe an improvement, on average, from increasing the number of mixtures  on hard exploration games.
Thirdly, as one can observe in analyzing the value of , the value of  is the best average performing value, whereas  and  make the average performance worse on those hard exploration games. These values indicate, in this case, the limits in which NGU is either not having highly enough exploratory variants ( too low) or policies become too biased towards exploratory behavior ( too high).
Further, the use of the RND factor seems to be greatly beneficial on these hard exploration games. This matches the great success of existing literature, in which long-term intrinsic rewards appear to have a great impact \citep{bellemare2016unifying, ostrovski2017count, choi2018contingency}.
Additionally, as outlined above, the motivation behind studying these variations on this set of  games is that those hyperparameters are of general effect, rather than specific to exploration. However, surprisingly, with the exception of the case of removing the extrinsic reward, they seem to have little effect on the dense reward games we analyze (with all error bars overlapping). This suggests that NGU and its hyperparameters are relatively robust: as extrinsic rewards become dense, intrinsic rewards (and their relative weight to the extrinsic rewards) naturally become less relevant.
Finally, even without extrinsic reward , we can still obtain average superhuman performance on the 5 dense reward games we evaluate, indicating that the exploration policy of NGU is an adequate high performing prior for this set of tasks.
That confirms the findings of \citet{burda2018large}, where they showed that there is a high degree of alignment between the intrinsic curiosity objective and the hand-designed extrinsic rewards of many game environments.
The heuristics of surviving and exploring what is controllable seem to be highly general and beneficial, as we have seen in the Disco Maze environment in Section \ref{embedding_representation}, as well as on Atari.

\begin{figure}
    \centering
    \includegraphics[width=0.87\textwidth]{hns_barplot.png} 
    \vspace{-2ex}
    \caption{Human Normalized Scores on dense reward and hard exploration games.} 
    \label{fig_ablations}
\vspace{-1ex}
\end{figure}

\begin{table}
\small
\centering
\begin{tabular}{m{2.3cm}|m{1.4cm}m{1.4cm}m{1.4cm}m{1.6cm}m{1.3cm}m{1.2cm}}
Algorithm & Gravitar & MR & Pitfall! & PrivateEye & Solaris & Venture\\ \hline
Human & 3.4k & 4.8k & 6.5k & 69.6k & \textbf{12.3k} & 1.2k \\ \hline
Best baseline & \textbf{15.7k} & \textbf{11.6k} & 0.0 & 11k & 5.5k & 2.0k \\
RND & 3.9k & 10.1k & -3 & 8.7k & 3.3k & 1.9k \\
R2D2+RND & 15.6k0.6k & 10.4k1.2k & -0.50.3 & 19.5k3.5k & 4.3k0.6k & \textbf{2.7k0.0k}\\
R2D2(Retrace) & 13.3k0.6k & 2.3k0.4k & -3.51.2 & 32.5k4.7k & 6.0k1.1k & 2.0k0.0k\\
NGU(N=1)-RND & 12.4k0.8k & 3.0k0.0k & \textbf{15.2k9.4k} & 40.6k0.0k & 5.7k1.8k & 46.437.9\\
NGU(N=1) & 11.0k0.7k & 8.7k1.2k & 9.4k2.2k & 60.6k16.3k & 5.9k1.6k & 876.3114.5\\
NGU(N=32) & 14.1k0.5k & 10.4k1.6k & 8.4k4.5k & \textbf{100.0k0.4k} & 4.9k0.3k & 1.7k0.1k
\end{tabular}
\vspace{-2ex}
\caption{Results against exploration algorithm baselines. Best baseline takes the best result among R2D2~\citep{r2d2}, DQN + PixelCNN~\citep{ostrovski2017count}, DQN + CTS~\citep{bellemare2016unifying}, RND~\citep{burda2018exploration}, and PPO + CoEx~\citep{choi2018contingency} for each game.}
\label{table_action_prediction_montezuma}
\vspace{-2ex}
\end{table}

{\bf Hard exploration games: } 
We now evaluate the full NGU agent on the six hard exploration games identified by \citet{bellemare2016unifying}.
We summarise the results on Tab.~\ref{table_action_prediction_montezuma}. The proposed method achieves on similar or higher average return than state-of-the-art baselines on all hard exploration tasks.
Remarkably, to the best of our knowledge, this is the first method without use of privileged information that obtains a positive score on \textit{Pitfall!}, with NGU()-RND obtaining a best score of 15,200. Moreover, in 4 of the 6 games, NGU() appears to substantially improve against the single mixture case NGU(). This shows how the exploitative policy is able to leverage the shared weights with all the intrinsically-conditioned mixtures to explore games in which it is hard to do so, but still optimize towards maximizing the final episode score.
In Fig.~\ref{hard_explore_hns_graph} we can see these conclusions more clearly: both in terms of mean and median human normalized scores, NGU greatly improves upon existing algorithms.

\begin{figure}
    \centering
    \includegraphics[width=0.87\textwidth]{explore_hns.png} 
    \vspace{-2ex}
    \caption{Human Normalized Scores on the 6 hard exploration games.} 
    \label{hard_explore_hns_graph}
\vspace{-1ex}
\end{figure}

While direct comparison of the scores is interesting, the emphasis of this work is on learning directed exploration strategies that encourage the agent to cover as much of the environment as possible.
In Fig.~\ref{ap_mr_graph} (left) we observe the average episodic return of NGU run with and without RND on \textit{Pitfall!}. NGU() is able to learn a directed exploration policy capable of exploring an average of  rooms per episode, crossing  rooms before receiving the first extrinsic reward. We also observe that, in this case, using RND makes our model be less data efficient. This is also the case for NGU(), as observed on NGU()-RND in  Tab.~\ref{table_action_prediction_montezuma}, the best performing \textit{Pitfall!} agent. We conjecture three main hypotheses to explain this: firstly, on \textit{Pitfall!} (and unlike \textit{Montezuma's Revenge}) rooms are frequently aliased to one another, thus the agent does not obtain a large reward for discovering new rooms. This phenomenon would explain the results seen in Fig.~\ref{ap_mr_graph} (right), in which RND greatly improves the results of NGU(). Secondly, the presence of a timer in the observation acts as a spurious source of novelty which greatly increases the number of unique states achievable even within a single room. Thirdly, as analyzed in Section 3.7 of \cite{burda2018exploration}, RND-trained agents often keep 'interacting with danger' instead of exploring further, and \textit{Pitfall!} is a game in which this can be highly detrimental, due to the high amount of dangerous elements in each room.
Finally, we observe that NGU() obtains better results than NGU(). Our intuition is that, in this case, a single policy should be simpler to learn and can achieve quite good results on this task, since exploration and exploitation policies are greatly similar.

\begin{figure}
        \centering
        \includegraphics[width=0.4\textwidth]{pitfall_ngu_mer.png} 
    \hspace{2ex}
        \includegraphics[width=0.4\textwidth]{ngu_mr.png}  
        \vspace{-2ex}
        \label{ap_mr_graph}
        \caption{Mean episodic return for agents trained (left) \textit{Pitfall!} and (right) \textit{Montezuma's Revenge}.} 
\vspace{-2ex}
\end{figure}
\begin{table}[!t]
\small
\centering
\begin{tabular}{m{2.5cm}|m{1.3cm}m{1.8cm}m{1.6cm}m{2.1cm}m{1.5cm}}
Algorithm & Pong & QBert & Breakout & Space Invaders & Beam Rider\\ \hline
Human & 14.6 & 13.4k & 30.5 & 1.6k & 16.9k \\ \hline
R2D2 & \textbf{21.0} & 408.8k & 837.7 & 43.2k & \textbf{188.2k} \\
R2D2+RND & 20.70.0 & 353.5k41.0k & 815.85.3 & \textbf{54.5k2.8k} & 85.7k9.0k\\
R2D2(Retrace) & 20.90.0 & 415.6k55.8k & 838.37.0 & 35.0k13.0k & 111.1k5.0k\\
NGU(N=1)-RND & -8.11.7 & 647.1k50.5k & \textbf{864.00.0} & 45.3k4.9k & 166.5k8.6k\\
NGU(N=1) & -9.42.6 & \textbf{684.7k8.8k} & \textbf{864.00.0} & 43.0k3.9k & 114.6k2.3k\\
NGU(N=32) & 19.60.1 & 465.8k84.9k & 532.816.5 & 44.6k1.2k & 68.7k11.1k
\end{tabular}
\caption{Results against baselines on dense reward games.}
\label{table_single_mixture_dense_games}
\vspace{-3ex}
\end{table}

{\bf Dense reward games: } Tab.~\ref{table_single_mixture_dense_games} shows the results of our method on dense reward games. NGU() underperforms relative to R2D2 on most games (indeed the same can be said of R2D2(Retrace) that serves as the basis of NGU). Since the intrinsic reward signal may be completely misaligned with the goal of the game, these results may be expected. However, there are cases such as Pong, in which NGU() catastrophically fails to learn to perform well. Here is where NGU() solves this issue: the exploitative policy learned by the agent is able to reliably learn to play the game. Nevertheless, NGU() has limitations: even though its learned policies are vastly superhuman and empirically reasonable, they do not match R2D2 on Breakout and Beam Rider. This suggests that the representations learned by using the intrinsic signal still slightly interfere with the learning process of the exploitative mixture. We hypothesize that alleviating this further by having non-shared representations between mixtures should help in solving this issue.

{\bf Results on all Atari 57 games: }
The proposed method achieves an overall median score of 1354.4\%, compared to 
95\% for Nature DQN baseline, 191.8\% for IMPALA, 1920.6\% for R2D2, and 1451.8\% for R2D2 using retrace loss.
Please refer to App.~\ref{results_all_games} for separate results on individual games. Even though its overall median score is lower than R2D2, NGU maintains good performance on all games, performing above human level on 51 out of the 57 games. This also shows further confirmation that the learned exploitative mixture is still able to focus on maximizing the score of the game, making the algorithm able to obtain great performance across all games.

{\bf Analysis of Multiple Mixtures:} in Fig.~\ref{ngu_evals_graph}, we can see NGU() evaluated with  (used in all reported numerical results) against NGU() evaluated with . We can observe different trends in the games: on \textit{Q*Bert} the policies of the agent seem to converge to the exploitative policy regardless of the  condition, with its learning curve being almost identical to the one shown for R2D2 in \citet{r2d2}. As seen in App.~\ref{results_all_games}, this is common in many games. The second most common occurrence is what we see on \textit{Pitfall!} and \textit{Beam Rider}, in which the policies quantitatively learn very different behaviour.
In these cases, the exploitative learns to focus on its objective, and sometimes it does so by benefiting from the learnings of the exploratory policy, as it is the case in \textit{Pitfall!}\footnote{See videos of NGU on Pitfall with , : \url{https://sites.google.com/view/nguiclr2020}}, where R2D2 never achieves a positive score. Finally, there is the exceptional case of \textit{Montezuma's Revenge}, in which the reverse happens: the exploratory policy obtains better score than the exploitative policy. In this case, extremely long-term credit assignment is required in order for the exploitative policy to consolidate the knowledge of the exploratory policy. This is because, to achieve scores that are higher than k, the agent needs to go to the second level of the game, going through many non-greedy and sometimes irreversible actions. For a more detailed analysis of this specific problem, see App.~\ref{montezuma_hand_crafted}.

\begin{figure}
    \centering
        \includegraphics[width=0.8\textwidth]{ngu32_evals.png}  
        \caption{NGU(N=32) behavior for  (blue) and  (orange).} 
        \label{ngu_evals_graph}
\vspace{-2ex}
\end{figure}

\section{Conclusions}
We present a reinforcement learning agent that can effectively learn on both sparse and dense reward scenarios.
The proposed agent achieves high scores in all Atari hard-exploration games, while still maintaining a very high average score over the whole Atari-57 suite. Remarkably, it is, to the best of our knowledge, the first algorithm to achieve non-zero rewards on the challenging game of \textit{Pitfall!} without relying on human demonstrations, hand-crafted features, or manipulating the state of the environment.
A central contribution of this work is a method for learning policies that can maintain exploration throughout the training process.
In the absence of extrinsic rewards, the method produces a policy that aims at traversing all controllable states of the MDP in a depth-first manner. We highlight that this could have impact beyond this specific application and/or algorithmic choices. For instance, one could use it as a behaviour policy to facilitate learning models of the environment or as a prior for planning methods.

The proposed method is able to leverage large amounts of compute by running on distributed training architectures that collect large amounts of experience from many actors running in parallel on separate environment instances. This has been crucial for solving most challenging tasks in deep RL in recent years \citep{andrychowicz2018learning, espeholt2018impala, silver2016mastering}, and this method is able to utilize such compute to obtain strong performance on the set of hard-exploration games on Atari.
While this is certainly a desirable feature and allows NGU to achieve a remarkable performance, it comes at the price of high sample
complexity, consuming a large amount of simulated experience taking several days of wall-clock time.
An interesting avenue for future research lies in improving the data efficiency of these agents.

Further, the episodic novelty measure relies on the notion of controllable states to drive exploration. As observed on the Atari hard-exploration games, this strategy performs well on several tasks, but it may not be the right signal for some environments. For instance, in some environments it might take more than two consecutive steps to see the consequences of the actions taken by the agent. An interesting line for future research is learning effective controllable states beyond a simple inverse dynamics model.

Additionally, the proposed work relies on the assumption that while different, one can find good exploratory and exploitative policies that are similar enough to be effectively represented using a shared parameterization (implemented using the UVFA framework). This can be limiting when the two policies are almost adversarial. This can be seen in games such as ‘Surround’ and ‘Ice hockey’.

Finally, the hyperparameter  depends on the scale of the extrinsic reward. Thus, environments with significantly different extrinsic reward scales, might require different values of . An interesting avenue forward is the dynamic adaptation of , which could be done by using techniques such as Population Based Training (PBT)\citep{jaderberg2017population} or Meta-gradients\citep{xu2018meta}. Another advantage of dynamically tuning this hyperparameter would be to allow for the model to become completely exploitative when the agent has reached a point in which further exploring does not lead to improvements on the exploitative policy. This is not trivially achievable however, as including such a mechanism would require calibrating the adaptation to be aligned to the speed of learning of the exploitative policy. 

\section*{Acknowledgments}
We thank Daan Wierstra, Steph Hughes-Fitt, Andrea Banino, Meire Fortunato, Melissa Tan, Benigno Uria, Borja Ibarz, Mohammad Gheshlaghi Azar, Remi Munos, Bernardo Avila Pires, Andre Barreto, Vali Irimia, Sam Ritter, David Raposo, Tom Schaul and many other colleagues at DeepMind for helpful discussions and comments on the manuscript.

\bibliography{iclr2020_conference}
\bibliographystyle{iclr2020_conference}
\clearpage
\newpage


\appendix

\section{Evaluation setup}
\label{evaluation_setup}
The evaluation we do is also identical to the one done in R2D2 \cite{r2d2}: a parallel evaluation worker, which shares weights with actors and learners, runs the Q-network against the environment. This worker and all the actor workers are the two types of workers that draw samples from the environment. For Atari, we apply the standard DQN pre-processing, as used in R2D2. More concretely, this is how actors, evaluators, and learner are run:

\textbf{Learner}:

\begin{itemize}
    \item Sample from the replay buffer a sequence of augmented rewards , intrinsic rewards , observations , actions  and discounts .
    \item Use Q-network to learn from  with retrace using the procedure used by R2D2. As specified in Fig. \ref{overview_fig},  is sampled because it is fed as an input to the network.
    \item Use last  frames of the sampled sequences to train the action prediction network as specified in Section \ref{learning_exploratory}. This means that, for every batch of sequences, all time steps are used to train the RL loss, whereas only  time steps per sequence are used to optimize the action prediction loss.
    \item (If using RND) also use last  frames of the sampled sequences to train the predictor of RND as also specified in Section \ref{learning_exploratory}.
\end{itemize}

\textbf{Evaluator and Actor}
\begin{itemize}
    \item Obtain , , , and discount .
    \item With these inputs, compute forward pass of R2D2 to obtain .
    \item With , compute  using the embedding network as described in Section \ref{learning_exploratory}.
    \item (actor) Insert , , , , and  in the replay buffer.
    \item Step on the environment with .
\end{itemize}

\textbf{Distributed training}\
\gamma_i = 1 - \exp\bigg(\frac{(N-1-i)\log(1-\gamma_{\max}) + i\log(1-\gamma_{\min})}{N-1}\bigg),

    \tau = \left(x_t, a_t, r_t, x_{t+1}\right)_{t\in\mathbb{N}},

\mathcal{T}Q(x,a) = Q(x,a) + \mathbb{E}_{\mu}\left[\sum_{t\geq0}\gamma^t\left(\prod_{s=1}^tc_s\right)\delta_t \right],

\delta_t = r_t + \gamma \sum_{a\in A}\pi(a|x_{t+1})Q(x_{t+1},a)-Q(x_t, a_t),    

c_s = \lambda\min\left(1, \frac{\pi(a_s|x_s)}{\mu(a_s|x_s)}\right).    

    Q_{k+1} = \mathcal{T}_k Q_k,

    \hat{T}Q(x_t, a_t) = Q(x_t, a_t) + \sum_{s=t}^{t+k-1}\gamma^{s-t}\left(\prod_{i=t+1}^s c_i\right)\delta_s.

\hat{y}_t &= \hat{T}Q(x_t, a_t; \theta^-),
\\
&= Q(x_t, a_t; \theta^-) + \sum_{s=t}^{t+k-1}\gamma^{s-t}\left(\prod_{i=t+1}^s c_i\right)\left(r_s + \gamma \sum_{a\in A}\pi(a|x_{s+1})Q(x_{s+1},a; \theta^-)-Q(x_s, a_s; \theta^-)\right).

    L(x_t, a_t, \theta) = \left(Q(x_t,a_t;\theta)-\hat{y}_t\right)^2.

\mathcal{T}^hQ(x,a) =  \mathbb{E}_{\mu}\left[h\left(h^{-1}(Q(x,a)) +\sum_{t\geq0}\gamma^t\left(\prod_{s=1}^tc_s\right)\delta^h_t \right)\right],

\delta^h_t = r_t + \gamma \sum_{a\in A}\pi(a|x_{t+1})h^{-1}(Q(x_{t+1},a))-h^{-1}(Q(x_t, a_t)).  

\forall z\in\mathbb{R}, h(z)&=\sign(z)(\sqrt{|z|+1}-1) + \epsilon z,
\\
\forall z\in\mathbb{R}, h^{-1}(z)&=\sign(z)\left(\left(\frac{\sqrt{1+4\epsilon(|z|+1+\epsilon)}-1}{2\epsilon}\right)-1\right),

with .

\newpage
\section{Hyperparameters}
\label{hyperparameters}

\subsection{Selection of hyperparameters}
In order to select the hyperparameters used for NGU() for all 57 Atari games, which are shown on Tab.~\ref{table_hyper_montezuma_common}, we ran a grid search with the ranges shown on Tab.~\ref{table_hyper_ranges}. We used  seeds on the set of  Atari games shown in Tab.~\ref{table_ablations}. Regarding the hyperparameters concerning the kernel  (Kernel  and the number of neighbors used), we fixed them after determining suitable ranges of the intrinsic reward in our initial experimentation on Atari. After running the grid search with those hyperparameters, we selected the combination with the highest amount games (out of ) that held a score greater than our human benchmark. As one can see on the multiple mixtures ablations seen on Tab.~\ref{table_ablations}, as well as the single mixture ablations on App~\ref{app:single_mixture_ablations}, the only agent that achieved superhuman performance on the set of  games is NGU().

Finally, in order to obtain the R2D2+RND baseline, we ran a sweep over the  hyperparameter with values , , and , over the  games shown in Tab.~\ref{table_ablations}. Coincidentally, like NGU(), the best value of  was determined to be .

\subsection{Common hyperparameters}
\label{common_hyperparameters}
These are the hyperparameters used in all the experiments. We expose a full list of hyperparameters here for completeness. However, as one can see, the R2D2-related architectural hyperparameters are identical to the original R2D2 hyperparameters. Shown in Tab.~\ref{table_hyper_montezuma_common}.
\begin{small}
\begin{longtable}[h!]{l|c}
\centering
\textbf{Hyperparameter} & \textbf{Value} \\ \hline
Number of Seeds &   \\ \hline
Cross Mixture Ratio &  \\ \hline
Number of mixtures  &  \\ \hline
Optimizer & AdamOptimizer (for all losses) \\ \hline
Learning rate (R2D2) &   \\ \hline
Learning rate (RND and Action prediction) &  \\ \hline
Adam epsilon &   \\ \hline
Adam beta1 &   \\ \hline
Adam beta2 &   \\ \hline
Adam clip norm &   \\ \hline
Discount  &  \\ \hline
Discount  &  \\ \hline
Batch size &  \\ \hline
Trace length &  \\ \hline
Replay period &  \\ \hline
Retrace  &  \\ \hline
R2D2 reward transformation &  \\ \hline
Episodic memory capacity &  \\ \hline
Embeddings memory mode & Ring buffer\\ \hline
Intrinsic reward scale  &  \\ \hline
Kernel  &  \\ \hline
Kernel num. neighbors used &  \\ \hline 
Kernel cluster distance  &  \\ \hline
Kernel pseudo-counts constant  &  \\ \hline
Kernel maximum similarity  &  \\ \hline
Replay priority exponent &  \\ \hline 
Replay capacity &  \\ \hline 
Minimum sequences to start replay &  \\ \hline 
Actor update period &  \\ \hline
Target Q-network update period &  \\ \hline
Embeddings target update period & once/episode \\ \hline
Action prediction network L2 weight &  \\ \hline
RND clipping factor  &  \\ \hline
Evaluation  &  \\ \hline
Target  &  \\ \hline

\caption{Common hyperparameters.}
\label{table_hyper_montezuma_common}
\vspace{-2ex}
\end{longtable}
\end{small}

\subsection{Disco Maze hyperparameters}
Hyperparameters are shown in Tab.~\ref{table_hyper_discomaze}.
\begin{table}[h!]
\centering
\begin{tabular}{l|c}
\textbf{Hyperparameter} & \textbf{Value} \\ \hline
Episodic memory capacity &  \\ \hline
Learning rate (R2D2 and Action prediction) &   \\ \hline
Replay capacity &  \\ \hline 
Intrinsic reward scale  &  \\ \hline 
Trace length &  \\ \hline
Replay period &  \\ \hline
Retrace  &  \\ \hline
Retrace loss transformation &  \\ \hline
Num. action repeats &  \\ \hline
Target Q-network update period &  \\ \hline
Q-network filter sizes &  \\ \hline
Q-network filter strides &  \\ \hline
Q-network num. filters &  \\ \hline
Action prediction network filter sizes &  \\ \hline
Action prediction network filter strides &  \\ \hline
Action prediction network num. filters &  \\ \hline
Kernel  &  \\ \hline
Evaluation  &  \\ \hline

\end{tabular}
\caption{Disco Maze hyperparameters.}
\label{table_hyper_discomaze}
\vspace{-2ex}
\end{table}

\subsection{Atari pre-processing hyperparameters}
\label{atari_hypers}
Hyperparameters are shown in Tab.~\ref{table_hyper_atari}.
\begin{table}[ht!]
\centering
\begin{tabular}{l|c}
\textbf{Hyperparameter} & \textbf{Value} \\ \hline
Max episode length &   \\ \hline 
Num. action repeats &  \\ \hline
Num. stacked frames &  \\ \hline
Zero discount on life loss &  \\ \hline
Random noops range &  \\ \hline
Sticky actions &  \\ \hline
Frames max pooled & 3 and 4\\ \hline
Grayscaled/RGB & Grayscaled \\ \hline
Action set & Full \\ \hline
\end{tabular}
\caption{Atari pre-processing hyperparameters.}
\label{table_hyper_atari}
\vspace{-2ex}
\end{table}

\subsection{Hyperparameter ranges}
On Tab.~\ref{table_hyper_ranges} we can see the ranges we used to sweep over in our experiments.
\begin{table}[ht!]
\centering
\begin{tabular}{l|c}
\textbf{Hyperparameter} & \textbf{Value} \\ \hline
Intrinsic reward scale  &  \\ \hline
Number of mixtures  &  \\ \hline
Cross Mixture Ratio &  \\ \hline
\# Episodes w/o wiping Episodic Memory &  \\ \hline
\end{tabular}
\caption{Range of hyperparameters sweeps.}
\label{table_hyper_ranges}
\end{table}

\clearpage
\newpage
\section{Detailed Atari Results}
\label{results_all_games}

\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.98\textwidth]{atari57.png}  
    \caption{R2D2(Retrace) (green), NGU(N=32) with eval  (blue) and eval  (orange).} 
    \label{atari57}
\end{figure}

\begin{table}[ht!]
\small
\centering
\begin{tabular}{l|c|c|c}
\textbf{Game} & R2D2(Retrace) & NGU(32) eval beta=0.0 & NGU(32) eval beta=0.3 \\ \hline
alien  & 189.1k15.6k & \textbf{248.1k22.4k} & 225.5k36.9k \\
asteroids  & \textbf{338.5k4.5k} & 230.5k4.0k & 181.6k2.8k \\
time pilot  & \textbf{446.8k3.9k} & 344.7k31.0k & 336.1k32.9k \\
tutankham  & \textbf{452.220.0} & 191.11.2 & 125.75.2 \\
up n down  & \textbf{678.8k1.3k} & 620.1k13.7k & 575.2k10.4k \\
venture  & \textbf{2.0k0.0k} & 1.7k0.1k & 779.9188.7 \\
video pinball  & 948.6k5.2k & \textbf{965.3k12.8k} & 596.7k120.0k \\
wizard of wor  & \textbf{120.2k7.6k} & 106.2k7.0k & 85.1k12.3k \\
atlantis  & \textbf{1654.9k1.5k} & 1653.6k2.3k & 1638.0k4.6k \\
yars revenge  & 990.4k2.9k & 986.0k3.2k & \textbf{993.8k1.5k} \\
zaxxon  & 94.8k23.7k & 111.1k11.8k & \textbf{190.1k6.9k} \\
bank heist  & 15.0k5.7k & \textbf{17.4k12.0k} & 1.4k0.0k \\
battle zone  & \textbf{733.1k45.2k} & 691.7k22.6k & 571.5k45.4k \\
beam rider  & \textbf{103.9k1.1k} & 63.6k8.6k & 31.9k0.6k \\
berzerk  & \textbf{69.3k5.8k} & 36.2k4.7k & 27.3k0.8k \\
bowling  & \textbf{253.01.2} & 211.98.4 & 161.84.9 \\
boxing  & \textbf{100.00.0} & 99.70.0 & 3.81.4 \\
breakout  & \textbf{839.76.0} & 559.229.0 & 387.651.0 \\
centipede  & \textbf{700.2k19.8k} & 577.8k3.1k & 574.6k7.0k \\
chopper command  & \textbf{999.9k0.0k} & 999.9k0.0k & 974.1k14.7k \\
amidar  & \textbf{28.2k0.2k} & 17.8k1.2k & 8.5k0.4k \\
crazy climber  & 294.2k25.7k & 313.4k7.7k & \textbf{357.0k8.3k} \\
defender  & \textbf{675.6k3.2k} & 664.1k1.8k & 656.3k7.2k \\
demon attack  & \textbf{143.9k0.0k} & 143.5k0.0k & 136.6k3.3k \\
double dunk  & \textbf{24.00.0} & -14.12.4 & -21.50.7 \\
enduro  & \textbf{2.4k0.0k} & 2.0k0.1k & 682.524.0 \\
fishing derby  & \textbf{86.80.9} & 32.01.9 & -29.34.1 \\
freeway  & \textbf{33.20.1} & 28.51.1 & 21.20.5 \\
frostbite  & 10.5k3.8k & \textbf{206.4k150.0k} & 67.9k45.6k \\
gopher  & \textbf{117.8k0.9k} & 113.4k0.6k & 86.6k7.4k \\
gravitar  & 12.9k0.6k & \textbf{14.2k0.5k} & 13.2k0.3k \\
assault  & \textbf{36.7k3.0k} & 34.8k5.4k & 1.9k0.6k \\
hero  & 54.5k3.0k & \textbf{69.4k5.7k} & 64.2k7.0k \\
ice hockey  & \textbf{85.10.6} & -4.10.3 & -0.50.2 \\
jamesbond  & \textbf{30.8k2.3k} & 26.6k2.6k & 22.4k0.3k \\
kangaroo  & 14.7k0.1k & \textbf{35.1k2.1k} & 16.9k2.0k \\
krull  & \textbf{131.1k12.7k} & 127.4k17.1k & 26.7k2.2k \\
kung fu master  & \textbf{220.7k3.9k} & 212.1k11.2k & 203.2k10.8k \\
montezuma revenge  & 2.3k0.4k & 10.4k1.5k & \textbf{16.8k6.8k} \\
ms pacman  & 40.3k1.1k & \textbf{40.8k1.1k} & 38.1k1.6k \\
name this game  & \textbf{70.6k8.3k} & 23.9k0.5k & 15.6k0.3k \\
phoenix  & 935.2k13.5k & \textbf{959.1k2.7k} & 933.3k4.7k \\
asterix  & \textbf{994.3k0.9k} & 950.7k23.1k & 953.1k21.7k \\
pitfall  & -5.21.7 & \textbf{7.8k4.0k} & 1.3k0.9k \\
pong  & \textbf{20.90.0} & 19.60.2 & -9.71.4 \\
private eye  & 31.5k5.4k & \textbf{100.0k0.4k} & 65.6k14.3k \\
qbert  & 398.6k46.4k & \textbf{451.9k82.1k} & 449.0k108.2k \\
riverraid  & 38.9k0.6k & 36.7k2.3k & \textbf{42.6k4.0k} \\
road runner  & 105.2k16.8k & \textbf{128.6k28.7k} & 103.9k7.1k \\
robotank  & \textbf{142.40.8} & 9.10.7 & 24.92.5 \\
seaquest  & \textbf{1000.0k0.0k} & 1000.0k0.0k & 1000.0k0.0k \\
skiing  & \textbf{-11081.797.7} & -22977.95059.9 & -21907.43647.5 \\
solaris  & \textbf{5.6k1.1k} & 4.7k0.3k & 1.3k0.1k \\
space invaders  & 33.4k12.2k & \textbf{43.4k1.3k} & 12.0k1.9k \\
star gunner  & 412.8k4.1k & 414.6k66.8k & \textbf{452.5k53.0k} \\
surround  & \textbf{9.80.0} & -9.60.2 & -7.30.4 \\
tennis  & \textbf{24.00.0} & 10.23.5 & -3.55.7
\end{tabular}
\caption{Scores over all 57 Atari games.}
\label{table_atari57}
\end{table}


\clearpage
\newpage
\section{Network Architectures}
\subsection{Architecture of the Embedding Network with Inverse dynamics prediction}
\label{embedding_network}
\begin{figure}[!h]
    \centering
    \includegraphics[width=0.3\textwidth]{figures_architecture/inverse_model_detailed.pdf}
    \caption{Embedding Network Architecture.} 
    \label{Embedding Network.}
\end{figure}


\subsection{Architecture of the Random Network Distillation}
\label{rnd_network}
\begin{figure}[!h]
    \centering
    \includegraphics[width=0.5\textwidth]{figures_architecture/RND_model_detailed.pdf}
    \caption{RND Network Architecture.} 
    \label{RND Network.}
\end{figure}

\subsection{Architecture of the R2D2 Agent}
\label{r2d2_network}
\begin{figure}[!h]
    \centering
    \subfigure[Sketch of the R2D2 Agent]{\includegraphics[width=0.49\textwidth]{figures_architecture/R2D2_model.pdf} }
    \hspace{4ex}
    \subfigure[Detailed R2D2 Agent]{\includegraphics[width=0.3\textwidth]{figures_architecture/R2D2_model_detailed.pdf} }
    \caption{R2D2 Agent Architecture.} 
    \label{R2D2 Network.}
\end{figure}


\section{Controllable states}
\label{app:controllable_states}

In this section we evaluate properties of the learned controllable states. We further present a study of the performance of the algorithm when having access to oracle controllable states containing only the necessary information. We use Montezuma's Revenge as a case-study. 

\subsection{Inspecting the properties of learned controllable states}
As explained in Section \ref{learning_exploratory}, we train the embedding network  using an inverse dynamics model as done by \cite{pathak2017curiosity}. Intuitively, the controllable states should contain the information relevant to the action performed by
the agent given two consecutive observations. However it might contain other type of information as long as it can be easily ignored by our simple classifier, .


As noted in~\cite{burda2018exploration}, for this game, one can identify a novel state by using five pieces of information: the  position of the player, a room identifier, the level number, and the number of keys held. This information can be easily extracted from the RAM state of the game as described in Section \ref{app:handcrafter} bellow. 
One question that we could ask is whether this information is present (or easily decodable) or not in the learned controllable state.
We attempted to answer this question by training a linear classifier to predict the  coordinates and the room identified from the learned controllable state. Importantly we do not backpropagate the errors to the embedding network . Figure \ref{initial_results} shows the average results over the episodes as the training of the agent progresses. We can see that the squared error in predicting the  position of the agent stabilises to a more or less constant value, which suggests that it can successfully generalise to new rooms (we do not observe an increase in the error when new rooms are discovered). The magnitude of the error is of the order of 12 units, which less than 10\% of the range (see Section \ref{app:handcrafter}). This is to be expected, as it is the most important information for predicting which action was taken. It shows that the information is quite accessible and probably has a significant influence in the proposed novelty measure.
The room identifier, on the other hand, is information that is not necesary to predict the action taken by the agent. Unlike the previous case, one can see jumps in the error as training progresses as the problem becomes harder. It stabilises around an error slightly above 20\%, which is reasonably good considering that random chance is 96\%. This means that even if there is nothing specifically encouraging this information to be there, it is still present and in turn can influence the proposed novelty signal.

An avenue of future work is to research alternative methods for learning controllable states that directly search for retaining all relevant information. While very good results can be obtained with one of the simple alternative of an inverse dynamics model, it is reasonable to think that better results could be attained when using a better crafted one. To inform this question, we investigate in the next section what results could we obtain if we explicitly use as controllable states the quantities that we were trying to predict in this section.

\begin{figure}[!tbp]
    \centering
    \includegraphics[width=0.53\textwidth]{pred_emb_position.png}
    \\
    \includegraphics[width=0.53\textwidth]{pred_emb_room.png}
    \\
    \caption{Prediction loss from learned controllable states of the position (top) and room (bottom) on Montezuma's Revenge against minibatch updates.
}
    \label{predictability_results}
    \vspace{-1ex}
\end{figure}



\subsection{Montezuma's Revenge with hand-crafted controllable states}
\label{montezuma_hand_crafted}
In the previous section we analysed the properties of the learned controllable states. A valid question to ask is: how would the NGU work if we had access to an oracle controllable state containing only the relevant information? This analysis is a form of upper bound performance for a given agent architecture. 
We ran the NGU(N=1) model with two ablations: without RND and without extrinsic rewards.
Instead of resetting the memory after every episode, we do it after a small number of consecutive episodes, which we call a \emph{meta-episode}.
This structure plays an important role when the agent faces irreversible choices.
In this setting, approaches using non-episodic exploration bonuses are even more susceptible to suffer from the ``detachment'' problem described in \citet{ecoffet2019go}. The agent might switch between alternatives without having exhausted all learning opportunities, rendering choosing the initial option uninteresting from a novelty perspective. 
The episodic approach with a meta-episode of length one would be forced to make similar choices. However, when run with multiple episodes it can offer an interesting alternative. In the first episode, the agent starts with an empty episodic memory can can choose arbitrarily one of the options. In the second episode, the episodic memory contains all the experience collected in the first episode. The agent is then rewarded for \emph{not} repeating the strategy followed in the first one, as revisiting those states will lead to lower intrinsic reward. Thus, the agent is encourage to learn diverse behaviour across episodes without needing to choose between alternatives nor being susceptible to the detachment problem.
Results are summarized in Fig.~\ref{initial_results}. We report the average episodic return (left) as well as the average number of visited rooms per meta-episode (right).
The model achieves higher scores than the one using learned controllable states (as reported in Section \ref{montezuma_learned}).


Incorporating long-term novelty in the exploration bonus, encourages the agent to concentrate in the less explored areas of the environment. Similarly to what we observed with learned controllable states, this provides a boost both in data efficiency as well as final performance, obtaining close to 15,000 average return and visiting an average of 25 rooms per episode. In this run, three out of five seeds reach the second level of the game, one of which reaches the third level with an average of fifty different rooms per episode.
We also observe that, when running in the absence of extrinsic rewards, the agent remarkably still achieves a very high extrinsic reward. Secondly, the agent is able to consistently reach a large number of rooms and explore more than  rooms without any extrinsic guidance.


As noted in \citet{burda2018exploration}, in Montezuma's Revenge each level contains  doors and  keys. If the agent walks through a door holding a key, it receives a reward of  consuming the key in the process. In order to clear a level, the agent needs open two doors located just before the final room. 
During exploration, the agent needs to hold on to two keys to see what it could do with them later in the episode, sacrificing the immediate reward of opening more accessible doors. Any agent that acts almost greedily will struggle with what looks like a high level choice. 
With the right representation and using meta-episodes, our method can handle this problem in an interesting way. When the number of keys held is represented in the controllable state, the agent chooses a different key-door combination on each of the three episodes in which we do not wipe our episodic memory.
At the end of training, in the first episode after wiping the episodic memory, our agent shows a score of , while the third episode the agent shows a score of , exploring on average over 30 rooms and consistently going to the second level\footnote{See video of the three episodes at \url{https://sites.google.com/view/nguiclr2020}}.
The agent learns a complex exploratory policy spanning several episodes that can handle irreversible choices and overcome  ``distractor'' rewards. 
We do not observe different key-door combinations across episodes when using learned controllable states. Presumably the signal of the number of held keys in the learned controllable states is not strong enough to treat them as sufficiently different.

\begin{figure}[!tbp]
    \centering
    \includegraphics[width=0.5\textwidth]{montezuma_truestate_return2.png}
    \hfill
    \includegraphics[width=0.47\textwidth]{montezuma_truestate_rooms2.png}
    \caption{Mean episodic return (left) and mean number
of visited rooms per episode (right) vs environment frames for agents trained
Montezuma’s Revenge with hand-crafted controllable states.
}
    \label{initial_results}
\vspace{-3ex}
\end{figure}
The results describe in this section support the idea that significant gains can be obtained by improving the respresentation of the controllable states, suggesting that the study of learning better representations is an interesting line for future work.
Recent works have explored ways of measuring novelty by learning controllable aspects of an environment \citep{kim2018emi, warde2018unsupervised}, and we believe that some of these ideas could be also useful in this setting.

\subsection{Hand-crafted state features for Montezuma's Revenge}
\label{app:handcrafter}
We obtain the hand-crafted features for Montezuma's Revenge by observing the RAM state of the game at every time step. More concretely:

\begin{itemize}
    \item x and y can be observed at positions 0xAA and 0xAB respectively, represented by integers with a range of .
    \item Room id and level number can be found in positions 0x83 and 0xB9 respectively. We provide this information as a single integer to our agent in the form of  where  is the room id, and  is the level number.
    \item Byte 0xC1 is the player's inventory. We count the number of keys being held (and provide this information to the agent) by adding the bits , which correspond to the binary slots for keys.
\end{itemize}

\end{document}
