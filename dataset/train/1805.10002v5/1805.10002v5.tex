\documentclass{article} \usepackage{iclr2019_conference,times}
\iclrfinalcopy



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}











\usepackage[pdftex]{graphicx} 
\usepackage{threeparttable}
\usepackage{multirow}

\usepackage{verbatim} 
\usepackage{caption}
\captionsetup{font=small}

\usepackage[T1]{fontenc}


\title{Learning to Propagate Labels: Transductive Propagation Network for Few-shot Learning}

\author{
    Yanbin Liu$^1\thanks{This work was done when Yanbin Liu was an intern at AITRICS.}$, Juho Lee$^{2,3}$, Minseop Park$^3$, Saehoon Kim$^3$, Eunho Yang$^{3,4}$, \\
    \textbf{Sung Ju Hwang$^{3,4}$ \& Yi Yang$^{1,5}$\thanks{Part of this work was done when Yi Yang was visiting Baidu Research during his Professional Experience Program.}}\\
    $^1$CAI, University of Technology Sydney, $^2$University of Oxford\\ 
    $^3$AITRICS, $^4$KAIST, $^5$Baidu Research\\
    \texttt{csyanbin@gmail.com}, \texttt{juho.lee@stats.ox.ac.uk}, \\
    \texttt{\{mike\_seop, shkim\}@aitrics.com}, \texttt{\{eunhoy, sjhwang82\}@kaist.ac.kr},\\ \texttt{Yi.Yang@uts.edu.au}
}



\def\mini{{\textit{mini}ImageNet}}
\def\tiered{{\textit{tiered}ImageNet}}
\def\bfx{\mathbf{x}}

\begin{document}


\maketitle

\begin{abstract}
The goal of few-shot learning is to learn a classifier that generalizes well even when trained with a limited number of training instances per class. The recently introduced meta-learning approaches tackle this problem by learning a generic classifier across a large number of multiclass classification tasks and generalizing the model to a new task. Yet, even with such meta-learning, the low-data problem in the novel classification task still remains. In this paper, we propose \textit{Transductive Propagation Network} (TPN), a novel meta-learning framework for transductive inference that classifies the entire test set at once to alleviate the low-data problem. Specifically, we propose to \emph{learn to propagate labels} from labeled instances to unlabeled test instances, by learning a graph construction module that exploits the manifold structure in the data. TPN jointly learns both the parameters of feature embedding and the graph construction in an end-to-end manner.  We validate TPN on multiple benchmark datasets, on which it largely outperforms existing few-shot learning approaches and achieves the state-of-the-art results. 



\end{abstract}

\section{Introduction}
Recent breakthroughs in deep learning~\citep{imagenet,vgg,resnet} highly rely on the availability of large amounts of labeled data. However, this reliance on large data increases the burden of data collection, which hinders its potential applications to the low-data regime where the labeled data is rare and difficult to gather.
On the contrary, humans have the ability to recognize new objects after observing only one or few instances~\citep{oneshot}. For example, children can generalize the concept of ``apple'' after given a single instance of it. This significant gap between human and deep learning has reawakened the research interest on few-shot learning~\citep{matching,prototypical,maml,metaLSTM,layerwise,memory-few,imaginary}. 

Few-shot learning aims to learn a classifier that generalizes well with a few examples of each of these classes. Traditional techniques such as fine-tuning~\citep{caffe} that work well with deep learning models would severely overfit on this task~\citep{matching,maml}, since a single or only a few labeled instances would not accurately represent the true data distribution and will result in learning classifiers with high variance, which will not generalize well to new data.


In order to solve this overfitting problem, ~\cite{matching} proposed a meta-learning strategy which learns over diverse classification tasks over large number of episodes rather than only on the target classification task. In each episode, the algorithm learns the embedding of the few labeled examples (the \textit{support set}), which can be used to predict classes for the unlabeled points (the \textit{query set}) by distance in the embedding space. The purpose of episodic training is to mimic the real test environment containing few-shot support set and unlabeled query set. The consistency between training and test environment alleviates the distribution gap and improves generalization. This episodic meta-learning strategy, due to its generalization performance, has been adapted by many follow-up work on few-shot learning. \cite{maml} learned a good initialization that can adapt quickly to the target tasks. \cite{prototypical} used episodes to train a good representation and predict classes by computing Euclidean distance with respect to class prototypes. 

Although episodic strategy is an effective approach for few-shot learning as it aims at generalizing to unseen classification tasks, the fundamental difficulty with learning with scarce data remains for a novel classification task. One way to achieve larger improvements with limited amount of training data is to consider relationships between instances in the test set and thus predicting them as a whole, which is referred to as transduction, or transductive inference. In previous work~\citep{tsvm,labelprop1,vapnik}, transductive inference has shown to outperform inductive methods which predict test examples one by one, especially in small training sets. One popular approach for transduction is to construct a network on both the labeled and unlabeled data, and propagate labels between them for joint prediction. However, the main challenge with such label propagation (and transduction) is that the label propagation network is often obtained without consideration of the main task, since it is not possible to learn them at the test time.

Yet, with the meta-learning by episodic training, we can learn the label propagation network as the query examples sampled from the training set can be used to simulate the real test set for transductive inference. Motivated by this finding, we propose \textit{Transductive Propagation Network} (TPN) to deal with the low-data problem. Instead of applying the inductive inference, we utilize the entire query set for transductive inference (see Figure~\ref{fig:concept}). Specifically, we first map the input to an embedding space using a deep neural network. Then a graph construction module is proposed to exploit the manifold structure of the novel class space using the union of support set and query set. According to the graph structure, iterative label propagation is applied to propagate labels from the support set to the query set and finally leads to a closed-form solution. With the propagated scores and ground truth labels of the query set, we compute the cross-entropy loss with respect to the feature embedding and graph construction parameters. Finally, all parameters can be updated end-to-end using backpropagation.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\linewidth]{concept_fig.pdf}
  \caption{A conceptual illustration of our transductive meta-learning framework, where lines between nodes represent graph connections and their colors represent the potential direction of label propagation. The neighborhood graph is episodic-wisely trained for transductive inference.}
  \label{fig:concept}
\end{figure}

The main contribution of this work is threefold. 

\begin{itemize}
    \item To the best of our knowledge, we are the first to model transductive inference explicitly in few-shot learning. Although~\cite{first-order} experimented with a transductive setting, they only share information between test examples by batch normalization rather than directly proposing a transductive model.
    \item In transductive inference, we propose to \emph{learn to propagate labels} between data instances for unseen classes via  episodic meta-learning. This learned label propagation graph is shown to significantly outperform naive heuristic-based label propagation methods~\citep{labelprop1}.
    \item We evaluate our approach on two benchmark datasets for few-shot learning, namely \mini~ and \tiered. The experimental results show that our \textit{Transductive Propagation Network} outperforms the state-of-the-art methods on both datasets. Also, with semi-supervised learning, our algorithm achieves even higher performance, outperforming all semi-supervised few-shot learning baselines.
\end{itemize}





\section{Related work}

\paragraph{Meta-learning} 
In recent works, few-shot learning often follows the idea of meta-learning~\citep{meta1,meta2}. Meta-learning tries to optimize over batches of tasks rather than batches of data points. Each task corresponds to a learning problem, obtaining good performance on these tasks helps to learn quickly and generalize well to the target few-shot problem without suffering from overfitting. The well-known MAML approach~\citep{maml} aims to find more transferable representations with sensitive parameters. 
A first-order meta-learning approach named Reptile is proposed by~\cite{first-order}. It is closely related to first-order MAML but does not need a training-test split for each task. Compared with the above methods, our algorithm has a closed-form solution for label propagation on the query points, thus avoiding gradient computation in the inner updateand usually performs more efficiently. 

\paragraph{Embedding and metric learning approaches}
Another category of few-shot learning approach aims to optimize the transferable embedding using metric learning approaches. Matching networks~\citep{matching} produce a weighted nearest neighbor classifier given the support set and adjust feature embedding according to the performance on the query set. 
Prototypical networks~\citep{prototypical} first compute a class's prototype to be the mean of its support set in the embedding space. Then the transferability of feature embedding is evaluated by finding the nearest class prototype for embedded query points. An extension of prototypical networks is proposed in~\cite{semi-proto} to deal with semi-supervised few-shot learning.
Relation Network~\citep{compare} learns to learn a deep distance metric to compare a small number of images within episodes. Our proposed method is similar to these approaches in the sense that we all focus on learning deep embeddings with good generalization ability. However, our algorithm assumes a transductive setting, in which we utilize the union of support set and query set to exploit the manifold structure of novel class space by using episodic-wise parameters.

\paragraph{Transduction} 
The setting of transductive inference was first introduced by Vapnik~\citep{vapnik}. Transductive Support Vector Machines (TSVMs)~\citep{tsvm} is a margin-based classification method that minimizes errors of a particular test set. It shows substantial improvements over inductive methods, especially for small training sets. Another category of transduction methods involves graph-based methods~\citep{labelprop1,labelprop2,transfer,tzero}.  Label propagation is used in~\cite{labelprop1} to transfer labels from labeled to unlabeled data instances guided by the weighted graph. Label propagation is sensitive to variance parameter $\sigma$, so Linear Neighborhood Propagation (LNP)~\citep{labelprop2} constructs approximated Laplacian matrix to avoid this issue. In~\cite{labelprop3}, minimum spanning tree heuristic and entropy minimization are used to learn the parameter $\sigma$. In all these prior work, the graph construction is done on a pre-defined feature space using manually selected hyperparamters since it is not possible to learn them at test time. Our approach, on the other hand, is able to learn the graph construction network since it is a meta-learning framework with episodic training, where at each episode we simulate the test set with a subset of the training set.  

In few-shot learning, \cite{first-order}~experiments with a transductive setting and shows improvements. However, they only share information between test examples via batch normalization~\citep{bn} rather than explicitly model the transductive setting as in our algorithm. 



\section{Main approach}

In this section, we introduce the proposed algorithm that utilizes the manifold
structure of the given few-shot classification task to improve the performance.

\subsection{Problem definition}

We follow the episodic paradigm~\citep{matching} that effectively trains a meta-learner for 
few-shot classification tasks, which is commonly employed in various literature~\citep{prototypical,maml,first-order,compare,snail}. 
Given a relatively large labeled dataset with a set of classes $\mathcal{C}_{train}$,
the objective of this setting is to train classifiers for an unseen set of novel classes $\mathcal{C}_{test}$, for which only a few labeled examples are available. 



Specifically, in each episode, a small subset of $N$ classes are sampled from $\mathcal{C}_{train}$ to construct a \textit{support set} and a \textit{query set}. The \textit{support set} contains $K$ examples from each of the $N$ classes (i.e., $N$-way $K$-shot setting) denoted as $\mathcal{S}=\{(\bfx_1,y_1), (\bfx_2,y_2), \dots, (\bfx_{N\times K}, y_{N\times K})\}$, while the \textit{query set} $\mathcal{Q} = \{(\bfx_1^*,y_1^*), (\bfx_2^*,y_2^*), \dots, (\bfx_T^*, y_T^*)\}$ includes different examples from the same $N$ classes. Here, the support set  $\mathcal{S}$ in each episode serves as the labeled training set on which the model is trained to minimize the loss of its predictions for the query set $\mathcal{Q}$. This procedure mimics training classifiers for $\mathcal{C}_{test}$ and goes episode by episode until convergence. 

Meta-learning implemented by the episodic training reasonably performs well to
few-shot classification tasks. Yet, due to the lack of labeled instances ($K$ is usually very small)
in the support set, we observe that a reliable classifier is still difficult to be obtained. 
This motivates us 
to consider a transductive setting that utilizes the whole query set for the prediction rather than predicting each example independently. Taking the entire query set into account, we can alleviate the low-data problem and provide more reliable generalization property.



\subsection{Transductive Propagation Network (TPN)}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.9\linewidth]{Overview.pdf}
  \small
  \caption{The overall framework of our algorithm in which the manifold structure of the entire query set helps to learn better decision boundary. The proposed algorithm is composed of four components: feature embedding, graph construction, label propagation, and loss generation.}
  \label{transduction}
\end{figure}

We introduce \textit{Transductive Propagation Network} (TPN) illustrated  
in Figure~\ref{transduction}, which consists of four components: 
feature embedding with a convolutional neural network; 
graph construction that produces example-wise parameters to exploit the manifold structure;
label propagation that spreads labels from the support set $\mathcal{S}$ to the query set $\mathcal{Q}$; a loss generation step that computes a cross-entropy loss between propagated labels and the ground-truths on $\mathcal{Q}$ to jointly train all parameters in
the framework.





\subsubsection{Feature embedding}
\label{embedding}

We employ a convolutional neural network $f_{\varphi}$ to extract features of an input $\bfx_i$,
where $f_{\varphi}(\bfx_i; \varphi)$ refers to the feature map and $\varphi$ indicates a parameter
of the network. Despite the generality, we adopt the same architecture used in several recent works~\citep{prototypical,compare,matching}. By doing so, we can provide more fair comparisons in the experiments, highlighting the effects of transductive approach.
The network is made up of four convolutional blocks where each block begins with a 2D convolutional layer with a $3\times 3$ kernel and filter size of $64$. Each convolutional layer is followed by a batch-normalization layer~\citep{bn}, a ReLU nonlinearity and a $2\times 2$ max-pooling layer. We use the same embedding function $f_{\varphi}$ for both the support set $\mathcal{S}$ and the query set $\mathcal{Q}$.





\subsubsection{Graph construction}
\label{graph}

Manifold learning~\citep{spectral,labelprop1,revisiting} discovers the embedded low-dimensional
subspace in the data, where it is critical to choose an appropriate neighborhood graph.
A common choice is Gaussian similarity function:
\begin{equation}
\label{weight}
W_{ij} = \exp\left(-\frac{d(\bfx_i, \bfx_j)}{2\sigma^2}\right)\,,
\end{equation}
where $d(\cdot, \cdot)$ is a distance measure (e.g., Euclidean distance) and $\sigma$ is the length scale parameter. The neighborhood structure behaves differently with respect to various $\sigma$,
which means that it needs to carefully select the optimal $\sigma$ for the best
performance of label propagation~\citep{labelprop2,labelprop3}.
In addition, we observe that there is no principled way to tune the scale
parameter in meta-learning framework, though there exist some heuristics for 
dimensionalty reduction methods~\citep{localscaling,lfda}.



\paragraph{Example-wise length-scale parameter} To obtain a proper neighborhood graph in meta-learning, we propose a graph construction module built on the union set of support set and query set: $\mathcal{S}\cup \mathcal{Q}$. 
This module is composed of a convolutional neural network $g_{\phi}$ which takes the 
feature map $f_{\varphi}(\bfx_i)$ for $\bfx_i \in \mathcal{S}\cup \mathcal{Q}$ to produce an \emph{example-wise} length-scale parameter 
$\sigma_i = g_{\phi}(f_{\varphi}(\bfx_i))$. Note that the scale parameter is determined example-wisely and 
learned in an episodic training procedure, which adapts well to different tasks and makes it suitable for few-shot learning. With the example-wise $\sigma_i$, our similarity function is then defined as follows:
\begin{equation}
W_{ij} = \exp\left(-\frac{1}{2}d\Big(\frac{f_{\varphi}(\mathbf{x_i})}{\sigma_i},\frac{f_{\varphi}(\mathbf{x_j})}{\sigma_j}\Big) \right)\,
\end{equation}
where $W \in R^{(N\times K + T)\times(N\times K + T)}$ for all instances in $\mathcal{S}\cup \mathcal{Q}$. We only keep the $k$-max values in each row of $W$ to construct a $k$-nearest neighbour graph. Then we apply the normalized graph Laplacians~\citep{spectral} on $W$, that is,  $S=D^{-1/2}WD^{-1/2}$, where 
$D$ is a diagonal matrix with its $(i,i)$-value to be the sum of the $i$-th row of $W$. 

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.95\linewidth]{sigma_new.pdf}
  \caption{Detailed architecture of the graph construction module, 
  in which the length-scale parameter is example-wisely determined.}
  \label{construct}
\end{figure}

\paragraph{Graph construction structure} The structure of the proposed graph construction module is shown in Figure~\ref{construct}. It is composed of two convolutional blocks and two fully-connected layers, where each block contains a 3-by-3 convolution, batch normalization, ReLU activation, followed by 2-by-2 max pooling. The number of filters in each convolutional block is 64 and 1, respectively. To provide an example-wise scaling parameter, the activation map from the second convolutional block is transformed into a scalar by two fully-connected layers in which the number of neurons is 8 and 1, respectively.

\paragraph{Graph construction in each episode} We follow the episodic paradigm for few-shot meta-learner training. This means that the graph is individually constructed for each task in each episode, as shown in Figure~\ref{fig:concept}. Typically, in 5-way 5-shot training, $N=5, K=5, T=75$, the dimension of $W$ is only $100\times 100$, which is quite efficient. 



\subsubsection{Label propagation}
\label{lp}
We now describe how to get predictions for the query set $\mathcal{Q}$ using label propagation, before the last cross-entropy loss step. Let $\mathcal{F}$ denote the set of $(N\times K+T)\times N$ matrix with nonnegative entries.  We define a label matrix $Y \in \mathcal{F}$ with $Y_{ij}=1$ if $\bfx_i$ is from the support set and labeled as $y_i=j$, otherwise $Y_{ij}=0$. Starting from $Y$, label propagation iteratively determines 
the unknown labels of instances in the union set $\mathcal{S} \cup \mathcal{Q}$ according to the graph structure using the following formulation:
\begin{equation}
    F_{t+1} = \alpha SF_t + (1-\alpha)Y\,, 
\label{eq:lp_iter}
\end{equation}
where $F_{t} \in \mathcal{F}$ denotes the predicted labels at the timestamp $t$, 
$S$ denotes the normalized weight, and $\alpha \in (0,1)$ controls the amount of propagated information. It is well known that the sequence $\{F_{t}\}$ has a closed-form solution as follows:
\begin{equation}
	F^* = (I-\alpha S)^{-1}Y\,,
\label{eq:lp_closed}
\end{equation}
where $I$ is the identity matrix \citep{labelprop1}. We directly utilize this result for the label propagation, making a whole
episodic meta-learning procedure more efficient in practice. 

\paragraph{Time complexity} Matrix inversion originally takes $O(n^3)$ time complexity, which is inefficient for large $n$. However, in our setting, $n=N\times K+T$ (80 for 1-shot and 100 for 5-shot) is very small. Moreover, there is plenty of prior work on the scalability and efficiency of label propagation, such as \cite{scale1,scale2}, which can extend our work to large-scale data. More discussions are presented in \ref{sec:time}

\if
By iteratively executing Equation~(\ref{propF}), $F_t$ will converge to the optimal $F^*$. And the label of $\bfx_i$ is predicted as $\tilde{y}_i = \arg\max_{j\leq N}F^*_{ij}$.

The label propagation algorithm is equivalent to the following optimization~\citep{labelprop1}:
\begin{equation}
\label{objF}
	F^* = \arg\min_{F\in\mathcal{F}} \frac{1}{2}\left( \sum_{i,j=1}^{N\times K+T}W_{ij}\|\frac{1}{\sqrt{D_{ii}}} F_i - \frac{1}{\sqrt{D_{jj}}} F_j \|^2 + \mu \sum_{i=1}^{N\times K+T} \|F_i-Y_i\|^2\right)\,,
\end{equation}

where $\mu>0$ is the regularization parameter and its closed-form solution is given as follows:
\begin{equation}
	F^* = (I-\alpha S)^{-1}Y\,,
\end{equation}
where $I$ is the identity matrix and $\alpha=\frac{1}{1+\mu}$. The closed-form solution is an appealing result. At each training episode, we can directly compute $F^*$ rather than iterate using Equation~(\ref{propF}). In this way, the computation cost can be reduced, thus making our algorithm efficient in practice.
\fi

\subsubsection{Classification loss generation}
\label{loss}
The objective of this step is to compute the classification loss between the predictions of the union of support and query set via label propagation and the ground-truths.
We compute the cross-entropy loss between predicted scores $F^*$ and
ground-truth labels from $\mathcal{S}\cup \mathcal{Q}$ to learn all parameters in an end-to-end fashion, where $F^*$ is converted to probabilistic score using softmax:
\begin{equation}
	P(\tilde{y_i}=j|\bfx_i) = \frac{\exp(F^*_{ij})}{\sum_{j=1}^N \exp(F^*_{ij})}\,.
\end{equation}
Here, $\tilde{y_i}$ denotes the final predicted label for $i$th instance in the union of support and query set
and $F_{ij}^*$ denotes the $j$th component of predicted label from label propagation.
Then the loss function is computed as:
\begin{equation}
\label{ce}
	J(\varphi,\phi) = \sum_{i=1}^{N\times K+T}\sum_{j=1}^N-\mathbb{I}(y_i==j) \log(P(\tilde{y_i}=j|\bfx_i))\,,
\end{equation}
where $y_i$ means the ground-truth label of $\bfx_i$ and $\mathbb{I}(b)$ is an indicator function, $\mathbb{I}(b)=1$ if $b$ is true and $0$ otherwise.

Note that in Equation~(\ref{ce}), the loss is dependent on two set of parameters $\varphi$, $\phi$ (even though the dependency is implicit through $F^*_{ij}$). All these parameters are jointly updated by the episodic training in an end-to-end manner. 



\section{Experiments}
We evaluate and compare our TPN with state-of-the-art approaches on two datasets, i.e., \mini~\citep{metaLSTM} and \tiered~\citep{semi-proto}. The former is the most popular few-shot learning benchmark and the latter is a  much larger dataset released recently for few-shot learning. 

\subsection{Datasets}
\textbf{\mini}. The \mini~dataset is a collection of Imagenet~\citep{imagenet} for few-shot image recognition. It is composed of 100 classes randomly selected from Imagenet with each class containing 600 examples. In order to directly compare with state-of-the-art algorithms for few-shot learning, we rely on the class splits used by ~\cite{metaLSTM}, which includes 64 classes for training, 16 for validation, and 20 for test. All images are resized to $84\times 84$ pixels.

\textbf{\tiered}. Similar to \mini~, \tiered~\citep{semi-proto} is also a subset of Imagenet~\citep{imagenet}, but it has a larger number of classes from ILSVRC-12 (608 classes rather than 100 for \mini). Different from \mini, it has a hierarchical structure of broader categories corresponding to high-level nodes in Imagenet. The top hierarchy has 34 categories, which are divided into 20 training (351 classes), 6 validation (97 classes) and 8 test (160 classes) categories. 
The average number of examples in each class is 1281.
This high-level split strategy ensures that the training classes are distinct from the test classes semantically. This is a more challenging and realistic few-shot setting since there is no assumption that training classes should be similar to test classes. Similarly, all images are resized to $84\times 84$ pixels.

\subsection{Experimental Setup}
For fair comparison with other methods, we adopt a widely-used CNN~\citep{maml,prototypical} as the feature embedding function $f_{\varphi}$ (Section~\ref{embedding}). 
The hyper-parameter $k$ of $k$-nearest neighbour graph (Section~\ref{graph}) is set to $20$ and $\alpha$ of label propagation is set to $0.99$, as suggested in \cite{labelprop1}.


Following \cite{prototypical}, we adopt the episodic training procedure, i.e, we sample a set of $N$-way $K$-shot training tasks to mimic the $N$-way $K$-shot test problems. Moreover, \cite{prototypical} proposed a ``Higher Way '' training strategy which used more training classes in each episode than test case. However, we find that it is beneficial to train with more examples than test phase (Appendix \ref{sec:shots}). This is denoted as ``Higher Shot'' in our experiments. For 1-shot and 5-shot test problem, we adopt 5-shot and 10-shot training respectively. In all settings, the query number is set to 15 and the performance are averaged over 600 randomly generated episodes from the test set. 

All our models were trained with Adam \citep{adam} and an initial learning rate of $10^{-3}$. For \mini, we cut the learning rate in half every $10,000$ episodes and for \tiered, we cut the learning rate every $25,000$ episodes. The reason for larger decay step is that \tiered~has more classes and more examples in each class which needs larger training iterations. We ran the training process until the validation loss reached a plateau.

\subsection{Few-shot Learning Results}





We compare our method with several state-of-the-art approaches in various settings. Even though the transductive method has never been used explicitly, batch normalization layer was used transductively to share information between test examples. For example, in \cite{maml,first-order}, they use the query batch statistics rather than global BN parameters for the prediction, which leads to performance gain in the query set. 
Besides, we propose two simple transductive methods as baselines that explicitly utilize the query set. First, we propose the MAML+Transduction with slight modification of loss function to: $\mathcal{J}(\theta) = \sum_{i=1}^{T}\mathbf{y}_i\log \mathbb{P}(\widehat{\mathbf{y}}_i|\bfx_i) + \sum_{i,j=1}^{N\times K+T}W_{ij}\|\widehat{\mathbf{y}}_i-\widehat{\mathbf{y}}_j\|_2^2$ for transductive inference. The additional term serves as transductive regularization. Second, the naive heuristic-based label propagation methods~\citep{labelprop1} is proposed to explicitly model the transductive inference.  





\begin{table}[t]
\centering
\begin{threeparttable}
\small
\caption{Few-shot classification accuracies on \mini. All results are averaged over 600 test episodes. Top results are highlighted.}
\label{mini-results}
\begin{tabular}{lcccccc} \hline
                                       					&              & \multicolumn{2}{c}{5-way Acc} & \multicolumn{2}{c}{10-way Acc}                           \\
Model                                  					& Transduction & \multicolumn{1}{c}{1-shot} & \multicolumn{1}{c}{5-shot} & \multicolumn{1}{c}{1-shot} & \multicolumn{1}{c}{5-shot}\\ \hline
\textbf{MAML~\citep{maml}}             					& BN & 48.70  & 63.11 & 31.27 & 46.92    \\
\textbf{MAML+Transduction}             					& Yes & 50.83  & 66.19 & 31.83 & 48.23    \\
\textbf{Reptile~\citep{first-order}}                    & No & 47.07  & 62.74 & 31.10 & 44.66    \\
\textbf{Reptile + BN~\citep{first-order}} 	            & BN & 49.97  & 65.99 & 32.00 & 47.60    \\
\textbf{PROTO NET~\citep{prototypical}}                 & No & 46.14  & 65.77 & 32.88 & 49.29    \\
\textbf{PROTO NET (Higher Way)~\citep{prototypical}}	& No & 49.42  & 68.20 & 34.61 & 50.09    \\
\textbf{RELATION NET~\citep{compare}}                  	& BN & 51.38  & 67.07 & 34.86 & 47.94    \\ \hline
\textbf{Label Propagation}                              & Yes & 52.31  & 68.18 & 35.23 & 51.24\\
\textbf{TPN}                                            & Yes & \textbf{53.75}    & \textbf{69.43} & \textbf{36.62} & \textbf{52.32}    \\
\textbf{TPN (Higher Shot)}                              & Yes & \textbf{55.51}    & \textbf{69.86} & \textbf{38.44} & \textbf{52.77}    \\ \hline
\end{tabular}
\begin{tablenotes}
  	\item * ``Higher Way'' means using more classes in training episodes. ``Higher Shot'' means using more shots in training episodes. ``BN'' means information is shared among test examples using batch normalization.
  	\item $\dagger$ \textbf{Due to space limitation, we report the accuracy with 95\% confidence intervals in Appendix.}
\end{tablenotes} 
\end{threeparttable}
\end{table}


\begin{table}[t]
\centering
\begin{threeparttable}
\small
\caption{Few-shot classification accuracies on \tiered. All results are averaged over 600 test episodes. Top results are highlighted.}
\label{tiered-results}
\begin{tabular}{lccccc}
\hline
                                       						&              & \multicolumn{2}{c}{5-way Acc} & \multicolumn{2}{c}{10-way Acc}                           \\
Model                                  						& Transduction & \multicolumn{1}{c}{1-shot} & \multicolumn{1}{c}{5-shot} & \multicolumn{1}{c}{1-shot} & \multicolumn{1}{c}{5-shot} \\ \hline
\textbf{MAML~\citep{maml}}                          		& BN & 51.67  & 70.30 & 34.44 & 53.32  \\
\textbf{MAML + Transduction}                                & Yes & 53.23  & 70.83 & 34.78 & 54.67  \\
\textbf{Reptile~\citep{first-order}}                        & No & 48.97  & 66.47 & 33.67 & 48.04  \\
\textbf{Reptile + BN~\citep{first-order}}                   & BN & 52.36  & 71.03 & 35.32 & 51.98  \\
\textbf{PROTO NET~\citep{prototypical}}                     & No & 48.58  & 69.57 & 37.35 & 57.83  \\
\textbf{PROTO NET (Higher Way)~\citep{prototypical}}        & No & 53.31  & 72.69 & 38.62 & 58.32  \\
\textbf{RELATION NET~\citep{compare}}                  		& BN & 54.48  & 71.31 & 36.32 & 58.05  \\ \hline
\textbf{Label Propagation}                                  & Yes & 55.23  & 70.43 & 39.39 & 57.89  \\
\textbf{TPN}     				                            & Yes & \textbf{57.53}  & \textbf{72.85} & \textbf{40.93} & \textbf{59.17}   \\
\textbf{TPN (Higher Shot)}   	                            & Yes & \textbf{59.91}  & \textbf{73.30} & \textbf{44.80} & \textbf{59.44}   \\ \hline
\end{tabular}
\begin{tablenotes}
  	\item * ``Higher Way'' means using more classes in training episodes. ``Higher Shot'' means using more shots in training episodes. ``BN'' means information is shared among test examples using batch normalization.
  	\item $\dagger$ \textbf{Due to space limitation, we report the accuracy with 95\% confidence intervals in Appendix.}
\end{tablenotes} 
\end{threeparttable}
\end{table}

Experimental results are shown in Table~\ref{mini-results} and Table\ref{tiered-results}. Transductive batch normalization methods tend to perform better than pure inductive methods except for the ``Higher Way'' PROTO NET. Label propagation without learning to propagate outperforms other baseline methods in most cases, which verifies the necessity of transduction. The proposed TPN achieves the state-of-the-art results and surpasses all the others with a large margin even when the model is trained with regular shots. When ``Higher Shot'' is applied, the performance of TPN continues to improve especially for 1-shot case. 
This confirms that our model effectively finds the episodic-wise manifold structure of test examples through learning to construct the graph for label propagation.









Another observation is that the advantages of 5-shot classification is less significant than that of 1-shot case. For example, in 5-way \mini~, the absolute improvement of TPN over published state-of-the-art is 4.13\% for 1-shot and 1.66\% for 5-shot. 
To further investigate this, we experimented 5-way $k$-shot ($k=1,2,\cdots,10 $) experiments. The results are shown in Figure~\ref{5waykshot}. Our TPN performs consistently better than other methods with varying shots. Moreover, it can be seen that TPN outperforms other methods with a large margin in lower shots. With the shot increase, the advantage of transduction narrows since more labelled data are used. This finding agrees with the results in TSVM~\citep{tsvm}: when more training data are available, the bonus of transductive inference will be decreased.  



\begin{figure}[t]
  \centering
  \includegraphics[width=0.75\linewidth]{5way-kshot.pdf}
  \caption{5-way performance with various training/test shots.}
  \label{5waykshot}
\end{figure}


\subsection{Comparison with semi-supervised few-shot learning}

\begin{table}[ht]
\centering
\begin{threeparttable}
\small
\caption{Semi-supervised comparison on \mini.}
\label{semi-mini}
\begin{tabular}{lcccc}
\hline
Model   & \multicolumn{1}{c}{1-shot} & \multicolumn{1}{c}{5-shot} & \multicolumn{1}{c}{1-shot w/D} & \multicolumn{1}{c}{5-shot w/D} \\ \hline
\textbf{Soft $k$-Means~\citep{semi-proto}}          & 50.09 & 64.59 & 48.70 & 63.55 \\
\textbf{Soft $k$-Means+Cluster~\citep{semi-proto}}  & 49.03 & 63.08 & 48.86 & 61.27 \\
\textbf{Masked Soft $k$-Means~\citep{semi-proto}}   & 50.41 & 64.39 & 49.04 & 62.96 \\ \hline
\textbf{TPN-semi}                                   & \textbf{52.78} & \textbf{66.42} & \textbf{50.43} & \textbf{64.95}\\ \hline
\end{tabular}
\begin{tablenotes}
  	\item * ``w/D'' means with distraction. In this setting, many of the unlabelled data are from the so-called distraction classes , which is different from the classes of labelled data.
  	\item $\dagger$ \textbf{Due to space limitation, we report the accuracy with 95\% confidence intervals in Appendix.}
\end{tablenotes} 
\end{threeparttable}
\end{table}


\begin{table}[ht]
\centering
\begin{threeparttable}
\small
\caption{Semi-supervised comparison on~\tiered.}
\label{semi-tiered}
\begin{tabular}{lcccc}
\hline
Model                            						 & \multicolumn{1}{c}{1-shot} & \multicolumn{1}{c}{5-shot} & \multicolumn{1}{c}{1-shot w/D} & \multicolumn{1}{c}{5-shot w/D} \\ \hline
\textbf{Soft $k$-Means~\citep{semi-proto}}          & 51.52 & 70.25 & 49.88 & 68.32\\
\textbf{Soft $k$-Means+Cluster~\citep{semi-proto}}  & 51.85 & 69.42 & 51.36 & 67.56\\
\textbf{Masked Soft $k$-Means~\citep{semi-proto}}   & 52.39 & 69.88 & 51.38 & 69.08\\ \hline
\textbf{TPN-semi}                                   & \textbf{55.74} & \textbf{71.01} & \textbf{53.45} & \textbf{69.93}\\ \hline
\end{tabular}
\begin{tablenotes}
  	\item * ``w/D'' means with distraction. In this setting, many of the unlabelled data are from the so-called distraction classes , which is different from the classes of labelled data.
  	\item $\dagger$ \textbf{Due to space limitation, we report the accuracy with 95\% confidence intervals in Appendix.}
\end{tablenotes} 
\end{threeparttable}
\end{table}

The main difference of traditional semi-supervised learning and transduction is the source of unlabeled data. Transductive methods directly use test set as unlabeled data while semi-supervised learning usually has an extra unlabeled set. In order to compare with semi-supervised methods, we propose a semi-supervised version of TPN, named TPN-semi, which classifies one test example each time by propagating labels from the labeled set and extra unlabeled set. 

We use ~\mini~and~\tiered~with the labeled/unlabeled data split proposed by \cite{semi-proto}. Specifically, they split the images of each class into disjoint labeled and unlabeled sets. For \mini, the ratio of labeled/unlabeled data is 40\% and 60\% in each class. Likewise,  the ratio is 10\% and 90\% for \tiered. All semi-supervised methods (including TPN-semi) sample support/query data from the labeled set (e.g, 40\% from \mini) and sample unlabeled data from the unlabeled sets (e.g, 60\% from \mini). In addition, there is a more challenging situation where many unlabelled examples from other distractor classes (different from labelled classes). 


Following \cite{semi-proto}, we report the average accuracy over 10 random labeled/unlabeled splits and the uncertainty computed in standard error. Results are shown in Table~\ref{semi-mini} and Table~\ref{semi-tiered}. 
It can be seen that TPN-semi outperforms all other algorithms with a large margin, especially for 1-shot case. Although TPN is originally designed to perform transductive inference, we show that it can be successfully adapted to semi-supervised learning tasks with little modification. In certain cases where we can not get all test data, the TPN-semi can be used as an effective alternative algorithm.





\section{Conclusion}
In this work, we proposed the transductive setting for few-shot learning.
Our proposed approach, namely \textit{Transductive Propagation Network} (TPN), utilizes the entire test set for transductive inference. Specifically, our approach is composed of four steps: feature embedding, graph construction, label propagation, and loss computation. Graph construction is a key step that produces example-wise parameters to exploit the manifold structure in each episode. In our method, all parameters are learned end-to-end using cross-entropy loss with respect to the ground truth labels and the prediction scores in the query set. We obtained the state-of-the-art results on \mini~and \tiered. Also, the semi-supervised adaptation of our algorithm achieved higher results than other semi-supervised methods. 
In future work, we are going to explore the episodic-wise distance metric rather than only using example-wise parameters for the Euclidean distance.


\subsubsection*{Acknowledgments}
Saehoon Kim, Minseop Park, and Eunho Yang were supported by Samsung Research Funding \& Incubation Center of Samsung Electronics under Project Number SRFC-IT1702-15. Yanbin Liu and Yi Yang are in part supported by AWS Cloud Credits for Research. 

\small{
\bibliographystyle{named}
\bibliography{ICLR2019}
}



\newpage




\appendix




\section{Ablation Study}

In this section, we performed several ablation studies with respect to training shots and query number.

\subsection{Training Shots}
\label{sec:shots}
\begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\linewidth]{shot_exps_new.pdf}
  \caption{Model performance with different training shots. The $x$-axis indicates the number of shots in training, and the $y$-axis indicates 5-way test accuracy for 1-shot and 5-shot. Error bars indicate 95\% confidence intervals as computed over 600 test episodes. }
  \label{shot_exps}
\end{figure}


\subsection{Query Number}

\begin{table}[ht]
\centering
\small
\caption{Accuracy with various query numbers}
\begin{tabular}{l|llllll}
\hline
           & \multicolumn{6}{c}{\mini~1-shot} \\ \hline
           & 5     & 10    & 15    & 20    & 25     & 30                \\ \hline
Train=15   & 52.29 & 52.95 & 53.75 & 53.92 & 54.57  & 54.47   \\
Test=15    & 53.53 & 53.72 & 53.75 & 52.79 & 52.84  & 52.47   \\
Train=Test & 51.94 & 53.47 & 53.75 & 54.00 & 53.59  & 53.32  \\ \hline
           & \multicolumn{6}{c}{\mini~5-shot}  \\ \hline
           & 5     & 10    & 15    & 20    & 25    & 30 \\ \hline
Train=15   & 66.97 & 69.30 & 69.43 & 69.92 & 70.54 &  70.36    \\
Test=15    & 68.50 & 68.85 & 69.43 & 69.26 & 69.12 & 68.89    \\      
Train=Test & 67.55 & 69.22 & 69.43 & 69.85 & 70.11 & 69.94    \\ \hline
\end{tabular}
\label{tab:query}
\end{table}

At first, we designed three experiments to study the influence of the query number in both training and test phase: (1) fix training query to 15; (2) fix test query to 15; (3) training query equals test query. The results are shown in Table \ref{tab:query}. Some conclusions can be drawn from this experiment: (1) When training query is fixed, increasing the test query will lead to the performance gain. Moreover, even a small test query (e.g., 5) can yield good performance; (2) When test query is fixed, the performance is relatively stable with various training query numbers; (3) If the query number of training matches test, the performance can also be improved with increasing number. 


\subsection{Results on ResNet}
In this paper, we use a 4-layer neural network structure as described in Section~\ref{embedding} to make a fair comparison. 
Currently, there are two common network architectures in few-shot learning: 4-layer ConvNets (e.g., \cite{maml,prototypical,compare}) and 12-layer ResNet (e.g., \cite{snail,rapid,discriminative,tadam}). Our method belongs to the first one, which contains much fewer layers than the ResNet setting. Thus, it is more reasonable to compare algorithms such as TADAM~\citep{tadam} with ResNet version of our method. To make this comparison, we implemented our algorithm with ResNet architecture on miniImagenet dataset and show the results in Table~\ref{tab:resnet}.

\begin{table}[ht]
\centering
\small
\caption{ResNet results on~\mini}
\begin{tabular}{l|ll}
\hline
Method & 1-shot & 5-shot    \\
\hline
SNAIL~\citep{snail}        & 55.71 & 68.88  \\
adaResNet~\citep{rapid}    & 56.88 & 71.94  \\
Discriminative k-shot~\citep{discriminative} & 56.30 & 73.90  \\ 
TADAM~\citep{tadam}        & 58.50 & \textbf{76.70} \\
\hline
TPN                        & \textbf{59.46} & 75.65 \\
\end{tabular}
\label{tab:resnet}
\end{table}

It can be seen that we beat TADAM for 1-shot setting. For 5-shot, we outperform all other recent high-performance methods except for TADAM. 





\subsection{Closed-form solution vs Iterative updates}
\label{sec:time}

There is a potential concern that the closed-form solution of label propagation can not scale to large-scale matrix. 
We relieve this concern from two aspects. On one hand, the few-shot learning problem assumes that training examples in each class is quite small (only 1 or 5). In this situation, Eq~\ref{eq:lp_iter} and the closed-form version can be efficiently solved, since the dimension of $S$ is only $80\times 80$ (5-way, 1-shot, 15-query) or $100\times 100$ (5-way, 5-shot, 15-query). On the other hand, there are plenty of prior work on the scalability and efficiency of label propagation, such as \cite{scale1,scale2}, which can extend our work to large-scale data. 

Furthermore, on miniImagenet, we performed iterative optimization and got 53.05/68.75 for 1-shot/5-shot experiments with only 10 steps. This is slightly worse than closed-form version (53.75/69.43). We attribute this slightly worse accuracy to the inaccurate computation and unstable gradients caused by multiple step iterations. 






\subsection{Accuracy with 95\% confidence intervals}
\label{sec:std}

\begin{table}[h]
\centering
\begin{threeparttable}
\small
\caption{Few-shot classification accuracies on \mini. All results are averaged over 600 test episodes and are reported with 95\% confidence intervals. Top results are highlighted.}
\label{mini-results-std}
\begin{tabular}{lcccccc} \hline
                                       					&              & \multicolumn{2}{c}{5-way Acc} & \multicolumn{2}{c}{10-way Acc}                           \\
Model                                  					& Transduction & \multicolumn{1}{c}{1-shot} & \multicolumn{1}{c}{5-shot} & \multicolumn{1}{c}{1-shot} & \multicolumn{1}{c}{5-shot}\\ \hline
\textbf{MAML}             		& BN & 48.70$\pm$1.84 & 63.11$\pm$0.92 & 31.27$\pm$1.15 & 46.92$\pm$1.25    \\
\textbf{MAML+Transduction}      & Yes& 50.83$\pm$1.85 & 66.19$\pm$1.85 & 31.83$\pm$0.45 & 48.23$\pm$1.28    \\
\textbf{Reptile}                & No & 47.07$\pm$0.26 & 62.74$\pm$0.37 & 31.10$\pm$0.28 & 44.66$\pm$0.30    \\
\textbf{Reptile + BN} 	        & BN & 49.97$\pm$0.32 & 65.99$\pm$0.58 & 32.00$\pm$0.27 & 47.60$\pm$0.32    \\
\textbf{PROTO NET}              & No & 46.14$\pm$0.77 & 65.77$\pm$0.70 & 32.88$\pm$0.47 & 49.29$\pm$0.42    \\
\textbf{PROTO NET (Higher Way)}	& No & 49.42$\pm$0.78 & 68.20$\pm$0.66 & 34.61$\pm$0.46 & 50.09$\pm$0.44    \\
\textbf{RELATION NET}           & BN & 51.38$\pm$0.82 & 67.07$\pm$0.69 & 34.86$\pm$0.48 & 47.94$\pm$0.42    \\ \hline
\textbf{Label Propagation}      & Yes& 52.31$\pm$0.85 & 68.18$\pm$0.67 & 35.23$\pm$0.51 & 51.24$\pm$0.43\\
\textbf{TPN}                    & Yes& \textbf{53.75$\pm$0.86} & \textbf{69.43$\pm$0.67} & \textbf{36.62$\pm$0.50} & \textbf{52.32$\pm$0.44}    \\
\textbf{TPN (Higher Shot)}      & Yes & \textbf{55.51$\pm$0.86} & \textbf{69.86$\pm$0.65} & \textbf{38.44$\pm$0.49} & \textbf{52.77$\pm$0.45}    \\ \hline
\end{tabular}
\begin{tablenotes}
  	\item * ``Higher Way'' means using more classes in training episodes. ``Higher Shot'' means using more shots in training episodes. ``BN'' means information is shared among test examples using batch normalization.
\end{tablenotes} 
\end{threeparttable}
\end{table}


\begin{table}[t]
\centering
\begin{threeparttable}
\small
\caption{Few-shot classification accuracies on \tiered. All results are averaged over 600 test episodes and are reported with 95\% confidence intervals. Top results are highlighted.}
\label{tiered-results-std}
\begin{tabular}{lccccc}
\hline
                                       						&              & \multicolumn{2}{c}{5-way Acc} & \multicolumn{2}{c}{10-way Acc}                           \\
Model                                  						& Transduction & \multicolumn{1}{c}{1-shot} & \multicolumn{1}{c}{5-shot} & \multicolumn{1}{c}{1-shot} & \multicolumn{1}{c}{5-shot} \\ \hline
\textbf{MAML}                   & BN & 51.67$\pm$1.81 & 70.30$\pm$1.75 & 34.44$\pm$1.19 & 53.32$\pm$1.33  \\
\textbf{MAML + Transduction}    & Yes& 53.23$\pm$1.85 & 70.83$\pm$1.78 & 34.78$\pm$1.18 & 54.67$\pm$1.26  \\
\textbf{Reptile}                & No & 48.97$\pm$0.21 & 66.47$\pm$0.21 & 33.67$\pm$0.28 & 48.04$\pm$0.30  \\
\textbf{Reptile + BN}           & BN & 52.36$\pm$0.23 & 71.03$\pm$0.22 & 35.32$\pm$0.28 & 51.98$\pm$0.32  \\
\textbf{PROTO NET}              & No & 48.58$\pm$0.87 & 69.57$\pm$0.75 & 37.35$\pm$0.56 & 57.83$\pm$0.55  \\
\textbf{PROTO NET (Higher Way)} & No & 53.31$\pm$0.89 & 72.69$\pm$0.74 & 38.62$\pm$0.57 & 58.32$\pm$0.55  \\
\textbf{RELATION NET}           & BN & 54.48$\pm$0.93 & 71.31$\pm$0.78 & 36.32$\pm$0.62 & 58.05$\pm$0.59  \\ \hline
\textbf{Label Propagation}      & Yes& 55.23$\pm$0.96 & 70.43$\pm$0.76 & 39.39$\pm$0.60 & 57.89$\pm$0.55  \\
\textbf{TPN}     				& Yes& \textbf{57.53$\pm$0.96} & \textbf{72.85$\pm$0.74} & \textbf{40.93$\pm$0.61} & \textbf{59.17$\pm$0.52}   \\
\textbf{TPN (Higher Shot)}   	& Yes& \textbf{59.91$\pm$0.94} & \textbf{73.30$\pm$0.75} & \textbf{44.80$\pm$0.62} & \textbf{59.44$\pm$0.51}   \\ \hline
\end{tabular}
\begin{tablenotes}
  	\item * ``Higher Way'' means using more classes in training episodes. ``Higher Shot'' means using more shots in training episodes. ``BN'' means information is shared among test examples using batch normalization.
\end{tablenotes} 
\end{threeparttable}
\end{table}


\begin{table}[ht]
\centering
\begin{threeparttable}
\small
\caption{Semi-supervised comparison on \mini.}
\label{semi-mini-std}
\begin{tabular}{lcccc}
\hline
Model   & \multicolumn{1}{c}{1-shot} & \multicolumn{1}{c}{5-shot} & \multicolumn{1}{c}{1-shot w/D} & \multicolumn{1}{c}{5-shot w/D} \\ \hline
\textbf{Soft $k$-Means}          & 50.09$\pm$0.45 & 64.59$\pm$0.28 & 48.70$\pm$0.32 & 63.55$\pm$0.28 \\
\textbf{Soft $k$-Means+Cluster}  & 49.03$\pm$0.24 & 63.08$\pm$0.18 & 48.86$\pm$0.32 & 61.27$\pm$0.24 \\
\textbf{Masked Soft $k$-Means}   & 50.41$\pm$0.31 & 64.39$\pm$0.24 & 49.04$\pm$0.31 & 62.96$\pm$0.14 \\ \hline
\textbf{TPN-semi}                & \textbf{52.78$\pm$0.27} & \textbf{66.42$\pm$0.21} & \textbf{50.43$\pm$0.84} & \textbf{64.95$\pm$0.73}\\ \hline
\end{tabular}
\begin{tablenotes}
  	\item * ``w/D'' means with distraction. In this setting, many of the unlabelled data are from the so-called distraction classes , which is different from the classes of labelled data.
\end{tablenotes} 
\end{threeparttable}
\end{table}


\begin{table}[ht]
\centering
\begin{threeparttable}
\small
\caption{Semi-supervised comparison on~\tiered.}
\label{semi-tiered-std}
\begin{tabular}{lcccc}
\hline
Model                            						 & \multicolumn{1}{c}{1-shot} & \multicolumn{1}{c}{5-shot} & \multicolumn{1}{c}{1-shot w/D} & \multicolumn{1}{c}{5-shot w/D} \\ \hline
\textbf{Soft $k$-Means}          & 51.52$\pm$0.36 & 70.25$\pm$0.31 & 49.88$\pm$0.52 & 68.32$\pm$0.22\\
\textbf{Soft $k$-Means+Cluster}  & 51.85$\pm$0.25 & 69.42$\pm$0.17 & 51.36$\pm$0.31 & 67.56$\pm$0.10\\
\textbf{Masked Soft $k$-Means}   & 52.39$\pm$0.44 & 69.88$\pm$0.20 & 51.38$\pm$0.38 & 69.08$\pm$0.25\\ \hline
\textbf{TPN-semi}                & \textbf{55.74$\pm$0.29} & \textbf{71.01$\pm$0.23} & \textbf{53.45$\pm$0.93} & \textbf{69.93$\pm$0.80}\\ \hline
\end{tabular}
\begin{tablenotes}
  	\item * ``w/D'' means with distraction. In this setting, many of the unlabelled data are from the so-called distraction classes , which is different from the classes of labelled data.
\end{tablenotes} 
\end{threeparttable}
\end{table}







\begin{comment}
\subsection{Noise of label propagation}
In order to discover the stability and robustness of our label propagation algorithm, we experimented with noisy labels and incorrect labels. Two groups of experiments were performed in~\mini: (1) label initialization for unlabeled data with normal or uniform distribution; (2) use various number of incorrect labels for labeled data (only experimented on 5-shot). Corresponding results are shown in Table~\ref{noise} and Table~\ref{incorrect}. The results show that with different kinds of label disturbance, our algorithm always achieved stable results. Specifically, with noise initialization, 5-shot setting is more stable than 1-shot setting since it contains more labeled data. With label corruption, our algorithm yielded good results even with 20\% incorrect labels.

\begin{table}[h]
\footnotesize
\label{noise}
\centering
\caption{Accuracy with noisy labels}
\begin{tabular}{c|c|ccc|ccc}
\hline
\multirow{2}{*}{\textit{mini}} & \multicolumn{1}{c|}{\multirow{2}{*}{Baseline}} & \multicolumn{3}{c|}{Uniform initial for unlabeled} & \multicolumn{3}{c}{Normal initial for unlabeled}  \\ \cline{3-8} 
                      & \multicolumn{1}{c|}{}      & U(0,0.01) & U(0,0.05) & U(0,0.1) & $\mathcal{N}$(0,0.01) & $\mathcal{N}$(0.05) & $\mathcal{N}$(0,0.1)         \\ \hline
5way1shot             &                       &      &      &     &                  &                &                  \\
5way5shot             &                       &      &      &     &                  &                &    \\ \hline
\end{tabular}
\end{table}

\begin{table}[h]
\footnotesize
\label{incorrect}
\centering
\caption{Accuracy with incorrect labels}
\begin{tabular}{c|c|ccccc}
\hline
\multirow{2}{*}{\textit{mini}} & \multicolumn{1}{c|}{\multirow{2}{*}{Baseline}} & \multicolumn{5}{c}{number (ratio) of incorrect labels} \\ \cline{3-7} 
                      & \multicolumn{1}{c|}{}     & 1(4\%) & 2(8\%) & 3(12\%) & 4(16\%) & 5(20\%)        \\ \hline
5way5shot  &     &       &   &    &    &         \\ \hline
\end{tabular}
\end{table}
\end{comment}

\end{document}
