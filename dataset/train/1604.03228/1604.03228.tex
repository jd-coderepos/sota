\documentclass[11pt]{article}

\usepackage[margin=1in]{geometry}

\usepackage{hyperref}
\pdfoutput=1 

\usepackage{amsthm}
\usepackage[cmex10]{amsmath}
\usepackage{amssymb}
\usepackage[caption=false,font=scriptsize]{subfig}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem*{definition}{Definition}
\usepackage[pdftex]{graphicx}
\usepackage{array}

\usepackage{balance}
\usepackage{mathptmx}


\usepackage{pbox}



\usepackage{algorithm}
\usepackage[noend]{algorithmic}
  
\usepackage{xspace}
\newcommand{\eps}{\ensuremath{\varepsilon}}
\newcommand{\ours}{{\sc MRG}\xspace}
\newcommand{\ene}{{\sc EIM}\xspace}
\newcommand{\gon}{{\sc Gon}\xspace}
\newcommand{\unif}{{\sc Unif}\xspace}
\newcommand{\gauss}{{\sc Gau}\xspace}
\newcommand{\unbalanced}{{\sc UnB}\xspace}

\newcommand{\poker}{{\sc Poker Hand}\xspace}
\newcommand{\kdd}{{\sc KDD Cup}\xspace}



\newcommand{\OPT}{\ensuremath{\mathit{OPT}}}

\setlength{\textfloatsep}{4.4mm}
\usepackage{siunitx}


\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}


\title{\Large Efficient Parallel Algorithms for -Center Clustering}

\author{Jessica McClintock\\
{Department of Computing and Information Systems}\\
{The University of Melbourne}\\
{jmcclintock@unimelb.edu.au}
\and 
Anthony Wirth\\
{Department of Computing and Information Systems}\\
{The University of Melbourne}\\
awirth@unimelb.edu.au
}
\date{}
\maketitle



\begin{abstract} 
The -center problem is one of several classic NP-hard clustering questions.
For contemporary massive data sets, RAM-based algorithms become impractical.
And although there exist good sequential algorithms for -center, they are not easily parallelizable.

In this paper, we design and implement parallel approximation algorithms for
this problem.
We observe that Gonzalez's greedy algorithm can be efficiently parallelized in
several MapReduce rounds; in practice, we find that two rounds are sufficient,
leading to a -approximation.
We contrast this with an existing parallel algorithm for -center that runs
in a constant number of rounds, and offers a -approximation.
In depth runtime analysis reveals that this scheme is often slow, and that its
sampling procedure only runs if~ is sufficiently small, relative to the
input size.
To trade off runtime for approximation guarantee, we parameterize this
sampling algorithm, and find in our experiments that the algorithm is not only
faster, but sometimes more effective.
Yet the parallel version of Gonzalez is about~ times faster than both its
sequential version and the parallel sampling algorithm, barely compromising
solution quality.
\end{abstract}


\medskip
\paragraph*{Keywords}
\noindent
Clustering, -center, approximation algorithms, parallel algorithms.
 

\section{Introduction}

Clustering is a fundamental task in interpreting data sets in contexts such as social networking, event recognition and bioinformatics.
For many applications, the data sets can be prohibitively large, and there may be
insufficient RAM to perform the necessary calculations efficiently,
even when seeking approximate solutions. 
There are parallel-computing schemes such as MapReduce~\cite{dean2008mapreduce}
that offer the ability to overcome the memory obstacle.


The -center problem is a famous clustering problem, is NP-hard, and has
well known (sequential) polynomial-time algorithms that offer essentially the best
approximation possible.
We describe a multi-round parallel algorithm for -center, analyze in detail several
parallel algorithms and compare them with
one of these sequential methods.
Inspired by theoretical guarantees and evaluation, we run comprehensive
experiments, including trading off approximation for running time.

\subsection{Clustering algorithms}

Generally, clustering problems involve optimizing some function that indicates how well the clusters
portray underlying structures in the data.
In a \emph{metric} clustering problem, the
weights, representing the similarity between objects,
observe the triangle inequality.
The best-known example is of course the Euclidean metric.
In the context of clustering, points in a metric space can be modelled as vertices in a complete graph.
Each vertex stands for a data point, and each edge is weighted to
indicate the distance (or dissimilarity) between the two adjacent points.
The -center problem is one of the fundamental NP-hard clustering problems on a metric input.



\begin{definition}[-\textsc{Center}]
Find a set of at most~ centers ---
here we assume they are a subset of the vertices ---
such that the maximum distance from a vertex to its assigned center
is minimized.
The key task is to choose the optimum set of ~centers, as each of the
remaining vertices would be assigned to its nearest center.
For a set of points~, solution set~ containing at most~ vertices,
and a distance function~, the objective of this problem can be considered as minimizing the objective .
\end{definition}	


This objective has many applications, from vehicle routing to document clustering, in which it relates to concepts such as the furthest traveling time, or the least ``similar'' document. 
It can alternatively be considered to be  minimizing the (maximum)
covering \emph{radius} of the clusters.
Related classic NP-hard clustering questions include
-median, -means, and facility location problems.

 Via a reduction from the \textsc{Dominating set} problem, 
 Hsu and Nemhauser proved that, for all~, it is NP-hard to guarantee approximations within a factor  of optimum for -center~\cite{hsu1979easy}. 
Also exploiting the connection with the dominating set problem, Hochbaum and Shmoys gave a -approximation algorithm for the -center problem~\cite{hochbaum1985best}.
Gonzalez introduced an greedy -approximation algorithm for the -center problem~\cite{gonzalez1985clustering}.
Each of these -center algorithms is inherently sequential,
none admitting a simple parallel implementation. 

\subsection{Parallel algorithms}

While approximation algorithms provide guaranteed performance with 
polynomial-time complexity, often data sets are large enough that running
these algorithms efficiently requires prohibitively large amounts of RAM. 
For such instances, we can instead design algorithms that split the data across multiple machines, and process each part in parallel before aggregating the results. 
One important paradigm for parallel computing is
MapReduce~\cite{dean2008mapreduce}. 
There are several fast approximation algorithms for
famous clustering problems, such as -center and -median, in
MapReduce~\cite{blelloch2010parallel,chierichetti2010max,ene2011fast}.
Karloff et al.~\cite{karloff2010model} introduced a theoretical
model of computation for the MapReduce paradigm that is often applied
to the analysis of MapReduce algorithms~\cite{bahmani2012scalable,lattanzi2011filtering}.
They offered a comprehensive method for theoretically structuring algorithms for MapReduce,
and defined a family of classes for MapReduce algorithms.

A MapReduce algorithm consists of a series of interleaving rounds of sequential \emph{mappers} and parallel \emph{reducers}.
A map round assigns each data point independently to some reducer(s);
the reducers run in parallel, each performing some procedure
on the subset of points it has been assigned.
A program in MapReduce may consist of several iterations
of mappers and reducers, each involving potentially different map and reduce functions.

Both the -means~\cite{bahmani2012scalable} and -median~\cite{ene2011fast} problems have been adapted to the MapReduce framework.


\subsection{Our contribution}
We provide a very careful and detailed examination both of the best-known
MapReduce approximation algorithm for -center~\cite{ene2011fast}, based on
sampling,
and a parallel implementation of Gonzalez's algorithm (that typically gives a
-approximation).
The -round special case of the latter approach was recently considered by Malkomes et
al.~\cite{malkomes2015fast}, although their analysis and experiments differ
considerably from ours.
We describe in depth the performance and computational requirements of these
approaches, and detail how this procedure can be adapted to allow for cases where RAM is insufficient even for the -round parallel solution.
Based in part on a careful calculation of its running time,
we generalize the sampling MapReduce scheme of Ene et al.~\cite{ene2011fast},
to trade off approximation guarantee for speed.

Our experiments show that the parallelized Gonzalez approach is often~100 times faster than the alternatives, while being almost as effective.
These are the first experimental results for the -center algorithm of Ene et al.~\cite{ene2011fast}.
Our results conform with the findings of Malkomes et
al.~\cite{malkomes2015fast}, regarding the performance of their greedy approach.


\section{Related work}

\subsection{Approximations}
The -center problem was first adapted to the MapReduce scheme
by Ene et al.~\cite{ene2011fast}.
Their algorithm selects a uniformly random sample of the points,~, and
adds points to~ until most vertices of the graph are
within a bounded distance of the sample.
Finally, it adds remaining unrepresented vertices to~. 
A sequential -center algorithm, with approximation factor~,
is then run on~.
With high probability,
the~ resulting centers constitute
a -approximation for the -center instance.
When implemented using one of the -approximation algorithms described
above, with high probability, this results in a -approximation overall. 
Ene et al.~\cite{ene2011fast} apply a similar scheme to the -median
problem, with an -approximation (where~ is a the factor
of the standard approximation for -median).


Recently, there has been increased interest in adapting -center
to Map\-Reduce. 
Ceccarello et al.~\cite{DBLP:CeccarelloPPU14} gave
a MapReduce diameter-approximation procedure with low parallel depth.
From this, they derive a
-center solution for graphs with unit-weight edges: 
for ,
with high probability, this is a -approximation. 
Im and Moseley~\cite{im2015} have described a
randomized -round -approximation algorithm that requires
prior knowledge of the value of the optimal solution.
Although they have announced that this leads
to a -round -approximation without the requirement,
the details have yet to be outlined.
Very recently, Malkomes et al.~\cite{malkomes2015fast} gave a -round approach similar to ours.



\subsection{Experiments}
Ene et al.~\cite{ene2011fast} reported that their -center MapReduce scheme
performs poorly due to the sensitivity of -center to sampling.
Unfortunately, there are no results nor implementation details to confirm this.
In combination with another simpler algorithm, we investigate the empirical performance their -center scheme in greater detail.

Conversely, their -median implementation performs significantly better than the worst-case guarantee.
Solutions are comparable to sequential algorithms with much better bounds. 
Ene et al.'s results were based on the -approximation algorithm
from Arya et al.~\cite{arya2004local}.
There have been recent advances in -median approximation algorithms, by Byrka et al.~\cite{DBLP:ByrkaPRST15}, as well as by Li and Svensson~\cite{li2013approximating}, and including these might improve the approximation bound.


\section{Parallel \emph{k}-center}

We describe and analyze an approximation algorithm for the -center problem that, for most practical cases, achieves a -approximation in only two MapReduce rounds.
The intuition is that a sequential -center algorithm finds in the first
round a sample from  each of the reducers
such that the distance to all of the unsampled points is bounded.
Running a standard factor- algorithm on the sample
reveals a factor- solution to the whole instance.
Additional rounds can be performed in cases where even the sample is too large
for a single machine:
this would usually occur for very large values of~. 
Experiments show that this approach is often as good as that of the baseline
sequential algorithm.
The -round case of our algorithm is similar to the approach of Malkomes et
al.~\cite{malkomes2015fast}.
Along with generalizing to larger instances, we analyze the run time of these
algorithms in more detail,
and provide an alternative, shorter proof of the two-round factor-four
approximation.

\subsection{Description}

In this paper, the standard~-center approach is the factor--approximation
of Gonzalez~\cite{gonzalez1985clustering}, which we refer to as \gon.
This algorithm chooses an arbitrary vertex from the graph, and marks it as a center.
At each following step, the vertex farthest from the existing centers is marked as a new center,
until~ centers have been chosen.
As the edge weights comprise a metric, the triangle inequality ensures that the resulting set of centers comprises a -factor approximation. 


\paragraph*{Parallelized version}
Given a point set~ and a metric~, with~ representing the optimal
covering radius,
Algorithm~\ref{alg:mr} obtains a set of centers~
for which all points
in~ -- where  partitions~ -- are within radius  from~. 
Running \gon on  obtains~ centers whose
covering radius for~ is~.
Assume that we have~ machines each with capacity~.
If  and  then,
due to the triangle inequality, this results in a -approximation MapReduce algorithm for -center.
If the sample is too large to fit onto the final machine, further iterations of the first round can be run on the sample until there are few enough points.
Each additional round increases the approximation ratio by~.

We dub this multi-round scheme
for -center \ours, for ``MapReduce Gonzalez'', as shown in 
Algorithm~\ref{alg:mr}.

\begin{algorithm}\begin{algorithmic}[1]
\small
\STATE 
\WHILE{ }
\STATE The mapper arbitrarily partitions~ into sets  such that  and , and each set  is sent to a reducer~. 
\STATE In parallel, each reducer~ runs \gon on~, and returns a set~ containing the ~centers found.
\STATE 
\ENDWHILE
\STATE The mapper sends all points in  to a single reducer.
\STATE This reducer runs \gon on , and returns the set of centers .
\RETURN .
\end{algorithmic}
\caption{}
\label{alg:mr}
\end{algorithm}



\subsection{Approximation}

Algorithm \ours clearly
runs in polynomial time; to prove the four approximation of the -round
case, we prove the following intermediate result.
For an arbitrary subset~ of the vertex set~,
let~ denote the set of points in the solution 
obtained by running \gon on~, and let  denote the value,
the covering radius, of this solution.

\begin{lemma}\label{thm:approx}
For each , .
\end{lemma}


\begin{proof}
Let~ be an optimal set of centers.
The vertex set~ can be partitioned into~ sets 
such that  all points in set~ are within  of some
center .


First, assume every set  has exactly one point.
This point,~,
can serve as the center
for every point in~.
Then every point~ in , and hence in , is within
 of~,
as both~ and~ are within  of~.

However, if there is some partition~
with , then points in the same partition are within  from each
other. \gon adds a new center to~
only when it is the farthest from the points previously added to~.
The presence of two centers within  implies that all
points in~ are within  of~
(if there were some point farther, it would be in~ instead).


Therefore, for every subset~ of~, the value of the -center solution
returned by \gon on~ is at most twice the optimal solution for~.
\end{proof}



With sufficient space for~,
the consequence of Lemma~\ref{thm:approx} is  a  factor-four approximation.
\begin{lemma}
\label{thm:mr}
If  and , then the -center algorithm can be implemented in MapReduce in two rounds with a -approximation guarantee. 
\end{lemma}

\begin{proof}
Let~ refer to the points mapped to reducer~.
Since we run \gon on~, every point in~ is within
 of a center in~ and hence in~.

According to Lemma~\ref{thm:approx},
running \gon on~ arrives at a set of centers~
that is a  solution on~.
By the triangle inequality, it then follows that every vertex in the graph is
within  of the ~centers~.
\end{proof}

We now describe the properties of the setup and input for when \ours
can run effectively in two rounds.
The capacity required is ,
based on which of the two rounds receives the most points. 
We assume that , otherwise the solution to -center is trivial.
We further assume that :
if this is not the case, then we can reduce
the number of machines.
For small~, we only require that there is sufficient space across the machines to store the data set: 
that is, . 
We could also exploit external memory, for example by running multiple instances of our MapReduce algorithm and using a -center
algorithm on the disjoint union of the solutions;
such cases are beyond the scope of this paper.

\subsection{Multi-round analysis}


If , we
lack the required memory to store the sample on a single machine, and therefore run further iterations of the while loop.  
In such instances, \ours uses more MapReduce rounds, loosening the approximation guarantee.


\begin{lemma}
\label{thm:mr_rounds}
If  and , then the -center problem can be implemented in  rounds with a -approximation, where~ is chosen such that inequality~\ref{eq:inequality} is satisfied.
\end{lemma}

During each round, the number of centers is decreased, ending when they fit on a single machine:
each additional round adds two to the approximation factor.
As  and , it follows that .
Even relaxing the requirement that , it is still necessary
that .
Without this condition, selecting~ centers
from a single machine seems to require incorporating external memory in some manner. 


Assuming that , after the first round we have  centers, so we send them to  machines.
After the second round, we have  centers, which we can send to  machines.  
In general,
the number of machines required after~ rounds observes the bound

and we can run the final round when .
As~ increases, the second term in the inequality approaches , which
itself will be less than~ only if .
Intuitively, during each round we select  centers from each of the machines, so if~ is close to~ then the reduction in the number of centers in each round will be small.



\section{Revisiting the sampling approach}

In this section, we introduce a generalization of
Ene et al.'s~\cite{ene2011fast} iterative-sampling procedure.
As we show below, their algorithm is slower, but is more effective on the whole, than the sequential and parallel versions of Gonzalez's algorithm.
So that we can trade off runtime with approximation ratio,
we add a new parameter to the iterative-sampling approach, and call this
generalization \ene.
Before this, we make some alterations to the scheme to prevent eccentric behaviors that sometimes occur.



\subsection{Termination}
The core of Ene et al.'s scheme is shown as Algorithm~\ref{alg:EIM-MRS}.
Our implementation this algorithm adjusts the removal of points from~
to ensure that the size of the set decreases in every iteration.
For our implementation of line~\ref{step:keepx},
we remove vertices whose distance from~ is \emph{equal} to that
from~ to~. 
In the original presentation such a vertex would remain in~,
which might lead to iterations in which
no vertices are removed from~, and the procedure looping indefinitely. 

{
\begin{algorithm}\begin{algorithmic}[1]
\small
\STATE 
\WHILE{}
		\STATE The mappers partition~, and uniquely map each set  to a reducer~.
		\STATE Reducer~ independently adds each point in~ to set~  with probability , and to set~  with probability .
		\STATE Let  and . The mappers
assign~ and~ to one machine, along with all edge distances between~ and~.
		\STATE The reducer sets .
		\STATE The mappers arbitrarily partition~, with~ denoting  these sets. Let~, , , and the distances between~ and~ be assigned to reducer~. 
		\STATE For , remove  from  if .\label{step:keepx}	 	
		\STATE Let .
\ENDWHILE
\STATE Output .
\end{algorithmic}
\caption{}
\label{alg:EIM-MRS}
\end{algorithm}
}



With relatively small graphs, there is
a non-trivial probability that the point~ will also be in~.
In such cases, the vertex~ will be at equal distance to~ as the
points prior to it in the ordering given in line~\ref{step:whileR}
of  (Algorithm~\ref{alg:select}).
This would mean that even points added to the sample might not be removed from~.  
This increases the relative size of , also increasing
the probability of no vertices being removed from~ in subsequent rounds,
as~ is sampled from~.
If all points in~ are eventually added to~ then the algorithm cannot
terminate.
Therefore we assume that sampled points should \emph{always} be removed
from~, and as such have adapted the algorithm to reflect this.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\small
\STATE For each point , find 
\STATE \label{step:whileR} Order the points in~ according to their distance to~ from farthest to smallest.
\STATE Let~ be the point in position   in the ordering.
\RETURN 
\end{algorithmic}
\caption{, with our parameter~.}
\label{alg:select}
\end{algorithm}


\subsection{Trade-off}
Ene et al.~\cite{ene2011fast} prove that with high probability their MapReduce
procedure runs in  rounds.  
To decrease the number of rounds, we introduce parameter~ to
, which
trades off approximation for running time.
The original algorithm effectively fixed~ to be~.




In the original \ene scheme,
the expected number of points in~ that are farther from~ than~ is
.
By choosing a lower threshold for point~, we decrease the number of points that remain in~.
Since the sampling algorithm terminates when~ falls below a the threshold defined by~,
potentially this decreases the number of iterations.
We introduce a variable~, and choose~ such that it is
the  farthest point in~ from~. 



To obtain a feasible -center solution from the sample given by 
\texttt{EIM-MapReduce-Sample()},
a sequential -center procedure is run on the resulting sample
in an additional MapReduce round. 
Note that in line~3,~ is partitioned into  sets of size
at most , and in line~7 the mappers partition   into  sets of size at most  .
In Section~\ref{sec:sampling}, we prove that -- with weaker bounds, and with
appropriate values of~ -- the probabilistic
-approximation still holds.


\section{Runtime analysis}
\label{sec:runtime}


We now analyze in detail these parallel algorithms for -center.
Ene et al.~\cite{ene2011fast} proved that their sampling procedure required  rounds with high probability, while \ours can run in two rounds given sufficient resources.
We consider also the computations required in each of the rounds to determine the expected overall runtime.


\subsection{\ours}
Assuming that  and , \ours will run in two consecutive MapReduce iterations.
The first iteration involves running~ concurrent -center algorithms,
each on  vertices. 

The runtime of \gon on~ points is : each time a new center is selected, we need to find the distance of that center to all of the other vertices.
So the runtime for the first round of \ours is , with a low
constant in the~ expression.
In its second round, \ours runs \gon on the 
centers obtained from the first round; this gives a runtime of . 
Therefore the total runtime of \ours is , and 
for larger data sets, we would expect the dominant term to be . 


\subsection{\ene}
The sampling algorithm, \ene, has, with high probability,~
iterations -- each comprising
three MapReduce rounds --
followed by a final clean-up round at the end that solves a single -center
instance. 
Let~  and~ denote the state of sets~ and~,
respectively, in iteration~ of the main loop of the algorithm.
Counting from the first iteration,  and, with high probability, .
In each iteration, points in~ are added to~ with probability
, so  is expected to be~.
And in line~5,  becomes , so that,
starting with , we expect 
.
We now analyze each MapReduce round.

\vspace{2mm}
\paragraph*{Round 1}
(Lines  \& ). 
This round involves  operations during iteration~,
so the total number of operations is
\vspace{-2mm}

\vspace{-6mm}

\paragraph*{Round 2}
(Lines  \& ). 
This uses  distance calculations per iteration,
which is 
for each of
the~ (w.h.p.) iterations.
The total runtime is , which is in

\vspace{-10mm}

\paragraph*{Round 3}
(Lines  \& ). 
The third round requires  distance calculations in each
iteration, so summing over all iterations this is
\vspace{-2mm}
\vspace{-6mm}


\paragraph*{Final round}
 This sends~ points to a single machine,
on which, say,  \gon is run.
With high probability,
this takes time 


In practice, we find the dominant procedure for \ene is Round~3, in which points are
removed from~.
This makes sense, as in most cases  is much larger than
; the converse inequality implies that .
Furthermore, \ours also has  complexity for cases where .


Experiments confirmed that
the dominant round for each algorithm was linear in~, rather
than quadratic.
Comparing the dominant round of \ene to \ours,
we expect  \ene to be slower by a factor of
. 





\section{Approximation ratio of \ene}
\label{sec:sampling}




In this section, we prove that the approximation bound for
\ene still holds under our changes to the sampling algorithm. 
This proof is based on the original analysis,
with the necessary details altered for correctness and relevance.
The main impact of the parameter~ is to vary the number of points we consider to be represented by the existing sample. 
To analyze this,
we first require a formal description of what it means for points to be well represented (or \emph{satisfied}) by a sample.


Let~ denote some subset of the vertex set~ (that we hope will
`represent'~).
Each vertex  is assigned to its closest point in~,
breaking ties arbitrarily but consistently.
For each , let  denote the point in~ to which~ is
assigned; if~ is in~ we assign~ to itself. 
For , let  denote the set of all points assigned to~
when~ is the `assignment subset'. 

For a sample~,
Ene et al. say that a point~ is \emph{satisfied} by~ with respect
to~ if 
In words, there is a point in the sample that is closer to its -assigned
point, than~ is to its -assigned point, . 



Let~ denote the set of points returned by . 
The set~ might not include every center in~, but a point~ can still be satisfied if 
by including a point in~ that is closer to~ than . 
If  returns a set 
that satisfies every point in~,
then the sample is very representative of the initial data set,
and the clustering algorithms based on it should perform well.
However, there is no guarantee that the sample satisfies all points;
instead we can only be guarantee that the number of unsatisfied points
is small, and their contribution to the performance of the clustering algorithms is negligible compared to that of the satisfied points.

The sets at the core of 
change with every iteration. 
Denote the state of  sets~,~ and~ at the beginning 
of iteration~ by~, ,
and~ respectively,
where~ and~.
The set of points that are removed from~ during iteration~ is
denoted by~, so . 
Let  denote the set of points in  that are not satisfied by  with respect to . 
Let  denote the set of all points that are not satisfied by  (the sample returned by the algorithm) with respect to . 
If a point  is satisfied by  with respect to , then it is also satisfied by  with respect to , and therefore .


From the analysis of Ene et al.~\cite{ene2011fast} we have the following lemma.
\begin{lemma}
\label{unsatisfied}
Let~ be an arbitrary set with no more than~ points. 
In iteration~ of \sloppy\texttt{EIM{-}MapReduce}\texttt{{-}Sample}, where ,

\end{lemma}


We now show that our adaptation of the sampling algorithm by Ene et al. retains the same probabilistic -approximation guarantee.


\begin{lemma}
\label{chernoff}
Let~ be a set of no more than~ points.
In iteration~ of the while loop in
\sloppy\texttt{EIM{-}MapReduce}\texttt{{-}Sample},
let~ denote the threshold in the current iteration:
the  point in~ that is the~ most distant
from~.
Then there exist values~ and~ such that, for some~,

\end{lemma}

\begin{proof}
\label{chernoff-proof}
Recall that we selected a pivot point~, and discarded the points that are well represented by the current sample, compared to~. 
Note that  is the set of points in  such that the distance to the sample  is greater than the distance between the pivot point and the sample.

Ene et al. introduce these handy definitions.
For a vertex~, we refer to the number of points in~ further
from~ than the point~ as the~
of~. 
For some value~, and a set ,
define 
as the number of points in the set~ that have rank smaller than~. 


\noindent
Let , and let .  
By design,

and 
If , then with high probability, the pivot
(chosen to be the   point in ) will be in the range .


\noindent
By the Chernoff inequality, 

\vspace{-2mm}
 
\noindent
Choosing~ so that

gives . 
Since the Chernoff bound requires that ,
we insist that .

The lemma statement requires , which we can achieve by finding values
of , , , and   that for some  satisfy

Letting , this is equivalent to , which has real roots at .
Similarly, 
2pt]
  &= \mathbf{P}[L(b\cdot r, H_\ell)\leq(1-\delta)E[L(b\cdot r, H_\ell)]] \2pt]
 & \leq \exp\left[\frac{-\delta^2\cdot bcd\log n }{2}\right] \
\vspace{-2mm}
  
  
Choosing~ so that  gives .
 Since the Chernoff bound requires that , this gives the
constraint .

For the last inequality to hold,
we need to find values of~,~,~, and~ such that  

This has real roots at .

This gives feasible solutions for  and .
For later results we require that  and . 
So for there to exist feasible values of~ and~, we have the following constraint,

where  and .
When this bound holds, we can find values of each of the parameters such that the probability of  being outside of the defined bounds is less than , and 
therefore 

which is .
With this probability,
the number of points in~ that are further from~ than~
(and hence the size of the set~)
is in the range .
\end{proof}





Ene et al.~\cite{ene2011fast} prove that with probability , it is possible to map each unsatisfied point to a satisfied point such that no two unsatisfied points are mapped to the same satisfied point. 
Such a mapping allows them to bound the cost of the unsatisfied points with regards to the cost of the optimal solution. 
Their proof relies on the choice of , and the bound from Lemma~\ref{chernoff} giving a probability greater than . 
However, we use , and only assure a probability of . 
Therefore, we prove that the required mapping exists with probability ; by setting  this gives a probability of  , which is sufficient for large values of . 
The choice of~ arises from the requirement that :
for  and , this holds for . 


In the original analysis, Ene et al. proved that their results hold \emph{with high probability}, which they define as having probability .
We instead bound our confidence in these results with probability  for a variable , which we will refer to as \emph{with sufficient probability}, or \emph{w.s.p.}. 


The following results follow from the above analysis and that given by Ene et al~\cite{ene2011fast}. 

\begin{lemma}
For the sample  returned by ,
\emph{w.s.p.} we have .
\end{lemma}



\begin{lemma}
The procedure resulting from running an -approximation algorithm on the sample returned by   achieves a -approximation for the -centre problem   \emph{w.s.p.}
\end{lemma}


When running a -approximation algorithm on the sample, this result gives a -approximation bound on the resulting procedure. 
To achieve a success probability higher than , we need : by
the bound in Inequality~\eqref{eqn:bound}, this implies that .



\section{Experiments}

In this section we compare three algorithm (families), both in terms of speed
and effectiveness, and contrast the theoretical properties of these methods
(as shown in Table~\ref{table_compare}
with their empirical performance.

\begin{table}[!t]
\renewcommand{\arraystretch}{1.4}
\caption{Theoretical comparison of algorithms: Approximation factor
represented by~, run times are asymptotic, .}
\label{table_compare}
\centering
\begin{tabular}{l|r|r|c}
\hline
Algorithm    & 

& Rounds & Runtime \\
\hline
GON~\cite{gonzalez1985clustering} 
	&   
		& n/a    
			&   \\
\ours 
	&     
 		& 2 
			&  \1mm]
\ene~\cite{ene2011fast}
	& 
		&  
			& \pbox{20cm}{\small } \\
\end{tabular}
\end{table}


\subsection{Setup}
We run experiments on three algorithm families, each of which we implement in the~C language.
First is the typically -round algorithm, \ours;
second is (our Section-\ref{sec:sampling} generalization of) the sampling algorithm
of Ene et al.~\cite{ene2011fast}, \ene;
third is the (standard) sequential algorithm, \gon.
The latter, with its factor- approximation guarantee serves as an
effectiveness baseline.

For the sake of consistency with previous literature,
our method of implementing these algorithms mimics that of
Ene et al.~\cite{ene2011fast} in several ways.
In particular, we adopt a MapReduce approach, but do not record the cost of moving data between machines.
(As \ours involves fewer rounds, the expected cost of moving data between
machines would be less than for \ene.)
We simulate the parallel machines sequentially on a single machine,
taking the longest processing time of the simulated machines
as the processing time for that MapReduce round. 
For all parallel implementations, \gon is the subprocedure for selecting the final centers. 

The experimental system is a `commodity' machine,
with 8GB of main memory and an Intel\textregistered \\
Core\texttrademark i7-2600 CPU @ 3.40GHz.




\subsection{Experimental design}
Ene et al.~\cite{ene2011fast} generated synthetic data,
designed to have a fixed number of similarly sized clusters.
Moreover, they  tested their algorithm for values of~ equal to the number of clusters.
We evaluate the algorithms over a range of values of~ and vary the numbers of inherent clusters.
In practice, the number of clusters may not be known in advance, and the number of clusters required can be independent of the structure of the data.
To better determine how well these algorithms are likely to perform in practice,
we extend these experiments to test on  graphs with different underlying structures.


In all of the experiments, the distance is Euclidean, computed as required
from the locations of the points.
The -center algorithm assumes a complete graph as input, and a matrix
representation of a graph, with all distances stored explicitly,
might result in a significant proportion of the data sent between machines being unnecessary.
The number of machines,~, is fixed to~, while~ and~ vary.
Our preliminary experimentation with the \ene algorithm, over a range of values of~,
confirms that Ene et al.'s choice of~ was good.



In Section~\ref{sec:sampling}, we introduced a parameter~ to the \ene sampling
approach.
In our experiments, we test the effect of lowering~ from its
``original'' value of~, both in terms of runtime and effectiveness
Corresponding with our theoretical results in Section~\ref{sec:sampling} we
choose ; and to determine the robustness of the algorithm, we test
with  and , which are below the bound of  that was given in Section~\ref{sec:sampling}.




\subsection{Data sets}

We test against a combination of real and synthetic data sets,
primarily in two and three dimensions,
but with several real data sets of larger dimension.
The data sets have a range of sizes, from  through to
 points, with varying degrees of inherent clustering.
Our synthetic  data sets have three different formats, viz.


\begin{description}
\setlength\itemsep{0.5em}
\item[\unif] The~ points are uniformly distributed in a two-dimensional square.
\item[\gauss] 
The~ cluster centers -- where~ might not equal~ -- are uniformly randomly generated in a unit cube.
The~ points are distributed into these clusters uniformly at random, resulting in clusters of roughly similar size.
This helps determine the accuracy with which the procedures can
identify different clusters.
Distance from points to the cluster center follows a Gaussian distribution with
.
These data sets mimic those used in the experiments of Ene et al~\cite{ene2011fast}.
\item[\unbalanced]
An unbalanced arrangement, similar to~\gauss.
The distribution of points to inherent clusters is biased
such that around half of the points are in a single
(inherent) cluster; the distribution between the remaining clusters remains uniform.
\end{description}


We generate three graphs of each size and type, and run the algorithms twice over each data set, taking the average.
This gives a total of six results for each type of data set, over three different graphs.

We take real data sets from the UCI Machine Learning Repository~\cite{Lichman:2013}, over a wide range of sizes, applications and dimensions. 
We run four tests over each of the real data sets, and take the average result.
We include results for the -point training set for the \poker data
set, and the~ sample from the -point \kdd 1999 data set.


\begin{figure}[!t]
\center
{\includegraphics[width=3.1in]{n_kdd_AVGsols.pdf}}
\caption{\small Solution values over~
on \kdd 1999.}\vspace{-3mm}
\label{fig_real}
\end{figure}

\vspace{-2mm}
\section{Results}
\vspace{-2mm}
Overall \ours is faster than the alternative procedures - often by orders of magnitude,
with \ene running slower than the sequential algorithm despite being parallelized, conforming with the analysis in Section~\ref{sec:runtime}. 
\vspace{-1mm}




\begin{figure*}[!t]
\vspace{-4mm}
\centerline 
\hfil
{\subfloat[\gauss(, ).]{\includegraphics[width=3.1in]{n_clust_1000000n25c_AVGtimes.pdf}
\label{fig_time_first}}}
\hfil
\subfloat[\unif().]{\includegraphics[width=3.1in]{n_random_100000_AVGtimes.pdf}
\label{fig_time_second}}
\caption{\small Runtimes in seconds over a range of values
of~.
Corresponding with our theoretical analysis, \ene runs slower than
both \ours and the sequential alternative, with \ours being the fastest of the algorithms considered.}
\label{fig_time}
\vspace{-4mm}
\end{figure*}


\begin{table}[!t]
\renewcommand{\arraystretch}{1.2}
\caption{\small Solution value over~ for \gauss(, ).}
\label{fig_value_first}
\centering
\small{
\begin{tabular}{r|S|S|S}
&\ours\ \ &\ene\ \ &\gon \\ \hline
2  &96.04  &93.11  &95.86  \\
5  &61.90  &61.58  &63.31  \\
10 &41.31  &39.43  &39.72  \\
25  &0.961  &0.854  &0.961 \\
50  &0.762   &0.683  &0.719 \\
100  &0.607   &0.556  &0.573 \\
\end{tabular}
}
\renewcommand{\arraystretch}{1.2}
\caption{\small Solution value over~ for \unif().}
\label{fig_value_second}
\centering
\small{
\begin{tabular}{r|S|S|S}&\ours&\ene&\gon\\ \hline
2  &91.33  &95.80 &91.18  \\
5  &50.68  &50.65  &53.14  \\
10  &33.35  &31.12  &32.35  \\
25 &18.49  &18.01  &18.27  \\
50 &13.14 &12.39  &12.36  \\
100  &9.144  &8.764  &8.727 \\
\end{tabular}
}
\end{table}
\normalsize



\begin{figure*}[!t]
\centerline 
\hfil
{\subfloat[\gauss(, ).]{\includegraphics[width=3.1in]{n_clust_1000000n50c_AVGtimes.pdf}
\label{fig_size_first}}}
\hfil
\subfloat[\gauss(, ).]{\includegraphics[width=3.1in]{n_clust_50000n50c_AVGtimes.pdf}
\label{fig_size_second}}
\caption{\small Runtimes in seconds for \gauss graphs over a range values of~.
When~ becomes too large, relative to~, \ene no longer performs sampling and defaults to the sequential algorithm.
}
\label{fig_size}
\end{figure*}




\begin{table}
\renewcommand{\arraystretch}{1.2}
\vspace{-4mm}
\caption{\small Solution value over~ for \unbalanced(,
).
When~,
\ene is notably better.}
\label{compare_clust}
\centering
\small{
\begin{tabular}{r|S|S|S} 
&\ours&\ene&\gon\\ \hline
2  &97.96  &93.69 &93.37  \\
5 &64.61  &64.28  &61.72 \\
10 &40.17 &40.05 &40.39  \\
25  &0.932  &0.828  &0.939 \\
50 &0.668 &0.643  &0.655 \\
100  &0.515  &0.530  &0.500 \\
\end{tabular}
}
\end{table}
\normalsize


\begin{table}[!t]
\renewcommand{\arraystretch}{1.2}
\vspace{-3mm}
\caption{\small Solution value over~ for the \poker data set.}
\label{poker}
\centering
\small{
\begin{tabular}{r|S|S|S} 
&\ours&\ene&\gon\\ \hline
2 &19.41  &18.60  &18.17 \\
5  &18.06   &17.07   &17.25   \\
10  &15.12  &14.20   &15.03   \\
25 &12.13   &11.98   &11.84   \\
50  &10.07  &9.418 &9.617 \\
100  &8.774 &9.241 &8.396 \\
\end{tabular}
}
\end{table}
\normalsize




\vspace{-2mm}
\subsection{Summary}
\vspace{-2mm}
In most cases, despite having worse approximation guarantees, the
solutions for the parallelized algorithms are comparable to
those of the baseline, \gon, with \ene performing slightly better for synthetic data sets.
Ene et al~\cite{ene2011fast} suggested that their sampling-based
algorithm did not perform particularly well, likely
due to the -center procedure being sensitive to outliers. 
Our experimental results show otherwise: sampling fewer points can
occasionally provide \emph{better} results due to the tendency to
avoid sampling points that are well represented,
but toward the edge of the cluster. 
The tendency for \gon to favor outliers is often
 mitigated, rather than amplified, by sampling.
As shown in Table~\ref{compare_clust},
this effect is particularly evident for \gauss graphs where~.




As illustrated in Tables~\ref{fig_value_first} and~\ref{compare_clust},
for the synthetic data sets, the parallel algorithms
are about as effective as Gonzalez's algorithm.
In general, \ene is slightly more effective than \ours.
With the exception of the \ene results on the \kdd 1999~ sample, for which it performs poorly,
the same occurs on the real data sets, as seen in Figure~\ref{fig_real} and Table~\ref{poker}.




\subsection{Running time}
For the majority of the experiments, \ene ran using two iterations of the main loop, for a total of seven MapReduce rounds.
On certain data sets,
\ene sometimes executes one iteration, sometimes two --
that is, four or seven
MapReduce rounds
 -- as the number of points removed per round is probabilistic.






From Figures~\ref{fig_time_second},~\ref{fig_size_second}
and~\ref{fig_second_case}, we can see that as the ratio of~ to~
drops, at some point, \ene merely sends the entire data set to a single
machine, rather than employing the sampling procedure.
We can also note that in Figure~\ref{fig_second_case}, \ours displays a different trend from Figure~\ref{fig_first_case}.
In Section~\ref{sec:runtime}, we showed that the runtime is . 
For larger values of~ and small values of~, the  term
dominates;
as~ grows, the  term dominates,
so the trend becomes similar to that in Figure~\ref{fig_first_case}. 
From our analysis in Section~\ref{sec:runtime}, both \ours and \ene have a
round with a  term in the running time.
When~ is large relative to~,
this can potentially dominate.




 


\subsection{Runtime/Approximation Trade-off }

We examine the sensitivity of the \ene algorithm to the~ parameter.
As expected, the variability of effectiveness increases
as the~ parameter decreases,
while the runtimes significantly decrease. 
Tables~\ref{table_emi_sol} and~\ref{table_emi_run} compare
the average solution value and runtimes for the different parameters. 
The algorithm speeds up significantly 
for values of~ below the threshold of~ (above which there is a
guaranteed low probability of poor solutions, see Section~\ref{sec:sampling}).
Yet, in practice, it still returns acceptable solutions:
in some cases solutions are even better with smaller values of~.

\begin{table}[!t]
\renewcommand{\arraystretch}{1.2}
\caption{Average solution value over~, in \ene,
for \gauss  (, ). For each~, the lowest value is in \emph{italics}.
}
\label{table_emi_sol}
\centering
{
\small
\begin{tabular}{r|S|S|S|S} & \multicolumn{3}{c}{} \\
\emph{\textbf{}}&\emph{\textbf{ }}  &\emph{\textbf{ }}  &\emph{\textbf{ }}  &\emph{\textbf{}}  \\ \hline
2 & 88.4  & \hspace{1.5mm}  &85.5  &86.5  \\
5 & 59.9  &60.9  & \  &61.9  \\
10 & 36.2  &35.5 & \  &35.3  \\
25 & 0.796   &\hspace{2.5mm}   & 0.826 &0.840 \\
50 & 0.630   &0.617   &\hspace{2.5mm}   &0.666 \\
100 &\hspace{2.4mm}   &0.492   &0.505  &0.535\\
\end{tabular}
}
\vspace{2mm}
\renewcommand{\arraystretch}{1.2}
\caption{Average runtime over~, in \ene,
for \gauss (, ).
The lowest runtime in each row is in \emph{italics}.
}
\label{table_emi_run}
\centering
{
\small
\begin{tabular}{r|S|S|S|S} & \multicolumn{3}{c}{} \\
\emph{\textbf{}}&\emph{\textbf{}}  &\emph{\textbf{}} 
&\emph{\textbf{}} &\emph{\textbf{}}  \\ \hline
2&  &0.059 &0.165 &0.135 \\
5&  &0.130 &0.368 &0.314 \\
10&  &0.480 &0.549 &0.552 \\
25& \hspace{-.4mm}0.588 &\hspace{3.4mm} &1.47   &1.42   \\
50&  &0.816 &2.84  &2.24   \\
100& &0.757 &3.78   &3.59    \\
\end{tabular}
}
\end{table}








 
This seemingly counterintuitive behavior can be explained by the choice
of \gon as the sub-procedure for the sample. 
As noted above,
selecting the farthest points as new centers makes it more likely that points
at the perimeter of a cluster are chosen; although each cluster is well
represented by some vertex, the selected center is at the perimeter of the cluster. 
By sampling \emph{fewer} points, it is less likely that points that are
extremal to the cluster are present in the subgraph on which
\gon is run.
Therefore in decreasing the runtime of the algorithm,
for appropriate values of~,
we can potentially improve the average value of the solutions obtained.
However this behavior is likely to be more volatile:
the guaranteed bound on the performance has lower probability,
giving a higher chance that a very poor solution is returned.






\section{Conclusion}
In this paper, we describe a multi-round parallel procedure for the~-center
problem.
When it runs in only~ MapReduce rounds, it is  a -approximation. 
We show experimentally that it returns solutions that compare well
to those of a sequential -approximation algorithm, while running extremely
fast. 

We compare this approach to the existing -approximation
sampling-based MapReduce procedure~\cite{ene2011fast}.
It is often slightly more effective, but can be very slow.
To support our experimental results, we give the first detailed runtime analysis for the sampling approach, the proof of which correspond with our empirical results.
We also parameterized the
sampling procedure to improve runtimes, sometimes even bringing better
solutions despite the lack of a provable effectiveness bound.



\begin{figure*}[!t]
\vspace{-7mm}
\centerline 
\hfil
{\subfloat[]{\includegraphics[width=3.1in]{k_clust_alln25c_10_AVGtimes.pdf}
\label{fig_first_case}}}
\hfil
\subfloat[]{\includegraphics[width=3.1in]{k_clust_alln25c_100_AVGtimes.pdf}
\label{fig_second_case}}
\caption{\small Runtimes in seconds for fixed~ over values of~ ranging
from  to .
For sufficiently small values of~ relative to~, \ene behaves identically to \gon.
The is caused by the condition on the while loop: if~ is large enough, the condition is never met and no sampling occurs,
so \gon is run on the entire data set.}
\label{fig_sim}
\end{figure*}

\subsection*{Future work}
The approximation factor of four for \ours is tight.
There are graphs on which,
with adversarial  assignment of points to machines and choice of seedings
for \gon,
 \ours gives a -approximation.
How likely such cases are in practice?
We seek bounds on the probability that this algorithm gives a poor approximation.
And what is the effectiveness when \ours needs more than two rounds?

Recently, Im and Moseley~\cite{im2015} described a
-round -approximation MapReduce procedure for the -center problem
under the assumption that  is known, and announced a -round procedure that does not require prior knowledge of the optimal solution -- 
these details have yet to appear.
More recently Malkomes et al.~\cite{malkomes2015fast} presented a parallel adaptation of the -center algorithm comparable to a special case of our approach.
Currently all such approaches rely on the sequential algorithm of Gonzalez~\cite{gonzalez1985clustering}. 
It would be interesting to compare with similar adaptations of alternative sequential algorithms, such as that of Hochbaum \& Shmoys~\cite{hochbaum1985best}.


\vspace{3mm}
\paragraph*{Acknowledgment}
Many thanks to Kewen Liao for valued feedback and proofreading.

\newpage


\bibliographystyle{siam}
\bibliography{references}


\end{document}
