\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{ICE 2014} 


\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{times}
\usepackage{txfonts}
\usepackage{stmaryrd}
\usepackage{url}
\usepackage{amsfonts}
\usepackage{code}
\setlength\hfuzz{3pt}
\usepackage{mathrsfs}
\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}
\let\mathpzc\mathscr
\let\mathpzc\mathcal
\def\BNF{\ \  | \ \  }
\def\bondi{{\bf bondi}}
\def\ltrans{[\![}
\def\rtrans{]\!]}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\newenvironment{proof}[1][Proof]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{definition}[1][Definition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{example}[1][Example]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{remark}[1][Remark]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}


\usepackage{prooftree}
\usepackage{macros}


\pagestyle{plain} 

\sloppy



\title{An Intensional Concurrent Faithful Encoding of Turing Machines}

\author{Thomas Given-Wilson
\institute{INRIA, Paris, France
\footnote{This work has been supported by the project ANR-12-IS02-001 PACE.}
}
\email{thomas.given-wilson@inria.fr}
}

\def\titlerunning{An Intensional Concurrent Faithful Encoding of Turing Machines}
\def\authorrunning{T. Given-Wilson}




\renewcommand{\beq}{\simeq}
\renewcommand{\rew}{\redar}

\newcommand{\withproof}[1]{#1}

\makeatletter
\def \rightarrowfill{\m@th\mathord{\smash-}\mkern-6mu\cleaders\hbox{}\hfill
  \mkern-6mu\mathord\to}
\makeatother
\makeatletter
\def \Rightarrowfill{\m@th\mathord{\smash=}\mkern-6mu\cleaders\hbox{}\hfill
  \mkern-6mu\mathord\Rightarrow}
\makeatother
\def \overstackrel#1#2{\mathrel{\mathop{#1}\limits^{#2}}}

\renewcommand{\iap}[1]{#1\to}
\renewcommand{\oap}[1]{\overline{#1}\to}
\newcommand{\oan}[1]{\overline{#1}}
\newcommand{\tmach}[1]{\tuple{\tuple{#1}}}
\newcommand{\tape}[1]{[#1]}

\begin{document}
\makeatactive

\maketitle  

\begin{abstract}
The benchmark for computation is typically given as Turing computability;
the ability for a computation to be performed by a Turing Machine.
Many languages exploit (indirect) encodings of Turing Machines to demonstrate
their ability to support arbitrary computation.
However, these encodings are usually by simulating the entire Turing Machine
within the language, or by encoding a language that does an encoding or
simulation itself.
This second category is typical for process calculi that show an encoding of
-calculus (often with restrictions) that in turn simulates a Turing Machine.
Such approaches lead to indirect encodings of Turing Machines that are complex,
unclear, and only weakly equivalent after computation.
This paper presents an approach to encoding Turing Machines into intensional
process calculi that is faithful, reduction preserving, and structurally
equivalent.
The encoding is demonstrated in a simple asymmetric concurrent pattern calculus
before generalised to simplify infinite terms, and to show encodings into
Concurrent Pattern Calculus and Psi Calculi.
\end{abstract}

\section{Introduction}
\label{sec:intro}

The benchmark for computation is typically given as Turing computability
\cite{zbMATH02522537,Kleene52,McCarthy:1960:RFS:367177.367199,boolos2007computability};
the ability for a computation to be performed by a Turing Machine
\cite{turing36}.
This choice of benchmark is also widely supported by various appeals to
calculation of a ``computable function'' or ``decidable predicate'' or
``recursive function'' by a Turing Machine
\cite{zbMATH02522537,Kleene52,Curry58combinatorylogic,Curry72combinatorylogic,jay2011}.
Indeed, since Turing \cite{zbMATH02522537}, Kleene \cite{Kleene52}, Curry
\cite{Curry58combinatorylogic,Curry72combinatorylogic}
and others showed that Turing Machines can encode -calculus, general recursive functions, 
and combinatory logic \cite{685558}, respectively,
any language that can encode any of these can be considered to be able to
do computation.
However, these rely upon their encoding of Turing Machines which typically
involve the simulation of a Turing Machine within the other language.

The typical simulation of a Turing Machine, say in -calculus, is to
represent the tape as a list, and the symbols by natural numbers using G\"odelisation.
The operations of the Turing Machine are then handled by a function that
can operate over the list (encoded tape) and compare the numbers using their
Church encodings \cite{Barendregt85}.
While such encodings preserve computation they have some weaknesses.
The encoded computation takes many more reductions to produce the same operations;
recognising a symbol requires a predecessor function, testing for zero, and then
switching on numbers to determine the next symbol to write, all before
reconstructing the list (encoded tape).
Such encodings are not very clear; the representation of a symbol  may be
mapped to some number  that is then represented as a function that is the
th iterator.
These kinds of encodings are also metamathematical \cite{Tarski56logic} in nature and
so are always at least one level of mathematics away from the computation itself,
which can lead to misunderstandings about the true expressiveness of a
language \cite{jay2011}.

Process calculi are often considered to generalise the sequential (non-concurrent)
computation of -calculus by some form of encoding
\cite{90426,Berry:1989:CAM:96709.96717,Milner:1992:CMP:162037.162038,Milner:1992:CMP:162037.162039,DBLP:conf/fossacs/CardelliG98,DBLP:books/daglib/0098267,
705654}.
These encodings again have weaknesses such as adding reductions steps,
lacking clarity, or even limiting reductions strategies (such as in
Milner's encoding of -calculus into -calculus \cite{90426}, which is
then built upon by those who use encoding -calculus to capture
computation).
Further, these encodings are often up to some weak behavioural equivalence and
can create many dead processes as a side effect.
Thus a Turing Machine can be encoded into -calculus and then encoded into
-calculus and then encoded into another process calculus so that the 
original computation is now buried three levels of meta-operations deep,
with almost no obvious connection to the original Turing Machine,
and only weakly behaviourally equivalent to an encoding of the Turing Machine
after the computation.

This paper attempts to avoid the worst of these various encoding issues by
presenting a straightforward approach to encoding a Turing Machine into any process
calculus that supports {\em intensional} communication
\cite{GivenWilsonPhD,GivenWilsonGorla13}.
Intensionality is the capability for functions or communication primitives
to operate based upon the internal structure of terms that are arguments
or being communicated, respectively \cite{jay2011,GivenWilsonPhD}.
Some recent process calculi support intensionality, in particular
Concurrent Pattern Calculus \cite{GivenWilsonGorlaJay10,givenwilson:hal-00987578} and
Psi Calculi \cite{BJPV11}.
The presentation here will use a simplified {\em asymmetric concurrent
pattern calculus} (ACPC) to detail the translation as clearly as possible.

The intensionality of ACPC is an advanced form of pattern-matching
that allows {\em compound} structures of the form  to be bound to a single
name, or to have their structure and components be matched in communication.
For example, consider the following processes:

where  is an output of the compound .
The inputs of  and  have binding names of the form  in their
patterns  and , respectively.
The input of  tests the names  and  for equality and performs no binding.
These process can be combined to form three possible reductions:

The first matches the structure of the output of  with the input of  and binds
 and  to  and , respectively, in .
The second binds the entire output of  to the single name  in .
The third matches the structure and names of the output of  with the structure
and names of the input of , as they match they interact although no binding
or substitution occurs.

The encoding presented here exploits the ability to represent symbols and structures
into the output of a process, and to test for structure, equality, and to bind in
an input to clearly represent a Turing Machine.
Indeed, the encoding is {\em faithful} in that each operation that is performed
by a Turing Machine yields exactly one reduction in the encoding to the (structurally)
equivalent encoded Turing Machine after the operation.
The key to the elegance of the encoding is to represent the current state  and
tape  of the Turing Machine by an output of the form

where  converts the tape to a convenient format.
The transitions functions of the Turing Machine are then each encoded into
a process of the form

where  and  match the current state, current symbol, and the structure of the
tape, and the output exhibits the new state  and modified representation of the tape .
These transition functions can then be combined via parallel composition and replication
in a manner that allows for a faithful encoding of a Turing Machine.


The elegance of this encoding can be built upon by considering some variations.
It is straightforward to modify the encoding so that a tape with infinite blank symbols
at the edges can be represented by a finite term in the output.
Both of these encodings can then be easily captured by both Concurrent Pattern Calculus
and Psi Calculi with only minor changes to the encoding and proofs.

There are two limitations for non-intensional process calculi.
First is the inability to match multiple names in a single reduction.
This can be worked around by encodings or match-rules that rely upon structural equivalence,
however at some cost to the elegance of the encoding.
Second proves impossible to fix; the inability for non-intensional calculi to bind
an arbitrarily complex structure to a single name and still access the components.
Thus alternative approaches must be used to encode Turing Machines into, say,
synchronous polyadic -calculus, at the cost of faithfulness and easy equivalence
of encodings.


\medskip

The structure of the paper is as follows.
Section~\ref{sec:tm} recalls Turing Machines.
Section~\ref{sec:int} presents intensionality via asymmetric concurrent pattern calculus.
Section~\ref{sec:enc} defines the encoding of Turing Machines in asymmetric concurrent pattern calculus.
Section~\ref{sec:var} considers variations on the encoding, including into published calculi.
Section~\ref{sec:fail} discusses non-faithful encodings into, and limitations of other calculi.
Section~\ref{sec:conc} draws conclusions.

\section{Turing Machines}
\label{sec:tm}


Each Turing Machine is defined by an alphabet, a set of states, a transition function,
and a tape. In addition during operation the current head position and current state
must also be accounted for.
The alphabet  is the set of symbols  recognised by the Turing Machine and includes
a special {\em blank} symbol .
The set of states  is a collection of states  that the Turing Machine can transition
to and from, and includes a {\em start state} .
The transition function  is represented by tuples of the form
 that instructs the machine when the current state is  and the
current head position symbol is  to write (to the current head position)  and
then move the current head position direction  (either  for left or  for right),
and change the current state to .
The {\em tape}  is an infinite sequence of cells each of which contains a symbol,
this is denoted by  that indicates an infinite sequence
of blanks, the symbols  then  then  and then an infinite sequence of blanks.
The current head position can be represented by marking the pointed to symbol in bold,
e.g.~the tape  indicates that the current head position is
the leftmost instance of .
Thus the definition of a Turing Machine can be given by
 where
 is the current state.

For a Turing Machine 
a state  is a {\em terminating} state if there are no transitions of the
form .
A Turing Machine is well formed if for every  then either  is terminating, or
for every symbol  then there exists a transition of the
form  for some  and  and .
The rest of this paper shall only consider well formed Turing Machines
although no results rely upon this.


\subsection*{A Simple Example}

Consider the following simple example of a Turing Machine that accepts numbers
represented in unary and terminates with the current head on  if the number is
even and  if the number is odd.

The alphabet is given by  and the states by
.
The transition function  is defined as follows:

Observe that  is a terminating state and so has not transitions that
begin in that state.

Now consider the Turing Machine given by
, that is
the Turing Machine defined above with the current head position on the first  of the
number three represented in unary.
The computations progress as follows:

Since  is a terminating state the Turing Machine halts and has the current head position on a
blank as required.
A similar Turing Machine with a tape that represents two would have the following reductions

Since two is even this time the Turing Machine halts with the current head position on a  symbol
as required.



\section{Intensional Process Calculi}
\label{sec:int}

Intensionality in process calculi is the ability for the structure of a term to be
determined, here during interaction.
This has appeared in communication primitives in some more recent process calculi such
as Concurrent Pattern Calculus and Psi Calculi.
Spi calculus supports intentional reductions, but not in a communication reduction
\cite{Abadi:1997:CCP:266420.266432}.
This section defines an {\em asymmetric concurrent pattern calculus} (ACPC) that
is a simple variation of Concurrent Pattern Calculus as described before \cite{GivenWilsonPhD}.
ACPC is trivial to represent in either Concurrent Pattern Calculus or Psi Calculi,
and so has been used here for clarity of the encoding, and to transfer the results
(details in Section~\ref{sec:var}).

Assume a countable collection of names denoted .
The {\em terms} of ACPC are given by

the {\em names} , and {\em compounds}  that combine the two terms  and 
into a single term.

The {\em patterns} of ACPC are defined by

The {\em binding names}  play the r\^ole of inputs in the pattern.
The {\em name-match}  is used to test for equality during interaction
\footnote{This corresponds to the protected names  of CPC in the
r\^ole they play. However, the syntax is chosen to mirror the variable names
 of CPC since they more closely align with -calculus and Psi Calculi syntax, and
later results for CPC can use either protected or variable names.}.
The {\em compound patterns}  combine the two patterns  and  into a single pattern.
Note that a well-formed pattern is one where each binding name appears only once, the
rest of this paper will only consider well formed patterns.

Substitutions, denoted , are finite mappings from names to terms.
Their domain and range are expected, with their names being the union of domain and range.

\renewcommand{\match}[2]{\{#1/\!\!/#2\}}

The key to interaction for ACPC is the matching  of the term  against the pattern 
to generate a substitution 
is defined as follows.

Any term  can be matched with a binding name  to generate a substitution from the
binding name to the term .
A single name  can be matched with a name-match for that name  to yield the
empty substitution.
A compound term  can be matched by a compound pattern  when
the components match to yield substitutions  and ,
the resulting substitution is the unification of  and .
Observe that since patterns are well formed, the substitutions of components will always have
disjoint domain.
Otherwise the match is undefined.

The processes of ACPC are given by

The null process, parallel composition, replication, and restriction are standard
from CPC (and many other process calculi).
The {\em input}  has a pattern  and body , the binding names of the pattern
bind their instances in the body.
The {\em output}  has a term  and body , like in -calculus and Psi
Calculi there are no binding names or scope effects for outputs.
Note that an input  may be denoted by  and an output 
by  when no ambiguity may occur.

-conversion  is defined upon inputs and restrictions in the usual manner for 
Concurrent Pattern Calculus \cite{GivenWilsonGorlaJay10}.
The structural equivalence relation  is given by:


The application of a substitution  to a process  denoted  is
as usual with scope capture avoided by -conversion where required.

ACPC has a single interaction axiom given by:

It states that when the term of an output can be matched with the pattern of an input to
yield the substitution  then reduce to the body of the output in parallel with
 applied to the body of the input.



\section{Encoding}
\label{sec:enc}

\newcommand{\enclist}[2]{#2} 
This section presents a faithful encoding of Turing Machines into ACPC.
The key to the encoding is to capture the current state and tape as the term of
an output, and to encode the transition function as a process that will operate
upon the encoded tape.
The spirit to this kind of encoding has been captured before when encoding
combinatory logics into CPC \cite{GivenWilsonPhD}.

Consider the simple encodings  and  that take a sequence of symbols
and encodes them into a term as follows:
\enclist{

That is,  encodes a sequence of symbols (to be from the left hand side of
the current head position) into a list starting with the symbol on the right (closest to the current
head position) at the head of the list.
Similarly,  encodes a sequence of symbols (from the right hand side of
the current head position) into a list starting from the symbol on the left (again, closest to the current
head position).
}
{

That is,  encodes a sequence of symbols from right to left, compounding
on the left hand side.
Similarly,  encodes a sequence of symbols from left to right,
compounding on the right hand side.
}

Now consider a tape that must be of the form
.
That is, an infinite sequence of blanks, some sequence of symbols including the current
head position, and then another infinite sequence of blanks.
This can be encoded  into a term by:

\enclist{
Observe that the result is a term of the form 
where  is the encoding of the tape left of the current head position
(reversed so as to be ordered from right to left),
 is the current head position, and  is the encoding of the tape right of
the current head position.
In particular note that both  and  are of the form  where
 is the symbol next to the current head position and  is the rest of
the sequence in that direction.
}
{
Observe that the result is a term of the form 
where  is the encoding of the tape left of the current head position,
 is the current head position symbol,
and  is the encoding of the tape right of the current head position.
In particular note that  and  are both compounds of their symbol closest
to the current head position and the rest of the sequence in their direction.
}
For now the encoding handles an infinite tape and produces an infinite term,
although this can be removed later without effect on the results (details in Section~\ref{sec:var}).


Now the current state  and a tape  can be represented as an output by


\begin{lemma}
\label{lem:tape-no-red}
The representation  of the state 
and tape  does not reduce.
\end{lemma}

With the current state and tape encoded into a term it remains to encode the
transition function in a manner that allows faithfulness.
Consider that each tuple of the transition function is of the form
 for states  and , and symbols  and , and
for  either  or . Thus we can encode  such a tuple as a single process
as follows:
\enclist{

}
{

}
Note that in both cases the pattern matches on the state  and the symbol .
When the tape is going to move left then the first symbol to the left is bound to 
and the rest to , and  and  when respectively moving right.
The output in each case is the new state  and the tape with the written symbol
 added to the right side of the head position when moving left, or the left side
when moving right.
Thus, the new output represents the updated state and tape after the transition
 has been applied once.
Note that the encoding here assumes the four names  and  and  and  do
not appear in the symbols  of the encoded Turing Machine.
Since the collection of symbols  is finite it is always possible to
choose four such names.

Building upon this, the encoding of the transition function  can be
done.
Define  to be the parallel composition of processes  in
the usual manner.
Now the encoding of the transition function  can be captured as follows:

where  is each tuple of the form .
Observe that this creates a process of the form  where each
 performs a single transition.

\begin{lemma}
\label{lem:trans-no-red}
The encoding  of the transition function 
does not reduce.
\end{lemma}
\begin{proof}
For every tuple  in  the encoding  is an input.
It is then straightforward to consider all the structural congruence rules
and show that there are no outputs and thus the reduction axiom cannot be satisfied.
\end{proof}

Finally, the encoding  of a Turing Machine into ACPC is given by:


\begin{lemma}
\label{lem:faithful}
Given a Turing Machine 
then
\begin{enumerate}
\item If there is a transition

then there is a reduction

where , and
\item if there is a reduction

then  and
there is a transition
.
\end{enumerate}
\end{lemma}
\begin{proof}
The first part is proven by examining the tuple  that corresponds to the transition 

by the Turing Machine. This tuple must be of the form
 and it must also be that  is of the form
.
Further, it must be that  is either:
 when  is , or
 when  is .
Now 
is of the form
 and
by Lemmas~\ref{lem:tape-no-red} and \ref{lem:trans-no-red} neither 
nor  can reduce, respectively.
Now by exploiting structural congruence gain that
.
Then by the definition of matching and the reduction axiom is straightforward to show that
 and thus conclude.

The reverse direction is proved similarly by observing that the only possible reduction

must be due to a tuple  that is in the transition function 
and the result follows.
\end{proof}

\begin{theorem}
\label{thm:done}
The encoding  of a Turing Machine into ACPC; faithfully preserves reduction, and
divergence.
That is, given a Turing Machine 
then it holds that:
\begin{enumerate}
\item there is a transition

if and only if there is exactly one reduction

where , and
\item there is an infinite sequence of transitions

if and only if there is an infinite sequence of reductions
.
\end{enumerate}
\end{theorem}
\begin{proof}
Both parts can be proved by exploiting Lemma~\ref{lem:faithful}.
\end{proof}

Observe that this encoding of a Turing Machine into ACPC is not only faithful
and straightforward, but also up to structural congruence.
This is in contrast with the popular style of encoding -calculi into process
calculi that requires many reductions to simulate one -reduction, and the
equivalence of encoded terms/machines is only up to weak behavioural equivalence.
The simplicity and faithfulness here is gained by being able to directly render
the current state and tape as a single term, and the transition function as a
process that modifies the current state and tape in the same manner as the original
Turing Machine.

\section{Variations}
\label{sec:var}

This section considers variations to the encoding including:
representing the tape as a finite term,
encoding into Concurrent Pattern Calculus,
and encoding into Psi Calculi.

\subsection*{Finite Terms}

One potential concern is the infinite tape being represented as an infinite term
in ACPC. However, this can be done away with by adding an additional reserved name 
during the translation that does not appear in the symbols of the Turing Machine 
and represents the edge of the tape.


Now  and  are modified to account for the
endless sequence of blank symbols  as follows:
\enclist{
}{
}
Here the endless blanks at the edge of the tape are simply replaced by .
Otherwise the encoding of the state  and tape  is the same.

\begin{lemma}
\label{lem:fin:tape-no-red}
The representation  of the state 
and tape  does not reduce.
\end{lemma}



The encoding of tuples  is now modified to account for  given by:

The encoding of a tuple now has two input processes in parallel and each under
a replication;
the first matching the original encoding, and the second detecting when the
transition would move the current head position to the edge of the tape.
The new one inserts a new blank  in the output and shifts the edge  along
one cell.
Observe that due to definition of the matching rule no output can interact
with both of these inputs (as no term can be matched with both patterns of the
form  and ).
The replications have been added so that structural congruence can be achieved in
the final results. This requires a change to the encoding of the transitions
function as follows:

where the replications are now left to the encoding of each tuple .

The rest of the results follow with minor alterations.

\begin{lemma}
\label{lem:fin:trans-no-red}
The encoding  of the transition function 
does not reduce.
\end{lemma}

\begin{lemma}
\label{lem:fin:faithful}
Given a Turing Machine 
then
\begin{enumerate}
\item If there is a transition

then there is a reduction

where , and
\item if there is a reduction

then  and
there is a transition
.
\end{enumerate}
\end{lemma}
\begin{proof}
The first part is proven by examining the tuple  that corresponds to the transition 

by the Turing Machine. This tuple must be of the form
 and it must also be that  is of the form
.
Further, it must be that  is either:
 when  is , or
 when  is .
Now 
is of the form
 and
by Lemmas~\ref{lem:fin:tape-no-red} and \ref{lem:fin:trans-no-red} neither 
nor  can reduce, respectively.

By definition  is of the form

for some process . 
Now consider .
\begin{itemize}
\item If  is  then consider the encoded tape .
  \begin{itemize}
  \item If  is of the form 
        then by definition of  and structural congruence  and thus there is a reduction
        .
        It is straightforward to show that 
        and thus by structural congruence that
         and thus conclude.
  \item If  is of the form
        
        then take  and the rest is as in the previous case.
  \end{itemize}
\item If  is  then the proof is a straightforward adaptation of the  case above.
\end{itemize}

The reverse direction is proved similarly by observing that the only possible reduction

must be due to a tuple  that is in the transition function 
and the result follows. The only added complexity is to ensure that there is only one possible
reduction for a given current state and current head position symbol, this can be assured by
definition of the match rule excluding any term from matching with both patterns
 and .
\end{proof}

\begin{theorem}
\label{thm:fin:done}
The encoding  of a Turing Machine into ACPC; faithfully preserves reduction, and
divergence.
That is, given a Turing Machine 
then it holds that:
\begin{enumerate}
\item there is a transition

if and only if there is exactly one reduction

where , and
\item there is an infinite sequence of transitions

if and only if there is an infinite sequence of reductions
.
\end{enumerate}
\end{theorem}
\begin{proof}
Both parts can be proved by exploiting Lemma~\ref{lem:fin:faithful}.
\end{proof}


\subsubsection*{Concurrent Pattern Calculus}
\label{ssec:cpc}


The choice of using ACPC here rather than CPC is for simplicity in presentation.
This section recalls CPC and proves that the encodings hold in CPC as well.
CPC has a single class of {\em patterns} that combines both the terms and patterns of
ACPC defined as follows:

The {\em binding names}  are as before.
The {\em variable names}  can be used as both output (like the name terms
of ACPC) and equality tests (like the name-match of ACPC).
The {\em protected names}  are only equality tests (name-matches of ACPC).
{\em Compounds}  are as in ACPC.
A {\em communicable pattern} is a pattern that contains no binding or protected names.
\newcommand{\cpcmatch}[2]{\{ #1\pmatch #2\}}

Interaction CPC relies upon the {\em unification}  of the patterns  and 
to yield a pair of substitutions  and is 
defined by:

The unification succeeds and yields empty substitutions when both patterns are the same
name and are both variable or protected.
If either pattern is a binding name and the other is communicable, then the communicable
pattern is bound to the binding name in the appropriate substitution.
Otherwise if both patterns are compounds then unify component-wise.
Finally, if all these fail then unification is undefined (impossible).

The process of CPC are given by:

All are familiar from ACPC although the input and output are now both represented by
the {\em case}  with pattern  and body .

The structural laws are the same as for ACPC with -conversion defined in the usual
manner \cite{GivenWilsonGorlaJay10,givenwilson:hal-00987578} and interaction is defined by the following
axiom:

It states that when two cases in parallel can unify their patterns to yield substitutions
 and  then apply those substitutions to the appropriate bodies.


The encodings of Turing Machines into CPC are trivial, the only change is to remove
the overhead line from outputs, i.e.~ becomes  since all terms of
ACPC are patterns of CPC
\footnote{There is no need to convert syntax between ACPC and CPC, for example changing
name-matches from  to  in patterns, as the unification rules for CPC allow for both.
Indeed, the encodings were chosen to allow this.
Although in theory
CPC could allow two ACPC outputs to interact, this does not occur for the encodings in this paper.}.
However some proofs require changes due to the change from input and
output with one sided matching, to CPC cases with pattern unification.
The proof of Lemma~\ref{lem:tape-no-red} is trivial. For Lemmas~\ref{lem:trans-no-red}
and \ref{lem:fin:trans-no-red}
the proof is resolved due to CPC unification only allowing a binding name  to
unify with a communicable pattern.
The rest are effectively unchanged.

\begin{theorem}
\label{thm:cpc:done}
There is an encoding  of a Turing Machine into CPC that;
faithfully preserves reduction, and
divergence.
That is, given a Turing Machine 
then it holds that:
\begin{enumerate}
\item there is a transition

if and only if there is exactly one reduction

where , and
\item there is an infinite sequence of transitions

if and only if there is an infinite sequence of reductions
.
\end{enumerate}
\end{theorem}

\medskip


\newcommand{\cheq}{\stackrel\cdot\leftrightarrow}
\newcommand{\terms}{{\bf T}}
\newcommand{\assertion}{{\bf A}}
\newcommand{\one}{{\bf 1}}
\newcommand{\compose}{\otimes}
\newcommand{\assert}[1]{\llparenthesis \, #1 \, \rrparenthesis}
\newcommand{\fram}[1]{{\cal F}(#1)}

\subsubsection*{Psi Calculi}

\newcommand{\psiap}[2]{\underline{#1}(#2)}
\newcommand{\psoap}[2]{\overline {#1}(#2)}

Similarly both encodings can be easily adapted for Psi Calculi \cite{BJPV11}.
Psi Calculi are parametrized with respect to two sets: terms  defined by

the names  and the {\em pair}  of two terms  and ;
and assertions , ranged over by  (that play no significant r\^ole here).
The empty assertion is written .
Also assume two operators: channel equivalence, ,
and assertion composition, . 
It is also required that  is transitive and
symmetric, and that  is a commutative monoid.

Processes in Psi Calculi are defined as:

exploiting the notation  for a sequence .
Most process forms are as usual with:
{\em input}  on channel  and binding names  in the pattern 
and with body ;
and {\em output}  on channel  and outputting term .

The reduction relation semantics are given by
isolating the  actions of the LTS given in \cite{BJPV11}.
To this aim, the definiton of frame of a process , written ,
as the set of unguarded assertions occurring in . Formally:

and is  in all other cases. Denote as  the frame of .
The structural laws are the same as in ACPC.
The reduction relation is inferred by the following axioms:

The interesting axiom is the first that states when  and  are equivalent and
the term  is equal to the term  with each name in  replaced by some ,
then reduce to  in parallel with the substitution  applied to .
Denote with  whenever .



Both encodings of Turing Machines into ACPC can be easily adapted for Psi Calculi,
the following changes show how to do adapt the encodings for the infinite tape encoding.
All instances of the compounding operator  are replaced by the pair
operator ``'', i.e.~all terms and patterns of the form  take the form .
The encoding of the current state  and tape  becomes:

The encoding of the tuples becomes:

From there the rest of the encoding remains the same and the results are
straightforward.

\begin{theorem}
\label{thm:psi:done}
The encoding  of a Turing Machine into Psi Calculi;
faithfully preserves reduction, and
divergence.
That is, given a Turing Machine 
then it holds that:
\begin{enumerate}
\item there is a transition

if and only if there is exactly one reduction

where , and
\item there is an infinite sequence of transitions

if and only if there is an infinite sequence of reductions
.
\end{enumerate}
\end{theorem}

\section{Limitations}
\label{sec:fail}

\newcommand{\ifte}[4]{{\sf if}\ #1=#2\ {\sf then}\ #3\ {\sf else}\ #4}
\newcommand{\piiap}[2]{#1(#2)}
\newcommand{\pioap}[2]{\overline{#1}\langle #2\rangle}

This section discusses the difficulties of attempting to faithfully encode Turing Machines
into non-intensional calculi, particularly -calculi. (Here for synchronous polyadic -calculus, but
adaptations for asynchronous or monadic variations are straightforward, although may require
more reductions.)




The -calculus processes are given by the following grammar:

The null process, parallel composition, replication, and restriction are as usual.
The input  has channel name  and a sequence of binding names
 denoted by  and body .
The output  has channel name  and sequence of output names
 denoted  and body .
The length of a sequence  is denoted ,
i.e.~.
-conversion and structural equivalence are as usual.

The only reduction axiom is

That is an output and input reduce if they have the same channel name and the
length of their output names and binding names are the same, reducing to
the body of the output, in parallel with
the substitution that binds each output name  to the corresponding binding name 
applied to the body of the input.
The reduction relation is obtained by closing this reduction rule by parallel, restriction and the
same structural congruence relation defined for ACPC.



The first limitation of -calculi is in the number of names that can be determined
equal in an interaction. In the Psi Calculi encoding 
the channel name is used to detect the state, this can also be used for -calculi as
well.
However, the detection of the symbol at the current head position would require an additional
reduction.
There are two approaches that can resolve this first limitation while maintaining faithfulness.
The first solution is to account for both names by representing every possible
pair of state and symbol by a new name. That is, the encoding of a transition tuple
can be represented by

for some form of input  and process . Here the state  and current
head symbol  are combined into a single name  by the encoding.
The second approach is to use a structural equivalence rule such as
 with the following rules

Now the encoding of all of the tuples of the form 
are of the form

for each possible symbol .
Here  represents the process that does the transition for
, that is the reductions that correspond to the
transition for the matching current head position symbol , and are 
otherwise.

Note that there are other solutions to the problem of matching the state, such as
doing further reductions after binding the symbol at the current head position,
however these would immediately fail faithfulness.


The impossibility of encoding Turing Machines faithfully without intensionality
arises from the encoding of the tape into a single structure.
Since -calculi cannot bind a structured term to a single name, it is impossible
to represent the infinite tape by a finite structure.
The closest is to take the traditional approach of using some name(s) to identify
where the rest of the structure (tape) can be obtained from.
For example, consider the followings of an encoding into -calculus:

where  and  are reserved names for the left and right hand sides of the tape, respectively,
in the encoding.
Observe that in each case, the name can be used as a channel to input the symbol to
the left  or right  and the next name to use for the next symbol in that direction.
Note that parallel composition is used as this allows results to exploit structural
equivalence.

Using this approach the state  and tape
 can be encoded by


Now a transition  can be encoded as follows
(showing the  case only):

where each line after the encoding does as follows.
The  matches the (encoded) state  and current head position symbol ,
and binds the names
to access the left and right parts of the tape to  and , respectively.
Since the transition moves left, the  then reads the next symbol to the
left  and the name to access the rest of the left hand side of the tape .
A new name for the new right hand side of the tape is created with .
The next
line detects
the new symbol  under the current head position by
comparing to each possible symbol  and
outputting the new left and right hand tape access channel names  and  respectively
on the appropriately encoded channel name .
Finally, in parallel  provides the new right hand side of the tape.
The encoding of the  transitions can be done similarly.

Putting all of these pieces together as in Section~\ref{sec:enc} allows similar results
to ACPC to be applied to -calculi.

\begin{lemma}
\label{lem:tape-no-red-pi}
The representation
.
of the state  and tape 
does not reduce.
\end{lemma}

\begin{lemma}
\label{lem:trans-no-red-pi}
The encoding 
where  is each tuple of the form 
of the transition function 
does not reduce.
\end{lemma}

Finally, the encoding  of a Turing Machine into 
-calculus is given by:


The limitations of -calculi appear in the following lemma where the correspondence
of a single reduction in the original to a single reduction in the translation is lost,
instead a single reduction becomes two reductions (or more for some other -calculi).
Further, the proof is complicated by now having to consider -equivalence of all
the restricted names.
The impact is also in the final theorem in this section where faithfulness is lost.


\begin{lemma}
\label{lem:reduction-pi}
Given a Turing Machine 
then
\begin{enumerate}
\item If there is a transition

then there are reductions

where , and
\item if there is a reduction

then there exists  such that  and
 and
there is a transition
.
\end{enumerate}
\end{lemma}
\begin{proof}
The first part is proven by examining the tuple  that corresponds to the transition 

by the Turing Machine. This tuple must be of the form
 and it must also be that  is of the form
.
Further, it must be that  is either:
 when  is , or
 when  is .
Now 
is of the form
 and
by Lemmas~\ref{lem:tape-no-red-pi} and \ref{lem:trans-no-red-pi} neither 
nor  can reduce, respectively.
Now by exploiting structural congruence gain that
.
Then by two applications of the definition of the -calculus reduction axiom 
it is straightforward to show that
 for some .
Now by two applications of -conversion it can be shown that

for some  and  and .
Now consider .
\begin{itemize}
\item When  it can be shown that  and by two applications of induction on the
  indices of the restrictions  of the left and right hand sides of the tape it can be shown
  that  and that .
\item When  is can be shown that  and by two applications of induction on the
  indices of the restrictions  of the left and right hand sides of the tape it can be shown
  that  and that .
\end{itemize}

The reverse direction is proved similarly by observing that the only possible reduction

must be due to a tuple  that is in the transition function .
Then it follows that there exists a reduction  by definition of
.
Finally showing that 
again requires tedious renaming of both sides of the encoded tape.
\end{proof}

\begin{theorem}
\label{thm:done-pi}
The encoding  of a Turing Machine into (synchronous polyadic) -calculus;
preserves reduction, and divergence.
That is, given a Turing Machine 
then it holds that:
\begin{enumerate}
\item there is a transition

if and only if there are reductions

where , and
\item there is an infinite sequence of transitions

if and only if there is an infinite sequence of reductions
.
\end{enumerate}
\end{theorem}




\section{Conclusions}
\label{sec:conc}

The traditional approaches to encoding Turing Machines into process calculi
tend to be indirect and lead to complex and unclear results.
This is particularly true when the traditional path for process calculi is
taken by encoding a Turing Machine into -calculus and then into a 
process calculus.

Recent calculi with intensional communication allow the representation of
the current state and tape of a Turing Machine to be made clear and simple.
Similarly, the capture of each transition of the Turing Machine by an
input that transforms the state into a new output is a straightforward and
elegant solution.
The result is an encoding that is not only clearer and more direct, but also
faithful and holds up to structural equivalence.

The encoding can also be adapted in various ways.
The infinite terms of an infinite tape can be made finite if the tape of
the Turing Machine has some finite sequence of symbols with infinite blanks
on either side.
The choice of asymmetric concurrent pattern calculus here is for clarity alone,
the results also hold with only minor adaptations for both Concurrent Pattern
Calculus and Psi Calculi.

The approach used here to encode Turing Machines into intensional process calculi
can also be used to inform on similar approaches into non-intensional process
calculi such as -calculus. Although faithfulness is lost, the
simplicity of intensional calculi in both: matching many names in a single interaction,
and of binding complex structures to a single name, becomes clearer when observing
the complexity required to use this approach in -calculus.
Thus despite -calculi only losing faithfulness directly, the complexity of
the encodings into -calculi and having to work with many restrictions and
renamings highlights the elegance of the
encodings into intensional calculi.

\subsection*{Future Work}

The r\^ole of intensionality in process calculi has not been explored in depth
outside of particular calculi. A more general exploration of the expressiveness
of intensionality remains to be published.

The approach of encoding Turing Machines by directly capturing the state and
transitions has some similarities to the encoding of -logic \cite{jay2011}
into CPC \cite{GivenWilsonPhD}.
Adapting these approaches to other types of Turing Machines or rewriting
systems is also of interest.


\bibliographystyle{eptcs}
\bibliography{auto}


\end{document}
