\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\makeatletter
\def\ps@headings{\def\@oddhead{\mbox{}\scriptsize\rightmark \hfil \thepage}\def\@evenhead{\scriptsize\thepage \hfil \leftmark\mbox{}}\def\@oddfoot{}\def\@evenfoot{}}
\makeatother
\pagestyle{headings}

\usepackage{cite}
\usepackage{boxedminipage}
\usepackage{amsthm}
\usepackage{amssymb,amsmath,bm}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{macros}
\usepackage{times}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{color}
\usepackage{array}
\usepackage{tabularx}
\usepackage{wrapfig}
\usepackage{subfig}
\usepackage{algorithm}
\usepackage{algorithmic}

\ifCLASSINFOpdf
\else
\fi

\usepackage{url}


\newtheorem{Definition}{Definition}
\newtheorem{Problem}{Problem}
\newtheorem{Theorem}{Theorem}
\newtheorem{Lemma}{Lemma}
\newtheorem{Property}{Property}
\newtheorem{Observation}{Observation}
\newtheorem{Corollary}{Corollary}
\newenvironment{Proof}{\noindent{\bf Proof: }}{\hfill\qed}

\begin{document}
\title{Secure Multidimensional Queries in Tiered Sensor Networks}

\author{\IEEEauthorblockN{Chia-Mu Yu\IEEEauthorrefmark{2}\IEEEauthorrefmark{4}, Chun-Shien Lu\IEEEauthorrefmark{2}, and Sy-Yen Kuo\IEEEauthorrefmark{4}}

\IEEEauthorblockA{\IEEEauthorrefmark{2}Institute of Information Science, Academia Sinica, Taipei, Taiwan}
\IEEEauthorblockA{\IEEEauthorrefmark{4}Department of Electrical Engineering, National Taiwan University, Taipei, Taiwan}
}

\maketitle


\begin{abstract}
In this paper, aiming at securing range query, top-k query, and skyline query in tiered sensor networks, we propose the Secure Range Query (SRQ), Secure Top- Query (STQ), and Secure Skyline Query (SSQ) schemes, respectively. In particular, SRQ, by using our proposed \emph{prime aggregation} technique, has the lowest communication overhead among prior works, while STQ and SSQ, to our knowledge, are the first proposals in tiered sensor networks for securing top- and skyline queries, respectively. Moreover, the relatively unexplored issue of the security impact of sensor node compromises on multidimensional queries is studied; two attacks incurred from the sensor node compromises, \emph{collusion attack} and \emph{false-incrimination attack}, are investigated in this paper. After developing a novel technique called \emph{subtree sampling}, we also explore methods of efficiently mitigating the threat of sensor node compromises. Performance analyses regarding the probability for detecting incomplete query-results and communication cost of the proposed schemes are also studied.
\end{abstract}

\section{Introduction}\label{sec: Introduction}

\textbf{Tiered Sensor Networks.} Sensor networks are expected to be deployed on some harsh or hostile regions for data collection or environment monitoring. Since there is the possibility of no stable connection between the authority and the network, in-network storage is necessary for caching or storing the data sensed by sensor nodes. A straightforward method is to attach external storage to each node, but this is economically infeasible. Therefore, various data storage models for sensor networks have been studied in the literature. In \cite{rksegyy03,dglls05}, a notion of tiered sensor networks was discussed by introducing an intermediate tier between the authority and the sensor nodes. The purpose of this tier is to cache the sensed data so that the authority can efficiently retrieve the cache data, avoiding unnecessary communication with sensor nodes.

The network model considered in this paper is the same as the ones in \cite{rksegyy03,dglls05}. More specifically, some storage-abundant nodes, called \emph{storage nodes}, which are equipped with several gigabytes of NAND flash storage \cite{slm06}, are deployed as the intermediate tier for data archival and query response. In practice, some currently available sensor nodes such as RISE \cite{RISE} and StarGate \cite{startgate} can work as the storage nodes. The performance of sensor networks wherein external flash memory is attached to the sensor nodes was also studied in \cite{mdgs06}. In addition, some theoretical issues concerning the tiered sensor networks, such as the optimal storage node placement, were also studied in \cite{slm06,stlm07}. In fact, such a two-tiered network architecture has been demonstrated to be useful in increasing network capacity and scalability, reducing network management complexity, and prolonging network lifetime.

\textbf{Multidimensional Queries.} Although a large amount of sensed data can be stored in storage nodes, the authority might be interested in only some portions of them. To this end, the authority issues proper queries to retrieve the desired portion of sensed data. Note that, when the sensed data have multiple attributes, the query could be multidimensional. We have observed that range query, top- query, and skyline query are the most commonly used queries. Range query \cite{lkgh03,mfhh05}, which could be useful for correlating events occurring within the network, is used to retrieve sensed data whose attributes are individually within a specified range. After mapping the sensed data to a ranking value, top- query \cite{wxtl07}, which can be used to extract or observe the extreme phenomenon, is used to retrieve the sensed data whose ranking values are among the first  priority. Skyline query \cite{czg07,lcy08}, due to its promising application in multi-criteria decision making, is also useful and important in environment monitoring, industry control, \emph{etc}.

Nonetheless, in the tiered network model, the storage nodes become the targets that are easily compromised because of their significant roles in responding to queries. For example, the adversary can eavesdrop on the communications among nodes or compromise the storage nodes to obtain the sensed data, resulting in the breach of \emph{data confidentiality}. After the compromise of storage nodes, the adversary can also return falsified query-results to the authority, leading to the breach of \emph{query-result authenticity}. Even more, the compromised storage nodes can cause \emph{query-result incompleteness}, creating an incomplete query-result for the authority by dropping some portions of the query-result.

\textbf{Related Work.} Secure range queries in tiered sensor networks have been studied only in \cite{sl08,szz09,zsz09}. Data confidentiality and query-result authenticity can be preserved very well in \cite{sl08,szz09,zsz09} owing to the use of the bucket scheme \cite{hilm02,hmt04}. Unfortunately, encoding approach \cite{sl08} is only suitable for the one-dimensional query scenario in the sensor networks for environment monitoring purposes. On the other hand, crosscheck approaches \cite{szz09,zsz09} can be applied on sensor networks for event-driven purposes at the expense of the reduced probability for detecting query-result incompleteness. The security issues incurred from the compromise of storage nodes have been addressed in \cite{sl08,szz09,zsz09}. The impact of \emph{collusion attacks} defined as the collusion among compromised sensor nodes and compromised storage nodes, however, was only discussed in \cite{zsz09}, wherein only a naive method was proposed as a countermeasure. When the compromised sensor nodes are taken into account, a Denial-of-Service attack, called \emph{false-incrimination attack}, not addressed in the literature, can be extremely harmful. In such an attack, the compromised sensor nodes subvert the functionality of the secure query schemes by simply claiming that their sensed data have been dropped by the storage nodes. After that, the innocent storage nodes will be considered compromised and will be revoked by the authority. It should be noted that all the previous solutions suffer from false-incrimination attacks.

\textbf{Contribution.} Our major contributions are:
\begin{itemize}
\item The Secure Range Query (SRQ) scheme is proposed to secure the range query in tiered networks (Sec. \ref{sec: Securing Range Queries (SRQ)}). By taking advantage of our proposed \emph{prime aggregation} technique for securely transmitting the amount of data in specified buckets, SRQ has the lowest communication cost among prior works in all scenarios (environment monitoring and event detection purposes), while preserving the probability for detecting incomplete query-results close to . It should be noted that although incorporating bucket scheme \cite{hilm02,hmt04} (described in Sec. \ref{sec: Confidentiality-preserving reporting}) in the protocol design \cite{sl08,szz09,zsz09} is not new, the novelty of our method lies on the use of \emph{prime aggregation} in reducing the overhead and guaranteeing query-result completeness.

\item For the first time in the literature, the issues of securing top- and skyline queries in tiered networks are studied (Secs. \ref{sec: Securing Top- Queries (STQ)} and \ref{sec: Securing Skyline Queries (SSQ)}). Our solutions to these two issues are Secure Top- Query (STQ) and Secure Skyline Query (SSQ), respectively. The former is built upon the proposed SRQ scheme to detect query-result completeness, while the efficiency of SSQ is based on our proposed \emph{grouping} technique.

\item The security impact of sensor compromises is studied (Sec. \ref{sec: Impact of Sensor Node Compromise}); \emph{collusion attack} is formally addressed, and a new Denial-of-Service attack, \emph{false-incrimination attack}, which can thwart the security purpose in prior works, is first identified in our paper. The resiliency of SRQ, STQ, and SSQ against these two attacks is investigated. With a novel technique called \emph{subtree sampling}, some minor modifications are introduced for SRQ and STQ as countermeasures to these two attacks. Moreover, the compromised nodes can even be efficiently identified and be further attested \cite{slpdk06,smkk05,spdk04}.
\end{itemize}
\section{System Model}\label{sec: System Model}
In general, the models used in this paper are very similar to those in \cite{rksegyy03,dglls05,sl08,szz09,zsz09}.

\textbf{Network Model.} As shown in Fig. \ref{fig: tiered_network}, the sensor network considered in this paper is composed of a large number of resource-constrained sensor nodes and a few so-called \emph{storage nodes}. Storage nodes are assumed to be storage-abundant and may be compromised. In addition, in certain cases, storage nodes could also have abundant resources in energy, computation, and communication. The storage nodes can communicate with the authority via direct or multi-hop communications. The network is connected such that, for two arbitrary nodes, at least one path connecting them can be found.

A \emph{cell} is composed of a storage node and a number of sensor nodes. In a cell, sensor nodes could be far away from the associated storage node so that they can communicate with each other only through multi-hop communication. For example, in Fig. \ref{fig: tiered_network}, without the relay of the gray node, the black node cannot reach the storage node. \begin{wrapfigure}{r}{0.25\textwidth}
  \begin{center}
    \includegraphics[width=0.32\textwidth]{tiered_network}
  \end{center}
  \caption{\footnotesize A tiered sensor network.}
  \label{fig: tiered_network}
\end{wrapfigure} The nodes in the network have synchronized clocks \cite{snwlz06} and the time is divided into epochs. As in \cite{sl08,slm06,szz09,zsz09}, each node is assumed to be aware of the geographic position it locates \cite{lnd05,zlfw06} so that the association between the sensor node and storage node can be established. As a matter of fact, information about the time and geographic position is indispensable for most sensor network applications.

For each cell, aggregation is assumed to be performed over an aggregation tree rooted at the storage node. Since the optimization of the aggregation tree structure is out of the scope of this paper, we adopt the method described in TAG \cite{mfhh02} to construct an aggregation tree. We follow the conventional assumption that the topology of the aggregation tree is known by the authority \cite{cp08,cps06}. Similar to sensor nodes, storage nodes also perform the sensing task. Each sensor node senses the data and temporarily stores the sensed data in its local memory within an epoch. At the end of each epoch, the sensor nodes in a cell report the sensed data stored in local memory to the associated storage node. Throughout this paper, we focus on a cell , composed of  sensor nodes, , and a storage node .

\textbf{Security Model.}
We consider the adversary who can compromise an arbitrary number of storage nodes. After node compromises, all the information stored in the compromised storage nodes will be exposed to the adversary. The goal of the adversary is to breach at least one of the following: data confidentiality, query-result authenticity, and query-result completeness. We temporarily do not consider the compromise of sensor nodes in describing SRQ, STQ, and SSQ in Sec. \ref{sec: Securing Multidimensional Queries}. The impact of sensor node compromise on the security breach, however, will be explored in Sec. \ref{sec: Impact of Sensor Node Compromise}. Many security issues in sensor networks, such as key management \cite{cps03,eg02,ylk09}, broadcast authentication \cite{pswct01,ln04}, and secure localization \cite{lnd05,zlfw06}, have been studied in the literature. This paper focuses on securing multidimensional queries that are relatively unexplored in the literature, while the protocol design of the aforementioned issues are beyond the scope of this paper.

\textbf{Query Model.}
The sensed data can be represented as a -dimensional tuple, , where , , denotes the -th attribute. The authority may issue a proper -dimensional query to retrieve the desired portion of data stored in storage nodes. Three types of queries, including range query, top- query, and skyline query, are considered in this paper. For range query, its form, issued by the authority, is expressed as , which means that the sensed data to be reported to the authority should be generated by the nodes in cell  at epoch , and their -th attributes, 's, should be within the range of , . Top- query is usually associated with a scalar (linear) \emph{ranking function}. With ranking function, , the sensed data, even if it is multidimensional, can be individually mapped to a one-dimensional \emph{ranking value}. The top- query issued by the authority is in the form of . As the first attempt to achieve secure top- query, the goal of top- query in this paper is simply assumed to obtain the sensed data generated by the nodes in cell  at epoch  with the first  smallest ranking values. For skyline query, the desired \emph{skyline data} are defined as those not \emph{dominated} by any other data. Assuming that smaller values are preferable to large ones for all attributes, for a set of -dimensional data, a datum  \emph{dominates} another datum  if both the conditions, , , and , where  denotes the -th attribute value of the datum , hold. Hence, the form of the skyline query issued by the authority is given as , which is used to retrieve the skyline data generated in cell  at epoch .

\section{Securing Multidimensional Queries}\label{sec: Securing Multidimensional Queries}
In this section, aiming at securing range query, top- query, and skyline query, we propose the SRQ (Sec. \ref{sec: Securing Range Queries (SRQ)}), STQ (Sec. \ref{sec: Securing Top- Queries (STQ)}), and SSQ (Sec. \ref{sec: Securing Skyline Queries (SSQ)}) schemes, respectively. Note that though SRQ, STQ, and SSQ use the bucket scheme \cite{hilm02,hmt04}, the novelty of them is due to their design in efficiently detecting the incomplete query-result (described later).

\subsection{Securing Range Queries (SRQ)}\label{sec: Securing Range Queries (SRQ)}
Our proposed SRQ scheme consists of a confidentiality-preserving reporting phase (Sec. \ref{sec: Confidentiality-preserving reporting}) that can simultaneously prevent the adversary from accessing data stored in the storage nodes, authenticate the query results, and ensure efficient multidimensional query processing, and a query-result completeness verification phase (Sec. \ref{sec: Query-Result Completeness Verification}) for guaranteeing the completeness of query-results.

\subsubsection{Confidentiality-preserving reporting}\label{sec: Confidentiality-preserving reporting}
Data encryption is a straightforward and common method of ensuring data confidentiality against a compromised storage node. Moreover, we hope that even when the adversary compromises the storage node, the previously stored information should not be exposed to the adversary. To this end, the keys used in encryption should be selected from a one-way hash chain. In particular, assume that a key  is initially stored in sensor node . At the beginning of epoch , the key , which is used only within epoch , is calculated as , where  is a hash function, and  is dropped. Suppose that sensor node  has sensed data  at epoch . One method for storing  in the storage node  while preserving the privacy is to send , which denotes the encryption of  with the key . With this method, when an OCB-like authenticated encryption primitive \cite{rbb03} is exploited, the authenticity of  can be guaranteed. At the same time,  will not be known by the adversary during message forwarding and even after the compromise of the storage node at epoch  because the adversary cannot recover the keys used in the time before epoch . Nevertheless, no query can be answered by  if only encrypted data is stored in . Hence, the \emph{bucket scheme} proposed in \cite{hilm02,hmt04}, which uses the encryption keys generated via a one-way hash chain, is used in the SRQ scheme.

In the bucket scheme, the domain of each attribute , , is assumed to be known in advance, and is divided into  consecutive non-overlapping intervals sequentially indexed from  to , under a publicly known partitioning rule. For ease of representation, in the following, we assume that , . A -dimensional bucket is defined as a tuple,  (hereafter called \emph{bucket ID}), where , . The sensor node , when it has sensed data at epoch ,  sends to  the corresponding bucket IDs, which are constructed by mapping each attribute of the sensed data to the proper interval index, and the sensed data encrypted by the key . For example, when  has sensed data , , and  at epoch , the message transmitted to the storage node at the end of epoch  is , assuming that , , and each interval length, set at , is the same.

Let  be the set of all possible bucket IDs. Assume that there are on average  and  data generated in a cell and in a node, respectively, at epoch . Assume that,  is a set containing all the data within the bucket  sensed by  at epoch . The messages sent from  to  at the end of epoch  can be abstracted as , where  if there are some data sensed by  within epoch . Note that  sends nothing to  if 's, , are empty. After that,  can answer the range query according to the information revealed by the bucket IDs. Assume that  and  are located within the -th and -th intervals, respectively, where , , , and . The encrypted data falling into the buckets in the set  are reported to the authority. In other words, once receiving the range query,  first translates the information  into the proper bucket IDs and then replies all the encrypted data falling into the buckets\footnote{There is a tradeoff between the communication cost and confidentiality in terms of bucket sizes because larger bucket size implies higher data confidentiality and higher communication cost due to more superfluous data being returned to the authority. The design of optimal bucketing strategies is beyond the scope of this paper, and we refer to \cite{hilm02,hmt04} for more details.} in .

Nevertheless, in tiered sensor networks, even when the original bucket scheme is used,  could still maliciously drop some encrypted data and only report part of the results to the authority, resulting in an incomplete query-result. In the following, we will describe an extended bucket scheme, which incorporates the prime aggregation strategy into the original bucket scheme, to detect the incomplete reply in a communication-efficient manner.

\subsubsection{Query-Result Completeness Verification}\label{sec: Query-Result Completeness Verification}
With \emph{prime aggregation} technique, SRQ detects an incomplete reply by taking advantage of aggregation for counting the amount of sensed data falling into specified buckets. Together with a hash for verification purpose, the count forms a so-called \emph{proof} in detecting an incomplete reply. The storage node  is required to provide the proof to the authority at the epoch specified in the query so that the authority can use the proof to verify the completeness of received query-results. Since in our design all the sub-proofs generated by the nodes can be aggregated to yield the final proof, the communication cost can be significantly reduced. The details are described as follows.

Assume that an aggregation tree \cite{mfhh02} has been constructed after sensor deployment. Recall that the domain of attribute  is divided into  intervals. Before the sensor deployment, a set  of  prime numbers is selected by the authority such that  and  if  or . Then, the set  of  prime numbers, called the set of \emph{bucket primes} of , is stored in each sensor node . In addition, a set  of  keys is selected by the authority and is stored in each sensor node  initially. For fixed  and , the set of  is called the set of \emph{bucket keys} of  at epoch . Bucket primes could be publicly-known, while bucket keys should be kept secret. Each sensor node , at the beginning of epoch , calculates  and then drops , . In addition,  also calculates  and then drops .

Recall that each node  on average has  sensed data at epoch , and assume that the set of  bucket IDs associated with these  sensed data is , which could be a multiset. Then, according to its sensed data,  calculates , where  denotes the keyed hash function with key , if it has sensed data, and  otherwise. Moreover,  computes  if it has sensed data, and  otherwise. Moreover, once receiving ,  from its  children, ,  calculates , where  denotes the set of encrypted data sensed by  at epoch , and , where  denotes the set of bucket IDs of . In addition,  also calculates  and , . Finally,  reports  to its parent node on the aggregation tree. Note that, if  is a leaf node on the aggregation tree, then we assume that it receives .

Assume that the set  of  prime numbers stored in  are all different from those stored in sensor nodes, and the set  of  bucket keys are selected by the authority and stored in .  computes  and drops  at epoch . In addition,  also computes  and drops  at epoch . For the storage node , it can also calculate , , , and  according to the its own sensed data at epoch . In fact, the procedures  needs to perform after messages are received from the child nodes are the same as the ones performed by the sensor nodes. Acting as the root of the aggregation tree, however,  keeps the aggregated results, which are denoted as  and , respectively, in its local storage and waits for the query issued by the authority. Note that  can be thought of as a compact summary of the sensed data of the whole network and can be very useful for the authority in checking the completeness of the query-result, while  can be used by the authority to verify the authenticity of .

Assume that a range query  is issued by the authority. The encrypted data falling into the buckets in the set , along with the proof composed of  and , are sent to the authority. Once  is received, the authority immediately performs the prime factor decomposition of . Due to the construction of , which guarantees that the bucket primes are all distinct, after the prime factor decomposition of , the authority can be aware of which node contributes which data within specified buckets. As a result, the authority can know which keys should be used to verify the authenticity and integrity of . More specifically, assume that , , and that  are distinct prime numbers. From the construction of , we know that , for , is equal to , for  and . From the procedure performed by each node, it can also be known that the appearance of  in  means that at epoch  the sensor node  produces  data falling into bucket , contributing the bucket key  in total  times in . Here, the sensor node  producing the data falling into the bucket  means that  senses nothing. Thus, we can infer the total amount of data falling into specified buckets at epoch . Recall that the authority is aware of the topology of the aggregation tree. Thus, after the prime factor decomposition of , the authority can reconstruct  according to the derived 's and 's by its own effort, because it knows  and , , , . Therefore, we know that the  reconstructed by the authority is equal to the received  if and only if the received  are considered authentic. When the verification of  fails,  is considered compromised. When the verification of  is successful, the authority decrypts all the received encryptions, and checks whether the number of query-results falling into the buckets in  matches those indicated by . If and only if there are matches in all the buckets in , the received query-results are considered complete.

\subsection{Securing Top- Queries (STQ)}\label{sec: Securing Top- Queries (STQ)}
Basically, the proposed STQ scheme for securing top- query is built upon SRQ in that both confidentiality-preserving reporting and query-result completeness verification phases in SRQ are exploited. In particular, based on the proof generated in SRQ, since it can know which buckets contain data, the authority can also utilize such information to examine the completeness of query-results of top- query. In other words, top- query can be secured by the use of the SRQ scheme. Because of the similarity between the SRQ and STQ schemes, some details of the STQ scheme will be omitted in the following description.

Here, a \emph{bucket data set} is defined to be composed of bucket IDs. We use a -dimensional tuple, , where , to represent the bucket IDs in a bucket data set. With this representation, we can use the ranking function, , to calculate the ranking value of each bucket ID. Assume that the -th interval in the -th attribute contains the values in . The ranking value of the bucket ID, , is evaluated as , where the -dimensional tuple, , whose individual entry is simply averaged over the minimum and maximum values in each interval, acts as the representative of the bucket  for simplicity.

Recall that we simply assume that the data with the first  smallest ranking values are desired. The general form of the message sent from  to its parent node at the end of epoch  is , where , , , and  are the same as those defined in SRQ. Assume that  are  bucket IDs in the bucket data set whose ranking values are among the first  smallest ones. According to ,  can calculate the ranking values of bucket IDs in  and, therefore, knows . To answer a top- query, , the storage node  reports the bucket IDs, , and their corresponding encrypted data, along with  and , to the authority because it can be known that the data with the first  smallest ranking values must be within . After receiving the query-result, the authority can first verify the authenticity of  by using , and verify the query-result completeness by using . Note that both of the above verifications can be performed in a way similar to the one described in Sec. \ref{sec: Securing Range Queries (SRQ)}. Actually, after receiving , the authority knows which buckets contain data and the amount of data. Hence, knowing  and , , , the authority can also obtain . Afterwards, what the authority should do is to check if it receives the bucket IDs, , and if the number of data in bucket , , is consistent with the number indicated by . If and only if these two verifications pass, the authority considers the received query-result to be complete and extracts the top- result from the encrypted data sent from .

\subsection{Securing Skyline Queries (SSQ)}\label{sec: Securing Skyline Queries (SSQ)}
To support secure skyline query in sensor networks, in the following we first present a naive approach as baseline, and then propose an advanced approach that employs a grouping technique for simultaneously reducing the computation and communication cost.

\subsubsection{Baseline scheme}\label{sec: Baseline scheme}
To ensure the data confidentiality and authenticity, as in the SRQ and STQ schemes, the sensed data are also encrypted by using the bucket scheme mentioned in Sec. \ref{sec: Confidentiality-preserving reporting}. At the end of epoch , each  broadcasts its sensor ID, all the sensed data encrypted by key , and the proper bucket IDs to all the nodes within the same cell. Then, according to the broadcast messages, each sensor node  at epoch  has a bucket data set composed of the bucket IDs extracted from broadcast messages and the bucket IDs corresponding to its own sensed data. In fact, the bucket data sets constructed by different nodes in the same cell at epoch  will be the same. Treating these bucket IDs as data points,  can find the set  of \emph{skyline buckets} that are defined as the bucket IDs not dominated by the other bucket IDs. Here, since the bucket IDs are represented also by -dimensional tuples, the notion of domination is the same as the one defined in the query model of Sec. \ref{sec: System Model}. Define \emph{quasi-skyline data} as the set of data falling into the skyline buckets. It can be observed that the set of skyline data must be a subset of quasi-skyline data. After doing so, each node can locally find\footnote{The design of an algorithm for efficiently finding the skyline data given a data set is a research topic, but is beyond the scope of this paper. We consider the naive data-wise comparison-based algorithm with running time  if the size of the data set is , but each node, in fact, can implement an arbitrary algorithm for finding skyline data in our setting.} the quasi-skyline data, although there could be the cases where superfluous data are also included. At the end of epoch , if  is smaller than a pre-determined threshold, then  sends its sensor ID and  to . Here,  works as a kind of proof so that it can be used for checking the query-result completeness. Note that only  needs to be transmitted to  because  also receives all the encrypted data and bucket IDs, and can calculate the quasi-skyline data by itself after message broadcasting.

To answer the skyline query  the storage node reports the quasi-skyline data calculated at epoch  and the hash values received at epoch  to the the authority. Since the authority knows the threshold and  , it will expect to receive hash values from a set of sensor nodes whose keys are smaller than the threshold. Unfortunately, due to the network-wide broadcast, this baseline scheme works but is inefficient in terms of communication overhead. Hence, an efficient SSQ scheme exploiting a grouping strategy is proposed as follows.

\subsubsection{Grouping technique}\label{sec: Grouping technique}
Like the baseline scheme, the bucket scheme mentioned in Sec. \ref{sec: Confidentiality-preserving reporting} is also used. Given a data set  and a collection  of subsets of  satisfying  and ,  for . An observation is that the skyline data of  must be a subset of the union of the skyline data of , . Thus, the key idea of our proposed SSQ scheme is to partition the sensor nodes in a cell into groups so that broadcasting can be limited within a group, resulting in reduced computation and communication costs. In what follows, the SSQ scheme will be described in more detail.

The sensor nodes in a cell are divided into  disjoint groups, , , each of which is composed of  sensor nodes. The grouping needs to be performed only once right after the sensor deployment. Note that each group is formed by nearby sensor nodes and the grouping procedure is independent of the structure of the aggregation tree without affecting SRQ and STQ. Let \emph{cell-region} be part of the sensing region monitored by one specified cell. For example, with the assumption that the shape of each cell-region is approximately a square, as shown in Fig. \ref{fig: tiered_network}, and sensor nodes with uniform deployment are considered, the grouping can be achieved by simply dividing a cell-region into  () sub-cell-regions. The sensor nodes in the same sub-cell-region form a group. Note that the square cell-region is assumed here for ease of explanation, but is not necessary for the grouping procedures\footnote{For example, the authority knowing the position of each node or the use of clustering algorithms can also divide nodes into groups. In general, after the localization, each sensor node can join the proper group possibly according to its geographic position when the grouping information such as the sizes of sensing region and cell-region are preloaded in sensor nodes.}.

At the end of epoch , each sensor node  broadcasts its sensor ID, its \emph{order seed} , all the sensed data encrypted with the key , and the proper bucket IDs to all the nodes within the same group. After doing so, as in baseline scheme, the sensor nodes in the same group can locally find the quasi-skyline data from the bucket data set whose entries are generated by the sensor nodes in the same group. Let  be the set of skyline bucket IDs and  their corresponding quasi-skyline data encrypted by the sensor nodes in group  using proper keys at epoch . At the end of epoch , if  is among the first  smallest ones in the set of order seeds in group  at epoch , where  is a pre-determined threshold known by each node, then  reports , , its \emph{verification seed} , and the IDs of sensor nodes generating  to . In fact,  is sufficient for the verification purpose. , however, is also related to the resiliency against sensor node compromises. Thus, we still keep  as a variable and defer the explanation of the purpose of  to Sec. \ref{sec: Impact of Sensor Node Compromise}. Here, the purpose of verification seeds is that the completeness of quasi-skyline data can be guaranteed by exactly  sensor nodes for each group, while the purpose of order seed is to guarantee that at each epoch exactly  sensor nodes will send the verification seeds as the proofs.

To answer a skyline query, , the storage node  reports a hash of all the received verification seeds, , where  denotes the bit-string concatenation and  is the set of sensor nodes responsible for sending a hash value to  in each group at epoch , the set of skyline bucket IDs, and their corresponding encrypted data received at epoch  to the authority. Since it knows the threshold  and , , the authority will expect to receive a particular hash value from . If and only if the hash sent from the  matches the hash of the verification seeds calculated according to the knowledge of  and  by the authority itself, the received data are considered complete, and contain the skyline data.


\section{Performance Evaluation}\label{sec: Performance Evaluation}
We will focus on analyzing the critical issue of detecting an incomplete query-result in tiered networks. In this section, the detection probability and communication cost of query-result completeness verification in the proposed schemes will be analyzed. It is assumed that the number of hops between  and each sensor node is  for a collection of  uniformly deployed nodes \cite{cp05}. In this section, both detection probability and communication cost are discussed at a fixed epoch .

As the communication cost of encoding approach \cite{sl08} grows exponentially with the number of attributes, and some crosscheck approaches \cite{szz09,zsz09} have relatively low detection probability, in the following, we compare SRQ with only \emph{hybrid crosscheck} \cite{zsz09}, which achieves the best balance between the detection probability and communication cost in the literature. Note that, the parameter setting required in hybrid crosscheck is the same as that listed in \cite{zsz09}.

\subsection{Detection Probability}\label{sec: Detection Probability}
The detection probability is defined as the probability that the compromised storage node  is detected if it returns an incomplete query-result. With the fact that the larger the portion of query-result  drops, higher the probability that the authority detects it, we consider the worst case that only one bucket and its corresponding data in the query-result are dropped by  and the number of data sensed by a node is either  or  as the lower bound of detection probability.

\subsubsection{Detection probability for SRQ and STQ}\label{sec: Detection probability of SRQ and STQ}
To return an incomplete query-result without being detected by the authority,  should create a proof, , corresponding to the incomplete query-result. Since bucket primes can be known by the adversary,  can be easily constructed. Nevertheless,  cannot be constructed, since the bucket keys of sensor nodes generating the bucket dropped by  are not known by the adversary. Therefore, only two options can be chosen by the adversary. First, the adversary can directly guess to obtain , with probability being , where  is the number of bits output by a keyed hash function. This implies that the detection probability  is  for the first case. Second, knowing the aggregation tree topology, the adversary can also follow the rule of SRQ to construct the  without considering the bucket key of dropped bucket. Assume that the probability that a sensor node has sensed data is . The size of the bucket key pool can be derived as . Thus, the probability for the adversary to guess successfully is , where  is the number of bits of a key, leading to the detection probability  is  for the second case. Overall, the final detection probability, , is . On the other hand, as stated in Sec. \ref{sec: Securing Top- Queries (STQ)}, the STQ scheme is built upon the SRQ scheme. Thus, the detection probability, , will be the same as . As Fig. \ref{fig: detection probability} depicts, the detection probability of SRQ is close to  in any case. However, hybrid crosscheck is effective only when a few sensed data are generated in the network. Such a performance difference can be attributed to the fact that the sensed data in the network are securely and deterministically summarized in the proof of SRQ but they are probabilistically summarized in hybrid crosscheck.

\begin{figure}[h]
\centering
\subfloat[]{\label{fig: detection probability Y100}\includegraphics[width=0.26\textwidth]{probY100}}
\subfloat[]{\label{fig: detection probability Y5000}\includegraphics[width=0.26\textwidth]{probY5000}}
\caption{\scriptsize The detection probability of SRQ and hybrid crosscheck in the cases that (a)  and (b) .} \label{fig: detection probability}
\end{figure}

\subsubsection{Detection probability for SSQ}\label{sec: Detection probability of SSQ}
To return an incomplete query-result without being detected by the authority,  should forge a proof, \emph{i.e.}, a hash  of all the received verification seeds, corresponding to the incomplete query-result. Therefore, only two options can be chosen by the adversary. First, the adversary can directly guess a hash value . The probability for the adversary to guess successfully is , implying the detection probability  is  in this case. Second, the adversary can also follow the rule of SRQ to construct  for incomplete data. In this case, the adversary is forced to guess  keys for each one of  groups, leading to the probability of success guess being  and the detection probability being . The final detection probability, , is thus, . Obviously,  will also be close to  when appropriate key length or hash function is selected.

\subsection{Communication Cost}\label{sec: Communication Cost}
The communication cost, , is defined as the number of bits in the communications required for the proposed schemes. We are mainly interested in the asymptotic result in terms of  and  because they reflect the scalability of the number of attributes and the network size, respectively. We do not count the number of bits in representing data, , since the sending of  is necessary in any data collection scheme. We further assume that there are on average  data buckets, where , generated in cell .

\subsubsection{Communication Cost of SRQ and STQ} Each sensor node  in SRQ is required to send , and  to its parent node. Nevertheless, , and  can be aggregated along the path in the aggregation tree. As a consequence,  actually has only one-hop broadcast containing , and  once at each epoch. In addition, to answer a range query,  is responsible for sending , , and the bucket IDs in . In summary, the communication cost, , can be calculated as , where  is the number of bits used to represent the bucket prime . Due to the similarity between SRQ and STQ, the communication cost, , can also be calculated as  in a way similar to the one for obtaining .

\begin{figure}[h]
\centering
\subfloat[]{\label{fig: communication cost Y100}\includegraphics[width=0.26\textwidth]{commcostY100}}
\subfloat[]{\label{fig: communication cost Y5000}\includegraphics[width=0.26\textwidth]{commcostY5000}}
\caption{\scriptsize The communication cost of SRQ and hybrid crosscheck in the cases that (a)  and (b) .} \label{fig: communication cost}
\end{figure}

As shown in Fig. \ref{fig: communication cost} where the parameters  and  are used, the communication cost of SRQ is significantly lower than that of hybrid crosscheck. More specifically, as the communication cost of hybrid crosscheck can be asymptotically represented as  and will be drastically increased with  and , the proposed SRQ scheme, however, exhibits low communication cost regardless of the amount of sensed data in the network due to the fact that the size of the proof used in SRQ is always a constant. Hence, the communication cost of SRQ will be dominated by the aggregation procedure, the average hop distance between  and each node, and the transmission of bucket IDs, resulting  communication cost.

\subsubsection{Communication Cost of SSQ}
Since grouping is only performed once after sensor deployment, we ignore its communication cost. Note that, in the following, the communication cost of the data should be counted because it is involved in the design of SSQ. After the grouping, each  broadcasts the data bucket IDs, sensor ID, and the order seed to all the nodes within the same group. Assuming that the nodes employ a duplicate suppression algorithm, by which each node only broadcasts a given message once, one node should broadcast a message with  bits, where  is the average size of a datum and  is the number of bits required to represent sensor IDs, resulting in communication cost of  bits in each group. Let  be the average ratio of the quasi-skyline data to all the sensed data.  is equal to  on average. Then, once the the order seed is among the first  smallest ones of the order seeds in a group,  is required for sending , , , its sensor ID, and the IDs of sensor nodes generating buckets in  to , implying the communication cost of  bits in the worst case. Note that the verification seeds cannot be aggregated, although the verification seed can also be delivered along the path to  on the aggregation tree.  needs to send the skyline bucket IDs, its sensor ID, and a hash  as the proof to the authority for answering the query. The communication cost of  is . Consequently, the upper bound of communication cost, , can be obtained as  when  and , . By similar derivation, the communication cost of the baseline scheme is . Thus, exploiting the proposed grouping technique does reduce the required communication cost. The trends of communication cost in SSQ are shown in Fig. \ref{fig: SSQ communication cost}.

\begin{figure}[h]
\centering
\subfloat[]{\label{fig: SSQ communication cost Y100}\includegraphics[width=0.26\textwidth]{SSQcommcostY100}}
\subfloat[]{\label{fig: SSQ communication cost Y5000}\includegraphics[width=0.26\textwidth]{SSQcommcostY5000}}
\caption{\scriptsize The communication cost of SSQ for (a)  and (b) .} \label{fig: SSQ communication cost}
\end{figure}

\section{Impact of Sensor Node Compromise}\label{sec: Impact of Sensor Node Compromise}
In the previous discussions, we have ignored the impact of the compromise of sensor nodes. In practice, the adversary could take the control of sensor nodes to enhance the ability of performing malicious operations. The notation  is used to denote a set of random sensor nodes compromised by the adversary. In \emph{collusion attack} considered here,  colludes with  in the hope that more portions of query-results generated by innocent sensor nodes can be dropped. Since crosscheck approaches \cite{zsz09} suffer from collusion attacks, the impact of collusion attack on secure range query for tiered sensor networks was addressed in \cite{zsz09}. Their proposed method is \emph{random probing}, by which the authority occasionally checks if there is no data sensed by some randomly selected sensor nodes by directly communicating with them. Random probing, however, can only discover the incomplete query-results with an inefficient but possibly lucky way and cannot identify .

On the other hand, in this paper, we identify a new Denial-of-Service attack never addressed in the literature, called \emph{false-incrimination attack}, by which  provides false sub-proofs to the innocent storage node so that the innocent storage node will be regarded as the compromised one and be revoked. Unfortunately, all the prior works \cite{sl08,szz09,zsz09} suffer from this attack. In summary, with minor modifications involved, our proposed SRQ, STQ, and SSQ schemes are resilient against both the collusion attack and false-incrimination attack.

It should be especially noted that, in the following discussion of SRQ, we temporarily make two unrealistic assumptions that the compromised nodes can only disobey the procedures of the proposed schemes\footnote{In other words, compromised nodes are assumed to \emph{not} inject bogus sensor readings. They can only manipulate its own subproof and the proofs sent from its descendant sensor nodes.} and the (subtree) proofs (defined later) will not be manipulated by the compromised storage and sensor nodes, in order to emphasize on the effectiveness of our proposed technique in identifying compromised nodes. Nevertheless, these two assumptions will be relaxed later.

\textbf{Impact of Sensor Node Compromise on SRQ and STQ.} Under the above two assumptions, the SRQ scheme is inherently resilient against collusion attack, because, regardless of the existence and position of , the proper bucket keys will be embedded into the proofs and cannot be removed by . Nevertheless, SRQ could be vulnerable to the false-incrimination attack since false sub-proofs injected by  will be integrated with the other correct sub-proofs to construct a false proof, leading to the revocation of innocent . Here, we present a novel technique called \emph{subtree sampling} enabling SRQ, with a slight modification, to efficiently mitigate the threat of false-incrimination attacks. The idea of \emph{subtree sampling} is to check if the proof constructed by the nodes in a random subtree with fixed depth is authentic so as to perform the attestation only on the remaining suspicious nodes. Let  be a user-selected constant indicating the subtree depth. In the modified SRQ scheme, once receiving , , , from its  children, , each  calculates , , , and  as in the original SRQ scheme. Note that, if  is a leaf node on the aggregation tree, it is assumed that  receives . In the modified SRQ scheme, however,  additionally performs the following operations. Assume that , , , , and .  calculates  and , .  also calculates  and , where  and  are computed in a way stated in Sec. \ref{sec: Securing Range Queries (SRQ)}. Then,  and  are assigned to set , . If , where  is a pre-determined threshold known by each node and will be analyzed later, then  sends  to (possibly compromised) . Let  be a subtree of the underlying aggregation tree, rooted at  with depth .  generated by  can be thought of as the \emph{subtree proof} of the data sensed by the nodes in . Finally,  sends  to its parent node. Let  be the \emph{witness set} of sensor nodes satisfying  at epoch . The nodes in  are called \emph{witness nodes} at epoch .

\begin{figure}[h]
\centering
\subfloat[]{\label{fig: diagram goodcase}\includegraphics[width=0.25\textwidth]{goodcase}}
\subfloat[]{\label{fig: diagram badcase}\includegraphics[width=0.25\textwidth]{badcase}}
\caption{\scriptsize The conceptual diagrams of identifying the compromised nodes. (a) Only the nodes in red area need to be attested. (b) Only the nodes in gray area need to be attested.} \label{fig: diagram}
\end{figure}

We first consider the simplest case, where no compromised nodes act as the witness nodes. We further assume that only one compromised node (\emph{i.e.}, ) injects false sub-proof for simplicity and our method can be adapted to the case of multiple compromised nodes injecting false sub-proofs. We have the following observation regarding each witness node  and its generated . Assume that the query-result is found to be incomplete at epoch . The authority requests  for each witness node  stored in . To identify the compromised nodes, all the nodes at first are considered neutral. The nodes in  become innocent if the verification of  passes, and the nodes in  become suspicious otherwise\footnote{Note that there would be the cases that a node is deemed to be both innocent and suspicious when different subtree proofs are considered. When such a case happens, that node obviously should be innocent.}. The above verification is performed as follows. According to the  in the subtree proof , the authority knows which nodes in the subtree  contribute data and their amount. The authority can, based on this information, calculate  by itself. Define  as the set of data sensed by the nodes in , and  as the corresponding bucket IDs of . As a consequence, the verification passes if and only if the  calculated by the authority itself is equal to the  extracted from the received received , and the amount of the data in  falling into the specified buckets in  matches the one indicated in . As a whole, each time the above checking procedures are performed according to  at epoch , nodes will be partitioned into three sets, innocent set , neutral set, and suspicious set  containing innocent nodes, neutral nodes, and suspicious nodes, respectively. We can conclude that  contains at least one compromised node injecting the false subproof if at least one  is nonempty and  contains at least one compromised node injecting the false subproof otherwise. In more details, the authority at first only performs the attestation \cite{slpdk06,smkk05,spdk04} on the nodes in  or in . Nonetheless, after the attestation, if the nodes being attested are ensured to be not compromised, then  should be the compromised node. It can be observed that the size of the set of the nodes the authority needs to perform the attestation has possibility of being drastically shrunk so that the computation and communication cost required in the attestation will be substantially reduced as well. It can also be observed that each time the attestation is performed, at least one compromised node can be recovered. The intuition behind the checking procedure can be illustrated in Fig. \ref{fig: diagram}. In addition, Fig. \ref{fig: number of nodes to be attested} depicts the number of nodes to be attested after an incomplete reply is found in different settings. Since the number of witness nodes is approximately , it can be observed from Fig. \ref{fig: number of nodes to be attested} that the larger the  and , the lower the number of nodes to be attested. Nevertheless, when  and  become larger, the communication cost of the modified SRQ scheme, which will be presented later, is increased as well.

There, however, would still be the cases where the compromised nodes luckily act as witness nodes so that they can be considered innocent by sending genuine subtree proof to . In our consideration, this case does happen, but our technique also successfully mitigates the threat of false-incrimination attacks because the effectiveness of false-incrimination attacks is now limited within the case where some compromised nodes work as witness nodes.

\begin{figure}[h]
\centering
\subfloat[]{\label{fig: number of nodes to be attested N500}\includegraphics[width=0.26\textwidth]{attestnodesN500}}
\subfloat[]{\label{fig: number of nodes to be attested N1000}\includegraphics[width=0.26\textwidth]{attestnodesN1000}}
\caption{\scriptsize The number of nodes to be attested for (a)  and (b) .} \label{fig: number of nodes to be attested}
\end{figure}

Now, we have to remove the two unrealistic assumptions we made before, allowing that the bogus data can be injected and the subtree proof sent from the witness node has possibility to be maliciously altered on its way to the authority. After the removal of these two unrealistic assumptions, SRQ is still resilient against collusion attacks because the use of the proofs guarantees that the misbehavior of deleting the sensed data will be detected. Unfortunately, on the one hand, the compromised nodes injecting the bogus data can deceive the authority into accepting the falsified sensor reading. On the other hand, the compromised nodes lying on the path between  and witness nodes can manipulate the subtree proofs so that the compromised nodes can avoid the detection and the innocent  can still be falsely incriminated. In our strategy, we use the \emph{redundancy property}, which have been widely used in the design of the other security protocols in WSNs such as en-route filtering \cite{yg06,yl09,yllz04,zsjn04}, to mitigate the former threat, while we, motivated by the IP traceback technique in internet security literature, develop a new traceback technique suitable for WSNs to resist against the latter attack. Here, the redundancy property means that usually WSNs are densely deployed so that an event in the sensing region can be simultaneously detected by multiple nodes. In general, the redundancy property can be obtained by achieving the so-called -coverage \cite{ht05,mkps01,wxzlpg03} and therefore, an event can be simultaneously observed by at least  nodes. In the following description of our remedy to these problems, due to its similarity to our modified SRQ scheme previously mentioned, we will omit some notational details, stressing on the procedures itself.

When the redundancy property is used, in essence, our SRQ does not need to be changed. Assume for now that, the authority issues a range query and receives the query-result from . In addition, we also assume that all the checking procedures stated in (modified) SRQ are passed. The authority now wants to know whether the received data are falsified by and sent from the compromised nodes. Recall that each node can be aware of its geographic position. After knowing which nodes contribute the sensed data to its issued query from the query-result, the authority further acquires the encrypted data of the neighbors of those nodes from . Note that this can be achieved because when geographic positions of all nodes are known by the authority\footnote{As long as each node knows its position, it sends in a multihop manner its position to the authority with the MAC constructed by the key uniquely shared with the authority. This kind of operations are only performed once after the sensor deployment.}, inferring the one-hop neighbors of a specific node can be easily achieved. Finally, for each node in the query-result, the authority checks the consistency of its sensor reading and the sensor readings of its one-hop neighbors. The sensed data will be rejected as long as it is inconsistent with the sensor readings of its neighbors. The consistency checking procedure here may allow for certain measurement errors or environmental factors, which should be domain-specific and user-defined. 

Now, we turn to address another problem that the subtree proofs transmitted from the witness node to the authority could be maliciously altered by the compromised (storage or sensor) nodes. To deal with this kind of threat, we need a mechanism, by which the receiver not only can know whether the received message is modified by the intermediate nodes, but also can point out the node modifying the message if it does exist. Motivated by the IP traceback techniques, we develop a \emph{recursive traceback} mechanism. To be more specifically, each node  on the path connecting the  and the witness node, after receiving , where  denotes the subtree proof, from its descendant node, attaches  to  and then forwards  to its ascendant node on the underlying aggregation tree. Note that it is assumed that the witness node receives . Thus, with this modification, a subtree proof received by the authority should be accompanied with  hashes, where  is the number of nodes (including storage nodes and the witness node itself) between a specific witness node and the authority. Here, we should note that because the topology of the aggregation tree is known by the authority, when the subtree proof is sent, the IDs of intermediate nodes except for the ID of the witness node itself do not need to be attached\footnote{The path from any sensor node in the aggregation tree to  is unique. The authority can infer the nodes the subtree proof traverses once it is aware of the ID of the witness node.}. Hence, when the query-result is deemed incomplete, before conducting the procedures defined in the subtree sampling technique to attest nodes, the authority checks whether the received subtree proof is maliciously altered by the intermediate node. In particular, assume that the subtree proof and its  associated hashes, , where , , is the hash calculated by the node that is -hop away from the witness node and  is computed by the witness node itself according to its asserted subtree proof, are received by the authority. After the reception of , the authority checks the consistency of the hash backward; \emph{i.e.}, it first checks , and then , and so on. If such a verification can be successfully proceeded all  hashes, then the subtree proof  is considered to be intact. Otherwise, once the verification fails in, say, , we can conclude that the subtree proof was altered by the corresponding node since the innocent node is not assumed to behave in such a way.

Recall that the communication cost of original SRQ is . In the modified SRQ \emph{without those two unrealistic assumptions}, each node  at epoch  is required to additionally send , leading to  communication cost. At epoch , approximately  witness nodes will send their subtree proofs to . Nevertheless, when the subtree proofs are sent to , since the additional hashes will be added, its communication cost will be . As a result, the communication cost becomes .

Basically, STQ can be regarded as a special use of SRQ. Thus, its resiliency against false-incrimination attack is the same as that of SRQ. Nevertheless, due to the nature of top- query, the injection of the falsified sensor reading from the compromised nodes will imply a significant query-result deviation. Nevertheless, due to the use of the redundancy property in resisting against false data injection, STQ is resilient against the collusion attacks and false-incrimination attacks even when the compromised nodes can inject bogus data and can manipulate the proofs. Finally, because of its similarity to the SRQ scheme, STQ has the communication overhead the same as SRQ's.  

\textbf{Impact of Sensor Node Compromise on SSQ.} Recall that two aforementioned unrealistic assumptions are made. We first consider the resiliency against false-incrimination attacks. The simplest method is to introduce a parameter  so that  reports to the authority all the verification seeds, instead of the hash of them in original SSQ. After that, for each group, if at least  out of  verification seeds can be successfully verified, then the quasi-skyline data in that group are considered complete. Hence, the threat of false-incrimination attacks will be mitigated because the adversary is forced to send at least  false proofs, instead of single one false proof. With even one verification seed from a specific group failed to be verified, we can conclude that at least one compromised sensor node exists in that group.

Now, we consider collusion attacks. In SSQ, both  and sensor nodes only know the quasi-skyline data. Recall that quasi-skyline data are not necessarily the skyline data. Thus, even when there is more than one compromised sensor node in a group, the probability of successfully dropping the skyline data is actually small. More specifically, to drop the skyline data at a specified epoch,  should contain at least  sensor nodes responsible for sending hash values in order to successfully forge a proof of incomplete quasi-skyline data, and at the same time should be fortunate enough to select groups whose quasi-skyline data contain skyline data\footnote{Definitely,  can simply drop all the sensed data. Nevertheless, under this option, it is forced to forge at least  proofs ( in our analysis), leading to high probability of being detected.}.

Now, we consider both the collusion and false-incrimination attacks. To drop the skyline data, the only thing  can do is to drop the data of certain groups. Here, for simplicity, we consider the case where  drops the data of a fixed group , , in which a set  of  sensor nodes is compromised. To prevent the detection of incomplete query-result,  out of  compromised sensor nodes should be the sensor nodes responsible for sending the proofs. The probability that at least  out of  nodes responsible for sending the proofs are contained in  is . In other words, this is equal to the probability that the compromised sensor nodes can drop the quasi-skyline data without being detected.  Quasi-skyline data, however, are not necessarily equivalent to the skyline data. The probability that the quasi-skyline data dropped by compromised nodes indeed contain skyline data can be represented as , where  is the average ratio of the skyline data to all the sensed data. In short, this is equal to the probability that the operations performed by compromised nodes cause the loss of skyline data. As a whole, even if the adversary has  compromised nodes in , the probability of successfully making skyline query-result incomplete is merely . The trends of such a probability are depicted in Fig. \ref{fig: SSQimpact} under different parameter settings. As shown in Fig. \ref{fig: SSQimpactNY},  is decreased with an increase of  and . This is because when  and  become larger, it is more unlikely that the quasi-skyline data dropped by the adversary contains the skyline data. Nevertheless, as shown in Fig. \ref{fig: SSQimpactxi1xi3},  is increased with an increase of . This is because when  becomes larger, it is more likely that  can forge a proof of an incomplete quasi-skyline data. As a whole, from the false-incrimination attack point of view, the larger the , the lower the , but from the collusion attack point of view, the smaller the , the lower the . This would be an optimization problem that deserves further studying. In addition, compared with original SSQ, the additional communication cost incurred from the modified SSQ comes from the transmission of verification seeds from  to the authority. Thus, the communication cost of the modified SSQ scheme remains .

\begin{figure}[h]
\centering
\subfloat[]{\label{fig: SSQimpactNY}\includegraphics[width=0.26\textwidth]{SSQimpactNY}}
\subfloat[]{\label{fig: SSQimpactxi1xi3}\includegraphics[width=0.26\textwidth]{SSQimpactxi1xi3}}
\caption{\scriptsize The probability of successfully dropping skyline data in the cases that (a)  and , and (b)  and .} \label{fig: SSQimpact}
\end{figure}

Now, the two unrealistic assumptions will be relaxed so that the compromised nodes can provide falsified sensor readings and contaminate the proofs. The same as the top- query, skyline query is vulnerable to the falsified data. That is, a compromised node injecting an falsified extreme sensor reading can gain the effect of deleting all the data sensed by the other sensor nodes. Thus, the redundancy property is sill required to be applied on our SSQ scheme so as to detect the false data injection. Because the use of the redundancy property in SSQ is also similar to its use in SRQ, we omit the detailed description as well. In addition, the adversary may compromise the sensor nodes near the innocent  so that it can falsify all the verification seeds. Therefore, our recursive traceback mechanism is also required to be applied on SSQ to secure the verification seeds. Because of these two additional changes in SSQ, the communication cost becomes .

\section{Conclusion}\label{sec: Conclusion}
We propose schemes for securing range query, top- query, and skyline query, respectively. Two critical performance metrics, detection probability and communication cost, are analyzed. In particular, the performance of SRQ is superior to all the prior works, while STQ and SSQ act as the first proposals for securing top- query and skyline query, respectively, in tiered sensor networks. We also investigate the security impact of collusion attacks and newly identified false-information attacks, and explore the resiliency of the proposed schemes against these two attacks.
\begin{thebibliography}{1}
\bibitem{cp05}
H. Chan and A. Perrig. PIKE: Peer Intermediaries for Key Establishment in Sensor Networks. in \emph{Proceeding of IEEE Conference on Computer Communications (INFOCOM)}, 2005.

\bibitem{cp08}
H. Chan and A. Perrig. Efficient Security Primitives from a Secure Aggregation Algorithm. in \emph{Proceeding of ACM Conference on Computer and Communications Security (CCS)}, 2008.

\bibitem{cps03}
H. Chan, A. Perrig, and D. Song. Random Key Predistribution Schemes for sensor networks. in \emph{Proceeding of IEEE Symposium on Security and Privacy (S\&P)}, 2003.

\bibitem{cps06}
H. Chan, A. Perrig, and D. Song. Secure Hierarchical In-Network Aggregation in Sensor Networks. in \emph{Proceeding of ACM Conference on Computer and Communications Security (CCS)}, 2006.

\bibitem{czg07}
H. Chen, S. Zhou, and J. Guan. Towards Energy-Efficient Skyline Monitoring in Wireless Sensor Networks. in \emph{Proceeding of European Conference on Wireless Sensor Networks (EWSN)}, 2007.

\bibitem{dglls05}
P. Desnoyers, D. Ganesan, H. Li, M. Li, and P. Shenoy. PRESTO: A Predictive Storage Architecture for Sensor Networks. in \emph{Proceeding of Workshop on Hot Topics in Operating Systems (HotOS)}, 05.

\bibitem{eg02}
L. Eschenauer and V. Gligor. A Key-management Scheme for Distributed sensor networks. in \emph{Proceeding of ACM Conference on Computer and Communications Security (CCS)}, 2002.

\bibitem{hilm02}
H. Hacigumus, B. R. Iyer, C. Li, and S. Mehrotra, Executing SQL over encrypted data in the database service provider model. in \emph{Proceeding of ACM International Conference on Management of Data (SIGMOD)}, 2002.

\bibitem{hmt04}
B. Hore, S. Mehrotra, and G. Tsudik, A privacy-preserving index for range queries. in \emph{Proceeding of International Conference on Very Large Data Bases (VLDB)}, 2004.

\bibitem{ht05}
C. -F. Huang and Y. -C. Tseng, The Coverage Problem in a Wireless Sensor Network. \emph{ACM Mobile Networks and Applications (MONET)}, vol. 10, no. 4, pp. 519-528, 2005.

\bibitem{lcy08}
W. Liang, B. Chen, J. Yu. Energy-efficient skyline query processing and maintenance in sensor networks. in \emph{Proceeding of ACM Conference on Information and Knowledge Management (CIKM)}, 2008.

\bibitem{lkgh03}
X. Li, Y. Kim, R. Govindan, and W. Hong. Multi-dimensional range queries in sensor networks. in Proc. \emph{Proceeding of ACM Conference on Embedded Networked Sensor Systems (SenSys)}, 2003.

\bibitem{ln04}
D. Liu, P. Ning. Multi-level TESLA: broadcast authentication for distributed sensor networks. \emph{ACM Transactions in Embedded Computing Systems (TECS)}, vol. 3, no. 4, pp. 800-836, 2004.

\bibitem{lnd05}
D. Liu, P. Ning, and W. Du. Attack-resistant location estimation in sensor networks. in \emph{Proceeding of ACM/IEEE International Conference on Information Processing in Sensor Networks (IPSN)}, 2005.

\bibitem{mdgs06}
G. Mathur, P. Desnoyers, D. Ganesan, and P. Shenoy. Ultra-low power data storage for sensor networks. in \emph{Proceeding of ACM/IEEE International Conference on Information Processing in Sensor Networks (IPSN)}, 2006.

\bibitem{mfhh02}
S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong. TAG: a Tiny AGgregation Service for Ad-Hoc Sensor Networks. in \emph{Proceeding of USENIX Symposium on Operating Systems Design and Implementation (OSDI)}, 2002.

\bibitem{mfhh05}
S. R. Madden, M. J. Franklin, J. M. Hellerstein, and W. Hong. TinyDB: An Acquisitional Query Processing System for Sensor Networks. \emph{ACM Transactions on Database Systems (TODS)}, vol. 30, no. 1, pp. 122-173, Mar. 2005.

\bibitem{mkps01}
S. Meguerdichian, F. Koushanfar, M. Potkonjak, and M. B. Srivastava. Coverage Problems in Wireless Ad-hoc Sensor Networks. in \emph{Proceeding of IEEE Conference on Computer Communications (INFOCOM)}, 2001.

\bibitem{pswct01}
A. Perrig, R. Szewczyk, V. Wen, D. Culler, and J. D. Tygar. SPINS: Security Protocols for Sensor Networks. in \emph{Proceeding of ACM International Conference on Mobile Computing and Networking (Mobicom)}, 2001.

\bibitem{rbb03}
P. Rogaway, M. Bellare, and J. Black. OCB: A Block-Cipher Mode of Operation for Efficient Authenticated Encryption. \emph{ACM Transactions on Information and System Security (TISSEC)}, vol. 6, no. 3, pp. 365-403, 2003.

\bibitem{RISE}
RISE project. Available: \verb"http://www.cs.ucr.edu/~rise/"

\bibitem{rksegyy03}
S. Ratnasamy, B. Karp, S. Shenker, D. Estrin, R. Govindan, L. Yin, and F. Yu. Data-centric storage in sensornets with GHT, a geographic hash table. \emph{Mobile Networks and Applications}, vol. 8, no. 4, pp. 427-442, 2003.

\bibitem{sl08}
B. Sheng and Q. Li. Verifiable privacy-preserving range query in two-tiered sensor networks. in \emph{Proceeding of IEEE Conference on Computer Communications (INFOCOM)}, 2008.

\bibitem{slm06}
B. Sheng, Q. Li and W. Mao. Data storage placement in sensor networks. in \emph{Proceeding of ACM International Symposium on Mobile Ad Hoc Networking and Computing (MobiHoc)}, 2006.

\bibitem{slpdk06}
A. Seshadri, M. Luk, A. Perrig, L. V. Doorn, and P. Khosla. SCUBA: Secure Code Update By Attestation in Sensor Networks. in \emph{Proceeding of ACM Workshop on Wireless Security (WiSe)}, 2006.

\bibitem{smkk05}
M. Shaneck, K. Mahadevan, V. Kher, and Y. Kim. Remote Software-based Attestation for Wireless Sensors. in \emph{Proceeding of European Workshop on Security and Privacy in Ad-hoc and Sensor Networks (ESAS)}, 2005

\bibitem{snwlz06}
K. Sun, P. Ning, C. Wang, A. Liu, and Y. Zhou. TinySeRSync: Secure and Resilient Time Synchronization in Wireless Sensor Networks. in \emph{Proceeding of ACM Conference on Computer and Communications Security (CCS)}, 2006.

\bibitem{spdk04}
A. Seshadri, A. Perrig, L. V. Doorn, and P. Khosla. SWATT: SoftWare-based ATTestation for Embedded Devices. in \emph{Proceeding of IEEE Symposium on Security and Privacy (S\&P)}, 2004.

\bibitem{startgate}
Stargate gateway (SPB400). Available: \verb"http://www.xbow.com"

\bibitem{stlm07}
B. Sheng, C. C. Tan, Q. Li, and W. Mao. An Approximation Algorithm for Data Storage Placement in Sensor Networks. in \emph{Proceeding of WASA}, 2007.

\bibitem{szz09}
J. Shi, R. Zhang  and Y. Zhang. Secure range queries in tiered sensor networks. in \emph{Proceeding of IEEE Conference on Computer Communications (INFOCOM)}, 2009.

\bibitem{wxzlpg03}
X. Wang, G. Xing, Y. Zhang, C. Lu, R. Pless, and C. Gill. Integrated Coverage and Connectivity Configuration in Wireless Sensor Networks. in Proc. \emph{Proceeding of ACM Conference on Embedded Networked Sensor Systems (SenSys)}, 2003.

\bibitem{wxtl07}
M. Wu, J. Xu, X. Tang, W.-C. Lee. Top-k Monitoring in Wireless Sensor Networks. \emph{IEEE Transactions on Knowledge and Data Engineering (TKDE)}, vol. 19, no. 6, pp. 962-976, 2007.

\bibitem{yg06}
Z. Yu and Y. Guan. A Dynamic En-route Scheme for Filtering False Data Injection in Wireless Sensor Networks. in \emph{Proceeding of IEEE Conference on Computer Communications (INFOCOM)}, 2006.

\bibitem{yl09}
L. Yu and J. Li. Grouping-based Resilient Statistical En-route Filtering for Sensor Networks. in \emph{Proceeding of IEEE Conference on Computer Communications (INFOCOM)}, 2009.

\bibitem{ylk09}
C.-M. Yu, C.-S. Lu, and S.-Y. Kuo. A simple non-interactive pairwise key establishment scheme in sensor networks. in \emph{Proceeding of IEEE Conference on Sensor, Mesh and Ad Hoc Communications and Networks (SECON)}, 2009.

\bibitem{yllz04}
F. Ye, H. Luo, S. Lu, and L. Zhang. Statistical En-route Filtering of Injected False Data in Sensor Networks. in \emph{Proceeding of IEEE Conference on Computer Communications (INFOCOM)}, 2004.

\bibitem{zlfw06}
Y. Zhang, W. Liu, Y. Fang, and D. Wu. Secure localization and authentication in ultra-wideband sensor networks. in \emph{IEEE Journal on Selected Areas in Communications, Special Issue on UWB Wireless Comms. - Theory and Applications}, vol. 24, no. 4, pp. 829-835, 2006.

\bibitem{zsjn04}
S. Zhu, S. Setia, S. Jajodia, and P. Ning. An Interleaved Hop-by-Hop Authentication Scheme for Filtering False Data in Sensor Networks. in \emph{Proceeding of IEEE Symposium on Security and Privacy (S\&P)}, 2004.

\bibitem{zsz09}
R. Zhang, J. Shi, and Y. Zhang. Secure multidimensional range queries in sensor networks. in \emph{Proceeding of ACM International Symposium on Mobile Ad Hoc Networking and Computing (MobiHoc)}, 2009.

\end{thebibliography}
\end{document}
