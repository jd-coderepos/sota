\documentclass{llncs}

\newenvironment{proofofclaim}{\noindent {\em Proof.}}{\hfill  \medbreak}

\newcommand{\local}{{\cal LOCAL}}
\newcommand{\inp}{\mbox{\rm\bf x}}
\newcommand{\certif}{\mbox{\rm\bf y}}
\newcommand{\id}{\mbox{\rm Id}}
\newcommand{\LD}{\mbox{\rm LD}}
\newcommand{\NLD}{\mbox{\rm NLD}}
\newcommand{\coloring}{\mbox{\tt Coloring}}
\newcommand{\mis}{\mbox{\tt MIS}}
\newcommand{\up}{\mbox{\bf N}}

\def\cF{{\cal F}}
\def\cL{{\cal L}}


\begin{document}


\title{On the Impact of Identifiers on Local Decision\thanks{This work is supported by the \emph{Jules Verne}  Franco-Icelandic bilateral scientific framework.}}

\date{}

\author{
Pierre Fraigniaud\inst{1}\thanks{
E-mail: {\tt \{pierre.fraigniaud,amos.korman\}@liafa.univ-paris-diderot.fr}.
Additional support from  ANR project DISPLEXITY, and INRIA project GANG.}
\and Magn\'us M. Halld\'orsson\inst{2}\thanks{
Supported by Iceland Research Foundation grant-of-excellence 90032021.
E-mail: {\tt mmh@ru.is}.}
\and Amos Korman
}

\institute{
CNRS and University Paris Diderot, France. 
\medbreak
\and
ICE-TCS, School of Computer Science, Reykjavik University, Iceland.  \\
}

\maketitle


\begin{abstract}
The issue of identifiers is crucial in distributed
computing. Informally, 
identities are used for tackling two of the fundamental difficulties that are
inherent to deterministic
distributed computing, namely: (1) {\em symmetry
  breaking}, and (2) {\em topological information gathering}. In the
context of \emph{local computation}, i.e., when nodes can gather
information only from nodes at bounded distances, some insight
regarding the role of identities has been established. For instance,
it was shown that, for large classes of \emph{construction} problems,
the role of the identities can be rather small. However, for the
identities to play no role, some other kinds of mechanisms for
breaking symmetry must be employed, 
such as 
edge-labeling or sense
of direction. When it comes to local distributed \emph{decision}
problems, the specification of the decision task does not seem to
involve symmetry breaking. Therefore, it is expected that, assuming
nodes can gather sufficient information about their neighborhood, one
could get rid of the identities, without employing extra mechanisms
for breaking symmetry. We tackle this question in the framework of the
 model.

Let  be the class of all problems that can be \emph{decided} in a constant number of rounds in the  model. Similarly, let   be the class of all problems that can be decided at constant cost in the anonymous variant of the  model, in which nodes have no identities, but each node can get access to the (anonymous) ball of radius  around it, for any , at a cost of . It is clear that . We conjecture that . In this paper, we give several evidences supporting this conjecture. In particular, we show that it holds for \emph{hereditary} problems, as well as when the
nodes know an arbitrary upper bound on the total number of nodes.  Moreover, we prove that the conjecture holds in the context of \emph{non-deterministic} local decision, where nodes are given certificates (independent of the identities, if they exist), and the decision consists in verifying these certificates. In short, we prove that . 

\medskip

\noindent{\bf Keywords:} Distributed complexity; locality; identities; decision problems; symmetry breaking;  non-determinism.

\end{abstract}



\section{Introduction}


\subsection{Background and Motivation}

The issue of identifiers is crucial in distributed computing~\cite{A80,NS93}. Indeed, the  correct operation of deterministic protocols often relies on the assumption that each processor  comes with with a unique \emph{identity}, ~\cite{GHS}. Informally, in network computing, such an identity assignment is crucial for tackling two of the fundamental difficulties that are inherent to  distributed computing, namely: (1) {\em symmetry breaking}, and  (2)  {\em topological information gathering}. 

The use of identities for tackling the above two difficulties is illustrated well in the context of \emph{local} algorithms \cite{L92,L86}. Indeed, in the  model \cite{PelB00}, an algorithm that runs in  communication rounds, assuming an identity assignment, can be viewed as composed of two parts: first, collecting at each node , the ball  of radius  around it (together with the inputs of nodes), and second, deciding the output at    based solely on the information in . To achieve these two tasks, one should first obtain the ball , which may not be possible if the underlying graph is anonymous (i.e., without identities). Moreover, even if obtaining the ball is possible, e.g., if the structure of the graph allows it, the absence of unique identities  given to the nodes may prevent the algorithm from breaking symmetry. For example, in the absence of unique identities, it is impossible to design a distributed deterministic coloring algorithm, even for the symmetric connected graph composed of two nodes only.  In fact, to the best of our knowledge, all algorithms in the  model are designed assuming the presence of pairwise distinct identities or some other type of node-labeling or edge-labeling, including, e.g., sense of direction~\cite{BM09,HKP01,K09,LPR09,NS93,PS96}. 

The seminal paper of Naor and Stockmeyer \cite{NS93} provides an important insight regarding the role of identities in local computation. Informally, they show that, even though identities are necessary,  in many cases the actual values of identities is not crucial, and only their relative order matters. Specifically,  \cite{NS93} shows that for a particular class of problems, called LCL (for \emph{Locally Checkable Languages}), if there exists a local algorithm that, for any identity assignment, constructs an instance of a problem in LCL in constant number of rounds,  then there exists an \emph{order invariant}\footnote{Essentially, an order invariant algorithm uses the actual values of the identities only to impose an ordering between the nodes, that is, it behaves the same for any two identity assignments that preserve the total order between the nodes. For more details refer to \cite{NS93}.} algorithm  for that problem that  runs in the same number of rounds. LCL restricts its concern to graphs with constant maximum degree, and to problems with a constant number of inputs. The assumption on the size of the inputs of problems in LCL was shown necessary in \cite{HHRS12}, by exhibiting a natural problem that is locally checkable, has unbounded input size,  can be solved in 1 round with identities, but cannot be solved in constant time by any order invariant algorithm. The role of identities can also be gauged by comparing their impact to that of ``orientation mechanisms''.  For instance, G\"o\"os et al.~\cite{GHS12} have shown that for a large class of optimization problems, called PO-checkable problems, local algorithms do not benefit from any kind of identifiers: if a PO-checkable optimization problem can be approximated with a local algorithm, the same approximation factor can be achieved in anonymous networks if the network is provided with a port-numbering and an orientation.  

The discussion above involved distributed
\emph{construction} tasks, including, e.g., graph
coloring~\cite{BM09,K09,L92,NS93,PS96}, maximal independent
set~\cite{L92,PS96}, and maximal matching~\cite{HKP01,LPR09}. 
When it
comes to distributed \emph{decision} tasks~\cite{FKP11,FKPP12},
symmetry breaking issues do not however seem to play a
role. Informally, a decision task requires the nodes to ``collectively
decide'' whether the given instance (i.e., a graph with inputs to the
nodes) satisfies some specific properties. For instance, deciding
coloring requires, given a colored graph, to check whether this graph
is properly colored. The meaning of ``collectively decide'' is as
follows. On a legal instance, all nodes should output ``yes'', and on
an illegal one, at least one node should output ``no''. Note that it
is not really important whether this node is unique or not; hence, this
specification does not inherently require any symmetry
breaking. Therefore, assuming that each node  can obtain the ball
, it makes sense that the assumption of having an identity
assignment may not be crucial for achieving correct decision.

\subsection{Model and Objectives}

We tackle the question of whether identities play a role in decision problems in the framework of the aforementioned  model~\cite{PelB00}, which is a standard distributed computing model capturing the essence of locality. Recall that, in this model, processors are nodes of a connected network , have pairwise distinct identities, and have inputs. More formally, a {\em configuration} is a triplet  where  is a connected graph, every node  is assigned as its {\em local input} a binary string , and  denotes the identity of node . (In some problems, the local input of every node is empty, i.e.,  for every , where  denotes the empty binary string). Processors are woken up simultaneously, and computation proceeds over the input configuration  in fault-free synchronous \emph{rounds} during which every processor exchanges messages of unlimited size with its neighbors in the underlying network , and performs arbitrary individual computations on its data. In many cases, the running time of an algorithm is measured with respect to the size  of : the running time of an algorithm is defined as the maximum number of rounds it takes to terminate at all nodes, over all possible -node networks. Similarly to \cite{HHRS12,NS93}, we consider algorithms whose running time is independent of the size of the network, that is they run in constant time. 

Let  be the ball centered at , of radius , excluding the edges between two nodes at distance exactly  from . As mentioned before, without loss of generality, any algorithm running in time~ in the  model consists of:
\begin{enumerate}
\item  Collecting (in  rounds) at every node  the structure of the ball   together with all the inputs  and identities  of these nodes, and,
\item Performing some individual computation at every node. 
\end{enumerate}
We define the \emph{anonymous}   model similarly to the  model, except that nodes have no identities. More precisely, an input configuration in the anonymous  model is just a pair . An algorithm running in time~ in the anonymous  model consists of:
\begin{enumerate}
\item Getting at every node  a snapshot of the structure of the ball  together with all the inputs of the nodes in this ball, and,
\item Performing some individual computation at every node. 
\end{enumerate}
Note that the \emph{anonymous}  model does not explicitly involve communications between nodes. Instead, it implicitly assumes that the underlying network supports the snapshot operation.
Clearly, this model is not stronger than the   model, and possibly even strictly weaker, since a node  can no longer base its individual computation on the identities of the nodes in the ball . One can think of various other ``anonymous'' models, i.e., which do not involve node identities. In particular, there is a large literature on distributed computing in networks without node identities, where symmetry breaking is enabled thanks to locally disjoint port numbers (see, e.g., \cite{FP11}). We consider the anonymous  model to isolate the role of node identities from other symmetry breaking mechanisms.\footnote{In some sense, the anonymous  model is the strongest model among all models without node identities. Indeed, there are network problems that can be solved in the  anonymous  model  which cannot be solved in the aforementioned model that is based on locally disjoint port numbers. A simple example is to locally detect the absence of a 3-node cycle.} Our aim is to compare the power of the anonymous  model with the standard  model in order to capture the impact of identities on local distributed decision. 

Recall from~\cite{FKP11} that a {\em distributed language} is a decidable collection  of configurations. (Since an undecidable collection of configurations remains undecidable in the distributed setting too, we consider only decidable collections of configurations). A typical example of a language is 

where  denotes the (open) neighborhood of , that is, all nodes at distance exactly~1 from . Still following the terminology from~\cite{FKP11}, we say that a distributed algorithm  \emph{decides} a distributed language  if and only if for every configuration , every node of  eventually terminates and outputs ``yes'' or ``no'', satisfying the following decision rules: 
\begin{itemize}
\item 
if , then each node outputs ``yes'';
\item 
if , then at least one node outputs ``no''.
\end{itemize}
In the (non-anonymous)  model, these two rules must be satisfied for every identity assignment. That is, all processes must output ``yes'' on a legal instance, independent of their identities. And, on an illegal instance, at least one node must output ``no'', for every identity assignment. Note that this node may potentially differ according to the identity assignment. Some languages can be decided in constant time  (e.g., ), while others can easily be shown not to be decidable in constant time (e.g., ``is  the network planar?''). In contrast to the above examples, there are some languages whose status is unclear. To elaborate on this, consider the particular case where it is required to decide whether the network belongs to some specified family  of graphs. If this question can be decided in a constant number of communication rounds, then this means, informally, that the family  can somehow be characterized by relatively simple conditions. For example, a family  of graphs that can be characterized as consisting of all graphs having no subgraph from , where  is some specified finite set of graphs, is obviously decidable in constant time. However, the question of whether a family of graphs can be characterized as above is often non-trivial. For example, characterizing cographs as precisely the graphs with no induced , attributed to Seinsche~\cite{Seinsche74}, is not easy, and requires nontrivial usage of modular decomposition.

We are now ready to define one of our main subjects of interest, the classes  and . Specifically,  (for \emph{local decision}) is the class of all distributed languages that can be decided by a  distributed algorithm that runs in a constant number of  rounds in the  model~\cite{FKP11}. Similarly, , the anonymous version of , is the class of all distributed languages that can be decided by a  distributed algorithm that runs in a constant number of rounds in the anonymous  model. By definition, . We conjecture that  In this paper, we provide several evidences supporting this conjecture. In addition, we investigate the \emph{non-deterministic} version of these classes, and prove that they coincide. More specifically, a distributed {\em verification} algorithm is a distributed algorithm  that gets as input, in addition to a configuration , a global {\em certificate vector} , i.e., every node  of a graph  gets as input two binary strings, an input  and a certificate . A verification algorithm  verifies  if and only if for every input configuration , the following hold: 
\begin{itemize}
\item if , then there exists a certificate  such that every node outputs ``yes''; 
\item if , then for every certificate , at least one node outputs ``no''.
\end{itemize}
Again, in the (non-anonymous)  model, these two rules must be satisfied for every identity assignment, but the certificates must be the same regardless of the identities.
We now recall the class , for \emph{non-deterministic local decision}, as defined in \cite{FKP11}: it is the class of all distributed languages that can be verified in a constant number of rounds in the  model. Similarly, we define , the anonymous version of , as the class of all distributed languages that can be verified in a constant number of rounds in the anonymous  model. By definition, . 

\subsection{Our Results}


In this paper, we give several evidences supporting the conjecture . In particular, we show that it holds for languages defined on paths, with a finite set of input values. More generally, we show that the conjecture holds for \emph{hereditary} languages, that is, languages closed under node deletion. Regarding arbitrary languages, and arbitrary graphs, we prove that the conjecture holds assuming that every node knows an  upper bound on the total number of nodes in the input graph. (This upper bound can be arbitrary, and may not be the same for all nodes). 

Moreover, we prove that equality between non-anonymous decision and anonymous decision holds in the context of \emph{non-deterministic} local decision, where nodes are given certificates (independent of the identities, if they exist), and the decision consists in verifying these certificates. More precisely, we prove that . This latter result is obtained by characterizing both  and . 

\subsection{Related Work}
The question of how to locally decide (or verify)  languages has 
received quite a lot of attention recently. 
Inspired by classical computation complexity theory,
it was suggested in \cite{FKP11} that the study of decision problems may lead to new
structural insights also in the more complex distributed computing setting.
Indeed, following that paper, which focused on the  model, efforts were made to form a fundamental
computational complexity theory for distributed decision problems in
various other aspects of distributed computing
\cite{FKP11,FP12,FRT11,FRT12}.

The classes LD, NLD and BPLD defined in \cite{FKP11} are
the distributed analogues of the classes  P, NP and BPP, respectively.
The paper provides structural results,
developing a notion of local reduction and establishing completeness results.
One of the main results is the existence of a sharp threshold for randomization,
above which randomization does not help (at least for hereditary languages). 
More precisely, the BPLD classes were classified into two:
below and above the randomization threshold. 
In \cite{FKPP12}, the authors show that the hereditary assumption can be lifted if we restrict our attention
to languages on path topologies. 
These two results from \cite{FKP11,FKPP12}  are used in the current paper in a rather surprising manner. 
The authors in \cite{FKPP12} then 
``zoom''
into the spectrum of classes below the randomization threshold, and
defines a hierarchy of an infinite set of BPLD classes, each of which
is separated from the class above it in the hierarchy.


The precise knowledge of the number of nodes  was shown in  \cite{FKP11} to be of large impact on non-deterministic decision. Indeed, with such a knowledge
every language can be decided non-deterministically in the model of NLD. We note, however, that the knowledge of an arbitrary upper bound on  (as assumed here in one of our results) seems to be a much weaker assumption, and, in particular, will not suffice for non-deterministically deciding all languages. In the context of construction problems, it was shown in \cite{KSV11} that in many case, the knowledge of  (or an upper bound on ) is not essential.


The original theoretical basis for non-determinism in local
computation was laid by the theory of \emph{proof-labeling schemes} (PLS)~\cite{GS11,KK07,KKM11,KKP10} 
originally defined in \cite{KKP10}. As mentioned, 
this notion resembles the notion of NLD, but differs in the role identities play. Specifically, in PLS the designer of the algorithm may base the certificates'
(called labels in the terminology of PLS) construction on the given identity assignment. In contrast, in the model of NLD, the certificates must be the same regardless of the identities of nodes.
Indeed, this difference is significant: while every language can be verified by a proof labeling scheme, not every language belongs to NLD~\cite{FKP11}. These notions also bear some similarities to the notions of \emph{local computation with advice} \cite{DP12,FGIP07,FIP10,FKL07}, 
{\em local detection}~\cite{AKY97},
{\em local checking}~\cite{APV}, or {\em silent stabilization}~\cite{silent}.
In addition, as shown later on, the notion of NLD is related also to the theory of
{\em lifts} or {\em covers}~\cite{A80,Linial01}.

Finally, the classification of decision problems in distributed
computing has been studied in several other models. For example,
\cite{DHKKNPPW} and \cite{KKP11} study specific decision problems in
the  model. In \cite{KKM11}, the authors study MST verification in the PLS sense but under the   model of communication. 
In addition, decision problems have been studied in the asynchrony discipline
too, specifically in the framework of {\em wait-free computation}
\cite{FRT11,FRT12} and {\em mobile agents  computing} \cite{FP12}.
In the wait-free model, the main issues are not spatial constraints but timing
constraints (asynchronism and faults). The main focus of  \cite{FRT12} is
deterministic protocols aiming at studying the power of the ``decoder'',
i.e., the interpretation of the results. While this paper essentially
considers the AND-checker (since a global ``yes'' corresponds to all processes
saying ``yes''), \cite{FRT12} deals with other interpretations,
including more values (not only ``yes'' and ``no''), with the objective of
designing checkers that use the smallest number of values.

\section{Deterministic Decision}
\label{sec:dd}


We conjecture that . A support to this conjecture is that it holds for a large class of languages, namely for all \emph{hereditary} languages, that is languages closed under node deletion. For instance,  and  are hereditary, as well as all languages corresponding to hereditary graph families, such as planar graphs, interval graphs, forests, chordal graphs, cographs, perfect graphs, etc. 

\begin{theorem}\label{theo:LDhereditary}
 for hereditary languages. 
\end{theorem}

To prove the theorem, it is sufficient to show that  for hereditary languages. This immediately follows from the statement and proof of Theorem~3.3 in~\cite{FKP11}. Indeed, let  be a non-anonymous local algorithm deciding . This deterministic algorithm is in particular a randomized algorithm, with success probabilities  for legal instances, and  for illegal instance. That is, algorithm  is a -decider for , according to the  definition in~\cite{FKP11}. Since  is hereditary, and since , the existence of  implies the existence of a specific deterministic anonymous local algorithm  for . Indeed, the algorithm  described in the proof of Theorem~3.3 in~\cite{FKP11}  is in fact anonymous: it simply collects the ball  of radius  around each node  for some constant~, and  then decides ``yes'' or ``no'' according to whether  or not, regardless of the identities. 

A similar proof, based on Theorem~4.1 in~\cite{FKPP12}, enables to establish the following: 

\begin{theorem}\label{theo:LDpath}
 for languages defined on the set of paths, with a finite set of input values. 
\end{theorem}

Another evidence supporting the conjecture  is that it holds assuming that nodes have access to a seemingly weak oracle. Specifically, this oracle, denoted , simply provides each node with an arbitrarily large upper bound on the total number of nodes in the actual instance. 
(It is not assumed that all the upper bounds provided to nodes are the same). We denote by  the class of languages that can be decided by an anonymous local algorithm having access to oracle , and we prove the following: 

\begin{theorem}\label{theo:LD=LD}
.
\end{theorem}

\begin{proof}
We just need to prove that . Let , and let  be a local (non-anonymous) algorithm deciding . Assume that the running time of  is . We transform  into an anonymous algorithm  deciding  in time ,  assuming each node  in a given input  has an access to the oracle , i.e., it knows an arbitrary upper bound  on the number of nodes in . 
Algorithm  works as follows. Each node  collects the ball  of radius  around it. Then, for every possible assignment of identities to the nodes of   taken from the range , node  simulates the behavior of the non-anonymous algorithm  on the ball  with the corresponding identities. If, in one of these simulations, algorithm  decides ``no'', then  decides ``no''. Otherwise,  decides ``yes''. 

We now prove the correctness of . If the input , then  accepts it for every identity assignment to the nodes of . Therefore, since, for every node , every possible identity assignment to the nodes of the ball  can be extended to an  identity assignment to all the nodes of , all the simulations of  by  return ``yes'', and hence  accepts  as well. On the other hand, if   then  rejects it for every identity assignment to the nodes of . That is, for every identity assignment to the nodes of , at least one node  decides ``no''. (Note that, this node  may be different for two different identity assignments). Let us fix one identity assignment  to the nodes of , in the range , and let  be one node that decides ``no'' for . Let \id be the ball  with the identities of the nodes given by . In , since  tries all possible identity assignments of the ball  in the range  with , in one of its simulations of , node  will simulate  on \id. In this simulation, node  decides ``no'', and hence algorithm  rejects  as well. 
\qed
\end{proof}

Note that the inclusion  holds when one imposes no restrictions on the individual sequential running time. However, the transformation of a (non-anonymous) local algorithm into an anonymous local algorithm as described in the proof of Theorem~\ref{theo:LD=LD} is very expensive in terms of individual computation. Indeed, the number of simulations of the original local algorithm  by each node  can be as large as  where  is the upper bound on  given by the oracle , and  is the number of nodes in the ball . This bound can be exponential in  even if the oracle provides a good approximation of  (even if it gives precisely ). It would be nice to establish  by using a transformation not involving a huge increase in the individual sequential computation time. 

\section{Non-deterministic Decision}
\label{sec:ndd}


In the previous section, we have seen several evidences supporting the conjecture that , but whether it holds or not remains to be proved. In this section, we turn our attention to the non-deterministic variants of these two classes, and show that they coincide. More formally, we have:  

\begin{theorem}\label{theo:NLD=NLD}
.
\end{theorem}

\begin{proof}
To prove , it is sufficient to prove . To establish this inclusion, we provide a sufficient condition for -membership, and prove that it is a necessary condition for  -membership. 

Let  and  be two input instances. A \emph{homomorphism} from  to  is a function  that preserves the edges of  as well as the inputs to the nodes. Specifically, 
 
and  maps every node  to a node  satisfying  For instance, assuming the nodes have no inputs, and labeling the nodes of the -node cycle  by consecutive integers from 0 to , modulo~, then the map  defined by  is a homomorphism. The trivial map  defined by , where  is the 2-node clique, is also a homomorphism. To establish conditions for - and -membership, we require the involved homomorphisms to preserve the local neighborhood of a node, and define the notion of \emph{-local isomorphism}.  

Let  be a positive integer. We say that  is -local isomorphic to  if and only if there exists an homomorphism  from  to  such that,  for every node ,  restricted to  is an isomorphism from   to . We call such a homomorphism  a -local isomorphism. 

Note that a homomorphism is not necessarily a 1-local isomorphism. For instance, the aforementioned map  defined by  is a 1-local isomorphism, but the map  defined by  is not a 1-local isomorphism. 
To be a 1-local isomorphism, a homomorphism should also insure isomorphism between the balls of radius~1. Also observe that any -local isomorphism  is onto (because if a node of  has no pre-image, then neither do its neighbors have a pre-image, since  homomorphisms preserve edges, and so forth). To avoid confusion, it is thus useful to keep in mind that, informally, a -local isomorphism goes from a ``larger'' graph to a ``smaller'' graph. 

\begin{definition}
\label{def:lift}
For positive integer , we say that  is \emph{-closed under lift }if, for every two instances  such that  is -local isomorphic to , we have: 
\end{definition}

So, informally, Defintion~\ref{def:lift} states that, for a language  to be -closed under lift, if a ``smaller''  instance  is in  then any ``larger'' instance  that is a lift of , i.e., satisfying that  is -local isomorphic to , must also be in . The following lemma gives a sufficient condition for -membership. 

\begin{lemma}\label{claim:sufficient} 
Let  be a language. If there exists  such that  is -closed under lift, then . 
\end{lemma} 

\begin{proofofclaim}
Let  be a language, and assume that there exists  such that  is -closed under lift. We describe an anonymous non-deterministic local algorithm  deciding ,  and performing in  rounds. The certificate of each node  is a triple  where  is an -node graph with nodes labeled by distinct integers in , , and  is an -dimensional vector.
Informally, the certificates are interpreted by  as follows. The graph  is supposed to be a ``map'' of , that is,  is interpreted as an isomorphic copy of . The integer  is the label of the node in  corresponding to node  in . Finally,  is interpreted as the input of the nodes in . 

The algorithm  performs as follows. Every node  gets , the ball of radius  around it; hence, in particular, it collects all the certificates of all the nodes at distance at most  from it. Then, by comparing its own certificate with the ones of its neighbors,  it checks that the graph , and the input  in its certificate, are identical to the ones in the certificates of its neighbors. It also verifies consistency between the labels and the nodes in its ball of radius . That is, it checks whether the labels and inputs in the certificate of the nodes in  are as described by its  certificate. Whenever a node fails to pass any of these tests, it outputs ``no''. Otherwise it output ``yes'' or ``no'' according to whether  or not, respectively. (This is doable because we are considering languages that are decidable in the usual sense of sequential computation). 

We show that  performs correctly. If , then by labeling the nodes in  by distinct integers from~1 to , and by providing the node  labeled  with , the algorithm  output ``yes'' at all nodes, as desired. Consider now a instance . Assume, for the purpose of contradiction that there exists a certificate  leading all nodes to output ``yes''. Let  be defined by  where  is the label of  in its certificate. Since  passes all tests of , it means that (1)  where the instance  is the same for all nodes, (2)  restricted to  is an isomorphism from   to , for every node , and (3)  . In view of (2),  is -local isomorphic to . Therefore, (3) implies that , because  is -closed under lift. This is in contradiction with the actual hypothesis .  Thus, for each certificate , there must exist at least one node that outputs ``no''.  As a consequence,  is a non-deterministic algorithm deciding , and thus .
\end{proofofclaim}

The following lemma shows that the aforementioned sufficient condition for -membership is a necessary condition for -membership. 

\begin{lemma}\label{claim:necessary} 
Let  be a language. If , then there exists  such that  is -closed under lift. 
\end{lemma} 

\begin{proofofclaim}
Let  be a language in , and let  be a non-deterministic (non-anonymous) local algorithm deciding . Assume, for the purpose of contradiction that, for any integer ,  is \emph{not} -closed under lift. That is, for any , there exist two input instances  such that  is -local isomorphic to , with  and . Assume that  runs in  rounds. Without loss of generality, we can assume that .  Let  and  satisfying  is -local isomorphic to . Since , there exists a certificate  such that when  is running on  with certificate , every node output ``yes'' for every identity assignment. Since   is -local isomorphic to , there exists an homomorphism  such that, for every node ,  restricted to  is an isomorphism from   to . Let  be the certificate for  defined by . Consider the execution of  running on  with certificate , and some arbitrary  identity assignment~. 

Since  performs in  rounds, the decision at each node  is taken according to the inputs, certificates, and identities in the ball , as well as the structure of this ball. By the nature of the homomorphism , and by the definition of certificate , the structure, inputs and certificates of the ball , are identical to  the corresponding structure, inputs and certificates of the ball . Balls may however differ in the identities of their nodes. So,  let  be the node in  deciding ``no'' for  with certificate . There exists such a node since . Let , and assign  the same identities to the nodes in   as their corresponding nodes in . Arbitrarily extend this identities to an identity assignment  to  the whole graph . By doing so, the two balls are not only isomorphic, but every node in  has the same input, certificate and identity as its image in . Therefore, the decision taken by  at  under  is the same as its decision at  under . This is in contradiction to the fact that   decides ``no'' while  decides ``yes''.  
\end{proofofclaim}

Lemmas~\ref{claim:sufficient} and~\ref{claim:necessary}~together establish the theorem. 
\qed
\end{proof}

The proof of Lemma~\ref{claim:sufficient} also provides an upper bound on the size of the certificates for \emph{graph languages} in , that is, for languages in  with no input. (This includes, e.g., recognition of interval graphs, and recognition of chordal graphs). Indeed, given , Algorithm~ in the proof of Lemma~\ref{claim:sufficient} verifies  using a certificate at each node which is essentially an isomorphic copy of the input instance , with nodes labeled by consecutive integers in . If  is a graph language, then there is no input , and thus the size of the certificates depends only on the size of the graph. More precisely, we have:  

\begin{corollary}\label{cor:mlogn}
Let  be a graph language. There exists an algorithm verifying  using certificates of size   bits at each node of every -node graph in . 
\end{corollary}

We now argue that the above bound is tight, that is, we prove the following.

\begin{proposition}
 There exists a graph language  such that every algorithm verifying  requires certificates of size  bits.
\end{proposition}
\begin{proof}

Recall that  \cite{KKP10} showed that there exists a graph language for which every proof labeling scheme (PLS) requires labels of size  bits (the proof of this latter result appears in a detailed version \cite{KKP10b}). 
Still in the context of PLS, \cite{GS11} showed that this lower bound holds for  two {\em natural} graph families: specifically, \cite{GS11}  showed that verifying symmetric graphs requires labels of size  bits, and verifying   non-3 colorable graphs requires almost the same size of labels, specifically,  bits. Note that  the certificate size required for verifying a language  in  is at least as large as the minimum label size required for verifying the language via a proof labeling scheme. 
Unfortunately, however, one cannot obtain our claim directly from the aforementioned results since it turns out that neither of the two graph languages (namely, symmetric graphs and non-3 colorable graphs) belongs to .

We therefore employ an indirect approach.
Specifically, consider a graph . We say that  is a {\em seed} of  if there exists a 1-local isomorphism from  to .
Suppose  is a family of graphs. Let \textsf{Seed-} denote the family of graphs , for which there exists a seed of   that belongs to . 
Then, by definition, \textsf{Seed-} is  -closed under lift.  Indeed, assume that there is a 1-local isomorphism   from  to , and let  be a seed of  that belongs to . Then let  be the 1-local isomorphism  from  to . We have that  is a 1-local isomorphism  from  to , because, for every ,  is isomorphic to , which in turn is isomorphic to . Thus  is also a seed of .  \textsf{Seed-} is therefore in . Now, in the proof of corollary 2.2 in  \cite{KKP10b}, the authors construct, for every integer  , a family   of -node graphs that requires proof labels of size . Note that  for every prime integer , a graph  of size  belongs to   if and only if it belongs to 
\textsf{Seed-}.  Therefore, there exists a graph language, namely,   \textsf{Seed-}, that requires  certificates of size  bits (at least for prime 's).
\qed
\end{proof}

\section{Conclusion}


Again, in this paper, we provide some evidences supporting the conjecture . For instance, Theorem~\ref{theo:LD=LD} shows that if every node knows any upper bound on the number of nodes , then all languages in  can be decided in the anonymous  model. One interesting remark about the  model is that it is guaranteed that at least one node has an upper bound on . This is for instance the case of the node with the largest identity. In the anonymous  model, however, there is no such guarantee. Finding a language whose decision would be based on the fact that one node has an upper bound on  would disprove the conjecture  . Nevertheless, it is not clear whether such a problem exists. 

In this paper, we also prove that , that is, our conjecture holds for the non-deterministic setting. It is worth noticing that \cite{FKP11} proved that there exists an -complete problem under the local one-to-many reduction. It is not clear whether such a problem exists for . Indeed, the reduction in the completeness proof of \cite{FKP11} relies on the aforementioned guarantee that, in the  model,  at least one node has an upper bound on . 

\begin{thebibliography}{99}

\bibitem{AKY97}
Y.~Afek, S.~Kutten, and M.~Yung.
\newblock The local detection paradigm and its applications to self
  stabilization.
\newblock \emph{Theoretical Computer Science}, 186(1-2):199--230, 1997.

\bibitem{A80}
D. Angluin.
\newblock Local and Global Properties in Networks of Processors.
\newblock In \emph{Proc. Twelfth ACM Symp. on Theory of Computing (STOC)}, 
82--93, 1980. 

\bibitem{Linial01}
A. Amit, N. Linial, J. Matousek, and E. Rozenman.
\newblock Random lifts of graphs.
\newblock  In \emph{Proc. 12th ACM-SIAM Symp. on Discrete Algorithms (SODA)},  883--894, 2001.

\bibitem{APV}
B.~Awerbuch, B.~Patt-Shamir, and G.~Varghese.
\newblock Self-Stabilization By Local Checking and Correction.
\newblock In \emph{ Proc. IEEE Symp. on the Foundations of Computer
Science (FOCS)}, 1991, 268--277.

\bibitem{BM09}
L. Barenboim and M. Elkin.
\newblock Distributed -coloring in linear (in delta) time.
\newblock In \emph{Proc. 41st ACM Symp. on Theory of computing (STOC)}, 111--120,
2009.

\bibitem{DHKKNPPW}
A. Das Sarma, S. Holzer,  L. Kor, A.  Korman, D. Nanongkai, G. Pandurangan,
D. Peleg and R. Wattenhofer.
\newblock Distributed Verification and Hardness of Distributed Approximation.
\newblock In \emph{Proc. 43rd ACM Symp. on Theory of Computing (STOC)}, 2011.

\bibitem{DP12}
D.~Dereniowski and A.~Pelc.
\newblock Drawing maps with advice.
\newblock \emph{Journal of Parallel and Distributed Computing},72:132-143, 2012.

\bibitem{silent}
S.~Dolev, M.~Gouda, and M.~Schneider.
\newblock Requirements for silent stabilization.
\newblock \emph{Acta Informatica}, 36(6), 447--462, 1999.


\bibitem{GHS}
R.G. Gallager, P.A. Humblet, P.M. Spira.
\newblock A distributed algorithm for minimum-weight
spanning trees.
\newblock \emph{ACM Trans. on Programming Languages and Systems}, 5 (1983) 66--77.

\bibitem{FGIP07}
P. Fraigniaud, C. Gavoille, D. Ilcinkas and A. Pelc.
\newblock Distributed Computing with Advice: Information Sensitivity
of Graph Coloring.
\newblock  In \emph{Proc. 34th Colloq. on Automata, Languages and
Programming (ICALP)}, 231--242, 2007.

\bibitem{FIP10}
P.~Fraigniaud, D.~Ilcinkas, and A.~Pelc.
\newblock Communication algorithms with advice.
\newblock \emph{J. Comput. Syst. Sci.}, 76(3-4):222--232, 2008.

\bibitem{FKL07}
P.~Fraigniaud, A.~Korman, and E.~Lebhar.
\newblock Local MST computation with short advice.
\newblock In \emph{Proc. 19th ACM Symp. on Parallelism in Algorithms
and Architectures (SPAA)}, 154--160, 2007.

\bibitem{FKP11}
P. Fraigniaud, A. Korman, and D. Peleg.
\newblock Local Distributed Decision.
\newblock In \emph{Proc. 52nd Annual IEEE Symposium
on Foundations of Computer Science (FOCS)}, 708--717, 2011.

\bibitem{FKPP12}
P. Fraigniaud, A. Korman, M. Parter and D. Peleg.
\newblock Randomized Distributed Decision.
\newblock  http://arxiv.org/abs/1207.0252

\bibitem{FP12}
P. Fraigniaud and A. Pelc.
\newblock Decidability Classes for Mobile Agents Computing.
\newblock In {Proc. LATIN 2012: Theoretical Informatics - 10th Latin American Symposium}, 2012.

\bibitem{FRT11}
P. Fraigniaud, S. Rajsbaum, and C. Travers.
\newblock Locality and  Checkability  in Wait-free Computing.
\newblock In \emph{Proc. 25th International Symposium on Distributed Computing (DISC)}, 2011.

\bibitem{FRT12}
P. Fraigniaud, S. Rajsbaum, and C. Travers.
\newblock Universal Distributed Checkers and Orientation-Detection Tasks.
\newblock Submitted, 2012.

\bibitem{FP11}
E. Fusco and A. Pelc. 
\newblock Communication complexity of consensus in anonymous message passing systems. 
\newblock In \emph{Proc. 15th International Conference on Principles of Distributed Systems (OPODIS 2011)}, LNCS 7109, 191--206.

\bibitem{GS11}
M. G\"o\"os and J. Suomela.
\newblock Locally checkable proofs.
\newblock \emph{Proc. 30th ACM Symp. on Principles of Distributed Computing (PODC)}, 2011.

\bibitem{GHS12}
M. G\"o\"os, J. Hirvonen, and J. Suomela.
\newblock Lower bounds for local approximation. 
\newblock In \emph{Proc. 31st Symposium on Principles of Distributed Computing (PODC)}, 2012.

\bibitem{HHRS12}
H. Hasemann, J. Hirvonen, J. Rybicki, and J. Suomela. 
\newblock Deterministic Local Algorithms, Unique Identifiers, and Fractional Graph Colouring.
\newblock In \emph{Proc. 19th International Colloquium on Structural Information and Communication Complexity (SIROCCO)}, 2012.

\bibitem{HKP01}
M. Hanckowiak, M. Karonski, and A. Panconesi.
\newblock  On the Distributed Complexity of Computing Maximal Matchings.
\newblock \emph{SIAM J. Discrete Math.} 15(1): 41--57 (2001).

\bibitem{KKP11}
L. Kor, A. Korman and D. Peleg.
\newblock  Tight Bounds For Distributed MST Verification.
\newblock In \emph{Proc. 28th Int. Symp. on Theoretical Aspects of
Computer Science (STACS)}, 2011.

\bibitem{KK07}
A.~Korman and S.~Kutten.
\newblock Distributed verification of minimum spanning trees.
\newblock \emph{Distributed Computing}, 20:253--266, 2007.

\bibitem{KKM11}
A.~Korman,  S.~Kutten, and T. Masuzawa.
\newblock Fast and Compact Self-Stabilizing  Verification, Computation, and Fault Detection of an MST.
\newblock In \emph{Proc. 30th ACM Symp. on Principles of Distributed Computing (PODC)}, 2011.

\bibitem{KKP10}
A.~Korman, S.~Kutten, and D.~Peleg.
\newblock Proof labeling schemes.
\newblock \emph{Distributed Computing}, 22:215--233, 2010.

\bibitem{KKP10b}
A.~Korman, S.~Kutten, and D.~Peleg.
\newblock Proof labeling schemes.
\newblock Detailed version. See: http://ie.technion.ac.il/~kutten/ps-links/ProofLabelingSchemes.ps

\bibitem{KSV11}
A.~Korman, J.S.~Sereni, and L.~Viennot.
\newblock
Toward More Localized Local Algorithms: Removing Assumptions Concerning Global Knowledge.
\newblock In \emph{Proc. 30th ACM Symp. on Principles of Distributed Computing (PODC)}, 49--58, 2011.

\bibitem{K09}
F. Kuhn.
\newblock Weak graph colorings: distributed algorithms and applications.
\newblock In \emph{Proc. 21st ACM Symp. on Parallel Algorithms and Architectures
(SPAA)}, 138--144, 2009.

\bibitem{L92}
N. Linial.
\newblock Locality in distributed graph algorithms.
\newblock \emph{SIAM J.  Comput.}, 21(1):193--201, 1992.

\bibitem{LPR09}
Z. Lotker, B. Patt-Shamir and A. Rosen.
\newblock Distributed Approximate Matching.
\newblock \emph{SIAM J. Comput.} 39(2): 445--460, (2009).

\bibitem{L86}
M. Luby.
\newblock A simple parallel algorithm for the maximal independent set problem.
\newblock \emph{SIAM J.  Comput.}, 15:1036--1053, 1986.

\bibitem{NS93}
M.~Naor and L.~Stockmeyer.
\newblock What can be computed locally?
\newblock \emph{SIAM J. Comput.} 24(6): 1259--1277 (1995).

\bibitem{PS96}
A. Panconesi and A. Srinivasan.
On the Complexity of Distributed Network Decomposition.
\newblock \emph{J. Algorithms} 20(2): 356--374, (1996).

\bibitem{PelB00}
D. Peleg.
\newblock \emph{Distributed Computing: A Locality-Sensitive Approach}.
\newblock SIAM, 2000.

\bibitem{Seinsche74}
D. Seinsche.
\newblock On a property of the class of -colorable graphs.
\newblock \emph{J. Combinatorial Theory}, Ser. B, 16,  pages 191--193, 1974.

\end{thebibliography}

\end{document}
