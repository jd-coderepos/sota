\documentclass{article}

\pdfoutput=1

\usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{amssymb,amsmath,amsthm}
\usepackage{algorithm,algorithmic}
\usepackage{graphicx}
\usepackage{natbib}
\usepackage{fullpage}
\usepackage{tikz} 
\usepackage{pgfplots}
\usetikzlibrary{arrows.meta}

\renewcommand{\Pr}{\field{P}}

\DeclareMathOperator{\Tr}{Tr}
\newcommand{\bA}{\boldsymbol{A}}
\newcommand{\ba}{\boldsymbol{a}}
\newcommand{\bx}{\boldsymbol{x}}
\newcommand{\bxi}{\boldsymbol{\xi}}
\newcommand{\bc}{\boldsymbol{c}}
\newcommand{\bC}{\boldsymbol{C}}
\newcommand{\bd}{\boldsymbol{d}}
\newcommand{\bX}{\boldsymbol{X}}
\newcommand{\bM}{\boldsymbol{M}}
\newcommand{\bone}{\boldsymbol{1}}
\newcommand{\bI}{\boldsymbol{I}}
\newcommand{\bu}{\boldsymbol{u}}
\newcommand{\bb}{\boldsymbol{b}}
\newcommand{\by}{\boldsymbol{y}}
\newcommand{\bY}{\boldsymbol{Y}}
\newcommand{\sY}{\mathcal{Y}}
\newcommand{\bhatY}{\boldsymbol{\hat{Y}}}
\newcommand{\bbary}{\boldsymbol{\bar{y}}}
\newcommand{\bg}{\boldsymbol{g}}
\newcommand{\bz}{\boldsymbol{z}}
\newcommand{\bZ}{\boldsymbol{Z}}
\newcommand{\bbarZ}{\boldsymbol{\bar{Z}}}
\newcommand{\bbarz}{\boldsymbol{\bar{z}}}
\newcommand{\bhatZ}{\boldsymbol{\hat{Z}}}
\newcommand{\bhatz}{\boldsymbol{\hat{z}}}
\newcommand{\bhatx}{\boldsymbol{\hat{x}}}
\newcommand{\haty}{\hat{y}}
\newcommand{\barz}{\bar{z}}
\newcommand{\bS}{\boldsymbol{S}}
\newcommand{\bbarS}{\boldsymbol{\bar{S}}}
\newcommand{\bw}{\boldsymbol{w}}
\newcommand{\bhatw}{\hat{\boldsymbol{w}}}
\newcommand{\bW}{\boldsymbol{W}}
\newcommand{\bU}{\boldsymbol{U}}
\newcommand{\bv}{\boldsymbol{v}}
\newcommand{\bzero}{\boldsymbol{0}}
\newcommand{\balpha}{\boldsymbol{\alpha}}
\newcommand{\sA}{\mathcal{A}}
\newcommand{\sC}{\mathcal{C}}
\newcommand{\sX}{\mathcal{X}}
\newcommand{\sS}{\mathcal{S}}
\newcommand{\sZ}{\mathcal{Z}}
\newcommand{\sbarZ}{\bar{\mathcal{Z}}}
\newcommand{\fbag}{\bold{F}}


\DeclareMathOperator*{\Exp}{\mathbf{E}}
\DeclareMathOperator{\Regret}{Regret}
\DeclareMathOperator{\Wealth}{Wealth}
\DeclareMathOperator{\Reward}{Reward}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}
\newcommand{\fixme}[1]{\textcolor{red}{FIXME: #1}}

\newcommand{\field}[1]{\mathbb{#1}}
\newcommand{\fY}{\field{Y}}
\newcommand{\fX}{\field{X}}
\newcommand{\fH}{\field{H}}

\newcommand{\R}{\field{R}}
\newcommand{\Nat}{\field{N}}
\newcommand{\E}{\field{E}}
\newcommand{\Var}{\mathrm{Var}}

\renewcommand{\H}{\mathcal{H}}  \newcommand{\norm}[1]{\left\|{#1}\right\|}
\newcommand{\indicator}{\mathbf{1}}
\DeclareMathOperator*{\dom}{dom}


\newcommand{\btheta}{\boldsymbol{\theta}}
\newcommand{\bbartheta}{\boldsymbol{\bar{\theta}}}
\newcommand\theset[2]{ \left\{ {#1} \,:\, {#2} \right\} }
\newcommand\inn[2]{ \left\langle {#1} \,,\, {#2} \right\rangle }
\newcommand\RE[2]{ D\left({#1} \| {#2}\right) }
\newcommand\Ind[1]{ \left\{{#1}\right\} }
\newcommand{\diag}[1]{\mbox{\rm diag}\!\left\{{#1}\right\}}

\newcommand{\defeq}{\stackrel{\rm def}{=}}
\newcommand{\sgn}{\mbox{\sc sgn}}
\newcommand{\scI}{\mathcal{I}}
\newcommand{\scO}{\mathcal{O}}

\newcommand{\dt}{\displaystyle}
\renewcommand{\ss}{\subseteq}
\newcommand{\wh}{\widehat}
\newcommand{\ve}{\varepsilon}
\newcommand{\hlambda}{\wh{\lambda}}
\newcommand{\yhat}{\wh{y}}

\newcommand{\hDelta}{\wh{\Delta}}
\newcommand{\hdelta}{\wh{\delta}}
\newcommand{\spin}{\{-1,+1\}}



\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{cor}{Corollary}


\newcommand{\reals}{\mathbb{R}}


\newcommand{\bbeta}{{\boldsymbol{\beta}}}
\newcommand{\bgamma}{{\boldsymbol{\gamma}}}
\newcommand{\tp}{^{\top}}
\newcommand{\ip}[1]{\left\langle #1 \right\rangle}
\newcommand{\ME}[1]{\mathbb{E}_{#1}}
\newcommand{\Sloo}{S^{\backslash i}}
\newcommand{\loo}{_{\Sloo}}
\newcommand{\fhtlold}{f^{htl}_{S}}
\newcommand{\fhtl}{f^{htl'}_{S}}
\newcommand{\fhtlloo}{f^{htl'}\loo}
\newcommand{\fh}{\hat{f}}
\newcommand{\dm}[1]{\text{dim }\left(#1\right)}

\newtheorem{alg}{Algorithm}


\newcommand{\alert}[1]{\footnote{\color{red}! NOTE: #1 \textexclamdown\par}}


\newcommand{\KL}[2]{\operatorname{D}\left({#1}\middle\|{#2}\right)}  

\DeclareMathOperator{\Risk}{Risk} 
\title{Training Deep Networks without Learning Rates\\Through Coin Betting}



\author{
  Francesco Orabona\thanks{The authors contributed equally.} \\
  Department of Computer Science\\
  Stony Brook University, NY, USA\\
  \texttt{francesco@orabona.com}
  \and
  Tatiana Tommasi\footnotemark[1] \\
  Department of Computer, Control, and Management Engineering Antonio Ruberti\\
  Sapienza University of Rome, Italy \\
  \texttt{tommasi@dis.uniroma1.it}
}

\begin{document}

\maketitle

\begin{abstract}
Deep learning methods achieve state-of-the-art performance in many application scenarios. 
Yet, these methods require a significant amount of hyperparameters tuning in order to achieve 
the best results. In particular, tuning the learning rates in the stochastic optimization 
process is still one of the main bottlenecks.
In this paper, we propose a new stochastic gradient descent procedure for deep networks that 
does not require any learning rate setting. Contrary to previous methods, we do not adapt the 
learning rates nor we make use of the assumed curvature of the objective function. Instead, 
we reduce the optimization process to a game of betting on a coin and propose a learning-rate-free
optimal algorithm for this scenario.
Theoretical convergence is proven for convex and quasi-convex functions and empirical evidence shows 
the advantage of our algorithm over popular stochastic gradient algorithms.
 \end{abstract}

\section{Introduction}

In the last years deep learning has demonstrated a great success in a large number of fields
and has attracted the attention of various research communities with the consequent development
of multiple coding frameworks (e.g., Caffe~\citep{jia2014caffe}, TensorFlow~\citep{tensorflow2015-whitepaper}), 
the diffusion of blogs, online tutorials, books, and dedicated courses. Besides reaching out scientists
with different backgrounds, the need of all these supportive tools originates also from the nature 
of deep learning:~it is a methodology that involves many structural details as well as several hyperparameters
whose importance has been growing with the recent trend of designing deeper and multi-branches networks. Some of the hyperparameters define the model itself (e.g., number of hidden layers, regularization coefficients, kernel size for convolutional layers), while others are related 
to the model training procedure.
In both cases, hyperparameter tuning is a critical step to realize deep learning 
full potential and most of the knowledge in this area comes from living practice, years 
of experimentation, and, to some extent, mathematical justification~\citep{BookBengio2012}. 

With respect to the optimization process, stochastic gradient descent (SGD) has proved itself to be 
a key component of the deep learning success, but its effectiveness strictly depends on the choice of
the initial learning rate and learning rate schedule. This has primed a line of research on algorithms
to reduce the hyperparameter dependence in SGD---see Section~\ref{sec:rel} for an overview on the related literature. However,
all previous algorithms resort on adapting the learning rates, rather than removing them, or rely on assumptions on the shape of the objective function.

In this paper we aim at removing at least one of the hyperparameter of deep learning models. We leverage over recent advancements in the stochastic optimization literature to design 
a backpropagation procedure that does not have a learning rate at all, yet it is as simple as the vanilla SGD.
Specifically, we reduce the SGD problem to the game of betting on a coin (Section~\ref{sec:coin}). 
In Section~\ref{sec:cocob}, we present a novel strategy to bet on a coin that extends previous ones in a data-dependent way, 
proving optimal convergence rate in the convex and quasi-convex setting (defined in Section~\ref{sec:def}). 
Furthermore, we propose a variant of our algorithm for deep networks (Section~\ref{sec:backprop}). 
Finally, we show how our algorithm outperforms popular optimization methods in the deep learning 
literature on a variety of architectures and benchmarks (Section~\ref{sec:exp}).

 \section{Related Work}
\label{sec:rel}

Stochastic gradient descent offers several challenges in terms of convergence speed.
Hence, the topic of learning rate setting has been largely investigated.

Some of the existing solutions are based on the use of carefully tuned momentum terms~\citep{LeCunBOM98,SutskeverMDH13,KingmaB15}.
It has been demonstrated that these terms can speed-up the convergence for convex smooth functions~\citep{Nesterov83}.
Other strategies propose scale-invariant learning rate updates to deal with gradients whose magnitude
changes in each layer of the network~\citep{DuchiHS11,TielemanH12,Zeiler12,KingmaB15}. Indeed, scale-invariance is a
well-known important feature that has also received attention outside of the deep learning community~\citep{RossML13,OrabonaCCB15,OrabonaP15}.
Yet, both these approaches do not avoid the use of a learning rate.

A large family of algorithms exploit a second order approximation of the cost function to better
capture its local geometry and avoid the manual choice of a learning rate. The step size is automatically
adapted to the cost function with larger/shorter steps in case of shallow/steep curvature.
Quasi-Newton methods~\citep{WrightN99} as well as the natural gradient method~\citep{Amari98} belong
to this family. Although effective in general, they have a spatial and computational complexity that is square
in the number of parameters with respect to the first order methods, which makes the application
of these approaches unfeasible in modern deep learning architectures. Hence, typically the required matrices are approximated with diagonal ones~\citep{LeCunBOM98,SchaulZLC13}. Nevertheless, even assuming
the use of the full information, it is currently unclear if the objective functions in deep learning have
enough curvature to guarantee any gain.

There exists a line of work on unconstrained stochastic gradient descent without learning rates~\citep{Streeter-McMahan-2012,Orabona-2013,McMahan-Orabona-2014,Orabona-2014,CutkoskyB16,CutkoskyB17}.
The latest advancement in this direction is the strategy of reducing stochastic subgradient descent to coin-betting, proposed by~\citet{OrabonaP16b}.
However, their proposed betting strategy is worst-case with respect to the gradients received and cannot
take advantage, for example, of sparse gradients.











 \section{Definitions}
\label{sec:def}

We now introduce the basic notions of convex analysis that are used in the paper---see, e.g., \citet{Bauschke-Combettes-2011}.
We denote by $\norm{\cdot}_1$ the $1$-norm in $\R^d$. Let $f: \R^d \to \R
\cup \{\pm\infty\}$, the \emph{Fenchel conjugate} of $f$ is $f^*:\R^d \to \R \cup \{\pm
\infty\}$ with $f^*(\btheta) = \sup_{\bx \in
\R^d} \ \btheta^\top \bx - f(\bx)$.


A vector $\bx$ is a \emph{subgradient} of a convex function $f$ at $\bv$ if $f(\bv) - f (\bu) \leq  (\bv - \bu)^\top \bx$ for any $\bu$ in the domain of $f$. The \emph{differential set} of $f$ at $\bv$, denoted by $\partial f(\bv)$, is the set of all the subgradients of $f$ at $\bv$. If $f$ is also differentiable at $\bv$, then $\partial f(\bv)$ contains a single vector, denoted by $\nabla f(\bv)$, which is the \emph{gradient} of $f$ at $\bv$.

We go beyond convexity using the definition of weak quasi-convexity in \citet{HardtMR16}. 
This definition is relevant for us because \citet{HardtMR16} proved that $\tau$-weakly-quasi-convex objective functions arise in the training of linear recurrent networks.
A function $f:\R^d\to \R$ is \emph{$\tau$-weakly-quasi-convex} over a domain $B \subseteq \R^d$ with respect to the global minimum $\bv^*$ if there is a positive constant $\tau > 0$
such that for all $\bv \in B$, $f(\bv)-f(\bv^*) \leq \tau (\bv -\bv^*)^\top \nabla f(\bv)$. From the definition, it follows that differentiable convex function are also $1$-weakly-quasi-convex.

\paragraph{Betting on a coin.}
We will reduce the stochastic subgradient descent procedure to betting on a number of coins. Hence, here we introduce the betting scenario and its notation. We consider a gambler making repeated bets on the
outcomes of adversarial coin flips. The gambler starts with initial
money $\epsilon > 0$. In each round $t$, he bets on the outcome of a coin
flip $g_t \in \{-1,1\}$, where $+1$ denotes heads and $-1$ denotes tails.  We
do not make any assumption on how $g_t$ is generated.

The gambler can bet any amount on either heads or tails. However, he is not
allowed to borrow any additional money. If he loses, he loses the betted
amount; if he wins, he gets the betted amount back and, in addition to that, he
gets the same amount as a reward.  We encode the gambler's bet in round $t$ by
a single number $w_t$. The sign of $w_t$ encodes whether he is betting on heads
or tails. The absolute value encodes the betted amount.  We define $\Wealth_t$
as the gambler's wealth at the end of round $t$ and $\Reward_t$ as the
gambler's net reward (the difference of wealth and the initial money), that is
\begin{align}
\label{equation:def_wealth_reward}
\Wealth_t = \epsilon + \sum_{i=1}^t w_i g_i &
& \text{and} &
& \Reward_t = \Wealth_t - \ \epsilon = \sum_{i=1}^t w_i g_i~.
\end{align}
In the following, we will also refer to a bet with $\beta_t$, where $\beta_t$
is such that
\begin{equation}
\label{equation:def_wt}
w_t = \beta_t \Wealth_{t-1}~.
\end{equation}
The absolute value of $\beta_t$ is the \emph{fraction} of the current wealth to
bet and its sign encodes whether he is betting on heads or tails. The
constraint that the gambler cannot borrow money implies that $\beta_t \in
[-1,1]$.
We also slighlty generalize the problem by allowing the outcome of the coin flip
$g_t$ to be any real number in $[-1,1]$, that is a \emph{continuous coin}; wealth and reward in~\eqref{equation:def_wealth_reward} remain the same.
 \section{Subgradient Descent through Coin Betting}
\label{sec:coin}

In this section, following \citet{OrabonaP16b}, we briefly explain how to reduce subgradient 
descent to the gambling scenario of betting on a coin.


Consider as an example the function $F(x):=|x-10|$ and the optimization problem  $\min_{x} \ F(x)$.
This function does not have any curvature, in fact it is not even differentiable, thus
no second order optimization algorithm could reliably be used on it.
We set the outcome of the coin flip $g_t$
to be equal to the negative subgradient of $F$ in $w_t$, that is $g_t \in \partial [-F(w_t)]$, where we remind that $w_t$ is the amount of money we bet. 
Given our choice of $F(x)$, its negative subgradients are in $\{-1,1\}$.
In the first iteration we do not bet, hence $w_1=0$ and our initial money is \$1. 
Let's also assume that there exists a function $H(\cdot)$ such that our betting strategy will 
guarantee that the wealth after $T$ rounds will be at least $H(\sum_{t=1}^T g_t)$ for any arbitrary sequence $g_1, \cdots, g_T$.

We claim that the average of the bets, $\tfrac{1}{T}\sum_{t=1}^T w_t$, converges to the solution of our 
optimization problem and the rate depends on how good our betting strategy is. Let's see how.

Denoting by $x^*$ the minimizer of $F(x)$, we have that the following holds 
\begin{align*}
F\left(\frac{1}{T} \sum_{t=1}^T w_t\right) - F(x^*) 
&\leq \frac{1}{T} \sum_{t=1}^T F(w_t) - F(x^*)
\leq \frac{1}{T}\sum_{t=1}^T g_t x^* -\frac{1}{T}\sum_{t=1}^T g_t w_t \\
&\leq \tfrac{1}{T}+\tfrac{1}{T}\left(\sum_{t=1}^T g_t x^*  - H\left(\sum_{t=1}^T g_t\right)\right)
\leq \tfrac{1}{T}+\tfrac{1}{T}\max_v \ v x^*  - H(v) \\
&= \tfrac{H^*(x^*)+1}{T},
\end{align*}
where in the first inequality we used Jensen's inequality, in the second the definition of subgradients, 
in the third our assumption on $H$, and in the last equality the definition of Fenchel conjugate of $H$.

In words, we used a gambling algorithm to find the minimizer of a non-smooth objective function by 
accessing its subgradients. All we need is a good gambling strategy. Note that this is just a very 
simple one-dimensional example, but the outlined approach works in any dimension and for any convex 
objective function, even if we just have access to stochastic subgradients~\citep{OrabonaP16b}. 
In particular, if the gradients are bounded in a range, the same reduction works using a continuous coin.

\citet{OrabonaP16b} showed that the simple betting strategy of $\beta_t=\tfrac{\sum_{i=1}^{t-1} g_i}{t}$ 
gives optimal growth rate of the wealth and optimal worst-case convergence rates. However, it is not data-dependent 
so it does not adapt to the sparsity of the gradients.
In the next section, we will show an actual betting strategy that guarantees optimal convergence rate and adaptivity to the gradients.

\begin{algorithm}[t]
\caption{COntinuous COin Betting - COCOB}
\label{algorithm:COCOB}
\begin{algorithmic}[1]
{
\STATE{Input: $L_i>0, i=1,\cdots,d$; $\bw_1\in \R^d$ (initial parameters); $T$ (maximum number of iterations); $F$ (function to minimize) }
\STATE{Initialize: $G_{0,i}\leftarrow L_i$, $\Reward_{0,i}\leftarrow0$, $\theta_{0,i}\leftarrow0$, $i=1,\cdots, d$}
\FOR{$t=1,2,\dots, T$}
\STATE{Get a (negative) stochastic subgradient $\bg_{t}$ such that $\E[\bg_t] \in \partial[- F(\bw_t)]$}
\FOR{$i=1,2,\dots, d$}
\STATE{Update the sum of the absolute values of the subgradients: $G_{t,i} \leftarrow G_{t-1,i} + |g_{t,i}|$}
\STATE{Update the reward: $\Reward_{t,i} \leftarrow \Reward_{t-1,i} + (w_{t,i}-w_{1,i}) g_{t,i}$}
\STATE{Update the sum of the gradients: $\theta_{t,i} \leftarrow \theta_{t-1,i} + g_{t,i}$}
\STATE{Calculate the fraction to bet: $\beta_{t,i}=\frac{1}{L_i}\left(2\sigma\left(\tfrac{2\theta_{t,i}}{G_{t,i}+ L_{i}}\right)-1\right)$, where $\sigma(x)=\tfrac{1}{1+\exp(-x)}$} \label{line:bet}
\STATE{Calculate the parameters: $w_{t+1,i} \leftarrow w_{1,i}+ \beta_{t,i} \left(L_i + \Reward_{t,i}\right)$} \label{line:w}
\ENDFOR
\ENDFOR
\STATE{Return $\bar{\bw}_T=\frac{1}{T} \sum_{t=1}^T \bw_{t}$ or $\bw_I$ where $I$ is chosen uniformly between $1$ and $T$}
}
\end{algorithmic}
\end{algorithm}

\section{The COCOB Algorithm}
\label{sec:cocob}
We now introduce our novel algorithm for stochastic subgradient descent, COntinuous COin Betting (COCOB), 
summarized in Algorithm~\ref{algorithm:COCOB}.
COCOB generalizes the reasoning outlined in the previous section to the optimization of a 
function $F: \R^d \rightarrow \R$ with bounded subgradients, reducing the optimization to betting on $d$ coins.

Similarly to the construction in the previous section, the outcomes of the coins are linked to the stochastic gradients. In particular, each $g_{t,i}\in [-L_{i}, L_{i}]$ for $i=1,\cdots,d$ is equal to the coordinate $i$ of the negative stochastic gradient $\bg_t$ of $F$ in $\bw_t$.
With the notation of the algorithm, COCOB is based on the strategy to bet a signed fraction of the 
current wealth equal to $\tfrac{1}{L_i}\left(2\sigma\left(\tfrac{2\theta_{t,i}}{G_{t,i}+ L_{i}}\right)-1\right)$, 
where $\sigma(x)=\tfrac{1}{1+\exp(-x)}$ (lines \ref{line:bet} and \ref{line:w}).
Intuitively, if $\tfrac{\theta_{t,i}}{G_{t,i}+ L_{i}}$ is big in absolute value, it means that we received 
a sequence of equal outcomes, i.e., gradients, hence we should increase our bets, i.e., the absolute value of $w_{t,i}$. 
Note that this strategy assures that $|w_{t,i} g_{t,i}| < \Wealth_{t-1,i}$, so the wealth of the 
gambler is always positive. Also, it is easy to verify that the algorithm is scale-free because 
multiplying all the subgradients and $L_i$ by any positive constant it would result in the same sequence of iterates $w_{t,i}$.

Note that the update in line~\ref{line:w} is carefully defined: The algorithm does not use the previous 
$w_{t,i}$ in the update. Indeed, this algorithm belongs to the family of the Dual Averaging algorithms, 
where the iterate is a function of the average of the past gradients~\citep{Nesterov09}.

Denoting by $\bw^*$ a minimizer of $F$, COCOB satisfies the following convergence guarantee.
\begin{theorem}
\label{theo:main}
Let $F:\R^d \rightarrow \R$ be a $\tau$-weakly-quasi-convex function and assume that $\bg_t$ satisfy $|g_{t,i}|\leq L_i$.
Then, running COCOB for $T$ iterations guarantees, with the notation in Algorithm~\ref{algorithm:COCOB},
\[
\E[F\left(\bw_I\right)] - F(\bw^*) \leq \sum_{i=1}^d \tfrac{L_i+|w^*_i-w_{1,i}| \sqrt{ \E\left[L_i (G_{T,i} +L_i)\ln\left(1+ \tfrac{(G_{T,i}+L_i)^2 (w_i^*-w_{1,i})^2}{L_i^2}\right)\right]}}{\tau T},
\]
where the expectation is with respect to the noise in the subgradients and the choice of $I$.
Moreover, if $F$ is convex, the same guarantee with $\tau=1$ also holds for $\bw_T$.
\end{theorem}

The proof, in the Appendix, shows through induction that betting a fraction of money 
equal to $\beta_{t,i}$ in line~\ref{line:bet} on the outcomes $g_{i,t}$, with an initial 
money of $L_i$, guarantees that the wealth after $T$ rounds is at least 
$L_i \exp\left(\tfrac{\theta_{T,i}^2}{2 L_i (G_{T,i}+L_i)}-\tfrac{1}{2}\ln\tfrac{G_{T,i}}{L_i}\right)$. 
Then, as sketched in Section~\ref{sec:coin}, it is enough to calculate the Fenchel conjugate of the wealth and use the 
standard construction for the per-coordinate updates~\citep{StreeterM10}. We note in passing that the 
proof technique is also novel because the one introduced in \citet{OrabonaP16b} does not allow data-dependent bounds.



When $|g_{t,i}|=1$, we have $\beta_{t,i} \approx \tfrac{\sum_{i=1}^{t-1} g_i}{t}$ that recovers the betting strategy in \citet{OrabonaP16b}. In other words, we substitute the time variable with the 
data-dependent quantity $G_{t,i}$. In fact, our bound depends on the terms $G_{T,i}$ while the similar one in \citet{OrabonaP16b} simply depends on 
$L_i T$. Hence, as in AdaGrad~\citep{DuchiHS11}, COCOB's bound is tighter because it takes advantage of sparse gradients.


COCOB converges at a rate of $\tilde{O}(\tfrac{\|\bw^*\|_1}{\sqrt{T}})$ \emph{without any learning rate to tune}. 
This has to be compared to the bound of AdaGrad that is\footnote{The AdaGrad variant used in deep learning does not have 
a convergence guarantee, because no projections are used. Hence, we report the oracle bound in the case that projections 
are used inside the hypercube with dimensions $|w^*_i|$.} $O(\tfrac{1}{\sqrt{T}} \sum_{i=1}^d (\tfrac{(\bw^*)^2}{\eta_i}+\eta_i))$, 
where $\eta_i$ are the initial learning rates for each coordinate. Usually all the $\eta_i$ are set to the same value, 
but from the bound we see that the optimal setting would require a different value for each of them. This effectively means that the optimal $\eta_i$ for AdaGrad are problem-dependent and typically unknown.
Using the optimal $\eta_i$ would give us a convergence rate of $O(\tfrac{\|\bw^*\|_1}{\sqrt{T}})$, 
that is exactly equal to our bound up to polylogarithmic terms.
Indeed, the logarithmic term in the square root of our bound is the price to pay to be adaptive to any $\bw^*$ and 
not tuning hyperparameters. This logarithmic term is unavoidable for any algorithm that wants to be adaptive 
to $\bw^*$, hence our bound is optimal~\citep{Streeter-McMahan-2012, Orabona-2013}.

\begin{figure}[t]
  \centering
  \begin{tabular}{ccc}
    \resizebox{4.2cm}{!}{
    \begin{tikzpicture}
    \begin{axis}[axis line style = thick,
                domain = 0:15,
                samples = 200,
                axis x line = middle,
                axis y line = left,
                every axis x label/.style={at={(current axis.right of origin)},anchor=west},
                every axis y label/.style={at={(current axis.north west)},above=0mm},
                xlabel = {$x$},
                ylabel = {$y$},
                ticks = none,
                grid = major
                ]
                \addplot[blue,semithick] {abs(x-10)} [yshift=3pt] node[pos=.95,left] {};
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick](axis cs:0,10) to [out=0,in=100] (axis cs:0.5,9.5);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick](axis cs:0.5,9.5) to [out=0,in=100] (axis cs:1,9);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick](axis cs:1,9) to [out=0,in=80] (axis cs:1.875,8.125);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick](axis cs:1.875,8.125) to [out=0,in=80] (axis cs:3.5,6.5);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick](axis cs:3.5,6.5) to [out=355,in=85] (axis cs:6.5625,3.4375);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick](axis cs:6.5625,3.4375) to [out=10,in=130] (axis cs:12.3750,2.3750);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick](axis cs:12.3750,2.3750) to [out=90,in=0] (axis cs:1.2891,8.7109);
            \end{axis}
    \end{tikzpicture}} &
    \resizebox{4.2cm}{!}{
    \begin{tikzpicture}
    \begin{axis}[axis line style = thick,
                domain = 0:15,
                samples = 200,
                axis x line = middle,
                axis y line = left,
                every axis x label/.style={at={(current axis.right of origin)},anchor=west},
                every axis y label/.style={at={(current axis.north west)},above=0mm},
                xlabel = {$x$},
                ylabel = {$y$},
                ticks = none,
                grid = major
                ]
                \addplot[blue,semithick] {abs(x-10)} [yshift=3pt] node[pos=.95,left] {};
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick](axis cs:0,10) to [out=0,in=90] (axis cs:0.5,9.5);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick](axis cs:0.5,9.5) to [out=0,in=90] (axis cs:1,9);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick](axis cs:1,9) to [out=0,in=90] (axis cs:1.5,8.5);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick](axis cs:1.5,8.5) to [out=0,in=90] (axis cs:2,8);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick](axis cs:2,8) to [out=0,in=90] (axis cs:2.5,7.5);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick](axis cs:2.5,7.5) to [out=0,in=90] (axis cs:3,7);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick](axis cs:3,7) to [out=0,in=90] (axis cs:3.5,6.5);
                
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick, red](axis cs:0,10) to [out=5,in=75] (axis cs:3,7);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick, red](axis cs:3,7) to [out=5,in=75] (axis cs:6,4);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick, red](axis cs:6,4) to [out=5,in=75] (axis cs:9,1);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick, red](axis cs:9,1) to [out=40,in=120] (axis cs:12,2);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick, red](axis cs:12,2) to [out=270,in=350] (axis cs:9,1);

                \draw[-{Stealth[scale=0.8,angle'=30]},semithick, green](axis cs:0,10) to [out=0,in=80] (axis cs:2,8);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick, green](axis cs:2,8) to [out=0,in=80] (axis cs:3.4142,6.58);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick, green](axis cs:3.4142,6.58) to [out=0,in=80] (axis cs:4.5689,5.4311);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick, green](axis cs:4.5689,5.4311) to [out=0,in=90] (axis cs:5.5689,4.4311);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick, green](axis cs:5.5689,4.4311) to [out=0,in=90] (axis cs:6.4633,3.5367);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick, green](axis cs:6.4633,3.5367) to [out=0,in=90] (axis cs:7.2798,2.7202);
                \draw[-{Stealth[scale=0.8,angle'=30]},semithick, green](axis cs:7.2798,2.7202) to [out=0,in=90] (axis cs:8.0358,1.9642);
            \end{axis}
    \end{tikzpicture}} &
    \includegraphics[width=4.2cm]{figs/effective_lr}
  \end{tabular} 
  \caption{Behaviour of COCOB (left) and gradient descent with various learning rates and same number of steps (center)
in minimizing the function $y=|x-10|$. (right) The effective learning rates of COCOB. Figures best viewed in colors.}
  \label{fig:comparison}
\end{figure}

To gain a better understanding on the differences between COCOB and other subgradient descent algorithms, it is helpful 
to compare their behaviour on the simple one-dimensional function $F(x)=|x-10|$ already used in Section~\ref{sec:coin}. 
In Figure~\ref{fig:comparison} (left), COCOB starts from 0 and over time it increases in an exponential way 
the iterate $w_t$, until it meets a gradient of opposing sign. From the gambling perspective this is obvious: 
The wealth will increase exponentially because there is a sequence of identical outcomes, that in turn gives 
an increasing wealth and a sequence of increasing bets. 

On the other hand, in Figure~\ref{fig:comparison} (center), gradient descent shows a different behaviour depending on its learning rate. If the learning rate is constant and too small 
(black line) it will take a huge number of steps to reach the vicinity of the minimum. If the learning rate 
is constant and too large (red line), it will keep oscillating around the minimum, unless some form of 
averaging is used~\citep{Zhang04}. If the learning rate decreases as $\tfrac{\eta}{\sqrt{t}}$, as in 
AdaGrad~\citep{DuchiHS11}, it will slow down over time, but depending of the choice of the initial learning 
rate $\eta$ it might take an arbitrary large number of steps to reach the minimum.

Also, notice that in this case the time to reach the vicinity of the minimum for gradient descent is not influenced 
in any way by momentum terms or learning rates that adapt to the norm of the past gradients, because 
the gradients are all the same. Same holds for second order methods: The function in figure lacks of 
any curvature, so these methods could not be used. Even approaches based on the reduction of the variance 
in the gradients, e.g. \citep{JohnsonZ13}, do not give any advantage here because the subgradients are 
deterministic.

Figure~\ref{fig:comparison} (right) shows the ``effective learning'' rate of COCOB that is 
$\tilde{\eta}_t := w_t \sqrt{\sum_{i=1}^t g_i^2}$. This is the learning rate we should use in 
AdaGrad to obtain the same behaviour of COCOB. We see a very interesting effect: The learning rate 
is not constant nor is monotonically increasing or decreasing. Rather, it is big when we are far 
from the optimum and small when close to it. However, we would like to stress that this behaviour 
has not been coded into the algorithm, rather it is a side-effect of having the optimal convergence rate.

We will show in Section~\ref{sec:exp} that this theoretical gain is confirmed in the empirical results. 
 \section{Backprop and Coin Betting}
\label{sec:backprop}

The algorithm described in the previous section is guaranteed to converge at the optimal convergence 
rate for non-smooth functions and does not require a learning rate. However, it still needs to know 
the maximum range of the gradients on each coordinate.
Note that for the effect of the vanishing gradients, each layer will have a different range of the 
gradients~\citep{Hochreiter91}. Also, the weights of the network can grow over time, increasing the 
value of the gradients too. Hence, it would be impossible to know the range of each gradient beforehand and use any strategy based on betting.

By following the previous literature, e.g.~\citep{KingmaB15}, we propose a variant of COCOB 
better suited to optimizing deep networks. We name it COCOB-Backprop and its pseudocode is in 
Algorithm~\ref{algorithm:COCOB-Backprop}. Although this version lacks the backing of a theoretical 
guarantee, it is still effective in practice as we will show experimentally in Section~\ref{sec:exp}.

\setlength{\textfloatsep}{10pt}\begin{algorithm}[t]
\caption{COCOB-Backprop}
\label{algorithm:COCOB-Backprop}
\begin{algorithmic}[1]
{
\STATE{Input: $\alpha>0$ (default value = 100); $\bw_1\in \R^d$ (initial parameters); $T$ (maximum number of iterations); $F$ (function to minimize)}
\STATE{Initialize: $L_{0,i}\leftarrow0$, $G_{0,i}\leftarrow0$, $\Reward_{0,i}\leftarrow0$, $\theta_{0,i}\leftarrow0$, $i=1,\cdots, \text{number of parameters}$}
\FOR{$t=1,2,\dots, T$}
\STATE{Get a (negative) stochastic subgradient $\bg_{t}$ such that $\E[\bg_t] \in \partial [-F(\bw_t)]$}
\FOR{each $i$-th parameter in the network}
\STATE{Update the maximum observed scale: $L_{t,i} \leftarrow \max(L_{t-1,i}, |g_{t,i}|)$} \label{line:lipschitz}
\STATE{Update the sum of the absolute values of the subgradients: $G_{t,i} \leftarrow G_{t-1,i} + |g_{t,i}|$}
\STATE{Update the reward: $\Reward_{t,i} \leftarrow \max(\Reward_{t-1,i} + (w_{t,i}-w_{1,i}) g_{t,i},0)$} \label{line:wealth}
\STATE{Update the sum of the gradients: $\theta_{t,i} \leftarrow \theta_{t-1,i} + g_{t,i}$}
\STATE{Calculate the parameters: $w_{t,i} \leftarrow w_{1,i} + \tfrac{\theta_{t,i}}{L_{t,i} \max(G_{t,i}+L_{t,i},\alpha L_{t,i})} \left(L_{t,i} +\Reward_{t,i}\right)$} \label{line:update}
\ENDFOR
\ENDFOR
\STATE{Return $\bw_{T}$}\label{line:output}
}
\end{algorithmic}
\end{algorithm}

There are few differences between COCOB and COCOB-Backprop. First, we want to be adaptive to the maximum component-wise 
range of the gradients. Hence, in line \ref{line:lipschitz} we constantly update the values $L_{t,i}$ for each variable. 
Next, since $L_{i,t-1}$ is not assured anymore to be an upper bound on $g_{t,i}$, we do not have any guarantee that 
the wealth $\Reward_{t,i}$ is non-negative. Thus, we enforce the positivity of the reward in line \ref{line:wealth} of 
Algorithm~\ref{algorithm:COCOB-Backprop}.

We also modify the fraction to bet in line \ref{line:update} by removing the sigmoidal function
because $2\sigma(2x)-1\approx x$ for $x\in[-1,1]$. This choice simplifies the code and always improves 
the results in our experiments. Moreover, we change the denominator of the fraction to bet such that it is 
at least $\alpha L_{t,i}$. This has the effect of restricting the value of the parameters in the first iterations 
of the algorithm. To better understand this change, consider that, for example, in AdaGrad and Adam with learning rate $\eta$ the first update is $w_{2,i}=w_{1,i}-\eta \sgn(g_{1,i})$. Hence, $\eta$ should have a value smaller than $w_{1,i}$ in order to not ``forget'' the initial point too fast. In fact, the initialization is critical to obtain good results and moving too far away from it destroys the generalization ability of deep networks. Here, the first update becomes $w_{2,i}=w_{1,i}-\frac{1}{\alpha}\sgn(g_{1,i})$, so $\frac{1}{\alpha}$ should also be small compared to $w_{1,i}$.

Finally, as in previous algorithms, we do not return the average or a random iterate, but just the last one
(line \ref{line:output} in Algorithm~\ref{algorithm:COCOB-Backprop}).

 \section{Empirical Results and Future Work}
\label{sec:exp}

We run experiments on various datasets and architectures, comparing COCOB with some popular 
stochastic gradient learning algorithms: AdaGrad~\citep{DuchiHS11}, RMSProp~\citep{TielemanH12}, 
Adadelta~\citep{Zeiler12}, and Adam~\citep{KingmaB15}.
For all the algorithms, but COCOB, we select their learning rate as the one that gives the best training cost 
a posteriori using a very fine grid of values\footnote{[0.00001, 0.000025, 0.00005, 0.000075, 0.0001, 0.00025, 
0.0005, 0.00075, 0.001, 0.0025, 0.005, 0.0075, 0.01, 0.02, 0.05, 0.075, 0.1]}. 
We implemented\footnote{\url{https://github.com/bremen79/cocob}} COCOB (following Algorithm~\ref{algorithm:COCOB-Backprop}) in Tensorflow~\citep{tensorflow2015-whitepaper} 
and we used the implementations of the other algorithms provided by this deep learning framework.
The best value of the learning rate for each algorithm and experiment is reported in the legend.

We report both the training cost and the test error, but, as in previous work, e.g.,~\citep{KingmaB15}, 
we focus our empirical evaluation on the former. Indeed, given a large enough neural network it is always 
possible to overfit the training set, obtaining a very low performance on the test set. Hence, test errors 
do not only depends on the optimization algorithm.

\begin{figure}[t]
  \centering
  \begin{tabular}{c@{\hskip 1cm}c}
  \includegraphics[width=0.40\textwidth]{figs/mnist_fc_tr} &
  \includegraphics[width=0.40\textwidth]{figs/mnist_fc_te} \\
  \includegraphics[width=0.40\textwidth]{figs/mnist_cnn_tr} &
  \includegraphics[width=0.40\textwidth]{figs/mnist_cnn_te}
  \end{tabular} 
  \caption{Training cost (cross-entropy) (left) and testing error rate (0/1 loss) (right) vs. the number 
epochs with two different architectures on MNIST, as indicated in the figure titles. The y-axis is logarithmic 
in the left plots. Figures best viewed in colors.}
  \label{fig:exp1}
\end{figure}

\paragraph{Digits Recognition.}
As a first test, we tackle handwritten digits recognition using the MNIST dataset~\citep{MNIST}.
It contains $28\times 28$ grayscale images with 60k training data, and 10k test samples.   
We consider two different architectures, a fully connected 2-layers network and a 
Convolutional Neural Network (CNN). In both cases we study different optimizers on the standard
cross-entropy objective function to classify 10 digits. 
For the first network we reproduce the structure described in the multi-layer experiment of 
\citep{KingmaB15}: it has two fully connected
hidden layers with 1000 hidden units each and ReLU activations, with mini-batch size of 100.
The weights are initialized with a centered truncated normal distribution and standard deviation 0.1,
the same small value 0.1 is also used as initialization for the bias.
The CNN architecture follows the Tensorflow tutorial~\footnote{\url{https://www.tensorflow.org/get_started/mnist/pros}}:
two alternating stages of $5 \times 5$ convolutional filters and 
$2 \times 2$ max pooling are followed by a fully connected layer of 1024 
rectified linear units (ReLU). To reduce overfitting, 50\% dropout noise is used during training.


Training cost and test error rate as functions of the number of training epochs are reported in 
Figure~\ref{fig:exp1}. With both architectures, the training cost of COCOB 
decreases at the same rate of the best tuned competitor algorithms.  
The training performance of COCOB is also reflected in its associated test error
which appears better or on par with the other algorithms.




\begin{figure}[t]
  \centering
  \begin{tabular}{c@{\hskip 1cm}c}
  \includegraphics[width=0.40\textwidth]{figs/cifar10_tr} &
  \includegraphics[width=0.40\textwidth]{figs/cifar10_te} 
  \end{tabular} 
  \caption{Training cost (cross-entropy) (left) and testing error rate (0/1 loss) (right) 
vs. the number epochs on CIFAR-10. The y-axis is logarithmic in the left plots. Figures best viewed in colors.}
  \label{fig:exp2}

\end{figure}
\begin{figure}[t]
  \centering
  \begin{tabular}{c@{\hskip 1cm}c}
  \includegraphics[width=0.4\textwidth]{figs/ptb_train3_parametertuned} &
  \includegraphics[width=0.4\textwidth]{figs/ptb_val3_parametertuned} 
  \end{tabular} 
  \caption{Training cost (left) and test cost (right) measured as average per-word perplexity 
vs. the number epochs on PTB word-level language modeling task. Figures best viewed in colors.}
  \label{fig:exp3}
\end{figure}

\paragraph{Object Classification.}
We use the popular CIFAR-10 dataset~\citep{Krizhevsky09} to classify $32\times32$ RGB images across 10 object categories.
The dataset has 60k images in total, split into a training/test set of 50k/10k samples.  
For this task we used the network defined in the Tensorflow CNN tutorial\footnote{\url{https://www.tensorflow.org/tutorials/deep_cnn}}.
It starts with two convolutional layers with 64 kernels of dimension $5 \times 5 \times 3$,
each followed by a  $3 \times 3 \times 3$ max pooling with stride of 2 and by local response normalization 
as in \cite{NIPS2012_4824}. Two more fully connected layers respectively of 384 and 192 rectified linear units complete 
the architecture that ends with a standard softmax cross-entropy classifier. We use a batch size of 128 and the input 
images are simply pre-processed by whitening. Differently from the Tensorflow tutorial, we do not apply
image random distortion for data augmentation.

The obtained results are shown in Figure~\ref{fig:exp2}.
Here, with respect to the training cost, our learning-rate-free COCOB performs on par with the best competitors. For all the algorithms, there is a good correlation between the test performance and the training cost. COCOB and its best competitor AdaDelta show similar
classification results that differ on average $\sim 0.008$ in error rate.

\paragraph{Word-level Prediction with RNN.}
Here we train a Recurrent Neural Network (RNN) on a language modeling task. 
Specifically, we conduct word-level prediction experiments on the Penn Tree Bank (PTB) dataset~\citep{MarcusMS93} 
using the 929k training words and its 73k validation words. We adopted the medium LSTM~\citep{HochreiterS97} network 
architecture described in \citet{ZarembaSV14}: it has 2 layers with 650 units per layer and parameters
initialized uniformly in $[-0.05, 0.05]$, a dropout of 50\% is applied on the non-recurrent connections,
and the norm of the gradients (normalized by mini-batch size = 20) is clipped at 5.

We show the obtained results in terms of average per-word perplexity in Figure~\ref{fig:exp3}.
In this task COCOB performs as well as Adagrad and Adam with respect to the training cost and much better than the other
algorithms. In terms of test performance, COCOB, Adam, and AdaGrad all show an overfit behaviour 
indicated by the perplexity which slowly grows after having reached its minimum.
Adagrad is the least affected by this issue and presents the best results, followed by COCOB
which outperforms all the other methods. We stress again that the test performance does not depend only 
on the optimization algorithm used in training and that early stopping may mitigate the overfitting effect.

\paragraph{Summary of the Empirical Evaluation and Future Work.}
Overall, COCOB has a training performance that is on-par or better than state-of-the-art algorithms with perfectly tuned learning rates.
The test error appears to depends on other factors too, with equal training errors corresponding to different test errors.

We would also like to stress that in these experiments, contrary to some of the previous reported empirical results on similar datasets and networks, the difference between the competitor algorithms is minimal or not existent when they are tuned on a very fine grid of learning rate values. Indeed, the very similar performance of these methods seems to indicate that all the algorithms are inherently doing the same thing, despite their different internal structures and motivations. 
Future more detailed empirical results will focus on unveiling what is the common structure of these algorithms that give rise to this behavior.

In the future, we also plan to extend the theory of COCOB beyond $\tau$-weakly-quasi-convex functions, 
characterizing the non-convexity present in deep networks.
Also, it would be interesting to evaluate a possible integration of the betting framework with second-order methods.
 
\section*{Acknowledgments}
The authors thank the Stony Brook Research Computing and Cyberinfrastructure, and the Institute for 
Advanced Computational Science at Stony Brook University for access to the high-performance SeaWulf 
computing system, which was made possible by a \$1.4M National Science Foundation grant (\#1531492). 
The authors also thank Akshay Verma for the help with the TensorFlow implementation and Matej Kristan 
for reporting a bug in the pseudocode in the previous version of the paper. T.T. was supported by the 
ERC grant 637076 - RoboExNovo. F.O. is partly supported by a Google Research Award.


\bibliography{learning}
\bibliographystyle{abbrvnat}

\appendix

\section{Proof of Theorem~\ref{theo:main}}
\label{sec:proof_main}

First we state some technical lemmas that will be used in the proof of the convergence rate of COCOB.

\begin{lemma}{\cite[extended version, Lemma~18]{OrabonaP16b}}
\label{lemma:dual}
Define $f(x)= \beta \exp\frac{x^2}{2 \alpha}$, for $\alpha,\beta>0$. Then
\[
f^*(y) \leq |y| \sqrt{\alpha \log \left(\frac{\alpha y^2}{\beta^2} +1 \right)} - \beta~.
\]
\end{lemma}

\begin{lemma}
\label{lemma:recurrence}
Let $a\geq2$. Then, with the notation of Algorithm~\ref{algorithm:COCOB}, for any $t$ we have
\begin{align*}
&(1+\beta_{t,i} g_{t,i}) \exp\left(\frac{\theta_{t-1,i}^2}{a L_i (G_{t-1,i}+L_i)}- \sum_{j=1}^{t-1} \frac{|g_{j,i}|}{a (G_{j-1,i}+L_i)}\right)\\
&\quad \geq \exp\left(\frac{\theta_{t,i}^2}{a L_i (G_{t,i}+L_i)}- \sum_{j=1}^{t} \frac{|g_{j,i}|}{a (G_{j-1,i}+L_i)}\right)~.
\end{align*}
\end{lemma}
\begin{proof}
The statement to prove is equivalent to
\[
\ln(1+\beta_t g_t) + \frac{\theta_{t-1}^2}{a L (L+\sum_{j=1}^{t-1} |g_j|)}
\geq \frac{(\theta_t+g_t)^2}{a L (L+\sum_{j=1}^{t} |g_j|)}- \frac{|g_t|}{a (L+\sum_{l=1}^{t-1} |g_l|)},
\]
where for clarity we dropped the index $i$.

Consider the function 
\[
\phi(x)=-\log(1+\beta_t x) + \frac{(\theta_{t-1}+x)^2}{a L (G_{t-1} + |x|)}~.
\]
We have that $\phi(x)$ is piece-wise convex on $[-\infty,0]$ and $[0,\infty]$. Hence, we have that
\begin{align*}
&\phi(x) \leq \phi(0)+\frac{x}{L} (\phi(L)-\phi(0)), \forall 0 \leq x\leq L\\
&\phi(x) \leq \phi(0)+\frac{x}{L} (\phi(0)-\phi(-L)), \forall -L \leq x\leq 0~.
\end{align*}
Also, $\beta_t$ is such that $\phi(L)=\phi(-L)$.
Hence, we have
\[
\phi(x) \leq \phi(0)+ \frac{|x|}{L} (\phi(L)-\phi(0)), \forall -L \leq x\leq L,
\]
that is
\begin{align*}
&\frac{\theta_{t-1}^2}{a L G_{t-1}}-\frac{(\theta_{t-1}+g_t)^2}{a L (G_{t-1} +  |g_t|)} + \log(1+\beta_t g_t) \\
& \quad = \phi(0) - \phi(g_t) \\
& \quad \geq \frac{|g_t|}{L} \left(\phi(0) - \phi(L)\right) \\
& \quad = \frac{|g_t|}{L} \left(\frac{\theta_{t-1}^2}{a L G_{t-1}} - \frac{(\theta_{t-1}+L)^2}{a L (G_{t-1} + L)} + \log(1+\beta_t L)\right), \forall -L \leq g_t \leq L~.
\end{align*}

Using this relation we have that
\begin{align*}
&\frac{\theta_{t-1}^2}{a L G_{t-1}}-\frac{(\theta_{t-1}+g_t)^2}{a L (G_{t-1}+|g_t|)} +\log(1+\beta_t g_t)\\
&\qquad \geq \frac{|g_t|}{L} \left(\frac{\theta_{t-1}^2}{a L G_{t-1}} - \frac{(\theta_{t-1}+L)^2}{a L_i (G_{t-1} + L)} + \log(1+L \beta_t)\right)\\
&\qquad = \frac{|g_t|}{L} \left(\frac{(G_{t-1} + L) \theta_{t-1}^2 - (\theta_{t-1}^2+2 L \theta_{t-1} )G_{t-1} }{a L G_{t-1}(G_{t-1} + L)} + \log(1+L \beta_t)\right) - \frac{|g_t|}{a (G_{t-1} + L)}\\
&\qquad = \frac{|g_t|}{L} \left(\frac{\theta_{t-1}^2}{a G_{t-1}(G_{t-1} + L)}-\frac{2 \theta_{t-1}}{a (G_{t-1} + L)} + \log(1+L \beta_t)\right) - \frac{|g_t|}{a (G_{t-1} + L)}~.
\end{align*}
We now use the Taylor expansion, to obtain
\[
\log\left(1+\frac{\exp(x)-1}{\exp(x)+1}\right) \geq \frac{x}{2} -\frac{x^2}{8} \qquad \forall x \in \R
\]
and, using the expression of $\beta_t$, have
\[
\log\left(1+L \beta_t\right) 
= \log\left(1+\frac{\exp\left(\frac{4 \theta_{t-1}}{a (G_{t-1} + L)}\right)-1}{\exp\left(\frac{4 \theta_{t-1}}{a (G_{t-1} + L)}\right)+1}\right) 
\geq \frac{2 \theta_{t-1}}{a (G_{t-1} + L)} -\frac{2 \theta_{t-1}^2}{a^2 (G_{t-1} + L)^2}~.
\]
Hence the expression 
\begin{align*}
\frac{\theta_{t-1}^2}{a G_{t-1}(G_{t-1} + L)}-\frac{2 \theta_{t-1}}{a (G_{t-1} + L)} + \log(1 + L \beta_t)
&\geq \frac{\theta_{t-1}^2}{a G_{t-1}(G_{t-1} + L_i)}-\frac{2 \theta_{t-1}^2}{a^2 (G_{t-1} + L)^2}\\
& \geq \frac{a L_i \theta_{t-1}^2 + a G_{t-1} \theta_{t-1}^2  - 2 G_{t-1} \theta_{t-1}^2}{a^2 G_{t-1}(G_{t-1} + L)^2}
\end{align*}
is greater than zero if $a \geq 2$, that is true by definition of $a$.
\end{proof}

We can now prove Theorem~\ref{theo:main}.

\begin{proof}[Proof of Theorem~\ref{theo:main}]
First, assume that $\bw_1=\boldsymbol{0}$, then we will show how to remove this assumption.

Define $H_{t,i}(x)=L_i \exp\left(\frac{x^2}{2 L_i (G_{t,i}+L_i)}- \sum_{j=1}^{t} \frac{|g_j|}{2 (L_i+G_{j-1,i})}\right)$.
By induction, we first prove that $\Wealth_{t,i}\geq H_{t,i}(\theta_{t,i})$. For $t=0$, it is obvious because $\Wealth_{0,i}=L_i$. We now assume that $\Wealth_{t-1}\geq H_{t-1,i}(\theta_{t-1,i})$. Note that $|\beta_{t,i} g_{t,i}|<1$.
Hence, using Lemma~\ref{lemma:recurrence}, we have
\begin{equation}
\label{eq:bound_wealth}
\begin{split}
\Wealth_{t,i}
&=\Wealth_{t-1,i} + g_{t,i} w_{t,i} 
= \Wealth_{t-1,i}(1 + g_{t,i} \beta_{t,i}) \\
&\geq (1 + g_{t,1} \beta_{t,i}) H_{t-1,i}(\theta_{t-1,i}) \\
&\geq H_{t,i}(\theta_{t,i}),
\end{split}
\end{equation}
that proves the induction.

Now, in the convex case, using the fact that the stochastic subgradient are unbiased, the definition of the subgradients, and Jensen's inequality, we have
\begin{equation*}
T \left(\E[F(\bar{\bw}_T)] - F(\bw^*)\right) 
\leq \sum_{t=1}^T (\E[F(\bw_t)] - F(\bw^*)) 
\leq \sum_{t=1}^T \E[(\bw^* - \bw_{t})^\top \bg_{t}]~.
\end{equation*}

While, in the the $\tau$-weakly-quasi-convex case, we have
\[
T \left(\E[F(\bw_I)] - F(\bw^*)\right) 
= \sum_{t=1}^T \left( \E[F(\bw_t)] -F(\bw^*)\right)
\leq \tau \sum_{t=1}^T \E[(\bw^* - \bw_{t})^\top \bg_{t}]
\]
by fact that the gradient are unbiased, the definition of $\bw_I$, and the definition of $\tau$-weakly-quasi-convexity.
Hence, the two cases are the same up to the factor $\tau$. We can then proceed in both cases with
\begin{equation}
\sum_{t=1}^T \E[(\bw^* - \bw_{t})^\top \bg_{t}] 
= \sum_{i=1}^d \sum_{t=1}^T \E[w^*_i g_{t,i} - g_{t,i} w_{t,i} ]
= \sum_{i=1}^d \E[L_i + w^*_i \theta_{T,i} -  \Wealth_{T,i}]~. \label{eq:conv_wealth}
\end{equation}

Using the definition of Fenchel's conjugate, \eqref{eq:conv_wealth} and the lower bound on the wealth in \eqref{eq:bound_wealth}, we have
\begin{align*}
\sum_{t=1}^T \E[(\bw^* - \bw_{t})^\top \bg_{t}] 
&= \E\left[\sum_{i=1}^d (L_i + w^*_i \theta_{T,i} -  \Wealth_{T,i})\right] \\
&\leq \E\left[\sum_{i=1}^d (L_i + w^*_i \theta_{T,i} -  H_{T,i}(\theta_{T,i}))\right]\\
&\leq \E\left[\sum_{i=1}^d L_i+\max_{x} \ (w^*_i x -  H_{T,i}(x))\right]
= \E\left[\sum_{i=1}^d L_i+H^*_{T,i}(w^*_i)\right]~.
\end{align*}

Also, the concavity of the logarithm implies that $\frac{a-b}{a}\leq \ln a - \ln b$ for all $a \geq b >0$. Hence
\begin{equation}
\label{eq:bound_log}
\sum_{j=1}^T \frac{|g_j|}{L_i+G_{j-1,i}} 
\leq \sum_{j=1}^T \frac{|g_j|}{G_{j,i}} 
\leq \sum_{j=1}^T (\ln G_{j,i} - \ln G_{j-1,i}) 
= \ln \frac{G_{T,i}}{G_{0,i}}
= \ln \frac{G_{T,i}}{L_i}~.
\end{equation}

Using Lemma~\ref{lemma:dual}, the inequality in \eqref{eq:bound_log}, and overapproximating, we have
\[
H^*_{T,i}(w^*_i) \leq |w^*_i| \sqrt{ L_i (G_{T,i} +L_i)\ln\left(1+ \tfrac{(G_{T,i}+L_i)^2 (w_i^*)^2}{L_i^2}\right)}~.
\]

Putting all together, using Jensen's inequality to bring the expectation under the square root, and dividing by $T$ give us the stated bound, with $\bw_1=\boldsymbol{0}$.

Now, running the algorithm on the function $\tilde{F}(\bw)=F(\bw_t+\bw_1)$, for an arbitrary $\bw_1$, would result in the update in Algorithm~\ref{algorithm:COCOB} and would guarantee the same upper bound on $\E[\tilde{F}\left(\bar{\bw}_T\right)] - \tilde{F}(\bw^*) $ that implies the stated bound.
\end{proof}

 
\end{document}
