
\documentclass[12pt,journal,letterpaper,onecolumn]{IEEEtran}

\clearpage{}
\usepackage{setspace,fleqn,url,epsf,calc,latexsym,amsmath,multicol,cite}
\usepackage[dvips]{graphics,color,graphicx}


\usepackage[ruled, vlined]{algorithm2e}


\newcounter{myCounter}
\setcounter{myCounter}{1}
\renewcommand{\themyCounter}{\arabic{myCounter}\addtocounter{myCounter}{1}}
\newcommand{\finish}[1]{{\bf #1}}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{example}{Example}[section]


\newenvironment{myproofsketch}
{\noindent {\bf Proof Sketch:}}{\hspace*{\fill}}
\newenvironment{mydefinition}
{\begin{definition}\begin{em}}{\end{em}\end{definition}}
\newenvironment{myexample}
{\begin{example}\begin{em}}{\end{em}\hspace*{\fill}\end{example}}
\newenvironment{myalgorithm}
{\begin{algorithm}\begin{em}\begin{singlespace}}{\end{singlespace}\end{em}\end{algorithm}}
\newenvironment{mytheorem}
{\begin{theorem}\begin{em}}{\end{em}\end{theorem}}
\newenvironment{mylemma}
{\begin{lemma}\begin{em}}{\end{em}\end{lemma}}
\newenvironment{myproof}
{\noindent {\bf Proof:}}{\hspace*{\fill}}
\newenvironment{mytest}
{\begin{test}\begin{em}}{\end{em}\end{test}}
\newenvironment{myproposition}



\clearpage{}

\begin{document}

\title{Checking Security Policy Compliance}
 \begin{multicols}{2}
\author{Vaibhav Gowadia ~~~~~ Csilla Farkas  ~~~~~~~~~~~~~~Michiharu Kudo\\
       Center for Information Assurance Engineering~~~~~Tokyo Research Lab, IBM\\
     Department of Computer Science and Engineering~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\
        University of South Carolina, Columbia ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\
  }
  \end{multicols}
\date{January 30, 2008}

\maketitle 

\begin{abstract}
\noindent Ensuring compliance of organizations to federal
regulations is a growing concern. This paper presents a framework
and methods to verify whether an implemented low-level security policy is
compliant to a high-level security policy.  Our compliance checking framework
is based on organizational and security metadata to support
refinement of high-level concepts to implementation specific
instances. Our work uses the results of refinement calculus to
express valid refinement patterns and their properties.
Intuitively, a low-level security policy is compliant to a high-level security policy
if there is a valid refinement path from the high-level security policy to
the low-level security policy.  Our model is capable of detecting violations
of security policies, failures to meet obligations, and capability
and modal conflicts.
\end{abstract}

\begin{keywords}Policy refinement, action refinement, compliance checking, security policies, obligation, access control
\end{keywords}

\section{Introduction}




\PARstart{R}{ecent} regulations, like Sarbanes-Oxley (SOX)~\cite{sox} and Health
Insurance Portability and Accountability Act (HIPAA)~\cite{Hipaa96},
are having a broad impact in information technology (IT) operations
at many organizations. For example, SOX requires organizations to
place adequate internal controls over financial reporting. HIPAA
requires sufficient safeguards to be placed for controlling access
to medical records. Moreover, these regulations require evaluations
of safeguards and controls implemented by the organizations to
determine whether they are compliant with the requirements.

Tools to support automated compliance checking and establish formal
properties are needed. Clearly, this is a complex problem requiring
knowledge not only about the high- and low-level policies but also
the available technologies, organizational requirements and
processes, and system dynamics. Several policy
languages~\cite{Damianou01,Kagal02,Jajodia01,bettini02} have been
proposed by researchers. However, they were not designed to allow
comparison of high-level and low-level security policies.


In this paper, we focus on the specific problem of checking
compliance of an implemented security policy to the high-level
security policy of an organization. A high-level security policy may
specify 1) description of security requirements over abstract
concepts, and 2) obligations, dispensations, and permissions. The
low-level security policy gives specific security requirements over
instances of abstract concepts. For example, let us consider an
organization with a business process called Order Management. A rule
in high-level policy may be that the Business Manager must protect
the Order Management process from unauthorized access. Rules in
low-level security policy may specify access control list for the
purchase orders database used by the Order Management process.


Refinement of a high-level policy into a low-level policy may
require instantiation of roles, refinement of actions, and inference
procedures.  Many researchers have also proposed mechanisms
for policy refinement~\cite{Bandara04,Rubio06,Rochaeli07},
i.e. to derive the low-level enforceable policies from the
high-level policies. Instantiation of roles has been studied extensively in
context of access control~\cite{Ferraiolo}.
The work of Backes et al.~\cite{Backes04} focuses on comparing two privacy policies.
However, the problem of verifying
compliance of a low-level implemented policy to a high-level policy
is not fully considered yet. In this paper, we propose a mechanism
based on refinement calculus~\cite{Back} to fill this gap.

In this work, we propose a policy refinement framework and
action algebra that we apply for checking compliance of security
policies. The proposed action algebra forms the basis of action
 refinements.  To illustrate the need
of action refinement to study compliance checking we now present an
example. Let , , and  be actions,  a subject, and
 an object. Assume that allowing action  is equivalent to
allowing action  and disallowing action . If a high-level
policy contains an access control rule  and low-level
policy contains access control rules  and  then the low level policy is not compliant to the high-level policy.
Intuitively, the
policy compliance problem asks the question whether the low-level
policy satisfies the relevant requirements of the high-level
security policy.





Our main contributions in this paper are development of an action
algebra, a framework for policy refinement using refinement pattern,
and a definition of compliance based on the concept of model checking.
We describe a policy language that can model both high-level and low-level
security policies. The proposed policy language is an extension of
the Authorization Specification Language (ASL) and Flexible
Authorization Framework(FAF)~\cite{Jajodia01}. The
extended language supports specification of obligations,
dispensations, and authorizations. We have applied the principles of
refinement calculus to security policies, and developed an
action algebra that can be used to evaluate the correctness of
action compositions.  In addition, we have developed a policy
refinement mechanism that combines action algebra and the policy
language to refine high-level security policy into low-level
security policies. Security policies are refined using action
refinement patterns and derivation rules. The refinement process
results in a set of possible low-level policies and corresponding
system states. If the implemented low-level policy and the current
system state corresponds to a derived low-level policy and state
then we consider the implemented policy to be compliant to the
high-level policy.


Rest of the paper is organized as follows:
Section~\ref{sec:overview} presents an overview of the proposed
compliance checking framework. Section~\ref{sec:definitions}
presents definitions of basic constructs.
Section~\ref{sec:composition} describes action composition.
Section~\ref{sec:language} and \ref{sec:checking} describe our
extension of Flexible Authorization Framework(FAF) and the compliance checking process respectively.
In Section~\ref{sec:conclude} we conclude and recommend future work.



\section{Compliance Checking Framework}
\label{sec:overview}

We propose a compliance-checking framework, where all entities in
the concerned organization are described with ontological concepts.
We define an ontology that models concepts like, subjects,
permissions, obligations, actions, protection objects, and metadata
associated with them and with the organization. Our compliance
checking framework comprises of the following components: 1. an
ontology, 2. instances of ontology concepts (e.g., users,
organization's resources, roles, etc.), 3. a high-level security
policy, 4. a set of low-level security policies, 5. refinement
patterns, and 6. compliance checking engine. An overview of the
compliance checking framework is shown in Figure~\ref{fig:overview}(a).
We now describe the components of the proposed compliance checking
framework.

\begin{figure}[h]
\begin{center}

\end{center}
 \caption{(a) Compliance checking architecture (b) Partial Ontology}
 \label{fig:overview}
\end{figure}

We model security policies as locally stratified logic programs similar to
Authorization Specification Language~\cite{Jajodia01}. The
security policy language presented in this work can represent
obligation, dispensations, and authorizations. It also supports
conflict resolution rules and policy refinement. Action refinement
patterns specify refinement of an action of type  into a
composition expression (Section~\ref{sec:composition}) formed with
sub-actions of  such that the constraints for satisfying any
obligation of type  are preserved.


The compliance checking engine in our framework refines the high-level security policy by recursively applying policy refinement rules. The refinement process continues until no new facts can be derived. The refined policies generated by this process comprise of ground rules and system-state information (facts) only. The set of all decision rules in a policy is called a decision view.

The low-level security policy and system information given as input to check for compliance is now compared with the set of refined security policies generated. If the given system state satisfies post conditions of applicable obligations and the decision view of input low-level policy implies one of the possible decision views of high-level policy, we say that the given system complies to high-level policy. However, if the given system is not compliant, the compliance checking engine may also detect violations of high-level policy and capability conflicts that prevent users from performing their obligations. In Section~\ref{sec:checking}, we discuss different types of violations and capability conflicts in further detail.

Rules in high-level policy contain composite actions. Composite
action consists of two or more sub-actions. We present an action
composition algebra and Ontology based system model to check whether
the action compositions are well-formed.

In next section, we define constructs used to model system state and
policy components like actions.

\section{Definitions}
\label{sec:definitions} This work uses ontologies to model the
entities of our compliance checking framework. Our method relies on this
ontology to aid the compliance checking as described in following
sections.  We now present our definition on Ontology used in
this work.



\begin{definition}(Ontology)\\
An ontology  is a 6-tuple
,
where  is a set of classes,  is a set of
properties,  is the subclass hierarchy of
 and  is the subproperty hierarchy of
.  and  are functions defined as
 and
, where
 represents the power set of .
Let  be a class such that  for
 and let  represent the  for
. We represent the class  as
. \label{def:ontology}
\end{definition}

\begin{example} Let {\ttfamily Computer} be a class with properties {\ttfamily os}, {\ttfamily owner},
and {\ttfamily name}. Let the range of property {\ttfamily os} be
given by the class {\ttfamily OS}, the range of property {\ttfamily
owner} be given by the class {\ttfamily Agent}, and the range of
property {\ttfamily name} be given by the class {\ttfamily String}.
The class {\ttfamily Computer} is represented as {\ttfamily
Computer((os,\{OS\}),(owner,\{Agent\}),(name,\{String\}))}.
\label{eg:class}
\end{example}

Figure~\ref{fig:overview}(b) shows class hierarchy of the concepts
used in our framework. Our ontology is an extension of the SUMO
ontology~\cite{sumo} being developed by the IEEE SUO Working Group.
The root node of our ontology is the class {\em Entity}. The class
{\em Entity} refers to the fundamental concept in the domain being
modeled. The class {\em Object} refers to physical objects. Binary
relations that evaluates to true or false are represented by class
{\em Predicate}. {\em Process} is a class of active components that
occur and have temporal parts or stages. The class {\em Agent}
represents something or someone that can act on its own. For
example, software agents and human users. Human agents are
represented by the class {\em Users}. A set of users is called a
{\em Group}. A social position that is usually associated with some
obligations and permissions is called a {\em Role}. The class {\em
Action} represents a set of operations that the users may perform.
Properties of the class {\em Action} are shown in
Table~\ref{table:action}.

\begin{table}[h]
\begin{center}
\begin{minipage}{5in}
\footnotesize
\begin{tabular}{|l|l|p{3in}|}
\hline
Property & Range & Semantics \\
\hline
agent & Agent & Agent that actively carries out the process\\
instrument & Object & Instrument is used by the process and is not modified\\
resource & Object & Resource is modified and used by the process\\
target & Entity & The entity acted upon or modified by the process\\
evidence & Predicate & Predicate is true after the action is performed. \\
subAction & Action & A distinguished part of the process \\
causes & Process & This process causes or triggers another process of type specified by this property\\
prevents & Process &  Processes of type specified by this property are prevented by this process \\
\hline
\end{tabular}
\normalsize
\end{minipage}
\caption{OWL properties of class Action} \label{table:action}
\end{center}
\end{table}



\begin{definition}(Object)\\
Let  be an ontology. An object is an instance of any class 
defined in . Let  be the
definition of class  where  are properties
of class . We describe object  as
 ,
where  is a unique identifier, and for each 
there is a  of  such that 
and  is in range . We use the notation
 to represent the  property of  and
its value. Note that {\ttfamily type} is one of the properites
of . \label{def:object}
\end{definition}

\begin{example} An object of type {\ttfamily Computer} with
os {\ttfamily Solaris8}, owner {\ttfamily Alice}, and name
{\ttfamily Hadar} is represented as {\ttfamily
Comp1((type,Computer),(os,Solaris8)},{\ttfamily(owner,Alice)}, {\ttfamily(name,Hadar))},
where {\ttfamily Comp1} is an identifier used to represent the
computer object in question. Also note that {\ttfamily Solaris8},
{\ttfamily Alice}, and {\ttfamily Hadar} are identifiers of other
objects. \label{eg:object}
\end{example}

\begin{definition}(Data System)\\
The Data System  = \{\} is a set of objects.
\label{def:ds}
\end{definition}

\begin{definition}(State)\\
The state of a data system  is described by properties of
objects in , that is
  
.
 \label{def:state}
\end{definition}

For simplicity, in
the rest of this paper, we represent  as ,
where  is a variable representing the property  of object
. We say that the range of  is the same as the range of
. Let  be the set of
variables that describe a state in . The mapping from   to
objects and their properties is maintained separately.

 Alternatively, a state  is defined as an assignment
, where  is value of
variable  and .


Note that a system may satisfy more than one state representations.
These state representations are related to each other by refinement
relation as we describe below.
\begin{definition} (State Refinement)\\
\noindent Let  and  be two states. We say that  is
a refinement of  () if . Note that the refinement relation ()
between states is reflexive, transitive, and antisymmetric.
\end{definition}

\begin{example} Let   = \{:={\ttfamily Computer},
:={\ttfamily Linux\}}, = \{:={\ttfamily Notebook}, :={\ttfamily Linux\}} be two state representations for an object. Given,
{\ttfamily Notebook}  {\ttfamily Computer}, we can say that
state  is refined by state  . \label{eg:state}
\end{example}


\begin{definition}(State Space)\\
A state space is a set of states.
 \label{def:statespace}
\end{definition}

\begin{example} Let  = \{:={\ttfamily Computer}, :={\ttfamily Linux}\},
      = \{:={\ttfamily Computer}, :={\ttfamily Windows}\} be two states.
     Then the set \{\} represents a state space.
\label{eg:statespace1}
\end{example}

Description of a state space as illustrated
in above example can be very tedious for large systems. In many cases,
we want to specify only the variables of interest. We allow a more concise
description of a state space in such cases as described below.

Let  be a data system that can be described by variables
, where  .
A state space   described as  represents the following set of states:\\
 x  x  x
 x
    x
 
 where,  ,  ,
 

\begin{example}
Let us assume data system  contains only two variables  and .
Let state space  be described as (:={\ttfamily Computer}), and
 =\{{\ttfamily Linux, Windows}\}. \\
 Then  = \{:={\ttfamily Computer}\} x \{:={\ttfamily Linux}, :={\ttfamily Windows}\}, \\
 i.e.,  = \{ \{:={\ttfamily Computer}, :={\ttfamily Linux} \},
                     \{:={\ttfamily Computer}, :={\ttfamily Windows}\}
                   \}
\label{eg:statespace2}
\end{example}


Intuitively, refinement of a state space means reaching a more
specific state space. A more specific state space has fewer states or
contains states that are sub states of states in other state space.
Refinement of state space is now formally defined.

\begin{definition}(State Space Refinement)\\
Let  and  be two state spaces. We say that 
is refined by  (), if and only
if ,  
such that .
\label{def:statespacerefinement}
\end{definition}


\begin{example}
Let us assume  = \{:={\ttfamily Computer}, :={\ttfamily Linux}\},
      = \{:={\ttfamily Computer}, :={\ttfamily Windows}\}, and
      = \{:={\ttfamily Notebook}, :={\ttfamily Linux}\} are states, and  = \{\},
      = \{\}, and
      = \{\} describe state spaces.
From definition of state space refinement, we observe
1)  is refined by  (), as , , and  and 2)  is refined by  (), as ,  and .
\label{eg:statespaceref}
\end{example}



The refinement relation between states spaces is reflexive,
transitive, and antisymmetric.
\begin{center}
\begin{minipage}{4.5in}
  (reflexive) \\
   (transitive)\\
   (antisymmetric)
\end{minipage}
\end{center}

Let  represent a non empty state space that contains all
possible states of data system , and  be the power set
of . The pair () is then a partially
ordered set. Let  and  be two elements (state
spaces) in . The greatest lower bound of  and
 is given as .
The least upper bound of  and  is given as .


\begin{definition}(Restricted Subclass)\\
Let  be a class. Then
 is a restricted subclass,
where at least one of ,  is a subclass or an
instance of  respectively. For all other ,
. \label{def:RestrictedSubclass}
\end{definition}

\begin{example}  Consider the class {\ttfamily Computer} defined
in Example~\ref{eg:class}. The restricted class {\ttfamily
Computer} {\ttfamily((os,Windows))} represents the sub class comprising of all
computers with operating system of type {\ttfamily Windows}.
\end{example}


\begin{definition}(Action)\\
\label{def:action} Let  and  be two state spaces. An
action class  is a state transformer
from  to . An action 
is an instance of action class  only if  and
. We call  as the initial state space and
 as the final state space for action class .
\end{definition}

In the rest of this paper, for each variable  of type action class,
 we assume there exists corresponding initial and final state spaces
 and we use symbols  and  to denote them.

\begin{definition}(Monotonicity of Refinement)\\
\label{def:monotonicity}
Let  be an action. Let \{\} and
\{\} be state spaces such that
. If
 and ,
then .\\

Let  be an action.
Let  be a state space that
refines  ().
Let  represent actions performed
 on states in the state space , and let
  be the state space
 after action  is performed.  By definition of , the state
 space  is refined by  . This
 implies that .

\end{definition}

For better readability we often write
 instead of 
in rest of the paper.

Actions are often composed of several other sub-actions. Composition
may be performed by following operations: sequence (), choice
(), and conjunction (). These operators give us the
following language for
expressing action composition: \\
\indent \\
where  is an atomic action, and  and  are subactions of
.  The precedence order of the operators in action composition is
. We now describe properties of these
operators.

The choice operator () is a binary operator. If  and
 represent two action terms then  represents an
 action  that executes either  or
. The choice operation is commutative and associative.
\begin{center}
\begin{minipage}{4.5in}
\begin{multicols}{2}
 \\
 \\

\end{multicols}
\end{minipage}
\end{center}


The sequence operator () is also a binary operator. If  and
 represent two action terms then  represents an action
that performs  followed by . The sequence operator is not
commutative. It is associative and is distributive over the choice
operator.
\begin{center}
\begin{minipage}{4.5in}
\begin{multicols}{2}
\\
 \\
 \\
\\

\end{multicols}
\end{minipage}
\end{center}

Choice and sequence operators are the basic operators in our action
algebra. The conjunction operator is a composite operator. If 
and  are two action terms, then a conjunction operation on
 and  is defined by . Conjunction operator is associative, commutative
 and is distributive over the choice operator.
\begin{center}
\begin{minipage}{4.5in}
\begin{multicols}{2}
 \\
\\

\end{multicols}
\end{minipage}
\end{center}






\begin{definition}(Action Refinement)\\
Let ,  and  be actions, and
  be an action composition. We say that  is a refinement of , i.e., , iff given any states  and , where , the action
composition , such that
. \label{def:action-refinement}
\end{definition}

We assume that the action composition  used
as a pattern to refine an action  in our model is alway more 
restrictive then . Therefore, it not possible for the refinement
process to derive  when further refining the composition 
.


\begin{definition}(Atomic Action)\\
 An action  is an atomic action if it
cannot be refined by any other action.
\end{definition}

\begin{definition}(Action Tree)\\
An action composition tree is a node-labeled binary tree where each
internal node is labeled with an action and an operator pair, and
each leaf node is labeled with an atomic action. The composition of
actions represented by the child nodes is a refinement of the action
at the parent node.
\end{definition}


In next section, we present types of action compositions that are
allowed in this work. To provide assurance about correct compliance
checking and policy refinement, action compositions must be
well-formed. The concept of well-formed action composition is also
discussed in next section.

\section{Action Composition}
\label{sec:composition} We first define types of action compositions
categorized based on the depth of action tree.

\begin{definition}(Simple Composition)\\
Let  and  be two atomic actions and  be an action
composition operator. An action composition of the form  is called a simple composition. \label{def:simple}
\end{definition}

\begin{definition}(Complex Composition)\\
Let  and  be two actions and  be an action
composition operator. An action composition  is a
complex composition if 1.)  and  are either
 atomic actions, simple compositions, or complex compositions, and
 2.) at least one of  and  is not an atomic action.
\end{definition}

An action refinement pattern is a template for refining actions of a
particular type.

\begin{definition}(Action Refinement Pattern)\\
A refinement pattern  is an action tree with root
node of action type .
\end{definition}

We define additional types of composition in the context of
refinement. We categorize action compositions as basic or
advanced based on absence or presence of constraints in addition to
operator type. Note that the advanced composition type is applicable
only when it is required to perform both sub-action. Hence, it is
not applicable to choice operations.

\begin{definition}(Basic Composition)\\
\label{def:basic} Let  and  be two actions. We say that
 is a basic composition if  is
one of the
 operators: sequence, choice, or conjunction as defined in
Section~\ref{sec:definitions} and there are no additional
constraints.
\end{definition}


\begin{definition}(Advanced Composition)\\
\label{def:advanced}  Let  and  be two actions, 
be an operator, and  be a state space such that  (or ). We say
that  (or ) is an advanced composition if for all
states in  the sub action  (or  respectively) can
be ignored but for all states in  both  and
 must be performed.
\end{definition}

We also categorize action compositions as strict or flexible
based on the feasibility to perform both sub-actions in the initial
state space or the feasibility to perform at least one of
sub-actions in the initial state space. Strict and flexible action
composition types are not applicable for sequence operators as the
order of sub-actions is predetermined.

\begin{definition}(Strict Composition)\\
\label{def:strict} Let , where
 represents a composition operator. We say that  is a strict composition if  is constrained
strictly to satisfy conditions such that {\em both}  and 
can be performed in the initial state for all .
In other words, .
\end{definition}


\begin{definition}(Flexible Composition)\\
\label{def:flexible} Let , where
 represents a composition operator. We say that  is a flexible composition if for all , it is
feasible to perform {\em either}  or  in the initial
state, and both  and  must be performed. i.e., .
\end{definition}

The above composition types may be combined.
Figure~\ref{fig:compositionTypes} illustrates possible combinations.
Constraints for correct action refinements for various composition
types are given in Table~\ref{table:refine}.

\begin{figure}
\begin{minipage}{6in}
\footnotesize
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
& Basic & Advanced \\
\hline
Sequence &  &  \\
\hline
 Strict &  &  \\
 &  & \\
\hline
Flexible &  &  \\
&  & \\
\hline
\end{tabular}
\end{center}
\normalsize
\end{minipage}
\caption{Composition Types} \label{fig:compositionTypes}

\end{figure}



\begin{table}[h]
\begin{center}
\begin{minipage}{6in}
\footnotesize
\begin{center}
\begin{tabular}{|p{3.2cm}|llll|}
\hline
 Composition Type &             &&&\\
\hline \hline
Basic &   Constraints          &&&\\
\hline

 &

 &

 &

 & \\
\hline \hline
 Basic and Strict & Constraints &&&\\
\hline &
\multicolumn{3}{l}{Let  be the start state.} & \\


 &

 &

  &

 & \\



 &

 &  && \\

&  &  && \\

\hline \hline
Basic and Flexible & Constraints &&& \\
\hline

 &

 &

 &

 &\\

& & &  & \\



 &

 &

\multicolumn{2}{l}{ and }& \\

&& \multicolumn{2}{l}{ and } &\\

\hline
\hline Advanced &   Constraints          &&&\\
\hline

 &   &

 & & \\

&& \multicolumn{2}{l}{}&\\

\hline \hline
Advanced and Strict & Constraints &&& \\
\hline


 &

 & 
&
 &\\

& \multicolumn{3}{l}{
   and  and } &\\

& \multicolumn{3}{l}{
  and } &\\



\hline
\hline Advanced and Flexible & Constraints &&& \\
\hline


 &





 &  && \\

 &\multicolumn{3}{l}{ and
  } & \\


 &\multicolumn{3}{l}{ and  and } & \\


&\multicolumn{3}{l}{ and  } & \\


 \hline
\end{tabular}
\end{center}
\normalsize
\end{minipage}
\caption{Constraints for well-formed action refinement}
\label{table:refine}
\end{center}
\end{table}



\begin{definition}(Valid Action Trace)\\
Action trace is an action composition where the composition is
expressed using only the sequence operator. Given an action tree and
an action trace, the trace is valid with respect to the action tree
iff the trace can be derived from the root of the action tree using
the properties of the operators.
\end{definition}

\begin{definition}(Well-formed Action Composition)\\
Let  be an action composition and let
 represent all the valid traces of the action
composition. We say that an action composition is well-formed if and
only if for each trace ,  such
that , where .
\label{def:well-formed}
\end{definition}


\begin{theorem}
Basic Composition  is well-formed if , , and .\label{theorem:basic}
\end{theorem}
\noindent {\bf Proof.~}\\
\begin{minipage}{6in} \begin{center}
\begin{tabular}{llp{7.5cm}p{3.8cm}}
Initial State & Trace &  Proof step & \\
 &  &    & (by transitivity)  \hfill(\themyCounter)\\
& &    & (Definition of )\\
& &    & (by transitivity) \hfill(\themyCounter)\\
& &    & (Definition of )\\
& &    & (by transitivity) \hfill(\themyCounter)\\
\multicolumn{4}{l}{From (1),  can be performed in the initial state.}\\
\multicolumn{4}{l}{From (2),  can be performed after .}\\
\multicolumn{4}{l}{From (1), (2) and (3),  is a valid action trace.}\\
\multicolumn{4}{l}{ is a valid trace; therefore,  is well-formed.}\hfill\\
\end{tabular}
\end{center}
\end{minipage}\\


\begin{theorem}
Basic and Strict Composition  is
well-formed if ,
, and .
\label{theorem:basicstrictchoice}
\end{theorem}
\noindent {\bf Proof.~}\\
\begin{minipage}{6in} \begin{center}
\begin{tabular}{llp{8cm}p{3.8cm}}
Initial State & Trace &  Proof step & \\
 &  & & (by set inclusion)\\
& &    & (by transitivity) \hfill(\themyCounter) \\
& &   &  (Definition of )  \\
& &   & (by transitivity) \hfill(\themyCounter)\\
&  & & (by set inclusion)\\
& &    & (by transitivity) \hfill(\themyCounter) \\
& &   & (Definition of ) \\
& &   & (by transitivity) \hfill(\themyCounter)\\
\end{tabular}
\end{center}
\end{minipage}

\begin{minipage}{6in} \begin{center}
\begin{tabular}{llp{7.5cm}p{3.8cm}}
\multicolumn{4}{l}{From (4),  can be performed in the initial state.}\\
\multicolumn{4}{l}{From (4) and (5),  is a valid action trace.}\\
\multicolumn{4}{l}{From (6),  can be performed in the initial state.}\\
\multicolumn{4}{l}{From (6) and (7),  is a valid action trace.}\\
\multicolumn{4}{l}{ and  are valid traces; therefore,
 is well-formed.}\\
\end{tabular}
\end{center}
\end{minipage}

For all states in , both  and  can be performed.
Hence, the constraints show that the composition is
strict.\hfill


\begin{theorem}
Basic and Strict Composition   is
well-formed if , ,  and .
\label{theorem:basicstrictconjunction}\end{theorem}
\noindent {\bf Proof.~}\\
\begin{minipage}{6in} \begin{center}
\begin{tabular}{llp{7.5cm}p{3.8cm}}
Initial State & Trace &  Proof steps & \\
 &  &   & (by transitivity) \hfill(\themyCounter)\\
& & & (Hypothesis) \hfill(\themyCounter)\\ &  &   & (by transitivity) \hfill(\themyCounter)\\
& & & (Hypothesis) \hfill(\themyCounter)\\ \multicolumn{4}{l}{From (8),  can be performed in the initial state.}\\
\multicolumn{4}{l}{From (9),  can be performed after .}\\
\multicolumn{4}{l}{From (8) and (9),  is a valid action trace.}\\
\multicolumn{4}{l}{From (10),  can be performed in the initial state.}\\
\multicolumn{4}{l}{From (11),  can be performed after .} \\
\multicolumn{4}{l}{From (10) and (11),  is a valid action trace.}\\
\multicolumn{4}{l}{ and  are valid traces; therefore,  is a well-formed composition.}\hfill\\
\end{tabular}
\end{center}
\end{minipage}\\



\begin{theorem}
Basic and Flexible Composition  is
well-formed if ,
, ,  , and . \label{theorem:basicflexiblechoice}\end{theorem}
\noindent {\bf Proof.~}\\
\begin{minipage}{6in} \begin{center}
\begin{tabular}{llp{8cm}p{3.8cm}}
Initial State & Trace &  Proof steps & \\
 &  &   & (by transitivity) \hfill(\themyCounter)\\
 & &   & (Hypothesis) \hfill(\themyCounter)\\
 &  &    & (Definition of ) \hfill(\themyCounter) \\
 &  &    & (Definition of ) \hfill(\themyCounter) \\
\multicolumn{4}{l}{From (12), Initial state  is in either ,  or both. Therefore, at least one of  and  can}\\
\multicolumn{4}{l}{be performed.} \\
\multicolumn{4}{l}{From (13), There are states in  which provide a choice between  and .}\\
\multicolumn{4}{l}{From (12) and (14),  is a valid trace.} \\
\multicolumn{4}{l}{From (12) and (15),  is a valid trace.}\\
\multicolumn{4}{l}{ and  are valid traces; therefore,
 is well-formed.} \hfill
\end{tabular}
\end{center}
\end{minipage}\\


\begin{theorem}
Basic and Flexible Composition  is
well-formed if , and
for all  if  then  and , and if  then
 and .\label{theorem:basicflexibleconjunction}
\end{theorem}
\noindent {\bf Proof.~}\\
\begin{minipage}{6in} \begin{center}
\begin{tabular}{llp{7.5cm}p{3.8cm}}
Initial State & Trace &  Proof steps & \\
 &  & & (by transitivity) \hfill(\themyCounter) \\
 &  & & (Hypothesis) \hfill(\themyCounter)\\
 & &  & (Hypothesis) \hfill(\themyCounter)\\
 &  & & (Hypothesis) \hfill(\themyCounter)\\
 & &  & (Hypothesis) \hfill(\themyCounter)\\
\multicolumn{4}{l}{From (16), Initial state  is in either
,  or both. Therefore, at least one of  or}\\
\multicolumn{4}{l}{ can be performed. This constraint preserves the semantics of flexible composition.} \\
\multicolumn{4}{l}{From (17),  can be performed after .} \\
\multicolumn{4}{l}{From (17) and (18),  is a valid action trace.} \\
\multicolumn{4}{l}{From (19),  can be performed after .} \\
\multicolumn{4}{l}{From (19) and (20),  is a valid action trace.} \\
\multicolumn{4}{l}{ and  are valid traces; therefore,
 is a well-formed composition.}
\hfill
\end{tabular}
\end{center}
\end{minipage}\\



\begin{theorem}
Advanced Composition  is well-formed
under following conditions: 1) , 2) if
 then  must be refined
by , i.e., , else performing action
 after  must lead to a state in , i.e., . \label{theorem:advancedseq} \end{theorem}
\noindent {\bf Proof.~}\\
\begin{minipage}{6in} \begin{center}
\begin{tabular}{llp{7.5cm}p{3.8cm}}
Initial State & Trace &  Proof steps & \\
 &  &   & (by transitivity) \hfill(\themyCounter) \\
& &    & (Hypothesis) \hfill(\themyCounter)\\
&  &    & (by transitivity) \hfill(\themyCounter)\\
& &   & (Hypothesis) \hfill(\themyCounter)\\
\multicolumn{4}{l}{From (21),  can be performed in initial state.}\\
\multicolumn{4}{l}{From (21) and (22),  is a valid trace, when  can be ignored.}\\
\multicolumn{4}{l}{From (23),  can be performed in initial state.}\\
\multicolumn{4}{l}{From (23) and (24),  is a valid trace, when  can be performed after . }\\
\multicolumn{4}{l}{ and  are valid traces; therefore,
 is a well-formed composition.}
\hfill
\end{tabular}
\end{center}
\end{minipage}\\


\begin{theorem}
Advanced and Strict Composition  is well-formed if the following constraints
are satisfied: 1) if  and  then
 ,
2) if  then
   and  and , and
3) if  then
  and , and 4) \\
\label{theorem:advancedstrict} \end{theorem}
\noindent {\bf Proof.~}\\
\begin{minipage}{6in} \begin{center}
\begin{tabular}{llp{7.5cm}p{3.8cm}}
Initial State & Trace &  Proof steps & \\

 &  &
   &
(by transitivity) \hfill(\themyCounter)  \\

& &  & (Hypothesis) \hfill(\themyCounter)  \\


 &  &
   & (by transitivity) \hfill(\themyCounter) \\

& &  & (Hypothesis)  \hfill(\themyCounter)\\

& &  & (Hypothesis)  \hfill(\themyCounter)\\

&  &  &  (by set inclusion)  \hfill(\themyCounter)\\

& &    &   (by transitivity) \hfill(\themyCounter)\\

& & & (Hypothesis)  \hfill(\themyCounter)  \\

& &  & (Hypothesis)  \hfill(\themyCounter) \\

\multicolumn{4}{l}{From (25),  can be performed in initial state.}\\
\multicolumn{4}{l}{From (25) and (26),  is a valid trace.}\\
\multicolumn{4}{l}{From (27),  can be performed in initial state}\\
\multicolumn{4}{l}{From (28),  can be performed after . }\\
\multicolumn{4}{l}{From (27), (28), and (29),  is a valid trace.}\\
\multicolumn{4}{l}{From (31),  can be performed in initial state.}\\
\multicolumn{4}{l}{From (32),  can be performed after }\\
\multicolumn{4}{l}{From (31), (32), and (33),  is a valid trace.}\\
\multicolumn{4}{l}{The constraint  ensures that the trace  exists. This preserves the semantics of a}\\
\multicolumn{4}{l}{strict conjunction.}\\
\multicolumn{4}{l}{, , and  are valid traces;
therefore,  is a well-formed
composition.}\hfill
\end{tabular}
\end{center}
\end{minipage}\\


\begin{theorem}
Advanced and Flexible Composition  is well-formed under following conditions: 1)
, 2) if  and  then
, 3) if  and  and  then , 4)
if  and  then  .
\label{theorem:advancedflexible} \end{theorem}
\noindent {\bf Proof.~}\\
\noindent
\begin{minipage}{6in} \begin{center}
\begin{tabular}{llp{6.3cm}p{3.8cm}}
Initial State & Trace &  Proof steps & \\
 & &    & (by transitivity) \hfill(\themyCounter)\\
 &  & If , & (Case)\\& &  & (by transitivity) \hfill(\themyCounter) \\
& &  & (Hypothesis) \hfill(\themyCounter) \\

&  & If  & (Case) \\ & &  & (Hypothesis) \hfill(\themyCounter)\\

&  &  & (by transitivity) \hfill(\themyCounter) \\
& &  & (Hypothesis)\hfill(\themyCounter)\\
& &  & (Hypothesis)\hfill(\themyCounter)\\
\multicolumn{4}{l}{From (34), Initial state  is in either ,  or both. Therefore, at least one of  or  can}\\
\multicolumn{4}{l}{be performed.}\\
\multicolumn{4}{l}{From (35),  can be performed after .}\\
\multicolumn{4}{l}{From (35) and (36),  is a valid trace.}\\
\multicolumn{4}{l}{From (37),  is a valid trace.}\\
\multicolumn{4}{l}{From (38),  can be performed in the initial state.}\\
\multicolumn{4}{l}{From (39),  can be performed after .}\\
\multicolumn{4}{l}{From (38), (39) and (40),  is a valid trace.}\\
\multicolumn{4}{l}{, , and  are valid traces;
therefore,  is a well-formed
composition.}\hfill
\end{tabular}
\end{center}
\end{minipage}\\


\begin{theorem}(Well-formed Complex Composition)\\
Let  and
 be composite actions  and  respectively. An
action composition  is a
well-formed composition if the action compositions  and  are
well-formed.
 \label{thm:complexcomposition}
\end{theorem}
{\noindent {\bf Proof.~}} If  is refined by the composition
, all traces of the  must be valid.
Also, it must be possible to perform  for all states
in . From Def.~\ref{def:action-refinement}, if
, then for all ,
, such that, \\
\indent  and \hfill({\themyCounter)}\\

\noindent Similarly, for all ,
, such that \\
 and \hfill{(\themyCounter)}

\noindent Let  be a state transforming
function . The action
composition  is well-formed if all
traces of  are valid even after substitution of 
with
. We now prove validity of each possible trace. \\

\noindent
Case 1:{\em If  is a valid trace then  is a valid trace.}\\
If  is a valid trace then ,
such that  \\
and , such that \hfill{(\themyCounter)}\\
and , such that \hfill{(\themyCounter)}

\noindent
From~(41) and (43), we get, \\
\indent  or
 (by transitivity)
\hfill{(\themyCounter)}\\

\noindent Let , then from
(44) and (45), we get,\\
\indent   (by
monotonicity)\hfill{(\themyCounter)} \\

\noindent From (44) and (46),  (by
transitivity). Hence,  is a valid trace. \\

\noindent
Case 2: {\em If  is a valid trace then  is a valid trace.}\\
Reasoning is similar to Case 1. \\

\noindent Case 3: {\em If  is a valid trace then  is a valid trace.}\\
If  is a valid trace,  such that,
 and \hfill{(\themyCounter)}\\
\noindent From (41) and (47),  (by
transitivity). Hence  is a valid trace. \\

\noindent Case 4: Refinement of  does not effect the trace
. \hfill







Now we give an example of an action composition.
\begin{example}  Let  {\ttfamily InstallFirewall},   {\ttfamily InstallAntiVirus}, and
 {\ttfamily Protect} be types of actions. Let  {\ttfamily a = Protect((target,\x} is an object variable representing objects that satisfy the
predicates  {\ttfamily type(\x,Alice)}. Composition of  {\ttfamily a}
may be described as follows: \\
 {\ttfamily Protect((target,\\sqsubseteqx))}  \\
\indent \indent \indent \indent \indent \indent \indent
 {\ttfamily [\x))}\\
This composition is an advanced composition using the conjunction
operator. The sub-action  {\ttfamily Install}-{\ttfamily AntiVirus} must be
performed if the operating system is Windows. Otherwise the user may
choose not to perform this action. \label{eg:actionrefinement}
\end{example}


\section{Policy Specification Language}
\label{sec:language} In this section we briefly describe our
approach to incorporate action refinement in authorization policies.
For this we extend the Flexible Authorization Framework
(FAF)~\cite{Jajodia01} to express obligations,
dispensations, and refinement.
FAF is a logic-based framework to express authorization requirements.
Access control permissions or denials are derived by a sequence of applications
of the authorization rules.  These sequence include the propagation, the conflict
resolution, the decision, and the integrity modules.  In addition, it is ensured
that every access request is either granted or denied, therefore ensuring completeness
of the authorization policy.

In our work, we provide extension of FAF, while preserving its 
properties with respect to completeness and decidability. 
 Our extensions, that include predicates to express obligations,
dispensations, and refinements in FAF will preserve the 
properties of locally stratified logic program.
First, we give a brief overview of FAF.  The FAF syntax is built from constants, variables, and
predefined predicates.  The constants and variables range over authorization objects, subjects,
actions, and roles.  FAF includes the following predicates:
\begin{itemize}
\item 
\item 
\item 
\item 
\item  and  for overriding predicates
\item  for integrity viiolations
\item  and  for object and subject hierarhies
\end{itemize}
For detailed explanation of these predicates, look at reference~\cite{Jajodia01}.  FAF rules
are stratified by assigning levels to the predicates and requiring that the head predicate's
level is equal or higher than the levels of the predicates in the rule body.
Formal properties of FAF, such as unique stable model and well-founded model, as well as complexity
analysis, are presented in~\cite{Jajodia01}.

In this work, we propose new predicates to express obligation and dispensation requirements. Table~\ref{table:strata} shows the levels of these predicates along with the original FAF
predicates.  First, we start with the formal description of
these concepts.

Regulations often specify obligations as one of their requirements.
In general, we interpret obligations as actions that users are
required to perform to achieve specific goals. 
\begin{definition}(Obligation) \\
Let  be an action type. An obligation
 is defined as a command to subject  to
perform an action of type , such that the condition  is
satisfied. Definition of an obligation is said to be correct if
, where  is state space
representing all states in which  is true. Let  be the
state of a given system. We say that subject  has satisfied
obligation  if . If
, the assumptions made to perform
the action of type  are violated. Violating the assumptions
releases the subject from the obligation. As this is not fault of
the subject, it is considered to have satisfied the obligation.
 \label{def:obligation}
\end{definition}
\begin{definition}(Dispensation)\\
Let  be an action type. A dispensation
 is defined as an exemption given to subject 
from performing an action of type .
 \label{def:dispensation}
\end{definition}

Rules in our policy language consists of constants, variables, and
predicates. They are defined as follows:

\begin{enumerate}
\item {\em Constant Symbols:} Every member of
, where Obj is the set of
objects, T the set of types, U the set of users, G the set of
groups, R the set of roles, A the set of action types.
\item {\em Variable Symbols:} There are seven sets ,  ,
,  ,  ,  of variable symbols ranging over the
sets , , , , , , respectively. \item {\em
Predicate Symbols:}
    \begin{enumerate}
    \item A 3-ary predicate symbol, {\ttfamily hasObligation}. The first argument is
    a subject term, the second argument is an action term,
    and the third argument is a boolean formula called post-condition.
    \item A 2-ary predicate symbol, {\ttfamily hasDispensation}. The first argument
    is a subject term, and the second argument is an action term.
    \item A 3-ary predicate symbol, {\ttfamily derhasObligation}, with the same arguments
    as {\em hasObligation}. The predicate {\ttfamily derhasObligation} represents obligations
    derived by using logical rules of inference
    (modus ponens plus rules for stratified negation~\cite{Apt88}).
    \item A 2-ary predicate symbol, {\ttfamily derhasDispensation}, with the same arguments
    as {\em hasDispensation}. The predicate {\ttfamily derhasDispensation} represents
    dispensations derived by using logical rules of inference
    (modus ponens plus rules for stratified negation).
    \item A 3-ary predicate symbol, {\ttfamily mustdo}, with the same arguments
    as {\ttfamily hasObligation} and {\ttfamily derhasObligation}. It definitely represents
    the actions that must be performed. Intuitively, {\ttfamily mustdo} enforces the conflict
    resolution and obligation policy.
    \end{enumerate}
\end{enumerate}

In addition, we allow use of {\ttfamily cando, dercando, do, done,
, , error}, , and  predicates as
defined in FAF. Table~\ref{table:strata} shows the strata of rules
allowed in our policy to represent obligations, dispensations and
their refinement.



\begin{table}[h]
\begin{center}
\begin{minipage}[t]{6in}
\footnotesize
\begin{tabular}{|l|l|l|p{3.2in}|}
\hline

Level & Stratum & Predicate & Rules defining predicate \\

\hline

0 &  & hie-predicates & base relations \\
  &     & rel-predicates & base relations \\
  &     & done & base relation \\

\hline

1 &  & hasObligation & body may contain done, hie- and rel- literals. \\
  &        & hasDispensation & body may contain done, hie- and rel- literals. \\







\hline

2 &  & derhasDispensation & body may contain hasObligation,
hasDispensation, derhasDispensation, over, done,
hie- and rel- literals.\\
\hline

3 &  & derhasObligation & body may contain hasObligation,
hasDispensation,
derhasObligation, derhasDispensation, over, done, hie- and rel- literals.\\


\hline

4 &  & mustdo & body may contain hasObligation,
derhasObligation, hasDispensation, derhasDispensation, done,
hie- and rel- literals.\\

\hline

5 &  & cando & body may contain mustdo, done,
hie- and rel- literals.\\

\hline

6 &  & dercando & body may contain mustdo, cando, dercando,
 done, hie- and rel- literals.\\

\hline

7 &  & do & in the case when head is of the form do(o,s,+a)body
may contain cando, dercando, done,
hie- and rel- literals.\\
\hline

 8 & & do & in the case when head is of the form
do(o,s,-a) body
contains just one literal do(o,s,+a).\\

\hline

9 &  & error & body may contain mustdo, hasObligation, derhas-
Obligation, hasDispensation, derhasDispensation, do, cando,
dercando, done,
hie- and rel- literals.\\

\hline
\end{tabular}
\normalsize
\end{minipage}
\end{center}
\caption{Obligation and Authorization Specification Strata}
\label{table:strata}
\end{table}




\begin{definition}(Obligation Rule)\\
An {\em obligation rule} is a rule of the form:\\
{\ttfamily hasObligation(s,a,q)} \\
 where 
is a subject term,  is an obligation action type,  is a
boolean formula composed with - predicates and  literals,
and  are , - or - literals.
\label{def:obligationrule}
\end{definition}

\begin{example}  Let us assume that an organization requires
computers to have firewall software installed to be considered safe.
The obligation "Employees must protect computers they own from
unauthorized access" is then modelled by following obligation rule:

{\ttfamily hasObligation(\x))},
{\ttfamily hasInstalled(\y)} \\
{\ttfamily\&} {\ttfamily type(\\leftarrowx,Computer)} {\ttfamily \&}
{\ttfamily type(\x,\\y\ are variables, {\ttfamily Protect} is a
sub-class of {\ttfamily Action}, {\ttfamily Computer} and {\ttfamily
Employee} are sub-classes of {\ttfamily Object}, {\ttfamily type} is
a  predicate, and {\ttfamily target}, {\ttfamily hasInstalled},
and {\ttfamily owner} are  predicates.

Let us assume that the data system contains two Employee objects and
three Computer objects such that the following predicates hold in
the system state:

{\ttfamily type(pc1, Computer)}, {\ttfamily type(emp1, Employee)}\\
\indent {\ttfamily type(pc2, Computer)}, {\ttfamily type(emp2, Employee)}\\
\indent {\ttfamily type(pc3, Computer)}, {\ttfamily owner(emp1, pc1)}\\
\indent {\ttfamily owner(emp2, pc2)}, {\ttfamily owner(emp1, pc3)}

When above obligation rule is evaluated in the data system presented
above, the results of evaluations are {\ttfamily
(\s=emp1)}, {\ttfamily (\s=emp2)}, and {\ttfamily
(\s=emp1)}. Applying the evaluation results to the
obligation rule creates following three obligations:

\noindent
{\ttfamily hasObligation(emp1, Protect((target,pc1)), hasInstalled(pc1, \y,Firewall))} \\
{\ttfamily hasObligation(emp2, Protect((target,pc2)), hasInstalled(pc2, \y,Firewall))} \\
{\ttfamily hasObligation(emp1, Protect((target,pc3)), hasInstalled(pc3, \y,Firewall))} \\
\end{example}

\begin{definition}(Dispensation Rule)\\
A {\em dispensation rule} is a rule of the form: \\
{\ttfamily hasDispensation(s,a)}  \\
where  is a subject term,  is an obligation action type, and
 are , - or - literals.
\label{def:dispensationrule}
\end{definition}

New obligations and dispensation may be derived from existing
obligations, dispensations, hie- and rel- predicates using inference
rules called derivation rules. For example, a derivation rule can
specify propagation of obligation via subject hierarchy, and
delegation of duties. Definition of dispensation and obligation
derivation rules follow.

\begin{definition}(Dispensation Derivation Rule)\\
A {\em dispensation derivation rule} is a rule of the form: \\
{\ttfamily derhasDispensation(s,a)}  \\
where  is a subject term,  is an obligation action type, and
 are {\ttfamily hasDispensation,
derhasDispensation, done}, - or - literals. All {\ttfamily
derhasDispensation} literals appearing in the body must be positive.
\label{def:derdispensationrule}
\end{definition}



\begin{definition}(Obligation Derivation Rule)\\
An {\em obligation derivation rule} is a rule of the form: \\
\indent {\ttfamily derhasObligation(s,a,q)} \\
where  and  are terms of  and  respectively,  is a
system state, and  are {\ttfamily hasObligation,
derhasObligation, derhasDispensation, done}, - or -
literals. All {\ttfamily derhasObligation} literals appearing in the
body must be positive.\label{def:derivationrule}
\end{definition}

\begin{definition}(Derivation View)\\
A derivation view is a finite set of derivation rules.
\end{definition}

\subsection{Policy Refinement}

We use derivation rules to refine a high-level policy into low-level
policy. Derivation is based on subject hierarchy as in FAF, and
action refinement patterns. A discussion of types of derivation rules
is presented below.

\noindent {\bf A. Derivation via subject-hierarchy}\\
Propagation of obligations and dispensation can be achieved via
subject-hierarchy. Dispensation derivation rules expressing
propagation via subject-hierarchy may have the following form:\\
{\ttfamily derhasObligation(s,a,q) 
hasObligation(s',a,q)  hie(s,s')} \\
{\ttfamily derhasObligation(s,a,q) 
derhasObligation(s',a,q)  hie(s,s')} \\
{\ttfamily derhasDispensation(s,a) 
hasDispensation(s',a)  hie(s,s')   \\
\indent\indent\indent\indent    } \\
{\ttfamily derhasDispensation(s,a) 
derhasDispensation(s',a)  hie(s,s')}


where  are {\ttfamily hasDispensation,
derhasDispensation, done}, - or - literals. All {\ttfamily
derhasDispensation} literals appearing in the body must be
positive.

Obligation derivation rules expressing
propagation via subject-hierarchy may have the  following form:\\
{\ttfamily derhasObligation(s,a,q) 
hasObligation(s',a,q)  \\
\indent \indent \indent \indent \indent \indent \indent \indent
\indent\indent hie(s,s')  } \\
{\ttfamily derhasObligation(s,a,q) 
derhasObligation(s',a,q)  \\
\indent \indent \indent \indent \indent \indent \indent \indent
\indent\indent hie(s,s')  } \\
where  are {\ttfamily hasObligation,
derhasObligation, derhasDispensation, done}, - or -
literals. All {\ttfamily derhasObligation} literals appearing in the
body must be positive.


\begin{example}
Let us assume that a security policy specifies that all employees
have an obligation to protect computers they own. A manager is a
type of an employee. Hence, managers have an obligation to protect
computers they own. This derivation rule is represented as follows: \\

\noindent
{\ttfamily derhasObligation(\s_1x), q) \&
\\ \indent isa(Manager, Employee) \& type(\s_2,N1) \& type(N1, Computer)}
\end{example}

\noindent
{\bf B. Derivation via action refinement}\\
New obligation rules and dispensation rules may be derived from a
high-level obligation or dispensation rule, by substituting the
action in high-level rule with its sub-actions as specified in
refinement pattern. We now discuss construction of derivation rules
based on basic and strict action composition operators.

Let {\ttfamily hasObligation(s,a,q)} be an obligation rule, and let  and  be the
sub-actions of . Then the given
obligation rule can be
refined into obligation rules for sub-actions as described below. \\


\noindent {\bf B.1 Distribution over sequence operator}\\ Let  be the refinement pattern for action of type
. An obligation rule to perform action  can be refined into
two obligations to perform sub-actions  and  with rules
of following form:\\
\noindent
{\ttfamily derhasObligation(s,,)}  \\
{\ttfamily derhasObligation(s,,)}  {\ttfamily done()  \& hasObligation(s,a,q)}\\
where . We constrain the post-condition
of first obligation action  to satisfy pre-conditions required
to perform second obligation action .



\noindent {\bf B.2 Distribution over choice operator}\\
Let  be the refinement pattern for action
of type . Let  be the rule that derives obligation to perform .
We know that if either  or  is performed the obligation
is satisfied. Therefore, an obligation rule to perform action 
can be refined into either of the following two obligation rules 
and . Application of this refinement pattern to a policy 
generates two refined policies  and . The rule
rule  in  is substituted with  and  to generate
 and  respectively.

\noindent
: \indent {\ttfamily derhasObligation(s,,q)  done()}  \\
: \indent {\ttfamily derhasObligation(s,,q) done()}\\


\noindent {\bf B.3 Distribution over conjunction operator}\\
When an action  is refined by an action composition of form
, we refine the policy in two steps. First, we
substitute  with the composition ,
where  and .
This allows us to apply action refinement mechanism for choice operator
as we described above. In second step, we refine actions 
and  in resulting policies using the action refinement
mechanism for sequence operator.




\subsection{Deriving Authorizations}

Security policies may also contain authorization rules in addition
to obligation and dispensation rules. Moreover, the policy
refinement mechanism presented in the previous section can be
extended by adding rules that derive permissions and prohibitions from
predicates defined in obligation specification strata. In this
section, we examine authorization rules that may contain obligations
and dispensations.

From the perspective of refining a security policy, an obligation to
perform an action suggests that the subject must have permission to
perform or execute the obligation action.

\begin{definition}(Authorization Rule)\\
An {\em authorization rule} is a rule of the form: \\
\indent \indent \indent {\ttfamily cando(o,s,<sign>a)}  \\
where  is a subject term,  is a signed action type,  is
either + or -, and  are {\ttfamily mustdo,
done}, - or - literals. \label{def:authorizationrule}
\end{definition}

\begin{example} Suppose an obligation decision rule is derived
saying that subject  is required to encrypt an object . To be
able to fulfill the obligation  must have permission to execute
 action or function. \\
{\ttfamily cando(Encrypt((target,x)), s, +execute)} \\
\indent \indent \indent{\ttfamily mustdo(s, Encrypt((target,x)), q)}
\label{eg:derivecando}
\end{example}

Obligation to perform an action can also imply prohibition to
perform certain actions. Prohibitions are represented by
authorization rules specifying a - sign for the action.

\begin{example}
Suppose subject  has an obligation to encrypt email messages that
contain confidential messages. To ensure compliance to this policy
rule, the policy-refinement procedure can add a rule disallowing 
to send email if its contents are confidential. Such a rule may be
expressed as
follows:\\
{\ttfamily cando(sendEmail((message,x)),s,-execute)  \\
\indent\indent  mustdo(s, Encrypt((target,x)),q) \& type(x,
EmailMessage) \& \\
\indent\indent  messagetype(x, PlainText) \&
hasClassification(x,Confidential)} \label{eg:deriveprohibition}
\end{example}

To perform an obligation action, the subject  may need
permissions on objects accessed by the obligation action. Objects
that are accessed but not modified are described by {\ttfamily
instrument} property of the class {\ttfamily Action}. Objects that
are accessed and modified by an action are described by {\ttfamily
resource} property of the class {\ttfamily Action}. An obligation to
perform an action can be refined into authorization rules for
instrument and resource objects as shown below: \\
 {\ttfamily cando(\\leftarrowr)}\\
 {\ttfamily cando(\\leftarrowi)}


Authorization derivation in this framework have definition same as
in FAF~{\cite{Jajodia01}}. It is given below to provide complete
description of this framework.

\begin{definition}(Authorization Derivation Rule)\\
An {\em authorization derivation} rule is of the form:\\
\indent\indent\indent {\ttfamily dercando(o,s,signa) }\\
where  is an object term,  is a subject term,   is an
action term,  sign is either + or -, and  are
either cando, over, dercando, done, hie-, or rel literals. All
dercando-literals appearing in the body of a derivation rule must be
positive. \label{def:authorizationderivationrule}
\end{definition}

Definition of authorization decision rules in our policy refinement
framework is different than that in FAF. FAF uses a closed policy
and creates a prohibition for all actions that are not explicitly
permitted. However, in policy refinement we assume that the
refinement of high-level policy may not generate all the positive
authorization rules that may be present in the low-level security
policy. We do require that all negative authorization rules generated
by policy refinement must be present in the low-level security
policy. We assume that the high-level policy does not contain
positive authorization rules, and the low-level policy may not override
positive authorizations derived from the high-level policy.

\begin{definition}(Authorization Decision Rule)\\
An {\em authorization decision} rule is of the form:\\
\indent\indent\indent {\ttfamily do(o,s,signa) }\\
where  is an object term,  is a subject term,   is an
action term,  sign is either + or -, and  are
either cando, dercando, done, hie-, or rel literals.
\label{def:authorizationdecisionrule}
\end{definition}


\subsection{Conflict Resolution}

Policy refinement must lead to decision whether a subject has an
obligation to perform an action or not. However, policies may
generate conflicting rules. For example, a subject may have an
obligation to perform an action  and can also have a dispensation
for action  at the same time. Conflict resolution rules are added
to deal with such situations.

A conflict resolution rule expressing that dispensations take
precedence can be of following form: \\
{\ttfamily derhasDispensation(s,a) 
  hasDispensation(s,a) \\
  \indent\indent\indent\indent\indent\indent\indent\indent\indent
  \indent\indent\indent\indent\indent\indent\indent\indent\indent
   hasObligation(s,a,q)  \& }

Conflict resolution rules that express obligation takes precedence
are expressed as obligation decision rules
(Def.~\ref{def:obligationdecisionrule})

\begin{definition}(Obligation Decision Rule)\\
An obligation decision rule is a rule of the form \\
\indent {\ttfamily mustdo(s,a,q) } \\
where  and  are elements of  and  respectively,  is
a system state, and  are {\ttfamily
hasObligation, derhasObligation, hasDispensation, derhasDispensation,
done}, - or - literals and every variable
that appears in any of the 's also appears in the head of this
rule. \label{def:obligationdecisionrule}
\end{definition}

Separation of duty requires that for a particular set of actions in
a transaction, no single individual be allowed to execute all
actions within the set. Separation of duty is often enforced with
access control policies.  In the policy refinement model presented
in this work, positive authorizations are derived from obligations.
A user must have permissions to perform actions he is obliged to do
as discussed above. However, the derived permissions must reflect
separation of duty requirements. Hence, the obligation and
dispensation rules must be modeled to handle separation of duties.

For example, if the separation of duties require that actions 
and  must not be performed by the same subject. A subject
obliged to perform  must be given dispensation on action .
In such cases, an additional obligation derivation rule can be
stated to specify alternate subject that will be required to
perform action  and complete the transaction successfully.

\noindent {\ttfamily derhasDispensation(s,) 
derhasObligation(s,,) } \\
\indent {\ttfamily derhasObligation(s,,)} \\
\noindent {\ttfamily derhasObligation(s',,) 
derhasDispensation(s,)}\\
where  is a subject term defined in body of the rule.

In addition, a policy may have modal authorization conflicts, i.e.,
policy refinement may generate both positive and negative
authorizations on same object for a subject. For example, policy
refinement may derive positive authorizations for a subject on
objects required to perform his/her obligations. However, there may
be another rule in the policy prohibiting access to the required
object. In this case, a conflict resolution rule may be defined to
allow the subject to access required objects. In general, conflict
resolution rules for authorizations are modeled as authorization
decision rules (Def.~\ref{def:authorizationdecisionrule}).


\begin{definition}(Decision View)\\
A decision view is a finite set of decision rules.
\end{definition}


\begin{definition}(Integrity Rule)\\
An integrity rule is of the following form:
\begin{center}
{\ttfamily error  }
\end{center}
where  are mustdo, hasObligation, derhasObligation,
hasDispensation, derhasDispensation, do, cando, dercando, done,
hie-, and rel- literals.
\end{definition}

\begin{definition}(Policy) \\
\noindent A {\em policy}  is a set of rules  characterized by its scope  and environment ,
where  is a set of obligation rules and dispensation rules, 
is a set of authorization rules, and  is a set of propagation
rules, conflict resolution rules, and integrity rules. Scope
specifies set of target objects to which the policy is applicable,
and environment specifies compliance verification context
information like date, time, location, subject, etc.
\label{def:policy}
\end{definition}


\begin{example} Let us now consider an example illustrating
application of derivation rules, and decision rules for policy
refinement. Consider the following security policy:

\noindent {\ttfamily hasObligation(\x)),
true)  \\
\indent\indent\indent\indent type(\s,\x, Computer)}

\noindent {\ttfamily hasDispensation(\x)))  \\
\indent\indent\indent\indent type(\s,\x,Computer) \& \\
\indent\indent\indent\indent hasRole(\s, \q) 
 derhasObligation(\a, \\negs, \x)) 
 InstallFirewall((target, \\wedgex))}

\noindent
Let the following predicates hold in system state:\\
{\ttfamily type(Alice, Employee), hasRole(Alice, Manager), \\
 owns(Alice, NB1), type(NB1, Computer)}

To refine the security policy, we first apply the derivation rules to
derive all predicates in stratum , followed by derivation of
all predicates in stratum , and so on. We first, evaluate the
variables in obligation rules and dispensation rules using the
system state. For above security policy, following rules are
derived after evaluation:

\noindent {\ttfamily hasObligation(Alice, Protect((target, NB1)),
true)  \\
\indent\indent\indent type(Alice, Employee)
                     \&  owns(Alice,NB1) \& type(NB1, Computer)}

\noindent {\ttfamily hasDispensation(Alice, InstallFirewall((target,
NB1)))  \\
\indent\indent\indent type(Alice, Employee) \& owns(Alice,NB1)
                       \& type(NB1,Computer) \\
\indent\indent\indent  \& hasRole(Alice, Manager)}

We now apply derivation rules, e.g., derivation rules for policy
refinement by action refinement. By refining action protect, we
obtain following rules:

\noindent {\ttfamily derhasObligation(Alice,
InstallFirewall((target, NB1)), true)  \\
\indent\indent\indent type(Alice,Employee) \& owns(Alice,NB1) \&
type(NB1, Computer)}

\noindent {\ttfamily derhasObligation(Alice,
InstallAntiVirus((target, NB1)), true)  \\
\indent\indent\indent type(Alice, Employee) \& owns(Alice,NB1)
 \& type(NB1, Computer)}

No new predicates can be further derived in this level. Hence, we
now apply the decision rules to obtain predicates in higher stratum.
Since, both predicates
{\ttfamily derhasObligation(Alice,
Install}-{\ttfamily Firewall((target, NB1)), true)} and {\ttfamily
derhasDispensation(Alice, InstallFirewall} {\ttfamily ((target, NB1)))} hold, a
{\ttfamily mustdo} predicate for Alice to perform the action
{\ttfamily InstallFirewall} cannot be derived. However,  a
{\ttfamily mustdo} predicate for {\ttfamily InstallAntiVirus} action
is derived from the following instance of decision rule:

\noindent \ttfamily{mustdo(Alice, InstallAntiVirus((target,
NB1)),true)  \\
\indent\indent\indent derhasObligation(Alice,
InstallAntiVirus((target, NB1)),true)  \\
\indent\indent\indent \&  derhasDispensation(Alice,
InstallAntiVirus((target, NB1)))}
\end{example}


\section{Compliance}
\label{sec:checking}

To check compliance, we compare a high-level security policy
with a low-level security policy in context of a data system.
The set of {\ttfamily do} and {\ttfamily mustdo} ground predicates
that can be derived from a security policy and a data system is
called ground decision view.

\begin{definition}(Compliance)\\
A low-level policy  is {\em compliant} to a higher-level policy
 for a given ,  if there exists a , such
that  , where  is the data
system,  represents the ground decision view of low-level
security policy, and  represents the ground decision
view of refined high-level security policy. We assume that  does
not contain any positive authorization rules \label{def:compliance}
\end{definition}

\begin{algorithm}[!hb]
\scriptsize \dontprintsemicolon

\SetKwInOut{Input}{input} \SetKwInOut{Output}{output}

\SetKwData{DataSystem}{DS} \SetKwData{Onotology}{O}
\SetKwData{HLP}{} \SetKwData{LLP}{}
\SetKwData{Patterns}{RP} \SetKwData{State}{}

\Input{ High-level security policy \HLP, Low-level security policy \LLP, Data System \DataSystem, Refinement Patterns \Patterns, Current State \State}
\Output{true if \LLP and \State are compliant to \HLP, otherwise
false}

\BlankLine

// Generate ground decision view of  give a data system  \;


 Evaluate the variables in \LLP.\;

Instantiate the variables in \LLP to derive ground rules. \;

Apply derivation rules and conflict resolution rules until no new
fact is generated. \;

Apply Integrity rules. If errors are found report that policy \LLP
is inconsistent. \;



\BlankLine
// Generate all ground decision views of  given a data system  \;
// Note that multiple decision views may be derived from \HLP. \;


Evaluate the variables in \HLP.\;

\Repeat{no new fact is generated}{

 Instantiate the variables in \HLP to derive ground rules. \;

Apply derivation rules, and conflict resolution rules until no new
fact is generated. \;

Apply Integrity rules. If errors are found report that policy \HLP
is inconsistent. \; }



 \BlankLine
// Compare ground decision views, which consists of authorization
 obligation decision views. \;

compliant  false \;


\ForEach{decision view derived from \HLP}{

    found  true \;

    // Compare authorization decision views. \;
    Let  be the set of {\ttfamily do} predicates derived from \HLP
    and are applicable in \DataSystem and current state \State. \;

    Let  be the set of {\ttfamily do} predicates derived from \LLP
    and are applicable in \DataSystem and current state \State. \;

    \If{  }{
        found  false \;
    }



    \BlankLine

    // Compare obligation decision views \;

    Let  be the set of {\ttfamily mustdo} predicates derived from \HLP
    and are applicable in \DataSystem and current state \State. \;

    Let  be the set of {\ttfamily mustdo} predicates derived from \LLP
    and are applicable in \DataSystem and current state \State. \;

    (Note that \LLP may have no means to enforce obligations or \LLP may not
      contain obligations. In such cases, we consider  to be empty and check
      for satisfaction of obligations in .) \;

      \ForEach{predicate {\ttfamily mustdo(s,a,q)} in }{
        Let  be the effect of action  asserted by ontology. \;
        Compute  by evaluating {\ttfamily effect(a, )} given data system \DataSystem \;
        \If{not (({\ttfamily mustdo(s,a,q)} in ) OR (\State  and \State ))}{
            found  false \;
        }
      }

    compliant  compliant OR found \;
      \If{compliant}{break\;}

}

\Return compliant \;

\caption{Compliance checking algorithm} 
\label{alg:compliance}
\end{algorithm}

Algorithm~\ref{alg:compliance} describes the steps needed to 
check compliance of a give low-level policy and system state
to a given high-level policy. 
First, the algorithm decision view of low-level security policy. 
The low-level policy is a stratified logic program and can be 
evaluated in polynomial time~\cite{Jajodia01}. We then refine the 
high-level policy. The refinement process can lead to multiple
refinements of high-level policies due to action refinement over
the choice choice operator () and conjunction operator 
(). The process of refining low-level policies is analogous 
to a top-down tree traversal, where each internal node of the tree
represents the refinement stage at which an action is refined into a 
composition with choice operator or conjunction operator. The leafs 
of the tree represent derivation of refined policies with atomic actions.
Therefore, the complexity of the policy refinement can be seen
as exponential in terms of height of this evaluation tree, which 
corresponds to number of time action refinement has to be 
applied to reach atomic actions. Finally, the algorithm checks for
compliance by searching for a refinement of high-level policy such 
that all the access control and obligation requirements
specified in the refined policy are satisfied
by the low-level policy or current system state. 

A given refinement of high-level policy and low-level policy can 
also be compared to detect conflicts among them. 
We categorize conflicts between a (high-level) security policy and
system state (low-level policy and object properties) into following
four categories:

\begin{definition}(Modal Authorization Violations)\\
A modal violation occurs when a high level policy has granted
authorization but a low level policy denies authorization.\\
\noindent Let  be a authorization decision rule  in refinement of high level
policy , and  be an authorization decision rule  in low-level policy .
 and  have a modal conflict if 
and  can be true simultaneously for any system
state .
\end{definition}

A modal authorization violation may be modeled with rules of
following form:

 {\ttfamily error 
(() do(, , )) 
(() do(, , )) }

\begin{definition}(Obligation Violations)\\
An obligation violation occurs, when a subject either does not
perform his or her obligations or does not perform obligations
correctly.\\
 \noindent Let  be an obligation decision rule, where  is a subject, 
is an action,  is a post condition, and  is
a precondition. Let  be an effect of action  asserted by the
ontology. When  holds but  is not
satisfied, an obligation violation is indicated.
\end{definition}

We assume that prior to the time of compliance checking the subject
had sufficient time to perform obligations satisfactorily. Detection
of obligation violation may be modeled with rule of following form:

{\ttfamily error  }

\begin{definition}(Resource Capability Conflict)\\
Resource capability conflict occurs when resources required to
perform an obligation does not exist.
\end{definition}

Let  be a data system, where  is an ontology and  is
set of objects in the system. A resource capability conflict may be
modeled with rules of following form:

{\ttfamily error  mustdo(s,a,q)  resource(a,r) 
(r )}

\begin{definition}(Modal Capability Conflict)\\
Modal capability conflict occurs when an obligation requires access
to certain resources, and the subject does not have the requisite
permissions.
\end{definition}

{\ttfamily error  mustdo(s,a,q) \&
do(a,s,+execute)}

\begin{theorem}
Obligation and Authorization specification is a locally stratified
logic program, thus preserves the desirable properties given in
Theorem 1 of~\cite{Jajodia01}.
\end{theorem}
\begin{myproofsketch} Authorization specification language has been
extended by introducing new predicates. Table~\ref{table:strata}
shows that all atoms in the specification can be assigned a rank
such that no atom depends on an atom of greater rank or depends
negatively on one on equal or greater rank in any instantiated rule.
Proof of this theorem is similar to the proof of Theorem 1
of~\cite{Jajodia01}.
\end{myproofsketch}


We assume that the high-level policy does not contain positive
authorization rules. Any authorizations derived from  must be
derived from obligation and derivation rules. If    then low-level security policy is prohibiting some
users from performing their obligations. This is a case of modal
capability conflict and the algorithm correctly returns false.

Obligations derived from the high-level security policy must occur
in a compliant low-level policy or the obligations must have been
satisfied. If the obligation is satisfied, the obligation
postcondition must be true and the effect of obligation action must
also be true. The compliance checking algorithm returns false, when
both the above conditions are not satisfied.

\begin{theorem}
Compliance checking algorithm (Alg.~\ref{alg:compliance}) terminates
and the algorithm returns false if low-level security policy and
system state is not compliant with the high-level security policy.
\end{theorem}
\begin{myproofsketch} The compliance checking algorithm computes decision
view of the high-level and low-level policy by evaluating their
obligation and authorization specifications, which are locally
stratified logic programs. The herbrand base of the obligation and
authorization specification is finite. Also, the variables used in
the rule head are bounded by the variables in the body of the rule.
The policy refinement process performs substitution of rules in the 
high-level policy until actions can not be further refined. Action refinements
in our framework cannot contain loops as the refinement are always
more specific. Therefore the number of times action refinement may
be performed is finite. We consider a finite DS, thus only a 
finite number of instantiations may occur; 
therefore Alg.~\ref{alg:compliance} terminates.

If the low-level security policy violates the high-level security
policy, the algorithm detects the violation and returns false. This
is proved by contradiction. Let us assume that the low-level
security policy  violates high-level security policy  and
the compliance checking algorithm returns true. The algorithm can
return true only if 1) , and 2) for every
mustdo(s,a,q) predicate in , either mustdo(s,a,q) is in 
or ( and ). The
decision views () and  contain only
ground mustdo and do predicates. If ( and
), the obligation  has already been
satisfied in . As discussed the remainder of mustdo and do
predicates also occur in . Hence, the low-level
security policy is compliant to high-level security policy. This is
in contradiction to initial assumption.
\end{myproofsketch}




\section{Conclusions}
\label{sec:conclude} In this paper we proposed a framework and
techniques to evaluate whether a low-level, implemented security
policy is compliant to a high-level policy.  Our method uses
organizational and security meta-data and a set of well-defined
operations to generate valid refinements of a given high-level
policy.  The implemented policy is compared to these refinements to
verify whether it is compliant to the high-level policy.  The
correctness of the compliance is based on the properties of the
refinement, that is the well-formedness of the refinement operators
and the validity of the compositions.

Although the basic concept presented in this work have been proposed
and used in other fields of research and development, e.g., software
engineering and programming languages, their relevance for
information security have not yet been fully evaluated.  Our aim is
to build upon these technologies to establish formal properties of
security policies.  This work constitutes our initial efforts on
incorporating results from software
refinement~\cite{Dijkstra71,Wirth71}, requirement analysis, and
process
algebra~\cite{Baeten90,Bergstra84,Bergstra85,Hoare78,Hoare85,Milner82,Glabbeek01}
in security policy verification. Our ongoing work includes analysis
of more complex policy refinements, usage of extensive
organizational meta-data, and bottom-up compliance verification. Our
goal is to develop methods and tools that will aid and simplify the
human evaluation process for compliance checking.


\section{Acknowledgements}
\noindent This work was partially supported by National Science
Foundation grant number IIS-0237782 and an IBM Summer Internship.
We would like to express our gratitude and thanks to Duminda
Wijesekera for his valuable comments and suggestions on policy
languages, refinement, and obligations.

\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,master}

\end{document}
