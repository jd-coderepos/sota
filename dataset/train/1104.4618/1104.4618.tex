\documentclass[11pt,a4paper]{article}

\usepackage{a4wide,url}
\usepackage{graphicx,amssymb,amsmath,amsthm,color}

\graphicspath{{figures/}{}}


\newtheorem{definition}{Definition}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{proposition}[definition]{Proposition}
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{corollary}[definition]{Corollary}
\newtheorem{observation}[definition]{Observation}


\renewcommand{\topfraction}{0.9}	\renewcommand{\bottomfraction}{0.8}	\renewcommand{\floatpagefraction}{0.8}	\renewcommand{\dblfloatpagefraction}{0.8}	


\newcommand{\complain}[1]{\marginpar{{\color{red} ****}}{\color{red}\sf ***~~#1 ***}}

\def\Reals{\ensuremath{\mathbb{R}}}
\def\RR{\ensuremath{\mathbb{R}}}
\def\ZZ{\ensuremath{\mathbb{Z}}}
\def\SS{\ensuremath{\mathbb{S}}}
\def\A{\ensuremath{\mathcal{A}}}
\def\I{\ensuremath{\mathbb{G}}}
\def\cycle{\ensuremath{\tau}}
\def\true{{\rm T}}
\def\false{{\rm F}}

\newcommand\segment[1]{\ensuremath{\overline{#1}}}
\def\cut{{\rm cut}}

\DeclareMathOperator{\lengthBIS}{len}
\newcommand\length{\lengthBIS_{\I}}

\DeclareMathOperator{\reverse}{reverse}
\DeclareMathOperator{\lca}{lca}
\DeclareMathOperator{\polylog}{polylog}




\begin{document}
\pagestyle{plain}

\title{Minimum cell connection and separation\\ in line segment arrangements\thanks{Part of the results contained here were presented at EuroCG 2011~\cite{acgk-11}. Research partially conducted at the 9th McGill - INRIA Barbados Workshop on Computational Geometry, 2010.}}

\author{Helmut Alt\thanks{Institut f{\"ur} Informatik, Freie Universit{\"a}t Berlin,
    Takustra{\ss}e 9, D-14195 Berlin, Germany, {\tt \{alt, panos\}@mi.fu-berlin.de}}
    \footnote{Research supported by the German Science Foundation (DFG) under grant Kn~591/3-1.}
\and
Sergio Cabello\thanks{Department of Mathematics, IMFM and FMF, University of Ljubljana,
                Jadranska 19, SI-1000 Ljubljana, Slovenia, {\tt sergio.cabello@fmf.uni-lj.si.}}
       \footnote{Research was partially supported by the Slovenian Research Agency, program P1-0297.}
\and
Panos Giannopoulos\footnotemark[2]{\ }\footnotemark[3]
\and
Christian Knauer\thanks{Institut f{\"ur} Informatik, Universit{\"a}t Bayreuth
    Universit{\"a}tsstra{\ss}e 30
    D-95447 Bayreuth
    Germany, {\tt christian.knauer@uni-bayreuth.de}}{\ }\footnotemark[2]
}
\date{}
\maketitle

\begin{abstract}
We study the complexity of the following cell connection and separation problems in segment arrangements.
Given a set of straight-line segments in the plane and two points  and  in different cells of the induced arrangement:
\begin{itemize}
\setlength{\itemsep}{-\parsep}
\item[(i)] compute the minimum number of segments one needs to remove so that there is a path connecting  to  that does not intersect any of the remaining segments;
\item[(ii)] compute the minimum number of segments one needs to remove so that the arrangement induced by the remaining segments has a single cell;
\item[(iii)] compute the minimum number of segments one needs to retain so that any path connecting  to  intersects some of the retained segments.
\end{itemize}

We show that problems (i) and (ii) are NP-hard and discuss some special, tractable cases. Most notably, we provide a linear-time algorithm for a variant of problem (i) where the path connecting  to  must stay inside a given polygon  with a constant number of holes, the segments are contained in , and the endpoints of the segments are on the boundary of .
For problem (iii) we provide a cubic-time algorithm.
\end{abstract}

\section{Introduction}

In this paper we study the complexity of some natural optimization problems in segment arrangements. Let  be a set of straight-line segments in ,  be the arrangement induced by , and  be two points not incident to any segment of  and in different cells of .

In the {\sc -Cells-Connection} problem we want to compute a set of segments  of minimum cardinality with the property that  and  belong to the same cell of . 
In other words, we want to compute 
an - path that \emph{crosses} the minimum number of segments of  counted without multiplicities.
The \emph{cost} of a path is the total number of segments it crosses.

In the {\sc All-Cells-Connection} problem we want to compute a set  of minimum cardinality such that  consists of one cell only.

In the {\sc -Cells-Separation} problem we want to compute a set  of minimum cardinality that \emph{separates}  and , i.e.,  and  belong to different cells of  -- equivalently -- any - path intersects some segment of . 

Apart from being interesting in their own right, the problems we consider here are also natural abstractions of problems concerning sensor networks. Each segment is surveyed (covered) by a sensor, and the task is to find the minimum number of sensors of a given network over some domain that must be switched on or off so that: an intruder can be detected when walking between two given points ({\sc -Cells-Separation}), or can walk freely between two given points ({\sc -Cells-Connection}) or can reach freely any point ({\sc All-Cells-Connection}). Because of these applications, it is worth considering a variant where the segments lie inside a given polygon  with holes and have their endpoints on the boundary of , and the - path must also stay inside . See Fig.~\ref{fig:polygon} for an example of this last scenario. We refer to these variants as the restricted {\sc -Cells-Separation} or {\sc -Cells-Connection} in a polygon.

\medskip
\noindent
{\bf Our results.} We provide an algorithm that solves {\sc -Cells-Separation} in  time, where  is the number of pairs of segments that intersect. The same algorithm, with an extra logarithmic factor, works for a generalization where the segments are weighted. The algorithm itself is simple, but its correctness is not at all obvious. We justify its correctness by considering an appropriate set of cycles in the intersection graph and showing that it satisfies the so-called \emph{3-path condition}~\cite{t-egsnc-90} (see also \cite[Chapter 4]{mt-gs-01}). The use of the 3-path condition for solving {\sc -Cells-Separation} is surprising and makes the connection to topology clear. 

We show that both {\sc -Cells-Connection} and {\sc All-Cells-Connection} are NP-hard even when the segments are in general position. The first result is given by a careful reduction from {\sc Max--Sat}, which also implies APX-hardness. The second one follows from a straightforward reduction that uses a connection to the feedback vertex set problem in the intersection graph of the segments and holds even if there are no proper segment crossings. Also, when any three segments may intersect only at a common endpoint, {\sc -Cells-Connection} is fixed-parameter tractable with respect to the number of proper segment crossings. 

Finally, we consider the restricted problems in a polygon. The restricted {\sc -Cells-Separation} in a polygon is easily reduced to the general weighted version and thus can be solved efficiently. The restricted {\sc -Cells-Connection} in a polygon remains NP-hard but can be solved in near-linear time for any fixed number of holes. The approach for this latter result uses homotopies to group the segments into clusters with the property that any cluster is either contained or disjoint from the optimal solution. 

\begin{figure}[t]
\centering
\includegraphics[width=0.47\textwidth]{polygon}
\caption{A polygon with holes and a minimum-cost - path.}
\label{fig:polygon}
\end{figure}

\medskip
\noindent
{\bf Related work.} Our NP-hardness proof for {\sc -Cells-Connection} has been carefully extended by Kirkpatrick and Tseng~\cite{tseng-thesis}, who showed that the {\sc -Cells-Connection} remains NP-hard even for \emph{unit-length} segments. However, their result does not imply APX-hardness for unit-length segments. 
The related problem of finding (from scratch) a set of segments with minimum total length that forms a barrier between two specified regions in a polygonal domain has been shown to be polynomial-time solvable by Kloder and Hutchinson~\cite{KH07}.

The problems we consider can of course be considered for other geometric objects, most notably unit disks. To this end, closely related work was done by Bereg and Kirkpatrick~\cite{BK09}, who studied the counterpart of {\sc -Cells-Connection} in arrangements of unit disks and gave a -approximation algorithm.  While the complexity of {\sc -Cells-Connection} for unit (or arbitrary) disks is still unknown, there exist polynomial-time algorithms for restricted belt-shaped and simple polygonal domains~\cite{KLA07}. Simultaneously and independently to our work, Gibson et al.~\cite{gkv-ipud-11} have considered the problem of separating  points in an arrangements of disks and provided a polynomial-time -approximation algorithm. Their approach is based on building a solution by considering several instances {\sc -Cells-Separation} on arrangements of disks, which they can solve approximately.



\section{Separating two cells}

In this section we provide a polynomial-time algorithm for {\sc -Cells-Separation}.
We will actually solve a weighted version, where we have a weight function  assigning 
weight  to each segment . For any subset  we define its weight
 as the sum of the weights over all segments . 
The task is to find a minimum weight subset  that separates two given points  and .
Our time bounds will be expressed as a function of , the number of segments in ,
and , the number of pairs of segments in  that intersect.
We first describe the algorithm, and then justify its correctness.

We assume for simplicity of exposition that the segment  is vertical
and does not contain any endpoint of  or any vertex of .

Let  be a polygonal path contained in , possibly with self-intersections.
Because of our assumption on general position, no vertex
of  is on the segment .
We define  as the number of oriented intersections
of  with : a crossing where  goes from the left to the right of 
contributes  to ,
while a right-to-left crossing contributes  to .
We have .

In a graph, we will use the term \emph{cycle} for a closed walk without repeated vertices.
A polygonal path is \emph{simple} if it does not have self-intersections.

\subsection{The algorithm}
\label{sec:algorithm}

From  we construct its intersection graph 
.
See Fig.~\ref{fig:intersectiongraph}(a)-(b). 
Note that  has  edges.
To each edge  of  we attach a weight (abstract length) .
Any distance in  will refer to these edge weights.
For any walk  in  we use  for its length, that is, the sum of the weights on its edges
counted with multiplicity, and  for the set of segments along .
For any spanning tree  in  and any edge ,
let  denote the cycle obtained by concatenating the edge  with 
the path in  connecting both endpoints of . 
(The actual orientation of  will not be relevant.)

\begin{figure}
\centering
	\includegraphics[width=\textwidth]{intersectiongraph}
	\caption{(a) A set of segments . 
			(b) The corresponding intersection graph  with some of its edge-weights.
			(c) The polygonal path  for the walk .
			(d) The closed polygonal path  for the closed walk .}
	\label{fig:intersectiongraph}
\end{figure}	

Consider any walk  in .
This walk defines a polygonal path, denoted by , 
which has vertices ,
where  for . 
If  is a closed walk with , then we take  to be 
a closed polygonal path whose last edge is , which is contained in .
See Fig.~\ref{fig:intersectiongraph}(c)-(d). 
The polygonal path  is contained in .
Note that even if  is a cycle
the closed polygonal path  may have self-intersections.

For any segment , let  be a shortest-path tree in  from ;
if there are several we fix one of them.
We will mainly use polygonal paths arising from cycles ,
where .
Thus we introduce the notation .
(Again, the actual orientation of  will not be relevant.)

The algorithm is the following. We
compute the set

choose

and return .
This finishes the description of the algorithm.
For analyzing it, it will be convenient to use the notation
 and  for the polygonal path . 

The algorithm, as described above,
can be implemented in  time in a straightforward way.
We can speed up the procedure to obtain the following result.

\begin{lemma}\label{le:time}
	The pair  can be computed in  time.
\end{lemma}
\begin{proof}
	The graph  can be constructed explicitly in  time by checking
	each pair of segments, whether they cross or not.
	Recall that  has  edges.

	For any segment , let us define
	
	Note that 
	
	and therefore 
	
	Thus,  can be computed by finding, for each ,
	the value 
	
	We shall see that, for each fixed
	, such value  
	can be computed in  time. 
	It then follows that   can be found in 
	 time.	
	
	\begin{figure}
	\centering
		\includegraphics[width=\textwidth]{intersectiongraph2}
		\caption{(a) Tree  for the scenario of Fig.~\ref{fig:intersectiongraph} assuming unit weights in the segments. 
				In this case  and .
			(b) The polygonal paths  and .
			(c) The polygonal paths  
				and  that are used to compute 
				in Lemma~\ref{le:time}.
			}
	\label{fig:intersectiongraph2}
	\end{figure}
	
	For the rest of the proof, let us fix a segment . 
	Computing  takes  time. 
	For any segment , , let  denote the path in  from  
	to . We define  
	and define  to be the child of  in the path .
	See~Fig.~\ref{fig:intersectiongraph2}(a)--(b).
	The values , , can be computed in  
	time using a BFS traversal of : 
	if  is the parent of  in , we can compute 
	from  in  time using  
	
	Similarly , , can be computed in  time:
	we assign  for all children  of  and use
	that  for any  not adjacent to .
	
	For  we have that  is equal to
	
	See~Fig.~\ref{fig:intersectiongraph2}(b)--(c).
	(The negative sign comes from the reversal of .)
	Therefore, each  can be computed in  time from the values , , , .
	It follows that  can be constructed in  time.
	
	The length of any cycle  can be computed in  time per cycle in a similar fashion.
	For each vertex , we store at  its distance  from the root .
	We also construct a data structure for finding lowest common ancestor () of two vertices in constant
	time. Such data structure can be constructed in  time~\cite{lca1,lca2}. The length of a cycle can then be recovered using
	
	Equipped with this, we can in  time compute
	
\end{proof}

The following special case will be also relevant later on.
\begin{lemma}\label{le:time2}
	If the weights of the segments  are  or , 
	then the pair  can be computed in  time.
\end{lemma}
\begin{proof}
	In this case, a shortest path tree  can be computed 
	in  time
	because the edge weights of  are , , or .
	Using the approach described in the proof of Lemma~\ref{le:time} we spend  per root ,
	and thus spend  in total.
\end{proof}

\subsection{Correctness}

Consider the set of closed walks
 
We have the following property, known as 3-path condition.

\begin{lemma}\label{le:3-path}
	Let  be 3 walks in  from  to . For ,
	let  be the closed walk obtained by concatenating  and the reverse of ,
	where indices are modulo 3.
	If one of the walks  is in , then at least two of them are in .
\end{lemma}
\begin{proof}
	\begin{figure}
	\centering
		\includegraphics[width=\textwidth]{3pathcondition}
		\caption{(a) Scenario in the proof of Lemma~\ref{le:3-path}.
			(b) The polygonal path .
            (c) The polygonal paths  and . (The bottom of  lies on . We draw it outside because of the common part with .)}
	\label{fig:3pathcondition}
	\end{figure}
	(This result is a consequence of the group structure for relative -homology. 
	We provide an elementary proof that avoids using homology.)
	For , let  be the starting vertex of the polygonal path 
	and let  be the ending vertex.
	The polygonal paths  
	start on  and finish on .
	However, they may have different endpoints.
	See Fig.~\ref{fig:3pathcondition}.
	To handle this, we choose a point  on  and a point  on ,
	and define  to be the polygonal path obtained
	by the concatenation of , , and . 
A simple but tedious calculation shows that, using indices modulo 3,
	
	Indeed, since
	
	and 
	
	we have 
	
	It follows that, using indices modulo ,
	
	Therefore, if  for some , at least another cycle , ,
	must have .\qedhere
\end{proof}

When a family of closed walks satisfies the 3-path condition, there is a general method to find a shortest element in the family.
The method is based on considering fundamental-cycles defined by shortest-path trees, which is
precisely what our algorithm is doing specialized for the family . 
We thus obtain:

\begin{lemma}\label{le:shortest}
	The cycle  is a shortest element of .
\end{lemma}
\begin{proof}
It is a consequence of the 3-path condition, 
	that a shortest cycle in 
	
	is a shortest cycle in . That is, the search for a shortest element in 
	can be restricted to cycles of the type .
	See Thomassen~\cite{t-egsnc-90} or the book by Mohar and Thomassen~\cite[Chapter 4]{mt-gs-01} 
	for the so-called fundamental cycle method. 
	(The method is described for unweighted graphs but it also works for weighted graphs.
	See, for example, Cabello et al.~\cite{ccl-fsntc-10} for the generalized case of weighted, directed graphs.)
\end{proof}

The next step in our argument is showing that  is simple (without self-intersections) 
and separates  and .
We will use the following characterization of which simple, closed  
polygonal paths separate  and . 

\begin{lemma}\label{le:jordan}
	For any simple, closed polygonal path  we have .
	Furthermore,  separates  and  if and only if .
\end{lemma}
\begin{proof} 
	Since  is simple, it defines an interior and an exterior by the Jordan curve theorem.
	The crossings between  and , as we walk along ,
	alternate between left-to-right and right-to-left crossings because  has
	pieces alternating in the interior and exterior of .
	Therefore .
	
	Assume that  separates  and , so that one is in the interior of 
	and the other in the exterior.
	Then the segment  crosses  an odd number of times, and it must be 
	. Conversely, if , then the number of intersections between
	 and  is odd, which implies that one of the points  and  is in the interior
	of  and the other in the exterior.
\end{proof}

We can now prove that  is simple using a standard uncrossing argument.
Indeed, a self-crossing of  would imply that we can find a strictly 
shorter element in , which would contradict the property stated in Lemma~\ref{le:shortest}.

\begin{lemma}\label{le:feasible}
	The polygonal path  is simple and separates  and .
\end{lemma}
\begin{proof}
Assume, for the sake of contradiction, that  is not simple.
	It is then possible to show the existence of two cycles  and  in  such that
	,
	,
	and ,
	as follows.
	
	\begin{figure}
		\centering
			\includegraphics[width=0.8\textwidth]{partition}
			\caption{The polygonal paths defined by the cycles  and  from the cycle  in Lemma~\ref{le:feasible}.}
			\label{fig:partition}
	\end{figure}	

	Let , with , be the cycle .
	Start walking along  from , until we find the first self-intersection,
	which is defined by segments  and , with .
	Note that  because  and  cannot define a self-intersection of .
	Consider the cycles 
	and . See Fig.~\ref{fig:partition}.
	Note that
	
	because the polygonal paths  and  form a disjoint partition
	of , with orientations preserved.
	Moreover, because  and  is a cycle,
	we have  and .
	This finishes the proof of existence of  and .

	Because  we have 
	
	Therefore,  for some . 
	Since  and ,
	then . This contradicts the property that  is a shortest
	cycle of  (Lemma~\ref{le:shortest}).
	We conclude that  must be simple.
		
	Since  is simple,  by Lemma~\ref{le:jordan}.
	Since , then , which implies .
	It then follows from Lemma~\ref{le:jordan} that  separates  and .\qedhere	
\end{proof}

We can now prove the main theorem.
\begin{theorem}\label{thm:separation}
	The weighted version of {\sc 2-Cells-Separation} can be solved in  time,
	where  is the number of input segments and  is the number of pairs of segments that intersect.
\end{theorem}
\begin{proof}
	We use the algorithm described in Section~\ref{sec:algorithm}.
	The algorithm returns a feasible solution because of Lemma~\ref{le:feasible}:
	the cycle  separates  and  and
	is contained in , therefore, 
	the set  returned by the algorithm separates  and .
	
	To see the optimality of the weight of , consider an optimal solution .
	Assume that we run the algorithm on .
	The algorithm would compute a cycle  in the intersection graph of the segments 
	and return . By Lemma~\ref{le:feasible},
	the polygonal path  is simple and separates  and .
	Lemma~\ref{le:jordan} implies that ,
	and therefore  (here  refers to the original problem, rather than the subproblem
	defined by input ).
	
	For any cycle  of  we have  because of the choice of the edge-weights in . 
	Since  is a shortest cycle in  by Lemma~\ref{le:shortest},
	we have
	
	It follows that  is a feasible solution whose weight is not larger than ,
	and therefore it is optimal.
	The running time follows from Lemma~\ref{le:time}.
\end{proof}


\begin{corollary}\label{co:separation}
	The weighted version of {\sc -Cells-Separation} in which the segments have weights  or  
	can be solved in  time,
	where  is the number of input segments and  is the number of pairs of segments that intersect.
\end{corollary}
\begin{proof}
	In the proof of the previous theorem we use Lemma~\ref{le:time2} instead of Lemma~\ref{le:time}.
\end{proof}

In the case where the segments of  are unweighted, the points  are inside a polygon  with holes, and the - path must be contained in the interior of , the problem can be easily solved by 
assigning weight 0 to the edges  of the polygon 
and weight  to the segments in . 
We can then apply Corollary~\ref{co:separation} on , and obtain the following.

\begin{corollary}
The restricted {\sc -Cells-Separation} problem in a polygon with holes can be solved in  time, where  is the total size of the input
and  is the number of pairs of segments in  that intersect.
\end{corollary}



\section{Connecting two cells}
\label{2cells}

We show that {\sc -Cells-Connection} is NP-hard and APX-hard by a reduction from {\sc Exact-Max--Sat}, a well studied NP-complete and APX-complete problem(c.f.~\cite{Hastad01}):
Given a propositional CNF formula  with  clauses on  variables and exactly two variables per clause, decide whether there exists a truth assignment that satisfies at least  clauses, for a given , .
Let  be the variables of ,  be the number of appearances of variable  in , and ; since each clause contains exactly 2 variables, . The maximum number of satisfiable clauses is denoted by .
Using  we construct an instance consisting of a set of segments  and two points  and  as follows.

Abusing the terminology slightly, the term \emph{segment} will refer to a set of identical single segments stacked on top of each other. The cardinality of the set is the \emph{weight} of the segment. Either all or none of the single segments in the set can be crossed by a path. 
There are two different types of segments, , and , according to their weight. Segments of type  have weight  (light or single segments), while segments of type  have weight  (heavy segments). The weight of heavy segments is chosen so that they are never crossed by an optimal - path.

\begin{figure}
\centering
\includegraphics[width=.43\textwidth]{idea_construction}
\caption{Idea of the construction with curved segments.}
\label{idea}
\end{figure}

We first provide an informal, high-level description of the construction that uses \emph{curved} segments. Later on, each curved segment will by replaced by a collection of straight-line segments in an appropriate manner. See Fig.~\ref{idea}. We have a rectangle  made of heavy segments, with point  at a lower corner and  at an upper corner. For each variable  we add a small vertical segment of type  in the lower half of .
From the segment we place  horizontal light segments, denoted by , going to the right and  horizontal light segments, denoted by , going to the left until they reach the outside of . Roughly speaking, (things are slightly more complicated)
an optimal - path will have to choose for each  whether it crosses all segments in , encoding the assignment , or all segments in , encoding the assignment .
Consider a clause like , where both literals are positive.  We prolong one of the segments of  and one of the segments of  with a curved segment so that they cross again inside  (upper half) in such a way that an - path inside  must cross one of the prolongations, and one is enough; see Fig.~\ref{idea}, where one of the prolongations passes below . A clause like  is represented using prolongations of one segment from  and one segment of . The other types of clauses are symmetric. For each clause we always prolong different segments; since  and  have  segments, there is always some segment that can be prolonged. It will then be possible to argue that the optimal - path has cost . 
We do not provide a careful argument of this here since we will need it later for a most complicated scenario. This finishes the informal description of the idea.

We now describe in detail the construction with straight-line segments.
First, we construct a polygon, called the \emph{tunnel}, with heavy boundary segments of type ; see Fig.~\ref{chain}(a).  
The tunnel has a `zig-zag' shape and can be seen as having  corridors, . It starts with ,  the \emph{main} corridor (at the center of the figure), which contains point , then it turns left to  , then right, etc., gradually turning around to  and then to the \emph{end} corridor  (at the top). The latter contains point . To facilitate the discussion, we place a point  in the tunnel where the transition from  to the end corridor occurs. 
The tunnel has a total weight of .
The rest of the construction will force any - path of some particular cost (to be given shortly) to stay always in the interior of the tunnel. 

\begin{figure}
\centering
\includegraphics[width=.88\textwidth]{variable_chain}
\caption{(a) Tunnel and variable chain. Each gray trapezoid represents a piece with  parallel segments. (b) Part of a chain piece close to the tunnel.}
\label{chain}
\end{figure}

Each variable  of  is represented by a collection of 16 pieces, which form a chain-like structure. Each \emph{piece} is a group of  nearly-parallel single segments whose ends are either outside the tunnel or lie on `short' heavy segments of type  in the interior of the tunnel, referred to as \emph{obstacles}. For each variable, there is one obstacle in each of the corridors , ,  and there are two obstacles in each of the corridors , , , and . See Fig.~\ref{chain}(a), where we represent each piece by a light gray trapezoid and each obstacle by a bold, short segment. Pieces always contain a part outside the tunnel. The exact description of the structure is cumbersome; we refer the reader to the figures. The obstacle in  contains the extremes of four pieces: two pieces, called , go to the obstacle in the main corridor, one goes to an obstacle in , and the fourth piece, which we call  goes outside the tunnel. Symmetrically, the obstacle in  contains the extremes of four pieces: two pieces, called , go to the main corridor, one goes to the corridor , and one, which we call  goes outside the tunnel. We add pieces connecting the obstacles in  and , the obstacles in   and , and the obstacles in  and . From the obstacle in  that currently has one piece we add another piece, which we call  and whose other extreme is outside the tunnel. From the obstacle in  that currently has one piece we add another piece, which we call , whose other extreme is outside the tunnel. 

The obstacles and the pieces of all variables should satisfy some conditions: obstacles should be disjoint, pieces can touch only the obstacles at their extremes, and pieces may cross only outside the tunnel. See Fig.~\ref{complete}. Some of the single segments of , , ,  will be prolonged and rotated slightly to encode the clauses. For this, we will need that the line supporting a segment from  intersects inside the end corridor the line supporting a segment from . This can be achieved by stretching the end corridor sufficiently and placing the obstacles of  and  close to the tunnel boundary; see Fig.~\ref{chain}(b).

\begin{figure}
\centering
\includegraphics[width=.86\textwidth]{general_construction_2}
\caption{Example of overall construction.}
\label{complete}
\end{figure}

For each clause of  we prolong two segments of  as follows; see Fig.~\ref{complete} for an example of the overall construction, where prolongations are shown by dashed lines. Each segment corresponds to some literal  or  in the clause: in the first case the segment comes from either  or , while in the second one it comes from either  or . For the construction, these choices for each clause can be made arbitrarily, provided that one segment intersects the tunnel from the left side and the other one from the right. These segments are prolonged until their intersection point inside the end corridor. For each clause, two different segments are prolonged. Since the pieces corresponding to variable  have  segments, there is always some segment available. 
Segments corresponding to different clauses may intersect only outside the tunnel; this is ensured by rotating the segments slightly around the endpoint lying in the obstacle. In this way, the end corridor is obstructed by  pairs of intersecting segments such that any path from the intermediate point  to point  staying inside the tunnel must intersect at least one segment from each pair.  

The following lemma establishes the correctness of the reduction. 

\begin{lemma}\label{sec2_lem:bothdirections}
There is an - path of cost at most , where , if and only if 
there is a truth assignment satisfying at least  of the clauses.
\end{lemma}
\begin{proof}
We denote by  the set of segments in the pieces corresponding to the variable .
We denote by  the segments in the pieces of , the piece connecting  to , the piece  , and so on in an alternating manner along the chain structure. Note that  contains ,  and .
We denote by  the segments . Note that  contains ,  and .
See Fig.~\ref{chain-posneg}.
Each of the sets  and  contains  segments. Inside the tunnel there is an - path disjoint from  and there is another - path disjoint from . We also denote by  the two segments used for clause  of .

\begin{figure}
\centering
\hfill
\includegraphics[width=.49\textwidth]{variable_chain-positive}
\centering
\hfill
\includegraphics[width=.49\textwidth]{variable_chain-negative}
\hfill
\caption{Removal of  (left) and  (right).}
\label{chain-posneg}
\end{figure}

Consider a truth assignment , where each , satisfying at least  clauses. We construct a subset of segments  where we include the set , for each variable , and a segment of , for each clause  that is not satisfied by the truth assignment. Since , the set  contains at most  segments. The removal of  leaves the points  and  in the same cell of the arrangement. Equivalently, there is an - path inside the tunnel that crosses only segments from . If a clause  of  is satisfied by the truth assignment, then at least one of the segments in  is included in . If a clause  is not satisfied, then one of the segments  is included in  by construction. Thus, for each clause  we have . It follows that  and  are in the same cell after the removal of .

Conversely, note first that any - path with cost at most  cannot intersect the tunnel boundary or an obstacle because segments of type  have weight . Let  be the set of segments crossed by the path. If , then we define ; otherwise, we define .
Note that when , then  because the - path is inside the tunnel. (However it may be , so the assignment of  is not symmetric.) We next argue that the truth assignment  satisfies at least  clauses.

Consider the case when . Inspection shows that 

Indeed, after the removal of  any path from  to  must still cross at least  pieces. Similarly, inspection shows that when  we have 
 
Let  if  and  if . The previous cases can be summarized as 

We further define

For each clause  we have  by construction, as otherwise  and  cannot be in the same cell of . If  is not satisfied by the truth assignment , then it must be  for some variable  in . This means that  
. Since the sets  are disjoint by construction, the number of unsatisfied clauses is bounded by .
Using that 

we obtain 

Therefore, the total number of clauses with value  is bounded by

\end{proof}
The construction can be easily modified by replacing every heavy segment with a set of  distinct parallel single segments such that every single segment in  that originally intersected the heavy segment now intersects all the segments in the new set and such that no three segments have a point in common. We have the following:

\begin{theorem}\label{NP-hard}
 {\sc -Cells-Connection} is NP-hard and APX-hard even when no three segments intersect at a point.
\end{theorem}
\begin{proof}
NP-hardness follows form Lemma~\ref{sec2_lem:bothdirections} and the fact that the reduction produces  segments, whose coordinates can be bounded by a polynomial in . APX-hardness follows from the fact that the reduction is approximation-preserving, as we now show.

	First, since there is always an assignment that satisfies at least  clauses, we have that . Recall that an optimal - path costs , where . A polynomial-time -approximation algorithm () for the problem would give a path that costs at most

	
	and, by Lemma~\ref{sec2_lem:bothdirections}, a truth assignment that satisfies at least 
	 clauses. However, {\sc Exact-Max-2-SAT} cannot be approximated 
	above ~\cite{Hastad01}, which implies that  must be larger than 
	(A slightly better inapproximability result can be obtained using the better bounds that rely on the unique games conjecture~\cite{kkmo-oir-07}.)
\end{proof}

We can reduce {\sc -Cells-Connection} to the minimum color path problem (MCP): 
Given a graph G with colored (or labeled) edges and two of its vertices, find a path between the vertices that uses the minimum possible number of colors.
We color the edges of the dual graph  of  as follows: two edges of  get the same color if and only if their corresponding edges in  lie on the same segment of .
Then, finding an - path of cost  in  amounts to finding a -color path in  between the two cells which ,  lie in.

However, MCP is NP-hard~\cite{BLWZ05} and W[1]-hard~\cite{FGK10} (with respect to solution size) even for planar graphs, it has a polynomial-time -approximation algorithm and is non-approximable within any polylogarithmic factor~\cite{HMS07}. 

\section{Tractable cases for connecting two cells}

We now describe two special cases where {\sc -Cells-Connection} is tractable. First, we consider the case where the input segments
have few crossings, in a sense that is specified below. Then, we return to the special case where we have a polygon and provide an algorithm
that takes polynomial time when the number of holes in the polygon is constant.
 
\subsection{Segments crossings.}
Without loss of generality, we assume that every segment in  intersects at least two other segments and that both endpoints of a segment are intersection points. We say that two segments cross if and only if they intersect at a point that is interior to both segments (a segment crossing).

Consider the colored dual graph  of  as defined after Theorem~\ref{NP-hard}. A face of  (except the outer one) corresponds to a point of intersection of some  segments and has  colors and, depending on the type of intersection, from  to  edges. 
For example, for  we can get two multiple edges, a triangle, or a quadrilateral, with two distinct colors. See Fig.~\ref{fig:colored_dual}(a)-(c), where the colors are given as labels.

\begin{figure}[t]
\centering
\includegraphics[width=\textwidth]{colored_dual}
\caption{Examples of intersections in  and colored edges in .}
\label{fig:colored_dual}
\end{figure}

When any three segments may intersect only at a common endpoint and no two segments cross,  can only have multiple edges (possible all with the same color), bi-chromatic triangles, and arbitrary large faces where all edges have different colors; See Fig.~\ref{fig:colored_dual}(d) for an example. In this case, since two segments can intersect only at one point, each color induces a connected subgraph of , in fact a tree (where all but one multiple edges with the same color can be deleted) for there can be no monochromatic cycle in .  Then, {\sc -Cells-Connection} reduces to a simple shortest path computation between the cells containing  and  in the (uncolored) graph resulting from  by completing each monochromatic tree into a clique.
By contrast, note that {All-Cells-Connection} is still NP-hard for this special case; see Section~\ref{allcells}.

Generalizing this, if we allow  segment crossings, 
we can easily reduce the problem to  shortest path problems as follows. Let  be the set of the (at most ) segments participating in these crossings. For a fixed subset  of , we first contract every edge of  corresponding to a segment in , effectively putting all segments of  into the solution. Then, we delete every edge corresponding to a segment in   that still participates in a crossing, i.e., we exclude all crossing segments of  from the solution. 
In the resulting (possibly disconnected) graph , each of the remaining colors induces again a monochromatic subtree, thus we can compute a shortest path as before and add  to the solution. Finally, we return a minimum size solution set over all  possible subsets . 
Thus, we have just proved the following:

\begin{theorem}
{\sc -Cells-Connection} is fixed-parameter tractable with respect to the number of segment crossings if any three segments may intersect only at a common endpoint.
\end{theorem}

\subsection{Polygon with holes.}
Let  be a polygon with  holes and  be a set of segments lying inside  with their endpoints on its boundary; see Fig.~\ref{fig:polygon}. We use  as a bound for the number of vertices of  and segments in . 
We consider the restricted {\sc -Cells-Connection} problem where the - path may not cross the boundary of . This version is also NP-hard by a simple reduction from the general one: place a large polygon enclosing all the segments and add a hole at the endpoint of each segment. 
We assume for simplicity that  and  are in the interior of . 

A boundary component of  may be the exterior boundary or the boundary of a hole. For each boundary component  of , let  be the connected component of  that has  as boundary, and let  be an arbitrary, fixed point in the interior of . If  is the exterior boundary, then  is unbounded.

Let  and  be two boundary components of ; it may be that . 
Let  be the subset of segments from  with one endpoint in  and another endpoint in . We partition  into clusters, as follows. Consider the set  obtained from  by adding  and . Note that  and  are holes in . For each segment , with  and , we define the following
curve : follow a shortest path in  from  to , then follow , and then follow a shortest path
in  from  to . See Fig.~\ref{fig:polygon2}.
We say that segments  and  from  are \emph{- equivalent} if  and  are homotopic paths in .
Since being homotopic is an equivalence relation (reflexive, symmetric, transitive), being - equivalent is also an equivalence relation in .
Therefore, we can make equivalence classes, which we call \emph{clusters}. 
The following two results provide key properties of the clusters. 

\begin{figure}[t]
\centering
\includegraphics[width=0.9\textwidth]{polygon2}
\caption{Some of the curves  arising from Fig.~\ref{fig:polygon}, after a small perturbation, and the resulting clusters. In the left case,  and  are boundaries of holes, while in the right case  is the exterior boundary.}
\label{fig:polygon2}
\end{figure}

\begin{lemma}\label{le:clusters1}
 is partitioned into  clusters. Such partition can be computed in  time.
\end{lemma}
\begin{proof}
Let  be the set of curves  over all segments .
Note that two curves  and  of  may cross only once, and they do so along  and .
With a small perturbation of the curves in  we may assume that  and  are either disjoint or cross at .
(We do not actually use that  contains shortest paths inside  and  besides for this property of non-crossing curves inside  and .)

We now describe a simple criteria using crossing sequences to decide when two segments of  are - equivalent. We take a set  of non-crossing paths in  that have the following property: cutting  along the curves of  removes all holes. Such set  has a tree-like structure and can be constructed as follows. For each boundary  of , distinct from  and , we add to  the shortest path in  between  and . We add to  the shortest path in  between  and . Finally, if  or  is the exterior boundary of , we add to  a shortest path from  to a point that is very far in  union the the outer face. In total,  has  polygonal paths in . Note that the curves in  are non-crossing and a small perturbation makes them disjoint, except at the common endpoint . See Fig.~\ref{fig:polygon3}. Each curve  is simple and has two sides. We arbitrarily choose one of them as the right side and the other as the left side. We use  to denote the curves of .

\begin{figure}[t]
\centering
\includegraphics[width=0.9\textwidth]{polygon3}
\caption{The curves  in solid and  in dashed style for the example of Fig.~\ref{fig:polygon2}, after a small perturbation.}
\label{fig:polygon3}
\end{figure}

To each path  in  we associate a crossing sequence  as follows. We start with the empty word and walk along . When  crosses an arc  from left-to-right we append  to the word, and when  crosses  from right-to-left we append   to the word. From the crossing sequence  we can obtain the \emph{reduced crossing sequence}  : we iteratively remove contiguous appearances of  and , for any . For example, from the crossing sequence  we obtain the reduced crossing sequence . A consequence of using  to construct the so-called universal cover is the following characterization:
the curves  and  are homotopic in  if and only if the curves  and  have the same reduced crossing sequence. See for example~\cite{clms-04}. We conclude that  and  from  are - equivalent if and only if 
.

The union of  and  forms a family of pseudosegments: any two of them crosses at most once.
Indeed, by construction different curves can only cross in , but inside  all those curves are shortest paths, and thus can cross at most once.
Furthermore, the segments  do not cross by construction and the curves of  have common endpoints.
Mount~\cite[Theorem 1.1]{mount-90} has shown that in such case the curves in  
define at most  distinct crossing sequences. Therefore, there are at most  homotopy classes defined
by the curves in , and  defines  clusters. 

The procedure we have described is constructive: we have to compute  shortest paths in  to obtain the curves of , and then, for each segment , we have to compute the corresponding crossing sequence. Such crossing sequence is already reduced. Note that for computing the crossing sequence of  we never have to construct  itself because all crossings occur along .
This can be done in  time using algorithms for shortest paths in polygonal domains~\cite{hs-oaesp-99} and data structures for ray-shooting among the segments of ~\cite{ray-shooting}.
\end{proof}

\begin{lemma}\label{le:clusters2}
For each cluster, either all or none of the 
segments in the cluster are crossed by a minimum-cost - path. 
\end{lemma}
\begin{proof}

\begin{figure}[t]
\centering
\includegraphics[width=0.9\textwidth]{polygon4}
\caption{Figure for the proof of Lemma~\ref{le:clusters2}. Left: case when  and  are disjoint.
	Right: case when  and  intersect. In both cases, the darker gray region represents the topological disk defined by  and .}
\label{fig:polygon4}
\end{figure}

Let  and  be two - equivalent segments from .
This implies that  and  are homotopic in .
Therefore, the path  obtained by concatenating  and the reversal of  is contractible in .

Let  be a minimum-cost path between  and  that crosses  but does not cross .
We will reach a contradiction.
We take  that minimizes the total number of crossings with . 
We may assume that  is simple and disjoint from .
We use  to denote the subpath of  between points  and  of . 
We distinguish two cases:
\begin{itemize}
	\item  and  do not intersect. In this case, the curve  is simple and contractible
		in . It follows that  bounds a topological disk  in .
		By hypothesis,  crosses the part of the boundary of  defined by  but
		not . Therefore,  must cross at least twice along . Let  and  be two consecutive crossings of  and 
		as we walk along . See Fig.~\ref{fig:polygon4} left. Consider the path  that replaces  by the segment .
		Any segment  crossing  along  crosses also  because  and  define a disk.
		Therefore  crosses no more segments than  and crosses  twice less than .
		Thus, we reach a contradiction. (If  is not simple we can take a simple path contained in .)
	\item  and  intersect. In this case, the curve  
		in  has precisely one crossing. Let  and  be the two simple loops
		obtained by splitting  at its unique crossing. It must be that  and  are contractible,
		as otherwise  would not be contractible. See Fig.~\ref{fig:polygon4} right.
		Therefore, we obtain two topological disks  and , one bounded by  and another by .
		The path  must cross the boundary of  or , and the same argument than in the previous item
		leads to a contradiction.\qedhere
\end{itemize}
\end{proof}

A minimum-cost - path can now be found by testing all possible cluster subsets, that is,  possibilities.

\begin{theorem}
The restricted {\sc -Cells-Connection} problem in a polygon with  holes and  segments can be found in  time.
\end{theorem}
\begin{proof}
We classify the segments of  into  clusters using Lemma~\ref{le:clusters1}. This takes  time. Because 
of Lemma~\ref{le:clusters2}, we know that either all or none of the segments in a cluster are crossed by an optimal - path. Each subset of the clusters defines 
a set of segments , and we can test whether  separates  and  in  time~\cite{single-face1,single-face2}. 
\end{proof}


\section{Connecting all cells}\label{allcells}

We show that {\sc All-Cells-Connection} is NP-hard by a reduction from the NP-hard problem of feedback vertex set (FVS) in planar graphs (c.f.~\cite{V01}): Given a planar graph , find a minimum-size set of vertices  such that  is acyclic. 

First, we subdivide every edge of  obtaining a planar bipartite graph . It is clear that  has a feedback vertex set of size  if and only if  has one.  Next, we use the result by de Fraysseix et al.~\cite{dFMP91} (see also Hartman et al.~\cite{HNZ91}), 
which states that every planar bipartite graph is the intersection graph of horizontal and vertical segments, where no two of them cross (intersect at a common interior point). Let  be the set of segments whose intersection graph is ; it can be constructed in polynomial time. Since  has no triangles, no three segments of  intersect at a point. Then, observe that all cells in  become connected by removing  segments if and only if  has a feedback vertex set of size . Therefore we have:

\begin{theorem}
{\sc All-Cells-Connection} in NP-hard even if no three segments intersect at a point and there are no segment crossings.
\end{theorem}

It is also easy to see that if no three segments intersect at a point a -size solution to {\sc All-Cells-Connection}
corresponds to a -size solution of FVS in the intersection graph of the input segments. 
For general graphs, FVS is fixed-parameter tractable when parameterized with the size of the solution~\cite{CFLLV08}, and has a polynomial-time -approximation algorithm~\cite{V01}. We thus obtain the following:

\begin{corollary}
When no three segments intersect at a point, {\sc All-Cells-Connection} is fixed-parameter tractable with respect to the size of the solution and has a polynomial-time -approximation algorithm.
\end{corollary}



\section*{Acknowledgments:}
We would like to thank Primo{\v z} {\v S}kraba
 for bringing to our attention some of the problems studied in this abstract.

\bibliographystyle{alpha}
\bibliography{segments_full}

\end{document}
