\documentclass[11pt]{article}


\ifdefined\CR
\usepackage{ltexpprt}
\newenvironment{definition}{\begin{Definition}}{\end{Definition}}
\newtheorem{claim}{Claim}[section]
\newenvironment{proofof}[1]{\rm \trivlist \item[\hskip \labelsep{\it #1.\/}]}{\outerparskip 0pt\endtrivlist}
\else
\usepackage{amsthm}
\usepackage{fullpage}
\usepackage{typearea}
\paperwidth 8.5in \paperheight 11in
\typearea{15}
\newtheorem{theorem}{Theorem} \newtheorem{lemma}{Lemma}[section]
\newtheorem{proposition}[lemma]{Proposition}
\newtheorem{corollary}[lemma]{Corollary}
\newtheorem{definition}[lemma]{Definition}
\newtheorem{claim}[lemma]{Claim}
\newenvironment{proofof}[1]{\begin{proof}[#1]}{\end{proof}}
\fi

\usepackage{amssymb, amsmath}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{color}
\usepackage{xcolor}
\usepackage[pagebackref,letterpaper=true,colorlinks=true,pdfpagemode=none,urlcolor=blue,linkcolor=blue,citecolor=violet,pdfstartview=FitH]{hyperref}
\usepackage{enumitem}
\usepackage{thm-restate}
\usepackage{mathrsfs}





\newcounter{prop}
\newenvironment{properties}
{
\addtocounter{prop}{1}
\begin{enumerate}[labelindent=0pt,label=(\Alph{prop}\arabic*),itemindent=1em,itemsep=-1pt]
}
{
\end{enumerate}
}

\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\cardinal}[1]{\left|#1\right|}

\DeclareMathOperator{\E}{\mathbb E}
\DeclareMathOperator{\union}{\bigcup}
\newcommand{\R}{{\mathbb R}}
\newcommand{\Z}{{\mathbb Z}}

\newcommand{\calA}{{\mathscr A}}
\newcommand{\calB}{{\mathscr B}}
\newcommand{\calI}{{\mathscr I}}
\newcommand{\calS}{{\mathscr S}}
\newcommand{\calT}{{\mathscr T}}

\newcommand{\cA}{{\mathscr A}}
\newcommand{\cB}{\mathscr{B}}
\newcommand{\cC}{{\mathscr C}}
\newcommand{\cD}{\mathscr{D}}
\newcommand{\cE}{{\mathscr E}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\cH}{{\cal H}}
\newcommand{\cI}{{\mathsf I}}
\newcommand{\cJ}{{\cal J}}
\newcommand{\cL}{{\cal L}}
\newcommand{\cM}{{\cal M}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cQ}{\mathcal{Q}}
\newcommand{\cR}{{\cal R}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cT}{{\cal T}}
\newcommand{\cU}{{\cal U}}
\newcommand{\cV}{{\cal V}}
\newcommand{\cX}{{\cal X}}

\newcommand{\sfH}{{\mathsf H}}
\newcommand{\sfL}{{\mathsf L}}

\newcommand{\eps}{\varepsilon}
\renewcommand{\epsilon}{\varepsilon}
\newcommand{\lam}{\lambda}
\newcommand{\sgn}{\mathrm{sgn}}
\newcommand{\poly}{\mathrm{poly}}
\newcommand{\polylog}{\mathrm{polylog}}
\newcommand{\littlesum}{\mathop{{\textstyle \sum}}}
\newcommand{\half}{{\textstyle \frac12}}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\wh}{\widehat}
\newcommand{\wt}{\widetilde}

\newcommand{\x}{{\mathbf x}}

\newcommand{\Exp}{\EX}
\newcommand{\EX}{\hbox{\bf E}}
\newcommand{\prob}{{\rm Prob}}

\newcommand{\OPT}{{\mathsf{OPT}}}
\newcommand{\LP}{{\mathsf{LP}}}

\newcommand{\floor}[1]{\left\lfloor#1\right\rfloor}
\newcommand{\ceil}[1]{\left\lceil#1\right\rceil}

\newcommand{\ignore}[1]{}
\renewcommand{\epsilon}{\varepsilon}


\newcommand{\Sec}[1]{\texorpdfstring{\hyperref[sec:#1]{\S\ref*{sec:#1}}}{\S\ref*{sec:#1}}} \newcommand{\Eqn}[1]{\texorpdfstring{\hyperref[eq:#1]{(\ref*{eq:#1})}}{(\ref*{eq:#1})}} \newcommand{\Thm}[1]{\texorpdfstring{\hyperref[thm:#1]{Theorem~\ref*{thm:#1}}}{Theorem~\ref*{thm:#1}}} \newcommand{\Lem}[1]{\texorpdfstring{\hyperref[lem:#1]{Lemma~\ref*{lem:#1}}}{Lemma~\ref*{lem:#1}}} \newcommand{\Def}[1]{\texorpdfstring{\hyperref[def:#1]{Definition~\ref*{def:#1}}}{Definition~\ref*{def:#1}}} \newcommand{\Clm}[1]{\texorpdfstring{\hyperref[clm:#1]{Claim~\ref*{clm:#1}}}{Claim~\ref*{clm:#1}}} \newcommand{\App}[1]{\hyperref[app:#1]{Appendix~\ref*{app:#1}}}  

\allowdisplaybreaks

\title{On -Restricted Assignment Makespan Minimization}
\author{Deeparnab Chakrabarty\footnote{Microsoft Research. {\tt dechakr@microsoft.com}} \and Sanjeev Khanna\thanks{Department of Computer and Information Science, University of Pennsylvania,
Philadelphia, PA 19104. Email: {\tt sanjeev@cis.upenn.edu}.  Supported in part by National Science Foundation grant CCF-1116961.}  \and Shi Li\footnote{TTIC. {\tt shili@ttic.edu}}}

\begin{document}
\date{}
\maketitle

\begin{abstract}
Makespan minimization on unrelated machines is a classic problem in approximation algorithms. No polynomial time -approximation algorithm is known for the problem for constant . This is true even for certain special cases, most notably the {\em restricted assignment} problem where each job has the same load on any machine but can be assigned to one from a specified subset. Recently in a breakthrough result, Svensson~\cite{Sve11} proved that the integrality gap of a certain configuration LP relaxation is upper bounded by  for the restricted assignment problem; however, the rounding algorithm is {\em not known} to run in polynomial time.\smallskip

In this paper we consider the -restricted assignment problem where each job is either heavy () or light (), for some parameter . 
Our main result is a -approximate \emph{polynomial time} algorithm for the -restricted assignment problem for a fixed constant . Even for this special case, the best polynomial-time approximation factor known so far is . We obtain this result by rounding the configuration LP relaxation for this problem.
A simple reduction from vertex cover shows that this special case remains NP-hard to approximate to within a factor better than .
\end{abstract}


\setcounter{page}{0}
\thispagestyle{empty}
\ifdefined\CR

\else
\newpage
\fi

\section{Introduction}

In the makespan minimization problem, we are given a set  of  machines, and a set  of  jobs where a job  contributes a load of  to a machine , if assigned to it. The goal is to assign each job to a machine, so that the maximum load on any machine is minimized. Formally, one seeks an allocation  minimizing . In 1990, Lenstra, Shmoys, and Tardos \cite{LST90} gave a -approximation for the problem, and showed that it is NP-hard to obtain an approximation factor better than . 
Closing this gap is an outstanding problem in approximation algorithms.

In order to understand the problem better, researchers have focused on special cases. 
The most notable among them is the {\em restricted assignment} problem. In this problem, each job  has an inherent load  but it can be assigned only to a machine  from a specified subset. Equivalently, each  with  for machines  which  cannot be assigned to.
 The hardness of  carries over to the restricted assignment problem and no  polynomial time -algorithm is known for any constant .
In a breakthrough, Svensson~\cite{Sve11} proved that the integrality gap of a certain configuration LP for the restricted assignment problem is at most  .  Svensson's result can thus be used to efficiently {\em estimate the value} of the optimum makespan to within a factor of ; however, no {\em polynomial time} algorithm to compute a corresponding schedule is known. Nonetheless, it gives hope\footnote{Without discussing this technically, we refer the reader to the articles by Feige~\cite{F08}, and Feige and Jozeph~\cite{FJ14}.} that the restricted assignment case may have a polynomial time `better-than-factor-' algorithm. 

Our paper makes progress on this front.  We study the -restricted assignment problem, in which 
all jobs fall in two classes: heavy or light. Every heavy job has load, , and each light job has , for some parameter , and the goal is to find a schedule which minimizes the makespan.
We give a -approximate \emph{polynomial time} algorithm for the -restricted assignment problem for a constant .



The -case is interesting because in some sense it is the simplest case which we do not understand. If all jobs have the same size, the problem becomes a matching problem. If there are two job sizes, we can assume they are  and  by scaling. The reader should think of  as a number that tends to , as there is a simple -approximation if each job has size either  or  (see \App{large-eps}).  The -restricted assignment problem is already hard -- it is NP hard to obtain an approximation factor  for this problem (see \App{hardness}), and no -approximation is known for any  independent of .  It is plausible that an understanding of the -case might lead to an understanding of  the restricted assignment case; indeed,
Svensson \cite{Sve11}, in his paper, first gives an improved integrality gap of  for this special case before proving  his result for the general case. 


\begin{theorem}(Main Result.)
\label{thm:main}
 There is a polynomial time -approximation algorithm, where  is a specific constant,  for makespan minimization in the -restricted assignment case.
\end{theorem}

\subsection{Our Techniques}
For concreteness, let us assume for now that the optimal makespan is .
Note that once we have an assignment of the heavy jobs to machines, we can decide in polynomial time whether there is a (fractional) allocation of light jobs so that the total makespan is at most  or not, for any . Such an assignment of heavy jobs is called a {\em -good} assignment, and given such an assignment one can recover an integral assignment for light jobs as well such that the total load on any machine is at most . 
The rounding process to recover a -good assignment proceeds in three phases. 

In the first phase, we `reduce' our instance to a {\em canonical instance} where for each heavy job there is a distinct (private) set of machines to which it can be assigned to, and for each unassigned light job, there are at most  two machines to which it can be assigned to. Such a  pre-processing technique has also been used in 
tackling the max-min allocation problem~\cite{BS06,CCK09}. There are two main parameters of interest in a canonical instance, namely, a parameter  that asserts that the positive fractional assignment of a heavy job to a machine is at least , and a parameter , that asserts that the total load of light jobs shared by any two machines is either  or is at least .

The second phase of the rounding process is a {\em coarsening} of the parameters  and  of the canonical instance where we ensure that whenever a heavy job is fractionally assigned to a machine, the assignment is sufficiently large (at least  for some constant ). Furthermore, the total light load shared by any pair machines is either  or at least  . The flip side is the total fractional load on a single machine could increase from  to roughly .
The technique used to achieve this coarsening is essentially due to Feige~\cite{Fei08} in his work on max-min allocation, and is done by iteratively assigning heavy jobs and `merging' light jobs. The proof uses the asymmetric Lovasz Local Lemma (LLL), and 
polynomial time algorithms to do the same are guaranteed by the recent works of Moser and Tardos~\cite{MT10} and Haeupler, Saha, and Srinivasan~\cite{HSS11}.


The heart of our approach and our main technical contribution is the third and the final phase of rounding. At this point we have a canonical instance where each heavy job is assigned to a constant number  of machines that are private to it, each light job has constant size, and is shared between at most  two machines. Note that if the fractional load on each machine was at most , then things are trivial -- assign the heavy job to the machine which is fractionally assigned more than  of it, and the total load on it become . 
However, the second step has increased the fractional load from  to , and this `extra' load swamps the gain of .
This issue does not arise in the max-min allocation where one targets a constant factor; however, it defeats our goal of beating the 
factor -approximation for makespan minimization.

Nevertheless, if we could find an assignment such that the total light load on any machine receiving a heavy job is at most , then we are in good shape, and this is what we do.
We find such an assignment by randomized rounding and again use the (asymmetric) LLL. A key and difficult aspect of making this entire approach work is to have only a small degree of dependence between various ``bad'' events in the final rounding step. This reduction in dependence is the essence of our approach, and is accomplished by the structure of canonical instances, and further simplifying this structure before picking the final random assignment.

\subsection{Relevant Related Work}
We briefly note some other works on makespan minimization. Ebenlendr, Krc\'{a}l, and Sgall~\cite{EKS08} consider the special case of the restricted assignment makespan minimization problem where each job could be assigned to at most  machines, and design a polynomial time -approximation algorithm for the same. Interestingly, even when jobs can go to at most two machines, the general makespan minimization problem seems difficult; Verschae and Wiese~\cite{VW11} show that the configurational LP has integrality gap tending to . Kolliopoulos and Moysoglou~\cite{KM13} consider the restricted assignment problem with two jobs sizes as well; they show that Svensson's estimation algorithm can be improved to  for this case. See \App{large-eps} for a slightly better factor.

The `dual' problem to makespan minimization, max-min allocation, where jobs need to be allocated to maximize the minimum load, has seen interesting developments recently. A constant factor approximation is known for the `restricted assignment' case (the so-called {\em Santa Claus} problem), where each job has the same load for all the machines it can go to. This follows from the works of Bansal and Sviridenko~\cite{BS06}, Feige~\cite{Fei08}, and the constructive LLL version due to~\cite{MT10,HSS11}. Our work closely follows this line and exhibits its utility for the makespan minimization problem. Another line of work on the Santa Claus problem is via local search; Asadpour, Feige, and Saberi~\cite{AFS08} show an upper bound of  on the integrality gap via a not-known-to-be-polynomial time local search algorithm. Polacek and Svensson~\cite{PS12} use these ideas to give a {\em quasipolynomial} time, -approximation. Very recently, Annamalai, Kalaitzis, and Svensson~\cite{AKS15} improve this to get a polynomial time -approximation.
For the {\em general} max-min allocation problem, Chakrabarty, Chuzhoy, and Khanna~\cite{CCK09}, improving upon earlier results by Asadpour and Saberi~\cite{AS07} and Bateni, Charikar, and Guruswami~\cite{BCG09}, give a -approximation algorithm which runs in -time.




\section{Linear Programming Relaxation}
\label{sec:LP}

Recall that we denote the set of all machines by  and the set of all jobs by . We assume that  is partitioned into the set of heavy jobs by , and the set of light jobs by .  We consistently use  to index jobs, and  and  to index machines. For any job , we denote by  the set of machines to which job  can be assigned.

Given a guess  for the optimal makespan, the {\em configuration LP} w.r.t.  is as follows. For every machine ,  contains subsets of jobs of total load at most  which can be assigned to  . We have a variable  for each machine  and subset . 
\noindent
Given an instance , we let  be the {\em smallest}  for which the configuration LP has a feasible solution;  can be found by binary search.
Trivially, , where  denotes the optimal (integral) makespan. 


In this paper, we use the following simpler parametrized LP relaxation  tailored for -instances. 
\ifdefined\CR

\else
\begin{minipage}{0.37\textwidth}

\end{minipage}
\begin{minipage}{0.58\textwidth}

\end{minipage}
\fi

\medskip
To get some intuition, 
consider the LP with .
We claim there exists a  feasible solution if . In this case, it must be that every machine either gets one heavy job or 
at most  light jobs. In particular, any machine getting a light job {\em cannot} get a heavy job.
Constraint~\eqref{CLP:compact} encodes this. The connection between  and the configuration LP is captured by the following lemma.
\begin{restatable}{lemma}{clp}
\label{lemma:reduce-to-feasible-instances}
\label{lem:reduce-to-feasible-instances}
Given an -restricted assignment instance  with , there is a polynomial time procedure which 
returns another -instance  which has a feasible solution to .
Furthermore, given a schedule for  with makespan , the procedure returns a schedule for  of makespan .
\end{restatable}

\begin{proof}
Let  be the solution to the configuration LP at .
Call a configuration  {\em heavy} if it contains a heavy job. Define
 for all , and  for all .
Note that  for all , we have 
 since each configuration has load .

Now, if for some light job , , we remove  from  and set . 
Let  be the set of remaining jobs. The new instance is .
For any job  in , 
, that is, 
Thus,   is a feasible solution for  for . Now, given an assignment of jobs for , we augment it to get one for  by assigning job  to .
Note
\ifdefined\CR

\else

\fi
since  for heavy .
\end{proof}

The remainder of the paper is devoted to proving the following theorem.

\begin{theorem} 
\label{thm:main-2}
There is a constant , such that given an instance  and a feasible solution to , in polynomial time one can obtain a schedule for  of makespan at most .
\end{theorem}

We conclude this section by showing that the preceding theorem suffices to establish our main result.

\begin{proofof}{\bf Proof of Theorem \ref{thm:main}}
Set , where  is the constant specified in \Thm{main-2}.
Fix an instance  and the corresponding .
If , then the classic result of Lenstra et al.~\cite{LST90} returns a schedule whose makespan is at most .
If , then \Lem{reduce-to-feasible-instances} can be used to get an instance  for which  is feasible.
\Thm{main-2} returns a schedule for  with makespan at most , which when fed to \Lem{reduce-to-feasible-instances} gives
a schedule for  of makesan at most  since .
This proves \Thm{main}.
\end{proofof}

\section{Canonical Instances and \texorpdfstring{}{delta}-good Assignments}
\label{sec:canonical_definition}

In this section we introduce the notion of canonical instances and formalize the notion of a -good assignment of heavy jobs for these instances.  



In a canonical instance, heavy jobs have size . Light jobs can be scheduled fractionally and any light job can be assigned to at most two machines. Thus each light job is of type- for some ; it can only be assigned to  or . It is possible that ; when ,  and  are two different job types. Subsequently, it will be clear that these types are differentiated and defined by how the LP assigns the jobs; for now the reader may think of  as the load of light jobs which `belong to  but can be assigned to  if  gets a heavy job'.
  Given , we will merge the light jobs of type- into a single job of total size equal to the sum of the light jobs. We call this the light load of type-.
Henceforth, we use ``light load'' instead of ``light jobs'' in a canonical instance. 


\begin{definition}
\label{def:ci-0}
A {\bf canonical instance} is defined by a triple , where
\begin{properties}
\item for every heavy job ,  is the set of machines that  can be assigned to; for any pair heavy jobs , we have ; \label{property:ci-M}
\item  a matrix, where   is the light load of type-. If  and , then ; if  then ;  \label{property:ci-w}
\item  is a function on  where  if and only if . \label{property:ci-z}
 \end{properties}
\end{definition}
\noindent
There is an intrinsic fractional solution defined by the function . If  for some , then  is the fraction of the heavy job  assigned to machine . A heavy job may not be fully assigned, but we will ensure that a decent portion of it is.  If ,  fraction the  light load of type- is assigned to , and the remaining  fraction is assigned to .  The  light load of type- is fully assigned to .  
Given a matrix , we use the notation  for subsets  to denote the sum .   

\begin{definition}
The directed graph  formed by the support of , with self-loops removed, is called the {\bf light load graph}.
\end{definition}

\begin{definition}
Given a canonical instance , we say that  is a {\bf -canonical instance} for some  and , if it satisfies the following properties (in addition to Properties~\ref{property:ci-M} to \ref{property:ci-z}):
\begin{properties}
\item for each , either , or ; 
\label{property:canonical-instance-z-i-large}
\item for every , either  or ;
\label{property:canonical-instance-light-load-large}
\item , for every ;
\label{property:canonical-instance-big-job-covered}
\item , for every machine .
\label{property:canonical-instance-load-small}
\end{properties}
\end{definition}

Property~\ref{property:canonical-instance-z-i-large} says that none of the heavy job assignments is too small.  Property~\ref{property:canonical-instance-light-load-large} says that any positive load of some type is large. Property~\ref{property:canonical-instance-big-job-covered} says that  a `decent' fraction of each heavy job  is assigned. Property~\ref{property:canonical-instance-load-small} says that the total load assigned to a machine  in the intrinsic fractional solution is bounded.
Our goal is to find a valid assignment  of heavy jobs to machines which leaves ``enough room'' for the light loads. We say  is {\em valid} if  for every . This motivates the following definition.

\begin{definition}[-good Assignment]
Given a -canonical instance and a number ,  a valid assignment  for a canonical instance is -good if all the light loads can be \emph{fractionally} assigned so that each machine has total load at most .
\end{definition}
\noindent
Define . The following theorem (basically Hall's condition)
is a characterization of good assignments. 

\begin{restatable}{theorem}{density}
\label{thm:alpha-good-equivalent-to-no-bad-set}

For a canonical instance, an assignment  of heavy jobs is a -good assignment if and only if for every subset ,

\end{restatable}

\begin{proof}
We define an instance of the single-source single-sink network flow problem as follows.  Construct a directed bipartite graph , where edges are directed from  to . For every  such that , we have a vertex  that is connected to  and . All edges in  have infinite capacity.  Now an assignment  is -good if and only if we can send flow from  to  in  such that: (1) Each vertex  sends exactly  flow, and (2)
Each machine  receives at most  flow, where  is 1 if  and  otherwise.
By Hall's theorem, there is a feasible flow if and only if the following holds:
,
where  is the set of vertices in  adjacent to .  It is easy to see that for every , it suffices to consider the maximal  with . For this , we have . Thus, the condition can be rewritten as 
.
This finishes the proof.
\end{proof}

\subsection{Roadmap of the Proof}

We are now armed to precisely state the ingredients which make up the proof of \Thm{main-2}. 
In \Sec{app-canonical}, we show how to reduce any instance to a canonical instance.  
The precise theorem that we will prove is the following, where  is the number of machines. 

\begin{restatable}{theorem}{redtocanon}
\label{thm:reducing-to-canonical-instances}\label{thm:1}
Let  and . Given an instance  of the -restricted assignment problem with a feasible solution to , there is a polynomial time procedure to obtain an -canonical instance  such that any -good assignment for  implies a schedule of makespan at most  for .
\end{restatable}
\noindent
In \Sec{reducing-p-and-q}, we reduce a canonical instance to one with ``small''  and . More precisely, we prove the following.

\begin{restatable}{theorem}{redpq}
\label{thm:reducing-p-and-q}\label{thm:2}
For some large enough constant  the following is true. Given a -canonical instance , in polynomial time we can obtain a -canonical instance  such that any -good assignment for  is a -good assignment for , for every .
\end{restatable}
\noindent
Finally, in \Sec{fixq}, we show how given a -canonical instance we can `round' it to a -good instance where  is inverse {\em polylogarithmic} in the  parameter. Observe, from definition of canonical instances, -good assignments are trivial.

\begin{restatable}{theorem}{smallpq}
\label{thm:small-q-and-m}
For some large enough constant , every  and every , the following is true. Given a -canonical instance , there is a polynomial time procedure  to obtain a -good assignment for .
\end{restatable}
\noindent
Assuming the above theorems, the proof of \Thm{main-2} follows easily.
\begin{proofof}{\bf Proof of Theorem \ref{thm:main-2}} Let  be as in Theorem~\ref{thm:small-q-and-m}, and choose   such that . Let . Given a feasible solution to , we convert it to a -canonical instance  using \Thm{reducing-to-canonical-instances}. Then using \Thm{reducing-p-and-q}, we obtain a -canonical instance . Given , via \Thm{small-q-and-m}, we obtain a -good assignment with . This in turn implies a  -good assignment for . By choice of parameters, this is a -good assignment when .
By \Thm{1}, this implies a schedule of makespan  which proves \Thm{main-2}.
\end{proofof}
\noindent
The rest of the paper proves the above theorems in \Sec{app-canonical}, \Sec{reducing-p-and-q}, and \Sec{fixq} respectively which can be read in any order.

\section{Reduction to Canonical Instances}

\label{sec:app-canonical}
\label{app:app-canonical}
This section is devoted to proving \Thm{1}.
\redtocanon*

Let  be any feasible solution for .  The solution  defines the following weighted bipartite graph : if  for some ,  there is an edge  of weight . We will create the desired canonical instance  by performing the following sequence of transformation steps. 

\subsection{Processing Heavy Jobs}
Without loss of generality, we can assume  is a forest. Indeed, if there is an even cycle in the sub-graph, we can \emph{rotate} the cycle as follows. Color the edges of the cycle alternately as red and black. Uniformly decrease the  values of red edges and increase  values of the black edges. Observe that Constraints~\eqref{CLP:job-covered} and \eqref{CLP:machine-big-job} remain satisfied, and Constraints \eqref{CLP:zi-atmost-1}, \eqref{CLP:machine-small-job}  and \eqref{CLP:compact} are untouched since 's and 's for light jobs  did not change.  Apply the operation until the -value of some edge in the cycle becomes .  By applying this operation repeatedly, we can guarantee that the graph  is a forest. 
Some heavy jobs  may be completely assigned to a machine ; in this case, the edge  forms a two-node tree, since . We call such trees trivial.

We now further modify the instance so that each connected component in  is a star, with center being a heavy job, and leafs being machines.  Consider any nontrivial tree  in the forest . We root  at an arbitrary heavy job.  If the weight  between any heavy job  in  and its parent machine  is at most , we remove the edge  from .  After this operation,  is possibly broken into many trees.

Now focus on one particular such tree . Note the following facts about : (i)  is rooted at a heavy job ; (ii) every machine  in  has either 0 or 1 child since  for any child  of  in  and \eqref{CLP:zi-atmost-1} holds; (iii) all leaves are machines since a heavy job can only be partially assigned to its parent.  Thus, in , the number of heavy jobs is exactly the number of non-leaf-machines plus 1. 
\begin{lemma}
\label{lem:sum-z-is-large}
Let  be the set of leaf-machines in . Then .
\end{lemma}
\begin{proof}
Suppose there are  heavy jobs in the tree . Since we may remove an edge of weight at most  connecting the root of  to its parent in , we have , where  is the set of machines in .  Since  for each  and , we have .
\end{proof}

We assign heavy jobs in  to machines in  as follows. Each non-leaf machine of  is guaranteed to be assigned a heavy job.  There is one extra heavy job left, and we assign it to a leaf machine.  The following lemma shows that any leaf-machine can yield to a valid assignment for the heavy jobs.

\begin{lemma}
\label{lemma:choose-any-leaf-machine}
\label{lem:choose-any-leaf-machine}

Let  be any leaf-machine in . There is a valid assignment of heavy jobs in  to machines in  such that
\begin{enumerate}[itemsep=-2pt]
\item Any non-leaf-machine is assigned exactly one heavy job;
\item  is assigned exactly one heavy job;
\item No heavy jobs are assigned to other leaf-machines.
\end{enumerate}
\end{lemma}
\begin{proof}
Focus on the path from the root of  to the leaf-machine .  We assign each heavy job in this path to its child in the path.  For all the other heavy jobs, we assign them to their parents.  It is easy to see this assignment satisfies all the conditions.
\end{proof}
We now create a new set of heavy jobs to \emph{replace} the heavy jobs in .  For each non-leaf machine , we create a new heavy job  with . We also create a new heavy job  with  being the set of leaf machines.  By \Lem{choose-any-leaf-machine}, a valid assignment for the new machines implies a valid assignment for the original machines.  Notice that new created heavy jobs  have disjoint . This is true even if we consider the new jobs for all trees  as the machines in these trees are disjoint. For every new created heavy job , we have : if  for a non-leaf machine , then  as the weight of edge from  to its child has weight at least ; if  is the set of all leaves, then by \Lem{sum-z-is-large}, . 

We have created a new set  of heavy jobs for  and the sets  are disjoint. An assignment of these big jobs imply an assignment of  via \Lem{choose-any-leaf-machine}. From now on we let  and only consider the set of new heavy jobs. Thus, Property~\ref{property:ci-M} is satisfied.  

Since we haven't modified  and  for  and , Constraint~\eqref{CLP:zi-atmost-1}, \eqref{CLP:machine-small-job} and \eqref{CLP:compact} are satisfied. Constraint~\eqref{CLP:job-covered} is satisfied for light jobs . We did not define 's for the new created heavy jobs  and thus Constraint~\eqref{CLP:job-covered} for heavy jobs  and Constraint~\eqref{CLP:machine-big-job} are meaningless and henceforth will be ignored. 

We now scale down  by a factor of  for all machines in , then Constraint~\eqref{CLP:compact} is strengthened to

For every , we have . Every  is between  and . Moreover, if for some  and some  we have , we remove  from . Then, Property~\ref{property:ci-z} holds and Property~\ref{property:canonical-instance-big-job-covered} holds with .

\subsection{Processing Light Jobs}
Now let  be the weighted bipartite graph between  and . In this step, we make sure that each light job is fractionally assigned to exactly  machines.   To achieve this, perform the rotation operations to cycles in , as we did before for heavy jobs. Note that the rotation preserves the sum . In order to maintain Condition~\eqref{equ:CLP-strengthened-compact}, we may not be able to break all cycles in .  We say an edge  in  is tight if .  We can perform rotation operations so that the non-tight edges form a forest.  Also, since  for all machines ,  for a tight edge .  Thus, each light job  is incident to at most 1 tight edge.

For each non-singleton tree  in the forest formed by the non-tight edges,  we root  at an arbitrary light job and {\em permanently} assign each {\em non-leaf} light job in  arbitrarily to one of its children. These light jobs are then removed from . 
Notice that each machine can get permanently assigned at most 1 light job during this process.  Each unassigned light job in the tree  is incident to exactly one non-tight edge (since it was a leaf).

Therefore, each remaining light job  must be one of the following. First,  can be completely assigned to some machine  (thus  and ), then, we say  is of type-. Second,  maybe incident to two edges, one tight, the other non-tight. Let  be a tight edge and  be the other edge; then we say  is of type-.   This lets us define the matrix : we let  be the total load of light jobs of type-, or equivalently,  times the number of light jobs of type-.  For every light job  of type-, , we have  and .   Thus  satisfies Property~\ref{property:ci-w} and Property~\ref{property:canonical-instance-light-load-large} with .  Property~\ref{property:canonical-instance-load-small} holds with  as the  is exactly the total fractional load assigned to  which is at most  by \eqref{CLP:machine-small-job}

Property~\ref{property:canonical-instance-z-i-large} holds for a sufficiently large number  as each  can be represented using polynomial number of bits.  However, we would like to start with , where  is the number of machines. If  for some , we change  to  and remove  from . Then, Property~\ref{property:canonical-instance-big-job-covered} still holds for  as there are at most  machines. Thus, our canonical instance is -canonical.
This ends the proof of \Thm{1}.



\section{Reducing Parameters \texorpdfstring{}{p} and \texorpdfstring{}{q} in Canonical Instances}\label{sec:reducing-p-and-q}
This section is devoted to proving \Thm{2}. The proof is analogous to a similar theorem proved by Feige~\cite{Fei08} for max-min allocations, and 
therefore we only provide a sketch in the main body. 
All omitted proofs from this section can be found in \App{reducing-p-and-q}.
\redpq*

Using the characterization of -good assignment given in \Thm{alpha-good-equivalent-to-no-bad-set}, we define a {\em -witness} 
as a pair of sets which rules out any -good assignment.

\begin{definition}[-witness]
A pair  of subsets of machines is called a {\bf -witness} if  and 

Moreover, we call a -witness   {\bf connected} if  is (weakly) connected in the light load graph .
\end{definition}
\noindent


\begin{restatable}{claim}{connectedwitness}
\label{claim:witness-implies-connected-witness}
\label{clm:witness-implies-connected-witness}
If  is a -witness, then there is a connected -witness , with  and .
\end{restatable}

\begin{claim}
\label{claim:alpha-good-equivalent-to-no-witness}
\label{clm:alpha-good-equivalent-to-no-witness}
 is a -good assignment iff for every connected -witness  of , .
\end{claim}

Now, we prove two main lemmas for our algorithm that alternatively reduce  and .   Let  be a -canonical instance. If , \Lem{reduce-q} reduces it to a -canonical instance; if , \Lem{reduce-p} reduces it to a -canonical instance. 

\begin{restatable}{lemma}{reduceq}
\label{lemma:reduce-q}\label{lem:reduce-q}
 Let  be a -canonical instance. Assume .  Then, we can find in polynomial time a -canonical instance , such that any -good assignment  for  is -good for , where .
\end{restatable}

The proof follows from an application of asymmetric LLL. We want that Property~\ref{property:canonical-instance-light-load-large} holds for .  We apply the following natural procedure. For each  such that , we change  to  with probability  and to  with probability . We need to show that Property~\ref{property:canonical-instance-load-small} holds. Also, we need to show that any -witness in the original instance is also a -witness in the new instance. We apply the asymmetric LLL (\Thm{lll}) to show that all these properties can hold.  The idea is that a bad event depending on many other bad events must have a smaller probability.  The detailed proof is in \App{reducing-p-and-q-1}.

\begin{restatable}{lemma}{reducep}
\label{lemma:reduce-p}\label{lem:reduce-p}
 Let  be a -canonical instance, where .  We can find in polynomial time a -canonical instance  such that any -good solution  for  is also -good for , where .
\end{restatable}

This lemma is by symmetric LLL. To guarantee that each positive  has , we apply the following natural process: if , we change  to  with probability , and to  with the probability . All bad events in the proof are local; they only depend on a few variables.  Thus, a symmetric LLL suffices to prove the lemma. The detailed proof is in \App{reducing-p-and-q-2}.

To complete the proof of \Thm{2}, we apply \Lem{reduce-q} and \Lem{reduce-p} repeatedly till we obtain a -canonical instance , where 
with the guarantee that a -good solution to  implies a -good solution to the original instance. 

\section{Solving Canonical Instances with Small Values of \texorpdfstring{}{p} and \texorpdfstring{}{q}}
\label{sec:fixq}

This section is devoted to proving \Thm{small-q-and-m}.
\smallpq*

\noindent For convenience, we will make  by scaling down the light load matrix  by a factor of . After this operation, Property~\ref{property:canonical-instance-load-small} will hold with  as we have . Let ; then the new instance is -canonical except that Property~\ref{property:canonical-instance-big-job-covered} only holds with right side being  instead of  (as  for large enough ).  At the end, we can scale up light loads by . As each machine is assigned strictly less than    units of total load, the scaling will increase the light load on each machine by at most .  

Thus, we can assume   and focus on a -canonical instance  from now on.  With , Property~\ref{property:canonical-instance-load-small} implies that  for every .

 Given an assignment , for convenience we use  to denote the set of machines that are assigned heavy jobs. We define the concept of a `boundary' of a set which will be crucial in what follows.

\def\bnd{{\tt bnd}}
\begin{definition}[Boundary of a set]
Given a subset  of machines, we define its boundary as 
 
\end{definition}

\begin{definition}
Let the \emph{deficiency} of a machine  be . The deficiency of a subset  is . 
\end{definition}

Thus,  measures how far away Property~\ref{property:canonical-instance-load-small} is from being tight.  With the definition, we can rewrite the condition for -good assignments.  From \Thm{alpha-good-equivalent-to-no-bad-set},  is -good iff for every , we have 


Adding the definition of  for every , we get that  .

\ifdefined\CR
The left hand side of \eqref{eq:farkas} is

\else

\fi

Thus,   is -good iff for every  we have 


We fix  whose value will be decided later. We say a machine  is {\bf green} if   and {\bf red} otherwise.  Let  be the set of red machines.  


To check if  is -good, we can check the Inequality~\eqref{equ:good-assignments-condtion1} for every .   With some condition on  and some loss on the goodness, we only need to check the above condition for .  To be more specific,

\begin{lemma}
\label{lem:reduce-to-star}
Let .  Suppose  is a valid assignment with  satisfying
\begin{properties}
\item for every , we have ; \label{property:weight-to-x-small}
\item for every subset ,
. \label{eq:desire}
\end{properties}
Then  is a -good assignment.
\end{lemma}

\begin{proof}
 Decompose  where . Each machine in  contributes at least  to the left-side of Inequality~\eqref{equ:good-assignments-condtion1}. If , then the inequality with  replaced with  holds trivially.  

  So, assume . 
 For large enough , we get . 
  By Condition~\ref{eq:desire} for  being ,  we have .  Notice that .  Notice that for any machine ,   by Condition~\ref{property:weight-to-x-small} and . We have . Thus, .
\end{proof}

To prove \Thm{small-q-and-m},  it suffices to find an assignment  which satisfies Properties~\ref{property:weight-to-x-small} and \ref{eq:desire} for suitable  and . In the remainder of this section, we will focus on finding such an assignment.

\paragraph{Sketch of the Proof.}  Suppose for the time being all the positive 's are very close to .   implies that in the light load graph  any machine  can have in-degree at most . In other words,  is a collection of disjoint cycle-rooted trees. Suppose again there are no cycles, and so  is a collection of trees. 

Now consider the random process which allocates job  to machine  with probability proportional to .  We now describe some bad events such that if none of them occur we satisfy   \ref{property:weight-to-x-small} and \ref{eq:desire}. The first bad event is of course the negation of \ref{property:weight-to-x-small} (corresponding to  in what follows). The second  bad event (corresponding to  in what follows) occurs if the forest induced by  contains a connected component larger than . 

Note that if these bad events don't occur then any subset  which does not contain roots of trees in the forest satisfy \ref{eq:desire}   (for ). This is because every connected component contributes  in-degree to . 

Now suppose  contains the root  as well. Since  has no incoming edges and is red, by \ref{property:canonical-instance-load-small}, it has many out-edges. The third bad event (corresponding to  in what follows) occurs if lots of out-neighbors of a machine have been picked in . If 's doesn't occur in addition to the 's, then the out-edges of  which exit   contributes the boundary term in \ref{eq:desire}. In summary, if no bad event of type  occur, then \ref{property:weight-to-x-small} and \ref{eq:desire} are satisfied. The formal statement of this is \Lem{no-bad-events-and-we-are-done}.

To show that with positive probability none of the bad events occur, we invoke the asymmetric  Lovasz Local Lemma. To do so, we need to argue about the dependency structure of the various events.  We use a connection  to Galton-Watson branching processes described by Moser and Tardos to prove that  has `good' dependency properties (the concrete statement  is \Lem{galton-watson}.). The algorithm follows from the constructive versions of LLL due to~\cite{MT10,HSS11}.

Till now we have been assuming positive 's are close to . In reality, we divide the edges into two classes: {\em dense}, if  and {\em sparse} otherwise.  Note that dense edges no longer form trees. However, for each machine which has at least one dense edge coming into it (which are called {\em in-dense} later); we arbitrarily pick one of them and color it {\em red} and only count the red edges towards the boundary. 

The reason such a `sparsification' helps is that it decreases the dependence among events leading to the application of LLL. To take care of machines with only sparse in-coming edges, we need another type of bad events  (corresponding to  in what follows) whose non-existence implies a large contribution to the boundary for such machines.  This ends the sketch of the proof.  We begin the details with some definitions.

\begin{definition}
An edge  is {\bf dense} if , and {\bf sparse} otherwise, where  is large enough constant ( suffices).
\end{definition}

\begin{definition}
A machine  is {\bf in-sparse} if {\em all} incoming edges  are sparse. Otherwise,  is  {\bf in-dense}.
\end{definition}

\begin{definition}
A machine  is called {\bf out-dense} if  where  is a large enough constant ( suffices). Otherwise, the machine is called {\bf out-sparse}.
\end{definition}

We are now ready to describe our algorithm for assigning heavy jobs to machines satisfying \ref{property:weight-to-x-small} and \ref{eq:desire}.  Our algorithm starts with a pre-processing of the fractional solution, and then recovers a good integral assignment of heavy jobs from the pre-processed solution using randomized rounding. note by  is the set of machines getting heavy jobs.

\subsection{Pre-processing of the Instance}\label{sec:preprocessing}
For every in-dense, red machine , we arbitrarily select an incoming dense edge  of .  If  is red and out-sparse, we color the edge  in  red. Every machine has at most one incoming red edge. Moreover, the two end points of a red edge are also red. Then each connected component formed by red edges is either a tree, or a tree plus an edge. Recall  is the set of machines which we will assign heavy jobs and  is the set of red machines.

We want to  ensure that  does not contain any red cycles. That is, for any cycle of red edges in , we wish to ensure that at least one of these machines is not assigned a heavy job.  For each heavy job , we now identify a subset  such that (i) , and (ii) the subgraph of  induced by  does not contain a red cycle. 

We reduce the task of identifying  to an instance of the generalized assignment problem where red cycles correspond to jobs and groups correspond to machines. If a red cycle  contains two machines from a group , we can ignore it since one machine in the cycle will not get a heavy job. So assume  contains at most one job from each group . The cost of assigning a red cycle  to a group  is  if some machine  participates in the cycle  and  otherwise. Since each red cycle  contains at least two machines(if a red cycle contains one machine , then , implying  by Property~\ref{property:ci-w} and thus  is not in any ), a solution that assigns each  uniformly to groups of all machines contained in , is a feasible fractional solution where the load assigned to  is at most . We can now use the Lenstra-Shmyos-Tardos~\cite{LST90} algorithm to recover an integral assignment of red cycles to groups such that maximum load on any machine is at most the fractional load  plus the largest job size, which is at most .  Thus for any group , the total -value of machines chosen in the red cycle elimination step is at most  since .

\subsection{Randomized Assignment of Heavy Jobs and Bad Events}
Now we are ready to describe the randomized algorithm to get the heavy job assignment. For every heavy job , assign it to a machine  with probability proportional to . Note that the probability  a machine  gets a heavy job is at most . We describe the bad events.

\begin{itemize}[itemsep=2pt,parsep=2pt]
\item {Bad events , .}  occurs if  . Setting  is sufficient.
\item {Bad events , for a set  of  machines connected by red edges.}  occurs if .
\item {Bad events , .}  occurs if  .
\item {Bad events ,  is in-sparse.}   
occurs if .
\end{itemize}

\begin{restatable}{lemma}{chernoff}
\label{lem:probabilities}
The bad events described above have probabilities bounded as follows:
\ifdefined\CR

\else

\fi
\end{restatable}	

\begin{proof}
The second inequality is trivial. The remaining follow as easy consequences of \Thm{Chernoff}. For any machine ,  since  and by Property~\ref{property:canonical-instance-load-small} with . Since , and  are large enough, \Thm{Chernoff} implies . 

 implies for any machine , the expected number of out-neighbors  such that  is dense is at most .  Therefore, the probability that  occurs, by the second inequality of \Thm{Chernoff},  is at most .

For any machine , the expected value of  is at most  since red machines are sampled with probability at most . If  is large enough, .  Since  is in-sparse, each , and since  is red, .  Therefore . By the first inequality of  \Thm{Chernoff}, the probability  occurs is at most .
\end{proof}

\begin{lemma}\label{lem:no-bad-events-and-we-are-done}
If none of the bad events occur,  then  is -good  for  and  .
\end{lemma}

\begin{proof}
We show that if no bad events occur then both conditions of \Lem{reduce-to-star} hold. In fact, since  doesn't occur for any , we get \ref{property:weight-to-x-small} holds.  Fix a subset .  We now prove .   This is done by careful accounting.


Focus on an in-sparse machine .  Since  doesn't occur, we have .  By the definition of  we have . Thus, the contribution of  to  is at least .









The red edges induced by  form a forest of rooted trees, by the preprocessing step.   For each machine in the forest, we ask the root of the tree to contribute to . Let  be such a root.

If  is in-sparse, then its contribution is at least . Otherwise,  is in-dense and we have selected an dense incoming edge  in the pre-processing step.  If  is green, then .  If  is red and out-sparse, then the edge  is red and thus .  In either case, the contribution of  is at least . 

It remains to consider the case  is red and out-dense, and . In this case, we ask  to contribute to .   Let . Since   and  does not happen, we have .  as all machines in  are red.
\ifdefined\CR

\else

\fi
The quantity is at least  since  .

We count the number of times each machine is asked to contribute.  Since   events do not happen, every root  is asked at most  times.  Since  does not happen, every  is asked by at most  roots . Overall,  we have proved the lemma for .

\end{proof}

\subsection{Applying the Asymmetric LLL}
In this section, we show via LLL that no bad event occurs with positive probability. Using the results in~\cite{MT10,HSS11}, we get a polynomial time procedure to obtain an assignment such that no bad events occur. \Lem{no-bad-events-and-we-are-done} proves \Thm{small-q-and-m} for .  

We assign each bad event the following  values:  for any bad event. The key is arguing about the dependence structure of these events which we undertake next by defining the notion of relevant machines for each event.
For any event ,  the relevant subset of machines is the set  of out-neighbors of .  For any event ,  the relevant subset of machines is the set . For any event ,  the relevant subset of machines is the set  of heavy out-neighbors of .  For any event ,  the relevant subset of machines is the set  of in-neighbors and out-neighbors of . 
By the facts that  , and {\em that all positive  and  are at least} , we get that
. 
\def\group{{\tt group}}
For a machine , we let  denote the set  where  if it exists; otherwise . 
\begin{definition}
Two sets ,  of machines are {\bf group-disjoint} if no machine in  is in the same group with a machine in . That is, for any , .
\end{definition}

\begin{claim}
An event  is independent of  if the relevant subset of machines for these events are  group-disjoint.
\end{claim}

The main non-trivial lemma is the following.
\begin{restatable}{lemma}{galtonwatson}
\label{lem:galton-watson}
For every red machine , we have  where  is over all sets of size  containing  and connected by red edges.
\end{restatable}
\begin{proof} To argue about the probability of a connected set  being chosen so that ,  focus on the red machines  and the red edges induced on these machines.  The graph is a directed forest. We remove the directions, and focus on the connected component containing . Root this tree at  and let  be the set of children of  for any  in this rooted tree. Consider a branching process which selects  with probability  (recall  is the probability a machine  gets a heavy job), and if  is chosen, pick each child  with probability , and continue thus.
When this process terminates, we end up with some connected set . The probability that we get a specific set   is precisely 
\ifdefined\CR

\else

\fi
Since  as  is red, we have . Therefore, . If  is out-dense, then  has degree 1 thus has no children; the quantity is 1.
If  is out-sparse, then . As , we get that  . This implies .
Since  (the branching process leads to one set ), we get .
Now, 
.
\end{proof}
\noindent
To check the conditions of the asymmetric LLL is now just book keeping. 
For any bad event  we have 
\ifdefined\CR

\else

\fi
where  is the heavy job which can go to , and since , we have . Since , the RHS is at least  whenever .


Fix an event  where . Let us calculate upperbound the product
\ifdefined\CR

\else

\fi
where  is the heavy job which contains  in its . Since , the RHS is at least  since .
Similarly, 
\ifdefined\CR

\else

\fi
The number of terms in the RHS is at most . Since  (if  and ), the RHS is atleast  for large enough .

Finally, we have
\ifdefined\CR

\else

\fi
For any machine , the set  is precisely the neighbors of  (the machines of which  is a neighbor of are precisely the neighbors of ). Therefore, the number of terms in the summation is at most 
. Since , we get that the RHS is at least  for large enough . In sum, we get that for any event , we have
\ifdefined\CR

\else

\fi
implying that  satisfies the LLL condition. 

Finally note that the number of events of type  are polynomially many, and given an assignment of heavy jobs, one can easily check if one of the  occurs or not. Therefore, \Thm{hss-1} applies  
and this completes the proof of \Thm{small-q-and-m}.

\bibliographystyle{plain}
\bibliography{reflist}

\appendix
\section{A \texorpdfstring{}{2-epsilon} algorithm for the \texorpdfstring{}{(1,epsilon)}-restricted assignment problem.}
\label{app:large-eps}

\begin{theorem}
There exists a polynomial time algorithm which returns a -approximation to the makespan minimization problem in -restricted assignment instances. There exists a polynomial time -factor algorithm to estimate the optimal makespan in -restricted assignment instances.
\end{theorem}
\begin{proof}
We construct a bipartite matching problem. Vertices on the right side correspond to jobs. Suppose  is the optimum makespan.  For each machine , we create  heavy slots and   -  light slots. There is an edge between a heavy slot and all jobs that can be assigned to the machine; there is an edge between a light slot and all light jobs that can be assigned to the machine. It is easy that there is a matching that covers all jobs. Each machine gets a total load at most .

This gives a  approximation for the problem. By combining this with the -estimation algorithm of Svensson~\cite{Sve11}, we obtain an algorithm that estimates the make span  up to a factor of .

\end{proof}


\section{Hardness of \texorpdfstring{}{(1,epsilon)}-restricted assignment problem}
\label{app:hardness}
We complement our algorithmic result with the following hardness of approximation result.

\begin{theorem}\label{thm:3}
For any , 
it is NP-hard to approximate the makespan of the -restricted assignment problem to a factor better than .
\end{theorem}
\begin{proof}
We reduce from the problem of finding a vertex cover in cubic graphs: there exists parameter  so that it is NP hard to decide whether an -vertex cubic graph has a vertex cover of size  or not.
Given a vertex cover instance  on  vertices, we construct an instance of  as follows: we have a machine for every vertex , a set of  heavy jobs that can be assigned to any machine,
a set of  light jobs  for every edge  with job  having
 and can be scheduled on machine  or machine .

If  has a vertex cover of size , then we can find a schedule of makespan . 
Let  be the vertex cover; allocate all heavy jobs to machines corresponding to . For every edge , we are guaranteed one of the end points lies in  and thus doesn't have a heavy job. Allocate all jobs of  to that machine. Any machine gets a total small load of at most , and any machine getting a heavy job doesn't get a light job. 

If  doesn't have a vertex cover of size , then no matter how the heavy jobs are allocated, there must be an edge  such that both  and  are allocated heavy jobs. The total load on one of these two machines is at least .
\end{proof}

\section{Some Useful Tools}\label{app:useful-tools}
We state below two results that we will frequently utilize in our analysis. 

\begin{theorem}
\label{thm:Chernoff}
Let  be the sum of independent scalar random variables each individually in range  and . Then for any , we have

For any , we have
\ifdefined\CR

\else

\fi
\end{theorem}
\begin{proof}
All those bounds are simple application of standard Chernoff bounds.  Let  be the sum of  independent random variables, each take value in .  Let . Then for every , we have 

For every , we have 


To prove the theorem, we can scale the random variables by a factor of  and then mean of  is changed to . Thus, we can assume .  

The first inequality is obtained by setting  and observing that  for .  For the second inequality and third inequality, let . The second inequality holds since . The third inequality holds since .

\end{proof}
\begin{theorem}[Asymmetric LLL]\label{thm:lll}
Let  be a finite collection of (bad) events in a probability space.
For each , let  denote a subset of events such that  is independent of each event in . Then if there exists an assignment 
 satisfying the property ,
the probability that none of the events in  occurs is at least .
\end{theorem}

While the version stated above is only an existence statement, the recent work of Moser and Tardos~\cite{MT10}, and Haeupler et al.~\cite{HSS11} has given polynomial-time algorithms for finding a solution that avoids all bad events. We  use the notation  to indicate that .
Let  be  independent random variables. Let  be a finite collection of (bad) events where each  only depends on a subset  of variables.   Let .  

The Moser-Tardos (MT, henceforth) algorithm does the following: a) Initially sample 's independently, and b) until all 's are dissatisfied, pick an arbitrary satisfied  and resample the 's present in .
Moser and Tardos~\cite{MT10} showed that if the LLL condition held, the above algorithm terminated in  iterations. 
This suffices for many applications; however there are two issues -- a)  could be superpolynomial in , and b) given a setting of 's there may not be an efficient method to detect if a satisfied  exists or not.
Haeupler et al.~\cite{HSS11} addressed these issues in the following ways. 

\begin{theorem}(Paraphrasing of Theorem 3.1 in~\cite{HSS11})\label{thm:hss-1}
Suppose the LLL condition holds, and let . Then the expected number of resamplings of the MT algorithm is at most 
.
\end{theorem}

The above theorem takes care of situations where the number of events may be superpolynomial; however, `efficient verifiability' occurs, that is, given a setting of 's one can detect a satisfied   or assert none hold.
To take care of issue (b) above, Haeupler et al.~\cite{HSS11} modified the MT algorithm as follows. It parametrizes the events 
with a set  of {\em core events}. Randomly and independently assign a value to each random variable in .  In each iteration, we check if any bad event  happens. If there is such a bad event , we resample all variables in  and start a new iteration. Otherwise we terminate the algorithm return the current assignment.  


\begin{theorem}(Paraphrasing of Theorem 3.4 in~\cite{HSS11})\label{thm:hss-2}
Suppose there exists an  and assignment  such that a slightly stronger-than-LLL condition holds:

Suppose further, that . Then 
\begin{enumerate}
\item For any , the set  is of size at most .
\item With probability , the HSS algorithm with core events  terminates after  resamplings and returns an assignment such that no event in  occurs.
\end{enumerate} 
\end{theorem}




\section{Omitted details from \Sec{reducing-p-and-q}}
\label{app:reducing-p-and-q}
\connectedwitness*
\begin{proof}
Consider all the (weakly) connected components of (the sub-graph of  induced by ). There must be some connected component induced by  such that , since summing up the left side over all connected components  gives  and summing up the right side gives . Thus,  is a connected -witness.
\end{proof}

\Clm{alpha-good-equivalent-to-no-witness} follows
immediately from \Thm{alpha-good-equivalent-to-no-bad-set} and \Clm{witness-implies-connected-witness}.

\subsection{Proof of \Lem{reduce-q}}
\label{app:reducing-p-and-q-1}

Before the proof of the Lemma, we need one simple claim. 
\begin{claim}
\label{clm:degree-is-small}
For any -canonical instance, we have  for every . 
\end{claim}

\begin{proof}
Since  and , we have .  

Consider any machine . Notice that  and  if . We have .
\end{proof}

\reduceq*
\begin{proof}


For each pair  with , we let  with probability  and let  with probability .  For all other pairs , we let . Then  is the new canonical instance. 
\begin{enumerate}
\item , for every machine :   occurs if ;
\item , for every connected -witness  of :  occurs if  is not a -witness of .
\end{enumerate}

If none of the bad events occur, then  is a -canonical instance; furthermore, any -good assignment for  must be a -good assignment for  since
otherwise  would occur for some connected -witness.
In the rest of the proof, we use LLL to show that none of the bad events occur with positive probability. Using the techniques of ~\cite{MT10,HSS11}, there is a polynomial time procedure which obtains  with the desired property. 

Focus on the quantity  on the left side of the inequality defining .  All random variables (the s) in  take value in  and the coefficient before each random variable in  is at most 1; moreover, .
By Property~\ref{property:canonical-instance-load-small}, we have .    The Chernoff bound in \Thm{Chernoff} gives that the probability that  occurs is at most .  

Now consider the bad event . Since  is a -witness of , we have .    occurs if . Again, by Chernoff bound, the probability that  occurs is at most .

Now we apply the (asymmetric) LLL. In order to apply LLL, we need to define the  values for the bad events. 
Define  and . 

Focus on some bad event . If  is dependent of , then either , or  and . By \Clm{degree-is-small}, the number of events  dependent of  is at most  since each positive  has  and .  We count the number of events  dependent on  satisfying .   is dependent on  only if . Since the degree of vertices in  is at most , and  is connected, the number of sets  is at most . \footnote{We can use the same argument as in \cite{Fei08}. Given a graph  of degree  and a vertex , we want to bound the number of induced connected sub-graphs of  containing . Fix an arbitrary spanning tree for the sub-graph and root it at . There are at most  tree structures: visiting the tree in the DFS order and we only need to specify which  edges are forward moves. Given a tree structure, there at at most  choices for the tree. Thus the number is bounded by .} 
For a fixed , there are at most  different sets .  Thus, the number of such dependent events is at most .  This gives, 
\ifdefined\CR

\else

\fi
where the product in the LHS is over all events  dependent on .  

Now consider some bad event  with . Using a similar counting argument, the number of events  that are dependent on  is at most  and the number of events  dependent on  satisfying  is at most .  Thus, 
\ifdefined\CR

\else

\fi
We have verified that the conditions for the asymmetric LLL, and this completes the proof of the lemma.

To see how the theorems of~\cite{MT10,HSS11} can be applied, note that that there are at most  events of the type . The events  are exponentially many and do not seem to be efficiently verifiable. 
This is where one uses \Thm{hss-2} of~\cite{HSS11}. Note in the above analysis, \eqref{eq:HSS} holds with . The theorem implies the `core bad events' which have , that is, those with  , are at most . Since these can be enumerated over using a BFS tree, 
we can find a `good' assignment in polynomial time.
\end{proof}

\subsection{Proof of \Lem{reduce-p}}
\label{app:reducing-p-and-q-2}
\reducep*
\begin{proof}
For every  with , we let  with probability  and let  with probability . For all other machines , we let .  Note that . 

To make  a canonical instance, we need to apply more operations. If some  has , we need to remove  from . If , for every , we need to change the  light load of type- to load of type-.  However, these operations do not affect our proof. Thus, we can pretend our new instance is .

Since the definition of a -good assignment is independent of ,  a -good assignment for  is a -good assignment for . The non-trivial part is to show that  is -canonical. The non-trivial properties are  \ref{property:canonical-instance-big-job-covered} and \ref{property:canonical-instance-load-small}. Note that \ref{property:canonical-instance-z-i-large} is satisfied by the construction above and \ref{property:canonical-instance-light-load-large} is untouched.

To this end, consider the following two types of bad events. If none of the bad events occur we are done. Once again, we use LLL to show that none of the bad events occur with positive probability, and the lemma is proven by the theorems of~\cite{MT10,HSS11}.
\begin{enumerate}
 \item :  occurs if .
 
\item .  occurs if .
\end{enumerate}

Consider the quantity  on the left side of the inequality defining . Notice that we have .  All random variables  take value in ; moreover, we have .   The coefficient before each  in  is at most . The coefficient before  is at most  but might as small as . If  is not fixed and the coefficient before it is negative, we define  and replace the random variable  with . The Chernoff bound in \Thm{Chernoff} gives that  happens with probability
.

Now focus on  for some .  Since the unfixed random variable  takes value between  and , the Chernoff bound gives that the probability that  occurs is at most .
In order to apply the uniform LLL,  we need to upper-bound the number of bad events that each  (or ) depends on.  
 and  are dependent only if  and  are adjacent ;  and  are dependent if there exists  such that  and  are adjacent in . 
Since each  and  since the degree of the graph  is at most  by \Clm{degree-is-small},  any bad event is dependent on at most  other events.  Thus the symmetric LLL conditions hold, and thus with positive probability none of the bad events occur.
The polynomial time algorithm follows directly from~\cite{MT10} since the number of bad events is polynomially many.
\end{proof}

\end{document}