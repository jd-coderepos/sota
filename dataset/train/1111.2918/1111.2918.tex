\documentclass[12pt]{llncs}
\usepackage{lineno}
\pagestyle{plain}
  \pagenumbering{arabic}
\usepackage{amsmath,amssymb,amsmath}
\pdfoutput=1
\usepackage{ifpdf}
\usepackage{graphicx}
\usepackage{color}
\usepackage{fullpage}
\usepackage{textcomp}
\usepackage{setspace}
\usepackage{algorithmic}
\usepackage[ruled]{algorithm}
\usepackage{ulem}
\newtheorem{observation}{Observation}
\newtheorem{result}{Result}
\setlength{\parskip}{1.3mm} \setlength{\parindent}{0pt}
\setlength{\parindent}{0pt}

\newcommand{\red}[1]{{\textcolor{red}{#1}}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\newcommand{\comment}[1]{{\red{({\em #1})}}}
\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}

\frenchspacing


\title{Localized Geometric Query Problems}
\author{John Augustine\inst{1} \and Sandip Das \inst{2} \and 
Anil Maheshwari \inst{3}\thanks{Research supported by NSERC.} \and Subhas C. 
Nandy 
\inst{2} \and 
Sasanka Roy\inst{4} \and  \\ Swami Sarvattomananda \inst{5}}

\institute{Department of Computer Science and Engineering, Indian Institute of 
Technology 
Madras, Chennai, India
\and  Advanced Computing and Microelectronics Unit, 
Indian Statistical Institute, Kolkata, India
\and  School of Computer Science, Carleton University, 
Ottawa, Canada
\and Chennai Mathematical Institute, Chennai,India
\and  School of Mathematical Sciences, Ramakrishna 
Mission Vivekananda University, Belur, India}



\begin{document}
\maketitle



\begin{abstract}
A new class of geometric query problems are studied in this paper. 
We are required to preprocess a set of geometric objects  in 
the plane, so that for any arbitrary query point , the largest 
circle that contains  but does not contain any member of , 
can be reported efficiently. The geometric sets that we consider 
are point sets and boundaries of simple polygons. 
\end{abstract}

{\bf Keywords:} Largest empty disk, query answering, medial axis, computational 
geometry

\vspace{-0.2in}
\section{Introduction}
Largest empty space recognition is a classical problem in computational 
geometry, and has applications in several disciplines like database 
management, operations research, wireless sensor network, VLSI, to name 
a few. Here the problem is 
to identify an empty space of a desired shape and of maximum size in a  
region containing a set of obstacles. Given a set  of  
points in , an {\it empty circle}, is a circle that does 
not contain any member of . An empty circle is said to be a {\it 
maximal empty circle} ({\tt MEC}) if it is not fully contained in any 
other empty circle. Among the {\tt MEC}s, the one having the maximum radius 
is the {\it largest empty circle}. The largest empty circle among a point 
set  can easily be located by using the Voronoi diagram of  in 
 time \cite{T}. 



Although a lot of study has been made on the empty space recognition 
problem, surprisingly, the query version of the problem  has not received 
much attention. The problem of finding the 
largest empty circle centered on a given query line segment has been 
considered in \cite{APS10}. The preprocessing time, space and query time 
complexities of the algorithm in \cite{APS10} are ,  and 
, respectively. In practical applications, one may need to 
locate the largest empty circle in a desired location. For 
example, in the VLSI physical design, one may need to place a large circuit 
component in the vicinity of some already placed components. Such problems 
arise in mining large data sets as well, where one of the objectives is to  
search for empty spaces in  data sets\ \cite{LKH1997}. In\ \cite{EGLM2003}, 
Edmonds {\it et al.} formalized the problem of finding  large empty spaces in 
geometric data sets. In particular, they studied the problem of finding large empty 
rectangles in data sets. 


An important problem in this context is the {\it circular 
separability problem}. Two planar sets  and  are circularly 
separable if there is a circle that encloses  but excludes . 
O'Rourke {\it et al.} \cite{OKM86} showed that the decision version of the circularly 
separability of two sets can be solved in  time using linear 
programming. Furthermore, they show that a smallest separating circle can be found 
in  time while the computation of the largest separating circle needs 
 time. Detailed study on circular separability problem can be 
found in \cite{BCDUY00,BCOY01,Fisk86,OKM86}. Boissonnat {\it et al.} \cite{BCOY01}
proposed a linear-time algorithm for solving the decision version of
circular separability problem where the sets  and  are simple
polygons, and the algorithm outputs the smallest separating circle. They also 
consider the query version of this problem where the objective is to
preprocess a convex polygon  such that given a query point  and a query
line ,  report the largest circle inside  that contains  and
does not intersect . The preprocessing time and space
complexities of their proposed algorithm are both , and the query
can be answered in  time. They also showed that a convex polygon
 can be preprocessed in  time and space such that for a query set 
of  points, the largest circle inside  that encloses  can be computed
in  time.

In addition to empty circles, empty rectangles have also been studied. We introduced the query version of the maximal empty rectangle in \cite{ADMNRS10}. The problem entails preprocessing a set of  points such that, given a query point , the largest empty rectangle containing  can be reported efficiently. We gave a solution with  query time   with preprocessing time and space being  and , respectively.
Recently, Kaplan {\it et al.} \cite{KMNS12} improved the preprocessing time 
and space complexities  to  and 
, respectively, while the query time has increased to 
. Here  is the inverse Ackermann function.

\subsection{Our Results}
In this paper, we  study the query versions of the maximum empty circle  problem ({\tt QMEC}).  
The following variations are considered. 
\begin{itemize}
\item Given a simple polygon , preprocess it 
such that given a query point , the largest circle inside  
that contains the query point  can be identified efficiently.
\item Given a set of points , preprocess it such 
that given a query point , the largest circle that does not contain 
any member of , but contains the query point  can be identified 
efficiently.
\end{itemize}
Our results are summarized in Table 
\ref{TAB1}.
\begin{table} \caption{Complexity results for different variations 
of largest empty space query problem}
\begin{center}
\begin{tabular}{|l|c|c|c|} \hline 
Geometric set  & Preprocessing & Space & Query
time \\ 
&  time  &  & \\ \hline 
Simple Polygon &   &  & 
 \\ \hline 
Point Set &   &  &  
\\ \hline
Point Set &   &  &  
\\ \hline
\end{tabular}
\end{center}
\label{TAB1}
\vspace{-0.15in}
\end{table}

We believe that our work will motivate the study of new types of geometric 
query problems and may lead to a very active research area. The main 
theme of our work is to achieve  subquadratic preprocessing time and space, while ensuring 
polylogarithmic query times. 
The results in this paper, improve upon the results in our previous 
work  \cite{ADMNRS10}. Very recently, Kaplan and Sharir\ \cite{KS12} provided a solution to the {\tt QMEC} problem for point sets that only requires  time and  space for preprocessing. Their query times, however, are .


\subsection{Organization of the paper}
In Section \ref{sec:Convex}, as a preliminary requisite, we describe a way to answer {\tt QMEC} query for the case of convex polygons. The same bounds have been achieved by  Boissonnat {\it et al.} 
\cite{BCOY01}, but
our solution is slightly different and serves as the basis for solving the {\tt QMEC} problem on simple 
polygons. In Section \ref{sec:simple-polygon-case}, 
we present the {\tt QMEC} problem for simple polygons with  vertices. The preprocessing 
time and space complexities are  and  respectively, 
and the query answering time is . In Section \ref{sec:QMEC}, we 
consider the same problem on  a set  of  points in . We present 
two algorithms (cf. Table\ \ref{TAB1}). Our first algorithm uses the 
concept of planar separators \cite{LT79} on the underlying planar graph corresponding to 
the  Voronoi  diagram of  . It solves the {\tt QMEC} 
problem  on  with  preprocessing time 
and  space. Here, the queries can be answered in  time. Our second algorithm (cf. Section\ \ref{sec:fastquery}) uses the -partitioning \cite{fed} of planar graphs. With a suitable 
choice of
, the query time is only , an improvement over our first algorithm. However, the preprocessing time 
and 
space increase
to   and , respectively. 

\section{Preliminaries: {\tt QMEC} problem for a convex polygon}
 \label{sec:Convex}


Let  be a convex polygon and  be its
vertices in counter-clockwise order. Our objective in this section is to preprocess
 such that given an arbitrary query point , the largest
circle  containing  inside the polygon  can be reported 
efficiently. Note that, the locus of the centers of all the maximally empty circles ({\tt MEC}s) 
inside  is defined to be the {\em medial axis}  of . Let  be the center of 
the largest {\tt MEC} inside  (see Figure \ref{fig:figure1}(a)).\footnote{There can be 
infinitely many {\tt MEC}s of largest radius, in which case we pick 
 to be the center of one such {\tt MEC}.} The medial 
axis of a convex polygon consists of straight line
segments and can be viewed as a tree rooted at  \cite{CSW99}. To
avoid  confusion with the vertices of the polygon, we call the
vertices of  as nodes. Note that, the leaf-nodes of  are the
vertices of . Let us denote an {\tt MEC}  of  centered at a point  as  and let  be the area of . 

In \cite{BCOY01}, a planar map of circular arcs is constructed by drawing the {\tt 
MEC} at 
each node of  in  time and space.
The problem of finding  reduces to the point location problem in
the associated planar map.  These point location queries can be answered in   
time. We propose an 
alternative solution (with the same complexity results as in\ \cite{BCOY01})  because our new technique plays a basic role in solving 
the problem when  is a simple 
polygon (cf.  Section\ \ref{subsec:MiM}). We use the fact that the medial 
axis 

is a tree, and then use the level-ancestor queries \cite{BF04} on . \begin{figure}
[thb]
\centering  
\includegraphics[width=\textwidth]{figure1.pdf}
  \caption{(a) Illustration of Lemma \ref{obs1}, and  (b)
partition of .}
  \label{fig:figure1}
\end{figure}

\begin{lemma}\cite{BCOY01} \label{obs1}
As the point  moves from the center  of the largest MEC  along the medial axis 
towards any
vertex  (leaf node of ),  decreases
monotonically.
\end{lemma}



\begin{lemma}\label{llx}
The polygon  can be preprocessed in  time such that given any
arbitrary query point , a point  on  such that  contains  
can be 
reported in  time. 
\end{lemma}
\begin{proof}
The medial axis  subdivides   into  convex faces 
such that each face  consists of an edge  from 
and a convex chain of edges from  connecting  to  (see Figure 
\ref{fig:figure1}(b)). In the preprocessing phase, we perform the following steps.
\begin{enumerate}
\item Compute the medial axis  of , which is a tree rooted at .
\item Compute the subdivision  in  time. For this we will need , which 
can be computed in linear time \cite{CSW99}. 
\item Store the chain of edges associated with each face in an array so that it is 
amenable to binary searching.
\item Finally, the subdivision can be 
preprocessed in  time so that the face containing a query point 
 can be located in  time \cite{Krik83}.  
\end{enumerate}
 
In the query phase, we perform the following steps.
\begin{enumerate}
\item  We find the face  that contains  in  time. 

\item Recall that exactly one edge
 of  will be an edge in .  Consider the line  through  
that is perpendicular to the edge . It will intersect an edge in  that is 
also an edge bounding ;  we report that intersection point 
as . Note that  can be computed in  time via binary searching over the chain of medial axis edges bounding .
\end{enumerate}
We need to  prove that  indeed encloses .  Firstly, note that  
will  intersect the edge  internally at a point  because (i)  is 
convex and (ii) the two internal angles in  at  and  are both acute.  
Secondly, note that any {\tt MEC} that goes through  must be tangential to , thereby making it unique and centred on ; more precisely, the {\tt MEC} 
that goes through  must be centred at . Finally, from the construction, it is clear 
that  lies on the diameter of  , thus proving that that  
encloses . 
\qed
\end{proof}


Now we will describe how to solve the {\tt QMEC} problem for a convex
polygon. Given a  query point  we find (using Lemma\ \ref{llx}) the point  on 
 such that  encloses . 

Observe (informally for now) that, for any fixed point  inside , the {\tt MEC}s 
that encloses  are centered on a connected subtree  of the medial axis . This observation is formally proved in Lemma\ \ref{l1} in the more general setting of 
simple polygons. Coupling this observation with Lemma\ \ref{obs1}, we can conclude 
that  is the point on  closest to the root  of . Therefore, we can 
locate  by performing a binary
search on the path . We find two consecutive nodes  
and its parent  on the path  such that  encloses , but 
 does not.  Since the path lies on a 
tree representing the medial axis , we can use level-ancestor 
queries \cite{BF04} for this purpose. After computing  and , 
the exact location of  can be computed in  time. Thus, 
we have the following theorem:

\begin{theorem} \label{th-QMEC-convex}
A convex polygon  with   vertices can be preprocessed in  time
and space such that, given any arbitrary query point , the largest circle 
containing 
 inside  
can be reported in  time.
\end{theorem}



\vspace{-0.2in}
\section{{\tt QMEC} problem for simple polygons} \label{sec:simple-polygon-case}
Let  be a simple polygon on  vertices. Recall that the
{\it medial axis}  of  is defined to be the locus of  the centers of all
circles inside  that touch the boundary of
 in two or more points (see, e.g.,  \cite{CSW99}). While the medial axis of
a convex polygon consists only of straight line segments, the medial axis of 
a simple polygon may additionally contain parabolic arcs \cite{P1977}.

Our approach for solving the 
{\tt QMEC} problem uses the fact that 
 is a geometric tree. Its {\it leaf nodes} 
correspond to the vertices of , and the {\it internal nodes}
correspond to the points on  such that the {\tt MEC}s  centered at each 
of those points touch three or more distinct points on the boundary 
of . We  denote the set of internal nodes of  as . An {\it edge} in 
 is a path between two nodes that does not contain  any other node in its interior. Note that 
 a single edge  consists of one or more line segments or parabolic arcs.

For any point , we denote the maximal empty circle centered at  in  
by .
A point , that is not a leaf, is said to be a {\it
valley} (resp., {\it peak}) if for a positive , the {\tt MEC}s
centered at points in  within  distance  from  are at
least as large as (resp., no larger than)  and at least 
one such {\tt MEC} is strictly larger (resp., smaller) than . Note that a pair of parallel edges in  may induce a pair of peaks or a pair of 
valleys. In such cases, we only pick one representative peak or valley and discard the 
other. We use  and  to denote the set of valleys and 
peaks, 
respectively.  For any , it is easy to observe that  touches  in exactly two points diametrically opposed to each other. Otherwise, we can move along a direction to get smaller {\tt MEC}s. 
 As a consequence, a valley can only be in the interior of an edge.
Therefore, . On the other hand, . 




We define a {\em mountain} to be a maximal subtree of 
 that does not contain any valley point (except as its leaves). 
We partition  by cutting the tree at all the valley 
points, and generate a set of mountains  
(See Figure \ref{fig:MedialAxisPartitioning}(a)). 
\begin{observation} \label{o} ~\\
(i) Each valley point is the common leaf of exactly two mountains.\\
(ii) Each mountain has exactly one peak.\\
(iii) If a point  moves from a valley point of a 
mountain towards its peak, the size of  increases monotonically.  
\end{observation}
\begin{proof}
Suppose  is a valley point. We have noted earlier that  can only be in 
the interior of an edge. Therefore,  must be a common leaf between exactly two mountains.

For part (ii), assume that there are two peaks  and  in a mountain. Consider the path in  from  to  (denoted ). Consider the point .  One can observe that  will be a valley, implying that  and  cannot be in the same mountain.

 Consider a point  that moves from a valley  of a 
mountain towards its peak. If the {\tt MEC}s don't increase monotonically, 
it is easy to see that a valley point will be encountered. This
implies that  has moved into another mountain.\qed
\end{proof}
\begin{figure}[h]
\begin{minipage}[c]{0.5\textwidth}
\begin{center} \includegraphics[width=0.95\textwidth]{figure2a.pdf}\\
(a)  
\end{center}
\end{minipage}\begin{minipage}[c]{0.5\textwidth}
\begin{center} \includegraphics[width=0.95\textwidth]{figure2b.pdf}\\
(b)  
\end{center}
\end{minipage}
\caption{(a) Partitioning the medial axis 
 into mountains, and (b) The subtree  for a query point }
\label{fig:MedialAxisPartitioning}
\end{figure}

At each valley point  of , consider the chord in  connecting the two points 
at which  touches . These chords induced by each  will 
partition  into  a set of sub-polygons  of 
cardinality equaling the total number of mountains because this 
partitioning ensures that the portion of   contained in each of these sub-polygons 
is a 
mountain containing a single peak. 

Given a (query) point , let  denote the locus of the 
centers of all possible maximal empty circles in  that enclose  (see 
Figure \ref{fig:MedialAxisPartitioning}(b)). The following structural lemma 
plays a crucial role in designing our algorithm. 
\begin{lemma} \label{l1}
 is a (connected) subtree of .
\end{lemma}
\begin{proof}
For the sake of contradiction, let us assume that  is disconnected. Then, there 
are at least two distinct  points  and  on the medial axis such that 
(a)  and  contain , but (b)  
does not contain  for some   on the path along the medial axis connecting 
 and .   

Without loss of generality, we assume that such a  is not a node in . 
Therefore,  touches the simple polygon  at exactly two points, 
 and . The chord  partitions  into two polygons  and 
 to the left and right of  respectively (see Figure~
\ref{fig:fig_lemma3}(a)). 
Note that,  also partitions the medial axis into two subtrees,  and 
, 
such that  and . For the rest of the proof, 
we use  and  to denote the region enclosed by  
them. We now claim that 




\begin{figure}[ht]
\begin{minipage}[b]{0.57\linewidth}
\centering
\includegraphics[width=0.7\linewidth]{fig_lemma3.pdf}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.37\linewidth}
\centering
\includegraphics[width=\linewidth]{Lemma3_SplCase.pdf}
\end{minipage}
\caption{Proof of Lemma \ref{l1}: (a) the general case, and (b) a special 
case where the points  and  are concave vertices of }
\label{fig:fig_lemma3}
\end{figure}


To show that Equation \ref{eqn:clm} holds, we consider the following cases.


\begin{description}
\item[Case:  touches  at both  and :] 
This case is illustrated in Figure~\ref{fig:fig_lemma3}(b). Here,  and  
must be concave vertices that induce a straight line segment edge in the medial 
axis. Both  and  are on that edge; in particular,  will be to the 
left of . It is now easy to infer that Equation~\ref{eqn:clm} holds.

\item[Case:  touches at most one of :]
Let  touch the other point  on the boundary of . 
Clearly, . If we assume that  
 also passes through a point , 
then 
it is  
impossible to construct  without properly enclosing 
some point outside . Therefore, Equation~\ref{eqn:clm} holds.
\end{description}
By symmetry, we can also say that 


Taking the intersection  of Equations~\ref{eqn:clm} and \ref{eqn:sym}, we get

 \\
=  
=  (since  .

This contradicts our assumption that  falls in  and , 
but not in .
\qed 
\end{proof}



\begin{corollary}\label{l2}
Let  be such that  does not contain . Then  is 
contained 
entirely in one 
of the subtrees of  obtained by deleting  from .
\end{corollary}
\begin{corollary}\label{cor:intermediate}
Consider two points , such that  overlaps with  .
Let  be a point in  such that .
Then  will lie in all {\tt MEC}s centered  along 
the path from  to  in . 
\end{corollary}
\begin{proof}
Since  overlaps with   and , both  and  are points on . The result  now follows 
immediately  from Lemma\ \ref{l1}. 
\qed
\end{proof}

Before we delve into solving {\tt QMEC}, in the next three subsections, we define 
three data structures that we use as building blocks.


\vspace{-0.15in}
\subsection{{\tt PLiCA}: Point location in circular arrangement} \label{sec:plica}
The problem is to preprocess a set 
 of circles 
of arbitrary radii, so that for any query point  in the plane, we need to 
quickly report if there exists a circle  such that . 
This can be achieved by using the concept of Voronoi diagrams in Laguerre geometry 
of circles in  \cite{IIM}. Each cell of the Voronoi 
diagram is a convex polygon and is associated with a circle in 
. The membership query is answered by performing a 
point location in the associated planar subdivision. 
The preprocessing time and space complexities are  and 
 respectively, and the queries can be answered in  time.

\vspace{-0.15in}
\subsection{{\tt QiM}: Query-in-Mountain}\label{subsec:MiM}
Given a mountain , we must preprocess it such that given a query point  inside  such that  (and a point ),
our task is to report the largest {\tt MEC}  centered at a point on  that contains 
. 
Note that if the center moves 
from  towards the peak of , the size of the 
{\tt MEC} increases monotonically. Thus, we can apply the algorithm proposed in 
Section\ \ref{sec:Convex} for the convex polygon case to identify the largest {\tt MEC}  
containing , and centered on . 
The preprocessing time and space complexities for the mountain  are both 
, and the query time is , where  denotes the 
number of edges in the sub-polygon   that induces . Since the 
set of mountains and sub-polygons are partitions of the medial axis  and the 
polygon , respectively, all the 
mountains can be preprocessed for the {\tt QiM} queries in  time. 


\subsection{{\tt QiC}: Query-in-Circle (Problem Definition and Bounds)} 
\label{qic_defn}
The {\tt QiC} is a simplification of the {\tt QMEC} problem in which, in addition to  and its medial
axis , a node  of    is 
specified as part of the input for preprocessing. We are  promised that 
the query point  will lie inside . As in , we are to report 
the largest {\tt MEC}  that contains . We defer the details of our solution for the 
{\tt QiC} problem to Section\ \ref{subsec:QiC}, where we prove the following theorem.
\begin{theorem}\label{thm:qic}
There exists a solution for {\tt QiC} that takes  time and  space for preprocessing.
Queries can be answered in  time.
\end{theorem}
To solve {\tt QMEC},  we employ a divide-and-conquer strategy that 
divides the medial axis into smaller pieces. On these smaller pieces, we employ {\tt 
QiC}. We remark in Section\ \ref{subsec:QiC} how the solution to the  {\tt QiC} 
problem on the entire medial axis can be adapted to restricted portions of the medial 
axis. For now, we note that the preprocessing time and space of {\tt QiC} scale with the size of the portion of the medial axis that is preprocessed.
On a  
portion  of the medial axis, the preprocessing time and space are  time and , respectively, where  is the number of edges of  that induce\footnote{We say that an edge  in 
 induces an edge   in  if for some point  in the interior of ,  
touches .} the edges in  (cf. Corollary\ \ref{cor:mstar}).


\begin{algorithm}[h!]
\caption{Preprocessing for {\tt QMEC} on a Simple Polygon }
\label{alg:qmecSP}
\begin{algorithmic}[1]
\REQUIRE{A simple polygon .}
\STATE Compute the medial axis  of .

\STATE Construct a {\tt PLiCA} data structure on {\tt MEC}s centered on nodes of .
\STATE Construct a secondary {\tt PliCA} data structure on the {\tt MEC}s centered on 
valley points of .
\STATE Construct a list  of mountains and preprocess each 
mountain for {\tt QiM}.
\STATE Partition  into sub-polygons , ,  such that each  
is associated with its corresponding . (Recall that this can be performed by 
cutting along diameters of {\tt MEC}s centered on valley points.) 
\STATE Preprocess   and its sub-polygons (in  time and 
space) such that, given a query point , the sub-polygon that contains  can be 
reported efficiently (in  time). Call this data structure . \label{lno:easy}
\STATE  Decompose(). \label{lno:decompose}

\FOR{each node } \label{lno:for}
\STATE Let  be the subtree associated with .
\STATE Let  be the centroid of  (cf. Lemma\ \ref{Jordon}).
\STATE Preprocess  for {\tt QiC} with the additional promise that 
the largest empty circle  that contains query point  is centered on 
. Associate this {\tt QiC} data structure with . \label{lno:qic}
\ENDFOR \label{lno:endfor}

\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h!]
\caption{Decompose()}
\label{alg:decompose}
\begin{algorithmic}[1]
\REQUIRE{A tree  with   nodes.}
\ENSURE{A divide-and-conquer tree  that decomposes .}
\IF{}
\RETURN a tree with the single node.
\ENDIF
\STATE Find the centroid (cf. Lemma\ \ref{Jordon}) of  that will decompose  
into subtrees , , 
\STATE Create a  node {\tt node} with a list {\tt child} of child pointers.
\STATE Associate  with {\tt node}.
\FOR{each subtree }
\STATE  {\tt node.child[i]}  Decompose().
\ENDFOR
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h!]
\caption{Query phase of {\tt QMEC} on a simple polygon  with query point }
\label{alg:QMECquery}
\begin{algorithmic}[1]
\REQUIRE{Query point  and all the data structures created in the preprocessing 
phase.}

\COMMENT{We can use the {\tt PLiCA} data structure for the following condition.}
\IF{ falls inside some {\tt MEC} centered on a node  of }
\STATE \COMMENT{We are in the affirmative case.}
\STATE Find the node  in  whose centroid is .\\
\COMMENT{In the next step,  is the centroid of the subtree of  associated 
with .}
\STATE Find (in ) the farthest ancestor  of   such that  
contains .
\STATE  circle returned by querying the {\tt QiC} data structure 
associated with . 
\STATE Return . 
\ELSE
\STATE \COMMENT{We are in the negative case.}
\IF{ falls in some  {\tt MEC} centered on a valley point }
\STATE \COMMENT{ is a valley point connecting exactly two mountains  and 
.}
\STATE  is the larger of the {\tt MEC}s returned by querying the {\tt QiM} data 
structures associated with  and .
\STATE Return .
\ELSE 
\STATE Use data structure  to find the sub-polygon  that contains .
\STATE  circle returned by querying the {\tt QiM} data structure 
associated with .
\STATE Return 
\ENDIF
\ENDIF
\end{algorithmic}
\end{algorithm}

\vspace{-0.2in}
\subsection{Preprocessing for the {\tt QMEC} problem} \label{preprocessing}

Algorithm\ \ref{alg:qmecSP} outlines the steps in the preprocessing phase. The first 
\ref{lno:easy} steps are straightforward. Before we explain the subsequent steps, we 
state (for the sake of completeness) a well-known lemma.
\begin{lemma} \label{Jordon} \cite{jordon}
Every tree  with  nodes has at least one node  whose 
removal splits the tree into subtrees with at most 
 nodes. The node  is called the 
centroid of .
\end{lemma}


In line number\ \ref{lno:decompose} we call Algorithm\ \ref{alg:decompose} 
(recursively) to build  a centroid decomposition tree . We partition   using the 
centroid (cf. Lemma \ref{Jordon}) in order to ensure that  is balanced. 

The centroid decomposition is constructed in anticipation of the query phase. Suppose  is a query point. If  lies in  , where  is  the centroid  associated with the root of . Then, we can use the  attached  to the root (in line number\ \ref{lno:qic}). If, on the contrary, , then 
from Corollary\ \ref{l2} we know that only one of the 
subtrees rooted at  will contain , thereby allowing us to recurse into that 
subtree until we find the centroid whose {\tt MEC} encloses . To facilitate this recursion, we must provide a way to find the correct subtree 
to recurse into. For this, we consider the geometry of the polygon . Let  touch the polygon  at  
() 
points. Consider the partitioning of   into  sub-polygons, apart 
from the 
one containing , by inserting chords as shown in Figure \ref{recursion}. These 
 sub-polygons correspond to the  subtrees of  obtained by removing . It is easy to 
see now that a point location data structure will suffice. In the query phase, 
we can simply find the sub-polygon that contains  and recurse into the 
corresponding subtree.



\begin{figure}
\centering
\includegraphics[width=0.7\columnwidth]{figure5.pdf}
\caption{The divide and conquer search structure}
\label{recursion}
\end{figure}



In lines \ref{lno:for} to \ref{lno:endfor}, for each node  of  we
associate an appropriate subtree  of  along with the centroid  of . Additionally, we will construct a {\tt QiC} data structure associated with  with the 
additional promise that the largest empty circle  that contains query point  is 
centered on . 



\begin{lemma} \label{sv}
The time and space required for preprocessing  
are  and , 
respectively.
\end{lemma}
\begin{proof}
The medial axis  of a simple polygon can  be computed in  time 
\cite{CSW99}. Once we have , the partition of  into mountains, and the 
associated 
partitioning of
  can be done in  time. 
The data structure for the planar point location can easily be obtained in  
time 
and  space. The {\tt PLiCA} 
data structure for all the {\tt MEC}s centered at the nodes of  requires  
time and  space. 

Consider a level  in the tree . Each node in level  implements the {\tt 
QiC} data structure on a  portion of the medial axis that is disjoint from the portion 
addressed by other {\tt QiC} implementations in the same level. Therefore,  the 
preprocessing times and spaces of all {\tt QiC}s at any level  is  
and  respectively. Since there are  levels in , the total 
preprocessing time and space for all {\tt QiC}s is  and , 
respectively.
\qed
\end{proof}

\vspace{-0.2in}
\subsection{{\tt QMEC} query}
As discussed in Algorithm\ \ref{alg:QMECquery}, in the query phase with a point , 
we first test whether  lies in the {\tt MEC} centered at any node  of 
the medial axis. This can be performed using the {\tt PLiCA} data structure 
(see Subsection \ref{sec:plica}) built over the set of {\tt MEC}s centered 
at all the nodes in . We now need to consider two cases:

{\bf Affirmative case:} There exists a node  in  such that  
contains . From  corresponding to  we move upward in the centroid  
tree  following the parent 
pointers to identify a node  at the highest level such that the  
centered at , 
the medial axis node of the subtree associated with , 
contains . Our choice of  coupled with Corollary\ \ref{l2} imply the following 
lemma.
\begin{lemma}\label{lem:promise}
Let  be the subtree of  associated with  and let  be the 
centroid of . 
Then,  and  contains .
\end{lemma}
Lemma\ \ref{lem:promise}  ensures all the prerequisites for {\tt QiC}, so we can query 
the {\tt QiC} data structure associated with  node  and correctly obtain .

{\bf Negative case:} There exists no node  in  such that  
contains . In this case,  cannot span more than two  mountains as 
otherwise  must include a node in . If  falls in an {\tt MEC} centered at a valley point , we 
query the {\tt QiM} data structure associated with the two polygons connected by . 
Otherwise, 
the center of  lies in only one mountain, the mountain that 
contains . We identify the sub-polygon   in the planar subdivision that 
contains  using the data structure {\tt D} (see line number\ \ref{lno:easy} of 
Algorithm\ \ref{alg:qmecSP}). Finally, we can compute 
 by performing the {\tt QiM} query in , the mountain associated with .
 
 
 

\begin{theorem} \label{th:th}
Given a simple polygon , we can preprocess it in  time and 
 space, such that for a query point , the largest circle 
 in , that contains , can be reported in  time. 
\end{theorem}
\begin{proof}
The correctness follows from the above discussion.
Preprocessing time and space have already been established in Lemma \ref{sv}.
We now analyze the  query time. The {\tt PLiCA} query requires  time 
\cite{IIM}. If we are in the affirmative case, then finding the node  
at the maximum level in  such that  needs another 
 time. The {\tt QiC} query for  can be executed in  
time (Lemma \ref{lem:prep}). In the negative case, finding the appropriate sub-
polygon 
and then performing the  query requires  time.\qed
\end{proof}


\vspace{-0.15in}
\subsection{Description of the {\tt QiC} Data Structure}\label{subsec:QiC}
Recall from Section\ \ref{qic_defn} that  the {\tt QiC} data structure preprocesses  the 
medial axis and a specified node  such that when queried with a point , the largest {\tt MEC} containing  can be reported efficiently.  

We use the concept of {\it guiding circles} associated with node  to find .
Let  be an array containing the radii of the {\tt MEC}s centered at all the 
nodes 
in , sorted in increasing order.



\begin{definition} (Guiding Circles of a node  of ) \label{def1}
An {\tt MEC}  centered somewhere on  is called a guiding {\tt MEC} of the 
node 
 of  if (i) its radius is in , (ii) every {\tt MEC}  on the path from 
 to the center of  in  (both inclusive) is no larger than , and (iii)  
overlaps with .\footnote{We say that two circles overlap if they have a 
common point in their interior.} (See Figure\ \ref{fig:gc} for an illustration of guiding 
circles on a single path from .) We denote the set of guiding circles of the node  by .
\end{definition}
\vspace{-0.2in}
\subsubsection{Computing .} \label{GC}
We can compute  by adapting  either depth-first search 
or breadth-first search 
traversal on  starting from . As we traverse  using (say) depth first search 
starting from , we keep track of the largest MEC along the path from  to the 
current position in the traversal. When we encounter an {\tt MEC}   that fits our 
definition of a guiding circle, we include  in  along with the id of the 
mountain in which it is centered. 


\begin{algorithm}[h!]
\caption{Preprocessing Phase of {\tt QiC}}
\label{alg:QiCPrep}
\begin{algorithmic}[1]
\REQUIRE {Polygon , its medial axis  and a vertex  of .}
\STATE Compute the radii of {\tt MEC}s centered at nodes of  and store them in a sorted array .
\STATE Compute the guiding circles  of node . \COMMENT{We can use 
an adaptation of either depth first search or breadth first search.}
\STATE To each  centered at , attach  the mountain id of the mountain containing .
\STATE For each , attach the set sr. \COMMENT{In Lemma\ 
\ref{lem:BoundingS}, we will see that, for any ,  is a constant.}
\end{algorithmic}
\end{algorithm}






Before we provide the pseudocode for the query phase, we establish a few lemmas. 
Recall from Lemma\ \ref{cor:intermediate} that if a guiding circle  contains , 
then every guiding circle from  to  will contain . The proof for the 
following lemma follows from the definition of guiding circles.
\begin{lemma}\label{increasing} 
Let  be the path on  from  to some guiding circle . 
\begin{enumerate}
\item The radii of guiding circles along  are non-decreasing. 
\item Furthermore, if  is the radius of  and  is the 
radius of ,  then for every   such that , there is at least one guiding circle of radius  in the path from  to the center 
of . 
\end{enumerate}
\end{lemma}
\begin{corollary}\label{cor:binary}
Given a query point , let   be the radius  in  such that  that contains  but ,  that contains . Then, for every  such that , 
 that contains .
\end{corollary}

\begin{figure}
\centering
\includegraphics[width=0.9\columnwidth]{figure4.pdf}
\caption{For the sake of intuition on the construction and usefulness of guiding circles, 
we show a path  laid out on the -axis. }
\label{fig:gc}
\end{figure}


Corollary\ \ref{cor:binary} will allow us to perform a binary search  for  which 
in turn will lead us to the largest guiding circles in  that contain . The following lemma ensures that  the binary search will run in  time.


\begin{lemma}\label{lem:BoundingS} For any , 
 is bounded by a constant. 
\end{lemma}
\begin{figure}[t]
\vspace{-0.1in}
\begin{minipage}[c]{0.35\textwidth}
\begin{center} \includegraphics[height=1.75in]{./figure3a.pdf}\\
(a)  
\end{center}
\end{minipage}\begin{minipage}[c]{0.65\textwidth}
\begin{center} \includegraphics[width=\textwidth] {./figure3b.pdf}\\
(b)  
\end{center}
\end{minipage}
\vspace{-0.1in}
\caption{(a) Bounding , and (b) Illustration of Lemma \ref{lem:BoundingS}}
\vspace{-0.1in}
\label{fig:BoundingS_r}
\end{figure}

\begin{proof}
Consider any . Let  be the {\tt MEC}s of radius  in 
. 
For convenience, let us assume that  does not contain {\tt MEC}  
centered at any node of . Since {\tt MEC}s centered at nodes of  have 
distinct radii, at most one {\tt MEC}  in  can be centered at a node.

By the condition (ii) of Definition \ref{def1}, . Also recall that every 
{\tt MEC} in  must intersect  (see 
Figure \ref{fig:BoundingS_r}(a)). Therefore, every {\tt MEC}  in  must lie 
entirely within a circle  of radius  centered at . Thus, we need 
to prove that the number of guiding circles of radius  at node  inside  is
bounded by a constant.

Let us consider a point . Let  
be the set of {\tt MEC}s in  that enclose . Consider any {\tt MEC}  ; let  be its center. Let  and  be the two points at 
which  touches the boundary of the polygon . The chord  must 
intersect 
the medial axis (see Figure \ref{fig:BoundingS_r}(b)). Note that, the points  and  
lie on different sides of . On the contrary, if  and  lie in 
the same side of , where  and  are the points of contact of the 
said {\tt MEC}  and the polygon , then we can increase the size of the {\tt MEC} by 
moving its center  towards  along the medial axis (see Figure 
\ref{fig:BoundingS_r}
(b)). 
Thus, . Thus, we have . Again, 
the 
angles subtended by different {\tt MEC}s in  are disjoint. These 
two 
facts imply that . In other words, any point inside the circle 
 can be enclosed by at most four different circles of . We need to 
compute . Let us consider a function  defined as the 
number 
of circles in  that overlap at the point , . Clearly, 
 for all . The total number of circles in 
 can be bounded as follows: 

Total area of circles in . \\ 

Therefore, . \qed
\end{proof}

\vspace{-0.15in}
\subsubsection{Answering {\tt QiC} query}
Given a query point  and a node  in  such that , we 
compute 
 as follows. Let  be the radius of the largest guiding circle in
 containing , and  be all the members of  
with radius  that contain .  We report  by executing the steps in Algorithm\ \ref{alg:QiCQuery}. 


\begin{algorithm}[h!]
\caption{Query Phase of {\tt QiC}}
\label{alg:QiCQuery}
\begin{algorithmic}[1]
\REQUIRE {A query point  lying inside .}

 \COMMENT{We want to find  such that  that contains  but ,  that contains 
.}

\STATE Perform a binary search in the array  to identify 
. This also returns the members in . 
Note that, each member  is attached with its 
corresponding mountain-id.

\STATE For each member in , locate the largest 
{\tt MEC}  containing  in the mountain attached to  by executing the 
{\tt QiM} query algorithm.

\STATE Report  as the largest one among the {\tt MEC}s obtained in
Step 2. 
\end{algorithmic}
\end{algorithm}




Lemmata \ref{lem:correctness} and  \ref{lem:prep} state the correctness and 
complexity. 

\begin{lemma}\label{lem:correctness}
At least one of the circles in  is centered at some point 
on the mountain in which  is centered. 
\end{lemma}

\begin{proof}
Since  is a subtree of  (Lemma \ref{l1}), if we explore all the paths in  
from node  towards its leaves, the center  of  is reached in one 
of these paths, say . Let  be the  last guiding circle when going from  to 
. Let the center of  be . As a consequence of Lemma\ \ref{increasing}, 
. Suppose for the sake of contradiction,  is not centered 
on the same mountain on which  is centered. Then,  between  and  
there is a valley point 
 on the path , such that the radius of  is 
less than the radius of . Also, there exists another point 
 on the path  between  and  such that the radius of 
 is equal to the radius of . Since the radius 
of  matches with an element of ,  
must  also be a guiding circle. This contradicts our assumption that  is the last
guiding circle between  and .  
\qed
\end{proof}

\begin{lemma} \label{lem:prep}
(i) For a node ,  can be computed in  time and 
 space. (ii) If the query point  lies in , then  can be 
computed in  time. 
\end{lemma}

\begin{proof}
(i) First of all, note that . The breadth first search in  needs 
 time. The time for computing 
the members in  is  
(by Lemma \ref{lem:BoundingS}), which may be  in the worst case. 
A sorting of the members in  with respect to their radii is required; this takes 
 time. Once sorted, attaching  with each  will 
take  time. The space requirement can be argued similarly.

(ii)  If , the binary search in  considers at most 
 distinct radii. For each radius, the number of guiding 
circles inspected to find whether any one contains  is bounded by a constant 
(see Lemma \ref{lem:BoundingS}). Thus , the largest radius among the guiding 
circles of node  that contains , can be identified in  time.

Let  denote the set of guiding circles of node  of radius 
 that contains . Each of them is attached with the corresponding mountain-
id. 
For each member in , we invoke {\tt QiM} query to find the 
largest {\tt MEC} in the associated mountain ; this takes  time, 
where  may be  in the worst case (see Subsection \ref{subsec:MiM}).  
\qed
\end{proof}

\begin{corollary} \label{cor:mstar}
Suppose {\tt QiC} is restricted to a connected , i.e.,  
and . Suppose further that  edges of  induce the edges 
in . Then, the preprocessing time and space for {\tt QiC} are  and 
, respectively. The query time will be .
\end{corollary}
\begin{proof}
We can restrict our  to radii of {\tt MEC}s centered on nodes only in . 
Hence . 
Rest of the proof follows from the previous discussion.
\qed
\end{proof}

\begin{proof}[of Theorem\ \ref{thm:qic}]
The proof follows from Lemma\ \ref{lem:correctness} and Lemma\ \ref{lem:prep}.
\qed
\end{proof}

\section{{\tt QMEC} problem for Point Set}
\label{sec:QMEC}
The input consists of a set of points  in 
. The objective is to preprocess  such that given any 
arbitrary query point , the largest circle  that
does not contain any point of  but contains , can be reported 
quickly. Observe that, if  does not lie in the interior of the convex 
hull of , then we can easily report a circle of infinite radius passing 
through , that does not overlap with . So, in the rest of this section, 
we shall consider the case where  lies in the  interior of the convex 
hull of . 

Consider the Voronoi diagram of . Observe that the {\tt MEC} centered at 
any {\it Voronoi vertex} touches at least three points of . To simplify 
our presentation, we assume  that {\tt MEC}s 
centered at Voronoi vertices are of distinct sizes. 
In the course of our algorithm, we  treat the Voronoi diagram of , as a 
plane graph  . To keep  within a finite region, we  insert artificial vertices,
one for each unbounded edge in the Voronoi diagram 
of ,  so that  is the plane graph of the Voronoi diagram of  with each 
unbounded edge clipped at 
its corresponding artificial vertex. In placing the artificial vertices, we ensure that 
(i) every {\tt MEC} centered at an artificial vertex 
must be larger than all the {\tt MEC}s centered at Voronoi vertices, and 
(ii) 
the {\tt MEC}s centered at artificial vertices do not overlap pairwise within 
the convex hull of . They may overlap outside the convex hull of .
The second condition ensures that there exists no query point , in the convex hull 
of ,
which can be enclosed by more than one {\tt MEC} centered at artificial vertices.
From now onwards, we will use the term {\em vertices of } to collectively refer 
to Voronoi vertices and artificial vertices. We will use both the geometric and 
graph theoretic properties of . In particular, to achieve the subquadratic 
preprocessing time, we use the classical planar separator theorem\ \cite{LT79}. The intuition is as follows.


Consider the following naive approach to solving {\tt QMEC} on points.
Suppose we store the {\tt MEC}s of vertices in  in a {\tt PLiCA} data structure. Suppose, furthermore, that we preprocess each vertex for {\tt QiC} adapted for points set. We note that
here also the {\tt QiC} data structure of a vertex can be implemented using 
guiding circles (cf. Section\ \ref{sec:QiC-1} for details).
Given an arbitrary query point  in 
the convex hull of , we know that  lies in at least one of the {\tt MEC}s centered on vertices\footnote{The {\tt MEC}s on vertices can be thought of as circumcircles of triangles in the Delaunay triangulation of  and therefore the union of these {\tt MEC}s covers the entire convex hull region.}, 
so we can locate one such {\tt MEC}, say  for some vertex . We can
execute the {\it {\tt QiC} query for the point set} to identify .  This, unfortunately, will require  time for preprocessing because each {\tt QiC} preprocessing requires  time. Instead, to achieve sub-quadratic bounds on the preprocessing time and space for the {\tt 
QMEC} problem we employ a divide-and-conquer approach
by recursively splitting the vertices of  using the planar separator theorem 
 stated below.

\begin{theorem}\label{Planar-Separator} \cite{LT79}
A planar graph  on  vertices can, in  time, be partitioned into disjoint 
vertex sets , 
, and  such that (i) , (ii) , and (iii) 
there is no edge in  that joins a vertex in  to a vertex in . 
\end{theorem}







\newcommand{\gin}{{G_{\text{in}}}}
\newcommand{\win}{{W_{\text{in}}}}
\begin{algorithm}[h!]
\caption{Preprocessing Phase of {\tt QMEC} for set  of points in }
\label{alg:QMECPrep}
\begin{algorithmic}[1]
\REQUIRE {This is a recursive algorithm. In the first call, the input  graph  is . Subsequently, the input graph  is a subgraph of .}
\ENSURE{The first call on the entire plane graph  will return a pointer  to 
the root of the separator decomposition tree .}
\IF{ is empty}
\RETURN {\sc null}.
\ENDIF

\STATE Create a node  of the separator decomposition tree .

\STATE Compute the planar separator vertices  of  (cf. Theorem\ 
\ref{Planar-Separator}). Denote the two separated subgraphs as  and .
\STATE Compute a {\tt PLiCA} data structure  on the {\tt MEC}s centered on 
vertices in . 
\STATE Compute a {\tt PLiCA} data structure  on the {\tt MEC}s centered on 
vertices in .
\STATE Compute a {\tt QiC} data structure corresponding to node . \COMMENT{This {\tt QiC} data structure is built on the two promises that (i) {\it at least} one {\tt MEC} centered on the planar separator vertices  will enclose the query point , and (ii)  is centered on an edge of the plane graph .}

\STATE Attach ,  and the {\tt QiC} data structures to . 

\STATE  (Call Algorithm\ \ref{alg:QMECPrep} on ).
\STATE  (Call Algorithm\ \ref{alg:QMECPrep} on ).

\RETURN pointer to .

\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h!]
\caption{Query Phase of {\tt QMEC} for set  of points in }
\label{alg:QMECQuery}
\begin{algorithmic}[1]
\REQUIRE {A query point  inside the convex hull of  and pointer  to root of the separator 
decomposition tree .}
\ENSURE{The larges {\tt MEC}  that contains   is returned.}

\STATE {\sc ptr}  .

\WHILE{{\sc ptr} is not {\sc null}}
\STATE Let  be the node pointed by {\sc ptr}.
\STATE Let  be the subgraph of  associated with .
\STATE Let  be the separator vertices of .
\STATE Let  and  be the two disconnected subgraphs obtained when vertices in  are removed from .
\STATE Let , , and  be the data structures attached to .
\IF{  such that  
encloses  (we check this using )}
\STATE  (circle returned by querying  with query point ).
\RETURN .
\ENDIF
\IF{ in the data structure  associated with  such that  
encloses }
\STATE {\sc ptr} = .
\ELSE
\STATE {\sc ptr} = .
\ENDIF
\ENDWHILE
\STATE \COMMENT{The execution will not reach this point.}

\end{algorithmic}
\end{algorithm}

We construct a separator decomposition tree  as follows (cf. Algorithm\ \ref{alg:QMECPrep} for a detailed pseudocode). The root  of 
 represents the plane graph . We  attach two {\tt PLiCA} data structures 
 and  at . In , we store {\tt MEC}s centered on the 
 planar separator vertices (denoted by ). We also build the {\tt 
QiC} data structure for the node . The details of {\tt QiC} in the current context of a set of points (rather than polygon)  is described in Subsection \ref{sec:QiC-1}. For now, however, we state the {\tt QiC} problem in the current context where  is a set of points. The node  has  {\tt MEC}s corresponding to the  separator vertices and therefore, the {\tt QiC} attached to  comes with two promises. The first promise is  that the query point  will be enclosed by \textit{at least} one of the separator {\tt MEC}s. (Note that this first promise is an adaptation from the context where  is a simple polygon. In that context, because the medial axis of  was a tree, the separator was  a single vertex.) Our second promise is that  is centered on some edge of the plane graph  attached to . In the query phase of {\tt QiC}, given a query point , we are to return . 


The removal of the  vertices in  from  will induce two disjoint subgraphs  and . Without loss of generality, we pick   and build  
containing the {\tt MEC}s centered at the vertices of . The root  
has two children  and  in .  is associated with the 
 subgraph  while   is associated 
with 
the  subgraph . The two children of  are then
processed recursively. 

In the query phase (cf. Algorithm\ \ref{alg:QMECQuery}), we are given a query point . We find the highest node  in {\tt T} such that (at least) one of the {\tt MEC}s  stored in the associated  encloses . We find  by a traversal from the root node of {\tt T}. Let  be the center of . The point  is a separator vertex in the graph  associated with . Recall that each separator vertex has a {\tt QiC} data structure (restricted to ) associated with it. We prove subsequently that when we query the {\tt QiC} data structure attached to  with the query point , we will indeed obtain the largest {\tt MEC}  that encloses . 

We now turn our attention to analyzing Algorithm\ \ref{alg:QMECPrep} and Algorithm\ \ref{alg:QMECQuery}. We begin with some important lemmata.

\begin{lemma}\label{lem:cycle} 
Consider any cycle  in the Voronoi diagram of . Let  be an {\tt 
MEC} centered at some point on . Then, there exists another {\tt MEC} 
 centered at some other point on  that does not properly overlap 
with . 
\end{lemma}
\begin{proof}
Clearly, any cycle in the Voronoi diagram of  must contain at 
least one point from  inside it. Let  be such a  point
that lies inside the cycle  (see Figure~\ref{fig:nspa}). Let 
be any {\tt MEC} centered at some point on ; let  be the center of .
Consider the line connecting  and . It intersects  at
another point . It is easy to see that the {\tt MEC} , centered
at , will not properly overlap  as, otherwise,
 will lie inside both  and . 
\end{proof}
\begin{figure}[h]
\begin{center} 
\includegraphics[height=3in,clip=true,trim=0 50 0 50]{figure6.pdf}\\

\end{center}

\caption{Illustration for Lemma~\ref{lem:cycle}}
\label{fig:nspa}
\end{figure}

\begin{figure}[h]
\begin{center} 
\includegraphics[width=\textwidth,clip=true,trim=0 100 50 180]{figure7.pdf}\\
 \end{center}
\caption{Illustration of  in unique path lemma} 
\label{fig:nsp}
\end{figure}




\begin{lemma}(Unique Path Lemma.)
If  and  are two distinct but overlapping {\tt MEC}s with centers
at  and , respectively, then there is a unique path  
from  to  in  the Voronoi diagram of  such that every {\tt MEC} centered 
on that path encloses .
\end{lemma}

\begin{proof}
 The structure of the proof is as follows. We provide a procedure that 
constructs a path  from  to  along the Voronoi
edges, and ensure that every {\tt MEC} centered on that path encloses . As a consequence of Lemma \ref{lem:cycle}, the path does not
form an intermediate cycle and terminates at . Finally, we again
use Lemma~\ref{lem:cycle} to show that no path , other than
, exists between  and  such that every {\tt MEC} centered
on  contains . Throughout this proof, we closely follow
Figure~\ref{fig:nsp} in order to keep the arguments intuitive. To keep
arguments simple, we assume that  and  are Voronoi vertices. The arguments 
hold 
even
when  and  are not Voronoi vertices. 

Let  be the number of points in  that   touches. These
 points partition   into  arcs. The degree of
the corresponding Voronoi vertex  (center of ) is also  because each
adjacent pair of points of  on the boundary of  will
induce a Voronoi edge incident on  and vice verse. These Voronoi
edges and their corresponding arcs are denoted by  and ,
for .


Consider the other  {\tt MEC}  ( and centered at a vertex )
that overlaps with .  intersects  at two points  and
. Since  is empty, both  and  must lie on one of the  arcs 
of
. Let us name this arc by .
Consider the edge  that corresponds to the arc
. The other end of , i.e., the vertex , is called
the {\em next step from  toward } and denote it as
. Consider the pseudocode in Procedure~\ref{alg:pi} that generates 
the 
path
denoted by :


\begin{algorithm}[h!]
\caption{ Computation}
\label{alg:pi}
\begin{algorithmic}[1]
\STATE 
\STATE 
\REPEAT
\STATE 
\STATE Append  to 
\UNTIL{ equals .}
\COMMENT{Note that this is the only terminating condition.}
\end{algorithmic}
\end{algorithm}

We now show that (i)  is our desired path, and 
(ii) there exists no other path satisfying the {\it unique path lemma}.

{\bf Proof of correctness:} 
Algorithm\ \ref{alg:pi} constructs a path , where each  is a vertex in the Voronoi diagram of . Let  denote the
{\tt MEC} centered at . If , then the procedure
terminates and, as required, every {\tt MEC} centered on the edge  
encloses .  

Therefore, we consider the case where . We need to prove 
.

Let  be the points at which  and  intersect;  are
the end points of the arc  that defines the move of the next step 
toward  (in Figure \ref{fig:nsp},  is ). By
definition,  and  lie on the arc . Notice that  (shaded region in Figure~\ref{fig:nsp}) is shaped like a rugby
ball with  and  at its end-points. One side of 
(called the {\it initial side}) is in  and the other side 
(called the {\it final side}) is in . Clearly,  and
 are inside (or on the boundary of) every {\tt MEC} centered on the
edge . Otherwise, as we go from  to , a
circle would be present that must touch the final side of , but that would 
mean
that we have either 
\begin{itemize}
\item reached , which contradicts our assumption that , 
\item or found a {\tt MEC} that contains , which contradicts the fact
that  is itself a {\tt MEC}.
\end{itemize}


We now make two observations: (i)  touches the initial side of , but (ii) no other {\tt MEC} centered on  ( in particular)
touches the final side of . 

Observation (i) is obvious. We prove Observation (ii) by contradiction. Let   be an {\tt MEC} centered on  that touches the final side
of  at, say, some point . It is easy to see that 
will contain  because  touches  at the point  and also  
contains 

and , which are also on the boundary of . Thus we have a contradiction that 
 
is an {\tt MEC}. 
Thus, it is clear that .  

Consider two adjacent vertices  and  along 
with {\tt MEC}s  and  centered on them, respectively. The
above argument can be easily extended to give us the following: 
 Therefore, we can conclude
that every {\tt MEC} along  encloses . 
Lemma~\ref{lem:cycle} suggests that  does not
form a cycle. The only stopping condition is when we actually reach
. So  terminates at  in at most  steps. 

{\bf Proof of uniqueness:} To complete the proof of this lemma, we 
must show that  is the only required path. For the sake 
of contradiction, assume that there is another path  such that 
every {\tt MEC} centered on  contains . Then, there are 
two distinct paths from  to  such that every {\tt MEC} centered 
on both the paths contain . Clearly, there must be a cycle 
when the two paths are combined. From Lemma~\ref{lem:cycle}, we know 
that there are pairs of {\tt MEC}s in the cycle that do not overlap on 
each other. This is a contradiction. Thus  is the only 
required path.  
\qed
\end{proof}


Recall that,
given a query point , we locate  by traversing the tree  from its root 
node . At each node  on the search path, we search in the  data 
structure 
to check whether  lies in an {\tt MEC}s corresponding to a separator vertex of 
node .
If there exists an  containing , then we perform {\tt QiC} 
query in  to identify .   
Otherwise,  we search  in , 
associated with the partition . Now, if there exists an  containing , we proceed towards the left child of , otherwise we proceed 
towards the right child.
\begin{lemma}\label{lz}
The search with  must stop at a node  of {\tt T}, and outputs a vertex  in the plane graph  associated with  such that (i)  and (ii)  is centered on some edge of .
\end{lemma}
\begin{proof}
Because {\tt MEC}s on Voronoi vertices are circumcircles of triangles in the Delaunay triangulation of ,  the union of these {\tt MEC}s covers the entire convex hull region. Since every  centered on a Voronoi vertex of  is a separator for some node in {\tt T}, the proof of (i) follows. 

Suppose some {\tt MEC}  centered somewhere outside  encloses .
From the planar decomposition of  down to , it is clear that the (collective) neighborhood  of  consists of vertices that appear in the separator vertices associated with some ancestor of . Therefore, by the Unique Path Lemma, there must exist a vertex  such that the {\tt MEC} centered on  encloses . Since  is associated with some ancestor  of , the search path in  must have stopped at   instead of coming all the way to , which establishes a contradiction.
\qed
\end{proof}

Now that Lemma\ \ref{lz} is established, we can easily see that if the search path in {\tt T} for a query point  stops at node , then the two promises required for  data structure are fulfilled. Therefore, assuming {\tt QiC} is correctly designed (established in Section\ \ref{sec:QiC-1}), we get the following lemma. 
\begin{lemma}\label{lem:qmeccorrect}
Algorithm \ref{alg:QMECPrep} preprocesses a set  of points such that given a query point , Algorithm\ \ref{alg:QMECQuery} can be used to correctly finds .
\end{lemma}
In the next subsection we describe both the preprocessing and query phases of {\tt QiC} before proving time and space bounds in subsection\ \ref{cc}. 


\subsection{{\tt QiC} data structure for points set} \label{sec:QiC-1}

The {\tt QiC} data structure for the points set case (attached to nodes in {\tt T}) largely mimics the simple polygon case. Note that each  has a  data structure attached to it. We reiterate that, while the query point  is promised to lie in a particular {\tt MEC} in the polygon case, in the points set case,  is promised to lie in at least one of the {\tt MEC}s centered on a node in . 
The preprocessing and query algorithms are given as self explanatory pseudocode in Algorithm\ \ref{alg:qicprep} and Algorithm\ \ref{alg:qicquery}, respectively. The time and space bounds of the preprocessing phase follow from the following lemma.

\begin{algorithm}[h!]
\caption{Preprocessing for {\tt QiC} attached to node .}
\label{alg:qicprep}
\begin{algorithmic}[1]
\REQUIRE{A node  and the plane graph  attached to  along with separator vertices  and parts  and .}
\STATE Compute rG_t.
\FORALL{}
\STATE Compute C:
\begin{enumerate}
\item[] 1.  overlaps with ,
\item[] 2. Radius of  is in , and
\item[] 3. Every {\tt MEC} in the unique path from  to  has radius no more than that of .
\end{enumerate}
\STATE Sort 
\STATE Compute BFS tree  rooted at  with centers of {\tt MEC}s  in  as nodes.
\STATE For each node  in , there is at most one edge  incident on  such that the {\tt MEC}s centered on  strictly grow in size (starting from ). Mark  red.
\ENDFOR
\STATE The {\tt QiC} data structure associated with  consists of   and  for all .
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h!]
\caption{Query phase for {\tt QiC} attached to node .}
\label{alg:qicquery}
\begin{algorithmic}[1]
\REQUIRE{{\tt QiC} data structure and a query point  that meets the two promises.}
\ENSURE{The largest {\tt MEC} containing  is computed and returned.}
\STATE Using the {\tt PLiCA} data structure  attached to , we find a   such that  encloses .
\STATE Perform a binary search on  to find the radius  of the largest {\tt MEC} in  that encloses . Also compute  
\STATE , where  is chosen arbitrarily.
\FORALL{}
\STATE Let  be the center of . Recall that  is a node in .
\STATE Let  be the largest {\tt MEC} centered on the red edge in  incident on . If no red edge is incident on , assign .
\IF{ is larger than }
\STATE .
\ENDIF
\ENDFOR
\RETURN .
\end{algorithmic}
\end{algorithm}


\begin{lemma} \label{lem:BoundingS2}
For any  node , any vertex  in  and any , we define  Cr. We claim that  is
bounded by a constant. 
\end{lemma}
\begin{proof}
The key ideas required to prove this lemma have already been discussed in the 
context of 
Lemma~\ref{lem:BoundingS}. Therefore, we limit ourselves 
to making a few  important observations that establish a correspondence between the 
current context (where  is a set of points) to the context of 
Lemma~\ref{lem:BoundingS} (where  is a simple polygon). 

Firstly, observe that all circles in  must lie in a circle  of radius  
centered at ; here  is the radius of   
and  is the radius of circles in  (see Figure \ref{fig:BoundingS_r}).

To make the second observation, consider a circle  centered at a point 
 
strictly in the interior of  an edge .
Without loss of generality,  assume  is smaller than . 
Therefore,  will be no smaller  than  and 
no larger  than . Our second observation is that the {\tt MEC}s  
centered on 
 are growing in size in the vicinity of  as we move in 
the direction from  to . 

To make the third observation, note first that the unique path (as defined in the 
Unique 
Path Lemma) from  to  passes through  and not 
through . Let  and 
 be the two points in  that touch . The third observation is that  the 
chord 
 intersects the unique path (as defined in the Unique Path Lemma) between 
 
and  (see Figure
\ref{fig:BoundingS_r} for a similar situation in the context where  is a simple 
polygon).  

The rest of the proof follows from the proof of Lemma~\ref{lem:BoundingS}. \qed
\end{proof}


\begin{lemma}\label{lem:qic}
Algorithms\ \ref{alg:qicprep} and \ref{alg:qicquery} correctly implement the {\tt QiC} data structure.
The preprocessing time and space of the {\tt QiC} attached to node  in {\tt T} is bounded by  and , respectively, where  is the number of vertices in the plane graph  attached to . Queries can be answered correctly in  time.
\end{lemma}
\begin{proof}
Let  be the subgraph attached to a node , and  be the separator vertices of . Recall that , where . In the {\tt QiC} data structure 
for the node ,  can be  for each node in , 
and it can be computed in  time. Thus, the time required 
to create the {\tt QiC} data structure for all the nodes in  is 
. The space requirement is . 

The correctness argument is similar to the polygon case. In the polygon case, a single path between any two points on the medial axis followed immediately from the fact that the medial axis was a tree. In the current context, the Unique Path Lemma provides a similar unique path. 
\qed
\end{proof}


\subsection{Complexity}\label{cc}

Lemma \ref{lem:qmeccorrect} justifies that our proposed algorithm correctly computes 
the 
largest {\tt MEC} containing the query point  among the points in . The 
following 
lemma establishes the  complexity.

\begin{lemma} \label{xxz}
The preprocessing time and space complexities of the {\tt QMEC} problem are  
 and  ,
respectively. The query can be answered in  time.
\end{lemma}
\begin{proof}
The preprocessing consists of the following steps:
\begin{itemize}
\item[] Constructing the tree . At each node  of 
, we need to compute the separator vertices among the set of 
vertices of the Voronoi subgraph  corresponding to the node . 
The time complexity for this computation is , where  
denotes the number of vertices in . Since the total number of 
vertices at each level of  is , the total time spent for 
computing the separator vertices at all nodes in each level of  
is .  Since the height of {\tt T} is at most ,  
the total time for constructing it is .
\item[]  For each node  in {\tt T}, we need to construct the {\tt QiC} data structure. The subgraphs associated with each node in any particular level of {\tt T} are disjoint. Therefore, as a consequence of Lemma\ \ref{lem:qic}, the preprocessing time and space required for {\tt QiC} data structures associated with nodes in any particular level is  and , respectively. Since  can have at most 
 levels, the preprocessing time and space complexities follow .
\item[] For each node , we also will need to compute two  {\tt PLiCA} data structures  and , but the time and space complexities of the {\tt QiC} data structures dominate the complexities of computing the {\tt PLiCA} data structures.
\end{itemize}

While querying with a point ,  searching in the {\tt PLiCA} data 
structures  for each node  in the search path of   will take  time. We  have 
to traverse a path of length at most  to get to a node  in {\tt T} such that  there is a vertex  of 
 such that . Thus, traversing  needs 
 time. Finally searching in  and  to get  needs another 
 time (see Theorem \ref{th:th}). 
\qed
\end{proof}

\subsection{Improving the query time}
We now show that a minor tailoring of the data structure reduces 
the query time to\\
 , while maintaining the same preprocessing 
time and space.

\subsubsection{Data structure.}
After computing the planar separator tree , each {\tt MEC}  centered on a vertex in  is 
attached with 
\begin{itemize}
\item an , which is the {\it level} of  in which  
belongs as a separator {\tt MEC}, and
\item a pointer to the node  in {\tt T} such that  belongs to the separator 
vertices of 
.
\end{itemize}
 Next, we create an array  of  data structures as follows. Each 
  is a {\tt PLiCA} data structure constructed 
with the set of {\tt MEC}s with  ranging from 
 to , i.e., root to the level .   

\subsubsection{Query.}
While querying with a point , we conduct a binary search on the array  
of 
data structures to find  such that there is an {\tt 
MEC}  in  that contains , but no {\tt MEC} in  
that 
contains . Let  the node in {\tt T} where  the center of  is a separator vertex. We now perform a {\tt QiC} query on  and 
report the result of that {\tt QiC} query as the required {\tt MEC} .
\begin{theorem}
The improvement described in this subsection is correct and its preprocessing time 
and 
space complexities for the {\tt QMEC} problem are  
 and   
respectively. Each query can be answered in  time.
\end{theorem}
\begin{proof}
The correctness follows from the fact that there is no {\tt MEC} with id smaller than 
 
that contains , but  in fact contains . Therefore, 
a {\tt QiC} on  indeed gives us the required {\tt MEC} .

Each  requires  time and  space. Therefore, to 
construct 
, we require  time and  space, which are subsumed in the bounds established in Lemma~\ref{xxz} to 
construct .

In the query phase, each {\tt PLiCA} query on any element of  requires 
 time and the binary search over all elements of  requires  such {\tt PLiCA} queries, thereby requiring  time overall. The {\tt QiC} query requires an 
additional  time, which is subsumed. 
\end{proof}


\subsection{Achieving  Query Time}\label{sec:fastquery}
Here, we shall use Frederickson's -partitioning of planar graphs, stated below, 
to improve the query time complexity to . Furthermore, this algorithm is 
simpler in that it does not require us to construct a divide and conquer tree. 


\begin{lemma} \label{fedrick}\cite{fed} Given a planar graph  with  vertices 
with a planar embedding and a parameter  (),
\begin{itemize}
\item[(a)]   can be partitioned into   parts with at most  
vertices in each part, and a total of  boundary vertices over 
all the 
partitions. 
\item[(b)] This partitioning can be computed in  time. 
\end{itemize}
\end{lemma}

We compute the -partitioning of the graph  with  set to . Now, we construct two data structures,  and , as stated 
below.
\begin{itemize}
\item[:] We 
construct a {\tt PLiCA} data structure and a {\tt QiC} data structure  over all {\tt MEC}s centered on boundary vertices in the -partitioning. 
\item[:] It consists of a {\tt PLiCA} data structures with the set of {\tt MEC}s 
that correspond to the internal vertices of all the partitions.
Furthermore, for each partition , we construct a {\tt QiC} data structure limited to partition  on the {\tt MEC}s centered on the internal vertices of partition .
\end{itemize}
For a given query point , we first search in  to check whether there exists 
a boundary {\tt MEC} that contains . Here two cases may arise:
\begin{description}
\item[Case 1:]  If an {\tt MEC}  encloses , then we search in the {\tt QiC} 
data structure attached with  to identify the largest {\tt MEC} containing .
\item[Case 2:] Otherwise, we search in  to identify an {\tt MEC}  that 
contains . We also find the partition  on which  is centered. We  then search in the {\tt QiC} data structure attached with  to 
identify the largest {\tt MEC} containing .
\end{description}
\begin{lemma} 
The above algorithm correctly identified the largest {\tt MEC} containing . The 
preprocessing time, space and query time complexities of this algorithm are 
,  and , respectively. 
\end{lemma}
\begin{proof}
The correctness of the algorithms follows from the following argument. During the 
query, 
if Case (i) arises the algorithm produces the correct result since the {\tt QiC} data 
structure attached to  is built on the {\tt MEC}s corresponding to all 
the vertices in .  If Case (ii) arises, and  lies in an {\tt MEC}  of the -th 
partition, then it implies that  lies in some {\tt MEC} in the proper interior of the 
-th partition. Thus, the largest {\tt MEC} containing  is surely an {\tt MEC}  
of the -th partition. Thus the {\tt QiC} of  constructed with the {\tt 
MEC}s in the -th partition only is sufficient to obtain .      

Now, we justify the complexity results of the algorithm. The total size of the {\tt QiC} 
data structures in  is , and these are constructed in 
 time. The total size of the {\tt QiC} data structures for 
all the {\tt MEC}s in the -th partition of  is , and these are 
constructed 
in  time. Since, we have at most  partitions, the total 
space 
and time required to construct  is  and , respectively. Thus, 
the 
total preprocessing space and time complexities are  and 
, respectively. Choosing , the 
preprocessing 
time and space complexity results follow.

The query time complexity follows from the fact that the search in the {\tt PLiCA} of 
both 
 and  take  time, and the search in the {\tt QiC} data structure 
of 
exactly one {\tt MEC} needs another  time in the worst case. 
\qed
\end{proof}
 
\noindent {\bf Acknowledgments.} We are grateful to Samir Datta and
Vijay Natarajan for their helpful suggestions and ideas.
We are also thankful to Subir Ghosh for providing the environment to
carry out this work.  
Finally, we are grateful to the anonymous referees for providing insightful comments and suggestions.



\begin{thebibliography}{88}
\bibitem{ADMNRS10} J. Augustine, S. Das, A. Maheshwari, S. C. Nandy,
S. Roy, and S. Sarvattomananda, {\it Recognizing the largest empty circle and
axis-parallel rectangle in a desired location.}, {\sf Technical Report:
http://arxiv.org/abs/1004.0558}, 2010.
\bibitem{AGSS} A. Aggarwal, L. J. Guibas, J. Saxe and P. W. Shor, {\it
A linear time algorithm for computing the Voronoi diagram of a convex
polygon}, Proc. of the {\sf 19th Annual ACM Symposium on Theory of
Computing}, pp. 39-45, 1987.
\bibitem{APS10} J. Augustine, B. Putnam, and S. Roy, {\it Largest
empty circle centered on a query line}, {\sf Journal of Discrete
Algorithms}, vol. 8, pp. 143-153, 2010.
\bibitem{AS} A. Aggarwal, S. Suri, {\it Fast algorithms for computing
the largest empty rectangle}, Proc. of the {\sf 3rd Annual Symposium
on Computational Geometry}, pp. 278 - 290, 1987. 
\bibitem{AS1} B. Aronov and M. Sharir, {\it Cutting circles into
pseudo-segments and improved bounds for incidences}, {\sf Discrete
Computational Geometry}, vol. 28, pp. 475-490, 2000.
\bibitem{BF04} M. A. Bender, and M. Farach-Colton, {\it The level
ancestor problem simplified}, {\sf Theoretical Computer Science},
vol. 321, pp. 5-12, 2004. 
\bibitem{BCDUY00} J. Boissonnat, J. Czyzowicz, O. Devillers,
J. Urrutia, and M. Yvinec, {\it Computing largest circles
separating two sets of segments}, {\sf International Journal of  
Computational Geometry and Applications}, vol. 10, pp. 41-54, 2000.
\bibitem{BCOY01} J. Boissonnat, J. Czyzowicz, O. Devillers, and
M. Yvinec, {\it Circular separability of polygons}, {\sf Algorithmica},
 vol. 30, pp. 67-82, 2001.
\bibitem{BU} R. P. Boland and J. Urrutia, {\it Finding the largest
axis aligned rectangle in a polygon in  time}, Proc.
of the {\sf Canad. Conf. on Computational Geometry}, pp. 41-44, 2001.
\bibitem{CND} J. Chaudhuri, S. C. Nandy, S. Das, {\it Largest empty
rectangle among a point set}, {\sf  Journal of  Algorithms}, vol. 46,
pp. 54-78, 2003.
\bibitem{CSW99} F. Y. L. Chin, J. Snoeyink, and C. A. Wang, {\it
Finding the medial axis of a simple polygon in linear time}, {\sf
Discrete Computational Geometry}, vol. 21, pp. 405-420, 1999.
\bibitem{EGLM2003} J. Edmonds, J. Gryz, D. Liang, and R. J. 
Miller, {\it Mining for empty spaces in large data sets}, 
{\sf Theoretical Computer Science}, vol. 296(3), pp. 435-452, 2003. 

\bibitem{Fisk86} S. Fisk, { \it Separating point sets by circles, and the
recognition of digital disks}, {\sf Transactions on Pattern Analysis and Machine
Intelligence}, vol. 8, pp. 554-556, 1986.
\bibitem{fed} G. N. Frederickson, {\it Fast algorithms for shortest 
paths in planar graphs, with applications}, {\sf SIAM J. on Computing}, 
vol. 16, pp. 1004-1022, 1987.
\bibitem{HT91} W. L. Hsu and K. H. Tsai, {\it Linear time algorithm
on circular-arc-graphs}, {\sf Information Processing Letters}, vol.
40, pp. 123-129, 1991.


\bibitem{IIM} H. Imai, M. Iri and K. Murota, {\it Voronoi diagram
in the Laguerre geometry and its applications}, {\sf SIAM Journal on
Computing}, vol. 14: 93-105, 1985.
\bibitem{JP} R. Janardan and F. P. Preparata, {\it Widest  
corridor problem}, {\sf Nordic Journal on Computing}, vol. 1, 
pp. 231-245, 1994.
\bibitem{jordon} C. Jordan, {\it Sur les assemblages de lignes}, {\sf 
Journal fur die Reine und Angewandte Mathematik} vol. 70, pp. 185-190,
1869.
\bibitem{KMNS12} H. Kaplan, S. Mozes, Y. Nussbaum, and M. Sharir, {\it Submatrix maximum queries in Monge matrices and Monge partial matrices, and their applications}, in {\sf Proceedings of the Symposium on Discrete Algorithms}, 2012,  pp. 338-355.
\bibitem{KS12} H. Kaplan and M. Sharir, {\it Finding the Maximal Empty Disk Containing a Query Point}, in {\sf Proceedings of the Symposium on Computational Geometry}, 2012.
\bibitem{Krik83} D. G. Kirkpatrick, {\it Optimal search in planar
subdivisions}, {\sf SIAM Journal on Computing}, vol. 12, pp. 28-35,
1983.
\bibitem{LT79} R. Lipton and R.E. Tarjan, {\it A separator theorem for 
planar graphs}, {\sf SIAM Journal on Applied Mathematics},
vol. 36, pp. 177-189, 1979.
\bibitem{LKH1997} B. Liu, L. Ku, and W. Hsu, {\it Discovering interesting holes in data}, in {\sf Proceedings of the Fifteenth international joint conference on Artifical intelligence}, pp. 930-935, 1997.

\bibitem{MN} K. Mehlhorn and S. Naher, {\it  Dynamic fractional
cascading}, {\sf Algorithmica}, vol. 5, pp. 215-241, 1990.
\bibitem{NHL} A. Naamad, W.-L. Hsu and D. T. Lee,  {\it On the 
maximum empty rectangle problem}, {\sf Discrete Applied 
Mathematics}, vol. 8, pp. 267-277, 1984.
\bibitem{NSB} S. C. Nandy, A. Sinha, B. B. Bhattacharya, {\it 
Location of the largest empty rectangle among arbitrary obstacles}, 
Proc. of the {\sf 14th Annual Conf. on Foundations of Software
Technology 
and Theoretical Computer Science}, LNCS-880, pp. 159-170, 1994.
\bibitem{OKM86} J. O'Rourke, S. Kosaraju and N. Megiddo, {\it 
Computing circular separability}, {\sf Discrete \& Computational 
Geometry}, vol. 1, pp. 105-113, 1986.
\bibitem{P1977} F. P. Preparata, {\it The Medial Axis of a Simple Polygon}, In {\sf Mathematical Foundations of Computer Science}, pp 443-450, 1977.
\bibitem{PS} F. P. Preparata and M. I. Shamos, {\sf Computational
Geometry: An Introduction}, Springer, 1975.
\bibitem{SarTar86} N. Sarnak and R. E. Tarjan, {\it Planar point
location using persistent search trees}, {\sf Communications of the
ACM} vol. 29, pp. 669-679, 7 July 1986.
\bibitem{TT} H. Tamaki and T. Tokuyama, {\it How to cut
pseudo-parabolas into segments}, {\sf Discrete
Computational Geometry}, vol. 19, pp. 265-290, 1998.
\bibitem{T} G. Toussaint, {\it  Computing largest empty circles with
location constraints}, {\sf International Journal of Parallel
Programming}, vol. 12, pp. 347-358, 1983.
\end{thebibliography}
\end{document}
