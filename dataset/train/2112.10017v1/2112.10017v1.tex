\documentclass{article}







\usepackage[final]{neurips_2020}



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{subcaption}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{breqn}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{color}
\usepackage{tcolorbox}
\usepackage{CJK}
\usepackage{adjustbox}
\usepackage{xcolor}
\usepackage{colortbl}
\usepackage{multicol}
\usepackage{vwcol} 
\newsavebox{\algleft}
\newsavebox{\algright}
\usepackage{bm}
\usepackage{booktabs}
\usepackage{ctable} \usepackage{amsmath,stackengine}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother
\makeatletter
\newcommand{\removelatexerror}{\let\@latex@error\@gobble}
\makeatother

\DeclareMathOperator*{\argmin}{argmin} 

\tcbset{width=0.9\textwidth,boxrule=0pt,colback=red,arc=0pt,auto outer arc,left=0pt,right=0pt,boxsep=5pt}
\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{black}{#1}}
\SetCommentSty{mycommfont}

\SetKwInput{KwInput}{Input}                \SetKwInput{KwOutput}{Output}              

\DeclareMathOperator*{\minimize}{minimize}
\DeclareMathSymbol{\mh}{\mathord}{operators}{`\-}

\title{Continual Learning of a Mixed Sequence of \\ Similar and Dissimilar Tasks}





\author{
  Zixuan Ke,~~Bing Liu\thanks{Corresponding author. The work was done when B. Liu was at Peking University on leave of absence from University of Illinois at Chicago.}~~~and~~Xingchang Huang \\
   Department of Computer Science, University of Illinois at Chicago \\
   ETH Zurich \\
\texttt{\{zke4,~liub\}@uic.edu, huangxch3@gmail.com}
}

\newcommand{\zixuan}[1]{{\color{brown}{\small\bf\sf [zixuan: #1]}}}


\begin{document}

\maketitle

\begin{abstract}
Existing research on continual learning of a sequence of tasks focused on dealing with \textit{catastrophic forgetting}, where the tasks are assumed to be dissimilar and have little shared knowledge. Some work has also been done to transfer previously learned knowledge to the new task when the tasks are similar and have shared knowledge. To the best of our knowledge, no technique has been proposed to learn a sequence of mixed similar and dissimilar tasks that can deal with forgetting and also transfer knowledge forward and backward. This paper proposes such a technique to learn both types of tasks in the same network. For dissimilar tasks, the algorithm focuses on dealing with forgetting, and for similar tasks, the algorithm focuses on selectively transferring the knowledge learned from some similar previous tasks to improve the new task learning. Additionally, the algorithm automatically detects whether a new task is similar to any previous tasks. Empirical evaluation using sequences of mixed tasks demonstrates the effectiveness of the proposed model.\footnote{https://github.com/ZixuanKe/CAT} 







\end{abstract}


\maketitle

\section{Introduction}
\label{sec:introduction}

In many applications, the system needs to incrementally or continually learn a sequence of tasks. This learning paradigm is called \textit{continual learning} (CL) or \textit{lifelong learning}~\citep{chen2018lifelong}. Ideally, in learning each new task , the learner should 
\textbf{(1)} not forget what it has learned from previous tasks in order to achieve knowledge accumulation, 
\textbf{(2)} transfer the knowledge learned in the past forward to help learn the new task  if  is similar to some previous tasks and has shared knowledge with those previous tasks, 
\textbf{(3)} transfer knowledge backward to improve the models of similar previous tasks, and 
\textbf{(4)} learn a mixed sequence of dissimilar and similar tasks and achieve (1), (2) and (3) at the same time. To our knowledge, no existing CL technique has all these four capabilities. This paper makes an attempt to achieve all these objectives in the \textit{task continual learning} (TCL) setting (also known as \textit{task incremental learning}), where each task is a separate or distinct classification problem. This work generalizes the existing works on TCL. Note, there is also the \textit{class continual learning} (CCL) setting (or \textit{class incremental learning}), which learns a sequence of classes to build one overall multi-class classifier for all the classes seen so far.

As AI agents such as chatbots, intelligent personal assistants and physical robots are increasingly made to learn many skills or tasks, this work is becoming more and more important. In practice, when an agent faces a new task , naturally some previous tasks are similar and some are dissimilar to . The agent should learn the new task without forgetting knowledge learned from previous tasks while also improving its learning by transferring the shared knowledge from those similar tasks. 


Most existing CL models focus on (1), i.e., dealing with \textit{catastrophic forgetting} or simply \textit{forgetting}~\citep{chen2018lifelong,Parisi2018continual,Li2016LwF,Seff2017continual,Shin2017continual,Kirkpatrick2017overcoming,Rebuffi2017,yoon2018lifelong,He2018overcoming,yoon2018lifelong,Masse2018alleviating,schwarz2018progress,Nguyen2018variational,hu2019overcoming}. 
In learning a new task, the learner has to update the network parameters but this update can cause the models for previous tasks to degrade or to be forgotten~\citep{mccloskey1989catastrophic}. Existing works dealing with forgetting typically try to make the update of the network toward less harmful directions to protect the previously learned knowledge. Forgetting mainly affects the learning of a sequence of dissimilar tasks. When a sequence of similar tasks is learned, there is little forgetting as we will see in Section~\ref{sec:experiments}. There are also existing methods for knowledge transfer~\citep{ruvolo2013ella,chen2014topic,chen2015lifelong,hao2019forward,ke2020continual} when all tasks are similar. 



This paper proposes a novel TCL model called \textbf{CAT} (\textit{Continual learning with forgetting Avoidance and knowledge Transfer}) that can effectively learn a mixed sequence of similar and dissimilar tasks and achieve all the aforementioned objectives. 
CAT uses a \textit{knowledge base} \textbf{(KB)} to keep the knowledge learned from all tasks so far and is shared by all tasks. Before learning each new task , the learner first automatically identifies the previous tasks  that are similar to . The rest of the tasks are dissimilar to  and denoted by . In learning , the learner uses the \textit{task masks} (\textbf{TM}) learned from the previous tasks to protect the knowledge learned for those dissimilar tasks in  so that their important parameters are not affected (\textbf{\textit{no forgetting}}). A set of masks (one for each layer) is also learned for  in the process to be used in the future to protect its knowledge. For the set of similar tasks , the learner learns a \textit{knowledge transfer attention} (\textbf{KTA}) to selectively transfer useful knowledge from the tasks in  to the new task to improve the new task learning (\textbf{\textit{forward knowledge transfer}}). 
During training the new task , CAT also allows the past knowledge to be updated so that some tasks in  may be improved as well (\textbf{\textit{backward knowledge transfer}}).
Our empirical evaluation shows that CAT outperforms the state of the art existing baseline models that can be applied to the proposed problem.


\section{Related Work}
\label{sec:related}

Work on continual learning (CL) started in 1990s (see a review in \citep{Li2016LwF}). Most existing papers focus on dealing with \textit{catastrophic forgetting} in neural networks. \cite{Li2016LwF} proposed the technique LwF to deal with forgetting using knowledge distillation. \cite{Kirkpatrick2017overcoming} proposed EWC to quantify the importance of network weights to previous tasks, and update weights that are not important for previous tasks. Similar methods are also used in~\citep{DBLP:conf/eccv/AljundiBERT18,schwarz2018progress,Zenke2017continual}. 
Some methods memorize a small set of training examples in each task and use them in learning a new task to deal with forgetting (called \textit{replay})~\citep{Rebuffi2017,Lopez2017gradient,Chaudhry2019ICLR,wu2018memory,Kemker2018fearnet}. 
Some works built generators for previous tasks so that learning is done using a mixed set of real data of the new task and generated data of previous tasks (called \textit{pseudo-replay})~\citep{Shin2017continual,Kamra2017deep,Rostami2019ijcai,hu2019overcoming}. 

Additionally,~\cite{Rosenfeld2017incremental} proposed to optimize loss on the new task with representations learned from old tasks. \cite{hu2019overcoming} proposed PGMA, which deals with forgetting by adapting a shared model through parameter generation.  
\cite{zeng2019continuous} tried to learn the new task by revising the weights in the orthogonal direction of the old task data.~\cite{Dhar2019CVPR} combined three loss functions to encourage the model resulted from the new task to be similar to the previous model. Other related works include Phantom Sampling \citep{Venkatesan2017strategy}, Conceptor-Aided Backprop \citep{He2018overcoming}, Gating Networks \citep{Masse2018alleviating,Serra2018overcoming}, PackNet \citep{Mallya2017packnet}, Diffusion-based Neuromodulation \citep{Velez2017diffusion}, IMM \citep{Lee2017overcoming}, Expandable Networks \citep{yoon2018lifelong,li2019learn}, RPSNet~\citep{rajasegaran2019neurIPS}, reinforcement learning~\citep{Kaplanis2019,Rolnick2019}, and meta-learning~\citep{Javed2019}. See the surveys in~\citep{chen2018lifelong,Parisi2018continual}.





Most CL works focus on \textit{class continual learning} (CCL). This paper focuses on \textit{task continual learning} (TCL)~\citep{Fernando2017pathnet,Serra2018overcoming}.
For example, GEM~\citep{Lopez2017gradient} takes task id in addition to the training data of the specific task as input. A-GEM~\citep{Chaudhry2019ICLR} improves GEM's efficiency. HAT~\citep{Serra2018overcoming} takes the same inputs and use hard attention to learn binary masks to protect old models in the TCL setting. 
But unlike CAT, HAT does not have mechanisms for knowledge transfer. 
Note that the controller in iTAML~\citep{rajasegaran2020itaml} behaves similarly to HAT's annealing strategy in training. But the controller is for balancing between plasticity and stability, while HAT trains binary masks. {UCL~\citep{DBLP:conf/nips/AhnCLM19} is a latest work on TCL}. However, none of these methods can deal with forgetting and perform knowledge transfer to improve the new task learning at the same time. Progressive Network~\citep{DBLP:journals/corr/RusuRDSKKPH16} tries to perform forward knowledge transfer. It first builds one model for each task and then connects them. However, it cannot do backward transfer and its whole network size grows quadratically in the number of tasks, which makes it difficult to handle a large number of tasks. It also does not deal with a mixed sequence of tasks. 

Earlier work on lifelong learning has focused on forward knowledge transfer to help learn the new task better~\citep{thrun1998lifelong,ruvolo2013ella,Silver2013,chen2015lifelong,mitchell2015never}.~\cite{ke2020continual} and~\cite{hao2019forward} also did backward transfer. However, these lifelong learning works mainly use the traditional learning methods such as regression~\citep{ruvolo2013ella}, naive Bayes~\citep{chen2015lifelong,hao2019forward}, and KNN~\citep{thrun1998lifelong} to build a model for each task independently and hence there is no forgetting problem. Although there are also works using neural networks~\citep{ke2020continual,Wang2018lifelong, thrun1998lifelong,Silver2013}, all of them (including those based on traditional learning methods) work on tasks that are very similar and thus there is almost no forgetting. Earlier research on lifelong reinforcement learning worked on cross-domain lifelong reinforcement learning, where each domain has a sequence of similar tasks~\citep{wilson2007multi,BouAmmar2015CrossDomainLRL}. But like others, they don't deal with forgetting. To the best of our knowledge, no existing work has been done to learn a sequence of mixed similar and dissimilar tasks that deal with forgetting and improve learning at the same time. 




\section{Proposed CAT Model}
























The CAT model is depicted in Figure~\ref{overview}(A). At the bottom, it is the input data and the task ID . Above it, we have the \textbf{knowledge base} (\textbf{KB}), which can be any differentiable layers {\color{black}(CAT has been experimented with a 2-layer fully connected network and a CNN architecture).} The task ID  is used to generate three different task ID embeddings. Two of them are element-wise multiplied () with the outputs of the corresponding layers in the KB while the last one is the input to the knowledge transfer module (top right). The output of the KB can go to two branches (blue and red parallelogram). It will always go to the blue branch, which learns a classification model  for task  and at the same time, learns a binary mask (called the \textbf{task mask} (\textbf{TM})) for each layer in the KB indicating the units that are important/useful for the task in the layer. The mask is used to protect the learned knowledge for task  in learning future tasks. If task  is similar to some previous tasks, the output of the KB also goes to the right branch for selective knowledge transfer, which is achieved through \textbf{knowledge transfer attention} (\textbf{KTA}). On top of KTA, another classifier  is built for task , which leverages the transferred knowledge to learn . This classifier should be used in testing rather than  for the task.  is only used in testing when the task  has no similar previous task. Note that in task continual learning (TCL), task ID is needed because in testing each test instance will be tested by the classifier/model of its corresponding task~\citep{Ven2019Three}.\footnote{For example, one task is to classify fish and non-fish, and another task is to classify different kinds of fishes. Without knowing the userâ€™s specific task (task ID) at hand, the system will not know which is the right answer.} 
{\color{black}Note that Figure~\ref{overview}(A) does not show the network for detecting whether task  is similar to some previous tasks, which we will discuss in Section~\ref{tsv}. For now, we can assume that a set of similar previous tasks to  is available.} 
\begin{figure}[]
\centering
\includegraphics[width=\columnwidth]{architecture.png}
\caption{(A) CAT architecture, and (B) illustration of task masking and knowledge transfer. Some notes about (B) are: In the matrix before training, those cells with 0's are the units to be protected (masked), and with 1's are units to be shared and whose tasks are similar to the current task. Those cells without a number are free units (not used). In the matrix after training, those cells with 1's show those units that are important for the current task, which are used as a mask for the future. The rest of the cells or units are not important for the task. Those 0 cells without a color are not used by any task. }
\vspace{-3mm}
\label{overview}
\end{figure}


\subsection{Preventing Forgetting for Dissimilar Tasks: Task Masks}

Let the set of tasks learned so far be  (before learning a new task ). Let  be a set of similar tasks to  and  be the set of dissimilar tasks to . We will discuss how to compute  in Section~\ref{tsv}. In learning , we overcome forgetting for the dissimilar tasks in  by identifying the units in the KB that are used by the tasks and blocking the gradient flow through the units (i.e., setting their gradients to 0). To achieve this goal, a task mask (a binary mask)  is trained for each task  at each layer  of the KB during training for task 's classifier/model, indicating which units are important for the task in the layer. Here we borrow the hard attention idea in \citep{Serra2018overcoming} and leverage the task ID embedding to train the mask.


\textbf{From Task ID Embedding to Task Mask. }
For a task ID , its embedding  consists of differentiable deterministic parameters that can be learned together with other parts of the network. The subscript  indicates the layer number. A separate task ID embedding is trained for each layer of the KB. {\color{black}To generate the task mask  from , Sigmoid is used as a pseudo-gate function and a positive scaling hyper-parameter  is applied to help training.}  is computed as follows:

Given the output of each layer in the KB, , we element-wise multiply . The masked output of the last layer  is fed to the  classification head to train the task classifier. After learning task , the final  is saved and added to the set . 

\textbf{Block Gradients Flow through Used Units for Dissimilar Tasks.} For each previous dissimilar task  in  of the current task , its mask  indicates which units in the KB are used by task . In learning task ,  is used to set the gradient  on \textit{all} used units of the layer  to 0. Before modifying the gradient, we first accumulate all used units by all previous dissimilar tasks making use of their masks. Since  is binary, we can use element-wise maximum to achieve the accumulation:  




 is applied to the gradient:

Those gradients corresponding to the 1 entries in  are set to 0 while the others remain unchanged. Note that we expand (copy) the vector  to match the dimensions of .

\textbf{Training Tricks.} 
Though the idea is intuitive,  is not easy to train. To make the learning of  easier, an annealing strategy is applied~\citep{Serra2018overcoming}. That is,  is annealed during training, inducing a gradient flow and set  during testing. {\color{black}Eq.~\ref{eq1} approximates a unit step function as the mask, with  when . 
A training epoch starts with all units being equally active, which are progressively polarized within the epoch. Specifically,  is annealed as follows}:

where  is the batch index and  is the total number of batches in an epoch. The task masks are trained together with 
 by minimizing (using cross entropy):

\textbf{Illustration.} In Figure~\ref{overview}(B). Task 0 is the first task. After learning it, we obtain its useful units marked in orange with a 1 in each unit, which serves as a mask for future tasks. In learning task 1, we found that task 1 is not similar to task 0. Those useful units for task 0 is masked (with 0 in those orange units or cells in the matrix on the left). The process also learns the useful units for task 2 marked in green with 1's. 

\subsection{Knowledge Transfer from Similar Tasks: Knowledge Transfer Attention}

If there are similar tasks () to the new task , we want to learn  better, by encouraging knowledge transfer from . Due to the fact that every task may have its domain specific knowledge that is not applicable to other tasks, knowledge transfer has to be selective.  
We propose a \textit{knowledge transfer attention} (KTA) for the purpose. The idea is to give different importance to different previous tasks by an attention mechanism so that their knowledge can be selectively transferred to the new task. Those transferred units are also made updateable to achieve \textit{backward knowledge transfer} automatically so that the previous task models may be improved in training the new task .

\textbf{Knowledge Base Output for Previous Tasks.} Recall we know which units are for which task  by reading . For each previous similar task  in  of the current task , we can compute its masked KB output  (the last layer) by applying  to the KB.





\textbf{Knowledge Transfer Attention.} We learn another task ID embedding (separate from the task ID embedding used in the KB)  and stack all the outputs of the last layer in the KB  into a collection . We then compute the attention weight for each  in the collection in the right branch of Figure~\ref{overview}(A) by:

where  is the number of previous similar tasks ().  and  are parameters matrices for projections in self-attention (\cite{vaswani2017attention}). The  indicates the importance of each previous task in . We then compute the weighted sum among  to get the output of similar tasks:

where  is the parameter matrix for projection in self-attention.  is then fed to the  classification head to learn the classifier.

\textbf{Loss function for training  and }. Both terms below use cross entropy. 
where  is the number of training examples in task ,  is the set of parameters of , and  is the set of parameters of . 



\textbf{Illustration.} 
In Figure~\ref{overview}(B), when task 2 arrives, the system found that task 1 is similar to task 2, but task 0 is not. Then, task 0's important units are blocked, i.e., its mask entries are set to 0 (orange units in the left matrix). Task 1's important units are left open with its mask entries set to 1 (green units in the left matrix). After learning with knowledge transfer, task 2 and task 1 have some shared units that are important to both of them, i.e., those units marked in both red and green. 



\subsection{Task Similarity Detection}
\label{tsv}

In the above discussion, we assume that we know the set of similar previous tasks  of the new task . We now present how to find similar tasks for a given task . We use a binary vector TSV (\textit{task similarity vector}) to indicate whether each previous task  is similar to the new task . 

We define task similarity by determining whether there is a \textit{positive knowledge transfer} from a previous task  to the current task . A \textit{transfer model}  is used to transfer knowledge from task  to task . A single task model , called the \textit{reference model}, is used to learn  independently. If the following statistical risk holds, which indicates a positive knowledge transfer, we say that task  is similar to task ; otherwise task  is dissimilar to task . 

We use a validation set to check whether Eq.~\ref{eq9} holds. Specifically, if the transfer model  classifies the validation data of task  better than the reference model , then we say  contains shareable prior knowledge that can help  learn a better model than without the knowledge, , indicating positive knowledge transfer. We set  indicating that  is similar to ; otherwise  indicating that  is dissimilar to .

\textbf{Transfer model.} The transfer model  trains a small readout function (1 layer fully-connected network on top of the KB) for the previous task  given the representation/features for  produced by the task  model in the KB. In training the transfer network, the KB is frozen or not updated. 

Recall the model of task  is specified by its mask , which is saved after training task . The transfer network is trained by minimizing the following empirical risk using the cross entropy loss:

\textbf{Reference model.} The reference model  is a separate network for building a model for task  alone from scratch with random initialization. It uses the same architecture as  without applying any task masks. However, the size of the network is smaller, 50\% of  in our experiments. The network is trained by the following using the cross entropy loss:




\section{Experiments}
\label{sec:experiments}

We now evaluate CAT following the standard continual learning evaluation method in~\citep{DBLP:journals/corr/abs-1909-08383}.
We present CAT a sequence of tasks for it to learn. Once a task is learned, its training data is discarded. After all tasks are learned, we test all task models using their respective test data. In training each task, we use its validation set to decide when to stop training.  

\subsection{Experiment Datasets}
{\color{black}
Since CAT not only aims to deal with forgetting for dissimilar tasks but also to perform knowledge transfer for similar tasks, we consider two types of datasets. 

\textit{Similar Task Datasets:} We adopt two similar-task datasets from {\em federated learning}.~Federated learning is an emerging machine learning paradigm with its emphasis on data privacy. The idea is to train through model aggregation rather than the conventional data aggregation and keep local data staying on the local device. These datasets naturally consist of similar tasks. We randomly choose 10 tasks from two publicly available federated learning datasets~\citep{DBLP:journals/corr/abs-1812-01097} to form (1) \textbf{F-EMNIST} - each of the 10 tasks contains one writer's written digits/characters (62 classes in total), and (2) \textbf{F-CelebA} - each of the 10 tasks contains images of a celebrity labeled by whether he/she is smiling or not. {\color{black}Note that the training and testing sets are already provided in \citep{DBLP:journals/corr/abs-1812-01097}. We further split about 10\% of the original training data as the validate data.}


\textit{Dissimilar Task Datasets:} We use 2 benchmark image classification datasets: \textbf{EMNIST}~\citep{lecun1998gradient}
and \textbf{CIFAR100}~\citep{krizhevsky2009learning}. We consider two splitting scenarios. For each dataset, we prepare two sets of tasks with a different number of classes in each task. For EMNIST, which has 47 classes in total, the first set has 10 tasks and each task has 5 classes (the last task has 2 classes). The second set has 20 tasks and each task has 2 classes (the last task has 9 classes). For CIFAR100, which has 100 classes, the first set has 10 tasks and each task has 10 classes. The second set has 20 tasks and each task has 5 classes. {\color{black}For EMNIST, for efficiency reasons we randomly sampled a subset of the original dataset and also make the validation set the same as the training set following \citep{Serra2018overcoming}.}
For CIFAR100, we split 10\% of the training set and keep it for validation purposes. Statistics of the datasets are given in Table~\ref{tab:dataset}.
}


\textit{Mixed Sequence Datasets for Experimentation:} To experiment with learning a mixed sequence of tasks, we constructed four \textit{mixed sequence datasets} from the above similar and dissimilar tasks datasets: 
\textbf{M(EMNIST-10, F-EMNIST)},
\textbf{M(EMNIST-20, F-EMNIST)},
\textbf{M(CIFAR100-10, F-CelebA)}, and
\textbf{M(CIFAR100-20, F-CelebA)}. The first mixed sequence dataset \textbf{M(EMNIST-10, F-EMNIST)} consists of 5 random sequences of tasks from EMNIST (10 dissimilar tasks) and all 10 similar F-EMNIST task. \textbf{M(EMNIST-20, F-EMNIST)} consists of 5 random sequences of tasks from EMNIST (20 dissimilar tasks) and all 10 similar F-EMNIST tasks. Note that EMNIST and F-EMNIST datasets are paired together because they contain images of the same size. The other two mixed sequence datasets involving CIFAR100 and F-CelebA are prepared similarly. CIFAR100 and F-CelebA are paired together also because their images are of the same size. 


\begin{table}[]
\centering
\resizebox{0.6\columnwidth}{!}{
\begin{tabular}{ccccc}
\specialrule{.2em}{.1em}{.1em}
Dataset & \# Classes & \# Training & \# Validation & \# Testing \\
\specialrule{.1em}{.05em}{.05em}
\multicolumn{5}{c}{M(EMNIST-10/20, F-EMNIST)} \\
\specialrule{.1em}{.05em}{.05em}
EMNIST-10/20 & 47 & 6,000 & 6,000 & 800 \\
F-EMNIST  & 62 & 6,911 & 762  & 858 \\
\specialrule{.1em}{.05em}{.05em}
\multicolumn{5}{c}{M(CIFAR100-10/20, F-CelebA)} \\
\specialrule{.1em}{.05em}{.05em}
CIFAR100-10/20 & 100 & 45,000 & 5,000 & 10,000 \\
F-CelebA & 2 & 870 & 90 & 110 \\
\specialrule{.1em}{.05em}{.05em}
\end{tabular}
}
\vspace{+2mm}
\caption{Statistics of the datasets, which contain the total number of classes and the total numbers of training, validation and testing instances for each dataset.}
\label{tab:dataset}
\vspace{-4mm}
\end{table}


\subsection{Compared Baselines}
We consider ten task continual learning (TCL) baselines.  
\textbf{EWC} \citep{Kirkpatrick2017overcoming} - {\color{black}a popular regularization-based class continual learning (CCL) method. We adopt its TCL variant implemented by \cite{Serra2018overcoming}}.
\textbf{HAT} 
\citep{Serra2018overcoming} - one of the best TCL methods with almost no forgetting. 
\textbf{UCL}
\citep{DBLP:conf/nips/AhnCLM19} - a latest TCL method using a Bayesian online learning framework. 
\textbf{HYP}~\citep{von2019continual} - a latest TCL method addressing forgetting by generating the weights of the target model based on the task ID.
\textbf{HYP-R}~\citep{von2019continual} - a latest replay-based method. 
\textbf{PRO} (Progressive Network)~\citep{DBLP:journals/corr/RusuRDSKKPH16} - another popular continual learning method which focuses on forward transfer. 
{\textbf{PathNet}~\citep{Fernando2017pathnet} - a classical continual learning method selectively masks out irrelevant model parameters}. We also adopt its TCL variant implemented by \cite{Serra2018overcoming}. 
{\color{black}\textbf{RPSNet}~\citep{rajasegaran2019neurIPS} - an improvement over PathNet which encourages knowledge sharing and reuse. As RPSNet is a CCL method, we adapted it to a TCL method. Specifically, we only train on the corresponding head of the specific task ID during training and only consider the corresponding head's prediction during testing. }
\textbf{NCL (naive continual learning)} - greedily training a sequence of tasks incrementally without dealing with forgetting. It uses the same network as the next baseline.
\textbf{ONE (one task learning)} - building a model for each task independently using a separate neural network, which clearly has no knowledge transfer and no forgetting involved. 



\subsection{Network and Training Details}
Unless otherwise stated, for NCL, ONE, and the KB in CAT, {\color{black}we employ a 2-layer fully connected network for all our datasets. For F-CelebA and CIFAR100, we further experiment CAT using a CNN based AlexNet-like architecture \citep{krizhevsky2012imagenet}.} We also employ the embedding with 2000 dimensions as the final and hidden layer of the KB. The task ID embeddings have 2000 dimensions. A fully connected layer with softmax output is used as the  and  classification heads, together with the categorical cross-entropy loss. We use 140 for  in , dropout of 0.5 between fully connected layers. For the knowledge transfer attention (KTA), we apply layer normalization and dropout following the setting in \citep{vaswani2017attention}. We also employ multiple attention heads. We set the number of attention heads to 5 (grid search from the candidates set \{1, 5, 10, 15, 20\} on the validation set). We train all models using SGD with the learning rate of 0.05. We stop training when there is no improvement in the validation accuracy for 5 consecutive epochs (i.e., early stopping with ). The batch size is set to 64. For all the other baselines, we use the code provided by their authors and adopt their original parameters.  























\subsection{Results and Analysis}

\begin{table}[]

\centering
 \vspace{-4mm}
\resizebox{\columnwidth}{!}{\begin{tabular}{cccccccccccc}
\specialrule{.2em}{.1em}{.1em} 
 & NCL & ONE & EWC & UCL & HYP & HYP-R & PRO & PathNet & RPSNet & HAT & \textbf{CAT} \\
\specialrule{.1em}{.05em}{.05em} 
\specialrule{.1em}{.05em}{.05em} 

M(EMNIST-10, F-EMNIST): Overall & 0.7293 & 0.7337 & 0.7339 & 0.7262 & 0.6271 & 0.4889 & 0.5391 & 0.5901 & 0.7044 & 0.7302 & \textbf{0.7710} \\
M(EMNIST-10, F-EMNIST): EMNIST-10 & 0.9156 & \textbf{0.9437} & 0.9157 & 0.9161 & 0.8329 & 0.7254 & 0.9289  & 0.9163 & 0.8945 & 0.9337 & 0.9287 \\
M(EMNIST-10, F-EMNIST): F-EMNIST & 0.5430 & 0.5238 & 0.5521 & 0.5362 & 0.4212 & 0.2524 & 0.1492 & 0.2638 & 0.5144 & 0.5268 & \textbf{0.6134} \\
\specialrule{.1em}{.05em}{.05em} 

M(CIFAR100-10, F-CelebA): Overall & 0.5535 & 0.5967 & 0.5945 & 0.5523 & 0.5352 & 0.3703 & 0.5863 & 0.5504 & 0.4801 & 0.5682 & \textbf{0.6194} \\
M(CIFAR100-10, F-CelebA): CIFAR100-10 & 0.5124 & \textbf{0.5861} & 0.5345 & 0.5373 & 0.4667 & 0.2096 & 0.5599  & 0.5244 & 0.4056 & 0.5692 & 0.5479 \\
M(CIFAR100-10, F-CelebA): F-CelebA & 0.5945 & 0.6073 & 0.6545 & 0.5673 & 0.6036 & 0.5309 & 0.6127 & 0.5764 & 0.5545 & 0.5673 & \textbf{0.6909} \\
\specialrule{.1em}{.05em}{.05em} 

M(EMNIST-20, F-EMNIST): Overall & 0.8024 & 0.8245	& 0.8213 & 0.8186 & 0.7332 & 0.6092 & 0.6794 & 0.7115 & 0.74835 & 0.8169 & \textbf{0.8439} \\

M(EMNIST-20, F-EMNIST): EMNIST-20 & 0.9270 & \textbf{0.9712} & 0.9393 & 0.9567 & 0.8970 & 0.7856 & 0.9660 & 0.9472 & 0.8861 & 0.9678 & 0.9566 \\ 





M(EMNIST-20, F-EMNIST): F-EMNIST & 0.5531 & 0.5310 & 0.5855	& 0.5425 & 0.4056 & 0.2565 & 	0.1062 & 0.2403 & 0.4728 & 0.5136 & \textbf{0.6187} \\ 



\specialrule{.1em}{.05em}{.05em} 
M(CIFAR100-20, F-CelebA): Overall & 0.6018 & 0.6796 & 0.6292 & 0.6368 & 0.5878 & 0.3892 & 0.6682 & 0.6169 & 0.5410 & 0.6535 & \textbf{0.6843} \\

M(CIFAR100-20, F-CelebA): CIFAR100-20 & 0.6136 & \textbf{0.7058} & 0.6348 & 0.6689 & 0.6053 & 0.3274 & 0.6896  & 0.6163 & 0.5507 & 0.6802 & 0.6683 \\
M(CIFAR100-20, F-CelebA): F-CelebA & 0.5782 & 0.6273 & 0.6182 & 0.5727 & 0.5527 & 0.5127 & 0.6255 & 0.6182 & 0.5218 & 0.6000 & \textbf{0.7164} \\
\specialrule{.1em}{.05em}{.05em} 
\vspace{-2mm}
\end{tabular}
}

\caption{Accuracy results of different models on the four mixed sequence datasets (average over 5 random sequences) {\color{black} using a 2-layer fully connected network}. 
The number in bold in each row is the best result of the row. }


\label{tab:OverallAccuracy}
\end{table}





\begin{table}[]

\centering
 \vspace{-4mm}
\resizebox{0.7\columnwidth}{!}{\begin{tabular}{ccccc}
\specialrule{.2em}{.1em}{.1em} 
 & NCL & ONE & HAT & \textbf{CAT} \\
 \specialrule{.1em}{.05em}{.05em} 
\specialrule{.1em}{.05em}{.05em} 

M(CIFAR100-10,F-CelebA):   Overall & 0.6155 & 0.6764 & 0.6178 & \textbf{0.6831} \\
M(CIFAR100-10,F-CelebA):   CIFAR100-10 & 0.5692 & \textbf{0.6892} & 0.6301 & 0.6099 \\
M(CIFAR100-10,F-CelebA):   F-CelebA & 0.6618 & 0.6636 & 0.6055 & \textbf{0.7564} \\
\specialrule{.1em}{.05em}{.05em} 

M(CIFAR100-20,F-CelebA):   Overall & 0.6931 & 0.7428 & 0.6946 & \textbf{0.7468} \\
M(CIFAR100-20,F-CelebA):   CIFAR100-20 & 0.6669 & \textbf{0.7870} & 0.7419 & 0.7339 \\
M(CIFAR100-20,F-CelebA):   F-CelebA & 0.7455 & 0.6545 & 0.6000 & \textbf{0.7727} \\
\specialrule{.1em}{.05em}{.05em} 
\vspace{-2mm}
\end{tabular}
}

\caption{Accuracy results of different models on the {\color{black} mixed sequences of F-CelebA and CIFAR100 (average over 5 random sequences) using an AlexNet-like architecture}. The number in bold in each row is the best result of the row. 
}
\vspace{-5mm}

\label{tab:OverallAccuracyCNN}
\end{table}



\begin{table}[]

\centering
\vspace{-3mm}
\resizebox{0.7\columnwidth}{!}{\begin{tabular}{cccc}
\specialrule{.2em}{.1em}{.1em} 
Task & ONE & Backward & Forward \\

\specialrule{.1em}{.05em}{.05em} 
\specialrule{.1em}{.05em}{.05em} 


M(EMNIST-10, F-EMNIST): F-EMNIST & 0.5238 & \textbf{0.6134} & 0.6104 \\
M(EMNIST-20, F-EMNIST): F-EMNIST & 0.5310 & \textbf{0.6187} & 0.6081 \\
M(CIFAR100-10, F-CelebA): F-CelebA & 0.6073 & \textbf{0.6909} & 0.6873 \\
M(CIFAR100-20, F-CelebA): F-CelebA & 0.6273 & \textbf{0.7164} & 0.6782
\\
\specialrule{.1em}{.05em}{.05em} 

\vspace{-2mm}
\end{tabular}
}

\caption{Effect of forward and backward knowledge transfer in CAT. }
\vspace{-4mm}
\label{tab:KnowledgeTransfer}

\end{table}






















Table~\ref{tab:OverallAccuracy} gives the accuracy results of all systems on the four mixed sequence datasets. {\color{black} For NCL, ONE, HAT, and CAT, we use a 2-layer fully connected network.} The first part of the table contains the average results for the 5 random sequences of the 20 tasks M(EMNIST-10, F-EMNIST) dataset. The first row shows the average accuracy of all 20 tasks for each system. The second row shows the average accuracy results of only the 10 dissimilar tasks of EMNIST-10 among all 20 tasks of the compared systems. The third row shows the average accuracy results of only the 10 similar tasks of F-EMNIST among all 20 tasks of the compared systems. 
Other parts of the table contain the corresponding results of the 20/30 tasks mixture sequence datasets. The detailed results of different sequences are given in \textit{Supplementary Materials}. {\color{black}Table~\ref{tab:OverallAccuracyCNN} gives the results of the two mixed  sequence datasets involving CIFAR100 and F-CelebA using the CNN based AlexNet-like architecture.} 






\textbf{Overall Performance.} 
The \textit{overall} accuracy results of all tasks for four mixed sequence datasets in Tables~\ref{tab:OverallAccuracy} {\color{black} and~\ref{tab:OverallAccuracyCNN}} show that CAT outperforms all baselines. {\color{black} In Table~\ref{tab:OverallAccuracy},} although EWC, HAT, and UCL perform better than NCL due to their mechanisms for avoiding forgetting, they are all significantly worse than CAT as they don't have methods to encourage knowledge transfer. {\color{black}HYP, HYP-R, PathNet and RPSNet} fail to outperform NCL, indicating their failure in learning mixed sequence of tasks. Even though PRO, by construction, never forget, it still exhibits difficulties in dealing with mixed sequences. 




\textbf{Performance on Dissimilar Tasks.} {\color{black} We can see from Tables~\ref{tab:OverallAccuracy} and~\ref{tab:OverallAccuracyCNN} that CAT performs better than most of the baselines on dissimilar tasks.}
It is not surprising that ONE is the best overall except for EMNIST-20 as it builds separate classifiers independently. CAT performs similarly to HAT, which has little forgetting.  
This indicates that CAT deals with forgetting reasonably well. {\color{black} In Table~\ref{tab:OverallAccuracy}, we see that PathNet and RPSNet work well on EMNIST-20 datasets but extremely poorly on F-EMNIST, indicating they are not able to deal with a mixed sequence well as CAT does.}

\textbf{Performance on Similar Tasks.} For the results of similar tasks, {\color{black}In both Tables~\ref{tab:OverallAccuracy} and~\ref{tab:OverallAccuracyCNN}, }we can see that CAT markedly outperforms HAT and all other baselines as CAT can leverage the shared knowledge among similar tasks while the other CL approaches, including HAT, only tries to avoid interference with the important units of previous tasks to deal with forgetting.





\textbf{Effectiveness of Knowledge Transfer.}
Here, we look at only the similar tasks from F-EMNIST and F-CelebA in the four mixed sequence experiments. For forward transfer, we use the test accuracy of each similar task in F-EMNIST or F-CelebA when it was first learned. For backward transfer, we use the final result after all tasks are learned. The average results are given in Table \ref{tab:KnowledgeTransfer}. 
Table \ref{tab:KnowledgeTransfer} clearly shows that forward knowledge transfer is highly effective. For backward transfer, CAT slightly improves the forward performance for F-MNIST and markedly improves the performance for F-CelebA. 




\subsection{Ablation Experiments} 


\begin{table}[]

\centering
 \vspace{-4mm}
\resizebox{\columnwidth}{!}{\begin{tabular}{cccccccccc}
\specialrule{.2em}{.1em}{.1em} 
\multicolumn{1}{c}{} & \multicolumn{1}{c}{\begin{tabular}[c]{@{}c@{}}CAT\\ (-TSV: all-sim;\\ -KTA)\end{tabular}} & \multicolumn{1}{c}{\begin{tabular}[c]{@{}c@{}}CAT\\ (-TSV: all-sim)\end{tabular}} & \multicolumn{1}{c}{\begin{tabular}[c]{@{}c@{}}CAT\\ (-TSV: all-dis)\end{tabular}} & \multicolumn{1}{c}{\begin{tabular}[c]{@{}c@{}}CAT \\ (-KTA)\end{tabular}} & \multicolumn{1}{c}{\textbf{CAT}} \\
\specialrule{.1em}{.05em}{.05em} 
\specialrule{.1em}{.05em}{.05em} 

M(EMNIST-10, F-EMNIST): Overall & 0.7293 & 0.1887 & 0.7337 & 0.7585 & \textbf{0.7710} \\
M(EMNIST-10, F-EMNIST):   EMNIST-10 & 0.9156 & 0.2961 & \textbf{0.9437} & 0.9301 & 0.9287 \\
M(EMNIST-10, F-EMNIST):   F-EMNIST & 0.5430 & 0.0813 & 0.5238 & 0.5870 & \textbf{0.6134} \\
\specialrule{.1em}{.05em}{.05em} 

M(CIFAR100-10, F-CelebA): Overall & 0.5535 & 0.3090 & 0.5967 & 0.5915 & \textbf{0.6194} \\
M(CIFAR100-10, F-CelebA):   CIFAR100-10 & 0.5124 & 0.1253 & \textbf{0.5861} & 0.5594 & 0.5479 \\
M(CIFAR100-10, F-CelebA):   F-CelebA & 0.5945 & 0.4927 & 0.6073 & 0.6236 & \textbf{0.6909} \\
\specialrule{.1em}{.05em}{.05em} 

M(EMNIST-20, F-EMNIST):   Overall & 0.8024 & 0.3631 & 0.8245 & 0.8423 & \textbf{0.8439} \\
M(EMNIST-20, F-EMNIST):   EMNIST-20 & 0.9270 & 0.5174 & \textbf{0.9712} & 0.9637 & 0.9566 \\
M(EMNIST-20, F-EMNIST):   F-EMNIST & 0.5531 & 0.0545 & 0.5310 & 0.5995 & \textbf{0.6187} \\
\specialrule{.1em}{.05em}{.05em} 
M(CIFAR100-20, F-CelebA): Overall & 0.6018 & 0.3207 & 0.6796 & 0.6572 & \textbf{0.6843} \\
M(CIFAR100-20, F-CelebA):   CIFAR100-20 & 0.6136 & 0.2210 & \textbf{0.7058} & 0.6740 & 0.6683 \\
M(CIFAR100-20, F-CelebA):   F-CelebA & 0.5782 & 0.5200 & 0.6273 & 0.6236 & \textbf{0.7164}\\
\specialrule{.1em}{.05em}{.05em} 
\vspace{-2mm}
\end{tabular}
}

\caption{Ablation experiment results.}
\vspace{-7mm}
\label{tab:ablation}
\end{table}

We now show the results of ablation experiments in Table \ref{tab:ablation}. ``-KTA'' means without deploying KTA (knowledge transfer attention). ``-TSV'' means without detecting task similarity, i.e., no TSV (task similarity vector), which has two cases, treating all previous tasks as dissimilar (all-dis) or treating all previous tasks as similar (all-sim). From Table \ref{tab:ablation}, we can see that the full CAT system always gives the best overall accuracy and every component contributes to the model. 
 









\section{Conclusion}

This paper first described four desired capabilities of a continual learning system: no forgetting, forward knowledge transfer, backward knowledge transfer, and learning a mixed sequence of similar and dissimilar tasks. To our knowledge, no existing continual learning method has all these capabilities. This paper proposed a novel architecture CAT to achieve all these goals. Experimental results showed that CAT outperforms strong baselines. Our future work will focus on improving the accuracy of learning similar tasks (e.g., by considering task similarity computation as a regression problem rather than a binary classification problem), and improving the efficiency (e.g., by removing explicit similarity computation). We also plan to explore ways to use fewer labeled data in training.


\section*{Acknowledgments}
This work was supported in part by two grants from National Science Foundation: IIS-1910424 and IIS-1838770, a DARPA Contract HR001120C0023, and a research gift from Northrop Grumman.

\section*{Broader Impact}
\label{sec:bi}

An intelligent agent typically needs to learn many skills or tasks. Some of the tasks are similar to each other and some are distinct. It is desirable that the agent can learn these tasks without interference with each other and also improve its learning when there is shared/transferable knowledge learned in the past. As more and more chatbots, intelligent personal assistants and physical robots appear in our lives, we believe that this research will become more and more important. We could not see anyone will be put at disadvantage by this research. The consequence of failure of the system is that the system makes some incorrect classifications. Our task and method do not  leverage biases in the data.








\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-base}


\end{document}
