
\documentclass{article} \usepackage{iclr2021_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\usepackage{caption}
\usepackage{graphicx}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{amsmath}
\usepackage[inline]{enumitem}
\usepackage{xcolor}
\usepackage{amssymb}
\usepackage{bbm}
\usepackage{booktabs}
\usepackage{wrapfig}

\SetKwInput{KwRequire}{Require}

\hypersetup{hidelinks}

\title{Neural networks with late-phase weights}





\author{Johannes von Oswald*, Seijin Kobayashi*, Alexander Meulemans,\\
\textbf{Christian Henning, Benjamin F.~Grewe, João Sacramento}\\
\vspace{0.5cm}
* -- equal contribution\\
Institute of Neuroinformatics\\
University of Zürich and ETH Zürich\\
Zürich, Switzerland\\
\texttt{\{voswaldj,seijink,ameulema,henningc,bgrewe,rjoao\}@ethz.ch}}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
The largely successful method of training neural networks is to learn their weights using some variant of stochastic gradient descent (SGD). Here, we show that the solutions found by SGD can be further improved by ensembling a subset of the weights in late stages of learning. At the end of learning, we obtain back a single model by taking a spatial average in weight space. To avoid incurring increased computational costs, we investigate a family of low-dimensional late-phase weight models which interact multiplicatively with the remaining parameters. Our results show that augmenting standard models with late-phase weights improves generalization in established benchmarks such as CIFAR-10/100, ImageNet and \texttt{enwik8}. These findings are complemented with a theoretical analysis of a noisy quadratic problem which provides a simplified picture of the late phases of neural network learning.
\end{abstract}

\section{Introduction}

Neural networks trained with SGD generalize remarkably well on a wide range of problems. A classic technique to further improve generalization is to ensemble many such models \citep{lakshminarayanan_simple_2017}. At test time, the predictions made by each model are combined, usually through a simple average. Although largely successful, this technique is costly both during learning and inference. This has prompted the development of ensembling methods with reduced complexity, for example by collecting models along an optimization path generated by SGD \citep{huang_snapshot_2017}, by performing interpolations in weight space \citep{garipov_loss_2018}, or by tying a subset of the weights over the ensemble \citep{lee_why_2015,wen_batchensemble_2020}.

An alternative line of work explores the use of ensembles to guide the optimization of a single model \citep{zhang_deep_2015,pittorino_entropic_2020}. We join these efforts and develop a method that fine-tunes the behavior of SGD using late-phase weights: late in training, we replicate a subset of the weights of a neural network and randomly initialize them in a small neighborhood. Together with the stochasticity inherent to SGD, this initialization encourages the late-phase weights to explore the loss landscape. As the late-phase weights explore, the shared weights accumulate gradients. After training we collapse this implicit ensemble into a single model by averaging in weight space.

Building upon recent work on ensembles with shared parameters \citep{wen_batchensemble_2020} we explore a family of late-phase weight models involving multiplicative interactions \citep{jayakumar_multiplicative_2020}. We focus on low-dimensional late-phase models that can be ensembled with negligible overhead. Our experiments reveal that replicating the ubiquitous batch normalization layers \citep{ioffe_batch_2015} is a surprisingly simple and effective strategy for improving generalization\footnote{We provide code to reproduce our experiments at \url{https://github.com/seijin-kobayashi/late-phase-weights}}. Furthermore, we find that late-phase weights can be combined with stochastic weight averaging \citep[][]{izmailov_averaging_2018}, a complementary method that has been shown to greatly improve generalization.

\section{Methods and models}

\subsection{Learning with late-phase weights}
\paragraph{Late-phase weights.} To apply our learning algorithm to a given neural network model  we first specify its weights  in terms of two components, base and late-phase ( and , resp.). The two components interact according to a weight interaction function . Base weights are learned throughout the entire training session, and until time step  both  and  are learned and treated on equal grounds. At time step , a hyperparameter of our algorithm, we introduce  late-phase components , that are learned together with  until the end.

This procedure yields a late-phase ensemble of  neural networks with parameter sharing: reusing the base weights , each late-phase weight  defines a model with parameters .

\paragraph{Late-phase weight averaging at test time.} Our ensemble defined by the  late-phase weight configurations in  is kept only during learning. At test time, we discard the ensemble and obtain a \emph{single} model by averaging over the  late-phase weight components. That is, given some input pattern , we generate a prediction  using the averaged model, computed once after learning:


Hence, the complexity of inference is independent of , and equivalent to that of the original model.

\paragraph{Late-phase weight initialization.} We initialize our late-phase weights from a reference base weight. We first learn a base parameter  from time step  until , treating  as any other base parameter in . Then, at time , each configuration  is initialized in the vicinity of . We explore perturbing  using a symmetric Gaussian noise model,

where  is a standard normal variate of appropriate dimension and  is a hyperparameter controlling the noise amplitude. We allow for a -dependent normalization factor, which we set so as to ensure layerwise scale-invariance, which helps finding a single  that governs the initialization of the entire network. More concretely, for a given neural network layer  with weights  of dimension , we choose .

Our perturbative initialization (Eq.~\ref{eq:ensemble-init}) is motivated by ongoing studies of the nonconvex, high-dimensional loss functions that arise in deep learning. Empirical results and theoretical analyses of simplified models point to the existence of dense clusters of connected solutions with a locally-flat geometry \citep{hochreiter_flat_1997} that are accessible by SGD \citep{huang_snapshot_2017,garipov_loss_2018,baldassi_shaping_2020}. Indeed, the eigenspectrum of the loss Hessian evaluated at weight configurations found by SGD reveals a large number of directions of low curvature \citep{keskar_large-batch_2017,chaudhari_entropy-sgd_2019,sagun_empirical_2018}. For not yet completely understood reasons, this appears to be a recurring phenomenon in overparameterized nonlinear problems \citep[][]{brown_statistical_2003,waterfall_sloppy-model_2006}.

Based on these observations, we assume that the initial parameter configuration  can be perturbed in a late phase of learning without leading to mode hopping across the different models . While mode coverage is usually a sought after property when learning neural network ensembles \citep{fort_deep_2020}, here it would preclude us from taking the averaged model at the end of learning (Eq.~\ref{eq:test-time-averaging}).



\paragraph{Stochastic learning algorithm.} Having decomposed our weights into base and late-phase components, we now present a stochastic algorithm which learns both  and . Our algorithm works on the standard stochastic (minibatch) neural network optimization setting \citep{bottou_large-scale_2010}. Given a loss function  to be minimized with respect to the weights  on a set of data , at every round we randomly sample a subset  from  and optimize instead the stochastic loss . However, in contrast to the standard setting, in late stages of learning () we simultaneously optimize  parameterizations , instead of one.

We proceed by iteration over . At each step , we sample a minibatch  and immediately update the late-phase weights , while accumulating gradients over the shared base weights . Such gradient accumulation has been previously used when learning ensembles \citep{lee_why_2015,wen_batchensemble_2020} and multi-task models \citep{rebuffi_learning_2017} with shared base parameters. A single iteration is finally concluded by changing the base weights in the direction opposite of the accumulated gradient. We scale the accumulated gradient by ; setting  recovers the original step size in , but other choices are possible. In particular, we find that a large  of unit size is in practice often tolerated, resulting in accelerated learning.

\setlength\intextsep{0pt}
\begin{wrapfigure}{r}{0.43\textwidth}
    \begin{minipage}{0.43\textwidth}
    \begin{algorithm}[H]
      \KwRequire{Base weights ,\\late-phase weight set , dataset , gradient scale factor , loss }
      \KwRequire{Training iteration }
      
      \For{}{
        Sample minibatch from 
    
       
       
       
       
      }

      
      \caption{Late-phase learning\label{alg:learning}}
     \end{algorithm}
    \end{minipage}
\end{wrapfigure}
We summarize an iteration of our method in Algorithm~\ref{alg:learning}, where the loss  is now seen as a function of  and . We opt for a general presentation using unspecified gradient-based update operators  and . These operators can be set to optimizers of choice. For instance, our method might benefit from additional noise injection onto parameter updates \citep{welling_bayesian_2011}. Furthermore, late-phase optimizers need not coincide with the optimizer used in the early phase. In our work we typically set  and  to a single step of SGD with Nesterov momentum \citep{nesterov_introductory_2004}, and explore Adam \citep{kingma_adam:_2015} and plain SGD in a smaller set of experiments.



\subsection{Late-phase weight models}
\label{section:late-phase-models}
As detailed next, we consider a number of distinct late-phase weight models in our experiments. In particular, we explore weight interaction functions  in which late-phase weights have low dimensionality, to avoid a large increase in complexity with the ensemble size . To counteract this reduced dimensionality, we make extensive use of multiplicative base-late weight interactions. This design choice is motivated by the large expressive power of multiplicative interactions despite low dimensionality, which has been demonstrated in a wide range of settings \citep{jayakumar_multiplicative_2020}.

\paragraph{Late-phase batch normalization layers.} Batch normalization layers \citep[BatchNorm;][]{ioffe_batch_2015} are a staple of current deep neural network models. Besides standardizing the activity of the layer they are applied to, BatchNorm units introduce a learnable multiplicative (scale) parameter  and an additive (shift) parameter . While being low-dimensional, these additional parameters have large expressive power: it has been shown that learning only  and  keeping the remaining weights frozen can lead to significantly lower loss than when learning random subsets of other weights of matching dimensionality \citep[][]{frankle_training_2020,mudrakarta_k_2019}.


We take the scale and shift parameters of BatchNorm layers as our first choice of late-phase weights; the base weights are the remaining parameters of the model. Batch statistics are also individually estimated for each model in . This late-phase weight parameterization is motivated by
\begin{enumerate*}[label=(\itshape\roman*)]
  \item the expressive power of  and  discussed above, and by
  \item practical considerations, as BatchNorm layers are generally already present in feedforward neural network models, and are otherwise easy to implement efficiently.
\end{enumerate*}

More concretely, let us consider an affine transformation layer  which maps an input vector  to , where the early-phase weight matrix  and bias vector  are already standardized using the respective batch statistics. For this standard layer, our model introduces a multiplicative interaction between base and late-phase weights, , and an additive interaction between base and late-phase bias parameters, .

\paragraph{Late-phase rank-1 matrix weights.} We also study a closely related late-phase weight model, where existing weight matrices -- the base components, as before -- are multiplied elementwise by rank-1 matrices \citep[][]{wen_batchensemble_2020}. For a given affine layer , we define a late-phase weight matrix with resort to a pair of learnable vectors, . Taking the Hadamard product with the base weight matrix yields the effective weights .

With this parameterization, we recover the ensemble proposed by \citet{wen_batchensemble_2020}, except that here it is generated late in training using our perturbative initialization (Eq.~\ref{eq:ensemble-init}). Unlike BatchNorm layers, which include the shift parameter, rank-1 late-phase weights interact in a purely multiplicative manner with base weights. We study this model since it is easy to implement on neural networks which do not feature BatchNorm layers, such as standard long short-term memories \citep[LSTMs;][]{hochreiter_long_1997}.

\paragraph{Hypernetworks with late-phase weight embeddings.} Additionally, we generalize the late-phase weight models described above using hypernetworks \citep[][]{ha_hypernetworks_2017}. A hypernetwork generates the parameters  of a given target neural network  based on a weight embedding. In our framework, we can use a hypernetwork to implement the interaction function  directly, with parameters  corresponding to base weights and embeddings  to late-phase weights.

We experiment with linear hypernetworks and use the same hypernetwork to produce the weights of multiple layers, following \citet{savarese_learning_2019,ha_hypernetworks_2017,von_oswald_continual_2020}. In this scheme, the weight embedding input specifies the target layer whose parameters are being generated.  More specifically, the weight matrix for some layer  belonging to a group of layers  which share a hypernetwork is given by , where  and  are appropriately-sized tensors. Sharing  over a layer group  allows countering an increase in the overall number of parameters. We parameterize our hypernetworks such that the weight embedding vectors   are small, and therefore cheap to ensemble.

\paragraph{Late-phase classification layers.} Finally, inspired by \citet{lee_why_2015}, in classification experiments we take the weights of the last linear layer as late-phase weights by default. In modern neural network architectures these layers do not usually comprise large numbers of parameters, and our architecture explorations indicated that it is typically beneficial to ensemble them. We therefore include  in our late-phase weights , where  denotes the weights of the final layer .

\section{Results}

\subsection{Noisy quadratic problem analysis}
Before turning to real-world learning problems, we first focus on a simplified stochastic optimization setup which can be analytically studied. We consider the noisy quadratic problem \citep[NQP;][]{schaul_no_2013,martens_second-order_2016,wu_understanding_2018,zhang_which_2019,zhang_lookahead_2019}, where the goal is to minimize the scalar loss

with respect to . In the equation above,  denotes the target weight vector, which is randomly shifted by a noise variable  assumed to follow a Gaussian distribution . The (constant) Hessian matrix  controls the curvature of the problem.

\begin{wrapfigure}[13]{r}{0.43\textwidth}
  \vspace{-10pt}
  \begin{center}
    \includegraphics[width=0.43\textwidth]{pdf/nqp_d.pdf}
  \end{center}
  \vspace{-15pt}
  \caption{Steady-state loss for varying , of multiplicative late-phase weights (\emph{Ours}) compared to an ensemble of models. \label{fig:NQP-main-results}}
\end{wrapfigure}
Despite the simplicity of Eq.~\ref{eq:NQP-definition}, the NQP captures a surprising number of empirically-observed aspects of neural network learning \citep{zhang_which_2019}. Here, we motivate its study as a model of late stages of learning, by Taylor expanding the loss around a minimum . Thus, for a sufficiently late initialization time  (and small ) the NQP is particularly well suited to study our algorithm.


There are three main strategies to improve the expected NQP loss after convergence:
\begin{enumerate*}[label=(\itshape\roman*)]
  \item increase the minibatch size ,
  \item use more members  in an ensemble, and
  \item decrease the learning rate  \citep{zhang_which_2019}.
\end{enumerate*}
Our Algorithm~\ref{alg:learning} combines the first two strategies in a non-trivial manner. First, the gradients for base weights  are averaged during the inner loop over all ensemble members, corresponding to a minibatch-size rescaling by . Second, we introduce  ensemble members, to be averaged in weight space, that only differ in their late-phase weights .


In Appendix \ref{apx:NQP}, we show analytically that this combination of an increased effective minibatch size for  and introducing  ensemble members for  is successful, resulting in a scaling of the expected loss after convergence by . This analysis holds for general  and , and for both scalar and hypernetwork multiplicative late-phase weights. Hence, our approach combines the benefits of an increased effective minibatch size and of ensembling, while yielding a single model after training.


We present a numerical validation of this theoretical result in Fig.~\ref{fig:NQP-main-results}. Our model includes a multiplicative late-phase weight,  with  and . We simulate a standard instance of the NQP, with diagonal Hessian  and  \citep[cf.][]{zhang_which_2019}, and report the average loss after convergence. Hyperparameters are given in Appendix~\ref{apx:NQP}. As predicted by the theory, the loss falls as  with increasing ensemble size , and our algorithm performs on par with a full ensemble of  models trained independently with gradient descent.


\vspace{-0.15cm}
\subsection{CIFAR-10/100 experiments}
To test the applicability of our method to more realistic problems, we next augment standard neural network models with late-phase weights and examine their performance on the CIFAR-10 and CIFAR-100 image classification benchmarks \citep{krizhevsky_learning_2009}. We use standard data preprocessing methods (cf.~Appendix~\ref{apx:implementation}) and train our models for 200 epochs from random initializations, except when noted otherwise. All evaluated methods are trained using the same amount of data.

Besides SGD (with Nesterov momentum), we also investigate stochastic weight averaging \citep[SWA;][]{izmailov_averaging_2018}, a recent reincarnation of Polyak averaging \citep{polyak_acceleration_1992} that can strongly improve neural network generalization. For completeness, we present pseudocode for SWA in Algorithm ~\ref{alg:swa} and SGD with Nesterov momentum in Algorithm ~\ref{alg:nesterov} (cf.~Appendix~\ref{apx:implementation}). When learning neural networks with late-phase weights we set  and  to one step of SGD (or SGD wrapped inside SWA). 

We compare our method to dropout  \citep{srivastava_dropout_2014}, a popular regularization method that can improve generalization in neural networks. Like our approach, dropout produces a single model at the end of training. We also consider its Monte Carlo variant \citep[MC-dropout;][]{gal_dropout_2016}, and the recently proposed BatchEnsemble \citep{wen_batchensemble_2020}. This method generates an ensemble using rank-1 matrices as described in Section~\ref{section:late-phase-models}. Predictions still need to be averaged over multiple models, but this averaging step can be parallelized in modern hardware.

Additionally, we report single-seed results obtained with an ensemble of  independently-trained models \citep[a deep ensemble,][]{lakshminarayanan_simple_2017}. Deep ensembles provide a strong baseline, at the expense of large computational and memory costs. Therefore, they are not directly comparable to the other methods considered here, and serve the purpose of an upper baseline.

\setlength\intextsep{0pt}
\begin{wraptable}[16]{r}{0.5\textwidth}
\caption{CIFAR-10, WRN 28-10. Mean  std.~over 5 seeds. Late-phase BatchNorm (LPBN).}
  \label{tab:CIFAR-10}
\centering
  {\renewcommand{\arraystretch}{1.1}\setlength{\tabcolsep}{4pt}
  \begin{tabular}{@{}llllllll@{}} 
    \toprule
Model & Test acc. (\%) \\\midrule
Base (SGD)      &    96.16  \\
Dropout (SGD)   & 96.02 \\
MC-Dropout (SGD)   & 96.03 \\
BatchEnsemble (SGD)   & 96.19 \\
Late-phase (SGD)  & \textbf{96.46}    \\\midrule
Base (SWA)      &    96.48   \\
Late-phase (SWA) & \textbf{96.81}    \\
\midrule
Deep ensemble (SGD) &  96.91  \\
Deep ensemble (LPBN, SGD) &  \textbf{96.99}  \\\bottomrule
    \end{tabular}}
\end{wraptable}
By contrast, augmenting the architectures considered here with late-phase weights results in negligible additional costs during learning (with the exception of hypernetworks, which require additional tensor products) and none during testing. In principle, a set of independently-trained models yielded by our algorithm can therefore even be used as the basis of a deep ensemble, when the memory and compute budget allows for one. We present proof-of-concept experiments exploring this option.


Throughout our CIFAR-10/100 experiments we set , use a fast base gradient scale factor of , and set our late-phase initialization hyperparameters to  (measured henceforth in epochs;  for SWA) and do not use initialization noise, . These hyperparameters were tuned manually once on CIFAR-100 and then kept fixed unless otherwise noted. We use standard learning rate scheduling, optimized for SGD and SWA on the base model (cf.~Appendices~\ref{apx:implementation} and \ref{apx:extra-expt}). Last-layer weights are included by default in our late-phase weight set .


\paragraph{CIFAR-10.} For CIFAR-10 we focus on the WRN architecture, a high-performance residual network \citep[WRN;][]{zagoruyko_wide_2016} which features BatchNorm layers. Taking advantage of this we implement a late-phase weight model consisting of BatchNorm shift and scale parameters.

All algorithms achieve a training error close to zero (cf.~Appendix~\ref{apx:extra-expt}). The resulting predictive accuracies are shown in Table~\ref{tab:CIFAR-10}. We find that augmenting the WRN 28-10 (a standard WRN configuration) with BatchNorm late-phase weights leads to a systematic improvement in generalization, reducing the gap with a deep ensemble of  models. Initializing our ensemble from the onset () fails to meet the performance of the base model, reaching only \% (cf.~Appendix~\ref{tab:t0-sensitivity}).

We also investigate initializing a late-phase (full) deep ensemble at . This results in a test set accuracy of , in between late-phase BatchNorm weights and no late-phase weights at all. This speaks to the data-efficiency of our low-dimensional late-phase ensembles which can be trained with as little data as a single model, besides being memory efficient.



In addition, we consider a larger instance of the WRN model (the WRN 28-14), trained for 300 epochs using cutout data augmentation \citep[][]{devries_improved_2017}, as well as a small convolution neural network without skip connections, cf.~Table~\ref{tab:CIFAR-other-arch}. When late-phase weights are employed in combination with SWA, we observe significant accuracy gains on the WRN~28-14. Thus, our late-phase weights impose an implicit regularization that is effective on models with many weights. Similarly, we observe larger gains when training on a random subset of CIFAR-10 with only  examples (cf.~Appendix~\ref{apx:extra-expt}).



\setlength\intextsep{10pt}
\begin{table}[h]
\centering
\caption{Mean CIFAR-100 test set accuracy (\%)  std.~over 5 seeds, WRN 28-10. Different late-phase weight augmentations are compared to the base architecture and to an upper bound consisting of an ensemble of models. \emph{Deep ens.}~stands for deep ensemble, \emph{LPBN} for late-phase BatchNorm.\label{tab:CIFAR-100}}
\begin{tabular}{llllll}
\toprule
    & Base & BatchNorm & Hypernetwork &  Deep ens. & Deep ens.~(LPBN) \\\midrule
SGD &  81.35   & 82.87&   81.55 &                      84.09 & 84.69     \\
SWA &  82.46  & 83.06& 82.01   &   83.62 & -    \\\bottomrule  
\end{tabular}
\vspace{-0.4cm}
\end{table}
\paragraph{CIFAR-100.} We next turn to the CIFAR-100 dataset, which has 10-fold less examples per class and more room for improvements. We study the WRN~28-10, as well as the larger WRN~28-14 variant (using cutout data augmentation as before) and a PyramidNet \citep{han_deep_2017} with ShakeDrop regularization \citep{yamada_shakedrop_2019}. The latter are trained for 300 epochs.



Predictive accuracy is again highest for our neural networks with late-phase weights, trained with SGD or SWA, cf.~Table~\ref{tab:CIFAR-100}. We observe that the simplest BatchNorm late-phase weight model reaches the highest accuracy, with late-phase hypernetwork weight embeddings yielding essentially no improvements. Once again, the setting of  (onset ensemble learning) fails to match base model performance, finishing at
\% test accuracy. As for CIFAR-10, a late-phase full deep ensemble only reached intermediate improvements, at \% test accuracy. Furthermore, a gap towards deep ensembles persists. This suggests that covering different modes of the loss \citep{fort_deep_2020} can provide benefits that cannot be captured by ensembling models in a small neighborhood.

\setlength\intextsep{0pt}
\begin{wraptable}[10]{R}{0.57\textwidth}
  \caption{Additional architectures, CIFAR-10 (C10) and CIFAR-100 (C100). Mean test set acc.~ std.~over 3 seeds (\%). Late-phase BatchNorm weights.}
  \label{tab:CIFAR-other-arch}
 \vspace{-0.2cm}
\begin{tabular}{lll}
\toprule
           & Base & Late-phase \\\midrule
C10 ConvNet (SGD)      & 77.41   &  77.94      \\
C10 WRN 28-14 (SWA)  &     96.75     &  97.45 \\
C100 WRN 28-14 (SWA)  &     84.01     &  85.00 \\
C100 PyramidNet (SGD) &     84.04     &  84.35 \\
\bottomrule
\end{tabular}
\end{wraptable}
The final averaged solutions found with late-phase weights are strong base models to build a deep ensemble of independently-trained networks. The fact that our algorithm yields a single model allows further pushing the upper bound of what can be achieved when unrestricted full ensemble training is possible. This improvement comes at no cost compared to a standard deep ensemble.




We train additional neural network architectures restricting our experiments to the BatchNorm late-phase weight model, which can be readily implemented without architectural modifications. Again, learning with late-phase weights yields a consistent improvement over the baseline, cf.~Table~\ref{tab:CIFAR-other-arch}. 

\begin{wrapfigure}[14]{R}{0.4\textwidth}
\begin{center}
    \includegraphics[width=0.4\textwidth]{pdf/const-crop.pdf}
  \end{center}
  \vspace{-10pt}
  \captionof{figure}{WRN  28-10, CIFAR-100, constant learning rate SWA (activated at epoch 150). With BatchNorm  late-phase weights (=10, initialized at epoch 120) and without (=1). Mean  test  acc.~(\%)  std.~over 5 seeds. \label{fig:constant-LR-results}}
\end{wrapfigure}
Notably, SWA can achieve high predictive accuracy with a large constant learning rate  \citep{izmailov_averaging_2018}. We reproduce these previous results and show that they improve when learning with late-phase weights, cf.~Fig.~\ref{fig:constant-LR-results}. Substantial progress is made both when entering the late-phase learning period and when activating SWA.


\paragraph{Out-of-distribution (OOD) generalization.} Deep ensembles are an effective technique for improving the behavior of neural networks in OOD data \citep{lakshminarayanan_simple_2017}. We ask whether our implicit ensembles modeled during late-phase learning could confer a similar advantage to our final averaged model.

Additionally, we evaluate the performance of a late-phase weight ensemble obtained with large initialization noise  (at ), skipping the final weight averaging step. This requires integrating predictions over  late-phase ensemble members at test time, . Unlike standard deep ensembles, training this ensemble is still as cheap as training a single model.

\setlength\intextsep{10pt}
\begin{table}[h]
\vspace{0.2cm}
\centering
\caption{CIFAR-100, WRN-28-10, uncertainty representation results. Mean  std.~over 5 seeds (except deep ensembles). This first group of methods yield a single model; the second group requires test-time averaging over models while training as efficiently as =1; the last group are full deep ensembles which require training =10 models from scratch (\emph{Deep ens.}). We report in-distribution test set acc.~(\%) and negative log-likelihood (NLL), and in-distribution vs.~out-of-distribution (OOD) discrimination performance (average AUROC over four OOD datasets, see main text).\label{tab:ood}}
\begin{tabular}{llll}

\toprule
               & Test acc. (\%) & Test NLL & OOD \\\midrule
Base (SGD)            &   81.35 & 0.7400 &   0.8015         \\\midrule
Dropout (Mean) (SGD)     &    81.31       &0.7736&      0.8022    \\
Late-phase Hypernetwork (SGD)     &  81.55   & 0.8327  &   0.8209    \\
Late-phase BatchNorm (SGD)     &    \textbf{82.87}       &\textbf{0.7542}&      \textbf{0.8360}    \\
\midrule
MC-Dropout (SGD)     &    81.55       &0.7105&      0.8225    \\
SWAG (SWA)         & 82.12    &    \textbf{0.6189}     &      0.8283    \\
BatchEnsemble (SGD)     &    81.25       &0.7691&      0.8285    \\
Late-phase BatchNorm (SGD, non-averaged)     &    \textbf{82.71}       & 0.7512&      \textbf{0.8624}  \\
\midrule
Deep ens. (SGD) & 84.09 & \textbf{0.5942} &  0.8312 \\
Deep ens. (Late-phase BatchNorm, SGD) & \textbf{84.69} & 0.6712 &  \textbf{0.8575} \\\bottomrule       
\end{tabular}
\end{table}
We draw novel images from a collection of datasets (SVHN, \citet{netzer_reading_2011}; LSUN, \citet{yu_lsun_2015}; Tiny ImageNet; CIFAR-10) and present them to a WRN 28-10 trained on CIFAR-100.  We use Shannon's entropy \citep{cover_elements_2006} to measure the uncertainty in the output predictive distribution, which should be high for OOD and low for CIFAR-100 data. Overall performance is summarized using the area under the receiver operating characteristics curve (AUROC), averaged over all datasets. We report per-dataset results in Appendix \ref{apx:extra-expt} (Table~\ref{tab:c100-detailed-ood}) alongside experiments measuring robustness to corruptions in the input data \citep{hendrycks_benchmarking_2019}.


\begin{wrapfigure}[13]{R}{0.4\textwidth}
  \vspace{-19pt}
  \begin{center}
    \includegraphics[width=0.4\textwidth]{pdf/flat-crop.pdf}
  \end{center}
  \vspace{-14pt}
  \captionof{figure}{Flatness score. Mean score  std.~over 5 seeds, WRN  28-10, CIFAR-100, SGD, with  and  without  BatchNorm  late-phase weights. Slower increase with  is better.\label{fig:flatness-results}}
\end{wrapfigure}
We compare our results to alternative methods with strong uncertainty representation: MC-dropout \citep{gal_dropout_2016}, SWA-Gaussian \citep[SWAG;][]{maddox_simple_2019} and BatchEnsemble \citep{wen_batchensemble_2020}. All three methods require integrating predictions over an ensemble at test time.

We find that learning with late-phase weights increases prediction uncertainty in OOD data, allowing for a significantly better separation between in and out-of-distribution examples, cf.~Table~\ref{tab:ood}. The OOD performance of late-phase BatchNorm weights compares favorably to the alternative methods including deep ensembles, even when using a single weight-averaged model, while maintaining high predictive accuracy. Remarkably, keeping the late-phase BatchNorm ensemble at test time allows reaching the highest OOD performance throughout. Paired with non-zero initialization noise  (cf.~Appendix~\ref{apx:extra-expt}), this method results in the best OOD performance.

Despite our improved performance on both predictive accuracy (with late-phase BatchNorm) and OOD discrimination (with late-phase BatchNorm and hypernetwork embeddings), the test set negative log-likelihood \citep[NLL; often used to assess predictive uncertainty,][]{guo_calibration_2017} is surprisingly slightly worse for our solutions. This is aligned with the finding that SWA does not always significantly reduce NLL, even though predictive accuracy increases \citep{maddox_simple_2019}.



\paragraph{Flatness.} Why do our networks generalize better? Approximate Bayesian inference suggests that flat minima generalize better than sharp minima \citep{hochreiter_flat_1997,mackay_practical_1992}. Due to symmetries that are present in neural networks there is some debate surrounding this argument \citep{dinh_sharp_2017}, but current evidence seems favorable \citep[][]{jiang_fantastic_2020}.


We hypothesize that sharing base weights over  late-phase weight configurations can implicitly lead to flatter solutions. To investigate whether our algorithm finds flatter minima, we examine a simple flatness score that correlates well with generalization \citep{pittorino_entropic_2020,jiang_fantastic_2020}. Concretely, we add multiplicative Gaussian noise  to each weight  and then measure the change in the loss
. Our final weight configurations are indeed in flatter regions of weight space according to this measure:  increases more slowly with  for the WRN 28-10 models that are learned with BatchNorm late-phase weights, Fig.~\ref{fig:flatness-results}.


\subsection{ImageNet experiments}
\setlength\intextsep{0pt}
\begin{wraptable}[10]{R}{0.55\textwidth}
\vspace{-0.05cm}
\centering
  \caption{Validation set acc.~(\%) on ImageNet. Mean  std.~over 5 seeds. BatchNorm late-phase and baseline trained for 20 epochs with SGD.}
  \label{tab:imagenet}
\begin{tabular}{llll}
\toprule
           & Initial & Base & Late-phase \\\midrule
ResNet-50  & 76.15 & 76.62 & 76.87 \\
ResNet-152  & 78.31 & 78.37 & 78.77 \\
DenseNet-161  & 77.65 & 78.17 & 78.31 \\
\midrule
\end{tabular}
\end{wraptable}
To investigate whether our gains translate to large-scale learning problems, we train deep residual networks \citep{he_deep_2016} and a densely-connected convolutional network \citep[DenseNet;][]{huang_densely_2018} on the ImageNet dataset \citep{russakovsky_imagenet_2015}. We start from pretrained models and contrast BatchNorm late-phase weight learning to fine-tuning with SGD for 20 epochs, with  and  (cf.~Appendix~\ref{apx:implementation}). For simplicity we do not include last-layer weights in .


Fine-tuning with late-phase weights improves the final top-1 validation accuracy of this pretrained model significantly with only minor training, as seen in Table~\ref{tab:imagenet}. These results serve as a proof-of-concept that existing models can be further improved, taking our late-phase initialization  as the time the previous experimenter stopped training. In Appendix~\ref{apx:extra-expt}, we present additional CIFAR-100 experiments where we apply late-phase learning starting at the suboptimal end-of-training , to mimic the pretrained condition.

\subsection{LSTM language modeling experiments}


Finally, we conduct experiments on the language modeling benchmark \texttt{enwik8}. To show that the benefits of late-phase weights extend to recurrent neural networks, we augment a standard LSTM with multiplicative late-phase weights consisting of rank-1 matrices \citep[][cf.~Section~\ref{section:late-phase-models}]{wen_batchensemble_2020}. 

\begin{wraptable}[10]{r}{0.5\textwidth}
  \caption{\texttt{enwik8} results measured in bits per character (BPC), LSTM with 500 units. Mean ~over 5 seeds, with std.  for all results.}
  \label{tab:lstm}
  \vspace{-0.2cm}
  \centering
  {\renewcommand{\arraystretch}{1.1}\setlength{\tabcolsep}{4pt}
  \begin{tabular}{@{}llll@{}} 
    \toprule
Model & Train & Test & Test (SWA) \\\midrule
Base           &     1.570      &  1.695  & 1.626  \\
Base + Rank1    &      1.524     &  1.663  & 1.616  \\
Late-phase Rank1     &      1.522     &  1.633  &  1.615   \\\bottomrule
\end{tabular}}
\end{wraptable}
Overfitting is a major issue when training LSTMs. Recent studies have shown that by leveraging vast amounts of computation and smart black-box optimizers \citep{golovin_google_2017}, properly regularized LSTMs can outperform previously published state-of-the-art models \citep{melis_state_2017}. To avoid this issue, we train models where the number of parameters (1.56M) is drastically smaller than the number of training data points (90M), such that we do not observe any overfitting. Thus, we do not apply any regularization. This helps minimize the effects of hyperparameter tuning. Our only hyperparameter is the learning rate ( here), which we tune via grid search to maximize base model performance.

We train our LSTM with 500 units for 50 epochs, optimizing every weight with Adam \citep{kingma_adam:_2015}. We apply a multiplicative rank-1 matrix elementwise to the recurrent weight matrix. Interestingly, merely adding the multiplicative parameters to the LSTM (Base) accelerates training and leads to better training and test set performance (measured in bits per character, BPC) with no additional changes to the optimizer (Base + Rank1, Table~\ref{tab:lstm}). Further improvements can be achieved with our late-phase weights. We generate  late-phase weight components at epoch 30 with  and set . 
Additionally, we find that SWA (starting at epoch 40) substantially improves all scores, with smaller gains on the models with multiplicative weights.



\section{Related work}
Our late-phase weights define an ensemble with the special property that every model shares the same base weights. Such parameter sharing is an established method for ensembling neural networks while controlling for the memory and time complexity of learning \citep{lee_why_2015}. In designing our late-phase weight models, we draw directly from recent work which proposes sharing a set of base parameters over  rank-1 matrices \citep{wen_batchensemble_2020} or  heads \citep{lee_why_2015}.


The elastic averaging SGD algorithm learns  neural networks in parallel, coupled through an additional central model \citep[EASGD;][]{zhang_deep_2015}. Like our algorithm, EASGD often yields solutions which generalize better than those found by standard SGD \citep{pittorino_entropic_2020}. Our late-phase weight learning is intimately related to EASGD, as we optimize the performance of a central model through an ensemble. However, thanks to parameter sharing and late-phase ensembling, we do not find the need to introduce a coupling term to our loss function. Additionally, as we replicate a small number of parameters only, the complexity of our algorithm is greatly reduced in comparison to EASGD, which requires learning a full ensemble of models.


Splitting the weights of a neural network into a set of fast and slow components which vary on different timescales is a classic technique \citep{hinton_using_1987,schmidhuber_learning_1992} that has proven useful in a wide range of problems. This list includes applications to few-shot learning \citep{munkhdalai_meta_2017,nichol_first-order_2018,perez_film_2018,zintgraf_fast_2019,flennerhag_meta-learning_2020}, optimization \citep{zhang_lookahead_2019,chaudhari_entropy-sgd_2019}, improving recurrent neural networks \citep{ba_using_2016,ha_hypernetworks_2017}, and continual learning with biologically-realistic synapses \citep{kaplanis_continual_2018,leimer_synaptic_2019}, to name a few. Although there is no explicit separation of timescales in our weight components, the update accumulation in  as  varies (cf.~Algorithm~\ref{alg:learning}) suggests interpreting the base  as slow weights and the late-phase  as fast weights. 

This accumulation is reminiscent of a recent meta-learning algorithm \citep{zintgraf_fast_2019}, which first separates parameters into task-shared and task-specific, and then differentiates through a sequence of accumulated updates performed over the task-specific parameters \citep{finn_model-agnostic_2017}. Continuing with the fast-slow weight analogy, our averaging over fast weights at the end of learning (Eq.~\ref{eq:test-time-averaging}) could be thought of as a synaptic consolidation step which integrates the fast weight components onto a slow, persistent form of memory.


\section{Conclusion}
We proposed to replicate and learn in parallel a subset of weights in a late phase of neural network learning. These late-phase weights define an ensemble of models which share every other weight. We studied convolutional neural networks, a common recurrent neural network, and a simple quadratic problem. Surprisingly, across these cases, we found that a small number of appropriately chosen such weights can quickly guide SGD towards solutions that generalize well. Most of our experiments relied on BatchNorm late-phase weights, making our method easy to implement in a wide range of existing models, including pretrained ones. We expect future work to uncover new effective late-phase weight models.

\section*{Acknowledgements}
This work was supported by the Swiss National Science Foundation (B.F.G. CRSII5-173721 and 315230\_189251), ETH project funding (B.F.G. ETH-20 19-01), the Human Frontiers Science Program (RGY0072/2019) and funding from the Swiss Data Science Center (B.F.G, C17-18, J.v.O. P18-03). João Sacramento was supported by an Ambizione grant (PZ00P3\_186027) from the Swiss National Science Foundation. We would like to thank Nicolas Zucchet, Simon Schug, Xu He, Ângelo Cardoso and Angelika Steger for feedback, Mark van Rossum for discussions on flat minima, Simone Surace for his detailed feedback on Appendix~\ref{apx:NQP}, and Asier Mujika for providing very useful starter code for our LSTM experiments.

\bibliography{ensembles}
\bibliographystyle{iclr2021_conference}

\appendix
\setlength\intextsep{10pt}

\section{Additional implementation details}
\label{apx:implementation}


\paragraph{Hypernetwork model.} The base neural network architecture we use when parameterizing our weights using a hypernetwork is identical to the WRN~28-10 described by \citet{zagoruyko_wide_2016}. Our hypernetwork implementation closely follows \citet{savarese_learning_2019}, who studied high-performing linear hypernetwork architectures for WRNs. We do not use dropout or biases in the convolutional layers. The parameters of every convolutional layer are hypernetwork-generated, with one hypernetwork per layer group (Table~\ref{tab:hnet-spec}). The remaining parameters, namely those of BatchNorm units and final linear layer weights, are non-hypernetwork-generated.

Following \citet{savarese_learning_2019} we turn off weight decay for the model embeddings and initialize these parameters with a random pseudo-orthogonal initialization over layers. The hypernetwork parameters are initialized using a standard Kaiming initialization \citep{he_delving_2015}.

\begin{table}[htbp!]
  \caption{Specification of the hypernetwork used for each convolutional layer of the WRN, indexed by its depth in the network. A depth marked by * refers to the residual connection spanning across the specified layers. The characteristics of each layer is described in the format input-channels  [kernel-size]  output-channels under \emph{Conv-layer}. Layers within the same group are generated by the same hypernetwork. Each hypernetwork has a unique parameter tensor of shape \emph{Hnet-PS}, which, when multiplied by a layer and weight embedding of shape \emph{Emb-PS} and reshaped appropriately, generates the primary network parameter of shape \emph{Base-PS}.}
  \label{tab:hnet-spec}
 \centering
  {\renewcommand{\arraystretch}{1.1}\setlength{\tabcolsep}{5pt}
  \begin{tabular}{@{}llllll@{}}
  \toprule
Depth & Conv-layer & Base-PS & Layer group & Hnet-PS & Emb-PS \\ 
 \midrule
1 & 3[33]16 & [16, 3, 3, 3] & 0 & [16, 3, 3, 3, 10] & [10, 1] \\ 
 &  &  &  &  &  \\ 
2 & 16[33]160 & [160, 3, 3, 16] & 1 & [160, 3, 3, 16, 7] & [7, 1] \\ 
3 & 160[33]160 & [160, 3, 3, 160] & 2 & [160, 3, 3, 80, 14] & [14, 2] \\ 
4 & 160[33]160 & [160, 3, 3, 160] & 2 & [160, 3, 3, 80, 14] & [14, 2] \\ 
5 & 160[33]160 & [160, 3, 3, 160] & 2 & [160, 3, 3, 80, 14] & [14, 2] \\ 
6 & 160[33]160 & [160, 3, 3, 160] & 2 & [160, 3, 3, 80, 14] & [14, 2] \\ 
7 & 160[33]160 & [160, 3, 3, 160] & 2 & [160, 3, 3, 80, 14] & [14, 2] \\ 
8 & 160[33]160 & [160, 3, 3, 160] & 2 & [160, 3, 3, 80, 14] & [14, 2] \\ 
9 & 160[33]160 & [160, 3, 3, 160] & 2 & [160, 3, 3, 80, 14] & [14, 2] \\ 
 &  &  &  &  &  \\ 
10 & 160[33]320 & [320, 3, 3, 160] & 3 & [320, 3, 3, 160, 14] & [14, 1] \\ 
11 & 320[33]320 & [320, 3, 3, 320] & 3 & [320, 3, 3, 160, 14] & [14, 2] \\ 
12 & 320[33]320 & [320, 3, 3, 320] & 3 & [320, 3, 3, 160, 14] & [14, 2] \\ 
13 & 320[33]320 & [320, 3, 3, 320] & 3 & [320, 3, 3, 160, 14] & [14, 2] \\ 
14 & 320[33]320 & [320, 3, 3, 320] & 3 & [320, 3, 3, 160, 14] & [14, 2] \\ 
15 & 320[33]320 & [320, 3, 3, 320] & 3 & [320, 3, 3, 160, 14] & [14, 2] \\ 
16 & 320[33]320 & [320, 3, 3, 320] & 3 & [320, 3, 3, 160, 14] & [14, 2] \\ 
17 & 320[33]320 & [320, 3, 3, 320] & 3 & [320, 3, 3, 160, 14] & [14, 2] \\ 
 &  &  &  &  &  \\ 
18 & 320[33]640 & [640, 3, 3, 320] & 4 & [640, 3, 3, 320, 14] & [14, 1] \\ 
19 & 640[33]640 & [640, 3, 3, 640] & 4 & [640, 3, 3, 320, 14] & [14, 2] \\ 
20 & 640[33]640 & [640, 3, 3, 640] & 4 & [640, 3, 3, 320, 14] & [14, 2] \\ 
21 & 640[33]640 & [640, 3, 3, 640] & 4 & [640, 3, 3, 320, 14] & [14, 2] \\ 
22 & 640[33]640 & [640, 3, 3, 640] & 4 & [640, 3, 3, 320, 14] & [14, 2] \\ 
23 & 640[33]640 & [640, 3, 3, 640] & 4 & [640, 3, 3, 320, 14] & [14, 2] \\ 
24 & 640[33]640 & [640, 3, 3, 640] & 4 & [640, 3, 3, 320, 14] & [14, 2] \\ 
25 & 640[33]640 & [640, 3, 3, 640] & 4 & [640, 3, 3, 320, 14] & [14, 2] \\ 
 &  &  &  &  &  \\ 
24* & 16[11]160 & [160,1, 1, 16] & 5 & [160, 1, 1, 16, 7] & [7, 1] \\ 
1012* & 160[11]320 & [320, 1, 1, 160] & 6 & [320, 1, 1, 160, 7] & [7, 1] \\ 
1820* & 320[11]640 & [640, 1, 1, 320] & 7 & [640, 1, 1, 320, 7] & [7, 1] \\
 \midrule
  \end{tabular}}
\end{table}




\paragraph{Small ConvNet model.} We train a slight modification of the classic LeNet-5 \citep{lecun_gradient-based_1998} for 200 epochs on CIFAR-10. Both convolutional and fully-connected layers are left unchanged, but we use rectified linear units on the hidden layers. Furthermore, after each such activation, BatchNorm units are inserted. We optimize the model with SGD and use late-phase BatchNorm weights, with  and . For simplicity of implementation, we do not include the last linear layer in the late-phase weight set .

\paragraph{Optimization.} We optimize the cross-entropy loss, using either SGD with Nesterov momentum (0.9) or SGD with Nesterov momentum (0.9) wrapped inside SWA. \textbf{LSTM:} Our LSTM experiments use Adam with constant learning rate , batch size , and no regularizers such as weight decay or dropout. \textbf{WRN-28-10:} For our WRN experiments on the CIFAR datasets we use the learning rate annealing schedule of \citet{izmailov_averaging_2018}, according to which an initial learning rate of  is linearly decreased at every epoch from the end of the 100th epoch (80th for SWA) to the end of the 180th epoch (144th for SWA; SWA is activated at epoch 160), when a final value of  ( for SWA) is reached. Our optimizers use Nesterov momentum (set to ), a batch size of  and weight decay (set to ). On CIFAR-100 (SGD) we set the weight decay of late-phase weights proportional to the ensemble size, . \textbf{WRN-28-14:} The WRN 28-14 models are trained for 300 epochs on CIFAR-100. The learning rate is initialized at 0.1, then annealed to 0.05 from the 80th epoch to the 240th epoch. SWA is activated at epoch 160. All other hyperparameters are identical to those of WRN~28-10. \textbf{ConvNet:} Same as for the WRN~28-10 model, except that we anneal the learning rate until the 160th epoch.

\begin{figure}[h!]
\centering
\begin{minipage}{0.46\textwidth}
\begin{algorithm}[H]    
  \KwRequire{Base weights , dataset , hyperparameter , loss }
  \KwRequire{Training iteration }
   Sample minibatch from \\
 \\
 
 
 \\
   
  \caption{Stochastic weight averaging (SWA)\label{alg:swa}}
 \end{algorithm}
 \hspace{0.5cm}
\end{minipage}
\begin{minipage}{0.46\textwidth}
\hspace{0.3cm}
\begin{algorithm}[H]    
  \KwRequire{Base weights , dataset , learning rate , momentum , loss }
   Sample minibatch from \\
 \\
 \\
   
  \caption{SGD with Nesterov momentum\label{alg:nesterov}}
 \end{algorithm}
\end{minipage}
  \caption{Pseudocode for a single parameter update for SWA and SGD with Nesterov momentum, the two main optimizers used in our experiments. These are either used standalone, or as  and  in Algorithm \ref{alg:learning} (main text).  in Algorithm \ref{alg:swa} (SWA) serves as a placeholder for a parameter update rule such as SGD (with Nesterov momentum) or Adam. Training iteration  is counted from the activation of SWA in Algorithm \ref{alg:learning}.}
\end{figure}


\begin{figure}[h!]
\centering
\begin{minipage}{0.8\textwidth}
    \begin{algorithm}[H]
      \KwRequire{Base weights , late-phase weight set , dataset , gradient scale factor , learning rate , ensemble size , initialization noise , initialization time , number of training iterations , loss }
      \textbf{Initialization:} , , \\
      \While{}{
        \If{}{
        \textrm{// generate late-phase weights}
        
            \For{}{
                
                
                
            }
            
            
            
            
            
            
            
        }
      \For{}{
        Sample minibatch from 
    
       
       
       
       
       
      }

      
      }
      
      \caption{Late-phase learning\label{alg:learning_2}}
     \end{algorithm}
 \hspace{0.5cm}
\end{minipage}
  \caption{Complete pseudocode for an entire training session using late-phase weights. To avoid notational clutter ,  and  are measured in numbers of minibatches consumed. In the paper, we measure  and  in epochs. For simplicity, we present the case where  and  are set to plain SGD (without momentum) and  of dimension 1. Other optimization algorithms (e.g., Algorithm \ref{alg:swa} or Algorithm \ref{alg:nesterov}) can be used to replace  and  , as described in Algorithm~\ref{alg:learning}. Note that we increase  inside the inner loop. This highlights  (\textit{i}) that
   every specialist parameter is trained only on  data samples after  compared to , and (\textit{ii}) that  we count every minibatch drawn from the data to compare fairly to algorithms without an inner loop.}
\end{figure}


\paragraph{Batch normalization units.} Whenever we use SWA, we follow \citet{izmailov_averaging_2018} and perform a full pass over the training set to re-estimate BatchNorm unit statistics before testing. This correction is required since the online BatchNorm mean and variance estimates track the activations produced with the raw (non-averaged) weights during training, while the averaged solution is the one used when predicting at test time.

\paragraph{Data augmentation and preprocessing.} On both CIFAR and ImageNet datasets, all images are normalized channelwise by subtracting the mean and dividing by the standard deviation; both statistics are computed on the training dataset. The same transformation is then applied when testing, including to OOD data. Following a standard procedure \citep[e.g.,][]{zagoruyko_wide_2016,he_deep_2016} we augment our training datasets using random crops (with a 4-pixel padding for CIFAR) and random horizontal flips. The ImageNet training dataset is augmented with random horizontal flips, as well as random cropping of size 224, while a centered cropping of size 224 was used on the test set. Our OOD datasets are resized to fit whenever necessary; we used the resized images made available by \citet{lee_simple_2018}.

\paragraph{ImageNet experiments.} The pretrained model for the ImageNet experiment is obtained from torchvision's models subpackage. We fine-tune the model for 20 additional epochs on ImageNet. We use a multistep learning rate scheduler, starting at  then decreasing at the 10th epoch to . We use SGD with momentum (set to ) and weight decay (set to ) as our optimizer, with a batch size of . We use  and  for our late-phase model.

\begin{wraptable}[13]{R}{0.45\textwidth}
\centering
\caption{CIFAR-100 test set accuracy (\%) depending on different values of  for WRN 28-10, SGD. Mean  std.~over 5 seeds.\label{tab:k-sensitivity}}
\begin{tabular}{ll}
\toprule
    & Test acc. (\%) \\\midrule
1 &  81.35     \\
5 & 82.44  \\
10  & 82.87  \\
15  & 83.01  \\
20  & 82.86  \\
\bottomrule  
\end{tabular}
\end{wraptable}

\paragraph{Code forks.}
Our hypernetwork implementation was inspired by the code made publicly available by \citet{savarese_learning_2019}. Our implementation of SWA was adapted from the code accompanying the work of \citet{izmailov_averaging_2018}, now available on the torchcontrib Python package. The SWAG method was evaluated directly using the code provided by the authors \citep{maddox_simple_2019}. We used the same base WRN model as \citet{maddox_simple_2019}, which can be retrieved from \url{https://github.com/meliketoy/wide-resnet.pytorch}.

\paragraph{LSTM}

All experiments are conducted using the Tensorflow Python framework \citep{abadi_tensorflow_2016}. All base weights are initialized uniform in  whereas the initial rank-1 matrix weights are centered around  i.e.  to mitigate strong difference in initialization compared to the base model. We use the Tensorflow default values (, , ) for the Adam optimiser. We perform a grid search over  (in steps of size 0.05) for our LSTM experiments (fixing  and varying ) and obtain the values reported in the main text,  and .

\section{Additional experiments}
\label{apx:extra-expt}
\begin{table}[h!]
\centering
  \caption{Applying late-phase weights to a pretrained WRN~28-10, CIFAR-100, SGD. Mean  std.~over 5 seeds.}
  \label{tab:pretrained-c100}
  \vspace{-0.2cm}
  \centering
    \begin{tabular}{ll}
    \toprule
    Model    & Test acc. (\%) \\\midrule
    Initial &  81.35 \\
    Base &  81.47    \\
    Late-phase BatchNorm & 82.02 \\
    Late-phase BatchNorm, frozen base weight  &  81.50  \\\bottomrule  
    \end{tabular}
\end{table}

\paragraph{Pretrained CIFAR-100.}
We apply our method to a standard WRN 28-10 pretrained on CIFAR-100 (i.e., we set ) and train for an additional 20 epochs. At the beginning of the fine-tuning, the learning rate is reset to 0.01, then annealed linearly to 0.001 for 10 epochs. It is then held constant for the remainder of the fine-tuning process. We observe that augmenting with BatchNorm late-phase weights yields an improved predictive accuracy compared to additional fine-tuning with SGD (Base), cf.~Table~\ref{tab:pretrained-c100}. Both methods improve over the initial baseline (Initial), including the base model. This can be explained by the optimization restart and the accompanying spike in the learning rate introduced by our scheduler \citep{loshchilov_sgdr_2017}.



Importantly, we find that fine-tuning only BatchNorm late-phase weights while keeping all other weights fixed does not even match the Base control. Together with the finding that the optimal late-phase weight initialization time is at  (when learning for 200 epochs), this result speaks to the importance of jointly optimizing both base and late-phase weights through our Algorithm~\ref{alg:learning}.


\begin{table}
\centering
  \caption{Gradient accumulation control, CIFAR-100, WRN 28-10, SGD. Mean  std.~over 5 seeds.}
  \label{tab:gead-control}
  \vspace{-0.2cm}
  \centering
  {\renewcommand{\arraystretch}{1.1}\setlength{\tabcolsep}{4pt}
  \begin{tabular}{@{}llllllll@{}} 
    \toprule
Model & Test acc. (\%) \\\midrule
Base (SGD)      &  81.35     \\
Base + gradient accumulation (   & 80.76   \\
Base + gradient accumulation (  & 80.34      \\\bottomrule
    \end{tabular}}
\end{table}

\paragraph{Gradient accumulation control.} Here we show that the improved generalization we report in the main text is not merely due to gradient accumulation over larger batches. We take our base WRN 28-10 model (without late-phase weights) and start accumulating gradients over  minibatches at , experimenting both with  and . The models are trained with SGD using otherwise standard optimization settings. Both controls fail to improve (even match) the performance of the base model trained without any gradient accumulation.

\begin{table}
\centering
\caption{CIFAR-100 test set accuracy (\%) depending on different values of  for WRN 28-10 SGD with late-phase BatchNorm weights (LPBN). Mean  std.~over 5 seeds.\label{tab:sigma-sensitivity}}
\begin{tabular}{lllllll}
\toprule
& \multicolumn{2}{l}{CIFAR-100} &  \multicolumn{2}{l}{CIFAR-100} & \multicolumn{2}{l}{CIFAR-100} \\
& \multicolumn{2}{l}{(LPBN)}  &   \multicolumn{2}{l}{(LPBN, non-averaged)}  & \multicolumn{2}{l}{(LPBN, pretrained)} \\
\midrule
 & Test acc. (\%) & OOD&Test acc. (\%) & OOD&Test acc. (\%) & OOD \\\midrule
 & 82.87& 0.833 &83.20&0.854 & 81.70    &0.803   \\
  & 82.77& 0.836 &82.68 & 0.861& 82.02  &0.808  \\
  & 82.78 & 0.837 & 82.71& 0.862& 81.15 &0.797   \\
  &  82.41& 0.839&82.43 & 0.855& - &- \\
  &  81.52& 0.840 &82.38& 0.848&  - & - \\ \bottomrule  
\end{tabular}
\end{table}


\begin{wraptable}[18]{R}{0.45\textwidth}
\centering
\caption{CIFAR-10 and CIFAR-100 test set accuracy (\%) depending on different late phase timing  for WRN 28-10, SGD. Mean  std.~over 5 seeds.\label{tab:t0-sensitivity}}
\vspace{-0.2cm}
\begin{tabular}{lll}
\toprule
    & CIFAR-10 & CIFAR-100   \\\midrule
0 &  95.68  &  74.38\\
40 &  96.34 &   79.69    \\
60 &  96.42 & 80.53\\
80 &  96.50 & 81.72 \\
100 &  96.45 & 82.48 \\
120 &  96.48 & 82.87 \\
140 &  96.26 & 82.53 \\
160 &  96.23 & 81.41 \\
180 &  96.25 & 81.43 \\
200 &  96.16 & 81.35 \\\bottomrule  
\end{tabular}
\end{wraptable}

\begin{figure}
  \centering
  \begin{center}
    \includegraphics[width=0.6\textwidth]{pdf/cifar100_to_sens.pdf}
  \end{center}
   \vspace{-0.4cm}
  \captionof{figure}{Sensitivity analysis of . Mean AUROC score (OOD) and test set accuracy for different values of  for WRN  28-10, CIFAR-100, SGD, with BatchNorm  late-phase weights.\label{fig:T0-sensitivity}}
\end{figure}

\paragraph{Sensitivity to ,  and .} We present a hyperparameter exploration on the CIFAR-100 dataset using BatchNorm late-phase weights in Tables  \ref{tab:k-sensitivity}, \ref{tab:sigma-sensitivity} and \ref{tab:t0-sensitivity}. We find that our algorithm is largely robust to  when  can be set to its optimal value, which is at 60\% of training. See also Figure \ref{fig:T0-sensitivity} for a visualisation of the same data, specifically the change in mean AUROC score and test set accuracy when changing . This result holds also on CIFAR-10, cf.~Table~\ref{tab:t0-sensitivity}. When starting from a pretrained condition (), finite  leads to a significant improvement in performance, cf.~Table~\ref{tab:sigma-sensitivity}. We therefore report results obtained with  for every CIFAR and ImageNet experiment in the main text. The exception to this is the non-averaged (ensemble) late-phase BatchNorm model presented in Table~\ref{tab:ood}, which was optimized for best OOD performance (corresponding to ).


\begin{table}[h!]
\centering
\caption{Performance of a WRN 28-10 on CIFAR-100 with different dropout probability . For MC-dropout we average over 10 different samples.  Mean  std.~over 5 seeds. \label{tab:dropout}}
\vspace{-0.2cm}
\begin{tabular}{lllll}
\toprule
   &  & Test acc. (\%) & Test NLL & OOD \\\midrule
Dropout & 0.1 &    81.46       &0.7476&      0.8031    \\
Dropout & 0.2 &    81.31       &0.7736&      0.8022    \\
Dropout & 0.3 &    80.93       &0.8342&      	0.7833    \\\midrule

MC-Dropout & 0.1 &  81.51     &0.7197&      0.8149    \\
MC-Dropout & 0.2  &    81.55       &0.7105&      0.8225    \\
MC-Dropout & 0.3 &  81.36  &0.7150&      0.8040    \\\bottomrule  
\end{tabular}
\end{table}

\paragraph{Related work.} Here we provide details for the training setups of alternative methods we compare against in the main text. For the results reported for dropout \citep{srivastava_dropout_2014} and MC-dropout \citep{gal_dropout_2016}, we simply train a WRN 28-10 on CIFAR-100 with the exact same configuration as for our base model, see above, but include dropout layers as usually done \citep{zagoruyko_wide_2016} after the first convolution in each residual block.
For a scan over the dropout probability  in this setup, see Table~\ref{tab:dropout}.  is reported in the main text - for CIFAR-100 and CIFAR-10. Note that  was only tuned for CIFAR-100. 

For the reported results of BatchEnsemble \citep{wen_batchensemble_2020}, we simply execute the code provided by the authors at \url{https://github.com/google/uncertainty-baselines} with their fine-tuned configuration for CIFAR-10/100.
Notably, the authors use a different setup than followed in this manuscript. First, the WRN 28-10 is trained for 250 epochs (we allow for this increased budget exceptionally for BatchEnsemble), with a multi-step learning rate annealing at  with a learning rate decay factor of . Second, a weight decay of  is used.

\begin{table}
\centering
\caption{Final training set loss on CIFAR datasets, WRN 28-10, SGD.  Mean  std.~over 5 seeds.\label{tab:training-loss}}
\begin{tabular}{ll}
\toprule
    & Training loss \\\midrule
CIFAR-10 -- base &  0.0010     \\
CIFAR-10 -- late-phase BatchNorm  & 0.0019  \\\midrule  
CIFAR-100 -- base &  0.0024     \\
CIFAR-100 -- late-phase BatchNorm  & 0.0267  \\\bottomrule  
\end{tabular}
\end{table}

For the results reported for SWAG \citep{maddox_simple_2019}, we use the code provided by the authors at \url{https://github.com/wjmaddox/swa_gaussian}, and the proposed fine-tuned configuration which coincides with the configuration used to
obtain all CIFAR-100 results reported in this manuscript, except for BatchEnsembles (see above). We report results for SWAG after training on 200 epochs for fair comparison.

\paragraph{Training losses.} We provide the final achieved training losses for the base model and when augmenting it with BatchNorm late-phase weights on Table~\ref{tab:training-loss}, for both CIFAR-10 and CIFAR-100. Using a fast gradient accumulation scale factor of  leads to a higher training loss on CIFAR-100 than that of the standard model, but we found this setting crucial to achieve the largest improvement on test set generalization.



\paragraph{CIFAR-10 with a reduced training set.} Here we evaluate the performance of our method on a reduced training set of CIFAR-10. We randomly pick 10000 training data out of the 50000 available, and use this new set to train different models. After training, the models are evaluated on the standard CIFAR-10 test set. Results are shown in Table~\ref{tab:reduced-c10}. 


\begin{table}
\centering
\caption{Performance of models trained on a reduced CIFAR-10 training set and evaluated on the full CIFAR-10 test set.  Mean  std.~over 5 seeds. \label{tab:reduced-c10}}
\vspace{-0.2cm}
\begin{tabular}{ll}
\toprule
Model & Test acc. (\%) \\\midrule
Base (SGD)      &    88.98  \\
Late-phase BN (SGD)   & 89.58 \\\bottomrule  
\end{tabular}
\end{table}

\paragraph{Detailed OOD results and mean corruption error (mCE) experiments.}
In order to test the robustness of late-phase weights against input data corruption, we used the  corruptions and dataset proposed by \citet{hendrycks_benchmarking_2019}, freely available at \url{https://github.com/hendrycks/robustness}. The authors propose 15 noise sources such as random Gaussian noise, spatter or contrast changes to deform the input data and report the model test set accuracy on the corrupted dataset under 5 severity levels (noise strengths). For each source noise, its corruption error is computed by averaging the prediction error over the severity levels. The average of the corruption error of all 15 noises gives us the Mean Corruption Error (mCE). See Table \ref{tab:ood_mce} for the mCE computed on the corrupted CIFAR-100 dataset.

\paragraph{Training run time.} Here we compare the training run time of our method with the baseline. The result was computed in Python 3.7, using the automatic differentiation and GPU acceleration package PyTorch (version 1.4.0). We used the standard datasets (including training and test splits) as provided by the torchvision package unless stated otherwise. We used a single NVIDIA GeForce 2080 Ti GPU for the experiment. Results are presented in Table~\ref{tab:runtime}.


\setlength\intextsep{5pt}
\begin{table}
\centering
\caption{OOD performance measured by the AUROC, and robustness measured by the Mean Corruption Error (\emph{mCE}). We train the models on CIFAR-100 and attempt to discriminate test set images from novel ones drawn from the SVHN, LSUN, Tiny ImageNet (\emph{TIN}) and CIFAR-10 dataset. The mCE value is the average across 75 different corruptions from the CIFAR-100-C dataset. LPBN and LP HNET stand respectively for late-phase BatchNorm and late-phase hypernetwork. \label{tab:c100-detailed-ood}}
\label{tab:ood_mce}
\begin{tabular}{llllll}

\toprule
               & SVHN	& LSUN	& TIN	& CIFAR-10 & mCE \\\midrule
Base   &  0.814  &0.798   &0.776&0.818  & 47.84\\
LPBN     & 0.831  & 0.862  &0.838  &0.814  & 45.59       \\
LPBN (non-avg.)  &  0.877  &0.883  &0.863  &0.827  & 46.21     \\
LP HNET      &0.815 &   0.842  &0.816   &0.811  & 47.84   \\\midrule
Dropout (Mean)      & 0.792 &  0.807  &   0.788 &   0.822  & 48.97\\
MC-Dropout      & 0.806 &  0.842  &   0.817 &   0.824  & 48.09 \\

SWAG      &  0.824  &0.839  &0.835  &0.816  &  -  \\

BatchEnsemble     &  0.848  &0.828  &0.820  & 0.829  &  -     \\

\midrule
Deep ens. &  0.839  & 0.836  &0.812  &0.839  & 44.21 \\
Deep ens. (LPBN)  &  0.855  &0.884  &0.856  &0.834  &43.15 \\
\bottomrule       
\end{tabular}
\end{table}


\begin{table}
\centering
\caption{Training time in seconds and hours on CIFAR-10 for 200 epochs on a single NVIDIA GeForce 2080 Ti GPU. \label{tab:runtime}}
\vspace{-0.2cm}
\begin{tabular}{lll}
\toprule
Model & seconds & hours \\\midrule
Base (SGD)      &     17714  &      4.92 \\
Late-phase BN (SGD)   &  17772 &   4.94 \\\bottomrule  
\end{tabular}
\end{table}




\section{Theoretical analysis of the noisy quadratic problem}
\label{apx:NQP}
In this section, we consider a noisy quadratic problem (NQP) that can be theoretically analyzed and that captures important characteristics of the stochasticity of a minibatch-based optimizer \citep{schaul_no_2013, martens_second-order_2016, wu_understanding_2018, zhang_which_2019, zhang_lookahead_2019}. 
The NQP does a second-order Taylor expansion of the loss function around the optimum  and models the minibatch noise as a random translation  of the optimum, while keeping the curvature  the same. This gives us the following minibatch loss:

with  and  the minibatch size. Note that we use boldface notation for vectors in this analysis for notational clarity. The NQP can be seen as an approximation of the loss function in the final phase of learning, where we initialize the late-phase ensemble. Despite its apparent simplicity, it remains a challenging optimization problem that has important similarities with stochastic mini-batch training in deep neural networks \citep{schaul_no_2013, martens_second-order_2016, wu_understanding_2018, zhang_which_2019, zhang_lookahead_2019}. For the simple loss landscape of the NQP, there are three main strategies to improve the expected loss after convergence: (i) increase the mini-batch size  \citep{zhang_which_2019}, (ii) use more members  in an ensemble (c.f.~Section \ref{sec:NQP_full_ensembles} and (iii) decrease the learning rate  \citep{schaul_no_2013, martens_second-order_2016, wu_understanding_2018, zhang_which_2019, zhang_lookahead_2019}. The late-phase weights training combines the two first strategies in a non-trivial manner by (i) averaging over the base-weights gradients for all ensemble members and (ii) averaging the late-phase weights in parameter space to obtain a mean-model. The goal of this theoretical analysis is to show that the expected loss after convergence scales inversely with the number of late-phase ensemble members , which indicates that the non-trivial combination of the two strategies is successful.

To model the multiplicative weight interaction between late-phase weights and base weights, we use linear hypernetworks of arbitrary dimension. The linear hypernetworks parameterize the weights as , with  the hypernetwork parameters and  the embedding vector. The embedding vectors  are used as late-phase weights ( in the main manuscript) to create a late-phase ensemble with  members, while using a shared hypernetwork  as base-weights: . Ultimately, we are interested in the expected risk of the the mean model at steady state: 

with  and  the steady-state distribution of the parameters. Note that we cannot put  without loss of generality, because the overparameterization of the hypernetworks makes the optimization problem nonlinear.

We start with investigating the discrete time dynamics induced by late-phase learning, after which we derive the corresponding continuous time dynamics to be able to use the rich stochastic dynamical systems literature for analyzing the resulting nonlinear stochastic dynamical system.

\subsection{Discrete Time Dynamics}
As we want to investigate the multiplicative interaction between the shared and late-phase parameters, we substitute  into \eqref{eq:noisy_loss_weightspace}, instead of computing a new Taylor approximation in the hypernetwork parameter space. Let us take  as the index for the outer loop (updating ) and  the index for the ensemble member. Then we have the following stochastic minibatch loss:

which gives rise to the following parameter updates using late-phase learning with learning rate  and minibatch size :

The above discrete time dynamics are nonlinear, giving rise to a non-Gaussian parameter distribution . Hence, it is not possible to characterize these dynamics by the moment-propagating equations of the first and second moment as done in \citet{zhang_which_2019, zhang_lookahead_2019, schaul_no_2013} and \citet{wu_understanding_2018}, without having full access of the parameter distribution . Furthermore, because of the hypernetwork parameterization, we cannot decouple the system of equations, even if  and  are diagonal, which is a common approach in the literature. Therefore, we investigate the corresponding continuous time dynamics, such that we can use the rich literature on stochastic dynamical systems.

\subsection{Continuous Time Dynamics} \label{sec:continuous_time_dynamics}
First, let us define some compact notations for the various parameters.

where  concatenates the columns of  in a vector. Then the discrete time dynamics (\eqref{eq:theta_discrete_time_dynamics} and \eqref{eq:embedding_discrete_time_dynamics}) can be rewritten as: 

with 

with  the Kronecker product,  an identity matrix of the appropriate size and  a vector full of ones of the appropriate size. As a linear transformation of Gaussian variables remains a Gaussian variable, we can rewrite eq. \eqref{eq:compact_discrete_dynamics} as follows:

with  and . Following \cite{liu_deep_2019} and \cite{chaudhari_stochastic_2018}, the corresponding continuous-time dynamics are:

with  Brownian motion and  the inverse temperature. 
Note that  is incorporated in the noise covariance, such that the correct limit to stochastic continuous time dynamics can be made (\citealp{liu_deep_2019, chaudhari_stochastic_2018}; but see \citealp{yaida_fluctuation-dissipation_2018}). 
For computing the expected loss  of the mean model, we need to have the stochastic dynamics of this loss. Using the Itô lemma \citep{ito_stochastic_1951, liu_deep_2019}, which is an extension of the chain rule in the ordinary calculus to the stochastic setting, we get

with  for notational simplicity and  the Hessian of  w.r.t. . As we are interested in the expected risk (\eqref{eq:risk_meanmodel}), we can take the expectation of \eqref{eq:loss_dynamics} over the parameter distribution  to get the dynamics of the first moment of the loss (also known as the backward Kolmogorov equation \citep{kolmogorov_analytical_1931}): 

In order to obtain the dynamics of the parameter distribution, the Fokker-Planck equation can be used \citep{jordan_variational_1998}. However, due to the nonlinear nature of the stochastic dynamical system, the distribution is non-Gaussian and it is not possible (to our best knowledge) to obtain an analytical solution for \eqref{eq:kolmogorov_loss}. Nevertheless, we can still gain important insights by investigating the steady-state of \eqref{eq:kolmogorov_loss}. After convergence, the left-hand side (LHS) is expected to be zero. Hence, we have that 

The remainder of our arguments is structured as follows. First, we will show that the left-hand-side (LHS) of \eqref{eq:ss_kolmogorov_loss} is the expectation of an approximation of a weighted norm of the gradient , after which we will connect this norm to the loss  of the mean model. Second, we will investigate the RHS to show that the late-phase learning with ensembles lowers the expected risk of the NQP at steady-state. For clarity and ease of notation, we will drop the  subscripts. The gradient of the mean-model loss is given by: 

By introducing  and using that , we can rewrite  as: 

with  and . We see that  is an approximation of the gradient  where the lower block of  is scaled by . Importantly, the lower block of the second element of the RHS of \eqref{eq:F_rewritten} (the approximation error) will disappear when taking the inner product with  and the upper block is not influenced by the number of ensemble members , which we will need later. The LHS of \eqref{eq:ss_kolmogorov_loss} can now be rewritten as:

with  the diagonal matrix of \eqref{eq:F_rewritten} (first element of the RHS). The first term of the RHS of \eqref{eq:LHS_kolmogorov} is the expectation of a weighted squared norm of , while the second term is an approximation error due to the covariance of . Hence, we see that the LHS of \eqref{eq:ss_kolmogorov_loss} can be seen as an approximation of a weighted norm of the gradient . By investigating the term  further, we show that it is closely connected to the loss .

When comparing to the mean-model loss  we see that the two are tightly connected, both using a weighted distance measure between  and  , with only a different weighting. Taken everything together, we see that we can take the LHS of \eqref{eq:ss_kolmogorov_loss} (and hence also the RHS) as a rough proxy for the expected risk under the steady-state distribution (\eqref{eq:risk_meanmodel}), which will be important to investigate the influence of the amount of ensemble members on the expected risk. \citet{zhu_anisotropic_2018} highlighted this trace quantitiy in \eqref{eq:ss_kolmogorov_loss} as a measurement of the escaping efficiency out of poor minima. However, we assume that we are in the final valley of convergence (emphasized by this convex NQP), so now this interpretation does not hold and the quantity should be considered as a proxy measurement of the width of the steady-state parameter distribution around the minimum. The trace quantity has  and  as main elements, which we structure in block matrices below (for clarity and ease of notation, we drop the subscripts ).



with  a matrix or vector of the appropriate size full of ones,  and the rows of  given by:

with  the -th column of an appropriately sized identity matrix.
After some intermediate calculations and rearranging of terms, we reach the following expression for the RHS of \eqref{eq:ss_kolmogorov_loss}:

with 
Note that everything between the big brackets in the RHS is independent of  in expectation. Hence, we see that the RHS of \eqref{eq:ss_kolmogorov_loss} scales inversely by , exactly as the case for full ensembles (see Section \ref{sec:NQP_full_ensembles}). Importantly, the approximation errors in \eqref{eq:F_rewritten} are independent of , hence, the found scaling of  in \eqref{eq:trace_solution} translates to a scaling of  of the expected risk of the NQP, following the above argumentation. Hence, we see that the non-trivial combination of (i) averaging over the base-weights gradients for all ensemble members and (ii) averaging the late-phase weights  in parameter space to obtain a mean-model, succeeds in scaling the expected loss after convergence inversely by .


\subsection{NQP with full ensembles}\label{sec:NQP_full_ensembles}
As a comparison for the above theoretical results, we also analyze the NQP that uses an ensemble of  full weight configurations  to get a mean model , instead of shared weights  and ensemble-member-specific weights . For the case of linear models, the averaging in weight space to obtain a mean model is equivalent to the averaging of the predictions over the ensemble, which is conventionally done using ensembles. Without loss of generality, we can take  (corresponding with a simple reparameterization of ). Using \eqref{eq:noisy_loss_weightspace}, this results in the following parameter updates for the ensemble members:

The mean model  has the following corresponding discrete dynamics: 

\paragraph{Exact moment propagating equations.}
As this is a discrete linear system with Gaussian noise, the resulting parameter distributions will also be linear and can be fully characterized by the mean and covariance of the parameters. Taking the expectation and variance of \eqref{eq:full_ensemble_updates} results in: 

with  the covariance matrix of . For an appropriate , the above equations converge to the following fixed points at steady-state: 

We see that the steady-state covariance of  and hence of the risk  scales with  (). The expected risk  obtained with computationally expensive full ensembles can be seen as a lower limit that we try to reach with the \textit{economical} ensembles of shared weights  and late-phase weights . Note that for the NQP, increasing the batchsize  has a similar influence as increasing the number of ensemble members , as can be seen in \eqref{eq:full_ensemble_covariance_ss}. 

\paragraph{Continuous time stochastic dynamics.} We can also do a similar continuous time analysis as Section \ref{sec:continuous_time_dynamics} for the case of full ensembles, to better relate it to the results of the late-phase learning with shared parameters. Following the same approach, we get the following expression for the trace term: 

When comparing to \eqref{eq:trace_solution}, we see that the economical ensembles with shared parameters reach the same scaling with  as a result of ensembling, however, some extra terms that vanish asymptotically for big  appear as a result of the interplay between shared and late-phase parameters. 

\paragraph{Experimental details for Fig.~\ref{fig:NQP-main-results}.} We take the model  (i.e., ) as our baseline, since this overparameterization could already result in accelerated learning \citep{arora_optimization_2018}. Our parameters are randomly initialized and scaled such that  has a fixed distance to  of 1. Since the NQP mimics a late phase of learning we set . We study a problem of dimension  and train the model with gradient descent (without momentum).

To validate the theoretical results, we show in Fig.~\ref{fig:NQP-main-results} that
the steady-state reached by our method scales inversely with , similarly to an ensemble of independently-trained models. We run experiments with  and train every configuration for  iterations until convergence. We average over the last  weight updates and over  different random seeds.

\end{document}