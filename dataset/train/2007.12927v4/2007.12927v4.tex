
\documentclass{article} \usepackage{iclr2021_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\usepackage{caption}
\usepackage{graphicx}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{amsmath}
\usepackage[inline]{enumitem}
\usepackage{xcolor}
\usepackage{amssymb}
\usepackage{bbm}
\usepackage{booktabs}
\usepackage{wrapfig}

\SetKwInput{KwRequire}{Require}

\hypersetup{hidelinks}

\title{Neural networks with late-phase weights}





\author{Johannes von Oswald*, Seijin Kobayashi*, Alexander Meulemans,\\
\textbf{Christian Henning, Benjamin F.~Grewe, Jo達o Sacramento}\\
\vspace{0.5cm}
* -- equal contribution\\
Institute of Neuroinformatics\\
University of Z端rich and ETH Z端rich\\
Z端rich, Switzerland\\
\texttt{\{voswaldj,seijink,ameulema,henningc,bgrewe,rjoao\}@ethz.ch}}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
The largely successful method of training neural networks is to learn their weights using some variant of stochastic gradient descent (SGD). Here, we show that the solutions found by SGD can be further improved by ensembling a subset of the weights in late stages of learning. At the end of learning, we obtain back a single model by taking a spatial average in weight space. To avoid incurring increased computational costs, we investigate a family of low-dimensional late-phase weight models which interact multiplicatively with the remaining parameters. Our results show that augmenting standard models with late-phase weights improves generalization in established benchmarks such as CIFAR-10/100, ImageNet and \texttt{enwik8}. These findings are complemented with a theoretical analysis of a noisy quadratic problem which provides a simplified picture of the late phases of neural network learning.
\end{abstract}

\section{Introduction}

Neural networks trained with SGD generalize remarkably well on a wide range of problems. A classic technique to further improve generalization is to ensemble many such models \citep{lakshminarayanan_simple_2017}. At test time, the predictions made by each model are combined, usually through a simple average. Although largely successful, this technique is costly both during learning and inference. This has prompted the development of ensembling methods with reduced complexity, for example by collecting models along an optimization path generated by SGD \citep{huang_snapshot_2017}, by performing interpolations in weight space \citep{garipov_loss_2018}, or by tying a subset of the weights over the ensemble \citep{lee_why_2015,wen_batchensemble_2020}.

An alternative line of work explores the use of ensembles to guide the optimization of a single model \citep{zhang_deep_2015,pittorino_entropic_2020}. We join these efforts and develop a method that fine-tunes the behavior of SGD using late-phase weights: late in training, we replicate a subset of the weights of a neural network and randomly initialize them in a small neighborhood. Together with the stochasticity inherent to SGD, this initialization encourages the late-phase weights to explore the loss landscape. As the late-phase weights explore, the shared weights accumulate gradients. After training we collapse this implicit ensemble into a single model by averaging in weight space.

Building upon recent work on ensembles with shared parameters \citep{wen_batchensemble_2020} we explore a family of late-phase weight models involving multiplicative interactions \citep{jayakumar_multiplicative_2020}. We focus on low-dimensional late-phase models that can be ensembled with negligible overhead. Our experiments reveal that replicating the ubiquitous batch normalization layers \citep{ioffe_batch_2015} is a surprisingly simple and effective strategy for improving generalization\footnote{We provide code to reproduce our experiments at \url{https://github.com/seijin-kobayashi/late-phase-weights}}. Furthermore, we find that late-phase weights can be combined with stochastic weight averaging \citep[][]{izmailov_averaging_2018}, a complementary method that has been shown to greatly improve generalization.

\section{Methods and models}

\subsection{Learning with late-phase weights}
\paragraph{Late-phase weights.} To apply our learning algorithm to a given neural network model $f_w$ we first specify its weights $w$ in terms of two components, base and late-phase ($\theta$ and $\phi$, resp.). The two components interact according to a weight interaction function $w = h(\theta, \phi)$. Base weights are learned throughout the entire training session, and until time step $T_0$ both $\theta$ and $\phi$ are learned and treated on equal grounds. At time step $T_0$, a hyperparameter of our algorithm, we introduce $K$ late-phase components $\Phi=\{\phi_k\}_{k=1}^{K}$, that are learned together with $\theta$ until the end.

This procedure yields a late-phase ensemble of $K$ neural networks with parameter sharing: reusing the base weights $\theta$, each late-phase weight $\phi_k$ defines a model with parameters $w_k = h(\theta, \phi_k)$.

\paragraph{Late-phase weight averaging at test time.} Our ensemble defined by the $K$ late-phase weight configurations in $\Phi$ is kept only during learning. At test time, we discard the ensemble and obtain a \emph{single} model by averaging over the $K$ late-phase weight components. That is, given some input pattern $x$, we generate a prediction $\overline{y}(x)$ using the averaged model, computed once after learning:
\begin{equation}
\label{eq:test-time-averaging}
  \overline{y}(x) = f_{\overline{w}}(x), \qquad \overline{w} \equiv h\left(\theta, \frac{1}{K} \sum_{k=1}^K \phi_k\right).
\end{equation}

Hence, the complexity of inference is independent of $K$, and equivalent to that of the original model.

\paragraph{Late-phase weight initialization.} We initialize our late-phase weights from a reference base weight. We first learn a base parameter $\phi_0$ from time step $t=0$ until $T_0$, treating $\phi_0$ as any other base parameter in $\theta$. Then, at time $t=T_0$, each configuration $\phi_k$ is initialized in the vicinity of $\phi_0$. We explore perturbing $\phi_0$ using a symmetric Gaussian noise model,
\begin{equation}
\label{eq:ensemble-init}
    \phi_k = \phi_0 +  \frac{\sigma_0}{Z(\phi_0)} \, \epsilon_k,
\end{equation}
where $\epsilon_k$ is a standard normal variate of appropriate dimension and $\sigma_0$ is a hyperparameter controlling the noise amplitude. We allow for a $\phi_0$-dependent normalization factor, which we set so as to ensure layerwise scale-invariance, which helps finding a single $\sigma_0$ that governs the initialization of the entire network. More concretely, for a given neural network layer $l$ with weights $\phi_0^{(l)}$ of dimension $D^{(l)}$, we choose $Z(\phi_0^{(l)}) = \sqrt{D^{(l)}} / \| \phi_0^{(l)} \|$.

Our perturbative initialization (Eq.~\ref{eq:ensemble-init}) is motivated by ongoing studies of the nonconvex, high-dimensional loss functions that arise in deep learning. Empirical results and theoretical analyses of simplified models point to the existence of dense clusters of connected solutions with a locally-flat geometry \citep{hochreiter_flat_1997} that are accessible by SGD \citep{huang_snapshot_2017,garipov_loss_2018,baldassi_shaping_2020}. Indeed, the eigenspectrum of the loss Hessian evaluated at weight configurations found by SGD reveals a large number of directions of low curvature \citep{keskar_large-batch_2017,chaudhari_entropy-sgd_2019,sagun_empirical_2018}. For not yet completely understood reasons, this appears to be a recurring phenomenon in overparameterized nonlinear problems \citep[][]{brown_statistical_2003,waterfall_sloppy-model_2006}.

Based on these observations, we assume that the initial parameter configuration $\phi_0$ can be perturbed in a late phase of learning without leading to mode hopping across the different models $w_k$. While mode coverage is usually a sought after property when learning neural network ensembles \citep{fort_deep_2020}, here it would preclude us from taking the averaged model at the end of learning (Eq.~\ref{eq:test-time-averaging}).



\paragraph{Stochastic learning algorithm.} Having decomposed our weights into base and late-phase components, we now present a stochastic algorithm which learns both $\theta$ and $\Phi$. Our algorithm works on the standard stochastic (minibatch) neural network optimization setting \citep{bottou_large-scale_2010}. Given a loss function $\mathcal{L}(\mathcal{D}, w)=\frac{1}{|\mathcal{D}|} \, \sum_{x \in \mathcal{D}}L(x, w)$ to be minimized with respect to the weights $w$ on a set of data $\mathcal{D}$, at every round we randomly sample a subset $\mathcal{M}$ from $\mathcal{D}$ and optimize instead the stochastic loss $\mathcal{L}(\mathcal{M},w)$. However, in contrast to the standard setting, in late stages of learning ($t>T_0$) we simultaneously optimize $K$ parameterizations $\mathcal{W} := \{w_k \mid w_k = h(\theta, \phi_k)\}_{k=1}^K$, instead of one.

We proceed by iteration over $\mathcal{W}$. At each step $k$, we sample a minibatch $\mathcal{M}_k$ and immediately update the late-phase weights $\phi_k$, while accumulating gradients over the shared base weights $\theta$. Such gradient accumulation has been previously used when learning ensembles \citep{lee_why_2015,wen_batchensemble_2020} and multi-task models \citep{rebuffi_learning_2017} with shared base parameters. A single iteration is finally concluded by changing the base weights in the direction opposite of the accumulated gradient. We scale the accumulated gradient by $\gamma_\theta$; setting $\gamma_\theta = 1/K$ recovers the original step size in $\theta$, but other choices are possible. In particular, we find that a large $\gamma_\theta$ of unit size is in practice often tolerated, resulting in accelerated learning.

\setlength\intextsep{0pt}
\begin{wrapfigure}{r}{0.43\textwidth}
    \begin{minipage}{0.43\textwidth}
    \begin{algorithm}[H]
      \KwRequire{Base weights $\theta$,\\late-phase weight set $\Phi$, dataset $\mathcal{D}$, gradient scale factor $\gamma_\theta$, loss $\mathcal{L}$}
      \KwRequire{Training iteration $t > T_0$}
      
      \For{$1 \le k \le K$}{
       $\mathcal{M}_k \gets$ Sample minibatch from $\mathcal{D}$
    
       $\Delta \theta_k \gets \nabla_\theta \, \mathcal{L}(\mathcal{M}_k, \theta, \phi_k)$
       
       $\phi_k \gets U_{\phi}(\phi_k, \nabla_{\phi_k} \, \mathcal{L}(\mathcal{M}_k, \theta, \phi_k))$
       
      }

      $\theta \gets U_\theta(\theta, \gamma_\theta \sum_{k=1}^K \Delta \theta_k)$
      \caption{Late-phase learning\label{alg:learning}}
     \end{algorithm}
    \end{minipage}
\end{wrapfigure}
We summarize an iteration of our method in Algorithm~\ref{alg:learning}, where the loss $\mathcal{L}(\mathcal{M}, \theta, \phi)$ is now seen as a function of $\theta$ and $\phi$. We opt for a general presentation using unspecified gradient-based update operators $U_\phi$ and $U_\theta$. These operators can be set to optimizers of choice. For instance, our method might benefit from additional noise injection onto parameter updates \citep{welling_bayesian_2011}. Furthermore, late-phase optimizers need not coincide with the optimizer used in the early phase. In our work we typically set $U_{\phi}$ and $U_\theta$ to a single step of SGD with Nesterov momentum \citep{nesterov_introductory_2004}, and explore Adam \citep{kingma_adam:_2015} and plain SGD in a smaller set of experiments.



\subsection{Late-phase weight models}
\label{section:late-phase-models}
As detailed next, we consider a number of distinct late-phase weight models in our experiments. In particular, we explore weight interaction functions $h$ in which late-phase weights have low dimensionality, to avoid a large increase in complexity with the ensemble size $K$. To counteract this reduced dimensionality, we make extensive use of multiplicative base-late weight interactions. This design choice is motivated by the large expressive power of multiplicative interactions despite low dimensionality, which has been demonstrated in a wide range of settings \citep{jayakumar_multiplicative_2020}.

\paragraph{Late-phase batch normalization layers.} Batch normalization layers \citep[BatchNorm;][]{ioffe_batch_2015} are a staple of current deep neural network models. Besides standardizing the activity of the layer they are applied to, BatchNorm units introduce a learnable multiplicative (scale) parameter $\gamma$ and an additive (shift) parameter $\beta$. While being low-dimensional, these additional parameters have large expressive power: it has been shown that learning only $\gamma$ and $\beta$ keeping the remaining weights frozen can lead to significantly lower loss than when learning random subsets of other weights of matching dimensionality \citep[][]{frankle_training_2020,mudrakarta_k_2019}.


We take the scale and shift parameters of BatchNorm layers as our first choice of late-phase weights; the base weights are the remaining parameters of the model. Batch statistics are also individually estimated for each model in $\mathcal{W}$. This late-phase weight parameterization is motivated by
\begin{enumerate*}[label=(\itshape\roman*)]
  \item the expressive power of $\gamma$ and $\beta$ discussed above, and by
  \item practical considerations, as BatchNorm layers are generally already present in feedforward neural network models, and are otherwise easy to implement efficiently.
\end{enumerate*}

More concretely, let us consider an affine transformation layer $l$ which maps an input vector $r^{(l-1)}$ to $\theta_w^{(l)} \, r^{(l-1)} + \theta_b^{(l)}$, where the early-phase weight matrix $\theta_w^{(l)}$ and bias vector $\theta_b^{(l)}$ are already standardized using the respective batch statistics. For this standard layer, our model introduces a multiplicative interaction between base and late-phase weights, $\text{diag}(\gamma^{(l)}) \, \theta_w^{(l)}$, and an additive interaction between base and late-phase bias parameters, $\theta_b^{(l)} + \beta^{(l)}$.

\paragraph{Late-phase rank-1 matrix weights.} We also study a closely related late-phase weight model, where existing weight matrices -- the base components, as before -- are multiplied elementwise by rank-1 matrices \citep[][]{wen_batchensemble_2020}. For a given affine layer $l$, we define a late-phase weight matrix with resort to a pair of learnable vectors, $\phi^{(l)} = u^{(l)} \, {v^{(l)}}^T$. Taking the Hadamard product with the base weight matrix yields the effective weights $W^{(l)} = \phi^{(l)} \, \circ \, \theta^{(l)}$.

With this parameterization, we recover the ensemble proposed by \citet{wen_batchensemble_2020}, except that here it is generated late in training using our perturbative initialization (Eq.~\ref{eq:ensemble-init}). Unlike BatchNorm layers, which include the shift parameter, rank-1 late-phase weights interact in a purely multiplicative manner with base weights. We study this model since it is easy to implement on neural networks which do not feature BatchNorm layers, such as standard long short-term memories \citep[LSTMs;][]{hochreiter_long_1997}.

\paragraph{Hypernetworks with late-phase weight embeddings.} Additionally, we generalize the late-phase weight models described above using hypernetworks \citep[][]{ha_hypernetworks_2017}. A hypernetwork generates the parameters $w$ of a given target neural network $f_w$ based on a weight embedding. In our framework, we can use a hypernetwork to implement the interaction function $w = h(\theta, \phi)$ directly, with parameters $\theta$ corresponding to base weights and embeddings $\phi$ to late-phase weights.

We experiment with linear hypernetworks and use the same hypernetwork to produce the weights of multiple layers, following \citet{savarese_learning_2019,ha_hypernetworks_2017,von_oswald_continual_2020}. In this scheme, the weight embedding input specifies the target layer whose parameters are being generated.  More specifically, the weight matrix for some layer $l$ belonging to a group of layers $g$ which share a hypernetwork is given by $W^{(g,l)} = \theta^{(g)} \, \phi^{(g,l)}$, where $\theta^{(g)}$ and $\phi^{(g,l)}$ are appropriately-sized tensors. Sharing $\theta^{(g)}$ over a layer group $g$ allows countering an increase in the overall number of parameters. We parameterize our hypernetworks such that the weight embedding vectors  $\phi^{(g,l)}$ are small, and therefore cheap to ensemble.

\paragraph{Late-phase classification layers.} Finally, inspired by \citet{lee_why_2015}, in classification experiments we take the weights of the last linear layer as late-phase weights by default. In modern neural network architectures these layers do not usually comprise large numbers of parameters, and our architecture explorations indicated that it is typically beneficial to ensemble them. We therefore include $W^{(L)}$ in our late-phase weights $\phi$, where $W^{(L)}$ denotes the weights of the final layer $L$.

\section{Results}

\subsection{Noisy quadratic problem analysis}
Before turning to real-world learning problems, we first focus on a simplified stochastic optimization setup which can be analytically studied. We consider the noisy quadratic problem \citep[NQP;][]{schaul_no_2013,martens_second-order_2016,wu_understanding_2018,zhang_which_2019,zhang_lookahead_2019}, where the goal is to minimize the scalar loss
\begin{equation}
\label{eq:NQP-definition}
    \mathcal{L} = \frac{1}{2}(w - w^* + \epsilon)^T \, H \, (w - w^* + \epsilon)
\end{equation}
with respect to $w \in \mathbb{R}^{n}$. In the equation above, $w^*$ denotes the target weight vector, which is randomly shifted by a noise variable $\epsilon$ assumed to follow a Gaussian distribution $\mathcal{N}(0, \Sigma)$. The (constant) Hessian matrix $H$ controls the curvature of the problem.

\begin{wrapfigure}[13]{r}{0.43\textwidth}
  \vspace{-10pt}
  \begin{center}
    \includegraphics[width=0.43\textwidth]{pdf/nqp_d.pdf}
  \end{center}
  \vspace{-15pt}
  \caption{Steady-state loss for varying $K$, of multiplicative late-phase weights (\emph{Ours}) compared to an ensemble of models. \label{fig:NQP-main-results}}
\end{wrapfigure}
Despite the simplicity of Eq.~\ref{eq:NQP-definition}, the NQP captures a surprising number of empirically-observed aspects of neural network learning \citep{zhang_which_2019}. Here, we motivate its study as a model of late stages of learning, by Taylor expanding the loss around a minimum $w^*$. Thus, for a sufficiently late initialization time $T_0$ (and small $\sigma_0$) the NQP is particularly well suited to study our algorithm.


There are three main strategies to improve the expected NQP loss after convergence:
\begin{enumerate*}[label=(\itshape\roman*)]
  \item increase the minibatch size $B$,
  \item use more members $K$ in an ensemble, and
  \item decrease the learning rate $\eta$ \citep{zhang_which_2019}.
\end{enumerate*}
Our Algorithm~\ref{alg:learning} combines the first two strategies in a non-trivial manner. First, the gradients for base weights $\theta$ are averaged during the inner loop over all ensemble members, corresponding to a minibatch-size rescaling by $K$. Second, we introduce $K$ ensemble members, to be averaged in weight space, that only differ in their late-phase weights $\phi$.


In Appendix \ref{apx:NQP}, we show analytically that this combination of an increased effective minibatch size for $\theta$ and introducing $K$ ensemble members for $\phi$ is successful, resulting in a scaling of the expected loss after convergence by $\frac{1}{K}$. This analysis holds for general $\Sigma$ and $H$, and for both scalar and hypernetwork multiplicative late-phase weights. Hence, our approach combines the benefits of an increased effective minibatch size and of ensembling, while yielding a single model after training.


We present a numerical validation of this theoretical result in Fig.~\ref{fig:NQP-main-results}. Our model includes a multiplicative late-phase weight, $w_k=\theta \, \phi_k $ with $\phi_k \in \mathbb{R}$ and $\theta \in \mathbb{R}^{n}$. We simulate a standard instance of the NQP, with diagonal Hessian $H_{ii}=1/i$ and $\Sigma=H^{-1}$ \citep[cf.][]{zhang_which_2019}, and report the average loss after convergence. Hyperparameters are given in Appendix~\ref{apx:NQP}. As predicted by the theory, the loss falls as $\sim 1/K$ with increasing ensemble size $K$, and our algorithm performs on par with a full ensemble of $K$ models trained independently with gradient descent.


\vspace{-0.15cm}
\subsection{CIFAR-10/100 experiments}
To test the applicability of our method to more realistic problems, we next augment standard neural network models with late-phase weights and examine their performance on the CIFAR-10 and CIFAR-100 image classification benchmarks \citep{krizhevsky_learning_2009}. We use standard data preprocessing methods (cf.~Appendix~\ref{apx:implementation}) and train our models for 200 epochs from random initializations, except when noted otherwise. All evaluated methods are trained using the same amount of data.

Besides SGD (with Nesterov momentum), we also investigate stochastic weight averaging \citep[SWA;][]{izmailov_averaging_2018}, a recent reincarnation of Polyak averaging \citep{polyak_acceleration_1992} that can strongly improve neural network generalization. For completeness, we present pseudocode for SWA in Algorithm ~\ref{alg:swa} and SGD with Nesterov momentum in Algorithm ~\ref{alg:nesterov} (cf.~Appendix~\ref{apx:implementation}). When learning neural networks with late-phase weights we set $U_\phi$ and $U_\theta$ to one step of SGD (or SGD wrapped inside SWA). 

We compare our method to dropout  \citep{srivastava_dropout_2014}, a popular regularization method that can improve generalization in neural networks. Like our approach, dropout produces a single model at the end of training. We also consider its Monte Carlo variant \citep[MC-dropout;][]{gal_dropout_2016}, and the recently proposed BatchEnsemble \citep{wen_batchensemble_2020}. This method generates an ensemble using rank-1 matrices as described in Section~\ref{section:late-phase-models}. Predictions still need to be averaged over multiple models, but this averaging step can be parallelized in modern hardware.

Additionally, we report single-seed results obtained with an ensemble of $K$ independently-trained models \citep[a deep ensemble,][]{lakshminarayanan_simple_2017}. Deep ensembles provide a strong baseline, at the expense of large computational and memory costs. Therefore, they are not directly comparable to the other methods considered here, and serve the purpose of an upper baseline.

\setlength\intextsep{0pt}
\begin{wraptable}[16]{r}{0.5\textwidth}
\caption{CIFAR-10, WRN 28-10. Mean $\pm$ std.~over 5 seeds. Late-phase BatchNorm (LPBN).}
  \label{tab:CIFAR-10}
\centering
  {\renewcommand{\arraystretch}{1.1}\setlength{\tabcolsep}{4pt}
  \begin{tabular}{@{}llllllll@{}} 
    \toprule
Model & Test acc. (\%) \\\midrule
Base (SGD)      &    96.16$^{\pm 0.12}$  \\
Dropout (SGD)   & 96.02$^{\pm 0.06}$ \\
MC-Dropout (SGD)   & 96.03$^{\pm 0.09}$ \\
BatchEnsemble (SGD)   & 96.19$^{\pm 0.18}$ \\
Late-phase (SGD)  & \textbf{96.46}$^{\pm 0.15}$    \\\midrule
Base (SWA)      &    96.48$^{\pm 0.04}$   \\
Late-phase (SWA) & \textbf{96.81}$^{\pm 0.07}$    \\
\midrule
Deep ensemble (SGD) &  96.91  \\
Deep ensemble (LPBN, SGD) &  \textbf{96.99}  \\\bottomrule
    \end{tabular}}
\end{wraptable}
By contrast, augmenting the architectures considered here with late-phase weights results in negligible additional costs during learning (with the exception of hypernetworks, which require additional tensor products) and none during testing. In principle, a set of independently-trained models yielded by our algorithm can therefore even be used as the basis of a deep ensemble, when the memory and compute budget allows for one. We present proof-of-concept experiments exploring this option.


Throughout our CIFAR-10/100 experiments we set $K=10$, use a fast base gradient scale factor of $\gamma_\theta=1$, and set our late-phase initialization hyperparameters to $T_0=120$ (measured henceforth in epochs; $T_0=100$ for SWA) and do not use initialization noise, $\sigma_0=0$. These hyperparameters were tuned manually once on CIFAR-100 and then kept fixed unless otherwise noted. We use standard learning rate scheduling, optimized for SGD and SWA on the base model (cf.~Appendices~\ref{apx:implementation} and \ref{apx:extra-expt}). Last-layer weights are included by default in our late-phase weight set $\Phi$.


\paragraph{CIFAR-10.} For CIFAR-10 we focus on the WRN architecture, a high-performance residual network \citep[WRN;][]{zagoruyko_wide_2016} which features BatchNorm layers. Taking advantage of this we implement a late-phase weight model consisting of BatchNorm shift and scale parameters.

All algorithms achieve a training error close to zero (cf.~Appendix~\ref{apx:extra-expt}). The resulting predictive accuracies are shown in Table~\ref{tab:CIFAR-10}. We find that augmenting the WRN 28-10 (a standard WRN configuration) with BatchNorm late-phase weights leads to a systematic improvement in generalization, reducing the gap with a deep ensemble of $K=10$ models. Initializing our ensemble from the onset ($T_0=0$) fails to meet the performance of the base model, reaching only $95.68 \pm 0.23$\% (cf.~Appendix~\ref{tab:t0-sensitivity}).

We also investigate initializing a late-phase (full) deep ensemble at $T_0=120$. This results in a test set accuracy of $96.32 \pm 0.09 \%$, in between late-phase BatchNorm weights and no late-phase weights at all. This speaks to the data-efficiency of our low-dimensional late-phase ensembles which can be trained with as little data as a single model, besides being memory efficient.



In addition, we consider a larger instance of the WRN model (the WRN 28-14), trained for 300 epochs using cutout data augmentation \citep[][]{devries_improved_2017}, as well as a small convolution neural network without skip connections, cf.~Table~\ref{tab:CIFAR-other-arch}. When late-phase weights are employed in combination with SWA, we observe significant accuracy gains on the WRN~28-14. Thus, our late-phase weights impose an implicit regularization that is effective on models with many weights. Similarly, we observe larger gains when training on a random subset of CIFAR-10 with only $10^4$ examples (cf.~Appendix~\ref{apx:extra-expt}).



\setlength\intextsep{10pt}
\begin{table}[h]
\centering
\caption{Mean CIFAR-100 test set accuracy (\%) $\pm$ std.~over 5 seeds, WRN 28-10. Different late-phase weight augmentations are compared to the base architecture and to an upper bound consisting of an ensemble of models. \emph{Deep ens.}~stands for deep ensemble, \emph{LPBN} for late-phase BatchNorm.\label{tab:CIFAR-100}}
\begin{tabular}{llllll}
\toprule
    & Base & BatchNorm & Hypernetwork &  Deep ens. & Deep ens.~(LPBN) \\\midrule
SGD &  81.35$^{\pm 0.16}$   & 82.87$^{\pm 0.22}$&   81.55$^{\pm 0.31}$ &                      84.09 & 84.69     \\
SWA &  82.46$^{\pm 0.09}$  & 83.06$^{\pm 0.08}$& 82.01$^{\pm 0.17}$   &   83.62 & -    \\\bottomrule  
\end{tabular}
\vspace{-0.4cm}
\end{table}
\paragraph{CIFAR-100.} We next turn to the CIFAR-100 dataset, which has 10-fold less examples per class and more room for improvements. We study the WRN~28-10, as well as the larger WRN~28-14 variant (using cutout data augmentation as before) and a PyramidNet \citep{han_deep_2017} with ShakeDrop regularization \citep{yamada_shakedrop_2019}. The latter are trained for 300 epochs.



Predictive accuracy is again highest for our neural networks with late-phase weights, trained with SGD or SWA, cf.~Table~\ref{tab:CIFAR-100}. We observe that the simplest BatchNorm late-phase weight model reaches the highest accuracy, with late-phase hypernetwork weight embeddings yielding essentially no improvements. Once again, the setting of $T_0=0$ (onset ensemble learning) fails to match base model performance, finishing at
$80.26\pm 0.42$\% test accuracy. As for CIFAR-10, a late-phase full deep ensemble only reached intermediate improvements, at $82.17\pm 0.15$\% test accuracy. Furthermore, a gap towards deep ensembles persists. This suggests that covering different modes of the loss \citep{fort_deep_2020} can provide benefits that cannot be captured by ensembling models in a small neighborhood.

\setlength\intextsep{0pt}
\begin{wraptable}[10]{R}{0.57\textwidth}
  \caption{Additional architectures, CIFAR-10 (C10) and CIFAR-100 (C100). Mean test set acc.~$\pm$ std.~over 3 seeds (\%). Late-phase BatchNorm weights.}
  \label{tab:CIFAR-other-arch}
 \vspace{-0.2cm}
\begin{tabular}{lll}
\toprule
           & Base & Late-phase \\\midrule
C10 ConvNet (SGD)      & 77.41$^{\pm 0.23}$   &  77.94$^{\pm 0.37}$      \\
C10 WRN 28-14 (SWA)  &     96.75$^{\pm 0.05}$     &  97.45$^{\pm 0.10}$ \\
C100 WRN 28-14 (SWA)  &     84.01$^{\pm 0.29}$     &  85.00$^{\pm 0.25}$ \\
C100 PyramidNet (SGD) &     84.04$^{\pm 0.28}$     &  84.35$^{\pm 0.14}$ \\
\bottomrule
\end{tabular}
\end{wraptable}
The final averaged solutions found with late-phase weights are strong base models to build a deep ensemble of independently-trained networks. The fact that our algorithm yields a single model allows further pushing the upper bound of what can be achieved when unrestricted full ensemble training is possible. This improvement comes at no cost compared to a standard deep ensemble.




We train additional neural network architectures restricting our experiments to the BatchNorm late-phase weight model, which can be readily implemented without architectural modifications. Again, learning with late-phase weights yields a consistent improvement over the baseline, cf.~Table~\ref{tab:CIFAR-other-arch}. 

\begin{wrapfigure}[14]{R}{0.4\textwidth}
\begin{center}
    \includegraphics[width=0.4\textwidth]{pdf/const-crop.pdf}
  \end{center}
  \vspace{-10pt}
  \captionof{figure}{WRN  28-10, CIFAR-100, constant learning rate SWA (activated at epoch 150). With BatchNorm  late-phase weights ($K$=10, initialized at epoch 120) and without ($K$=1). Mean  test  acc.~(\%) $\pm$ std.~over 5 seeds. \label{fig:constant-LR-results}}
\end{wrapfigure}
Notably, SWA can achieve high predictive accuracy with a large constant learning rate  \citep{izmailov_averaging_2018}. We reproduce these previous results and show that they improve when learning with late-phase weights, cf.~Fig.~\ref{fig:constant-LR-results}. Substantial progress is made both when entering the late-phase learning period and when activating SWA.


\paragraph{Out-of-distribution (OOD) generalization.} Deep ensembles are an effective technique for improving the behavior of neural networks in OOD data \citep{lakshminarayanan_simple_2017}. We ask whether our implicit ensembles modeled during late-phase learning could confer a similar advantage to our final averaged model.

Additionally, we evaluate the performance of a late-phase weight ensemble obtained with large initialization noise $\sigma_0 = 0.5$ (at $T_0 = 100$), skipping the final weight averaging step. This requires integrating predictions over $K$ late-phase ensemble members at test time, $y(x) = \frac{1}{K} \sum_{k=1}^K y(x, w_k)$. Unlike standard deep ensembles, training this ensemble is still as cheap as training a single model.

\setlength\intextsep{10pt}
\begin{table}[h]
\vspace{0.2cm}
\centering
\caption{CIFAR-100, WRN-28-10, uncertainty representation results. Mean $\pm$ std.~over 5 seeds (except deep ensembles). This first group of methods yield a single model; the second group requires test-time averaging over models while training as efficiently as $K$=1; the last group are full deep ensembles which require training $K$=10 models from scratch (\emph{Deep ens.}). We report in-distribution test set acc.~(\%) and negative log-likelihood (NLL), and in-distribution vs.~out-of-distribution (OOD) discrimination performance (average AUROC over four OOD datasets, see main text).\label{tab:ood}}
\begin{tabular}{llll}

\toprule
               & Test acc. (\%) & Test NLL & OOD \\\midrule
Base (SGD)            &   81.35$^{\pm 0.16}$ & 0.7400$^{\pm 0.0034}$ &   0.8015$^{\pm 0.0189}$         \\\midrule
Dropout (Mean) (SGD)     &    81.31$^{\pm 0.20}$       &0.7736$^{\pm 0.0025}$&      0.8022$^{\pm 0.0299}$    \\
Late-phase Hypernetwork (SGD)     &  81.55$^{\pm 0.32}$   & 0.8327$^{\pm 0.0066}$  &   0.8209$^{\pm 0.00168}$    \\
Late-phase BatchNorm (SGD)     &    \textbf{82.87}$^{\pm 0.14}$       &\textbf{0.7542}$^{\pm 0.0076}$&      \textbf{0.8360}$^{\pm 0.0118}$    \\
\midrule
MC-Dropout (SGD)     &    81.55$^{\pm 0.11}$       &0.7105$^{\pm 0.0026}$&      0.8225$^{\pm 0.0488}$    \\
SWAG (SWA)         & 82.12$^{\pm 0.03}$    &    \textbf{0.6189}$^{\pm 0.0036}$     &      0.8283$^{\pm 0.0274}$    \\
BatchEnsemble (SGD)     &    81.25$^{\pm 0.10}$       &0.7691$^{\pm 0.0048}$&      0.8285$^{\pm 0.0189}$    \\
Late-phase BatchNorm (SGD, non-averaged)     &    \textbf{82.71}$^{\pm 0.10}$       & 0.7512$^{\pm 0.0069}$&      \textbf{0.8624}$^{\pm 0.0094}$  \\
\midrule
Deep ens. (SGD) & 84.09 & \textbf{0.5942} &  0.8312 \\
Deep ens. (Late-phase BatchNorm, SGD) & \textbf{84.69} & 0.6712 &  \textbf{0.8575} \\\bottomrule       
\end{tabular}
\end{table}
We draw novel images from a collection of datasets (SVHN, \citet{netzer_reading_2011}; LSUN, \citet{yu_lsun_2015}; Tiny ImageNet; CIFAR-10) and present them to a WRN 28-10 trained on CIFAR-100.  We use Shannon's entropy \citep{cover_elements_2006} to measure the uncertainty in the output predictive distribution, which should be high for OOD and low for CIFAR-100 data. Overall performance is summarized using the area under the receiver operating characteristics curve (AUROC), averaged over all datasets. We report per-dataset results in Appendix \ref{apx:extra-expt} (Table~\ref{tab:c100-detailed-ood}) alongside experiments measuring robustness to corruptions in the input data \citep{hendrycks_benchmarking_2019}.


\begin{wrapfigure}[13]{R}{0.4\textwidth}
  \vspace{-19pt}
  \begin{center}
    \includegraphics[width=0.4\textwidth]{pdf/flat-crop.pdf}
  \end{center}
  \vspace{-14pt}
  \captionof{figure}{Flatness score. Mean score $\pm$ std.~over 5 seeds, WRN  28-10, CIFAR-100, SGD, with  and  without  BatchNorm  late-phase weights. Slower increase with $\sigma_z$ is better.\label{fig:flatness-results}}
\end{wrapfigure}
We compare our results to alternative methods with strong uncertainty representation: MC-dropout \citep{gal_dropout_2016}, SWA-Gaussian \citep[SWAG;][]{maddox_simple_2019} and BatchEnsemble \citep{wen_batchensemble_2020}. All three methods require integrating predictions over an ensemble at test time.

We find that learning with late-phase weights increases prediction uncertainty in OOD data, allowing for a significantly better separation between in and out-of-distribution examples, cf.~Table~\ref{tab:ood}. The OOD performance of late-phase BatchNorm weights compares favorably to the alternative methods including deep ensembles, even when using a single weight-averaged model, while maintaining high predictive accuracy. Remarkably, keeping the late-phase BatchNorm ensemble at test time allows reaching the highest OOD performance throughout. Paired with non-zero initialization noise $\sigma_0>0$ (cf.~Appendix~\ref{apx:extra-expt}), this method results in the best OOD performance.

Despite our improved performance on both predictive accuracy (with late-phase BatchNorm) and OOD discrimination (with late-phase BatchNorm and hypernetwork embeddings), the test set negative log-likelihood \citep[NLL; often used to assess predictive uncertainty,][]{guo_calibration_2017} is surprisingly slightly worse for our solutions. This is aligned with the finding that SWA does not always significantly reduce NLL, even though predictive accuracy increases \citep{maddox_simple_2019}.



\paragraph{Flatness.} Why do our networks generalize better? Approximate Bayesian inference suggests that flat minima generalize better than sharp minima \citep{hochreiter_flat_1997,mackay_practical_1992}. Due to symmetries that are present in neural networks there is some debate surrounding this argument \citep{dinh_sharp_2017}, but current evidence seems favorable \citep[][]{jiang_fantastic_2020}.


We hypothesize that sharing base weights over $K$ late-phase weight configurations can implicitly lead to flatter solutions. To investigate whether our algorithm finds flatter minima, we examine a simple flatness score that correlates well with generalization \citep{pittorino_entropic_2020,jiang_fantastic_2020}. Concretely, we add multiplicative Gaussian noise $z_i \sim \mathcal{N}(0, w_i^2 \, \sigma_z^2)$ to each weight $w_i$ and then measure the change in the loss
$\delta\mathcal{L} = \mathbb{E}_z [\mathcal{L}(w + z) - \mathcal{L}(w)]$. Our final weight configurations are indeed in flatter regions of weight space according to this measure: $\delta L$ increases more slowly with $\sigma_z$ for the WRN 28-10 models that are learned with BatchNorm late-phase weights, Fig.~\ref{fig:flatness-results}.


\subsection{ImageNet experiments}
\setlength\intextsep{0pt}
\begin{wraptable}[10]{R}{0.55\textwidth}
\vspace{-0.05cm}
\centering
  \caption{Validation set acc.~(\%) on ImageNet. Mean $\pm$ std.~over 5 seeds. BatchNorm late-phase and baseline trained for 20 epochs with SGD.}
  \label{tab:imagenet}
\begin{tabular}{llll}
\toprule
           & Initial & Base & Late-phase \\\midrule
ResNet-50  & 76.15 & 76.62$^{\pm 0.06}$ & 76.87$^{\pm 0.03}$ \\
ResNet-152  & 78.31 & 78.37$^{\pm 0.01}$ & 78.77$^{\pm 0.01}$ \\
DenseNet-161  & 77.65 & 78.17$^{\pm 0.01}$ & 78.31$^{\pm 0.01}$ \\
\midrule
\end{tabular}
\end{wraptable}
To investigate whether our gains translate to large-scale learning problems, we train deep residual networks \citep{he_deep_2016} and a densely-connected convolutional network \citep[DenseNet;][]{huang_densely_2018} on the ImageNet dataset \citep{russakovsky_imagenet_2015}. We start from pretrained models and contrast BatchNorm late-phase weight learning to fine-tuning with SGD for 20 epochs, with $\gamma_\theta=1/K$ and $\sigma_0=0$ (cf.~Appendix~\ref{apx:implementation}). For simplicity we do not include last-layer weights in $\Phi$.


Fine-tuning with late-phase weights improves the final top-1 validation accuracy of this pretrained model significantly with only minor training, as seen in Table~\ref{tab:imagenet}. These results serve as a proof-of-concept that existing models can be further improved, taking our late-phase initialization $T_0$ as the time the previous experimenter stopped training. In Appendix~\ref{apx:extra-expt}, we present additional CIFAR-100 experiments where we apply late-phase learning starting at the suboptimal end-of-training $T_0=200$, to mimic the pretrained condition.

\subsection{LSTM language modeling experiments}


Finally, we conduct experiments on the language modeling benchmark \texttt{enwik8}. To show that the benefits of late-phase weights extend to recurrent neural networks, we augment a standard LSTM with multiplicative late-phase weights consisting of rank-1 matrices \citep[][cf.~Section~\ref{section:late-phase-models}]{wen_batchensemble_2020}. 

\begin{wraptable}[10]{r}{0.5\textwidth}
  \caption{\texttt{enwik8} results measured in bits per character (BPC), LSTM with 500 units. Mean ~over 5 seeds, with std. $\sigma<0.01$ for all results.}
  \label{tab:lstm}
  \vspace{-0.2cm}
  \centering
  {\renewcommand{\arraystretch}{1.1}\setlength{\tabcolsep}{4pt}
  \begin{tabular}{@{}llll@{}} 
    \toprule
Model & Train & Test & Test (SWA) \\\midrule
Base           &     1.570      &  1.695  & 1.626  \\
Base + Rank1    &      1.524     &  1.663  & 1.616  \\
Late-phase Rank1     &      1.522     &  1.633  &  1.615   \\\bottomrule
\end{tabular}}
\end{wraptable}
Overfitting is a major issue when training LSTMs. Recent studies have shown that by leveraging vast amounts of computation and smart black-box optimizers \citep{golovin_google_2017}, properly regularized LSTMs can outperform previously published state-of-the-art models \citep{melis_state_2017}. To avoid this issue, we train models where the number of parameters ($\sim$1.56M) is drastically smaller than the number of training data points (90M), such that we do not observe any overfitting. Thus, we do not apply any regularization. This helps minimize the effects of hyperparameter tuning. Our only hyperparameter is the learning rate ($0.001$ here), which we tune via grid search to maximize base model performance.

We train our LSTM with 500 units for 50 epochs, optimizing every weight with Adam \citep{kingma_adam:_2015}. We apply a multiplicative rank-1 matrix elementwise to the recurrent weight matrix. Interestingly, merely adding the multiplicative parameters to the LSTM (Base) accelerates training and leads to better training and test set performance (measured in bits per character, BPC) with no additional changes to the optimizer (Base + Rank1, Table~\ref{tab:lstm}). Further improvements can be achieved with our late-phase weights. We generate $K=10$ late-phase weight components at epoch 30 with $\sigma_0=0.35$ and set $\gamma_\theta=1$. 
Additionally, we find that SWA (starting at epoch 40) substantially improves all scores, with smaller gains on the models with multiplicative weights.



\section{Related work}
Our late-phase weights define an ensemble with the special property that every model shares the same base weights. Such parameter sharing is an established method for ensembling neural networks while controlling for the memory and time complexity of learning \citep{lee_why_2015}. In designing our late-phase weight models, we draw directly from recent work which proposes sharing a set of base parameters over $K$ rank-1 matrices \citep{wen_batchensemble_2020} or $K$ heads \citep{lee_why_2015}.


The elastic averaging SGD algorithm learns $K$ neural networks in parallel, coupled through an additional central model \citep[EASGD;][]{zhang_deep_2015}. Like our algorithm, EASGD often yields solutions which generalize better than those found by standard SGD \citep{pittorino_entropic_2020}. Our late-phase weight learning is intimately related to EASGD, as we optimize the performance of a central model through an ensemble. However, thanks to parameter sharing and late-phase ensembling, we do not find the need to introduce a coupling term to our loss function. Additionally, as we replicate a small number of parameters only, the complexity of our algorithm is greatly reduced in comparison to EASGD, which requires learning a full ensemble of models.


Splitting the weights of a neural network into a set of fast and slow components which vary on different timescales is a classic technique \citep{hinton_using_1987,schmidhuber_learning_1992} that has proven useful in a wide range of problems. This list includes applications to few-shot learning \citep{munkhdalai_meta_2017,nichol_first-order_2018,perez_film_2018,zintgraf_fast_2019,flennerhag_meta-learning_2020}, optimization \citep{zhang_lookahead_2019,chaudhari_entropy-sgd_2019}, improving recurrent neural networks \citep{ba_using_2016,ha_hypernetworks_2017}, and continual learning with biologically-realistic synapses \citep{kaplanis_continual_2018,leimer_synaptic_2019}, to name a few. Although there is no explicit separation of timescales in our weight components, the update accumulation in $\theta$ as $\phi_k$ varies (cf.~Algorithm~\ref{alg:learning}) suggests interpreting the base $\theta$ as slow weights and the late-phase $\Phi$ as fast weights. 

This accumulation is reminiscent of a recent meta-learning algorithm \citep{zintgraf_fast_2019}, which first separates parameters into task-shared and task-specific, and then differentiates through a sequence of accumulated updates performed over the task-specific parameters \citep{finn_model-agnostic_2017}. Continuing with the fast-slow weight analogy, our averaging over fast weights at the end of learning (Eq.~\ref{eq:test-time-averaging}) could be thought of as a synaptic consolidation step which integrates the fast weight components onto a slow, persistent form of memory.


\section{Conclusion}
We proposed to replicate and learn in parallel a subset of weights in a late phase of neural network learning. These late-phase weights define an ensemble of models which share every other weight. We studied convolutional neural networks, a common recurrent neural network, and a simple quadratic problem. Surprisingly, across these cases, we found that a small number of appropriately chosen such weights can quickly guide SGD towards solutions that generalize well. Most of our experiments relied on BatchNorm late-phase weights, making our method easy to implement in a wide range of existing models, including pretrained ones. We expect future work to uncover new effective late-phase weight models.

\section*{Acknowledgements}
This work was supported by the Swiss National Science Foundation (B.F.G. CRSII5-173721 and 315230\_189251), ETH project funding (B.F.G. ETH-20 19-01), the Human Frontiers Science Program (RGY0072/2019) and funding from the Swiss Data Science Center (B.F.G, C17-18, J.v.O. P18-03). Jo達o Sacramento was supported by an Ambizione grant (PZ00P3\_186027) from the Swiss National Science Foundation. We would like to thank Nicolas Zucchet, Simon Schug, Xu He, ngelo Cardoso and Angelika Steger for feedback, Mark van Rossum for discussions on flat minima, Simone Surace for his detailed feedback on Appendix~\ref{apx:NQP}, and Asier Mujika for providing very useful starter code for our LSTM experiments.

\bibliography{ensembles}
\bibliographystyle{iclr2021_conference}

\appendix
\setlength\intextsep{10pt}

\section{Additional implementation details}
\label{apx:implementation}


\paragraph{Hypernetwork model.} The base neural network architecture we use when parameterizing our weights using a hypernetwork is identical to the WRN~28-10 described by \citet{zagoruyko_wide_2016}. Our hypernetwork implementation closely follows \citet{savarese_learning_2019}, who studied high-performing linear hypernetwork architectures for WRNs. We do not use dropout or biases in the convolutional layers. The parameters of every convolutional layer are hypernetwork-generated, with one hypernetwork per layer group (Table~\ref{tab:hnet-spec}). The remaining parameters, namely those of BatchNorm units and final linear layer weights, are non-hypernetwork-generated.

Following \citet{savarese_learning_2019} we turn off weight decay for the model embeddings and initialize these parameters with a random pseudo-orthogonal initialization over layers. The hypernetwork parameters are initialized using a standard Kaiming initialization \citep{he_delving_2015}.

\begin{table}[htbp!]
  \caption{Specification of the hypernetwork used for each convolutional layer of the WRN, indexed by its depth in the network. A depth marked by * refers to the residual connection spanning across the specified layers. The characteristics of each layer is described in the format input-channels $\times$ [kernel-size] $\times$ output-channels under \emph{Conv-layer}. Layers within the same group are generated by the same hypernetwork. Each hypernetwork has a unique parameter tensor of shape \emph{Hnet-PS}, which, when multiplied by a layer and weight embedding of shape \emph{Emb-PS} and reshaped appropriately, generates the primary network parameter of shape \emph{Base-PS}.}
  \label{tab:hnet-spec}
 \centering
  {\renewcommand{\arraystretch}{1.1}\setlength{\tabcolsep}{5pt}
  \begin{tabular}{@{}llllll@{}}
  \toprule
Depth & Conv-layer & Base-PS & Layer group & Hnet-PS & Emb-PS \\ 
 \midrule
1 & 3$\times$[3$\times$3]$\times$16 & [16, 3, 3, 3] & 0 & [16, 3, 3, 3, 10] & [10, 1] \\ 
 &  &  &  &  &  \\ 
2 & 16$\times$[3$\times$3]$\times$160 & [160, 3, 3, 16] & 1 & [160, 3, 3, 16, 7] & [7, 1] \\ 
3 & 160$\times$[3$\times$3]$\times$160 & [160, 3, 3, 160] & 2 & [160, 3, 3, 80, 14] & [14, 2] \\ 
4 & 160$\times$[3$\times$3]$\times$160 & [160, 3, 3, 160] & 2 & [160, 3, 3, 80, 14] & [14, 2] \\ 
5 & 160$\times$[3$\times$3]$\times$160 & [160, 3, 3, 160] & 2 & [160, 3, 3, 80, 14] & [14, 2] \\ 
6 & 160$\times$[3$\times$3]$\times$160 & [160, 3, 3, 160] & 2 & [160, 3, 3, 80, 14] & [14, 2] \\ 
7 & 160$\times$[3$\times$3]$\times$160 & [160, 3, 3, 160] & 2 & [160, 3, 3, 80, 14] & [14, 2] \\ 
8 & 160$\times$[3$\times$3]$\times$160 & [160, 3, 3, 160] & 2 & [160, 3, 3, 80, 14] & [14, 2] \\ 
9 & 160$\times$[3$\times$3]$\times$160 & [160, 3, 3, 160] & 2 & [160, 3, 3, 80, 14] & [14, 2] \\ 
 &  &  &  &  &  \\ 
10 & 160$\times$[3$\times$3]$\times$320 & [320, 3, 3, 160] & 3 & [320, 3, 3, 160, 14] & [14, 1] \\ 
11 & 320$\times$[3$\times$3]$\times$320 & [320, 3, 3, 320] & 3 & [320, 3, 3, 160, 14] & [14, 2] \\ 
12 & 320$\times$[3$\times$3]$\times$320 & [320, 3, 3, 320] & 3 & [320, 3, 3, 160, 14] & [14, 2] \\ 
13 & 320$\times$[3$\times$3]$\times$320 & [320, 3, 3, 320] & 3 & [320, 3, 3, 160, 14] & [14, 2] \\ 
14 & 320$\times$[3$\times$3]$\times$320 & [320, 3, 3, 320] & 3 & [320, 3, 3, 160, 14] & [14, 2] \\ 
15 & 320$\times$[3$\times$3]$\times$320 & [320, 3, 3, 320] & 3 & [320, 3, 3, 160, 14] & [14, 2] \\ 
16 & 320$\times$[3$\times$3]$\times$320 & [320, 3, 3, 320] & 3 & [320, 3, 3, 160, 14] & [14, 2] \\ 
17 & 320$\times$[3$\times$3]$\times$320 & [320, 3, 3, 320] & 3 & [320, 3, 3, 160, 14] & [14, 2] \\ 
 &  &  &  &  &  \\ 
18 & 320$\times$[3$\times$3]$\times$640 & [640, 3, 3, 320] & 4 & [640, 3, 3, 320, 14] & [14, 1] \\ 
19 & 640$\times$[3$\times$3]$\times$640 & [640, 3, 3, 640] & 4 & [640, 3, 3, 320, 14] & [14, 2] \\ 
20 & 640$\times$[3$\times$3]$\times$640 & [640, 3, 3, 640] & 4 & [640, 3, 3, 320, 14] & [14, 2] \\ 
21 & 640$\times$[3$\times$3]$\times$640 & [640, 3, 3, 640] & 4 & [640, 3, 3, 320, 14] & [14, 2] \\ 
22 & 640$\times$[3$\times$3]$\times$640 & [640, 3, 3, 640] & 4 & [640, 3, 3, 320, 14] & [14, 2] \\ 
23 & 640$\times$[3$\times$3]$\times$640 & [640, 3, 3, 640] & 4 & [640, 3, 3, 320, 14] & [14, 2] \\ 
24 & 640$\times$[3$\times$3]$\times$640 & [640, 3, 3, 640] & 4 & [640, 3, 3, 320, 14] & [14, 2] \\ 
25 & 640$\times$[3$\times$3]$\times$640 & [640, 3, 3, 640] & 4 & [640, 3, 3, 320, 14] & [14, 2] \\ 
 &  &  &  &  &  \\ 
2$\rightarrow$4* & 16$\times$[1$\times$1]$\times$160 & [160,1, 1, 16] & 5 & [160, 1, 1, 16, 7] & [7, 1] \\ 
10$\rightarrow$12* & 160$\times$[1$\times$1]$\times$320 & [320, 1, 1, 160] & 6 & [320, 1, 1, 160, 7] & [7, 1] \\ 
18$\rightarrow$20* & 320$\times$[1$\times$1]$\times$640 & [640, 1, 1, 320] & 7 & [640, 1, 1, 320, 7] & [7, 1] \\
 \midrule
  \end{tabular}}
\end{table}




\paragraph{Small ConvNet model.} We train a slight modification of the classic LeNet-5 \citep{lecun_gradient-based_1998} for 200 epochs on CIFAR-10. Both convolutional and fully-connected layers are left unchanged, but we use rectified linear units on the hidden layers. Furthermore, after each such activation, BatchNorm units are inserted. We optimize the model with SGD and use late-phase BatchNorm weights, with $T_0=50$ and $\sigma_0=0.5$. For simplicity of implementation, we do not include the last linear layer in the late-phase weight set $\Phi$.

\paragraph{Optimization.} We optimize the cross-entropy loss, using either SGD with Nesterov momentum (0.9) or SGD with Nesterov momentum (0.9) wrapped inside SWA. \textbf{LSTM:} Our LSTM experiments use Adam with constant learning rate $0.001$, batch size $128$, and no regularizers such as weight decay or dropout. \textbf{WRN-28-10:} For our WRN experiments on the CIFAR datasets we use the learning rate annealing schedule of \citet{izmailov_averaging_2018}, according to which an initial learning rate of $0.1$ is linearly decreased at every epoch from the end of the 100th epoch (80th for SWA) to the end of the 180th epoch (144th for SWA; SWA is activated at epoch 160), when a final value of $0.001$ ($0.05$ for SWA) is reached. Our optimizers use Nesterov momentum (set to $0.9$), a batch size of $128$ and weight decay (set to $0.0005$). On CIFAR-100 (SGD) we set the weight decay of late-phase weights proportional to the ensemble size, $0.0005 K$. \textbf{WRN-28-14:} The WRN 28-14 models are trained for 300 epochs on CIFAR-100. The learning rate is initialized at 0.1, then annealed to 0.05 from the 80th epoch to the 240th epoch. SWA is activated at epoch 160. All other hyperparameters are identical to those of WRN~28-10. \textbf{ConvNet:} Same as for the WRN~28-10 model, except that we anneal the learning rate until the 160th epoch.

\begin{figure}[h!]
\centering
\begin{minipage}{0.46\textwidth}
\begin{algorithm}[H]    
  \KwRequire{Base weights $\theta$, dataset $\mathcal{D}$, hyperparameter $\eta$, loss $\mathcal{L}$}
  \KwRequire{Training iteration $t$}
  $\mathcal{M} \gets$ Sample minibatch from $\mathcal{D}$\\
 $\Delta \theta \gets \nabla_\theta \, \mathcal{L}(\mathcal{M}, \theta)$\\
 $\theta \gets U(\theta, \eta, \Delta \theta)$
 
 $ \theta_\text{SWA} \gets (t \, \theta_\text{SWA} + \theta)/(t+1) $\\
   $t \gets t + 1 $
  \caption{Stochastic weight averaging (SWA)\label{alg:swa}}
 \end{algorithm}
 \hspace{0.5cm}
\end{minipage}
\begin{minipage}{0.46\textwidth}
\hspace{0.3cm}
\begin{algorithm}[H]    
  \KwRequire{Base weights $\theta$, dataset $\mathcal{D}$, learning rate $\eta$, momentum $\rho$, loss $\mathcal{L}$}
  $\mathcal{M} \gets$ Sample minibatch from $\mathcal{D}$\\
 $\Delta \theta \gets \nabla_\theta \, \mathcal{L}(\mathcal{M}, \theta + \rho \, \nu)$\\
 $\nu \gets \rho\nu- \eta \, \Delta \theta$\\
   $\theta \gets \theta + \nu $
  \caption{SGD with Nesterov momentum\label{alg:nesterov}}
 \end{algorithm}
\end{minipage}
  \caption{Pseudocode for a single parameter update for SWA and SGD with Nesterov momentum, the two main optimizers used in our experiments. These are either used standalone, or as $U_\theta$ and $U_\phi$ in Algorithm \ref{alg:learning} (main text). $U$ in Algorithm \ref{alg:swa} (SWA) serves as a placeholder for a parameter update rule such as SGD (with Nesterov momentum) or Adam. Training iteration $t$ is counted from the activation of SWA in Algorithm \ref{alg:learning}.}
\end{figure}


\begin{figure}[h!]
\centering
\begin{minipage}{0.8\textwidth}
    \begin{algorithm}[H]
      \KwRequire{Base weights $\theta$, late-phase weight set $\Phi$, dataset $\mathcal{D}$, gradient scale factor $\gamma_\theta$, learning rate $\eta$, ensemble size $K$, initialization noise $\sigma_0$, initialization time $T_0$, number of training iterations $T$, loss $\mathcal{L}$}
      \textbf{Initialization:} $\hat{K} \gets 0$, $s \gets 0$, $t \gets 1$\\
      \While{$t \leq T$}{
        \If{$t  = T_0$}{
        \textrm{// generate late-phase weights}
        
            \For{$1 \le k \le K$}{
                $\textrm{sample } \epsilon \sim \mathcal{N}(0,1)$
                
                $\phi_k \gets \phi_0 + \frac{\sigma_0}{\|\phi_0\|}\epsilon$
            }
            
            $\textrm{// set range for specialists training}$
            
            $\hat{K} \gets K$
            
            $s \gets 1$
            
        }
      \For{$s \le k \le \hat{K}$}{
       $\mathcal{M}_k \gets$ Sample minibatch from $\mathcal{D}$
    
       $\Delta \theta_k \gets \nabla_\theta \, \mathcal{L}(\mathcal{M}_k, \theta, \phi_k)$
       
       $\phi_k \gets \phi_k - \eta \, \nabla_{\phi_k} \, \mathcal{L}(\mathcal{M}_k, \theta, \phi_k)$
       
       $t \gets t + 1 $
      }

      $\theta \gets \theta - \gamma_{\theta} \, \eta \sum_{k=1}^K \Delta \theta_k$
      }
      
      \caption{Late-phase learning\label{alg:learning_2}}
     \end{algorithm}
 \hspace{0.5cm}
\end{minipage}
  \caption{Complete pseudocode for an entire training session using late-phase weights. To avoid notational clutter $T$, $T_0$ and $t$ are measured in numbers of minibatches consumed. In the paper, we measure $T_0$ and $T$ in epochs. For simplicity, we present the case where $U_{\phi}$ and $U_{\theta}$ are set to plain SGD (without momentum) and $\phi_k$ of dimension 1. Other optimization algorithms (e.g., Algorithm \ref{alg:swa} or Algorithm \ref{alg:nesterov}) can be used to replace $U_{\phi}$ and $U_{\theta}$ , as described in Algorithm~\ref{alg:learning}. Note that we increase $t$ inside the inner loop. This highlights  (\textit{i}) that
   every specialist parameter is trained only on $1/K$ data samples after $t > T_0$ compared to $\theta$, and (\textit{ii}) that  we count every minibatch drawn from the data to compare fairly to algorithms without an inner loop.}
\end{figure}


\paragraph{Batch normalization units.} Whenever we use SWA, we follow \citet{izmailov_averaging_2018} and perform a full pass over the training set to re-estimate BatchNorm unit statistics before testing. This correction is required since the online BatchNorm mean and variance estimates track the activations produced with the raw (non-averaged) weights during training, while the averaged solution is the one used when predicting at test time.

\paragraph{Data augmentation and preprocessing.} On both CIFAR and ImageNet datasets, all images are normalized channelwise by subtracting the mean and dividing by the standard deviation; both statistics are computed on the training dataset. The same transformation is then applied when testing, including to OOD data. Following a standard procedure \citep[e.g.,][]{zagoruyko_wide_2016,he_deep_2016} we augment our training datasets using random crops (with a 4-pixel padding for CIFAR) and random horizontal flips. The ImageNet training dataset is augmented with random horizontal flips, as well as random cropping of size 224, while a centered cropping of size 224 was used on the test set. Our OOD datasets are resized to fit whenever necessary; we used the resized images made available by \citet{lee_simple_2018}.

\paragraph{ImageNet experiments.} The pretrained model for the ImageNet experiment is obtained from torchvision's models subpackage. We fine-tune the model for 20 additional epochs on ImageNet. We use a multistep learning rate scheduler, starting at $0.001$ then decreasing at the 10th epoch to $0.0001$. We use SGD with momentum (set to $0.9$) and weight decay (set to $0.0001$) as our optimizer, with a batch size of $256$. We use $\sigma_0=0$ and $K=10$ for our late-phase model.

\begin{wraptable}[13]{R}{0.45\textwidth}
\centering
\caption{CIFAR-100 test set accuracy (\%) depending on different values of $K$ for WRN 28-10, SGD. Mean $\pm$ std.~over 5 seeds.\label{tab:k-sensitivity}}
\begin{tabular}{ll}
\toprule
 $K$   & Test acc. (\%) \\\midrule
1 &  81.35$^{\pm 0.16}$     \\
5 & 82.44$^{\pm 0.22}$  \\
10  & 82.87$^{\pm 0.22}$  \\
15  & 83.01$^{\pm 0.27}$  \\
20  & 82.86$^{\pm0.29}$  \\
\bottomrule  
\end{tabular}
\end{wraptable}

\paragraph{Code forks.}
Our hypernetwork implementation was inspired by the code made publicly available by \citet{savarese_learning_2019}. Our implementation of SWA was adapted from the code accompanying the work of \citet{izmailov_averaging_2018}, now available on the torchcontrib Python package. The SWAG method was evaluated directly using the code provided by the authors \citep{maddox_simple_2019}. We used the same base WRN model as \citet{maddox_simple_2019}, which can be retrieved from \url{https://github.com/meliketoy/wide-resnet.pytorch}.

\paragraph{LSTM}

All experiments are conducted using the Tensorflow Python framework \citep{abadi_tensorflow_2016}. All base weights are initialized uniform in $[-0.01,0.01]$ whereas the initial rank-1 matrix weights are centered around $1$ i.e. $[1-0.01,1 + 0.01]$ to mitigate strong difference in initialization compared to the base model. We use the Tensorflow default values ($\beta_1=0.9$, $\beta_2=0.$, $\epsilon=10^{-8}$) for the Adam optimiser. We perform a grid search over $\sigma_0 \in [0, 0.5]$ (in steps of size 0.05) for our LSTM experiments (fixing $K=10$ and varying $T_0 \in \{0, 30\}$) and obtain the values reported in the main text, $T_0=30$ and $\sigma_0=0.35$.

\section{Additional experiments}
\label{apx:extra-expt}
\begin{table}[h!]
\centering
  \caption{Applying late-phase weights to a pretrained WRN~28-10, CIFAR-100, SGD. Mean $\pm$ std.~over 5 seeds.}
  \label{tab:pretrained-c100}
  \vspace{-0.2cm}
  \centering
    \begin{tabular}{ll}
    \toprule
    Model    & Test acc. (\%) \\\midrule
    Initial &  81.35$^{\pm 0.16}$ \\
    Base &  81.47$^{\pm 0.14}$    \\
    Late-phase BatchNorm & 82.02$^{\pm 0.12}$ \\
    Late-phase BatchNorm, frozen base weight  &  81.50$^{\pm 0.20}$  \\\bottomrule  
    \end{tabular}
\end{table}

\paragraph{Pretrained CIFAR-100.}
We apply our method to a standard WRN 28-10 pretrained on CIFAR-100 (i.e., we set $T_0=200$) and train for an additional 20 epochs. At the beginning of the fine-tuning, the learning rate is reset to 0.01, then annealed linearly to 0.001 for 10 epochs. It is then held constant for the remainder of the fine-tuning process. We observe that augmenting with BatchNorm late-phase weights yields an improved predictive accuracy compared to additional fine-tuning with SGD (Base), cf.~Table~\ref{tab:pretrained-c100}. Both methods improve over the initial baseline (Initial), including the base model. This can be explained by the optimization restart and the accompanying spike in the learning rate introduced by our scheduler \citep{loshchilov_sgdr_2017}.



Importantly, we find that fine-tuning only BatchNorm late-phase weights while keeping all other weights fixed does not even match the Base control. Together with the finding that the optimal late-phase weight initialization time is at $T_0^*=120$ (when learning for 200 epochs), this result speaks to the importance of jointly optimizing both base and late-phase weights through our Algorithm~\ref{alg:learning}.


\begin{table}
\centering
  \caption{Gradient accumulation control, CIFAR-100, WRN 28-10, SGD. Mean $\pm$ std.~over 5 seeds.}
  \label{tab:gead-control}
  \vspace{-0.2cm}
  \centering
  {\renewcommand{\arraystretch}{1.1}\setlength{\tabcolsep}{4pt}
  \begin{tabular}{@{}llllllll@{}} 
    \toprule
Model & Test acc. (\%) \\\midrule
Base (SGD)      &  81.35$^{\pm 0.16}$     \\
Base + gradient accumulation ($\gamma_\theta=1)$   & 80.76$^{\pm 0.26}$   \\
Base + gradient accumulation ($\gamma_\theta=1/K)$  & 80.34$^{\pm 0.28}$      \\\bottomrule
    \end{tabular}}
\end{table}

\paragraph{Gradient accumulation control.} Here we show that the improved generalization we report in the main text is not merely due to gradient accumulation over larger batches. We take our base WRN 28-10 model (without late-phase weights) and start accumulating gradients over $K=10$ minibatches at $T_0=120$, experimenting both with $\gamma_\theta=1/K$ and $\gamma_\theta=1$. The models are trained with SGD using otherwise standard optimization settings. Both controls fail to improve (even match) the performance of the base model trained without any gradient accumulation.

\begin{table}
\centering
\caption{CIFAR-100 test set accuracy (\%) depending on different values of $\sigma_{0}$ for WRN 28-10 SGD with late-phase BatchNorm weights (LPBN). Mean $\pm$ std.~over 5 seeds.\label{tab:sigma-sensitivity}}
\begin{tabular}{lllllll}
\toprule
& \multicolumn{2}{l}{CIFAR-100} &  \multicolumn{2}{l}{CIFAR-100} & \multicolumn{2}{l}{CIFAR-100} \\
& \multicolumn{2}{l}{(LPBN)}  &   \multicolumn{2}{l}{(LPBN, non-averaged)}  & \multicolumn{2}{l}{(LPBN, pretrained)} \\
\midrule
$\sigma_{0}$ & Test acc. (\%) & OOD&Test acc. (\%) & OOD&Test acc. (\%) & OOD \\\midrule
$0$ & 82.87$^{\pm 0.22}$& 0.833$^{\pm 0.005}$ &83.20$^{\pm 0.20}$&0.854$^{\pm 0.017}$ & 81.70$^{\pm 0.19}$    &0.803 $^{\pm 0.017}$  \\
$0.25$  & 82.77$^{\pm 0.19}$& 0.836$^{\pm 0.012}$ &82.68$^{\pm 0.32}$ & 0.861$^{\pm 0.013}$& 82.02$^{\pm 0.12}$  &0.808 $^{\pm 0.017}$ \\
$0.5$  & 82.78$^{\pm 0.18}$ & 0.837$^{\pm 0.011}$ & 82.71$^{\pm 0.10}$& 0.862$^{\pm 0.009}$& 81.15 $^{\pm 0.29}$&0.797 $^{\pm 0.007}$  \\
$0.75$  &  82.41$^{\pm 0.20}$& 0.839$^{\pm 0.012}$&82.43$^{\pm 0.15}$ & 0.855$^{\pm 0.013}$& - &- \\
$1.0$  &  81.52$^{\pm 1.09}$& 0.840$^{\pm 0.017}$ &82.38$^{\pm 0.15}$& 0.848$^{\pm 0.014}$&  - & - \\ \bottomrule  
\end{tabular}
\end{table}


\begin{wraptable}[18]{R}{0.45\textwidth}
\centering
\caption{CIFAR-10 and CIFAR-100 test set accuracy (\%) depending on different late phase timing $T_0$ for WRN 28-10, SGD. Mean $\pm$ std.~over 5 seeds.\label{tab:t0-sensitivity}}
\vspace{-0.2cm}
\begin{tabular}{lll}
\toprule
$T_{0}$    & CIFAR-10 & CIFAR-100   \\\midrule
0 &  95.68$^{\pm 0.23}$  &  74.38$^{\pm 0.71}$\\
40 &  96.34$^{\pm 0.08}$ &   79.69$^{\pm 0.11}$    \\
60 &  96.42$^{\pm 0.10}$ & 80.53$^{\pm 0.21}$\\
80 &  96.50$^{\pm 0.11}$ & 81.72$^{\pm 0.18}$ \\
100 &  96.45$^{\pm 0.08}$ & 82.48$^{\pm 0.21}$ \\
120 &  96.48$^{\pm 0.20}$ & 82.87$^{\pm 0.22}$ \\
140 &  96.26$^{\pm 0.17}$ & 82.53$^{\pm 0.21}$ \\
160 &  96.23$^{\pm 0.11}$ & 81.41$^{\pm 0.31}$ \\
180 &  96.25$^{\pm 0.23}$ & 81.43$^{\pm 0.27}$ \\
200 &  96.16$^{\pm 0.12}$ & 81.35$^{\pm 0.16}$ \\\bottomrule  
\end{tabular}
\end{wraptable}

\begin{figure}
  \centering
  \begin{center}
    \includegraphics[width=0.6\textwidth]{pdf/cifar100_to_sens.pdf}
  \end{center}
   \vspace{-0.4cm}
  \captionof{figure}{Sensitivity analysis of $T_0$. Mean AUROC score (OOD) and test set accuracy for different values of $T_0$ for WRN  28-10, CIFAR-100, SGD, with BatchNorm  late-phase weights.\label{fig:T0-sensitivity}}
\end{figure}

\paragraph{Sensitivity to $T_0$, $K$ and $\sigma_0$.} We present a hyperparameter exploration on the CIFAR-100 dataset using BatchNorm late-phase weights in Tables  \ref{tab:k-sensitivity}, \ref{tab:sigma-sensitivity} and \ref{tab:t0-sensitivity}. We find that our algorithm is largely robust to $\sigma_0$ when $T_0$ can be set to its optimal value, which is at 60\% of training. See also Figure \ref{fig:T0-sensitivity} for a visualisation of the same data, specifically the change in mean AUROC score and test set accuracy when changing $T_0$. This result holds also on CIFAR-10, cf.~Table~\ref{tab:t0-sensitivity}. When starting from a pretrained condition ($T_0=200$), finite $\sigma_0$ leads to a significant improvement in performance, cf.~Table~\ref{tab:sigma-sensitivity}. We therefore report results obtained with $\sigma_0=0$ for every CIFAR and ImageNet experiment in the main text. The exception to this is the non-averaged (ensemble) late-phase BatchNorm model presented in Table~\ref{tab:ood}, which was optimized for best OOD performance (corresponding to $\sigma_0=0.5$).


\begin{table}[h!]
\centering
\caption{Performance of a WRN 28-10 on CIFAR-100 with different dropout probability $p$. For MC-dropout we average over 10 different samples.  Mean $\pm$ std.~over 5 seeds. \label{tab:dropout}}
\vspace{-0.2cm}
\begin{tabular}{lllll}
\toprule
   & $p$ & Test acc. (\%) & Test NLL & OOD \\\midrule
Dropout & 0.1 &    81.46$^{\pm 0.13}$       &0.7476$^{\pm 0.0059}$&      0.8031$^{\pm 0.0064}$    \\
Dropout & 0.2 &    81.31$^{\pm 0.20}$       &0.7736$^{\pm 0.0025}$&      0.8022$^{\pm 0.0299}$    \\
Dropout & 0.3 &    80.93$^{\pm 0.19}$       &0.8342$^{\pm 0.0098}$&      	0.7833$^{\pm 0.0239}$    \\\midrule

MC-Dropout & 0.1 &  81.51$^{\pm 0.14}$     &0.7197$^{\pm 0.0054}$&      0.8149$^{\pm 0.0087}$    \\
MC-Dropout & 0.2  &    81.55$^{\pm 0.11}$       &0.7105$^{\pm 0.0026}$&      0.8225$^{\pm 0.0488}$    \\
MC-Dropout & 0.3 &  81.36$^{\pm 0.31}$  &0.7150$^{\pm 0.0069}$&      0.8040$^{\pm 0.0135}$    \\\bottomrule  
\end{tabular}
\end{table}

\paragraph{Related work.} Here we provide details for the training setups of alternative methods we compare against in the main text. For the results reported for dropout \citep{srivastava_dropout_2014} and MC-dropout \citep{gal_dropout_2016}, we simply train a WRN 28-10 on CIFAR-100 with the exact same configuration as for our base model, see above, but include dropout layers as usually done \citep{zagoruyko_wide_2016} after the first convolution in each residual block.
For a scan over the dropout probability $p$ in this setup, see Table~\ref{tab:dropout}. $p=0.2$ is reported in the main text - for CIFAR-100 and CIFAR-10. Note that $p$ was only tuned for CIFAR-100. 

For the reported results of BatchEnsemble \citep{wen_batchensemble_2020}, we simply execute the code provided by the authors at \url{https://github.com/google/uncertainty-baselines} with their fine-tuned configuration for CIFAR-10/100.
Notably, the authors use a different setup than followed in this manuscript. First, the WRN 28-10 is trained for 250 epochs (we allow for this increased budget exceptionally for BatchEnsemble), with a multi-step learning rate annealing at $[80,160,180]$ with a learning rate decay factor of $0.2$. Second, a weight decay of $3 \times 10^{-4}$ is used.

\begin{table}
\centering
\caption{Final training set loss on CIFAR datasets, WRN 28-10, SGD.  Mean $\pm$ std.~over 5 seeds.\label{tab:training-loss}}
\begin{tabular}{ll}
\toprule
    & Training loss \\\midrule
CIFAR-10 -- base &  0.0010$^{\pm 0.0000}$     \\
CIFAR-10 -- late-phase BatchNorm  & 0.0019$^{\pm 0.0001}$  \\\midrule  
CIFAR-100 -- base &  0.0024$^{\pm 0.0001}$     \\
CIFAR-100 -- late-phase BatchNorm  & 0.0267$^{\pm 0.0004}$  \\\bottomrule  
\end{tabular}
\end{table}

For the results reported for SWAG \citep{maddox_simple_2019}, we use the code provided by the authors at \url{https://github.com/wjmaddox/swa_gaussian}, and the proposed fine-tuned configuration which coincides with the configuration used to
obtain all CIFAR-100 results reported in this manuscript, except for BatchEnsembles (see above). We report results for SWAG after training on 200 epochs for fair comparison.

\paragraph{Training losses.} We provide the final achieved training losses for the base model and when augmenting it with BatchNorm late-phase weights on Table~\ref{tab:training-loss}, for both CIFAR-10 and CIFAR-100. Using a fast gradient accumulation scale factor of $\gamma_\theta=1$ leads to a higher training loss on CIFAR-100 than that of the standard model, but we found this setting crucial to achieve the largest improvement on test set generalization.



\paragraph{CIFAR-10 with a reduced training set.} Here we evaluate the performance of our method on a reduced training set of CIFAR-10. We randomly pick 10000 training data out of the 50000 available, and use this new set to train different models. After training, the models are evaluated on the standard CIFAR-10 test set. Results are shown in Table~\ref{tab:reduced-c10}. 


\begin{table}
\centering
\caption{Performance of models trained on a reduced CIFAR-10 training set and evaluated on the full CIFAR-10 test set.  Mean $\pm$ std.~over 5 seeds. \label{tab:reduced-c10}}
\vspace{-0.2cm}
\begin{tabular}{ll}
\toprule
Model & Test acc. (\%) \\\midrule
Base (SGD)      &    88.98$^{\pm 0.18}$  \\
Late-phase BN (SGD)   & 89.58$^{\pm 0.19}$ \\\bottomrule  
\end{tabular}
\end{table}

\paragraph{Detailed OOD results and mean corruption error (mCE) experiments.}
In order to test the robustness of late-phase weights against input data corruption, we used the  corruptions and dataset proposed by \citet{hendrycks_benchmarking_2019}, freely available at \url{https://github.com/hendrycks/robustness}. The authors propose 15 noise sources such as random Gaussian noise, spatter or contrast changes to deform the input data and report the model test set accuracy on the corrupted dataset under 5 severity levels (noise strengths). For each source noise, its corruption error is computed by averaging the prediction error over the severity levels. The average of the corruption error of all 15 noises gives us the Mean Corruption Error (mCE). See Table \ref{tab:ood_mce} for the mCE computed on the corrupted CIFAR-100 dataset.

\paragraph{Training run time.} Here we compare the training run time of our method with the baseline. The result was computed in Python 3.7, using the automatic differentiation and GPU acceleration package PyTorch (version 1.4.0). We used the standard datasets (including training and test splits) as provided by the torchvision package unless stated otherwise. We used a single NVIDIA GeForce 2080 Ti GPU for the experiment. Results are presented in Table~\ref{tab:runtime}.


\setlength\intextsep{5pt}
\begin{table}
\centering
\caption{OOD performance measured by the AUROC, and robustness measured by the Mean Corruption Error (\emph{mCE}). We train the models on CIFAR-100 and attempt to discriminate test set images from novel ones drawn from the SVHN, LSUN, Tiny ImageNet (\emph{TIN}) and CIFAR-10 dataset. The mCE value is the average across 75 different corruptions from the CIFAR-100-C dataset. LPBN and LP HNET stand respectively for late-phase BatchNorm and late-phase hypernetwork. \label{tab:c100-detailed-ood}}
\label{tab:ood_mce}
\begin{tabular}{llllll}

\toprule
               & SVHN	& LSUN	& TIN	& CIFAR-10 & mCE \\\midrule
Base   &  0.814$^{\pm 0.024}$  &0.798$^{\pm 0.036}$   &0.776$^{\pm 0.038}$&0.818$^{\pm 0.003}$  & 47.84$^{\pm 0.41}$\\
LPBN     & 0.831$^{\pm 0.021}$  & 0.862$^{\pm 0.017}$  &0.838$^{\pm 0.023}$  &0.814$^{\pm 0.002}$  & 45.59$^{\pm 0.25}$       \\
LPBN (non-avg.)  &  0.877$^{\pm 0.008}$  &0.883$^{\pm 0.015}$  &0.863$^{\pm 0.023}$  &0.827$^{\pm 0.002}$  & 46.21$^{\pm 0.29}$     \\
LP HNET      &0.815$^{\pm 0.022}$ &   0.842$^{\pm 0.023}$  &0.816$^{\pm 0.027}$   &0.811$^{\pm 0.002}$  & 47.84$^{\pm 0.42}$   \\\midrule
Dropout (Mean)      & 0.792$^{\pm 0.093}$ &  0.807$^{\pm 0.040}$  &   0.788$^{\pm 0.044}$ &   0.822$^{\pm 0.003}$  & 48.97$^{\pm 0.33}$\\
MC-Dropout      & 0.806$^{\pm 0.082}$ &  0.842$^{\pm 0.046}$  &   0.817$^{\pm 0.041}$ &   0.824$^{\pm 0.003}$  & 48.09$^{\pm 0.36}$ \\

SWAG      &  0.824$^{\pm 0.012}$  &0.839$^{\pm 0.054}$  &0.835$^{\pm 0.041}$  &0.816$^{\pm 0.004}$  &  -  \\

BatchEnsemble     &  0.848$^{\pm 0.020}$  &0.828$^{\pm 0.018}$  &0.820$^{\pm 0.030}$  & 0.829$^{\pm 0.019}$  &  -     \\

\midrule
Deep ens. &  0.839  & 0.836  &0.812  &0.839  & 44.21 \\
Deep ens. (LPBN)  &  0.855  &0.884  &0.856  &0.834  &43.15 \\
\bottomrule       
\end{tabular}
\end{table}


\begin{table}
\centering
\caption{Training time in seconds and hours on CIFAR-10 for 200 epochs on a single NVIDIA GeForce 2080 Ti GPU. \label{tab:runtime}}
\vspace{-0.2cm}
\begin{tabular}{lll}
\toprule
Model & seconds & hours \\\midrule
Base (SGD)      &     17714  &     $\sim$ 4.92 \\
Late-phase BN (SGD)   &  17772 &  $\sim$ 4.94 \\\bottomrule  
\end{tabular}
\end{table}




\section{Theoretical analysis of the noisy quadratic problem}
\label{apx:NQP}
In this section, we consider a noisy quadratic problem (NQP) that can be theoretically analyzed and that captures important characteristics of the stochasticity of a minibatch-based optimizer \citep{schaul_no_2013, martens_second-order_2016, wu_understanding_2018, zhang_which_2019, zhang_lookahead_2019}. 
The NQP does a second-order Taylor expansion of the loss function around the optimum $\mathbf{w}^*$ and models the minibatch noise as a random translation $\boldsymbol{\epsilon}$ of the optimum, while keeping the curvature $H$ the same. This gives us the following minibatch loss:
\begin{align}\label{eq:noisy_loss_weightspace}
    \hat{\mathcal{L}} = \frac{1}{2}(\mathbf{w} - \mathbf{w}^* + \frac{1}{\sqrt{B}}\boldsymbol{\epsilon})^T H (\mathbf{w} - \mathbf{w}^* + \frac{1}{\sqrt{B}}\boldsymbol{\epsilon})
\end{align}
with $\boldsymbol{\epsilon} \sim \mathcal{N}(\mathbf{0}, \Sigma)$ and $B$ the minibatch size. Note that we use boldface notation for vectors in this analysis for notational clarity. The NQP can be seen as an approximation of the loss function in the final phase of learning, where we initialize the late-phase ensemble. Despite its apparent simplicity, it remains a challenging optimization problem that has important similarities with stochastic mini-batch training in deep neural networks \citep{schaul_no_2013, martens_second-order_2016, wu_understanding_2018, zhang_which_2019, zhang_lookahead_2019}. For the simple loss landscape of the NQP, there are three main strategies to improve the expected loss after convergence: (i) increase the mini-batch size $B$ \citep{zhang_which_2019}, (ii) use more members $K$ in an ensemble (c.f.~Section \ref{sec:NQP_full_ensembles} and (iii) decrease the learning rate $\eta$ \citep{schaul_no_2013, martens_second-order_2016, wu_understanding_2018, zhang_which_2019, zhang_lookahead_2019}. The late-phase weights training combines the two first strategies in a non-trivial manner by (i) averaging over the base-weights gradients for all ensemble members and (ii) averaging the late-phase weights in parameter space to obtain a mean-model. The goal of this theoretical analysis is to show that the expected loss after convergence scales inversely with the number of late-phase ensemble members $K$, which indicates that the non-trivial combination of the two strategies is successful.

To model the multiplicative weight interaction between late-phase weights and base weights, we use linear hypernetworks of arbitrary dimension. The linear hypernetworks parameterize the weights as $\mathbf{w} = \theta \mathbf{e}$, with $\theta \in \mathbb{R}^{n \times d}$ the hypernetwork parameters and $\mathbf{e} \in \mathbb{R}^{d}$ the embedding vector. The embedding vectors $\mathbf{e}$ are used as late-phase weights ($\phi$ in the main manuscript) to create a late-phase ensemble with $K$ members, while using a shared hypernetwork $\theta$ as base-weights: $\mathbf{w}_k = \theta \mathbf{e}_k$. Ultimately, we are interested in the expected risk of the the mean model at steady state: 
\begin{align}\label{eq:risk_meanmodel}
    \mathbb{E}[\mathcal{L}^{(ss)}] =  \mathbb{E}_{\rho_{ss}}[\frac{1}{2}(\bar{\mathbf{w}}- \mathbf{w}^*)^T H (\bar{\mathbf{w}}-\mathbf{w}^*)]
\end{align}
with $\bar{\mathbf{w}} \triangleq \frac{1}{K}\sum_k \theta \mathbf{e}_k = \theta \frac{1}{K}\sum_k \mathbf{e}_k \triangleq \theta \bar{\mathbf{e}}$ and $\rho_{ss}$ the steady-state distribution of the parameters. Note that we cannot put $\mathbf{w}^*=\mathbf{0}$ without loss of generality, because the overparameterization of the hypernetworks makes the optimization problem nonlinear.

We start with investigating the discrete time dynamics induced by late-phase learning, after which we derive the corresponding continuous time dynamics to be able to use the rich stochastic dynamical systems literature for analyzing the resulting nonlinear stochastic dynamical system.

\subsection{Discrete Time Dynamics}
As we want to investigate the multiplicative interaction between the shared and late-phase parameters, we substitute $\mathbf{w} = \theta \mathbf{e}$ into \eqref{eq:noisy_loss_weightspace}, instead of computing a new Taylor approximation in the hypernetwork parameter space. Let us take $t$ as the index for the outer loop (updating $\theta$) and $k$ the index for the ensemble member. Then we have the following stochastic minibatch loss:
\begin{align}
    \hat{\mathcal{L}}^{(t,k)} = \frac{1}{2}(\theta^{(t)} \mathbf{e}_k^{(t)} - \mathbf{w}^* +  \frac{1}{\sqrt{B}}\boldsymbol{\epsilon}^{(t,k)})^T H (\theta^{(t)} \mathbf{e}_k^{(t)} - \mathbf{w}^* + \frac{1}{\sqrt{B}}\boldsymbol{\epsilon}^{(t,k)}),
\end{align}
which gives rise to the following parameter updates using late-phase learning with learning rate $\eta$ and minibatch size $B$:
\begin{align}
    \theta^{(t+1)} &= \theta^{(t)} - \eta \frac{1}{K}\sum_k H( \theta^{(t)}\mathbf{e}_k^{(t)} - \mathbf{w}^*)\mathbf{e}_k^{(t)T} + \frac{\eta}{\sqrt{B}} \frac{1}{K}\sum_k H \boldsymbol{\epsilon}^{(t,k)}\mathbf{e}_k^{(t)T} \label{eq:theta_discrete_time_dynamics}\\
    \mathbf{e}_k^{(t+1)} &= \mathbf{e}_k^{(t)} - \eta \theta^{(t)T} H (\theta^{(t)}\mathbf{e}_k^{(t)} - \mathbf{w}^*) + \frac{\eta}{\sqrt{B}} \theta^{(t)T} H \boldsymbol{\epsilon}^{(t,k)} \label{eq:embedding_discrete_time_dynamics}
\end{align}
The above discrete time dynamics are nonlinear, giving rise to a non-Gaussian parameter distribution $\rho$. Hence, it is not possible to characterize these dynamics by the moment-propagating equations of the first and second moment as done in \citet{zhang_which_2019, zhang_lookahead_2019, schaul_no_2013} and \citet{wu_understanding_2018}, without having full access of the parameter distribution $\rho$. Furthermore, because of the hypernetwork parameterization, we cannot decouple the system of equations, even if $H$ and $\Sigma$ are diagonal, which is a common approach in the literature. Therefore, we investigate the corresponding continuous time dynamics, such that we can use the rich literature on stochastic dynamical systems.

\subsection{Continuous Time Dynamics} \label{sec:continuous_time_dynamics}
First, let us define some compact notations for the various parameters.
\begin{align}
    \mathbf{e}_t &\triangleq [\mathbf{e}^{(t)T}_1 \hdots \mathbf{e}^{(t)T}_K]^T\\
    E_t &\triangleq [\mathbf{e}^{(t)}_1 \hdots \mathbf{e}^{(t)}_K]\\
    \boldsymbol{\theta}_t &\triangleq \text{vec}(\theta_t) \\
    \mathbf{x}_t &\triangleq [\boldsymbol{\theta}_t^T, \mathbf{e}_t^T]^T\\
    \boldsymbol{\epsilon}_t &\triangleq [\boldsymbol{\epsilon}^{(t,1)T} \hdots \boldsymbol{\epsilon}^{(t,K)T}]^T,\\
\end{align}
where $\text{vec}(\theta)$ concatenates the columns of $\theta$ in a vector. Then the discrete time dynamics (\eqref{eq:theta_discrete_time_dynamics} and \eqref{eq:embedding_discrete_time_dynamics}) can be rewritten as: 
\begin{align}\label{eq:compact_discrete_dynamics}
    \mathbf{x}_{t+1} = \mathbf{x}_t - \eta F(\mathbf{x}_t) + \frac{\eta}{\sqrt{B}} G(\mathbf{x}_t) \boldsymbol{\epsilon}_t
\end{align}
with 
\begin{align}
    F(\mathbf{x}_t) &\triangleq \begin{bmatrix}
 \frac{1}{K}\sum_k \big(\mathbf{e}_k^{(t)}\otimes H\big)\big(\theta_t \mathbf{e}_k^{(t)} - \mathbf{w}^*\big) \\
\big(I \otimes (\theta_t^TH\theta_t)\big)\mathbf{e}_t - \mathbbm{1}\otimes (\theta_t^TH\mathbf{w}^*)
\end{bmatrix} \\
G(\mathbf{x}_t &\triangleq \begin{bmatrix}
\frac{1}{K}E_t \otimes H \\
I \otimes (\theta_t^T H)
\end{bmatrix} \\
\end{align}
with $\otimes$ the Kronecker product, $I$ an identity matrix of the appropriate size and $\mathbbm{1}$ a vector full of ones of the appropriate size. As a linear transformation of Gaussian variables remains a Gaussian variable, we can rewrite eq. \eqref{eq:compact_discrete_dynamics} as follows:
\begin{align}
    \mathbf{x}_{t+1} = \mathbf{x}_t - \eta F(\mathbf{x}_t) + \frac{\eta}{\sqrt{B}} D(\mathbf{x}_t) \boldsymbol{\zeta}_t
\end{align}
with $D(x_t) \triangleq \big(G(x_t)(I \otimes \Sigma )G(x_t)^T\big)^{0.5}$ and $\boldsymbol{\zeta} \sim \mathcal{N}(0, I)$. Following \cite{liu_deep_2019} and \cite{chaudhari_stochastic_2018}, the corresponding continuous-time dynamics are:
\begin{align}
    \text{d}\mathbf{x}_t = -F(\mathbf{x}_t)\text{d}t + \sqrt{2\beta^{-1}} D(\mathbf{x}_t)\text{d}\mathbf{W}_t
\end{align}
with $\mathbf{W}_t$ Brownian motion and $\beta \triangleq \frac{2B}{\eta}$ the inverse temperature. 
Note that $\sqrt{\eta}$ is incorporated in the noise covariance, such that the correct limit to stochastic continuous time dynamics can be made (\citealp{liu_deep_2019, chaudhari_stochastic_2018}; but see \citealp{yaida_fluctuation-dissipation_2018}). 
For computing the expected loss $\mathbb{E}[\mathcal{L}_t]$ of the mean model, we need to have the stochastic dynamics of this loss. Using the It担 lemma \citep{ito_stochastic_1951, liu_deep_2019}, which is an extension of the chain rule in the ordinary calculus to the stochastic setting, we get
\begin{align}\label{eq:loss_dynamics}
    \text{d}\mathcal{L}(\mathbf{x}_t) = \Big[-\nabla \mathcal{L}(\mathbf{x}_t)^T F(\mathbf{x}_t) + \frac{1}{2} \text{Tr}\big[\tilde{D}H_{\mathcal{L}}\tilde{D}\big]\Big] \text{d}t + \big[\nabla \mathcal{L}(\mathbf{x}_t)^T \tilde{D}\big] \text{d}\mathbf{W}_t
\end{align}
with $\tilde{D} \triangleq \sqrt{2\beta^{-1}} D(\mathbf{x}_t)$ for notational simplicity and $H_{\mathcal{L}}$ the Hessian of $\mathcal{L}$ w.r.t. $\mathbf{x}_t$. As we are interested in the expected risk (\eqref{eq:risk_meanmodel}), we can take the expectation of \eqref{eq:loss_dynamics} over the parameter distribution $\rho_t(\mathbf{x})$ to get the dynamics of the first moment of the loss (also known as the backward Kolmogorov equation \citep{kolmogorov_analytical_1931}): 
\begin{align}\label{eq:kolmogorov_loss}
    \text{d} \mathbb{E}_{\rho_t}\big[\mathcal{L}(\mathbf{x}_t)\big] = \mathbb{E}_{\rho_t} \Big[-\nabla \mathcal{L}(\mathbf{x}_t)^T F(\mathbf{x}_t) + \frac{1}{2} \text{Tr}\big[\tilde{D}^2H_{\mathcal{L}}\big]\Big] \text{d}t
\end{align}
In order to obtain the dynamics of the parameter distribution, the Fokker-Planck equation can be used \citep{jordan_variational_1998}. However, due to the nonlinear nature of the stochastic dynamical system, the distribution is non-Gaussian and it is not possible (to our best knowledge) to obtain an analytical solution for \eqref{eq:kolmogorov_loss}. Nevertheless, we can still gain important insights by investigating the steady-state of \eqref{eq:kolmogorov_loss}. After convergence, the left-hand side (LHS) is expected to be zero. Hence, we have that 
\begin{align}\label{eq:ss_kolmogorov_loss}
     \mathbb{E}_{\rho^{ss}} \big[\nabla \mathcal{L}(\mathbf{x}_{ss})^T F(\mathbf{x}_{ss})\big] = \frac{1}{2} \mathbb{E}_{\rho^{ss}} \big[\text{Tr}[\tilde{D}^2H_{\mathcal{L}}]\big]
\end{align}
The remainder of our arguments is structured as follows. First, we will show that the left-hand-side (LHS) of \eqref{eq:ss_kolmogorov_loss} is the expectation of an approximation of a weighted norm of the gradient $\nabla \mathcal{L}$, after which we will connect this norm to the loss $\mathcal{L}$ of the mean model. Second, we will investigate the RHS to show that the late-phase learning with ensembles lowers the expected risk of the NQP at steady-state. For clarity and ease of notation, we will drop the $ss$ subscripts. The gradient of the mean-model loss is given by: 
\begin{align}
    \nabla \mathcal{L}(\mathbf{x}) = \begin{bmatrix}
 \big(\bar{\mathbf{e}} \otimes H\big)\big(\theta \bar{\mathbf{e}} - \mathbf{w}^*\big) \\
\frac{1}{K} \mathbbm{1} \otimes \big(\theta^TH\theta \bar{\mathbf{e}} - \mathbf{w}^*\big)
\end{bmatrix}
\end{align}
By introducing $\Delta \mathbf{e}_k \triangleq \mathbf{e}_k - \bar{\mathbf{e}}$ and using that $\sum_k \Delta\mathbf{e}_k = 0$, we can rewrite $F(\mathbf{x})$ as: 
\begin{align} \label{eq:F_rewritten}
    F(\mathbf{x}) = \begin{bmatrix} 
    I & 0 \\ 0 & KI \end{bmatrix} \nabla \mathcal{L}(\mathbf{x}) + 
    \begin{bmatrix}
    (\Gamma \otimes H)\boldsymbol{\theta}\\
    \big(I \otimes ( \theta^T H \theta)\big) \Delta \mathbf{e}
\end{bmatrix}
\end{align}
with $\Gamma \triangleq \frac{1}{K} \sum_k \Delta \mathbf{e}_k\Delta\mathbf{e}_k^T$ and $\Delta \mathbf{e}^T \triangleq [\mathbf{e}_1^T ... \mathbf{e}_K^T]$. We see that $F$ is an approximation of the gradient $\nabla \mathcal{L}$ where the lower block of $\nabla \mathcal{L}$ is scaled by $K$. Importantly, the lower block of the second element of the RHS of \eqref{eq:F_rewritten} (the approximation error) will disappear when taking the inner product with $\nabla \mathcal{L}$ and the upper block is not influenced by the number of ensemble members $K$, which we will need later. The LHS of \eqref{eq:ss_kolmogorov_loss} can now be rewritten as:
\begin{align} \label{eq:LHS_kolmogorov}
    \mathbb{E}_{\rho^{ss}} \big[\nabla \mathcal{L}(\mathbf{x})^T F(\mathbf{x})\big] = \mathbb{E}_{\rho^{ss}} \big[\nabla \mathcal{L}(\mathbf{x})^T M \nabla \mathcal{L}(\mathbf{x})\big] +  \mathbb{E}_{\rho^{ss}} \big[\text{Tr}[H\theta\Gamma H(\theta\bar{\mathbf{e}} - \mathbf{w}^*)\bar{\mathbf{e}}^T]\big]
\end{align}
with $M$ the diagonal matrix of \eqref{eq:F_rewritten} (first element of the RHS). The first term of the RHS of \eqref{eq:LHS_kolmogorov} is the expectation of a weighted squared norm of $\nabla \mathcal{L}$, while the second term is an approximation error due to the covariance of $\Delta \mathbf{e}_k$. Hence, we see that the LHS of \eqref{eq:ss_kolmogorov_loss} can be seen as an approximation of a weighted norm of the gradient $\nabla \mathcal{L}$. By investigating the term $\nabla \mathcal{L}(\mathbf{x})^T M \nabla \mathcal{L}(\mathbf{x})$ further, we show that it is closely connected to the loss $\mathcal{L}$.
\begin{align}
    \nabla \mathcal{L}(\mathbf{x})^T M \nabla \mathcal{L}(\mathbf{x}) =  (\bar{\mathbf{w}} - \mathbf{w}^*)^T(\bar{\mathbf{e}}^T\bar{\mathbf{e}}H^2 + H\theta \theta^T H)(\bar{\mathbf{w}} - \mathbf{w}^*)
\end{align}
When comparing to the mean-model loss $\mathcal{L} = (\bar{\mathbf{w}} - \mathbf{w}^*)^TH(\bar{\mathbf{w}} - \mathbf{w}^*)$ we see that the two are tightly connected, both using a weighted distance measure between $\bar{\mathbf{w}}$ and  $\mathbf{w}^*$, with only a different weighting. Taken everything together, we see that we can take the LHS of \eqref{eq:ss_kolmogorov_loss} (and hence also the RHS) as a rough proxy for the expected risk under the steady-state distribution (\eqref{eq:risk_meanmodel}), which will be important to investigate the influence of the amount of ensemble members on the expected risk. \citet{zhu_anisotropic_2018} highlighted this trace quantitiy in \eqref{eq:ss_kolmogorov_loss} as a measurement of the escaping efficiency out of poor minima. However, we assume that we are in the final valley of convergence (emphasized by this convex NQP), so now this interpretation does not hold and the quantity should be considered as a proxy measurement of the width of the steady-state parameter distribution around the minimum. The trace quantity has $H_{\mathcal{L}}$ and $D(\mathbf{x}_{ss})^2$ as main elements, which we structure in block matrices below (for clarity and ease of notation, we drop the subscripts $ss$).


\begin{align}
    H_{\mathcal{L}} &= \begin{bmatrix}
(\bar{\mathbf{e}} \bar{\mathbf{e}}^T) \otimes H & \frac{1}{K} \mathbbm{1}^T \otimes Q^T \\
\frac{1}{K} \mathbbm{1} \otimes Q &  \frac{1}{K^2} \mathbbm{1} \otimes \theta^TH\theta \\
\end{bmatrix} \\
D(\mathbf{x})^2 &= G(I\otimes \Sigma) G^T =  \begin{bmatrix}
\frac{1}{K^2} (EE^T) \otimes (H\Sigma H) & \frac{1}{K} E \otimes (H \Sigma H \theta)\\
\frac{1}{K}  E^T \otimes (\theta^TH \Sigma H) & I \otimes (\theta^TH\Sigma H \theta)
\end{bmatrix}
\end{align}
with $\mathbbm{1}$ a matrix or vector of the appropriate size full of ones, $\bar{\mathbf{e}} \triangleq  1/K \sum_k \mathbf{e}_k$ and the rows of $Q \in \mathbb{R}^{d\times nd}$ given by:
\begin{align}
    Q_{i,:} \triangleq \boldsymbol{\theta}^T\big((\bar{\mathbf{e}}\boldsymbol{\delta}_i^T + \boldsymbol{\delta}_i \bar{\mathbf{e}}^T) \otimes H\big) - \boldsymbol{\delta}_i^T \otimes (\mathbf{w}^{*T}H),
\end{align}
with $\boldsymbol{\delta}_i$ the $i$-th column of an appropriately sized identity matrix.
After some intermediate calculations and rearranging of terms, we reach the following expression for the RHS of \eqref{eq:ss_kolmogorov_loss}:
\begin{align}\label{eq:trace_solution}
    \frac{1}{2} \mathbb{E}_{\rho^{ss}} \big[\text{Tr}[\tilde{D}^2H_{\mathcal{L}}]\big] &= \frac{1}{K\beta} \Big( \mathbb{E}_{\rho^{ss}} \Big[\text{Tr}\big[\tilde{E}^2 \bar{\mathbf{e}} \bar{\mathbf{e}}^T\big]\Big] \text{Tr}\big[H\Sigma H^2\big] + 
    \mathbb{E}_{\rho^{ss}} \Big[\text{Tr}\big[\bar{\mathbf{e}}\otimes (H\Sigma H \theta Q)\big] + ... \nonumber \\  
    &... \text{Tr} \big[\big(\bar{\mathbf{e}}^T \otimes (\theta^T H\Sigma H)\big) Q^T)\big]  + \text{Tr} \big[\theta^TH\Sigma H\theta\theta^TH\theta\big]\Big]\Big),
\end{align}
with $\tilde{E}^2 \triangleq \frac{1}{K} \sum_k \mathbf{e}_k \mathbf{e}_k^T = \frac{1}{K} EE^T$
Note that everything between the big brackets in the RHS is independent of $K$ in expectation. Hence, we see that the RHS of \eqref{eq:ss_kolmogorov_loss} scales inversely by $K$, exactly as the case for full ensembles (see Section \ref{sec:NQP_full_ensembles}). Importantly, the approximation errors in \eqref{eq:F_rewritten} are independent of $K$, hence, the found scaling of $\frac{1}{K}$ in \eqref{eq:trace_solution} translates to a scaling of $\frac{1}{K}$ of the expected risk of the NQP, following the above argumentation. Hence, we see that the non-trivial combination of (i) averaging over the base-weights gradients for all ensemble members and (ii) averaging the late-phase weights $\mathbf{e}_k$ in parameter space to obtain a mean-model, succeeds in scaling the expected loss after convergence inversely by $K$.


\subsection{NQP with full ensembles}\label{sec:NQP_full_ensembles}
As a comparison for the above theoretical results, we also analyze the NQP that uses an ensemble of $K$ full weight configurations $\mathbf{w}_k$ to get a mean model $\bar{\mathbf{w}}$, instead of shared weights $\theta$ and ensemble-member-specific weights $\phi_k$. For the case of linear models, the averaging in weight space to obtain a mean model is equivalent to the averaging of the predictions over the ensemble, which is conventionally done using ensembles. Without loss of generality, we can take $\mathbf{w}^*=0$ (corresponding with a simple reparameterization of $\mathbf{w}$). Using \eqref{eq:noisy_loss_weightspace}, this results in the following parameter updates for the ensemble members:
\begin{align}
    \mathbf{w}_k^{(t+1)} = (I - \eta H) \mathbf{w}_k^{(t)} + \frac{\eta}{\sqrt{B}}H\boldsymbol{\epsilon}^{(t,k)}
\end{align}
The mean model $\bar{\mathbf{w}} \triangleq \frac{1}{K}\sum_k \mathbf{w}_k $ has the following corresponding discrete dynamics: 
\begin{align}\label{eq:full_ensemble_updates}
    \bar{\mathbf{w}}^{(t+1)} = (I - \eta H) \bar{\mathbf{w}}^{(t)} + \frac{\eta}{K\sqrt{B}}H\sum_k \boldsymbol{\epsilon}^{(t,k)}
\end{align}
\paragraph{Exact moment propagating equations.}
As this is a discrete linear system with Gaussian noise, the resulting parameter distributions will also be linear and can be fully characterized by the mean and covariance of the parameters. Taking the expectation and variance of \eqref{eq:full_ensemble_updates} results in: 
\begin{align}
    \mathbb{E}\big[\bar{\mathbf{w}}^{(t+1)}\big] &= (I - \eta H) \mathbb{E}\big[\bar{\mathbf{w}}^{(t)}\big]\\
    \mathbb{C}\big[\bar{\mathbf{w}}^{(t+1)}\big] &= (I - \eta H) \mathbb{C}\big[\bar{\mathbf{w}}^{(t)}\big] (I - \eta H) +  \frac{\eta^2}{KB}H\Sigma H
\end{align}
with $\Sigma$ the covariance matrix of $\boldsymbol{\epsilon}$. For an appropriate $\eta$, the above equations converge to the following fixed points at steady-state: 
\begin{align}
    \mathbb{E}_{\rho^{ss}}\big[\bar{\mathbf{w}}\big] &= \mathbf{0}\\
    \text{vec}\big(\mathbb{C}_{\rho^{ss}}\big[\bar{\mathbf{w}}\big]\big) &= \frac{\eta^2}{KB}\big(I - (I - \eta H)\otimes(I - \eta H)\big)^{-1} \text{vec}\big(H\Sigma H) \label{eq:full_ensemble_covariance_ss}
\end{align}
We see that the steady-state covariance of $\bar{\mathbf{w}}$ and hence of the risk $\mathcal{L}$ scales with $\frac{1}{K}$ ($\mathbb{E}_{\rho^{ss}}[\mathcal{L}] = \mathbb{E}_{\rho^{ss}}[\bar{\mathbf{w}}^TH\bar{\mathbf{w}}] = \text{Tr}\big[H\mathbb{C}_{\rho^{ss}}[\bar{\mathbf{w}}]\big]$). The expected risk $\mathbb{E}_{\rho^{ss}}[\mathcal{L}]$ obtained with computationally expensive full ensembles can be seen as a lower limit that we try to reach with the \textit{economical} ensembles of shared weights $\theta$ and late-phase weights $\phi_k$. Note that for the NQP, increasing the batchsize $B$ has a similar influence as increasing the number of ensemble members $K$, as can be seen in \eqref{eq:full_ensemble_covariance_ss}. 

\paragraph{Continuous time stochastic dynamics.} We can also do a similar continuous time analysis as Section \ref{sec:continuous_time_dynamics} for the case of full ensembles, to better relate it to the results of the late-phase learning with shared parameters. Following the same approach, we get the following expression for the trace term: 
\begin{align}
    \frac{1}{2} \mathbb{E}_{\rho^{ss}} \big[\text{Tr}[\tilde{D}^2H_{\mathcal{L}}]\big] &= \text{Tr}\big[\frac{1}{\beta}\big(I\otimes (H\Sigma H)\big)\frac{1}{K^2}\big(\mathbbm{1}\otimes H\big)\big]\\
    &= \frac{1}{K\beta} \text{Tr}\big[H\Sigma H^2]
\end{align}
When comparing to \eqref{eq:trace_solution}, we see that the economical ensembles with shared parameters reach the same scaling with $\frac{1}{K}$ as a result of ensembling, however, some extra terms that vanish asymptotically for big $K$ appear as a result of the interplay between shared and late-phase parameters. 

\paragraph{Experimental details for Fig.~\ref{fig:NQP-main-results}.} We take the model $w=\theta \, \phi$ (i.e., $K=1$) as our baseline, since this overparameterization could already result in accelerated learning \citep{arora_optimization_2018}. Our parameters are randomly initialized and scaled such that $\bar{w}$ has a fixed distance to $w^*$ of 1. Since the NQP mimics a late phase of learning we set $T_0=0$. We study a problem of dimension $n=100$ and train the model with gradient descent (without momentum).

To validate the theoretical results, we show in Fig.~\ref{fig:NQP-main-results} that
the steady-state reached by our method scales inversely with $K$, similarly to an ensemble of independently-trained models. We run experiments with $K \in [2,5,10,15,20,25]$ and train every configuration for $2 \times 10^7$ iterations until convergence. We average over the last $10^4$ weight updates and over $5$ different random seeds.

\end{document}