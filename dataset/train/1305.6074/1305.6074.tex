\documentclass[envcountsame]{llncs}

\usepackage{amsmath}
\usepackage{subfigure}
\usepackage{booktabs}
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{positioning}
\usetikzlibrary{automata}
\usetikzlibrary{shapes}

\usepackage{multirow}


\title{On the Structure and Complexity of \RegularlyGeneratedLanguageSetsTitle}
\author{Andreas Holzer\inst{1} \and Christian Schallhart\inst{2} \and Michael
  Tautschnig\inst{3} \and Helmut~Veith\inst{1}}
\institute{Vienna University of Technology, Austria \and University of Oxford, UK \and Queen Mary, University of London, UK}

\usepackage{epsfig}
\usepackage{amssymb}
\usepackage{xspace}
\usepackage{url}
\usepackage[ruled,vlined,linesnumbered,shortend]{algorithm2e}
\SetKwInOut{Input}{input}
\SetKwInOut{Requires}{requires}
\SetKwInOut{Returns}{returns}
\SetKw{Yield}{yield}
\SetKw{WriteAs}{write}
\SetKw{WriteAsAs}{as}
\SetKw{Violates}{violates}
\SetKw{With}{with}
\SetKwInOut{Yields}{yields}
\usepackage{tabularx}
\usepackage{todonotes}
\usepackage{paralist}

\newcommand{\PSPACE}{\complexityclass{PSpace}}
\newcommand{\DSPACE}{\complexityclass{DSpace}}
\newcommand{\PTIME}{\complexityclass{PTime}}
\newcommand{\tEXPTIME}{\complexityclass{2ExpTime}}
\newcommand{\tEXPSPACE}{\complexityclass{2ExpSpace}}
\newcommand{\EXPSPACE}{\complexityclass{ExpSpace}}

\newcommand{\complexityclass}[1]{\ensuremath{\textsc{#1}}\xspace}

\newcommand{\rationalset}{\ensuremath{\mathcal{R}}\xspace}
\newcommand{\representation}{\ensuremath{{\sf rep}}\xspace}
\newcommand{\basiccheck}{\ensuremath{{\sf basiccheck}}\xspace}
\newcommand{\membership}{\ensuremath{{\sf membership}}\xspace}
\newcommand{\setenumeration}{\ensuremath{{\sf enumerate}}\xspace}
\newcommand{\unfold}{\ensuremath{{\sf unfold}}\xspace}
\newcommand{\order}{\ensuremath{{\mathcal O}}\xspace}
\newcommand{\unfoldstep}{\ensuremath{{\sf ufs}}\xspace}

\newcommand{\minlength}{\ensuremath{{\sf minlen}}\xspace}

\newcommand{\cL}{\ensuremath{\mathcal{L}}\xspace}
\newcommand{\cR}{\ensuremath{\mathcal{R}}\xspace}
\newcommand{\fR}{\ensuremath{\mathfrak{R}}\xspace}
\newcommand{\bN}{\ensuremath{\mathbb{N}}\xspace}
\newcommand{\cA}{\ensuremath{\mathcal{A}}\xspace}
\newcommand{\cM}{\ensuremath{\mathcal{M}}\xspace}
\newcommand{\boolTrue}{\ensuremath{\mathbf{true}}\xspace}
\newcommand{\boolFalse}{\ensuremath{\mathbf{false}}\xspace}

\newcommand{\dotdiv}{\:\ensuremath{\mathaccent\cdot-}\:}
\newcommand{\dotcup}{\:\ensuremath{\mathaccent\cdot\cup}\:}
\newcommand{\dotcap}{\:\ensuremath{\mathaccent\cdot\cap}\:}
\newcommand{\timescup}{\mathrel{\ooalign{\hss\hss\cr}}}
\newcommand{\timescap}{\mathrel{\ooalign{\hss\hss\cr}}}
\newcommand{\timesminus}{\:\ensuremath{\scriptscriptstyle\mathaccent\times{\textstyle-}}\:}

\renewcommand{\epsilon}{\pleaseusevarepsiloninstead}

\newcommand{\unionfreerep}{\ensuremath{\mathsf{unionfreedecomp}}\xspace}
\newcommand{\criticalpos}{\ensuremath{\mathsf{critical}}\xspace}
\newcommand{\Linit}{\ensuremath{L_\mathsf{init}}\xspace}

\newcommand{\query}[1]{\medskip \noindent{\small\hspace*{1em}\tt #1}\medskip\noindent}
\newdimen{\queryindent}
\settowidth{\queryindent}{\query{> }}
\newcommand{\quoteop}[1]{\text{\tt "}#1\text{\tt "}}
\newcommand{\queryinline}[1]{{\small\tt #1}\xspace}
\newcommand{\queryinlinemath}[1]{\text{\tt #1}}

\newcommand{\quoted}[1]{" #1 "}
\newcommand{\regexp}[1]{\mathsf{#1}}

\newcolumntype{C}{>{\centering}X}
\newcolumntype{Z}{>{\centering\arraybackslash}X}

\newcommand{\RegularlyGeneratedLanguageSets}{rational sets of regular languages\xspace}
\newcommand{\RegularlyGeneratedLanguageSet}{rational set of regular languages\xspace}
\newcommand{\RegularlyGeneratedLanguageSetAbbrev}{RSRL\xspace}
\newcommand{\RegularlyGeneratedLanguageSetsAbbrev}{RSRLs\xspace}
\newcommand{\RegularlyGeneratedLanguageSetsStart}{Rational sets of regular languages\xspace}
\newcommand{\RegularlyGeneratedLanguageSetsStartAbbrev}{RSRL\xspace}
\newcommand{\RegularlyGeneratedLanguageSetsTitle}{Rational Sets of Regular Languages\xspace}
\newcommand{\RegularlyGeneratedLanguageSetsTitleAbbrev}{RSRL\xspace}
\newcommand{\ARegularlyGeneratedLanguageSet}{rational\xspace}
\newcommand{\ARegularlyGeneratedLanguageSetTitle}{Rational\xspace}

\newtheorem{fact}[theorem]{Fact}

\newcommand{\FSHELL}{\textsc{Fshell}\xspace}
\newcommand{\FQL}{FQL\xspace}

 
\begin{document}

\maketitle

\thispagestyle{plain} 
\pagestyle{plain} 


\begin{abstract}
In a recent thread of papers, we have introduced \FQL, a precise specification
language for test coverage, and developed the test case generation engine \FSHELL
for ANSI C. In essence, an \FQL test specification amounts to a set of regular languages,
each of which has to be matched by at least one test execution. To describe such sets of regular
languages, the \FQL semantics uses an automata-theoretic concept
known as \RegularlyGeneratedLanguageSets (\RegularlyGeneratedLanguageSetsAbbrev). \RegularlyGeneratedLanguageSetsAbbrev are automata whose alphabet
consists of regular expressions. Thus, the language accepted by the automaton is a set of
regular expressions.

In this paper, we study RSRLs from a theoretic point of view. More specifically, we analyze
RSRL closure properties under common set theoretic operations, and the complexity of membership checking,
i.e., whether a regular language is an element of a \RegularlyGeneratedLanguageSetAbbrev. For all questions we investigate both the general
case and the case of finite sets of regular languages. Although a few properties are left as open problems,
the paper provides a systematic semantic foundation for the test specification language \FQL.
\end{abstract}
 \section{Introduction}
\label{sec:introduction}

Despite the success of model checking and theorem proving, software testing has a dominant role
in industrial practice. In fact, state-of-the-art development guidelines such as the avionic
standard DO-178B~\cite{do-178b} are heavily dependent on test coverage criteria. It is therefore quite
surprising that the formal specification of coverage criteria has been a blind spot in the
formal methods and software engineering communities for a long time.

In a recent thread of
papers~\cite{FQL-ASE,holzer11:_seaml_testin_for_model_and_code,holzer10:_introd_to_test_specif_in_fql,holzer09:_query_dirven_progr_testin,holzer08,DBLP:conf/esop/BeyerHTV13},
we have addressed this situation and introduced the \FSHELL Query
Language (\FQL) to specify and tailor coverage criteria, together with
\FSHELL, a tool to generate matching test suites for ANSI C programs.
At the semantic core of \FQL, test goals are described as regular expressions whose alphabet are the edges
of the program control flow graph (CFG). For example, to cover a particular CFG edge , one can use the
regular expression . Importantly, however, a coverage criterion usually contains
not just a single test goal, but a (possibly large) number of test goals -- e.g.~{\em all} basic blocks
of a program. \FQL therefore employs regular languages which can express sets of regular expressions.
To this end, the alphabet contains not only the CFG edges but also \emph{postponed regular expressions} over these edges, written within quotes.

For example,  describes the language   . Each of these words is a regular expression that will then serve as a test goal. Following~\cite{membership},
  we call such languages \emph{\RegularlyGeneratedLanguageSets
  (\RegularlyGeneratedLanguageSetAbbrev).}

The goal of this paper is to initiate a systematic study of \RegularlyGeneratedLanguageSetsAbbrev from a
theoretical point of view, considering closure properties and complexity of common set-theoretic operations.
Thus, this paper is a first step towards a systematic foundation of \FQL. \RegularlyGeneratedLanguageSetsAbbrev have
a similar role for test specifications as relational algebra has for databases. In particular, a good understanding
of set-theoretic operations is necessary for systematic algorithmic optimization and manipulation of test specifications.
First results on query optimization for \FQL have been obtained in \cite{DBLP:conf/esop/BeyerHTV13}.

A \RegularlyGeneratedLanguageSet is given by a regular
language  over alphabet , and a \emph{regular language
  substitution} , mapping
each symbol  to a regular language 
over alphabet .
We extend  to words  with , and set  for~.






\begin{definition}[\RegularlyGeneratedLanguageSetsTitle,
  \RegularlyGeneratedLanguageSetsAbbrev~\cite{membership}]
  \label{def:rational-set}
  A set \rationalset of regular languages over  is called
  \emph{\ARegularlyGeneratedLanguageSet,} written , if there exists
  a finite alphabet , a regular language , and a regular language substitution , such that 
The \RegularlyGeneratedLanguageSetAbbrev~\rationalset is \emph{Kleene star free,} if  is
  given as Kleene star free regular expression.
\end{definition}


Depending on context, we refer to \rationalset as a set of languages
or as a pair~, but we always write  iff
.
\label{ex:intro}
  Consider the above specification  over base alphabet .
To represent this specification as
  \RegularlyGeneratedLanguageSetAbbrev , we
  set , containing a fresh
  symbol  for the quoted expression
  .
We set  with
   and
   for .
Thus  contains the words  with , as desired.






Note that the \RegularlyGeneratedLanguageSetAbbrev above is finite
with exactly four elements.
This is of course not atypical: in concrete testing applications, \FQL
generates finite sets of test goals, since it relies on \emph{Kleene
  star free} \RegularlyGeneratedLanguageSetsAbbrev only.
For future applications, however, it is well possible to consider
infinite sets of test goals e.g. for unbounded integer and real valued
variables or for path coverage criteria which are either matched
partially, or by abstract executions.
In this paper, we are therefore considering the general, finite, and
Kleene star free case.


\begin{example}
  Consider the alphabets~
  and~. Then,
\begin{inparaenum}[\bfseries(1)]
  \item  with ,
    , and , we obtain the
    \RegularlyGeneratedLanguageSet ;
  \item with ,
    , and , we obtain  for
    all  with ;
  \item with ,
    , and , we have  and  for all .
  \end{inparaenum}
\end{example}



In the finite case we make an additional distinction for the
subcase where the regular expressions in , i.e., the set of
postponed regular expressions, are fixed. This has practical
relevance, because in the context of \FQL, the results of the
operations on \RegularlyGeneratedLanguageSetAbbrev will be better
readable by engineers if  is unchanged.

















\paragraph{Contributions and Organization.}
In Section~\ref{sec:closure-properties}, we investigate \emph{closure
  properties} of general and finite
\RegularlyGeneratedLanguageSetsAbbrev, considering the operators
product, Kleene star, complement, union, intersection, set difference,
and symmetric difference.
We also consider the case of finite
\RegularlyGeneratedLanguageSetsAbbrev with a fixed language
substitution , as this case is of particular interest for
testing applications.
Next, in Section~\ref{sec:decision-problems}, we investigate the
\emph{complexity} of the decision problems equivalence, inclusion, and
membership for Kleene star free \RegularlyGeneratedLanguageSetsAbbrev.
We also give an algorithm for checking the membership in general and
analyze its complexity.
We close in Section~\ref{sec:conclusion} with a discussion on how our
results reflect back to design decisions for \FQL.

 \section{Related Work}

Afonin et al.~\cite{membership} introduced
\RegularlyGeneratedLanguageSetsStartAbbrev and studied the
decidability of whether a regular language is contained in an
\RegularlyGeneratedLanguageSetsStartAbbrev and the decidability of
whether an \RegularlyGeneratedLanguageSetsStartAbbrev is finite.
Although Afonin et al.~shortly discuss possible upper bounds for the
membership decision problem, their analysis is incomplete due to gaps
in their algorithmic presentation. 
Pin introduced the term \emph{extended automata} for
\RegularlyGeneratedLanguageSetsAbbrev as an example for a formalism that can be expressed by equations~\cite{Pin}, but
did not investigate any of their properties.
In our own related work on \FQL~\cite{FQL-ASE,holzer12:_provin_reach_using_fshel_compet_contr,holzer11:_seaml_testin_for_model_and_code,holzer10:_introd_to_test_specif_in_fql,holzer09:_query_dirven_progr_testin,holzer08,DBLP:conf/esop/BeyerHTV13}, we deal with practical
issues arising in testcase generation. Note that \FQL uses a language layer on top of 
\RegularlyGeneratedLanguageSetsAbbrev which extracts the alphabet from the program using
a convenient syntax. 
In conclusion, we are unaware of related work that considers the properties we study here.


Let us finally discuss other work whose terminology is similar to \RegularlyGeneratedLanguageSetsAbbrev without
direct technical relation. Barcel{\'o} et al.~define \emph{rational relations}, which are
relations between words over a common alphabet, whereas we consider
sets of regular languages~\cite{DBLP:conf/lics/BarceloFL12}.
Barcel{\'o} et al.~also investigate \emph{parameterized regular
  languages}~\cite{DBLP:journals/tcs/BarceloRL13}, where words are
obtained by replacing variables in expressions with alphabet symbols.
\emph{Metaregular languages} deal with languages recognized by
automata with a time-variant
structure~\cite{1967Agasandyan,Salomaa196885}.
Lattice Automata~\cite{lattice-automata} only consider lattices that
have a unique complement element, whereas
\RegularlyGeneratedLanguageSetsAbbrev are not closed under complement
(no \RegularlyGeneratedLanguageSetAbbrev has a
\RegularlyGeneratedLanguageSetAbbrev as complement).
 \section{Closure Properties}
\label{sec:closure-properties}

\paragraph*{Operators.}
\label{sec:operators}
We investigate the closure properties of \RegularlyGeneratedLanguageSetsAbbrev, considering
standard set theoretic operators, such as union, intersection, and
complement, and variants thereof, fitting \RegularlyGeneratedLanguageSetsAbbrev. 
In particular, we apply those operators also to pairs in the
\emph{Cartesian product} of \RegularlyGeneratedLanguageSetsAbbrev, and \emph{point-wise} to
each element in a \RegularlyGeneratedLanguageSetAbbrev and another given regular language.

\begin{definition}[Operations on \RegularlyGeneratedLanguageSetsTitleAbbrev]
  \label{def:ops}
Let  and  be \RegularlyGeneratedLanguageSetsAbbrev and let
   be a regular language.  Then, we define the following operations
  on \RegularlyGeneratedLanguageSetsAbbrev:
  \begin{center}
  {
  	\relsize{-1}
    \begin{tabularx}{\textwidth}{p{10.5em}lp{2em}X}
      \toprule
      Operation & Definition & \\
      \midrule
      
      Product &  & = & 
      \\
      
      Kleene Star &  & = & 
      \\
      
      \hspace*{2em}Point-wise &  & = & 
       \\
      
      Complement &  & = & 
       \\
      
      \hspace*{2em}Point-wise &  & = & 
       \\
      
      Binary Operators & \multicolumn{3}{l}{
        ,\ \ 
        ,\ \ 
        \ \ 
        \hfill (standard def.)
}\\
      


     \hspace*{2em}Point-wise\hfill &  & = &  
      \\
      
      \hspace*{2em}Cartesian &  & = & 
      \\
      
      Symmetric Difference &  & = & 
      \\			
      \bottomrule
    \end{tabularx}
   }
  \end{center}
\end{definition}


\paragraph*{Language Restrictions.}
\label{sec:lang-restr}
We analyze three different classes of \RegularlyGeneratedLanguageSetsAbbrev for being closed
under these operators:
\begin{inparaenum}[\bfseries(1)]
\item General \RegularlyGeneratedLanguageSetsAbbrev,
\item finite \RegularlyGeneratedLanguageSetsAbbrev, and
\item finite \RegularlyGeneratedLanguageSetsAbbrev with a fixed
  language substitution .
\end{inparaenum}
For closure properties, we do \emph{not distinguish} between Kleene
star free and finite \RegularlyGeneratedLanguageSetsAbbrev, since
every finite \RegularlyGeneratedLanguageSetAbbrev is expressible as
Kleene star free \RegularlyGeneratedLanguageSetAbbrev (however, given
a \RegularlyGeneratedLanguageSetAbbrev with Kleene star, it is
non-trivial to decide whether the given
\RegularlyGeneratedLanguageSetAbbrev it finite or not~\cite{membership}).
Therefore, all closure properties for finite
\RegularlyGeneratedLanguageSetsAbbrev apply to Kleene star free
\RegularlyGeneratedLanguageSetsAbbrev as well.
Hence, cases {\bfseries(2-3)} correspond to \FQL.
Case {\bfseries(3)} is relevant for usability in practice, allowing to
apply the corresponding operators without constructing a new language
substitution. 
This does not only significantly reduce the search space but also
provides more intuitive results to users.

\begin{theorem}[Closure Properties of \RegularlyGeneratedLanguageSetsTitleAbbrev]
  \label{thm:closure-properties}
The following Table summarizes the closure properties for
  \RegularlyGeneratedLanguageSetsAbbrev.
\begin{center}
  	{
	  	\relsize{-1}
	    \begin{tabularx}{\textwidth}{p{9.5em}r@{\hspace{.5em}}CCZ}
	      \toprule
	      Operation & & \multicolumn{3}{c}{Closure Property}\\\cmidrule{3-5}
	               & & General  & \multicolumn{2}{c}{Finite \RegularlyGeneratedLanguageSetsAbbrev}\\\cmidrule{4-5}
	        \multicolumn{3}{l}{\relsize{-1}(+ closed\ \ \ \ - not closed\
              \ \ \ ? unknown)}             & General & Fixed Subst.\\
	      \midrule
	      Product     & Prop.~\ref{prop:closure:product-kleene} & +       & +       & + \\
	      Kleene Star & Prop.~\ref{prop:closure:product-kleene}    & +       & -       & - \\
	      \hspace*{2em}Point-wise & Prop.~\ref{prop:closure:pw-star}       & -       & +       & - \\
	      
	      Complement              & Prop.~\ref{prop:closure:complement}      & -       & -       & - \\
	      \hspace*{2em}Point-wise & Prop.~\ref{prop:closure:pw-complement}    & -       & +       & - \\
	
	      Union         & Prop.~\ref{prop:closure:union}        & +       & +       & + \\
	      \hspace*{2em}Point-wise & Prop.~\ref{prop:closure:pw-union}      & -       & +       & - \\
	      \hspace*{2em}Cartesian  &  Cor.~\ref{cor:catesian-binary}  & -       & +       & - \\
	      
	      Intersection  & Prop.~\ref{prop:closure:intersection}    & ?       & +       & + \\
	      \hspace*{2em}Point-wise & Prop.~\ref{prop:closure:pw-intersection}   & -       & +       & - \\
	      \hspace*{2em}Cartesian  &  Cor.~\ref{cor:catesian-binary} & -       & +       & - \\
	      
	      Difference    & Prop.~\ref{prop:closure:difference}     & ?       & +       & + \\
	      \hspace*{2em}Point-wise & Prop.~\ref{prop:closure:pw-difference}    & -       & +       & - \\
	      \hspace*{2em}Cartesian  & Cor.~\ref{cor:catesian-binary}   & -       & +       & - \\
	      \hspace*{2em}Symmetric  & Prop.~\ref{prop:closure:sym-difference}   & ?       & +       & + \\
	      \bottomrule
	    \end{tabularx}
    }
  \end{center}
\end{theorem}




\paragraph*{Unifying Alphabets.}
\label{sec:unifying-alphabets}
Let  and  be \RegularlyGeneratedLanguageSetsAbbrev over a
common alphabet  with ,
, and .
Then we create a unified alphabet  and a unified language
substitution  with
.
We obtain  where  is derived
from  by substituting each symbol  with
.
Hence without loss of generality, we \textbf{fix} the
\textbf{alphabets}  and  with \textbf{language
  substitution}~, allowing our \RegularlyGeneratedLanguageSetsAbbrev only to differ
in the generating languages .
When we discuss binary operators, we freely refer to \textbf{\RegularlyGeneratedLanguageSetsAbbrev}  for , in case of unary
operators to , and in case of point-wise
operators to the regular language . 


\paragraph*{General Observations.}
We exploit in our proofs some general observations on the cardinality
of \RegularlyGeneratedLanguageSetsAbbrev.
Moreover, we prove all closure properties of Cartesian binary
operators by reducing the point-wise operators to the Cartesian
one.
For space reasons, we show this generic argument only in
Appendix~\ref{sec:proofs:cart-binary-oper}.


\begin{fact}[Finite Sets of Regular Languages are \ARegularlyGeneratedLanguageSetTitle]
  \label{fact:finite-regular-sets-are-rational}
  Every finite set of regular languages is \ARegularlyGeneratedLanguageSet. 
\end{fact}

\begin{proof}
  For a finite set of regular languages , we set
   for all , taking fresh
  symbols .
With  we
  obtain .\qed
\end{proof}


\begin{fact}[Cardinality of \RegularlyGeneratedLanguageSetsTitleAbbrev]
  \label{fact:rational-sets-cardinality}
  A \RegularlyGeneratedLanguageSetAbbrev contains at most countably many languages. In
  particular,  is not a \RegularlyGeneratedLanguageSetAbbrev. 
\end{fact}

\begin{proof}
  A \RegularlyGeneratedLanguageSetAbbrev  is countable, as 
  contains countably many words, and  holds.
Since  is uncountable, it is not a \RegularlyGeneratedLanguageSetAbbrev. \qed
\end{proof}



\subsection{Product and Kleene Star}
\label{sec:product-kleene-star}



\begin{proposition}[Closure of Product and Kleene Star]
  \label{prop:closure:product-kleene}
  \begin{inparaenum}[\normalfont\bfseries(1)]
  \item  is a \RegularlyGeneratedLanguageSetAbbrev,
    defined over the same substitution . If 
    are finite, then  is also
    finite.
  \item  is a \RegularlyGeneratedLanguageSetAbbrev.
It is in general infinite even if  is finite.
  \end{inparaenum}
\end{proposition}

\begin{proof}
  \begin{inparaenum}[\bfseries(1)]
  \item We construct  with  and obtain .
  \item We construct  with 
    setting  and
     otherwise, and obtain
    .
Consider the finite \RegularlyGeneratedLanguageSetAbbrev ,
    then,  is the infinite \RegularlyGeneratedLanguageSetAbbrev .
\qed
  \end{inparaenum}
\end{proof}

In the following we consider the set  of \emph{shortest words}
of a language , disregarding , defined with
.
We also refer to the shortest words  of a \RegularlyGeneratedLanguageSetAbbrev  with
. 

\begin{lemma}
  \label{lemma:minimal-words}
  Let  hold for all .
Then, for each  and shortest word , there exists a  such that .
\end{lemma}

\begin{proof}
  We start with a little claim: 
Because of  for all
  , we have 
  for  and all .


  Assume  with  for all
  .
Then  with , and since
  ,  for some . We
  fix such a .
From the claim above, we get , leading to a contradiction:
If , then  is not a shortest word in
  , as  is shorter. 
If , we contradict our assumption with
  .  


  Thus, we have shown that there exists a  with
  .
It remains to show .
Assuming that  is
  shorter than , we quickly arrive at a contradiction:
 from the claim above,
  implies that  would not be a shortest word in
   in the first place, i.e.,
  . 
\qed
\end{proof}


\begin{corollary}
  \label{cor:finite-number-of-shortest-words}
  Let  hold for all .
Then the set of shortest words  is finite.
\end{corollary}

\begin{proof}
  Lemma~\ref{lemma:minimal-words} states for each word , we have  for some
  .
But there are only finitely many symbols , each
  generating only finitely many shortest words in
  . 
Hence  must be finite.\qed
\end{proof}




\begin{proposition}[Closure of Point-wise Kleene Star]
  \label{prop:closure:pw-star}
  \begin{inparaenum}[\normalfont\bfseries(1)]
  \item\label{prop:closure:pw-star:a} In general,
     is not a \RegularlyGeneratedLanguageSetAbbrev.
  \item\label{prop:closure:pw-star:b} If  is finite,
     is a finite \RegularlyGeneratedLanguageSetAbbrev.
  \item\label{prop:closure:pw-star:c} In the latter case, expressing
     requires a new language
    substitution~.
\end{inparaenum}
\end{proposition}

\begin{proof}
  \begin{inparaenum}[\bfseries(1)]
  \item Consider the \RegularlyGeneratedLanguageSetAbbrev  with  with .
Every language  contains the
    empty word~, and hence,
     for all 
    (disregarding symbols  not occurring in ).
Thus, Corollary~\ref{cor:finite-number-of-shortest-words} applies,
    requiring that the set of shortest words
     is finite. 
This leads to a contradiction, since
     is infinite. 
\item Since  is finite, also
     has to be finite and statement follows
    from Fact~\ref{fact:finite-regular-sets-are-rational}.
\item Consider the \RegularlyGeneratedLanguageSetAbbrev , produced
    from  with  and
    .
Then, ,
    and since  we have to
    introduce a new symbol.  \qed
  \end{inparaenum}
\end{proof}




\subsection{Complement}
\label{sec:complement}


\begin{proposition}[Non-closure under Complement]
  \label{prop:closure:complement}
  Let  be a \RegularlyGeneratedLanguageSet.  Then 
  is not a \RegularlyGeneratedLanguageSet.
\end{proposition}

\begin{proof}
  Fact~\ref{fact:rational-sets-cardinality} states that 
  is countable while  is uncountable.
Hence,  is uncountable and is
  therefore inexpressible as \RegularlyGeneratedLanguageSetAbbrev.\qed
\end{proof}



\begin{proposition}[Closure of Point-wise Complement]
  \label{prop:closure:pw-complement}
  \begin{inparaenum}[\normalfont\bfseries(1)]
  \item\label{prop:closure:pw-complement:a}
     is in general not a \RegularlyGeneratedLanguageSetAbbrev.
  \item\label{prop:closure:pw-complement:b} If  is
    finite,  is a finite \RegularlyGeneratedLanguageSetAbbrev
    as well,
  \item requiring, in general, a modified language substitution.
  \end{inparaenum}
\end{proposition}

\begin{proof}
  \begin{inparaenum}[\bfseries(1)]
  \item Consider the \RegularlyGeneratedLanguageSetAbbrev  with  and .
Then we have . 
For , we have , and consequently,
     and
    .
Furthermore, observe  for
    each .
Assume  is a \RegularlyGeneratedLanguageSetAbbrev.  Then,
    there are  and  such that
    .  
Since  is infinite and  is regular, there
    exists a word  with  and  and  for all .
Because of  for
    some , we obtain  as well.
But then, for all , ,
    i.e., .
This contradicts the observation that .
\item By Fact~\ref{fact:finite-regular-sets-are-rational}.
  \item Let  with
    .  Then,
    .
    But, .  Therefore, we need
    a new symbol to represent .  \qed
  \end{inparaenum}
\end{proof}


In contrast to complementation, some \RegularlyGeneratedLanguageSetsAbbrev have a point-wise
complement which is a \RegularlyGeneratedLanguageSetAbbrev as well; first, this is true for
all finite \RegularlyGeneratedLanguageSetsAbbrev, as shown above, but there are also some
infinite \RegularlyGeneratedLanguageSetsAbbrev which have point-wise complement.

\begin{example}
  The \RegularlyGeneratedLanguageSetAbbrev  with
   has the point-wise
  complement
   with  and
  .
\end{example}



\subsection{Union}
\label{sec:union}


\begin{proposition}[Closure of Union]
  \label{prop:closure:union}
  The set  is a \RegularlyGeneratedLanguageSet,
  expressible as  without changing the
  substitution~.
\end{proposition}

\begin{proof}
  Regular languages are closed under union, hence the claim
  follows.\qed
\end{proof}


The following set of regular languages is not \ARegularlyGeneratedLanguageSet.
We will use it in the proof of Proposition~\ref{prop:closure:pw-union} to show that, in general, \RegularlyGeneratedLanguageSetsAbbrev are not closed under point-wise union.
\begin{example}
	\label{expl:pumping-lemma}
Consider the set .
	 contains infinitely many languages, therefore, any \RegularlyGeneratedLanguageSetAbbrev , with , requires a regular language  containing infinitely many words.
	By  we denote the set .
	Then, .
	There must be a word  such that , for all  (cf.~pumping lemma for regular languages~\cite{DBLP:books/aw/HopcroftU79}).
	Furthermore, there must be such a word  such that , , , and .
	This is due to the fact that we have to generate arbitrary long words .
	We can assume that  because otherwise , for all .
	Therefore,  for some .
	Since  has to be true, we can assume w.l.o.g.~that .
	But, then .
	This is a contradiction to the fact that, for all , .
\end{example}


\begin{proposition}[Closure of Point-wise Union]
  \label{prop:closure:pw-union}
  \begin{inparaenum}[\normalfont\bfseries(1)]
  \item\label{prop:closure:pw-union:a} The set  is, in general, not a \RegularlyGeneratedLanguageSetAbbrev.
  \item\label{prop:closure:pw-union:b} The set  is a \RegularlyGeneratedLanguageSetAbbrev for finite .
  \item\label{prop:closure:pw-union:c} In the latter case, the
    resulting \RegularlyGeneratedLanguageSetAbbrev requires in general a different language
    substitution.
  \end{inparaenum}
\end{proposition}

\begin{proof}
  \begin{inparaenum}[\bfseries(1)]
  \item Let  with
     and  and let .  Then,  which is not a \RegularlyGeneratedLanguageSetAbbrev, as shown in
    Example~\ref{expl:pumping-lemma}.
  \item By Fact~\ref{fact:finite-regular-sets-are-rational}.
  \item\label{proof:star-free-fixed-alphabet-point-wise-union} Let
     with , , 
    and let .  Then, , which is inexpressible with . \qed
  \end{inparaenum}
\end{proof}









\subsection{Intersection}
\label{sec:intersection}


\begin{proposition}[Closure of Intersection]
	\label{prop:closure:intersection}
Let  and
       be two finite \RegularlyGeneratedLanguageSetsAbbrev using the same
      language substitution~.  Then,  is a finite \RegularlyGeneratedLanguageSetAbbrev which can be expressed
      using the language substitution~.
\end{proposition}

\begin{proof}
We can enumerate each word  and check whether there is a word  such that .
	If so, we keep  in a new set  and .
	\qed
\end{proof}


In general, \RegularlyGeneratedLanguageSetsAbbrev are not closed under point-wise intersection
but they are closed under point-wise intersection when restricting to
finite \RegularlyGeneratedLanguageSetsAbbrev.


\begin{proposition}[Closure of Point-wise Intersection]
  \label{prop:closure:pw-intersection}
  \begin{inparaenum}[\normalfont\bfseries(1)]
  \item\label{prop:closure:pw-intersection:a} \RegularlyGeneratedLanguageSetsStartAbbrev are not
    closed under point-wise intersection.
  \item\label{prop:closure:pw-intersection:b} For finite
    \rationalset  is a finite \RegularlyGeneratedLanguageSetAbbrev,
  \item\label{prop:closure:pw-intersection:c} in general requiring a
    different language substitution.
  \end{inparaenum}
\end{proposition}

\begin{proof}
  \begin{inparaenum}[\bfseries(1)]
  \item Let  with 
    and , and set .  
Then .  
In Example~\ref{expl:pumping-lemma}, we showed that
     is not a \RegularlyGeneratedLanguageSetAbbrev.
  \item By Fact~\ref{fact:finite-regular-sets-are-rational}.
  \item Let  with  and
    , and set .
Then,  which in
    inexpressible via .  \qed
  \end{inparaenum}
\end{proof}








\subsection{Set Difference}
\label{sec:set-difference}




\begin{proposition}[Closure of Difference]
  \label{prop:closure:difference}
For finite 
    and ,  is a
    finite \RegularlyGeneratedLanguageSetAbbrev, expressible as , for some
    .
\end{proposition}

\begin{proof}
Set  and
    the claim follows. \qed
\end{proof}


\begin{proposition}[Closure of Point-wise Difference]
  \label{prop:closure:pw-difference}
  \begin{inparaenum}[\normalfont\bfseries(1)]
  \item\label{prop:closure:pw-difference:a} In general,  is not a \RegularlyGeneratedLanguageSetAbbrev.
  \item\label{prop:closure:pw-difference:b} 
    is a finite \RegularlyGeneratedLanguageSetAbbrev for finite \rationalset, 
  \item\label{prop:closure:pw-difference:c} requiring in general a
    different language substitution.
  \end{inparaenum}
\end{proposition}

\begin{proof}
  \begin{inparaenum}[\bfseries(1)]
  \item Let  with
     and .  Let .  Then,  which is
    not a \RegularlyGeneratedLanguageSetAbbrev (see Example~\ref{expl:pumping-lemma}).
  \item By Fact~\ref{fact:finite-regular-sets-are-rational}.
  \item Let  with
     and let .  Then,
    , requiring a new
    symbol.\qed
	\end{inparaenum}
\end{proof}





\begin{proposition}[Closure of Symmetric Difference]
  \label{prop:closure:sym-difference}
Let  and
     be finite \RegularlyGeneratedLanguageSetsAbbrev using the same language
    substitution~.  Then,
     is a finite \RegularlyGeneratedLanguageSetAbbrev and
    can be expressed using the language substitution~.
\end{proposition}

\begin{proof}
	The proof follows immediately from the closure properties of union, intersection, and difference.
	\qed
\end{proof}


%
 \section{Decision Problems}
\label{sec:decision-problems}

Given a a regular language  and a
\RegularlyGeneratedLanguageSetAbbrev 
over the alphabets  and , the \emph{membership
  problem} is to decide whether  holds.
Given another , also over the
alphabets  and , the \emph{inclusion problem} asks
whether  holds, and the
\emph{equivalence problem,} whether 
holds.


\begin{theorem}[Equivalence, Inclusion, and Membership for Kleene star
  free \RegularlyGeneratedLanguageSetsAbbrev]
  \label{thm:kleene-star-free}
Membership, inclusion, and equivalence are \PSPACE-complete for
  Kleene star free \RegularlyGeneratedLanguageSetsAbbrev. 
\end{theorem}

This holds true, since in case of Kleene star free
\RegularlyGeneratedLanguageSetsAbbrev, we can enumerate the regular
expressions defining all member languages in \PSPACE.
Given the \PSPACE-completeness of regular language equivalence, we
compare a given regular expression with all member languages, solving
the membership problem in \PSPACE.
Doing so for all languages of another
\RegularlyGeneratedLanguageSetAbbrev solves the inclusion problem, and
checking mutual inclusion yields an algorithm for equivalence.
This approach does \emph{not} immediately generalize to finite
\RegularlyGeneratedLanguageSetsAbbrev, since finite
\RegularlyGeneratedLanguageSetsAbbrev  may be generated from an infinite  with Kleene stars.


In the general case, the situation is quite different:
Previous work shows that the membership problem is
decidable~\cite{membership}.
Taking this work as starting point, we give a first \tEXPSPACE upper
bound on the complexity of the problem.
A corresponding lower bound is missing, however we expect the problem
to be at least \EXPSPACE-hard.
Due to space reasons, we only give an overview on the algorithm in the
paper and must defer its details to the appendix.
Finally, the decidability of inclusion and equivalence are still open
problems.




\subsection{Membership for general \RegularlyGeneratedLanguageSetsAbbrev}
\label{sec:memb-gener-case}

\begin{algorithm}[tbp]
  \Input{regular languages , ,\\
    \hspace*{4mm} regular language substitution  with
     for all , and\\
    \hspace*{4mm} all as regular expressions}
  \Returns{ iff  (i.e., iff )}

  \ForEach{}{ \label{line:mem:decomp-iteration}
    \lIf{}{\label{line:mem:check}
      \Return \;}}
  \Return \;
  \caption{}
  \label{alg:membership}
\end{algorithm}


By definition, the membership problem is equivalent to asking whether
there exists a  with .
For checking the existence of such a , we have to check possibly
infinitely many words in  efficiently.
\begin{inparaenum}[\bfseries (A)]
  To render this search feasible, we
\item rule out irrelevant parts of , and
\item treat subsets of  at once.
\end{inparaenum}
This leads to the procedure  shown in
Algorithm~\ref{alg:membership}, which first enumerates with  a sufficient set of sublanguages
(Line~\ref{line:mem:decomp-iteration}), and then checks each of those
sublanguages individually (Line~\ref{line:mem:check}).
More specifically, we employ the following optimizations:
\begin{inparaenum}
  We rule out
\item[\bfseries (A.1)] all words  with ,
  and
\item[\bfseries (A.2)] all words  whose language 
  differs from  in the \emph{length of its shortest
    word.} 
We subdivide the remaining search space 
\item[\bfseries (B)] into finitely many suitable languages  and
  check the existence of a  with  in a single
  step.
\end{inparaenum}


We discuss a mutually fitting design of these steps below and
consider the resulting complexity. 
However, due to space limitations, we put the details on
 and  into
Sections~\ref{sec:impl-prop} and~\ref{sec:impl-lemma-as},
respectively, followed by Section~\ref{sec:decision-proofs} with the
corresponding proofs. 



\subsubsection{(A.1) Maximal Rewriting.}
\label{sec:maximal-rewriting}
To rule out all  with , we rely on the
notion of a \emph{maximal -rewriting  of },
taken from~\cite{rewriting}.
 consists of the words  with ,
i.e., we set .
Furthermore, all subsets  are called
\emph{rewritings} of , and if  holds,  is called
\emph{exact} rewriting.
\begin{proposition}[Regularity of maximal rewritings~\cite{rewriting}]
	\label{def:rewriting}
	Let  be a regular
    language substitution.
Then the \emph{maximal -rewriting} of a regular language
     is a regular language over .
\end{proposition}
As all words  with  must be element of
, we restrict our search to .



\subsubsection{(A.2) Minimal Word Length.}
We restrict the search space further by checking the \emph{minimal
  word length,} i.e., we compare the length of the respectively
shortest word in  and . If  and  have
different minimal word lengths,  holds, and hence, we
rule out .
We define the minimal word length  of a language~
with , leading to the
definition of language strata.
\begin{definition}[Language Stratum]
  \label{def:stratum}
  Let  be a language over , and  be a regular language substitution, then the
  \emph{-stratum of ,} denoted as , is the set of
  words in  which generate via  languages of minimal word
  length , i.e., .
\end{definition}
Starting with , we restrict our search further
to .



\subsubsection{(B) 1-Word Summaries.}
\label{sec:1-word-summaries}
It remains to subdivide  into finitely many
subsets , which are then checked efficiently without enumerating
their words .
Here, we only discuss the property of these subsets  which enables
such an efficient check, and later we will describe an enumeration of
those subsets .
When we check a subset , we do not search for a single word  with  but for a finite set  with
.
The soundness of this approach will be guaranteed by the existence of
\emph{1-word summaries:}
A language  has 1-word summaries, if for all
finite subsets  there exists a summary word 
with .
The property we exploit is given by the following proposition.
\begin{proposition}[Membership Condition for Summarizable Languages]
  \label{prop:membership-in-summarizable}
  Let  be a regular language with 1-word
  summaries and .
Then there exists a  with  iff there exists a
  finite subset  with .
\end{proposition}



\subsubsection{Putting it together.}
\label{sec:putting-it-together}
\begin{inparaenum}[]
\item First, combining \textbf{A.2} and \textbf{B}, we obtain
  Lemma~\ref{lem:representation}, to subdivide the search space  into a set  of languages  with
  1-word summaries.
\item Second, in Theorem~\ref{thm:membership-condition}, building upon
  Lemma~\ref{lem:representation} and \textbf{A.1}, we fix
   and iterate through these languages .
We check each of them at once with our membership condition from
  Proposition~\ref{prop:membership-in-summarizable}.
In terms of Algorithm~\ref{alg:membership},
  Lemma~\ref{lem:representation} provides the foundation for
   and
  Proposition~\ref{prop:membership-in-summarizable} underlies
  .
\end{inparaenum}


\begin{lemma}[Summarizable Language Representation,
  adapting~\cite{membership}]
  \label{lem:representation}
  Let  be a regular language.
Then, for each bound , there exists a family
   of union-free regular languages
   with 1-word summaries, such that
   holds.
\end{lemma}



\begin{theorem}[Membership Condition, following~\cite{membership}]
  \label{thm:membership-condition}
  Let  be a
  \RegularlyGeneratedLanguageSetAbbrev and  be a regular language substitution.
Then, for a regular language , we have
  ,
iff there exists an  with a finite subset  with
  .
\end{theorem}


We obtain the space complexity of \membership, depending on the
\emph{size of the expressions,} representing the involved languages.
More specifically, we use the expression sizes  and  and
the summed size
 of the
expressions in the co-domain of .


\begin{theorem}[ runs in \tEXPSPACE]
  \label{thm:membership-complexity}
  More precisely, it runs in  for some constants  and
  .
\end{theorem}

 \section{Conclusion}
\label{sec:conclusion}



Motivated by applications in testcase specifications with FQL, we have
studied general and finite
\RegularlyGeneratedLanguageSetsAbbrev. While we showed that general
\RegularlyGeneratedLanguageSetsAbbrev are not closed under most common
operators, \emph{finite} \RegularlyGeneratedLanguageSetsAbbrev are
closed under all operators except Kleene stars and complementation
(Theorem~\ref{thm:closure-properties}).
This shows that our restriction to Kleene star free and hence finite
\RegularlyGeneratedLanguageSetsAbbrev in \FQL results in a natural
framework with good closure properties.
Likewise, the proven \PSPACE-completeness results for Kleene star free
\RegularlyGeneratedLanguageSetsAbbrev provide a starting point to
develop practical reasoning procedures for Kleene star free
\RegularlyGeneratedLanguageSetsAbbrev and \FQL.
Experience with LTL model checking shows that \PSPACE-completeness
often leads to algorithms which are feasible in practice.
In contrast, for general and possibly infinite
\RegularlyGeneratedLanguageSetsAbbrev, we have described a \tEXPSPACE
membership checking algorithm -- leaving the question for matching
lower bounds open.
Nevertheless, reasoning on general
\RegularlyGeneratedLanguageSetsAbbrev seems to be rather infeasible.



Last but not least, \RegularlyGeneratedLanguageSetsAbbrev give rise to new
and interesting research questions, for instance 
the decidability of inclusion and equivalence for general
\RegularlyGeneratedLanguageSetsAbbrev, and the closure properties left open in this paper.
In our future work, we want to generalize
\RegularlyGeneratedLanguageSetsAbbrev to other base formalisms.
For example, we want  to substitute symbols by context-free
expressions, thus enabling \FQL test patterns to recognize
e.g.~matching of parentheses or emptiness of a stack.  



 
\section*{Acknowledgments}
This work received funding in part by the Austrian National Research
Network S11403-N23 (RiSE) of the Austrian Science~Fund~(FWF), by the
Vienna Science and Technology Fund (WWTF) grant PROSEED, and by the
European Research Council under the European Community's Seventh
Framework Programme (FP7/2007--2013) / ERC grant agreement DIADEM
no.~246858.


\bibliographystyle{splncs}
\begin{thebibliography}{10}

\bibitem{do-178b}
{RTCA DO-178B}:
\newblock Software considerations in airborne systems and equipment
  certification (1992)

\bibitem{FQL-ASE}
Holzer, A., Schallhart, C., Tautschnig, M., Veith, H.:
\newblock How did you specify your test suite.
\newblock In: ASE. (2010)  407--416

\bibitem{holzer11:_seaml_testin_for_model_and_code}
Holzer, A., Januzaj, V., Kugele, S., Langer, B., Schallhart, C., Tautschnig,
  M., Veith, H.:
\newblock {Seamless Testing for Models and Code}.
\newblock In: {FASE'11}. (2011)  278--293

\bibitem{holzer10:_introd_to_test_specif_in_fql}
Holzer, A., Tautschnig, M., Schallhart, C., Veith, H.:
\newblock {An Introduction to Test Specification in FQL}.
\newblock In: {HVC}. (2010)  9--22

\bibitem{holzer09:_query_dirven_progr_testin}
Holzer, A., Tautschnig, M., Schallhart, C., Veith, H.:
\newblock {Query-Dirven Program Testing}.
\newblock In: {VMCAI}. (2009)  151--166

\bibitem{holzer08}
Holzer, A., Tautschnig, M., Schallhart, C., Veith, H.:
\newblock {FSHELL: Systematic Test Case Generation for Dynamic Analysis and
  Measurement}.
\newblock In: {CAV}. (2008)  209--213

\bibitem{DBLP:conf/esop/BeyerHTV13}
Beyer, D., Holzer, A., Tautschnig, M., Veith, H.:
\newblock Information reuse for multi-goal reachability analyses.
\newblock In: ESOP. (2013)  472--491

\bibitem{membership}
Afonin, S., Hazova, E.:
\newblock Membership and finiteness problems for rational sets of regular
  languages.
\newblock In: DLT. (2005)  88--99

\bibitem{Pin}
Pin, J.E.:
\newblock Mathematical foundations of automata theory.
\newblock Lecture Notes (2011)

\bibitem{holzer12:_provin_reach_using_fshel_compet_contr}
Holzer, A., Kroening, D., Schallhart, C., Tautschnig, M., Veith, H.:
\newblock {Proving Reachability using FShell (Competition Contribution)}.
\newblock In: {TACAS}. (2012)  538--541

\bibitem{DBLP:conf/lics/BarceloFL12}
Barcel{\'o}, P., Figueira, D., Libkin, L.:
\newblock Graph logics with rational relations and the generalized intersection
  problem.
\newblock In: LICS. (2012)  115--124

\bibitem{DBLP:journals/tcs/BarceloRL13}
Barcel{\'o}, P., Reutter, J.L., Libkin, L.:
\newblock Parameterized regular expressions and their languages.
\newblock Theor. Comput. Sci. \textbf{474} (2013)  21--45

\bibitem{1967Agasandyan}
{Agasandyan}, G.A.:
\newblock {Variable-Structure Automata}.
\newblock Soviet Physics Doklady (1967)

\bibitem{Salomaa196885}
Salomaa, A.:
\newblock On finite automata with a time-variant structure.
\newblock Information and Control \textbf{13}(2) (1968)  85 -- 98

\bibitem{lattice-automata}
Kupferman, O., Lustig, Y.:
\newblock Lattice automata.
\newblock In: {VMCAI}.
\newblock (2007)  199--213

\bibitem{DBLP:books/aw/HopcroftU79}
Hopcroft, J.E., Ullman, J.D.:
\newblock Introduction to Automata Theory, Languages and Computation.
\newblock Addison-Wesley (1979)

\bibitem{rewriting}
Calvanese, D., Giacomo, G.D., Lenzerini, M., Vardi, M.Y.:
\newblock Rewriting of regular expressions and regular path queries.
\newblock {JCSS} \textbf{64} (2002)  443--465

\bibitem{leung04:_limit_probl_distan_autom}
Leung, H., Podolskiy, V.:
\newblock The limitedness problem on distance automata: Hashiguchi's method
  revisited.
\newblock {TCS} \textbf{310}(1--3) (2004)  147--158

\bibitem{DBLP:conf/focs/MeyerS72}
Meyer, A.R., Stockmeyer, L.J.:
\newblock The equivalence problem for regular expressions with squaring
  requires exponential space.
\newblock In: {SWAT, later FOCS}. (1972)  125--129

\bibitem{decomposition}
Afonin, S., Golomazov, D.:
\newblock Minimal union-free decomposition of regular languages.
\newblock (2009)  83--92

\end{thebibliography}


\appendix
\section{Closure Properties for Cartesian Binary Operators}
\label{sec:proofs:cart-binary-oper}

We deal with Cartesian binary operators generically, by reducing the
point-wise operators to the Cartesian one. 

\begin{lemma}[Reducing Point-Wise to Cartesian Operators]
  \label{lem:reducing-point-wise-to-cartesian}
  Let  be an arbitrary binary operator over sets, let , and let .
  \begin{inparaenum}[\normalfont\bfseries(1)]
  \item If  is not closed under \RegularlyGeneratedLanguageSets,
    then the corresponding  is not closed.
  \item If  is not closed under finite 
  	\RegularlyGeneratedLanguageSets with constant language 
  	substitution, even in presence of a
    symbol  with , then the corresponding
     is also not closed.
  \end{inparaenum}
\end{lemma}

\begin{proof}
  \begin{inparaenum}[\bfseries(1)]
  \item If  is not closed, we fix a violating
    pair  and .
Then we obtain
      for
     and .
Since  is not a \RegularlyGeneratedLanguageSetAbbrev,
     is not as well, and the
    claim follows.
\item If  is inexpressible as a \RegularlyGeneratedLanguageSetAbbrev
    without introducing new symbols in , even in presence of
    , then  is also
    inexpressible without changing .  
\qed
  \end{inparaenum}
\end{proof}


Given Lemma~\ref{lem:reducing-point-wise-to-cartesian}, it is not
surprising that point-wise and Cartesian operators behave for all
discussed underlying binary operators identically, as shown in Theorem~\ref{thm:closure-properties}.


\begin{corollary}[Closure of Cartesian Binary Operators]
  \label{cor:catesian-binary}
  Let .
  \begin{inparaenum}[\normalfont\bfseries(1)]
  \item The set  is, in
    general, not a \RegularlyGeneratedLanguageSet.
  \item The set  is a
    \RegularlyGeneratedLanguageSet if  and  are finite,
  \item requiring in general a new language substitution.
  \end{inparaenum}
\end{corollary}

\begin{proof}
  \begin{inparaenum}[\bfseries(1)]
  \item By Lemma~\ref{lem:reducing-point-wise-to-cartesian} we reduce
    the point-wise case to the Cartesian case, covered by Propositions
    \ref{prop:closure:pw-union}, \ref{prop:closure:pw-intersection},
    and \ref{prop:closure:pw-difference} for union, intersection, and
    set difference, respectively.
The claim follows.
  \item Since all considered operators are closed for regular
    languages, the claim follows from
    Fact~\ref{fact:finite-regular-sets-are-rational}.
  \item Again, with Lemma~\ref{lem:reducing-point-wise-to-cartesian}
    we reduce the point-wise case to the Cartesian case.
The lemma is applicable, as the examples in the proofs of
    Propositions \ref{prop:closure:pw-union},
    \ref{prop:closure:pw-intersection}, and
    \ref{prop:closure:pw-difference} are not jeopardized by a symbol
     with .
Hence the claim follows. \qed
  \end{inparaenum}
\end{proof}


%
 \section{Implementation and Proofs for Section~\ref{sec:decision-problems}}
\label{sec:decision-problems-detail}


\subsection{Implementing }
\label{sec:impl-prop}
Since Lemma~\ref{lem:representation} produces only languages
 with 1-word summaries,
we restrict our implementation to such languages and exploit these
restrictions subsequently.
So, given such a language  over , and a regular language
substitution , we need to
check whether there exists a finite  with
.
We implement this check with the procedure
, splitting the condition of
Proposition~\ref{prop:membership-in-summarizable} into two parts,
namely
\begin{inparaenum}[\bfseries(1)]
\item whether there exists a finite  with
  , and
\item whether  holds.
\end{inparaenum}
While the latter condition amounts to regular language equivalence,
the former requires distance automata as additional machinery.



\begin{definition}[Distance Automaton~\cite{membership}]
  \label{def:distance-automaton}
  A \emph{distance automaton} over an alphabet  is a tuple
   where  is an NFA and  is a distance function, which can be extended
  to a function on words as follows.
The distance function  of a path  is the sum of the
  distances of all edges in .
The distance  of a word  is the minimum of
   for all paths  accepting .

  A distance automaton  is called \emph{limited} if there exists
  a constant  such that  for all words .
\end{definition}

In our check for {\bfseries(1)}, we build a distance automaton which
is limited iff a finite  with  exists.
Then, we rely on the
\PSPACE-decidability~\cite{leung04:_limit_probl_distan_autom} of the
limitedness of distance automata to check whether  exists or not.


\paragraph{Distance-automaton Construction.}
Here, we exploit the assumption that  is a union-free language
over :
Given the regular expression defining , we construct the distance
automaton  following the form of this regular expression:
\begin{itemize}
\item : We construct the finite automaton 
  with .  We extend  to a
  distance automaton by labeling each transition in 
  with .
\item : Given the distance automata  and , we set  where  and , i.e., we connect each final
  state of  to the initial state of  and assign the
  distance  to these connecting transitions.
\item : We construct the distance automaton .  Then,
  , where  and , i.e., we connect each final state of  to the
  initial states of  and assign the corresponding transitions
  the distance .
\end{itemize}
If the resulting distance automaton  is limited, then there
exists a finite subset  such that .
This implies that {\bfseries(1)} holds.



\begin{algorithm}[tbp]
  \SetKw{Build}{build}
  \Input{regular languages , , and\\
    \hspace*{4mm} regular language substitution  with  for all ,\\
    \hspace*{4mm} all given as regular expressions}
   \Requires{ is of form  with }
  \Requires{}
  \Returns{ iff }

  \Build \;\label{line:bm:limitedautomaton}
  \If{ limited}{ \label{line:bm:limitedness}
    \lIf{}{ \label{line:bm:equivalence}
      \Return ;
    }
  }
  \Return \;
  \caption{}
  \label{alg:basicmembership}
\end{algorithm}


So, given , , and all languages in the domain of  as
regular expressions,  in
Algorithm~\ref{alg:basicmembership} first builds 
(Line~\ref{line:bm:limitedautomaton}) and checks its limitedness
(Line~\ref{line:bm:limitedness}), amounting to condition
{\bfseries(1)}.
For condition {\bfseries(2)}, \basiccheck verifies that 
and  are equivalent (Line~\ref{line:bm:equivalence}) and returns
 if both checks succeed.


\begin{lemma}[ runs in \PSPACE]
  \label{lem:pspace-completiy-of-prop1-check}
   runs in \PSPACE, which is optimal, as it
  solves a \PSPACE-complete problem.
\end{lemma}



\subsection{Implementing }
\label{sec:impl-lemma-as}

Our enumeration algorithm must produce the languages
, guaranteeing that all
 have 1-word summaries, and that
 holds (as specified by Lemma~\ref{lem:representation}).
To this end, we rely on a sufficient condition for the existence of
1-word summaries.
First we show this condition with Proposition~\ref{prop:summarizable},
before turning to the enumeration algorithm itself.


\begin{proposition}[Sufficient Condition for 1-Word Summaries]
  \label{prop:summarizable}
  Let  be a union-free language over , given as 
  , with words
   
  and union-free languages .
If  for all  and all , then
   has 1-word summaries.
\end{proposition}



\begin{algorithm}[tbp]
  \Input{regular languages ,
    ,\\
    \hspace*{4mm} regular language substitution  with
     for all , and\\
    \hspace*{4mm} all given as regular expressions}
    \Yields{ for }
  \; \label{line:intersection}
  \lFor{}{\;}\label{line:iterateunfold}
  \caption{}
  \label{alg:enumeration}
\end{algorithm}

\begin{algorithm}[tbp]
  \Input{regular language ,\\
    \hspace*{4mm} regular language substitution  with
     for all , and\\
    \hspace*{4mm} a bound } 
  \Yields{}

  \lIf{}{\Yield{}\;}\label{line:yield}\Else{
    fix  arbitrarily with \;\label{line:chooseSH}
    ; \hspace*{4em}\tcp*[h]{}\label{line:epsilonlang}\\
    \;
    \;\label{line:unfold-rec-0}
    \tcp*[h]{ (see text)}\\
    \lFor{ with }{\;}\label{line:unfold-rec-iterate}
  }
  \caption{}
  \label{alg:unfold}
\end{algorithm}



We are ready to design our enumeration algorithm, shown in
Algorithm~\ref{alg:enumeration}, and its recursive subprocedure in
Algorithm~\ref{alg:unfold}.
Both algorithms do not return a result but yield their result as an
enumeration: Upon invocation, both algorithms run through a sequence
of \Yield statements, each time appending the argument of \Yield to
the enumerated sequence.
Thus, the algorithm never stores the entire sequence but only the
stack of the invoked procedures.



Initializing the recursive enumeration,
Algorithm~\ref{alg:enumeration} obtains the maximum rewriting  of  (Line~\ref{line:intersection}) and
iterates over the languages  in the union-free decomposition of 
(Line~\ref{line:iterateunfold}) to call for each  the recursive
procedure , shown in Algorithm~\ref{alg:unfold}.
In turn, Algorithm~\ref{alg:unfold} takes a union free language
 and a bound  to
unfold the Kleene-star expressions of  until the precondition of
Proposition~\ref{prop:summarizable} is satisfied or
.



More specifically, \unfold exploits a rewriting, based on the
following terms:
Given a union free language , let
 with  denote all
words  in  with  and let .
Since  is in general not union free, we need to split 
further. 
To this end, we define  recursively for an integer
sequence  with head element  and
tail sequence .
Intuitively, a sequence  identifies a subexpression in  by
recursively selecting a nested Kleene star expression;
 unfolds  such that this selected expression
is instantiated at least once. 
Formally, for  we set
 and .
Consider  (with
all  for brevity), then we obtain 
\vspace*{-.5em}\begin{center}\begin{tabular}{cccccccccccc}
     &  &  &  & \multicolumn{4}{c}{} &
     &  \\
    &  &  &  &  &
     &  &  &  &  \\
    &  &  &  &  & 
    &  &  &  & 
\end{tabular}\end{center}\vspace*{-.5em}
instantiating  at position  at least once. 
Let  be integer sequences which identify a
subexpression of  which directly contain a symbol  with
 (and not only via another
Kleene-star expression).
Then, we write ,
with .
This discussion leads to the following rewriting:

\begin{proposition}[Rewriting for 1-Word Summaries]
  \label{prop:unfold-rewriting}
  For every union free language , we have . All languages in the rewriting, i.e.,  and
  , are union free,  has 1-word
  summaries, and  holds for all .
\end{proposition}


If  already satisfies the precondition imposed by
Proposition~\ref{prop:summarizable}, Algorithm~\ref{alg:unfold}
\Yield-s  and terminates (Line~\ref{line:yield}).
Otherwise, it fixes an arbitrary  violating this precondition and
rewrites  recursively with Proposition~\ref{prop:unfold-rewriting}
(Lines~\ref{line:chooseSH}-\ref{line:unfold-rec-iterate}).
\begin{inparaenum}[\bfseries(1)]
\item \emph{Termination:} In each recursive call, \unfold either
  eliminates in  an occurrence of a subexpression  violating
  the precondition of Proposition~\ref{prop:summarizable}
  (Line~\ref{line:unfold-rec-0}), or increases the minimum length in
  , eventually running into the upper bound 
  (Line~\ref{line:unfold-rec-iterate}).
\item \emph{Correctness:} Setting , \unfold \Yield-s a
  possibly infinite sequence of union free languages which have 1-word
  summaries such that their union equals the original language :
As the generation of these languages is based on the equality of
  Proposition~\ref{prop:unfold-rewriting} each rewriting step is sound
  and complete, leading to an infinite recursion tree whose leaves
  \Yield the languages in the sequence.
The upper bound on minimum length only cuts off languages 
  producing words of minimum length beyond , i.e., , and in consequence, it is safe to drop
  , since we only need to construct
   with
  .
\end{inparaenum}

 \subsection{Proofs}
\label{sec:decision-proofs}


\begin{proof}[\textbf{of Theorem~\ref{thm:kleene-star-free}}]
  \emph{\PSPACE-Membership.} We exploit for the \PSPACE-membership of
  all three considered problems the same observations:
\begin{inparaenum}[\bfseries(1)]
  \item Given Kleene star free languages , we can enumerate in
    \PSPACE all words ,
and
  \item we can check whether  holds, in
    \PSPACE~\cite{DBLP:conf/focs/MeyerS72}.
  \end{inparaenum}
  
  Thus, to check \emph{membership} of  in , we
  enumerate all  and check whether 
  holds for some ~-- if so,  is true. 
For checking the \emph{inclusion}
  , we enumerate all 
  and search in a nested loop for a  with
  .
If such a  exists for all , we have established
  .
We obtain \PSPACE-membership for \emph{equivalence}  by checking both, 
  and .



  \emph{Hardness.} For hardness we reduce the \PSPACE-complete problem
  whether a given regular expression  is
  equivalent to ~\cite{DBLP:conf/focs/MeyerS72} to all three
  considered problems:
Given an arbitrary regular expressions , we set ,
  , , , and
  .
This gives us  iff 
  (equivalence) iff  (inclusion)
  iff  (membership).
\qed
\end{proof}


\begin{proof}[\textbf{of Proposition~\ref{prop:membership-in-summarizable}}]
   With  and , taking
  , we obtain
  , as required.


    has 1-word summaries, hence there exists a  with , leading to
  , as required.  \qed
\end{proof}



\begin{proof}[\textbf{of Lemma~\ref{lem:representation}}]
  We prove the Lemma with Algorithm~\ref{alg:unfold}.
 yields  for
  union free languages , hence we obtain .\qed
\end{proof}


\begin{proof}[\textbf{of Theorem~\ref{thm:membership-condition}}]
  Most of the work for the proof of
  Theorem~\ref{thm:membership-condition} is already achieved by the
  representation  of
  Lemma~\ref{lem:representation}:
The languages  are
  constructed to have 1-word summaries, which make the check whether
  there exists  with  relatively easy~-- this
  is the case iff there exists a finite subset  with
  .
We show both directions of the theorem statement individually.


   Assume : By Definition~\ref{def:rational-set},
  there exists  with , by
  Definition~\ref{def:rewriting}, we get , and
  hence .
From  and , we
  get .
Since the maximal rewriting  of a regular language 
  is regular as well~\cite{rewriting}, and since regular languages are
  closed under intersection, we obtain the regularity of , and
  hence, Lemma~\ref{lem:representation} applies.
Thus, there exists an  with
  , and via
  Proposition~\ref{prop:membership-in-summarizable}, we obtain 
for , , as required.


   Assume that there exists an  with a finite subset  with .
Then, via Proposition~\ref{prop:membership-in-summarizable}, we take
  the summary word  for , yielding , as
  required. \qed
\end{proof}



\begin{proof}[\textbf{of Lemma~\ref{lem:pspace-completiy-of-prop1-check}}]
  \emph{Membership.} 
The construction of the automaton 
  (Line~\ref{line:bm:limitedautomaton}) runs in polynomial time and
  hence produces a polynomially sized distance automaton. 
Thus, the check for limitedness of 
  (Line~\ref{line:bm:limitedness}) retains its \PSPACE
  complexity~\cite{DBLP:conf/focs/MeyerS72}.
Given , , and all  for  as
  regular expressions, we can build a polynomially sized regular
  expression for  by substituting  for
  each occurrence of  in .
Then we check the equivalence of the regular expressions for
   and  (Line~\ref{line:bm:equivalence}), again
  keeping the original \PSPACE complexity of regular expression
  equivalence~\cite{DBLP:conf/focs/MeyerS72}.
This yields an overall \PSPACE procedure.



  \emph{Hardness.} 
We reduce the \PSPACE-complete problem of deciding whether a regular
  expression  over  is equivalent to
  ~\cite{DBLP:conf/focs/MeyerS72} to a single
  \basiccheck invocation~-- proving that \basiccheck solves a \PSPACE
  complete problem.
Given an arbitrary regular expressions , we set ,
   and . Then
   returns \boolTrue iff  is equivalent
  to .
\qed
\end{proof}


\begin{proof}[\textbf{of Proposition~\ref{prop:summarizable}}]
  We construct  the desired word:
Choose an arbitrary finite subset . 
Then each word  is of the form
   with
  .
We set , and
  observe, because of  for all 
  and ,
  
Thus we choose the summary word  and obtain
  , and hence
   .
\qed
\end{proof}



\begin{proof}[\textbf{of Proposition~\ref{prop:unfold-rewriting}}]
  We have 
and find the desired result by substituting , as discussed before
  Proposition~\ref{prop:unfold-rewriting}.

  \begin{inparaenum}[\bfseries(1)]
  \item \emph{Union freeness:} We construct the regular expression for
     by dropping all Kleene-stared subexpressions in
     which contain a symbol  with
     (possibly producing the empty
    language), preserving union freeness.
The construction of  only unrolls Kleene star expressions,
    also preserving the union freeness  from . 
  \item \emph{1-word summaries for :} For all , we
    have , since all symbols  in 
    have .
  \item \emph{Increasing minimal length in :} Since  is a subexpression of
     the minimal length can only increase,
    and since  instantiates an expression with a symbol
     and , it actually
    increases. \qed
  \end{inparaenum}
\end{proof}



\subsubsection{Proof of Theorem~\ref{thm:membership-complexity}.}
The proof is based on the complexity of the maximum rewriting
from~\cite{rewriting} and the complexity of \unfold, shown first via
Propositions~\ref{prop:unfold-step-size}
and~\ref{prop:unfold-complexity}, before proving the overall
complexity of \setenumeration in Lemma~\ref{lem:complexity-enumerate}.
This Lemma, together with
Lemma~\ref{lem:pspace-completiy-of-prop1-check}, leads to the desired
theorem. 


Recall the definition of \unfoldstep before
Proposition~\ref{prop:unfold-rewriting} for
 and 
with .
We denote with  the \emph{length of the regular expression}
representing .

\begin{proposition}[An Upper Bound for ]
  \label{prop:unfold-step-size}
  Let  be the maximum length of a Kleene star subexpression in
  . 
Then  holds.
\end{proposition}

\begin{proof}
  \unfoldstep duplicates  of  and continues
  recursively on a third copy of .
Since \unfoldstep does not introduce new Kleene star subexpressions
  but only duplicates some, all Kleene star expressions occurring
  during the \emph{entire} recursion are at most of length .
Hence, each recursive step of  adds at most  to the
  entire expression, and because the Kleene star nesting depth of at
  most , we obtain .\qed
\end{proof}

\begin{proposition}[ runs in ]
  \label{prop:unfold-complexity}
\end{proposition}

\begin{proof}
  In this proof, we denote with \Linit the language given in the first
  call to \unfold, while  denotes the language given to current
  call of \unfold. 
  We show the claim in three steps: 
  \begin{inparaenum}[\bfseries(1)]
  \item  holds at any point during the
    recursion, given  is the number of recursive calls going through
    Line~\ref{line:unfold-rec-iterate}.
First, recursive calls through Line~\ref{line:unfold-rec-0} cannot
    increase the size of the expression, i.e., ,
    since we obtain  by removing from  all
    subexpressions directly containing a symbol  with
     (and not only via another Kleene
    star expression).
Thus, only recursive calls going through
    Line~\ref{line:unfold-rec-iterate} possibly increase the size of
    the expression.
Now, in such a call, we unroll a subexpression  with
     and  for some integer sequence .
From Proposition~\ref{prop:unfold-step-size}, we have
    . 
Since \unfoldstep and \unfold only duplicate already existing
    Kleene star subexpressions, we have both 
    and , and hence
    .
Together with  and , this
    leads to .
 recursive calls through Line~\ref{line:unfold-rec-iterate}
    substitute  subexpressions  with  to unfold  into , each time adding
     to the size of the expression representing
    .
Hence . 



  \item  holds for all recursive calls to
    \unfold while computing .
\unfold makes at most  recursive steps through
    Line~\ref{line:unfold-rec-iterate}, since
     holds (this is
    true, since  in  instantiates some  with
    ).
Then the claim follows setting .


  \item The total recursion depth of \unfold is at most
    .
In the previous claim, we saw that there are at most  recursive
    calls through Line~\ref{line:unfold-rec-iterate}.
It remains to give an upper bound for the calls through
    Line~\ref{line:unfold-rec-0}:
In each such call, at least one Kleene star subexpression in 
    is removed in substituting  for .
At any point there are at most 
    expressions in , hence we get a maximum recursion depth of
    . 


  \item The space required to compute  is
    bounded by the depth of the recursion times the stack frame size,
    which is dominated by , plus .
This gives  as desired.\qed
  \end{inparaenum}
\end{proof}


\begin{lemma}[ runs in
  ]
  \label{lem:complexity-enumerate}
\end{lemma}

\begin{proof}The construction of  yields an expression in
  the size  for some constant
  ~\cite{rewriting}.
The union free decomposition yields possibly exponentially many
  union free languages, however, each of them has linear size, using
  the rewriting rules, , ,
  , and .
In practical implementations, however, one might prefer to generate
  less but larger individual expressions, employing e.g.~\cite{decomposition}. 
With Proposition~\ref{prop:unfold-complexity}, we obtain the overall
  space complexity of \setenumeration with  for  and
  .
This leads to the desired result with  for some other constant
  .\qed
\end{proof}


\begin{proof}[\textbf{of Theorem~\ref{thm:membership-complexity}}]
  The enumeration runs , producing expressions for
   at most of the same size
  (Lemma~\ref{lem:complexity-enumerate}).
Since  is in 
  (Lemma~\ref{lem:pspace-completiy-of-prop1-check}), we obtain the
  overall complexity  for some
  constants  and . \qed
\end{proof}
 
\end{document}
