\documentclass{article} \usepackage{iclr2019_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\usepackage{subfigure}
\usepackage{graphicx}
\usepackage{soul}


\title{R-Transformer: Recurrent Neural Network Enhanced Transformer}




\author{{Zhiwei Wang} \\
Department of Computer Science\\
Michigan State University\\
\texttt{wangzh65@msu.edu}
\And {Yao Ma} \\
Department of Computer Science\\
Michigan State University\\
\texttt{mayao4@msu.edu} \\
\And {Zitao Liu} \\
AI Lab\\
TAL Education Group \\
\texttt{liuzitao@100tal.com} \\
\And {Jiliang Tang} \\
Department of Computer Science\\
Michigan State University\\
\texttt{tangjili@msu.edu}}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
Recurrent Neural Networks have long been the dominating choice for sequence modeling. However, it severely suffers from two issues: impotent in capturing very long-term dependencies and unable to parallelize the sequential computation procedure. Therefore, many non-recurrent sequence models that are built on convolution and attention operations have been proposed recently. Notably, models with multi-head attention such as Transformer have demonstrated extreme effectiveness in capturing long-term dependencies in a variety of sequence modeling tasks. Despite their success, however, these models lack necessary components to model local structures in sequences and heavily rely on position embeddings that have limited effects and require a considerable amount of design efforts. In this paper, we propose the R-Transformer which enjoys the advantages of both RNNs and the multi-head attention mechanism while avoids their respective drawbacks. The proposed model can effectively capture both local structures and global long-term dependencies in sequences without any use of position embeddings. We evaluate R-Transformer through extensive experiments with data from a wide range of domains and the empirical results show that R-Transformer outperforms the state-of-the-art methods by a large margin in most of the tasks. We have made the code publicly available at \url{https://github.com/DSE-MSU/R-transformer}.
\end{abstract}

\section{Introduction}
Recurrent Neural Networks (RNNs) especially its variants such as Long Short-Term Memory (LSTM) and Gated Recurrent Unit (GRU) have achieved great success in a wide range of sequence learning tasks including language modeling, speech recognition, recommendation, etc~\citep{mikolov2010recurrent,sundermeyer2012lstm,graves2014towards,hinton2012deep,hidasi2015session}. Despite their success, however, the recurrent structure is often troubled by two notorious issues.  First, it easily suffers from gradient vanishing and exploding problems, which largely limits their ability to learn very long-term dependencies~\citep{pascanu2013difficulty}. Second, the sequential nature of both forward and backward passes makes it extremely difficult, if not impossible, to parallelize the computation, which dramatically increases the time complexity in both training and testing procedure. Therefore, many recently developed sequence learning models have completely jettisoned the recurrent structure and only rely on convolution operation or attention mechanism that are easy to parallelize and allow the information flow at an arbitrary length. Two representative models that have drawn great attention are Temporal Convolution Networks(TCN)~~\citep{bai2018empirical} and Transformer~\citep{vaswani2017attention}. In a variety of sequence learning tasks, they have demonstrated comparable or even better performance than that of RNNs~\citep{gehring2017convolutional,bai2018empirical,devlin2018bert}.
 

The remarkable performance achieved by such models largely comes from their ability to capture long-term dependencies in sequences. In particular, the multi-head attention mechanism in Transformer allows every position to be directly connected to any other positions in a sequence. Thus, the information can flow across positions without any intermediate loss. Nevertheless, there are two issues that can harm the effectiveness of multi-head attention mechanism for sequence learning. The first comes from the loss of sequential information of positions as it treats every position identically. To mitigate this problem, Transformer introduces position embeddings, whose effects, however, have been shown to be limited~\citep{dehghani2018universal,al2018character}. In addition, it requires considerable amount of efforts to design more effective position embeddings or different ways to incorporate them in the learning process~\citep{dai2019transformer}. Second, while multi-head attention mechanism is able to learn the global dependencies, we argue that it ignores the local structures that are inherently important in sequences such as natural languages. Even with the help of position embeddings, the signals at local positions can still be very weak as the number of other positions is significantly more. 

To address the aforementioned limitations of the standard Transformer, in this paper, we propose a novel sequence learning model, termed as R-Transformer. It is a multi-layer architecture built on RNNs and the standard Transformer, and enjoys the advantages of both worlds while naturally avoids their respective drawbacks. More specifically, before computing global dependencies of positions with the multi-head attention mechanism, we firstly refine the representation of each position such that the sequential and local information within its neighborhood can be compressed in the representation. To do this, we introduce a local recurrent neural network, referred to as LocalRNN, to process signals within a local window ending at a given position. In addition, the LocalRNN operates on local windows of all the positions identically and independently and produces a latent representation for each of them. In this way, the locality in the sequence is explicitly captured. In addition, as the local window is sliding along the sequence one position by one position, the global sequential information is also incorporated. More importantly, because the localRNN is only applied to local windows, the aforementioned two drawbacks of RNNs can be naturally mitigated. We evaluate the effectiveness of R-Transformer with a various of sequence learning tasks from different domains and the empirical results demonstrate that R-Transformer achieves much stronger performance than both TCN and standard Transformer as well as other state-of-the-art sequence models. 






 \begin{figure}
\label{fig:r-transformer}
	\begin{center}
		\includegraphics[scale=1.2]{fig/net}
	\end{center}
	\caption{The illustration of one layer of R-Transformer. There are three different networks that are arranged hierarchically. In particular, the lower-level is localRNNs that process positions in a local window sequentially (This figure shows an example of local window of size 3); The middle-level is multi-head attention networks which capture the global long-term dependencies; The upper-level is Position-wise feedforward networks that conduct non-linear feature transformation. These three networks are connected by a residual and layer normalization operation. The circles with dash line are the paddings of the input sequence}
\end{figure}
The rest of the paper is organized as follows: Section 2 discusses the sequence modeling problem we aim to solve; The proposed R-Transformer model is presented in Section 3. In Section 4, we describe the experimental details and discuss the results. The related work is briefly reviewed in Section 5. Section 6 concludes this work.

\section{Sequence Modeling Problem}
Before introducing the proposed R-Transformer model, we formally describe the sequence modeling problem. Given a sequence of length $N$: $x_1, x_2, \cdots, x_N$, we aim to learn a function that maps the input sequence into a label space $\mathcal{Y}$: ($f: \mathcal{X}^N \rightarrow \mathcal{Y}$). Formally, 
\begin{align}
y = f(x_1, x_2, \cdots, x_N)
\end{align}
\noindent where $y \in \mathcal{Y} $ is the label of the input sequence. Depending on the definition of label $y$, many tasks can be formatted as the sequence modeling problem defined above. For example, in language modeling task, $x_t$ is the character/word in a textual sentence and $y$ is the character/word at next position~\citep{mikolov2010recurrent}; in session-based recommendation, $x_t$ is the user-item interaction in a session and $y$ is the future item that users will interact with~\citep{hidasi2015session}; when $x_t$ is a nucleotide in a DNA sequence and $y$ is its function, this problem becomes a DNA function prediction task~\citep{quang2016danq}. Note that, in this paper, we do not consider the sequence-to-sequence learning problems. However, the proposed model can be easily extended to solve these problems and we will leave it as one future work.

\section{The R-Transformer Model}
The proposed R-Transformer consists of a stack of identical layers. Each layer has 3 components that are organized hierarchically and the architecture of the layer structure is shown in Figure~\ref{fig:r-transformer}. As shown in the figure, the lower level is the local recurrent neural networks that are designed to model local structures in a sequence; the middle level is a multi-head attention that is able to capture global long-term dependencies; and the upper level is a position-wise feedforward networks which conducts a non-linear feature transformation. Next, we describe each level in detail.

\subsection{LocalRNN: Modeling Local Structures}




Sequential data such as natural language inherently exhibits strong local structures. Thus, it is desirable and necessary to design components to model such locality. In this subsection, we propose to take the advantage of RNNs to achieve this. Unlike previous works where RNNs are often applied to the whole sequence, we instead reorganize the original long sequence into many short sequences which only contain local information and are processed by a shared RNN independently and identically. In particular, we construct a local window of size $M$ for each target position such that the local window includes $M$ consecutive positions and ends at the target position. Thus, positions in each local window form a local short sequence, from which the shared RNN will learn a latent representation. In this way, the local structure information of each local region of the sequence is explicitly incorporated in the learned latent representations. We refer to the shared RNN as LocalRNN. Comparing to original RNN operation, LocalRNN only focuses on local short-term dependencies without considering any long-term dependencies. Figure~\ref{fig:rnn} shows the different between original RNN and LocalRNN operations. Concretely, given the positions $x_{t-M-1}, x_{t-M-2}, \cdots, x_{t}$ of a local short sequence of length $M$, the LocalRNN processes them sequentially and outputs $M$ hidden states, the last of which is used as the representation of the local short sequences:
\begin{align}
h_{t} = \text{LocalRNN}(x_{t-M-1}, x_{t-M-2}, \cdots, x_{t})
\end{align}
\noindent where RNN denotes any RNN cell such as Vanilla RNN cell, LSTM, GRU, etc. To enable the model to process the sequence in an auto-regressive manner and take care that no future information is available when processing one position, we pad the input sequence
by $(M - 1)$ positions before the start of a sequence. Thus, from sequence perspective, the LocalRNN takes an input sequence and outputs a sequence of hidden representations that incorporate information of local regions:
\begin{align}
h_1, h_2, \cdots, h_N = LocalRNN(x_1, x_2, \cdots, x_N)
\end{align}

The localRNN is analogous to 1-D Convolution Neural Networks where each local window is processed by convolution operations. However, the convolution operation completely ignores the sequential information of positions within the local window. Although the position embeddings have been proposed to mitigate this problem, a major deficiency of this approach is that the effectiveness of the position embedding could be limited; thus it requires considerable amount of extra efforts~\citep{gehring2017convolutional}. On the other hand, the LocalRNN is able to fully capture the sequential information within each window. In addition, the one-by-one sliding operation also naturally incorporates the global sequential information.

{\bf Discussion:} RNNs have long been a dominating choice for sequence modeling but it severely suffers from two problems -- The first one is its limited ability to capture the long-term dependencies and the second one is the time complexity, which is linear to the sequence length. However, in LocalRNN, these problems are naturally mitigated. Because the LocalRNN is applied to a short sequence within a local window of fixed size, where no long-term dependency is needed to capture. In addition, the computation procedures for processing the short sequences are independent of each other. Therefore, it is very straightforward for the parallel implementation (e.g., using GPUs), which can greatly improve the computation efficiency. 
\begin{figure}

	\begin{center}
		\subfigure[Original RNN.]{\label{fig:original-rnn}\includegraphics[scale=0.5]{fig/normal_rnn}}
		\subfigure[Local RNN.]{\label{fig:local-rnn}\includegraphics[scale=0.5]{fig/rnn}}
	\end{center}
	\caption{An illustration of the original and local RNN. In contrast to orignal RNN which maintains a hidden state at each position summarizing all the information seen so far,  LocalRNN only operates on positions within a local window. At each position, LocalRNN will produce a hidden state that represents the information in the local window ending at that position.}
	\label{fig:rnn}
\end{figure}

\subsection{Capturing the Global Long-Term Dependencies with Multi-Head Attention}

The RNNs at the lower level introduced in the previous subsection will refine representation of each positions such that it incorporates its local information. In this subsection, we build a sub-layer on top of the LocalRNN to capture the global long-term dependencies. We term it as pooling sub-layer because it functions similarly to the pooling operation in CNNs. Recent works have shown that the multi-head attention mechanism is extremely effective to learn the long-term dependencies, as it allows a direct connection between every pair of positions. More specifically, in the multi-head attention mechanism, each position will attend to all the positions in the past and obtains a set of attention scores that are used to refine its representation. Mathematically, given current representations $h_1, h_2, \cdots, h_t$, the refined new representations $u_t$ are calculated as:
 \begin{align}
 u_t &= MultiHeadAttention(h_1, h_2, \cdots, h_t)  \\ \nonumber
 	&= Concatenation(head_1(h_t), head_2(h_t), \cdots, head_k(h_t)) W^o \nonumber
 \end{align}
\noindent where $head_k(h_t)$ is the result of $k^{th}$ attention pooling and $W^o$ is a linear projection matrix. Considering both efficiency and effectiveness, the scaled dot product is used as the attention function~\citep{vaswani2017attention}. Specifically, $head_i(h_t)$ is the weighted sum of all value vectors and the weights are calculated by applying attention function to all the query, key pairs:
\begin{align}
\label{eq:attn}
\{\alpha_1, \alpha_2, \cdots \alpha_n\ \} &= Softmax( \{ \frac{<q, k_1>}{\sqrt(d_k)}, \frac{<q, k_2>}{\sqrt(d_k)}, \cdots, \frac{<q, k_n>}{\sqrt(d_k)} \}) \\ \nonumber
head_i(h_t) &= \sum^{n}_{j=1} \alpha_j v_j
\end{align}

\noindent where $q$, $k_i$, and $v_i$ are the query, key, and value vectors and $d_k$ is the dimension of $k_i$. Moreover, $q$, $k_i$, and $v_i$ are obtained by projecting the input vectors into query, key and value spaces, respectively~\citep{vaswani2017attention}. They are formally defined as:
\begin{align}
q, k_i, v_i = W^qh_t, W^kh_i, W^vh_i
\end{align}
\noindent where $W^q$, $W^k$ and $W^v$ are the projection matrices and each  attention pooling $head_i$ has its own projection matrices. As shown in Eq.~(\ref{eq:attn}), each $head_i$ is obtained by letting $h_t$ attending to all the ``past'' positions, thus any long-term dependencies between $h_t$ and $h_i$ can be captured. In addition, different heads will focus on dependencies in different aspects. After obtaining the refined representation of each position by the multi-head attention mechanism, we add a position-wise fully connected feed-forward network sub-layer, which is applied to each position independently and identically. This feedforward network transforms the features non-linearly and is defined as follows:
\begin{align}
FeedForward(m_t) = max(0, u_tW_1 + b1)W_2 + b2
\end{align}
Following~\citep{vaswani2017attention}, We add a residual~\citep{he2016deep} and layernorm~\citep{ba2016layer} connection between all the sub-layers.

\subsection{Overall Architecture of R-Transformer}

With all the aforementioned model components, we can now give a formal description of the overall architecture of an $N$-layer R-Transformer. For the $i^{th}$ layer ($i \in \{ 1, 2, \cdots N\}$):
\begin{align}
\label{eq:layer}
h^i_1, h^i_2, \cdots, h^i_T &=  LocalRNN(x^i_1, x^i_2, \cdots, x^i_T) \\ \nonumber
\hat{h}^i_1, \hat{h}^i_2, \cdots, \hat{h}^i_T &= LayerNorm(h^i_1 + x^i_1, h^i_2+ x^i_2, \cdots, h^i_T + x^i_T) \\ \nonumber
u^i_1, u^i_2, \cdots, u^i_T &=  MultiHeadAttention(\hat{h}v_1, \hat{h}^i_2, \cdots, \hat{h}^i_T) \\ \nonumber
\hat{u}^i_1, \hat{u}^i_2, \cdots, \hat{u}^i_T &= LayerNorm(u^i_1 + \hat{h}^i_1, u^i_2 + \hat{h}^i_2, \cdots, u^i_T + \hat{h}^i_T ) \\ \nonumber
m^i_1, m^i_2, \cdots, m^i_T &= FeedForward(\hat{u}^i_1, \hat{u}^i_2, \cdots, \hat{u}^i_T) \\ \nonumber
x^{i+1}_1, x^{i+1}_2, \cdots, x^{i+1}_T &= LayerNorm(m^i_1 + \hat{u}^i_1, m^i_2 + \hat{u}^i_2, \cdots, m^i_T + \hat{u}^i_T)
\end{align}
\noindent where $T$ is the length of the input sequence and $x^i_t$ is the input position of the layer $i$ at time step $t$.

{\bf Comparing with TCN:} R-Transformer is partly motivated by the hierarchical structure in TCN~\citet{bai2018empirical}, thus, we make a detailed comparison here. In TCN, the locality in sequences in captured by convolution filters. However, the sequential information within each receptive field is ignored by convolution operations. In contrast, the LocalRNN structure in R-Transformer can fully incorporate it by the sequential nature of RNNs. For modeling global long-term dependencies, TCN achieves it with dilated convolutions that operate on nonconsecutive positions. Although such operation leads to larger receptive fields in lower-level layers, it misses considerable amount of information from a large portion of positions in each layer. On the other hand, the multi-head attention pooling in R-Transformer considers every past positions and takes much more information into consideration than TCN.

{\bf Comparing with Transformer:} The proposed R-Transformer and standard Transformer enjoys similar long-term memorization capacities thanks to the multi-head attention mechanism~\citep{vaswani2017attention}. Nevertheless, two important features distinguish R-Transformer from the standard Transformer. First, R-Transformer explicitly and effectively captures the locality in sequences with the novel LocalRNN structure while standard Transformer models it very vaguely with multi-head attention that operates on all of the positions. Second, R-Transformer does not rely on any position embeddings as Transformer does. In fact, the benefits of simple position embeddings are very limited~\citep{al2018character} and it requires considerable amount of efforts to design effective position embeddings as well as proper ways to incorporate them~\citep{dai2019transformer}. In the next section, we will empirically demonstrate the advantages of R-Transformer over both TCN and the standard Transformer. 
 \section{Experiment}
In this section, we evaluate R-Transformer with sequential data from various domains including images, audios and natural languages and compare it with canonical recurrent architectures (Vanilla RNN, GRU, LSTM) and two of the most popular generic sequence models that do not have any recurrent structures, namely, TCN and Transformer. For all the tasks, Transformer and R-Transformer were implemented with Pytorch and the results for canonical recurrent architectures and TCN were directly copied from~\citet{bai2018empirical} as we follow the same experimental settings. In addition, to make the comparison fair, we use the same set of hyperparameters (i.e, hidden size, number of layers, number of heads) for R-Transformer and Transformer. Moreover, unless specified otherwise, for training, all models are trained with same optimizer and learning rate is chosen from the same set of values according to validation performance. In addition, the learning rate annealed such that it is reduced when validation performance reaches plateau.

\subsection{Pixel-by-pixel MNIST: Sequence Classification}

This task is designed to test model ability to memorize long-term dependencies. It was firstly proposed by~\citet{le2015simple} and has been used by many previous works~\citep{wisdom2016full,chang2017dilated,zhang2016architectural,krueger2016zoneout}. Following previous settings, we rescale each $28 \times 28$ image in MNIST dataset~\citet{lecun1998gradient} into a $784 \times 1$ sequence, which will be classified into ten categories (each image corresponds to one of the digits from 0 to 9) by the sequence models. Since the rescaling could make pixels that are connected in the origin images far apart from each other, it requires the sequence models to learn very long-term dependencies to understand the content of each sequence. The dataset is split into training and testing sets as same as the default ones in Pytorch(version 1.0.0)~\footnote{https://pytorch.org}. The model hyperparameters and classification accuracy are reported in Table~\ref{table:mnist}. From the table, it can be observed that firstly, RNNs based methods generally perform worse than others. This is because the input sequences exhibit very long-term dependencies and it is extremely difficult for RNNs to memorize them. On the other hand, methods that build direct connections among positions, i.e., Transformer, TCN, achieve much better results. It is also interesting to see that TCN is slightly better than Transformer, we argue that this is because the standard Transformer cannot model the locality very well. However, our proposed R-Transformer that leverages LocalRNN to incorporate local information, has achieved better performance than TCN. 


\begin{table}
\begin{center}	
		\caption{MNIST classification task results. Italic numbers denote that the results are directly copied from other papers that have the same settings.}
		\vspace{4mm}
		\label{table:mnist}
\begin{tabular}{ccc}
			\hline \\[-0.9ex]
			Model &  \# of layers / hidden size & Test Accuracy(\%)\\ [0.9ex]	
			\hline			\\[-0.9ex]
			RNN~\citep{bai2018empirical} &  -   &  {\it 21.5} \\ 	[0.5ex]		
			GRU~\citep{bai2018empirical} & - &  {\it 96.2}  \\	[0.5ex]		
			LSTM~\citep{bai2018empirical} &  {\it 1}/ {\it 130} & {\it 87.2} \\[0.5ex]
			TCN~\citep{bai2018empirical} &  {\it 8} /{\it 25} &  {\it 99.0} \\[0.5ex]
			Transformer &  8/32   & 98.2\\[0.5ex]
			R-Transformer &  8/32 & 99.1 \\[0.6ex]
			\hline   
		\end{tabular}
	\end{center}
\end{table}
\subsection{Nottingham: polyphonic music modeling}
\begin{table}
\begin{center}	
		\caption{Polyphonic music modeling. Italic numbers denote that the results are directly copied from other papers that have the same settings.}
		\vspace{4mm}
		\label{table:music}
\begin{tabular}{ccc}
			\hline \\[-0.9ex]
			Model &  \# of layers / hidden size & NLL\\ [0.9ex]	
			\hline			\\[-0.9ex]
			RNN~\citep{bai2018empirical} &  -   &  {\it 4.05} \\ 	[0.5ex]		
			GRU~\citep{bai2018empirical} & - &  {\it 3.46}  \\	[0.5ex]		
			LSTM~\citep{bai2018empirical} &  - & {\it 3.29} \\[0.5ex]
			TCN~\citep{bai2018empirical} &  {\it 4} /{\it 150} &  {\it 3.07} \\[0.5ex]
			Transformer &  3/160   & 3.34\\[0.5ex]
			R-Transformer & 3/160  & 2.37 \\[0.6ex]
			\hline   
		\end{tabular}
	\end{center}
\end{table}
Next, we evaluate R-Transformer on the task of polyphonic music modeling with Nottingham dataset~\citep{boulanger2012modeling}. This dataset collects British and American folk tunes and has been commonly used in previous works to investigate the model's ability for polyphonic music modeling~\citep{boulanger2012modeling,chung2014empirical,bai2018empirical}. Following the same setting in~\citet{bai2018empirical}, we split the data into training, validation, and testing sets which contains 694, 173 and 170 tunes, respectively. The learning rate is chosen from $\{5e^{-4}, 5e^{-5}, 5e^{-6}\}$ and dropout with probability of 0.1 is used to avoid overfitting.  Moreover, gradient clipping is used during the training process. We choose negative log-likelihood (NLL) as the evaluation metrics and lower value indicates better performance. The experimental results are shown in Table~\ref{table:music}. Both LTSM and TCN outperform Transformer in this task. We suspect this is because these music tunes exhibit strong local structures. While Transformer is equipped with multi-head attention mechanism that is effective to capture long-term dependencies, it fails to capture local structures in sequences that could provide strong signals. On the other hand, R-Transformer enhanced by LocalRNN has achieved much better results than Transformer. In addition, it also outperforms TCN by a large margin. This is expected because TCN tends to ignore the sequential information in the local structure, which can play an important role as suggested by~\citep{gehring2017convolutional}.

\begin{table}
\begin{center}	
		\caption{Character-level language modeling. Italic numbers denote that the results are directly copied from other papers that have the same settings.}
		\vspace{4mm}
		\label{table:ptb_c}
\begin{tabular}{ccc}
			\hline \\[-0.9ex]
			Model &  \# of layers / hidden size & NLL\\ [0.9ex]	
			\hline			\\[-0.9ex]
			RNN~\citep{bai2018empirical} &  -   &  {\it 1.48} \\ 	[0.5ex]		
			GRU~\citep{bai2018empirical} & - &  {\it 1.37}  \\	[0.5ex]		
			LSTM~\citep{bai2018empirical} &  {\it 2} /{\it 600} & {\it 1.36} \\[0.5ex]
			TCN~\citep{bai2018empirical} &  {\it 3} /{\it 450} &  {\it 1.31} \\[0.5ex]
			Transformer &  3/512  & 1.45\\[0.5ex]
			R-Transformer & 3/512  & 1.24 \\[0.6ex]
			\hline   
		\end{tabular}
	\end{center}
\end{table}

\subsection{PennTreebank: language modeling}
In this subsection, we further evaluate R-Transformer's ability on both character-level and word-level language modeling tasks. The dataset we use is PennTreebank(PTB)~\citep{marcus1993building} that contains 1 million words and has been extensively used by previous works to investigate sequence models~\citep{chen1999empirical, chelba2000structured,kim2016character,tran2016recurrent}. For character-level language modeling task, the model is required to predict the next character given a context. Following the experimental settings in ~\citet{bai2018empirical}, we split the dataset into training, validation and testing sets that contains 5059K, 396K and 446K characters, respectively. For Transformer and R-Transformer, the learning rate is chosen from $\{1, 2, 3\}$ and dropout rate is 0.15.  Gradient clipping is also used during the training process. The negative log-likelihood (NLL) is used to measure the predicting performance. 

For word-level language modeling, the models are required to predict the next word given the contextual words. Similarly, we follow previous works and split PTB into training, validation, and testing sets with 888K, 70K and 79K words, respectively. The vocabulary size of PTB is 10K. As with character-level language modeling,the learning rate is chosen from $\{1, 2, 3\}$ for Transformer and R-Transformer and dropout rate is 0.35. The prediction performance is evaluated with perplexity, the lower value of which denotes better performance.


The experimental results of character-level and word-level language modeling tasks are shown in Table~\ref{table:ptb_c} and Table~\ref{table:ptb_w}, respectively. Several observations can be made from the Table~\ref{table:ptb_c}. First, Transformer performs only slightly better than RNN while much worse than other models. The reason for this observation is similar to the case of polyphonic music modeling task that language exhibits strong local structures and standard Transformer can not fully capture them.  Second, TCN achieves better results than all of the RNNs, which is attributed to its ability to capture both local structures and long-term dependencies in languages. Notably, for both local structures and long-term dependencies, R-Transformer has more powerful components, i.e., LocalRNN and Multi-head attention, than TCN. Therefore, it is not surprising to see that R-Transformer achieves significantly better results. The results for word-level language modeling in Table~\ref{table:ptb_w} show similar trends, with the only exception that LSTM achieves the best results among all the methods.

In summary, previous results have shown that the standard Transformer can achieve better results than RNNs when sequences exhibit very long-term dependencies, i.e., sequential MNIST while its performance could drop dramatically when strong locality exists in sequences, i.e., polyphonic music and language. Meanwhile, TCN is a very strong sequence model that can effectively learn both local structures and long-term dependencies and has very stable performance in different tasks. More importantly, the proposed R-Transformer that combines a lower level LocalRNN and a higher level multi-head attention, outperforms both TCN and Transformer by a large margin consistently in  most of the tasks.

\begin{table}
\begin{center}	
		\caption{Word-level language modeling. Italic numbers denote that the results are directly copied from other papers that have the same settings.}
		\vspace{4mm}
		\label{table:ptb_w}
\begin{tabular}{ccc}
			\hline \\[-0.9ex]
			Model &  \# of layers / hidden size & Perplexity\\ [0.9ex]	
			\hline			\\[-0.9ex]
			RNN~\citep{bai2018empirical} &  -   &  {\it 114.50} \\ 	[0.5ex]		
			GRU~\citep{bai2018empirical} & - &  {\it 92.48}  \\	[0.5ex]		
			LSTM~\citep{bai2018empirical} &  {\it 3} /{\it 700} & {\it 78.93} \\[0.5ex]
			TCN~\citep{bai2018empirical} &  {\it 4} /{\it 600} &  {\it 88.68} \\[0.5ex]
			Transformer &  3/128 & 122.37\\[0.5ex]
			R-Transformer & 3/128  & 84.38 \\[0.6ex]
			\hline   
		\end{tabular}
	\end{center}
\end{table}

 \section{Related Work}
Recurrent Neural Networks including its variants such LSTM~\citep{hochreiter1997long} and GRU~\citep{cho2014learning} have long been the default choices for generic sequence modeling. A RNN sequentially processes each position in a sequence and maintains an internal hidden state to compresses information of positions that have been seen. While its design is appealing and it has been successfully applied in various tasks, several problems caused by its recursive structures including low computation efficiency and gradient exploding or vanishing make it ineffective when learning long sequences. Therefore, in recent years, a lot of efforts has been made to develop models without recursive structures and they can be roughly divided into two categories depending whether they rely on convolutions operations or not.

The first category includes models that mainly built on convolution operations. For example, van den Oord {\it et al.} have designed an autoregressive WaveNet that is based on causal filters and dilated convolution to capture both global and local information in raw audios~\citep{van2016wavenet}. Ghring {\it et al.} has successfully replace traditional RNN based encoder and decoder with convolutional ones and outperforms LSTM setup in neural machine translation tasks~\citep{gehring2017convolutional,gehring2016convolutional}. Moreover, researchers introduced gate mechanism into convolutions structures to model sequential dependencies in languages~\citep{dauphin2017language}. Most recently, a generic architecture  for sequence modeling, termed as Temporal Convolutional Networks (TCN), that combines components from previous works has been proposed in~\citep{bai2018empirical}. Authors in~\citep{bai2018empirical} have systematically compared TCN with canonical recurrent networks in a wide range of tasks and TCN is able achieve better performance in most cases. Our R-transformer is motivated by works in this group in a sense that we firstly models local information and then focus on global ones.

The most popular works in second category are those based on multi-head attention mechanism. The multi-head attention mechanism was firstly proposed in~\citet{vaswani2017attention}, where impressive performance in machine translation task has been achieved with Transformer. It was then frequently used in other sequence learning models~\citep{devlin2018bert,dehghani2018universal,dai2019transformer}. The success of multi-head attention largely comes from its ability to learn long-term dependencies through direct connections between any pair of positions. However, it heavily relies on position embeddings that have limited effects and require a fair amount of effort to design effective ones. In addition, our empirical results shown that the local information could easily to be ignored by multi-head attention even with the existence of position embeddings. Unlike previously proposed Transformer-like models, R-Transformer in this work leverages the strength of RNN and is able model the local structures effectively without the need of any position embeddings.  \section{Conclusion}
In this paper, we propose a novel generic sequence model that enjoys the advantages of both RNN and the multi-head attention while mitigating their disadvantages. Specifically, it consists of a LocalRNN that learns the local structures without suffering from any of the weaknesses of RNN and a multi-head attention pooling that effectively captures long-term dependencies without any help of position embeddings. In addition, the model can be easily implemented with full parallelization over the positions in a sequence. The empirical results on sequence modeling tasks from a wide range of domains have demonstrated the remarkable advantages of R-Transformer over state-of-the-art non-recurrent sequence models such as TCN and standard Transformer as well as canonical recurrent architectures. 
\bibliography{zhiwei}
\bibliographystyle{iclr2019_conference}

\end{document}
