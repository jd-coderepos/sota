\documentclass[titlepage, 11pt]{article}

\usepackage{setspace}
\usepackage[dvips]{graphicx}
\graphicspath{{grim/} }
\usepackage{mathptmx}
\usepackage{color}
\usepackage{graphicx}
\usepackage{amsmath,amssymb,amsfonts,amsthm,latexsym,eucal}
\usepackage{fullpage}
\usepackage{pdfsync}
\usepackage{mdwlist}
\usepackage{algorithmic}
\usepackage{algorithm}


\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}


\newcommand{\ignore}[1]{}
\newcommand{\fl}[1]{\mbox{}}
\newcommand{\pair}[2]{\mbox{}}
\newcommand{\mc}{\mathcal}
\newcommand{\fail}{\textsf{fail}}
\newcommand{\exclude}{\textsf{miss}}
\newcommand{\Enc}{\textrm{Enc}}
\newcommand{\Dec}{\textrm{Dec}}
\newcommand{\remove}[1]{}
\newcommand{\new}[1]{\textcolor{red}{#1}}

\def\PPT{{\rm PPT} }
\def\ff{\mathbb{F}}
\def\sbs{\subseteq}
\def\zz{\mathbb{Z}}




\newcommand{\B}{\vspace*{-\smallskipamount}}
\newcommand{\BB}{\vspace*{-\medskipamount}}
\newcommand{\BBB}{\vspace*{-\bigskipamount}}
\newcommand{\F}{\vspace*{\smallskipamount}}
\newcommand{\FF}{\vspace*{\medskipamount}}
\newcommand{\FFF}{\vspace*{\bigskipamount}}
\newcommand{\T}{\hspace*{1em}}
\newcommand{\TT}{\hspace*{2em}}
\newcommand{\TTT}{\hspace*{3em}}



\doublespacing

\title{ A Paradigm for Channel Assignment  and Data Migration  in Distributed Systems}
\author{\textsc{Chadi Kari}\\ \\ 
\\Technical Report
\\
\\
\\
Computer Science and Engineering Department \\ University of Connecticut\\
2010
\date{}
\\}

\date{\today}               

\singlespacing

\begin{document}
\maketitle

\begin{abstract}
In this manuscript, we consider the problems of channel assignment in wireless networks and data migration in heterogeneous storage systems. We show that a  \emph{soft edge coloring} approach to both problems  gives rigorous approximation guarantees. 

In the channel assignment problem arising in wireless networks, we are given a graph , and the number of wireless cards  for each vertex . The constraint  limits the number
of channels that edges incident to  can use. We also have the total number of channels  available in the network. For a pair of edges incident to a vertex, they are said to be {\em conflicting}
if the channels assigned to them are the same. Our goal is to assign channels (color edges) so that
the number of conflicts is minimized. In this manuscript we  first study the problem for a homogeneous network where  and  for all nodes .  The problem is NP-hard by a reduction from \textsc{Edge coloring} and
we present two combinatorial algorithms for this case.
The first algorithm is based on a distributed greedy method and 
gives a solution with at most  more conflicts than the optimal solution,
which implies a -approximation. 
We also present a soft edge coloring algorithm that  yields at most  more conflicts than the optimal solution.  The approximation ratio is , which gives a ()-factor for dense graphs.  The algorithm generalizes Vizing's algorithm in the sense that it gives the same result as Vizing's algorithm when . Moreover, we show that this approximation result is best possible unless . For the case where  or ,
we show that the problem is NP-hard even when  or , and , and present two approximation algorithms. The first algorithm is completely combinatorial and has an approximation ratio of .  We also develop an SDP-based algorithm, producing a solution with an approximation ratio of  for , and  in general.
   
In this manuscript, we also consider  the \emph{ data migration} problem in heterogeneous storage systems.  Large-scale storage systems are crucial components in
data-intensive applications such as search engine clusters,
video-on-demand servers, sensor networks, and grid computing.
A storage server typically consists of a set of storage devices.
In such systems, data layouts may need to be reconfigured over time
for load balancing or in the event of system failure/upgrades.
It is critical to migrate data to their target locations
as quickly as possible to obtain the best performance of the system.
Most of the previous results on data migration assume that each storage
node can perform only one data transfer at a time. A storage node,
however, typically can handle multiple transfers simultaneously and
this can reduce the total migration time significantly.
Moreover, storage devices tend to have heterogeneous capabilities
as devices may be added over time due to storage demand increase.
We consider  the \emph{heterogeneous data migration} problem
where we assume that each storage node has different transfer constraint ,
representing how many \emph{simultaneous} transfers the node can handle.
We develop algorithms to minimize the data migration time. 
We show that it is possible to find
an optimal migration schedule when all 's are even. Furthermore, though
the problem is \textsf{NP}-hard in general, we give an efficient    \emph{soft edge coloring} algorithm
that offers a rigorous -approximation guarantee.



\end{abstract}

\newpage

\doublespacing

\tableofcontents

\singlespacing

\newpage


\section{Soft Edge Coloring }
\label{sec:soft}


\subsection{Introduction}
In a  multi-radio multi-channel wireless network, simultaneous transmissions from nearby nodes over the same wireless channel may \emph{interfere} with each other and as a result can degrade the performance of the network.
One way to overcome this limitation is to assign independent channels (that can be used without interference) to nearby links of the network. However, the number of independent channels that can be employed is usually limited and insufficient and thus conflicts are bound to happen.\\
\B 
Consider the example shown in Figure~\ref{fig:3node}.
If all links use the same channel for transmissions, only one 
pair of nodes may communicate with each other at a time
due to interferences.  However, if there are three channels available 
and each node has two wireless interface cards (so 
it can use two channels), then we may assign a different channel to each link so that all links can be used at the same time. 

\begin{figure}[h]
\begin{center}
    \centerline{\includegraphics[width=1.4in]{fig1.pdf}}
    \caption{\small Each node has two wireless interface cards 
(thus can use two different channels) and three channels are available in the network.
	We can assign a distinct channel to each link as shown above so that 
there is no conflict among links.
\label{fig:3node}}
\vspace{-0.3in}
\end{center}
\end{figure}

We informally define the \textsc{Soft edge coloring} for the channel assignment  problem as follows:
We are given a graph , and constraints on the number of 
wireless cards  for all . These constraints limit the number
of colors that edges incident to  can use. 
In addition, we have a constraint on the total number
of channels available in the network (denoted as ).
For a pair of edges incident to a vertex, they are said to be {\em conflicting} 
if the colors assigned to them are the same.
Our goal is to color edges (assign channels) so that
the number of conflicts is minimized while satisfying 
constraints on the number of colors that can be used. 
In section \ref{sec:soft}, we study this problem for homogeneous networks where 
and   and for networks  where  or  for all nodes . \\


In section \ref{sec:hom} we consider a homogeneous network where 
and  for all nodes ,  we show 
that the problem is NP-hard for homogeneous networks (section \ref{sec:np}).
We present two combinatorial algorithms in sections \ref{sec:greedy} and \ref{sec:improv} :
First a distributed greedy algorithm that
gives a solution with at most  more conflicts than the optimal solution,
which implies a -approximation. 
The second algorithm  yields at most  more conflicts than the optimal solution. 
The approximation ratio is , which gives a ()-factor for dense graphs. 
The algorithm generalizes Vizing's algorithm in the sense that it gives the same result as Vizing's algorithm when . Moreover, we show in section \ref{sec:best} that this approximation result is best possible unless .
\B
For the case where  or ,
we show in section \ref{sec:hetnp} that the problem is NP-hard even when  or , and , and present two approximation algorithms.
The first algorithm in section \ref{sec:ext} is completely combinatorial and has an approximation ratio of . The second is an SDP-based algorithm, producing a solution with an approximation ratio of  for , and  in general (section \ref{sec:sdp}).

\subsubsection{Edge coloring}
In the traditional edge coloring problem,
the goal is to find the minimum number 
of colors required to have a proper edge coloring.
The problem is -hard even for cubic graphs \cite{Holyer}.
For a simple graph, a solution using at most  colors
can be found by Vizing's theorem \cite{V64} where
 is the maximum degree of a node.
For multigraphs, there is an approximation algorithm
which uses at most  colors where  is the optimal number of colors 
required \cite{multigraph} (the additive term was improved to  by Caprara
 \cite{caprara98improving}). 
Recently, Sanders and Steurer developed an algorithm that
gives a solution with  colors \cite{sanders05}.


{\sc Soft edge coloring} is a variant of the {\sc Edge coloring} problem.
In our problem, coloring need not be proper (two adjacent edges
are allowed to use the same color)---the goal is to minimize the
number of such conflicts. In addition, each node has its local color constraint, which limits the
number of colors that can be used by the edges incident to the node.
For example, if a node has two wireless cards (), 
the node can choose two colors 
and edges incident to the node should use only those two colors.



\subsubsection{Related Work} 
\paragraph{Relationship to \textsc{Min k-partition} and \textsc{Max k-cut}.} 
The {\sc Min k-partition} problem is 
to color vertices with  different colors
so that the total number of conflicts (monochromatic edges) is minimized.
It is the dual of the well-known {\sc Max k-cut} problem \cite{kann:istcs}.
Our problem for homogeneous networks ( for all ) 
is an edge coloring version of {\sc Min -parition} problem\footnote{
Or it can be considered as {\sc Min -partition} problem  
when the given graph is a line graph where 
the line graph of  has a vertex corresponding to
each edge of , and there is an edge between two vertices
in the line graph if the corresponding edges
are incident on a common vertex in .}.
Kann \cite{kann:istcs} showed that for  and for every ,
there exists a constant  such that the {\sc Min -partition} 
cannot be approximated within a constant factor
unless 
\footnote{Their objective function is
slightly different from ours as they do not count self-conflicts. Their inapproximability bound 
of O() can be extended to the bound of O() in our objective function.}. 


\paragraph{Other Related Work.}
Fitzpatrick and Meertens~\cite{softexp} have considered a variant of 
graph coloring problem (called the {\sc Soft graph coloring} problem)
where the objective is to develop a distributed  algorithm for coloring
vertices so that the number of conflicts is minimized.
The algorithm repeatedly recolors vertices to quickly reduce 
the conflicts to an acceptable level.
They have studied experimental performance for regular graphs 
but no theoretical analysis has been provided.   
Damaschke~\cite{softpath} presented a distributed soft coloring algorithm
for special cases such as paths and grids, 
and provided the analysis on the number of conflicts as a function of time . 
In particular, the conflict density on the path is given as  
when two colors are used,
where the conflict density is the number of conflicts divided by .

\subsubsection{Problem Definition}
We are given a graph  representing a wireless network, where  represents a node in the wireless network and an edge  represents a communication link
between  and .
Each node  can use  different channels and the total number
of channels that can be used in the network is . 
More formally, let  be the set of edges incident to  and  be the channel assigned to . 
Then  and 
.
\iffalse when we color edges, we can use at most  colors and for each node ,
edges in  can use at most  different colors
(We use {\em channel} and {\em color} interchangeably).
\fi

A pair of edges  and  in  are said to be conflicting
if the two edges use the same channel.
Let us define the {\em conflict number},  of an edge 
 at a vertex  to be the number of edges (including ) that conflict with  at .
In other words, for an edge  incident to ,
 is the number of edges in   that use the same channel as . 
Our goal is to minimize the total number of conflicts. That is, 

Note that in (\ref{eq:metric}) each conflict is counted twice. We can also define the total number of conflicts as the sum of the squares of the color classes at each node.
That is, let  be the set of  edges with color  at node . Then,  

The two objective functions are equivalent.
Note that the number of conflicts at a vertex , , 
is minimized locally when edges in  are distributed evenly to each color.
Figure \ref{fig:cfexample} shows a feasible coloring and  the number of conflicts for the given graph.
\begin{figure}[ht]
\begin{center}
    \centerline{\includegraphics[width=4in]{fig3.pdf}}
    \caption{
 ( conflicts at  and  conflicts at ),  ( conflict at  and  conflicts at ),  and .
\newline
Total number of conflicts is .
\label{fig:cfexample}}
\end{center}   
\end{figure} 

In sections \ref{sec:hom} and \ref{sec:improv}, we denote {\em channels} by {\em
colors} and use edge coloring and channel assignment, interchangeably.
We also use conflicts and interferences interchangeably.


\subsection{Algorithms for Homogeneous Networks}
\label{sec:hom}

In this section, we consider the case for a homogeneous network where for all nodes v, the number of channels that can be used is the same (). 
\subsubsection{NP hardness}
\label{sec:np}
For an arbitrary , the problem is NP-hard as the edge coloring problem can be reduced to our problem by setting  where  is the maximum degree of nodes.


\subsubsection{Greedy Algorithm} 
\label{sec:greedy}
The greedy algorithm works as follows:
We choose colors from  
(We only use  colors even for problem instances where  as  is the worst case.) For any  uncolored edge ,
we choose a color for edge  that introduces 
the smallest number of conflicts.
More formally, when we assign a color to ,
we count the number of edges in 
that are already colored with  (denoted as ),
and choose color  with the smallest , ties are broken arbitrarily. 

\begin{algorithm}[h]
\caption{\bf  Greedy Algorithm}
\label{dgreedy}
\begin{algorithmic}
\FOR {each edge }
	\FOR {each color }
	\STATE compute the number of edges in  and  using color .
	\ENDFOR
	\STATE let  be the color with min  for all colors .
	\STATE assign color  to edge .

\ENDFOR
\end{algorithmic}
\end{algorithm}

\begin{theorem}
\label{th:onehop-greedy}
The greedy algorithm yields at most   conflicts more than the optimal solution
in homogeneous networks, which implies  a  -approximation.
\end{theorem}
To prove Theorem \ref{th:onehop-greedy} we need to show the following two lemmas. We first obtain a lowerbound on the optimal solution.

\begin{lemma}
The total number of conflicts when  for all nodes  in any channel assignment
is at least
.
\label{lemma:lower}
\end{lemma}

The second lemma gives an upperbound on the number of conflicts in our solution.
\begin{lemma}
The total number of conflicts introduced by the greedy algorithm is at most 
.
\label{lemma:upper}
\end{lemma}
Note that the algorithm can be performed in a distributed manner as each node needs only local information. 

\noindent{\em Remark 1:} we can consider a simple randomized algorithm, in which each edge
chooses its color uniformly at random from . 
The algorithm gives the same expected approximation guarantee and
it can be easily derandomized using conditional expectations.  \\



\subsubsection{Improved Algorithm}
\label{sec:improv}
In this section, we give an algorithm with an additive factor of 2 and an approximation ratio of  . Our algorithm is a generalization of Vizing's algorithm in the sense that
it gives the same result as Vizing's algorithm  when  where  is the maximum degree of nodes. 
We first define some notations. For each vertex , let  and .

Let  be the size of the color class of color  at vertex  i.e. the number of edges adjacent to  that have color .

\begin{definition}
A color  is called \emph{strong} on a vertex  if . A color  is called weak on  
if  . A color  is called very weak on  if .
\end{definition}
\begin{definition}
A vertex  has a \emph{balanced} coloring if the number of strong classes at  is at most  and no color class in  is larger than . A graph  has a balanced coloring if each vertex  has a balanced coloring.   
\end{definition}

The intuition behind the definition of balanced coloring is that the local number of conflicts at a vertex is minimized when
edges are distributed as evenly as possible to each color. We try to achieve the balanced coloring
by not creating too many strong color classes and also allowing at most one more strong color class than the optimal solution.
In the following we present an algorithm that achieves a balanced coloring for a given graph ;  we show in Theorem~\ref{approxfactor} that a balanced coloring implies an additive approximation factor of 2 in terms of number of conflicts and an approximation ratio of . 

In Algorithm {\sc BalancedColoring}() described below, we color edge  so that the graph has a balanced coloring 
(which may require the recoloring of already colored edges to maintain the balanced coloring),
assuming that it had a balanced coloring before coloring .
We perform {\sc BalanacedColoring} for all edges in arbitrary order.
The following terms are used in the algorithm description.
Let  denote the number of strong color classes at vertex .
\begin{definition}\label{def:weak}
For vertex  with  or with ,  is a missing color if  is weak or very weak on .  For vertex  with ,  is a missing color if  is very weak on 
\end{definition}

In Lemma \ref{missing}, we will show that it is safe to use a missing color at a vertex 
for an edge incident to it (i.e., we can maintain the balanced coloring property).

\begin{definition}\label{def:path}
An \emph{-path} between vertices  and  where  and  are colors, is a path connecting  and  and has the following properties:
\begin{itemize}
\item Edges in the path have alternating colors  and . 
\item Let  be the first edge on that path and suppose  is colored , then  must be missing  and not missing . 
\item If  is reached by an edge colored  then  must be missing  but not missing , otherwise if  is reached by an edge colored  then  must be missing  and not missing .
\end{itemize}  
\end{definition}
\begin{definition}
A flipping of an -path is a recoloring of the edges on the path such that edges previously with color  will be recolored with color  and vice versa. 
\end{definition}

Note that an -path is not necessarily a simple path and may contain a cycle as a vertex can have multiple edges with the same color.
We show that flipping an -path does not violate the balanced coloring property in Lemma \ref{flipping}.
Algorithm {\sc BalancedColroing} works as follows. \\


\begin{figure}[t]
\begin{center}
    \centerline{\includegraphics{fig2.pdf}}
    \caption{\small The figures illustrate how recoloring is performed in {\sc BalancedColoring}. The colors beside edges
indicate the original color and the color after recoloring. \vspace{-0.3in}}
 \label{fig:phaseone}
 \end{center}
\end{figure}

\noindent Algorithm {\sc BalancedColoring(}) \\
Let . At -th round (), we do the following. \\
\underline{STEP 1:} Let  be the set of missing colors on .
If ,  is the set of missing colors on . 
When ,  is  the set of missing colors on  excluding color .
( is defined in STEP 2 at -th round).
If , 
then choose a color , color edge  with  and terminate. \\
\underline{STEP 2:} If , choose  and  ( and   by lemma \ref{saturated} ) . Find a -path that starts at  and ends at a vertex other than . If such a path exists, flip this path, color edge  with  and terminate (Fig. \ref{fig:phaseone} a).\\
\underline{STEP 3:} If all -paths that start at vertex  end at , fix one path and let  be the last edge on that path. The edge  must have color  by definition \ref{def:path} . Uncolor it and color edge  with  (Fig. \ref{fig:phaseone} b). Mark edge  as ``used" and go to -th round and repeat the above steps with edge .


\paragraph{Analysis} In the following, we prove that our algorithm terminates and achieves 
a balanced coloring. First Lemma \ref{saturated} and \ref{lemma:saturated2} show that we can always find a missing color at each round and at Lemma \ref{termin} shows that at some round ,
the algorithm terminates. Due to the choice of missing colors and -path,
we can show that our algorithm gives a balanced coloring (Lemma \ref{missing} and \ref{flipping} ).

\begin{lemma}\label{saturated}
\iffalse
For vertex  with , if  has a balanced coloring and an uncolored adjacent edge  then there must be a very weak color class in .
For vertex  with , has a balanced coloring then there must be a very weak color class at .
\fi
For a given edge , there is a missing color at  and .
That is,  and  .
\end{lemma}

For , ,  we need to choose a missing color at  other than . We prove in the following lemma
that there is a missing color other than . 
\begin{lemma}\label{lemma:saturated2}
At -th round (), there is a missing color other than  at . 
\end{lemma}

\begin{lemma}\label{termin}
At some round , there exists a -path starting at  and not ending at .
\end{lemma}

\begin{figure}[ht]      
\begin{center}        
  \begin{center}
    \centerline{\includegraphics[width=1.5in]{fig4.pdf}}
    \caption{if the -path  connecting  and  exists then  is a -path connecting  and , so the algorithm would terminate at STEP 2 in round .
\label{fig:lemma12}}
  \end{center}
\end{center}
\end{figure}

\begin{lemma}\label{missing}
Let  be a vertex that has a balanced coloring. Let  be uncolored and let  be a missing color on . Coloring  with  will not violate the balanced coloring property at . 
\end{lemma}

\begin{lemma}\label{flipping}
A flipping of an -path in a graph with balanced coloring will not violate the balanced coloring.
Moreover, a terminal node of the path which was originally missing  (resp., ) and not missing  (resp., )
will be missing  (resp., ) after flipping.
\end{lemma}

\begin{theorem}\label{mainthm}
The above algorithm terminates and achieves a balanced coloring.
\end{theorem}

\begin{theorem}\label{approxfactor}
A balanced coloring of a graph gives at most  more conflicts than  which implies a -approximation algorithm for the soft edge coloring problem in homogeneous networks.
\end{theorem}

\begin{corollary}
For any  if   the algorithm gives an optimal solution.
\end{corollary}


\subsubsection{Best Possible approximation for dense graphs unless P = NP}
\label{sec:best}
 We can show that the approximation ratio given by the algorithm 
is best possible unless . 
\begin{theorem}
For a given constant , it is NP-hard to approximate the channel assignment problem  in homogeneous networks 
within an additive term of  and thus it is NP-hard to get an approximation factor with  .
\label{theorem:inapprox}
\end{theorem}

\subsection{Networks where  or }
\label{sec:het}
In this section, 
we present two algorithms for networks with  or 
 and analyze the approximation ratios of the algorithms.
The case where  or  is interesting since 
 it reflects a realistic setting, in which 
most of mobile stations are equipped with one wireless card and 
nodes with multiple wireless cards are placed in strategic places
to increase the capacity of networks.

\subsubsection{NP-Hardness}
\label{sec:hetnp}
The problem is NP-hard even when  or . We show it by reducing 3SAT to this problem. 
\begin{theorem}
The channel assignment problem to minimize the number of conflicts 
is NP-hard even when  or , and .
\label{theorem:nphard}
\end{theorem}

\subsubsection{Extended Greedy Algorithm}
\label{sec:ext}


Here we present an extended greedy algorithm when  or ,
and .
The approximation factor is . Even though
the algorithm based on SDP (semi-definite programming) gives
a better approximation factor (see Section \ref{sec:sdp}), 
the greedy approach gives a simple combinatorial algorithm. 
The algorithm generalizes the idea of the greedy algorithm 
for homogeneous networks.

Before describing the algorithm, we define some notations. 
Let  be the set of nodes  with 
(i.e., we have  and ).
 consists of connected clusters ,
such that nodes  belong to the same cluster
if and only if there is a path composed of nodes in  only.
(See Figure \ref{fig:cgreedy} for example.)
Let   be a set of edges both of which endpoints are in .
We also define  to be a set of edges whose one
endpoint is in  and the other is in . We can think of 
 as a set of edges in the boundary of cluster .
Note that all edges in  should have the same color.
  is a set of edges both of which endpoints are in .
 is defined to be  and  is defined to be 

\begin{figure}[ht]      
\begin{center}        
  \begin{center}
    \centerline{\includegraphics[width=2.5in]{fig7.pdf}}
    \caption{The figure shows an example of clusters 
when  or . Black nodes have only one wireless card
and white nodes have  wireless cards. Dotted lines belong
to .
\label{fig:cgreedy}}
  \end{center}
\end{center}
\end{figure}

In the greedy algorithm for homogeneous networks,
each edge greedily chooses a color so that
the number of conflicts it creates (locally) is minimized.
Similarly, when  or , edges in the same cluster 
choose a color  so that the number of conflicts it creates is minimized.
Formally, we choose a color  with minimum value of 
 where
 is the number of edges  with color . Algorithm \ref{cgreedy} describes the extended greedy algorithm.

\begin{algorithm}[ht]
\caption{\bf  Extended Greedy Algorithm}
\label{cgreedy}
\begin{algorithmic}
\FOR {each cluster }
	\STATE (choose a color for edges in  as follows)

\IF { is empty} 
	\STATE choose any color for .
\ELSE 
	\FOR{each color  }
	\STATE count the number of conflicts to be created 
when we choose color  for .
Formally, count  where
 is the number of edges  
with color .
\ENDFOR
\STATE choose a color  
that  minimizes . 
\ENDIF
\ENDFOR

\FOR{each edge that belongs to }
\STATE choose a color using the greedy algorithm
in Section \ref{section:greedy}.
\ENDFOR
\end{algorithmic}
\end{algorithm}


Any edges   incident to a vertex in 
should use the same color and therefore are conflicting with each other no matter what algorithm we use.
Given an optimal solution, consider  and 
where  is the number of conflicts at vertices in .
Similarly, we have  and  where
 is the number of conflicts at vertices in  in our solution.
Then we have . Therefore, we only need to
compare  and 

\begin{theorem}
\iffalse
The number of conflicts created by the extended greedy algorithm 
at  is at most 
where  is . 
\fi
The approximation ratio of the extended greedy algorithm 
at  is  .
\label{th:1k-approx}
\end{theorem}

Note that as in the homogeneous case, 
we can obtain the same expected approximation guarantee with a randomized algorithm, 
i.e., choose a color uniformly at random for each cluster .
Note also that the approximation ratio remains the same for any .
In the following section, we obtain a slightly better approximation factor 
using SDP relaxation  when  or  and .

\subsubsection{SDP-based Algorithm}
\label{sec:sdp}

In this subsection, we assume that  different channels are
available in the network and all nodes have  or  wireless cards.  We formulate the problem using semidefinite programming.
Consider the following vector program (VP), which we can  
convert to an SDP and obtain an optimal solution in polynomial time. 
We have an -dimensional unit vector  for each edge  ().


We can relate a solution of VP to a channel assignment as follows.
Consider  unit length vectors in -dimensional space such 
that for any pair of vectors  and , 
the dot product of the vectors is .
(these  vectors form an equilateral -simplex on a -dimensional space
\cite{kcut,kms94}.)
Given an optimal channel assignment of the problem,
we can map each channel to a vector .
 takes the vector that corresponds to the channel of edge .
If , all edges incident to  should have the same color.
The objective function is exactly the same as the number of 
conflicts in the given channel assignment
since if  ( and  have the same color),
it contributes  to the objective function, and 0 otherwise.
Thus the optimal solution of the VP gives a lower bound on the optimal solution.


The above VP can be converted to a semidefinite program (SDP) and
solved in polynomial time (within any desired precision) 
\cite{ali95,gls81,gls87,nn90,nn94}, and given a solution for the SDP,
we can find a solution to the corresponding VP, 
using incomplete Cholesky decomposition \cite{golub83}. 

We use the rounding technique used for {\sc Maxcut} by Goeman and Williamson 
\cite{GW} when  and show that the expected number of conflicts 
in the solution is at most .When , we obtain  the approximation guarantee of   
where .\\



\section{Data Migration}

\subsection{Introduction}

Large-scale storage systems are crucial components for today's data-intensive 
applications such as search engine clusters, video-on-demand servers, sensor networks, and grid computing.
A storage cluster can consist of several hundreds to thousands of storage devices,
which are typically 
connected using a dedicated high-speed network. In such systems, data locations may have to be changed over time 
for load balancing or in the event of disk addition and removal which can occur freuqently \cite{UCSB}.
It is critical to migrate data to their target disks
as quickly as possible to obtain the best performance of the system
since the storage system will perform sub-optimally  
until migrations are finished.


The data migration problem can be informally defined as follows.
We have a set of disks  and
a set of data items . Initially,
each disk stores a subset of items. Over time, data items
may be moved to another disk for load balancing or for system reconfiguration.
We can construct a \emph{transfer graph}  where 
each node represents a disk and an edge  represents a data item
to be moved from disk  to . 
Note that the transfer graph can be a multi-graph (i.e., there
can be multiple edges between two nodes) when multiple data
items are to be moved from one disk to another.
See Figure~\ref{fig:dm-example} for example.
In their ground-breaking work, Hall ~\cite{Karlin} studied
the data migration problem of scheduling migrations 
and developed efficient approximation algorithms.
In their algorithm, they assume that each disk can participate
in only one migration at a time and  both disks and data items are identical;
they show that this is exactly the problem of edge-coloring the transfer graph. 
Algorithms for edge-coloring multigraphs can now be applied to produce 
a migration schedule since each color class represents a matching 
in the graph that can be scheduled simultaneously.
\begin{figure}[h]
\centering
\includegraphics[width=2.5in,height=1.5in]{dm.pdf}
\vspace{0.2in}
\caption{
An example of data transfer instance}
\label{fig:dm-example}
\end{figure}

\subsection{Related Work}
Hall et al ~\cite{Karlin} studied
the problem of scheduling migrations given a set of disks, with each storing a subset of items
and a specified set of migrations. A crucial constraint in their problem is that each disk can participate
in only one migration at a time. If both disks and data items are identical,
this is exactly the problem of edge-coloring a multi-graph.
That is, we can create a transfer graph  that has a node corresponding to each disk, and
a directed edge corresponding to each migration that is specified.
Algorithms for edge-coloring multigraphs can now be applied to produce
a migration schedule since each color class represents a matching
in the graph that can be scheduled simultaneously.
Computing a solution with the minimum number of
colors is \textsf{NP}-hard \cite{holyerNPhard}, but several approximation algorithms
are available for edge coloring

\subsection{Problem Definition}
In the {\sc Heterogeneous Data Migration} problem, 
we are given a transfer graph .
Each node in  represents a disk in the system
and each edge  in  represents
a data item that need to be transferred from  to .
We assume that each data item has the same length, and therefore
it takes the same amount of time for each data to migrate.
Note that the resulting graph is a multi-graph as
there may be several data items to be sent from disk  to disk .

We assume that transfers between disks can be done through 
a very fast network connection dedicated to support a storage system.
Therefore, we assume that any two disks can send data to each other directly.
{\em In particular, we assume that each disk  can handle multiple transfers
at a time. Transfer constraint  represents 
how many parallel data transfers the disk  can perform
simultaneously}.

Our objective is to minimize the number of rounds
to finish all data migrations.

\subsubsection{Lower Bounds}
We have the following two lower bounds on the optimal solution.

where  is the set of edges both of which endpoints
are in .

 follows from the fact that for a node , at most  data items can be migrated
in a round.  When all 's are even,  and, 
in fact, we show that there is a migration schedule that can be
completed in  rounds.
The following lemma proves that  is a lower bound on the optimal
solution.
\begin{lemma}
 is a lower bound on the optimal solution.
\end{lemma}
\begin{proof}
An optimal migration is a decomposition of edges in  into 
 such that for each  and a vertex ,
there is at most  edges incident to  in .
For a subset , let  be
the set of edges in  both of which endpoints are in 
and  be the number of edges in  incident to .
Then .
As , we have .
As 's cover all edges in , the lemma follows.
\end{proof}


\subsection{Optimal Migration Schedule for Even Transfer Constraints}

In this section, we describe a polynomial time algorithm to find an optimal migration
schedule when each node  has even transfer constraint . We show that it is possible to obtain a migration schedule using  rounds.

\subsubsection{Outline of Algorithm}
We first present the outline of our algorithm when  is even for any .

\begin{enumerate}
\item[(1)] Construct  so that every node has degree exactly    
by adding dummy edges.
\item[(2)] Find a Euler cycle (EC) on . 
\item[(3)] Construct a bipartite graph  by considering the directions of edges
obtained in . That is, for each node  in , create two copies 
and . For an edge  in , if the edge is visited
from  to  in , then create an edge from  to  in .
\item[(4)] We now decompose  into  components
by repeatedly finding a -matching in . 
\item[(5)] Let  be the matching
obtained in Step (4). Then schedule one matching in each round.
\end{enumerate}


\subsubsection{Description and Analysis}\label{sec:detail_even}
We now describe the details and show that
the algorithm gives an optimal migration schedule.
\vspace{0.1in}
\noindent{Step (4):}
We now find a -matching in   where exactly  edges are matched for each 
and . We show the following lemma.
\begin{figure}[h]
\centering
\includegraphics[width=3in]{flow.pdf}
\caption{Flow Network for Step (4)}
\label{fig:flow}
\end{figure}
\vspace{0.1in}

\vspace{0.1in}
\noindent{Step (1)-(3):} 
The first three steps  are a generalization of
Peterson's theorem.  can be constructed as follows.
For any node  with degree less than , we add
loops until degree of the node becomes at least .
Note that after the modification, the number of node with degree 
 is even as 's are even. Pair the nodes and add edges 
so that every node has degree .

Note that each node in  has even degree  as all 's are even. 
Therefore, we can find a Euler cycle  on .
Note that  for each node , there are  incoming edges
and  outgoing edges in  .

We construct a bipartite graph  by considering the directions of edges
obtained in . For each node  in , create two copies 
and . For an edge  in , if the edge is visited
from  to  in , then create an edge from  to  in .
As each node  in  has  incoming edges and
 outgoing edges in , the degrees of  and
  in  is also .

We construct a bipartite graph  by considering the directions of edges
obtained in . For each node  in , create two copies 
and . For an edge  in , if the edge is visited
from  to  in , then create an edge from  to  in .
As each node  in  has  incoming edges and
 outgoing edges in , the degrees of  and
  in  is also .

\vspace{0.1in}
\noindent{Step (4):}
We now find a -matching in   where exactly  edges are matched for each 
and . 

\begin{theorem}
We can find an optimal migration schedule when each node has even .
\end{theorem}

We can show the theorem by showing the following lemmas 

\begin{lemma}
There exists  a -matching in  and it can be found in polynomial time.
\end{lemma}

\begin{lemma}
We can decompose  into 
so that each  is a -matching in .
\end{lemma}

\begin{lemma}
Each component  can be scheduled in one round.
\end{lemma}

\subsection{Soft Edge Coloring - General Case}
In this section, we consider the case that each node  has an arbitrary .
The problem is \textsf{NP}-hard even when  for all nodes.
We develop a soft edge coloring algorithm that colors edges of the given graph so that  
the transfer constraints  of the nodes are satisfied. 
The coloring defines a data migration schedule and, 
as the number of colors used determines the number of rounds in our schedule, 
we would like our coloring algorithm to minimize the number of colors needed.
We obtain an algorithm that uses at most  colors

\subsubsection{Outline of the Algorithm}
We first  give an overview of the coloring algorithm. 
Our algorithm is inspired by the recent work for multi-graph edge coloring algorithm by
Sanders and Steurer~\cite{sanders05} and generalized their algorithm.
Our algorithm uses three particular subgraph structures, balancing orbits, color orbits and edge orbits,
which is defined Section~\ref{sec:struct}. 
The latter two structures --- color orbits and edge orbits --- are generalizations of 
the structures used by Sanders and Steurer~\cite{sanders05}.
\iffalse
In Section~\ref{sec:alg} we describe the algorithm in detail and, in Section~\ref{sec:analysis}, show that it uses at most  colors.
\fi

The algorithm starts with a naive partial coloring of  and proceeds in two phases. 
In the first phase, we use three structures and color edges until we produce 
a simple uncolored subgraph   (Section \ref{sec:bad})
consisting of small connected components (Section \ref{sec:size}); in the second phase 
we color  and show that  new colors
are enough to obtain a proper coloring in  (Section \ref{sec:simple}).

\subsubsection{Preliminaries} \label{sec:struct}

We first introduce some definitions.
Let  be the number of edges of color  adjacent to a vertex .
\begin{definition}[Strongly/lightly missing color]
Color  is \emph{saturated} at vertex  if . The color  is \emph{missing} at vertex  if  is less than ; in this case we distinguish two possibilities: 
\begin{itemize}
\item  is \emph{strongly missing} if . 
\item  is \emph{lightly missing} if .
\end{itemize}
\end{definition} 



We will reuse definition \ref{def:path} for altenating paths but  unlike the case when , an alternating path may not be a simple path  as there can be multiple edges with the same color incident to a node.

\paragraph{Balancing Orbits}
\vspace{5pt}
We first define balancing orbits as follows.
\begin{definition}[balancing orbit] 
\label{def:balancing}
A \emph{balancing orbit}  is a node induced subgraph such that 
all nodes  are connected by uncolored edges and the following property holds
\begin{itemize}
\item A vertex  is strongly missing a color.
\item There are at least two nodes  lightly missing the same color.
\end{itemize}
\end{definition}
\begin{figure}
\centering
\includegraphics[scale = 0.45]{bal.pdf}
\caption{ strongly missing  and path  ends at , we can color  with }
\label{fig:bal}
\end{figure}
\vspace{0.2in}
The following lemma shows that if we have a balancing orbit, we can color
an uncolored edge and eventually remove any balancing orbits.
\begin{lemma}\label{lemma:balancing}
If there is a balancing orbit in , then we can color a previously uncolored edge.
\end{lemma}

\paragraph{Color Orbits and Edge Orbits}
In this section, we define two subgraph structures: a \emph{color orbit} and an \emph{edge orbit}, 
which are basically generalizations of the structures defined in \cite{sanders05}.

\begin{definition}[Color orbit]
\label{def:color}
A \emph{color orbit}  is a node induced subgraph such that
all nodes  are connected by uncolored edges and the following property holds
\begin{itemize}
\item There are at least two nodes  lightly missing the same color.
\end{itemize}

\end{definition}

\begin{lemma}\label{lemma:balancing2}
\cite{sanders05} If there exists a color orbit in  then we can color a previously uncolored edge.
\end{lemma}

By Lemma \ref{lemma:balancing} and \ref{lemma:balancing2}, 
whenever we find a balancing orbit or color orbit, we can color a previously 
uncolored edge and make progress.
If neither of properties in Definition \ref{def:balancing} and \ref{def:color}
hold, we call  a \emph{tight color orbit}.

\vspace{5pt}
Our goal at the end of Phase 1 of the algorithm is to get a \emph{simple} uncolored graph  consisting of small connected components.
That is, in  there cannot be more than one uncolored edges between two nodes. 
In order to eliminate parallel uncolored edges the following subgraph structure is used.

\begin{definition}[Lean and bad edges]
If an edge  is colored and all its parallel edges are colored then  is a \emph{lean} edge. 
If  is uncolored and has a parallel uncolored edge then  is a \emph{bad} edge.
\end{definition}

\begin{definition}
An \emph{edge orbit} is a subgraph consisting of two uncolored parallel edges (called the \emph{seed} of the edge orbit) and then is inductively defined as follows:
Let  be an edge in the edge orbit , let  and  be missing colors at  and  respectively and let  be the alternating path starting at  then  is an edge orbit if
\begin{itemize}
\item no edge of color a or b is contained in .
\item  that was not in the vertex set of .\\
\end{itemize}
\end{definition}
If edge orbit  has a lean edge then  is called a weak edge orbit otherwise  is a tight edge orbit. A color  is free for an edge orbit  if  does not contain an edge with color . 

The following lemma from \cite{sanders05} states that if in some coloring of , there exists a weak edge orbit then we make progress toward our goal of obtaining  by either coloring a previously uncolored edge or by uncoloring a lean edge and coloring a bad edge.
\begin{lemma}\label{lemma:weakedge}
\cite{sanders05} If a coloring of  contains a weak edge orbit then we can either color a previously uncolored edge or we can uncolor a lean edge and color a bad edge.\\
\end{lemma}

A tight edge orbit does not have lean edges so its vertex set is connected 
by uncolored edges and thus a tight edge orbit is one of the following 
--- a balancing orbit, color orbit or a tight color orbit. 
When it is a tight color orbit, as we cannot make progress toward , 
which we call a \emph{hard orbit}. 
Note that no vertex in a hard orbit is strongly missing a color, no two
nodes are lightly messing the same color, and no edge in a hard orbit is lean.

\paragraph{Growing Orbits}
A color  is \emph{full} in a hard orbit  if  is saturated on all vertices of  but at most one vertex in  is lightly missing  or equivalently if 
So if color  is full in a hard orbit  it cannot be used to color uncolored edges whose endpoints are in .
\begin{definition}[Lower bound witnesses]
A hard orbit is a -witness if all missing colors at some node are non-free. It is a -witness if all free colors of the orbit are full.
\end{definition}
The intuition behind the witnesses is the following. Suppose very few colors are used in hard orbit , in the case of -witness almost all color classes are full in  and in the case of a -witness almost all available colors are strong on some node . So a witness in some coloring using  colors indicates that it is \textit{almost} impossible to color an additional uncolored edge using the available  colors and thus the number of available colors needs to be increased.  
\begin{lemma}\label{lemma:groworbit}
\cite{sanders05} Given a hard orbit in some coloring we can either find a witness or compute a larger edge orbit.
\end{lemma} 

\subsubsection{Algorithm}\label{sec:alg}
The algorithm proceeds in two phases. The outcome of the first phase would be , a simple uncolored graph with no large components. 
The following procedure for the first phase 
eliminates all the bad edges in  (Section \ref{sec:bad}) and reduce the size of connected components 
(Section \ref{sec:size}), which gives  with the desired properties.
In the second phase (Section \ref{sec:simple}), we color the remaining subgraph .

\paragraph{Eliminating bad edges}
\label{sec:bad}
Given a partial coloring using  colors, we iterate over a list of bad edges and we execute the following steps (Note a bad edge is a trivial edge orbit).
Given an edge orbit  
\begin{enumerate}
\item[(1)] If nodes of  form a balancing or color orbit, 
apply Lemma \ref{lemma:balancing} or \ref{lemma:balancing2}.
\item[(2)] If  is weak, apply Lemma \ref{lemma:weakedge}.
\item[(3)] If  is a hard orbit, apply Lemma \ref{lemma:groworbit}.
\begin{enumerate}
\item If Lemma \ref{lemma:groworbit} gives a larger edge orbit , repeat with .
\item If Lemma \ref{lemma:groworbit} gives a witness then increase  by one color and color the bad edges in the seed with the additional color.
\end{enumerate}
\end{enumerate}
\vspace{11 pt}
The output of this procedure is a simple subgraph  of  induced by uncolored edges. 
In Lemma \ref{lemma:witness1} and Lemma \ref{lemma:witness2},
we show an upper bound on the number of used colors if there is a  or -witness. The next procedure reduces the size of the connected components of  whenever  has balancing or color orbits.

\paragraph{Reducing size of connected components}
\label{sec:size}
For every connected component  of , 
\begin{enumerate}
\item If  contains a vertex that is strongly missing a color then use Lemma \ref{lemma:balancing} to color an uncolored edge.
\item If  contains two or more vertices that are lightly missing the same color use Lemma \ref{lemma:balancing2} to color an uncolored edge.
\end{enumerate}
So at the end of the first phase we have the simple subgraph  where for every connected component  of ,
 no vertex is strongly missing a color and no two vertices of  miss the same color. 
 In Lemma \ref{lemma:size}, we show that the size of  is no more than .
\paragraph{Coloring } \label{sec:simple}
Phase 2 colors . We use  only  colors. The procedure goes as follows: 
\begin{enumerate}
\item Create  copies of each vertex  and distribute the edges over the copies so that each vertex is adjacent to at most 
 edges where  represents the degree of  in .
\item Use Vizing's algorithm to properly color each component. We need at most  + 1 colors.
\item Contract the copies back to  getting a coloring where for any node  there is no more than
 edges of the same color. 
\end{enumerate}



\subsubsection{Analysis}\label{sec:analysis}
In the following  denotes the total number of colors available for the algorithm. We show that the algorithm colors all the edges of  using at most  colors.
We first bound the number of used colors when there is a  or -witness.
In particular, we show that when there exists a -witness, 
the total number of colors is a constant more than  and does not depend on the size of ,
which is tighter than the analysis given in \cite{sanders05}.

\begin{lemma}\label{lemma:witness1}
Let  be a hard orbit. If  is a -witness then

where  . 
\end{lemma}

\begin{lemma}\label{lemma:witness2}
Let  be a hard orbit. If  is a -witness then 
\end{lemma}

We now bound the size of .

\begin{lemma} \label{lemma:size}
Let  be a tight color orbit. Then  
\end{lemma} 

The following corollary follows from Lemma \ref{lemma:witness1}, \ref{lemma:witness2}, 
and Corollary \ref{cor:size}, 

\begin{corollary}\label{cor:cwitness}
If  and 
there is a witness then 
\end{corollary}

The following lemma provides a bound on the number of required colors for .
\begin{lemma} \label{lemma:G0}
Suppose that the size of the largest component of  is bounded by . 
Then coloring  requires at most  colors.
\end{lemma}

\begin{theorem}
Given a transfer graph , we can compute a coloring of the edges using at most 
colors.
\end{theorem}

\begin{corollary}
The coloring algorithm uses at most  colors, which implies an approximation factor of  as   increases.
\end{corollary}




\bibliographystyle{plain}
\bibliography{TR_SoftEdge}
 
\end{document}