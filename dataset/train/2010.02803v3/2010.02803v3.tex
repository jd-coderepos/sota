 
\documentclass{article} \usepackage{iclr2021_conference,times}

\iclrfinalcopy



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
	
\usepackage{hyperref}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{adjustbox}
\usepackage{graphicx}
\usepackage{ulem}
\usepackage{placeins}
\usepackage{hhline}
\usepackage{caption}
\usepackage{multirow}
\usepackage{graphicx} 

\graphicspath{{figures/}} 

\usepackage{booktabs}

\title{A Transformer-based Framework for Multivariate Time Series Representation Learning}



\author{George Zerveas\\
Brown University\\
Providence, RI, USA \\
\texttt{george\_zerveas@brown.edu}\\

\And
Srideepika Jayaraman, \\
IBM Research\\
Yorktown Heights, NY, USA \\
\texttt{j.srideepika@ibm.com}\\

\And
Dhaval Patel \\
IBM Research \\
Yorktown Heights, NY, USA \\
\texttt{pateldha@us.ibm.com}\\

\And
Anuradha Bhamidipaty \\
IBM Research \\
Yorktown Heights, NY, USA \\
\texttt{anubham@us.ibm.com}\\

\And
Carsten Eickhoff \\
Brown University\\
Providence, RI, USA \\
\texttt{carsten@brown.edu}\\
}





\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}


\maketitle

\begin{abstract}
In this work we propose for the first time a transformer-based framework for unsupervised representation learning of multivariate time series. Pre-trained models can be potentially used for downstream tasks such as regression and classification, forecasting and missing value imputation. By evaluating our models on several benchmark datasets for multivariate time series regression and classification, we show that our modeling approach represents the most successful method  employing unsupervised learning of multivariate time series presented to date; it is also the first unsupervised approach shown to exceed the current state-of-the-art performance of supervised methods. It does so by a significant margin, even when the number of training samples is very limited, while offering computational efficiency. Finally, we demonstrate that unsupervised pre-training of our transformer models offers a substantial performance benefit over fully supervised learning, even without leveraging additional unlabeled data, i.e., by reusing the same data samples through the unsupervised objective.
\end{abstract}

\section{Introduction}

Multivariate time series (MTS) are an important type of data that is ubiquitous in a wide variety of domains, including science, medicine, finance, engineering and industrial applications.
As the name suggests, they typically represent the evolution of a group of synchronous variables (e.g., simultaneous measurements of different physical quantities) over time, but they can more generally represent a group of dependent variables (abscissas) aligned with respect to a common independent variable, e.g., absorption spectra under different conditions as a function of light frequency. Despite the recent abundance of MTS data in the much touted era of ``Big Data'', the availability of \textit{labeled} data in particular is far more limited: extensive data labeling is often prohibitively expensive or impractical, as it may require much time and effort, special infrastructure or domain expertise. For this reason, in all aforementioned domains there is great interest in methods which can offer high accuracy by using only a limited amount of labeled data or by leveraging the existing plethora of unlabeled data.

There is a large variety of modeling approaches for univariate and multivariate time series, with deep learning models recently challenging and at times replacing the state of the art in tasks such as forecasting, regression and classification~\citep{de_brouwer_gru-ode-bayes_2019, regression_monash_2020, ismail_fawaz_deep_review2019}. However, unlike in domains such as Computer Vision or Natural Language Processing (NLP), the dominance of deep learning for time series is far from established: in fact, non-deep learning methods such as TS-CHIEF~\citep{ts-chief_2020}, HIVE-COTE~\citep{hive_cote_2018}, and ROCKET~\citep{rocket_2020} currently hold the record on time series regression and classification dataset benchmarks~\citep{regression_monash_2020, classification_archive}, matching or even outperforming sophisticated deep architectures such as InceptionTime~\citep{inceptiontime_2019} and ResNet~\citep{ismail_fawaz_deep_review2019}. 

In this work, we investigate, for the first time, the use of a transformer encoder for unsupervised representation learning of multivariate time series, as well as for the tasks of time series regression and classification. Transformers are an important, recently developed class of deep learning models, which were first proposed for the task of natural language translation~\citep{vaswani_attention_2017} but have since come to monopolize the state-of-the-art performance across virtually all NLP tasks~\citep{t5}. A key factor for the widespread success of transformers in NLP is their aptitude for learning how to represent natural language through unsupervised pre-training~\citep{gpt3, t5, devlin_bert_2018}.  Besides NLP, transformers have also set the state of the art in several domains of sequence generation, such as polyphonic music composition~\citep{music2018}.

Transformer models are based on a multi-headed attention mechanism that offers several key advantages and renders them particularly suitable for time series data (see Appendix section~\ref{sec:transformer_advantages} for details).

Inspired by the impressive results attained through unsupervised pre-training of transformer models in NLP, as our main contribution, in the present work we develop a generally applicable methodology (framework) that can leverage unlabeled data by first training a transformer model to extract dense vector representations of multivariate time series through an input denoising (autoregressive) objective. The pre-trained model can be subsequently applied to several downstream tasks, such as regression, classification, imputation, and forecasting. Here, we apply our framework for the tasks of multivariate time series regression and classification on several public datasets and demonstrate that transformer models can convincingly outperform all current state-of-the-art modeling approaches, even when only having access to a very limited amount of training data samples (on the order of hundreds of samples), an unprecedented success for deep learning models. To the best of our knowledge, this is also the first time that unsupervised learning has been shown to confer an advantage over supervised learning for classification and regression of multivariate time series without utilizing additional unlabeled data samples. Importantly, despite common preconceptions about transformers from the domain of NLP, where top performing models have billions of parameters and require days to weeks of pre-training on many parallel GPUs or TPUs, we also demonstrate that our models, using at most hundreds of thousands of parameters, can be practically trained even on CPUs; training them on GPUs allows them to be trained as fast as even the fastest and most accurate non-deep learning based approaches.



\section{Related Work}

\textbf{Regression and classification of time series}:
Currently, non-deep learning methods such as TS-CHIEF~\citep{ts-chief_2020}, HIVE-COTE~\citep{hive_cote_2018}, and ROCKET~\citep{rocket_2020} constitute the state of the art for time series regression and classification based on evaluations on public benchmarks~\citep{regression_monash_2020, classification_archive}, followed by CNN-based deep architectures such as InceptionTime~\citep{inceptiontime_2019} and ResNet~\citep{ismail_fawaz_deep_review2019}. ROCKET, which on average is the best ranking method, is a fast method that involves training a linear classifier on top of features extracted by a flat collection of numerous and various random convolutional kernels. HIVE-COTE and TS-CHIEF (itself inspired by Proximity Forest~\citep{proximity_forest_2019}), are very sophisticated methods which incorporate expert insights on time series data and consist of large, heterogeneous ensembles of classifiers utilizing shapelet transformations, elastic similarity measures, spectral features, random interval and dictionary-based techniques; however, these methods are highly complex, involve significant computational cost, cannot benefit from GPU hardware and scale poorly to datasets with many samples and long time series; moreover, they have been developed for and only been evaluated on \textit{univariate} time series.

\textbf{Unsupervised learning for multivariate time series}:
Recent work on unsupervised learning for multivariate time series has predominantly employed autoencoders, trained with an input reconstruction objective and implemented either as Multi-Layer Perceptrons (MLP) or RNN (most commonly, LSTM) networks. As interesting variations of the former, \citet{kopf_mixture--experts_2019} and \citet{fortuin_som-vae_2019} additionally incorporated Variational Autoencoding into this approach, but focused on clustering and the visualization of shifting sample topology with time. As an example of the latter, \citet{malhotra_timenet_2017} presented a multi-layered RNN sequence-to-sequence autoencoder, while \citet{lyu_improving_2018} developed a multi-layered LSTM with an attention mechanism and evaluated both an input reconstruction (autoencoding) as well as a forecasting loss for unsupervised representation learning of Electronic Healthcare Record multivariate time series.

As a novel take on autoencoding, and with the goal of dealing with missing data, \citet{bianchi_learning_2019} employ a stacked bidirectional RNN encoder and stacked RNN decoder to reconstruct the input, and at the same time use a user-provided kernel matrix as prior information to condition internal representations and encourage learning similarity-preserving representations of the input. They evaluate the method on the tasks of missing value imputation and classification of time series under increasing ``missingness'' of values.
For the purpose of time series clustering, \citet{lei_similarity_2017} also follow a method which aims at preserving similarity between time series by directing learned representations to approximate a distance such as Dynamic Time Warping (DTW) between time series through a matrix factorization algorithm. 

A distinct approach is followed by~\citet{mscred_2019}, who use a composite convolutional - LSTM network with attention and a loss which aims at reconstructing correlation matrices between the variables of the multivariate time series input. They use and evaluate their method only for the task of anomaly detection.

Finally, \citet{jansen_unsupervised_2018} rely on a triplet loss and the idea of temporal proximity (the loss rewards similarity of representations between proximal segments and penalizes similarity between distal segments of the time series) for unsupervised representation learning of non-speech audio data. This idea is explored further by~\citet{franceschi19}, who combine the triplet loss with a deep causal CNN with dilation, in order to make the method effective for very long time series. Although on the task of \textit{univariate} classification the method is outperformed by the aforementioned supervised state-of-the-art methods, it is the best performing method leveraging unsupervised learning for univariate and multivariate classification datasets of the UEA/UCR archive~\citep{classification_archive}.


\textbf{Transformer models for time series}:
Recently, a full encoder-decoder transformer architecture was employed for \textit{univariate} time series forecasting: \citet{li2019enhancing} showed superior performance compared to the classical statistical method ARIMA, the recent matrix factorization method TRMF, an RNN-based autoregressive model (DeepAR) and an RNN-based state space model (DeepState) on 4 public forecasting datasets,  while~\citet{transformer_influenza} used a transformer to forecast influenza prevalence and similarly showed performance benefits compared to ARIMA, an LSTM and a GRU Seq2Seq model with attention, and \citet{lim2020temporal} used a transformer for multi-horizon univariate forecasting, supporting interpretation of temporal dynamics. Finally,~\cite{Ma2019CDSACS} use an encoder-decoder architecture with a variant of self-attention for imputation of missing values in multivariate, geo-tagged time series and outperform classic as well as the state-of-the-art, RNN-based imputation methods on 3 public and 2 competition datasets for imputation.

By contrast, our work aspires to generalize the use of transformers from solutions to specific generative tasks (which require the full encoder-decoder architecture) to a framework which allows for unsupervised pre-training and with minor modifications can be readily used for a wide variety of downstream tasks; this is analogous to the way BERT~\citep{devlin_bert_2018} converted a translation model into a generic framework based on unsupervised learning, an approach which has become a de facto standard and established the dominance of transformers in NLP.

\section{Methodology}

\subsection{Base model}\label{sec:base_model}

At the core of our method lies a transformer encoder, as described in the original transformer work by ~\citet{vaswani_attention_2017}; however, we do not use the decoder part of the architecture.  A schematic diagram of the generic part of our model, common across all considered tasks, is shown in Figure~\ref{fig:generic_architecture_pretraining}. We refer the reader to the original work for a detailed description of the transformer model, and here present the proposed changes that make it compatible with multivariate time series data, instead of sequences of discrete word indices.

\begin{figure}[h]
    \centering
    \includegraphics[width=1\linewidth]{Generic_architecture_Pretraining.png}
    \caption{\textbf{Left:} Generic model architecture, common to all tasks. The feature vector  at each time step  is linearly projected to a vector  of the same dimensionality  as the internal representation vectors of the model and is fed to the first self-attention layer to form the keys, queries and values after adding a positional encoding. \textbf{Right:} Training setup of the unsupervised pre-training task. We mask a proportion  of each variable sequence in the input independently, such that across each variable, time segments of mean length  are masked, each followed by an unmasked segment of mean length . Using a linear layer on top of the final vector representations , at each time step the model tries to predict the full, uncorrupted input vectors ; however, only the predictions on the masked values are considered in the Mean Squared Error loss.}
    \label{fig:generic_architecture_pretraining}
\end{figure}

In particular, each training sample , which is a multivariate time series of length  and  different variables, constitutes a sequence of  feature vectors :  . The original feature vectors  are first normalized (for each dimension, we subtract the mean and divide by the variance across the training set samples) and then linearly projected onto a -dimensional vector space, where  is the dimension of the transformer model sequence element representations (typically called \textit{model dimension}):



\noindent where ,  are learnable parameters and  are the model input vectors\footnote{Although \eqref{lin_proj} shows the operation for a single time step for clarity, all input vectors are embedded concurrently by a single matrix-matrix multiplication}, which correspond to the word vectors of the NLP transformer.
These will become the queries, keys and values of the self-attention layer, after adding the positional encodings and multiplying by the corresponding matrices. 

We note that the above formulation also covers the univariate time series case, i.e., , although we only evaluate our approach on multivariate time series in the scope of this work. We additionally note that the input vectors  need not necessarily be obtained from the (transformed) feature vectors at a time step : because the computational complexity of the model scales as  and the number of parameters\footnote{Specifically, the learnable positional encoding, batch normalization and output layers} as  with the input sequence length ,  to obtain  in case the granularity (temporal resolution) of the data is very fine, one may instead use a 1D-convolutional layer with 1 input and  output channels and kernels  of size , where  is the width in number of time steps and  the output channel:



In this way, one may control the temporal resolution by using a stride or dilation factor greater than 1. Moreover, although in the present work we only used \eqref{lin_proj}, one may use \eqref{conv_proj} as an input to compute the keys and queries and \eqref{lin_proj} to compute the values of the self-attention layer. This is particularly useful in the case of univariate time series, where self-attention would otherwise match (consider relevant/compatible) all time steps which share similar values for the independent variable, as noted by~\citet{li2019enhancing}.

Finally, since the transformer is a feed-forward architecture that is insensitive to the ordering of input, in order to make it aware of the sequential nature of the time series, we add positional encodings  to the input vectors : .

Instead of deterministic, sinusoidal encodings, which were originally proposed by \cite{vaswani_attention_2017}, we use fully learnable positional encodings, as we observed that they perform better for all datasets presented in this work. Based on the performance of our models, we also observe that the positional encodings generally appear not to significantly interfere with the numerical information of the time series, similar to the case of word embeddings; we hypothesize that this is because they are learned so as to occupy a different, approximately orthogonal, subspace to the one in which the projected time series samples reside. This approximate orthogonality condition is much easier to satisfy in high dimensional spaces. 

An important consideration regarding time series data is that individual samples may display considerable variation in length. This issue is effectively dealt with in our framework: after setting a maximum sequence length  for the entire dataset, shorter samples are padded with arbitrary values, and we generate a padding mask which adds a large negative value to the attention scores for the padded positions, before computing the self-attention distribution with the softmax function. This forces the model to completely ignore padded positions, while allowing the parallel processing of samples in large minibatches.

Transformers in NLP use layer normalization after computing self-attention and after the feed-forward part of each encoder block, leading to significant performance gains over batch normalization, as originally proposed by \cite{vaswani_attention_2017}. However, here we instead use batch normalization, because it can mitigate the effect of outlier values in time series, an issue that does not arise in NLP word embeddings. Additionally, the inferior performance of batch normalization in NLP has been mainly attributed to extreme variation in sample length (i.e., sentences in most tasks)~\citep{powernorm_2020}, while in the datasets we examine this variation is much smaller. In Table~\ref{tab:batchnorm_layernorm} of the Appendix we show that batch normalization can indeed offer a very significant performance benefit over layer normalization, while the extent can vary depending on dataset characteristics. 

\subsection{Regression and classification}

The base model architecture presented in Section~\ref{sec:base_model} and depicted in Figure~\ref{fig:generic_architecture_pretraining} can be used for the purposes of regression and classification with the following modification: the final representation vectors  corresponding to all time steps are concatenated into a single vector , which serves as the input to a linear output layer with parameters , , where  is the number of scalars to be estimated for the regression problem (typically ), or the number of classes for the classification problem:



In the case of regression, the loss for a single data sample will simply be the squared error , where  are the ground truth values. We clarify that regression in the context of this work means predicting a numeric value for a given sequence (time series sample). This numeric value is of a different nature than the numerical data appearing in the time series: for example, given a sequence of simultaneous temperature and humidity measurements of 9 rooms in a house, as well as weather and climate data such as temperature, pressure, humidity, wind speed, visibility and dewpoint, we wish to predict the total energy consumption in kWh of a house for that day. The parameter  corresponds to the number of scalars (or the dimensionality of a vector) to be estimated.

In the case of classification, the predictions  will additionally be passed through a softmax function to obtain a distribution over classes, and its cross-entropy with the categorical ground truth labels will be the sample loss.

Finally, when fine-tuning the pre-trained models, we allow training of all weights; instead, freezing all layers except for the output layer would be equivalent to using static, pre-extracted time-series representations of the time series. In Table~\ref{tab:static_vs_tunable} in the Appendix we show the trade-off in terms of speed and performance when using a fully trainable model versus static representations.

\subsection{Unsupervised pre-training} \label{sec:unsupervised_pretraining}
	
As a task for the unsupervised pre-training of our model we consider the autoregressive task of denoising the input: specifically, we set part of the input to 0 and ask the model to predict the masked values. The corresponding setup is depicted in the right part of Figure~\ref{fig:generic_architecture_pretraining}. A binary noise mask , is created independently for each training sample, and the input is masked by elementwise multiplication: . On average, a proportion  of each mask column of length  (corresponding to a single variable in the multivariate time series) is set to 0 by alternating between segments of 0s and 1s. We choose the state transition probabilities such that each masked segment (sequence of 0s) has a length that follows a geometric distribution with mean  and is succeeded by an unmasked segment (sequence of 1s) of mean length . We chose  for all presented experiments. The reason why we wish to control the length of the masked sequence, instead of simply using a Bernoulli distribution with parameter  to set all mask elements independently at random, is that very short masked sequences (e.g., of 1 masked element) in the input can often be trivially predicted with good approximation by replicating the immediately preceding or succeeding values or by the average thereof. In order to obtain enough long masked sequences with relatively high likelihood, a very high masking proportion  would be required, which would render the overall task detrimentally challenging. Following the process above, at each time step on average  variables will be masked. We empirically chose  for all presented experiments. This input masking process is different from the ``cloze type'' masking used by NLP models such as BERT, where a special token and thus word embedding vector replaces the original word embedding, i.e., the \textit{entire} feature vector at affected time steps. We chose this masking pattern because it encourages the model to learn to attend both to preceding and succeeding segments in individual variables, as well as to existing contemporary values of the other variables in the time series, and thereby to learn to model inter-dependencies between variables. In Table~\ref{tab:masking_schemes} in the Appendix we show that this masking scheme is more effective than other possibilities for denoising the input.

Using a linear layer with parameters ,  on top of the final vector representations , for each time step the model concurrently outputs its estimate  of the full, uncorrupted input vectors ; however, only the predictions on the masked values (with indices in the set , where  are the elements of the mask ), are considered in the Mean Squared Error loss for each data sample:



This objective differs from the one used by denoising autoencoders, where the loss considers reconstruction of the entire input, under (typically Gaussian) noise corruption. Also, we note that the approach described above differs from simple dropout on the input embeddings, both with respect to the statistical distributions of masked values, as well as the fact that here the masks also determine the loss function. In fact, we additionally use a dropout of 10\% when training all of our supervised and unsupervised models.


\section{Experiments \& Results}

In the experiments reported below we use the predefined training - test set splits of the benchmark datasets and train all models long enough to ensure convergence. We do this to account for the fact that training the transformer models in a fully supervised way typically requires more epochs than fine-tuning the ones which have already been pre-trained using the unsupervised methodology of Section~\ref{sec:unsupervised_pretraining}. Because the benchmark datasets are very heterogeneous in terms of number of samples, dimensionality and length of the time series, as well as the nature of the data itself, we observed that we can obtain better performance by a cursory tuning of hyperparameters (such as the number of encoder blocks, the representation dimension, number of attention heads or dimension of the feed-forward part of the encoder blocks) separately for each dataset. To select hyperparameters, for each dataset we randomly split the training set in two parts, 80\%-20\%, and used the 20\% as a validation set for hyperparameter tuning. After fixing the hyperparameters, the entire training set was used to train the model again, which was finally evaluated on the test set. A set of hyperparameters which has consistently good performance on all datasets is shown in Table~\ref{good_config} in the Appendix, alongside the hyperparameters that we have found to yield the best performance for each dataset (Tables~\ref{tab:hyperparams_supervised_regression_datasets}, \ref{tab:hyperparams_unsupervised_regression_datasets}, \ref{tab:hyperparams_supervised_classification_datasets}, \ref{tab:hyperparams_unsupervised_classification_datasets}. 

\subsection{Regression} \label{sec:regression}

We select a diverse range of 6 datasets from the Monash University, UEA, UCR Time Series Regression Archive~\cite{regression_monash_2020} in a way so as to ensure diversity with respect to the dimensionality and length of time series samples, as well as the number of samples (see Appendix Table~\ref{tab:characteristics_regression_datasets} for dataset characteristics). Table~\ref{tab:performance_regression} shows the Root Mean Squared Error achieved by of our models, named TST for ``Time Series Transformer'', including a variant trained only through supervision, and one first pre-trained on the same \textit{training set} in an unsupervised way. We compare them with the currently best performing models as reported in the archive. Our transformer models rank first on all but two of the examined datasets, for which they rank second. They thus achieve an average rank of 1.33, setting them clearly apart from all other models; the overall second best model, XGBoost, has an average rank of 3.5, ROCKET (which outperformed ours on one dataset) on average ranks in 5.67th place and Inception (which outperformed ours on the second dataset) also has an average rank of 5.67. On average, our models attain 30\% lower RMSE than the mean RMSE among all models, and approx.\ 16\% lower RMSE than the overall second best model (XGBoost), with absolute improvements varying among datasets from approx.\ 4\% to 36\%. We note that all other deep learning methods achieve performance close to the middle of the ranking or lower. In Table~\ref{tab:performance_regression} we report the "average relative difference from mean" metric  for each model , the  over  datasets: , where  is the RMSE of model  on dataset  and  is the number of models.

Importantly, we also observe that the pre-trained transformer models outperform the fully supervised ones in 3 out of 6 datasets. This is interesting, because no additional samples are used for pre-training: the benefit appears to originate from reusing the same training samples for learning through an unsupervised objective. To further elucidate this observation, we investigate the following questions:

\textbf{Q1: Given a partially labeled dataset of a certain size, how will additional labels affect performance?} This pertains to one of the most important decisions that data owners face, namely, to what extent will further annotation help. To clearly demonstrate this effect, we choose the largest dataset we have considered from the regression archive (12.5k samples), in order to avoid the variance introduced by small set sizes. The left panel  of Figure~\ref{fig:Q1_Q2} (where each marker is an experiment) shows how performance on the entire test set varies with an increasing proportion of labeled training set data used for \textit{supervised} learning. As expected, with an increasing proportion of available labels performance improves both for a fully supervised model, as well as the same model that has been first pre-trained on the entire training set through the unsupervised objective and then fine-tuned. Interestingly, not only does the pre-trained model outperform the fully supervised one, but the benefit persists throughout the entire range of label availability, even when the models are allowed to use all labels; this is consistent with our previous observation on Table~\ref{tab:performance_regression} regarding the advantage of reusing samples.
    
\textbf{Q2: Given a labeled dataset, how will additional \textit{unlabeled} samples affect performance?} In other words, to what extent does unsupervised learning make it worth collecting more data, even if no additional annotations are available?  
This question differs from the above, as we now only scale the availability of data samples for \textit{unsupervised} pre-training, while the number of labeled samples is fixed. The right panel of Figure~\ref{fig:Q1_Q2} (where each marker is an experiment) shows that, for a given number of labels (shown as a percentage of the totally available labels), the more data samples are used for unsupervised learning, the lower the error achieved (note that the horizontal axis value 0 corresponds to fully supervised training only, while all other values to unsupervised pre-training followed by supervised fine-tuning). This trend is more linear in the case of supervised learning on 20\% of the labels (approx.\ 2500). Likely due to a small sample (here, meaning set) effect, in the case of having only 10\% of the labels (approx.\ 1250) for supervised learning, the error first decreases rapidly as we use more samples for unsupervised pre-training, and then momentarily increases, before it decreases again (for clarity, the same graphs are shown separately in Figure~\ref{fig:Q2_detail} in the Appendix).
Consistent with our observations above, it is interesting to again note that, for a given number of labeled samples, even reusing a subset of the \textit{same samples} for unsupervised pre-training improves performance: for the 1250 labels (blue diamonds of the right panel of Figure~\ref{fig:Q1_Q2} or left panel of Figure~\ref{fig:Q2_detail} in the Appendix) this can be observed in the horizontal axis range , and for the 2500 labels (blue diamonds of the right panel of Figure~\ref{fig:Q1_Q2} or right panel of Figure~\ref{fig:Q2_detail} in the Appendix) in the horizontal axis range .


\begin{figure}[h]
    \centering
    \includegraphics[width=1\linewidth]{Q1_Q2_newColor_crop.pdf}
    \caption{Dataset: BeijingPM25Quality. \textbf{Left:} Root Mean Squared Error of a fully supervised transformer (orange circles) and the same model pre-trained (blue diamonds) on the training set through the unsupervised objective and then fine-tuned on available labels, versus the proportion of labeled data in the training set. \textbf{Right:} Root Mean Squared Error of a given model as a function of the number of samples (here, shown as a proportion of the total number of samples in the training set) used for unsupervised pre-training. For supervised learning, two levels of label availability are depicted: 10\% (purple circles) and 20\% (green squares) of all training data labels. Note that a horizontal axis value of 0 means fully supervised learning only, while all other values correspond to unsupervised pre-training followed by supervised fine-tuning.}
    \label{fig:Q1_Q2}
\end{figure}




\begin{table}
\centering
\begin{adjustbox}{width=1.2\textwidth,center=\textwidth}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} 
\cline{2-14}
\multicolumn{1}{c|}{}              & \multicolumn{13}{c|}{\textbf{Root MSE} }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \\ 
\cline{2-14}
\multicolumn{1}{c|}{}              & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}                                                                       & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}                                                 & \multicolumn{1}{c}{}                                                   & \multicolumn{1}{c}{}                                                   & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} &                     & \multicolumn{2}{c|}{\textbf{Ours} }                                                                                                                           \\ 
\hline
\textbf{Dataset}                   & \textbf{SVR}         & \begin{tabular}[c]{@{}c@{}}\textbf{Random}\\\textbf{\textasciitilde{}Forest} \end{tabular} & \textbf{XGBoost}     & \textbf{1-NN-ED}     & \begin{tabular}[c]{@{}c@{}}\textbf{5-NN}\\\textbf{-ED} \end{tabular} & \begin{tabular}[c]{@{}c@{}}\textbf{1-NN-}\\\textbf{DTWD} \end{tabular} & \begin{tabular}[c]{@{}c@{}}\textbf{5-NN-}\\\textbf{DTWD} \end{tabular} & \textbf{Rocket}      & \textbf{FCN}         & \textbf{ResNet}      & \textbf{Inception}  & \begin{tabular}[c]{@{}c@{}}\textbf{TST }\\\textbf{(sup. only)} \end{tabular} & \begin{tabular}[c]{@{}c@{}}\textbf{TST }\\\textbf{(pretrained)} \end{tabular}  \\ 
\hline
AppliancesEnergy                   & 3.457                & 3.455                                                                                      & 3.489                & 5.231                & 4.227                                                                & 6.036                                                                  & 4.019                                                                  & \uline{2.299}        & 2.865                & 3.065                & 4.435               & \textbf{2.228}                                                               & 2.375                                                                          \\
BenzeneConcentr.                   & 4.790                & 0.855                                                                                      & 0.637                & 6.535                & 5.844                                                                & 4.983                                                                  & 4.868                                                                  & 3.360                & 4.988                & 4.061                & 1.584               & \uline{0.517}                                                                & \textbf{0.494}                                                                 \\
BeijingPM10                        & 110.574              & 94.072                                                                                     & 93.138               & 139.229              & 115.669                                                              & 139.134                                                                & 115.502                                                                & 120.057              & 94.348               & 95.489               & 96.749              & \uline{91.344}                                                               & \textbf{86.866}                                                                \\
BeijingPM25                        & 75.734               & 63.301                                                                                     & \uline{59.495}       & 88.193               & 74.156                                                               & 88.256                                                                 & 72.717                                                                 & 62.769               & 59.726               & 64.462               & 62.227              & 60.357                                                                       & \textbf{53.492}                                                                \\
LiveFuelMoisture                   & 43.021               & 44.657                                                                                     & 44.295               & 58.238               & 46.331                                                               & 57.111                                                                 & 46.290                                                                 & \textbf{41.829}      & 47.877               & 51.632               & 51.539              & \uline{42.607}                                                               & 43.138                                                                         \\
IEEEPPG                            & 36.301               & 32.109                                                                                     & 31.487               & 33.208               & 27.111                                                               & 37.140                                                                 & 33.572                                                                 & 36.515               & 34.325               & 33.150               & \textbf{23.903}     & \uline{25.042}                                                               & 27.806                                                                         \\ 
\hline\hline
\textbf{Avg Rel. diff. from mean}  & 0.097                & -0.172                                                                                     & -0.197               & 0.377                & 0.152                                                                & 0.353                                                                  & 0.124                                                                  & -0.048               & 0.021                & 0.005                & -0.108              &  \uline{-0.301}                                                              &  \textbf{-0.303 }                                                              \\ 
\hline
\textbf{Avg Rank}                  & 7.166                & 4.5                                                                                        & 3.5                  & 10.833               & 8                                                                    & 11.167                                                                 & 7.667                                                                  & 5.667                & 6.167                & 6.333                & 5.666               & \multicolumn{2}{c|}{\textbf{1.333} }                                                                                                                          \\
\hline
\end{tabular}
\end{adjustbox}
\caption{Performance on \textbf{multivariate regression} datasets, in terms of Root Mean Squared Error. Bold indicates best values, underlining indicates second best.}
\label{tab:performance_regression}
\end{table}



\subsection{Classification}

We select a set of 11 multivariate datasets from the UEA Time Series Classification Archive~\citep{bagnall_uea_2018} with diverse characteristics in terms of the number, dimensionality and length of time series samples, as well as the number of classes (see Appendix Table~\ref{tab:characteristics_classification_datasets}). As this archive is new, there have not been many reported model evaluations; we follow \cite{franceschi19} and use as a baseline the best performing method studied by the creators of the archive,  (dimension-Dependent DTW), together with the method proposed by \cite{franceschi19} themselves (a dilation-CNN leveraging unsupervised and supervised learning).
Additionally, we use the publicly available implementations \cite{Tan2020Time} of ROCKET, which is currently the top performing model for univariate time series and one of the best in our regression evaluation, and XGBoost, which is one of the most commonly used models for univariate and multivariate time series, and also the best baseline model in our regression evaluation (Section~\ref{sec:regression}). 
Finally, we did not find any reported evaluations of RNN-based models on any of the UCR/UEA archives, possibly because of a common perception for long training and inference times, as well as difficulty in training \citep{ismail_fawaz_deep_review2019}; therefore, we implemented a stacked LSTM model and also include it in the comparison. The performance of the baselines alongside our own models are shown in Table~\ref{tab:performance_classification} in terms of accuracy, to allow comparison with reported values.

\begin{table}[h!]
\centering
\begin{adjustbox}{width=1.2\textwidth,center=\textwidth}
\begin{tabular}{|c|c|c|c|c|c|c|c|} 
\hline
                                                                                            & \multicolumn{2}{c|}{\textbf{Ours}}                                           &                  &                   & \begin{tabular}[c]{@{}c@{}}\\\end{tabular} &                                         &                  \\ 
\hline
\textbf{Dataset}                                                                            & \multicolumn{1}{l}{\textbf{TST (pretrained)}}     & \textbf{TST (sup. only)} & \textbf{Rocket~} & \textbf{XGBoost~} & \textbf{LSTM}                              & \textbf{Frans. et al}                   & \textbf{DTW\_D}  \\ 
\hline
EthanolConcentration                                                                        & 0.326                                             & 0.337                    & \textbf{0.452}   & \uline{0.437}     & 0.323                                      & 0.289                                   & 0.323            \\
FaceDetection                                                                               & \textbf{0.689}                                    & \uline{0.681}            & 0.647            & 0.633             & 0.577                                      & 0.528                                   & 0.529            \\
Handwriting                                                                                 & 0.359                                             & 0.305                    & \textbf{0.588}   & 0.158             & 0.152                                      & \uline{0.533}                           & 0.286            \\
Heartbeat                                                                                   & \textbf{0.776}                                    & \textbf{0.776}            & 0.756            & 0.732             & 0.722                                      & 0.756                                   & 0.717            \\
JapaneseVowels                                                                              & \textbf{0.997}                                    & \uline{0.994}            & 0.962            & 0.865             & 0.797                                      & 0.989                                   & 0.949            \\
InsectWingBeat                                                                              & \textbf{0.687}                                                 & \uline{0.684}           & -                & 0.369     & 0.176                                      & \textcolor[rgb]{0.149,0.196,0.22}{0.16} & -                \\
PEMS-SF                                                                                     & 0.896                                             & \uline{0.919}            & 0.751            & \textbf{0.983}    & 0.399                                      & 0.688                                   & 0.711            \\
SelfRegulationSCP1                                                                          & \uline{0.922}                                     & \textbf{0.925}           & 0.908            & 0.846             & 0.689                                      & 0.846                                   & 0.775            \\
SelfRegulationSCP2                                                                          & \textbf{0.604}                                       & \uline{0.589}          & 0.533            & 0.489             & 0.466                                      & 0.556                                   & 0.539            \\
SpokenArabicDigits                                                                          & \textbf{0.998}                                    & \uline{0.993}            & 0.712            & 0.696             & 0.319                                      & 0.956                                   & 0.963            \\
UWaveGestureLibrary                                                                         & \textcolor[rgb]{0.149,0.196,0.22}{\uline{~0.913}} & 0.903                    & \textbf{0.944}   & 0.759             & 0.412                                      & 0.884                                   & 0.903            \\ 
\hline
\begin{tabular}[c]{@{}c@{}}\textbf{Avg Accuracy}\\{(excl. InsectWingBeat)}\end{tabular} & \textbf{0.748}                                    & 0.742                    & 0.725            & 0.659             & 0.486                                      & 0.703                                   & 0.669            \\ 
\hline
\textbf{Avg Rank}                                                                           & \multicolumn{2}{c|}{\textbf{1.7}}                                            & 2.3              & 3.8               & 5.4                                        & 3.7                                     & 4.1              \\
\hline
\end{tabular}

\end{adjustbox}
\caption{Accuracy on \textbf{multivariate classification} datasets. Bold indicates best and underlining second best values. A dash indicates that the corresponding method failed to run on this dataset.}
\label{tab:performance_classification}
\end{table}


It can be seen that our models performed best on 7 out of the 11 datasets, achieving an average rank of 1.7, followed by ROCKET, which performed best on 3 datasets and on average ranked 2.3th. The dilation-CNN~\citep{franceschi19} and XGBoost, which performed best on the remaining 1 dataset, tied and on average ranked 3.7th and 3.8th respectively. Interestingly, we observe that all datasets on which ROCKET outperformed our model were very low dimensional (specifically, 3-dimensional). Although our models still achieved the second best performance for UWaveGestureLibrary, in general we believe that this indicates a relative weakness of our current models when dealing with very low dimensional time series. As discussed in Section~\ref{sec:base_model}, this may be due to the problems introduced by a low-dimensional representation space to the attention mechanism, as well as the added positional embeddings; to mitigate this issue, in future work we intend to use a 1D-convolutional layer to extract more meaningful representations of low-dimensional input features (see Section~\ref{sec:base_model}).  Conversely, our models performed particularly well on very high-dimensional datasets (FaceDetection, HeartBeat, InsectWingBeat, PEMS-SF), and/or datasets with relatively more training samples. As a characteristic example, on InsectWingBeat (which is by far the largest dataset with 30k samples and contains time series of 200 dimensions and highly irregular length) our model reached an accuracy of 0.689, while all other methods performed very poorly - the second best was XGBoost with an accuracy of 0.369. However, we note that our model performed exceptionally well also on datasets with only a couple of hundred samples, which in fact constitute 8 out of the 11 examined datasets.

Finally, we observe that the pre-trained transformer models performed better than the fully supervised ones in 8 out of 11 datasets, sometimes by a substantial margin.Again, no additional samples were available for unsupervised pre-training, so the benefit appears to originate from reusing the same samples.

\section{Additional points \& Future Work}

\textbf{Execution time for training:} While a precise comparison in terms of training time is well out of scope for the present work, in Section~\ref{sec:timing} of the Appendix we demonstrate that our transformer-based method is economical in terms of its use of computational resources. Alternative self-attention schemes, such as sparse attention patterns~\citep{li2019enhancing}, recurrence~\citep{dai_transformer-xl_2019} or compressed (global-local) attention~\citep{beltagy_longformer_2020}, can help drastically reduce the  complexity of the self-attention layers with respect to the time series length , which is the main performance bottleneck.

\textbf{Imputation and forecasting:} The model and training process described in Section~\ref{sec:unsupervised_pretraining} is exactly the setup required to perform imputation of missing values, without any modifications, and we observed that it was possible to achieve very good results following this method; as a rough indication, our models could reach Root Mean Square Errors very close to 0 when asked to perform the input denoising (autoregressive) task on the test set, after being subjected to unsupervised pre-training on the training set. We also show example results of imputation on one of the datasets presented in this work in Figure~\ref{fig:imputation}. However, we defer a systematic quantitative comparison with the state of the art to future work. Furthermore, we note that one may simply use different patterns of masking to achieve different objectives, while the rest of the model and setup remain the same. For example, using a mask which conceals the last part of all variables simultaneously, one may perform forecasting (see Figure~\ref{fig:forecasting_mask} in Appendix), while for longer time series one may additionally perform this process within a sliding window. Again, we defer a systematic investigation to future work.

\textbf{Extracted representations:} The representations   extracted by the transformer models can be used directly for evaluating similarity between time series, clustering, visualization and any other use cases where time series representations are used in practice. A valuable benefit offered by transformers is that representations can be independently addressed for each time step; this means that, for example, a greater weight can be placed at the beginning, middle or end of the time series, which allows to selectively compare time series, visualize temporal evolution of samples etc.


\section{Conclusion}

In this work we propose a novel framework for multivariate time series representation learning based on the transformer encoder architecture. The framework includes an unsupervised pre-training scheme, which we show that can offer substantial performance benefits over fully supervised learning, even without leveraging additional unlabeled data, i.e., by reusing the same data samples. By evaluating our framework on several public multivariate time series datasets from various domains and with diverse characteristics, we demonstrate that it is currently the best performing method for regression and classification, even for datasets where only a few hundred training samples are available, and the only top performing method based on deep learning. It is also the first unsupervised method shown to push the state-of-the-art performance for multivariate time series regression and classification.





\bibliography{iclr2021_conference}
\bibliographystyle{iclr2021_conference}


\appendix
\section{Appendix}


\subsection{Additional points \& Future Work}

\textbf{Execution time for training:} While a precise comparison in terms of training time is well out of scope for the present work, in Section~\ref{sec:timing} of the Appendix we demonstrate that our transformer-based method is economical in terms of its use of computational resources. However, alternative self-attention schemes, such as sparse attention patterns~\citep{li2019enhancing}, recurrence~\citep{dai_transformer-xl_2019} or compressed (global-local) attention~\citep{beltagy_longformer_2020}, can help drastically reduce the  complexity of the self-attention layers with respect to the time series length , which is the main performance bottleneck.

\textbf{Imputation and forecasting:} The model and training process described in Section~\ref{sec:unsupervised_pretraining} is exactly the setup required to perform imputation of missing values, without any modifications, and we observed that it was possible to achieve very good results following this method; as a rough indication, our models could reach Root Mean Square Errors very close to 0 when asked to perform the input denoising (autoregressive) task on the test set, after being subjected to unsupervised pre-training on the training set. We also show example results of imputation on one of the datasets presented in this work in Figure~\ref{fig:imputation}. However, we defer a systematic quantitative comparison with the state of the art to future work. Furthermore, we note that one may simply use different patterns of masking to achieve different objectives, while the rest of the model and setup remain the same. For example, using a mask which conceals the last part of all variables simultaneously, one may perform forecasting (see Figure~\ref{fig:forecasting_mask} in Appendix), while for longer time series one may additionally perform this process within a sliding window. Again, we defer a systematic investigation to future work.

\textbf{Extracted representations:} The representations   extracted by the transformer models can be used directly for evaluating similarity between time series, clustering, visualization and any other use cases where time series representations are used in practice. A valuable benefit offered by transformers is that representations can be independently addressed for each time step; this means that, for example, a greater weight can be placed at the beginning, middle or end of the time series, which allows to selectively compare time series, visualize temporal evolution of samples etc.


\begin{table}[h]
\centering
\small
\begin{tabular}{@{}|c|c|c|c|c|c|@{}}
\hline
Dataset               & Train Size & Test Size & Length & Dimension & Missing Values  \\ \hline
AppliancesEnergy           & 96         & 42        & 144    & 24        & No                   \\ 
BenzeneConcentration       & 3433       & 5445      & 240    & 8         & Yes                   \\ 
BeijingPM10Quality         & 12432      & 5100      & 24     & 9         & Yes                   \\ 
BeijingPM25Quality         & 12432      & 5100      & 24     & 9         & Yes                   \\ 
LiveFuelMoistureContent    & 3493       & 1510      & 365    & 7         & No                     \\ 
IEEEPPG                    & 1768       & 1328      & 1000   & 5         & No                      \\ \hline
\end{tabular}
\caption{Multivariate Regression Datasets}
\label{tab:characteristics_regression_datasets}
\end{table}


\begin{table}[h]
\begin{tabular}{@{}|c|c|c|c|c|c|c|@{}}
\hline
Dataset                 & TrainSize & TestSize & NumDimensions & SeriesLength & NumClasses  \\ \hline
EthanolConcentration    & 261       & 263      & 3             & 1751         & 4                   \\ 
FaceDetection   & 5890      & 3524     & 144           & 62           & 2                   \\ 
Handwriting             & 150       & 850      & 3             & 152          & 26                  \\ 
Heartbeat               & 204       & 205      & 61            & 405          & 2                   \\ 
InsectWingbeat  & 30000     & 20000    & 200           & 30           & 10                 \\ 
JapaneseVowels          & 270       & 370      & 12            & 29           & 9                   \\ 
PEMS-SF                 & 267       & 173      & 963           & 144          & 7                   \\ 
SelfRegulationSCP1      & 268       & 293      & 6             & 896          & 2                   \\ 
SelfRegulationSCP2      & 200       & 180      & 7             & 1152         & 2                   \\ 
SpokenArabicDigits      & 6599      & 2199     & 13            & 93           & 10                  \\ 
UWaveGestureLibrary     & 120       & 320      & 3             & 315          & 8                   \\ \hline
\end{tabular}
\caption{Multivariate Classification Datasets}
\label{tab:characteristics_classification_datasets}
\end{table}

\subsection{Criteria for dataset selection}

We select a diverge range of datasets from the Monash University, UEA, UCR Time Series Regression and Classification Archives, in a way so as to ensure diversity with respect to the dimensionality and length of time series samples, as well as the number of samples. Additionally, we have tried to include both "easy" and "difficult" datasets (where the baselines perform very well or less well). In the following we provide a more detailed rationale for each of the selected multivariate datasets.

\textbf{EthanolConcentration}: very low dimensional, very few samples, moderate length, large number of classes, challenging

\textbf{FaceDetection}: very high dimensional, many samples, very short length, minimum number of classes

\textbf{Handwriting}: very low dimensional, very few samples, moderate length, large number of classes

\textbf{Heartbeat}: high dimensional, very few samples, moderate length, minimum number of classes

\textbf{JapaneseVowels}: very heterogeneous sample length,  moderate num. dimensions, very few samples, very short length, moderate number of classes, all baselines perform well

\textbf{InsectWingBeat}: very high dimensional, many samples, very short length, moderate number of classes, very challenging

\textbf{PEMS-SF}: extremely high dimensional, very few samples, moderate length, moderate number of classes

\textbf{SelfRegulationSCP1}: Few dimensions, very few samples, long length, minimum number of classes, baselines perform well

\textbf{SelfRegulationSCP2}: similar to SelfRegulationSCP1, but challenging

\textbf{SpokenArabicDigits}: Moderate number of dimensions, many samples, very heterogeneous length, moderate number of classes, most baselines perform well

\textbf{UWaveGestureLibrary}: very low dimensional, very few samples, moderate length, moderate number of classes, baselines perform well






\begin{table}
\centering
\begin{tabular}{|c|c|c|} 
\hline
\multirow{2}{*}{ \textbf{Dataset}} & \multicolumn{2}{c|}{\textbf{Standard deviation}}  \\ 
\cline{2-3}
                                   & Supervised TST & Pre-trained TST                  \\ 
\hline
AppliancesEnergy                   & 0.240          & 0.163                            \\
BenzeneConcentration               & 0.031          & 0.092                            \\
BeijingPM10Quality                 & 0.689          & 0.813                            \\
BeijingPM25Quality                 & 0.189          & 0.253                            \\
LiveFuelMoistureContent            & 0.735          & 0.013                            \\
IEEEPPG                            & 1.079          & 1.607                            \\
\hline
\end{tabular}
\caption{Standard deviation of the Root Mean Square Error displayed by the Time Series Transformer models on multivariate regression datasets}
\label{tab:std_regression_datasets}
\end{table}


\begin{table}
\centering

\begin{tabular}{|c|c|c|} 
\hline
\multirow{2}{*}{ \textbf{Dataset}} & \multicolumn{2}{c|}{\textbf{Standard deviation}}  \\ 
\cline{2-3}
                                   & Supervised TST & Pre-trained TST                  \\ 
\hline
EthanolConcentration               & 0.024          & 0.002                            \\
FaceDetection                      & 0.007          & 0.006                              \\
Handwriting                        & 0.020          & 0.006                            \\
Heartbeat                          & 0.018          & 0.018                            \\
InsectWingbeat                     & 0.003          & 0.026                            \\
JapaneseVowels                     & 0.000          & 0.0016                           \\
PEMS-SF                            & 0.017          & 0.003                            \\
SelfRegulationSCP1                 & 0.005          & 0.006                            \\
SelfRegulationSCP2                 & 0.020          & 0.003                            \\
SpokenArabicDigits                 & 0.0003         & 0.001                            \\
UWaveGestureLibrary                & 0.005          & 0.003                            \\
\hline
\end{tabular}
\caption{Standard deviation of accuracy displayed by the Time Series Transformer models on multivariate classification datasets}
\label{tab:std_classification_datasets}
\end{table}








\subsection{Execution time}\label{sec:timing}

We recorded the times required for training our fully supervised models until convergence on a GPU, as well as for the currently fastest and top performing (in terms of classification accuracy and regression error) baseline methods, ROCKET and XGBoost on a CPU. These have been shown to be orders of magnitude faster than methods such as TS-CHIEF, Proximity Forest, Elastic Ensembles, DTW and HIVE-COTE, but also deep learning based methods~\cite{rocket_2020}.  Although XGBoost and ROCKET are incomparably faster than the transformer on a CPU, as can be seen in Table~\ref{tab:timing} in the Appendix, exploiting commercial GPUs and the parallel processing capabilities of a transformer typically enables as fast (and sometimes faster) training times as these (currently fastest available) methods. In practice, despite allowing for many hundreds of epochs, using a GPU we never trained our models longer than 3 hours on any of the examined datasets.

As regards deep learning models, LSTMs are well known to be slow, as they require  sequential operations (where  is the length of the time series) for each sample, with the complexity per layer scaling as , where  is the internal representation dimension (hidden state size). We refer the reader to the original transformer paper~\citep{vaswani_attention_2017} for a detailed discussion about how tranformers compare to Convolutional Neural Networks in terms of computational efficiency.




\begin{table}
\centering
\begin{tabular}{|c|c|c|c|} 
\hline
 \textbf{Dataset}    & \textbf{Rocket}  & \textbf{XGBoost}  & \textbf{TST (GPU)}  \\ 
\hline
EthanolConcentration & 41.937           & 3.760             & 34.72               \\
FaceDetection        & 279.033          & 57.832            & 67.8                \\
Handwriting          & 6.705            & 1.836             & 134.4               \\
Heartbeat            & 35.825           & 3.013             & 2.57                \\
InsectWingBeat       & -                & 64.883            & 4565                \\
JapaneseVowels       & 5.032            & 0.527             & 4.71                \\
PEMS-SF              & 369.198          & 150.879           & 341                 \\
SelfRegulationSCP1   & 30.578           & 0.967             & 3.46                \\
SelfRegulationSCP2   & 28.286           & 1.213             & 97.3                \\
SpokenArabicDigits   & 65.143           & 3.129             & 73.2                \\
UWaveGestureLibrary  & 3.078            & 0.636             & 2.90                \\
\hline
\end{tabular}
\caption{Total training time (time until maximum accuracy is recorded) in seconds: for the fastest currently available methods (Rocket, XGBoost) on the same CPU, as well as for our fully supervised transformer models on a GPU. On a CPU, training for our model is typically at least an order of magnitude slower.}
\label{tab:timing}
\end{table}

\begin{figure}[h]
    \centering
    \includegraphics[width=1\linewidth]{Q2_detail.pdf}
    \caption{Root Mean Squared Error of a given model as a function of the number of samples (here, shown as a proportion of the total number of samples in the training set) used for unsupervised pre-training. Two levels of label availability (used for supervised learning) are depicted: 10\% (left panel) and 20\% (right panel) of all training data labels. Note that a horizontal axis value of 0 means fully supervised learning only, while all other values correspond to unsupervised pre-training followed by supervised fine-tuning.}
    \label{fig:Q2_detail}
\end{figure}






\begin{table}
\centering
\begin{adjustbox}{width=1.2\textwidth,center=\textwidth}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} 
\hline
\textbf{Dataset}   & \textbf{TST}                       & \textbf{SVR}         & \begin{tabular}[c]{@{}c@{}}\textbf{Random}\\\textbf{~Forest}\end{tabular} & \textbf{XGBoost}     & \begin{tabular}[c]{@{}c@{}}\textbf{1-NN}\\\textbf{-ED}\end{tabular} & \begin{tabular}[c]{@{}c@{}}\textbf{5-NN}\\\textbf{-ED}\end{tabular} & \begin{tabular}[c]{@{}c@{}}\textbf{1-NN-}\\\textbf{DTWD}\end{tabular} & \begin{tabular}[c]{@{}c@{}}\textbf{5-NN-}\\\textbf{DTWD}\end{tabular} & \textbf{Rocket}      & \textbf{FCN}         & \textbf{ResNet}      & \textbf{Inception}    \\ 
\hline
AppliancesEnergy        & 1                                  & 6                    & 5                                                                         & 7                    & 11                                                                  & 9                                                                   & 12                                                                    & 8                                                                     & 2                    & 3                    & 4                    & 10 \\
BenzeneConcentration    & 1                                  & 7                    & 3                                                                         & 2                    & 12                                                                  & 11                                                                  & 9                                                                     & 8                                                                     & 5                    & 10                   & 6                    & 4           \\
BeijingPM10Quality      & 1                                  & 7                    & 3                                                                         & 2                    & 12                                                                  & 9                                                                   & 11                                                                    & 8                                                                     & 10                   & 4                    & 5                    & 6          \\
BeijingPM25Quality      & 1                                  & 10                   & 6                                                                         & 2                    & 11                                                                  & 9                                                                   & 12                                                                    & 8                                                                     & 5                    & 3                    & 7                    & 4           \\
LiveFuelMoistureContent & 2                                  & 3                    & 5                                                                         & 4                    & 12                                                                  & 7                                                                   & 11                                                                    & 6                                                                     & 1                    & 8                    & 10                   & 9   \\
IEEEPPG                 & 2                                  & 10                   & 5                                                                         & 4                    & 7                                                                   & 3                                                                   & 12                                                                    & 8                                                                     & 11                   & 9                    & 6                    & 1     \\
\hline
\end{tabular}
\end{adjustbox}
\caption{Ranks of all methods on regression datasets based on Root Mean Squared Error.}

\end{table}

\begin{table}
\centering
\begin{adjustbox}{width=1.2\textwidth,center=\textwidth}

\begin{tabular}{|c|c|c|c|c|c|c|c|} 
\hline
Dataset              & TST & Rocket & XGBoost & LSTM & Franseschi et al & DTW\_D   \\ 
\hline
EthanolConcentration & 4   & 1      & 2       & 3    & 6                & 5      \\
FaceDetection        & 1   & 2      & 3       & 4    & 6                & 5  \\
Handwriting          & 3   & 1      & 5       & 6    & 2                & 4     \\
Heartbeat            & 1   & 2      & 4       & 5    & 3                & 6    \\
JapaneseVowels       & 1   & 3      & 5       & 6    & 2                & 4     \\
PEMS-SF              & 2   & 3      & 1       & 6    & 5                & 4     \\
SelfRegulationSCP1   & 1   & 2      & 3       & 6    & 4                & 5     \\
SelfRegulationSCP2   & 1   & 4      & 5       & 6    & 2                & 3    \\
SpokenArabicDigits   & 1   & 4      & 5       & 6    & 3                & 2    \\
UWaveGestureLibrary  & 2   & 1      & 5       & 6    & 4                & 3    \\
\hline
\end{tabular}
\end{adjustbox}
\caption{Ranks of all methods on classification datasets based on Root Mean Squared Error.}
\end{table}


\begin{table}
\centering
\begin{adjustbox}{width=1.2\textwidth,center=\textwidth}

\begin{tabular}{|c|c|c|c|c|c|} 
\hline
\textbf{Dataset}        & \textbf{Task (Metric)} & \textbf{Sep., Bern.} & \textbf{\textbf{Sync., Bern.}}  & \textbf{Sep., Stateful} & \textbf{Sync., Stateful}  \\ 
\hline
Heartbeat               & Classif. (Accuracy)    & 0.761                & 0.756                           & \textbf{0.776}          & 0.751                     \\
InsectWingbeat          & Classif. (Accuracy)    & 0.641                & 0.632                           & \textbf{0.687}          & \textbf{0.689}            \\
SpokenArabicDigits      & Classif. (Accuracy)    & 0.994                & 0.994                           & \textbf{0.998}          & \textbf{0.996}            \\
~PEMS-SF                & Classif. (Accuracy)    & 0.873                  & 0.879                             & \textbf{0.896}                     & 0.879                       \\ 
\hhline{|======|}
BenzeneConcentration    & Regress. (RMSE)        & 0.681                & \textbf{0.493}                  & \textbf{0.494}          & 0.684                     \\
BeijingPM25Quality      & Regress. (RMSE)        & 57.241               & 59.529                          & \textbf{53.492}         & 59.632                    \\
LiveFuelMoistureContent & Regress. (RMSE)        & 44.398               & 43.519                          & \textbf{43.138}         & 43.420                    \\
\hline
\end{tabular}
\end{adjustbox}
\caption{Comparison of four different input value masking schemes evaluated for unsupervised learning on 4 classification and 3 regression datasets. Two of the variants involve separately generating the mask for each variable, and two involve a single distribution over ``time steps'', applied synchronously to all variables. Also, two of the variants involve sampling each ``time step'' independently based on a Bernoulli distribution with parameter , while the remaining two involve using a Markov chain with two states, ``masked'' or ``unmasked'', with different transition probabilities  and , such that the masked sequences follow a geometric distribution with a mean length of  and each variable is masked on average by . We observe that our proposed scheme, separately masking each variable through stateful generation, performs consistently well and shows the overall best performance across all examined datasets.}
\label{tab:masking_schemes}
\end{table}


\begin{table}
\centering
\begin{tabular}{|c|c|c|c|} 
\hline
\textbf{Dataset}        & \textbf{Task (Metric)} & \begin{tabular}[c]{@{}c@{}}\textbf{LayerNorm}\\ \end{tabular} & \textbf{BatchNorm}  \\ 
\hline
Heartbeat               & Classif. (Accuracy)    & 0.741                                                         & \textbf{0.776}      \\
InsectWingbeat          & Classif. (Accuracy)    & 0.658                                                         & \textbf{0.684}      \\
SpokenArabicDigits      & Classif. (Accuracy)    & \textbf{0.993}                                                & \textbf{0.993}      \\
~PEMS-SF                & Classif. (Accuracy)    & 0.832                                                         & \textbf{0.919}      \\ 
\hhline{|====|}
BenzeneConcentration    & Regress. (RMSE)        & 2.053                                                         & \textbf{0.516}      \\
BeijingPM25Quality      & Regress. (RMSE)        & 61.082                                                        & \textbf{60.357}     \\
LiveFuelMoistureContent & Regress. (RMSE)        & 42.993                                                        & \textbf{42.607}     \\
\hline
\end{tabular}
\caption{Performance comparison between using layer normalization and batch normalization in our supervised transformer model. The batch size is 128.}
\label{tab:batchnorm_layernorm}
\end{table}


\begin{table}
\centering
\begin{tabular}{|c|c|cc|cc|} 
\hline
\multirow{2}{*}{ \textbf{Dataset} } & \multirow{2}{*}{ \textbf{Task (Metric)}} & \multicolumn{2}{c|}{\textbf{Static}}                               & \multicolumn{2}{c|}{\textbf{Fine-tuned}}  \\
                                    &                                          & \begin{tabular}[c]{@{}c@{}}Metric\\ \end{tabular} & Epoch time (s) & Metric          & Epoch time (s)          \\ 
\hline
Heartbeat                           & Classif. (Accuracy)                      & 0.756                                             & \textbf{0.082} & \textbf{0.776}  & 0.14                    \\
InsectWingbeat                      & Classif. (Accuracy)                      & 0.236                                                 & \textbf{4.52}  & \textbf{0.687}  & 6.21                    \\
SpokenArabicDigits                  & Classif. (Accuracy)                      & 0.996                                             & \textbf{1.29}  & \textbf{0.998}  & 2.00                    \\
~PEMS-SF                            & Classif. (Accuracy)                      & 0.844                                             & \textbf{0.208} & \textbf{0.896}  & 0.281                   \\ 
\hhline{|======|}
BenzeneConcentration                & Regress. (RMSE)                          & 4.684                                             & \textbf{0.697} & \textbf{0.494}  & 1.101                   \\
BeijingPM25Quality                  & Regress. (RMSE)                          & 65.608                                            & \textbf{1.91}  & \textbf{53.492} & 2.68                    \\
LiveFuelMoistureContent             & Regress. (RMSE)                          & 48.724                                            & \textbf{1.696} & \textbf{43.138} & 3.57                    \\
\hline
\end{tabular}
\caption{Performance comparison between allowing all layers of a pre-trained transformer to be fine-tuned, versus using static (``extracted'') representations of the time series as input to the output layer (which is equivalent to freezing all model layers except for the output layer). The per-epoch training time on a GPU is also shown.}
\label{tab:static_vs_tunable}
\end{table}


\begin{figure}[h]
    \centering
    \includegraphics[width=0.45\linewidth]{Forecasting_mask.pdf}
    \hspace{5mm}
    \includegraphics[width=0.45\linewidth]{synchronous_noise.pdf}
    \caption{Masking schemes within our transformer encoder framework: for implementation of forecasting objective \textit{(left)}, for an alternative unsupervised learning objective involving a single noise distribution over time steps, applied synchronously to all variables \textit{(right)}.}
    \label{fig:forecasting_mask}
\end{figure}


\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\linewidth]{detail_imputation_BenzeneConcentration.pdf}\\
    \hspace*{-1.3in}
    \includegraphics[width=1.4\linewidth]{examples_imputation_BenzeneConcentration.pdf}
    \caption{\textbf{Top:} Imputation of missing values in the test set of BenzeneConcentration dataset. The continuous blue line is the ground truth signal, the light blue circles indicate the values hidden from the model and the orange dots its prediction. We observe that imputed values approximate true values very well, even in cases of rapid transitions and in cases where many contiguous values are missing. \textbf{Bottom:} Same, shown for 5 different dimensions of the time series (here, these are concentrations of different substances) as columns and 4 different, randomly selected samples as rows.}
    \label{fig:imputation}
\end{figure}

\FloatBarrier

\subsection{Advantages of transformers}\label{sec:transformer_advantages}

Transformer models are based on a multi-headed attention mechanism that offers several key advantages and renders them particularly suitable for time series data:

\begin{itemize}
    \item They can concurrently take into account long contexts of input sequence elements and learn to represent each sequence element by selectively attending to those input sequence elements which the model considers most relevant. They do so without position-dependent prior bias; this is to be contrasted with RNN-based models: a) even bi-directional RNNs treat elements in the middle of the input sequence differently from elements close to the two endpoints, and b) despite careful design, even LSTM (Long Short Term Memory) and GRU (Gated Recurrent Unit) networks practically only retain information from a limited number of time steps stored inside their hidden state (vanishing gradient problem~\citep{hochreiter_vanishing_1998, pascanu_difficulty_2013}), and thus the context used for representing each sequence element is inevitably local.
    
    \item Multiple attention heads can consider different representation subspaces, i.e., multiple aspects of relevance between input elements. For example, in the context of a signal with two frequency components,  and  , one attention head can attend to neighboring time points, while another one may attend to points spaced a period  before the currently examined time point, a third to a period  before, etc. This is to be contrasted with attention mechanisms in RNN models, which learn a single global aspect/mode of relevance between sequence elements.
    
    \item After each stage of contextual representation (i.e., transformer encoder layer), attention is redistributed over the sequence elements, taking into account progressively more abstract representations of the input elements as information flows from the input towards the output. By contrast, RNN models with attention use a single distribution of attention weights to extract a representation of the input, and most typically attend over a single layer of representation (hidden states).

\end{itemize}

\subsection{Hyperparameters}

\begin{table}
\centering
\begin{tabular}{|c|c|} 
\hline
\textbf{Parameter}   & \textbf{Value}  \\ 
\hline
activation       & gelu            \\
dropout          & 0.1             \\
learning rate               & 0.001           \\
pos. encoding    & learnable       \\
\hline
\end{tabular}
\caption{Common (fixed) hyperparameters used for all transformer models.}
\label{basic_config}
\end{table}


\begin{table}
\centering
\begin{tabular}{|c|c|} 
\hline
\textbf{Parameter}   & \textbf{Value}  \\ 
\hline
dim. model         & 128             \\
dim. feedforward & 256             \\
num. heads       & 16              \\
num. encoder blocks      & 3               \\
batch size & 128 \\
\hline
\end{tabular}
\caption{Hyperparameter configuration that performs reasonably well for all transformer models.}
\label{good_config}
\end{table}


\begin{table}
\centering
\begin{tabular}{|c|c|c|c|c|} 
\hline
Dataset                 & num. blocks & num. heads & dim. model & dim. feedforward  \\ 
\hline
AppliancesEnergy        & 3           & 8          & 128        & 512               \\
BenzeneConcentration    & 3           & 8          & 128        & 256               \\
BeijingPM10Quality      & 3           & 8          & 64         & 256               \\
BeijingPM25Quality      & 3           & 8          & 64 (128)         & 256               \\
LiveFuelMoistureContent & 3           & 8          & 64         & 256               \\
IEEEPPG                 & 3           & 8          & 512        & 512               \\
\hline
\end{tabular}
\caption{Supervised TST model hyperparameters for the multivariate regression datasets}
\label{tab:hyperparams_supervised_regression_datasets}
\end{table}


\begin{table}
\centering
\begin{tabular}{|c|c|c|c|c|} 
\hline
Dataset                 & num. blocks & num. heads & dim. model & dim. feedforward  \\ 
\hline
AppliancesEnergy        & 3           & 16         & 128        & 512               \\
BenzeneConcentration    & 1           & 8          & 128        & 256               \\
BeijingPM10Quality      & 3           & 8          & 64         & 256               \\
BeijingPM25Quality      & 3           & 8          & 128        & 256               \\
LiveFuelMoistureContent & 3           & 8          & 64         & 256               \\
IEEEPPG                 & 4           & 16         & 512        & 512               \\
\hline
\end{tabular}
\caption{Unsupervised TST model hyperparameters for the multivariate regression datasets}
\label{tab:hyperparams_unsupervised_regression_datasets}
\end{table}


\begin{table}
\centering
\begin{tabular}{|c|c|c|c|c|} 
\hline
Dataset              & num. blocks & num. heads & dim. model & dim. feedforward  \\ 
\hline
EthanolConcentration & 1           & 8          & 64         & 256               \\
FaceDetection        & 3           & 8          & 128        & 256               \\
Handwriting          & 1           & 8          & 128        & 256               \\
Heartbeat            & 1           & 8          & 64         & 256               \\
JapaneseVowels       & 3           & 8          & 128        & 256               \\
PEMS-SF              & 1           & 8          & 128        & 512               \\
SelfRegulationSCP1   & 3           & 8          & 128        & 256               \\
SelfRegulationSCP2   & 3           & 8          & 128        & 256               \\
SpokenArabicDigits   & 3           & 8          & 64         & 256               \\
UWaveGestureLibrary  & 3           & 16         & 256        & 256               \\
\hline
\end{tabular}
\caption{Supervised TST model hyperparameters for the multivariate classification datasets}
\label{tab:hyperparams_supervised_classification_datasets}
\end{table}



\begin{table}
\centering
\begin{tabular}{|c|c|c|c|c|} 
\hline
Dataset              & num. blocks & num. heads & dim. model & dim. feedforward  \\ 
\hline
EthanolConcentration & 1           & 8          & 64         & 256               \\
FaceDetection        & 3           & 8          & 128        & 256               \\
Handwriting          & 3           & 16         & 64         & 256               \\
Heartbeat            & 1           & 8          & 64         & 256               \\
JapaneseVowels       & 3           & 8          & 128        & 256               \\
PEMS-SF              & 1           & 8          & 256        & 512               \\
SelfRegulationSCP1   & 3           & 16         & 256        & 512               \\
SelfRegulationSCP2   & 3           & 8          & 256        & 512               \\
SpokenArabicDigits   & 3           & 8          & 64         & 256               \\
UWaveGestureLibrary  & 3           & 16         & 256        & 512               \\
\hline
\end{tabular}
\caption{Unsupervised TST model hyperparameters for the multivariate classification datasets}
\label{tab:hyperparams_unsupervised_classification_datasets}
\end{table}

\end{document}