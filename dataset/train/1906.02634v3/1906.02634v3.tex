
\documentclass{article} \usepackage{iclr2020_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\usepackage{booktabs}       \usepackage{nicefrac}       

\usepackage{sidecap}
\usepackage{subcaption}
\usepackage{color}
\usepackage{amsmath,amssymb}
\usepackage{floatrow}
\usepackage{bm}
\usepackage{caption}

\floatsetup[table]{capposition=top}

\usepackage{tikz}
\usetikzlibrary{positioning}
\tikzset{>=stealth}



\title{Scaling Autoregressive Video Models}



\author{
   Dirk Weissenborn\thanks{Equal contribution.} \\
   Google Research \\
   \texttt{diwe@google.com} \\
   \And
   Oscar T\"{a}ckstr\"{o}m\thanks{Work done while at Google Research.} \\
   Sana Labs \\
   \texttt{oscar@sanalabs.com} \\
   \And
   Jakob Uszkoreit \\
   Google Research \\
   \texttt{usz@google.com} \\
   }



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}
\maketitle

\begin{abstract}
Due to the statistical complexity of video, the high degree of inherent stochasticity, and the sheer amount of data, generating natural video remains a challenging task. State-of-the-art video generation models often attempt to address these issues by combining sometimes complex, usually video-specific neural network architectures, latent variable models, adversarial training and a range of other methods. Despite their often high complexity, these approaches still fall short of generating high quality video continuations outside of narrow domains and often struggle with fidelity.
In contrast, we show that conceptually simple autoregressive video generation models based on a three-dimensional self-attention mechanism achieve competitive results across multiple metrics on popular benchmark datasets, for which they produce continuations of high fidelity and realism. 
We also present results from training our models on Kinetics, a large scale action recognition dataset comprised of YouTube videos exhibiting phenomena such as camera movement, complex object interactions and diverse human movement. While modeling these phenomena consistently remains elusive, we hope that our results, which include occasional realistic continuations encourage further research on comparatively complex, large scale datasets such as Kinetics.

\end{abstract}

\section{Introduction}Generative modeling of video holds promise for applications such as content creation, forecasting, transfer learning and model-based reinforcement learning \citep{Srivastava2015MovingMNIST,Vondrick2016Anticipating,Oh2015ActionConditionalVP, Kaiser2019ModelBasedRL}.
While recently there has been a lot of progress on generative models for text, audio and images, video generation remains challenging. To some extent this is simply due to the large amount of data that needs to be produced.
Autoregressive models suffer from this particularly in their generation speed. On the other hand, they have a number of desirable attributes, such as their conceptual simplicity and tractable likelihood, which enables straightforward evaluation of their ability to model the entire data distribution.

Moreover, recent results on image generation by \citet{Menick2018GeneratingHF} show that pixel-level autoregressive models are capable of generating images with high fidelity. These findings motivate the question of how far one can push such autoregressive models in the more general task of video generation when scaling recent advances in neural architectures to modern hardware accelerators.

In this work, we introduce a generalization of the Transformer architecture of \citet{Vaswani2017AttentionIA} using three-dimensional, block-local self-attention. In contrast to the block-local attention mechanism of \citet{Parmar2018ImageT}, our formulation can be implemented efficiently on Tensor Processing Units, or TPUs \citep{Jouppi2017TPU}.
To further reduce the memory footprint, we combine this with a three-dimensional generalization of methods from \citet{Menick2018GeneratingHF}, who generate images as sequences of smaller, sub-scaled image slices.

Together, these techniques allow us to efficiently model videos as 3D volumes instead of sequences of still image frames, with direct interactions between representations of pixels across the spatial and temporal dimensions.

We obtain strong results on popular benchmarks (Section \ref{sec:bair}, Appendix \ref{sec:other_benchmarks}) and produce high fidelity video continuations on the BAIR robot pushing dataset \citep{ebert17sna} exhibiting plausible object interactions. Furthermore, our model achieves an almost 50\% reduction in perplexity compared to prior work on autoregressive models on another robot pushing dataset.

Finally, we apply our models to down-sampled videos from the Kinetics-600 dataset \citep{Carreira2018ASN} (Section \ref{sec:kinetics}). While modeling the full range of Kinetics-600 videos still poses a major challenge, we see encouraging video continuations for a more limited subset, namely cooking videos. These feature camera movement, complex object interactions and still cover diverse subjects.


We hope that these initial results will encourage future video generation work to evaluate models on more challenging datasets such as Kinetics.

\section{Related Work}
Our setup is closely related to that of \citet{Kalchbrenner2016VideoPN}, who extend work on pixel-level autoregressive image generation \citep{Oord2016PixelRNN,Oord2016PixelCNN} to videos. However, whereas they model the temporal and spatial dimensions separately with dilated convolutions and convolutional LSTMs, respectively, our model is conceptually simpler in that we do not make any distinction between temporal and spatial dimensions and instead rely almost entirely on multi-head self-attention \citep{Vaswani2017AttentionIA} within the 3D video volume. For comparability, we provide results on Moving MNIST and another robot pushing dataset \citep{Finn2016RobotPushing} on which our model achieves an almost 50\% reduction in perplexity (see Appendix~\ref{sec:other_benchmarks}).

One major drawback of autoregressive models is their notoriously slow generation speed. However, we believe that further research into (partially) parallelizing sampling \citep{Stern2018BlockwisePD} and future hardware accelerators will help alleviate this issue and eventually make autoregressive modeling a viable solution even for extremely high-dimensional data such as videos.

To reduce the generally quadratic space complexity of the self-attention mechanism, we use block-local self-attention, generalizing the image generation approaches of \citet{Parmar2018ImageT} and \citet{Chen2018PixelSNAIL} to 3D volumes. In concurrent work, \citet{Child2019SparseTransformers} instead use sparse attention after linearizing images to a sequence of pixels.

To further reduce memory requirements, we generalize sub-scaling \citep{Menick2018GeneratingHF} to video. An alternative approach is optionally hierarchical multi-scale generation, which has recently been explored for both image generation \citep{reed2017parallel,de2019hierarchical} as well as video generation \citep{Mathieu2016BeoyndMSE}.

Earlier work on video generation mostly focused on deterministic approaches \citep{Srivastava2015MovingMNIST,Vondrick2016Anticipating,xingjian2015convolutional,liu2017video,jia2016dynamic}, which fail to capture the high degree of stochasticity inherent in video.
In response, a popular research direction has been that of generative latent-variable video models. In contrast to pixel-level autoregressive models, these posit an underlying latent process in tandem with the observed pixel values. Work in this category includes variants of variational autoencoders \citep{Babaeizadeh2017SV2P, Denton2018SVGLP}. To address the issues inherent in these models, most notably the tendency to generate blurry outputs possibly due to restricted modeling power, inadequate prior distributions, or optimization of a lower bound in place of the true likelihood, various directions have been explored, including the use of adversarial objectives \citep{Mathieu2016BeoyndMSE,Vondrick2016GeneratingVideos,Lee2018SAVP}, hierarchical latent-variables \citep{Catrejon2019ConditionalVRNN}, or flow-based models \citep{Kumar2019VideoFlowAF}.
All of these approaches admit significantly faster generation. However, in the adversarial case, they tend to only focus on a subset of the modes in the empirical distribution while flow-based models struggle with limited modeling power even when using a large number of layers and parameters. 


A large fraction of earlier work on video generation has encoded specific intuitions about videos, such as explicit modeling of motion \citep{Finn2016VideoPrediction,Denton2018SVGLP} or generation of optical flow \citep{Handa2016SpatioTemporalAE}.
The conceptual simplicity of our model, however, is more in line with recent approaches to video classification that process videos by means of 3D convolutions \citep{Carreira2017QuoVA,Xie2018RethinkingSF} or, similar to this work, spatiotemporal self-attention \citep{Girdhar2018VideoActionTransformer}.

\section{Video Transformer}

\begin{figure}[t]
    \floatbox[{\capbeside\thisfloatsetup{capbesideposition={right,top},capbesidewidth=5cm}}]{figure}[\FBwidth]
    {\caption{\small \textbf{Top}: Illustration of the subscale video transformer architecture and process flow. We incrementally generate  video slices. The video slices and their respective generation order are derived from subscaling. In each iteration, we first process the partially padded video (illustrated for slice index , black means padding and gray means already generated or visible) by an encoder, the output of which is used as conditioning for decoding the current video slice. After generating a slice we replace the respective padding in the video with the generated output and repeat the process for the next slice.
    \textbf{Bottom}: Subscaling in 3D (best viewed in color). The 3D volume is evenly divided by a given subscale factor, here , and the respective slices are extracted. The whole volume is generated by incrementally predicting the individual, much smaller slices, starting at slice  (yellow), followed by  (green),  (red), etc., in raster-scan order.} \label{fig:architecture_subscaling}}
{\resizebox {0.6\textwidth} {!} {\begin{tikzpicture}
        

        \node[inner sep=0pt](architecture) at (0,9) {\includegraphics[scale=1.0,clip]{SubscaleVT.pdf}};
        
        \node[inner sep=0pt] (full_cube)  at (-5,0)
        {\includegraphics[scale=0.5,trim={100 100 90 100},clip]{subscaling.png}};


        
        \node[inner sep=0pt,right=1cm of full_cube] (subscale_000)
        {\includegraphics[scale=0.6,trim={45 55 74 55},clip]{subscale_000.png}};
        \node[align=center, below=1mm of subscale_000] {\large };
    
        


        \node[inner sep=0pt, right=1cm of subscale_000] (subscale_001)
        {\includegraphics[scale=0.6,trim={45 55 74 55},clip]{subscale_001.png}};
        \node[align=center, below=1mm of subscale_001] {\large };
    
        
        \draw[->,thick] (subscale_000.east) -- (subscale_001.west) node[] {};
        
        \node[inner sep=0pt, right=1cm of subscale_001] (subscale_010)
        {\includegraphics[scale=0.6,trim={45 55 74 55},clip]{subscale_010.png}};
        \node[align=center, below=1mm of subscale_010] {\large };
    
        \draw[->,thick] (subscale_001.east) -- (subscale_010.west) node[] {};
        
        \node[inner sep=0pt, right=1cm of subscale_010] (subscale_100)
        {\includegraphics[scale=0.6,trim={45 55 74 55},clip]{subscale_100.png}};
        \node[align=center, below=1mm of subscale_100] {\large };
        
        \draw[->,dotted,thick] (subscale_010.east) -- (subscale_100.west) node[] {};
        
        \node[inner sep=0pt, right=3mm of subscale_100] (subscale_x) {};
        
        \draw[-,dotted,thick] (subscale_100.east) -- (subscale_x.west) node[] {};
        
        
        \node[align=center, above=5mm of subscale_001] {\large \textbf{Subscale Slices}};
        
        
        \node[] (split_start) at (-8, 2.5) {};
        \node[] (split_end) at (8, 2.5) {};
        
        \draw[-,thick] (split_start) edge[gray] (split_end);
        \end{tikzpicture}}}
        
\end{figure}

We generalize the one-dimensional Transformer \citep{Vaswani2017AttentionIA} to explicitly model videos represented as three-dimensional spatiotemporal volumes, without resorting to sequential linearization of the positions in the volume \citep{Child2019SparseTransformers}. This allows for maintaining spatial neighborhoods around positions, which is important as the large number of individual positions to be predicted in a video requires limiting the receptive field of the self-attention mechanism to a neighborhood around every position to avoid the quadratic blow-up in memory consumption of naive fully-connected attention.


We model the distribution  over videos  --- with time, height, width and channel dimensions, respectively --- by means of a pixel-channel level autoregressive factorization.\footnote{In the following, we denote general tensors by boldface lowercase letters and matrices by capital letters.} That is, the joint distribution over pixels is factorized into a product of channel intensities for all  channels, for each of the  pixels, with respect to an ordering  over pixels:

The ordering  is given by a combination of a subscale- and raster-scan ordering, as detailed in \ref{sec:subscaling}.

\subsection{Block-local Self-Attention} \label{sec:selfattn}

The attention mechanism of the original Transformer lets each element in a set of  elements connect to every other element, via the fully-connected weighted adjacency (attention) matrix , with  representing attention weights from element  to element . Because  grows quadratically with the number of elements it becomes prohibitively large for objects such as videos, which typically consist of hundreds of thousands of pixels or more. Therefore, similar in spirit to \citet{Parmar2018ImageT}, we propose to use local self-attention by dividing a video into much smaller non-overlapping sub-volumes, or \emph{3D blocks}. We then apply self-attention separately within each block. This approach is conceptually simple and amenable to highly efficient implementation on TPUs, which enables us to scale our models substantially while maintaining a comparatively high training speed with only a modest sacrifice in expressive power.

The Video Transformer consists of multiple stacked self-attention layers. Each layer divides the overall video volume of shape  into smaller blocks of shape  of length , and performs attention within each block independently. Given a (flattened) block representation  of hidden size  as input, this amounts to:

The input is first projected to query, key and value representations (Eq.~\ref{eq:qkv}).
The attention matrix  is then formed as the scaled dot-product between all query-key pairs adding a relative position bias  \citep{Parikh2016ADA} (Eq.~\ref{eq:attn_matrix}).
The bias  is defined as the sum of per-dimension relative distance biases between element  and , along each of the time- and spatial dimensions.
Finally, the values are aggregated with respect to the attention weights (Eq.~\ref{eq:selfattn}).

Following \citet{Vaswani2017AttentionIA}, we concatenate the output of  parallel attention heads in each layer and project the result by a linear transformation (Eq.~\ref{eq:multihead}) before applying a residual connection. Finally, the output of the multi-head self-attention layer is passed through another dense layer with ReLU activation, followed by a final linear transformation and a residual connection (Eq.~\ref{eq:selfattn_output}):

where overloading notation,  denotes the blockwise application of self-attention to .
Similar to \citet{Baevski2019Adaptive}, we found that applying layer normalization before each block, rather than after each block as proposed by \citet{Vaswani2017AttentionIA}, improves training.

\textbf{Connectivity.}
Operating on 3D sub-volumes (blocks) of videos means that there is no direct information exchange between blocks. However, this can be addressed by varying the block sizes between each layer. To achieve this, we define blocks that stretch over the entire extent of at least a single dimension in each layer.
Following this procedure, we can effectively connect all pixel positions in the encoder, but due to masking some dependencies are missed in the decoder. However, in our experiments these did not produce any visible, systematic artifacts. We discuss missing dependencies and potential remedies in Appendix~\ref{sec:independence}.





\textbf{Efficiency.}
Running block-local self-attention is very efficient in practice as the cost of splitting videos into blocks is negligible. The approach of \citet{Parmar2018ImageT} uses overlapping 2D image blocks in each layer. We found this prohibitive as the required data copying is comparatively expensive. To avoid the need for overlaps to connect pixels across blocks, we simply vary block sizes between layers, which is highly efficient and, as our results show, works well in practice.


\subsection{Spatiotemporal Subscaling}\label{sec:subscaling}

\citet{Menick2018GeneratingHF} recently proposed generating images as a sequence of subscaled image slices. We similarly define a \textit{subscale factor}  which divides a video into  sub-sampled videos (\emph{slices}), each of resolution , as depicted in the bottom part of Figure~\ref{fig:architecture_subscaling}. The slices are generated in order according to their respective offsets, such that we first generate slice , then , up until slice . Generating all slices one at a time in this way drastically reduces the number of pixels in memory to , which enables scaling our architectures by a factor of . Each slice is internally generated according to the raster-scan order. In the following we explain how slices are generated and how they are conditioned on already decoded slices. An overview is illustrated in the upper part of Figure~\ref{fig:architecture_subscaling}.

\textbf{Slice Encoder.}
The current slice  is generated conditioned on the encoded pixels from preceding slices as follows. First, we create a partially masked video, where only the pixels of preceding slices  are visible. The partially masked video is then embedded by concatenating the one-hot encoding of the discretized pixel intensities of each channel. Subsequently, a 3D convolution with kernel size  and stride   (the sub-scaling factor) results in an encoded video of resolution . We apply convolution padding depending on the current slice index . In particular, we pad with , which ``centers'' the convolution kernel on the pixels of the current slice. Finally, we add positional embeddings for each axis, as well as embeddings for the current slice index  , to the output of this strided convolution. The result is an initial encoder representation , where  is the embedding size. We can optionally condition on auxiliary information, such as per-frame action values of a robot arm, by concatenating this information to the initial encoder representation.

This representation is further transformed by a linear projection to hidden size , before being fed as input to a stack of  block-local self-attention layers as described in \S\ref{sec:selfattn}. Each layer is parameterized by a different block size and number of attention heads. The resulting output  is used as conditional input to the subscale slice decoder, which generates the pixels of the current slice . 

\textbf{Slice Decoder.}
The pixel values of the current slice  are predicted conditioned on the encoder representation . The decoder is almost identical to the encoder in structure, except for the use of masking in the decoder as defined by the generation order.
First, we embed  by summing  channel embeddings of size  at every pixel, before applying a 3x3x3 masked convolution \citep{Oord2016PixelCNN} on the embedded pixels, effectively representing each pixel by its already generated, immediate neighbors. Similar to the encoder, we add positional embeddings for the space- and time dimensions to the output of this masked convolution. As in the encoder, this results in an initial decoder representation .

To condition on the encoder state, a linear projection of  is added to  and the resulting representation is fed through a stack of  block-local self-attention layers, with masking, to produce a state  on which the final channel predictions are conditioned.


\subsection{Channel Prediction \& Loss Function.}

The per-pixel channel intensities  (we omit the slice index  in the following) for each channel  are predicted by MLPs with a single hidden layer (Eq.~\ref{eq:prediction}), conditioned on the flattened final decoder state  --- which is itself conditioned on  and hence on prior slices  --- as well as the preceding channels  for each pixel, encoded as one-hot vectors. Finally, the per video slice loss is defined as the negative log-likelihood as in Eq.~\ref{eq:loss}:


We found that splitting the color channel values of the videos into coarse and fine bits helps slightly in terms of performance. Specifically, we split the -bit RGB channels into -bit channels (,  ), such that the coarse bits of all three channels are predicted before the fine bits. Furthermore, splitting channels this way at the input level considerably lowers memory footprint when encoding videos as  vectors on TPUs.


\section{Experiments}
Below, we provide details on the model variants considered, our training setup and the evaluation metrics used. We focus our evaluation on the BAIR Robot Pushing and Kinetics datasets. Additional results on Moving MNIST and another robot pushing dataset are provided in Appendix~\ref{sec:other_benchmarks} for reference.
Sample videos strips of each model and dataset can be found in Appendix~\ref{sec:rollouts} and sample videos at \url{https://bit.ly/2Zb017f}.

\subsection{Models \& Setup}
Unless specified otherwise, we model video slices of 4 frames with a spatial resolution of 32x32.
Both the encoder and decoder consist of 8 layers and have a nearly identical structure, except for the use of masking in the decoder, as described in Section~\ref{sec:subscaling}. We apply block-local self-attention with the following block sizes . Layers 1-4: (4, 8, 4); (4, 4, 8); (1, 32, 4); and (1, 4, 32). Intuitively, layers 1 and 2 are responsible for gathering temporal information whereas layers 3 and 4 gather spatial information of the entire frame. Layer 3 has access to the entire height and layer 4 to the entire width of a frame. The remaining 4 layers have the same block sizes, but in reverse order. However, as discussed in Appendix~\ref{sec:hparams}, this particular choice of block size ordering is not crucial.
There are  attention heads, each with hidden size . Our base models are trained with embedding size  and hidden size of  (46M parameters). Based on ablations in Appendix~\ref{sec:hparams}, we observed that increasing the hidden dimension is preferable to using deeper networks. Hence, we increase the hidden size to  and use  instead of  heads for the last  encoder/decoder layers in our large models (373M parameters).

\textbf{Models.} To assess the effect of subscaling, we explore the following variants. These differ mainly in the subscaling factor  as well as the context kernel size , defaulting to :

\textit{\textbf{Spatiotemporal Subscaling.}}
The subscale video transformer with full spatiotemporal subscaling applies subscaling in every dimension. For instance, a 16x64x64 video is subscaled by factors  to 16 slices of 4x32x32.

\textit{\textbf{Spatial Subscaling.}
}This model uses no temporal subscaling and only subscales individual frames to a resolution of 32x32. For instance, a 4x64x64 video is subscaled by factors  to 4 slices of 4x32x32.

\textit{\textbf{Single Frame.}}
This model uses no subscaling. Instead, we here model an entire single frame at a time, conditioned only on the previous three frames to limit memory consumption. The model uses no actual subscaling. Instead, one can imagine a 16x64x64 video to be subscaled by factors  to 16 slices of 1x64x64 frames. The context kernel size is  which means that we merely condition on a context of 3 past frames, as the current and future frames are always masked when the temporal subscaling factor equals the full video length.
Self-attention blocks are adapted as follows: Layers 1-4: (1, 8, 16); (1, 16, 8); (1, 2, 64); (1, 64, 2). For the remaining 4 layers we use the same blocks, again in reverse order.

\textbf{Training.}
All models are trained with RMSProp \citep{tieleman2012lecture} with a fixed learning rate of , decay of  and momentum of . We use a batch size of 64 video slices, if not stated otherwise, and shuffle the slices to avoid having all slices in a batch correspond to the same video. The smaller models are trained for 300K steps and the larger ones for 1M steps. No explicit regularization is applied as we could not observe any form of over-fitting. Videos longer than the training resolution are cropped randomly in time to the defined training length. If not stated otherwise, models are conditioned on the first frame during training, which is achieved by masking the loss corresponding to this frame. In preliminary experiments, this gave a minor improvement over computing the training loss across all frames.

\textbf{Intrinsic Evaluation.}
Most results are reported as bits per dimension (bits/dim), the average negative -probability assigned by the model per (RGB) channel, averaged across all pixels in the video. This corresponds directly to the loss optimized by the model. In all experiments, we condition (prime) on a specified number of initial frames. The log-probabilities corresponding to these frames are excluded from this average.

\textbf{Extrinsic Evaluation.}
Prior work mainly reported results on the peak signal-to-noise ratio (PSNR) and mean-structural similarity (SSIM) metrics \citep{Wang2004ImageQuality}.
However, these metrics were developed for images and have serious flaws when applied to videos \citep{Wang2004VideoSSIM, Wang2007VideoHuman, Zhang2018Unreasonable, Lee2018SAVP}. Conceptually, PSNR has a strong preference for blurry videos as it is based on pixel-level mean squared error. Similarly, SSIM does not correlate well with perceptual quality either. For instance, variational autoencoders show very strong performance on this metric despite producing blurry videos \citep{Lee2018SAVP}. Hence, we focus on the Fr\'{e}chet Video Distance (FVD), which was recently proposed by \citet{Unterthiner2018FVD} as a qualitative metric sensitive to visual quality, temporal coherence and diversity of samples. This is the spatiotemporal counterpart to the Fr\'{e}chet Inception Distance \citep{Heusel2017FID}, replacing the ImageNet-trained Inception network of the latter with an I3D Network trained on Kinetics. Despite sharing the known drawbacks of FID \citep{Binkowski2018}, FVD has shown to correlate much stronger with human raters compared to both PSNR and SSIM \citep{Unterthiner2018FVD}. We report the FVD of the first 16 frames, as well as the ``unrolled'' average FVD across all contiguous subsequences of 16 frames. In each case, we report the mean and standard deviation of 20 trials.

\textbf{Sampling time.} Sampling from autoregressive models is notoriously slow. However, because our decoders are not very deep (8 layers) we are able to sample a batch of four 30x64x64 videos in acceptable time (approx. 8 minutes) with our large models on a Nvidia Tesla V100. Though this might still be impractical we argue that further advances in parallel sampling strategies \citep{Stern2018BlockwisePD} and future hardware will alleviate this disadvantage significantly.


\begin{table}
    \label{tab:results}
    \scriptsize
    \centering
    \caption{Quantitative results on BAIR Robot Pushing (left) and Kinetics (right).}
    \begin{subtable}[t]{0.48\textwidth}
        \centering
        \begin{tabular}{lccc}
\toprule
            \textbf{Models} & Bits/dim & FVD & FVD (Avg) \\
            \midrule
            Single Frame & 1.49 & 1044 & \phantom{1}992 \\
            Spatial Sub. & 1.57 & 1114 & 1081\\
            Spatiotemp. Sub. & 1.53 & 1063 & 1062\\
\midrule  
            Spatiotemp. Sub. (L) & \bf{1.35} & \bf{\phantom{1}942} & \bf{\phantom{1}962} \\
            \midrule
SV2P [1] & -- & 263 & -- \\
            SAVP [2] & -- & 116 & -- \\ VideoFlow [3] & 1.87 & -- & -- \\
            \bottomrule
        \end{tabular}
        \subcaption{\scriptsize \textbf{BAIR Robot Pushing.} Bits/dim averaged across 15 subsequent frames when priming with 1 initial frame, FVD and unrolled average FVD scores. Best results in bold. ~Results from \citet{Unterthiner2018FVD}. ~Results are not strictly comparable (see text for details). [1] \citet{Babaeizadeh2017SV2P}, [2] \citet{Lee2018SAVP}, [3] \citet{Kumar2019VideoFlowAF}.}
        \label{tab:robotic_pushing}
    \end{subtable}
    \hspace{\fill}
    \begin{subtable}[t]{0.48\textwidth}
        \centering
        \begin{tabular}{l c c c}
\toprule
            \textbf{Models} & Bits/dim & FVD & FVD (Avg) \\
            \midrule
            Single Frame & 1.40 & 2436 & 41311 \\ 
            Spatial Sub. & 1.47 & 2636 & 45015 \\
            Spatiotemp. Sub. & 1.49 & 1957 & 37511 \\
            \midrule
Single frame (L) & \bf{1.14} & 2078 & 35313 \\
            Spatiotemp. Sub. (L) & 1.19 & \bf{1705} & \bf{31612} \\
            \bottomrule
        \end{tabular}
        \subcaption{\scriptsize \textbf{Kinetics.} Bits/dim averaged across 15 subsequent frames when priming with 1 initial frame, FVD and unrolled average FVD scores when priming with 5 frames. Best results in bold.}
        \label{tab:kinetics}
    \end{subtable}
\end{table}


\subsection{BAIR Robot Pushing}\label{sec:bair}

BAIR Robot Pushing \citep{ebert17sna} shows a robotic arm pushing and grasping objects in a box. It consists of roughly 40K training- and 256 test videos. We prime on the first frame for training and evaluation.

\textbf{Empirical Results.}
All variants of the Video Transformer achieve strong results compared to prior work in terms of both intrinsic and extrinsic metrics.
From Table~\ref{tab:robotic_pushing}, we see that the small models already reduce the perplexity in terms of bits/dim by almost 20\% compared to the recently proposed VideoFlow model \citep{Kumar2019VideoFlowAF} with our large model (L) reducing perplexity even further to a 25\% improvement. Similar to \citet{Menick2018GeneratingHF}, we find that subscaling can have a slightly negative effect on bits/dim. In terms of perceptual quality, every incarnation of our model obtains a lower (better) FVD score compared to all models evaluated by \citet{Unterthiner2018FVD}, which notably includes adversarial networks with no guarantees of covering the full empirical distribution.
These results are not strictly comparable, since prior work has used longer priming sequences of two \citep{Babaeizadeh2017SV2P,Lee2018SAVP} or three \citep{Kumar2019VideoFlowAF} frames, whereas our models (to our disadvantage) see a single prime frame. Note that we sample with temperature 0.9 for the extrinsic metrics as we observed improved qualitative results at this temperature on the validation set. This corresponds to a mild form of mode dropping and is common practice to improve sampling quality. For fair comparison we also tweaked the ``temperature'' of SAVP by scaling the variance of its normal distribution when sampling. This, however, did not result in any improvements for FVD. 

Further results on an earlier version of robot pushing \citep{Finn2016RobotPushing} and Moving MNIST \citep{Srivastava2015MovingMNIST} can be found in Appendix~\ref{sec:other_benchmarks} for brevity. In summary, like \citet{Kalchbrenner2016VideoPN}, we match the lower bound on Moving MNIST while obtaining an \emph{almost 50\% reduction in bits/dim on robotic pushing} which demonstrates the superiority of our models against prior work on autoregressive video modeling.

\begin{figure}[t]
    \centering
    \captionsetup{font=small}
    \begin{subfigure}{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth,keepaspectratio]{plots/bair-fvd-stretched.pdf}
    \vspace{-1em}
    \subcaption{}
    \label{fig:bair_fvd}
    \end{subfigure}
\quad
    \begin{subfigure}{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth,keepaspectratio]{plots/kinetics-fvd-stretched.pdf}
    \vspace{-1em}
    \subcaption{}
    \label{fig:kinetics_fvd}
    \end{subfigure}
\caption{Unrolled FVD metrics on BAIR Robot Pushing (left) and Kinetics (right).}
\end{figure}

\textbf{Qualitative Observations.}
All variants of our model reach similar quantitative results on these benchmarks and we observe no immediate differences in fidelity. However, there are some notable differences. First, whereas the spatiotemporal subscaling model is able to capture temporal dependencies across up to 16 frames (given subscaling in time by a factor four), the remaining models can only capture dependencies across four frames. This can, for example, result in deformation of occluded objects (e.g., Figure~\ref{fig:occlusion} of the Appendix). However, due to the simplicity of the benchmark datasets, this is not appropriately reflected in the metrics including better unrolled FVD curves for the single frame base model in Figure~\ref{fig:bair_fvd}.
Second, we observe that lowering the sampling temperature from 1.0 to 0.9 consistently improves results. Notably, spatiotemporal subscaling seems more robust to sampling errors as its performance decays less when sampling with temperature 1.0 (1224 Avg. FVD) compared to the spatial subscaling (1344) and single frame models (1537). We attribute this finding to the difference in generation order when spatiotemporal subscaling is employed as it predicts pixels over the entire extend of the 3D video volume early and thereby effectively anchors future predictions around these pixels.
Finally, considering that our results on BAIR Robot Pushing in terms of FVD are on par with those between two ground-truth subsamples (Figure 4 of \citet{Unterthiner2018FVD}), we may be approaching the limit of this benchmark. On the other hand, it could be that FVD suffers out-of-domain and is not sufficiently sensitive to long-range temporal dynamics, since it is trained to perform human action recognition, which is known to predominantly rely on local features \citep{Carreira2017QuoVA,Xie2018RethinkingSF}.

\subsection{Kinetics}\label{sec:kinetics}


Moving from a constrained to a real world setting, we next apply our models to the Kinetics dataset \citep{Kay2017TheKH}, a large scale action-recognition dataset consisting of YouTube videos. Specifically, we use Kinetics-600, which contains roughly 400K training videos ranging over 600 action classes \citep{Carreira2018ASN}. We center-crop and down-sample each frame to 64x64 with a width-3 Lanczos filter and anti-aliasing.

We introduce a slight change to our setup by using a separate decoder for the first slice . This decoder can be twice as deep (16 instead of 8 layers) as the original subscale decoder, because it does not rely on any encoder. For all other slices we train a regular subscale model (8 layers in both encoder and decoder) as before. Using a separate first-slice decoder means that there is no wasted encoder computation on the first slice and that there are additional parameters.
Furthermore, for our large models we scale the batch size to 256 by training in parallel on 128 TPU v3 instances for 1M steps.

\textbf{Empirical Results.}
Results for our base models are shown in the upper part of Table~\ref{tab:kinetics}.
In line with results on BAIR pushing, we find that the single frame model obtains better performance in terms of bits/dim. In contrast, we observe that the spatiotemporal subscaling model generates better and more robust video continuations which is reflected by its superior FVD scores.
Our large models (L) show much stronger performance across the board (see lower half of Table~\ref{tab:kinetics} and Figures~\ref{fig:kinetics_fvd}), lowering the perplexity to 1.14 bits/dim for the single frame model. While the spatiotemporal subscaling model obtains slightly worse perplexity of 1.19 bits/dim, it improves FVD to 170. Despite its good performance on bits/dim, even with a temperature of 0.9, samples from the large single frame model are prone to instability and in many cases we observe color ``explosions'' (Figure~\ref{fig:rollout_fingers_nextframe} in the Appendix shows an example) which is reflected in its significantly higher FVD score. Although much less pronounced we observed such instability already when sampling with temperature 1.0 on BAIR pushing which clearly indicates the benefits of temporal subscaling for video generation.

\textbf{Qualitative Observations.} Figure~\ref{fig:qualitative} shows samples from a cooking subset of Kinetics that we describe in Appendix~\ref{sec:kinetics_cooking}. These are selected to showcase different aspects of real-world videos learned by the large spatiotemporal subscaling model. Figures~\ref{fig:zoom} and \ref{fig:camera} demonstrate the model's ability to handle camera movement. We find that camera movement seems to be learned early in training, possibly since it is a major source of uncertainty. This requires transforming pixels correctly while hallucinating new pixels at the edges. Similarly, object movement resulting, for instance, in a change of perspective is predicted quite well (Figure~\ref{fig:perspective}). Highly stochastic motion such as fire (Figure~\ref{fig:fire}) or steam is modeled surprisingly well.
Videos in Kinetics sometimes contain scene changes and our model, too, occasionally generates videos with jumps to completely new scenes (Figure~\ref{fig:scene_change}).
Motion of human fingers and faces seems challenging to model. Nevertheless, in a number of samples the model is able to generate somewhat believable continuations as can be seen in Figures~\ref{fig:finger}, \ref{fig:mouth1} or \ref{fig:yawning}.

These selected examples show only a small subset of the interesting phenomena handled by the model and illustrate the sheer complexity involved in modeling this dataset. In Appendix~\ref{sec:rollouts}, we provide multiple samples, primed with the same initial frames to illustrate the diversity of the generated samples.

\begin{figure}[t]
    \captionsetup{font=small}
    \begin{subfigure}{0.31\textwidth}
    \includegraphics[width=\textwidth]{kinetics_examples/zoom_frames_0-5-10-15.jpg}\vspace{-0.5em}
    \caption{Zoom} \label{fig:zoom}
    \end{subfigure}
    ~
    \begin{subfigure}{0.31\textwidth}
    \includegraphics[width=\textwidth]{kinetics_examples/perspective_frames_0-5-10-15.jpg}\vspace{-0.5em}
    \caption{Perspective} \label{fig:perspective}
    \end{subfigure}
    ~
    \begin{subfigure}{0.31\textwidth}
    \includegraphics[width=\textwidth]{kinetics_examples/camera_frames_0-5-10-15.jpg}\vspace{-0.5em}
    \caption{Camera movement} \label{fig:camera}
    \end{subfigure}
    \vspace{0.2em}
    
    \begin{subfigure}{0.31\textwidth}
    \includegraphics[width=\textwidth]{kinetics_examples/fire_0-5-10-15.jpg}\vspace{-0.5em}
    \caption{Fire} \label{fig:fire}
    \end{subfigure}
    ~
    \begin{subfigure}{0.31\textwidth}
    \includegraphics[width=\textwidth]{kinetics_examples/scene_change_0-5-10-15.jpg}\vspace{-0.5em}
    \caption{Scene change} \label{fig:scene_change}
    \end{subfigure}
    ~
    \begin{subfigure}{0.31\textwidth}
    \includegraphics[width=\textwidth]{kinetics_examples/object_interaction_0-5-10-15.jpg}\vspace{-0.5em}
    \caption{Object interaction} \label{fig:}
    \end{subfigure}
    \vspace{0.2em}
    
    \begin{subfigure}{0.31\textwidth}
    \includegraphics[width=\textwidth]{kinetics_examples/finger_frames_0-5-10-15.jpg}\vspace{-0.5em}
    \caption{Fingers} \label{fig:finger}
    \end{subfigure}
    ~
    \begin{subfigure}{0.31\textwidth}
    \includegraphics[width=\textwidth]{kinetics_examples/mouth1_frames_0-5-10-15.jpg}\vspace{-0.5em}
    \caption{Mouth closing} \label{fig:mouth1}
    \end{subfigure}
    ~
    \begin{subfigure}{0.31\textwidth}
    \includegraphics[width=\textwidth]{kinetics_examples/mouth2_frames_0-5-10-15.jpg}\vspace{-0.5em}
    \caption{Yawning} \label{fig:yawning}
    \end{subfigure}
    \caption{\small Selected Kinetics continuations from a set of 128 videos and 16 samples which showcase a variety of natural, video-specific phenomena our model learns to generate. We used our large spatiotemporal subscaling model and prime generation with 5 frames (0-4) to include the first two frames in subscale order (0, 4). Samples are generated with temperature of 0.9. The examples depict frames 0, 5, 10 and 15.}\label{fig:qualitative}
\end{figure}

\textbf{Limitations.} While we obtained the occasional encouraging sampl, we would like to point out that the diversity of Kinetics still poses a major challenge. Failure modes range from freezing movement or object distortions to continuations that "wash out" entirely after a few frames. We firmly beleive that yet larger datasets and/or models will be required to capture the complexity of even short clips from YouTube videos. With this work we merely provide an initial baseline, hoping to highlight both the potential and the enormous room for improvement.

\section{Conclusion}
We presented an autoregressive model of videos based almost entirely on a variant of block-local self-attention that can easily be implemented efficiently on TPUs. Combined with spatiotemporal subscaling, our models can be scaled up substantially while retaining the ability to capture longer range spatiotemporal dependencies.

Empirically, we obtain state-of-the-art results across a range of video generation benchmarks, while the scalability of our approach enables us to make an initial attempt at modeling videos of unusually high complexity and diversity as found in the Kinetics dataset. Our models occasionally generate encouraging continuations, especially on a subset of cooking videos, yet we find modeling the full range of such videos clearly remains a major challenge.

\section*{Acknowledgements}
This work benefited from numerous conversations with Nal Kalchbrenner, as well as discussions
with Jacob Menick, Mohammad Taghi Saffar and Niki Parmar. We would also like to thank Chelsea
Finn and Tom Kwiatkowski for thoughtful comments on an earlier draft.

\bibliographystyle{iclr2020_conference}
\bibliography{iclr2020_conference}


\clearpage


\appendix

\begin{figure}[t]
  \centering
  \includegraphics[width=\textwidth]{occlusion.pdf}
  \caption{Samples (showing every 5th frame horizontally) illustrating occlusion effects on BAIR Robot Pushing. Models without temporal subscaling (rows 3-4) fail on occlusions, whereas the model with temporal subscaling (row 2) correctly maintains objects from the ground truth video (row 1). Notice the green ball deformation on rows 2 and 3 and the hallucinated green ball on the right edge of row 3, which are caused by missing temporal dependencies across the duration of occlusion.}
  \label{fig:occlusion}
\end{figure}

\section{Further benchmarks}\label{sec:other_benchmarks}

\begin{table}[t]
    \centering
    \caption{\textbf{Moving MNIST.} Nats per frame averaged across 10 subsequent frames when priming with 10 initial frames. Best results in bold. ~The lower bound reported in \citep{Kalchbrenner2016VideoPN} is slightly higher than ours.}\label{tab:mnist}
    \begin{tabular}{l c}
        \toprule
\textbf{Models} & Nats/Frame () \\ \midrule
        Single Frame & \textbf{86.2} \\
        Spatial Subscaling & 91.8 \\
        Spatiotemporal Subscaling & 90.0 \\
        \midrule
        VPN \citep{Kalchbrenner2016VideoPN} & 87.6 \\
        Lower bound  & 85.1 (86.3) \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{Moving MNIST}

Moving MNIST \citep{Srivastava2015MovingMNIST} consists of 100K training- and 10K validation/test videos of two handwritten digits from the MNIST benchmark that move deterministically across the frame, crossing each other and bouncing off the borders.
The partial occlusion of crossing digits makes this dataset challenging.
To be comparable with \citet{Kalchbrenner2016VideoPN}, we use the first ten frames as priming and predict the subsequent ten frames.

To allow direct comparison with \citet{Kalchbrenner2016VideoPN}, we change our loss to a ``deterministic'' loss (and derived nats-per-frame metric) which is defined as: , where  are the gray-scale targets between 0.0 and 1.0, and  are the predicted scalar intensities.

From Table~\ref{tab:mnist}, we find that like \citet{Kalchbrenner2016VideoPN} our single frame prediction model (i.e., no subscaling) virtually solves the task in the sense that it almost matches the lower bound of the loss. However, this is not true for our subscaling models. Employing spatial subscaling on this task gives aliasing artifacts that make it harder to predict future frames. Although this finding is limited to Moving MNIST, it suggests that spatial subscaling can potentially hurt generation.

\subsection{Robotic Pushing.}


Robotic Pushing \citep{Finn2016RobotPushing} was used in prior work on autoregressive video generation \citep{Kalchbrenner2016VideoPN}. The videos show a robotic arm pushing and grasping objects in a box and there are roughly 50K training videos and 1500 test videos with seen and novel objects, respectively.
Following prior work, we use the initial two frames for priming and condition on the robot arm action for each frame as described in Section~\ref{sec:subscaling}. We use the same setup as \citep{Kalchbrenner2016VideoPN} with videos of twenty frames down-sampled to 64x64 with a Lanczos filter and anti-aliasing.

We report results to compare with prior work on autoregressive video generation by \citet{Kalchbrenner2016VideoPN}, who achieve 0.92 bits/dim (0.64 nats/dim) with 2 frames of priming on each of the test splits (one with objects seen during training and one with novel objects). We trained a large (2048 dimensional) spatiotemporal subscaling model which achieves 0.51 bits/dim on the subset with seen objects and 0.47 bits/dim on the subset with new objects, which corresponds to an \textbf{almost 50\% reduction in perplexity}.

\section{Hyper-Parameter Sweeps} \label{sec:hparams}

\begin{table}[t]
    \centering


    \caption{Ablation of hyper-parameter settings in terms of bits per dimension for models on 256 BAIR Robot Pushing validation videos. All models were primed on 1 frame and trained for 300K steps with a batch size of 64.}
    \begin{tabular}{rc@{\extracolsep{1cm}}r@{\extracolsep{0cm}}c@{\extracolsep{1cm}}r@{\extracolsep{0cm}}c}
    \toprule
        \multicolumn{2}{l}{\textbf{Layers}} & \multicolumn{2}{l}{\textbf{Heads}} & \multicolumn{2}{l}{\textbf{Hidden size}} \\
        \midrule
        
        4 & 1.63 &
        4 & 1.59 &
        256 & 1.65 \\
        
        8 & 1.55 &
        8 & 1.55 &
        512 & 1.55 \\
        
        16 & 1.48 &
        16 & 1.51 &
        1024 & 1.47 \\
        
        24 & 1.45 &
        24 & 1.47 &
        2048 & \textbf{1.40} \\
        \bottomrule
    \end{tabular}

    \label{tab:model_ablation}
\end{table}

Table~\ref{tab:model_ablation} shows the impact of different architectural settings. We see that the hidden size has the biggest impact followed by the number of layers and heads. This is an interesting as well as important finding because increasing the hidden size (wider networks) requires more parallel compute which modern Deep Learning hardware excels at. Computation time grows sub-linear, memory linear and parameters partially quadratically. In contrast all of these aspects grow linearly with deep networks. For scaling up architectures depth is therefore not the preferred option as we suffer much more in terms of computation time while having less parameters. 

In another experiment, we shuffle the arrangement of block sizes between layers and found that it did not really matter, that is, all results were within 0.01 bits/dim. However, our setup had the best overall performance.

Finally, we tried sampling temperature 0.9 and 1.0 only on the BAIR Robot Pushing validation set and found that temperature 0.9 consistently gave more robust predictions and better results on all extrinsic metrics.

\section{Connectivity in Block-local Self-Attention}\label{sec:independence}

\paragraph{Blind Spots.}
Varying block sizes between layers in block-local self-attention can efficiently connect every pixel with every other pixel when no masking is employed. If masking is employed to respect the generation order (as in our slice decoder) block-local self attention produces ``blind spots'' which leads to independence assumptions. To exemplify these special cases, consider position , the top-left pixel of the second frame, and its direct predecessor in generation order , the bottom-right pixel of the first frame. The only way to establish a connection between these two positions is through a direct connection, because masking prevents any indirect connection. Thus, there has to be one layer in which both of these pixels are in the same block. This block must at least stretch over the entire extent of both width and height (i.e., the full frame) as well as at least 2 time steps. Running full self-attention in such blocks can easily become prohibitive for large  and .

\paragraph{Remedies.}
There seems to be no simple solution that solves the problem of blind spots completely. However, we can make sure that local dependencies up to a certain distance are all covered by increasing the kernel size of the initial, masked convolution in the decoder. It is also possible to combine block-local self-attention with its dual form, dilated self-attention in  dimensions which connects all pixels at the same relative position within their respective block with each other. Finally, we find that it is important to avoid blocks of small sizes in any dimension (e.g., 1). That means, even if we stretch a block to the full extent of one dimension it is important to define sizes at least larger than 1 on all other dimensions to limit the number of unconnected pixels.

On the other hand, the independence assumptions due to masking do not seem to produce any systematic, visible artifacts in our samples. We believe this to be an interesting finding by itself as it shows that there is potential for parallelizing autoregressive video generation by systematically exploring further independence assumptions.

\section{Additional Findings} \label{sec:laundry-list}

Below, we summarize some additional findings that may be of interest to some readers:

\begin{itemize}
    \item We found that using blocks stretching across a single time-/row-/column- dimension, is substantially worse than using blocks that stretch at least to some extent in all directions. This is likely due to the fact that future masking in the decoder imposes strong independence assumptions in this case, as discussed in Appendix~\ref{sec:independence}.
    \item We found that RMSProp with momentum converges significantly faster than ADAM, which we tried with different learning rates and settings for  and .
    \item We tried using continuous, rather than discretized one-hot, input channel representations, but this had an overall negative impact on both performance and sample quality.
    \item We experimented with a gating mechanism in Eq.~\ref{eq:attn_matrix}, such that the attention matrix  is masked elementwise with  to allow for not attending to any element, similar to sentinel attention \citep{Lu2017KnowingWT}. However, this had no effect on generation quality.
\end{itemize}

\section{Kinetics Cooking}\label{sec:kinetics_cooking}
We found that for many video-prefixes in Kinetics it is very hard for our model to predict continuations. For instance, main objects in the videos are too small or movement is too fast which results in very blurry frames or there is little to no movement at all. Figure~\ref{fig:kinetics_prefixes} shows some examples.
Therefore, we created a subset of cooking videos that we found to exhibit these problems to a lesser degree.

In particular we filtered videos whose label matched the following regular expression:

\begin{verbatim}
.*(baking|barbequing|breading|cooking|cutting|pancake|vegetables|
   meat|cake|sandwich|pizza|sushi|tea|peeling|fruit|eggs|salad).*
\end{verbatim}

Note that we still train on the full Kinetics training set and only use the cooking set to showcase samples in some cases.


\section{Samples}\label{sec:rollouts}

Figures~\ref{fig:bair-rollout-small}-\ref{fig:bair-diversity-large} show samples from our spatiotemporal subscaling and large spatiotemporal subscaling models on BAIR Robot Pushing. Figures \ref{fig:bair-rollout-small} and \ref{fig:bair-rollout-large} illustrate the fidelity and realism of the generated samples, whereas Figures \ref{fig:bair-diversity-small} and \ref{fig:bair-diversity-large} illustrate the diversity of samples.

Figures~\ref{fig:rollout_hands}-\ref{fig:rollout_eggs} show samples from our spatiotemporal subscaling model on cooking videos for Kinetics-600, while Figure ~\ref{fig:rollout_fingers_nextframe} depicts samples from the single frame model. In each case, we prime on 5 frames and sample the next 11 frames. Each figure shows 16 different samples from the same model. As can be seen, the model is able to generate diverse continuations while retaining fidelity. For the single frame model we observe strange color artifacts (exploding colors) which we attribute to the standard, raster-scan generation order of this model.



\begin{figure}[p]
    \centering
    \includegraphics[width=\textwidth]{bair_examples/bair-small-rollout.jpg}
    \caption{Samples of 30 future frames (showing every 4th frame) for 12 test videos with the spatiotemporal subscaling model, using 1 prime frame and temperature 0.9 on BAIR Robot Pushing.}
    \label{fig:bair-rollout-small}
\end{figure}

\begin{figure}[p]
    \centering
    \includegraphics[width=\textwidth]{bair_examples/bair-large-rollout.jpg}
    \caption{Samples of 30 future frames (showing every 4th frame) for 12 test videos with the large spatiotemporal subscaling model, using 1 prime frame and temperature 0.9 on BAIR Robot Pushing.}
    \label{fig:bair-rollout-large}
\end{figure}

\begin{figure}[p]
    \centering
    \includegraphics[width=\textwidth]{bair_examples/bair-small-diversity.jpg}
    \caption{11 samples of 30 future frames (showing every 4th frame) for 1 test video (top row) with the spatiotemporal subscaling model, using 1 prime frame and temperature 0.9 on BAIR Robot Pushing.}
    \label{fig:bair-diversity-small}
\end{figure}

\begin{figure}[p]
    \centering
    \includegraphics[width=\textwidth]{bair_examples/bair-large-diversity.jpg}
    \caption{11 samples of 30 future frames (showing every 4th frame) for 1 test video (top row) with the large spatiotemporal subscaling model, using 1 prime frame and temperature 0.9 on BAIR Robot Pushing.}
    \label{fig:bair-diversity-large}
\end{figure}

\begin{figure}[p]
    \centering
    \includegraphics[width=\textwidth]{kinetics_examples/rollout_hands.jpg}
    \caption{Samples of 11 future frames from the spatiotemporal subscaling model with 5 prime frames on 64x64 Kinetics.}
    \label{fig:rollout_hands}
\end{figure}

\begin{figure}[p]
    \centering
    \includegraphics[width=\textwidth]{kinetics_examples/rollout_fire.jpg}
    \caption{Samples of 11 future frames from the spatiotemporal subscaling model with 5 prime frames on 64x64 Kinetics.}
    \label{fig:rollout_fire}
\end{figure}


\begin{figure}[p]
    \centering
    \includegraphics[width=\textwidth]{kinetics_examples/rollout_eggs.jpg}
    \caption{Samples of 11 future frames from the spatiotemporal subscaling model with 5 prime frames on 64x64 Kinetics.}
    \label{fig:rollout_eggs}
\end{figure}

\begin{figure}[p]
    \centering
    \includegraphics[width=\textwidth]{kinetics_examples/fingers_rollout_nextframe.jpg}
    \caption{Samples of 11 future frames from the single frame model with 5 prime frames on 64x64 Kinetics exhibiting strange color artifacts.}
    \label{fig:rollout_fingers_nextframe}
\end{figure}


\begin{figure}[p]
    \centering
    \begin{subfigure}{0.48\textwidth}
    \includegraphics[width=\textwidth]{kinetics_examples_bad/kinetics_6.jpg}
    \caption{Blurry and fast camera movement.}
    \end{subfigure}\quad
    \begin{subfigure}{0.48\textwidth}
    \includegraphics[width=\textwidth]{kinetics_examples_bad/kinetics17.jpg}
    \caption{Blurry and fast camera movement.}
    \end{subfigure}
    \begin{subfigure}{0.48\textwidth}
    \includegraphics[width=\textwidth]{kinetics_examples_bad/kinetics_baseball.jpg}
    \caption{Very little movement.}
    \end{subfigure}\quad
    \begin{subfigure}{0.48\textwidth}
    \includegraphics[width=\textwidth]{kinetics_examples_bad/kinetics_football.jpg}
    \caption{Very little movement and small objects.}
    \end{subfigure}
    \caption{Ground-truth (top) and 2 samples of 30 future frames (showing every 4th frame) demonstrating that random Kinetics videos do not always lend themselves as good prefixes for generating continuations.}
    \label{fig:kinetics_prefixes}
\end{figure}

\end{document}
