
\documentclass[table]{article} \usepackage{iclr2021_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{scrextend}
\usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{color, colortbl}
\usepackage{multirow, multicol}
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{decorations.pathreplacing}
\usepackage{bbding}
\usepackage{pifont}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{wrapfig}
\usepackage{picins}
\usepackage[font=footnotesize]{caption}
\usepackage{xparse}
\usepackage{tabularx}
\renewcommand\tabularxcolumn[1]{m{#1}}\usepackage{lscape} 
\usepackage{hhline}




 

\newcolumntype{Y}{>{\centering\arraybackslash}X}


\definecolor{persian}{HTML}{00A572}
\def\checkmark{\tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (1,.7) -- (.25,.15) -- cycle;} 
\newcommand{\xmark}{\small \color{red}\ding{55}}\definecolor{Gray}{gray}{0.9}

\newlength{\Oldarrayrulewidth}
\newcommand{\Cline}[2]{\noalign{\global\setlength{\Oldarrayrulewidth}{\arrayrulewidth}}\noalign{\global\setlength{\arrayrulewidth}{#1}}\cline{#2}\noalign{\global\setlength{\arrayrulewidth}{\Oldarrayrulewidth}}}

\title{Wasserstein Embedding for Graph Learning}



\author{Soheil Kolouri\thanks{Denotes equal contribution.}, Navid Naderializadeh, Gustavo K. Rohde, \& Heiko Hoffmann\\
  HRL Laboratories, LLC., University of Virginia\\
  {\small \texttt{\{skolouri,nnaderializadeh,hhoffmann\}@hrl.com},~\texttt{gustavo@virginia.edu}}\\
}

\newcommand{\soheil}[1]{{\color{red} \textbf{Soheil:} #1}}
\newcommand{\navid}[1]{{\color{blue} \textbf{Navid:} #1}}
\newcommand{\heiko}[1]{{\color{magenta} \textbf{Heiko:} #1}}


\renewcommand{\arraystretch}{1.25}




\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
We present Wasserstein Embedding for Graph Learning (WEGL), a novel and fast framework for embedding entire graphs in a vector space, in which various machine learning models are applicable for graph-level prediction tasks. We leverage new insights on defining similarity between graphs as a function of the similarity between their node embedding distributions. Specifically, we use the Wasserstein distance to measure the dissimilarity between node embeddings of different graphs. Unlike prior work, we avoid pairwise calculation of distances between graphs and reduce the computational complexity from quadratic to linear in the number of graphs. WEGL calculates Monge maps from a reference distribution to each node embedding and, based on these maps, creates a fixed-sized vector representation of the graph. We evaluate our new graph embedding approach on various benchmark graph-property prediction tasks, showing state-of-the-art classification performance while having superior computational efficiency. The code is available at \url{https://github.com/navid-naderi/WEGL}.
\end{abstract}

\section{Introduction}
Many exciting and practical machine learning applications involve learning from graph-structured data. While images, videos, and temporal signals (e.g., audio or biometrics) are instances of data that are supported on grid-like structures, data in social networks, cyber-physical systems, communication networks, chemistry, and bioinformatics often live on irregular structures~\citep{backstrom2011supervised, sadreazami2017distributed, jin2017predicting, agrawal2018large, naderializadeh2020wireless}. One can represent such data as (attributed) graphs, which are universal data structures. Efficient and generalizable learning from graph-structured data opens the door to a vast number of applications, which were beyond the reach of classic machine learning (ML) and, more specifically, deep learning (DL) algorithms.

Analyzing graph-structured data has received significant attention from the ML, network science, and signal processing communities over the past few years. On the one hand, there has been a rush toward extending the success of deep neural networks to graph-structured data, which has led to a variety of graph neural network (GNN) architectures. On the other hand, the research on kernel approaches~\citep{gartner2003graph}, perhaps most notably the random walk kernel~\citep{kashima2003marginalized} and the Weisfeiler-Lehman (WL) kernel~\citep{shervashidze2011weisfeiler,rieck2019persistent,morris2019weisfeiler,morris2020weisfeiler}, remains an active field of study and the methods developed therein provide competitive performance in various graph representation tasks (see the recent survey by \cite{kriege2020survey}).





To learn graph representations, GNN-based frameworks make use of three generic modules, which provide i) feature aggregation, ii) graph pooling (i.e., readout), and iii) classification~\citep{Hu*2020Strategies}. The feature aggregator provides a vector representation for each node of the graph, referred to as a node embedding. The graph pooling module creates a representation for the graph from its node embeddings, whose dimensionality is fixed regardless of the underlying graph size, and which can then be analyzed using a downstream classifier of choice. On the graph kernel side, one leverages a kernel to measure the similarities between pairs of graphs, and uses conventional kernel methods to perform learning on a set of graphs~\citep{hofmann2008kernel}. A recent example of such methods is the framework provided by ~\cite{togninalli2019wasserstein}, in which the authors propose a novel node embedding inspired by the WL kernel, and combine the resulting node embeddings with the Wasserstein distance~\citep{villani2008optimal, kolouri2017optimal} to measure the dissimilarity between two graphs. Afterwards, they leverage conventional kernel methods based on the pairwise-measured dissimilarities to perform learning on graphs.

Considering the ever-increasing scale of graph datasets, which may contain tens of thousands of graphs or millions to billions of nodes per graph, the issue of scalability and algorithmic efficiency becomes of vital importance for graph learning methods~\citep{hernandez2020measuring,hu2020open}. However, both of the aforementioned paradigms of GNNs and kernel methods suffer in this sense. On the GNN side, acceleration of the training procedure is challenging and scales poorly as the graph size grows~\citep{mlg2019_50}. On the graph kernel side, the need for calculating the matrix of all pairwise similarities can be a burden in datasets with a large number of graphs, especially if calculating the similarity between each pair of graphs is computationally expensive. For instance, in the method proposed in~\citep{togninalli2019wasserstein}, the computational complexity of each calculation of the Wasserstein distance is cubic in the number of nodes (or linearithmic for the entropy-regularized distance).



To overcome these issues, inspired by the linear optimal transport framework of~\citep{wang2013linear}, we propose a linear Wasserstein Embedding for Graph Learning, which we refer to as WEGL. Our proposed approach embeds a graph into a Hilbert space, where the  distance between two embedded graphs provides a true metric between the graphs that approximates their 2-Wasserstein distance. For a set of  graphs, the proposed method provides: 
\begin{enumerate}
\item Reduced computational complexity of estimating the graph Wasserstein distance~\citep{togninalli2019wasserstein} for a dataset of  graphs from a quadratic complexity in the number of graphs, i.e.,  calculations, to linear complexity, i.e.,  calculations of the Wasserstein distance; and
\item An explicit Hilbertian embedding for graphs, which is not restricted to kernel methods, and therefore can be used in conjunction with any downstream classification framework.
\end{enumerate} 
We show that compared to multiple GNN and graph kernel baselines, WEGL achieves either state-of-the-art or competitive results on benchmark graph-level classification tasks, including classical graph classification datasets~\citep{KKMMN2016} and the recent molecular property-prediction benchmarks~\citep{hu2020open}. We also compare the algorithmic efficiency of WEGL with two baseline GNN and graph kernel methods and demonstrate that it is much more computationally efficient relative to those algorithms.

\vspace{-0.05in}
\section{Background and Related Work}
\vspace{-0.05in}
In this section, we provide a brief background on different methods for deriving representations for graphs and an overview on Wasserstein distances by reviewing the related work in the literature.

\vspace{-0.05in}
\subsection{Graph Representation Methods}
\vspace{-0.05in}
Let  denote a graph, comprising a set of nodes  and a set of edges , where two nodes  are connected to each other if and only if .\footnote{Note that this definition includes both directed and undirected graphs, where in the latter case, for each edge , the reverse edge  is also included in .} For each node , we define its set of neighbors as . The nodes of the graph  may have categorical labels and/or continuous attribute vectors. We use a unified notation of  to denote the label and/or attribute vector of node , where  denotes the node feature dimensionality. Moreover, we use  to denote the edge feature vector for any edge , where  denotes the edge feature dimensionality. Node and edge features may be present depending on the graph dataset under consideration.

To learn graph properties from the graph structure and its node/edge features, one can use a function  to map any graph  in the space of all possible graphs  to an \emph{embedding}  in a Hilbert space . Kernel methods have been among the most popular ways of creating such graph embeddings. A graph kernel is defined as a function , where for two graphs  and ,  represents the inner product of the embeddings  and  over the Hilbert space . The mapping  could be explicit, as in graph convolutional neural networks, or implicit as in the case of the kernel similarity function  (i.e., the kernel trick). \cite{kriege2014explicit} provide a thorough discussion on explicit and implicit embeddings for learning from graphs.

\cite{kashima2003marginalized} introduced graph kernels based on random walks on labeled graphs. Subsequently, shortest-path kernels were introduced in~\citep{borgwardt2005shortest}. These works have been followed by graphlet and Weisfeiler-Lehman subtree kernel methods~\citep{shervashidze2009efficient, shervashidze2011weisfeiler, morris2017glocalized}. More recently, kernel methods using spectral approaches~\citep{kondor2016multiscale}, assignment-based approaches~\citep{kriege2016valid, nikolentzos2017matching}, and graph decomposition algorithms~\citep{nikolentzos2018degeneracy} have also been proposed in the literature.  

Despite being successful for many years, kernel methods often fail to leverage the explicit continuous features that are provided for the graph nodes and/or edges, making them less adaptable to the underlying data distribution. To alleviate these issues, and thanks in part to the prominent success of deep learning in many domains, including computer vision and natural language processing, techniques based on \emph{graph neural networks (GNNs)} have emerged as an alternative paradigm for learning representations from graph-based data. In general, a GNN comprises multiple hidden layers, where at each layer, each node combines the features of its neighboring nodes in the graph to derive a new feature vector. At the GNN output, the feature vectors of all nodes are aggregated using a readout function (such as global average pooling), resulting in the final graph embedding . More details on the combining and readout mechanisms of GNNs are provided in Appendix~\ref{sec:appx:gnns}.

Kipf and Welling~\citep{kipf2016semi} proposed a GNN architecture based on a graph convolutional network (GCN) framework. This work, alongside other notable works on geometric deep learning~\citep{defferrard2016convolutional}, initiated a surge of interest in GNN architectures, which has led to several architectures, including the Graph Attention network (GAT)~\citep{velivckovic2017graph}, Graph SAmple and aggreGatE (GraphSAGE)~\citep{hamilton2017inductive}, and the Graph Isomorphism Network (GIN)~\citep{xu2018how}. Each of these architectures modifies the GNN combining and readout functions and demonstrates state-of-the-art performance in a variety of graph representation learning tasks.




\subsection{Wasserstein Distances}\label{sec:wd}
\vspace{-0.05in}

Let  denote a Borel probability measure with finite \textsuperscript{th} moment defined on , with corresponding probability density function , i.e., . The 2-Wasserstein distance between  and  defined on  is the solution to the optimal mass transportation problem with  transport cost \citep{villani2008optimal}:
\vspace{-.1in}

where  is the set of all transportation plans  such that  and  for any Borel subsets  and .
Due to Brenier's theorem \citep{brenier1991polar}, for absolutely continuous probability measures  and  (with respect to the Lebesgue measure), the -Wasserstein distance can be equivalently obtained from
\vspace{-.05in}

where  and  represents the pushforward of measure , characterized as
\vspace{-.05in}

The mapping  is referred to as a transport map \citep{kolouri2017optimal}, and the optimal transport map is called the Monge map. For absolutely continuous measures, the differential form of the above equation takes the following form, , which is referred to as the Jacobian equation.
For discrete probability measures, when the transport plan  is a deterministic optimal coupling, such a transport plan is referred to as a Monge coupling \citep{villani2008optimal}.

Recently, Wasserstein distances have been used for representation learning on graphs and images \citep{togninalli2019wasserstein,Zhang_2020_CVPR,becigneul2020optimal}.
In particular, ~\citep{togninalli2019wasserstein} proposed a Wasserstein kernel for graphs that involves pairwise calculation of the Wasserstein distance between graph representations. Pairwise calculation of the Wasserstein distance, however, could be expensive, especially for large graph datasets. In what follows, we apply the linear optimal transportation framework \citep{wang2013linear} to define a Hilbertian embedding, in which the  
distance provides a true metric between the probability measures that approximates . We show that in a dataset containing  graphs, this framework reduces the computational complexity from calculating  linear programs to .





\section{Linear Wasserstein Embedding}
\label{sec:lot}

\setlength{\columnsep}{16pt}\begin{wrapfigure}[19]{r}{0.40\linewidth}
\vspace{-.25in}
\captionsetup{belowskip=0pt}
\includegraphics[width=\linewidth]{Figures/LOT_Figure.png}\caption{Graphical representation of the linear Wasserstein embedding framework, where the probability distributions are mapped to the tangent space with respect to a fixed reference distribution. The figure is adapted from~\cite{kolouri2017optimal}.}\label{fig:lot_main}
\end{wrapfigure}
~\hspace{-.05in}\cite{wang2013linear} and the follow-up works \citep{seguy2015principal,kolouri2016continuous,courty2018learning} describe frameworks for isometric Hilbertian embedding of probability measures such that the Euclidean distance between the embedded images approximates . We leverage the prior work and introduce the concept of linear Wasserstein embedding for learning graph embeddings. 

\vspace{-0.05in}
\subsection{Theoretical Foundation}
\vspace{-0.05in}

We adhere to the definition of the linear Wasserstein embedding for continuous measures. However, all derivations hold for discrete measures as well. More precisely, let  be a reference probability measure defined on , with a positive probability density function , s.t.  and  for . Let  denote the Monge map that pushes  into , i.e.,

Define , where  is the identity function. In cartography, such a mapping is known as the equidistant azimuthal projection, while in differential geometry, it is called the logarithmic map. The mapping  has the following characteristics (partially illustrated in Figure~\ref{fig:lot_main}):

\begin{enumerate}
    \item  provides an isometric embedding for probability measures, i.e., using the Jacobian equation , where .
    \item , i.e., the reference is mapped to zero.
    \item  , i.e., the mapping preserves distances to .
    \item , i.e., the  distance between  and , while being a true metric between  and , is an approximation of .
\end{enumerate} 

Embedding probability measures  via  requires calculating  Monge maps. The fourth characteristic above states that    provides a linear embedding for the probability measures. Therefore, we call it the linear Wasserstein embedding. The mapping  could be thought as the Reproducing Kernel Hilbert Space (RKHS) embedding of the measure,  \citep{muandet2017kernel}. In practice, for discrete distributions, the Monge coupling is used, which could be approximated from the Kantorovich plan (i.e., the transport plan) via the so-called barycenteric projection~\citep{wang2013linear}. We here acknowledge the concurrent work by \citet{mialon2021a}, where the authors use a similar idea to the linear Wasserstein embedding as a pooling operator for learning from \emph{sets} of features. The authors demonstrate the relationship between their proposed optimal transport-based pooling operation and the widespread attention pooling methods in the literature.  A detailed description of the capabilities of the linear Wasserstein embedding framework is included in Appendix~\ref{sec:appx:lot}. We next provide the numerical details of the barycenteric projection \citep{ambrosio2008gradient,wang2013linear}.

\vspace{-0.05in}
\subsection{Numerical Details}
\vspace{-0.05in}

Consider a set of probability distributions , and let 
be an array containing  i.i.d. samples from distribution , i.e., . 
Let us define  to be a reference distribution, with 

, where  and . The optimal transport plan between  and , denoted by , is the solution to the following linear program,
\vspace{-.05in}

where .
The Monge map is then approximated from the optimal transport plan by barycentric projection via

Note that the transport plan  could split the mass in  and distribute it on s. The barycentric projection calculates the center of mass of the transportation locations for  to ensure that no mass splitting is happening  (see Figure \ref{fig:lot_appendix}), and hence it approximates a Monge coupling. Finally, the embedding can be calculated by . With a slight abuse of notation, we use  and  interchangeably throughout the paper. Due to the barycenteric projection, here,  is only pseudo-invertible. 

\section{WEGL: A Linear Wasserstein Embedding for Graphs}


The application of the optimal transport problem to graphs is multifaceted.  For instance, some works focus on solving the ``structured'' optimal transport concerning an optimal probability flow, where the transport cost comes from distances on an often unchanging underlying graph
\citep{leonard2016lazy,essid2018quadratically,titouan2019}.  Here, we are interested in applying optimal transport to measure the dissimilarity between two graphs \citep{maretic2019got,togninalli2019wasserstein,dong2020copt}. Our work significantly differs from \citep{maretic2019got,dong2020copt}, which measure the dissimilarity between non-attributed graphs based on distributions defined by their Laplacian spectra and is closer to \citep{togninalli2019wasserstein}.  

Our proposed graph embedding framework, termed Wasserstein Embedding for Graph Learning (WEGL), combines node embedding methods for graphs with the linear Wasserstein embedding explained in Section \ref{sec:lot}. More precisely, let  denote a set of  individual graphs, each with a set of possible node features  and a set of possible edge features .
Let  be an arbitrary node embedding process, where . Having the node embeddings , we can then calculate a reference node embedding  (see Section~\ref{sub:template} for details), which leads to the linear Wasserstein embedding  with respect to , as described in Section~\ref{sec:lot}. Therefore, the entire embedding for each graph , is obtained by composing  and , i.e., . Figure \ref{fig:graph_lot} visualizes this process. 
\begin{figure}[t]
\centering
\includegraphics[width=\linewidth]{Figures/Graph_LOT_v2.pdf}
\caption{Our proposed graph embedding framework, WEGL, combines node embedding methods with the linear Wasserstein embedding framework described in Section \ref{sec:lot}. Given a graph , we first embed the graph nodes into a -dimensional Hilbert space and obtain an array of node embeddings, denoted by .
We then calculate the linear Wasserstein embedding of  with respect to a reference , i.e., , to derive the final graph embedding.}
\label{fig:graph_lot}
\vspace{-.1in}
\end{figure}

\subsection{Node Embedding}

There are many choices for node embedding methods \citep{chami2020machine}. These methods in general could be parametric or non-parametric, e.g., as in propagation/diffusion-based embeddings. Parametric embeddings are often implemented via a GNN encoder. The encoder can capture different graph properties depending on the type of supervision (e.g., supervised or unsupervised). Self-supervised embedding methods have also been recently shown to be promising~\citep{Hu*2020Strategies}.

In this paper, for our node embedding process , we follow a similar non-parametric propagation/diffusion-based encoder as in \citep{togninalli2019wasserstein}. One of the appealing advantages of this framework is its simplicity, as there are no trainable parameters involved. In short, given a graph  with node features  and scalar edge features , we use the following instantiation of~\eqref{eq:GNN_layers} to define the combining function as

where for any node , its degree  is defined as its number of neighbors in  augmented with self-connections, i.e., . Note that the normalization of the messages between graph nodes by the (square root of) the two end-point degrees in~\eqref{eq:wl_diff} have also been used in other architectures, including GCN~\citep{kipf2016semi}. For the cases where the edge weights are not available, including self-connection weights , we set them to one. In Appendix~\ref{sec:appx:implementation}, we show how we use an extension of~\eqref{eq:wl_diff} to treat graphs with multiple edge features/labels. Finally, we let  represent the resultant embedding for each node , where  is a local pooling process on a single node (not a global pooling), e.g., concatenation or averaging.

\vspace{-0.05in}
\subsection{Calculation of the Reference Distribution}\label{sub:template}
\vspace{-0.05in}

To calculate the reference distribution, we use the -means clustering algorithm on  with  centroids. Alternatively, one can calculate the Wasserstein barycenter \citep{cuturi2014fast} of the node embeddings or simply use  samples from a normal distribution. While approximation of the 2-Wasserstein distance in the tangent space depends on the reference distribution choice, surprisingly, we see a stable performance of WEGL for different references. 
In Appendix~\ref{sec:appx:sensitivity_reference}, we compare the performance of WEGL with respect to different references.

\section{Experimental Evaluation}
In this section, we discuss the evaluation results of our proposed algorithm on multiple benchmark graph classification datasets. We use the PyTorch Geometric framework~\citep{Fey/Lenssen/2019} for implementing WEGL. In all experiments, we use scikit-learn for the implementation of our downstream classifiers on the embedded graphs~\citep{sklearn_api}. 

\subsection{Molecular Property Prediction on the Open Graph Benchmark}

We first evaluate our algorithm on the molecular property prediction task on the \texttt{ogbg-molhiv} dataset. This dataset is part of the Open Graph Benchmark~\citep{hu2020open}, which involves node-level, link-level, and graph-level learning and prediction tasks on multiple datasets spanning diverse problem domains. The \texttt{ogbg-molhiv} dataset, in particular, is a molecular tree-like dataset, consisting of  graphs, with an average number of  nodes and  edges per graph. Each graph is a molecule, with nodes representing atoms and edges representing bonds between them, and it includes both node and edge attributes, characterizing the atom and bond features. The goal is to predict a binary label indicating whether or not a molecule inhibits HIV replication.

To train and evaluate our proposed method, we use the scaffold split provided by the dataset, and report the mean and standard deviation of the results across 10 different random seeds. We perform a grid search over a set of hyperparameters and report the configuration that leads to the best validation performance. We also report a \emph{virtual node} variant of the graphs in our evaluations, where each graph is augmented with an additional node that is connected to all the original nodes in the graph. This node serves as a shortcut for message passing among the graph nodes, bringing any pair of nodes within at most two hops of each other. The complete implementation details can be found in Appendix~\ref{sec:appx:implementation}.

Table~\ref{table:Results_molhiv} shows the evaluation results of WEGL on the \texttt{ogbg-molhiv} dataset in terms of the ROC-AUC (i.e., Receiver Operating Characteristic Area Under the Curve), alongside multiple GNN-based baseline algorithms. Specifically, we show the results using two classifiers: A random forest classifier~\citep{breiman2001random} and an automated machine learning (AutoML) classifier using the Auto-Sklearn 2.0 library~\citep{feurer2020auto}. As the table demonstrates, while WEGL embeddings combined with random forest achieve a decent performance level, using AutoML further enhances the performance and achieves state-of-the-art test results on this dataset, showing the high expressive power of WEGL in large-scale graph datasets, without the need for end-to-end training.

Moreover, as an ablation study, we report the evaluation results on the \texttt{ogbg-molhiv} dataset using a random forest classifier, where the Wasserstein embedding module after the node embedding process is replaced with global average pooling (GAP) among the output node embeddings of each graph to derive the graph-level embedding. As the table demonstrates, there is a significant performance drop when using GAP graph embedding, which indicates the benefit of our proposed graph embedding method as opposed to average readout.


\aboverulesep=0ex
\belowrulesep=0ex
\begin{table}[t!]
\scriptsize
\centering
\noindent\makebox[\textwidth]{
\rowcolors{1}{Gray}{}
\setlength\tabcolsep{5.6pt}
\begin{tabular}{cl|ccc}
\cmidrule[1.5pt]{2-4}
 & Method & Validation ROC-AUC (\%) & Test ROC-AUC (\%)\\ 
\cline{2-4}& 
GCN~\citep{kipf2016semi} & 83.8  0.9 & 76.0  1.2 \\
\cellcolor{white} & GIN + Virtual Node~\citep{xu2018how} & \bf84.8  0.7 & 77.1  1.5\\
& DeeperGCN~\citep{li2020deepergcn} & 84.3  0.6 & 78.6  1.2 \\
\cellcolor{white} & HIMP~\citep{fey2020hierarchical} & - & 78.8  0.8 \\
\multirow{-5}{*}{\rotatebox[origin=c]{90}{~~~GNN~~~}} & GCN + GraphNorm~\citep{cai2020graphnorm} & 79.0  1.1 & 78.8  1.0 & \multirow{-5}{*}{\rotatebox[origin=c]{90}{\phantom{GNN}}} \\
\cline{2-4}
& WEGL + Random Forest &  79.2  2.2 &  75.5  1.5 \\
\cellcolor{white}& WEGL + Virtual Node + Random Forest & 81.9  1.3 & 76.5  1.8 \\
\multirow{-3}{*}{\rotatebox[origin=c]{90}{\cellcolor{white}~Ours~}} &  WEGL + Virtual Node + AutoML & 81.6  0.6 & {\bf79.1  0.3} \\
\hhline{~|*3{-}|}
\cellcolor{white} & \cellcolor{white}GAP + Virtual Node + Random Forest & 74.9  2.4 & \cellcolor{white}72.1  1.7 \\
\cmidrule[1.5pt]{2-4}
\end{tabular}}
\vspace{.1in}
\caption{Graph classification results on the \texttt{ogbg-molhiv} dataset. The results for GCN and GIN are reported from~\citep{hu2020open}. The best validation and test results are shown in \textbf{bold}.}
\label{table:Results_molhiv}
\end{table}

\subsection{TUD Benchmark Datasets}\label{sec:tud_results}
\vspace{-0.05in}

We also consider a set of social network, bioinformatics and molecule graph datasets~\citep{KKMMN2016}. The social network datasets (\texttt{IMDB-BINARY}, \texttt{IMDB-MULTI}, \texttt{COLLAB}, \texttt{REDDIT-BINARY}, and \texttt{REDDIT-MULTI-5K}) lack both node and edge features. Therefore, in these datasets we use a one-hot representation of the node degrees as their initial feature vectors, as also used in prior work, e.g.,~\citep{xu2018how}. To handle the large scale of the \texttt{REDDIT-BINARY} and \texttt{REDDIT-MULTI-5K} and datasets, we clip the node degrees at 500.

Moreover, for the molecule (\texttt{PTC-MR}) and bioinformatics (\texttt{ENZYMES} and \texttt{PROTEINS}) datasets, we use the readily-provided node labels in~\citep{KKMMN2016} as the initial node feature vectors. Besides, for \texttt{PTC-MR} which has edge labels, as explained in Appendix~\ref{sec:appx:implementation}, we use an extension of~\eqref{eq:wl_diff} to use the one-hot encoded edge features in the diffusion process. To evaluate the performance of WEGL, we follow the methodology used in~\citep{yanardag2015deep,niepert2016learning,xu2018how}, where for each dataset, we perform 10-fold cross-validation with random splitting on the entire dataset, conducting a grid search over the desired set of hyperparameters as mentioned in Appendix~\ref{sec:appx:implementation}, and we then report the mean and standard deviation of the validation accuracies achieved during cross-validation. For this experiment, we use two ensemble classifiers, namely Random Forest and Gradient Boosted Decision Tree (GBDT), together with kernel-SVM with an RBF kernel (SVM-RBF). Given that the Euclidean distance in the embedding space approximates the 2-Wasserstein distance, the SVM-RBF classification results are comparable with those reported by~\cite{togninalli2019wasserstein}.

Table~\ref{table:Results_TUD} shows the classification accuracies achieved by WEGL on the aforementioned datasets as compared with several GNN and graph kernel baselines, whose results are extracted from the corresponding original papers. As the table demonstrates, our proposed algorithm achieves either state-of-the-art or competitive results across all the datasets, and in particular, it is among the top-three performers in all of them. This shows the effectiveness of the proposed linear Wasserstein embedding for learning graph-level properties across different domains.

\aboverulesep=0ex
\belowrulesep=0ex
\begin{table}[t!]
\centering
\scriptsize
\setlength\tabcolsep{3pt}
\begin{tabular}{rl|cccccccc} 
\cmidrule[1.5pt]{2-10}
& Method & \texttt{IMDB-B} & \texttt{IMDB-M} & \texttt{COLLAB} & \texttt{RE-B} & \texttt{RE-M5K} & \texttt{PTC-MR} & \texttt{ENZYMES}  & \texttt{PROTEINS}\\ 
\cmidrule[.5pt]{2-10}
 & DGCNN {\tiny \citep{zhang2018end}} & 69.23.0 & 45.63.4  & 71.21.9   & 87.82.5   & 49.21.2   & 58.6 & 38.95.7   & 72.93.5    \\
\rowcolor{Gray}\cellcolor{white} 
& GraphSAGE {\tiny \citep{hamilton2017inductive}}     & 68.84.5   & 47.63.5   & 73.91.7   & 84.31.9   & 50.01.3   & 63.97.7   & - & 75.93.2    \\
& GIN  {\tiny \citep{xu2018how}}          & 75.15.1   & 2.32.8    & 80.21.9   & {\bf 92.42.5}   & {\bf 57.51.5}   & 64.67.0   & -  & 76.22.8    \\
\rowcolor{Gray}\cellcolor{white} 
& GNTK {\tiny \citep{du2019graph}}  & {\bf 76.93.6}   & {\bf 52.84.6}   & {\bf 83.61.0}   &  -  &    -    & {\bf 67.96.9}   &     -   & 75.64.2    \\
& CapsGNN  {\tiny \citep{xinyi2019capsule}}      & 73.14.8   & 50.32.6   & 79.60.9   &  -      & 52.91.5   &       -    & 54.75.7   & {\bf 76.33.6}    \\
 \multirow{-6}{*}{\rotatebox[origin=c]{90}{~~~GNN~~~}}
 & \cellcolor{Gray}GraphNorm  {\tiny \citep{cai2020graphnorm}}    & \cellcolor{Gray}{\bf 76.03.7}   &  \cellcolor{Gray}- & \cellcolor{Gray}{\bf 80.21.0}   & \cellcolor{Gray}{\bf 93.52.1}   &  \cellcolor{Gray}-   & \cellcolor{Gray}64.97.5   & \cellcolor{Gray}- & \cellcolor{Gray}{\bf 77.44.9}   \\ 
 \cmidrule[.5pt]{2-10}
& DGK   {\tiny \citep{yanardag2015deep}}        & 67.00.6   & 44.60.5   & 73.10.3   & 78.00.4   & 41.30.2   & 57.31.1   & 27.10.8   & 71.70.5    \\
\rowcolor{Gray}\cellcolor{white}& 
WL  {\tiny \citep{shervashidze2011weisfeiler}}     & 73.83.9   & 49.80.5   & 74.80.2   & 68.20.2   & 51.20.3   & 57.02.0   & 53.21.1   & 72.90.6    \\ 
& RetGK   {\tiny \citep{zhang2018retgk}}& 71.00.6   & 46.70.6   & 73.60.3   & 90.80.2   & 54.20.3   & {\bf 67.91.4}   & 59.11.1   & 75.20.3    \\
\rowcolor{Gray}\cellcolor{white}
& AWE {\tiny \citep{ivanov2018anonymous}}      & 74.55.8   & 51.53.6   & 73.91.9   & 87.92.5   & 50.51.9   &      -     & 35.85.9   &      -      \\
\multirow{-5}{*}{\rotatebox[origin=c]{90}{~~~GK~~~}}
& WWL   {\tiny \citep{togninalli2019wasserstein}}      & 74.40.8   &     -   &     -      &    -       &     -  & 66.31.2   & {\bf 59.10.8}   & 74.30.6    \\ 
\cmidrule[.5pt]{2-10}
\rowcolor{Gray}\cellcolor{white}
& WEGL + SVM-RBF & 73.42.5 & 51.73.1 & 78.61.0 & 92.11.9 & {\bf 56.12.3} & 63.45.3 & 57.34.2 & 76.04.4  \\
\cellcolor{white}
& WEGL + Random Forest      & {\bf 75.45.0}   & {\bf 52.04.1}   & 79.81.5   & 92.00.8   & 55.12.5   & {\bf 67.57.7}   & {\bf 60.55.9}   & {\bf 76.54.2}    \\
\multirow{-3}{*}{\rotatebox[origin=c]{90}{~~~Ours~~~}}
& \cellcolor{Gray}WEGL + GBDT    & \cellcolor{Gray}75.25.0 & \cellcolor{Gray}{\bf 52.32.9} & \cellcolor{Gray}{\bf 80.62.0} & \cellcolor{Gray}{\bf 92.91.9} & \cellcolor{Gray}{\bf 55.41.6} & \cellcolor{Gray}66.26.9 & \cellcolor{Gray}{\bf 60.06.3} & \cellcolor{Gray}76.33.9 \\
\cmidrule[1.5pt]{2-10}
\end{tabular}
\caption{Graph classification accuracy (\%) of our method and comparison with the state-of-the-art GNNs and graph kernels (GKs) on various TUD graph classification tasks. The results for DGCNN are reported from~\citep{Errica2020A}. The top-three performers on each dataset are shown in \textbf{bold}.}
\label{table:Results_TUD}
\end{table}












\iffalse
\subsection{Impact of Wasserstein Embedding}
Table~\ref{table:ablation_GAP} shows the graph classification accuracy on two TUD datasets (\texttt{IMDB-B} and \texttt{IMDB-M}), when the Wasserstein embedding module after the node embedding process is replaced with global average pooling among the output node embeddings of each graph to derive the graph-level embedding. As the table demonstrates, in most cases, for any given classifier (i.e., SVM-RBF, random forest, and GBDT), our proposed Wasserstein embedding method outperforms global average pooling of the node embeddings.
\aboverulesep=0ex
\belowrulesep=0ex
\begin{table}[t!]
\scriptsize
\centering
\noindent\makebox[\textwidth]{
\rowcolors{3}{}{Gray}
\setlength\tabcolsep{5.6pt}
\begin{tabular}{l|ccc|ccc}
\cmidrule[1.5pt]{1-7}
\multirow{2}{*}{Dataset} & \multicolumn{3}{c|}{WEGL} & \multicolumn{3}{c}{Global Average Pooling}\\ 
& SVM-RBF & Random Forest & GBDT & SVM-RBF & Random Forest & GBDT \\
\hline
\texttt{IMDB-B} & 73.42.5 & 75.45.0 & 75.25.0 & 72.43.3 & 74.84.1 & 75.24.1 \\
\texttt{IMDB-M} & 51.73.1 & 52.04.1 & 52.32.9 & 50.93.3 & 53.15.0 & 52.24.2 \\
\cmidrule[1.5pt]{1-7}
\end{tabular}}
\vspace{.1in}
\caption{Ablation study on the graph classification accuracy (\%) of Wasserstein embedding vs simple global average pooling on \texttt{IMDB-B} and \texttt{IMDB-M} datasets.}
\label{table:ablation_GAP}
\end{table}
\fi


\subsection{Computation Time}
As mentioned before, one of the most important advantages of WEGL as compared to other graph representation learning methods is its algorithmic efficiency. To evaluate that, we compare the wall-clock training and inference times of WEGL with those of GIN and the Wasserstein Weisfeiler-Lehman (WWL) graph kernel on five different TUD datasets (\texttt{IMDB-B}, \texttt{MUTAG}, \texttt{PTC-MR}, \texttt{PROTEINS}, and \texttt{NCI1})\footnote{The complete classification results of WEGL on these datasets can be found in Appendix~\ref{sec:appx:full_wegl_results}.}. For WEGL and WWL, we use the exact linear programming solver (as opposed to the entropy-regularized version). We carry out our experiments for WEGL and WWL on a  GHz Intel\textsuperscript{\tiny \textregistered} Xeon\textsuperscript{\tiny \textregistered} E5-2670 v3 CPU, while we use a  GB NVIDIA\textsuperscript{\tiny \textregistered} Tesla\textsuperscript{\tiny \textregistered} P100 GPU for GIN. As a reference, we implement GIN on the aforementioned CPU hardware as well.

Figure~\ref{fig:wall_clock} shows how the training and inference run-times of WEGL, WWL and GIN scale with the number of graphs in the dataset, the average number of nodes per graph, and the average number of edges per graph. As the figure illustrates, while having similar or even better performance, training WEGL is several orders of magnitude faster than WWL and GIN, especially for datasets with larger numbers of graphs. Note that training WWL becomes very inefficient as the number of graphs in the dataset increases due to the pairwise distance calculation between all the graphs.

During inference, WEGL is slightly slower than GIN, when implemented on a GPU. However, on most datasets, WEGL is considerably faster in inference as compared to GIN implemented on a CPU. Moreover, both algorithms are significantly faster than WWL. Using GPU-accelerated implementations of the diffusion process in~\eqref{eq:wl_diff} and the entropy-regularized transport problem could potentially further enhance the computational efficiency of WEGL during inference.

\begin{figure}[t]
\centering
\includegraphics[width=\linewidth]{Figures/training_testing_runtime_comparison.pdf}
\caption{Average wall-clock time comparison of our proposed method, WEGL with WWL \citep{togninalli2019wasserstein} and GIN \citep{xu2018how}. WEGL and WWL were implemented on a  GHz Intel\textsuperscript{\tiny \textregistered} Xeon\textsuperscript{\tiny \textregistered} E5-2670 v3 CPU. Moreover, GIN was implemented twice, once using the aforementioned CPU and once using a  GB NVIDIA\textsuperscript{\tiny \textregistered} Tesla\textsuperscript{\tiny \textregistered} P100 GPU, with 5 hidden layers,  training epochs and a batch size of  in both cases.}
\label{fig:wall_clock}
\vspace{-.05in}
\end{figure}



\section{Conclusion}
We considered the problem of graph property prediction and introduced the linear Wasserstein Embedding for Graph Learning, which we denoted as WEGL. Similar to \citep{togninalli2019wasserstein}, our approach also relies on measuring the Wasserstein distances between the node embeddings of graphs. Unlike \citep{togninalli2019wasserstein}, however, we further embed the node embeddings of graphs into a Hilbert space, in which their Euclidean distance approximates their 2-Wasserstein distance. WEGL provides two significant benefits: i) it has linear complexity in the number of graphs (as opposed to the quadratic complexity of \citep{togninalli2019wasserstein}), and ii) it enables the application of any ML algorithm of choice, such as random forest, gradient boosted decision tree, or even AutoML. We demonstrated WEGL's superior performance and highly efficient training on a wide range of benchmark datasets, including the \texttt{ogbg-molhiv} dataset and the TUD graph classification tasks. 


\section*{Acknowledgement}
We gratefully acknowledge funding by the United States Air Force under Contract No. FA8750‐19‐C‐0098. Gustavo K. Rohde also acknowledges funding by NIH grant GM130825. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the United States Air Force and DARPA. 



\bibliography{WEGL_ICLR21.bib}
\bibliographystyle{iclr2021_conference}

\newpage
\clearpage
\appendix
\section{Appendix}
\label{sec:appx}

Here we provide further details on the theoretical aspect of WEGL, our implementation details, and the sensitivity of the results to the choice of reference distribution. We also share our implementation code on the \texttt{ogbg-molhiv} dataset to help with the review process.

\vspace{-0.05in}
\subsection{Detailed Discussion on Linear Wasserstein Embedding}
\label{sec:appx:lot}

\begin{figure}[b]
    \centering
    \includegraphics[width=\linewidth]{Figures/LOT_theory.pdf}
    \caption{Illustration of (a) the meaning behind  used in the LOT distance in \eqref{eq:lot_discrete}, and (b) the idea of the barycenteric projection, which provides a fixed-size representation (i.e., of size ).}
    \label{fig:lot_theory}
\end{figure}

The linear Wasserstein embedding used in WEGL is based on the Linear Optimal Transport (LOT) framework introduced in \citep{wang2013linear}. The main idea is to compute the ``projection'' of the manifold of probability measures to the tangent space at a fixed reference measure. In particular, the tangent space at measure  is the set of vector fields  such that the inner product is the weighted :
\vspace{-.07in}


We can then define , where  is the optimal transport map from  to . Note that , , and
\vspace{-0.07in}

In the paper, we use  to turn the weighted- into .

The discussion above assumes an absolutely continuous reference measure . A more interesting treatment of the problem is via the \emph{generalized geodesics} defined in~\citep{ambrosio2008gradient}, connecting  and  and enabling us to use discrete reference measures. Following the notation in~\citep{ambrosio2008gradient}, given the reference measure , let  be the set of transport plans between  and , and let  be the set of all measures on the product space  such that the marginals over  and  are  and , respectively. Then the linearized optimal transport distance is defined as
\vspace{-.07in}

In a discrete setting, where , , and , we have
\vspace{-.03in}

See Figure \ref{fig:lot_theory}a for a depiction of Equation \eqref{eq:lot_discrete}'s meaning. Finally, the idea of barycenteric projection used to approximate Monge couplings and provide a fixed-size representation is shown in Figure \ref{fig:lot_theory}b.

Next, to demonstrate the capability of the linear Wasserstein embedding, we present the following experiment. Consider a set of distributions , where each  is a translated and dilated ring distribution in , and  samples are observed from , where  and  could be different for . We then consider a normal distribution as the reference distribution and calculate the linear Wasserstein embedding with respect to the reference (See Figure \ref{fig:lot_appendix}a). Given the pseudo-invertible nature of the embedding, to demonstrate the modeling capability of the framework, we calculate the mean in the embedding space (i.e., on the vector fields), and invert it to obtain the mean distribution . Figure \ref{fig:lot_appendix}b shows the calculated mean, indicating that the linear Wasserstein embedding framework has successfully retrieved a ring distribution as the mean. Finally, we calculate Euclidean geodesics in the embedding space (i.e., the convex combination of the vector fields) between  and , as well as between  and , and show the inverted geodesics in Figures \ref{fig:lot_appendix}c and \ref{fig:lot_appendix}d, respectively. As the figures demonstrate, the calculated geodesics follow the Wasserstein geodesics.

\begin{figure}[t!]
    \setlength{\belowcaptionskip}{-3pt}
    \centering
    \includegraphics[width=\linewidth]{Figures/LOT.pdf}
    \caption{An experiment demonstrating the capability of the linear Wasserstein embedding. (a) A simple dataset consisting of shifted and scaled noisy ring distributions , where we only observe samples  from each distribution, together with the process of obtaining the linear Wasserstein embedding with respect to a reference distribution. In short, for each distribution , the embedding approximates the Monge-map (i.e., a vector field) from the reference samples  to the target samples  by a barycentric projection of the optimal transport plan. Adding samples in the embedding space corresponds to adding their vector fields, which can be used to calculate (b) the mean distribution in the embedding space, i.e.,  and (c)-(d) the Euclidean geodesics in this space, i.e.,   for . As can be seen, the calculated mean is the Wasserstein barycenter of the dataset, and the Euclidean geodesics in the embedding space follow the Wasserstein geodesics in the original space. 
}
    \label{fig:lot_appendix}
\end{figure}

\subsubsection*{Approximation Error of the Embedding}

Given the Euclidean distance in the embedding space is a transport-based distance (i.e., the so-called LOT distance) that approximates the Wasserstein distance, a natural question arises about the approximation error. Here we point the reader to the recent work of \cite{moosmuller2020linear} in which the authors provide bounds on how well the Euclidean distance in the embedding space approximates the 2-Wasserstein distance. In particular, the authors show that:
        
where  is the optimal transport map from  to . This inequality simply indicates that the approximation error is caused by conditioning the transport map to be obtained by composition of the optimal transport maps from  to , and then from  to . More importantly, it can be shown that if  and  are shifted and scaled versions of the reference measure, , then the embedding is isometric (See Figure 1 and 2 in \cite{moosmuller2020linear}).

Maybe a less interesting upper bound can also be obtained by the triangle inequality:
        
which ensures some regularity of the embedding.

\subsubsection*{Regularity of the Embedding}
A good question was raised during the feedback period, about the regularity of the proposed embedding. The regularity of the graph embedding will depend on both the regularity of node-embedding and the Wasserstein embedding. In the following, we avoid the discussion on regularity of the node-embedding (as it is not the main focus of our work), and focus on the regularity of the Wasserstein embedding. To that end, we first point out several regularity characteristics pointed out in Appendix A of \cite{moosmuller2020linear}. Most notably Theorem 4.2 in their paper, shows an \emph{almost isometric} property when the distortions are within an -tube around the set of shifts and scalings. In short, let , ,  ,  be the set of all shifts and scalings, and 
        
        and let
        
        which is the -tube around set of shifts and scalings. Now, assume  is the reference measure and both  and  satisfy Caffarelli's regularity theorem. Then for  we have
        
        where  and  are constants depending on , , and . 
        
The results shown above can be used to derive regularity results for the linear Wasserstein embedding with respect to additive noise. We know that the addition of two random variables leads to a new random variable with its PDF being the convolution of the original PDFs. Therefore, for features , let  denote the noisy samples for , where  is the noise distribution. Then the noisy samples, , will be distributed according to . For instance,  for the Gaussian additive noise,  is the smoothed version of . Therefore, there exists a transport map in  for which,  and , and we have:


\begin{figure}[b!]
    \centering
    \includegraphics[width=\linewidth]{Figures/Sensitivity_to_template.pdf}
    \caption{ROC-AUC (\%) results on \texttt{ogbg-molhiv} dataset, when the reference distribution is calculated by -means (Section \ref{sub:template}) on the training dataset (denoted as -means), compared to when it is fixed to be a normal distribution (denoted as Normal). With a -value, the choice of the template is statistically insignificant.}
    \label{fig:template}
\end{figure}

\subsection{Sensitivity to the Choice of Reference Distribution}
\label{sec:appx:sensitivity_reference}

To measure the dependency of WEGL on the reference distribution choice, we changed the reference to a normal distribution (i.e., data-independent). We compared the results of WEGL using the new reference distribution to that using a reference distribution calculated via -means on the training set. We used the \texttt{ogbg-molhiv} dataset with initial node embedding of size  and  diffusion layers. We ran the experiment with 100 different random seeds, and measured the test ROC-AUC of WEGL calculated with the two aforementioned reference distributions. Figure~\ref{fig:template} shows the results of this experiment, indicating that the choice of reference distribution is statistically insignificant.

\subsection{Linear Programming vs. Entropy Regularization}

In this paper, we used the Python Optimal Transport \citep{flamary2017pot} for the calculation of the optimal transport plans. During the feedback period, a point came up regarding the entropy-regularized version of the OT problem \citep{cuturi2014fast}, which reduces the complexity of the linear programming problem from being cubic, in the number of nodes, to being quadratic, using the Sinkhorn algorithm. Given the Sinkhorn algorithm's iterative nature, the computational gain of the method is prominent when calculating the transportation problem between graphs with a large number of nodes (e.g., larger than ). However, the graph datasets used in this paper often have a small number of nodes (e.g., ). In these settings, linear programming is efficient. To obtain any computational gain using the Sinkhorn algorithm, one would need to use a large regularization coefficient, which reduces the Sinkhorn algorithm's precision. 

Here we ran an experiment on the \texttt{ogbg-molhiv} dataset. We obtain the transport plans between the node embeddings and the reference distribution using the linear programming solver (using \texttt{ot.emd2} from \citep{flamary2017pot}) and the Sinkhorn algorithm for the entropy-regularized problem (using \texttt{ot.sinkhorn2} from \citep{flamary2017pot}). We measure the calculation time as well as the calculated distances for both algorithms. For the Sinkhorn algorithm, we used four different regularization values. We report the mean and standard deviation of calculation time ratio, i.e.,  and the relative error of calculating the 2-Wasserstein distance, i.e.,  in Figure \ref{fig:sink}. As the figure shows, due to the small graph size, the LP solver is efficient and little to no gain can be obtained using the Sinkhorn algorithm. Nevertheless, in the case of dealing with larger graph sizes, the entropy regularized formulation should be the definite choice. Finally, for the entropy-regularized OT problem, more efficient solvers have been proposed that outperform the Sinkhorn algorithm \citep{dvurechensky2018computational}. However, given the acceptable performance of the linear programming solver (at least for the graph datasets in this paper), we did not find it necessary to seek more efficient solvers. 

\begin{figure}
    \centering
    \includegraphics[width=.6\linewidth]{Figures/LP_Sinkhorn_molhiv.png}
    \caption{Comparing the performance of the linear programming (LP) solver with the Sinkhorn algorithm (on entropy regularized OT problem) on the \texttt{ogbg-molhiv} dataset for various regularization parameters.}
    \label{fig:sink}
\end{figure}

\subsection{Inner Working of GNNs}\label{sec:appx:gnns}
In its most general form, a GNN consists of  hidden layers, where at the \textsuperscript{th} layer, each node  aggregates and combines \emph{messages} from its 1-hop neighboring nodes , resulting in the feature vector
\vspace{-.03in}

where  denotes a parametrized and differentiable combining function.

At the input layer, each node  starts with its initial feature vector , and the sequential application of GNN layers, as in~\eqref{eq:GNN_layers}, computes intermediate feature vectors . At the GNN output, the feature vectors of all nodes from all layers go through a global pooling (i.e., readout) function , resulting in the final graph embedding



\subsection{Implementation Details}\label{sec:appx:implementation}



To derive the node embeddings, we use the diffusion process in~\eqref{eq:wl_diff} for the datasets without edge features/labels, i.e., all the social network datasets (\texttt{IMDB-BINARY}, \texttt{IMDB-MULTI}, \texttt{COLLAB}, \texttt{REDDIT-BINARY}, \texttt{REDDIT-MULTI-5K}, and \texttt{REDDIT-MULTI-12K}) and four of the molecule and bioinformatics datasets (\texttt{ENZYMES}, \texttt{PROTEINS}, \texttt{D\&D}, and \texttt{NCI1}). We specifically set  for any  and also for all self-connections, i.e., .

The remaining datasets contain edge labels that cannot be directly used with~\eqref{eq:wl_diff}. Specifically, each edge in the \texttt{MUTAG} and \texttt{PTC-MR} datasets has a categorical label, encoded as a one-hot vector of dimension four. Moreover, in the \texttt{ogbg-molhiv} dataset, each edge has three categorical features indicating bond type (five categories), bond stereochemistry (six categories) and whether the bond is conjugated (two categories). We first convert each categorical feature to its one-hot representation, and then concatenate them together, resulting in a binary 13-dimensional feature vector for each edge.

In each of the three aforementioned datasets, for any edge , let us denote its binary feature vector by , where  is equal to 4, 4, and 13 for \texttt{MUTAG}, \texttt{PTC-MR}, and \texttt{ogbg-molhiv}, respectively. We then use the following extension of the diffusion process in~\eqref{eq:wl_diff},

where for any ,  denotes the \textsuperscript{th} element of , and for any node , we define  as its degree over the \textsuperscript{th} elements of the edge features; i.e., . We assign vectors of all-one features to the self-connections in the graph; i.e., . Note that the formulation of the diffusion process in~\eqref{eq:wl_diff_binary_edge_features} can be seen as an extension of~\eqref{eq:wl_diff}, where the underlying graph with multi-dimensional edge features is broken into  \emph{parallel} graphs with non-negative single-dimensional edge features, and the parallel graphs perform message passing at each round/layer of the diffusion process.

For the \texttt{ogbg-molhiv} experiments in which virtual nodes were appended to the original molecule graphs, we set the initial feature vectors of all virtual nodes to all-zero vectors. Moreover, for any graph  in the dataset with  nodes, we set the edge features for the edge between the virtual node  and each of the original graph nodes  as . The normalization by the number of graph nodes is included so as to regulate the degree of the virtual node used in~\eqref{eq:wl_diff_binary_edge_features}. We also include the resultant embedding of the virtual node at the end of the diffusion process in the calculation of the graph embedding .

In the experiments conducted on each dataset, once the node embeddings are derived from the diffusion process, we standardize them by subtracting the mean embedding and dividing by the standard deviation of the embeddings, where the statistics are calculated based on all the graphs in the dataset. Moreover, to reduce the computational complexity of estimating the graph embeddings for the \texttt{ogbg-molhiv} dataset, we further apply a 20-dimensional PCA on the node embeddings.

\subsubsection*{Hyperparameters}
We use the following set of hyperparameters to perform a grid search over in each of the experiments:
\begin{itemize}
    \item \textbf{Random Forest}: , , and .
    \item \textbf{Gradient Boosted Decision Tree (GBDT)}: , , , and .
    \item \textbf{SVM-Linear and SVM-RBF}: .
    \item \textbf{Multi-Layer Perceptron (MLP)}:
    
    .
    \item \textbf{Auto-ML}: Auto-Sklearn 2.0 searches over a space of 42 hyperparameters using Bayesian optimization techniques, as mentioned in~\cite{feurer2020auto}.
    \item \textbf{Number of Diffusion Layers in~\eqref{eq:wl_diff} and~\eqref{eq:wl_diff_binary_edge_features}}: .
    \item \textbf{Initial Node Feature Dimensionality (for \texttt{ogbg-molhiv} only)}: .
    \item \textbf{Node Embedding Type}: For a graph with -dimensional initial node features, we consider using the following three types of node embedding:
\begin{itemize}
    \item Concat: , where  denotes concatenation.
    
    \item Average: .
    
    \item Final: .
\end{itemize}
\end{itemize}




\subsection{TUD Benchmark --- Complete Results}
\label{sec:appx:full_wegl_results}
Here, we report the comprehensive set of classification results of our proposed method, WEGL, for each of the node embedding types mentioned in Section~\ref{sec:appx:implementation}, using five different classifiers: Linear SVM, Kernel-SVM (SVM-RBF), Gradient Boosted Decision Trees (GBDT), Multi-Layer Perceptron (MLP), and Random Forest (RF). The results are shown in Table \ref{table:Results_TUD_All}.

\renewcommand\arraystretch{1.5}
\begin{landscape}
\begin{table}
[t!]
\centering
\noindent\makebox[\textwidth]{
\setlength\tabcolsep{4pt}
\begin{tabular}{c|c|c|cccccccccc|} 
\cline{2-13}
& \multicolumn{2}{l|}{Classifier + Embedding Type}                & IMDB-B     & IMDB-M     & COLLAB     & RE-B       & RE-M5K     & PTC-MR     & ENZYMES    & PROTEINS   & MUTAG       & NCI         \\ 
\cline{2-13}
\multirow{15}{*}{\rotatebox[origin=c]{90}{WEGL}} & \multirow{3}{*}{SVM - Linear} & Concat & 69.1  6.1 & 41.3  1.8 & 72.7  1.9 & 91.3  1.8 & 55.6  2.5 & 61.6  5.8 & 50.0  5.8 & 74.1  2.3 & 83.6  9.5  & 58.9  7.2  \\ 
\cline{3-3}
                       &                               & Avg    & 72.7  5.5 & 51.7  3.4 & 76.4  1.3 & 79.8  3.1 & -          & 62.8  4.9 & 39.3  7.7 & 74.2  3.5 & 82.0  7.4  & 56.2  3.6  \\ 
\cline{3-3}
                       &                               & Final  & 72.5  3.7 & 51.1  6.3 & -          & -          & -          & 62.2  6.6 & 37.5  5.5 & 73.1  2.1 & 81.9  5.4  & 57.4  5.0  \\ 
\cline{2-13}
                       & \multirow{3}{*}{SVM - RBF}    & Concat & 71.9  2.4 & 49.2  3.1 & 75.8  2.6 & 92.1  1.9 & 56.1  2.3 & 62.5  5.8 & 57.3  4.2 & 76.0  4.4 & 84.0  7.6  & 67.8  2.1  \\ 
\cline{3-3}
                       &                               & Avg    & 73.4  2.5 & 50.9  2.7 & 78.6  1.0 & 80.5  2.6 & -          & 63.4  5.3 & 50.8  5.0 & 75.7  4.4 & 83.0  8.4  & 65.1  2.1  \\ 
\cline{3-3}
                       &                               & Final  & 72.8  3.8 & 51.7  3.1 & -          & -          & -          & 62.8  8.2 & 52.7  5.0 & 75.8  4.7 & 82.4  7.9  & 64.9  2.3  \\ 
\cline{2-13}
                       & \multirow{3}{*}{GBDT}         & Concat & 74.5  4.2 & 51.9  2.8 & 80.6  2.0 & 92.9  1.9 & 55.4  1.6 & 63.4  5.4 & 60.0  6.3 & 76.3  3.9 & 89.3  6.6  & 78.4  1.6  \\ 
\cline{3-3}
                       &                               & Avg    & 75.2  5.0 & 52.3  2.9 & -          & 88.8  1.9 & -          & 65.2  6.0 & 58.5  6.5 & 75.9  2.7 & 87.8  6.2  & 78.2  2.9  \\ 
\cline{3-3}
                       &                               & Final  & 75.1  2.0 & 52.1  4.0 & -          & -          & -          & 66.2  6.9 & 57.7  5.6 & 75.9  2.8 & 87.2  10.0 & 76.4  2.5  \\ 
\cline{2-13}
                       & \multirow{3}{*}{MLP}          & Concat & 72.0  3.5 & 48.9  3.1 & 73.1  2.4 & 86.9  3.6 & 51.5  1.6 & 60.2  6.5 & 57.8  5.4 & 72.5  4.2 & 82.0  6.2  & 61.3  4.6  \\ 
\cline{3-3}
                       &                               & Avg    & 72.0  4.0 & 48.5  3.7 & 78.6  1.0 & 76.2  2.3 & -          & 61.1  5.0 & 55.7  5.6 & 74.1  3.0 & 82.0  8.5  & 60.0  3.8  \\ 
\cline{3-3}
                       &                               & Final  & 72.6  3.5 & 50.3  3.8 & -          & -          & -          & 61.6  6.3 & 55.5  5.2 & 72.8  4.1 & 81.9  5.9  & 59.9  3.7  \\ 
\cline{2-13}
                       & \multirow{3}{*}{RF}           & Concat & 74.96.3   & 50.84.0   & 79.81.5   & 92.00.8   & 55.12.5   & 64.67.4   & 60.55.9   & 76.13.3   & 88.35.1    & 76.81.7    \\ 
\cline{3-3}
                       &                               & Avg    & 74.45.6   & 52.04.1   & 78.81.4   & 87.83.0   & 53.32.0   & 67.57.7   & 58.76.9   & 75.83.6   & 86.25.8    & 76.61.1    \\ 
\cline{3-3}
                       &                               & Final  & 75.45.0   & 51.74.6   & 79.11.1   & 87.52.0   & 53.21.8   & 66.36.5   & 57.55.5   & 76.54.2   & 86.29.5    & 75.91.2    \\
\cline{2-13}
\end{tabular}}
\caption{Graph classification accuracy (\%) of the Wasserstein embedding based on different classifiers and the three types of node embeddings, on various TUD graph classification tasks.}
\label{table:Results_TUD_All}
\end{table}
\end{landscape}





\end{document}
