\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{psfrag}


\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newenvironment{proof}{\noindent \begin{rm}{\textbf{Proof.} }}{\hspace*{\fill}\par\end{rm} \vspace{.3cm}}

\newcommand{\id}{\mbox{ID}}
\newcommand{\Neig}{\mbox{\rm N}}
\newcommand{\InfoMsg}{\mbox{\tt InfoMsg}}

\renewcommand{\root}{\mbox{\sf root}}
\newcommand{\parent}{\mbox{\sf parent}}
\newcommand{\level}{\mbox{\sf level}}
\newcommand{\dist}{\mbox{\sf dist}}
\newcommand{\need}{\mbox{\sf need}}
\newcommand{\connect}{\mbox{\sf connected}}
\newcommand{\member}{\mbox{\sf member}}
\newcommand{\connectpt}{\mbox{\sf connect\_pt}}

\newcommand{\IsRoot}{\mbox{\sf Is\_Root}}
\newcommand{\CRoot}{\mbox{\sf CRoot}}
\newcommand{\CParent}{\mbox{\sf CParent}}
\newcommand{\distConnect}{\mbox{\sf distConnect}}
\newcommand{\distNotConnect}{\mbox{\sf distNotConnect}}
\newcommand{\parentConnect}{\mbox{\sf parentConnect}}
\newcommand{\parentNotConnect}{\mbox{\sf parentNotConnect}}
\newcommand{\Better}{\mbox{\sf Better\_Path}}
\newcommand{\Ask}{\mbox{\sf Asked\_Connection}}
\newcommand{\ConnectS}{\mbox{\sf Connect\_Stab}}
\newcommand{\ConnectPtS}{\mbox{\sf Connect\_Pt\_Stab}}

\newcommand{\ARA}{}
\newcommand{\ARB}{}
\newcommand{\CRA}{}
\newcommand{\CRB}{}
\newcommand{\CRC}{}
\newcommand{\CRD}{}
\newcommand{\CRE}{}
\newcommand{\CRF}{}
\newcommand{\CRG}{}

\newcommand{\STT}{{\sc s3t}}

\newenvironment{lemma-repeat}[1]{\begin{trivlist}
\item[\hspace{\labelsep}{\bf\noindent Lemma~\ref{#1} }]}{\end{trivlist}}
\newcommand{\toto}{xxx}
\newenvironment{proofT}{\noindent{\bf
Proof }} {\hspace*{\fill}\par\vspace{3mm}}





\begin{document}
\title{A Superstabilizing -Approximation Algorithm for Dynamic Steiner Trees}

\author{
L\'{e}lia Blin 
\and
Maria Gradinariu Potop-Butucaru
\and
St\'{e}phane Rovedakis
}


\footnotetext[1]{Universit\'e d'Evry, IBISC, CNRS, France.}
\footnotetext[2]{Univ. Pierre \& Marie Curie - Paris 6, LIP6-CNRS UMR 7606, France.}
\footnotetext[3]{INRIA REGAL, France.}

\date{}


\maketitle

\begin{abstract}
In this paper we design and prove correct a fully dynamic distributed algorithm for maintaining an approximate Steiner 
 tree that connects via a minimum-weight spanning tree a 
subset of nodes of a network (referred as Steiner members or Steiner group) .
Steiner trees are good 
candidates to efficiently implement communication primitives such
as publish/subscribe or multicast, essential building blocks for the new
emergent networks (e.g. P2P, sensor or adhoc networks). 

The cost
of the solution returned by our algorithm is at most 
times the cost of an optimal solution, where  is the group of
members. Our algorithm improves over existing solutions in several
ways. First, it tolerates the dynamism of both the group members and
the network. Next, our algorithm is self-stabilizing, that is, it
copes with nodes memory
corruption. Last but not least, our algorithm is
\emph{superstabilizing}. 
That is, while converging to a correct
configuration (i.e., a Steiner tree) after a modification of the
network, it keeps offering the Steiner tree service during the
stabilization time to all members that have not been affected by
this modification.
\end{abstract}





\section{Introduction}

The design of efficient distributed applications in the newly distributed 
emergent networks such as MANETs, P2P or sensor networks raises 
various challenges ranging 
from models to fundamental services. These networks face frequent
churn (nodes and links creation or destruction) and various privacy
and security attacks that cannot be easily encapsulated in the
existing distributed models. 
Therefore, new models and new algorithms have to be designed. 

Communication services are the building blocks for any distributed
system and they have received a particular attention in the lately
years. Their efficiency greatly depends 
on the performances of the underlying routing overlay. 
These overlays should be optimized to reduce the network
overload. Moreover, in order 
to avoid security and privacy attacks the number of network nodes that
are used only for the overlay connectivity have to be minimized. Additionally, the overlays have to offer 
some quality of services while nodes or links fail.
  
The work in designing optimized communication overlays for the new emergent
networks has been conducted in both structured (DHT-based) and un-structured networks. 
Communication primitives using DHT-based schemes such as Pastry, CAN or Chord  \cite{CDCHR03} 
build upon a global naming scheme based on hashing nodes identifiers.
These schemes are optimized to efficiently route in the virtual name
space however they have weak energy performances in MANETs or
sensor networks where the maintenance of long links reduces the
network perennial. Therefore, alternative strategies \cite{KS07}, mostly based on
gossip techniques, 
have been recently considered. These schemes, highly 
efficient when nodes have no information on the content and the topology of the system,
offer only probabilistic guarantees on the message delivery.

In this paper we are interested in the study of overlays targeted 
to efficiently connect a group of nodes that are 
not necessarily located in the same geographical area (e.g. sensors that should communicate their 
sensed data to servers located outside the deployment area, P2P nodes that share the same 
interest and are located in different countries, robots that should 
participate to the same task but need to remotely coordinate). Steiner trees are good 
candidates to implement the above mentioned requirements since the problem have been 
designed for efficiently connect a subset of the network nodes, referred as Steiner members. 


\paragraph{The Steiner tree problem.}

The Steiner tree problem can be informally expressed as follows: 
given a weighted graph 
in which a subset  
of nodes 
is identified, 
find a minimum-weight tree spanning .
The Steiner tree problem is one of the most important 
combinatorial optimization problems and finding a Steiner tree is NP-hard. 






A survey on different heuristics for constructing Steiner trees with different competitiveness levels can be found
in \cite{thesis96,Steiner_survey}.
In our work we are interested in dynamic variants of Steiner trees
first addressed in \cite{ImaseWaxman91} in a centralized online setting.
They propose a -approximation algorithm for this problem that copes
only with Steiner member arrivals. This algorithm can be 
implemented in a decentralized environment (see~\cite{GataniRG05}).

Our work considers the fully dynamic version
of the problem where both Steiner members and ordinary nodes can join
or leave the system.
Additionally, our work aims at providing a 
superstabilizing approximation of a Steiner tree. 
The property of self-stabilization  \cite{Dij74,Dol00} enables a distributed
algorithm to recover from a transient fault regardless of its initial
state. The superstabilization \cite{Dolev_SuperStab} is an extension of the
self-stabilization property for dynamic settings. The idea is to
provide some minimal guarantees while the system repairs after a 
topology change.

To our knowledge there are only two self-stabilizing approximations of
Steiner trees
\cite{SS_Steiner02,Kakugawa_Steiner_journal}. Both works assume the 
shared memory model and an unfair centralized scheduler.
In \cite{SS_Steiner02} the authors propose a self-stabilizing
algorithm based on a pruned minimum spanning 
tree. 
The computed solution has a competitiveness of
 where  is the set of nodes in the network. 
In \cite{Kakugawa_Steiner_journal}, the authors proposed a
four-layered algorithm that builds upon the techniques 
proposed in \cite{WuWW86} in order to obtain a  approximation. 



The above cited algorithms work only for static networks. 


\paragraph{Our results.}

We describe a super-stabilizing algorithm for the Steiner tree problem. This algorithm has the following properties:
\begin{itemize}
\item First, it is distributed, i.e.,  completely decentralized. That is, nodes
locally self-organize in a Steiner tree. The cost of the constructed Steiner tree 
is at most  times the cost of an optimal solution, where  is the Steiner group. 
\item Second, our algorithm is specially designed to cope with user
dynamism. In other words, 
our solution withstand when nodes (or links) join and leave the system. 
\item Third, our algorithm includes self-stabilization policies. Starting from an arbitrary state (nodes local memory corruption, counter program corruption, or
erroneous messages in the network buffers), our algorithm is guaranteed to converge to a tree spanning the Steiner members. 
\item Fourth, our algorithm is \emph{superstabilizing}. That is, while
a topology change occurs, i.e., during the restabilization period,
 the algorithm offers the guarantee that only the subtree connected
through the crashed node/edge is reconstructed. 
\end{itemize}

\begin{table*}[!htb]
\begin{center}
\scalebox{1}
{
\begin{tabular}{|l|c|c|c|}
\hline
 & Approximation ratio & Self-Stabilizing & Superstabilizing \\
\hline
Chen et al. \cite{ChenHK93} & 2 & No & No \\
Kamei and Kakugawa \cite{SS_Steiner02} &  & Yes & No \\
Kamei and Kakugawa \cite{Kakugawa_Steiner_journal} &  & Yes & No \\
\hline
This paper &   & Yes & Yes \\
\hline
\end{tabular}
}
\caption{Distributed (deterministic) algorithms for the Steiner tree problem.}
\label{tableresume}
\end{center}
\end{table*}

Table~\ref{tableresume} summarizes our contribution compared to
previous works. Hence, our algorithm is the first superstabilizing
algorithm for the Steiner tree problem. Its approximation ratio is
logarithmic, which is not as good as the 2-approximation algorithm by
Kamei and Kakugawa in \cite{Kakugawa_Steiner_journal}. However, this
latter algorithm is not superstabilizing. Designing a superstabilizing
2-approximation algorithm for the Steiner tree problem is a
challenge. Indeed, all known 2-approximation distributed algorithms
(self-stabilizing or not) for the Steiner tree problem use a minimum
spanning tree (MST), and the design of a superstabilizing algorithm
for MST is a challenge by itself.



\section{Model and notations} 
\label{sec:model}
We consider an undirected weighted connected network  where
 is the set of nodes,  is the set of edges and  is a cost function. Nodes represent processors and edges
represent bidirectional communication links. Each node in the network
has an unique identifier. 
 defines the set of members we have to connect. For any pair of nodes , we note  the distance of the shortest path  between  and  in  (i.e. ). For a node , we denote the set of its neighbors . A Steiner tree,  in  is a connected acyclic sub-graph of  such that ,  and . We denote by  the cost of a tree , i.e. .



We consider an asynchronous communication message passing model with
FIFO channels (on each link messages are delivered in the same order as
they have been sent).

A {\it local state} of a node is the value of the local variables of
the node and the state of its program counter. 
We consider a fined-grained communication atomicity model \cite{BK07,Dol00}. That is,
each node maintains a local copy of the variables of its
neighbors. These variables are refreshed via special
messages (denoted in the sequel ) exchanged periodically 
by neighboring nodes.
A {\it configuration} of the
system is the cross product of the local states of all nodes in the
system plus the content of the communication links. 
The transition from a configuration to the next one is produced by the
execution of an atomic step at a node. An {\it atomic step} at node  
is an internal computation based on the
current value of 's local variables and a single communication
operation (send/receive) at . 
An {\it execution} of the system is an infinite sequence of
configurations, , where each
configuration  follows from  by the execution 
of a single atomic step.

In the sequel we consider the system can start in any
configuration. That is, the local state of a node can be corrupted.
Note that we don't make any assumption on the bound of
corrupted nodes. In the worst case all nodes in the system 
may start in a corrupted configuration.
In order to tackle these faults we use {\it self-stabilization} techniques.

Given  a non-empty
\emph{legitimacy predicate}\footnote{A legitimacy predicate is 
defined over the configurations of a system and 
is an indicator of its correct behavior.} 
an algorithm  is \emph{self-stabilizing} 
iff
the following two conditions hold:
\textsf{(i)} Every computation of  starting from a configuration
satisfying  preserves  (\emph{closure}).  
\textsf{(ii)} Every computation of  starting from an arbitrary configuration
contains a configuration that satisfies 
(\emph{convergence}).

A {\it legitimate configuration} for the Steiner Tree is a
configuration that provides an instance of a tree  spanning . 
Additionally, we expect a competitiveness of , 
i.e. , with  and  an optimal Steiner tree.

In the following we propose a self-stabilizing Steiner tree algorithm.
We expect our algorithm to be also {\it superstabilizing}
\cite{Dolev_SuperStab}. That is, 
given a class of topology changes  and a passage predicate, an algorithm 
is superstabilizing with respect to  iff it
is self-stabilizing, and for every
execution\footnote{\cite{Dolev_SuperStab} use the notion of trajectory
which is the execution of a system enriched with dynamic actions.}  beginning at a
legitimate state and containing a single topology change event of type
, the passage predicate holds for every configuration in .










In the following we propose a self-stabilizing Steiner tree algorithm and
extend it 
to a superstabilizing Steiner tree algorithm
that copes with the Steiner members and tree edges removal. During the tree
restabilization the algorithm verifies a passage predicate detailed below. 
Then, we discuss the extension of the algorithm to fully dynamic
settings (the add/removal of members, nodes or links join/leave). 
This second extension offers no guarantees during the restabilization period.


\section{The Superstabilizing Algorithm \STT}






The section describes a superstabilizing algorithm for the Steiner tree problem, called \STT.
It implements the
technique proposed by Imase and
Waxman~\cite{ImaseWaxman91},  in a stabilizing manner. That is, each Steiner member is connected
to the existing Steiner tree via a shortest path. Note that in a
stabilizing setting the initial configuration may be arbitrary hence
nodes have to perpetually verify the coherency of their state:
a Steiner member has to be connected to the Steiner
tree via a shortest path while a not Steiner node which does not
serve for the tree connectivity has to be recognized as disconnected.
In our implementation we assume a special node that acts as the root
of the Steiner tree. To this end, we assume an underlying overlay that elects a
leader within the Steiner group. That is, we assume a leader oracle that returns to every node
in the system its status: leader or follower. The leader of the system
is a node in the Steiner group. Note that the implementation of a
leader oracle is beyond the scope of the current work. Several
implementations fault-tolerant and self-stabilizing can be found in
\cite{DDF07}. Recently, algorithms that implement leader
oracles in dynamic settings are proposed in \cite{Baldoni08} for example.

\subsection{Detailed description}



\subsubsection{Variables and Predicates}

For any node ,  is the neighbors set of  in the network  (our algorithm is built upon an underlying self-stabilizing protocol that regularly updates the neighbor set of every node). We denote by  the unique network identifier of . Every node  maintains seven variables for constructing and maintaining a Steiner tree. Three of them are integers, and the others are booleans.

\begin{itemize}
\item :  of the parent of node  in the current tree;
\item : number of nodes on the path between the root and 
in spanning tree;
\item : the shortest distance to a node already connected to the current tree;
\item : \emph{true} if , \emph{false} otherwise (this is not a variable wrote by the algorithm but only read);
\item : \emph{true} if  or  has a descendant which is a member, \emph{false} otherwise;
\item : \emph{true} if  is in the current tree, \emph{false} otherwise;
\item : \emph{true} if  is a member or  has more than one children in the current tree, \emph{false} otherwise.
\end{itemize}

\begin{small}
\begin{figure*}
\scalebox{1}
{
\fbox{
\begin{minipage}{15.7cm}
\footnotesize{
\begin{description}
\item[] 
\item[]
\item[] 
\item[]
\item[]
\item[]
\item[]
\item[]
\item[]
\item[]
\end{description}
}
\end{minipage}
}
}
\caption{Predicates used by the algorithm.}
\label{fig:algo_predicates}
\end{figure*}
\end{small}

\subsubsection{Description of the algorithm}
\label{sec:algo}
Every node  sends periodically its local variables to each of its neighbors
using  messages. Upon the reception of this message a neighbor updates the local copy
of its neighbor variables. The description of a  message is
as follows:\\ 


Our algorithm is a four phase computation: (1)
first nodes update their distance to the existing Steiner tree, then (2) nodes
request connection (if they are members or they received a connection
demand), then (3) they establish the
connection, and finally (4) they update the state of the current Steiner tree.  These
phases have to be performed in the given order.
That is, a node cannot initiate a request for connection for example if it has not yet updated
its distance.



Note that if a node detects a
distance modification in its neighborhood, it can change its
connection to the current tree. Therefore a node  before computing any
other action must update its
distance to the current tree. 

Every node in the network, 
maintains a
parent link. The parent of a node is one of its neighbors having the shortest
distance to the current tree. Note that erroneous initial configurations may create cycles in the
parent link. To break these cycles, we 
use the notion of tree level, defined by the variable \level: 
the root has the level zero and each node has the level equal to its parent level plus one.


When a member tries to connect to the
tree, it sets its variable
\need\/ to \emph{true}. 
When a node in the current tree receives a
demand for connection, an acknowledgment is sent back along the
requesting path enabling every node along this path to set a variable \connect\/ to
\emph{true}. Nodes with \connect\/ set \emph{true} are called
``connected nodes''. 

Whenever a node detects an incoherency in its neighborhood it disconnects
from the current tree. 



In order to give a -approximate Steiner tree, we introduce a variable \connectpt. This variable
signals if a node is a connection point or not. A connection
point is a connected node which is a member or has more than one
connected child. 









\paragraph{\underline{Algorithm:}}
Upon the reception  of a  nodes correct their local state
via the rules explained below then broadcast their new local state in 
their local neighborhood.







\paragraph{\underline{Root:}}

In a coherent state the root has a distance and a level equal to zero,
variables  and  
are \emph{true} since the root is always connected (it always belongs to the Steiner tree). Variable  is \emph{true} because the root is a member so a connection point.
Whenever the state of the root is incoherent the Rule \CRA\/ below is enabled.
\begin{small}
\begin{description}
\item[\CRA: (Root reinitialization)]~\\\textbf{If}  \textbf{then}\\
\hspace*{0,8cm}   \\ 
\hspace*{0,8cm} 
\end{description}
\end{small}


\paragraph{\underline{Distance update:}} 

Rule \ARA\/ enables to a not connected node to compute its shortest path
distance to the Steiner tree 
as follows: Take the minimum between the edge weights with connected
neighbors and the distances 
with not connected neighbors. If a not connected node detects it has a
better 
shortest path (see Predicate ) then it updates its distance 
(using Predicates \distNotConnect\/ and \distConnect) and changes its
other variables accordingly. 

The same rule is used to reinitiate the state of a node if it observes that its parent is no more in its neighborhood.

Similarly, Rule \ARB\/ enables to a connected node to compute its
shortest path distance. In order to execute this rule 
a connected node must have a stabilized connection. The distance is
computed as for a not connected node but a connected node compares
this distance with its local distance towards its connection point and takes the minimum.




\begin{small}
\begin{description}
\item[\ARA : (Distance stabilization for not connected nodes)]~\\\textbf{If}  \textbf{then}\\ 
\hspace*{0,8cm} \\
\hspace*{0,8cm} 

\item[\ARB: (Distance stabilization for connected nodes)]~\\\textbf{If}  \textbf{then}\\ \hspace*{0,8cm} \\
\hspace*{0,8cm}
\end{description}
\end{small}
\paragraph{\underline{Request to join the tree:}}

Variable  is used by a not connected node to ask to its parent
a connection to the current Steiner tree. 
Since a member must be connected to the Steiner tree, each member sets
this variable to \emph{true} using Rule \CRB. 
A not member and not connected node which detects that a child wants
to be connected (see Predicate ) 
changes its variable  to \emph{true}. This connection request
is forwarded in the spanning 
tree until a not connected node neighbor of a connected node is
reached.

A not connected node sets its variable  to \emph{false} using
Rule \CRC\/ if it is not a member and it has no child requesting a
connection. 




\begin{small}
\begin{description}
\item[\CRB: (Nodes which need to be connected)]~\\\textbf{If} \\
\textbf{then} 
\item[\CRC: (Nodes which need not to be connected)]~\\\textbf{If}  \\
\textbf{then} 
\end{description}
\end{small}
\paragraph{\underline{Member connection:}}

When a not connected node neighbor of a connected node (i.e. which
belongs to the Steiner tree) detects a connection request from a child
(i.e. Predicate  is \emph{true}), an acknowledgment is sent
backward using variable  along the request path. Therefore
every not connected node 
on this path uses Rule \CRD\/ and sets  to \emph{true} until
the member that asked the connection is connected. Only a node that
has (1) no better path, 
(2) its variable  and (3) a connected parent can use Rule
\CRD.

A connected node becomes not connected if its connection path is no
more stabilized (i.e. Predicate  is false). Therefore, it
sets  to \emph{false} using Rule \CRE.

The parent distance is used for the disconnection of a subtree whenever a
fault occurs in the network. 
If a fault occurs (parent distance is infinity), a connected node in the subtree below a faulty node or edge in the spanning tree must be disconnected using Rule \CRG. So the node sets  to false and  to infinity and waits until all its subtree is disconnected (i.e. it has no connected child).




\begin{small}
\begin{description}
\item[\CRD: (Nodes which must be connected)]~\\\textbf{If} \\
\textbf{then} 
\item[\CRE: (Nodes which must not be connected)]~\\\textbf{If}  
\textbf{then} 
\item[\CRG: (Consequence of a deletion)]~\\
\textbf{If} 
\textbf{then}  \\
\hspace*{1,1cm} send  to all  and wait until (\\ \hspace*{1,2cm})



\end{description}
\end{small}
\paragraph{\underline{Update the Steiner tree:}}

Since we use shortest paths to connect members to the existing Steiner
tree, we must maintain distances from members to 
connection points. A connection point is a connected member or a connected node with more than one connected children, i.e. the root of the branch connecting a member. Every connected node updates its distance if it has a better path. So thanks to connection points and distance computation, we maintain a shortest path between a member and the Steiner tree in order to respect the construction in \cite{ImaseWaxman91}. Rule \CRF\/ is used by a connected node to change its variable  and to become or not a connection point. This rule is executed only if the connected node has a stabilized connection path (i.e. Predicate  is \emph{true}).


\begin{small}
\begin{description}
\item[\CRF: (Connected path stabilization)]~\\\textbf{If} \\ 
\textbf{then} \hspace*{0,1cm}\textbf{If}  \textbf{then}  \\ \hspace*{0,8cm}\textbf{Else} 
\end{description}
\end{small}

\section{Correctness and proof in Static setting}
\label{sec:correction}

\begin{definition}[Legitimate state of DST]
\label{def:legitimate_state}
A configuration of algorithm is legitimate iff each process  satisfies the following conditions:
\begin{enumerate}
\item a Steiner tree  spanning the set of members  is constructed;
\item a shortest path connects each member  to the existing tree.
\end{enumerate}
\end{definition}



\begin{lemma}
\label{lem:correct1}
Eventually the node's parent relation constructs a rooted spanning tree in the network.
\end{lemma}

\begin{proof}
Function  is a perfect oracle which returns true if 
is the root of the tree and false otherwise. So we assume that there
is a time after which only one root exists in the network. Moreover
Rule \CRA\/ is only used by the root to correct its corrupted variables.

Since there is only one root in the network, to have a spanning tree
we must show that each node has one parent and there is no
cycle. First note that each node  could have at each time only one
parent in its neighborhood (see predicate ) designed by
variable , only root has its parent equal to itself. Each
node maintains its level stored in variable  which is updated
by Rules \CRA\/, \ARA\/ and \ARB\/. The level of each node is equal to the level
of its parent plus one, except for the root which has a level at zero
(see Rule \CRA\/). Suppose there is a cycle in the node's parent
relation. This implies that there is a time after which we have a
sequence of nodes with a growing sequence of levels. But there is at
least one node  with a smaller level than its parent  in the
cycle. That is, for  we have  and for 
we have . So predicate
 is false for  and , thus  and  can execute Rule \ARA\/
to reset their variables and break the cycle. Therefore, there is a
time after which no cycle exists in the structure described by the
node's parent relation. Since there is only one root in the network
(i.e.  and ) and there is no cycle, thus the
node's parent relation describe one tree spanning the network.
\end{proof}


\begin{lemma}
\label{lem:correct1bis}
Eventually each non-connected node knows its distance to the current tree.
\end{lemma}

\begin{proof}
A node  is connected iff . There is at least one
connected node because the root is always connected (see Rule \CRA\/),
otherwise there is a time where the root corrects its variables using
Rule \CRA\/. According to Lemma \ref{lem:correct1}, a tree spanning the
network is constructed. Let  be a non-connected node,  the
distance of the shortest path from  to any connected node and 
the neighbor on this shortest path. Suppose , thus it
exists a time after which a neighbor offers a better path and  can
execute Rule \ARA\/ because predicate  is true. So 
corrects  as the minimum distance in its neighborhood (see
function ). Therefore there is a time after which
. Moreover, at each time  executes Rule \ARA\/ the variable
 is modified respectively to variable  (see function
) and thus  stores the neighbor of 
which offers to  the shortest path to any connected
node. Therefore, there is a time after which when we have 
then .
\end{proof}

\begin{lemma}
\label{lem:correct2}
Eventually each Steiner member is linked to root via a connected path.
\end{lemma}

\begin{proof}
A node  is connected iff . There is at least one
connected node because the root is always connected (see Rule \CRA\/),
otherwise there is a time where the root corrects its variables using
Rule \CRA\/. Moreover, according to lemma \ref{lem:correct1}, there is
only one root and a rooted tree spanning the network is
constructed. Thus it exists a path between each member and the root.

To prove the lemma, we first show that for each node  on the path
connecting a member we have .

Each node  (except the root) can change the value of its variable
 or  to true respectively with Rule \CRB\/ and \CRC\/
only when  has no neighbor with a lower distance than its parent
(i.e.  has no better path so \ARA\/ and \ARB\/ are not
executable). Otherwise  returns true and Rules \ARA\/ or
\ARB\/ are uppermost used to correct  and . So we
suppose that  returns false.

Note that for any member  we must have  otherwise 
executes Rule \CRB\/ to correct . Since there is a path from each
member  to the root, the parent  of a member will execute Rule
\CRB\/ because according to procedure ,  has at
least a child  s.t. . Thus  changes the value of
its variable  if necessary. Therefore one can show by
induction using the same scheme that for each node  on the path
between a member and the root we have .

Each node  (except the root) with  can correct
its variable  only when Rule \CRB\/ is not executable
(i.e. ) because predicate  and
Rule \CRD\/ can not be executed. Since the root  is always connected
(i.e. ), each child  of the root with
 and  can execute Rule \CRD\/ to change
the value of its variable  if necessary because predicate
 is satisfied. Thus one can show by induction that
for any node on the path between a member and the root we have
.
\end{proof}

\begin{lemma}
\label{lem:correct3}
Eventually  is true for every connected node  on the path between each member and the root in the network.
\end{lemma}

\begin{proof}
According to Lemma \ref{lem:correct2}, there is a time after which we have paths of connected nodes between members and the root. Note that in this case predicate  is true.

Suppose that  for a connected node  is false. If  is a member then this implies that  (see predicate ), so  can execute Rule \CRF\/ to change the value of  to true and we have . Otherwise, let  be the parent of a member  on the path of connected nodes connecting  to the root. This implies that  (see predicate ), so  can execute Rule \CRF\/ to update  and we have . Thus one can show by induction on the height of the tree that it exists a time where  is true for every connected node  on the path between each member and the root.
\end{proof}

\begin{lemma}
\label{lem:correct4}
Eventually each member is connected by a shortest path to the current tree.
\end{lemma}

\begin{proof}
Let  be the tree constructed by the algorithm before the
connection of the member . To prove the lemma, we must show that
for any member  we have a shortest path from  to 
when  and 
(i.e. Rule \ARB\/ can not be executed by a member and so there is no
better path to connect the member).

Initially, according to Rule \CRA\/ the root  is always connected and
we have  and
 (because ). We show by induction on
the number of members that the property is satisfied for each
member. At iteration , let  be a not connected member then
according to Lemma \ref{lem:correct1bis} the path  from  to
 in the spanning tree is a shortest path, so there is a time
s.t.  (see Lemma
\ref{lem:correct3}) since  is a shortest path between  and
 (i.e. ), we have , thus the
property is satisfied for . We suppose that the tree 
satisfies the desired property for every member . At
iteration , when member  is not connected, according to
Lemma \ref{lem:correct1bis} the path  from  to 
is a shortest path, so there is a time
s.t.  (see Lemma
\ref{lem:correct3}). Since  is a shortest path between
 and , we have  and the
property is satisfied for .

Note that a member  can create a connection point 
(i.e. ) on the path  connecting a
member . In this case, the property is still satisfied
for  because the path between  and  is part of  so
it is a shortest path since a subpath of a shortest path is a shortest
path. Moreover, when we have  for  then
all nodes on the path between  and  update their distance with
Rule \ARB\/ (see predicate ).
\end{proof}

\begin{lemma}
\label{lem:correct5}
Eventually a Steiner tree is constructed.
\end{lemma}

\begin{proof}
According respectively to Lemmas \ref{lem:correct1} and
\ref{lem:correct2} a spanning tree is constructed (i.e.  is also
spanned) and there is a path of connected nodes between each member
and the root. To prove the lemma we must show that every leaf of 
is a member.

Consider the connected node  (i.e.  and
), such that  is a leaf of . Since  is a
leaf, this implies that  has no connected child in , so
predicate  is false.\\ Suppose that  is not a
member. Thus  can execute Rule \CRC\/ and change the value of
 to false. As a consequence predicate 
is false and  can then execute Rule \CRE\/ which changes the value of
 to false. Therefore  is not connected and is no more
a leaf of . By using the same scheme we can show by induction on
the height of  that every node on a path of connected nodes which
contains no member nodes can not belong to  after a finite bounded
of time.\\ Now suppose that  is a member, the guard of Rule \CRC\/ is
not satisfied so  remains true. Since , predicate
 remains true too and  is maintained by the
algorithm as a leaf of .
\end{proof}

\begin{lemma}[Convergence]
\label{lem:convergence}
Starting from an illegitimate configuration eventually the algorithm reaches in a finite time a legitimate
configuration.
\end{lemma}

\begin{proof}
Let  be an illegitimate configuration, i.e. . According to Lemmas \ref{lem:correct1},
\ref{lem:correct4} and \ref{lem:correct5}, in a finite time a
legitimate state is reached for any process . Therefore in a
finite time a legitimate configuration is reached in the network.
\end{proof}

\begin{lemma}[Correction]
The set of legitimate configurations is closed.
\end{lemma}

\begin{proof}
According to the model,  messages are exchanged periodically
with the neighborhood by all nodes in the network, so 
messages maintain up to date copies of neighbor states. Thus starting
in a legitimate configuration the algorithm maintains a legitimate
configuration.
\end{proof}


\section{Correctness and proof in Dynamic setting}



In this section, we consider dynamic networks and we prove that topology changes can be correctly treated by extending our algorithm, given in Figure \ref{fig:algo_dynamic}. Moreover, we show that a passage predicate is satisfied during restabilizing execution of given algorithm.

In the following, we define the topology change events, noted , that we must consider:
\begin{itemize}
\item an add (resp. a removal) of a member  ( remains in the network) noted  (resp. );
\item an add (resp. a removal) of edge  in the network noted  (resp. );
\item an add (resp. a removal) of a neighbor node  of  in the network noted  (resp. ).
\end{itemize}



Algorithm given in Figure \ref{fig:algo_dynamic} completes the self-stabilizing algorithm described in precedent sections and allows to a node  to take into account topology change events.
\begin{small}
\begin{figure}[!ht]
\begin{center}
\fbox{
\begin{minipage}{11.7cm}
\begin{description}
\item[\underline{Do forever:}] send  to all 
\item[\underline{Upon receipt of  from :}]
use all the rules to correct the local state of  
send  to all 
\item[\underline{Interrupt Section:}]
\textbf{If}  is a  event or ( is a  or  event and ) \\ \textbf{then}
\hspace*{0.1cm}  \\
\hspace*{0.8cm}send  to all  
\hspace*{0.8cm}\textbf{wait until} 
\end{description}
\end{minipage}
}
\end{center}
\caption{Algorithm describing message exchanges and treatment of topology change events.}
\label{fig:algo_dynamic}
\end{figure}
\end{small}
In the sequel we suppose that after every topology change the network remains connected. We prove in the next subsection that algorithm of Figure \ref{fig:algo_dynamic} has a superstabilizing property.

\subsection{Correctness under restricted dynamism}

We provide below definitions of the topology change events class  and passage predicate for protocol given in Figure \ref{fig:algo_dynamic}.


\begin{definition}[Class  of topology change events]
  and  compose the class
  of topology change events.
\end{definition}

\begin{definition}[Passage predicate]
\label{def:passage_predicate}
Parent relations can be modified for nodes in the subtree connected by
the removed member, edge or node, and parent relations are not changed
for any other node in the tree.
\end{definition}





\begin{lemma}
\label{lem:dyn_suppression}
Starting from a legitimate configuration, if a
member  leaves the set of members  or node  or edge 
is removed from the network then each connected node  in the
subtree of  is disconnected from the tree and a legitimate
configuration is reached by the system.
\end{lemma}

\begin{proof}
According to the description of the complete algorithm, when a member  leaves the set of members  then  changes first its variables as following:  and , then  sends its state to its neighborhood and finally  waits until it has no connected child. In the same way, if a node  (resp. edge  (assume )) is removed from the network then each child  of  (resp. ) changes first its variables as following:  and  (resp.  and ), then  (resp. ) sends its state to its neighborhood and finally  (resp. ) waits until it has no connected child.

When a connected child  of  (resp. of ) receives message  from  (resp.  from ), since predicate  is false (because ) and  the node  executes Rule \CRG\/ changing the variables of  like 's or 's variables, sends its state to its neighborhood and waits until it has no connected child. According to Lemma \ref{lem:no_deadlock}, no node in the subtree of  executing Rule \CRG\/ perpetually waits it has no connected child. As a consequence, after a finite time every connected node  in the subtree of  is no more connected.

Since each node in the subtree of  is not connected, there is at least one of those nodes  such that predicate  is true. Thus  can execute Rule \ARA\/. According to Lemmas \ref{lem:correct1} and \ref{lem:correct1bis}, there is a time after which each node in the subtree of  knows its correct shortest path distance to a connected node. Moreover, by Lemmas \ref{lem:correct2} and \ref{lem:correct4} each not connected member will be connected by a shortest path to a connected node in the existing Steiner tree. Therefore, in a finite number of steps the system reaches a legitimate configuration .
\end{proof}

\begin{lemma}
\label{lem:2}
The proposed protocol is superstabilizing for the class  of
topology change events, and the passage predicate (Definition
\ref{def:passage_predicate}) continues to be satisfied while a
legitimate configuration is reached.
\end{lemma}

\begin{proof}
Consider a configuration . Suppose  is a removal of edge  from the network. If  is not a tree edge then the distances of  and  are not modified neither  nor  changes its parent, thus no parent relation is modified. Otherwise let , 's distance and 's parent are not modified, it is true for any other node not contained in the subtree of  since the distances are not modified (i.e. predicate  is not satisfied). However,  is no more a neighbor of  so according to the handling of an edge removal by the algorithm 's variables are reseted. Then  sends its state to its neighborhood and waits until it has no connected child. According to Lemma \ref{lem:dyn_suppression}, all its children will become not connected and eventually change their parent by executing Rule \ARA\/ because there is a better path (i.e. predicate  is satisfied). Therefore, only any node in the subtree connected by the edge  may change its parent relation.

Suppose  is a removal of node  from the network. Any node not contained in the subtree of  do not change its parent relation because the distances are not modified (i.e. predicate  is not satisfied). Consider each edge  between  and its child , we can apply the same argument described above for an edge removal. Therefore, only any node contained in the subtree connected by  may change its parent relation.
\end{proof}

A fault which occurs in the network is detected using a distance with an infinity value. To handle a fault, we introduce Rule \CRG\/ to bootstrap connected nodes in the subtree below a faulty node/edge. We show in Lemma \ref{lem:no_deadlock} that even Rule \CRG\/ is executed when no fault occurs in the network then no node perpetually waits (no deadlock) because of Rule \CRG.

\begin{lemma}
Starting from an arbitrary configuration, Rule \CRG\/ introduces no deadlock in the network.
\label{lem:no_deadlock}
\end{lemma}

\begin{proof}
Consider a configuration which simulates the presence of a fault in the network (but there is not really a fault) and allows the execution of Rule \CRG\/ by a node , i.e.  is a connected node and has a not connected parent  with . According to Rule \CRG,  becomes a not connected node and sets its distance to infinity (i.e.  and ), then it sends its state to its neighbors and waits until it has no connected child. There are two cases: (1)  has no connected child or (2)  has at least one connected child. In case (1),  is a leaf of the connected subtree and does not wait. Otherwise, in case (2) the subtree of connected nodes rooted in  has a finite height so we can show by induction that in a finite time every node in the subtree executes Rule \CRG\/. According to case (1), there is no deadlock for the leaves of the connected subtree. Therefore, we can show by induction on the height of the subtree rooted in  that after a finite time there is no connected node and  wakes up.
\end{proof}


\subsection*{Correctness under fully dynamism  assumptions}

In the precedent subsection guarantees are given on the conservation of the tree structure, only for removal topology events. Here, we consider all the different topology change events presented in Section \ref{sec:correction} (i.e. add/removal of members, nodes or edges). We must maintain a quality of service on the weight of the structure reserved to interconnect all members. Therefore, legitimate configurations take into account a global constraint on the Steiner tree weight. As a consequence, we can not give any guarantees on the tree structure during the stabilization of protocol defined by the presented rules and algorithm of Figure \ref{fig:algo_dynamic} (i.e. no passage predicate is satisfied) if an add of a member, node or edge arises in the network. However to maintain a quality of service on the structure weight, we show here that the protocol is able to restabilize when one of the previous mentioned topology change events arises in the network.

Lemma \ref{lem:dyn_suppression} proves that a legitimate configuration is reached starting from an arbitrary configuration if removal topology change events arises in the network. The following lemma considers add topology change events and shows that a legitimate configuration is reached too.

\begin{lemma}
\label{lem:dyn_ajout}
Starting from a legitimate configuration, after a
member add to  or a node or edge add in the network, eventually the
algorithm leads in a finite number of steps to a legitimate
configuration.
\end{lemma}

\begin{proof}
We must consider three cases: an edge add, a node add and the add of a path in the network.

Consider the add of an edge between two existing nodes  and 
with a weight . If predicate  is false for 
and  (i.e.  and ) then the system is still in a legitimate configuration . Otherwise  is true and Rule \ARA\/
(resp. \ARB\/) can be executed if  or  is not connected
(resp. connected) to correct its distance. In the same way, other tree
nodes  or  correct their distances, thus after a finite number
of steps the system reaches a legitimate configuration .

Consider the add of a node  to an existing node  by an edge
.  corrects its variables by executing Rule \ARA\/. If  is
not a member, variable  is corrected if necessary with Rule \CRC\/
otherwise according to Lemmas \ref{lem:correct2}, \ref{lem:correct3}
and \ref{lem:correct4}  is connected by a shortest path to the
existing tree, which leads the system to a legitimate configuration
.

Consider the add of a path . If  is a path between an existing
node  and a new node  then all nodes of  behave like the case
of a node add  to an existing node . Otherwise  is a path
between two existing nodes  and , all nodes of  behave like
the case of a node add to an existing node and  and  behave like
the case of an edge add if  offers a better path. Thus, in a finite
number of steps the system reaches a legitimate configuration .
\end{proof}

\section*{Complexity and Cost Issues}
\begin{theorem}
Using the notation of Theorem~\ref{theo1}, 
Algorithm \STT\/ performs in  rounds where 
 is the current diameter of the
network. It uses  bits of memory in
the send/receive model\footnote{In the classical message passing model
the memory complexity is }, where  is the current maximal degree of the
network.
\end{theorem}

\begin{proof}
We consider the worst case in which all the tree must be reconstructed
because of topological or member set modifications. Let
 be a tree constructed at some step  of the
algorithm. Our algorithm can be viewed as a special case of a shortest
path tree construction in which all nodes  are
considered as a single virtual root and all nodes 
computes the shortest distance from this virtual root. So we can show
by induction that the algorithm connects in at most  rounds the
nearest member to the tree . Initially when the root  is
stabilized and connected to ,  initiates a classic shortest
path computation. So after  rounds the algorithm connects the
nearest member to the root (we need at most  rounds to compute the
shortest path to the root and at most  rounds for the nodes on the
path to change their states from not connected to connected). We
assume that following the first  rounds  members are connected
to the tree . We prove that after  additional rounds 
members are connected. In at most  rounds all nodes  compute their shortest path to , in additional  rounds
all nodes on the path from the nearest member  to
 change their state to connected. So after  rounds 
members are connected in tree . Thus as  the
algorithm connects all members in at most  rounds.

In the following we analyze the memory complexity of our solution.
Each node maintains a constant number of 
local variables of size  bits. However, due 
to specificity of our model (the send/receive model) the memory 
complexity including the copies of the local neighborhood is
 where  is the maximal degree of the network.
\end{proof}


 Since we use the shortest distance metric between nodes in the network, any network can be represented by a complete graph so the following Lemma can be applied.

\begin{lemma}[Imase and Waxman \cite{ImaseWaxman91}]
\label{lem:ImaseWaxman91}
Let  be a complete graph with a cost function  satisfying the triangle inequality, and let  be any nonempty subset of  with . If  is the cost of an optimal tour for  and  satisfying the following conditions:
\begin{enumerate}
\item  for all nodes , and
\item  for all nodes ,
\end{enumerate}
then .
\end{lemma}

\begin{theorem}\label{theo1}
Let  be a dynamic network, and let  be a set of members. Algorithm \STT\/ is a superstabilizing algorithm that returns a steiner tree  for  satisfying
,  where  is an optimal Steiner tree for .
\end{theorem}

\begin{proof}
Let a set  of members, and . According to Lemmas \ref{lem:correct4} and \ref{lem:correct5}, when our algorithm completes each member  is connected in  by a shortest path to a node , such that  has been connected in  before . Let  the tree constructed by our algorithm before the connection of a member . As in \cite{ImaseWaxman91} (proof of theorem 2), if we let  for , then the cost of the path selected by the algorithm to connect  to  is less than or equal to . Let , so . Thus we have . Moreover for any pair of nodes , according to definition of function  we have  so (1) of lemma \ref{lem:ImaseWaxman91} holds. Note that a tour of set  can be constructed from a Steiner tree for  of cost of  such that the cost of the tour is no more than twice the cost of the Steiner tree. Since  for all , , (2) of lemma \ref{lem:ImaseWaxman91} holds and according to lemma \ref{lem:ImaseWaxman91} the theorem follows.

Since  is a dynamic set of member, we must consider two cases: the add of a member and the removal of a member. Consider the add of a new member  to . By Lemma \ref{lem:dyn_ajout}, the system reaches a legitimate configuration. Thus,  is connected by a shortest path to the existing Steiner tree and  is still satisfied. The same argument is true for the add of a node or an edge of the network. Consider the removal of a member  from . By Lemma \ref{lem:dyn_suppression}, the system reaches a legitimate configuration. Thus, each member  of  is connected by a shortest path to a connected member in the Steiner tree and  is satisfied again. The same argument is true for the removal of a node or an edge of the network. Therefore, considering a dynamic network  and a dynamic set of members the theorem is always satisfied.
\end{proof}

\section{Conclusion}

We propose a self-stabilizing algorithm for the Steiner tree problem, based on the heuristic proposed in \cite{ImaseWaxman91}, and achieves starting from any configuration a competitiveness of  in  rounds with  the number of members and  the diameter of the network. Additionally, we show that our algorithm works for dynamic networks in which a fault may occur on a node or edge. Moreover, we prove that if a fault occurs in a legitimate configuration our algorithm is superstabilizing and is able to satisfy a "passage predicate" about the tree structure.

For future works, it will be interesting to design a self-stabilizing algorithm in dynamic networks for the Steiner tree problem, which achieves a constant competitiveness of 2. For example, by using the self-stabilizing algorithm proposed in \cite{Kakugawa_Steiner_journal} and extending it for dynamic networks or by using another heuristic.

\bibliographystyle{alpha}
\bibliography{SS_Steiner_Bib}


\end{document}
