\documentclass{LMCS}

\usepackage{amssymb,amsmath,latexsym,enumerate,hyperref,proof}



\newcommand{\cal}{\mathcal}


\newcommand{\com}{\newcommand}

\newcommand{\bstart}[1]{\fl{\bf#1}}








\setlength{\unitlength}{1.0pt}







\newcommand{\irule}[2]
{}


\newcommand{\fl}{\noindent}
\newcommand{\hair}{\hspace{2mm}}
\newcommand{\vair}{\relax}
\newcommand{\bq}{\begin{quote}}
\newcommand{\eq}{\end{quote}}
\newcommand{\bc}{\begin{center}}
\newcommand{\ec}{\end{center}}
\newcommand{\bi}{\begin{itemize}}
\newcommand{\ei}{\end{itemize}}
\newcommand{\be}{\begin{enumerate}}
\newcommand{\ee}{\end{enumerate}}
\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}
\newcommand{\bd}{\begin{description}}
\newcommand{\ed}{\end{description}}
\newcommand{\bt}{\begin{tabular}}
\newcommand{\et}{\end{tabular}}
\newcommand{\bp}{\begin{program}\small}
\newcommand{\ep}{\end{program}}

\newcommand{\bdfn}{\begin{defi}}
\newcommand{\edfn}{\end{defi}}

\newcommand{\blem}{\begin{lem}}
\newcommand{\elem}{\end{lem}}

\newcommand{\bcor}{\begin{cor}}
\newcommand{\ecor}{\end{cor}}

\newcommand{\bprf}{\proof}

\newcommand{\eprf}{\qed}

\newcommand{\bthm}{\begin{thm}}
\newcommand{\ethm}{\end{thm}}

\newcommand{\ignoreIF}[1] {}

\newcommand{\ignorePROD}[1] {}

\newcommand{\ignoreBOOL}[1] {}

\newcommand{\nats} {{I\!\!N}}

\renewcommand{\int} {{\bf int}}
\newcommand{\bool}  {{\bf bool}}

\newcommand{\pgt}[1]{\tt#1}

\newcommand{\lsem}{\mbox{}}
\newcommand{\rsem}{\mbox{}}
\newcommand{\sempar}[1]{\mbox{\lsem\pgt{#1}\rsem}}
\newcommand{\semparlang}[2]{\sempar{#1}}

\newcommand{\runpgm}[2]{\mbox{\lsem\pgt{#1}\rsem}(\pgt{#2})}


\com{\deq}{{\downarrow}{\raisebox{1ex}{\!\rmfamily\hspace{-0.8ex}\scriptsize=}}}
\com{\deqsm}{\downarrow{}^{\hspace{-1.1ex}=}} 

\newcommand{\programenvironment}{\programmode \def\par{\leavevmode\endgraf}\obeylines\nobreak \programmode}
\newcommand{\programinfig}{\parindent 0em
	 \nobreak\programenvironment}
\newcommand{\programmode}{\tt \catcode`\_=12 \catcode`\?=12 \catcode`\.=12 \catcode`\,=12
	\catcode`\;=12 \catcode`\:=12 \catcode`\@=12 \catcode`\~=12
        \catcode`\#=12 \catcode`\&=12      \obeyspaces\frenchspacing}

\newenvironment{programintext}{\programenvironment}{}

\newenvironment{program}{\setlength{\partopsep}{0mm}\setlength{\topsep}{0mm}
	\begin{trivlist}\item[]
\hspace*{5mm}\begin{minipage}{1.0\textwidth}
\vspace{1mm}
	\begin{programintext}
	}{\end{programintext}
	\vspace{1mm}
	\end{minipage}
	\end{trivlist}
	\noindent}



{\catcode`\^^I=\active \obeyspaces\global\def^^I{ }}
{\obeyspaces\global\let =\ } {\catcode`\`=\active \gdef`{\relax\lq}}








\def\doframeit#1{\vbox{\hrule height\fboxrule
    \hbox{\vrule width\fboxrule \kern\fboxsep
      \vbox{\kern\fboxsep #1\kern\fboxsep }\kern\fboxsep \vrule width\fboxrule }\hrule height\fboxrule }}



\def\frameit{\smallskip \advance \linewidth by -7.5pt \setbox0=\vbox \bgroup
\strut \ignorespaces }

\def\endframeit{\ifhmode \par \nointerlineskip \fi \egroup
\doframeit{\box0}}




\theoremstyle{definition}\newtheorem{env}[thm]{Environment}


\newcounter{figur}
\newsavebox{\fighack}


\newenvironment{fig}[3]
{
\refstepcounter{figur}
\label{#3}
\sbox{\fighack}{{\it Figure \ref{#3}: #1}}
\begin{figure*}[#2]
\begin{frameit}
\hspace*{3mm}\begin{minipage}{0.95\textwidth}}{\end{minipage}            
\end{frameit}                                    
\usebox{\fighack} 
\end{figure*}}

\newenvironment{fig0}[3]
{
\refstepcounter{figur}
\label{#3}
\sbox{\fighack}{{\it Figure \ref{#3}: #1}}
\begin{figure}[#2]
\hspace*{0.02\textwidth}\begin{minipage}{0.98\textwidth}}{\end{minipage} 
\usebox{\fighack}\end{figure}}



\def\verbatim{\small \@verbatim \frenchspacing\@vobeyspaces \@xverbatim}
\let\endverbatim=\endtrivlist


\newcommand{\tosub}[1]{\raisebox{-6.0pt}{}}
			






\setcounter{tocdepth}{3}

\def\doi{4 (1:3) 2008}
\lmcsheading {\doi}
{1--39}
{}
{}
{Jul.~\phantom{0}5, 2007}
{Mar.~14, 2008}
{}   

\begin{document}


\title{Call-by-value Termination in the Untyped -calculus}

\author[N.~D.~Jones]{Neil D.~Jones\rsuper a}
\address{{\lsuper a}DIKU, University of Copenhagen, Denmark}
\email{neil@diku.dk}

\author[N.~Bohr]{Nina Bohr\rsuper b}
\address{{\lsuper b}IT-University of Copenhagen, Denmark}
\email{nina@itu.dk}

\keywords{Program analysis, Termination analysis, Untyped Lambda
  calculus, The Size-Change Principle} \subjclass{F.3.2, D.3.1}



\begin{abstract}
A fully-automated algorithm is developed able to show that evaluation
of a given untyped -expression will terminate under CBV
(call-by-value).  The ``size-change principle'' from first-order
programs is extended to arbitrary untyped -expressions in two
steps.  The first step suffices to show CBV termination of a single,
stand-alone -expression. The second suffices to show CBV
termination of any member of a regular set of -expressions,
defined by a tree grammar.  (A simple example is a minimum function,
when applied to arbitrary Church numerals.)  The algorithm is sound
and proven so in this paper. The Halting Problem's undecidability
implies that any sound algorithm is necessarily incomplete: some
-expressions may in fact terminate under CBV evaluation, but
not be recognised as terminating.

The intensional power of the termination algorithm is reasonably
high. It certifies as terminating many interesting and useful general
recursive algorithms including programs with mutual recursion and
parameter exchanges, and Colson's ``minimum'' algorithm.  Further, our
type-free approach allows use of the Y combinator, and so can identify
as terminating a substantial subset of PCF.

\end{abstract}

\maketitle
\bigskip
\bigskip

\tableofcontents\newpage

\section{Introduction}

\noindent The {\em size-change} analysis by Lee, Jones and Ben-Amram
\cite{popl01} can show termination of programs whose parameter values
have a well-founded size order.  The method is reasonably general,
easily automated, and does not require human invention of lexical or
other parameter orders.  It applies to first-order functional
programs. This paper applies similar ideas to termination of {\em
higher-order} programs. For simplicity and generality we focus on the
simplest such language, the -calculus.


\subsection*{Contribution of this paper}

Article \cite{rta} (prepared for an invited conference lecture) showed
how to lift the methods of \cite{popl01} to show termination of closed
-expressions.  The current paper is a journal version of
\cite{rta}. It extends \cite{rta} to deal not only with a single
-expression in isolation, but with a regular set of
-expressions generated by a finite tree grammar.  For
example, we can show that a -expression terminates when
applied to Church numerals, even though it may fail to terminate on
all possible arguments.  This paper includes a number of examples
showing its analytical power, including programs with primitive
recursion, mutual recursion and parameter exchanges, and Colson's
``minimum'' algorithm.  Further, examples show that our type-free
approach allows free use of the Y combinator, and so can identify as
terminating a substantial subset of PCF.

\subsection{Related work}

Jones \cite{Jones:FALambda} was an early paper on control-flow analysis of the untyped -calculus.
Shivers' thesis and subsequent work  \cite{shivers1991,shivers2004} on CFA (control flow analysis) 
developed this approach considerably further and applied it to the Scheme
programming language. This line is
closely related to the approximate semantics (static control graph) 
of Section \ref{sec-abstract-interpretation-for-cfg}
 \cite{Jones:FALambda}.


\subsubsection*{Termination of untyped programs} 

Papers based on \cite{popl01} have used size-change graphs to 
find bounds on program running times 
(Frederiksen and Jones \cite{frederiksen-jones}); solved related problems, e.g., to ensure that 
partial evaluation will
terminate  (Glenstrup and Jones, Lee \cite{glenstrup-jones,lee-ptime-bta}); and
found more efficient (though less precise)
algorithms (Lee \cite{lee-poly-time-analysis}).
Further, Lee's thesis  \cite{lee-thesis} extends the first-order size-change method  
\cite{popl01} to handle higher-order named combinator programs.
It uses a different approach than ours, and appears to be less general.

We had anticipated from the start that our framework could
naturally be extended to higher-order functional programs, 
e.g., functional subsets of Scheme or ML. This has since been 
confirmed by Sereni and Jones, first reported in  \cite{serenijones}.
Sereni's Ph.D.\ thesis  \cite{sereni} develops this direction in considerably more detail
with full proofs, and also investigates problems with lazy (call-by-name) languages. 
Independently and a bit later, Giesl and coauthors have addressed the analysis of 
the lazy functional language Haskell \cite{haskell}.




\subsubsection*{Termination of typed -calculi} 

Quite a few people have written  about termination based on types. 
Various subsets of the
-calculus, in particular subsets typable by various 
disciplines,  have been proven
strongly normalising. 
Work in this direction includes 
pathbreaking results by Tait  \cite{tait} and others
concerning simple types,
and
Girard's System F  \cite{girard}.
Abel, Barthe and others have done newer type-based approaches to show termination
of a -calculus extended with recursive data types \cite{abel,abelthesis,barthe}. 



{\em Typed functional languages:}
Xi's Ph.D.\ research focused on tracing value flow via data types
for termination verification 
in higher order programming languages  \cite{xi}, 
Wahlstedt has an approach to combine size-change termination 
analysis with constructive type theory
\cite{wahlstedt, wahlstedt1}. 



{\em Term rewriting systems:}
The popular ``dependency pair'' method was developed
 by Arts  and Giesl \cite{giesl-arts} for first-order programs in TRS form.
This community has begun to study termination  of
higher order 
term rewriting systems, including research by 
Giesl et.al.\ \cite{giesl-thiemann,haskell},
Toyama \cite{toyama} and others.

\section{The call-by-value -calculus}

First, we review relevant definitions and results for the
call-by-value -calculus, and then provide an observable
characterisation of the behavior of a nonterminating expression.

\subsection{Classical semantics}
\label{classical-semantics}

\bdfn
\label{def-syntax}
  {\it Exp} is the set of all -expressions that can be 
formed by these syntax rules, where {\tt @} 
is the {\em application operator} (sometimes omitted). We 
 use the {\tt teletype} font for -expressions.
\vair

{\tt 
\bt{lcl}
e, P &\ ::=\ &\  x | e @ e | x.e\\
x &\ ::=\ &\  {\rm Variable name}
\et}
\be[]
\item 
The set of {\em free variables}  is defined as usual: , 
 
and 
.
 A {\it closed}  -expression {\tt e} satisfies 
.

\item
A {\em program}, usually 
denoted by {\tt P},  is any closed -expression. 

\item The set of {\em subexpressions} of a 
-expression {\tt e} is denoted by .
\ee
\edfn

The following is standard, e.g., \cite{plotkin}. Notation: 
-reduction is done by substituting 
 for all free occurrences of {\tt x} in {\tt e},
written
,  and renaming 
-bound variables if needed to avoid 
capture.

\bdfn \label{def-call-by-value-evaluation}
{\rm (Call-by-value semantics)}
The {\em call-by-value evaluation relation}  is defined by the 
following inference rules, with judgement form 
where  is a closed -expression and .
{\it ValueS} (for ``standard value'') is the set of all abstractions 
. \medskip


\edfn
\bigskip

\blem\label{lem-determinism}
{\rm(Determinism)} If  and   then .
\elem



\subsection{Nontermination is sequential} 
\label{sec-making-nontermination-visible}

A proof of  is a finite object, and no such proof
exists if the evaluation of  fails to terminate.  Thus in
order to be able to trace an arbitrary computation, terminating or
not, we introduce a new ``calls'' relation , in
order to make nontermination visible.\nobreak

\subsubsection*{The ``calls'' relation}

The rationale is straightforward:  if in order to
deduce  for some value , it is necessary first
to deduce  for some , i.e., some inference
rule has form \irule{}{}.  Applying this to Definition
\ref{def-call-by-value-evaluation} gives the following.\break

\bdfn \label{def-evaluation-and-call} {\rm (Evaluation and call semantics)} 
The {\em evaluation 
and call relations}   
are defined by the following inference rules, where
\footnote{Naming:  in 
 are the last letters of {\em operato{\bf r}} 
and {\em 
operan{\bf d}}, and  in  stands for ``call''. }.
\medskip





\edfn
\bigskip

\fl 
For convenience we will sometimes 
combine the three into a single {\em call relation} 
.
As usual, we write  for the transitive closure of , and 
  for its reflexive transitive closure. 
We will sometimes write  to mean  for some , and  write  to mean 
there is no  such that , i.e., if evaluation of  does not terminate.



\subsubsection*{A small improvement to the operational semantics} 

Note
that rules (Call)
and (Apply) from Definition \ref{def-evaluation-and-call} overlap:
 appears in both, as does
. Thus (Call) can be used 
as an intermediate step 
to simplify (Apply), giving a more orthogonal set of  rules. 
Variations on the following  
combined set will be used in the rest of the paper:

\bdfn \label{def-evaluate-and-call-relation}
(Combined evaluate and call rules, standard semantics)
\medskip




\edfn
\smallskip

\fl The {\em call tree} of program {\tt P} is the smallest set of
 expressions  containing {\tt P} that is closed under  .  It
 is not necessarily finite.


\blem \label{lem-NIS-standard} {\rm (}NIS, or {\bf\underline N}ontermination 
{\bf\underline I}s 
{\bf\underline S}equential{\rm )} 
Let {\tt P} be a program. 
Then   if and only  if  has no infinite call chain starting with :

\elem

\fl{\em Example:} evaluation of expression
 
yields an infinite call chain:

By the NIS Lemma all nonterminating computations
give rise to   {\em infinite linear call chains}.
Such call chains need not, however, be repetitive as in this example, 
or even finite. 


Informally  
implies existence of an infinite call chain as follows:
Try to build,  
bottom-up and left-to-right,  a 
proof tree for .
Since call-by-value evaluation cannot ``get stuck''
this process will continue infinitely, leading to an infinite call chain.
Figure \ref{fig-NIS-behavior} shows 
such a call tree with infinite path starting with , 
where .
The Appendix contains a formal proof. 



\begin{fig}{Nontermination implies existence of an infinite call chain}{bth}{fig-NIS-behavior}




\fl{\tt    \setlength{\unitlength}{1.5pt}
\begin{picture}(530,200)(0,-10)
\thinlines
	      
              \put(150,148){\vector(-1,1){30}}


	      
              \put(150,103){\vector(-1,1){30}}
              \put(130,163){\line(-1,0){20}}
              \put(120,133){\line(-1,3){10}}
              \put(120,133){\line(1,3){10}}
	      
              \put(110,58){\vector(-1,1){30}}
              \put(90,118){\line(-1,0){20}}
              \put(80,88){\line(-1,3){10}}
              \put(80,88){\line(1,3){10}}
	      
              \put(110,58){\vector(0,1){30}}
              \put(120,118){\line(-1,0){20}}
              \put(110,88){\line(-1,3){10}}
              \put(110,88){\line(1,3){10}}
	      
              \put(70,13){\vector(-1,1){30}}
              \put(50,73){\line(-1,0){20}}
              \put(110,88){\line(-1,3){10}}
              \put(40,43){\line(1,3){10}}
	      
              \put(70,13){\vector(-1,1){30}}
              \put(50,73){\line(-1,0){20}}
              \put(40,43){\line(-1,3){10}}
              \put(40,43){\line(1,3){10}}
	      
              \put(70,13){\vector(0,1){30}}
              \put(80,73){\line(-1,0){20}}
              \put(70,43){\line(-1,3){10}}
              \put(70,43){\line(1,3){10}}


\thicklines
	      
              \put(140,135){
}
              \put(140,160){\Large }
	      
              \put(140,90){}
              \put(150,103){\vector(0,1){27}}
              \put(151,103){\vector(0,1){27}}
              \put(125,115){\Large \hspace{7mm}}
	      
              \put(100,45){}
              \put(110,58){\vector(1,1){25}}
              \put(110,59){\vector(1,1){25}}
              \put(85,70){\Large \hspace{7mm}\hspace{10mm}}
	      
              \put(60,0){
\hspace{14mm}{\it{\small Code:  = ``Operato{\bf r}'', = ``Operan{\bf d}'',  
  = ``{\bf c}all''.}}}
              \put(70,13){\vector(1,1){25}}
              \put(70,14){\vector(1,1){25}}
              \put(45,25){\Large \hspace{7mm}\hspace{10mm}}
	      
              \put(150,147){\vector(-1,1){30}}
              \put(150,148){\vector(-1,1){30}}
              \put(118,183){}
	      
	      
\end{picture}}



\end{fig}



\section{An approach to termination analysis}


 The ``size-change termination'' analysis of  Lee, Jones and Ben-Amram \cite{popl01} is based on 
several concepts,  including:
\be[(1)]
\item\label{chal-identifying-nontermination}
Identifying nontermination as caused by 
{\em infinitely long sequential state transitions}.

\item\label{chal-control-points} 
A fixed set of {\em program control points}.

\item\label{chal-observable-decreases}
{\em Observable decreases} in data value sizes.

\item\label{chal-construct-size-change-graph}
{\em  Construction} of  one size-change graph for each 
 function call.

\item\label{chal-control-flow-graph}
Finding the program's  {\em control flow graph}, and the 
call sequences that follow it.

\ee


\fl The NIS Lemma establishes point \ref{chal-identifying-nontermination}. However, concepts 
\ref{chal-control-points},
\ref{chal-observable-decreases},
\ref{chal-construct-size-change-graph} and
\ref{chal-control-flow-graph}
all seem a priori absent from the 
-calculus, 
except that an application must be a call; and even then, 
it is not a priori clear {\em which} function is being called. 
We will show, one step at a time, that all the concepts do in fact 
exist in call-by-value  -calculus evaluation.


\subsection{An environment-based semantics}
\label{sec-environment-based-semantics}

Program flow analysis usually requires evident 
program control points.
An alternate environment-based formulation remedies their absence in the -calculus. 
The ideas were formalised  
by Plotkin \cite{plotkin},
and have  long been used in implementations 
of functional programming language such as
{\sc scheme} and {\sc ml}.


 

\bdfn \label{def-environment-etc} {\rm (States, etc.)} 
Define {\it State}, {\it Value}, {\it Env} to be the smallest 
sets such that
\vspace{1mm}

\bt{lccclr}

{\it State} &&   
&& &\\

{\it Value} &&   
&& &\\

{\it Env} &&  
&& &
\et
\vair

Equality of states is defined by:



\fl
The empty environment with  domain  is written . 
The environment-based evaluation judgement form is 
 where . 
\edfn



\fl The Plotkin-style rules  follow the pattern of Definition 
\ref{classical-semantics}, except that 
substitution (-reduction) 
 of the (CallS) rule is replaced 
by a ``lazy 
substitution'' that just updates the environment in the new (Call) rule.
Further, variable values are fetched from the environment



\bdfn \label{def-environment-evaluation} {\rm (Environment-based
evaluation semantics)} The evaluation relation  is
defined by the following inference rules.
\bigskip





\smallskip



\subsection{States are tree structures}

A state has form  as in Definition 
\ref{def-environment-etc} where  binds the free variables of 
{\tt e} to values, which are themselves states. 
Consider, for two examples,  these two states
\medskip

{\tt
\bt{lclcl}
 &  & {\tt e}: &  & r@(r@a): \\\\
 &  & {\tt e}: &  & r@(r@a): \\
\et
}
\medskip

\fl(written in our usual linear notation
and using the standard Church numerals 
. For brevity details of the successor 
function {\tt succ} are omitted.
It is straightforward to verify  that 
 and
 by Definition \ref{def-environment-evaluation}.


More generally, each value bound in an environment is a state in turn, so in full 
detail a state's structure  is 
a {\em finite tree}. (The levels of this tree represent variable 
bindings, not to be confused with the syntactic or subexpression
tree structures from 
Figure \ref{fig-ex-call relation}.)

\begin{fig0}{Structures of two states . Each state is  a finite tree.}{htb}{fig-state-as-tree}


{\tt    \setlength{\unitlength}{0.8pt}
\begin{picture}(292,160)(-10,60)
\thicklines    
              \put(-15,70){\framebox(155,95){}}

              \put(27,154){}
              \put(-3,131){
}
              \put(75,130){\vector(1,-1){30}}
              \put(75,130){\vector(-1,-1){30}}
              \put(47,112){{\tt r}}
              \put(94,112){{\tt a}}
              \put(25,85){{\tt succ:[]}}
              \put(100,85){{\tt \underline{2}:[]}}


\end{picture}}
{\tt    \setlength{\unitlength}{0.8pt}
\begin{picture}(292,160)(250,20)
\thicklines 
              \put(130,30){\framebox(210,142){}} 
	      
              \put(207,156){}  

              \put(185,131){}
              \put(255,130){\vector(1,-1){30}}
              \put(255,130){\vector(-1,-1){30}}
              \put(228,112){{\tt r}}
              \put(274,112){{\tt a}}
              \put(150,85){{\tt a.r@(r@a):[]}}
              \put(280,85){{\tt {\underline{2}}:[]}}

              \put(239,85){\vector(0,-1){30}}
              \put(227,67){{\tt r}}

              \put(220,41){{\tt succ}:[]}


\end{picture}}

\end{fig0}

\noindent Figure \ref{fig-state-as-tree} shows the structure of these two states, with abbreviations for  Church numerals such as
.

\medskip

\edfn

\fl 


\subsection{Nontermination made visible in an environment-based semantics}

Straightforwardly adapting the approach of 
Section \ref{sec-making-nontermination-visible}.
gives  the following  set of inference rules, variations on which will be used in the rest of the paper:

\bdfn \label{def-evaluate-and-call-relation-environment}
(Combined evaluate and call rules, environment semantics)
\bigskip







\edfn
\bigskip

\noindent The following is proven in the same way as Lemma  \ref{lem-NIS-standard}.

\blem \label{lem-NIS-environment} {\rm (}NIS, or {\bf\underline N}ontermination 
{\bf\underline I}s 
{\bf\underline S}equential{\rm )} 
Let {\tt P} be a program. 
Then   if and only if  has no infinite call chain staring with 
(where ):

\elem
\medskip

Following the lines of Plotkin \cite{plotkin}, the environment-based semantics is 
shown equivalent to the usual semantics in 
the sense that they have the same termination behaviour. Further, 
when evaluation terminates the computed values are related by function
 defined by


\vair
\blem\label{lem-equivalent-semantics} 
 (by Definition \ref{def-environment-evaluation}) 
implies
  (by Definition \ref{def-evaluate-and-call-relation}), and\\
 implies there exists  such that   and .
\elem 

\medskip


\fl{\em Example:} evaluation of closed 
 
yields an infinite call chain:

where \hair and \hair
	      .	      







\subsection{A control point is a subexpression of a -expression}

The following {\em subexpression property} 
does not hold for the classical rewriting -calculus 
semantics, but does hold for Plotkin-style environment semantics of 
Definition \ref{def-environment-evaluation}. It is central to our program 
analysis: A {\em control point} will be a
subexpression of the program {\tt P} being analysed, and our analyses will trace 
program information flow to and from subexpressions of {\tt P}.


\blem \label{lem-prog-subexpression}
If 
 then 
. {\rm [Recall Definition \ref{def-syntax}.]}
\elem
This is proven as follows, using a more general inductive hypothesis.

\bdfn The {\em expression support} of a given state  is
 , defined by

\edfn

\blem \label{lem-subexpression} 
{\rm (Subexpression property)} If  or  then
. 
\elem


\bprf 
This follows by induction on the proof of 
  or . Lemma \ref{lem-prog-subexpression} is 
 an immediate corollary.


Base cases:  and  
 are immediate.
 For rule (Call)  suppose 
  and
 . By induction

Thus


\medskip

\fl For rule (Apply) we have 
.  The cases (Operator), (Operand) are immediate.
  \eprf





\subsection{Finitely describing a program's  computation space }
\label{sec-lambda-lacks}

A standard approach to program analysis is to trace data flow along the arcs of 
 the program's  {\em dynamic control graph} or DCG. In our case this is  the call relation  of
Definition \ref{def-evaluate-and-call-relation}.
Unfortunately the DCG may be infinite, so for program analysis we will 
instead compute a 
safe finite approximation called the SCG, for  {\em static control graph}. 



\begin{exa}


Figure \ref{fig-ex-call relation} shows the combinator  
 as a 
syntax tree whose  subexpressions are labeled by numbers. To its right is the ``calls'' 
relation . It has an infinite call chain:

Using subexpression numbers, the loop is

where \hair and \hair
	      .	      
The  set of states reachable from  is 
finite, so this computation is in fact a ``repetitive loop.'' 
(It is also possible that
a computation will reach infinitely many  states that are all 
different.)
\end{exa}
\bigskip

\begin{fig}{The DCG or dynamic control graph of a -expression}{htb}{fig-ex-call relation}

    \fl{\tt    \setlength{\unitlength}{0.92pt}
\begin{picture}(530,140)(60,40)
\thicklines

              \put(70,170){{\rm-expression} }

              \put(95,150){1 @}
              \put(111,153){\circle{15}}
              \put(107,145){\vector(-1,-1){15}}
              \put(115,145){\vector(1,-1){15}}
	      
              \put(70,120){2 x}
              \put(88,123){\circle{15}}
              \put(89,114){\vector(0,-1){12}}
	      
              \put(120,120){6 y}
              \put(138,123){\circle{15}}
              \put(139,114){\vector(0,-1){12}}
	      
              \put(74,90){3 @}
              \put(89,93){\circle{15}}
              \put(85,85){\vector(-1,-2){7}}
              \put(93,85){\vector(1,-2){7}}
	      
              \put(60,60){4 x}
              \put(74,63){\circle{15}}
	      
              \put(85,60){5 x}
              \put(99,63){\circle{15}}
	      
              \put(124,90){7 @}
              \put(138,93){\circle{15}}
              \put(134,85){\vector(-1,-2){7}}
              \put(142,85){\vector(1,-2){7}}
	      
              \put(110,60){8 y}
              \put(124,63){\circle{15}}
	      
              \put(135,60){9 y}
              \put(149,63){\circle{15}}
	      
	      
              \put(200,170){{\bf\em The ``calls'' relation} }
	      
              \put(200,80){1}
              \put(210,83){\circle{20}}
              \put(223,83){\vector(1,0){70}}
              \put(255,75){}
              \put(221,89){\vector(1,1){17}}
              \put(229,110){}
              \put(216,92){\vector(1,2){23}}
              \put(230,90){}
	      
              \put(240,110){6}
              \put(250,113){\circle{20}}
	      
              \put(240,140){2}
              \put(250,143){\circle{20}}
	      
              \put(299,80){3}
              \put(310,83){\circle{24}}
              \put(323,83){\vector(1,0){73}}
              \put(355,75){}
              \put(322,90){\vector(1,1){15}}
              \put(330,110){}
              \put(319,94){\vector(1,2){20}}
              \put(330,90){}
	      
              \put(340,110){5}
              \put(350,113){\circle{24}}
	      
              \put(340,140){4}
              \put(350,143){\circle{24}}
	      
              \put(399,80){7}
              \put(410,83){\circle{24}}
              \put(422,90){\vector(1,1){15}}
              \put(430,110){}
              \put(419,94){\vector(1,2){20}}
              \put(430,92){}
              \put(432,83){\circle{15}}
              \put(425,78){\vector(-1,1){3}}
              \put(440,80){}
	      
              \put(440,110){9}
              \put(450,113){\circle{24}}
	      
              \put(440,140){8}
              \put(450,143){\circle{24}}
	      
	      
              \put(200,50){{\rm where \hair
	      \hair and \hair
	      }}
\end{picture}}

\end{fig}



\fl By the NIS Lemma \ref{lem-NIS-environment}, 
if   then there  exists
an infinite call chain


\fl By Lemma \ref{lem-subexpression}, 
 for each . 
Our termination-detecting algorithm will focus on the {\em size relations 
between consecutive environments}  and  in this chain.
Since  is a finite set,  at least 
one subexpression {\tt e} occurs 
infinitely often, so ``self-loops'' will be of particular 
interest.



Since all states have an expression component lying in a set of fixed 
size, 
and each expression in the environment also lies in this finite set,
in an infinite state set 
there will be states whose {\em environment depths} are arbitrarily large.



\subsection{Static control flow graphs for -expressions} 
\label{sec-abstract-interpretation-for-cfg}

The end goal, given program {\tt P}, is implied by the NIS Lemma 
\ref{lem-NIS-environment}:
correctly to assert the 
nonexistence of any infinite call chain starting at .
By  the Subexpression Lemma 
\ref{lem-subexpression} an  infinite  call chain 

can only contain  
finitely many different expression components .
A static control flow graph (SCG for short) including all expression components can be
obtained by abstract interpretation
 of the ``Calls'' and  ``Evaluates-to'' relations
  (Cousot and Cousot  \cite{CousotCousot}). 
  Figure \ref{fig-control-flow-graph} shows a SCG for .
  
  \begin{fig}{The SCG or static control graph of a -expression}{htb}
	       {fig-control-flow-graph}

    \fl{\tt    \setlength{\unitlength}{0.92pt}
\begin{picture}(530,140)(60,40)
\thicklines

              \put(80,170){{\bf-expression} }

              \put(95,150){1 @}
              \put(111,153){\circle{15}}
              \put(107,145){\vector(-1,-1){15}}
              \put(115,145){\vector(1,-1){15}}
	      
              \put(70,120){2 x}
              \put(88,123){\circle{15}}
              \put(89,114){\vector(0,-1){12}}
	      
              \put(120,120){6 y}
              \put(138,123){\circle{15}}
              \put(139,114){\vector(0,-1){12}}
	      
              \put(74,90){3 @}
              \put(89,93){\circle{15}}
              \put(85,85){\vector(-1,-2){7}}
              \put(93,85){\vector(1,-2){7}}
	      
              \put(60,60){4 x}
              \put(74,63){\circle{15}}
	      
              \put(85,60){5 x}
              \put(99,63){\circle{15}}
	      
              \put(124,90){7 @}
              \put(138,93){\circle{15}}
              \put(134,85){\vector(-1,-2){7}}
              \put(142,85){\vector(1,-2){7}}
	      
              \put(110,60){8 y}
              \put(124,63){\circle{15}}
	      
              \put(135,60){9 y}
              \put(149,63){\circle{15}}
	      
	      
              \put(200,170){{\bf\em Control flow graph}}
	      
              \put(207,80){1}
              \put(210,83){\circle{20}}
              \put(223,83){\vector(1,0){70}}
              \put(221,89){\vector(1,1){17}}
              \put(216,92){\vector(1,2){23}}	      
              \put(247,110){6}
              \put(250,113){\circle{20}}
	      
              \put(247,140){2}
              \put(250,143){\circle{20}}
	      
              \put(307,80){3}
              \put(310,83){\circle{24}}
              \put(323,83){\vector(1,0){73}}
              \put(322,90){\vector(1,1){15}}
              \put(319,94){\vector(1,2){20}}	      
              \put(347,110){5}
              \put(350,113){\circle{24}}
	      
              \put(347,140){4}
              \put(350,143){\circle{24}}
	      
              \put(407,80){7}
              \put(410,83){\circle{24}}
              \put(422,90){\vector(1,1){15}}
              \put(419,94){\vector(1,2){20}}
              \put(432,83){\circle{15}}
              \put(425,78){\vector(-1,1){3}}	      
              \put(447,110){9}
              \put(450,113){\circle{24}}
	      
              \put(447,140){8}
              \put(450,143){\circle{24}}
	      


\end{picture}}

\end{fig}


An approximating SCG may be obtained by removing all 
environment components from 
Definition \ref{def-evaluate-and-call-relation-environment}. To deal with the 
absence of environments the variable lookup rule 
is modified: 
If  is {\em any} application in {\tt P} 
such that  can evaluate to a value of form  and 
 can evaluate to value , then 
is regarded as a possible value of {\tt x}. 

Although approximate, these rules have the virtue that 
there are only finitely many possible judgements  
and
. Consequently, the runtime behavior of 
program {\tt P} may be 
(approximately) analysed by exhaustively applying these 
inference rules. A later section will extend the rules so they also 
generate  size-change graphs.



\bdfn
\label{def-eval-approx}
{\rm(Approximate evaluation and call rules)}
The new judgement forms are
 and . 
The inference rules are:
\smallskip





\edfn


\fl  The (VarA) rule refers globally to {\tt P}, the program being 
analysed.
The approximate evaluation is nondeterministic, since an 
expression may evaluate to more than one value. 
\medskip

Following is a central result: that 
all possible values obtained by the {\em actual evaluation} of  Definition \ref{def-evaluate-and-call-relation-environment}
are accounted for by
the {\em approximate evaluation} of Definition \ref{def-eval-approx}.
\blem \label{abs-super} 
\hfill  \bt{ccccc} If  &and& , &then& 
. \\

\hfill  If    &and& , &then& .
\et
\elem
\fl Proof is in the Appendix.
\section{A quick review of size-change analysis}
 \label{sec-quick-review-size-change-analysis}


Using the framework of  \cite{popl01}, the relation between two
states  and  in a call 
 or an evaluation  will be
described by means of a size-change graph . 


\begin{exa}
Let first-order  functions {\tt f} and {\tt g} be
defined by mutual recursion:

\bp
    f(x,y)   = if x=0 then y else {1:} g(x,y,y) 
    g(u,v,w) = if w=0 then {3:}f(u-1,w) else {2:}g(u,v-1,w+2)

\ep

\fl Label the three function calls  {\tt 1}, {\tt 2} and {\tt 
3}. The ``control flow graph'' in Figure \ref{fig-first-order-example} 
shows the calling function
and called function of each 
call, e.g., . Associate with each call 
a ``size-change graph'', e.g.,  for call {\tt 1}, that safely describes 
the data flow from the calling function's parameters to the 
called function's parameters. Symbol  indicates a value decrease.
\begin{fig0}{Call graph and size-change graphs for the example 
first-order program.}{htb}
	       {fig-first-order-example}
	       
\fl{\tt    \setlength{\unitlength}{0.5pt}
\begin{picture}(530,180)(-100,20)
\thicklines

              \put(60,190){{\bf\em Size-change graph set} }


              \put(50,60){\framebox(60,120){}}
              \put(56,150){x}
              \put(95,150){u}
              \put(56,110){y}
              \put(95,110){v}
              \put(95,70){v}
              \put(74,34){}
              \put(70,148){}
              \put(70,107){}
              \put(70,107){\vector(1,-1){25}}
              \put(73,80){=}


              \put(150,60){\framebox(60,120){}}
              \put(156,150){u}
              \put(195,150){u}
              \put(156,110){v}
              \put(195,110){v}
              \put(156,70){w}
              \put(195,70){w}
              \put(165,34){}
              \put(170,107){}
              \put(170,148){}


              \put(250,60){\framebox(60,120){}}
              \put(256,150){u}
              \put(295,150){x}
              \put(256,110){v}
              \put(295,110){y}
              \put(256,70){w}
              \put(270,77){\vector(1,1){25}}
              \put(270,85){=}
              \put(274,34){}
              \put(270,148){}


              \put(460,180){{\bf\em Control flow graph}}
	      
              \put(440,90){\framebox(200,70)}

              \put(475,120){f}
              \put(550,120){g}
              \put(497,129){\vector(1,0){40}}
              \put(537,119){\vector(-1,0){40}}


              \put(600,120){2}
              \put(510,137){1}
              \put(510,100){3}
              \put(585,125){\circle{25}}
              \put(573,120){\vector(-1,1){3}}
	      \thinlines
              \put(480,125){\circle{30}}
              \put(555,123){\circle{30}}
	      

\end{picture}}

\end{fig0}




\fl{\bf Termination reasoning:}
We show that
{\em all infinite size-change graph sequences}  

that follow 
the program's control flow {\em are impossible} (assuming
that the data value set is well-founded):
\vair

{\bf Case 1:}\ \     ends in infinitely many 's: 
This would imply that {\em variable {\tt v} descends infinitely.}

{\bf Case 2:}\ \  . 
This would imply that  {\em variable {\tt u} descends infinitely.}


\fl Both cases are impossible; therefore a call of  
{\em any program function with any data will terminate.}
\hfill {\em End of example.}



\end{exa}



\bdfn
\label{def-size-change-terminology}
\hfill

\be[(1)]
	   
\item 

A {\em size-change graph}  consists of 
a {\em source} set ; 
a {\em target} set ; and 
a   set of labeled\footnote{Arc label  signifying  was used in  \cite{popl01} instead of , but this makes no difference in our context.}
 arcs .

\item The {\em identity}  size-change graph for  is 
 where 
.


\item Size-change graphs  and 
 are {\em composible} if .
The {\em composition} of 
 and 
  is

where 



\ee


\edfn

\blem Composition is associative, and 
implies .
\elem



\bdfn A {\em multipath}  over a set   of 
size-change graphs is a finite or infinite composible sequence
of graphs in . Define
 
\edfn




\bdfn\label{def-thread-inf-descent}\hfill
\be[(1)]
\item A {\em thread} in a multipath 
 
is a sequence 
 
such that 
 for every 
(and each  is  or .)\vair

\item Thread  is of {\em infinite descent} if  for 
infinitely many .\vair
\ee
\edfn

\bdfn \label{def-size-change-condition}The size-change condition.\hfill
\be
\item[] A  set   of size-change graphs satisfies the 
{\em size-change condition} if every infinite multipath 
 
contains at least one thread of infinite descent.
\ee
\edfn

\fl Perhaps surprisingly, the size-change condition is decidable. 
Its worst-case complexity
is shown to be complete for {\sc pspace}  in \cite{popl01}
(for first-order programs, in relation to the length of the program being analysed).
\smallskip

\fl{\it The example revisited} 
 The program of Figure \ref{fig-first-order-example} 
has three size-change graphs, one for each of the calls 
, so
 
 where  and .
(Note: the vertical layout
of size-change graphs in Figure \ref{fig-first-order-example} is 
inessential; one could simply write
.)

	  
satisfies the size-change condition, since {\em every infinite multipath 
has either a thread that decreases {\tt u} infinitely, or
a thread that decreases {\tt v} infinitely}.


\section{Tracing data size changes in call-by-value -calculus evaluation}


The next focus is on size relations between consecutive environments 
in a call chain. 


\subsection{Size changes in a computation: a well-founded  relation between states}


\bdfn 
\label{def-graph-nodes}\hfill
\be[(1)]

\item A {\em name path} is  a finite string  of 
variable names, where the empty string is (as usual) written . 

\item The {\em graph basis} of a state  is the smallest set  
 
of name paths satisfying

\ee
\edfn
By this definition, for the two states in the example above we have
 and 
. Further, given a state  and a path , we can 
find the substate identified by name path  as follows: 

\bdfn 
\label{def-graph-valuation}
The {\em valuation function}
  of a state  
is defined by: 
 
\edfn
We need to develop a size ordering on states. 
This will  be modeled by size-change arcs
 and .
The size relation we use is partly the ``subtree'' relation on closure 
values , and partly the ``subexpression'' relation on 
-expressions.



\bdfn\label{def-value-decrease}\hfill

\be[(1)]

\item 
The {\em state support}  of 
a state  is given by


\item Relations  
, ,  and  on states are defined by:
\be[]

\item   holds if  and ; 

\item  holds if  and 
, where 
 and  and . Further, \\


\item Relation   is defined to be the transitive closure of 
. 

\item Finally,  if  and \\
\ee
\ee
\edfn

\blem\label{lem-well-founded}
The relation  is 
well-founded.
\elem

We prove that the relation  on states is well-founded
by proving that 

in the lexicographic order, where  gives the height of the environment and  gives the length of the expression. 
 The proof is in the Appendix.



\blem\label{lem-sub-env}
If  then . 
If  and  then .
\elem


\section{Size-change graphs that safely describe a program}


\subsection{Safely describing state transitions}

We now define the arcs of the size-change graphs 
(recalling Definition \ref{def-size-change-terminology}):
\bdfn 
\label{def-graph-arcs}
A size-change graph  relating state  to state  has {\em source}
 and {\em target}
. 
\edfn


\bdfn\label{def-safe-call-and-evaluation}
Let
 and .
Size-change graph  is 
{\em safe}\footnote{The term ``safe'' comes from abstract interpretation 
\cite{jonesnielson}. An alternative would be  ``sound.''}  
for  if

\edfn
\fl
By  we denote the subset of  from where arcs begin. By  we denote the subset of  where arcs end.
Notice that if a size-change graph  is safe for the states , then any subset size-change graph  with  and  is safe for .


\bdfn
\label{safe-set-of-size-change-graphs}
A set  of size-change graphs is 
{\em safe for program {\tt P}} if  
 implies some 
 is safe 
for the pair .
\edfn



\begin{exa} Figure \ref{fig-ann-call-graph} below shows a graph 
set  that is safe for the program 
{\tt x.x@x}{\tt y.y@y}.
For brevity, each subexpression of   is 
referred to by number in the diagram of .
Subexpression  has no free 
variables, so  arcs from node {\tt 1} are labeled with
size-change graphs .
\begin{fig}{A set of size-change graphs that safely describe
     's nonterminating computation}{htb}
	       {fig-ann-call-graph}

    \fl{\tt    \setlength{\unitlength}{0.92pt}
\begin{picture}(530,140)(60,40)
\thicklines

              \put(80,170){{\bf-expression} }

              \put(95,150){1 @}
              \put(111,153){\circle{15}}
              \put(107,145){\vector(-1,-1){15}}
              \put(115,145){\vector(1,-1){15}}
	      
              \put(70,120){2 x}
              \put(88,123){\circle{15}}
              \put(89,114){\vector(0,-1){12}}
	      
              \put(120,120){6 y}
              \put(138,123){\circle{15}}
              \put(139,114){\vector(0,-1){12}}
	      
              \put(74,90){3 @}
              \put(89,93){\circle{15}}
              \put(85,85){\vector(-1,-2){7}}
              \put(93,85){\vector(1,-2){7}}
	      
              \put(60,60){4 x}
              \put(74,63){\circle{15}}
	      
              \put(85,60){5 x}
              \put(99,63){\circle{15}}
	      
              \put(124,90){7 @}
              \put(138,93){\circle{15}}
              \put(134,85){\vector(-1,-2){7}}
              \put(142,85){\vector(1,-2){7}}
	      
              \put(110,60){8 y}
              \put(124,63){\circle{15}}
	      
              \put(135,60){9 y}
              \put(149,63){\circle{15}}
	      
	      
              \put(200,170){{\bf\em Set of size-change graphs 
	                     }}
	      
              \put(207,80){1}
              \put(210,83){\circle{20}}
              \put(223,83){\vector(1,0){70}}
              \put(221,89){\vector(1,1){17}}
              \put(216,92){\vector(1,2){23}}
              \put(213,115){}
              \put(230,90){}
              \put(260,88){}
	      
              \put(247,110){6}
              \put(250,113){\circle{20}}
	      
              \put(247,140){2}
              \put(250,143){\circle{20}}
	      
              \put(307,80){3}
              \put(310,83){\circle{24}}
              \put(323,83){\vector(1,0){73}}
              \put(322,90){\vector(1,1){15}}
              \put(319,94){\vector(1,2){20}}
              \put(316,115){}
              \put(330,90){}
              \put(360,88){}
	      
              \put(347,110){5}
              \put(350,113){\circle{24}}
	      
              \put(347,140){4}
              \put(350,143){\circle{24}}
	      
              \put(407,80){7}
              \put(410,83){\circle{24}}
              \put(422,90){\vector(1,1){15}}
              \put(419,94){\vector(1,2){20}}
              \put(432,83){\circle{15}}
              \put(425,78){\vector(-1,1){3}}
              \put(416,115){}
              \put(431,91){}
              \put(443,77){}
	      
              \put(447,110){9}
              \put(450,113){\circle{24}}
	      
              \put(447,140){8}
              \put(450,143){\circle{24}}
	      

              \put(180,50){
	      , \
	      , \ 
	      , \ 
	       } 

\end{picture}}
\end{fig}
\end{exa} 

\bthm
If  is safe for program {\tt P} and satisfies 
the size-change condition, then call-by-value evaluation of {\tt P} 
terminates.
\ethm

\bprf
Suppose call-by-value-evaluation of {\tt P} does not terminate. Then by 
Lemma \ref{lem-NIS-environment} there is an  infinite call chain

Letting , by safety of  
(Definition \ref{safe-set-of-size-change-graphs}),  
there is a size-change 
graph  that safely describes each pair
.
By the size-change condition 
(Definition \ref{def-size-change-condition}) the multipath 
 has an infinite  thread
 
such that  implies
, and each  is 
 or , and 
there are infinitely many .
Consider the value sequence 
.
By safety of   (Definition \ref{def-safe-call-and-evaluation})
we have 
  
for every ,
and infinitely many  
proper decreases 
. 
However this 
is impossible since by Lemma \ref{lem-well-founded} the 
relation  on {\it State} is 
well-founded.

Conclusion: call-by-value-evaluation of {\tt P} 
terminates.
\eprf

\fl The goal is partly achieved: We have found a sufficient condition 
on a set of size-change graphs to guarantee program termination. 
What we have not yet done is to find an algorithm to 
{\em construct} a size-change graph set  that is safe for {\tt P}
(The safety condition of 
Definition \ref{safe-set-of-size-change-graphs} is in general undecidable, so
enumeration of all graphs won't work.)
Our graph construction algorithm is developed in two stages:
\be[]
\item 
First, the exact evaluation and call relations are ``instrumented'' so 
as to produce safe size-change graphs during evaluation. 

\item Second, an extension of the abstract interpretation 
from Section \ref{sec-abstract-interpretation-for-cfg} yields a 
{\em computable} over-approximation  that  contains all graphs that can be 
built during exact evaluation. 
\ee


\subsection{Generating size-change graphs during a computation}
We now ``instrument''  the exact evaluation and call relations  so 
as to produce safe size-change graphs during evaluation. In the definition of the size-change graphs {\tt x}, {\tt y}, {\tt z} are variables, and   can be variables or , the empty path. Recall the valuation function for a state gives , so in a sense  is bound to the whole state. 

\bdfn
\label{def-eval-call-generate-graphs}
{\rm(Evaluation and call with graph generation)}
The extended  evaluation and call judgement forms are 
, where  = fv({\tt e}) and  = fv({\tt e}). The inference rules are:
\medskip

\smallskip

\fl\bt{cll}
 &stands for& 
 \\
 &stands for& 
 \\
\et\\
\smallskip

\noindent An arc  express that the
state bound to the variable  is the same in both sides,
before and after the evaluation or call.\\ The  ``represent"
the whole state.  In the (ValueG) rule the state  is the same in both sides and so there is an arc
. In the (OperatorG) and
(OperandG) rules the state is smaller in the right hand side because
we go to a strict subexpression and possibly also restrict the
environment  accordingly. So there are
 arcs.


\smallskip

\noindent In the (VarG) rule the state on the right side is . This is the state which  is bound to in the environment in the left hand side, therefore we have an arc . Suppose  and . Then  is bound in  and this binding is then a subtree of  . So we have an arc .





\noindent In the definition of the size-change graphs used in the
(CallG) rule {\tt x}, {\tt y}, {\tt z} are variables, and  can be
variables or .  In  the  can be either
 or .  The construction of the size-change graph
associated with the call is explained below.  \vair


\fl\bt{lll}
&stands for&cases\\

&&:   
\\

&&:  \\
&&     \\

  &stands for& 
\\

 &stands for&the restriction of  such that the codomain \\
\et
\bigskip

\fl First we consider how much information from  we can preserve. We have that the whole state  in left hand side for the -call is strictly larger than . 
The variable {\tt x} is not free in  and so does not belong to the target of . If a variable {\tt z}
   fv() is bound in 
 then it is bound to the same state in .
 Therefore, if there is an arc  in , then it also safely describes the -call and can be preserved. Also, if there is an arc  in , then an arc  describes the c-call. Further, if  then  and then . In this case, if there is an arc  going to  in , then  the arc  describes the -call.\\
Now consider which information we can gain from . We have that the whole state  in left hand side for the -call is strictly larger than .  
If  then in  we have that  is bound to the whole state in the right hand side for the evaluation of the operand. So in this case, if there is an arc  in   then  the arc  describes the -call, and if there is an arc  in   then  the arc  describes the -call. If  then we cannot gain any information from . 
The restriction built into the definition of  ensures that this holds.



\smallskip


\fl The size-change graph (G';G) is the composition of the two graphs.
\edfn

\fl
In the size-change graphs generated by the rules above, the less-than relations  
in (VarG)-rule arise from the sub-environment property of  from 
Lemma \ref{lem-sub-env}. The remaining relations  arise from 
the subexpression property of . The  relations based on the sub-environment property 
capture the case that the state on the right hand side is fetched 
from the environment in the left hand side. The equality relations  describe 
how values are preserved under calls and evaluations.




\vair
\blem\label{lem-graph-extend}

 
   {\rm(by Definition \ref{def-evaluate-and-call-relation})}
   iff 
 
   {\rm(by Definition  \ref{def-eval-call-generate-graphs})
   for some }.
Further, 

iff
   
   for some .
\elem

\bthm \label{graphs_safe}
{\rm (The extracted graphs are safe)}\hfill\ \\
 or  {\rm(by Definition  \ref{def-eval-call-generate-graphs})} implies  is safe for 
 (with  and  sets extended as necessary).
\ethm

Lemma \ref{lem-graph-extend}
is immediate since the new rules extend 
the old, without any restriction on their applicability. Proof of ``safety'' 
Theorem \ref{graphs_safe} is in Appendix.\\


\vair
\begin{fig}{Data-flow in a variable evaluation}{h}{fig-data-flow-variable}

    \fl{\tt \large   \setlength{\unitlength}{1.8pt}

\begin{picture}(300,75)(80,-5)
\thicklines

	      
              \put(84,52){}
              \put(90,54){\oval(15,10)}
              \put(98,54){\vector(1,0){53}}
              \put(120,56){}
              \put(94,51){\vector(1,-2){12}}
              \put(94,40){x}
	      
	      
              \put(152,52){}
              \put(164,54){\oval(25,10)}
              \put(170,50){\line(-1,-2){10}}
              \put(170,50){\line(1,-2){10}}
              \put(160,30){\line(1,0){20}}
              \put(170,50){\vector(1,-3){5}}
              \put(168,40){y}
	      
	      
              \put(92,22){}
              \put(110,20){\line(-1,-2){10}}
              \put(110,20){\line(1,-2){10}}
              \put(100,0){\line(1,0){20}}
              \put(110,20){\vector(1,-3){5}}
              \put(108,10){y}
	      
	      \thinlines
	      
\put(147,18){{\rm equal}}
              \put(115,5){\vector(2,1){60}}
	      

\end{picture}}

\end{fig}

\begin{fig}{Data-flow in an application}{h}{fig-data-flow-apply}.
    \fl{\tt \large   \setlength{\unitlength}{1.8pt}
\begin{picture}(300,120)(10,25)
\thicklines

              \put(67,132){}
              \put(78,135){\oval(40,10)}
              \put(90,130){\line(-1,-2){10}}
              \put(90,130){\line(1,-2){10}}
              \put(80,110){\line(1,0){20}}
	      
	      
              \put(27,92){}
              \put(38,94){\oval(35,10)}
              \put(56,95){\vector(1,0){55}}
              \put(55,90){\vector(1,-1){30}}
	      
              \put(73,73){\rm (Operand)}
              \put(65,80){e}
              \put(50,100){\vector(1,1){30}}
	      
              \put(33,115){\rm (Operator)}
              \put(37,108){e}
	      
              \put(50,90){\line(-1,-2){10}}
              \put(50,90){\line(1,-2){10}}
              \put(40,70){\line(1,0){20}}
              \put(67,101){}
	      
              \put(80,97){\rm (Call)}
	      
	      
              \put(117,92){}
              \put(144,94){\oval(65,10)}
              \put(130,90){\vector(1,-1){30}}
              \put(148,75){x}
              \put(130,90){\line(-1,-2){10}}
              \put(130,90){\line(1,-2){10}}
              \put(120,70){\line(1,0){20}}
	      
	      
              \put(79,52){}
              \put(88,55){\oval(25,10)}
              \put(90,50){\line(-1,-2){10}}
              \put(90,50){\line(1,-2){10}}
              \put(80,30){\line(1,0){20}}
	      
	      
              \put(158,52){}
              \put(165,55){\oval(25,10)}
              \put(170,50){\line(-1,-2){10}}
              \put(170,50){\line(1,-2){10}}
              \put(160,30){\line(1,0){20}}
	      
	      \thinlines
\put(45,75){\vector(1,1){40}}
              \put(52,75){\vector(1,1){40}}
	      
\put(45,75){\vector(1,-1){42}}
              \put(52,75){\vector(1,-1){36}}
              \put(55,56){}
	      
\put(85,115){\vector(1,-1){40}}
              \put(92,115){\vector(1,-1){40}}
              \put(100,100){}
	      
\put(115,41){{\rm equal:} }
              \put(88,39){\vector(1,0){81}}
              \put(87,33){\vector(1,0){81}}
	      

\end{picture}
}


\end{fig}


\fl The diagram of Figure \ref{fig-data-flow-variable} illustrates the data-flow in a variable evaluation.    
The diagram of Figure \ref{fig-data-flow-apply} may be of some use in 
visualising data-flow during evaluation of .
States are in ovals and triangles represent environments.
In the application  on 
the left, operator  evaluates to 
 
and operand  evaluates to . 
The size-change graphs  and  show relations between variables 
bound in their environments. There is a call from the application 
 to 
 
the body of the operator-value with the environment extended with a binding of 
 to the operand-value .

It is possible to approximate the calls and evaluates to relations with different degrees of precision depending on how much information is kept about the bindings in the environment. Here we aim at a coarse approximation, where we remove all environment components.\footnote{It is possible to keep a little more information in the graphs than we do here even with no knowledge about value-bindings in the environment. 
We have chosen the given presentation for simplicity.}


\subsection{Construction of size-change graphs by abstract 
interpretation} 
\label{sec-absint-generate-graphs}


We now extend the coarse approximation to construct size-change 
graphs.

\bdfn\label{def-approx-eval-and-graph-gen} {\rm (Approximate
evaluation and call with graph generation)} \\ The judgement forms are
now  and , where
source() = fv({\tt e}) and target() = fv({\tt
e}'). The inference rules are:




\smallskip


\smallskip


\edfn
\smallskip

\blem \label{abs-graphs}Suppose . 
If   by definition \ref{def-eval-call-generate-graphs}
then . Further, if
 then 
.
\elem

\bprf  Follows from Lemma \ref{abs-super}; see the Appendix.
\eprf

\bdfn 


\edfn


\bthm \hfill
\be[\em(1)]
\item The set  is safe for {\tt P}.
\item The set   can be effectively computed 
from {\tt P}.
\ee
\ethm
\bprf 
Part 1: Suppose . Theorem 
\ref{graphs_safe} implies
 where each  is safe for the pair . 
Let . By Lemma \ref{abs-graphs},
.  
By the definition of ,  .

Part 2: There is only a fixed number of subexpressions of {\tt P}, or 
of possible size-change graphs with source and target 
. 
Thus 
can be computed by applying Definition \ref{def-approx-eval-and-graph-gen}
exhaustively, starting with {\tt P}, until no new graphs or 
subexpressions are obtained.
\eprf 


\section{Some examples} \label{sec:examples}

\subsection{A simple example}

\fl Using Church numerals 
(), 
we expect {\tt 2 succ 0} to reduce to {\tt 
succ(succ 0)}. However this  contains unreduced redexes because 
call-by-value does not reduce under a , so we force the 
computation to carry on through by applying {\tt 2 succ 0} to the 
identity (twice). This gives:

\bp
2 succ 0 id1 id2 where
  succ = m.s.z. m s (s z)
  id1  = x.x
  id2  = y.y

\ep
After writing this out in full as a -expression, our 
analyser yields (syntactically sugared):\medskip

{\tt\bt{llll}
      &[s2.z2.(s2 @ (s2 @ z2))] &\hair& -- two --\\
   @ & [m.s.z. \fbox{15:}((m@s)@(s@z))] && -- succ 
   --\\
   @ & [s1.z1.z1]   &&  -- zero --\\
   @ & [x.x]                 && -- id1 --\\
   @ & [y.y]                 && -- id2 --
   \et}

\bp
Output of loops from an analysis of this program:

1515: [(m,>,m),(s,=,s),(z,=,z)], []

Size-Change Termination: Yes

\ep
The first number refers to the program point,
then comes a list of edges. 
The loop occurs because application of {\tt 2} forces the code for 
the successor function to be executed twice, with decreasing argument 
values {\tt m}. The notation for edges is a little
different from previously, here {\tt (m,>,m)} stands for
.



\subsection{  by Church numerals}\label{ex:fnx}

This more interesting program computes  by 
higher-order primitive 
recursion. If {\tt n} is a Church numeral then expression {\tt n g x} reduces to
{\tt gx}). Let {\tt x} be the successor function, and {\tt g} be 
a ``double application'' functional. Expressed in a readable named 
combinator form, we get: 
\bp
   f n x    where
   f n   =  if n=0 then succ else g(f(n-1)) 
   g r a =  r(ra)
\ep\smallskip

\fl As a lambda-expression (applied to values 
this can be written:\medskip

{\tt\bt{lllll}
[n.x. & n    &&& -- n --\\
   & @ & [r.a.\fbox{11:}(r@\fbox{13:}(r@a))] && -- 
   g --\\
  & @ & [ k. s. z.(s@((k@s)@z))] && - succ-\\
  & @ & x ]   && -- x --\\\\
   @ & & [s2.z2. (s2@(s2@(s2@z2))) ]     && -- 3 --\\
   @ & & [s1.z1. (s1@(s1@(s1@(s1@z1))))] && -- 4 --
   \et}
\smallskip

\fl Following is the output from program analysis. The analysis found
the following loops from a program point to itself with the associated
size-change graph and path. The first number refers to the program point,
then comes a list of edges and last a list of numbers, the other program
points that the loop passes through. 

\bp
SELF Size-Change Graphs, no repetition of graphs: 

11  11: [(r,>,r)]           []
11  11: [(a,=,a),(r,>,r)]   [13]
13  13: [(a,=,a),(r,>,r)]   [11]
13  13: [(r,>,r)]           [11,11]

Size-Change Termination: Yes
\ep

\subsection{Ackermann's function, second-order}

This can be written without recursion  using Church numerals as:
{\tt a m n} where {\tt a = m. m b succ} and
{\tt b =  g.n. n g (g 1)}.  
Consequently {\tt a m = b(succ)} and
{\tt b g n = g(1)}, which can be seen to agree with the 
usual first-order definition of Ackermann's function.
Following is the same as a lambda-expression applied 
to argument values {\tt m=2, n=3}, with numeric labels on some subexpressions.

\bp
(m.m b succ) 2 3  =  (m.m@b@succ)@2@3
(m.m@(g.n.n@g@(g@1))@succ)@2@3
(m.m@(g.n.\fbox{9:}(n@g@\fbox{13:}(g@1)))@succ)@2@3
{\rm where}
 1   =  s1.z1. \fbox{17:}(s1@z1)
succ =  k.s.z. \fbox{23:}(s@\fbox{25:}(k@s@z))
 2   =  s2.z2. s2@(s2@z2)
 3   =  s3.z3. \fbox{39:}(s3@\fbox{41:}(s3@\fbox{43:}(s3@z3)))

\ep

\fl Output from an analysis of this program is shown here.\\
{\small (It is not always the case that the same loop is shown for all program points in its path)}

\bp
SELF Size-Change Graphs, no repetition of graphs:


9  9: [(,>,n),(g,>,g)]           [13]
 9   9: [(g,>,g)]                   [17]
13  13: [(g,>,g)]                   [9]
17  17: [(s1,>,s1)]                 [9]
23  23: [(k,>,k),(s,=,s),(z,=,z)]   [25]
23  23: [(s,>,s)]                   [9]
23  23: [(s,>,s),(z,>,k)]           [25,17,9]
25  25: [(k,>,k),(s,=,s),(z,=,z)]   [23]
25  25: [(s,>,s),(z,>,k)]           [17,9,23]
25  25: [(s,>,s)]                   [23,9,23]
39  39: [(s3,>,s3)]                 [9]
41  41: [(s3,>,s3)]                 [9,39]
43  43: [(s3,>,s3)]                 [9,39,41]

Size-Change Termination: Yes

\ep



\subsection{Arbitrary natural numbers as inputs}

The astute reader may have noticed a limitation in the above examples: each only concerns {\em a single -expression}, e.g., Ackermann's function applied to  argument values {\tt m=2, n=3}.

In an implemented version of the -termination analysis
a program may have an arbitrary natural number as input; this is represented by . 
Further, programs can have 
as constants the predecessor, successor and zero-test functions,
and if-then-else expressions. 
We show, by some examples using , that the size-change termination approach
can handle the Y-combinator.

\

In Section \ref{sec-regular-program-inputs} we show how to do size-change analysis 
of  -expressions applied to {\em sets  of  argument values} in a more classic context, using Church or other numeral notations instead of .

\subsection{A minimum function, with general recursion and Y-combinator}


This program computes the minimum of its two inputs using the call-by-value 
combinator 
 {\ttp. [q.p@(s.q@q@s)] @
                     [t.p@(u.t@t@u)]}.
The program, first as a first-order recursive definition.

\bp
  m x y = if x=0 then 0 else if y=0 then 0 else succ (m (pred x) (pred y))

\ep
Now,  in -expression form for analysis.\medskip


{\tt\bt{lllllll}
\multicolumn{7}{l}{
\{p. [q.p@(s.q@q@s)] @
                     [t.p@(u.t@t@u)]\} \hair -- the Y combinator --}\\

@\\

[m.x.y.\fbox{27:}if&((ztst @ &x),\\

&0,\\

&\fbox{32:}\hair\hair if&((ztst @ y),\\

&&0,\\

&&\fbox{37:}succ @ \fbox{39:} m @ (pred@x) @ (pred@y)] \\

@ \\

@ 
\et}



\bp
Output of loops from an analysis of this program:

27  27: [(x,>,x),(y,>,y)]    [32,37,39]
32  32: [(x,>,x),(y,>,y)]    [37,39,27]
37  37: [(x,>,x),(y,>,y)]    [39,27,32]
39  39: [(x,>,x),(y,>,y)]    [27,32,37]

Size-Change Termination: Yes
\ep
\vair
\subsection{Ackermann's function, second-order with constants and Y-combinator}

Ackermann's function can be written as:
{\tt a m n} where {\tt a m = b(suc)} and
{\tt b g n = g(1)}. The following program 
expresses the computations of both {\tt a} and {\tt b} by loops,
using the Y 
combinator (twice). 
\vair

{\tt\bt{llllll}
[ y. y1. \\

(y1 @\\

 a. m.
\fbox{11:}if( & \multicolumn{3}{l}{(ztst@m),}\\

              & \multicolumn{3}{l}{ v.(suc@v),}\\
	      
	      & \fbox{19:}( & (y
@\\

&&\multicolumn{3}{l}{ b. f. n.}\\

&&\fbox{25:}if( & (ztst@n),\\

&&              & \fbox{29:}(f@1),\\
		
&&              & \fbox{32:}f@\fbox{34:}b @ f @ (pred@n))\\

& \multicolumn{3}{l}{@ \fbox{41:} a @ (pred@m)}]\\\\


\multicolumn{6}{l}{
@ \{p.[q.p@(s. q@q@s)] @
                     [t.p@(u.t@t@u)]\}
}\\

\multicolumn{6}{l}{
@ \{p1.[q1.p1@(s.\fbox{72:}q1@1q@s1)] @
                     [t1.p1@(u1.\fbox{81:}t1@t1@u1)]\}
}\\

@ \\

@ 
\et}



\bp
Output of loops from an analysis of this program:

SELF Size-Change Graphs no repetition of graphs: 
\ep

\bp

11 11: [(a,>,y),(m,>,m)]    [19,41,72]
11 11: [(m,>,m)]            [19,41,72,11,19,41,72]
19 19: [(a,>,y),(m,>,m)]    [41,72,11]
19 19: [(m,>,m)]            [41,72,11,19,41,72,11]
25 25: [(f,>,b),(f,>,f)]    [29]
25 25: [(f,=,f),(n,>,n)]    [32,34]
25 25: [(f,>,f)]            [29,25,32,34]
29 29: [(f,>,f)]            [25]
32 32: [(f,>,b),(f,>,f)]    [25]
32 32: [(f,=,f),(n,>,n)]    [34,25]
32 32: [(f,>,f)]            [25,32,34,25]
34 34: [(f,=,f),(n,>,n)]    [25,32]
34 34: [(f,>,b),(f,>,f)]    [25,29,25,32]
34 34: [(f,>,f)]            [25,29,25,32,34,25,32]
41 41: [(m,>,m)]            [72,11,19]
72 72: [(s1,>,s1)]          [11,19,41]
81 81: [(u1,>,u1)]          [11,19,41]

Size-Change Termination: Yes
\ep

\fl

\vair
\subsection{Imprecision of abstract interpretation}



It is natural to wonder 
whether the gross approximation of Definition \ref{def-eval-approx} 
comes at a cost. The (VarA) rule can in effect 
``mix up'' different function applications, losing the coordination 
between operator and operand that is present in the exact semantics.



We have observed this in practice: The first time we had programmed 
Ackermann's using explicit recursion, we used the same instance of 
Y-combinator for both 
loops, so the single Y-combinator expression was ``shared''. The analysis did 
not discover that the program terminated. 

However when this was replaced by 
the ``unshared'' version above, with two instances of the Y-combinator
({\tt y} and {\tt y1}) (one for each application), the problem disappeared 
and termination was correctly recognised.




\subsection{A counterexample to a conjecture}

Sereni disproved in \cite{sereni2,sereni} our  {\bf conjecture}  that the size-change 
method would recognise as terminating any 
simply typed -expression. The root of the problem is the imprecision of abstract interpretation just noted. A counter-example: the -expression

is simply-typable but not size-change terminating. Its types are any
instantiation of \medskip


\bigskip

\section{Arbitrary -regular program inputs (Extended -calculus)} 
\label{sec-regular-program-inputs}

Above we have analysed the termination behaviour of a single closed -expression. We now analyse the termination behaviour for a program in the -calculus for all possible inputs from a given input-set of -expressions (e.g., Church numerals). The first step is to define which sets of -expressions we consider. A well-defined input set will be the set of closed expressions in the ``language'' generated by a -regular grammar. 

We extend the syntax and semantics of the -calculus to handle expressions containing nonterminals. An extended lambda term represents all instances of a program with input taken from the input set. If our analysis certifies that the extended term terminates, then this implies that the program will terminate for all possible inputs.

\subsection{-regular grammars}

We are interested in a -regular grammar for the sake of the {\em language}  that it generates:
a set of pure -expressions (without nonterminals). This is done using the derivation relation , soon to be defined. 


\bdfn \label{def-lamda-reg}\hfill

\be[(1)]
\item A {\em -regular grammar} has form  where  is a
finite set of {\em nonterminal} symbols and  is a finite set of {\em productions}.
\bigskip

\item A {\em -extended  -expression} has the following syntax:\medskip

\bt{lcl}
{\tt e, P} &\ ::=\ &\  {\tt
x | A | e @ e | x.e}\\
{\tt A} &\ ::=\ &\  {\rm Non-terminal name, }\\
{\tt x} &\ ::=\ &\  {\rm Variable name}\\
\et\\

 \fl{\em Exp} denotes the set of -extended -expressions. {\em Exp} denotes the set of pure -expressions (without nonterminals). Clearly .
\bigskip


\item A production has form  where {\tt e}
is a  -extended  -expression. \ee
\edfn

\fl


\bdfn \label{prodstar}Let   denote the {\em multi-set} of nonterminal
occurrences in   {\em Exp}. 
The {\em derivation  relation }
 is  the
smallest relation such that

\be[(1)]
\item  If   and 
 for , \\then
\vair

\item If  and  then .
\vair
\ee
\edfn

Notice that  relates extended -terms to pure -terms.
\vair

In the above definition \ref{prodstar}  denotes the multi-set of nonterminals in {\tt e} so two different  may be instances of the same nonterminal {\tt A}. In the substitution  such two different instances of a nonterminal may be replaced by different pure -terms. 



\begin{exa} A grammar for Church Numerals: Consider

Here  iff  has form
 for some . 
Clearly  iff  has form
 for some
. 

\end{exa}
\fl
The following  assumption makes proofs more convenient; proof is standard and so omitted.
\blem For any -regular grammar  there exists an equivalent -regular grammar  such that  no production in  has form  where . We henceforth assume that all productions in a -regular grammar have form  where 
.\qed 
\elem


\bdfn \label{def-fv-subexp} In the following   is a -extended -expression:\hfill
\be[(1)]
\item Define the {\em free variables of {\tt e}} by  and  
\vair

\item Define that  is {\em closed} iff  is closed for all  such that .
It follows that  is closed iff .
\vair

\item 
Define {\em subterms}({\tt e}) inductively by: \\
For a variable : .\\
For an abstraction : .\\
For an application : .\\
For a nonterminal : .
\vair

\item Define {\em subexps}({\tt e}) as the smallest set satisfying:\\
For a variable : .\\
For an abstraction : .\\
For an application : .\\
For a nonterminal :  and .
\ee
\edfn
\fl If  then  is syntactically present as part of .\\
If  then  is either a subterm of  or a subexpression of a nonterminal . 

Sets  are both finite, and  for expressions  in the pure -calculus.

\begin{exa} In the grammar for Church Numerals
 is a closed -extended expression, but
 is not a closed -extended expression.
Further,
, 
,
, 
\end{exa}


\blem \label{prod-to-form} Let  be a variable. 
If  then  .\\
If  then  there exists   such that  .\\
If  then  there exist   such that  .
\elem

Any production has one of the forms , , . No
production performed on a subterm (which must be a nonterminal) can
give a new outermost syntactic term-constructor.

The following Lemma follows from the definition of free variables of
an extended expression.

\blem
For a variable : .\\
For an abstraction : .\\
For an application : .\\
For a nonterminal {\tt A}  N:  and . 
\elem

\blem\label{lem:fin-subexp-fv}
For  the sets  and  are finite and computable.
\elem

Proof is straightforward.

\subsection{Extended environment-based semantics.}

A  semantics extending Definition \ref{def-evaluate-and-call-relation-environment}
addresses the problem of substitution in expressions with non-terminals. Environments  bind -variables (and not  non-terminals) to values. 

\bdfn \label{def-environment-etc-ext} {\rm (Extended states, values and environments)}
{\it State}, {\it Value}, {\it Env} are the smallest
sets such that
\vspace{1mm}

\fl\bt{lccclr}

{\it State} &&  
&& &\\

{\it Value} &&  
&& &\\

{\it Env} && 
&& &
\et
\bigskip

\fl
The empty environment with  domain  is written .
The evaluation judgement form is
 where .
\edfn

The following rules for calls and evaluations in the extended language are simple extensions of the rules for pure -calculus to also handle nonterminals. 


\bdfn \label{def-environment-evaluation-ext} {\rm (Extended environment-based
evaluation)}
The judgement forms are  and
, where ,  and  are states. 
The evaluation
and call relations  are defined by the following inference rules, where
. 









\fl The following rules have not been changed (but now expressions
belong to ).
\smallskip






\edfn 


A -extended {\em program} is a closed expression .  While evaluating a program in the extended language
(), all calls and subevaluations will be from
state to state.

In pure -calculus the evaluation relation is
deterministic. The extended language is nondeterministic since a
nonterminal  may have  for more than one
.

Informally explained, consider closed extended -expression
 where nonterminal  satisfies
. Then  represents
application of  to all possible inputs generated by {\tt
B}. The analysis developed below can safely determine that 
terminates on all inputs by analysing .



 If a program in the extended language takes more than one input at a time, 
then we may rename the nonterminals and bound variables similarly as in -conversion. 
As an example, if a program takes two Church numerals as input, then they can be given by two grammars identical in structure:

\bt{lll}
&& and\\
&&\\
\et

\fl and we can analyse the termination behaviour for . 
Such renaming can sometimes make the termination analysis more precise.

\bdfn Suppose  is a closed -extended expression and  where
 is a  -regular grammar.
By definition {\tt e} is {\em -terminating} iff

for all pure -expressions  such that
 for
.
\edfn
\vair

The following rules for calls and evaluations with size-change graphs in the extended language are simple extensions of the rules for pure -calculus to also handle nonterminals. 

\bdfn \label{def-environment-evaluation-extb} {\rm (Environment-based
evaluation and call semantics utilizing size-change graphs)}
The judgement forms are  and
, where ,  and  are states,  and  .
The evaluation
and call relations  are defined by the following inference rules, where
. 








\fl The following rules have not been changed (but now expressions belong to ).









\edfn 
\medskip

\bthm \label{graphs_safeG_Ext}
{\rm (The extracted graphs are safe)}\hfill
 or  implies  is safe for 
. 
\ethm

\bprf 
\fl
This is shown by a case analysis as in the pure -calculus. For the (GramG) rule it is immediate from the definition of free variables for non-terminals.
\eprf

\subsection{Relating extended and pure -calculus}\ 

\fl The aim is now to show that execution of a program  in the extended language can 
simulate execution of any program  in the pure -calculus, where  is derived from  by replacing each nonterminal occurrence  in  with a pure -expression  can produce. The converse does not hold: it is possible that there are simulated executions that do not correspond to any instantiated program {\tt Q}. We have however  certified a number of programs to terminate when applied to arbitrary Church numerals. An example is given at the end of this section.
\smallskip

\fl \textbf{Properties of the relation }\\
 relates expressions  in
the extended language to expressions  in the pure
lambda-calculus.  Notice that there are only the following possible
forms of -related expressions:  

\bt{rrrrr}
 & &
 & &
\\
 & &
 & &
\\
\et
\medskip


\fl The relation  has the following inductive properties:\medskip

\fl, for  is given by definition \ref{prodstar}.\\
, -- a variable  corresponds to the same variable  and nothing else. \\
, iff , same .\\
 iff  and .\medskip

\blem If  then .
\elem

\bprf This is by induction on the structure of .\\
Case , immediate.\\ 
Case  where . By definition  and .\\
Case , iff . By induction the lemma holds for  and .
Therefore .\\ 
Case , iff  and . By induction the lemma holds for  and .
Hence .
\eprf

If , i.e., no nonterminals occur in , then
.  If  then there exist 
such that  and .



\bdfn \textbf{The relation  between states}\\
Define the relation  between states in the extended language and states in the pure -calculus as the smallest relation  such that: 
\bi
\item[] if  and for all  it holds that .
\ei
\edfn

If  is a state in the pure lambda calculus then it is also a state in the extended language and .

\blem \label{push-S}
If  and  then also .\qed
\elem

We now define a relation  between size-change graphs. The intention is that  is to hold when the only difference in the generation of the graphs is due to nonterminals that take the place of pure lambda expressions.
\bdfn \textbf{The relation  between size-change graphs}

Define  to hold iff 
\be[i)]
\item  and .
\item The subgraph of  restricted to  and  is a subset of .
\item Furthermore if  then either there is no edge from  in  or the only edge from  in  is 
, and if  then . 
\ee
\edfn

\noindent We have that , , target() = source() and target() = source() together imply  that  holds.

\blem \label{simulation}\rm{\bf Simulation Property}
\be[i)]
\item If  and  then there exist  with  and  such that .
\item If  and  with  then there exist  and possibly  such that 
either  or  with , , and in the last case .\\ 
The composite size-change graph for the double-call  will have the same edges as  because the  call generates an  graph.
\ee
\elem

\bcor For programs  and  with  it holds that:\\ 
If  then there exists  such that  and .\\
If  then there exist  such that  and .
\ecor

Also notice that if  then  by the definition of free variables for nonterminals. (By definition,  implies .)

\bprf Lemma \ref{simulation} is shown by induction on the tree for the proof of evaluation or call in the pure -calculus and uses the observation about free variables. Proof is in the appendix.
\eprf

\subsection{The subexpression property}

\bdfn Given a state  in the extended language, we define its
{\em expression support}  by

\edfn

\blem \label{lem-subexpression-ext}
{\rm (Subexpression property)} If  or  then
.
\elem
\bcor If
 then
. If
 then
.
\ecor

The proof of Lemma \ref{lem-subexpression-ext} follows the same lines
as the proof of Lemma \ref{lem-subexpression}. The proof for the rule
(Gram) is immediate from the definition of subexpressions in the
extended language. Proof omitted.


\subsection{Approximate extended semantics with size-change graphs}
\bdfn
\label{def-Ext-eval-approx}
{\rm(Approximate evaluation and call rules for extended semantics with size-change graphs)}. 
The judgement forms are now   and
, where , and  and  .








\edfn
\medskip

Putting the pieces together, we now show how to analyse any program in the
regular grammar-extended -calculus . Let  be a program in the extended language.
\bdfn\ 

\fl 


\edfn

\bthm The set   can be effectively computed 
from {\tt P}.\ethm
\bprf 
In the extended -calculus there is only a fixed number of subexpressions of {\tt P}, and
a fixed number of  
of possible size-change graphs with 

Thus 
can be computed in finite time by applying Definition \ref{def-Ext-eval-approx}
exhaustively, starting with {\tt P}, until no new graphs or 
subexpressions are obtained.
\eprf 



\subsection{Simulation properties of approximate extended semantics}

We will show the following properties of approximate extended semantics: 
\be[(1)]
\item Calls and evaluations for a program in {\em extended semantics with environments} can be stepwise simulated by {\em approximate extended semantics} with identical size-change graphs associated with corresponding calls and evaluations. To a call or evaluation in the extended -calculus with environments corresponds the same call or evaluation with environments removed.
\item 
Suppose   for programs  {\tt P},{\tt Q}. Then calls and evaluations for  in the pure lambda calculus with environments can be simulated by calls and evaluations in the approximate extended semantics for  using the relations   
and .
\item The extra edges in the size-change graphs in extended semantics can never give rise to incorrect termination analysis.
\ee

\blem \label{embExt}
Let  be a program in the extended language and .\\ 
If  then  in approximate semantics.\\
If  then  in approximate semantics.
\elem
\bprf
The proof is similar to the proof for approximation of the pure lambda-calculus \ref{abs-super} and \ref{abs-graphs}.
For rules (Value), (Operator), (Operand) it is immediate. The (Gram)-rule do not refer to the environment, hence the lemma holds if the (Gram)-rule has been applied. For rules (Call) and (Result) it holds by induction. For the (Var)-rule we need induction on the total size of the derivation, and we can argue as in the case of the pure lambda calculus.
\eprf


\blem \label{simulation-approx}
Let  be a program in the extended language and  a program in the pure -calculus with .

If  and  then there 
exist  with , ,  such that  and .

If  and  then there 
exist  with  ,,  such that  and either  or  where in the last case  is the composite size-change graph for the double call.
\elem

\bprf The lemma follows from the simulation property lemma \ref{simulation} together with lemma \ref{embExt}.
\eprf


\bthm\label{gamma-termination}\ 
\be[\em(1)]
\item Let  be a program in the extended language. If there is a program  in the pure lambda-calculus such that   and there exists an infinite call-sequence 
in the call-graph for  in the exact semantics, then there exists an infinite call-sequence with no infinitely descending thread in the call-graph for  in the approximate extended semantics.
\item It follows that if each infinite call-sequence  in the call-graphs for  in the approximate extended semantics has an infinitely descending thread, then  is -terminating.
\end{enumerate}
\ethm

\bprf 
(1): Assume an infinite call-sequence 
exists in the call-graph for . By the safety of the size-change graphs in the pure -calculus, the size-change graphs associated with this call sequence cannot have an infinitely descending thread. By lemma \ref{simulation-approx} there exists a simulating call-sequence in the call-graph for  such that  the corresponding size-change graphs are in the -relation. 
Let  be any such two corresponding -related size-change graphs from these call-sequences, . 
By the definition of the -relation it holds that the largest subgraph of , with  and  the same as   and ,  is equal to or a subset of . 
 We need to show that the possible extra variables in the size-change graphs for the simulating sequence in the call-graph for  can never take part in an infinitely descending thread. By the definition of the -relation it holds that 
an edge leaving from such a variable  must have have the form  if any exists in the simulating sequence. Also by the definition of the -relation, if  and  then . Hence either an extra thread in the size-change graphs going out from  will be finite or it will be infinitely equal , i.e. an extra variable can never take part in an infinitely descending thread in the simulating sequence.\\
(2) is a corollary to (1).
\eprf

\begin{exa}
The following is an example of a  program certified to terminate  by our proof method. The program computes  when applied to two arbitrary Church numerals for  and . In Section \ref{sec:examples} we analysed the program applied to Church numerals 3 and 4 (Example \ref{ex:fnx}).
\medskip

\fl Grammar for Church numerals:\hair\hair 
C ::= A\hair\hair
A ::= {\tt z}   {\tt s}{\tt @}A
\vair

\fl The program applied to two Church numerals:
\vair

{\tt\bt{lllll}
[n.n. & n    &&& -- n --\\
   & @ & [r.a.\fbox{11:}(r@\fbox{13:}(r@a))] && -- 
   g --\\
  & @ & [ k. p. q.(p@((k@p)@q))] && - succ-\\
  & @ & n ]   && -- x --\\\\
   @ & & C  && -- Church numeral --\\
   @ & & C  && -- Church numeral --
   \et}
\bigskip

Following is the output from program analysis. The analysis found
the following loops from a program point to itself with the associated
size-change graph and path. The first number refers to the program point,
then comes a list of edges and last a list of numbers, the other program
points that the loop passes through. The program points are found automatically by the analysis. The program points 30 and 32 are not written into the presentation of the program because they involve the subexpression A of a Church numeral. The subexpression associated with 30 is A and the subexpression associated with 32 is {\tt s@}A. The loops  from 30 to itself and from 32 to itself in the output correspond to the call sequence 
A{\tt s@}AA{\tt s@}A\ldots.

\bp
SELF SCGS no repetition of graphs: 

11  11: [(r,>,r)]                                     []
11  11: [(a,=,a),(r,>,r)]                             [13]
13  13: [(a,=,a),(r,>,r)]                             [11]
13  13: [(r,>,r)]                                     [11,11]
30  30: [(,>,),(s,=,s),(z,=,z)]   [32]
32  32: [(,>,),(s,=,s),(z,=,z)]   [30]

Size-Change Termination: Yes
\ep


\

\end{exa}
\section{Concluding matters}

We have developed a method based on The Size-Change Principle to show termination of a closed expression in the untyped -calculus. This is further developed to analyse if a program in the -calculus will terminate when applied to any input from a given input set defined by a tree grammar. The analysis is safe and the method can be  completely automated. We have a simple first implementation. The method certifies termination of many interesting recursive programs, including programs with mutual recursion and parameter exchange.

\subsubsection*{Acknowledgements.} The authors gratefully acknowledge 
detailed and constructive comments by Arne Glenstrup, Chin Soon 
Lee and Damien Sereni, and insightful comments by Luke Ong, David Wahlstedt and Andreas Abel.
\appendix


\section{Proof of Lemma \ref{lem-NIS-standard}}

\bprf 
: Assume . To show: CT has no infinite call chain starting with . 
The proof is by induction on the height of the proof tree. Each call rule of  \ref{lem-NIS-standard} is associated 
with a use of rule (ApplyS) from Definition 
\ref{def-call-by-value-evaluation}. So if  is a value, there is no call from . If  is concluded by rule (ApplyS), then  and  by induction there is no infinite call chain starting with ,  and . All call chains starting with  go  directly to one of these. So, there are no infinite call chains starting with .


 : Assume CT has no infinite call chain starting with . To show: .  
Since the call tree is finitely branching,
 by K\"{o}nig's lemma the whole call tree is finite, and 
 hence there exists a finite number  bounding the length of all branches.

We prove  that   for any expression in the call tree, by induction on the maximal length  of a call chain from 
. 

 {\tt e} is an abstraction that evaluates to itself.

 {\tt e} must be an application .
By rule (Operator) 
there is a call 
, 
and the maximal length of 
a call chain from  is less than . 
By induction there exists 
 such that . 
We  now  conclude by rule (Operand) 
that
. By induction
there exists  such that . 

All values are abstractions, so we can write 
.
We  now conclude by rule (Call) 
that
. 
 By induction again, 
 for some .
This gives us all premises for the (ApplyS) rule of
Definition \ref{def-call-by-value-evaluation}, so
 .
\eprf







\section{Proof of Lemma \ref{abs-super}}

\bprf  To be shown:
\hfill  \bt{ccccc} If  &and& , &then& 
. \\

\hfill  If    &and& , &then& .
\et
\vair

\fl We prove both parts of Lemma \ref{abs-super} by course-of-value induction over the size  of a deduction   by Definition \ref{def-evaluate-and-call-relation-environment} of the
assumption 

The deduction size may be 
thought of as the number of 
steps in the computation of 
 or  starting from .


The induction hypothesis  is that the Lemma holds for all 
deductions of size not exceeding .
This implies that the Lemma holds for all
calls and evaluations performed in the computation before the last 
conclusion giving 
( and ) or ( and ), i.e.,  the Lemma holds for premises of the  rule last applied, and 
{\em for any call and 
evaluation in the computation until then}.


Proof  is by cases on which rule is applied to conclude 
 or . 
In all cases we show that some corresponding abstract interpretation rules  
can be applied to 
give the desired conclusion. 

Base cases: Rule (Value), (Operator) and 
(Operand) in the exact semantics (def. \ref{def-evaluate-and-call-relation-environment}) are modeled by axioms (ValueA), 
(OperatorA) and 
(OperandA) in the abstract semantics (def. \ref{def-eval-approx}). These are the same as their 
exact-evaluation 
counterparts, after removal of  environments for  (ValueA) and 
(OperatorA), 
and a premise as well for (OperandA). 
Hence the Lemma holds if one of these rules was the last one applied.

The (Var) rule is, however, rather different from the (VarA) rule.
If  (Var)  was applied to a variable {\tt x} 
then the assumption is ( and 
).
In this case  
and
.   
The total size of the deduction 
(of both parts together) 
is . 

Now  begins from 
the empty environment, and we know all calls are from state to state.
The only possible way {\tt x} can have been bound is 
by a previous use of the (Call) rule, 
the only rule that extends an environment.\footnote{This must have occurred in the part
.}

The premises of the (Call) rule require that 
operator and operand in an application  have previously been evaluated. So it must be the case that there exist  and  such that 
( and 
 and 
) and the size of both deductions are strictly smaller than . 
By the Subexpression Lemma, . 
By induction, 
Lemma \ref{abs-super} holds for both  and 
, so  and 
 in the abstract semantics. 
Now we have all premises of rule (VarA),
so we can conclude that  as required.

For remaining rules (Apply) and (Call), when we assume that the Lemma holds for the premises in 
the rule applied to conclude  or , 
then this gives us the premises for the corresponding rule for abstract interpretation. 
From this we can conclude the desired result.
\eprf

\section{Proof of Lemma \ref{lem-well-founded}}

\bprf
Define the length  of an expression e by:

For any expression {\tt e},  is a natural number .  For a program, the length of the initial expression bounds all lengths of occurring expressions.\\

\fl
Define for a state  the height  of the state to be the height of the environment:

So,  the maximum of the empty set, and for any state  is a natural number .
Let  stand for lexicographic order relation on pairs of natural numbers,
hence  is well-founded.
We prove that the relation  on states is well-founded
by proving that

implies
that


First, consider . Clearly, if   then
. 
Hence even though  might be  larger than , 
it holds that in the lexicographic order  
.

Now, consider . If  then

and , hence
in the lexicographic order
.
Trivially,  implies
.

Recall, by definition  is the transitive closure 
of , and  
holds when  and .
So, from the derivations above we can conclude that
 implies
,
hence the relation  on states is well-founded.







\eprf



\section{Proof of Theorem \ref{graphs_safe}}



\bprf 
For the 
``safety'' theorem we use induction on proofs of 
 or
. 
Safety of the constructed graphs  for 
rules (ValueG), (OperatorG) and (OperandG)
is immediate by Definitions \ref{def-safe-call-and-evaluation}  
and \ref{def-value-decrease}. 
\vair

In the following  are variables and  can be variables or .



\vair
The variable lookup rule {\bf (VarG)} yields
 with
 and
. 
By Definition \ref{def-graph-valuation},
,
  so arc    satisfies 
Definition \ref{def-safe-call-and-evaluation}. 
Further, if 
 then
. 
Thus 
 as required.

\vair
The rule  {\bf (CallG)} concludes , where
 and 
 and
. Its
premises are
 and
. 
We assume inductively that   is safe for
 and that
 is safe for . Let .


We wish to show safety: that 
 implies 
, and  
 implies 
.
By definition of  and ,  

breaks into 7 cases:

\vair
\fl {\em Case 1:} 
   
because . 
By safety of ,
.
Thus, as required,


\vair
\fl {\em Case 2:} 
   
because .
Like Case 1.

\vair
\fl   {\em Case 3:} 
    
because , 
then  by the definition of  and then .
By safety of ,
.
Thus, as required,



\vair
\fl {\em Case 4:} 
   
because . Then it holds that either  is a variable-name or  . 
Now  in  refers to , so
  by safety of .
Thus, as required,



\vair
\fl {\em Case 5:} 
 because  and 

because . 
By safety of , 
.
Thus, as required,


\vair
\fl {\em Case 6:} 
 because  and

because . 
Like Case 5.


\vair 
\fl {\em Case 7:}
 because  and

because .
By safety of , 
.
Thus, as required,



\vair
The rule {\bf (ApplyG)} concludes   
from premises

and
, where
 and .
We assume inductively 
that  is safe for 
and  is safe for .
Let . 


We wish to show that  is safe: that 
 implies
, and
 implies
 ( can be variables or ).
First, consider the case .
Definition \ref{def-size-change-terminology} 
implies

and 
for some . Thus by the inductive assumptions we have
, as required.



Second, consider the case 
.
Definition \ref{def-size-change-terminology} 
implies

and 
for some , where either one or both of  are . 
By the inductive assumptions we have
 and 
, and 
one or both of
 and 
 hold.
By Definition of  and  this implies that 
, as required. 


\eprf



\section{Proof of Lemma \ref{abs-graphs}}

\bprf 
The rules are the same as in Section \ref{def-eval-approx}, 
only extended with size-change graphs. 
We need to add to Lemma \ref{abs-super} that the size-change graphs 
generated for
calls and evaluations can also be generated by the abstract interpretation. 
The proof is by cases on which rule is applied to conclude 
 or . 

We build on Lemma \ref{abs-super}, and we saw in the proof of this that 
in abstract interpretation we can always use a rule corresponding to 
the one used in exact computation to prove corresponding steps. 
The induction hypothesis is that the Lemma holds for the premises of the rule 
in exact semantics. 

Base case (VarAG): By Lemma \ref{abs-super} 
we have  implies 
. The size-change graph built in (VarAG) 
is derived in the same way from {\tt x} and  
as in rule (VarG), and they will therefore be identical.

For other call- and evaluation rules without premises, 
the abstract evaluation rule 
is as the exact-evaluation rule, only with environments removed, and 
the generated size-change graphs 
are not influenced by environments. Hence the Lemma will hold if these rules are applied.

For all other rules in a computation: When we know that 
Lemma \ref{abs-super} holds and 
assume that Lemma \ref{abs-graphs} hold for the premises, then we 
can conclude that 
if this rule is applied, then Lemma \ref{abs-graphs} holds by the 
corresponding rule from 
abstract interpretation. 
\eprf
\section{Proof of Lemma \ref{simulation}}
\bprf By induction on the tree for the proof of evaluation or call in the pure -calculus.\\
Possible cases of the structure of  and  in -related states:\smallskip

\bt{rlccrlccrl}
&& & &
&& & &
&\\
&& & &
&& & &
&\\
\et
\medskip

Base cases, evaluations and calls in pure -calculus by rules without premisses.
\medskip

Case : No calls from .\\ 
\fl (Var)-rule,  and . Beginning from -related states, by defintion of the relation  we have  and .  and the generation of size-change graphs gives that the restriction of  to  equals , hence . \\
\\
Case : No calls from . \\
(Value)-rule, 
 
and . .\\
\\
Case :\\ 
(Operator)-rule,  and 
.Beginning from -related states, by defintion of the relation  we have . Then \\
\\
Case : \\
(Var)-rule:  where .  
By the definition of  we must have . This againg by lemma \ref{prod-to-form} gives that we must have . Then  by (Gram)-rule, and we have . Also  where  by (Var)-rule. 
The edges in  are the same as the edges in .
Hence by (Result)-rule . 
As before  and .\\
\\
Cases  with (Value)-rule, and  with (Operator)-rule: Similarly by use of lemma \ref{prod-to-form} and reasoning as above. We will use the rules (Gram)(Value) (Result) and (Gram)(Operator) respectively, where (Value) and (Operator) do not have premises.\\
\\
Step cases.\\
\\
Case .  by (Operand)-rule.
It follows from the definition of  that also  hence by IH since  then also  and then  and by the definition of  we have , .\\
\\
The next case is the one that requires the most consideration to see that we stay within the -relation. Assume we know for graphs , that the restriction of  to source and target of  is a subset of . Notice, if  and  , then for testing  we only need to look at which edges leaves from , we do not need to care about if other edges goes into .\\
\\
Case .  by (Call)-rule, where we have the premises  and .  


It follows from the definition of  that also  and . Hence by IH since  then also  where  and . Then by definition of values, relations  and  we must have . Also by IH since  then also  where  and . Then we have the premises to conclude . By definition of  we have . 
We notice that  and therefore .\\
We consider different possibilities for the generated graphs:

If  but  then we can have some extra edges going to  in extended semantics where we will have no edges to  in pure semantics because  is not in the target, but this is acceptable in the -relation. There can also be some extra edges going to  in pure semantics where no edges go to  in exact semantics, but as  is within the codomain in pure semantics, this is also acceptable in the -relation. Since  it will still hold that . 

If  then also  and if  then , in these cases since  and  also . \\
\\
Case  with  by(Operand)-rule. By the definition of  we must have . This againg by lemma \ref{prod-to-form} gives that we must have . Then  by (Gram)-rule, and we have . Then we have seen that  with ,  and we have that the edges of  are the same as the edges of () hence .\\
\\
Case  with (Call)-rule : Similarly as before we have  by (Gram)-rule, and we have . We can now use the derivation above and with the notation from above we have  with  and . Looking into the derivation of  we find that the edges of  are the same as the edges of ().\\
\\
Case ,  by (Result)-rule, where we have the premises  and , : 
By IH since  then  with , and , . Again by IH since  then  with  and . Let  then . If  we have the premises to conclude . If  by lemma \ref{push-S} we have  and we have the premises to conclude , and by applications of (Result)-rule once more in the extended semantics we can also conclude  where the edge set of  is the same as the edge set of .
\eprf



\nocite{*}
\bibliographystyle{alpha}

\begin{thebibliography}{MMM}

\bibitem{abel}
Abel, A.: 2004, Termination Checking with Types.
\newblock {\em RAIRO - Theoretical Informatics and Applications, Special Issue:
  Fixed Points in Computer Science (FICS'03)} { 38}(4), 277--319.

\bibitem{abelthesis}
Abel, A.: 2006 A Polymorphic Lambda-Calculus with Sized Higher-Order
		  Types.
\newblock Ph.d.\ thesis, Ludwig-Maximilians-Universit\"at M\"unchen



\bibitem{barthe}
G. Barthe, M. J. Frade, E. Gim\'{e}nez, L. Pinto, T. Uustalu.
Type-based termination of recursive definitions. 
Mathematical. Structures in Comp. Sci. 14:97--141, 
2004. 

\bibitem{CousotCousot}
Cousot, P. and R. Cousot: 1977, Abstract interpretation: A unified lattice
  model for static analysis of programs by construction of approximation of
  fixpoints.
\newblock In: {\em {POPL} 77: 4th {ACM} {SIGPLAN}-{SIGACT} Symposium on
  Principles of Programming Languages}. pp. 238--252.
  
\bibitem{frederiksen-jones}
C.C.\ Frederiksen and N.D.\ Jones.
Running-time Analysis and Implicit Complexity.
unpublished, 2006.


\bibitem{giesl-arts}
T.\ Arts and J.\ Giesl.
Termination of Term Rewriting Using Dependency Pairs. 
{Theoretical Computer Science 236:133--178}, 2000.

\bibitem{giesl-thiemann}
Giesl, J., R. Thiemann, and P. Schneider-Kamp.
Proving and disproving
  termination of higher-order functions.
\newblock Technical report, RWTH Aachen, 2005.


\bibitem{haskell}
J.\ Giesl, S.\ Swiderski,
P.\ Schneider-Kamp, R.\ Thiemann.
Automated Termination Analysis for Haskell: From Term Rewriting
               to Programming Languages. 
In RTA 2006: Rewriting Techniques and Applications:
(Frank Pfenning, eds), 
 pp. 297-312. Volume 4098 of Lecture 
Notes in Computer Science, 2006. 



\bibitem{girard}
J.Y.\ Girard, Y.\ Lafont, P.\ Taylor.
{\em Proofs and Types}.
Cambridge University Press, 1989.


\bibitem{glenstrup-jones}
N.D.\ Jones and A.\ Glenstrup.
Partial Evaluation Termination Analysis and 
   Specialization-Point Insertion. 
ACM Transactions on Programming Languages and Systems: 27, 6: 1147--1215,
2005. 

\bibitem{Jones:FALambda}
N.D.\ Jones: Flow Analysis of Lambda Expressions, 
{\em ICALP 1981}, {\em Lecture  Notes in Computer Science}. Springer-Verlag (1981).


\bibitem{rta}
N.D.\ Jones and N. Bohr.
Termination analysis of the untyped -calculus. 
In RTA 2004: Rewriting Techniques and Applications: 
(V.\ van Oostrom, eds.), pp. 1--23. Volume 3091 of Lecture 
Notes in Computer Science. Springer. June, 2004. 


\bibitem{jonesnielson}
N.D.\ Jones and F.\ Nielson.
Abstract Interpretation: 
a Semantics-Based Tool for Program Analysis. 
In Handbook of Logic in Computer Science, pp. 527-629. 
Oxford University Press, 1994.  

\bibitem{popl01}
C.S.\  Lee, N.D.\ Jones and A.M.\ Ben-Amram
\newblock The Size-Change Principle for Program Termination
\newblock POPL 2001: Proceedings  ACM SIGPLAN-SIGACT Symposium on
          Principles of Programming Languages, January 2001.



\bibitem{lee-ptime-bta}
C.S.\  Lee.
Finiteness analysis in polynomial time. 
In Static Analysis: 9th International Symposium, SAS 2002 
(M Hermenegildo and G Puebla, eds.), pp. 493-508. Volume 2477 of Lecture 
Notes in Computer Science. Springer. September, 2002. 

\bibitem{lee-poly-time-analysis}
C.S.\ Lee.
Program termination analysis in polynomial time.
In Generative Programming and Component Engineering:
ACM SIGPLAN/SIGSOFT Conference, GPCE 2002 
(D Batory, C Consel, and W Taha, eds.), pp. 
218-235. Volume 2487 of Lecture Notes in Computer Science.

\bibitem{lee-thesis}
C.S.\  Lee.
\newblock Program Termination Analysis and the Termination of Offline 
          Partial Evaluation
\newblock Ph.D. thesis, University of Western Australia, March 2001.

\bibitem{plotkin}
G.D.\ Plotkin. 
Call-by-name, call-by-value and the lambda-calculus. 
Theoretical Computer Science, 1, 1975.

\bibitem{serenijones}
D.\  Sereni, N.D.\ Jones.
Termination Analysis of Higher-Order Functional Programs
In APLAS 2005: The Third Asian Symposium on
Programming Languages and Systems 
( Kwangkeun Yi, ed.), pp. 281--297. Volume 3780 of Lecture 
Notes in Computer Science. Springer. November, 2005. 


\bibitem{sereni2}
D.\  Sereni.
-SCT and simple types.
E-mail communication. April, 2005. 

\bibitem{sereni}
D.\  Sereni.
\newblock Termination Analysis of Higher-Order Functional Programs
\newblock D.Phil thesis, OUCL (Oxford University Computing 
Laboratory),  2006.




\bibitem{shivers1991}
D.\  Olin Shivers.
\newblock Control-Flow Analysis of Higher-Order Languages
\newblock D.Phil thesis, Carnegie Mellon University, 1991.

\bibitem{shivers2004}
D.\  Olin Shivers.
\newblock Higher-order control-flow analysis in retrospect:
    Lessons learned, lessons abandoned
\newblock In \emph{20 Years of the ACM SIGPLAN Conference on 
         Programming Language Design and Implementation (1979-1999): 
         A Selection}, 
    pages 269--270,
    editor Kathryn S.~McKinley, 2004.

\bibitem{tait}
W.W.\ Tait.
Intensional interpretation of functionals of finite type I. 
{Journal of Symbolic Logic 32:198--212}, 1967.


\bibitem{toyama}
Toyama, Y.,
Termination of S-expression rewriting systems: Lexicographic
  path ordering for higher-order terms.
\newblock In: {\em Proceedings of the 15th International Conference on
  Rewriting Techniques and Applications (RTA 2004)}, Vol. 3091 of {\em Lecture
  Notes in Computer Science}. pp. 40--54, 2004.



\bibitem{wahlstedt}
D. Wahlstedt.
Type Theory with First-Order Data Types and Size-Change Termination.
\newblock Licentiate thesis, Chalmers University of Technology, Gothenburg, Sweden, 2004.

\bibitem{wahlstedt1}
D. Wahlstedt.
Dependent Type Theory with Paraetrized First-Order Data Types and Well-Founded Recursion.
\newblock Ph.D.\ thesis, Chalmers University of Technology, Gothenburg, Sweden, 2007.


\bibitem{xi}
Hongwei Xi.
 Dependent Types for Program Termination Verification, 
 Journal of Higher-Order Symbolic Logic, 15(1), pp. 91--131, 2002.

\end{thebibliography}




\end{document}
