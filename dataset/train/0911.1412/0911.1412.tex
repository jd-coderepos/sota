\documentclass[envcountsame,runningheads]{llncs}

\bibliographystyle{plain}

\usepackage{graphicx}
\usepackage{multirow}
\usepackage{latexsym}
\usepackage{amsmath,amssymb,amstext}
\usepackage{graphicx}
\usepackage{wasysym}
\usepackage{float}
\usepackage{enumerate}
\usepackage[arrow, matrix, curve]{xy}
\usepackage[justification=centering,singlelinecheck=off]{caption}
\usepackage{color}
\usepackage{url}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{sidecap}
\usepackage{comment}
\usepackage{xcomment}
\usepackage{bussproofs} \floatstyle{plain}
   \newfloat{Figure}{tp}{Fig}


\newcommand{\pairlft}{{\langle}}
\newcommand{\pairrgt}{{\rangle}}
\newcommand{\pairsep}{{,\,}\nix}
\newcommand{\pairstr}[1]{\pairlft#1\pairrgt}
\newcommand{\pair}[2]{\pairstr{#1\pairsep#2}}
\newcommand{\triple}[2]{\pair{#1\pairsep#2}}
\newcommand{\quadruple}[2]{\triple{#1\pairsep#2}}
\newcommand{\quintuple}[2]{\quadruple{#1\pairsep#2}}
\newcommand{\tuple}{\pairstr}

\newcommand{\seqlft}{{\langle}}
\newcommand{\seqrgt}{{\rangle}}
\newcommand{\seq}[1]{\seqlft#1\seqrgt}


\newcommand{\nat}{\mathbb N}
\newcommand{\pnat}{\mathbb{N}_{{>}0}}
\newcommand{\zer}{0}
\newcommand{\ssuc}{\msf{s}}
\newcommand{\suc}{\funap{\ssuc}}
\newcommand{\zz}{\mathbb Z}

\newcommand{\aset}{A}\newcommand{\bset}{B}\newcommand{\ssetin}{{\in}}
\newcommand{\sseteq}{{=}}
\newcommand{\ssetneq}{{\neq}}
\newcommand{\ssetle}{{\subseteq}}
\newcommand{\ssetlt}{{\subset}}
\newcommand{\ssetge}{{\supseteq}}
\newcommand{\setin}{\relap{\ssetin}}
\newcommand{\seteq}{\relap{\sseteq}}
\newcommand{\setneq}{\relap{\ssetneq}}
\newcommand{\setne}{\setneq}
\newcommand{\setle}{\relap{\ssetle}}
\newcommand{\setlt}{\relap{\ssetlt}}
\newcommand{\setge}{\relap{\ssetge}}
\newcommand{\setemp}{{\varnothing}}\newcommand{\ssetunion}{{\cup}}
\newcommand{\setunion}{\relap{\ssetunion}}
\newcommand{\ssetintersect}{{\cap}}
\newcommand{\setintersect}{\relap{\ssetintersect}}
\newcommand{\ssetprod}{{\times}}
\newcommand{\setprod}{\relap{\ssetprod}}
\newcommand{\ssetfun}{{\rightarrow}}
\newcommand{\setfun}{\binap{\ssetfun}}
\newcommand{\ssetpartfun}{{\rightharpoonup}}
\newcommand{\setpartfun}{\binap{\ssetpartfun}}
\newcommand{\setop}[1]{\setfun{#1}{#1}}
\newcommand{\setopn}[2]{\setfun{#2^{#1}}{#2}}
\newcommand{\sfunin}{{:}}
\newcommand{\funin}{\mathrel{\sfunin}}
\newcommand{\afun}{f}
\newcommand{\afunap}{\funap{\afun}}
\newcommand{\iafun}{\sub{\afun}}
\newcommand{\iafunap}[1]{\funap{\iafun{#1}}}
\newcommand{\bfun}{g}
\newcommand{\pto}{\rightharpoonup}

\newcommand{\sdomain}{\mrm{dom}}
\newcommand{\domain}{\funap{\sdomain}}


\newcommand{\spowerset}{\mcl{P}}
\newcommand{\powerset}{\funap{\spowerset}}
\newcommand{\sfuncmp}{{\circ}}
\newcommand{\funcmp}{\binap{\sfuncmp}}
\newcommand{\sfuninf}{\siosqinf}
\newcommand{\funinf}{\binap{\sfuninf}}
\newcommand{\sfunsup}{\siosqsup}
\newcommand{\funsup}{\binap{\sfunsup}}
\newcommand{\invfun}[1]{#1^{-1}}

\newcommand{\floor}[1]{\lfloor#1\rfloor}
\newcommand{\ceil}[1]{\lceil#1\rceil}

\newcommand{\slcm}{\mrm{lcm}}
\newcommand{\lcm}{\funap{\slcm}}

\newcommand{\scosubtr}{{\dotminus}}
\newcommand{\cosubtr}{\binap{\scosubtr}}

\newcommand{\sbisimilar}{{\underline{\leftrightarrow}}}
\newcommand{\bisimilar}{\relap{\sbisimilar}}
\newcommand{\xbisimilar}{\mathrel{\sbisimilar}}

\newcommand{\finsets}{\funap{{\cal P}_{\text{f}}}}
\newcommand{\finmulsets}{\funap{{\cal M}}}
\newcommand{\finseqs}{\funap{{\mit Seqs}_{\text{f}}}}

\newcommand{\aseq}{\sigma}


\newcommand{\nix}{}
\newcommand{\id}[1]{#1}
\newcommand{\sub}[2]{#1_{#2}}
\newcommand{\super}[2]{#1^{#2}}
\newcommand{\binap}[3]{#2\mathbin{#1}#3}
\newcommand{\funap}[2]{#1(#2)}
\newcommand{\funnap}[2]{\funap{\super{#1}{#2}}}
\newcommand{\indap}[2]{{\sub{#1}{#2}}}
\newcommand{\relap}[3]{#2\mathrel{#1}#3}
\newcommand{\bfunap}[3]{\funap{#1}{#2,#3}}
\newcommand{\tfunap}[4]{\funap{#1}{#2,#3,#4}}
\newcommand{\labap}[2]{{\stackrel{#2}{#1}}}
\newcommand{\where}{\mathrel{|}}


\newcommand{\ARS}{ARS}
\newcommand{\aobjects}{A}
\newcommand{\bobjects}{B}
\newcommand{\aobject}{a}
\newcommand{\bobject}{b}
\newcommand{\asteps}{\Phi}
\newcommand{\bsteps}{\Psi}
\newcommand{\astep}{\phi}
\newcommand{\bstep}{\psi}
\newcommand{\ssrc}{{\sf src}}
\newcommand{\stgt}{{\sf tgt}}
\newcommand{\src}{\funap{\ssrc}}  
\newcommand{\tgt}{\funap{\stgt}}
\newcommand{\aARS}{{\cal A}}


\newcommand{\AKeq}{} \newcommand{\ACeq}{} \newcommand{\BHeq}{} 



\newcommand{\APHS}{A\hspace*{-0.3pt}P\hspace*{-0.6pt}H\hspace*{-0.4pt}S}
\newcommand{\ANDS}{ANDS}
\newcommand{\nAHS}{\mbox{n-AHS}}
\newcommand{\aprfsys}{{\cal S}}
\newcommand{\aLRsystem}{{\cal S}}
\newcommand{\aAPHS}{{\cal H}}
\newcommand{\aANDS}{{\cal N}}
\newcommand{\aHS}{{\cal H}}
\newcommand{\extd}[1]{{#1 '}}
\newcommand{\extsysbyrule}[2]{{{#1}{+}{#2}}}
\newcommand{\arule}{R}
\newcommand{\brule}{\rho}
\newcommand{\insts}{{\mit Insts}}
\newcommand{\instsR}[1]{{\mit Insts}_{#1}} 
\newcommand{\forms}{{\mit F\hspace*{-1.1pt}o}}
\newcommand{\formsH}[1]{{\mit F\hspace*{-1.1pt}o}_{#1}}
\newcommand{\axioms}{{\mit Ax}}
\newcommand{\rules}{{\mit Ru}}
\newcommand{\ainst}{\iota}
\newcommand{\names}{\mit{N\hspace*{-1.2pt}a}}
\newcommand{\namedAxioms}{{\mit n\hspace*{-0.4pt}Ax}}
\newcommand{\namedRules}{{\mit n\hspace*{-0.4pt}Ru}}
\newcommand{\sname}{{\sf name}}
\newcommand{\name}{\funap{\sname}}
\newcommand{\aname}{{\mit na}}
\newcommand{\anamedAxiom}{{\hat{A}}}
\newcommand{\anamedRule}{{\hat{R}}}
\newcommand{\aunnamedRule}{R}

\newcommand{\sAPHSrules}{\mcl{R}}
\newcommand{\APHSrules}{\funap{\sAPHSrules}}
\newcommand{\sANDSrules}{\mcl{R}}
\newcommand{\ANDSrules}{\funap{\sAPHSrules}}

\newcommand{\sprem}{{\sf prem}}
\newcommand{\sconcl}{{\sf concl}}
\newcommand{\prem}{\funap{\sprem}}  
\newcommand{\concl}{\funap{\sconcl}}  
\newcommand{\sarity}{{\sf arity}}
\newcommand{\arity}{\funap{\sarity}}


\newcommand{\spremR}[1]{{{\sf prem}_{#1}}}
\newcommand{\premR}[1]{\funap{\spremR{#1}}}
\newcommand{\sconclR}[1]{{{\sf concl}_{#1}}}
\newcommand{\conclR}[1]{\funap{\sconclR{#1}}}  
\newcommand{\sarityR}[1]{{{\sf arity}_{#1}}}
\newcommand{\arityR}[1]{\funap{\sarityR{#1}}} 

\newcommand{\spremi}[1]{{\sprem^{(#1)}}}
\newcommand{\premi}[1]{\funap{\spremi{#1}}}

\newcommand{\spremiR}[2]{\sprem_{#2}^{(#1)}}
\newcommand{\premiR}[2]{\funap{\spremiR{#1}{#2}}}

\newcommand{\sassm}{{\sf assm}}
\newcommand{\assm}{\funap{\sassm}}
\newcommand{\smassm}{{\sf massm}}
\newcommand{\massm}{\funap{\smassm}}
\newcommand{\somassm}{{\sf omassm}}
\newcommand{\omassm}{\funap{\somassm}}
\newcommand{\sdmassm}{{\sf dmassm}}
\newcommand{\dmassm}{\funap{\sdmassm}}
\newcommand{\spmassm}{{\sf pmassm}}
\newcommand{\pmassm}{\funap{\spmassm}}

\newcommand{\sassmR}[1]{{{\sf assm}_{#1}}}
\newcommand{\assmR}[1]{\funap{\sassmR{#1}}}
\newcommand{\smassmR}[1]{{{\sf massm}_{#1}}}
\newcommand{\massmR}[1]{\funap{\smassmR{#1}}}
\newcommand{\somassmR}[1]{{{\sf omassm}_{#1}}}
\newcommand{\omassmR}[1]{\funap{\somassmR{#1}}}
\newcommand{\sdmassmR}[1]{{{\sf dmassm}_{#1}}}
\newcommand{\dmassmR}[1]{\funap{\sdmassmR{#1}}}
\newcommand{\spmassmR}[1]{{{\sf pmassm}_{#1}}}
\newcommand{\pmassmR}[1]{\funap{\spmassm{#1}}}

\newcommand{\spmassmi}[1]{{\spmassm^{(#1)}}}
\newcommand{\pmassmi}[1]{\funap{\spmassmi{#1}}}

\newcommand{\spmassmiR}[2]{{\smassm^{(#1)}_{#2}}}
\newcommand{\pmassmiR}[2]{\funap{\spmassmi{#1}{#2}}}

\newcommand{\ModusPonens}{{\normalfont MP}}


\newcommand{\boldf}[1]{{\bf {#1}}}
\newcommand{\bs}{\boldsymbol}
\newcommand{\mcl}{\mathcal}
\newcommand{\ul}{\underline}
\newcommand{\ol}{\overline}

\newcommand{\todo}[1]{}

\newcommand{\sdefdby}{{:}{=}}

\newcommand{\defdby}{\mathrel{\sdefdby}}
\newcommand{\sred}{{\rightarrow}}
\newcommand{\red}{\mathrel{\sred}}
\newcommand{\sredR}[1]{{\sred_{#1}}}
\newcommand{\redR}[1]{\mathrel{\sredR{#1}}}
\newcommand{\sredi}{{\leftarrow}}
\newcommand{\redi}{\mathrel{\sredi}}
\newcommand{\sredsym}{{\leftrightarrow}}
\newcommand{\redsym}{\mathrel{\sred}}
\newcommand{\smred}{{\twoheadrightarrow}}
\newcommand{\mred}{\mathrel{\smred}}
\newcommand{\smredi}{{\twoheadleftarrow}}
\newcommand{\mredi}{\mathrel{\smredi}}
\newcommand{\sconv}{{=}}
\newcommand{\conv}{\mathrel{\sconv}}
\newcommand{\sbis}{{\sim}}
\newcommand{\bis}{\mathrel{\sbis}}
\newcommand{\spbis}{\sbis'}
\newcommand{\pbis}{\mathrel{\spbis}}
\newcommand{\sinfred}{\threeheadrightarrow}
\newcommand{\infred}{\mathrel{\sinfred}}
\newcommand{\sinfredi}{{\threeheadleftarrow}}
\newcommand{\infredi}{\mathrel{\sinfredi}}
\newcommand{\sired}{\indap{\sred}}
\newcommand{\ired}[1]{\mathrel{\sired{#1}}}
\newcommand{\siredi}{\indap{\sredi}}
\newcommand{\iredi}[1]{\mathrel{\siredi{#1}}}
\newcommand{\simred}{\indap{\smred}}
\newcommand{\imred}[1]{\mathrel{\simred{#1}}}
\newcommand{\simredi}{\indap{\smredi}}
\newcommand{\imredi}[1]{\mathrel{\simredi{#1}}}
\newcommand{\siredsym}{\indap{\sredsym}}
\newcommand{\iredsym}[1]{\mathrel{\siredsym{#1}}}

\newcommand{\siconv}{\indap{\sconv}}
\newcommand{\iconv}[1]{\mathrel{\siconv{#1}}}
\newcommand{\atrs}{{\cal T}}


\newcommand{\saruledes}{\Phi}
\newcommand{\aruledes}{\funap{\Phi}}
\newcommand{\srule}{R}
\newcommand{\rulei}{\indap{\srule}}


\newcommand{\aderiv}{{\cal D}}
\newcommand{\aform}{A}
\newcommand{\bform}{B}
\newcommand{\cform}{C}
\newcommand{\asetforms}{\Sigma}
\newcommand{\bsetforms}{\Delta}
\newcommand{\csetforms}{\Pi}

\newcommand{\slogand}{{\wedge}}
\newcommand{\logand}{\mathrel{\slogand}}
\newcommand{\slogor}{{\vee}}
\newcommand{\logor}{\mathrel{\slogor}}
\newcommand{\sAndElim}{{\slogand\text{E}}}
\newcommand{\sAndElimLeft}{{\slogand\text{E}_{\text{L}}}}
\newcommand{\sAndElimRight}{{\slogand\text{E}_{\text{R}}}}

\newcommand{\sconsrel}{\vdash}
\newcommand{\consrel}[2]{{#1 \mathrel{\sconsrel} #2}}
\newcommand{\sconsrelH}[1]{{\sconsrel_{#1}}}
\newcommand{\consrelH}[3]{{#2 \mathrel{\sconsrelH{#1}} #3}}

\newcommand{\sset}{\text{\normalfont set}}
\newcommand{\set}{\funap{\sset}}

\newcommand{\asubst}{\sigma}
\newcommand{\bsubst}{\tau}

\newcommand{\atheory}{{\cal T}}



\newcommand{\modlogicK}{{\bf K}}
\newcommand{\modlogicT}{{\bf T}}
\newcommand{\modlogicSfour}{{\bf S4}}
\newcommand{\modlogicSfive}{{\bf S5}}
\newcommand{\Necessitation}{{\normalfont NR}}
\newcommand{\necessite}[1]{{\Box{#1}}} \newcommand{\figpath}{figs}

\begin{document} 

\title{From Abstract Rewriting Systems\\ to Abstract Proof Systems}
   
\author{Clemens Grabmayer}
\institute{
    Universiteit Utrecht,
    Department of Philosophy\\
    Heidelberglaan 8,
    3584 CS Utrecht,
    The Netherlands\\
    \email{clemens@phil.uu.nl}
}
\maketitle




\begin{abstract}
Some personal recollections on the introduction of `abstract
  proof systems' as a framework for formulating syntax-independent,
  general results about rule derivability and admissibility.
  With a particular eye on the inspiration I owe to Roel de Vrijer:
the analogy with abstract rewriting systems.
\end{abstract}



\begin{flushright}
\emph{For Roel de~Vrijer with my best wishes\\
        on the occasion of his 60 birthday
} 
\end{flushright}


\section{Introduction}
  \label{sec:intro}



As a first aim\footnote{It turned out that work at this `first aim' eventually
            developed into my thesis \cite{grab:2005}.}
in my Ph.D.~project as \emph{AIO} at the VU-Amsterdam,
Jan Willem Klop suggested to me to investigate the 
proof-theoretic relationships between three kinds of proof systems for 
recursive type equivalence: 
a Hilbert-style proof system~\ACeq\ by Amadio and Cardelli (1993),
a coinductively motivated proof system~\BHeq\ by Brandt and Henglein (1998),
and a proof system~\AKeq\ by Ariola and Klop (1995)
for consistency-checking with respect to recursive type equivalence.
While originally formulated as a sequent-style calculus, the system of Brandt
and Henglein has a straightforward reformulation in natural-deduction style. 
The system of Ariola and Klop can be formulated as a tableau system. 

The easiest kind of relationship turned out to hold between the Brandt--Henglein 
and Ariola--Klop systems: proofs in \BHeq\ are, basically, mirror-images of 
`consistency unfoldings' (successful finite consistency-checks,
comparable to tableaux proofs) in \AKeq.\footnote{Jan Willem Klop had observed this mirroring property in examples
    before, and pointed me to this phenomenon.}
The proof-theoretic relationships of both systems with the Amadio--Cardelli system,
however, are considerably less straightforward. 
Although also in this case I found proof-transformations 
in both directions fairly soon, these transformations were quite complicated, 
and at least in part had the flavour of \emph{ad hoc} solutions.
The situation was theoretically unsatisfying insofar as a frequently
encountered situation, at the time of constructing these proof-transformations,
was the following.
While having shown that a particular rule~ of a proof system~
can always be eliminated from a derivation in an extension~
of another system~ by an effective procedure,
I was not sure at all whether applying such an elimination-procedure
was in fact essential. Perhaps instances of~ could always
be modelled by derivations in~,
and I only had failed to find some very easy demonstration of this fact.
In other words, by having only shown `admissibility' of~ in~,
I had not excluded the possibility that  was actually `derivable'
in~. 

For this reason I got interested in the relationship between, on the one hand,
the notions of rule derivability and rule admissibility,
and on the other hand, the precise manner of how rules can be eliminated
from derivations: either by `mimicking' derivations or by elimination procedures.
The notions of derivability and admissibility of inference rules date
back at least to Kleene \cite{klee:1952} (1952) and Lorenzen \cite{lore:1955} (1955),
and have since then been used for the analysis of concrete
proof calculi, and, this predominantly concerns rule admissibility, 
of what kinds of 
inferences a particular semantically given logic admits\footnote{An impressive body of work concerning this question is the study of
    admissible rules in intuitionistic propositional logic (IPC)
    by, to mention only a few names, Friedman, Rasiowa, Harrop, Rybakov, 
    Visser, de~Jongh, Ghilardi, and Iemhoff.}.
Notwithstanding the familiarity of the concepts of rule derivability and admissibility,
the impression I got from the literature was that
these notions are usually defined only for concrete proof systems, and not 
in an abstract way. Furthermore, I did not find definitions that
applied to natural-deduction style systems directly (definitions which
I could immediately have applied for the Brandt--Henglein system \BHeq),
nor a presentation that explains the general practical relevance
of rule derivability and admissibility for \emph{interpretational proof theory},
and that is, for `syntactical translations of one formal theory into the other'
\cite{troe:schw:2000}.

However, I came across definitions of rule derivability and admissibility  
in the book \cite[p.70]{hind:seld:1986} of Hindley and Seldin, definitions that I found
appealing because they are based on an abstract notion of proof system
(`formal system'). 
While these definitions only pertain to Hilbert-style proof systems,
and while only basic properties are stated for rule
derivability and admissibility in \cite{hind:seld:1986},
two lemmas there (Lemma~6.14 and Lemma~6.15) stimulated me to think
about definitions for natural-deduction style systems,
and about how the mentioned lemmas could be extended.

In autumn 2002 I picked up again on my earlier triggered interest in
rule derivability and admissibility,
trying to investigate, in an abstract framework close to the one chosen
by Hindley and Seldin,
the relationship between derivability and admissibility of rules 
and 
the ways how rules can be eliminated from derivations.
Having gathered a number of, elementary, results about
derivability and admissibility in natural-deduction style proof systems,
I gave two talks on this topic in the regular TCS-seminar of our theory
group at the VU on Friday afternoons (January 24, and February 7, 2003).
While finding my results interesting, I recall that Roel de~Vrijer
reacted strongly against the concrete formulation of rules as extensional 
`rule descriptions' that I employed.

\paragraph{Overview.}
In Section~\ref{sec:rules} Roel's\footnote{I hope to stay true to the spirit of this 
            \emph{liber amicorum} by switching to
            using only Roel de Vrijer's first name from now on.} 
remarks about two `naive' abstract notions of inference rule are explained,
which had highlighted to me significant problems of those notions. 
Section~\ref{sec:ARSs} is concerned with the concept
of `abstract rewriting system' in the theory of rewriting, which
Roel suggested me to look at.
In Section~\ref{sec:APHSs} the definition of `abstract pure Hilbert system'
(\APHS) is given and explained, which I formulated
as a direct consequence of Roel's remarks. 
In Section~\ref{sec:APHSs:results} derivability and admissibility of
rules in \APHS{s} are defined, and some results about these notions
are stated.  In Section~\ref{sec:ANDSs}
the idea of the notion of rules in `abstract natural-deduction systems'
is outlined. Finally in Section~\ref{sec:conclusion} a short summary
is given, and an idea for further research is mentioned.



\section{What is an inference rule, formally?}
  \label{sec:rules}



For this section heading I borrowed from the title
`\emph{What is an inference rule?}' of the article \cite{fagi:halp:vard:1992}
by Fagin, Halpern, and Vardi.
There, the investigation concentrates on the question of what
kinds of inferences semantically defined logics give rise to,
and how these inferences can be classified even with little specific knowledge
about the underlying semantics. 
Here, however, the focus is on the ways how rules are formulated
operationally, and how abstract rule definitions can be obtained.

Inference rules in logical calculi are defined in a variety of ways.
Here are just a few examples:
1.5ex]
\begin{aligned}
&
      \mbox{
         \AxiomC{}
         \RightLabel{L}
         \UnaryInfC{}
         \DisplayProof
            }
& &   \hspace*{2ex}
      \mbox{
         \AxiomC{}
         \AxiomC{}
         \insertBetweenHyps{\hspace*{3ex}}
         \RightLabel{UFP}
         \BinaryInfC{}
         \DisplayProof
            }
\end{aligned}

\saruledes \funin \underbrace{ \forms \times \ldots \times \forms }_{n}
      \: \rightharpoonup \: \forms \; ;

\mbox{
       \AxiomC{}
       \AxiomC{}
       \AxiomC{}
       \insertBetweenHyps{\hspace*{-0.75ex}}
\TrinaryInfC{}
       \DisplayProof
          }
    \text{is an instance of }
    \;\; & \Longleftrightarrow\;\;
\aruledes{A_1,\ldots,A_n} = A \; .

&
  \mbox{ 
     \AxiomC{}
     \RightLabel{I}
     \UnaryInfC{}
     \DisplayProof
        }
  & &
  \mbox{
     \AxiomC{}
     \RightLabel{E}
     \UnaryInfC{}
     \DisplayProof
        }
\mbox{ 
        \AxiomC{}
        \RightLabel{E }
        \UnaryInfC{}
        \DisplayProof
          }

&
     \mbox{ 
        \AxiomC{}
        \RightLabel{}
        \UnaryInfC{}
           \DisplayProof
           }
     & &
     \mbox{
        \AxiomC{}
        \RightLabel{}
        \UnaryInfC{}
        \DisplayProof
           }

\funap{\bs{f}}{\funap{f}{a}} &\red \funap{f}{a}
&
     \funap{f}{\funap{\bs{f}}{a}} &\red \funap{f}{a} \; , 

  \label{eq:pHS:inst}
\mbox{
    \AxiomC{}
    \insertBetweenHyps{\;\;\ldots\;\;}
    \AxiomC{}
    \RightLabel{}
    \BinaryInfC{}
    \DisplayProof
        }

  \label{eq:NR}
\mbox{
    \AxiomC{}
    \RightLabel{\Necessitation}
    \UnaryInfC{}
    \DisplayProof
       }

\text{the function} \quad
      & \sarity : \insts \rightarrow \,\nat \;\,
      & & \text{and}
                                                                 \
are defined as follows:
 assigns to an instance  of  the number of
its premises, that is, the length of the sequence .
For all ,
 assigns to an instance  of 
its -th premise, that is, the -th formula  in
 if it exists;
otherwise,  is undefined. 
\begin{Figure}[t]
\begin{center}
\scalebox{0.5}{\input{\figpath/inst_APHS-Rule.pdf_t}}
\end{center}
\caption{\label{fig:inst:APHS-Rule}Visualisation as hypergraph hyperedge of
           an instance  of an \APHS-rule
           with arity .}
\end{Figure}

Using these definitions, a visualisation 
of an instance  with 
of an unnamed \APHS-rule 

as a hypergraph hyperedge
is given in Figure~\ref{fig:inst:APHS-Rule}.
In a prooftree such an instance can be written as: 
\begin{center}
\mbox{
    \AxiomC{}
    \insertBetweenHyps{\;\;\ldots\;\;}
    \AxiomC{}
\BinaryInfC{}
    \DisplayProof
        }
\end{center}


While rules \emph{for} \APHS{s} do not carry names,
rules \emph{in} abstract pure Hilbert systems as defined below
\emph{do} carry names. 


\begin{definition} \normalfont
   \label{def:APHS}
An \emph{abstract pure Hilbert system (an \APHS)~} is a quadruple
   
  where:
\begin{itemize}
\item[]  
      , ,  and  are sets
      whose elements are called
      the {\em formulas of\/} ,
      the {\em names\/} (for axioms and rules) {\em in\/} ,
      the {\em named axioms of\/} ,
      and the {\em named rules of \/}, respectively;
      we demand , i.e.\ that
      the formula set be nonempty;
\item[] 
      , 
      i.e.\ the named axioms of  are tuples with
      formulas of  as first, and names in 
      as second, components;
\item[] 
      ,
      i.e.\ the named rules of  are tuples that have
      unnamed \APHS-rules on  as their first, and names
      as their second components; 
\item[] 
      for the named axioms and the named rules of 
      the following holds:
\begin{enumerate}
        \renewcommand{\labelenumi}{(\roman{enumi})}
\item  names of named axioms in  are different from names 
          of named rules,
\item different named rules in  carry different names
          (but for an unnamed APHS-rule  and different
           names , it is possible that    
           ).
\end{enumerate}
\begin{comment}

i.e.\ names of named axioms are different from names 
      of named rules, and

i.e.\ different rules are differently named in  
      (but it is not excluded that the 
      same rule may occur with different names in ).
\end{comment}
\end{itemize}    
\end{definition}


This definition of \APHS{s}, which is essentially the formulation in
my thesis \cite{grab:2005}, is actually a slight reformulation of the notion of
`abstract Hilbert system with names for axioms and rules' (\nAHS)
in \cite{grab:2003} after discussions with Roel in my last year
as Ph.D.~student, when I was writing down my thesis.
In \cite{grab:2003} an \nAHS\ is defined as 
a quintuple 
consisting of a set  of formulas, a set 
of axioms, a set  of unnamed \APHS-rules,
a set  of names, and a name function
.
Roel remarked that this use of a name function on a set of unnamed \APHS-rules 
prevents the possibility that the same unnamed \APHS-rule could occur twice,
under different names, in an \APHS. He convinced me that the formalisation should
not a priori exclude systems in which an initially unnamed rule occurs
under more than one name. 

Let

be an APHS.
In prooftrees, an instance  of 
an unnamed rule  such that 
, 
is written as:
\begin{center}
\mbox{
    \AxiomC{}
    \insertBetweenHyps{\;\;\ldots\;\;}
    \AxiomC{}
    \RightLabel{}
    \BinaryInfC{}
    \DisplayProof
        }
\end{center}
A \emph{derivation in } is defined as a prooftree in
the sense of \cite{troe:schw:2000}:
a tree in which the nodes are labelled by formulas and in which
the edges make part of rule instances and are not drawn,
but are replaced by horizontal lines that represent rule instances
and carry the name of the rule that is applied. 
Axioms and assumptions appear as top
nodes; lower nodes are formed by applications of rules;
the bottommost formula is the conclusion.
If  is a derivation in , then 
by  the set of assumptions of ,
and by  the conclusion of  will be denoted. 
Let  be an \APHS-rule on the formula set of . 
A derivation  in  is called 
a \emph{mimicking derivation} for an instance  of  
if
 
and .

The (usual, standard) consequence relation 
in an \APHS~ with formula set  
is a binary relation between sets of formulas and formulas
of .
For all formulas , and sets 
of formulas, in ,
 holds
if there is a derivation  in  such that
the assumptions of  are contained in ,
and  is the conclusion of .
By  
the statement  is abbreviated.
A formula  is a \emph{theorem} of an \APHS~ if
 holds, that is, if there is a derivation
in  without assumptions that has  as its conclusion.

Let  be an \APHS,
 an unnamed \APHS-rule over the set of formulas of ,
and   
a named version of .
Then the result of adding  to the named rules of  is
denoted by  given that it is an \APHS.




\section{Rule derivability and admissibility in \APHS{s}}
  \label{sec:APHSs:results}



In this section the definitions of derivability and admissibility
of arbitrary \APHS-rules in an \APHS\ are introduced,
based on the stipulations at the end of the previous section.
Furthermore, basic results about these notions 
are stated, together with results that I have obtained
in \cite{grab:2003} and \cite{grab:2005}.

In the definitions below of rule derivability and admissibility in \APHS{s}
the following notation will be used:
for a set  and a sequence , 
denotes the set of elements of  that occur in .

Let  be an abstract Hilbert system,
and let

an unnamed \APHS-rule over the set of formulas of .
Then  is called \emph{derivable in } if:

 is called \emph{correct for } if: 

And  is stipulated to be \emph{admissible in } if
every (or equivalent: one)
extension  of 
by adding a named version  of 
has the same theorems as . 
A named rule  
is derivable/correct/admissible in 
if the underlying unnamed rule  
is derivable/correct/admissible in , respectively.

Each of these definitions can be reformulated in terms of `mimicking derivations'.
For example,
an unnamed \APHS-rule  is derivable in an \APHS~ 
if and only if
for every instance of  there exists a mimicking derivation
in .

The following proposition gathers some of the most basic properties of
rule derivability, correctness, and admissibility, and of their interrelations.
Items~(i)--(iii) of this statement are a reformulation for \APHS{s} of 
a lemma by Hindley and Seldin (Lemma~6.14 on p.~70 in \cite{hind:seld:1986}).
Item~(iv) is taken from \cite{grab:2003} (see Theorem~3.5 on p.~18--19 there).


\begin{proposition}
Let  be an \APHS, and let  be an unnamed \APHS-rule
  on the set of formulas of . Then the following statements hold:
\begin{enumerate}
    \renewcommand{\labelenumi}{(\roman{enumi})}
\item  is admissible in  if and only
      if  is correct for .
\item If  is derivable in , 
      then  is admissible in . But the converse
      implication does not hold in general.
\item If  is derivable in , the
       is derivable in every extension of  by
      adding new formulas, new axioms, and/or new rules. 
\item  is derivable in  if and only if
       is admissible in every extension of  by
      adding new formulas, new axioms, and/or new rules. 
\end{enumerate}
\end{proposition}


Further results that I have obtained in \cite{grab:2003} include the
following:
\begin{enumerate}
\item Let  be an \APHS,  an unnamed \APHS-rule,
    and  an extension of 
    by adding a named version 
    of . 
    If  is admissible in ,
    then every derivation  in  
    without assumptions can
    be replaced by a mimicking derivation 
    in  (without assumptions).
    If  is derivable in ,
    then every derivation  in  can
    be replaced by a mimicking derivation  in , which
    moreover can be found by stepwise replacements 
    of -instances
    in  by mimicking derivations in . 
\item Let  be \APHS{s} that have the same set of formulas.
    The following statements are equivalent with 
    the statement that
     and  have the same admissible rules:
    (i)~the rules of  are admissible in ,
    and vice versa,
    and
    (ii)~ and  have the same theorems.
    Statements equivalent with the assertion that
     and  have the same derivable rules
    are:
    (i)~the rules of  are derivable in ,
    and vice versa,
    and
    (ii)~ and  induce the same consequence
    relation.
\item Let  be an \APHS,  an unnamed \APHS-rule,
    and  an extension of 
    by adding a named version 
    of . 
    If  is derivable in ,
    then -elimination for derivations in 
     can be performed effectively: 
    For a given derivation  in ,
    pick an arbitrary instance of  in the derivation
    and replace it, in the derivation,  by a mimicking derivation;
    carry out such {\em mimicking steps\/} repeatedly until no
    further applications of  are present,
    and a derivation  in  has been reached. 
    This nondeterministic procedure is strongly normalising.
\end{enumerate}


Apart from the notions of rule derivability and admissibility
defined above that
are based on the standard notion of consequence relation, 
in \cite{grab:2003} two variant notions are studied that refer to
variant consequence relations.
For these variant notions similar results are obtained;
their interconnections with each other and with the standard notions
are studied with the result of `interrelation prisms'.  



\section{Abstract natural-deduction systems}
  \label{sec:ANDSs}


In this section the notion of rule in an `abstract natural-deduction system'
(\ANDS) is only hinted at. For the details I refer to Chapter~4 and Appendix~B
of my thesis \cite{grab:2005}. 

Rules in natural-deduction style proof systems typically have a more
complex form than rules in Hilbert systems:
\begin{Figure}[t]
\begin{center}
\scalebox{0.55}{\input{\figpath/inst_ANDS-Rule.pdf_t}}
\end{center}
\caption{\label{fig:inst:ANDS-Rule}Visualisation as an hypergraph hyperedge of
           an instance  with arity  
           of an \ANDS-rule.}
\end{Figure}
An instance  of a rule in a natural-deduction system 
is usually not exclusively determined by
a sequence of premises and a conclusion, but its description
frequently also involves, per premise,
a set of assumptions that has to be present, and a number of
assumptions that may be, or in fact are, discharged at .
Instead of assumption formulas, assumptions in natural-deduction systems
are often formalised as formulas with decorating markers 
that are used to single out those marked assumptions which are discharged 
at an instance.

Figure~\ref{fig:inst:ANDS-Rule} contains an illustration of
an instance of an unnamed rule for an `abstract natural-deduction system'
as defined in \cite{grab:2005}:
apart from premise and conclusion functions, unnamed \ANDS-rules
also contain functions  and  that map instances
to their sequences of \emph{present marked assumptions} per premise,
and to their \emph{discharged marked assumptions}, respectively.

In a sequent-style representation, a typical instance  
of an \ANDS-rule, one with 
as depicted in Figure~\ref{fig:inst:ANDS-Rule},
can be written in the following form:

For the precise formal
definitions of rule derivability and admissibility in \ANDS{s}
some care is needed. The situation is considerably less straightforward 
than in \APHS{s}, and I refer to \cite{grab:2005} for the details.
I want to mention, however, that the definitions of admissibility and
derivability of \ANDS-rules in \ANDS{s} can be obtained in the 
following way:
(i) by considering sequent-style representations of \ANDS-rules
    with instances of the form~\eqref{eq:ANDS-rule:seqstyle} as \APHS-rules
    on sequents as formulas,
    and by considering sequent-style representations of entire \ANDS{s}
    as \APHS{s} with sequents as their formulas,
(ii) by applying 
     the definitions of rule derivability and admissibility in \APHS{s}
     to these \APHS-rules and \APHS{s},
and 
(iii) by transferring the resulting conditions back to \ANDS{s}. 
That is to say, rule derivability and admissibility in \ANDS{s}
can be defined by applying the definitions
of rule derivability and admissibility  in \APHS{s} 
for \APHS-rules on sequents that represent \ANDS-rules
with respect to \APHS{s} (with sequents as formulas)
that represent \ANDS{s}.

In my thesis, the definition of rule derivability and admissibility
for natural-deduction systems proved to be useful in the manner
indicated in the Section~\ref{sec:intro}.
In essentially all relevant cases of rules  of the
Amadio--Cardelli system \ACeq\ whose status
in \BHeq\ earlier seemed doubtful to me,
I succeeded in proving that  is admissible, but not derivable
in the Brandt--Henglein system~\BHeq; and consequently, that
instances of  cannot just be simulated in \BHeq\ 
by mimicking derivations, but have to eliminated in an other,
typically more complicated, way.
Having earlier obtained  elimination procedures for instances
of such rules  from \BHeq-derivations,
I at least obtained some certainty that I had not overlooked an
obvious way to mimic -instances by derivations in \BHeq. 



\section{Summary, a research idea, and thanks}
  \label{sec:conclusion}


\paragraph{Summary.}
By work for my Ph.D.~thesis on proof-theoretic interpretations into each other 
of proof systems for recursive types I became aware of the general relevance
of rule derivability and admissibility for interpretational proof theory. 
Due to the fact that rule derivability and admissibility are usually only
defined for concrete proof systems, and since the definitions of these
notions in natural-deduction style systems had not been clear to me
from the outset, I started a study of general properties of these notions
in abstractly viewed proof systems (both Hilbert\rule{1pt}{0pt} 
and natural-deduction style).
Formal definitions of abstract notions of inference rule
such as extensional rule descriptions, on which I had based
this study in my early attempts, 
were criticised by Roel as inadequate and, most of all, as conceptually 
unsatisfiable. 
Stimulated by Roel's remarks and his suggestion to try to draw inspiration from
the concept `abstract rewriting system' in rewriting theory,
I formulated the frameworks of \APHS{s} and \ANDS{s} for
abstract Hilbert-style and natural-deduction style proof systems.
In these systems, rules  
are treated as sets of (abstract) inference steps rather than
as mere relations between formulas, thereby keeping 
some information about how concrete rules are defined intensionally. 
In the sequel I used the concepts of \APHS{s} and \ANDS{s} to
state general results about derivability and admissibility of rules 
in pure Hilbert systems, and in natural-deduction systems.

\paragraph{A research idea.}
The frameworks of \APHS{s} and \ANDS{s} are based on abstract concepts of rules
that do not make use (at least not a priori) of special assumptions
on the formula language. 
While studying rule derivability and admissibility in these kinds
of abstract proof systems was sufficient for my particular purposes,
I think that it would also be fruitful to carry out a similar investigation
in abstract proof systems that are based on syntactic rule concepts,
perhaps 
formalised within a `logical framework' such as LF.
In particular, it would be interesting to see what kind of additional results 
about derivability and admissibility become possible 
once the syntactic manners in which inference rules are usually
defined is exploited systematically.
In the setting of proof systems that are formalised within a logical framework,
an idea for research would be to view elimination procedures for inference rules 
as higher-order rewriting systems, and to try to take advantage of 
the well-developed theory for higher-order rewriting. 

\paragraph{Thanks.}
I want to conclude by expressing my gratitude to Roel 
for his critical remarks about my earlier use of extensional rule descriptions,
his reference to abstract rewriting systems,
and the help he gave to me in regular discussions about the notions
of abstract proof systems during my last year as an \emph{AIO}
at the Vrije Universiteit, Amsterdam.


\paragraph{Acknowledgement.}
I thank Vincent van Oostrom for discussions,
  for explaining to me the origins of abstract rewriting systems
  in the work of Newman,
  and for his comments about previous versions of this text.
  My thanks go also to Jan Willem Klop for indicating a number of
  typos and inaccuracies in language use. 



\bibliography{main}

\end{document}
