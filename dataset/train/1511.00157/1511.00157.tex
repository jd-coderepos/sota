\documentclass[final]{dmtcs-episciences}

\usepackage{geometry}
\usepackage{multicol}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{verbatim}

\usepackage{graphicx}
\usepackage{epic}
\usepackage{eepic}

\usepackage{epsfig,float}
\usepackage{pdfsync}

\usepackage{gastex}
\usepackage{multicol}

\usepackage{xcolor}
\newcommand{\rt}{\text{\textcolor{red}{}}}
\newcommand{\lt}{\text{\textcolor{red}{}}}
\newcommand{\rs}{\text{\textcolor{blue}{}}}
\newcommand{\ls}{\text{\textcolor{blue}{}}}

\pagestyle{plain}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\renewcommand{\le}{\leqslant}
\renewcommand{\ge}{\geqslant}

\newcommand{\ol}{\overline}
\newcommand{\eps}{\varepsilon}
\newcommand{\emp}{\emptyset}
\newcommand{\rhoR}{R}
\newcommand{\Sig}{\Sigma}
\newcommand{\sig}{\sigma}
\newcommand{\noin}{\noindent}
\newcommand{\pf}{prefix-focused}
\newcommand{\ur}{uniquely reachable}
\newcommand{\bi}{\begin{itemize}}
\newcommand{\ei}{\end{itemize}}
\newcommand{\be}{\begin{enumerate}}
\newcommand{\ee}{\end{enumerate}}
\newcommand{\bd}{\begin{description}}
\newcommand{\ed}{\end{description}}
\newcommand{\bq}{\begin{quote}}
\newcommand{\eq}{\end{quote}}
\newcommand{\txt}[1]{\mbox{ #1 }}

\newcommand{\etc}{\mbox{\it etc.}}
\newcommand{\ie}{\mbox{\it i.e.}}
\newcommand{\eg}{\mbox{\it e.g.}}
\newcommand{\FigureDirectory}{FIGS}

\newcommand{\inv}[1]{\mbox{}}

\newcommand{\stress}[1]{{\fontfamily{cmtt}\selectfont #1}}

\def\shu{\mathbin{\mathchoice
{\rule{.3pt}{1ex}\rule{.3em}{.3pt}\rule{.3pt}{1ex}
\rule{.3em}{.3pt}\rule{.3pt}{1ex}}
{\rule{.3pt}{1ex}\rule{.3em}{.3pt}\rule{.3pt}{1ex}
\rule{.3em}{.3pt}\rule{.3pt}{1ex}}
{\rule{.2pt}{.7ex}\rule{.2em}{.2pt}\rule{.2pt}{.7ex}
\rule{.2em}{.2pt}\rule{.2pt}{.7ex}}
{\rule{.3pt}{1ex}\rule{.3em}{.3pt}\rule{.3pt}{1ex}
\rule{.3em}{.3pt}\rule{.3pt}{1ex}}\mkern2mu}}

\newcommand{\cA}{{\mathcal A}}
\newcommand{\cB}{{\mathcal B}}
\newcommand{\cC}{{\mathcal C}}
\newcommand{\cD}{{\mathcal D}}
\newcommand{\cE}{{\mathcal E}}
\newcommand{\cI}{{\mathcal I}}
\newcommand{\cK}{{\mathcal K}}
\newcommand{\cL}{{\mathcal L}}
\newcommand{\cM}{{\mathcal M}}
\newcommand{\cN}{{\mathcal N}}
\newcommand{\cP}{{\mathcal P}}
\newcommand{\cQ}{{\mathcal Q}}
\newcommand{\cR}{{\mathcal R}}
\newcommand{\cS}{{\mathcal S}}
\newcommand{\cT}{{\mathcal T}}
\newcommand{\cU}{{\mathcal U}}
\newcommand{\cV}{{\mathcal V}}
\newcommand{\cW}{{\mathcal W}}

\newcommand{\one}{{\mathbf 1}}

\newcommand{\bN}{{\mathbb N}}

\newcommand{\Lra}{{\hspace{.1cm}\Leftrightarrow\hspace{.1cm}}}
\newcommand{\lra}{{\hspace{.1cm}\leftrightarrow\hspace{.1cm}}}
\newcommand{\la}{{\hspace{.1cm}\leftarrow\hspace{.1cm}}}
\newcommand{\raL}{{\hspace{.1cm}{\rightarrow_L} \hspace{.1cm}}}
\newcommand{\lraL}{{\hspace{.1cm}{\leftrightarrow_L} \hspace{.1cm}}}

\newcommand{\sn}{{semiautomaton}}
\newcommand{\sa}{{semiautomata}}
\newcommand{\Sn}{{Semiautomaton}}
\newcommand{\Sa}{{Semiautomata}}
\newcommand{\se}{{settable}}
\newcommand{\Se}{{Settable}}
\newcommand{\pc}{{prefix-continuous}}

\newcommand{\cover}{{version}}
\newcommand{\defeq}{\stackrel{\rm def}{=}}
\newcommand{\com}{\mathbb{C}}
\newcommand{\rev}{R}
\newcommand{\deter}{D}
\newcommand{\mini}{\mathbb{M}}
\newcommand{\trim}{\mathbb{T}}

\newcommand{\timg}{\mathop{\mbox{rng}}}
\newcommand{\tdom}{\mathop{\mbox{dom}}}

\newcommand{\qedb}{\hfill} 

\newcommand{\gen}[1]{\langle #1 \rangle}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}

\theoremstyle{remark}
\newtheorem{remark}{Remark}

\newcommand{\atoms}{{\bf A}}
\newcommand{\atp}{{\phi(\atoms)}}
\newcommand{\quot}{{\bf K}}

\DeclareMathOperator{\lcm}{lcm} 

\usepackage{color}
\newcommand{\tr}{\textcolor{red}{}}
\newcommand{\tl}{\textcolor{red}{}}
\newcommand{\gtr}{\textcolor{green}{}}
\newcommand{\gtl}{\textcolor{green}{}}

\newcommand{\co}{\colon}
\newcommand{\ra}{\rightarrow}

\title{Most Complex Regular Ideal Languages}

\author{Janusz~Brzozowski\affiliationmark{1}\thanks{This work was supported by the Natural Sciences and Engineering Research Council of Canada under grant No.~OGP0000871.}
\and Sylvie Davies\affiliationmark{2} \and Bo Yang Victor Liu\affiliationmark{1}} 

\affiliation{David R. Cheriton School of Computer Science, University of Waterloo \\
Department of Pure Mathematics, University of Waterloo}

\keywords{atom, basic operations,  ideal, most complex,  quotient, regular language,   state complexity,  syntactic semigroup, universal witness}

\received{2015-12-03}
\accepted{2016-10-11}
\revised{2016-10-04}

\begin{document}
\publicationdetails{18}{2016}{3}{15}{1343}

\maketitle
\begin{abstract}
A right ideal (left ideal, two-sided ideal) is a non-empty language  over an alphabet  
such that
 (, ).
Let  for right ideals, 4 for left ideals and 5 for two-sided ideals.
We show that there exist sequences () of  right, left, and two-sided regular ideals, where  has quotient complexity (state complexity) , such that 
 is most complex in its class under the following measures of complexity: 
the size of the syntactic semigroup,
the quotient complexities of the left quotients of ,  
the number of atoms (intersections of complemented and uncomplemented left quotients), 
the quotient complexities of the atoms,  
and the quotient complexities  of 
reversal, 
star,  
product (concatenation), 
and all binary boolean operations.
In that sense, these ideals are ``most complex'' languages in their classes, or ``universal witnesses'' to the complexity of the various operations.
\end{abstract}



\section{Introduction}
\label{sec:introduction}

We begin informally, postponing definitions until Section~\ref{sec:background}.
In~\cite{Brz13} Brzozowski introduced a list of conditions that a regular language should satisfy in order to be called ``most  complex'', and found a sequence  of  regular languages with quotient/state complexity  that have the smallest possible alphabet and meet all of these conditions~\cite{Brz13}.
Namely, the languages  meet the upper bounds for 
the size of the syntactic semigroup,
the quotient complexities of left quotients,
the number of atoms (intersections of complemented and uncomplemented left quotients),
the quotient complexities of the atoms, 
and the quotient complexities of  the following operations:
reversal, 
star, 
product (concatenation), 
and all binary boolean operations.
In this sense the languages in this sequence are most complex when compared to other regular languages of the same quotient complexity.
However, these  ``universal witnesses''
cannot be used when studying the complexities listed above in subclasses of regular languages, since they generally lack the properties of those classes.

This paper is part of an ongoing project to investigate whether the approach used for general regular languages can be extended to subclasses. 
We present sequences of most complex languages for the classes of right, left, and two-sided regular  ideals. 
Right ideals were chosen as an initial ``test case'' for this project due to their simple structure; we were able to obtain a sequence of most complex right ideals by making small modifications to the sequence .
A preliminary version of our results about right ideals appeared in~\cite{BrDa14}. 
The sequences of witnesses for left and two-sided ideals are more complicated, and first appeared in~\cite{BrYe11} where they were conjectured to have syntactic semigroups of maximal size; this was later proved in~\cite{BSY15}.
Our main new result is a demonstration that these sequences are in fact most complex.
It has been shown in~\cite{BrSz15a} that a most complex sequence does not exist for the class of suffix-free languages.

Having a single sequence of witnesses for all the complexity measures is useful when one needs to test systems that perform operations on regular languages and finite automata: to determine the sizes of the largest automata that can be handled by the system, one can use the same sequence of witnesses for all the operations.

For a further discussion of regular ideals see~\cite{BrDa14,BJL13,BrSz14,BSY15,BrYe11}.
It was pointed out in~\cite{BJL13} that 
ideals deserve to be studied for several reasons. 
They are fundamental objects in semigroup theory. They appear in the theoretical computer science literature 
as early as 1965,
and continue to be of interest; an overview of historical and recent work on ideal languages is given in~\cite{BJL13}.
Besides being of theoretical interest, ideals also play a role in algorithms for pattern matching: 
For example, when searching for all words ending in a word from some set , one is looking for all the words of the left ideal .
Additional examples of the use of ideals in applications can be found in~\cite{AhCo75,CrHa90,CHL07,YCDLK06}. 

\section{Background}
\label{sec:background}

A \emph{deterministic finite automaton (DFA)}  consists of 
a finite non-empty set  of \emph{states},
a finite non-empty \emph{alphabet} ,  
a \emph{transition function} , an
\emph{initial state} , and 
a set  of \emph{final states}.
The transition function is extended to functions  and  as usual, but these extensions are  also denoted by . 
State   is \emph{reachable} if there is a word  such that . 
The \emph{language  accepted} by  is .
Two DFAs are \emph{equivalent} if their languages are equal.
The \emph{language of a state}  is the language accepted by the DFA 
.
Two states are \emph{equivalent} if their languages are equal; otherwise, they are \emph{distinguishable} by some word that is in the language of one of the states, but not the other. 
A~DFA is \emph{minimal} if all of its states are reachable and no two states are equivalent.
A state is \emph{empty} if its language is empty.

A \emph{nondeterministic finite automaton (NFA)} is a tuple , where 
, , and  are as in a DFA,  is the transition function 
and  is the \emph{set of initial states}.
An \emph{-NFA} has all the features of an NFA but its transition function 
 allows also transitions under the empty word . 
The \emph{language accepted} by an NFA or an -NFA is the set of words  for which there exists a sequence of transitions such that the concatenation of the symbols causing the transitions is ,
and this sequence leads from a state in  to a state in .
Two NFAs are \emph{equivalent} if they accept the same language.

Without loss of generality we use the set  as the set of states for our automata.
A \emph{transformation} of  is a mapping of  into itself.
We denote the image of a state  under a transformation  by .
An arbitrary transformation of  can be written as
\goodbreak


where ,  , and .
The \emph{image of a set}  
is .


The \emph{identity} transformation  maps  each element to itself, that is,  for .
For ,  a
transformation  of a set  is a \emph{-cycle} if there exist pairwise different elements  such that
,  , and all other elements of  are mapped to themselves.
A -cycle is denoted by .
A \emph{transposition} is a -cycle .
A transformation that changes only one element  to an element  is denoted by .
A transformation mapping a subset  of  to a single element  and acting as the identity on  is denoted by .

A \emph{permutation} of  is a mapping of  \emph{onto} itself. 
The set of all permutations of a set  of  elements is a group, 
called the \emph{symmetric group} of degree . 
This group has size .
It is well known that  two generators are necessary and sufficient to generate the symmetric group of degree ;
 in particular, the pairs  and  generate .


The set  of all transformations of  
is a semigroup, in fact a monoid with  as the identity. 
It is well known that three transformations are necessary and sufficient to generate  ;
in particular,  the triples
  and  generate .

Let  be a DFA. For each word , the transition function induces a transformation  of  by  : for all , 
 
The set  of all such transformations by non-empty words forms a semigroup of transformations called the \emph{transition semigroup} of ~\cite{Pin97}. 
Conversely, we can use a set   of transformations to define , and so the DFA . We write , where  is a transformation of , to mean that the transformation  induced by  is~. 

The \emph{Myhill congruence}~\cite{Myh57}  of a language  is defined on  as follows:

This congruence is also known as the \emph{syntactic congruence} of .
The quotient set  of equivalence classes of the relation  is a semigroup called the \emph{syntactic semigroup} of .
If   is a minimal DFA of , then  is isomorphic to the syntactic semigroup  of ~\cite{Pin97}, and we represent elements of  by transformations in~. 
The size of the syntactic semigroup has been used as a measure of complexity for regular languages~\cite{Brz13,BrYe11,HoKo04}, and is denoted by . 

The \emph{Nerode right congruence}~\cite{Ner58} of a language  is defined on  as follows:

The (left) quotient of  by a word  is the language 
.
Thus two words  and  are in the same class of the Nerode right congruence if they define the same quotient, that is, if , and  
the number of equivalence classes of  is the number of quotients, which is called the 
 \emph{quotient complexity}~\cite{Brz10} of .
An equivalent concept is
the \emph{state complexity of a regular language}~\cite{Yu01} , which  is the number of states in a minimal DFA with alphabet  that recognizes . 
This paper uses  the term \emph{complexity} for both of these equivalent notions.
We denote the (quotient/state) complexity of a regular language  by .

Atoms of regular languages were studied in~\cite{BrTa14}, and their complexities  
in~\cite{BrDa14,BrTa13,Iva16}.
Consider the left congruence defined as follows:

Thus  if . 
An equivalence class of this relation is called an \emph{atom}.
It follows that atoms are intersections of complemented and uncomplemented quotients.
In particular, if the quotients of  are , then for each atom  there is a unique set  such that
.
In~\cite{Brz13} it was argued that 
for a regular language to be considered ``most complex'' when compared with other languages of the same (quotient/state) complexity, it should have the maximal possible number of atoms and each atom should have maximal complexity.
The complexity of atoms of ideals was studied in~\cite{BrDa14,BrDa15}, and we shall  state the results obtained there without proofs.

Most of the results in the literature concentrate on the (quotient/state) complexity of operations on regular languages.
The \emph{complexity of an operation} is the maximal  complexity of the language resulting from the operation as a function of the  complexities of the arguments.

It is generally assumed when studying complexity of binary operations that both arguments are languages over the same alphabet, since if they have different alphabets, we can just view them as languages over the union of the alphabets.
However, in 2016, Brzozowski demonstrated that this viewpoint leads to incorrect complexity results for operations on languages over different alphabets~\cite{Brz16}. He introduced a notion of \emph{unrestricted (quotient/state) complexity} of operations, which gives correct results when languages have different alphabets. The traditional notion of complexity, in which languages are assumed to have the same alphabet, is referred to as \emph{restricted (quotient/state) complexity} of operations.
As this paper was written well before~\cite{Brz16}, all our results are in terms of restricted complexity.
A study of unrestricted complexity of binary operations on ideals can be found in~\cite{BrCo16}.

There are two parts to the process of  establishing the  complexity of an operation.
First, one must find an \emph{upper bound} on the  complexity of the result of the operation
by using quotient computations or automaton constructions.
Second, one must find \emph{witnesses}  that meet this upper bound.
One usually defines a sequence  of languages, where   is some small positive integer (the bound may not apply for small values of ).  This sequence is called a \emph{stream}. The languages  in a stream usually differ only in the parameter . 
For example, 
one might study unary languages  that have zero 's modulo~. 
A unary operation then takes its argument from a stream .
For a binary operation, one adds as the second argument a stream . 

Sometimes one considers the case where the inputs to the operations are restricted to some \emph{subclass} of the class of regular languages. In this setting, typically the upper bounds on complexity are different and different witnesses must be found. The complexity of operations on regular ideal languages was studied in~\cite{BJL13}.

While witness streams are normally different for different operations, the main result of this paper shows that for the subclasses of right, left and two-sided ideals, the complexity bounds for all ``basic operations'' (those mentioned in the introduction) can be met by a single stream of languages along with a stream of ``dialects'', which are slightly modified versions of the languages. Several types of dialects were introduced in~\cite{Brz13}; in this paper we consider only dialects defined as follows:

Let  be an alphabet; we assume that its elements are ordered as shown.
Let  be a \emph{partial permutation} of , that is, a partial function  where , for which there exists  such that  is bijective when restricted to  and  undefined on . We denote undefined values of  by the symbol ``''.

If  is a language over , we denote it by  to stress its dependence on .
If  is a partial permutation, let  be the language substitution  defined as follows: 
 for , 
 when  is defined, and  when  is not defined.
For example, if , , and , , and , then .
In other words, the letter  plays the role of , and  plays the role of .
A \emph{permutational dialect} of  is a language of the form 
, where  is a partial permutation of ; this dialect is denoted by
.
If the order on  is understood, we use   for  and 
for .

Let ,  and 
let  be a DFA; we denote it by
 to stress its dependence on .
If  is a partial permutation, then the \emph{permutational dialect} 
 of
 is obtained by changing the alphabet of  from  to , and modifying  so that in the modified DFA 
 induces the transformation induced by   in the original DFA; thus  plays the role of .
One verifies that if the language  is accepted by DFA , then
 is accepted by .

In the sequel we refer to permutational dialects simply as dialects.

\begin{example}
Suppose , where   is defined by the transformations 
, , and . 
 Let  be the language of this DFA. 
Consider the partial permutation , , and . In the dialect associated with , the letter  plays the role of , and  plays the role of . 
Thus 
 is the DFA , where  is defined by 
 and .
The language of  is the dialect  of .
\end{example}



The notion of a \emph{most complex stream} of regular languages was introduced informally in~\cite{Brz13}. 
A~most complex stream is one whose languages together with  their dialects  meet all the upper bounds for the complexity measures described in the introduction.
We now make this notion precise. First, however, we recall a property of boolean functions.
Let the truth values of propositions be 1 (true) and 0 (false). Let  be a binary boolean function.
Extend  to a function
:
If  and , 
then 
A binary boolean function is \emph{proper} if it is not a constant  and not a function of one variable only. 


\begin{definition}
Let  be a class of languages and let  be the subclass of  that consists of all the languages of  that have (quotient/state) complexity .
Let , and let  be a stream of languages, where  for all . Then  is most complex in class  if it satisfies all of the following conditions:
\be
\item
The syntactic semigroup of  has maximal cardinality for each .
\item
Each quotient of  has maximal   complexity for each .
\item
 has the maximal possible number of atoms for each .
\item
Each atom of  has maximal complexity for each .
\item
The reverse of  has maximal complexity for each .
\item 
The star of  has maximal  complexity for each .
\item
The product
 has maximal  complexity for all .
\item
There exists a dialect  such that each proper binary boolean function 
 has maximal  complexity for all .
\ee
\end{definition}

A most complex stream  for the class of regular languages was introduced in~\cite{Brz13}. 
We give the definition of  below.

\begin{definition}
\label{def:regular}
For , let , where 
, 
and  is defined by the transformations
,
,
. 
Let  be the language accepted by~.
The structure of  is shown in Figure~\ref{fig:RegWit}. 
\end{definition}

\begin{figure}[ht]
\unitlength 11pt
\begin{center}\begin{picture}(31,7)(-2,0)
\gasset{Nh=2.4,Nw=2.4,Nmr=1.2,ELdist=0.3,loopdiam=1.2}

\node(1)(2,4){}\imark(1)
\node(2)(6,4){}
\node(3)(10,4){}
\node[Nframe=n](qdots)(14,4){}
\node(n-2)(18,4){{\small }}
\node(n-1)(22,4){{\small }}
\node(n)(26,4){{\small }}\rmark(n)


\drawedge(1,2){}
\drawedge(2,3){}
\drawedge(3,qdots){}
\drawedge(qdots,n-2){}
\drawedge(n-2,n-1){}
\drawedge(n-1,n){}
\drawedge[curvedepth=-1.9,ELdist=-.9](2,1){}
\drawedge[curvedepth=3.8](n,1){}

\drawloop(1){}
\drawloop(2){}
\drawloop(3){}
\drawloop(n-1){}
\drawloop(n-2){}
\drawloop(n){}

\end{picture}\end{center}
\caption{Minimal DFA   of Definition~\ref{def:regular}.}
\label{fig:RegWit}
\end{figure}

Our main contributions in this paper are most complex streams for the classes of right, left, and two-sided regular ideals.

\section{Right Ideals}

A stream of right ideals  that is most complex was defined and studied in~\cite{BrDa14}. For completeness we include the results from that paper; the proof of Theorem~\ref{thm:RBool2} did not appear in~\cite{BrDa14}.

\begin{definition}
\label{def:RWit}
For , let , where 
, 
and  is defined by the transformations
,
,

and . 
Note that  is the identity when .
Let  be the language accepted by~.
The structure of  is shown in Figure~\ref{fig:RWit}. 
\end{definition}





\begin{figure}[ht]
\unitlength 11pt
\begin{center}\begin{picture}(31,7)(-2,0)
\gasset{Nh=2.4,Nw=2.4,Nmr=1.2,ELdist=0.3,loopdiam=1.2}

\node(1)(2,4){}\imark(1)
\node(2)(6,4){}
\node(3)(10,4){}
\node[Nframe=n](qdots)(14,4){}
\node(n-2)(18,4){{\small }}
\node(n-1)(22,4){{\small }}
\node(n)(26,4){{\small }}\rmark(n)

\drawedge(1,2){}
\drawedge(2,3){}
\drawedge(3,qdots){}
\drawedge(qdots,n-2){}
\drawedge(n-2,n-1){}
\drawedge(n-1,n){}
\drawedge[curvedepth=2.1](n-1,2){}
\drawedge[curvedepth=3.8](n-1,1){}

\drawloop(1){}
\drawloop(2){}
\drawloop(3){}
\drawloop(n-2){}
\drawloop(n){}

\end{picture}\end{center}
\caption{Minimal DFA   of Definition~\ref{def:RWit}.}
\label{fig:RWit}
\end{figure}

The DFA of Figure~\ref{fig:RWit} has a similar structure to the DFA of Figure~\ref{fig:RegWit}.
More precisely,
DFA   of Figure~\ref{fig:RWit} is constructed by taking DFA  of Figure~\ref{fig:RegWit}, adding a new state  and a new input , making  the only final state, and having  induce the cyclic permutation , rather than  the transposition . The new state and input  ensure that  is a right ideal. The new transformation by  is necessary since, if   induces  in , then  does not meet the bound for product.


\begin{theorem}[Right Ideals~\cite{BrDa14}]
\label{thm:main}
For each , the DFA  of Definition~\ref{def:RWit} is minimal and its 
language  is a right ideal of complexity .
The stream   with dialect stream

is most complex in the class of regular right ideals.
In particular, this stream meets all the complexity bounds listed below, which are maximal for right ideals.
In several cases the bounds can be met with restricted alphabets, as shown below.
\begin{enumerate}
\item
The syntactic semigroup of  has cardinality .  Moreover, fewer than four inputs do not suffice to meet this bound.
\item
The quotients of  have complexity , except for the quotient , which has complexity 1.
\item
 has  atoms.
\item
For each atom  of , the complexity  satisfies:

\item
The reverse of  has complexity .
\item
The star of  has complexity .
\item
The product  has complexity .
\item
For any proper binary boolean function , the complexity of 
is maximal. In particular,
	\be
	\item
	 and  have complexity  .
	\item
	 has complexity .
	\item
	 has complexity .
	\item 
	If , the bounds are met by  and .
	\ee
\end{enumerate}
\end{theorem}

\begin{proof}
For , a non-final state  accepts  and no other non-final state accepts this word. All non-final states are distinguishable from the final state . Hence  is minimal and  has  quotients.
Since  has only one final state and that state accepts , it is a right ideal.
\be
\item
The case  is easily checked. For ,
let , where  , and
, ,  and 
.
It was proved in~\cite{BrYe11} that  the transition semigroup of a minimal DFA accepting a right ideal has at most  transformations, and that the transition semigroup of 
 has cardinality . 
Since for ,     is induced by   in ,
all the transformations of  can be induced in ,
and the claim follows.
Moreover, it was proved in~\cite{BSY15} that an alphabet of at least four letters is required to meet this bound. 


\item
Each quotient of , except , has complexity , since states  are strongly connected.
Each right ideal must have a final state that accepts  (for  this is state ), and so the complexity of the quotient corresponding to this final state is .
Hence the complexities of the quotients are maximal for right ideals.
\item
It was proved  in~\cite{BrTa13} that the number of atoms of any regular language  is equal to the complexity of the reverse of .
If  is a right ideal of complexity , the maximal complexity of the reverse  is 
~\cite{BJL13}.
For , it is easily checked that our witness meets this bound.
For , it was proved in~\cite{BrYe11} that the reverse of  reaches this bound.
\item
This was proved in~\cite{BrDa15}.
\item
See Item 3 above.
\item
See Theorem~\ref{thm:RStar}.
\item
See Theorem~\ref{thm:RProd}.
\item
See Theorems~\ref{thm:RBool} and \ref{thm:RBool2}.  
\ee
\end{proof}

\subsection{Star}
\begin{theorem}[Right Ideals: Star~\cite{BrDa14}]
\label{thm:RStar}
For  the complexity of the  star of  is .
\end{theorem}
\begin{proof}
If  is a right ideal, then .
Consider the DFA for star constructed as follows.
To add  to , 
the initial state  of our witness cannot be made final since this would add other words to the language, for example, .
Thus an additional state, say , is required; this state is both initial and final in the DFA for , its outgoing transitions are the same as those of the initial state  of the DFA for , and it has no incoming transitions. Since this DFA accepts ,  states are sufficient. All the states are pairwise distinguishable, since  rejects , while  accepts it, and all the non-final states are distinguishable by words in . 
\end{proof}


\subsection{Product}
\label{ssec:product_right}

We use the DFAs  and  shown in
Figure~\ref{fig:RProd} for  and , where  and the states of the first DFA are primed to distinguish them from those of the second DFA.

We show that the complexity of the product of  
reaches the maximum possible bound  derived in~\cite{BJL13}.
Define the -NFA , 
where  if , ,
 if , , 
and .
This -NFA accepts , and is illustrated in Figure~\ref{fig:RProd}.


\begin{figure}[ht]
\unitlength 9pt
\begin{center}\begin{picture}(36,8)(0,1)
\gasset{Nh=2.4,Nw=2.4,Nmr=1.2,ELdist=0.4,loopdiam=1.2}
\node(1')(2,4){}\imark(1')
\node(2')(6,4){}
\node(3')(10,4){}
\node(4')(14,4){}
\drawedge(1',2'){}
\drawedge(2',3'){}
\drawedge(3',4'){}

\drawedge[curvedepth=-2,ELdist=-1.2](3',2'){}
\drawedge[curvedepth=2,ELdist=0.6](3',1'){}

\drawloop(1'){}
\drawloop(2'){}
\drawloop(4'){}

\node(1)(19,4){}\imark(1)
\node(2)(23,4){}
\node(3)(27,4){}
\node(4)(31,4){}
\node(5)(35,4){}\rmark(5)

\drawedge(1,2){}
\drawedge(2,3){}
\drawedge(3,4){}
\drawedge(4,5){}

\drawedge[curvedepth=-4,ELdist=-1.0](4,2){}
\drawedge[curvedepth=2.3,ELdist=0.5](4,1){}

\drawedge(4',1){}

\drawloop(1){}
\drawloop(2){}
\drawloop(3){}
\drawloop(5){}
\end{picture}\end{center}
\caption{-NFA for product with , .}
\label{fig:RProd}
\end{figure}


\begin{theorem}[Right Ideals: Product~\cite{BrDa14}]
\label{thm:RProd}
For  the complexity of the product of  and  is .
\end{theorem}

\begin{proof}
It was shown in~\cite{BJL13} that  is an upper bound on the complexity of the product of two right ideals. To prove this bound is met, 
we apply the subset construction to  to obtain a DFA  for .
The states of  are subsets of .
We prove that all states of the form ,  and all states of the form
, where , and state 
 are reachable, for a total of  states.


State  is the initial state, and   is reached by  for .
Also,  is reached by , and  
states  and 1 are present in every subset reachable from . 
By applying  to  we reach ; hence all subsets 
 with  are reachable.

Assume now that we can reach all sets  with , and 
suppose that we want to reach  with 
with .
 This can be done by starting with  and applying . 
Finally, to reach , apply  to .

If , then state  is distinguishable from  by 
.
Also, state  with  accepts  and no other state  with  accepts this word. 
Hence, if  and , then 
 and  are distinguishable.
State  with  is distinguishable from state 
because there is a word with a single  that is accepted from 
but no such word is accepted by . Hence all the non-final states are distinguishable, and  is the only final state.
\end{proof}


\subsection{Boolean Operations}
\label{ssec:boolean_right}

We restrict our attention to the four boolean operations , since the complexity of any other proper binary boolean operation can be obtained from these four. For example,
we have .

Tight upper bounds for boolean operations on right ideals~\cite{BJL13}  are  for intersection and symmetric difference,  for difference, and  for union.
Since , and 
, two different languages must be used
to reach the bounds if . 

We use the DFAs  and  shown in
Figure~\ref{fig:RBool} for  and .
\begin{figure}[ht]
\unitlength 9pt
\begin{center}\begin{picture}(36,8)(0,1)
\gasset{Nh=2.4,Nw=2.4,Nmr=1.2,ELdist=0.3,loopdiam=1.2}
\node(1')(2,4){}\imark(1')
\node(2')(6,4){}
\node(3')(10,4){}
\node(4')(14,4){}\rmark(4')
\drawedge(1',2'){}
\drawedge(2',3'){}
\drawedge(3',4'){}

\drawedge[curvedepth=-2,ELdist=-1.2](3',2'){}
\drawedge[curvedepth=2,ELdist=0.6](3',1'){}

\drawloop(1'){}
\drawloop(2'){}
\drawloop(4'){}

\node(1)(20,4){}\imark(1)
\node(2)(24,4){}
\node(3)(28,4){}
\node(4)(32,4){}
\node(5)(36,4){}\rmark(5)

\drawedge(1,2){}
\drawedge(2,3){}
\drawedge(3,4){}
\drawedge(4,5){}

\drawedge[curvedepth=-4,ELdist=-1.0](4,2){}
\drawedge[curvedepth=2.5,ELdist=0.5](4,1){}

\drawloop(1){}
\drawloop(2){}
\drawloop(3){}
\drawloop(5){}
\end{picture}\end{center}
\caption{Right-ideal witnesses for boolean operations with , .}
\label{fig:RBool}
\end{figure}


\begin{figure}[ht]
\unitlength 9pt
\begin{center}\begin{picture}(25,20)(0,-2)
\gasset{Nh=2.4,Nw=2.4,Nmr=1.2,ELdist=0.3,loopdiam=1.2}
\node(1'1)(2,15){}\imark(1'1)
\node(2'1)(2,10){}
\node(3'1)(2,5){}
\node(4'1)(2,0){}

\node(1'2)(7,15){}
\node(2'2)(7,10){}
\node(3'2)(7,5){}
\node(4'2)(7,0){}

\node(1'3)(12,15){}
\node(2'3)(12,10){}
\node(3'3)(12,5){}
\node(4'3)(12,0){}

\node(1'4)(17,15){}
\node(2'4)(17,10){}
\node(3'4)(17,5){}
\node(4'4)(17,0){}

\node(1'5)(22,15){}
\node(2'5)(22,10){}
\node(3'5)(22,5){}
\node(4'5)(22,0){}

\drawedge(1'1,2'1){}
\drawedge(2'1,3'1){}
\drawedge(3'1,4'1){}

\drawedge[curvedepth=3,ELdist=.4](3'1,1'1){}

\drawedge(1'2,2'3){}
\drawedge[linewidth=0.15](2'2,3'3){}
\drawedge(3'2,1'3){}
\drawedge(3'2,4'2){}

\drawedge(1'3,2'4){}
\drawedge[linewidth=0.15](2'3,3'4){}
\drawedge(3'3,1'4){}
\drawedge(3'3,4'3){}

\drawedge(1'4,2'2){}
\drawedge(2'4,3'2){}
\drawedge(3'4,4'5){}

\drawedge(1'5,2'5){}
\drawedge[linewidth=0.15](2'5,3'5){}
\drawedge(3'5,4'5){}

\drawedge[curvedepth=-3,ELdist=-0.9](3'5,1'5){}

\drawedge[curvedepth=-2,ELdist=-0.9](3'4,1'2){}

\drawedge[dash={.5 .25}{.25}](4'1,4'2){}
\drawedge[linewidth=0.15](4'2,4'3){}
\drawedge[linewidth=0.15](4'3,4'4){}
\drawedge(4'4,4'5){}

\drawedge[curvedepth=2.2,ELdist=-.7](4'4,4'2){}
\drawedge[curvedepth=3,ELdist=-1,dash={.5 .25}{.25}](4'4,4'1){}
\drawedge[dash={.5 .25}{.25}](1'1,1'2){}
\drawedge[dash={.5 .25}{.25}](1'2,1'3){}
\drawedge[dash={.5 .25}{.25}](1'3,1'4){}
\drawedge(1'4,1'5){}
\drawedge[curvedepth=-2.5,ELdist=-1,dash={.5 .25}{.25}](1'4,1'1){}

\drawedge[dash={.5 .25}{.25}](2'1,3'2){}
\drawedge[dash={.5 .25}{.25}](3'1,2'2){}
\drawedge[dash={.5 .25}{.25}](3'2,2'3){}
\drawedge[curvedepth=1.5,ELdist=.5,dash={.5 .25}{.25}](3'5,2'5){}

\drawedge[dash={.5 .25}{.25}](2'4,3'1){}
\drawedge[dash={.5 .25}{.25}](3'3,2'4){}
\drawedge[dash={.5 .25}{.25}](3'4,2'1){}
\drawedge(2'4,2'5){}

\end{picture}\end{center}
\caption{Direct product for boolean operations. Unlabeled transitions under  are solid, under  are dashed, and under both  and  are thick.   Self-loops are omitted.}
\label{fig:RCross}
\end{figure}



Let .
Depending on the assignment of final states, this DFA recognizes different boolean operations on  and .
The 
direct product  of  and   is  in
Figure~\ref{fig:RCross}.  





Let  denote the symmetric group of degree . 
A \emph{basis}~\cite{Pic39} of 
is an ordered pair  of distinct transformations of  that generate .
A DFA \emph{has a basis  for } if it has letters  such that  induces  and  induces .
In the case of our right ideal  (), the transitions  and  ( and ) restricted to (), constitute a basis for  (. 
Consider DFAs 
 and 
, where  and the transitions of  () are the same as those of  ( restricted to  (.
By~\cite[Theorem 1]{BBMR14} all the states in the direct product of 
  and  are reachable and distinguishable for 
,  .
We shall use this result to simplify our proof of the next theorem.

\begin{theorem}[Right Ideals: Boolean Operations~\cite{BrDa14}]
\label{thm:RBool}
If , then
\be
\item
The complexity of  is .
\item
The complexity of  is .
\item
The complexity of  is .
\item
The complexity of  is .
\ee
\end{theorem}

\begin{proof}
In the cases where , we cannot 
apply the result from~\cite[Theorem 1]{BBMR14}, but we have verified computationally that the bounds are met. Thus we assume that .

Our first task is to show that all  states of  are reachable.
By~\cite[Theorem 1]{BBMR14}, all states in the set  are reachable. The remaining states are the ones in the last row or last column (that is, Row  or Column ) of the direct product.

For , from state  we can reach  by . From state  we can reach  by . From state  we can reach  by . Hence all states in Row  are reachable.

For , from state  we can reach  by . From state  we can reach  by . Hence all states in Column  are reachable, and thus all  states are reachable.

We now count the number of distinguishable states for each operation. Let  be the set of states in the last row and let  be the set of states in the last column. If , then  is recognized by , where the set of final states is taken to be .

Let  and let .
That is,  is the second last row of states, and  is the second last column, restricted to . 
By~\cite[Theorem 1]{BBMR14}, all states in  are distinguishable with respect to , for each boolean operation .
We claim that they are also distinguishable with respect to  for .

To see this, one verifies the following statement: for each  and each state , we have  if and only if . (This \emph{only} applies to states ; for example, in Figure \ref{fig:RCross} we see that  but .) Since states in  are distinguishable with respect to , it follows that for any pair of states  there is a word  with  and . Then by the statement, the word  sends  into  and  outside of , thus distinguishing the two states with respect to .


Thus for each boolean operation , all 
states in  are distinguishable from each other with respect to the final state set . Next, we prove that the states in  are distinguishable from the rest of the states (those in ) with respect to the final state set .

Since all states in  are non-final, it suffices to distinguish states in  from states in , the set of non-final states in . If , then  contains no states and there is nothing to be done. 
If , the only state in  is , which is empty, but all states in  are non-empty. If , then all states in  are empty but no states in  are.
Finally, if , observe that each state in  accepts a word containing a single , while states in   accept only words with at least two occurrences of . To distinguish  from , apply  (which maps  to ) and then apply a word which distinguishes  from .

We have shown that each state in  is distinguishable from every other state in the direct product , with respect to each of the four final state sets  with .
Since there are  states in ,  there are at least that many distinguishable states for each operation .
To show that the complexity bounds are reached by , it suffices to consider how many of the remaining  states in  are distinguishable with respect to .
We consider each operation in turn.

\noin\textbf{Intersection:}
Here the set of final states is .
State  is the only final state and hence is distinguishable from all the other states.
Any two states in  () are distinguished by words in  ().
State  accepts , while  rejects it.
For ,  is sent to  by , while 
state  is not changed by that word.
Hence  is distinguishable from .
By a symmetric argument,  is distinguishable from  for .
For  and ,  is distinguished from
 because  sends the former to  and the latter to a state of the form , where .
Hence all pairs of states from  are distinguishable. 
Since there are  states in ,  it follows there are  distinguishable states.

\noin\textbf{Symmetric Difference:}
Here the set of final states is , that is, all states in the last row and column except , which is the only empty state.
This situation is complementary to that for intersection. Thus every two states from  are distinguishable by the same word as for intersection.
Hence there are  distinguishable states.

\noin\textbf{Difference:}
Here the set of final states is , that is, all states in the last row  except , which is empty. All other states in the last column  are also empty. 
The  empty states in  are all equivalent, and the  final states in  are distinguished in the same way as for intersection. Hence there are  distinguishable states in . It follows there are  distinguishable states.

\noin\textbf{Union:}
Here the set of final states is . From a state in  it is possible to reach only other states in , and all these states are final; so every state in  accepts . Thus all the states in  are equivalent, and so there are  distinguishable states.
\end{proof}

Although it is impossible for the stream  to meet the bounds for boolean operations when , this stream is as complex as it could possibly be
in view of the following theorem:

\begin{theorem}[Right Ideals: Boolean Operations, ]
\label{thm:RBool2}
Suppose  and .
\be
\item
The complexity of  is .
\item
The complexity of  is .
\item
The complexity of  is .
\item
The complexity of  is .
\ee
\end{theorem}
\begin{proof}
Let , , and  be the direct product automaton. 
If , we have verified computationally that the bounds are met. If ,  we can apply~\cite[Theorem 1]{BBMR14}. Thus by the arguments used in the proof of Theorem \ref{thm:RBool}, all states of  are reachable. 

Most of the distinguishability arguments carry over as well.
If  and  are the last row and column of states in  respectively, and  is the set of states lying outside of , we can use nearly identical arguments as in the proof of Theorem \ref{thm:RBool} to show that for , every state in  is distinguishable from every other state in  with respect to .
It remains to count the number of states in  that are distinguishable with respect to .

\noin\textbf{Intersection:}
Here the set of final states is . Since  is the only final state, it is distinguishable from all other states.
Any two states both in  (or both in ) are distinguished by words in .
Suppose . Then  sends  to  and fixes .
Words in  can send  to  for , and they fix .
For ,  accepts , while  remains fixed.
Hence  is distinguishable from  for all . 
For  and ,  is distinguished from  because  sends  to  and  to some state that is distinguishable from .
Hence all pairs of states from  are distinguishable if . A symmetric argument works for . Thus all  states are distinguishable.

\noin\textbf{Symmetric Difference, Difference, and Union:}
The arguments are similar to those used in the proof of Theorem \ref{thm:RBool}. 
\end{proof}

\begin{remark}
For each class of languages we studied in this paper, our goal was to find a single DFA stream that meets the upper bounds (for that class) on all of our complexity measures.
For regular right ideals, a four-letter alphabet was necessary to achieve this, because fewer than four letters are not sufficient for the size of the syntactic semigroup to be maximal. Having found such a DFA, we then observed that the alphabet of this DFA can be reduced for several operations. On the other hand, if one wishes to minimize the alphabet for one particular operation only, it is possible to find witnesses over even smaller alphabets. 

We list here each operation with the size of the smallest known alphabet (first entry) along with our alphabet size (second entry):
reversal (2/2), star (2/2), product (2/3), union (2/3), intersection (2/3), symmetric difference (2/3), and difference (2/3).

As an example, consider the two binary witnesses for the product operation that are used in~\cite{BJL13}: 
, 
where 

and 
, 
where 
, 
Note that, although only two inputs are used, they induce three different transformations. 
Thus one can argue that these witnesses are not simpler than ours.
\end{remark}



\section{Left Ideals}

The following stream of left ideals was  defined in~\cite{BrYe11}:

\begin{definition}
\label{def:LWit}
For , let , where 
,
and  is defined by  transformations
,
,
,
, 
.
Let  be the language accepted by~.
The structure of   is shown in Figure~\ref{fig:LWit}. 
\end{definition}


\begin{figure}[ht]
\unitlength 10.5pt
\begin{center}\begin{picture}(33,11)(-.5,2.0)
\gasset{Nh=2.4,Nw=2.4,Nmr=1.2,ELdist=0.3,loopdiam=1.2}
\node(1)(2,8){}\imark(1)
\node(2)(7,8){}
\node(3)(12,8){}
\node(4)(17,8){}
\node[Nframe=n](qdots)(22,8){}
{\scriptsize
\node(n-1)(27,8){{\small }}
\node(n)(31,8){{\small }}\rmark(n)
}
\drawedge(1,2){}
\drawedge[ELdist=.2](2,3){}
\drawedge(3,4){}
\drawedge(4,qdots){}
\drawedge(qdots,n-1){}
\drawedge(n-1,n){}
\drawloop(1){}
\drawloop(2){}
\drawloop(3){}
\drawloop(4){}
\drawloop(n-1){}
\drawloop(n){}
\drawedge[curvedepth=-2.5](3,2){}
\drawedge[curvedepth=-4.8](4,2){}
\drawedge[curvedepth=2.1](n-1,2){}
\drawedge[curvedepth=3.5](n,2){}
\drawedge[curvedepth=5](n,1){}
\end{picture}\end{center}
\caption{Minimal DFA   of Definition~\ref{def:LWit}.}
\label{fig:LWit}
\end{figure}


This stream of languages is closely related to the stream of Figure~\ref{fig:RegWit}.
The DFA  of Definition~\ref{def:LWit} is constructed by taking  of Figure~\ref{fig:RegWit} with states relabeled , adding a new state  and new inputs  and . 
 


\begin{theorem}[Left Ideals]
For each , the DFA  of Definition~\ref{def:LWit} is minimal and its 
language  is a left ideal of complexity .
The stream   with dialect stream

is most complex in the class of regular left ideals.
In particular, this stream meets all the complexity bounds listed below, which are maximal for left ideals. In several cases the bounds can be met with restricted alphabets, as shown below.
\be
\item
The syntactic semigroup of  has cardinality .  Moreover, fewer than five inputs do not suffice to meet this bound.
\item
All quotients of  have complexity .
\item
 has  atoms. 
\item
For each atom  of , the complexity  satisfies:

\item
The reverse of  has complexity .

\item
The star of  has complexity .
\item
The product  has complexity .
\item
For any proper binary boolean function , the complexity of  
is .

\ee
\end{theorem}
\begin{proof}
DFA  is minimal  since 
only state 1 does not accept any word in , whereas every other state  accepts  and no state  with   accepts this word.
It was proved in~\cite{BrYe11} that   accepts a left ideal.
\be
\item
It was shown in~\cite{BrSz14} that the syntactic semigroup of a left ideal of complexity  has cardinality at most , and
in~\cite{BrYe11} that the syntactic semigroup of  has cardinality . 
Moreover, it was proved in~\cite{BSY15} that an alphabet of at least five letters is required to meet this bound. 
\item
Each quotient of  has complexity , since its minimal DFA is strongly connected.
\item
The number of atoms of any regular language  is equal to the complexity of the reverse of ~\cite{BrTa13}. It was proved in~\cite{BrYe11} that the complexity of the reverse of  is .
\item
This was proved in~\cite{BrDa15}.
\item
See Item~3 above.
\item
The argument is the same as for the star of right ideals.
\item
See Theorem~\ref{thm:LProd}.
\item
See Theorem~\ref{thm:LBool}.
\ee
\end{proof}

\subsection{Product}
\label{ssec:product_left}
We now show that the complexity of the product of  with  
reaches the maximum possible bound  derived in~\cite{BJL13}. 
As in~\cite{BJL13} we use the following construction:
Define a DFA  from DFAs  and 
by omitting  the final state of 
and all the transitions from the final state,
and redirecting all the transitions that  go
from a non-final state of 
to the final state of 
to the initial state of .
It was proved in~\cite{BJL13} that  accepts .
The construction is illustrated in Figure~\ref{fig:LProd} for  and .

\begin{figure}[ht]
\unitlength 9pt
\begin{center}\begin{picture}(36,8)(0,1)
\gasset{Nh=2.4,Nw=2.4,Nmr=1.2,ELdist=0.4,loopdiam=1.0}
\node(1')(2,4){}\imark(1')
\node(2')(6,4){}
\node(3')(10,4){}
\drawedge(1',2'){}
\drawedge(2',3'){}

\drawedge[curvedepth=1.2,ELdist=.4](3',2'){}

\drawloop(1'){}
\drawloop(2'){}

\node(1)(16,4){}
\node(2)(20,4){}
\node(3)(24,4){}
\node(4)(28,4){}
\node(5)(32,4){}\rmark(5)

\drawedge(1,2){}
\drawedge(2,3){}
\drawedge(3,4){}
\drawedge(4,5){}

\drawedge[curvedepth= 1.2,ELdist=-.7](3,2){}
\drawedge[curvedepth=-2.5,ELdist=-1.0](4,2){}
\drawedge[curvedepth=3,ELdist=-1](5,2){}

\drawedge(3',1){}

\drawloop(1){}
\drawloop(2){}
\
\end{picture}\end{center}
\caption{Product of left-ideal witnesses with , .}
\label{fig:LProd}
\end{figure}



\begin{theorem} [Left Ideals: Product]
\label{thm:LProd}
For , the complexity of  the product of  and   is .
\end{theorem}
\begin{proof}
By construction  has  states.
It is also clear that the shortest word accepted by state  is , whereas for a state  with  it is , for state  it is , and for any state  with  it is .
Hence all the states are distinguishable by their shortest words.
\end{proof}


\subsection{Boolean Operations}
\label{ssec:boolean_left}
As pointed out earlier, two different languages have to be used to reach the maximal complexity for boolean operations. 
Let ,  ,
and . Figure~\ref{fig:LBool} shows DFAs  and  . 


\begin{figure}[ht]
\unitlength 9pt
\begin{center}\begin{picture}(36,8)(0,1)
\gasset{Nh=2.4,Nw=2.4,Nmr=1.2,ELdist=0.3,loopdiam=1.0}
\node(1')(2,4){}\imark(1')
\node(2')(6,4){}
\node(3')(10,4){}
\node(4')(14,4){}\rmark(4')
\drawedge(1',2'){}
\drawedge(2',3'){}
\drawedge(3',4'){}

\drawedge[curvedepth=-1.7,ELdist=-.9](3',2'){}
\drawedge[curvedepth=2,ELdist=0.5](4',2'){}

\drawloop(1'){}
\drawloop(2'){}
\drawloop(3'){}

\node(1)(20,4){}\imark(1)
\node(2)(24,4){}
\node(3)(28,4){}
\node(4)(32,4){}
\node(5)(36,4){}\rmark(5)

\drawedge(1,2){}
\drawedge(2,3){}
\drawedge(3,4){}
\drawedge(4,5){}

\drawedge[curvedepth=1.2,ELdist=-.8](3,2){}
\drawedge[curvedepth=-3.5,ELdist=-.8](4,2){}
\drawedge[curvedepth=3.0,ELdist=0.5](5,2){}

\drawloop(1){}
\drawloop(2){}
\drawloop(3){}
\drawloop(4){}
\end{picture}\end{center}
\caption{Left-ideal witnesses for boolean operations with , .}
\label{fig:LBool}
\end{figure}



\begin{theorem}[Left Ideals: Boolean Operations]
\label{thm:LBool}
If  and  is any proper binary boolean function, then
the complexity of  is .
\end{theorem}
\begin{proof}
Our first task is to show that all  states of  are reachable.
State  is the initial state. For ,   is reachable by , and for ,  is reachable by .
Next,   is reached from  by  for , and 
 is reached from  by  for .

Let  and ; then .
Note that  is a permutation on the set . Since  is a cyclic permutation of order  on , and  is also a cyclic permutation of order  on ,   is a permutation of order  on .

Let  and  be elements of , such that . Then . 
Since  and  
are coprime,  by the Chinese Remainder Theorem the equivalences  and  have a unique solution modulo  for . 
Since ,  we have  . Combined with , this gives . Applying   to , gives the state . 
So for every pair  and  such that ,    is reachable from   by  some number of 's.

If    is reachable,  all  such that   are also reachable. 
Since   is reachable for ,  all  such that  are  reachable. 
Since  is reachable, all  such that  are reachable. Since all remainders modulo   have  at least one representative, all of  is reachable.

We prove distinguishability using a number of claims:
\be
\item
{\bf  is distinguishable from every other state in Column 2.}\hfill
	\be
	\item If the operation is intersection (symmetric difference), then  is distinguishable from all other states in Column , since  is the only final (non-final) state in this column. Note that  () acts as the identity on the set   ().
	Hence  is the identity on 
	, and
	 maps  to .
	If two states are in the same column, then so are their successors after  is applied, for any . Therefore applying  to  leads to a state in Column ; so  and  are distinguishable by .
	
	\item
	If the operation is union (difference), then  is distinguishable from any other state in Column . 
	Consider  and ; applying  results in  and , where . Following this by  yields  and , where . Hence  distinguishes  from .
	\ee
\item
{\bf  is distinguishable from every other state in Row 2.}\hfill\\
The argument is symmetric to that for Claim 1,  when the operation is intersection, symmetric difference, or union. If the operation is difference, the states can be distinguished by  since this maps  to , which is distinguishable from all other states in Row .
\item
{\bf For any two states in the same column there is a word mapping exactly one of them to .}\hfill\\
Let the two states be  and . 
If , let ; otherwise, let . Applying  
results in  and , where , since .
Thus we can assume that the pair of states to be distinguished is  and , where . 
Now  takes these states to  and , and , since  can map two states of  to the same state only if these states are  and . 
Observe that  cyclically permutes states .
So  applying   a sufficient number of times maps exactly one of the two states to .
\item
{\bf For any two states in the same row there is a word mapping exactly one of them to .}\hfill\\
The proof is symmetric to that for Claim 3, 
if we interchange rows and columns and replace  by .

\item
{\bf  For any pair of states, there exists a word that maps one of the states to  and the other to a state , , or , .}
There are several cases:
\be
\item
If the states are in the same column or row, then the result holds by Claims 3 and 4.
Hence assume they  are not in the same column or row.
\item
If both states  
lie outside of Row ,
then  takes both states to Column  but it takes each state to a different row. The result now follows by Claim~3.

\item
If  both states  
lie outside of Column ,
then    takes both states to Row  but it takes each state to a different column. The result now follows by Claim~4.

\item
If one of the states is , then  takes it to . If Case (b) does not apply, the other state must have been taken to Row .
If Case (c) also does not apply, it must also have been taken to Column .
Thus the other state must have been taken to . 
Applying  again
results in  and , 
and this reduces to Case~(b).
\item
If the states are  and , then applying  results in 
 and , 
and Case (b) applies.
\item
In the remaining case, one state is in Row  and the other state is in Column ; furthermore, neither state is the state  from Case (d), and the pair of states being considered is not the pair  and  from Case (e).

If the state in Row  is not , applying  sends it to a state that is not in Column , and the other state to Column ; so Case (c) applies. 
Otherwise, the state in Row  is  and the state in Column  is not . Applying  sends the first state to Row 2 and the other state to a state not in Row ; so Case (b) applies.
\ee
\ee
We have shown that for any pair of states, there exists a word that takes one of the states to  and the other state not to  but to either Row  or Column  by Claim 5.
By Claims 1 and 2, those states are distinguishable. Therefore the original states are also distinguishable.
\end{proof}


\begin{remark}
For regular left ideals, the minimal alphabet required to meet all the bounds has five letters. 
As was the case with right ideals, it is possible to reduce the alphabet for some operations~\cite{BJL13}. The sizes are as follows:
reversal (3/4), star (2/2), product (1/2), union , intersection (2/3), symmetric difference (2/3), and difference (3/3). Note that the previously known witness for union used a four-letter alphabet, while ours only uses three letters. 
\end{remark}


\section{Two-Sided Ideals}
\label{sec:2sided}

The following stream of two-sided ideals was  defined in~\cite{BrYe11}:


\begin{definition}
\label{def:2sided}
For , let  
, where
, 
and  is defined by the transformations
,
,
,
,
,
and .
The structure of   is shown in Figure~\ref{fig:2sided}. 
\end{definition}

\begin{figure}[ht]
\unitlength 7pt
\begin{center}\begin{picture}(43,19)(0,-1)
\gasset{Nh=2.5,Nw=4,Nmr=1.25,ELdist=0.4,loopdiam=1.5}
\node(n)(8,14){}\rmark(n)
\drawloop(n){}

\node(1)(1,7){1}\imark(1)
\node(2)(8,7){2}
\node(3)(15,7){3}
\node(4)(22,7){4}
\node[Nframe=n](4dots)(29,7){}
	{\small
\node(n-2)(36,7){}
	}
	{\small
\node(n-1)(43,7){}
	}
\drawedge(2,n){}
\drawedge(1,2){}
\drawloop(1){}
\drawloop[loopangle=270,ELdist=.2](2){}
\drawedge[curvedepth= 1,ELdist=.1](2,3){}
\drawedge[curvedepth= 1,ELdist=-1.2](3,2){}
\drawloop(3){}
\drawedge(3,4){}
\drawedge[curvedepth= 2.5,ELdist=-1](4,2){}
\drawedge(4,4dots){}
\drawedge(4dots,n-2){}
\drawloop(4){}
\drawloop(n-2){}
\drawedge(n-2,n-1){}
\drawedge[curvedepth= 5,ELdist=-1.2](n-2,2){}
\drawedge[curvedepth= -9.5,ELdist=-1.2](n-1,2){}
\drawedge[curvedepth= 9.5,ELdist=-1.5](n-1,1){}
\drawloop(n-1){}
\end{picture}\end{center}
\caption{Minimal DFA   of Definition~\ref{def:2sided}.}
\label{fig:2sided}
\end{figure}

This stream of languages is closely related to the stream of Figure~\ref{fig:RegWit}.
The DFA  of Definition~\ref{def:2sided} is constructed by taking  of Figure~\ref{fig:RegWit} with states relabeled , adding new states  and , and new inputs ,  , and . 


\begin{theorem}[Two-Sided Ideals]
For each ,  
the DFA  of Definition~\ref{def:2sided} is minimal and its 
language  is a two-sided ideal of complexity .
The stream   with dialect stream

is most complex in the class of regular two-sided ideals.
In particular, this stream meets all the complexity bounds listed below, which are maximal for two-sided ideals. In several cases the bounds can be met with restricted alphabets, as shown below.
\be
\item
The syntactic semigroup of  has cardinality .  Moreover, fewer than six inputs do not suffice to meet this bound.
\item
All quotients of  have complexity , except the quotient corresponding to state , which has complexity .
\item
 has  atoms. 


\item
For each atom  of , the complexity  satisfies:

\item
The reverse of  has complexity .

\item
The star of  has complexity .
\item
The product  has complexity .
\item
For any proper binary boolean function , the complexity of 
is maximal. In particular,
	\be
	\item
	  has complexity , as does\\ 
	 .
	 \item
	 has complexity 	.
	\item
	 has complexity 	.
	\item 
	If , the bounds are met by  and .
	\ee
\ee
\end{theorem}
\begin{proof}
Notice that inputs ,  and  are needed to make all the states reachable.
It was proved in~\cite{BrYe11} that   is minimal and accepts a two-sided ideal.
\be
\item
It was shown in~\cite{BrSz14} that the syntactic semigroup of a two-sided ideal of complexity  has cardinality at most , and
in~\cite{BrYe11} that the syntactic semigroup of  has that cardinality. 
Moreover, it was proved in~\cite{BSY15} that an alphabet of at least six letters is required to meet this bound. 
\item
This follows from Definition~\ref{def:2sided}.
\item
The number of atoms of any regular language  is equal to the complexity of the reverse of ~\cite{BrTa13}. It was proved in~\cite{BrYe11} that the complexity of the reverse of  is .
\item
This was proved in~\cite{BrDa15}.

\item
See Item~3 above.
\item
The argument is the same as for the star of right ideals.
\item
See Theorem~\ref{thm:2Prod}.
\item
See Theorems~\ref{thm:2Bool} and~\ref{thm:2Bool2}.
\ee
\end{proof}

\subsection{Product}
\label{ssec:product_2sided}
We show that the complexity of the product of the DFA  with  
meets the upper bound  derived in~\cite{BJL13}. We use the same construction as for left ideals for the product DFA . 
The construction is illustrated in Figure \ref{fig:TSProd} for .


\begin{theorem} [Two-Sided Ideals: Product]
\label{thm:2Prod}
For , the product of the language  with  has complexity .
\end{theorem}
\begin{proof}
By construction  has  states.
We know that all the states in  are pairwise distinguishable. Hence in , for each pair there exists a word that takes one state to state 1 and the other to a state in . Also, all pairs of distinct states in  are distinguishable. 
To distinguish a state  from a state  in , note that every word accepted from  contains two 's, whereas there are words accepted from  that contain only one .

\end{proof}


\begin{figure}[ht]
\unitlength 9pt
\begin{center}\begin{picture}(36,10)(1,-1)
\gasset{Nh=2.4,Nw=2.4,Nmr=1.2,ELdist=0.4,loopdiam=1.0}
\node(1')(2,4){}\imark(1')
\node(2')(7,4){}
\node(3')(12,4){}
\node(4')(17,4){}

\drawedge(1',2'){}
\drawedge(2',3'){}
\drawedge(3',4'){}

\drawedge[curvedepth=1.3,ELdist=-.9](3',2'){}
\drawedge[curvedepth=-4.5,ELdist=-1.0](4',2'){}

\drawloop(1'){}
\drawloop(2'){}
\drawloop(3'){} 
\drawloop(4'){} 

\node(1)(22,4){}
\node(2)(27,4){}
\node(3)(32,4){}
\node(4)(37,4){}
\node(5)(27,-1){}\rmark(5)

\drawedge(1,2){}
\drawedge(2,3){}
\drawedge(3,4){}
\drawedge(2,5){}

\drawedge[curvedepth= -5,ELdist=.6](2',1){}

\drawedge[curvedepth= 1.2,ELdist=-.7](3,2){}
\drawedge[curvedepth=-2.5,ELdist=-1.0](4,2){}


\drawloop(1){}
\drawloop(2){}
\drawloop[loopangle=360](5){}
\end{picture}\end{center}
\caption{Product of two-sided-ideal witnesses with , .}
\label{fig:TSProd}
\end{figure}


\subsection{Boolean Operations}
\label{ssec:boolean_2sided}
\begin{theorem}[Two-Sided Ideals: Boolean Operations]
\label{thm:2Bool}
If , then
\be
\item
The complexity of  is .
\item
The complexity of  is .
\item
The complexity of  is .
\item
The complexity of  is .
\ee
\end{theorem}
\begin{proof}
As before, we take the direct product DFA  and count reachable and distinguishable states.
First we prove all states are reachable, as illustrated in Figure~\ref{fig:2Cross}. State  is the initial state, and  is reached from  by  . Since  generates all permutations of  and , by~\cite[Theorem 1]{BBMR14} all states in  are reachable, unless ; the case  does not occur since , and we have verified the other special cases computationally. Thus it remains to show that all states in Rows  and  and Columns  and  are reachable.

For Row 1, first note that  is reachable since .
Then 
for , so we can reach .
Finally, we can reach  since .
A symmetric argument applies to Column 1.
For Row , note  is reachable since it is in Column 1.
Then we have , and , for , and finally .
A symmetric argument applies to Column .


\begin{figure}[ht]
\unitlength 8pt
\begin{center}\begin{picture}(30,27)(0,-8)
\gasset{Nh=2.5,Nw=2.5,Nmr=1.2,ELdist=0.3,loopdiam=1.2}
\node(1'1)(2,15){}\imark(1'1)
\node(2'1)(2,10){}
\node(3'1)(2,5){}
\node(4'1)(2,0){}
\node(5'1)(2,-5){}

\node(1'2)(7,15){}
\node(2'2)(7,10){}
\node(3'2)(7,5){}
\node(4'2)(7,0){}
\node(5'2)(7,-5){}

\node(1'3)(12,15){}
\node(2'3)(12,10){}
\node(3'3)(12,5){}
\node(4'3)(12,0){}
\node(5'3)(12,-5){}

\node(1'4)(17,15){}
\node(2'4)(17,10){}
\node(3'4)(17,5){}
\node(4'4)(17,0){}
\node(5'4)(17,-5){}

\node(1'5)(22,15){}
\node(2'5)(22,10){}
\node(3'5)(22,5){}
\node(4'5)(22,0){}
\node(5'5)(22,-5){}

\node(1'6)(27,15){}
\node(2'6)(27,10){}
\node(3'6)(27,5){}
\node(4'6)(27,0){}
\node(5'6)(27,-5){}

\drawedge[ELpos=40](1'1,2'2){}
\drawedge(1'2,1'3){}
\drawedge(1'3,1'4){}
\drawedge(1'4,1'5){}
\drawedge(2'1,3'1){}
\drawedge(3'1,4'1){}
\drawedge(1'6,2'6){}
\drawedge(5'1,5'2){}
\drawedge[curvedepth=2.2,ELdist=0.4](4'2,1'2){}
\drawedge[curvedepth=-2.4,ELdist=-1](2'5,2'1){}
\drawedge[curvedepth=2.9,ELdist=0.2](1'2,1'6){}
\drawedge[curvedepth=-2.2,ELdist=-0.8](2'1,5'1){}

\drawedge[curvedepth= - 2.9,ELdist=0.2](5'2,5'6){}
\drawedge(5'2,5'3){}
\drawedge(5'3,5'4){}
\drawedge(5'4,5'5){}
\drawedge(2'6,3'6){}
\drawedge(3'6,4'6){}
\end{picture}\end{center}
\caption{Partial direct product for boolean operations on two-sided ideals. 
}
\label{fig:2Cross}
\end{figure}

Before we begin the distinguishability proofs, we make a few observations. Let  and  be states with ; note that .
\be
\item
If , the word  sends  to a state in Row . It sends  to either Row 1 (if ) or Row  (if ); in either case  is not sent to Row  or Row .
\item
If , the word  sends  to Row , and it  sends  to the same  row as .
\item
If , then  sends  to Row , and  to a row other than Row .  If , then , the state  is in Row , and the state  is not in Row . 
\ee
Thus the word  will send any state in Row  to Row , and any state not in Row  to a row other than Row . By a symmetric argument, the word  sends states in Column  to Column , and states not in Column  to a different column, for . We use this fact frequently to distinguish states.

For each boolean operation we now prove that the number of distinguishable states meets the relevant upper bound.
\be
\item
{\bf Intersection/Symmetric Difference.}
For intersection, the only final state is . For symmetric difference, every state in Row  or Column  except   is final, and  is the only empty state. We can use the same distinguishing words in both cases.
	\be
	\item
	{\bf States in distinct rows, }: States  and , , are distinguishable by first applying . This sends one of the states to Row , and the other to a different row.  We then apply : applying  sends the state in Row  to   or , and the state not in Row  to  or . Then  fixes   or  and sends the other state to   or . Finally, applying  sends  one state to , and the other state to . 
	\item
	{\bf States in distinct columns, }: The argument is symmetric if we interchange  and .
	\ee
Since all states are distinguishable, the complexity  is .

\item
{\bf Difference.}
Here the final states are those which are in Row , but not Column .
States in Column  are indistinguishable and empty, since no word can take any of these states out of Column , and that column 	contains only non-final states. Hence there are at most  distinguishable states.
	\be
	\item
	{\bf States in Row , }: States  and  are distinguishable by , since  is the only non-final state in Row .
	\item
	{\bf States in distinct rows, and one state is in Column }:
Any state outside of Column  accepts , and thus all of these states are non-empty. It follows that all states outside of Column  are distinguishable from the empty states in Column . 
	\item
	{\bf States in distinct rows, and neither state is in Column }: 
    States  and , with  and , are distinguishable by  unless this word sends   to . This occurs only if  and  sends   to . In this case, applying  after   sends   to , and does not affect the row numbers; thus one of them will be in Row 2 and the other in neither Row 2 nor Row . Then  distinguishes the states.
	\item
	{\bf States in distinct columns}: The arrangement of final and non-final states in Row  matches that of symmetric difference. Thus the argument used for intersection/symmetric difference  applies here also.
	\ee
Since all states in  are distinguishable, the complexity of difference is .

\item
{\bf Union.}
The final states are those in Row  and Column .
All final states are indistinguishable, since they all accept .
Therefore there are at most  distinguishable states. 
\be
\item
{\bf Non-final states in distinct rows}:
Two non-final states  and ,  with   and , are distinguishable by , unless this word sends  to Column  (since it also sends  to Row ). This occurs only if  sends  to Column 2. In this case we can use  to distinguish the states; this is similar to Case (c) of the difference operation.
\item
{\bf Non-final states in distinct columns}:
These states are distinguishable by a symmetric argument.
\ee
Thus the complexity of union is . 
\ee
\end{proof}

If , the complexity bounds for boolean operations can be met by using languages from the stream  for both arguments. That is, we can meet the bounds for boolean operations without the dialect stream .

\goodbreak

\begin{theorem}[Two-Sided Ideals: Boolean Operations, ]
\label{thm:2Bool2}
Suppose  and .
\be
\item
The complexity of  is .
\item
The complexity of  is .
\item
The complexity of  is .
\item
The complexity of  is .
\ee
\end{theorem}

\begin{proof}
Here we consider the DFA .
The proof that all states are reachable is identical to the proof above, except state  is reachable from  by  instead of , and when applying~\cite[Theorem~1]{BBMR14} the special cases we must verify are only , since we are assuming .
Also, for states  and  with , the same remark about the word  applies, i.e., this word sends  to Row  and  to a different row. For  and  with , the word  sends  to Column  and  to a different column (previously we used  for this purpose).

For each boolean operation we now prove that the number of distinguishable states meets the relevant upper bound.
\be
\item
{\bf Intersection/Symmetric Difference.}
As before, the same distinguishing words can be used for intersection and symmetric difference.
\be
\item
{\bf States in Column }: States  and , with , are distinguishable by .
\item
States  and  are distinguishable as follows. Since all states in 

 are reachable from  using words in , there is a word  which sends  to . 
If we view  as a permutation on  alone, it must fix .
Thus  sends  to . 
Then  and  are distinguished by .
\item
{\bf States in Column }: States  and , with , are distinguishable since the word  reduces this case to Case (a) or (b).
\item
By symmetry, states in the same row are distinguishable.
\item
{\bf States in distinct columns}:  and , , are distinguishable  by first applying . This sends  to some state in Column 2 and  to some state in Column . If these successor states  are in the same row, then this case reduces to Case (d). Otherwise, since  was applied, the only possible states are  and , or  and . In either case, these states are distinguished by . 
\item
By symmetry, states in distinct rows are distinguishable.
\ee
Since all states are distinguishable, the complexity of intersection is .

\item
{\bf Difference.}
States in Column  are empty and thus indistinguishable.
\be
\item
{\bf States in distinct columns, and one state is in Column }:
All states ,  are non-empty, and thus distinguishable from those in Column . To see this, observe that if , then  is a final state and thus is non-empty. If  then  sends  to . Since every state in 
 is reachable from , there is a word  that sends  to . Then  sends  to the final state .
\item
{\bf States in distinct columns, and neither state is in Column }:
States  and , with  are distinguishable since applying  reduces this case to 
Case~(a).
\item
{\bf States in distinct rows, and neither state is in Column }:
States  and , with  and  not both equal to , are distinguishable by , unless this word sends   to .
This occurs only if   and  sends  to .
Recall that  sends  to Row 2, and sends  to a row other than Row 2 or Row ; so suppose that after applying  the states are  and   for some .
There is a word  which sends  to . 
If we view  as a permutation on , it sends  to , so it sends  to some .
So  sends  and  to  and  respectively; since  these states are distinguished by .
\ee
Since  is a maximal distinguishable set, the complexity of set difference is .

\item
{\bf Union.}
All final states are indistinguishable, since they all accept .
\be
\item
{\bf Non-final states in the same row}:
Consider states  and  with  and .
The word  takes these to   or , and  respectively for some ; note  that in either case  does not get mapped to Column .
Hence the two states are sent to  where  and , respectively.
If , then these states are distinguished by .

If , there exists a word  which maps  to .
We can view  as a permutation on  which fixes  and ; it sends  to  and sends  to some , since it is bijective. 
Hence the other state  is sent to  for some .
Then  and  are distinguished by .
\item
{\bf Non-final states in the same column}: These are distinguishable by a symmetric argument.

\item
{\bf Non-final states in distinct columns}:
Non-final states  and , with   and , are distinguishable by , unless this word sends  to Row  (since it also sends  to Column ). This occurs only if  sends  to Row . 
Note that  sends  to Column ; so after applying  the states are  and  for some  and .  By (a) and (b), we can assume . Then  distinguishes the states.
\item
{\bf Non-final states in distinct rows}:
A symmetric argument works.
\ee
Since all non-final states are distinguishable and all final states are indistinguishable, the complexity of union is . 

\ee
\end{proof}

\begin{remark}
For regular two-sided ideals, the minimal alphabet required to meet all the bounds has six letters. 
As before, it is possible to reduce the alphabet for some operations~\cite{BJL13}. The sizes are as follows:
reversal (3/4), star (2/3), product (1/3), union (2/5), intersection (2/5), symmetric difference (2/5), and difference (2/5). 

\end{remark}

\section{Conclusions}
In the case of regular right, left, and two-sided ideals,
we have demonstrated that there exist  single witness streams that meet the bounds for all of our complexity measures, and that the only dialects required are those in which two  letters are interchanged; this is needed in the case where the bounds for boolean operations are to be met with witnesses of the same complexity.
\providecommand{\noopsort}[1]{}
\begin{thebibliography}{10}
\providecommand{\url}[1]{\texttt{#1}}
\providecommand{\urlprefix}{URL }

\bibitem{AhCo75}
Aho, A., Corasick, M.J.: Efficient string matching: An aid to bibliographic
  search. Communications of the ACM  18(6),  333--340 (1975)

\bibitem{BBMR14}
Bell, J., Brzozowski, J., Moreira, N., Reis, R.: Symmetric groups and quotient
  complexity of boolean operations. In: Esparza, J., et~al. (eds.) ICALP 2014.
  LNCS, vol. 8573, pp. 1--12. Springer (2014)

\bibitem{Brz10}
Brzozowski, J.: Quotient complexity of regular languages. J. Autom. Lang. Comb.
   15(1/2),  71--89 (2010)

\bibitem{Brz13}
Brzozowski, J.: In search of the most complex regular languages. Int. J. Found.
  Comput. Sci.,  24(6),  691--708 (2013)

\bibitem{Brz16}
Brzozowski, J.: Unrestricted state complexity of binary operations on regular
  languages. In: C{\^a}mpeanu, C., Manea, F., Shallit, J. (eds.) DCFS 2016.
  LNCS, vol. 9777, pp. 60--72. Springer (2016)

\bibitem{BrDa14}
Brzozowski, J., Davies, G.: Most complex regular right ideals. In: J\"urgensen,
  H., Karhum\"aki, J., Okhotin, A. (eds.) DCFS 2014. LNCS, vol. 8614, pp.
  90--101. Springer (2014)

\bibitem{BrDa15}
Brzozowski, J., Davies, S.: Quotient complexities of atoms in regular ideal
  languages. Acta Cybernetica  22(2),  293--311 (2015)

\bibitem{BJL13}
Brzozowski, J., Jir{\'a}skov{\'a}, G., Li, B.: Quotient complexity of ideal
  languages. Theoret. Comput. Sci.  470,  36--52 (2013)

\bibitem{BrCo16}
Brzozowski, J., Sinnamon, C.: Unrestricted state complexity of binary
  operations on regular and ideal languages (2016), {\small\tt
  http://arxiv.org/abs/1609.04439}

\bibitem{BrSz14}
Brzozowski, J., Szyku{\l}a, M.: Upper bounds on syntactic complexity of left
  and two-sided ideals. In: Shur, A.M., Volkov, M.V. (eds.) DLT 2014. LNCS,
  vol. 8633, pp. 13--24. Springer (2014)

\bibitem{BrSz15a}
Brzozowski, J., Szyku{\l}a, M.: Complexity of suffix-free regular languages.
  In: Kosowski, A., Walukiewicz, I. (eds.) FCT 2015. LNCS, vol. 9210, pp.
  146--159. Springer (2015)

\bibitem{BSY15}
Brzozowski, J., Szyku{\l}a, M., Ye, Y.: Syntactic complexity of regular ideals
  (September 2015), {\small\tt http://arxiv.org/abs/1509.06032}

\bibitem{BrTa13}
Brzozowski, J., Tamm, H.: Quotient complexities of atoms of regular languages.
  Int. J. Found. Comput. Sci.  24(7),  1009--1027 (2013)

\bibitem{BrTa14}
Brzozowski, J., Tamm, H.: Theory of \'atomata. Theoret. Comput. Sci.  539,
  13--27 (2014)

\bibitem{BrYe11}
Brzozowski, J., Ye, Y.: Syntactic complexity of ideal and closed languages. In:
  Mauri, G., Leporati, A. (eds.) DLT 2011. LNCS, vol. 6795, pp. 117--128.
  Springer Berlin / Heidelberg (2011)

\bibitem{CrHa90}
Crochemore, M., Hancart, C.: Automata for pattern matching. In: Rozenberg, G.,
  Salomaa, A. (eds.) Handbook of Formal Languages, vol.~2, pp. 399--462.
  Springer (1997)

\bibitem{CHL07}
Crochemore, M., Hancart, C., Lecroq, T.: Algorithms on Strings. Cambridge
  University Press (2007), 392 pages

\bibitem{HoKo04}
Holzer, M., K\"{o}nig, B.: On deterministic finite automata and syntactic
  monoid size. Theoret. Comput. Sci.  327(3),  319--347 (2004)

\bibitem{Iva16}
Iv\'an, S.: Complexity of atoms, combinatorially. Inform. Process. Lett.
  116(5),  356--360 (2016)

\bibitem{Myh57}
Myhill, J.: Finite automata and representation of events. Wright Air
  Development Center Technical Report  57--624 (1957)

\bibitem{Ner58}
Nerode, A.: Linear automaton transformations. Proc. Amer. Math. Soc.  9,
  541--544 (1958)

\bibitem{Pic39}
Piccard, S.: Sur les bases du groupe sym\'etrique. \v{C}asopis pro
  p\v{e}stov\'an\'i matematiky a fysiky  68(1),  15--30 (1939)

\bibitem{Pin97}
Pin, J.E.: Syntactic semigroups. In: Handbook of Formal Languages, vol.~1:
  Word, Language, Grammar, pp. 679--746. Springer, New York, NY, USA (1997)

\bibitem{YCDLK06}
Yu, F., Chen, Z., Diao, Y., Lakshman, T.V., Katz, R.H.: Fast and
  memory-efficient regular expression matching for deep packet inspection. In:
  Proceedings of the 2006 ACM/IEEE Symposium on Architecture for Networking and
  Communications Systems ANCS\/. pp. 93--102. ACM, New York (2006)

\bibitem{Yu01}
Yu, S.: State complexity of regular languages. J. Autom. Lang. Comb.  6,
  221--234 (2001)

\end{thebibliography}

\end{document}
