\documentclass[envcountsame]{llncs}
\usepackage{amssymb,amsmath}
\usepackage{graphicx}





\newcommand{\Nat}{\mathbb{N}}
\newcommand{\mon}[2]{Q_{#1}^{#2}}
\newcommand{\nnp}{\mathrm{nnp}}
\newcommand{\FO}{\mathrm{FO}}
\newcommand{\GROUP}{\mathrm{GROUP}}
\newcommand{\MOD}{\mathrm{MOD}}
\newcommand{\Arb}{\mathrm{arb}}
\newcommand{\MAJ}{\mathrm{MAJ}}
\newcommand{\IL}{\mathrm{IL}}
\newcommand{\IR}{\mathrm{IR}}
\newcommand{\uniform}{\mathrm{uniform}}
\newcommand{\NL}{\mathbf{N}}
\newcommand{\REG}{\mathrm{REG}}
\newcommand{\alphabet}{\mathcal{A}}
\newcommand{\defs}{::=}
\newsavebox{\meinebox}


\begin{document}
\title{Non-definability of languages by generalized first-order formulas over (,+)}
\titlerunning{Non-definability of languages by generalised first-order formulas over (,+)}
\author{Andreas Krebs \inst{1} \and
A V Sreejith\inst{2}}

\institute{ Wilhelm-Schickard Institut, Universtit\"at T\"ubingen, Germany
\and Institute of Mathematical Sciences, Chennai, India}

\maketitle


\begin{abstract}
We consider first-order logic with monoidal quantifiers over words. We show that all languages with a neutral letter, definable using the 
addition predicate are also definable with the order predicate as the only numerical predicate. Let  be a subset of monoids.
Let  be the logic closed under quantification over the monoids in , and  be the class of neutral letter languages.
Then we prove that 

Our result can be interpreted as the Crane Beach conjecture to hold for the logic [\textless,].
As a consequence we get the result of Roy and Straubing that
FOMOD[\textless,] collapses to FOMOD[\textless]. For cyclic groups, we answer an open question of Roy and Straubing, proving that MOD[\textless,] collapses to MOD[\textless].
Our result also shows that multiplication as a numerical predicate is necessary for Barrington's theorem to hold and also to simulate
majority quantifiers.

All these results can be viewed as separation results for highly uniform circuit classes. For example we separate 
FO[\textless,]-uniform CC from FO[\textless,]-uniform ACC.
\end{abstract}



\section{Introduction}
Consider a language with a ``neutral letter", i.e. a letter which can be inserted or deleted from any word in the language without 
changing its membership. The neutral letter concept has turned out to be useful for showing non-expressibility results. 
It had been used to establish super linear lower bounds for bounded-width branching
programs \cite{barr_superLinLBBWBP} and for the number of wires in circuit classes \cite{koucky_wiresVsGates}; it also led to results in communication complexity \cite{bddMultiPartyCommCompl}.
But mostly the concept is known in the context of the Crane Beach conjecture  proposed in \cite{barr_cbconj}.
There it was conjectured that first order logic with arbitrary numerical predicates (denoted as )  collapses to 
first order logic with only linear ordering in the presence of a neutral letter. The idea is that, in the presence of a neutral letter, formulas cannot rely on the precise location of input letters and hence numerical predicates will be of little use. Let  denote the class of languages with neutral letters. 
Let  be a set of finite monoids  and  be the logic closed under quantification, where the quantifiers are Lindstr\"om quantifiers over some monoid from . Then the Crane Beach conjecture says that 

The conjecture was refuted by Barrington et. al. \cite{barr_cbconj}, where they showed that it does not hold for the logic , i.e. 
first order logic ( consists of only the existential quantifier) using addition and multiplication relation. 
In the same paper, the authors proved that the conjecture holds for various other logics. The Boolean closure of the -fragment of  satisfies the conjecture; that is . 
Lautemann, Tesson and Th\'erien \cite{ltt06} considered quantifiers which can count modulo a prime  (called ). They obtain that , which is equivalent to .

Benedikt and Libkin \cite{libkin_relIntrStruc} in the context of collapse results in database theory showed that first order logic
with only addition satisfies the Crane Beach conjecture. A different proof of the result can be found in \cite{barr_cbconj}. 
We generalize this result to arbitrary monoidal quantifiers. Let  be a set of finite monoids. Consider the logic
 where the quantifiers are Lindstr\"om quantifiers whose languages are word problems of monoids in . Our main result
(Theorem \ref{thm_cbconj}) is that the Crane Beach conjecture hold for the logic ; that is


If  is an aperiodic monoid, then the theorem is equivalent to the result of Benedikt and Libkin. 
For solvable monoids Roy and Straubing \cite{roy_defGenFO} 
(used ideas of Benedikt and Libkin to) showed that in the presence of neutral letters   collapse to
. In their paper they raised the question: does  satisfy the Crane Beach conjecture?
This can be answered by our main theorem.

Our results can also be viewed from the perspective of descriptive complexity of circuit classes. The books
\cite{immerman_book, vollmer_book} present the close connection between logics with monoid quantifiers and circuit classes. 
We know that the set of languages accepted by uniform- circuits
are exactly those definable by first order logic using order,
addition and multiplication relations. Similarly CC (constant depth, polynomial size circuits with MOD-gates)
corresponds to , ACC corresponds to , TC corresponds to , 
and NC corresponds to  (The ``group quantifier'' evaluates
over a finite group). It is a well known result that AC is separated from ACC \cite{furst_parity}, but relationships between 
most other classes are open. For example, we do not know whether CC is different from ACC. In fact we do not know whether
 contains uniform-AC. This explains why the Crane Beach conjecture for prime modulo quantifiers \cite{ltt06}, using
arbitrary predicates, cannot be easily extended to composite modulo quantifiers.

We look at these separation questions from the descriptive complexity
perspective. As a first step, one can ask the
question of separating the logics without the multiplication
relation. That is, can one separate  from
? Is  different from ? 

Behle and Lange \cite{behle_foLessUniform} gave a notion of interpreting  as highly uniform circuit classes.  Our results therefore can be summarized as: every  uniform constant depth polynomial size circuit with gates that compute a product in  and that recognizes a language with a neutral letter can be made -uniform.

As a consequence of our main theorem we are able to separate these uniform versions of circuit classes.
For example: The theorem states that  definable languages with a neutral letter are also definable in . Since  cannot simulate the existential quantifiers \cite{str_cirBook} we have that  and  are incomparable. In fact we show that no group quantifier can simulate existential quantifier if only addition is available.
This gives an alternate proof of the known result \cite{roy_defGenFO} that  cannot count modulo a
prime , where  does not divide . 
Another consequence is that the majority quantifier cannot be simulated by group quantifiers if multiplication is not available, thus
separating  from . Barrington's theorem \cite{barr_NC1} says that word problems over any finite group can be defined by the logic which 
uses only the  group quantifier (the group whose elements are the set of all permutations over  elements) if addition and multiplication predicates are available.
Our result shows multiplication is necessary for Barrington's theorem to hold. In other words  cannot define word problems over
 if only addition is available. 

Non expressibility results for various logics which uses addition and a variety of quantifiers have been considered earlier. Lynch \cite{lynch82} proved that  cannot count modulo any number. Nurmonen \cite{nur_countQuant} and Niwi\'nski and Stolboushkin \cite{niw_yEq2x} looked at logics with counting quantifiers equipped with numerical predicates of form  and a linear ordering. Ruhl \cite{ruhl_FOUnc}, Schweikardt \cite{schwei_FOUnc},
Lautemann et.al. \cite{lautemann_logcfl}, Lange \cite{lange_majQnt} all showed the limited expressive power of addition in the presence of majority quantifiers. Behle, Krebs and Reifferscheid \cite{behle_regLangMajQnt,behle_nonSolvGrpsNotinMaj} proved that non-solvable groups are not definable in the two variable fragment of . 


For the purpose of proof we work over infinite strings which contain finite number of non-neutral letters. 
Our general proof strategy is similar to Benedikt and Libkin \cite{libkin_relIntrStruc} or Roy and Straubing \cite{roy_defGenFO} and consists of three main steps.
\begin{enumerate}
 \item Given a formula , we give an infinite set  and an ``active domain formula''  such that for all words  whose non neutral positions belong to  we have 
 .
 Active domain formulas quantify only over non-neutral letter positions. Our major contribution (Theorem \ref{thm_acd4ls}) is  showing
 this step.  
 \item We give another infinite set  and an active domain formula  such that for all words  whose non neutral positions belong to  we have 
 .
 This step follows from an application of Ramsey theory (Theorem \ref{thm_ramsey}).
 \item All active domain formulas in  accept languages with a neutral letter. This is an easy observation given by Lemma \ref{lem_acdneutr}.
\end{enumerate}
Finally using these three steps we prove our main theorem.

The main step is to build an active domain formula. Hence we need to show how to simulate a quantifier by an active domain formula.
In the case of , the quantifiers, considered as Lindstr\"om quantifiers, have a commutative and idempotent monoid. Hence
neither the order in which the quantifier runs over the positions of the word is important, nor does it matter if positions are queried
multiple times.
In Roy and Straubing this idea was extended in such a way that in the simulation of the  quantifier (again a commutative monoid),
every position is taken into account exactly once. In their construction while replacing a  quantifier they need to add
additional  quantifiers and hence their construction only allows to replace a  formula by an active domain  formula.
In this paper, we construct a formula that takes every position into account exactly once and in
the correct order. Moreover we do not introduce any new quantifier, but use only the quantifier that is replaced.
This enables us to obtain the Crane Beach conjecture for logics whose quantifiers have a non-commutative monoid or are groups. For
example , , and .

In contrast to previous work, we do not construct an equivalent active domain formula, but only a formula that is equivalent for certain domains. We show that it is in general sufficient to show this for one infinite domain. We also introduce a combinatorial structure called \emph{Sorting Tree} which can be of interest on its own. Yet another contribution is to use inverse elements of groups to merge two sorted lists of numbers. 



\noindent We present our main theorem and its corollaries in Section \ref{sec_result} followed by a section with the proof of Theorem
\ref{thm_acd4ls}. Our main contribution is 
Section \ref{sec_lemmaProof}. There we replace group quantifiers by its active domain version. 

\bigskip
\section{Preliminaries} \label{sec_prelims}
An alphabet  is a finite set of symbols. The set of all finite words over  is denoted by , the set of all right infinite words is denoted by . Let .  Consider a language  and a letter . We say that  is a \emph{neutral letter} for  if for all  we have that . We denote the set of all languages with a neutral letter by . 

For a word  
the notation  denotes the  letter in , i.e. .
For a word  in a language  with neutral letter , we define the non-neutral positions  of  to be the set of all positions which do not have the neutral letter. 


A monoid is a set closed under a binary associative operation and has an identity element. All monoids we consider except for  and  will be finite. A monoid  and  defines a \emph{word problem}. Its language is composed of words , such that when the elements of  are multiplied in order we get an element in . 
We say that a monoid  \emph{divides} a monoid  if there exists a submonoid  of  and a surjective morphism from  to
. A monoid  \emph{recognizes} a language  if there exists a morphism  and a subset
 such that . It is known that finite monoids recognize exactly regular languages \cite{str_cirBook}. We
denote by  the set of all finite monoids,  the set of all finite groups and  the set of all
finite cyclic group. We denote by  the monoid consisting of elements  under multiplication. For a monoid , the element
 will denote its identity element. We also use the block product of monoids, whose definition can be found in
\cite{str_cirBook}. For a set  of monoids,  denotes the smallest set which contains  and is closed under block products. 



Given a formula  with free variables , we write  if  is a model for the formula  when the free variables  is assigned to  for .
We abuse notation and let  also be the unary predicate symbols of the logic we consider. That is  iff . 
Let  be a set of variables,  be a set of numerical predicates and . We define the
logic  to be built from the unary predicate symbols , where , the binary predicate ,
the predicates in , the variable symbols , the Boolean connectives , and the monoid
quantifiers , where  is a monoid and . We also identify the logic class  with the set of all languages definable in it.

Our definition of monoid quantifiers is a special case of Lindstr\"om quantifiers \cite{lin_genQuant}. The formal definition of a
monoid quantifier \cite{barr_uniformNC1} is as follows. Let  be a monoid with  elements. For an , the quantifier  is applied on  formulas. Let  be a free variable and  be   formulas. Then 

iff the word  when multiplied gives the element , i.e.\  , where the  letter of , , is 


The following ``shorthand'' notation is used to avoid clutter. We denote by , the formula
. Informally, this relativizes the quantifier to the positions where  is true, by multiplying the neutral element in all other places.

Consider the monoid . It is easy to see that the word problem defined by  and the set  defines the regular language
. Then  is same as the existential quantifier , since any formula of the form  is equivalent
to . So the logic  denotes first-order logic, . Let
 stand for the cyclic group with  elements. Then the quantifiers  corresponds to modulo quantifiers
\cite{str_regGenQnt}. Thus  corresponds to all regular languages whose syntactic monoids are solvable groups
\cite{str_cirBook}. 
For a sentence  we define .
The following result gives an algebraic characterization for the logic .
\begin{lemma}[\cite{str_cirBook}]
\label{lem_logicalgb}
Let . 
Let  such that  is the smallest monoid which recognizes . 
Then  is definable in  iff  divides a monoid in .
\end{lemma}
\bigskip
\section{Results}\label{sec_result} 
Let  be any set of monoids. 
We show that the Crane Beach conjecture is true for the logic .
\begin{theorem}[Main Theorem]
\label{thm_cbconj}
 Let . Then 
\end{theorem}
The proof of this theorem is given in Section \ref{sec_cranebeach}.



\subsection{Non definability Results}

Theorem \ref{thm_cbconj} give us the following corollaries. 
\begin{corollary} 
\label{cor_regLang}
All languages with a neutral letter in  are regular.
\end{corollary}
\begin{proof}
 By Theorem \ref{thm_cbconj} we know that all languages with a neutral letter in  can be defined in  which by Lemma \ref{lem_logicalgb} is the set of all regular languages.
\qed \end{proof}

Recall that a monoid  \emph{divides} a monoid  if  is a morphic image of a submonoid of .

\begin{corollary}
  \label{cor_simGrp}
Let . Let  be a simple group that does not divide any monoid  in . Then the word problem over  is not definable in .
\end{corollary}
\begin{proof}
The word problem over  has a neutral letter. The result now follows from Theorem \ref{thm_cbconj} and Lemma \ref{lem_logicalgb}.
\qed \end{proof}



The majority quantifier,  is given as follows.

  denotes the logic closed under majority quantifiers.
It is known that the majority quantifier can be simulated by the non-solvable group  if both multiplication and addition are available \cite{vollmer_book}. We show that multiplication is necessary to simulate majority quantifiers.
\begin{corollary}
.
\end{corollary}
\begin{proof}
 Consider the language  consisting of all words with an equal number of 's and 's.  can be proven to be definable in . Also note that  is a neutral element for . By Corollary \ref{cor_regLang}, and the fact that  is nonregular,  we know that  is not definable in .
\qed \end{proof}

Barrington's theorem \cite{barr_NC1} says that the word problem of any finite group can be defined in the logic . The following theorem shows that multiplication is necessary for Barrington's theorem to hold.
\begin{corollary}
  The word problem over the group  is not definable in . Infact there does not exist any one finite monoid 
  such that all regular languages can be defined in .
\end{corollary}
\begin{proof}
   is a simple subgroup of , which does not divide . From Corollary \ref{cor_simGrp} it follows that the word problem over
   is not definable in . \\
  For any finite monoid , there exists a simple group  such that  does not divide  and hence the word problem over  is
  not definable in .
\qed \end{proof}

Let  be the set of all words  such that the number of occurrences of  in  is equal to . Then we
get the result in \cite{roy_defGenFO} that  is not definable in , if  is a prime which does not divide
.
\begin{corollary}[\cite{roy_defGenFO}]
  If  is a prime which does not divide , then  is not definable in .
\end{corollary}
\begin{proof}
  Let  be definable in . Since  is a neutral letter in , Theorem \ref{thm_cbconj} says
   is also definable in .  Due to Lemma \ref{lem_logicalgb} and \cite{str_cirBook}, this is a contradiction.
\qed \end{proof}

It is an open conjecture whether the language  can be accepted by the circuit complexity class CC \cite{str_cirBook}. It is also known that languages accepted by CC circuits are exactly those which are definable by  formulas \cite{vollmer_book}. 

To progress in this direction Roy and Straubing \cite{roy_defGenFO} had posed the question of whether . Below we show that this is the case. 


\begin{corollary}
 . In fact .
\end{corollary}
\begin{proof}
  The minimal monoid which can accept  is  and clearly the language is in . By Theorem \ref{thm_cbconj} if
  there is a formula in  which can define , then  can also define .
  From Lemma \ref{lem_logicalgb} it follows that the monoid  divides a group. But this is a contradiction \cite{str_cirBook}.
\qed \end{proof}

Behle and Lange \cite{behle_foLessUniform} give a notion of interpreting  as highly uniform circuit classes.  As a consequence we can interpret the following results as a separation of the corresponding circuit classes.
\begin{corollary}
The following separation results hold, for all 
\begin{itemize}
\item .
\item .
\item 
\item 
\item 
\end{itemize}
\end{corollary}



\subsection{Regular languages in }
We now look at regular languages definable by the logic , for an . We first show that this logic is closed under quotienting.

\begin{lemma} \label{lem_qnt}
Let  and  be a finite alphabet. Let  be definable in  and . Then  is also definable in .
\end{lemma}
\begin{proof}
\qed \end{proof}

We now show that the logic is also closed under inverse length perserving morphisms.
\begin{lemma} \label{lem_morph}
Let . Let  be finite alphabets and let  be a homomorphism such that  for some fixed . If  is definable in , then  is also definable in .
\end{lemma}
\begin{proof}
\qed \end{proof}

We now give an algebraic characterization for regular languages definable by . 
\begin{theorem}
Let . Let  be a regular language. Then  is definable in  iff there exists a semigroup  and a morphism, , such that for all , every monoid in  is also in .
\end{theorem}
\begin{proof}

\qed \end{proof}


Let  be a set of monoids such that, given a monoid , it is decidable if  divides a block product of monoids in . 
Then, given a regular language , it is decidable if .
Together with our main theorem we get that it is decidable if .

\begin{corollary}
Let  be a set of monoids such that, given a monoid , it is decidable if  divides a block product of monoids in
. Then, given a regular language , it is decidable if .
\end{corollary}

For  this was proved in \cite{roy_defGenFO}. Here we prove this for the special case when .
\begin{corollary}
Given a regular language , the question whether  is definable in  is decidable.
\end{corollary}

\bigskip
\section{Proof of the Main Theorem}\label{sec_cranebeach}
In this section we handle the general proof steps as in Libkin or Roy and Straubing of removing the plus predicate from the formula in the presence of a neutral letter. We show that all these results go through even in the presence of general Lindstr\"om quantifiers. The new crucial step is Lemma \ref{lem_acd4grpqnt} where we convert a group quantifier to an active domain formula without introducing any other quantifiers. The proof of this lemma is deferred to the next section.


Let  be any nonempty set. To prove Theorem \ref{thm_cbconj} we will consider the more general logic,  over 
the alphabet . In this logic  is a binary function,  is a constant, and  means  divides . 
The reason for introducing these new relations (which are definable using ) is to use a quantifier elimination procedure.
All languages recognized by this logic are in . 

The formulas we consider will usually define languages with a neutral letter. 
Let an \emph{active domain formula} over a letter  be a formula where all quantifiers are of the form:
.
That is the quantifiers, quantify only over the ``active domain'', the positions which does not contain the letter .
For the purpose of the proof we assume that the neutral letter language defined by a formula  is a subset of . 
The idea is to work with infinite words, where the arguments are easier, since the variable range is not bounded by the word length.

For  we define the set . We say that a formula  \emph{collapses} to , if  is an active domain formula in  and there exists an 
 such that for all ,  with 
 and for all  we have that 
 
In the above definition we say that  collapse  to .

The results by Benedikt and Libkin \cite{libkin_relIntrStruc}, and Roy and Straubing \cite{roy_defGenFO} show that for all formulas  
there exists an active domain formula  in that logic, such that for all words , . 
They assume no restriction on the non-neutral positions of . Observe that our collapse result is different from theirs. We prove that if we consider only words, 
whose non-neutral positions are in , then any formula  is equivalent to the active domain
formula . 
That is, we are not concerned about the satisfiability of those words with non-neutral positions not in .

We show that formulas with a group quantifier,  can be collapsed.
\begin{lemma}
 \label{lem_acd4grpqnt}
Let  be in . Assume formulas\linebreak 
collapse. Then  collapses to an active domain formula .
\end{lemma}

The proof of Lemma \ref{lem_acd4grpqnt} will be given in Section \ref{sec_lemmaProof}. 
Benedikt and Libkin \cite{libkin_relIntrStruc} gives a similar theorem for the monoid  (the existential quantifier).
\begin{lemma}[\cite{libkin_relIntrStruc}]
 \label{lem_acd4u1}
Let  be a formula in . Let us assume that formulas
 collapse. Then  collapses to an active domain formula .
\end{lemma}

Recall the  steps for proving the main theorem given in Introduction. The following theorem proves the first step.

\begin{theorem}
\label{thm_acd4ls}
 Let . Then there exists an active domain formula  such that  collapses to .
\end{theorem}
\begin{proof}
Let . We first claim that we can convert  into a formula which uses only groups and  as quantifiers. 
This follows from the Krohn-Rhodes decomposition theorem for monoids that every monoid can be decomposed into block products over groups and . This decomposition can then be converted back into a formula using the groups and  as quantifiers \cite{str_cirBook}. 

So without loss of generality we can assume  has only group or  quantifiers.
The proof is by induction on the quantifier depth. For the base case, let  be a quantifier free formula. 
It is an active domain formula and therefore the claim holds. Let the claim be true for all formulas with quantifier depth . 
Lemma \ref{lem_acd4grpqnt} and Lemma \ref{lem_acd4u1} show that the claim is true for formulas of type  with 
quantifier depth , when  is a group or  respectively. We are now left with proving that the claim is closed under conjunction and negation. So assume that 
formulas  collapse to  respectively. That is there exist  such that  collapses
 to  and  collapses  to . Let . 
Then it is easy to see that  collapses  to  and  collapses  to .
\qed \end{proof}

We have shown above that all formulas in  can be collapsed to active domain formulas. Now using a Ramsey type argument we obtain that addition is useless, giving us a formula in . This corresponds to the second step in our three step proof strategy.

Let  be any set of relations on  and let  be an active domain formula in . We say that
 has the \emph{Ramsey property} if for all infinite subsets  of , there exists an infinite set  and an active
domain formula  that satisfies the following conditions. 
If  and , then for all ,
 

The Ramsey property for first order logic has been considered by Libkin \cite{libkin_FMT}. These results can be extended
to our logic.

\begin{theorem}
\label{thm_ramsey}
Let  be a set of relations on . Every active domain formula in  satisfies 
the Ramsey property.
\end{theorem}
\begin{proof}
  Let  be a formula. We now prove by induction on the structure of the formula.
  Let  be a term in . We assume without loss of generality that for all .
  Now consider the infinite complete hypergraph, whose vertices are labelled by numbers from  and whose edges are  tuple of vertices.
 Let  be some permutation of numbers from  to . Consider the edge formed by the vertices . 
 We color this edge by the formula  if  is true. Observe that each edge can
 have multiple colors and therefore the total number of different colorings possible is . Ramsey theory gives us that there exists
 an infinite set , such that the induced subgraph on the vertices in  will have a monochromatic color, ie. all the
 edges will be colored using the same color. Let us assume that the edges in  are colored . Then for all
 
 
This shows that  satisfies the Ramsey property and thus all atomic formulas satisfy the Ramsey property.
We now show that Ramsey property is preserved while taking Boolean combination of formulas. Consider the formula . We know that by induction hypothesis there exists a formula  and an infinite set  such that
for all , . We can now find an
infinite set  and a formula  such that the Ramsey property holds for the formula . Therefore for all

 
Similarly we can show that the Ramsey property holds for disjunctions and negations.
We need to now show that active domain quantification also preserves
Ramsey property. So let  be an infinite subset of  and let

be a formula in .
By induction hypothesis we know that there exists an infinite set  and an active domain formula  such that for all  the Ramsey property is satisfied. That is 
. Now for , using the infinite set  we can find an infinite 
set  and a formula  satisfying the Ramsey property. Continuing like this will give us a set  and formulas
 such that  and for all  with , we have
that . Hence we also have 
that 

Therefore for the formula , we
have  where  and   that

Observe that  is an active domain formula in .
\qed \end{proof}

We continue with the third step of our three step proof strategy. 
\begin{lemma}
\label{lem_acdneutr}
 Every active domain sentence in  define a language with a neutral letter.
\end{lemma}
\begin{proof}
Let  be an active domain formula over letter . Let . 
Let  got by inserting letter  in  at some positions. Let  belong to  and 
 be in . Let  be the bijective map . We show that for any subformula 
 of  and any , we have that .
The claim holds for the atomic formula , because  iff  for an . Similarly the claim also
hold for all other atomic formulas  and  for an . The claim remains to hold under
conjunctions, negations and active domain quantifications. Hence .
This proves that  is a neutral letter for .
\qed \end{proof}

Now we can prove our main theorem.


\begin{proof}[Proof of Theorem \ref{thm_cbconj}]
Let , such that  is a language with a neutral letter, . By Theorem \ref{thm_acd4ls} there exists an active domain sentence  over  and a set  such that  collapses 
 to . Theorem \ref{thm_ramsey} now gives an active domain formula  and an infinite set . 
We now show that .
Let . Consider the word  got by inserting the neutral letter  in  in such a way 
that . Since  is a language with a neutral letter we have that . From Theorem \ref{thm_acd4ls} and 
Theorem \ref{thm_ramsey} we get
.
Finally as shown in Lemma \ref{lem_acdneutr},  defines a language with a neutral letter and hence . 
\qed \end{proof}



\bigskip
\section{Proof of Lemma \ref{lem_acd4grpqnt}} \label{sec_lemmaProof}
In this section we replace a group quantifier by an active domain formula. Here we make use of the fact that we can a priory restrict our domain as shown in the previous section.

Recall that  and . 
We know that for all , there exists  and a formula  such that  collapse  to . 
Then clearly  collapse  to  for all .
So without loss of generality we assume s are active domain formulas. 

Before we go in the details we will give a rough overview of the proof idea.
The group quantifier will evaluate a product  where  is a group element that depends on the set of  such that . So we start and analyze the sets . Since the formulas  are active domain formulas, we will see that there exists a set of intervals such that inside an interval the set  is periodic. Boundary points for these intervals are either points in the domain, or linear combinations of these. 
In the construction of the active domain formula for  we will show how to iterate over all these boundary points in a strictly increasing order. An active domain quantifier can only iterate over active domain positions, hence we will need nested active domain quantifiers, and a way how to ``encode'' the boundary points by tuples of active domain positions in a unique and order preserving way. Additionally we need to deal with the periodic positions inside the intervals, without being able to compute the length of such an interval, or even check if the length is zero. Here will make use of the inverse elements that always exist in groups.
 
We start by analyzing the intervals which occur.
We will pick an  to collapse the formula . During the course of the proof we will require 
 to be greater than a few others constants, which will be specified then. But always observe that  will depend only on .


Since we consider a fixed set  for the rest of the paper, we will write  for the logic .

\subsection{Intervals and Linear Functions} \label{linFunc}
We first show that every formula  with at least one free variable has a normal form.
\begin{lemma}
 \label{lem_normalform}
Let . Then there exists a formula  such that  is equivalent to , where all 
atomic formulas in  with  are of the form , where  is a linear function on variables other than .
 \end{lemma}

\begin{proof}
Terms in our logic are expressions of the form  and atomic formulas are of the form

whee  are linear functions,  and . \\
Now using any , where  is not the neutral element, we can rewrite  as

Now consider the atomic formulas containing the free variable  in . 
By multiplying with appropriate numbers, we can re-write these atomic formulas as  
for one particular , which is the least common multiple (lcm) of all the coefficients in . Here  does not contain  and also it might contain subtraction. That is  might stand for . Now we replace  by  and 
conjunct the formula with . 
\qed \end{proof}

For any formula , the notation  denotes the normal form as in Lemma \ref{lem_normalform}.
Let  be the bounded variables occurring in  and   be the free variables other than  in .
Hence the terms  that appear in the formula  can be identified as functions, .

We collect all functions  that occur in the formulas  for an :  

We define the set  of offsets as a set of terms which are functions using the variables  as parameters:

Consider the set of absolute values of all the coefficients appearing in one of the functions in . Let  be the maximum value among these. That is 
. Let .
Now we can define our set of extended functions.
For a  we define a set of terms which are functions using the variables  as parameters:

We denote by .

For a fixed word  and a fixed assignment of the free variables  to  we let 

be the set of {\em boundary points}. Note that the assignments to the functions are of strictly decreasing order. Let  be the boundary points 
in . Then the following sets are called \emph{intervals}: . Here 
.
We also split the set of points in  depending on the offset




In the following Lemma we fix a word  and an .
\begin{lemma}\label{bplemma}

\end{lemma}
\begin{proof}
Let . 
Since  is in , for some , we have . Let . Then there is a function
 in  and values  such that . Let  be the ordered set of all s in the above assignment. We let , where 
. Therefore .
Since  we have  and hence .
\qed \end{proof}

Let  be the lcm of all  where  occurs in one of the . We need the following lemma, that inside an interval with only neutral letters, the congruence relations decide the truth of an active domain formula. 
\begin{lemma}
\label{lem_witInIntrv}
Let  and let  belong to the same interval in  such that . Then for all :
.
\end{lemma}
\begin{proof}
Proof is by induction on the structure of the formula . We will now show that  and all
subformulas  of  that . The atomic formulas of  are of the following form:  and formulas which does not depend on . It is clear that the truth of formulas which
does not depend on ,  and  does not change whether we assign  or  to . Let .
By Lemma \ref{bplemma} we know that  is in  and since  lies in the same interval it follows that . Similarly we can show that the truth of  does not change on 
being assigned  or . Thus we have that the claim holds for atomic formulas.
The claim clearly holds for conjunction and negation of formulas. Now let the claim hold for subformulas . Therefore  we have that
.
Therefore we have that

And hence it is closed under active domain quantification.
\qed \end{proof}

The following Lemma deals with the infinite interval.

\begin{lemma}
 \label{lem_infInterval}
 Let  belong to the infinite interval and . If  then 
 for any .
\end{lemma}
\begin{proof}
Let  and  be in the infinite interval and . From Lemma \ref{lem_witInIntrv} we know that all points
 and such that  is also in the infinite interval will be a witnesses for . This means the set of witnesses is infinite and hence .
\qed \end{proof}

Lemma \ref{lem_witInIntrv} says that inside an interval, the congruence relations decide the satisfiability of the formulas s.
This shows that it is enough to know the truth values of  at a distance of  from the boundary points, since the truth
values inside an interval are going to repeat after every  positions.
The rest of the proof demonstrates 
\begin{enumerate}
 \item How we can treat each  differently. 
\item There is an active domain formula which goes through the points in  in an increasing order
\end{enumerate}
We fix the word  and assignment . Therefore we drop the superscripts in
 () and call them  (). 
\subsection{Treating each  differently}
Let , where  was defined in the previous section and depends on the  predicates.
For an element , we have , so .
Recall the definitions of  from Section \ref{sec_lemmaProof}. 

Recall from the Preliminaries (Section \ref{sec_prelims}) that we denoted by  the group element at position . That is
 iff . Our aim is to give an active domain formula such that the formula evaluates to true iff the group element  is equal to . The rest of this subsection will be devoted to computing this product in a way which helps in building an active domain formula.

Let  be boundary points in . Below we compute  in a different way:

Observe that we can compute the product of the interval using two terms that both need to know only one boundary of the interval.
It becomes simpler if we note that the two products do not really need to multiply all the elements , for  but simply agree on a common set of elements to multiply. 


For a , we define the function  to be the length of the interval to the left of . That is if  form an interval then . Similarly we define  to be the length of the interval to the right of . For all , we define functions  and , which maps points  to a group element. 




Inductively we define



\noindent We first show how  and  are related for .
\begin{lemma} Let .
Let  such that there are no points , where . Then
.
\end{lemma}
\begin{proof}
We prove this by induction over .
Let  and let  form an interval in . If  then 


If the interval is large, i.e. , then let , be the smallest, resp. the largest numbers such that  and .
Lemma \ref{lem_witInIntrv} shows that inside an interval all positions congruent modulo  satisfy the same formulas. Therefore , and hence . So 

The last equality being true since 

As induction hypothesis assume that the lemma is true for all .
Since for all  the terms  appear in both  and  
they cancel out (whatever they compute to). Thus 


Let  be all positions in  between  and . By the requirements of the lemma the only positions of 
between  and  are in . Writing out the product we get 

By I.H.  . Hence

\qed \end{proof}

The following Lemma shows that  gives the product of the group elements.
\begin{lemma}\label{lem_whattocomp}
We have that .
\end{lemma}
\begin{proof}
Using appropriate induction hypothesis we get that , where . The lemma now follows from Lemma \ref{lem_infInterval} which gives that  for every  in the infinite interval.
\qed \end{proof}

We now give active domain formulas , , such that  is true iff . For this we make use of the
inductive definition of  and show that there exists active domain formulas  such that .
Similarly we give active domain formulas  such that .
Observe that  is got by computing the product of 
, over , where  strictly increases. This requires us to traverse the elements in  in an increasing order. The following section builds a Sorting tree to sort the elements of  in an increasing order.



 
\subsection{Sorting Tree} \label{subsec_sortingtree}
Let . The aim of this section is to create a data structure, which can traverse the elements in  in an ascending order. 



For a , we define a tree called \emph{sorting tree},  which corresponds to . The tree satisfies the
following property.
If the leaves of the tree are enumerated from left to right, then we get the set  in ascending order.
A node in  is labeled by a tuple , where  is a function in ,  an assignment for the variables in  
such that  and . 

We show how to inductively built the tree. The root is labeled by the tuple , where  is the function which depends only on  (and hence constant on )
 and  is the empty assignment. The root is not marked a leaf node.


Consider the internal node . It will have three kinds of children ordered from left to right as follows.
\begin{enumerate}
 \item Left children: These are labeled by tuples of the form  
where\linebreak  and , , , where  and .

 The tuples  is on the left of  if  or if  and . 
 \item Middle child: It is labeled by the tuple  where . It is marked a {\bf leaf} node.
  \item Right children: These are labeled by tuples of the form  
where  and , , , where  and .

The tuple  is on the left of  if  or  and . 
\end{enumerate}

Observe that if there is no  such that  and , then  will only have the child .


Note that in our tree construction the values of the children of a node increase from left to right. The tree is built until
all functions with  variables appear in leaves and hence the depth of the tree is .
Figure \ref{fig_sortingTree} shows part of a tree, where , ,  and .

\begin{figure*}
\centering
\vspace*{-4mm}
\includegraphics[width=0.9\textwidth]{linFunc} 
\vspace*{-4mm}
\caption{Sorting Tree: The double circles represent leaves of the tree. The nodes of the tree are labelled , 
where  is an assignment for the function  and . For better presentation we only show the assignment to the newly introduced variable in a node. 
For example, the tuple  assigns  and . The assignment to  is given in the node's parent.}
\label{fig_sortingTree}
\vspace*{-5mm}
\end{figure*} 

The following lemma holds if . We also assume that .
Given a node , we say the value of the node is the function  evaluated under the assignment of  (denoted by ).
\begin{lemma}
\label{lem_child}
Let  be an internal node labeled by a function  with  and an assignment .
If  for some , then the children of this node have values in the range .
Moreover the values of the children increases from left to right.
\end{lemma}
\begin{proof}
By construction.
\qed \end{proof}

Next we show that for any two neighboring nodes in the tree, the values in the leaves of the subtree rooted at the left node is less 
than the values in the leaves of the subtree rooted at the right node. Let  denote the set of values in the leaves of the subtree rooted at .

\begin{lemma}
 \label{lem_neighNoIntersect}
Let  and  be neighboring nodes of the same parent such that  is to the left of . Then  for every  and .
\end{lemma}
\begin{proof}
Let  and . We show that the rightmost element,  in  is less 
than the left most element,  in . From Lemma \ref{lem_child} and applying induction on the depth of the tree, one can show that  and 
. Here  are the minimum assignments in  and  respectively.
Let us assume that both coefficients . A similar analysis can be given for other combinations of  and
. 
Now since  is the left neighbor of  we have .  Then 
. The claim follows, since .
\qed \end{proof}
The next lemma says that the values of the leaves of the tree increases as we traverse from left to right.

\begin{lemma} \label{lem_tree}
Let  and  be two distinct nodes such that . Then  appear to the left of .
\end{lemma}
\begin{proof}
This follows from Lemma \ref{lem_neighNoIntersect}.
\qed \end{proof}



\begin{lemma}[Tree Lemma]\label{lem_treelemma}
Fix . Assume that for every  we have an element .
For all ,  let  be active domain formulas  such that 
Then there are active domain formulas  such that 
\end{lemma}
\begin{proof}
We will use the sorting tree,  corresponding to  for the construction of our formula. 
Recall that the nodes are labeled by tuples , where  is a function and  is the assignment of the parameters of . Let  be the set of values at the leaves of the subtree rooted at the node labeled by , and .
We will do induction on the depth  of the tree.
Let  be a formula such that 
~~ where  is the label of a node that has a subtree of depth at most .
Hence we multiply all group elements  for which  is in .

{\bf Base Case (leaves):} 
We define .

{\bf Induction Step:} Let us assume that the claim is true for all nodes with a subtree of depth at most .
Let the node labeled by  have a subtree of depth . We will need to specify the formula , where  agrees with the assignment .
For every child  of  the depth of the corresponding subtree is less than or equal to . Hence we know we have already formulas by induction.

Recall what the children of  are: They are of form  and . Moreover all nodes
, where  is
negative, come to the left of  and all nodes , where  is positive, come to its right.

We start by grouping some of the children and computing their product.
We let  be the product of all subtrees labeled by  for .
This is a finite product so we can compute this by a Boolean combination of the formulas .

Now we want to compute the product  which is the product of the  where  is decreasing.
But this can be computed using an active domain group quantifier,  as follows:

 
Recall that the elements of group  are ordered .
For the single node  we already have the formulas  by induction (here we have  since the assignment  is the same for  and ).

Similarly we define formulas  for the positive coefficients, and compute their product  in an increasing order.



We have now computed the product of the group elements for the three different groups of children. So by a Boolean combination over
these formulas we get :

So finally we get  which is same as the formula , which is valid at the root of the tree.
\qed \end{proof}

Since the above lemma holds only for , our  should be greater than .
 
\subsection{Constructing the active domain formula} 
We know that for every  there is a function , , such that , where  is the fixed assignment to the variables .
We will use this encoding of a position and define a formula  such that 

Similarly we define formulas  such that  iff .

We show this by induction over . Starting with the base case .

\begin{lemma}\label{lem_formbase}
Let .  For each , there is an active domain formula  in , 
such that if  then . \\
Similarly there is an active domain formula  in  such that if  
 then .
\end{lemma}
\begin{proof}
  For an , we denote by  the formula .
For a , the following formula checks if there is a point  in  such that . Since in each  there is at most
one such element, we can use the group quantifier to simulate the existential quantifier.

So we have that  iff  is true. We define  to be true if the product of the first  group elements is . 

Now we have two cases to consider. \\
{\bf Case :} 
For each of the case  such that , the formula  compute the product of the group elements. 
Hence  in this case can be given as:

{\bf Case :} 
When  we have to compute the product for the first  group elements, where  and . Therefore
 in this case is 

A Boolean combination over  can differentiate the two cases.
Similarly we can give active domain formulas .
\qed \end{proof}

The induction step follows.
\begin{lemma}\label{lem_formstep}
  Let . For each , there is an active domain formula  in ,
such that  then . \\
Similarly there is an active domain formula  in ,
such that  then
.
\end{lemma}
\begin{proof}
  For all  and  we give formulas  such that for all  the
  following holds. Let  and . Then 
    and  
  or    and .
  By induction hypothesis there exists formulas  and  which corresponds to 
  and  respectively. Taking a Boolean combination over these formulas we get the required formula .
  We now apply our Tree Lemma \ref{lem_treelemma} which gives us formulas , 
  for all , such that 
   
  Taking Boolean combination over  and  will give us the formula .
Similarly we can build active domain formulas , for all .
\qed \end{proof}

\begin{proof}[Proof of Lemma \ref{lem_acd4grpqnt}] 
By Lemma \ref{lem_whattocomp} we know that it suffices to compute  and by Lemma \ref{lem_formstep} we know that there are
active domain formulas  such that  iff 

We need to do one last thing. Check that the infinite interval evaluates to . Replace all formulas , ,  for
a  and  by , , ,  respectively in the formulas  and call these formulas . 
There exists a witness in the infinite interval for the formula  iff  evaluates to true. 
By Theorem \ref{lem_infInterval} there should not be any witness in the infinite interval. Hence there exists a  which
evaluates to true iff the infinite interval does not evaluate to .
\qed \end{proof}

\bigskip


\bigskip
\section{Discussion}
We have shown that in the presence of a neutral letter the addition relation collapse to linear ordering no matter what monoid
quantifier is been used. All languages definable using monoid quantifiers and an order predicate, on the other hand, are regular \cite{barr_uniformNC1}. 
Now using semigroup theoretic methods we can separate these classes \cite{str_cirBook}. This enabled us to show separation between
various logics which uses addition and order predicates. 


Unfortunately if both addition and multiplication are present, then the collapse does not happen. It is also interesting to note that non-solvable
groups do not show any surprising property if only addition is present, but as we know from Barrington's theorem non-solvable groups
behave quite differently when both addition and multiplication are present.

The ultimate objective is to show non-expressibility results for arbitrary predicates or at least when both addition and multiplication
are present. As a first step one can look at extending these results for other kinds of predicates. 

Another way to look at separating the ``natural uniform'' versions of the complexity classes will be to ask whether one can come up
with other suitable restrictions on the set of languages. Inside this restricted set of languages can one show addition and
multiplication collapse to order relation? This seems to be the idea Straubing considers in \cite{str_inexpRegLan}. Straubing
\cite{str_cirBook} proposes word problems over Regular language as a suitable restriction, while McKenzie, Thomas, Vollmer \cite{mckenzie_extUniformity} consider context free languages as a restriction.

Another interesting question which our result fails to answer is whether word problems over non-solvable groups can be defined in
 \cite{krebs_infGroups}?
\section*{Acknowledgement}
\noindent We like to thank Baskar Anguraj, Christoph Behle, Micha\"el Cadilhac, Klaus-J\"orn Lange, Nutan Limaye, T. Mubeena, and Ramanujam for a lot of useful comments on the draft of this paper.

\begin{thebibliography}{10}

\bibitem{barr_NC1}
David~A. Barrington.
\newblock Bounded-width polynomial-size branching programs recognize exactly
  those languages in {}.
\newblock {\em Journal of Computer and System Sciences}, 38(1):150--164,
  February 1989.

\bibitem{barr_cbconj}
David A.~Mix Barrington, Neil Immerman, Clemens Lautemann, Nicole Schweikardt,
  and Denis Th{\'e}rien.
\newblock First-order expressibility of languages with neutral letters or: The
  {C}rane {B}each conjecture.
\newblock {\em J. Comput. Syst. Sci.}, 70(2):101--127, 2005.

\bibitem{barr_uniformNC1}
David A.~Mix Barrington, Neil Immerman, and Howard Straubing.
\newblock On uniformity within {}.
\newblock {\em Journal of Computer and System Sciences}, 41(3):274--306,
  December 1990.

\bibitem{barr_superLinLBBWBP}
David A.~Mix Barrington and Howard Straubing.
\newblock Superlinear lower bounds for bounded-width branching programs.
\newblock In {\em Structure in Complexity Theory Conference}, pages 305--313,
  1991.

\bibitem{behle_nonSolvGrpsNotinMaj}
Christoph Behle, Andreas Krebs, and Stephanie Reifferscheid.
\newblock Non-solvable groups are not in {FO+MOD+M{\^A}J2[REG]}.
\newblock In {\em LATA}, pages 129--140, 2009.

\bibitem{behle_regLangMajQnt}
Christoph Behle, Andreas Krebs, and Stephanie Reifferscheid.
\newblock Regular languages definable by majority quantifiers with two
  variables.
\newblock In {\em Developments in Language Theory}, pages 91--102, 2009.

\bibitem{behle_foLessUniform}
Christoph Behle and Klaus-J{\"o}rn Lange.
\newblock {FO}[]-uniformity.
\newblock In {\em IEEE Conference on Computational Complexity}, pages 183--189,
  2006.

\bibitem{libkin_relIntrStruc}
Michael Benedikt and Leonid Libkin.
\newblock Relational queries over interpreted structures.
\newblock {\em J. ACM}, 47(4):644--680, 2000.

\bibitem{bddMultiPartyCommCompl}
Arkadev Chattopadhyay, Andreas Krebs, Michal Kouck{\'y}, Mario Szegedy, Pascal
  Tesson, and Denis Th{\'e}rien.
\newblock Languages with bounded multiparty communication complexity.
\newblock In {\em STACS}, pages 500--511, 2007.

\bibitem{furst_parity}
Merrick~L. Furst, James~B. Saxe, and Michael Sipser.
\newblock Parity, circuits, and the polynomial-time hierarchy.
\newblock {\em Mathematical Systems Theory}, 17(1):13--27, 1984.

\bibitem{immerman_book}
Neil Immerman.
\newblock {\em Descriptive complexity}.
\newblock Graduate texts in computer science. Springer, 1999.

\bibitem{koucky_wiresVsGates}
Michal Kouck{\'y}, Pavel Pudl{\'a}k, and Denis Th{\'e}rien.
\newblock Bounded-depth circuits: separating wires from gates.
\newblock In {\em STOC}, pages 257--265, 2005.

\bibitem{krebs_infGroups}
Andreas Krebs, Klaus-J{\"o}rn Lange, and Stephanie Reifferscheid.
\newblock Characterizing {TC} in terms of infinite groups.
\newblock {\em Theory Comput. Syst.}, 40(4):303--325, 2007.

\bibitem{lange_majQnt}
Klaus-J{\"o}rn Lange.
\newblock Some results on majority quantifiers over words.
\newblock In {\em IEEE Conference on Computational Complexity}, pages 123--129.
  IEEE Computer Society, 2004.

\bibitem{lautemann_logcfl}
Clemens Lautemann, Pierre McKenzie, Thomas Schwentick, and Heribert Vollmer.
\newblock The descriptive complexity approach to {LOGCFL}.
\newblock {\em J. Comput. Syst. Sci}, 62(4):629--652, 2001.

\bibitem{ltt06}
Clemens Lautemann, Pascal Tesson, and Denis Th{\'e}rien.
\newblock An algebraic point of view on the crane beach property.
\newblock In {\em CSL}, pages 426--440, 2006.

\bibitem{libkin_FMT}
Leonid Libkin.
\newblock {\em Elements of Finite Model Theory}.
\newblock Springer-Verlag, Berlin, 2004.

\bibitem{lin_genQuant}
P.~Lindstr{\"o}m.
\newblock First order predicate logic with generalized quantifiers.
\newblock {\em Theoria}, 32:186--195, 1966.

\bibitem{lynch82}
James~F. Lynch.
\newblock On sets of relations definable by addition.
\newblock {\em J. Symb. Log.}, 47(3):659--668, 1982.

\bibitem{mckenzie_extUniformity}
Pierre McKenzie, Michael Thomas, and Heribert Vollmer.
\newblock Extensional uniformity for boolean circuits.
\newblock {\em SIAM Journal on Computing}, 39(7):3186--3206, 2010.

\bibitem{nur_countQuant}
Juha Nurmonen.
\newblock Counting modulo quantifiers on finite structures.
\newblock {\em Inf. Comput.}, 160(1-2):62--87, 2000.

\bibitem{roy_defGenFO}
Amitabha Roy and Howard Straubing.
\newblock Definability of languages by generalized first-order formulas over
  {}.
\newblock {\em SIAM J. Comput}, 37(2):502--521, 2007.

\bibitem{ruhl_FOUnc}
M.~Ruhl.
\newblock Counting and addition cannot express deterministic transitive
  closure.
\newblock In {\em 14th Symposium on Logic in Computer Science ({LICS}'99)},
  pages 326--335, Washington - Brussels - Tokyo, July 1999. IEEE.

\bibitem{schwei_FOUnc}
Nicole Schweikardt.
\newblock Arithmetic, first-order logic, and counting quantifiers.
\newblock {\em ACM Trans. Comput. Log}, 6(3):634--671, 2005.

\bibitem{niw_yEq2x}
Alexei~P. Stolboushkin and Damian Niwinski.
\newblock y = 2x vs. y = 3x.
\newblock {\em J. Symb. Log.}, 62(2):661--672, 1997.

\bibitem{str_cirBook}
Howard Straubing.
\newblock {\em Finite automata, formal logic, and circuit complexity}.
\newblock Birkhauser Verlag, Basel, Switzerland, 1994.

\bibitem{str_inexpRegLan}
Howard Straubing.
\newblock Inexpressibility results for regular languages in nonregular
  settings.
\newblock In {\em Developments in Language Theory}, pages 69--77, 2005.

\bibitem{str_regGenQnt}
Howard Straubing, Denis Th{\'e}rien, and Wolfgang Thomas.
\newblock Regular languages defined with generalized quanifiers.
\newblock {\em Inf. Comput}, 118(2):289--301, May 1995.

\bibitem{vollmer_book}
Heribert Vollmer.
\newblock {\em Introduction to circuit complexity}.
\newblock Springer-Verlag, Berlin-Heidelberg-New York-Barcelona-Hong
  Kong-London-Milan-Paris-Singapur-Tokyo, 1999.

\end{thebibliography}

\end{document}
