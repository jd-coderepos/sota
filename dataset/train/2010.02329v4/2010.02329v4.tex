\PassOptionsToPackage{dvipsnames}{xcolor}
\documentclass{article} \usepackage{iclr2021_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 \usepackage{bbm}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{booktabs}
\usepackage{color}
\usepackage{hyperref}
\usepackage{xspace}
\usepackage{url}
\usepackage{times}
\usepackage{amsthm}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{url}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{makecell}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{enumitem}
\newtheorem{theorem}{Theorem}[section]
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}
\usepackage[dvipsnames]{xcolor}

\title{InfoBERT: Improving Robustness of Language Models from An Information Theoretic \\ Perspective}





\author{\thanks{Work was done during Boxin Wang's Summer internship in Microsoft Dynamics 365 AI Research.}$\;\,$Boxin Wang$^1$, Shuohang Wang$^2$, Yu Cheng$^2$, Zhe Gan$^2$, Ruoxi Jia$^3$, Bo Li$^1$, Jingjing Liu$^2$ \\
\small $^1$University of Illinois at Urbana-Champaign \; $^2$ Microsoft Dynamics 365 AI Research \; $^3$ Virginia Tech \\
\scriptsize \texttt{\{boxinw2,lbo\}@illinois.edu \, \{shuohang.wang,yu.cheng,zhe.gan,jingjl\}@microsoft.com}}




\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}
\newcommand{\method}{InfoBERT\xspace}

\newcommand{\jj}[1]{{\color{blue}{\small{\bf [JJ: #1]}}}}
\newcommand{\JJ}[1]{{\color{blue}{\small{\bf [JJ: #1]}}}}
\newcommand{\boxin}[1]{{\textcolor{Maroon}{\small{\bf [Boxin: #1]}}}}
\newcommand{\yu}[1]{{\textcolor{orange}{\small{\bf [Yu: #1]}}}}
\newcommand{\zhe}[1]{{\color{blue}{\small{\bf [Zhe: #1]}}}}

\newcommand{\modified}[1]{{\color{black}{#1}}}
\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
Large-scale pre-trained language models such as BERT and RoBERTa have achieved state-of-the-art performance across a wide range of NLP tasks. Recent studies, however, show that such BERT-based models are vulnerable facing the threats of textual adversarial attacks. We aim to address this problem from an information-theoretic perspective, and propose InfoBERT, a novel learning framework for robust fine-tuning of pre-trained language models. InfoBERT contains two mutual-information-based regularizers for model training: ($i$) an Information Bottleneck regularizer, which suppresses noisy mutual information between the input and the feature representation; and ($ii$) an Anchored Feature regularizer, which increases the mutual information between local stable features and global features.
We provide a principled way to theoretically analyze and improve the robustness of language models in both standard and adversarial training. Extensive experiments demonstrate that InfoBERT 
achieves state-of-the-art robust accuracy over several adversarial datasets on Natural Language Inference (NLI) and Question Answering (QA) tasks. 
Our code is available at \url{https://github.com/AI-secure/InfoBERT}.
    
\end{abstract} 
\section{Introduction}


Self-supervised representation learning pre-trains good feature extractors from massive unlabeled data, which show promising transferability to various downstream tasks.
Recent success includes large-scale pre-trained language models (\emph{e.g.,} BERT, RoBERTa, and GPT-3 \citep{bert,roberta,gpt3}), which have advanced state of the art over a wide range of NLP tasks such as NLI and QA, even surpassing human performance. Specifically, in the computer vision domain, many studies have shown that self-supervised representation learning is essentially solving the problem of maximizing the mutual information (MI) $I(X;T)$ between the input $X$ and the representation $T$ \citep{infonce, pmlr-v80-belghazi18a,hjelm2018learning,simclr}. Since MI is computationally intractable in high-dimensional feature space, many MI estimators~\citep{pmlr-v80-belghazi18a} have been proposed to serve as lower bounds \citep{Barber2003TheIA,infonce} or upper bounds \citep{Cheng2020CLUBAC} of MI.  Recently, \citeauthor{Kong2020A} 
point out that the MI maximization principle of representation learning can be applied to not only computer vision but also NLP domain, and propose a unified view that recent pre-trained language models are maximizing a lower bound of MI among different segments of a word sequence. 

On the other hand, deep neural networks are known to be prone to adversarial examples \citep{Goodfellow2015ExplainingAH,Papernot2016DistillationAA,Eykholt2017RobustPA,MoosaviDezfooli2016DeepFoolAS}, \emph{i.e.,} the outputs of neural networks can be arbitrarily wrong when human-imperceptible adversarial perturbations are added to the inputs. Textual adversarial attacks typically perform word-level substitution \citep{hotflip, DBLP:conf/emnlp/AlzantotSEHSC18,weight_attack} or sentence-level paraphrasing \citep{scpn,DBLP:conf/naacl/ZhangBH19} to achieve semantic/utility preservation that seems innocuous to human, while fools NLP models. Recent studies \citep{textfooler, comattack, anli, t3} further show that even large-scale pre-trained language models (LM) such as BERT are vulnerable to adversarial attacks, which raises the challenge of building robust real-world LM applications against unknown adversarial attacks.

We investigate the robustness of language models from an information theoretic perspective, and propose a novel learning framework \method, which focuses on improving the robustness of language representations by fine-tuning both local features (word-level representation) and global features (sentence-level representation) for robustness purpose. \method considers two MI-based regularizers: $(i)$ the \emph{Information Bottleneck} regularizer manages to extract approximate minimal sufficient statistics for downstream tasks, while removing excessive and noisy information that may incur adversarial attacks; $(ii)$ the \emph{Anchored Feature} regularizer carefully selects useful local stable features that are invulnerable to adversarial attacks, and maximizes the mutual information between local stable features and global features to improve the robustness of the global representation. In this paper, we provide a detailed theoretical analysis to explicate the effect of \method for robustness improvement, along with extensive empirical adversarial evaluation to validate the theory.

Our contributions are summarized as follows. ($i$) We propose a novel learning framework \method from the information theory perspective, aiming to effectively improve the robustness of language models. ($ii$) We provide a principled theoretical analysis on model robustness, and propose two MI-based regularizers to refine the local and global features, which can be applied to both standard and adversarial training for different NLP tasks. ($iii$) Comprehensive experimental results demonstrate that \method can substantially improve robust accuracy by a large margin without sacrificing the benign accuracy, yielding the state-of-the-art performance across multiple adversarial datasets on NLI and QA tasks.  \vspace{-1mm} 
\section{Related Work}
\vspace{-1mm}


\textbf{Textual Adversarial Attacks/Defenses} Most existing textual adversarial attacks focus on word-level adversarial manipulation. \citet{hotflip} is the first to propose a whitebox gradient-based attack to search for adversarial word/character substitution. Following work \citep{DBLP:conf/emnlp/AlzantotSEHSC18, weight_attack, comattack, textfooler} further constrains the perturbation search space and adopts Part-of-Speech checking to make NLP adversarial examples look natural to human. 

To defend against textual adversarial attacks, existing work can be classified into three categories:
($i$) \textit{Adversarial Training} is a practical method to defend against adversarial examples. Existing work either uses PGD-based attacks to generate adversarial examples in the embedding space of NLP as data augmentation \citep{freelb}, or regularizes the standard objective using virtual adversarial training \citep{smart,alum,gan2020large}. However, one drawback is that the threat model is often unknown, which renders adversarial training less effective when facing unseen attacks.
($ii$) \textit{Interval Bound Propagation} (IBP) \citep{ibp} is proposed as a new technique to consider the worst-case perturbation theoretically. Recent work \citep{ibp1,ibp2} has applied IBP in the NLP domain to certify the robustness of models. However, IBP-based methods rely on strong assumptions of model architecture and are difficult to adapt to recent transformer-based language models. 
($iii$) \textit{Randomized Smoothing} \citep{DBLP:conf/icml/CohenRK19} provides a tight robustness guarantee in $\ell_2$ norm by smoothing the classifier with Gaussian noise. \citet{safer} adapts the idea to the NLP domain, and replace the Gaussian noise with synonym words to certify the robustness as long as adversarial word substitution falls into predefined synonym sets. However, to guarantee the completeness of the synonym set is challenging.

\textbf{Representation Learning} MI maximization principle has been adopted by many studies on self-supervised representation learning \citep{infonce,pmlr-v80-belghazi18a,hjelm2018learning,simclr}. Specifically, InfoNCE \citep{infonce} is used as the lower bound of MI, forming the problem as contrastive learning \citep{DBLP:conf/icml/SaunshiPAKK19, yu2020finetuning}. However, \citet{infomin} suggests that the InfoMax \citep{DBLP:journals/computer/Linsker88} principle may introduce excessive and noisy information, which could be adversarial. 
To generate robust representation, \citet{worstcase} formalizes the problem from a mutual-information perspective, which essentially performs adversarial training for worst-case perturbation, while mainly considers the continuous space in computer vision. In contrast, \method originates from an information-theoretic perspective and is compatible with both standard and adversarial training for discrete input space of language models.






%
 \vspace{-1mm}
\section{\method}
\vspace{-1mm}





Before diving into details, we  first discuss the textual adversarial examples we consider in this paper. We mainly focus on the dominant word-level  attack as the main threat model, since it achieves higher attack success and is less noticeable to human readers than other attacks. 
Due to the discrete nature of text input space, it is difficult to measure adversarial distortion on token level.
Instead, because most word-level adversarial attacks \citep{textbugger,textfooler} constrain word perturbations via the bounded magnitude in the semantic embedding space, \modified{by adapting from \citet{jacobsen2018excessive}}, we define the adversarial text examples with distortions constrained in the embedding space.




\begin{definition}\label{def:adv}($\epsilon$-bounded Textual Adversarial Examples). Given a sentence $x=[x_1;x_2;...;x_n]$, where $x_i$ is the word at the $i$-th position, the $\epsilon$-bounded adversarial sentence $x'=[x_1';x_2';...;x_n']$ for a classifier $\mathcal{F}$ satisfies: $(1)$ $\mathcal{F}(x) = o(x) = o(x')$ but $\mathcal{F}(x') \ne o(x')$, where $o(\cdot)$ is the oracle (\emph{e.g.}, human decision-maker); $(2)$ $||t_i - t_i'||_2 \le \epsilon$ for $i=1, 2, ..., n$, where $\epsilon \ge 0$ and $t_i$ is the word embedding of $x_i$. 
\end{definition}



\subsection{Information Bottleneck as a Regularizer}
In this section, we first discuss the general IB implementation, and then explain how IB formulation is adapted to \method as a regularizer  along with  theoretical analysis to support why IB regularizer can help improve the robustness of language models.
The IB principle formulates the goal of deep learning as an information-theoretic trade-off between representation compression and predictive power \citep{deepib}. Given the input source $X$, a deep neural net learns the internal representation $T$ of some intermediate layer and maximizes the MI between $T$ and label $Y$, so that $T$ subject to a constraint on its complexity contains sufficient information to infer the target label $Y$. Finding an optimal representation $T$ can be formulated as the maximization of
the Lagrangian
\begin{align} 
    \label{eq:ib}
    \mathcal{L}_{\text{IB}} = I(Y; T) - \beta I(X; T),
\end{align}
where $\beta > 0$ is a hyper-parameter to control the tradeoff, and  $I(Y;T)$ is defined as: 
\begin{align}
    \label{eq:mi}
    I(Y; T) = \int p(y, t) \log \frac{p(y,t)}{p(y)p(t)} \, \modified{dy \, dt \,}.
\end{align}
Since Eq.~(\ref{eq:mi}) is intractable, we instead use the lower bound from \citet{Barber2003TheIA}: 
\begin{align}
    \label{eq:lower}
    I(Y; T) \ge \int p(y, t) \log q_\psi(y \mid t) \, \modified{dy \, dt \,},
\end{align}
where  $q_\psi(y|t)$ is the variational approximation learned by a neural network parameterized by $\psi$ for the true distribution $p(y|t)$. This indicates that maximizing the lower bound of the first term of IB $I(Y; T)$ is equivalent to minimizing the task cross-entropy loss $\ell_{\text{task}} = H(Y \mid T)$. 

To derive a tractable lower bound of IB, we here use an upper bound \citep{Cheng2020CLUBAC} of $I(X;T)$ 
\begin{align}
\label{eq:upper}
    I(X; T) \le  \int  p(x, t) \log (p(t \mid x)) \,  \modified{dx \, dt \,} -  \int  p(x) p(t) \log (p(t \mid x)) \, \modified{dx \, dt \,}.
\end{align}
By combining Eq.~(\ref{eq:lower}) and (\ref{eq:upper}), we can maximize the tractable lower bound ${\mathcal{\hat{L}}}_{\text{IB}}$ of IB in practice by:
\begin{align}
\label{eq:all}
    \hat{\mathcal{L}}_{\text{IB}} = \frac{1}{N}\sum_{i=1}^{N} \big[ \log q_\psi({y}^{(i)} \mid {t}^{(i)}) \big] -  \frac{\beta}{N} \sum_{i=1}^{N} \Big[\log (p({t}^{(i)} \mid {x}^{(i)})) -  \frac{1}{N} \sum_{j=1}^{N} \log (p({t}^{(j)} \mid {x}^{(i)}))  \Big]
\end{align}
with data samples $\{{x}^{(i)}, {y}^{(i)}\}_{i=1}^{N}$, where   $q_\psi$ can represent any classification model (\emph{e.g.}, BERT), and   $p(t \mid x)$ can be viewed as the feature extractor $f_\theta: \mathcal{X} \rightarrow \mathcal{T}$, where $\mathcal{X}$ and $\mathcal{T}$ are the support of the input source $X$ and extracted feature $T$, respectively.

The above is a general implementation of IB objective function. In \method, we consider $T$ as the features consisting of the local word-level features after the BERT embedding layer $f_\theta$. The following BERT self-attentive layers along with the linear classification head serve as  $q_\psi(y|t)$ that predicts the target $Y$ given representation $T$. 

Formally, given random variables  $X=[X_1; X_2; ...; X_n]$ representing input sentences with $X_i$ (word token at $i$-th index), let $T=[T_1; ...; T_n]=f_\theta([X_1; X_2; ...; X_n]) = [f_\theta(X_1); f_\theta(X_2); ...; f_\theta(X_n)]$ denote the random variables representing the features generated from input $X$ via the BERT embedding layer $f_\theta$, where $T_i \in \R^{d}$ is the high-dimensional word-level local feature for word $X_i$. Due to the high dimensionality $d$ of each word feature (\emph{e.g.}, $1024$ for BERT-large), when the sentence length $n$ increases, the dimensionality of features $T$ becomes too large to compute $I(X;T)$ in practice. Thus, we propose to maximize a localized formulation of IB $\mathcal{L}_{\text{LIB}}$ defined as:
\begin{align} 
\label{eq:local_ib}
  \mathcal{L}_{\text{LIB}} := I(Y; T) - n\beta \sum_{i=1}^{n} I(X_i; T_i).
\end{align}
\begin{theorem} (Lower Bound of $\mathcal{L}_{\text{IB}}$) Given a sequence of random variables $X=[X_1; X_2; ...; X_n]$ and a deterministic feature extractor $f_\theta$, let $T=[T_1; ...; T_n] = [f_\theta(X_1); f_\theta(X_2); ...; f_\theta(X_n)]$. Then the localized formulation of IB $\mathcal{L}_{\text{LIB}}$ is a lower bound of $\mathcal{L}_{\text{IB}}$ (Eq.~(\ref{eq:ib})), i.e.,
\label{thm:local}
\begin{align}
     I(Y; T) - \beta I(X; T) \ge I(Y; T) - n\beta \sum_{i=1}^{n} I(X_i; T_i).
\end{align}
\end{theorem} Theorem \ref{thm:local} indicates that we can maximize \modified{the localized formulation of} $\mathcal{L}_{\text{LIB}}$ as a lower bound of IB $\mathcal{L}_{\text{IB}}$ when $I(X;T)$ is difficult to compute. In Eq.~(\ref{eq:local_ib}), if we regard the first term ($I(Y;T)$) as a task-related objective, the second term ($-n\beta \sum_{i=1}^{n} I(X_i; T_i)$) can be considered as a regularization term to constrain the complexity of representation $T$, thus named as \textit{Information Bottleneck regularizer}.  Next, we give a theoretical analysis for the adversarial robustness of IB and demonstrate why localized IB objective function can help improve the robustness to adversarial attacks. 

Following Definition \ref{def:adv}, let $T=[T_1;T_2;...;T_n]$ and $T'=[T_1';T_2';...;T_n']$ denote the features for the benign sentence $X$ and adversarial sentence $X'$. The distributions of $X$ and $X'$ are denoted by probability $p(x)$ and $q(x)$ with the support $\mathcal{X}$ and $\mathcal{X'}$, respectively. 
We assume that the feature representation $T$ has finite support denoted by $\mathcal{T}$ considering the finite vocabulary size in NLP.



\begin{theorem}\label{thm:bound} (Adversarial Robustness Bound) For random variables $X=[X_1; X_2; ...; X_n]$ and $X'=[X'_1; X'_2; ...; X'_n]$, let $T=[T_1;T_2;...;T_n]=[f_\theta(X_1); f_\theta(X_2); ...; f_\theta(X_n)]$ and $T'=[T'_1;T'_2;...;T'_n]=[f_\theta(X'_1); f_\theta(X'_2); ...; f_\theta(X'_n)]$ with finite support $\mathcal{T}$, where $f_\theta$ is a deterministic feature extractor. The performance gap between benign and adversarial data $|I(Y;T) - I(Y;T')|$ is bounded above by \begin{align}
    |I(Y;T) - I(Y; T') |  & \le B_0  
    + B_1 \sum_{i=1}^n \sqrt{|\mathcal{T}|}(I(X_i; T_i))^{1/2} + B_2 \sum_{i=1}^n |\mathcal{T}|^{3/4}(I(X_i;T_i))^{1/4} \nonumber \\ 
     &+  B_3 \sum_{i=1}^n \sqrt{|\mathcal{T}|}(I(X'_i; T'_i))^{1/2} + B_4 \sum_{i=1}^n |\mathcal{T}|^{3/4}(I(X'_i; T'_i))^{1/4},  
\end{align}
where $B_0, B_1, B_2, B_3$ and $B_4$ are  constants depending on the sequence length $n$, $\epsilon$ and $p(x)$. 
\end{theorem}

\modified{The sketch of the proof is to express the difference of $|I(Y;T) - I(Y';T)|$ in terms of $I(X_i;T_i)$. Specifically,  Eq.~(\ref{eq:init}) factorizes the difference into two summands. The first summand, the conditional entropy $|H(T \mid Y) - H(T' \mid Y)|$, can be bound by Eq. (\ref{eq:init1}) in terms of MI between benign/adversarial input and representation $I(X_i; T_i)$ and $I(X'_i; T'_i)$. The second summand $|H(T) - H(T')|$ has a constant upper bound (Eq.~(\ref{eq:final_bound3})), since language models have bounded vocabulary size and embedding space, and thus have bounded entropy.}

\modified{The intuition of Theorem \ref{thm:bound} is to bound the adversarial performance drop $|I(Y;T) - I(Y; T')|$ by $I(X_i;T_i)$.} As explained in Eq.~(\ref{eq:lower}), $I(Y;T)$ and $I(Y;T')$ can be regarded as the model performance on benign and adversarial data. Thus, the LHS of the bound represents such a performance gap. The adversarial robustness bound of Theorem \ref{thm:bound} indicates that the performance gap becomes closer when $I(X_i;T_i)$ and $I(X_i';T_i')$ decrease. Note that our IB regularizer in the objective function Eq.~(\ref{eq:local_ib}) achieves the same goal of minimizing $I(X_i;T_i)$ while learning the most efficient information features, or approximate minimal sufficient statistics, for downstream tasks. Theorem \ref{thm:bound} also suggests that combining adversarial training with our IB regularizer can further minimize $I(X_i';T_i')$,  leading to better robustness, which is verified in \S\ref{sec:exp}.

\subsection{Anchored Feature Regularizer}
In addition to the IB regularizer that suppresses noisy information that may incur adversarial attacks, we propose a novel regularizer termed  ``Anchored Feature Regularizer'', which extracts local stable features and aligns them with sentence global representations, thus improving the stability and robustness of language representations.  

The goal of the \textit{local anchored} feature extraction is to find features that carry useful and stable information for downstream tasks. Instead of directly searching for local anchored features, we start with searching for \textit{nonrobust} and \textit{unuseful} features. To identify local nonrobust features, we perform adversarial attacks to detect which words are prone to changes under adversarial word substitution. We consider these vulnerable words as features nonrobust to adversarial threats. Therefore, global robust sentence representations should rely less on these vulnerable statistical clues. On the other hand, by examining the adversarial perturbation on each local word feature, we can also identify words that are less useful for downstream tasks. For example, stopwords and punctuation usually carry limited information, and tend to have smaller adversarial perturbations than words containing more effective information. Although these unuseful features are barely changed under adversarial attacks, they contain insufficient information and should be discarded. After identifying the nonrobust and unuseful features, we treat the remaining local features in the sentences as useful stable features and align the global feature representation based on them. 

During the local anchored feature extraction, we perform ``virtual'' adversarial attacks that generate adversarial perturbation in the embedding space, as it abstracts the general idea for existing word-level adversarial attacks. Formally, given an input sentence $x=[x_1; x_2; ...; x_n]$ with its corresponding local embedding representation $t=[t_1; ...; t_n]$, where $x$ and $t$ are the realization of random variables $X$ and $T$, we generate adversarial perturbation $\delta$ in the embedding space so that the task loss $\ell_\text{task}$ increases. The adversarial perturbation $\delta$ is initialized to zero, and the gradient of the loss with respect to $\delta$ is calculated by $g({\delta}) = \nabla_\delta \ell_\text{task}(q_{\psi}({t} + \delta), y)$ to update $\delta \leftarrow \prod_{||\delta||_F \le \epsilon} ( \eta g(\delta) / ||g(\delta)||_F) $. The above process is similar to one-step PGD with zero-initialized perturbation $\delta$. Since we only care about the ranking of perturbation to decide on robust features, in practice we skip the update of $\delta$ to save computational cost, and simply examine the $\ell_2$ norm of the gradient $g({\delta})_i$ of the perturbation on each word feature ${t}_i$. A feasible plan is to choose the words whose perturbation is neither too large (nonrobust features) nor too small (unuseful features), \emph{e.g.}, the words whose perturbation rankings are among $50\% \sim 80\%$ of all the words. The detailed procedures are provided in Algorithm \ref{algo:selection}.
\begin{algorithm}[t]
\caption{\textbf{- Local Anchored Feature Extraction.} This algorithm takes in the word local features and returns the index of local anchored features.}
\label{algo:selection}
\begin{algorithmic}[1]
    \STATE {\bfseries Input:}  Word local features $t$, upper and lower threshold $c_h$ and $c_l$
    \STATE $\delta \leftarrow 0$ \quad \emph{// Initialize the perturbation vector $\delta$}
    \STATE $g({\delta}) = \nabla_\delta \ell_\text{task}(q_{\psi}({t} + \delta), y)$ \quad \emph{// Perform adversarial attack on the embedding space}
    \STATE Sort the magnitude of the gradient of the perturbation vector from $||g({\delta})_1||_2, ||g({\delta})_2||_2, ..., ||g({\delta})_n||_2$ into $||g({\delta})_{k_1}||_2, ||g({\delta})_{k_2}||_2, ..., ||g({\delta})_{k_n}||_2$ in ascending order, where $z_i$ corresponds to its original index.
    \STATE {\bfseries Return:} $k_i, k_{i+1}, ..., k_{j}$, where $c_l \le \frac{i}{n} \le \frac{j}{n} \le c_h$.
\end{algorithmic}
\end{algorithm}

After local anchored features are extracted, we propose to align sentence global representations $Z$ with our local anchored features $T_i$. \modified{In practice, we can use the final-layer [CLS] embedding to represent global sentence-level feature $Z$.} Specifically, we use the information theoretic tool to increase the mutual information $I(T_i; Z)$ between local anchored features $T_i$ and sentence global representations $Z$, so that the global representations can share more robust and useful information with the local anchored features and focus less on the nonrobust and unuseful ones. By incorporating the term $I(T_i; Z)$ into the previous objective function Eq.~(\ref{eq:local_ib}), our final objective function becomes: 
\begin{align}
    \label{eq:complete}
   \max \; I(Y; T) - n \beta \sum_{i=1}^{n} I(X_i; T_i) + \alpha \sum_{j=1}^M I(T_{k_j}; Z), 
\end{align}
where $T_{k_j}$ are the local anchored features selected by Algorithm \ref{algo:selection} \modified{and $M$ is the number of local anchored features}. An illustrative figure can be found in Appendix Figure \ref{fig:overall}.

In addition, due to the intractability of computing MI, we use InfoNCE \citep{infonce} as the lower bound of MI to approximate the last term $I(T_{k_j};Z)$:
\begin{align}
    \label{eq:local}
    \hat{I}^{\text{(InfoNCE})}(T_i; Z) := \mathbb{E_P}\Bigg[g_{\omega}(t_i, z) -  \mathbb{E}_{\mathbb{\tilde{P}}} \Big[ \log \sum_{t'_i} e^{g_{\omega}(t'_i, z)} \Big] \Bigg],
\end{align}
where $g_\omega(\cdot, \cdot)$ is a score function (or critic function) approximated by a neural network, $t_i$ are the positive samples drawn from the joint distribution $\mathbb{P}$ of local anchored features and global representations,  and $t'_i$ are the negative samples drawn from  the distribution of nonrobust and unuseful features $\mathbb{\tilde{P}}$. \section{Experiments}\label{sec:exp}
In this section, we demonstrate how effective \method improves the robustness of language models over multiple NLP tasks such as NLI and QA. We evaluate \method against both strong adversarial datasets and state-of-the-art adversarial attacks.\subsection{Experimental Setup}
\textbf{Adversarial Datasets} The following adversarial datasets and adversarial attacks are used to evaluate the robustness of \method and baselines.
\textbf{(I)} Adversarial NLI (ANLI)~\citep{anli} is a large-scale NLI benchmark, collected via an iterative, adversarial, human-and-model-in-the-loop procedure to attack BERT and RoBERTa. ANLI dataset is a strong adversarial dataset which can easily reduce the  accuracy of BERT$_{\text{Large}}$ to $0\%$. 
\textbf{(II)} Adversarial SQuAD~\citep{advsquad} dataset is an adversarial QA benchmark dataset generated by a set of handcrafted rules and refined by crowdsourcing. Since adversarial training data is not provided, we fine-tune RoBERTa$_{\text{Large}}$ on benign SQuAD training data~\citep{squad} only, and test the models on both benign and adversarial test sets. 
\textbf{(III)} TextFooler~\citep{textfooler} is the state-of-the-art word-level adversarial attack method to generate adversarial examples. To create an adversarial evaluation dataset, we sampled $1,000$ examples from the test sets of SNLI and MNLI respectively, and run TextFooler against BERT$_{\text{Large}}$ and RoBERTa$_{\text{Large}}$ to obtain the adversarial text examples.

\textbf{Baselines} Since IBP-based methods \citep{ibp1,ibp2} cannot be applied to large-scale language models yet, and the randomized-smoothing-based method \citep{safer} achieves limited certified robustness, we compare \method against three competitive baselines based on adversarial training: \textbf{(I)} FreeLB~\citep{freelb} applies adversarial training to language models during fine-tuning stage to improve generalization. In \S\ref{sec:results}, we observe that FreeLB can boost the robustness of language models by a large margin. 
\textbf{(II)} SMART~\citep{smart} uses adversarial training as smoothness-inducing regularization and Bregman proximal point optimization during fine-tuning, to improve the generalization and robustness of language models. 
\textbf{(III)} ALUM~\citep{alum} performs adversarial training in both pre-training and fine-tuning stages, which achieves substantial performance gain on a wide range of NLP tasks. Due to the high computational cost of adversarial training, we compare \method to ALUM and SMART with the best results reported in the original papers.

\textbf{Evaluation Metrics} 
We use robust accuracy or robust F1 score to measure how robust the baseline models and \method are when facing adversarial data. Specifically, robust accuracy is calculated by: $\text{Acc} =  \frac{1}{|D_{\text{adv}}|} \sum_{ \boldsymbol{x'} \in D_{\text{adv}}}{\mathbbm{1}[\argmax q_\psi(f_\theta(x')) \equiv {y}]}$, where  $D_{\text{adv}}$ is the adversarial dataset, $y$ is the ground-truth label, \modified{$\argmax$ selects the class with the highest logits} and $\mathbbm{1}(\cdot)$ is the indicator function. Similarly, robust F1 score is calculated by: $\text{F1} =  \frac{1}{|D_{\text{adv}}|} \sum_{ \boldsymbol{x'} \in D_{\text{adv}}} v(\argmax q_\psi(f_\theta(x')),  {a}) $, where $v(\cdot, \cdot)$ is the F1 score between the true answer $a$ and the predicted answer $\argmax q_\psi(f_\theta(x'))$, and \modified{$\argmax$ selects the answer with the highest probability}  (see \citet{squad} for details).

\textbf{Implementation Details}  To demonstrate \method is effective for different language models, we apply \method to both pretrained RoBERTa$_{\text{Large}}$ and BERT$_{\text{Large}}$. Since \method can be applied to both standard training and adversarial training, we here use FreeLB as the adversarial training implementation. \method is fine-tuned for 2 epochs for the QA task, and 3 epochs for the NLI task. More implementation details such as $\alpha, \beta, c_h, c_l$ selection can be found in Appendix \ref{ap:setup}.

\subsection{Experimental Results} \label{sec:results} 
\textbf{Evaluation on ANLI} As ANLI provides an adversarial training dataset, we evaluate models in two settings: $1)$ training models on benign data (MNLI~\citep{mnli} + SNLI~\citep{snli}) only, which is the case when the adversarial threat model is unknown; $2)$ training models on both benign and adversarial training data (SNLI+MNLI+ANLI+FeverNLI), which assumes the threat model is known in advance. 


\begin{table}[t]
\centering
\resizebox{1.0\textwidth}{!}{
\begin{tabular}{c|c|l|cccc|cccc}
\toprule
\multirow{2}{*}{Training} & \multirow{2}{*}{{Model}} & \multirow{2}{*}{{Method}} &  \multicolumn{4}{c|}{Dev} &  \multicolumn{4}{c}{Test} \\
\cmidrule{4-11}
         &       &            &  A1 & A2 & A3 & ANLI &  A1 & A2 & A3 & ANLI \\
\midrule
\multirow{4}{*}{\shortstack{Standard \\Training}} & \multirow{2}{*}{\shortstack{RoBERTa}} & Vanilla & 49.1 & 26.5 & 27.2 & 33.8 & 49.2 & 27.6 & 24.8 & 33.2 \\
&                                       & InfoBERT       & 47.8 & 31.2 & 31.8 & \textbf{36.6} & 47.3 & 31.2 & 31.1 & \textbf{36.2}  \\
\cmidrule{2-11}
                                                  & \multirow{2}{*}{\shortstack{BERT}}    & Vanilla & 20.7 & 26.9 & 31.2 & 26.6 & 21.8 & 28.3 & 28.8 & 26.5 \\
&                                       & InfoBERT & 26.0 & 30.1 & 31.2 & \textbf{29.2} & 26.4 & 29.7 & 29.8 & \textbf{28.7} \\                   
\midrule
\midrule
\multirow{4}{*}{\shortstack{Adversarial\\Training}} & \multirow{2}{*}{\shortstack{RoBERTa}} & FreeLB   & 50.4 & 28.0 & 28.5 & 35.2 &  48.1 & 30.4  & 26.3 & 34.4 \\
                                                    &                                       & InfoBERT   & 48.4 & 29.3 & 31.3 & \textbf{36.0} &  50.0 & 30.6  & 29.3 & \textbf{36.2} \\
\cmidrule{2-11}
                                                  & \multirow{2}{*}{\shortstack{BERT}}    & FreeLB    & 23.0 & 29.0 & 32.2 & 28.3 & 22.2 & 28.5 & 30.8 & 27.4 \\
                                                  &                                       & InfoBERT   & 28.3 & 30.2 & 33.8 & \textbf{30.9} & 25.9 & 28.1 & 30.3 & \textbf{28.2} \\                          
\bottomrule
\end{tabular}
}
\caption{Robust accuracy on the ANLI dataset. Models are trained on the benign datasets (MNLI + SNLI) only. `A1-A3' refers to the rounds with increasing difficulty. `ANLI' refers to A1+A2+A3.} 
\label{tab:set1_acc}
\vspace{-2mm}
\end{table} \begin{table}[t]
\centering
\resizebox{1.0\textwidth}{!}{
\begin{tabular}{c|c|l|cccc|cccc}
\toprule
\multirow{2}{*}{Training} & \multirow{2}{*}{{Model}} & \multirow{2}{*}{{Method}} &  \multicolumn{4}{c|}{Dev} &  \multicolumn{4}{c}{Test} \\
\cmidrule{4-11}
         &       &            &  A1 & A2 & A3 & ANLI &  A1 & A2 & A3 & ANLI \\
\midrule
\multirow{4}{*}{\shortstack{Standard \\Training}} & \multirow{2}{*}{\shortstack{RoBERTa}} & Vanilla   & 74.1 & 50.8 & 43.9 & 55.5 & 73.8 & 48.9 & 44.4 & 53.7\\
&                                       & InfoBERT   & 75.2 & 49.6 & 47.8 & \textbf{56.9} & 73.9 & 50.8 & 48.8 & \textbf{57.3} \\
\cmidrule{2-11}
                                                  & \multirow{2}{*}{\shortstack{BERT}}    & Vanilla &  58.5 & 46.1 & 45.5 & 49.8 & 57.4 & 48.3 & 43.5 & 49.3 \\


                                                  &                                       & InfoBERT  & 59.3 & 48.9 & 45.5 & \textbf{50.9} & 60.0 & 46.9 & 44.8 & \textbf{50.2} \\
\midrule
\midrule 
\multirow{7}{*}{\shortstack{Adversarial\\Training}} & \multirow{4}{*}{\shortstack{RoBERTa}} & FreeLB     &  75.2 & 47.4 & 45.3 & 55.3 & 73.3 & 50.5 & 46.8 & 56.2 \\
                                                  &                                       &  SMART     &  74.5 & 50.9 & 47.6 & 57.1 & 72.4 & 49.8 & 50.3 & 57.1 \\
                                                  &                                       &  ALUM       &  73.3 & 53.4 & 48.2 & 57.7 & 72.3 & 52.1 & 48.4 & 57.0 \\
                                                  &                                       & InfoBERT    & 76.4 & 51.7 & 48.6 & \textbf{58.3} & 75.5 & 51.4 & 49.8 & \textbf{58.3}  \\
\cmidrule{2-11}
                                                  & \multirow{3}{*}{\shortstack{BERT}}     & FreeLB    &  60.3 & 47.1 & 46.3 & 50.9 & 60.3 & 46.8 & 44.8 & 50.2 \\
                                                  &                                       & ALUM        &  62.0 & 48.6 & 48.1 & \textbf{52.6} & 61.3 & 45.9 & 44.3 & 50.1 \\
                                                  &                                       & InfoBERT     &  60.8 & 48.7 & 45.9 & 51.4 & 63.3 & 48.7 & 43.2 & \textbf{51.2} \\
\bottomrule
\end{tabular}
}
\caption{Robust accuracy on the ANLI dataset.  Models are trained on both adversarial and benign datasets (ANLI (training) + FeverNLI + MNLI + SNLI). } 
\label{tab:set2_acc}
\vspace{-3mm}
\end{table} Results of the first setting are summarized in Table \ref{tab:set1_acc}. The vanilla RoBERTa and BERT models perform poorly on the adversarial dataset. In particular, vanilla BERT$_{\text{Large}}$ with standard training achieves the lowest robust accuracy of $26.5\%$ among all the models. We also evaluate the robustness improvement by performing adversarial training during fine-tuning, and observe that adversarial training for language models can improve not only generalization but also robustness. In contrast, \method substantially improves robust accuracy in both standard and adversarial training. The robust accuracy of \method through standard training is even higher than the adversarial training baseline FreeLB for both RoBERTa and BERT, while the training time of \method is $1/3 \sim 1/2$ less than FreeLB. This is mainly because FreeLB requires multiple steps of PGD attacks to generate adversarial examples, while \method essentially needs only 1-step PGD attack for anchored feature selection. 

Results of the second setting are provided in Table 2, which shows \method can further improve robust accuracy for both standard and adversarial training. Specifically, when combined with adversarial training, \method achieves the state-of-the-art robust accuracy of $58.3\%$, outperforming all 
existing baselines. Note that although ALUM achieves higher accuracy for BERT on the dev set, it tends to overfit on the dev set, therefore performing  worse than \method on the test set. 

\textbf{Evaluation against TextFooler} \method can defend against not only human-crafted adversarial examples (\emph{e.g.}, ANLI) but also those generated by adversarial attacks (\emph{e.g.}, TextFooler). Results are summarized in Table \ref{tab:set1_tf_acc}. We can see that \method barely affects model performance on the benign test data, and in the case of adversarial training, \method even boosts the benign test accuracy. Under the TextFooler attack, the robust accuracy of the vanilla BERT drops to $0.0\%$ on both MNLI and SNLI datasets, while RoBERTa drops from $90\%$ to around $20\%$. We observe that both adversarial training and \method with standard training can improve robust accuracy by a comparable large margin, while \method with adversarial training achieves the best performance among all models, confirming the hypothesis in Theorem \ref{thm:bound} that combining adversarial training with IB regularizer can further minimize $I(X_i';T_i')$,  leading to better robustness than the vanilla one.

\begin{table}[t]
\centering
\resizebox{1.0\textwidth}{!}{
\begin{tabular}{c|c|l|cc|cccc}
\toprule
\multirow{2}{*}{Training} & \multirow{2}{*}{{Model}} & \multirow{2}{*}{{Method}}  & \multirow{2}{*}{{SNLI}} & {MNLI} & {adv-SNLI} & adv-MNLI & adv-SNLI & adv-MNLI \\
& & & & (m/mm) & (BERT) & (BERT) & (RoBERTa) & (RoBERTa)\\
\midrule
\multirow{4}{*}{\shortstack{Standard \\Training}} & \multirow{2}{*}{\shortstack{RoBERTa}} & Vanilla  & {92.6} & \textbf{90.8/90.6}  & {56.6} &  {68.1}/68.6 &  19.4 & 24.9/24.9  \\
                                                  &                                       & InfoBERT & \textbf{93.3} & {90.5/90.4}  & \textbf{59.8} &  \textbf{69.8/70.6} &  \textbf{42.5} & \textbf{50.3/52.1}  \\
\cmidrule{2-9}
                                                  & \multirow{2}{*}{\shortstack{BERT}}    & Vanilla   & {91.3} & \textbf{86.7/86.4} & 0.0 & 0.0/0.0 & 44.9 & 57.0/57.5   \\
                                                  &                                       & InfoBERT  &  \textbf{91.7} & 86.2/86.0 & \textbf{36.7} & \textbf{43.5}/\textbf{46.6} & \textbf{45.4} & \textbf{57.2/58.6}   \\
\midrule
\midrule
\multirow{4}{*}{\shortstack{Adversarial \\Training}} & \multirow{2}{*}{\shortstack{RoBERTa}} & FreeLB  & \textbf{93.4} & 90.1/{90.3} & {60.4} & 70.3/72.1 &  41.2 & 49.5/50.6  \\
                                                  &                                       & InfoBERT       & 93.1 & \textbf{90.7/90.4} & \textbf{62.3} & \textbf{73.2/73.1} &  \textbf{43.4} & \textbf{56.9/55.5}  \\
\cmidrule{2-9}
                                                  & \multirow{2}{*}{\shortstack{BERT}}    & FreeLB     & \textbf{92.4} & 86.9/86.5 & 46.6 & 60.0/60.7 & 50.5 & 64.0/62.9  \\
                                                  &                                       & InfoBERT     & 92.2 & \textbf{87.2/87.2} & \textbf{50.8} & \textbf{61.3/62.7} & \textbf{52.6} & \textbf{65.6/67.3}   \\
\bottomrule
\end{tabular}
}
\caption{Robust accuracy on the adversarial SNLI and MNLI(-m/mm) datasets generated by TextFooler based on blackbox BERT/RoBERTa (denoted in brackets of the header). Models are trained on the benign datasets (MNLI+SNLI) only.
}  \label{tab:set1_tf_acc}
\vspace{-3mm}
\end{table}
 
\textbf{Evaluation on Adversarial SQuAD} Previous experiments show that \method can improve model robustness for NLI tasks. Now we demonstrate that \method can also be adapted to other NLP tasks such as QA in Table \ref{tab:adv_squad}. Similar to our observation on NLI dataset, we find that \method barely hurts the performance on the benign test data, and even improves it in some cases. Moreover, \method substantially improves model robustness when presented with adversarial QA test sets (AddSent and AddOneSent). While adversarial training does help improve robustness, \method can further boost the robust performance by a larger margin. In particular, \method through standard training achieves the state-of-the-art robust F1/EM score as $78.5/72.9$ compared to existing adversarial training baselines, and in the meantime requires only half the training time of adversarial-training-based methods. 









\begin{figure}[t]
\begin{minipage}{\textwidth}
  \begin{minipage}[b]{0.59\textwidth}
    \centering
    \resizebox{1.0\textwidth}{!}{
    \begin{tabular}{c|l|c|cc}
    \toprule
    Training & {Method}  & {benign} & {{AddSent}} & {AddOneSent} \\
    \midrule
    \multirow{2}{*}{\shortstack{Standard \\Training}  }    & Vanilla     & \textbf{93.5}/86.9  & 72.9/66.6  & 80.6/74.3 \\
                                                           & InfoBERT     & \textbf{93.5/87.0}  & \textbf{78.5/72.9}  & \textbf{84.6/78.3} \\ 


    \midrule
    \midrule                                                      
    \multirow{3}{*}{\shortstack{Adversarial \\Training}}   & FreeLB     & \textbf{93.8}/\textbf{87.3}   & 76.3/70.3  & 82.3/76.2 \\
                                                           & ALUM         & -            & 75.5/69.4  &  81.4/75.9 \\
                                                           & InfoBERT     & 93.7/87.0  &  \textbf{78.0/71.8} &   \textbf{83.6/77.1} \\
\bottomrule   
    \end{tabular}
    }
    \captionof{table}{Robust F1/EM scores based on RoBERTa$_{\text{Large}}$ on the adversarial SQuAD datasets (AddSent and AddOneSent). Models are trained on standard SQuAD 1.0 dataset.}\label{tab:adv_squad}
    \end{minipage}
     \hfill
     \begin{minipage}[b]{0.39\textwidth}
    \centering
    \includegraphics[trim=0 108 0 0, clip,width=\linewidth]{figures/robust_feature2.pdf}
    \captionof{figure}{Local anchored features contribute more to MI improvement than nonrobust/unuseful features, unveiling closer relation with robustness.}\label{fig:robust_analysis}
  \end{minipage}
\end{minipage}
\end{figure}

\subsection{Analysis of Local Anchored Features}

We conduct an ablation study to further validate that our anchored feature regularizer indeed filters out nonrobust/unuseful information. As shown in Table \ref{tab:set1_acc}  and \ref{tab:set2_acc}, adding adversarial data in the training set can significantly improve model robustness. To find out what helps improve the robustness from the MI perspective, we first calculate the MI between anchored features and global features $\frac{1}{M}\sum_{j=1}^M I(T_{k_j}; Z)$ on the adversarial test data and benign test data, based on the model trained without adversarial training data (denoted by $I'_{\text{R}}$ and $I_{\text{R}}$). We then calculate the MI between nonrobust/unuseful features and global features $\frac{1}{M'}\sum_{i=1}^{M'} I(T_{k_i}; Z)$ on the adversarial test data and benign data as well (denoted by $I'_{\text{N}}$ and $I_{\text{N}}$). After adding adversarial examples into the training set and re-training the model, we find that the MI between the local features and the global features substantially increases on the adversarial test data, which accounts for the robustness improvement. We also observe that those local anchored features extracted by our anchored feature regularizer, as expected, contribute more to the MI improvement. As shown in Figure \ref{fig:robust_analysis}, the MI improvement of anchored features on adversarial test data $\Delta I'_{\text{R}}$ (red bar on the left) is higher than that of nonrobust/unuseful $\Delta I'_{\text{N}}$ (red bar on the right), thus confirming that local anchored features discovered by our anchored feature regularizer 
have a stronger impact on robustness than nonrobust/unuseful ones. 

We conduct more ablation studies in Appendix \S\ref{ap:exp}, including analyzing \modified{the individual impact of two regularizers,} the difference between global and local features for IB regularizer, hyper-parameter selection strategy and so on.


 \section{Conclusion}
In this paper, we propose a novel learning framework \method from an information theoretic perspective to perform robust fine-tuning over pre-trained language models. Specifically, InfoBERT consists of two novel regularizers to improve the robustness of the learned representations: (a) Information Bottleneck Regularizer, learning to extract the approximated minimal sufficient statistics and denoise the excessive spurious features, and (b) Local Anchored Feature Regularizer, which improves the robustness of global features by aligning them with local anchored features.  Supported by our theoretical analysis, \method provides a principled way to improve the robustness of BERT and RoBERTa against strong adversarial attacks over a variety of NLP tasks, including NLI and QA tasks. Comprehensive experiments demonstrate that \method outperforms existing baseline methods and achieves new state of the art on different adversarial datasets. We believe this work will shed light on future research directions towards improving the robustness of representation learning for language models. 



\section{Acknowledgement}
We gratefully thank the anonymous reviewers and meta-reviewers for their constructive feedback. We also thank Julia Hockenmaier, Alexander Schwing, Sanmi Koyejo, Fan Wu, Wei Wang, Pengyu Cheng, and many others for the helpful discussion.   This work is partially supported by NSF grant No.1910100, DARPA QED-RML-FP-003, and the Intel RSA 2020. 
\bibliography{iclr2021_conference}
\bibliographystyle{iclr2021_conference}

\newpage
\appendix
\section{Appendix}

\begin{figure}[htp!]
    \centering
    \includegraphics[width=\linewidth]{figures/infobert1.pdf}
    \caption{The complete objective function of \method, which can be decomposed into (a) standard task objective, (b) Information Bottleneck Regularizer, and (c) Local Anchored Feature Regularizer. For (b), we both theoretically and empirically demonstrate that we can improve the adversarial robustness by decreasing the mutual information of $I(X_i; T_i)$ without affecting the benign accuracy much. For (c), we propose to align the local anchored features $T_{k_j}$ (highlighted in Yellow) with the global feature $Z$ by maximizing their mutual information $I(T_{k_j}; Z)$. }
    \label{fig:overall}
\end{figure}

\subsection{Implementation Details} \label{ap:setup}


\paragraph[Model Details]{Model Details\footnote{We use the huggingface implementation  \url{https://github.com/huggingface/transformers} for BERT and RoBERTa.}}  BERT is a transformer \citep{DBLP:conf/nips/VaswaniSPUJGKP17} based model, which is unsupervised pretrained on large corpora. We use BERT$_\text{Large}$-uncased as the baseline model, which has $24$ layers,  $1024$ hidden units, $16$ self-attention heads, and $340$M parameters. RoBERTa$_\text{Large}$ shares the same architecture as BERT, but modifies key hyperparameters, removes the next-sentence pretraining objective and trains with much larger mini-batches and learning rates, which results in higher performance than BERT model on GLUE, RACE and SQuAD.

\paragraph{Standard Training Details} For both standard and adversarial training, we fine-tune \method for 2 epochs on the QA task, and for 3 epochs on the NLI task. The best model is selected based on the performance on the development set. All fine-tuning experiments are run on Nvidia V100 GPUs. For NLI task, we set the batch size to $256$, learning rate to $2 \times 10^{-5}$, max sequence length to $128$ and warm-up steps to 1000. For QA task,  we set the batch size to $32$, learning rate to $3\times 10^{-5}$ and max sequence length to $384$ without warm-up steps. 

\paragraph[Adversarial Training Details]{Adversarial Training Details\footnote{We follow the FreeLB implementations in \url{https://github.com/zhuchen03/FreeLB}.}} Adversarial training introduces hyper-parameters including adversarial learning rates, number of PGD steps, and adversarial norm. When combing adversarial training with \method, we use FreeLB as the adversarial training implementation, and set adversarial learning rate to $10^{-1}$ or $4*10^{-2}$, adversarial steps to $3$, maximal perturbation norm to $3* 10^{-1}$ or $2*10^{-1}$ and initial random perturbation norm to $10^{-1}$ or $0$.

\paragraph{Information Bottleneck Regularizer Details} For information bottleneck, there are different ways to model $p(t \mid x)$: 
\begin{enumerate}[leftmargin=*]
    \item \textbf{Assume that $p(t \mid x)$ is unknown.} We use a neural net parameterized by $q_\theta(t \mid x)$ to learn the conditional distribution $p(t \mid x)$. We assume the distribution is a Gaussian distribution. The neural net $q_\theta$ will learn the mean and variance of the Gaussian given input ${x}$ and representation ${t}$. By reparameterization trick, the neural net can be backpropagated to approximate the distribution given the training samples.
    \item \textbf{$p(t \mid x)$ is known.} Since ${t}$ is the representation encoded by BERT, we actually already know the distribution of $p$. We also denote it as $q_\theta$, where $\theta$ is the parameter of the BERT encoder $f_\theta$. If we assume the conditional distribution is a Gaussian $\mathcal{N}({t}_i, \sigma)$ for input $x_i$ whose mean is the BERT representation $t_i$ and variance is a fixed constant $\sigma$, the Eq.\ref{eq:local_ib} becomes
\begin{align}
    \label{eq:l2}
    \mathcal{L}_{\text{LIB}} = \frac{1}{N}\sum_{i=1}^{N} \Bigg( \big[ \log q_\psi({y}^{(i)} \mid {t}^{(i)}) \big] - \beta  \sum_{k=1}^{n} \Big[- 
    c(\sigma) || {t}'^{(i)}_k - {t}^{(i)}_k ||^2_2  +  \frac{1}{n} \sum_{j=1}^{N} c(\sigma) ||{t}_j - {t}_k ||^2_2  \Big] \Bigg),
\end{align}
    where $ c(\sigma)$ is a positive constant related to $\sigma$. In practice, the sample ${t}'_i$ from the conditional distribution Gaussian $\mathcal{N}({t}_i, \sigma)$  can be ${t}_i$ with some Gaussian noise, an adversarial examples of ${t}_i$, or ${t}_i$ itself (assume $\sigma=0$).
\end{enumerate}

We use the second way to model $p(t \mid x)$ for \method finally, as it gives higher robustness improvement than the first way empirically (shown in the following \S\ref{ap:exp}). We suspect that the main reason is because the first way needs to approximate the distribution $p(t \mid x)$ via another neural net which could present some difficulty in model training. 

Information Bottleneck Regularizer also introduces another parameter $\beta$ to tune the trad-off between representation compression $I(X_i;T_i)$ and predictive power $I(Y;T)$. We search for the optimal $\beta$ via grid search, and set $\beta=5 \times 10^{-2}$ for RoBERTa, $\beta=10^{-3}$ for BERT on the NLI task. On the QA task, we set $\beta=5 \times 10^{-5}$, which is substantially lower than $\beta$ on NLI tasks, thus containing more word-level features. We think it is mainly because the QA task relies more on the word-level representation to predict the exact answer spans. More ablation results can be found in the following \S\ref{ap:exp}.

\paragraph{Anchored Feature Regularizer Details} Anchored Feature Regularizer uses $\alpha$ to weigh the balance between predictive power and importance of anchored feature. We set $\alpha=5 \times 10^{-3}$ for both NLI and QA tasks. Anchored Feature Regularizer also introduces upper and lower threshold $c_l$ and $c_h$ for anchored feature extraction. We set $c_h = 0.9$ and $c_l = 0.5$ for the NLI task, and set $c_h = 0.95$ and $c_l = 0.75$ for the QA task. The neural MI estimator used by infoNCE uses two-layer fully connected layer to estimate the MI with the intermediate layer hidden size set to $300$.









\subsection{Additional Experimental Results} \label{ap:exp}
\subsubsection{Ablation Study on Information Bottleneck Regularizer}
\paragraph{Modeling $p(t \mid x)$} As discussed in \S\ref{ap:setup}, we have two ways to model $p( t\mid x)$: ($i$) using an auxiliary neural network to approximate the distribution; ($ii$) directly using the BERT encoder $f_\theta$ to calculate the $p(t \mid x)$. Thus we implemented these two methods and compare the robustness improvement in Table \ref{tab:ablation_p}.  To eliminate other factors such as Anchored Feature Regularizer and adversarial training, we set $\alpha=0, \beta=5 \times 10^{-2}$ and conduct the following ablation experiments via standard training on standard datasets. We observe that although both modeling methods can improve the model robustness, modeling as BERT encoder gives a larger margin than the Auxiliary Net. Moreover, the second way barely sacrifices the performance on benign data, while the first way can hurt the benign accuracy a little bit. Therefore, we use the BERT Encoder $f_\theta$ to model the $p(t \mid x)$ in our main paper.


\begin{table}[t]
\centering
{
\begin{tabular}{c|c|l|c|c}
\toprule
\multirow{2}{*}{Model} & \multirow{2}{*}{{Datasets}} & \multirow{2}{*}{{Method}} & Adversarial Accuracy & Benign Accuracy \\
& & & (ANLI) & (MNLI/SNLI) \\
\midrule
\multirow{3}{*}{BERT} & \multirow{3}{*}{\shortstack{Standard \\Datasets}} & Vanilla & 26.5 & \textbf{86.7}/91.3 \\
\cmidrule{3-5}
& & Auxiliary Net & 27.1 & 83.1/90.7 \\
\cmidrule{3-5}
& & BERT Encoder $f_\theta$ & \textbf{27.7} & 85.9/\textbf{91.7} \\
\bottomrule
\end{tabular}
}
\caption{Robust accuracy on the ANLI dataset. Here we refer ``Standard Datasets'' as training on the benign datasets (MNLI + SNLI) only. ``Vanilla'' refers to the vanilla BERT trained without Information Bottleneck Regularizer.} 
\label{tab:ablation_p}
\end{table}

\begin{table}[b]
\centering
{
\begin{tabular}{c|c|l|c|c}
\toprule
\multirow{2}{*}{Model} & \multirow{2}{*}{{Datasets}} & \multirow{2}{*}{{Features}} & Adversarial Accuracy & Benign Accuracy \\
& & & (ANLI) & (MNLI/SNLI) \\
\midrule
\multirow{6}{*}{RoBERTa} & \multirow{3}{*}{\shortstack{Standard \\Datasets}} & Vanilla & 33.2 & 90.8/92.6 \\
\cmidrule{3-5}
& & Global Feature & 33.8 & 90.4/93.5 \\
\cmidrule{3-5}
& & Local Feature & \textbf{33.9} & \textbf{90.6/93.7} \\
\cmidrule{2-5}
& \multirow{3}{*}{\shortstack{Standard\\and\\Adversarial \\Datasets}} & Vanilla & 53.7 & \textbf{91.0}/92.6 \\
\cmidrule{3-5}
& & Global Feature & 55.1 & 90.8/\textbf{93.3} \\
\cmidrule{3-5}
& & Local Feature & \textbf{56.2} & 90.5/\textbf{93.3} \\
\bottomrule
\end{tabular}
}
\caption{Robust accuracy on the ANLI dataset. Here we refer ``Standard Datasets'' as training on the benign datasets (MNLI + SNLI) only, and ``Standard and Adversarial Datasaets'' as training on the both benign and adversarial datasets (ANLI(trianing) + MNLI + SNLI + FeverNLI). ``Vanilla'' refers to the vanilla RoBERTa trained without Information Bottleneck Regularizer.} 
\label{tab:ablation_global}
\end{table}

\paragraph{Local Features v.s. Global Features} Information Bottlenck Regularizer improves model robustness by reducing $I(X;T)$. In the main paper, we use $T$ as word-level local features. Here we consider $T$ as sentence-level global features, and compare the robustness improvement with $T$ as local features. To eliminate other factors such as Anchored Feature Regularizer and adversarial training, we set $\alpha=0, \beta=5 \times 10^{-2}$ and conduct the following ablation experiments via standard training. 

The experimental results are summarized in Table \ref{tab:ablation_global}. We can see that while both features can boost the model robustness, using local features yield higher robust accuracy improvement than global features, especially when adversarial training dataset is added. 

\paragraph{Hyper-parameter Search} We perform grid search to find out the optimal $\beta$ so that the optimal trade-off between representation compression (``minimality'') and predictive power (``sufficiency'') is achieved. An example to search for the optimal $\beta$ on QA dataset is shown in Fingure \ref{fig:ablation_beta}, which illustrates how $\beta$ affects the F1 score on benign and adversarial datasets. We can see that from a very small $\beta$, both the robust and benign F1 scores increase, demonstrating \method can improve both robustness and generalization to some extent. When we set $\beta=5\times10^{-5}$ ($\log(\beta)=-9.9$), \method achieves the best benign and adversarial accuracy. When we set a larger $\beta$ to further minimize $I(X_i;T_i)$, we observe that the benign F1 score starts to drop, indicating the increasingly compressed representation could start to hurt its predictive capability.
\begin{figure}[t]
    \centering
    \includegraphics[width=0.7\linewidth]{figures/tune_ib.eps}
    \caption{Benign/robust F1 score on benign/adversarial QA datasets. Models are trained on the benign SQuAD dataset with different $\beta$.}
    \label{fig:ablation_beta}
\end{figure}


\subsubsection{Ablation Study on Anchored Feature Regularizer}
\paragraph{Visualization of Anchored Words} To explore which local anchored features are extracted, we conduct another ablation study to visualize the local anchored words. We follow the best hyper-parameters of Anchored Feature Regularizer introduced in \S\ref{ap:setup}, use the best BERT model trained on benign datasets (MNLI + SNLI) only and test on the ANLI dev set. We visualize the local anchored words in Table \ref{tab:ablation_anchor} as follows. In the first example, we find that Anchored Features mainly focus on the important features such as quantity number ``Two'', the verb ``playing'' and objects ``card''/``poker'' to make a robust prediction. In the second example, the matching robust features between hypothesis and premise, such as ``people'', ``roller'' v.s. ``park'', ``flipped upside'' v.s. ``ride'', are aligned to infer the relationship of hypothesis and premise. These anchored feature examples confirm that Anchored Feature Regularizer is able to find out useful and stable features to improve the robustness of global representation.

\begin{table}[htp!]\small \setlength{\tabcolsep}{7pt}
\centering
\begin{tabular}{p{13.8cm}}
\toprule Input (\textbf{bold} = local stable words for local anchored features.) \\
\midrule
\textbf{Premise:} \textbf{Two} woman, both sitting near a \textbf{pile} of \textbf{poker} \textbf{chips}, are \textbf{playing} \textbf{cards}.  \\
\textbf{Hypothesis:} \textbf{Two} woman \textbf{playing} \textbf{poker}.  \\
\midrule
\textbf{Premise:} \textbf{People} are \textbf{flipped} \textbf{upside} - down on a bright yellow \textbf{roller} coaster.  \\
\textbf{Hypothesis:} \textbf{People} \textbf{on} on a \textbf{ride} at an amusement \textbf{park}.  \\
\bottomrule
\end{tabular}
\caption{Local anchored features extracted by Anchored Feature Regularizer.}
\label{tab:ablation_anchor}
\end{table}

\modified{
\subsubsection{Ablation Study on Disentangling Two Regularizers}
To understand how two regularizers contribute to the improvement of robustness separetely, we apply two regularizers individually to both the standard training and adversarial training. We refer InfoBERT trained with IB regularizer only as ``InfoBERT (IBR only)'' and InfoBERT trained with Anchored Feature Regularizer only as ``InfoBERT (AFR only)''. ``InfoBERT (Both)'' is the standard setting for InfoBERT, where we incorporate both regularizers during training. For ``InfoBERT (IBR only)'', we set $\alpha = 0$  and perform grid search to find the optimal $\beta=5 \times 10^{-2}$. Similarly for ``InfoBERT (AFR only)'', we set $\beta = 0$ and find the optimal parameters as $\alpha=5 \times 10^{-3}, c_h=0.9$ and $c_l=0.5$.

The results are shown in Table \ref{tab:ablation_separately}. We can see that both regularizers improve the robust accuracy on top of vanilla and FreeLB to a similar margin. Applying one of the regularizer can achieve similar performance of FreeLB, but the training time of InfoBERT is only $1/3 \tilde 1/2$ less than FreeLB. Moreover, after combining both regularizers, we observe that InfoBERT achieves the best robust accuracy.
}

\begin{table}[ht]
\centering
{
\modified{
\begin{tabular}{c|c|l|c|c}
\toprule
\multirow{2}{*}{Model} & \multirow{2}{*}{{Training}} & \multirow{2}{*}{{Method}} & Adversarial Accuracy & Benign Accuracy \\
& & & (ANLI) & (MNLI/SNLI) \\
\midrule
\multirow{8}{*}{BERT} & \multirow{4}{*}{\shortstack{Standard \\Training}} & Vanilla & 26.5 & {86.7}/91.3 \\
\cmidrule{3-5}
& & InfoBERT (IBR only) & {27.7} & 85.9/{91.7} \\
\cmidrule{3-5}
& & InfoBERT (AFR only) & 28.0 & 86.6/91.9    \\
\cmidrule{3-5}
& & InfoBERT (Both) & 29.2 & 85.9/91.6  \\
\cmidrule{2-5}
& \multirow{4}{*}{\shortstack{Adversarial \\Training}} & FreeLB & 27.7 & 86.7/\textbf{92.3} \\
\cmidrule{3-5}
& & InfoBERT (IBR only) & {29.3} & 87.0/\textbf{{92.3}} \\
\cmidrule{3-5}
& & InfoBERT (AFR only) & 30.3 & 86.9/\textbf{92.3}  \\
\cmidrule{3-5}
& & InfoBERT (Both) & \textbf{30.9} & \textbf{87.2}/92.2  \\
\bottomrule
\end{tabular}
}
}
\caption{Robust accuracy on the ANLI dataset. Models are trained on the benign datasets (MNLI + SNLI). Here we refer ``IBR only'' as training with Information Bottleneck Regularizer only. ``AFR only'' refers to InfoBERT trained with Anchored Feature Regularizer only. ``Both'' is the standard InfoBERT that applies two regularizers together.} 
\label{tab:ablation_separately}
\end{table}


\subsubsection{Examples of Adversarial Datasets generated by TextFooler} We show some adversarial examples generated by TextFooler in Table \ref{tab:ablation_eg}. We can see most adversarial examples are of high quality and look valid to human while attacking the NLP models, thus confirming our adversarial dastasets created by TextFooler is a strong benchmark dataset to evaluate model robustness. However, as also noted in \citet{textfooler}, we observe that some adversarial examples look invalid to human For example, in the last example of Table \ref{tab:ablation_eg}, TextFooler replaces ``stand'' with ``position'', losing the critical information that ``girls are \textbf{standing} instead of kneeling'' and fooling both human and NLP models. Therefore, we expect that \method should achieve better robustness when we eliminate such invalid adversarial examples during evaluation.
\begin{table}[htp!]\small \setlength{\tabcolsep}{7pt}
\centering
\begin{tabular}{p{13.8cm}}
\toprule Input (\textcolor{red}{red} = Modified words, \textbf{bold} = original words.) \\
\midrule
\midrule
\textbf{\textit{Valid Adversarial Examples} }\\
\midrule 

\textbf{Premise:} A young boy is playing in the sandy water.\\
\textbf{Original Hypothesis: } There is a \textbf{boy} in the water. \\
\textbf{Adversarial Hypothesis: } There is a \textcolor{red}{man} in the water. \\
\\
\textbf{Model Prediction: } Entailment $\rightarrow$ Contradiction \\
\midrule

\textbf{Premise:} A black and brown dog is playing with a brown and white dog .\\
\textbf{Original Hypothesis: } Two dogs \textbf{play}. \\
\textbf{Adversarial Hypothesis: } Two dogs \textcolor{red}{gaming}. \\
\\
\textbf{Model Prediction: } Entailment $\rightarrow$ Neutral \\
\midrule

\textbf{Premise:} Adults and children share in the looking at something, and some young ladies stand to the side.\\
\textbf{Original Hypothesis: } Some children are \textbf{sleeping}. \\
\textbf{Adversarial Hypothesis: } Some children are \textcolor{red}{dreaming}. \\
\\
\textbf{Model Prediction: } Contradiction $\rightarrow$ Neutral \\
\midrule

\textbf{Premise:} Families with strollers waiting in front of a carousel.\\
\textbf{Original Hypothesis: } Families have some \textbf{dogs} in front of a carousel. \\
\textbf{Adversarial Hypothesis: } Families have some \textcolor{red}{doggie} in front of a carousel. \\
\\
\textbf{Model Prediction: } Contradiction $\rightarrow$ Entailment \\
\midrule 
\midrule 
\textbf{\textit{Invalid Adversarial Examples }}\\
\midrule 

\textbf{Premise:} Two girls are kneeling on the ground. \\
\textbf{Original Hypothesis: } Two girls \textbf{stand} around the vending \textbf{machines}.\\
\textbf{Adversarial Hypothesis: } Two girls \textcolor{red}{position} around the vending \textcolor{red}{machinery}. \\
\\
\textbf{Model Prediction: } Contradiction $\rightarrow$ Neutral \\
\bottomrule
\end{tabular}
\caption{Adversarial Examples Generated by TextFooler for BERT$_\text{Large}$ on SNLI dataset.}
\label{tab:ablation_eg}
\end{table}




\clearpage
\subsection{Proofs}
\subsubsection{Proof of Theorem \ref{thm:local}}
We first state two lemmas.
\begin{lemma}\label{lem:mi}
Given a sequence of random variables $X_1, X_2, ..., X_n$ and a deterministic function $f$, then $\forall \, i, j = 1, 2, ..., n,$ we have 
\begin{align}
    I(X_i; f(X_i)) \ge I(X_j; f(X_i))
\end{align}
\end{lemma}
\begin{proof}
By the definition,
\begin{align}
    I(X_i; f(X_i)) &= H(f(X_i)) - H(f(X_i) \mid X_i) \\
    I(X_j; f(X_i)) &= H(f(X_i)) - H(f(X_i) \mid X_j) 
\end{align}

Since $f$ is a deterministic function, 
\begin{align}
     H(f(X_i) \mid X_i) &= 0 \\
     H(f(X_i) \mid X_j) &\ge 0 
\end{align}
Therefore, 
\begin{align}
    I(X_i; f(X_i)) \ge I(X_j; f(X_i))
\end{align}
\end{proof}

\begin{lemma} \label{lem:local} Let $X=[X_1; X_2; ...; X_n]$ be a sequence of random variables, and $T=[T_1; T_2; ...; T_n]=[f(X_1); f(X_2); ...; f(X_n)]$ be a sequence of random variables generated by a deterministic function $f$.  Then we have 
\begin{align}
    I(X;T) \le n \sum_{i=1}^n I(X_i;T_i)
\end{align}

\end{lemma}
\begin{proof}
Since $X=[X_1;X_2;...;X_n]$ and $T=[T_1;T_2;...;T_n]$ are language tokens with its corresponding local representations, we have 
\begin{align}
    I(X;T) &= I(X; T_1, T_2, ..., T_n) = \modified{\sum_{i=1}^n[H(T_i \mid T_1, T_2,..., T_{i-1}) - H(T_i \mid X, T_1, T_2, ..., T_{i-1})]} \\
    &\le \sum_{i=1}^n [ H(T_i) - H(T_i \mid X)] = \sum_{i=1}^n I(X; T_i) \\
    &\le \sum_{i=1}^n \sum_{j=1}^n I(X_j; T_i) \le n \sum_{i=1}^n I(X_i; T_i),
\end{align}
where the first inequality follows because conditioning reduces entropy, and the last inequality is because $I(X_i; T_i) \ge I(X_j; T_i) $ based on Lemma \ref{lem:mi}.
\end{proof}
Then we directly plug Lemma \ref{lem:local} into Theorem \ref{thm:local}, we have the lower bound of $\mathcal{L}_{\text{IB}}$ as
\begin{align}
 I(Y; T) - \beta I(X; T) \ge I(Y; T) - n\beta \sum_{i=1}^{n} I(X_i; T_i).    
\end{align}

\subsubsection{Proof of Theorem \ref{thm:bound}}
We first state an easily proven lemma,

\begin{lemma} \label{lem:phi} For any $a, b \in [0,1]$,  \begin{align}
    |a\log(a) - b \log(b)| \le \phi(|a-b|),
\end{align}
where $\phi(\cdot): \R_+ \rightarrow \R_+$ is defined as
\begin{align}
    \phi(x) = 
\begin{cases}
    0              &  x =0 \\
    x \log(\frac{1}{x}) & 0 < x < \frac{1}{e} \\
    \frac{1}{e}     &  x > \frac{1}{e}
\end{cases}.
\end{align}
\end{lemma}

It is easy to verify that $\phi(x)$ is a continuous, monotonically increasing, concave and subadditive function.

Now, we can proceed with the proof of Theorem \ref{thm:bound}.

\begin{proof}
We use the fact that 
\begin{align}
    |I(Y;T) - I(Y;T')| \le |H(T\mid Y) - H(T' \mid Y)  |  + |H(T) - H(T')|
    \label{eq:init}
\end{align}
and bound each of the summands on the right separately.

We can bound the first summand as follows: 
\begin{align}
    & |H(T\mid Y) - H(T'\mid Y)| \le \sum_y p(y) |H(T\mid Y=y) - H(T' \mid Y=y)| \\ 
    &= \sum_y p(y) | \sum_t p(t\mid y) \log(1 / p(t\mid y)) - \sum_t q(t\mid y) \log(1 / q(t\mid y))| \\
    &\le \sum_y p(y) \sum_t |p(t \mid y) \log p(t\mid y) - q(t \mid  y) \log q(t\mid y)| \\
    &\le \sum_y p(y) \sum_t \phi(|p(t\mid y) - q(t \mid y)|) \\
    &= \sum_y p(y) \sum_t \phi(|\sum_x p(t \mid x)[p(x \mid y) -q( x \mid y)]|),
\end{align}
where 
\begin{align}
    p(x \mid y) = \frac{p(y \mid x) p(x)}{\sum_x p(y \mid x)p(x)} \\
    q(x \mid y) = \frac{p(y \mid x) q(x)}{\sum_x p(y \mid x)q(x)}.
\end{align}

Since $\sum_{x \in \mathcal{X} \cup \mathcal{X'}} p(x \mid y) - q(x \mid y) = 0$ for any $y \in \mathcal{Y}$, we have that for any scalar $a$,
\begin{align}
   & |\sum_x p(t \mid x)[p(x \mid y) -q( x \mid y)])| \\
    &=  |\sum_x (p(t \mid x) - a)(p(x \mid y) - q(x \mid y))| \\
    &\le \sqrt{\sum_x (p(t \mid x) -a )^2 } \sqrt{\sum_x (p(x \mid y) - q(x \mid y))^2}.
\end{align}

Setting $a=\frac{1}{|\mathcal{X} - \mathcal{X'}|}\sum_{x \in \mathcal{X} \cup \mathcal{X'}} p(t \mid x)$ we get
\begin{align}
    |H(T \mid Y) - H(T' \mid Y) \le \sum_y p(y) \sum_t \phi\big(\sqrt{V(\mathbf{p}(t \mid x \in \mathcal{X} \cup \mathcal{X'})} \cdot ||\mathbf{p}(x \mid y) - \mathbf{q}(x \mid y)||_2\big),
\end{align}
where for any real-value vector $\mathbf{a} = (a_1,...,a_n)$, $V(\mathbf{a})$ is defined to be proportional to the variance of elements of $\mathbf{a}$:
\begin{align}
    V(\mathbf{a}) = \sum_{i=1}^n(a_i - \frac{1}{n} \sum_{j=1}^n a_j)^2,
\end{align}
$\mathbf{p}(t \mid x \in \mathcal{X} \cup \mathcal{X'})$ stands for the vector in which entries are $p(t \mid x)$ with different values of $x \in \mathcal{X} \cup \mathcal{X'}$ for a fixed $t$, and $\mathbf{p}(x \mid y)$ and $\mathbf{q}(x \mid y)$ are the vectors in which entries are $p(x \mid y)$ and $q(x \mid y)$, respectively, with different values of $x \in \mathcal{X} \cup \mathcal{X'}$ for a fixed $y$.

Since 
\begin{align}
    ||\mathbf{p}(x \mid y) - \mathbf{q}(x \mid y)||_2 \le ||\mathbf{p}(x \mid y) - \mathbf{q}(x \mid y)||_1 \le 2,
\end{align}
it follows that 
\begin{align}
    |\modified{H(T \mid Y)} - H(T' \mid Y) | \le \sum_y p(y) \sum_t \phi\big(2\sqrt{V(\mathbf{p}(t \mid x \in \mathcal{X} \cup \mathcal{X'}))}\big)
\end{align}

Moreover, we have 
\begin{align}
    \sqrt{V(\mathbf{p}(t \mid x \in \mathcal{X} \cup \mathcal{X'})} &\le \sqrt{V(\mathbf{p}(t \mid x \in \mathcal{X})) +   V(\mathbf{p}(t \mid x \in \mathcal{X'}))} \\
    &\le \sqrt{V(\mathbf{p}(t \mid x \in \mathcal{X}))} +  \sqrt{V(\mathbf{p}(t \mid x \in \mathcal{X'}))},
\end{align}
where the rst inequality is because sample mean is the minimizer of the sum of the squared distances to each sample and the second inequality is due to the subadditivity of the square root function.
Using the fact that $\phi(\cdot)$ is monotonically increasing and subadditive, we get
\begin{align}
    |\modified{H(T \mid Y)} - H(T' \mid Y) | &\le \sum_y p(y) \sum_t \phi \big( 2\sqrt{V(\mathbf{p}(t \mid x \in \mathcal{X}))} \big) \nonumber \\
    &+ \sum_y p(y) \sum_t \phi \big( 2\sqrt{V(\mathbf{p}(t \mid x \in \mathcal{X'}))} \big) 
    \label{eq:init1}
\end{align}

Now we explicate the process for establishing the bound for $\sum_y p(y) \sum_t \phi \big( 2\sqrt{V(\mathbf{p}(t \mid x \in \mathcal{X}))} \big)$ and the one for $\sum_y p(y) \sum_t \phi \big( 2\sqrt{V(\mathbf{p}(t \mid x \in \mathcal{X'}))} \big)$ can be similarly derived.

By denition of $V(\cdot)$ and using Bayes' theorem $p(t \mid x) = \frac{p(t)p(x \mid t)}{p(x)}$ for $x \in \mathcal{X}$, we have that
\begin{align}
    \sqrt{V(\mathbf{p}(t \mid x \in \mathcal{X}))} = p(t) \sqrt{ \sum_{x\in \mathcal{X}} \big( \frac{p(x \mid t)}{p(x)} - \frac{1}{|\mathcal{X|}} \sum_{x' \in \mathcal{X}} \frac{p(x' \mid t)}{p(x')} \big)\modified{^2} } \label{eq:Vp}
\end{align}

Denoting $\mathbf{1} = (1,..., 1)$, we have by the triangle inequality that 
\begin{align}
    & \sqrt{ \sum_{x\in \mathcal{X}} \big( \frac{p(x \mid t)}{p(x)} - \frac{1}{|\mathcal{X|}} \sum_{x' \in \mathcal{X}} \frac{p(x' \mid t)}{p(x')} \big)\modified{^2} } \\
    & \le || \frac{\mathbf{p}(x \mid t)}{\mathbf{p}(x)} - \mathbf{1}||_2 + \sqrt{ \sum_{x\in \mathcal{X}} \big( 1 - \frac{1}{|\mathcal{X|}} \sum_{x' \in \mathcal{X}} \frac{p(x' \mid t)}{p(x')} \big)\modified{^2} } \\
    &= || \frac{\mathbf{p}(x \mid t)}{\mathbf{p}(x)} - \mathbf{1}||_2 + \sqrt{ |\mathcal{X}| \big( 1 - \frac{1}{|\mathcal{X|}} \sum_{x' \in \mathcal{X}} \frac{p(x' \mid t)}{p(x')} \big)\modified{^2} } \\
    &= || \frac{\mathbf{p}(x \mid t)}{\mathbf{p}(x)} - \mathbf{1}||_2 + \sqrt{  \frac{1}{|\mathcal{X|}} \big( |\mathcal{X}| - \sum_{x' \in \mathcal{X}} \frac{p(x' \mid t)}{p(x')} \big)\modified{^2} } \\
    &= || \frac{\mathbf{p}(x \mid t)}{\mathbf{p}(x)} - \mathbf{1}||_2 + \frac{1}{\sqrt{|\mathcal{X}|}} | \sum_{x' \in \mathcal{X}} (1 - \frac{p(x' \mid t)}{p(x')} ) | \\
    &\le || \frac{\mathbf{p}(x \mid t)}{\mathbf{p}(x)} - \mathbf{1}||_2 + \frac{1}{\sqrt{|\mathcal{X}|}} || \frac{\mathbf{p}(x \mid t)}{\mathbf{p}(x)} - \mathbf{1}||_1 \\
    &\le ( 1 + \frac{1}{\sqrt{|\mathcal{X}|}}) || \frac{\mathbf{p}(x \mid t)}{\mathbf{p}(x)} - \mathbf{1}||_1 \\
    & \le \frac{2}{\min_{x \in \mathcal{X}} p(x)} || {\mathbf{p}(x \mid t) - \mathbf{p}(x)}||_1 \label{eq:l1_bound}
\end{align}
From an inequality linking KL-divergence and the $l_1$ norm, we have that 
\begin{align}
    ||  {\mathbf{p}(x \mid t) - \mathbf{p}(x)} ||_1  \le \sqrt{2 \log(2) D_{\text{KL}}[ {\mathbf{p}(x \mid t) || \mathbf{p}(x)}] } \label{eq:l1_bound2}
\end{align}
Plugging \modified{Eq.~(\ref{eq:l1_bound2})} into Eq.~(\ref{eq:l1_bound}) and using Eq.~(\ref{eq:Vp}), we have the following bound: 
\begin{align}
    \sqrt{V(\mathbf{p}(t \mid x \in \mathcal{X}))} \le \frac{B}{2} p(t) \sqrt{d_t},
\end{align}
where $B =\frac{4 \sqrt{2\log(2)}}{\min_{x \in \mathcal{X}}p(x)}$ and $d_t = D_{\text{KL}}[ {\mathbf{p}(x \mid t) || \mathbf{p}(x)}].$

We will first proceed the proof under the assumption that $Bp(t) \sqrt{d_t} \le \frac{1}{e}$ for any $t$. We will later see that this condition can be discarded. If $Bp(t) \sqrt{d_t} \le \frac{1}{e},$ then
\begin{align}
     &\sum_t \phi \big( 2\sqrt{V(\mathbf{p}(t \mid x \in \mathcal{X}))} \big)  \\ &\le \sum_t Bp(t) \sqrt{d_t} \big( \log(\frac{1}{B}) + \log(\frac{1}{p(t)d_t}) \big) \\
     &= B \log(\frac{1}{B}) \sum_t p(t) \sqrt{d_t} + B \sum_t p(t) \sqrt{d_t} \log(\frac{1}{p(t)d_t}) \\
     &\le B \log(\frac{1}{B}) ||\mathbf{p}(t) \sqrt{\mathbf{d}_t}||_1 + B ||\sqrt{\mathbf{p}(t)\sqrt{\mathbf{d}_t}}||_1,
\end{align}
where the last inequality is due to an easily proven fact that for any $ x > 0, x\log(\frac{1}{x}) \le \sqrt{x}$. We $\mathbf{p}(t)$ and $\mathbf{d}(t)$ are vectors comprising $p(t)$ and $d_t$ with different values of $t$, respectively.

Using the following two inequalities:
\begin{align}
    ||\mathbf{p}(t) \sqrt{\mathbf{d}_t}||_1 \le \sqrt{|\mathcal{T}|} ||\mathbf{p}(t) \sqrt{\mathbf{d}_t}||_2 \le \sqrt{|\mathcal{T}|} || \sqrt{\mathbf{p}(t) {\mathbf{d}_t}}||_2
\end{align}
and
\begin{align}
    ||\sqrt{\mathbf{p}(t)\sqrt{\mathbf{d}_t}}||_1 &\le \sqrt{|\mathcal{T}|} ||\sqrt{\mathbf{p}(t)\sqrt{\mathbf{d}_t}}||_2 \\
    &= \sqrt{\mathcal{T}}\sqrt{||\mathbf{p}(t)\sqrt{\mathbf{d}_t}||_1} \le |\mathcal{T}|^{3/4}\sqrt{||\sqrt{\mathbf{p}(t) {\mathbf{d}_t}}||_2}
\end{align}
we have 
\begin{align}
     &\sum_t \phi \big( 2\sqrt{V(\mathbf{p}(t \mid x \in \mathcal{X}))} \big)
     &\le B\log(\frac{1}{B}) \sqrt{|\mathcal{T}|} || \sqrt{\mathbf{p}(t) {\mathbf{d}_t}}||_2 + B |\mathcal{T}|^{3/4}\sqrt{||\sqrt{\mathbf{p}(t) {\mathbf{d}_t}}||_2}.
\end{align}

Using the equality
\begin{align}
    || \sqrt{\mathbf{p}(t) {\mathbf{d}_t}}||_2 = \sqrt{\E[D_{\text{KL}[p(x \mid t) || p(x)]}]} = \sqrt{I(X;T)},
\end{align}
we reach the following bound
\begin{align}
    \label{eq:final_bound}
     &\sum_t \phi \big( 2\sqrt{V(\mathbf{p}(t \mid x \in \mathcal{X}))} \big) \\
     &\le  B\log(\frac{1}{B}) |\mathcal{T}|^{1/2} I(X;T)^{1/2}  + B |\mathcal{T}|^{3/4} I(X;T)^{1/4}.
\end{align}

Plug Lemma \ref{lem:local} into the equation above, we have
\begin{align}
       \label{eq:benign_bound}
         &\sum_t \phi \big( 2\sqrt{V(\mathbf{p}(t \mid x \in \mathcal{X}))} \big) \\
     &\le  B\log(\frac{1}{B})|\mathcal{T}|^{1/2} (n\sum_{i=1}^n{I(X_i; T_i)})^{1/2}  + B |\mathcal{T}|^{3/4}(n\sum_{i=1}^n{I(X_i; T_i)})^{1/4} \\
     &\le \sqrt{n}B\log(\frac{1}{B}) |\mathcal{T}|^{1/2} \sum_{i=1}^n I(X_i; T_i)^{1/2} + n^{1/4} B |\mathcal{T}|^{3/4}\sum_{i=1}^n I(X_i; T_i)^{1/4}
\end{align}

We now show the bound is trivial if the assumption that $Bp(t) \sqrt{d_t} \le \frac{1}{e}$ does not hold. If the assumption does not hold, then there exists a $t$ such that $Bp(t) \sqrt{d_t} > \frac{1}{e}$. Since
\begin{align}
    \sqrt{I(X;T)} = \sqrt{\sum_t p(t)d_t} \ge \sum_t p(t)\sqrt{d_t} \ge p(t)\sqrt{d_t}
\end{align}
for any t, we get that $\sqrt{I(X;T)} \ge \frac{1}{eB}.$ Since $|\mathcal{T}| \ge 1$ and $C \ge 0$, we get that our bound in Eq.~(\ref{eq:final_bound}) is at least 
\begin{align}
     & B\log(\frac{1}{B}) |\mathcal{T}|^{1/2} I(X;T)^{1/2}  + B |\mathcal{T}|^{3/4} I(X;T)^{1/4} \\
     &\ge \sqrt{|\mathcal{T}|}(\frac{\log(1/B)}{e} + \frac{B^{1/2} |\mathcal{T}|^{1/4}}{e^{1/2}})
\end{align}

Let $f(c) = \frac{\log(1/c)}{e} + \frac{c^{1/2} |\mathcal{T}|^{1/4}}{e^{1/2}}$. It can be verifed that $f'(c) > 0$ if $c > 0$. Since $B > 4\sqrt{2\log(2)}$ by the definition of $B$, we have $f(B) > f(4\sqrt{2\log(2)}) > 0.746. $ Therefore, we have 
\begin{align}
       & B\log(\frac{1}{B}) |\mathcal{T}|^{1/2} I(X;T)^{1/2}  + B |\mathcal{T}|^{3/4} I(X;T)^{1/4} \\
       & \ge 0.746 \sqrt{|\mathcal{T}|} \ge \log(|\mathcal{T}|)
\end{align}

Therefore, if indeed $Bp(t) \sqrt{d_t} > \frac{1}{e}$ for some $t$, then the bound in Eq.~(\ref{eq:final_bound}) is trivially true, since $H(T \mid Y)$ is within $[0, \log(|\mathcal{T}|)]$.
Similarly, we can establish a bound for $\sum_t \phi \big( 2\sqrt{V(\mathbf{p}(t \mid x \in \mathcal{X'}))} \big)$ as follows:
\begin{align} 
    \label{eq:adv_bound}
      &\sum_t \phi \big( 2\sqrt{V(\mathbf{p}(t \mid x \in \mathcal{X'}))} \big)
      \le \sqrt{n}B'\log(\frac{1}{B'}) |\mathcal{T}|^{1/2} \sum_{i=1}^n I(X_i'; T_i')^{1/2} + n^{1/4} B' |\mathcal{T}|^{3/4}\sum_{i=1}^n I(X_i'; T_i')^{1/4},
\end{align}
where $B' =\frac{4 \sqrt{2\log(2)}}{\min_{x \in \mathcal{X'}}q(x)}.$

Plugging Eq.~(\ref{eq:adv_bound}) and Eq.~(\ref{eq:benign_bound}) into Eq.~(\ref{eq:init1}), we get 
\begin{align}
    \label{eq:final_bound2}
    |H(T \mid Y) - H(T' \mid Y)| \le &\sqrt{n}B\log(\frac{1}{B}) |\mathcal{T}|^{1/2} \sum_{i=1}^n I(X_i; T_i)^{1/2} + n^{1/4} B  |\mathcal{T}|^{3/4}\sum_{i=1}^n I(X_i; T_i)^{1/4} + \nonumber \\ 
    &\sqrt{n}B'\log(\frac{1}{B'}) |\mathcal{T}|^{1/2} \sum_{i=1}^n I(X_i'; T_i')^{1/2} + n^{1/4} B' |\mathcal{T}|^{3/4}\sum_{i=1}^n I(X_i'; T_i')^{1/4} 
\end{align}

Now we turn to the third summand in Eq.~(\ref{eq:init}), we have to bound $|H(T) - H(T')|$.  


Recall the definition of $\epsilon$-bounded adversarial example. We denote the set of the benign data representation $t$ that are within the $\epsilon$-ball of $t'$ by $Q(t')$. Then for any $t \in Q(t')$, we have 
\begin{align}
   ||t'_i - t_i|| \le \epsilon,
\end{align}
for $i=1,2,...,n$. We also denote the number of the $\epsilon$-bounded adversarial examples around the benign representation $t$ by $c(t)$. Then we have the distribution of adversarial representation $t'$ as follows:
\begin{align}
    q(t') = \sum_{t \in Q(t')} \frac{p(t)}{c(t)}
\end{align}


\begin{align}
    \label{eq:init3}
    & |H(T) - H(T')| \\
    & = |\sum_t p(t) \log p(t) - \sum_{t'} q(t') \log q(t')| \\
    & = |\sum_t p(t) \log p(t) - \sum_{t'} \big[ (\sum_{t \in Q(t')} \frac{p(t)}{c(t)} ) \log(\sum_{t \in Q(t')} \frac{p(t)}{c(t)} ) \big] | \\
    & \le |\sum_t p(t) \log p(t) - \sum_{t'} \sum_{t \in Q(t')}  \frac{p(t)}{c(t)} \log(\frac{p(t)}{c(t)}) | \\ 
    & = |\sum_t p(t) \log p(t) - \sum_t c(t) \frac{p(t)}{c(t)} \log(\frac{p(t)}{c(t)}) |  \\
    & = |\sum_t p(t) \log c(t) |,
\end{align}
where the inequality is by log sum inequality. If we denote the $C = \max_t c(t)$ which is the maximum number of $\epsilon$-bounded textual adversarial examples given a benign representation $t$ of a word sequence $x$, we have 
\begin{align}
    & |H(T) - H(T')| \\
    & \le |\sum_t p(t) \log c(t) | \\
    & \le |\sum_t p(t) \log C|  = \log C. \label{eq:final_bound3}
\end{align}
Note that given a word sequence $x$ of $n$ with representation $t$, the number of $\epsilon$-bounded textual adversarial examples $c(t)$ is finite given a finite vocabulary size. Therefore, if each word has at most $k$ candidate word perturbations, then $\log C \le n\log k$ can be viewed as some constants depending only on $n$ and $\epsilon$.

Now, combining Eq.~(\ref{eq:init}), Eq.~(\ref{eq:final_bound2}) and Eq.~(\ref{eq:final_bound3}), we prove the bound in Theorem \ref{thm:bound}.
\end{proof}




 
\end{document}
