
\documentclass{article} \usepackage{iclr2021_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}

\usepackage{graphicx}
\usepackage{wrapfig}
\graphicspath{{figs/}}
\usepackage{multirow}
\usepackage{comment}
\usepackage{algorithm}
\usepackage{listings}
\usepackage{subfig}

\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}{.1em \@plus1ex \@minus.2ex}{-.5em}{\normalfont\normalsize\bfseries}}
\makeatother

\makeatletter
\def\thickhline{\noalign{\ifnum0=`}\fi\hrule \@height \thickarrayrulewidth \futurelet
   \reserved@a\@xthickhline}
\def\@xthickhline{\ifx\reserved@a\thickhline
               \vskip\doublerulesep
               \vskip-\thickarrayrulewidth
             \fi
      \ifnum0=`{\fi}}
\makeatother

\newlength{\thickarrayrulewidth}
\setlength{\thickarrayrulewidth}{2\arrayrulewidth}

\newcommand{\tableCellHeight}{1}
\newcommand{\std}[1]{\tiny{#1}}

\newcommand{\tabstyle}[1]{
  \setlength{\tabcolsep}{#1}
  \renewcommand{\arraystretch}{\tableCellHeight}
  \centering
}


\title{Domain Generalization with MixStyle}



\author{Kaiyang Zhou\textsuperscript{1}, Yongxin Yang\textsuperscript{1}, Yu Qiao\textsuperscript{2}, Tao Xiang\textsuperscript{1} \\
\textsuperscript{1}University of Surrey, UK \\
\textsuperscript{2}Shenzhen Institutes of Advanced Technology, Chinese Academy of Sciences, Shenzhen, China \\
\texttt{k.zhou.vision@gmail.com} \\
\texttt{\{yongxin.yang, t.xiang\}@surrey.ac.uk} \\ \texttt{yu.qiao@siat.ac.cn}
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
Though convolutional neural networks (CNNs) have demonstrated remarkable ability in learning discriminative features, they often generalize poorly to unseen domains. Domain generalization aims to address this problem by learning from a set of source domains a model that is generalizable to any unseen domain. In this paper, a novel approach is proposed based on probabilistically mixing instance-level feature statistics of training samples across source domains. Our method, termed MixStyle, is motivated by the observation that visual domain is closely related to image style (e.g., photo vs.~sketch images). Such style information is captured by the bottom layers of a CNN where our proposed style-mixing takes place. Mixing styles of training instances results in novel domains being synthesized implicitly, which increase the domain diversity of the source domains, and hence the generalizability of the trained model. MixStyle fits into mini-batch training perfectly and is extremely easy to implement. The effectiveness of MixStyle is demonstrated on a wide range of tasks including category classification, instance retrieval and reinforcement learning.
\end{abstract}


\section{Introduction}

Key to automated understanding of digital images is to compute a compact and informative feature representation. Deep convolutional neural networks (CNNs) have demonstrated remarkable ability in representation learning, proven to be effective in many visual recognition tasks, such as classifying photo images into 1,000 categories from ImageNet~\citep{krizhevsky2012imagenet} and playing Atari games with reinforcement learning~\citep{mnih2013playing}. However, it has long been discovered that the success of CNNs heavily relies on the i.i.d.~assumption, i.e.~training and test data should be drawn from the same distribution; when such an assumption is violated even just slightly, as in most real-world application scenarios, severe performance degradation is expected~\citep{hendrycks2019robustness,recht2019imagenet}.

Domain generalization (DG) aims to address such a problem~\citep{zhou2021domain,blanchard2011generalizing,muandet2013domain,li2018learning,zhou2020deep,balaji2018metareg,dou2019domain,cvpr19jigen}. In particular, assuming that multiple source domains containing the same visual classes are available for model training, the goal of DG is to learn models that are robust against data distribution changes across domains, known as domain shift, so that the trained model can generalize well to any unseen domains. Compared to the closely related and more widely studied domain adaptation (DA) problem, DG is much harder in that no target domain data is available for the model to analyze the distribution shift in order to overcome the negative effects. Instead, a DG model must rely on the source domains and focus on learning domain-invariant feature representation in the hope that it would remain discriminative given target domain data.

A straightforward solution to DG is to expose a model with a large variety of source domains. Specifically, the task of learning domain-invariant and thus generalizable feature representation becomes easier when data from more diverse source domains are available for the model. This would reduce the burden on designing special models or learning algorithms for DG. Indeed, model training with large-scale data of diverse domains is behind the success of existing commercial face recognition or vision-based autonomous driving systems. A recent work by~\citet{xu2021how} also emphasizes the importance of diverse training distributions for out-of-distribution generalization. However, collecting data of a large variety of domains is often costly or even impossible. It thus cannot be a general solution to DG.

In this paper, a novel approach is proposed based on probabilistically mixing instance-level feature statistics of training samples across source domains. Our model, termed \emph{MixStyle}, is motivated by the observation that visual domain is closely related to image style. An example is shown in Fig.~\ref{fig:motivation}: the four images from four different domains depict the same semantic concept, i.e.~dog, but with distinctive styles (e.g., characteristics in color and texture). When these images are fed into a deep CNN, which maps the raw pixel values into category labels, such style information is removed at the output. However, recent style transfer studies~\citep{huang2017arbitrary,dumoulin2017learned} suggest that such style information is preserved at the bottom layers of the CNN through the instance-level feature statistics, as shown clearly in Fig.~\ref{fig:tsne_feat_sty}. Importantly, since replacing such statistics would lead to replaced style while preserving the semantic content of the image, it is reasonable to assume that mixing styles from images of different domains would result in images of (mixed) new styles. That is, more diverse domains/styles can be made available for training a more domain-generalizable model. 

Concretely, our MixStyle randomly selects two instances of different domains and adopts a probabilistic convex combination between instance-level feature statistics of bottom CNN layers. In contrast to style transfer work~\citep{huang2017arbitrary,dumoulin2017learned}, no explicit image synthesis is necessary meaning much simpler model design. Moreover, MixStyle perfectly fits into modern mini-batch training. Overall, it is very easy to implement with only few lines of code. To evaluate the effectiveness as well as the general applicability of MixStyle, we conduct extensive experiments on a wide spectrum of datasets covering category classification (Sec.~\ref{sec:experiments:cls}), instance retrieval (Sec.~\ref{sec:experiments:retrieval}), and reinforcement learning (Sec.~\ref{sec:experiments:rl}). The results demonstrate that MixStyle can significantly improve CNNs' cross-domain generalization performance.\footnote{Source code can be found at \texttt{https://github.com/KaiyangZhou/mixstyle-release}.}

\begin{figure}[t]
    \centering
    \includegraphics[width=.8\textwidth]{motivation.pdf}
    \caption{2-D t-SNE~\citep{tsne} visualization of the style statistics (concatenation of mean and standard deviation) computed from the first residual block's feature maps of a ResNet-18 ~\citep{he2016deep} trained on four distinct domains~\citep{li2017deeper}. It is clear that different domains are well separated. }
    \label{fig:motivation}
\end{figure}


\section{Methodology} \label{sec:method}

\subsection{Background} \label{sec:method:bg}
Normalizing feature tensors with instance-specific mean and standard deviation has been found effective for removing image style in style transfer models~\citep{ulyanov2016instance,huang2017arbitrary,dumoulin2017learned}. Such an operation is widely known as instance normalization (IN,~\citet{ulyanov2016instance}). Let  be a batch of tensors, with , ,  and  denoting the dimension of batch, channel, height and width, respectively, IN is formulated as

where  are learnable affine transformation parameters, and  are mean and standard deviation computed across the spatial dimension within each channel of each instance (tensor), i.e.

and


\citet{huang2017arbitrary} introduced adaptive instance normalization (AdaIN), which simply replaces the scale and shift parameters in Eq.~(\ref{eq:instance_norm}) with the feature statistics of style input  to achieve arbitrary style transfer:



\subsection{MixStyle} \label{sec:method:mixstyle}
Our method, MixStyle, draws inspiration from AdaIN. However, rather than attaching a decoder for image generation, MixStyle is designed for the purpose of regularizing CNN training by perturbing the style information of source domain training instances. It can be implemented as a plug-and-play module inserted between CNN layers of, e.g., a supervised CNN classifier, without the need to explicitly generate an image of new style.

\begin{wrapfigure}{r}{.35\textwidth}
\vspace{-.3cm}
\centering
\includegraphics[width=.33\textwidth]{shuffle_batch.pdf}
\caption{A graphical illustration of how a reference batch is generated. Domain label is denoted by color.}
\label{fig:shuffle_batch}
\vspace{-.3cm}
\end{wrapfigure}

More specifically, MixStyle mixes the feature statistics of two instances with a random convex weight to simulate new styles. In terms of implementation, MixStyle can be easily integrated into mini-batch training. Given an input batch , MixStyle first generates a reference batch  from . When domain labels are given,  is sampled from two different domains  and , e.g.,  ( and  have the same batch size). Then,  is obtained by swapping the position of  and , followed by a shuffling operation along the batch dimension applied to each batch, i.e. . See Fig.~\ref{fig:shuffle_batch}(a) for an illustration. In cases where domain labels are unknown,  is randomly sampled from the training data, and  is simply obtained by  (see Fig.~\ref{fig:shuffle_batch}(b)). Fig.~\ref{fig:tsne_feat_sty} shows that sub-domains exist within each domain, so even if two instances of the same domain are sampled, new domain could be synthesized. After shuffling, MixStyle computes the mixed feature statistics by

where  are instance-wise weights sampled from the Beta distribution,  with  being a hyper-parameter. Unless specified otherwise, we set  to 0.1 throughout this paper. Finally, the mixed feature statistics are applied to the style-normalized ,


In practice, we use a probability of 0.5 to decide if MixStyle is activated or not in the forward pass. At test time, no MixStyle is applied. Note that gradients are blocked in the computational graph of  and . MixStyle can be implemented with only few lines of code. See Algorithm~\ref{alg:mixstyle_pytorch} in Appendix~\ref{appx:pseudo_code} for the PyTorch-like pseudo-code.


\section{Experiments} \label{sec:experiments}

\subsection{Generalization in Category Classification} \label{sec:experiments:cls}
\paragraph{Dataset and implementation details.}
We choose the PACS dataset~\citep{li2017deeper}, a commonly used domain generalization (DG) benchmark concerned with domain shift in image classification. PACS consists of four domains, i.e. Art Painting, Cartoon, Photo and Sketch, with totally 9,991 images of 7 classes. As shown in Fig.~\ref{fig:motivation}, the domain shift mainly corresponds to image style changes. For evaluation, a model is trained on three domains and tested on the remaining one. Following prior work~\citep{li2019episodic,zhou2020learning}, we use ResNet-18~\citep{he2016deep} as the classifier where MixStyle is inserted after the 1st, 2nd and 3rd residual blocks. Our code is based on Dassl.pytorch~\citep{zhou2020domain}.\footnote{\texttt{https://github.com/KaiyangZhou/Dassl.pytorch}.}

\paragraph{Baselines.}
Our main baselines are general-purpose regularization methods including Mixup~\citep{zhang2018mixup}, Manifold Mixup~\citep{verma2019manifold}, DropBlock~\citep{ghiasi2018dropblock}, CutMix~\citep{yun2019cutmix} and Cutout~\citep{devries2017improved}, which are trained using the same training parameters as MixStyle and the optimal hyper-parameter setup as reported in their papers. We also compare with the existing DG methods which reported state-of-the-art performance on PACS. These include domain alignment-based CCSA~\citep{motiian2017unified} and MMD-AAE~\citep{li2018mmdaae}, Jigsaw puzzle-based JiGen~\citep{cvpr19jigen}, adversarial gradient-based CrossGrad~\citep{shankar2018generalizing}, meta-learning-based Metareg~\citep{balaji2018metareg} and Epi-FCR~\citep{li2019episodic}, and data augmentation-based L2A-OT~\citep{zhou2020learning}.

\begin{table}[t]
\tabstyle{6pt}
\caption{Leave-one-domain-out generalization results on PACS.}
\label{tab:result_pacs}
\begin{tabular}{l | c c c c c}
\hline
Method & Art & Cartoon & Photo & Sketch & Avg \\
\hline \hline
MMD-AAE & 75.2 & 72.7 & 96.0 & 64.2 & 77.0 \\
CCSA & 80.5 & 76.9 & 93.6 & 66.8 & 79.4 \\
JiGen & 79.4 & 75.3 & 96.0 & 71.6 & 80.5 \\
CrossGrad & 79.8 & 76.8 & 96.0 & 70.2 & 80.7 \\
Epi-FCR & 82.1 & 77.0 & 93.9 & 73.0 & 81.5 \\
Metareg & 83.7 & 77.2 & 95.5 & 70.3 & 81.7 \\
L2A-OT & {83.3} & {78.2} & {96.2} & {73.6} & {82.8} \\
\hline
ResNet-18 & 77.00.6 & 75.90.6 & 96.00.1 & 69.20.6 & 79.5 \\
+ Manifold Mixup & 75.60.7 & 70.10.9 & 93.50.7 & 65.40.6 & 76.2 \\
+ Cutout & 74.90.4 & 74.90.6 & 95.90.3 & 67.70.9 & 78.3 \\
+ CutMix & 74.60.7 & 71.80.6 & 95.60.4 & 65.30.8 & 76.8 \\
+ Mixup (w/o label interpolation) & 74.71.0 & 72.30.9 & 93.00.4 & 69.20.2 & 77.3 \\
+ Mixup & 76.80.7 & 74.90.7 & 95.80.3 & 66.60.7 & 78.5 \\
+ DropBlock & 76.40.7 & 75.40.7 & 95.90.3 & 69.00.3 & 79.2 \\
+ MixStyle w/ random shuffle & {82.3}0.2 & \textbf{79.0}0.3 & \textbf{96.3}0.3 & {73.8}0.9 & {82.8} \\
+ MixStyle w/ domain label & \textbf{84.1}0.4 & 78.80.4 & 96.10.3 & \textbf{75.9}0.9 & \textbf{83.7} \\
\hline
\end{tabular}
\end{table}

\paragraph{Comparison with general-purpose regularization methods.}
The results are shown in Table~\ref{tab:result_pacs}. Overall, we observe that the general-purpose regularization methods do not offer any clear advantage over the vanilla ResNet-18 in this DG task, while MixStyle improves upon the vanilla ResNet-18 with a significant margin. Compared with Mixup, MixStyle is 5.2\% better on average. Recall that Mixup also interpolates the output space, we further compare with a variant of Mixup in order to demonstrate the advantage of mixing style statistics at the feature level over mixing images at the pixel level for DG---following~\citet{sohn2020fixmatch}, we remove the label interpolation in Mixup and sample the mixing weights from a uniform distribution of . Still, MixStyle outperforms this new baseline with a large margin, which justifies our claim. MixStyle and DropBlock share some commonalities in that they are both applied to feature maps at multiple layers, but MixStyle significantly outperforms DropBlock in all test domains. The reason why DropBlock is ineffective here is because dropping out activations mainly encourages a network to mine discriminative patterns, but does not reinforce the ability to cope with unseen styles, which is exactly what MixStyle aims to achieve: by synthesizing ``new'' styles (domains) MixStyle regularizes the network to become more robust to domain shift. In addition, it is interesting to see that on Cartoon and Photo, MixStyle w/ random shuffle obtains slightly better results. The reason might be because there exist sub-domains in a source domain (see Fig.~\ref{fig:tsne_feat_sty}(a-c)), which allow random shuffling to produce more diverse ``new'' domains that lead to a more domain-generalizable model.


\paragraph{Comparison with state-of-the-art DG methods.}
Overall, MixStyle outperforms most DG methods by a clear margin, despite being a much simpler method. The performance of MixStyle w/ domain label is nearly 1\% better on average than the recently introduced L2A-OT. From a data augmentation perspective, MixStyle and L2A-OT share a similar goal---to synthesize data from pseudo-novel domains. MixStyle accomplishes this goal through mixing style statistics at the feature level. Whereas L2A-OT works at the pixel level: it trains an image generator by maximizing the domain difference (measured by optimal transport) between the original and the generated images, which introduces much heavier computational overhead than MixStyle in terms of GPU memory and training time. It is worth noting that MixStyle's domain label-free version is highly competitive: its 82.8\% accuracy is on par with L2A-OT's.


\subsection{Generalization in Instance Retrieval} \label{sec:experiments:retrieval}

\paragraph{Dataset and implementation details.}
We evaluate MixStyle on the person re-identification (re-ID) problem, which aims to match people across disjoint camera views. As each camera view is itself a distinct domain, person re-ID is essentially a cross-domain image matching problem. Instead of using the standard protocol where training and test data come from the same camera views, we adopt the \emph{cross-dataset} setting so test camera views are never seen during training. Specifically, we train a model on one dataset and then test its performance on the other dataset. Two commonly used re-ID datasets are adopted: Market1501~\citep{zheng2015scalable} and Duke~\citep{ristani2016performance,zheng2017unlabeled}. Ranking accuracy and mean average precision (mAP) are used as the performance measures (displayed in percentage). We test MixStyle on two CNN architectures: ResNet-50~\citep{he2016deep} and OSNet~\citep{zhou2019osnet}. The latter was designed specifically for re-ID. In both architectures, MixStyle is inserted after the 1st and 2nd residual blocks. Our code is based on Torchreid~\citep{torchreid}.\footnote{\texttt{https://github.com/KaiyangZhou/deep-person-reid}.}

\paragraph{Baselines.}
We compare with three baseline methods: 1) The vanilla model, which serves as a strong baseline; 2) DropBlock, which was the top-performing competitor in Table~\ref{tab:result_pacs}; 3) RandomErase~\citep{zhong2020random}, a widely used regularization method in the re-ID literature (similar to Cutout).

\paragraph{Results.}
The results are reported in Table~\ref{tab:result_reid}. It is clear that only MixStyle consistently outperforms the strong vanilla model under both settings with considerable margins, while DropBlock and RandomErase are unable to show any benefit. Notably, RandomErase, which simulates occlusion by erasing pixels in random rectangular regions with random values, has been used as a default trick when training re-ID CNNs. However, RandomErase shows a detrimental effect in the cross-dataset re-ID setting. Indeed, similar to DropBlock, randomly erasing pixels offers no guarantee to improve the robustness when it comes to domain shift.

\begin{table}[t]
\tabstyle{6pt}
\caption{Generalization results on the cross-dataset person re-ID task.}
\label{tab:result_reid}
\begin{tabular}{l | c c c c | c c c c}
\hline
\multirow{2}{*}{Model} & \multicolumn{4}{c|}{Market1501Duke} & \multicolumn{4}{c}{DukeMarket1501} \\
& mAP & R1 & R5 & R10 & mAP & R1 & R5 & R10 \\
\hline \hline
ResNet-50 & 19.3 & 35.4	& 50.3 & 56.4 & 20.4 & 45.2 & 63.6 & 70.9 \\
+ RandomErase & 14.3 & 27.8 & 42.6 & 49.1 & 16.1 & 38.5 & 56.8 & 64.5 \\
+ DropBlock & 18.2 & 33.2 & 49.1 & 56.3 & 19.7 & 45.3 & 62.1 & 69.1 \\
+ MixStyle w/ random shuffle & \textbf{23.8} & {42.2} & {58.8} & \textbf{64.8} & {24.1} & {51.5} & {69.4} & {76.2} \\
+ MixStyle w/ domain label & 23.4 & \textbf{43.3} & \textbf{58.9} & 64.7 & \textbf{24.7} & \textbf{53.0} & \textbf{70.9} & \textbf{77.8} \\
\hline
OSNet & 25.9 & 44.7 & 59.6 & 65.4 & 24.0 & 52.2 & 67.5 & 74.7 \\
+ RandomErase & 20.5 & 36.2 & 52.3 & 59.3 & 22.4 & 49.1 & 66.1 & 73.0 \\
+ DropBlock & 23.1 & 41.5 & 56.5 & 62.5 & 21.7 & 48.2 & 65.4 & 71.3 \\
+ MixStyle w/ random shuffle & {27.2} & \textbf{48.2} & \textbf{62.7} & \textbf{68.4} & {27.8} & {58.1} & {74.0} & \textbf{81.0} \\
+ MixStyle w/ domain label & \textbf{27.3} & 47.5 & 62.0 & 67.1 & \textbf{29.0} & \textbf{58.2} & \textbf{74.9} & 80.9 \\
\hline
\end{tabular}
\end{table}


\subsection{Generalization in Reinforcement Learning} \label{sec:experiments:rl}
Though RL has been greatly advanced by using CNNs for feature learning in raw pixels~\citep{mnih2013playing}, it has been widely acknowledged that RL agents often overfit training environments while generalize poorly to unseen environments~\citep{cobbe2019quantifying,igl2019generalization}. 

\paragraph{Dataset and implementation details.}
We conduct experiments on Coinrun~\citep{cobbe2019quantifying}, a recently introduced RL benchmark for evaluating the generalization performance of RL agents. As shown in Fig.~\ref{fig:coinrun_main}(a), the goal in Coinrun is to control a character to collect  golden coins while avoiding both stationary and non-stationary obstacles. We follow~\citet{igl2019generalization} to construct and train our RL agent: the CNN architecture used in IMPALA~\citep{impala2018} is adopted as the policy network, and is trained by the Proximal Policy Optimization (PPO) algorithm~\citep{schulman2017proximal}. Please refer to~\citet{igl2019generalization} for further implementation details. MixStyle is inserted after the 1st and 2nd convolutional sequences. Training data are sampled from 500 levels while test data are drawn from new levels of only the highest difficulty. As domain labels are difficult to define, we use the random shuffle version of MixStyle. Our code is built on top of~\citet{igl2019generalization}.\footnote{\texttt{https://github.com/microsoft/IBAC-SNI}.}


\paragraph{Baselines.}
Following~\citet{igl2019generalization},  we train strong baseline models and add MixStyle on top of them to see whether MixStyle can bring further improvements. To this end, we train two baseline models: 1) Baseline, which combines weight decay and data augmentation;\footnote{We do not use batch normalization~\citep{ioffe2015batch} or dropout~\citep{srivastava2014dropout} because they are detrimental to the performance, as shown by~\citet{igl2019generalization}.} 2) IBAC-SNI (the  version), the best-performing model in~\citet{igl2019generalization} which is based on selective noise injection.


\paragraph{Results.}
The test performance is shown in Fig.~\ref{fig:coinrun_main}(b). Comparing Baseline (blue) with Baseline+MixStyle (orange), we can see that MixStyle brings a significant improvement. Interestingly, the variance is also significantly reduced by using MixStyle, as indicated by the smaller shaded areas (for both orange and red lines). These results strongly demonstrate the effectiveness of MixStyle in enhancing generalization for RL agents. When it comes to the stronger baseline IBAC-SNI (green), MixStyle (red) is able to bring further performance gain, suggesting that MixStyle is complementary to IBAC-SNI. This result also shows the potential of MixStyle as a plug-and-play component to be combined with other advanced RL methods. It is worth noting that Baseline+MixStyle itself is already highly competitive with IBAC-SNI. Fig.~\ref{fig:coinrun_main}(c) shows the generalization gap from which it can been seen that the models trained with MixStyle (orange \& red) clearly generalize faster and better than those without using MixStyle (blue \& green).

\begin{figure}[t]
    \centering
    \includegraphics[width=\textwidth]{coinrun_main.pdf}
    \caption{(a) Coinrun benchmark. (b) Test performance in unseen environments. (c) Difference between training and test performance.}
    \label{fig:coinrun_main}
\end{figure}


\subsection{Analysis} \label{sec:experiments:analysis}

\begin{figure}[t]
    \centering
    \includegraphics[width=\textwidth]{tsne_feat_sty.pdf}
    \caption{2-D visualization of flattened feature maps (top) and the corresponding style statistics (bottom). \texttt{res1-4} denote the four residual blocks in order in a ResNet architecture. We observe that \texttt{res1} to \texttt{res3} contain domain-related information while \texttt{res4} encodes label-related information.}
    \label{fig:tsne_feat_sty}
\end{figure}

\begin{table}[t]
    \tabstyle{5pt}
    \caption{Ablation study on where to apply MixStyle in the ResNet architecture.}
    \label{tab:where_mixstyle}
    \subfloat[Category classification on PACS.]{
        \begin{tabular}{lc}
        \hline
        Model & Accuracy \\
        \hline \hline
        ResNet-18 & 79.5 \\
        + MixStyle (\texttt{res1}) & 80.1 \\
        + MixStyle (\texttt{res12}) & 81.6 \\
        + MixStyle (\texttt{res123}) & \textbf{82.8} \\
        + MixStyle (\texttt{res1234}) & 75.6 \\
        + MixStyle (\texttt{res14}) & 76.3 \\
        + MixStyle (\texttt{res23}) & 81.7 \\
        \hline
        \end{tabular}
    }
    ~
    \subfloat[Cross-dataset person re-ID.]{
        \begin{tabular}{lc}
        \hline
        Model & mAP \\
        \hline \hline
        ResNet-50 & 19.3 \\
        + MixStyle (\texttt{res1}) & 22.6 \\
        + MixStyle (\texttt{res12}) & \textbf{23.8} \\
        + MixStyle (\texttt{res123}) & 22.0 \\
        + MixStyle (\texttt{res1234}) & 10.2 \\
        + MixStyle (\texttt{res14}) & 11.1 \\
        + MixStyle (\texttt{res23}) & 20.6 \\
        \hline
        \end{tabular}
    }
\end{table}

\paragraph{Where to apply MixStyle?}
We repeat the experiments on PACS (category classification) and the re-ID datasets (instance retrieval) using the ResNet architecture. Given that a standard ResNet model has four residual blocks denoted by \texttt{res1-4}, we train different models with MixStyle applied to different layers. For notation, \texttt{res1} means MixStyle is applied after the first residual block; \texttt{res12} means MixStyle is applied after both the first and second residual blocks; and so forth. The results are shown in Table~\ref{tab:where_mixstyle}. We have the following observations. 1) Applying MixStyle to multiple lower-level layers generally achieves a better performance---for instance, \texttt{res12} is better than \texttt{res1} on both tasks. 2) Different tasks favor different combinations---\texttt{res123} achieves the best performance on PACS, while on the re-ID datasets \texttt{res12} is the best. 3) On both tasks, the performance plunges when applying MixStyle to the last residual block. This makes sense because \texttt{res4} is the closest to the prediction layer and tends to capture semantic content (i.e.~label-sensitive) information rather than style. In particular, \texttt{res4} is followed by an average-pooling layer, which essentially forwards the mean vector to the prediction layer and thus forces the mean vector to capture label-related information. As a consequence, mixing the statistics at \texttt{res4} breaks the inherent label space. This is clearer in Fig.~\ref{fig:tsne_feat_sty}: the features and style statistics in \texttt{res1-3} exhibit clustering patterns based on domains while those in \texttt{res4} have a high correlation with class labels.
\vspace{1em}

\begin{wraptable}{r}{.3\textwidth}
\vspace{-.5cm}
\tabstyle{5pt}
\caption{Mixing vs.~replacing.}
\label{tab:mix_vs_replace}
\begin{tabular}{lc}
\hline
 & Accuracy (\%) \\
\hline \hline
Mixing & \textbf{82.8}0.4 \\
Replacing & 82.10.5 \\
\hline
\end{tabular}
\vspace{-.5cm}
\end{wraptable}


\paragraph{Mixing vs.~replacing.}
Unlike the AdaIN formulation, which completely replaces one style with the other, MixStyle mixes two styles via a convex combination. Table~\ref{tab:mix_vs_replace} shows that mixing is better than replacing. This is easy to understand: mixing diversifies the styles (imagine an interpolation between two data points).

\begin{wraptable}{r}{.3\textwidth}
\vspace{-.5cm}
\tabstyle{5pt}
\caption{Random vs.~fixed shuffle at multiple layers.}
\label{tab:random_vs_fixed_shuffle}
\begin{tabular}{lc}
\hline
 & Accuracy (\%) \\
\hline \hline
Random & \textbf{82.8}0.4 \\
Fixed & 82.40.5 \\
\hline
\end{tabular}
\vspace{-.5cm}
\end{wraptable}

\paragraph{Random vs.~fixed shuffle at multiple layers.}
Applying MixStyle to multiple layers, which has been shown advantageous in Table~\ref{tab:where_mixstyle}, raises another question of whether to shuffle the mini-batch at different layers or use the same shuffled order for all layers. Table~\ref{tab:random_vs_fixed_shuffle} suggests that using random shuffle at different layers gives a better performance, which may be attributed to the increased noise level that gives a better regularization effect.

\paragraph{Sensitivity of hyper-parameter.}
Recall that  is used to control the shape of Beta distribution, which has a direct effect on how the convex weights  are sampled. The smaller  is, the more likely the value in  is close to the extreme value of 0 or 1. In other words, a smaller  favors the style statistics in Eqs.~(\ref{eq:mix_gamma}) \&~(\ref{eq:mix_jeta}) to be dominated by one side. We first evaluate  on PACS. Fig.~\ref{fig:ablation_alpha}(a) shows that with  increasing from 0.1 to 0.4, the accuracy slides from 82.8\% to 81.7\%. However, further increasing  does not impact on the accuracy. Therefore, the results suggest that the performance is not too sensitive to ; and selecting  from  seems to be a good starting point. We further experiment with  on the re-ID datasets and the Coinrun benchmark. Figs.~\ref{fig:ablation_alpha}(b) \& (c) show that in general the variance for the results of different values is small. Therefore, we suggest practitioners to choose  from , with  being a good default setting.

\begin{figure}[t]
    \centering
    \includegraphics[width=\textwidth]{ablation_alpha.pdf}
    \caption{Evaluation on the hyper-parameter  on (a) PACS, (b) person re-ID datasets and (c) Coinrun. In (b), M and D denote Market1501 and Duke respectively.}
    \label{fig:ablation_alpha}
\end{figure}

For more analyses and discussions, please see Appendix~\ref{appx:further_analysis}.


\section{Related Work}
\paragraph{Domain generalization,}
or DG, studies out-of-distribution (OOD) generalization given only source data typically composed of multiple related but distinct domains. We refer readers to~\citet{zhou2021domain} for a comprehensive survey in this topic. Many DG methods are based on the idea of aligning features between different sources, with a hope that the model can be invariant to domain shift given unseen data. For instance, \citet{li2018mmdaae} achieved distribution alignment in the hidden representation of an autoencoder using maximum mean discrepancy; \citet{li2018ciddg} resorted to adversarial learning with auxiliary domain classifiers to learn features that are domain-agnostic. Some works explored domain-specific parameterization, such as domain-specific weight matrices~\citep{li2017deeper} and domain-specific BN~\citep{seo2020learning}. Recently, meta-learning has drawn increasing attention from the DG community~\citep{li2018learning,balaji2018metareg,dou2019domain}. The main idea is to expose a model to domain shift during training by using pseudo-train and pseudo-test domains, both drawn from source domains. Data augmentation has also been investigated for learning domain-invariant models. \citet{shankar2018generalizing} introduced a cross-gradient training method (CrossGrad) where source data are augmented by adversarial gradients obtained from a domain classifier. \citet{gong2018dlow} proposed DLOW (for the DA problem), which models intermediate domains between source and target via a domainness factor and learns an image translation model to generate intermediate-domain images. Very recently, \citet{zhou2020learning} introduced L2A-OT to learn a neural network to map source data to pseudo-novel domains by maximizing an optimal transport-based distance measure. Our MixStyle is related to DLOW and L2A-OT in its efforts to synthesizing novel domains. However, MixStyle differs in the fact that it is done implicitly with a much simpler formulation leveraging the feature-level style statistics and only few lines of extra code on top of a standard supervised classifier while being more effective. Essentially, MixStyle can be seen as \emph{feature}-level augmentation, which is clearly different from the \emph{image}-level augmentation-based DLOW and L2A-OT.

\paragraph{Generalization in deep RL}
has been a challenging problem where RL agents often overfit training environments, and as a result, perform poorly in unseen environments with different visual patterns or levels~\citep{zhang2018study}. A natural way to improve generalization, which has been shown effective in~\citep{cobbe2019quantifying,farebrother2018generalization}, is to use regularization, e.g., weight decay. However, \citet{igl2019generalization} suggested that stochastic regularization methods like dropout and batch normalization (which uses estimated population statistics) have adverse effect as the training data in RL are essentially model-dependent. As such, they proposed selective noise injection (SNI), which basically combines a stochastic regularization technique with its deterministic counterpart. They further integrated SNI with information bottleneck actor critic (IBAC-SNI) to reduce the variance in gradients. Curriculum learning has been investigated in~\citep{justesen2018illuminating} where the level of training episodes progresses from easy to difficult over the course of training. \citet{gamrian2019transfer} leveraged the advances in GAN-based image-to-image translation~\citep{liu2017unsupervised} to map target data to the source domain which the agent was trained on. \citet{tobin2017domain} introduced domain randomization, which diversifies training data by rendering images with different visual effects via a programmable simulator. With a similar goal of data augmentation, \citet{lee2020network} pre-processed input images with a randomly initialized network. Very recent studies~\citep{laskin2020reinforcement,kostrikov2020image} have shown that it is useful to combine a diverse set of label-preserving transformations, such as rotation, shifting and Cutout. Different from the aforementioned methods, our MixStyle works at the feature level and is orthogonal to most existing methods. For instance, we have shown in Sec.~\ref{sec:experiments:rl} that MixStyle significantly improves upon IBAC-SNI.


\section{Conclusion}
We presented a simple yet effective domain generalization method, termed MixStyle. MixStyle mixes the feature statistics of two instances to synthesize novel domains, which is inspired by the observation in style transfer work that the feature statistics encode style/domain-related information. Extensive experiments covering a wide range of tasks were conducted to demonstrate that MixStyle yields new state-of-the-art on three different tasks.


\subsubsection*{Acknowledgments}
This work was supported in part by the Shanghai Committee of Science and Technology, China (Grant No.~20DZ1100800), in part by the National Natural Science Foundation of China under Grant (61876176, U1713208), the National Key Research and Development Program of China (No.~2020YFC2004800), and in part by the Guangzhou Research Program (201803010066).



\bibliography{iclr2021_conference}
\bibliographystyle{iclr2021_conference}

\clearpage
\appendix
\section{Appendix}


\subsection{Pseudo-Code of MixStyle} \label{appx:pseudo_code}
Algorithm~\ref{alg:mixstyle_pytorch} provides a PyTorch-like pseudo-code.

\begin{algorithm}[h]
\caption{PyTorch-like pseudo-code for MixStyle.}
\label{alg:mixstyle_pytorch}
\definecolor{codeblue}{rgb}{0.25,0.5,0.5}
\lstset{
  backgroundcolor=\color{white},
  basicstyle=\fontsize{7.2pt}{7.2pt}\ttfamily\selectfont,
  columns=fullflexible,
  breaklines=true,
  captionpos=b,
  commentstyle=\fontsize{7.2pt}{7.2pt}\color{codeblue},
  keywordstyle=\fontsize{7.2pt}{7.2pt},
}
\begin{lstlisting}[language=python]
# x: input features of shape (B, C, H, W)
# p: probabillity to apply MixStyle (default: 0.5)
# alpha: hyper-parameter for the Beta distribution (default: 0.1)
# eps: a small value added before square root for numerical stability (default: 1e-6)

if not in training mode:
    return x

if random probability > p:
    return x

B = x.size(0) # batch size

mu = x.mean(dim=[2, 3], keepdim=True) # compute instance mean
var = x.var(dim=[2, 3], keepdim=True) # compute instance variance
sig = (var + eps).sqrt() # compute instance standard deviation
mu, sig = mu.detach(), sig.detach() # block gradients
x_normed = (x - mu) / sig # normalize input

lmda = Beta(alpha, alpha).sample((B, 1, 1, 1)) # sample instance-wise convex weights

if domain label is given:
    # in this case, input x = [x^i, x^j]
    perm = torch.arange(B-1, -1, -1) # inverse index
    perm_j, perm_i = perm.chunk(2) # separate indices
    perm_j = perm_j[torch.randperm(B // 2)] # shuffling
    perm_i = perm_i[torch.randperm(B // 2)] # shuffling
    perm = torch.cat([perm_j, perm_i], 0) # concatenation
else:
    perm = torch.randperm(B) # generate shuffling indices

mu2, sig2 = mu[perm], sig[perm] # shuffling
mu_mix = mu * lmda + mu2 * (1 - lmda) # generate mixed mean
sig_mix = sig * lmda + sig2 * (1 - lmda) # generate mixed standard deviation

return x_normed * sig_mix + mu_mix # denormalize input using the mixed statistics
\end{lstlisting}
\end{algorithm}

\clearpage
\subsection{Further Analysis} \label{appx:further_analysis}

\begin{wraptable}{r}{.5\textwidth}
\tabstyle{3pt}
\caption{Investigation on the effect of mixing styles between same-domain instances.}
\label{tab:mixstyle_samedom_instance}
\begin{tabular}{lc}
\hline
 & Accuracy (\%) \\
\hline \hline
ResNet18 & 79.5 \\
+ MixStyle w/ same-domain & 80.4 \\
+ MixStyle w/ random shuffle & {82.8} \\
+ MixStyle w/ domain label & \textbf{83.7} \\
\hline
\end{tabular}
\end{wraptable}

\paragraph{MixStyle between same-domain instances.}
We are interested in knowing if mixing styles between same-domain instances helps performance. To this end, we sample each mini-batch from a single domain during training when using MixStyle. The results are shown in Table~\ref{tab:mixstyle_samedom_instance} where we observe that mixing styles between same-domain instances is about 1\% better than the baseline model. This suggests that instance-specific style exists. Nonetheless, the performance is clearly worse than mixing styles between instances of different domains.

\paragraph{Performance on source domains.}
To prove that MixStyle does not sacrifice the performance on seen domains in exchange for gains on unseen domains, we report the test accuracy on the held-out validation set of the source domains on PACS in Table~\ref{tab:test_src_domain}.

\begin{table}[t]
\tabstyle{6pt}
\caption{Test results on the source domains on PACS. A: Art. C: Cartoon. P: Photo. S: Sketch.}
\label{tab:test_src_domain}
\begin{tabular}{l | c c c c | c}
\hline
Method & C,P,S & A,P,S & A,C,S & A,C,P & Avg \\
\hline \hline
Vanilla & 99.490.03 & 99.470.04 & 99.380.02 & 99.650.03 & 99.50 \\
MixStyle & \textbf{99.55}0.02 & \textbf{99.54}0.01 & \textbf{99.47}0.03 & \textbf{99.68}0.03 & \textbf{99.56} \\
\hline
\end{tabular}
\end{table}


\paragraph{Results on Digits-DG and Office-Home.}
In addition to the experiments on PACS (in Sec.~\ref{sec:experiments:cls}), we further evaluate MixStyle's effectiveness on two DG datasets, namely Digits-DG~\citep{zhou2020learning} and Office-Home~\citep{office_home}. Digits-DG contains four digit datasets (domains) including MNIST~\citep{lecun1998mnist}, MNIST-M~\citep{ganin2015unsupervised}, SVHN~\citep{netzer2011svhn} and SYN~\citep{ganin2015unsupervised}. Images from different digit datasets differ drastically in font style, stroke color and background. Office-Home is composed of four domains (Artistic, Clipart, Product and Real World) with around 15,500 images of 65 classes for home and office object recognition. The results are shown in Tables~\ref{tab:result_digits_dg} and~\ref{tab:result_office_home} where no domain labels are used in MixStyle. Similar to the results on PACS, here we observe that MixStyle also brings clear improvements to the baseline CNN model and outperforms all general-purpose regularization methods on both Digits-DG and Office-Home. Compared with more sophisticated DG methods like L2A-OT, MixStyle's performance is comparable, despite being much simpler to train and consuming much less computing resources.

\begin{table}[t]
\tabstyle{6pt}
\caption{Leave-one-domain-out generalization results on Digits-DG.}
\label{tab:result_digits_dg}
\begin{tabular}{l | c c c c | c}
\hline
Method & MNIST & MNIST-M & SVHN & SYN & Avg \\
\hline \hline
JiGen & 96.5 & 61.4 & 63.7 & 74.0 & 73.9 \\
CCSA & 95.2 & 58.2 & 65.5 & 79.1 & 74.5 \\
MMD-AAE & 96.5 & 58.4 & 65.0 & 78.4 & 74.6 \\
CrossGrad & \textbf{96.7} & 61.1 & 65.3 & 80.2 & 75.8 \\
L2A-OT & \textbf{96.7} & \textbf{63.9} & \textbf{68.6} & \textbf{83.2} & \textbf{78.1} \\
\hline
CNN & 95.80.3 & 58.80.5 & 61.70.5 & 78.60.6 & 73.7 \\
+ Mixup w/o label interpolation & 93.70.6 & 55.21.0 & 61.60.9 & 74.40.8 & 71.2 \\
+ Manifold Mixup & 92.70.4 & 53.10.8 & 64.40.2 & 76.80.5 & 71.7 \\
+ CutMix & 94.90.2 & 50.10.5 & 64.10.9 & 78.10.7 & 71.8 \\
+ Mixup & 94.20.5 & 56.50.8 & 63.30.7 & 76.70.6 & 72.7 \\
+ Cutout & 95.80.4 & 58.40.6 & 61.90.9 & 80.60.5 & 74.1 \\
+ DropBlock & 96.20.1 & 60.50.6 & 64.10.8 & 80.20.6 & 75.3 \\
+ MixStyle (ours) & 96.50.3 & 63.50.8 & 64.70.7 & 81.20.8 & 76.5 \\
\hline
\end{tabular}
\end{table}

\begin{table}[t]
\tabstyle{6pt}
\caption{Leave-one-domain-out generalization results on Office-Home.}
\label{tab:result_office_home}
\begin{tabular}{l | c c c c | c}
\hline
Method & Artistic & Clipart & Product & Real World & Avg \\
\hline \hline
JiGen & 53.0 & 47.5 & 71.5 & 72.8 & 61.2 \\
CCSA & 59.9 & 49.9 & 74.1 & 75.7 & 64.9 \\
MMD-AAE & 56.5 & 47.3 & 72.1 & 74.8 & 62.7 \\
CrossGrad & 58.4 & 49.4 & 73.9 & 75.8 & 64.4 \\
L2A-OT & \textbf{60.6} & 50.1 & \textbf{74.8} & \textbf{77.0} & \textbf{65.6} \\
\hline
ResNet18 & 58.90.3 & 49.40.1 & 74.30.1 & 76.20.2 & 64.7 \\
+ Manifold Mixup & 56.20.4 & 46.30.3 & 73.60.1 & 75.20.2 & 62.8 \\
+ Mixup w/o label interpolation & 57.00.2 & 48.70.2 & 71.40.6 & 74.50.4 & 62.9 \\
+ Cutout & 57.80.2 & 48.10.3 & 73.90.2 & 75.80.3 & 63.9 \\
+ CutMix & 57.90.1 & 48.30.3 & 74.50.1 & 75.60.4 & 64.1 \\
+ DropBlock & 58.00.1 & 48.10.1 & 74.30.3 & 75.90.4 & 64.1 \\
+ Mixup & 58.20.1 & 49.30.2 & 74.70.1 & 76.10.1 & 64.6  \\
+ MixStyle (ours) & 58.70.3 & \textbf{53.4}0.2 & 74.20.1 & 75.90.1 & 65.5 \\
\hline
\end{tabular}
\end{table}






\end{document}
