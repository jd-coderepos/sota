\documentclass{sig-alternate}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage[outdir=./figures/]{epstopdf}
\usepackage{url}
\usepackage{color}
\usepackage{flushend}

\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{enumerate}

\author{Heejin Ahn and Domitilla Del Vecchio}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{problem}{Problem}
\newdef{definition}{Definition}
\newdef{example}{Example}

\graphicspath{{./figures/}}
\begin{document}



\title{Semi-autonomous Intersection Collision Avoidance through Job-shop Scheduling}


\numberofauthors{2}

\author{
\alignauthor
Heejin Ahn\\
       \affaddr{Massachusetts Institute of Technology}\\
       \affaddr{77 Massachusetts Avenue}\\
       \affaddr{Cambridge, MA, 02139}\\
       \email{hjahn@mit.edu}
\alignauthor
Domitilla Del Vecchio\\
       \affaddr{Massachusetts Institute of Technology}\\
       \affaddr{77 Massachusetts Avenue}\\
       \affaddr{Cambridge, MA, 02139}\\
       \email{ddv@mit.edu}
}
\date{23 Oct 2015}


\maketitle
\begin{abstract}
In this paper, we design a supervisor to prevent vehicle collisions at intersections. An intersection is modeled as an area containing multiple conflict points where vehicle paths cross in the future. At every time step, the supervisor determines whether there will be more than one vehicle in the vicinity of a conflict point at the same time. If there is, then an impending collision is detected, and the supervisor overrides the drivers to avoid collision. 
A major challenge in the design of a supervisor as opposed to an autonomous vehicle controller is to verify whether future collisions will occur based on the current drivers choices. This verification problem is particularly hard due to the large number of vehicles often involved in intersection collision, to the multitude of conflict points, and to the vehicles dynamics. In order to solve the verification problem, we translate the problem to a job-shop scheduling problem that yields equivalent answers. The job-shop scheduling problem can, in turn, be transformed into a mixed-integer linear program when the vehicle dynamics are first-order dynamics, and can thus be solved by using a commercial solver. 
\end{abstract}

\category{I.2.8}{Artificial Intelligence}{Problem Solving, Control Methods, and Search}[Control theory, Scheduling]
\category{I.2.9}{ Artificial Intelligence}{Robotics}[Autonomous vehicles]


\terms{Theory, Algorithms}

\keywords{Intersection collision avoidance, multi-vehicle control, supervisory control, collision detection, verification, scheduling}

\section{Introduction}
\begin{figure}[t!]
\centering
\includegraphics[width = \columnwidth]{general_intersection_wo_no}
\caption{General intersection scenario, taken from \cite{MassDOT_2012_Topcrash} to encompass the most dangerous intersections in Massachusetts, USA. This intersection contains forty eight conflict areas (small red circles). The supervisor designed in this paper can prevent collisions at the conflict areas by minimally overriding the vehicles.}
\label{figure:general_intersection}
\end{figure}

In the United States, 33,561 people lost their lives in vehicle crashes in 2012, and 26~\% of them occurred at or near intersections \cite{US_DOT_2012:overview}. This raises the need for improved safety systems that actively prevent collisions at intersections. For example, a centralized controller could be implemented on the infrastructure to coordinate vehicles near an intersection so as to prevent collisions. However, since a large number of vehicles are often involved in intersection collisions and vehicles are dynamic agents, the design of such systems faces challenges in terms of computational complexity. An additional substantial complication is that the system should override the drivers only when their driving will certainly cause a collision. That is, override actions should be minimally restrictive. This allows drivers to be in control of the vehicle unless unable to handle a dangerous situation. This supervisor can also be used as a safety guard for future fully autonomous vehicles driving in complex environment.

In this paper, we design a supervisor, which can be implemented on an infrastructure, communicating with human-driven vehicles near an intersection as shown in Figure~\ref{figure:general_intersection}. The most important and challenging part in the design is to determine whether vehicles' current driving will cause collisions at some future time. This is important because the exact collision detection, called the \textit{verification problem}, makes the supervisor least restrictive. This problem is not scalable with respect to the number of vehicles near an intersection yet their future safety must be verified every  seconds, where  is usually 100 ms \cite{US_plan_2015_2019}. To solve the verification problem in real-time, we formulate a job-shop scheduling problem, and prove that this is equivalent to the former problem. Although the job-shop scheduling problem is NP-hard \cite{garey_computers_1979}, we can solve this problem using a commercial solver by converting it into a mixed-integer linear programming problem. 

Mixed integer programming can handle both discrete and continuous aspects of a system. For example, collision avoidance can be formulated using discrete variables while the dynamic behaviors of vehicles, such as position and speed, are represented by continuous variables. Thus, mixed-integer programming has been employed in various collision avoidance applications such as air traffic control \cite{richards_spacecraft_2002,borrelli_milp_2006,christodoulou_automatic_2006} and multi-robot control \cite{earl_modeling_2002,grotli_path_2011}. Since the decision variables of these works are control inputs, for example, velocity, acceleration, or heading angle, at each time step within a finite time horizon, the discrete-time dynamics of vehicles are considered. As the number of time steps increases, the discretization error is diminished whereas the problem becomes larger and more difficult to solve. Because of this computational complexity, real-time verification is usually not feasible and hence not considered. Moreover, these works are cast in an autonomous framework in which if one input that satisfies the constraints is found, then it is applied. In contrast, in a semi-autonomous framework, such as ours, all admissible inputs need to be examined to determine if at least one feasible input exists.

In collision avoidance confined to an intersection, complexity can be mitigated by exploiting the fact that vehicles tend to follow predetermined paths. Given this, the intersection can be considered as a resource that all vehicles share. In \cite{kowshik_provable_2011, lee_development_2012,campos_cooperative_2014}, vehicles are assigned time slots during which they can be inside the intersection without conflict. Since the decision variables are the times at which each vehicle enters the intersection, the continuous dynamics are employed to compute these times. Notice that this approach considers  decision variables if  is the number of vehicles, whereas the approach in the previous paragraph considers at least  decision variables if  is the number of time steps on a finite time horizon. Because of the significantly smaller number of decision variables, the scheduling approach is computationally more efficient. The above works also assume full autonomy, which is not applicable to the scenarios considered in this paper. A detailed review of autonomous intersection management can be found in \cite{chen_cooperative_2015}.

\begin{figure}[tb!]
\centering
\includegraphics[width=\columnwidth]{3x3}
\caption{Example of three vehicles with three conflict areas. The dashed circle represents the intersection model used in \cite{colombo_efficient_2012,colombo_least_2014}. In this paper, the intersection is modeled as multiple conflict areas as represented by the three shaded circles.}
\label{figure:scenario}
\end{figure}
A semi-autonomous framework with the scheduling approach is considered in \cite{colombo_efficient_2012,colombo_least_2014} by proving the equivalence between the verification problem and the scheduling problem. In these works, the authors design a least restrictive supervisor and restrict their attention to a special intersection scenario where all paths of vehicles intersect at one conflict area as indicated by the dashed region in Figure~\ref{figure:scenario}. While maintaining the same structure of the supervisor as in \cite{colombo_efficient_2012,colombo_least_2014}, we formulate a \textit{job-shop scheduling problem} to account for general scenarios of an intersection, where the paths of vehicles intersect at multiple points as in Figure~\ref{figure:general_intersection}. Considering multiple conflict points enables us to design a less conservative verification problem, but makes it more difficult to translate the problem to a job-shop scheduling problem. In this paper, we prove that our job-shop scheduling problem is equivalent to the verification problem with multiple conflict points. By virtue of this proof, we can solve the verification problem by solving the job-shop scheduling problem, which is computationally tractable. The job-shop scheduling problem is then transformed into a mixed-integer linear programming problem by assuming the single integrator dynamics of vehicles. Although a mixed-integer linear programming problem is NP-hard \cite{garey_computers_1979}, it can be solved by commercial solvers such as CPLEX \cite{Cplex_2009} or Gurobi \cite{Gurobi_2014}.
 
The rest of this paper is organized as follows. In Section~\ref{section:system_definition}, we introduce the intersection model and the dynamic model of vehicles. In Section~\ref{section:problem_statement}, we formally state the verification problem and the supervisor-design problem. The verification problem can be solved by formulating and solving a job-shop scheduling problem, which plays the most important role in the design of the supervisor. We then transform the job-shop scheduling problem into a mixed-integer linear programming problem to solve the job-shop scheduling problem using a commercial solver. These solutions will be given in Section~\ref{section:problem_solution}. We conclude this paper by presenting the results of computer simulations in Section~\ref{section:simulation_results} and conclusions in Section~\ref{section:conclusions}.

\section{System Definition}\label{section:system_definition}

Let us consider  vehicles approaching an intersection. The vehicles follow their predetermined paths, and a point at which at least two of the paths intersect is defined as a \textit{conflict point}. Around a conflict point, we define a \textit{conflict area} to account for the size of vehicles. The intersection is modeled as a set of  conflict areas as in Figures~\ref{figure:general_intersection} and \ref{figure:scenario}. Throughout this paper, vehicles and conflict areas are distinguished by integer indexes  and , respectively. In order to focus only on intersection collision, we assume that there is only one vehicle per road. 

To model the longitudinal dynamics of vehicles, let  be the dynamic state of vehicle . Let  the control input of vehicle . Then, the longitudinal dynamics are as follows:

The output of the system is the position  along the path. Here,  is in a compact set, i.e., . We assume that the output  continuously depends on the input . With abuse of notation, let  denote the input signal as well as the input value in . The input signal  is a function of time defined as .  

Let  denote the state reached after time  with input signal  starting from . Similarly, let  denote the position reached after time  with input signal  starting from . The aggregate state, output, input, and input signal are denoted by , and , respectively.

One of the most important properties of the dynamic model \eqref{equation:dynamics} is the order-preserving property. That is, for  for all , we have  and  for all . We will exploit this property in the design of the supervisor, particularly in formulating the job-shop scheduling problem.
	
\section{Problem Statement}\label{section:problem_statement}

Let  denote the location of conflict area  along the longitudinal path of vehicle . A conflict area is defined around a conflict point such that a collision occurs if more than one vehicle stay in a conflict area at the same time. That is, a collision occurs if  where

This subset of output  is called the \textit{bad set}, and if  for all , we consider the system \textit{safe}.

The verification problem is to determine if collisions at an intersection can be prevented at all future time given an initial state. We formally state this problem using the bad set \eqref{equation:badset} as follows.

\begin{problem}[Verification]\label{problem:verification}
Given , determine if there exists  such that  for all .
\end{problem}	
	
	 
Now, we design a supervisor as follows. Every time , the supervisor receives the measurements of current states of vehicles and drivers' inputs. Based on the measurements, the supervisor determines whether it must override the vehicles at this time step because otherwise there will be no admissible input to avoid collisions at the next time step. This decision can be made by solving the verification problem. 

The supervisor-design problem is formulated as follows.
\begin{problem}[Supervisor-design]\label{problem:supervisor}
	At time , given state  and drivers' input , design a supervisor that satisfies the following specifications.
	\begin{enumerate}[{Spec} 1.]
		\item For time , it returns  if there exists  such that for all   or returns  otherwise. Here,  is defined as the safe input that guarantees the existence of  such that for all ,  \label{specification1}
		\item It is non-blocking, that is,  must exist for any  if  exists.\label{specification2}
	\end{enumerate}
\end{problem}	

In Problem~\ref{problem:supervisor}, Spec~\ref{specification1} guarantees that the supervisor is least restrictive, and Spec~\ref{specification2} guarantees that the supervisor always has an input to override vehicles to ensure safety.

\section{Problem Solution}\label{section:problem_solution}
In this section, we solve the two problems: the verification problem (Problem~\ref{problem:verification}) and the supervisor-design problem (Problem~\ref{problem:supervisor}). As a main result, we formulate a job-shop scheduling problem and prove that this problem is equivalent to Problem~\ref{problem:verification}. Before formulating the job-shop scheduling problem in Section~\ref{section:verification_solution}, we introduce classical job-shop scheduling in Section~\ref{section:classical_job-shop}. In Section~\ref{section:verification_solution}, we also convert the job-shop scheduling problem into a mixed-integer linear programming problem with the assumption of first-order vehicle dynamics. In Section~\ref{section:supervisor}, the supervisor algorithm satisfying the specifications of Problem~\ref{problem:supervisor} is given.

\subsection{Classical job-shop scheduling}\label{section:classical_job-shop}
In classical job-shop scheduling \cite{pinedo_scheduling_2012},  jobs are processed on  machines subject to the constraints that (a) each job has its own prescribed sequence of machines to follow, and (b) each machine can process at most one job at a time. 
This can be represented by a disjunctive graph with a set of nodes  and two sets of arcs  and . Here, the sets are defined as follows.

The arcs in , called the conjunctive arcs, represent the routes of the jobs, and the arcs in , called the disjunctive arcs, connect two operations processed on a same machine. 

Let  denote a set of the first operations of jobs, and  denote a set of the last operations of jobs. If each job has only one operation on its route,  


The scenario in Section~\ref{section:system_definition} can be described in job-shop scheduling by considering vehicles as jobs and conflict areas as machines. For instance, each vehicle in Figure~\ref{figure:scenario} has its own prescribed route. Vehicle 1 crosses conflict area 1 first and then conflict area 3. At most one vehicle can be inside each conflict area at a time, because otherwise collisions occur. The corresponding disjunctive graph is shown in Figure~\ref{figure:disjunctiveGraph}.

\begin{figure}[t]
	\centering
	\includegraphics[width=0.6\columnwidth]{disjunctive_graph_3x3}
	\caption{Disjunctive graph of the example in Figure~\ref{figure:scenario}. The black solid lines are the conjunctive arcs, and the red dotted lines are the disjunctive arcs.}
	\label{figure:disjunctiveGraph}
\end{figure}

\begin{example}
	The disjunctive graph in Figure~\ref{figure:disjunctiveGraph} consists of the set of nodes  and the sets of conjunctive and disjunctive arcs
	respectively. 
	
	The sets of the first and the last operations are 	 and , respectively.
	
\end{example}


In \cite{balas_job_1998}, as a variant of job-shop scheduling, release times and deadlines are considered such that jobs must start after given release times and be finished before given deadlines. The release time  and the deadline  are defined for each job , not for each operation . The process time  is a constant for all operations of job  independent of the machines. Then, the classical job-shop scheduling problem with deadline is formulated as follows.
\begin{problem}[Classical job-shop]\label{problem:classical_jobshop}
	Given the release times , the deadlines , and the process time , determine if there exists the operation starting times  for all  such that
	
\end{problem}

In the next section, a new job-shop scheduling problem similar to Problem~\ref{problem:classical_jobshop} is formulated to solve Problem~\ref{problem:verification}. 


\subsection{Solution of Problem~\ref{problem:verification}}\label{section:verification_solution}


\subsubsection{Job-shop scheduling}\label{section:job-shop}
 In contrast to classical job-shop scheduling, our problem must account for the dynamic model of vehicles \eqref{equation:dynamics}. Thus, process times, release times, and deadlines are not initially given and not constant with operation starting times. Also, they are defined for each operation, that is, depending on the jobs and the machines as follows.

	\begin{figure}[tb!]
	\centering
	\includegraphics[width = \columnwidth]{RDP}
	\caption{Process time, release time, and deadline of vehicle 1 in the example in Figure~\ref{figure:scenario}. The thick blue line represents the position of vehicle 1 on its longitudinal path with the schedules  and . For ,  is a function of  and , while for ,  is a function of  only. Also, for ,  and  are functions of .}
	\label{figure:RDP}
	\end{figure}
	

\begin{definition}\label{definition:job-shop}
	Given initial condition  and schedule , process time  is defined for operation  as follows.
	
	\begin{itemize}
		\item If , for , 
		
		For , set . For , set . If the constraint is not satisfied, set .
		\item If , that is,  such that , for ,
		
		For , set . For , set . If the constraints are not satisfied, set .
	\end{itemize}
\end{definition}
By the above definition, process time  is the earliest time at which vehicle  can exit conflict area .

\begin{definition}
	Given initial condition  and schedule , release time  and deadline  are defined for operation  as follows.
	
	\begin{itemize}
		\item If , for , 
		
		For , set  and .
		\item If , that is,  such that , for ,
		
		For , set  and . If the constraint cannot be satisfied by any , set  and .
	\end{itemize}	
	\end{definition}
	By definition, release time  is the earliest time at which vehicle  can enter conflict area , and deadline  is the latest such time. 
	

	If an intersection is modeled as a single conflict point as in \cite{colombo_efficient_2012,colombo_least_2014}, the process time is defined by \eqref{definition:P_in_L}, and the release time and deadline by \eqref{definition:RD_in_F}. This is because each vehicle has a single operation so that . As for multiple conflict points, we have to include the effect of preceding and succeeding operations in the definition. Notice that the process time  in \eqref{definition:P_notin_L} depends on the schedules  and  where  is the succeeding operation of , and the release time  and deadline  in \eqref{definition:RD_notin_F} depend on  where  is the preceding operation of . An example of these definitions is illustrated in Figure~\ref{figure:RDP}.
	
	
Using the above definitions, we formulate the job-shop scheduling problem as follows.
\begin{problem}[Job-shop Scheduling]\label{problem:job-shop}
Given , determine the existence of a schedule  that satisfies the following constraints.

\end{problem}

Constraint~\eqref{constraint2:BI} implies avoidance of intersection collisions between vehicles  and  by ensuring that vehicle  must exit conflict area  before vehicle  enters it. 


We now prove that Problem~\ref{problem:verification} is equivalent to Problem~\ref{problem:job-shop}. Before this, we introduce the formal definition of the equivalence between two problems, and prove a lemma that relates Constraint~\eqref{constraint1:physical} to the existence of an input  such that  and  for .



\begin{definition}\cite{cormen_introduction_2009}
	An instance  of Problem A is the information required to solve the problem. If  satisfies Problem A, we write ~Problem A. 
	
	Problem A is reducible to Problem B if for any instance  of Problem A, an instance  of Problem B can be constructed in polynomial time, and ~Problem A if and only if ~Problem B. If Problem A is reducible to Problem B, and Problem B is reducible to Problem A, then Problem A is equivalent to Problem B.
\end{definition}
\begin{lemma}\label{lemma:existence_input}
	If  for all  with , there exists  such that  and .
\end{lemma}
\begin{proof}
	By the definitions of  and  in \eqref{definition:RD_in_F}, for the first operation  on the route of vehicle , there exists an input signal  such that . This is because the input space is path-connected, and the output  continuously depends on . Then, for the next operation , that is, , since the constraint in definition \eqref{definition:RD_notin_F} is satisfied by the input signal , there is an input signal  such that . By induction on the sequence of operations, for all , there exists an input signal  such that .
	
	This input signal  satisfies the constraints in the definition of  in \eqref{definition:P_in_L} and \eqref{definition:P_notin_L}. Since there exists at least one input signal that satisfies the constraints, an input signal  exists such that  for all .
\end{proof}
\begin{theorem}\label{theorem:P1_equivalent_P3}
Problem~\ref{problem:verification} is equivalent to Problem~\ref{problem:job-shop}.
\end{theorem}
\begin{proof}
An instance of Problem~\ref{problem:verification} is , where  . 
Notice that an instance of Problem~\ref{problem:job-shop} is , which is identical to an instance of Problem~\ref{problem:verification}. Thus, the construction of an instance takes  time. All we have to show is that given , ~Problem~\ref{problem:verification} if and only if ~Problem~\ref{problem:job-shop}.

Suppose ~Problem~\ref{problem:verification}. Then, there exists  such that  for all . In this proof, we assume . For all , let  and . We will show that  satisfies the constraints in Problem~\ref{problem:job-shop} so that ~Problem~\ref{problem:job-shop}.

By the definitions of  and , we have  (Constraint~\eqref{constraint1:physical}). For all , assume without loss of generality vehicle  enters conflict area  before vehicle . Then we know that at , since , we have . That is, . Since  satisfies all the constraints given in the definitions of , we have . Therefore,  (Constraint~\eqref{constraint2:BI}). 


Suppose ~Problem~\ref{problem:job-shop}. Then, there exists  satisfying the constraints in Problem~\ref{problem:job-shop}. By Lemma~\ref{lemma:existence_input}, there exists  that satisfies  and  for all . In Constraint~\eqref{constraint2:BI}, for all , we have  if . Then, at , we have  while . This implies that any two vehicles never meet inside a conflict area, that is,  for all . 

Therefore, there exists  such that  for all .
\end{proof}

By Theorem~\ref{theorem:P1_equivalent_P3}, we can solve Problem~\ref{problem:verification} by solving Problem~\ref{problem:job-shop}. One may notice that Problem~\ref{problem:job-shop} is similar to the classical job-shop scheduling problem (Problem~\ref{problem:classical_jobshop}) if  and . However, in Problem~\ref{problem:job-shop}, the release times, deadlines, and process times are defined for each operation as functions of the schedules. The fact that they vary depending on the schedules significantly complicates the problem. We thus cannot directly employ the solutions from the scheduling literature. Instead, we have to formulate a mixed-integer linear programming problem, which is proved to yield the equivalent answers to Problem~\ref{problem:job-shop} by assuming that the vehicle dynamics are single integrator dynamics.

\subsubsection{Mixed-integer programming}
Problem~\ref{problem:job-shop} can be transformed into a mixed-integer programming problem, which is an optimization problem subject to equality and inequality constraints in the presence of continuous and discrete variables. Notice that Constraint~\eqref{constraint1:physical} is already an inequality constraint. However, Constraint~\eqref{constraint2:BI} contains a disjunctive constraint, which can be converted into linear inequalities by introducing a binary variable  and using the big- method \cite{grossmann_generalized_2012}. In particular, define 
Also, let  be a large positive constant in . Then Constraint~\eqref{constraint2:BI} can be rewritten as follows:

for  sufficiently larger than  and  for all . If  and , vehicle  crosses conflict area  before vehicle  so that . Then,  is imposed while  is automatically satisfied because of a sufficiently large . Thus, \eqref{constraint:BI_mip} encodes the same constraint as \eqref{constraint2:BI}.

Notice that because  and  are functions of variable , Problem~\ref{problem:job-shop} with Constraint~\eqref{constraint1:physical} and \eqref{constraint:BI_mip} is a general mixed-integer program (MIP). Due to its high complexity, this formulation is usually difficult to solve \cite{bussieck_minlp_2010}. If the constraints can be expressed in a linear function of variables, the problem becomes a mixed-integer linear program (MILP). Although MILP are combinatorial, several algorithmic approaches are available to solve medium to large size application problems \cite{floudas1995nonlinear}.


To this end, we assume that the longitudinal dynamics of vehicles are modeled as a single integrator as follows. For vehicle ,

Notice that the dynamic state  is the position, and the control input  is the speed. Since vehicles do not go in reverse, we let .  

With the first order dynamic model \eqref{equation:single_integrator}, we can transform Problem~\ref{problem:job-shop} into a mixed-integer linear programming problem.
Let us write  so that the constraint that  is automatically satisfied. By defining   corresponds to the time spent inside conflict area , independent of . Then, the variables for the mixed-integer linear programming problem are as follows:
\begin{itemize}
	\item  for , continuous variables,
	\item  for , continuous variables,
	\item  and  for , binary variables.
\end{itemize}
Notice that  for  is excluded from the variables because we can set . This is possible because  by definition~\eqref{definition:P_in_L}, and  the minimum  is most likely to satisfy the problem formulated in the following paragraph.

Given the single integrator dynamics, we formulate the mixed-integer linear programming problem as follows.

\begin{problem}\label{problem:milp}
	Given , determine if there exists a feasible solution subject to the following constraints.
	
\begin{enumerate}[A.]
	\item If , for 
	
	\label{constraint1:firstoperation}
	For , consider .
	\item If , that is  such that ,
	
	\label{constraint2:sequential}
	
	\item If , for ,
	
	\label{constraint3:process}
	For , consider instead . If , the schedule of operation  is not of interest.
	
	\item For all , with a large number ,
	
	\label{constraint4:disjunctive}
\end{enumerate}
\end{problem}

We now prove that this problem yields equivalent answers to the job-shop scheduling problem (Problem~\ref{problem:job-shop}) with the first-order dynamics.

\begin{theorem}\label{theorem:P3_equivalent_P4}
	If the vehicle dynamics \eqref{equation:dynamics} are modeled as \eqref{equation:single_integrator}, Problem~\ref{problem:job-shop} is equivalent to Problem~\ref{problem:milp}.
\end{theorem}
\begin{proof}
	Problem~\ref{problem:job-shop} and Problem~\ref{problem:milp} have an identical instance . Thus, we need to show that ~Problem~\ref{problem:job-shop} if and only if ~Problem~\ref{problem:milp}. We will prove that ~Problem~\ref{problem:job-shop} if ~Problem~\ref{problem:milp}, and ~Problem~\ref{problem:job-shop} if ~Problem~\ref{problem:milp}. 
	
	Suppose ~Problem~\ref{problem:milp}. Then there exist a feasible solution  where , , and . 
	
	For ,  and  by definition \eqref{definition:RD_in_F}. For , that is, , there is the constraint in definition~\eqref{definition:RD_notin_F} that . Thus,  and  are as follows.
	
	The second equalities in both equations result from Constraint \ref{constraint3:process}. Therefore, Constrains \ref{constraint1:firstoperation} and \ref{constraint2:sequential} imply  for all  (Constraint \eqref{constraint1:physical}).
		
	In Constraint \ref{constraint4:disjunctive}, we have  because  is the minimum time to reach . Therefore, we have . Similarly,  (Constraint~\eqref{constraint:BI_mip}).
	
	Thus,  satisfies the constraints in Problem~\ref{problem:job-shop}. That is,  Problem~\ref{problem:job-shop}.

	Suppose ~Problem~\ref{problem:milp}. Notice that if Constraint \ref{constraint3:process} is ignored and let , the problem is always feasible because for  and ,
	 becomes a feasible solution for any . Constraint~\ref{constraint4:disjunctive} is also satisfied because either  or  is always true. We can thus find the maximum process time that is a feasible solution for the problem without Constraint~\ref{constraint3:process}. Since ~Problem~\ref{problem:milp}, this solution violates Constraint~\ref{constraint3:process}. Thus, there is no  for any  such that Constraints \ref{constraint1:firstoperation}, \ref{constraint2:sequential}, and \ref{constraint4:disjunctive} are satisfied. This, in turn, implies that given the definition , there is no  such that the constraints in Problem~\ref{problem:job-shop} are satisfied. Since  is not feasible, neither are  and . Thus,  Problem~\ref{problem:job-shop}.
\end{proof}

We solve Problem~\ref{problem:milp} using CPLEX. The procedure that solves Problem~\ref{problem:milp} given an instance  is referred to as \texttt{Jobshop}. If  Problem~\ref{problem:milp}, that is,  Problem~\ref{problem:verification} by Theorems~\ref{theorem:P1_equivalent_P3} and \ref{theorem:P3_equivalent_P4},  returns . Otherwise, it returns . 

\subsection{Solution of Problem~\ref{problem:supervisor}}\label{section:supervisor}
 The supervisor runs in discrete time with a time step . At time  where , it receives the measurements of the states  and drivers' inputs  of the vehicles near an intersection. By assuming that  is constant for time , we predict a state at the next time step, called a state prediction and denoted by , as follows.

 
 Notice that  determines whether or not collisions can be avoided at all future time given the state prediction. If it returns , then the supervisor allows the vehicles to drive with input  for time . The schedule  and the process time  are used to generate a safe input signal , defined on time . We define a safe input operator  as follows.
 
 where  is the  entry of , and  is the  entry of . This safe input signal is stored for possible uses at the next time step.
 
 If  returns , then the supervisor overrides the vehicles using the safe input signal stored at the previous step, . Since  is defined on time , let  be  restricted to time . The supervisor blocks the drivers' inputs  and returns the safe input  for time  to prevent future collisions.

This procedure is written as an algorithm as follows.
\begin{algorithm}[H]
	\caption{}
	\label{algorithm:supervisor}
	\begin{algorithmic}[1]
		\State \label{algorithm:solve_verification1}
		\If{}
		\State \label{algorithm:1_safe_input}
		\State  for \label{algorithm:1_safe_input2}
		\State \textbf{return} \label{algorithm:doesnot_intervene}
		\Else
		\State \label{algorithm:verification_again}
		\State \label{algorithm:2_safe_input}
		\State \label{algorithm:2_safe_input2}
		\State \textbf{return} \label{algorithm:override}
		\EndIf
	\end{algorithmic}
\end{algorithm}
If , then the supervisor generates and stores the safe input  in lines~\ref{algorithm:1_safe_input}-\ref{algorithm:1_safe_input2}, and does not intervene in line~\ref{algorithm:doesnot_intervene}. If , the supervisor solves the verification problem in line~\ref{algorithm:verification_again} given the state predicted with the safe input . It will be proved in the following theorem that  is always , which implies the non-blocking property of the supervisor. Based on  and , the supervisor generates and stores the safe input  in lines~\ref{algorithm:2_safe_input}-\ref{algorithm:2_safe_input2}, and overrides the vehicles in line~\ref{algorithm:override}.

\begin{theorem}
	Algorithm~\ref{algorithm:supervisor} solves Problem~\ref{problem:supervisor}.
\end{theorem}
\begin{proof}
	To prove that Algorithm~\ref{algorithm:supervisor} is a solution of Problem~\ref{problem:supervisor}, we check if the algorithm satisfies the specifications in Problem~\ref{problem:supervisor}.
	
	Specification~\ref{specification1} is met by the design of the algorithm. If there exists  such that  for all , then  returns \textit{yes}. In this case, the supervisor returns . Otherwise, it returns . The fact that this input makes  return \textit{yes} will be clear in the proof of the non-blocking property. 
	
	To prove the non-blocking property, we use mathematical induction on  where . At , we assume . At , suppose there exists . That is, by definition, there exists  such that  for all . If  returns \textit{yes}, then then there exists  such that  for all  by Problem~\ref{problem:verification}. 
	
	Now at , we want to prove that there exists . Notice that  is either  or . In the former case, let  be  restricted to time , and  be  restricted to time . Then, we have  Thus there exists . Similarly for the latter case, let  be  restricted to time , and  be  restricted to time . Then, we have
	 Thus there exists . Therefore, in any case, there exists a safe input .
	
	If  exists, there exists  for any . The supervisor is thus, non-blocking.
	\end{proof}
	\begin{figure*}[htb!]
	\centering
	\subfigure[Bad set]{	
		\includegraphics[width=0.99\columnwidth]{final_badset}
		\label{figure:badset}}
	\quad
	\subfigure[Capture set]{	
		\includegraphics[width=0.99\columnwidth]{final_captureset_thicker}
		\label{figure:captureset}}
	
	\caption{Position space of the three vehicles in the scenario of Figure~\ref{figure:scenario}. Subfigure (a) shows the bad set defined in \eqref{equation:badset}, and subfigure (b) shows the resulting capture set defined in \eqref{equation:capture_Set}. In (b), the black line is the trajectory of the system, and the blue thick line highlights the positions at times when the supervisor overrides the vehicles. Notice that the supervisor prevents them from entering the capture set, thereby averting collision.}
	\label{figure:3D}
	\end{figure*}


\section{Simulation Results}\label{section:simulation_results}
This section presents simulation results of the supervisor. In particular, considering the intersection scenarios illustrated in Figures~\ref{figure:general_intersection} and \ref{figure:scenario}, we validate that the supervisor prevents impending collisions by minimally overridng vehicles. Also, the simulations illustrate that for a system with a large number of vehicles, the computation time required for the supervisor algorithm (Algorithm~\ref{algorithm:supervisor}) at each step is within the allotted 100 ms.

 We implement Algorithm~\ref{algorithm:supervisor} using MATLAB, in which mixed-integer programming in Problem~\ref{problem:milp} is solved by using CPLEX. To speed up the process of generating the constraints of the problem, MATLAB Coder\texttrademark \cite{Matlab_coder_2015} is used to replace the code written in MATLAB with the C code and compile it into a MATLAB executable function. Simulations are performed on a personal computer, which runs Windows 7 Home Premium and consists of an Intel Core i7-3770s processor at 3.10 GHz and 8 GB random-access memory.

Consider first Figure~\ref{figure:scenario}, in which three vehicles are approaching the intersection containing three conflict points. The parameters used in the simulations are 0.1,  for all , (10,20) for , and  for , where . 

To solve the verification problem (Problem~\ref{problem:verification}), the work in \cite{hafner_cooperative_2013} considers the set of initial states such that no input exists to avoid a collision. This subset of the state space is called the \textit{capture set} and defined as follows.
	
	The capture set resulting from the bad set in Figure~\ref{figure:badset} is shown in Figure~\ref{figure:captureset}.
Given an instance  of Problem~\ref{problem:verification}, ~Problem~\ref{problem:verification} if and only if  by definition. By Theorems~\ref{theorem:P1_equivalent_P3} and \ref{theorem:P3_equivalent_P4}, if , ~Problems~\ref{problem:job-shop} and \ref{problem:milp}.

In Figure~\ref{figure:captureset}, the black line represents the trajectory of the system given an initial condition (-2.8,-3.7,-1.2). When the supervisor overrides the vehicles, the trajectory is shown in blue. The drivers' inputs are set to be  and constant for all  where , so that without override actions of the supervisor, the trajectory would enter the bad set in Figure~\ref{figure:badset}. Notice that the supervisor overrides the vehicles right before the trajectory enters the capture set and makes the trajectory ride on the boundary of the capture set. The drivers regain the control of their vehicles once the dangerous situation is resolved. This confirms that the supervisor is least restrictive because it intervenes only when the state prediction  enters the capture set. The computation of the supervisor algorithm (Algorithm~\ref{algorithm:supervisor}) takes less than 4 ms per iteration in the worst case.


\begin{figure}[htb!]
	\includegraphics[width = \columnwidth]{complexity}
	\caption{Computation time for one iteration of  Algorithm~\ref{algorithm:supervisor} in the worst case with respect to the number of vehicles. }
	\label{figure:complexity}
\end{figure}
We then run Algorithm~\ref{algorithm:supervisor} for the intersection instance shown in Figure~\ref{figure:general_intersection}, which contains twenty vehicles and forty eight conflict points. Then, we inserted additional vehicles per road (far enough so to ensure that rear-end collsions do not occur) to determine how many vehicles the supervisor can handle within the 100 ms. In Figure~\ref{figure:complexity}, the computation time required for one iteration of Algorithm~\ref{algorithm:supervisor} is shown with respect to the number of vehicles. Notice that as the number of vehicles increases, the computation time increases exponentially. Although the problem is not scalable, about twenty five vehicles can be managed by the supervisor within the 100 ms even in the complicated intersection scenario. 

The intersection scenario of Figure~\ref{figure:general_intersection} is created from the top 20 crash intersection locations in the report of the Massachusetts Department of Transportation \cite{MassDOT_2012_Topcrash} such that it can represent each intersection topology by removing or combining its lanes. That is, this intersection scenario consisting of twenty lanes and forty eight conflict points is more complicated than the twenty most dangerous intersections in Massachusetts. If we do not consider rear-end collisions and assume that there is only one vehicle per road, the number of vehicles in typical intersection scenarios usually does not exceed twenty. We can thus conclude that this supervisor is practical for typical intersection scenarios. How accounting for rear-end collisions affects computational complexity will be investigated in future work. It is shown in \cite{colombo_least_2014} that additional vehicles on the same lane increase computational complexity less than those on different lanes due to precedence constraints. Since in Figure~\ref{figure:complexity}, we did not consider these precedence constraints, we expect that the computation time will be lower than that shown in Figure~\ref{figure:complexity}.

\section{Conclusions}\label{section:conclusions}
We have designed a supervisor that overrides human-driven vehicles only when a future collision is detected and has a non-blocking property. To this end, we have formulated the verification problem and the job-shop scheduling problem and proved that they are equivalent. To solve the job-shop scheduling problem, we have converted it into a mixed-integer linear programming problem by assuming the single integrator vehicle dynamics. The computer simulations confirm that the supervisor guarantees safety while overriding vehicles only when a future collision is unavoidable otherwise. Also, the computational studies show that despite the combinatorial complexity of the verification problem, the supervisor can deal with a complicated intersection scenario as in Figure~\ref{figure:general_intersection} within the allotted 100 ms per iteration. 

While this paper considers a general intersection model in terms of conflict areas, the inclusion of rear-end collisions in the scenario makes it more practical. Moreover, to account for more realistic dynamic behaviors of vehicles, a nonlinear second-order model will be considered. In particular, for second-order linear dynamics, the job-shop scheduling problem may be reformulated as a mixed-integer quadratic programming problem. Also, as considered in \cite{bruni_robust_2013,ahn_supervisory_2014,ahn_experimental_2015} in which an intersection is modeled as a single conflict area, measurement and process uncertainty and the presence of unequipped vehicles will be investigated in future work. Undetermined routes of vehicles will also be investigated by considering possible decisions of steering inputs.

\section{Acknowledgments}
The authors would like to thank Alessandro Colombo and Gabriel Campos at Politecnico di Milano for the helpful discussions and suggestions. This work was in part supported by NSF CPS Award No. 1239182.



\bibliographystyle{abbrv}
\bibliography{IEEEabrv} 



\end{document}