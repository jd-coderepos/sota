
\documentclass{article} \usepackage{iclr2022_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}

\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{amssymb} 
\usepackage[multiple]{footmisc} 

\usepackage[toc,page,header]{appendix}
\usepackage{minitoc}
\renewcommand \thepart{}
\renewcommand \partname{}
\setcounter{parttocdepth}{3}

\usepackage{listings}
\lstset{
basicstyle=\tiny\ttfamily,
columns=flexible,
breaklines=true
}

\usepackage{floatrow}
\newfloatcommand{capbtabbox}{table}[][\FBwidth]
\usepackage{blindtext}


\usepackage{xcolor}
\usepackage{totcount}

\setlength{\marginparwidth}{2cm}
\usepackage[disable]{todonotes}

\newcommand{\prompt}[1]{{\footnotesize \textsf{#1}}}
\newcommand{\andrew}[1]{\todo[nolist]{#1 \\ (andrew)}}
\newcommand{\schaerli}[1]{\todo[nolist]{#1 \\ (schaerli)}}
\newcommand{\ekin}[1]{\todo[nolist]{#1 \\ (ekin)}}
\newcommand{\nathan}[1]{\todo[nolist]{#1 \\ (nathan)}}
\newcommand{\xysong}[1]{\todo[nolist]{#1 \\ (xysong)}}
\newcommand{\xinyun}[1]{\todo[nolist]{#1 \\ (xinyun)}}
\newcommand{\olivier}[1]{\todo[nolist]{#1 \\ (olivier)}}
\newcommand{\denny}[1]{\todo[nolist]{#1 \\ (denny)}}
\newcommand{\example}[1]{\begin{itemize} #1 \end{itemize}}
\newcommand{\ex}{\item}
\newcommand{\comment}[1]{}


\title{Compositional Semantic Parsing with Large Language Models}


\author{\0.5ex]
\textsuperscript{1}Google Research
\quad \textsuperscript{2}UMass Amherst CICS
\quad \textsuperscript{3}MIT CSAIL
\quad \textsuperscript{*}Equal contribution
\vspace{-3ex}}

\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy 

\renewcommand*\contentsname{}

\pagestyle{fancy}
\renewcommand{\headrulewidth}{1pt}
\fancypagestyle{firstpage}{\lhead{\begin{picture}(0,0)\put(0,-3){\includegraphics[width=0.2\linewidth]{logo.png}}\end{picture}}
  \rhead{\normalsize{\today}}
}



\begin{document}

\doparttoc \faketableofcontents 

\maketitle

\thispagestyle{firstpage}

\begin{abstract}
Humans can reason compositionally when presented with new tasks.  Previous research shows that appropriate prompting techniques enable large language models (LLMs) to solve artificial compositional generalization tasks such as SCAN. In this work, we identify additional challenges in more realistic semantic parsing tasks with larger vocabulary and refine these prompting techniques to address them. Our best method is based on least-to-most prompting: it decomposes the problem using prompting-based syntactic parsing, then uses this decomposition to select appropriate exemplars and to sequentially generate the semantic parse. This method allows us to set a new state of the art for CFQ while requiring only 1\% of the training data used by traditional approaches. Due to the general nature of our approach, we expect similar efforts will lead to new results in other tasks and domains, especially for knowledge-intensive applications.
\end{abstract}



\section{Introduction}

Compositionality is a key part of human intelligence as it allows us to understand and produce a potentially infinite number of novel combinations of known components~\citep{chomsky1957syntax,Montague1970grammar,lake2017buildingmachines}. In contrast, standard neural sequence models, transformers and recurrent neural networks, often fail to capture the compositional
structure of the problem domain and thus fail to generalize compositionally
\citep{Keysers2020MeasuringCG,Furrer2020CompositionalGI}.

Prior efforts to improve compositional generalization primarily rely on specialized architectures or training procedures \citep{lake2019compositional,xinyun2020neuralsymbolic,nye2020learning,andreas-2020-good,conklin-etal-2021-meta,ekina2021recombine,liu-etal-2021-learning-algebraic}. Although effective, these can be task-specific. Even more general purpose methods that rely on data augmentation are limited in the class of data it can support \citep{shaw2020compositional,qiu-etal-2022-improving}.
Prompting on the other hand is sufficiently flexible and, with recent advancement of large-scale pretrained language models (LLMs), has become an effective and generic approach to address a wide range of language understanding problems \citep{gpt3}. Prompting now performs on-par or better than model finetuning in many cases \citep{Wei2022ChainOT,palm2022,wei2022emergent,kojima2022large,palm2022saycan}, and might be suitable for improving language model performance on compositional generalization.

In particular, recent work \citep{zhou2022leasttomost} found that least-to-most prompting shows a lot of potential for adapting LLMs for compositional generalization, achieving  accuracy on SCAN, a commonly used compositional generalization benchmark. Least-to-most prompting decomposes each problem into a series of subproblems, then sequentially solves one after another. However, SCAN is an artificial task built upon a synthetic language with a tiny vocabulary and is generated from a small set of grammar rules, and it is unclear whether strong results transfer to more realistic tasks that are based on a larger vocabulary and more complicated grammars~\citep{Furrer2020CompositionalGI}.

Additional challenges arise when applying least-to-most prompting to more realistic semantic parsing benchmarks. Among others, they may require information beyond what fits in a single prompt. Also, decomposing a problem is more difficult than with SCAN, exacerbated by constituents that cannot be translated independent of their context.
We address these challenges with \textit{dynamic least-to-most prompting}, a generic refinement of least-to-most prompting that involves the following steps: (1) tree-structured decomposition of natural language inputs through LM-predicted syntactic parsing, (2) use the decomposition to dynamically select exemplars, and (3) linearize the decomposition tree and prompt the model to sequentially generate answers to subproblems. 


We evaluate our approach on two realistic benchmarks that, like SCAN, are designed to measure compositional generalization: CFQ \citep{Keysers2020MeasuringCG} and COGS \citep{kim-linzen-2020-cogs}. On CFQ, our best performing method outperforms previous fully supervised finetuning approaches and achieves a new state-of-the-art accuracy of 95\% (averaged across MCD splits) and thereby reduced the error rate by about 45\% compared to the previous best result while using about 1\% of the training data as candidates for exemplars. On COGS, our approach scores an accuracy of 99.2\% when evaluated on the generalization test set, comparable with strong baselines. We also demonstrate robustness of our approach to exemplar pool size, and when using less than 0.1\% of the training data as exemplars, \textit{dynamic least-to-most prompting} is still competitive with previous approaches.

\section{Background and Motivation \label{sec:background}}

\subsection{Compositional Generalization}

\begin{center}
    \textit{Compositionality is the idea that the meanings of complex expressions are constructed from the meanings of the less complex expressions that are their constituents. ---\cite{fodor2002compositionality}}
\end{center}

Given the knowledge of conceptual primitives and a few combinations, \textit{compositional generalization} is the capability to use and comprehend unseen combinations. SCAN~\citep{Lake2018GeneralizationWS,loula-etal-2018-rearranging} is one of the earliest benchmarks that shows neural sequence models cannot systematically generalize to novel combinations of the primitive items of the language. The benchmark requires the learner to translate simple commands to action sequences, where all commands are generated from a set of 20 grammar rules and use a a vocabulary consisting of about 20 words.

Recent work has achieved perfect generalization accuracy on SCAN by inferring grammar rules in symbolic form~\citep{xinyun2020neuralsymbolic,nye2020learning,liu2020compositional,shaw2020compositional}. Most recently, \citet{zhou2022leasttomost} demonstrate that SCAN can be solved by least-to-most prompting, which leverages a pretrained large language model (LLM) and a prompt consisting of only 14 exemplars, which is less than 0.1\% of the training data used by previous approaches.


\subsection{Least-to-Most Prompting Enables Compositional Generalization}
Least-to-most prompting teaches a language model how to solve a complex problem by reducing it
to a set of easier subproblems. This is done by constructing two types of prompts. The first type of
prompt tells the language model how to decompose a problem into a list of subproblems, while the second
type of prompt describes how to sequentially solve the subproblems.

As an illustration, consider the application of least-to-most prompting to SCAN. The decomposition of the input ``look around right thrice and walk twice'' yields the following subproblems: ``look right'', ``look around right'', ``look around right thrice'', and ``walk twice''. Since SCAN commands are generated by a simple grammar of only 20 rules, this decomposition task can be performed using a prompt consisting of only 8 decomposition exemplars.

This decomposition allows the translation of the original input to be produced sequentially rather than in one step (as would be the case with naive prompting). The first subproblem is translated by passing the language model a prompt context consisting of 14 simple translation exemplars followed by the command ``look right''. The model's answer is then appended to the prompt such that it is used as additional context when translating the next subproblem ``look around right'', etc.

\begin{figure}[h!]
\begin{flushleft}
\small{
    \textbf{Did M1 star M2 , star M3 , and star a art director and editor of M0} \\
    \texttt{SELECT count(*) WHERE \{ ?x0 edited M0 . ?x0 art\_directed M0 .  \\
    \phantom{0000}M1 starred ?x0 . M1 starred M2 . M1 starred M3  \}} 
    \vspace{4mm} \\
    \textbf{What was produced by a art director that M1 and M2 employed} \\
    \texttt{SELECT DISTINCT WHERE \{ ?x0 produced\_by ?x1 . ?x1 a art\_director .  \\
    \phantom{0000}M0 employed ?x1 . M1 employed ?x1  \}}
}
\end{flushleft}
    \caption{An example of semantic parsing problems in CFQ, where the input is a sentence and the output is its formal representation as a SPARQL query.}
    \label{fig:cfq_examples}
\end{figure}


\subsection{Least-to-Most Prompting: Limitations and Challenges \label{sec:l2m_challenges}}

While the performance of least-to-most prompting on SCAN is impressive, it is not clear whether and how the same technique can be applied to compositional generalization problems that are based on a more realistic subset of natural language. In particular, we identified three challenges that are common for more realistic natural language tasks and need to be addressed in order to apply least-to-most prompting: (1) decomposition is more challenging, (2) the knowledge required for translation may be too large to fit into a single prompt, and (3) translation of constituents is context-dependent.

As we consider extending least-to-most to the more realistic data setting, we have two semantic parsing benchmarks in mind: 
CFQ~\citep{Keysers2020MeasuringCG} and COGS~\citep{kim-linzen-2020-cogs}.

CFQ is a compositional semantic parsing task where natural language questions need to be translated into SPARQL commands. Compared to SCAN, CFQ is based on a much larger vocabulary as well as more complex linguistic structures produced by a unification-based grammar \citep{shieber2003introduction}. As a result, CFQ has proven to be quite challenging for generic ML architectures such as transformers and LSTMs. Even with custom architectures, the best generalization accuracy is less than 91\%, achieved by specialized architectures for compositional grammar learning~\citep{liu-etal-2021-learning-algebraic}

COGS is another semantic parsing tasks where natural language sentences need to be translated into a formal representation. As for CFQ and SCAN, the training data for COGS contains multiple systematic gaps that can only be addressed by compositional generalization; these include new combinations of familiar syntactic structures and familiar structures. While COGS proves to be quite challenging for generic ML architectures, the best specialized models achieve 99.7\% accuracy \citep{qiu-etal-2022-improving}. 


\paragraph{Natural Language is Challenging to Decompose}
SCAN commands are constructed from  eight distinct symbols with a fixed precedence (``left'', ``right'', ``twice'', ``thrice'', ``opposite'', ``around'', ``and'', and ``after''). Roughly, the decomposition of a SCAN statement resembles that of a mathematical expression with standard arithmetic operations. In practice, the decomposition for SCAN can be predicted by a language model using a simple prompt.

CFQ and COGS sentences represent a richer subset of natural language, meaning the various components and their interactions involve grammatical features such as different parts of speech, grammatical voice, conjunctions, and pronouns. This makes decomposition much more challenging as it requires deep understanding of the underlying linguistic structures.


\paragraph{Single Prompt Insufficient to Represent Full Label Space}
In the case of SCAN, the knowledge needed to translate a command into a sequence of actions is small enough that it can be captured with about a dozen examples. This is not the case for more realistic semantic parsing problems. For example, CFQ uses more than 50 different Freebase types and relations and we cannot really expect the model to know the names of those relations without seeing them used in examples. Similarly, COGS uses hundreds of verbs, and their translation depends on details such as whether or not a verb is unaccusative or unergative, which are difficult or impossible to determine without seeing corresponding translation examples.

\paragraph{Constituent Translation is Context-Dependent}
Least-to-most prompting has only been applied to domains where constituents can be translated independent of their context.
The context-free nature of those tasks enables smooth derivation of a final output from the solutions to the subproblems.
As an illustration of the context-free nature of SCAN, consider the expression ``walk twice'', which always translates to ``WALK WALK''. The constituents in CFQ can not be translated independent of their context. This is exemplified by the two sentences in Figure~\ref{fig:cfq_examples}. In one, the expression ``a art director'' translates to ``?x0 art\_directed M0'', but translates to ``?x1 a art\_director'' in the other.

As we will detail in the next section, this means that we cannot use the traditional approach for least-to-most prompting, where we first ask the model to translate each subproblem in isolation. Instead, we need to make sure that the subproblems are provided to the model with enough context.


\section{Dynamic Least-to-most Prompting \label{sec:dynamic_l2m}}
In this section, we introduce \textit{dynamic least-to-most prompting}, which is an extension of least to most prompting that allows us to overcome the challenges stated above and consequently apply least-to-most prompting to more realistic natural language tasks.

We start by giving a high-level summary of this approach, which is outlined in Figure~\ref{fig:dynamic_l2m}.

\begin{enumerate}
    \item \textbf{Decomposition using LM-based syntactic parsing.} We use a series of prompts to teach the language model to perform a syntactic parse of all possible input sentences. This provides us with a \textit{tree-based decomposition} rather than a linear decomposition obtained by traditional least-to-most prompting.
    
    \item \textbf{Dynamic selection of exemplars based on the decomposition.} We sample a small subset of the training set as a pool of candidate exemplars. For each new input sentence to process, we dynamically select exemplars from this pool such that they collectively demonstrate relevant knowledge needed to translate the input sentences. This is done by matching the decomposition tree of the input against the decomposition tree of the candidate the exemplars.
    
    \item \textbf{Sequential solution based on the decomposition.} 
    We use the tree-based decomposition of the input sentence to generate a linear sequence of other relevant simpler sentences.
    We then construct a prompt including the dynamically selected exemplars and use it to sequentially predict the solutions for the simpler sentences before generating the final output.
\end{enumerate}

\begin{figure}[t!]
    \centering
    \includegraphics[width=\textwidth]{figures/dynamic_l2m.pdf}
    \caption{Our application of least-to-most is similar to \cite{zhou2022leasttomost} with the differences that we obtain the ``problem reduction'' via a multi-step syntactic parse of the input, and we dynamically select exemplars from a fixed pool such that they collectively demonstrate as many parts of the decomposition as possible. }
    \label{fig:dynamic_l2m}
\end{figure}

\subsection{Decomposition using LM-based syntactic parsing}
\label{sec:decomposition}

As discussed in Section~\ref{sec:l2m_challenges}, decomposition is  more challenging for realistic tasks such as CFQ and COGS than for artificial tasks like SCAN. Indeed, while decomposing SCAN commands is similar to decomposing mathematical expressions with standard arithmetic operations, decomposing sentences corresponding to more realistic subsets of natural language essentially becomes a problem of syntactic parsing. We find it natural to decompose problems using a tree structure guided by that syntax (see Figure~\ref{fig:dynamic_l2m_solution}).

To teach LMs to perform decomposition, we divide the syntactic parsing task into multiple steps, such as  subclause identification, noun phrase identification, verb phrase identification, phrase annotation, and verb normalization. For each step, we provide the LM with exemplars that illustrate the task to be performed.\footnote{To better handle compositionality of the input sentences, some prompts may be applied iteratively. For instance, some sentences in COGS have up to 12 nested that-clauses. Therefore, we use a prompt that extracts the outer-most that-clause and apply this prompt until all those clauses are identified.}\footnote{Because of a lack of golden data, we did not directly evaluate  syntactic parsing. However, a manual inspection reveals desirable outputs for both CFQ and COGS, which speaks for the ability of LMs to perform syntactic parsing when the task is broken down into individual steps that are illustrated with appropriate prompts.} See Appendix~\ref{app:cfq_decomposition} and Appendix~\ref{app:cogs_decomposition} for detailed description of the decomposition process and prompts used for CFQ and COGS, respectively.

\begin{figure}[t!]
\includegraphics[width=0.8\textwidth]{figures/syntactic_parse.pdf}
    \caption{Syntactic parse of a CFQ input and its decomposition into subproblems. Like the input, the subproblems are well-formed sentences.}
    \label{fig:dynamic_l2m_solution}
\end{figure}

\subsection{Dynamic exemplar selection}
\label{sec:dynamic_exemplar_selection}

Prompt size is limited, so rather than attempt to represent all relevant knowledge in single prompt, for each input we dynamically select  a set of relevant exemplars from a pre-selected exemplar pool.

\paragraph{Choosing the exemplar pool.}
The exemplar pool is typically a small subset of the available training data. The knowledge required for CFQ is rich and diverse, so we randomly sample 1000 exemplars from the training data for this purpose (separately for each split).
For COGS, including in the exemplar pool translations of as many different verbs and verb phrases is important. Therefore, we selected from the training data one exemplar for each unergative and unaccusative verb as well as 3 examples for each type of verb phrase (e.g., active, passive, with and without recipient, etc.). This resulted in a relatively small exemplar pool consisting of only 89 exemplars (which is used in addition to a static context consisting of 28 exemplars).

\paragraph{Selecting exemplars.}
The goal of exemplar selection is to provide the LLM with the most relevant information needed to process a given input sentence. We do this by making sure that as many nodes as possible of the decomposition tree of the input are covered by the decomposition trees of the selected exemplars. Specifically, we perform the following bottom-up and top-down matching.

\begin{itemize}
    \item \textit{Top-down matching:} 
    We begin by anonymizing the decomposition tree of the input. For instance, the example ``What was produced by a art director that M1 and M2 employed'' is anonymized to ``What V N that M and M V'', where V stands for verb, N for noun, and M for entity. Starting at the top of the anonymized tree, we use a heuristic approach to find exemplars such that all nodes are covered, prioritizing exemplars that match large subtrees.
    
    \item \textit{Bottom-up matching}:
    Then, we try to make sure that all leaf phrases are covered by an exemplar. If there is more than one exemplar for a certain phrase, we prefer exemplars where the phrase occurs within a similar anonymized subtree. For instance, for the phrase ``M1 and M2 employed'' (which anonymizes to ``M and M V''), we would prefer an exemplar containing ``M1 and M2 produced'' over both ``art director employed''  and ``directed by M1 and M2''.
    
\end{itemize}

Depending on its complexity, we select for each input between 4 and 35 exemplars for CFQ and between 1 and 3 exemplars for COGS. Full details of the anonymized tree and our heuristic matching algorithms are in Appendix~\ref{app:cfq_exemplar_selection} for CFQ and Appendix~\ref{app:cogs_exemplar_selection} for COGS.
 
\subsection{Sequential solution}
\label{sec:seq_solution}

This is similar to the solution step for traditional least-to-most prompting. The main difference is we cannot translate the constituents in isolation because they might not be well-formed sentences and their translation  is context-dependent. Instead, we linearize the decomposition tree into a sequence of increasingly complex subproblems and sequentially predict their solutions. 

In Figure 4, we show a barebones snapshot of dynamic least-to-most prompting, immediately before predicting the final output. In previous steps, the model predicted via prompt the solution to the first subproblem, ``What was directed by M3'', then appended the prediction to the prompt before proceeding with, ``What was produced by an art director'', etc. Not displayed in the figure are dynamically selected exemplars, and a fixed list of exemplars we prepend to each prompt.\footnote{In error analysis, we found using a fixed list of basic exemplars greatly improved performance on CFQ (see Appendix~\ref{app:l2m_ablations_error_analysis}). Full prompt details for dynamic least-to-most are in Appendices~\ref{app:cfq_solution} (CFQ) and \ref{app:cogs_solution} (COGS).}

\begin{figure}[t!]
    \centering
    \includegraphics[width=\textwidth]{figures/prompt_design.pdf}
    \caption{Prompt designs for semantic parsing. Chain-of-thought (left) generates intermediate steps before the final output. Dynamic least-to-most (right) first sequentially predicts solutions to subproblems before generating the final output---the subproblems are extracted through a separate prompt.}
    \label{fig:cot}
\end{figure}


\section{Baseline: Prompting without Decomposition \label{sec:cot}}

To demonstrate the effectiveness of dynamic least-to-most prompting, we compare against a strong prompting baseline called chain-of-thought prompting \citep{Wei2022ChainOT}. Chain-of-thought generates intermediate steps before predicting the final answer and has been shown to improve reasoning capabilities of language models.
Unlike least-to-most prompting, chain-of-thought does not have a decomposition step, potentially limiting its effectiveness for compositional generalization tasks. 

\subsection{Chain-of-Thought Prompt Design}

Our chain-of-thought prompt is shown in Figure \ref{fig:cot}. It first categorizes the query, then generates quasi-alignments between the text and output statements. This represents synchronicity in the same spirit as other higher performing semantic parsers do \citep{qiu-etal-2022-improving}, but the intermediate constituents and clauses need not map exactly to what is seen in the input and output. The flexibility of chain-of-thought is convenient for data like CFQ where inclusion of variables is not compatible with synchronous grammar training and inference \citep{wong-mooney-2007-learning}.

\subsection{Dynamically selecting exemplars based on lexical similarity \label{sec:factored_search}}

Since there is no decomposition with chain-of-thought, we rank exemplars by bag-of-words similarity with the current sentence. To reduce redundancy, we select exemplars one by one, and at each iteration prioritize exemplars with relevant words that have not been found yet. This is approach is not deterministic---selecting different exemplars in the first iteration can alter results. In practice, when using chain-of-thought we find it is helpful to sample multiple exemplar lists, then use temperature-based decoding to sample multiple predictions per list, and finally aggregate predictions by plurality vote using self-consistency \citep{wang2022selfconsistency,shi2022codetranslation,li2022diverse}.

\section{Experiments and Results}

\subsection{Data \label{sec:data}}

\paragraph{Datasets.} We empirically measure the effectiveness of prompting on two semantic parsing datasets. CFQ \citep{Keysers2020MeasuringCG} has three maximum compound divergence splits (MCD1, MCD2, MCD3) for measuring compositional generalization, each with 95743/11968/11968 sentences in their train/validation/test splits. COGS \citep{kim-linzen-2020-cogs} has 24155/3000/21000 sentences in their train/validation/generalization splits. 

\paragraph{Exemplar pools.} Also described in Section~\ref{sec:dynamic_exemplar_selection}. For each CFQ split, we sampled 1000 training examples to use as potential exemplars (about 1\% of the training data). For COGS, we manually selected 89 training examples as potential exemplars (about 0.4\% of the training data).


\paragraph{Preprocessing.} For CFQ we replace freebase identifiers with human-readable strings.\footnote{We manually mapped 52 properties to a human-readable form, which took about one hour to complete. This heavily relies on the original ID, and results in properties that are more feasible to predict. For example, mapping \texttt{ns:film.film\_art\_director.films\_art\_directed} to \texttt{art\_directed}.} We also remove clauses that are redundant from a prediction perspective, which always appear alongside the same properties in both train and evaluation data. For COGS we use the variable-free and equivalent outputs introduced by \cite{qiu-etal-2022-improving}. See Appendix~\ref{app:data_prep_eval_hyper} for details.

\paragraph{Evaluation.} We measure accuracy using exact match (EM). This is computed as an exact string match between ground truth and predict labels, and no partial credit is assigned. To make this metric interpretable for CFQ we apply normalization to outputs, including sorting properties and applying a deterministic argument ordering (additional details in Appendix \ref{app:cfq_postprocessing}).\footnote{Any specialized preprocessing and evaluation steps we take for CFQ are tailored for prompting and are not necessary for fully supervised training. In order to verify this, we reproduced experiments with T5-base using our same preprocessing and evaluation. The results match previously published exact match within 1-2 points on MCD1, MCD2, and MCD3. COGS does not require such steps.} For COGS we add any missing closing parentheses at the end of the output before computing EM.

\subsection{Experimental Design Choices \label{sec:modeling}}


The number of exemplars used in dynamic least-to-most varies  based on the complexity of the decomposition tree, as does the number of subproblems. Predictions are made with greedy decoding. Since there is a single final output, no self-consistency is needed.

To improve performance with vanilla few-shot prompts (simple input/output exemplars) and chain-of-thought prompts, we sample  different exemplar lists (each consisting  exemplars), then sample  outputs per list using temperature-based decoding, yielding  outputs that are aggregated with self-consistency.\footnote{Vanilla few-shot and chain-of-thought do worse without self-consistency (see results in Appendix~\ref{app:fair_compare}).}

We use {\small \texttt{code-davinci-002}} hosted by OpenAI for all experiments described in this paper. This is a version of InstructGPT \citep{Ouyang2022TrainingLM} finetuned on code, referred to as Codex.\footnote{At time of use, anyone could sign up for OpenAI access right away, and Codex required an additional sign-up with a short waiting period (around 3-5 days).} 
Hyperparameters are summarized in Appendix~\ref{app:hyperparams}.

\subsection{Results}

\paragraph{CFQ} Our main results are on CFQ test splits and are reported in Table \ref{tab:results_cfq}. Not only does this show that prompting enables compositional generalization on a realistic natural language task, dynamic least-to-most sets a new state of the art (95.0\% accuracy) while only using about 1\% of the training data, whereas traditional approaches are fully supervised. 

\paragraph{COGS} We run experiments on COGS with minimal changes to our approach (Table \ref{tab:cogs_gen}) even though the output space is quite different from CFQ. Dynamic least-to-most prompting scores 99.2\% accuracy (using 0.4\% of the training data), reinforcing the generic nature of our approach.



\begin{table}[t!]
\setlength\tabcolsep{4pt}
\begin{center}
\begin{tabular}{ l | c | c | c | c }
\toprule
 & MCD1 & MCD2 & MCD3 & ~~Ave.~~ \\
\midrule
{\small \bf Fully Supervised} & & & & \\
T5-base \citep{herzig2021unlocking} 
             & 58.5 & 27.0 & 18.4 & 34.6 \\
T5-large \citep{herzig2021unlocking} 
             & 65.1 & 32.3 & 25.4 & 40.9 \\
T5-3B \citep{herzig2021unlocking} 
             & 65.0 & 41.0 & 42.6 & 49.5 \\
HPD \citep{guo2020hierarchical}
             & 79.6 & 59.6 & 67.8 & 69.0 \\
T5-base + IR \citep{herzig2021unlocking} 
             & 85.8 & 64.0 & 53.6 & 67.8 \\
T5-large + IR \citep{herzig2021unlocking} 
             & 88.6 & 79.2 & 72.7 & 80.2 \\
T5-3B + IR \citep{herzig2021unlocking} 
             & 88.4 & 85.3 & 77.9 & 83.9 \\
LeAR \citep{liu-etal-2021-learning-algebraic}
             & 91.7 & 89.2 & 91.7 & 90.9 \\
\midrule
{\small \bf Prompting} & & & & \\
(Ours) Dynamic Least-to-Most
    & \textbf{94.3} & \textbf{95.3} & \textbf{95.5} & \textbf{95.0} \\
\bottomrule
\end{tabular}
\end{center}
\caption{Test accuracy across the MCD splits for the CFQ dataset.}
\label{tab:results_cfq}
\end{table}


\begin{figure}[t!]
\begin{floatrow}
\capbtabbox{\begin{tabular}{ l | c }
\toprule
  & Gen. \\
\midrule
{\small \bf Fully Supervised}   & \\
LeAR \citep{liu-etal-2021-learning-algebraic}
   & 97.7 \\
T5-base \citep{qiu-etal-2022-improving}
   & 89.8 \\
T5-base + CSL \citep{qiu-etal-2022-improving}
   & \textbf{99.5} \\
\midrule
{\small \bf Prompting}  & \\
(Ours) Dynamic Least-to-Most  & 99.2 \\
\bottomrule
\end{tabular}
}{\caption{Accuracy on COGS generalization set. The COGS data is not SQL-like, and has a more diverse lexicon compared with CFQ.}\label{tab:cogs_gen}
}
\ffigbox{\includegraphics[width=0.48\textwidth]{figures/ablate_exemplar_pool_wide.pdf}

}{\caption{Accuracy on a 500-example subset of CFQ. To improve vanilla  and chain-of-thought, we sample multiple exemplar lists and outputs with temperature-based decoding, then apply self-consistency. }
  \label{fig:ablation_pool_size}
}
\end{floatrow}
\end{figure}


\section{Discussion and Analysis}

\paragraph{Is dynamic least-to-most more effective than other prompting methods?} 

In Figure~\ref{fig:ablation_pool_size}, we compare dynamic least-to-most (L2M) with vanilla few-shot prompting and chain-of-thought prompting enhanced with self-consistency. We measure performance on a random 500-sentence subset of CFQ's MCD1 test split. Chain-of-thought (87.2\%) outperforms vanilla (80.8\%) and most baselines when extrapolating to the full data, but dynamic least-to-most (94.4\%) achieves the best result. Additionally, dynamic least-to-most is more than 2x as fast as chain-of-thought despite its sequential nature, since chain-of-thought uses self-consistency across multiple exemplar lists and outputs.

\paragraph{How many exemplars are needed in the pool?} 

Figure~\ref{fig:ablation_pool_size} shows performance as we decrease the size of the exemplar pool. Dynamic least-to-most outperforms other prompts, but performance degrades especially once the exemplar pool contains only 15 exemplars. At this size, each input will basically have the same exemplars and many properties will not be represented at all. The drop in performance is expected since exemplars are randomly chosen. We achieved high performance on COGS with a small exemplar pool (89 instances) by choosing them methodically. 





\paragraph{Why is Codex effective for semantic parsing?} 

We use Codex instead of text-based GPT-3 in our evaluation because of its better performance in our initial experiments, and this observation is also presented in prior works on semantic parsing~\citep{shin-etal-2021-constrained,shin-van-durme-2022-shot}. For pretrained models, leakage of the test data is a potential concern \citep{Krishna2020Thieves,carlini21extracting}. However, given the inferior performance of vanilla few-shot prompting, we attribute success of prompting to in-context learning rather than memorization. Furthermore, least-to-most prompting requires the LM to translate as intermediate steps new subproblems that are guaranteed to be unseen during training.



\section{Related Work}

\paragraph{Compositional generalization} Compositional generalization in machine learning has been a challenging problem that attracts attention across fields, including vision~\citep{johnson2017clevr,bahdanau2019closure,ruis2020benchmark,nikolaus2019compositional} and language domains~\citep{Lake2018GeneralizationWS,Keysers2020MeasuringCG,kim-linzen-2020-cogs,shaw2020compositional,yin-etal-2021-compositional,gan-etal-2022-measuring}. A number of approaches have been proposed to improve compositional generalization on SCAN~\citep{Lake2018GeneralizationWS,loula-etal-2018-rearranging}, including specialized design of neural model architectures ~\citep{xinyun2020neuralsymbolic,nye2020learning,liu2020compositional,shaw2020compositional,russin2019compositional,li2019compositional,gordon2019permutation,herzig2020span} and training algorithms~\citep{lake2019compositional,kim2021sequence}, training data augmentation~\citep{andreas-2020-good,ekina2021recombine}, and prompting~\citep{zhou2022leasttomost}. While  accuracy has been accomplished on SCAN~\citep{xinyun2020neuralsymbolic,nye2020learning,liu2020compositional,shaw2020compositional}, good performance on SCAN does not necessarily transfer to more challenging compositional generalization problems~\citep{Furrer2020CompositionalGI}. Notably, although least-to-most prompting has achieved  accuracy on SCAN~\citep{zhou2022leasttomost}, prior attempts on prompting for semantic parsing still demonstrate limited compositional generalization performance~\citep{Qiu2022EvaluatingTI}. In this work, we propose prompting schemes to bridge this gap.

To improve compositional generalization for semantic parsing, recent works incorporate a latent syntactic component~\citep{qiu-etal-2022-improving,liu-etal-2021-learning-algebraic}. Similarly to symbolic grammar learning techniques on SCAN, these approaches achieve impressive performance on several benchmarks, and represent the previous state of the art on CFQ~\citep{Keysers2020MeasuringCG} and COGS~\citep{kim-linzen-2020-cogs}. Other lines of work improve the performance on CFQ through specialized decoding algorithms, including graph decoding~\citep{gai-etal-2021-grounded-graph} and hierarchical poset decoding~\citep{guo2020hierarchical}. Yet others exploit correlations between the input and output tokens, e.g. through loss functions with attention supervision~\citep{yin-etal-2021-compositional}, using a lexicon \citep{akyurek2021lexicon}, and reformulating the label space~\citep{herzig2021unlocking}. Without relying on specialized model architectures or training algorithms, our results demonstrate generic prompting schemes based on decomposition demonstrate strong results on CFQ and COGS, and achieve state-of-the-art results on CFQ.

\paragraph{Prompting} The most similar work to ours is SeqZero \citep{yang-etal-2022-seqzero}, but there are key differences. SeqZero decomposes semantic parsing into generating three parts separately (SELECT, FROM, and WHERE parts of the output), and further decomposes WHERE into generating each clause separately. 
This means that decomposition is conducted via a fixed, rule-based system. In contrast, 
our decomposition is automatically accomplished by prompting. 
We use the syntactic parse of the sentence to create different related sentences, such as by simplifying conjunctions or removing text fragments. This is more general than SeqZero and it is readily applicable to many natural language tasks. For example, we successfully used our approach 
on COGS even though the output does not resemble SQL. Furthermore, SeqZero is an ensemble of a finetuned BART and a zero-shot model while we use only prompting with large language models and forego finetuning entirely.


\section{Conclusion}

Through dynamic least-to-most prompting, we demonstrate state-of-the-art performance on a difficult natural language semantic parsing benchmark that measures compositional generalization. Our results are achieved using about 1\% of the training data from traditional finetuning approaches. Many machine learning models struggle with compositional generalization, and our findings should facilitate future research that enables this capability through task decomposition. We expect dynamic least-to-most prompting to have immediate impact in a variety of settings. It is flexible and general purpose, enabling quick adaptation to new tasks and domains. Especially for knowledge-intensive applications of language models, where precise semantic parsing can be directly leveraged.



\subsubsection*{Acknowledgments}
We thank Andrew McCallum, Mohit Iyyer, Jacob Andreas, Ed Chi, Quoc Le, Xuezhi Wang, Jason Wei, Mirac Suzgun, Freda Shi for helpful discussion and feedback, and
Najoung Kim for help understanding edge cases in the COGS dataset.
We are grateful to Peter Shaw for sharing their expertise in compositional generalization and their detailed comments on earlier versions of this manuscript.

\subsubsection*{Reproducibility Statement}

Throughout our work we aim to provide exhaustive details about prompt design and exemplar selection, and we include all the prompts we use in the Appendix. To ease future use, we further outline key details related to reproducibility in Appendix~\ref{app:reproduce}.


\bibliography{iclr2022_conference}
\bibliographystyle{iclr2022_conference}

\clearpage
\appendix


\addcontentsline{toc}{section}{Appendix} \part{Appendix} \parttoc 

\clearpage

\begin{figure}[h!]
\begin{flushleft}
\small{
    \textbf{Which film editor was influenced by a cinematographer that wrote M3 , M4 , and M5 and influenced by M1 's editor} \\
    \texttt{SELECT DISTINCT ?x0 WHERE \{ ?x0 a film\_editor . ?x0 influenced\_by ?x1 .\\
    \phantom{0000}?x0 influenced\_by ?x2 . ?x1 edited M1 . ?x2 a cinematographer .\\
    \phantom{0000}?x2 wrote M3 . ?x2 wrote M4 . ?x2 wrote M5 \}}
}
\end{flushleft}
    \caption{A CFQ example, which we use to illustrate the application of dynamic least-to-most prompting to CFQ.}
    \label{fig:cfq_example_e2e}
\end{figure}

\section{Least-to-most Prompting for CFQ}
\label{app:l2m_cfq}

In this section, we provide more details on the application of dynamic least-to-most prompting for CFQ. In particular, we detail all the prompts and show how the example in Figure~\ref{fig:cfq_example_e2e} is processed step by step.

\subsection{CFQ Decomposition: Details and Prompts}
\label{app:cfq_decomposition}
As discussed in Section~\ref{sec:decomposition}, we use prompting-based syntactic parsing to decompose CFQ questions. To teach LMs to perform this kind of decomposition, we divide the syntactic parsing task into the following steps:

\begin{enumerate}
    \item Noun phrase identification
    \item Subclause identification
    \item Verb and other phrase identification
    \item Part-of-speech tagging and phrase labeling
    \item Verb normalization
\end{enumerate}

Consider the question from from Figure~\ref{fig:cfq_example_e2e}.

\example{\ex Which film editor was influenced by a cinematographer that wrote M3 , M4 , and M5 and influenced by M1 's editor}

The first step, noun phrase identification, yields:

\example{\ex Which (film editor) was influenced by (a cinematographer) that wrote (M3 , M4 , and M5) and influenced by (M1 's editor)}

Then, we replace the identified noun phrases with placeholders N1, N2, N3, and N4, which yields:

\example{\ex Which N1 was influenced by N2 that wrote N3 and influenced by N4}

The next step, subclause identification, uses the form with placeholders and yields:

\example{\ex Which N1 was influenced by ((N2) that (wrote N3)) and influenced by N4}

Then we have another round applying placeholders, on the subclause this time:

\example{\ex Which N1 was influenced by N5 and influenced by N4}

The third step is to identify verb phrases and other miscellaneous phrases, which yields:

\example{
\ex (Which) (N1) ((was influenced by N5) and (influenced by N4))
\ex that (wrote N3)
}

As a fourth step, we perform various part-of-speech tagging and phrase labeling. We start with the noun phrases, which yields:

\example{
\ex N=(film editor)
\ex \text{[a]} N=(cinematographer)
\ex M=(M3 , M4 , [and], M5)
\ex M=(M1) P=('s) N=(editor)
}

We continue with verb phrases, which yields:

\example{
\ex W=(Which)
\ex V=([was] influenced by) (N5)
\ex V=(influenced by) (N4)
\ex V=(wrote) (N3)
}

As a fifth step, we normalize all the verbs: ``was'' yields ``be'', ``influenced'' yields ``influence'', and ``wrote'' yields ``write''. Finally, we run a few lines of Python code that puts all these parts back together to obtain a parse tree. Note that the normalized verbs do not replace the original ones but are kept in addition, which allows us to obtain higher recall when selecting exemplars.

This yields the following fully decomposed and annotated question: 

\example{\ex W=(Which) N=(film editor) ((V=([was] influenced by) ([a] N=(cinematographer) that (V=(wrote) N=(M3 , M4 , [and] M5)))) and (V=(influenced by) (M=(M1) P=('s) N=(editor))))}

Below, we present the exact prompt contexts used for each of the parsing steps.

\subsubsection{Step 1: Noun phrase identification}

\prompt{Q: Was M0 's producer a art director 's sibling \\
A: Was (M0 's producer) (a art director 's sibling) \\
 \\
Q: Did M1 influence a French producer and editor 's child 's spouse \\
A: Did (M1) influence (a French producer and editor 's child 's spouse) \\
 \\
Q: Which female French costume designer , producer , and editor of M3 and M4 was M5 's parent \\
A: Which (female French costume designer , producer , and editor of M3 and M4) was (M5 's parent) \\
 \\
Q: Was a Dutch parent and spouse a editor , producer , and writer of a film 's prequel \\
A: Was (a Dutch parent and spouse) (a editor , producer , and writer of a film 's prequel) \\
 \\
Q: Who employed , met , and was influenced by a female film director 's Spanish parent and married M1 \\
A: Who employed , met , and was influenced by (a female film director 's Spanish parent) and married (M1) \\
 \\
Q: Were M3 and M6 executive produced by , written by , and directed by a writer 's spouse , friend , and employer , and produced by a child \\
A: Were (M3 and M6) executive produced by , written by , and directed by (a writer 's spouse , friend , and employer) , and produced by (a child) \\
 \\
Q: What film director and editor of M0 , M1 , and M2 married , divorced , and was kissed by a Spanish editor and producer of M5 \\
A: What (film director and editor of M0 , M1 , and M2) married , divorced , and was kissed by (a Spanish editor and producer of M5) \\
 \\
Q: Which child of a production company did M0 acquire \\
A: Which (child of a production company) did (M0) acquire \\
 \\
Q: Which star of M5 was influenced by a person , influenced by M0 , M1 , M2 , and M3 , and influenced by M4 \\
A: Which (star of M5) was influenced by (a person) , influenced by (M0 , M1 , M2 , and M3) , and influenced by (M4) \\
 \\
Q: Was a screenwriter employed by M1 , M2 , and M3 and employed by M4 , M5 , and M6 M7 's spouse \\
A: Was (a screenwriter) employed by (M1 , M2 , and M3) and employed by (M4 , M5 , and M6) (M7 's spouse) \\
 \\
Q: Was M4 produced by a German screenwriter that M1 and spouse of M2 's sibling were influenced by \\
A: Was (M4) produced by (a German screenwriter) that (M1 and spouse of M2 's sibling) were influenced by \\
 \\
Q: Was M0 M1 's sibling and spouse \\
A: Was (M0) (M1 's sibling and spouse) \\
 \\
Q: Which film did M3 's employer 's Mexican employee produce and M1 direct \\
A: Which (film) did (M3 's employer 's Mexican employee) produce and (M1) direct \\
 \\
Q: Did M3 's parent 's employee influence M0 and M1 and influence M2 's founder and employee \\
A: Did (M3 's parent 's employee) influence (M0 and M1) and influence (M2 's founder and employee) \\
 \\
Q: What male director of M3 and M4 did M0 and M1 influence \\
A: What (male director of M3 and M4) did (M0 and M1) influence \\
 \\
Q: Which female person whose sibling was influenced by M3 and was influenced by M4 and M5 directed M2 \\
A: Which (female person) whose (sibling) was influenced by (M3) and was influenced by (M4 and M5) directed (M2) \\
 \\
Q: Did M0 direct , produce , executive produce , edit , and write M1 , M2 , and M3 \\
A: Did (M0) direct , produce , executive produce , edit , and write (M1 , M2 , and M3) \\
 \\
Q: Was M0 executive produced by , edited by , written by , and directed by M1 , M2 , and M3 \\
A: Was (M0) executive produced by , edited by , written by , and directed by (M1 , M2 , and M3) \\
 \\
Q: Who influenced and was influenced by M1 's female actor 's parent \\
A: Who influenced and was influenced by (M1 's female actor 's parent) \\
 \\
Q: Did M0 's editor , costume designer , star , writer , and art director executive produce and produce M1 \\
A: Did (M0 's editor , costume designer , star , writer , and art director) executive produce and produce (M1) \\
 \\
Q: Which film that was written by M1 M2 directed \\
A: Which (film) that was written by (M1) (M2) directed \\
 \\
Q: Which director of M3 , M4 , and M5 was a Japanese screenwriter that M1 employed and was founded by \\
A: Which (director of M3 , M4 , and M5) was (a Japanese screenwriter) that (M1) employed and was founded by \\
 \\
Q: Did M1 's executive producer employ M2 , edit M3 , employ a film director , and employ M4 \\
A: Did (M1 's executive producer) employ (M2) , edit (M3) , employ (a film director) , and employ (M4) \\
 \\
Q: Was a film whose star , writer , cinematographer , and executive producer executive produced , edited , and wrote M0 M1 \\
A: Was (a film) whose (star , writer , cinematographer , and executive producer) executive produced , edited , and wrote (M0) (M1) \\
 \\
Q: Was M1 a film that M0 's editor distributed \\
A: Was (M1) (a film) that (M0 's editor) distributed \\
 \\
Q: Was M1 a child of a production company 's parent and child \\
A: Was (M1) (a child of a production company 's parent and child) \\
 \\
Q: What did a director that M1 influenced and M2 influenced write \\
A: What did (a director) that (M1) influenced and (M2) influenced write \\
 \\
Q: What was written by M0 's art director and executive producer \\
A: What was written by (M0 's art director and executive producer) \\
 \\
Q: Did M1 influence a production company , influence M2 , influence M3 , M4 , and M5 , and influence M6 \\
A: Did (M1) influence (a production company) , influence (M2) , influence (M3 , M4 , and M5) , and influence (M6)
}

\subsubsection{Step 2: Subclause identification}

\prompt{Q: What N1 that M0 was employed by directed M5 \\
A: What ((N1) that (M0 was employed by)) directed M5 \\
 \\
Q: What N1 was N2 that M2 influenced \\
A: What N1 was ((N2) that (M2 influenced)) \\
 \\
Q: Did N1 that N2 married meet N3 \\
A: Did ((N1) that (N2 married)) meet N3 \\
 \\
Q: Did M2 marry N1 that M1 was edited by , directed by , and written by \\
A: Did M2 marry ((N1) that (M1 was edited by , directed by , and written by)) \\
 \\
Q: Which N1 that was written by M1 M2 directed \\
A: Which ((N1) that (was written by M1)) M2 directed \\
 \\
Q: Which N1 that N2 influenced was influenced by and married N3 \\
A: Which ((N1) that (N2 influenced)) was influenced by and married N3 \\
 \\
Q: Which director of N1 was N2 that M1 employed and was founded by \\
A: Which director of N1 was ((N2) that (M1 employed and was founded by)) \\
 \\
Q: Was N0 that M1 influenced and M2 was influenced by N1 \\
A: Was ((N0) that (M1 influenced and M2 was influenced by)) N1 \\
 \\
Q: What N1 that N2 influenced and N3 was influenced by influenced M1 \\
A: What ((N1) that (N2 influenced and N3 was influenced by)) influenced M1 \\
 \\
Q: Who was influenced by N1 that wrote N2 and influenced by N3 \\
A: Who was influenced by ((N1) that (wrote N2)) and influenced by N3 \\
 \\
Q: Was M4 produced by N1 that N2 were influenced by \\
A: Was M4 produced by ((N1) that (N2 were influenced by)) \\
 \\
Q: Was M0 N1 that M2 starred and was written by \\
A: Was M0 ((N1) that (M2 starred and was written by)) \\
 \\
Q: Was N1 N2 that M2 employed \\
A: Was N1 ((N2) that (M2 employed)) \\
 \\
Q: Who was N0 that wrote N1 and edited N2 \\
A: Who was ((N0) that (wrote N1 and edited N2)) \\
 \\
Q: Did N1 marry and divorce N2 whose N3 wrote M3 \\
A: Did N1 marry and divorce ((N2) whose (N3 wrote M3)) \\
 \\
Q: Did N1 whose N2 was employed by M2 and was employed by M3 direct and write M1 \\
A: Did ((N1) whose (N2 was employed by M2 and was employed by M3)) direct and write M1 \\
 \\
Q: Did M3 found M4 and found N1 whose N2 wrote M1 \\
A: Did M3 found M4 and found ((N1) whose (N2 wrote M1)) \\
 \\
Q: What N1 whose N2 was influenced by N3 played M1 \\
A: What ((N1) whose (N2 was influenced by N3)) played M1 \\
 \\
Q: Which N1 whose N2 was influenced by M3 and was influenced by N3 directed M2 \\
A: Which ((N1) whose (N2 was influenced by M3 and was influenced by N3)) directed M2 \\
 \\
Q: Which N1 was influenced by N2 whose N3 edited M2 and employed by M3 \\
A: Which N1 was influenced by ((N2) whose (N3 edited M2)) and employed by M3 \\
 \\
Q: Was N1 whose N2 executive produced , edited , and wrote M0 M1 \\
A: Was ((N1) whose (N2 executive produced , edited , and wrote M0)) M1 \\
 \\
Q: Was M1 N2 whose N3 directed , produced , and wrote N4 \\
A: Was M1 ((N2) whose (N3 directed , produced , and wrote N4)) \\
 \\
Q: Was N1 that N2 directed N3 \\
A: Was ((N1) that (N2 directed)) N3 \\
 \\
Q: Was N1 whose N2 executive produced M1 and edited M0 M3 \\
A: Was ((N1) whose (N2 executive produced M1 and edited M0)) M3 \\
 \\
Q: What N1 was N2 whose N3 wrote N4 \\
A: What N1 was ((N2) whose (N3 wrote N4)) \\
 \\
Q: Which N1 that N2 were written by and were produced by was N3 \\
A: Which ((N1) that (N2 were written by and were produced by)) was N3 \\
 \\
Q: Was M2 N2 whose N3 was employed by and founded M1 \\
A: Was M2 ((N2) whose (N3 was employed by and founded M1)) \\
 \\
Q: Which N1 was N2 whose N3 produced and executive produced M2 \\
A: Which N1 was ((N2) whose (N3 produced and executive produced M2)) \\
 \\
Q: Was N0 that N1 were executive produced by , were edited by , were written by , and starred M0 \\
A: Was ((N0) that (N1 were executive produced by , were edited by , were written by , and starred M0)) \\
 \\
Q: Which N0 that M2 employed executive produced M1 \\
A: Which ((N0) that (M2 employed)) executive produced M1 \\
 \\
Q: Who was N0 that M2 was influenced by and married \\
A: Who was ((N0) that (M2 was influenced by and married)) \\
 \\
Q: Which N0 that M1 was edited by did M2 influence \\
A: Which ((N0) that (M1 was edited by)) did M2 influence \\
 \\
Q: Were N0 directed by and produced by N1 that executive produced M1 \\
A: Were N0 directed by and produced by ((N1) that (executive produced M1)) \\
 \\
Q: What N0 that M1 was executive produced by and written by did N1 marry \\
A: What ((N0) that (M1 was executive produced by and written by)) did N1 marry \\
 \\
Q: Was N0 that M1 married N1 that directed and edited N2 \\
A: Was ((N0) that (M1 married)) ((N1) that (directed and edited N2)) \\
 \\
Q: What N0 influenced by M1 and influenced by N1 that founded N2 edited M2 \\
A: What N0 influenced by M1 and influenced by ((N1) that (founded N2)) edited M2 \\
 \\
Q: Was N0 that N1 were edited , art directed , and produced by M0 \\
A: Was ((N0) that (N1 were edited , art directed , and produced by)) M0
}

\subsubsection{Step 3: Verb phrase identification}

\paragraph{Verb phrase identification in subclauses}

\prompt{\\
Q: that N1 influenced and N2 was influenced by \\
A: that ((N1 influenced) and (N2 was influenced by)) \\
 \\
Q: that was edited by N1 and starred N2 \\
A: that ((was edited by N1) and (starred N2)) \\
 \\
Q: whose N1 was influenced by M3 and was influenced by N2 \\
A: whose (N1) ((was influenced by M3) and (was influenced by N2)) \\
 \\
Q: whose N1 produced and edited M2 \\
A: whose (N1) (produced and edited) (M2) \\
 \\
Q: whose N1 married M2 , met M3 , and played M4 \\
A: whose (N1) ((married M2) , (met M3) , and (met M3)) \\
 \\
Q: that M2 was influenced by and M3 influenced \\
A: that ((M2 was influenced by) and (M3 influenced)) \\
 \\
Q: whose N1 executive produced , edited , and wrote M0 \\
A: whose (N1) (executive produced , edited , and wrote) (M0) \\
 \\
Q: whose N1 was influenced by N2 \\
A: whose (N1) (was influenced by) (N2) \\
 \\
Q: that N1 influenced \\
A: that (N1) (influenced) \\
 \\
Q: that M1 starred and was written by \\
A: that (M1) (starred and was written by) \\
 \\
Q: that M1 was edited by , directed by , and written by \\
A: that (M1) (was edited by , directed by , and written by) \\
 \\
Q: whose N1 was employed by M2 and was employed by M3 direct and write M1 \\
A: whose (N1) ((was employed by M2) and (was employed by M3)) (direct and write) (M1) \\
 \\
Q: whose N1 was employed by and founded M1 \\
A: whose (N1) (was employed by and founded) (M1) \\
 \\
Q: that M1 influenced \\
A: that (M1) (influenced) \\
 \\
Q: that directed and executive produced N1 \\
A: that (directed and executive produced) (N1) \\
 \\
Q: that M2 was influenced by and married \\
A: that (M2) (was influenced by and married) \\
 \\
Q: that N1 were influenced by , M3 was edited by , and M4 married \\
A: that ((N1 were influenced by) , (M3 was edited by) , and (M4 married)) \\
 \\
Q: that N1 were written by \\
A: that (N1) (were written by) \\
 \\
Q: that was founded by and employed N2 \\
A: that (was founded by and employed) (N2) \\
 \\
Q: that was influenced by M2 and was employed by M3 and M4  \\
A: that ((was influenced by M2) and (was employed by M3 and M4)) \\
 \\
Q: that N1 married \\
A: that (N1) (married) \\
 \\
Q: that edited N1 and produced M2 \\
A: that ((edited N1) and (produced M2)) \\
 \\
Q: whose N1 edited M0 and executive produced N2 \\
A: whose (N1) ((edited M0) and (executive produced N2)) \\
 \\
Q: whose N1 edited N2 \\
A: whose (N1) (edited) (N2) \\
 \\
Q: that M1 influenced and employed \\
A: that (M1) (influenced and employed) \\
 \\
Q: that wrote N1 and edited N2 \\
A: that ((wrote N1) and (edited N2)) \\
 \\
Q: that edited and wrote N1 \\
A: that (edited and wrote) (N1) \\
 \\
Q: whose N1 was employed by and founded M1 \\
A: whose (N1) (was employed by and founded) (M1) \\
 \\
Q: whose N1 married M2 and married N2 \\
A: whose (N1) ((married M2) and (married N2)) \\
 \\
Q: that played M2 , played M3 , and played M4 \\
A: that ((played M2) , (played M3) , and (played M4)) \\
 \\
Q: that wrote , edited , executive produced , and directed N1 \\
A: that (wrote , edited , executive produced , and directed) (N1) \\
 \\
Q: that N3 were written by and art directed by \\
A: that (N3) (were written by and art directed by)}

\paragraph{Verb phrase identification in main clauses}

\prompt{\\
Q: Was N1 N2 \\
A: (Was) (N1) (N2) \\
 \\
Q: Did M1 influence N2 \\
A: (Did) (M1) (influence) (N2) \\
 \\
Q: Which N1 was N2 \\
A: (Which) (N1) (was) (N2) \\
 \\
Q: Who employed , met , and was influenced by N1 and married M1 \\
A: (Who) ((employed , met , and was influenced by N1) and (married M1)) \\
 \\
Q: Were N1 executive produced by , written by , and directed by N2 , and produced by N3 \\
A: (Were) (N1) ((executive produced by , written by , and directed by N2) , and (produced by N3)) \\
 \\
Q: What N1 married , divorced , and was kissed by N2 \\
A: (What) (N1) (married , divorced , and was kissed by) (N2) \\
 \\
Q: Which N1 did M0 acquire \\
A: (Which) (N1) (did) (M0) (acquire) \\
 \\
Q: Which N1 was influenced by N2 , influenced by N3 , and influenced by M4 \\
A: (Which) (N1) ((was influenced by N2) , (influenced by N3) , and (influenced by M4)) \\
 \\
Q: Was N1 employed by N2 and employed by M4 , M5 , and M6 N4 \\
A: (Was) ((N1) ((employed by N2) and (employed by N3))) (N4) \\
 \\
Q: Which N1 did N2 produce and M1 direct \\
A: (Which) (N1) (did) ((N2 produce) and (M1 direct)) \\
 \\
Q: Did N1 influence N2 and influence N3 \\
A: (Did) (N1) ((influence N2) and (influence N3)) \\
 \\
Q: What N1 did N2 influence \\
A: (What) (N1) (did) (N2) (influence) \\
 \\
Q: Did M0 direct , produce , executive produce , edit , and write N1 \\
A: (Did) (M0) (direct , produce , executive produce , edit , and write) (N1) \\
 \\
Q: Was M0 executive produced by , edited by , written by , and directed by N1 \\
A: (Was) (M0) (executive produced by , edited by , written by , and directed by) (N1) \\
 \\
Q: Who influenced and was influenced by N1 \\
A: (Who) (influenced and was influenced by) (N1) \\
 \\
Q: Did N1 executive produce and produce M1 \\
A: (Did) (N1) (executive produce and produce) (M1) \\
 \\
Q: Did N1 found N1 and found M2 \\
A: (Did) (N1) ((found N1) and (found M2)) \\
 \\
Q: What was executive produced by N1 and executive produced by N2 \\
A: (What) ((was executive produced by N1) and (executive produced by N2)) \\
 \\
Q: Was N1 produced by and written by N2 \\
A: (Was) (N1) (produced by and written by) (N2) \\
 \\
Q: What did N1 produce and write \\
A: (What) (did) (N1) (produce and write) \\
 \\
Q: Was M1 produced by N1 \\
A: (Was) (M1) (produced by) (N1) \\
 \\
Q: Did N1 edit , N2 direct , and N3 produce M4 \\
A: (Did) ((N1 edit) , (N2 direct) , and (N3 produce)) M4 \\
 \\
Q: Was N1 written by and executive produced by N2 M1 \\
A: (Was) ((N1) (written by and executive produced by) (N2)) (M1) \\
 \\
Q: Which N1 was founded by N2 \\
A: (Which) (N1) (was founded by) (N2) \\
 \\
Q: Which N1 was acquired by N2 and acquired N3 \\
A: (Which) (N1) ((was acquired by N2) and (acquired N3)) \\
 \\
Q: Was M2 N0 written by M4 and directed by N1 \\
A: (Was) (M2) ((N0) ((written by M4) and (directed by N1))) \\
 \\
Q: What N1 did N2 marry and influence \\
A: (What) (N1) (did) (N2 marry and influence) \\
 \\
Q: Did N1 influence and marry N2 \\
A: (Did) (N1) (influence and marry) (N2) \\
 \\
Q: Which N1 did M1 marry and M2 marry \\
A: (Which) (N1) (did) ((M1 marry) and (M2 marry)) \\
 \\
Q: What was directed by and edited by N1 \\
A: (What) (was directed by and edited by) (N1) \\
 \\
Q: What did N1 edit and M0 executive produce \\
A: (What) (did) ((N1 edit) and (M0 executive produce)) \\
 \\
Q: What N0 did N1 edit and produce \\
A: (What) (N0) (did) (N1) (edit and produce) \\
 \\
Q: Was N1 N2 edited by M0 \\
A: (Was) (N1) (N2 (edited by) M0) \\
 \\
Q: Did N1 write a film and direct N2 \\
A: (Did) (N1) ((write a film) and (direct N2)) \\
 \\
Q: Was N1 produced by M1 and executive produced by M2 \\
A: (Was) (N1) ((produced by M1) and (executive produced by M2)) \\
 \\
Q: Were N1 written , executive produced , produced , and edited by N2 \\
A: (Were) (N1) (written , executive produced , produced , and edited by) (N2) \\
 \\
Q: Was N0 influenced by N1 and influenced by M1 M1 \\
A: (Was) ((N0) (influenced by N1) and (influenced by M1)) (M1) \\
 \\
Q: What was edited by M0 and executive produced by N0 \\
A: (What) ((was edited by M0) and (executive produced by N0)) \\
 \\
Q: Did M2 star M3 and star N0 \\
A: (Did) (M2) ((star M3) and (star N0)) \\
 \\
Q: Was M1 employed by M2 and employed by N0 \\
A: (Was) (M1) ((employed by M2) and (employed by N0)) \\
 \\
Q: What did N0 write , direct , edit , executive produce , and produce \\
A: (What) (did) (N0) (write , direct , edit , executive produce , and produce) \\
 \\
Q: Was N1 N2 founded by N3 and founded by N4 \\
A: (Was) (N1) (N2 ((founded by N3) and (founded by N4))) \\
 \\
Q: Did M2 marry N1 employed by N2 \\
A: (Did) (M2) (influence) (N1 employed by N2)}

\subsubsection{Step 4: Part of speech tagging}

\paragraph{Part of speech tagging of noun phrases}

\prompt{\\
Q: M1 \\
A: M=(M1) \\
 \\
Q: (film) \\
A: N=(film) \\
 \\
Q = N2 \\
A: N=(N2) \\
 \\
Q: M0 's producer \\
A: M=(M0) P=('s) N=(producer) \\
 \\
Q: a art director 's sibling \\
A: [a] (N=(art director) P=('s) N=(sibling)) \\
 \\
Q: a French producer and editor 's child 's spouse \\
A: [a] ((N=(French /A, producer, [and] editor) P=('s) N=(child)) P=('s) N=(spouse)) \\
 \\
Q: female French costume designer , producer , and editor of M3 and M4 \\
A: N=(female /A, French /A, costume designer, producer, [and] editor) P=(of) M=(M3, M4) \\
 \\
Q: country of nationality of M3 \\
A: N=(country of nationality) P=(of) M=(M3) \\
 \\
Q: a Dutch parent and spouse \\
A: [a] N=(Dutch /A, parent, [and] spouse) \\
 \\
Q: a editor , producer , and writer of a film 's prequel \\
A: [a] (N=(editor, producer, [and] writer) P=(of) ([a] (N=(film) P=('s) N=(prequel)))) \\
 \\
Q: a female film director 's Spanish parent \\
A: [a] ((female /A, film director) P=('s) N=(Spanish /A, parent)) \\
 \\
Q: M3 and M6 \\
A: M=(M3, [and] M6) \\
 \\
Q: a writer 's spouse , friend , and employer \\
A: [a] (N=(writer) P=('s) N=(spouse, friend, [and] employer)) \\
 \\
Q: male Spanish spouse and parent \\
A: N=(male /A, Spanish /A, spouse, [and] parent) \\
 \\
Q: a person \\
A: [a] N=(person) \\
 \\
Q: M4 , M5 , M6 , and M7 \\
A: M=(M4, M5, M6, [and] M7) \\
 \\
Q: film director and editor of M0 , M1 , and M2 \\
A: N=(film director, [and] editor) P=(of) M=(M0, M1, [and] M2) \\
 \\
Q: a Spanish editor and producer of M5 \\
A: [a] (N=(Spanish /A, editor, [and] producer) P=(of) M=(M5)) \\
 \\
Q: child of a production company \\
A: N=(child) P=(of) ([a] N=(production company)) \\
 \\
Q: M1 's sibling and spouse \\
A: M=(M1) P=('s) N=(sibling, [and] spouse) \\
 \\
Q: M3 's employer 's Mexican employee \\
A: (M=(M3) P=('s) N=(employer)) P=('s) N=(Mexican /A, employee) \\
 \\
Q: M3 's parent 's employee \\
A: (M=(M3) P=('s) N=(parent)) P=('s) N=(employee) \\
 \\
Q: M2 's founder and employee \\
A: M=(M2) P=('s) N=(founder, [and] employee) \\
 \\
Q: director of M3 , M4 , and M5 \\
A: N=(director) P=(of) M=(M3 , M4 , [and] M5) \\
 \\
Q: male director of M3 and M4 \\
A: N=(male /A, director) P=(of) M=(M3, [and] M4) \\
 \\
Q: a child of M4 's male editor 's sibling \\
A: [a] (N=(child) P=(of) ((M=(M4) P=('s) N=(male /A, editor)) P=('s) N=(sibling))) \\
 \\
Q: spouse of M0 's sibling 's employee \\
A: N=(spouse) P=(of) ((M=(M0) P=('s) N=(sibling)) P=('s) N=(employee)) \\
 \\
Q: a actor 's country of nationality \\
A: [a] (N=(actor) P=('s) N=(country of nationality)) \\
 \\
Q: a female person 's parent 's sibling \\
A: [a] ((N=(female /A, person) P=('s) N=(parent)) P=('s) N=(sibling)) \\
 \\
Q: a screenwriter 's French parent \\
A: [a] (N=(screenwriter) P=('s) N=(French /A, parent)) \\
 \\
Q: sibling and friend of a director and actor \\
A: N=(sibling, [and] friend) P=(of) ([a] (N=(director, [and] actor))) \\
 \\
Q: Mexican American parent \\
A: N=(Mexican /A, American /A, parent)}

\paragraph{Part of speech tagging of other phrases}

\prompt{\\
Q: What \\
A: W=(What) \\
 \\
Q: Which \\
A: W=(Which) \\
 \\
Q: Who \\
A: W=(Who) \\
 \\
Q: (Did) \\
A: V=(Did) \\
 \\
Q: Was \\
A: V=(Was) \\
 \\
Q: employed , met , and was influenced by N1 \\
A: V=(employed, met, [and] [was] influenced by) (N1) \\
 \\
Q: married M1 \\
A: V=(married) M=(M1) \\
 \\
Q: executive produced by , written by , and directed by N1 \\
A: V=(executive produced by, V=written by, [and] V=directed by) (N1) \\
 \\
Q: produced by N1 \\
A: V=(produced by) (N1) \\
 \\
Q: M0 was employed by \\
A: M=(M0) V=([was] employed by) \\
 \\
Q: N1 married \\
A: (N1) V=(married) \\
 \\
Q: M4 , M5 , M6 , and M7 \\
A: M=(M4, M5, M6, [and] M7) \\
 \\
Q: was written by M1 \\
A: V=([was] written by) M=(M1) \\
 \\
Q: married , divorced , and was kissed by \\
A: V=(married, divorced, [and] [was] kissed by) \\
 \\
Q: N1 wrote M3 \\
A: (N1) V=(wrote) M=(M3) \\
 \\
Q: was influenced by N1 \\
A: V=([was] influenced by) (N1) \\
 \\
Q: influenced by N1 \\
A: V=(influenced by) (N1) \\
 \\
Q: (employed by M1 , M2 , and M3) \\
A: V=(employed by) M=(M1, M2, [and] M3) \\
 \\
Q: N1 produce \\
A: (N1) V=(produce) \\
 \\
Q: influence N1 \\
A: V=(influence) (N1) \\
 \\
Q: M1 employed and was founded by \\
A: M=(M1) V=(employed, [and] [was] founded by)) \\
 \\
Q: direct , produce , executive produce , edit , and write \\
A: V=(direct, produce, executive produce, edit, [and] write) \\
 \\
Q: executive produced by , edited by , written by , and directed by \\
A: V=(executive produced by, edited by, written by, [and] directed by)}

\subsubsection{Step 5: Verb normalization}

\prompt{Q: and \\
A: and \\
 \\
Q: was \\
A: be \\
 \\
Q: Was \\
A: be \\
 \\
Q: were \\
A: be \\
 \\
Q: Were \\
A: be \\
 \\
Q: did \\
A: do \\
 \\
Q: Did \\
A: do \\
 \\
Q: directed \\
A: direct \\
 \\
Q: edited \\
A: edit \\
 \\
Q: met \\
A: meet \\
 \\
Q: found \\
A: found \\
 \\
Q: edited by \\
A: edit by \\
 \\
Q: written by \\
A: write by}

\subsection{CFQ Exemplar Selection: Details}
\label{app:cfq_exemplar_selection}

For CFQ, we use a random subset consisting of 1000 examples from the training set as a pool of candidate exemplars. For each input question to process, we then dynamically select exemplars from this pool such that they collectively demonstrate relevant knowledge needed to translate the input sentences. This is done by making sure that as many nodes as possible of the decomposition tree of the input are covered by the decomposition trees of the selected exemplars. Depending on the complexity of the input and the similarity of the candidate exemplars in the pool, we select between 4 and 35 exemplars for any given input.

We provide a general description of this process in Section~\ref{sec:dynamic_exemplar_selection} and add the CFQ-specific details here. In Section~\ref{app:cfq_solution}, we also show the set of all selected exemplars for the example in Figure~\ref{fig:cfq_example_e2e}.

\subsubsection{Top-down matching}
We want to select exemplars that cover the structure of the input question as well as possible. We do this using the following process:

We first convert the decomposition trees of all the candidate exemplars as well as the concrete input question into syntactic templates by anonymizing concrete leafs and just keeping their types. For instance, the question shown in Figure~\ref{fig:cfq_example_e2e} results in the syntactic template ``Which N (V (N that (V (M , M , [and] M))) and (V (M 's N))''.

Then we try to find exemplars that match the full template of the input question. If we succeed, we keep them. Otherwise, we reduce the templates by collapsing some of the nodes. For example, we can collapse the node ``(M , M , [and] M)'' in the above template and instead just use ``M''. We again try to find exemplars that match the reduced template, keep them if we succeed, and otherwise continue reducing the templates. We do this until we retrieve exemplars that collectively cover the input template as well as possible.

We wrote a small amount of Python code that implements a generic version of this heuristics and use it for both CFQ and COGS. For the example shown in Figure~\ref{fig:cfq_example_e2e}, the top-down matching yields exemplars such as the ones shown below. Note that to provide the LM with additional hints, we add to the original question parentheses that indicate the syntactic structure.

\prompt{Q: Which cinematographer founded (M1 's distributor)\\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a cinematographer . ?x0 founded ?x1 . ?x1 distributed M1 \}\\
\\
Q: What (film director ((influenced by M1) and (influenced by (a person that (founded (M4 and M5)))))) produced M2\\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a film\_director . ?x0 produced M2 . ?x0 influenced\_by ?x1 . ?x0 influenced\_by M1 . ?x1 a person . ?x1 founded M4 . ?x1 founded M5 \}
}

\subsubsection{Bottom-up matching}
We also want to select exemplars that collectively cover each of the unanonymized leafs. In our running example, this means that we want to cover the leafs ``film editor'', ``influence'', ``cinematographer'', ``write'', and ``editor''. In addition, we prefer exemplars where these leafs occur within a similar syntactic template as in the input question.

For each leaf, we do this by converting the decomposition trees into a form where everything but this leaf is anonymized. For the leaf ``editor'', this results in ``Which N (V (N that (V (M , M , [and] M))) and (V (M 's editor))''. Then we try to find exemplars that share as many subtrees containing ``editor'' as possible. This yields exemplars such as:

\prompt{Q: Was a (Dutch film editor) M0 \\
A: SELECT count(*) WHERE \{ M0 a film\_editor . M0 has\_nationality Dutch \} \\
\\
Q: Which actor (was influenced by and influenced) (M1 's editor) \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a actor . ?x0 influenced ?x1 . ?x0 influenced\_by ?x1 . ?x1 edited M1 \} \\
\\
Q: Was a (Chinese cinematographer) M0 \\
A: SELECT count(*) WHERE \{ M0 a cinematographer . M0 has\_nationality Chinese \} \\
\\
Q: What did (M0 's sibling) write \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 written\_by ?x1 . ?x1 sibling\_of M0 \} \\
\\
Q: Was M1 ((founded by (M0 's editor)) and (founded by M2)) \\
A: SELECT count(*) WHERE \{ ?x0 edited M0 . M1 founded\_by ?x0 . M1 founded\_by M2 \}
}

\subsection{CFQ Solution: Details and Prompt}
\label{app:cfq_solution}

As we discussed in Section~\ref{sec:seq_solution}, one novelty of dynamic least-to-most prompting is that we cannot translate the constituents in isolation because they might not correspond to well-formed questions and their translation may depend on the context. Instead, we linearize the composition tree into a sequence of increasingly complex subquestions. 

This linearization is performed by a walk over the parse tree. We keep the most generic variant of each top-level node and then expand these nodes step by step to obtain a linear sequence of well-formed subquestions. For each subquestion, we then query the language model using a prompt that consists of three parts.

\begin{enumerate}
    \item Static prompt context for question grounding
    \item Dynamically selected exemplars as additional context
    \item Sequential questions
\end{enumerate}

These parts are detailed throughout the rest of this section.

\subsubsection{Part 1: Static prompt context.}
Because we cannot translate constituents in isolation, even the simplest subquestion may be too complex to be translated correctly based on the selected exemplars alone. This is especially the case if the exemplar pool does not contain similar questions.

To teach the language model how to translate the simplest subquestions, we therefore provide it with a constant prompt context consisting of 12 grounding examples that illustrate these kinds of subquestions. In addition to the question and its translation, each of these grounding examples also provides a rationale that tells the model how the translation can be obtained (this resembles our chain-of-thought prompt).

The static prompt context is provided below. Note that we we use a slightly different prefix (``Partial Q: '' instead of ``Q:'') for these grounding questions. This allows us to encourage the model to perform rationale-based reasoning when asking it to translate the simplest question of a sequence. Also note that we again use parentheses to indicate the syntactic structure of the questions.

\prompt{Partial Q: Was a (costume designer 's parent) (M0 's editor) \\
Rational: Was = \{\}, "costume designer 's parent" = \{ ?x0 parent\_of ?x1 . ?x1 a costume\_designer \}, "M0 's editor" = \{ ?x0 edited M0 \} ==\textgreater \  A: SELECT count(*) WHERE \{ ?x0 parent\_of ?x1 . ?x1 a costume\_designer . ?x0 edited M0 \} \\
 \\
Partial Q: Was M0 a (screenwriter 's spouse) \\
Rationale: Was = \{\}, "M0" replaces ?x0, "screenwriter 's spouse" = \{ ?x0 married\_to ?x1 . ?x1 a writer \} ==\textgreater \  A: SELECT count(*) WHERE \{ M0 married\_to ?x1 . ?x1 a writer \} \\
 \\
Partial Q: Was a (sequel of M1) M0 \\
Rationale: Was = \{\}, "star of M1" = \{ ?x0 has\_prequel M1 \}, "M0" replaces ?x0 ==\textgreater \  A: SELECT count(*) WHERE \{ M0 has\_prequel M1 \} \\
 \\
Partial Q: Was M1 executive produced by a (sibling of a film producer) \\
Rationale: Was = \{\}, "M1" replaces ?x0, "executive produced by" = \{ ?x0 executive\_produced\_by ?x1 \}, "sibling of a film producer" = \{ ?x1 sibling\_of ?x2 . ?x2 a film\_producer \} ==\textgreater \  A: SELECT count(*) WHERE \{ M1 executive\_produced\_by ?x1 . ?x1 sibling\_of ?x2 . ?x2 a film\_producer \} \\
 \\
Partial Q: Did a (film 's prequel) star M1 \\
Rationale: Did = \{\}, "film 's prequel" = \{ ?x0 has\_sequel ?x1 . ?x1 a film \}, "star M1" = \{ ?x0 starred M1 \} ==\textgreater \  A: SELECT count(*) WHERE \{ ?x0 has\_sequel ?x1 . ?x1 a film . ?x0 starred M1 \} \\
 \\
Partial Q: Did M0 art direct M1 \\
Rationale: Did = \{\}, "M0" replaces ?x0, art direct M1 = \{ ?x0 art\_directed M1 \} ==\textgreater \  A: SELECT count(*) WHERE \{ M0 art\_directed M1 \} \\
 \\
Partial Q: Which person did M1 star \\
Rationale: Which = \{\}, "person" = \{ ?x0 a person \}, "did M1 star" = \{ M1 starred ?x0 \} ==\textgreater \  A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a person .  M1 starred ?x0 \} \\
 \\
Partial Q: Which (parent of M0) was a (person 's parent) \\
Rationale: Which = \{\}, "parent of M0" = \{ ?x0 parent\_of M0 \}, "costume designer 's parent" = \{ ?x0 parent\_of ?x1 . ?x1 a costume\_designer \} ==\textgreater \  A: SELECT DISTINCT ?x0 WHERE \{ ?x0 parent\_of M0 . ?x0 parent\_of ?x1 . ?x1 a costume\_designer \} \\
 \\
Partial Q: What was a film written by M1 \\
Rationale: What = \{\}, "film written by M1" = \{ ?x0 a film . ?x0 written\_by M1 \} ==\textgreater \  A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a film . ?x0 written\_by M1 \} \\
 \\
Partial Q: What (star of M1) was a (cinematographer 's parent)", \\
Rationale: What = \{\}, "star of M1" = \{ ?x0 starred\_in M1 \}, "cinematographer 's parent" = \{ ?x0 parent\_of ?x1 . ?x1 a cinematographer \} ==\textgreater \  A: SELECT DISTINCT ?x0 WHERE \{ ?x0 starred\_in M1 . ?x0 parent\_of ?x1 . ?x1 a cinematographer \} \\
 \\
Partial Q: Who was a (producer of M1) \\
Rationale: "Who" = \{ ?x0 a person \}, "executive producer of M1" = \{ ?x0 produced M1 \} ==\textgreater \  SELECT DISTINCT ?x0 WHERE \{ ?x0 a person . ?x0 produced M1 \} \\
 \\
Partial Q: Who employed a person influenced by M0 \\
Rationale: "Who" = \{ ?x0 a person \}, "employed a person" = \{ ?x0 employed ?x1 . ?x1 a person \}, "influenced by M0" = \{ ?x1 influenced\_by M0 \} ==\textgreater \  A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a person . ?x0 employed ?x1 . ?x1 a person . ?x1 influenced\_by M0 \}
}

\subsubsection{Part 2: Dynamically selected exemplars}
After the constant prompt context, we add as additional context the exemplars that we dynamically selected for the given input using the process described in Section~\ref{app:cfq_exemplar_selection}.

For our example from Figure~\ref{fig:cfq_example_e2e}, this results in the following prompt context, which is appended to the static context shown above.

\prompt{Q: Were (M2 and M3) produced by (a actor that (influenced (M1 's editor))) \\
A: SELECT count(*) WHERE \{ ?x0 a actor . ?x0 influenced ?x1 . ?x1 edited M1 . M2 produced\_by ?x0 . M3 produced\_by ?x0 \} \\
 \\
Q: Did M1 ((star a (editor of M0)) and (star M2)) \\
A: SELECT count(*) WHERE \{ ?x0 edited M0 . M1 starred ?x0 . M1 starred M2 \} \\
 \\
Q: Was M1 ((founded by (M0 's editor)) and (founded by M2)) \\
A: SELECT count(*) WHERE \{ ?x0 edited M0 . M1 founded\_by ?x0 . M1 founded\_by M2 \} \\
 \\
Q: Which actor ((was influenced by (M4 's (art director and writer))) , (influenced M1) , and (influenced (M2 and M3))) \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a actor . ?x0 influenced M1 . ?x0 influenced M2 . ?x0 influenced M3 . ?x0 influenced\_by ?x1 . ?x1 art\_directed M4 . ?x1 wrote M4 \} \\
 \\
Q: Which actor ((married a film editor) and (was influenced by (M1 's sibling))) \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a actor . ?x0 influenced\_by ?x1 . ?x0 married\_to ?x2 . ?x1 sibling\_of M1 . ?x2 a film\_editor \} \\
 \\
Q: Did a (film editor 's parent) write M0 \\
A: SELECT count(*) WHERE \{ ?x0 wrote M0 . ?x0 parent\_of ?x1 . ?x1 a film\_editor \} \\
 \\
Q: Did M0 (write , edit , and produce) M1 \\
A: SELECT count(*) WHERE \{ M0 edited M1 . M0 produced M1 . M0 wrote M1 \} \\
 \\
Q: What did (M0 's sibling) write \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 written\_by ?x1 . ?x1 sibling\_of M0 \} \\
 \\
Q: Was a (Chinese cinematographer) M0 \\
A: SELECT count(*) WHERE \{ M0 a cinematographer . M0 has\_nationality Chinese \} \\
 \\
Q: Who was (a cinematographer that (distributed M2)) \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a cinematographer . ?x0 a person . ?x0 distributed M2 \} \\
 \\
Q: Who ((was influenced by M1) and (influenced by a (Swedish cinematographer))) \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a person . ?x0 influenced\_by ?x1 . ?x0 influenced\_by M1 . ?x1 a cinematographer . ?x1 has\_nationality Swedish \} \\
 \\
Q: Who ((was influenced by (M1 's star)) and (married (M2 's sibling))) \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a person . ?x0 influenced\_by ?x1 . ?x0 married\_to ?x2 . ?x1 starred\_in M1 . ?x2 sibling\_of M2 \} \\
 \\
Q: Who ((was influenced by M1) and (influenced by (a person that (edited M2)))) \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a person . ?x0 influenced\_by ?x1 . ?x0 influenced\_by M1 . ?x1 a person . ?x1 edited M2 \} \\
 \\
Q: Which actor (was influenced by and influenced) (M1 's editor) \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a actor . ?x0 influenced ?x1 . ?x0 influenced\_by ?x1 . ?x1 edited M1 \} \\
 \\
Q: Was a (Dutch film editor) M0 \\
A: SELECT count(*) WHERE \{ M0 a film\_editor . M0 has\_nationality Dutch \} \\
 \\
Q: Was M1 a (employer of a film editor) \\
A: SELECT count(*) WHERE \{ ?x0 a film\_editor . M1 employed ?x0 \} \\
 \\
Q: Did a (actor of M1) edit M0 \\
A: SELECT count(*) WHERE \{ ?x0 portrayed M1 . ?x0 edited M0 \} \\
 \\
Q: Did M1 ((star M2) and (star (M0 's employee))) \\
A: SELECT count(*) WHERE \{ ?x0 employed\_by M0 . M1 starred ?x0 . M1 starred M2 \} \\
 \\
Q: Did M0 (executive produce (M1 , M2 , and produce)) M3 \\
A: SELECT count(*) WHERE \{ M0 executive\_produced M1 . M0 executive\_produced M2 . M0 produced M3 \} \\
 \\
Q: What (film director ((influenced by M1) and (influenced by (a person that (founded (M4 and M5)))))) produced M2 \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a film\_director . ?x0 produced M2 . ?x0 influenced\_by ?x1 . ?x0 influenced\_by M1 . ?x1 a person . ?x1 founded M4 . ?x1 founded M5 \} \\
 \\
Q: Which cinematographer founded (M1 's distributor) \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a cinematographer . ?x0 founded ?x1 . ?x1 distributed M1 \} \\
 \\
Q: Which character influenced a film editor \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a fictional\_character . ?x0 influenced ?x1 . ?x1 a film\_editor \} \\
 \\
Q: Which film editor founded (M1 's distributor) \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a film\_editor . ?x0 founded ?x1 . ?x1 distributed M1 \} \\
 \\
Q: Which character married a screenwriter \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a fictional\_character . ?x0 married\_to ?x1 . ?x1 a writer \}
}

\subsubsection{Part 3: Sequential questions}
After providing the static and dynamic prompt context, we start by grounding the simplest subquestion. To encourage the model to use the rationale-based reasoning, we use the prefix ``Partial Q:'' rather than just ``Q:'' for this question. After we obtain the translation from the model, we append it to the prompt and then again ask the same subquestion, but this time using the regular ``Q:'' prefix. In addition, we tell the model that it can simply copy the answer from above by adding the comment ``\# Copy the answer from above''.

For the example from Figure~\ref{fig:cfq_example_e2e}, this first part of the prompt looks as follows. Note that the text that is not bolded corresponds to the answers provided by the model.

\prompt{\textbf{Partial Q: Which film editor was influenced by a cinematographer} \\
Rationale: Which = \{\}, "film editor" = \{ ?x0 a film\_editor \}, "was influenced by a cinematographer" = \{ ?x0 influenced\_by ?x1 . ?x1 a cinematographer \} ==\textgreater\ A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a film\_editor . ?x0 influenced\_by ?x1 . ?x1 a cinematographer \} \\
\\
\textbf{\# Copy the answer from above.} \\
\textbf{Q: Which film editor was influenced by a cinematographer} \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a film\_editor . ?x0 influenced\_by ?x1 . ?x1 a \\ cinematographer \}
}

After grounding the simplest question, we continue with the next subquestions, which are presented to the model one after the other using the ordinary prefix ``Q:''. Sometimes, a subquestion is a strict extension of the previous subquestion. To make sure that the model does not miss this, we add a comment of the form ``\# Extend the answer anove. Add: \ldots''. which highlights the delta between the questions. In other cases, a subquestion is almost the same as the previous question, except that one constituent is replaced by another.

For each of these subquestions, we perform a request to the language model and append the answer to the prompt before asking the next question. For our running example, this part of the prompt looks as follows. Note that we obtain the correct answer to the original question at the end.

\prompt{\textbf{\# Extend the answer above. Add: that (wrote M3)} \\
\textbf{Q: Which film editor (was influenced by (a cinematographer that (wrote M3)))} \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a film\_editor . ?x0 influenced\_by ?x1 . ?x1 a cinematographer . ?x1 wrote M3 \} \\
\\
\textbf{\# Extend the answer above. Add: M5} \\
\textbf{Q: Which film editor (was influenced by (a cinematographer that (wrote (M3 and M5))))} \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a film\_editor . ?x0 influenced\_by ?x1 . ?x1 a cinematographer . ?x1 wrote M3 . ?x1 wrote M5 \} \\
\\
\textbf{\# Extend the answer above. Add: M4} \\
\textbf{Q: Which film editor (was influenced by (a cinematographer that (wrote (M3 , M4 , and M5))))} \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a film\_editor . ?x0 influenced\_by ?x1 . ?x1 a cinematographer . ?x1 wrote M3 . ?x1 wrote M4 . ?x1 wrote M5 \} \\
\\
\textbf{Q: Which film editor (influenced by (M1 's editor))} \\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a film\_editor . ?x0 influenced\_by ?x1 . ?x1 edited M1 \} \\
\\
\textbf{\# Extend the answer above. Add: was influenced by (a cinematographer that (wrote (M3 , M4 , and M5)))} \\
\textbf{Q: Which film editor ((was influenced by (a cinematographer that (wrote (M3 , M4 , and M5)))) and (influenced by (M1 's editor)))}\\
A: SELECT DISTINCT ?x0 WHERE \{ ?x0 a film\_editor . ?x0 influenced\_by ?x1 . ?x1 edited M1 . ?x0 influenced\_by ?x2 . ?x2 a cinematographer . ?x2 wrote M3 . ?x2 wrote M4 . ?x2 wrote M5 \}
}


\section{Least-to-most Prompting for COGS}
\label{app:l2m_cogs}

\begin{figure}[h!]
\begin{flushleft}
\small{
    \textbf{James said that a manager liked that Aiden appreciated that Emily believed that the girl was posted a cake beside a table by Olivia .} \\
    \texttt{PARSE: say ( agent = James , ccomp = like \\
    \phantom{0000}( agent = manager , ccomp = appreciate \\
    \phantom{0000}( agent = Aiden , ccomp = believe \\
    \phantom{0000}( agent = Emily , ccomp = post \\
    \phantom{0000}( recipient = * girl , theme = cake \\
    \phantom{0000}( nmod . beside = table ) , agent = Olivia ) ) ) ) ) DONE}
    \vspace{4mm} \\
    \textbf{The boy shortened the donut beside the bed in the car in the garden in the can on the tree .}\\
    \texttt{PARSE: shorten ( agent = * boy , theme = * donut \\
    \phantom{0000}( nmod . beside = * bed \\
    \phantom{0000}( nmod . in = * car \\
    \phantom{0000}( nmod . in = * garden \\
    \phantom{0000}( nmod . in = * can \\
    \phantom{0000}( nmod . on = * tree ) ) ) ) ) ) DONE}
}
\end{flushleft}
    \caption{Two COGS example, which we use to illustrate the application of dynamic least-to-most prompting to COGS. The first example contains nested subclauses while the second example contains nested propositional phrases.}
    \label{fig:cogs_example_e2e}
\end{figure}

In this section, we provide more details on the application of dynamic least-to-most prompting for COGS. In particular, we detail all the prompts and show how the example in Figure~\ref{fig:cogs_example_e2e} is processed step by step. Note that this is a variation of the application of dynamic-least-to-most prompting for CFQ, which is detailed in Section~\ref{app:l2m_cfq}. Therefore, we mostly focus on highlight the differences.


\subsection{COGS Decomposition: Details and Prompts}
\label{app:cogs_decomposition}

As discussed in Section~\ref{sec:decomposition}, we use prompting-based syntactic parsing to decompose COGS sentences. To teach LMs to perform this kind of decomposition, we divide the syntactic parsing task into the following steps

\begin{enumerate}
    \item \emph{Iterative} subclause decomposition
    \item Phrase identification
    \item \emph{Iterative} prepositional phrase decomposition and noun phrase annotation
    \item Verb phrase normalization
\end{enumerate}

This is quite similar to the steps used for CFQ (see Section~\ref{app:cfq_decomposition}) but there are some important differences. Since the CFQ dataset only contains limited nesting of subclauses and noun phrases, we were able to identify them in a single step. As exemplified by the first example in Figure~\ref{fig:cogs_example_e2e}, the COGS dataset contains much deeper nesting of subclauses (up to level 12), which we address by performing subclause decomposition iteratively. This means that the prompt for subclause decomposition (step 1) is designed such that it only extracts one subclause at a time and is applied iteratively until all subclauses are extracted.

As exemplified by the second example in Figure~\ref{fig:cogs_example_e2e}, COGS also contains deep nesting of prepositional phrases (up to level 12). We again address this by performing prepositional phrase decomposition (step 3) iteratively and designed the prompt such that it only extracts one prepositional phrase at a time and is applied iteratively until all prepositional phrases are extracted.

\paragraph{Example 1.}
To illustrate this step-by-step process, we begin with the first example from Figure~\ref{fig:cogs_example_e2e}, which is ``James said that a manager liked that Aiden appreciated that Emily believed that the girl was posted a cake beside a table by Olivia .''.  The first step decomposes the subclauses of this sentence via 4 iterative calls:

\example{
\ex P=(James) V=(said) that C=(a manager liked that Aiden appreciated that Emily believed that the girl was posted a cake beside a table by Olivia)
\ex P=(a manager) V=(liked) that C=(Aiden appreciated that Emily believed that the girl was posted a cake beside a table by Olivia)
\ex P=(Aiden) V=(appreciated) that C=(Emily believed that the girl was posted a cake beside a table by Olivia)
\ex P=(Emily) V=(believed) that C=(the girl was posted a cake beside a table by Olivia)
}

In the second step, we identify the different phrases for the final subclause ``the girl was posted a cake beside a table by Olivia'', which yields:

\example{
\ex P=(the girl) V=(was posted) P=(a cake beside a table) by P=(Olivia)
}

In the third step, we decompose the propositional phrase, which is not nested and therefore requires only one iteration:

\example{
\ex (a cake) beside P=(a table)
}

Note that the same prompt is also used to annotate noun phrases by marking the use of the definite article with a star. We therefore also apply it to all other noun phrases, which yields:

\example{
\ex James
\ex a manager
\ex Aiden
\ex Emily
\ex the * girl
\ex Olivia
\ex a table
}

In the fourth step, we normalize all the verbs, which means that ``said'' yields ``say'', ``liked'' yields ``like'', ``appreciated'' yields ``appreciate'', ``believed'' yields ``believe'', and ``was posted'' yields ``post''. Finally, we run a few lines of Python code that puts all these parts back together to obtain a parse tree. Note that the normalized verbs do not replace the original ones but are kept in addition, which allows us to obtain higher recall when selecting exemplars.

This yields the following fully decomposed sentence: 

\example{\ex (James) (said [say]) that ((a manager) (liked [like]) that ((Aiden) (appreciated [appreciate]) that ((Emily) (believed [believe]) that ((the * girl) (was posted [post]) ((a cake) (beside) (a table)) by (Olivia)))))}

\paragraph{Example 2.}
We now walk through the step-by-step process using the second example from Figure~\ref{fig:cogs_example_e2e}, which is ``The boy shortened the donut beside the bed in the car in the garden in the can on the tree .''. Since this example does not contain any suubclauses, the first step does not apply. In the second step, we identify the different phrases, which yields:

\example{
\ex P=(The boy) V=(shortened) P=(the donut beside the bed in the car in the garden in the can on the tree)
}

In the third step, we decompose the prepositional phrase, which happens to be nested and therefore requires 5 iterations:

\example{
\ex (the * donut) beside P=(the bed in the car in the garden in the can on the tree)
\ex (the * bed) in P=(the car in the garden in the can on the tree)
\ex (the * car) in P=(the garden in the can on the tree)
\ex (the * garden) in P=(the can on the tree)
\ex (the * can) on P=(the tree)
}

Since the same prompt is also used to annotate noun phrases by marking the use of the definite article with a star, we also apply it to all other noun phrases, which yields:

\example{
\ex The * boy
\ex the * tree
}

In the fourth step, we normalize all the verbs, which means that ``shortened'' yields ``shorten''.

This yields the following fully decomposed sentence:

\example{\ex (The * boy) (shortened [shorten]) ((the * donut) (beside) ((the * bed) (in) ((the * car) (in) ((the * garden) (in) ((the * can) (on) (the * tree))))))}

Below, we present the exact prompt contexts used for each of the parsing steps.

\subsubsection{Iterative subclause decomposition}

\prompt{Q: The girl expected that Daniel liked that a weapon was liked \\
A: P=(The girl) V=(expected) that C=(Daniel liked that a weapon was liked) \\
 \\
Q: The girl hoped that a donut was returned to a cat by a monkey \\
A: P=(The girl) V=(hoped) that C=(a donut was returned to a cat by a monkey) \\
 \\
Q: a teacher thought that a girl liked that a cookie was valued by Emma \\
A: P=(a teacher) V=(thought) that C=(a girl liked that a cookie was valued by Emma) \\
 \\
Q: Benjamin supported that Avery loaned a donut in a cup to a frog \\
A: P=(Benjamin) V=(supported) C=(that Avery loaned a donut in a cup to a frog) \\
 \\
Q: A girl liked that a frog liked that Eleanor gave a brush to the professor \\
A: P=(A girl) V=(liked) that C=(a frog liked that Eleanor gave a brush to the professor) \\
 \\
Q: Charlotte expected that Emma liked that the patient lended a box on a table to Nora \\
A: P=(Charlotte) V=(expected) that C=(Emma liked that the patient lended a box on a table to Nora) \\
 \\
Q: Aiden believed that a mouse hoped that Olivia examined a glue beside the stage beside a duck \\
A: P=(Aiden) V=(believed) that C=(a mouse hoped that Olivia examined a glue beside the stage beside a duck) \\
 \\
Q: a girl declared that the boy was offered the watch beside the table \\
A: P=(a girl) V=(declared) that C=(the boy was offered the watch beside the table) \\
 \\
Q: the teacher declared that a donut was given to the student by Noah \\
A: P=(the teacher) V=(declared) that C=(a donut was given to the student by Noah) \\
 \\
Q: A dog respected that Emma rented the biscuit in a pot beside a nest to the boy \\
A: P=(A dog) V=(respected) that C=(Emma rented the biscuit in a pot beside a nest to the boy) \\
 \\
Q: The teacher liked that a driver hoped that the girl meant to eat \\
A: P=(The teacher) V=(liked) that C=(a driver hoped that the girl meant to eat) \\
 \\
Q: the giraffe liked that Olivia noticed that the butterfly was given the drink in the garden on a table \\
A: P=(the giraffe) V=(liked) that C=(Olivia noticed that the butterfly was given the drink in the garden on a table) \\
 \\
Q: A cat in a box on a table tolerated that a professor beside the stage liked a dog \\
A: P=(A cat in a box on a table) V=(tolerated) that C=(a professor beside the stage liked a dog) \\
 \\
Q: the professor on a chair beside a bench in a room expected that a mouse was given a present by a doctor on the stage in a house \\
A: P=(the professor on a chair beside a bench in a room) V=(expected) that C=(a mouse was given a present by a doctor on the stage in a house) \\
 \\
Q: Joe liked that Fred thought that a girl confessed that the chicken meant that Freda liked that Peter hoped that Elizabeth said that a professor whished that Anna hoped that Lisa declared that the creature tolerated that a teacher liked that Lily was given the clock beside a guitar beside the table by Isabella \\
A: P=(Joe) V=(liked) that C=(Fred thought that a girl confessed that the chicken meant that Freda liked that Peter hoped that Elizabeth said that a professor whished that Anna hoped that Lisa declared that the creature tolerated that a teacher liked that Lily was given the clock beside a guitar beside the table by Isabella)
}

\subsubsection{Phrase identification}
\prompt{Q: a boy meant to talk \\
A: P=(a boy) V=(meant) (to talk) \\
 \\
Q: Camila rolled a lamb beside a flower \\
A: P=(Camila) V=(rolled) P=(a lamb beside a flower)) \\
 \\
Q: the hen appreciated the journalist on the piano \\
A: P=(the hen) V=(appreciated) P=(the journalist on the piano) \\
 \\
Q: The chicken on a box needed to eat \\
A: P=(The chicken on a box) V=(needed) (to eat) \\
 \\
Q: a king awarded Joe Fred \\
A: P=(a king) V=(awarded) P=(Joe) P=(Fred) \\
 \\
Q: The drink was snapped by Ava \\
A: P=(The drink) V=(was snapped) by P=(Ava) \\
 \\
Q: the teacher passed Joe a pen \\
A: P=(the teacher) V=(passed) P=(Joe) P=(a pen) \\
 \\
Q: the girl offered Fred to James \\
A: P=(the girl) V=(offered) P=(Fred) to P=(James) \\
 \\
Q: A teacher beside the table wanted to hunt \\
A: P=(A teacher beside the table) V=(wanted) (to hunt) \\
 \\
Q: A crayon was handed to the girl on the table \\
A: P=(A crayon) V=(was handed) to P=(the girl on the table) \\
 \\
Q: Aria rented the boy a donut in the room \\
A: P=(Aria) V=(rented) P=(the boy) P=(a donut in the room) \\
 \\
Q: Peter mailed Sawyer the hedgehog in the garage \\
A: P=(Peter) V=(mailed) P=(Sawyer) P=(the hedgehog in the garage) \\
 \\
Q: a boy froze the sandwich on the stage in the room \\
A: P=(a boy) V=(froze) P=(the sandwich on the stage in the room) \\
 \\
Q: A donut was returned to a cat beside the dog by a monkey on a roof \\
A: P=(A donut) V=(was returned) to P=(a cat beside the dog) by P=(a monkey on a roof) \\
 \\
Q: Avery loaned a donut in a cup to a frog \\
A: P=(Avery) V=(loaned) P=(a donut in a cup) to P=(a frog) \\
 \\
Q: the patient lended a box on a table to Nora \\
A: P=(the patient) V=(lended) P=(a box on a table) to P=(Nora) \\
 \\
Q: The butterfly was given the drink in the garden on a table \\
A: P=(The butterfly) V=(was given) P=(the drink in the garden on a table) \\
 \\
Q: Luke gave the cake on the windowsill beside a bed under a lamp to a teacher on a pony \\
A: P=(Luke) V=(gave) P=(the cake on the windowsill beside a bed under a lamp) to P=(a teacher on a pony) \\
 \\
Q: The teacher received a cat in a box on a table on a carpet beside a window from Joe \\
A: P=(The teacher) V=(received) P=(a cat in a box on a table on a carpet beside a window) (from P=(Joe)) \\
 \\
Q: A cat in a cage on a table gave a present in a box to a dog on the floor \\
A: P=(A cat in a cage on a table) V=(gave) P=(a present in a box) to P=(a dog on the floor) \\
 \\
Q: A ring on a pillow in a wrapper was presented to the professor in a room by a priest on a chair \\
A: P=(a ring on a pillow in a wrapper) V=(was presented) to P=(the professor in a room) by P=(a priest on a chair) \\
 \\
Q: Charles posted the pony in a barn the drink in a pear on the floor beside the book in the iron on a brick in the robe in a pipe \\
A: P=(Charles) V=(posted) P=(the pony in a barn) P=(the drink in a pear on the floor beside the book in the iron on a brick in the robe in a pipe) \\
 \\
Q: a frog was given the apple in a school in a town on a stool on a sheet on a table on a desk on the floor in a room beside a building on a road in a city in the world in the universe by a baby \\
A: P=(a frog) V=(was given) P=(the apple in a school in a town on a stool on a sheet on a table on a desk on the floor in a room beside a building on a road in a city in the world in the universe) by P=(a baby)
}

\subsubsection{Iterative prepositional phrase decomposition and noun phrase annotation}
\prompt{Q: Joe \\
A: Joe \\
 \\
Q: Liam \\
A: Liam \\
 \\
Q: Isabelle \\
A: Isabelle \\
 \\
Q: Benedict \\
A: Benedict \\
 \\
Q: A atom \\
A: A atom \\
 \\
Q: a helmet \\
A: a helmet \\
 \\
Q: A camera \\
A: A camera \\
 \\
Q: a helmet \\
A: a helmet \\
 \\
Q: the atom \\
A: the * atom \\
 \\
Q: The helmet \\
A: The * helmet \\
 \\
Q: the camera \\
A: the * camera \\
 \\
Q: The song \\
A: The * song \\
 \\
Q: the rino \\
A: the * rino \\
 \\
Q: The lizzard \\
A: The * lizzard \\
 \\
Q: the plane \\
A: the * plane \\
 \\
Q: The gnome \\
A: The * gnome \\
 \\
Q: the nose \\
A: the * nose \\
 \\
Q: The adventure \\
A: The * adventure \\
 \\
Q: the undertaking \\
A: the * undertaking \\
 \\
Q: The camera \\
A: The * camera \\
 \\
Q: the sky \\
A: the * sky \\
 \\
Q: The trainer \\
A: The * trainer \\
 \\
Q: the underdog \\
A: the * underdog \\
 \\
Q: The mole \\
A: The * mole \\
 \\
Q: the floor \\
A: the * floor \\
 \\
Q: The stone \\
A: The * stone \\
 \\
Q: the smartphone \\
A: the * smartphone \\
 \\
Q: The hiccups \\
A: The * hiccups \\
 \\
Q: the wine \\
A: the * wine \\
 \\
Q: The dinosaur \\
A: The * dinosaur \\
 \\
Q: the boy \\
A: the * boy \\
 \\
Q: a atom beside a flower \\
A: (a atom) (beside) P=(a flower) \\
 \\
Q: A song beside a roof \\
A: (A song) (beside) P=(a roof) \\
 \\
Q: the shark in the helmet \\
A: (the * shark) (in) P=(the helmet) \\
 \\
Q: The camera beside the pool \\
A: (The * camera) (beside) P=(the pool) \\
 \\
Q: the floor in the rino \\
A: (the * floor) (in) P=(the rino) \\
 \\
Q: the sky on a ceiling \\
A: (the * sky) (on) P=(a ceiling) \\
 \\
Q: the plane on the piano \\
A: (the * plane) (on) P=(the piano) \\
 \\
Q: A rino in a trainer \\
A: (A rino) (in) P=(a trainer) \\
 \\
Q: The sandwich on the underdog in the camera \\
A: (The * sandwich) (on) P=(the underdog in the camera) \\
 \\
Q: A undertaking in the camera on a leg \\
A: (A undertaking) (in) P=(the camera on a leg) \\
 \\
Q: The helmet on the smartphone \\
A: (The * helmet) (on) P=(the smartphone) \\
 \\
Q: the helmet on the dinosaur beside a smartphone under a wine \\
A: (the * helmet) (on) P=(the dinosaur beside a smartphone under a wine) \\
 \\
Q: A stone in a trainer on a leg on a helmet beside a window \\
A: (A stone) (in) P=(a trainer on a leg on a helmet beside a window) \\
 \\
Q: a riffle on the floor in the rino on the leg beside the stone on a spear beside the rino on a sofa \\
A: (a riffle) (on) P=(the floor in the rino on the leg beside the stone on a spear beside the rino on a sofa) \\
 \\
Q: The referee in a rino beside a official on a smartphone in the camera beside the trainer in a trainer under the spider on the shingle \\
A: (The * referee) (in) P=(a rino beside a official on a smartphone in the camera beside the trainer in a trainer under the spider on the shingle) \\
 \\
Q: Joe in a helmet in a vessel on the water beside a harbor in a village beside city in a country on a continent on earth \\
A: (Joe) (in) P=(a helmet in a vessel on the water beside a harbor in a village beside city in a country on a continent on earth) \\
 \\
Q: a underdog beside a foreigner on a smartphone in a truck in a microwave beside a rocket on a computer on a stool on the surface \\
A: (a underdog) (beside) P=(a foreigner on a smartphone in a truck in a microwave beside a rocket on a computer on a stool on the surface) \\
 \\
Q: the rooster over a computer on a board on the spear on a leg on the floor beside a rocker under a window on a shingle beside a rino under the clouds on the sky \\
A: (the * rooster) (over) P=(a computer on a board on the spear on a leg on the floor beside a rocker under a window on a shingle beside a rino under the clouds on the sky) \\
 \\
Q: A phone on the helmet in the rino on the wallet beside the knive on a floor beside the lizzard on a underdog in a wardrobe beside the rocket in the bus beside a hut in the village \\
A: (A phone) (on) P=(the helmet in the rino on the wallet beside the knive on a floor beside the lizzard on a underdog in a wardrobe beside the rocket in the bus beside a hut in the village) \\
 \\
Q: the country in a school in a town on a stool on a sheet on a leg on a rocker on the floor in a camera beside a building on a street in a city in the world in the universe \\
A: (the * country) (in) P=(a school in a town on a stool on a sheet on a leg on a rocker on the floor in a camera beside a building on a street in a city in the world in the universe)
}

\subsubsection{Verb phrase normalization}

\prompt{Q: expected \\
A: expect \\
 \\
Q: hoped \\
A: hope \\
\\
Q: thought \\
A: think \\
\\
Q: supported \\
A: support \\
\\
Q: liked \\
A: like \\
\\
Q: gave \\
A: give \\
\\
Q: ate \\
A: eat \\
\\
Q: was snapped \\
A: snap \\
\\
Q: was given \\
A: give \\
\\
Q: was returned \\
A: return \\
\\
Q: was lended \\
A: lend \\
\\
Q: was brought \\
A: bring}

\subsection{COGS Exemplar Selection: Details}
\label{app:cogs_exemplar_selection}

We provide a general description of the exemplar selection process in Section~\ref{sec:dynamic_exemplar_selection} and add the CFQ-specific details in Section~\ref{app:cfq_exemplar_selection}. Since COGS is using the same heuristics with slightly different parameters, we just highlight the differences here.

\subsubsection{Exemplar pool}

For CFQ, we use a random subset consisting of 1000 examples from the training set as a pool of candidate exemplars. For COGS, we went a different route and manually selected a set of exemplars from the training data. The main reason for this is that COGS contains many different verbs and since unergative and unaccusative are translated differently, it is important to include as many of them in the exemplar pool as it would otherwise be hard for the model to figure out how a certain verb should be treated. Also, since some of those verbs are quite rare in the training data, some of them would not be included in a reasonably sized random sample.

Concretely, we include in the exemplar pool for COGS the following 62 exemplars containing all unegative and unaccuastive verbs that occur in the training data. As for CFQ, we use for all exemplars a parsed version of the natural language sentence, which contains additional parentheses and other annotations that make it easier for the model to perform the translation.

\prompt{(The * goose) (baked [bake]) \\
PARSE: bake ( agent = * goose ) DONE \\
 \\
(A bell) (broke [break]) \\
PARSE: break ( theme = bell ) DONE \\
 \\
(A molecule) (burned [burn]) \\
PARSE: burn ( theme = molecule ) DONE \\
 \\
(A cat) (called [call]) \\
PARSE: call ( agent = cat ) DONE \\
 \\
(A cake) (changed [change]) \\
PARSE: change ( theme = cake ) DONE \\
 \\
(A student) (cleaned [clean]) \\
PARSE: clean ( agent = student ) DONE \\
 \\
(A pickle) (collapsed [collapse]) \\
PARSE: collapse ( theme = pickle ) DONE \\
 \\
(A baby) (cooked [cook]) \\
PARSE: cook ( agent = baby ) DONE \\
 \\
(A dog) (crumpled [crumple]) \\
PARSE: crumple ( theme = dog ) DONE \\
 \\
(A pig) (cried [cry]) \\
PARSE: cry ( agent = pig ) DONE \\
 \\
(A chicken) (danced [dance]) \\
PARSE: dance ( agent = chicken ) DONE \\
 \\
(A buyer) (decomposed [decompose]) \\
PARSE: decompose ( theme = buyer ) DONE \\
 \\
(A mandarin) (disintegrated [disintegrate]) \\
PARSE: disintegrate ( theme = mandarin ) DONE \\
 \\
(A bowl) (doubled [double]) \\
PARSE: double ( theme = bowl ) DONE \\
 \\
(A cat) (drew [draw]) \\
PARSE: draw ( agent = cat ) DONE \\
 \\
(A monster) (dusted [dust]) \\
PARSE: dust ( agent = monster ) DONE \\
 \\
(A boy) (ate [eat]) \\
PARSE: eat ( agent = boy ) DONE \\
 \\
(A boy) (enlarged [enlarge]) \\
PARSE: enlarge ( theme = boy ) DONE \\
 \\
(A boy) (examined [examine]) \\
PARSE: examine ( agent = boy ) DONE \\
 \\
(A girl) (floated [float]) \\
PARSE: float ( theme = girl ) DONE \\
 \\
(A melon) (froze [freeze]) \\
PARSE: freeze ( theme = melon ) DONE \\
 \\
(A resident) (frowned [frown]) \\
PARSE: frown ( agent = resident ) DONE \\
 \\
(A dog) (gasped [gasp]) \\
PARSE: gasp ( agent = dog ) DONE \\
 \\
(A chicken) (giggled [giggle]) \\
PARSE: giggle ( agent = chicken ) DONE \\
 \\
(A dog) (grew [grow]) \\
PARSE: grow ( theme = dog ) DONE \\
 \\
(A butterfly) (heard [hear]) \\
PARSE: hear ( agent = butterfly ) DONE \\
 \\
(A child) (hunted [hunt]) \\
PARSE: hunt ( agent = child ) DONE \\
 \\
(A cat) (improved [improve]) \\
PARSE: improve ( theme = cat ) DONE \\
 \\
(A boy) (inflated [inflate]) \\
PARSE: inflate ( theme = boy ) DONE \\
 \\
(A cat) (investigated [investigate]) \\
PARSE: investigate ( agent = cat ) DONE \\
 \\
(A girl) (jogged [jog]) \\
PARSE: jog ( agent = girl ) DONE \\
 \\
(A chicken) (juggled [juggle]) \\
PARSE: juggle ( agent = chicken ) DONE \\
 \\
(A penguin) (knew [know]) \\
PARSE: know ( agent = penguin ) DONE \\
 \\
(A mouse) (laughed [laugh]) \\
PARSE: laugh ( agent = mouse ) DONE \\
 \\
(A mouse) (napped [nap]) \\
PARSE: nap ( agent = mouse ) DONE \\
 \\
(A professor) (noticed [notice]) \\
PARSE: notice ( agent = professor ) DONE \\
 \\
(A bee) (nursed [nurse]) \\
PARSE: nurse ( agent = bee ) DONE \\
 \\
(A dog) (observed [observe]) \\
PARSE: observe ( agent = dog ) DONE \\
 \\
(A frog) (packed [pack]) \\
PARSE: pack ( agent = frog ) DONE \\
 \\
(A kid) (painted [paint]) \\
PARSE: paint ( agent = kid ) DONE \\
 \\
(A dog) (reddened [redden]) \\
PARSE: redden ( theme = dog ) DONE \\
 \\
(A pig) (rolled [roll]) \\
PARSE: roll ( theme = pig ) DONE \\
 \\
(A queen) (ran [run]) \\
PARSE: run ( agent = queen ) DONE \\
 \\
(A butterfly) (scoffed [scoff]) \\
PARSE: scoff ( agent = butterfly ) DONE \\
 \\
(A dog) (screamed [scream]) \\
PARSE: scream ( agent = dog ) DONE \\
 \\
(A boy) (saw [see]) \\
PARSE: see ( agent = boy ) DONE \\
 \\
(Julian) (shattered [shatter]) \\
PARSE: shatter ( theme = Julian ) DONE \\
 \\
(A cookie) (shortened [shorten]) \\
PARSE: shorten ( theme = cookie ) DONE \\
 \\
(A boy) (sketched [sketch]) \\
PARSE: sketch ( agent = boy ) DONE \\
 \\
(A soldier) (slept [sleep]) \\
PARSE: sleep ( agent = soldier ) DONE \\
 \\
(A raisin) (slid [slide]) \\
PARSE: slide ( theme = raisin ) DONE \\
 \\
(A champion) (smiled [smile]) \\
PARSE: smile ( agent = champion ) DONE \\
 \\
(A chicken) (smirked [smirk]) \\
PARSE: smirk ( agent = chicken ) DONE \\
 \\
(A donut) (snapped [snap]) \\
PARSE: snap ( theme = donut ) DONE \\
 \\
(A tenant) (sneezed [sneeze]) \\
PARSE: sneeze ( agent = tenant ) DONE \\
 \\
(A student) (snoozed [snooze]) \\
PARSE: snooze ( agent = student ) DONE \\
 \\
(A girl) (snored [snore]) \\
PARSE: snore ( agent = girl ) DONE \\
 \\
(A boy) (split [split]) \\
PARSE: split ( theme = boy ) DONE \\
 \\
(A monster) (studied [study]) \\
PARSE: study ( agent = monster ) DONE \\
 \\
(A girl) (stuttered [stutter]) \\
PARSE: stutter ( agent = girl ) DONE \\
 \\
(A crocodile) (talked [talk]) \\
PARSE: talk ( agent = crocodile ) DONE \\
 \\
(A baby) (walked [walk]) \\
PARSE: walk ( agent = baby ) DONE
}

Once the sentences are fully decomposed, COGS only contains only 9 different types of verb phrases. We select for the pool 3 examples for each of them, which adds another 27 exemplars to the pool (see below) and hence results in a pool size of 89 exemplars in total.

\prompt{(The * girl) (fed [feed]) (the * dog) (the * mandarin) \\
PARSE: feed ( agent = * girl , recipient = * dog , theme = * mandarin ) DONE \\
 \\
(The * cat) (gave [give]) (the * host) (the * yogurt) \\
PARSE: give ( agent = * cat , recipient = * host , theme = * yogurt ) DONE \\
 \\
(The * mouse) (loaned [loan]) (the * turkey) (the * chalk) \\
PARSE: loan ( agent = * mouse , recipient = * turkey , theme = * chalk ) DONE \\
 \\
(The * creature) (wired [wire]) (the * cake) to (the * giraffe) \\
PARSE: wire ( agent = * creature , theme = * cake , recipient = * giraffe ) DONE \\
 \\
(The * sailor) (gave [give]) (the * bucket) to (the * chicken) \\
PARSE: give ( agent = * sailor , theme = * bucket , recipient = * chicken ) DONE \\
 \\
(The * chicken) (brought [bring]) (the * pen) to (the * consumer) \\
PARSE: bring ( agent = * chicken , theme = * pen , recipient = * consumer ) DONE \\
 \\
(The * cat) (was awarded [award]) (the * pencil) \\
PARSE: award ( recipient = * cat , theme = * pencil ) DONE \\
 \\
(The * lion) (was given [give]) (the * cake) \\
PARSE: give ( recipient = * lion , theme = * cake ) DONE \\
 \\
(The * coach) (was lended [lend]) (the * balloon) \\
PARSE: lend ( recipient = * coach , theme = * balloon ) DONE \\
 \\
(The * frog) (was mailed [mail]) (the * ball) by (the * child) \\
PARSE: mail ( recipient = * frog , theme = * ball , agent = * child ) DONE \\
 \\
(The * dog) (was given [give]) (the * cookie) by (the * duck) \\
PARSE: give ( recipient = * dog , theme = * cookie , agent = * duck ) DONE \\
 \\
(The * prince) (was passed [pass]) (the * box) by (the * president) \\
PARSE: pass ( recipient = * prince , theme = * box , agent = * president ) DONE \\
 \\
(The * doll) (was awarded [award]) to (the * consumer) \\
PARSE: award ( theme = * doll , recipient = * consumer ) DONE \\
 \\
(The * donut) (was given [give]) to (the * teacher) \\
PARSE: give ( theme = * donut , recipient = * teacher ) DONE \\
 \\
(The * balloon) (was wired [wire]) to (the * giraffe) \\
PARSE: wire ( theme = * balloon , recipient = * giraffe ) DONE \\
 \\
(The * bat) (was given [give]) to (the * girl) by (the * governor) \\
PARSE: give ( theme = * bat , recipient = * girl , agent = * governor ) DONE \\
 \\
(The * cake) (was posted [post]) to (the * hero) by (the * donkey) \\
PARSE: post ( theme = * cake , recipient = * hero , agent = * donkey ) DONE \\
 \\
(The * block) (was given [give]) to (the * teacher) by (the * butterfly) \\
PARSE: give ( theme = * block , recipient = * teacher , agent = * butterfly ) DONE \\
 \\
(The * pig) (liked [like]) (the * zebra) \\
PARSE: like ( agent = * pig , theme = * zebra ) DONE \\
 \\
(The * baby) (missed [miss]) (the * cake) \\
PARSE: miss ( agent = * baby , theme = * cake ) DONE \\
 \\
(The * creature) (appreciated [appreciate]) (the * present) \\
PARSE: appreciate ( agent = * creature , theme = * present ) DONE \\
 \\
(The * cake) (was found [find]) by (the * teacher) \\
PARSE: find ( theme = * cake , agent = * teacher ) DONE \\
 \\
(The * seed) (was eaten [eat]) by (the * coach) \\
PARSE: eat ( theme = * seed , agent = * coach ) DONE \\
 \\
(The * donut) (was inflated [inflate]) by (Aiden) \\
PARSE: inflate ( theme = * donut , agent = Aiden ) DONE \\
 \\
(The * shirt) (was liked [like]) \\
PARSE: like ( theme = * shirt ) DONE \\
 \\
(The * rose) (was discovered [discover]) \\
PARSE: discover ( theme = * rose ) DONE \\
 \\
(The * raisin) (was frozen [freeze]) \\
PARSE: freeze ( theme = * raisin ) DONE
}


\subsubsection{Exemplar matching}
\label{app:cogs_exemplar_selection_matching}
For matching, we use essentially the same heuristics as we used for CFQ with slightly adjusted parameters. In particular, we only look at the inner-most subclause when selecting exemplars. This is sufficient because the handling of the nested subclauses and nested prepositional clauses is demonstrated with a static prompt that we provide in addition to the dynamically selected exemplars (see Section~\ref{app:cogs_solution} below).

If the inner-most subclause has a subject but no object (e.g., ``a donut snapped''), we select the exemplar for the verb of this subclause, which is either unaccuastive or unergarive. This tells the model whether the subject should be annotated as the agent or the theme (e.g., since ``snap'' is unaccusative ``a donate'' is annotated as the theme). If the inner-most subclause has both a subject and an object, we select 3 exemplars corresponding to the subclause structure.

\paragraph{Example 1.}
In our first example ``James said that a manager liked that Aiden appreciated that Emily believed that the girl was posted a cake beside a table by Olivia .'', the inner-most subclause is ``the girl was posted a cake by Olivia'', which means that we select the following three exemplars:

\prompt{Q: (The * frog) (was mailed [mail]) (the * ball) by (the * child) \\
A: PARSE: mail ( recipient = * frog , theme = * ball , agent = * child ) DONE \\
\\
Q: (The * dog) (was given [give]) (the * cookie) by (the * duck) \\
A: PARSE: give ( recipient = * dog , theme = * cookie , agent = * duck ) DONE \\
\\
Q: (The * prince) (was passed [pass]) (the * box) by (the * president) \\
A: PARSE: pass ( recipient = * prince , theme = * box , agent = * president ) DONE
}

\paragraph{Example 2.}
In our second example ``The boy shortened the donut beside the bed in the car in the garden in the can on the tree .'', the inner-most subclause is ``the boy shortened the donit'', which means that we select the following three exemplars:

\prompt{Q: (The * pig) (liked [like]) (the * zebra) \\
A: PARSE: like ( agent = * pig , theme = * zebra ) DONE \\
\\
Q: (The * baby) (missed [miss]) (the * cake) \\
A: PARSE: miss ( agent = * baby , theme = * cake ) DONE \\
\\
Q: (The * creature) (appreciated [appreciate]) (the * present) \\
A: PARSE: appreciate ( agent = * creature , theme = * present ) DONE \\
}


\subsection{COGS Solution: Details and Prompts}
\label{app:cogs_solution}

As we discussed in Section~\ref{sec:seq_solution}, we linearize the composition tree into a sequence of sentences that correspond to increasingly complex subproblems. Like with CFQ (see Section~\ref{app:cfq_solution}, this linearization is performed by a walk over the parse tree to obtain a linear sequence of well-formed sentences. For each sentence, we then query the language model using a prompt that consists of three parts.

\begin{enumerate}
    \item Static prompt context illustrating the composition of subclauses and prepositional phrases
    \item Dynamically selected exemplars as additional context
    \item Sequential subproblems.
\end{enumerate}

These parts are detailed throughout the rest of this section.

\subsubsection{Part 1: Static prompt context}
The compositions of subclauses and prepositional phrases are translated very systematically. Furthermore, because of the sequential prompting, the model only needs to perform one step of compposition at a time. As a consequence, it is sufficient to demonstrate this behavior with the following static prompt context that is used for all inputs. Noe that this prompt does not contain any nesting beyond level 2. Note that we again use a parsed version of the natural language sentences, which contain additional parentheses and other annotations that make it easier for the model to perform the translation.

\prompt{Q: (the * song) (needed [need]) (to help) \\
A: PARSE: need ( agent = * song , xcomp = help ( agent = * song ) ) DONE \\
 \\
Q: (The * camera) (hoped [hope]) (to run) \\
A: PARSE: hope ( agent = * camera , xcomp = run ( agent = * camera ) ) DONE \\
 \\
Q: (the * atom) (wanted [want]) (to hunt) \\
A: PARSE: wanted ( agent = * atom , xcomp = hunt ( agent = * atom ) ) DONE \\
 \\
Q: (a helmet) (preferred [prefer]) (to cook) \\
A: PARSE: prefer ( agent = helmet , xcomp = cook ( agent = helmet ) ) DONE \\
 \\
Q: (Fred) (expected [expect]) (to paint)  \\
A: PARSE: expect ( agent = Fred , xcomp = paint ( agent = Fred ) ) DONE \\
 \\
Q: (A camera) (intended [intend]) (to clean) \\
A: PARSE: intend ( agent = camera , xcomp = clean ( agent = camera ) ) DONE \\
 \\
Q: ((A camera) (beside) (the * song)) (intended [intend]) (to clean) \\
A: PARSE: intend ( agent = camera ( nmod . beside = * song ) , xcomp = clean ( agent = camera ( nmod . beside = * song ) ) ) DONE \\
 \\
Q: (Lucas) (liked [like]) (to eat) \\
A: PARSE: like ( agent = Lucas , xcomp = eat ( agent = Lucas ) ) DONE \\
 \\
Q: ((Lucas) (in) (the * helmet)) (liked [like]) (to eat) \\
A: PARSE: like ( agent = Lucas ( nmod . in = * helmet ) , xcomp = eat ( agent = Lucas ( nmod . in = * helmet ) ) ) DONE \\
 \\
Q: (the * atom) (returned [return]) (a camera) (Louise) \\
A: PARSE: return ( agent = * atom , recipient = camera , theme = Louise ) DONE \\
 \\
Q: ((the * atom) (beside) (the * rino)) (returned [return]) (a camera) (Louise) \\
A: PARSE: return ( agent = * atom ( nmod . beside = * rino ) , recipient = camera , theme = Louise ) DONE \\
 \\
Q: (Liam) (returned [return]) (Noah) to (the * helmet) \\
A: PARSE: return ( agent = Liam , theme = Noah , recipient = * helmet ) DONE \\
 \\
Q: (Liam) (returned [return]) (Noah) to ((the * helmet) (on) (the * atom)) \\
A: PARSE: return ( agent = Liam , theme = Noah , recipient = * helmet ( nmod . on = * atom ) ) DONE \\
 \\
Q: (the * rino) (was returned [return]) (a helmet) \\
A: PARSE: return ( recipient = * rino , theme = helmet ) DONE \\
 \\
Q: (the * rino) (was returned [return]) ((a helmet) (on) (the * camera)) \\
A: PARSE: return ( recipient = * rino , theme = helmet ( nmod . on = * camera ) ) DONE \\
 \\
Q: (Zoey) (was returned [return]) (the * song) by (the * helmet) \\
A: PARSE: return ( recipient = Zoey , theme = * song , agent = * helmet ) DONE \\
 \\
Q: (Zoey) (was returned [return]) ((the * song) (in) (the * camera)) by (the * helmet) \\
A: PARSE: return ( recipient = Zoey , theme = * song ( nmod . in = * camera ) , agent = * helmet ) DONE \\
 \\
Q: (Anna) (was returned [return]) to (the * TV) \\
A: PARSE: return ( theme = Anna , recipient = * tv ) DONE \\
 \\
Q: (Anna) (was returned [return]) to ((the * TV) (beside) (the * rino)) \\
A: PARSE: return ( theme = Anna , recipient = * tv ( nmod . beside = * rino ) ) DONE \\
 \\
Q: (A atom) (was passed [pass]) to (Nicole) by (a camera) \\
A: PARSE: pass ( theme = atom , recipient = Nicole , agent = camera ) DONE \\
 \\
Q: (A atom) (was passed [pass]) to (Nicole) by ((a camera) (in) (the * song)) \\
A: PARSE: pass ( theme = atom , recipient = Nicole , agent = camera ( nmod . in = * song ) ) DONE \\
 \\
Q: (A atom) (was wired [wire]) (a TV) by (the * song) \\
A: PARSE: wire ( recipient = atom , theme = tv , agent = * song) DONE \\
 \\
Q: (A atom) (was wired [wire]) ((a TV) (on) (the * camera)) by (the * song) \\
A: PARSE: wire ( recipient = atom , theme = tv ( nmod . on = * camera ) , agent = * song ) DONE \\
 \\
Q: (Noah) (hoped [hope]) that ((a atom) (was wired [wire]) ((a TV) (on) (the * camera)) by (the * song)) \\
A: PARSE: hope ( agent = Noah , ccomp = wire ( recipient = atom , theme = tv ( nmod . on = * camera ) , agent = * song ) ) DONE \\
 \\
Q: (a song) (ate [eat]) (the * atom) \\
A: PARSE: eat ( agent = song , theme = * atom ) DONE \\
 \\
Q: ((a song) (in) (the * camera)) (ate [eat]) (the * atom) \\
A: PARSE: eat ( agent = song ( nmod . in = * camera ) , theme = * atom ) DONE \\
 \\
Q: (The * rino) (valued [value]) that (((a song) (in) (the * camera)) (ate [eat]) (the * atom)) \\
A: PARSE: value ( agent = * rino , ccomp = eat ( agent = song ( nmod . in = * camera ) , theme = * atom ) ) DONE \\
 \\
Q: ((The * rino (beside) (the * helmet)) (valued [value]) that (((a song) (in) (the * camera)) (ate [eat]) (the * atom)) \\
A: PARSE: value ( agent = * rino ( nmod . beside = * helmet ) , ccomp = eat ( agent = song ( nmod . in = * camera ) , theme = * atom ) ) DONE
}

\subsubsection{Part 2: Dynamically selected exemplars}
After the constant prompt context, we add as additional context the exemplars that we dynamically selected for the given input using the process described in Section~\ref{app:cogs_exemplar_selection}. We provide these exemplars for both of our runnning examples in Section~\ref{app:cogs_exemplar_selection_matching} and do not repeat them here.

\subsubsection{Part 3: Sequential subproblems}
After providing the static and dynamic prompt context, we perform the sequential prompting. We start by appending to the prompt the simplest subproblem and send it as a request to the language model. We then append the model's reply before we append the next subproblem and make another request to the language model. This is done until we obtain the result for the final subproblem, which corresponds to the solution of the original problem.

\paragraph{Example 1.}
For the first example (``James said that a manager liked that Aiden appreciated that Emily believed that the girl was posted a cake beside a table by Olivia .''), this part of the prompt looks as follows. Note that the not bolded text corresponds to answers provided by the model.

\prompt{\textbf{Q: (the * girl) (was posted [post]) (a cake) by (Olivia)} \\
A: PARSE: post ( recipient = * girl , theme = cake , agent = Olivia ) DONE \\
\\
\textbf{Q: (the * girl) (was posted [post]) ((a cake) (beside) (a table)) by (Olivia)} \\
A: PARSE: post ( recipient = * girl , theme = cake ( nmod . beside = table ) , agent = Olivia ) DONE \\
\\
\textbf{Q: (Emily) (believed [believe]) that ((the * girl) (was posted [post]) ((a cake) (beside) (a table)) by (Olivia))} \\
A: PARSE: believe ( agent = Emily , ccomp = post ( recipient = * girl , theme = cake ( nmod . beside = table ) , agent = Olivia ) ) DONE \\
\\
\textbf{Q: (Aiden) (appreciated [appreciate]) that ((Emily) (believed [believe]) that ((the * girl) (was posted [post]) ((a cake) (beside) (a table)) by (Olivia)))} \\
A: PARSE: appreciate ( agent = Aiden , ccomp = believe ( agent = Emily , ccomp = post ( recipient = * girl , theme = cake ( nmod . beside = table ) , agent = Olivia ) ) ) DONE \\
\\
\textbf{Q: (a manager) (liked [like]) that ((Aiden) (appreciated [appreciate]) that ((Emily) (believed [believe]) that ((the * girl) (was posted [post]) ((a cake) (beside) (a table)) by (Olivia))))} \\
A: PARSE: like ( agent = manager , ccomp = appreciate ( agent = Aiden , ccomp = believe ( agent = Emily , ccomp = post ( recipient = * girl , theme = cake ( nmod . beside = table ) , agent = Olivia ) ) ) ) DONE \\
\\
\textbf{Q: (James) (said [say]) that ((a manager) (liked [like]) that ((Aiden) (appreciated [appreciate]) that ((Emily) (believed [believe]) that ((the * girl) (was posted [post]) ((a cake) (beside) (a table)) by (Olivia)))))} \\
A: PARSE: say ( agent = James , ccomp = like ( agent = manager , ccomp = appreciate ( agent = Aiden , ccomp = believe ( agent = Emily , ccomp = post ( recipient = * girl , theme = cake ( nmod . beside = table ) , agent = Olivia ) ) ) ) ) DONE
}

\paragraph{Example 2.}
For the second example (``The boy shortened the donut beside the bed in the car in the garden in the can on the tree .''), the sequential part of the prompt looks as follows.

\prompt{\textbf{Q: (The * boy) (shortened [shorten]) (the * donut)} \\
A: PARSE: shorten ( agent = * boy , theme = * donut ) DONE \\
\\
\textbf{Q: (The * boy) (shortened [shorten]) ((the * donut) (beside) (the * bed))} \\
A: PARSE: shorten ( agent = * boy , theme = * donut ( nmod . beside = * bed ) ) DONE \\
\\
\textbf{Q: (The * boy) (shortened [shorten]) ((the * donut) (beside) ((the * bed) (in) (the * car)))} \\
A: PARSE: shorten ( agent = * boy , theme = * donut ( nmod . beside = * bed ( nmod . in = * car ) ) ) DONE \\
\\
\textbf{Q: (The * boy) (shortened [shorten]) ((the * donut) (beside) ((the * bed) (in) ((the * car) (in) (the * garden))))} \\
A: PARSE: shorten ( agent = * boy , theme = * donut ( nmod . beside = * bed ( nmod . in = * car ( nmod . in = * garden ) ) ) ) DONE \\
\\
\textbf{Q: (The * boy) (shortened [shorten]) ((the * donut) (beside) ((the * bed) (in) ((the * car) (in) ((the * garden) (in) (the * can)))))} \\
A: PARSE: shorten ( agent = * boy , theme = * donut ( nmod . beside = * bed ( nmod . in = * car ( nmod . in = * garden ( nmod . in = * can ) ) ) ) ) DONE \\
\\
\textbf{Q: (The * boy) (shortened [shorten]) ((the * donut) (beside) ((the * bed) (in) ((the * car) (in) ((the * garden) (in) ((the * can) (on) (the * tree))))))} \\
A: PARSE: shorten ( agent = * boy , theme = * donut ( nmod . beside = * bed ( nmod . in = * car ( nmod . in = * garden ( nmod . in = * can ( nmod . on = * tree ) ) ) ) ) ) DONE
}


\section{Chain-of-thought Prompting for CFQ}

This section includes the chain-of-thought prompts introduced in Section~\ref{sec:cot}. A prompt in chain-of-thought format includes intermediate steps that are processed before predicting the final answer. Although the exemplars include these intermediate steps already, the model must predict the steps for new input. Also, it is assumed that the exemplar pool has not previously been annotated with chain-of-thought, so a procedure to bootstrap these chain-of-thought (also called rationale) is required. In practice, we can do this by annotating a small set of exemplars (in our case 5), then using these to teach the model to predict new chain-of-thought through prompting. The prompt we use for bootstrapping is in Appendix~\ref{app:cfq_cot_bootsrap_prompt}.

For evaluation, we use prompts including a mix of exemplars, some in chain-of-thought format, and the rest in vanilla format, this allows us to keep the prompt relatively short, since chain-of-thought can be verbose, often the same length or longer than the original exemplar. An example chain-of-thought prompt uused in evaluation is shown in Appendix~\ref{app:cfq_cot_prompt}. Note, the vanilla few-shot prompts we use are similar but only includes exemplars in the vanilla format.

We only evaluate chain-of-thought and vanilla few-shot prompting against CFQ, not COGS.

\subsection{Bootstrap Prompt \label{app:cfq_cot_bootsrap_prompt}}

This is a hybrid prompt containing 15 vanilla input/output exemplars selected by bag-of-words similarity with the input, and a static set of 5 exemplars manually annotated in the chain-of-thought format. This prompt is used to generate new chain-of-thought for the rest of the exemplar pool. An example is shown below in reduced font size, since the chain-of-thought can be verbose.

\begin{lstlisting}
# SQL Dataset:

input: Who was a actor that M2 starred and M3 was directed by

output: SELECT DISTINCT ?x0 WHERE { ?x0 a actor . ?x0 a person . ?x0 starred_in M2 . ?x0 directed M3 }

input: Were M2 and M4 edited by a male sibling of M0 and directed by M3

output: SELECT count(*) WHERE { ?x0 has_gender male . ?x0 sibling_of M0 . M2 directed_by M3 . M2 edited_by ?x0 . M4 directed_by M3 . M4 edited_by ?x0 }

input: Who was a Swedish actor that M3 married and M4 's producer influenced

output: SELECT DISTINCT ?x0 WHERE { ?x0 a actor . ?x0 a person . ?x0 influenced_by ?x1 . ?x0 has_nationality Swedish . ?x0 married_to M3 . ?x1 produced M4 }

input: What was produced and directed by a cinematographer 's Chinese sibling

output: SELECT DISTINCT ?x0 WHERE { ?x0 directed_by ?x1 . ?x0 produced_by ?x1 . ?x1 has_nationality Chinese . ?x1 sibling_of ?x2 . ?x2 a cinematographer }

input: Who was a film director that M2 was influenced by and a founder of M3 and M4 was influenced by

output: SELECT DISTINCT ?x0 WHERE { ?x0 a film_director . ?x0 a person . ?x0 influenced ?x1 . ?x0 influenced M2 . ?x1 founded M3 . ?x1 founded M4 }

input: Did M2 and M4 influence M3 , influence M0 's child , and influence a cinematographer 's sibling 's spouse

output: SELECT count(*) WHERE { ?x0 child_of M0 . ?x1 married_to ?x2 . ?x2 sibling_of ?x3 . ?x3 a cinematographer . M2 influenced ?x0 . M2 influenced ?x1 . M2 influenced M3 . M4 influenced ?x0 . M4 influenced ?x1 . M4 influenced M3 }

input: Who married , influenced , and was influenced by a cinematographer that M2 was directed by and starred

output: SELECT DISTINCT ?x0 WHERE { ?x0 a person . ?x0 influenced ?x1 . ?x0 influenced_by ?x1 . ?x0 married_to ?x1 . ?x1 a cinematographer . ?x1 starred_in M2 . ?x1 directed M2 }

input: What was written by and directed by a female sibling of a cinematographer of M1

output: SELECT DISTINCT ?x0 WHERE { ?x0 directed_by ?x1 . ?x0 written_by ?x1 . ?x1 has_gender female . ?x1 sibling_of ?x2 . ?x2 cinematographer_of M1 }

input: Who influenced , married , and was influenced by a actor that edited M2 and directed M3

output: SELECT DISTINCT ?x0 WHERE { ?x0 a person . ?x0 influenced ?x1 . ?x0 influenced_by ?x1 . ?x0 married_to ?x1 . ?x1 a actor . ?x1 directed M3 . ?x1 edited M2 }

input: Was M2 directed by M3 and M4 and written by a male sibling of M0

output: SELECT count(*) WHERE { ?x0 has_gender male . ?x0 sibling_of M0 . M2 directed_by M3 . M2 directed_by M4 . M2 written_by ?x0 }

input: Who was influenced by M1 , influenced by M4 's producer , cinematographer , and director , and influenced by M2 and M3

output: SELECT DISTINCT ?x0 WHERE { ?x0 a person . ?x0 influenced_by ?x1 . ?x0 influenced_by M1 . ?x0 influenced_by M2 . ?x0 influenced_by M3 . ?x1 cinematographer_of M4 . ?x1 directed M4 . ?x1 produced M4 }

input: Were M2 , M3 , M4 , M5 , and M6 influenced by a Spanish spouse of M1

output: SELECT count(*) WHERE { ?x0 has_nationality Spanish . ?x0 married_to M1 . M2 influenced_by ?x0 . M3 influenced_by ?x0 . M4 influenced_by ?x0 . M5 influenced_by ?x0 . M6 influenced_by ?x0 }

input: Were M2 and M3 directed by and edited by a cinematographer 's French parent

output: SELECT count(*) WHERE { ?x0 parent_of ?x1 . ?x0 has_nationality French . ?x1 a cinematographer . M2 directed_by ?x0 . M2 edited_by ?x0 . M3 directed_by ?x0 . M3 edited_by ?x0 }

input: Who was a film producer whose sibling directed M3 and edited M2

output: SELECT DISTINCT ?x0 WHERE { ?x0 a film_producer . ?x0 a person . ?x0 sibling_of ?x1 . ?x1 directed M3 . ?x1 edited M2 }

## Example Parsings:

Query: What was executive produced by , directed by , and edited by M1 's male spouse
Query Type: What => DISTINCT
There is an entity (?x0) => ?x0 a entity
?x0 is executive produced by M1's male spouse => ?x0 executive_produced_by ?x1, ?x1 has_gender male, ?x1 married_to M1
?x0 is directed by M1's male spouse => ?x0 directed_by ?x1
?x0 is edited by M1's male spouse => ?x0 edited_by ?x1

So the parse of this query is:
Parse: SELECT DISTINCT ?x0 WHERE { ?x0 directed_by ?x1 . ?x0 edited_by ?x1 . ?x0 executive_produced_by ?x1 . ?x1 has_gender male . ?x1 married_to M1 }


Query: Were M0 , M4 , M5 , M6 , and M7 directed by M3 , executive produced by M1 , and written by M2
Query Type: were/was => count(*)
M0 is directed by M3 => M0 directed_by M3
M0, M4, M5, M6 is executive produced by M1 => M0 executive_produced_by M1, M4 executive_produced_by M1, M5 executive_produced_by M1, M6 executive_produced_by M1, M7 executive_produced_by M1
M0, M4, M5, M6 is written by M2 => M0 written_by M2, M4 written_by M2, M5 written_by M2, M6 written_by M2
M0, M4, M5, M6 is directed by M3 => M0 directed_by M3, M4 directed_by M3, M5 directed_by M3, M6 directed_by M3

So the parse of this query is:
Parse: SELECT count(*) WHERE { M0 directed_by M3 . M0 executive_produced_by M1 . M0 written_by M2 . M4 directed_by M3 . M4 executive_produced_by M1 . M4 written_by M2 . M5 directed_by M3 . M5 executive_produced_by M1 . M5 written_by M2 . M6 directed_by M3 . M6 executive_produced_by M1 . M6 written_by M2 . M7 directed_by M3 . M7 executive_produced_by M1 . M7 written_by M2 }


Query: Was a Japanese screenwriter whose parent played M0 and M1 M2
Query Type: was/were => count(*)
There is a Japanese screenwriter (?x0) => ?x0 a writer, ?x0 has_nationality Japanese
?x0's parent is ?x1 => ?x0 child_of ?x1
?x1 played M0 and M1 => ?x1 portrayed M0, ?x1 portrayed M1

So the parse of this query is:
Parse: SELECT count(*) WHERE { ?x0 portrayed M0 . ?x0 portrayed M1 . M2 a writer . M2 has_nationality Japanese . M2 child_of ?x0 }


Query: Was M1 produced by M0 's editor and art director , produced by M3 and M4 , and distributed by M2
Query Type: was/were => count(*)
There is an editor (?x0) of M0 => ?x0 edited M0
?x0 is art director of M0 => ?x0 art_directed M0
M1 is distributed by M2 => M1 distributed_by M2
M1 is produced by ?x0 => M1 produced_by ?x0
M1 is produced by M3 => M1 produced_by M3
M1 is produced by M4 => M1 produced_by M4

So the parse of this query is:
Parse: SELECT count(*) WHERE { ?x0 edited M0 . ?x0 art_directed M0 . M1 distributed_by M2 . M1 produced_by ?x0 . M1 produced_by M3 . M1 produced_by M4 }

Query: Was a film producer 's child founded by M0 and M1
Query Type: was/were => count(*)
There is a child (?x0) of film producer (?x1) => ?x0 child_of ?x1, ?x1 a film_producer
?x0 is founded by M0 and M1 => ?x0 founded_by M0, ?x0 founded_by M0

So the parse of this query is:
Parse: SELECT count(*) WHERE { ?x0 founded_by M0 . ?x0 founded_by M1 . ?x0 child_of ?x1 . ?x1 a film_producer }


Query: Who was a French cinematographer whose sibling directed M3 and M4
Query Type:
\end{lstlisting}

\subsection{Prediction Prompt \label{app:cfq_cot_prompt}}

This is an example of the chain-of-thought prompt used to predict semantic parse output on evaluation data. It includes 10 exemplars in the vanilla input/output format, then 5 exemplars in the chain-of-thought format. The example is shown below in reduced font size, since the chain-of-thought can be verbose.

\begin{lstlisting}
input: Were M2 and M3 written by M0 's producer 's employer 's founder and edited by a screenwriter
output: SELECT count(*) WHERE { ?x0 founded ?x1 . ?x1 employed ?x2 . ?x2 produced M0 . ?x3 a writer . M2 edited_by ?x3 . M2 written_by ?x0 . M3 edited_by ?x3 . M3 written_by ?x0 }


input: Was M2 executive produced by M3 , edited by a film editor , and edited by M0 's producer , executive producer , and writer
output: SELECT count(*) WHERE { ?x0 executive_produced M0 . ?x0 produced M0 . ?x0 wrote M0 . ?x1 a film_editor . M2 edited_by ?x0 . M2 edited_by ?x1 . M2 executive_produced_by M3 }


input: Was M2 founded by a screenwriter 's French parent and founded by M3
output: SELECT count(*) WHERE { ?x0 parent_of ?x1 . ?x0 has_nationality French . ?x1 a writer . M2 founded_by ?x0 . M2 founded_by M3 }


input: Was a French film producer that was employed by M2 M0
output: SELECT count(*) WHERE { M0 a film_producer . M0 employed_by M2 . M0 has_nationality French }


input: Was M2 executive produced by and written by a screenwriter 's Italian sibling
output: SELECT count(*) WHERE { ?x0 has_nationality Italian . ?x0 sibling_of ?x1 . ?x1 a writer . M2 executive_produced_by ?x0 . M2 written_by ?x0 }


input: Were M2 and M5 founded by M3 and M4 , founded by a screenwriter , and founded by M1 's executive producer
output: SELECT count(*) WHERE { ?x0 a writer . ?x1 executive_produced M1 . M2 founded_by ?x0 . M2 founded_by ?x1 . M2 founded_by M3 . M2 founded_by M4 . M5 founded_by ?x0 . M5 founded_by ?x1 . M5 founded_by M3 . M5 founded_by M4 }


input: Did M2 marry a screenwriter , marry M3 , and influence M0 's producer
output: SELECT count(*) WHERE { ?x0 produced M0 . ?x1 a writer . M2 influenced ?x0 . M2 married_to ?x1 . M2 married_to M3 }


input: Was M1 produced by M2 , edited by a film producer 's employee and founder , and directed by M3
output: SELECT count(*) WHERE { ?x0 founded ?x1 . ?x0 employed_by ?x1 . ?x1 a film_producer . M1 directed_by M3 . M1 edited_by ?x0 . M1 produced_by M2 }


input: Was M1 executive produced by a producer of M0 's prequel and written by M2
output: SELECT count(*) WHERE { ?x0 produced ?x1 . ?x1 has_sequel M0 . M1 executive_produced_by ?x0 . M1 written_by M2 }


input: Was M1 employed by M2 and employed by a film 's producer and distributor
output: SELECT count(*) WHERE { ?x0 distributed ?x1 . ?x0 produced ?x1 . ?x1 a film . M1 employed_by ?x0 . M1 employed_by M2 }


Query: Was a screenwriter 's British parent 's parent M2
Query Type: was/were => count(*)
There is a screenwriter (?x0) => ?x0 a writer
?x0's parent is ?x1 => ?x0 parent_of ?x1
?x1 is British => ?x1 has_nationality British
?x1's parent is M2 => M2 parent_of ?x1

So the parse of this query is:
Parse: SELECT count(*) WHERE { ?x0 parent_of ?x1 . ?x0 has_nationality British . ?x1 a writer . M2 parent_of ?x0 }


Query: Was M2 edited by a Swedish film producer 's spouse and written by M3
Query Type: was/were => count(*)
There is a Swedish film producer (?x0) => ?x0 a film_producer, ?x0 has_nationality Swedish
?x0's spouse is ?x1 => ?x0 married_to ?x1
M2 is edited by ?x1 => M2 edited_by ?x1
M2 is written by M3 => M2 written_by M3

So the parse of this query is:
Parse: SELECT count(*) WHERE { ?x0 married_to ?x1 . ?x1 a film_producer . ?x1 has_nationality Swedish . M2 edited_by ?x0 . M2 written_by M3 }


Query: Was M2 a film written by M4 and directed by M0 's male executive producer
Query Type: was/were => count(*)
There is a male executive producer (?x0) of M0 => ?x0 executive_produced M0, ?x0 has_gender male
M2 is directed by ?x0 => M2 directed_by ?x0
M2 is written by M4 => M2 written_by M4
M2 is a film => M2 a film

So the parse of this query is:
Parse: SELECT count(*) WHERE { ?x0 executive_produced M0 . ?x0 has_gender male . M2 a film . M2 directed_by ?x0 . M2 written_by M4 }


Query: Was a film producer influenced by a costume designer 's sibling and influenced by M1 and M2
Query Type: was/were => count(*)
There is a film producer (?x0) => ?x0 a film_producer
?x0 is influenced by a costume designer's sibling (?x1) => ?x0 influenced_by ?x1, ?x1 sibling_of ?x2, ?x2 a costume_designer
?x0 is influenced by M1 => ?x0 influenced_by M1
?x0 is influenced by M2 => ?x0 influenced_by M2

So the parse of this query is:
Parse: SELECT count(*) WHERE { ?x0 a film_producer . ?x0 influenced_by ?x1 . ?x0 influenced_by M1 . ?x0 influenced_by M2 . ?x1 sibling_of ?x2 . ?x2 a costume_designer }


Query: Was M3 produced by a Mexican film producer and produced by M2 's star 's spouse 's sibling
Query Type: was/were => count(*)
There is a Mexican film producer (?x0) => ?x0 a film_producer, ?x0 has_nationality Mexican
?x0 is produced by M2's star's spouse's sibling (?x1) => ?x1 sibling_of ?x2, ?x2 married_to ?x3, ?x3 starred_in M2, M3 produced_by ?x0, M3 produced_by ?x1

So the parse of this query is:
Parse: SELECT count(*) WHERE { ?x0 a film_producer . ?x0 has_nationality Mexican . ?x1 sibling_of ?x2 . ?x2 married_to ?x3 . ?x3 starred_in M2 . M3 produced_by ?x0 . M3 produced_by ?x1 }


Query: Was a screenwriter M2 's French producer
Query Type:
\end{lstlisting}

\begin{table}[h]
    \centering
    \tiny
    \begin{tabular}{l|l}
         ns:organization.organization.companies\_acquired/ns:business.acquisition.company\_acquired	& acquired \\
ns:organization.organization.acquired\_by/ns:business.acquisition.acquiring\_company	& acquired\_by \\
ns:film.actor.film/ns:film.performance.film	& starred\_in \\
ns:film.film\_art\_director.films\_art\_directed	& art\_directed \\
ns:film.film.film\_art\_direction\_by	& art\_direction\_by \\
ns:people.person.parentsns:fictional\_universe.fictional\_character.parents|ns:organization.organization.parent/ns:orga & child\_of \\
ns:film.cinematographer.film	& cinematographer\_of \\
ns:film.film.cinematography	& cinematography\_by \\
ns:film.film\_costumer\_designer.costume\_design\_for\_film	& costume\_designed \\
ns:film.film.costume\_design\_by	& costume\_designed\_by \\
ns:film.director.film	& directed \\
ns:film.film.directed\_by	& directed\_by \\
ns:film.film\_distributor.films\_distributed/ns:film.film\_film\_distributor\_relationship.film	& distributed \\
ns:film.film.distributors/ns:film.film\_film\_distributor\_relationship.distributor	& distributed\_by \\
ns:film.editor.film	& edited \\
ns:film.film.edited\_by	& edited\_by \\
ns:business.employer.employees/ns:business.employment\_tenure.person	& employed \\
ns:people.person.employment\_history/ns:business.employment\_tenure.company	& employed\_by \\
ns:film.producer.films\_executive\_produced	& executive\_produced \\
ns:film.film.executive\_produced\_by	& executive\_produced\_by \\
ns:organization.organization\_founder.organizations\_founded	& founded \\
ns:organization.organization.founders	& founded\_by \\
\^ns:people.person.gender	& gender\_of \\
ns:film.actor.film/ns:film.performance.character	& portrayed \\
ns:people.person.gender	& has\_gender \\
ns:people.person.nationality	& has\_nationality \\
ns:film.film.prequel	& has\_prequel \\
ns:film.film.sequel	& has\_sequel \\
ns:influence.influence\_node.influenced	& influenced \\
ns:influence.influence\_node.influenced\_by	& influenced\_by \\
ns:people.person.spouse\_s/ns:people.marriage.spousens:fictional\_universe.fictional\_character.married\_to/ns:fictiona	& married\_to \\
\^ns:people.person.nationality	& nationality\_of \\
ns:people.person.childrenns:fictional\_universe.fictional\_character.childrenns:organization.organization.child/ns:org	& parent\_of \\
ns:film.producer.filmns:film.production\_company.films	& produced \\
ns:film.film.produced\_byns:film.film.production\_companies	& produced\_by \\
ns:people.person.sibling\_s/ns:people.sibling\_relationship.siblingns:fictional\_universe.fictional\_character.siblings	& sibling\_of \\
ns:film.film.starring/ns:film.performance.actor	& starred \\
ns:film.film.written\_by	& written\_by \\
ns:film.writer.film	& wrote \\
ns:film.actor	& actor \\
ns:film.film\_art\_director	& art\_director \\
ns:film.cinematographer	& cinematographer \\
ns:film.film\_costumer\_designer	& costume\_designer \\
ns:film.director	& film\_director \\
ns:film.editor	& film\_editor \\
ns:business.employer	& employer \\
ns:fictional\_universe.fictional\_character	& fictional\_character \\
ns:film.film	& film \\
ns:film.film\_distributor	& film\_distributor \\
ns:people.person	& person \\
ns:film.producer	& film\_producer \\
ns:film.production\_company	& production\_company \\
ns:film.writer	& writer \\
    \end{tabular}
    \caption{Mapping of freebase IDs (truncated to 120 characters) to human-readable strings. We apply this to CFQ to make the task more feasible for prompting.}
    \label{tab:cfq_mapping}
\end{table}

\section{Data Preparation, Evaluation, and Hyperparameters}
\label{app:data_prep_eval_hyper}

\subsection{CFQ Processing and Evaluation} 

To make the CFQ benchmark more appropriate for processing with large language models we use the processing steps and evaluation method detailed below. We verified that these steps do not alter the performance for fully supervised methods by reproducing experiments with T5-base. The results match previously published results within 1-2 points on MCD1, MCD2, and MCD3.

\subsubsection{CFQ Preprocessing \label{app:cfq_preprocessing}}

To prepare the CFQ data we apply two preprocessing steps:

\begin{enumerate}
    \item We replace excessively long freebase identifiers with human-readable strings (see Table~\ref{tab:cfq_mapping}).
    \item We strip FILTER statements because they always appear with the ``sibling\_of'' and ``married\_to'' properties, and would be trivial to add to the output after prediction (i.e., they can be considered to be part of the abbreviated property). For example, if ``?x0 married\_to M0'' appeared then so would ``FILTER(?x0 != M0)''. Essentially, one can not be married to themselves, nor a sibling of themselves.
\end{enumerate}

\subsubsection{CFQ Postprocessing and Evaluation \label{app:cfq_postprocessing}}

For CFQ, we apply the following post-processing to both gold and predicted semantic parses.

\begin{enumerate}
    \item \textit{Clause sanitization}: We discard any malformed clause. To measure well-formedness we check all of the following. (a) A clause should have 3 white-space separated tokens; (b) A clause should either have ``a'' as its second token or a string, so symbols such as ``='' can be safely discard.
    \item \textit{Inverse properties}: For properties that have an official inverse property in Freebase (e.g. ``directed'' vs. ``directed\_by'') we deterministically pick one of its variants and flip the arguments if needed. However, note that in some error cases the model will predict ``sequel\_of'' which does not get corrected since ``sequel\_of'' is not in the original property vocabulary, only ``has\_sequel'' and ``has\_prequel''.
    \item \textit{Argument ordering}: For clauses that are bidirectional (``sibling\_of'', ``married\_to''), we sort the arguments alphabetically.
    \item \textit{Statement ordering}: Since order does not matter in SPARQL statements, we sort statements alphabetically.
    \item \textit{Variable normalization}: Since variable labels are arbitrary (?x0, ?x1, etc.) in SPARQL, we re-label the variables so that they appear in increasing order, ``SELECT ?x1 \{ ?x2 directed ?x1 . ?x1 influenced ?x0 \}'' gets converted to ``SELECT ?x0 \{ ?x1 directed ?x0 . ?x0 influenced ?x2 \}''. We alternate running \textit{variable normalization} and \textit{statement ordering} until no change is detected, since re-labeling variables might impact the sort order of clauses.
    \item \textit{Stripping of implied types}: CFQ is constructed such that types that are directly implied by a accompanied relation are dropped from the SPARQL even if these types are explicitly mentioned in the natural language question. For example, the clause ``?x0 a actor'' is dropped from the translation of the question ``Did a male actor play M0 and play M1'' because the relation ``?x0 portrayed M0'' implies that ?x0 has type actor. For a pretrained language model, this is quite unnatural and hurts accuracy even though keeping the type leads to a SPARQL query that has the is semantically equivalent. We therefore strip implied types when they're predicted by the language model.
\end{enumerate}

After completing these steps, we do the standard approach and measure accuracy using exact string match. 

\subsection{COGS Postprocessing and Evaluation \label{app:cogs_postprocessing}}
For longer outputs, the language model sometimes fails to match closing parentheses. When this happens, we add closing parentheses at the end of output until all opening parenthesis are matched. This trivial fix improved exact match accuracy on COGS generalization test set from 97.8\% to 99.2\%.

It's worth noting 50 examples in the original COGS generalization test set are mislabeled (the authors have since released a new version). We evaluate using the original data in order to compare with previous work. One would not expect a model to accurately predict the idiosyncrasies associated with the mislabeled data, so upper bound on performance for the generalization test should be about 99.7\% accuracy.

\subsection{Hyperparameters \label{app:hyperparams}}

There are two sets of hyperparameters, those for prompts and those for generation. We performed initial minimal hyperparameter tuning using a 100-sentence subset of the validation data.

\subsubsection{Prompt Hyperparameters}

\paragraph{Dynamic Least-to-Most} Described in Section \ref{sec:dynamic_l2m}.

\begin{itemize}
    \item Number of Static Exemplars = 12 for CFQ, 28 for COGS
    \item Number of Dynamic Exemplars = 4-35 for CFQ, between 1-3 for COGS (these are determined automatically based on the decomposition tree)
    \item Number of Exemplar Lists = 1
    \item Number of Generations per List = 1
    \item Generation Mode = Greedy
\end{itemize}

\paragraph{Chain-of-Thought}

Selects exemplars according to bag-of-words similarity (Section \ref{sec:factored_search}), but to be effective, at least some of the exemplars must use rationale. To keep the prompt compact, we use a hybrid approach where 5 exemplars are in chain-of-thought format and the rest are vanilla.

The original data does not have alignments, so we need to manually create some chain-of-thought exemplars which we can then use to generate chain-of-thought for the full exemplar pool \citep{zelikman2022star}. In our case, we manually labeled 5 sentences with chain-of-thought, then appended these to the 15 exemplars we already retrieve for each sentence. We did this to predict chain-of-thought for the exemplar pool, and discarded any chain-of-thought that did not produce the correct semantic parse. 884 out of 1000 successfully predicted the correct semantic parse. When constructing chain-of-thought prompts, we only represent an exemplar with chain-of-thought if it succeeded in this previous step, otherwise we use its vanilla format.

\begin{itemize}
    \item Bootstrap Pool Size = 5
    \item Number of Exemplars per List () = 15
    \item Number of Exemplar Lists () = 4
    \item Number of Generations per List () = 4
    \item Generation Mode = Sample
    \item Number of Chain-of-Thought Exemplars = 5 (the other 10 are in vanilla format)
\end{itemize}

\paragraph{Vanilla Few-Shot}

Vanilla few-shot is a simple input/output exemplar-based prompts. The exemplars are chosen identically as chain-of-thought.

\begin{itemize}
    \item Number of Exemplars per List () = 15
    \item Number of Exemplar Lists () = 4
    \item Number of Generations per List () = 4
    \item Generation Mode = Sample
\end{itemize}

\subsubsection{Generation Hyperparameters}

We did not require any extensive search over these hyperparamters. We tried reasonable settings based on previously published works, and the only real toggle here is temperature, which wasn't used at all by dynamic least-to-most.

\begin{itemize}
    \item Model = \texttt{code-davinci-002}
    \item Temperature = 0.7 when sampling, or 0.0 when greedy.
    \item Top-P = 1.0
    \item Presence Penalty = 0
    \item Frequency Penalty = 0
\end{itemize}

\section{Additional Analysis}
\label{app:additional_analysis}

\subsection{Initial Prompting Attempts for CFQ \label{app:cfq_initial}}

We initially tried various prompting attempts for CFQ where we did not provide any examples as part of the context. Instead, we provided an instruction along the lines of, ``Translate English to SPARQL''. While the language model was still able to produce SPARQL-like output, it scored 0\% accuracy on CFQ. This indicates that the language model was exposed to SPARQL in pretraining but has not seen or memorized specific CFQ examples.

{\small
\begin{verbatim}
# Translate English to SPARQL. 

English: What did a production company 's Japanese founder direct , edit ,
    and executive produce
SPARQL:
```
SELECT ?director ?editor ?executive_producer
WHERE {
  ?director a dbo:FilmDirector .
  ?director dbo:nationality dbr:Japan .
  ?director dbo:birthPlace dbr:Japan .
  ?director dbo:birthDate ?birthDate .
  FILTER (?birthDate < "1940-01-01T00:00:00Z"^^xsd:dateTime)
  ?director dbo:film ?film .
  ?film dbo:editor ?editor .
  ?film dbo:executiveProducer ?executive_producer .
}
```
\end{verbatim}
}


\begin{table}[h]
\setlength\tabcolsep{4pt}
\begin{center}
\begin{tabular}{ l | c | c c c c }
\toprule
 & ~~Acc.~~ & \parbox[c]{15mm}{\centering Type} & 
\parbox[c]{15mm}{\centering Cartesian \\ product} &
\parbox[c]{15mm}{\centering Property \\ direction} & 
\parbox[c]{15mm}{\centering Entity \\ reference} \\
\midrule
Decomposition-based exemplars & 55 & 24 & 11 & 3 & 3 \\
\ + Decomposition hints & 67 & 18 & 10 & 2 & 3 \\
\ + Least-to-most prompting   & 83 & 15 & 0  & 2 & 0 \\
\ + CoT grounding   & 99 & 0  & 0  & 1 & 0 \\
\bottomrule
\end{tabular}
\end{center}
\caption{Accuracy and error error frequency on a 100-example subset of MCD1 validation for various ablations of dynamic-least-to-most prompting. Note: We only use CoT grounding for CFQ.}
\label{tab:ablation_l2m}
\end{table}


\subsection{Dynamic Least-to-most Prompting on CFQ: Ablations and Error Analysis}
\label{app:l2m_ablations_error_analysis}

During the development of dynamic least-to-most prompting, we performed a qualitative error analysis for various ablations on a 100-example subset of the CFQ validation set (MCD1 split). This provides us with interesting insights about the impact of different components that make up the dynamic least-to-most prompting technique. We compare the following 4 setups:

\begin{enumerate}
    \item \textbf{Decomposition-based exemplar retrieval.} We use the decomposition to retrieve the exemplars, then execute a vanilla few-shot prompt. We do not perform any form of sequential least-to-most prompting.
    
    \item \textbf{+ Decomposition hints.} Same as above, but adds brackets to sentences indicating compositional structure and hinting at relations between exemplars (see Appendix~\ref{app:l2m_cfq} for examples).
    
    \item \textbf{+ Least-to-most prompting.} Adds sequential least-to-most prompting, including subproblems in the prompt that were used to select the exemplars.
    
    \item \textbf{+ Chain-of-thought (CoT) grounding.} A constant prompt prefix with basic subproblems solved in a chain-of-thought-like way. This corresponds to the full implementation of dynamic least-to-most prompting, also described in Appendix~\ref{app:cfq_solution} with concrete examples.
\end{enumerate}

Table~\ref{tab:ablation_l2m} shows the accuracy and error types associated with these setups. We observe that the most basic approach using decomposition-based exemplar retrieval only achieves 55\% accuracy. The majority of the errors (24) are caused by unnecessary or missing types and by incorrect expansion of cartesian products (11). Adding decomposition hints in form of parentheses to the question eliminates some of the errors across the board and achieves 67\% accuracy.

Adding least-to-most prompting further increases accuracy to 83\%. The error analysis shows that this mostly because it eliminates all the errors related to cartesian products. Finally, adding CoT grounding pushes the accuracy to 99\%, which is mostly due to eliminating type errors.

Below are examples to illustrate the different error types.

\paragraph{Unnecessary or missing types}

\prompt{\\
\\
\textbf{Question:} What Dutch spouse of M2 was M0 's employee and founder\\
\textbf{Answer:} SELECT DISTINCT ?x0 WHERE \{ \textbf{?x0 a person} . ?x0 married\_to M2 . ?x0 founded M0 . ?x0 employed\_by M0 . ?x0 has\_nationality Dutch \} \\
\textbf{Golden:} SELECT DISTINCT ?x0 WHERE \{ ?x0 founded M0 . ?x0 employed\_by M0 . ?x0 has\_nationality Dutch . ?x0 married\_to M2\}\\
\\
\textbf{Question:} Who was a writer , costume designer , editor , and star of M1 and M2\\
\textbf{Answer:} SELECT DISTINCT ?x0 WHERE \{ ?x0 starred\_in M1 . ?x0 starred\_in M2 . ?x0 wrote M1 . ?x0 wrote M2 . ?x0 edited M1 . ?x0 edited M2 . ?x0 costume\_designed M1 . ?x0 costume\_designed M2 \}\\
\textbf{Golden:} SELECT DISTINCT ?x0 WHERE \{ \textbf{?x0 a person} . ?x0 starred\_in M1 . ?x0 starred\_in M2 . ?x0 edited M1 . ?x0 edited M2 . ?x0 costume\_designed M1 . ?x0 costume\_designed M2 . ?x0 wrote M1 . ?x0 wrote M2 \}
}

\paragraph{Incorrect cartesian product}

\prompt{\\
\\
\textbf{Question:} Did M1 's costume designer , cinematographer , director , art director , producer , and editor produce , write , and edit M0\\
\textbf{Answer:} SELECT count(*) WHERE \{ ?x0 directed M1 . ?x0 executive\_produced M0 . ?x0 edited M0 . ?x0 wrote M0 . ?x0 cinematographer\_of M1 . ?x0 costume\_designed M1 . ?x0 produced M1 \} \\
\textbf{Golden:} SELECT count(*) WHERE \{ ?x0 cinematographer\_of M1 . \textbf{?x0 directed M0} . ?x0 directed M1 . ?x0 edited M0 . ?x0 costume\_designed M1 . ?x0 executive\_produced M0 . ?x0 produced M1 . ?x0 wrote M0 \}\\
\\
\textbf{Question:} Did M2 's editor , director , star , art director , and cinematographer produce , direct , and edit M0 and M1\\
\textbf{Answer:} SELECT count(*) WHERE \{ ?x0 edited M0 . ?x0 edited M1 . ?x0 directed M0 . ?x0 directed M1 . ?x0 produced M0 . ?x0 produced M1 . ?x0 starred\_in M2 . ?x0 art\_directed M2 . ?x0 cinematographer\_of M2 \}\\
\textbf{Golden:} SELECT count(*) WHERE \{ ?x0 starred\_in M2 . ?x0 cinematographer\_of M2 . ?x0 directed M0 . ?x0 directed M1 . \textbf{?x0 directed M2} . ?x0 edited M0 . ?x0 edited M1 . \textbf{?x0 edited M2} . ?x0 art\_directed M2 . ?x0 produced M0 . ?x0 produced M1 \}
}

\paragraph{Wrong property direction}
\prompt{\\
\\
\textbf{Question:} Which actor that a cinematographer was influenced by was M1 's spouse\\
\textbf{Answer:} SELECT DISTINCT ?x0 WHERE \{ ?x0 a actor . ?x0 married\_to M1 . \textbf{?x0 influenced\_by ?x1} . ?x1 a cinematographer \} \\
\textbf{Golden:} SELECT DISTINCT ?x0 WHERE \{ ?x0 a actor . \textbf{?x0 influenced ?x1} . ?x0 married\_to M1 . ?x1 a cinematographer \}
}

\paragraph{Mixing up entities}
\prompt{\\
\\
\textbf{Question:} What costume designer was a film director 's Canadian female parent\\
\textbf{Answer:} SELECT DISTINCT ?x0 WHERE \{ ?x0 a costume\_designer . \textbf{?x0 a film\_director} . ?x0 has\_gender female . ?x0 has\_nationality Canadian . ?x0 parent\_of ?x1 \} \} \\
\textbf{Golden:} SELECT DISTINCT ?x0 WHERE \{ ?x0 a costume\_designer . ?x0 parent\_of ?x1 . ?x0 has\_gender female . ?x0 has\_nationality Canadian . \textbf{?x1 a film\_director} \}
}

\subsection{Fair Comparison against Other Prompting Techniques \label{app:fair_compare}}

In the comparison in Figure~\ref{fig:ablation_pool_size}, vanilla few-shot and chain-of-thought prompting have an advantage over least-to-most prompting because we sample multiple exemplar lists () and multiple outputs per list () using temperature-based decoding. This yields  outputs per input, which are aggregated using self-consistency. When using  and  with greedy decoding, the comparison between these prompting techniques and dynamic least-to-most is more fair, and the benefits of dynamic least-to-most are more prominent. Chain-of-thought achieves 75.4\% accuracy (down from 87.2\%), and vanilla few-shot achieves 69.8\% accuracy (down from 80.8\%). Dynamic least-to-most substantially outperforms both of these without using self-consistency, and achieves 94.4\% on the same 500-sentence subset of MCD1 validation data.


\section{Reproducibility Summary \label{app:reproduce}}

At all points in this work, we aim to make our methods and experiments easily reproducible, and we hope our findings will have impact in part through others using the same or similar methods for new tasks. Here we summarize critical components of our work and where their relevant details are described:

\begin{itemize}
    \item Main Prompts: In lieu of code, we provide the exact prompts that we executed to obtain model predictions. Prompts for CFQ: syntactic parsing (Appendix~\ref{app:cfq_decomposition}), dynamic least-to-most (Appendix~\ref{app:cfq_solution}). Prompts for COGS: syntactic parsing (Appendix~\ref{app:cogs_decomposition}), dynamic least-to-most (Appendix~\ref{app:cogs_solution}). Exemplars are chosen using the methods described in Section~\ref{sec:dynamic_exemplar_selection}, and Appendix~\ref{app:cfq_exemplar_selection} (for CFQ) and Appendix~\ref{app:cogs_exemplar_selection} (for COGS). The prompts include the exemplars found from a concrete input.
    \item Additional Prompts: We only use vanilla few-shot and chain-of-thought to compare against dynamic least-to-most on CFQ. The chain-of-thought prompt used to bootstrap rationale is in Appendix~\ref{app:cfq_cot_bootsrap_prompt}, and the one used for evaluation data is in Appendix~\ref{app:cfq_cot_prompt}. The prompt includes the exemplars found from a concrete input. The vanilla few-shot prompt is similar, but all examples use the vanilla input/output format. Exemplars are chosen using the methods described in Section~\ref{sec:factored_search}.
    \item Dataset Preparation and Evaluation: We performed both pre-processing and a post-processing output normalization step in order to make semantic parsing with freebase identifiers more feasible for prompting. Described in Section~\ref{sec:data}, Appendix~\ref{app:cfq_preprocessing},~\ref{app:cfq_postprocessing},~\ref{app:cogs_postprocessing}.
    \item Exemplar Pool: Methodology for constructing exemplar pools is described in Section \ref{sec:dynamic_exemplar_selection}.
    \item Hyperparameters: We didn't require any extensive hyperparameter search. The hyperparameters we used are described in Section~\ref{sec:modeling} and Appendix~\ref{app:hyperparams}.
\end{itemize}



\end{document}
