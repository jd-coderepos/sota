\documentclass{article}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{booktabs} 

\usepackage{hyperref}

\newcommand{\theHalgorithm}{\arabic{algorithm}}

\usepackage{amsmath,amssymb,mathtools,amsthm}
\usepackage{algorithmic}
\usepackage{wrapfig}

\usepackage{xspace}
\DeclarePairedDelimiterX{\infdivx}[2]{(}{)}{#1\;\delimsize|\delimsize|\;#2}
\newcommand{\kld}[2]{\ensuremath{D_{KL}\infdivx{#1}{#2}}\xspace}
\newcommand{\remark}[1]{{\color{red}{{[#1]}}}}

\makeatletter
\newcommand{\printfnsymbol}[1]{\textsuperscript{\@fnsymbol{#1}}}
\makeatother

\usepackage[accepted]{icml2021}



\icmltitlerunning{Improved Denoising Diffusion Probabilistic Models}





\begin{document}

\twocolumn[
\icmltitle{Improved Denoising Diffusion Probabilistic Models}





\icmlsetsymbol{equal}{*}

\begin{icmlauthorlist}
\icmlauthor{Alex Nichol}{equal,openai}
\icmlauthor{Prafulla Dhariwal}{equal,openai}
\end{icmlauthorlist}
\icmlaffiliation{openai}{OpenAI, San Francisco, USA}
\icmlcorrespondingauthor{}{alex@openai.com}
\icmlcorrespondingauthor{}{prafulla@openai.com}

\icmlkeywords{Machine Learning, ICML, Neural Networks, Generative Models, Likelihood, Denoising Diffusion, Image Generation}

\vskip 0.3in
]





\printAffiliationsAndNotice{\icmlEqualContribution} 

\begin{abstract}
Denoising diffusion probabilistic models (DDPM) are a class of generative models which have recently been shown to produce excellent samples. We show that with a few simple modifications, DDPMs can also achieve competitive log-likelihoods while maintaining high sample quality. Additionally, we find that learning variances of the reverse diffusion process allows sampling with an order of magnitude fewer forward passes with a negligible difference in sample quality, which is important for the practical deployment of these models. We additionally use precision and recall to compare how well DDPMs and GANs cover the target distribution. Finally, we show that the sample quality and likelihood of these models scale smoothly with model capacity and training compute, making them easily scalable. We release our code at {\small \url{https://github.com/openai/improved-diffusion}}.
\end{abstract}

\section{Introduction}

\citet{diffusion} introduced diffusion probabilistic models, a class of generative models which match a data distribution by learning to reverse a gradual, multi-step noising process. More recently, \citet{ddpm} showed an equivalence between denoising diffusion probabilistic models (DDPM) and score based generative models \citep{scorematching,improvedscore}, which learn a gradient of the log-density of the data distribution using denoising score matching \citep{hyverianscorematching}. It has recently been shown that this class of models can produce high-quality images \citep{ddpm,improvedscore,adversarial} and audio \citep{wavegrad,diffwave}, but it has yet to be shown that DDPMs can achieve log-likelihoods competitive with other likelihood-based models such as autoregressive models \citep{pixelcnn} and VAEs \citep{vae}. This raises various questions, such as whether DDPMs are capable of capturing all the modes of a distribution. Furthermore, while \citet{ddpm} showed extremely good results on the CIFAR-10 \citep{cifar10} and LSUN \citep{lsun} datasets, it is unclear how well DDPMs scale to datasets with higher diversity such as ImageNet. Finally, while \citet{wavegrad} found that DDPMs can efficiently generate audio using a small number of sampling steps, it has yet to be shown that the same is true for images.

In this paper, we show that DDPMs can achieve log-likelihoods competitive with other likelihood-based models, even on high-diversity datasets like ImageNet. To more tightly optimise the variational lower-bound (VLB), we learn the reverse process variances using a simple reparameterization and a hybrid learning objective that combines the VLB with the simplified objective from \citet{ddpm}.

We find surprisingly that, with our hybrid objective, our models obtain better log-likelihoods than those obtained by optimizing the log-likelihood directly, and discover that the latter objective has much more gradient noise during training. We show that a simple importance sampling technique reduces this noise and allows us to achieve better log-likelihoods than with the hybrid objective.

After incorporating learned variances into our model, we surprisingly discovered that we could sample in fewer steps from our models with very little change in sample quality. While DDPM \citep{ddpm} requires hundreds of forward passes to produce good samples, we can achieve good samples with as few as 50 forward passes, thus speeding up sampling for use in practical applications. In parallel to our work, \citet{ddim} develops a different approach to fast sampling, and we compare against their approach, DDIM, in our experiments.

While likelihood is a good metric to compare against other likelihood-based models, we also wanted to compare the distribution coverage of these models with GANs. We use the improved precision and recall metrics \citep{improvedpr} and discover that diffusion models achieve much higher recall for similar FID, suggesting that they do indeed cover a much larger portion of the target distribution. 

Finally, since we expect machine learning models to consume more computational resources in the future, we evaluate the performance of these models as we increase model size and training compute. Similar to \cite{scalingcompendium}, we observe trends that suggest predictable improvements in performance as we increase training compute. 

\section{Denoising Diffusion Probabilistic Models}
\label{sec:ddpm}
We briefly review the formulation of DDPMs from \citet{ddpm}. This formulation makes various simplifying assumptions, such as a fixed noising process  which adds diagonal Gaussian noise at each timestep. For a more general derivation, see \citet{diffusion}.

\subsection{Definitions}

Given a data distribution , we define a forward noising process  which produces latents  through  by adding Gaussian noise at time  with variance  as follows:


Given sufficiently large  and a well behaved schedule of , the latent  is nearly an isotropic Gaussian distribution. Thus, if we know the exact reverse distribution , we can sample  and run the process in reverse to get a sample from . However, since  depends on the entire data distribution, we approximate it using a neural network as follows:


The combination of  and  is a variational auto-encoder \citep{vae}, and we can write the variational lower bound (VLB) as follows:


Aside from , each term of Equation \ref{eq:loss} is a \ensuremath{KL} divergence between two Gaussians, and can thus be evaluated in closed form. To evaluate  for images, we assume that each color component is divided into 256 bins, and we compute the probability of  landing in the correct bin (which is tractable using the CDF of the Gaussian distribution). Also note that while  does not depend on , it will be close to zero if the forward noising process adequately destroys the data distribution so that .

As noted in \cite{ddpm}, the noising process defined in Equation \ref{eq:singlestep} allows us to sample an arbitrary step of the noised latents directly conditioned on the input . With  and , we can write the marginal

where . Here,  tells us the variance of the noise for an arbitrary timestep, and we could equivalently use this to define the noise schedule instead of .

Using Bayes theorem, one can calculate the posterior  in terms of  and  which are defined as follows:


\subsection{Training in Practice}

The objective in Equation \ref{eq:loss} is a sum of independent terms , and Equation \ref{eq:jumpnoise} provides an efficient way to sample from an arbitrary step of the forward noising process and estimate  using the posterior (Equation \ref{eq:posterior}) and prior (Equation \ref{eq:nn}). We can thus randomly sample  and use the expectation  to estimate . \citet{ddpm} uniformly sample  for each image in each mini-batch.

There are many different ways to parameterize  in the prior. The most obvious option is to predict  directly with a neural network. Alternatively, the network could predict , and this output could be used in Equation \ref{eq:mutilde} to produce . The network could also predict the noise  and use Equations \ref{eq:jumpnoise} and \ref{eq:mutilde} to derive

\citet{ddpm} found that predicting  worked best, especially when combined with a reweighted loss function:

This objective can be seen as a reweighted form of  (without the terms affecting ). The authors found that optimizing this reweighted objective resulted in much better sample quality than optimizing  directly, and explain this by drawing a connection to generative score matching \citep{scorematching,improvedscore}.

One subtlety is that  provides no learning signal for . This is irrelevant, however, since \citet{ddpm} achieved their best results by fixing the variance to  rather than learning it. They found that they achieve similar sample quality using either  or , which are the upper and lower bounds on the variance given by  being either isotropic Gaussian noise or a delta function, respectively.

\section{Improving the Log-likelihood}
\label{sec:improvinglikelihood}

While \citet{ddpm} found that DDPMs can generate high-fidelity samples according to FID \citep{fid} and Inception Score \citep{inceptionscore}, they were unable to achieve competitive log-likelihoods with these models. Log-likelihood is a widely used metric in generative modeling, and it is generally believed that optimizing log-likelihood forces generative models to capture all of the modes of the data distribution \citep{vqvae2}. Additionally, recent work \citep{scalingcompendium} has shown that small improvements in log-likelihood can have a dramatic impact on sample quality and learnt feature representations. Thus, it is important to explore why DDPMs seem to perform poorly on this metric, since this may suggest a fundamental shortcoming such as bad mode coverage. This section explores several modifications to the algorithm described in Section \ref{sec:ddpm} that, when combined, allow DDPMs to achieve much better log-likelihoods on image datasets, suggesting that these models enjoy the same benefits as other likelihood-based generative models.

To study the effects of different modifications, we train fixed model architectures with fixed hyperparameters on the ImageNet  \citep{imagenet64} and CIFAR-10 \citep{cifar10} datasets. While CIFAR-10 has seen more usage for this class of models, we chose to study ImageNet  as well because it provides a good trade-off between diversity and resolution, allowing us to train models quickly without worrying about overfitting. Additionally, ImageNet  has been studied extensively in the context of generative modeling \citep{pixelcnn,spn,sparsetransformer,routingtransformer}, allowing us to compare DDPMs directly to many other generative models.

The setup from \citet{ddpm} (optimizing  while setting  and ) achieves a log-likelihood of 3.99 (bits/dim) on ImageNet  after 200K training iterations. We found in early experiments that we could get a boost in log-likelihood by increasing  from 1000 to 4000; with this change, the log-likelihood improves to 3.77. For the remainder of this section, we use , but we explore this choice in Section \ref{sec:numberofsteps}.

\subsection{Learning }
\label{sec:learnsigma}

\begin{figure}[ht]
\begin{center}
\centerline{\includegraphics[width=0.8\columnwidth]{variance_ratio-eps.pdf}}
\caption{\label{fig:sigmaratio} The ratio  for every diffusion step for diffusion processes of different lengths.}
\end{center}
\vskip -0.4in
\end{figure}

\begin{figure}[ht]
\vskip 0.2in
\begin{center}
\centerline{\includegraphics[width=0.8\columnwidth]{loss_terms-eps.pdf}}
\caption{\label{fig:lossterms} Terms of the VLB vs diffusion step. The first few terms contribute most to NLL.}\end{center}
\vskip -0.4in
\end{figure}



In \citet{ddpm}, the authors set , where  is not learned. Oddly, they found that fixing  to  yielded roughly the same sample quality as fixing it to . Considering that  and  represent two opposite extremes, it is reasonable to ask why this choice doesn't affect samples. One clue is given by Figure \ref{fig:sigmaratio}, which shows that  and  are almost equal except near , i.e. where the model is dealing with imperceptible details. Furthermore, as we increase the number of diffusion steps,  and  seem to remain close to one another for more of the diffusion process. This suggests that, in the limit of infinite diffusion steps, the choice of  might not matter at all for sample quality. In other words, as we add more diffusion steps, the model mean  determines the distribution much more than .

While the above argument suggests that fixing  is a reasonable choice for the sake of sample quality, it says nothing about log-likelihood. In fact, Figure \ref{fig:lossterms} shows that the first few steps of the diffusion process contribute the most to the variational lower bound. Thus, it seems likely that we could improve log-likelihood by using a better choice of . To achieve this, we must learn  without the instabilities encountered by \citet{ddpm}.

Since Figure \ref{fig:sigmaratio} shows that the reasonable range for  is very small, it would be hard for a neural network to predict  directly, even in the log domain, as observed by \citet{ddpm}. Instead, we found it better to parameterize the variance as an interpolation between  and  in the log domain. In particular, our model outputs a vector  containing one component per dimension, and we turn this output into variances as follows:


We did not apply any constraints on , theoretically allowing the model to predict variances outside of the interpolated range. However, we did not observe the network doing this in practice, suggesting that the bounds for  are indeed expressive enough.

Since  doesn't depend on , we define a new hybrid objective:


For our experiments, we set  to prevent  from overwhelming . Along this same line of reasoning, we also apply a stop-gradient to the  output for the  term. This way,  can guide  while  is still the main source of influence over .

\subsection{Improving the Noise Schedule}
\label{sec:schedule}

\begin{figure}[t]
\begin{center}
\centerline{\includegraphics[width=\columnwidth]{linear_vs_cosine.png}}
\caption{\label{fig:noisingprocess} Latent samples from linear (top) and cosine (bottom) schedules respectively at linearly spaced values of  from  to . The latents in the last quarter of the linear schedule are almost purely noise, whereas the cosine schedule adds noise more slowly}
\end{center}
\vskip -0.2in
\end{figure}

\begin{figure}[t]
\begin{center}
\centerline{\includegraphics[width=0.8\columnwidth]{skip_steps-eps.pdf}}
\caption{\label{fig:skipsteps} FID when skipping a prefix of the reverse diffusion process on ImageNet .}
\end{center}
\end{figure}

\begin{figure}[ht]
\begin{center}
\centerline{\includegraphics[width=0.8\columnwidth]{alpha_bar-eps.pdf}}
\caption{\label{fig:alphabar}  throughout diffusion in the linear schedule and our proposed cosine schedule.}
\end{center}
\vskip -0.2in
\end{figure}



We found that while the linear noise schedule used in \citet{ddpm} worked well for high resolution images, it was sub-optimal for images of resolution  and . In particular, the end of the forward noising process is too noisy, and so doesn't contribute very much to sample quality. This can be seen visually in Figure \ref{fig:noisingprocess}. The result of this effect is studied in Figure \ref{fig:skipsteps}, where we see that a model trained with the linear schedule does not get much worse (as measured by FID) when we skip up to 20\% of the reverse diffusion process.

To address this problem, we construct a different noise schedule in terms of :

To go from this definition to variances , we note that . In practice, we clip  to be no larger than 0.999 to prevent singularities at the end of the diffusion process near .

Our cosine schedule is designed to have a linear drop-off of  in the middle of the process, while changing very little near the extremes of  and  to prevent abrupt changes in noise level. Figure \ref{fig:alphabar} shows how  progresses for both schedules. We can see that the linear schedule from \citet{ddpm} falls towards zero much faster, destroying information more quickly than necessary.

We use a small offset  to prevent  from being too small near , since we found that having tiny amounts of noise at the beginning of the process made it hard for the network to predict  accurately enough. In particular, we selected  such that  was slightly smaller than the pixel bin size , which gives . We chose to use  in particular because it is a common mathematical function with the shape we were looking for. This choice was arbitrary, and we expect that many other functions with similar shapes would work as well.

\subsection{Reducing Gradient Noise}
\label{sec:gradnoise}

\begin{figure}[ht]
\begin{center}
\centerline{\includegraphics[width=0.8\columnwidth]{reweight_loss_curves-eps.pdf}}
\caption{\label{fig:reweightlosscurves} Learning curves comparing the log-likelihoods achieved by different objectives on ImageNet .}
\end{center}
\vskip -0.4in
\end{figure}


\begin{figure}[ht]
\vskip 0.2in
\begin{center}
\centerline{\includegraphics[width=0.8\columnwidth]{noise_scales-eps.pdf}}
\caption{\label{fig:noisescales} Gradient noise scales for the  and  objectives on ImageNet .}
\end{center}
\vskip -0.2in
\end{figure}

We expected to achieve the best log-likelihoods by optimizing  directly, rather than by optimizing . However, we were surprised to find that  was actually quite difficult to optimize in practice, at least on the diverse ImageNet  dataset. Figure \ref{fig:reweightlosscurves} shows the learning curves for both  and . Both curves are noisy, but the hybrid objective clearly achieves better log-likelihoods on the training set given the same amount of training time.

We hypothesized that the gradient of  was much noisier than that of . We confirmed this by evaluating the gradient noise scales \citep{gradnoisescale} for models trained with both objectives, as shown in Figure \ref{fig:noisescales}. Thus, we sought out a way to reduce the variance of  in order to optimize directly for log-likelihood.

Noting that different terms of  have greatly different magnitudes (Figure \ref{fig:lossterms}), we hypothesized that sampling  uniformly causes unnecessary noise in the  objective. To address this, we employ importance sampling:

Since  is unknown beforehand and may change throughout training, we maintain a history of the previous 10 values for each loss term, and update this dynamically during training. At the beginning of training, we sample  uniformly until we draw 10 samples for every .

With this importance sampled objective, we are able to achieve our best log-likelihoods by optimizing . This can be seen in Figure \ref{fig:reweightlosscurves} as the  (resampled) curve. The figure also shows that the importance sampled objective is considerably less noisy than the original, uniformly sampled objective. We found that the importance sampling technique was not helpful when optimizing the less-noisy  objective directly.

\subsection{Results and Ablations}
\label{sec:summarizing}

In this section, we ablate the changes we have made to achieve better log-likelihoods. Table \ref{tbl:improvementcomparison} summarizes the results of our ablations on ImageNet , and Table \ref{tbl:cifar_improvementcomparison} shows them for CIFAR-10. We also trained our best ImageNet  models for 1.5M iterations, and report these results as well.  and  were trained with learned sigmas using the parameterization from Section \ref{sec:learnsigma}. For , we used the resampling scheme from Section \ref{sec:gradnoise}.

Based on our ablations, using  and our cosine schedule improves log-likelihood while keeping similar FID as the baseline from \citet{ddpm}. Optimizing  further improves log-likelihood at the cost of a higher FID. We generally prefer to use  over  as it gives a boost in likelihood without sacrificing sample quality. 

In Table \ref{tbl:allvlbcomparison} we compare our best likelihood models against prior work, showing that these models are competitive with the best conventional methods in terms of log-likelihood.

\begin{table}[t]
    \caption{\label{tbl:improvementcomparison} Ablating schedule and objective on ImageNet .}
    \centering
    \vskip 0.15in
	\begin{center}
	\begin{small}
    \begin{tabular}{ccccll}
    	\toprule
        Iters &  & Schedule & Objective & NLL & FID \\ 
		\midrule
        200K & 1K & linear &  & 3.99 & 32.5 \\
        200K & 4K & linear &  & 3.77 & 31.3 \\
		\midrule
        200K & 4K & linear &  & 3.66 & 32.2 \\
        200K & 4K & cosine &  & 3.68 & \bf 27.0 \\
        200K & 4K & cosine &  & 3.62 & 28.0 \\
        200K & 4K & cosine &  & \bf 3.57 & 56.7 \\
        \midrule
        1.5M & 4K & cosine &  & 3.57 & \bf 19.2 \\
        1.5M & 4K & cosine &  & \bf 3.53 & 40.1 \\
        \bottomrule
    \end{tabular}
    \end{small}
    \end{center}
    \vskip -0.1in
\end{table}

\begin{table}[t]
    \caption{\label{tbl:cifar_improvementcomparison} Ablating schedule and objective on CIFAR-10.}
    \centering
    \vskip 0.15in
	\begin{center}
	\begin{small}
    \begin{tabular}{ccccll}
    	\toprule
        Iters &  & Schedule & Objective & NLL & FID \\ 
        \midrule
        500K & 1K & linear &  & 3.73 & 3.29 \\
        500K & 4K & linear &  & 3.37 & \bf 2.90 \\
        \midrule
        500K & 4K & linear &  & 3.26 & 3.07 \\
        500K & 4K & cosine &  & 3.26 & 3.05 \\
        500K & 4K & cosine &  & 3.17 & 3.19 \\
        500K & 4K & cosine &  & \bf 2.94 & 11.47 \\
        \bottomrule
    \end{tabular}
    \end{small}
    \end{center}
    \vskip -0.1in
\end{table}

\begin{table}[t]
    \caption{\label{tbl:allvlbcomparison} Comparison of DDPMs to other likelihood-based models on CIFAR-10 and Unconditional ImageNet . NLL is reported in bits/dim. On ImageNet , our model is competitive with the best convolutional models, but is worse than fully transformer-based architectures.}
    \centering
    \vskip 0.15in
	\begin{center}
	\begin{small}
    \begin{tabular}{lcc}
    	\toprule
        Model & ImageNet & CIFAR \\
        \midrule
        Glow \citep{glow} & 3.81 & 3.35 \\
        Flow++ \citep{flow++} & 3.69 & 3.08 \\
        PixelCNN \citep{pixelcnn} & 3.57 & 3.14 \\
        SPN \citep{spn} & 3.52 & - \\
        NVAE \citep{nvae} & - & 2.91 \\
        Very Deep VAE \citep{vdvae} & 3.52 & 2.87 \\
        PixelSNAIL \citep{pixelsnail} & 3.52 & 2.85 \\
        Image Transformer \citep{imagetransformer} & 3.48 & 2.90 \\
        Sparse Transformer \citep{sparsetransformer} & 3.44 & \bf 2.80 \\
        Routing Transformer \citep{routingtransformer} & \bf 3.43 & - \\
        \midrule 
        DDPM \citep{ddpm} & 3.77 & 3.70 \\
        DDPM (cont flow) \citep{sde} & - & 2.99 \\
        Improved DDPM (ours) & \bf 3.53 & \bf 2.94 \\
        \bottomrule
    \end{tabular}
    \end{small}
    \end{center}
    \vskip -0.1in
\end{table}

\section{Improving Sampling Speed}
\label{sec:numberofsteps}

All of our models were trained with 4000 diffusion steps, and thus producing a single sample takes several minutes on a modern GPU. In this section, we explore how performance scales if we reduce the steps used during sampling, and find that our pre-trained  models can produce high-quality samples with many fewer diffusion steps than they were trained with (without any fine-tuning). Reducing the steps in this way makes it possible to sample from our models in a number of seconds rather than minutes, and greatly improves the practical applicability of image DDPMs.



For a model trained with  diffusion steps, we would typically sample using the same sequence of  values  as used during training. However, it is also possible to sample using an arbitrary subsequence  of  values. Given the training noise schedule , for a given sequence  we can obtain the sampling noise schedule , which can be then used to obtain corresponding sampling variances


Now, since  is parameterized as a range between  and , it will automatically be rescaled for the shorter diffusion process. We can thus compute  as . 


\begin{figure}[t]
\begin{center}
\centerline{\includegraphics[width=0.8\columnwidth]{fid_vs_steps_cifar_legend-eps.pdf}}
\centerline{\includegraphics[width=0.8\columnwidth]{fid_vs_steps-eps.pdf}}
\centerline{\includegraphics[width=0.8\columnwidth]{fid_vs_steps_cifar-eps.pdf}}
\caption{\label{fig:fidvssteps} FID versus number of sampling steps, for models trained on ImageNet  (top) and CIFAR-10 (bottom). All models were trained with 4000 diffusion steps.}
\end{center}
\vskip -0.4in
\end{figure}

To reduce the number of sampling steps from  to , we use  evenly spaced real numbers between 1 and  (inclusive), and then round each resulting number to the nearest integer. In Figure \ref{fig:fidvssteps}, we evaluate FIDs for an  model and an  model that were trained with 4000 diffusion steps, using 25, 50, 100, 200, 400, 1000, and 4000 sampling steps. We do this for both a fully-trained checkpoint, and a checkpoint mid-way through training. For CIFAR-10 we used 200K and 500K training iterations, and for ImageNet-64 we used 500K and 1500K training iterations.
We find that the  models with fixed sigmas (with both the larger  and the smaller ) suffer much more in sample quality when using a reduced number of sampling steps, whereas our  model with learnt sigmas maintains high sample quality. With this model, 100 sampling steps is sufficient to achieve near-optimal FIDs for our fully trained models. 

Parallel to our work, \citet{ddim} propose a fast sampling algorithm for DDPMs by producing a new implicit model that has the same marginal noise distributions, but deterministically maps noise to images. We include their algorithm, DDIM, in Figure \ref{fig:fidvssteps}, finding that DDIM produces better samples with fewer than 50 sampling steps, but worse samples when using 50 or more steps. Interestingly, DDIM performs worse at the start of training, but closes the gap to other samplers as training continues. We found that our striding technique drastically reduced performance of DDIM, so our DDIM results instead use the constant striding\footnote{We additionally tried the quadratic stride from \citet{ddim}, but found that it hurt sample quality when combined with our cosine schedule.} from \citet{ddim}, wherein the final timestep is  rather than . The other samplers performed slightly better with our striding.





\section{Comparison to GANs}
\begin{table}[t]
    \caption{\label{tbl:classcondfid} Sample quality comparison on class-conditional ImageNet . Precision and recall \citep{improvedpr} are measured using Inception-V3 features and . We trained BigGAN-deep for 125K iterations, and did not use truncation for sampling to maximize recall for the GAN.}
    \centering
    \vskip 0.15in
	\begin{center}
	\begin{small}
    \begin{tabular}{lccc}
        \toprule
        Model & FID & Prec. & Recall \\
        \midrule
        BigGAN-deep \citep{biggan} & 4.06 & \bf 0.86 & 0.59 \\
        Improved Diffusion (small) & 6.92 & 0.77 & \bf 0.72 \\ 
        Improved Diffusion (large) & \bf 2.92 & 0.82 & \bf 0.71 \\
        \bottomrule
    \end{tabular}
\end{small}
\end{center}
\vskip -0.1in
\end{table}

\begin{figure}[t]
\begin{center}
\centerline{\includegraphics[width=0.8\columnwidth]{samples_classcond_imgnet_fid3p7_grid.png}}
\caption{\label{fig:classcond} Class-conditional ImageNet  samples generated using 250 sampling steps from  model (FID 2.92). The classes are 9: ostrich, 11: goldfinch, 130: flamingo, 141: redshank, 154: pekinese, 157: papillon, 97: drake and 28: spotted salamander. We see that there is a high diversity in each class, suggesting good coverage of the target distribution}
\end{center}
\vskip -0.2in
\end{figure}

While likelihood is a good proxy for mode-coverage, it is difficult to compare to GANs with this metric. Instead, we turn to precision and recall \citep{improvedpr}. Since it is common in the GAN literature to train class-conditional models, we do the same for this experiment. To make our models class-conditional, we inject class information through the same pathway as the timestep . In particular, we add a class embedding  to the timestep embedding , and pass this embedding to residual blocks throughout the model. We train using the  objective and use  sampling steps. We train two models: a "small" model with 100M parameters for 1.7M training steps, and a larger model with 270 million parameters for 250K iterations. We train one BigGAN-deep model with 100M parameters across the generator and discriminator.

When computing metrics for this task, we generated 50K samples (rather than 10K) to be directly comparable to other works.\footnote{We found that using more samples led to a decrease in estimated FID of roughly 2 points.} This is the only ImageNet  FID we report that was computed using 50K samples. For FID, the reference distribution features were computed over the full training set, following \cite{biggan}.

Figure \ref{fig:classcond} shows our samples from the larger model, and Table \ref{tbl:classcondfid} summarizes our results. We find that BigGAN-deep outperforms our smaller model in terms of FID, but struggles in terms of recall. This suggests that diffusion models are better at covering the modes of the distribution than comparable GANs.

\section{Scaling Model Size}
\label{sec:scaling}

In the previous sections, we showed algorithmic changes that improved log-likelihood and FID without changing the amount of training compute. However, a trend in modern machine learning is that larger models and more training time tend to improve model performance \citep{scalinglaws,igpt,gpt3}. Given this observation, we investigate how FID and NLL scale as a function of training compute. Our results, while preliminary, suggest that DDPMs improve in a predictable way as training compute increases.

To measure how performance scales with training compute, we train four different models on ImageNet  with the  objective described in Section \ref{sec:learnsigma}. To change model capacity, we apply a depth multiplier across all layers, such that the first layer has either 64, 96, 128, or 192 channels. Note that our previous experiments used 128 channels in the first layer. Since the depth of each layer affects the scale of the initial weights, we scale the Adam \citep{adam} learning rate for each model by , such that the 128 channel model has a learning rate of 0.0001 (as in our other experiments).

Figure \ref{fig:computevsfidnll} shows how FID and NLL improve relative to theoretical training compute.\footnote{The x-axis assumes full hardware utilization} The FID curve looks approximately linear on a log-log plot, suggesting that FID scales according to a power law (plotted as the black dashed line). The NLL curve does not fit a power law as cleanly, suggesting that validation NLL scales in a less-favorable manner than FID. This could be caused by a variety of factors, such as 1) an unexpectedly high irreducible loss \citep{scalingcompendium} for this type of diffusion model, or 2) the model overfitting to the training distribution. We also note that these models do not achieve optimal log-likelihoods in general because they were trained with our  objective and not directly with  to keep both good log-likelihoods and sample quality.
\begin{figure}[t]
\begin{center}
\centerline{\includegraphics[width=0.8\columnwidth]{compute_frontier-eps.pdf}}
\centerline{\includegraphics[width=0.8\columnwidth]{compute_frontier_nll-eps.pdf}}
\caption{\label{fig:computevsfidnll} FID and validation NLL throughout training on ImageNet  for different model sizes. The constant for the FID trend line was approximated using the FID of in-distribution data. For the NLL trend line, the constant was approximated by rounding down the current state-of-the-art NLL \citep{routingtransformer} on this dataset.}
\end{center}
\vskip -0.4in
\end{figure}
\section{Related Work}
\citet{wavegrad} and \citet{diffwave} are two recent works that use DDPMs to produce high fidelity audio conditioned on mel-spectrograms. Concurrent to our work, \citet{wavegrad} use a combination of improved schedule and  loss to allow sampling with fewer steps with very little reduction in sample quality. However, compared to our unconditional image generation task, their generative task has a strong input conditioning signal provided by the mel-spectrograms, and we hypothesize that this makes it easier to sample with fewer diffusion steps.

\citet{adversarial} explored score matching in the image domain, and constructed an adversarial training objective to produce better  predictions. However, they found that choosing a better network architecture removed the need for this adversarial objective, suggesting that the adversarial objective is not necessary for powerful generative modeling.

Parallel to our work, \citet{ddim} and \citet{sde} propose fast sampling algorithms for models trained with the DDPM objective by leveraging different sampling processes. \citet{ddim} does this by deriving an implicit generative model that has the same marginal noise distributions as DDPMs while deterministically mapping noise to images. \citet{sde} model the diffusion process as the discretization of a continuous SDE, and observe that there exists an ODE that corresponds to sampling from the reverse SDE. By varying the numerical precision of an ODE solver, they can sample with fewer function evaluations. However, they note that this technique obtains worse samples than ancestral sampling when used directly, and only achieves better FID when combined with Langevin corrector steps. This in turn requires hand-tuning of a signal-to-noise ratio for the Langevin steps. Our method allows fast sampling directly from the ancestral process, which removes the need for extra hyperparameters.

Also in parallel, \citet{ebmdiffusion} develops a diffusion model with reverse diffusion steps modeled by an energy-based model. A potential implication of this approach is that fewer diffusion steps should be needed to achieve good samples.

\section{Conclusion}
We have shown that, with a few modifications, DDPMs can sample much faster and achieve better log-likelihoods with little impact on sample quality. The likelihood is improved by learning  using our parameterization and  objective. This brings the likelihood of these models much closer to other likelihood-based models. We surprisingly discover that this change also allows sampling from these models with many fewer steps. 

We have also found that DDPMs can match the sample quality of GANs while achieving much better mode coverage as measured by recall. Furthermore, we have investigated how DDPMs scale with the amount of available training compute, and found that more training compute trivially leads to better sample quality and log-likelihood.

The combination of these results makes DDPMs an attractive choice for generative modeling, since they combine good log-likelihoods, high-quality samples, and reasonably fast sampling with a well-grounded, stationary training objective that scales easily with training compute. These results indicate that DDPMs are a promising direction for future research.

\bibliography{main}
\bibliographystyle{icml2021}

\clearpage

\appendix

\section{Hyperparameters}
\label{app:hyperparameters}

For all of our experiments, we use a UNet model architecture\footnote{In initial experiments, we found that a ResNet-style architecture with no downsampling achieved better log-likelihoods but worse FIDs than the UNet architecture.} similar to that used by \citet{ddpm}. We changed the attention layers to use multi-head attention \citep{transformers}, and opted to use four attention heads rather than one (while keeping the same total number of channels). We employ attention not only at the 16x16 resolution, but also at the 8x8 resolution. Additionally, we changed the way the model conditions on . In particular, instead of computing a conditioning vector  and injecting it into hidden state  as , we compute conditioning vectors  and  and inject them into the hidden state as . We found in preliminary experiments on ImageNet  that these modifications slightly improved FID.

For ImageNet  the architecture we use is described as follows. The downsampling stack performs four steps of downsampling, each with three residual blocks \citep{resnet}. The upsampling stack is setup as a mirror image of the downsampling stack. From highest to lowest resolution, the UNet stages use  channels, respectively. In our ImageNet  ablations, we set , but we experiment with scaling  in a later section. We estimate that, with , our model is comprised of 120M parameters and requires roughly 39 billion FLOPs in the forward pass.

For our CIFAR-10 experiments, we use a smaller model with three resblocks per downsampling stage and layer widths  with . We swept over dropout values  and found that 0.1 worked best for the linear schedule while 0.3 worked best for our cosine schedule. We expand upon this in Section \ref{app:overfitting}.

We use Adam \citep{adam} for all of our experiments. For most experiments, we use a batch size of 128, a learning rate of , and an exponential moving average (EMA) over model parameters with a rate of 0.9999. For our scaling experiments, we vary the learning rate to accomodate for different model sizes. For our larger class-conditional ImageNet  experiments, we scaled up the batch size to 2048 for faster training on more GPUs.

When using the linear noise schedule from \citet{ddpm}, we linearly interpolate from  to  to preserve the shape of  for the  schedule.

When computing FID we produce 50K samples from our models, except for unconditional ImageNet  where we produce 10K samples. Using only 10K samples biases the FID to be higher, but requires much less compute for sampling and helps do large ablations. Since we mainly use FID for relative comparisons on unconditional ImageNet , this bias is acceptable. For computing the reference distribution statistics we follow prior work \citep{ddpm,biggan} and use the full training set for CIFAR-10 and ImageNet, and 50K training samples for LSUN. Note that unconditional ImageNet  models are trained and evaluated using the official ImageNet-64 dataset \cite{pixelrnn}, whereas for class conditional ImageNet  and  we center crop and area downsample images \cite{biggan}.



\section{Fast Sampling on LSUN }
\begin{figure}[ht]
    \centering
    \includegraphics[width=\columnwidth]{fid_vs_steps_lsun_legend-eps.pdf}
    \includegraphics[width=\columnwidth]{fid_vs_steps_lsun-eps.pdf}
    \vskip -0.1in
    \caption{\label{fig:fidvssteps_lsun} FID vs. number of sampling steps from an LSUN  bedroom model.}
\end{figure}
To test the effectiveness of our  models on a high-resolution domain, we trained both  and  models on the LSUN bedroom \citep{lsun} dataset. We train two models: one with batch size 64 and learning rate  as in \citet{ddpm}, and another with a larger batch size 128 and learning rate . All models were trained with 153.6M examples, which is 2.4M training iterations with batch size 64.

Our results are displayed in Figure \ref{fig:fidvssteps_lsun}. We find that DDIM outperforms our  model when using fewer than 50 diffusion steps, while our  model outperforms DDIM with more than 50 diffusion steps. Interestingly, we note that DDIM benefits from a smaller learning rate and batch size, whereas our method is able to take advantage of a larger learning rate and batch size.

\section{Sample Quality on ImageNet }
We trained two models on class conditional ImageNet . The first is a usual diffusion model that directly models the  images. The second model reduces compute by chaining a pretrained  model  with another upsampling diffusion model  to upsample images to . For the upsampling model, the downsampled image   is passed as extra conditioning input to the UNet. This is similar to VQ-VAE-2 \citep{vqvae2}, which uses two stages of priors at different latent resolutions to more efficiently learn global and local features. The linear schedule worked better for  images, so we used that for these results. Table \ref{tbl:classcond256fid} summarizes our results. For VQ-VAE-2, we use the FIDs reported in \cite{cas}. Diffusion models still obtain the best FIDs for a likelihood-based model, and close the gap to GANs considerably. 

\begin{table}[ht]
    \centering
    \begin{tabular}{l|c}
        \bf MODEL & \bf FID \\
        \hline
        VQ-VAE-2 (\cite{vqvae2}, two-stage) & 38.1 \\
        Improved Diffusion (ours, single-stage) & 31.5 \\
        Improved Diffusion (ours, two-stage) & \bf{12.3} \\ 
        BigGAN \citep{biggan} & 7.7 \\
        BigGAN-deep \citep{biggan} & \bf{7.0} \\
    \end{tabular}
    \caption{\label{tbl:classcond256fid} Sample quality comparison on class conditional ImageNet . BigGAN FIDs are reported for the truncation that results in the best FID.}
\end{table}

\begin{figure}[ht]
    \centerline{\includegraphics[width=\columnwidth]{samples_classcond_imgnet_64.png}}
    \vskip 0.1in
    \centerline{\includegraphics[width=\columnwidth]{samples_classcond_imgnet_upsampled_256.png}}
    \caption{\label{fig:classcondtwostage}Random samples from two-stage class conditional ImageNet  model. On top are random samples from the  model (FID 2.92), whereas on bottom are the results after upsampling them to  (FID 12.3). Each model uses 250 sampling steps.}
    \vspace{1.5in}
\end{figure}

\clearpage

\section{Combining  and  Models}

\begin{figure}[ht]
    \centerline{\includegraphics[width=\columnwidth]{bpd_terms-eps.pdf}}
    \caption{\label{fig:bpdterms} The ratio between VLB terms for each diffusion step of  and . Values less than 1.0 indicate that  is "better" than  for that timestep of the diffusion process.}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=\columnwidth]{comparison_samples.png}
    \caption{\label{fig:objectivesamples} Samples from  and , as well as an ensemble produced by using  for the first and last 100 diffusion steps. For these samples, the seed was fixed, allowing a direct comparison between models.} 
\end{figure}

To understand the trade-off between  and , we show in Figure \ref{fig:bpdterms} that the model resulting from  (referred to as ) is better at the start and end of the diffusion process, while the model resulting from  (referred to as ) is better throughout the middle of the diffusion process. This suggests that  is focusing more on imperceptible details, hence the lower sample quality.

Given the above observation, we performed an experiment on ImageNet  to combine the two models by constructing an ensemble that uses  for  and  elsewhere. We found that this model achieved an FID of \textbf{19.9} and an NLL of \textbf{3.52 bits/dim}. This is only slightly worse than  in terms of FID, while being better than both models in terms of NLL.

\newpage
\section{Log-likelihood with Fewer Diffusion Steps}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.85\columnwidth]{fid_vs_steps_cifar_legend-eps.pdf}
    \includegraphics[width=\columnwidth]{nll_vs_steps-eps.pdf}
    \includegraphics[width=\columnwidth]{nll_vs_steps_cifar-eps.pdf}
    \caption{\label{fig:nllvssteps} NLL versus number of evaluation steps, for models trained on ImageNet  (top) and CIFAR-10 (bottom). All models were trained with 4000 diffusion steps.}
\end{figure}

Figures \ref{fig:nllvssteps} plots negative log-likelihood as a function of number of sampling steps for both ImageNet  and CIFAR-10. In initial experiments, we found that although constant striding did not significantly affect FID, it drastically reduced log-likelihood. To address this, we use a strided subset of timesteps as for FID, but we also include every  from 1 to . This requires  extra evaluation steps, but greatly improves log-likelihood compared to the uniformly strided schedule. We did not attempt to calculate NLL using DDIM, since \citet{ddim} does not present NLL results or a simple way of estimating likelihood under DDIM.

\clearpage

\section{Overfitting on CIFAR-10}
\label{app:overfitting}

\begin{figure}[ht]
    \centering
    \includegraphics[width=\columnwidth]{overfitting_fid_vs_steps-eps.pdf}
    \includegraphics[width=\columnwidth]{overfitting_nll_vs_steps-eps.pdf}
    \caption{\label{fig:overfitting} FID (top) and NLL (bottom) over the course of training for two CIFAR-10 models, both with dropout 0.1. The model trained with the linear schedule learns more slowly, but does not overfit as quickly. When too much overfitting occurs, we observed overfitting artifacts similar to those from \citet{pixelcnn++}, which is reflected by increasing FID.}
\end{figure}

On CIFAR-10, we noticed that all models overfit, but tended to reach similar optimal FID at some point during training. Holding dropout constant, we found that models trained with our cosine schedule tended to reach optimal performance (and then overfit) more quickly than those trained with the linear schedule (Figure \ref{fig:overfitting}). In our experiments, we corrected for this difference by using more dropout for our cosine models than the linear models. We suspect that the overfitting from the cosine schedule is either due to 1) less noise in the cosine schedule providing less regularization, or 2) the cosine schedule making optimization, and thus overfitting, easier.

\newpage
\section{Early stopping for FID}
\begin{figure}[ht]
    \centering
    \includegraphics[width=\columnwidth]{ema_sweep_full_fid_v4-eps.pdf}
    \caption{\label{fig:emasweep} A sweep of dropout and EMA hyperparameters on class conditional ImageNet-64.}
\end{figure}
Like on CIFAR-10, we surprisingly observed overfitting on class-conditional ImageNet , despite it being a much larger and more diverse dataset. The main observable result of this overfitting was that FID started becoming worse over the course of training. We initially tried a sweep (Figure \ref{fig:emasweep}) over the EMA hyperparameter to make sure it was well tuned, and found that 0.9999 and 0.99995 worked best. We then tried runs with dropout 0.1 and 0.3, and found that models with a small amount of dropout improved the best attainable FID but took longer to get to the same performance and still eventually overfit. We concluded that the best way to train, given what we know, is to early stop and instead increase model size if we want to use additional training compute. 



\section{Samples with Varying Steps and Objectives}
\label{app:samples}

Figures \ref{fig:firstimagenet} through \ref{fig:lastimagenet} show unconditional ImageNet  samples as we reduce number of sampling steps for an  model with  diffusion steps trained for 1.5M training iterations.

Figures \ref{fig:firstcifar} through \ref{fig:lastcifar} show unconditional CIFAR-10 samples as we reduce number of sampling steps for an  model with  diffusion steps trained for 500K training iterations.

Figures \ref{fig:uncondvlbcomparison} and \ref{fig:uncondvlbcomparison_cifar} highlight the difference in sample quality between models trained with  and .

\clearpage

\begin{figure}[h!]
    \centerline{\includegraphics[width=0.78\columnwidth]{samples_hybrid_50steps_1.5M_grid.png}}
    \caption{\label{fig:firstimagenet} 50 sampling steps on unconditional ImageNet }
\end{figure}
\begin{figure}[h!]
    \centerline{\includegraphics[width=0.78\columnwidth]{samples_hybrid_100steps_1.5M_grid.png}}
    \caption{100 sampling steps on unconditional ImageNet }
\end{figure}
\begin{figure}[h!]
    \centerline{\includegraphics[width=0.78\columnwidth]{samples_hybrid_200steps_1.5M_grid.png}}
    \caption{200 sampling steps on unconditional ImageNet }
    \vskip -0.4in
\end{figure}

\newpage
\begin{figure}[h!]
    \centerline{\includegraphics[width=0.78\columnwidth]{samples_hybrid_400steps_1.5M_grid.png}}
    \caption{400 sampling steps on unconditional ImageNet }
\end{figure}
\begin{figure}[h!]
    \centerline{\includegraphics[width=0.78\columnwidth]{samples_hybrid_1000steps_1.5M_grid.png}}
    \caption{1000 sampling steps on unconditional ImageNet }
\end{figure}
\begin{figure}[h!]
    \centerline{\includegraphics[width=0.78\columnwidth]{samples_hybrid_1.5M_grid.png}}
    \caption{\label{fig:lastimagenet} 4K sampling steps on unconditional ImageNet .}
    \vskip -0.4in
\end{figure}

\clearpage

\begin{figure}[h!]
    \centerline{\includegraphics[width=0.78\columnwidth]{samples_cifar_hybrid_50.png}}
    \caption{\label{fig:firstcifar} 50 sampling steps on unconditional CIFAR-10}
\end{figure}
\begin{figure}[h!]
    \centerline{\includegraphics[width=0.78\columnwidth]{samples_cifar_hybrid_100.png}}
    \caption{100 sampling steps on unconditional CIFAR-10}
\end{figure}
\begin{figure}[h!]
    \centerline{\includegraphics[width=0.78\columnwidth]{samples_cifar_hybrid_200.png}}
    \caption{200 sampling steps on unconditional CIFAR-10}
    \vskip -0.4in
\end{figure}
\newpage
\begin{figure}[h!]
    \centerline{\includegraphics[width=0.78\columnwidth]{samples_cifar_hybrid_400.png}}
    \caption{400 sampling steps on unconditional CIFAR-10}
\end{figure}
\begin{figure}[h!]
    \centerline{\includegraphics[width=0.78\columnwidth]{samples_cifar_hybrid_1000.png}}
    \caption{1000 sampling steps on unconditional CIFAR-10}
\end{figure}
\begin{figure}[h!]
    \centerline{\includegraphics[width=0.78\columnwidth]{samples_cifar_hybrid.png}}
    \caption{\label{fig:lastcifar} 4000 sampling steps on unconditional CIFAR-10}
    \vskip -0.4in
\end{figure}

\clearpage

\begin{figure}[t]
    \centerline{\includegraphics[width=0.78\columnwidth]{samples_hybrid_1.5M_grid.png}}
    \vskip 0.1in
    \centerline{\includegraphics[width=0.78\columnwidth]{samples_vlb_1.5M_grid.png}}
    \caption{\label{fig:uncondvlbcomparison} Unconditional ImageNet  samples generated from  (top) and  (bottom) models using the exact same random noise. Both models were trained for 1.5M iterations.}
\end{figure}

\begin{figure}[t]
    \centering
    \centerline{\includegraphics[width=0.78\columnwidth]{samples_cifar_hybrid.png}}
    \vskip 0.1in
    \centerline{\includegraphics[width=0.78\columnwidth]{samples_cifar_vlb.png}}
    \caption{\label{fig:uncondvlbcomparison_cifar} Unconditional CIFAR-10 samples generated from  (top) and  (bottom) models using the exact same random noise. Both models were trained for 500K iterations.}
\end{figure}

\end{document}
