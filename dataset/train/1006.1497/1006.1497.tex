\documentclass{tlp}

\usepackage{url,alltt,amsmath,epsfig,epsf,amssymb}
\usepackage[utf8]{inputenc}
\usepackage[all]{xy}
\usepackage{todo}

\bibliographystyle{acmtrans}



\newtheorem{theorem}{Theorem}\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}

\newtheorem{example}{Example}[section]
\newtheorem{definition}{Definition}[section]




\newcommand{\st}[3]{\ensuremath{\langle #1 , #2 , #3 \rangle}}
\newcommand{\CT}{\ensuremath{\mathcal{CT}}}

\newcommand{\mcCP}{\ensuremath{\mathcal{CP}}}
\newcommand{\mcI}{\ensuremath{\mathcal{I}}}
\newcommand{\mcG}{\ensuremath{\mathcal{G}}}
\newcommand{\mcP}{\ensuremath{\mathcal{P}}}
\newcommand{\mcS}{\ensuremath{\mathcal{S}}}

\newcommand{\Ps}{\ensuremath{\mcP_1,\mcP_2}}
\newcommand{\Ss}{\ensuremath{\mcS_1,\mcS_2}}

\newcommand{\bbB}{\ensuremath{\mathbb{B}}}
\newcommand{\bbBca}{\ensuremath{\bbB_c \land \bbB_a}}
\newcommand{\bbG}{\ensuremath{\mathbb{G}}}
\newcommand{\bbV}{\ensuremath{\mathbb{V}}}

\newcommand{\subxt}{\left[x/t\right] }
\newcommand{\psubxt}{\left[x\wr t\right] }
\newcommand{\subxy}{\left[x/y\right] }

\newcommand{\extend}{\ensuremath{\lhd}}
\newcommand{\mcp}{\ensuremath{\mathcal{M}^\mcG_e(\sigma_{\mcCP})}}
\newcommand{\sigcp}{\ensuremath{\sigma_{\mcCP}}}

\newcommand{\der}{\ensuremath{\rightarrowtail}}
\newcommand{\derrev}{\ensuremath{\ {}^*\!\!\leftarrowtail}}
\newcommand{\dergts}{\ensuremath{\Rightarrow}}

\DeclareMathOperator{\var}{var}
\DeclareMathOperator{\vars}{vars}
\DeclareMathOperator{\dvar}{dvar}
\DeclareMathOperator{\degree}{deg}
\DeclareMathOperator{\type}{type}
\DeclareMathOperator{\src}{src}
\DeclareMathOperator{\tgt}{tgt}
\DeclareMathOperator{\gnd}{ground}
\DeclareMathOperator{\kp}{keep}
\DeclareMathOperator{\track}{tr}
\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\node}{node}
\DeclareMathOperator{\edge}{edge}

\newcommand{\chr}{\ensuremath{{\tt chr}}}
\newcommand{\VARS}{\ensuremath{\mbox{VARS}}}
\newcommand{\chrrule}{\ensuremath{\varrho}}
\newcommand{\eqct}{\ensuremath{\stackrel{\CT}{\equiv}}}
\newcommand{\eqsubst}{\ensuremath{\stackrel{\text{Subst}}{\equiv}}}
\newcommand{\prodrule}{\ensuremath{p = (L \stackrel{l}{\leftarrow} K
\stackrel{r}{\rightarrow} R)\ }}
\newcommand{\strong}{\ensuremath{\mathcal{S}}}
\newcommand{\iso}{\ensuremath{\simeq}}

\submitted{25 September 2009}
\revised{18 April 2010}
\accepted{2 June 2010}

\begin{document}

\title{Analyzing Graph Transformation Systems through Constraint Handling Rules}
\shorttitle{Analyzing GTS through CHR}

\author[Frank Raiser, Thom Fr{\"u}hwirth]{FRANK RAISER \and THOM FR{\"U}HWIRTH\\
Faculty of Engineering and Computer Sciences, Ulm University, Germany\\
\email{\{Frank.Raiser|Thom.Fruehwirth\}@uni-ulm.de}}

\maketitle 



\begin{abstract}
Graph transformation systems (GTS) and constraint handling rules (CHR) are
non-deterministic rule-based state transition systems. 
CHR is well-known for its powerful confluence and program equivalence analyses,
for which we provide the basis in this work to apply them to GTS.
We give a sound and complete embedding of GTS in CHR, investigate confluence of
an embedded GTS, and provide a program equivalence analysis for GTS via the
embedding.
The results confirm the suitability of CHR-based program analyses for
other formalisms embedded in CHR.
\end{abstract}

\begin{keywords}
Graph Transformation Systems, Constraint Handling Rules, Program Analysis
\end{keywords}

\section{Introduction}
\label{sec:intro}

Graph transformation systems (GTS) are used to describe complex structures and
systems in a concise, readable, and easily understandable way. They have
applications ranging from implementations of programming languages over model
transformations to graph-based models of computation
\cite{Blostein1995,ehrigprangetaentzer06}. Graph transformation systems see
widespread use in many applications \cite{ehrigprangetaentzer06}, and hence
performing program analysis on them is becoming more important.

Constraint handling rules (CHR) \cite{fruehwirth09} on the other side allows for
rapid prototyping of constraint-based algorithms. Besides constraint reasoning,
CHR has been used for such diverse applications as type system design for Haskell
\cite{sulz_schr_stuck_aplas06}, time tabling
\cite{abd_marte_timetabling_chr_aai00}, computational linguistics
\cite{dahl_maharshak_dna_replication_iwinac09}, chip card verification
\cite{pretschner_et_al_model-based_testing_sttt04}, computational biology
\cite{bavarian_dahl_bio_seq_analysis_jucs06}, and decision support for cancer
diagnosis \cite{alma_thesis05}. Essentially, CHR performs guarded multiset
rewriting, extended by a complete and decidable constraint theory. A specific
strength of CHR is the wide array of available program analyses. Other formalisms
have been embedded in CHR in order to compare and mutually benefit from different
analysis approaches (cf. Section~\ref{sec:related_work}). In this work, we extend
this line of research by embedding graph transformation systems in CHR and
comparing confluence and operational equivalence analysis methods.

First, we embed graph transformation systems in CHR \cite{raiser07iclp} in
Section~\ref{sec:encoding}. This encoding is intuitive and offers a clear
one-to-one correspondence between GTS and CHR rules. Our proposed encoding
characterizes a subset of CHR that closely corresponds to graph transformation
systems, and furthermore we prove its soundness and completeness. Then, we show
that CHR is capable of expressing infinite numbers of graphs, which we will call
\emph{partial graphs}, and their transformations in a finite way, thus
facilitating program analysis.

\begin{figure} 
\centerline{
\xymatrix{
& \ar@{=>}[dl]_{r_1} \sigma \ar@{=>}[dr]^{r_2} &\\
\sigma_1 \ar@{=>}[dr]^{*} & & \ar@{=>}[dl]_{*} \sigma_2\\
& \sigma_1' \simeq \sigma_2' &
}}
\caption{Confluence Property for rules  and }
\label{fig:confluence}
\end{figure}

In non-deterministic rule-based systems, like GTS and CHR, two or more rules can
be applied to a state~. An interesting property in that respect is the
notion of \emph{confluence}, which holds, if for any case in which two rules are
applicable there exist computations yielding the same, or equivalent, results.
This situation is displayed in Figure~\ref{fig:confluence}, which due to its
shape is referred to as the \emph{diamond property}.

For terminating CHR programs a decidable automatic confluence test exists, based
on research in the area of term-rewriting \cite{baadernipkow98}. However as shown
in \cite{plump05}, an analogous approach fails for graph transformation systems.
Therefore, confluence analysis is an important example for a program analysis of
a GTS with methods from CHR. In Section~\ref{sec:confluence} we show that the
confluence test for CHR coincides with the strongest known sufficient criterion
for confluence of a GTS \cite{Raiser2009}.

\begin{figure} 
\centerline{
\xymatrix{
& \ar@{=>}[dl]_{\mcP_1} \sigma \ar@{=>}[dr]^{\mcP_2} &\\
\sigma_1 \ar@{=>}[dr]^{\mcP_1^*} & & \ar@{=>}[dl]_{\mcP_2^*} \sigma_2\\
& \sigma_1' \simeq \sigma_2' &
}}
\caption{Operational Equivalence for programs  and }
\label{fig:opeq}
\end{figure}

In Section~\ref{sec:opeq} we examine operational equivalence
\cite{abdennadherfruehwirth99} as a second example of a program analysis that is
available for CHR and can be applied to GTS. Operational equivalence,
intuitively, decides if two programs can compute equivalent results when given
the same input, as shown in Figure~\ref{fig:opeq}. The diamond shape in
Figure~\ref{fig:opeq} emphasizes the similarity to confluence, which is also
found in the respective program analysis methods. We introduce operational
equivalence in the GTS context in analogy to CHR \cite{Raiser2009b}. Then, we
prove that deciding operational equivalence of a CHR program, derived from a GTS,
is a sufficient criterion for operational equivalence of the corresponding GTS.

An interesting application of this result is the possibility to detect and
remove redundant rules using the test for operational equivalence. Redundant rules of
graph transformation systems have been formally defined in \cite{Kreowski2000},
however to the best of our knowledge, this is the first available algorithm for
detecting them in a GTS.

This work presents a unified treatment and considerable extension of previously
published works
\cite{raiser07iclp,Raiser2009a,Raiser2009c,Raiser2009b,Raiser2009}. In
\cite{Raiser2009a} a formal treatment of CHR state equivalence is provided and,
derived from that, a simplified formulation of the operational semantics of CHR.
This novel formulation allows us to unify our previous works while simplifying
presentation and formal proofs significantly. Furthermore, the state equivalence
definition from \cite{Raiser2009a} is the basis for new insights on CHR states
that encode graphs.

\section{Preliminaries}
\label{sec:preliminaries}

In this section we introduce the required formalisms for graph transformation
systems in Section~\ref{sec:prelim:gts} and constraint handling rules in
Section~\ref{sec:prelim:chr}.

\subsection{Graph Transformation System}
\label{sec:prelim:gts}

The following definitions for graphs and graph transformation systems (GTS) have
been adapted from \cite{ehrigprangetaentzer06}.

\begin{definition}[graph] A \emph{graph}  consists of a finite set  of nodes, a finite set  of edges and two
functions  specifying source and target of an edge,
respectively. A \emph{type graph}  is a graph with unique labels for all
nodes and edges.

For simplicity, we avoid an additional label function in favor of identifying
variable names with labels. For multiple graphs we refer to the node~set~ of a
graph~ as  and analogously for edge sets and the  functions.
We further define the degree of a node as . As
there may be multiple graphs containing the same node, we use  to
specify the degree of a node~ with respect to the graph~. When the context
graph is clear the subscript is omitted.
\end{definition}

In this work, we consider typed graphs, i.e. graphs in which nodes and edges are
assigned types from a type graph.

\begin{definition}[graph morphism,typed graph] 
Given graphs  with  for  a
\emph{graph morphism}  consists of two
functions  and  that
preserve the source target functions, i.e.  and .

A graph morphism  is \emph{injective} (or \emph{surjective}) if both
functions~ are injective (or surjective, respectively);  is called
\emph{isomorphic} if it is bijective.  is called an \emph{inclusion} if
 and . When the context is
clear, we simply refer to graph morphisms as morphisms.

A \emph{typed graph}  is a tuple  where  is a graph,  a type graph, and  a graph morphism with
 and .

For a typed graph~ we define a
\emph{subgraph}~ as a typed graph~ such that
 with .
\end{definition}

\begin{example}Figure~\ref{fig:type} shows an example for a type graph and a
corresponding typed graph. The type graph at the top defines two types of nodes:
processes and resources. Furthermore, it defines \emph{use} edges going from
processes to resources. The typed graph is one possible instance of a graph
modeling processes and resources being used by those processes. The 
graph morphism is represented by the dotted lines, showing how the nodes are
typed as processes or resources, respectively.
\end{example}

\begin{figure}
\centerline{
\scalebox{0.4}{\includegraphics{type}}
}
\caption{Example of a type graph and typed graph}
\label{fig:type}
\end{figure}

\begin{definition}[GTS, rule] A \emph{Graph Transformation System} (GTS) is a
tuple consisting of a type graph and a set of graph production rules. A
\emph{graph production rule} -- simply called \emph{rule} if the context is clear
-- is a tuple \prodrule of graphs , and  with inclusion morphisms  and .
\end{definition}

We distinguish two kinds of typed graphs: \emph{rule graphs} and \emph{host
graphs}. Rule graphs are the graphs  of a graph production rule  and
host graphs are graphs to which the graph production rules are applied. This work
is based on the double-pushout approach (DPO) as defined in
\cite{ehrigprangetaentzer06}. Most notably, we require a \emph{match~morphism}~ to apply a rule  to a typed host graph . The
transformation yielding the typed graph  is written as .  is given mathematically by constructing
 as shown in Figure~\ref{fig:dpo}, such that (1) and (2) are pushouts in the
category of typed graphs. Intuitively, the graph~ is matched to a subgraph of
 and its occurrence in  is then replaced by the graph~. The intermediate
graph~ is the \emph{context graph}, which contains the nodes and edges in
both  and , i.e. all nodes and edges matched to  remain during the
transformation.

\begin{figure} 
 \centerline{
  \xymatrix { 
   L \ar[d]_m \ar @{} [dr]|{(1)} & \ar[l]_l \ar[d]_k K \ar[r]^r \ar @{}
   [dr]|{(2)} & \ar[d]_n R \\ G  & \ar[l]_f D \ar[r]^g & H
  }
 }
  
 \caption{Double-pushout approach}
 \label{fig:dpo}
\end{figure}

A graph production rule  can only be applied to a host graph  if the
following gluing condition is satisfied. In fact, \cite{ehrigprangetaentzer06}
shows, that  and the pushout~(1) exist if and only if this gluing condition is
satisfied. It is based on the following three sets \cite{ehrigprangetaentzer06}:

\begin{itemize}
  \item gluing points: 
  \item identification points: 
  \item dangling points: 
\end{itemize}

\begin{definition}[gluing condition]
The \emph{gluing condition} is defined as .
\end{definition}

If the gluing condition is satisfied for a rule  the application of
the rule consists of transforming  into  by performing the construction
described above. An implementation-oriented interpretation of a rule application
is that all nodes and edges in  are removed from  to
create  and then all nodes and edges in  are added to create .

\begin{example}\label{ex:gts}
Figure~\ref{fig:cyclic_grs} shows two graph production rules in a shorthand
notation that defines the morphisms  and  implicitly by the labels of the
nodes which are mapped onto each other. The resulting graph transformation system
is implicitly defined over the simple type graph consisting only of a single node
with a loop, depicted in Figure~\ref{fig:trivial_type}.

The two rules constitute a graph transformation system for detecting cyclic
lists. The basic idea of the \emph{unlink} rule is to remove intermediate nodes
of the list, while the \emph{twoloop} rule replaces the cyclic list consisting of
two nodes by a single node with a loop. Note that application of the
\emph{twoloop} rule requires that no additional edges are adjacent to the removed
node. Such \emph{dangling edges} are discussed in more detail in
Section~\ref{sec:encoding}.

To detect if a host graph is a cyclic list, the GTS is applied to the host graph
until exhaustion, i.e. until no rule is applicable anymore. The initial host
graph then is a cyclic list if and only if the final graph consists of a single
node with a loop (cf. \cite{bakewellplumprunciman03}).

\begin{figure}
\centerline{
\scalebox{0.5}{\includegraphics{cyclic}}
}
\caption{Graph transformation system for recognizing cyclic lists}
\label{fig:cyclic_grs}
\end{figure}

\begin{figure}
\includegraphics{trivial_type} 
\caption{Simple type graph consisting of a node and edge}
\label{fig:trivial_type}
\end{figure}
\end{example}

In general, the match morphism  can be non-injective. However, for the
remainder of this work we only consider injective match morphisms, which have the
advantage that the set  of identification points is guaranteed to be
. Furthermore, non-injective match morphisms can be simulated as
follows: given a rule  and a non-injective match morphism  it holds
 with  that the rule is only
applicable, if , i.e. only nodes which are not removed by the
rule application are allowed to be matched non-injectively -- otherwise . Therefore, it is possible to add another rule  which is
derived from  by merging the nodes  and  into a node  in all three
graphs of the rule. Thus, the non-injective matching with  can be
simulated by injectively matching  to  where  is the same
node in  as . The same argumentation holds for edges, analogously.
Therefore, we can restrict ourselves to injective match morphisms by extending
the set of rules with new rules for all possible merges of nodes and edges in the
graph . This simplifies the generic gluing condition to .

Finally, we require the following definition of the track morphism
\cite{Plump1995}. Intuitively, the track morphism is defined for a node or edge,
if it is not removed by the rule application.

\begin{definition}[track morphism]\label{def:track} Given 
the \emph{track morphism}  is the partial
graph morphism defined by 
Here  and  are the morphisms in the
lower row of the pushout~(1) in Figure~\ref{fig:dpo} and  maps each item  to .

The track morphism of a derivation  is defined by
 if  and  otherwise, where
 is the identity morphism on .
\end{definition}


\subsection{Constraint Handling Rules}
\label{sec:prelim:chr}
This section presents the syntax and operational semantics of Constraint Handling
Rules (CHR) \cite{chr_survey_tplp08,fruehwirth09}. Constraints are first-order
predicates which we separate into \emph{built-in constraints} and
\emph{user-defined constraints}. Built-in constraints are provided by the
constraint solver while user-defined constraints are defined by a CHR program.
The notation~, where  is called the \emph{constraint symbol} and  the
\emph{arity}, is used for both types of constraints.

Its semantics is based on an underlying complete \emph{constraint theory}~
on built-in constraints for which satisfiability and entailment are decidable. In
general, CHR allows arbitrary constraint theories for \CT, requiring only that it
contains at least Clark's equality theory for syntactic equality. In addition to
that, in this work we also require \CT\ to cover the elementary arithmetic
operations~ and . Furthermore,  denotes the built-in which is
always true and  denotes false, respectively.

The survey \cite{chr_survey_tplp08} provides an overview over the different
techniques used in CHR implementations and the book \cite{fruehwirth09} details
the different available operational semantics for CHR. In this work we abstract
from specific implementations and rely on the operational semantics given in
\cite{Raiser2009a}, which corresponds to the \emph{very abstract operational
semantics} in \cite{fruehwirth09}.

CHR is a state transition system over the set of states given in the following
definition.

\begin{definition}[CHR states] 
\label{def:states}

A \emph{(CHR) state} is a tuple 

\bbG\ is a multiset of user-defined constraints called the \emph{goal} (or
\emph{(user-defined) constraint store}), \bbB\ is a conjunction of built-in
constraints called the \emph{built-in (constraint) store}, and \bbV\ is the set
of \emph{global variables}.

In this work  denote CHR states and  denotes the
set of all CHR states.
\end{definition}

The following definition introduces the different types of variables we
distinguish for a given CHR state.

\begin{definition}[Variable Types]\label{def:var_types} For the variables
occurring in a state~ we distinguish three
different types:
\begin{enumerate}
  \item a variable~ is called a \emph{global} variable
  \item a variable~ is called a \emph{local} variable
  \item a variable~ is called a
  \emph{strictly local} variable
\end{enumerate}
\end{definition}

The following equivalence relation~ between CHR states \cite{Raiser2009a}
is an important tool that facilitates a succinct definition of the operational
semantics of CHR and simplifies proofs.

\begin{definition}[State Equivalence]
\label{def:equiv}

Equivalence between CHR states is the smallest equivalence relation~
over CHR states that satisfies the following conditions:

\begin{enumerate}
\item \label{cond:subst} \emph{(Substitution)}

\item \label{cond:ct} \emph{(Transformation of the Constraint Store)} If
 where  are the strictly local variables of , respectively,
then:

\item \label{cond:global} \emph{(Omission of Non-Occurring Global Variables)} If
 is a variable that does not occur in  or  then:

\item \label{cond:fail} \emph{(Equivalence of Failed States)}

\end{enumerate}

\end{definition}

The following lemma presents basic properties of this equivalence relation:

\begin{lemma}[Properties of State Equivalence \cite{Raiser2009a}]
\label{lem:equiv_props}
The equivalence relation over CHR states, given in Definition~\ref{def:equiv},
has the following properties:

\begin{enumerate}
\item \label{prop:rename} \emph{(Renaming of Local Variables)} Let  be
variables such that  and  does not occur in  or :

\item \label{prop:partial} \emph{(Partial Substitution)} Let  be a
multiset where \emph{some} occurrences of  are substituted with :

\item \label{prop:lequiv} \emph{(Logical Equivalence)} If

then ,  where  are the local
variables of , respectively.
\end{enumerate}
\end{lemma}

Decidability of state equivalence is a result of the following theorem from
\cite{Raiser2009a}:

\begin{theorem}[Criterion for  \cite{Raiser2009a}]\label{thm:equiv_tf} Let
 be CHR states with
local variables~ that have been renamed apart.
\end{theorem}

As CHR is a rule-based programming language we now introduce the different
types of possible CHR rules.

\begin{definition}[CHR Rules, CHR Program]\label{def:rules}
For multisets~ of user-defined constraints with  and conjunctions  of built-in constraints a CHR
\emph{simpagation} rule is of the form

For the case~ we call the rule a \emph{simplification} rule
and denote it as

and for the case~ we call the rule a \emph{propagation} rule
and denote it as

If  it can be omitted together with the .

A \emph{CHR program} is a set of CHR rules.
\end{definition}

Next, we define the operational semantics of CHR by introducing its transition
relation~ based on the formulation given in \cite{Raiser2009a}, which
relies on equivalence classes of CHR states. In the remainder of this work we
take the liberty of notationally identifying a CHR state~ with its
equivalence class~. Furthermore, we simplify multiset expressions like
 to  or .

\begin{definition}[Operational Semantics] \label{def:opsem}

For a CHR program~ we define the state transition
system~ as follows. The application of a rule~ assumes a copy of it that contains only fresh variables.

\begin{center}
\textwidth 9.5cm
\begin{tabular}{c}
 \\
\hline

\end{tabular}
\end{center}
\end{definition}

Simplification rules are only syntactically different, but operate as described
by Definition~\ref{def:opsem} with , respectively. Note that
propagation rules lead to trivial non-termination in this formulation, however
that is no problem here, because the work at hand requires no propagation rules.

A rule~ is \emph{applicable} to a state~ if and only if there
exists a state~ such that . We say that a state~
is \emph{final} if and only if there exists no state~ with . As usual,  denotes the reflexive-transitive closure of .
When we want to emphasize that a transition uses a specific rule~ we denote
this by . When discussing multiple programs,  denotes a
transition using a rule of program~\mcP.

\begin{example}[Example Computation]
In this comprehensive example, we present a complete computation in CHR. Readers
already familiar with CHR may want to skip this.

The following rule \cite{fruehwirth09} is a program for computing the minimum of
a multiset of numbers: 

Intuitively, two  constraints are matched and the one with the larger
number is removed. We will now walk through the detailed computation of running
the following input~ on the above program, in order to determine the
minimum of the numbers~, and : 

First, we take a fresh copy of the rule as demanded by
Definition~\ref{def:opsem}: 

Next, we apply Definition~\ref{def:equiv} in order to show that  is
contained in the equivalence class required for applying this rule (we use
 here):


Hence, all conditions for Definition~\ref{def:opsem} are satisfied, so we can
apply the rule to the equivalence class of , getting , or more precisely, : 


Next, we repeat this procedure for another application of the above rule, based
on the following fresh copy: 

This results in the expected answer, that  is the minimum of the
numbers~, and :


We can also witness the difference between global and local variables in this
computation. While the variable~ is no longer used in a CHR constraint in the
final state, we still have to keep track of the information~, because it is
a global variable. The auxiliary variables~ instead, are local
when used in a CHR constraint and strictly local, when only occurring in the
built-in store. In the latter case we may replace the built-in store by a
logically equivalent representation that removes the strictly local variables.
\end{example}

\section{Embedding GTS in CHR}
\label{sec:encoding}

In this section we encode rules of a graph transformation system as CHR rules and
discuss how host graphs are encoded in CHR to work with these rules.
Section~\ref{sec:default_encoding}  defines the necessary encoding and presents
an example computation in CHR. We then analyze formal properties of graph
transformation systems embedded in CHR in Section~\ref{sec:properties}. Finally,
Section~\ref{sec:encoding_discussion} discusses the suitability of this encoding
for program analysis and variations of the encoding.

In this work, we assume that the CHR programs resulting from encoding a GTS are
executed only with encodings of graphs. Naturally, we may provide the CHR
programs with completely different inputs or inconsistently encoded graphs. It is
clear, that we cannot expect any meaningful results from such computations,
hence, for the remainder of this work we restrict all observations to programs
and states that correspond to GTS and graphs. We formalize this restriction in
Section~\ref{sec:properties} by means of an invariant. Therefore, on one hand any
state that violates the invariant will not be considered as input, and on the
other hand any graph can be encoded into a state that satisfies the invariant. We
show in Section~\ref{sec:sound_complete} that execution of the encoded GTS in CHR
for invariant-satisying states always leads to results that also satisfy the
invariant. In other words, when providing a graph as input to the CHR program,
the result will also be a graph, as is to be expected.

\subsection{CHR Encoding of a GTS}
\label{sec:default_encoding}

First, we determine the necessary constraint symbols for encoding rule and host
graphs. At this point we require the GTS to be typed, so this can be directly
inferred from the corresponding type graph as explained in
Definition~\ref{def:constraints_i}. Note that this is not a restriction though,
as every untyped graph can be typed over the type graph consisting of a single
node with a loop (cf. Figure~\ref{fig:trivial_type}).

\begin{definition}[type graph encoding] \label{def:constraints_i}
For a type graph  we define the set  of required constraint
symbols to encode graphs typed over  as the minimal set satisfying:
\begin{itemize}
  \item If  then .
  \item If  then .
\end{itemize}
\end{definition}

We assume that all constraints introduced by Definition~\ref{def:constraints_i}
have unique names. Furthermore, for graphs to be encoded with these constraints,
we associate elements of the set~ of nodes with integer numbers or letters
that can be used as arguments.

\begin{definition}[typed graph encoding]\label{def:encoding}
 
We define the following helpful mappings for an infinite set
of variables~\VARS:

\begin{itemize}
  \item  denotes the corresponding constraint symbol for encoding a
  node or edge of the given type.

  \item  such that  is a unique
  variable associated to , i.e.  is injective for  being the set of
  all graph nodes and edges.
  
  \item  such that  is a unique
  variable associated to , i.e.  is injective for  being the set of
  all graph nodes and edges and different from .
\end{itemize}

Using these mappings we define the following encoding of graphs:


We use the notations  as
well as . Furthermore, we omit the
index~ if the context is clear. We call  the \emph{degree variable}
for a node~.

A host graph~ is encoded in CHR as , where
\bbV\ can be chosen freely.
\end{definition}

\begin{figure}
\includegraphics{loop2}
\caption{Cyclic graph consisting of two nodes} 
\label{fig:loop2}
\end{figure}

\begin{example}[cont] For our example of the GTS for recognizing cyclic lists we
assume the type graph in Figure~\ref{fig:trivial_type}. Based on this type graph
we need the constraints  and . The host graph~ given in
Figure~\ref{fig:loop2} that contains a cyclic list consisting of exactly two
nodes is encoded in  as:  The same
graph~ encoded in  has the following form: 
\end{example}

We can now encode a complete graph production rule based on these definitions:

\begin{definition}[GTS rule in CHR]
\label{def:chr_rule}
For a graph production rule~\prodrule from a GTS we define  with
\begin{itemize}
  \item 
  \item \\ 
  \item 
\end{itemize}
\end{definition}

A CHR program that is created from a GTS according to the above definition, will
be referred to as a \emph{GTS-CHR program} for the remainder of this work.

\begin{example}[cont.]\label{ex:twoloop}As an example, consider the second rule
from Example~\ref{ex:gts}, which reduces two cyclic nodes to a single node with
a loop. Its encoding as a CHR simplification rule is given below: \\
\begin{tabular}{ll} 
twoloop  & \\
& \\
& \\
& 
\end{tabular}

Note that it is also possible to simplify this encoding, as explained later in
Section~\ref{sec:diff_encoding}.
\end{example}

When applying a GTS rule the gluing condition has to be satisfied. Due to our
restriction to injective match morphisms, the gluing condition is violated if
there exists  with . Intuitively, when a node gets
deleted by a rule, the corresponding node in the host graph may have an edge
adjacent to it which is not explicitly given in the rule. In such a case, the
remaining edge would be left \emph{dangling} as it is no longer adjacent to two
nodes. Therefore, this situation has to be avoided and before a rule is applied
to a host graph, we first have to ensure that there are no dangling edges
according to the following definition:

\begin{definition}[dangling edge]A \emph{dangling edge} is an edge  such that there is a node  with 
.
\end{definition}

\begin{figure}
\includegraphics{dangle}
\caption{Graph with a dangling edge if node~2 is removed by the
\emph{twoloop} rule}
\label{fig:dangle}
\end{figure}

\begin{example}[cont.] Consider the \emph{twoloop} rule given in
Example~\ref{ex:twoloop}, along with the following encoded host graph shown in
Figure~\ref{fig:dangle}:


Applying the \emph{twoloop} rule to this graph to remove the node  would
leave the edge~ dangling. However, this is avoided as the encoding of the
\emph{twoloop} rule contains the following constraint in its head: . Hence, only a node with a degree of exactly  can be removed by this rule.
Nevertheless, the rule can be applied with  as the node  has the
required degree of .
\end{example}

\subsubsection{Example Computation}
\label{sec:encoding_example}

In this section we provide a complete computation for our cyclic list example to
demonstrate how our encoding works. The following two rules are the CHR encoding
of the rules in Figure~\ref{fig:cyclic_grs}:

\begin{center} 
\begin{tabular}{ll}
\emph{unlink}\ @ & \\
				& \\
                & \\
                & \\
                & \\
                &\\
\emph{twoloop}\ @ &  \\
				 &  \\
				 &  \\
				 & \\
				 & 
\end{tabular}
\end{center}

The following state~ encodes a cycle consisting of three nodes. The
following computation is depicted in Figure~\ref{fig:ex_comp}. To demonstrate
computations on partially defined graphs, further discussed in
Section~\ref{sec:encoding_discussion}, the degree of the third node is left
uninstantiated:



Rule~\emph{unlink} is applied to state~ resulting in the state



which is equivalent to state~:



Finally, rule~\emph{twoloop} is applied to  to remove node~,
resulting in :



As can be seen the built-in store may contain a chain of degree adjustments for
nodes with initially uninstantiated degree, although in this example it is not
the case as all degrees remain unchanged. The other interesting consequences of
partially uninstantiated encodings are investigated more thoroughly in
Section~\ref{sec:encoding_discussion}.

\begin{figure}
\includegraphics{ex_comp}
\caption{Example computation} 
\label{fig:ex_comp}
\end{figure}

\subsection{Formal Properties}
\label{sec:properties}

This section examines formal properties of the encoding given in
Section~\ref{sec:default_encoding}. First, Section~\ref{sec:graph_states}
analyzes the special CHR states found when working with a GTS-CHR program. Then
we prove soundness and completeness of the encoding in
Section~\ref{sec:sound_complete}.

Our encoding is based on the assumption that the resulting CHR programs are
executed only for initial states that correspond to graphs. We are not interested
in executions for arbitrary CHR states.

\subsubsection{States Encoding Graphs}
\label{sec:graph_states}

In this section we compare the different equivalence notions, i.e. graph
isomorphism and CHR state equivalence, and present a formal characterization of a
CHR state~ that is the encoding of a graph~.

In order to determine if a CHR state encodes a graph, we define a predicate that
holds if and only if this is the case. It is intuitively clear, that starting
with the encoding of a graph and transforming it via a graph transformation rule
yields the encoding of a graph again. Formally, this is an invariant according to
the following definition. The first appearance of invariants in CHR research is
found in \cite{lam_sulz_linear_logic_agents_chr06} in the context of agent
programming.

\begin{definition}[Invariant]\label{def:invariant}

An \emph{invariant}~ is a predicate such that for all  and
, we have that if  (or ) and  then .
\end{definition}

The definition below introduces our desired property for CHR states. Note that it
is referred to as an invariant here, although we do not require it to be an
invariant throughout this section. In Section~\ref{sec:sound_complete}, more
precisely Corollary~\ref{cor:g_invariant}, we will show that it is indeed a
proper invariant.

\begin{definition}[Graph Invariant]\label{def:inv_graph}

Let  be a state where  are
constraints of the form~ for constants~ and  are constraints of
the form~ for constants~.

The \emph{graph invariant}~ holds for state  if and only if there
exists a graph~ and a conjunction~ of equality constraints of the
form~ for a variable~ and constant~, such that 

For a state~ for which  holds with a graph~ we say
 is a -\emph{state~based~on}~.
\end{definition}

\begin{example}

Consider again the final state~ from the example computation in
Section~\ref{sec:encoding_example}:


By using the equality constraint~ the resulting state for
Definition~\ref{def:inv_graph} is equivalent to: 

Let  be the graph consisting of a node~ with a loop, then . Therefore, the invariant~
is satisfied for the above state~ as the corresponding states are
equivalent by renaming of local variables.

This example further shows why the variable set~ is disregarded for the two
states. The variable given by  for a node of the graph has to coincide with
the corresponding global variable for both states to be equivalent. Hence, for
the above graph with node~, knowledge of the state~ would be
necessary to determine that . Omitting global variables from both
states, however, allows us to freely map~ to any variable through .
\end{example}

\begin{example} 

For the state~ there clearly exists such
a graph~, for which  simply assigns the corresponding degree variables.
States may also be in-between  and  in the sense
that only some of the degree variables are instantiated, resulting in a state~ with  being the corresponding equality
constraints. By instantiating the remaining degrees it is clear that
 holds.
\end{example}

Note that arithmetic built-in constraints, introduced by bodies of rules in order
to adjust a node's degree, are covered by the above graph invariant definition:
The introduction of the corresponding degree equality constraint leads to a
collapse of the chain of arithmetic constraints. Hence, the concept of a
\mcG-state~based~on~ also applies to intermediate computation states, which
gives rise to the following lemma.

\begin{lemma}[Graph States]\label{lem:graph_states} Let  hold for a
state~, then there exists a graph~ such that 
\begin{itemize}
  \item  is a conjunction of  constraints
  \item  is a conjunction of 
  constraints
\end{itemize}
\begin{proof}

Let , then by Def.~\ref{def:inv_graph} we have
that  for a graph~ and  constraints~.

W.l.o.g. all identifier variables occurring in  (and therefore in
) also occur in  as identifier variables. Due to the state
equivalence the difference between \bbG\ and  can then only consist
in \bbG\ specifying some node degrees by constants (for degree variables we can
again assume that they are the same as in ).

Let  be a conjunction of equality constraints of the form~ for each
degree specified explicitly in \bbG, using fresh variables for . Interpreting
 as a substitution, replacing  with  for each of the equivalences,
we have that  As all
variables occurring in  are local, we get by
Def.~\ref{def:equiv}:
\end{proof}
\end{lemma}

The reverse direction of Lemma~\ref{lem:graph_states} does not hold in
general: The state~ satisfies the conditions for an empty graph~, but of
course  does not hold, as .

The following lemma presents an interesting fact of the correspondence between
state equivalence and graph isomorphism: equivalent CHR states encoding two
graphs imply that these graphs are isomorphic.

\begin{lemma}[Equivalent \mcG-states imply Graph Isomorphism]
\label{lem:eq_iso}

Given a state , a
\mcG-state~based~on~, and a state , a \mcG-state~based~on~, then 
\begin{proof}

First, we note that  consist only of degree equalities or
adjustments. Therefore, we consider the following states instead, which are
already sufficient to imply the isomorphism:  W.l.o.g. let the local variables occurring in the two states be disjoint (it
is clear that otherwise we can consider equivalent states that only differ by
renaming of local variables and that these states all provide corresponding graph
isomorphisms).

Let  and  be the set of local variables of the two states. We
can then apply the criterion from Thm.~\ref{thm:equiv_tf} to get  As there are only variable
terms contained in this equivalence we have the following conclusion, where
 is any constraint with argument terms, i.e. variables,~.  We know that  is
surjective (as the variables are disjoint and the above equality demands that at
least one variable from  is mapped to each variable in ). A
consequence of this is that .

Analogously, we get from  that , and hence, .
From this follows that  is also injective, and therefore, bijective.

Next we realize, that by the above equality,  has to map local variables
corresponding to node identifiers to local variables that also correspond to node
identifiers. Let 
be the local variables used for node identifiers, then  is a well-defined and bijective
function. We use this to define the actual graph isomorphism function~:

 is well-defined: for every node there is a corresponding node identifier
variable and it has to be either global or local. If it is local, then  has
to map it to another local variable, as otherwise the  relation cannot
hold. Furthermore,  is bijective as well, because it is defined
bijectively via  on local variables and the identity function on global
variables.

Finally,  is a graph isomorphism: By the above equality we have corresponding
pairs of edge constraints. For every edge adjacent to a node given by a global
variable, the corresponding edge has to be adjacent to the same node with the
same global variable in order to satisfy . If the edge is adjacent to a
node identified by a local variable, then this variable is bijectively mapped to
another local variable and the above equality ensures that the corresponding edge
is adjacent to the same node as well. 
\end{proof}
\end{lemma}

The reverse direction of Lemma~\ref{lem:eq_iso} cannot hold in general:
The encoding of the graphs~ and  are independent from determining the
set~\bbV\ of global variables. Even a graph consisting of a single node only can
be encoded in two ways, such that the states are not equivalent:


As indicated in Section~\ref{sec:encoding_example}, states may contain node
encodings with a variable degree. As these states are fundamental for program
analysis the following definition characterizes the set of these nodes.

\begin{definition}[Strong Nodes]\label{def:strong_state}

For a CHR state~ which is a
\mcG-state~based~on~ we define the set of \emph{strong nodes} as: 
\end{definition}

The effect of strong nodes on computations and their use in program analysis is
discussed in detail in Section~\ref{sec:encoding_discussion}.

\subsubsection{Soundness and Completeness}
\label{sec:sound_complete}

In this section, we prove soundness and completeness of our embedding. That
 is an invariant for a GTS-CHR program and that termination of a GTS and
its GTS-CHR program coincide, are then derived as consequences of the main
theorem below.

\begin{theorem}[Soundness and Completeness]\label{thm:sound_and_complete}

Let  be a CHR state with
 holding with graph~. Then 
\centerline{if and only if}


\begin{proof}

In order to shorten this proof we use  and  to denote 
and , respectively.

``'':

Let  and let .

Let .

Let  with .

For  we have  and\\
, as the types match due to
 being a graph morphism.

As we have a fresh rule using node~ that does not occur elsewhere we can say
that , and hence


Consider , then . Assume that , then 
is defined, which is a contradiction to . Therefore,  and hence . As
 satisfies the gluing condition, we know 
that . Therefore, we have that


From \eqref{eq:sigma_subst} for nodes~ and the above for nodes~ follows for a conjunction of equality constraints~ that 

Let , than 
and after the previous substitutions have been made for node identifier
variables, and as , we get
 . We then have


By applying this substitution for all edges~ and extending  with
the required equalities to  we get:  Hence,  such that we apply the rule~ to
: 

As  contains  let  be
 without these constraints, then


Let , then  with . Furthermore, consider  a substitution corresponding to the reverse
reading of  which undoes the ideas of \eqref{eq:sigma_subst} and
\eqref{eq:sigma_subst3} for all affected nodes and edges. We then get



We get the graph~ as its DPO construction corresponds to the removal of  and addition of .  is needed to attach the
new nodes of  to nodes from  and  contains degree
adjustments for those nodes that are correct by construction. Hence, it also
holds that  is satisfied with graph~.

\vskip1cm
``'':

Let  with  and
 holds with graph~. Let  with . From Def.~\ref{def:opsem}
follows that


Using Lemma~\ref{lem:graph_states} and with  being a conjunction of
 constraints for  we get: 
where  is the extension of  with  constraints
for  and .

 is well-defined and injective by the multiset semantics of
CHR and it remains to be shown, that  is a graph morphism. Therefore, let , then  and
. Hence, ,  and
 are all in . Therefore, .

The gluing condition is satisfied, as  the
matched degree ensures that there are no dangling edges, hence,  is
GTS-applicable to . Similarly to the other proof direction, we show that the
DPO construction of  coincides with the construction of  by CHR rule
application:

 where  is the reverse substitution for  similar to the other proof
direction. The final equivalence comes from extracting the degrees of constraints
in  into equality constraints contained in . As can be
seen here, the application of the rule results in a state encoding the graph~,
such that  holds.

Finally, for the set~ we know that the nodes cannot be removed
by rule~: For a node~ we have
, but this cannot be matched with
, as by Def.~\ref{def:strong_state} the corresponding degree is
unavailable. Hence, none of the nodes from  are removed by the
rule application~, i.e.  is defined for all .
\end{proof}
\end{theorem}

As can be seen in the proof of Theorem~\ref{thm:sound_and_complete}, a GTS-CHR
rule application on a \mcG-state~based~on~ always results in a state encoding
a corresponding graph~, which gives us the following corollary.

\begin{corollary}[\mcG\ Invariant]\label{cor:g_invariant}

For a GTS-CHR program \mcG\ is an invariant.
\end{corollary}

A closer look at the conditions required in Theorem~\ref{thm:sound_and_complete}
reveals that for a state~ with , i.e. for an
encoding of a graph with all degrees explicitly given, we have unrestricted
soundness and completeness.

\begin{corollary}[Unrestricted Soundness and Completeness]
\label{cor:sound_and_complete}

Let  be a CHR state with
 holding with graph~. Then 
\centerline{if and only if}

\begin{proof}
This follows from Theorem~\ref{thm:sound_and_complete} and the following
insight: as all degrees of  are specified explicitly and all nodes added by
the rule are also given explicit degrees, all degrees in  are given
explicitly as well, which allows us to use  here.
\end{proof}
\end{corollary}

Finally, the soundness and completeness result induces a termination
correspondence between a GTS and its GTS-CHR program. Again, we restrict our
observation to graph-encoding states.

\begin{corollary}[Termination Correspondence]\label{cor:termination} A GTS is
terminating if and only if its corresponding GTS-CHR program is \mcG-terminating,
i.e. terminating for all \mcG-states.
\begin{proof}
If a GTS contains a non-terminating derivation, we have the corresponding
computation in its GTS-CHR program by Corollary~\ref{cor:sound_and_complete}.
Similarly, if the GTS-CHR program has a non-terminating computation, there
exists a corresponding non-terminating GTS derivation according to
Theorem~\ref{thm:sound_and_complete}.
\end{proof}
\end{corollary}

\subsection{Discussion}
\label{sec:encoding_discussion}

In this section we discuss our previously presented encoding. First,
Section~\ref{sec:partial} investigates that a GTS-CHR program works with
partially defined graphs and explains the suitability of these graphs for program
analysis. Then we present ways to simplify the encoding of GTS-CHR rules in
Section~\ref{sec:diff_encoding}.

\subsubsection{Partially Defined Graphs}
\label{sec:partial}

In the example computation given in Section~\ref{sec:encoding_example} the input
contains a node with a variable degree: . Nevertheless,
computations on this input are possible and the example resulted in the final
state: 

In general, a variable node degree will cause a chain of degree adjustment
constraints to be created, i.e. constraints of the form .
These stem from the node being involved in a rule application that affects its
degree.

It is important to realize that we can only match such a node in rules that do
not remove it. A rule that removes a node contains the explicit degree for that
node in the head, which cannot be matched through a variable degree. As a
consequence, specifying variable degrees in the input ensures that the
corresponding nodes will not be removed by the computation. This also becomes
clear from the investigation of strong nodes in the previous section.

While this is an interesting feature in its own right, it provides the basis for
many forms of program analysis. The aim of program analysis is to make statements
on an infinite number of graphs, while only having to investigate a small
selection of graphs. Graph encodings with variable degrees can here be thought of
as partially defined graphs, i.e. there may be any number of further edges being
connected to a node with a variable degree. 

Note that partially defined graphs only exist within the CHR context. In a GTS
the degree of a node is implicitly given by the adjacent edges. As a consequence,
leaving a node's degree undefined in the CHR encoding ensures, that this node
will not be removed during computation. In the GTS context we have no such option
available for host graphs.

By the above argument, the state  therefore
not only represents the graph consisting of a single node and no edges. Instead,
it represents the set of all graphs with at least one node. Similarly, the above
final state from Section~\ref{sec:encoding_example} stands for the set of graphs
that contain at least one node with a loop.


Every computation performed on an input with variable degrees actually represents
computations for an infinite set of graphs. This is a fundamental feature for the
usage of our encoding in program analysis and will be exploited in
Sections~\ref{sec:confluence} and \ref{sec:opeq}.

\subsubsection{Different Encoding Possibilities}
\label{sec:diff_encoding}

The encoding proposed in this work can be varied in several different ways. We
chose the encoding in Definition~\ref{def:encoding} and
Definition~\ref{def:chr_rule} for this work, because it is a verbose encoding,
hence, directly presenting all its components and simplifying the proofs. In
practice however, a less verbose encoding resulting in shorter rules can be used
instead. In this section we present different possible simplifications achieving
this.

The different simplifications are illustrated by applying them to the
\emph{twoloop} rule which is of the following form when encoded as specified in
Definition~\ref{def:chr_rule}:

\begin{center} 
\begin{tabular}{ll} 
twoloop  & \\
& \\
& \\
& 
\end{tabular}
\end{center}

There are two ways to specify the degree of nodes in . The one
chosen in Definition~\ref{def:chr_rule} explicitly specifies the respective
degree in the head. Another way is to keep the degree as a variable~ in the
head and add the built-in constraint  to the guard of the rule. However,
most current CHR compilers detect these equalities and automatically transform
between them to the representation most suitable for an optimization. Therefore,
in this work we directly specify the degree in the head to avoid guards
altogether.

\paragraph{Variable Elimination}

As Definition~\ref{def:chr_rule} encodes a node~ using a new node
identifier~ with  and  is not used elsewhere,
this substitution can be included directly into the rule encoding:

\begin{center} 
\begin{tabular}{ll} 
twoloop  & \\
& \\
& \\
& 
\end{tabular}
\end{center}

Note that we perform variable elimination on node identifiers by default in the
remainder of this work. However, as we need to take degree adjustments into
account, the formulation of Definition~\ref{def:chr_rule} is simplified by the
variable duplication.

\paragraph{Arithmetic Simplification}

The degree adjustments in Definition~\ref{def:chr_rule} explicitly contain the
information on how many edges the rule deletes and creates. For the adjustment
itself, however, it is sufficient to simply adjust the degree by the actual
change in the number of edges. Additionally, if the change is , like in the
\emph{twoloop} rule, the extra local variable used for the degree can be
substituted, resulting in:

\begin{center} 
\begin{tabular}{ll} 
twoloop  & \\
& \\
& \\
& 
\end{tabular}
\end{center}

\paragraph{Elimination of Edge Identifiers}

The edge identifier variables are used throughout this work, because they
simplify dealing with the multiset semantics of CHR with respect to the edge
constraint representing exactly one edge of a graph. In a CHR implementation,
however, every constraint is implemented as a unique object -- sometimes even
annotated with an identifier number -- which makes the explicit edge identifiers
redundant. Using this idea the \emph{twoloop} rule can be further simplified to:

\begin{center} 
\begin{tabular}{ll} 
twoloop  & \\
& \\
& \\
& 
\end{tabular}
\end{center}

Note that the same argumentation cannot be applied to node identifiers, as those
are required for specifying the source and target of edge constraints.

\paragraph{Simpagation Rules}

Some nodes and edges of the left-hand rule graph~ of a GTS rule can occur only
to specify a certain graph context and are unaffected by the rule application.
For nodes this can also happen if the modification to adjacent edges results in
no change to the degree, as in the \emph{twoloop} rule. In those cases, the node
or edge is encoded in exactly the same way in the head and body of the rule.
Therefore, during the rule application the corresponding constraint is removed
and introduced again. Using a simpagation rule allows us to move such a
constraint into the part of the head which is not removed during the rule
application. This reduces the textual size of the rule as well as its execution
time, because it avoids the generation of a new constraint during the rule
application.

After applying all the previous simplifications to the \emph{twoloop} rule and
transforming it into a simpagation rule we get the following simplified rule:

\begin{center} 
\begin{tabular}{ll} 
twoloop  & \\
& \\
& \\
& 
\end{tabular}
\end{center}

One might be tempted to always create simpagation rules in
Definition~\ref{def:chr_rule}, based on the idea that the context graph~
already identifies non-removed nodes. However, the above creation of simpagation
rules with node constraints among the kept constraints, is only possible if the
respective node's degree remains unchanged by the rule application.

Readers more familiar with CHR may also wonder if propagation rules could be used
as well. It is technically possible to define a GTS rule that does not remove any
elements, but only adds new nodes and edges. However, a thusly created GTS would
suffer from a problem that in CHR literatue is referred to as trivial
non-termination (see e.g., \cite{fruehwirth09}), i.e. such a rule could be
applied infinitely often. For this reason, most CHR implementations restrict
propagation rule applications, hence, our encoding using simplification or
simpagation rules remains more faithful to the semantics of graph
transformations.

\section{Analyzing Confluence}
\label{sec:confluence}

The confluence property is relevant to both, graph transformation systems and
Constraint Handling Rules. It guarantees that any terminating computation made
for an initial state results in the same final state no matter in which order
applicable rules are applied.

In Section~\ref{sec:confl_gts} we formally introduce confluence, both for GTS and
CHR. Furthermore, we give the definitions for \emph{critical pairs} in both
systems, which are derived directly from the rules. Investigation of critical
pairs for determining confluence of a terminating rewrite system goes back to
research about term rewriting systems \cite{huet80}, and both, GTS and CHR, have
adapted the corresponding criteria.

Next, Section~\ref{sec:confl_pairs} examines the relation between critical pairs
of a GTS and its corresponding GTS-CHR program. We then introduce the concept of
\emph{observable confluence} \cite{duckstuckeysulzmann07}. It is a technical
means to restrict our observations to CHR states that correspond to graphs. This
in turn results in a closer correspondence between GTS and CHR for later results.

For terminating GTS, confluence analysis proved to be undecidable: \cite{plump05}
showed that the critical pair analysis gives only a sufficient criterion for
confluence. We show that the decidable observable confluence test of a GTS-CHR
program coincides with this criterion.

The discrepance in decidability of the two systems' confluence properties is
discussed in Section~\ref{sec:confl_discussion} for exemplary critical pair
analyses.

\subsection{Preliminaries}
\label{sec:confl_gts}

This subsection introduces the necessary definitions for GTS and CHR confluence
before comparing the two notions. Unless noted otherwise, the involved graph
transformation systems and GTS-CHR programs are assumed to be terminating.

\begin{definition}[GTS Confluence]A GTS is called \emph{confluent} if, for all
typed graph transformations  and , there is a typed graph  together with
typed graph transformations  and . \emph{Local confluence} means that this
property holds for all pairs of direct typed graph transformations  and  \cite{ehrigprangetaentzer06}.
\end{definition}

Newman's general result for rewriting systems \cite{newman} implies that it is
sufficient to consider local confluence for terminating graph transformation
systems. To verify local confluence, we particularly need to study critical pairs
and their joinability, according to the following definition based on
\cite{ehrigprangetaentzer06,plump05}.

\begin{definition}[Joinability of Critical GTS Pair]\label{def:gts_cp} Let  be two GTS rules. A
pair  of direct typed graph transformations is called a
\emph{critical GTS pair} if it is parallel dependent, and minimal in the sense
that the pair  of matches  and  is jointly surjective.

A pair  of direct typed graph transformations is called
\emph{parallel independent} if , otherwise it is called \emph{parallel dependent}.

A critical GTS pair  is called \emph{joinable} if there exist typed graphs
 together with typed graph transformations .
It is \emph{strongly joinable} if there is an isomorphism~ such that for each node~, for which  and
 are defined, the following holds:
\begin{enumerate}
  \item  and  are defined and
  \item 
\end{enumerate}
\end{definition}

A similar notion of confluence has been developed for CHR. The following
definition is an adaptation of \cite{fruehwirth09} to the operational semantics
on equivalence classes.

\begin{definition}[CHR Confluence] A CHR program is called \emph{confluent} if
for all states  and : If , then  and  are joinable. Two states  and
 are called \emph{joinable} if there exists a state  such that
.
\end{definition}

Analogous to a GTS, the confluence property for terminating CHR programs is
determined by local confluence which can be checked through critical pairs. The
following definition is adapted to the situation in this work, i.e. it only
considers simplification rules and no guards.

\begin{definition}[Joinability of Critical CHR Pair]\label{def:chr_cp} Let  be two (not necessarily different) simplification rules of the following
kind with variables that have been renamed apart: 

Then an \emph{overlap}~ of  and  is , provided  and  are non-empty
multisets,  and .

Let  and
. Then the
tuple~ is a \emph{critical CHR pair} of  and
. A critical CHR pair  is \emph{joinable} if
 and  are joinable.
\end{definition}

\subsection{Analyzing Confluence via Critical Pairs}
\label{sec:confl_pairs}

After defining the different notions of confluence we now further investigate the
difference between critical GTS pairs and critical CHR pairs for GTS-CHR
programs. The following lemma shows that there exists a corresponding overlap for
each critical GTS pair. Therefore, by examining the overlaps and using the
previous soundness result we can transfer joinability results to the critical GTS
pair.

\begin{lemma}[Overlap for Critical GTS Pair]\label{lem:cp_gts_chr}

If  is a critical GTS pair, then there exists an overlap~
of  and
 which is a
\mcG-state~based~on~ and a critical CHR pair~ such that
 is a \mcG-state~based~on~ and  is a
\mcG-state~based~on~.

\begin{proof}

Let the two GTS rules be  for  and let
. We then define the following sets of constraints
from which we construct the overlap: 

Let  and let , then  by
applying  as a substitution to , and then removing  as all
 variables for  are then strictly
local.

Similarly, , and analogously, we define 
and .

By Def.~\ref{def:chr_rule} we have that   and . As  it follows that  and  are
non-empty. To investigate if  we take a closer
look at the equality constraints imposed by : 

Except for the last row, the above equality constraints can easily be satisfied
under existential quantification. Hence, the only remaining problematic case is
when two node constraints with constant degrees are overlapped. However, the
degree of  equals the degree of  and the degree of
 due to the gluing condition being satisfied, such that this case can only
occur with equal constant degrees.

Hence,  is
an overlap of  and  with the critical CHR
pair~.\end{proof}

\end{lemma}

If we try to directly transfer the confluence property of a GTS to the
corresponding GTS-CHR program, we cannot succeed however, as in general there are
too many critical CHR pairs that could cause the GTS-CHR program to become
non-confluent. The following example provides a rule which only has one critical
GTS pair, but for which the corresponding CHR rule has three critical CHR pairs.

\begin{figure}
\includegraphics{remloop}
\caption{Graph production rule for removing a loop} 
\label{fig:remloop}
\end{figure}

\begin{example}\label{ex:confluence}
Consider the graph production rule in Fig.~\ref{fig:remloop}. It removes a
loop from a node and has the following corresponding CHR rule:

To investigate confluence one must overlap this rule with itself which yields the
following three CHR overlap states:
\begin{enumerate}
  \item \label{ex:conf:s1} 
  \item \label{ex:conf:s2} 
  \item \label{ex:conf:s3} 
\end{enumerate}

State~\eqref{ex:conf:s1} is not critical, because the corresponding pair of graph
transformations is parallel independent (cf. \cite{ehrigprangetaentzer06}, and
hence, directly joinable by applying the rule again. State~\eqref{ex:conf:s2} is
an invalid state, i.e. it violates \mcG, as it has multiple encodings of the same
node and state~\eqref{ex:conf:s3} is the encoding of the corresponding critical
pair for the graph production rule.
\end{example}

As we want to rule out invalid states, we use the following notion of observable
confluence presented in \cite{duckstuckeysulzmann07}. It is based on restricting
confluence investigations to states that satisfy an invariant. Based on these
invariants, observable confluence (or \mcI-confluence) is defined as follows:

\begin{definition}[Observable Confluence]\label{def:obs_conf}

A CHR program  is \mcI-confluent with respect to invariant~\mcI\ if the
following holds for all states , and  where
 holds: If  then
 and  are joinable.
\end{definition}

In order to use the graph invariant~\mcG\ for the notion of observable
confluence, we have to investigate the properties of this invariant. We introduce
the following definitions from \cite{duckstuckeysulzmann07}. As overlap states
themselves may not satisfy the invariant we have to examine all possible
extensions that satisfy it. Note that in \cite{duckstuckeysulzmann07} CHR states
are defined as 5-tuples consisting of a goal, user store, built-in store, token
store, and the set of global variables. As such a verbose definition is not
necessary for the remainder of this work, we use the more concise state
definition from Section~\ref{sec:prelim:chr} and have adjusted the work from
\cite{duckstuckeysulzmann07} accordingly.

\begin{definition}[Extension, Valid Extension] 

A state~ can be \emph{extended} by another
state~ as follows. We say that
 is an \emph{extension} of . A \emph{valid
extension}~ of a state~ is an extension such that
\end{definition}

When applied to confluence checking with critical pairs there are generally
infinitely many possible extensions of a critical pair. To get a decidable
criterion, the following relation on extensions \footnote{Originally, in
\cite{duckstuckeysulzmann07} this relation is defined as a partial order,
despite being neither transitive nor anti-symmetric. However, it is sufficient
for this work to consider it as a reflexive binary relation.} allows us to
consider only minimal elements.

\begin{definition}[Relation on Extensions]\label{def:partialorder}

Let  be a state, and let  and  be valid extensions of . Then we
define  to hold if
\begin{enumerate}
  \item there exists a valid extension~ of  such that 
  \item  holds.
\end{enumerate}
\end{definition}

Note that for any extension~ of a
state~ there exists a valid extension
 with , simply because the second condition in
Definition~\ref{def:partialorder} is trivially satisfied and  satisfies the first condition.

In the following we want to discuss overlap states that do not satisfy an
invariant~\mcI. Therefore, we are interested in extensions of those states, such
that the result satisfies the invariant~\mcI. The following definition introduces
the set of all those extensions and their minimal elements with respect to the
previously defined relation.

\begin{definition}

Let  be the set of all valid extensions of a state~,
and let  be the set of all valid extensions
satisfying the invariant~\mcI. Finally, let  be the
-minimal elements of .
\end{definition}

As shown in \cite{duckstuckeysulzmann07} the analysis of critical pairs can be
extended to this context. Instead of requiring joinability of a critical pair --
which might not satisfy the invariant \mcG\ -- we require joinability for all
possible extensions of a critical pair that satisfy \mcG. We make use of the
relation on extensions here, such that we only have to investigate minimal
extensions. Note that we implicitly consider minimal elements modulo built-in
equivalence, e.g., the built-in store~ subsumes equivalent stores, like
.

\begin{definition}

A program~\mcP\ is \emph{minimal extension joinable} if for all critical pairs
 with overlap~\sigcp, and for all , we have that  is joinable.
\end{definition}

It has been shown in \cite{duckstuckeysulzmann07} that joinability of critical
pairs, stemming from overlaps with minimal extensions, is a necessary and
sufficient criterion for \mcI-local-confluence if the relation on extensions is
well-founded.

\begin{lemma}[Deciding \mcI-Local-Confluence]\label{lem:obs_confl}

Given that  is well-founded for all overlaps~, then:
\mcP\ is \mcI-local-confluent if and only if \mcP\ is minimal extension joinable.
\end{lemma}

Although, in our programs built-in constraints~ and  occur, we can
consider  well-founded for the following reason: On state
components other than the built-in store the -relation
corresponds to the well-founded subset ordering with the minimal element
 (cf. \cite{duckstuckeysulzmann07}). For the built-ins, we can
consider  and  as successor/predecessor terms (as they are only used
with constants in rules), and hence, we get well-foundedness via proposition~1 of
\cite{duckstuckeysulzmann07}. 

We further note, that for any extension~ and state~ holds that
. The following discussion shows that
either  or . Whether the minimal element  exists depends
solely on  holding as the following lemma shows.

\begin{lemma}[No Minimal Elements]\label{lem:obs_confl_empty_M}

If  is violated for an overlap~\sigcp\ then no extension~
exists such that  is satisfied, i.e.
.

\begin{proof}
We proof this by a structural analysis of the overlap which gives the different
possibilities for  to be violated. W.l.o.g.
the overlap stems from the two rules~ and  with the corresponding rule graphs
, and .

First consider the case of nodes~ and  being overlapped:\\
Let  and
 be overlapped with
. The equality constraint  resembles the merging of the two graph nodes  and
. However, for the degree equalities different possibilities exist:

\begin{itemize}

  \item  and  are constants: Then , as the overlap is impossible otherwise. Then \sigcp\
  contains only one constraint~. As
  in  and  the nodes each have  adjacent edges, all constraints
  corresponding to adjacent edges in both rule graphs have to be contained in the
  overlap as well. If at least one such constraint is not part of the overlap
  then \sigcp\ contains more than  constraints corresponding to edges adjacent
  to . As the degree for the node is a constant it cannot be changed
  by any extension and the additional edge constraints cannot be removed either.
  Therefore in such a case, no extension~ can correct the degree
  inconsistency and  cannot hold.

  \item  and  are variable: In this case the overlap is possible
  without any problems. Depending on the number of overlapped adjacent edge
  constraints the degree variables can always be instantiated with the correct
  degree, thus satisfying the invariant~\mcG.

  \item w.l.o.g.  and  is a variable: this means , therefore, all edge constraints of  of edges adjacent to
   have to be overlapped with edge constraints of  corresponding to
  edges adjacent to . If there is such an edge constraint from 
  which is not contained in the overlap, then \sigcp\ contains more than  edge
  constraints corresponding to edges adjacent to . Again the degree of 
  is specified as the constant~ in \sigcp, and thus, an extension cannot
  correct this degree inconsistency. If however, all these edge constraints are
  contained in the overlap, \mcG\ is satisfied again, as there are exactly 
  such edge constraints coming from .
\end{itemize}

Finally, consider an edge being overlapped:\\
Let  and\\
, then\\
. By Def.~\ref{def:chr_rule} we have
constraints  and
. If these two
constraints are not part of the overlap, the corresponding equality
constraint~ results in a single graph
node being represented by two constraints. This is a violation of \mcG, as
 contains exactly one constraint for each node. This violation
cannot be fixed by an extension, as the conflicting additional node constraint
cannot be removed. Analogously, the two node constraints corresponding to
 and  have to be contained in the overlap.

Therefore, an overlap~\sigcp\ which violates the invariant~\mcG\ has to violate
it due to one of the above reasons for which it cannot be extended by an
extension~ such that  is satisfied.
\end{proof}

\end{lemma}

Combining these two results yields the criterion in Corollary~\ref{cor:g_confl}
for deciding \mcG-local-confluence. Note that this decision criterion is
essentially the same criterion as used for traditional local confluence, except
that the invariant~\mcG\ restricts the set of investigated overlaps.

\begin{corollary}[Deciding \mcG-Local-Confluence]\label{cor:g_confl}

\mcP\ is \mcG-local-confluent if and only if for all critical pairs~ with overlap~\sigcp, for which  holds, \mcCP\
is joinable.
\begin{proof}

This follows from the combination of Lemma~\ref{lem:obs_confl},
Lemma~\ref{lem:obs_confl_empty_M} and the insight that  is
the unique minimal extension in the case of  holding.
\end{proof}
\end{corollary}

Next we transfer the joinability of critical CHR pairs to strong joinability in
GTS:

\begin{lemma}[-Confluence Implies Strong Joinability]
\label{lem:confluence_chr_gts}
If a terminating GTS-CHR program is \mcG-confluent, then all critical GTS pairs
are strongly joinable.

\begin{proof}
Let  be a critical GTS pair. Let  and  for .

By Lemma~\ref{lem:cp_gts_chr} there exists an overlap~\sigcp\ which is a
\mcG-state~based~on~. As the critical pair  created by
the overlap~\sigcp\ is joinable we have the computations  and  with . From Thm.~\ref{thm:sound_and_complete} we know that there exist
corresponding GTS transformations . The isomorphism between  and 
follows from Lemma~\ref{lem:eq_iso}. Hence, the critical GTS pair is joinable.

To see that it is strongly joinable consider the set . Every
node~ for which  and 
are defined is a node which is not deleted by either  or . As  and
 are jointly surjective w.l.o.g. there exists a node~ of
rule~ with . As the node is not removed we know ,
and therefore, . Either the
node is not part of the overlap in , or if it is overlapped with a
node~ such that , then we also know that  due to the defined track morphism. Therefore, we always have the
node constraint~ and . As this node cannot be removed during the transformation, a
variant of this constraint with adjusted degree is also present in  and
. These two variant constraints are uniquely determined, as  by Def.~\ref{def:chr_cp}, and hence, they both have to use  for
the node identifier variable. This means we still have to show for such a
node~ that the two conditions from Def.~\ref{def:gts_cp} are satisfied:
\begin{enumerate}
  \item  and  are defined:\\
  By Thm.~\ref{thm:sound_and_complete} we know that the GTS transformations are strong
  w.r.t. . As  this implies  for each of the applied rules, i.e. the node remains
  during the transformation and hence the track morphisms are defined as in
  Def.~\ref{def:track}.

  \item :\\
  As the isomorphism~ is derived from  and  this isomorphism correctly relates the original node~ with its
  occurrences in , resp. , and , resp.
  .\end{enumerate}\end{proof}
\end{lemma}

The reverse direction holds as well, as the following lemma shows.

\begin{lemma}[Strong Joinability Implies
\mcG-Confluence]\label{lem:confluence_gts_chr} 

If all critical GTS pairs of a terminating GTS are strongly joinable, then the
corresponding GTS-CHR program is \mcG-confluent.
\begin{proof}
Consider an overlap~\sigcp\ for the critical CHR pair~.
W.l.o.g.  holds according to Cor.~\ref{cor:g_confl}.
Therefore,  is a \mcG-state~based~on~ and  correspond to graphs~. Consider now .

We now show, that either the critical CHR pair is non-critically joinable, or it
corresponds to a critical GTS pair and can thus be joined, because all critical
GTS pairs are strongly joinable.

First, we want to point out that  is minimal by the definition of the CHR
overlap, i.e. every occurring node and edge is part of a match, hence,  and
 are jointly surjective.

Next, we distinguish two cases: First, let  be
parallel independent. Therefore, the second rule can be applied after the
first, because none of the required nodes or edges has been removed. The
following diagram depicts this situation:\\
\centerline{
\xymatrix{
& \ar@{=>}[dl]_{r_1} G \ar@{=>}[dr]^{r_2} & \\
G_1 \ar@{=>}[dr]^{r_2} & & \ar@{=>}[dl]_{r_1} G_2 \\
& X &
}}

By Theorem~\ref{thm:sound_and_complete} we can apply the corresponding rules to
 in order to join the critical CHR pair, because 
contains only nodes not deleted by  and .

Secondly, let  be parallel dependent. It follows that
. However, this is now a
critical GTS pair, and hence, strongly joinable as depicted on the left of the
following diagram:\\
\centerline{
\xymatrix{
& \ar@{=>}[dl]_{r_1} G \ar@{=>}[dr]^{r_2} & & & \ar[dl]_{r_1} \sigcp
\ar[dr]^{r_2}&\\
G_1 \ar@{=>}[dr]^{*} & (GTS) & \ar@{=>}[dl]_{*} G_2 &  \sigma_1\ar[dr]^{*}
&(CHR)& \ar[dl]_{*}\sigma_2 \\
& X_1 \simeq X_2 & & & \sigma_1' \equiv \sigma_2' &
}}

The right part of the diagram shows the situation for the critical CHR pair which
is joinable by Thm.~\ref{thm:sound_and_complete}. This is possible, because
 we know that  and
 are defined, thus by Def.~\ref{def:gts_cp}, 
is never removed and still present in  and . Finally, the isomorphism
implied by  gives us . Note that
despite Lemma~\ref{lem:eq_iso} not being reversible in general this holds here,
as it is clearly determined for both  and  which node
identifier variables are global and the strong joinability condition reflects
this in the isomorphism.

Therefore, for all overlaps~ with  holding we know that the
corresponding critical CHR pair is joinable, and hence, by Cor.~\ref{cor:g_confl}
that the CHR program is -local-confluent. As it is terminating as
well, it is -confluent.
\end{proof}
\end{lemma}

The combination of the previous two lemmata gives us our main result:

\begin{theorem}[Strong Joinability iff
\mcG-Confluence]\label{thm:confluence_characterization}

All critical GTS pairs of a terminating GTS are strongly joinable if and only if
the corresponding GTS-CHR program is \mcG-confluent.
\begin{proof}
Direct combination of Lemma~\ref{lem:confluence_chr_gts} and
Lemma~\ref{lem:confluence_gts_chr}.
\end{proof}
\end{theorem}

\begin{corollary}[\mcG-Confluence Implies GTS Confluence]

If a terminating GTS-CHR program is \mcG-confluent, then the corresponding GTS is
confluent.
\begin{proof}
Strong joinability is a sufficient criterion for confluence of a terminating
GTS (cf. \cite{plump05}). Therefore, this follows directly from
Theorem~\ref{thm:confluence_characterization}.
\end{proof}
\end{corollary}

Practically, with Theorem~\ref{thm:confluence_characterization} we can reuse the
automatic confluence check for terminating CHR programs
\cite{abdennadherfruehwirthmeuss99,fruehwirth09} to prove confluence of a
terminating GTS-CHR program. As Lemma~\ref{lem:obs_confl_empty_M} showed, it is
sufficient to only consider overlaps satisfying the graph invariant~\mcG.
Whenever all the resulting critical CHR pairs are joinable, the CHR program is
\mcG-confluent according to Corollary~\ref{cor:g_confl}. This, in turn, is
sufficient for proving confluence of the original GTS.

\subsection{Discussion}
\label{sec:confl_discussion}

In this section we elaborate on some canonical examples that highlight different
properties of critical pairs. These examples are inspired by \cite{plump05}.

\begin{example}

Consider the following rules which use two different edge types: a and b
\begin{center} 
\includegraphics{ex_join_rule}
\end{center}

The only critical GTS pair of these rules is joinable. This is possible in the
GTS case, because the resulting graphs, shown below, are isomorphic.

\begin{center}
\includegraphics{ex_join_cp} 
\end{center}
 

However, the track morphisms of the above derivations are incompatible, i.e. the
strong joinability condition from Definition~\ref{def:gts_cp} cannot be
satisfied. As the following derivation shows, this hinders monotonicity and
joinability is lost, when the critical pair is embedded into a larger context.

\begin{center}
\includegraphics{ex_join_state} 
\end{center}

The two resulting states are no longer isomorphic and also cannot be joined, as
no more rules are applicable to them. Therefore, this GTS is not locally
confluent, although all its critical GTS pairs are joinable.

We now examine this scenario in CHR. The two GTS rules then become the
following CHR rules:

\begin{center} 
\begin{tabular}{ll}
 @ & 
\\ &  \\
& \\
& \\
 @ & \\ &  \\
& \\
& 
\end{tabular}
\end{center}

We now consider the critical CHR pair corresponding to the above critical GTS
pair. It is generated by fully overlapping both rule heads, resulting in the
overlap  with . The resulting
critical CHR pair~ is:

It is clear that , because  as
required by Theorem~\ref{thm:equiv_tf}.

The strong nodes~ and , i.e. , enforce compatible
track morphisms, and hence are responsible for the non-joinability above. If we
instead want to test non-strong joinability, we can do so as well by setting
. Then, the two states  and  are indeed
equivalent by Definition~\ref{def:equiv}, as  is existentially quantified
and the remaining conditions of Theorem~\ref{thm:equiv_tf} hold as well.
\end{example}

\begin{example}\label{ex:counterexample}
Another example from \cite{plump05} is the following GTS which is terminating and
confluent, however, the critical GTS pair from the overlap of rule~ with
itself is not strongly joinable. This is a counterexample used to show that
strong joinability of critical GTS pairs is only a sufficient criterion for
confluence of a terminating GTS.

\begin{center} 
\includegraphics{ex_confl_rule}
\end{center}

The GTS works as follows: If there is at least one loop in the graph, then all
but a last loop are removed by the first rule. Additionally, all non-loop edges
are removed by the second rule. Therefore, the remaining final graph contains
zero or one loops and no other edges, and hence the GTS is terminating and
confluent due to graph isomorphism. The first rule is encoded in CHR as follows:

\begin{center} 
\begin{tabular}{ll}
 @ & \\
&  \\
&  \\
& \\
& 
\end{tabular}
\end{center}

Completely overlapping the rule with itself yields the overlap  with  resulting in the critical CHR pair~ with:


Analogously to the previous example, the two states are not equivalent and cannot
be joined, therefore the corresponding critical GTS pair is not strongly
joinable. Again, setting  results in both states becoming
equivalent. As before, this reflects that for the critical GTS pairs the two
corresponding graphs are isomorphic.
\end{example}

\section{Analyzing Operational Equivalence}
\label{sec:opeq}

Constraint Handling Rules is well-known for its decidable, sufficient, and
necessary criterion for operational equivalence of terminating and confluent
programs \cite{abdennadherfruehwirth99,fruehwirth09}. After presenting this
result in Section~\ref{sec:opeq_chr}, we introduce the concept of operational
equivalence for graph transformation systems in Section~\ref{sec:opeq_gts}. Then
we investigate operational equivalence of GTS-CHR programs and show that it is
sufficient for operational equivalence of the original GTS. We further
demonstrate its application to detect redundant rules of a GTS.

The contents of this section are a revised and extended version of
\cite{Raiser2009b}.

\subsection{Operational Equivalence in CHR}
\label{sec:opeq_chr}

Operational equivalence, intuitively, means that two programs should be able to
compute equivalent outputs given the same input. Applied to a single state, this
behavior is called \Ps-joinability:

\begin{definition}[\Ps-joinability]\label{def:p_joinable} Let  be CHR
programs. A state~ is \emph{\Ps-joinable}, if and only if there are
computations  and  with  where all  are final states
with respect to .
\end{definition}

If \Ps-joinability is given for all states the programs are considered
operationally equivalent:

\begin{definition}[Operational Equivalence]
Let  be CHR programs.

 are \emph{operationally equivalent} if and only if all states~
are \Ps-joinable.
\end{definition}

As mentioned before, operational equivalence is decidable for terminating and
confluent CHR programs. Similarly to confluence, the decision algorithm
investigates critical states created from rule heads.

\begin{definition}[Critical States]\label{def:critical_states} 
Let  be CHR programs. The set of \emph{critical states of  and
} is defined as .
\end{definition}

Note that we had to consider observable confluence for CHR, because overlap
states constructed for critical pair analysis may not always encode a graph. The
critical states used for operational equivalence here, however, stem directly
from a complete head of a rule, which in turn was derived from a GTS rule graph.
Therefore, all critical states of GTS-CHR programs are valid encodings of
graphs.

The following theorem, adapted from \cite{abdennadherfruehwirth99}, is based on
the idea to determine \Ps-joinability of these critical states. The monotonicity
property of CHR ensures, that if all critical states are \Ps-joinable, then all
states are. Additionally demanding termination and confluence of the programs,
allows us to decide \Ps-joinability simply by executing a critical state in each
of the programs and then comparing the resulting final states.

\begin{theorem}[Operational Equivalence via Critical States]\label{thm:opeq} Let
 be terminating and confluent CHR programs.  are operationally
equivalent if and only if for all critical states~ of  and
 it holds that  is \Ps-joinable.
\begin{proof}
Given in \cite{abdennadherfruehwirth99}.
\end{proof}
\end{theorem}

Note that in contrast to confluence, Theorem~\ref{thm:opeq} will always consider
states satisfying the \mcG-invariant, when applied to a GTS-CHR program. This
follows from the fact, that each critical state is the head of a rule, and in
turn, corresponds to a rule graph from the GTS by construction.

\subsection{Analyzing Operational Equivalence in GTS}
\label{sec:opeq_gts}

In this section we introduce the notion of operational equivalence for GTS. Based
on the previous embedding of GTS in CHR, we use the existing decision algorithm
from CHR as a sufficient criterion for operational equivalence of two graph
transformation systems.

First, we define the property of \Ss-joinability for two graph transformation
systems \Ss, analogously to \Ps-joinability.

\begin{definition}[\Ss-joinability]

Let \Ss\ be two graph transformation systems. A typed graph~ is
\emph{\Ss-joinable} if and only if there are derivations  and  with  being final with respect
to  and . 

Here  denotes traditional graph isomorphism and a graph~ is considered
\emph{final} with respect to  iff there is no transition~ for any graph~.
\end{definition}

Building on \Ss-joinability, we now define operational equivalence for graph
transformation systems with the same intuitive understanding: two operationally
equivalent GTS should be able to produce the same result graphs up to isomorphism
given an input graph:

\begin{definition}[GTS Operational Equivalence]\label{def:gts_oe}
Let  and  be two graph
transformation systems.

\Ss\ are \emph{operationally equivalent} if and only if for all graphs~ typed
over  it holds that  is \Ss-joinable.
\end{definition}

Similar to operational equivalence in CHR, where it is futile to directly compare
programs that use different constraints, Definition~\ref{def:gts_oe} requires
 and  to be based on the same type graph~. With the previous
results from \cite{Raiser2009} we can directly use CHR's operational equivalence
as a sufficient criterion for deciding operational equivalence of two GTS:

\begin{theorem}[GTS-CHR Operational Equivalence]\label{thm:gtsopeq}
Let \Ss\ be graph transformation systems and \Ps\ their corresponding GTS-CHR
programs. \Ss\ are operationally equivalent if \Ps\ are operationally
equivalent.

\begin{proof}

Let  be a graph typed over . Then the state~ is \Ps-joinable by Def.~\ref{def:p_joinable}. Therefore,
there exist the final states~ with  and .

By Thm.~\ref{thm:sound_and_complete} we know that there exist corresponding
derivations~ and  such
that  is a \mcG-state~based~on~ and  is a
\mcG-state~based~on~.

The graphs~ and  are final states w.r.t.  and , and
finally, the isomorphism between  and  is implied by  according to Lemma~\ref{lem:eq_iso}. Therefore,  is \Ss-joinable.
\end{proof}
\end{theorem}

An interesting application of the above theorem is the removal of redundant
rules. Originally proposed in \cite{Abdennadher2003}, decidable operational
equivalence of CHR programs implies a straight-forward redundant rule removal
algorithm: Remove a single rule from the program, then compare the operational
equivalence of the program thus created and the original program. If the two
programs are operationally equivalent the selected rule is shown to be redundant
and can be removed.

Clearly, program equivalence in general is undecidable, and hence, we cannot
expect such an algorithm to correctly identify all redundant rules. Nevertheless,
the algorithm was applied in CHR research to great success on automatically
generated programs \cite{Abdennadher2007,raiser08cp}. These generations tend to
create rules which subsume each other, in which case the algorithm works well as
the following example demonstrates.

\begin{figure}
\centerline{
\scalebox{.8}{\includegraphics{opeq}}
}
\caption{Example of a graph transformation system}
\label{fig:ex:opeq}
\end{figure}

\begin{example}

Consider the graph transformation system~ given in
Figure~\ref{fig:ex:opeq}. It depicts a typical case, in that the rule~ is
subsumed by rule~. While this is easily verified by a human reader,
Theorem~\ref{thm:opeq} gives us the means for an automated verification.

In order to verify the redundancy of rule~, consider a second graph
transformation system~, which contains only rule~. Proving that
 and  are operationally equivalent then proves the redundancy of
rule~.

Encoding the graph transformation system~ from Figure~\ref{fig:ex:opeq}
in CHR results in the following two rules:\\
\begin{tabular}{ll}
 @ & 
\\
&  \\
& \\
\\
 @ & \\
&  \\
&  \\
& \\
& 
\end{tabular}

This GTS-CHR program~ is confluent and terminating and the same holds for
, which encodes  respectively. Next, we investigate the
-joinability of all critical states, of which there are two. The critical
state derived from  is clearly -joinable, as the same rule can be
applied to it in both programs, resulting in equivalent final states.

The critical state derived from rule~ contains two a-edges, which can be
converted to b-edges either by applying rule~ or rule~ twice. Therefore,
the final states in both programs are equivalent again, and hence, the programs
are operationally equivalent. As a conclusion,  and  are
operationally equivalent, which in turn proves the redundancy of rule~.

\end{example}

In general, Theorem~\ref{thm:gtsopeq} cannot be reversed, i.e. it is only a
sufficient, not a necessary criterion. A counterexample for the reverse direction
is given in the following example. Notice that it is based on the example used by
\cite{plump05} in order to demonstrate why the critical pair lemma is not a
necessary criterion for confluence. This might be seen as an indication that a
similar situation exists for GTS program equivalence.

\begin{example}

Consider two GTS with the first being the one from
Example~\ref{ex:counterexample} and the second GTS is identical to the first
except for rule~, in which the loop for node~ is removed instead. It is
clear, that both programs are terminating, confluent, and operationally
equivalent. The following two rules are from the corresponding GTS-CHR
programs~ and :\\
\begin{tabular}{ll}
 @ & \\
&  \\
&  \\
& \\
& \\
\\
 @ & \\
&  \\
&  \\
& \\
& 
\end{tabular}

We can now investigate the following critical state~ according to
Theorem~\ref{thm:gtsopeq}, where :


The critical state~ is not \Ps-joinable, as there is only one rule
applicable in each program and the resulting states are not equivalent:\\
\begin{tabular}{r} 
\\
\\

\end{tabular}
\end{example}   

\section{Related and Future Work}
\label{sec:related_work}

The relation of CHR to other formalisms has been thoroughly investigated in the
literature. This includes comparison to logical formalisms (e.g., linear logic
\cite{Betz2005}), term rewriting
(\cite{duck_stuck_brand_acd_term_rewriting_iclp06}), Join-Calculus
(\cite{lam_sulz_finallyjoin_chr08}), and Petri nets \cite{betz_petri_nets_chr07}.
More detailled surveys of these relations can be found in
\cite{chr_survey_tplp08} and \cite{fruehwirth09}.

The relation of graph transformation systems to CHR differs from these other
formalisms, because firstly, it is a graph-based formalism, and secondly, there
are significant differences in program analysis results. Most importantly,
confluence of terminating GTS is undecidable \cite{plump05} whereas confluence of
terminating CHR programs is decidable \cite{abdennadherfruehwirthmeuss99}.
Furthermore, no operational equivalence analysis exists for GTS, as opposed to
the situation in CHR \cite{abdennadherfruehwirth99}.

The operational equivalence test presented in Section~\ref{sec:opeq} yields a
method for removal of redundant rules, which is remarkable for another reason: In
\cite{Kreowski2000} the notions of redundancy and subsumptions have been
introduced for GTS, however, the authors only gave the definitions and a
sufficient condition for redundancy, but no verification procedure. While the
notion of redundancy in that paper is slightly different from the one found in
\cite{Abdennadher2003}, the adaptation of the algorithm to GTS-CHR programs is to
the best of our knowledge the only available verification procedure for redundant
GTS rules.

Note, that operational equivalence, as defined here, is only one possible notion
of equivalence between programs. It was used in this work as an example of CHR
program analyses applied to embedded graph transformation systems. Another, more
popular, notion of equivalence of GTS is bisimilarity, introduced in the GTS
context in \cite{Ehrig2004}. It has been successfully applied to determine
behavioral equivalence of graph transformation systems in \cite{Rangel2008}.
While bisimilarity originated from process calculi and is focused on the
transitions made during computations of a result, operational equivalence on the
other hand, only compares the final computational results, independently of how
they are reached.

The encoding of GTS in CHR, as presented in Section~\ref{sec:encoding}, is based
on the double-pushout approach for graph transformation systems. A related graph
rewriting mechanism, the single-pushout approach, was introduced in
\cite{loewe93}. Instead of demanding two pushouts, as in Figure~\ref{fig:dpo},
rewriting is defined there over a category of partial graph morphisms, hence only
a single pushout construction is used. Intuitively, this results in a different
behavior with respect to dangling edges: While the double-pushout approach
prohibits a rule application in case a dangling edge would remain, the
single-pushout approach removes all dangling edges instead. In \cite{Lowe1993}
the authors investigate confluence for single-pushout graph rewriting. In
particular, the critical pair analysis is shown to be only a sufficient criterion
as well, not a necessary one.

In this work, we based our encoding on the DPO approach as the non-applicability
of rules due to the dangling edge condition corresponds nicely to
non-applicability of corresponding CHR rules. In order to support the approach
from \cite{loewe93}, remaining dangling edges would need to be removed by an
additional rule, hence, we would lose the one-on-one correspondence of GTS and
CHR rules.

Our encoding further serves as the foundation of the extensible platform for the
analysis of graph transformation systems using constraint handling rules
presented in the diploma thesis \cite{Wasserthal2009}. This platform is based on
JCHR \cite{jchr}, a Java-based implementation of CHR and the work presented in
Section~\ref{sec:encoding}. The developed tool presents a graphical view of a GTS
which is synchronized with the corresponding GTS-CHR program at all times.
Furthermore, it provides an interface for program analysis plug-ins, which can
work directly on the GTS or on the GTS-CHR program.

As this work demonstrated, our embedding leads to cross-fertilizations of CHR and
GTS research. Future work should therefore concentrate on further comparing the
different approaches to program analysis. In particular, CHR provides several
approaches to termination analysis
\cite{Fruhwirth2000,voets_pilozzi_deschreye_termination_techrep08,Pilozzi2008}
that GTS research may profit from.

Research on GTS contains several extensions for the typed graphs and rules
considered in this work. One such extension adds attributes
\cite{ehrigprangetaentzer06} to graphs, which can then be modified by rules. We
assume that built-in constraints available in CHR could closely correspond to
attributes. Another important extension, is the addition of negative application
conditions \cite{ehrigprangetaentzer06}, i.e. applying a rule requires the
absence of certain graph structures. This is more difficult to achieve in CHR, as
it traditionally has no support for negation as absence. However, there exist
proposed extensions of CHR with negation as absence
\cite{vanweert_sney_schr_demoen_negation_chr06} and aggregates
\cite{vanweert_sney_demoen_aggregates_lopstr07}, which could help in extending
our encoding to allow application conditions.

Our work on operational equivalence for graph transformation systems yielded a
first useable criterion. However, there is lot of remaining work in this field.
From a decidability point of view, operational equivalence is in a similar
situation as confluence: \cite{plump05} showed that confluence is undecidable
even for terminating GTS and we expect a similar result for operational
equivalence. Therefore, our criterion might only be applicable to a small subset
of all GTS.

Similarly, in CHR research, the operational equivalence result assumes that both
programs use the same constraint symbols in the same manner. While this
restriction yields a decidable criterion, it also means that it seldomly applies
to real-world programs. Traditionally, one may be able to manually show
operational equivalence for two concrete programs by taking into account known
restrictions on data structures or inputs and ignoring irrelevant states. The
same situation was present for confluence (e.g., \cite{fruehwirth05}) until
observable confluence \cite{duckstuckeysulzmann07} succeeded in providing an
extended approach.

We plan to develop such an invariant-based approach for operational equivalence
in CHR as well, which extends Theorem~\ref{thm:opeq}. Combined with a better
criterion for operational equivalence in GTS, including the track morphism
similarly to the critical pair approach, this might reveal a closer
correspondence between operational equivalence in both systems.

\section{Conclusion}
\label{sec:conclusion}

We have shown that constraint handling rules (CHR) provides an elegant way for
embedding graph transformation systems (GTS). The resulting rules are concise and
directly related to the corresponding graph production rules. We proved soundness
and completeness of this embedding and verified formal properties of CHR states
that encode graphs. Furthermore, we considered partial graphs and showed that the
CHR embedding naturally supports these, hence facilitating program analysis.

Next, we analyzed confluence and showed that observable confluence of a GTS-CHR
program is a sufficient criterion for confluence of the analyzed GTS.
Furthermore, we transferred the notion of operational equivalence from CHR to GTS
and discussed the CHR-based decision algorithm for redundant rule removal.

\bibliography{bibliography}

\end{document}
