
\documentclass{article} \usepackage{iclr2021_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=magenta,
}
\usepackage{url}

\usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{color}
\newcommand{\MS}[1]{\textcolor{blue}{#1}}
\newcommand{\YSR}[1]{\textcolor{green}{#1}}
\usepackage{bbm}
\usepackage{algorithm}
\usepackage{multirow}
\usepackage[noend]{algpseudocode}
\usepackage[justification=centering]{caption}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{wrapfig,lipsum,booktabs}
\usepackage{algorithmicx}

\usepackage{amsmath}
\usepackage{mathtools}

\usepackage[justification=justified]{caption}
\usepackage[font=small]{caption}

\DeclarePairedDelimiter\set\{\}
\DeclarePairedDelimiter\abs{\lvert}{\rvert}\DeclarePairedDelimiter\norm{\lVert}{\rVert}

\title{In Defense of Pseudo-Labeling: \\An Uncertainty-Aware Pseudo-label Selection Framework for Semi-Supervised Learning 
}




\author{Mamshad Nayeem Rizve\IEEEauthorrefmark2, Kevin Duarte\IEEEauthorrefmark2, Yogesh S Rawat\IEEEauthorrefmark3 \& Mubarak Shah\IEEEauthorrefmark3 \\
Center for Research in Computer Vision\\
University of Central Florida, Orlando, Florida, USA\\
\texttt{\IEEEauthorrefmark2\{nayeemrizve, kevin\_duarte\}@knights.ucf.edu} \\
\texttt{\IEEEauthorrefmark3\{yogesh, shah\}@crcv.ucf.edu} \\
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
The recent research in semi-supervised learning (SSL) is mostly dominated by {\em consistency regularization} based methods which achieve strong performance. However, they heavily rely on domain-specific data augmentations, which are not easy to generate for all data modalities. Pseudo-labeling (PL) is a general SSL approach that does not have this constraint but performs relatively poorly in its original formulation. We argue that PL underperforms due to the erroneous high confidence predictions from poorly calibrated models; these predictions generate many incorrect pseudo-labels, leading to noisy training. We propose an uncertainty-aware pseudo-label selection (UPS) framework which improves pseudo labeling accuracy by drastically reducing the amount of noise encountered in the training process. Furthermore, UPS generalizes the pseudo-labeling process, allowing for the creation of negative pseudo-labels; these negative pseudo-labels can be used for multi-label classification as well as negative learning to improve the single-label classification. We achieve strong performance when compared to recent SSL methods on the CIFAR-10 and CIFAR-100 datasets. Also, we demonstrate the versatility of our method on the video dataset UCF-101 and the multi-label dataset Pascal VOC. Our codes are available at: \url{https://github.com/nayeemrizve/ups}.



\end{abstract}






\iffalse 




Recent consistency regularization methods tend to outperform pseudo-labeling based approaches in semi-supervised learning; however, these methods heavily rely on domain-specific data augmentations, which are not easy to generate for all data modalities. We attempt to bridge this performance gap by proposing a novel uncertainty-aware pseudo-labeling selection (UPS) framework that does not inherently rely on this rich set of data augmentations. Current pseudo-labeling methods fail because erroneous predictions from poorly calibrated models generate many incorrect pseudo-labels, leading to noisy training. We leverage prediction uncertainty to drastically reduce the number of incorrect pseudo-labels encountered during training. Furthermore, UPS is a general extension of pseudo-labeling that allows for the creation of negative pseudo-labels, which can be used for multi-label classification as well as negative learning to improve single-label classification. We achieve strong performance when compared to recent SSL methods on the CIFAR-10 and CIFAR-100 datasets. Also, we demonstrate the versatility of our method on the multi-label dataset Pascal VOC and the video dataset UCF-101. \textit{Code will be made publicly available.}
\fi


\section{Introduction}
The recent extraordinary success of deep learning methods can be mostly attributed to advancements in learning algorithms and the availability of large-scale labeled datasets. However, constructing large labeled datasets for supervised learning tends to be costly and is often infeasible. Several approaches have been proposed to overcome this dependency on huge labeled datasets; these include semi-supervised learning \citep{NIPS2019_8749_MixMatch,NIPS2017_6719_meanT, Miyato2018VirtualAT, Lee2013PseudoLabelT}, self-supervised learning \citep{doersch2015unsupervised, noroozi2016unsupervised, chen2020simple}, and few-shot learning \citep{finn2017model, snell2017prototypical, vinyals2016matching}. Semi-supervised learning (SSL) is one of the most dominant approaches for solving this problem, where the goal is to leverage a large unlabeled dataset alongside a small labeled dataset.







One common assumption for SSL is that decision boundaries should lie in low density regions \citep{chapelle2005semi}.
Consistency-regularization based methods achieve this by making the network outputs invariant to small input perturbations \citep{Verma2019InterpolationCT}. However, one issue with these methods is that they often rely on a rich set of augmentations, like affine transformations, cutout \citep{devries2017cutout}, and color jittering in images, which limits their capability for domains where these augmentations are less effective (e.g. videos and medical images). Pseudo-labeling based methods select unlabeled samples with high confidence as training targets (pseudo-labels); this can be viewed as a form of entropy minimization, which reduces the density of data points at the decision boundaries \citep{grandvalet2005semi, Lee2013PseudoLabelT}. One advantage
of pseudo-labeling over consistency regularization is that it does not inherently require augmentations and can be generally applied to most domains. However, recent consistency regularization approaches tend to outperform pseudo-labeling on SSL benchmarks. This work is in defense of pseudo-labeling: we demonstrate that pseudo-labeling based methods can perform on par with consistency regularization methods.









Although the selection of unlabeled samples with high confidence predictions moves decision boundaries to low density regions in pseudo-labeling based approaches, many of these selected predictions are incorrect due to the poor calibration of neural networks \citep{pmlr-v70-guo17a}. Since, calibration measures the discrepancy between the confidence level of a network's individual predictions and its overall accuracy \citep{doi:10.1080/01621459.1982.10477856, Degroot1983TheCA}; for poorly calibrated networks, an incorrect prediction might have high confidence. {\em We argue that conventional pseudo-labeling based methods achieve poor results because poor network calibration produces incorrectly pseudo-labeled samples, leading to noisy training and poor generalization}. To remedy this, we empirically study the relationship between output prediction uncertainty and calibration. We find that selecting predictions with low uncertainty greatly reduces the effect of poor calibration, improving generalization. 


Motivated by this, we propose an uncertainty-aware pseudo-label selection (UPS) framework that leverages the prediction uncertainty to guide the pseudo-label selection procedure. We believe pseudo-labeling has been impactful due to its simplicity, generality, and ease of implementation; to this end, our proposed framework attempts to maintain these benefits, while addressing the issue of calibration to drastically improve PL performance. UPS does not require modality-specific augmentations and can leverage most uncertainty estimation methods in its selection process. Furthermore, the proposed framework allows for the creation of negative pseudo-labels (i.e. labels which specify the absence of specific classes). If a network predicts the absence of a class with high confidence and high certainty, then a negative label can be assigned to that sample. This generalization is beneficial for both single-label and multi-label learning. In the single-label case, networks can use these labels for negative learning \citep{kim2019nlnl}\footnote{The motivations for using negative learning (NL) in this work differs greatly from \cite{kim2019nlnl}. In this work, NL is used to incorporate more unlabeled samples into training and to generalize pseudo-labeling to the multi-label classification setting, whereas \cite{kim2019nlnl} use negative learning primarily to obtain good network initializations to learn with noisy labels. Further discussion about NL can be found in Appendix \ref{sec:nl}.}; in the multi-label case, class presence is independent so both positive and negative labels are necessary for training.

Our key contributions include the following: (1) We introduce UPS, a novel uncertainty-aware pseudo-label selection framework which greatly reduces the effect of poor network calibration on the pseudo-labeling process, (2) While prior SSL methods focus on single-label classification, we generalize pseudo-labeling to create negative labels, allowing for negative learning and multi-label classification, and (3) Our comprehensive experimentation shows that the proposed method achieves strong performance on commonly used benchmark datasets CIFAR-10 and CIFAR-100. In addition, we highlight our method's flexibility by outperforming previous state-of-the-art approaches on the video dataset, UCF-101, and the multi-label Pascal VOC dataset.  

\iffalse
Our key contributions include the following:
\begin{itemize}
  \item We introduce UPS, a novel uncertainty-aware pseudo-label selection framework which greatly reduces the effect of poor network calibration on the pseudo-labeling process.
  \item While prior SSL methods focus on single-label classification, we generalize pseudo-labeling to create negative labels, allowing for negative learning and multi-label classification.  
  \item Our comprehensive experimentation shows that the proposed method achieves strong performance on commonly used benchmark datasets CIFAR-10 and CIFAR-100. In addition, we highlight our method's flexibility by outperforming previous state-of-the-art approaches on the video dataset, UCF-101, and the multi-label Pascal VOC dataset.  
 \end{itemize}
 \fi
 


 






\section{Related Works}
Semi-supervised learning is a heavily studied problem. In this work, we mostly focus on pseudo-labeling and consistency regularization based approaches as currently, these are the dominant approaches for SSL. Following \citep{NIPS2019_8749_MixMatch}, we refer to the other SSL approaches for interested readers which includes: “transductive” models \citep{Gammerman1998Learning, joachims1999transductive, joachims2003transductive}, graph-based methods \citep{zhu2003semi, bengio200611, liu2019deep}, generative modeling \citep{belkin2002laplacian, lasserre2006principled, kingma2014semi, pu2016variational}. Furthermore, several recent self-supervised approaches \citep{grill2020bootstrap, chen2020big, caron2020unsupervised}, have shown strong performance when applied to the SSL task. For a general overview of SSL, we point to \citep{10.5555/semi-super, zhu2005semi}. 

\label{sect:relatedworks}

\paragraph{Pseudo-labeling}
The goal of pseudo-labeling \citep{Lee2013PseudoLabelT, Shi_2018_ECCV} and self-training \citep{yarowsky-1995-unsupervised, mcclosky-etal-2006-effective} is to generate pseudo-labels for unlabeled samples with a model trained on labeled data. In \citep{Lee2013PseudoLabelT}, pseudo-labels are created from the predictions of a trained neural network. Pseudo-labels can also be assigned to unlabeled samples based on neighborhood graphs \citep{Iscen2019LabelPF}. \citet{Shi_2018_ECCV} extend the idea of pseudo-labeling by incorporating confidence scores for unlabeled samples based on the density of a local neighborhood. Inspired by noise correction work \citep{yi2019probabilistic}, \citet{R2D2_AAAI_2020} attempt to update the pseudo-labels through an optimization framework. Recently, \citep{xie2019self} show self-training can be used to improve the performance of benchmark supervised classification tasks. A concurrent work \citep{HaaseSchutz2020IterativeLI} partitions an unlabeled dataset and trains re-initialized networks on each partition. They use previously trained networks to filter the labels used for training newer networks. However, most of their experiments involve learning from noisy data. Although previous pseudo-labeling based SSL approaches are general and domain-agnostic, they tend to under-perform due to the generation of noisy pseudo-labels; our approach greatly reduces noise by minimizing the effect of poor network calibration, allowing for competitive state-of-the-art results. 

\paragraph{Consistency Regularization}
The main objective of consistency regularization methods is to obtain perturbation/augmentation invariant output distribution. In \citep{NIPS2016_6333} random max-pooling, dropout, and random data augmentation are used as input perturbations. In \citep{Miyato2018VirtualAT} perturbations are applied to the input that changes the output predictions maximally. Temporal ensembling \citep{LaineA17} forces the output class distribution for a sample to be consistent over multiple epochs. \cite{NIPS2017_6719_meanT} reformulate temporal ensembling as a teacher-student problem. Recently, the Mixup \citep{zhang2018mixup} augmentation, has been used for consistency regularization in \citep{Verma2019InterpolationCT}. Several SSL works combine ideas from both consistency regularization and pseudo-labeling \citep{NIPS2019_8749_MixMatch, Berthelot2020ReMixMatch:,zhoutime}. In \citep{NIPS2019_8749_MixMatch}, pseudo-labels are generated by averaging different predictions of augmented versions of the same sample and the Mixup augmentation is used to train with these pseudo-labels. The authors in \citep{Berthelot2020ReMixMatch:} extend this idea by dividing the set of augmentations into strong and weak augmentations. Also, \citep{zhoutime} incorporate a time-consistency metric to effectively select time-consistent samples for consistency regularization. The success of recent consistency regularization methods can be attributed to domain-specific augmentations; our approach does not inherently rely on these augmentations, which allows for application to various modalities. Also, our pseudo-labeling method is orthogonal to consistency regularization techniques; therefore, these existing techniques can be applied alongside UPS to further improve network performance.  

\paragraph{Uncertainty and Calibration}








Estimating network prediction uncertainty has been a deeply studied topic \citep{NIPS2011_4329, 10.5555/3045118.3045290, pmlr-v48-louizos16, NIPS2017_7219, malinin2018predictive, maddox2019simple, welling2011bayesian}. In the SSL domain, \citep{yu2019uncertainty, xia20203d} use uncertainty to improve consistency regularization learning for the segmentation of medical images. A concurrent work \citep{mukherjee2020uncertainty}, selects pseudo-labels predicted by a pretrained language model using uncertainty for a downstream SSL task. One difference between our works is the selection of hard samples. Whereas Mukherjee et al. select a certain amount of hard samples (i.e. those which are not confident or certain) and learn from these using positive learning, we decide to use negative learning on these samples which reduces the amount of noise seen by the network. \cite{zheng2020rectifying} show strong performance on the domain adaptive semantic segmentation task by leveraging uncertainty. However, to the best of our knowledge, uncertainty has not been used to reduce the effect of poor network calibration in the pseudo-labeling process. In this work, instead of improving the calibration of the network \citep{pmlr-v70-guo17a, Xing2020Distance-Based}, we present a general framework which can leverage most uncertainty estimation methods to select a better calibrated subset of pseudo-labels. 












\section{Proposed Method}

\subsection{Pseudo-labeling for Semi-Supervised Learning}
\paragraph{Notation} 
Let  be a labeled dataset with  samples, where  is the input and  is the corresponding label with  class categories (note that multiple elements in  can be non-zero in multi-label datasets). For a sample ,  denotes that class  is present in the corresponding input and  represent the class's absence. Let  be an unlabeled dataset with  samples, which does not contain labels corresponding to its input samples. For the unlabeled samples, pseudo-labels  are generated. Pseudo-labeling based SSL approaches involve learning a parameterized model  on the dataset , with  for the  labeled samples. 


\paragraph{Generalizing Pseudo-label Generation}
There are several approaches to create the pseudo-labels , which have been described in Section \ref{sect:relatedworks}. We adopt the approach where hard pseudo-labels are obtained directly from network predictions. Let  be the probability outputs of a trained network on the sample , such that  represents the probability of class  being present in the sample. Using these output probabilities, the pseudo-label can be generated for  as:


where  is a threshold used to produce hard labels. Note that conventional single-label pseudo-labeling can be derived from equation \ref{eq:pl} when . For the multi-label case,  would lead to binary pseudo-labels, in which multiple classes can be present in one sample.


\subsection{Pseudo-label Selection} 
Although pseudo-labeling is versatile and modality-agnostic, it achieves relatively poor performance when compared to recent SSL methods. This is due to the large number of incorrectly pseudo-labeled samples used during training. Therefore, we aim at reducing the noise present in training to improve the overall performance. This can be accomplished by intelligently selecting a subset of pseudo-labels which are less noisy; since networks output confidence probabilities for class presence (or class absence), we select those pseudo-labels corresponding with the high-confidence predictions.

Let  be a binary vector representing the selected pseudo-labels in sample 
, where  when  is selected and  when  is not selected. This vector is obtained as follows:

where  and  are the confidence thresholds for positive and negative labels (here, ). If the probability score is sufficiently high () then the positive label is selected; conversely, a network is sufficiently confident of a class's absence (), in which case the negative label is selected.

The parameterized model  is  trained on the selected subset of pseudo-labels. For single-label classification, cross-entropy loss is calculated on samples with selected positive pseudo-labels.
If no positive label is selected, then negative learning is performed, using negative cross-entropy loss:

where  is the number of selected pseudo-labels for sample . Here,  is the probability output for the model . For multi-label classification, a modified binary cross-entropy loss is utilized:

In both cases, the selection of high confidence pseudo-labels removes noise during training, allowing for improved performance when compared to traditional pseudo-labeling.



\begin{figure}

\vspace{-4mm}
    \centering
    \subfloat[]{{\includegraphics[width=0.32\textwidth]{images/eceVuncertainty_multiple.pdf}{\label{fig:ece}} }}\hspace*{-0.4em}
\subfloat[]{{\includegraphics[width=0.32\textwidth]{images/accuracyViteration_1000.pdf}{\label{fig:acc}} }}\hspace*{-0.4em}
\subfloat[]{{\includegraphics[width=0.32\textwidth]{images/selectedViteration_1000.pdf}{\label{fig:num}} }}
\label{fig:example}\caption{(a) The relationship between prediction uncertainty and expected calibration error (ECE). In all datasets, as the uncertainty of the selected pseudo-labels decreases, the ECE of that selected subset decreases. (b) Comparison of pseudo-label selection accuracy between conventional pseudo-labeling (PL), confidence-based selection (Confidence PL),  and UPS. (c) Comparison of the number of selected pseudo-labels between conventional pseudo-labeling (PL), confidence-based selection (Confidence PL), and UPS.  Although UPS initially selects a smaller set of pseudo-labels, by the final pseudo-labeling iterations it incorporates the majority of pseudo-labels in training, while maintaining a higher pseudo-labeling accuracy (as seen in (b)). Figures (b) and (c) are generated from the CIFAR-10 dataset with 1000 labels.}
    \vspace{-4mm}
    
\end{figure}

\subsection{Uncertainty-Aware Pseudo-label Selection}
Although confidence-based selection reduces pseudo-label error rates, the poor calibration of neural networks renders this solution insufficient - in poorly calibrated networks, incorrect predictions can have high confidence scores. Since calibration can be interpreted as a notion of a network's overall prediction uncertainty \citep{NIPS2017_7219}, the question then arises: \textit{Is there a relationship between calibration and individual prediction uncertainties?} To answer this question, we empirically analyze the relationship between the Expected Calibration Error (ECE) score\footnote{An in-depth description of the ECE score is included in section \ref{sec:ece} of the Appendix.} \citep{pmlr-v70-guo17a} and output prediction uncertainties.
Figure \ref{fig:ece} illustrates the direct relationship between the ECE score and output prediction uncertainty; when pseudo-labels with more certain predictions are selected, the calibration error is greatly reduced for that subset of pseudo-labels. Therefore, for that subset of labels, a high-confidence prediction is more likely to lead to a correct pseudo-label.

From this observation, we conclude that prediction uncertainties can be leveraged to negate the effects of poor calibration. Thus, we propose an uncertainty-aware pseudo-label selection process: by utilizing both the confidence and uncertainty of a network prediction, a more accurate subset of pseudo-labels are used in training. Equation \ref{eq:confselect} now becomes,



where  is the uncertainty of a prediction , and  and  are the uncertainty thresholds. This additional term, involving  , ensures the network prediction is sufficiently certain to be selected. Figure \ref{fig:acc} shows that this uncertainty-aware selection process greatly increases pseudo-label accuracy when compared to both traditional pseudo-labeling and confidence-based selection.


\subsection{Learning with UPS}

First, a neural network  is trained on the small labeled set, . Once trained, the network generates predictions for all unlabeled data in ; pseudo-labels are created from these predictions following equation \ref{eq:pl}. A subset of the pseudo-labels is selected using UPS (equation \ref{eq:ups}). Next, another network , is trained using the selected pseudo-labels as well as the labeled set. This process is continued iteratively until convergence is observed in terms of the number of selected pseudo-labels. Figure \ref{fig:num} illustrates that most pseudo-labels are selected by the end of the training. To limit error propagation in our iterative training and pseudo-labeling process, we generate new labels for all unlabeled samples and reinitialize the neural network after each pseudo-labeling step. The complete training procedure is described in Algorithm \ref{alg: alogirthm1} in Section \ref{sec:algorithm} of the Appendix.









\section{Experimental Evaluation}


\paragraph{Datasets} To show the versatility of UPS we conduct experiments on four diverse datasets: CIFAR-10, CIFAR-100 \citep{krizhevsky2009learning}, Pascal VOC2007 \citep{pascal-voc-2007}, and UCF-101 \citep{soomro2012ucf101}. CIFAR-10 and CIFAR-100 are standard benchmark datasets, with 10 and 100 class categories respectively;
both contain ,  images, split into  training images and  test images. 
Pascal VOC2007 is a multi-label dataset with  training images and  test images. It consists of 20 classes and each sample contains between 1 and 6 class categories. We also evaluate our method on the video dataset UCF-101, which contains 101 action classes. We use the standard train/test split with  videos for training and  videos for testing. 

\subsection{Implementation Details}

\label{sec:implementation}
For CIFAR-10 and CIFAR-100 experiments, we use the CNN-13 architecture that is commonly used to benchmark SSL methods \citep{NIPS2018_7585, luo2018smooth}. For the Pascal VOC2007 experiments, we use ResNet-50 \citep{he2016deep} with an input resolution of .  Finally, for UCF-101, we follow the experimental setup of \citep{jing2020videossl} by using 3D ResNet-18 \citep{hara2018can} with a resolution of  and  frames. For all experiments, we set a dropout rate of . We use SGD optimizer with an initial learning rate of  and cosine annealing \citep{loshchilov-ICLR17SGDR} for learning rate decay.
We set the confidence thresholds  and  for all experiments, except on the Pascal VOC dataset, where  as it is a multi-label dataset and strict confidence threshold significantly reduces the number of positive pseudo-labels for difficult classes. Furthermore, for the uncertainty thresholds we use  and  for all experiments. The threshold, , used to generate the pseudo-labels is set to  in single-label experiments and  in multi-label experiments.


Our framework can utilize most uncertainty estimation method for selecting pseudo-labels (see section \ref{sec:discussion} for experiments with different uncertainty estimation methods). Unless otherwise stated, we use MC-Dropout \citep{pmlr-v48-gal16} to obtain an uncertainty measure by calculating the standard deviation of 10 stochastic forward passes.
To further reduce the calibration error and to make the negative pseudo-label selection more robust, we perform temperature scaling to soften the output predictions - we set  \citep{pmlr-v70-guo17a}. 
Moreover, networks trained on datasets with few classes tend to be biased towards easy classes in the initial pseudo-labeling iterations. This leads to the selection of more pseudo-labels for these classes, causing a large class imbalance. 
To address this issue, we balance the number of selected pseudo-labels for all classes;
this constraint is removed after 10 pseudo-labeling iterations in CIFAR-10 and after 1 pseudo-labeling iteration in Pascal VOC. The effect of this balancing is presented in section \ref{sec:class_balance} of the Appendix.

\begin{table}[t!]
\vspace{-5mm}
\caption{Error rate (\%) on the CIFAR-10 and CIFAR-100 test set. Methods with  are pseudo-labeling based, whereas others are consistency regularization methods.}
\label{tab:comaprison_SSL_CIFAR10_100}
\centering
\small
\begin{tabular}{l|cc|cc}
\hline
\multicolumn{1}{l|}{\multirow{2}{*}{Method}} & \multicolumn{2}{c|}{CIFAR-10} & \multicolumn{2}{c}{CIFAR-100} \\  
\multicolumn{1}{c|}{} & 1000 labels & 4000 labels & 4000 labels & 10000 labels \\ 

\hline


DeepLP  &  &  &  &  \\
TSSDL  &  &  & - & - \\ 
MT  &  &  &  & \\ 
MT + DeepLP &  &  &  & \\
ICT  &  &  & - & - \\ 
DualStudent  &  &  & - &  \\ 
R2-D2 & - & - & - &  \\
MixMatch  & - & 6.84 & - & - \\
\hline
UPS &  &  &  &  \\ 
\hline
\end{tabular}
\vspace{-4mm}
\end{table}












\begin{wraptable}{r}{0.48\linewidth}
\vspace{-4mm}
\caption{Error rate (\%) on CIFAR-10 with different backbones Wide ResNet-28-2 (WRN) and Shake-Shake (S-S).}
\centering

\label{tab:backbone}
\small
\begin{tabular}{l|ccc}
\hline
\multicolumn{1}{l|}{\multirow{2}{*}{Method}} & {\multirow{2}{*}{Backbone}} & \multicolumn{2}{c}{Labels} \\  
\multicolumn{1}{c|}{} & & 1000 & 4000\\
\hline





MixMatch & WRN & 7.75 & 6.24 \\ 
MixMatch & S-S & - & 4.95 \\
ReMixMatch & WRN & 5.73 & 5.14\\
TC-SSL & WRN & 6.15 & 5.07 \\
R2-D2 & S-S & - & 5.72 \\
 
 \hline UPS & WRN & 7.95 & 6.42 \\ 
UPS & S-S & - & 4.86 \\ \hline
\end{tabular}
\end{wraptable} 


\subsection{Results}

\paragraph{CIFAR-10 and CIFAR-100}
We conduct experiments on CIFAR-10 for two different labeled set sizes (1000 and 4000 labels), as well as on CIFAR-100 with labeled set sizes of 4000 and 10000 labels. For a fair comparison, we compare against methods which report results using the CNN-13 architecture: DeepLP \citep{Iscen2019LabelPF}, TSSDL \citep{Shi_2018_ECCV}, MT \citep{NIPS2017_6719_meanT}, MT + DeepLP, ICT \citep{Verma2019InterpolationCT}, DualStudent \citep{Ke_2019_ICCV}, and MixMatch \citep{NIPS2019_8749_MixMatch}. The results reported in Table \ref{tab:comaprison_SSL_CIFAR10_100}, are the mean and standard deviation from experiments across three different random splits. We achieve comparable results to the state-of-the-art holistic method MixMatch \citep{NIPS2019_8749_MixMatch} for CIFAR-10 with 4000 labels, with a  improvement. {\em Our CIFAR-10 experiment with 1000 labeled samples outperforms previous methods which use the CNN-13 architecture}. Also, we {\em outperform} previous methods in the CIFAR-100 experiments. We present additional results on CIFAR-10 with better backbone networks (Wide ResNet 28-2 \citep{BMVC2016_87} and Shake-Shake \citep{gastaldi2017shake}) in Table \ref{tab:backbone}, and compare with methods: MixMatch, ReMixMatch \citep{Berthelot2020ReMixMatch:}, TC-SSL \citep{zhoutime}, R2-D2 \citep{R2D2_AAAI_2020}. We find that UPS is not backbone dependent, and achieves further performance improvements when a stronger backbone is used.






\paragraph{UCF-101} 
For our UCF-101 experiments, we evaluate our method on using 20\% and 50\% of the training data as the labeled set. A comparison of our method and several SSL baselines is reported in Table \ref{tab:comaprison_SSL_UCF101}. The results reported for the baselines PL \citep{Lee2013PseudoLabelT}, MT \citep{NIPS2017_6719_meanT}, and S4L \citep{zhai2019s4l} are obtained from \citep{jing2020videossl}, as it uses the same network architecture and a similar training strategy. We do not compare directly with \citep{jing2020videossl}, since  they utilize a pretrained 2D appearance classifier which makes it an unfair comparison. {\em Even though none of the reported methods, including UPS, are developed specifically for the video domain, UPS outperforms all SSL methods}. Interestingly, both pseudo-labeling (PL) and UPS achieve strong results, when compared to the consistency-regularization based method, MT \citep{NIPS2017_6719_meanT} .

\paragraph{Pascal VOC2007} 
We conduct two experiments with  (500 samples) and  (1000 samples) of the train-val split as the labeled set. Since {\em there is no prior work on multi-label semi-supervised classification}, we re-implement three methods: Pseudo-labeling (PL) \citep{Lee2013PseudoLabelT},  MeanTeacher (MT) \citep{NIPS2017_6719_meanT}, and MixMatch \citep{NIPS2019_8749_MixMatch}. For a fair comparison, we use the same network architecture and similar training strategy for all baselines. Table \ref{tab:comaprison_SSL_PASCALVOC} shows UPS outperforming all methods with  and  improvements when using  and  of the labeled data, respectively. One reason why UPS and MT performs strongly in multi-label classification that neither approach has a single-label assumption; meanwhile, recent SSL methods like MixMatch and ReMixMatch are designed for single-label classification (e.g. temperature sharpening assumes a softmax probability distribution), which make them difficult to apply to multi-label datasets\footnote{Details on how MixMatch was adapted for this experiment can be found in section \ref{sec:mixmatch} of the Appendix.}. 
  

\begin{table}[t]
\begin{minipage}{.48\linewidth}
\vspace{-4mm}
\caption{Accuracy (\%) on the UCF-101 test set. Methods with * use scores reported in \citep{jing2020videossl}.}
\label{tab:comaprison_SSL_UCF101}
\centering
\small
\begin{tabular}{l|cc}
\hline
Method & 20\% labeled & 50\% labeled \\ \hline
Supervised & 33.5 & 45.6 \\
MT*  & 36.3 & 45.8 \\
PL*  & 37.0 & 47.5  \\
S4L* & 37.7 & 47.9 \\  \hline
UPS & \textbf{39.4} & \textbf{50.2}\\ \hline
\end{tabular}
\vspace{-4mm}

\end{minipage}\hfill
\begin{minipage}{.48\linewidth}
\vspace{-4mm}
\caption{mAP scores on the Pascal VOC2007 test set.}
\label{tab:comaprison_SSL_PASCALVOC}
\centering
\small
\begin{tabular}{l|cc}
\hline
Method & 10\% labeled & 20\% labeled \\ \hline
Supervised &  &  \\ 
PL  &  &  \\
MixMatch  &  &  \\
MT  &  &  \\ 
\hline
UPS &  &  \\ \hline
\end{tabular}
\end{minipage} 
\end{table}













\begin{wraptable}{r}{0.48\linewidth}
\vspace{-4mm}
\caption{Ablation Study on CIFAR-10 dataset (Error Rate (\%)). UPS with no uncertainty-aware (UA) selection, selects using only confidence-based criteria.}

\label{tab:ablation}
\small
\centering
\begin{tabular}{l|cc}
\hline
Method & 1000 labels & 4000 labels \\ \hline
Supervised &  27.66 & 16.65 \\
UPS, no selection &  22.60 & 12.94 \\ 
UPS, no UA & 16.50 & 10.02 \\ UPS, no UA (Cal.) & 13.68 & 8.09 \\ UPS, no NL &  9.46 & 6.64 \\ \hline UPS, full method & 8.14 & 6.36 \\ \hline
\end{tabular}
\end{wraptable} 

\subsection{Ablations}
\label{sec:ablation}
We present an ablation study to measure the contribution of the method's different components. We run experiments on CIFAR-10 with 1000 and 4000 labeled samples. Table \ref{tab:ablation} displays the results from our ablation study. Standard pseudo-labeling (UPS, no selection) slightly improves upon the supervised baseline; this is caused by the large number of incorrect pseudo-labels present in training. Through confidence-based selection (UPS, no uncertainty-aware (UA) selection), many incorrect pseudo-label are ignored, leading to  and  error rate reductions for 1000 and 4000 labels respectively. When MC-Dropout is used to improve network calibration (UPS, no UA (Cal.)), there is a slight improvement; however, this calibration is not adequate to produce sufficiently accurate pseudo-labels. Hence, by including uncertainty into the selection process, a further improvement of  is observed for 1000 samples and  for 4000 samples. We also find that negative learning (NL) is beneficial in both experimental setups. By incorporating more unlabeled samples in training (i.e. samples which do not have a confident and certain positive label), NL leads to  and  error rate reductions for 1000 and 4000 samples respectively.



\subsection{Analysis}



\begin{wrapfigure}{r}{0.48\linewidth}
\vspace{-4mm}


\centering
\includegraphics[width=1.0\linewidth]{images/uncertainty_error.pdf}

\caption{Robustness to uncertainty threshold. Thresholds below 0.1 lead to similar test error on CIFAR-10 (1000 labels), showing that UPS is not reliant on a single threshold.}
\label{fig:uncertaintyrobust}
\vspace{-2.5mm}
\end{wrapfigure}


\paragraph{Robustness to Hyperparameters} Our framework introduces new threshold hyperparameters  and . Following \citep{oliver2018realistic} we do not ``over-tweak" the hyperparameters - we select thresholds based on a CIFAR-10 validation set of 1000 samples\footnote{Additional information on hyperparameter selection can be found in section \ref{sec:hyperparam} of the Appendix.}. Although our experiments set , we find that UPS is relatively robust to this hyperparameter. Figure \ref{fig:uncertaintyrobust} shows the test error produced when using various uncertainty thresholds. We find that using  leads to comparable performance, and further increases of the threshold lead to predictable performance drops (as the threshold increases, more noisy pseudo-labels are selected leading to higher test error). Once the uncertainty threshold is selected, confidence thresholds  also lead to similar performance. UPS requires little hyperparameter tuning: although our thresholds were selected using the CIFAR-10 validation set, these same thresholds were used successfully on the other datasets (CIFAR-100, UCF-101, and Pascal VOC) and splits. 





\paragraph{UPS vs Confidence-based PL} To investigate the performance difference between our approach and conventional pseudo-labeling, we analyse the subset of labels which UPS selects. Our analysis is performed on CIFAR-10 with 1000 labeled samples.
Both confidence based selection and UPS improve pseudo-labeling accuracy, while still utilizing the majority of samples by the end of the training, as seen in Figures \ref{fig:acc} and \ref{fig:num}. Specifically, after 10 pseudo-labeling iterations, UPS selects about 93.12\% of the positive pseudo-labels with an accuracy of 90.29\%. Of the remaining 3371 samples which do not have a selected positive pseudo-label, over 88\% of them are still used in training through negative learning: negative pseudo-labels are selected for 2988 samples, with an average of 6.57 negative pseudo-labels per sample. Even though confidence-based selection improves upon conventional PL in terms of label accuracy (77.44\% vs. 72.03\% in the initial pseudo-labeling step), it is insufficient to achieve strong overall performance. UPS overcomes this problem by initially selecting a smaller, more accurate subset (20217 positive labels with an accuracy of 94.87\%), and gradually increasing the number of selected pseudo-labels while maintaining high accuracy. 
 










    










 



\section{Discussion}
\label{sec:discussion}
\begin{wraptable}{r}{0.48\linewidth}
\vspace{-4mm}
\caption{Comparison of methods for uncertainty estimation on CIFAR-10 (1000 labels) (Error Rate (\%))}
\centering
\label{tab:comparison_uncertain}
\small
\centering
\begin{tabular}{l|cc}
\hline
Method & 1000 labels & 4000 labels \\ \hline
MC-Dropout  &  8.14 & 6.36 \\ 
MC-SpatialDropout & 8.28  & 6.60 \\ 
MC-DropBlock & 9.76  & 7.50 \\ 
DataAug & 8.28  & 6.72 \\ 
\hline
\end{tabular}
\end{wraptable}
\paragraph{Uncertainty Estimation}
UPS is a general framework, it does not depend on a particular uncertainty  measure. In our experiments, we use MC-Dropout \citep{pmlr-v48-gal16} to obtain the uncertainty measure. Ideally, approximate Bayesian inference methods \citep{NIPS2011_4329, 10.5555/3045118.3045290, pmlr-v48-louizos16} can be used to obtain prediction uncertainties; however, Bayesian NNs are computationally costly and more difficult to implement than non-Bayesian NNs. Instead, methods like \citep{wan2013regularization, NIPS2017_7219, tompson2015efficient, NIPS2018_8271_DropBlock} can be used without extensive network modification to obtain an uncertainty measure directly (or through Monte Carlo sampling) that can easily be incorporated into UPS. To this end, we evaluate UPS using three other uncertainty estimation methods using MC sampling with SpatialDropout \citep{tompson2015efficient} and DropBlock \citep{NIPS2018_8271_DropBlock}, as well as random data augmentation (DataAug). The experimental settings are described in Section \ref{sec:uncertaintyest} of the Appendix. Without using uncertainty estimation method specific hyperparameters, we find that UPS achieves comparable results when using any of these methods, as seen in Table \ref{tab:comparison_uncertain}.






\paragraph{Data Augmentation in SSL}
One major advantage of UPS over recent state-of-the-art consistency regularization based SSL methods is that it does not inherently rely on domain-specific data augmentations. For different data modalities like video, text, and speech it is not always possible to obtain a rich set of augmentations. This is evident in Table \ref{tab:comaprison_SSL_UCF101}, where both standard pseudo-labeling approach \citep{Lee2013PseudoLabelT} and UPS outperform MT \citep{NIPS2017_6719_meanT} on the video dataset, UCF-101. Recent state-of-the-art SSL methods, like \citep{Berthelot2020ReMixMatch:, sohn2020fixmatch}, divide the augmentation space into the sets of strong and weak augmentations, which is possible for the image domain as it has many diverse augmentations. However, it is not straightforward to extend these methods to other data modalities; for instance, in the video domain, the two dominant augmentations are spatial crop and temporal jittering, which are difficult to divide into strong and weak subcategories. Moreover, the Mixup \citep{zhang2018mixup} data augmentation is used in several recent SSL methods \citep{Verma2019InterpolationCT,NIPS2019_8749_MixMatch, Berthelot2020ReMixMatch:}; it achieves strong results on single-label data, but extensions to multi-label classification have been ineffective \citep{wang2019baseline}.
Although using augmentations during training improves network performance (see section \ref{sec:data_aug} in the Appendix), the existence of domain-specific augmentations is not a prerequisite for UPS.


\vspace{-1mm}
\section{Conclusion}
In this work, we propose UPS, an uncertainty-aware pseudo-label selection framework that maintains the simplicity, generality, and ease of implementation of pseudo-labeling, while performing on par with consistency regularization based SSL methods. Due to poor neural network calibration, conventional pseudo-labeling methods trained on a large number of incorrect pseudo-labels result in noisy training; our pseudo-label selection process utilizes prediction uncertainty to reduce this noise. This results in strong performance on multiple benchmark datasets. The unique properties of UPS are that it can be applied to multiple data modalities and to both single-label and multi-label classification. We hope that in the future, the machine learning community will focus on developing general SSL algorithms which do not have inherent limitations like domain-specific augmentations and single-label assumptions.




\paragraph{ACKNOWLEDGEMENTS}
This research is based upon work supported by the Office of the Director of National Intelligence (ODNI), Intelligence Advanced Research Projects Activity (IARPA), via IARPA R\&D Contract No. D17PC00345. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of the ODNI, IARPA, or the U.S. Government. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright annotation thereon.



\bibliography{iclr2021_conference}
\bibliographystyle{iclr2021_conference}

\appendix
\section{Appendix}

In the appendix we include the following: training procedure of UPS (section \ref{sec:algorithm}), additional experiments on Pascal VOC, UCF-101, and CIFAR-10 (section \ref{sec:experiments}), implementation details of the uncertainty estimation  (section \ref{sec:uncertaintyest}), experiments with additional data augmentation (section \ref{sec:data_aug}), analysis of the effects of class balancing in pseudo-label selection (section \ref{sec:class_balance}), additional details on ECE (section \ref{sec:ece}), details pertaining to the use of MixMatch in multi-label classification (section \ref{sec:mixmatch}), additional details about hyperparameter selction (section \ref{sec:hyperparam}), and some qualitative results (section \ref{sec:qualitative}).

\section{UPS Training Procedure}
\label{sec:algorithm}
The training procedure for our proposed UPS framework is described in Algorithm \ref{alg: alogirthm1}.

\begin{algorithm}[h]
\caption{The proposed method takes a set of labeled data, , and a set of unlabeled data, , and returns a trained model, , using samples from both  and }
\label{alg: alogirthm1}
\begin{algorithmic}[1]
\State Train a network, , using the samples from .

\For{ = 1..MaxIterations} \Comment{Repeats until convergence}
  \State Pseudo-label  using  \Comment{Equation \ref{eq:pl}} 
  \State   Select pseudo-labels using UPS \Comment{Equation \ref{eq:ups}} 
  \State 
  \State Initialize new network 
  \State Train  using the samples from . \Comment{Using cross-entropy loss or losses in Equations 4-5}
  \State 
\EndFor
\State \textbf{return} 


\end{algorithmic}
\end{algorithm}





\section{Additional Results}
\label{sec:experiments}


\subsection{Fully Supervised Classification Scores}
For Pascal VOC2007 and UCF-101 datasets the fully supervised classification
scores are presented in Table \ref{tab:supervised}; these scores can be viewed as an upper-bound for our method, as our method trains in a supervised manner on the pseudo-labeled samples and on a percentage of the labeled data. These results should not be confused with the ``Supervised" baseline in Tables \ref{tab:comaprison_SSL_PASCALVOC} and \ref{tab:comaprison_SSL_UCF101} of our paper, which involve training with \textit{only} the listed percentage of data. With UPS we obtain a mAP of 40.34 and 34.22 when  and  of the Pascal VOC2007 training-validation data is available respectively. Using all labeled data, a fully supervised network achieves 52.62\% mAP with the ResNet-50 network. For UCF-101, a fully supervised 3D ResNet-18 achieves 50.4\% accuracy. Even with only  of the labeled data, UPS is able to achieve a similar accuracy (50.2\%).







\begin{table}[h]
\caption{Fully supervised classification score on Pascal VOC2007 and UCF-101 dataset. The metrics used for each dataset are mAP and accuracy, respectively.}
\begin{center}
\label{tab:supervised}
\small
\begin{tabular}{l|c|c|c|c}
\hline
Dataset & UPS, 10\% data & UPS, 20\% data & UPS, 50\% data & Supervised, all data \\ \hline
Pascal VOC2007 &  &  & - &   \\ 
UCF-101 & - & 39.4 & 50.2 &  \\ \hline
\end{tabular}
\end{center}
\end{table}

\subsection{CIFAR-10 Results}
We conduct experiments on the CIFAR-10 dataset with 250 and 500 labeled examples. The results are presented in table \ref{tab:250_500}. We achieve similar results (within 1.5\%) to MixMatch \citep{NIPS2019_8749_MixMatch} when using CNN-13 on 250 labels. Most other pseudo-labeling based semi-supervised learning methods do not present results using 250 and 500 labeled samples.



\begin{table}[h]
\caption{Error rates on CIFAR-10 dataset with very few training samples. }
\begin{center}
\label{tab:250_500}
\small
\begin{tabular}{l|cc}
\hline
Method & 250 labels & 500 labels \\ \hline
UPS &  &  \\ \hline
\end{tabular}
\end{center}
\end{table}


\section{Uncertainty Estimation: Implementation Details}
\label{sec:uncertaintyest}



The proposed UPS framework can leverage most uncertainty estimation methods to select a better calibrated subset of pseudo-labels. In Table \ref{tab:comparison_uncertain} of the main text we show that UPS performs comparably when uncertainty is estimated using \citep{tompson2015efficient, NIPS2018_8271_DropBlock} through Monte Carlo sampling during inference time. For MC-SpatialDropout we set the dropout rate to  and performed  stochastic forward passes to obtain an uncertainty measure from the standard deviation of the output probabilities. We follow the same MC sampling strategy with MC-DropBlock. Following \citep{NIPS2018_8271_DropBlock} we set the keep probability to  for the experiment with MC-DropBlock. For estimating uncertainty with random data augmentation we perform  forward passes while performing random crop and random horizontal flip.  







\section{Data Augmentation}
\label{sec:data_aug}
Since it is common practice to use data augmentation on image datasets, we use RandAugment \citep{DBLP:journals/corr/abs-1909-13719} for experiments on CIFAR-10, CIFAR-100, and Pascal VOC2007 datasets. For UCF-101 dataset experiments, we use random crop and temporal jittering following \citep{jing2020videossl}. The Mixup augmentation \citep{zhang2018mixup} has become widely used in both supervised and semi-supervised classification. We test how the addition of this powerful augmentation technique could improve UPS on single-label classification. As the extension of Mixup to negative learning is non-trivial, we do not include negative learning in this experiment. For Mixup, we set the hyper-parameter  to 0.50. Since the output prediction with mixup augmentation is better calibrated \citep{thulasidasan2019mixup} we use relaxed thresholds for  () and  (). The results are presented in table \ref{tab:mixup}. As expected the improved augmentation leads to an improvement: it achieves a 2.16\% reduction in error when compared to UPS without negative learning on the 1000 label experiment. Notably, UPS+Mixup  even outperforms UPS with negative learning. 

\begin{table}[t]
\caption{The effect of using the Mixup augmentation with UPS on CIFAR-10 dataset with 1000 labels.
}
\begin{center}
\label{tab:mixup}
\small
\begin{tabular}{l|c}
\hline
Method & Error Rate (\%) \\ \hline
UPS, without negative learning  & 9.46 \\ 
UPS, with negative learning  &  8.14 \\ 
UPS+Mixup, without negative learning & 7.30  \\ 
\hline
\end{tabular}
\end{center}
\end{table}

Since our method is not inherently reliant on specific data augmentations, we run additional experiments on CIFAR-10, with no input augmentations. The results are shown in the table \ref{tab:noaugments}. Our method achieves an error rate of 28.14\% and 14.98\% for 1000 and 4000 labels respectively. This is a respectable score that improves upon other SSL methods  model \citep{LaineA17} and Mean Teacher \citep{NIPS2017_6719_meanT} in the same experimental setting (i.e. no data augmentations).


\begin{table}[t]
\caption{Error rates on the CIFAR-10 test set with no input augmentations used during training.}
\begin{center}
\label{tab:noaugments}
\small
\begin{tabular}{l|c|c}
\hline
Method & 1000 labels & 4000 labels \\ \hline
 model & 32.18 & 17.08 \\ 
MT  &  30.62 & 17.74 \\ 
UPS & 28.14 & 14.98  \\ 
\hline
\end{tabular}
\end{center}
\end{table}








\section{Effect of Class Balancing}
\label{sec:class_balance}

In our experiments, we observe that generating pseudo-labels with only a limited number of labeled samples is difficult especially for the datasets with a small number of classes -  CIFAR-10 and Pascal VOC2007. For these datasets, when the number of training samples is limited, the network tends to be biased towards easy classes which leads to class imbalance during the pseudo-label selection; this is specifically true for the initial pseudo-labeling iterations. Table \ref{tab:per_class_selection} presents the number of selected pseudo-labels for each class of CIFAR-10 during the first pseudo-labeling iteration. For  labeled samples, there is an imbalance between the number of selected pseudo-labels for each class; the cat class has only  pseudo-labels selected whereas the automobile class has  selected pseudo-labels, leading to an imbalance ratio of . For the CIFAR-10 experiment with  labeled samples the imbalance ratio is not that severe but it's still . To address this issue we make the pseudo-label selection class balanced for CIFAR-10 for the first 10 pseudo-labeling iterations. Even though Pascal VOC2007 itself is not a class balanced dataset, it has only  object classes and training with limited data results in a trained classifier biased towards easy classes. Therefore, for the first iteration of pseudo-label selection, we enforce class balancing for the Pascal VOC2007 dataset, which results in improvement. The results with and without class balancing are presented in table \ref{tab:class_balanced_cifar10_pascalvoc}. It is evident that class balancing is more impactful when fewer labeled samples are used in training.


\begin{table}[h]
\caption{Number of selected pseudo-labels from each class of CIFAR-10.}
\begin{center}
\label{tab:per_class_selection}
\small
\begin{tabular}{l|cc}
\hline
Class ID and Name & 1000 labels & 4000 labels \\ \hline
0 (airplane)  &  2707 & 3274 \\ 
1 (automobile) & 3734 & 3900  \\
2 (bird) & 1929 & 2377 \\ 
3 (cat) & 1065 & 1658 \\ 
4 (deer) & 2145 & 2898 \\ 
5 (dog) & 1924 & 2273 \\ 
6 (frog) & 3224 & 3468 \\ 
7 (horse) & 3266 & 3403 \\ 
8 (ship) & 3083 & 3538 \\ 
9 (truck) & 3214 & 3920 \\ 
\hline
\end{tabular}
\end{center}
\end{table}


\begin{table}[h]
\caption{Performance on the CIFAR-10 and Pascal VOC2007 test sets.}
\label{tab:class_balanced_cifar10_pascalvoc}
\centering
\small
\begin{tabular}{l|cc|cc}
\hline
\multicolumn{1}{c|}{\multirow{2}{*}{Method}} & \multicolumn{2}{c|}{CIFAR-10 (accuracy)} & \multicolumn{2}{c}{Pascal VOC2007 (mAP)} \\  
\multicolumn{1}{c|}{} & 1000 labels & 4000 labels & 10\% labeled & 20\% labeled \\ \hline
UPS, with class balance &  &  &  &  \\
UPS, without class balance &  &  &  &  \\
 
\hline
\end{tabular}
\end{table}


\section{Expected Calibration Error (ECE) Computation}
\label{sec:ece}

In our work, we analyse the effect of prediction uncertainty and network calibration. A standard metric for measuring network calibration is Expected Calibration Error (ECE) \citep{pmlr-v70-guo17a, Xing2020Distance-Based} score,


where the confidence predictions on dataset  are partitioned into  equally-spaced bins.  are the samples present in a particular bin . The discrepancy between the average confidence and average accuracy gives the calibration gap of each bin. The average over the calibration gap of all the bins results in ECE score. In our ECE score calculation we have set . Conventionally, ECE is calculated over an entire test set. In our case, we select a subset of unlabeled samples based on their prediction uncertainty and calculate the ECE on this subset. As shown in the main text, we find that as the prediction uncertainty decreases, the ECE score tends to decrease. This implies that neural networks tend to be more calibrated on samples for which it has a lower uncertainty.



\section{MixMatch for Multi-Label Classification}
\label{sec:mixmatch}
MixMatch \citep{NIPS2019_8749_MixMatch} is a recent popular SSL method that performs well in the single-label case. We find that this performance does not transfer to the multi-label case. For implementing MixMatch for multi-label classification in the Pascal VOC2007 dataset we use the default parameters mentioned in their paper. We set the value of  to be  and we use . Label sharpening for single-label predictions defined below, cannot be applied to multi-label predictions, which assume class independence.



 Sharpening can be performed independently on each output by dividing the logits by a temperature , and applying a sigmoid operation to obtain the probabilities . In our experiments, we found that this did not lead to a significant change in results, so in our main paper the MixMatch experiments on Pascal VOC2007, we report results without label sharpening. 




\begin{figure}\centering
    
   \subfloat[]{{\includegraphics[width=0.49\linewidth]{images/conf_stacked_barchart_cifar10_1000_new.pdf}{\label{fig:sel_conf_1000}} }} \subfloat[]{{\includegraphics[width=0.49\linewidth]{images/unc_7_stacked_barchart_cifar10_1000_new.pdf}{\label{fig:sel_unc_conf_1000}} }}\\
   \subfloat[]{{\includegraphics[width=0.49\linewidth]{images/conf_stacked_barchart_cifar10_1000.pdf}{\label{fig:sel_conf}} }} \subfloat[]{{\includegraphics[width=0.49\linewidth]{images/unc_7_stacked_barchart_cifar10_1000.pdf}{\label{fig:sel_unc_conf}} }}\\
    
    
    \caption{(a) The distribution of correct and incorrect pseudo-labels with respect to the confidence on a 1000 sample CIFAR-10 validation set. (b) The distribution of correct and incorrect pseudo-labels with respect to the uncertainty on a 1000 sample CIFAR-10 validation set. (c) The distribution of correct and incorrect pseudo-labels with respect to the confidence on the set of unlabeled samples. (d) The distribution of correct and incorrect pseudo-labels with respect to the uncertainty on the set of unlabeled samples.  Both the full unlabeled set and the small validation have similar skewed confidence and uncertainty distributions.}
    \label{fig:example}\end{figure}


\section{Hyperparameter Selection}
\label{sec:hyperparam}


In this section, we present how hyperparameters are selected in our experiments. As stated in the main text, our hyper-parameters are selected based on a 1000 sample CIFAR-10 validation set. The distribution of pseudo-labels for this validation set can be found in Figures \ref{fig:sel_conf_1000} and \ref{fig:sel_unc_conf_1000}. The distributions with respect to confidence and uncertainty are skewed toward 1 and 0 respectively. Therefore, selecting confidence and uncertainty thresholds which encompass the majority of pseudo-labels, while maintaining a relatively high accuracy would be sufficient. We find that a similar pattern emerges on the full unlabeled set (Figures \ref{fig:sel_conf} and \ref{fig:sel_unc_conf}). 

On the CIFAR-10 validation set, we select the confidence threshold of  and uncertainty threshold of  leading to the selection of 531 labels with 92.28\% accuracy. We find that once we select this uncertainty threshold, , changes in the confidence threshold yields a similar numbers of selected pseudo-labels with similar accuracy. Although, if we select a less strict uncertainty threshold, then changes in the confidence threshold have larger impacts. Since we did not want to over-tweak the confidence threshold from dataset to dataset, we maintained this stricter uncertainty threshold of 0.05 throughout our experiments. However, for any drastically different dataset, we can perform this analysis to obtain a new set of thresholds.

Using a fixed set of hyper-parameters in our experiments demonstrates that UPS can give reasonable performance without dataset specific hyper-parameter tuning; we achieve strong performance on CIFAR-100 and UCF-101 with thresholds obtained from the CIFAR-10 validation set. It is true that a better set of hyper-parameters for a particular dataset can always be found, which is also the case for existing SSL methods (e.g. loss weighting for unlabeled samples and  in the MixUp augmentation are both hyper-parameters which can be tuned for improved performance), but the robustness of our method (shown on multiple datasets) and a reasonable hyper-parameter selection strategy enables our method to be applicable to many different datasets.

\section{Calibration and Threshold Selection}

We show in our ablations (Table 5) that having a calibrated network with confidence-based thresholding achieves better performance than without calibration, when the confidence threshold are the same (=0.7). However, we find that even with adjusted thresholds the calibrated network is unable to achieve sufficient pseudo-labeling accuracy to outperform the uncertainty-aware selection. We present the accuracy for the first set of selected pseudo-labels (CIFAR-100, 4000 labels) in Table \ref{tab:diffthresh}. Increasing the threshold for the calibrated network leads to increased accuracy (which is to be expected), but even with this high threshold of 0.9, it is unable to achieve the 83\% selected pseudo-label accuracy of UPS.

\begin{table}[h]
\caption{Pseudo-Labeling accuracy on the CIFAR-100 (4000 labels)}
\label{tab:diffthresh}
\centering
\small
\begin{tabular}{l|ccc}
\hline
Method &  &  &  \\ \hline
Conf.-Based Selection &  &  &  \\
Conf.-Based Selection (Cal) &  &  &  \\
UPS &  &  &  \\
 
\hline
\end{tabular}
\end{table}



Based on the trend present in this table, it is feasible that there exists some confidence-based threshold for a network (uncalibrated or calibrated) that could achieve strong pseudo-labeling performance. However, finding such a threshold would be difficult and would not reasonably transfer across datasets. Calibrating the network may make the task simpler, as it moves distribution of confidences, but the use of UPS allows us to find a robust set of thresholds (both confidence and uncertainty) which can be applied across different label splits and datasets.





\section{Negative Learning}
\label{sec:nl}
There are several distinctions between the use of NL in previous works \citep{kim2019nlnl} and its use in this work. First, the motivation of using negative labels in this work is to 1) incorporate more unlabeled samples into the training procedure, and 2) to generalize pseudo-labeling for the multi-label classification setting. On the other hand, \cite{kim2019nlnl} use negative learning primarily to obtain good network initializations to learn with noisy labels.

Furthermore, our negative labels are selected in an uncertainty-aware process (equation \ref{eq:ups}), whereas \cite{kim2019nlnl} initially generates negative labels randomly (NL step) to train a network and then use that network to selectively generate negative labels using confidence scores (SelNL). Their use of selective positive learning (SelPL) also relies on confidence-based positive pseudo-label creation. In our work, we show that relying on confidence-based selection is insufficient, and our proposed uncertainty-aware selection is beneficial for the pseudo-labeling task. In general, our method is not built upon negative learning - we achieve strong performance without NL (see Table \ref{tab:ablation}), but best performance is achieved when the additional negatively pseudo-labeled samples are used during training.












\section{Qualitative Results}
\label{sec:qualitative}
In Figure  \ref{fig:qualitative} we show some incorrect pseudo-labels obtained from the network trained with  labeled samples from the CIFAR-10 dataset. As the confidence scores for all these images is greater than 0.9, no reasonable confidence based selection criteria would be able to filter out these incorrect predictions. However, UPS easily filters out these incorrect pseudo-labels by leveraging the prediction uncertainties. This demonstrates the adverse effect of poor network calibration in pseudo-labeling, and the benefit of using uncertainty in the selection process.  


\begin{figure}\centering
   
  \includegraphics[width=\linewidth]{images/final_master5.png}
    \caption{CIFAR-10 samples with incorrect high confidence predictions, that are filtered out by UPS when prediction uncertainty is leveraged. }
    \label{fig:qualitative}\end{figure}

\end{document}
