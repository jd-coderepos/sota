\pdfoutput=1


\documentclass[11pt]{article}

\usepackage{emnlp2021}

\usepackage{times}
\usepackage{latexsym}

\usepackage[T1]{fontenc}


\usepackage[utf8]{inputenc}

\usepackage{microtype}

\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{bm}
\usepackage{color}
\usepackage{multirow}
\usepackage[export]{adjustbox}
\usepackage{float}
\usepackage{comment}



\title{Adaptive Information Seeking for Open-Domain Question Answering}

\author{Yunchang Zhu, Liang Pang, Yanyan Lan, Huawei Shen, Xueqi Cheng \\
    Data Intelligence System Research Center \\ 
    and CAS Key Lab of Network Data Science and Technology, \\
    Institute of Computing Technology, Chinese Academy of Sciences \\
    University of Chinese Academy of Sciences \\
    Institute for AI Industry Research, Tsinghua University \\
    \texttt{\{zhuyunchang17s, pangliang, shenhuawei, cxq\}@ict.ac.cn} \\
    \texttt{lanyanyan@tsinghua.edu.cn}
}

\begin{document}
\maketitle
\begin{abstract}
Information seeking is an essential step for open-domain question answering to efficiently gather evidence from a large corpus. 
Recently, iterative approaches have been proven to be effective for complex questions, by recursively retrieving new evidence at each step.
However, almost all existing iterative approaches use predefined strategies, either applying the same retrieval function multiple times or fixing the order of different retrieval functions, which cannot fulfill the diverse requirements of various questions. 
In this paper, we propose a novel adaptive information-seeking strategy for open-domain question answering, namely AISO. 
Specifically, the whole retrieval and answer process is modeled as a partially observed Markov decision process, where three types of retrieval operations (e.g., BM25, DPR, and hyperlink) and one answer operation are defined as actions.
According to the learned policy, AISO could adaptively select a proper retrieval action to seek the missing evidence at each step, based on the collected evidence and the reformulated query, or directly output the answer when the evidence set is sufficient for the question.
Experiments on SQuAD Open and HotpotQA fullwiki, which serve as single-hop and multi-hop open-domain QA benchmarks, show that AISO outperforms all baseline methods with predefined strategies in terms of both retrieval and answer evaluations. 
\let\thefootnote\relax\footnotetext{*Corresponding Author}
\end{abstract}


\section{Introduction}
Open-domain question answering (QA) \citep{voorhees1999trec} is a task of answering questions using a large collection of texts (e.g., Wikipedia). 
It relies on a powerful information-seeking method to efficiently retrieve evidence from the given large corpus.

\begin{figure}
    \centering
    \includegraphics[width=0.47\textwidth]{example.pdf}
    \caption{An example derived from HotpotQA development set. P1, P2 and P3 are the most relevant passages, of which P2 and P3 are supporting passages, which are essential to answer the question. Except for the adaptive strategy in the last row, fixed strategy methods such as using BM25 or dense retrieval multiple times and first using BM25 and then entity linking have failed, due to the rank of the remaining supporting passages larger than 1k. The number between two arrows indicates the highest rank of the remaining supporting passages in the retrieval list, unless ranked first.}
    \label{fig:exmaple}
\end{figure}

Traditional open-domain QA approaches mainly follow the two-stage retriever-reader pipeline \citep{chen-etal-2017-reading, yang-etal-2018-hotpotqa, karpukhin-etal-2020-dense}, in which the retriever uses a determinate sparse or dense retrieval function to retrieve evidence, independently from the reading stage. 
But these approaches have limitations in answering complex questions, which need multi-hop or logical reasoning \cite{xiong2021answering}. 

To tackle this issue, iterative approaches have been proposed to recurrently retrieve passages and reformulate the query based on the original question and the previously collected passages. 
Nevertheless, all of these approaches adopt fixed information-seeking strategies in the iterative process.
For example, some works employ a single retrieval function multiple times \citep{das2018multistep, qi-etal-2019-answering, xiong2021answering}, and the other works use a pre-defined sequence of retrieval functions \citep{Asai2020Learning, Dhingra2020Differentiable}.

However, the fixed information-seeking strategies cannot meet the diversified requirements of various problems. 
Taking Figure~\ref{fig:exmaple} as an example, the answer to the question is `Catwoman' in P3.
Due to the lack of essential supporting passages, simply applying BM25/dense retrieval (DR) multiple times (strategy 1 \citep{qi-etal-2019-answering} or 2 \citep{xiong2021answering}), or using the mixed but fixed strategy (strategy 3 \citep{Asai2020Learning}) cannot answer the question.
Specifically, it is hard for \citet{qi-etal-2019-answering} to generate the ideal query `Catwoman game' by considering P1 or P2, thus BM25 \citep{10.1561/1500000019} suffers from the mismatch problem and fails to find the next supporting passage P3.
The representation learning of salient but rare phrases (e.g.~`Pitof') still remains a challenging problem \citep{karpukhin-etal-2020-dense}, which may affect the effectiveness of dense retrieval, i.e.,~the supporting passage P3 is ranked 65, while P1 and P2 do not appear in the top-1000 list at the first step.
Furthermore, link retrieval functions fail when the current passage, e.g.,~P2, has no valid entity links.

Motivated by the above observations, we propose an \textbf{A}daptive \textbf{I}nformation-\textbf{S}eeking approach for \textbf{O}pen-domain QA, namely AISO. 
Firstly, the task of open-domain QA is formulated as a partially observed Markov decision process (POMDP) to reflect the interactive characteristics between the QA model (i.e.,~agent) and the intractable large-scale corpus (i.e.,~environment).
The agent is asked to perform an action according to its state (belief module) and the policy it learned (policy module).
Specifically, the belief module of the agent maintains a set of evidence to form its state.
Moreover, there are two groups of actions for the policy module to choose, 
1) retrieval action that consists of the type of retrieval function and the reformulated query for requesting evidence, 
and 2) answer action that returns a piece of text to answer the question, then completes the process.
Thus, in each step, the agent emits an action to the environment, which returns a passage as the observation back to the agent. 
The agent updates the evidence set and generates the next action, step by step, until the evidence set is sufficient to trigger the answer action to answer the question.
To learn such a strategy, we train the policy in imitation learning by cloning the behavior of an oracle online, which avoids the hassle of designing reward functions and solves the POMDP in the fashion of supervised learning.

Our experimental results show that our approach achieves better retrieval and answering performance than the state-of-the-art approaches on SQuAD Open and HotpotQA fullwiki, which are the representative single-hop and multi-hop datasets for open-domain QA. 
Furthermore, AISO significantly reduces the number of reading steps in the inference stage.


In summary, our contributions include: 
\begin{itemize}
    \item To the best of our knowledge, we are the first to introduce the adaptive information-seeking strategy to the open-domain QA task;
    \item Modeling adaptive information-seeking as a POMDP, we propose AISO, which learns the policy via imitation learning and has great potential for expansion.
    \item The proposed AISO achieves state-of-the-art performance on two public dataset and wins the first place on the HotpotQA fullwiki leaderboard. Our code is available at \url{https://github.com/zycdev/AISO}.
\end{itemize}


\begin{figure*}
    \centering
    \includegraphics[width=1\textwidth]{model.pdf}
    \caption{The overview of the AISO.}
    \label{fig:model}
\end{figure*}


\section{Related Work}
Traditional approaches of open-domain QA mainly follow the two-stage retriever-reader pipeline \citep{chen-etal-2017-reading}: a retriever first gathers relevant passages as evidence candidates, then a reader reads the retrieved candidates to form an answer.
In the retrieval stage, most approaches employ a determinate retrieval function and treat each passage independently \citep{wang2018r, lin-etal-2018-denoising, lee-etal-2018-ranking, yang-etal-2018-hotpotqa, pang2019has, lee-etal-2019-latent, pmlr-v119-guu20a, karpukhin-etal-2020-dense, izacard2020leveraging}.
As an extension, some approaches further consider the relations between passages through hyperlinks or entity links and extend evidence with the linked neighbor passages \citep{nie-etal-2019-revealing, das-etal-2019-multi, Zhao2020Transformer-XH}.
However, pipeline approaches retrieve evidence independently from reader, leading to 1) introduce less-relevant evidence to the question, and 2) hard to model the complex question which has high-order relationship between question and evidence.

Instead, recent iterative approaches sequentially retrieve new passages by updating the query inputted to a specific retrieval function at each step, conditioned on the information already gathered.
At each step, \citet{das2018multistep, feldman-el-yaniv-2019-multi, xiong2021answering} reformulate the dense query vector in a latent space, while \citet{ding-etal-2019-cognitive, qi-etal-2019-answering, zhang2020ddrqa, qi2020retrieve} update the natural language query.
After the first step retrieval using TF-IDF, \citet{Asai2020Learning} and \citet{li2020hopretriever} recursively select subsequent supporting passages on top of a hyperlinked passage graph.
Nevertheless, all of these approaches adopt fixed information-seeking strategies, employing the same retrieval function multiple times \citep{das2018multistep, feldman-el-yaniv-2019-multi, xiong2021answering, ding-etal-2019-cognitive, qi-etal-2019-answering, zhang2020ddrqa, qi2020retrieve} or pre-designated sequence of applying retrieval functions \citep{Asai2020Learning, li2020hopretriever}.
Due to the diversity of questions, these fixed strategies established in advance may not be optimal for all questions, or even fail to collect evidence.


\section{Method}
In this section, we first formulate the open-domain QA task as a partially observed Markov decision process (POMDP) and introduce the dynamics of the environment.
Then, we elaborate on how the agent interacts with the environment to seek evidence and answer a question.
Finally, to solve the POMDP, we describe how to train the agent via imitation learning.

\subsection{Open-Domain QA as a POMDP}\label{odqa_pomdp}
Given a question  and a large corpus  composed of passages, the task of open-domain QA is to collect a set of evidence  and answer the question based on the gathered evidence.

The fashion of iterative evidence gathering, proven effective by previous works \citep{das2018multistep, Asai2020Learning, xiong2021answering}, is essentially a sequential decision-making process.

Besides, since the corpus is large, ranging from millions (e.g., Wikipedia) to billions (e.g., the Web), and the input length of a QA model is limited, the QA model can only observe a part of the corpus.
Owing to the above two reasons, we model open-domain QA as a partially observed Markov decision process.

In the POMDP we designed, as shown in Figure~\ref{fig:model}, the agent is the QA model that needs to issue actions to seek evidence from the large-scale corpus hidden in the environment and finally respond to the question.
By executing the received action, the environment can return a retrieved passage to the agent as an observation of the corpus.
Formally, the POMDP is defined by , where  is the reward function.



\textbf{Actions:} 
At timestep , the action  in the action space  is a request for an executable function , expressed as , where  is the text argument that gets passed to .
The space of executable functions  includes two groups of functions,
1) retrieval function that takes the query  and corpus  as input and ranks a retrieval list of passages as , 
2) answer function that replies to the question  with the answer  and ends the process.
The action  is performed following the policy  described in Subsection~\ref{policy}.

\textbf{States:} 
The environment state  in the state space  contains revealing states of retrieval lists of all history retrieval actions.
When the agent issues an action ,  will transfer to  governed by a deterministic transition dynamics .
Specifically,  will mark the topmost unrevealed passage in the retrieval list  as revealed. 
If the environment has never executed  before, it will first search and cache  for possible repeated retrieval actions in the future.

\textbf{Observations:}
On reaching the new environment state , the environment will return an observation  from the observation space , governed by the deterministic observation dynamics . 
At the initial timestep, the question  will returned as .
In other cases,  is designed to return only the last passage marked as revealed in  at a time.
For example, if the action  is received for the th time, the th passage in  will be returned.

\subsection{Agent}\label{agent}
The agent interacts with the environment to collect evidence for answering the question.
Without access to the environment state , the agent can only perform sub-optimal actions based on current observations. 
It needs to build its belief  in the state that the environment may be in, based on its experience .
Therefore, the agent consists of two modules: \textbf{belief module}  that generates the belief state  from the experience , and \textbf{policy module}  that prescribes the action  to take for current belief state .

Both belief and policy modules are constructed based on pretrained Transformer encoders \citep{Clark2020ELECTRA}, respectively denoted as  and , which encode each inputted token into a -dimensional contextual representation.
The input of both encoders is a belief state, formatted as ``\verb|[CLS]| \verb|[YES]| \verb|[NO]| \verb|[NONE]|  \verb|[SEP]|  \verb|[SOP]|  \verb|[SEP]|  \verb|[SOP]|   \verb|[SEP]|'', where the subscript  denotes the observation passage, and the others passages come from the collected evidence set , \verb|[SOP]| is a special token to separate the title and content of a passage, \verb|[YES]| and \verb|[NO]| are used to indicate yes/no answer, and \verb|[NONE]| is generally used to indicate that there is no desired answer/query/evidence.
In this way, the self-attention mechanism across the concatenated sequence allows each passage in the input to interact with others, which has been shown crucial for multi-hop reasoning \citep{wang-etal-2019-multi-hop}.

\subsubsection{Belief Module}\label{belief}
The belief module  transforms the agent's experience  into a belief state  by maintaining a set of evidence .
At the end of the process, the evidence set  is expected to contain sufficient evidence necessary to answer the question and no irrelevant passage.
In the iterative process, the agent believes that all the passages in  may help answer the question.
In other words, those passages that were observed but excluded from the evidence set, i.e., , are believed to be irrelevant to the question.

For simplicity, assuming that the negative passages  and action history  are not helpful for subsequent decision-making, the experience  is equivalent to .
Thus, let  be the current candidate evidence set, then the original question and current evidence candidates can form the belief state  as

At the beginning, the belief state  is initialized to , and the evidence set  is initialized to .

To maintain the essential evidence set , we use a trainable scoring function  to identify each evidence candidate .
Specifically, each passage is represented as the contextual representation of the special token \verb|[SOP]| in it, which is encoded by .
Then, the representation of each candidate is projected into a score through a linear layer.
Besides, we use a pseudo passage , represented as \verb|[None]|, to indicate the dynamic threshold of the evidence set.
In this way, after step , the evidence set is updated as

It is worth noting that these evidence candidates are scored jointly since encoded together in the same input, different from conventional rerankers that score separately.

\subsubsection{Policy Module}\label{policy}
The policy module  decides the next action  to be taken based on the current belief state .
In this paper, we equipped the agent with three retrieval functions and one answer function, which means that the action space  consists of three types of retrieval actions and one type of answer actions.
However, unlike the finite space of executable functions , the space of function arguments  includes all possible natural-language queries and answers.
To narrow the search space, for each executable function, we employ a suggester to propose a plausible query or answer as the argument passed to the function.
Finally, we apply an action scoring function in the narrowed action space and select the action with the highest score.

\paragraph{Equipped Functions}
Formally, the space of executable functions is defined as .

Among them, except  is the answer function used to reply to the question, the rest are three distinct off-the-shelf retrieval functions (RF) used to explore the corpus.
 is a sparse RF, implemented as BM25 \citep{10.1561/1500000019}. 
It performs well when the query is concise and contains highly selective keywords but often fails to capture the semantics of the query.
 is a dense RF, implemented as MDR \citep{xiong2021answering} for multi-hop questions, and DPR \citep{karpukhin-etal-2020-dense} for single-hop questions.
Dense RFs can capture lexical variations and semantic relationships, but they struggle when encountering out-of-vocabulary words. 
 is a link RF, implemented as hyperlink.
When hyperlink markups are available in a source passage, it can readily map a query (i.e., anchor text) to the target passage.

\paragraph{Argument Generation}
The space of function arguments , composed of textual queries and answers, is too large to perform an exhaustive search due to the complexity of natural language.
To reduce the search complexity, inspired by \citet{yao-etal-2020-keep}, we employ four argument generators to generate the most plausible query/answer for the equipped functions.

 is a trainable reading comprehension model for .
It is a span extractor built upon the contextual representations outputted by the encoder .
Like conventional extractive reading comprehension models \citep{yang-etal-2018-hotpotqa, Clark2020ELECTRA},  uses the contextual representations to calculate the start and end positions of the most plausible answer .
If the current context  is insufficient to answer the question, the special token \verb|[NONE]| will be extreacted.

 is a query reformulation model for .
In this work, we directly employ the well-trained query reformulator from \citet{qi-etal-2019-answering} for multi-hop questions, which takes the belief state  as input and outputs a span of the input sequence as the sparse query .
As for single-hop questions, since there exists no off-the-shelf multi-step query reformulator, we leave  as an identity function that returns the original question directly.
In this case, requesting the same RF multiple times is equivalent to traverse the retrieval list of original question.

 is a query reformulator for .
For multi-hop questions,  concatenates the question  and the passage with the highest score in evidence set  as the dense query , the same as the input of MDR \citep{xiong2021answering}.
If  is empty,  is equal to the question .
Similar to ,  for single-hop questions also leaves original questions unchanged.

 is a trainable multi-class classifier for .
It selects the most promising anchor text from the belief state .
To enable rejecting all anchors, \verb|[NONE]| is also treated as a candidate anchor.
 shares the encoder , where each anchor is represented by the average of contextual representations of its tokens.
Upon , we use a linear layer to project the hidden representations of candidate anchors to real values and select the anchor with the highest value as the link query .

In this way, the action space is narrowed down to .

\paragraph{Action Selection}
The action scoring function  is also built upon the output of .
To score an action  for current belief state , an additional two-layer () MLP, with a ReLU activation in between, projects the concatenated representation of , executable function , and function argument , i.e., , , and , into a real value.
 is a trainable embedding for each executable function, the same dimension as the token embedding.
 is specific for each function.
Since ,  and  have explicit text span in the , thus their  are the averages of their token representations.
As for , if  does not expand the original question,  is the contextual representation of \verb|[NONE]|. 
Otherwise,  is the \verb|[SOP]| of the passage concatenated to the question.

In short, the next action is selected from the narrowed action space  by the scoring function ,


\subsection{Training}\label{training}
In the agent, in addition to the encoders  and , we need to train the evidence scoring function , link classifier ,  answer extractor , and action scoring function , whose losses are , , , and .
Since the policy module is dependent on the belief module, we train the agent jointly using the following loss function,


Unlike ,  and  that can be trained in supervised learning through human annotations in QA datasets, the supervision signal for  is hard to be derived directly from QA datasets.
Even though policies are usually trained via reinforcement learning, reinforcement learning algorithms \citep{sutton2000policy, mnih2015human} are often sensitive to the quality of reward functions. 
For a complex task, the reward function  is often hard to specify and exhaustive to tune.
Inspired by \citet{choudhury2017adaptive}, we explore the use of imitation learning (IL) by querying a model-based oracle online and imitating the action  chose by the oracle, which avoids the hassle of designing  and solves the POMDP in the fashion of supervised learning.
Thus, the loss of  is defined as the cross entropy,

where  is the belief state of the agent.

The link classifier  and the answer extractor  are also optimized with multi-class cross-entropy losses.
For , denoting its loss as , the classification label is set to the anchor text that links to a gold supporting passage, if there is no such anchor, then the pseudo hyperlink \verb|[NONE]| is labeled.
 is trained as a classifier of start and end position following previous work \citep{Clark2020ELECTRA}, denoting its loss as .
Considering the belief state , the ListMLE \citep{10.1145/1390156.1390306} ranking loss of the evidence scoring function  is defined as the negative log likelihood of the ground truth permutation,

where  is the relevance label of  and  is their ground truth permutation.
To learn the dynamic threshold , we set the relevance label of the pseudo passage  to . And passages in  are labeled as 1/0 according to whether they are gold supporting passages.

\paragraph{Model-based Oracle}
The model-based oracle has full access to the environment and can foresee the gold evidence and answer of every question, which means that the oracle can infer the rank of a supporting passage in the retrieval list of any retrieval action.
Thus, given a state, the oracle can easily select a near-optimal one from candidate actions according to a greedy policy .
Specifically, if all gold evidence is collected and the argument of an answer action is a correct answer, the oracle will select the answer action.
Otherwise, the oracle will use a greedy algorithm to select the retrieval action that helps to gather a missing passage of evidence in the fewest steps.

\paragraph{Belief States Sampling}
We train the agent on sampled belief states instead of long trajectories.
In every epoch, one belief state is sampled for each question.
To sample a belief state , we first uniformly sample a subset from 's gold evidence as , which could be an empty set.
However, at testing time, it is impossible for the candidate evidence set  to contain only gold evidence.
To alleviate the mismatch of the state distribution between training and testing, we inject a few negative passages into  and shuffle them.
We treat the first passage in the candidate set as the observation, and the others as evidence collected before.

The distribution of injected negative passages can affect the test performance.
In this work, to make it simple, we sample 0\textasciitilde2 passages from all top-ranked negative passages in retrieval lists of , , and .


\section{Experiments}
We evaluate AISO and baselines on two Wikipedia-sourced benchmarks. 
We first introduce the experimental setups, then describe the experimental results on evidence gathering and question answering. 
Furthermore, detailed analyses are discussed. 

\subsection{Experimental Setup}

\paragraph{Data}
HotpotQA \citep{yang-etal-2018-hotpotqa}, a multi-hop QA benchmark. We focus on its fullwiki (open-domain) setting\footnote{https://hotpotqa.github.io/wiki-readme.html}.
It requires gathering two supporting passages (paragraphs) to answering a question, given the introductory (first) paragraphs of 5M Wikipedia articles dumped on October 1, 2017. 

SQuAD Open \citep{chen-etal-2017-reading}, a single-hop QA benchmark, whose questions are from the SQuAD dataset \citep{rajpurkar-etal-2016-squad} and can be answered based on a single passage. 
We preprocess the Wikipedia dump on December 21, 2016 and extract hyperlinks using WikiExtractor\footnote{https://github.com/attardi/wikiextractor. We do not use the processed data provided by \citet{chen-etal-2017-reading} because it removed the hyperlinks required by our link RF.}.
Following \citet{karpukhin-etal-2020-dense}, we split articles into some disjoint passages, resulting in 20M passages in total. 
We add two extra hyperlinks to each passage, one linking to its previous passage in the article, the other to the next passage.

\paragraph{Metrics}
To test whether the top-2 passages in the evidence set exactly cover both gold supporting passages, we use Supporting Passage Exact Match (P EM) as the evaluation metric following \citep{Asai2020Learning}. 
To test the performance of answer extraction, we use EM and F1 as our metrics following \citep{yang-etal-2018-hotpotqa}.

\paragraph{Implementation Details}
For sparse retrieval, we index all passages in the corpus with Elasticsearch and implement BM25 following \citet{qi-etal-2019-answering}\footnote{https://github.com/qipeng/golden-retriever}.
For dense retrieval, we leverage the trained passage encoder and query encoder from \citet{karpukhin-etal-2020-dense}\footnote{https://github.com/facebookresearch/DPR, the multi-set version is used} and \citet{xiong2021answering}\footnote{https://github.com/facebookresearch/multihop\_dense \_retrieval} and index all passage vectors using FAISS \citep{johnson2019billion} offline.
During training, we use the HNSW-based index for efficient low-latency retrieval; in test time, we use the exact inner product search index for better retrieval results.
For link retrieval, the filtered hyperlinks are used, whose targets have to be another article from this dump.

Based on Huggingface Transformers \citep{wolf-etal-2020-transformers}, we use ELECTRA \citep{Clark2020ELECTRA} ( for base/large)\footnote{Many recent approaches are based on ELECTRA, so we use ELECTRA for fair comparison.} as the initializations for our encoders  and .
The maximum number of passages inputted into the encoders is set to 3 and the length of input tokens is limited to 512.
To avoid the high confidence passages from being truncated, we input the passages of evidence in descending order of their belief scores from the previous step.

To accelerate the model training, for the first 24 epochs,  and  share parameters, for the next 6 epochs, they are trained separately. 
The batch size is 32.
We use Adam optimization with learning rate .
To select the best agent (QA model), we first save several checkpoints that perform well on heuristic single-step metrics, such as action accuracy.
Then we choose the one that performs best in the whole process on the development set.
In test time, the number of interaction steps is limited to . 
We set the maximum number of steps to  if not specified.
Once the agent has exhausted its step budget, it is forced to answer the question.

\subsection{Results}

\begin{table}
\centering
\scalebox{0.7}{
\begin{tabular}{llcc} 
\toprule
Strategy                                 & Method                                      & P EM                      & \# read        \\ 
\midrule
\multirow{2}{*}{}                   & BM25                                        & 11.11                     & 2                   \\
                                         & BM25 + Reranker                           & 29.60                     & 20                  \\ 
\hline
                                    & DPR \citep{karpukhin-etal-2020-dense}        & 14.18                     & 2                   \\ 
\hline
\multirow{2}{*}{}         & Semantic Retrieval       & 69.35                     & 39.4                \\
                                         & Entity Centric IR       & 34.90                     & -                   \\ 
\hline
\hline
                          & GoldEn Retriever                          & 47.77                     & 10                  \\ 
\hline
\multirow{3}{*}{}         & MDR \citep{xiong2021answering}                                        & 64.52                     & 2                   \\
                                         & MDR + Reanker                     & 81.20                     & 200            \\
                                         & Ballen \citep{khattab2021baleen}                             & 86.70                     & -                   \\ 
\hline
\multirow{3}{*}{}                 & CogQA \citep{ding-etal-2019-cognitive}                             & 57.80                     & -                   \\
                                         & DDRQA \citep{chen-etal-2017-reading}                          & 79.80                     & -                   \\
                                         & IRRR \citep{qi2020retrieve}                      & 84.10                     & 150            \\ 
\hline
\multirow{4}{*}{}   & GRR \citep{Asai2020Learning}                       & 75.70                     & 500            \\
                                         & HopRetriever \citep{li2020hopretriever}              & 82.54                     & 500            \\
                                         & HopRetriever-plus   & 86.94                     & 500              \\
                                         & TPRR \citep{TPRR}                      & \multicolumn{1}{l}{86.19} & 500            \\ 
\hline
                  & DrKit \citep{Dhingra2020Differentiable}                             & 38.30                     & -                   \\ 
\hline
\multirow{2}{*}{} & AISO                        & 85.69                     & 36.7                \\
                                         & AISO                       & \textbf{88.17}            & 35.7                \\
\bottomrule
\end{tabular}}
\caption{Evidence gathering performance and reading cost on the HotpotQA fullwiki development set. 
The symbol  denotes the baseline methods use the large version of pretrained language models comparable to our AISO.
The results with  are from published papers, otherwise they are our implementations.
The symbol  denotes sequential apply RFs,  denotes apply the RF  multiple times,  denotes combining the results of different RFs, and  means choosing one of RFs to use according to the policy .
: \citep{nie-etal-2019-revealing},
: \citep{qi-etal-2019-answering},
: \citep{qi-etal-2019-answering}
}
\label{tab:hotpotqa_ret}
\end{table}

\begin{table*}
\centering
\scalebox{0.8}{\begin{tabular}{lcccccccccccc} 
\toprule
\multirow{3}{*}{Method} & \multicolumn{6}{c}{Dev}                                                                       & \multicolumn{6}{c}{Test}                                                                                                                             \\ 
\cmidrule(r){2-7}\cmidrule(r){8-13}
                        & \multicolumn{2}{c}{Ans}       & \multicolumn{2}{c}{Sup}       & \multicolumn{2}{c}{Joint}     & \multicolumn{2}{c}{Ans}                                  & \multicolumn{2}{c}{Sup}                & \multicolumn{2}{c}{Joint}                        \\ 
\cmidrule(r){2-3}\cmidrule(r){4-5}\cmidrule(r){6-7}\cmidrule(r){8-9}\cmidrule(r){10-11}\cmidrule(r){12-13}
                        & EM            & F1            & EM            & F1            & EM            & F1            & EM                                       & F1            & EM                     & F1            & EM                     & F1                      \\ 
\midrule
Semantic Retrieval \citep{nie-etal-2019-revealing}      & 46.5          & 58.8          & 39.9          & 71.5          & 26.6          & 49.2          & 45.3                                     & 57.3          & 38.7                   & 70.8          & 25.1                   & 47.6                    \\
GoldEn Retriever \citep{qi-etal-2019-answering}       & -             & -             & -             & -             & -             & -             & 37.9                                     & 49.8          & 30.7                   & 64.6          & 18.0                   & 39.1                    \\
CogQA \citep{ding-etal-2019-cognitive}                  & 37.6          & 49.4          & 23.1          & 58.5          & 12.2          & 35.3          & 37.1                                     & 48.9          & 22.8                   & 57.7          & 12.4                   & 34.9                    \\
DDRQA \citep{zhang2020ddrqa}                  & 62.9          & 76.9          & 51.3          & 79.1          & -             & -             & 62.5                                     & 75.9          & 51.0                   & 78.9          & 36.0                   & 63.9                    \\
IRRR+ \citep{qi2020retrieve}                  & -             & -             & -             & -             & -             & -             & 66.3                                     & 79.9          & 57.2                   & 82.6          & 43.1                   & 69.8                    \\
MUPPET \citep{feldman-el-yaniv-2019-multi}                 & 31.1          & 40.4          & 17.0          & 47.7          & 11.8          & 27.6          & 30.6                                     & 40.3          & 16.7                   & 47.3          & 10.9                   & 27.0                    \\
MDR \citep{xiong2021answering}                    & 62.3          & 75.1          & 56.5          & 79.4          & 42.1          & 66.3          &  62.3 & 75.3          & 57.5                   & 80.9          & 41.8                   & 66.6                    \\
GRR \citep{Asai2020Learning}                    & 60.5          & 73.3          & 49.2          & 76.1          & 35.8          & 61.4          & 60.0                                     & 73.0          & 49.1                   & 76.4          & 35.4                   & 61.2                    \\
HopRetriever \citep{li2020hopretriever}           & 62.2          & 75.2          & 52.5          & 78.9          & 37.8          & 64.5          & 60.8                                     & 73.9          & 53.1                   & 79.3          & 38.0                   & 63.9                    \\
HopRetriever-plus \citep{li2020hopretriever}      & 66.6          & 79.2          & 56.0          & 81.8          & 42.0          & 69.0          & 64.8                                     & 77.8          & 56.1                   & 81.8          & 41.0                   & 67.8                    \\
EBS-Large       & -             & -             & -             & -             & -             & -             & 66.2                                     & 79.3          & 57.3                   & 84.0          & 42.0                   & 70.0                    \\
TPRR \citep{TPRR}          & 67.3          & 80.1          & 60.2          & 84.5          & 45.3          & 71.4          & 67.0                                     & 79.5          & 59.4                   & 84.3          & 44.4                   & 70.8                    \\ 
\hline
AISO    & 63.5          & 76.5          & 55.1          & 81.9          & 40.2          & 66.9          & -                                        & -             & -                      & -             & -                      & -                       \\
AISO   & \textbf{68.1} & \textbf{80.9} & \textbf{61.5} & \textbf{86.5} & \textbf{45.9} & \textbf{72.5} & \textbf{67.5}                            & \textbf{80.5} & \textbf{\textbf{61.2}} & \textbf{86.0} & \textbf{\textbf{44.9}} & \textbf{\textbf{72.0}}  \\
\bottomrule
\end{tabular}}
\caption{Answer extraction and supporting sentence identification performance on HotpotQA fullwiki. 
The methods with  use the large version of pretrained language models comparable to AISO.
The results marked with  are from the official leaderboard otherwise originated from published papers.
}
\label{tab:hotpotqa_ans}
\end{table*}

\begin{table}
\centering
\scalebox{0.75}{
\begin{tabular}{lccc} 
\toprule
Method                                                  & EM            & F1            & \# read  \\ 
\midrule
DrQA \citep{chen-etal-2017-reading}                     & 27.1          & -             & 5        \\
Multi-passage BERT \citep{wang-etal-2019-multi-passage} & 53.0          & 60.9          & 100      \\
DPR \citep{karpukhin-etal-2020-dense}                   & 29.8          & -             & 100      \\
BM25+DPR \citep{karpukhin-etal-2020-dense}              & 36.7          & -             & 100      \\
Multi-step Reasoner \citep{das2018multistep}            & 31.9          & 39.2          & 5        \\
MUPPET \citep{feldman-el-yaniv-2019-multi}              & 39.3          & 46.2          & 45       \\
GRR \cite{Asai2020Learning}                   & 56.5          & 63.8          &  \\
SPARTA \citep{zhao2020sparta}                 & 59.3          & 66.5          & -        \\
IRRR \citep{qi2020retrieve}                   & 56.8          & 63.2          &  \\
\hline
AISO                                   & \textbf{59.5} & \textbf{67.6} & 24.8 \\
\bottomrule
\end{tabular}}
\caption{Question answering performance on SQuAD Open benchmark.  denotes the methods use the large pretrained language models comparable to AISO.}
\label{tab:squad_ans}
\end{table}

\paragraph{Evidence Gathering}
We first evaluate the performance and reading cost on the evidence gathering, illustrating the effectiveness and efficiency of AISO. 
In Table~\ref{tab:hotpotqa_ret}, we split evidence gathering methods into different groups according to their strategies. 
Moreover, the first three groups are the traditional pipeline approaches, and the others are iterative approaches.

For effectiveness, we can conclude that 1) almost all the iterative approaches perform better than the pipeline methods, 2) the proposed adaptive information-seeking approach AISO outperforms all previous methods and achieves the state-of-the-art performance.
Moreover, our AISO model outperforms some baselines that use the large version of pretrained language models, such as HopRetriever, GRR, IRRR, DDRQA, and MDR.

For efficiency, the cost of answering an open-domain question includes the retrieval cost and reading cost.
Since the cost of reading a passage along with the question online is much greater than the cost of a search, the total cost is linear in \#~read, reported in the last column of Table~\ref{tab:hotpotqa_ret}.
\#~read means the total number of passages read along with the question throughout the process, which is equal to the adaptive number of steps.
We can find that the number of read passages in AISO model, i.e., the  is about 35, which is extremely small than the competitive baselines (P EM > 80) that need to read at least 150 passages. 
That is to say, our AISO model is efficient in practice.

\paragraph{Question Answering}
Benefit from high-performance evidence gathering, as shown in Tables \ref{tab:hotpotqa_ans} and \ref{tab:squad_ans}, AISO outperforms all existing methods across the evaluation metrics on the HotpotQA fullwiki and SQuAD Open benchmarks.
This demonstrates that AISO is applicable to both multi-hop questions and single-hop questions.
Notably, on the HotpotQA fullwiki blind test set\footnote{https://hotpotqa.github.io. As of September 2021, AISO is still at the top of the fullwiki leaderboard.},  AISO significantly outperforms the second place TPRR \citep{TPRR} by 2.02\% in Sup F1 (supporting sentence identification) and 1.69\% on Joint F1.


\subsection{Analysis}

\begin{table}
\centering
\scalebox{0.8}{
\begin{tabular}{lccc} 
\toprule
Model                             & P EM  & Ans F1 & \# read  \\ 
\midrule
AISO              & 85.69 & 76.45  & 36.64    \\ 
\hline
w.~                 & 97.52 & 79.99  & 40.01    \\
w.~~+~ & 98.88 & 80.34  & 8.92     \\ 
\hline
                           & 68.51 & 67.33  & 58.74    \\
                           & 79.80 & 72.91  & 68.63    \\
             & 83.97 & 74.93  & 61.41    \\
             & 82.44 & 74.44  & 37.76    \\
             & 79.66 & 73.36  & 42.01    \\
\bottomrule
\end{tabular}}
\caption{Analysis experiments on HotpotQA fullwiki.}
\label{tab:ablation}
\end{table}

We conduct detailed analysis of AISO on the HotpotQA fullwiki development set. 

\paragraph{The effect of the belief and policy module}
As shown in the second part of Table~\ref{tab:ablation}, we examine the variations of AISO with the oracle evidence scoring function  or oracle action scoring function , which are key components of the belief and policy module.
When we replace our learned evidence scoring function with  that can identify supporting passage perfectly, the performance increase a lot while the reading cost do not change much.
This means that the belief module has a more impact on the performance than the cost. 
If we further replace the learned  with , the cost decreases a lot.
This shows that a good policy can greatly improve the efficiency.

\paragraph{The impact of retrieval functions}
As shown in the last part Table~\ref{tab:ablation}, the use of a single RF, such as  and , leads to poor performance and low efficiency.
Moreover, lack of any RF will degrade performance, which illustrates that all RFs contribute to performance.
Specifically, although the link RF  cannot be used alone, it contributes the most to performance and efficiency.
Besides, the sparse RF  may be better at shortening the information-seeking process than the dense RF , since removing  from the action space leads to the number of read passages increase from 36.64 to 61.41. 
We conjecture this is because  can rank the evidence that matches the salient query very high.

\paragraph{The impact of the maximum number of steps}
As shown in Figure~\ref{fig:step_metric}, with the relaxation of the step limit , AISO can filter out negative passages and finally observe low-ranked evidence through more steps, so its performance improves and tends to converge.
However, the cost is more paragraphs to read.
Besides, once  exceeds 1000, only a few questions (about 1\%) can benefit from the subsequent steps.

\begin{figure}
    \centering
    \includegraphics[width=0.48\textwidth]{step_metric.pdf}
    \caption{Performance and cost of AISO on the HotpotQA development set with different step limits.}
    \label{fig:step_metric}
\end{figure}

\paragraph{The ability to recover from mistakes}
We count three types of mistakes in gathering evidence on the HotpotQA development set. 
In the process of collecting evidence for 7405 questions, false evidence was added into the evidence set for 1061 questions, true evidence was missed for 449 questions, and true evidence was deleted from the evidence set for 131 questions.
And we find that AISO recovered from 17.7\%, 43.9\%, and 35.9\% of these three types of errors respectively, which implies that even without beam search, AISO can make up for previous mistakes to some extent.
Besides, we can see that false evidence is the most harmful to evidence gathering and the most difficult to remedy.


\section{Conclusion and Future Work}
This work presents an adaptive information-seeking approach for open-domain question answering, called AISO. 
It models the open-domain QA task as a POMDP, where the environment contains a large corpus and the agent is asked to sequentially select retrieval function and reformulate query to collect the evidence. 
AISO achieves state-of-the-art results on two public datasets, which demonstrates the necessity of different retrieval functions for different questions. 
In the future, we will explore other adaptive retrieval strategies, like directly optimizing various information-seeking metrics by using reinforcement learning techniques.


\section*{Ethical Considerations}
We honor and support the ACL code of Ethics. The paper focuses on information seeking and question answering tasks, which aims to answer the question in the open-domain setting. It can be widely used in search engine and QA system, and can help people find the information more accuracy and efficiency. Simultaneously, the datasets we used in this paper are all from previously published works and do not involve privacy or ethical issues.


\section*{Acknowledgements}
This work was supported by National Natural Science Foundation of China (NSFC) under Grants No. 61906180, No. 61773362 and No. 91746301, National Key R\&D Program of China under Grants 2020AAA0105200.
The authors would like to thank Changying Hao for valuable suggestions on this work.


\bibliography{anthology, custom}
\bibliographystyle{acl_natbib}

\end{document}
