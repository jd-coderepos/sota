
\documentclass{article} 
\usepackage{iclr2022_conference,times}
\PassOptionsToPackage{square,sort,comma,numbers}{natbib}



\usepackage{tikz}
\usetikzlibrary{arrows.meta,shapes,calc,matrix,fit,positioning,backgrounds,decorations.markings}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\pgfplotsset{compat=1.9}
\usepackage{xstring}



\usepgfplotslibrary{external}
\newcommand{\extfig}[2]{\tikzsetnextfilename{#1}{#2}}
\newcommand{\noextfig}[1]{\tikzset{external/export next={false}}{#1}}
\newcommand{\extdata}[1]{\input{#1}}
\IfBeginWith*{\jobname}{fig/extern/}{\finalcopy}{}



\tikzstyle{every picture}+=[
	remember picture,
	every text node part/.style={align=center},
	every matrix/.append style={ampersand replacement=\&},
]
\tikzstyle{tight} = [inner sep=0pt,outer sep=0pt]
\tikzstyle{node}  = [draw,circle,tight,minimum size=12pt,anchor=center]
\tikzstyle{op}    = [draw,circle,tight]
\tikzstyle{dot}   = [fill,draw,circle,inner sep=1pt,outer sep=0]
\tikzstyle{pt}    = [fill,draw,circle,inner sep=1.5pt,outer sep=.2pt]
\tikzstyle{box}   = [draw,thick,rectangle,inner sep=3pt]
\tikzstyle{high}  = [black!60]
\tikzstyle{group} = [high,box,opacity=.5]
\tikzstyle{rectc} = [tight,transform shape]
\tikzstyle{rect}  = [rectc,anchor=south west]



\newcommand{\framed}[3][1]{\extfig{#2}{\tikz{
	\node[tight](a){\fig[#1]{#3}};
	\node[tight,draw=gray,fit=(a)]{};
}}}



\newcommand{\leg}[1]{\addlegendentry{#1}}

\tikzset{every mark/.append style={solid}}
\pgfplotsset{grid=both, width=\columnwidth, try min ticks=5,
	every axis/.append style={font=\small},
	every axis plot/.append style={thick,mark=none,mark size=1.8,tension=0.18},
	legend cell align=left, legend style={fill opacity=0.8},
	xticklabel={\pgfmathprintnumber[assume math mode=true]{\tick}},
	yticklabel={\pgfmathprintnumber[assume math mode=true]{\tick}},
	nodes near coords math/.style={
		nodes near coords={\pgfmathprintnumber[assume math mode=true]{\pgfplotspointmeta}},
	},
}

\pgfplotsset{
	dash/.style={mark=o,dashed,opacity=0.6},
	dott/.style={mark=o,dotted,opacity=0.6},
	nolim/.style={enlargelimits=false},
	plain/.style={every axis plot/.append style={},nolim,grid=none},
}
\newcommand{\kilo}[1]{\thisrow{#1}/1000}

 
\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}{1ex}{-1em}{\normalfont\normalsize\bfseries}}
\makeatother

\usepackage{times}
\usepackage{epsfig}
\usepackage{authblk}
\usepackage{graphicx}
\usepackage[colorlinks]{hyperref}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{xspace}
\usepackage{bm}
\usepackage{array,booktabs}
\usepackage{makecell}
\usepackage{multirow}
\usepackage[normalem]{ulem}
\usepackage{verbatim}
\usepackage{kantlipsum}
\usepackage{wrapfig}
\usepackage{dsfont}
\usepackage{comment}

\usepackage[ruled,vlined,linesnumbered]{algorithm2e}

\usepackage{caption}
\usepackage{subcaption}
\renewcommand\thesubfigure{\roman{subfigure}}
\captionsetup{subrefformat=parens}

\newcommand\blfootnote[1]{\begingroup
  \renewcommand\thefootnote{}\footnote{#1}\addtocounter{footnote}{-1}\endgroup
}

\urlstyle{rm}


\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}
\newcommand{\ewa}[1]{\textcolor{blue}{[E: #1]}}
\newcommand{\sv}[1]{\textcolor{orange}{[S: #1]}}
\newcommand{\bill}[1]{\textcolor{pink}{[B: #1]}}

\newcommand{\printfnsymbol}[1]{\textsuperscript{\@fnsymbol{#1}}}

\iclrfinalcopy \begin{document}



\title{It Takes Two to Tango: \\ Mixup for Deep Metric Learning}

\author{Shashanka Venkataramanan\thanks{equal contribution}  \hspace{1.5em} Bill Psomas  \hspace{1.5em} Ewa Kijak \hspace{1.5em}  Laurent Amsaleg\\
\vspace{-6pt}
Konstantinos Karantzalos\hspace{1.5em} Yannis Avrithis\\
\vspace{6pt}
Inria, Univ Rennes, CNRS, IRISA \hspace{1.5em} Athena RC\\
\vspace{3pt}
National Technical University of Athens\\
}





\maketitle



\newcommand{\head}[1]{{\smallskip\noindent\textbf{#1}}}
\newcommand{\alert}[1]{{\color{red}{#1}}}
\newcommand{\sm}{\scriptsize}
\newcommand{\eq}[1]{(\ref{eq:#1})}

\newcommand{\Th}[1]{\textsc{#1}}
\newcommand{\mr}[2]{\multirow{#1}{*}{#2}}
\newcommand{\mc}[2]{\multicolumn{#1}{c}{#2}}
\newcommand{\tb}[1]{\textbf{#1}}
\newcommand{\ch}{\checkmark}

\newcommand{\red}[1]{{\color{red}{#1}}}
\newcommand{\blue}[1]{{\color{blue}{#1}}}
\newcommand{\green}[1]{\color{green}{#1}}
\newcommand{\gray}[1]{{\color{gray}{#1}}}

\newcommand{\citeme}[1]{\red{[XX]}}
\newcommand{\refme}[1]{\red{(XX)}}

\newcommand{\fig}[2][1]{\includegraphics[width=#1\linewidth]{fig/#2}}
\newcommand{\figh}[2][1]{\includegraphics[height=#1\linewidth]{fig/#2}}


\newcommand{\tran}{^\top}
\newcommand{\mtran}{^{-\top}}
\newcommand{\zcol}{\mathbf{0}}
\newcommand{\zrow}{\zcol\tran}

\newcommand{\ind}{\mathbbm{1}}
\newcommand{\expect}{\mathbb{E}}
\newcommand{\nat}{\mathbb{N}}
\newcommand{\zahl}{\mathbb{Z}}
\newcommand{\real}{\mathbb{R}}
\newcommand{\proj}{\mathbb{P}}
\newcommand{\prob}{\operatorname{P}}
\newcommand{\normal}{\mathcal{N}}

\newcommand{\mif}{\textrm{if}\ }
\newcommand{\other}{\textrm{otherwise}}
\newcommand{\minimize}{\textrm{minimize}\ }
\newcommand{\maximize}{\textrm{maximize}\ }
\newcommand{\st}{\textrm{subject\ to}\ }

\newcommand{\id}{\operatorname{id}}
\newcommand{\const}{\operatorname{const}}
\newcommand{\sgn}{\operatorname{sgn}}
\newcommand{\var}{\operatorname{Var}}
\newcommand{\mean}{\operatorname{mean}}
\newcommand{\trace}{\operatorname{tr}}
\newcommand{\diag}{\operatorname{diag}}
\newcommand{\vect}{\operatorname{vec}}
\newcommand{\cov}{\operatorname{cov}}
\newcommand{\sign}{\operatorname{sign}}
\newcommand{\prj}{\operatorname{proj}}

\newcommand{\softmax}{\operatorname{softmax}}
\newcommand{\clip}{\operatorname{clip}}

\newcommand{\defn}{\mathrel{:=}}
\newcommand{\peq}{\mathrel{+\!=}}
\newcommand{\meq}{\mathrel{-\!=}}

\newcommand{\floor}[1]{\left\lfloor{#1}\right\rfloor}
\newcommand{\ceil}[1]{\left\lceil{#1}\right\rceil}
\newcommand{\inner}[1]{\left\langle{#1}\right\rangle}
\newcommand{\norm}[1]{\left\|{#1}\right\|}
\newcommand{\abs}[1]{\left|{#1}\right|}
\newcommand{\frob}[1]{\norm{#1}_F}
\newcommand{\card}[1]{\left|{#1}\right|\xspace}
\newcommand{\diff}{\mathrm{d}}
\newcommand{\der}[3][]{\frac{d^{#1}#2}{d#3^{#1}}}
\newcommand{\pder}[3][]{\frac{\partial^{#1}{#2}}{\partial{#3^{#1}}}}
\newcommand{\ipder}[3][]{\partial^{#1}{#2}/\partial{#3^{#1}}}
\newcommand{\dder}[3]{\frac{\partial^2{#1}}{\partial{#2}\partial{#3}}}

\newcommand{\wb}[1]{\overline{#1}}
\newcommand{\wt}[1]{\widetilde{#1}}

\def\xssp{\hspace{1pt}}
\def\ssp{\hspace{3pt}}
\def\msp{\hspace{5pt}}
\def\lsp{\hspace{12pt}}

\newcommand{\cA}{\mathcal{A}}
\newcommand{\cB}{\mathcal{B}}
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cD}{\mathcal{D}}
\newcommand{\cE}{\mathcal{E}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\cH}{\mathcal{H}}
\newcommand{\cI}{\mathcal{I}}
\newcommand{\cJ}{\mathcal{J}}
\newcommand{\cK}{\mathcal{K}}
\newcommand{\cL}{\mathcal{L}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\cN}{\mathcal{N}}
\newcommand{\cO}{\mathcal{O}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cQ}{\mathcal{Q}}
\newcommand{\cR}{\mathcal{R}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cT}{\mathcal{T}}
\newcommand{\cU}{\mathcal{U}}
\newcommand{\cV}{\mathcal{V}}
\newcommand{\cW}{\mathcal{W}}
\newcommand{\cX}{\mathcal{X}}
\newcommand{\cY}{\mathcal{Y}}
\newcommand{\cZ}{\mathcal{Z}}

\newcommand{\vA}{\mathbf{A}}
\newcommand{\vB}{\mathbf{B}}
\newcommand{\vC}{\mathbf{C}}
\newcommand{\vD}{\mathbf{D}}
\newcommand{\vE}{\mathbf{E}}
\newcommand{\vF}{\mathbf{F}}
\newcommand{\vG}{\mathbf{G}}
\newcommand{\vH}{\mathbf{H}}
\newcommand{\vI}{\mathbf{I}}
\newcommand{\vJ}{\mathbf{J}}
\newcommand{\vK}{\mathbf{K}}
\newcommand{\vL}{\mathbf{L}}
\newcommand{\vM}{\mathbf{M}}
\newcommand{\vN}{\mathbf{N}}
\newcommand{\vO}{\mathbf{O}}
\newcommand{\vP}{\mathbf{P}}
\newcommand{\vQ}{\mathbf{Q}}
\newcommand{\vR}{\mathbf{R}}
\newcommand{\vS}{\mathbf{S}}
\newcommand{\vT}{\mathbf{T}}
\newcommand{\vU}{\mathbf{U}}
\newcommand{\vV}{\mathbf{V}}
\newcommand{\vW}{\mathbf{W}}
\newcommand{\vX}{\mathbf{X}}
\newcommand{\vY}{\mathbf{Y}}
\newcommand{\vZ}{\mathbf{Z}}

\newcommand{\va}{\mathbf{a}}
\newcommand{\vb}{\mathbf{b}}
\newcommand{\vc}{\mathbf{c}}
\newcommand{\vd}{\mathbf{d}}
\newcommand{\ve}{\mathbf{e}}
\newcommand{\vf}{\mathbf{f}}
\newcommand{\vg}{\mathbf{g}}
\newcommand{\vh}{\mathbf{h}}
\newcommand{\vi}{\mathbf{i}}
\newcommand{\vj}{\mathbf{j}}
\newcommand{\vk}{\mathbf{k}}
\newcommand{\vl}{\mathbf{l}}
\newcommand{\vm}{\mathbf{m}}
\newcommand{\vn}{\mathbf{n}}
\newcommand{\vo}{\mathbf{o}}
\newcommand{\vp}{\mathbf{p}}
\newcommand{\vq}{\mathbf{q}}
\newcommand{\vr}{\mathbf{r}}
\newcommand{\Vs}{\mathbf{s}}
\newcommand{\vt}{\mathbf{t}}
\newcommand{\vu}{\mathbf{u}}
\newcommand{\vv}{\mathbf{v}}
\newcommand{\vw}{\mathbf{w}}
\newcommand{\vx}{\mathbf{x}}
\newcommand{\vy}{\mathbf{y}}
\newcommand{\vz}{\mathbf{z}}

\newcommand{\vone}{\mathbf{1}}
\newcommand{\vzero}{\mathbf{0}}

\newcommand{\valpha}{{\boldsymbol{\alpha}}}
\newcommand{\vbeta}{{\boldsymbol{\beta}}}
\newcommand{\vgamma}{{\boldsymbol{\gamma}}}
\newcommand{\vdelta}{{\boldsymbol{\delta}}}
\newcommand{\vepsilon}{{\boldsymbol{\epsilon}}}
\newcommand{\vzeta}{{\boldsymbol{\zeta}}}
\newcommand{\veta}{{\boldsymbol{\eta}}}
\newcommand{\vtheta}{{\boldsymbol{\theta}}}
\newcommand{\viota}{{\boldsymbol{\iota}}}
\newcommand{\vkappa}{{\boldsymbol{\kappa}}}
\newcommand{\vlambda}{{\boldsymbol{\lambda}}}
\newcommand{\vmu}{{\boldsymbol{\mu}}}
\newcommand{\vnu}{{\boldsymbol{\nu}}}
\newcommand{\vxi}{{\boldsymbol{\xi}}}
\newcommand{\vomikron}{{\boldsymbol{\omikron}}}
\newcommand{\vpi}{{\boldsymbol{\pi}}}
\newcommand{\vrho}{{\boldsymbol{\rho}}}
\newcommand{\vsigma}{{\boldsymbol{\sigma}}}
\newcommand{\vtau}{{\boldsymbol{\tau}}}
\newcommand{\vupsilon}{{\boldsymbol{\upsilon}}}
\newcommand{\vphi}{{\boldsymbol{\phi}}}
\newcommand{\vchi}{{\boldsymbol{\chi}}}
\newcommand{\vpsi}{{\boldsymbol{\psi}}}
\newcommand{\vomega}{{\boldsymbol{\omega}}}

\newcommand{\rLambda}{\mathrm{\Lambda}}
\newcommand{\rSigma}{\mathrm{\Sigma}}

\newcommand{\vLambda}{\bm{\rLambda}}
\newcommand{\vSigma}{\bm{\rSigma}}

\makeatletter
\newcommand*\bdot{\mathpalette\bdot@{.7}}
\newcommand*\bdot@[2]{\mathbin{\vcenter{\hbox{\scalebox{#2}{}}}}}
\makeatother

\makeatletter
\DeclareRobustCommand\onedot{\futurelet\@let@token\@onedot}
\def\@onedot{\ifx\@let@token.\else.\null\fi\xspace}

\def\eg{\emph{e.g}\onedot} \def\Eg{\emph{E.g}\onedot}
\def\ie{\emph{i.e}\onedot} \def\Ie{\emph{I.e}\onedot}
\def\cf{\emph{cf}\onedot} \def\Cf{\emph{Cf}\onedot}
\def\etc{\emph{etc}\onedot} \def\vs{\emph{vs}\onedot}
\def\wrt{w.r.t\onedot} \def\dof{d.o.f\onedot} \def\aka{a.k.a\onedot}
\def\etal{\emph{et al}\onedot}
\makeatother
 \newcommand{\cont}{\text{cont}}
\newcommand{\MS}{\text{MS}}
\newcommand{\Pos}{\text{Pos}}

\definecolor{ForestGreen}{RGB}{34,139,34}
\definecolor{Orange}{RGB}{1.0, 0.55, 0.0}
\definecolor{Purple}{RGB}{0.58, 0.44, 0.86}


\newcommand{\mix}{\operatorname{mix}}
\newcommand{\Mix}{\operatorname{Mix}}
\newcommand{\Beta}{\operatorname{Beta}}

\newcommand{\gp}[1]{{\color{ForestGreen}#1}}




\newcommand{\sota}[1]{\red{\textbf{#1}}}
\newcommand{\negative}[1]{\blue{#1}} 
\begin{abstract}


Metric learning involves learning a discriminative representation such that embeddings of similar classes are encouraged to be close, while embeddings of dissimilar classes are pushed far apart. State-of-the-art methods focus mostly on sophisticated loss functions or mining strategies. On the one hand, \emph{metric learning losses} consider two or more examples at a time. On the other hand, modern \emph{data augmentation} methods for \emph{classification} consider two or more examples at a time. The combination of the two ideas is under-studied.

In this work, we aim to bridge this gap and improve representations using \emph{mixup}, which is a powerful data augmentation approach interpolating two or more examples and corresponding target labels at a time. This task is challenging because unlike classification, the loss functions used in metric learning are not additive over examples, so the idea of interpolating target labels is not straightforward. To the best of our knowledge, we are the first to investigate mixing \emph{both} examples and target labels for deep metric learning. We develop a generalized formulation that encompasses existing metric learning loss functions and modify it to accommodate for mixup, introducing \emph{Metric Mix}, or \emph{Metrix}. We also introduce a new metric---\emph{utilization}---to demonstrate that by mixing examples during training, we are exploring areas of the embedding space beyond the training classes, thereby improving representations. To validate the effect of improved representations, we show that mixing inputs, intermediate representations or embeddings along with target labels significantly outperforms state-of-the-art metric learning methods on four benchmark deep metric learning datasets. Code at: \url{https://tinyurl.com/metrix-iclr}.

\end{abstract}

\section{Introduction}
\label{sec:intro}

\begingroup
\setlength{\columnsep}{20pt}\begin{wrapfigure}{r}{7cm}
\centering
\newcommand{\getangle}[3]{\pgfmathanglebetweenpoints{\pgfpointanchor{#2}{center}}{\pgfpointanchor{#3}{center}}
	\global\let#1\pgfmathresult
}
\newcommand{\mixup}[3][]{\coordinate (a0) at ();
	\coordinate (b0) at ();
	\coordinate (a1) at ();
	\coordinate (a2) at ();
	\coordinate (b1) at ();
	\coordinate (b2) at ();
	\getangle{\ang}{a0}{b0}
	\shade[#1,shading angle=\ang+90] (a1)--(a2)--(b1)--(b2)--cycle;
}
\vspace{-18pt}
\begin{tikzpicture}[
	scale=.9,
	a/.style={pt},
	p/.style={pt,green!50!black},
	n/.style={pt,red!60!black},
	m/.style={pt,fill=white,thick},
	thn/.style={draw,ultra thin},
	class/.style={thn,fill opacity=.3},
	mix/.style={thn,fill opacity=.6,rounded corners=3.6pt},
	pn/.style={mix,left color=green,right color=red},
	nn/.style={mix,left color=red,right color=red},
]
\fill[class,shift={(0,0)},rotate=-10] (0,0) ellipse (1.5 and .7);
	\coordinate(a) at (-.1,.3);
	\coordinate(p1) at (-.8,.1);
	\coordinate(p2) at (.9,-.2);

\fill[class,shift={(-.5,3)},rotate=10] (0,0) ellipse (1.3 and .6);
	\coordinate(n1) at (-1,3);
	\coordinate(n2) at (.3,3.2);

\fill[class,shift={(2.8,1.6)},rotate=-70] (0,0) ellipse (1.3 and .8);
	\coordinate(n3) at (2.7,2);
	\coordinate(n4) at (3.3,1);

\coordinate(m1) at ();
	\coordinate(m2) at ();
	\coordinate(m3) at ();
	\coordinate(m4) at ();

\mixup[pn]{p1}{n1}
	\mixup[pn]{p2}{n2}
	\mixup[nn]{n2}{n3}
	\mixup[pn]{p2}{n4}

\draw[semithick]
		(a)--(p1) (a)--(p2)
		(a)--(m1) (a)--(m2) (a)--(m3) (a)--(m4)
		(a)--(n2) (a)--(n3);

\path
		(a) node[a]{}
		(p1)node[p]{} (p2)node[p]{}
		(n1)node[n]{} (n2)node[n]{} (n3)node[n]{} (n4)node[n]{}
		(m1)node[m]{} (m2)node[m]{} (m3)node[m]{} (m4)node[m]{};

\path (4.5,1)
		++(0,-.4) node[a]{} +(.1,0) node[right]{anchor}
		++(0,-.4) node[p]{} +(.1,0) node[right]{positive}
		++(0,-.4) node[n]{} +(.1,0) node[right]{negative}
		++(0,-.4) node[m]{} +(.1,0) node[right]{mixed};

\path (3.4,4.4)
		++(0,-.5) coordinate(c) +(.7,0) node[right]{class}
		++(0,-.5) coordinate(l) +(.7,0) node[right]{label}
		++(0,-.4) coordinate(i) +(.7,0) node[right]{interpolation};
	\fill[class] (c) ellipse (.6 and .2);
	\path (l)
		+(-.45,0) coordinate(l1)
		+( .45,0) coordinate(l2);
	\mixup[pn]{l1}{l2}

\end{tikzpicture}
\caption{\emph{Metrix} ( \emph{Metric Mix}) allows an anchor to interact with positive (same class), negative (different class) and interpolated examples, which also have interpolated labels.}
\vspace{-20pt}
\label{fig:idea}
\end{wrapfigure}


\emph{Classification} is one of the most studied tasks in machine learning and deep learning. It is a common source of pre-trained models for \emph{transfer learning} to other tasks~\citep{donahue2014decaf,ECCV2020_211}. It has been studied under different \emph{supervision settings}~\citep{caron2018deep,sohn2020fixmatch}, \emph{knowledge transfer}~\citep{hinton2015distilling} and \emph{data augmentation}~\citep{cubuk2018autoaugment}, including the recent research on \emph{mixup}~\citep{zhang2018mixup,verma2019manifold}, where embeddings and labels are interpolated.

\emph{Deep metric learning} is about learning from pairwise interactions such that inference relies on instance embeddings, \eg for \emph{nearest neighbor classification}~\citep{oh2016deep}, \emph{instance-level retrieval}~\citep{gordo2016deep}, \emph{few-shot learning}~\citep{vinyals2016matching}, \emph{face recognition}~\citep{ facenet} and \emph{semantic textual similarity}~\citep{ReGu19}.

\endgroup

Following~\citep{xing2002distance}, it is most often fully supervised by one class label per example, like classification. The two most studied problems are \emph{loss functions}~\citep{musgrave2020metric} and \emph{hard example mining}~\citep{sampling_matters, robinson2020contrastive}. Tuple-based losses with example weighting~\citep{wang2019multi} can play the role of both.

Unlike classification, classes (and distributions) at training and inference are different in metric learning. Thus, one might expect interpolation-based data augmentation like mixup to be even more important in metric learning than in classification. Yet, recent attempts are mostly limited to special cases of embedding interpolation and have trouble with label interpolation~\citep{ko2020embedding}. This raises the question: \emph{what is a proper way to define and interpolate labels for metric learning?}

In this work, we observe that metric learning is not different from classification, where examples are replaced by pairs of examples and class labels by ``positive'' or ``negative'', according to whether class labels of individual examples are the same or not.  The positive or negative label of an example, or a pair, is determined in relation to a given example which is called an \emph{anchor}. Then, as shown in \autoref{fig:idea}, a straightforward way is to use a \emph{binary} (two class) label per pair and interpolate it linearly as in standard mixup. We call our method \emph{Metric Mix}, or \emph{Metrix} for short.

To show that mixing examples improves representation learning, we quantitatively measure the properties of the test distributions using \emph{alignment} and \emph{uniformity}~\citep{wang2020understanding}. \emph{Alignment} measures the clustering quality and \emph{uniformity} measures its distribution over the embedding space; a well clustered and uniformly spread distribution indicates higher representation quality. We also introduce a new metric, \emph{utilization}, to measure the extent to which a test example, seen as a query, lies near any of the training examples, clean or mixed. By quantitatively measuring these three metrics, we show that interpolation-based data augmentation like mixup is very important in metric learning, given the difference between distributions at training and inference.


In summary, we make the following contributions:
\begin{enumerate}[itemsep=4pt, parsep=0pt, topsep=0pt,labelwidth=20pt,leftmargin=20pt]
	\item We define a generic way of representing and interpolating labels, which allows straightforward extension of any kind of mixup to deep metric learning for a large class of loss functions. We develop our method on a generic formulation that encapsulates these functions (\autoref{sec:method}).
	\item We define the ``positivity'' of a mixed example and we study precisely how it increases as a function of the interpolation factor, both in theory and empirically (\autoref{sec:analysis}).
	\item We systematically evaluate mixup for deep metric learning under different settings, including mixup at different representation levels (input/manifold), mixup of different pairs of examples (anchors/positives/negatives), loss functions and hard example mining (\autoref{sec:exp_result}).
	\item We introduce a new evaluation metric, \emph{utilization}, validating that a representation more appropriate for test classes is implicitly learned during exploration of the embedding space in the presence of mixup (\autoref{sec:discussion}). 
	\item We improve the state of the art on four common metric learning benchmarks (\autoref{sec:exp_result}).
\end{enumerate} \section{Related Work}
\label{sec:related}

\paragraph{Metric learning}

Metric learning aims to learn a metric such that \emph{positive} pairs of examples are nearby and \emph{negative} ones are far away.
In \emph{deep metric learning}, we learn an explicit non-linear mapping from raw input to a low-dimensional \emph{embedding space}~\citep{oh2016deep}, where the Euclidean distance has the desired properties. Although learning can be unsupervised~\citep{hadsell2006dimensionality}, deep metric learning has mostly followed the supervised approach, where positive and negative pairs are defined as having the same or different class label, respectively~\citep{xing2002distance}.

Loss functions can be distinguished into pair-based and proxy-based~\citep{musgrave2020metric}. \emph{Pair-based} losses use pairs of examples \citep{sampling_matters, hadsell2006dimensionality}, which can be defined over triplets \citep{WSL+14, facenet, weinberger2009distance, hermans2017defense}, quadruples~\citep{quadruplet} or tuples \citep{sohn2016improved, oh2016deep, wang2019multi}. \emph{Proxy-based} losses use one or more proxies per class, which are learnable parameters in the embedding space~\citep{movshovitz2017no, qian2019softtriple, kim2020proxy, teh2020proxynca++, zhu2020fewer}. Pair-based losses capture data-to-data relations, but they are sensitive to noisy labels and outliers. They often involve terms where given constraints are satisfied, which produce zero gradients and do not contribute to training. This necessitates \emph{mining} of hard examples that violate the constraints, like semi-hard~\citep{facenet} and distance weighted~\citep{sampling_matters}. By contrast, proxy-based losses use data-to-proxy relations, assuming proxies can capture the global structure of the embedding space. They involve less computations that are more likely to produce nonzero gradient, hence have less or no dependence on mining and converge faster.


\paragraph{Mixup}

\emph{Input mixup}~\citep{zhang2018mixup} linearly interpolates between two or more examples in the input space for data augmentation. Numerous variants take advantage of the structure of the input space to interpolate non-linearly, \eg for images~\citep{yun2019cutmix, kim2020puzzle, kim2021co, hendrycks2019augmix,devries2017improved, qin2020resizemix, uddin2020saliencymix}. \emph{Manifold mixup}~\citep{verma2019manifold} interpolates intermediate representations instead, where the structure is learned. This can be applied to or assisted by decoding back to the input space~\citep{berthelot2018understanding,LZK+18,beckham2019adversarial,zhu2020automix,venkataramanan2021alignmix}. In both cases, corresponding labels are linearly interpolated too. Most studies are limited to cross-entropy loss for classification. Pairwise loss functions have been under-studied, as discussed below.

\paragraph{Interpolation for pairwise loss functions}

As discussed in \autoref{sec:mixup}, interpolating target labels is not straightforward in pairwise loss functions.  In \emph{deep metric learning}, \emph{embedding expansion}~\citep{ko2020embedding}, HDML~\citep{zheng2019hardness} and \emph{symmetrical synthesis}~\citep{gu2020symmetrical} interpolate pairs of embeddings in a deterministic way within the same class, applying to pair-based losses, while \emph{proxy synthesis}~\citep{gu2021proxy} interpolates between classes, applying to proxy-based losses. None performs label interpolation, which means that~\citep{gu2021proxy} risks synthesizing false negatives when the interpolation factor  is close to  or .

In \emph{contrastive representation learning}, MoCHi~\citep{kalantidis2020hard} interpolates anchor with negative embeddings but not labels and chooses  to avoid false negatives. This resembles thresholding of  at  in OptTransMix~\citep{zhu2020automix}. Finally, \emph{i-mix}~\citep{LZS+21} and MixCo~\citep{kim2020mixco} interpolate pairs of anchor embeddings as well as their (virtual) class labels linearly. There is only one positive, while all negatives are clean, so it cannot take advantage of interpolation for relative weighting of positives/negatives per anchor~\citep{wang2019multi}.

By contrast, Metrix is developed for deep metric learning and applies to a large class of both pair-based and proxy-based losses. It can interpolate inputs, intermediate features or embeddings of anchors, (multiple) positives or negatives \emph{and} the corresponding two-class (positive/negative) labels per anchor, such that relative weighting of positives/negatives  depends on interpolation. \section{Mixup for metric learning}
\label{sec:method}



\subsection{Preliminaries}
\label{sec:prelim}

\paragraph{Problem formulation}

We are given a training set , where  is the input space. For each \emph{anchor} , we are also given a set  of \emph{positives} and a set  of \emph{negatives}. The positives are typically examples that belong to the same class as the anchor, while negatives belong to a different class. The objective is to train the parameters  of a model  that maps input examples to a -dimensional \emph{embedding}, such that positives are close to the anchor and negatives are far away in the embedding space. Given two examples , we denote by  the \emph{similarity} between  in the embedding space, typically a decreasing function of Euclidean distance.  It is common to -normalize embeddings and define , which is the \emph{cosine similarity}. To simplify notation, we drop the dependence of  on .



\emph{Pair-based} losses \citep{hadsell2006dimensionality, WSL+14, oh2016deep, wang2019multi} use both anchors and positives/negatives in , as discussed above. \emph{Proxy-based} losses define one or more learnable \emph{proxies}  per class, and only use proxies as anchors~\citep{kim2020proxy} or as positives/negatives~\citep{movshovitz2017no, qian2019softtriple, teh2020proxynca++}. To accommodate for uniform exposition, we extend the definition of similarity as  for  (proxy anchors) and  for  (proxy positives/negatives). Finally, to accommodate for mixed embeddings in \autoref{sec:idea}, we define  for . 
Thus, we define  over pairs of either inputs in  or embeddings in . We discuss a few representative loss functions below, before deriving a generic form.



\paragraph{Contrastive}

The contrastive loss~\citep{hadsell2006dimensionality} encourages positive examples to be pulled towards the anchor and negative examples to be pushed away by a margin . This loss is \emph{additive} over positives and negatives, defined as:


\paragraph{Multi-Similarity}

The multi-similarity loss~\citep{wang2019multi} introduces \emph{relative weighting} to encourage positives (negatives) that are farthest from (closest to) the anchor to be pulled towards (pushed away from) the anchor by a higher weight. This loss is \emph{not} additive over positives and negatives:

Here,  are scaling factors for positives, negatives respectively.

\paragraph{Proxy Anchor}

The proxy anchor loss~\citep{kim2020proxy} defines a learnable \emph{proxy} in  for each class and only uses proxies as anchors. For a given anchor (proxy) , the loss has the same form as~\eq{MS}, although similarity  is evaluated on .



\subsection{Generic loss formulation}
\label{sec:frame}

We observe that both additive~\eq{contr} and non-additive~\eq{MS} loss functions involve a sum over positives  and a sum over negatives . They also involve a decreasing function of similarity  for each positive  and an increasing function of similarity  for each negative . Let us denote by  this function for positives, negatives respectively. Then, non-additive functions differ from additive by the use of a nonlinear function  on positive and negative terms respectively, as well as possibly another nonlinear function  on their sum:

With the appropriate choice for , this definition encompasses contrastive~\eq{contr}, multi-similarity~\eq{MS} or proxy-anchor as well as many pair-based or proxy-based loss functions, as shown in \autoref{tab:losses}. It does not encompass the \emph{triplet loss}~\citep{WSL+14}, which operates on pairs of positives and negatives, forming triplets with the anchor. The triplet loss is the most challenging in terms of mining because there is a very large number of pairs and only few contribute to the loss. We only use function  to accommodate for \emph{lifted structure}~\citep{oh2016deep,hermans2017defense}, where  is reminiscent of the triplet loss. We observe that multi-similarity~\citep{wang2019multi} differs from \emph{binomial deviance}~\citep{deviance} only in the weights of the positive and negative terms. Proxy anchor~\citep{kim2020proxy} is a proxy version of multi-similarity~\citep{wang2019multi} on anchors and ProxyNCA~\citep{movshovitz2017no} is a proxy version of NCA~\citep{GRHS05} on positives/negatives.

This generic formulation highlights the components of the loss functions that are additive over positives/negatives and paves the way towards incorporating mixup.

\begin{table}
\scriptsize
\centering
\def\tabcolsep{3pt}
\begin{tabular}{lccccccc}
\toprule
\Th{Loss}                                    & \Th{Anchor} & \Th{Pos/Neg} &    &                &                 &           &           \\ \midrule
Contrastive~\citep{hadsell2006dimensionality} &          &           &          &                          &                           &               &          \\
Lifted structure~\citep{hermans2017defense}   &          &           &      &                    &                     &           &          \\
Binomial deviance~\citep{deviance}            &          &           &          &                  &                   &  &  \\
Multi-similarity~\citep{wang2019multi}        &          &           &          &  &  &  &  \\
Proxy anchor~\citep{kim2020proxy}             & proxy       &           &          &  &  &  &  \\
NCA~\citep{GRHS05}                            &          &           &          &                   &                     &              &              \\
ProxyNCA~\citep{movshovitz2017no}             &          & proxy        &          &                   &                     &              &              \\
ProxyNCA~\citep{teh2020proxynca++}        &          & proxy        &          &                   &                     &              &  \\

\bottomrule
\end{tabular}

\caption{Loss functions. Anchor/positive/negative: : embedding of input example from training set  by ; proxy: learnable parameter in  ;  : temperature. All loss functions are encompassed by~\eq{generic} using the appropriate definition of functions  as given here.}
\label{tab:losses}
\vspace{-10pt}
\end{table}




\subsection{Improving representations using mixup}
\label{sec:mixup}

To improve the learned representations, we follow~\citep{zhang2018mixup, verma2019manifold} in mixing inputs and features from intermediate network layers, respectively. Both are developed for classification.

\emph{Input mixup}~\citep{zhang2018mixup} augments data by linear interpolation between a pair of input examples. Given two examples  we draw  as \emph{interpolation factor} and mix  with  using the standard mixup operation .

\emph{Manifold mixup}~\citep{verma2019manifold} linearly interpolates between intermediate representations (features) of the network instead. Referring to 2D images, we define 
as the mapping from the input to intermediate layer  of the network and  as the mapping from intermediate layer  to the embedding, where  is the number of channels (feature dimensions) and  is the spatial resolution. Thus, our model  can be expressed as the composition . 

For manifold mixup, we follow~\citep{venkataramanan2021alignmix} and mix either features of intermediate layer  or the final embeddings. Thus, we define three \emph{mixup types} in total:

Function  performs both mixup and embedding. We explore different mixup types in \autoref{sec:ablation} of the Appendix. 




\subsection{Label representation}
\label{sec:labels}

\paragraph{Classification}

In supervised classification, each example  is assigned an one-hot encoded label , where  is the number of classes. Label vectors are also linearly interpolated: given two labeled examples , the interpolated label is . The loss (cross-entropy) is a continuous function of the label vector. We extend this idea to metric learning.

\paragraph{Metric learning}

Positives  and negatives  of anchor  are defined as having the same or different class label as the anchor, respectively. To every example in , we assign a binary (two-class) label , such that  for positives and  for negatives:
\

Thus, we represent both positives and negatives by . We now rewrite the generic loss function~\eq{generic} as:

Here, every labeled example  in  appears in both positive and negative terms. However, because label  is binary, only one of the two contributions is nonzero. Now, in the presence of mixup, we can linearly interpolate labels exactly as in classification.



\subsection{Mixed loss function}
\label{sec:idea}

\paragraph{Mixup}

For every anchor , we are given a set  of pairs of examples to mix. This is a subset of  where . 
That is, we allow mixing between positive-negative, positive-positive and negative-negative pairs, where the anchor itself is also seen as positive. We define the possible choices of \emph{mixing pairs}  in \autoref{sec:exp-set} and we assess them in \autoref{sec:ablation} of the Appendix. Let  be the set of corresponding \emph{labeled mixed embeddings}

where  is defined by~\eq{mix-embed}. With these definitions in place, the generic loss function  over mixed examples takes exactly the same form as~\eq{loss-labels}, with only  replaced by :

where similarity  is evaluated on  for pair-based losses and on  for proxy anchor. Now, every labeled embedding () in  appears in both positive and negative terms and \emph{both} contributions are nonzero for positive-negative pairs, because after interpolation, .

\paragraph{Error function}

Parameters  are learned by minimizing the error function, which is a linear combination of the \emph{clean loss}~\eq{generic} and the \emph{mixed loss}~\eq{loss-mixed}, averaged over all anchors

where  is the \emph{mixing strength}. At least for manifold mixup, this combination comes at little additional cost, since clean embeddings are readily available.



\subsection{Analysis: Mixed embeddings and positivity}
\label{sec:analysis}

Let  be the event that a mixed embedding  behaves as ``positive'' for anchor , \ie, minimizing the loss  will increase the similarity . In \autoref{sec:app-analysis} of the Appendix, we explain that this ``positivity'' is equivalent to . Under positive-negative mixing, \ie, , we then estimate the probability of  as a function of  in the case of multi-similarity~\eq{MS} with a single mixed embedding :

where  is the CDF of similarities  between anchors  and mixed embeddings  with interpolation factor . In \autoref{fig:gradient-plot}, we measure the probability of  as a function of  in two ways, both purely empirically and theoretically by~\eq{prob}. Both measurements are increasing functions of  of sigmoidal shape, where a mixed embedding is mostly positive for  close to  and mostly negative for  close to .




 \section{Experiments}
\label{sec:exp}





\begingroup
\setlength{\columnsep}{16pt}














\subsection{Setup}
\label{sec:exp-set}



\paragraph{Datasets}

We experiment on Caltech-UCSD Birds (CUB200)~\citep{cub}, Stanford Cars (Cars196)~\citep{cars}, Stanford Online Products (SOP)~\citep{oh2016deep} and In-Shop Clothing retrieval (In-Shop)~\citep{deepfashion} image datasets. More details are in \autoref{sec:app-exp_setup}.

\paragraph{Network, features and embeddings}

We use Resnet-50~\citep{he2016deep} (R-50) pretrained on ImageNet~\citep{russakovsky2015imagenet} as a backbone network. We obtain the intermediate representation (\emph{feature}), a  tensor, from the last convolutional layer. Following~\citep{kim2020proxy}, we combine adaptive average pooling with max pooling, followed by a fully-connected layer to obtain the \emph{embedding} of  dimensions.

\paragraph{Loss functions}

We reproduce \emph{contrastive} (Cont)~\citep{hadsell2006dimensionality}, \emph{multi-similarity} (MS)~\citep{wang2019multi}, \emph{proxy anchor} (PA)~\citep{kim2020proxy} and \emph{ProxyNCA++}~\citep{teh2020proxynca++} and we evaluate them under different mixup types. For MS~\eq{MS}, following \cite{musgrave2020metric}, we use ,  and . For PA, we use  and , as reported by the authors.
Details on training are in \autoref{sec:app-exp_setup} of the Appendix.



\paragraph{Methods}

We compare our method, \emph{Metrix}, with \emph{proxy synthesis} (PS)~\citep{gu2021proxy}, \emph{i-mix}~\citep{LZS+21} and MoCHi~\citep{kalantidis2020hard}. For PS, we adapt the official code\footnote{\url{https://github.com/navervision/proxy-synthesis}} to PA on all datasets, and use it with PA only, because it is designed for proxy-based losses. PS has been shown superior to \citep{ko2020embedding, gu2020symmetrical}, although in different networks. MoCHi and \emph{i-mix} are meant for contrastive representation learning. We evaluate using Recall@~\citep{oh2016deep}: For each test example taken as a query, we find its -nearest neighbors in the test set excluding itself in the embedding space. We assign a score of  if an example of the same class is contained in the neighbors and  otherwise. Recall@ is the average of this score over the test set.

\begin{wrapfigure}{r}{7cm}
\centering
\vspace{-20pt}
\begin{tikzpicture}
\begin{axis}[
	title={},
	xlabel={},
	ylabel={},
	width=7cm, height=5cm,
xmin=0.0, xmax=1.0,
	ymin=0.0, ymax=1.0,
legend pos=south east,
	legend columns=1,
	ymajorgrids=true,
	grid,
]
	\addplot[red,mark=*]coordinates {
		(0.0,0.0)(0.1, 0.01)(0.2, 0.03)(0.3, 0.1)(0.4, 0.22)(0.5, 0.55)(0.6, 0.79)(0.7, 0.9)(0.8, 1.0)(0.9, 1.0)(1.0,1.0)
		}; \leg{empirical}
	\addplot[blue,mark=*]coordinates {
		(0.0,0.0)(0.1, 0.01)(0.2, 0.07)(0.3, 0.16)(0.4, 0.37)(0.5, 0.49)(0.6, 0.70)(0.7, 0.73)(0.8, 0.88)(0.9, 0.99)(1.0,1.0)
		}; \leg{theoretical}
\end{axis}
\end{tikzpicture}
\vspace{-6pt}
\caption{\emph{``Positivity'' of mixed embeddings \vs }. We measure  empirically as  and theoretically by~\eq{prob}, where  is again measured from data. We use embedding mixup on MS~\eq{MS} on CUB200 at epoch , based on the setup of \autoref{sec:exp-set}.}
\vspace{-6pt}
\label{fig:gradient-plot}
\end{wrapfigure}



\paragraph{Mixup settings}

For input mixup, we use the  \emph{hardest negative} examples for each anchor (each example in the batch) and mix them with positives or with the anchor. We use  by default. For manifold mixup, we focus on the \emph{last} few layers instead, where features and embeddings are compact, and we mix all pairs. We use feature mixup by default and call it \emph{Metrix/feature} or just \emph{Metrix}, while input and embedding mixup are called \emph{Metrix/input} and \emph{Metrix/embed}, respectively. For all mixup types, we use clean examples as anchors and we define a set  of pairs of examples to mix for each anchor , with their labels (positive or negative). By default, we mix positive-negative or anchor-negative pairs, by choosing uniformly at random between  and ,
respectively, where  is replaced by hard negatives only for input mixup. More details are in \autoref{sec:mixup-set}.



 \subsection{Results}
\label{sec:exp_result}

\paragraph{Improving the state of the art}

As shown in \autoref{tab:metric_r50_512}, Metrix consistently improves the performance of all baseline losses (Cont, MS, PA, ProxyNCA++) across all datasets. More results in \autoref{sec:app-exp_result} of the Appendix reveal that the same is true for Metrix/input and Metrix/embed too. Surprisingly, MS outperforms PA and ProxyNCA++ under mixup on all datasets but SOP, where the three losses are on par. This is despite the fact that baseline PA outperforms MS on CUB200 and Cars-196, while ProxyNCA++ outperforms MS on SOP and In-Shop. Both contrastive and MS are significantly improved by mixup. By contrast, improvements on PA and ProxyNCA++ are marginal, which may be due to the already strong performance of PA, or further improvement is possible by employing different mixup methods that take advantage of the image structure.

\begin{table}
\centering
\scriptsize
\setlength{\tabcolsep}{3pt}
\begin{tabular}{lccc|ccc|ccc|ccc} \toprule
	                                            & \multicolumn{3}{c}{\Th{CUB200}}         & \multicolumn{3}{c}{\Th{Cars196}}        & \multicolumn{3}{c}{\Th{SOP}}            & \multicolumn{3}{c}{\Th{In-Shop}}        \\ \midrule
	\Th{Method}                                 & R@1         & R@2         & R@4         & R@1         & R@2         & R@4         & R@1         & R@10        & R@100       & R@1         & R@10        & R@20        \\ \midrule
	Triplet~\citep{weinberger2009distance}      & 63.5        & 75.6        & 84.4        & 77.3        & 85.4        & 90.8        & 70.5        & 85.6        & 94.3        & 85.3        & 96.6        & 97.8        \\
	LiftedStructure~\citep{oh2016deep}          & 65.9        & 75.8        & 84.5        & 81.4        & 88.3        & 92.4        & 76.1        & 88.6        & 95.2        & 88.6        & 97.6        & 98.4        \\
	ProxyNCA~\citep{movshovitz2017no}           & 65.2        & 75.6        & 83.8        & 81.2        & 87.9        & 92.6        & 73.2        & 87.0        & 94.4        & 86.2        & 95.9        & 97.0        \\
	Margin~\citep{sampling_matters}             & 65.0        & 76.2        & 84.6        & 82.1        & 88.7        & 92.7        & 74.8        & 87.8        & 94.8        & 88.6        & 97.0        & 97.8        \\
	SoftTriple~\citep{qian2019softtriple}       & 67.3        & 77.7        & 86.2        & 86.5        & 91.9        & 95.3        & 79.8        & 91.2        & 96.3        & \tb{91.0}   & 97.6        & 98.3        \\
	D\&C~\citep{sanakoyeu2019divide}      & 65.9        & 76.6        & 84.4        & 84.6        & 90.7        & 94.1        & 75.9        & 88.4        & 94.9        & 85.7        & 95.5        & 96.9        \\
	EPSHN~\citep{xuan2020improved}        & 64.9        & 75.3        & 83.5        & 82.7        & 89.3        & 93.0        & 78.3        & 90.7        & 96.3        & 87.8        & 95.7        & 96.8        \\ \midrule
	Cont~\citep{hadsell2006dimensionality}      & 64.7        & 75.9        & 84.6        & 81.6        & 88.2        & 92.7        & 74.9        & 87.0        & 93.9        & 86.4        & 94.7        & 96.2        \\
	\hspace{3pt} Metrix                      & 67.4        & 77.9        & 85.7        & 85.1        & 91.1        & 94.6        & 77.5        & 89.1        & 95.5        & 89.1        & 95.7        & 97.1        \\
	                                            & \gp{+2.7}   & \gp{+2.0}   & \gp{+1.1}   & \gp{+3.5}   & \gp{+2.9}   & \gp{+1.9}   & \gp{+2.6}   & \gp{+2.1}   & \gp{+1.5}   & \gp{+2.7}   & \gp{+1.0}   & \gp{+0.9}   \\ \midrule
	MS~\citep{wang2019multi}                    & 67.8        & 77.8        & 85.6        & \tb{87.8}   & 92.7        & 95.3        & 76.9        & 89.8	    & 95.9        & 90.1        & 97.6        & 98.4        \\
	\hspace{3pt} Metrix                      & \sota{71.4} & 80.6        & 86.8        & \sota{89.6} & \sota{94.2} & 96.0        & 81.0        & 92.0        & \sota{97.2} & \sota{92.2} & \sota{98.5} & 98.6        \\
	                                            & \gp{+3.6}   & \gp{+2.8}   & \gp{+1.2}   & \gp{+1.8}   & \gp{+1.5}   & \gp{+0.7}   & \gp{+4.1}   & \gp{+2.2}   & \gp{+1.3}   & \gp{+2.1}   & \gp{+0.9}   & \gp{+0.2}   \\ \midrule
	PA~\citep{kim2020proxy}               & \tb{69.7}   & \tb{80.0}   & 87.0        & 87.7        & \tb{92.9}   & \tb{95.8}   & --          & --          & --          & --          & --          & --          \\
	PA~\citep{kim2020proxy}                     & 69.5        & 79.3        & 87.0        & 87.6        & 92.3        & 95.5        & 79.1        & 90.8        & 96.2        & 90.0        & 97.4        & 98.2        \\
	\hspace{3pt} Metrix                      & 71.0        & \sota{81.8} & \sota{88.2} & 89.1        & 93.6        & \sota{96.7} & \sota{81.3} & 91.7        & 96.9        & 91.9        & 98.2        & \sota{98.8} \\
	                                            & \gp{+1.3}   & \gp{+1.8}   & \gp{+1.2}   & \gp{+1.4}   & \gp{+0.7}   & \gp{+0.9}   & \gp{+2.2}   & \gp{+0.9}   & \gp{+0.7}   & \gp{+1.9}   & \gp{+0.8}   & \gp{+0.6}   \\ \midrule
    ProxyNCA++~\citep{teh2020proxynca++}  & 69.0        & 79.8        & 87.3        & 86.5        & 92.5        & 95.7        & \tb{80.7}   & \tb{92.0}   & \tb{96.7}   & 90.4        & \tb{98.1}   & \tb{98.8}   \\
	ProxyNCA++~\citep{teh2020proxynca++}        & 69.1	      & 79.5	    & \tb{87.7}   & 86.6	    & 92.1	      & 95.4        & 80.4        & 91.7        & \tb{96.7}   & 90.2	    & 97.6	      & 98.4        \\
	\hspace{3pt} Metrix                      & 70.4	      & 80.6	    & 88.7        & 88.5	    & 93.4	      & 96.5        & \sota{81.3} & \sota{92.7} & 97.1        & 91.9	    & 98.1	      & 98.8        \\
	                                            & \gp{+1.3}   & \gp{+0.8}   & \gp{+1.0}   & \gp{+1.9}   & \gp{+0.9}   & \gp{+0.8}   & \gp{+0.6}   & \gp{+0.7}   & \gp{+0.4}   & \gp{+1.5}   & \gp{+0.0}   & \gp{+0.0}   \\ \midrule	                                           
	Gain over SOTA                              & \gp{+1.7}   & \gp{+1.8}   & \gp{+0.5}   & \gp{+1.8}   & \gp{+1.3}   & \gp{+0.9}   & \gp{+0.6}   & \gp{+0.7}   & \gp{+0.5}   & \gp{+1.2}   & \gp{+0.4}   & \gp{+0.0}   \\ \bottomrule
\end{tabular}
\caption{\emph{Improving the SOTA with our Metrix} (Metrix/feature) using Resnet-50 with embedding size . R@ (\%): Recall@; higher is better. :  reported by authors. \tb{Bold black}: best  baseline (previous SOTA, one per column). \sota{Red}: Our new SOTA. Gain over SOTA is over best  baseline. MS: Multi-Similarity, PA: Proxy Anchor. Additional results are in ~\autoref{sec:app-exp_result} of the Appendix.}

\label{tab:metric_r50_512}
\vspace{-6pt}
\end{table}



In terms of Recall@1, our MS+Metrix is best overall, improving by  () on CUB200,  () on Cars196,  () on SOP and  () on In-Shop. The same solution sets new state of the art, outperforming the previously best PA by  () on CUB200, MS by  () on Cars196, ProxyNCA by  () on SOP and SoftTriple by  () on In-Shop. Importantly, while the previous state of the art comes from a different loss per dataset, MS+Metrix is almost consistently best across all datasets.



\paragraph{Alternative mixing methods}

In \autoref{tab:compete}, we compare Metrix/input with -Mix~\citep{LZS+21} and Metrix/embed with MoCHi~\citep{kalantidis2020hard} using contrastive loss, and with PS~\citep{gu2021proxy} using PA. MoCHi and PS mix embeddings only, while labels are always negative. For -Mix, we mix anchor-negative pairs (). For MoCHi, the anchor is clean and we mix negative-negative () and anchor-negative () pairs, where  is replaced by  hardest negatives and  for anchor-negative. PS mixes embeddings of different classes and treats them as new classes. For clean anchors, this corresponds to positive-negative () and negative-negative () pairs, but PS also supports mixed anchors.

In terms of Recall@1, Metrix/input outperforms -Mix with anchor-negative pairs by  () on CUB200,  () on Cars196,  () and  () on In-Shop. Metrix/embed outperforms MoCHI with anchor-negative pairs by  () on CUB200,  () on Cars196,  () and  () on In-Shop. The gain over MoCHi with negative-negative pairs is significantly higher. Metrix/embed also outperforms PS by  () on CUB200,  () on Cars196,  () on SOP and  () on In-Shop.

\paragraph{Computational complexity} We study the computational complexity of Metrix in~\autoref{sec:app-exp_result}.

\paragraph{Ablation study} 

We study the effect of the number  of hard negatives, mixup types (input, feature and embedding), mixing pairs and mixup strength  in ~\autoref{sec:ablation} of the Appendix.
\vspace{-1em}
\subsection{How does mixup improve representations?}
\label{sec:discussion}

We analyze how Metrix improves representation learning, given the difference between distributions at training and inference. As discussed in~\autoref{sec:intro}, since the classes at inference are unseen at training, one might expect interpolation-based data augmentation like mixup to be even more important than in classification. This is so because, by mixing examples during training, we are exploring areas of the embedding space beyond the training classes. We hope that this exploration would possibly lead the model to implicitly learn a representation more appropriate for the test classes, if the distribution of the test classes lies near these areas.
\vspace{-.5em}
\paragraph{Alignment and Uniformity}


In terms of quantitative measures of properties of the training and test distributions, we follow~\cite{wang2020understanding}. This work introduces two measures -- \emph{alignment} and \emph{uniformity} (the lower the better) to be used both as loss functions (on the training set) and as evaluation metrics (on the test set). \emph{Alignment} measures the expected pairwise distance between positive examples in the embedding space. A small value of alignment indicates that the positive examples are clustered together. \emph{Uniformity} measures the (log of the) expected pairwise similarity between all examples regardless of class, using a Gaussian kernel as similarity. A small value of uniformity indicates that the distribution is more uniform over the embedding space, which is particularly relevant to our problem. Meant for contrastive learning,~\citep{wang2020understanding} use the same training and test classes, while in our case they are different.

By training with contrastive loss on CUB200 and then measuring on the test set, we achieve an alignment (lower the better) of 0.28 for contrastive loss, 0.28 for -Mix~\citep{LZS+21} and 0.19 for Metrix/input. MoCHi~\citep{kalantidis2020hard} and Metrix/embed achieve an alignment of 0.19 and 0.17, respectively. We also obtain a uniformity (lower the better) of 2.71 for contrastive loss, 2.13 for -Mix and 3.13 for Metrix/input. The uniformity of MoCHi and Metrix/embed is 3.18 and 3.25, respectively. This indicates that Metrix helps obtain a test distribution that is more uniform over the embedding space, where classes are better clustered and better separated.

\paragraph{Utilization}

The measures proposed by~\citep{wang2020understanding} are limited to a single distribution or dataset, either the training set (as loss functions) or the test set (as evaluation metrics). It is more interesting to measure the extent to which a test example, seen as a query, lies near any of the training examples, clean or mixed. For this, we introduce the measure of \emph{utilization}  of the training set  by the test set  as 
\vspace{-10pt}

Utilization measures the average, over the test set , of the minimum distance of a query  to a training example  in the embedding space of the trained model  (lower is better). A low value of utilization indicates that there are examples in the training set that are similar to test examples. When using mixup, we measure utilization as , where  is the augmented training set including clean and mixed examples over a number of epochs and  remains fixed. Because , we expect , that is, the embedding space is better explored in the presence of mixup. 

By using contrastive loss on CUB200, utilization drops from 0.41 to 0.32 when using Metrix. This indicates that test samples are indeed closer to mixed examples than clean in the embedding space. This validates our hypothesis that a representation more appropriate for test classes is implicitly learned during exploration of the embedding space in the presence of mixup.

\begin{table}
\centering
\scriptsize
\setlength{\tabcolsep}{1.5pt}
\begin{tabular}{lcccc|ccc|ccc|ccc} \toprule
                                                            &                    & \multicolumn{3}{c}{\Th{CUB200}}   & \multicolumn{3}{c}{\Th{Cars196}}   & \multicolumn{3}{c}{\Th{SOP}}              & \multicolumn{3}{c}{\Th{In-Shop}}  \\ \midrule
	\Th{Method}                                              & \Th{Mixing Pairs}  & R@1       & R@2       & R@4       & R@1        & R@2       & R@4       & R@1        & R@10         & R@100        & R@1       & R@10      & R@20     \\ \midrule
	Cont~\citep{hadsell2006dimensionality}                   & --                 & 64.7      & 75.9      & 84.6      & 81.6       & 88.2      & 92.7      & 74.9       & 87.0         & 93.9         & 86.4	  & 94.7      & 96.3        \\
	\hspace{3pt}  -Mix~\citep{LZS+21}                  & anc-neg            & 65.8      & 76.2      & 84.9      & 82.0       & 88.5      & 93.2      & 75.2       & 87.3         & 94.2        & 87.1       & 95.4      & 96.1     \\
	\hspace{3pt}  Metrix/input                            & pos-neg / anc-neg  & 66.3      & 77.1      & 85.2      & 82.9       & 89.3      & 93.7      & 75.8       & 87.8         & 94.6         & 87.7      & 95.9      & 96.5     \\ \cmidrule(r){2-14}
	\hspace{3pt} MoCHi~\citep{kalantidis2020hard}         & neg-neg            & 63.1      & 74.3      & 83.8      & 76.3       & 84.0      & 89.3      & 68.9	    & 83.1	       & 91.8         & 81.8	  & 91.9      & 93.9        \\
	\hspace{3pt} MoCHi~\citep{kalantidis2020hard}         & anc-neg            & 65.2      & 75.8      & 84.2      & 82.5       & 88.0      & 92.9      & 75.8	    & 87.1	       & 94.8         & 87.2	  & 92.8      & 94.9         \\
	\hspace{3pt} Metrix/embed                             & pos-neg / anc-neg  & \tb{66.4} & \tb{77.6} & \tb{85.4} & \tb{83.9}  & \tb{90.3} & \tb{94.1} & \tb{76.7}  & \tb{88.6}    & \tb{95.2}    & \tb{88.4} & \tb{95.4} & \tb{96.9} \\ \midrule
	PA~\citep{kim2020proxy}                                  & --                 & 69.7      & 80.0      & 87.0      & 87.6       & 92.3      & 95.5      & 79.1       & 90.8         & 96.2         & 90.0      & 97.4      & 98.2      \\
	\hspace{3pt} PS~\citep{gu2021proxy}                   & pos-neg / neg-neg  & 70.0      & 79.8      & 87.2      & 87.9       & 92.8      & 95.6      & 79.6       & 90.9         & 96.4         & 90.3      & 97.4      & 98.0      \\
	\hspace{3pt} Metrix/embed                             & pos-neg / anc-neg  & \tb{70.4} & \tb{81.1} & \tb{87.9} & \tb{88.9}  & \tb{93.3} & \tb{96.4} & \tb{80.6}  & \tb{91.7}    & \tb{96.6}    & \tb{91.6} & \tb{98.3} & \tb{98.3} \\ \bottomrule
\end{tabular}
\caption{\emph{Comparison of our Metrix/embed with other mixing methods} using R-50 with embedding size . R@ (\%): Recall@; higher is better. PA: Proxy Anchor, PS: Proxy Synthesis.}
\label{tab:compete}
\vspace{-10pt}
\end{table}


 
\section{Conclusion}
\label{sec:conclusion}

Based on the argument that metric learning is binary classification of pairs of examples into ``positive'' and ``negative'', we have introduced a direct extension of mixup from classification to metric learning. Our formulation is generic, applying to a large class of loss functions that separate positives from negatives per anchor and involve component functions that are additive over examples. Those are exactly loss functions that require less mining. We contribute a principled way of interpolating labels, such that the interpolation factor affects the relative weighting of positives and negatives. Other than that, our approach is completely agnostic with respect to the mixup method, opening the way to using more advanced mixup methods for metric learning.

We consistently outperform baselines using a number of loss functions on a number of benchmarks and we improve the state of the art using a single loss function on all benchmarks, while previous state of the art was not consistent in this respect. Surprisingly, this loss function, multi-similarity~\cite{wang2019multi}, is not the state of the art without mixup. Because metric learning is about generalizing to unseen classes and distributions, our work may have applications to other such problems, including transfer learning, few-shot learning and continual learning.



\section{Acknowledgement}
\label{sec:acknowledgement}
Shashanka's work was supported by the ANR-19-CE23-0028 MEERQAT project and was performed using the HPC resources from GENCI-IDRIS Grant 2021 AD011011709R1. Bill's work was partially supported by the EU RAMONES project grant No. 101017808 and was performed using the HPC resources from GRNET S.A. project pr011028. This work was partially done when Yannis was at Inria.

 

\bibliography{iclr2022_conference}
\bibliographystyle{iclr2022_conference}


\clearpage


\appendix

\section{More on the method}
\label{sec:app-method}



\subsection{Mixed loss function}
\label{sec:app-idea}

\paragraph{Interpretation}

To better understand the two contributions of a labeled embedding () in  to the positive and negative terms of~\eq{loss-mixed}, consider the case of positive-negative mixing pairs, . Then, for , the mixed label is  and~\eq{loss-mixed} becomes

Thus, the mixed embedding  is both positive (with weight ) and negative (with weight ). Whereas for positive-positive mixing, that is, for , the mixed label is  and the negative term vanishes. Similarly, for negative-negative mixing, that is, for , the mixed label is  and the positive term vanishes.

In the particular case of contrastive~\eq{contr} loss, positive-negative mixing~\eq{loss-posneg} becomes

Similarly, for multi-similarity~\eq{MS},




\subsection{Analysis: Mixed embeddings and positivity}
\label{sec:app-analysis}

\paragraph{Positivity}

Under positive-negative mixing,~\eq{loss-posneg} shows that a mixed embedding  with interpolation factor  behaves as both positive and negative to different extents, depending on : mostly positive for  close to , mostly negative for  close to . The net effect depends on the derivative of the loss with respect to the similarity : if the derivative is negative, then  behaves as positive and vice versa. This is clear from the chain rule

because  is a vector pointing in a direction that makes  more similar and the loss is being minimized. Let  be the event that  behaves as ``positive'', \ie,  and minimizing the loss will increase the similarity .

\paragraph{Multi-similarity}

We estimate the probability of  as a function of  in the case of multi-similarity with a single embedding  obtained by mixing a positive with a negative:

In this case,  occurs if and only if

By letting , this condition is equivalent to

Finally, the probability of  as a function of  is

where  is the CDF of similarities  between anchors  and mixed embeddings  with interpolation factor .

In \autoref{fig:gradient-plot}, we measure the probability of  as a function of  in two ways. First, we measure the derivative  for anchors  and mixed embeddings  over the entire dataset and we report the empirical probability of this derivative being non-positive versus . Second, we measure  theoretically using~\eq{app-prob}, where the CDF of similarities  is again measured empirically for  and  over the dataset, as a function of . Despite the simplifying assumption of a single positive and a single negative in deriving~\eq{app-prob}, we observe that the two measurements agree in general. They are both increasing functions of  of sigmoidal shape, they roughly yield  for  and they confirm that a mixed embedding is mostly positive for  close to  and mostly negative for  close to .

\begin{figure}
\centering
\fig[1]{metrix_utilization}
\caption{Exploring the embedding space when using (a) only clean examples (b) clean and mixed examples. Given a query , the distance  to its nearest training embedding (clean or mixed) is smaller with mixup (b) than without (a).}

\label{fig:utiliz}
\end{figure}

\subsection{More on utilization}
\label{sec:app-utilization}

In~\autoref{sec:discussion}, we discuss that a representation more appropriate for test classes is implicitly learned during exploration of the embedding space in the presence of mixup. We provide an illustration of this exploration in \autoref{fig:utiliz}, where we visualize the embedding space using (a) only clean train examples and (b) clean and mixed train examples. 
In case (a), the model is trained using only clean examples, exploring a smaller area of the embedding space. In case (b), it is trained using both mixed and clean examples, exploring a larger area. It is clear that the distance between a query and its nearest training example (clean or mixup) is smaller in the presence of mixup. Utilization is the average of this distance over the test set. This shows that the model implicitly learns a representation closer the test example in the presence of mixup during training and it partially explains why mixup leads to better performance.



\section{More on experiments}
\label{sec:app-exp}



\subsection{Setup}
\label{sec:app-exp_setup}

\begin{table}
\centering
\scriptsize
\setlength{\tabcolsep}{2.5pt}
\begin{tabular}{lcccc} \toprule
	\Th{Dataset}         & \Th{CUB200}~\citep{cub} & \Th{Cars196}~\citep{cars} & \Th{SOP}~\citep{oh2016deep} & \Th{In-Shop}~\citep{deepfashion} \\ \midrule
	Objects              & birds                  & cars                     & household furniture        & clothes                         \\
	\# classes           &                   &                     &                    &                          \\
	\# training images   &                 &                   &                    &                         \\
	\# testing images    &                 &                   &                    &                         \\ 
	\# training classes  &                   &                      &                    &                           \\
	\# testing classes   &                   &                      &                    &                           \\ \midrule
	sampling             & random                 & random                   & balanced                   & balanced                        \\
	samples per class    & --                     & --                       &                         &                              \\
	classes per batch    &          &            &                        &                             \\ \midrule
	learning rate        &      &        &          &               \\ \bottomrule
\end{tabular}
\vspace{6pt}
\caption{\emph{Statistics and settings} for the four datasets we use in our experiments. : average.}
\label{tab:exp-settings}
\end{table}


\paragraph{Datasets and sampling}

Dataset statistics are summarized in~\autoref{tab:exp-settings}. Since the number of classes is large compared to the batch size in SOP and In-Shop, batches would rarely contain a positive pair when sampled uniformly at random. Hence, we use \emph{balanced sampling}~\citep{zhai2018classification}, \ie, a fixed number of classes and examples per class, as shown in~\autoref{tab:exp-settings}. For fair comparison with baseline methods, images are randomly flipped  and cropped to  at training. At inference, we resize to  and then center-crop to .

\paragraph{Training}

We train R-50 using AdamW~\citep{adamw} optimizer for  epochs with a batch size . The initial learning rate per dataset is shown in \autoref{tab:exp-settings}. The learning rate is decayed by  for Cont and by  for MS and PA on CUB200 and Cars196. For SOP and In-Shop, we decay the learning rate by  for all losses. The weight decay is set to .







\subsection{Mixup settings}
\label{sec:mixup-set}

In mixup for classification, given a batch of  examples, it is standard to form  pairs of examples by pairing the batch with a \emph{random permutation} of itself, resulting in  mixed examples, either for input or manifold mixup. In metric learning, it is common to obtain  embeddings and then use all  pairs of embeddings in computing the loss.
We thus treat mixup types differently.

\paragraph{Input mixup}

Mixing all pairs would be computationally expensive in this case, because we would compute  embeddings. A random permutation would not produce as many hard examples as can be found in all pairs. Thus, for each anchor (each example in the batch), we use the  \emph{hardest negative} examples and mix them with positives or with the anchor. We use  by default.


\paragraph{Manifold mixup}

Originally, manifold mixup~\citep{verma2019manifold} focuses on the \emph{first} few layers of the network. Mixing all pairs would then be even more expensive than input mixup, because intermediate features (tensors) are even larger than input examples. Hence, we focus on the \emph{last} few layers instead, where features and embeddings are compact, and we mix all pairs. We use feature mixup by default and call it \emph{Metrix/feature} or just \emph{Metrix}, while input and embedding mixup are called \emph{Metrix/input} and \emph{Metrix/embed}, respectively. All options are studied in \autoref{sec:ablation}.

\paragraph{Mixing pairs}

Whatever the mixup type, we use clean examples as anchors and we define a set  of pairs of examples to mix for each anchor , with their labels (positive or negative). By default, we mix positive-negative or anchor-negative pairs, according to  and , respectively, where  is replaced by hard negatives only for input mixup. The two options are combined by choosing uniformly at random in each iteration. More options are studied in \autoref{sec:ablation}.

\paragraph{Hyper-parameters}

For any given mixup type or set of mixup pairs, the interpolation factor  is drawn from  with . We empirically set the mixup strength~\eq{loss-final} to  for positive-negative pairs and anchor-negative pairs.



\subsection{More results}
\label{sec:app-exp_result}

\begin{table}
\centering
\scriptsize
\setlength{\tabcolsep}{4pt}
\begin{tabular}{lccc|ccc|ccc|ccc} \toprule
	                                            & \multicolumn{3}{c}{\Th{CUB200}}         & \multicolumn{3}{c}{\Th{Cars196}}        & \multicolumn{3}{c}{\Th{SOP}}            & \multicolumn{3}{c}{\Th{In-Shop}}        \\ \midrule
	Method                                      & 1           & 2           & 4           & 1           & 2           & 4           & 1           & 10          & 100         & 1           & 10          & 20          \\ \midrule
	Triplet~\citep{weinberger2009distance}      & 63.5        & 75.6        & 84.4        & 77.3        & 85.4        & 90.8        & 70.5        & 85.6        & 94.3        & 85.3        & 96.6        & 97.8        \\
	LiftedStructure~\citep{oh2016deep}          & 65.9        & 75.8        & 84.5        & 81.4        & 88.3        & 92.4        & 76.1        & 88.6        & 95.2        & 88.6        & 97.6        & 98.4        \\
	ProxyNCA~\citep{movshovitz2017no}           & 65.2        & 75.6        & 83.8        & 81.2        & 87.9        & 92.6        & 73.2        & 87.0        & 94.4        & 86.2        & 95.9        & 97.0        \\
	Margin~\citep{sampling_matters}             & 65.0        & 76.2        & 84.6        & 82.1        & 88.7        & 92.7        & 74.8        & 87.8        & 94.8        & 88.6        & 97.0        & 97.8        \\
	SoftTriple~\citep{qian2019softtriple}       & 67.3        & 77.7        & 86.2        & 86.5        & 91.9        & 95.3        & 79.8        & 91.2        & 96.3        & \tb{91.0}   & 97.6        & 98.3        \\
	D\&C~\citep{sanakoyeu2019divide}      & 65.9        & 76.6        & 84.4        & 84.6        & 90.7        & 94.1        & 75.9        & 88.4        & 94.9        & 85.7        & 95.5        & 96.9        \\
	EPSHN~\citep{xuan2020improved}        & 64.9        & 75.3        & 83.5        & 82.7        & 89.3        & 93.0        & 78.3        & 90.7        & 96.3        & 87.8        & 95.7        & 96.8        \\
	ProxyNCA++~\citep{teh2020proxynca++}  & 69.0        & 79.8        & \tb{87.3}   & 86.5        & 92.5        & 95.7        & \tb{80.7}   & \tb{92.0}   & \tb{96.7}   & 90.4        & \tb{98.1}   & \tb{98.8}   \\ \midrule
Cont~\citep{hadsell2006dimensionality}      & 64.7        & 75.9        & 84.6        & 81.6        & 88.2        & 92.7        & 74.9        & 87.0        & 93.9        & 86.4        & 94.7        & 96.2        \\
	\hspace{3pt} Metrix/input                & 66.3        & 77.1        & 85.2        & 82.9        & 89.3        & 93.7        & 75.8        & 87.8        & 94.6        & 87.7        & 95.9        & 96.5        \\
	                                            & \gp{+1.6}   & \gp{+1.2}   & \gp{+0.6}   & \gp{+1.3}   & \gp{+1.1}   & \gp{+1.0}   & \gp{+0.9}   & \gp{+0.8}   & \gp{+0.7}   & \gp{+1.3}   & \gp{+1.2}   & \gp{+0.3}   \\
	\hspace{3pt} Metrix                      & 67.4        & 77.9        & 85.7        & 85.1        & 91.1        & 94.6        & 77.5        & 89.1        & 95.5        & 89.1        & 95.7        & 97.1        \\
	                                            & \gp{+2.7}   & \gp{+2.0}   & \gp{+1.1}   & \gp{+3.5}   & \gp{+2.9}   & \gp{+1.9}   & \gp{+2.6}   & \gp{+2.1}   & \gp{+1.5}   & \gp{+2.7}   & \gp{+1.0}   & \gp{+0.9}   \\
	\hspace{3pt} Metrix/embed                & 66.4        & 77.6        & 85.4        & 83.9        & 90.3        & 94.1        & 76.7        & 88.6	    & 95.2        & 88.4        & 95.4        & 96.8        \\
	                                            & \gp{+1.7}   & \gp{+1.7}   & \gp{+0.8}   & \gp{+2.3}   & \gp{+2.1}   & \gp{+1.4}   & \gp{+1.8}   & \gp{+1.6}   & \gp{+1.3}   & \gp{+2.0}   & \gp{+0.7}   & \gp{+0.6}   \\ \midrule
	MS~\citep{wang2019multi}                    & 67.8        & 77.8        & 85.6        & \tb{87.8}   & 92.7        & 95.3        & 76.9        & 89.8	    & 95.9        & 90.1        & 97.6        & 98.4        \\
	\hspace{3pt} Metrix/input                & 69.0        & 79.1        & 86.0        & 89.0        & 93.4        & 96.0        & 77.9        & 90.6	    & 95.9        & 91.8        & 98.0        & 98.9        \\
	                                            & \gp{+1.2}   & \gp{+1.3}   & \gp{+0.4}   & \gp{+1.2}   & \gp{+0.7}   & \gp{+0.7}   & \gp{+1.0}   & \gp{+0.8}   & \gp{+0.0}   & \gp{+1.7}   & \gp{+0.4}   & \gp{+0.5}   \\
	\hspace{3pt} Metrix                      & \sota{71.4} & 80.6        & 86.8        & \sota{89.6} & \sota{94.2} & 96.0        & 81.0        & 92.0        & \sota{97.2} & \sota{92.2} & \sota{98.5} & 98.6        \\
	                                            & \gp{+3.6}   & \gp{+2.8}   & \gp{+1.2}   & \gp{+1.8}   & \gp{+1.5}   & \gp{+0.7}   & \gp{+4.1}   & \gp{+2.2}   & \gp{+1.3}   & \gp{+2.1}   & \gp{+0.9}   & \gp{+0.2}   \\
	\hspace{3pt} Metrix/embed                & 70.2        & 80.4        & 86.7        & 88.8	    & 92.9        & 95.6        & 78.5        & 91.3        & 96.7        & 91.9        & 98.3        & 98.7      \\
	                                            & \gp{+2.4}   & \gp{+2.6}   & \gp{+1.1}   & \gp{+1.0}   & \gp{+0.2}   & \gp{+0.3}   & \gp{+1.6}   & \gp{+1.5}   & \gp{+0.8}   & \gp{+1.8}   & \gp{+0.7}   & \gp{+0.3}   \\ \midrule
	PA~\citep{kim2020proxy}               & \tb{69.7}   & \tb{80.0}   & 87.0        & 87.7        & \tb{92.9}   & \tb{95.8}   & --          & --          & --          & --          & --          & --          \\
	PA~\citep{kim2020proxy}                     & 69.5        & 79.3        & 87.0        & 87.6        & 92.3        & 95.5        & 79.1        & 90.8        & 96.2        & 90.0        & 97.4        & 98.2        \\
	\hspace{3pt} Metrix/input                & 70.5        & 81.2        & 87.8        & 88.2        & 93.2        & 96.2        & 79.8        & 91.4        & 96.5        & 90.9        & 98.1        & 98.4        \\
	                                            & \gp{+0.8}   & \gp{+1.2}   & \gp{+0.8}   & \gp{+0.5}   & \gp{+0.3}   & \gp{+0.4}   & \gp{+0.7}   & \gp{+0.6}   & \gp{+0.3}   & \gp{+0.9}   & \gp{+0.7}   & \gp{+0.2}   \\
	\hspace{3pt} Metrix                      & 71.0        & \sota{81.8} & \sota{88.2} & 89.1        & 93.6        & \sota{96.7} & \sota{81.3} & 91.7        & 96.9        & 91.9        & 98.2        & \sota{98.8} \\
	                                            & \gp{+1.3}   & \gp{+1.8}   & \gp{+1.2}   & \gp{+1.4}   & \gp{+0.7}   & \gp{+0.9}   & \gp{+2.2}   & \gp{+0.9}   & \gp{+0.7}   & \gp{+1.9}   & \gp{+0.8}   & \gp{+0.6}   \\
	\hspace{3pt} Metrix/embed                & 70.4        & 81.1        & 87.9        & 88.9        & 93.3        & 96.4        & 80.6        & 91.7        & 96.6        & 91.6        & 98.3        & 98.3        \\
	                                            & \gp{+0.7}   & \gp{+1.1}   & \gp{+0.9}   & \gp{+1.2}   & \gp{+0.4}   & \gp{+0.6}   & \gp{+1.5}   & \gp{+0.9}   & \gp{+0.4}   & \gp{+1.6}   & \gp{+0.9}   & \gp{+0.1}   \\ \midrule
	                                            
	ProxyNCA++~\citep{teh2020proxynca++}  & 69.0        & 79.8        & 87.3        & 86.5        & 92.5        & 95.7        & \tb{80.7}   & \tb{92.0}   & \tb{96.7}   & 90.4        & \tb{98.1}   & \tb{98.8}   \\ 
	ProxyNCA++~\citep{teh2020proxynca++}        & 69.1	      & 79.5	    & \tb{87.7}   & 86.6	    & 92.1	      & 95.4        & 80.4        & 91.7        & \tb{96.7}   & 90.2	    & 97.6	      & 98.4        \\
	\hspace{3pt} Metrix/input                & 69.7    	  & 79.9      	& 88.3        & 87.5     	& 92.9    	  & 96.0        & 80.9        & 92.2        & 96.9        & 91.4      	& 98.1    	  & 98.8        \\
	                                            & \gp{+0.6}   & \gp{+0.1}   & \gp{+0.6}   & \gp{+0.9}   & \gp{+0.4}   & \gp{+0.3}   & \gp{+0.2}   & \gp{+0.2}   & \gp{+0.2}   & \gp{+1.0}   & \gp{+0.0}   & \gp{+0.0}   \\ 
	\hspace{3pt} Metrix                      & 70.4	      & 80.6	    & 88.7        & 88.5	    & 93.4	      & 96.5        & \sota{81.3} & \sota{92.7} & 97.1        & 91.9	    & 98.1	      & 98.8        \\
	                                            & \gp{+1.3}   & \gp{+0.8}   & \gp{+1.0}   & \gp{+1.9}   & \gp{+0.9}   & \gp{+0.8}   & \gp{+0.6}   & \gp{+0.7}   & \gp{+0.4}   & \gp{+1.5}   & \gp{+0.0}   & \gp{+0.0}   \\
	\hspace{3pt} Metrix/ embed               & 70.2   	  & 80.2      	& 88.2        & 88.1     	& 93.0    	  & 96.2        & 81.1        & 92.4        & 97.0        & 91.6      	& 98.1    	  & 98.8        \\
	                                            & \gp{+1.1}   & \gp{+0.4}   & \gp{+0.5}   & \gp{+1.5}   & \gp{+0.5}   & \gp{+0.5}   & \gp{+0.4}   & \gp{+0.4}   & \gp{+0.3}   & \gp{+1.2}   & \gp{+0.0}   & \gp{+0.0}       \\ \midrule
	                                             
	Gain over SOTA                              & \gp{+1.7}   & \gp{+1.8}   & \gp{+0.5}   & \gp{+1.8}   & \gp{+1.3}   & \gp{+0.9}   & \gp{+0.6}   & \gp{+0.0}   & \gp{+0.5}   & \gp{+1.2}   & \gp{+0.4}   & \gp{+0.0}   \\ \bottomrule
\end{tabular}
\vspace{6pt}
\caption{\emph{Improving the SOTA with our Metrix}  (Metrix/feature) using Resnet-50 with embedding size . R@ (\%): Recall@; higher is better. :  reported by authors. \tb{Bold black}: best baseline (previous SOTA, one per column). \sota{Red}: Our new SOTA.  Gain over SOTA is over best baseline. MS: Multi-Similarity, PA: Proxy Anchor }
\label{tab:app-metric_r50_512}
\end{table}


\paragraph{Computational complexity} 

On CUB200 dataset, using a batch size of  on an NVIDIA RTX 2080 Ti GPU, the average training time in ms/batch is  for MS and  for MS+Metrix. The 39\% increase in complexity is reasonable for 3.6\% increase in R@1. Furthermore, the average training time in ms/batch is   for baseline PA,  for PA+Metrix and  for PS~\citep{gu2021proxy}. While the computation cost of PS is higher than Metrix by 62\%, Metrix outperform PS by 0.4\% and 1.3\%  in terms of R@1 and R@2 respectively (\autoref{tab:compete}). At inference, the computational cost is equal for all methods.

\paragraph{Improving the state of the art}

\autoref{tab:app-metric_r50_512} is an extension of \autoref{tab:metric_r50_512} that includes all three mixup types (input, feature, embedding). It shows that not just feature mixup but \emph{all} mixup types consistently improve the performance of all baseline losses (Cont, MS, PA, ProxyNCA++) across all datasets. It also shows that across all baseline losses and all datasets, feature mixup works best, followed by embedding and input mixup. This result confirms the findings of \autoref{tab:ablation} on Cars196.

\paragraph{Qualitative results of retrieval} 

\autoref{fig:retrieval} shows qualitative results of retrieval on CUB200 using Contrastive loss, with and without mixup. This dataset has large intra-class variations such as pose variation and background clutter. Baseline Contrastive loss may fail to retrieve the correct images due to these challenges. The ranking is improved in the presence of mixup.

\begin{figure}
\centering
\fig[1]{retrieval}
\caption{\emph{Retrieval results} on CUB200 using Contrastive loss, with and without mixup. For each query, the top-5 retrieved images are shown. Images highlighted in green (red) are correctly (incorrectly) retrieved images. 
}
\label{fig:retrieval}
\end{figure}


\paragraph{Visualization of embedding space} 

We visualize CUB200 test examples for 10, 15 and 20 classes in the embedding space using Contrastive loss, with and without mixup in~\autoref{fig:tsne}. We observe that in the presence of mixup, the embeddings are more tightly clustered and more uniformly spread, despite the variations in pose and background in the test set. This finding validates our quantitative analysis of alignment and uniformity in~\autoref{sec:discussion}.

\begin{figure}
\centering
\fig[1]{metrix_tsne}
\caption{\emph{Embedding space visualization} of CUB200 test examples of a given number of classes using Contrastive loss, with and without mixup.
}
\label{fig:tsne}
\end{figure}












\subsection{Ablations}
\label{sec:ablation}

We perform ablations on Cars196 using R-50 with , applying mixup on contrastive loss.



\paragraph{Hard negatives}

We study the effect of the number  of hard negatives using different mixup types. The set of mixing pairs is chosen from (positive-negative, anchor-negative) uniformly at random per iteration. We choose  for input mixup. For feature/embedding mixup, we mix all pairs in a batch by default, but also study . As shown in \autoref{tab:ablation},  for input and all pairs for feature/embedding mixup works best. Still, using few hard negatives for feature/embedding mixup is on par or outperforms input mixup. All choices significantly outperform the baseline.

\paragraph{Mixing pairs}

We study the effect of mixing pairs , in particular,  (positive-positive),  (positive-negative) and  (anchor-negative), again using different mixup types. As shown in \autoref{tab:ablation}, when using a single set of mixing pairs during training, positive-negative and anchor-negative consistently outperform the baseline, while positive-positive is actually outperformed by the baseline. This may be due to the lack of negatives in the mixed loss~\eq{loss-mixed}, despite the presence of negatives in the clean loss~\eq{generic}. Hence, we only use positive-negative and anchor-negative by default, combined by choosing uniformly at random in each iteration.

\paragraph{Mixup types}

We study the effect of mixup type (input, feature, embedding), when used alone. The set of mixing pairs is chosen from (positive-negative, anchor-negative) uniformly at random per iteration. As shown in both ``hard negatives'' and ``mixing pairs'' parts of \autoref{tab:ablation}, our default feature mixup works best, followed by embedding and input mixup. 

\paragraph{Mixup type combinations}

We study the effect of using more than one mixup type (input, feature, embedding), chosen uniformly at random per iteration. The set of mixing pairs is also chosen from (positive-negative, anchor-negative) uniformly at random per iteration. As shown in \autoref{tab:ablation}, mixing inputs, features and embeddings works best. Although this solution outperforms feature mixup alone by  Recall@ (), it is computationally expensive because of using input mixup. The next best efficient choice is mixing features and embeddings, which however is worse than mixing features alone ( \vs ). This is why we chose feature mixup by default.

\begin{table}
\centering
\scriptsize
\setlength{\tabcolsep}{6pt}
\begin{tabular}{lccccccc} \toprule
	\Th{Study}      & \Th{Hard Negatives }       &\Th{Mixing Pairs} &\Th{Mixup Type}           & R@1       & R@2       & R@4       & R@8       \\ \toprule
	baseline        &                               &                  &                          & 81.6      & 88.2      & 92.7      & 95.8      \\ \midrule
	                &                            &pos-neg / anc-neg & input                    & 82.0      & 89.1      & 93.1      & 96.1      \\
	                &                            &pos-neg / anc-neg & input                    & 82.5      & 89.2      & 93.4      & 96.2      \\
	                &                            &pos-neg / anc-neg & input                    & 82.9      & 89.3      & 93.7      & 95.5      \\ \cmidrule(r){2-8}
	                &                           &pos-neg / anc-neg & feature                  & 83.5      & 90.1      & 94.0      & 96.5      \\
	hard negatives  &                           &pos-neg / anc-neg & feature                  & 84.0      & 90.4      & 94.2      & 96.8      \\
	                & all                           &pos-neg / anc-neg & feature                  & \tb{85.1} & \tb{91.1} & \tb{94.6} & \tb{97.0} \\ \cmidrule(r){2-8}
	                &                           &pos-neg / anc-neg & embed                    & 82.7      & 89.2      & 93.4      & 96.1      \\
	                &                           &pos-neg / anc-neg & embed                    & 83.0      & 90.0      & 93.8      & 96.4      \\
	                & all                           &pos-neg / anc-neg & embed                    & 83.4      & 89.9      & 94.1      & 96.4      \\ \midrule
	                & --                            &pos-pos           & input                    & 81.0      & 88.2      & 92.6      & 95.6      \\
	                &                            &pos-neg           & input                    & 82.4      & 89.1      & 93.3      & 95.6      \\
	                &                            &anc-neg           & input                    & 81.8      & 89.0      & 93.6      & 95.4      \\ \cmidrule(r){2-8}
	                & --                            &pos-pos           & feature                  & 81.1      & 88.3      & 92.9      & 95.8      \\
	mixing pairs    & all                           &pos-neg           & feature                  & 84.0      & 90.2      & 94.2      & 96.6      \\
	                & all                           &anc-neg           & feature                  & 83.7      & 90.1      & 94.4      & 96.7      \\ \cmidrule(r){2-8}
	                & --                            &pos-pos           & embed                    & 78.3      & 85.7      & 90.8      & 94.4      \\
	                & all                           &pos-neg           & embed                    & 83.1      & 90.0      & 93.9      & 96.6      \\
	                & all                           &anc-neg           & embed                    & 82.7      & 89.5      & 93.5      & 96.3      \\ \midrule
	                &             &pos-neg / anc-neg &\{input, feature\}        & 83.7      & 94.2      & 95.9      & 96.7      \\
	mixup type      &             &pos-neg / anc-neg &\{input, embed\}          & 83.0      & 90.9      & 94.1      & 96.4      \\
	combinations    &    &pos-neg / anc-neg &\{feature, embed\}        & 84.7      & 90.6      & 94.4      & 96.9      \\
	                &  &pos-neg / anc-neg &\{input, feature, embed\} & \tb{85.3} & \tb{94.9} & \tb{96.2} & \tb{97.1} \\ \bottomrule
\end{tabular}
\vspace{6pt}
\caption{\emph{Ablation study of our Metrix} using contrastive loss and R-50 with embedding size  on Cars196. R@ (\%): Recall@; higher is better.}
\label{tab:ablation}
\end{table}







\paragraph{Mixup strength }

We study the effect of the mixup strength  in the combination of the clean and mixed loss~\eq{loss-final} for different mixup types. As shown in \autoref{fig:ablation-weight}, mixup consistently improves the baseline and the effect of  is small, especially for input and embedding mixup. Feature mixup works best and is slightly more sensitive.

\begin{figure}
\centering
\begin{tikzpicture}
\begin{axis}[
    title={},
    xlabel={mixup strength },
    ylabel={Recall@1},
    width=8cm,height=6cm,
    xmin=0.1, xmax=1.0,
    ymin=79, ymax=90,
legend pos=north east,
    legend columns=2
    ymajorgrids=true,
    grid,
]
\addplot[color=cyan] coordinates {(0.1,81.552) (1.0,81.552) }; \leg{baseline}
\addplot[color=red,mark=*]coordinates {
	(0.1,81.9)(0.2, 82.3)(0.3, 82.8)(0.4, 82.9)(0.5, 82.7)(0.6, 82.3)(0.7, 82.4)(0.8, 82.5)(0.9, 82.5)(1.0, 81.9)}; \leg{input}
\addplot[color=blue,mark=*]coordinates {
	(0.1, 83.2)(0.2, 83.1)(0.3, 83.8)(0.4, 83.5)(0.5, 83.7)(0.6, 83.1)(0.7, 83.4)(0.8, 83.1)(0.9, 83.1)(1.0, 83.0)}; \leg{embedding}
\addplot[color=olive,mark=*]coordinates {
	(0.1, 82.9)(0.2, 83.8)(0.3, 84.2)(0.4, 85.1)(0.5, 85.3)(0.6, 84.9)(0.7, 84.7)(0.8, 84.6)(0.9, 84.6)(1.0, 84.0)}; \leg{feature}
\end{axis}
\end{tikzpicture}
\caption{\emph{Effect of mixup strength} for different mixup types using contrastive loss and R-50 with embedding size  on Cars196. Recall@ (\%): higher is better.}
\label{fig:ablation-weight}
\end{figure}

\paragraph{Ablation on CUB200}
We perform additional ablations on CUB200 using R-50 with  by applying contrastive loss. All results are shown in \autoref{tab:app-ablation-cub}. One may draw the same conclusions as from \autoref{tab:ablation} on Cars196 with , which confirms that our choice of hard negatives and mixup pairs is generalizable across different datasets and embedding sizes.

In particular, following the settings of~\autoref{sec:ablation}, we observe in~\autoref{tab:app-ablation-cub} that using  hard negatives for input mixup and all pairs for feature/embedding mixup achieves the best performance in terms of Recall@1. Similarly, using a single set of mixing pairs, positive-negative and anchor-negative consistently outperform the baseline, whereas positive-positive is inferior than the baseline. Furthermore, combining positive-negative and anchor-negative pairs by choosing uniformly at random in each iteration achieves the best overall performance.

We also study the effect of using more than one mixup type (input, feature,embedding), chosen uniformly at random per iteration. The set of mixing pairs is also chosen from (positive-negative, anchor-negative) uniformly at random per iteration in this study. From~\autoref{tab:app-ablation-cub}, we observe that although mixing input, features and embedding works best with an improvement of  over feature mixup alone (), it is computationally expensive due to using input mixup. The next best choice is mixing features and embeddings, which is worse than using feature mixup alone ( \vs ). This confirms our choice of using feature mixup as default.

\begin{table}[t!]
\centering
\scriptsize
\setlength{\tabcolsep}{6pt}
\begin{tabular}{lccccccc} \toprule
	\Th{Study}      & \Th{Hard Negatives }       & \Th{Mixing Pairs} &\Th{Mixup Type}           & R@1       & R@2       & R@4       & R@8       \\ \toprule
	baseline        &                               &                   &                          & 61.6      & 73.7      & 83.6      & 90.1      \\ \midrule
	                &                            & pos-neg / anc-neg & input                    & 62.4      & 73.9      & 83.0      & 89.7      \\
	                &                            & pos-neg / anc-neg & input                    & 62.7      & 74.2      & \tb{83.6} & 90.0      \\
	                &                            & pos-neg / anc-neg & input                    & 63.1      & 74.5      & 83.5      & 90.3      \\ \cmidrule(r){2-8}
	                &                           & pos-neg / anc-neg & feature                  & 63.9      & 75.0      & 83.9      & 89.9      \\
	hard negatives  &                           & pos-neg / anc-neg & feature                  & 63.5      & 75.2      & 83.5      & 89.8      \\
	                & all                           & pos-neg / anc-neg & feature                  & \tb{64.5} & \tb{75.4} & 84.3      & \tb{90.6} \\ \cmidrule(r){2-8}
	                &                           & pos-neg / anc-neg & embed                    & 63.1      & 74.3      & 83.1      & 90.0      \\
	                &                           & pos-neg / anc-neg & embed                    & 63.5      & 74.7      & 83.6      & 90.1      \\
	                & all                           & pos-neg / anc-neg & embed                    & 64.0      & 75.1      & 84.8      & 90.9      \\ \midrule
	                & --                            & pos-pos           & input                    & 58.7      & 70.7      & 80.1      & 87.1      \\
	                &                            & pos-neg           & input                    & 62.9      & 75.1      & 83.4      & 90.6      \\
	                &                            & anc-neg           & input                    & 62.8      & 74.7      & 83.6      & 90.1      \\ \cmidrule(r){2-8}
	                & --                            & pos-pos           & feature                  & 61.0      & 73.1      & 82.5      & 89.7      \\
	mixing pairs    & all                           & pos-neg           & feature                  & 63.9      & 75.0      & 83.9      & 89.9      \\
	                & all                           & anc-neg           & feature                  & 63.8      & 74.8      & 83.6      & 90.2      \\ \cmidrule(r){2-8}
	                & --                            & pos-pos           & embed                    & 59.7      & 72.2      & 82.7      & 89.5      \\
	                & all                           & pos-neg           & embed                    & 63.8      & 75.1      & 83.3      & 90.5      \\
	                & all                           & anc-neg           & embed                    & 63.5      & 75.0      & 83.9      & 90.5      \\ \midrule
	                &             & pos-neg / anc-neg &\{input, feature\}        & 63.9      & 75.1      & \tb{84.9} & 90.5      \\
	mixup type      &             & pos-neg / anc-neg &\{input, embed\}          & 63.4      & 74.9      & 84.5      & 90.1      \\
	combinations    &    & pos-neg / anc-neg &\{feature, embed\}        & 64.2      & 75.2      & 84.1      & 90.7      \\
	                &  & pos-neg / anc-neg &\{input, feature, embed\} & \tb{65.3} & \tb{76.2} & 84.4      & \tb{91.2} \\ \bottomrule
\end{tabular}
\vspace{6pt}
\caption{\emph{Ablation study of our Metrix} using contrastive loss and R-50 with embedding size  on CUB200. R@ (\%): Recall@; higher is better.}
\label{tab:app-ablation-cub}
\end{table}
%
 
\end{document}
