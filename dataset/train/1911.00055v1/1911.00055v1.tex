\documentclass{article}

\PassOptionsToPackage{numbers, compress}{natbib}


\usepackage[preprint]{neurips_2019}







\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{wrapfig}
\usepackage{multirow}
\usepackage{tabularx}


\usepackage{bm}
\newtheorem{theorem}{Theorem}
\newcommand\raisepunct[1]{\,\mathpunct{\raisebox{0.5ex}{#1}}}
\newlength{\Oldarrayrulewidth}
\usepackage{xcolor}
\usepackage{appendix}

 
\newcommand{\mb}[1]{\mathbf{#1}} 

\makeatletter
\def\thanks#1{\protected@xdef\@thanks{\@thanks
        \protect\footnotetext{#1}}}
\makeatother


\title{DRUM: End-To-End Differentiable Rule Mining On Knowledge Graphs}



\author{
        Ali Sadeghian~\textsuperscript{*1},~\thanks{*Authors contributed equally}
        Mohammadreza Armandpour\textsuperscript{*2},
        Patrick Ding,\textsuperscript{2}
        Daisy Zhe Wang,\textsuperscript{1}
        \\
        \textsuperscript{1} Department of Computer Science, University of Florida
        \\
        \textsuperscript{2} Department of Statistics, Texas A\&M University 
        \\
        \texttt{\{asadeghian, daisyw\}@ufl.edu}, \texttt{\{armand, patrickding\}@stat.tamu.edu}
}


\begin{document}

\maketitle

\begin{abstract}
  In this paper, we study the problem of learning probabilistic logical rules for inductive and interpretable link prediction. Despite the importance of inductive link prediction, most previous works focused on transductive link prediction and cannot manage previously unseen entities. Moreover, they are black-box models that are not easily explainable for humans. We propose DRUM, a scalable and differentiable approach for mining first-order logical rules from knowledge graphs which resolves these problems. We motivate our method by making a connection between learning confidence scores for each rule and low-rank tensor approximation. DRUM uses bidirectional RNNs to share useful information across the tasks of learning rules for different relations. We also empirically demonstrate the efficiency of DRUM over existing rule mining methods for inductive link prediction on a variety of benchmark datasets.
\end{abstract}

\section{Introduction}
\label{sec:intro}

Knowledge bases store structured information about real-world people, locations, companies and governments, etc. Knowledge base construction has attracted the attention of researchers, foundations, industry, and governments \citep{dong2014knowledge, ellis2015overview, suchanek2007yago, vrandevcic2014wikidata}. Nevertheless, even the largest knowledge bases remain incomplete due to the limitations of human knowledge, web corpora, and extraction algorithms. 


Numerous projects have been developed to shorten the gap between KBs and human knowledge. A popular approach is to use the existing elements in the knowledge graph to infer the existence of new ones. There are two prominent directions in this line of research: representation learning that obtains distributed vectors for all entities and relations in the knowledge graph \citep{ebisu2018toruse, schlichtkrull2018modeling,  socher2013reasoning}, and rule mining that uses observed co-occurrences of frequent patterns in the knowledge graph to determine logical rules \citep{chen2016ontological, galarraga2015fast}. An example of knowledge graph completion with logical rules is shown in Figure~\ref{fig:reasoning}. 

One of the main advantages of logic-learning based methods for link prediction is that they can be applied to both transductive and inductive problems while representation learning methods like that of \citet{bordes2013translating,sadeghian2016temporal} and \citet{Yang2015EmbeddingEA} cannot be employed in inductive scenarios. Consider the scenario in Figure~\ref{fig:reasoning}, and suppose that at training time our knowledge base does not contain information about Obama's family.  Representation learning techniques need to be retrained on the whole knowledge base in order to find the answer. In contrast rule mining methods can transfer reasoning to unseen facts.  

Additionally, learning logical rules provides us with interpretable reasoning for predictions which is not the case for the embedding based method. This interpretability can keep humans in the loop, facilitate debugging, and increase user trustworthiness. More importantly, rules allow domain knowledge transfer by enabling the addition of extra rules by experts, a strong advantage over representation learning models in scenarios with little or low-quality data. 

\begin{wrapfigure}{r}{0.5\textwidth}
  \begin{center}
    \includegraphics[width=0.48\textwidth]{sasha_bala3.pdf}
  \end{center}
  \caption{Using logical rules for knowledge base reasoning}
  \vspace{-7pt}
  \label{fig:reasoning}
\end{wrapfigure}

Mining rules have traditionally relied on pre-defined statistical measures such as support and confidence to assess the quality of rules. These are fixed heuristic measures, and are not optimal for various use cases in which one might want to use the rules. For example, using standard confidence is not necessarily optimal for statistical relational learning. Therefore, finding a method that is able to simultaneously learn rule structures as well as appropriate scores is crucial. However, this is a challenging task because the method needs to find an optimal structure in a large discrete space and simultaneously learn proper score values in a continuous space. Most previous approaches address parts of this problem \citep{de2015inducing,kok2007statistical, lao2011random, wang2014structure} but are not able to learn both structure and scores together, with the exception of \citet{yang2017differentiable}.  

In this paper we propose DRUM, a fully differentiable model to learn logical rules and their related confidence scores. DRUM has significant importance because it not only addresses the aforementioned challenges, but also allows gradient based optimization to be employed for inductive logic programming tasks.

Our contributions can be summarized as: 1) An end-to-end differentiable rule mining model that is able to learn rule structures and scores simultaneously; 2) We provide a connection between tensor completion and the estimation of confidence scores; 3) We theoretically show that our formulation is expressive enough at finding the rule structures and their related confidences; 
4) Finally, we demonstrate that our method outperforms previous models on benchmark knowledge bases, both on the link prediction task and in terms of rule quality.

\section{Problem Statement}
\label{sec:problem_statement}

\noindent \textbf{Definitions} \quad We model a knowledge graph as a collection of facts $G=\{(s,r,o)| s,o\in \mathcal{E}, r\in \mathcal{R} \}$, where $\mathcal{E}$ and $\mathcal{R}$ represent the set of entities and relations in the knowledge graph, respectively.

A first order logical rule is of the form $\textbf{B}\Longrightarrow H$, where $\textbf{B} = \bigwedge_i B_i(\cdot \raisepunct{,} \cdot)$ is a conjunction of atoms $B_i$, e.g., $livesIn(\cdot \raisepunct{,} \cdot)$, called the \textit{Body}, and $H$ is a specific predicate called the head. A rule is  \textit{connected} if every atom in the rule shares at least one variable with another atom, and a rule is \textit{closed} if each variable in the rule appears in at least two atoms.

\textbf{Rule Mining} \quad We address the problem of learning first-order logical Horn clauses from a knowledge graph. In particular we are interested in mining closed and connected rules. These assumptions ensure finding meaningful rules that are human understandable. Connectedness also prevents finding rules with unrelated relations.

Formally, we aim to find all $T \in \mathbb{N}$ and relations $B_1, B_2, \cdots, B_T, H$ as well as a \textit{confidence value} $\alpha \in \mathbb{R}$, where:

\begin{equation}
B_1(x, z_1) \land B_2(z_1,z_2) \land \cdots \land B_{\scriptstyle_{T}}(z_{\scriptstyle_{T-1}}, y) \implies H(x,y) \, \, :\alpha,
\end{equation}


where, $z_i$s are variables that can be substituted with entities. This requires searching a discrete space to find $B_i$s and searching a continuous space to learn $\alpha$ for every particular rule. 

\section{Related work}
\label{sec:related_work}


Mining Horn clauses has been previously studied in the Inductive Logic Programming (ILP) field, e.g, FOIL~\cite{quinlan1990learning}, MDIE~\cite{muggleton1995inverse} and Inspire~\cite{schuller2018best}. Given a background knowledge base, ILP provides a framework for learning on multi-relational data. However, despite the strong representation powers of ILP, it requires both positive and negative examples and does not scale to large datasets. This is a huge drawback since most knowledge bases are large and contain only positive facts.

Recent rule mining methods such as AMIE+ \cite{galarraga2015fast} and Ontological Pathfinding~(OP)~\cite{chen2016ontological} use predefined metrics such as confidence and support and take advantage of various parallelization and partitioning techniques to speed up the counting process. However, they still suffer from the inherent limitations of relying on predefined confidence and discrete counting.


Most recent knowledge base rule mining approaches fall under the same category as ILP and OP. However,~\citet{Yang2015EmbeddingEA} show that one can also use graph embeddings to mine rules. They introduce DistMult, a simple bilinear model for learning entity and relation representations. The relation representations learned via the bilinear model can capture compositional relational semantics via matrix multiplications. For example, if the rule $B_1(x,y) \land B_2(y,z) \implies H(x,z)$ holds, then intuitively so should $\mb{A}_{B_1} \mb{A}_{B_2} \approx \mb{A}_{H}$. To mine rules, they use the Frobenius norm to search for all possible pairs of relations with respect to their compositional relevance to each head. In a more recent approach \citet{omran2018scalable} improve this method by leveraging pruning techniques and computing traditional metrics to scale it up to larger knowledge bases.

In~\cite{guu2015traversing} the authors proposed a RESCAL-based model to learn from paths in KGs. More recently, \citet{yang2017differentiable} provide the first fully differentiable rule mining method based on TensorLog \citep{cohen2016tensorlog}, Neural LP. They estimate the graph structure via constructing TensorLog operators per relation using a portion of the knowledge graph. Similar to us, they chain these operators to compute a score for each triplet, and learn rules by maximizing this score. As we explain in Section~\ref{sec:compact_formulation}, this formulation is bounded to a fixed length of rules. To overcome this limitation, Neural LP uses an LSTM and attention mechanisms to learn variable rule lengths. However, it can be implied from Theorem~\ref{thr:theorem_1} that its formulation has theoretical limitations on the rules it can produce.

There are some other interesting works \citep{das2017go, evans2018learning, minervini2018towards, rocktaschel2017end} which learn rules in a differentiable manner. However, they need to learn embeddings for each entity in the graph and they do link prediction not only based on the learned rules but also the embeddings. Therefore we exclude them from our experiment section. 

We did not cover embedding based methods on graphs or knowledge graphs here, we refer the reader to some of the recent works~\cite{hajiramezanali2019variational,hasanzadeh2019semi,kazemi2019relational,goyal2018graph} 

\section{Methodology}
\label{sec:methodology}

To provide intuition about each part of our algorithm we start with a vanilla solution to the problem. We then explain the drawbacks of the this approach and modify the suggested method step-by-step to makes the challenges of the problem more clear and provides insight into different parts of the suggested algorithm.

We begin by defining a one-to-one correspondence between the elements of $\mathcal{E}$ and $\{\mb{v}_1, ..., \mb{v}_n \}$, where $n$ is the number of entities and $\mb{v}_i \in \{0,1\}^n$ is a vector with $1$ at position $i$ and $0$ otherwise.  We also define $\mb{A}_{B_r}$ as the adjacency matrix of the knowledge base with respect to relation $B_r$; the $(i,j)^{\text{th}}$ elements of  $\mb{A}_{B_r}$ equals to $1$ when the entities corresponding to $\mb{v}_i$ and $\mb{v}_j$ have relation $B_r$, and $0$ otherwise.

\subsection{A Compact Differentiable Formulation}
\label{sec:compact_formulation}

To approach this inherently discrete problem in a differentiable manner, we utilize the fact that using the above notations for a pair of entities $(x,y)$ the existence of a chain of atoms such as
\begin{equation}
    B_1(x, z_1) \land B_2(z_1,z_2) \land \cdots \land     
    B_{\scriptstyle_{T}}(z_{\scriptstyle_{T-1}}, y)
\end{equation}

is equivalent to $\mb{v}_x^T \cdot  \mb{A}_{B_{1}} \cdot \mb{A}_{B_{2}} \cdots \mb{A}_{B_{\scriptstyle_{T}}} \cdot \mb{v}_y$ being a positive scalar.

This scalar is equal to the number of paths of length $T$ connecting $x$ to $y$ which traverse relation $B_{r_i}$ at step $i$. It is straightforward to show that for each head relation $H$, one can learn logical rules by finding an appropriate $\bm{\alpha}$ in
\begin{equation}
    \omega_{\scriptstyle_{H}}(\bm{\alpha})\doteq \sum_{s} \alpha_s \prod_{k \in p_s} \mb{A}_{B_k}
\end{equation}
that maximizes
\begin{equation}
    O_{\scriptstyle_{H}}(\bm{\alpha}) \doteq \sum_{(x,H,y) \in KG} \mb{v}_x^T \omega_{\scriptstyle_{H}}(\bm{\alpha}) \mb{v}_y,    
\end{equation}
where $s$ indexes over all potential rules with maximum length of $T$, and $p_s$ is the ordered list of relations related to the rule indexed by $s$.

However, since the number of learnable parameters in $O_{\scriptstyle_{H}}(\bm{\alpha})$ can be exceedingly large, i.e. $\mathcal{O}(|\mathcal{R}|^T)$, and the number of observed pairs $(x,y)$ which satisfy the head $H$ are usually small, direct optimization of $O_{\scriptstyle_{H}}(\bm{\alpha})$ falls in the regime of over-parameterization and cannot provide useful results. To reduce the number of parameters one can rewrite $\omega_{\scriptstyle_{H}}(\bm{\alpha})$ as
\begin{equation}
    \Omega_{\scriptstyle_{H}}(\mb{a}) \doteq \prod_{i=1}^T \sum_{k=1}^{|\mathcal{R}|} a_{i,k} \mb{A}_{B_k}.
\end{equation}
This reformulation significantly reduces the number of parameters to $T \mathcal{R}$.
However, the new formulation can only learn rules with fixed length $T$. To overcome this problem, we propose to modify $\Omega_{\scriptstyle_{H}}(\mb{a})$ to
\begin{equation}
    \Omega^I_{\scriptstyle_{H}}(\mb{a}) \doteq \prod_{i=1}^T (\sum_{k=0}^{|\mathcal{R}|} a_{i,k} \mb{A}_{B_k}),       
\end{equation}
where
we define a new relation $B_0$ with an identity adjacency matrix $A_{B_0} = I_n$. With this change, the expansion of $\Omega^I_{\scriptstyle_{H}}$ includes all possible rule templates of length $T$ or smaller with only $T (|\mathcal{R}|+1)$ free~parameters.

Although $\Omega^I_{\scriptstyle_{H}}$ considers all possible rules lengths, it is still constrained in learning the correct rule confidences. As we will show in the experiments Section~\ref{sec:rule_interpretability}, this formulation (as well as Neural~LP~\cite{yang2017differentiable}) inevitably mines incorrect rules with high confidences. The following theorem provides insight about the restricted expressive power of the rules obtained by $\Omega^I_{\scriptstyle_{H}}$.

\begin{theorem}
\label{thr:theorem_1}
If $R_o$, $R_s$ are two rules of length $T$ obtained by optimizing the objective related to $\Omega^I_{\scriptstyle_{H}}$, with confidence values $\alpha_o, \alpha_s$, then there exists $\ell$ rules of length $T$, $R_1, R_2, \cdots, R_{\ell}$, with confidence values $\alpha_1, \alpha_2, \cdots, \alpha_{\ell}$ such~that:
\begin{align*}
    & d(R_o, R_1) =d(R_{\ell}, R_s)=1 \quad \text{and} \quad  d(R_o, R_s) \leq \ell +1, \\
    & d(R_l, R_{l+1})=1 \quad \text{and} \quad \alpha_l \geq  \min(\alpha_o, \alpha_s) \quad \text{for} \quad 1 \leq l \leq \ell,
\end{align*}
where $d(.,.)$ is a distance between two rules of the same size defined as the number of mismatched atoms in their bodies.
\end{theorem}
\begin{proof} The proof is provided in the appendix.
\end{proof}

To further explain Theorem \ref{thr:theorem_1}, consider an example knowledge base with only two meaningful logical rules of body length $T=3$, i.e. $R_o \text{ and } R_s$ such that they do not share any body atoms. According to Theorem~\ref{thr:theorem_1}, learning these two rules by optimizing $O^I_{\scriptstyle_{H}}(\mb{a})$ leads to learning at \mbox{least~$\ell \geq 2$} other rules, since $d(R_o, R_s)=3$, with confidence values greater than $\min(\alpha_o, \alpha_s)$. This means we inevitably learn at least $2$ additional \textbf{incorrect} rules with substantial confidence~values.

Theorem~\ref{thr:theorem_1} also entails other undesirable issues, for example the resulting list of rules may not have the correct order of importance. More specifically, a rule might have higher confidence value just because it is sharing an atom with another high confidence rule. Thus confidence values are not a direct indicator of rule importance. This reduces the interpretability of the output rules.

We must note that all previous differentiable rule mining methods based on $\Omega_{\scriptstyle_{H}}(\mb{a})$ suffer from this limitation. For example \citet{yang2017differentiable} has this limitation for rules with maximum length. Section~\ref{sec:rule_interpretability} illustrates these drawbacks using examples of mined rules.

\subsection{DRUM}
\label{sec:DRUM}

Recall that the number of confidence values for rules of length $T$ or smaller is $(|\mathcal{R}|+1)^T$. These values can be viewed as entries of a $T$ dimensional tensor where the size of each axis is $|\mathcal{R}|+1$. To be more specific, we put the confidence value of the rule with body $B_{r_1} \land B_{r_2} \land \cdots \land B_{r_T}$ at position $(r_1, r_2,\dots, r_T )$ in the tensor and we call it the \textit{confidence value tensor}. 

It can be shown that the final confidences obtained by expanding $\Omega^I_{\scriptstyle_{H}}(\mb{a})$ are a rank one estimation of the \textit{confidence value tensor}. This interpretation makes the limitation of $\Omega^I_{\scriptstyle_{H}}(\mb{a})$ more clear and provides a natural connection to the tensor estimation literature. Since a low-rank approximation (not just rank one) is a popular method for tensor approximation, we use it to generalize $\Omega^I_{\scriptstyle_{H}}(\mb{a})$. The $\Omega$ related to rank $L$ approximation can be formulated as
\begin{equation}\label{eq:omega}
    \Omega^L_{\scriptstyle_{H}}(\mb{a}, L) \doteq \sum^{L}_{j=1} \{ \prod_{i=1}^T \sum_{k=0}^{|\mathcal{R}|} a_{j,i,k} \mb{A}_{B_k}\}.
\end{equation}

In the following theorem, we show that $\Omega^L_{\scriptstyle_{H}}(\bm{a}, L)$ is powerful enough to learn any set of logical rules, without including unrelated ones.

\begin{theorem}
\label{thr:theorem_2}
For any set of rules $R_1, R_2, \cdots R_r$ and their associated confidence values $\alpha_1, \alpha_2, \cdots, \alpha_r$ there exists an $L^*$, and $\bm{a^*}$, such that:
\[
\Omega^L_{\scriptstyle_{H}}(\bm{a^*}, L^*)=\alpha_1 R_1+\alpha_2 R_2 \cdots + \alpha_r R_r.
\]
\end{theorem}
\begin{proof}
To prove the theorem we will show that one can find a $\mb{a^*}$ for $L^* = r$ such that the requirements are met. Without loss of generality, assume $R_j$ (for some $1\leq j \leq r$) is of length $t_0$ and consists of body atoms $B_{r_1}, B_{r_2}, \cdots, B_{r_{t_0}}$. By setting $a^*_{j,i,k}$ 
\begin{equation*}
  a^*_{j,i,k} =
  \begin{cases}
    \alpha_j \delta_{r_1}\scriptstyle{(k)} & \text{if $i = 1$} \\
    \delta_{r_i}\scriptstyle{(k)} & \text{if $1<i\leq t_0$} \\
    \delta_{0}\scriptstyle{(k)} & \text{if $t_0<i$}
  \end{cases}
\end{equation*}
it is easy to show that $\mb{a^*}$ satisfies the condition in Theorem~\ref{thr:theorem_2}. Let's look at $\Omega^L_{\scriptstyle_{H}}(\mb{a^*}, L^*)$ for each~$j$:
\[
     \prod_{i=1}^T  \sum_{k=1}^{|\mathcal{R}|} a^*_{j,i,k} \mb{A}_{B_k} = 
        \alpha_j \mb{A}_{B_{r_1}}\cdot \mb{A}_{B_{r_2}} \cdots \mb{A}_{B_{r_{t_0}}} \cdot \mb{I}\cdots \mb{I} = 
        \alpha_j R_j.
\]
Therefore $\Omega^L_{\scriptstyle_{H}}(\bm{a^*}, L^*)=\sum \alpha_j R_j$.
\end{proof}



Note the number of learnable parameters in $\Omega^L_{\scriptstyle_{H}}$ is now $LT(|\mathcal{R}|+1)$. However, this is just the number of free parameters for finding the rules for a single head relation, learning the rules for all relations in knowledge graph requires estimating $LT(|\mathcal{R}|+1)\cdot |\mathcal{R}|$ parameters, which is $\mathcal{O}(|\mathcal{R}|^2)$ and can be potentially large. Also, the main problem that we haven't addressed yet, is that direct optimization of the objective related to $\Omega^L_{\scriptstyle_{H}}$ learns parameters of rules for different head relations separately, therefore learning one rule can not help in learning others. 

Before we explain how RNNs can solve this problem, we would like to draw your attention to the fact that some pairs of relations cannot be followed by each other, or have a very low probability of appearing together. Consider the family knowledge base, where the entities are people and the relations are familial ties like \texttt{fatherOf, AuntOf, wifeOf}, etc. If a node in the knowledge graph is \texttt{fatherOf}, it cannot be \texttt{wife\_of} another node because it has to be male. Therefore the relation \texttt{wife\_of} never follows the  relation \texttt{father\_of}. This kind of information can be useful in estimating logical rules for different head relations and can be shared among them.

To incorporate this observation in our model and to alleviate the mentioned problems, we use $L$ bidirectional RNNs to estimate $a_{j,i,k}$ in equation~\ref{eq:omega}:
\begin{align} 
    &\mkern3mu \mb{h}^{(j)}_{i},\mkern3mu \mb{h}^{\prime(j)}_{T-i+1} =\mb{BiRNN}_j(\mb{e}_H,\mkern3mu \mb{h}^{(j)}_{i-1},\mkern3mu \mb{h}^{\prime(j)}_{T-i}), 
    \\ 
    &[a_{j,i,1},\cdots,\mkern3mu  a_{j,i, |\mathcal{R}|+1}] =      f_{\mb{\theta}}([\mkern3mu \mb{h}^{(j)}_{i},\mkern3mu \mb{h}^{\prime^{(j)}}_{T-i+1}]),
\end{align}
where $\mb{h}$ and $\mb{h}^\prime$ are the hidden-states of the forward and backward path RNNs, respectively, both of which are zero initialized. The subindexes of the hidden states denote their time step, and their superindexes identify their bidirectional RNN. $e_H$ is the embedding of the head relation $H$ for which we want to learn a probabilistic logic rule, and $f_{\theta}$ is a fully connected neural network that generates the coefficients from the hidden states of the RNNs.

We use a bidirectional RNN instead of a normal RNN because it is capable of capturing information about both backward and forward order of which the atoms can appear in the rule. In addition, sharing the same set of recurrent networks for all head predicates (for all $\Omega^L_H$) allows information to be shared from one head predicate to another.

\section{Experiments}
\label{sec:experiments}

In this section we evaluate DRUM on statistical relation learning and knowledge base completion. We also empirically assess the quality and interpretability of the learned rules.

We implement our method in TensorFlow~\cite{tensorflow2015-whitepaper} and train on Tesla K40 GPUs. We use ADAM \cite{kingma2014adam} with learning rate and batch size of 0.001 and 64, respectively. We set both the hidden state dimension and head relation vector size to 128. We did gradient clipping for training the RNNs and used LSTMs \cite{hochreiter1997long} for both directions. $f_{\theta}$ is a single layer fully connected. We followed the convention in the existing literature \citep{yang2017differentiable} of splitting the data into three categories of facts, train, and test. The code and the datasets for all the experiments will be publicly available.

\vspace{5pt}

\subsection{Statistical Relation Learning}
\label{sec:srl}


\begin{wraptable}{r}{0.51\textwidth}
\vspace{-20pt}
\caption{Dataset statistics for statistical relation learning}\label{tab:data_stat}
\begin{tabular}{lccc}
\toprule
& \textbf{\#Triplets} & \textbf{\#Relations} & \textbf{\#Entities} \\ 
\midrule
\textbf{Family}  & 28356                & 12                    & 3007               \\
\textbf{UMLS}    & 5960                 & 46                    & 135                \\
\textbf{Kinship} & 9587                 & 25                    & 104                \\
\bottomrule
\end{tabular}
\end{wraptable} 

\textbf{Datasets:} Our experiments were conducted on three different datasets \cite{kok2007statistical}. The Unified Medical Language System (UMLS) consists of biomedical concepts such as drug and disease names and relations between them such as diagnosis and treatment. Kinship contains kinship relationships among members of a Central Australian native tribe. The Family data set contains the bloodline relationships between individuals of multiple families. Statistics about each data set are shown in  Table~\ref{tab:data_stat}.

\vspace{5pt}

\label{sec:drum_vs_rulemining}

We compared DRUM to its state of the art differentiable rule mining alternative, Neural LP~\cite{yang2017differentiable}. To show the importance of having a rank greater than one in DRUM, we test two versions, DRUM-1 and DRUM-4, with $L=1$ and $L=4$ (rank 4), respectively. 

To the best of our knowledge, NeuralLP and DRUM are the only scalable \footnote{e.g., On the Kinship dataset DRUM takes 1.2 minutes to run vs +8 hours for NTP(-$\lambda$) \cite{rocktaschel2017end} on the same machine.} and differentiable methods that provide reasoning on KBs without the need to use embeddings of the entities at test time, and provide prediction solely based on the logical rules. Other methods like NTPs~\cite{minervini2018towards, rocktaschel2017end} and MINERVA~\cite{das2018go}, rely on \textit{some type of learned} embeddings at training and test time. Since rules are interpretable and embeddings are not, this puts our method and NeuralLP in fully-interpretable category while others do not have this advantage (therefore its not fair to directly compare them with each other). Moreover, methods that rely on embeddings (fully or partially) are prone to having worse results in inductive tasks, as partially shown in the experiment section. Nonetheless we show the results of the other methods in the appendix.

\begin{table}[h!]
    \centering
    \caption{Experiment results with maximum rule length 2 and 3}\label{tab:srl_results}
    \scalebox{0.95}{
    \begin{tabular}{lccccccccccccccc}
        \toprule
         & & \multicolumn{4}{c}{\textbf{Family}} & \multicolumn{4}{c}{\textbf{UMLS}} & \multicolumn{4}{c}{\textbf{Kinship}}
        \\
        \cmidrule(r){3-6} \cmidrule(r){7-10} \cmidrule(r){11-14}
         & & & \multicolumn{3}{c}{Hits@} & & \multicolumn{3}{c}{Hits@} & & \multicolumn{3}{c}{Hits@}
        \\
        \cmidrule(r){4-6} \cmidrule(r){8-10} \cmidrule(r){12-14}
         & & MRR & 10 & 3 & 1 & MRR & 10 & 3 & 1 & MRR & 10 & 3 & 1
        \\
        \midrule
        \multirow{3}{*}{$T=2$} & Neural-LP & .91 & .99 & .96 & .86 & .75 & .92 & .86 & .62 & \textbf{.62} & .91 & .69 & \textbf{.48}
        \\
& DRUM-1 & .92 & \textbf{1.0} & .98 & .86 & .80 & .97 & .93 & .66 & .51 & .85 & .59 & .34
        \\
        & DRUM-4 & .94 & \textbf{1.0} & \textbf{.99} & .89 & \textbf{.81} & \textbf{.98} & \textbf{.94} & \textbf{.67} & .60 & \textbf{.92} & .69 & .44
        \\
        \midrule 
        \multirow{3}{*}{$T=3$} 
                 & Neural-LP & .88 & .99 & .95 & .80 & .72 & .93 & .84 & .58 & .61 & .89 & .68 & .46
         \\
         & DRUM-1 & .91 & .99 & .96 & .85 & .77 & .96 & .92 & .63 & .57 & .88 & .66 & .43
         
         
        \\
        & DRUM-4 & \textbf{.95} & .99 & .98 & \textbf{.91} &.80 & .97 & .92 & .66 & .61 & .91 & \textbf{.71} & .46
        \\
        \bottomrule
    \end{tabular}
    }
\end{table}

Table \ref{tab:srl_results} shows link prediction results for each dataset in two scenarios with maximum rule length two and three. The results demonstrate that DRUM empirically outperforms Neural-LP in both cases $T=2,3$. Moreover it illustrates the importance of having a rank higher than one in estimating confidence values. We can see a more than seven percent improvement on some metrics for UMLS, and meaningful improvements in all other datasets. We believe DRUM's performance over Neural LP is due to its high rank approximation of rule confidences and its use of bidirectional LSTM to capture forward and backward ordering criteria governing the body relations according to the ontology.


\subsection{Knowledge Graph Completion}

We evaluate our proposed model in inductive and transductive link prediction tasks on two widely used knowledge graphs WordNet \citep{kilgarriff2000wordnet, miller1995wordnet} and Freebase \citep{bollacker2008freebase}. WordNet is a knowledge base constructed to produce an intuitively usable dictionary, and Freebase is a growing knowledge base of general facts. In the experiment we use WN18RR \citep{dettmers2018convolutional}, a subset of WordNet, and FB15K-237~\citep{toutanova2015observed}, which both are more challenging versions of  WN18 and FB15K~\citep{bordes2013translating} respectively. The statistics of these knowledge bases are summarized in Table~\ref{table:kbc_dst_stats}. We also present our results on WN18  \citep{bordes2013translating} in the appendix.

\begin{wraptable}{r}{0.45 \textwidth}
\vspace{-4pt}
\caption{Datasets statistics for Knowledge base completion.}
\label{table:kbc_dst_stats}
\centering
\begin{tabular}{lll}
\toprule
& \textbf{WN18RR} & \textbf{FB15K-237} \\
\midrule
\#Train & 86,835 & 272,155 \\
\#Valid & 3,034 & 17,535 \\
\#Test & 3,134 & 20,466\\
\#Relation & 11 & 237 \\
\#Entity & 40,943 &  14,541 \\
\bottomrule
\end{tabular}
\vspace{-10pt}
\end{wraptable}




For transductive link prediction we compare DRUM to several state-of-the-art models, including DistMult \citep{Yang2015EmbeddingEA}, ComplEx \citep{pmlr-v48-trouillon16}, Gaifman \citep{Niepert:2016:DGM:3157382.3157479}, TransE \citep{bordes2013translating}, ConvE
\citep{dettmers2018convolutional}, and most importantly Neural-LP. Since NTP(-$\lambda$)~\cite{rocktaschel2017end} are not scalable to WN18 or FB15K, we could not present results on larger datasets. Also dILP~\cite{evans2018learning}, unlike our method requires negative examples which is hard to obtain under Open World Assumption (OWA) of modern KGs and dILP is memory-expensive as authors admit, which cannot scale to the size of large KGs, thus we can not compare numerical results here.

In this experiment for DRUM we set the rank of the estimator $L=3$ for both datasets. The results are reported without any hyperparamter tuning. To train the model, we split the training file into facts and new training file with the ratio of three to one. Following the evaluation method in \citet{bordes2013translating}, we use filtered ranking; table \ref{tab:tran} summarizes our results. 


\begin{table}[h!]
    \centering  
    \caption{Transductive link prediction results. The results are taken from \cite{lacroix2018canonical, yang2017differentiable} and \cite{sun2018rotate}}
    \label{tab:tran}
    \begin{tabular}{lccccccccc}
        \toprule
         & \multicolumn{4}{c}{\textbf{WN18RR}} & & \multicolumn{4}{c}{\textbf{FB15K-237}} 
        \\
        \cmidrule{2-5} \cmidrule{7-10}
         & & \multicolumn{3}{c}{Hits} & & & \multicolumn{3}{c}{Hits}
        \\
        \cmidrule{3-5} \cmidrule{8-10}
         & MRR & @10 & @3 & @1 & & MRR & @10 & @3 & @1 
        \\
        \midrule
        R-GCN \citep{schlichtkrull2018modeling} & -- & -- & -- & -- & & .248 & .417 & .258 & .153
        \\
        DistMult \citep{Yang2015EmbeddingEA} & .43 & 49 & .44 & .39 & & .241 & .419 & .263 & .155
        \\
        ConvE \citep{dettmers2018convolutional} & .43 & .52 & .44 & .40 & & .325 & .501 & .356 & .237
        \\
        ComplEx \citep{pmlr-v48-trouillon16} & .44 & .51 & .46 & .41 & & .247 & .428 & .275 & .158
        \\
        TuckER \citep{balavzevic2019tucker} & .470 & .526 & .482 & .443 & & .358 & .544 & .394 & .266\\
        ComplEx-N3 \citep{lacroix2018canonical} & .47 & .54 & -- & -- & & .35 & .54 & -- & --
        \\
        RotatE \citep{sun2018rotate} & .476 & .571 & .492 & .428 & & .338 & .533 & .375 & .241
        \\
        \midrule
        Neural LP \citep{yang2017differentiable} & .435 & .566 & .434 & .371 & & .24 & .362 & -- & --
        \\
        MINERVA \citep{das2018go} & .448 & .513 & .456 & .413 & & .293 & .456 & .329 & .217
        \\
        Multi-Hop \citep{lin2018multi} & .472 & .542 & -- & .437 & & .393 & .544 & -- & .329
        \\
DRUM (T=2) & .435 & .568 & .435 & .370 & & .250 & .373 & .271 & .187
        \\ 
        DRUM (T=3) & .486 & .586 & .513 & .425 & & .343 & .516 & .378 & .255 
        \\ 
        \bottomrule
    \end{tabular}
\end{table}

The results clearly show DRUM empirically outperforms Neural-LP for all metrics on both datasets. 
DRUM also achieves state of the art Hit@1, Hit@3 as well as MRR on WN18RR among all methods (including the embedding based ones). 

It is important to note that comparing DRUM with embedding based methods solely on accuracy is not a fair comparison, because unlike DRUM they are black-box models that do not provide interpretability. Also, as we will demonstrate next, embedding based methods are not capable of reasoning on previously unseen entities.


For the inductive link prediction experiment, the set of entities in the test and train file need to be disjoint. To force that condition, after randomly selecting a subset of test tuples to be the new test file, we omit any tuples from the training file with the entity in the new test file. Table ~\ref{table:inductive} summarizes the inductive results for Hits@10. 

It is reasonable to expect a significant drop in the performance of the embedding based methods in the inductive setup. The result of Table \ref{table:inductive} clearly shows that fact for the TransE method. The table also demonstrates the superiority of DRUM to Neural LP in the inductive regime. Also for Hits@1 and Hits@3, the results of DRUM are about 1 percent better than NeuralLP and for the TransE all the values are very close to zero.
\begin{table}
\parbox{.45\linewidth}{
\centering
\caption{Inductive link prediction Hits@10 metrics.}
\label{table:inductive}
\begin{tabular}{l  c c}
\toprule
& WN18 & FB15K-237 \\
\midrule
TransE &0.01 & 0.53 \\
Neural LP &94.49  &27.97 \\
DRUM &\textbf{95.21}  &\textbf{29.13} \\
\bottomrule
\end{tabular}
}
\hfill
\parbox{.45\linewidth}{
\centering
\caption{Human assessment of number of consecutive
correct rules}
\label{tab:human_assessment}
\begin{tabular}{lcc}
\toprule
T=2        & Neural LP  & DRUM  \\ \midrule father  & 2       & 5    \\  sister  & 3       & 10    \\ uncle    & 6      & 6    \\  \bottomrule
\end{tabular}
}
\end{table}


\subsection{Quality and Interpretability of the Rules}
\label{sec:rule_interpretability}

As stated in Section~\ref{sec:intro}, an important advantage of rules as a reasoning mechanism is their comprehensibility by humans. To evaluate the quality and interpretability of rules mined by DRUM we perform two experiments. Throughout this section we use the \textit{family} dataset for demonstration purposes as it is more tangible. Other datasets like \textit{umls} yield similar results.

\newlength{\oldintextsep}
\setlength{\oldintextsep}{\intextsep}
\setlength{\intextsep}{-11pt}\setlength{\columnsep}{10pt}We use human annotation to quantitatively assess rule quality of DRUM and Neural LP. For each system and each head predicate, we ask two blind annotators\footnote{Two CS students. The annotators are not aware which system produced the rules.} to examine each system's sorted list of rules. The annotators were instructed to identify the first rule they perceive as erroneous. Table~\ref{tab:human_assessment} depicts the number of correct rules before the system generates an erroneous rule.


\setlength{\intextsep}{\oldintextsep} The results of this experiment demonstrate that rules mined by DRUM appear to be better sorted and are perceived to be more accurate.

We also sort the rules generated by each system based on their assigned confidences and show the three top rules\footnote{A complete list of top 10 rules is available in the supplementary materials.} in Table~\ref{tab:rule_examples}. Logically incorrect rules are highlighted by \textit{\textcolor{red}{italic-red}}. This experiment shows two of the three top ranked rules generated by Neural LP are incorrect (for both head predicates $wife$ and $son$). 

These errors are inevitable because it can be shown that for rules of maximum length ($T$), the estimator of Neural LP provides a rank one estimator for the \textit{confidence value tensor} described in Section~\ref{sec:DRUM}. Thus according to Theorem~\ref{thr:theorem_1} the second highest confidence rule generated by Neural LP has to share a body atom with the first rule. For example the rule \texttt{brother(B,A) $\shortrightarrow$ son(B,A)}, even though incorrect, has a high confidence due to sharing the body atom \texttt{brother} with the highest confidence rule (first rule). Since DRUM does not have this limitation it can be seen that the same does not happen for rules mined by DRUM.  

\begin{table*}[h!]
\centering
\caption{Top 3 rules obtained by each system learned on \textit{family} dataset}
\resizebox{0.95\textwidth}{!}{\begin{tabular}{@{}clll@{}}
\toprule
Neural LP                 & \begin{tabular}[c]{@{}l@{}}brother(B, A) $\shortleftarrow$ sister(A, B)\\ brother(C, A) $\shortleftarrow$ sister(A, B), sister(B, C)\\ brother(C, A) $\shortleftarrow$ brother(A, B), sister(B, C)\end{tabular}                                                                                                               & \begin{tabular}[c]{@{}l@{}}\textit{\textcolor{red}{wife(C, A) $\shortleftarrow$ husband(A, B), husband(B, C)}}\\ wife(B, A) $\shortleftarrow$ husband(A, B)\\ \textit{\textcolor{red}{wife(C, A) $\shortleftarrow$ daughter(B, A), husband(B, C)}}\end{tabular}                                                                                                                               & \begin{tabular}[c]{@{}l@{}}son(C, A) $\shortleftarrow$ son(B, A), brother(C, B)\\ \textit{\textcolor{red}{son(B, A) $\shortleftarrow$ brother(B, A)}}\\ \textit{\textcolor{red}{son(C, A) $\shortleftarrow$ son(B, A), mother(B, C)}}\end{tabular}                     \\ \midrule
DRUM                     & \begin{tabular}[c]{@{}l@{}}brother(C, A) $\shortleftarrow$ nephew(A, B), uncle(B, C)\\ brother(C, A) $\shortleftarrow$ nephew(A, B), nephew(C, B)\\ brother(C, A) $\shortleftarrow$ brother(A, B), sister(B, C)\end{tabular} & \begin{tabular}[c]{@{}l@{}}wife(A, B) $\shortleftarrow$ husband(B, A)\\ wife(C, A) $\shortleftarrow$ mother(A, B), father(C, B)\\ wife(C, A) $\shortleftarrow$ son(B, A), father(C, B)\end{tabular} & \begin{tabular}[c]{@{}l@{}}son(C, A) $\shortleftarrow$ nephew(A, B), brother(B, C)\\ son(C, A) $\shortleftarrow$ brother(A, B), mother(C, B)\\ son(C, A) $\shortleftarrow$ brother(A, B), daughter(B, C)\end{tabular} \\ \bottomrule
\end{tabular}
}
\label{tab:rule_examples}
\end{table*}


\section{Conclusion}

We present DRUM, a fully differentiable rule mining algorithm which can be used for inductive and interpretable link prediction. We provide intuition about each part of the algorithm and demonstrate its empirical success for a variety of tasks and benchmark datasets.  

DRUM's objective function is based on the Open World Assumption of KBs and is trained using only positive examples. As a possible future work we would like to modify DRUM to take advantage of negative sampling. Negative sampling has shown empirical success in representation learning methods and it may also be useful here. Another direction for future work would be to investigate an adequate way of combining differential rule mining with representation learning techniques.


\section*{Acknowledgments}
We thank Kazem Shirani for his valuable feedback. We thank Anthony Colas and Sourav Dutta for their help in human assessment of the rules. This work is partially supported by NSF under IIS Award \#1526753 and DARPA under Award \#FA8750-18-2-0014 (AIDA/GAIA). 

\bibliographystyle{abbrvnat}
\bibliography{neurips_2019}

\clearpage



\appendix
\appendixpage
\addappheadtotoc

\section{Proof of Theorem~\ref{thr:theorem_1}}

\renewcommand\thetheorem{1}
\begin{theorem}
\label{thr:theorem_1_appendix}
If $R_o$, $R_s$ are two rules of length $T$ obtained by optimizing the objective related to $\Omega^I_{\scriptstyle_{H}}$, with confidence values $\alpha_o, \alpha_s$, then there exists $\ell$ rules of length $T$, $R_1, R_2, \cdots, R_{\ell}$, with confidence values $\alpha_1, \alpha_2, \cdots, \alpha_{\ell}$ such~that:
\begin{align*}
    & d(R_o, R_1) =d(R_{\ell}, R_s)=1 \quad \text{and} \quad  d(R_o, R_s) \leq \ell +1, \\
    & d(R_l, R_{l+1})=1 \quad \text{and} \quad \alpha_l \geq  \min(\alpha_o, \alpha_s) \quad \text{for} \quad 1 \leq l \leq \ell,
\end{align*}
where $d(.,.)$ is a distance between two rules of the same size defined as the number of mismatched atoms between them.
\end{theorem}
\begin{proof}
Define:
\[
    \mb{a}^*\doteq \arg \max_{\mb{a}} O^I_{\scriptstyle_{H}}(\mb{a}) = 
        \sum_{(x,H,y) \in KG} \mb{v}_x^T \Omega^I_{\scriptstyle_{H}}(\mb{a}) \mb{v}_y,    
\]
where $O^I_H(\mb{a})$, is the objective related to the $\Omega^I_{\scriptstyle_{H}}(\bm{a})$ model. The confidence value of a rule of length $T$, for instance $S$, with body $B_{r_1} \land B_{r_2} \land \cdots \land B_{r_T}$, is
\[
    \alpha^*_S=\prod^{T}_{i=1} a^*_{i, r_i}.
\]
Therefore changing a body atom $B_{r_i}$ to $B_{r^{\prime}_i}$ in $S$, does not decrease the confidence value iff $a^*_{i, r_i} \leq a^*_{i, r^{\prime}_i}$. Let $a^*_{i, r^{*}_i}$ be the maximum element of the sequence $a^*_{i, 1}, \cdots, a^*_{i, |\mathcal{R}| }$. By consequently changing $B_{r_i}$ in $S$ to $B_{r^{*}_i}$ (for $i$'s where $r^{*}_i \neq r_i$) we obtain a sequence of rules of length T, with non-decreasing confidence values. The distance between any two consecutive elements in that sequence is 1. The last element of the sequence ($S^*$) is the rule with the highest confidence value among length $T$ rules, and the length of the sequence is $d(S, S^*)+1$.

To prove the theorem, it is sufficient to substitute $S$ with $R_o$ and $R_s$ to obtain two sequences of rules, with lengths $d(R_o, S^*)+1$ and $d(R_s, S^*)+1$, respectively. by reversing the sequence related to $R_s$ and concatenate it with the other sequence, we have a sequence of length $d(R_o, S^*)+d(R_s, S^*)+1$, satisfying the conditions required to prove the theorem (after excluding $R_o$ and $R_s$). 

The confidences values for the rules in the sequence satisfy the condition  $\alpha_l \geq \min(\alpha_o, \alpha_s)$, because all the rules in the sequence related to $R_s$ ($R_o$) and $S^*$ have larger or equal confidence value to $R_s$ ($R_o$). And since $d(.,.)$ is a valid distance function it satisfies the triangle inequality; therefore $d(R_o, R_s) \leq d(R_o, S^*)+d(R_s, S^*)$, which implies $d(R_s, R_o) \leq \ell +1 $.    
\end{proof}


\section{Extension to the table~\ref{tab:srl_results}: Comparison with other reasoning methods}

\begin{table}[!h]
\centering
\caption{Statistical Relation Learning comparison with other reasoning methods.}
\begin{tabular}{lrrrrrrrr} 
\toprule
\multicolumn{1}{c}{\multirow{2}{*}{Datasets}} & \multicolumn{4}{c}{UMLS}                                                                                        & \multicolumn{4}{c}{Kinship}                                                                                      \\
\multicolumn{1}{c}{}                          & \multicolumn{1}{c}{MRR} & \multicolumn{1}{c}{Hits@1} & \multicolumn{1}{c}{Hits@3} & \multicolumn{1}{c}{Hits@10} & \multicolumn{1}{c}{MRR} & \multicolumn{1}{c}{Hits@1} & \multicolumn{1}{c}{Hits@3} & \multicolumn{1}{c}{Hits@10}  \\ 
\hline
ConvE                                         & 0.94                    & 0.92                       & 0.96                       & 0.99                        & 0.83                    & 0.98                       & 0.92                       & 0.98                         \\
ComplEx                                       & 0.89                    & 0.82                       & 0.96                       & 1                           & 0.81                    & 0.7                        & 0.89                       & 0.98                         \\
MINERVA                                       & 0.82                    & 0.73                       &  0.90                       & 0.97                        &  0.72                    &  0.60                       & 0.81                       &  0.92                         \\
\hline
NTP$^1$                                           & 0.88                    & 0.82                       & 0.92                       & 0.97                        & 0.6                     & 0.48                       & 0.7                        & 0.78                         \\
NTP-$\lambda^1$                    & 0.93                    & 0.87                       & 0.98                       & 1                           & 0.8                     & 0.76                       & 0.82                       & 0.89                         \\
NTP 2.0                                       & 0.76                    & 0.68                       & 0.81                       & 0.88                        & 0.65                    & 0.57                       & 0.69                       & 0.81                         \\
DRUM                                          & 0.81                    & 0.67                       & 0.94                       & 0.98                        & 0.61                    & 0.46                       & 0.71                       & 0.91                         \\
\bottomrule
\end{tabular}
\end{table}

\clearpage

\section{Extension to the table~\ref{tab:tran}: WN18 dataset results}
\begin{table}[!h]
    \centering  
    \caption{Transductive link prediction results}
    \label{tab:tran_appendix}
    \begin{tabular}{lccccc}
        \toprule
         & \multicolumn{4}{c}{\textbf{WN18}} 
        \\
        \cmidrule{2-5} 
         & & \multicolumn{3}{c}{Hits}
        \\
        \cmidrule{3-5} 
         & MRR & @10 & @3 & @1 
        \\
        \midrule
        DistMult  & .822 & .936 & .914 & .728 
        \\
        ComplEx  & .941 & .947 & .936 & .936 
        \\
        Gaifman  & --    & .939 &  --   & .761   
        \\
        R-GCN  & .814 & .964 & .929 & .697 
        \\
        TransE & .495 & .943 & .888 & .113 
        \\
ConvE  & .943 & .956 & .946 &.935 \\
        \midrule
        
        Neural LP  & .94 & .945 & -- & -- 
        \\
        DRUM & .944 & .954 & .943 & .939  \\ 
        \bottomrule
    \end{tabular}
\end{table}

\section{Extension to the table~\ref{tab:rule_examples}: top 10 rules obtained by each system}

\large{
    
\begin{table}[h!]
\caption{Examples of top rules obtained by each system learned on \textit{family} dataset}
\label{tab:rule_examples_appendix}
\centering
\resizebox{1.0\textwidth}{!}{\begin{tabular}{@{}|c|l|l|l|@{}}
\toprule
\multicolumn{1}{|l|}{Head} & brother(., .)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     & wife(., .)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                & son(., .)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \\ \midrule
NeuralLP                 & \begin{tabular}[c]{@{}l@{}}(B, A) $\shortleftarrow$ inv\_sister(B, A)\\ (C, A) $\shortleftarrow$ inv\_sister(B, A), inv\_sister(C, B)\\ (C, A) $\shortleftarrow$ inv\_brother(B, A), inv\_sister(C, B)\\ (B, A) $\shortleftarrow$ inv\_brother(B, A)\\ (C, A) $\shortleftarrow$ inv\_sister(B, A), inv\_brother(C, B)\\ (C, A) $\shortleftarrow$ inv\_brother(B, A), inv\_brother(C, B)\\ (B, A) $\shortleftarrow$ son(B, A)\\ (C, A) $\shortleftarrow$ inv\_sister(B, A), son(C, B)\\ N/A\\ N/A\end{tabular}                                                                                                               & \begin{tabular}[c]{@{}l@{}}(C, A) $\shortleftarrow$ inv\_husband(B, A), inv\_husband(C, B)\\ (B, A) $\shortleftarrow$ inv\_husband(B, A)\\ (C, A) $\shortleftarrow$ daughter(B, A), inv\_husband(C, B)\\ (C, A) $\shortleftarrow$ wife(B, A), inv\_husband(C, B)\\ (C, A) $\shortleftarrow$ inv\_husband(B, A), mother(C, B)\\ (C, A) $\shortleftarrow$ mother(B, A), inv\_husband(C, B)\\ N/A\\ N/A\\ N/A\\ N/A\end{tabular}                                                                                                                               & \begin{tabular}[c]{@{}l@{}}(C, A) $\shortleftarrow$ son(B, A), brother(C, B)\\ (B, A) $\shortleftarrow$ brother(B, A)\\ (C, A) $\shortleftarrow$ son(B, A), inv\_mother(C, B)\\ (C, A) $\shortleftarrow$ inv\_mother(B, A), brother(C, B)\\ (B, A) $\shortleftarrow$ inv\_mother(B, A)\\ (C, A) $\shortleftarrow$ inv\_mother(B, A), inv\_mother(C, B)\\ (C, A) $\shortleftarrow$ inv\_husband(B, A), brother(C, B)\\ (C, A) $\shortleftarrow$ inv\_father(B, A), brother(C, B)\\ (C, A) $\shortleftarrow$ inv\_husband(B, A), inv\_mother(C, B)\\ (C, A) $\shortleftarrow$ inv\_father(B, A), inv\_mother(C, B)\end{tabular}                     \\ \midrule
DRUM                     & \begin{tabular}[c]{@{}l@{}}(C, A) $\shortleftarrow$ nephew(A, B), uncle(B, C)\\ (C, A) $\shortleftarrow$ nephew(A, B), inv\_nephew(B, C)\\ (C, A) $\shortleftarrow$ brother(A, B), sister(B, C)\\ (C, A) $\shortleftarrow$ brother(A, B), inv\_sister(B, C)\\ (C, A) $\shortleftarrow$ brother(A, B), inv\_brother(B, C)\\ (C, A) $\shortleftarrow$ brother(A, B), brother(B, C)\\ (C, A) $\shortleftarrow$ nephew(A, B), inv\_niece(B, C)\\ (C, A) $\shortleftarrow$ nephew(A, B), aunt(B, C)\\ (C, A) $\shortleftarrow$ inv\_uncle(A, B), uncle(B, C)\\ (C, A) $\shortleftarrow$ inv\_uncle(A, B), inv\_nephew(B, C)\end{tabular} & \begin{tabular}[c]{@{}l@{}}(A, B) $\shortleftarrow$ inv\_husband(A, B)\\ (C, A) $\shortleftarrow$ mother(A, B), inv\_father(B, C)\\ (C, A) $\shortleftarrow$ inv\_son(A, B), inv\_father(B, C)\\ (C, A) $\shortleftarrow$ mother(A, B), son(B, C)\\ (C, A) $\shortleftarrow$ inv\_son(A, B), son(B, C)\\ (C, A) $\shortleftarrow$ mother(A, B), daughter(B, C)\\ (C, A) $\shortleftarrow$ inv\_son(A, B), daughter(B, C)\\ (C, A) $\shortleftarrow$ inv\_daughter(A, B), inv\_father(B, C)\\ (C, A) $\shortleftarrow$ inv\_daughter(A, B), son(B, C)\\ N/A\end{tabular} & \begin{tabular}[c]{@{}l@{}}(C, A) $\shortleftarrow$ nephew(A, B), brother(B, C)\\ (C, A) $\shortleftarrow$ brother(A, B), inv\_mother(B, C)\\ (C, A) $\shortleftarrow$ brother(A, B), daughter(B, C)\\ (C, A) $\shortleftarrow$ brother(A, B), son(B, C)\\ (C, A) $\shortleftarrow$ brother(A, B), inv\_father(B, C)\\ (C, A) $\shortleftarrow$ inv\_sister(A, B), inv\_mother(B, C)\\ (C, A) $\shortleftarrow$ inv\_sister(A, B), daughter(B, C)\\ (C, A) $\shortleftarrow$ inv\_sister(A, B), son(B, C)\\ (C, A) $\shortleftarrow$ inv\_sister(A, B), inv\_father(B, C)\\ (C, A) $\shortleftarrow$ inv\_uncle(A, B), brother(B, C)\end{tabular} \\ \bottomrule
\end{tabular}
}

\end{table}


}
    



\end{document}
