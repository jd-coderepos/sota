
\documentclass{article} \usepackage{iclr2022_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}



\usepackage{booktabs}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{amsmath,amsfonts,amsthm,amssymb,amsopn,bm}
\usepackage{xspace}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{mathtools}
\usepackage{mathptmx}
\usepackage{bm}
\usepackage{subfigure}
\usepackage{wrapfig}
\usepackage{microtype}
\usepackage{pifont}
\usepackage{urwchancal}
\usepackage{arydshln}
\usepackage{makecell}

\usepackage[pdftex]{graphicx}

\definecolor{highlight}{rgb}{0,0,0} 


\nointerlineskip 

\newcommand*\samethanks[1][\value{footnote}]{\footnotemark[#1]}



\newcommand{\ti}[1]{\textit{#1}}
\newcommand{\ts}[1]{\textsc{#1}}
\newcommand{\tf}[1]{\textbf{#1}}
\newcommand{\ttt}[1]{\texttt{#1}}
\newcommand{\mf}[1]{\mathbf{#1}}

\newcommand{\customcomment}[3]{\textcolor{#1}{[#2:#3]}}
\newcommand{\chj}[1]{\customcomment{purple}{CHJ}{#1}}
\newcommand{\dsm}[1]{\customcomment{cyan}{DSM}{#1}}
\newcommand{\zny}[1]{\customcomment{orange}{ZNY}{#1}}
\newcommand{\todo}[1]{\customcomment{red}{TODO}{#1}}

\newcommand{\ours}{DART}
\newcommand{\oursbase}{DART}
\newcommand{\oursopt}{DART}
\newcommand{\dtrain}{\mathcal{D}_{\text{train}}}
\newcommand{\ddev}{\mathcal{D}_{\text{dev}}}
\newcommand{\dtest}{\mathcal{D}_{\text{test}}}
\newcommand{\seedset}{\mathcal{S}_{\text{seed}}}

\newcommand{\lsent}{\texttt{<}S_1\ttt{>}}
\newcommand{\lfirstsent}{\texttt{<}S_1\ttt{>}}
\newcommand{\lsecondsent}{\texttt{<}S_2\ttt{>}}
\newcommand{\sent}{\ttt{<}\ttt{>}}
\newcommand{\firstsent}{\ttt{<}\ttt{>}}
\newcommand{\secondsent}{\ttt{<}\ttt{>}}
\newcommand{\xinput}{{X}_{\mathrm{in}}}
\newcommand{\xinputhat}{\tilde{X}_{\mathrm{in}}}
\newcommand{\xprompt}{{X}_{\mathrm{prompt}}}

\newcommand{\gen}{\mathrm{g}}


\newcommand{\template}{\mathcal{T}}
\newcommand{\lwordset}{\mathcal{W}}
\newcommand{\vocabulary}{\mathcal{V}}
\newcommand{\vocabularyhat}{\mathcal{V'}}
\newcommand{\labelset}{Y}
\newcommand{\mapping}{\mathcal{M}}
\newcommand{\totalk}{K_{\text{tot}}}
\newcommand{\lm}{\mathcal{L}}
\newcommand{\cls}{\texttt{[CLS]}}
\newcommand{\sep}{\texttt{[SEP]}}
\newcommand{\mask}{\texttt{[MASK]}}
\newcommand{\tableindent}{~~} 
\title{Differentiable Prompt Makes Pre-trained Language Models Better Few-shot Learners}




\author{Ningyu Zhang \quad Luoqiu Li\quad Xiang Chen\quad Shumin Deng \quad Zhen Bi \\ \textbf{Chuanqi Tan} \quad \textbf{Fei Huang} \quad \textbf{Huajun Chen}\thanks{Corresponding author.}\\
  College of Computer Science and Technology, Zhejiang University\\
  School of Software Technology, Zhejiang University\\
  Alibaba-Zhejiang University Joint Research Institute of Frontier Technologies\\
  Hangzhou Innovation Center, Zhejiang University \\
  Alibaba Group\\
  \texttt{\{zhangningyu,3160102409,xiang\_chen,231sm,bizhen\_zju\}@zju.edu.cn},\\ 
  \texttt{\{chuanqi.tcq,songfang.hsf,f.huang\}@alibaba-inc.com}
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
Large-scale pre-trained language models have contributed significantly to natural language processing by demonstrating remarkable abilities as few-shot learners. However, their effectiveness depends mainly on scaling the model parameters and prompt design, hindering their implementation in most real-world applications. This study proposes a novel pluggable, extensible, and efficient approach named DifferentiAble pRompT (DART), which can convert small language models into better few-shot learners. The main principle behind this approach involves reformulating potential natural language processing tasks into the task of a pre-trained language model and differentially optimizing the prompt template as well as the target label with backpropagation. Furthermore, the proposed approach can be: (i) Plugged to any pre-trained language models; (ii) Extended to widespread classification tasks. A comprehensive evaluation of standard NLP tasks demonstrates that the proposed approach achieves a better few-shot performance\footnote{Code is available in \url{https://github.com/zjunlp/DART}.}. 
\end{abstract}


\section{Introduction}

The pre-train—fine-tune paradigm has become the de facto standard for natural language processing (NLP), and has achieved excellent results in several benchmarks \citep{DBLP:conf/naacl/DevlinCLT19,DBLP:journals/corr/abs-1907-11692,DBLP:conf/acl/LewisLGGMLSZ20,DBLP:conf/nips/00040WWLWGZH19,DBLP:conf/icml/Bao0WW0L0GP0H20}. 
The success of these pioneers seems to suggest that large-scale pre-trained models are always nothing short of a panacea for boosting machine intelligence. 
However, supervised fine-tuning is still prone to labeled data in practice and faces unignorable challenges owing to the variations of domains, language, and tasks.
These drawbacks lead to the research of an important technique, \textit{few-shot learning}, which can significantly improve the learning capabilities of machine intelligence and practical adaptive applications by accessing only a small number of labeled examples.

The GPT-3 model, introduced by \cite{DBLP:conf/nips/BrownMRSKDNSSAA20}, exhibits impressive few-shot learning capabilities. 
Given a natural language prompt and 16 labeled samples as demonstrations in the contextual input, GPT-3 achieves 80\% of the SOTA results.
However, GPT-3 is a fully dense transformer model with 175B parameters, which makes it challenging to deploy in most real-world applications. 






\begin{figure} 
\centering 
\includegraphics[width=0.84\linewidth]{figs/Intro.pdf}  
\caption{The architecture of \textbf{D}ifferenti\textbf{A}ble p\textbf{R}omp\textbf{T} (\textbf{DART}) model comparing with \emph{MLM pre-training} and \emph{conventional fine-tuning}, where  and  are unused or special tokens in the vocabulary.
 {\color{highlight}
We leverage a few parameters within the language model as the template and label tokens and optimize them via backpropagation without introducing additional parameters apart from the model. }
 } 
\label{model}  
\end{figure}


Recently, an emerging fine-tuning methodology has arisen to equip smaller language models (LMs) with few-shot capabilities: adapting the pre-trained LM directly as a predictor through completion of a cloze task (\cite{DBLP:conf/eacl/SchickS21,DBLP:journals/corr/abs-2009-07118,DBLP:journals/corr/abs-2012-15723,DBLP:journals/corr/abs-2103-10385}), which treats the downstream task as a (masked) language modeling problem.
These prompts can be used in fine-tuning to provide the classifier with additional task information, especially in the low-data regime. 
Notably, \cite{DBLP:journals/corr/abs-2103-08493} observe that prompting can often compensate for hundreds of data points on average across multiple classification tasks.
However, determining the appropriate prompts requires domain expertise, and handcrafting a high-performing prompt often requires impractically large validation sets (\cite{Ethan2021true}). 
Recent studies (\cite{DBLP:journals/corr/abs-2104-08786,DBLP:journals/corr/abs-2102-09690}) have reported that the manual prompt format can be sub-optimal, which would result in the accuracy varying from random guess performance to near the state-of-the-art.
Therefore, previous approaches have attempted to search for discrete prompt tokens automatically. 
However, it is non-trivial for widespread classification tasks to obtain an optimized prompt template and target label token.
For example, specific classification tasks such as relation extraction with the label of  and  cannot specify a single label token in the vocabulary. 


In this paper, we propose a novel \textbf{D}ifferenti\textbf{A}ble p\textbf{R}omp\textbf{T} (\textbf{DART}) fine-tuning approach, which is model-agnostic, parameter-efficient.
As illustrated in Figure~\ref{model}, the key idea is to leverage a few parameters (unused tokens) in the language model, which serve as the template and label tokens, and to optimize them in the continuous space using backpropagation. 
Subsequently, we introduce differentiable prompt learning to obtain optimized prompt templates as well as labels. 
Since fine-tuning with limited samples can be affected by instability~(\cite{DBLP:journals/corr/abs-2002-06305,zhang2021revisiting}), we propose an optimization algorithm to jointly learning templates as well as labels. 
We further introduce an auxiliary fluency constraint object to ensure the association among the prompt embeddings.

We conduct extensive experiments on 15 NLP datasets.
With only a few training samples across all the tasks, our approach (DART) can obtain a better performance. 
Notably, absolute performance improvement of up to 23.28\%, over the conventional fine-tuning, is obtained on average in the setting of  (and 1.55\% for fully supervised settings) on relation extraction datasets with complex label semantics.
Our approach can be applied to real-world classification tasks without the high cost of collecting and annotating a large amount of data. 
The main contributions of this study are as follows:

\begin{itemize}
    \item We propose a new simple framework for few-shot learning, which is pluggable, extensible, and efficient. 
    To the best of our knowledge, optimizing label tokens in continuous space is also a new branch of research that has not been explored in language model prompting.
    
    \item A systematic evaluation of 15 NLP tasks shows that the simple-yet-effective method contributes towards improvements across all these tasks.  
    Remarkably, given only 8 labeled samples per class, our proposed approach can achieve 90\% performance of the SOTA results (full dataset).
\end{itemize}

\section{Related Work}

\paragraph{Language Model Prompting.} 
The language model prompting has emerged with the introduction of GPT-3~(\cite{DBLP:conf/nips/BrownMRSKDNSSAA20}), which demonstrates excellent few-shot performance (\cite{DBLP:journals/corr/abs-2107-13586}). 
However, GPT-3 is not designed for fine-tuning; it mainly relies on the handcraft prompt (in-context learning~(\cite{DBLP:journals/corr/abs-2101-06804,DBLP:journals/corr/abs-2102-09690,ding2021prompt,DBLP:journals/corr/abs-2108-04106})). 
Thus, recent studies (\cite{DBLP:journals/corr/abs-2104-06599,DBLP:journals/corr/abs-2101-00121,chen2021adaprompt}) conducted in this field have been focused on automatically searching the prompts. 
\cite{DBLP:conf/eacl/SchickS21,DBLP:journals/corr/abs-2009-07118} propose the PET, which reformulates the NLP tasks as cloze-style questions and performs gradient-based fine-tuning.
\cite{DBLP:journals/corr/abs-2103-11955} improve the PET with a denser supervision object during fine-tuning. 
\cite{DBLP:conf/emnlp/ShinRLWS20} propose the AUTOPROMPT to create prompts for a diverse set of tasks based on a gradient-guided search. 
\cite{DBLP:journals/corr/abs-2105-11259}  propose an approach called PTR, which leverages logic rules to construct prompts with sub-prompts for many-class text classification. 
\cite{DBLP:journals/corr/abs-2104-14690} reformulate potential NLP task into an entailment one, and then fine-tune the model with few-shot samples. 
\cite{DBLP:journals/corr/abs-2108-02035} propose an approach to incorporate external knowledge graph into the verbalizer with calibration. 
Additionally, \cite{DBLP:journals/corr/abs-2012-15723} present LM-BFF—better few-shot fine-tuning of language models, which leverages T5~(\cite{DBLP:journals/jmlr/RaffelSRLNMZLL20}) to generate templates and search label tokens in the vocabulary. 
However, the utilization of the generative model and the label search with validation is computation-intensive. 
Moreover, the prompt search over discrete space is sub-optimal due to the continuous nature of neural networks. 

To overcome these limitations,  \cite{DBLP:journals/corr/abs-2103-10385} propose P-tuning, which employs trainable continuous prompt embeddings learned by an LSTM. 
\cite{zhong2021factual} propose an effective continuous method called OPTIPROMPT to optimize prompts for factual probing. 
\cite{DBLP:journals/corr/abs-2103-10385} propose prefix-tuning, which keeps language model parameters frozen but optimizes a small continuous task-specific vector for natural language generation tasks.
\cite{DBLP:journals/corr/abs-2104-08691}  propose a mechanism for learning “soft prompts” to condition frozen language models to perform downstream tasks.
However, these approaches still have to optimize the external parameters (e.g., LSTM in P-tuning) and are prone to complex label space. 

Conversely, this study aims to develop a novel few-shot learning framework based on pre-trained language models which can reduce the prompt engineering (including templates and labels) and external parameter optimization. 
Furthermore, the proposed approach only leverages the noninvasive modification of the model, which can be plugged into any pre-trained language model and extended to the widespread classification task. 

\paragraph{Few-shot Learning.}
Few-shot learning can significantly improve the learning capabilities for machine intelligence and practical adaptive applications by accessing only a small number of labeled examples (\cite{DBLP:conf/www/ZhangDSCZC20}). 
The proposed approach corresponds to the other few-shot NLP methods, including: 
(1) Meta-learning (\cite{DBLP:conf/naacl/YuGYCPCTWZ18,DBLP:conf/iclr/BaoWCB20,DBLP:conf/coling/BansalJM20,DBLP:conf/aaai/DengZSCC20,DBLP:conf/wsdm/DengZKZZC20,DBLP:conf/coling/YuZDYZC20}), in which the quantities of the auxiliary tasks are optimized. 
(2) Intermediate training (\cite{DBLP:journals/corr/abs-1811-01088,DBLP:conf/emnlp/YinRRSX20}), which supplements the pre-trained LMs with further training on the data-rich supervised tasks.
(3) Semi-supervised learning (\cite{DBLP:conf/iclr/MiyatoDG17,DBLP:conf/nips/XieDHL020}), which leverages unlabeled samples. 
The proposed approach focuses on a more realistic few-shot setting (the number of labeled instances per class can be any variable).

\section{Background}
Let  be a sentence, where  is the  token in the input sentence and  is the number of tokens. 
Specifically,  is converted to a fixed token sequence  and then mapped to a sequence of hidden vectors . 
Given the input sequence, , the conventional fine-tuning approaches leverage a generic head layer over [CLS] embeddings (e.g., an MLP layer) to predict an output class. 
For the prompt-based method, a task-specific pattern string (template ) is designed to coax the model into producing a textual output corresponding to a given class (label token )---we refer to these two things together as a prompt.
Specifically,  containing one \mask~token is directly tasked with the MLM input as:



When the prompt is fed into the MLM, the model can obtain the probability distribution   of the candidate class,  as:

where  represents the  label token of class . 



\section{Our Approach}

\subsection{Motivation}

It can be observed from the previous empirical findings (\cite{DBLP:journals/corr/abs-2012-15723,DBLP:journals/corr/abs-2103-08493}) that an optimal prompt is necessary for the improvement of the pre-trained language models for the few-shot learners. 
Since templates with discrete tokens may be sub-optimal and are insufficient to represent a specific class\footnote{It is non-trivial to evaluate all options of templates and label tokens.}, this study proposes \textbf{D}ifferenti\textbf{A}ble p\textbf{R}omp\textbf{T}, referred to as {\textbf{DART}}, which can reduce the requirement of prompt engineering in order to improve the applicability of the proposed method in various domains.

\subsection{Differentiable Template Optimization}
\label{optsec1}

Since the language tokens are discrete variables, finding the optimal prompts with token searching is non-trivial and may easily fall into the local minima.
To overcome these limitations, we utilize pseudo tokens to construct templates and then optimize them with backpropagation.
Specifically, given the template,
\mask, which varies from  the traditional discrete prompts, satisfying  and map  into:



DART considers [] as pseudo tokens and maps the template as follows:



where  are trainable parameters. 
Differentiable template optimization can obtain expressive templates beyond the original vocabulary .
Lastly, the templates, , are differentially optimized by:



Note that the values of the prompt embeddings, , must be co-dependent with each other rather than independent.
Unlike P-tuning (\cite{DBLP:journals/corr/abs-2103-10385}), which utilizes a bidirectional LSTM, DART leverages an auxiliary fluency constraint objective to associate the prompt embeddings with each other, thus stimulating the model to focus on context representation learning. 

\subsection{Differentiable Label Optimization}
\label{optsec2}

Prompt-based fine-tuning requires filling in one word, and the masked word prediction is mapped to a verbalizer, which produces a class (i.e., "Yes": True. "No": False).
For each class , the previous approaches such as LM-BFF (\cite{DBLP:journals/corr/abs-2012-15723}) estimate the conditional likelihood of the initial   on a pruned set   of the top  vocabulary words.

However, the brute-forcing label searching:
(1) is computationally intensive and tedious because the  is generally very large, requiring multiple rounds of evaluation.
(2) has poor scalability with an increase in the class numbers (many classification datasets have more than 100 classes), the number of searches may be  ( represents the total number of classes), which is exponential and thus intractable.
Additionally, the labels of classes contain rich, complex semantic knowledge, and one discrete token may be insufficient to represent this information.

Specifically, with the labels,
, different from the previous approach which converts the class type \text{} into a variable number of label tokens \{...,\text{},..,\text{,...}\}, DART maps the \text{} to a continuous vocabulary space as follows:

where  is the number of trainable embedding in template.
To avoid optimizing any external parameters,  is replaced with unused tokens (e.g., [unused1] or special tokens in vocabulary) in  to generate , as shown in Figure \ref{model}.

\subsection{Training Objectives}
\label{object}

Since the pseudo tokens in the prompt template must be co-dependent with each other, we introduce an auxiliary fluency constraint training without optimizing any other parameters inspired by  \cite{DBLP:journals/corr/abs-2103-10385,DBLP:journals/corr/abs-2103-11955}.
Overall, there are two objectives: the class discrimination objective  and the fluency constraint objective .

\paragraph{Class Discrimination Object} 
The class discrimination objective is the main objective that aims to classify the sentences.
As shown in Figure~\ref{model}, given , we can generate  as: 

where  is the cross-entropy loss function,   represents the class discrimination loss.

\paragraph{Fluency Constraint Object}
 
To ensure the association among the template tokens and to maintain the ability of language understanding inherited from the PLMs, we leverage a fluency constraint object with the MLM. 
As shown in Figure \ref{model}, one token in the input sentence is randomly masked, and the masked language prediction is conducted.
 and  are the original and masked sequences, respectively. 
Let  be the target token that has been masked out in , and  is maximized as follows\footnote{We use the golden label  rather than the [MASK] in the input of the fluency constraint object.}:
 




By optimizing , the language model can obtain a better contextual representation with a rich association among the template tokens. 
We have the following training object:


where  is the hyper-parameter. 
Lastly, we introduce the overall optimization procedure of DART. 
To mitigate the instability of the few-shot fine-tuning, we jointly optimize templates and labels. 
Note that our approach can reuse the same transformer architecture (rather than additional LSTM) so that it enjoys the beauty of simplicity for prompt-tuning.



\iffalse
\begin{algorithm}[h]
  \caption{Differentiable Prompt Fine-tuning Algorithm with Two-stage Optimization} \label{alg}
  \begin{algorithmic}[1]
    \Require
        : stochastic objective function with parameters ;
        ,: learning rate;
        : parameters of the templates and label tokens;  
    
    \State initialize ;
    \While{ not converged} \Comment{Template and label optimization with learning rate }
        \label{alg:iteration1}
        \State  ; 
        \State  ;
        \State  ;
    \EndWhile

    \label{alg:iteration11}
    \While{ not converged} \Comment{All parameter optimization with learning rate }
        \label{alg:iteration2} 
        \State  ;
        \State ;
        \State ;
    \EndWhile
    \label{alg:iteration22}

  \end{algorithmic}
\end{algorithm}
\fi

\iffalse
\subsection{Comparison to Previous Prompt-tuning Approaches}
Since prompt learning has become a new paradigm or a way for human-PLMs communication, it appeals to many researchers.
Due to the fast development of prompt learning, some similar ideas (learned embeddings) may be introduced by different research teams.
However, we list the major difference between our model and other approaches as shown in Table \ref{tab:diff}:

To conclude, our approach is quite simple and requires no external parameters (different from WARP/Prefix-Tuning/P-tuning/ADAPET). 
Moreover, our approach unifies the optimization of template and answer.


\begin{table*}[!htb]
    \begin{center}
    \small
    \centering
    \resizebox{1.0\columnwidth}{!}{\begin{tabular}{l c c c c}
    \toprule
    \tf{Model}
    
    & \tf{External Parameter} & \tf{External Architecture} & \tf{Template} & \tf{Answer} \\
    \toprule
   Prefix-Tuning (\cite{DBLP:journals/corr/abs-2101-00190})&	yes	&no	&continuous&	no \\
   WARP	(\cite{DBLP:journals/corr/abs-2101-00121})&yes&	no&	continuous&	continuous\\
   P-tuning (\cite{DBLP:journals/corr/abs-2103-10385})&	yes&	LSTM	&continuous	&no\\
   ADAPET (\cite{DBLP:journals/corr/abs-2103-11955})&	yes&	no&	discrete&	discrete\\
    \midrule
    DART (Ours)&	no	&no&continuous	&continuous\\
    \bottomrule
    \end{tabular}
    }
\end{center}
    \caption{The difference between DART and previous prompt-tuning approaches.}
    \label{tab:diff}
\end{table*}
 
 \fi

\section{Experiments}
\label{sec:exp}
In this section, we detail the comprehensive experimental results conducted on classification tasks.
The promising results demonstrate that our proposed DART substantially outperforms the conventional fine-tuning method, thus, making pre-trained language models better few-shot learners.

\subsection{Dataset Statistics}
We conduct a comprehensive study across 15 NLP tasks, which covers sentiment analysis, natural language inference, paraphrases, sentence similarity, relation extraction, and event extraction (We only report event argument extraction performance). 
The evaluation consisted of 10  popular sentence classification datasets (SST-2, MR, CR, Subj, TREC, MNLI, SNLI, QNLI, MRPC, QQP).To further evaluate the effectiveness of the proposed approach with complex label space, we conduct experiments on the relation extraction and event extraction datasets, including SemEval-2010 Task 8 \citep{DBLP:conf/semeval/HendrickxKKNSPP10}, TACRED-Revisit~(\cite{DBLP:conf/acl/AltGH20a}), Wiki80\footnote{\url{https://github.com/thunlp/OpenNRE/}} \citep{DBLP:conf/emnlp/HanGYYLS19}, ChemProt \citep{DBLP:journals/biodb/KringelumKBLOT16}, and ACE-2005\footnote{\url{https://catalog.ldc.upenn.edu/LDC2006T06}}.

\subsection{Settings}
\label{sec:setting}

The proposed model is implemented using Pytorch (\cite{DBLP:conf/nips/PaszkeGMLBCKLGA19}).
Our experiments are conducted with the same setting following LM-BFF ( \cite{DBLP:journals/corr/abs-2012-15723}), which measures the average performance with a fixed set of seeds, , across five different sampled  for each task. 
We utilize a grid search over multiple hyperparameters and select the best result as measured on  for each set .
We employ AdamW as the optimizer. 
We conduct experiments with a RoBERTa-large (\cite{DBLP:journals/corr/abs-1907-11692}) on classification tasks for a fair comparison with LM-BFF.
We leverage an uncased BERT-large (\cite{DBLP:conf/naacl/DevlinCLT19}) for relation extraction datasets, except that we use SCIBERT (\cite{DBLP:conf/emnlp/BeltagyLC19}) for the ChemProt dataset. 
We follow ~\cite{DBLP:conf/acl/SoaresFLK19} and use special entity markers uniformly to highlight the entity mentions for relation extraction. 


\begin{table*}[t]
\begin{center}
\centering
\resizebox{\linewidth}{!}{
\begin{tabular}{l c c c c c c}
\toprule
\textbf{Model} & \tf{SST-2} (acc) & \tf{MR} (acc) & \tf{CR} (acc) & \tf{Subj} (acc)  & \tf{TREC} (acc) \\
\toprule
Majority & 50.9  & 50.0 & 50.0 & 50.0 & 18.8 \\
Prompt-based zero-shot & 83.6 & 80.8 & 79.5 & 51.4 & 32.0 \\
``GPT-3'' in-context learning & 84.8 (1.3) & 80.5 (1.7) & 87.4 (0.8) & 53.6 (1.0) & 26.2 (2.4) \\
Fine-tuning & 81.4 (3.8) & 76.9 (5.9) & 75.8 (3.2) & 90.8 (1.8) & 88.8 (2.1) \\
LM-BFF & 92.3 (1.0) & 85.5 (2.8)  & 89.0 (1.4) & 91.2 (1.1) & 88.2 (2.0) \\
P-Tuning & 92.2 (0.4) & 86.7 (1.2) & 91.8 (1.1) & 90.3 (2.2) & 86.3 (4.5) \\
\midrule
DART & \tf{93.5 (0.5)} & \tf{88.2 (1.0)} & \tf{91.8 (0.5)} & 90.7 (1.4) & 87.1(3.8) \\
\midrule
Fine-tuning (full) & \ti{95.0} & \ti{90.8} & \ti{89.4} & \ti{97.0} & \ti{97.4} \\

\toprule
\toprule
\textbf{Model} & \tf{MNLI} (acc) & \tf{SNLI} (acc) & \tf{QNLI} (acc) & \tf{MRPC} (F1)  & \tf{QQP} (F1) \\
\toprule
Majority & 32.7 & 33.8 & 49.5 & 81.2 & 0.0 \\
Prompt-based zero-shot & 50.8 & 49.5 & 50.8 & 61.9 & 49.7 \\
``GPT-3'' in-context learning & 52.0 (0.7) & 47.1 (0.6) & 53.8 (0.4) & 45.7 (6.0) & 36.1 (5.2) \\
Fine-tuning & 45.8 (6.4) & 48.4 (4.8) & 60.2 (6.5) & 76.6 (2.5) & 60.7 (4.3)    \\
LM-BFF & 68.3 (2.5) & 77.1 (2.1) & 68.3 (7.4) & 76.2 (2.3) & 67.0 (3.0) \\
P-Tuning & 61.5 (2.1) & 72.3 (3.0) & 64.3 (2.8) & 74.5 (7.6) & 65.6 (3.0) \\
\midrule
DART & 67.5 (2.6) & 75.8 (1.6) & 66.7 (3.7) & \tf{78.3 (4.5)} & \tf{67.8 (3.2)} \\ 
\midrule
Fine-tuning (full) & \ti{89.8} & \ti{92.6} & \ti{93.3} & \ti{91.4} & \ti{81.7} \\

\bottomrule
\end{tabular}
}
\end{center}

\caption{
Our main results with RoBERTa-large.
: the full training set is used.
: no training examples are used.
Otherwise, we use  (\# examples per class).
We report mean (and standard deviation) performance over 5 different splits.
{Majority:} majority class
{``GPT-3'' in-context learning:} using the in-context learning proposed in  with RoBERTa-large (no parameter updates);
{LM-BFF:} we report the performance in \cite{DBLP:journals/corr/abs-2012-15723}.
{full:} fine-tuning using full training set.
}
\vspace{-15pt}
    \label{tab:glue}
\end{table*}


\begin{table*}[!htb]
    \small
    \footnotesize
    \centering
    \begin{tabular}{c | c | c | c | c | c}
        \toprule



        \textbf{Dataset} & \textbf{Model} & \textbf{} & \textbf{} & \textbf{} & \textbf{} \\
        
        \midrule
        
        \multirow{3}*{SemEval} 
        & Fine-tuning & 26.3 & 43.8 & 64.2 & 87.8 \\
        & LM-BFF & 43.2 & 62.0 & 72.9 & 88.0 \\
        & DART
        & \textbf{51.8} \tiny{\color{red}{(+25.5)}}  
        & \textbf{67.2} \tiny{\color{red}{(+23.4)}}
        & \textbf{77.3} \tiny{\color{red}{(+13.1)}}
        & \textbf{89.1} \tiny{\color{red}{(+1.3)}} \\

        \midrule
        
        \multirow{3}*{TACRED-Revisit} 
        & Fine-tuning & 7.4 & 15.5 & 25.8 & 75.0 \\
        & LM-BFF & 21.0 & 23.7 & 27.1 & 76.4 \\
        & DART  
        & \textbf{25.8} \tiny{\color{red}{(+18.4)}}  
        & \textbf{30.1} \tiny{\color{red}{(+14.6)}}  
        & \textbf{31.8} \tiny{\color{red}{(+6.0)}}  
        & \textbf{77.8} \tiny{\color{red}{(+2.8)}} \\

        \midrule
    
        \multirow{3}*{WiKi80} 
        & Fine-tuning & 46.3 &60.3 & 70.0 & 87.5 \\
        & LM-BFF & 66.5 & 73.5 & 78.1 & 86.2 \\
        & DART
        & \textbf{68.5} \tiny{\color{red}{(+22.2)}}  
        & \textbf{75.2} \tiny{\color{red}{(+14.9)}}  
        & \textbf{79.4} \tiny{\color{red}{(+9.4)}} 
        & \textbf{88.1} \tiny{\color{red}{(+0.6)}} \\

        \midrule
        
        \multirow{3}*{ChemProt} 
        & Fine-tuning & 30.2 & 41.5 & 52.5 & 79.5 \\
        & LM-BFF & 55.0 & 56.1 & 60.0 & 79.1 \\
        & DART
        & \textbf{57.2} \tiny{\color{red}{(+27.0)}} 
        & \textbf{60.8} \tiny{\color{red}{(+19.3)}} 
        & \textbf{63.1} \tiny{\color{red}{(+10.6)}}
        & \textbf{81.0} \tiny{\color{red}{(+1.5)}} \\
        
        \bottomrule
    \end{tabular}
    \caption{Results on RE dataset WiKi80~(accuracy), while other datasets~(micro F). We use  (\# examples per class).  represents the full training set is used.}
    \label{tab:main_result}
\end{table*}



\begin{table*}[!htb]
    \begin{center}
    \small
    \centering
\begin{tabular}{l c c c c}
    \toprule
    \tf{Method}
    & \tf{K=8} & \tf{K=16} & \tf{K=32} & \tf{Full} \\
    \toprule
    Conventional FT   &26.3   &43.8  &64.2  &87.8   \\
    {\oursopt}    & \tf{51.8}   &\tf{67.2}  & \tf{77.3}      &\tf{89.1}   \\
    \midrule
    \tableindent -fluency constraint object & 50.3 \tiny{\color{blue}{(-1.5)}} & 66.1 \tiny{\color{blue}{(-1.1)}}
    & 76.0  \tiny{\color{blue}{(-1.3)}}& 88.2  \tiny{\color{blue}{(-0.9)}} \\
    \tableindent -differentiable template  &49.8 \tiny{\color{blue}{(-2.0)}} &66.3 \tiny{\color{blue}{(-0.9)}} & 76.2 \tiny{\color{blue}{(-1.1)}}     &88.4 \tiny{\color{blue}{(-0.7)}}  \\
    \tableindent -differentiable label &47.5 \tiny{\color{blue}{(-4.3)}}  &62.5 \tiny{\color{blue}{(-4.7)}}     &73.7 \tiny{\color{blue}{(-0.6)}}  &87.8 \tiny{\color{blue}{(-1.3)}}  \\

    \bottomrule
    \end{tabular}
\end{center}
    \caption{Ablation of DART with different components on SemEval. (FT= Fine tuning)
    }
    \label{tab:pair_ablation}
\end{table*}


\subsection{Main Results}

As shown in Table~\ref{tab:glue}, we observe that our approach obtains better performance than conventional fine-tuning and achieves comparable results with LM-BFF. 
Note that DART can reduce the prompt engineering without external models (e.g., T5 in LM-BFF) to generate templates that are readily easy to adapt to other datasets. 
DART can obtain 11.3\% improvement with only 16 training samples per class on the MR dataset, comparable with LM-BFF, which leverages T5 to generate appropriate prompts.
These results indicate that DART can better stimulate potential ability and makes the pre-trained language model a better few-shot learner. 
We also notice that DART yields better performance than P-tuning, which indicates that label optimization is beneficial. 



For the classification tasks with the complex label space, as shown in Table \ref{tab:main_result} and Figure \ref{e1}, we observe that DART outperforms the conventional fine-tuning approach as well as LM-BFF with a large margin on relation extraction and event extraction datasets in both the few-shot and fully supervised settings.
The proposed approach achieves an improvement of 2.8\% of the absolute performance on the TACRED-Revisit dataset with full supervision and yields 18.4\% gains with only 8 training samples per class. 
These findings also indicate that more relevant templates and labels can be determined without expert intervention, making it possible to generalize the proposed approach to other domains.
{\color{highlight}
We attribute the significant improvements to the fact that, unlike the GLUE datasets containing small categories, in relation extraction and event extraction tasks, the datasets consist of a large number of classes with complex label space, making it more challenging to obtain suitable label tokens.
}
Furthermore, we notice that the improvement decays slowly when  becomes larger (i.e., from  to ).
Our approach is a simple yet effective fine-tuning paradigm that can reduce prompt engineering within the complex label space, thus, making it possible to be an appropriate plug-in for some SOTA models.

\begin{figure*}[!htbp]
\centering
\subfigure[Event extraction results on ACE-2005.] { 
  \includegraphics[height=5cm]{figs/ee.pdf}\label{e1}
}
\subfigure[BERT-large \& GPT-2-medium results on SemEval.] { 
\includegraphics[height=5cm]{figs/result.pdf}\label{e2}
}

\caption{
(a) Few-shot results using the ACE-2005.
We used K = 4, 8, 16, and 32 (\# examples per class) with BERT. (FT= Fine-tuning)
(b) BERT-large vs. GPT-2-medium results for the SemEval. 
Moreover, for lower K, our method consistently outperforms conventional fine-tuning.
}
\label{exp2}
\end{figure*}


\subsection{Ablation Study}
We conduct an ablation study to validate the effectiveness of the components in the proposed approach.
We observe that DART exhibits a performance decay in the absence of any one of the modules, i.e., fluency constraint object, differentiable template, or differentiable label, demonstrating that all the modules are advantageous.
Furthermore, we notice that differentiable label optimization is more sensitive to performance and is highly beneficial for DART, especially for low-resource settings. 
Since the proposed approach is the first approach that utilizes the differentiable label optimization, these findings illustrate that a suitable label token is important.

\subsection{Analysis and Discussion}





\subsubsection*{Can DART Be Applied to Other Pre-trained LMs?}

To evaluate whether the proposed approach can be applied to other LMs, we conduct experiments using GPT-2-medium\footnote{
{\color{highlight}
We do not utilize the fluency constraint object in GPT-2-medium since the model is not pre-trained with MLM objective.}
}
.
From Figure \ref{e2}, we observe that DART with GPT-2-medium yields better performance than the conventional fine-tuning approach.
Furthermore, we notice that DART with GPT-2-medium can achieve performance on par with BERT-large, as observed by \cite{DBLP:journals/corr/abs-2103-10385}, indicating that the potential of GPT-style architectures for natural language understanding has been underestimated.



\subsubsection*{Why do Differentiable Prompts Yield Better Performance?}

To further analyze why our differentiable prompts method yields better performance compared with prompts with fixed templates and label tokens, we visualize the representation of masked tokens in the CR dataset during different training steps (from left to right) as shown in Figure \ref{dynamic1} (fixed) and \ref{dynamic2} (differentiable), respectively.
While both methods learn separable hidden states, differentiable prompts' representation is relatively more compact while the representation generated from fixed prompts is more scattered.
This observation of differentiable prompts generating more discriminative representations than the fixed prompts method is supported by an indicator , the ratio between average intra-class and average inter-class distance. We believe the main reason behind its better performance lies in the more discriminative representation of the differentiable method. More details can be found in Appendix \ref{exp_appendx}.

\begin{figure}[!htbp]
 \centering
  \includegraphics[height=3.4cm]{figs/cr-none-test-tsne.pdf}

\caption{
\color{highlight}
Visualization of masked tokens' representation in different training steps (with training 10, 30, 50, 70 steps from left to right) with \emph{fixed prompts}.
}
\label{dynamic1}
\end{figure}

\begin{figure*}[!htbp]
 \centering
  \includegraphics[height=3.4cm]{figs/cr-inner-test-tsne.pdf}
\caption{
\color{highlight}
Visualization of masked tokens' representation in different training steps (with training 10, 30, 50, 70 steps from left to right) with \emph{differentiable prompts}.
}
\label{dynamic2}
\end{figure*}



\subsubsection*{What Exactly is Optimized Prompt?}



Since prompt templates and label tokens in the proposed approach are mapped as , we further analyze what exactly optimized label learned. 
We conduct a nearest-neighbor vocabulary embedding search to project the Top-3 optimized pseudo-label tokens in   to a readable natural language.We use \ti{t}-SNE (\cite{van2008visualizing}) with normalization to visualize labels on Wiki80 dataset. 
For example, ``'' refers to as red   in Figure \ref{fig:scatter} represents the relation type, which is learned by optimizing the pseudo label in the continuous space, and the ``'', ``'' and ``'', refers to as  are the tokens closest to the label.
This finding indicates that the differentiable method generates better semantic representation.




\subsubsection*{DART v.s. Conventional Fine-tuning}

\begin{wrapfigure}{r}{0.4\textwidth}
\centering
\vspace{-10mm}
\includegraphics[width=0.4\textwidth]{./figs/scatter_hue.png} 
\vspace{-4mm}
\caption{A 3D visualization of several label representations learned in DART.}
\vspace{-10mm}
\label{fig:scatter}
\end{wrapfigure} 

The ability of DART to perform few-shot learning can be attributed to the label and being a true language understanding task, that once the model is capable of performing it correctly, it can easily apply this knowledge to other tasks that are framed as such. 
Superficially, 
(i) DART does not optimize any new parameters; however, conventional fine-tuning should learn an explicit classifier head over [CLS] embeddings, which may fail in the low-data regime. 
(ii) DART has the same task setting as large-scale language model pre-training.



\section{Conclusion and Future Work}
This paper presents DART, a simple yet effective fine-tuning approach that improves the fast-shot learning pre-trained language model.
The proposed approach can produce satisfactory improvements in the few-shot scenarios when compared to the conventional fine-tuning approaches.
The proposed method is also pluggable for other language models (e.g., BART) and can be extended to other tasks, such as intent detection and sentiment analysis. 
Intuitively, the results obtained in this study can be used to stimulate future research directions in the few-shot or lifelong learning for NLP.
\section*{Acknowledgments}
We  want to express gratitude to the anonymous reviewers for their hard work and kind comments. This work is funded by National Key R\&D Program of China (Funding No.SQ2018YFC000004), NSFCU19B2027/NSFC91846204, Zhejiang Provincial Natural Science Foundation of China (No. LGG22F030011), Ningbo Natural Science Foundation (2021J190), and Yongjiang Talent Introduction Programme (2021A-156-G). 

\section*{Reproducibility Statement}
Our code is available in \url{https://github.com/zjunlp/DART} for reproducibility.
Hyper-parameters are provided in the Appendix \ref{app:hyper}.





\bibliography{iclr2022_conference}
\bibliographystyle{iclr2022_conference}

\appendix
\section{Appendix}

Our code is available in the supplementary materials for reproducibility.
This section contains details about the training procedures and hyperparameters for each of the datasets. 
We utilize Pytorch \citep{DBLP:conf/nips/PaszkeGMLBCKLGA19} to conduct experiments with 1 Nvidia 3090 GPUs. 
All optimizations are performed with the AdamW optimizer with a linear warmup of learning rate over the first 10\% of gradient updates to a maximum value, then linear decay over the remainder of the training. 
Gradients are clipped if their norm exceeds 1.0, and weight decay on all non-bias parameters is set to 0.01. 
Early stopping is adopted to reduce over-fitting on the training set.

We follow LM-BFF \citep{DBLP:journals/corr/abs-2012-15723} to measure the average performance of models trained on 5 different randomly sampled  and  splits, and perform grid search for optimal hyper-parameter combinations on each split, including learning-rate, weight decay, and batch size.

For P-tuning \citep{DBLP:journals/corr/abs-2103-10385}, due to the limit of search space, we do not set anchor tokens in prompt tokens.
 
For {\oursopt}, we adopt joint optimization to acquire optimal prompts and fine-tune over global parameters. 
Note that we use base prompts as templates of pseudo tokens to accelerate convergence.
 
To compare fairly, we use RoBERTa-large \citep{DBLP:journals/corr/abs-1907-11692} as pre-trained model for both {\oursopt} and P-tuning framework, following LM-BFF \citep{DBLP:journals/corr/abs-2012-15723}. 
We also adopt the best discrete prompts together with label words in LM-BFF as base prompt settings for each framework, as stated below.
 
\subsection{Hyper-parameter Search Space of Our Method in Grid Search}
\label{app:hyper}

\textbf{SST-2, MR, CR, Subj, TREC, QNLI, MRPC, QQP}

The hyper-parameter search space is (the optimal set of parameters may vary across different tasks and data splits):
\begin{itemize}
\item learning rate
[1e-5, \textbf{5e-5}, 1e-4, 2e-4]
\item weight decay
[0.0, \textbf{0.01}, 0.05, 0.10]
\item number epochs [\textbf{20},30]
\item batch size: [4, \textbf{8}, 16, 24, 32]
\item max seq length: 128
\item gradient accumulation steps: [\textbf{1}, 2]
\end{itemize}

\textbf{MNLI, SNLI}

The hyper-parameter search space is (the optimal set of parameters may vary across different tasks and data splits):
\begin{itemize}
\item learning rate
[1e-5, \textbf{5e-5}, 1e-4, 2e-4]
\item weight decay
[\textbf{0.0}, 0.01, 0.05, 0.10]
\item number epochs [\textbf{30},40]
\item batch size: [4, \textbf{8}, 16]
\item max seq length: 256
\item gradient accumulation steps: [1, \textbf{2}]
\end{itemize}

\textbf{TACRED-Revisit, WiKi80, SemEval}

The hyper-parameter search space are:
\begin{itemize}
\item learning rate
[3e-5,\textbf{5e-5},1e-5,5e-6]
\item number epochs [\textbf{20},30]
\item batch size: 48
\item max seq length: 128
\item gradient accumulation steps: 2
\end{itemize}

\textbf{ChemProt}

The hyper-parameter search space are:
\begin{itemize}
\item learning rate
[3e-5,\textbf{5e-5},1e-5,5e-6]
\item number epochs [\textbf{20},30]
\item batch size: 48
\item max seq length: 256
\item gradient accumulation steps: 4
\end{itemize}

\textbf{DialogRE}

The hyper-parameter search space is (the optimal set of parameters may vary across different tasks and data splits):
\begin{itemize}
\item learning rate
[1e-5, \textbf{5e-5}, 1e-4, 2e-4]
\item weight decay
[0.0, \textbf{0.10}]
\item number epochs [20,30,\textbf{40}]
\item batch size: [4, \textbf{8}]
\item max seq length: 256
\item gradient accumulation steps: [1, \textbf{2}]
\end{itemize}

\subsection{Base Prompt and Label Words}

\textbf{SST-2, MR, CR}
\begin{itemize}
\item prompt template()
["", "it", "was", "mask", "."]
\item label words
\{"0": "terrible", "1": "great"\}
\end{itemize}

\textbf{Subj}
\begin{itemize}
\item prompt template()
["", "This", "is", "mask", "."]
\item label words
\{"0": "incorrect", "1": "correct"\}
\end{itemize}

\textbf{TREC}
\begin{itemize}
\item prompt template()
["mask", ":", ""]
\item label words
\{"0": "Description", "1":"Entity","2: "Expression","3": "Human","4": "Location","5":"Number"\}
\end{itemize}

\textbf{MNLI, SNLI}
\begin{itemize}
\item prompt template()
["", "?", "mask", ",", ""]
\item label words
\{"contradiction": "No","entailment": "Yes", "neutral": "Maybe"\}
\end{itemize}

\textbf{QNLI}
\begin{itemize}
\item prompt template()
["", "?", "mask", ",", ""]
\item label words
\{"not\_entailment": "No","entailment": "Yes"\}
\end{itemize}

\textbf{MRPC, QQP}
\begin{itemize}
\item prompt template()
["", "?", "mask", ",", ""]
\item label words
\{"0": "No", "1": "Yes"\}
\end{itemize}

\textbf{TACRED-Revisit, WiKi80, SemEval,DialogRE}
\begin{itemize}
\item prompt template()
["", Entity1, "is", "the", "mask", "of", Entity2]
\item label words
\{"country\_of\_origin", "participating\_team", "participant\_of",...\}
\end{itemize}
 {
 \color{highlight}
 
 
 


 
 
 
 
\subsection{Template Length Analysis}


\begin{table*}[h]
\begin{center}
\centering
\begin{tabular}{l  c}
\toprule
\textbf{Model}  & \textbf{Accuracy} \\

\midrule
DART () &  92.6 (0.6) \\
\textbf{DART()} &  \textbf{93.5 (0.5)} \\
DART ()  & 91.2 (1.1) \\
DART () & 90.6 (0.5) \\
Fine-tuning &  81.4 (3.8) \\
\bottomrule
\end{tabular}
\end{center}
\caption{Few-shot performance on SST-2 task using templates with different length.
}
\vspace{-15pt}
    \label{tab:len}
\end{table*}

We define the length of a template as the number of tokens except for input sentence and mask token, and apply DART on templates with different length. 
The performance of a specific template length  is derived by summarizing the averaging accuracy on each few-shot data splits, using template . 
From the Table \ref{tab:len}, we observe that for the SST-2 task, the model whose template length is three yield best performance; however, the overall impact of template length is rather insignificant as models with different template length obtain relatively similar performance.













\subsection{Performance on Full Training Set}

\begin{table*}[htb]
\begin{center}
\centering
\resizebox{\linewidth}{!}{
\begin{tabular}{l c c c c c c}
\toprule
\textbf{Model} & \tf{SST-2} (acc) & \tf{MR} (acc) & \tf{CR} (acc) & \tf{Subj} (acc)  & \tf{TREC} (acc) \\
\toprule
Fine-tuning & \ti{95.0} & \ti{90.8} & \ti{89.4} & \ti{97.0} & \ti{97.4} \\
LM-BFF & 94.9 & \tf{91.9}  & 92.4 & 96.9 & 97.3 \\
DART & 94.6 & 91.3 & \tf{93.8} & 96.6 & 95.6 \\
\toprule
\toprule
\textbf{Model} & \tf{MNLI} (acc) & \tf{SNLI} (acc) & \tf{QNLI} (acc) & \tf{MRPC} (F1)  & \tf{QQP} (F1) \\
\toprule
Fine-tuning & \ti{89.8} & \ti{92.6} & \ti{93.3} & \ti{91.4} & \ti{81.7} \\
LM-BFF & 89.6 & 90.3 & 92.8 & \tf{91.7} & 86.4 \\
DART & 87.3 & 89.5 & 92.3 & 90.4 & \tf{89.5} \\
\bottomrule
\end{tabular}
}
\end{center}
\caption{
Full training set results with RoBERTa-large. {Fine-tuning:} we reported same results as \cite{DBLP:journals/corr/abs-2012-15723}.
{LM-BFF:} we trained LM-BFF model (without demonstration) on full-training set.
}
\vspace{-15pt}
    \label{tab:full}
\end{table*}

We conduct experiments and report the performance of  DART with full-sized training data of GLUE tasks.
From  Table \ref{tab:full}, we notice that DART obtain better or comparable results compared with the standard fine-tuning and LM-BFF, indicating that prompt-based tuning methods benefit less from full-sized data.






\subsection{Performance with Constrained Label Tokens}

We conduct a nearest neighbor vocabulary embedding search to project the best optimized differentialble label token to a readable natural token.
Those tokens are chosen based on cosine-similarity between all tokens' embedding and the optimized differentialble label token of DART. 
We list them in descending order with similarity scores (i.e., the token `great` is chosen as its cosine-similarity score with trained positive label embedding of DART is the highest among all tokens, and the token `terrible` is the most similar token with the trained negative label embedding; the other tokens are selected and listed in descending order with similarity scores). 
From Table \ref{tab:label}, we observe that the performance of fixed prompt models is related to the similarity score of the chosen label token and that the DART model learns more semantic representation for label tokens, thus, yield best performance.

\begin{table*}[htb]
\begin{center}
\centering
\begin{tabular}{l c c}
\toprule
 \textbf{Label tokens} & \textbf{Accuracy} \\
\midrule
 differentiable token (DART) & \textbf{91.8 (0.5)} \\
 great/terrible & 91.5 (0.3) \\
 fantastic/awful & 91.0 (0.6) \\
 amazing/horrible & 90.2 (0.8) \\
 good/bad & 89.6 (0.5) \\
\bottomrule
\end{tabular}
\end{center}
\caption{Few-shot performance on CR task using constrained label tokens with DART.
}
\vspace{-15pt}
    \label{tab:label}
\end{table*}

 }
 
 
 
 
\subsection{More Experiments}
\label{exp_appendx}
We numeralize our observation on representation of masked token with a ratio between the average intra-class distance and average inter-class distance of hidden state vectors as , where:

where  is the euclidean metric between two vectors, and  means the hidden state representation of masked token of -th sample from class .
For discriminative representation, its average intra-class distance is low as data points within the same class tend to gather together, and its average inter-class distance is high as data points from different classes are separated, so its  ratio should be close to 0.

As is shown in Figure \ref{ratio}, the  ratio of the differentiable method grows lower than that of the fixed label method, which shows the hidden state representation trained in the differentiable method has better linear separability.

Note that in a masked language model, a linear transformation is performed on the hidden state representations, with a linear decoder sharing weights with the model's word embeddings serving as the final token classifier. 
Hence it is evident that better linear separability of the representations leads to better performance. 
In our case, the differentiable method yields better performance due to its better linear separability.

\begin{figure}
\centering 
\includegraphics[width=0.80\linewidth]{figs/cr-dist_ratio.pdf}  
\caption{The  ratio curve on dev set of CR task of fixed prompt and differentiable prompt during training.}
\label{ratio}  
\end{figure}



\subsection{Limitations}\label{limit}
Our work may fail when the distribution of the task corpus varies from that of the pre-training corpus. 
For example, a general pre-trained language model may be fine-tuned with more training instances in a specific domain (e.g., medical domain).
This issue can be addressed by intermediate training \citep{DBLP:journals/corr/abs-1811-01088,DBLP:conf/emnlp/YinRRSX20,DBLP:journals/corr/abs-2102-09690}, and will be analyzed in the future work.
Besides, our work also shows an instability associated with hyper-parameters which is also observed by \cite{DBLP:journals/corr/abs-2002-06305,zhang2021revisiting,Ethan2021true} as volatility of few-shot learning in NLP.  
Overall, however, we believe our work will inspire future work to few-shot settings with more practical applications to low-data settings, e.g., that involve low-resource languages or expert annotation.

\subsection{Broader Impact}

The pre-train-fine-tune approach has become the standard for natural language processing (NLP). 
However, supervised fine-tuning is still practically affected by labeled data.
This study proposes a novel pluggable, extensible, and efficient approach named DifferntiAble pRompT (DART), which can convert small language models into better few-shot learners. 
We believe that our study makes a significant contribution to the literature because determining the appropriate prompts requires domain expertise, and handcrafting a high-performing prompt often requires impractically large validation sets, and these issues have been overcome with the use of the proposed method, which is model-agnostic, parameter-efficient. We experimentally verified our proposed approach on 13 standard NLP tasks, and it was seen to outperform several standard NLP platforms.

\end{document}
