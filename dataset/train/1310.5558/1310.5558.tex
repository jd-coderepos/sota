\documentclass{LMCS}

\def\dOi{9(4:13)2013}
\lmcsheading {\dOi}
{1--26}
{}
{}
{Nov.~14, 2012}
{Nov.~14, 2013}
{}

\ACMCCS{[{\bf Theory of computation}]: Models of computation---Timed
  and hybrid models; Models of computation---Concurrency---Distributed
  computing models}



\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{wasysym}
\usepackage[norelsize,boxed,lined,longend]{algorithm2e}
\usepackage[tight,footnotesize]{subfigure}
\usepackage{tikz}
\usetikzlibrary{automata,shapes,arrows,decorations,petri}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}
\tikzstyle{transition} = [rectangle,
                   draw,
                   inner sep      = 0,
                   text width     = 0.4cm,
                   minimum height = 0.4cm,
                   text centered]
\tikzstyle{state} = [circle,
                   draw,
                   inner sep      = 0,
                   text width     = 0.4cm,
                   minimum height = 0.4cm,
                   text centered]
\tikzstyle{none} = [draw = none]
\tikzstyle{sad} = [none,circle,inner sep=-2.5pt]
\tikzstyle{every picture} = [auto,
                   >             = stealth,
node distance = 1.2cm,
                   initial text=,
                   font=\footnotesize,
                   initial distance=0.3cm]
\usepackage{macros}

\theoremstyle{plain}\newtheorem*{prop11}{Proposition~\ref{prop:states} bis}
\newtheorem*{lem4}{Lemma~\ref{lem:sad_equiv_read}}
\newtheorem*{thm3}{Theorem~\ref{thm:nsc}}
\def\ie{{\em i.e.\ }}



\begin{document}

\title[Avoiding Shared Clocks in NTA]
{Avoiding Shared Clocks in Networks of Timed Automata\rsuper*}

\author[S.~Balaguer]{Sandie Balaguer\rsuper a}	\address{LSV (ENS Cachan, CNRS, Inria)\\
61, avenue du Pr\'esident Wilson\\
94235 CACHAN Cedex, France}	\email{\{balaguer,chatain\}@lsv.ens-cachan.fr}  \thanks{{\lsuper a}This work is partially supported by the French ANR project ImpRo.}

\author[T.~Chatain]{Thomas Chatain\rsuper b}	



\keywords{networks of timed automata,
shared clocks,
implementation on distributed architecture,
contextual timed transition system,
behavioral equivalence for distributed systems}
\subjclass{F.1.1}
\titlecomment{{\lsuper*}This paper extends the version presented at
CONCUR'12~\cite{BC-concur12}.}




\begin{abstract}
  \noindent Networks of timed automata (NTA) are widely used to model distributed real-time
  systems. Quite often in the literature, the automata are allowed to share
  clocks, \ie transitions of one automaton may be guarded by conditions
  on the value of clocks reset by another automaton. This is a
  problem when one considers implementing such model in a distributed
  architecture, since reading clocks a priori requires communications which are
  not explicitly described in the model. We focus on the following question: given
  an NTA  where  reads some clocks reset by ,
  does there exist an NTA  without shared clocks
  with the same behavior as the initial NTA?
For this, we allow the automata to exchange information during synchronizations
  only, in particular by copying the value of their neighbor's clocks.
We discuss a formalization of the problem and define an appropriate
  behavioural equivalence. Then we give a criterion using the notion
  of contextual timed transition system, which represents the behavior of 
  when in parallel with .
  Finally, we effectively build  when it exists.
\end{abstract}

\maketitle

\section*{Introduction}
Timed automata \cite{AD94} are one of the most famous formal models for
real-time systems. They have been deeply studied and very mature tools are
available, like \textsc{Uppaal} \cite{uppaal}, \textsc{Epsilon}
\cite{Epsilon93} and \textsc{Kronos} \cite{kronos}.

Networks of Timed Automata (NTA) are a natural generalization to model real-time
distributed systems. In this formalism, each automaton has a set of clocks that
constrain its real-time behavior. But quite often in the literature, the
automata are allowed to share clocks, which provides a special way of making the
behavior of one automaton depend on what the others do. Actually shared clocks
are relatively well accepted and can be a convenient feature for modeling
systems. Imagine for instance several agents performing together a distributed
task according to a predefined schedule. In a typical implementation the
schedule would be sent to the agents at the beginning and every agent would
store its own copy of the schedule. But for a (simplified) model of the system,
it may be easier to have one timed automaton modeling a single copy of the
schedule and every agent referring to it via shared clocks.

Since NTA are almost always given a sequential semantics,
shared clocks can be handled very easily even by tools: once the NTA is
transformed into a single timed automaton by the classical product construction,
the notion of distribution is lost and the notion of shared clock itself becomes
meaningless. Nevertheless, implementing a model with shared clocks in a
multi-core architecture is not straightforward since reading clocks a priori
requires communications which are not explicitly described in the model.

Here we are concerned with the expressive power of shared clocks according to
the distributed nature of the system. We are aware of only one previous study
about this aspect, presented in~\cite{LPW07}.
Our purpose is to identify NTA where sharing clocks could be avoided,  \ie NTA
which syntactically use shared clocks, but whose semantics could be achieved by
another NTA without shared clocks. For simplicity, we look at NTA made of two
automata  and  where only  reads clocks reset by .
The first step is to formalize which aspect of the semantics we want to preserve
in this setting. Then the idea is essentially to detect cases where  can
avoid reading a clock because its value does not depend on the actions that are
local to  and thus unobservable to . To generalize this idea we
have to compute the knowledge of  about the state of . We show
that this knowledge is maximized if we allow  to communicate its state to
 each time they synchronize on a common action.

In order to formalize our problem we need an appropriate notion of behavioral
equivalence between two NTA\@. We explain why classical comparisons based on the
sequential semantics, like timed bisimulation, are not sufficient here.
We need a notion that takes the distributed nature of the system into account.
That is, a component cannot observe the moves and the state of the other and
must choose its local actions according to its partial knowledge of the state of
the system. We define the notion of contextual timed transition systems
(contextual TTS) in order to formalize this idea.

Then we express the problem of avoiding shared clocks in terms of contextual TTS
and we give a characterization of the NTA for which shared clocks can be avoided.
Finally we effectively construct an NTA without shared clocks with the same
behavior as the initial one, when it exists.
A possible interest is to allow a designer to use shared clocks as a high-level
feature in a model of a protocol, and rely on our transformation to make it
implementable.


\subsubsection*{Related work}

The semantics of time in distributed systems has already been debated. The idea
of localizing clocks has already been proposed and some authors
\cite{ABGMN-concur08,Dima,Bengtsson98partialorder} have even suggested to use
local-time semantics with independently evolving clocks. Here we stay in the
classical setting of perfect clocks evolving at the same speed. This is a key
assumption that provides an implicit synchronization and lets us know some clock
values without reading them.

Many formalisms exist for real-time distributed systems, among which
NTA~\cite{AD94} and time Petri nets~\cite{Merlin}. So far, their
expressiveness was
compared~\cite{BCHRL-FORMATS2005,BoyerR08,Cassez-JSS06,Srba08} essentially in terms of
sequential semantics that forget concurrency. In \cite{BCH-fmsd12}, we defined a
concurrency-preserving translation from time Petri nets to networks of timed
automata. This transformation uses shared clocks and the question whether these
could be avoided remained open.

While partial-order semantics and unfoldings are well known for untimed systems,
they have been very little studied for distributed real-time
systems~\cite{Cassez-Ch-Jard_ATVA06,BHR-atva06}. Partial order reductions for (N)TA were
proposed in~\cite{Minea99,Bengtsson98partialorder,LugiezNZ05}.
Behavioral equivalence relations for distributed systems, like
history-preserving bisimulations, were defined for
untimed systems only \cite{BestDKP91,GlabbeekG01}.

Finally, our notion of contextual TTS deals with knowledge of agents in
distributed systems. This is the aim of epistemic logics
\cite{ReasoningAboutKnowledge},
which have been extended to real-time in \cite{WoznaL04, Dima09}.
Our notion of contextual TTS also resembles the technique of partitioning
states based on observation, used in timed games with partial observability~\cite{Bouyer03,David09}.


\subsubsection*{Organization of the paper}
The paper is organized as follows. Section~\ref{sec:preliminaries} recalls basic
notions about TTS and NTA\@. Section~\ref{sec:nsc_problem_setting} presents the
problem of avoiding shared clocks on examples and rises the problem of comparing
NTA component by component. For this, the notion of contextual TTS is developed
in Section~\ref{sec:TTS}. The problem of avoiding shared clocks is formalized
and characterized in terms of contextual TTS\@. Then
Section~\ref{sec:construction} presents our construction.




\section{Preliminaries}\label{sec:preliminaries}                               \subsection{Timed Transition Systems}
The behavior of timed systems is often described as timed transition systems.
\begin{defi}A \emph{timed transition system} (TTS)
  is a tuple \mbox{}
  where
   is a set of states,
   is the initial state,
   is a finite set of actions disjoint from , and
  
  is a set of edges.
\end{defi}
For any , we write  if
\mbox{}, and  if for some ,
\mbox{}. We define the transition relation  as:
\begin{itemize}
  \item  if ,
  \item ,
   if ,
  \item ,
   if , where
  .
\end{itemize}


A \emph{path} of a TTS is a possibly infinite sequence of transitions
, where, for all ,
 and .
A path is \emph{initial} if it starts in .
A path  generates a
\emph{timed word} \mbox{} where, for
all , . The duration of  is
 and the untimed word of  is
.  denotes the set of finite timed words of duration 
over , i.e.\ .  denotes the set of finite paths of duration 
over .
Lastly, we write  if there is a path from  to 
that generates the timed word .

In the sequel, we use the following notations: for ,
 is a TTS, and
, where 
is the silent action.

\subsubsection*{Product of timed transitions systems.}
The \emph{product} of  and , denoted by , is the TTS
\mbox{},
where  is defined as:
\begin{itemize}
  \item  iff ,
  for any ,
  \item  iff ,
  for any ,
  \item  iff 
  and , for any .
\end{itemize}


\subsubsection*{Timed Bisimulations}
Let  be a binary relation over .
 is a
\emph{strong (resp.\ weak) timed bisimulation} relation between  and  if
 and  implies that, for any
,
if , then, for some ,
   (resp.\ ) and
  ;
  and conversely, if , then, for some ,
   (resp.\ ) and .


We write  (resp.\ ) when there is a strong (resp.\ weak)
timed bisimulation between  and .

\subsection{Networks of Timed Automata}
The set  of clock constraints over the set of clocks  is
defined by the grammar , where ,
 and . Invariants are clock
constraints of the form .
\begin{defi} A \emph{network of timed automata (NTA)} \cite{AD94} is a parallel composition
  of timed automata (TA) denoted as \mbox{},
  with  where
   is a finite set of \emph{locations},
   is the \emph{initial} location,
   is a finite set of \emph{clocks},
   is a finite set of \emph{actions},
  
  is a set of \emph{edges},
  and  assigns \emph{invariants}
  to locations.
\end{defi}
If , we also write .
For such an edge,  is the \emph{guard},  the \emph{action} and  the set of clocks to \emph{reset}.
 is the set
of clocks reset by  and for ,  may not be
empty.

\subsubsection*{Semantics} For simplicity, we give the semantics of a network of two TA
. We denote by  a \emph{state} of
the NTA, where   and  are the current locations, and
, with , is a \emph{clock valuation}
that maps each clock to its current value. A state is legal only if its
valuation  satisfies the invariants of the current locations, denoted by
.
For each set of clocks , the valuation  is defined by
 if  and  otherwise.
For each , the valuation  is
defined by  for each .
Then,
the \emph{TTS generated by } is
,
where
 is the set of legal states,
, where  maps each clock to 0,
and  is defined by
\begin{description}
  \item[Local action]
   iff
  ,
  ,
  ,  and , and similarly
  for a local action in ,
  \item[Synchronization]
   iff ,
  , \mbox{},
  ,  and
  ,
  \item[Time delay]  iff
  .
\end{description}

A \emph{run} of an NTA  is an initial path in its TTS.
The semantics of a TA  alone can also be given as a TTS denoted by
 with only local actions and delay.
A TA is \emph{non-Zeno} iff for every infinite timed word  generated by a
run, time diverges (\ie ).
This is a common assumption for TA\@. In the sequel,
we always assume that the TA we deal with are non-Zeno.


\begin{rem}\label{rem:disjoint_clocksets}
  Let  be such that . Then
   is isomorphic to .
  This is not true in general when .
  For example, in Fig.~\ref{fig:example1}, taking  at time  and
   at time 1 is possible in  but not in
  , since  resets  which is tested by
  .
\end{rem}






\section{Need for Shared Clocks}
\label{sec:nsc_problem_setting}

\subsection{Problem Setting}
\begin{figure}[t]
  \centering
  \begin{tikzpicture}[node distance = 3cm,
                    initial where = left]
  \node[state, initial,initial text  = ] (q_0) [label=above:] {};
  \node[state] (q_1) [right of=q_0] {};


  \node[state, initial,initial text  = ] (q_2) at (5,0) {};
  \node[state] (q_3) [right of=q_2] {};


  \path[->] (q_0) edge node {} (q_1)
            (q_2) edge node {} (q_3);
  \end{tikzpicture}
  \caption{ could avoid reading clock  which belongs to .}
  \label{fig:example0}
\end{figure}
We are interested in detecting the cases where it is possible to avoid sharing
clocks, so that the model can be implemented using no other synchronization than
those explicitly described by common actions.

In this paper, we consider only the case of a network of two TA, , such that  does not read the clocks reset by , and 
may read the clocks reset by .
We want to know whether  really needs to read these clocks,
or if another NTA  could achieve the same
behavior as  without using shared clocks.

A first remark is that our problem makes sense only if we insist on the
distributed nature of the system, made of two separate components. On the other
hand, if the composition operator is simply used as a convenient syntax for
describing a system that is actually implemented on a single sequential
component, then a simple product automaton would perfectly describe the system
and every clock becomes local.

So, let us consider the example of Fig.~\ref{fig:example0}, made of two TA,
supposed to describe two separate components. Remark that  reads clock
 which is reset by . But a simple analysis shows that this reading
could be avoided: because of the condition on its clock ,  can only
take transition  before time ; but  cannot reach value 
before time , since it must be reset between time  and .
Thus, forgetting the condition on  in  would not change the
behavior of the system.

\subsection{Transmitting Information during Synchronizations}
\begin{figure}[t]
  \centering
  \def\b{3.7}
  \begin{tikzpicture}[node distance = 1.6cm, initial where = above]
  \node[state, initial] (q_0) [label=left:] {};
  \node[state] (q_1) [below of=q_0]
          [label=left:] {};
  \node[none] (a_1) at (0,-\b) {};
  \node[state] (q_4) [below of=q_1] {};

  \node[state, initial] (q_2) at (2.5,0) {};
  \node[state] (q_3) [below of=q_2] [label=right:] {};
  \node[state] (q_5) [below of=q_3] {};
  \node[none] (a_2) at (2.5,-\b) {};

  \path[->] (q_0) edge [bend right] node [swap, pos=0.45] {}
                                    node [swap] {} (q_1)
            (q_1) edge [bend left] node [pos=0.45] {}
                       node {} (q_4)
                  edge [bend right,swap] node [pos=0.45] {}
                       node {} (q_4)
            (q_0) edge [bend left] node [pos=0.45]{}
                                    node {}
                                    node [pos=0.55] {} (q_1)
            (q_2) edge node [pos=0.2]{} node {} (q_3)
            (q_3) edge node [pos=0.2] {}
                                   node {}
                                   node [pos=0.8] {}(q_5);
  \begin{scope}[xshift=6cm]
    \node[state, initial] (q_2) {};
    \node[state] (q_3) [below of=q_2] [label=right:] {};
    \node[state] (q_5) [below of=q_3] {};
    \path[->] (q_2) edge node [pos=0.2]{}
                         node {}
                         node [pos=0.8] {}(q_3)
              (q_3) edge node [pos=0.2] {}
                         node {}
                         node [pos=0.8] {}(q_5);
  \node[none] (a_3) at (0,-\b) {};
  \end{scope}
\end{tikzpicture}
  \caption{ reads  which belongs to  and  does not.}
  \label{fig:example1}
\end{figure}
Consider now the example of Fig.~\ref{fig:example1}. Here also  reads clock
 which is reset by , and here also this reading could be avoided.
The idea is that  could transmit the value of  when
synchronizing, and afterwards any reading of  in  can be replaced
by the reading of a new clock  dedicated to storing the value of 
which is copied on the synchronization. Therefore  can be replaced by
 pictured in Fig.~\ref{fig:example1}, while preserving the behavior of
the NTA, but also the behavior of  w.r.t.\ .

We claim that we cannot avoid reading  without this copy of clock. Indeed,
after the synchronization, the maximal delay in the current location depends on
the exact value of , and even if we find a mechanism to allow  to
move to different locations according to the value of  at synchronization
time, infinitely many locations would be required (for example, if  occurs
at time 2,  may have any value in ).

\subsubsection*{Coding Transmission of Information}
In order to model the transmission of information during synchronizations, we
allow  and  to use a larger synchronization alphabet than
 and . This allows  to transmit discrete information,
like its current location, to .

But we saw that  also needs to transmit the exact value of its clocks,
which requires a more general mechanism than the simple clock resets.
For this we allow an automaton to copy its neighbor's clocks into local clocks
during synchronizations. This is denoted as updates of the form  in
 (see Fig.~\ref{fig:example1}).
This feature is a bit unusual but has already been studied: it is a restricted
class of updatable timed automata as defined in \cite{upd}.
Moreover, as shown in \cite{upd}, the class we consider, without comparisons of
clocks and with only equalities in the updates
is not more expressive than classical TA for the sequential semantics
(any updatable TA of the class is bisimilar to a classical TA), and the
emptiness problem is \textsf{PSPACE}-complete, as in the case of classical TAs.

\subsubsection*{Semantics}
 can be defined as previously,
with the difference that the synchronizations are now defined by:

iff ,
 where  is a partial function
from  to , \mbox{},
\mbox{},
and . The valuation  is defined by
 if  is defined, and  otherwise.

Here, we choose to apply the reset  before the update ,
because we are interested in sharing the state reached in  after the
synchronization, and  may reset some clocks in .


\subsection{Towards a Formalization of the Problem}\label{subsec:towards}

We want to know whether  really needs to read the clocks reset by
, or if another NTA  could achieve the same
behavior as  without using shared clocks. It remains to
formalize what we mean by ``having the same behavior'' in this context.

\begin{figure}[t]
  \centering
  \def\a{0.75}
\def\b{1.5}
\def\c{4}
\begin{tikzpicture}[node distance = 2cm, initial where = above]
  \tikzstyle{every label}=[label distance=-2pt]
  \node[state, initial] (q_0) [label=left:] {};
  \node[state] (q_1) at (-\a,-\b) {};
  \node[state] (q_2) at (\a,-\b) {};
  \node[none] (a_1) at (0,-2.3*\b) {};

  \begin{scope}[xshift=\c cm]
  \node[state, initial] (q_02) [label=left:] {};
  \node[state] (q_12) at (-2*\a,-\b) [label=right:] {};
  \node[state] (q_22) at (2*\a,-\b) [label=left:] {};
  \begin{scope}[xshift=-2*\a cm]
  \node[state] (q_32) at (-0.45*\a,-2*\b) {};
  \node[state] (q_42) at (0.45*\a,-2*\b) {};
  \end{scope}
  \begin{scope}[xshift=2*\a cm]
  \node[state] (q_52) at (-0.45*\a,-2*\b) {};
  \node[state] (q_62) at (0.45*\a,-2*\b) {};
  \end{scope}
  \node[none] (a_2) at (0,-2.3*\b) {};
  \end{scope}

  \begin{scope}[xshift=2.1*\c cm]
  \node[state, initial] (q_03) [label=left:] {};
  \node[state] (q_13) at (-1.6*\a,-\b) [label=right:] {};
  \node[state] (q_23) at (1.6*\a,-\b) [label=left:] {};
  \node[state] (q_33) at (-1.6*\a,-2*\b) {};
  \node[state] (q_43) at (1.6*\a,-2*\b) {};
  \node[none] (a_3) at (0,-2.3*\b) {};
  \end{scope}

  \tikzstyle{every node}=[inner sep=1.5pt]
  \path[->] (q_0) edge [swap] node [pos=0.25] {}
                       node {} (q_1)
                  edge node [pos=0.25] {}
                       node {}
                       node [pos=0.75] {} (q_2)
           (q_02) edge [swap] node [pos=0.45] {}
                       node [pos=0.65] {} (q_12)
                  edge node [pos=0.45] {}
                       node [pos=0.65] {} (q_22)
           (q_12) edge [swap] node [pos=0.45] {}
                       node [pos=0.65] {}
                       node [pos=0.9] {} (q_32)
                  edge node [pos=0.45] {}
                       node [pos=0.65] {}
                       node [pos=0.9] {} (q_42)
           (q_22) edge [swap] node [pos=0.45] {}
                       node [pos=0.65] {}
                       node [pos=0.9] {} (q_52)
                  edge node [pos=0.45] {}
                       node [pos=0.65] {}
                       node [pos=0.9] {} (q_62)
           (q_03) edge [swap] node [pos=0.45] {}
                       node [pos=0.65] {} (q_13)
                  edge node [pos=0.45] {}
                       node [pos=0.65] {}  (q_23)
           (q_13) edge node [pos=0.25] {}
                       node {} (q_33)
           (q_23) edge [swap] node [pos=0.25] {}
                       node {} (q_43);
\end{tikzpicture}
  \caption{ needs to read the clocks of  and
  . \label{fig:bisim}}
\end{figure}

First, we impose that the locality of actions is preserved, \ie  uses
the same set of local actions as , and similarly for  and
. For the synchronizations, we have explained earlier why we allow
 and  to use a larger synchronization alphabet than  and
. The correspondence between both alphabets will be done by a mapping
 (this point will be refined later).

Now we have to ensure that the behavior is preserved. The first idea that comes
to mind is to impose bisimulation between 
(\ie  with synchronization actions relabeled by
) and . But this is not sufficient, as illustrated by
the example of Fig.~\ref{fig:bisim} (where  is the identity).
Intuitively  needs to read  when in  (and similarly in
) at time 2, because this reading determines whether it will
perform  or , and the value of  cannot be inferred from its local
state given by  and the value of . Anyway 
is bisimilar to , and  does not read .
For the bisimulation relation , it is sufficient to impose
 and
.

What we see here is that, from the point of view of  and ,
these two automata do not behave the same. As a matter of fact, when  
fires one edge labeled by , it has not read  yet, and there is still a
possibility to fire  or , whereas when  fires one edge labeled
by , there is no more choice afterwards. Therefore we need a relation
between  and , and in the general case,
a relation between  and  also.



\section{Contextual Timed Transition Systems}\label{sec:TTS}

As we are interested in representing a partial view of one of the components, we
need to introduce another notion, that we call \emph{contextual timed transition
system}. This resembles the powerset construction used in game theory to
capture the knowledge of an agent about another agent~\cite{Reif}.

\subsubsection*{Notations}
 denotes the set of common actions.
 denotes the set of states of .
When  is a state of , we also write
\mbox{}, where  is in , and
, where  is  restricted to
.


\begin{defi}[]
Let \mbox{} and .
The set of states of  reachable from  by local actions in 0 delay
(and therefore not observ\-able by ) is denoted by  (for
Unobservably Reachable) and defined as

\end{defi}

\subsection{Contextual TTS}

\subsubsection*{Contextual States}
The states of this contextual TTS are called \emph{contextual states}. They can
be regarded as possibly infinite sets of states of   for which
 is in the same location and has the same valuation over .
 may not be able to distinguish between some states
 and . In , these states are
grouped into the same contextual state.
However, when , it may happen that  is able
to perform a local action or delay from  and not from
, even if these states are grouped in a same contextual state.


\begin{defi}[Contextual TTS]
Let \mbox{}.
Then, the \emph{TTS of  in the context of }, denoted by
, is the TTS
, where
\begin{itemize}
  \item , \item , s.t.\  and
  ,
  \item  is defined by
  \begin{itemize}
    \item Local action: for any ,
    
    iff ,
    and 
\item Synchronization: for any ,
    
    iff 
\item Local delay: for any ,
    
    iff , and  
\end{itemize}
\end{itemize}
\end{defi}

\noindent For example, consider  and  of Fig.~\ref{fig:bisim}. The initial
state is . From this contextual
state, it is possible to delay  time units and reach the contextual
state . Indeed,
during this delay,  has to perform either  and reset , or
. Now, from this contextual state, we can take an edge labeled by ,
and reach . Lastly,
from this new state,  can be fired, because it is enabled by
 in the TTS of the NTA, and the reached
contextual state is .




\subsubsection*{Unrestricted Contextual TTS}
We say that there is no restriction in  if whenever a local
step is possible from a reachable contextual state, then it is possible from all
the states  that are grouped into this contextual state.
In the example above, there is a restriction in  because
we have seen that  is enabled only by ,
and not by all states merged in
.
Formally, we use the predicate  defined as follows.

\begin{defi}[\text{}]
The predicate  holds iff for any reachable state
 of , both
\begin{itemize}
  \item , and
  \item 
\end{itemize}
\end{defi}
\begin{rem}\label{rem:noread_norest}
  If  does not read , then there is no restriction in
  .
\end{rem}

\subsubsection*{Sharing of Information During Synchronizations}
Later we assume that during a synchronization,  is allowed to transmit all
its state to , that is why, in , we distinguish the
states reached after a synchronization according to the state reached in
. We also label the synchronization edges by a pair  where  is the action and  the state reached in
. 

For the sequel, let  (resp. )
denote  (resp. ) where the synchronization edges
are labeled by , where  is the action, and  is
the state reached in .

We can now state a nice property of unrestricted contextual TTS that is similar
to the distributivity of TTS over the composition when considering TA with
disjoint sets of clocks (see Remark~\ref{rem:disjoint_clocksets}). We say that a TA
is \emph{deterministic} if it has no -transition and for any location
 and action , there is at most one edge labeled by  from
.

\begin{lem}\label{lem:distrib}
  If there is no restriction in , then
  .
  Moreover, when  is deterministic, this condition becomes necessary.
\end{lem}
\begin{figure}[t]
  \centering
  \def\a{1.75}
\def\b{0.4}
\def\c{4}
\begin{tikzpicture}[node distance = 2cm]
  \tikzstyle{every label}=[label distance=-2pt]

  \node[state, initial, initial text=] (p_0) {};

  \begin{scope}[xshift=\c cm]
  \node[state, initial, initial text=] (q_0) {};
  \node[state] (q_1) at (\a,\b) {};
  \node[state] (q_2) at (\a,-\b) {};
  \end{scope}

  \tikzstyle{every node}=[inner sep=1.5pt]
  \path[->] (q_0) edge node [sloped,pos=0.9] {} (q_1)
                  edge node [swap,sloped,pos=0.5] {} (q_2)
            (p_0) edge [loop right] node {} (p_0);
\end{tikzpicture}
  \caption[ is non-deterministic and the reciprocal of
  Lemma~\ref{lem:distrib} does not hold.]
  {,
  although there is a restriction in \label{fig:counterex}}
\end{figure}
The example of Fig.~\ref{fig:counterex} shows that the reciprocal does not hold
when  is not deterministic.
In order to prove Lemma~\ref{lem:distrib}, we first present two propositions.
The first one relates the reachable states of  with those of
.

\begin{prop}\label{prop:reachable}\hfill
\begin{enumerate}
  \item For any reachable state  of ,\\
  
  \item  iff\\
  
  \end{enumerate}
\end{prop}
\proof (1) For any reachable state , let us denote by  the
  fact that for any ,  is reachable in
  . We give a recursive proof. First, the
  initial state  satisfies  because for any
  ,  and hence .
Then, assume some reachable state  of 
  satisfies  and show that any state  reachable in
  one step from  also satisfies .
  There can be three kinds of steps from  in .
  \begin{enumerate}
  \item If for some ,
    , then for any
    \mbox{},
    ,
    \ie  holds.
  \item If for some ,
    , then , and
    for some \mbox{},
    .
    By the same reasoning as for , for any
    , .
    Hence  holds.
  \item If for some ,
    , then
    ,
    that is  is reachable, and by time-determinism,
    .
  \end{enumerate}
  For the third case, take  small enough (but strictly positive) so that
  .
  That is, after some local actions that take no time,  is able to
  perform a delay  during which no local action is enabled (such 
  exists because  of the non-zenoness assumption). With such , any state
   is such that  for some  so
  that  is reachable. Therefore,
   and hence  holds.

  Since  is not Zeno, any delay in  can be cut into a
  finite number of such smaller global delays. Hence, for any  that
  satisfies , for any  such that
  ,  holds.


  (2, ) (1) already gives that
  ,  is a reachable state.
  So it remains to prove that, when ,
  if  is a reachable state, then
  . We say that a reachable state  satisfies
   iff .

  Assume  and  is a reachable
  state that satisfies .
  Then, any state  reachable in one step from  by some local action
  or delay  or by some synchronization
   matches one of the following cases:
  \begin{itemize}
    \item if , then 
    such that   (by construction,
    ),
    \item if , then ,
    \item if , then ,
    where  such that  is in
    ,
    \item if , then
    .
  \end{itemize}
  Therefore, any state  reached in one step from  also satisfies
  , and recursively, since the initial state
   satisfies , any reachable state
   of  satisfies .

  (2, ) By contradiction, assume there is a restriction in state  for
  local delay or action  \ie
   is possible from some state  but not from another state
   such that . Then, after performing  from
  , that is reachable according to
  Proposition~\ref{prop:reachable}, we reach state  such
  that .\qed

\begin{prop}\label{prop:uniqueness}
  If  then,
  for any timed word  over , there exists at most one  such that, for some ,
   in 
  (\ie  is uniquely determined by , whatever the structure of
  ).
\end{prop}
\proof Assuming , we show that, for any  reachable
in , for any action or delay in
,
there is at most one  such that, for some ,  is a
successor of  by this action.

Indeed, by construction, and since there is no restriction,
\begin{itemize}
  \item any successor of  by a local action is of the form
  ,
  \item any successor of  by a synchronization  is
  of the form ,
  \item any successor of  by a delay  is
  of the form  with .
\end{itemize}
Therefore, for any possible action or delay,  does not depend on the
state of , and is uniquely determined by this action or delay.

Since  is unique, for any timed word  over
, either  does not
describe a valid path in , or there exists a unique 
such that for some ,
 in .\qed

We can now prove Lemma~\ref{lem:distrib}.
\proof[Proof of Lemma~\ref{lem:distrib}]
  Assume , and define relation
   as ,
  for any reachable states
   of  and
   of .
  By Proposition~\ref{prop:reachable}, since 
  is reachable, .
We show that  is a strong timed bisimulation.

  First, the initial states
  are -related: .
  Then, if , four kinds of steps are possible:
  \begin{itemize}
    \item if for some ,
    , then
     and ,
    and conversely.
    \item if for some ,
    , then, ,
     (because ),
    and in particular,  and
    , and conversely.
    \item if for some ,
    , then
     and ,
    and conversely.
    \item if for some ,
    , then
     (because ),
    and , and conversely.
  \end{itemize}

  \noindent Now assume  is deterministic.
  Let relation  be a strong timed bisimulation between  and
  . 

  By contradiction, assume there is a restriction in . Then
  there is a reachable state  of , and a local
  delay or action  such that, for
  some ,  enables  in
  , whereas  does not.

  By definition of a bisimulation, there also exist two states
   and  such that
   and . That
  is, in particular,  does not enable .
Moreover, these states can be chosen so that they are reached by the same
  timed word over , and since
   is deterministic, .


  Now, we can assume that  is chosen so that it is the first state
  with a restriction along an initial path. Then, the paths to  and
   generate the same timed word over
  , and by
  Proposition~\ref{prop:uniqueness}, . 

  Therefore, we have shown the existence of a state  in
   that does not enable , which means
  that  does not enable  in .
  This contradicts the fact that there exists  such that
   enables .\qed

We are now in condition to formalize our problem.


\subsection{Need for Shared Clocks Revisited}\label{subsec:nsc}                We have argued in Section~\ref{subsec:towards} that the existence of a
NTA  without shared clocks and such that
 is not sufficient to
capture the idea that  does not need to read the clocks of .
We are now equipped to define the relations we want to impose
on the separate components, namely
 and
.
And since we have seen the importance of labeling the synchronization
actions in contextual TTS by labels in  rather than in
, the correspondence between the synchronization labels of  with those of  is now done by a mapping
.

\begin{figure}[t]
  \centering
  \def\b{-0.4}
\def\c{2}
\def\d{1}
\def\a{\c+\d}
\begin{tikzpicture}[node distance = 2cm]
  \node[state, initial, initial text  = ] (q_0) [label=above:] {};
  \node[state] (q_1) at (\c,\b) {};
  \node[state] (q_2) at (\c,-\b) {};

  \begin{scope}[xshift=4.2cm-\d cm/2]
  \node[state, initial, initial text  = ] (q_02) [label=above:] {};
  \node[state] (q_12) at (\a,\b) {};
  \node[state] (q_22) at (\a,-\b) {};
  \end{scope}

  \begin{scope}[xshift=8.4cm]
  \node[state, initial, initial text  = ] (q_03) [label=above:] {};
  \node[state] (q_13) at (\c,\b) {};
  \node[state] (q_23) at (\c,-\b) {};
  \end{scope}

  \path[->] (q_0) edge node [sloped,above] {} (q_2)
                  edge node [sloped,below] {} (q_1)
           (q_02) edge node [sloped,above] {} (q_22)
                  edge node [sloped,below] {} (q_12)
           (q_03) edge node [sloped,above] {} (q_23)
                  edge node [sloped,below] {} (q_13);
\end{tikzpicture}
  \caption{ needs to read the clocks of  and
  . \label{fig:bisim2}}
\end{figure}

This settles the problem of the example of Fig.~\ref{fig:bisim} where
 (here ), but as shown in
Fig.~\ref{fig:bisim2}, a problem remains.
In this example, we can see that 
needs to read clock  of  to know whether it has to perform 
or  at time 2, and yet 
(here also ). The intuition
to understand this is that the contextual TTS merge too many states for the two
systems to remain differentiable. However we remark that here, the
first condition that we have required in Section~\ref{sec:nsc_problem_setting},
namely the global bisimulation between  and ,
does not hold.


\subsubsection{Formalization}
Now we show that the conjunction of global and local bisimulations actually
gives the good definition.

\begin{defi}[Need for shared clocks]\label{def:nsc}
  Given  such that  does not read the clocks of ,
   \emph{does not need to read the clocks of
    } iff there exists an NTA  without shared clocks
  (but with clock copies during synchronizations),
  using the same sets of local actions and a synchronization
  alphabet  related to the original one by a mapping , and such that
  \begin{enumerate}
    \item  and
    \item  and
    \item .
  \end{enumerate}
\end{defi}

Notice that this does not mean that the clock constraints that read  can
simply be removed from  (see Fig.~\ref{fig:example1}).
\begin{lem}\label{lem:nsc}
  When there is no restriction in , any NTA  which has no shared clocks and which satisfies items 2 and 3 of
  Definition~\ref{def:nsc}, also satisfies item 1.
\end{lem}
\proof
  When  holds, then by Lemma~\ref{lem:distrib},
  . So for any NTA
   satisfying items 2 and 3 of Definition~\ref{def:nsc},
  we have . It remains to show that
  .
  Remark that applying  to the labels before doing the product allows
  more synchronizations than applying  on the TTS of the system since
   may merge different labels. We show that, in our case, the two
  resulting TTS are bisimilar anyway.

  For this, let  be a bisimulation relation between
   and , and  be a
  bisimulation relation between  and
  . We will build inductively a bisimulation  between
   and
   such that for any  and  such that , there exists
  a state  of  and a state  of
   such that  and  and  and .
The inductive definition of  is as follows. The initial states (which
  are the same in both sides) are in relation;  is preserved by delays;
   is preserved by playing local actions. The key is the treatment of
  synchronizations: when  and  in  and  in  with , then the
  existence of the  and  mentioned earlier ensures that there
  exists a state  in  such that
  , and we set  for any such .\qed

\subsubsection{A Criterion to Decide the Need for Shared Clocks}
We are now ready to give a criterion to decide whether shared clocks are necessary.
\begin{thm}\label{thm:nsc}
  When there is no restriction in  holds,  does not
  need to read the clocks of . When  is deterministic, this
  condition becomes necessary.
\end{thm}


\proof[Proof of Theorem~\ref{thm:nsc}, necessary condition when  is deterministic]
  Like in the proof of Lemma~\ref{lem:nsc}, we show that for any NTA
   satisfying items 2 and 3 of Definition~\ref{def:nsc},
  . But, by
  Lemma~\ref{lem:distrib}, when  is deterministic and 
  has restrictions,  is not timed bisimilar to
   (not even weakly timed bisimilar since there are no
  -transitions). Hence any NTA  satisfying items
  2 and 3 of Definition~\ref{def:nsc}, does not satisfy item 1.\qed

We remark from the proof that when there is a restriction in ,
even infinite  and  would not help. Next section will be devoted to the constructive proof of the direct part of
this theorem.

The counterexample in Fig.~\ref{fig:counterex} also works here to argue that the
conditions of Lemma~\ref{lem:nsc} and Theorem~\ref{thm:nsc} are not necessary
when  is not deterministic. Indeed  with only one unguarded edge
labeled by  and  satisfy the three items of
Definition~\ref{def:nsc} but there is a restriction in .





\section{Constructing a Network of Timed Automata without Shared Clocks}\label{sec:construction}
This section is dedicated to proving Theorem~\ref{thm:nsc} by constructing
suitable  and .
For simplicity, we assume that in , the guards on the synchronizations do
not read . Otherwise, the constraints that read  could be moved
into the corresponding edges in , with the intuition that, for a
synchronization, each automaton can check the constraints about its own clocks.


\subsection{Construction}\label{subsec:simple}
First, our  is obtained from  by replacing all the labels
 on the synchronization edges of  by
, where  is the output location of the
edge. Therefore the synchronization alphabet between  and  will
be , which allows  to transmit its location
after each synchronization.


Then, the idea is to build  as a product 
( denotes the product of TA as it is usually defined~\cite{AD94}),
where  plays the role of  and  acts as a
local copy of , from which  reads clocks instead of
reading those of .
For this, as long as the automata do not synchronize,  will evolve,
simulating a run of  that is compatible with what  knows about
.
And, as soon as  synchronizes with ,  updates
 to the actual state of .
If the clocks of  always give the same truth value to the guards and
invariants of  than the actual value of the clocks of , then our
construction behaves like . To check that this is the case,
we equip  with an error location, , and edges that lead to it if there is a
contradiction between the values of the clocks of  and the values of the
clocks of . The guards of these edges are the only cases where
 reads clocks of . Therefore, if  is not
reachable, they can be removed so that  does not read the clocks of
.
More precisely, a contradiction happens when  is in a given
location and the guard of an outgoing edge is true according to  and
false according to , or vice versa, or when the invariant of the current
location is false according to  (whereas it is true according to
, since  reads the clocks of ).

Namely, 
where  and  are defined as follows.
, where
\begin{itemize}
  \item each clock  is associated
  with a clock  ( is a bijection from  to
  ).
For any clock constraint ,  denotes the clock constraint where any clock  of 
  is substituted by  of .
  \item 
  \item A_1A_{1,2}A_1\\ where  denotes the assignment of any clock 
  with the value of its associated clock  (written 
  in Fig.~\ref{fig:example2}).
\end{itemize}
, where
\begin{itemize}
\item  and ,
  \item 
\end{itemize} 

\noindent For the example of Fig.~\ref{fig:example1},  and 
are pictured in Fig.~\ref{fig:example2}.
\begin{figure}[t]
  \centering
  \def\b{3.7}
\def\c{1.6cm}
\begin{tikzpicture}[node distance = \c, initial where = above]
  \node[state, initial] (q_0) [label=left:] {};
  \node[state] (q_1) [below of=q_0]
          [label=left:] {};
  \node[none] (a_1) at (0,-\b) {};

  \node[state] (q_4) [below of=q_1] {};
  \node[state, initial] (q_2) at (5.5,0) {};
  \node[state] (q_3) [below of=q_2] [label=left:] {};
  \node[state] (q_5) [below of=q_3] {};
  \node[sad] (q_6) at (8.5,-\c) {\huge\sad};
  \node[none] (a_2) at (5.5,-\b) {};

  \path[->] (q_0) edge [bend right] node [swap, pos=0.45] {}
                                    node [swap] {} (q_1)
            (q_1) edge [bend right,swap] node [pos=0.45] {}
                       node {} (q_4)
            (q_0) edge [bend left] node [pos=0.45]{}
                                    node {}
                                    node [pos=0.55] {} (q_1)
            (q_2) edge node [pos=0.2,swap] {}
                       node [swap] {} (q_3)
            (q_3) edge node [pos=0.2,swap] {}
                       node [swap]{}
                       node [pos=0.8,swap] {} (q_5);
  \path[->,densely dotted] (q_3) edge [bend left] node [above] {}(q_6)
                  edge [bend right=10] node [above]
                    {}(q_6)
                  edge [bend right=30] node [below]
                    {}(q_6);
  \path[->,densely dashed](q_1) edge [bend left]
                       node [pos=0.45] {}
                       node [pos=0.5] {} (q_4)
            (q_0) edge [bend left=85, looseness=1.8]
                       node [pos=0.5] {}
                       node [pos=0.53] {}(q_4)
            (q_4) edge [loop left] node {}(q_4);
\end{tikzpicture}
  \caption{ and  for the example of
  Fig.~\ref{fig:example1} \label{fig:example2}. We represent by dotted arcs the
  edges leading to the error state, and by dashed arcs those used during
  synchronizations to reset  to the actual state of .}
\end{figure}




We now prove the
correspondence between a state of  and two states of
 that are merged into the same state of .
This is stated in the following proposition.
A state of  is denoted as . For a given state of , , we denote
by  the state , where  is defined as:
for any ,  (\ie  is a state of ).
Reciprocally, for a given
state of , ,
 denotes the state , where  is defined as:
for any  , .
\begin{prop}\label{prop:states}
  Let  be a state of . If along one path that leads to  no edge leading to
   is enabled, then there exists  such that 
  is a reachable state of  and  and  are
  both in .

  Conversely, let  be a reachable state of , and
   and  be some states in .
  Then  is a state of .
\end{prop}


\proof Let  be a reachable state of , such that
  there is a path  from the initial state 
  to  that does not enable any edges leading to 
  (except maybe from ).
  We give a recursive proof. First, for the initial state
   of ,  and
   are both in  such that  is the
  initial state of . Now, assume this is true for some
   visited along . That is, there exists 
  such that  is reachable and .
  Then, the next state  visited along  is reached
  after one of the
  following steps:
  \begin{itemize}
    \item local action in :  such that
    ,
    \item local action in :  such that
    ,
    \item local action in :  such that
    there exists  such that  is reachable from 
    by the same action, and, since no edge leading to  is enabled,
    both  and  enable this step in
    . Therefore, .
    \item synchronization:  such that there exists
     such that  is reachable from 
    by the same action, and .
  \end{itemize}
  By recursion,  also satisfies the property, that is,
  there exists  such that  is reachable and
  .

  Conversely, let denote by  the fact that for any reachable
  state  of , for any states
  ,  is a reachable state of
  .
  First, for any , 
  is a reachable state, because by construction,  can only mimic
  (as long as there is no synchronization) one possible behavior of 
  to reach  from , therefore 
  holds.
  Assume that for some reachable state   holds.
  Then any state reachable in one step from  is reached by one of
  the following steps.
  \begin{itemize}
  \item If for some ,
    , then for any
    \mbox{},
    ,
    \ie  holds.
  \item If for some ,
    , then , and
    for any \mbox{},  can be
    reached from some  such that \mbox{}.
    Indeed, in , synchronization  resets
     in the same state as  and then
     performs some local actions while  also performs some
    local actions mimicking one possible behavior of  (that is why
    ).
    Hence  holds.
  \item If for some ,
    , then we use the same reasoning as
    for a synchronization. Since  is built
    so that it mimics any possible behavior of  between synchronizations,
    any state  reachable by  during this delay
    corresponds to a state  reachable by .
    Hence  also holds.
  \end{itemize}
  By recursion,  holds for any reachable state .\qed


Lastly, the following lemma will be used to prove the direct part of
Theorem~\ref{thm:nsc}.

\begin{lem}\label{lem:sad_equiv_read}
   is reachable in  iff there is a restriction
  in .
\end{lem}
\proof
  Assume  is not reachable in . From
  Proposition~\ref{prop:states}, we know that for any state  of
  , for any ,  in , there is a
  corresponding state  of . Moreover, for
  any such , if there is an outgoing edge towards  from ,
  then this edge is never enabled. That is, for any time constraint 
  read in  in the original system  (invariant of  or
  guard of an outgoing edge with a local action),
  .
  Hence for any enabled step from ,  and  are in the
  same restriction. Therefore, .

  Assume  is reachable in . From
  Proposition~\ref{prop:states}, we know that for any state
   of , reached after a path that does not
  enable edges leading to  (except maybe from this last state), there
  is a corresponding state  of  such that
   and  are both in .
If  can be reached, then consider a path that reaches 
  and such that no edge leading to  was enabled before along the path.
  The last state  of  visited before  is such that
  for some time constraint  evaluated at  from ,
   and
   (or conversely).
  Therefore, a local action or local delay is possible from  and
  not from .
  Hence  is a state with a restriction.\qed




We now give a first simple case for which Theorem~\ref{thm:nsc} can be proved
easily. We say that  has no urgent synchronization if for any location,
when the invariant reaches its limit, a local action is enabled.
Under this assumption, we can show that
, where  is
 without location  (that is never reached according to
Lemma~\ref{lem:sad_equiv_read}) and its ingoing edges, is suitable.
Indeed, we can show that  does not read  and is such that
, where for any
, .
Obviously, item 2 of Definition~\ref{def:nsc} holds, and Lemma~\ref{lem:nsc}
says that item 1 also holds.

When  has urgent synchronizations, this construction allows one to check
the absence of restriction in , but it does not give directly
a suitable . We define the construction of  for
the general case in Subsection~\ref{subsec:general}.



\proof[Proof of Theorem~\ref{thm:nsc},
direct part, when no urgent synchronization in ]\label{proof}\hfill


  \noindent Assume .
  We consider
   where  is
   without  (that is never reached according to
  Lemma~\ref{lem:sad_equiv_read}) and its ingoing edges. Therefore,
   does not read  and neither does
  . Below we show that  is a suitable
  candidate because 
  ( obviously holds).

  Let  be the relation such that for any reachable state  of
  , and any reachable state  of ,
  
  \ie  and  are both in  and their local
  clocks have the same value, and  and  are in
  indistinguishable states (states merged in a same contextual state ).
Obviously, the initial states,  and
  , are -related.
Since there is no marked state in  (resp.\ in
  ), for any state  (resp.\
  ) of this TTS, all time constraints read by automaton 2 in
   (invariant of  and guards of the outgoing edges) have the
  same truth value for all the states  such that 
  (resp.\ ).
In the sequel, we say that valuation  of  (resp.\  of ) satisfies
  constraint , when the valuations of all states  in 
  (resp.\ in ) satisfy .
  Assume now that for some reachable states  and ,
  .

  \subsubsection*{Local Action}
  If  is enabled from , then,
  there is an associated edge in ,  such that
  guard  is satisfied by .
  Let  be the guard on the corresponding outgoing edge
   in .
   uses clocks in , and by construction,
   has the same form but with clocks in .
   says that  and  coincide on , and since
   is never reached in ,  satisfies the constraints of 
  on  iff  satisfies the constraints of  on .
  That is, . Therefore  can also perform
   from  and the states reached in both systems
  are -related: , because  and
  .
  This also holds reciprocally.

  \subsubsection*{Synchronization} Assume for some ,
  .
  That is, there is an edge
    in  such that 
  and  and,
  for some , an edge 
  in  such that  and .
  Hence, synchronization  is also enabled from state 
  because  is in the same location as , and has the same
  clock values over , and  is also in some state
  of , therefore, there is also the same state 
  which enables .
  We do not consider  because it is always ready to
  synchronize.
Moreover, the state reached in  after this synchronization is
   such that , because 
  and  where  denotes the copy of the
  clocks of  into their associated clocks of  and therefore  modifies
  only clocks that we do not consider in relation , and 
  resets the same clocks in both systems.
And reciprocally.

  \subsubsection*{Local Delay}
  Assume for some , .
  Then, \mbox{}, and since  is never reached
  in , .
  That is, the same delay is enabled from  while  may
  perform some local steps:
  ,
  where ,  is a guard over  and  is a reset
  included in .
  This works because we assumed that  has no urgent synchronization
  (and so does ).
  Therefore,  cannot force a synchronization.

  Reciprocally, if we can perform a delay  from , then
  .
And since
  ,
  we can perform the same delay from .

  Moreover, we reach equivalent states in both systems. Indeed,  and
   stay in the same location, the clocks in 
  increase their value by , and the set of states of  and  becomes
  .

  Therefore,  is a weak timed bisimulation and
  .
  Lastly, by Lemma~\ref{lem:nsc}, 
  also, and  does not need to read .\qed



In the example of Fig.~\ref{fig:example1},  is not reachable in
 (see Fig.~\ref{fig:example2}), therefore  does not need
to read .
For an example where  is reachable, consider the same example with an
additional edge  from the end location of 
to a new location. Location  can now be reached in ,
for example consider a run where  is performed at time 2 leading to a state
where  and , and then  immediately performs 
and resets , leading to a state where the valuation  is such that
 and , and satisfies guard  in
. Therefore, with this additional edge in , 
needs to read . Indeed, without this edge,  knows that 
cannot modify  after the synchronization, but with this edge,  does
not know whether  has performed  and reset , while this may
change the truth value of its guard .

\subsection{Complexity}
\subsubsection*{\textsf{PSPACE}-hardness}
The reachability problem for timed automata is known to be
\textsf{PSPACE}-complete~\cite{AD90}. We will reduce this problem to our problem
of deciding whether  needs to read the clocks of .
Consider a timed automaton  over alphabet ,
with some location . Build the timed
automaton  as  augmented with two new locations  and 
and two edges,  and
, where  is a fresh clock, and
 is some action in .
Let  be the one of Fig.~\ref{fig:counterex} with an action .
Then,  is reachable in  iff  needs to
read  which belongs to . Therefore the problem of deciding whether
 needs to read the clocks of  is also \textsf{PSPACE}-hard.

\subsubsection*{\textsf{PSPACE}-membership}
Moreover, we can show that when  is deterministic, our problem is in
\textsf{PSPACE}. Indeed, by Theorem~\ref{thm:nsc} and
Lemma~\ref{lem:sad_equiv_read},  is not reachable iff
 iff  does not need to read the clocks of .
Since the size of the modified system on which we check the reachability of
 is polynomial in the size of the original system, our problem is in
\textsf{PSPACE}.


\subsection{Dealing with Urgent Synchronizations}
\label{subsec:general}

If we use exactly the same construction as before and allow urgent
synchronizations, the following problem may occur. Remind that 
simulates a possible run of  while  plays its actual run. There is
no reason why the two runs should coincide. Thus it may happen that the run
simulated by  reaches a state where the invariant expires and only a
synchronization is possible. Then  is expecting a synchronization with
, but it is possible that the actual  has not reached a state
that enables this synchronization. Intuitively,
 should then realize that the simulated run cannot be the actual one and
try another run compatible with the absence of synchronization.



In fact, between two synchronizations,
, the local copy of , can be constructed to simulate
only one fixed run of , instead of being able to simulate all its runs.
If this run is well chosen, then the situation described above never happens,
and we can use a construction similar to the one above, on which we can prove that
if  is not reachable, then any run of  is compatible with the
fixed run of , and  can avoid reading the clocks of .

Therefore, the idea of the construction is to force  to simulate one
of the runs of  (from the state reached after
the last synchronization) that has maximal duration before it synchronizes again
with  (or never synchronizes again if
possible). There may not be any
  such run if some time constraints are strict inequalities, but the idea can be
  adapted even to this case.
This choice of a run of  is as valid as the others, and it
prevents the system from having to deal with the subtle situation that we described
above.
Below, we describe the construction of  in two cases:
\begin{enumerate}
  \item After any synchronization there is a local run of maximal duration.
  \item It may happen that, after a synchronization, there is no
    run of maximal duration because of some strict time constraints.
\end{enumerate}

\subsubsection*{Case 1:
After any synchronization there is a local run of maximal duration}
\begin{figure}[tp]
  \centering
  \def\b{3.7}
\begin{tikzpicture}[node distance = 1.6cm, initial where = above]
  \node[state, initial] (q_0) [label=left:] {};
  \node[state] (q_1) [below of=q_0]
          [label=left:] {};
  \node[none] (a_1) at (0,-\b) {};
  \node[state] (q_4) [below of=q_1] {};

  \node[state, initial] (q_2) at (2.5,0) {};
  \node[state] (q_3) [below of=q_2] [label=right:] {};
  \node[state] (q_5) [below of=q_3] {};
  \node[none] (a_2) at (2.5,-\b) {};

  \path[->] (q_0) edge [bend right] node [swap, pos=0.45] {}
                                    node [swap] {} (q_1)
            (q_1) edge node [pos=0.25] {}
                       node {} (q_4)
            (q_0) edge [bend left] node [pos=0.45]{}
                                    node {}
                                    node [pos=0.55] {} (q_1);

  \path[->] (q_2) edge node [pos=0.2]{} node {} (q_3)
            (q_3) edge node [pos=0.2] {}
                                   node {}
                                   node [pos=0.8] {}(q_5);
\end{tikzpicture}
  \caption{ has an urgent synchronization.}\label{fig:urgent}
\end{figure}
Consider automaton  in Fig.~\ref{fig:urgent}.
We can see that, for the urgent synchronization to happen as late as possible,
 has to fire  at time 1, so that it can then wait 3 time units
before synchronizing, although it is still able to synchronize at any time (we
add the same dashed edges as in Fig.~\ref{fig:example2}). Fig.~\ref{fig:result}
shows a timed automaton that achieves the desired behaviour for 
using a fresh clock  to force the simulation of  at time .

\begin{figure}[t]
  \centering
  \def\b{3.7}
\def\c{1.6cm}
\begin{tikzpicture}[node distance = \c, initial where = above]
  \node[state, initial] (q_0) [label=left:] {};
  \node[state] (q_1) [below of=q_0]
          [label=left:] {};
  \node[state] (q_4) [below of=q_1] {};

  \path[->] (q_0) edge [swap]
                       node [pos=0.25]{}
                       node {}
                       node [pos=0.75] {} (q_1);
  \path[->,densely dashed](q_1) edge [swap]
                       node [pos=0.35] {}
                       node [pos=0.65] {} (q_4)
            (q_0) edge [bend left=85, looseness=1.8]
                       node [pos=0.5] {}
                       node [pos=0.53] {}(q_4)
            (q_4) edge [loop left] node {}(q_4);
\end{tikzpicture}
  \caption[ associated with  of Fig.~\ref{fig:urgent}]
  { associated with  of Fig.~\ref{fig:urgent}.}\label{fig:result}
\end{figure}


This can be generalized for any . The idea is essentially to force
 to follow the appropriate finite or ultimately periodic path in the
region automaton~\cite{AD94} of .
The construction is described below and illustrated by
Fig.~\ref{fig:region}.

 is now built over the region automaton~\cite{AD94}
of . Transitions labeled by some  are treated separately
like in the original construction. The problem now is to constrain 
to take one of the most time consuming local runs after a synchronization.

The first step is to build the region automaton of , and remove the
synchronizations. Then, from each state  we compute the most time consuming
run and keep only the output arcs of  that start a most time consuming run.

The computation of the most time consuming runs from  is done as follows.
If one of the paths from  has a loop, then there is an infinite run from
 with local actions, and since we consider non-Zeno TA, time diverges and
this run is valid.
If no path from  contains a loop, then
the paths from  are finite and there is a finite number of such paths.
It is possible to compute, for each path, the supremum of the duration of the path:
just sum the maximal delays in each location (including the time spent in the
last location).

It remains to force, using a fresh clock, the longest stay in each state.



\begin{figure}[tp]
  \centering
  \def\b{1.8}
\begin{tikzpicture}[node distance = 1.6cm, initial where = above]
  \tikzstyle{state} = [rectangle, rounded corners,
                   draw,
                   inner sep      = 2pt,
                   text width     = 1cm,
                   minimum height = 0.8cm,
                   text centered]
  \node[state, initial] (q_0) { };
  \node[state,text width = 1.5cm] (q_01) at (\b,0)   { \mbox{}};
  \node[state] (q_02) at (2*\b,0) { };
  \node[state,text width = 1.5cm] (q_03) at (3*\b,0) { \mbox{}};
  \node[state] (q_04) at (4*\b,0) { };
  \node[state,text width = 1.5cm] (q_05) at (5*\b,0) { \mbox{}};
  \node[state] (q_06) at (6*\b,0) { };

  \node[state] (q_1) [below of=q_0] { };
  \node[state,text width = 1.5cm] (q_12) at (1*\b,-1.6) { \mbox{}};
  \node[state] (q_13) at (2*\b,-1.6) { };
  \node[state,text width = 1.5cm] (q_14) at (3*\b,-1.6) { \mbox{}};
  \node[state] (q_15) at (4*\b,-1.6) { };
  \node[state,text width = 1.5cm] (q_16) at (5*\b,-1.6) { \mbox{}};
  \node[state] (q_17) at (6*\b,-1.6) { };

  \node[state] (q_2) [below of=q_15] { };
  \node[state,text width = 1.5cm] (q_22)  [below of=q_16] { \mbox{}};
  \node[state] (q_23) [below of=q_17] { };
  \node[state] (q_24) at (7*\b,-3.2) { };

  \tikzstyle{every node}=[inner sep=1pt]
  \path[->] (q_0)  edge [dashed,swap] node {} (q_1)
            (q_01) edge [dashed,swap] node {} (q_1)
            (q_02) edge [swap] node {} (q_1)
            (q_02) edge [dashed] node {} (q_13)
            (q_03) edge [dashed] node {} (q_14)
            (q_04) edge [dashed] node {} (q_15)
            (q_05) edge [dashed] node {} (q_16)
            (q_06) edge [dashed] node {} (q_17)
            (q_15) edge [dotted] node {} (q_2)
            (q_16) edge [dotted] node {} (q_22)
            (q_17) edge [dotted] node {} (q_23)
            (q_0)  edge node {} (q_01)
            (q_01) edge node {} (q_02)
            (q_02) edge node {} (q_03)
            (q_03) edge node {} (q_04)
            (q_04) edge node {} (q_05)
            (q_05) edge node {} (q_06)
            (q_1)  edge node {} (q_12)
            (q_12) edge node {} (q_13)
            (q_13) edge node {} (q_14)
            (q_14) edge node {} (q_15)
            (q_15) edge node {} (q_16)
            (q_16) edge node {} (q_17)
            (q_2)  edge node {} (q_22)
            (q_22) edge node {} (q_23)
            (q_23) edge node {} (q_24);
\end{tikzpicture}
  \caption[Region automaton of  of Fig.~\ref{fig:urgent}]
  {The region automaton of  of Fig.~\ref{fig:urgent}. The dashed arcs
    indicate occurrences of internal actions of  that will be removed in
    the construction of  in order to force a run of maximal duration
    between synchronizations. The occurrences of the synchronization ,
    represented by dotted arrows, are treated separately in the construction
    of .}
  \label{fig:region}
\end{figure}









Lastly, we treat the synchronizations like in the construction of
Section~\ref{subsec:simple}: for each synchronizing edge in , and each
corresponding output state in the region automaton,
we add synchronizing edges from all states of , which reset the state
of  to the actual state of . These edges are labeled by
``'', where  is the constraint that
describes the region  associated with the target state,  is the
synchronization label in ,  is the output location of the
synchronization in , and  is the assignment of clock values.



\subsubsection*{Definition of }
Assume  is a structure that
stores the region automaton of , without the synchronization edges,
and with only the edges that are in the most time consuming paths computed as explained earlier.
That is,  (resp.\ ) is the set of states (resp.\ the initial state)
of the region automaton of , and

stores edges in the form \mbox{}
where  is the delay that has to be performed in , the location
associated with state , before performing edge  labeled by some
action in .
Then,  where
\begin{itemize}
  \item  is the set of clocks associated with  as previously,
  and clocks in  will be read on the synchronizations only,
  \item \\ where  is the clock constraint that describes the region of state ,
  and
   still denotes the assignment of any clock 
  with the value of its associated clock  (written ).
  \item ,  if ,
  and  otherwise.
\end{itemize}



We can now prove the direct way of Theorem~\ref{thm:nsc} in this setting
where  may have urgent synchronizations, and the most time consuming
local runs between two synchronizations exist.
First, let us recall some notations.
, with the same
 and  as before,
 where  denotes
 without location ,
and  is such that for any
, .
\proof[Proof of Theorem~\ref{thm:nsc}, when runs of maximal duration before synchronization exist]\hfill

\noindent We show that when  holds,  does not need to read the clocks of
, because then, the constructed  satisfies Definition~\ref{def:nsc},
\ie has no shared clocks and
  \begin{enumerate}
    \item  and
    \item  (this still holds because
     has not changed)
    \item .
  \end{enumerate}

  First, we can prove that
   is reachable in  iff there is a restriction
  in , as we proved Lemma~\ref{lem:sad_equiv_read}.
  Indeed, what works when  simulates any run of  also
  works when  simulates a fixed run of .

  Then, we can prove that, if  is not reachable (\ie if there is
  no restriction in ),
  then .
  We use the same relation  as in the previous proof in~\ref{proof},
  that is,  is the relation such that for any reachable state  of
  , and any reachable state  of ,
  
  The proof of this bisimulation follows the same steps as the proof in~\ref{proof},
  except now we know that  cannot force a synchronization by construction,
  and not by assuming that there is not urgent synchronization in .

  Then, by Lemma~\ref{lem:nsc}, 
  also.\qed


\subsubsection*{Case 2: There is not always a Local Run of Maximal Duration after a Synchronization}
Now, we show how to adapt the previous construction when there are strict time
constraints and there is no path of maximal duration before an urgent
synchronization. For example, consider automaton  of Fig.~\ref{fig:urgent2}
that has an urgent synchronization and such that there is no path of maximal duration
before this synchronization is taken: as previously,  has to be performed
as late as possible, but because of the strict inequality  on the edge
labeled by , it is not possible to enforce this.

\begin{figure}[t]
  \centering
  \def\b{3.7}
\begin{tikzpicture}[node distance = 1.6cm, initial where = above]
  \node[state, initial] (q_0) [label=left:] {};
  \node[state] (q_1) [below of=q_0]
          [label=left:] {};
  \node[none] (a_1) at (0,-\b) {};
  \node[state] (q_4) [below of=q_1] {};
  
  \node[state, initial] (q_2) at (2.5,0) {};
  \node[state] (q_3) [below of=q_2] [label=right:] {};
  \node[state] (q_5) [below of=q_3] {};
  \node[none] (a_2) at (2.5,-\b) {};

  \path[->] (q_0) edge [bend right] node [swap, pos=0.45] {}
                                    node [swap] {} (q_1)
            (q_1) edge node [pos=0.25] {}
                       node {} (q_4)
            (q_0) edge [bend left] node [pos=0.45]{}
                                    node {}
                                    node [pos=0.55] {} (q_1);

  \path[->] (q_2) edge node [pos=0.2]{} node {} (q_3)
            (q_3) edge node [pos=0.2] {}
                                   node {}
                                   node [pos=0.8] {}(q_5);
\end{tikzpicture}
  \caption{ has an urgent synchronization and there is no path with
  maximal duration before this synchronization.}\label{fig:urgent2}
\end{figure}

Here also, the construction relies on the region automaton and on the
computation of the supremum of the possible durations. Then the idea is again to
follow one of the paths with the best supremum duration. But there may not exist
any optimal timing to run this path and reach the supremum. Then we run it with
one possible timing and we wait in the last region, ignoring the invariant that
would force us to synchronize.
In our example, the supremum of the duration of the path
with  is 4, and is greater than the supremum
of any other paths (the paths with  have a maximal duration of 3).
Therefore,  has to be performed while  is in the region defined by
.


Now, when  reaches a state where it has to synchronize, if
 is not ready to synchronize (\ie  is not in the location
before the synchronization), then this means that  took
a more time consuming path (and not necessarily the same actions).
Then  can stop using the values of the clocks of  to
evaluate the truth value of its time constraints, and simply take their truth value according to the last region that makes
the invariant of the urgent synchronization true (\ie the region of its current
valuation), since it would still be in this region if it had been more time consuming.
Note that, if  is not reachable, this means that, if  had
performed a more time consuming run (for example the actual run followed by ),
then  would have been able to perform the same run.
Therefore, ``stopping'' the clocks in their current region has no
side effects.


In the construction, this results in new synchronization edges, performed
by  and , when  has not been
slow enough (\ie when the invariant expires).
In our example, the synchronization labeled by ,
guarded by , notifies  that 
is stuck in the final region  (here  corresponds to  and ) but that its clocks do not satisfy the constraint any more.
In this case,  enters a duplicated version of itself, where
the guards over  are no more evaluated according to the value of the
duplicated clocks , but simply replaced by their truth value according
to the final region.
In the example of Fig.~\ref{fig:result2}, the constraint  that
appears on the arc from  to  is simply replaced by ,
because the constraint is true in region .
The duplicated versions can still reach location
,
and the constraints on the edges leading to  are also evaluated
according to the final region.

If a synchronization happens when  is in one of its
duplicated versions,
then  goes back to its initial version,
as depicted in Fig.~\ref{fig:result2}.



\begin{figure}[t]
  \centering
  \def\c{1.9}
  \def\b{5.5}
  \begin{tikzpicture}[node distance = \c cm, initial where = above]
  \fill[lightgray!60,rounded corners] (9.4-0.5,0+0.5) rectangle (9.4+0.5,-2*\c-0.5);
  \node[state, initial] (q_0) [label=left:]{};
\node[state] (q_1) [below of=q_0,label={above right,inner sep=0.5pt}:{\colorbox{lightgray!60}{}}] {};
  \node[state] (q_2) [below of=q_1] {};
\node[state,fill=lightgray!60] (q_5)  at (-2.5, -\c) {};
  \node[none] (a_1) at (0,-\b) {};
  \path[->,swap] (q_0) edge node[pos=0.2] {}
                       node {}(q_1)
(q_1) edge node[above, inner sep=1pt] {{\colorbox{lightgray!60}{}}}
        node[below, inner sep=1pt,pos=0.4] {\scriptsize} (q_5)
                  ;
  \path[->,densely dashed](q_1) edge
                       node [pos=0.4] {}
                       node [pos=0.6] {} (q_2)
            (q_0) edge [bend left=85, looseness=1.8]
                       node [pos=0.5] {}
                       node [pos=0.53] {}(q_2)
            (q_2) edge [loop below] node {}(q_2)
            (q_5) edge [swap,bend right=35]
                       node [pos=0.4] {}
                       node [pos=0.6] {}(q_2);


  \node[state, initial] (q_2) at (5.5,0) {};
  \node[state] (q_3) [below of=q_2] [label=left:] {};
  \node[state] (q_5) [below of=q_3] {};
  \node[sad] (q_6) at (7.5,-2*\c) {\huge\sad};

  \node[state] (q_7) [right of=q_2,xshift=2cm] {};
  \node[state] (q_8) [right of=q_3,xshift=2cm] {};
  \node[state] (q_9) [right of=q_5,xshift=2cm] {};
  \node[none] (a_2) at (5.5,-\b) {};
  \node[none,text width=2.6cm] (a_3) at (9.4,-\b-.2) {constraints on 
    evaluated according to region , i.e.\ with };
  \draw[->,lightgray!60,line width=1pt,>=triangle 60] (a_3)--(9.4,-2*\c-0.5);

  \path[->] (q_2) edge node [pos=0.2,swap] {}
                       node [swap] {} (q_3)
            (q_3) edge node [pos=0.2,swap] {}
                       node [swap]{}
                       node [pos=0.8,swap] {} (q_5)

        (q_2) edge node[above, inner sep=1pt] {\scriptsize} (q_7)
        (q_3) edge node[above, inner sep=1pt] {\scriptsize} (q_8)

            (q_7) edge node [sloped, above]{} (q_3)
            (q_8) edge node [pos=0.2] {}
                       node {}
                       node [pos=0.8] {}(q_9)
            ;
  \path[->,densely dotted] (q_3) edge [bend left]
                       node [sloped, above, inner sep=-1pt] {}(q_6)
                  edge node [sloped, above, inner sep=1pt] {}(q_6)
                  edge [bend right=30]
                       node [sloped, below, inner sep=-2pt,pos=0.6] {}(q_6)
            (q_8) edge [bend right]
                       node [sloped, above, inner sep=-1pt] {}(q_6)
                  edge node [sloped, above, inner sep=1pt] {}(q_6);
\end{tikzpicture}
  \caption[ and  for the NTA of Fig.~\ref{fig:urgent2}]
  { and  for the NTA of Fig.~\ref{fig:urgent2}.}
  \label{fig:result2}
\end{figure}















In order to prove the soundness of the construction, one has to show that if
there is no restriction in  (\ie if  is not reachable),
then . The bisimulation relation now
takes the new states into account as follows.












\section{Discussion and Extensions}\label{sec:shared_clocks_ext}


We have shown that in a distributed framework, when locality of actions and
synchronizations matter, NTA with shared clocks cannot be easily transformed
into NTA without shared clocks. The fact that the transformation is possible can
be characterized using the notion of contextual TTS which represent the
knowledge of one automaton about the other. Checking whether the transformation
is possible is \textsf{PSPACE}-complete.

In system design, our technique could help a designer to use shared clocks in an
abstract specification, and build automatically an implementable distributed
model without shared clocks.
Coming back to the example described in the introduction with several agents
performing together a distributed task according to a predefined schedule, this
would generate the mechanism for creating the local copies of the schedule.

A first point to notice is that, contrary to what happens when one considers the
sequential semantics, NTA with shared clocks are strictly more expressive if we
take distribution into account. This somehow justifies why shared clocks were
introduced: they are actually more than syntactic sugar.

Another interesting point that we want to recall here is the use of
transmitting information during synchronizations. In the end, when the
construction is possible, the only modification that is needed for 
is the renaming of the synchronizations, which codes this transmission of
information. On the other side,  needs a much stronger modification in
order to handle the information transmitted by .

Finally, it is noticeable that infinitely precise information is required in
general. This advocates the interest of updatable (N)TA used in an appropriate
way, and more generally gives a flavor of a class of NTA closer to
implementation.

\subsubsection*{Perspectives}
Our first perspective is to generalize our result to the symmetrical case where
 also reads clocks from . Then of course we can tackle general NTA
with more than two automata.

Notice that the set  used in the definition of contextual TTS is
always put in parallel with a state . Therefore, it can be extended to
 that represents the set of states that  can immediately
reach from  while  is in . This means that the TTS of
 in the context of  can still be defined when
 also reads clocks from .
However, we do not know whether Theorem~\ref{thm:nsc} is still true with this
definition of contextual TTS, because most of the intermediate lemmas and
propositions to prove this theorem use  that is not defined
when  reads clocks from .

Another line of research is to focus on transmission of information. The
goal would be to minimize the information transmitted during synchronizations,
and see for example where the limits of finite information lay.
Even when infinitely precise information is required to achieve the exact
semantics of the NTA, it would be interesting to study how this semantics can be
approximated using finitely precise information.

Finally, when shared clocks are necessary, one can discuss how to minimize their
number, or how to implement the model on a distributed architecture and how to
handle shared clocks with as few communications as possible.

\pagebreak
\bibliographystyle{alpha}
\bibliography{references}

\end{document}
