\documentclass[11pt]{article}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{epsfig}
\usepackage{xspace}
\usepackage{mdwlist}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{Thm}{Theorem}[section]
\newtheorem{Lem}[theorem]{Lemma}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{Def}[theorem]{Definition}
\newtheorem{prop}[theorem]{Proposition}
\newtheorem{corol}[theorem]{Corollary}
\newtheorem{obs}[theorem]{Observation}
\newtheorem{defn}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{corollary}[theorem]{Corollary}


\newenvironment{myproof}{\noindent {\sc Proof:}}{}
\newenvironment{proofsketch}{\noindent {\sc Proof Sketch:}}{}

\newtheorem{Conj}{Conjecture}
\newtheorem{property}{Property}
\setlength{\oddsidemargin}{0pt} \setlength{\evensidemargin}{0pt}
\setlength{\topmargin}{0in} \setlength{\textwidth}{6.5in}
\setlength{\textheight}{9in}\setlength{\headheight}{0.0in}
\setlength{\headsep}{0.0in}


\newcommand\pr{\mbox{\bf Pr}}
\newcommand\av{\mathop{\mathbb{E}}}
\newcommand\E{{\mathbb{E}}}
\newcommand\var{\mbox{\bf Var}}
\newcommand\rcp{r}
\newcommand \poly{\mbox{poly}}
\def\tsum{{\textstyle \sum}}
\def\epsilon{\varepsilon}
\def\lap{{\mathcal L}}
\newcommand\qi{q_i}
\newcommand\qhi{\widehat{y}_i}
\newcommand\qbi{\bar{y}_i}
\newcommand\qti{\widetilde{y_i}}
\newcommand\halfqi{y_i}

\newcommand\psubi{p_i}
\newcommand\phti{\hat{p}_i}
\newcommand\pbi{\bar{p}_i}
\newcommand\be[1]{\bar{\epsilon}_{#1}}
\newcommand\round{f}
\newcommand\dense{\qhi}
\newcommand\pti{\widetilde{p_i}}
\newcommand\good{\textrm{Good}}
\newcommand\cross{\textrm{Cross}}
\newcommand\inc{\textrm{Inc}}
\newcommand\cut{\textrm{Cut}}

\newcommand\Recursive{{\`sc Recursive-walk}\xspace}
\newcommand\Balance{{\sc Balance}\xspace}
\newcommand\Threshold{\textsc{Threshold}\xspace}
\newcommand\Find{\textsc{Find-threshold}\xspace}
\newcommand\Simple{{\sc Simple}\xspace}
\newcommand\CutOrBound{{\sc CutOrBound}\xspace}
\newcommand\otilde{\widetilde{O}}

\newcommand\soto{f\xspace}
\newcommand\volls{\omega}

\def\maxcut{\textsc{MaxCut}\xspace}
\def\Dhalf{D^{1/2}}
\def\Dhalfinv{D^{-1/2}}
\def\vol{\text{Vol}}

\addtolength{\textheight}{0.3cm}



\begin{document}
\begin{titlepage}
\title{Combinatorial Approximation Algorithms for {\sc MaxCut} using Random Walks}
\date{}
\author{
Satyen Kale\\
Yahoo! Research\\
4301 Great America Parkway, \\
Santa Clara, CA 95054\\
{\tt skale@yahoo-inc.com} \and
C. Seshadhri \\
IBM Almaden Research Center\\
650 Harry Road, \\
San Jose, CA 95120\\
{\tt csesha@us.ibm.com}}
\maketitle

\thispagestyle{empty}
\begin{abstract}

We give the first combinatorial approximation algorithm for \maxcut that beats
the trivial  factor by a constant. The main partitioning procedure is very intuitive, natural, and easily described. It essentially performs a number of random walks and aggregates the information to provide the partition. We can control the running time to get an approximation factor-running time tradeoff. We show that for any constant , there is an  algorithm that outputs a -approximation for \maxcut, where  is some positive constant.

One of the components of our algorithm is a weak local
graph partitioning procedure that may be of independent interest. Given a starting vertex  and a conductance parameter , unless a random walk of length  starting from  mixes rapidly (in terms of  and ), we can find a cut of conductance at most  close to the vertex. The work done per vertex found in the cut is sublinear in .
\end{abstract}
\end{titlepage}


\section{Introduction}

The problem of finding the maximum cut of a graph is a classical combinatorial optimization problem. Given a graph , with weights  on edges , the problem is to partition the vertex set  into two sets  and  to maximize the weight of \emph{cut edges} (these have one endpoint in  and the other in ). The value of a cut is the total weight of cut edges divided by the total weight. The largest possible value of this is .
The problem of computing  was one of Karp's original NP-complete problems~\cite{Kar75}.

Therefore, polynomial-time approximation algorithms for \maxcut were sought out, that would provide a cut with value at least ,
for some fixed constant . It is easy to show that a random cut
gives a -approximation for the \maxcut. This was the best known
for decades, until the seminal paper on semi-definite programming (SDP) by Goemans and Williamson~\cite{GW95}. They gave a -approximation algorithm, which is optimal for polynomial time algorithms under the Unique Games Conjecture~\cite{Kho02,KKMO04}. Arora and Kale~\cite{AK07} gave an efficient near-linear-time implementation of the SDP algorithm for \maxcut\footnote{This was initially only proved for graphs in which the ratio of maximum to average degree was bounded by a polylogarithmic factor, but a linear-time reduction due to Trevisan~\cite{Tre09} converts any arbitrary graph to this case.}.

In spite of the fact that efficient, possibly optimal, approximation algorithms are known, there is a lot of interest in understanding what techniques are required to improve the -approximation factor. By ``improve", we mean a ratio of the form , for some constant . The powerful technique of Linear Programming (LP) relaxations fails to improve the  factor. Even the use of strong LP-hierarchies to tighten relaxations does not help~\cite{dlVKM07,STT07}. Recently, Trevisan~\cite{Tre09} showed for the first time that a technique weaker than SDP relaxations can beat the -factor. He showed that the eigenvector corresponding to the smallest eigenvalue of the adjacency matrix can be used to approximate the \maxcut to factor of .
Soto~\cite{Sot09} gave an improved analysis of the same algorithm that provides a better approximation factor of . The running time\footnote{In this paper, we use the  notation to suppress dependence on polylogarithmic factors.} of this algorithm is .

All the previous algorithms that obtain an approximation factor better than  are not ``combinatorial", in the sense that they all involve numerical matrix computations such as eigenvector computations and matrix exponentiations. It was not known whether combinatorial algorithms can beat the  factor, and indeed, this has been explicitly posed as an open problem
by Trevisan~\cite{Tre09}. Combinatorial algorithms are appealing because they exploit deeper insight into the combinatorial structure of the problem, and because they can usually be implemented easily and efficiently, typically without numerical round-off issues.






\subsection{Our contributions}

1. In this paper, we achieve this goal of a combinatorial approximation
algorithm for \maxcut. We analyze a very natural, simple, and combinatorial
heuristic for finding the \maxcut of a graph, and show that it actually manages
to find a cut with an approximation factor strictly greater than . In fact, we really
have a suite of algorithms:
\begin{theorem} \label{thm:main}
For any constant , there is a combinatorial algorithm
that runs in  time and provides
an approximation factor that is a constant greater than .
\end{theorem}
The running time/approximation factor tradeoff curve is
shown in Figure~\ref{fig:simple-balance}. A few representative numbers: in
, , and  times, we can get
approximation factors of , , and  respectively. As 
becomes large, this converges to the ratio of Trevisan's algorithm.


2. Even though the core of our algorithm is completely combinatorial, relying only on simple random walks and integer operations, the analysis of the algorithm is based on spectral methods. We obtain a combinatorial version of Trevisan's algorithm by showing two key facts: (a) the ``flipping signs'' random walks we use corresponds to running the power method on the graph Laplacian, and (b) a random starting vertex yields a good starting vector for the power method with constant probability. These two facts replace numerical matrix computations with the combinatorial problem of estimating certain probabilities, which can be done effectively by sampling and concentration bounds. This also allows improved running times since we can selectively find portions of the graph and classify them.

3. A direct application of the partitioning procedure yields an algorithm whose running time is . To design the sub-quadratic time algorithm, we have to ensure that the random walks in the algorithm mix rapidly. To do this, we design a sort of a local graph partitioning algorithm of independent interest based on simple random walks of logarithmic length. Given a starting vertex ,
either it finds a low conductance cut or certifies that the random walk from  has somewhat mixed, in the sense that the ratio of the probability of hitting any vertex  to its probability in the stationary distribution is bounded. The work done per vertex output in the cut is sublinear in . The precise statement is given in Theorem~\ref{thm:max}.
Previous local partitioning algorithms~\cite{ST04, ACL06, AL08} are more efficient than our procedure, but
can only output a low conductance cut, if the actual conductance of some set containing  is .
In this paper, we need to be able to find low conductance cuts in more general settings, even if there is no cut of conductance of , and hence the previous algorithms are unsuitable for our purposes.




\subsection{Related work}

Trevisan~\cite{Tre05} also uses random walks to give approximation algorithms for \maxcut (as a special case of unique games), although the algorithm only deals with the case when \maxcut is .
The property tester for bipartiteness in sparse graphs
by Goldreich and Ron~\cite{GR99} is a sublinear time procedure that uses
random walks to distinguish
graphs where  from .
The algorithm, however, does not actually give an approximation to \maxcut.
There is a similarity in flavor to Dinur's proof of the PCP theorem~\cite{Din05},
which uses
random walks and majority votes for gap amplification of CSPs.
Our algorithm might be seen as some kind of belief
propagation, where messages about labels are passed around.

For the special case of cubic and maximum
degree  graphs, there has been a study of combinatorial
algorithms for \maxcut~\cite{BL86,ELZ04,BT08}. These
are based on graph theoretic properites and very different
from our algorithms. Combinatorial algorithms for CSP
(constraint satisfaction problems) based on LP
relaxations have been studied in~\cite{DDFGMP03}.



\section{Algorithm Overview and Intuition}

Let us revisit the greedy algorithm. We currently have a partial
cut, where some subset  of the vertices have been classified (placed
in either side of the cut). We take a new vertex  and look at the
edges of  incident to . In some sense, each such edge provides
a ``vote" telling  where to go.
Suppose there is such an edge , such that .
Since we want to cut edges, this edge tells  to be placed in .
We place  accordingly to a majority vote, and hence the  factor.

Can we take that idea further, and improve on the  factor?
Suppose we fix a source vertex  and
try to classify vertices with respect to the source.
Instead of just looking at edges (or paths of length ),
let us look at longer paths. Suppose we choose a length
 from some nice distribution (say, a binomial
distribution with a small expectation)
and consider paths of length  from .
If there are many more even length paths to  than odd length
paths, we put  in , otherwise in .
This gives a partition of vertices that we can reach,
and suggests an algorithm based on random walks.
We hope to estimate the odd versus even length probabilities
through random walks from . This is a very natural
idea and elegantly extends the greedy approach. Rather
surprisingly, we show that this can be used to beat
the  factor by a constant.

One of the main challenges is to show that we do not
need too many walks to distinguish these various
probabilities. We also need to choose our length
carefully. If it is too long, then the odd and even path
probabilities may become too close to each other.
If it is too short, then it may not be enough to
get sufficient information to beat the greedy
approach.


Suppose the algorithm detects that the probability of going from vertices  to  by an odd length path is significantly higher than an even length path. That suggests that we can be fairly confident that  and  should be on different sides of the cut.
This constitutes the core of our algorithm, \Threshold. This algorithm classifies some vertices as lying on ``odd'' or ``even'' sides of the cut based on which probability (odd or even length paths) is significantly higher than the other.  Significance is decided by a threshold that is a parameter to the algorithm. We show a connection between this algorithm and Trevisan's, and then we adapt his (and Soto's) analysis to show that one can choose the threshold carefully so that amount of work done per classified vertex is bounded, and the number of uncut edges is small. The search for the right threshold is done by the \Find algorithm.

Now, this procedure leaves some vertices unclassified, because no probability is significantly larger than the other. We can simply recurse on the unclassified vertices, as long as the the cut we obtain is better than the trivial  approximate cut. This constitutes the \Simple algorithm. The analysis of this algorithm shows that we can bound the work done per vertex is at most  for any constant , and thus the overall running time becomes . This almost matches the running time of Trevisan's algorithm, which runs in  time.


To obtain a sub-quadratic running time, we need to do a more careful analysis of the random walks involved. If the random walks do not mix rapidly, or, in other words, tend to remain within a small portion of the graph, then we end up classifying only a small number of vertices, even if we run a large number of these random walks. This is why we get the  work per vertex ratio.

But in this case, we can exploit the connection between fast mixing and high conductance~\cite{sinclair, M89, LS90} to conclude that there must be a low conductance cut which accounts for the slow mixing rate. To make this algorithmic, we design a local graph partitioning algorithm based on the same random walks as earlier. This algorithm, \CutOrBound, finds a cut of (low) constant conductance if the walks do not mix, and takes only around  time, for any constant , per vertex found in the cut. Now, we can remove this low conductance set, and run \Simple on
the induced subgraph. In the remaining piece, we recurse. Finally, we combine the cuts found randomly.
This may leave up to half of the edges in the low conductance cut uncut, but that is only a small constant fraction of the total number of edges overall. This constitutes the \Balance algorithm. We show that we spend only  time for every classified vertex, which leads to a  overall running time.

All of these algorithms are combinatorial: they only need random selection of outgoing edges, simple arithmetic operations, and comparisons. Although the analysis is technically involved, the algorithms themselves are simple and easily implementable.


\section{The Threshold Cut} \label{sec:cut}

We now describe our core random walk based procedure to partition vertices.
Some notation first.
The graph  will have  vertices. All our algorithms will be based on lazy
random walks on  with self-loop probability . We define these walks now. Fix a
length . At each step in the random walk, if we are currently
at vertex , then in the next step we stay at  with probability .
With the remaining probability (), we choose a random incident edge  with probability proportional to  and move to . Thus the edge
 is chosen with overall probability , where  is the (weighted) degree of vertex . Let
 be an upper bound on the maximum degree. By a linear time reduction of
Trevisan~\cite{Tre01,Tre09}, it suffices to solve \maxcut on graphs\footnote{We
can think of these as unweighted multigraphs.} where .
We set  to be sum of weighted degrees, so . We note that by
Trevisan's reduction, , and thus running times stated in terms
of  translate directly to the same polynomial in .


The random walk described above is equivalent to flipping an unbiased coin  times, and running a simple (non-lazy) random walk for  steps, where  is the number of heads seen. At each step of this simple random walk, an outgoing edge is chosen with probability proportional to its weight. We call  the {\em hop-length} of the random walk, and we call a walk odd or even based on the parity of .


We will denote the two sides of the cut by  and . The parameters  and  are fixed throughout this section, and should
be considered as constants. We will choose the length  of the
walk to be 
(the reason for this choice will be explained later). We will assume that  and  are arbitrarily small constants. The procedure {\Threshold} takes as input a \emph{threshold} , and puts \emph{some} vertices in one of two sets,  and , that are assumed to be global variables (i.e. different calls to \Threshold update the same sets). We call vertices  {\em classified}. Once classified, a vertex is never re-classified. We perform a series of random walks to decide this. The number of walks will be a function of this threshold .
We will specify this function later.
\begin{center}
\fbox{\begin{minipage}{\columnwidth} \Threshold \ \ \ \ \ {\bf Input:} Graph . \ \ \ \ {\bf Parameters:} Starting vertex , threshold .
\begin{enumerate*}
    \item Perform  walks of length  from .
    \item For every vertex  that is not classified:
    \begin{enumerate*} \item Let jj.
	    \item If , put  in set . If , put it in set .
		\end{enumerate*}
\end{enumerate*}
\end{minipage}}
\end{center}

We normalize the difference of the number of even and odd walks by  to
account for differences in degrees. This accounts for the fact that the
stationary probability of the random walk at  is proportional to . For
the same reason, when we say ``vertex chosen at random" we will mean choosing a
vertex  with probability proportional to . We now need some definitions.
\begin{Def}[Work-to-output ratio.]
Let  be an algorithm that, in time , classifies  vertices (into the sets  or ). Then the work-to-output ratio of  is defined to be .
\end{Def}
\begin{Def}[\good, \cross, \inc, \cut.] \label{def:cut}
Given two sets of vertices  and , let  be the total weight of edges that have one endpoint in  and the other in . Let  be the total weight of edges with only one endpoint in . Let  be the total weight of edges incident on . We set .
\end{Def}

Suppose we either put all the vertices in  in  or , and the vertices in
 in  or  respectively, retaining whichever assignment cuts more
edges. Then the number of edges cut is at least .



\begin{Def}[, , , .] \label{def:alpha-sigma-etc}
\begin{enumerate}
    \item For every vertex , let  be the probability of reaching 
    starting from  with an -length lazy random walk.
    Let  be an upper bound on .

    \item Define , for a large enough constant .

    \item Define , where the  term can be made as small as we please by setting  to be sufficiently small constants.

    \item Define the function  (c.f. \cite{Sot09})
as follows: here  is a fixed constant. If , then  . If , then
    .
    Otherwise, .
\end{enumerate}
\end{Def}

The parameter  measures how far the walk is from mixing, because the stationary probability of  is proportional to . The function  when , and this leads to an approximation factor greater than . Now we state our main performance bound for \Threshold.
\begin{Lem} \label{lem:threshold-perf}
Suppose . Then, there is a threshold  such that with constant probability over the choice of a starting vertex  chosen at random, the following holds. The procedure  outputs sets  and  such that
. Furthermore, the work-to-output ratio is bounded by .
\end{Lem}


The main procedure of this section, {\Find}, is just an algorithmic version of
the existential result of Lemma~\ref{lem:threshold-perf}.



\begin{center}
\fbox{\begin{minipage}{\columnwidth} {\Find} \ \ \ \ \ {\bf Input:} Graph . \ \ \ \ {\bf Parameters:} Starting vertex 
\begin{enumerate*}
    \item Initialize sets  and  to empty sets.
    \item For , for , as long as . \begin{enumerate*}
			\item Run \Threshold.
\item If 
	    and , output  and . Otherwise go to the next threshold.
	  \end{enumerate*}
	  \item Output FAIL.
\end{enumerate*}
\end{minipage}}
\end{center}
We are now ready to state the performance bounds for \Find.

\begin{Lem} \label{lem:find} Suppose . Let  be chosen at random.
With constant probability over the choice of  and the randomness of
, the procedure  succeeds and has a work to output ratio of
. Furthermore, regardless of the
value of \maxcut or the choice of , the worst-case running time of
 is .
\end{Lem}

The proofs of Lemmas~\ref{lem:threshold-perf} and~\ref{lem:find} use
results from Trevisan's and Soto's analyses~\cite{Tre09,Sot09}.
The vectors we consider will always be -dimensional,
and should be thought of as an assignment of values to each of the  vertices
in .
Previous analyses rest on the fact that a vector
that has a large Rayleigh quotient
(with respect to the graph Laplacian\footnote{For a vector 
and matrix , the Rayleigh quotient is .}) can be
used to find good cuts. Call such a vector ``good".
These analyses show that partitioning vertices by \emph{thresholding} over
a good vector  yields a good cut. This means that for some threshold ,
vertices  with  are placed in  and those with 
are placed in .
We would like to show that {\Threshold} is
essentially performing such a thresholding on some good vector. We will construct a vector,
somewhat like a distribution, related to {\Threshold}, and show that it is
good. This requires an involved spectral
analysis. This is formalized in Lemma~\ref{lem:good-q}. With this
in place, we use concentration inequalities and an adaptation of the techniques
in~\cite{Sot09} to connect thresholding to the cuts looked at by {\Find}.
We first state Lemma~\ref{lem:good-q}. Then we will show how
to prove Lemmas~\ref{lem:threshold-perf} and~\ref{lem:find} using Lemma~\ref{lem:good-q}.
This is rather involved, but intuitively should be fairly clear.
It mainly requires understanding of
the random process that {\Threshold} uses to classify vertices.

We need some
definitions. Let  be the (weighted) adjacency matrix of  and 
be the degree of vertex .  The (normalized) Laplacian of the graph is . Here  is the matrix where  and
 (for ). For a vector  and coordinate/vertex , we use 
to denote the th coordinate of  (we do \emph{not} use subscripts
for coordinates of vectors).
In~\cite{Tre09} and~\cite{Sot09}, it was shown
that vectors that have high Rayleigh quotients with 
can be used to get a
partition that cuts significant number of edges. Given a vector , let us do
a simple rounding to get partition vertices. We define the sets  and . We refer to
rounding of this form as \emph{tripartitions}, since we divide the vertices
into three sets. The following lemma, which is Lemma 4.2 from~\cite{Sot09}, an
improvement of the analysis in~\cite{Tre09}, shows that this tripartition cuts
many edges for some threshold:

\begin{Lem}\label{lem:soto} (\cite{Sot09}) Suppose .
Let .
Then, for some  (called \emph{good}),
.
\end{Lem}

The algorithm of Trevisan is the following: compute the top eigenvector  of  (approximately), compute , and find a good threshold  and the corresponding sets . Assign  or  to  and  (or vice-versa, depending on which assignment cuts more edges), and recurse on the remaining unclassified vertices.

The algorithms of this paper essentially mimic this process, except that
instead of computing the top eigenvector, we use random walks. We establish a
connection between random walks and the power method to compute the top
eigenvector. Let  be the probability that a length  (remember that this
is fixed) lazy
random walk from  reaches  with hop-length . Then define the vector
 as follows: the th coordinate of  is 

Note that {\Threshold} is essentially computing an estimate 
of . For convenience, we will denote  by .
This is the main lemma of this section.
\begin{Lem}\label{lem:good-q}
Let  be a sufficiently small constant, and  be
a (constant) parameter.
If , where , then
with constant probability over the choice of ,
, and

\end{Lem}

Although this not at all straightforward, it appears that Lemma~\ref{lem:good-q}
with Lemma~\ref{lem:soto} essentially proves Lemma~\ref{lem:threshold-perf}.
To ease the flow of the paper, we defer these arguments to Section~\ref{sec:thresh}.

Lemma~\ref{lem:good-q} is proved in two parts. In the first, we establish a connection
between the random walks we perform and running the power method on the
Laplacian:
\begin{claim} \label{lem:lap-rw} Let  be  standard basis vector. Then, we
have
.
\end{claim}
\begin{myproof} Note that . Hence,

The last equality follows because the vector  is
the vector of probabilities of reaching different vertices starting from  in a walk of length  with hop-length exactly . We also used the
facts that  and .
\end{myproof}\\




In the second part, we show that with constant probability, a randomly chosen starting vertex yields a good starting vector for the power method, i.e., the vector  satisfies (\ref{eq:lap-q}). This will require a spectral analysis.  We need some notation first.
Let the eigenvalues of  be , and let the corresponding (unit) eigenvectors be .
For a subset  of vertices, define . Let . Any vector  can be
expressed in terms of the eigenvectors of  as .
Define the norm .

Let  be the max-cut, where we use the convention . Let  and define
. Note that . Since the max-cut has size at least , we must have .
We set the vector  where 
where  is the indicator vector for . We will need some
preliminary claims before we can show (\ref{eq:lap-q}).

\begin{claim} \label{clm:hnorm-x} .
\end{claim}

\begin{myproof} We have
 Now\footnote{This is easily seen using Pythagoras: since . This
only uses the fact that .},
.
Let  be the
representation of  in the basis given by the 's, and let . Then we have , and


Combining the two bounds, and solving for , we get the required bound for small enough .
\end{myproof}


\begin{claim} \label{clm:hnorm-e}
With constant probability over the choice of , .
\end{claim}
\begin{myproof} Let , and let . Our aim is to show that
 is at most a constant fraction of . For the sake of
contradiction, assume ,
where . Let .
We have

The second equality above uses the fact that  and .
The third inequality follows from .
By the triangle inequality and Claim~\ref{clm:hnorm-x}, we have

Now, we have ,
so by Jensen's inequality, we get
 a contradiction.
The equality in the chain above holds because  has no component along
the eigenvectors corresponding to  (this is an eigenvector itself,
with eigenvalue ).

Thus the set  has volume at least . Note that the sampling process, which chooses
the initial vertex of the random walk by choosing a random edge and choosing a
random end-point  of it, hits some vertex in  with probability
at least , i.e. constant probability.
\end{myproof}
\medskip

At this point, standard calculations for the power method imply Lemma~\ref{lem:good-q}. \\

\begin{myproof}(Of Lemma~\ref{lem:good-q})
From Claim~\ref{clm:hnorm-e}, with constant probability . Let us assume this is case.

For convenience, define , so that the number of walks is .  Now let .
Write  in terms of the 's as
. Let . Note that . Then we have

and

We have

Thus,

Observe that  is just a scaled version of , so we
can replace  by  above. For the denominator in the right,
we would like to set that to be . Choosing
, we get



Since , we have


This implies


By definition, for all , .
This gives a lower bound on the rate of decay of these coefficients,
as the walk progresses.

by our choice of .
\end{myproof}


\subsection{Proofs of Lemmas~\ref{lem:threshold-perf} and~\ref{lem:find}} \label{sec:thresh}

Both Lemma~\ref{lem:find} and
Lemma~\ref{lem:threshold-perf} follow directly
from the following statement.

\begin{Lem} \label{lem:good-thresh} Let , where
 is a sufficiently large constant. Let  denote the set of vertices
classified by \Threshold.
The following hold with constant probability
over the choice of  and the randomness of {\Threshold}.
There exists a threshold  such
that .
Also, the tripartition generated satisfies Step 2(b) of {\Find}.
\end{Lem}

In this section, we will prove this lemma. But first,
we show how this implies Lemmas~\ref{lem:threshold-perf}
and~\ref{lem:find}.\\

\begin{myproof} (of Lemma~\ref{lem:threshold-perf}) We take
the threshold  given by Lemma~\ref{lem:good-thresh}.
Since it satisfies Step 2(b) of {\Find},
. To see the work
to output ratio, observe that the work done is . It is convenient
to write this as .
The output is . We have

The output is at least . Therefore, the work per
output is at most .
\end{myproof}\\

\begin{myproof} (of Lemma~\ref{lem:find}) The running time when there
is failure is easy to see. The running time upto round 
is .
Since  and , we get the desired bound.
By Lemma~\ref{lem:good-thresh}, we know that {\Find} succeeds with high probability.
We have some round  where {\Find} will
terminate (satisfying the conditions of Step 2(b)).
The work to output ratio analysis is the same as the previous
proof, and is at most .
\end{myproof}\\

We will first need some auxilliary claims that
will help us prove Lemma~\ref{lem:good-thresh}.
The first step
is the use concentration inequalities to bound
the number of walks required to get coordinates of .
As mentioned before, we designate the coordinates of  by . The 
vector is the probability vector of the random walk (without charges)
for  steps. In other words:

and

This clearly shows that the random walks performed
by \Threshold{} are being used to estimate coordinates of .
The following claim shows how many  walks are required
to get good a approximation of coordinates .

\begin{claim} \label{clm:est-qi} Suppose  walks are performed. Let
 be a sufficiently large constant and . The following
hold with probability at least .
\begin{itemize}
	\item If , then we can get
	an estimate  such that .
	\item If , then we can get
	an estimate  such that ,
	where .
\end{itemize}
\end{claim}

\begin{myproof} We define a vector of random variables , one
for each walk.
Define random variables  as follows:

Note that , and . Our estimate
 will be .
Observing that , Bernstein's inequality implies that
for any ,

For the first part, we set . For a sufficiently large ,
We get that the exponent is at least , and hence the probability
is at most . For the second part, we set .
Note that if , then .
So, the exponent is at least , completing the proof.
\end{myproof}\\


We need to find a vector with a large Rayleigh
quotient that can be used in Lemma~\ref{lem:soto}. We already have a candidate
vector . Although we get a very good approximation of this, note that
the order of vertices in an approximation can be very far from .
Nonetheless, the following lemma allows us to do so.

\begin{claim} \label{clm:close}
Let  be a vector such that . Then,
if  is a vector such that , then
 and .
\end{claim}
\begin{myproof}
We have
 Thus,
 Furthermore,
 Thus, we have

\end{myproof}


Now we prove Lemma~\ref{lem:good-thresh}.

\begin{myproof} Our cutting procedure is somewhat different from the
sweep cut used in~\cite{Tre09}. The most naive cut algorithm would
take  and perform a sweep cut. Lemma~\ref{lem:good-q} combined
Lemma~\ref{lem:soto} would show that we can get a good cut. Unfortunately,
we are using an approximate version of  () for this purpose.
Nonetheless, Claim~\ref{clm:est-qi} tells us that we can get
good estimates of , so  is close to . Claim~\ref{clm:close}
tells us that  is good enough for all these arguments to go through
(since Lemma~\ref{lem:soto} only requires a bound on the Rayleigh quotient).

Our algorithm {\Find} is performing a geometric search for the right
threshold, invoking {\Threshold} many times. In each call
of the {\Threshold}, let estimate vector 
be generated. Using these, we will construct a vector .
This construction is not done by the algorithm, and is only
a thought experiment to help us analyze {\Find}.

Initially, all coordinates of  are not defined, and we
incrementally set values. We will call {\Threshold}
in order, just as {\Find}. In the call to {\Threshold},
we observe that vertices which are classified. These are
the vertices  for which  and
which have not been classified before. For all such ,
we set . We then proceed to the next
call of {\Threshold} and keep continuing until
the last call. After the last invocation of {\Threshold},
we simply set any unset  to .

\begin{claim} \label{clm:qti} 
\end{claim}

\begin{myproof} Suppose . Note that .
Therefore,

So  must be set in round , if not before. If  remains
unset to the end (and is hence ), then .
This implies that . The total contribution
of all these coordinates to the difference  is
at most .

Suppose  is set in round  to . This means
that . By the choice of  and Claim~\ref{clm:est-qi},
.
Therefore,

Combining with the first part, we get .
\end{myproof}\\

We now observe that sweep cuts in  generate \emph{exactly}
the same classifications that {\Threshold} outputs.
Therefore, it suffices to analyze sweep cuts of .
We need to understand why there are thresholds that cut away many vertices.
Observe that the coordinates of  are of the form .
This vector partitions all vertices in a natural way.
For each , define .
Call  \emph{sparse}, if

Otherwise, it is \emph{dense}.
Note that a dense threshold exactly satisfies the condition
in Lemma~\ref{lem:good-thresh}.
Abusing notation, we call a vertex  sparse if , such
that  is sparse. Similarly, a threshold  is sparse if 
is sparse. We construct a vector .
If , for  sparse, then .
Otherwise, .

\begin{claim} \label{clm:dense} 
\end{claim}

\begin{myproof}

\end{myproof}

Let us now deal with the vector  and perform the sweep cut
of~\cite{Tre09}.
All coordinates of  are at most . We choose a threshold
 at random: we select  uniformly at random\footnote{Both~\cite{Tre09}
and~\cite{Sot09} actually select  uniformly at random, and use  as
a threshold. We do this modified version because it is more natural, for our
algorithm, to think of the threshold as a lower bound on the probabilities
we can detect.} from . We do a rounding
to get the vector :

The non-zero vertices in  are classified accordingly.
A \emph{cut} edge is one both of whose endpoints are non-zero
and of opposite size. A \emph{cross} edge is one where
only one endpoint is zero.
This classifying procedure is shown to cut a large
fraction of edges. By Lemma~\ref{lem:good-q}, we have
 (where 
is some function of  and ).
By Claims~\ref{clm:qti},~\ref{clm:dense} and Claim~\ref{clm:close},
.
Then, by Lemma~\ref{lem:soto}, there are good thresholds for .
It remains to prove the following claim.

\begin{claim} \label{clm:couple} There are thresholds for 
that are dense \emph{and} good.
\end{claim}

\begin{myproof} We follow the analysis of~\cite{Sot09}.
We will perform sweep cuts for both  and 
and follow their behavior.
First, let take the sweep cut over .
Consider the indicator random variable  (resp. ) that is 
if edge  is a cut (resp. cross) edge. It is then
show that ,
where the expectation is over the choice of the threshold .
Let us define a slight different choice of random thresholds.
As before  is chosen uniformly at random from .
Then, we find the smallest  such that  is dense
and . We use this  as the threshold for the cut.
Observe that this gives the \emph{same} distribution over
cuts as the original and \emph{only} selects dense thresholds. This is because in  all non-dense
vertices are set to . All thresholds strictly in
between two consective dense 's output the same
classification. The expectations of  and 
are still the same.

We define analogous random variables  and  for .
We still use the distribution over dense thresholds
as described above. When both  and  are dense,
we note that  and .
This is because if  falls below, say,  (which is equal to
), then  will be cut. Even though ,
it will not cross , since  is dense.
So, we have .

If both  and  are not dense, then .
Therefore, .
That leaves the main case, where  is dense but  is not.
Note that , since .
We have .
If , then
.
If , then
.
So, we can bound 
and .

Summing over all edges, and applying the bound in Lemma 4.2 of~\ref{lem:soto}
for the non-prime random variables (dealing with ), we get

The second last step comes from the bound on  we have found,
and the observation that  will always be set to less than .
We have  (based on Lemma~\ref{lem:good-q}.
Since , we get  as given
in Lemma~\ref{lem:find}. Because of the equations above, the analysis
of~\cite{Sot09} shows that the randomly chosen threshold 
has the property that

Therefore, some threshold satisfies the condition 2(b) of {\Find}.
Note that the thresholds are chosen over a distribution of dense
thresholds. Hence, there is a good and dense threshold.
\end{myproof}

\end{myproof}





\section{\CutOrBound and local partitioning}
\def\ptil{\tilde{p}}
\def\Itil{\tilde{I}}
\def\Stil{\tilde{S}}
We describe our local partitioning procedure
{\CutOrBound} which is used to get the improved
running time. We first set some notation.
For a subset of vertices , define , and let  be the \emph{set} of edges crossing the cut . Define the {\em weight} of  to be , to account for the self-loops of weight : we assume that each vertex has a self-loop of weight
, and the random walk simply chooses one edge with probability
proportional to its weight. For convenience, given a vertex , .
For a subset of edges , let . The conductance of the set
, , is defined to be
.

\begin{center}
\fbox{\begin{minipage}{\columnwidth} \CutOrBound \ \ \ \ \ {\bf Input:} Graph . \ \ \ \ {\bf Parameters:} Starting vertex , .
\begin{enumerate*}
    \item Define  to satisfy , , .

	\item Run  random walks of length  from .

	\item For each length :
	\begin{enumerate*}
		\item For any vertex , let  be the number of walks of length  ending at . Order the vertices in decreasing order of the ratio of , breaking ties arbitrarily.

		\item For all , compute the conductance of
		the set of top  vertices in this order.

		\item If the conductance of any such set is less than , stop and
		output the set.
	\end{enumerate*}

	\item Declare that 
\end{enumerate*}
\end{minipage}}
\end{center}
The main theorem of this section is:
\begin{theorem} \label{thm:max}
Suppose a lazy random walk is run from a vertex  for  steps, for some constant . Let  be the probability distribution induced on the final vertex.
Let , for constant , be a given parameter so that , and let  be chosen to satisfy .
Then, there is an algorithm \CutOrBound, that with probability , in  time, finds a cut
of conductance less than , or declares correctly that .
\end{theorem}
We provide a sketch before giving the detailed proof.
We use the Lov\'{a}sz-Simonovits curve technique~\cite{LS90}.
For every length , let  be the probability vector induced on vertices after running a random walk of length .
The Lov\'{a}sz-Simonovits curve  is constructed as follows. Let  be an ordering of the vertices
such that .

For , define the set . For convenience, we
define , the empty set. For a subset of vertices , and a
probability vector , define . Then, we define
the curve  at the following points: ,
for  Now we complete the curve  by
interpolating between these points using line segments.
Note that this curve is concave because the slopes of the line segments are
decreasing. Also, it is an increasing function. Lov\'{a}sz and Simonovits
prove that as  increases,  ``flattens" out, at a rate
governed by the conductance. A flatter  means that the probabilities
at vertices are more equal (slopes are not very different), and hence
the walk is mixing.

Roughly speaking, the procedure {\CutOrBound} only looks the portion
of  upto , since it only tries to find sweep cuts among the
top  vertices. We would like to argue that if {\CutOrBound}
is unsuccessful in finding a low conductance cut there, the
maximum probability should be small. In terms of the s,
this means that the portion upto  flattens out rapidly.
In some sense, we want to prove versions of theorems
in~\cite{LS90} that only talk about a prefix of the
 curves.

The issue now is that it is not possible to compute the 's (and )
exactly since we only use random walks. We run walks
of length  and get an empirical distribution
. We define  to be the
corresponding Lov\'{a}sz-Simonovits curve corresponding to
. If we run sufficiently many random walks and aggregate them to compute , then concentration bounds imply that  is close
to  (when  is large enough). Ideally, this should imply
that the behavior of  is similar to .
There is a subtle difficulty here. The \emph{order}
of vertices with respect to  and  could
be very different, and hence prefixes in the  and
 could be dealing with different subsets
of vertices. Just because  is flattening, it is
not obvious that  is doing the same.

Nonetheless, because for large 's,
 is a good approximation, some sort
of flattening happens for . We give some
precise expressions to quantify this statement. Suppose
{\CutOrBound} is unable to find a cut of conductance .
Then we show that for any , if ,

This is the flattening from  to . Since  is concave, the
averaging in the first part shows that  is much smaller than
. Note that additive error term, which does not occur
in~\cite{LS90}. This shows that when  is large, this bound is not
interesting. That is no surprise, because we can only sample some prefix of
. Then, we prove by induction on  that, if we define , then
.
Assuming that ,  the  term decays very
rapidly. For the final , we are only left with the error term, which will be . We then get
.


\subsection{Proof of Theorem~\ref{thm:max}} \label{sec:ls}

First, we note that , so . Consider the following algorithm:


It is easy to see that this algorithm can be implemented to run in time . We now prove that this algorithm has the claimed behavior. We make use of the Lov\'{a}sz-Simonovits curve technique. For every length , let  be the probability vector induced on vertices after running a random walk of length .

Now, we construct the Lov\'{a}sz-Simonovits curve~\cite{LS90},  as follows. Let  be an ordering of the vertices
as follows:

For , define the set . For convenience, we
define , the empty set. For a subset of vertices , and a
probability vector , define . Then, we define
the curve  at the following points: ,
for  Now we complete the curve  by
interpolating between these points using line segments. Note that the slope of
the line segment of the curve at the points  is
exactly .  A direct definition of the
curve is the following: for any point , if  is the unique
index where , then 

An useful alternative definition for  is the following:


Note that this curve is concave because the slopes of the line segments are
decreasing. Also, it is an increasing function. Now, Lov\'{a}sz and Simonovits prove the following facts about the
curve: let  be any set of vertices, and let  and  be its conductance.
For , define . Then, we have the following:

Furthermore, for any , we have
.

The issue now is that it is not possible to compute the 's exactly since we only use random walks. Fix an error parameter . In the algorithm \CutOrBound, we run  walks of length , where . For each length
, , consider the empirical distribution 
induced by the walks on the vertices of the graph, i.e. , where  is the number of walks of length  ending at . We search for low conductance cuts by ordering the vertices in decreasing order of  and checking the sets of top  vertices in this order, for all . This takes time . To show that this works,
first, define  be the Lov\'{a}sz-Simonovits curve corresponding to
. Then, we have the following:
\begin{Lem} \label{lem:concentration-ptil}
With probability , the following
holds. For every vertex subset of vertices , we have

For every length , and every ,

\end{Lem}
\begin{myproof}
For any vertex , define . By Bernstein's
inequality, we have  since . So
with probability at least , for all lengths , and for all vertices
, we have  Assume this is the case. This immediately
implies that for any set , we have 

Now, because both curves  and  are piecewise linear, concave and
increasing, to prove the lower bound in the claimed inequality, it suffices to
prove it for only , for . So fix
such an index .

Now, . Consider . We have
 Now, the alternative
definition of the Lov\'{a}sz-Simonovits curve (\ref{eq:alt-def}) implies that
, so we get  as required. The upper bound is
proved similarly, considering instead the corresponding sets 
for  consisting of the top  vertices in  probability.
\end{myproof}



The algorithm \CutOrBound can be seen to be searching for low conductance cuts in the top  vertices in the order given by . Now, we prove that if we only find large conductance cuts, then the curve  ``flattens'' out rapidly. Let  be this order.
Let  be the set of top  vertices in the order, , and  be the conductance of . Now we are ready to show our flattening lemma:
\begin{Lem} \label{lem:ls-chords-empirical} With probability , the
following holds. Suppose the algorithm \CutOrBound finds only cuts of conductance  when sweeping over the top  vertices in  probability. Then, for any index , we have

\end{Lem}
\begin{myproof}
Let .
We have , so .

As defined in the algorithm \CutOrBound, let . Let  be the largest index so that . If , then let  be the set of  vertices  of zero  probability considered by algorithm \CutOrBound for searching for low conductance cuts. We assume that in choosing the ordering of vertices to construct , the vertices in  appear right after the vertex . This doesn't change the curve  since the zero  probability vertices may be arbitrarily ordered.


Suppose that the algorithm \CutOrBound finds only cuts of conductance at least
 when running over the top  vertices. Then, let  be some index in . We consider two cases for the index
:\\
{\bf Case 1:} :\\
In this case, since the sweep only yielded cuts of conductance at least , we have . Then (\ref{eq:ls-chords}) implies that


\noindent{\bf Case 2:}  :\\
We have
 Thus,
.
Hence, the slope of the curve  at the point 
is at most . Since the curve  is concave and
increasing, we conclude that

and

Since ,

This completes the proof of the lemma.
\end{myproof}


Since the bounds of Lemma~\ref{lem:concentration-ptil} hold with probability , we assume from now on that is indeed the case for all lengths . Thus, we conclude that if we never find a cut of conductance at most , and for any index , we have

Here, we use the facts that , and . Now, because  is a piecewise linear and concave
function, where the slope only changes at the  points, the above
inequality implies that for all , we have

Here, we used the bound .

Now, assume that we never find a cut of conductance at most  over all lengths . Define . Note that . Then, we prove by induction on  that
 The statement for  is easy to see, since the curve
 (recall that we start the walk at vertex ).
Assuming the truth of this bound for , we now show it for . We have

which completes the induction. In the last step, we used the following bounds:
if , then
 and if , then

Since , we get

assuming , , and . Finally, again invoking Lemma~\ref{lem:concentration-ptil}, we get that , since .



\section{Recursive partitioning} \label{sec:algo}

Given the procedure {\Find}, one can construct
a recursive partitioning algorithm to approximate the
{\maxcut}.
We classify some vertices through {\Find}, remove them,
and recurse on the rest of the graph. We call
this algorithm {\Simple}. The algorithm {\Balance}
uses the low conductance sets obtained from
Theorem~\ref{thm:max} and does a careful
balancing of parameters to get an improved
running time. All proofs of this section, including theoretical guarantees on approximation factors, are in Appendix~\ref{app:algo}. We state the procedure {\Simple}
first and provide the relevant claims.



\begin{center}
\fbox{\begin{minipage}{\columnwidth} \Simple \ \ \ \ \ {\bf Input:} Graph . \ \ \ \ {\bf Parameters:} .
\begin{enumerate*}
		\item If , then put each vertex
		in  or  uniformly at random (and return).
    \item Let  be a set of  vertices chosen uniformly at random.
    \begin{enumerate*}
    	\item For all , run procedures {\Find} in parallel. Stop when any one of these
    	succeeds or all of them fail.
    \end{enumerate*}
    \item If all procedures failed, output FAIL.
    \item \label{step} Let the successful output be the set  and . With
    probability , put  in  and  in . With probability ,
    do the opposite.
    \item Let . Set  and  be the induced
    subgraph on unclassified vertices. Run {\Simple}.
    If it succeeds, output the final cut  and .
    \item If  is the original graph, put each vertex (even those already classified)
    randomly in  or . Irrespective of , output FAIL.
\end{enumerate*}
\end{minipage}}
\end{center}

The guarantees
of {\Simple} are in terms of a function .
For a given  and , let  be the largest value
such that .
Then . For constant ,  is a constant
.

\begin{Lem} \label{lem:simple} Let .
There is an algorithm {\Simple} that, with high probability,
outputs a cut of value , and thus the worst-case approximation ratio is . The running time is .
\end{Lem}
Tle algorithm {\Simple} is a version of {\Simple} that only takes  as a
parameter and searches for the appropriate value of . Suppose
. The procedure {\Simple} runs
{\Simple} (i.e. ), for all  such
that  and . By
choosing  small enough and Claim~\ref{clm:simple} below, we can ensure
that we cut at least  fraction of edges. It therefore
suffices to prove:
\begin{claim} \label{clm:simple}
If {\Simple} succeeds, it outputs a cut of (fractional) value at least
. If it fails, it outputs a cut of value . If
 , then {\Simple} succeeds with
high probability. The running time is always bounded by .
\end{claim}

We now describe {\Balance} and state the main lemma associated
with it. We observe that {\Balance} uses \CutOrBound to
either decompose the graph into pieces, or ensure
that we classify many vertices. We use Theorem~\ref{thm:max}
to bound the running time.

\begin{center}
\fbox{\begin{minipage}{\columnwidth} \Balance \ \ \ \ \  {\bf Input:} Graph .  \ \ \ \
{\bf Parameters:} .
\begin{enumerate*}
    \item Let  be a random subset of  vertices.
    \item For each vertex , run {\CutOrBound}.
    \item If a low conductance set  was found by any of the above calls:
    \begin{enumerate*}
    		\item Let  be the induced graph on , and  be the induced graph on .
    Run {\Simple} and {\Balance} (with same parameters) to get the final partition.
    \end{enumerate*}
   	\item Run {\Simple} up to Step~\ref{step}, using random vertex set .
   	Then run \Balance (with same parameters), where
		 is the induced graph on the unclassified vertices.
		\item Output the better of this cut and the trivial cut.
\end{enumerate*}
\end{minipage}}
\end{center}

\begin{Lem} \label{lem:balance}
For any constant , there is a choice of ,  and
 so that {\Balance} runs in  time and provides
an approximation factor that is a constant greater than .
\end{Lem}

Let us give a simple explanation for the -factor. Neglecting the 's and
polylogarithmic factors, we perform  walks in {\CutOrBound}. In
the worst case, we could get a low conductance set of constant size, in which
case the work per output is . When we have the  bound on
probabilities, the work per output is . So it appears that  is the balancing point, which yields an  time
algorithm.

In the next subsection, we define many parameters
which will be central to our analysis.
We then provide detailed proofs for Claim~\ref{clm:simple} and
Lemma~\ref{lem:balance}. Finally, we give a graph
detailing how the approximation factor increases with
running time (for both {\Simple} and {\Balance}).


\subsection{Preliminaries} \label{app:algo}

For convenience, we list the various free parameters and dependent variables.
\begin{itemize*}
	\item  is the maxcut parameter, as described above. Eventually, this will be set
	to some constant (this is explained in more detail later).
	\item  is a running time parameter. This is used to control the norm
	of the  vector, and through that, the running time. This affects the approximation
	factor obtained, through Lemma~\ref{lem:good-q}.
	\item  is the maximum probability parameter. This directly affects the running
	time through Lemma~\ref{lem:find}. For {\Simple}, this is just set to , so it
	only plays a role in {\Balance}.
	\item . This is the
	length of the random walk.
	\item  is the parameter that is in Lemma~\ref{lem:find}. Setting
	, we get .
	\item  is the cut parameter that comes from Theorem~\ref{thm:max}.
	When we get a set  of low conductance, the number of edges in the cut
	is at most . Here,  is the set
	of edges internal to . In Theorem~\ref{thm:max}, the number
	of cut edges in stated in terms of the conductance . We have
	. Also,  is at most .
	We will drop the dependence on , since it will be fixed (more details
	given later).
\end{itemize*}

We will also use some properties of the function .

\begin{Lem} \label{lem:H-properties}
For any fixed ,  is a convex, decreasing function of
. Furthermore, there is a value  such that .
\end{Lem}
\begin{myproof}
First, note that  is a decreasing function of . This is
because all the three functions that define  are decreasing in their
respective ranges, and the transition from one function to the next occurs
precisely at the point where the functions are equal.

Now, for any fixed ,  is a strictly increasing
function of , and hence,  is a
decreasing function of . Thus,  is a decreasing function of , since
for any fixed , the integrand  is a
decreasing function of .

For convenience of notation, we will use  and  to refer  and  respectively. Now define .
Doing this change of variables in the integral, we get . By the fundamental
theorem of calculus, we get that

Again applying the fundamental theorem of calculus, we get that
 since  is a decreasing function of . Thus,  is a convex
function of .

To show the last part, let  is the inverse function of
, keeping  fixed, and consider , by
making  and  small enough constants. For , we
have . Thus, we get

\end{myproof}


\subsection{Proof for {\Simple}}

As we showed in the main body, it suffices to prove
Claim~\ref{clm:simple}.

\begin{myproof} (of Claim~\ref{clm:simple}) This closely follows the analysis given
in~\cite{Tre09} and~\cite{Sot09}.
If any recursive call to \Simple fails, then the top
level algorithm also fails and outputs the trivial cut.

Suppose  is at least .
Then  is at least

Applying this inductively, we can argue that \emph{whenever} a recursive call
{\Simple} is made,  .
From Lemma~\ref{lem:good-q}, since  vertices are chosen in ,
with high probability, in \emph{every} recursive call, a good vertex
is present in . From Lemma~\ref{lem:find}, in every recursive call,
with high probability, some call to {\Find} succeeds. Hence, {\Simple} will
not output FAIL and succeeds.

Assuming the success of {\Simple}, let us compute the total number of edges cut. We denote the parameters of the th
recursive call to {\Simple} by subscripts of . Let the number of edges
in  be  (where ). Let  be the last call to {\Simple}.
We have .
Only for , we have that .
In the last round, we cut
 edges.
The number of cut
edges in other rounds is .
Summing over all , the total number of edges cut (as a fraction of ) is

The inequality comes about because  is a decreasing function
and  is an increasing function of .

We now bound the running time, using Lemma~\ref{lem:find}. Consider a successful iteration .
Suppose the number of vertices classified in this iteration is .
The total running time in iteration  is
. This is because we run the  calls
in parallel, so the running time is at most  times
the running time of the successful call. Summed over all
iterations, this is at most . Suppose
an iteration is unsuccessful, the total running time
is . There can only be one such iteration,
and the claimed bound follows.
\end{myproof}


\subsection{Proofs for {\Balance}}

We first give a rather complicated expression for the approximation ratio
of {\Balance}. First, for any , define . This is essentially the approximation factor of \Simple'.

\begin{claim} \label{clm:threehalf} The algorithm {\Balance} has a work to output ratio
of . The approximation ratio
is at least:

\end{claim}

\begin{myproof} First let us analyze the work per output ratio of \Balance.
We initially perform  walks. Suppose we get a low
conductance set . We then run {\Simple}.
Here, the work to output ratio is at most .
If we get a tripartition, the work to output ratio
is at most . Adding these, we get an
upper bound on the total work to output ratio.

Because we choose a random subset  of size ,
we will assume that Lemma~\ref{lem:simple} and Claim~\ref{clm:simple}
hold (without any error).
To analyze the approximation ratio, we follow the progress of the algorithm
to the end. In each iteration, either a low conductance set is removed,
or the basic algorithm is run. In each iteration, let us consider
the set of vertices this is assigned to some side of the final cut.
In case of a low conductance set, we get a cut for the whole set.
Otherwise, if we get a tripartition, the union 
will be this set. If we do not get a tripartition,
then we output the trivial cut (thereby classifying all remaining vertices).
Let us number the low conductance sets
as . The others are denoted .
We will partition the edges of  into parts, defining subgraphs.
The subgraph  consists of all edges incident to some
. The remaining edges form . The
edges of  are further partitioned into two sets:
 is the subgraph of \emph{cross} edges, which have only
one endpoint in . The other edges make the subgraph .
The edge sets of these subgraphs are ,
respectively. For any set ,  denotes
the induced subgraph on .

We now count the number of edges
in each set that our algorithm cuts. We can only
guarantee that half the edges in  are cut. Let the
\maxcut of  be . Our algorithm will
cut (in each ) at least  edges.
This deals with all the edges in . In , we can
only cut half of the edges. In , we cut an 
fraction of edges. In total,

The maxcut of  is at most  (otherwise, we would
get a tripartition). So we get,


By definition, . Fixing the size
of , we minimize the number of edges cut by taking
this to be equality. Consider the subgraph  and let its
\maxcut value be . If we remove the edges ,
we get the subgraph . The \maxcut of  is at least

Now, we lower bound the total number of edges in  that are cut.

By definition of ,

The total number of edges cut is bounded below by:

\end{myproof}

Using this we prove the main lemma about {\Balance} (restated here
for convenience):

\begin{Lem}
For any constant , there is a choice of ,  and
 so that there is an  time algorithm with an
approximation factor that is a constant greater than .
\end{Lem}

\begin{myproof}
The algorithm {\Balance} has a work to output ratio of
. We now set  and
 to be constants so that the work to output ratio is . For
this, we set . Letting 
be a free parameter, this gives , and . Note that since , we can choose  so that  and .

Now, it remains to show that for any choice of , the bound on
the approximation factor given by Claim~\ref{clm:threehalf} is greater than
. For convenience of notation, we will drop the arguments to functions and
use , , and  to refer to , , and
 respectively. First, note that . Let us set
 as from the statement of
Lemma~\ref{lem:H-properties}. Then , and  since . Furthermore, note that
 is obtained
at , and takes the value  since . Thus, the minimum of all these three
quantities is greater than , and hence the approximation factor is more
than .
\end{myproof}\\

Using a more nuanced analysis of the approximation ratio, we can
get better bounds. This requires the solving of an optimization
problem, as opposed to Claim~\ref{clm:threehalf}. We provided
the weaker claim because it is easier to use for Lemma~\ref{lem:balance}.


\begin{claim} \label{clm:lp} Let us fix . The approximation ratio
can be bounded as follows: let  be variables and  be
fixed. First minimize the function:

with constraints:

Let this value by . The approximation ratio is at least

\end{claim}

\begin{myproof} To analyze the approximation ratio, we follow the progress of the algorithm
to the end. In each iteration, either a low conductance set is removed,
or the basic algorithm is run. In each iteration, let us consider
the set of vertices this is assigned to some side of the final cut.
In case of a low conductance set, we get a cut for the whole set.
Otherwise, if we get a tripartition, the union 
will be this set. If we do not get a tripartition,
then we output the trivial cut (thereby classifying all remaining vertices).
Let us number the low conductance sets
as . The others are denoted .
We will partition the edges of  into parts, defining subgraphs.
The subgraph  consists of all edges incident to some
. The remaining edges form . The
edges of  are further partitioned into two sets:
 is the subgraph of \emph{cross} edges, which have only
one endpoint in . The other edges make the subgraph .
In , let the edges incident to vertices \emph{not} in
 be be . The remaining edges form the subgraph .
The edge sets of these subgraphs are ,
respectively. For any set ,  denotes
the induced subgraph on .

We now count the number of edges
in each set that our algorithm cuts. We can only
guarantee that half the edges in  are cut. Let the
\maxcut of  be  (). Our algorithm will
cut (in each ) at least  edges.
This deals with all the edges in . In , we can
only cut half of the edges. In , we cut an 
fraction of edges. In total,

By convexity of , we have
,
where . Putting it all together, we cut
at least

We would like to find out the minimum value this can attain, for a given
. The parameters  are fixed.
The maxcut of  is at most  (otherwise, we would
get a tripartition). We have the
following constraints:

For a given size of , we should maximize  to cut the least
number of edges. So we can assume that .
Let us set , , and .
Consider fixing  and . The variables are .
This means the approximation ratio is at least
the \emph{minimum} of

under the constraints:

Let  be the minimum value attained.
We observe that given any solution, the objective can
be decreased if we decrease . This is because for
a small decrease in , we can increase  (and decrease either  or ).
This preserves all the constraints, but decreases the objective.
So we can set .
Our bound on the approximation ratio is

\end{myproof}

\subsection{Running Time/Approximation Ratio Tradeoff}


\begin{figure}[htbp] \centering
    \includegraphics[width=7in]{simple-balance} \caption{Running Time/Approximation Ratio Tradeoff Curve for \Simple and \Balance. \Simple
    needs running time  and \Balance needs running time , for any constant . The approximation ratio for \Simple is from Lemma~\ref{lem:simple}, and that for \Balance is from Claim~\ref{clm:lp}.}
    \label{fig:simple-balance}
\end{figure}


\section{Conclusions and Further Work}

Our combinatorial algorithm is very natural and simple, and beats
the  barrier for \maxcut. The current bounds for the approximation
ratio we get for, say, quadratic time are quite far from the
optimal Goemans-Williamson , or even from Soto's  bound
for Trevisan's algorithm.
The approximation ratio of our algorithm can probably be improved, and it might
be possible to get a better running time. This would probably
require newer analyses of Trevisan's algorithm, similar in spirit
to Soto's work~\cite{Sot09}.
It would be interesting to
see if some other techniques different from random walks
can be used for \maxcut.

This algorithm naturally suggests whether a similar approach can
be used for other -CSPs. We believe that this should be possible,
and it would provide a nice framework for combinatorial algorithms
for such CSPs. On a different note, our local partitioning algorithm
raises very interesting questions. Can we get such a partitioning
procedure that has a better work to output ratio (close to polylogarithmic)
but does not lose the  factor in the conductance
(which previous algorithms lose)? We currently have a work to output
that can be made close to  in the worst case.
A significant improvement would be of great interest.

\bibliographystyle{alpha}
\bibliography{maxcut}















\end{document}
