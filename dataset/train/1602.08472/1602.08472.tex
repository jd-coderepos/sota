\documentclass[english,draftcls,onecolumn,11pt]{IEEEtran}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{color}
\usepackage{array}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{setspace}

\makeatletter

\providecommand{\tabularnewline}{\\}

\theoremstyle{definition}
  \newtheorem{defn}{\protect\definitionname}
\theoremstyle{plain}
\newtheorem{thm}{\protect\theoremname}
  \theoremstyle{plain}
  \newtheorem{cor}{\protect\corollaryname}
 \theoremstyle{definition}
  \newtheorem{example}{\protect\examplename}

\hyphenation{op-tical net-works semi-conduc-tor}
\usepackage{amsfonts}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{multirow}
\usepackage{cite}
\usepackage{xcolor}

\newtheorem{ctexample}{Counter-Example}

\def\calA{\mathcal{A}}
\def\calB{\mathcal{B}}

\makeatother

\usepackage{babel}
  \providecommand{\definitionname}{Definition}
  \providecommand{\examplename}{Example}
\providecommand{\corollaryname}{Corollary}
\providecommand{\theoremname}{Theorem}

\begin{document}

\title{ExpSOS: Secure and Verifiable Outsourcing of Exponentiation Operations
for Mobile Cloud Computing}


\author{Kai Zhou, M. H. Afifi and Jian Ren\thanks{The authors are with the Department of Electrical and Computer Engineering,
Michigan State University, East Lansing, MI 48824-1226, Email: \{zhoukai,
afifi, renjian\}@msu.edu}}
\maketitle
\begin{abstract}
Discrete exponential operation, such as modular exponentiation and
scalar multiplication on elliptic curves, is a basic operation of
many public-key cryptosystems. However, the exponential operations
are considered prohibitively expensive for resource-constrained mobile
devices. In this paper, we address the problem of secure outsourcing
of exponentiation operations to one single untrusted server. Our proposed
scheme (ExpSOS) only requires very limited number of modular multiplications
at local mobile environment thus it can achieve impressive computational
gain. ExpSOS also provides a secure verification scheme with probability
approximately  to ensure that the mobile end-users can always
receive valid results. The comprehensive analysis as well as the simulation
results in real mobile device demonstrates that our proposed ExpSOS
can significantly improve the existing schemes in efficiency, security
and result verifiability. We apply ExpSOS to securely outsource several
cryptographic protocols to show that ExpSOS is widely applicable to
many cryptographic computations.\end{abstract}

\begin{IEEEkeywords}
Mobile cloud computing, secure outsourcing, modular exponentiation,
scalar multiplication, result verification
\end{IEEEkeywords}


\section{Introduction}

Cloud computing provides end-users the capability to securely access
the shared pool of resources such as computational power and storage.
It enables end-users to utilize those resources in a pay-per-use manner.
Among all types of computations, exponential operation in a finite
group is almost ubiquitous in public-key cryptosystems. However, due
to large integers involved, exponentiation is considered prohibitively
expensive for resource-constrained devices such as mobile phones.
Thus, outsourcing exponentiation operation to the cloud servers becomes
an appealing choice. 

However, when sensitive data is outsourced to the untrusted cloud,
security of the data as well as the result is at risk. Moreover, many
cryptographic applications, such as digital signature, require to
verify the validity of the results of modular exponentiation. Thus
result verification is also a crucial issue. In contrast, the cloud
cannot be fully trusted for at least three reasons. First, the cloud
could be curious. That is, it may try to ``mine'' as much information
as possible from the outsourced data. Second, the computational resource
is commodity. The cloud has the motivation to cheat in the computation
process in order to save computational resources. Third, the cloud
is a shared environment. It is hard to secure individual data using
just regular processor. Thus, security and verifiability are two major
concerns for computation outsourcing.

To address these two issues, various computation outsourcing mechanisms
have been proposed, including outsourcing of modular exponentiation
operations \cite{atallah2002,atallah2010,atallah2005secure,wang2011infocom,chen2014efficient,blanton2012secure,blanton2010secure,hohenberger2005securely,chen2012new,wang2014securely}.
In \cite{hohenberger2005securely}, the authors considered outsourcing
modular exponentiation to two servers assuming that they would not
collude. The basic idea of the proposed scheme in \cite{hohenberger2005securely}
is to split the base and exponent of modular exponentiation into random
looking pieces that are separately outsourced to two servers. Then
the end-user can combine the results returned by the servers to recover
the desired result. Under this scheme, the end-user can check the
validity of the returned results with probability .
Following \cite{hohenberger2005securely}, the authors in \cite{chen2012new}
proposed a similar scheme and improved the performance by reducing
one query to the servers and increasing the verifiability to .
In order to eliminate the assumption that the two servers would not
collude, the authors in \cite{wang2014securely} proposed a scheme
to outsource modular exponentiation to one single server. However,
at local side, the end-user still needs to carry out some exponentiation
operations. As a result, the computational gain is limited for the
end-user. Moreover, all these three schemes rely on pre-computation
of modular exponentiation of some random integers. This will cause
extra overhead to end-user's limited computational power or storage
space depending on the method by which pre-computation is implemented.

From the above analysis of several previous schemes, we can summarize
some basic requirements of secure outsourcing of modular exponentiation.
First, for the system model, it is much more desirable to outsource
exponentiation operations to one single server instead of two servers
with security based on the assumption that two servers would not collude.
Second, the secure outsourcing scheme should not impose expensive
computational overhead at local side. Otherwise, the performance gain
from outsourcing would diminish. Third, the scheme should provide
a high verifiability. Ideally, the end-user should be able to verify
the validity of the returned result with probability .

In this paper, we extend the notion of exponentiation from modular
exponentiation to general exponential operations in a finite group,
including scalar multiplication on elliptic curves. In general, each
exponential operation consists of a series of basic group operations.
The number of such operations varies with the exponent. In this sense,
modular exponentiation and scalar multiplication can both be regarded
as exponentiation operations. Thus, we propose a Secure Outsourcing
Scheme for general Exponential (ExpSOS) operations. The proposed ExpSOS
is based on ring homomorphism. Specifically, we map the integers in
the ring  to the ring  so that the
computation in  is homomorphic to that in .
We let the cloud carry out the computation in  and
from the result returned by the cloud, the end-user is able to recover
the result back to  efficiently. The ring homomorphism
has two features: i) the mapping between  and 
is computationally efficient, and ii) without possessing the secret
key, it is computationally infeasible to derive any key information
of the result in  from that in .
The main contributions of this paper can be summarized as follows:
\begin{itemize}
\item We formally define a secure outsourcing scheme and four outsourcing
models. The proposed ExpSOS is shown to be effective under all four
different models.
\item We develop schemes to securely outsource exponentiation operations
in a general finite group, including modular exponentiation and scalar
multiplication on elliptic curves.
\item We outsource exponential operation to one single untrusted server
eliminating the non-collusion assumption between multiple servers.
\item Our proposed ExpSOS is efficient in that it requires only a small
number of modular multiplications at local side. 
\item We propose a verification scheme such that the end-user can verify
the validity of the result with probability approximately .
\end{itemize}
The rest of this paper is organized as follows. In Section \ref{sec:Secure-Outsourcing-Model},
we introduce four secure outsourcing models and formally define a
secure outsourcing scheme. In Section \ref{sec:Proposed-Scheme},
we present the design of ExpSOS for both modular exponentiation and
scalar multiplication based on ring homomorphism. We propose the verification
scheme in Section \ref{sec:Result-Verification}. The complexity and
security analysis of ExpSOS are given in Section \ref{sec:Complexity-and-Security}.
Then we apply ExpSOS to outsource several cryptographic protocols
in Section \ref{sec:Application}. In Section \ref{sec:Performance-Comparison},
we compare the performance of ExpSOS with several existing works and
give some numeric results. We conclude in Section \ref{sec:Conclusion}.


\section{Secure Computation Outsourcing Model\label{sec:Secure-Outsourcing-Model}}


\subsection{System Model and Threat Model}


\paragraph{System Model}

In the general settings of computation outsourcing, the system consists
of two entities: an end-user  and the cloud . The end-user
 is resource-constrained. It has limited computational power and
storage space. The cloud  is regarded as possessing abundant resources
and is able to carry out expensive computations. The cloud can be
further modeled as the \textit{single-server} model and the \textit{multiple-servers}
model. In the single-server model, the cloud is viewed as one unit.
In contrast, in the multiple-servers model, the cloud is divided into
two or more individual units. Each unit carries out the computational
tasks independently. While communication between different units is
allowed, key information is only limited to individual unit since
otherwise security of the whole system maybe in jeopardy. 

Suppose the end-user  wishes to accomplish a computationally expensive
task , where  is the
input and  is the output of the task. However, due to the
limited resources,  may not be able to finish the task using the
locally available resources. The computational task  could be
outsourced to . Unfortunately, the cloud is only a shared server
and cannot be fully trusted. Therefore, we have to make sure that
it is infeasible for  to derive any key information about both
 and  from the outsourced task. 


\paragraph{Threat Model}

We propose two threat models for the cloud. First, the cloud 
is \textit{honest but curious}. That is, the cloud will honestly fulfill
its advertised functionality. However,  could be curious. It may
try to exploit any key information from the outsourced task, which
may include the input, the output as well as the intermediate computational
results. When the outsourced data is sensitive, this could cause severe
security and privacy issues. Second, the cloud  is \textit{malicious},
meaning that the cloud  may not carry out the desired computation
truthfully. This can happen for various reasons. A simple scenario
could be that the cloud simply returns some trivial results since
the computational resource is a commodity for the cloud server. As
a consequence, the end-user  is unable to receive a valid result
from the cloud server . 

Based on the above system model and threat model, we can divide the
computation outsourcing scenarios into four types in a hierarchical
manner: 
\begin{itemize}
\item \textbf{MS}: Malicious cloud under Single-server model. 
\item \textbf{HCS}: Honest but Curious cloud under Single-server model.
\item \textbf{MM}: Malicious cloud under Multiple-servers model.
\item \textbf{HCM}: Honest but Curious cloud under Multiple-servers model. 
\end{itemize}
It is hierarchical in the sense that a secure outsourcing scheme designed
for single-server model can be extended to multiple-servers model
and a scheme for malicious cloud can be extended to honest but curious
cloud. Specifically, these four models can be organized into three
layers: at the bottom layer is the HCM model, in the middle are the
MM and HCS and on the top is MS. A secure outsourcing scheme designed
for a model in an upper layer is also suitable for that in a lower
layer . Thus, a secure outsourcing scheme for MS is most widely applicable
and achieves the highest security standard. In this paper, we first
propose a secure outsourcing scheme for the HCS model. Then a verification
scheme is proposed for MS model.


\subsection{Definition of Secure Outsourcing Scheme}

A secure computation outsourcing scheme mainly addresses two issues:
the security of the outsourced computational problem and the validity
of the returned results. We formally define a Secure Outsourcing Scheme
(SOS) as a 4-tuple 
consisting of four different functions:
\begin{enumerate}
\item \textbf{Problem Transformation} .
The end-user  locally transforms the problem 
to a new form , where  is the new input
and  is the new problem description.  then outsources 
to the cloud server .
\item \textbf{Cloud Computation} .
The cloud  solves the transformed problem  to
obtain the corresponding result . At the same time, 
returns  that is a proof of the validity of the result.
\item \textbf{Result Recovery} . Based
on the returned result , the end-user  recovers the result
 of the original problem .
\item \textbf{Result Verification} .
Based on  and the proof , the end-user 
verifies the validity of the result.
\end{enumerate}
An SOS should satisfy the following two requirements:
\begin{enumerate}
\item \textbf{Soundness}: given that the cloud is honest but curious, 
can successfully recover the correct result  from the returned
result . That is .
\item \textbf{Security}: the cloud is unable to derive any key information
about the original input  and output  from the
transformed problem , the new input  and the new
output . 
\end{enumerate}
To measure the performance of an SOS, we adopt a similar definition
of efficiency and verifiability as proposed in \cite{hohenberger2005securely}.
We introduce the following two definitions:
\begin{defn}[-efficient]
\label{def:efficient} Suppose the running time of a task  for
 is . Under an SOS, the running time of local processing
for  is . Then the SOS is -efficient if .
\end{defn}

\begin{defn}[-verifiable]
\label{def:checkable} Given the returned output  and the
proof , denote the probability that  is able to verify
the validity of the result  as . Then an SOS is -verifiable
if .
\end{defn}
From the definition above, we can see that a larger  indicates
a better performance of a secure outsourcing scheme, while a larger
 means a better verifiability.


\section{Secure Outsourcing of Exponentiation Operations \label{sec:Proposed-Scheme}}

In this section, we first define a ring homomorphism .
Based on this ring homomorphism, we propose a secure outsourcing scheme
for exponentiation operations. In this section, the threat model is
assumed to be HCS.\textcolor{red}{{} }However, our proposed verification
scheme ensures that ExpSOS is secure under the MS model.


\subsection{Ring Homomorphism}

Consider two rings and their corresponding operations 
and  and a mapping function .
We define ring homomorphism as follows:
\begin{defn}[\textbf{Ring Homomorphism}]
 Given  and ,
a mapping function 
is a ring homomorphism if there exists an inverse mapping function
 and the pair 
possesses the following two properties:\end{defn}
\begin{itemize}
\item \textbf{Additive Homomorphism}: ,
;
\item \textbf{Multiplicative Homomorphism}: ,
.
\end{itemize}
In this paper, we assume that exponentiation operations are operated
in the ring . We note that  is not necessarily
a prime. It can also be product of large primes. Then, our primitive
goal is to construct a proper ring homomorphism 
that maps elements in  to elements in another ring
denoted as . In this way, the computations in 
can be concealed when transformed to the corresponding computations
in  so that the computations in 
can be concealed. 

Define  as follows:


where  is a random integer in ,  and 
is a large prime. The following theorem states that the proposed 
achieves ring homomorphism.
\begin{thm}
\label{thm:ring-homo}, the mapping 
defined in equation (\ref{eq:ring-homomorphism}) is a ring homomorphism.\end{thm}
\begin{IEEEproof}
We show that there exists an inverse mapping function 
and the pair  possesses both the additive and the multiplicative
homomorphic properties. Define the inverse mapping function  as



Suppose , 
and , where 
are randomly selected integers. We can verify that 




Thus, we have proved that  has additive homomorphic property.
Similarly, we can verify that  is also multiplicative homomorphic
as follows:




Hence, the proposed mapping function  is a ring
homomorphism.
\end{IEEEproof}
The above proposed ring homomorphism enables us to transform the addition
and multiplication in a ring into the corresponding operations in
another large ring. We further explore the polynomial homomorphic
property of the ring homomorphism that is defined as follows.
\begin{defn}[\textbf{Polynomial Homomorphism}]
 Suppose 
and  is a polynomial function defined on
. A mapping function 
is polynomial homomorphic if there exists an inverse mapping function
 such that 

where  is applied on  opponent-wise. \end{defn}
\begin{thm}
\label{thm:The-proposed-ring}The proposed ring homomorphism 
is polynomial-homomorphic.
\end{thm}
The proof of the above theorem is straightforward given the additive
and multiplicative homomorphic properties of the ring homomorphism.


\subsection{ExpSOS under HCS Model}

In this section, we will consider two kinds of exponentiation operations,
that are modular exponentiation and scalar multiplication on elliptic
curves.


\subsubsection{Secure Outsourcing of Modular Exponentiation}

Consider modular exponentiation . We assume that
 is either a large prime or a product of large prime numbers,
which is the typical situation in cryptosystems. Theorem \ref{thm:ring-homo}
states that the result of multiplication in the ring 
can be obtained from the multiplication in  through
the transformation function and the inverse function. If we take ,
we can get

If we repeat the multiplication in  for  times,
we have the following corollary.
\begin{cor}
\label{cor:exponentiation} For , we have


\end{cor}
Corollary \ref{cor:exponentiation} gives us a way to conceal the
base when outsourcing modular exponentiation. That is, we can first
transform the original base  to , where 
is a random integer. Then the cloud can compute  based
on which the result can be recovered by computing .
As long as  is kept secret, the cloud cannot learn the value of
 due to the randomness of . 

The remaining task is to conceal the exponent . We have the following
theorem.
\begin{thm}
\label{thm:euler} For , where 
are distinct prime numbers, we have

where  is a random integer and  is the Euler's totient
function.\end{thm}
\begin{IEEEproof}
We first prove . Consider a prime
factor  of , . There are two cases:
\begin{itemize}
\item Case 1: , that is  and
 are not relatively prime. In this case, we have .
Thus

which means that .
\item Case 2: , that is  and  are relatively
prime. Then, by the Euler's Theorem, we have .
From the multiplicative property of the Euler's totient function,
we have . Let .
Then,




That is . 


Thus, in both cases, we have proved that 
Since  is arbitrarily selected and 
are distinct primes, we have




Hence, . Multiplying both sides of
the equation by , we can obtain



\end{itemize}
\end{IEEEproof}
In Theorem \ref{thm:euler}, we do not require that  and 
to be co-prime as required in the Euler's theorem. Instead, we assume
that  is the product of distinct primes that is typical in cryptosystems.
For instance, in RSA, the modulus  is the product of two distinct
prime numbers.

Theorem \ref{thm:euler} introduces a way to conceal the exponent
. That is, by transforming the original exponent  to ,
where  is a random integer, we can conceal  due to the randomness
of . Now, based on Theorem \ref{thm:ring-homo} and Theorem \ref{thm:euler},
we can construct our secure outsourcing scheme for modular exponentiation.
In the secure outsourcing scheme, the function 
outsourced to the could can be expressed as a modular exponentiation
. The result recovery function is
. The secure outsourcing scheme for modular
exponentiation under HCS model is given in Algorithm \ref{alg:ExpSOS-under-HCS}. 

\begin{algorithm}[tbh] 
\caption{Secure Outsourcing of Modular Exponentiation Under HCS Model\label{alg:ExpSOS-under-HCS}}

\smallskip 
\textbf{Input:} .\\
\textbf{Output:} .

\smallskip 
:
\begin{algorithmic}[1] 
\STATE  generates a large prime  and calculate . 
\STATE The public key is , and the private key is .  
\end{algorithmic} 

\smallskip 
:  
\begin{algorithmic}[1] 
\STATE  selects random integers  as the temporary key.
\STATE  calculates ,
.
\STATE  outsources  to the cloud.
\end{algorithmic} 

\smallskip
:
\begin{algorithmic}[1] 
\STATE  computes . 
\STATE  returns  to .
\end{algorithmic} 

\smallskip
:
\begin{algorithmic}[1] 
\STATE  recovers the result as .
\end{algorithmic} 
\end{algorithm}

The soundness of the outsourcing scheme is guaranteed by the following
theorem:
\begin{thm}
\label{thm:correctness} The secure outsourcing scheme for modular
exponentiation is sound. That is .
\end{thm}
The proof of Theorem \ref{thm:correctness} is straightforward based
on Theorem \ref{thm:ring-homo} and Theorem \ref{thm:euler}. Specifically,
by transforming the original problem of modular exponentiation to
a disguised form, our proposed ExpSOS under HCS model is sound. 


\subsubsection{Secure Outsourcing of Scalar Multiplication}

In this section, we consider secure outsourcing of scalar multiplication
 on an elliptic curve  described by the following
short Weierstrass equation: 


where the coefficients  and the coordinates of the points are
all in a finite field . Furthermore, for cryptographic
applications, we usually work with points in a set of -torsion
points  defined as ,
where  is the point at infinity. Thus, we assume 
and .

The secure outsourcing of scalar multiplication relies on two basic
operations that are point addition and point doubling. They play a
similar role as modular multiplication in the outsourcing of modular
exponentiation. Specifically, the ``double-and-add'' algorithm to
calculate scalar multiplication on elliptic curves consists of a series
of point addition and point doubling. Thus intuitively, we can regard
secure outsourcing of point addition and point doubling as two building
blocks to implement scalar multiplication.

We utilize projective coordinate to represent a point 
corresponding to the point 
in the affine coordinates. As a result, the computation of point addition
and point doubling consists of only modular addition and multiplication.
Specifically, given two points  and 
such that , the point addition 
can be calculated as follows:

where 

The point doubling  can be calculated as
follows:

where 

In projective coordinates, one point addition and doubling take 
multiplications and  multiplications, respectively. 

Theorem \ref{thm:The-proposed-ring} states that by mapping the variables
of a polynomial from a finite field to variables in a ring, we can
evaluate the polynomial in the ring and recover the result in the
finite field. This gives us the insight of our proposed scheme since
essentially, point addition and point doubling are both the process
of evaluating polynomials on the coordinates of the points. Thus,
we can construct the secure computation scheme for point addition
and point doubling as in Algorithm \ref{alg:Secure-Point-Addition}. 

\begin{algorithm}[tbh] 
\caption{Secure Point Addition and Point Doubling\label{alg:Secure-Point-Addition}}

\textbf{Input:} ,  and .\\
\textbf{Output:} point .

\begin{algorithmic}[1] 
\STATE Select a large prime  and compute . 
\STATE For a coordinate , select a random integer  and compute .
\STATE Transform the points  and the elliptic curve  to ,  and  respectively as described in Step 2. 
\STATE Outsource  and  to the cloud.
\STATE Cloud computes  following the point doubling or point addition prodecure.
\STATE On receiving , recover  as .
\end{algorithmic} 
\end{algorithm}
\begin{thm}
\label{thm:The-proposed-secure}The proposed secure point addition
and point doubling algorithm is sound.
\end{thm}
The proof of Theorem \ref{thm:The-proposed-secure} is straightforward
from the polynomial-homomorphic property of the ring homomorphism.

The above theorem enables us to conceal the points as well as the
parameters of the elliptic curve from the cloud. To outsource scalar
multiplication , the remaining part is to conceal the multiplier
. We utilize the property of the order  of the torsion group
that is , for an arbitrary point 
and any integer . As a result, we can conceal  by adding it
to a multiple of  as , where  is a random
integer. Now, we can summarize the secure outsourcing scheme of scalar
multiplication as in Algorithm \ref{alg:Secure-Outsourcing}.

\begin{algorithm}[tbh]
\caption{Secure Outsourcing of Scalar Multiplication Under HCS Model\label{alg:Secure-Outsourcing}}

\textbf{Input:} , ,  and .\\
\textbf{Output:} point .

:
\begin{algorithmic}[1] 
\STATE End-user selects a large prime  and compute .
\end{algorithmic} 

:
\begin{algorithmic}[1] 
\STATE End-user generates random integers .
\STATE Computes , , , , , . 
\STATE End-user outsources ,  and .
\end{algorithmic} 

:
\begin{algorithmic}[1] 
\STATE The cloud computes  utilizing the double-and-add algorithm.
\end{algorithmic}

:
\begin{algorithmic}[1] 
\STATE The end-user recovers the result  as .
\end{algorithmic} 
\end{algorithm}
\begin{thm}
The secure outsourcing scheme for scalar multiplication is sound.
That is .\end{thm}
\begin{IEEEproof}
From Theorem \ref{thm:The-proposed-secure}, we know that the secure
computation scheme for point addition and point doubling is sound.
Since the double-and-add algorithm to compute scalar multiplication
consists of a series of point addition and point doubling, we have
.
\end{IEEEproof}
In the next section, we propose a verification scheme to ensure that
ExpSOS is secure under the MS model. 


\section{Result Verification \label{sec:Result-Verification}}

In this section, we first analyze the necessary properties of a result
verification scheme through some counter examples. We then propose
a result verification scheme for the outsourcing of modular exponentiation
under MS model. We show that the verification scheme can also be applied
to the outsourcing of scalar multiplication.

In the HCS model discussed in the previous section, we assume that
the cloud will honestly conduct its advertised functionality. That
is, to compute the function  and return the correct
result . However, in the MS model, the cloud may manipulate
the result in order to save computational resources. Thus, to verify
the soundness of the result returned by the cloud is a critical issue.

A natural way to verify the result, as utilized in many previous works
\cite{chen2012new,chen2014efficient,hohenberger2005securely}, is
to outsource the problem multiple times and verify whether the returned
results satisfy certain criteria. However, this methodology may cause
potential security problems if it is not carefully designed. This
is because outsourcing multiple times essentially gives more information
about the original problem to the cloud, which may increase the probability
for the cloud to recover the original problem. Moreover, the cloud
may manipulate the results in order to satisfy the criteria, thus
passing the verification. Therefore, we believe that an effective
verification scheme should at least have the following two properties: 
\begin{itemize}
\item \textbf{Security}: The verification process should not reveal any
key information about the original problem to the cloud. 
\item \textbf{Anti-manipulation}: It is infeasible for the cloud to manipulate
the result and pass the verification process. 
\end{itemize}
We utilize two counter-examples in verifying modular exponentiation
to illustrate the significance of the above properties and emphasize
the key issues in designing a verification scheme. 

\begin{ctexample}
Transform the exponent   to  and . The cloud returns results  and . The end-user checks whether the condition   holds.  
\end{ctexample}

Unfortunately, the above example violates the security property. When
the cloud possesses  and , it can calculate ,
which is a multiple of the Euler's totient function . In
this case, the cloud can factorize  based on
which, the cloud may be able to check the primality of . Since
 is a product of large primes, the consequence is that the cloud
can limit the valid value of  to a short list. That is the cloud
have a good chance to guess the value of . This means that the
cloud can derive some key information from the outsourced problem
thus making outsourcing insecure. Similarly, some variances of this
type of method (e.g.,  and ,
where  is a known constant) may also have security problems.

\begin{ctexample}
Transform the exponent  to  and , where  is a relatively small integer and calculating  is within the end-user's computational ability. The cloud returns results  and . The end-user checks whether the condition  holds.
\end{ctexample}

Due to the randomness of , the cloud is not able to obtain a multiple
of . However, from the equality condition ,
we have , which is
equivalent to 




In this case, the cloud can manipulate two arbitrary integers 
and  as long as .
The results will pass the verification but the recovered result 
is incorrect. This means that the cloud can manipulate a false result
while passing the verification process.

From the above two counter examples, we can see that security and
anti-manipulation are two critical issues in result verification schemes.
In the following Algorithm \ref{alg:Result-Verification-Scheme},
we propose a verification scheme for modular exponentiation.



\begin{algorithm}[tbh] 
\caption{ExpSOS under MS Model\label{alg:Result-Verification-Scheme}}

\smallskip 
\textbf{Input:} .\\
\textbf{Output:} , 

\smallskip 
:
\begin{algorithmic}[1] 
\STATE  generates a large prime  and calculate . 
\STATE The public key is , and the private key is .  
\end{algorithmic} 

\smallskip 
:  
\begin{algorithmic}[1] 
\STATE  selects random integers   as the ephemeral key with the constraint that .
\STATE  calculates ,  and .
\STATE  outsources  and  to the cloud.
\end{algorithmic} 

\smallskip
:
\begin{algorithmic}[1] 
\STATE  computes  and .
\STATE  returns  and  to .
\end{algorithmic} 

\smallskip
:
\begin{algorithmic}[1] 
\STATE  checks .
\STATE If the equality holds, set . Otherwise, set .
\end{algorithmic} 

\smallskip
:
\begin{algorithmic}[1] 
\STATE  recovers the result as .
\end{algorithmic} 
\end{algorithm}



Now, we utilize an example to illustrate our proposed ExpSOS under
MS model.
\begin{example}
Suppose the end-user  wants to calculate , where
 is a prime,  and .  can outsource 
as follow:\end{example}
\begin{enumerate}
\item :  select a prime number  and
calculate . Then  selects random integers 
and  with .
\item :  calculates ,
 and .
 then queries  and 
to the cloud .
\item :  computes ,
 and returns
 and  to .
\item :  calculates 
and  that satisfy .
Thus the returned results are correct.
\item Result Recovery:  recovers the result as 
that is equal to .
\end{enumerate}
In Algorithm \ref{alg:Result-Verification-Scheme}, the two outsourced
exponential operations are related through an affine function. As
a consequence, the cloud is unable to derive a multiple of 
only based on  and . Moreover, the cloud cannot manipulate
the results to create a verifiable equality. 

This verification scheme can also be applied to the outsourcing of
scalar multiplications. The base point  can be transformed to
 as described in Algorithm \ref{alg:Secure-Outsourcing}.
The exponent  can be transformed to  and ,
where  are random integers and .
Then the end-user can check the condition ,
where  and . 


\section{Complexity and Security Analysis \label{sec:Complexity-and-Security}}

In this section, we analyze the security and the computational complexity
of ExpSOS. We utilize the secure outsourcing of modular exponentiation
as a representative to perform the analysis. The analysis of outsourcing
scalar multiplication can be conducted in a similar way. We show that
ExpSOS is secure under both HCS and MS model. Specifically, under
the HCS model, the ExpSOS is -efficient. Under
the MS model, the ExpSOS is -efficient and
-verifiable, where  is the exponent and
 is the security parameter.


\subsection{Security Analysis}

In ExpSOS, we conceal the base  through a ring homomorphism 
and the exponent  is mapped to . In our analysis,
we show that given the public information ,
the cloud cannot derive any key information about the input 
and the output .

First, the following theorem shows that the ring homomorphism is secure.
\begin{thm}
\label{thm:ring-security} When the integers  and  are sufficiently
large, it is computationally infeasible to recover  from the ring
homomorphism .\end{thm}
\begin{IEEEproof}
The security is based on the hardness of integer factorization. That
is, given , where  and  are large prime numbers, it
is computationally infeasible to factorize  to get  and .
In our case, we consider the module  as a large prime number or
a product of large prime numbers, which is typical in cryptosystems.
Thus, given , the cloud is unable to recover . Furthermore,
as  is a random integer, given , the cloud is
also unable to recover . \end{IEEEproof}
\begin{thm}
In the ExpSOS scheme, it is computationally infeasible to recover
the exponent  under both HCS and MS model.\end{thm}
\begin{IEEEproof}
The proof is straightforward since under the HCS model, the cloud
obtains , while under the MS model, the cloud obtains
 and . In
both cases, the randomness of  and security
of the totient function  make it infeasible for the cloud
server to derive the exponent 
\end{IEEEproof}
We show that the proposed verification scheme has the security and
effectiveness properties as described previously. First, the security
is based on the likelihood of finding two integers  and 
so that 
holds true, and deriving a multiple of  from ,
and . The former would enable the
cloud server to cheat the end-user without conducting the actual computation
and the latter could make it possible for the cloud server to recover
 and then perform collision attacks. 
\begin{thm}
For any two randomly selected integers  and  the
probability that 
is  \end{thm}
\begin{IEEEproof}
The proof of this theorem is straightforward since only one pair of
 will make the equality holds true, while the total
number of possible combinations for the  pair is  
\end{IEEEproof}
This theorem indicates that if the cloud wants to manipulate the result,
it has to guess the random integers, the probability to succeed is
only . In fact, if we outsource 
and  in a random order, we can further reduce
the probability for the cloud to guess the correct randoms to 
According to Definition \ref{def:checkable}, ExpSOS is at least -verifiable. 
\begin{thm}
For any two randomly selected integer  and  the probability
to derive a multiple of  is at most  \end{thm}
\begin{IEEEproof}
Since  and ,
and  is a randomly chosen integer from  the cloud
server has probability  to get the right  and derive
the following equation

where  and  are known and  are secretly
selected. For the right-hand side of this equation, if further 
is known, then its integer factorization could potentially reveal
the factors of  However, since  is randomly chosen
in the range , the likelihood to get a proper  is
 Therefore, the overall probability to obtain equation (\ref{eq:Verification-Collision})
is 
\end{IEEEproof}
The upper bound  is a security parameter that measures the confidence
of the end-user about the returned result. In practical computation
outsourcing systems, the cloud would be severely punished if cloud
manipulation is detected. Therefore, the benefit for the cloud to
cheat would be hardly justifiable in this setting. 


\subsection{Complexity Analysis}

We utilize outsourcing of modular exponentiation as a representative
to analysis complexity. The analysis can be applied to scalar multiplication
similarly. The essence of ExpSOS is to limit the number of modular
multiplications for the end-user to compute modular exponentiation
with the aid of the cloud. In our analysis, we utilize the number
of modular multiplications, denoted as , as a measurement. To
calculate , the number of multiplications is ,
where  is the bit length of \cite{zhong2000modular}.
Therefore, in calculating the modular exponentiation ,
 and .

In ExpSOS, under the HCS model, to calculate  and , the
end-user needs  multiplications. We notice that when the end-user
knows the factors of , it is computationally easy to calculate
. For example, when  is a prime, . Moreover,
the calculation of  is a one-time process. The computational
overhead for calculating  is negligible especially when
the end-user outsources modular exponentiation multiple times. Thus,
under HCS model, we have . Hence, the computational
gain from outsourcing is .
From Definition \ref{def:efficient}, ExpSOS is -efficient
under the HCS model. 

Under the MS model, the calculation of  will take
 multiplications. In the verification scheme, the end-user has
to calculate  and .
Thus, .
Since  and  are upper-bounded by , we have .
Hence the computational gain from outsourcing is 

 Thus under the MS model, ExpSOS is at least -efficient. 


\subsection{Trade-Off between Computation and Security}

The above security and complexity analysis reveal the trade-off between
computational overhead and security. In the MS model, ExpSOS is at
least -efficient and -verifiable.
Both measurements relate to the same parameter . On one hand,
 is the upper bound of the computational overhead that the end-user
can tolerate. On the other hand,  reveals the confidence of the
end-user about the returned result which is also regarded as the security
level of the result. When  increases, the end-user has to carry
out more computation. However, the probability that the end-user can
verify the validity of the result also increases. 

Thus, the proposed ExpSOS is cost-aware in the sense that it enables
the end-user to have the flexibility to choose the most suitable outsourcing
scheme according to its computational constraint and security demand.
This is important especially when the end-users vary in computational
power and security demands. It also makes ExpSOS widely applicable.


\section{Applications\label{sec:Application}}

The proposed ExpSOS is able to conceal the base, the exponent and
the module of the modular exponentiation . It can also
be used to conceal the base point  and multiplier  of the
scalar multiplication . With this feature, the parameters (private
or public) within the cryptosystem are totally concealed from the
outside especially the cloud. Thus, the cryptosystem is isolated from
the outsourced system. In this sense, ExpSOS can be regarded as a
black box that takes as input  and creates the output
 as ,
where  is security parameter selected by the end-user. The end-user
will have a performance gain of  and can verify
the validity of the result with probability . 

In this section, we will explore efficient outsourcing of exponential
operations in some typical cryptographic protocols to the cloud. We
will first introduce the outsourcing of Digital Signature Algorithm
(DSA) that involves only modular exponentiation. Then, we illustrate
how to outsource the encryption part of Identity Based Encryption
(IBE) system involving both modular exponentiation and scalar multiplication. 


\subsection{Outsourcing DSA Operations}

We utilize DSA \cite{william2003} as an example of digital signature
schemes. In DSA, the global public key component  is shared
by a group of users. Here,  are prime numbers and  is a
divisor of .  with  such
that . The algorithm can be divided into the
following three phases:
\begin{enumerate}
\item \textbf{Key Generation}: The signer  generates a private key 
with  and calculates the public key as .
\item \textbf{Signing}:  selects a private key  with  and
calculates , ,
where  is the message and  is the hash value of  using
SHA-1. The signature of  is .
\item \textbf{Verifying}: A verifier  calculates ,
,  and .
Then the verifier checks whether  is true.
\end{enumerate}


\begin{algorithm}[h] 
\caption{Secure Outsourcing of DSA message signing\label{alg:SecureDSA-Sign}}

\smallskip 
:  
\begin{algorithmic}[1] 
\STATE  selects a large prime number  and calculate . 
\end{algorithmic} 

\smallskip 
:  
\begin{algorithmic}[1] 
\STATE  selects temporary key  with . 
\STATE  calculates , ,  and .
\STATE  outsources ,  and  in random order to the cloud .
\end{algorithmic} 

\smallskip
:
\begin{algorithmic}[1] 
\STATE  computes ,  and .
\STATE  returns the results ,  and  to .
\end{algorithmic} 

\smallskip
:
\begin{algorithmic}[1] 
\STATE  verifies the results by checking .
\end{algorithmic} 

\smallskip
:
\begin{algorithmic}[1] 
\STATE  recovers the results  and .
\end{algorithmic} 

\smallskip
: 
\begin{algorithmic}[1] 
\STATE  generates the signature  by calculating . 
\STATE  shares the public information  within the group of users.
\end{algorithmic}
\end{algorithm}



\begin{algorithm}[h] 
\caption{Secure Outsourcing of DSA sigature verification\label{alg:SecureDSA-Verification}}

\smallskip 
:  
\begin{algorithmic}[1] 
\STATE The verifier  generates temporary key  with .
\STATE  calculates , ,  and . 
\STATE  outsources , ,  and  to the
cloud.
\end{algorithmic} 

\smallskip
:
\begin{algorithmic}[1] 
\STATE  calculates , , ,  
\STATE  returns the results  to .
\end{algorithmic} 

\smallskip
:
\begin{algorithmic}[1] 
\STATE  verifies the results by checking  and .
\end{algorithmic} 

\smallskip
:
\begin{algorithmic}[1] 
\STATE  recovers the results  and .
\end{algorithmic} 

\smallskip
: 
\begin{algorithmic}[1] 
\STATE  calculates  and check .
\end{algorithmic}
\end{algorithm}

We can see that the computational bottleneck of DSA is the calculation
of ,  for the signer and 
for the verifier. We formulate the outsourcing of DSA in Algorithms
\ref{alg:SecureDSA-Sign} and Algorithm \ref{alg:SecureDSA-Verification}.
To outsource the two exponentiation operations , ,
the signer  makes  queries to the cloud and carries out 
modular multiplications. In comparison, the original computational
burden is . For the verifier
, the computational overhead becomes  in
comparison with the original . 


\subsection{Outsourcing Identity Based Encryption}

Identity Based Encryption (IBE) system is proposed to alleviate the
process of public key certification in traditional public key cryptosystems.
In IBE system, a user can utilize his identity such as his email address\textit{
}as the public key. Then a trusted authority will generate and distribute
private key to the message receiver. The idea of IBE was initialized
by Shamir in \cite{shamir1985identity}. A practical IBE system was
proposed in \cite{boneh2001identity} based on bilinear pairing on
elliptic curves.

In an implementation of IBE system \cite[Chapter 5]{hoffstein2008introduction},
the public parameters are an elliptic curve 
and a base point . Also, the trusted authority
will publish his own public key .
The parameters are known to the authenticated users in the system.
We assume that a user Alice uses the hash of her own identity to generate
the public key which is a point on the elliptic curve, that is .
For any other user Bob who desires to send a message  to Alice,
he will conduct the following encryption process:
\begin{enumerate}
\item Bob selects a random integer ;
\item Bob computes ;
\item Bob computes ;
\item Bob sets the cipher text as .
\end{enumerate}
In the above encryption algorithm,  denotes the pairing
between public points  and  and  is a hash
. We note that both the input and output of the pairing 
are public. Thus, the end-user Bob can obtain the pairing result denoted
as . To this end, we can see that the computational
burden for Bob lies in the scalar multiplication  and the modular
exponentiation . We summarize the outsourcing of IBE
as in Algorithm \ref{alg:SecureIBE}.

\begin{algorithm}[tbh] 
\caption{Secure Outsourcing of Identity Based Encryption\label{alg:SecureIBE}}

: , , \\
: , 

:  
\begin{algorithmic}[1] 
\STATE Bob selects a large prime  and calculates . 
\end{algorithmic} 
\smallskip 
:  
\begin{algorithmic}[1] 
\STATE Bob generates temporary key  with .
\STATE Bob calculates , , , , . Bob sets .
\STATE Bob outsources , ,  and  to the
cloud, where  is the transformed elliptic curve.
\end{algorithmic} 

\smallskip
:
\begin{algorithmic}[1] 
\STATE  calculates , ,  and .  
\STATE  returns the results  to Bob.
\end{algorithmic} 

\smallskip
:
\begin{algorithmic}[1] 
\STATE Bob verifies the results by checking  and , where the modular is applied coordinate-wise.
\end{algorithmic} 

\smallskip
:
\begin{algorithmic}[1] 
\STATE Bob  recovers the results  and .
\end{algorithmic} 
\end{algorithm}

From the above two applications, we can summarize some techniques
in designing secure outsourcing scheme utilizing the outsourcing of
exponential operation as a building block.
\begin{itemize}
\item It is more efficient and secure to share some common parameters in
different subroutines of the outsourcing process. For example, in
outsourcing of DSA, the signer and verifier share the same disguised
base  and . The benefits are that on one hand, the computational
overhead is reduced; on the other hand, less information is exposed
to the cloud. 
\item When outsourcing modular exponentiation with the same base, the computational
overhead can be reduced by jointly verifying the result. For example,
in outsourcing of of the DSA, the results of  and 
can be jointly verified by constructing a common exponent 
that is a linear combination of the two disguised exponents  and
. Therefore, the signer does not have to carry out the extra exponentiation.
\item When making multiple queries to the cloud, the end-user can randomize
the order of queries to increase verifiability. For example, in outsourcing
of DSA, the signer and the verifier need to make  and  queries
to the cloud, respectively. If the order of queries are randomized,
the cloud has to guess the correct orders before guessing the correct
parameters. As a result, the verifiability for the signing process
increases to  and that of the verifying process
increases to . 
\end{itemize}

\section{Performance Evaluation\label{sec:Performance-Comparison}}

To the best of our knowledge, previous research on secure outsourcing
of cryptographic computations mainly focuses on modular exponentiation.
In this section, we first compare ExpSOS with three existing works
on secure outsourcing of modular exponentiation. Then we give some
numeric results to show the efficiency of ExpSOS.


\subsection{Performance Comparison}

\begin{table*}
\caption{Performance Comparison\label{tab:Performance-Comparison-1}}


\begin{spacing}{1.1}
\centering{}\begin{tabular}{|c|c|c|c|c|c|c|}
\hline 
\textbf{Scheme} & \textbf{Model} & \textbf{Pre-Processing} & \textbf{Multiplication} & \textbf{Inversion} & \textbf{Queries to Server} & \textbf{verifiability}\tabularnewline
\hline 
\hline 
\cite{hohenberger2005securely} & MM &   &    &  &  & \tabularnewline
\hline 
\cite{chen2012new} & MM &    &   &  &  & \tabularnewline
\hline 
\cite{wang2014securely} & MS &    &   &  &  & \tabularnewline
\hline 
\multirow{3}{*}{ExpSOS} & HCS & Not Required &  &  &  & Not Applicable\tabularnewline
\cline{2-7} 
 & MM & Not Required &  &  &  & \tabularnewline
\cline{2-7} 
 & MS & Not Required &  &  &  & \tabularnewline
\hline 
\end{tabular}\end{spacing}
\end{table*}


Secure outsourcing of cryptographic computations, especially modular
exponentiation, has been a popular research topic \cite{hohenberger2005securely,chen2012new,wang2014securely,matsumoto1990speeding,de1997schnorr,boyko1998speeding,nguyen2001distribution,van2006speeding}.
For instance, the authors in \cite{van2006speeding} proposed a secure
outsourcing scheme for modular exponentiation with variable-exponent
fixed base and fixed-exponent variable-base under single untrusted
server model. However, the base is known to the server. In \cite{hohenberger2005securely},
the authors considered outsourcing variable-base variable-exponent
modular exponentiation to two untrusted servers. Following this work,
the authors in \cite{chen2012new} improved the scheme in \cite{hohenberger2005securely}
in both efficiency and verifiability. Then, the authors in \cite{wang2014securely}
made further improvement by reducing the two servers model to one
single untrusted server model. In the following, we will compare our
ExpSOS with the three schemes in \cite{hohenberger2005securely,chen2012new,wang2014securely}.

In both \cite{hohenberger2005securely} and \cite{chen2012new}, the
authors consider outsourcing modular exponentiation to two untrusted
servers  and  and it is assumed that the two servers
do not collude which corresponds to our MM model. In both schemes,
a subroutine  is utilized to generate random modular
exponentiation pairs. Specifically, on input a base ,
the subroutine  will generate random pairs in the
form of , where  is a random
number in . Then the end-user can make queries
to  and each query will return a random pair to the
end-user. Typically, the subroutine  is implemented
via two different methods. One method is that a table of random pairs
is pre-computed from a trusted server and stored at the end-user.
Whenever the end-user needs to make a query to , it
just randomly draw a pair from the table. The critical problem of
this method is that it will take a lot of storage space from the end-user.
Specifically, a random pair will take  space, where 
is the bit length of . In addition, to make the generation of
the pairs look random, the table size should be large. As a result,
the storage overhead becomes unacceptable for the resource-constrained
end-users. The other method is to utilize some pre-processing techniques
such as the  generator \cite{boyko1998speeding} and
the the  generator \cite{nguyen2001distribution}.
To generate one random pair, the  generator takes
 modular multiplications, where 
is the bit length of the exponent. 

The scheme proposed in \cite{hohenberger2005securely} can be briefly
summarized as follows. First, the end-user runs  
times to obtain random pairs 
. Then 
can be written as 

where ,  and  are random
integers. The end-user then makes queries in random order to the cloud
server  .
Similarly, the end-user makes queries to the second cloud server 
.
The result can be recovered as .
The result verification is carried out by checking whether 
and . We note that the end-user needs
to make queries to each server  and  for four times,
among which the first two are computation queries and the other two
are test queries. Since the test queries and the computation queries
are independent, the servers can potentially compute the test queries
honestly but cheat in the computation queries. The authors address
this problem by sending out the queries in random order. The verifiability
of this scheme is . In the outsourcing process, 
has to run the subroutine  6 times, make 9 modular
multiplications () and 5 modular inversions (), where
 has a complexity of  
and  is the bit length of the exponent.

Based on \cite{hohenberger2005securely}, the authors in \cite{chen2012new}
made some improvement by reducing the computational overhead to 
,   and  and the queries to
the two servers are reduced to  times in total. Moreover, the
verifiability is improved to .

In comparison, our ExpSOS under MM model can be modified as in Algorithm
\ref{alg:CryptSOS-under-MM}. Since the cloud servers  and
 do not collude, the only way to make the equality condition
satisfied is that  and  both compute honestly. Thus
the verifiability is . Moreover, in this process, we successfully
avoid inversion that is considered much more expensive than multiplication
in field operations. The total computational overhead is only 3 . 

\begin{table*}
\caption{Numeric Results\label{tab:Numeric-Results}}


\centering{}\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline 
\multirow{3}{*}{(bits)} & \multicolumn{9}{c|}{}\tabularnewline
\cline{2-10} 
 & \multicolumn{3}{c|}{} & \multicolumn{2}{c|}{} & \multicolumn{2}{c|}{} & \multicolumn{2}{c|}{}\tabularnewline
\cline{2-10} 
 &  () &  () &  &  () &  &  () &  &  () & \tabularnewline
\hline 
 &  &  &  &  &  &  &  &  & \tabularnewline
\hline 
 &  &  &  &  &  &  &  &  & \tabularnewline
\hline 
 &  &  &  &  &  &  &  &  & \tabularnewline
\hline 
 &  &  &  &  &  &  &  &  & \tabularnewline
\hline 
 &  &  &  &  &  &  &  &  & \tabularnewline
\hline 
 &  &  &  &  &  &  &  &  & \tabularnewline
\hline 
 &  &  &  &  &  &  &  &  & \tabularnewline
\hline 
 &  &  &  &  &  &  &  &  & \tabularnewline
\hline 
\end{tabular}
\end{table*}


\begin{algorithm}[tbh]
\caption{ExpSOS under MM Model\label{alg:CryptSOS-under-MM}}

\smallskip 
\textbf{Input:} .\\
\textbf{Output:} , 

:
\begin{algorithmic}[1]
\STATE  generates a large prime number  and calculate . The public key is  and the private key is .
\STATE  selects random integers  as the temporary key.
\end{algorithmic}


\begin{algorithmic}[1]
\STATE  calculates  and . 
\STATE  then outsources  to both  cloud servers  and .
\end{algorithmic}

:
\begin{algorithmic}[1]
\STATE   computes  and  computes . 
\STATE The results  and  are returned to .
\end{algorithmic}


\begin{algorithmic}[1]
\STATE  checks . Set  if the equality holds; otherwise set .
\end{algorithmic}

:
\begin{algorithmic}[1]
\STATE  recovers the result as .
\end{algorithmic}
\end{algorithm}

In \cite{wang2014securely}, the authors assume a Malicious Single
server (MS) model. Similarly, the scheme utilizes a subroutine 
via some pre-processing techniques such as  that
is a modified version of . The scheme in \cite{wang2014securely}
can be summarized as follows. First, the end-user runs 
 times to obtain random pairs 
. Then it calculates 
 and ,
where  are randomly selected and 
for . The end-user then queries to a single cloud server
 .
The result is recovered as .
The result verification is carried out by checking whether 
is true. Similarly, the queries can be divided as test queries and
computation queries. As a consequence, the cloud can compute honestly
on the test queries and cheat on the computation queries. Thus, due
to the random order of the queries, the verifiability of this scheme
is . We note that in the result recovery process, the
end-user has to compute an exponentiation 
which takes  multiplications. The whole scheme
will take  ,  ,
  and make  queries to the cloud server. In comparison,
ExpSOS can avoid inversion and only needs  ,
where  is a small integer. 

In terms of security, we have shown that ExpSOS can successfully conceal
the base, exponent and the modulus of the modular exponentiation.
It is computationally infeasible for the cloud to derive any key information
from the disguised problem. In comparison, all the above three schemes
\cite{hohenberger2005securely,chen2012new,wang2014securely} can only
conceal the exponent and base while the modulus is exposed to the
cloud. Thus ExpSOS can provide much improved security. Moreover, the
three schemes in \cite{hohenberger2005securely},\cite{chen2012new}
and \cite{wang2014securely} achieve verifiability of ,
 and  respectively. In comparison, the
verifiability of ExpSOS is  that is close to
. This means that the end-user is more confident about the results
returned by the cloud. Furthermore, the security of the schemes in
\cite{hohenberger2005securely} and \cite{chen2012new} relies on
the assumption that the two cloud servers will not collude. The scheme
\cite{wang2014securely} and our proposed ExpSOS are applicable to
one single untrusted server hence eliminating the non-collusion assumption.

The comparison of ExpSOS and the schemes in \cite{hohenberger2005securely,chen2012new,wang2014securely}
is summarized in Table \ref{tab:Performance-Comparison-1}. We can
see that our proposed ExpSOS outperforms other schemes in both computational
complexity and security. ExpSOS also makes the least queries to the
cloud that will introduce the least communication overhead. Moreover,
ExpSOS is cost-aware in computational overhead and security such that
the end-users can select the most suitable outsourcing scheme according
to their own constraints and demands. Also, ExpSOS can be modified
such that it is applicable to HCS, MM and MS model.


\subsection{Numeric Results}

In this section, we measure the performance of ExpSOS for modular
exponentiation through simulation in mobile phones. The computation
of both the end-user and the cloud server is simulated in the same
phone Samsung GT-I9100 with Android 4.1.2 operating system. The CPU
is Dual-core 1.2 GHz Cortex-A9 with  GB RAM. In the outsourcing
process, we focus on the computational gain, denoted as , from
the outsourcing. We measure the local processing time () to
compute the modular exponentiation  without outsourcing
and the local processing time () with outsourcing which includes
the problem transformation, result recovery and result verification.
To measure the performance of ExpSOS under different levels of complexity,
we let the size of the ring  vary from  bits to 
bits. Also, to show the cost-awareness of ExpSOS, we let the size
of the security parameter  vary from  bits to  bits.
The processing time is averaged over  independent rounds. The
numeric result is shown in Table \ref{tab:Numeric-Results} where
each number stands for the average processing time for  rounds.
We can see that when the size of the ring  increases, the
performance gain  also increases for the same security parameter
. This means that when the original problem is more complex, ExpSOS
would have a better performance. The reason is that the complexity
of modular exponentiation depends on the number of multiplications
that is positively correlated to the logarithm of the size of the
ring . However, in ExpSOS the local processing takes almost
the same number of multiplications for a fixed security parameter
. We can also see that there exists a trade-off between security
and computational overhead. When  increases, the computational
overhead increases accordingly. Since the verifiability is ,
a bigger  means better security guarantees. 


\section{Conclusion\label{sec:Conclusion}}

In this paper, we design a secure outsourcing scheme ExpSOS that can
be widely used to outsource general exponentiation operations for
cryptographic computations, including modular exponentiation and scalar
multiplication. The proposed ExpSOS enables end-users to outsource
the computation of exponentiation to a single untrusted server at
the cost of only a few multiplications. We also provide a verification
scheme such that the result is verifiable with probability .
With the security parameter , ExpSOS is cost-aware in that it
can provide different security levels at the cost of different computational
overhead. The comprehensive evaluation demonstrates that our scheme
ExpSOS can significantly improves the existing schemes in efficiency,
security and result verifiability.

\begin{thebibliography}{10}

\bibitem{atallah2002}
M.~J. Atallah, K.~Pantazopoulos, J.~R. Rice, and E.~E. Spafford, ``Secure
  outsourcing of scientific computations,'' {\em Advances in Computers},
  vol.~54, pp.~215--272, 2002.

\bibitem{atallah2010}
M.~J. Atallah and K.~B. Frikken, ``Securely outsourcing linear algebra
  computations,'' in {\em Proceedings of the 5th ACM Symposium on Information,
  Computer and Communications Security}, pp.~48--59, ACM, 2010.

\bibitem{atallah2005secure}
M.~J. Atallah and J.~Li, ``Secure outsourcing of sequence comparisons,'' {\em
  International Journal of Information Security}, vol.~4, no.~4, pp.~277--287,
  2005.

\bibitem{wang2011infocom}
C.~Wang, K.~Ren, and J.~Wang, ``Secure and practical outsourcing of linear
  programming in cloud computing,'' in {\em INFOCOM, 2011 Proceedings IEEE},
  pp.~820--828, IEEE, 2011.

\bibitem{chen2014efficient}
X.~Chen, W.~Susilo, J.~Li, D.~S. Wong, J.~Ma, S.~Tang, and Q.~Tang, ``Efficient
  algorithms for secure outsourcing of bilinear pairings,'' {\em Theoretical
  Computer Science}, 2014.

\bibitem{blanton2012secure}
M.~Blanton, M.~J. Atallah, K.~B. Frikken, and Q.~Malluhi, ``Secure and
  efficient outsourcing of sequence comparisons,'' in {\em Computer
  Security--ESORICS 2012}, pp.~505--522, Springer, 2012.

\bibitem{blanton2010secure}
M.~Blanton and M.~Aliasgari, ``Secure outsourcing of dna searching via finite
  automata,'' in {\em Data and Applications Security and Privacy XXIV},
  pp.~49--64, Springer, 2010.

\bibitem{hohenberger2005securely}
S.~Hohenberger and A.~Lysyanskaya, ``How to securely outsource cryptographic
  computations,'' in {\em Theory of Cryptography}, pp.~264--282, Springer,
  2005.

\bibitem{chen2012new}
X.~Chen, J.~Li, J.~Ma, Q.~Tang, and W.~Lou, ``New algorithms for secure
  outsourcing of modular exponentiations,'' in {\em Computer Security--ESORICS
  2012}, pp.~541--556, Springer, 2012.

\bibitem{wang2014securely}
Y.~Wang, Q.~Wu, D.~S. Wong, B.~Qin, S.~S. Chow, Z.~Liu, and X.~Tan, ``Securely
  outsourcing exponentiations with single untrusted program for cloud
  storage,'' in {\em Computer Security-ESORICS 2014}, pp.~326--343, Springer,
  2014.

\bibitem{zhong2000modular}
L.~Zhong, ``Modular exponentiation algorithm analysis for energy consumption
  and performance,'' tech. rep., Citeseer, 2000.

\bibitem{william2003}
W.~Stallings, {\em Cryptography and Network Security, 4/E}.
\newblock Pearson Education, Inc., 2003.

\bibitem{shamir1985identity}
A.~Shamir, ``Identity-based cryptosystems and signature schemes,'' in {\em
  Advances in cryptology}, pp.~47--53, Springer, 1985.

\bibitem{boneh2001identity}
D.~Boneh and M.~Franklin, ``Identity-based encryption from the weil pairing,''
  in {\em Advances in Cryptology CRYPTO 2001}, pp.~213--229, Springer, 2001.

\bibitem{hoffstein2008introduction}
J.~Hoffstein, J.~C. Pipher, J.~H. Silverman, and J.~H. Silverman, {\em An
  introduction to mathematical cryptography}.
\newblock Springer, 2008.

\bibitem{matsumoto1990speeding}
T.~Matsumoto, K.~Kato, and H.~Imai, ``Speeding up secret computations with
  insecure auxiliary devices,'' in {\em Advances in Cryptology--CRYPTO'88},
  pp.~497--506, Springer, 1990.

\bibitem{de1997schnorr}
P.~de~Rooij, ``On schnorr's preprocessing for digital signature schemes,'' {\em
  Journal of Cryptology}, vol.~10, no.~1, pp.~1--16, 1997.

\bibitem{boyko1998speeding}
V.~Boyko, M.~Peinado, and R.~Venkatesan, ``Speeding up discrete log and
  factoring based schemes via precomputations,'' in {\em Advances in
  Cryptology--EUROCRYPT'98}, pp.~221--235, Springer, 1998.

\bibitem{nguyen2001distribution}
P.~Q. Nguyen, I.~E. Shparlinski, and J.~Stern, ``Distribution of modular sums
  and the security of the server aided exponentiation,'' in {\em Cryptography
  and Computational Number Theory}, pp.~331--342, Springer, 2001.

\bibitem{van2006speeding}
M.~Van~Dijk, D.~Clarke, B.~Gassend, G.~E. Suh, and S.~Devadas, ``Speeding up
  exponentiation using an untrusted computational resource,'' {\em Designs,
  Codes and Cryptography}, vol.~39, no.~2, pp.~253--273, 2006.

\end{thebibliography}

\end{document}
