\documentclass{LMCS}

\def\dOi{10(1:17)2014}
\lmcsheading {\dOi}
{1--52}
{}
{}
{Aug.~27, 2012}
{Mar.~24, 2014}
{}

\keywords{Linear type theory, monads, computational effects, categorical semantics, enriched category theory, state passing translation}
\ACMCCS{[{\bf Theory of computation}]: Semantics and
  reasoning---Program semantics---Denotational
  semantics\,/\,Categorical semantics; Logic---Linear logic\,/\,Type theory}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{stmaryrd}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{xy}
\xyoption{all}
\newcommand{\hide}[1]{}
\usepackage{url,hyperref}
\urldef{\mailsa}\path|{alfred.hofmann, ursula.barth, ingrid.haas, frank.holzwarth,|
\urldef{\mailsb}\path|anna.kramer, leonie.kunz, christine.reiss, nicole.sator,|
\urldef{\mailsc}\path|erika.siebert-cole, peter.strasser, lncs}@springer.com|    
\usepackage[height=.8cm,silent]{diagrams}
\newarrow{Into}C--->




\message{<Paul Taylor's Proof Trees, 2 August 1996>}


\def\introrule{{\cal I}}\def\elimrule{{\cal E}}\def\andintro{\using{\land}\introrule\justifies}\def\impelim{\using{\Rightarrow}\elimrule\justifies}\def\allintro{\using{\forall}\introrule\justifies}\def\allelim{\using{\forall}\elimrule\justifies}\def\falseelim{\using{\bot}\elimrule\justifies}\def\existsintro{\using{\exists}\introrule\justifies}

\def\andelim#1{\using{\land}#1\elimrule\justifies}\def\orintro#1{\using{\lor}#1\introrule\justifies}

\def\impintro#1{\using{\Rightarrow}\introrule_{#1}\justifies}\def\orelim#1{\using{\lor}\elimrule_{#1}\justifies}\def\existselim#1{\using{\exists}\elimrule_{#1}\justifies}



\newdimen\proofrulebreadth \proofrulebreadth=.05em
\newdimen\proofdotseparation \proofdotseparation=1.25ex
\newdimen\proofrulebaseline \proofrulebaseline=2ex
\newcount\proofdotnumber \proofdotnumber=3
\let\then\relax
\def\hfi{\hskip0pt plus.0001fil}
\mathchardef\squigto="3A3B
\newif\ifinsideprooftree\insideprooftreefalse
\newif\ifonleftofproofrule\onleftofproofrulefalse
\newif\ifproofdots\proofdotsfalse
\newif\ifdoubleproof\doubleprooffalse
\let\wereinproofbit\relax
\newdimen\shortenproofleft
\newdimen\shortenproofright
\newdimen\proofbelowshift
\newbox\proofabove
\newbox\proofbelow
\newbox\proofrulename
\def\shiftproofbelow{\let\next\relax\afterassignment\setshiftproofbelow\dimen0 }
\def\shiftproofbelowneg{\def\next{\multiply\dimen0 by-1 }\afterassignment\setshiftproofbelow\dimen0 }
\def\setshiftproofbelow{\next\proofbelowshift=\dimen0 }
\def\setproofrulebreadth{\proofrulebreadth}

\def\prooftree{\ifnum  \lastpenalty=1
\then   \unpenalty
\else   \onleftofproofrulefalse
\fi
\ifonleftofproofrule
\else   \ifinsideprooftree
        \then   \hskip.5em plus1fil
        \fi
\fi
\bgroup \setbox\proofbelow=\hbox{}\setbox\proofrulename=\hbox{}\let\justifies\proofover\let\leadsto\proofoverdots\let\Justifies\proofoverdbl
\let\using\proofusing\let\endprooftree\fi
\proofdotsfalse\doubleprooffalse
\let\thickness\setproofrulebreadth
\let\shiftright\shiftproofbelow \let\shift\shiftproofbelow
\let\shiftleft\shiftproofbelowneg
\let\ifwasinsideprooftree\ifinsideprooftree
\insideprooftreetrue
\setbox\proofabove=\hbox\bgroup\egroup  \shortenproofleft=\dimen0
\shortenproofright=\dimen1
\proofrulebreadth=\dimen2
\proofbelowshift=\dimen3
\proofdotseparation=\dimen4
\proofdotnumber=\count255
}

\def\proofover{\eproofbit \setbox\proofbelow=\hbox\bgroup \let\wereinproofbit\proofover
\displaystyle
}\def\proofoverdots{\eproofbit \proofdotstrue
\setbox\proofbelow=\hbox\bgroup \let\wereinproofbit\proofoverdots

}

\def\endprooftree{\eproofbit \dimen5 =0pt\dimen0=\wd\proofabove \advance\dimen0-\shortenproofleft
\advance\dimen0-\shortenproofright
\dimen1=.5\dimen0 \advance\dimen1-.5\wd\proofbelow
\dimen4=\dimen1
\advance\dimen1\proofbelowshift \advance\dimen4-\proofbelowshift
\ifdim  \dimen1<0pt
\then   \advance\shortenproofleft\dimen1
        \advance\dimen0-\dimen1
        \dimen1=0pt
\ifdim  \shortenproofleft<0pt
        \then   \setbox\proofabove=\hbox{\kern-\shortenproofleft\unhbox\proofabove}\shortenproofleft=0pt
        \fi
\fi
\ifdim  \dimen4<0pt
\then   \advance\shortenproofright\dimen4
        \advance\dimen0-\dimen4
        \dimen4=0pt
\fi
\ifdim  \shortenproofright<\wd\proofrulename
\then   \shortenproofright=\wd\proofrulename
\fi
\dimen2=\shortenproofleft \advance\dimen2 by\dimen1
\dimen3=\shortenproofright\advance\dimen3 by\dimen4
\ifproofdots
\then
        \dimen6=\shortenproofleft \advance\dimen6 .5\dimen0
        \setbox1=\vbox to\proofdotseparation{\vss\hbox{}\vss}\setbox0=\hbox{\advance\dimen6-.5\wd1
                \kern\dimen6
                \unhbox\proofrulename}\else   \dimen6=\fontdimen22\the\textfont2 \dimen7=\dimen6
        \advance\dimen6by.5\proofrulebreadth
        \advance\dimen7by-.5\proofrulebreadth
        \setbox0=\hbox{\kern\shortenproofleft
                \ifdoubleproof
                \then   \hbox to\dimen0{\mkern-2mu=\mkern-2mu}\else   \vrule height\dimen6 depth-\dimen7 width\dimen0
                \fi
                \unhbox\proofrulename}\ht0=\dimen6 \dp0=-\dimen7
\fi
\let\doll\relax
\ifwasinsideprooftree
\then   \let\VBOX\vbox
\else   \ifmmode\else\fi
        \let\VBOX\vcenter
\fi
\VBOX   {\baselineskip\proofrulebaseline \lineskip.2ex
        \expandafter\lineskiplimit\ifproofdots0ex\else-0.6ex\fi
        \hbox   spread\dimen5   {\hfi\unhbox\proofabove\hfi}\hbox{\box0}\hbox   {\kern\dimen2 \box\proofbelow}}\doll \global\dimen2=\dimen2
\global\dimen3=\dimen3
\egroup \ifonleftofproofrule
\then   \shortenproofleft=\dimen2
\fi
\shortenproofright=\dimen3
\onleftofproofrulefalse
\ifinsideprooftree
\then   \hskip.5em plus 1fil \penalty2
\fi
}

 

\newcommand{\colim}{\operatorname{colim}}

\newtheorem{lemma}{Lemma}[section]
\newtheorem{definition}[lemma]{Definition}
\newtheorem{theorem}[lemma]{Theorem}
\newtheorem{proposition}[lemma]{Proposition}
\newtheorem{corollary}[lemma]{Corollary}
\newtheorem{example}[lemma]{Example}
\newtheorem{examples}[lemma]{Examples}
\newtheorem*{terminology}{Terminology}

\newcommand{\dotshort}{\mathrel{.\,.}}


\newenvironment{examplet}[1]{\begin{italicexample}[#1]\em}{\end{italicexample}}






\newenvironment{proofof}[1]{\begin{proof}[Proof of {#1}.]}{\end{proof}}



\newenvironment{proofsketchof}[1]{\begin{proof}[Proof of {#1} (sketch).]}{\end{proof}}




\newenvironment{proofsketch}{\begin{proof}[Proof (sketch)]}{\end{proof}}



\newenvironment{proofnotes}{\begin{proof}[Proof notes]}{\end{proof}}






\newcommand{\mj}[3]{#1 \mathrel{\vdash} #2 \colon \! #3}
\newcommand{\vj}[3]{#1 \mathrel{\vdash^{v}} #2 \colon \! #3}
\newcommand{\pj}[3]{#1 \mathrel{\vdash^p} #2 \colon \! #3}
\newcommand{\vjname}{{\vdash^{v}}}
\newcommand{\pjname}{{\vdash^p}}
\newcommand{\meq}[4]{#1 \mathrel{\vdash} #2\equiv #3 \colon \! #4}
\newcommand{\veq}[4]{#1 \mathrel{\vdash^{v}} #2\equiv #3 \colon \! #4}
\newcommand{\peq}[4]{#1 \mathrel{\vdash^p} #2\equiv #3 \colon \! #4}

\newcommand{\STA}{\sigma}
\newcommand{\STB}{\tau}
\newcommand{\STC}{\upsilon}

\newcommand{\spi}{\pi}
\newcommand{\slet}[3]{#2 \, \codefont{to} \, #1 \ld #3}
\newcommand{\return}[1]{\codefont{return} \, #1}



\newcommand{\loc}{\mathrm{Loc}}
\newcommand{\val}{\mathrm{Val}}
\newcommand{\bool}{\mathrm{bool}}
\newcommand{\nat}{\mathrm{nat}}
\newcommand{\EECstate}{\underline{\mathrm{S}}}
\newcommand{\EECarbstate}{\comptype{\mathsf{S}}}
\newcommand{\EECarbret}{\comptype{\mathsf{R}}}
\newcommand{\EECret}{\comptype{\mathrm{R}}}
\newcommand{\svar}s
\newcommand{\kvar}k



\newcommand{\readas}[3]{\codefont{read}_{#1} \, \codefont{as }\, #2 \ld #3}
\newcommand{\writeto}[3]{{#1} : = #2 ; #3}
\newcommand{\print}[1]{\codefont{print}_{#1}}
\newcommand{\outputop}{\codefont{output}}
\newcommand{\inputop}{\codefont{input}}
\newcommand{\orop}{\codefont{or}}
\newcommand{\infixor}[2]{#1\, \orop\, #2}
\newcommand{\random}{\codefont{random}}
\newcommand{\coop}{\codefont{op}}



\newcommand{\geffrandom}{\codefont{random}}
\newcommand{\geffreadcell}[1]{\codefont{deref}}
\newcommand{\geffwritecell}[1]{\codefont{assign}}

\newcommand{\saccrandom}{\codefont{random}}
\newcommand{\saccreadcell}[1]{\codefont{read}_{#1}}
\newcommand{\saccwritecell}[1]{\codefont{write}_{#1}}


\newcommand{\effctx}{\Xi}
\newcommand{\effj}[3]{#1 ; #2 \vdash #3}
\newcommand{\op}{\codefont{op}}

\newcommand{\effabs}[3]{(#1 \co \! #2) \ld #3}



\newcommand{\ltj}[3]{#1 \vdash^v \, #2 \colon \! #3}

\newcommand{\pto}{\rightharpoonup}

\newcommand{\codefont}[1]{\mathtt{#1}}

\newcommand{\comptype}[1]{\underline{#1}}

\newcommand{\letexp}[3]{\codefont{let} \, #1 \,\codefont{ be } \, #2 \,\codefont{ in } \,#3}
\newcommand{\eq}{\textit{eq}}
\newcommand{\fold}{\codefont{fold}}
\newcommand{\interm}{\codefont{in}}
\newcommand{\pack}{\codefont{pack}}
\newcommand{\unfold}{\codefont{unfold}}
\newcommand{\out}{\codefont{out}}
\newcommand{\linlambda}{\comptype{\lambda}}

\newcommand{\ld}{\mathpunct{.}}
\newcommand{\bang}[1]{{!} \,#1}
\newcommand{\co}{\colon}
\newcommand{\fixedtermtypekindfont}{\mathsf}


\newcommand{\ftv}[1]{\text{FTV}(#1)}
\newcommand{\fv}[1]{\text{FV}(#1)}
\newcommand{\fn}[1]{\text{FN}(#1)}

\newcommand{\TVX}{X}
\newcommand{\TVY}{Y}
\newcommand{\TVZ}{Z}

\newcommand{\algX}{{\comptype{X}}}
\newcommand{\algY}{{\comptype{Y}}}
\newcommand{\algZ}{\comptype{Z}}

\newcommand{\VconstA}{\alpha}
\newcommand{\VconstB}{\beta}
\newcommand{\VconstC}{\gamma}

\newcommand{\CconstA}{\comptype{\alpha}}
\newcommand{\CconstB}{\comptype{\beta}}
\newcommand{\CconstC}{\comptype{\gamma}}





\newcommand{\VA}{\mathsf{A}}
\newcommand{\VB}{\mathsf{B}}
\newcommand{\VC}{\mathsf{C}}
\newcommand{\VD}{\mathsf{D}}

\newcommand{\CA}{\comptype{\mathsf{A}}}
\newcommand{\CB}{\comptype{\mathsf{B}}}
\newcommand{\CC}{\comptype{\mathsf{C}}}
\newcommand{\CD}{\comptype{\mathsf{D}}}

\newcommand{\CR}{\comptype{\mathsf{R}}}
\newcommand{\CI}{\comptype{I}}



\newcommand{\Ftc}{!}\newcommand{\lpop}{\multimap}
\newcommand{\tensor}{\otimes}
\newcommand{\ltensortype}[2]{{!} #1 \, {\tensor} \, #2}
\newcommand{\lpowertype}[2]{#1\to #2}
\newcommand{\prodtype}{\times}
\newcommand{\Ctimes}{\mathop{\underline{\times}}}
\newcommand{\Cone}{{\underline{1}}}

\newcommand{\lfun}{\multimap}
\newcommand{\All}[2]{\forall #1.\: #2}

\newcommand{\Exists}[2]{\exists #1.\: #2}
\newcommand{\Mu}[2]{\mu #1.\: #2}
\newcommand{\Nu}[2]{\nu #1.\: #2}


\newcommand{\one}{{1}}
\newcommand{\algplus}{\oplus}
\newcommand{\algtimes}{{\underline\times}}
\newcommand{\Algplus}{\bigoplus}
\newcommand{\algone}{{\underline 1}} \newcommand{\valone}{{1}} \newcommand{\algzero}{\comptype{0}}
\newcommand{\algunit}{\mathrm{I}}
\newcommand{\algMu}[2]{\mu^\circ #1.\: #2}
\newcommand{\algNu}[2]{\nu^\circ #1.\: #2}

\newcommand{\algexists}[2]{\exists^{\circ} #1.\, #2}



\newcommand{\llambda}{\linlambda}
\newcommand{\lam}[3]{\lambda #1.\: #3}
\newcommand{\lamnt}[2]{\lambda #1.\: #2}
\newcommand{\llam}[3]{\llambda #1.\: #3}
\newcommand{\llamnt}[2]{\llambda #1.\: #2}
\newcommand{\Let}[3]{\mathrm{let}\: {\bang {#1}}\:\mathrm{be}\:{#2} \;\mathrm{in}\: #3}
\newcommand{\Lam}[2]{\Lambda #1.\: #2}
\newcommand{\vars}[1]{\mathrm{vars}(#1)}
\newcommand{\linvars}[1]{\mathrm{linvars}(#1)}
\newcommand{\Inl}[1]{\mathrm{in_1}(#1)}
\newcommand{\Inr}[1]{\mathrm{in_2}(#1)}
\newcommand{\Ini}[2]{\mathrm{in}_{#1}(#2)}
\newcommand{\Case}[5]{\mathrm{case}\: {#1}\:\mathrm{of}\:\Inl{#2}.\: #3| \: \Inr{#4}.\: #5}
\newcommand{\eecinl}[1]{\mathrm{inl}(#1)}
\newcommand{\eecinr}[1]{\mathrm{inr}(#1)}
\newcommand{\eecimage}[1]{\mathrm{image}(#1)}
\newcommand{\eeccase}[5]{\mathrm{case}~#1~\mathrm{of}~(\vinl{#2}.#3|\vinr{#4}.#5)}

\newcommand{\vimage}[1]{\mathrm{?}(#1)}


\newcommand{\prj}[2]{\pi_{#1}(#2)}
\newcommand{\fst}[1]{\prj 1 {#1}}
\newcommand{\snd}[1]{\prj 2 {#1}}




\newcommand{\cbvdo}[1]{\mathrm{do\ }#1}
\newcommand{\cbvimage}[1]{\codefont{?}(#1)}


\newcommand{\ltensorterm}[2]{{!  #1} \tensor #2}
\newcommand{\lpowerterm}[3]{\lambda #1.\, #3}

\newcommand{\algstar}{\star} 

\newcommand{\algpair}[2]{\langle #1,#2 \rangle^{\circ}}
\newcommand{\algpi}[2]{\mathrm{proj}^\circ_{#1}(#2)}
\newcommand{\algfst}[1]{\mathrm{fst}^\circ(#1)}
\newcommand{\algsnd}[1]{\mathrm{snd}^\circ(#1)}

\newcommand{\genalgcase}[3]{\comptype{\mathrm{case}} \, #1 \,\mathrm{of}\,\{ \algin{i}{#2}. \, #3\}}

\newcommand{\algi}{\mathrm{i}}
\newcommand{\Letunit}[2]{\mathrm{let}\: {\algi}={#1} \;\mathrm{in}\: #2}



\newcommand{\letdot}[4]{{#3}\:\mathrm{to}\:{(\ltensorterm{#1}{#2})}.\;#4}

\newcommand{\algpack}[2]{\pair{#1}{#2}}
\newcommand{\algunpack}[4]{\mathrm{let}\: \algpack{#1}{#2} = {#3} \;\mathrm{in}\: #4}


\newcommand{\Unit}{\texttt{unit}}

\newcommand{\lappl}[2]{#1[ #2 ]}

\newcommand{\compterm}{\mathrm{comp}} 

\newcommand{\In}[2]{#1 \colon  \! #2}
\newcommand{\rIn}[2]{#1 \colon  #2}
\newcommand{\aj}[4]{#1 \mid  \! #2 \, \vdash \, \rIn{#3}{#4}}
\newcommand{\aeq}[5]{#1 \mid  \! #2 \, \vdash \, \rIn{#3\equiv #4}{#5}}
\newcommand{\ajth}[5]{#1 \mid  \! #2 \, \vdash_{#5} \, \rIn{#3}{#4}}
\newcommand{\tj}[3]{\aj{#1}{{-}}{#2}{#3}}
\newcommand{\teq}[4]{\aj{#1}{{-}}{#2\equiv #3}{#4}}
\newcommand{\lamj}[3]{#1 \vdash \, \rIn{#2}{#3}} 


\newcommand{\rj}[4]{#1 \mid  \! #2 \, \vdash \, #3 \,\colon #4}
\newcommand{\dedj}[4]{#1 \mid  \! #2 \mid \! #3\, \vdash \, #4}

\newcommand{\trj}[3]{#1 \mid  \! #2 \, \vdash \, #3}



\newcommand{\lambdac}{\lambda_\mathrm{c}}





\newcommand{\CBV}[1]{\mathrm{FGCBV}\!_{#1}}
\newcommand{\EEC}{\mathrm{EEC}}


\newcommand{\FGCBV}{FGCBV}
\newcommand{\ECBV}{ECBV}
\newcommand{\ECBVS}[1]{\mathrm{ECBV}_{#1}^{\states}}


\newcommand{\CpsVT}[1]{#1^{\mathcal{V}_{\CR}}}
\newcommand{\CpsCT}[1]{#1^{\mathcal{C}_{\CR}}}

\newcommand{\Cpsiso}[1]{i_{#1}}
\newcommand{\Cpsniso}[1]{p_{#1}} 

\newcommand{\CpsVVT}[1]{#1^{\mathcal{V}_{\CR}\mathcal{V}_{\CR}}}
\newcommand{\CpsCCT}[1]{#1^{\mathcal{C}_{\CR}\mathcal{C}_{\CR}}}
\newcommand{\CpsVVVT}[1]{#1^{\mathcal{V}_{\CR}\mathcal{V}_{\CR}\mathcal{V}_{\CR}}}
\newcommand{\CpsCCCT}[1]{#1^{\mathcal{C}_{\CR}\mathcal{C}_{\CR}\mathcal{C}_{\CR}}}

\newcommand{\CpsVTcbv}[1]{#1^{\mathrm{cbv}\mathcal{V}_{\CR}}}
\newcommand{\CpsCTcbn}[1]{#1^{\mathrm{cbn}\,\mathcal{C}_{\CR}}}
\newcommand{\CpsVTcbn}[1]{#1^{\mathrm{cbn}\,\mathcal{V}_{\CR}}}

\newcommand{\Viso}[1]{j_{#1}}
\newcommand{\Ciso}[1]{k_{#1}}

\newcommand{\viso}[1]{q_{#1}}
\newcommand{\niso}[1]{r_{#1}}



\newcommand{\CBVtoEEC}[1]{#1^{\circ}}
\newcommand{\CBVtoEECbase}[2]{#2^{#1}}



\newcommand{\Mod}{\mathcal{M}}



\newcommand{\cps}[1]{#1^{*}} 

\newcommand{\cbv}[1]{#1^{\mathrm{cbv}}}
\newcommand{\cbn}[1]{#1^{\mathrm{cbn}}}

\newcommand{\cbvLincps}[1]{#1^{\mathrm{cbv}_{\CR}}}
\newcommand{\cbnLincps}[1]{#1^{\mathrm{cbn}_{\CR}}}

\renewcommand{\vec}[1]{\bar{#1}}



\DeclareMathOperator{\Prod}{\textstyle{\prod}}
\DeclareMathOperator{\Coprod}{\textstyle{\coprod}}
\DeclareMathOperator{\Sum}{\textstyle{\sum}}



\newcommand{\modelM}{\fixedcatfont{M}} 
\newcommand{\modelN}{\fixedcatfont{N}} 
\newcommand{\dual}[1]{#1^{\bot}} \newcommand{\ddual}[1]{#1^{\bot\bot}} 



\newcommand{\VCat}{\fixedcatfont{V}} \newcommand{\CCat}{\fixedcatfont{C}} \newcommand{\DCat}{\fixedcatfont{D}} 

\newcommand{\Alg}[1]{\mathbf{Alg}(#1)}
\newcommand{\Kl}[1]{\mathbf{Kl}(#1)}

\newcommand{\VHom}[2]{[#1 \to #2]} \newcommand{\CHom}[2]{\CCat(#1, #2)} \newcommand{\CHomp}[2]{\CCat'(#1, #2)} 

\newcommand{\FFun}{F} \newcommand{\UFun}{U} \newcommand{\GFun}{G} \newcommand{\FFunK}[1]{F^K} \newcommand{\UFunK}[1]{U^K} 

\newcommand{\UEM}[1]{U^{#1}} \newcommand{\UKl}[1]{U_{#1}} 

\newcommand{\Id}{\textit{Id}} 


\newcommand{\cotensor}[2]{#2^{#1}}
\newcommand{\ltensoriso}{\lambda}
\newcommand{\ltensorisoKl}{\lambda_{\mathbf{Kl}}}

\newcommand{\CZero}{0}
\newcommand{\COne}{1}
\newcommand{\CPlus}{+}
\newcommand{\CTimes}{\times}



\newcommand{\VOne}{1}
\newcommand{\VTimes}{\times}

\newcommand{\proj}{\pi}
\newcommand{\id}{\mathit{id}}
\newcommand{\ev}{\mathit{ev}}
\newcommand{\Klev}{\mathit{ev}_{\mathbf{Kl}}}
\newcommand{\cotensorev}{\mathit{ev}}
\newcommand{\ccomp}{\mathit{comp}} \newcommand{\cotensoriso}{\xi}
\newcommand{\cotensorisoind}[3]{\cotensoriso_{#1, #2, #3}}
\newcommand{\ltensor}[2]{#1 \cdot #2}
\newcommand{\ltensorname}{\ltensor {-_1}{-_2}}
\newcommand{\lpower}[2]{#2^{#1}}
\newcommand{\ltensorisoind}[3]{\ltensoriso_{#1, #2, #3}}
\newcommand{\adjiso}[2]{\rho_{#1, #2}} \newcommand{\helpiso}[2]{\phi} \newcommand{\cid}{\mathit{id}} \newcommand{\termmap}{\star} 

\newcommand{\fixedcatfont}{\mathbf}
\newcommand{\imp}{\supset}
\newcommand{\denlb}{[\![}
\newcommand{\denrb}{]\!]}
\newcommand{\den}[1]{\denlb{#1}\denrb}
\newcommand{\bdenlb}{(\![}
\newcommand{\bdenrb}{]\!)}
\newcommand{\bden}[1]{\bdenlb{#1}\bdenrb}

\newcommand{\pair}[2]{\langle #1 , #2 \rangle}
\newcommand{\tuple}[2]{\langle #1 , \dots , #2 \rangle}
\newcommand{\ituple}[2]{\langle #1 \rangle_{#2}} 

\newcommand{\meet}{\wedge}
\newcommand{\biimp}{\supset\!\!\subset}
\newcommand{\iso}{\cong}
\newcommand{\equi}{\simeq}

\newcommand{\inv}[1]{#1^{-1}}

\newcommand{\ltensorunit}{\eta}

\newcommand{\vrel}[2]{\mathsf{Rel}_{v}(#1, #2)}
\newcommand{\crel}[2]{\mathsf{Rel}_{c}(#1, #2)}
\newcommand{\rel}[3]{\mathsf{Rel}_{#1}(#2, #3)}
\newcommand{\Prop}{\mathsf{Prop}}


\newcommand{\relabs}[3]{(#1, #2) \ld #3}

\newcommand{\SA}{A}
\newcommand{\SB}{B}
\newcommand{\SC}{C}
\newcommand{\SP}{P}
\newcommand{\SQ}{Q}


\newcommand{\algA}{\underline{A}}
\newcommand{\algB}{\underline{B}}
\newcommand{\algC}{\underline{C}}
\newcommand{\algD}{\underline{D}}
\newcommand{\algR}{\underline{R}}

\newcommand{\tensorunit}{\underline{I}}
\newcommand{\stateobj}{{\underline{S}}}
\newcommand{\retobj}{\underline{R}}

\newcommand{\vrho}{\rho}
\newcommand{\algrho}{\underline{\rho}}

\newcommand{\FP}{\mathrm{FP}}
\newcommand{\Set}{\mathbf{Set}}
\newcommand{\Sets}{\mathbf{Set}}
\newcommand{\Relations}{\mathbf{Rel}}
\newcommand{\CatA}{\mathcal{A}}
\newcommand{\CatB}{\mathcal{B}}
\newcommand{\CatC}{\mathcal{C}}

\newcommand{\CatReplete}{\mathcal{C}_\mathrm{rep}}

\newcommand{\CatFun}{\Rightarrow}

\newcommand{\SetA}{\mathbf{A}}
\newcommand{\SetC}{\mathbf{C}}

\newcommand{\SetReplete}{\mathbf{C}_\textrm{rep}}

\newcommand{\SubC}[1]{\mathrm{Sub}_{\CatC}(#1)}
\newcommand{\SubA}[1]{\mathrm{Sub}_{\CatA}(#1)}


\newcommand{\RC}{\mathcal{R}_{\CatC}}
\newcommand{\RA}{\mathcal{R}_{\CatA}}
\newcommand{\RAprime}{\mathcal{R}_{\CatA'}}

\newcommand{\Rel}[1]{\mathcal{R}(#1)}
\newcommand{\RelC}[1]{\RC(#1)}
\newcommand{\RelA}[1]{\RA(#1)}
\newcommand{\RelAprime}[1]{\RAprime'(#1)}


\newcommand{\Graph}[1]{\langle #1 \rangle}

\newcommand{\Sem}[1]{[\! [ #1 ] \! ]}
\newcommand{\Sems}[2]{\Sem{#2}_{#1}}
\newcommand{\Semr}[2]{\Sem{#2}^{\mathcal{R}}_{#1}}


\newcommand{\SemCT}[1]{\CCat\den{#1}}
\newcommand{\SemVT}[1]{\VCat\den{#1}}
\newcommand{\SemCTiso}[1]{s_{#1}}

\newcommand{\oprel}[1]{#1^{\mathrm{op}}}
\newcommand{\eqrel}{\equiv}

\newcommand{\algiso}{\cong^\circ}

\newcommand{\toptop}[1]{{#1}^{\top\top}}

\newcommand{\states}{{\underline{\mathrm{S}}}}
\newcommand{\locations}{L}
\newcommand{\values}{V}

\newcommand{\alphabet}{A}
\newcommand{\strings}[1]{#1^*}





\newcommand{\SynMonadModel}{(\VSynM,{1\pto(-)})}
\newcommand{\SynEnrichedModel}{(\VSynE,\CSynE, \states)}
\newcommand{\SynEnrichedModelth}[1]{(\VSynE^{#1},\CSynE^{#1}, \states)}
\newcommand{\SynKlModel}{(\VSynKl,\CSynKl, J)}
\newcommand{\SynKlModelth}[1]{(\VSynKl^{#1},\CSynKl^{#1}, J)}

\newcommand{\VSynKl}{\mathcal{V}_{\textsc{fgcbv}}}
\newcommand{\CSynKl}{\mathcal{C}_{\textsc{fgcbv}}}
\newcommand{\VSynE}{\mathcal{V}_{\textsc{ecbv}}}
\newcommand{\CSynE}{\mathcal{C}_{\textsc{ecbv}}}








\newcommand{\Klmodel}{enriched Kleisli model}
\newcommand{\dKlmodel}{distributive Kleisli model}
\newcommand{\enrmodel}{enriched call-by-value model}
\newcommand{\denrmodel}{distributive enriched model}



\newcommand{\ENR}{\TwoCatFont{Enr}}
\newcommand{\dENR}{\TwoCatFont{dEnr}}
\newcommand{\CATECBV}{\TwoCatFont{Ecbv}}
\newcommand{\dCATECBV}{\TwoCatFont{dEcbv}}
\newcommand{\Freyd}{\TwoCatFont{Kleisli}}
\newcommand{\dFreyd}{\TwoCatFont{dKleisli}}
\newcommand{\CATECBVtheory}[1]{\dCATECBV_{#1}}
\newcommand{\Freydtheory}[1]{\dFreyd_{#1}}



\newcommand{\FreydToECBV}{\mathbf{St}}
\newcommand{\ECBVToFreyd}{\mathbf{Kl}}



\newcommand{\KlCat}[3]{\mathbf{Kl}_{#3}} \newcommand{\Klltensor}[2]{#1 \cdot_{\mathbf{Kl}} #2}

\newcommand{\KlHom}[3]{\KlCat{}{}{#1}(#2,#3)} 



\newcommand{\stateiso}{\delta}
\newcommand{\VTwoCell}{\beta}
\newcommand{\CTwoCell}{\gamma}





\newcommand{\Cat}{\mathbf{Cat}}
\newcommand{\TwoCatFont}[1]{\mathfrak{#1}}
\newcommand{\CoprodCat}{\TwoCatFont{Coprod}}
\newcommand{\CAT}{\TwoCatFont{Cat}}
\newcommand{\CocompCat}{\TwoCatFont{Cocomp}}
\newcommand{\TwoMultiCat}{\TwoCatFont{K}}













\newcommand{\opcat}[1]{#1^{\mathrm{op}}}
\newcommand{\ordinary}[1]{#1_{\mathrm{o}}}

\newcommand{\Psh}[1]{\widehat{#1}}
\newcommand{\Yon}{\mathbf{y}}

\newcommand{\nameof}[1]{\ulcorner #1 \urcorner}

\newcommand{\ntarrow}{\to} 

\newcommand{\MonT}{T} 

\newcommand{\lradj}[2]{{#1} \dashv {#2}} 

\newcommand{\initobj}{0} \newcommand{\initmorph}{?} 



\newcommand{\loccit}{\emph{loc.\ cit.}}

\newcommand{\defnfont}{\textbf}
\newcommand{\emphdefn}[1]{\defnfont{#1}}

\newcommand{\GAP}{\hspace*{.5cm}}
\newcommand{\GAPGAP}{\GAP\GAP}

\newcommand{\gnl}{\4ex]} 





\newcommand{\eqdef}{\defeq}
\newcommand{\defeq}{\mathrel{\,\stackrel{\mbox{\tiny{}}}=\,}}


\newcommand{\todo}[1]{\textbf{[to do: #1]}}


\newcommand{\vin}[2]{{\mathrm{in}_{#1}}(#2)}
\newcommand{\vinl}[1]{\vin{1}{#1}}
\newcommand{\vinr}[1]{\vin{2}{#1}}
\newcommand{\vcase}[5]{{\mathrm{case}} \, #1 \,\mathrm{of}\,( \vinl{#2}. \, #3 |  \vinr{#4}. \, #5)}

\newcommand{\algin}[2]{\comptype{\mathrm{in}}_{#1}(#2)}

\newcommand{\alginl}[1]{\algin{1}{#1}}
\newcommand{\alginr}[1]{\algin{2}{#1}}
\newcommand{\algcase}[5]{\comptype{\mathrm{case}} \, #1 \,\mathrm{of}\,( \alginl{#2}. \, #3 |  \alginr{#4}. \, #5)}

\newcommand{\eecproj}[2]{\pi_{#1}(#2)}
\newcommand{\eecprojb}[2]{(\pi_{#1}\,#2)}

\newcommand{\algimage}[1]{\comptype{\mathrm{?}}(#1)}


\newcommand{\pRightarrow}
{\mbox{\rightharpoonup\rightharpoonup}}
\newcommand{\pexp}{\pRightarrow}

\newcommand{\sub}[3]{#1[^{#2}\!/\!_{#3}]}




\begin{document}

\title[Linear usage of state]{Linear usage of state\rsuper*}

\author[R.~E.~M{\o}gelberg]{Rasmus Ejlers M{\o}gelberg\rsuper a}
\address{{\lsuper a}IT University of Copenhagen, Denmark}
\thanks{{\lsuper a}Research supported by the Danish Agency for Science, Technology and Innovation.}
\email{mogel@itu.dk}

\author[S.~Staton]{Sam Staton\rsuper b}
\address{{\lsuper b}Radboud University Nijmegen, Netherlands}
\thanks{{\lsuper b}Research supported by EPSRC Fellowship EP/E042414/1,
ANR Projet CHOCO, the Isaac Newton Trust, and ERC Projects ECSYM and QCLS}
\email{s.staton@cs.ru.nl}

\titlecomment{{\lsuper*}This article expands on a paper presented at 
the Fourth International Conference on Algebra and Coalgebra in Computer Science (CALCO 2011).}



\begin{abstract}
  We investigate the phenomenon that \emph{every monad is a linear state
  monad}. We do this by studying a fully-complete state-passing
  translation from an impure call-by-value language to a new linear
  type theory: the enriched call-by-value calculus.  The results are not specific
  to store, but can be applied to any computational effect expressible
  using algebraic operations, even
  to effects that are not usually thought of as stateful.  There is a
  bijective correspondence between 
  generic effects in the source language
  and state access operations in the enriched call-by-value calculus.
\vspace{2mm}

  From the perspective of categorical models, the enriched call-by-value calculus 
  suggests a refinement of the traditional Kleisli models of effectful
  call-by-value 
  languages. The new models can be understood as enriched adjunctions.
\end{abstract}

\maketitle


\section{Introduction}

\subsection{Informal motivation}
The state-passing translation 
transforms a stateful program into a pure function. 
As an illustration, consider the following ML program
which uses a single fixed memory cell \verb|l : int ref|.
\begin{verbatim}
       - fun f x = let val y = !l in l := x ; y end ;
       val f = fn : int -> int
\end{verbatim}
The state-passing translation transforms that program into 
the following pure function which takes the state as an argument
and returns the updated state as a result.
\begin{verbatim}
       - fun f (x,s) = let val y = s val s' = x in (y,s') end ;      
       val f = fn : int * int -> int * int
\end{verbatim}
The state-passing translation is straightforward
if the program only uses a fixed, finite area of memory of type :
an impure program of type  becomes a pure program
of type .


To what extent does the state-passing translation apply to programs with
other effects?
In this article we develop the idea
that, from a semantic perspective, 
all effects can be understood as state effects.
Central to our treatment of state is the idea of 
linear usage: in general, computations cannot copy the state and 
save it for later, nor
can they discard the state and insert a new one instead.
In 1972, Strachey wrote \cite{Strachey72}:
\begin{quote}
\emph{The state transformation produced by obeying a command is essentially irreversible and it is, by the nature of the computers we use, impossible to have
more than one version of  \emph{[the state]} at any one time.}
\end{quote}
Historically, the importance of the linearity of state
arose in the study of 
programs with private store. 
In this setting, the naive state-passing translation does not preserve 
contextual equivalence. 
For instance, the function `snapback' takes a
stateful computation  and returns the computation that
executes  but then snaps back to the original state:
\hide{}

The snapback program does not arise as the state-passing translation
of an impure program. 
No impure program could tamper with the private store in the way 
that the snapback program does.
In other words, the state-passing translation
is not fully complete.
One can use this fact to show that 
contextual equivalence is not preserved by the 
state-passing translation. 
Sieber~\cite{DBLP:conf/mfcs/Sieber94} 
insisted that every function be wrapped in snapback to obtain 
full abstraction for his simple denotational model.

O'Hearn and Reynolds~\cite{OHearn:R:00}
resolved these difficulties with private store
by moving to a linear typing system.
Linear usage of state can be expressed syntactically 
by considering a stateful computation of
type  as a linear map of type .  The type of states~
must be used linearly, but the argument type  and the return type 
can be used arbitrarily. 
The snapback program violates these linear typing constraints.

This notation is reminiscent of Girard's linear
logic~\cite{DBLP:journals/tcs/Girard87}.  Our starting point is
actually a more refined calculus, the enriched effect calculus, which
was developed by Egger, M\o gelberg and
Simpson~\cite{EEC:journal,Mogelberg:CSL:09,Mogelberg:fossacs:10,EEC:LCPS:journal} as a
way of investigating linear usage of resources such as state.

\subsubsection*{All effects are state effects}
In this paper we develop this linear typing discipline to show that
\emph{all} effects can be understood as state effects and that there
is \emph{always} a fully-complete linear-use state-passing
translation.  Our analysis applies even to effects that do not involve
the memory of a computer, like printing or coin-tossing.  (For this
reason we use the word `store' to refer to memory related effects and
`state' for the general notion.)  We now provide two informal
explanations of this general phenomenon.

A first informal explanation is that an inhabitant of the `state' type 
 
is an entire history of the universe. The history of the universe 
certainly cannot be discarded or duplicated. 
To be slightly more precise, if the effect in question is 
printing, then a `state' is a string of everything that has been printed
so far. 

A second informal explanation involves Jeffrey's 
graphical notation~\cite{jeffrey-premonoidal-graphics}.
Jeffrey noticed that a naive graphical notation for 
composition of impure functions does not work,
for it describes how functions depend on their arguments 
but it does not describe the order of side effects:
\\
\begin{center}
\includegraphics{jeffrey1.pdf}
\end{center}
To make the 
order of evaluation visible in the graphical notation, 
Jeffrey adds a special kind of edge which must be treated linearly.
This is what we call state.
\\
\begin{center}
\includegraphics{jeffrey2.pdf}
\end{center}

Our contribution in this paper is foundational,
but let us speculate briefly on possible applications.
State plays an important role in many aspects of semantics,
including operational semantics and Hoare
logic.  
The type  can be thought of as a type of 
configurations (program/state pairs) 
for a general abstract machine.
This might pave the way for a general framework for operational semantics, 
building 
on the ideas of Plotkin and Power~\cite{Plotkin:Power:08}.

We also note that variations on linear-use state-passing style
are already used to accommodate a broad class of effects 
within pure languages such as Clean~\cite{DBLP:journals/jfp/AchtenP95} and Mercury~\cite{DBLP:journals/jlp/SomogyiHC96}.

\subsection{The state-passing translation}
The source language of our translation is an impure functional
language with
product and function types:

We also consider sum types and unspecified base types.
We adopt the 
call-by-value calling convention because it is 
most natural one for effectful programs.
For simplicity we choose a fine-grain language
in which the order of evaluation is totally explicit.
The full syntax, equational theory
and framework for denotational semantics is in Section~\ref{sec:fgcbv}.
Sum types are treated in Section~\ref{sec:sums}.

The types of the target language are essentially the minimal
fragment of the enriched effect calculus (EEC, \cite{Mogelberg:CSL:09,EEC:journal}) 
that is 
needed for the linear-use state-passing translation.
To enforce linear usage, EEC borrows some techniques and notation
from linear logic (, , and )
but in a careful way, enforced by the following grammar:

The full syntax, equational theory
and framework for denotational semantics is in 
Section~\ref{sec:ecbv}.

In Section~\ref{sec:translation}
we provide a linear-use state passing translation
from the source language to the target language
The translation on types 
takes a type  
of the source language to a value type~ of the target language, by induction on the structure of types:

Theorem~\ref{thm:full:faithful} says that 
the linear-use state-passing translation is \emph{fully complete}:
it describes a bijective correspondence between
programs in the source language of type  
and programs in the target language of type .
This means that contextual equivalence is preserved by 
linear-use state-passing translation.

\subsubsection*{Enriched category theory}
The constructions involved in the target language
have an elegant categorical formulation:
they can be modelled in any enriched 
category with copowers. For this reason we call 
the target language \emph{the enriched call-by-value calculus}.

Recall that in categorical semantics
a type  is interpreted as an object  of a category,
a context  
is interpreted as an object  of a category,
and a term-in-context  is interpreted
as a morphism .
In the enriched call-by-value calculus,
there are two classes of type: computation types and value types.
A categorical analysis must thus involve two categories:
a category  whose objects interpret value types,
and a category  whose objects interpret computation types.
The structure of the types dictates the  
structure that the categories  and  must have:
\begin{itemize}
\item For the product types (, ),  must have
finite products in the categorical sense.
\item For the tensor type (),
 must act on . This means that there is a functor
 such that
 and 
.
\item For the linear function type ,
the action  must have a right adjoint in
its first argument.
\end{itemize}
The linear function type  ensures that the 
space of 
morphisms  forms an object of .
So  is enriched in , and the action structure
provides copowers.
There are many examples of enriched models, including 
categories of algebras and Kleisli categories
(understood as `closed Freyd categories'~\cite{Levy:03}). 
Full details are in Section~\ref{sec:ecbv}. 

In Section~\ref{sec:relating:models} we explain that
the connection with Kleisli categories gives us a categorical 
explanation of the linear-use state-passing translation.
We use a semantic 
approach to prove the full completeness 
of the translation.
We show that the
traditional models of effectful call-by-value languages, using monads
and Kleisli constructions, form a coreflective subcategory 
of the enriched models, and that the state-passing translation is the
unit of the coreflection.  
\hide{Our main semantic result provides a
bijective correspondence between comodel structures on a state object
and model structures on the induced linear state monad. This extends
Plotkin and Power's correspondence between algebraic operations and
generic effects~\cite{Plotkin:Power:03} with a third component: state access operations.}

\subsection{Relationship with monads}
\label{sec:intro:monads}


In an enriched situation, because  is right adjoint to 
,
any computation type  induces a monad on value types:

We call this a \emph{linear-use state monad}.
In Section~\ref{sec:monads} we show that 
every monad arises as a linear-use state monad. 
In brief, the argument is as follows.
The right notion of monad for programming languages is
`strong monad  on a category  with finite products and 
Kleisli exponentials';
for every such monad ,
the Kleisli category  is -enriched and has copowers
and is thus a model of the enriched call-by-value language.
The object  in  
induces a linear-use state monad
on   \eqref{eqn:statemonad} 
which is isomorphic to
the original monad  on .

For the simplest case, consider the following monad on the category
of sets for storing a single bit. 
If we let  and 
let  (there are two states), 
then the linear-use state monad is the usual state monad
.

In general, the linear-use state monad \eqref{eqn:statemonad} arises
from an adjunction that is parameterized in .
Atkey~\cite{a-parammonad} has investigated monads that arise from
parameterized adjunctions: in fact Atkey's parameterized monads are
essentially the same as our enriched models.  We return to this in
Section~\ref{sec:parammonad}.

\subsection{Algebraic theories and state access operations}
In order to explain the general connection between
effects and state, we turn to the analysis of effects begun by Plotkin and Power~\cite{Plotkin:Power:03}.
Categorically, a finitary monad on the category of sets
is essentially the same thing as an algebraic  theory.
Plotkin and Power proposed to use this
connection 
to investigate computational effects from the perspective of universal algebra.

The analysis of Plotkin and Power centres around the 
correspondence between \emph{algebraic operations} and \emph{generic effects}.
More precisely, for a monad  the following data are equivalent:
\begin{enumerate}
\item An \emph{algebraic operation}:
roughly, a functorial assignment of an -ary function
 to the carrier of each -algebra ;
\item A \emph{generic effect}: a function . 
\end{enumerate}
For instance, 
consider the store monad for a single bit of memory 
(using the isomorphic presentation 
).
Each -algebra 
 supports 
an algebraic operation 

in a functorial way: 
let . 
If we understand elements of -algebras
as computations, then  is the computation that  reads
the bit in memory 
and then branches to either~ or~ depending on what was read.

The corresponding generic effect  
is given by .
It can be thought of as the command that 
reads the bit and returns the contents of memory.

We have already explained (\S\ref{sec:intro:monads})
that all monads can be understood as linear-use state monads,
.
The data for algebraic operations and generic effects
can equivalently be given in terms of the following structure on 
the state object :
\begin{enumerate}
\item[(3)]
A \emph{state access operation}: 
a morphism 
in the computation category .
\end{enumerate}
For instance, let  and .
This gives a state monad for a single bit of memory,
isomorphic to .
The state access operation corresponding to 
reading the bit is simply the function 
 
given by , 
which reads 
the store and returns the result along with the store.
\hide{
For another example,
consider the monad  for printing bits.
We let . We let  be the category
of whose objects are sets  equipped with 
a function ;
morphisms in  are functions that preserve the structure.
The idea is that  is a set of computations
and  is a computation that first prints~ 
and then continues as .
The set of bit-strings  is an object of ,
with . 
The resulting linear-use state monad is the monad for printing bits.

We can investigate this theory in terms of algebraic operations,
generic effects and state access operations.
\begin{itemize}
\item A -algebra is the same thing as an object of ,
and so the algebraic operations are the unary
functions , .
\item The generic effects are 
functions 
,

which describe commands that print 0 and 1 respectively.
\item The state access operations are
homomorphisms ,
which take a bit string -- the history of what has been 
printed so far -- and append 0 or 1.
\end{itemize}
}

In Section~\ref{sec:modelsoftheories}
we provide more examples and investigate a general framework 
for algebraic presentations of theories of effects
using algebraic operations, generic effects and state access operations.
\hide{
Computational effects such as store effects, input/output and 
control effects are usually associated with the imperative style of programming, and functional programming languages exhibiting such behaviour are thought of as ``impure''. However, computational effects can be encapsulated within a purely functional language by the use of monads~\cite{Moggi:91}. The central idea behind this is to distinguish between a type of values such as , and a type of computations  that may return a value of type  but can also do other things along the way. Imperative behaviour can then be encoded using \emph{generic effects} in the sense of Plotkin and Power~\cite{Plotkin:Power:03}. For example, one can add global store by adding a pair of terms,
 and 
, for each cell  in the store, or one can add nondeterminism by adding a constant  computing a random boolean.
Computational effects that can be described using generic effects are called \emph{algebraic} and these account for a wide range of effects with the notable exception of control effects such as continuations.

In this paper we show how the theory of algebraic effects can be
formulated by taking the notion of state as primitive, rather than the
notion of monad.  On the syntactic side we introduce the
\emph{enriched call-by-value calculus}
(ECBV). 
We show that a special state type in ECBV gives rise to a language 
that is equivalent to a fine-grain monadic call-by-value calculus ({\FGCBV})~\cite{Levy:03}. On the semantic side we introduce a notion of enriched call-by-value model which generalises monad models. 



The type constructors  and 
form the basis of ECBV,
which can be considered as a kind of non-commutative linear logic that
is expressive enough to describe the linear usage of state. The equivalence
of ECBV with the fine-grain call-by-value calculus can be understood 
as stating that the linear usage of state in ECBV exactly captures computability. [[Sam: do you agree?? or is this too strong]]

Earlier metalanguages for effects, such as the monadic metalanguage
\cite{Moggi:91}, call-by-push-value \cite{Levy:book}, and the enriched
effect calculus~\cite{Mogelberg:CSL:09} have an explicit
monadic type constructor.  There is no monadic type constructor in
ECBV: there is a state type  instead. Still, in this
fragment one can express all algebraic notions of effects, even the
ones that we are not used to thinking of as ``state-like'', using what we
call \emph{state access operations}.  For example, the generic effects
, , and  correspond
to the following state access operations:

The equivalence of {\FGCBV} and {\ECBV} is proved for extensions of the two calculi along any algebraic effect theory. The generalisation is formulated using a notion of effect theory~\cite{Plotkin:Pretnar:08} which captures notions of algebraic effects.

The categorical models of {\ECBV} provide a new general notion of
model for call-by-value languages. In brief, an enriched model
consists of two categories~ and  such that  has
products and distributive coproducts, and  is enriched in~
with copowers and coproducts. The objects of  interpret ordinary
``value'' types, and the objects of  interpret ``computation''
types (such as the state type ) which must be used linearly.
This class of models encompasses all Kleisli categories 
(which have been axiomatized as closed Freyd categories) and
many Eilenberg-Moore categories (which provide a natural notion of
model for call-by-push-value and the enriched effect calculus).
}

\subsection{The enriched effect calculus}
The work presented here grew out of work on the enriched effect calculus by 
Egger, M\o gelberg and Simpson~(EEC, \cite{EEC:journal,Mogelberg:CSL:09,Mogelberg:fossacs:10,EEC:LCPS:journal}). 
The enriched call-by-value calculus that we introduce in this paper is
a fragment of EEC 
and our categorical semantics is based on their work. 
Every model of EEC contains a monad, and one of the observations of~\cite{Mogelberg:fossacs:10} (see also~\cite[Example~4.2]{EEC:journal})
was that this monad can always be represented as a linear state monad.
A special case of the embedding theorem~\cite[Theorem~4]{Mogelberg:CSL:09} 
shows that given a strong monad  on a category  with finite products and 
Kleisli exponentials we can embed  in a model of EEC preserving the monad 
and all other structure. This 
gives the motto: \emph{every monad embeds in a linear state monad}.

Since the enriched call-by-value calculus is a 
fragment of EEC (as opposed to full EEC), 
we allow ourselves a broader class of
models. In contrast to the earlier work on EEC, 
we do not include products among the computation types,
since they are not needed in the state-passing translation,
and so in our models the category  does not need to 
have products. This allows us to build models from Kleisli categories,
which typically do not have products, and this makes the relationship 
with monad models and closed Freyd categories much more straightforward.
In particular, in our setting every monad \emph{is} a linear state monad.

Nonetheless, in Section~\ref{sec:ecbvtoeec} we show that  is a
conservative extension of the enriched call-by-value calculus. This
shows that there is a fully-complete linear-use state translation into
.  This result is further evidence that  is a promising
calculus for reasoning about linear usage of effects. The related
papers~\cite{Mogelberg:fossacs:10,EEC:LCPS:journal} show how the linear-use
continuation passing translation arises from a natural dual model
construction on models of , and use this to prove a full completeness theorem 
similar to that proven here for the linear-use state-passing translation.
In fact, from the point of view of
 the two translations are surprisingly similar: the linear-use
state-passing translation is essentially dual to the linear-use
continuation-passing translation. This observation goes back to the work on
 and indeed duality plays a key role in~\cite{Mogelberg:fossacs:10} (although the relationship with state wasn't made explicit there). We draw it out explicitly in
Section~\ref{sec:cps}.


\subsubsection*{Acknowledgements.}
We thank Alex Simpson for help and encouragement. Also thanks to Lars Birkedal, Jeff Egger, Masahito Hasegawa, Shin-ya Katsumata and Paul Levy for helpful discussions. Diagrams are typeset using the \texttt{xymatrix} package
and Paul Taylor's \texttt{diagrams} package.



\newcommand{\ccat}{\mathfrak{K}}
\newcommand{\dcat}{\mathbb{D}}

\newcommand{\cbvinp}[2]{\codefont{in}_{#1}^p(#2)}
\newcommand{\cbvimagep}[1]{\codefont{image}^p(#1)}
\newcommand{\cbvcasep}[5]{\codefont{case}^p~#1~\codefont{of}~(\cbvinl{#2}.#3|\cbvinr{#4}.#5)}

\newcommand{\geff}{e} 
\newcommand{\geffj}[3]{\pj{#1}{#2}{#3}}
\newcommand{\geffin}[2]{\codefont{in}_{#1}(#2)} \newcommand{\geffinname}[1]{\codefont{in}_{#1}} \newcommand{\geffabs}[2]{#1 \text{ to } \{#2 \}}

\newcommand{\cbvin}[2]{{\codefont{in}}_{#1}(#2)}
\newcommand{\cbvinl}[1]{\cbvin{1}{#1}}
\newcommand{\cbvinr}[1]{\cbvin{2}{#1}}
\newcommand{\cbvcase}[5]{\codefont{case}~#1~\codefont{of}~(\cbvinl{#2}.#3|\cbvinr{#4}.#5)}
\newcommand{\cbvcasen}[6]{\codefont{case}~#1~\codefont{of}~(\codefont{in_1}({#2}).#3|\dots|\codefont{in_{#4}}({#5}).#6)}
\newcommand{\cbvcasenp}[6]{\codefont{case}^p~#1~\codefont{of}~(\codefont{in_1}({#2}).#3|\dots|\codefont{in_{#4}}({#5}).#6)}

\newcommand{\arit}[2]{#1;  #2}
\newcommand{\arityj}[3]{#1: \arit{#2}{#3}}

\newcommand{\Homset}[3]{\mathrm{Hom}_{#1}({#2},{#3})}

\section{Enriched call-by-value: a calculus for enriched categories with copowers}
\label{sec:ecbv}
The target language for the linear-use state translation
is a new calculus called the 
\emph{enriched call-by-value calculus} (ECBV), that we now introduce.
As we will explain, it is an internal language for 
enriched categories with copowers.

The enriched call-by-value calculus 
is a fragment of the enriched effect calculus (EEC),
which was introduced by Egger et al.~\cite{Mogelberg:CSL:09,EEC:journal}
as a calculus for reasoning about linear usage in computational effects.
The types of ECBV
can be understood as a fragment of linear
logic that is expressive enough to describe the 
linear state monad, .
We will not dwell on the connection with linear logic here.

\subsection{Type theory and equational theory}
\label{sec:ecbvsyntax}
The enriched call-by-value calculus has two collections of types:
value types and computation types.  We use 
to range over a set of \emph{value type constants}, and
 to range over a disjoint set of
\emph{computation type constants}.  We then use 
upright letters  to
range over value types, and underlined letters 
 to range over
computation types, which are specified by the grammar below:

\noindent
Note that the construction  is indivisible:
the strings  and  
are not well-formed types.
The stratification of types means that one cannot chain function 
types: the string  is not well-formed.

Readers familiar with Levy's
Call-by-Push-Value~\cite{Levy:book} or ~\cite{Mogelberg:CSL:09}
should note that there are no type constructors  and  for
shifting between value and computation types and that 
computation types are not included in the value types.
The only way to shift between value types and computation types
is by using tensor and function types. As we will see, this is the essence
of the state-passing translation.
\begin{figure*}[tph]
\framebox{
\begin{minipage}{.96\linewidth}
\emph{Types.}

\begin{center}
\line(1,0){350}\gnl
\end{center}
\emph{Term formation.}
\begin{center}
\end{center}
\begin{center}\mbox{}\\
\line(1,0){350}\gnl
\end{center}
\emph{Equality.} (We elide -equivalence, 
reflexivity, symmetry, transitivity and 
congruence laws.)
\begin{center}

\end{center}\end{minipage}}
\caption{The enriched call-by-value calculus}
\label{figure:effects:typing}
\end{figure*}

The enriched call-by-value calculus has two basic typing judgements, written

In the both judgements,  is an assignment of value types to
variables.  In the first judgement,~ is a value type, and in the second judgement, both  and
 need to be computation types.  The second judgement should be
thought of as a judgement of linearity in the variable . These judgements are defined inductively by the typing rules in
Figure~\ref{figure:effects:typing}, which are a restriction of the
rules of EEC~\cite{EEC:journal} 
to this type structure. In the figure,~ is an
assignment of a computation type to a single variable, as
in~(\ref{eq:form:typing:rules}).  The ideas behind the term language
for the function space  and the tensor
 go back to the early work on linear lambda
calculus.  In particular, the introduction rule for
 uses pairing, and the elimination rule uses a
pattern matching syntax.



\subsection{Enriched call-by-value models}
\label{sec:adjmodels}
The categorical notion of model for {\ECBV}
involves basic concepts from enriched category theory~\cite{Kelly:Book}.
In summary, a model of the language comprises two categories,
 and , interpreting the value and computation types 
respectively; the function type  provides 
an enrichment of  in , and the universal property of the tensor
type  is the copower, sometimes called tensor.

We now make this precise. Let us recall some rudiments.
Following~\cite{JanelidzeKelly:actions,GordonPower:EnrichmentThroughVariation}, we begin with actions of
categories.  Let  be a category with finite products
(by which we mean that it has a chosen terminal object and chosen
binary products).
Recall that an \emph{action} of  on a category  is a functor
 
together with 
two natural isomorphisms, unit  and associativity
,
that cohere with the isomorphisms arising from 
the product structure of~ in the following sense:

(We underline objects of  to distinguish them from objects of 
.)

An \emph{enrichment of a category  in  with copowers} is
determined by an action of  on  such that each functor
 has a right adjoint,
.  Then  is called
a copower, and  is called enrichment.  
We write  for the usual hom-set of 
to distinguish it from the enrichment.


\begin{defi}
\label{def:enrichedmodel}
An \emph{enriched call-by-value model} (or simply \emph{enriched model}) is given by a category 
 with finite products
and a category  enriched in  with copowers.
\end{defi}
In Section~\ref{sec:examplesenriched}
we will illustrate the definition with some examples of enriched models.
First, let us clarify the 
semantics for {\ECBV} 
in an enriched model.
The interpretation is similar to the semantics of 
 proposed by Egger et al.~\cite{Mogelberg:CSL:09}. 
\begin{itemize}
\item 
A value type  is interpreted as an object  of ,
and a computation type  is interpreted 
as an object  of , as follows.
The interpretation is defined by induction on the structure of types. 
First, for each value type constant~, 
an object  of  is given,
and for each computation type constant~ 
an object  of  is given.
The product types are interpreted as products in 
.
The remaining type constructions are interpreted using the 
enriched structure:
we let ,
and . 
\item A value context 
is interpreted as a product .
in~.
A computation context  is interpreted as the object
 in~.
\item 
A judgement  is interpreted
as a morphism  in ,
and a judgement  is interpreted
as a morphism  in~.
This definition is made by induction on the structure of 
typing derivations, making use of the universal properties of the 
interpretations of the types.
For illustration, we consider the following two rules:

In dealing with the linear lambda abstraction rule,
the induction principle gives us an interpretation
 in 
which we use to form 
 
in , using the natural bijection
that defines the relationship between the copower and the enrichment:

For the pattern matching rule,
we assume morphisms 

in  and use them to 
define 
as the following composite:

\end{itemize}

\begin{prop}
The interpretation of the enriched call-by-value calculus 
in an enriched model 
 is sound:
\begin{enumerate}
\item If  then 

in .
\item If  then 

in .
\end{enumerate}
\end{prop}
\begin{proofnotes}
This is proved by induction on the structure of the 
derivation of~.
The following substitution lemma is helpful:
\hide{\item If  and  
then  is the following composite  in :

}
\begin{quote}
\emph{If  and  
then  is the following composite morphism in :}

\end{quote}\vspace{-1.367\baselineskip}
\end{proofnotes}
\subsection{Examples of enriched models}
\label{sec:examplesenriched}
We now list some examples of enriched models (Definition~\ref{def:enrichedmodel}).
\begin{enumerate}
\item If  then a -enriched category 
is just a locally small category.
The copower  is the -fold 
iterated coproduct of , if it exists.
The following three examples are instances of this example.
\item \label{ex:monoids}Let  and let  be 
the category of monoids and homomorphisms.
The copower , where  is a set and  is a monoid,
can be described as a quotient of the free monoid on the product of sets,
.
Here  is the 
set of strings built of pairs in ,
which is a monoid under concatenation
with the empty string  as unit.
The equivalence relation~ is generated by
 and .
There is a similar description of the copower for any algebraic theory.
\item
We can modify Example~(\ref{ex:monoids}) 
to make  the category of 
\emph{free monoids} and monoid homomorphisms.
That is, the objects are monoids of the form~.
In this situation, the copower satisfies 
.
In this example  is the Kleisli category 
for the free monoid monad. We will revisit Kleisli categories in 
Section~\ref{sec:monads}.
\item Let ,
with  considered with the ordinary enrichment.
The copower  is the cartesian product of sets.
This situation generalizes to the situation where  is an arbitrary
cartesian closed category.
\item Let  be the category of -cpo's and continuous functions, 
and let  be the category of pointed -cpo's and strict functions.
The enrichment  is the cpo of strict functions under
the pointwise order, and the copower  is the smash product
.
\item In the next section we will investigate a model
built from the syntax of the enriched 
call-by-value calculus.
\end{enumerate}


\subsection{The syntactic enriched model}
\label{sec:syn:enr:model}

The types and terms of the enriched call-by-value 
calculus form an enriched model
which we call the syntactic enriched model. 

Let  be the category whose objects are value types 
and where a morphism  is a term in context
 modulo the equational theory (Figure~\ref{figure:effects:typing}) and modulo renaming the free variable~.
The identity morphism
is the term ,
and composition of morphisms

is given by substitution: .
Since morphisms are actually equivalence classes, the 
well-definedness of substitution depends on the following 
substitution lemma
\begin{quote}
If  and
 
\\then 
\end{quote}
which is proved by induction on the derivation of 
. 

The laws of associativity and identity for composition 
are immediate. For instance, associativity 
amounts to the following syntactic identity:
\begin{quote}
If , \quad
 
and
 
\\then \text.
\end{quote}

The category  has products, given by the product types.
The equations at product types
are exactly what is needed to guarantee the universal
properties.

Let  be the category whose objects are computation types
and where a morphism  is a term in context
 modulo the equational theory
and modulo renaming the free variable~.
Identities and composition are defined in a similar way to .
The identity morphisms  are  
and composition is by substitution.

The action of  on  is given on objects by the tensor type: 
let .
Given morphisms 

we define a morphism 
in  by

Functoriality follows from the equational theory of ECBV.
The unit and associativity isomorphisms are straightforward to define.
For example, associativity () is given by exhibiting
 mutual inverses at all types:

It follows from the 
equational theory of ECBV that these are isomorphisms and are natural and 
coherent.

Finally, we discuss the enrichment of  in .
Given types ,  and  we describe a natural bijection

From left to right the bijection takes a 
computation term 
to a value term 
.
From right to left the bijection takes a 
value term

to a computation term
.

\subsection{Universal property of the syntactic enriched model}
\label{sec:enr:model:biinitial}

The syntactic model described in Section~\ref{sec:syn:enr:model} enjoys a universal property:
it is an initial object 
in a category of enriched models with structure preserving
functors as morphisms. Given any other enriched model, the unique morphism
from the syntactic model is given by interpretation of syntax in the model.


This semantic characterization 
of interpretation is standard in categorical semantics, and it
is useful for deriving syntactic results from semantics, as we shall see
in Section~\ref{sec:relating:models}. 
However, we shall also see (Section~\ref{sec:adj})
that we need to talk about morphisms of models preserving structure only 
up to isomorphism, and the syntactic model is not initial with respect 
to this collection of morphisms. Rather, interpretation defines a morphism
which is unique only up to unique isomorphism. In order to formulate
this kind of initiality, we need to be able to assess when 
two morphisms between enriched models are isomorphic.
Thus the enriched models
form a 
groupoid-enriched category,
i.e., a 2-category in which each 2-cell is invertible.
The idea of using groupoid-enriched 
categories of models has been around for a long time 
(e.g. \cite[\S 8]{dk-alggraph})
and has been used in previous work on the enriched effect 
calculus~\cite{Mogelberg:CSL:09,Mogelberg:fossacs:10}. 

A precise definition of the 2-category of enriched models  can be found in 
Appendix~\ref{app:cats:of:models}. Here we just state the initiality property of the syntactic model.
First recall the following definition from 2-category theory 
(see e.g. \cite[\S6]{k-twocatlimits}).

\begin{defi} \label{def:biinitial}
Let  be a 2-category. An object  of  is \emph{bi-initial} if
for any object  the hom-category  is equivalent to 
the terminal category (i.e., the category with one object and one morphism).
\end{defi}
An equivalent way of stating bi-initiality is to say that 
for any other object  
there exists a 1-cell 
which is unique up to unique 2-isomorphism.


The syntactic model of Section~\ref{sec:syn:enr:model} is bi-initial in the category , but in this paper
we are much more interested in a category of enriched models   
with a specified state object  in  (because of the relation to the state-passing
translation), and so we formulate bi-initiality with respect to a category 
 of these. Like all other structure, 1-cells of  are 
only required to preserve the state objects up to isomorphism. (See Appendix~\ref{app:CATECBV} 
for a full definition). We write  for the enriched model 
obtained as in Section~\ref{sec:syn:enr:model} from the syntax of the enriched call-by-value calculus
extended with a special computation type constant .

\begin{thm} \label{thm:ecbv:biinitial}
The model  is bi-initial in . The unique 
morphisms with domain  are given by interpretation of syntax into models.
\end{thm}





\section{Fine-grain call-by-value, a calculus for Kleisli models}
\label{sec:fgcbv}

The source language for our state-passing translation is a call-by-value language equipped with an equational theory to be thought of as generated by some operational semantics, as in~\cite{Plotkin:65}. 
We use a `fine grain' call-by-value language, 
following Levy et al.~\cite{Levy:03,Levy:book}.
We use  to range over type constants. The types are given by the grammar

The function space  is a call-by-value
one, which takes a value and produces a computation. 

The fine-grain call-by-value calculus ({\FGCBV}) has two typing
judgements, one for values and one for producers. These are written
 and .  The latter should
be thought of as typing computations which produce values in the type
judged but may also perform side-effects along the way. In both
judgements the variables of the contexts are to be considered as
placeholders for values. 
Typing rules along with equality rules are given in
Figure~\ref{fig:lambdac:typing}.
\begin{figure*}[tb]
\framebox{
\begin{minipage}{.96\linewidth}
\emph{Types.}

\begin{center}
\line(1,0){350}\gnl
\end{center}
\emph{Term formation.}
\begin{center}

\end{center}
\begin{center}\mbox{}\gnl
\line(1,0){350}\gnl
\end{center}
\emph{Equality.} (We elide -equivalence,
reflexivity, symmetry, transitivity and 
congruence laws.)
\begin{center}
\end{center}
\end{minipage}
}
\caption{Fine-grain call-by-value.
}
\label{fig:lambdac:typing}
\end{figure*}

The call-by-value language is called `fine grain' because the order of 
evaluation is explicit. Notice that the string
 is not well-formed syntax:
one must specify the order of evaluation,
for instance, like this:

Translations from a `coarser grain', more natural programming language
are given by Levy et al.~(\cite[\S 3]{Levy:03}, \cite[\S A.3.3]{Levy:book}).

\subsection{Interpretation in Kleisli models}
\label{sec:interpkleilsi}
The most natural way to interpret fine-grain call-by-value is 
two have two categories  and  to interpret
the judgements  and ,
but to insist that the two categories have exactly 
the same objects, since in this language there is only one 
class of types.
\begin{defi}
\label{def:monadmodel}
An \emph{enriched Kleisli model}
is an enriched call-by-value model  (Def.~\ref{def:enrichedmodel})
together with an 
identity-on-objects functor  that strictly
preserves copowers, which means that
 (naturally in  and )
and 
that the canonical isomorphisms induced by the product structure
are the coherent unit and associativity isomorphisms of the copowers:

\end{defi}
We will sometimes say `Kleisli model'
for `enriched Kleisli model'.
We use the name `Kleisli' because this definition
captures the situation where
 is the Kleisli category for a strong monad on .
The correspondence is explained in
Section~\ref{sec:monads}.

Kleisli models have earlier been called
`closed Freyd categories' by Levy et al.~\cite{Levy:03}.
Their original definition of closed Freyd category is based
on premonoidal categories;
the relationship with actions of categories 
and Kleisli models is observed by Levy~\cite[B.10]{Levy:book}.

A semantics for {\FGCBV} is given in a Kleisli model in a standard way.
\begin{itemize}
\item Each base type is given an interpretation 
 as an object of .
This interpretation is extended to all types:
 is the terminal object of ;
 is the product of 
 and ;
and 
 is defined using the enriched
structure of :
.
\item 
A context  
is interpreted in  as a product 
. 
\item 
A value type judgement 
  
is interpreted as a 
morphism  in 
and a producer type judgement  
is interpreted as a morphism 

in~.
This is defined by induction on the structure of derivations,
using the universal properties of Kleisli models.
For illustration we consider the following rule.

The induction hypothesis gives us two morphisms in 

and we use these to define a morphism in  that interprets
:

As another example .

\end{itemize}
This defines a sound and complete notion of model for 
{\FGCBV}.
\begin{prop}[\cite{Levy:03}, Prop.~5.1]
The interpretation of the 
fine-grain call-by-value calculus in a Kleisli model is sound:
\begin{enumerate}
\item If  then 

in .
\item If  then 

in .
\end{enumerate}
\end{prop}


\subsection{Relationship with monads}
\label{sec:monads}
We now explain the connection between enriched Kleisli models 
and Kleisli categories for a monad.
For more detail, see the paper by Levy et al.~\cite{Levy:03}.

From the syntactic point of view, 
the fine-grain call-by-value language 
can be thought of as a variant of Moggi's ~\cite{Moggi:89}:
the type construction  is a
monad.  

From the semantic point of view, 
recall that a -model~\cite{Moggi:89}
is a category with finite products and a strong monad 
with Kleisli exponentials. We now explain these conditions.

Let  be a category with finite products,
and let  be a monad on .
Let  be the Kleisli category for : the objects of  are 
the objects of  and a morphism  in  is a morphism
 in . 
There is an identity-on-objects functor
 
which takes a morphism  in 
to the morphism  in .

A strength for a monad  is usually expressed 
as a family of morphisms 
that respect the structure of the monad.
In fact, a monad is strong if and only if 
there is an action of  on  and the
identity-on-objects functor  
preserves it.
The strength is needed to 
take a morphism  in 
to  a morphism  
in .

The requirement of Kleisli exponentials is normally 
expressed as the requirement that for all  and ,
the hom-functor 
 is representable.
To endow~ with Kleisli exponentials is to 
give a right adjoint for the action,
i.e. an enrichment of  in .

Conversely, every enriched Kleisli model  
induces a strong monad on  with Kleisli exponentials.
The monad is defined using the closed structure:
.
The Kleisli category for this monad is isomorphic to .
On the other hand, if we begin with a monad, build the Kleisli category
and then take the monad , we recover a monad that is isomorphic
to the one that we started with. 
In this sense, enriched Kleisli models and -models are equivalent.
Note that they are not exactly the same,
for although the hom-set  is in bijection with
, the sets are typically not identical.

\subsection{The syntactic Kleisli model}
\label{sec:syn:Kl:model}

The types and terms of the fine-grain call-by-value calculus form 
a syntactic model.
We employ the same kinds of technique as 
for enriched call-by-value in Section~\ref{sec:syn:enr:model}.
\begin{itemize}
\item The objects of both  and  are the types of FGCBV.
\item A morphism  in  is a value judgement
 modulo the equational theory 
(Figure~\ref{fig:lambdac:typing}) and modulo renaming the free variable~.
Identities are variables and composition is by substitution. 
\item 
A morphism  in  
is a computation judgement  modulo the equational theory
 and renaming the free variable~.
The identity  is .
Composition is \emph{not} by substitution,
since one cannot substitute a producer term for a variable.
Rather, the composite of 

in  is 
.
\item The product structure in  is given by the product
types, projections and pairing.
\item The action of  on  is given on objects 
by the binary product types: let .
On morphisms, given  
in  
and 

in ,
we define 

\item The enrichment is given by
.
\item The identity-on-objects functor
 takes a morphism
 
in 
to the morphism
 
in .
\end{itemize}

\noindent We write  for the syntactic Kleisli model.

\subsection{Universal property of the syntactic Kleisli model}
\label{sec:syn:Kl:biinitial}

Appendix~\ref{app:Kleisli:cat} defines the 2-category  of Kleisli models. As was the case for , 
1-cells are only required to preserve structure up to isomorphism. 

\begin{thm} \label{thm:fgcbv:biinitial}
The syntactic Kleisli model  is bi-initial in . The unique 
morphisms with domain  are given by interpretation of syntax into models.
\end{thm}





\section{The linear-use state-passing translation}
\label{sec:translation}

This section defines the linear-use state-passing translation
from the fine-grain call-by-value calculus to 
the enriched call-by-value calculus, 
and states the main syntactic results of this paper:
fullness on types and full completeness. Together these assert that 
the linear-use state-passing translation is an equivalence of languages.

We now fix a computation type  of \ECBV.
For now, it can be an arbitrary computation type; later
we will make it a distinguished basic type to achieve a 
full completeness result.
We will describe a translation 
from {\FGCBV} to {\ECBV}. 
When  is thought of as a type of states,
then this translation reads as a state-passing translation.

\renewcommand{\CBVtoEEC}{\CBVtoEECbase\EECarbstate}
\newcommand{\CBVtoEECV}{\CBVtoEECbase \EECarbstate}
\newcommand{\CBVtoEECP}[1]{\CBVtoEECbase \EECarbstate{#1}_\svar}
We translate \FGCBV\ types  to \ECBV\ value types
:

We extend this translation to type contexts,
taking an FGCBV type context  to an
ECBV type context .

The translation on terms is syntax-directed.
We pick a variable , completely fresh.
The translation takes an FGCBV value type judgement
  
to an \ECBV\
judgement ,
and an FGCBV producer judgement  
to an \ECBV\ judgement . The translation is defined as follows.

In the case for -abstraction, the  is chosen to be completely fresh.

The translation respects types. For instance


\quad
{\aj{\CBVtoEEC\Gamma,x\co \CBVtoEEC \STA}{s\co \EECarbstate}
{\CBVtoEECP N}{\ltensortype {\CBVtoEEC\STB}\EECarbstate}}
\justifies
{\aj{\CBVtoEEC\Gamma}{z\co \ltensortype {\CBVtoEEC\STA}\EECarbstate}
{\letdot x s z{\CBVtoEECP N}}{\ltensortype {\CBVtoEEC\STB}\EECarbstate}}



\begin{thm}The linear-use state-passing translation is sound: \label{thm:soundness}
\begin{enumerate}
\item
If  then 
.
\item 
If  then 
.
\end{enumerate}
\end{thm}
This result can be proved by induction on the structure of equality
() derivations, but it can also be derived semantically as 
we shall see in Section~\ref{sec:sp:transl:semantics}.

\subsection{Full completeness}
We now state our main theorems: fullness on types and full completeness
on terms.
To state fullness on types we need to talk about isomorphism of types in {\ECBV}. 
This can be defined in the usual way: for
value types, an isomorphism  is given by two judgements,
 and , such that
 and . For computation types,  is
witnessed by closed terms of type , 
composing in both directions to identities. 
We note the following type isomorphisms, inherited from 
the enriched effect calculus~\cite[\S 3]{Mogelberg:CSL:09}:


\begin{thm}[Fullness on types]
\label{thm:full-on-types}
Let  be a value type of {\ECBV} formed using no other computation type constants than . Then there exists an {\FGCBV} type  such that .
\end{thm}

\begin{proof}
By induction on the structure of types. The interesting case  uses the fact that any computation type not using any  other than  is isomorphic to one of the form , which follows from the isomorphisms~(\ref{eq:tensor:one}). 
\end{proof}
\noindent
We now state our main syntactic result.
\renewcommand{\CBVtoEEC}{\CBVtoEECbase\EECstate}
\renewcommand{\CBVtoEECV}{\CBVtoEECbase \EECstate}
\renewcommand{\CBVtoEECP}[1]{\CBVtoEECbase \EECstate{#1}_\svar}
\begin{thm}[Full completeness] \label{thm:full:faithful}\mbox{}
\begin{enumerate}
\item \label{item:faithful:values} 
If  
and  
then .
\item
If   and 
 then 
.
\item For any  there is a term  such that . 
\item For any  there is a producer term  such that 
.
\end{enumerate}
\end{thm}
\noindent In Section~\ref{sec:sp:transl:semantics} we sketch a semantic proof of Theorems~\ref{thm:full-on-types} and~\ref{thm:full:faithful}.






\section{A semantic proof of full completeness}
\label{sec:relating:models}

In this section we present two constructions on models. The first 
(\S\ref{sec:enrtokleisli})
constructs a Kleisli model (Def.~\ref{def:monadmodel})
from an enriched model (Def.~\ref{def:enrichedmodel})
with a specified
state object.  The second (\S\ref{sec:kleisli-to-enriched-models})
constructs an enriched model with a state
object from a given Kleisli model. The state-passing translation
arises from the first of these constructions. These two constructions
form a bi-adjunction exhibiting the category of Kleisli models as a
coreflective subcategory of the category of enriched models with chosen
state objects (\S\ref{sec:adj}).  
In Section~\ref{sec:sp:transl:semantics} we shall see
how to use these facts to explain full completeness of the 
linear-use state-passing
translation
(Theorem~\ref{thm:full:faithful}).

\subsection{From enriched models with state to Kleisli models}\label{sec:enrtokleisli}

Given an {\enrmodel}  with a state object 
in , we can form an {\Klmodel} , where the category 
has the same objects as  and hom-sets

Composition in  is just composition as in . (This is an isomorphic presentation of the Kleisli category for the monad  on .) The functor  is the identity on objects and maps  to  .

\begin{lem} \label{lem:Kl:well-def}
For any {\enrmodel} with state  the data  defines an {\Klmodel}.
\end{lem}

\begin{proof}
The action  is defined on objects as . On morphisms it maps  to the composite

which is easily seen to be functorial. 

The right adjoint to  is . \end{proof}

The construction  described above extends to a 2-functor 
from the 2-category of enriched models to the 2-category of 
Kleisli models.
See Appendix~\ref{app:ECBVToFreyd} for details.


\subsection{From Kleisli models to enriched models with state}
\label{sec:kleisli-to-enriched-models}
Any Kleisli model is trivially an enriched model, so for the opposite
construction we just need to pick a state object in a Kleisli
model. We define , where  is the terminal object of  considered 
as an object of .
This definition
extends to a 2-functor ,
as shown in Appendix~\ref{app:adjunction}.

The motivation for this definition is that, as we now show, the 2-category  can be seen as a 
2-category of enriched adjunctions, and the 2-functor  can be seen as an inclusion of
Kleisli adjunctions into . 

Let  be an enriched model. By an \emph{enriched adjunction} we mean 
an adjunction  equipped with a natural 
coherent isomorphism
.
When  is cartesian closed, this is equivalent to
the usual definition, i.e. a natural isomorphism
 in  (see e.g.~\cite{kelly-enrichedadj}). 

Any choice of state object gives an enriched adjunction,
since
 
is left adjoint to  .
The following proposition (first noted for , \cite[Proof of Thm.~4]{Mogelberg:CSL:09}, \cite{EEC:journal}) shows that every enriched adjunction arises in this way:
\begin{prop}[\cite{EEC:journal}]
\label{prop:adjmodels}
Let  be an enriched model.
If  is an enriched adjunction
then it is naturally isomorphic to
the enriched adjunction induced by .
\end{prop}
So enriched adjunctions correspond essentially bijectively 
to state objects.
In particular the state object corresponding to a Kleisli model is . 
Monads induced by state objects can be described in {\ECBV} as .
By the correspondence between Kleisli models and strong monads we arrive at the slogan: 
\emph{Every strong monad is a linear-use state monad.} 
More directly, the slogan can be derived from the 
isomorphism , which holds for 
the Kleisli category  of any strong monad~. 


(\emph{Remark:} if  is a strong monad on 
then, for any object~ of , 
the linear-use state monad 
 on  is also known as the
application of the state monad transformer to~, as in~\cite{lhj-monad-transformers}.)



\subsection{A coreflection}
\label{sec:adj}

The constructions  and  form a bi-adjunction
between the 2-categories of Kleisli models and of enriched models
with state. One intuition for this is that it expresses the minimality
property of Kleisli resolutions of monads.

\begin{thm} \label{thm:adj} The 2-functor  is left biadjoint to , i.e., for any
  pair of objects  and  of  and  respectively, there is an
  equivalence of categories
  
natural in   and . 
Moreover, the unit of the adjunction  is an isomorphism.
\end{thm}
See Appendix~\ref{app:adjunction} for a proof of Theorem~\ref{thm:adj}. Since left bi-adjoints preserve 
bi-initial objects we get the following
connection between the syntactic enriched model
 and the syntactic Kleisli model .
\begin{cor} \label{cor:eq:syn:models}
 and  are equivalent as objects of . 
\end{cor}

Since 
 the unit of the adjunction 
can be described as the pair  where  is the composite

using the isomorphism .
The pair  preserves the enrichment only up to isomorphism, 
and  
this is our main motivation for using 2-categories of models
(see also the discussion in Section~\ref{sec:enr:model:biinitial}).


\subsection{A semantic explanation of the state-passing translation}
\label{sec:sp:transl:semantics}

The linear-use state-passing translation is essentially the
interpretation of fine-grain call-by-value into the model obtained
by applying the construction  of
Section~\ref{sec:relating:models} to the syntactic {\enrmodel} of
Section~\ref{sec:syn:enr:model}. In this model judgements
 and  are interpreted as
judgements of the form

respectively, where  is the product of all the types appearing in .

\begin{lem} \label{lem:sp:transl:sem}
Let  be the syntactic {\Klmodel} of Section~\ref{sec:syn:enr:model}. 
The interpretation of FGCBV into  models a type  as . Let  be a context of FGCBV and let  and  be judgements of FGCBV. Then  and  are interpreted as the equivalence classes of the terms

\end{lem}

Soundness of the state-passing translation
(Theorem~\ref{thm:soundness}) follows immediately 
from Lemma~\ref{lem:sp:transl:sem}.
Fullness on types and 
full completeness (Theorems~\ref{thm:full-on-types} and \ref{thm:full:faithful})
are also  consequences.

\begin{proofof}{Theorems~\ref{thm:full-on-types} and \ref{thm:full:faithful}}
By Theorem~\ref{thm:fgcbv:biinitial} and Lemma~\ref{lem:sp:transl:sem} the state-passing translation is the unique (up to isomorphism) 1-cell

in . It suffices to show that this is an equivalence in , because this implies that  and  are both equivalences of categories, in particular they are essentially full on objects (proving Theorem~\ref{thm:full-on-types}) and full and faithful (proving Theorem~\ref{thm:full:faithful}). 

By initiality  must be isomorphic to the composite

of the unit of the adjunction (which is an isomorphism by Theorem~\ref{thm:adj}) and  applied to the equivalence of Corollary~\ref{cor:eq:syn:models}. Since this composite is an equivalence, so is . 
\end{proofof}







\section{Sums}\label{sec:sums}
It is routine to add sum types to the languages considered in 
Section~\ref{sec:ecbv} and \ref{sec:fgcbv},
and the state-passing translation extends straightforwardly.
We now summarize the details.
\subsection{Sums in the enriched call-by-value calculus}
\label{sec:sums:enriched}
We add sums to the enriched call-by-value calculus,
for both value and computation types.
The required modifications to the calculus are given in 
Figure~\ref{figure:effects:sumtyping}. The resulting calculus
is still a fragment of the enriched effect calculus~\cite{EEC:journal}.
\begin{figure*}[tb]
\framebox{
\begin{minipage}{.96\linewidth}
\emph{Types.}

\begin{center}
\line(1,0){350}\gnl
\end{center}
\emph{Term formation.}
The following rules are in addition 
to the rules in Figure~\ref{figure:effects:typing}.
\begin{center}

\end{center}
\begin{center}\mbox{}\\
\line(1,0){350}\gnl
\end{center}
\emph{Equality.} 
The following rules are in addition 
to the rules in Figure~\ref{figure:effects:typing}.
\begin{center}

\mbox{}\\\end{center}
\end{minipage}
}
\caption{Additional rules for sum types in Enriched Call-by-Value
}
\label{figure:effects:sumtyping}
\end{figure*}
We now extend the notion of model to accommodate the sums.
\begin{terminology}
Recall that a \emph{distributive category} 
is a category with finite products and 
coproducts such that the canonical morphisms
 
and 
are isomorphisms.

If a distributive category  
has an action  on a category  with finite coproducts
,
then we say that the situation is \emph{distributive}
if the four canonical morphisms 
,
,
 and 

are isomorphisms.
If the action is enriched, i.e.~each functor  has a right adjoint,
then this definition of distributive coproducts 
amounts to the usual notion of 
enriched coproducts.
(Note that when the action is enriched then the third
and fourth canonical morphisms
are necessarily isomorphisms since left adjoints preserve 
colimits.)
\end{terminology}
\begin{defi}\label{def:distrenrichedmodel}
A \emph{distributive enriched model}
is given by a distributive category  
and a category  enriched in  with copowers and 
enriched coproducts.
\end{defi}
It is straightforward to extend the sound interpretation
of the enriched call-by-value calculus in enriched models
(\S\ref{sec:adjmodels})
to a sound interpretation of 
enriched call-by-value calculus with sums in distributive enriched models.

Of the examples in Section~\ref{sec:examplesenriched},
(1)--(5) are distributive.
The syntactic model of the version of the calculus with sums is 
a distributive enriched model, and it is bi-initial for the suitable 
generalization of morphism.
\subsection{Sums in the fine-grain call-by-value calculus.}
\label{sec:sums:fgcbv}
It is equally straightforward to add sums to the fine-grain call-by-value
language. This is summarized in Figure~\ref{fig:lambdac:sumtyping}.
\begin{figure*}[tb]
\framebox{
\begin{minipage}{.96\linewidth}
\emph{Types.}

\begin{center}
\line(1,0){350}\gnl
\end{center}
\emph{Term formation.}
The following rules are in addition 
to the rules in Figure~\ref{fig:lambdac:typing}.
\begin{center}

\end{center}
\begin{center}\mbox{}\\
\line(1,0){350}\gnl
\end{center}
\emph{Equality.} 
The following rules are in addition 
to the rules in Figure~\ref{fig:lambdac:typing}.
\begin{center}

\mbox{}\\
\end{center}
\end{minipage}
}
\caption{Additional rules for sum types in Fine-Grain Call-by-Value.
}
\label{fig:lambdac:sumtyping}
\end{figure*}

We only include constructors/destructors as 
value terms, but from these we can derive constructors/destructors 
for producer terms, as follows.
3pt]
&\cbvcasep M {x_1} {N_1} {x_2} {N_2} 
\\&
\hspace{4.5cm}
 \defeq\ 
\slet{z}{M}{(\cbvcase z {x_1} {\lam{w}{1}{N_1}} {x_2} {\lam{w}{1}{N_2}}) (\star)} 

\label{eq:derived:rules:sums:p}
\begin{array}{c}
\begin{prooftree}
\pj{\Gamma}{M}0
\justifies
\pj{\Gamma}{\cbvimagep{M}}\STA
\end{prooftree}
\GAP\GAP
\begin{prooftree}
\pj{\Gamma}{M_i}{\STA_i}
\justifies
\pj{\Gamma}{\cbvinp i{M}}{\STA_1+\STA_2}
\using
{(i=1,2)}
\end{prooftree}
\
\\

For example:

\hide{}

We now refine the notion of Kleisli model (Def.~\ref{def:monadmodel})
to accommodate the sums.
\begin{defi}
\label{def:closeddistrFreyd}
A \emph{distributive enriched Kleisli model} 
(distributive Kleisli model for short)
is 
a distributive enriched model (Def~\ref{def:distrenrichedmodel}) together with
an identity-on-objects functor  that strictly
preserves copowers and coproducts.
\end{defi}
Note that in any Kleisli model,  will preserve
coproducts because it has a right adjoint,
.
We insist moreover that it preserves coproducts strictly.

Note that a distributive Kleisli model is what 
Power~\cite[Def.~36]{Power:GenericModels:06}
calls a distributive closed Freyd category.

It is straightforward to extend our interpretation
of the fine-grain call-by-value calculus in Kleisli models
(\S\ref{sec:interpkleilsi})
 to an interpretation of 
the calculus with sums in distributive Kleisli models.
The interpretation is sound and there is a syntactic model.

In Section~\ref{sec:monads} we discussed the equivalence 
between enriched Kleisli models and strong monads with Kleisli exponentials.
This equivalence extends to an equivalence between 
distributive enriched Kleisli models, and strong monads on distributive 
categories with Kleisli exponentials. 
Likewise, the constructions  and 
 of Section~\ref{sec:relating:models} 
extend to constructions deriving {\denrmodel}s from 
{\dKlmodel}s and vice versa, and an extension of Theorem~\ref{thm:adj}
states that  and 
 exhibit a 2-category of distributive Kleisli models 
as a coreflective subcategory of a 2-category of distributive enriched models. 

\subsection{Sums and the state-passing translation}
\label{sec:sums-sps}
It is straightforward to adapt the state-passing translation to 
accommodate sums.
\renewcommand{\CBVtoEEC}{\CBVtoEECbase\EECarbstate}\renewcommand{\CBVtoEECV}{\CBVtoEECbase \EECarbstate}\renewcommand{\CBVtoEECP}[1]{\CBVtoEECbase \EECarbstate{#1}_\svar}Recall that each type~ of FGCBV is translated
to a value type  of ECBV. We set

We extend this translation to type contexts,
taking an FGCBV type context  to an
ECBV type context .

Recall that 
the translation on terms takes an FGCBV value type judgement
  
to an \ECBV\ 
judgement ,
and takes an FGCBV producer judgement  
to an \ECBV\ judgement .
We extend the translation in Section \ref{sec:translation}
straightforwardly, as follows:

The translation remains sound.
The full definability results (Theorems~\ref{thm:full-on-types}
and~\ref{thm:full:faithful}) continue to hold in the presence of sums.



\section{Remarks on the linear-use continuation-passing translation}
\label{sec:cps}

We now briefly emphasise that the linear-use continuation-passing
translation arises as a formal
dual of the linear-use state-passing translation.  
This is not a new observation: Hasegawa noticed it 
in the context of classical linear logic 
(\cite[\S 8]{Hasegawa:Flops:02},\cite{pmp-mec})
and indeed it informed the earlier work on the enriched effect calculus.



The linear-use continuation-passing translation 
was first elaborated by Berdine, O'Hearn, Reddy 
and Thielecke~\cite{Berdine:02}, 
but our main reference is 
the more recent work by Egger, M\o gelberg and
Simpson~\cite{Mogelberg:fossacs:10,EEC:LCPS:journal}. They showed that the linear-use
continuation-passing translation can be extended to an involutive
translation of the enriched effect calculus to itself, and derived a
full completeness result from this.  That work, in turn, stems from
Hasegawa's full completeness result~\cite{Hasegawa:Flops:02} for a
linear-use continuation-passing translation into dual intuitionistic /
linear logic.


Following~\cite{Mogelberg:fossacs:10},
our development is fuelled by the following categorical observation.
If a category  is enriched in  with copowers, then we
can form the dual category  which is also enriched in
, but now with powers instead of copowers.  (Recall that an
enriched category  has powers  if the functor
 is
representable.)
When viewed under this duality, the state-passing translation
becomes the continuation-passing translation, as we now explain.

In Figure~\ref{figure:ecbv:powers}, we provide
an internal language for enriched categories with powers.
We call this the `CPS variant of ECBV', because
it is the target of the continuation passing translation 
(see below).
The key difference with Figure~\ref{figure:effects:typing} is that we 
have replaced the tensor type () by
a power type ().
It is another fragment of the enriched effect calculus.
If  is a category with products
and  is a category enriched in  with powers,
then we can interpret this CPS variant of ECBV in 
through a variation of the interpretation in Section \ref{sec:adjmodels}.
The power type is interpreted using the categorical powers:
.
A computation judgement  
is interpreted as a morphism
 in~.

\begin{figure*}[t]
\framebox{
\begin{minipage}{.96\linewidth}
\emph{Types.}

\begin{center}
\line(1,0){350}\gnl
\end{center}
\emph{Term formation.}
\begin{center}

\end{center}
\begin{center}
\mbox{}\\
\line(1,0){350}\gnl
\end{center}
\emph{Equations: } Equations of Figure~\ref{figure:effects:typing} 
but with equations
for tensor types replaced by:
\begin{center}

\end{center}
\end{minipage}}
\caption{A CPS variant of 
  the enriched call-by-value calculus.}
\label{figure:ecbv:powers}
\end{figure*}


Following the categorical analysis above, 
we define a bijection  between the types of
ECBV with this CPS variant:

This bijection extends to terms-in-context straightforwardly, and the resulting 
translation is a restriction of the linear-use cps involution of 
the enriched effect calculus studied in~\cite{Mogelberg:fossacs:10,EEC:LCPS:journal}.

We achieve a linear-use continuation-passing translation
by composing the state-passing translation of Section~\ref{sec:translation}
with this bijection (\ref{eqn:SPStoCPS}).
For clarity, we now write this out explicitly.
We fix a computation type  of \ECBV,
thought of as a return type.
\newcommand{\lneg}[1]{\lpowertype {#1}\EECarbret}\renewcommand{\CBVtoEEC}{\CBVtoEECbase\EECarbret}\renewcommand{\CBVtoEECV}{\CBVtoEECbase \EECarbret}\renewcommand{\CBVtoEECP}[1]{\CBVtoEECbase \EECarbret{#1}_\kvar}We translate \FGCBV\ types  to \ECBV\ value types
:

We extend this translation to type contexts,
taking an FGCBV type context  to an
ECBV type context .

The translation on terms is syntax-directed.
We pick a variable , completely fresh.
The translation takes an FGCBV value type judgement
  
to an \ECBV\
judgement ,
and it take an FGCBV producer judgement  
to an \ECBV\ judgement .


The continuation-passing translation inherits the following results from the 
soundness and full completeness of the state-passing translation 
(Theorems~\ref{thm:soundness} and~\ref{thm:full:faithful}). 
\begin{prop}
For any computation type ,
the continuation-passing translation is sound: 
\begin{enumerate}
\item
If  then 
.
\item 
If  then 
.
\end{enumerate}
\end{prop}
\renewcommand{\lneg}[1]{\lpowertype {#1}\EECret}\renewcommand{\CBVtoEEC}{\CBVtoEECbase\EECret}\renewcommand{\CBVtoEECV}{\CBVtoEECbase \EECret}\renewcommand{\CBVtoEECP}[1]{\CBVtoEECbase \EECret{#1}_\kvar}\begin{prop}[\cite{Mogelberg:fossacs:10}, Corollary~1]
Let  be a computation type constant.
The continuation-passing translation is fully complete, in the following 
sense.
\begin{enumerate}
\item \label{item:cps:faithful:values} 
If 
 
and 
 
then .
\item 
If  

and 
 then 
.
\item For any  there is   such that . 
\item For any  there is a producer term  such that 
.
\end{enumerate}
\end{prop}

\noindent The full completeness result is the same as 
the one obtained by Egger 
et al.~\cite[Corollary~1]{Mogelberg:fossacs:10} 
except that loc.~cit.~describes a translation on the full enriched
effect calculus rather than this fragment of it.


\subsection{Sums and products}
The CPS variant of the enriched call-by-value calculus can be 
extended so that value types are closed under sums and 
computation types are closed under products. 
Thus the types are as follows:

(For brevity, we omit the term language, which is a fragment of 
the enriched effect calculus.)
The type system is designed to be dual to the enriched call-by-value language 
with sums. 
The translation from that language to this one~\eqref{eqn:SPStoCPS} 
is extended as follows:

and the analysis
of Section \ref{sec:sums-sps} can be converted to
a fully-complete linear-use continuation-passing style translation
from fine-grain call-by-value with sums.



\section{Effect theories}
\label{sec:modelsoftheories}
To illustrate the nature of the state-passing translation
we endow our calculi with effects.
We do this is in a general way, by following the programme of 
Plotkin, Power and others~\cite{Plotkin:Power:03}
whereby a theory of effects is presented as an algebraic theory.

We discuss how to add effects to the source and target languages of
the state-passing translation, FGCBV and ECBV. Our central observation
is that to accommodate an algebraic theory of effects in the enriched
call-by-value calculus it is necessary and sufficient to supply the
chosen state type  with the structure of a comodel.  The
idea of state being a comodel, particularly for the theory of store,
arose in the work of Plotkin, Power and
Shkaravska~\cite{Power:Shkaravska:04,Plotkin:Power:08}.

The section is structured as follows. We begin with an overview
in which we study the situation for a particular algebraic effect.
We then proceed to look at a general notion of effect theory~(\S\ref{sec:eff:theories}),
its relationship with the state-passing 
translation~(\S\ref{sec:effsps}) and notions of 
model and comodel~(\S\ref{sec:effmodels},\ref{sec:effmodels-example}).

\subsection{Overview}
\label{sec:overview}
\newcommand{\ifp}[3]{\codefont{if}^p~#1~\codefont{then}~#2~\codefont{else}~#3}
\newcommand{\cbvif}[3]{\codefont{if}~#1~\codefont{then}~#2~\codefont{else}~#3}
\newcommand{\sif}[3]{\mathrm{if}~#1~\mathrm{then}~#2~\mathrm{else}~#3}
\newcommand{\oread}[2]{#1\mathrel{?}#2}
\newcommand{\oprint}[1]{\mathrm{p}_{#1}}
\newcommand{\eprint}{\mathtt{print}}
\newcommand{\sprint}{\mathrm{print}}
\newcommand{\etoss}{\mathtt{toss}}
\newcommand{\stoss}{\mathrm{toss}}
\newcommand{\owrite}[2]{\mathrm{update}_{#1}(#2)}
\newcommand{\oflip}[1]{\mathrm{f}(#1)}
\newcommand{\cpsflip}[1]{\mathrm{f}[#1]}
\newcommand{\opread}[3]{#2\mathrel{?_{#1}}#3}
\newcommand{\opwrite}[3]{\mathrm{w}_{#2,#1}(#3)}
\newcommand{\opflip}[2]{\mathrm{f}_{#1}(#2)}
\newcommand{\oreadname}{(?)}
\newcommand{\oflipname}{(\mathrm{f})}
\newcommand{\owritename}[1]{\mathrm{w}_{#1}}
\newcommand{\eread}{\mathtt{deref}}
\newcommand{\ewrite}{\mathtt{assign}}
\newcommand{\eflip}{\mathtt{flip}}
\newcommand{\sread}{\mathrm{read}}
\newcommand{\sflip}{\mathrm{flip}}
\newcommand{\sassign}{\mathrm{write}}
\newcommand{\sderef}{\mathrm{read}}
We give an overview of the situation
in terms of a particular algebraic theory:
an algebraic theory for accessing a single bit of memory.
This is an algebraic theory in the classical sense 
(like monoids, groups, rings, etc.).
It has one binary operation , a unary operation

and the following four equations:
\hide{}

Here is some intuition. If  and  are computations,
then  is the computation that first reads the bit 
in memory
and then branches to  or to  depending on whether the bit was set.
If~ is a computation then  is the computation that first
flips the bit in memory ( to ,  to~) and
then continues as~.
There are derived operations
 and 
,
which first write  (resp.~) and then continue as .

We now explain how to accommodate this algebraic theory in
the fine-grain and enriched call-by-value calculi.

\subsubsection{Fine-grain call-by-value: algebraic operations and generic effects.}
\label{sec:fgcbv-geff}
In the fine-grain call-by-value calculus~(\S\ref{sec:fgcbv}), 
the algebraic theory~(\ref{eqn:squareband})
can be accommodated in two 
equivalent ways: by adding algebraic operations and by adding generic effects.
In adding the operations, we add the following term formation rules for each 
type :

We also add the equations in (\ref{eqn:squareband})
at each type, and an algebraicity equation
for each operation~(e.g.~\cite[Def~3.14]{Pretnar-Thesis}):

The result is a programming language with higher types and a single bit of 
storage.

The second way to accommodate the algebraic 
theory into the fine-grain call-by-value calculus
is by adding generic effects.
For this we need sum types (\S\ref{sec:sums:fgcbv}).
The idea is that an expression in  variables in the algebraic 
theory corresponds to a ground producer term of type~ ().
Thus we add the following axioms for term formation:

Informally,  is a computation that returns
the boolean value of the memory cell,
and  is a computation that flips the value in the memory cell.
An important observation of Plotkin and Power~\cite{Plotkin:Power:03} 
is that the algebraic operations can be recovered at all
types from the generic effects,
as follows:

where we use some shorthand notation:

Conversely the generic effects can be derived from the 
algebraic operations:

(The subscript  on  is the unit type.)
We can thus write the four equations~(\ref{eqn:squareband}) 
directly in terms of generic effects:
6pt]
\peq{}{\return{(\star)}}{\eread(\star);\return(\star)}1
\qquad\qquad
\peq{}{\eflip(\star);\eflip(\star)}{\return(\star)} 1
\
writing  for .

The two derived operations for writing a bit can 
be combined into a single command~:

where  is the evident binary operation on values of type~.
Using this derived command,
the four equations for accessing the bit of memory can be equivalently
written as the
three program equations of 
Plotkin and Power \cite{PlotkinPower:fossacs02}:

which state that reading a cell and then writing the same value is the same as doing nothing, 
that writing and the reading yields the value just written, 
and that the effect of two writes equals that of the second.
\hide{
This simple example of an algebraic theory has been 
highlighted by Melli\'es, although our presentation (\ref{eqn:squareband})
appears to be novel.}

\subsubsection{Enriched call-by-value and state access operations}
How can we accommodate the algebraic theory for a bit of memory~(\ref{eqn:squareband}) in the
enriched call-by-value calculus?
In this section we develop the following observation.
Whereas in FGCBV each type should be a \emph{model}
of the theory,
in that (\ref{eq:syntax:flip:alg:op}) gives 
terms  
and  at each type ,
in ECBV the distinguished state type  
should be a \emph{comodel} of the theory, 
which means that there are ground value terms

which we call \emph{state access operations}.
(It is called a \emph{co}model 
because the arrows have been reversed and ()
has become ().)
Using the isomorphism , we can 
understand the type of 
 as .
The idea is that the 
read operation takes a state and returns the value stored 
in that state. 
It also returns a state: this is necessary because state is linear and
cannot be discarded or duplicated. 
Notice that, under the state-passing translation,
the two generic effects (\ref{eq:syntax:flip:gen:eff}) become 
the two state access operations.

The four equations~(\ref{eqn:squareband}) 
are also appealing when written in terms
of state access operations.

Notice that the second equation says that the read operation does not change the state.

The two derived operations for writing a bit 
can be combined into a single state access operation:

Intuitively, 
writes the value  to the state ,
 returning the updated state.

In Section~\ref{sec:translation}
we have seen a fully-complete state-passing translation 
from FGCBV to ECBV. 
This translation extends to a fully-complete translation
from FGCBV with generic effects to ECBV with state access operations.

\subsubsection{Continuation passing style and algebraic operations}
Finally, we turn to the linear-use continuation-passing style. 
In this setting, 
it is natural to require that 
the distinguished return type  be a model of the theory.
This is dual to the situation with state-passing style,
where the distinguished state type  
is a comodel of the theory.

More precisely, we extend the CPS variant of ECBV (\S~\ref{sec:cps}) with 
the theory of memory access
by adding ground value terms

satisfying the following equations:

Thus
the generic effects in the source language 
endow the return type~ 
of the linear-use continuation-passing translation 
with the structure of a model for the algebraic 
theory.

\subsubsection{Further simple examples of algebraic theories for computational effects.}
\label{sec:furtherexamplesalgtheories}

The theory of accessing a bit of memory is perhaps the simplest example 
of a stateful effect.
The connections between algebraic operations, generic effects and state access operations
also work for less state-like effects.

\subsubsection*{Printing}
The algebraic theory of printing a single bit has 
two unary function symbols,  and~. 
For instance, the term  
should be understood as the computation that first prints~, then prints~, then continues as .
There are no equations in this theory.

The generic effects for printing can be grouped together into one
producer term

thought of as a command that prints its argument.

As a state access operation, 
we have a function

which, given a bit and a state, returns a new state.
Intuitively,  is a list of everything printed so far,
and  appends its first argument to its second argument.

\subsubsection*{Probability}
There are different algebraic theories of probabilistic choice.
The simplest one is the theory of `mean-values'
considered by Heckmann~\cite{h-probdom}
(but perhaps first introduced by Acz\'el~\cite{on-mean-values}):
it has one binary function 
symbol~ and its axioms are
the medial law, idempotence and commutativity:

The idea is that a computation  tosses a coin, and proceeds as  
if heads and  if tails.

The generic effect for  is  which,
intuitively, tosses the coin and returns the result.
In this style, the first equation is written

It says that it doesn't matter which order you toss coins.

The state access operation 
 
can be thought of as making the coin an explicit parameter:
we can think of  as a type of coins.
In this style, the second equation  

says that when you toss a coin you get the same coin back.
The third equation

says that if you toss a coin it is the same as tossing a coin 
and turning it once more without looking.
This illustrates that probability is not really stateful and so 
for this effect the approach based on algebraic operations
is perhaps the most profitable perspective. 
The point is that different computational effects
are better suited to different approaches (algebraic operations,
generic effects, and state access operations)
even though all three approaches are always available.

\subsection{State access operations, algebraic operations, and generic effects}
\label{sec:sao-so-geff}
We now make precise the informal connections made between 
state access operations, generic effects and algebraic operations
in the previous section.
We do this by revisiting the results
of Plotkin and Power~\cite{Plotkin:Power:03} 
in the context of an 
enriched model .

In the previous section we focused on the classical situation
where arities are natural numbers.
However, from the perspective of 
state access operations, generic effects and algebraic operations
have little to do with
natural numbers per se.
It is just as easy to allow arities to be arbitrary 
objects of the base category .
In the following result we do not make an artificial 
restriction to natural numbers. Instead we consider an operation 
with arity  and a parameter from ,
where  are objects of .
The classical case of an -ary operation is recovered 
by setting the objects  to all be the terminal object .
\begin{thm}
\label{thm:stateaccess-geneff-algop}
Let  be an enriched model with sums. Let  be an object
of . Let  and  be objects of .
The following data are equivalent:
\begin{enumerate}
\item A state access operation:
a morphism  
in .
\item A generic effect:
a morphism  in ,
where  is the monad
.
\item An algebraic operation:
a -natural family of morphisms in 

where .
\end{enumerate}
\end{thm}

\noindent The last point requires some explanation.
First, even though  is not cartesian closed,
exponentials with base  exist:
.
Second, the constructions

can be understood as 
-functors ,
since there are families of morphisms

in  that satisfy the laws for functors (respecting identities and 
composition).
Thirdly, 
a family of morphisms  
is called -natural if the following diagram commutes in 
for all  and :

(It is perhaps more compelling if
algebraic operations are defined as structure
on a -category of -algebras,
but this -category cannot be constructed without further 
assumptions on  --- see \cite[\S7]{Plotkin:Power:03}.)
\begin{proof}[Proof of Theorem~\ref{thm:stateaccess-geneff-algop}]
To see the connection between~(1) and~(2),
consider the following bijections:

To see the connection between~(1) and~(3),
we note that 

and the enriched Yoneda lemma gives

We remark that the equivalence of~(2) and~(3) is essentially Theorem~2 of \cite{Plotkin:Power:03}.\end{proof}

\subsection{Effect theories} 
\label{sec:eff:theories}
In the previous section we described connection between 
state access operations, generic effects and algebraic operations.
As we explained, the natural level of generality for this is more 
sophisticated than the classical setting:
the arity
of an operation is a list
and we allow the operation to take a parameter.
This suggests a generalization of algebraic theories
that we call `effect theories', since 
they are useful from the computational perspective.

The illustration in Section~\ref{sec:overview} 
involves storage of a single bit.
A motivating example of effect theory arises from modifying 
that theory above to allow storage of a more interesting datatype.
In FGCBV, we would like to have 
an (abstract) type  of 
storable values, and 
generic effects 
 and  with typing judgements

We add to the theory of equality for 
FGCBV (Fig.~\ref{fig:lambdac:typing})
the three equations for global store proposed by 
Plotkin and Power~\cite{PlotkinPower:fossacs02}
(\ref{eq:GS1}--(\ref{eq:GS3})):


Our notion of effect theory accommodates the classical kinds of theory 
in the overview (\S~\ref{sec:overview})
and also the more general kind of theory of memory access illustrated
above. It is roughly the same as that used by Plotkin 
and Pretnar~\cite[\S 3]{Plotkin:Pretnar:09}. 
The main difference is in the presentation:
we use generic effects rather than algebraic operations.
Rather than introducing a new calculus for expressing the allowable
equations of an effect theory, we use the first-order fragment of FGCBV. 



\subsubsection*{Value theories}
Before we introduce effect theories we briefly discuss
\emph{value theories}, which are simple extensions 
of the value judgements of FGCBV.
By a value signature we shall simply mean a signature for a
many-sorted algebraic theory in the usual sense. This means a set of
type constants ranged over by , and a set of term
constants  with a given arity , where the  range over type constants. We
can extend {\FGCBV} along a value signature by adding the type
constants and the typing rule

for every term constant 
in the signature. 
A value theory is a value
signature 
with a set of equations, i.e. pairs of terms
typable in the same context , where 
are formed only using variable introduction and the rule
(\ref{eq:value:constant}).

\subsubsection*{Effect theories}
An \emph{effect signature} consists of a value theory and a set of
effect constants each with an assigned arity 
 consisting of a list
 of type constants and a formal sum of lists of type constants,
.
(Here we are abbreviating a list  using
the notation , etc.)
{\FGCBV} can be extended along an effect signature by
adding, for every effect constant 
, a typing judgement

where
. 
In the conclusion, the vectors  should be understood as 
the product of the types in the vector. 

Here are some examples of effect signatures:
\begin{itemize}
\item The theory of reading/flipping a bit of memory (\S~\ref{sec:overview})
has no value type constants.
It has two effect constants,  and .
The effect constant  has arity 
and the effect constant  has arity ,
where  is the empty string.
\item The theory for  storing an abstract datatype
(\ref{eqn:gs-typing})
has one value type constant 
and a pair of effect constants
 
and
.
In this case term constants in the value theory can be used to add basic operations manipulating values in~:
we could ask that the storable values form a ring.
(In future, it would be interesting to allow  to
have more structure, for example as an inductive type such as the natural numbers,
but it is not clear how to extend the proof of 
Theorem~\ref{thm:embedding:ECBV:EEC} to inductive types.)
\end{itemize}

\noindent An \emph{effect theory} comprises an effect signature and a set of
equations. 
The equations are pairs 
of producer terms-in-context

of a restricted kind: 
they must be built from the first-order fragment of fine-grain call-by-value in 
Figure~\ref{figure:effecttheories:typing}.
\begin{figure*}[tp]
\framebox{
\begin{minipage}{.96\linewidth}
\emph{Types.}

\begin{center}
\line(1,0){350}\gnl
\end{center}
\emph{Terms.}
The grammar for terms is as follows.
Typing judgements are in Figure~\ref{fig:lambdac:typing},
Figure~\ref{fig:lambdac:sumtyping},
and Equations~(\ref{eq:value:constant})
and~\eqref{eq:geff:intro}.
\begin{center}
5pt]
M\,::=\ \,&
\return V
\,\mid\,
\slet x M N
\,\mid\,
\cbvcasep M {x_1}{N_1}{x_2}{N_2}

\begin{prooftree}
\tj\Gamma {t_1}{\alpha_1}\qquad\dots\qquad
\tj\Gamma{t_n}{\alpha_n}
\justifies
\tj\Gamma{f(t_1,\dots, t_n)}{\beta}
\end{prooftree}
 \label{eq:state:acc:type}
\tj {-}{e}{\ltensortype{\vec\beta}\EECstate
\lpop\ltensortype{(\vec \alpha_1 + \ldots + \vec \alpha_n)}\EECstate}

\sderef : \EECstate\lpop \ltensortype \val\EECstate
\qquad\qquad
\sassign : \ltensortype\val\EECstate\lpop\EECstate

\CBVtoEECP{(\geff(V_1\dots V_m))}
\defeq 
\geff(\ltensorterm{(\CBVtoEECV{V_1},\dots,\CBVtoEECV{V_m})}\svar)

\aeq \Gamma {s\colon \EECstate}
{\CBVtoEECP{M}}
{\CBVtoEECP{N}}
{\ltensortype\tau\EECstate}\text.

\begin{aligned}
&\aeq{-}{\svar\co\EECstate}{\svar}{\sassign[\sderef[\svar]]}\EECstate
\\
&\aeq{x\co\val}{\svar\co\EECstate}{\sderef[\sassign[\ltensorterm x\svar]]}
{\ltensorterm x {(\sassign[\ltensorterm x \svar])}}{\ltensortype\val\EECstate}
\\
&\aeq{x,y\co\val}{\svar\co\EECstate}
{\sassign[\ltensorterm y{\sassign [\ltensorterm x  \svar]}]}
{\sassign[\ltensorterm y \svar]}
\EECstate
\end{aligned}

\den{\CBVtoEECP{M}}=
\den{\CBVtoEECP{N}}:
\ltensor {\den{\Gamma}}\stateobj\to\ltensor{\den \tau}\stateobj\text.
\den{\CBVtoEECP{M}},
\den{\CBVtoEECP{N}}:
\lpower{\den \tau}\retobj\to \lpower {\den{\Gamma}}\retobj\text.
\Amodel^{\denot\tau}
\xrightarrow{(\denot{\CBVtoEECP{(N_1)}},\denot{\CBVtoEECP{(N_2)}})}
\Amodel^{\denot{\Gamma,\sigma_1}}
\times 
\Amodel^{\denot{\Gamma,\sigma_2}}
\cong
\Amodel^{(\denot{\sigma_1+\sigma_2})\times \denot\Gamma}
\xrightarrow{\denot{\CBVtoEECP{M}}^{\denot{\Gamma}}}
\Amodel^{\denot\Gamma\times\denot\Gamma}
\xrightarrow{\Amodel^\Delta}
\Amodel^{\denot\Gamma}\text.

\begin{prooftree}
\pjc{-}{M_1}{n}
\quad\dots
\quad
\pjc{-}{M_m}{n}
\justifies
\pjc-{\cbvcasenp{\geff(\star)}{\star}{M_1}{m}{\star}{M_m}}
n
\using{(\geff:-;m)}
\end{prooftree}
\
It is informative to look at the interpretation of these normalized terms.
Given interpretations ,
we have 

Thus we see that, in 
the situation where there are no type constants 
or value constants, 
the new general notion of model is 
the classical notion of model for an algebraic theory.




\hide{In an enriched model , 
we have a category  
enriched in  with \emph{co}powers.
This means that  is enriched in  with powers. A \emph{comodel} in  is a model in . }


\subsection{Examples of set-theoretic models and comodels}
\label{sec:effmodels-example}
We revisit the simple example effect theories from
Sections~\ref{sec:overview} and~\ref{sec:eff:theories}
from the model-theoretic perspective.
In each case, we find that there are comodels that are state-like.
\subsubsection{Storage}
The category  is enriched in itself with
copowers given by products and the enrichment given by 
the function space.
The set  is a comodel for the theory of 
accessing a bit of memory~(\S\ref{sec:overview}),
with  and .
This is a comodel for the theory 
in the enriched model
.  
Power and Shkaravska~\cite{Power:Shkaravska:04} showed that~ is 
the final comodel in  for the theory of accessing a bit of memory.

As an aside, we note that  is actually equivalent to 
the category of models for the theory of accessing a bit of memory.
The theory of \emph{reading} a bit of memory is sometimes called the theory
of `rectangular bands' because 
every model is isomorphic to one of the form ,
with . 
The anti-involution operation  enforces that the model is
isomorphic to 
one of the form , and thus determined by a single set.
This phenomenon has been investigated in a more general setting by 
M\'etayer~\cite{metayer-state} and Mesablishvili~\cite{mesablishvili-state}.

We can consider set theoretic models of 
the theory of storing an abstract datatype~(\ref{eqn:gs-typing}).
What is needed is an interpretation
 of the value sort,
which also plays the role of the state object.
We let 
 and .
This is a comodel for the theory for
store in the enriched model
.  

In both cases, 
the induced monad on  is 
the store monad .

\subsubsection{Printing}
\newcommand{\TwoStarAct}{\textbf{-Act}}
Let  be the category
of algebras for 
the theory of printing a bit.
The objects are triples  
where ,
and the morphisms 
are functions  that commute with the operations.
As any ordinary category, this category is enriched in .
It has copowers given by 

Thus  is an enriched model.

The algebra structure of each algebra 
equips it with the structure of a comodel
in the category of algebras.
The leading example
is the set  of strings over , 
with .
The induced state monad  
is isomorphic to the monad
 on .
We can understand a string in  as a state: it is the 
list of things output so far.

\subsubsection{Probability}
\newcommand{\MeanValueAlgebras}{\textbf{MVAlg}}
Let  be the category
of mean-value algebras.
The objects are pairs  
of a set  and a binary operation~ 
satisfying the laws of mean-value algebras~(\S\ref{sec:furtherexamplesalgtheories}).
The pair  is an enriched model.

The one-element set is trivially a mean-value algebra,
and it can be given the structure of a comodel in the category of 
mean-value algebras.
We can understand the one-element set as a set of states:
this captures the idea that probability is a stateless notion of computation.
Nonetheless, this `state object' induces a `state monad' on .
This can be understood as a monad  of 
finite dyadic probability 
distributions.
By a finite dyadic probability distribution 
on a set , 
we mean a function  
such that 
 is finite,
,
and for all ,  has a finite binary representation.
The monad  has 
 as the set of all finite dyadic probability distributions;
the unit picks out the Kronecker distributions,
and multiplication 
 
takes a distribution  on  
to a distribution  on ,
given by .

In general, when the state object is a terminal object
then the induced monad preserves terminal objects.
A terminal-object-preserving monad is sometimes called 
affine \cite[Thm.~2.1]{bilinearity-and-cc-monads}
and the corresponding effects are said to be 
discardable (e.g. \cite{DBLP:conf/fossacs/Fuhrmann02}, \cite[Def.~4.2.4]{hayo-phd}) since the following rule is admissible
in the fine-grain call-by-value language.


\subsection{Relating notions of (co)model for effect theories}

We now extend Theorem~\ref{thm:stateaccess-geneff-algop} to show, for each effect theory , a bijective correspondence between 
the following: comodel structures on , interpretations of  in the Kleisli model 
, algebraic operations equipping each 
 with a model structure for . The latter notion requires some explanation, because the definition of model given in 
Section~\ref{sec:eff-cpsmodels} defines only what it means for  in a category  
to be a model of  if  
is an enriched model, and in the setting of Theorem~\ref{thm:stateaccess-geneff-algop}  is generally not 
-enriched.

\newcommand{\retVobj}{R}To generalize the notion of model, let  be a distributive category, let  be a fixed object of  such that
all exponents of the form  exist
(i.e.~ is representable for all )
and let an interpretation of 
the value theory of  be given. We define a model structure for  on  to be an
interpretation of  
in the Kleisli model 
where  has the same objects as
 , but where a morphism  in  is a morphism  in .
 This is isomorphic to the Kleisli category for the strong monad 
 on . 
By construction, the model structure interprets each effect constant 
 as a morphism

If  is cartesian closed then  is an enriched model and the above definition of a model structure for~ on~ is equivalent to 
the one given in Section~\ref{sec:eff-cpsmodels}.

\begin{thm}
\label{thm:correspondence:thm}
Let  be an enriched model with sums, let  be an object
of , let  be an effect theory and let an interpretation of the value theory of  in  
be given. 
The following data are equivalent:
\begin{enumerate}
\item \label{item:comodel} A comodel structure for  on 
\item \label{item:Kleisli:model} An interpretation of  in the Kleisli model  
\item \label{item:alg:op:model} For each effect constant  in  an algebraic operation:
a -natural family of morphisms in 

equipping each  with a model structure for .
\end{enumerate}
\end{thm}

\renewcommand{\CBVtoEEC}{\CBVtoEECbase\EECstate}
\renewcommand{\CBVtoEECV}{\CBVtoEECbase \EECstate}
\renewcommand{\CBVtoEECP}[1]{\CBVtoEECbase \EECstate{#1}_\svar}
\begin{proof}
We first prove equivalence of (\ref{item:comodel}) and (\ref{item:Kleisli:model}). First note that in both 
cases, an effect constant 
 is modelled as a morphism

It thus suffices to show that for any term 
 of the fragment
of Figure~\ref{figure:effecttheories:typing} 
the morphisms  are equal, where 
is the \ECBV\ term  interpreted 
in the enriched model  and  is
the fine-grain call-by-value term  interpreted in the Kleisli model . This can be
proved by induction on the structure of .

To prove equivalence of (\ref{item:comodel}) and (\ref{item:alg:op:model}) we build on the equivalence of 
state access operations and algebraic operations of Theorem~\ref{thm:stateaccess-geneff-algop}. First we show that
for any term  of the fragment
of Figure~\ref{figure:effecttheories:typing} the equation 

holds. This time the denotation brackets on the left hand side refers to the interpretation of ECBV in 
, and 
the denotation brackets on the right hand side refer to the interpretation of fine-grain call-by-value in the Kleisli model 
, where . As above,  is simply the interpretation  
of  in the Kleisli model . 
Equation (\ref{eq:yon:pres:fgcbv}) can be proved by induction on the structure of . 
(There is also a categorical perspective on this, based around the construction
 which gives rise to
an identity-on-objects functor

that preserves sums and the action of , although it does not preserve 
the enrichment.)




From (\ref{eq:yon:pres:fgcbv}) we deduce the equivalence of (1) and (3). 
In fact (1)(3) is immediate:
suppose  is a comodel, and consider an 
equation  in the theory.
Since  is a comodel, we have 

and so 
 as interpreted in . 

For (3)(1), suppose that 
 is a model for every , 
naturally in . Then by (\ref{eq:yon:pres:fgcbv})  
 
holds for all equations  and all .
The enriched Yoneda embedding
is full and faithful and so
, proving that  is a comodel.

We remark that the equivalence of (2) and (3) is in the spirit of
\cite[\S 6]{Plotkin:Power:03}.
\end{proof}

\subsection{Generalizing full completeness to the case of effects}

\label{sec:fullcomplete-effects}

The full completeness result of Theorem~\ref{thm:full:faithful}
extends verbatim to the case of the calculi augmented with an effect
theory . The proof is based on an extension of the coreflection
theorem (Theorem~\ref{thm:adj}) which we state below.

First 2-categories  and  of distributive Kleisli models of  and 
distributive enriched models of  are defined. These are defined similarly to 
and  except morphisms are required to preserve coproducts (up to isomorphism) and 
the interpretation of  (strictly). Details can be found in Appendix~\ref{app:def:cats:eff}. 

\begin{lem} \label{lem:functors:eff}
The assignments  and 
 
extend to 2-functors 

\end{lem}

\begin{proofsketch}
We just show that these are well-defined on objects. The case of  is simply the implication
from (\ref{item:comodel}) to (\ref{item:Kleisli:model}) of Theorem~\ref{thm:correspondence:thm}.

In the case of  we must show that  carries a comodel structure 
for  whenever  models~. An effect constant 
  can be modelled 
as the composite

where  refers to the interpretation of  in the given
-model structure of .  We must show that this
defines a comodel, i.e., that the equations are satisfied.  To this
end one can prove that for any term  of the
fragment of fine-grain call-by-value used for effect theories
(Figure~\ref{figure:effecttheories:typing}) the equation
 holds. Here, on the left hand side the double brackets refer to the
interpretation of {\ECBV} in  and the brackets on
the right hand side refer to the interpretation of fine-grain
call-by-value in . This equation is proved by
induction on typing derivations. Thus, for any equation  in , since  models  we have , and thus also ,
proving that  is indeed a comodel.
\end{proofsketch}
We end this section by stating the coreflection theorem for models of effect theories.

\begin{thm} \label{thm:adj:eff}
The 2-functor  is left biadjoint to , i.e., 
for any pair of objects   and  of  and  respectively, there is an equivalence of categories

natural in   and . 
Moreover, the unit of the adjunction  is an isomorphism.
\end{thm}



\section{Relationship with Atkey's parameterized monads}



Atkey's work on parameterized monads~\cite{a-parammonad},
has proven relevant to 
functional programming~(e.g.~\cite[\S5.2]{kps-funwithtypefunctions}).
In this section we show that parameterized monads are essentially the same as 
enriched models.

\label{sec:parammonad}
\newcommand{\SCat}{\mathcal S}
\renewcommand{\ACat}{\mathcal A}
\newcommand{\BCat}{\mathcal B}


Recall that, in general category theory, if a functor 
 
is such that  has a 
right adjoint  for each ,
then these right adjoints together form a 
functor 
called the parameterized right adjoint.
Atkey has carried out a study of a generalized form of 
monad 
that arises from parameterized adjunctions:
the functor 

is called a parameterized monad.
Thus a parameterized monad is a functor 
 
together with extranatural families of morphisms

satisfying monad laws.
A first example of a parameterized monad is the parameterized state
monad on the category of sets:
.

Every enriched model  
contains a parameterized adjunction, 
since 
is by definition a parameterized right adjoint 
for .

Conversely, in the theory of parameterized monads,
the following Kleisli construction \cite[Prop.~1]{a-parammonad}
plays a key role.
Given a parameterized monad , 
the objects of the Kleisli category are pairs 
 of an object of  and an object of ,
and a morphism
 is a morphism
 in~.
This is a first step towards building an enriched model from a parameterized
monad.

Plain parameterized monads are not especially relevant to 
the theory of programming languages,
just as plain monads are not very relevant.
In his study of parameterized monads, 
Atkey focuses on
\emph{strong parameterized monads with Kleisli exponentials}~\cite[\S 2.4.1]{a-parammonad}.
He uses these to provide
semantics for a `command calculus', 
which is a term language closely related to our
basic enriched call-by-value calculus~(Figure~\ref{figure:effects:typing}).
\begin{prop} Let  be a category with finite products.
The following data are equivalent.
\begin{enumerate}
\item A strong parameterized monad on  with Kleisli exponentials,
taking parameters in a category  \cite[\S 2.4.1]{a-parammonad}.
\item A category  enriched in  with copowers 
(i.e., an enriched model -- \S\ref{sec:adjmodels}) 
with a chosen subcategory  of 
such that every object  of  is of the 
form  for  in  and  in .
\end{enumerate}
\end{prop}
\begin{proofnotes}
Given a strong parameterized monad 
, we 
let  be the Kleisli category for~, as above.
The pair  forms an enriched model
with :
this is a rephrasing of
what it means for  to be strong and 
have Kleisli exponentials. 
Moreover  can be identified with a subcategory of  
whose objects are of the form 
and whose morphisms are induced by the morphisms in .

Conversely, suppose we are given an enriched model 
and a chosen subcategory~ of . 
We define a parameterized monad
 
by 

It is routine to check that the two constructions are mutually inverse,
up-to equivalence of categories. 
\end{proofnotes}

\section{Relationship with the enriched effect calculus}
\label{sec:ecbvtoeec}

Our enriched call-by-value calculus (ECBV) is a fragment of the enriched
effect calculus~(EEC, \cite{Mogelberg:CSL:09,EEC:journal}) which was
designed to analyze linear usage in effectful computation.  
We now show that ECBV is not only a syntactic fragment of EEC: every model of
the enriched call-by-value calculus embeds in a model of the enriched
effect calculus.

The enriched effect calculus extends the enriched
call-by-value calculus that we introduced in Section~\ref{sec:ecbv}
with some type constructions:
5pt]
\CA,\CB~  & ::=\,
\underbrace{\CconstA \,\mid\,\ltensortype \VA\CB\hspace{2.1cm}}_{\text{\qquad \emph{Figure~\ref{figure:effects:typing}}}}
&
\mid&\underbrace{\algzero\,\mid\,\CA\oplus\CB}_{\text{\quad\emph{Figure~\ref{figure:effects:sumtyping}}}}
&\mid&
\underbrace{1 \,\mid\,\CA \times \CB \,\mid\,\VA\to\CB\,\mid\,{!}\VA
\enspace .\hspace{2cm}}_{\text{\qquad \emph{Full EEC~\cite{Mogelberg:CSL:09}}}} 
\end{array}
(\Pshf F(P))(B)\defeq \int^{A}P(A)\times \BCat(B,A)
\ \cong \ 
\colim((\yoneda_{\ACat}\downarrow P)\xrightarrow \pi
\ACat\xrightarrow F\BCat\xrightarrow {\BCat(B,-)} \Set)\text.
\ACat_k\to \CocompCat(\ACat_1,\dots,\ACat_{k-1};\CAT(\ACat_{k+1},\dots,\ACat_n;\BCat))\hat{\ACat_k}\to \CocompCat(\ACat_1,\dots,\ACat_{k-1};\CAT(\ACat_{k+1},\dots,\ACat_n;\BCat))\text;G_{!k}(A_1,\dots,A_{k-1},P,A_{k+1},\dots, A_n)=
\colim(\yoneda_{\ACat_k}\downarrow P\xrightarrow \pi 
\ACat_k\xrightarrow {G(A_1,\dots,A_{k-1},-,A_{k+1},\dots,A_n)}\BCat)\text.
F_!(P_1,\dots,P_n)(B)\cong\int^{A_1,\dots,A_n}P_1(A_1)\times\dots\times P_n(A_n)\times
\CatB(B,F(A_1,\dots,A_n))

F_!(P_1,\dots,P_n)(B)\defeq\int^{A_1,\dots,A_n}P_1(A_1)\times\dots\times P_n(A_n)\times
\CatB(B,F(A_1,\dots,A_n))

\ltensoriso_{\SA,\algB} \co 
G(\ltensor\SA\algB) \iso 
\ltensor{F(\SA)}{G(\algB)}
\stateiso  \co G\stateobj  \iso \stateobj' 
(\VTwoCell,\CTwoCell) \co (F,G) \to (F',G')
\id & \co \den \alpha' \to F\den\alpha \\\inv{\stateiso} & \co \den\states' = \stateobj' \to G\stateobj = G\den\states

\FreydToECBV(\VCat, \CCat, J) & \,\defeq (\VCat, \CCat, 1) \\
\FreydToECBV(F,G) & \,\defeq (F,G, J'(\bang{})) && \text{for } (F,G) \co (\VCat, \CCat, J) \to (\VCat', \CCat', J') \\
\FreydToECBV(\VTwoCell, \CTwoCell) & \,\defeq (\VTwoCell, \CTwoCell) 

G(1) = G(J(1))  =  J'(F(1)) \xrightarrow{J'(\bang{})} J'(1) = 1
\text.
\ECBVToFreyd(\VCat, \CCat, \stateobj) \defeq (\VCat, \KlCat{\VCat}{\CCat}{\stateobj}, J_{\stateobj})

\Homset{\KlCat{\VCat}{\CCat}{\stateobj}}{\SA}{\SB} \defeq \Homset{\CCat}{\ltensor{\SA}{\stateobj}}{\ltensor{\SB}{\stateobj}}
\Kl{F,G} \co \KlCat{\VCat}{\CCat}{\stateobj} \to \KlCat{\VCat'}{\CCat'}{\stateobj'}\ltensorisoKl \co \Kl{F,G}(\Klltensor{\SA}{\SB}) \to \Klltensor{F(\SA)}{\Kl{F,G}(\SB)} 
\ltensor{\pair{F\pi_1}{F\pi_2}}{\stateobj'} \co \ltensor{F(\SA \times \SB)}{\stateobj'} \to \ltensor{(F(\SA) \times F(\SB))}{\stateobj'}
\ECBVToFreyd(\FreydToECBV(\VCat, \CCat, J)) = (\VCat, \KlCat{\VCat}{\CCat}{1}, J_{1}) 

\eta_{(\VCat, \CCat, J)} \defeq (\id, H, \id) \co (\VCat, \CCat, J) \to (\VCat, \KlCat{\VCat}{\CCat}{1}, J_{1}) 
\xymatrix@C+1cm{
\Freyd((\VCat, \CCat, J), (\VCat', \CCat', J')) 
\ar[r]^-{\ECBVToFreyd\circ \FreydToECBV} 
\ar@/_1pc/[dr]_-{(\eta_{(\VCat', \CCat', J')})_*} 
& \Freyd((\VCat, \KlCat{\VCat}{\CCat}1, J_1), (\VCat', {\KlCat{\VCat}{\CCat}1}', J_1')) 
\ar[d]^{(\eta_{(\VCat, \CCat, J)})^*}
\\
&\Freyd((\VCat, \CCat, J), (\VCat', {\KlCat{\VCat}{\CCat}1}', {J_1}'))
}
\FreydToECBV(\ECBVToFreyd(\VCat, \CCat, \stateobj)) = (\VCat, \KlCat{\VCat}{\CCat}{\stateobj}, 1)

\Homset{\KlCat{\VCat}{\CCat}{\stateobj}}{\SA}{\SB} = \Homset{\CCat}{\ltensor{\SA}{\stateobj}}{\ltensor{\SB}{\stateobj}}

\epsilon_{(\VCat, \CCat, \stateobj)} \defeq (\id, \I{\stateobj}, \delta) \co (\VCat, \KlCat{\VCat}{\CCat}{\stateobj}, 1) \to (\VCat, \CCat, \stateobj)
\delta \co \I{\stateobj}(1) =  \ltensor 1{\stateobj} \to \stateobj
\xymatrix@C+1cm{
\CATECBV((\VCat, \CCat, \stateobj), (\VCat', \CCat', \stateobj')) 
\ar[r]^{\FreydToECBV \circ \ECBVToFreyd} 
\ar@/_1pc/[dr]_-{(\epsilon_{(\VCat, \CCat, \stateobj)})^*} 
&\CATECBV((\VCat, \KlCat{\VCat}{\CCat}{\stateobj}, 1), (\VCat', \KlCat{\VCat'}{\CCat'}{\stateobj'}, 1)) 
\ar@{}[dl]|[.01]\cong
\ar[d]^-{(\epsilon_{(\VCat', \CCat', \stateobj')})_*} \\
&\CATECBV((\VCat, \KlCat{\VCat}{\CCat}{\stateobj}, 1), (\VCat', \CCat', \stateobj'))
}\ECBVToFreyd(\epsilon_{(\VCat, \CCat, \stateobj)}) \circ \eta_{\ECBVToFreyd(\VCat, \CCat, \stateobj)}\epsilon_{\FreydToECBV(\VCat, \CCat, J)} \circ \FreydToECBV(\eta_{(\VCat, \CCat, J)})
\CATECBV(\FreydToECBV(\VCat, \CCat, J),(\VCat', \CCat',
  \stateobj)) \ \simeq\ \Freyd((\VCat, \CCat, J),\ECBVToFreyd(\VCat',
  \CCat', \stateobj))\text.

(\epsilon_Y)_* \circ \FreydToECBV \circ \eta_X^* \circ \ECBVToFreyd  
& = (\epsilon_Y)_* \circ (\FreydToECBV(\eta_X))^* \circ \FreydToECBV \circ \ECBVToFreyd \\
& = (\FreydToECBV(\eta_X))^*  \circ (\epsilon_Y)_*\circ \FreydToECBV \circ \ECBVToFreyd \\
& \iso (\FreydToECBV(\eta_X))^*  \circ (\epsilon_{\FreydToECBV(Y)})^*  & \text{Lemma~\ref{lem:eps:biadj}} \\ 
& = (\epsilon_{\FreydToECBV(Y)} \circ \FreydToECBV(\eta_X))^*  \\
& \iso \id^* & \text{Proposition~\ref{prop:triangle:eq:2}} \\
& = \id

The other composite is isomorphic to the identity for a similar reason. \qed






\end{document}
