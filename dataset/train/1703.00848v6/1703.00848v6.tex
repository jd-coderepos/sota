\documentclass{article}



\usepackage[nonatbib,final]{nips_2017}
\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      

\usepackage{graphicx} \usepackage{subfigure} 
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsfonts}   
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{caption}
\usepackage{color}
\usepackage{array,graphicx}
\usepackage{tabularx, booktabs, ragged2e}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
\newcommand*{\bfrac}[2]{\genfrac{}{}{0pt}{}{#1}{#2}}
\newcommand{\JAN}[1]{\textcolor{blue}{\textbf{[JAN: #1]}}}

\title{Unsupervised Image-to-Image Translation Networks}



\author{
  Ming-Yu Liu,\quad Thomas Breuel,\quad Jan Kautz\\
  NVIDIA\\
  \texttt{\{mingyul,tbreuel,jkautz\}@nvidia.com} \\
}

\begin{document}


\maketitle

\begin{abstract}
Unsupervised image-to-image translation aims at learning a joint distribution of images in different domains by using images from the marginal distributions in individual domains. Since there exists an infinite set of joint distributions that can arrive the given marginal distributions, one could infer nothing about the joint distribution from the marginal distributions without additional assumptions. To address the problem, we make a shared-latent space assumption and propose an unsupervised image-to-image translation framework based on Coupled GANs. We compare the proposed framework with competing approaches and present high quality image translation results on various challenging unsupervised image translation tasks, including street scene image translation, animal image translation, and face image translation. We also apply the proposed framework to domain adaptation and achieve state-of-the-art performance on benchmark datasets. Code and additional results are available in \href{https://github.com/mingyuliutw/unit}{https://github.com/mingyuliutw/unit}.
\end{abstract}

\section{Introduction}

Many computer visions problems can be posed as an image-to-image translation problem, mapping an image in one domain to a corresponding image in another domain. For example, super-resolution can be considered as a problem of mapping a low-resolution image to a corresponding high-resolution image; colorization can be considered as a problem of mapping a gray-scale image to a corresponding color image. The problem can be studied in supervised and unsupervised learning settings. In the supervised setting, paired of corresponding images in different domains are available~\cite{isola2016image,ledig2016photo}. In the unsupervised setting, we only have two independent sets of images where one consists of images in one domain and the other consists of images in another domain---there exist no paired examples showing how an image could be translated to a corresponding image in another domain. Due to lack of corresponding images, the UNsupervised Image-to-image Translation (UNIT) problem is considered harder, but it is more applicable since training data collection is easier. 


When analyzing the image translation problem from a probabilistic modeling perspective, the key challenge is to learn a joint distribution of images in different domains. In the unsupervised setting, the two sets consist of images from two marginal distributions in two different domains, and the task is to infer the joint distribution using these images. The coupling theory~\cite{lindvall2002lectures} states there exist an infinite set of joint distributions that can arrive the given marginal distributions in general. Hence, inferring the joint distribution from the marginal distributions is a highly ill-posed problem. To address the ill-posed problem, we need additional assumptions on the structure of the joint distribution.


To this end we make a shared-latent space assumption, which assumes a pair of corresponding images in different domains can be mapped to a same latent representation in a shared-latent space. Based on the assumption, we propose a UNIT framework that are based on generative adversarial networks (GANs) and variational autoencoders (VAEs). We model each image domain using a VAE-GAN. The adversarial training objective interacts with a weight-sharing constraint, which enforces a shared-latent space, to generate corresponding images in two domains, while the variational autoencoders relate translated images with input images in the respective domains. We applied the proposed framework to various unsupervised image-to-image translation problems and achieved high quality image translation results. We also applied it to the domain adaptation problem and achieved state-of-the-art accuracies on benchmark datasets. The shared-latent space assumption was used in Coupled GAN~\cite{liu2016coupled} for joint distribution learning. Here, we extend the Coupled GAN work for the UNIT problem. We also note that several contemporary works propose the cycle-consistency constraint assumption~\cite{zhu2017unpaired,kim2017learning}, which hypothesizes the existence of a cycle-consistency mapping so that an image in the source domain can be mapped to an image in the target domain and this translated image in the target domain can be mapped back to the original image in the source domain. In the paper, we show that the shared-latent space constraint implies the cycle-consistency constraint. 

 \section{Assumptions}\label{sec::form}

\begin{figure*}[t]
\centering
\includegraphics[trim=0.00in 0.4in 0.00in 0in,width=0.99\textwidth]{figures/key_shared_latent_space_and_network.pdf}
\caption{\small (a) The shared latent space assumption. We assume a pair of corresponding images $(x_1,x_2)$ in two different domains $\mathcal{X}_1$ and $\mathcal{X}_2$ can be mapped to a same latent code $z$ in a shared-latent space $\mathcal{Z}$. $E_1$ and $E_2$ are two encoding functions, mapping images to latent codes. $G_1$ and $G_2$ are two generation functions, mapping latent codes to images. (b) The proposed UNIT framework. We represent $E_1$ $E_2$ $G_1$ and $G_2$ using CNNs and implement the shared-latent space assumption using a weight sharing constraint where the connection weights of the last few layers (high-level layers) in $E_1$ and $E_2$ are tied (illustrated using dashed lines) and the connection weights of the first few layers (high-level layers) in $G_1$ and $G_2$ are tied. Here, $\tilde{x}_1^{1\rightarrow 1}$ and $\tilde{x}_2^{2\rightarrow 2}$ are self-reconstructed images, and $\tilde{x}_1^{1\rightarrow 2}$ and $\tilde{x}_2^{2\rightarrow 1}$ are domain-translated images. $D_1$ and $D_2$ are adversarial discriminators for the respective domains, in charge of evaluating whether the translated images are realistic.}
\label{fig::network}
\vspace{-4 mm}
\end{figure*}
\begin{table}[t]
\caption{\small Interpretation of the roles of the subnetworks in the proposed framework.}\label{tbl::subnetworks}
\centering
\small
{\tabcolsep=4pt\def\arraystretch{0.9}
\begin{tabularx}{395pt}{c|cccccccc}\toprule
Networks & 
$\{ E_1, G_1\}$ &
$\{ E_1, G_2\}$ & 
$\{ G_1, D_1\}$ & 
$\{ E_1, G_1, D_1\}$ & 
$\{ G_1, G_2, D_1, D_2\}$ \tabularnewline\midrule
Roles &
VAE for $\mathcal{X}_1$ &
Image Translator $\mathcal{X}_1\rightarrow\mathcal{X}_2$ &
GAN for $\mathcal{X}_1$ & 
VAE-GAN \cite{larsen2015autoencoding} & 
CoGAN \cite{liu2016coupled}
\tabularnewline\midrule
\end{tabularx}}
\vspace{-4mm}
\end{table}


Let $\mathcal{X}_1$ and $\mathcal{X}_2$ be two image domains. In supervised image-to-image translation, we are given samples $(x_1,x_2)$ drawn from a joint distribution $P_{\mathcal{X}_1,\mathcal{X}_2}(x_1, x_2)$. In unsupervised image-to-image translation, we are given samples drawn from the marginal distributions $P_{\mathcal{X}_1}(x_1)$ and $P_{\mathcal{X}_2}(x_2)$. Since an infinite set of possible joint distributions can yield the given marginal distributions, we could infer nothing about the joint distribution from the marginal samples without additional assumptions.

We make the shared-latent space assumption. As shown Figure~\ref{fig::network}, we assume for any given pair of images $x_1$ and $x_2$, there exists a shared latent code $z$ in a shared-latent space, such that we can recover both images from this code, and we can compute this code from each of the two images. That is, we postulate there exist functions $E_1^*$, $E_2^*$, $G_1^*$, and $G_2^*$ such that, given a pair of corresponding images $(x_1, x_2)$ from the joint distribution, we have $z = E_1^*(x_1) = E_2^*(x_2)$ and conversely $x_1 = G_1^*(z)$ and $x_2 = G_2^*(z)$. Within this model, the function $x_2 = F_{1\rightarrow 2}^{*}(x_1)$ that maps from $\mathcal{X}_1$ to $\mathcal{X}_2$ can be represented by the composition $F_{1\rightarrow 2}^{*}(x_1) = G_2^*(E_1^*(x_1))$. Similarly, $x_1 = F_{2\rightarrow 1}^{*}(x_2) = G_1^*(E_2^*(x_2))$. The UNIT problem then becomes a problem of learning $F_{1\rightarrow 2}^{*}$ and $F_{2\rightarrow 1}^{*}$. We note that a necessary condition for $F_{1\rightarrow 2}^{*}$ and $F_{2\rightarrow 1}^{*}$ to exist is the cycle-consistency constraint~\cite{zhu2017unpaired,kim2017learning}: $x_1 =  F_{2\rightarrow 1}^{*}(F_{1\rightarrow 2}^{*}(x_1))$ and $x_2=F_{1\rightarrow 2}^{*}(F_{2\rightarrow 1}^{*}(x_2))$. We can reconstruct the input image from translating back the translated input image. In other words, the proposed shared-latent space assumption implies the cycle-consistency assumption (but not vice versa).


To implement the shared-latent space assumption, we further assume a shared intermediate representation $h$ such that the process of generating a pair of corresponding images admits a form of 
\begin{equation}
z \rightarrow h \begin{array}{cc} \bfrac{}{\nearrow} & x_1 \\ \bfrac{\searrow}{} & x_2 \end{array}.
\end{equation}
Consequently, we have $G_1^* \equiv G_{L,1}^* \circ G_{H}^*$ and $G_2^* \equiv G_{L,2}^* \circ G_{H}^* $ where $G_{H}^*$ is a common high-level generation function that maps $z$ to $h$ and $G_{L,1}^*$ and $G_{L,2}^*$ are low-level generation functions that map $h$ to $x_1$ and $x_2$, respectively. In the case of multi-domain image translation (e.g., sunny and rainy image translation), $z$ can be regarded as the compact, high-level representation of a scene ("car in front, trees in back"), and $h$ can be considered a particular realization of $z$ through $G_H^*$ ("car/tree occupy the following pixels"), and $G_{L,1}^*$ and $G_{L,2}^*$ would be the actual image formation functions in each modality ("tree is lush green in the sunny domain, but dark green in the rainy domain"). Assuming $h$ also allow us to represent $E_1^*$ and $E_2^*$ by $E_1^* \equiv E_{H}^* \circ E_{L,1}^*$ and $E_2^* \equiv E^{*}_{H} \circ E_{L,2}^*$. 


In the next section, we discuss how we realize the above ideas in the proposed UNIT framework.

\section{Framework}

Our framework, as illustrated in Figure~\ref{fig::network}, is based on variational autoencoders (VAEs)~\cite{kingma2013auto,rezende2014stochastic,larsen2015autoencoding} and generative adversarial networks (GANs)~\cite{goodfellow2014generative,liu2016coupled}. It consists of 6 subnetworks: including two domain image encoders $E_1$ and $E_2$, two domain image generators $G_1$ and $G_2$, and two domain adversarial discriminators $D_1$ and $D_2$. Several ways exist to interpret the roles of the subnetworks, which we summarize in Table~\ref{tbl::subnetworks}. Our framework learns translation in both directions in one shot. 


\noindent{\bf VAE.} The encoder--generator pair $\{E_1,G_1\}$ constitutes a VAE for the $\mathcal{X}_1$ domain, termed VAE$_{1}$. For an input image $x_1\in \mathcal{X}_1$, the VAE$_{1}$ first maps $x_1$ to a code in a latent space $\mathcal{Z}$ via the encoder $E_1$ and then decodes a random-perturbed version of the code to reconstruct the input image via the generator $G_1$. We assume the components in the latent space $\mathcal{Z}$ are conditionally independent and Gaussian with unit variance. In our formulation, the encoder outputs a mean vector $E_{\mu,1} (x_1)$ and the distribution of the latent code $z_1$ is given by $q_1 (z_1|x_1)\equiv\mathcal{N}(z_1|E_{\mu,1}(x_1),I)$ where $I$ is an identity matrix. The reconstructed image is $\tilde{x}_1^{1\rightarrow 1} =G_1 (z_1 \sim q_1 (z_1|x_1))$. Note that here we abused the notation since we treated the distribution of $q_1 (z_1|x_1)$ as a random vector of $\mathcal{N}(E_{\mu,1}(x_1),I)$ and sampled from it. Similarly, $\{E_2,G_2\}$ constitutes a VAE for $\mathcal{X}_2$: VAE$_2$ where the encoder $E_2$ outputs a mean vector $E_{\mu,2} (x_2)$ and the distribution of the latent code $z_2$ is given by $q_2 (z_2|x_2)\equiv\mathcal{N}(z_2|E_{\mu,2}(x_2),I)$. The reconstructed image is $\tilde{x}_2^{2\rightarrow 2} =G_2 (z_2 \sim q_2 (z_2|x_2))$. 


Utilizing the reparameterization trick~\cite{kingma2013auto}, the non-differentiable sampling operation can be reparameterized as a differentiable operation using auxiliary random variables. This reparameterization trick allows us to train VAEs using back-prop. Let $\eta$ be a random vector with a multi-variate Gaussian distribution: $\eta\sim \mathcal{N}(\eta|0,I)$. The sampling operations of $z_1 \sim q_1 (z_1|x_1)$ and $z_2 \sim q_2 (z_2|x_2)$ can be implemented via $z_1=E_{\mu,1}(x_1) + \eta$ and $z_2=E_{\mu,2}(x_2) + \eta$, respectively.



{\bf Weight-sharing.} Based on the shared-latent space assumption discussed in Section~\ref{sec::form}, we enforce a weight-sharing constraint to relate the two VAEs. Specifically, we share the weights of the last few layers of $E_1$ and $E_2$ that are responsible for extracting high-level representations of the input images in the two domains. Similarly, we share the weights of the first few layers of $G_1$ and $G_2$ responsible for decoding high-level representations for reconstructing the input images.


Note that the weight-sharing constraint alone does not guarantee that corresponding images in two domains will have the same latent code. In the unsupervised setting, no pair of corresponding images in the two domains exists to train the network to output a same latent code. The extracted latent codes for a pair of corresponding images are different in general. Even if they are the same, the same latent component may have different semantic meanings in different domains. Hence, the same latent code could still be decoded to output two unrelated images. However, we will show that through adversarial training, a pair of corresponding images in the two domains can be mapped to a common latent code by $E_1$ and $E_2$, respectively, and a latent code will be mapped to a pair of corresponding images in the two domains by $G_1$ and $G_2$, respectively.  


The shared-latent space assumption allows us to perform image-to-image translation. We can translate an image $x_1$ in $\mathcal{X}_1$ to an image in $\mathcal{X}_2$ through applying $G_2 (z_1 \sim q_1 (z_1|x_1))$. We term such an information processing stream as the image translation stream. Two image translation streams exist in the proposed framework: $\mathcal{X}_1 \rightarrow \mathcal{X}_2$ and $\mathcal{X}_2 \rightarrow \mathcal{X}_1$. The two streams are trained jointly with the two image reconstruction streams from the VAEs. Once we could ensure that a pair of corresponding images are mapped to a same latent code and a same latent code is decoded to a pair of corresponding images, $(x_1, G_2 (z_1 \sim q_1 (z_1|x_1)) )$ would form a pair of corresponding images. In other words, the composition of $E_1$ and $G_2$ functions approximates $F^{*}_{1\rightarrow 2}$ for unsupervised image-to-image translation discussed in Section~\ref{sec::form}, and the composition of $E_2$ and $G_1$ function approximates $F^{*}_{2\rightarrow 1}$.


{\bf GANs.} Our framework has two generative adversarial networks: $\text{GAN}_1=\{D_1,G_1\}$ and $\text{GAN}_2=\{D_2,G_2\}$. In $\text{GAN}_1$, for real images sampled from the first domain, $D_1$ should output true, while for images generated by $G_1$, it should output false. $G_1$ can generate two types of images: 1) images from the reconstruction stream $\tilde{x}_1^{1\rightarrow 1} = G_1 (z_1 \sim q_1 (z_1|x_1))$ and 2) images from the translation stream $\tilde{x}_2^{2\rightarrow 1} = G_1 (z_2 \sim q_2 (z_2|x_2))$. Since the reconstruction stream can be supervisedly trained, it is suffice that we only apply adversarial training to images from the translation stream, $\tilde{x}_2^{2\rightarrow 1}$. We apply a similar processing to $\text{GAN}_2$ where $D_2$ is trained to output true for real images sampled from the second domain dataset and false for images generated from $G_2$.

{\bf Cycle-consistency (CC).} Since the shared-latent space assumption implies the cycle-consistency constraint (See Section~\ref{sec::form}), we could also enforce the cycle-consistency constraint in the proposed framework to further regularize the ill-posed unsupervised image-to-image translation problem. The resulting information processing stream is called the cycle-reconstruction stream.

{\bf Learning.} We jointly solve the learning problems of the VAE$_1$, VAE$_2$, GAN$_1$ and GAN$_2$ for the image reconstruction streams, the image translation streams, and the cycle-reconstruction streams: 
\begin{align}
\min_{E_1,E_2,G_1,G_2} \max_{D_1,D_2} 
&\mathcal{L}_{\text{\tiny VAE}_1}(E_1,G_1) +\mathcal{L}_{\text{\tiny GAN}_1}(E_2,G_1,D_1) +\mathcal{L}_{\text{\tiny CC}_1}(E_1,G_1,E_2,G_2)\nonumber\\
&\mathcal{L}_{\text{\tiny VAE}_2}(E_2,G_2) + \mathcal{L}_{\text{\tiny GAN}_2}(E_1,G_2,D_2)+\mathcal{L}_{\text{\tiny CC}_2}(E_2,G_2,E_1,G_1)
\label{eqn::UNIT_training}.
\end{align}
VAE training aims for minimizing a variational upper bound In~(\ref{eqn::UNIT_training}), the VAE objects are 
\begin{align}
\mathcal{L}_{\text{\tiny VAE}_1}(E_1,G_1)=&\lambda_1 \text{KL}( q_1(z_1|x_1) || p_{\eta}(z) ) - \lambda_2 \mathbb{E}_{z_1 \sim q_1 (z_1|x_1)}[\log p_{G_1}(x_1|z_1)]\label{eqn::vae1}\\
\mathcal{L}_{\text{\tiny VAE}_2}(E_2,G_2)=&\lambda_1 \text{KL}( q_2(z_2|x_2) || p_{\eta}(z) ) - \lambda_2 \mathbb{E}_{z_2 \sim q_2 (z_2|x_2)}[\log p_{G_2}(x_2|z_2)].\label{eqn::vae2}
\end{align}
where the hyper-parameters $\lambda_1$ and $\lambda_2$ control the weights of the objective terms and the KL divergence terms penalize deviation of the distribution of the latent code from the prior distribution. The regularization allows an easy way to sample from the latent space~\cite{kingma2013auto}. We model $p_{G_1}$ and $p_{G_2}$ using Laplacian distributions, respectively. Hence, minimizing the negative log-likelihood term is equivalent to minimizing the absolute distance between the image and the reconstructed image. The prior distribution is a zero mean Gaussian $p_{\eta}(z)=\mathcal{N}(z|0,I)$.


In~(\ref{eqn::UNIT_training}), the GAN objective functions are given by  
\begin{align}
\mathcal{L}_{\text{\tiny GAN}_1}&(E_2,G_1,D_1)=\lambda_0\mathbb{E}_{x_1 \sim P_{\mathcal{X}_1}} [\log D_1 (x_1) ]+\lambda_0\mathbb{E}_{z_2 \sim q_2 (z_2|x_2)}[\log(1-D_1(G_1(z_2)))]\label{eqn::GAN1}\\
\mathcal{L}_{\text{\tiny GAN}_2}&(E_1,G_2,D_2)=\lambda_0\mathbb{E}_{x_2 \sim P_{\mathcal{X}_2}} [\log D_2 (x_2) ]+\lambda_0\mathbb{E}_{z_1 \sim q_1 (z_1|x_1)}[\log(1-D_2(G_2(z_1)))].\label{eqn::GAN2}
\end{align}
The objective functions in (\ref{eqn::GAN1}) and (\ref{eqn::GAN2}) are conditional GAN objective functions. They are used to ensure the translated images resembling images in the target domains, respectively. The hyper-parameter $\lambda_0$ controls the impact of the GAN objective functions.

We use a VAE-like objective function to model the cycle-consistency constraint, which is given by
\begin{align}
\mathcal{L}_{\text{\tiny CC}_1}(E_1,G_1,E_2,G_2)=&\lambda_3\text{KL}( q_1(z_1|x_1) || p_{\eta}(z) )+\lambda_3\text{KL}( q_2(z_2|x_1^{1\rightarrow 2})) || p_{\eta}(z) )-\nonumber\\
&\lambda_4\mathbb{E}_{z_2 \sim q_2 (z_2|x_1^{1\rightarrow 2})}[\log p_{G_1}(x_1|z_2)]\label{eqn::cc1}\\
\mathcal{L}_{\text{\tiny CC}_2}(E_2,G_2,E_1,G_1)=&\lambda_3\text{KL}( q_2(z_2|x_2) || p_{\eta}(z) )+\lambda_3\text{KL}( q_1(z_1|x_2^{2\rightarrow 1})) || p_{\eta}(z) )-\nonumber\\
&\lambda_4\mathbb{E}_{z_1 \sim q_1 (z_1|x_2^{2\rightarrow 1})}[\log p_{G_2}(x_2|z_1)].\label{eqn::cc2}
\end{align}
where the negative log-likelihood objective term ensures a twice translated image resembles the input one and the KL terms penalize the latent codes deviating from the prior distribution in the cycle-reconstruction stream (Therefore, there are two KL terms). The hyper-parameters $\lambda_3$ and $\lambda_4$ control the weights of the two different objective terms.

Inheriting from GAN, training of the proposed framework results in solving a mini-max problem where the optimization aims to find a saddle point. It can be seen as a two player zero-sum game. The first player is a team consisting of the encoders and generators. The second player is a team consisting of the adversarial discriminators. In addition to defeating the second player, the first player has to minimize the VAE losses and the cycle-consistency losses. We apply an alternating gradient update scheme similar to the one described in \cite{goodfellow2014generative} to solve~(\ref{eqn::UNIT_training}). Specifically, we first apply a gradient ascent step to update $D_1$ and $D_2$ with $E_1$, $E_2$, $G_1$, and $G_2$ fixed. We then apply a gradient descent step to update $E_1$, $E_2$, $G_1$, and $G_2$ with $D_1$ and $D_2$ fixed. 

{\bf Translation:} After learning, we obtain two image translation functions by assembling a subset of the subnetworks. We have $F_{1\rightarrow 2} (x_1)=G_2 (z_1 \sim q_1 (z_1|x_1))$ for translating images from $\mathcal{X}_1$ to $\mathcal{X}_2$ and  $F_{2\rightarrow 1} (x_2)=G_1 (z_2 \sim q_2 (z_2|x_2))$ for translating images from $\mathcal{X}_2$ to $\mathcal{X}_1$.


 \section{Experiments}

\begin{figure*}[t]
\centering
\includegraphics[trim=0.00in 0.4in 0.00in 0in,width=0.95\textwidth]{figures/key_ablation.pdf}
\caption{\small (a) Illustration of the Map dataset. Left: satellite image. Right: map. We translate holdout satellite images to maps and measure the accuracy achieved by various configurations of the proposed framework. (b) Translation accuracy versus different network architectures. (c) Translation accuracy versus different hyper-parameter values. (d) Impact of weight-sharing and cycle-consistency constraints on translation accuracy.}
\label{fig::map}
\vspace{-4 mm}
\end{figure*}

We first analyze various components of the proposed framework. We then present visual results on challenging translation tasks. Finally, we apply our framework to the domain adaptation tasks.

{\bf Performance Analysis.} We used ADAM~\cite{kingma2014adam} for training where the learning rate was set to 0.0001 and momentums were set to 0.5 and 0.999. Each mini-batch consisted of one image from the first domain and one image from the second domain. Our framework had several hyper-parameters. The default values were $\lambda_0=10$, $\lambda_3=\lambda_1=0.1$ and $\lambda_4=\lambda_2=100$. For the network architecture, our encoders consisted of 3 convolutional layers as the front-end and 4 basic residual blocks~\cite{he2016deep} as the back-end. The generators consisted of 4 basic residual blocks as the front-end and 3 transposed convolutional layers as the back-end. The discriminators consisted of stacks of convolutional layers. We used LeakyReLU for nonlinearity. The details of the networks are given in Appendix~\ref{app::network}.

We used the map dataset~\cite{isola2016image} (visualized in Figure~\ref{fig::map}), which contained corresponding pairs of images in two domains (satellite image and map) useful for quantitative evaluation. Here, the goal was to learn to translate between satellite images and maps. We operated in an unsupervised setting where we used the 1096 satellite images from the training set as the first domain and 1098 maps from the validation set as the second domain. We trained for 100K iterations and used the final model to translate 1098 satellite images in the test set. We then compared the difference between a translated satellite image (supposed to be maps) and the corresponding ground truth maps pixel-wisely. A pixel translation was counted correct if the color difference was within 16 of the ground truth color value. We used the average pixel accuracy over the images in the test set as the performance metric. We could use color difference for measuring translation accuracy since the target translation function was unimodal. We did not evaluate the translation from maps to images since the translation was multi-modal, which was difficult to construct a proper evaluation metric.

In one experiment, we varied the number of weight-sharing layers in the VAEs and paired each configuration with discriminator architectures of different depths during training. We changed the number of weight-sharing layers from 1 to 4. (Sharing 1 layer in VAEs means sharing 1 layer for $E_1$ and $E_2$ and, at the same time, sharing 1 layer for $G_1$ and $G_2$.) The results were reported in Figure~\ref{fig::map}(b). Each curve corresponded to a discriminator architecture of a different depth. The x-axis denoted the number of weigh-sharing layers in the VAEs. We found that the shallowest discriminator architecture led to the worst performance. We also found that the number of weight-sharing layer had little impact. This was due to the use of the residual blocks. As tying the weight of one layer, it effectively constrained the other layers since the residual blocks only updated the residual information. In the rest of the experiments, we used VAEs with 1 sharing layer and discriminators of 5 layers.

We analyzed impact of the hyper-parameter values to the translation accuracy. For different weight values on the negative log likelihood terms (i.e., $\lambda_2$, $\lambda_4$), we computed the achieved translation accuracy over different weight values on the KL terms (i.e., $\lambda_1$, $\lambda_3$). The results were reported in Figure~\ref{fig::map}(c). We found that, in general, a larger weight value on the negative log likelihood terms yielded a better translation accuracy. We also found setting the weights of the KL terms to 0.1 resulted in consistently good performance. We hence set $\lambda_1=\lambda_3=0.1$ and $\lambda_2=\lambda_4=100$.

We performed an ablation study measuring impact of the weight-sharing and cycle-consistency constraints to the translation performance and showed the results in Figure~\ref{fig::map}(d). We reported average accuracy over 5 trials (trained with different initialized weights.). We note that when we removed the weight-sharing constraint (as a consequence, we also removed the reconstruction streams in the framework), the framework was reduced to the CycleGAN architecture~\cite{zhu2017unpaired,kim2017learning}. We found the model achieved an average pixel accuracy of 0.569. When we removed the cycle-consistency constraint and only used the weight-sharing constraint\footnote{We used this architecture in an earlier version of the paper.}, it achieved 0.568 average pixel accuracy. But when we used the full model, it achieved the best performance of 0.600 average pixel accuracy. This echoed our point that for the ill-posed joint distribution recovery problem, more constraints are beneficial.

\begin{figure}
\centering
\includegraphics[trim=0.0in 0.3in 0.0in 0in,width=0.99\textwidth]{figures/street_scene.pdf}
\vspace{-2mm}
\caption{\small Street scene image translation results. For each pair, left is input and right is the translated image.}
\label{fig::street_result}
\includegraphics[trim=0.0in 0.2in 0.0in 0in,width=0.99\textwidth]{figures/dog_trans.pdf}
\caption{\small Dog breed translation results.}
\label{fig::dog_result}
\includegraphics[trim=0.0in 0.2in 0.0in 0in,width=0.99\textwidth]{figures/cat_trans.pdf}
\caption{\small Cat species translation results.}
\label{fig::cat_result}
\includegraphics[trim=0.0in 0.2in 0.0in 0in,width=0.99\textwidth]{figures/faces.pdf}
\caption{\small Attribute-based face translation results.}
\label{fig::face_result}
\end{figure}

{\bf Qualitative results.} Figure~\ref{fig::street_result} to~\ref{fig::face_result} showed  results of the proposed framework on various UNIT tasks.

{\it Street images.} We applied the proposed framework to several unsupervised street scene image translation tasks including sunny to rainy, day to night, summery to snowy, and vice versa. For each task, we used a set of images extracted from driving videos recorded at different days and cities. The numbers of the images in the sunny/day, rainy, night, summery, and snowy sets are 86165, 28915, 36280, 6838, and 6044. We trained the network to translate street scene image of size  640$\times$480. In Figure~\ref{fig::street_result}, we showed several example translation results . We found that our method could generate realistic translated images. We also found that one translation was usually harder than the other. Specifically, the translation that required adding more details to the image was usually harder (e.g. night to day). Additional results are available in \href{https://github.com/mingyuliutw/unit}{https://github.com/mingyuliutw/unit}.

{\it Synthetic to real.} In Figure~\ref{fig::street_result}, we showed several example results achieved by applying the proposed framework to translate images between the synthetic images in the SYNTHIA dataset~\cite{RosCVPR16} and the real images in the Cityscape dataset~\cite{cordts2015cityscapes}. For the real to synthetic translation, we found our method made the cityscape images cartoon like. For the synthetic to real translation, our method achieved better results in the building, sky, road, and car regions than in the human regions. 

{\it Dog breed conversion.} We used the images of Husky, German Shepherd, Corgi, Samoyed, and Old English Sheep dogs in the ImageNet dataset to learn to translate dog images between different breeds. We only used the head regions, which were extracted by a template matching algorithm. Several example results were shown in Figure~\ref{fig::dog_result}. We found our method translated a dog to a different breed. 

{\it Cat species conversion.} We also used the images of house cat, tiger, lion, cougar, leopard, jaguar, and cheetah in the ImageNet dataset to learn to translate cat images between different species. We only used the head regions, which again were extracted by a template matching algorithm. Several example results were shown in Figure~\ref{fig::cat_result}. We found our method translated a cat to a different specie.

{\it Face attribute.} We used the CelebA dataset~\cite{liu2015deep} for attribute-based face images translation. Each face image in the dataset had several attributes, including blond hair, smiling, goatee, and eyeglasses. The face images with an attribute constituted the 1st domain, while those without the attribute constituted the 2nd domain. In Figure~\ref{fig::face_result}, we visualized the results where we translated several images that do not have blond hair, eye glasses, goatee, and smiling to corresponding images with each of the individual attributes. We found that the translated face images were realistic.

{\bf Domain Adaptation.} We applied the proposed framework to the problem for adapting a classifier trained using labeled samples in one domain (source domain) to classify samples in a new domain (target domain) where labeled samples in the new domain are unavailable during training. Early works have explored ideas from subspace learning~\cite{fernando2013unsupervised} to deep feature learning~\cite{ganin2016domain,liu2016coupled,taigman2016unsupervised}. 

\begin{table}[t!]
\caption{\small Unsupervised domain adaptation performance. The reported numbers are classification accuracies.}\label{tab::svhn2mnist}
\centering
\small
{\tabcolsep=8pt\def\arraystretch{1.1}
\begin{tabularx}{355pt}{cccccc}
Method & SA~\cite{fernando2013unsupervised} & DANN~\cite{ganin2016domain} & DTN~\cite{taigman2016unsupervised}  &  CoGAN & UNIT (proposed) \tabularnewline\midrule
SVHN$\rightarrow$ MNIST & 0.5932 & 0.7385 & 0.8488 & - &{\bf 0.9053}\tabularnewline\
MNIST$\rightarrow$ USPS & - & -  & -  & 0.9565 &{\bf 0.9597}\tabularnewline
USPS$\rightarrow$ MNIST & - & -  & -  & 0.9315 &{\bf 0.9358}\tabularnewline
\end{tabularx}}
\vspace{-5mm}
\end{table}

We performed multi-task learning where we trained the framework to 1) translate images between the source and target domains and 2) classify samples in the source domain using the features extracted by the discriminator in the source domain. Here, we tied the weights of the high-level layers of $D_1$ and $D_2$. This allows us to adapt a classifier trained in the source domain to the target domain. Also, for a pair of generated images in different domains, we minimized the L1 distance between the features extracted by the highest layer of the discriminators, which further encouraged $D_1$ and $D_2$ to interpret a pair of corresponding images in the same way. We applied the approach to several tasks including adapting from the Street View House Number (SVHN) dataset~\cite{netzer2011reading} to the MNIST dataset and adapting between the MNIST and USPS datasets. Table~\ref{tab::svhn2mnist} reported the achieved performance with comparison to the competing approaches. We found that our method achieved a 0.9053 accuracy for the SVHN$\rightarrow$MNIST task, which was much better than 0.8488 achieved by the previous state-of-the-art method~\cite{taigman2016unsupervised}. We also achieved better performance for the MNIST$\leftrightarrow$SVHN task than the Coupled GAN approach, which was the state-of-the-art. The digit images had a small resolution. Hence, we used a small network. We also found that the cycle-consistency constraint was not necessary for this task. More details about the experiments are available in Appendix~\ref{app::domain}.



 \section{Related Work}

Several deep generative models were recently proposed for image generation including GANs~\cite{goodfellow2014generative}, VAEs~\cite{kingma2013auto,rezende2014stochastic}, and  PixelCNN~\cite{van2016conditional}. The proposed framework was based on GANs and VAEs but it was designed for the unsupervised image-to-image translation task, which could be considered as a conditional image generation model. In the following, we first review several recent GAN and VAE works and then discuss related image translation works.

{\bf GAN} learning is via staging a zero-sum game between the generator and discriminator. The quality of GAN-generated images had improved dramatically since the introduction. LapGAN~\cite{denton2015deep} proposed a Laplacian pyramid implementation of GANs. DCGAN~\cite{radford2015unsupervised} used a deeper convolutional network. Several GAN training tricks were proposed in~\cite{salimans2016improved}. WGAN~\cite{arjovsky2017wasserstein} used the Wasserstein distance.

{\bf VAEs} optimize a variational bound. By improving the variational approximation, better image generation results were achieved~\cite{maaloe2016auxiliary,kingma2016improving}. In~\cite{larsen2015autoencoding}, a VAE-GAN architecture was proposed to improve image generation quality of VAEs. VAEs were applied to translate face image attribute in~\cite{yan2015attribute2image}. 

Conditional generative model is a popular approach for mapping an image from one domain to another. Most of the existing works were based on supervised learning~\cite{ledig2016photo,isola2016image,johnson2016perceptual}. Our work differed to the previous works in that we do not need corresponding images. Recently,~\cite{taigman2016unsupervised} proposed the domain transformation network (DTN) and achieved promising results on translating small resolution face and digit images. In addition to faces and digits, we demonstrated that the proposed framework can translate large resolution natural images. It also achieved a better performance in the unsupervised domain adaptation task. In~\cite{shrivastava2016learning}, a conditional generative adversarial network-based approach was proposed to translate a rendering images to a real image for gaze estimation. In order to ensure the generated real image was similar to the original rendering image, the L1 distance between the generated and original image was minimized. We note that two contemporary papers~\cite{zhu2017unpaired,kim2017learning} independently introduced the cycle-consistency constraint for the unsupervised image translation. We showed that that the cycle-consistency constraint is a natural consequence of the proposed shared-latent space assumption. From our experiment, we found that cycle-consistency and the weight-sharing (a realization of the shared-latent space assumption) constraints rendered comparable performance. When the two constraints were jointed used, the best performance was achieved.

\section{Conclusion and Future Work}

We presented a general framework for unsupervised image-to-image translation. We showed it learned to translate an image from one domain to another without any corresponding images in two domains in the training dataset. The current framework has two limitations. First, the translation model is unimodal due to the Gaussian latent space assumption. Second, training could be unstable due to the saddle point searching problem. We plan to address these issues in the future work. 
{\small
\bibliographystyle{ieee}
\bibliography{unit.bib}
}
\appendix
\clearpage
\section{Network Architecture}\label{app::network}

The network architecture used for the unsupervised image-to-image translation experiments is given in Table~\ref{tbl::arch}. We use the following abbreviation for ease of presentation: N=Neurons, K=Kernel size, S=Stride size. The transposed convolutional layer is denoted by DCONV. The residual basic block is denoted as RESBLK. 

\begin{table}[tbh!]
\caption{\small Network architecture for the unsupervised image translation experiments.}
\label{tbl::arch}
\small
\centering
\begin{tabularx}{265pt}{clcc}
\toprule
Layer &  Encoders & Shared? \tabularnewline\midrule
1 & CONV-(N64,K7,S1), LeakyReLU &No\tabularnewline
2 & CONV-(N128,K3,S2), LeakyReLU  &No\tabularnewline
3 & CONV-(N256,K3,S2), LeakyReLU  &No\tabularnewline
4 & RESBLK-(N512,K3,S1) &No\tabularnewline
5 & RESBLK-(N512,K3,S1) &No\tabularnewline
6 & RESBLK-(N512,K3,S1) &No\tabularnewline
$\mu$ & RESBLK-(N512,K3,S1) &Yes\tabularnewline\midrule
Layer &  Generators & Shared?\tabularnewline\midrule
1 & RESBLK-(N512,K3,S1) &Yes\tabularnewline
2 & RESBLK-(N512,K3,S1) &No\tabularnewline
3 & RESBLK-(N512,K3,S1) &No\tabularnewline
4 & RESBLK-(N512,K3,S1) &No\tabularnewline
5 &  DCONV-(N256,K3,S2), LeakyReLU &No\tabularnewline
6 &  DCONV-(N128,K3,S2), LeakyReLU &No\tabularnewline
7 &  DCONV-(N3,K1,S1), TanH & No\tabularnewline\midrule
Layer &  Discriminators & Shared? \tabularnewline\midrule
1 & CONV-(N64,K3,S2), LeakyReLU &No\tabularnewline
2 & CONV-(N128,K3,S2), LeakyReLU  &No\tabularnewline
3 & CONV-(N256,K3,S2), LeakyReLU  &No\tabularnewline
4 & CONV-(N512,K3,S2), LeakyReLU  &No\tabularnewline
5 & CONV-(N1024,K3,S2), LeakyReLU  &No\tabularnewline
6 & CONV-(N1,K2,S1), Sigmoid &No\tabularnewline\bottomrule
\end{tabularx}
\end{table}

\section{Domain Adaptation}\label{app::domain}

{\bf MNIST$\leftrightarrow$USPS.} For the MNIST and USPS adaptation experiments, we used the entire training sets in the two domains (60000 training images for MNIST and 7291 training images for USPS) for learning and reported the classification performance on the test sets (10000 test images for MNIST and 2007 test images for USPS). The MNIST and USPS images had different sizes, we resized them to 28$\times$28 for facilitating the experiments. We trained the Coupled GAN algorithm~\cite{liu2016coupled} using the same setting for a fair comparison. 

The encoder and generator architecture was given in Table~\ref{tbl::digit_vae}. For the discriminators and classifiers, we used an architecture akin to the one used in the Coupled GAN paper, which is given in Table~\ref{tbl::digit_lenet}.

{\bf SVHN$\rightarrow$MNIST.} For the SVHN and MNIST domain adaptation experiment, we used the extra training set (consisting of 531131 images) in the SVHN dataset for the source domain and the training set (consisting of 60000 images) in the MNIST dataset for the target domain as in the DTN work~\cite{taigman2016unsupervised}. The test set consists of 10000 images in the MNIST test dataset. The MNIST images were in gray-scale. We converted them to RGB images and performed a data augmentation where we also used the inversions of the original MNIST images for training. All the images were resized to 32$\times$32 for facilitating the experiment. We also found spatial context information was useful. For each input image, we created a 5-channel variant where the first three channels were the original RGB images and the last two channels were the normalized x and y coordinates.

The encoder and generator architecture was the same as the one used in the MNIST$\leftrightarrow$USPS domain adaptation. For the discriminators and the classifier, we 
used a network architecture akin to the one used in the DTN paper. The details are given in Table~\ref{tbl::arch_maxpool_svhn}. We used dropout at every layer in the classifier for avoiding over-fitting.

\begin{table}[tbh!]
\caption{\small Encoder and generator architecture for MNIST$\leftrightarrow$USPS domain adaptation.}
\label{tbl::digit_vae}
\small
\centering
\begin{tabularx}{265pt}{clcc}
\toprule
Layer &  Encoders & Shared? \tabularnewline\midrule
1 & CONV-(N64,K5,S2), BatchNorm, LeakyReLU &No\tabularnewline
2 & CONV-(N128,K5,S2), BatchNorm, LeakyReLU  &Yes\tabularnewline
3 & CONV-(N256,K8,S1), BatchNorm, LeakyReLU  &Yes\tabularnewline
4 & CONV-(N512,K1,S1), BatchNorm, LeakyReLU  &Yes\tabularnewline
$\mu$ & CONV-(N1024,K1,S1) &Yes\tabularnewline\midrule
Layer &  Generators & Shared?\tabularnewline\midrule
1 &  DCONV-(N512,K4,S2), BatchNorm, LeakyReLU & Yes\tabularnewline
2 &  DCONV-(N256,K4,S2), BatchNorm, LeakyReLU &Yes\tabularnewline
3 &  DCONV-(N128,K4,S2), BatchNorm, LeakyReLU &Yes\tabularnewline
4 &  DCONV-(N64,K4,S2), BatchNorm, LeakyReLU &No\tabularnewline
5 &  DCONV-(N3,K1,S1), TanH & No\tabularnewline\midrule
\end{tabularx}
\caption{\small Discriminator architecture for MNIST$\leftrightarrow$USPS domain adaptation.}
\label{tbl::digit_lenet}
\small
\centering
\begin{tabularx}{265pt}{clcc}
\toprule
Layer &  Discriminators & Shared? \tabularnewline\midrule
1 & CONV-(N20,K5,S1), MaxPooling-(K2,S2) &No\tabularnewline
2 & CONV-(N50,K5,S1), MaxPooling-(K2,S2) &Yes\tabularnewline
3 & FC-(N500), ReLU, Dropout  &Yes\tabularnewline
4a & FC-(N1), Sigmoid  &Yes\tabularnewline
4b & FC-(N10), Softmax  &Yes\tabularnewline\bottomrule
\end{tabularx}
\caption{\small Discriminator architecture for SVHN$\rightarrow$MNIST domain adaptation.}
\label{tbl::arch_maxpool_svhn}
\small
\centering
\begin{tabularx}{265pt}{clcc}
\toprule
Layer &  Discriminators & Shared? \tabularnewline\midrule
1 & CONV-(N64,K5,S1), MaxPooling-(K2,S2) &No\tabularnewline
2 & CONV-(N128,K5,S1), MaxPooling-(K2,S2) &Yes\tabularnewline
3 & CONV-(N256,K5,S1), MaxPooling-(K2,S2) &Yes\tabularnewline
4 & CONV-(N512,K5,S1), MaxPooling-(K2,S2) &Yes\tabularnewline
5a & FC-(N1), Sigmoid  &Yes\tabularnewline
5b & FC-(N10), Softmax  &Yes\tabularnewline\bottomrule
\end{tabularx}
\end{table}


 
\end{document}
