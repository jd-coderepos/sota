\documentclass{llncs}

\usepackage{stmaryrd}

\usepackage{latexsym}
\usepackage{amstext,amssymb,amsmath}
\usepackage{prftree}
\usepackage{thmtools,thm-restate}

\usepackage{mdframed}

\declaretheorem[name=Theorem]{thm}
\declaretheorem[name=Proposition,numberlike=proposition]{prop}


\title{On Stronger Calculi for QBFs\thanks{The work was supported by
    the Austrian Science Foundation (FWF) under grant
    S11409-N23. Partial results have been announced at the QBF
    Workshop 2014
    (http://www.easychair.org/smart-program/VSL2014/QBF-program.html).
}
}

\author{Uwe Egly}

\institute{
Institut f\"ur Informationssysteme 184/3,
Technische Universit\"at Wien, \\
Favoritenstrasse 9--11, A-1040 Vienna, Austria\\
 {email: \texttt{uwe@kr.tuwien.ac.at}}
}

\newcommand{\remind}[1]{{\color{red}{\bf [#1]}}}

\newcommand{\qsigma}[1]{\mbox{}}
\newcommand{\qpi}[1]{\mbox{}}


\newcommand{\base}{{\sf Base}}
\newcommand{\ih}{{\sf IH}}
\newcommand{\step}{{\sf Step}}

\newcommand{\sccase}[1]{\noindent {\sc Case~#1}}
\newcommand{\scsubcase}[2]{\noindent {\sc Subcase~#1.#2}}
\newcommand{\scsubsubcase}[3]{\noindent {\sc Subsubcase~#1.#2.#3}}

\newcommand{\varMerged}[1]{{#1}^*}
\newcommand{\emptyclause}{\Box}

\newcommand{\qres}{\mbox{\sf Q-res}}
\newcommand{\qures}{\mbox{\sf QU-res}}
\newcommand{\qdres}{\mbox{\sf Q(D)-res}}
\newcommand{\ldqres}{\mbox{\sf LDQ-res}}
\newcommand{\ldqures}{\mbox{\sf LDQU-res}}
\newcommand{\ldqupres}{\mbox{\sf LDQU{}-res}}
\newcommand{\APRes}{\mbox{\sf PR}}
\newcommand{\EPRes}{\mbox{\sf PR}}
\newcommand{\PFac}{\mbox{\sf PF}}
\newcommand{\ForallRed}{\mbox{\sf R}}

\newcommand{\Rfo}{}
\newcommand{\Rfoqe}{}

\newcommand{\IRcalc}{}
\newcommand{\IRcalcPM}[2]{}
\newcommand{\IRcalcPMSubst}[3]{}
\newcommand{\IRcalcPMDSubst}[4]{}
\newcommand{\IRMcalc}{}

\newcommand{\Res}{}
\newcommand{\Fac}{}
\newcommand{\Axiom}{}
\newcommand{\Inst}{}
\newcommand{\InstOp}[2]{}

\newcommand{\Gq}{\mbox{{\sf G}}}
\newcommand{\Gqtree}{\mbox{{\sf G}}}
\newcommand{\Gqi}[1]{\mbox{{\sf G}}}
\newcommand{\Gqitree}[1]{\mbox{{\sf G}}}
\newcommand{\KP}{\mbox{{\sf KP}}}
\newcommand{\KPi}[1]{\mbox{{\sf KP}}}
\newcommand{\KPitree}[1]{\mbox{{\sf KP}}}

\newcommand{\Gqxetree}{}
\newcommand{\Gqfetree}{}
\newcommand{\Gqfetreei}[1]{}
\newcommand{\Gqvetree}{}
\newcommand{\Gqvetreei}[1]{}
\newcommand{\Gqsetree}{}
\newcommand{\Gqsstree}{}
\newcommand{\Gqxe}{\mbox{{\sf Gqxe}}}
\newcommand{\Gqfe}{\mbox{{\sf Gqfe}}}
\newcommand{\Gqve}{\mbox{{\sf Gqve}}}
\newcommand{\Gqse}{\mbox{{\sf Gqse}}}
\newcommand{\Gqss}{\mbox{{\sf Gqss}}}

\newcommand{\CMGtext}{\mbox{\sf G}}
\newcommand{\CMG}{\mbox{\CMGtext}}
\newcommand{\CMGi}[1]{\CMGtext_{#1}}

\newcommand{\Gfo}{\mbox{{\sf Gfo}}}
\newcommand{\Gfoext}{\mbox{{\sf Gfoext}}}

\newcommand{\Gqfecut}{\mbox{{\sf Gqfe+cut}}}
\newcommand{\Gqvecut}{\mbox{{\sf Gqve+cut}}}
\newcommand{\Gfocut}{\mbox{{\sf Gfo+cut}}}
\newcommand{\Gfoextcut}{\mbox{{\sf Gfoext+cut}}}

\newcommand{\GBP}{\mbox{{\sf GBP}}}

\newcommand{\pf}{^*}
\newcommand{\af}{^+}

\newcommand{\Piqi}[1]{\Pi^q_{#1}}
\newcommand{\Sigmaqi}[1]{\Sigma^q_{#1}}


\newcommand{\derive}{\vdash}
\newcommand{\dGqve}{\derive_{\mbox{{\sf\scriptsize Gqve}}}}
\newcommand{\dGfoext}{\derive_{\mbox{{\sf\scriptsize Gfoext}}}}
\newcommand{\dGfo}{\derive_{\mbox{{\sf\scriptsize Gfo}}}}
\newcommand{\dGqvecut}{\derive_{\mbox{{\sf\scriptsize Gqve+cut}}}}
\newcommand{\dGfoextcut}{\derive_{\mbox{{\sf\scriptsize Gfoext+cut}}}}
\newcommand{\dGfocut}{\derive_{\mbox{{\sf\scriptsize Gfo+cut}}}}


\newcommand{\quantifier}{{\sf Q}}
\newcommand{\propvars}{{\cal PV}}

\newcommand{\seqsign}{\vdash}
\newcommand{\falsum}{\bot}
\newcommand{\verum}{\top}
\newcommand{\ir}[2]{{#1}\protect\mbox{}}

\newcommand{\oc}[1]{{\mathfrak #1}} 
\newcommand{\aocc}[1]{\mbox{occ}}

\newcommand{\embed}[1]{\lceil #1 \rceil}
\newcommand{\embedstar}[1]{\lceil #1 \rceil^*}

\newcommand{\dom}[1]{\ensuremath\mathit{dom}(#1)}
\newcommand{\range}[1]{\ensuremath\mathit{rg}(#1)}

\newcommand{\sequence}[1]{\overline{#1}}

\newcommand{\complassign}{\ensuremath{\veebar}}
\newcommand{\is}{\ensuremath{\backslash}}

\newcommand{\restrict}[1]{\ensuremath{[#1]}}

\newcommand{\efcts}[3]{f_{#1}^{{#2}, {#3}}}
\newcommand{\efct}[4]{\efcts{#1}{#2}{#3}\mbox{}(#4)}
\newcommand{\oefcts}[2]{\bar{f}^{{#1}, {#2}}}
\newcommand{\oefct}[3]{\oefcts{#1}{#2}\mbox{}(#3)}

\newcommand{\caA}{{\cal A}}
\newcommand{\caB}{{\cal B}}
\newcommand{\caC}{{\cal C}}
\newcommand{\caD}{{\cal D}}
\newcommand{\caQ}{{\cal Q}}
\newcommand{\caT}{{\cal T}}
\newcommand{\caU}{{\cal U}}

\newcommand{\impl}{\rightarrow}
\newcommand{\lequiv}{\leftrightarrow}
\newcommand{\xor}{\oplus}

\newcommand{\lc}[1]{\mathit{lc}(#1)}

\newcommand{\fv}[1]{\mathit{freevars}(#1)}

\newcommand{\length}[1]{\mathit{l}(#1)}
\newcommand{\size}[1]{\mathit{size}(#1)}

\newcommand{\dep}[1]{\mathit{dep}(#1)}

\newcommand{\var}[1]{\mathit{var}(#1)}



\newcommand{\hkb}{\ensuremath{\Psi}}
\newcommand{\hkbt}[1]{\ensuremath{\hkb_{#1}}}

\newcommand{\QBFtoPL}[3]{\llbracket\,#1\,\rrbracket_{#2}^{#3}}
\newcommand{\QBFtoPLr}[3]{\llbracket\,#1\,\rrbracket_{#2r}^{#3}}
\newcommand{\SkQBFtoPL}[3]{\mathit{Sk}\llbracket\,#1\,\rrbracket_{#2}^{#3}}
\newcommand{\SkQBFtoPLr}[3]{\mathit{Sk}\llbracket\,#1\,\rrbracket_{#2r}^{#3}}
\newcommand{\EPRQBFtoPL}[3]{\mathit{EPR}\llbracket\,#1\,\rrbracket_{#2}^{#3}}
\newcommand{\EPRQBFtoPLr}[3]{\mathit{EPR}\llbracket\,#1\,\rrbracket_{#2r}^{#3}}


\newcommand{\level}[1]{{\mathit lv(#1)}}

\newcommand{\PHPText}{CPHP}
\newcommand{\PHPTextp}{DPHP}
\newcommand{\TPHPText}{TPHP}
\newcommand{\TPHPTextp}{TPHP}
\newcommand{\PHP}[1]{\mbox{}}
\newcommand{\PHPp}[1]{\mbox{}}
\newcommand{\TPHP}[1]{\mbox{}}
\newcommand{\TPHPp}[1]{\mbox{}}
\newcommand{\PHPVar}[2]{\mbox{}}
\newcommand{\PHPpVar}[2]{\mbox{}}
\newcommand{\TPHPVar}[2]{\mbox{}}
\newcommand{\TPHPpVar}[2]{\mbox{}}

\renewcommand{\qed}{\hfill\ensuremath{\square}}

\newcommand{\card}[1]{\left\vert{#1}\right\vert}

\allowdisplaybreaks

\newcommand{\THROWIT}[1]{}



\begin{document}

\maketitle
 
\begin{abstract}
Quantified Boolean formulas (QBFs) generalize propositional formulas
by admitting quantifications over propositional variables.  QBFs can
be viewed as (restricted) formulas of first-order predicate logic and
easy translations of QBFs into first-order formulas exist.  We analyze
different translations and show that first-order resolution combined
with such translations can polynomially simulate well-known deduction
concepts for QBFs. Furthermore, we extend QBF calculi by the
possibility to instantiate a universal variable by an existential
variable of smaller level. Combining such an enhanced calculus with
the propositional extension rule results in a calculus with a
universal quantifier rule which essentially introduces propositional
formulas for universal variables. In this way, one can mimic a very
general quantifier rule known from sequent 
systems.
\end{abstract}

\section{Introduction}\label{sec:intro}


Quantified Boolean formulas (QBFs) generalize propositional formulas
by admitting quantifications over propositional variables.  QBFs can
be viewed in two different ways, namely (i) as a generalization of
propositional logic and (ii) as a restriction of first-order predicate
logic (where we interpret over a two element domain). A number of
calculi are available for QBFs: the ones based on variants of
resolution for QBFs
\cite{DBLP:journals/iandc/BuningKF95,DBLP:conf/cp/Gelder12,DBLP:journals/fmsd/BalabanovJ12,BWJ:SAT14},
the ones based on instantiating universal variables with truth
constants combined with  propositional resolution and an additional
instantiation rule \cite{DBLP:conf/mfcs/BeyersdorffCJ14}, and
different sequent systems
\cite{DBLP:journals/aml/CookM05,Krajicek:1995,ESW-cj-2009,DBLP:conf/sat/Egly12}.

In all these calculi (except the latter ones from
\cite{DBLP:journals/aml/CookM05,Krajicek:1995,DBLP:conf/sat/Egly12}),
the possibility to instantiate a given formula is limited. In purely
resolution-based calculi, formulas (or more precisely universal
variables) are never instantiated. In instantiation-based calculi,
instantiation is restricted to truth constants. In contrast, sequent
systems possess flexible quantifier rules, and (existential) variables
as well as (propositional) formulas can be used for instantiation with
tremendous speed-ups in proof complexity. This motivates why we are
interested in strengthening instantiation techniques for
instantiation-based calculi.

We allow to replace (some) universal variables  not only by truth
constants but by existential variables left of  in the quantifier
prefix. This approach mimics the effect of quantifier rules
introducing atoms in sequent calculi from \cite{DBLP:conf/sat/Egly12}.
We add a propositional extension principle (known from extended
resolution \cite{Tseitin:1968}), which enables the introduction of
propositional formulas for universal variables via extension variables
(or names for the formula).  Contrary to \cite{DBLP:conf/sat/Egly12},
where we proposed propositional extensions of the form  which can be eliminated if the cut rule is available in
the sequent calculus, such an elimination is not possible here for
which reason we have to use (classical) extensions.

\smallskip
\noindent
\emph{Contributions.}
\vspace*{-0.5em}
\begin{enumerate}
\item We consider different translations from QBFs to first-order
  logic \cite{DBLP:conf/cade/SeidlLB12} and provide a
  proof-theoretical analysis of the translation in combination with
  first-order resolution (\Rfo). We exponentially separate two
  variants of the translation in Theorem~\ref{thm:EPR-notpsim-SK}.

\item We show that such combinations can polynomially simulate
  Q-resolution with resolution over existential and universal
  variables (\qures{} \cite{DBLP:conf/cp/Gelder12}, 
  Theorem~\ref{thm:R1-psim-QUres}), Q-resolution (\qres{}
  \cite{DBLP:journals/iandc/BuningKF95}, 
  Corollary~\ref{cor:Rfo-psim-qres}) and the instantiation-based
  calculus \IRcalc{} \cite{DBLP:conf/mfcs/BeyersdorffCJ14}
  (Theorem~\ref{Rfo-psim-IRcalc},
  Corollary~\ref{cor:Rfo-EPR-psim-IRcalc}). The latter simulation
  provides a soundness proof for \IRcalc{} independent from strategy
  extraction.

\item We show in Theorem~\ref{thm:usual-calculi-npsim-Rfo} that
  neither \qres{} nor \qures, the long-distance Q-resolution variants
  \ldqres, \ldqures, \ldqupres{}
  \cite{DBLP:conf/iccad/ZhangM02,DBLP:journals/fmsd/BalabanovJ12,BWJ:SAT14},
  different in\-stan\-tiation-based calculi
  \cite{DBLP:conf/mfcs/BeyersdorffCJ14} nor \qdres{}
  \cite{SlivovskySzeider-SAT14} can polynomially simulate \Rfo{} with
  one of the considered translations.

\item We generalize \IRcalc{} by the possibility to instantiate
  universal variables not only with truth constants but also with
  existential variables (similar to the corresponding quantifier rule
  in \cite{DBLP:conf/sat/Egly12}). We show in
  Proposition~\ref{prop:IRcalcPM-npsim-IRcalcPMSubst} that this
  generalized calculus is actually stronger than the original one.

\item We combine generalized \IRcalc{} by a propositional extension
  rule \cite{Tseitin:1968,BCJ-AAAI-WS16}
  essentially enabling the introduction of Boolean functions (instead
  of atoms and truth constants) for universal variables.

\end{enumerate}


\noindent
\emph{Structure.}  In Sect.~\ref{sec:prel} we introduce necessary
definitions and notations. In Sect.~\ref{sec:diff-trans} different
translations from QBFs to (restrictions of) first-order logic
\cite{DBLP:conf/cade/SeidlLB12} are reconsidered. In
Sect.~\ref{sec:res-calculi} different calculi based on (variants of)
the resolution calculus are described. Here, we introduce our calculi
generalized from \IRcalc. In Sect.~\ref{sec:poly-sim} we present our
results on polynomial simulations between considered calculi and in
Sect.~\ref{sec:exp-sep} we provide exponential separations. In the
last section we conclude and discuss future research possibilities.

\section{Preliminaries}\label{sec:prel}


We assume familiarity with the syntax and semantics of propositional
logic, QBFs and first-order logic (see, e.g.,
\cite{Leitsch-resolution1997} for an introduction). We recapitulate
some notions and notations which are important for the rest of the
paper.

We consider a propositional language based on a set  of
Boolean variables and truth constants  (true) and 
(false), both of which are not in . A variable or a truth
constant is called \emph{atomic} and connectives are from .
A \emph{literal} is a variable or its negation.  A \emph{clause} is a
disjunction of literals, but sometimes we consider it as a set of
literals. \emph{Tautological clauses} contain a variable and its
negation and the \emph{empty clause} is denoted by .
Propositional formulas are denoted by capital Latin letters like  possibly annotated with subscripts, superscripts or primes.

We extend the propositional language by Boolean quantifiers.
Universal () and existential () quantification
is allowed within a QBF.  The superscript  is used to distinguish
Boolean quantifiers from first-order quantifiers introduced later.
QBFs are denoted by Greek letters.  Observe that we allow non-prenex
formulas, i.e., quantifiers may occur deeply in a QBF.
An example for a non-prenex QBF is
, where , ,  and  are variables.  Moreover, free
variables (like ) are allowed, i.e., there might be occurrences of
variables in the formula for which we have no quantification. Formulas
without free variables are called \emph{closed}; otherwise they are
called \emph{open}. The \emph{universal} (\emph{existential}) closure
of  is 
(), for which we often
write  () if
 is the set of all free variables in
.  A formula in \emph{prenex conjunctive normal form} (PCNF)
has the form , where  is the \emph{quantifier prefix},  and  is the (propositional) \emph{matrix} which is in CNF.
Often we write a QBF as  ( for all  and the elements of  are pairwise disjoint). We define the \emph{level of a
  literal }, , as the index  such that the
variable of  occurs in .  The \emph{logical complexity} of a
formula , , is the number of occurrences of
connectives and quantifiers.

We use a first-order language consisting of (objects) {\em variables},
\emph{function symbols} (FSs), \emph{predicate symbols} (PSs),
together with the truth constants and connectives mentioned above.
Quantifiers  and  bind object variables.  \emph{
  Terms} and \emph{formulas} are defined according to the usual
formation rules.  We identify -ary PSs with
propositional atoms, and -ary FSs with
\emph{constants}. Clauses, tautological clauses and the empty clause
are defined as in the propositional case.

Let  be the set of first-order variables and  be the set of
terms.  A \emph{substitution} is a mapping  of type
 such that  only for finitely many
variables .  We represent  by a finite set of the form
.  The
\emph{domain} of 
, , is the set
. The \emph{range} of ,
, is the set . We call  a \emph{variable substitution} if
.  The \emph{empty} substitution
 is denoted by . We often write substitutions
post-fix, e.g., we use  instead of .
Algebraically, substitutions define a monoid with  being the
neutral element under the usual composition of substitutions.

Substitutions are extended to terms and formulas in the usual way,
e.g., ,
, and , where 
is an -place FS,  is an -place PS,  are
terms,  and  are (quantifier-free) formulas and  is a
binary connective.  For substitutions  and ,  is
\emph{more general than}  if there is a substitution  such
that .
A substitution  is called a \emph{permutation} if  is
one-one and a variable substitution. A permutation  is called
a \emph{renaming} (substitution) of an expression  (i.e.,  is a
term or a quantifier-free formula) if , where  is the set of all variables occurring in .
For an expression ,  is a \emph{variant} of  provided
 is a renaming substitution.

Let  be a non-empty set of expressions. A
substitution  is called a \emph{unifier of } if
. Unifier  is
called \emph{most general unifier} (mgu), if for every unifier 
of ,  is more general than .

Let  and  be two proof systems.  
\emph{polynomially simulates} (p-simulates)  if there is a
polynomial  such that, for every natural number  and every
formula , the following holds. If there is a proof of
 in  of size , then there is a proof of  (or
a suitable translation of it) in  whose size is less than .

\section{Different translations of QBFs to first-order logic}
\label{sec:diff-trans}


We introduce different translations of (closed) QBFs to (closed)
formulas in (restrictions of) first-order logic.  We start with the
basic translation from \cite{DBLP:conf/cade/SeidlLB12} in
Fig.~\ref{fig:translation1}.  Obviously, the QBF  and the
first-order formula  enjoy a very similar
structure. Especially the variable dependencies expressed by the
quantifier prefix are exactly the same.

\begin{figure}[t]
\begin{tabular}{ccccc}
 & \hspace{1em} &
  & \hspace{1em} &
       
\
\sigma = \{ a \backslash f_a(\dep{a}) \mid \text{for all existential variables
   in }\}

  \text{ is satisfiable} & \text{\quad iff\/ \quad} & 
  \text{ is satisfiable.} 

\prfbyaxiom{\Axiom}{\{e^{\restrict{\sigma}} \mid e \in C,
\text{ is existential}\}}
\label{eqn:completion}
\sigma(x) = 
\begin{cases}
\mu(x)  & \text{if };\\
\tau(x) & \text{if  and }.
\end{cases}

\prfbyaxiom{\Axiom}{\{e^{\restrict{\sigma}} \mid e \in C\sigma_v,
\text{ is existential}\}}

\caQ_1\exists e \caQ_2 \forall x \caQ_3 \, \varphi(e,x) \, \impl \, 
\caQ_1\exists e \caQ_2 \caQ_3 \, \varphi(e,e).

\prfbyaxiom{\Axiom}{\{e^{\restrict{\sigma}} \mid e \in C\sigma_v,
\text{ is existential}\}}

\big\{x_1\is s_1\mu, \ldots , x_k \is s_k\mu, 
y_1\is t_1, \ldots , y_l\is t_l \big\} 

\big\{(\neg) p(f_e(\sequence{X}_e)) \sigma \mid (\neg)
e^{\restrict{\sigma}} \in C \quad \text{and} \quad 
p(f_e(\sequence{X}_e))\cong e \big\}, 

D_i = \{p(f_e(\sequence{X}_e)) \sigma\} \cup D_i' 
\qquad  \text{and} \qquad  
D_j =  \{\neg p(f_e(\sequence{X}_e)) \sigma\} \cup D_j'
\label{eqn:Phi_n}
\exists^b X_n \forall^b Y_n \exists^b Z_n
\big( \TPHPpVar{n}{Y_n,Z_n}  \land \PHPVar{n}{X_n} \big)\enspace .

  \nonumber
  \bigg(\bigwedge_{i=1}^{n+1} \big(\bigvee_{j=1}^{n} x_{i,j} \big) \bigg) \land 
  \bigg(\bigwedge_{j=1}^{n} \bigwedge_{1\leq i_1<i_2\leq n+1} 
  (\neg x_{i_1,j} \lor \neg x_{i_2,j})\bigg)\enspace .

\label{eqn:varset2}
z_{1,2,j}, \, \ldots \, , z_{1,n+1,j}, \, z_{2,3,j}, \, \ldots \, , 
z_{2,n+1,j}, \, \ldots \, , z_{n,n+1,j}\enspace .

\nonumber
  \bigwedge_{i=1}^{n+1} \bigwedge_{j=1}^{n} (z_{i,0,0} \lor \neg y_{i,j})
\enspace . 

& &  
\bigwedge_{j=1}^{n} \bigwedge_{1\leq i_1<i_2\leq n+1} 
\big((z_{i_1,i_2,j} \lor y_{i_1,j}) \land
  (z_{i_1,i_2,j} \lor y_{i_2,j})\big)\enspace .
\label{eqn:Omega_n}
\forall^b Y_n \exists^b Z_n \exists^b X_n \big( \TPHPpVar{n}{Y_n,Z_n}
\land \PHPVar{n}{X_n} \big)

\overline{\PHPVar{n}{X_n}} &\colon 
  \bigg(\bigwedge_{i=1}^{n+1} \big(\bigvee_{j=1}^{n} 
  p(f_{x_{i,j}}(Y_n) \big)  \bigg)  \land \\
&  \qquad\quad
  \bigg(\bigwedge_{j=1}^{n} \bigwedge_{1\leq i_1<i_2\leq n+1} 
  (\neg p(f_{x_{i_1,j}}(Y_n)) \lor \neg p(f_{x_{i_2,j}}(Y_n)))\bigg)\enspace .
\\
\overline{D_n^{Z_n}} 
& \colon 
\bigvee_{z\in Z_n} \, \neg p(f_z(Y_n))
\\
\qquad\qquad 
\overline{P_n^{Y_n,Z_n}}
& \colon 
\bigwedge_{i=1}^{n+1} \bigwedge_{j=1}^{n} (p(f_{z_{i,0,0}}(Y_n)) \lor 
\neg p(y_{i,j}))
\\
\overline{Q_n^{Y_n,Z_n}}
& \colon 
\bigwedge_{j=1}^{n} \bigwedge_{1\leq i_1<i_2\leq n+1} 
\big((p(f_{z_{i_1,i_2,j}}(Y_n)) \lor p(y_{i_1,j})) \land \\
& \hspace*{10em}
  (p(f_{z_{i_1,i_2,j}}(Y_n)) \lor p(y_{i_2,j}))\big)\enspace .

\begin{array}{lclclclcl}
C_0     & \colon & \overline{d}_0 & \hspace{0.5em} & 
C_1     & \colon & d_0 \lor \overline{d}_1 \lor \overline{e}_1 \\
C_{2j}   & \colon & d_j \lor \overline{x}_j \lor \overline{d}_{j+1} 
\lor \overline{e}_{j+1} & & 
C_{2j+1} & \colon & e_j \lor x_j \lor \overline{d}_{j+1} 
\lor \overline{e}_{j+1}
& \hspace{0.5em} & j=1,\ldots , t-1\\
C_{2t}   & \colon & d_t \lor \overline{x}_{t} \lor 
\overline{f}_{1}\lor \cdots  \lor \overline{f}_{t}
& &  
C_{2t+1} & \colon & e_t \lor x_{t} \lor \overline{f}_{1}\lor 
\cdots  \lor \overline{f}_{t}\\
B_{2j}  & \colon & \overline{x}_{j+1} \lor f_{j+1} & & 
B_{2j+1} & \colon & x_{j+1} \lor f_{j+1} & & j=0, \ldots , t-1
\end{array}

\widetilde{D}_i \lor \widetilde{D}_j  
& = & 
\widetilde{E}_i\mu\pi\sigma_1''
\lor \widetilde{E}_j\sigma_2
\, \, = \, \, (\widetilde{E}_i\mu\pi \lor \widetilde{E}_j)\sigma
\{\mu(u) \backslash \sigma_1(u) \mid \text{for all }\} \cup \{v\backslash \sigma_2(v) \mid \text{for
  all }\}
 by deleting all elements of the form .  Observe that
 and .
Therefore .

\scsubcase{4}{2}:  is a constant.  Similar to \scsubcase{4}{1}
but with an empty mgu .

The clause  from both subcases is non-tautological by the
same reason as in \sccase{3}.


\medskip
\sccase{5}:  is a Q-resolvent of  and  () upon the universal variable . Similar to \scsubcase{4}{1}.
\qed
\end{proof}

\treeRefAtomicFct*

\begin{proof}[sketch]
Take  and derive
.
The first clause is derived by a resolution step between  and
. Then we derive 
from  and  and
 as follows.
Resolve  and ,
obtain  and factor it to get . Next factor  and get . Resolve the latter
with  and factor the resolvent. We get

Each of the  clauses has at most  literals. For , we have
a similar deduction but with at most  literals per clause. We
obtain  which can be
resolved by the  obtained from  and . Finally, it is easy to check that the refutation has tree
structure and is of size polynomial in .
\qed
\end{proof}


\end{document}
