\documentclass{article} \usepackage{multirow}
\usepackage{wrapfig}
\usepackage{amssymb}
\usepackage{iclr2020_conference,times}
\usepackage{pifont}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{xcolor}


\newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}




\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\Tabref#1{Table~\ref{#1}}

\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}

\def\Apref#1{Appendix~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}

\iclrfinalcopy
\title{Scale-Equivariant Steerable Networks}



\makeatletter
\newcommand{\specificthanks}[1]{\@fnsymbol{#1}}\makeatother

\makeatletter
\def\blfootnote{\gdef\@thefnmark{}\@footnotetext}
\makeatother

\author{Ivan Sosnovik\thanks{Correspondence to \texttt{i.sosnovik@uva.nl}} , \,
Micha\l{} Szmaja\thanks{Work was done when the author had an internship at the UvA-Bosch Delta Lab} , \,
Arnold Smeulders \\
UvA-Bosch Delta Lab \\
University of Amsterdam 
}


\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}


\maketitle

\begin{abstract}
    The effectiveness of Convolutional Neural Networks (CNNs) has been substantially 
    attributed to their built-in property of translation equivariance. 
    However, CNNs do not have embedded mechanisms to handle other types of 
    transformations. In this work, we pay attention to scale changes, 
    which regularly appear in various tasks due to the changing distances 
    between the objects and the camera. 
    First, we introduce the general theory for building scale-equivariant 
    convolutional networks with steerable filters. We develop 
    scale-convolution and generalize other common blocks to be scale-equivariant. 
    We demonstrate the computational efficiency and 
    numerical stability of the proposed method. We compare the proposed models
    to the previously developed methods for scale equivariance and local 
    scale invariance. We demonstrate state-of-the-art results on the MNIST-scale dataset 
    and on the STL-10 dataset in the supervised learning setting.
    \blfootnote{Source code is available at \url{http://github.com/isosnovik/sesn}}
\end{abstract}
\section{Introduction}
\label{sec:intro}


Scale transformations occur in many image and video analysis tasks. 
They are a natural consequence of the variable distances among objects, or between objects and the camera. Such transformations result in significant changes in the input space which are often difficult for models to handle appropriately without careful consideration. At a high level, there are two modeling paradigms which allow a model to deal with scale changes: models can be endowed with an internal notion of scale and transform their predictions accordingly, or instead, models can be designed to be specifically invariant to scale changes. In image classification, when scale changes are commonly a factor of 2, it is often sufficient to make class prediction independent of scale. However, in tasks such as image segmentation, visual tracking, or object detection, scale changes can reach factors of 10 or more. In these cases, it is intuitive that the ideal prediction should scale proportionally to the input. For example, the segmentation map of a nearby pedestrian should be easily converted to that of a distant person simply by downscaling. 

Convolutional Neural Networks (CNNs) demonstrate state-of-the-art performance in a wide range of tasks. Yet, despite their built-in translation equivariance, they do not have a particular mechanism for dealing with scale changes. One way to make CNNs account for scale is to train them with data augmentation \citet{barnard1991invariance}. This is, however, suitable only for global transformations. As an alternative, \citet{henriques2017warped} and \citet{tai2019equivariant} use the canonical coordinates of scale transformations to reduce scaling to well-studied translations. While these approaches do allow for scale equivariance, they consequently break translation equivariance. 

Several attempts have thus been made to extend CNNs to both scale and translation symmetry simultaneously. Some works use input or filter resizing to account for scaling in deep layers \citet{xu2014scale, kanazawa2014locally}. Such methods are suboptimal due to the time complexity of tensor resizing and the need for interpolation. In \citet{ghosh2019scale} the authors pre-calculate filters defined on several scales to build scale-invariant networks, while ignoring the important case of scale equivariance. In contrast, \citet{worrall2019deep} employ the theory of semigroup equivariant networks with scale-space as an example; however, this method is only suitable for integer downscale factors and therefore limited.

In this paper we develop a theory of scale-equivariant networks. 
We demonstrate the concept of steerable filter parametrization which allows for 
scaling without the need for tensor resizing. Then we derive scale-equivariant convolution
and demonstrate a fast algorithm for its implementation.
Furthermore, we experiment to determine to what degree the mathematical properties actually hold true. 
Finally, we conduct a set of experiments comparing our model with 
other methods for scale equivariance and local scale invariance.

\vspace{5mm}
The proposed model has the following 
advantages compared to other scale-equivariant models:
\begin{enumerate}
    \item It is equivariant to scale transformations with arbitrary discrete scale factors 
        and is not limited to either integer scales or 
        scales tailored by the image pixel grid.
    \item It does not rely on any image resampling techniques during training, and therefore, 
        produces deep scale-equivariant representations free of any interpolation artifacts.
    \item The algorithm is based on the combination of 
        tensor expansion and 2-dimensional convolution, and demonstrates the same 
        computation time as the general CNN with a  comparable filter bank.
\end{enumerate} \section{Preliminaries}
\label{sec:prelim}
Before we move into scale-equivariant mappings, we discuss some aspects of equivariance, 
scaling transformations, symmetry groups, and the functions defined on them.
For simplicity, in this section, we consider only 1-dimensional functions. 
The generalization to higher-dimensional cases is straightforward. 


\textbf{Equivariance}
Let us consider some mapping $g$. It is
equivariant under $L_\theta$ if and only if 
there exists $L'_\theta$ such that 
$g \circ L_\theta = L'_\theta \circ g$. In case 
$L'_\theta$ is the identity mapping, the function $g$ is invariant. 

In this paper we consider scaling transformations. In order to guarantee the equivariance 
of the predictions to such transformations, and to improve the performance of the model, we seek to incorporate this property directly inside CNNs.

\textbf{Scaling}
Given a function $f: \mathbb{R}\rightarrow\mathbb{R}$, a scale transformation is defined as follows:
\begin{equation}
    \label{eq:scale_transformation}
    L_s[f](x) = f(s^{-1}x), \quad \forall s > 0
\end{equation}

We refer to cases with $s>1$ as \textit{upscale} and to cases with $s<1$ as \textit{downscale}. 
If we convolve the downscaled function with an arbitrary filter $\psi$ and 
perform a simple change of variables inside the integral, we get the following property:
\begin{equation}
    \label{eq:scale_prop1}
    \begin{split}
        [L_s[f] \star \psi](x) 
        &= \int_{\mathbb{R}} L_s[f](x') \psi(x'-x) dx' = \int_{\mathbb{R}} f(s^{-1}x') \psi(x'-x) dx'\\
        &= s \int_{\mathbb{R}} f(s^{-1}x') \psi(s(s^{-1}x'-s^{-1}x)) d(s^{-1}x') 
        = s L_s[ f \star L_{s^{-1}}[\psi]](x)
    \end{split}
\end{equation}

In other words, \textit{convolution of the downscaled function with a filter can 
be expressed through a convolution of the function 
with the correspondingly 
upscaled filter where downscaling is performed afterwards}.
\Eqref{eq:scale_prop1} shows us that the standard convolution is not scale-equivariant.

\textbf{Steerable Filters}
In order to make computations simpler, we reparametrize 
$\psi_\sigma(x) = \sigma^{-1} \psi(\sigma^{-1} x)$, which has the following property:
\begin{equation}
    \label{eq:steerable_filter}
    L_{s^{-1}}[\psi_\sigma](x) = \psi_{\sigma}(s x) = s^{-1} \psi_{s^{-1}\sigma}(x)
\end{equation}

It gives a shorter version of \Eqref{eq:scale_prop1}:
\begin{equation}
    \label{eq:scale_prop2}
    L_s[f] \star \psi_\sigma = L_s[f \star \psi_{s^{-1}\sigma}] 
\end{equation}

We will refer to such a parameterization of filters as \textit{Steerable Filters} because
the scaling of these filters is the transformation of its parameters. Note that 
we may construct steerable filters from any function. This has the important consequence 
that it does not restrict our approach. Rather it will make 
the analysis easier for discrete data.
Moreover, note that any linear combination of steerable filters is still steerable.


\textbf{Scale-Translation Group}
All possible scales form the scaling group $S$. Here we consider the discrete scale group, i.e.
scales of the form $\dots a^{-1}, a^{-1}, 1, a, a^2, \dots$ with base $a$ as a parameter of our method.
Analysis of this group by itself breaks the translation equivariance of CNNs. 
Thus we seek to incorporate scale and translation symmetries into CNNs, 
and, therefore consider the Scale-Translation Group $H$. It is a semidirect product
of the scaling group $S$ and the group of translations $T \cong \mathbb{R}$. In other words:
$H = \{ (s, t) | s \in S, t \in T \}$. 
For multiplication of group elements, we have
$(s_2, t_2) \cdot (s_1, t_1) = (s_2 s_1, s_2 t_1 + t_2)$ and for the inverse 
$(s_2, t_2)^{-1} \cdot (s_1, t_1) = (s_2^{-1} s_1, s_2^{-1} (t_1 - t_2))$. 
Additionally, for the corresponding scaling and translation transformations, we have
$L_{st} = L_s L_t \neq L_t L_s $,
which means that the order of the operations matters.

From now on, we will work with functions defined on groups, i.e. mappings $H \rightarrow \mathbb{R}$.
Note, that simple function $f: \mathbb{R}\rightarrow \mathbb{R}$ may be considered as  
a function on $H$ with constant value along the $S$ axis. Therefore, \Eqref{eq:scale_prop2} holds true 
for functions on $H$ as well. One thing we should keep in mind is that when we apply $L_s$ 
to functions on $H$ and $\mathbb{R}$ we use different notations. For example
$L_s[f](x') = f(s^{-1}x')$ and 
$L_s[f](s', t')=f((s, 0)^{-1}(s', t'))=f(s^{-1}s', s^{-1}t')$

\textbf{Group-Equivariant Convolution}
Given group $G$ and two functions $f$ and $\psi$ defined on it, 
$G$-equivariant convolution is given by
\begin{equation}
    \label{eq:g_con_def}
    [f \star_G \psi](g) = \int_G f(g') L_{g}[\psi](g') d\mu(g') = \int_G f(g') \psi(g^{-1}g') d\mu(g')
\end{equation}
Here $\mu(g')$ is the Haar measure also known as invariant measure \citet{folland2016course}. For 
$T\cong\mathbb{R}$ we have $d\mu(g')=dg'$.
For discrete groups, the Haar measure is the counting measure, and integration becomes a discrete sum.
This formula tells us that the output of the convolution evaluated at point $g$ is 
the inner product between the function $f$ and the transformed filter $L_g[\psi]$.


 \section{Scale-Equivariant Mappings}
\label{sec:ses_conv}
Now we define the main building blocks 
of scale-equivariant models. 

\textbf{Scale Convolution}
In order to derive scale convolution, we start from group equivariant convolution with $G=H$. We first 
use the property of semidirect product of groups which splits the integral, then choose the appropriate 
Haar measures, and 
finally use the properties of steerable filters.
Given the function $f(s, t)$ and a steerable filter $\psi_\sigma(s, t)$ defined on $H$, 
a scale convolution is given by:
\begin{equation}
    \label{eq:scale_conv_def0}
    \begin{split}
        [f \star_H \psi_\sigma](s, t)
        &= \int_S \int_T f(s', t') L_{st}[\psi_\sigma](s', t') d\mu(s') d\mu(t') \\
        &= \sum_{s'} \int_T f(s', t') \psi_{s\sigma}(s^{-1}s', t'-t) dt' 
        = \sum_{s'}  [f(s', \cdot) \star \psi_{s\sigma}(s^{-1}s', \cdot)](t) 
    \end{split}
\end{equation}

And for the case of $C_\text{in}$ input and $C_\text{out}$ output channels we have:
\begin{equation}
    \label{eq:scale_conv_def}
    [f \star_H \psi_\sigma]_m(s, t)
    = \sum_{n=1}^{C_\text{in}}\sum_{s'}  [f_n(s', \cdot) \star \psi_{n,m,s\sigma}(s^{-1}s', \cdot)](t),
    \quad m=1\dots C_\text{out}
\end{equation}
The proof of the equivariance of this convolution to transformations from $H$ is given in \Apref{sec:appendix_proof}. 

\citet{kondor2018generalization} prove that a feed-forward neural network is 
equivariant to transformations from $G$ if and only if it is constructed from G-equivariant
convolutional layers. Thus \Eqref{eq:scale_conv_def} shows the most general 
form of scale-equivariant layers which allows for 
building scale-equivariant convolutional networks with such choice of $S$. 
We will refer to models using scale-equivariant layers with steerable filters as Scale-Equivariant Steerable Networks, 
or shortly \textit{SESN}\footnote{pronounced `season'}

\textbf{Nonlinearities}
In order to guarantee the equivariance of the network to scale transformations, 
we use scale equivariant nonlinearities. We are free to use simple point-wise nonlinearities.
Indeed, point-wise nonlinearities $\nu$, like ReLU, commute with scaling transformations: 
\begin{equation}
    \label{eq:nonlin}
    \begin{split}
        [\nu \circ L_s[f]](s', x')
        &= \nu(L_s[f](s', x'))
        = \nu(f(s^{-1}s', s^{-1}x'))\\
        &= \nu[f](s^{-1}s', s^{-1}x')
        = [L_s \circ \nu[f]](s', x')
    \end{split}
\end{equation}

\textbf{Pooling}
Until now we did not discuss how to convert an equivariant mapping to invariant one. 
One way to do this is to calculate the invariant measure of the signal. 
In case of translation, such a measure could be the maximum value for example. 

First, we propose the maximum scale projection defined as 
$f(s, x) \rightarrow \max_s f(s, x)$. This transformation projects the function $f$ from $H$ 
to $T$. Therefore, the representation stays equivariant to scaling, but loses all information about the scale itself.

Second, we are free to use spatial max-pooling with a moving window or global max pooling.
Transformation $f(s, x) \rightarrow \max_x f(s, x)$ projects the function $f$ from $H$ 
to $S$. The obtained representation is invariant to scaling in spatial domain, 
however, it stores the information about scale.

Finally, we can combine both of these pooling mechanisms in any order. 
The obtained transformation produces a scale invariant function. It is useful 
to utilize this transformation closer to the end of the network, when the deep representation must be invariant to nuisance input variations, but already has very rich semantic meaning. 




 \section{Implementation}
In this paragraph we discuss an efficient implementation of Scale-Equivariant Steerable Networks.
We illustrate all algorithms in \Figref{fig:kernel_reshape}.
For simplicity we assume that zero padding is applied when it is needed for both the spatial axes and the scale axis. 

\label{sec:implementation}
\textbf{Filter Basis}
A direct implementation of \Eqref{eq:scale_conv_def} is impossible due to several limitations.
First, the infinite number of scales in $S$ calls for a discrete approximation.
We truncate the scale group and limit ourselves to $N_S$ scales
and use discrete translations instead of continuous ones.
Training of SESN involves searching for the optimal filter in functional space which is a problem by itself. 
Rather than solving it directly, 
we choose a complete basis of $N_b$ steerable functions $\Psi =\{\psi_{s^{-1}\sigma,i}\}_{i=1}^{N_b}$
and represent convolutional filter as a linear combination of
basis functions with trainable parameters $w=\{w_i\}_{i=1}^{N_b}$. In other words, we do the following 
substitution in \Eqref{eq:scale_conv_def}: 
$\psi_{\sigma} \rightarrow \kappa = \sum_i w_i \Psi_i$

In our experiments we use a basis of 2D Hermite polynomials with 2D Gaussian envelope, 
as it demonstrates good results. The basis is pre-calculated for all scales and 
fixed. For filters of size $V\times V$, the basis is stored as an array of shape $[N_b, S, V, V]$.
See \Apref{sec:appendix_basis} for more details.

\textbf{Conv $\bm{T\rightarrow H}$}
If the input signal is just a function on $T$ with spatial size $U\times U$, stored as an array of shape 
$[C_\text{in}, U, U]$,
then \Eqref{eq:scale_conv_def} can be simplified. The summation over $S$ degenerates, and the final result 
can be written in the following form:
\begin{equation}
    \label{eq:algoTH}
    \texttt{convTH}(f, w, \Psi) = \texttt{squeeze}(
        \texttt{conv2d}(f,\; 
        \texttt{expand}(w\times \Psi)
        )
    )
\end{equation}

Here $w$ is an array of shape $[C_\text{out}, C_\text{in}, N_b]$. We compute filter $w\times\Psi$
of shape $[C_\text{out}, C_\text{in}, S, V, V]$
and expand it to shape $[C_\text{out}, C_\text{in}S, V, V]$. Then we use standard 2D convolution
to produce the output with $C_\text{out}S$ channels and squeeze it to shape $[C_\text{out}, S, U, U]$.
Note that the output can be viewed as a stack of feature maps, where all the features in each spatial position 
are vectors of $S$ components
instead of being scalars as in standard CNNs. 

\textbf{Conv $\bm{H\rightarrow H}$}
The function on $H$ has a scale axis and therefore there are two options for choosing weights of the convolutional filter. The filter may have just one scale and, therefore, does not capture the correlations between different scales 
of the input function; or, it may have a non-unitary extent $K_S$ in the scale axis and capture the correlation 
between $K_S$ neighboring scales. We refer to the second case as \textit{interscale interaction}. 

It the first case $w$ has shape $[C_\text{out}, C_\text{in}, N_b]$ and \Eqref{eq:scale_conv_def}
degenerates in the same way as before
\begin{equation}
    \label{eq:algoHH}
    \texttt{convHH}(f, w, \Psi) = \texttt{squeeze}(
        \texttt{conv2d}(
        \texttt{expand}(f),\; 
        \texttt{expand}(w\times \Psi)
        )
    )
\end{equation}

We expand $f$ to an array of shape $[C_\text{in} S, U, U]$ and expand $w\times \Psi$
to have shape $[C_\text{out}S, C_\text{in}S, V, V]$. The result of the convolution is then squeezed in the same way as before.

In the case of interscale interaction, $w$ has shape $[C_\text{out}, C_\text{in}, K_S, N_b]$. We iterate over all scales in interaction, shift $f$ for each scale, choose a corresponding part of $w$, and apply $\texttt{convHH}$ to them. We sum the obtained $K_S$ results afterwards.




\begin{figure}[h]
    \begin{center}
        \includegraphics[width=0.9\linewidth]{img/kernel_reshape_2.png}
    \end{center}
    \caption{Left: the way steerable filters are computed using steerable filter basis. 
        Middle and right: a representation of scale-convolution using \Eqref{eq:algoTH} and \Eqref{eq:algoHH}.
        As an example we use input signal $f$ with 3 channels. It has 1 scale on $T$ and $4$ scales on $H$.
        It is convolved with filter $\kappa=w \times \Psi$ without scale interaction, which produces
        the output with 2 channels and 4 scales as well. Here we represent only 
        channels of the signals and the filter. Spatial components are hidden for simplicity.
    }
    \label{fig:kernel_reshape}
\end{figure}
     \section{Related Work}
\label{sec:related}
Various works on group-equivariant convolutional networks have been published recently. 
These works have considered roto-translation groups in 2D \citet{cohen2016group,hoogeboom2018hexaconv,worrall2017harmonic,weiler2019general}
and 3D \cite{worrall2018cubenet,kondor2018n,thomas2018tensor} and rotation equivariant networks in 3D 
\citet{cohen2017convolutional,esteves2018learning,cohen2019gauge}. In \citet{freeman1991design} authors describe the 
algorithm for designing steerable filters for rotations. Rotation steerable filters are used in
\citet{cohen2016steerable,weiler20183d,weiler2018learning} for building equivariant networks. In \citet{jacobsen2017dynamic} the authors build convolutional blocks locally equivariant to arbitrary $k$-parameter Lie group by using a steerable basis. And in \citet{muruganso} the authors discuss the approach for learning steerable filters from data.
To date, the majority of papers on group equivariant networks have considered rotations in 2D and 3D, but have not 
payed attention to scale symmetry. As we have argued above, it is a fundamentally
different case.

Many papers and even conferences have been dedicated to image scale-space --- a concept where the image is analyzed
together with all its downscaled versions. Initially introduced in \citet{iijima1959basic} and later developed
by \citet{witkin1987scale,perona1990scale,lindeberg2013scale} scale space relies on the scale symmetry of images. 
The differential structure of the image \citet{koenderink1984structure} allows one to make a connection 
between image formation mechanisms and the space of solutions of the 2-dimensional heat equation, which 
significantly improved the image analysis models in the pre-deep learning era. 

One of the first works on scale equivariance and local scale invariance in the framework of CNNs 
was proposed by \citet{xu2014scale} named SiCNN.
The authors describe the model with siamese CNNs, where the filters of each instance are rescaled
using interpolation techniques.
This is the simplest case of equivariance where no interaction between different scales is done 
in intermediate layers. In SI-ConvNet by \citet{kanazawa2014locally} the original network is modified such that, 
in each layer, the input is first rescaled, then convolved and rescaled back to the original size. Finally, 
the response with the maximum values is chosen between the scales. Thus, the model is locally scale-invariant.
In \citet{marcos2018scale}, in the SEVF model, the input of the layers is 
rescaled and convolved multiple times to form vector features instead of scalar ones.
The length of the vector 
in each position is the maximum magnitude of the convolution, while the direction of the angle
encodes the scale of the image which gave this response. These scale-equivariant networks 
rely on image rescaling which is quite slow. \citet{worrall2019deep} (DSS) generalize the concept 
of scale-space to deep networks. They use filter dilation to analyze the images on different scales. 
While this approach is as fast as the standard CNN, it is restricted only to integer 
downscale factors $2,4,8\dots$.
In \citet{ghosh2019scale}, while discussing SS-CNN the authors 
use scale-steerable filters to deal with scale changes. The paper does not discuss equivariance, 
which is an important aspect for scale. 

We summarize the information about these models in \Tabref{tab:comparison}.
In contrast to other scale-equivariant models, SESN uses steerable filters which allows for 
fast scale-convolution with no limitation of flexibility. 
With the framework of Scale-Equivariant Convolutional Networks we are 
free to build both equivariant and invariant models
of different kinds. 

\begin{table}[t]
    \begin{center}
    \begin{tabular}{l|cccc}
    \toprule
    Method     & Equivariance & Admissible Scales & Approach          & Interscale  \\ \midrule
    SiCNN      & \cmark       & Grid              & Filter Rescaling  & \xmark                 \\
    SI-ConvNet & \xmark       & Grid              & Input Rescaling   & \xmark                 \\
    SEVF       & \cmark       & Grid              & Input Rescaling   & \cmark                 \\
    DSS        & \cmark       & Integer           & Filter Dilation  & \cmark                 \\
    SS-CNN     & \xmark       & Any               & Steerable Filters & \xmark                 \\ \midrule
    SESN, Ours & \cmark       & Any               & Steerable Filters & \cmark                 \\ \bottomrule
    \end{tabular}
    \end{center}
    \caption{Comparing SESN to SiCNN \citet{xu2014scale}, SI-ConvNet \citet{kanazawa2014locally}, 
    SEVF \citet{marcos2018scale}, DSS \citet{worrall2019deep} and SS-CNN \citet{ghosh2019scale}.
    ``Interscale'' refers to the ability of capturing interscale interactions with kernels of non-unitary scale extent.
    ``Grid'' stands for the scales which generate images which lie exactly on the initial pixel grid. }
    \label{tab:comparison}
\end{table}


 \section{Experiments}
\label{sec:experiments}

\begin{figure}[h]
    \begin{center}
        \includegraphics[width=1.0\linewidth]{img/equi_error_1.png}
    \end{center}
    \caption{Equivariance error $\Delta$ as a function of the number of layers (left), downscaling applied to the input image (middle),
    and as a function of number of scales in interscale interactions (right). The bars indicate standard deviation.}
    \label{fig:equi_error}
\end{figure}

In this section we conduct the experiments and compare various methods for 
working with scale variations in input data.
Alongside SESN, we test local scale invariant SI-ConvNet and SS-CNN, 
scale equivariant SiCNN, SEVF and DSS.
For SEVF, DSS and SS-CNN we use the code provided by authors, 
while for others we reimplement the main buildings blocks.

We provide additional experimental results on time performance of all these methods 
in \Apref{sec:appendix_time}. Due to the algorithm proposed in \Secref{sec:implementation}
SESN allows for training several times faster than other methods which rely on image rescaling.

\subsection{Equivariance error}
We have presented scale-convolution which is equivariant to 
scale transformation and translation for continuous signals. 
While translation equivariance holds 
true even for discretized signals and filters, scale equivariance 
may not be exact. Therefore, before starting any experiments,
we check to which degree the predicted properties of scale-convolution 
hold true. We do so by measuring the difference 
$\Delta = \|[L_s\Phi(f) - \Phi L_s(f)\|_2^2 / \|L_s\Phi(f)\|_2^2$, where 
$\Phi$ is scale-convolution with randomly initialized weights. 

In case of perfect equivariance the difference is equal to zero. 
We calculate the error on randomly sampled images 
from the STL-10 dataset \citet{coates2011analysis}. 
The results are represented in \Figref{fig:equi_error}. 
The networks on the left and on the middle plots do not have interscale interactions. The networks on the middle and on the right plots consist of just one layer. We use $N_S=5, 13, 5$ scales for the networks on the left, the middle, and the right plots respectively.
While discretization introduces some error, it stays very low, 
and is not much higher than 6\% for the networks with 50 layers. 
The difference, however, increases if the input image is downscaled more than 16 times.
Therefore, we are free to use deep networks. However, we 
should pay extra attention to extreme cases where scale changes are of 
very big magnitude. These are quite rare but still appear in practice.
Finally, we see that using SESN with interscale interaction introduces 
extra equivariance error due to the truncation of $S$. We will 
build the networks with either no scale interaction or interaction of 2 scales.

\subsection{MNIST-scale}
\label{sec:mnist_scale}

\begin{table}[t]
    \begin{center}
    \begin{tabular}{l|ccccc}
        \toprule
        Method      & $(28\times28)$     &$(28\times28)\;+$   & $(56\times56)$     & $(56\times56)\;+$  & \# Params \\ 
        \midrule
        CNN         & $2.56\pm0.04$      & $1.96\pm0.07$      & $2.02\pm0.07$      & $1.60\pm0.09$      & 495 K     \\
        SiCNN       & $2.40\pm0.03$      & $1.86\pm0.10$      & $2.02\pm0.14$      & $1.59\pm0.03$      & 497 K     \\
        SI-ConvNet  & $2.40\pm0.12$      & $1.94\pm0.07$      & $1.82\pm0.11$      & $1.59\pm0.10$      & 495 K     \\
        SEVF Scalar & $2.30\pm0.06$      & $1.96\pm0.07$      & $1.87\pm0.09$      & $1.62\pm0.07$      & 494 K     \\
        SEVF Vector & $2.63\pm0.09$      & $2.23\pm0.09$      & $2.12\pm0.13$      & $1.81\pm0.09$      & 475 K     \\
        DSS Scalar  & $2.53\pm0.10$      & $2.04\pm0.08$      & $1.92\pm0.08$      & $1.57\pm0.08$      & 494 K     \\
        DSS Vector  & $2.58\pm0.11$      & $1.95\pm0.07$      & $1.97\pm0.08$      & $1.57\pm0.09$      & 494 K     \\
        SS-CNN      & $2.32\pm0.15$      & $2.10\pm0.15$      & $1.84\pm0.10$      & $1.76\pm0.07$      & 494 K     \\ 
        \midrule
        SESN Scalar & $2.10\pm0.10$ & $1.79\pm0.09$      & $1.74\pm0.09$      & $1.50\pm0.07$      & 495 K     \\
        SESN Vector & $\bm{2.08\pm0.09}$ & $\bm{1.76\pm0.08}$ & $\bm{1.68\pm0.06}$ & $\bm{1.42\pm0.07}$ & 495 K     \\
        \bottomrule  

    \end{tabular}
    \end{center}
    \caption{Classification error of different methods on MNIST-scale dataset, lower is better. 
    In experiment we use image resolution of $28\times28$ and $56\times56$. 
    We test both the regime without data augmentation, and the regime with scaling data augmentation, denoted with ``$+$''. 
    All results are reported as mean $\pm$ std over 6 different fixed realizations of the dataset.
    The best results are \textbf{bold}.}
    \label{tab:mnist_scale_results}
\end{table}

Following \citet{kanazawa2014locally,marcos2018scale,ghosh2019scale} 
we conduct experiments on the MNIST-scale dataset. 
We rescale the images of the MNIST dataset \citet{lecun1998gradient}
to $0.3-1.0$ of the original size and pad them with zeros to retain the initial resolution. 
The scaling factors are sampled uniformly and independently for each image. 
The obtained dataset is then split into 10,000 for training,
2,000 for evaluation and 50,000 for testing. 
We generate 6 different realizations and fix them for all experiments.

As a baseline model we use the model described in \citet{ghosh2019scale},
which currently holds the state-of-the-art result on this dataset. It consists of 
3 convolutional and 2 fully-connected layers. 
Each layer has filters of size $7\times7$. 
We keep the number of trainable parameters almost the same for 
all tested methods. This is achieved by varying the number of channels. For scale equivariant models we add
scale projection at the end of the convolutional block. 

For SiCNN, DSS, SEVF and our model, we additionally train counterparts where after 
each convolution, an extra projection layer is inserted.
Projection layers transform vector features in each spatial position of each channel into scalar ones. All of the layers have now scalar inputs instead of vector inputs. Therefore, we denote these models with ``Scalar''. 
The original models are denoted as ``Vector''. The exact type of projection depends on the way the  
vector features are constructed. For SiCNN, DSS, and SESN, we use maximum pooling along 
the scale dimension, 
while for SEVF, it is a calculation of the $L_2$-norm of the vector. 

All models are trained with the Adam optimizer \citet{kingma2014adam} for 60 epochs with a batch size of 128. 
Initial learning rate is set to $0.01$ and divided by 10 after 20 and 40 epochs. 
We conduct the experiments with 4 different settings. Following the idea discussed 
in \citet{ghosh2019scale}, in addition to the standard setting we train the networks with 
input images upscaled to $56\times56$ using bilinear interpolation. 
This results in all image transformations performed by the network becoming more stable, 
which produces less interpolation artifacts. For both input sizes we conduct the experiments 
without data augmentation 
and with scaling augmentation, which results in 4 setups in total.
We run the experiments on 6 different realizations of MNIST-scale and 
report mean $\pm$ std calculated over these runs.

The obtained results are summarized in \Tabref{tab:mnist_scale_results}. 
The reported errors may differ a bit from the ones in the original paper because of the variations 
in generated datasets and slightly different training procedure. Nevertheless, we try to keep 
our configuration as close as possible to \citet{ghosh2019scale} which currently demonstrated the best 
classification accuracy on MNIST-scale. For example, SS-CNN reports 
error of $1.91\pm0.04$ in \citet{ghosh2019scale} while it has $1.84\pm0.10$ in our experiments.

SESN significantly outperforms other methods in all 4 regimes. ``Scalar''
versions of it already outperform all previous methods, and ``Vector'' versions make the gain even more significant.
The global architectures of all models are the same for all rows, 
which indicates that the way scale convolution is done plays an
important role. 


\subsection{STL-10}

\begin{wraptable}{r}{5.5cm}
        \begin{center}
        \begin{tabular}{l|cc}
        \toprule
        Method      & Error, \%         & \# Params \\ \midrule
        WRN         & $11.48$           & 11.0 M     \\
        SiCNN       & $11.62$           & 11.0 M     \\
        SI-ConvNet  & $12.48$           & 11.0 M     \\
DSS         & $11.28$           & 11.0 M     \\
        SS-CNN      & $25.47$           & 10.8 M     \\ 
        \midrule
        SESN-A        & $10.83$  & 11.0 M     \\
        SESN-B        & $\bm{8.51}$  & 11.0 M     \\
        SESN-C        & $14.08$  & 11.0 M     \\
         \midrule 
        Harm WRN & $9.55$ & 11.0 M \\
        \bottomrule              
        \end{tabular}
        \end{center}
        \caption{Classification error on \\STL-10. The best results are \textbf{bold}.
        We additionally report the current best result achieved by Harm WRN from \citet{ulicny2019harmonic}.}
        \label{tab:stl10}
\end{wraptable} 


In order to evaluate the role of scale equivariance in natural image classification, we
conduct the experiments on STL-10 dataset \citet{coates2011analysis}. 
This dataset consists of 8,000 training and 5,000 testing labeled images. Additionally, it includes 100,000 unlabeled images. The images have a resolution of $96\times96$ pixels and RGB channels.
Labeled images belong to 10 classes such as bird, horse or car.
We use only the labeled subset to demonstrate the performance of the models in the low data regime. 

The dataset is normalized by subtracting the per-channel mean and dividing 
by the per-channel standard deviation.
During training, we augment the dataset by applying 12 pixel zero padding 
and randomly cropping the images to size $96\times96$. Additionally, random horizontal flips with probability $50\%$ 
and Cutout \citet{devries2017improved} with 1 hole of 32 pixels are used.

As a baseline we choose WideResNet \citet{zagoruyko2016wide} with 16 layers and a widening factor of 8.
We set dropout probability to $0.3$ in all blocks. We train SESN-A with just vector features. 
For SESN-B we use maximum scalar projection several times in the intermediate layers, 
and for SESN-C we use interscale interaction. 

All models are trained for 1000 epochs with a batch size of 128. We use SGD optimizer
with Nesterov momentum of $0.9$ and weight decay of $5\cdot10^{-4}$. The initial learning rate is set to $0.1$
and divided by 5 after 300, 400, 600 and 800 epochs. 

The results are summarized in \Tabref{tab:stl10}. We found SEVF training unstable and therefore do not include it in the table.
Pure scale-invariant SI-ConvNet and SS-CNN demonstrate significantly worse results than the baseline. 
We note the importance of equivariance for deep networks.
We also find that SESN-C performs significantly worse than SESN-A and SESN-B due to high equivariance error
caused by interscale interaction. SESN-B significantly improves the results of both WRN and DSS due to the projection between scales. 
The maximum scale projection makes the weights of the next layer to have a maximum receptive field in the space of scales. This is an easy yet effective method for capturing the correlations between different scales.
This experiment shows that scale-equivariance is a very useful inductive bias for natural 
image classification with deep neural networks.

To the best of our knowledge, the proposed method achieves a new state-of-the-art result on the STL-10 dataset in the 
supervised learning setting. The previous lowest error is demonstrated in \citet{ulicny2019harmonic}. 
The authors propose Harm WRN --- a network where the convolutional kernels are represented as a linear combination of 
Discrete Cosine Transform filters.
 \section{Discussion}
\label{sec:discussions}
In this paper, we have presented the theory of Scale-Equivariant Steerable Networks.
We started from the scaling transformation and its application to continuous functions.
We have obtained the exact formula for scale-equivariant mappings and demonstrated how 
it can be implemented for discretized signals. 
We have demonstrated that this approach outperforms other 
methods for scale-equivariant and local scale-invariant CNNs. 
It demonstrated new state-of-the-art 
results on MNIST-scale and on the STL-10 
dataset in the supervised learning setting.

We suppose that the most exciting possible application of SESN is in computer vision for 
autonomous vehicles. Rapidly changing distances between the objects 
cause significant scale variations which makes this well suited for our work.
We especially highlight the direction of siamese visual tracking 
where the equivariance to principle transformations plays an important role.


 
\subsubsection*{Acknowledgments}
We thank Daniel Worrall for insightful discussion, Thomas Andy Keller, Victor Garcia, 
Artem Moskalev and Konrad Groh for valuable comments and feedback.


\bibliography{bib}
\bibliographystyle{iclr2020_conference}

\appendix
\newpage
\section{Proof of Equivariance}
\label{sec:appendix_proof}
Let us first show that scale-convolution defined in \Eqref{eq:scale_conv_def0} is equivariant to translations.

\begin{equation}
    \label{eq:appendix_equivariance_proof_1}
    \begin{split}
        [L_{\hat{t}}[f] \star_H \psi_\sigma](s, t)
        &= \sum_{s'}  [L_{\hat{t}}[f] (s', \cdot) \star \psi_{s\sigma}(s^{-1}s', \cdot)](t) \\
        &= \sum_{s'}  L_{\hat{t}}[f (s', \cdot) \star \psi_{s\sigma}(s^{-1}s', \cdot)](t) \\
        &= L_{\hat{t}}\Big\{\sum_{s'}[f (s', \cdot) \star \psi_{s\sigma}(s^{-1}s', \cdot)]\Big\}(t) \\
        &= L_{\hat{t}}[f \star_H \psi_\sigma](s, t)
    \end{split}
\end{equation}

Now we show that scale convolution is equivariant to scale transformations:
\begin{equation}
    \label{eq:appendix_equivariance_proof_2}
    \begin{split}
        [L_{\hat{s}}[f] \star_H \psi_\sigma](s, t)
        &= \sum_{s'}  [L_{\hat{s}}[f] (s', \cdot) \star \psi_{s\sigma}(s^{-1}s', \cdot)](t) \\
        &= \sum_{s'}  L_{\hat{s}}[f (\hat{s}^{-1}s', \cdot) \star \psi_{\hat{s}^{-1}s\sigma}(s^{-1}s', \cdot)](t) \\
        &= \sum_{s''}[f (s'', \cdot) \star \psi_{\hat{s}^{-1}s\sigma}(\hat{s}s^{-1}s'', \cdot)](\hat{s}^{-1}t) \\
        &= [f \star_H \psi_\sigma](\hat{s}^{-1}s, \hat{s}^{-1}t) \\
        &= L_{\hat{s}}[f \star_H \psi_\sigma](s, t)
    \end{split}
\end{equation}

Finally, we can use the property of semidirect product of groups
\begin{equation}
    \label{eq:appendix_equivariance_proof_3}
    \begin{split}
        L_{\hat{s}\hat{t}}[f] \star_H \psi_\sigma
        &= L_{\hat{s}}L_{\hat{t}}[f] \star_H \psi_\sigma
        = L_{\hat{s}}[L_{\hat{t}}[f] \star_H \psi_\sigma]
        = L_{\hat{s}}L_{\hat{t}}[f \star_H \psi_\sigma]
        = L_{\hat{s}\hat{t}}[f \star_H \psi_\sigma]
    \end{split}
\end{equation}

\newpage 
\section{Time Performance}
\label{sec:appendix_time}
We report the average time per epoch of different methods for scale equivariance
and local scale invariance in \Tabref{tab:appendix_time_performance}. 
Experimental setups from \Secref{sec:mnist_scale} are used. 
We used 1 Nvidia GeForce GTX 1080Ti GPU for training the models.

The methods relying on image rescaling techniques during training 
(SiCNN, SI-ConvNet, SEVF) demonstrate significantly worse time performance that 
the ones, using either steerable filters or filter dilation. Additionally, we see 
that our method outperforms SS-CNN by a wide margin. Despite the similar 
filter sizes and comparable number of parameters between SS-CNN and SESN Scalar, the 
second one demonstrates significantly better results due to the algorithm proposed in \Secref{sec:implementation}.
Finally, DSS performs slightly faster in some cases than our method as each convolution involves less FLOPs. Dilated filters 
are sparse, while steerable filters are dense. 

\begin{table}[h]
    \begin{center}
    \begin{tabular}{l|cc}
    \toprule
    Method              & $28\times28$, s           & $56\times56$, s \\ 
    \midrule
    CNN                 & $3.8$                     & $3.8$     \\
    SiCNN Scalar        & $13.5$                    & $18.9$    \\
    SiCNN Vector        & $15.3$                    & $22.8$     \\
    SI-ConvNet          & $18.4$                    & $33.1$     \\
    SEVF Scalar         & $21.0$                    & $38.4$     \\
    SEVF Vector         & $25.4$                    & $46.0$     \\
    DSS Scalar          & $3.9$                     & $5.0$     \\
    DSS Vector          & $3.9$                     & $4.8$     \\
    SS-CNN              & $14.8$                    & $16.6$    \\ 
    \midrule
    SESN Scalar         & $3.8$                     & $5.1$     \\
    SESN Vector         & $3.8$                     & $6.8$    \\
    \bottomrule              
    \end{tabular}
    \end{center}
    \caption{Average time per epoch during training on input data with resolution $28\times28$
    and $56\times56$.}
    \label{tab:appendix_time_performance}
\end{table} 


\section{Basis}
\label{sec:appendix_basis}
Assuming that the center of the filter is point $(0, 0)$ in coordinates $(x, y)$, 
we use the filters of the following form:
\begin{equation}
    \psi_\sigma(x, y) = A\frac{1}{\sigma^2}
    H_n\Big(\frac{x}{\sigma}\Big)
    H_m\Big(\frac{y}{\sigma}\Big)
    \exp\Big[ -\frac{x^2 + y^2}{2\sigma^2}\Big]
\end{equation}

Here $A$ is a constant independent on $\sigma$, $H_n$ --- Hermite polynomial of the $n$-th 
order. We iterate over increasing pairs of $n,m$ to generate the required number of functions.



\newpage
\section{Model Configuration}
\subsection{MNIST-scale}
\begin{table}[h]
    \begin{center}
    \begin{tabular}{l|cccc|c}
    \toprule
    Method                & Conv 1 & Conv 2 & Conv 3 & FC 1                 & \multicolumn{1}{c}{\# Scales}              \\ 
    \midrule
    CNN                   & $32$     & $63$     & $95$     & \multirow{8}{*}{256} & $1$                                               \\
    SiCNN                 & $32$     & $63$     & $95$     &                      & $7$        \\
    SI-ConvNet                & $32$     & $63$     & $95$     &                      & $7$        \\
    SEVF Scalar           & $32$     & $63$     & $95$     &                      & $8$     \\
    SEVF Vector           & $23$     & $45$     & $68$     &                      & $8$     \\
    DSS                   & $32$     & $63$     & $95$     &                      & $4$                   \\
    SS-CNN                & $30$     & $60$     & $90$     &                      & $6$                                                \\
    SESN                  & $32$     & $63$     & $95$     &                      & $4$                                              \\       
    \bottomrule                             
    \end{tabular}
    \end{center}
    \caption{Number of channels in convolutional layers, number of units in fully-connected layers 
    and number of scales used by different models in \Secref{sec:mnist_scale}.}
    \label{tab:appendix_arch_mnist}
\end{table}

\subsection{STL-10}
\begin{table}[h]
    \begin{center}
    \begin{tabular}{l|ccc|c}
    \toprule
    Method                & Block 1 & Block 2 & Block 3 & \# Scales              \\ 
    \midrule
    CNN                   & $16$     & $32$     & $64$    & $1$                                               \\
    SiCNN                 & $16$     & $32$     & $64$   & $3$        \\
    SI-ConvNet                & $16$     & $32$     & $64$    & $3$        \\
SEVF            & $11$     & $23$     & $45$   & $3$     \\
    DSS                   & $16$     & $32$     & $64$   & $4$                   \\
    SS-CNN                & $11$     & $22$     & $44$    & $3$                                                \\
    SESN                  & $16$     & $32$     & $64$    & $3$                                              \\       
    \bottomrule                             
    \end{tabular}
    \end{center}
    \caption{Number of channels in convolutional blocks 
    and number of scales used by different models in \Secref{sec:mnist_scale}. 
    We report the number of channels up to the widening factor.}
    \label{tab:appendix_arch_mnist}
\end{table} 
\end{document}
