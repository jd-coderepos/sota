\documentclass{article}

\usepackage{fullpage}
\usepackage{amsmath,amssymb,amsthm,epsfig,graphicx, color}
\usepackage[linesnumbered, boxruled, lined]{algorithm2e}
\usepackage{latexsym, ae, caption}
\usepackage{psfrag}

\newcommand{\lft}{\mbox{\em left}}
\newcommand{\rght}{\mbox{\em right}}
\newcommand{\NP}{NP}
\newcommand{\POL}{P}
\newcommand{\R}{\mathbb{R}}
\newcommand{\RP}{\mathbb{R_+}}
\newcommand{\RR}{\mathbb{R}^2}
\newcommand{\RRn}{\mathbb{R}^n}
\newcommand{\K}{\mathbb{K}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\N}{\mathbb{N}}

\def\fmax{f_{\mathrm{max}}}
\def\bmax{b_{\mathrm{max}}}
\def\falg{f_{\mathrm{alg}}}
\def\fopt{f_{\mathrm{opt}}}
\def\alg{\mathrm{ALG}}

\newtheorem{thm}{Theorem}

\title{Dynamic Defragmentation of Reconfigurable 
Devices\thanks{A  preliminary, considerably shorter extended-abstract version of this paper
appeared in the proceedings of the FPL~08 \cite{fktvakt-nbddr-08}.}}

\author{
S\'andor~P.~Fekete 
\and Tom~Kamphans\footnote{Supported by
DFG grant FE~407/8-2, 8-3, project ``ReCoNodes'',
as part of the Priority Programme 1148, ``Reconfigurable Computing''.}
\and Nils~Schweer
\and Christopher Tessars\footnote{Supported by BMBF grant 03FEPAI2, project ``Advest''.}
\and Jan~C.~van~der~Veen\footnotemark[2]
\and Josef Angermeier\footnote{Supported by DFG grant TE~163/14-2, 14-3,
project ``ReCoNodes'', as part of the Priority Programme 1148,
``Reconfigurable Computing''.}
\and Dirk Koch\footnote{Supported by DFG
grant TE~163/13-2, 13-3, project ``ReCoNets'', as part of the Priority
Programme 1148, ``Reconfigurable Computing''.}
\and J\"urgen Teich}

\date{
  
  Department of Computer Science\\
  Braunschweig University of Technology\\
  Braunschweig, Germany\\
  email: \{s.fekete, t.kamphans, n.schweer,\\
  \ \ \ j.van-der-veen\}@tu-bs.de\
\fopt \leq \alpha \cdot \falg + \beta <
kB \cdot C \cdot ( n \log \bmax )^{1-\varepsilon} + \beta \; ,

\fopt < kB \cdot C \cdot \left[ (5k+4r+1) \log (kB + 1 +
\frac{rB}{2}) \right]^{1-\varepsilon} \hspace{-0.5cm} + \beta \leq
kB + \frac{rB}{2} = f \; ,

\delta \leq \frac{1}{2} - \frac{1}{2} \cdot\frac{\max_{i=1,\ldots,n}\{m_i\}}
{\ell}
\label{eq:lowden2}

\sum_{i=1}^k f_i \geq \frac{l}{2} + \frac{1}{2}\cdot
\max_{i=1,\ldots,n}\{m_i\} \label{eq:lowden3}

\delta < \frac{1}{2} \;\; \mbox{and therefore} \;\; \sum_{i=1}^n m_i
< \sum_{j=1}^k f_j \label{eq:lowden4}

\frac{l}{2} + \frac{1}{2} m^\star \stackrel{(\ref{eq:lowden3})}{\leq} \sum_{i=1}^k f_i
< \sum_{i=1}^n m_i + f_k
\stackrel{(\ref{eq:lowden2})}{\leq}
\frac{l}{2} -
\frac{1}{2}m^\star + f_k  
implying
.
\end{proof}

\section{A Quadratic Lower Bound}
As a consequence of the hardness and inapproximability results we
focus on developing
heuristic approaches for the MDP. 
In this section, we bound
the number of steps needed by any algorithm that constructs a
maximum free interval, even in the homogeneous version. 
In the next sections, we state a heuristic and give
experimental results.

\begin{thm}
There is an instance of the maximum defragmentation problem such
that any algorithm needs at least  steps to solve it.
\end{thm}

\begin{proof}
We construct the instance in the following way. For an even number ,
we place  modules,
indexed from left to right by . 
The sizes of the modules are 
for .  has a free interval of size
 to its left and  has a free interval of size
 to its right.
In addition, every pair of consecutive modules is separated by a
free interval of size one, except for the pair  and
, which is separated by a distance of two. In
this initial configuration we denote the free intervals by
, and their sizes by . 
Fig.~\ref{fig:lbnsquare} shows an example for .

\begin{figure}[ht]
\centering
\begin{picture}(0,0)\includegraphics{lbnsquare.pstex}\end{picture}\setlength{\unitlength}{2072sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(12821,1008)(119,-3265)
\put(2026,-3076){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}8}}}}}
\put(3826,-3076){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}6}}}}}
\put(5176,-3076){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}4}}}}}
\put(3036,-3076){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}1}}}}}
\put(1011,-3076){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}1}}}}}
\put(4611,-3076){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}1}}}}}
\put(6076,-3076){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}2}}}}}
\put(7876,-3076){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}4}}}}}
\put(9226,-3076){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}6}}}}}
\put(6526,-3076){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}2}}}}}
\put(6976,-3076){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}2}}}}}
\put(5741,-3076){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}1}}}}}
\put(7308,-3076){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}1}}}}}
\put(8435,-3076){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}1}}}}}
\put(10002,-3076){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}1}}}}}
\put(11026,-3076){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}8}}}}}
\put(12049,-3076){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}1}}}}}
\put(2026,-2536){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}}}}}}
\put(3826,-2536){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}}}}}}
\put(6076,-2536){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}}}}}}
\put(6931,-2536){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}}}}}}
\put(11026,-2536){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}}}}}}
\put(5176,-2536){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}}}}}}
\put(9181,-2536){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \caption{\label{fig:lbnsquare} The instance for .}
\end{figure}


The following properties of this instance are essential for the rest
of the proof:

\begin{list}{}{}

\item[(i)] The module sizes , , are even.

\item[(ii)]  holds for
any pair ,  (i.e., the total free interval between two
modules of equal size is equal to the modules' sizes).

\item[(iii)] Every module has to be moved at least once (because of
the small free intervals at the left and right end of ).

\item[(iv)] For  , we have
; in particular, this
means that the pair ,  can be
moved only if ,  can be moved.

\end{list}

In the beginning, only the modules  and
 with  can
be moved. Using three moves, a free interval of size four can be
constructed. Note that both modules have to be moved and that there
can be a free interval of size four only if there is exactly one free interval 
between  and . Now we show
by induction for  from  to  that
\begin{list}{}{}

\item[(a)] at least  steps are necessary to make a pair
,  movable after the pair ,
 became movable and

\item[(b)] in the situation in which , 
become movable, there is exactly one free interval between these two
modules.

\end{list}

Both properties clearly hold for  and we assume that
 and  for  became movable (for
the first time) by the last step.

By part (b) of the induction hypothesis, the modules and free intervals
in the area between  and  are currently arranged
in the following order, described from left to right: a free interval 
of size one, a sequence of modules, a free interval of size , a
sequence of modules, and a free interval of size one (see 
Fig.~\ref{fig:lbnsquare2}). The modules in the rest of  are still in
their initial position (otherwise  and  could have
been moved earlier because of (iv)).

\begin{figure}[ht]
\centering
\begin{picture}(0,0)\includegraphics{lbnNoMove.pstex}\end{picture}\setlength{\unitlength}{2072sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(11358,1008)(847,-3265)
\put(9181,-2536){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}}}}}}
\put(3826,-2536){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}}}}}}
\put(11026,-2536){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}}}}}}
\put(3036,-3076){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}1}}}}}
\put(9996,-3076){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}1}}}}}
\put(2026,-2536){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}}}}}}
\put(6571,-3031){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}}}}}}
\put(12016,-2581){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}}}}}}
\put(1126,-2581){\makebox(0,0)[b]{\smash{{\SetFigFont{10}{12.0}{\rmdefault}{\mddefault}{\itdefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} \caption{\label{fig:lbnsquare2} The situation when  and
 can be moved for the first time.}
\end{figure}

Property (b) is a straightforward implication of (ii) and we show
that (a) holds as well. Suppose for a contradiction that 
and  can be made movable without shifting or ``jumping'' a module
 with , i.e., without moving a modules that lies
between  and ). We assume w.l.o.g.\ that  is in
the same sequence as . Thus, the distance from 's left boundary
to the right boundary of  can be calculated as the sum of
the sizes of modules lying on the left side of  plus one. By
(i), this is an odd number. The same holds for the distance from
's right boundary to the left boundary of . Again
using (i), this implies that none of these intervals can completely be
filled with other modules. Hence, by (ii),  and  
can never be moved without moving . There are  modules initially placed between  and
 and each of them has to be moved.

Altogether, this implies a lower bound of
 on
the total number of steps.
\end{proof}

\section{A Heuristic Method}
\label{sec:heuristic}

For runtime defragmentation, we propose a tabu search with a tabu list of length
, see Algorithm~2. In every iteration, all homogeneous modules  are
moved to the left end and to the right end of the free intervals
that are greater than or equal to . All inhomogeneous modules
are moved to any feasible position. Each move is evaluated by a
fitness function that divides the size of the maximal free interval by
the number of free slots. The move yielding the
configuration with the highest fitness is chosen. Ties are broken by
choosing the first one. The resulting configuration is added to the
tabu list.



If the current solution is the best one found so far, it is stored.
The heuristic ends if either a fitness of  (i.e., optimality)
is achieved or  iterations have been performed. As seen above,
there are instances for which  moves are necessary. 
Moreover, we conjecture that the number of necessary moves is 
in . 
\begin{algorithm}[p]\caption{Tabu Search}
\begin{tabbing}
\mbox\qquad\=\qquad\=\qquad\=\qquad\=\kill
{\it counter} := 0;\\
{\it tabulist} := \{\};\\
{\it maxfitness} := 0.0;\\

{\bf while} ({\it counter} ) and ({\it maxfitness} ) {\bf do}\\
\> {\bf foreach} module  in the array {\bf do}\\
\>\> {\it storedfitness} := 0.0\\
\>\> {\bf if}  is homogeneous {\bf then}\\
\>\>\> {\bf foreach} free interval  {\bf do}\\
\>\>\>\> move  to the left end of \\
\>\>\>\> evaluate move\\
\>\>\>\> move  to the right end of \\
\>\>\>\> evaluate move\\
\>\>\>\> move  back to its original position\\
\>\>\> {\bf end foreach}\\
\>\> {\bf else}\\
\>\>\> {\bf foreach} position  for  that is feasible and not blocked by another module {\bf do}\\
\>\>\>\> move  to \\
\>\>\>\> evaluate move\\
\>\>\>\> move  back to its original position\\
\>\>\> {\bf end foreach}\\
\>\> {\bf end if}\\
\>\> {\bf if} {\it storedfitness}  {\it maxfitness} {\bf then}\\
\>\>\> apply {\it storedmove}\\
\>\>\> store {\it storedmove} in {\it tabulist}\\
\>\>\> {\it maxfitness} := {\it storedfitness}\\
\>\>{\bf end if}\\
\> {\bf end foreach}\\
\> {\it counter}++\\
{\bf end while}\\
\\
{\bf Procedure} evaluate move:\\
\> {\bf if} move is not stored in {\it tabulist}\\
\>\> {\it thisfitness}  size of the maximal free interval / number of free slots \\
\>\> {\bf if} {\it thisfitness}  {\it storedfitness} {\bf then}\\
\>\>\> store move in {\it storedmove}\\
\>\>\> {\it storedfitness} := {\it thisfitness}\\
\>\> {\bf end if}\\
\> {\bf end if}
\end{tabbing}
\end{algorithm}

\section{Experimental Results}
\label{sec:experiments}

\subsection{Compacting an FPGA}
We performed a series of experiments for defragmentation based on scenarios of FPGAs with and 
without heterogeneities and different densities (i.e., different ratios of
occupied space compared to unoccupied space). Fig.~\ref{max:cf1} shows the results
for two FPGAs, both having 94
slots. The first FPGA does not contain any heterogeneities, while
the second one is an FPGA with heterogeneities at 
positions 3, 24, 45, 50, 71 and 82. Moreover, we compared our heuristic
to a simple greedy approach that moves every module to the most
promising position (i.e., to the position for which the ratio of
the size of the maximal free interval and 
the size of the total free space is maximal).

Generating the input was done in two steps, depending on the
size of the maximal free interval . In the first step
the module size is chosen with equal probability from the set
\{\}. This ensures that the modules can be
inserted. The exact position is chosen again with equal probability
among all feasible positions. If the interval
occupied by the module contains an heterogeneity, this heterogeneity
is assigned to the corresponding position of the module. The size of
the first module is shrunk by a factor of  in order to ensure
that it can be moved.

For the density ranging from  to  with steps of size
, we performed 100 runs of the tabu search and the greedy strategy 
for each value and
took the average value of the {\em number of free intervals} and
the {\em size of the maximal free interval}. The results are shown
in Fig.~\ref{max:cf1}. The diagrams
show the size of the maximal free interval (top row) of the
array and the number of free spaces (bottom row) 
before and after the defragmentation. In the
array with no heterogeneities (left column),
there is an improvement of up to 40\%.
On the FPGA (right column)
the size of any maximal free interval is limited
to  slots due to the heterogeneities. For a density of less than
, the tabu search achieves this upper bound for almost
all instances. For larger densities, it achieves an improvement of
approximately 35\%.

The change in the number of free intervals before and after
defragmentation is displayed in the right charts of Fig.~\ref{max:cf1}.
In the array with no heterogeneities there is an
increase of 50\%. For the FPGA there is almost no improvement for low densities (less than ) and an improvement of approximately 25\% for larger ones.


\begin{figure*}[p]
 \mbox{}\hfill 
  {\epsfig{figure=PLOT-MAX-CF0a.eps,width=67mm}}
\hfill
  {\epsfig{figure=PLOT-MAX-CF1a.eps,width=67mm}} 
\hfill\mbox{}\\
 \mbox{}\hfill  
{\epsfig{figure=PLOT-NUM-CF0a.eps,width=67mm}}
\hfill
  {\epsfig{figure=PLOT-NUM-CF1a.eps,width=67mm}}
\hfill\mbox{}
\caption{Averages over 100 runs. (Top left)
Size of the maximal free interval before and after
defragmentation, using our heuristic and a simple greedy approach
in an array with no heterogeneities.\newline
(Top right)
Size of the maximal free interval before and after
defragmentation of the FPGA. \newline
(Bottom left)
Number of free intervals before and after defragmentation in an array with no heterogeneities.\newline
(Bottom right)
Number of free intervals before and after defragmentation of
the FPGA.\label{max:cf1}}
\end{figure*}




\subsection{Case Study}
\label{sec:casestudy}

In this section, a case study is given that demonstrates the
efficiency of the proposed techniques and how they can be applied to a
real-world scenario. We assume a dynamically partially
reconfigurable device, whose reconfigurable area is separated into
 columns, also called {\em slots}. Modeling typical FPGAs, some of these slots contain
no logic resources, but a heterogeneities such as
BlockRAMs. This setting is illustrated in Figure~\ref{fig:casestudy_initial1}.

Furthermore, assume that one or multiple applications with a collection of
modules are executed on this device; e.g., these could a video
processing and a number cruncher application whose current state can
rather easily be saved and restored at a different position on the
reconfigurable device with moderate costs. During the execution of the
applications, different modules finish and are removed, while new modules
need to be placed. Thus, the free space on the reconfigurable device
can be scattered over the whole reconfigurable area. This situation is
illustrated in the upper part of Figure~\ref{fig:casestudy_greedy}.

\begin{figure}[p]
\centering
\includegraphics[width=.8\linewidth]{DefragCaseStudy_initial1.eps}
\caption{\label{fig:casestudy_initial1} Initial state in example scenario. The
reconfigurable device consists of  partially reconfigurable, empty slots.
Those containing a heterogeneity, such as BlockRAMs, are marked below with an
``m''.} \end{figure}

\begin{figure}[p]
\centering
\includegraphics[width=.8\linewidth]{DefragCaseStudy_initial2.eps}
\includegraphics[width=.8\linewidth]{DefragCaseStudy_greedy1.eps}
\caption{\label{fig:casestudy_greedy} (Top) Fragmented state in example scenario. Free space is scattered over the whole reconfigurable area. 
(Bottom) Free space after defragmentation with greedy approach.}
\end{figure}

\begin{figure}[p]
\centering
\includegraphics[width=.8\linewidth]{DefragCaseStudy_initial2.eps}
\includegraphics[width=.8\linewidth]{DefragCaseStudy_ts1.eps}
\includegraphics[width=.8\linewidth]{DefragCaseStudy_ts2.eps}
\includegraphics[width=.8\linewidth]{DefragCaseStudy_ts3.eps}
\includegraphics[width=.8\linewidth]{DefragCaseStudy_ts4.eps}
\caption{\label{fig:casestudy_ts} Tabu-search algorithm: defragmentation in four move steps (shown from top to bottom).}
\end{figure}

The fragmented free space on the reconfigurable area is a common,
unavoidable scenario, for which our proposed defragmentation
techniques represent an applicable and efficient solution. Our first
approach, the greedy algorithm, selects in each setting a step that
optimizes the resulting maximal contiguous free space. Based on the
state of the example in the upper part of Figure~\ref{fig:casestudy_greedy}, the
greedy algorithm moves the module ''G'' to position . Thus, a
biggest free space is achieved within a single move. The
heterogeneity requirements of module ''G'' are fulfilled at the time
at this position: at position , BlockRAMs are provided for the
right part of the module. Afterwards, no single move that
provides an improvement on the maximum free contiguous space is possible. Thus, the
greedy algorithm terminates. Note that the evaluation of each
possible step in the algorithm checks the maximal free space by taking
into account all contiguous free slots, no matter if they contain
heterogeneities or not.

In our second approach, the maximum free contiguous space is optimized
using tabu search, see Figure~\ref{fig:casestudy_ts}. Based on the state of the same example, module ''H'' is relocated to slot
position . This step yields a maximal, contiguous free space of four slots
including a single BlockRAM heterogeneity slot. In a
second step, module ''D'' is moved to slot , where module ''H''
was located before. Thus, a new maximal free space is created starting
at slot  up to . All other steps would have created a free
contiguous space with a size less than  slots. Further, this is also the
only position to which module ''D'' can be moved, due to its heterogeneity
constraints. In a third step, module ''F'' is moved to the single
empty slot without BlockRAMs between module ''B'' and module ''C''. In
a next step, module ''G'' can be either moved to slot position  or
to slot position ; both satisfy its heterogeneity
demands. Finally, it is moved to the latter position, because this
results in a maximal free space of  slots. It is also possible
that multiple single steps offer the same increase in contiguous free
space; 
in our current implementation,  one single move is selected randomly.

When the greedy algorithm is applied to the example input, a
contiguous free space of four slots is achieved. In contrast, the
tabu search merges all free space and yields one single contiguous 
block of free space of size . This shows
the usefulness of defragmentation techniques, and the importance of
the corresponding strategy. Similar scenarios of scattered empty space
and heterogeneities on the reconfigurable device are common when
executing modules. New modules with big area requirements must
unnecessarily be delayed without defragmentation steps, which can be
avoided with appropriate defragmentation strategies. How far different
strategies can deviate is shown by comparing the results of the greedy
and the tabu-search approach for this example.




\subsection{Makespan}

\newlength{\makespanfig}
\setlength{\makespanfig}{60mm}
\def\makespanspace{\hspace{-5mm}}


\begin{figure*}[p]
\mbox{}\makespanspace
{\epsfig{figure=PLOT-1-Makespan-CF0-Sn0010Texxxxxxx.eps,width=\makespanfig}}\makespanspace
{\epsfig{figure=PLOT-1-Makespan-CF0-Sn0050Texxxxxxx.eps,width=\makespanfig}}\makespanspace
{\epsfig{figure=PLOT-1-Makespan-CF0-Sn0150Texxxxxxx.eps,width=\makespanfig}}\makespanspace
\mbox{}

\caption{Comparison of makespans for schedules using tabu search, greedy, and no fragmentation for an array of size .
The average module size is fixed to 10, 50, and 150 columns,
the average duration time ranges from 1 to 400 time units.
The -axis shows the total makespan in time units.
\label{smalltimes-fig}}
\end{figure*}

\begin{figure*}[]
\mbox{}\makespanspace
{\epsfig{figure=PLOT-2-Makespan-CF0-Sn0010Texxxxxxx.eps,width=\makespanfig}}\makespanspace
{\epsfig{figure=PLOT-2-Makespan-CF0-Sn0050Texxxxxxx.eps,width=\makespanfig}}\makespanspace
{\epsfig{figure=PLOT-2-Makespan-CF0-Sn0100Texxxxxxx.eps,width=\makespanfig}}\makespanspace
\mbox{}
\caption{Comparison of makespans for schedules using tabu search, greedy, and no fragmentation for an array of size .
The average module size is fixed to 10, 50, and 100 columns,
the average duration time ranges from 600 to 3000 time units.
The -axis shows the total makespan in time units.
\label{bigtimes-fig}}
\end{figure*}


We also simulated the impact on the total makespan (i.e., the total
execution time) by randomly generating sequences of modules. A
sequence consists of 200 modules, for each module we chose size and
duration randomly using different distributions. 
Fig.~\ref{smalltimes-fig} and Fig.~\ref{bigtimes-fig} show examples
in which the size was chosen by normal distribution and duration according to an 
exponential distribution.  We used the exponential distribution for
the duration time, because this distribution models typical life
times~\cite{bn-gs-95}.
We normalized the duration times, i.e.,
we define the time to write a single FPGA column to be 1 time unit.

For each pair of size and duration values, we shuffled 100 sequences and calculated their
makespan by simulating the processing of a sequence using 
tabu search, greedy, and no defragmentation. More precisely, we successively
place the modules into an array that represents the FPGA. 
If we cannot place a module, because there is no sufficient free space,
either the module has to wait (no defragmentation) or we perform
the tabu search or the greedy strategy to compact the FPGA. 
After the duration time for a module elapsed, it is removed from the array.
Our simulation takes the times needed to place or move a module into 
account; the duration time is prolonged accordingly. 

It turned out that it pays off to use defragmentation for larger modules or larger
duration times. Small modules with small duration time enter and leave the system
so quickly that there is no need for defragmentation, 
see Fig.~\ref{smalltimes-fig}(left) up to an average duration of 50 time units.
At smaller module sizes and execution times, greedy's shorter running
time beats the effectiveness of the tabu search 
(Fig.~\ref{smalltimes-fig}(left) from 75 to 350).
However, as the
average module size (as a fraction of the total area) or execution
length increases, the more compact solution provided by the tabu
search provides a better overall execution time, even with increased
overhead
(Fig.~\ref{smalltimes-fig}(left) from 350 and Fig.~\ref{bigtimes-fig}(left)).
For modules of medium size (compared to the size of the FPGA), the tabu search
decreases the total makespan (Fig.~\ref{smalltimes-fig}(middle) and Fig.~\ref{bigtimes-fig}(middle)).
If the average size of a module approaches or even exceeds half the size of the FPGA, the benefit
of compaction disappears (Fig.~\ref{smalltimes-fig}(right) and Fig.~\ref{bigtimes-fig}(right)).
Note that in this case, compaction is often not even possible because the
modules are too large to be moved.






\section{Conclusion}
\label{sec:conclusion}

In this paper, we presented a new approach for defragmenting the module
layout on a dynamically reconfigurable device, for example a FPGA, in
a seamless fashion. As the reconfiguration costs continuously decrease
with each new generation of reconfigurable devices and a number of
techniques for task preemption and relocation at a different positions
are conceived (see Koch et al.~\cite{KHT07} for a comparison), task
relocation at runtime becomes a new opportunity for improving the
performance and efficiency of reconfigurable devices. However, this
also poses new challenges, because defragmentation methods developed
so far cannot be applied to reconfigurable devices, as they do not take
into account their special characteristics. For example, many
reconfigurable devices have heterogeneities on their reconfigurable
area, such as memory blocks, DSPs, and CPUs. We presented different
defragmentation strategies to relocate running modules and achieve a
contiguous free space of maximum size.

The presented experiments show in average an increase in the maximal
free space by  when applying our defragmentation techniques to 
FPGAs with heterogeneities; on some inputs an increase up to 
is observed. This additional free space allows earlier execution of
later modules,
so the total execution time is
reduced. This shows that it pays off to prefer a sophisticated heuristic 
for defragmentation (e.g., tabu search) 
over a simple heuristic (i.e., greedy), or over no 
defragmentation at all; provided that the execution times and module sizes 
are not too extreme (i.e., too large or too small compared to the size
of the FPGA).

Obviously, improved algorithmic results can lead to further
improvements. One of the possible extensions considers a more
controlled overall placement of modules, instead of simply fixing
fragmentation. As the necessary algorithmic methods are more involved,
we leave this to future work.

\section*{Acknowledgements}
We like to thank the anonymous referees for many valuable 
suggestions.

\small






\newcommand{\noopsort}[1]{}
\begin{thebibliography}{10}

\bibitem{blc-erpbr-07}
T.~Becker, W.~Luk, and P.~Y. Cheung.
\newblock Enhancing relocatability of partial bitstreams for run-time
  reconfiguration.
\newblock In {\em Proc. 15th Annu. Sympos. Field-Programm. Custom Comput.
  Mach.}, pages 35--44, 2007.

\bibitem{bn-gs-95}
K.~Behnen and G.~Neuhaus.
\newblock {\em Grundkurs Stochastik}.
\newblock B.G.Teubner-Verlag, 3nd edition, 1995.

\bibitem{Bender05}
M.~A. Bender, E.~D. Demaine, and M.~Farach-Colton.
\newblock Cache-oblivious {B}-trees.
\newblock {\em SIAM J. Comput.}, 35:341--358, 2005.

\bibitem{Bender05a}
M.~A. Bender, J.~T. Fineman, S.~Gilbert, and B.~C. Kuszmaul.
\newblock Concurrent cache-oblivious {B}-trees.
\newblock In {\em Proc. 17th Annu. ACM Sympos. Parallel. Algor. Architect.},
  pages 228--237, 2005.

\bibitem{Bromley80}
G.~Bromley.
\newblock Memory fragmentation in buddy methods for dynamic storage allocation.
\newblock {\em Acta Inform.}, 14:107--117, 1980.

\bibitem{claus09reconfig}
C.~Claus, R.~Ahmed, F.~Altenried, and W.~Stechele.
\newblock Towards rapid dynamic partial reconfiguration in video-based driver
  assistance systems.
\newblock In {\em ARC}, pages 55--67, 2010.

\bibitem{clckh-crdrt-02}
K.~Compton, Z.~Li, J.~Cooley, S.~Knol, and S.~Hauck.
\newblock Configuration relocation and defragmentation for run-time
  reconfigurable systems.
\newblock {\em IEEE Transact. VLSI}, 10:209--220, 2002.

\bibitem{fktvakt-nbddr-08}
S.~P. Fekete, T.~Kamphans, N.~Schweer, C.~Tessars, J.~C. van~der Veen,
  J.~Angermeier, D.~Koch, and J.~Teich.
\newblock No-break dynamic defragmentation of reconfigurable devices.
\newblock In {\em Proc. Internat. Conf. Field Program. Logic Appl.}, pages
  113--118, 2008.

\bibitem{Garey79}
M.~R. Garey and D.~S. Johnson.
\newblock {\em Computers and intractability; a guide to the theory of {\it
  NP}-completeness}.
\newblock W.H. Freeman, 1979.

\bibitem{gericota05}
M.~G. Gericota, G.~R. Alves, M.~L. Silva, and J.~M. Ferreira.
\newblock Run-time defragmentation for dynamically reconfigurable hardware.
\newblock {\em New Algorithms, Architectures and Applications for
  Reconfigurable Computing}, 2005.

\bibitem{hagemeyer_ersa07}
J.~{Hagemeyer}, B.~{Kettelhoit}, M.~{Koester}, and M.~{Porrmann}.
\newblock Design of homogeneous communication infrastructures for partially
  reconfigurable {FPGAs}.
\newblock In {\em Proc. Internat. Conf. Eng. Reconf. Syst. Algor.}, 2007.

\bibitem{Hinds75}
J.~A. Hinds.
\newblock An algorithm for locating adjacent storage blocks in the buddy
  system.
\newblock {\em Commun. ACM}, 18:221--222, 1975.

\bibitem{Hirs73}
D.~S. Hirschberg.
\newblock A class of dynamic memory allocation algorithms.
\newblock {\em Commun. {ACM}}, 16:615--618, 1973.

\bibitem{Know65}
K.~C. Knowlton.
\newblock A fast storage allocator.
\newblock {\em Commun. {ACM}}, 8:623--625, 1965.

\bibitem{Knuth97}
D.~E. Knuth.
\newblock {\em The Art of Computer Programming: Fundamental Algorithms},
  volume~1.
\newblock Addison Wesley, Reading, Massachusetts, 3rd edition, June 1997.

\bibitem{kabk-faepm-04}
D.~Koch, A.~Ahmadinia, C.~Bobda, and H.~Kalte.
\newblock {FPGA} architecture extensions for preemptive multitasking and
  hardware defragmentation.
\newblock In {\em Proc. IEEE Internat. Conf. Field-Programmable Technology},
  pages 433--436, Brisbane, Australia, 2004.

\bibitem{koch_fpl08}
D.~Koch, C.~Beckhoff, and J.~Teich.
\newblock {ReCoBusBuilder} --- {A} novel tool and technique to build static and
  dynamically reconfigurable systems for {FPGAs}.
\newblock In {\em Proc. 18th Internat. Conf. Field Programm. Logic Appl.},
  pages 119--124, 2008.

\bibitem{KHT07}
D.~Koch, C.~Haubelt, and J.~Teich.
\newblock Efficient hardware checkpointing---concepts, overhead analysis, and
  implementation.
\newblock In {\em Proc. 15th ACM/SIGDA Internat. Sympos. Field-Programm. Gate
  Arrays}, pages 188--196, Monterey, California, USA, 2007. ACM.

\bibitem{koch_fccm}
D.~{Koch}, C.~{Haubelt}, and J.~{Teich}.
\newblock Efficient reconfigurable on-chip buses for {FPGAs}.
\newblock In {\em Proc. 16th Annu. IEEE Sympos. Field-Programm. Custom Comput.
  Mach.}, Palo Alto, CA, USA, Apr. 2008.

\bibitem{koester07}
M.~Koester, H.~Kalte, M.~Porrmann, and U.~Ruckert.
\newblock Defragmentation algorithms for partially reconfigurable hardware.
\newblock {\em Internat. Federation for Information Processing Publications
  (Ifip)}, 240:41, 2007.

\bibitem{rose_FPGAgap}
I.~{Kuon} and J.~{Rose}.
\newblock Measuring the gap between {FPGAs} and {ASICs}.
\newblock {\em IEEE Trans. CAD Integr. Circuits Systems}, 26:203--215, Feb.
  2007.

\bibitem{xilinx_fpl06}
P.~Lysaght, B.~Blodget, J.~Mason, J.~Young, and B.~Bridgford.
\newblock Invited paper: Enhanced architecture, design methodologies and {CAD}
  tools for dynamic reconfiguration of {Xilinx FPGAs}.
\newblock In {\em Proc. 16th Internat. Conf. Field Programm. Logic Appl.},
  pages 1--6, Aug 2006.

\bibitem{Shen74}
K.~K. Shen and J.~L. Peterson.
\newblock A weighted buddy method for dynamic storage allocation.
\newblock {\em Commun. {ACM}}, 17:558--562, 1974.

\bibitem{Wils95}
P.~R. Wilson, M.~S. Johnstone, M.~Neely, and D.~Boles.
\newblock Dynamic storage allocation: {A} survey and critical review.
\newblock In H.~Baker, editor, {\em Proceedings of International Workshop on
  Memory Management}, volume 986 of {\em Lecture Notes in Computer Science},
  Kinross, Scotland, Sept. 1995. Springer-Verlag.

\end{thebibliography}
 
\iffalse
\newpage

\begin{appendix}
\section{Comparison to \cite{fktvakt-nbddr-08}}
All sections of the paper have been thoroughly revised and updated.
In particular, Section 1.2, Section 2 (notably Theorem 2), and Section 4
are substantially enhanced. 
Section 6, Section 8.2, and Section 8.3 contain new material.
\end{appendix}
\fi

\end{document}
