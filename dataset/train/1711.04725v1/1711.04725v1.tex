\documentclass[sigconf]{acmart}

\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{multirow}
\usepackage{balance}
\usepackage{url,graphicx}
\usepackage{tabularx}
\usepackage{mathrsfs, amsfonts}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{colortbl}
\usepackage{xcolor}
\usepackage{mdwlist}
\usepackage{marvosym}
\usepackage{bm}
\usepackage{amsmath}
\usepackage{dsfont}
\usepackage{comment}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{listings}
\usepackage[ruled,linesnumbered]{algorithm2e}
\usepackage{paralist}
\usepackage{enumitem}
\usepackage{threeparttable}
\setlist{nosep}

\usepackage{soul}
\graphicspath{{eps/}}
\usepackage{setspace}

\usepackage[np, autolanguage]{numprint}


\newcommand{\todo}[1]{\textcolor{red}{\bf #1}}
\newcommand{\changed}[1]{\textcolor{blue}{#1}}
\newcommand{\argmax}{\mathop{\mathrm{arg}\,\max}}
\newcommand{\krimphet}{\vspace*{-.75\baselineskip}}
\newcommand{\zr}[1]{\textcolor{magenta}{#1}}
\newcommand{\mdr}[1]{\textcolor{cyan}{MdR: #1}}

\newcommand{\enkelop}{}
\newcommand{\llenkelop}{\llap{}}
\newcommand{\dubbelop}{}
\newcommand{\lldubbelop}{\llap{}}
\newcommand{\enkelneer}{}
\newcommand{\llenkelneer}{\llap{}}
\newcommand{\dubbelneer}{}
\newcommand{\lldubbelneer}{\llap{}}

\newcommand{\hidethis}[1]{}

\allowdisplaybreaks

\makeatletter
\renewcommand{\paragraph}[1]{\medskip\noindent\emph{#1.~}}
\makeatother
\newcommand{\miniskip}{\vspace*{-.75\baselineskip}}
\newcommand{\nanoskip}{\vspace*{-.35\baselineskip}}
\hyphenpenalty=5000
\tolerance=1000

\copyrightyear{2017}
\acmYear{2017}
\setcopyright{acmcopyright}
\acmConference{CIKM'17 }{}{November 6--10, 2017, Singapore.}
\acmPrice{15.00}
\acmDOI{https://doi.org/10.1145/3132847.3132926}
\acmISBN{ISBN 978-1-4503-4918-5/17/11}

\fancyhead{}
\settopmatter{printacmref=false, printfolios=false}

\begin{document}

\title{Neural Attentive Session-based Recommendation}

\author{Jing Li}
\affiliation{
  \institution{Shandong University}
  \city{Jinan} 
  \state{China} 
}
\email{jingli.sdu@gmail.com}

\author{Pengjie Ren}
\affiliation{
  \institution{Shandong University}
  \city{Jinan} 
  \state{China} 
}
\email{jay.ren@outlook.com}

\author{Zhumin Chen}
\affiliation{
	\institution{Shandong University}
	\city{Jinan} 
	\state{China} 
}
\email{chenzhumin@sdu.edu.cn}

\author{Zhaochun Ren}
\affiliation{
	\institution{Data Science Lab, JD.com}
	\city{Beijing} 
	\state{China} 
}
\email{renzhaochun@jd.com}

\author{Tao Lian}
\affiliation{
	\institution{Shandong University}
	\city{Jinan} 
	\state{China} 
}
\email{liantao1988@gmail.com}

\author{Jun Ma}
\affiliation{
	\institution{Shandong University}
	\city{Jinan} 
	\state{China} 
}
\email{majun@sdu.edu.cn}

\renewcommand{\shortauthors}{J. Li et al.}


\begin{abstract}

Given e-commerce scenarios that user profiles are invisible, session-based recommendation is proposed to generate recommendation results from short sessions.
Previous work only considers the user's sequential behavior in the current session, whereas the user's main purpose in the current session is not emphasized.
In this paper, we propose a novel neural networks framework, i.e., Neural Attentive Recommendation Machine (NARM), to tackle this problem. Specifically, we explore a hybrid encoder with an attention mechanism to model the user's sequential behavior and capture the user's main purpose in the current session, which are combined as a unified session representation later. We then compute the recommendation scores for each candidate item with a bi-linear matching scheme based on this unified session representation. We train NARM by jointly learning the item and session representations as well as their matchings. 
We carried out extensive experiments on two benchmark datasets. Our experimental results show that NARM outperforms state-of-the-art baselines on both datasets. Furthermore, we also find that NARM achieves a significant improvement on long sessions, which demonstrates its advantages in modeling the user's sequential behavior and main purpose simultaneously.

\end{abstract}





\keywords{Session-based recommendation, sequential behavior, recurrent neural networks, attention mechanism}

\maketitle

\section{INTRODUCTION}

A user session is kicked off when a user clicks a certain item; within a user session,  
clicking on the interesting item, and spending more time viewing it. After that, the user clicks another interesting one to start the view again. Such iterative process will be completed until the user's requirements are satisfied. 
Current recommendation research confronts challenges when recommendations are merely from those user sessions, where existing recommendation methods \cite{koren2009matrix,adomavicius2005toward,weimer2007maximum,su2009survey} cannot perform well. To tackle this problem, session-based recommendation \cite{schafer1999recommender} is proposed to predict the next item that the user is probably interested in based merely on implicit feedbacks, i.e., user clicks, in the current session.

    \begin{figure}
    	\centering
    	\vspace{1em}
    	\subfloat[The global recommender]{
    		\includegraphics[height=0.6in, width=3.1in]{fig/fig1a}}
    	\hspace{4em} 
    	\subfloat[The local recommender]{
    		\includegraphics[height=0.6in, width=3.1in]{fig/fig1b}}	
    	\caption{Two different recommenders. The global recommender models the user's whole sequential behavior to make recommendations while the local recommender captures the user's main purpose to make recommendations. The numbers above the items denote the recommendation scores produced by each recommender. In (b), the item in the red dashed box is more relevant to the current user's intention. And the red line is thicker when the item is more important.}
    \end{figure}

\citet{hidasi2015session} apply recurrent neural networks (RNN) with Gated Recurrent Units (GRU) for session-based recommendation. The model considers the first item clicked by a user as the initial input of RNN, and generates recommendations based on it. Then the user might click one of the recommendations, which is fed into RNN next, and the successive recommendations are produced based on the whole previous clicks. \citet{tan2016improved} further improve this RNN-based model by utilizing two crucial techniques, i.e., data augmentation and a method to account for shifts in the input data distribution. Though all above RNN-based methods show promising improvements over traditional recommendation approaches, they only take into account the user's sequential behavior in the current session, whereas the user's main purpose in the current session is not emphasized. Relying only on the user's sequential behavior is dangerous when a user accidentally clicks on wrong items or s/he is attracted by some unrelated items due to curiosity. Therefore, we argue that both the user's sequential behavior and main purpose in the current session should be considered in session-based recommendation.

Suppose that a user wants to buy a shirt on the Internet. As shown in Figure 1, during browsing, s/he tends to click on some shirts with similar styles to make a comparison, meanwhile s/he might click a pair of suit pants by accident or due to curiosity. After that, s/he keeps looking for suitable shirts. In this case, if we only consider about his/her sequential behavior, another shirt or suit pants even a pair of shoes might be recommended because many users click them after clicking some shirts and suit pants, as shown in Figure 1(a). Assume that the recommender is an experienced human purchasing guide, the guide could conjecture that this user is very likely to buy a short sleeve shirt at this time because most of his/her clicked items are related to it. Therefore, more attention would be paid to the short sleeve shirts that the user has clicked and another similar shirt would be recommended, as shown in Figure 1(b). Ideally, in addition to considering about the user's entire sequential behavior, a better recommender should also take into account the user's main purpose which is reflected by some relatively important items in the current session. Note that the sequential behavior and the main purpose in one session are complementary to each other because we can not always conjecture a user's main purpose from a session, e.g., when the session is too short or the user just clicks something aimlessly.

To tackle the above problem, we propose a novel neural networks framework, namely Neural Attentive Recommendation Machine (NARM). Specifically, we explore a hybrid encoder with an attention mechanism to model the user's sequential behavior and capture the user's main purpose in the current session, which are combined as a unified session representation later. With this item-level attention mechanism, NARM learns to attend differentially to more and less important items. We then compute the recommendation scores for each candidate item with a bi-linear matching scheme based on the unified session representation. NARM is trained by jointly learning the item and session representations as well as their matchings.


\noindent The main contributions of this work are summarized as follows:
 \begin{itemize}
\item We propose a novel NARM model to take into account both the user's sequential behavior and main purpose in the current session, and compute recommendation scores by using a bi-linear matching scheme. 
\item We apply an attention mechanism to extract the user's main purpose in the current session. 
\item We carried out extensive experiments on two benchmark datasets. The results show that NARM outperforms state-of-the-art baselines in terms of recall and MRR on both datasets. Moreover, we find that NARM achieves better performance on long sessions, which demonstrates its advantages in modeling the user's sequential behavior and main purpose simultaneously.
\end{itemize}

\section{RELATED WORK}

Session-based recommendation is a typical application of recommender systems based on implicit feedbacks, where no explicit preferences (e.g., ratings) but only positive observations (e.g., clicks) are available \cite{mild2003improved,he2016fast,ren2017social}. These positive observations are usually in a form of sequential data as obtained by passively tracking users' behavior over a sequence of time. In this section, we briefly review the related work on session-based recommendation from the following two aspects, i.e., traditional methods and deep learning based methods.
  
\subsection{Traditional Methods}
  
Typically, there are two traditional modeling paradigms, i.e., general recommender and sequential recommender.
  
\textbf{General recommender} is mainly based on item-to-item recommendation approaches. In this setting, an item-to-item similarity matrix is pre-computed from the available session data. Items that are often clicked together (i.e., co-occurrence) in sessions are considered to be similar. \citet{linden2003amazon} propose an item-to-item collaborative filtering method to personalize the online store for each customer. \citet{sarwar2001item} analyze different item-based recommendation generation algorithms and compare their results with basic k-nearest neighbor approaches. Though these methods have proven to be effective and are widely employed, they only take into account the last click of the session, ignoring the information of the whole click sequence. 
  
\textbf{Sequential recommender} is based on Markov chains which utilizes sequential data by predicting users' next action given the last action~\cite{zimdars2001using,shani2005mdp}. \citet{zimdars2001using} propose a sequential recommender based on Markov chains and investigate how to extract sequential patterns to learn the next state using probabilistic decision-tree models. \citet{shani2005mdp} present a Markov Decesion Processes (MDP) aiming to provide recommendations in a session-based manner and the simplest MDP boil down to first-order Markov chains where the next recommendation can be simply computed through the transition probabilities between items. \citet{mobasher2002using} study different sequential patterns for recommendation and find that contiguous sequential patterns are more suitable for sequential prediction task than general sequential patterns. \citet{yap2012effective} introduce a new Competence Score measure in personalized sequential pattern mining for next-item recommendations. \citet{chen2012playlist} model playlists as Markov chains, and propose logistic Markov Embeddings to learn the representations of songs for playlists prediction. A major issue with applying Markov chains in the session-based recommendation task is that the state space quickly becomes unmanageable when trying to include all possible sequences of potential user selections over all items.
  
\subsection{Deep Learning based Methods}
  
Deep learning has recently been applied very successfully in areas such as image recognition \cite{krizhevsky2012imagenet,he2016deep}, speech recognition \cite{graves2013speech,amodei2016deep,hinton2012deep} and neural language processing \cite{socher2011parsing,de2014Medical,rsoy2014deep,song2017summarizing,li2017salience}. Deep models can be trained to learn discriminative representations from unstructured data \cite{he2017neural,he2017neuralfact,li2017neural}. Here, we focus on the related work that uses deep learning models to solve recommendation tasks.
  
\textbf{Neural network recommender} is mostly focusing on the classical collaborative filtering user-item setting. \citet{salakhutdinov2007restricted} first propose to use Restricted Boltzmann Machines (RBM) for Collaborative Filtering (CF). In their work, RBM is used to model user-item interactions and to perform recommendations. Recently, denoising auto-encoders have been used to perform CF in a similar manner \cite{wu2016collaborative,sedhain2015autorec}. \citet{wang2015learning} introduce a hierarchical representation model for the next basket recommendation which is based on encoder-decoder mechanism. Deep neural networks have also been used in cross-domain recommendations whereby items are mapped to a joint latent space \cite{elkahky2015a}. Recurrent Neural Networks (RNN) have been devised to model variable-length sequence data. Recently, \citet{hidasi2015session} apply RNN to session-based recommendation and achieve significant improvements over traditional methods. The proposed model utilizes session-parallel mini-batch training and employs ranking-based loss functions for learning the model. \citet{tan2016improved} further study the application of RNN in session-based recommendation. They propose two techniques to improve the performance of their model, namely data augmentation and a method to account for shifts in the input data distribution. \citet{zhang2014sequential} also use RNN for the click sequence prediction, they consider historical user behaviors as well as hand-crafted features for each user and item.
  
Though a growing number of publications on session-based recommendation focus on RNN-based methods, unlike existing studies, we propose a novel neural attentive recommendation model that combines both the user's sequential behavior and main purpose in the current session, which to the best of our knowledge, is not considered by existing researches. And we apply the attention mechanism to session-based recommendation for the first time.

\section{METHOD}

In this section, we first introduce the session-based recommendation task. Then we describe the proposed NARM in detail.
  
\subsection{Session-based Recommendation}
Session-based recommendation is the task of predicting what a user would like to click next when his/her current sequential transaction data is given. Here we give a formulation of the session-based recommendation problem.
  
Let  be a click session, where  is the index of one clicked item out of a total number of  items. We build a model  so that for any given prefix of the click sequence in the session, , we get the output , where . We view  as a ranking list over all the next items that can occur in that session, where  corresponds to the recommendation score of item . Since a recommender typically needs to make more than one recommendations for the user, thus the top-  items in  are recommended. 
  
    \begin{figure}
  	    \vspace{1em}
	    \centering
	    \includegraphics[height=2.2in, width=2.2in]{fig/fig2}
	    \caption{The general framework and dataflow of the encoder-decoder-based NARM.}
    \end{figure}
  
    \begin{figure*}
	    \centering
        \subfloat[The graphical model of the global encoder in NARM, where the last hidden state is interpreted as the user's sequential behavior feature .]{
	        \includegraphics[height=1.5in, width=3.2in]{fig/fig3}}
        \hspace{3.3em}
        \subfloat[The graphical model of the local encoder in NARM, where the weighted sum of hidden states is interpreted as the user's main purpose feature .]{
	        \includegraphics[height=1.55in, width=3.3in]{fig/fig4}}	
        \caption{The global encoder and the local encoder in NARM.}
    \end{figure*}
         
\subsection{Overview}
In this paper, we propose an improved neural encoder-decoder architecture \cite{shang2015neural,ren2017leveraging} to address the session-based recommendation problem, named Neural Attentive Recommendation Machine (NARM). The basic idea of NARM is to build a hidden representation of the current session, and then generate predictions based on it. As shown in Figure 2, the encoder converts the input click sequence  into a set of high-dimensional hidden representations , which along with the attention signal at time  (denoted as ), are fed to the session feature generator to build the representation of the current session to decode at time  (denoted as ). Finally  is transformed by a matrix  (as part of the decoder) into an activate function to produce a ranking list over all items, , that can occur in the current session.
    
The role of  is to determine which part of the hidden representations should be emphasized or ignored at time . It should be noted that  could be fixed over time or changes dynamically during the prediction process. In the dynamic setting,  can be a function of the representations of hidden states or the input item embeddings. We adopt the dynamic setting in our model, more details will be described in \S 3.4.
  
The basic idea of our work is to learn a recommendation model that takes into consideration both the user's sequential behavior and main purpose in the current session. In the following part of this section, we first describe the global encoder in NARM which is used to model the user's sequential behavior (\S 3.3). Then we introduce the local encoder which is used to capture the user's main purpose in the current session (\S 3.4). Finally we show our NARM which combines both of them and computes the recommendation scores for each candidate item by using a bi-linear matching scheme (\S 3.5).
    
\subsection{Global Encoder in NARM}
In the global encoder, the inputs are entire previous clicks while the output is the feature of the user's sequential behavior in the current session. Both the inputs and output are uniformly represented by high-dimensional vectors.
  
Figure 3(a) shows the graphical model of the global encoder in NARM. We use a RNN with Gated Recurrent Units (GRU)  rather than a standard RNN because \citet{hidasi2015session} demonstrate that GRU can outperform the Long Short-Term Memory (LSTM) \cite{hochreiter2012long} units for the session-based recommendation task. GRU is a more elaborate RNN unit that aims at dealing with the vanishing gradient problem. The activation of GRU is a linear interpolation between the previous activation  and the candidate activation ,
    
where the update gate  is given by
    
The candidate activation function  is computed as
    
where the reset gate  is given by
    
With a trivial session feature generator, we essentially use the final hidden state  as the representation of the user's sequential behavior
    
  
However, this global encoder has its drawbacks such as a vectorial summarization of the whole sequence behavior is often hard to capture a preciser intention of the current user.
  
\subsection{Local Encoder in NARM}

    \begin{figure*}
       	\centering
       	\includegraphics[height=2.3in, width=5.8in]{fig/fig5}
       	\caption{The graphical model of NARM, where the session feature  is represented by the concatenation of vectors  and  (as computed in equation (5) and (6)). Note that  and  play different roles, while they have the same values. The last hidden state of the global encoder  plays a role to encode the entire input clicks while the last hidden state of the local encoder  is used to compute attention weights with the previous hidden states.}
    \end{figure*}

The architecture of the local encoder is similar to the global encoder as shown in Figure 3(b). In this encoding scheme we also use RNN with GRU as the basic component. To capture the user's main purpose in the current session, we involve an item-level attention mechanism which allows the decoder to dynamically select and linearly combine different parts of the input sequence, 
     where the weighted factors  determine which part of the input sequence should be emphasized or ignored when making predictions, which in turn is a function of hidden states, 
     
Basically, the weighted factor  models the alignment between the inputs around position  and the output at position , so it can be viewed as a specific matching model. In the local encoder, the function  specifically computes the similarity between the final hidden state  and the representation of the previous clicked item ,
    
where  is an activate function such as sigmoid function, matrix  is used to transform  into a latent space, and  plays the same role for . 
  
This local encoder enjoys the advantages of adaptively focusing on more important items to capture the user's main purpose in the current session.

\subsection{NARM Model}
For the task of session-based recommendation, the global encoder has the summarization of the whole sequential behavior, while the local encoder can adaptively select the important items in the current session to capture the user's main purpose. We conjecture that the representation of the sequential behavior may provide useful information for capturing the user's main purpose in the current session. Therefore, we use the representations of the sequential behavior and the previous hidden states to compute the attention weight for each clicked item. Then a natural extension combines the sequential behavior feature and the user purpose feature by concatenating them to form an extended representation for each time stamp.
  
As shown in Figure 4, we can see the summarization  is incorporated into  to provide a sequential behavior representation for NARM. It should be noticed that the session feature generator in NARM will evoke different encoding mechanisms in the global encoder and the local encoder, although they will be combined later to form a unified representation. More specifically, the last hidden state of the global encoder  plays a role different from that of the local encoder . The former has the responsibility to encode the entire sequential behavior. The latter is used to compute the attention weights with the previous hidden states. By this hybrid encoding scheme, both the user's sequential behavior and main purpose in the current session can be modeled into a unified representation , which is the concatenation of vectors  and ,
    
  
    \begin{table*}
        \caption{Statistics of the datasets used in our experiments. (The avg.length means the average length of the complete dataset.)}
        \label{tab:freq}
            \begin{tabular}{lccccc}
            	\toprule
            	Datasets & all the clicks & train sessions & test sessions & all the items & avg.length\\
            	\midrule
            	YOOCHOOSE  & 557248 & 369859 & 55898 & 16766 & 6.16\\
            	YOOCHOOSE  & 8326407 & 5917746 & 55898 & 29618 & 5.71\\
            	DIGINETICA & 982961 & 719470 & 60858 & 43097 & 5.12\\
            	\bottomrule
            \end{tabular}
    \end{table*}
            
Figure 4 also gives a graphical illustration of the adopted decoding mechanism in NARM. Generally, a standard RNN utilizes fully-connected layer to decode. But using fully-connected layer means that the number of parameters to be learned in this layer is  where  is the dimension of the session representation and  is the number of candidate items for prediction. Thus we have to reserve a large space to store these parameters. Though there are some approaches to reduce the parameters such as using a hierarchical softmax layer \cite{mnih2009scalable}, and negative sampling at random \cite{mikolov2013distributed}, they are not the best choices for our model.
  
We propose an alternative bi-linear decoding scheme which not only reduces the number of the parameters, but also improves the performance of NARM. Specifically, a bi-linear similarity function between the representations of the current session and each candidate items is used to compute a similarity score ,
      
where  is a  matrix,  is the dimension of each item embedding. Then the similarity score of each item is entered to a softmax layer to obtain the probability that the item will occur next. By using this bi-linear decoder, we reduce the number of parameters from  to , where  is usually smaller than . Moreover, the experiment results demonstrate that using this bi-linear decoder can improve the performance of NARM (as demonstrated in \S 4.4). 
  
To learn the parameters of the model, we do not utilize the proposed training procedure in \cite{hidasi2015session}, where the model is trained in a session-parallel, sequence-to-sequence manner. Instead, in order to fit the attention mechanism in the local encoder, NARM process each sequence  separately. Our model can be trained by using a standard mini-batch gradient descent on the cross-entropy loss:
    
where  is the prediction probability distribution and  is the truly distribution. At last, a Back-Propagation Through Time (BPTT) method for a fixed number of time steps is adopted to train NARM.

\section{EXPERIMENTAL SETUP}
In this section, we first describe the datasets, the state-of-the-art methods and the evaluation metrics employed in our experiments. Then we compare NARMs with different decoding schemes. Finally, we compare NARM with state-of-the-art methods.

\subsection{Dataset}
We evaluate different recommenders on two standard transaction datasets, i.e., YOOCHOOSE dataset and DIGINETICA dataset.

    \begin{itemize}
  	    \item YOOCHOOSE\footnote{http://2015.recsyschallenge.com/challenge.html} is a public dataset released by RecSys Challenge 2015. This dataset contains click-streams on an e-commerce site. After filtering out sessions of length 1 and items that appear less than 5 times, there remains 7981580 sessions and 37483 items.
  	    \item DIGINETICA\footnote{http://cikm2016.cs.iupui.edu/cikm-cup} comes from CIKM Cup 2016. We only used the released transaction data and also filtered out sessions of length 1 and items that appear less than 5 times. Finally the dataset contains 204771 sessions and 43097 items.
    \end{itemize}

We first conducted some preprocesses over two datasets. For YOOCHOOSE, we used the sessions of subsequent day for testing and filtered out clicks from the test set where the clicked items did not appear in the training set. For DIGINETICA, the only difference is that we use the sessions of subsequent week for testing. Because we did not train NARM in a session-parallel manner \cite{hidasi2015session}, a sequence splitting preprocess is necessary. For the input session , we generated the sequences and corresponding labels , , ...,  for training on both YOOCHOOSE and DIGINETICA. The corresponding label  is the last click in the current session.
  
For the following reasons: (1) YOOCHOOSE is quite large, (2) \citet{tan2016improved} verified that the recommendation models do need to account for changing user behavior over time, (3) their experimental results showed that training on the entire dataset yields slightly poorer results than training on more recent fractions of the datasets. Thus we sorted the training sequences of YOOCHOOSE by time and reported our results on the model trained on more recent fractions  and  of training sequences as well. Note that some items that in the test set would not appear in the training set since we trained the model only on more recent fractions. The statistics of the three datasets (i.e., YOOCHOOSE , YOOCHOOSE  and DIGINETICA) are shown in Table 1.
    
    \begin{table*}
        \caption{The comparison of different decoders in NARM.}
	    \label{tab: decoder comparision}
	    \begin{tabular}{lcccccc}
		    \toprule
    	    \multirow{3}{*}{Decoders} & \multicolumn{2}{c}{YOOCHOOSE } & \multicolumn{2}{c}{YOOCHOOSE } & \multicolumn{2}{c}{DIGINETICA}\\
    	    \cmidrule(lr){2-3} \cmidrule(lr){4-5}\cmidrule(lr){6-7}
		        & Recall@20(\%) & MRR@20(\%) & Recall@20(\%) & MRR@20(\%) & Recall@20(\%) & MRR@20(\%)\\
    	    \midrule
    		    Fully-connected decoder & 67.67 & 29.17 & 69.49 & 29.54 & 57.84 & 24.77\\
    		    Bi-linear similarity decoder & \textbf{68.32} & 28.76 & \textbf{69.73} & 29.23 & \textbf{62.58} & \textbf{27.35}\\
    	    \bottomrule
	   \end{tabular}
    \end{table*}
    
    \begin{table*}
  	    \vspace{1.2em}
  	    \begin{threeparttable}
	        \caption{Performance comparison of NARM with baseline methods over three datasets.}
	        \label{tab:decoder comparision}
            \begin{tabular}{lcccccc}
		        \toprule
		        \multirow{3}{*}{Methods} & \multicolumn{2}{c}{YOOCHOOSE } & \multicolumn{2}{c}{YOOCHOOSE } & \multicolumn{2}{c}{DIGINETICA}\\
    	        \cmidrule(lr){2-3} \cmidrule(lr){4-5}\cmidrule(lr){6-7}
			        & Recall@20(\%) & MRR@20(\%) & Recall@20(\%) & MRR@20(\%) & Recall@20(\%) & MRR@20(\%)\\
    	        \midrule
    		        POP & 6.71 & 1.65 & 1.33 & 0.30 & 0.91 & 0.23\\
    		        S-POP & 30.44 & 18.35 & 27.08 & 17.75 & 21.07 & 14.69\\
    		        Item-KNN & 51.60 & 21.81 & 52.31 & 21.70 & 28.35 & 9.45\\
    		        BPR-MF & 31.31 & 12.08 & 3.40 & 1.57 & 15.19 & 8.63\\
    		        FPMC\tnote{*} & 45.62 & 15.01 & - & - & 31.55 & 8.92\\
    	        \midrule
    		        GRU-Rec & 60.64 & 22.89 & 59.53 & 22.60 & 43.82 & 15.46\\
    		        Improved GRU-Rec & 67.84 & \textbf{29.00} & 69.11 & 29.22 & 57.95 & 24.93\\
    		        NARM & \textbf{68.32} & 28.76 & \textbf{69.73} & \textbf{29.23} & \textbf{62.58} & \textbf{27.35}\\
    	        \bottomrule
            \end{tabular}
      
            \begin{tablenotes}
      	        \item[*] On YOOCHOOSE , we do not have enough memory to initialize FPMC. Our available memory is 120G.
            \end{tablenotes}
      
        \end{threeparttable}
    \end{table*}

\subsection{Baseline Methods}
We compare the proposed NARM with five traditional methods (i.e., POP, S-POP, Item-KNN, BPR-MF and FPMC) and two RNN-based models (i.e., GRU-Rec and Improved GRU-Rec).
  
    \begin{itemize}
  	    \item \textbf{POP}: Popular predictor always recommends the most popular items in the training set. Despite its simplicity, it is often a strong baseline in certain domains.
  	    \item \textbf{S-POP}: This baseline recommends the most popular items for the current session. The recommendation list changes during the session gains more items. Ties are broken up using global popularity values.
  	    \item \textbf{Item-KNN}: In this baseline, similarity is defined as the co-occurrence number of two items in sessions divided by the square root of the product of the number of sessions in which either item occurs. Regularization is also included to avoid coincidental high similarities between rarely visited items \cite{linden2003amazon,davidson2010youtube}.
  	    \item \textbf{BPR-MF}: BPR-MF \cite{rendle2009bpr} optimizes a pairwise ranking objective function via stochastic gradient descent. Matrix factorization can not be directly applied to session-based recommendation because new sessions do not have precomputed latent representations. However, we can make it work by representing a new session with the average latent factors of items occurred in the session so far. In other words, the recommendation score can be computed as the average of the similarities between latent factors of a candidate item and the items in the session so far.
  	    \item \textbf{FPMC}: FPMC \cite{rendle2010factorizing} is a state-of-the-art hybrid model on the next-basket recommendation. In order to make it work on session-based recommendation, we do not consider the user latent representations when computing recommendation scores.
  	    \item \textbf{GRU-Rec}: We denote the model proposed in \cite{hidasi2015session} as GRU-Rec, which utilizes session-parallel mini-batch training process and also employs ranking-based loss functions for learning the model.
  	    \item \textbf{Improved GRU-Rec}: We denote the model proposed in \cite{tan2016improved} as Improved GRU-Rec. Improved GRU-Rec adopts two techniques which include data augmentation and a method to account for shifts in the input data distribution to improve the performance of GRU-Rec.
    \end{itemize}

\subsection{Evaluation Metrics and Experimental Setup}
  
\subsubsection{Evaluation Metrics}\
  
As recommender systems can only recommend a few items at each time, the actual item a user might pick should be amongst the first few items of the list. Therefore, we use the following metrics to evaluate the quality of the recommendation lists.

    \begin{itemize}
	    \item Recall@20: The primary evaluation metric is Recall@20 that is the proportion of cases when the desired item is amongst the top-20 items in all test cases. Recall@N does not consider the actual rank of the item as long as it is amongst the top-N and also usually correlates well with other metrics such as click-through rate (CTR) \cite{liu2012enlister}.
	    \item MRR@20: Another used metric is MRR@20 (Mean Reciprocal Rank), which is the average of reciprocal ranks of the desire items. The reciprocal rank is set to zero if the rank is larger than 20. MRR takes the rank of the item into account, which is important in settings where the order of recommendations matters.
    \end{itemize}
  
\subsubsection{Experimental Setup}\
  
The proposed NARM model uses 50-dimensional embeddings for the items. Optimization is done using Adam \cite{kingma2014adam} with the initial learning rate sets to 0.001, and the mini-batch size is fixed at 512. There are two dropout layers used in NARM: the first dropout layer is between the item embedding layer and the GRU layer with 25\% dropout, the second one is between the GRU layer and the bi-linear similarity layer with 50\% dropout. We also truncate BPTT at 19 time steps as the setting in the state-of-the-art method \cite{tan2016improved} and the number of epochs is set to 30 while using 10\% of the training data as the validation set. We use one GRU layer in our model and the GRU is set at 100 hidden units. The model is defined and trained in Theano on a GeForce GTX TitanX GPU. The source code of our model is available online\footnote{https://github.com/lijingsdu/sessionRec\_NARM}.

\subsection{Comparison among Different Decoders}
We first empirically compare NARMs with different decoders, i.e., fully-connected decoder and bi-linear similarity decoder. The results over three datasets are shown in Table 2. Here we only illustrate the results on 100-dimensional hidden states because we obtain the same conclusions on other dimension settings.
  
We make following observations from Table 2: (1) With regard to Recall@20, the performance improves when using the bi-linear similarity decoder, and the improvements are around 0.65\%, 0.24\% and 4.74\% respectively over three datasets. (2) And with regard to MRR@20, the performance on the model using the bi-linear decoder becomes a little worse on YOOCHOOSE  and . But on DIGINETICA, the model with the bi-linear decoder still obviously outperforms the model with the fully-connected decoder.
  
For the session-based recommendation task, as the recommender system recommends top-20 items at once in our settings, the actual item a user might pick should be among the list of 20 items. Thus we consider that the recall metric is more important than the MRR metric in this task, and NARM adopts the bi-linear decoder in the following experiments.

    \begin{figure*}[htbp]
	    \centering
	    \subfloat[YOOCHOOSE]{
		    \includegraphics[height=3in, width=2in]{fig/yoo1_64}}
	    \vspace{0em} 
	    \subfloat[YOOCHOOSE]{
		    \includegraphics[height=3in, width=2in]{fig/yoo1_4}}	
	    \vspace{0em} 
	    \subfloat[DIGINETICA]{
		    \includegraphics[height=3in, width=2in]{fig/digi}}
	    \caption{Performance comparison between NARM and the best baseline (i.e., Improved GRU-Rec) over three datasets.}
    \end{figure*}

\subsection{Comparison against Baselines}
Next we compare our NARM model with state-of-the-art methods. The results of all methods over three datasets are shown in Table 3. And a more specific comparison between NARM and the best baseline (i.e., Improved GRU-Rec) over three datasets are illustrated in Figure 5.

We have the following observations from the results: (1) For YOOCHOOSE  dataset, BPR-MF does not work when we use the average of item factors occurred in the session to replace the user factor. Besides, since we regard each session as one user in FPMC, we do not have enough memory to initialize it. These problems indicate traditional user-based methods are no longer suitable for session-based recommendation. (2) Overall, three RNN-based methods consistently outperform the traditional baselines, which demonstrates that RNN-based models are good at dealing with sequence information in sessions. (3) By taking both the user's sequential behavior and main purpose into consideration, the proposed NARM can outperform all the baselines in terms of recall@20 over three datasets and can outperform most of the baselines in terms of MRR@20. Take DIGINETICA dataset as an example, when compared with the best baseline (i.e., Improved GRU-Rec), the relative performance improvements by NARM are around 7.98\% and 9.70\% respectively in terms of recall@20 and MRR@20. (4) As we can see, the recall values on two YOOCHOOSE datasets are not as significantly as the results on DIGINETICA and the obtained MRR values are very close to each other. We consider that one of the important reasons is when we split YOOCHOOSE dataset to  and , we do not filter out clicks from the test set where the clicked items are not in the training set in order to be consistent with the setting on Improved GRU-Rec \cite{tan2016improved}. While on DIGINETICA, we filter out these clicks from the test set, and hence NARM outperforms the baselines significantly in terms of both Recall@20 and MRR@20.

\section{ANALYSIS}
In this section, We further explore the influences of using different session features in NARM and analyze the effectiveness of the adopted attention mechanism.

    \begin{table}[htbp]
	    \vspace{-0.3em}
	    \caption{Performance comparison among three versions of NARM over three datasets.}
	    \centering
	    \subfloat[Performance comparison on YOOCHOOSE ]{
		    \begin{tabular}{lcccc}
			    \toprule
			    \multirow{3}{*}{Models} & \multicolumn{2}{c}{d=50} & \multicolumn{2}{c}{d=100}\\
			    & Recall@20 & MRR@20 & Recall@20 & MRR@20\\
			    \midrule
			     & 67.26 & 26.95 & 68.15 & 28.37\\
			     & 67.07 & 26.79 & 68.10 & 28.38\\
			     & \textbf{68.28} & \textbf{28.10} & \textbf{68.32} & \textbf{28.76}\\
			    \bottomrule
		    \end{tabular}
	    }
	    
	    \subfloat[Performance comparison on YOOCHOOSE ]{
		    \begin{tabular}{lcccc}
			    \toprule
			    \multirow{3}{*}{Models} & \multicolumn{2}{c}{d=50} & \multicolumn{2}{c}{d=100}\\
			    & Recall@20 & MRR@20 & Recall@20 & MRR@20\\
			    \midrule
			     & 67.67 & 27.10 & 68.91 & 28.48\\
			     & 67.50 & 27.21 & 68.01 & 27.36\\
			     & \textbf{69.17} & \textbf{28.67} & \textbf{69.73} & \textbf{29.23}\\
			    \bottomrule
		    \end{tabular}
    	}
 
	    \subfloat[Performance comparison on DIGINETICA]{
		    \begin{tabular}{lcccc}
			    \toprule
			    \multirow{3}{*}{Models} & \multicolumn{2}{c}{d=50} & \multicolumn{2}{c}{d=100}\\
			    & Recall@20 & MRR@20 & Recall@20 & MRR@20\\
			    \midrule
			     & 59.63 & 23.52 & 61.88 & 26.51\\
			     & 58.74 & 22.91 & 61.71 & 26.04\\
		    	 & \textbf{61.73} & \textbf{26.25} & \textbf{62.58} & \textbf{27.35}\\
			    \bottomrule
		    \end{tabular}
	    }
    \end{table}

\subsection{Influence of Using Different Features}
In this part, we refer to the NARM that uses the sequential behavior feature only, the NARM that uses the user purpose feature only, and the NARM that uses both two features as ,  and  respectively. As shown in Table 4, (1)  and , which only use a single feature, do not perform well on three datasets. Besides, their performance are very close to each other in terms of two metrics. This indicates that merely considering the sequential behavior or the user purpose in the current session may not be able to learn a good recommendation model. (2) When we take into account both the user's sequential behavior and main purpose,  performs better than  and  in terms of Recall@20 and MRR@20 on different hidden state dimensions over three datasets. Take DIGINETICA dataset as an example, when compared with  and  with the dimensionality of the hidden state set to 50, the relative performance improvements by  are around 3.52\% and 5.09\% in terms of Recall@20 respectively. These results demonstrate the advantages of considering both the sequential behavior and the main purpose of the current user in session-based recommendation.
  
    \begin{figure*}
  	    \centering
  	    \includegraphics[height=1.7in, width=6.8in]{fig/att}
  	    \caption{Visualization of items weights. The depth of the color corresponds to the importance of items given by equation (7). The numbers above the sessions is the session IDs. (Best viewed in color.)}
    \end{figure*}

    \begin{table}[htbp]
  	    \caption{Performance comparison among different session lengths on DIGINETICA dataset. (The baseline method is Improved GRU-Rec \cite{tan2016improved}.)}
  	    \label{tab:lenth comparision}
  	    \begin{tabular}{cccc}
  		    \toprule
  		    \multicolumn{4}{c}{DIGINETICA DATASET}\\
  		
  		    Length & Baseline correct & NARM correct & Performance\\
  		    \midrule
	  		1 & 8747 & 9358 & +6.98\%\\
	  		2 & 6601 & 7084 & +7.31\%\\
	  		3 & 4923 & 5299 & +7.63\%\\
	  		4 & 3625 & 3958 & +9.18\%\\
	  		5 & 2789 & 3019 & +8.24\%\\
	  		6 & 2029 & 2202 & +8.52\%\\
	  		7 & 1520 & 1656 & +8.94\%\\
	  		8 & 1198 & 1295 & +8.09\%\\
	  		9 & 915 & 996 & +8.85\%\\
	  		10 & 690 & 753 & +9.13\%\\
	  		11 & 509 & 587 & \textbf{+15.32\%}\\
	  		12 & 411 & 459 & \textbf{+11.67\%}\\
	  		13 & 304 & 323 & +6.25\%\\
	  		14 & 243 & 260 & +6.99\%\\
	  		15 & 199 & 219 & \textbf{+10.05\%}\\
	  		16 & 149 & 165 & \textbf{+10.73\%}\\
	  		17 & 98 & 112 &\textbf{+14.28\%}\\
	  		18 & 88 & 93 & +5.68\%\\
	  		19 & 70 & 75 & +7.14\%\\
  		    \bottomrule
  	    \end{tabular}
    \end{table}

\subsection{Influence of Different Session Lengths}
Our NARM model is based on the assumption that when a user is browsing online, his/her click behavior frequently revolves his/her main purpose in the current session. However, we can hardly capture the user's main purpose when s/he just clicks a few items. Therefore, our NARM model should be good at modeling long sessions. To verify this, we make comparisons among sessions with different lengths on DIGINETICA. As shown in Table 5, (1) NARM performs better when the session lengths are between 4 and 17 in general. This indicates that NARM do capture the user's main purpose more accuracy on long sessions. In other words, it could make a better prediction if NARM captures more user purpose features on the basis of the existing sequential behavior features. (2) When sessions are too long, the performance improvements of NARM are declined. We consider the reason is that when a session is too long, the user is very likely to click some items aimlessly, so that the local encoder in NARM could not capture the user's main purpose in the current session.

\subsection{Visualize the Attention Weights}
To illustrate the role of the attention mechanism intuitively, we present an example in Figure 6. The session instances are chosen randomly from DIGINETICA. The depth of the color corresponds to the importance of items given by equation (7). We have following observations from the example: (1) Overall, it is obvious that not all items are related to the next click and almost all the important items in the current session is continuous. This implies that the users' intentions in sessions are indeed localized, which is one of the reasons why NARM can outperform the general RNN-based model. (2) The most important items are often near the end of the session. This is in line with people's browsing behavior: a user is very likely to click other items that are related to what s/he has clicked just now. Recall that general RNN-based models are able to model this fact, thus they can achieve fairly good performance in session-based recommendation. (3) In some cases, the most important items appear in the beginning or middle of the session (e.g., in session 7974 or 4260). In this situation, we believe that our NARM can perform better than general RNN-based models because the attention mechanism could learn to pay more attention to more important items regardless of its position in one session. 

\section{CONCLUSION \& FUTURE WORK}
We have proposed the neural attentive recommendation machine (NARM) with an encoder-decoder architecture to address the session-based recommendation problem. By incorporating an attention mechanism into RNN, our proposed approach can capture both the user's sequential behavior and main purpose in the current session. \if0With this attention mechanism, NARM can attend differentially to more and less important items.\fi Based on the sequential behavior feature and the user purpose feature, we have applied NARM to predict a user's next click in the current session. We have conducted extensive experiments on two benchmark datasets and demonstrated that our approach can outperform state-of-the-art methods in terms of different evaluation metrics. Moreover, we have performed an analysis on user click behaviors and found that users' intentions are localized in most sessions, which proves the rationality of our model.

As to future work, more item attributes, such as prices and categories, may enhance the performance of our method in session-based recommendation. Meanwhile, both the nearest neighbor sessions and the importance of different neighbors  should give new insights. Finally, the attention mechanism can be used to explore the importance of attributes in the current session. 


\section*{Acknowledgments}
The authors wish to thank the anonymous reviewers for their helpful comments. This work is supported by the Natural Science Foundation of China (61672322, 61672324), the Natural Science Foundation of Shandong province (2016ZRE27468) and the Fundamental Research Funds of Shandong University.

\bibliographystyle{abbrvnatnourl}
\bibliography{sigproc} 

\end{document}
