\let\accentvec\vec  \documentclass{llncs}
\let\spvec\vec \let\vec\accentvec 
\usepackage{comment}
\usepackage{booktabs}
\usepackage{url}
\usepackage{graphicx} 	\usepackage[tight]{subfigure} \usepackage{float}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amstext}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{mathrsfs}
\usepackage[shortlabels]{enumitem}
\setlist{noitemsep}

\newcommand{\yes}{\textsc{yes}\xspace}
\newcommand{\no}{\textsc{no}\xspace}
\newcommand{\yesinstance}{\yes-instance\xspace}
\newcommand{\noinstance}{\no-instance\xspace}

\newtheorem{numberedclaim}{Claim}
\newtheorem{observation}{Observation}
\newtheorem{redrule}{Reduction Rule}

\newcommand{\claimqed}{\renewcommand{\squareforqed}{}\qed\renewcommand{\squareforqed}{\plainsquareforqed}}

\newcommand{\Oh}{{\mathcal{O}}}
\newcommand{\G}{{\mathcal{G}}}
\newcommand{\C}{{\mathcal{C}}}
\newcommand{\Q}{{\mathcal{Q}}}
\newcommand{\td}{\mathbf{td}}
\newcommand{\idf}{\mathbf{idf}}
\newcommand{\ch}{\mathbf{child}}
\newcommand{\clos}{{\mathbf{clos}}}
\newcommand{\dist}{{\mathbf{dist}}}
\newcommand{\height}{{\mathbf{height}}}
\newcommand{\depth}{{\mathbf{depth}}}
\newcommand{\reach}{{\mathbf{reach}}}
\newcommand{\anc}{{\mathbf{anc}}}

\newcommand{\NN}{\ensuremath{\mathcal{N}}\xspace}
\let\SSign\S
\renewcommand{\S}{\ensuremath{\mathcal{S}}\xspace}
\renewcommand{\P}{\ensuremath{\mathcal{P}}\xspace}
\newcommand{\FF}{\ensuremath{\mathcal{F}}\xspace}
\newcommand{\opt}{\ensuremath{\mathrm{\textsc{opt}}}\xspace}
\newcommand{\GG}{{\cal G}}
\newcommand{\HH}{{\cal H}}
\newcommand{\Ok}{ \tilde{O}(\sqrt k) }
\newcommand{\tw}{{\mathbf{tw}}}
\newcommand{\cwd}{{\mathbf{cwd}}}
\newcommand{\sfc}{-face}
\newcommand{\containment}[0]{{\sf NP}~~{\sf coNPpoly}\xspace} 

\newcommand{\forget}{\mbox{\bf forget}}

\newcommand{\pw}{\mbox{\bf pw}}
\newcommand{\h}[1]{\end{document}}
\newcommand{\param}{{\bf p}}
\DeclareMathOperator{\operatorClassNP}{\sf NP}

\usepackage{boxedminipage}

\newcommand{\inp}{{\text{\rm input}}\xspace}
\newcommand{\out}{{\text{\rm output}}\xspace}
\newcommand{\size}{{\text{\rm size}}\xspace}
\newcommand{\nats}{\mathbb{N}}

\newcommand{\X}{\ensuremath{\mathcal{X}}\xspace}
\renewcommand{\C}{\ensuremath{\mathcal{C}}\xspace}
\newcommand{\F}{\ensuremath{\mathcal{F}}\xspace}
\newcommand{\T}{\ensuremath{\mathcal{T}}\xspace}
\newcommand{\eps}{\varepsilon}
\newcommand{\poly}{{\rm{poly}}}
\newcommand{\ones}{{\rm{ones}}}
\newcommand{\cF}{{\mathcal{F}}}
\newcommand{\cS}{{\mathcal{S}}}
\newcommand{\cO}{{\mathcal{O}}}

\newcommand{\defparproblem}[4]{
 \vspace{1mm}
\noindent\fbox{
 \begin{minipage}{0.96\textwidth}
 \begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}lr} #1 & {\bf{Parameter:}} #3 \\ \end{tabular*}
 {\bf{Input:}} #2 \\
 {\bf{Question:}} #4
 \end{minipage}
 }
 \vspace{1mm}
}

\newcommand{\defproblem}[3]{
 \vspace{1mm}
\noindent\fbox{
 \begin{minipage}{0.96\textwidth}
 \begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}lr} #1 &  \\ \end{tabular*}
 {\bf{Input:}} #2 \\
 {\bf{Question:}} #3
 \end{minipage}
 }
 \vspace{1mm}
}


\newcommand{\ProblemFormat}[1]{{\sc #1}}

\newcommand{\ProblemIndex}[1]{\index{problem!\ProblemFormat{#1}}}

\newcommand{\HitPathsInFlower}{\textsc{Hitting Paths in a Flower with Budgets}\xspace}
\newcommand{\HitPathsInGraph}{\textsc{Hitting Paths in a Graph}\xspace}
\newcommand{\SignedThreeSatn}{\textsc{-Totally Ordered Regular Signed 3-SAT}\xspace}
\newcommand{\SignedTwoSat}{\textsc{Totally Ordered Regular Signed 2-SAT}\xspace}
\newcommand{\nTORSThreeSat}{\textsc{-TORS 3-SAT}\xspace}
\newcommand{\kIndependentSet}{\textsc{-Independent Set}\xspace}
\newcommand{\kClique}{\textsc{-Clique}\xspace}
\newcommand{\TORSTwoSat}{\textsc{TORS 2-SAT}\xspace}
\newcommand{\SetPacking}{\textsc{Set Packing}\xspace}
\newcommand{\VertexCover}{\textsc{Vertex Cover}\xspace}
\newcommand{\HittingSet}{\textsc{Hitting Set}\xspace}
\newcommand{\SetCover}{\textsc{Set Cover}\xspace}
\newcommand{\ProblemName}[1]{\ProblemFormat{#1}\ProblemIndex{#1}\xspace}
\newcommand{\ProblemNameX}[2]{\ProblemFormat{#1}\ProblemIndex{#2}\xspace}
\newcommand{\probbarF}{\ProblemName{Bar Fight Prevention}}
\newcommand{\probtdeta}{\ProblemName{Tree\-depth- Deletion}}
\newcommand{\XSC}{\ProblemName{Exact -Uniform Set Cover}}
\newcommand{\FDeletion}{\ProblemName{-Minor-Free Deletion}}
\newcommand{\PlanarFDeletion}{\ProblemName{Planar -Minor-Free Deletion}}
\newcommand{\TreewidthEtaDeletion}{\ProblemName{Treewidth- Deletion}}
\newcommand{\TreedepthEtaDeletion}{\probtdeta}
\newcommand{\KdplusoneDeletion}{\ProblemName{-Minor-Free Deletion}}
\newcommand{\CliqueorPathDeletion}{\ProblemName{-Minor-Free Deletion}}
\newcommand{\TreewidthDminoneDeletion}{\ProblemName{Treewidth- Deletion}}

\pagestyle{plain}

\renewcommand{\SS}{\ensuremath{\mathcal{S}}\xspace}

\title{On Structural Parameterizations of Hitting Set: \\ Hitting Paths in Graphs Using 2-SAT\thanks{Supported by NWO Veni grant ``Frontiers in Parameterized Preprocessing'' and NWO Gravity grant ``Networks''.}}

\author{Bart M.\ P.\ Jansen \inst{1}}

\institute{Eindhoven University of Technology, The Netherlands. \email{b.m.p.jansen@tue.nl}}

\usepackage[colorlinks=true,urlcolor=red,citecolor=red]{hyperref}

\graphicspath{{./images/}}

\begin{document}

\hypersetup{bookmarksdepth=-1}

\maketitle

\hypersetup{bookmarksdepth=2} 

\begin{abstract}
\HittingSet is a classic problem in combinatorial optimization. Its input consists of a set system~ over a finite universe~ and an integer~; the question is whether there is a set of~ elements that intersects every set in~. The \HittingSet problem parameterized by the size of the solution is a well-known W[2]-complete problem in parameterized complexity theory. In this paper we investigate the complexity of \HittingSet under various structural parameterizations of the input. Our starting point is the folklore result that \HittingSet is polynomial-time solvable if there is a tree~ on vertex set~ such that the sets in~ induce connected subtrees of~. We consider the case that there is a treelike graph with vertex set~ such that the sets in~ induce connected subgraphs; the parameter of the problem is a measure of how treelike the graph is. Our main positive result is an algorithm that, given a graph~ with cyclomatic number~, a collection~ of simple paths in~, and an integer~, determines in time~ whether there is a vertex set of size~ that hits all paths in~. It is based on a connection to the 2-SAT problem in multiple valued logic. For other parameterizations we derive W[1]-hardness and para-NP-completeness results.
\end{abstract}

\section{Introduction}

\HittingSet is a classic problem in combinatorial optimization that asks, given a set system~ over a finite universe~, and an integer~, whether there is a set of~ elements that intersects every set in~. It was one of the first problems to be identified as NP-complete~\cite{Karp72}. Parameterized complexity theory is a refined view of computational complexity that aims to attack NP-hard problems by algorithms whose running time is exponential in a problem-specific \emph{parameter value}, but polynomial in terms of the overall input size. The standard parameterization of \HittingSet by the size of the desired solution is unlikely to admit such a fixed-parameter tractable algorithm, as it is W[2]-complete~\cite{DowneyF13}. The goal of this paper is to consider other parameterizations of \HittingSet, with the aim of obtaining FPT algorithms. Our starting point is the folklore result that \HittingSet is polynomial-time solvable when there is a tree~ on vertex set~ such that all sets~ induce connected subtrees of~. The \HittingSet problem on such an instance can be solved by a greedy strategy (Section~\ref{section:prelims}). Motivated by this result, we consider whether \HittingSet can be solved efficiently if there is a graph~ that is close to being a tree, such that all~ induce connected subgraphs of~. We therefore parameterize the problem by measures of closeness of~ to a tree, which forms an example of parameterizing by distance from triviality~\cite{Niedermeier10}.

\textbf{Our results.} 
One way to measure how close a connected graph is to a tree is to consider its \emph{cyclomatic number}~. This is the size of a minimum feedback edge set of the graph, i.e., of a minimum set of edges whose removal breaks all cycles in the graph. As a tree has cyclomatic number zero, it is natural to ask if \HittingSet can be solved efficiently if the set system~ can be represented by a graph~ on vertex set~ having small cyclomatic number, such that every set~ induces a connected subgraph of~. To decouple the difficulty of finding a representation of~ in this form from the problem of exploiting this representation to solve \HittingSet, we consider the situation when such a representation is given. In this setting, the problem can be phrased more naturally in graph-theoretical terms: given a graph~ of cyclomatic number~, a collection~ of connected subgraphs of~, and an integer~, is there a vertex set of size~ that hits all subgraphs in~? 

\begin{table}[t]
	\caption{Parameterized complexity overview for hitting subgraphs by the minimum number of vertices, parameterized by measures of structure of the host graph. }
	\centering
{
\begin{tabular}{@{}llllll@{}}
\toprule
parameter & \multicolumn{5}{c}{complexity for type of subgraphs to be hit} \\ 
\cmidrule{2-6}
& \multicolumn{2}{l}{path} & \phantom{abc} & \multicolumn{2}{l}{3-leaf subtree} \\ 
\midrule
cyclomatic number & FPT, no~ kernel & thm.~\ref{theorem:pathsingraph:fpt} & & W[1]-hard & thm.~\ref{theorem:hitclaws:whard} \\
feedback vertex number & para-NP-complete & thm.~\ref{theorem:hitpaths:fvs:npc} & & para-NP-complete & thm.~\ref{theorem:hitpaths:fvs:npc} \\
\bottomrule
\end{tabular}
\label{table:summary}
}
\end{table}

Our first result for the parameterization by cyclomatic number is a hardness proof showing this problem to be W[1]-hard. In fact, we prove W[1]-hardness even when all subgraphs in~ are trees with at most three leaves. To establish this hardness result we prove that a variation of 3-SAT in multiple valued logic (see Section~\ref{section:prelims}) is W[1]-hard, which may be of independent interest. Concretely, we show the following. Given a set of~ variables~ that can take values from~ to~, and a formula that is a conjunction of clauses of size at most three, where each literal is of the form~ or~ for~, it is W[1]-hard parameterized by~ to determine whether there is an assignment to the variables satisfying all clauses. This parameterized logic problem reduces to the discussed structural parameterization of \HittingSet in a natural way.

The hardness result motivates us to place further restrictions on the problem in search of fixed-parameter tractable cases. We consider the situation of hitting a set~ of \emph{simple paths} in a graph~ of cyclomatic number~. This corresponds to \HittingSet instances where there is a graph~ on~ such that for all sets~ in~, there is a \emph{simple path} in~ on vertex set~. We prove that this problem is fixed-parameter tractable and can be solved in time~, which is the main algorithmic result in this paper. The algorithm is based on a reduction to~ instances of the 2-SAT problem in multiple valued logic, which is known to be polynomial-time solvable~\cite{BejarHM01,Manya00}. The reduction exploits the fact that in tree-like parts of the graph, the local structure of minimum hitting sets can be determined by greedily computed optimal hitting sets for subtrees of a tree. After branching in~ directions to determine the form of a solution, the interaction between such canonical subsolutions is then encoded in a 2-SAT formula in multiple valued logic, which can be evaluated efficiently.

There are several other parameters that measure the closeness of a graph to a tree, such as the \emph{feedback vertex number} and \emph{treewidth} (cf.~\cite{FellowsJR13}). As these parameters have smaller values than the cyclomatic number, one might hope to extend the FPT result mentioned above to these parameters. However, we show that this is impossible, unless P=NP. In particular, we prove that the problem of hitting simple paths in a graph of feedback vertex number~ is NP-complete, showing the parameterizations by feedback vertex number and treewidth to be para-NP-complete. Table~\ref{table:summary} gives an overview of the results in this paper.

\textbf{Related work.} Several authors~\cite{CoppersmithV85,Fiala01,UhlmannW13} have considered problems parameterized by cyclomatic number; this is also known as parameterizing by feedback edge set. In parameterized complexity, \HittingSet is often studied when the sets to be hit have constant size. In this setting, several FPT algorithms and kernelizations bounds are known \cite{Abu-Khzam10,DellM14,Wahlstrom07}. The weighted \SetCover problem, which is dual to \HittingSet, has been analyzed for tree-like set systems by Guo and Niedermeier~\cite{GuoN06}. Recently, Lu et al.~\cite{LuLTLX14} considered \SetCover and \HittingSet for set systems representable as subtrees of a (restricted type of) tree, distinguishing polynomial-time and NP-complete cases.

\textbf{Organization.} Preliminaries are given in~\ref{section:prelims}. The FPT algorithm for hitting paths is developed in Section~\ref{section:fpt}. Section~\ref{section:hardness} contains the hardness proofs.

\section{Preliminaries} \label{section:prelims}

\textbf{Parameterized complexity.}
A parameterized problem is a set~, where~ is a fixed finite alphabet. The second component of a tuple~ is the \emph{parameter}. A parameterized problem is (strongly uniformly) \emph{fixed-parameter tractable} if there is an algorithm that decides every input~ in time~. Evidence that a problem is not fixed-parameter tractable is given by proving that it is W[1]-hard. We refer to one of the textbooks~\cite{DowneyF13,FlumG06} for more background.

\textbf{Graphs.}
All graphs we consider are simple, undirected and finite. A graph~ consists of a set of vertices~ and edges~. Notation not defined here is standard. For a set of vertices~ we denote by~ the set~. A path in a graph~ is a sequence of distinct vertices such that successive vertices are connected by an edge. The first and last vertices on the path are its endpoints, the remaining vertices are its interior vertices. Given a graph~ and a vertex subset~, the operation of \emph{identifying} the vertices of~ into a new vertex~ is performed as follows: delete the vertices in~ and their incident edges, and insert a new vertex~ that is adjacent to~, i.e., to all remaining vertices of~ that were adjacent to at least one member of~.

\begin{proposition} \label{proposition:degtwo}
Let~ be a connected graph of minimum degree at least two with cyclomatic number~. The number of vertices in~ with degree at least three is bounded by~.
\end{proposition}
\begin{proof}
Denote by~ and~ the number of vertices in~ with degree two and at least three, respectively. Let~ and~ be the total number of vertices and edges in~, and let~ denote the degree of a vertex~. Since~ we have~. The value of~ can also be obtained as half the degree sum of~:

Hence we find:
 from which we obtain~ by subtracting~ on both sides and multiplying by two.
\qed
\end{proof}

\begin{proposition} \label{proposition:numcomponents}
Let~ be a connected graph of minimum degree at least two with cyclomatic number~ and let~ be the set of vertices of degree at least three. If~ then the number of connected components of~ is at most~.
\end{proposition}
\begin{proof}
As~ contains all vertices of degree at least three, every connected component~ of~ is a path. Since~ has minimum degree at least two, every endpoint of such a path has a neighbor in~. Hence for every connected component~ of~ there are exactly two edges between~ and~. Consider the multigraph~ on vertex set~ defined as follows. For every component~ of~, consider the two edges between~ and~  and let~ be their endpoints in~. We add an edge between~ and~ to~; if~ this becomes a self-loop, and there is the chance of creating parallel edges. Since~ is a connected topological minor of~ it is easy to see that the cyclomatic number~ of~ does not exceed that of~. Since~, we find that~. Since connected components of~ are in 1-to-1 correspondence with edges of~, this completes the proof.
\qed
\end{proof}

\textbf{Hitting set.} A set system~ can be viewed as a hypergraph whose vertices are~ and whose hyperedges are formed by the sets in~. A set system~ is a \emph{hypertree} if there is a tree~ on vertex set~ such that every set in~ induces a subtree of~. Testing whether a set system is a hypertree, and constructing a tree representation if this is the case, can be done in polynomial time~\cite{Trick87}. 

We frequently use the fact that a minimum hitting set for a hypertree can be found in polynomial time (cf.~\cite[\SSign 2]{GuoN06} for a view from a dual perspective). When a tree representation is known, a greedy algorithm can be used to find a minimum hitting set. If we root the tree at a leaf and find a vertex~ of maximum depth for which there is a set~ whose members all belong to the subtree rooted at~, then it is easy to show there is a minimum hitting set containing~. Consequently, we may add~ to the solution under construction, remove all sets hit by~, and remove all elements in the subtree rooted at~ from the universe.

This idea can be extended for the following setting. Suppose we have a graph~ that is isomorphic to a simple cycle and a set~ of paths in~. To find a minimum vertex set that hits all the paths in~, we try for each vertex~ of~ whether there is a minimum solution containing it. After removing~ and the paths hit by~, the remaining structure is a hypertree since the cycle breaks open when removing~. The minimum over all choices of~ gives an optimal hitting set. We will use this in our FPT algorithm to deal with a corner case.

\textbf{Multiple valued logic.} The hitting set problems we are interested in turn out to be related to variations of the \textsc{Satisfiability} problem that have been studied in the field of multiple valued logic. In a multiple valued logic, variables can take on more values than just~ and~: there is a \emph{truth value set} containing the possible values. For our application, the truth value set is totally ordered; it is a range of integers~. A \emph{regular sign} is a constraint of the form~ or~ for~. By constraining variables with regular signs, resulting in (generalized) literals of the form~ or~, and combining such literals with the usual logical connectives, one creates totally ordered regular signed formulas. As expected, the satisfiability problem for such formulas is to determine whether every variable can be assigned a value in the range~ such that the formula is satisfied. We shall be interested in the case of CNF formulas with clauses having at most two (2-SAT) or at most three (3-SAT) literals. 
\defparproblem{\SignedThreeSatn}
{A totally ordered regular signed 3-CNF formula with~ variables and truth value set~.}
{.}
{Is the formula satisfiable?}

For brevity we sometimes refer to this problem as \nTORSThreeSat. We also consider \TORSTwoSat, where clauses have at most two literals, which is polynomial-time solvable~\cite{Manya00}. In particular, \TORSTwoSat can be reduced to the 2-SAT problem in classical logic~\cite[\SSign 3]{BejarHM01}, which is well-known to be solvable in linear time~\cite{AspvallPT79}. For completeness, we sketch the reduction in Appendix~\ref{app:twosat}.

\section{Algorithms} \label{section:fpt}

The goal of this section is to develop an FPT algorithm for the following parameterized problem.

\defparproblem{\HitPathsInGraph}
{An undirected simple graph~ with cyclomatic number~, an integer~, and a set~ of simple paths in~.}
{.}
{Is there a set~ of size at most~ that hits all paths in~?}

The algorithm consists of two reductions. An instance of \HitPathsInGraph is reduced to a hitting set problem on a more structured graph, called a flower. An instance with such a flower structure can be reduced to a polynomial-time solvable 2-SAT problem in multiple valued logic. This section is structured as follows. We first describe the flower structure and the reduction to 2-SAT in Section~\ref{subsection:hit:flowers}. Afterward we show how to build an FPT algorithm from this ingredient, in Section~\ref{subsection:hit:paths}.

\subsection{Hitting Paths in Flowers} \label{subsection:hit:flowers}

The key notion in this section is that of a \emph{flower graph}, which is a graph~ with a distinguished vertex~ called the \emph{core} such that all connected components of~ are paths~ of which no interior vertex is adjacent to~. These paths are called \emph{petals} of the flower. When working with flower graphs we will assume an arbitrary but fixed ordering of the petals as~, as well as an orientation of each petal~ as consisting of vertices~. For ease of discussion we will interpret each petal to be laid out from left to right in order of increasing indices. We will give an FPT branching algorithm that reduces \HitPathsInGraph to solving several instances of the following more restricted problem.

\defproblem{\HitPathsInFlower}
{A flower graph~ with core~ and petals~, a set of simple paths~ in~, and a budget function~.}
{Is there a set~ that hits all paths in~ such that~ for all~?}

We show that \HitPathsInFlower can be solved in polynomial time. The following notion will be instrumental to analyze the structure of solutions to this problem.

\begin{definition} \label{definition:canonical}
Let~ be a petal of an instance~ of \HitPathsInFlower and let~. The \emph{canonical -th solution} for petal~ is defined by the following process.
\begin{enumerate}
	\item If there is a path in~ that is contained entirely within~, then define the canonical -th solution to be NIL.\label{step:earlyout}
	\item Otherwise, initialize~ as the singleton set containing~.
	\begin{enumerate}
		\item While there is a path in~ that is contained entirely within~ and is not intersected by~, consider a path among this set that minimizes the index~ of its right endpoint and add~ to~.\label{step:hitpath}
		\item While~ and~, add the highest-indexed vertex from~ to~. (Recall that~ is the budget for petal~.)\label{step:fillsize}
		\item If~, the canonical -th solution is~. If~, define the canonical -th solution to be NIL.\label{step:toolarge}
		\end{enumerate}
\end{enumerate}
A set~ is a canonical solution for petal~ if there is an integer~ for which~ is the canonical -th solution for~. A canonical solution is well defined if it is not NIL. A solution~ to the instance~ is \emph{globally canonical} if~ is a well-defined canonical solution for all~.
\end{definition}

Figure~\ref{fig:petals} illustrates these concepts. For a set~ we will denote by~ the highest index of any vertex in~, i.e., the index of the rightmost vertex of~. Similarly, we denote by~ the index of the leftmost vertex of~. The following observations about the procedure will be useful.

\begin{figure}[t]
\begin{center}
\subfigure[Flower.]{\label{fig:petal0}
\includegraphics[scale=1]{Canonical0}
}
\subfigure[-vertex petal.]{\label{fig:petal1}
\includegraphics[scale=1]{Canonical1}
}
\subfigure[Canonical solution.]{\label{fig:petal2}
\includegraphics[scale=1]{Canonical2}
}
\caption{(\ref{fig:petal0}) A flower graph with~ petals and core~. (\ref{fig:petal1}) A -vertex petal whose endpoints are adjacent to~. The target paths within the petal that must be hit by a solution are drawn stacked on top of each other. (\ref{fig:petal2}) The set~ is the -rd canonical solution of size~ for the petal, with respect to the target paths drawn in \ref{fig:petal1}. The corresponding partition of~ into two subpaths described in Observation~\ref{observation:partition} is shown above the petal. It includes the singleton path~. The canonical -st solution of size~ is NIL, since the procedure of Definition~\ref{definition:canonical} produces the set~, which is too large and is rejected in Step~\ref{step:toolarge}.}
\end{center}\label{fig:petals}
\end{figure}

\begin{observation} \label{observation:leftmost}
If~ is a well-defined canonical solution, then~.
\end{observation}

\begin{observation} \label{observation:partition}
Let~ result from Definition~\ref{definition:canonical}, and assume that Step~\ref{step:earlyout} does not apply and that Step~\ref{step:fillsize} is never triggered during the procedure. Partition the interval~ into~ maximal subpaths that each end at a vertex of~ and contain no other vertices of~. Then, for every such subpath~ except the singleton subpath~, there is a path in~ contained entirely within~.
\end{observation}

The main strategy behind our reduction of \HitPathsInFlower to \TORSTwoSat will be as follows. We will show that, if a solution to the hitting set problem exists, then there is a globally canonical solution. Such a solution can be fully characterized by indicating, for each petal, the index of the canonical solution on the petal (i.e., the leftmost vertex of the petal that is in the solution). Hence finding a solution reduces to finding a choice of canonical solutions on the petals. It turns out that for every path~, one can create a signed 2-clause on the variables controlling the choices on two petals, such that the path is hit by the selected solution if and only if the indices of the canonical subsolutions satisfy the 2-clause. This allows the hitting set problem to be modeled by \TORSTwoSat. We now formalize these ideas. Let us first get a feeling for canonical solutions by proving the following lemma.

\begin{lemma} \label{lemma:contiguous}
Let~ be an instance of \HitPathsInFlower and let~ be a petal. The indices for which~ has a well-defined canonical solution form a contiguous set of integers.
\end{lemma}
\begin{proof}
Assume for a contradiction that there are~ such that the canonical solutions for~ and~ are well-defined, but that for~ is not. Let us consider why the canonical solution for~ is not well-defined. 
\begin{enumerate}
	\item If Step~\ref{step:earlyout} applies for~, then the path~ that is contained entirely within~ also causes Step~\ref{step:earlyout} to apply for~, contradicting the assumption that there is a well-defined canonical solution for~.
	\item If~ is too small in Step~\ref{step:toolarge}, then this implies that there are less than~ vertices in~. But this contradicts the fact that~ has~ vertices and is a subset of~ for~.
	\item If~ is too large in Step~\ref{step:toolarge}, then its size exceeds~. Hence the precondition to Step~\ref{step:fillsize} never applied during the procedure for~. Consider the partition of the interval~ into~ subpaths as described in Observation~\ref{observation:partition}. Every subpath in the partition contains exactly one vertex of~, and all vertices of~ are in one such subpath. Observe that~, such that~ contains at most~ vertices in the interval~. Since~, there are at least two subpaths in the partition from which~ contains no vertex. Hence there is such a subpath, say~, that is not the singleton path~ and that contains no vertices of~. Then, by Observation~\ref{observation:partition}, there is a target path~ in~ that is entirely contained within~. But~ contains no vertex of this path, showing that~ does not intersect~, which contradicts the fact that the while-loop of Step~\ref{step:hitpath} terminated when defining~.
\end{enumerate}
As the cases are exhaustive, this concludes the proof.
\qed
\end{proof}

As the procedure of Definition~\ref{definition:canonical} can be implemented in polynomial time, the set of indices for which a petal has a canonical solution can be computed in polynomial time. We continue describing the structure of canonical solutions.

\begin{lemma} \label{lemma:latersolutionsreachfurther}
Let~ be an instance of \HitPathsInFlower and let~ be a petal. If~, and the -th and the~-th canonical solutions are well-defined as~ and~, then~.
\end{lemma}
\begin{proof}
Assume that~. We aim to apply Observation~\ref{observation:partition} to derive a contradiction. Since both canonical solutions are well defined, Step~\ref{step:earlyout} does not apply to~. As our assumption implies that the rightmost vertex of~ is not in~, it follows that Step~\ref{step:fillsize} never applied during the procedure for~. Since at least one vertex of~ lies right of~, and~ contains vertex~ that lies left of~, the partition of~ into~ subpaths described by Observation~\ref{observation:partition} contains at least two subpaths from which~ contains no vertex. Hence there is such a subpath~ that is not intersected by~ for which there is a target path~ contained entirely within~. This contradicts the fact that~ hits all paths contained entirely within~ by Step~\ref{step:hitpath} of Definition~\ref{definition:canonical}.
\qed
\end{proof}

We now establish that the hitting set problem has a globally canonical solution, if it has a solution at all. The proof exploits the fact that, after selecting the leftmost vertex of a petal to be used in the hitting set, removing it from the graph, and removing the paths hit by this vertex from the graph, the remainder of the petal turns into a pendant path that connects to the rest of the graph at vertex~. The hitting set problem has a greedy solution within this resulting path, which reflects the structure of the canonical solution. Formalizing this line of reasoning is tedious but straight-forward.

\begin{lemma} \label{lemma:existscanonical}
Let~ be an instance of \HitPathsInFlower having petals~. If the instance has a solution~, then it has a globally canonical solution~. \end{lemma}
\begin{proof}
Proof by induction on the number~ of petals for which~ is not a canonical solution. When~ the claim is trivial, so assume~ and let~ be a petal such that~ is not a canonical solution. Since~ is a solution, by the definition of \HitPathsInFlower we have~. Let~ be the index of the leftmost vertex from~ on~. Since~, such a vertex exists. Let~.

\begin{claim}
The -th canonical solution for~ is well defined.
\end{claim}
\begin{proof}
Consider the set~ resulting from the process of Definition~\ref{definition:canonical} and assume for a contradiction that the process defines the canonical -th solution to be NIL. There are two cases that yield NIL; we treat them consecutively.
\begin{enumerate}
	\item If the canonical solution is NIL because there is a path~ in~ that is contained entirely within~, then since~ is the index of the leftmost vertex from~ on~ we have~. Consequently, the set~ does not intersect path~, contradicting the assumption that~ is a solution.
	\item Consider the case that the canonical solution is NIL because the size of~ is not equal to~ in Step~\ref{step:toolarge}.
	\begin{enumerate}
		\item If~, then by the while-loop of Step~\ref{step:fillsize}, all vertices of~ are in~. Since~ and the leftmost vertex of~ on~ is~, the set~ cannot contain more vertices than~. But then~, showing that~ is not a solution.
		\item If~, Step~\ref{step:fillsize} never applied during the procedure. Consider the partition of the interval~ into~ subpaths as described in Observation~\ref{observation:partition}. Since every subpath in the partition contains exactly one vertex of~, and all vertices of~ are in one such subpath, it follows from~ that there is such a subpath, say~, containing no vertices of~. Since~ and~ both contain~, we know~ is not~. Then, by Observation~\ref{observation:partition}, there is a target path in~ that is entirely contained within~. But~ contains no vertex of this path, showing that~ is not a solution.
	\end{enumerate}
\end{enumerate}
As we covered all cases that lead to the canonical solution being NIL, this concludes the proof.
\claimqed
\end{proof}

In the remainder, let~ be the -th canonical solution for~, which is well defined by the previous claim.

\begin{claim}
.
\end{claim}
\begin{proof}
Consider the process of Definition~\ref{definition:canonical}. If the loop of Step~\ref{step:fillsize} was executed at least once, then the rightmost vertex of~ is in~ and the claim is trivially true. So assume that this is not the case, and assume for a contradiction that~. Consider the partition of the interval~ as in Observation~\ref{observation:partition}. Since~ and at least one vertex of~ does not lie in the interval~ since~, it follows that there is a subpath~ in the partition from which~ contains no vertices, and which therefore cannot be the subpath~. As there is a path~ that is entirely contained within~ by Observation~\ref{observation:partition}, the fact that~ and therefore~ contains no vertices from~ shows that~ is not a solution; contradiction.
\claimqed
\end{proof}

Using the previous claim we can finish the proof. Consider the set~, whose size equals that of~. We show that~ is a valid solution to the instance. To see that, observe that the budget constraints are trivially satisfied since~. To see that all paths in~ are hit by~, consider a path~. If~ is hit by~ then it is also hit by~. If~ is contained entirely within~, then by Step~\ref{step:hitpath} of Definition~\ref{definition:canonical} the path~ is hit by~ and thus by~. If~ is not contained entirely within~ and is not hit by~, then it enters the petal at the leftmost or rightmost vertex of the petal and contains a prefix or suffix of the petal. (Here we use the structure of the flower graph: the interior vertices of petal~ are not adjacent to any other vertex in the graph, only to their predecessor and successor on~.) Since~ hits~, it follows from the structure of the path in the petal that the leftmost or rightmost vertex of~ on~ hits~. But since the leftmost vertex of~ is~, which is also in~, and the rightmost vertex of~ does not have larger index than the rightmost vertex of~ by the previous claim, it follows that~ also hits~. Hence all paths in~ are hit by~, which is therefore a valid solution. Since the number of petals for which~ does not contain a canonical solution is less than for~, by induction it follows that there is a solution for the instance whose intersection with every petal is a canonical solution.
\qed
\end{proof}

\begin{lemma} \label{lemma:createliteral}
Let~ be an instance of \HitPathsInFlower. There is a polynomial-time algorithm that, given a path~ (not necessarily contained in~) which is a suffix or a prefix of a petal~, either correctly determines that no well-defined canonical solution for~ hits~, or produces a literal of the form~ or~ for~, such that the following holds.
\begin{enumerate}
	\item If~ is a globally canonical solution for the instance that hits~ and contains the -th canonical solution for petal~, then the literal is satisfied by setting~.
	\item If~ satisfies the literal and the -th canonical solution~ is well-defined, then~ is hit by~.
\end{enumerate}
\end{lemma}
\begin{proof}
The definition of the literal depends on whether~ is a suffix or a prefix of a petal. First consider the case that~ is a prefix of petal~. Observe that a well-defined canonical solution~ for~ hits~ if and only if~, since~ marks the index of the end of the prefix of~ used by~, and~ is the index of the leftmost vertex of the -th canonical solution on the petal by Observation~\ref{observation:leftmost}. Hence for this case we obtain the literal~.

Now consider the case that~ is a suffix of petal~. The situation is similar: a well-defined canonical solution~ hits the suffix~ if and only if~, i.e., when the rightmost vertex of the canonical solution lies right of the starting point of the suffix~. Since all canonical solutions for~ can be computed in polynomial time, we can efficiently find the indices~, if any, for which a canonical solution is well defined satisfying~. The indices for which a canonical solution is well defined form a contiguous set by Lemma~\ref{lemma:contiguous}. If~ holds for some~, then for all~ for which a canonical solution is well defined we have~ by Lemma~\ref{lemma:latersolutionsreachfurther}. Hence we can determine the smallest value~ for which this holds, and find that the canonical solution on~ hits~ if and only if its index is at least~. Hence we obtain the literal~. In the case that there is no well-defined canonical solution that hits the suffix, we report this instead.

The two correctness properties follow directly from the if-and-only-if nature of our arguments above.
\qed
\end{proof}

Using the lemmata developed so far, we can present a polynomial-time algorithm for the problem in flower graphs.

\begin{theorem} \label{theorem:pathsinflower:poly}
\HitPathsInFlower can be solved in polynomial time.
\end{theorem}
\begin{proof}
We show how to reduce an instance~ with petals~ to an equivalent instance of the polynomial-time solvable \TORSTwoSat problem. The main work will be done by Lemma~\ref{lemma:createliteral} to create the literals of the formula. Let~ be the maximum size of a petal. The truth value set for our multiple valued logic formula will be~. We create a variable~ for every petal~. The clauses in the formula are produced as follows.

\begin{enumerate}
	\item For every petal index~, we compute the values of~ for which the -th canonical solution for petal~ is well-defined, using the procedure of Definition~\ref{definition:canonical}. By Lemma~\ref{lemma:contiguous} these values form a contiguous interval, say~. We add the singleton clause~ to the formula, as well as the singleton clause~. If there is no well-defined canonical solution for~ then, by Lemma~\ref{lemma:existscanonical}, the hitting set instance has no solution. In this case we simply output the answer \no.
	\item For every path~ that is not contained entirely within a single petal (i.e., for every path that contains the core vertex~ of the flower) we do the following. If~ is the singleton path containing only vertex~, then we output \no as a solution is not allowed to contain vertex~; this path can never be hit. Otherwise, let~ be the two connected components of~. (In the exceptional case that~ has only a single component because~ has~ as an endpoint, take~ to be equal to~.) For~ let~ be the petal containing~ and invoke Lemma~\ref{lemma:createliteral} on~ with~. If the invocations for both values of~ produce a literal, say~ and~, then add the disjunction~ as a 2-clause to the formula. If one invocation concludes that no well-defined canonical solution hits the path, but the other invocation produces a literal, then add a singleton clause with the latter literal. Finally, if neither~ nor~ produces a literal, then neither of the subpaths of~ are hit by any well-defined canonical solution, and therefore the path~ is not hit by any canonical solution. (Recall that solutions are forbidden to contain~.)  Since, by Lemma~\ref{lemma:existscanonical}, a canonical solution exists if a solution exists at all, it follows that we can safely output \no and halt.
\end{enumerate}

The process above results in a totally ordered regular signed 2-SAT formula~ on~ variables with~ clauses, which is polynomial in the size of the total input. All numbers involved are in the range~ which is bounded by the order of the input graph~. The reduction can therefore be performed in polynomial time, and produces an instance of \TORSTwoSat of polynomial size, even when encoding the numbers in unary. It remains to prove correctness of the reduction.

\begin{claim}
Formula~ is satisfiable if and only if~ has a solution.
\end{claim}
\begin{proof}
() Suppose that the formula is satisfiable and consider a satisfying assignment to the variables~. Since the assignment satisfies the first type of clauses introduced, for every petal index~, if~ then the -th canonical solution for~ is well-defined. Initialize~ as an empty solution set. For each~ add the canonical solution for~ whose index is given by~ to the set~. Since well-defined canonical solutions for~ have size~ by Definition~\ref{definition:canonical}, this satisfies the budget constraints of the problem since the only vertices of~ added to~ are those of the canonical solution employed on that petal. As we trivially do not include~ in the solution~, to verify that~ is a valid solution it remains to check that~ intersects all paths in~. To this end, consider an arbitrary path~.

\begin{enumerate}
	\item If~ is contained entirely within one petal, say~, then observe that any well-defined canonical solution for petal~ hits~ by Step~\ref{step:hitpath} of Definition~\ref{definition:canonical}. Since a canonical solution for~ is included in~, the path~ is hit.
	\item If~ is not contained entirely within one petal, then by the structure of flower graphs we know that~ contains vertex~ and was considered in the second phase of the construction. Consider the clause created on account of~ during the construction above. Since the formula satisfies the clause, at least one literal is satisfied; say the literal for the subpath~ of~ residing in petal~. Then Lemma~\ref{lemma:createliteral} guarantees that the canonical solution employed on~ hits~, and therefore hits the larger path~ as well.
\end{enumerate}

\noindent As~ hits all paths in~, this proves the forward direction.

() For the reverse direction, suppose that~ has a solution. By Lemma~\ref{lemma:existscanonical} there is a globally canonical solution~. For every petal index~ let~ be such that~ includes the -th canonical solution on~, and assign variable~ the value~. Let us check that this assignment satisfies the formula. Every clause of the first type is satisfied by any setting corresponding to the index of a canonical solution, which is clearly the case. For the clauses of the second type that are produced on account of paths~, observe that~ intersects such a path in a connected component of~, since~. By Lemma~\ref{lemma:createliteral} this implies that the corresponding literal of the clause is satisfied, implying that the entire clause is satisfied. Hence all types of clauses are satisfied, showing the formula to be satisfiable.
\claimqed
\end{proof}

The claim shows that to solve the hitting set problem, it suffices to check the satisfiability of the polynomial-sized \TORSTwoSat instance. As the latter can be done in polynomial time, this proves Theorem~\ref{theorem:pathsinflower:poly}.
\qed
\end{proof}

\subsection{Hitting Paths in Graphs} \label{subsection:hit:paths}

In this section we will show that an instance of \HitPathsInGraph can be reduced to~ instances of \HitPathsInFlower. By the results of the previous section, this leads to an FPT algorithm. 

We will frequently use the following observation. It formalizes that if~ is a degree-one vertex in~ and we are looking for a set that hits all paths in~, then either there is a single-vertex path~, forcing~ to be in any solution, or there is an optimal solution that does not contain~.

\begin{observation} \label{observation:removeleaf}
Let~ be an instance of \HitPathsInGraph and let~ have degree at most one. 
\begin{enumerate}
	\item If the singleton path~ is contained in~, then~ is equivalent to the instance obtained by decreasing~ by one, removing~ from the graph, and removing all paths containing~ from~.
	\item Otherwise,~ is equivalent to the instance obtained by removing~ from the graph and replacing every path~ by~.
\end{enumerate}
The cyclomatic number is not affected by these operations.
\end{observation}

For an instance~ of \HitPathsInGraph and a vertex subset~, the \emph{cost of the subgraph induced by~}, denoted~, is defined as the minimum cardinality of a set that hits all paths~ for which~. Equivalently,~ is the minimum cardinality of a set that hits all paths~ in the graph~. Observe that if~ induces an acyclic subgraph of~, then this value is computable in polynomial time as discussed in Section~\ref{section:prelims}. To reduce the general \HitPathsInGraph problem to the version with budget constraints discussed in the previous section, the following lemma is useful for determining relevant values for the budgets.

\begin{lemma} \label{lemma:budget:on:paths}
Let~ be an instance of \HitPathsInGraph. Let~ be the vertices of degree unequal to two in~. There is a minimum-size hitting set~ for~ such that, for every connected component~ of~, we have~.
\end{lemma}
\begin{proof}
The fact that~ for all hitting sets of~ follows trivially since~ is a hitting set for the induced subinstance. For the other inequality we exploit the structure of the graph.

Let~ be a minimum-size hitting set for~, whose size may be less than~. We give a proof by induction on the number of components for which~ exceeds~. The statement is trivially true if this number is zero. Otherwise, fix a component~ for which~. As~ is a connected subgraph containing only vertices of degree two, the neighborhood~ has size at most two, and is contained within~. Let~ be a minimum-cardinality hitting set for the instance induced by~, of size~. Consider the set~, whose intersection with~ has size~. Since~ and~, the set~ is not bigger than~. We show it to be a hitting set as well. To see that, observe that all paths contained in~ are hit by~, as it is a solution to the subproblem induced by~. Any path intersecting~ that is not hit by~ was not included in the subinstance induced by~, and hence contains a vertex of~. Such paths are therefore hit by~. All paths that do not intersect~ are hit by~, and are therefore hit by its superset~ as well. It follows that~ is a hitting set of minimum cardinality. As the number of components~ from which it uses at least~ vertices is strictly smaller than for~ (the vertices of~ belong to~ and therefore do not increase this number, as components are taken of~), the proof now follows by induction.
\qed
\end{proof}

Using these ingredients we give an algorithm for \HitPathsInGraph.

\begin{theorem} \label{theorem:pathsingraph:fpt}
\HitPathsInGraph parameterized by cyclomatic number can be solved in time~.
\end{theorem}
\begin{proof}
When presented with an input~, the algorithm proceeds as follows. First, as a preprocessing step, the algorithm repeatedly removes vertices of degree at most one from the graph using Observation~\ref{observation:removeleaf}. If the resulting graph is empty, then we can simply decide the problem: the answer is \yes if and only if the value of~ was not decreased below zero by these operations. Otherwise we obtain a graph with minimum degree at least two. While this graph is disconnected, add an arbitrary edge between two distinct connected components. This does not change the answer to the instance (the paths~ to be hit are unchanged) and leaves the cyclomatic number unchanged. From now on we therefore assume that the instance we work with has minimum degree at least two and consists of a connected graph. For ease of notation, we refer to instance resulting from these steps simply as~. If~ consists of just a simple cycle (i.e.,~ is 2-regular) then we can decide the problem in polynomial time as discussed in Section~\ref{section:prelims}, so we focus on the case that the set~ of vertices of degree at least three is nonempty. By Proposition~\ref{proposition:degtwo}, the size of~ is bounded by~. The main idea of the algorithm is to use branching make two successive guesses. 
\begin{itemize}
	\item First, we guess which vertices from~ are used in a solution. Concretely, we try all subsets~ and test whether there is a solution~ for which~. 
	\item For every such set~, we do the following. By Lemma~\ref{lemma:budget:on:paths}, there is a minimum-size hitting set that intersects every component~ of~ (which is a path) in either~ or~ vertices. Let~ denote the set of these components. By Proposition~\ref{proposition:numcomponents}, we have~. We now guess the collection~ of components~ for which the solution uses~ vertices. Every guess~ defines a budget~ for each component~ as follows:  if~, and~ otherwise.
\end{itemize}

Having guessed both~ and~, we create an instance of \HitPathsInFlower to verify whether there is a hitting set~ for the paths~ such that~ and for all components~ of~ we have~. Observe that these constraints on~ completely determine its size, which must be~. Hence if the size exceeds~, then these guessed sets will not lead to a hitting set of the desired size, and can therefore be skipped. When we have a guess that leads to a hitting set size of at most~, we aim to produce an instance of \HitPathsInFlower to check whether there is a solution consistent with the guesses. To this end, initialize~ as a copy of~, and~ as a copy of~. We modify these structures to create an input on a flower graph. Throughout these modifications there will be a clear correspondence between components of~ and those of~, so that we may refer to the budgets of components~ of~. For each guess~ and~, we proceed as follows.

\begin{enumerate}
	\item Remove all the vertices of~ from the graph~ and remove all paths hit by~ from~.\label{flower:step:removeshitpaths}
	\item For all paths~ for which there is a component~ of~ such that all vertices of~ belong to~ and~, remove~ from the set~. All hitting sets that contain~ vertices from~ must hit~, so we can drop the constraint~ because we will introduce a budget constraint on~.\label{flower:step:removebudgethitpaths}
	\item For all components~ of~ such that~, do the following. Remove the vertices of~ from the graph~. For every~, replace~ by the subgraph~. This may cause the elements of~ to become disconnected subgraphs, rather than paths, but this will be resolved in the next step.\label{flower:step:splitpaths}
	\item The final step identifies several vertices in the graph into a single core vertex, to obtain a flower structure. Concretely, update the graph~ by identifying all vertices of~ into a single vertex~. Similarly, update every subgraph~ by identifying all vertices of~ into a single vertex~.\label{flower:step:merge}
\end{enumerate}

\begin{figure}[t]
\begin{center}
\subfigure[]{\label{fig:toflower1}
\includegraphics{ReduceToFlower1}
}
\subfigure[]{\label{fig:toflower4}
\includegraphics{ReduceToFlower4}
}
\subfigure[]{\label{fig:toflower3}
\includegraphics{ReduceToFlower3}
}
\subfigure[]{\label{fig:toflower5}
\includegraphics{ReduceToFlower5}
}
\caption{(\ref{fig:toflower1}) A graph with cyclomatic number~, whose vertices of degree~ are~. (\ref{fig:toflower4}) A simple path~ in the graph. (\ref{fig:toflower3}) Illustration of reduction Steps~\ref{flower:step:removeshitpaths} and~\ref{flower:step:merge} in the algorithm for the guess~. Vertices~ and~ are deleted, while~ and~ are identified into a single vertex~ to obtain a flower structure. (\ref{fig:toflower5}) Merging~ and~ into~ turns~ into a cyclic subgraph~. The bottom right petal is contained entirely within~. If its budget is positive, any solution hits~ in that petal, causing~ to be removed in Step~\ref{flower:step:removebudgethitpaths}. If its budget is zero, the vertices of the petal are removed from~ instead in Step~\ref{flower:step:splitpaths}, to eliminate the cycle.}\label{fig:mergeintoflower}
\end{center}
\end{figure}

Let~ denote the resulting graph and system of subgraphs. Refer to Figure~\ref{fig:mergeintoflower} for an illustration of these steps.

\begin{numberedclaim}
 is a flower with core~ and all subgraphs in~ are simple paths.
\end{numberedclaim}
\begin{proof}
Let us first verify that~ is indeed a flower. As every vertex of~ was either removed or merged into~, we find that~ is a subgraph of~. Since~ is the set of vertices of degree unequal to two, and~ had no vertices of degree at most one after preprocessing, every connected component of~ consists of vertices that have degree two in~ and therefore such components form paths. As~ is not empty, every such component has exactly two neighbors in~, which are adjacent to the first and last vertex of the path. Hence no interior vertex of such paths is adjacent to~. Since~ is a subgraph of~ it follows that all connected components of~ are paths and no interior vertex of such a path is adjacent to~. Hence~ is a flower with core~.

We continue by proving the second part of the claim. Consider a subgraph~ in the final set~, and let~ be the simple path in~ from which it originated. As~ is present after the last step, it follows that~ did not meet the precondition for removal in Step~\ref{flower:step:removeshitpaths} and therefore~, showing that~ is a simple path in~. Similarly, as~ was not removed by Step~\ref{flower:step:removebudgethitpaths} we know that~ does not fully contain any component~ of~ with positive budget. Consider what happens when deleting components~ with budget zero in Step~\ref{flower:step:splitpaths}. Since all vertices of~ have degree two in~, there are at most two components~ of~ from which~ contains at least one, but not all vertices: these are the components containing the endpoints of~. Hence if~ is transformed into a disconnected subgraph~ by Step~\ref{flower:step:splitpaths}, then (1)~ contains at least one vertex of~, and (2) there are at most two connected components in~, and both these components have (in subgraph~) a neighbor in~. This shows that when all vertices of~ are merged into a single vertex~ by Step~\ref{flower:step:merge}, then the disconnected subgraph~ is transformed into a path~ containing the core vertex~ in its interior. Hence all subgraphs~ in~ are simple paths.
\claimqed
\end{proof}

The claim shows that we can use the structures~ and~ resulting from the process above to formulate an instance of \HitPathsInFlower. To that end, we use~ as the flower graph,~ as the core, and~ as the set of paths to be hit. We number the connected components of~, which are the petals of the flower, as~. Each such petal corresponds to a connected component of~ for which we assigned a budget when guessing~; we define the budget function~ for the instance by letting~ be~ where~ is the component of~ corresponding to~. This results in a valid instance~ of \HitPathsInFlower. For the correctness of the algorithm, the following claim is crucial.

\begin{numberedclaim}
For every guess of~ and~, the following are equivalent. 
\begin{enumerate}
	\item There is a hitting set~ for the paths~ in graph~ such that~ and all components~ of~ satisfy~.\label{eqv:graphhitset}
	\item The produced instance~ of \HitPathsInFlower has a solution.\label{eqv:flowerhitset}
\end{enumerate}
\end{numberedclaim}
\begin{proof}
(\ref{eqv:graphhitset}\ref{eqv:flowerhitset}) Suppose there is a hitting set~ satisfying the stated conditions. We claim that~ is a solution for~. By the preconditions, set~ satisfies the budget constraints for the petals. Consider a path~ derived from a path~. Set~ does not hit~ in a component of~ with~, as~ contains no vertices of such components. Set~ does not intersect~ in a vertex of~, as such paths are not present in~ due to Step~\ref{flower:step:removeshitpaths}. It follows that~ intersects~ in a vertex~ of~ that lies in a connected component of~ with positive budget. Hence the component forms a petal~ in~, and the intersection of~ with the petal is contained in~. Hence~ hits~ at~. Since all paths in~ are hit, the budget constraints are met, and~, it follows that~ is a solution to~.

(\ref{eqv:flowerhitset}\ref{eqv:graphhitset}) For the reverse direction, suppose the flower problem has a solution~. We claim that~ is a hitting set for the paths~ in~ with~ for all components~ of~. The latter condition is easily verified: components~ with~ were discarded in Step~\ref{flower:step:splitpaths}, do not occur in~, and therefore~ contains no vertices of such components. For components with positive budget, which also exist in~, the budget constraints in the definition of \HitPathsInFlower ensure that~. Let us verify that~ indeed hits all paths~ in~ by considering an arbitrary~. If~ contains a vertex of~ then~ trivially hits~. Similarly, if~ fully contains a component~ of~ with~, then~ contains at least one vertex of~ and therefore of~; hence~ also hits~. In the remaining case, the construction of~ ensures that~ contains a path~ such that~ is a subgraph of~. Since~ hits~ in a vertex other than~, this vertex is included in~ and therefore~ hits~. It follows that~ is indeed a hitting set for all paths in~, which concludes the proof of the equivalence.
\claimqed
\end{proof}

Using the claim, the final part of the algorithm becomes clear. For every guess~ and~ that leads to a solution of size at most~, we construct the corresponding instance of \HitPathsInFlower and solve it using Theorem~\ref{theorem:pathsinflower:poly}. Since the flower instances are not larger than the input instance, this can be done in time~ for every guess. As there are~ options for~ and~ to check, the total running time is bounded by~. If one of the \HitPathsInFlower instances has answer \yes, then we output \yes; otherwise we output \no. In one direction, the correctness of this approach follows from the previous claim together with the facts that flower instances are only produced when the size of the resulting hitting sets is at most~. For the other direction, if~ has a hitting set of size at most~, then by Lemma~\ref{lemma:budget:on:paths} there is a minimum-cardinality hitting set~ (whose size is at most~) whose intersection with every component~ of~ is either~ or~. In the branch where~ and~ consists of the components where we use~ vertices, this leads to a \yes-instance of \HitPathsInFlower. This concludes the proof of Theorem~\ref{theorem:pathsingraph:fpt}.
\qed
\end{proof}

We remark that, while the previous theorem shows that \HitPathsInGraph is fixed-parameter tractable parameterized by the cyclomatic number, this problem is unlikely to admit a polynomial kernel. The general \HittingSet problem parameterized by the number of universe elements~ can be reduced to an instance of \HitPathsInGraph with cyclomatic number~: if we let~ be a complete~-vertex graph, which has cyclomatic number~, then we can model any subset of the universe as a simple path in~. Hence there is a polynomial-parameter transformation from \HittingSet parameterized by the universe size to \HitPathsInGraph parameterized by cyclomatic number. Since \HittingSet parameterized by universe size has no polynomial kernel unless \containment~\cite[Theorem 5.3]{DomLS14}, the same holds for \HitPathsInGraph parameterized by cyclomatic number.

\section{Hardness proofs} \label{section:hardness}

In this section we develop several hardness proofs. It turns out to be convenient to first prove the W[1]-hardness of 3-SAT in multiple valued logic. A similar result concerning the W[1]-hardness of \emph{not-all-equal} 3-SAT was obtained independently by Bringmann et al.~\cite{BringmannHML15}, who studied the problem under the name \textsc{NAE-Integer--SAT}.

\begin{theorem} \label{thm:threesat:whard}
The problem \SignedThreeSatn is W[1]-hard.
\end{theorem}
\begin{proof}
To establish the theorem we give an FPT-reduction from the W[1]-complete \kClique problem~\cite[Chapter 21]{DowneyF13}. Let~ be an instance of \kClique, asking whether the graph~ has a clique of size~. We use an edge representation strategy to encode this problem into an instance of \nTORSThreeSat whose parameter, the number of variables~ in the formula, is~. We may assume that~, as the instance is trivial otherwise. We may also assume that~ has no isolated vertices. The formula is constructed as follows.

There are variables~ corresponding to a choice of~ vertices in the clique. In addition, there are~ variables~ for~ that correspond to the edges between these vertices. The truth value set for the formula is the range of integers from~ to~, so~. Number the vertices of~ as~, and the edges from~ to~, arbitrarily. For every~ and for every possible edge index~, we add four clauses to the formula. Let~ be the endpoints of the -th edge such that~. We add the following clauses:
	
	
	To obtain a valid formula, we omit the literal~ when~, as do we omit the literal~ when~. These clauses are automatically satisfied if~, i.e., if~ does \emph{not} select the~-th edge. If~, however, then the clauses force~ to have the value~ and~ to have value~.
	
The conjunction of the produced clauses for all valid values of~, and~ forms the output formula. The construction can be performed in polynomial time and produces an instance of \nTORSThreeSat whose parameter~ is~, which is suitably bounded. To complete the proof it suffices to show that~ has a -clique if and only if the formula is satisfiable.

\begin{claim}
If~ has a -clique, then the formula is satisfiable.
\end{claim}
\begin{proof}
Consider a -clique in~ and let the indices of its vertices be~ in order of increasing value. For~ assign variable~ value~, and for~ assign variable~ the value of the index of the edge between~ and~. As observed above, the clauses that are created for values~ such that~ does not select the~-th edge, are satisfied. It is easy to verify that when~, the third literal of the created clauses is satisfied. Hence all clauses are satisfied and the formula is satisfiable.
\claimqed
\end{proof}

\begin{claim}
If the formula is satisfiable, then~ has a -clique.
\end{claim}
\begin{proof}
Consider an assignment to the variables that satisfies all clauses. Consider the values taken by the variables~. Suppose that some variable~ with~ has a value exceeding~. Then consider the value~ of variable~, and the clauses produced for this combination. Since~ is false, as is~, we must have~ where~ is the lowest-indexed endpoint of the -th edge; but this contradicts the assumption that~. A similar contradiction is reached when~ by considering variable~ instead. Hence the variables~ represent indices of vertices in~. 

Next, assume for a contradiction that there are indices~ such that~, and let~ be the value of variable~. As observed above, the clauses added for the combination~ are only satisfied if~ and~ represent the indices of the endpoints of the~-th edge. But since~ is a simple graph without self-loops, these indices are distinct and therefore these clauses cannot all be satisfied if~ and~ coincide. Hence the variables~ take~ distinct values in the range of~ to~.

We claim that the~ vertices in~ whose indices correspond to the values of~ form a clique. To see that all pairs of these vertices are adjacent in~, consider a pair~ and the value~ taken by variable~. The clauses produced for~ are only satisfied if~ is the lower-indexed endpoint of the -th edge and~ is the higher-index endpoint of that edge. Given the values of~ and~, the clauses can therefore only be satisfied if~ is the index of the edge between vertices with indices~ and~. Hence the edge connecting this pair must be present in~. As~ and~ were arbitrary, this shows that all vertex pairs are adjacent. Hence the set of vertices with indices~ is a -clique in~.
\claimqed
\end{proof}

This concludes the proof of Theorem~\ref{thm:threesat:whard}.
\qed
\end{proof}


Theorem~\ref{thm:threesat:whard} is used as the starting point for the next hardness proof.

\begin{theorem} \label{theorem:hitclaws:whard}
It is W[1]-hard to determine, given a graph~ with cyclomatic number~, a set~ of subgraphs of~, each isomorphic to a tree with at most three leaves, and an integer~, whether there is a set of~ vertices in~ that intersects all subgraphs in~.
\end{theorem}
\begin{proof}
We give an FPT-reduction from \nTORSThreeSat. Consider an instance of that problem, consisting of a signed 3-CNF formula over variables~ whose truth value set is~. We assume that there are no clauses that are trivially satisfied (that contain literals~ and~ for~), as they can be efficiently recognized and removed without changing the answer.

We construct a hitting set problem on a flower graph~ that has a core~ and~ petals~. Each petal is a path on~ vertices whose endpoints are adjacent to~. It is easy to see that this gives a cyclomatic number of at most~ for the graph~, as removing the~ edges from~ to the last vertex of each petal gives an acyclic graph. We seek a hitting set of size at most~.

Signed literals of the formula have the form~ or~ for~. We associate every literal to a prefix or suffix of a petal: a literal~ corresponds to the prefix~ of petal~, while a literal~ corresponds to the suffix~. For every clause~ of the formula, we consider the pre/suffixes associated to its literals. We add the subgraph~ that is induced by their vertices, together with~, to the set~ of subgraphs to be hit. Observe that, since there are no clauses that are trivially satisfied, each such subgraph~ induces a tree in~ with at most three leaves. In addition, for every petal~ we add the path~ as a subgraph to~. This concludes the description of the hitting set instance.

\begin{numberedclaim} \label{claim:hitset:iff:sat}
There is a hitting set of size at most~ if and only if the formula is satisfiable.
\end{numberedclaim} 
\begin{proof}
() Suppose there is a hitting set~ of size~. Since every petal~ is present as a subgraph in~ that must be hit, and the petals are pairwise disjoint, it follows that~ contains exactly one vertex of each petal. In particular, the core~ is not in~. Consider the assignment that sets the value of variable~ to the index of the vertex in~, which is a number in the range~. To see that an arbitrary clause~ is satisfied, consider the subgraph~ created on account of the clause, which consists of~ together with at most three pre/suffixes of petals, one for each literal of~. As the pre/suffix that is hit by~ corresponds to a literal that is satisfied by the assignment, clause~ is satisfied. As~ was arbitrary, the formula is satisfiable.

() Suppose that the formula is satisfied by a particular assignment to~. Let~ contain vertex~ for all~. Then all petals are hit by~, and all subgraphs~ added on account of a clause~ are hit at a pre/suffix corresponding to a literal in the clause that is satisfied.
\claimqed
\end{proof}

The claim shows the correctness of the reduction. It is a valid FPT-reduction since it can be executed in polynomial time and the new parameter~ equals the old parameter~. Since \SignedThreeSatn is W[1]-hard by Theorem~\ref{thm:threesat:whard}, this concludes the proof.
\qed
\end{proof}

By slightly modifying the construction, we can also obtain the following result which shows that hitting paths in graphs is para-NP-complete~\cite{FlumG06} parameterized by the feedback vertex number of the graph.

\begin{theorem} \label{theorem:hitpaths:fvs:npc}
It is NP-complete to determine, given a graph~ with a feedback vertex set of size two, a set~ of simple paths in~, and an integer~, whether there is a set of~ vertices in~ that intersects all paths in~.
\end{theorem}
\begin{proof}
The proof is similar to that of Theorem~\ref{theorem:hitclaws:whard}, so we only mention the key points. An instance of \SignedThreeSatn on variables~ with truth value set~ is reduced to an instance of the hitting set problem as follows. For every variable~ we create a new path~ on~ vertices in the graph. Finally we add two universal vertices~ to the graph, adjacent to all vertices on all created paths. The resulting graph~ has a feedback vertex set of size two, being~. For every~ we add~ to~ to ensure that a vertex of~ is selected in every hitting set. For every clause of the formula, we consider the (at most) three pre/suffixes of the petals~ corresponding to its literals, as in Theorem~\ref{theorem:hitclaws:whard}. Since both~ and~ are universal vertices, there is a simple path in~ consisting of the first pre/suffix, vertex~, the second pre/suffix, the vertex~, and ending with the last pre/suffix. For every clause we add such a path to~, which ensures that the clause must be satisfied when all paths are hit. Finally, we set the budget to~ to ensure that valid solutions select one value for each variable. Following the argumentation of Theorem~\ref{theorem:hitclaws:whard} it is easy to see that the reduction is correct. Since the \SignedThreeSatn problem is NP-complete, the theorem follows.
\qed
\end{proof}

We close this section on hardness by a discussion of subexponential-time algorithms. The construction in Theorem~\ref{theorem:hitpaths:fvs:npc} can be used to reduce an -variable instance of the classical 3-SAT problem (with binary variables) to the problem of hitting simple paths in a graph of cyclomatic number~. This implies that, assuming the exponential-time hypothesis~\cite{ImpagliazzoPZ01}, the dependence on~ in Theorem~\ref{theorem:pathsingraph:fpt} cannot be improved to~.

\section{Conclusion}

We have analyzed the problem of hitting subgraphs of a restricted form within a larger host graph, parameterized by structural measures of the host graph. There are several research directions related to this work that remain unexplored. For example, we have not touched upon the issue of computing, given a generic hitting set instance consisting of a set system~ over a universe~, how complex graphs on vertex set~ must be in which every set in~ induces a connected subgraph. What is the complexity of finding, given~ and~, a graph of minimum cyclomatic number that embeds~ in this way? Alternatively, what is the complexity of finding the minimum cyclomatic number of a graph~ such that for every set~, there is a simple path in~ on vertex set~? Efficient algorithms for this task 
could be used to transform generic hitting set instances into inputs of \HitPathsInGraph, on which Theorem~\ref{theorem:pathsingraph:fpt} can be applied.

One can also consider aggregate parameterizations of the hitting set problem using the measure of structure introduced here. We have shown that \HitPathsInGraph is FPT parameterized by the cyclomatic number. It is well known that the general \HittingSet problem is FPT parameterized by the number of sets, as it can be solved by dynamic programming. Suppose we have a \HittingSet instance where there are~ arbitrary sets, and there is a graph~ of cyclomatic number~ such that the remaining sets correspond to paths in~. Is \HittingSet parameterized by~ FPT, when this structure is given?

The complexity of the problem changes significantly when weights are introduced for the elements in the universe and the task is to find a minimum-weight hitting set. A simple reduction from \VertexCover shows that finding a minimum-weight set that hits a prescribed set of three-vertex paths in a star graph is already NP-complete. This suggests some topics for further investigation; we list some examples.

\begin{enumerate}
	\item Is the problem of finding a minimum-weight vertex set that hits a prescribed set of \emph{directed paths} in a \emph{directed tree} polynomial-time solvable?
	\item What is the parameterized complexity of the problem of hitting weighted paths in a tree plus~ edges, when the largest weight value is bounded by a constant?
\end{enumerate}

\textbf{Acknowledgments}. We are grateful to Mark de Berg and Kevin Buchin for interesting discussions that triggered this research.

\bibliographystyle{abbrvurl}
\bibliography{../Paper}

\clearpage

\appendix

\section{Reducing signed 2-SAT to classic 2-SAT} \label{app:twosat}
Given a totally ordered regular signed 2-SAT formula, replace each literal of the form~ by~, noting that if~ the clause is always satisfied and can be removed instead. The resulting clauses consist of literals~ and~ for~. To construct a classical 2-SAT formula, we interpret every term of the form~ as a new variable, such that we have a variable~, another variable~, and so on. The resulting 2-SAT formula over this new set of variables consists of the clauses resulting from our conversion process above, together with clauses~ for all~ and~. Observe that such clauses may also be represented as~, which shows they are valid 2-clauses. Finally, we add singleton clauses~ for all~. We invite the reader to verify that the resulting classical formula on variables~ is classically satisfiable if and only if the signed formula is satisfiable over truth value set~.

\end{document}