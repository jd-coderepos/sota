\documentclass{LMCS}

\def\doi{8 (2:09) 2012}
\lmcsheading {\doi}
{1--30}
{}
{}
{Nov.~20, 2011}
{Jun.~\phantom04, 2012}
{}

\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{stmaryrd}
\usepackage{verbatim}
\usepackage{fancyvrb}

\usepackage[all]{hypcap}
\hypersetup{pdftitle=Refining Inductive Types,
            pdfauthor=Robert Atkey and Patricia Johann and Neil Ghani}
\def\sectionautorefname{Section}
\def\subsectionautorefname{Section}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage[all]{xy}

\newcommand{\tyname}[1]{\texttt{#1}}
\newcommand{\consname}[1]{\texttt{#1}}
\newcommand{\neutral}[1]{\texttt{#1}}

\newcommand{\inn}{\mathit{in}}
\newcommand{\cat}[1]{\mathcal{#1}}
\newcommand{\sepbar}{\mathrel|}
\newcommand{\fold}[1]{\llparenthesis #1 \rrparenthesis}
\newcommand{\Id}{\mathrm{Id}}
\newcommand{\Fam}{\mathrm{Fam}}
\newcommand{\Sub}{\mathrm{Sub}}
\newcommand{\Set}{\mathrm{Set}}
\newcommand{\Alg}{\mathrm{Alg}}
\newcommand{\palg}{U^{\mathsf{Alg}}}
\newcommand{\sigmaAlg}{\Sigma^{\mathsf{Alg}}}
\newcommand{\reindAlg}{*{\mathsf{Alg}}}
\newcommand{\truthalg}{\top^{\mathsf{Alg}}}
\newcommand{\compralg}[1]{\{#1\}^{\mathsf{Alg}}}
\newcommand{\ok}{\mathsf{ok}}
\newcommand{\fail}{\mathsf{fail}}

\newtheorem{eorollary}{Example}

\newcommand{\parenref}[1]{\hyperref[#1]{(\ref*{#1})}}
\newcommand{\lemref}[1]{\hyperref[#1]{Lemma \ref*{#1}}}
\newcommand{\thmref}[1]{\hyperref[#1]{Theorem \ref*{#1}}}
\newcommand{\propref}[1]{\hyperref[#1]{Proposition \ref*{#1}}}
\newcommand{\corref}[1]{\hyperref[#1]{Corollary \ref*{#1}}}
\newcommand{\conref}[1]{\hyperref[#1]{Conjecture \ref*{#1}}}
\newcommand{\exref}[1]{\hyperref[#1]{Example \ref*{#1}}}


\newcommand{\zip}{\mathit{zip}}
\newcommand{\tail}{\mathit{tail}}
\newcommand{\ve}{\mathsf{Vec}}
\newcommand{\nil}{\mathsf{Nil}}
\newcommand{\cons}{\mathsf{Cons}}
\newcommand{\z}{\mathsf{Z}}
\newcommand{\s}{\mathsf{S}}
\newcommand{\sz}{\mathsf{Sz}}
\newcommand{\su}{\mathsf{Ss}}
\newcommand{\data}{\mathsf{data}}
\newcommand{\where}{\mathsf{where}}

\newcommand{\pushoutcorner}[1][dr]{\save*!/#1+1.2pc/#1:(1,-1)@^{|-}\restore}
\newcommand{\pullbackcorner}[1][dr]{\save*!/#1-1.2pc/#1:(-1,1)@^{|-}\restore}
\newcommand{\fixme}[1]{\textbf{FIXME: #1}}
\newcommand{\adjunction}[4]{\xymatrix{ {#1} \ar@/_/[r]_{#4}
    \ar@{}[r]|{\perp}& \ar@/_/[l]_{#3} {#2} }}

\begin{document}

\title[Refining Inductive Types]{Refining Inductive Types}

\author[R.~Atkey]{Robert Atkey}
\address{University of Strathclyde, UK}
\email{\{Robert.Atkey,Patricia.Johann,Neil.Ghani\}@cis.strath.ac.uk}

\author[P.~Johann]{Patricia Johann}


\author[N.~Ghani]{Neil Ghani}


\keywords{inductive types, dependent types, category theory, fibrations, 
refinement types}
\subjclass{D.3.3; F.3.3; D.3.1; F.3.2; F.3.1}

\begin{abstract}
  Dependently typed programming languages allow sophisticated
  properties of data to be expressed within the type system. Of
  particular use in dependently typed programming are indexed types
  that refine data by computationally useful information.  For
  example, the -indexed type of vectors refines lists by
  their lengths. Other data types may be refined in similar ways, but
  programmers must produce purpose-specific refinements on an {\em ad
    hoc} basis, developers must anticipate which refinements to
  include in libraries, and implementations must often store redundant
  information about data and their refinements. In this paper we show
  how to generically derive inductive characterisations of refinements
  of inductive types, and argue that these characterisations can
  alleviate some of the aforementioned difficulties associated with
  {\em ad hoc} refinements. Our characterisations also ensure that
  standard techniques for programming with and reasoning about
  inductive types are applicable to refinements, and that refinements
  can themselves be further refined.
\end{abstract}

\maketitle

\section{Introduction}\label{sec:introduction}

One of the key aims of current research in functional programming is
to reduce the {\em semantic gap} between what programmers know about
computational entities and what the types of those entities can
express. One particularly promising approach to closing this gap is to
{\em index} types by extra information that can be used to express
properties of their elements. For example, most functional languages
support a standard list data type parameterised over the type of the
data lists contain, but for some applications it is also convenient to
be able to state the length of a list in its type. This makes it
possible, for instance, to ensure that the list argument to the
\verb|tail| function has non-zero length --- i.e., is non-empty ---
and that the lengths of the two list arguments to \verb|zip| are the
same. Without this kind of static enforcement of preconditions,
functions such as these must be able to signal erroneous arguments ---
perhaps using an error monad, or a built-in exception facility --- and
their clients must be able to handle the cases in which an error is
raised.

A data type that equips each list with its length can be defined in
the dependently typed language Agda 2~\cite{agda10} using the
following declaration:
\begin{verbatim}
data Vector (B : Set) : Nat -> Set where
  nil  : Vector B zero
  cons : {n : Nat} -> B -> Vector B n -> Vector B (succ n)
\end{verbatim}

\noindent
This declaration\footnote{The \texttt{\{X : S\}} notation indicates
  that there is an implicit parameter of type \texttt{S}, named
  \texttt{X}. When applying a function with an implicit argument, Agda
  2 will attempt to infer a suitable value for it.} inductively
defines, for each choice of element type \verb|B|, a data type
\verb|Vector B| that is indexed by natural numbers and has two
constructors: , which constructs a vector of data with
type \verb|B| of length zero (here represented by the data constructor
 for the natural numbers), and ,
which constructs from an index , an element of
, and a vector of data with type \verb|B| of length
, a new vector of data with type \verb|B| of length
 (here represented by the application
 of the data constructor
 for the natural numbers to ). The
inductive type \verb|Vector B| can be used to define functions on
lists with elements of type \verb|B| that are ``length-aware'' in a
way that functions processing data of standard list types cannot
be. For example, it allows length-aware \verb|tail| and \verb|zip|
functions to be given via the following Agda 2 types and definitions:

\begin{verbatim}
tail : {B : Set} -> {n : Nat} -> Vector B (succ n) -> Vector B n
tail (cons b bs) = bs

zip  : {B C : Set} -> {n : Nat} -> 
         Vector B n -> Vector C n -> Vector (B x C) n
zip  nil         nil        = nil
zip (cons b bs) (cons c cs) = cons (b , c) (zip bs cs)
\end{verbatim}

\noindent
Examples such as these suggest that indexing types by computationally
relevant information has great potential. However, for this potential
to be realised we must better understand how indexed types can be
constructed. Moreover, since we want to ensure that all the techniques
that have been developed for structured programming with and
principled reasoning about inductive types\footnote{Recall that an
  inductive data type is one that an be represented as the least fixed
  point  of a functor  on a category suitable for
  interpreting the types in a language.} --- such as those championed
in the Algebra of Programming~\cite{bdm97} literature --- are
applicable to the resulting indexed types, we also want these types to
be inductive.  This paper therefore asks the following fundamental
question:

\vspace*{0.1in}

\begin{quote}
  \em Can elements of one inductive type be systematically augmented
  with computationally relevant information to construct an indexed
  inductive type that captures the computationally relevant
  information in their indices? If so, how?
\end{quote}

\vspace*{0.1in}

\noindent
That is, how can we {\em refine} an inductive type to get a new type,
called a {\em refinement}, that associates to each element of the
original type its index, and how can we ensure that the resulting
refinement is inductive?

\subsection{A Naive Solution}

One straightforward way to refine an inductive type is to use a
refinement function to compute the index for each of its elements and
then to associate these indices to their corresponding elements. To
refine lists by their lengths, for example, we would start with the
standard list data type, which has the following Agda 2
declaration\footnote{Agda 2 allows overloading of constructor names,
  so we reuse the constructor names \texttt{nil} and \texttt{cons}
  from the \texttt{Vector} type defined above.}:
\begin{verbatim}
data List (B : Set) : Set where
  nil  : List B
  cons : B -> List B -> List B
\end{verbatim}
We would then define the following function \verb|length| by
structural recursion on elements of \texttt{List B}\,:
\begin{verbatim}
length : {B : Set} -> List B -> Nat
length nil         = zero
length (cons _ bs) = succ (length bs)
\end{verbatim}
From these we would construct the following refinement of lists by the
function \verb|length|, using a subset type: 

(alternatively, we could have also used a -type to hold the
list  and the proof that .)  Note that this construction is {\em global} in that
both the data type and the collection of indices exist {\em a priori},
and the refinement is obtained by assigning, {\em post facto}, an
appropriate index to each data type element. It also suffers from a
serious drawback: the resulting refinement --- \verb|ListWithLength B|
here --- is not presented as an inductive type, so the naive solution
is not a solution to the fundamental question posed above. (In
addition, the refinement \verb|ListWithLength B| does not obviously
have anything to do with the type \texttt{Vector B}.) So the question
remains: how do we get the inductive type \texttt{Vector B} from the
inductive type \texttt{List B}?

\subsection{A Better Solution}\label{sec:better-solution}

When the given refinement function is computed by structural recursion
(i.e., by the fold) over the data type to be refined --- as is the
case for the function \verb|length| above and is often the case in
practice --- then we can give an alternative construction of
refinements that provides a comprehensive answer to the fundamental
question raised above.  In this case we can construct, for each
inductive type  and each -algebra  whose fold
computes the desired refinement function, a functor  whose
least fixed point  is the desired refinement. This
construction is the central contribution of the paper.  Our
characterisation of the refinement of  by  as the
inductive type  allows the entire arsenal of structured
programming techniques based on initial algebras to be brought to bear
on the resulting refinement. By contrast with the construction
in \parenref{eqn:vector} above, our characterisation is also {\em
  local}, in that the indices of recursive substructures are readily
available {\em at the time a structurally recursive program is
  written}, rather than needing to be computed by inversion at run
time from the index of the input data structure to the program.

For each functor  and -algebra , the functor
 that we construct is intimately connected with the
generic structural induction rule for the inductive type , as
presented by Hermida and Jacobs \cite{hermida98structural} and by
Ghani, Johann, and Fumex \cite{ghani10induction}. This is perhaps not
surprising: structural induction proves properties of functions
defined by structural recursion on elements of inductive types. If the
values of such functions are abstracted into the indices of associated
indexed inductive types, then their computation need no longer be
performed during inductive proofs. In essence, work has been shifted
away from computation and onto data. Refinement can thus be seen as
supporting reasoning by structural induction ``up to'' the index of a
term.

\subsection{The Structure of this Paper}

The remainder of this paper is structured as follows. In
\autoref{sec:f-algebras} we introduce inductive types and recall their
representation as carriers of initial algebras of functors. We first
recall that, for any functor , the collection of -algebras
forms a category, and then give a key theorem due to Hermida and
Jacobs~\cite{hermida98structural} relating different -algebras and,
thereby, different refinements of . In \autoref{sec:families}
we define the fibrational framework for refinements with which we work
in this paper, and introduce the important idea of the lifting of a
functor. In \autoref{sec:refining-inductive} we show how liftings can
be used to refine inductive types, prove the correctness of our
construction of refinements, and illustrate our construction with some
simple examples.  In \autoref{sec:indexed-refinement} we show how to
refine inductive types that are themselves already indexed, thus
extending our construction to allow refinement of the whole range of
indexed inductive types available in dependently typed languages.  In
\autoref{sec:partial-refinement} we further extend our basic
refinement technique to allow partial refinement, in which indexed
types are constructed from inductive types not all of whose elements
have indices. Our motivating example here is that of expressions that
can fail to be well-typed. Indeed, we refine the type of possibly
ill-typed expressions by a type checker to yield the indexed inductive
type of well-typed expressions. In \autoref{sec:zygo-refine} we extend
the basic notion of refinement in yet another direction to allow
refinement by paramorphisms --- also known as primitive recursive
functions --- and their generalisation zygomorphisms. Perhaps
surprisingly, this takes us from the world of indexed inductive types
to indexed induction-recursion, in which inductive types and recursive
functions are defined simultaneously.  In \autoref{sec:discussion} we
conclude and discuss related and future work.

Throughout this paper, we adopt a semantic approach based on category
theory because it allows a high degree of abstraction and
economy. More specifically, we develop our theory in the abstract
setting of fibrations~\cite{jacobs99book}. Nevertheless, we specialise
to the families fibration over the category of sets in order to
improve accessibility and give concrete intuitions;
\autoref{sec:families} gives the necessary definitions and
background. Moreover, carefully using only the abstract structure of
the families fibration allows us to expose crucial structure that
might be lost were a specific programming notation to be used. This
structure both simplifies our proofs and facilitates the iteration of
our construction detailed in \autoref{sec:indexed-refinement}. It also
highlights the commonalities between the various constructions we
present. In particular, each of the refinement processes we discuss
produces functors of the form , where  is
the lifting of the functor  defining the data type  to be
refined. We are currently investigating whether this observation leads
to a more general theory of refinement, as well as its potential use
in structuring an implementation. A type-theoretic, rather than
categorical, answer to the fundamental question this paper addresses
has already been given by McBride~\cite{mcbride10ornaments} using his
notion of ornaments for data types (see \autoref{sec:discussion}).

\subsection{Differences from the Previously Published Version}

This paper is a revised and expanded version of the FoSSaCS 2011
conference version \cite{atkey11refinement}. Additional explanations
have been provided throughout, examples have been expanded, and some
of the material has been reordered for
clarity. \autoref{sec:indexed-ind-types}, which explains in more
detail the connection between initial algebras and the indexed
inductive types present in systems such as Agda 2, is entirely
new. \autoref{sec:zygo-refine}, which discusses the connection between
refinement by zygomorphisms and indexed inductive-recursive
definitions, is also completely new, and represents significant
further development of our basic refinement technique.

\section{Inductive Types and -algebras}\label{sec:f-algebras}

A data type is {\em inductive (in a category )} if it is the
least fixed point  of an endofunctor  on , in a
sense to be made precise in \autoref{sec:f-algs} below. For example,
if  denotes the category of sets and functions,  is
the set of integers, and  and  denote the coproduct and
product, respectively, then  for the
endofunctor  on 
represents the following data type of binary trees with integer data
at the leaves:
\begin{verbatim}
data Tree : Set where
    leaf : Integer -> Tree
    node : (Tree x Tree) -> Tree
\end{verbatim}

\subsection{-algebras}\label{sec:f-algs}

Our precise understanding of inductive types comes from the
categorical notion of an -algebra. If  is a category and
 is an endofunctor on , then an \emph{-algebra} is a
pair  comprising an object  of 
and a morphism  in . The object  is
called the \emph{carrier} of the -algebra, and the morphism
 is called its \emph{structure map}. We usually refer to an
-algebra solely by its structure map , since the
carrier is present in the type of this map.

An \emph{-algebra morphism} from  to  is a morphism  of  such that . An -algebra  is
\emph{initial} if, for any -algebra , there
exists a unique -algebra morphism from  to . If it
exists, the initial -algebra is unique up to isomorphism, and
Lambek's Lemma further ensures that the\footnote{We identify
  isomorphic entities when convenient. When doing so, we write  in
  place of .}  initial -algebra is an isomorphism. Its
carrier is thus the least fixed point  of . We write  for the initial -algebra, and
 for the unique morphism from  to any -algebra . We write
 for  when  is clear from context.  Of
course, not all functors have initial algebras. For instance, the
functor  on  does not have an initial
algebra.

In light of the above, the data type  can be
interpreted as the carrier of the initial
-algebra. In functional programming terms, a
function  is an
-algebra, and the function  induced by the initiality property is exactly the
application to  of the standard iteration function
 for trees (actually, the application of \verb|fold| to
an ``unbundling'' of  into replacement functions, one for each
of 's constructors). More generally, for each
functor , the function 
is the standard iteration function for .

\subsection{Indexed Inductive Types as
  -Algebras}\label{sec:indexed-ind-types}  

Indexed types can be inductive, and this gives rise to the notion of
an {\em indexed inductive type}. Such a type is also called an {\em
  inductive family} of types~\cite{dybjer94inductive}. Indexed
inductive types can be seen as initial -algebras for endofunctors
 on categories of indexed sets. For example, if  is a set of
elements, then we can define a functor  on the
category of -indexed sets whose least fixed point
represents the inductive data type  from
\hyperref[sec:introduction]{introduction}. The two constructors
 and  are reflected in the definition of
 as a coproduct, the individual arguments to
each constructor are reflected as products within each summand of this
coproduct, and the implicit equality constraints on the indices are
reflected as explicit equality constraints. We define

where the notation  denotes the set  when
 and the empty set otherwise.  The carrier of the initial
algebra  of this functor
consists of the -indexed family  of sets of vectors with elements from ,
together with a function  that ``bundles
together'' the constructors  and . In
\autoref{sec:refining-examples} below we show how
 can be \emph{derived} from the functor
 whose least fixed point is the inductive type of
lists with elements from , together with the algebra
 whose fold is the standard length function on
lists.

In general, -indexed inductive types can be understood as initial
algebras of functors . In
\autoref{sec:families} below we will see how the collection of
categories of indexed sets can be organised into the \emph{families
  fibration}, in which we carry out the constructions giving rise to
our framework for refinement.

\subsection{Categories of -algebras}

If  is an endofunctor on , we write  for the
category whose objects are -algebras and whose morphisms are
-algebra morphisms between them. Identities and composition in
 are taken directly from . The existence of initial
-algebras is equivalent to the existence of initial objects in the
category .

In Theorems~\ref{thm:initial-fhat-algebra}
and~\ref{thm:partial-refinement} below, we will have an initial object
in one category of algebras and want to show that applying a functor
to it gives the initial object in another category of algebras. We
will use adjunctions to do this. Recall that an {\em adjunction}
 between two categories 
and  consists of a left adjoint functor , a right adjoint
functor , and an isomorphism natural in  and  between the set
 of morphisms in  from  to  and the set
 of morphisms in  from  to . We say
that the functor  is {\em left adjoint} to , and that the
functor  is {\em right adjoint} to , and we write . To lift adjunctions to categories of algebras, we will make much
use of the following theorem of Hermida and Jacobs
\cite{hermida98structural}:
\begin{thm}\label{thm:alg-adjunctions}
  If  and  are
  functors, , and  is a natural
  isomorphism, then the adjunction
   lifts to an adjunction
  .
\end{thm}

\noindent
In the setting of the theorem, if  has an initial algebra, then so
does  since left adjoints preserve colimits and in particular
initial objects. To compute the initial -algebra in concrete
situations we need to know that ,
where  is (one half of) the natural isomorphism between 
and . Then the initial -algebra is given by applying
 to the initial -algebra, i.e., , and hence .

\section{A Framework for Refinement}\label{sec:families}

We develop our theoretical framework for refinement in the setting of
fibrational models of extensional Martin-L\"of type theory, which is a
key theory underlying dependently typed programming.  Since the
concepts and terminology of fibrational category theory will not be
familiar to most readers, we have taken care to formulate each of our
definitions and main theorems in the families fibration. The families
fibration gives the archetypal semantics of Martin-L\"of type theory,
in which indexed types are interpreted directly as indexed sets. In
this section we define the families fibration, and identify the parts
of its structure that we require for the rest of the paper. As readers
who are familiar with the categorical notion of fibration will
observe, the terminology and structure that we identify comes from
fibred category theory. We take care to identify the particular
properties of the families fibration that are required for our results
to hold, and refer to the literature for the formulation of these
properties in the general setting.

\subsection{The Families Fibration}

As is customary, we model indexed types in the category .
An object of  is a pair  comprising a set  and a
function ; such a pair is called a {\em family} of
sets. We denote a family  as  when convenient,
or simply as  when  can be inferred from context. A morphism
 of  is a pair of
functions  and . From a programming perspective, a family  is an
-indexed type , where  represents the collection of data
with index . An alternative, logical, view is that  is a
predicate representing a property  of data of type , and that  represents the collection of proofs that  has property . When
 is inhabited,  is said to {\em hold} for . When  is
empty,  is said {\em not to hold} for . We will freely switch
between the programming and logical interpretations of families when
providing intuition for our formal development below.

The {\em families fibration}  is the functor
mapping each family  to  and each morphism  to
. The category  is referred to as the {\em base category} of
the families fibration and  is referred to as its {\em
  total category}. For each set , the category 
consists of families  and morphisms  between them
such that . Such a morphism is said to be a {\em
  vertical morphism}. Similarly, a {\em vertical natural
  transformation} is a natural transformation each of whose components
is a vertical morphism. We say that an object or morphism in
 is {\em over}  with respect to the families
fibration, and call  the \emph{fibre} of the families
fibration over .  A function  contravariantly
generates a \emph{reindexing functor}  for the families fibration that maps  to .

\subsection{Truth and Comprehension}\label{sec:truth-compr}

Each fibre  has a terminal object , where  is the canonical singleton set.  In light of the
logical reading of families above, this object is called the {\em
  truth predicate} for . The mapping of objects to their truth
predicates extends to a functor , called
the {\em truth functor} for the families fibration.  In addition, for
each family  we can define the {\em comprehension} of ,
denoted , to be , i.e., . The comprehension  packages
elements  with proofs .  The mapping of families to
their comprehensions extends to a functor , called the {\em comprehension functor} for the families
fibration. Overall, we have the following pleasing collection of
adjoint relationships:


The families fibration  is thus a \emph{comprehension category with
  unit} \cite{jacobs93comprehension,jacobs99book}. Like every
comprehension category with unit,  supports a natural
transformation  such that 
for all  in , projecting out the  component from
a comprehension. In fact,  is a {\em full comprehension category
with unit}, i.e., the functor from  to  induced
by  is full and faithful. Here,  is the {\em arrow
  category} of . Its objects are morphisms of  and its
morphisms from  to  are pairs  of morphisms in  such that . Fullness means that the action of  on
morphisms is surjective, and faithfulness means that it is injective.
Fullness will be used in the proof of \thmref{thm:change-of-base}
below, when we consider refinements of indexed types.

\subsection{Indexed Coproducts}\label{sec:sums}

For each function  and family , we can form the
family , called the {\em indexed coproduct of  along }.
The mapping of each family to its indexed coproduct along  extends
to a functor  which is left
adjoint to the reindexing functor  for the families fibration.
In the abstract setting of fibrations, a fibration with the property
that each re-indexing functor  has a left adjoint  is
called a \emph{bifibration}, and the functors  are called
{\em op-reindexing} functors. A bifibration that is also a full
comprehension category with unit is called a {\em full cartesian
  Lawvere category}~\cite{jacobs93comprehension}. The families
fibration is a full cartesian Lawvere category.

The functors  are often subject to the Beck-Chevalley
condition for coproducts, which is well-known to hold for the families
fibration. This condition ensures that, in certain circumstances,
op-reindexing commutes with re-indexing~\cite{jacobs99book}. It is
used in the proof of \lemref{lem:lifting-commute-reindex}.

At several places below we make essential use of the fact that the
families fibration has very strong coproducts, i.e., that in the diagram

\noindent
where  is the obvious map of families of sets over ,
 is an isomorphism. This notion of very strong coproducts
naturally generalises the usual notion of strong
coproducts~\cite{jacobs99book}, and imposes a condition that is
standard in models of type theory.

\subsection{Indexed Products}\label{sec:indexed-products}

For each function  and family  we can also form
the family , called the {\em indexed product of  along }.  The
mapping of each family to its indexed product along  extends to a
functor  which is right adjoint
to the reindexing functor  for the families fibration. Altogether
we have the following collection of relationships for each function :


\noindent
Like its counterpart for indexed coproducts, the Beck-Chevalley
condition for indexed products is often required and indeed it holds
in the families fibration. We do not make use of this condition in
this paper.

\subsection{Liftings}\label{sec:fibrational-ind}

The relationship between inductive types and their refinements can be
given in terms of liftings of functors. A {\em lifting} of a functor
 is a functor 
such that .  A lifting is {\em
  truth-preserving} if there is a natural isomorphism . Truth-preserving liftings for all
polynomial functors --- i.e., for all functors built from identity
functors, constant functors, coproducts, and products --- were given
by Hermida and Jacobs~\cite{hermida98structural}.  Truth-preserving
liftings were established for arbitrary functors by Ghani \emph{et
  al.}~\cite{ghani10induction}.  Their truth-preserving lifting
 is defined on objects by


\noindent
Reading this definition logically, we can say that 
holds for  if  holds for every  ``inside''
. Thus  is a generic definition of the \emph{everywhere}
modality, as defined for containers by Altenkirch and Morris
\cite{alten09indexed}. This can be seen clearly by considering the
action of the lifting in \parenref{eqn:fhat} on polynomial functors:

The identity functor on  does not contribute any new information
to proofs that a property holds for a given data element, so its
lifting is the identity functor on . For any , the
constantly -valued functor  on  does not contribute any
inductive information to proofs, so its lifting is the truth predicate
 for . The lifting of a coproduct of functors splits into
two possible cases, depending on the value being analysed. And a
product of functors contributes proof information from each of its
components. Lifting is defined generically in terms of the functor
, and so it is possible to compute the lifting of non-polynomial
functors such as the the finite powerset functor. Ghani, Johann and
Fumex \cite{ghani10induction} give further examples of the lifting
 applied to non-polynomial functors.

Below, in \hyperref[lem:lifting-commute-reindex]{Lemmas
  \ref*{lem:lifting-commute-reindex}} and
\ref{lem:lifting-commute-sigma} and
\hyperref[sec:refining-inductive]{Sections
  \ref*{sec:refining-inductive}}, \ref{sec:indexed-refinement},
\ref{sec:partial-refinement} and \ref{sec:zygo-refine}, we will be
interested in the restriction of the lifting  to fibres over
particular sets . Given an object  of ,
 is an object of . Therefore, if we
restrict the domain of  to , we get a functor
. The subscript  on
 indicates that we have restricted the domain to
.

The final expression in \parenref{eqn:fhat} is given in terms of the
constructions of \hyperref[sec:truth-compr]{Sections
  \ref*{sec:truth-compr}} and \hyperref[sec:sums]{ \ref*{sec:sums}},
so the definition of a lifting makes sense in any full cartesian
Lawvere category.

Under certain conditions, the lifting  for any functor  is
well-behaved with respect to reindexing and op-reindexing. We make
this observation precise in two lemmas that will be used in our
development of both our basic (\autoref{sec:refining-inductive}) and
partial refinement techniques (\autoref{sec:partial-refinement}). To
state the first, we need the notion of a pullback; this notion will
also be used in \hyperref[sec:indexed-refinement]{Sections
  \ref*{sec:indexed-refinement}}, \hyperref[sec:partial-refinement]{
  \ref*{sec:partial-refinement}}, and \hyperref[sec:zygo-refine]{
  \ref*{sec:zygo-refine}} below. The {\em pullback} of the morphisms
 and  consists of an object  and two
morphisms  and  such that .  We indicate pullbacks diagrammatically by

Moreover, for any , , and  such that
, there exists a unique morphism  such that  and .  When it exists,
the pullback of  and  is unique up to (unique) isomorphism.  All
container functors~\cite{DBLP:conf/fossacs/AbbottAG03}, and hence all
functors modelling strictly positive types, preserve pullbacks.

We can now state our lemmas.

\begin{lem}\label{lem:lifting-commute-reindex}
  For any functor  that preserves pullbacks,
  lifting commutes with reindexing, i.e., for all functions , there exists a vertical natural isomorphism .
\end{lem}

\begin{lem}\label{lem:lifting-commute-sigma}
  For any functor , lifting commutes with
  op-reindexing, i.e., for all functions , there exists a
  vertical natural isomorphism .
\end{lem}
\noindent
More generally, \lemref{lem:lifting-commute-reindex} holds in any full
cartesian Lawvere category satisfying the Beck-Chevalley condition for
coproducts, whereas \lemref{lem:lifting-commute-sigma} holds in any
full cartesian Lawvere category with very strong coproducts.

Since  is an endofunctor on , the category
 of -algebras exists. The families fibration
 extends to a fibration , called the {\em algebras fibration}
induced by . Concretely, the action of  is the same as that
of , so that  on
objects and  on morphisms.  Moreover, writing  and
 for the truth and comprehension functors for ,
respectively, the adjoint relationships from
\hyperref[ex:cc-with-unit]{Diagram \ref*{ex:cc-with-unit}} all lift to
give .  The two
adjunctions here follow from \thmref{thm:alg-adjunctions} using the
fact that  is a truth-preserving lifting. That left adjoints
preserve initial objects can now be used to establish the following
fundamental result, originally from Hermida and Jacobs
\cite{hermida98structural}, and generalised by Ghani \emph{et al.}
\cite{ghani10induction}:
\begin{thm}\label{thm:initial-fhat-algebra}
   is the carrier  of the initial
  -algebra.
\end{thm}
\noindent
\thmref{thm:initial-fhat-algebra} can be generalised to any full
cartesian Lawvere category.  As shown by Hermida and Jacobs, and by
Ghani \emph{et al.}, it can be used to give a generic structural
induction rule for any functor  having an initial algebra.

\section{From Liftings to Refinements}\label{sec:refining-inductive}

In this section we show that the refinement of an
inductive type  by an -algebra  --- i.e.,
the family

generalising the refinement in \parenref{eqn:vector} --- is
inductively characterised as , where  is given by

\noindent
That is,  is obtained by first building the
-indexed type  from~\hyperref[eqn:fhat]{Equation
  \ref*{eqn:fhat}}, and then restricting membership to those elements
whose -values are correctly computed from those of their
immediate subterms. More generally, we can express  in terms
of the constructions of \hyperref[sec:families]{Section
  \ref*{sec:families}} as 


Before we prove that the above construction of  is correct,
we show that it yields the refinement of lists by the length function
given in \parenref{eqn:vector}.

\begin{eorollary}\label{ex:lists-n-vectors}
  The inductive type of lists of elements with type  can be
  specified by the functor . Writing  for the left injection and
   for the right injection into the coproduct
  , the -algebra
  
  that computes the lengths of lists is

In the families fibration, we can calculate the refinement of  by the algebra  as follows:

The first equality holds by \parenref{eqn:Falpha} and the expansion of
this expression in the families fibration. The second is obtained by
unfolding the definition of  as a coproduct, which
allows the refinement to be presented as a coproduct as well. In the
first summand of the final expression above,
, so that  reduces to . We can expand the product and comprehension parts of  in the
second summand to see that  reduces to . Since ,
the whole refinement can therefore be expressed as

As we shall see in \thmref{thm:muFalpha-initial} below, the least
fixed point  of this
functor exists and is ,
exactly as required. Moreover, the expression for
 derived here is exactly the
same as the definition of the functor  given in
\autoref{sec:indexed-ind-types} whose least fixed point models the
Agda 2 declaration of \texttt{Vector B} given in the
\hyperref[sec:introduction]{introduction}.  The derivation just
completed therefore justifies this definition of \verb|Vector B|.
\end{eorollary}

\subsection{Correctness of Refinement}

We now turn our attention to proving the correctness of our refinement
construction from \parenref{eqn:Falpha-set}. The proof makes good use
of the relationship between the category  and the
categories  for various sets , as well as of the
lifting of this relationship to the categories  and
 of algebras.

We begin with a simple, but key, observation, namely:

\begin{lem}\label{lem:hidden-cartesian}
  Let  and  be objects in , and let  be a function. The set of morphisms  in  from
   to  such that  is isomorphic to the set of
  morphisms in  from  to .
\end{lem}
\begin{proof}
  This follows directly from the definitions. On the one hand, a
  morphism  in  from  to  such that  is a pair , where . On the other, the definition of the re-indexing functor
  , i.e.  , entails that a morphism in
   from  to  is a pair , where . There is clearly
  an isomorphism between these sets of morphisms.
\end{proof}

To understand the relationship between the category of
-algebras and the category of -algebras, it is
convenient to define category of -algebras that are over the
-algebra  with respect to the fibration  defined at
the end of \autoref{sec:fibrational-ind}.

\begin{defi}
  For each -algebra , the category
   of {\em -algebras over }
  with respect to  has as objects -algebras  such that , and as morphisms
  -algebra morphisms  such that .
\end{defi}

\begin{lem}\label{lem:alg-iso}
  For each -algebra , there is an isomorphism of
  categories .
\end{lem}
\begin{proof}
  We demonstrate only the isomorphism on objects here; the isomorphism
  on morphisms is similar. An object of  is a
  pair comprising a family  and a morphism  in  such that . By
  \lemref{lem:hidden-cartesian}, such morphisms  are in one-to-one
  correspondence with the morphisms  in . By the adjunction
  , the latter morphisms are in
  one-to-one correspondence with the morphisms  in . By the definition of
  , these morphisms are exactly the -algebras,
  i.e., the objects of .
\end{proof}

The next lemma shows that the reindexing and op-reindexing functors
for  are inherited from . We have:

\begin{lem}\label{lem:alg-bifibration}
  For every -algebra morphism , there are functors  and
   such that . Moreover, for any -algebra , the -algebra
   has carrier
  , and for any -algebra , the -algebra  has carrier .
\end{lem}

\begin{proof}
  By \lemref{lem:alg-iso}, we can treat  as
  if it were , and  as if it
  were . In \autoref{sec:families}, we noted that for
  any , there are functors  and  such
  that . The lemma statement is now a consequence
  of \thmref{thm:alg-adjunctions}, provided we can establish the isomorphism
  . But we can
  verify the existence of such an isomorphism as follows: 
  \begin{center}
    \begin{tabular}{cll}
      &  & \\
           &  & by the
      definition of  \\
       &  & since  is an -algebra morphism \\
       &  & by \lemref{lem:lifting-commute-sigma} \\
           &  & by the definition of 
    \end{tabular}
  \end{center}
  This is exactly as required.
\end{proof}

We can now see that \lemref{lem:hidden-cartesian} generalises from the
categories in the families fibration to those in . This gives:

\begin{lem}\label{lem:hidden-cartesian-alg}
  Let let  and  be objects of  and
  , respectively, and let  be an -algebra morphism. The set
  of morphisms  in  from  to  such that  is
  isomorphic to the set of morphisms in  from
   to .
\end{lem}
\begin{proof}
  The proof is tedious but not difficult. The key point entails
  constructing from each -algebra morphism  such that  another -algebra morphism
   such that . This is made
  easier by observing that the definition of  obtained by
  applying \thmref{thm:alg-adjunctions} in the proof of
  \lemref{lem:alg-bifibration} is equivalent to the functor which on
  input  returns , where  is the isomorphism derived from the fact that
   is an -algebra morphism.
\end{proof}

Putting this all together, we can now give our explicit
characterisation of .

\begin{thm}\label{thm:muFalpha-initial}
  The functor  has an initial algebra with carrier
  , i.e., with carrier .
\end{thm}
\begin{proof}
  By \lemref{lem:alg-iso}, it suffices to show that the category
   has an initial object with carrier
  . We construct an initial object
  in  from the initial -algebra
   from
  \thmref{thm:initial-fhat-algebra}. Since  is a
  left adjoint, it preserves initial objects, so that
   is the initial -algebra .
  We can apply  to the initial
  -algebra to get our candidate object
  . By \lemref{lem:alg-bifibration}, this
  candidate has carrier , as
  required.

  To see that our candidate object is initial in
  , let  be any
  object in . Then

  \begin{tabular}{cl}
    &
     \\ 
    &  \\ 
    & \hspace{11cm}by \lemref{lem:alg-bifibration} \\
    &  \\ 
    & \hspace{11cm}by \lemref{lem:hidden-cartesian-alg} \\
  \end{tabular}

  \noindent
  Since  is
  the initial -algebra and  takes  to
  , the final set in the above sequence has exactly one
  element. Thus there is exactly one morphism from
   to  in
  , and so our candidate object is indeed
  initial in .
\end{proof}

For readers familiar with fibred category theory, we briefly sketch
how our definitions and proofs may be generalised. We have been
careful to state the definition of  in terms of the abstract
structure we identified in \autoref{sec:families}. It can therefore be
generalised to any full cartesian Lawvere category with very strong
coproducts.  \hyperref[lem:alg-bifibration]{Lemmas
  \ref*{lem:alg-bifibration}} and \hyperref[lem:hidden-cartesian-alg]{
  \ref*{lem:hidden-cartesian-alg}}, as well as
\thmref{thm:muFalpha-initial}, can also be generalised. As was shown
by Hermida and Jacobs \cite{hermida98structural}, for any lifting
, the obvious generalisation of the functor  is a fibration. The generalisation of
\lemref{lem:alg-iso} is a result about the fibre categories of this
fibration, and the generalisation of \lemref{lem:alg-bifibration}
shows that it is a bifibration (i.e., that the re-indexing functors
have left adjoints). The generalisation of
\thmref{thm:muFalpha-initial} then follows from the Proposition 9.2.2
of Jacobs' book \cite{jacobs99book}, which relates initial objects in
the total category of a fibration with initial objects in the fibres.

\subsection{More Example Refinements}\label{sec:refining-examples}

The following explicit formulas can be used to compute refinements for
polynomial functors with respect to the families fibration:

Refinements of the identity and constant functors are as expected.
Refinement splits coproducts of functors into two cases, 
specialising the refining algebra for each summand. It is not, however,
possible to decompose the refinement of a product of functors  into refinements of  and , not even by algebras other
than . This is because  may need to relate multiple 
elements to the overall index. 

\begin{eorollary}\label{ex:refined-trees}
  We can refine  by the
  -algebra  given by

The fold of  sums the values stored at the leaves of
a tree. It yields the refinement  given by

By \thmref{thm:muFalpha-initial} and the definition of
 we have that the refinement  is . This
refinement indexes the elements of  by the sums
of the values in their leaves. It corresponds to the Agda 2 declaration
\begin{verbatim}
data SumTree : Integer -> Set where
  SumLeaf : (z : Integer) -> SumTree z
  SumNode : (l r : Integer) -> SumTree l -> SumTree r -> SumTree (l + r)
\end{verbatim}
\end{eorollary}

\noindent
Note that in the second summand of
 we have two recursive references
to , each with a separate index, and that these indices are related
to the overall index  as in the second case of
. However, the basic refinement process developed in
this section cannot be used to require indices of subterms to be
related to one another in particular ways. For instance, it cannot
enforce the requirement that the two subtrees sum to the same value,
or that the tree satisfy some balance property. Indeed, if such
restrictions are imposed, then some elements of the underlying data
type may fail to be assigned an index. We show how to treat this via
partial assignment of indices in \autoref{sec:partial-refinement}.

\subsection{Limiting cases} 

The two limiting cases of refinement are deserving of attention.
Refining by the initial -algebra 
gives a -indexed type inductively characterised as the least
fixed point of the functor . Since  is an isomorphism,  is as
well. Thus , so that . Taking, for each , the canonical
singleton set  to be , we can regard each element of 
is its own index. By contrast, refinement by the final algebra  gives a -indexed type inductively characterised by
. Since , the inductive type  is actually
. Since  is the canonical singleton set, all elements of
 have exactly the same index.  Refining by the initial
-algebra thus has maximal discriminatory power, while refining by
the final -algebra has no discriminatory power whatsoever.

\section{Starting with Already Indexed
  Types}\label{sec:indexed-refinement}  

The development in \autoref{sec:refining-inductive} assumes that the
type being refined is the initial algebra of an endofunctor  on
. This seems to preclude refining an inductive type that is
already indexed. But since we carefully identified the abstract
structure of  needed to construct our refinements, our
results can be extended to {\em any} fibration having that
structure. We now show that, in particular, we can refine already
indexed types.

To this end, let  be a set, and suppose we want to refine an
-indexed type.  As we have seen, such types may be interpreted in
the category . The carrier of an -algebra 
with respect to which we want to refine an already -indexed type
will thus be an -indexed set , and the resulting
refinement will be a type of the form , i.e.,
will be a family of sets that is doubly indexed by both  and .

Just as the categories of indexed sets comprise the category
 in \autoref{sec:families}, the families indexed by
-indexed sets comprise a category . (Our notation is derived from the pullback construction
used to construct this category in the general setting; see below.)
Objects of  are pairs ,
where  and , and morphisms
are pairs , where  and .
And just as there is a functor  defined by
 on objects and  on morphisms, there is a
functor 
defined by  on objects and  on
morphisms. We may now recreate each of the structures we identified
for the families fibration in \autoref{sec:families} for the new
fibration given by . We have:
\begin{iteMize}{}
\item {\em Fibres}: For each object  of , the fibre
  of  over  is the
  category  consisting of
  objects of  whose first
  component is , and morphisms , where . By abuse of terminology, such morphisms are again said
  to be \emph{vertical}.
\item {\em Reindexing}: Given a morphism  in
  , we can define the re-indexing functor  by composition, similarly to how
  reindexing is defined for the families fibration.
\item {\em Truth functor}: For each set , we can define  by
  . As in the families fibration,
  this mapping of objects to truth predicates extends to a functor,
  called the {\em truth functor} for .
\item {\em Comprehension functor}: For each set , we can define
  
  by . As in
  the families fibration, this mapping of objects to their
  comprehensions extends to a functor, called the {\em comprehension
    functor} for .
\item {\em Indexed coproducts}: For any morphism  in
  , we can define  by
  
\item {\em Indexed products}: For any morphism  in
  , we can define  by
  
\end{iteMize}
\noindent
Given these definitions, we can check by hand that they satisfy the
same relationships from \autoref{sec:families} that their counterparts
for the families fibration do. It is therefore possible to re-state
each of the definitions and results in
\hyperref[sec:fibrational-ind]{Sections \ref*{sec:fibrational-ind}}
and \hyperref[sec:refining-inductive]{ \ref*{sec:refining-inductive}}
for , and, thereby, to derive refinements of already indexed
inductive types. The constructions that we carry out in the families
fibration in \hyperref[sec:partial-refinement]{Sections
  \ref*{sec:partial-refinement}} and \hyperref[sec:zygo-refine]{
  \ref*{sec:zygo-refine}} can similarly be carried out in  as
well.

\vspace*{0.1in}

For readers familiar with fibred category theory, we now sketch how to
generalise the above construction to construct a suitable setting for
indexed refinement from any full cartesian Lawvere category with
products and very strong coproducts, provided these satisfy the
Beck-Chevalley condition for coproducts. For this we can use the
\emph{change-of-base} construction for generating new fibrations by
pullback~\cite{jacobs99book}. Indeed, if  is an object of
, then the following pullback in , the large
category of categories and functors, constructs :

\noindent
Instantiating  to  and  to the families
fibration constructs  as
defined above, up to currying. Moreover, the following theorem shows
that all the structure we require for constructing refinements is
preserved by the change-of-base construction, and thus ensures that
the change-of-base construction can be iterated as often as desired.

\begin{thm}\label{thm:change-of-base}
  If  is a full cartesian Lawvere category with products and with
  very strong coproducts satisfying the Beck-Chevalley condition for
  coproducts, then so is .
\end{thm}

\begin{proof}\emph{(Sketch)}
  First,  is well-known to be a fibration by its definition via
  the change-of-base construction \cite{jacobs99book}. The truth
  functor for  is defined for objects  in  by
  , and the comprehension functor for 
  is defined by , where  and . Coproducts are
  defined directly using the coproducts of .
\end{proof}

\begin{eorollary}\label{ex:indexed-refinement}
  To demonstrate the refinement of an inductive type which is already
  indexed we consider a small expression language of well-typed
  terms. Let  be the
  set of possible base types. The language is 
  for the functor  given by

This specification of an inductive type corresponds to the following
Agda 2 declaration, where we write \verb|Ty| for the Agda 2
equivalent of the set :
\begin{verbatim}
data WTExp : Ty -> Set where
  intConst  : Integer -> WTExp Int
  boolConst : Boolean -> WTExp Bool
  add       : WTExp Int -> WTExp Int -> WTExp Int
  if        : (t : Ty) -> WTExp Bool -> WTExp t -> WTExp t -> WTExp t
\end{verbatim}
The type \verb|WTExp| cannot be constructed by the process of
refinement presented in \autoref{sec:refining-inductive}. Indeed, the
indices of subexpressions, and not just the overall indexes, are
constrained in the types of the \texttt{add} and \texttt{if}
constructors. This accords with the discussion at the end of
\hyperref[sec:refining-examples]{Section
  \ref*{sec:refining-examples}}. Fortunately we can, and will, show in
\autoref{sec:partial-refinement} how to extend the notion of
refinement to the situation where not every element of a data type can
be assigned an index.

Meanwhile, in light of \thmref{thm:change-of-base}, we can refine the
already indexed type . For any , write
, , , and
 for the injections into . Let  denote the set of booleans, and
assume there exists a -indexed family  such that  and . Then
 gives a semantic interpretation of the types from 
that can be used to define an -algebra
 whose fold specifies a ``tagless'' interpreter. We
have:

The function  does indeed give a semantics to each
well-typed expression. Refining  by
 yields an object \verb|WTExpSem| of
 over
, i.e, an object of  indexed by
. This -indexed data type
associates to every well-typed expression that expression's
semantics. As an Agda 2 declaration, it can be expressed as follows,
after applying a few type isomorphisms to make the declaration more
idiomatic:
\begin{verbatim}
data WTExpSem : (t : Ty) -> T t -> Set where
  intConst  : (z : Integer) ->       WTExpSem Int z
  boolConst : (b : Boolean) ->       WTExpSem Bool b
  add       : (z1 z2 : Integer) ->
              WTExpSem Int z1 ->
              WTExpSem Int z2 ->     WTExpSem Int (z1 + z2)
  if        : (b : Boolean) ->
              (t : Ty) ->
              (x1 x2 : T t) ->
              WTExpSem Bool b ->
              WTExpSem t x1 ->
              WTExpSem t x2 ->       WTExpSem t (if b then x1 else x2)
\end{verbatim}
Here, we have assumed a standard \texttt{if\_then\_else} notation for
eliminating booleans.
\end{eorollary}

\section{Partial Refinement}\label{sec:partial-refinement}

In \hyperref[sec:refining-inductive]{Sections
  \ref*{sec:refining-inductive}} and
\hyperref[sec:indexed-refinement]{ \ref*{sec:indexed-refinement}} we
assumed that every element of an inductive type can be assigned an
index. Every list has a length, every tree has a number of leaves,
every well-typed expression has a semantic meaning, and so on. But how
can an inductive type be refined if only {\em some} data have values
by which we want to index?  For example, how can the inductive type of
well-typed expressions of \hyperref[ex:indexed-refinement]{Example
  \ref*{ex:indexed-refinement}} be obtained by refining a data type of
untyped expressions by an algebra for type assignment? And how can the
inductive type of red-black trees be obtained by refining a data type
of coloured trees by an algebra enforcing the well-colouring
properties? As these questions suggest, the problem of refining
subsets of inductive types is a common and naturally occurring
one. Our partial refinement technique, which we now describe, can
solve this problem.

\subsection{Partial Algebras}

To generalise our theory to partial refinements we move from algebras
to partial algebras. If  is a functor, then a {\em partial
  -algebra} is a pair  comprising a
carrier  and a structure map . We write
 and  for the injections into ,
and often refer to a partial algebra solely by its structure map. The
functor  is (the functor part of) the {\em error monad}.

\begin{eorollary} The inductive type of expressions is  for the functor .  Letting
   as in
  \hyperref[ex:indexed-refinement]{Example
    \ref*{ex:indexed-refinement}}, and using the obvious convention
  for naming the injections into , types can be
  inferred for expressions using the following partial
  -algebra:

\end{eorollary}

\begin{eorollary}
  Let  be a set of colours.
  The inductive type of coloured trees is  for
  the functor .  We write  and  for injections into
  . Red-black trees~\cite{cormen01intro} are
  coloured trees satisfying the following constraints:
\begin{enumerate}
\item Every leaf is black;
\item Both children of a red node are black;
\item For every node, all paths to leaves contain the same number of
  black nodes.
\end{enumerate}
We can check whether or not a coloured tree is a red-black tree using
the following partial -algebra. Its carrier
 records the colour of the root in the
first component and the number of black nodes to any leaf, assuming
this number is the same for every leaf, in the second. We have:

\end{eorollary}

\subsection{Using a Partial Algebra to Select Elements}

We now show how, given a partial algebra, we can use it to select some
of the elements of an underlying type and assign them indices. The key
to doing this is to turn every partial -algebra into a (total)
-algebra. Let  be any
distributive law for the error monad  over the functor . Then
 respects the unit and multiplication of 
(see~\cite{barr83toposes} for details). Every partial -algebra
 generates an -algebra  defined by , where  is the cotuple of the
functions  and .

We can use  to construct the following global
characterisation of the indexed type for which we seek an inductive
characterisation:

As in~\parenref{eqn:vector}, we can consider this characterisation a
specification; it is similar to the specification
in~\hyperref[sec:refining-inductive]{Section
  \ref*{sec:refining-inductive}}, except that the index generated by
the algebra  is required to return  for
some . We can rewrite this specification as follows, using
the categorical constructions from \autoref{sec:families} and
\thmref{thm:muFalpha-initial}:

Rewriting the specification in this way links partial refinements with
the indexed inductive type generated by the refinement process given
in \autoref{sec:refining-inductive}.

\subsection{Construction and Correctness of Partial Refinement}

Refining  by the -algebra  using the
techniques of \autoref{sec:refining-inductive} would result in an
inductive type indexed by . But our motivating examples suggest
that what we actually want is an -indexed type that inductively
describes only those terms having values of the form  for some
. Partial refinement constructs, from a functor  with
initial algebra , and a partial
-algebra , a functor  such that
. To this end, we define

We note that, in the special case of the families fibration, this
definition specialises to . Now, since left
adjoints preserve initial objects, we can prove  by lifting the adjunction on the left
below (cf.~\autoref{sec:indexed-products}) to an adjunction between
 and  via
\thmref{thm:alg-adjunctions}:
 

\noindent
To satisfy the precondition of \thmref{thm:alg-adjunctions}, we must
prove that . To show this, we reason as follows:
\begin{center}
  \begin{tabular}{cll}
    &  & \\
         &  &
    by definition of \\ 
     &  & by \lemref{lem:commute-ok} below \\ 
     &  & by
    \lemref{lem:lifting-commute-reindex} \\ 
         &  & by definition of 
  \end{tabular}
\end{center}
In these steps we have made use of two auxiliary results, relying on
two assumptions. First, in order to apply
\lemref{lem:lifting-commute-reindex}, we have assumed that 
preserves pullbacks. Secondly, we have made use of the vertical
natural isomorphism . We may deduce the
existence of the latter if we assume that the following property,
which we call \emph{non-introduction of failure}, is satisfied by the
distributive law  for the error monad  over : for all
 and ,  if and only if
.  This property strengthens the usual unit axiom for
distributive laws in which the implication holds only from right to
left, and ensures that if applying  does not result in
failure, then no failures were present in the data to which 
was applied. Every container functor has a canonical distributive law
for  satisfying the non-introduction of failure property.

\begin{lem}\label{lem:commute-ok}
  If the distributive law  satisfies non-introduction of
  failure, then .
\end{lem}

\begin{proof}
  Given , we have    
  
  Here, we have instantiated the definitions in terms of the
  constructions from \autoref{sec:families} for the families
  fibration.
\end{proof}

\noindent
Putting everything together, we have shown the correctness of partial
refinement:

\begin{thm}\label{thm:partial-refinement}
  If  is a distributive law for the error monad  over 
  with the non-introduction of failure property, and if  preserves
  pullbacks, then  has an initial algebra whose carrier
  is given by any, and hence all, of the expressions
  in~\parenref{eqn:muFkappa}.
\end{thm}

\noindent
In fact, Lemma 6.1, and hence Theorem 6.2, holds in the more general
setting of a full cartesian Lawvere category with products and very
strong coproducts that satisfy the Beck-Chevalley condition for
coproducts, provided that the base category satisfies
extensivity~\cite{clw93}. In the general setting, the non-introduction
of failure property can be formulated as requiring that the following
square (which is the unit axiom for the distributive law ) is
a pullback:

Moreover,~\thmref{thm:change-of-base} extends to show that extensivity
is also preserved by change-of-base provided all of the the fibres of
the given full cartesian Lawvere category satisfy extensivity. This
ensures that the process of partial refinement can be iterated as
often as desired.

\section{Refinement by Zygomorphisms and Small Indexed
Induction-Recursion}\label{sec:zygo-refine}

The refinement process of \autoref{sec:refining-inductive} allows us
to refine an inductive data type by any function definable as a fold.
Despite this generality, the restriction to functions defined by folds
can be a burden. Consider, for example, the following structurally
recursive function on natural numbers that computes factorials:
\begin{verbatim}
factorial : Nat -> Nat
factorial zero     = succ zero
factorial (succ n) = succ n * factorial n
\end{verbatim}
This \verb|factorial| function is not immediately expressible as a
fold of an algebra on the natural numbers; indeed, the right-hand side
of the second clause uses both the result of a recursive call and the
current argument, but a fold cannot use the current argument in
computing its result. The style of definition exemplified by
\verb|factorial| is known as a
\emph{paramorphism}~\cite{meertens92paramorphism}. As we recall in
\autoref{sec:para-zygo} below, such definitions can be reduced to
folds. However, reducing \verb|factorial| to a fold and then refining
as in \autoref{sec:refining-inductive} yields a \texttt{Nat
   Nat}-indexed type, i.e., a doubly indexed type that
reveals the auxiliary data used to define~\texttt{factorial} as a
fold.  But rather than \texttt{Nat  Nat}-indexed type,
what we actually want is an inductive characterisation of the
following \texttt{Nat}-indexed type:

If we try to implement \texttt{FactorialNat} inductively in Agda 2,
then we get stuck at the point marked by \texttt{???} below:
\begin{verbatim}
data FactorialNat : Nat -> Set where
  fnzero : FactorialNat (succ zero)
  fnsucc : {n : Nat} ->
           (x : FactorialNat n) ->
           FactorialNat (succ ??? * n)
\end{verbatim}
We'd like to put \verb|x| in place of \verb|???|, but there is a
problem. Indeed, if \verb|x : FactorialNat n|, then
in~\parenref{eq:suffixlist} we know that \verb|x : Nat|, so we can use
the assertion \verb|factorial x = n|.  But in the above Agda 2 code we
cannot conclude that if \verb|x : FactorialNat n|, then 
\verb|x : Nat|, and so we cannot use the fact that 
\verb|factorial x = n|. What is required is a function
{\tt forget} of type {\tt {n : Nat} -> FactorialNat n -> Nat} that
converts an element of \verb|FactorialNat n| into its underlying
natural number. Unfortunately, we cannot first define the data type
\verb|FactorialNat| and then define the function \verb|forget|
thereafter. Instead, as becomes evident upon replacing \verb|???| by
\verb|forget x| in the definition of \verb|FactorialNat|, we must
define both simultaneously.

Fortunately, this can be done using the principle of definition by
\emph{indexed induction-recursion} (IIR) due to Dybjer and Setzer
\cite{dybjer03induction,dybjer06indexed}. Agda 2 supports indexed
induction recursion, and so \texttt{FactorialNat} and \texttt{forget}
can be defined (simultaneously) as follows:
\begin{verbatim}
mutual
  data FactorialNat : Nat -> Set where
    fnzero : FactorialNat (succ zero)
    fnsucc : {n : Nat} ->
             (x : FactorialNat n) ->
             FactorialNat (succ (forget x) * n)

  forget : {n : Nat} -> FactorialNat n -> Nat
  forget fnzero     = zero
  forget (fnsucc x) = succ (forget x)
\end{verbatim}
\noindent
As we have already noted, it is possible to make sense of functions
such as \texttt{factorial} in terms of initial -algebras by using the
existing notion of a \emph{paramorphism} and its generalisation, a
\emph{zygomorphism}, but this gives incorrectly indexed types.
Instead, making use of a presentation of inductive-recursive
definitions as initial algebras (\autoref{sec:initial-algebra-ir}), we
show in \autoref{sec:zygo-refine-correct} that the definition of
\texttt{FactorialNat} can be generalised to an inductive-recursive
type satisfying the analogue of \parenref{eq:suffixlist} for all
zygomorphisms (rather than just \verb|factorial|) and all initial
algebras of functors (rather than just \verb|Nat|).

\subsection{Zygomorphisms and Paramorphisms}\label{sec:para-zygo}

\emph{Zygomorphisms} were introduced by Malcolm \cite{malcolm90}, and
have as a special case the concept of a \emph{paramorphism}
\cite{meertens92paramorphism}. Given a morphism  and an -algebra  we define the
-algebra 
by .
The zygomorphism  associated with  is
defined to be . It is the unique morphism satisfying the equation . Paramorphisms are a
special case of zygomorphisms for which  is the initial
-algebra .

The \texttt{factorial} function above can be represented as a
paramorphism (and hence as a zygomorphism). Recalling that the carrier
of the initial algebra for the functor  is
, we can define

Here, we have used  and  as suggestive
names for the two injections into . Taking  to be
, the induced paramorphism from  to
 is exactly the factorial function.

\subsection{Initial Algebra Semantics of Indexed Small
Induction-Recursion}\label{sec:initial-algebra-ir}

Indexed induction-recursion allows us to define a family of types  simultaneously with a recursive function , for some -indexed collection of potentially large types
. We are interested in the case when  does not depend on ,
so that  is , and  is small, i.e.,  is a set. In this
situation, the semantics of IIR definitions can be given as initial
algebras of functors over slice categories. We recall the definition
of slice categories on . Given a set , the {\em slice
  category}  on  has as objects pairs . A morphism from  to  in  is a function
from  such that . We write  for 
when  can be inferred from context.

Noting that  is isomorphic to  and that , this leads us to consider the
category  each of whose objects is an
-indexed set  together with a function from  to
. A morphism in this category from  to  is a
function  such that . In fact, this category is the
following pullback:


The pair (\texttt{FactorialNat}, \texttt{forget}) can be interpreted
as the carrier of the initial algebra of the following functor on
:

The first component of  defines the
constructors of \texttt{FactorialNat} in a manner similar to that
described in \hyperref[sec:indexed-ind-types]{Section
  \ref*{sec:indexed-ind-types}}. Note that this first component
depends on both  and , which is characteristic of
inductive-recursive, as well as of indexed inductive-recursive,
definitions. The second component of 
extends the function  to the new cases given in the first component
of .

To develop refinement by zygomorphisms, we use a similar methodology
to that in \autoref{sec:partial-refinement}. We first use the
refinement process of \autoref{sec:refining-inductive} to generate a
functor on  which has an initial algebra, and then
apply \thmref{thm:alg-adjunctions} with the adjoint equivalence in the
next theorem to produce the initial algebra for the functor on  that we define
in \parenref{eq:zygo-refine-functor} below.

\begin{thm}\label{thm:ir-equiv}
  There is an adjoint equivalence  which is witnessed by the following pair of
  functors:

\end{thm}
\begin{proof}
  This is a simple consequence of the fact that, for any set ,
 .
\end{proof}
\noindent
In light of the equivalence demonstrated in \thmref{thm:ir-equiv}, we
could use , rather than , as the appropriate category for refinement by
zygomorphisms. Our reasons for choosing the latter are twofold. First,
as we noted in the introduction to this section, we want an
-indexed type rather than a -indexed type. Secondly,
we want to define a function from that -indexed type into 
itself, rather than into a -indexed type.

\subsection{Refinement by Zygomorphisms}\label{sec:zygo-refine-correct}

We now show how to refine an inductive type by a zygomorphism to
obtain an indexed inductive-recursive definition. Generalising the
example of \texttt{FactorialNat} above, we want to construct from an
-algebra  and a morphism  an inductive-recursive characterisation of the following
-indexed set and accompanying -valued function:

Note that although the fold 
applied to  produces a pair , the first component of the
pair in \parenref{eq:zygo-refine-spec} is an -indexed set, rather
than an -indexed set. We can now see that the object of
 in \parenref{eq:zygo-refine-spec} is
isomorphic to 

The first component of \parenref{eq:zygo-refine-equiv}, and hence the
first component of \parenref{eq:zygo-refine-spec}, is the refinement
of  by the zygomorphism , and is thus is the -indexed set
we want to characterise inductively. To do this, we
characterise \parenref{eq:zygo-refine-spec} inductively. More
specifically, we prove in \thmref{thm:zygo-refine-correct} below that
the least fixed point of the following functor on  gives an inductive-recursive characterisation of
\parenref{eq:zygo-refine-spec}:

\noindent
This definition makes use of the functor  defined in \thmref{thm:ir-equiv}. The
first component of  uses  to bundle up
 and  into a -indexed set, and then applies
 as in the basic refinement construction
in \autoref{sec:refining-inductive}. The second component of
 extracts the underlying  component of 
and then applies .

\begin{eorollary}\label{ex:factorial-refine}
  We instantiate the characterisation of 
  in \parenref{eq:zygo-refine-functor} for the \texttt{factorial}
  function from the introduction to this section. That is, we consider
  the functor , the -algebra
  , and the morphism  defined
  in \parenref{eq:fact-paramorphism}.  Instantiating
  \parenref{eq:zygo-refine-functor} gives
  
  We can rewrite the first component of
   to the following
  -indexed set depending on  and :
  
  The  component in the second summand above is constrained to be
  , so we can first remove all references to  and then
  rewrite according to the definition of  to obtain
  
  Using this rewriting of the first component of the instantiation, we
  can rewrite the second component of
   to
  use pattern matching and normal arithmetic notation to get
  
  We have thus derived the definition of 
  from \parenref{eq:factorialnat} solely by way of a mechanical
  process, using the components of the paramorphism that computes
  factorials. Moreover, by \thmref{thm:zygo-refine-correct} below, we
  know that this functor has an initial algebra, and that this initial
  algebra represents the refinement of the natural numbers by the
  zygomorphism defining the function \verb|factorial|.
\end{eorollary}

As described above, the correctness of refinement by a zygomorphism is
a consequence of \thmref{thm:alg-adjunctions} and the adjoint
equivalence from \thmref{thm:ir-equiv}. Indeed, we have:

\begin{thm}\label{thm:zygo-refine-correct}
  The functor  defined
  in \parenref{eq:zygo-refine-functor} has an initial algebra whose
  carrier is given in \parenref{eq:zygo-refine-spec}.
\end{thm}

\begin{proof}
  Observe that the object of 
  in \parenref{eq:zygo-refine-spec} is isomorphic to the result of
  applying the functor  defined in \thmref{thm:ir-equiv} to the
  result of refining  by the algebra
  . Indeed,
  
  The isomorphism in the first step above is by the refinement process
  from \autoref{sec:refining-inductive}, and the equality in the
  second is by definition of . Now, to apply
  \thmref{thm:alg-adjunctions} we must show that . So
  suppose  is in . Then
  
 Here, we have used the fact that the functors  and  form
 an adjoint equivalence by \thmref{thm:ir-equiv}. On the other hand,
  
  by the definition of . So, by the comment
  after \thmref{thm:alg-adjunctions}, . But
  since  is the same
  as \parenref{eq:zygo-refine-spec}, we have
  that \parenref{eq:zygo-refine-spec} can indeed be inductively
  characterised as .
\end{proof}

It is also possible to state and prove a generalisation of
\thmref{thm:zygo-refine-correct} in the general setting of a full
cartesian Lawvere category with very strong coproducts, as defined in
\autoref{sec:families}. In this case, we make use of the category
, which is defined
by a pullback construction similar to that in
\autoref{sec:initial-algebra-ir}. The use of very strong coproducts is
essential to proving the generalised analogue of the adjoint
equivalence in \thmref{thm:ir-equiv}. In the general fibrational
setting, we have the following definition of :


The formulation of zygomorphic refinement in the general setting of a
full cartesian Lawvere category with very strong coproducts means that
we can use the process described in \autoref{sec:indexed-refinement}
to derive a fibration in which to perform zygomorphic refinement on
indexed inductive types.

\begin{eorollary}
  \exref{ex:factorial-refine} illustrates refinement by a
  paramorphism, but does not use the full generality of refinement by
  a zygomorphism. We now demonstrate the power of refinement by a
  zygomorphism to mechanically derive an inductive characterisation of
  the data type of lists of rational numbers indexed by their average.

  We specialise the functor  from
  \exref{ex:lists-n-vectors} to get the functor representing the type
  of lists of rational numbers: . We reuse the -algebra
  , also from \exref{ex:lists-n-vectors}, whose fold
  computes the length of a list. We also consider the following
  -algebra , which is
  used to compute the sum of the elements of a list:
  
  By the standard construction of the product of two -algebras, we
  combine  and  to produce the
  following single -algebra whose fold
  will simultaneously compute the sum and length of a list of rational
  numbers: 
  
  This algebra will form the -algebra component of the zygomorphism
  by which we will refine .

  The morphism component of the zygomorphism by which we will refine
   has carrier . Here, the non- case caters for empty lists,
  for which the average is not defined. We use  and
   as mnemonics for the left and right injections into
  . The morphism  is defined by
 

  Following a similar process to that in
  \exref{ex:factorial-refine}, we can now compute the refinement of
   by  and
  :
  
  In this definition, we have used  to obtain the sum
  of the list underlying , and have likewise used 
  to obtain its length. Expressing this refinement in Agda 2 gives the
  following definition:
\begin{verbatim}
mutual
  data AvgList : 1 + Rational -> Set where
    nil  : AvgList empty
    cons : (q : Rational) ->
           {a : 1 + Rational} ->
           (x : AvgList a) ->
           AvgList (avg ((q + sum x) / (length x + 1)))

  sum : {a : 1 + Rational} -> AvgList a -> Rational
  sum nil        = 0
  sum (cons q x) = q + sum x

  length : {a : 1 + Rational} -> AvgList a -> Nat
  length nil        = 0
  length (cons q x) = length x + 1
\end{verbatim}

\end{eorollary}

The fact we have generated small indexed inductive-recursive types by
a process of refinement by a zygomorphism leads to the interesting
question of whether it is possible to further refine small indexed
inductive-recursive types by any sort of refinement process. A
thorough investigation of such processes should also involve large
induction-recursion (recall that a large inductive-recursive type
entails the definition of a -valued recursive function
simultaneously with the inductive type). The setting of large
inductive-recursive types is much more complicated than small
(indexed) inductive-recursive types, and so we leave investigation of
the refinement of general inductive-recursive types to future
work. Recent work by Malatesta, Altenkirch, Ghani, Hancock and McBride
\cite{malatesta12small} has shown that a large universe of small
inductive-recursive types described by codes is equivalent to the
universe of indexed containers \cite{alten09indexed}. This work may
point to a way to formulate the development of this section in terms
of codes for functors describing types rather than directly in terms
of the functors themselves.

Another interesting avenue for future work is to determine whether the
partial refinement process of \autoref{sec:partial-refinement} can be
combined with the zygomorphic refinement process presented in this
section.

\section{Conclusions, Applications, Related and Future Work}
\label{sec:discussion}

We have given a clean semantic framework for deriving refinements of
inductive types that store computationally relevant information within
the indices of the resulting refined types. We have also shown how
already indexed types can be refined further, how refined types can be
derived even when some elements of the original type do not have
indices, and how refinement by zygomorphisms entails the use of small
indexed induction-recursion for information hiding. In addition to its
theoretical clarity, the theory of refinement we have developed has
potential applications in the following areas:

\medskip

\noindent {\em Dependently Typed Programming:} Often a user is faced
with a choice between building properties of elements of data types
into more sophisticated data types, or stating these properties
externally as, say, pre- and post-conditions. While the former is
clearly preferable because properties can then be statically
type-checked, it also incurs an overhead which can deter its
adoption. Supplying the programmer with infrastructure to produce
refined types as needed can reduce this overhead.

\vspace*{0.03in}

\noindent {\em Libraries:} With the implementation of refinement,
library implementers will no longer need to provide comprehensive
collections of data types, but instead only methods for defining new
data types. Our results also ensure that library implementers will not
need to guess which refinement types will prove useful to programmers,
and can instead focus on providing useful abstractions for creating
more sophisticated data types from simpler ones.

\vspace*{0.03in}

\noindent {\em Implementation:} Current implementations of types such
as {\tt Vector} types store all index information. For example, a
vector of length 3 will store the lengths 3, 2, and 1 of its
subvectors. Since this can be very space-consuming, Brady \emph{et
  al.}~\cite{brady03inductive} have sought to determine when this
information need not be stored in memory. Our work suggests that a
refinement  can be implemented by simply implementing
the underlying type , since programs requiring indices can
reconstruct these as needed. It could therefore provide a
user-controllable tradeoff between space and time efficiency.

\subsection{Related Work}

The work closest to that reported here is McBride's work on ornaments
\cite{mcbride10ornaments}. McBride defines a type of descriptions of
inductive data types, along with a notion of one description
``ornamenting'' another. Despite the differences between our
fibrational approach and his type-theoretic approach, the notion of
refinement presented in \hyperref[sec:refining-inductive]{Sections
  \ref*{sec:refining-inductive}} and
\hyperref[sec:indexed-refinement]{ \ref*{sec:indexed-refinement}} is
very similar to McBride's notion of an algebraic
ornament. Ornamentation further allows for additional arbitrary data
to be attached to constructors, something that is not possible with
any of the refinement processes that we have discussed in this
paper. On the other hand, ornamentation is restricted to inductive
types and so does not allow for the generation of indexed
inductive-recursive types that we presented in
\autoref{sec:zygo-refine}. The theory of ornamentation has been
developed by Ko and Gibbons \cite{KoGibbons2011OAOAOO}, who examine
the relationship between the ornamental versions of the ``local'' and
``global'' refinement that we discussed in
\autoref{sec:better-solution}. More recently, Dagand and McBride
\cite{DagandMcBride2012funOrn} have described an extension of
McBride's original definition of ornamentation which allows for the
removal of constructors. In our setting, the removal of constructors
is possible with the use of partial refinement
(\autoref{sec:partial-refinement}).

An interesting question for future work is to determine the
relationship between functions defined on data types and functions
defined on refined versions of data types. This question has been
addressed in the setting of McBride's work on ornaments by Ko and
Gibbons \cite{KoGibbons2011OAOAOO} and also by Dagand and McBride
\cite{DagandMcBride2012funOrn}. We have not considered the question of
refinement of functions in this paper, and we leave it as future work
to determine whether or not the fibrational approach taken here can
provide any insight.

Chuang and Lin \cite{chuang06algebra} present a way to derive new
indexed inductive types from existing inductive types and algebras
that is very similar to our basic refinement process in
\autoref{sec:refining-inductive}. Chuang and Lin work in the setting
of the codomain fibration, which makes some calculations easier, but
extensions to partial and zygomorphic refinement more difficult.

A line of research allowing the programmer to give refined types to
constructors of inductive data types was initiated by Freeman and
Pfenning \cite{freeman91refinement}. Freeman and Pfenning defined a
variant of ML that allowed programmers to define refinements of
inductive types by altering the types of constructors, or by
disallowing the use of certain constructors. Refinement of this sort
did not require dependent types. This work was later developed by Xi
\cite{xi00dependently}, Davies \cite{davies05practical} and Dunfield
\cite{dunfield07unified} for extensions of ML-like languages with
dependent types, and by Pfenning \cite{pfenning93refinement} and Lovas
and Pfenning \cite{lovas10refinement} for LF. The work of Kawaguchi
\emph{et al.}  \cite{kawaguchi09type} is also similar. This research
begins with an existing type system and provides a mechanism for
expressing richer properties of values that are well-typeable in that
type system.  It is thus similar to the work reported here, although a
major focus of the work of Freeman and Pfenning and its descendants is
on the decidability of type checking and inference of refined types,
which we have not considered in this paper. On the other hand, we
formally prove that each refinement is isomorphic to the richer,
property-expressing data type it is intended to capture, rather than
leaving this to the programmer to justify on a
refinement-by-refinement basis.

Refinement types have been used in other settings to give more precise
types to programs in existing programming languages (but not
specifically to inductive types). For example, Denney
\cite{denney98refinement} and Gordon and Fournet
\cite{gordon09principles} use subset types to refine the type systems
of ML-like languages. Subset types are also used heavily in the PVS
theorem prover \cite{rushby98subtypes}.

Our results extend the systematic code reuse delivered by generic
programming \cite{amm07,bghj07,bdj03}: in addition to generating new
programs we can also generate new types from existing types. This area
is being explored in Epigram \cite{chapman10gentle}, with codes for
data types being represented within a predicative intensional
system. This enables programs to generate new data types. It should be
possible to implement our refinement process using similar techniques.

In addition to the specific differences between our work and that
discussed above, a distinguishing feature of ours is the semantic
methodology we use to develop refinement. We believe that this
methodology is new. We also believe that a semantic approach is
important: it can serve as a principled foundation for refinement, as
well as provide a framework in which to compare different
implementations. Moreover, it may lead to new algebraic insights into
refinement that complement the logical perspective of previous work.

\bigskip

{\em Acknowledgements:} We thank Conor McBride, Frank Pfenning, and
Pierre-Evariste Dagand for helpful comments on this work. The
anonymous FoSSaCS and LMCS reviewers also provided useful
feedback. This work was funded by EPSRC grant EP/G068917/1.

\bibliographystyle{plain}

\bibliography{refinement-journal}

\end{document}
