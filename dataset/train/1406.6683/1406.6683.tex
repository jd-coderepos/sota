\documentclass{llncs}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{relsize}

\usepackage{tikz}
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}



\newcommand{\D}{\mathcal{D}}

\newcommand{\where}{\ | \ }

\renewcommand{\it}[1]{\singlearrow{#1}}  \newcommand{\mt}[1]{\doublearrow{#1}}  \newcommand{\mv}[1]{\singlearrow{#1}}

\newcommand{\MS}{\mbox{\sl MS}}
\newcommand{\IS}{\mbox{\sl IS}}
\newcommand{\MT}{\mbox{\sl MT}}
\newcommand{\IT}{\mbox{\sl IT}}
\newcommand{\PT}{\mbox{\sl PT}}

\newcommand{\cF}{{\mathcal F}}
\newcommand{\cP}{{\mathcal P}}
\newcommand{\cB}{{\mathcal B}}
\newcommand{\cA}{{\mathcal A}}
\newcommand{\cD}{{\mathcal D}}
\newcommand{\cL}{{\mathcal L}}
\newcommand{\cC}{{\mathcal C}}

\newcommand{\bfI}{{\mathbf I}}
\newcommand{\bfR}{{\mathbf R}}
\newcommand{\bfr}{{\mathbf r}}
\newcommand{\bfT}{{\mathbf T}}
\newcommand{\bfW}{{\mathbf W}}

\newcommand{\Paths}{\mbox{\sl Paths}}
\newcommand{\Pathsfin}{\mbox{\sl Paths}}
\newcommand{\Post}{\mbox{\sl Post}}
\newcommand{\Pre}{\mbox{\sl Pre}}
\newcommand{\init}{\mbox{\sl \tiny init}}

\newcommand{\smAP}{\mbox{\scriptsize \sl AP}}
\newcommand{\smPaths}{\mbox{\scriptsize \sl Paths}}

\newcommand{\ft}{\footnotesize}
\newcommand{\Prob}[3]{\mathbb{P}_{#1 #2} \left( #3 \right)}

\def\Pref{\pref}
\def\Outcome{\Outcomes}
\def\Outcomes{\mbox{}}
\def\Events{\mathfrak{E}}
\def\TransProb{\mbox{\bf P}}
\def\BSCC{\mbox{\sl BSCC}}
\def\Acc{\mbox{\sl Acc}}
\def\rew{\mbox{\sl rew}}
\def\ExpRew{\mbox{\sl ExpRew}}
\def\CondExpRew{\mbox{\sl CExpRew}}
\def\LongRunExpRew{\mbox{\sl LongRunER}}
\def\PRCTL{\mbox{PRCTL}}
\def\Distr{\mbox{\sl Distr}}
\def\action{\mbox{\sl act}}
\def\startmode{\mbox{\sl start}}
\def\PP{\mathbb{P}}
\def\EE{\mathbb{E}}
\def\LRER{\mathbb{L}}
\def\Sched{\mathfrak{S}}
\def\FairSched{\mathfrak{F}}
\def\GFairSched{\mathfrak{G}}
\def\HFairSched{\mathfrak{H}}
\def\Limit{\mbox{\sl Limit}}
\def\EC{\mbox{\sl EC}}
\def\MEC{\mbox{\sl MEC}}
\def\AEC{\mbox{\sl AEC}}
\def\equivMDP{\equiv_{\mbox{\tiny MDP}}}
\def\equivMC{\equiv_{\mbox{\tiny MC}}}
\def\CSL{\mbox{CSL}}
\def\sat{ \, \models \, }
\def\accBSCC{U}
\def\nestdepth{\mbox{\sl nd}}


\def\encoding{\mbox{\sl enc}}
\def\bars{\overline{\sfs}}
\def\bart{\overline{\sfz}}
\def\barv{\overline{\sfx}}
\def\baru{\overline{\sfy}}
\def\barz{\overline{\sfz}}
\def\bary{\overline{\sfy}}
\def\barx{\overline{\sfx}}
\def\bara{\overline{\sfa}}
\def\barb{\overline{\sfb}}
\def\barc{\overline{\sfc}}
\def\sfs{\mathit{x}}
\def\sft{\mathit{z}}
\def\sfu{\mathit{y}}
\def\sfv{\mathit{x}}
\def\sfz{\mathit{z}}
\def\sfy{\mathit{y}}
\def\sfx{\mathit{x}}
\def\sfa{\mathfrak{a}}
\def\sfb{\mathfrak{b}}
\def\sfc{\mathfrak{c}}
\def\sfVar{\mbox{\sl Var}}
\def\var{\mbox{\sl var}}
\def\val{\mbox{\sl val}}
\def\succ{\mbox{\sl succ}}
\def\OBDD{\mathfrak{B}}
\def\OBDDC{\mathfrak{C}}
\def\SOBDD{\overline{\mathfrak{B}}}
\def\ITE{\mbox{\sl ITE}}
\def\Done{\mbox{\sl CT}}
\def\CT{\Dome}
\def\info{\mbox{\sl info}}
\def\RENAME{\mbox{\sl Rename}}
\def\COFACTOR{\mbox{\sl Cof}}
\def\ISOM{\mbox{\sl ISO}}
\def\RELPROD{\mbox{\sl RelProd}}
\def\RelProd{\mbox{\sl RelProd}}



\renewcommand{\Pr}{\mbox{\rm Pr}}

\newcommand{\functionp}{\mbox{\sf x}}
\newcommand{\functionq}{\mbox{\sf y}}
\newcommand{\infin}{{\mbox{\sl inf}}}
\newcommand{\Count}{{\mbox{\sl count}}}



\newcommand{\move}[1]{\singlearrow{#1}}
\newcommand{\overto}[1]{\stackrel{{#1}}{\hookrightarrow}}
\newcommand{\overtolong}[1]{\stackrel{{#1}}{\scalebox{4}[1]{}}}
\newcommand{\overxlong}[1]{\stackrel{{#1}}{\scalebox{7}[1]{}}}
\newcommand{\overxxlong}[1]{\stackrel{{#1}}{\scalebox{10}[1]{}}}

\newcommand{\underto}[1]{\frac{\phantom{#1}}{#1}
   \!\!\!\!\!\!\!\rightarrow}

\newcommand{\Move}[1]{\doublearrow{#1}}

\def\Conf{\mbox{\tiny \sl Conf}}

\renewcommand{\Pr}{\mbox{\sl Pr}}
\def\nanoPromela{\mbox{nanoPromela}}
\def\Promela{\mbox{Promela}}
\def\bfIF{\mbox{\bf if}}
\def\bfFI{\mbox{\bf fi}}
\def\DO{\mbox{\bf do}}
\def\OD{\mbox{\bf od}}
\def\bfELSE{\mbox{\tt else}}
\def\PIF{\mbox{\bf pif}}
\def\FIP{\mbox{\bf fip}}
\def\PSELECT{\PIF}
\def\ENDPSELECT{\FIP}
\def\PGCL{\mbox{GCL}}
\def\expr{\mbox{\sf expr}}
\def\id{\mbox{\sl id}}
\def\bexpr{\mbox{\sf bexpr}}
\def\boolexpr{\mbox{\sf bexpr}}
\def\stmt{\mbox{\sf stmt}}
\def\assignments{\mbox{\sf assignments}}
\def\exit{\mbox{\sf exit}}
\def\SKIP{\mbox{\tt skip}}
\def\Effect{\mbox{\sl Effect}}
\def\SPIN{\mbox{SPIN}}
\def\sub{\mbox{\sl sub}}

\def\Values{\mbox{\sl Values}}

\def\Distr{\mbox{\sl Distr}}
\def\SyncChan{\mbox{\sl SynChan}}
\def\SynChan{\mbox{\sl SynChan}}
\def\FChan{\mbox{\sl FChan}}
\def\atomic{\mbox{\tt atomic}}
\def\r{r}
\def\w{w}
\def\add{\mbox{\sl add}}
\def\remove{\mbox{\sl remove}}
\def\full{\mbox{\sl full}}
\def\longrighttau{\move{\tau}}
\def\transtau{\move{\tau}}
\def\terminal{\mbox{T}}
\def\Supp{\mbox{\sl Supp}}
\def\otau{\move{\tau}}
\def\Steps{\mbox{steps}}

\def\C{{\cal C}}
\def\bfE{\mbox{\bf E}}
\def\bfI{\mbox{\bf I}}
\def\bfx{\mbox{\bf x}}
\def\bfy{\mbox{\bf y}}
\def\bfb{\mbox{\bf b}}
\def\bfB{\mbox{\bf B}}
\def\bfA{\mbox{\bf A}}
\def\sfb{b}
\def\sfa{a}
\def\ssigma{\varsigma}
\def\bfP{\mathbf{P}}
\def\init{{\mbox{\rm \tiny init}}}
\def\Outcomes{{\mbox{\sl Outc}}}
\def\cRfp{\cR_{\mbox{\tiny \it fp}}}
\def\fp{\lhd}
\def\dist{\mbox{\it dist}}
\def\Treduced{\hat{\T}}
\def\Sreduced{\hat{S}}
\def\sreduced{\hat{s}}
\def\treduced{\hat{t}}
\def\ureduced{\hat{u}}
\def\vreduced{\hat{v}}
\def\greduced{\hat{g}}
\def\hreduced{\hat{h}}
\def\alphareduced{\hat{\alpha}}
\def\betareduced{\hat{\beta}}
\def\gammareduced{\hat{\gamma}}
\def\rhoreduced{\hat{\rho}}
\def\varrhoreduced{\hat{\varrho}}
\def\PGreduced{\hat{\PG}}
\def\ample{\mbox{\sl ample}}
\def\Asticky{A_{\mbox{\tiny sticky}}}




\newcommand{\reset}[1]{\mbox{\sf reset } #1 \mbox{ \sf in }}
\newcommand{\bfZ}{{\mathbf Z}}
\newcommand{\tabs}{\rightleftarrows}

\def\Reset{\mbox{\it reset}}
\def\CC{\mbox{\it CC}}
\def\Atomic{\ACC}
\def\ACC{\mbox{\it ACC}}
\def\DCC{\mbox{\it DCC}}
\def\Inv{\mbox{\it Inv}}
\def\TTheta{{\mbox{\sf X}}}
\def\TPhi{\Phi}
\def\TPsi{\Psi}
\def\Syn{{\mbox{\it Syn}}}
\def\time{{\mbox{\it time}}}
\def\RG{{\mbox{\it RTS}}}
\def\ZG{{\mbox{\it ZTS}}}
\def\RE{r}
\def\Ra{{\mbox{\sf a}}}
\def\RAP{{\mbox{\sf AP}}}
\def\region{{\mbox{\sf s}}}
\def\RS{{\mbox{\sf S}}}
\def\RL{{\mbox{\sf L}}}
\def\RAct{{\mbox{\sf Act}}}
\def\Rpi{\pi}
\def\RT{{\mbox{\sf T}}}
\def\RSat{{\mbox{\sf Sat}}}
\def\TA{\mbox{\sl TA}}

\def\RMode{\mbox{\sl r\_mode}}
\def\SMode{\mbox{\sl s\_mode}}
\def\div{{\mbox{\it div}}}
\def\divtiny{{\tiny \it div}}
\def\refinement{\Refine}
\newcommand{\pay}{\mbox{\sl pay}}
\newcommand{\drink}{\mbox{\sl drink}}
\newcommand{\cola}{\mbox{\sl beer}}
\newcommand{\Cola}{\mbox{\sl beer}}
\newcommand{\lemonade}{\mbox{\sl soda}}
\newcommand{\Lemonade}{\mbox{\sl soda}}
\newcommand{\limo}{\mbox{\sl soda}}
\newcommand{\select}{\mbox{\sl select}}
\newcommand{\Sim}{\mbox{\sl Sim}}
\newcommand{\bis}{{\!\sim}}
\newcommand{\Refine}{{\mbox{\sl Refine}}}
\newcommand{\Remove}{{\mbox{\sl Remove}}}
\def\finpi{{\widehat{\pi}}}
\def\Bottom{\mbox{\sl Bottom}}
\def\accept{\mbox{\sl accept}}


\def\traceequiv{{\, \triangleq \, }}
\def\Mazutraceequiv{{\, \leftrightharpoons_{\mbox{\tiny \it perm}} \, }}
\def\Maztraceequiv{\Mazutraceequiv}
\def\Mazuleq{{\, \unlhd_{\mbox{\tiny \it perm}} \, }}
\def\negtraceequiv{{\, \not\triangleq \, }}
\def\ntraceequiv{{\, \not\unlhd \, }}
\def\traceinclusion{{\, \unlhd \, }}
\def\ntraceinclusion{{\, \not\unlhd \, }}
\def\negtraceinclusion{{\, \not\unlhd \, }}


\iffalse
\def\traceequiv{{\, \doteqdot \, }}
\def\Mazutraceequiv{{\, \doteqdot_{\mbox{\tiny \it perm}} \, }}
\def\Maztraceequiv{\Mazutraceequiv}
\def\Mazuleq{{\, \lessdot_{\mbox{\tiny \it perm}} \, }}
\def\negtraceequiv{{\, \not\lessdot \, }}
\def\ntraceequiv{{\, \not\lessdot \, }}
\def\traceinclusion{{\, \lessdot \, }}
\def\ntraceinclusion{{\, \not\lessdot \, }}
\def\negtraceinclusion{{\, \not\lessdot \, }}
\fi

\iffalse
\def\traceequiv{{\, \cong \, }}
\def\Mazutraceequiv{{\, \cong_{\mbox{\tiny \it perm}} \, }}
\def\Maztraceequiv{\Mazutraceequiv}
\def\Mazuleq{{\, \sqsubseteq_{\mbox{\tiny \it perm}} \, }}
\def\negtraceequiv{{\, \not\cong \, }}
\def\ntraceequiv{{\, \not\cong \, }}
\def\traceinclusion{{\, \sqsubseteq \, }}
\def\ntraceinclusion{{\, \not\sqsubseteq \, }}
\def\negtraceinclusion{{\, \not\sqsubseteq \, }}
\fi



\newcommand{\cl}{\mbox{\sl cl}}
\newcommand{\clos}{\cl}
\newcommand{\closure}{\cl}

\newcommand{\GNBA}{{\cal G}}

\newcommand{\LTL}{\mbox{LTL}}
\newcommand{\CTL}{\mbox{CTL}}
\newcommand{\PCTL}{\mbox{PCTL}}
\newcommand{\CTLX}{\CTL_{\mbox{\tiny }}}
\newcommand{\LTLX}{\LTL_{\mbox{\tiny }}}
\newcommand{\CTLstarX}{\CTL^*_{\mbox{\tiny }}}
\newcommand{\CTLU}{\CTL_{\mbox{\tiny }}}
\newcommand{\LTLU}{\LTL_{\mbox{\tiny }}}
\newcommand{\CTLstarU}{\CTL^*_{\mbox{\tiny }}}

\newcommand{\CTLstar}{\CTL^*}
\newcommand{\TCTL}{\mbox{TCTL}}
\newcommand{\occupied}{\mbox{\sl occupied}}
\newcommand{\green}{\mbox{\sl green}}
\newcommand{\rot}{\mbox{\sl red}}
\newcommand{\yellow}{\mbox{\sl yellow}}
\newcommand{\response}{\mbox{\sl response}}
\newcommand{\activeAP}{\mbox{AP}}
\newcommand{\enabled}{\mbox{\sl enabled}}
\newcommand{\Words}{\mbox{\sl Words}}

\newcommand{\AND}{\mbox{}}
\newcommand{\Impl}{\mbox{}}
\newcommand{\IMPL}{\mbox{}}
\newcommand{\Or}{\mbox{}}
\newcommand{\Exor}{\mbox{}}
\newcommand{\Not}{\mbox{}}
\newcommand{\Max}{\mbox{}}
\newcommand{\All}{\mbox{}}
\newcommand{\Ex}{\mbox{}}
\newcommand{\Su}{\mbox{}}
\newcommand{\Si}{\mbox{}}
\newcommand{\N}{\mbox{}}
\newcommand{\Eqv}{\mbox{}}
\newcommand{\EQV}{\mbox{}}
\newcommand{\False}{\mbox{false}}
\newcommand{\false}{\mbox{false}}
\newcommand{\True}{\mbox{true}} 
\newcommand{\true}{\mbox{true}} 
\newcommand{\AP}{\mbox{\sl AP}}
\newcommand{\aAP}{\mbox{\sl A}}
\newcommand{\bAP}{\mbox{\sl B}}
\newcommand{\cAP}{\mbox{\sl C}}
\newcommand{\slA}{\mbox{\sl A}}
\newcommand{\slB}{\mbox{\sl B}}
\newcommand{\slC}{\mbox{\sl C}}
\newcommand{\slD}{\mbox{\sl D}}
\newcommand{\sla}{\mbox{\sl A}}
\newcommand{\slb}{\mbox{\sl B}}
\newcommand{\slc}{\mbox{\sl C}}
\newcommand{\slL}{{\cal L}}
\newcommand{\slE}{\mbox{\sf E}}
\newcommand{\slF}{\mbox{\sf F}}
\newcommand{\slG}{\mbox{\sf G}}
\newcommand{\slword}{\mbox{\sl w}}
\newcommand{\slw}{\slword}
\newcommand{\slv}{\mbox{\sl v}}
\newcommand{\slu}{\mbox{\sl u}}
\newcommand{\Senderin}{\mbox{.{\sl in}}}
\newcommand{\Senderout}{\mbox{.{\sl out}}}
\newcommand{\Receiverin}{\mbox{.{\sl in}}}
\newcommand{\Receiverout}{\mbox{.{\sl out}}}








\newcommand{\smAct}{\mbox{\footnotesize \sl Act}}
\newcommand{\Label}{\mbox{\sl Label}}


\newcommand{\Sat}{\mbox{\sl Sat}}
\newcommand{\Path}{\mbox{\sl Paths}}
\newcommand{\FairPath}{\mbox{\sl FairPaths}}
\newcommand{\FairPaths}{\FairPath}
\newcommand{\FPath}{\mbox{\sl Paths}_{\it fair}}


\newcommand{\BDDSat}[1]{\mbox{\sf Sat}\sem{#1}}
\newcommand{\apply}{\mbox{\sc Apply}}
\newcommand{\restrict}{\mbox{\sc Restrict}}
\newcommand{\reduce}{\mbox{\sc Reduce}}
\newcommand{\rename}{\mbox{\sc Rename}}
\newcommand{\B}{\mathsf{B}}
\newcommand{\Left}{\mbox{\sl left}}
\newcommand{\Right}{\mbox{\sl right}}
\newcommand{\Val}{\mbox{\sl val}}
\newcommand{\Var}{\mbox{\sl Var}}
\newcommand{\Vis}{\mbox{\sl Vis}}
\newcommand{\Modify}{\mbox{\sl Modify}}
\newcommand{\mat}[1]{\mathbf{#1}}
\newcommand{\vt}[1]{\underline{#1}}
\newcommand{\tuple}[1]{\langle #1 \rangle}
\newcommand{\Par}[1]{\, |\!|_{#1} \,}
\newcommand{\enc}[1]{[\! [\, #1 \, ] \!]}

\newcommand{\IOK}{I_{\it OK}}
\newcommand{\INOK}{I_{\it NOK}}
\newcommand{\IFST}{I_{\it FST}}
\newcommand{\IDK}{I_{\it DK}}
\newcommand{\IINC}{I_{\it INC}}

\newcommand{\set}[1]{\{ \, #1 \, \}}
\newcommand{\Union}{\, \cup \,}

\newcommand{\To}{\longrightarrow}
\newcommand{\sem}[1]{[\![\, #1 \, ]\!]}

\newcommand{\New}{\mbox{\sl N}}
\newcommand{\Succ}{\mbox{\sl Succ}}
\newcommand{\Old}{\mbox{\sl O}}
\newcommand{\Pred}{\mbox{\sl P}}

\newcommand{\prln}[1]{\hspace*{3em}}
\newcommand{\widehint}[2]{\smallskip\\ \hspace*{1.5em} \makebox[5em][c]{}\{\ #2\ \}\smallskip\\}    
\newcommand{\wideprln}[1]{\hspace*{4.5em}}
\newenvironment{derivation}{\medskip\\}{\medskip}

\newenvironment{sderivation}{\medskip}{\medskip}
\newcommand{\shint}[2]{\hspace*{0.5em} \makebox[3em][c]{}\{\ #2\ \}}

\newcommand{\trans}[2]{\begin{tabular}{c} \underline{} \\  \end{tabular}} 

\newcommand{\tail}{\mbox{\sl tail}}
\newcommand{\head}{\mbox{\sl head}}

\iffalse
\newcommand{\IF}{\mbox{\bf if }}
\newcommand{\DO}{\mbox{\bf do }}
\newcommand{\OD}{\mbox{\bf od}}
\newcommand{\FI}{\mbox{\bf fi}}
\newcommand{\THEN}{ \mbox{\bf then }}
\newcommand{\WHILE}{\mbox{\bf while }}
\newcommand{\VAR}{\mbox{\bf var }} 
\newcommand{\LET}{\mbox{\bf let }} 
\newcommand{\CON}{\mbox{\bf con }}
\newcommand{\PROC}{\mbox{\bf process }}
\newcommand{\FUNC}{\mbox{\bf function }}
\newcommand{\BEG}{\mbox{\bf begin }}
\newcommand{\END}{\mbox{\bf end}}
\newcommand{\ELSE}{\mbox{\bf else }}
\newcommand{\ELSEIF}{\mbox{\bf elseif }}
\newcommand{\CASE}{\mbox{\bf case }}
\newcommand{\ESAC}{\mbox{\bf esac }}
\newcommand{\SKIP}{\mbox{\bf skip }}
\newcommand{\FOR}{\mbox{\bf for }}
\newcommand{\EACH}{\mbox{\bf each }}
\newcommand{\RET}{\mbox{\bf return }}

\fi

\newcommand{\Nats}{\mbox{}}
\newcommand{\Nat}{\Nats}
\newcommand{\Reals}{\mbox{\rm I}\!\mbox{\rm R}}
\newcommand{\Real}{\Reals}

\newcommand{\lead}{\mbox{\sl leader}}
\newcommand{\act}{\mbox{\sl active}}

\newcommand{\Guard}{\mbox{\sl guard}}
\newcommand{\Clock}{\mbox{\sl clocks}}

\newcommand{\Always}{\Box \, }
\newcommand{\Ever}{\Diamond \, }
\newcommand{\Next}{\bigcirc \, }
\newcommand{\Until}{\mbox{}}
\newcommand{\R}{\mbox{}}
\newcommand{\Unless}{\mbox{}}
\newcommand{\Model}{{\cal K}}
\newcommand{\Alwayss}{\mbox{}}
\newcommand{\Evers}{\mbox{}}
\newcommand{\Untils}{\mbox{}}
\newcommand{\Alwaysp}{\mbox{}}
\newcommand{\Everp}{\mbox{}}
\newcommand{\Nextp}{\mbox{}}

\newcommand{\G}{\Always}
\newcommand{\F}{\Ever}
\newcommand{\U}{\Until}
\newcommand{\WU}{\mbox{}}
\newcommand{\Release}{\mbox{}}
\newcommand{\X}{\Next}
\newcommand{\V}{\mbox{}}

\newcommand{\EF}{\exists \F}
\newcommand{\EU}{\exists \U\!}
\newcommand{\AU}{\forall \U\!}
\newcommand{\EG}{\exists \G}
\newcommand{\EX}{\exists {\X}}
\newcommand{\AF}{\forall \F}
\newcommand{\AG}{\forall \G}
\newcommand{\AX}{\forall {\X}}
\newcommand{\E}{\exists}
\newcommand{\A}{\forall}

\newcommand{\rU}[1]{\mbox{}}
\newcommand{\rEF}[1]{\mbox{}}
\newcommand{\rEG}[1]{\mbox{}}
\newcommand{\rAF}[1]{\mbox{}}
\newcommand{\rAG}[1]{\mbox{}}

\newcommand{\intg}[1]{\lfloor #1 \rfloor}
\newcommand{\fr}[1]{\mbox{\sl frac}(#1)}
\newcommand{\arr}[1]{\stackrel{#1}{\longrightarrow}}

\newcommand{\Line}{\rule{\mboxwidth}{0.04cm}}

\def\Ende{\mbox{\rule{6pt}{6pt}}}




\newcommand{\TS}{\mbox{\sl TS}}             \newcommand{\T}{\TS}             \newcommand{\smT}{{\mbox{\sl \tiny }}}          \newcommand{\Act}{\mbox{\sl Act}}     \newcommand{\Reach}{\mbox{\sl Reach}} \newcommand{\Eval}{\mbox{\sl Eval}}   \newcommand{\Dom}{\mbox{\sl dom}}     \newcommand{\dom}{\mbox{\sl dom}}     \newcommand{\Cond}{\mbox{\sl Cond}}   \newcommand{\Eff}{\mbox{\sl Effect}}  \newcommand{\PG}{\mbox{\sl PG}}            \newcommand{\Loc}{\mbox{\sl Loc}}     \newcommand{\Interleaving}{ \, ||| \, }  \newcommand{\product}{\otimes}  

\newcommand{\sosrule}[2]{{\displaystyle\frac{\displaystyle\; #1 \;}{\displaystyle\; #2 \;}}}

\newcommand{\crit}{\mbox{\sl crit}}
\newcommand{\noncrit}{\mbox{\sl noncrit}}
\newcommand{\wait}{\mbox{\sl wait}}
\newcommand{\req}{\mbox{\sl req}}
\newcommand{\request}{\mbox{\sl request}}
\newcommand{\release}{\mbox{\sl rel}}
\newcommand{\enter}{\mbox{\sl enter}}

\newcommand{\Chan}{\mbox{\sl Chan}}   \newcommand{\cp}{\mbox{\sl cap}}      \newcommand{\Comm}{\mbox{\sl Comm}}   \newcommand{\CS}{\mbox{\sl CS}}       

\newcommand{\len}{\mbox{\sl len}}
\newcommand{\first}{\mbox{\sl first}}
\newcommand{\last}{\mbox{\sl last}}

\newcommand{\sm}[1]{{\small #1}} 

\newcommand{\trace}{\mbox{\sl trace}}
\newcommand{\Traces}{\mbox{\sl Traces}}
\newcommand{\FairTraces}{\mbox{\sl FairTraces}}
\newcommand{\Tracesfin}{\mbox{\sl Traces}_{\it fin}}

\newcommand{\INV}{P_{\sl inv}}
\newcommand{\inv}{P_{\sl inv}}
\newcommand{\SAFE}{P_{\sl safe}}
\newcommand{\LIVE}{P_{\sl live}}

\renewcommand{\L}{{\cal L}}

\newcommand{\pref}{\mbox{\sl pref}}
\newcommand{\BadPref}{\mbox{\sl BadPref}}
\newcommand{\MinBadPref}{\mbox{\sl MinBadPref}}

\def\<{\langle}
\def\>{\rangle}
\newcommand{\size}{\mbox{\emph{size}}}

\newcommand{\fair}{{\sl fair}}
\newcommand{\sfair}{{\sl sfair}}
\newcommand{\wfair}{{\it wfair}}
\newcommand{\ufair}{{\it ufair}}

\newcommand{\PTIME}{\mbox{\rm PTIME}}
\newcommand{\PSPACE}{\mbox{\rm PSPACE}}
\newcommand{\coNP}{\mbox{\rm coNP}}
\newcommand{\NP}{\mbox{\rm NP}}
\newcommand{\poly}{\mbox{\rm poly}}
\newcommand{\coPTIME}{\mbox{\rm coPTIME}}
\newcommand{\coPSPACE}{\mbox{\rm coPSPACE}}
\newcommand{\NPSPACE}{\mbox{\rm NPSPACE}}
\def\EXPTIME{\mbox{\rm EXPTIME}}
\def\doubleEXPTIME{\mbox{\rm 2EXPTIME}}

\newcommand{\M}{{\cal M}}

\newcommand{\smU}{\, {\footnotesize {\sf U}} \, }
\newcommand{\son}{\mbox{\it son}}

\newcommand{\Sub}{\mbox{\sl Sub}}
\newcommand{\smLTL}{\mbox{\footnotesize \sl LTL}}
\newcommand{\smCTL}{\mbox{\footnotesize \sl CTL}}

\newcommand{\vet}[1]{{\bf #1}}

\def\succregion{\mbox{\it succ}}
 
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{multicol}
\newcommand{\prefix}{\mbox{prefix}}

\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\renewcommand{\emptyset}{\varnothing}
\renewcommand{\a}[1]{\textbf{\textit{#1}}}


\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle} 
 \newcommand{\ve}{{{\a v}}}
\newcommand{\de}{\Diamond}
\newcommand{\bo}{\Box}



\title{Parametric LTL on Markov Chains}
\author{Souymodip Chakraborty and Joost-Pieter Katoen\thanks{Currently on sabbatical leave at the University of Oxford, United Kingdom.}}
\institute{RWTH Aachen University, Ahornstra\ss{}e 55, D-52074 Aachen, Germany}
 \authorrunning{S. Chakraborty and J.-P. Katoen}







\pagestyle{headings}  \addtocmark{Hamiltonian Mechanics} 

\begin{document}
 \maketitle

\begin{abstract}
This paper is concerned with the verification of finite Markov chains against parametrized LTL (pLTL) formulas.
In pLTL, the until-modality is equipped with a bound that contains variables; e.g.,  asserts that  holds within  
time steps, where  is a variable on natural numbers.
The central problem studied in this paper is to determine the set of parameter valuations  for which the probability to satisfy pLTL-formula 
 in a Markov chain meets 
a given threshold , where  is a comparison on reals and  a probability.
As for pLTL determining the emptiness of  is undecidable, we consider several logic fragments.
We consider parametric reachability properties, 
a sub-logic of pLTL restricted to next and , 
parametric B\"uchi properties and finally, a maximal subclass of pLTL for which emptiness of  is decidable.
\end{abstract}

\section{Introduction} 
Verifying a finite Markov chain (MC, for short)  against an LTL-formula  amounts to determining the probability that  satisfies , i.e., 
the likelihood of the set of  infinite paths of  satisfying .
Vardi~\cite{DBLP:conf/focs/Vardi85} considered the qualitative version of this problem, that is, does  almost surely satisfy , or with positive probability.
Together with Wolper, he showed that the qualitative LTL model-checking problem for MCs is PSPACE-complete.
The quantitative verification problem -- what is the probability of satisfying ? -- has been treated by Courcoubetis and 
Yannakakis~\cite{DBLP:journals/jacm/CourcoubetisY95}.
An alternative algorithm that has a time complexity which is polynomial in the size of the MC and exponential in  is by 
Couvreur \emph{et al.}~\cite{CouvreurSahebSutre03}.
Recently, practical improvements have been obtained by Chatterjee \emph{et al.} for verifying the LTL(F,G)-fragment on MCs using generalized deterministic Rabin automata~\cite{DBLP:conf/cav/ChatterjeeGK13}.


This paper considers the verification of MCs against \emph{parametric} LTL formulas.
In parametric LTL~\cite{DBLP:journals/tocl/AlurETP01} (pLTL, for short), temporal operators can be subscripted by a variable ranging over the natural numbers.
The formula  means that in at most  steps  occurs, and  means that at every
index  occurs within  steps. 
Note that  and  are variables whose value is not fixed in advance.
The central question is now to determine the values of  and  such that the probability of a given MC satisfying the pLTL-formula  meets a certain 
threshold .
This is referred to as the valuation set  for comparison operator .
This problem has both a qualitative (threshold  and ) and a quantitative variant ().

The main results of this paper are as follows.
Just as for the setting with Kripke structures~\cite{DBLP:journals/tocl/AlurETP01}, it is shown that checking the emptiness of  in 
general is undecidable.
We therefore resort to fragments of pLTL.
We show that determining  can be done by searching in a range defined by the \emph{precision} of the input, 
whereas polynomial time 
graph algorithms suffice for its qualitative variant.
The same applies to formulas of the form .
We provide necessary and sufficient criteria for checking the emptiness of  (and )
for the fragments pLTL(F,X) and pLTL, and prove that checking these criteria are NP-complete and PSPACE-complete, respectively. 
We also define a representation of these sets and provide algorithms to construct them. 



\paragraph{Related work.}
The verification of parametric probabilistic models in which certain transition probabilities are given as parameters (or functions thereof) has recently received 
considerable attention.
Most of these works are focused on parameter synthesis: for which parameter instances does a given (LTL or PCTL) formula hold?
To mention a few, Han \emph{et al.}~\cite{DBLP:conf/rtss/HanKM08} considered this problem for timed reachability in continuous-time MCs, Hahn \emph{et al.}~\cite{DBLP:conf/nfm/HahnHZ11} and
Pugelli \emph{et al.}~\cite{DBLP:conf/cav/Pugelli13} for Markov decision processes (MDPs), and Benedikt \emph{et al.}~\cite{DBLP:conf/tacas/BenediktLW13} for -regular properties of interval MCs.
Hahn~\emph{et al.}~\cite{DBLP:journals/sttt/HahnHZ11} provide an algorithm for computing the rational function expressing the probability of reaching a given set of states in a parametric (reward) MDP based on exploiting regular expressions as initially proposed by Daws~\cite{DBLP:conf/ictac/Daws04}.
Other related work includes the synthesis of loop invariants for parametric probabilistic programs~\cite{DBLP:conf/sas/KatoenMMM10}.
To the best of our knowledge, verifying parametric properties on MCs has not been considered so far.
The closest related works are on combining two-variable FO with LTL for MDPs by Benedikt \emph{et al.}~\cite{DBLP:journals/corr/abs-1303-4533} and 
the computation of quantiles by Ummels and Baier~\cite{DBLP:conf/fossacs/UmmelsB13}.  

\paragraph{Organization of the paper.}
Section~\ref{sec:prelim} presents pLTL and MCs and a first undecidability result.
Section~\ref{sec:reach} considers parametric reachability.
Section~\ref{sec:pltlfx} treats the fragment pLTL(F,X) and
Section~\ref{sec:parambuechi} parametric B\"uchi properties.  
Section~\ref{sec:nobox}  treats the bounded always-free fragment of pLTL. 
Section~\ref{sec:concl} concludes the paper. \
\varphi \ ::= \ a \where \neg \varphi \where \varphi \, \wedge \, \varphi  \where \X\! \varphi \where \varphi \U\varphi \where 
\de_{\hspace{-0.05cm}\prec x} \hspace{0.1cm}\varphi \where \de_{\hspace{-0.05cm}\prec c}\hspace{0.1cm} \varphi

\begin{array}{lcl}
(w,i,{\a v}) \models a & \mbox{iff} & a \in w[i] \\
(w,i,{\a v}) \models \!\Not \varphi & \mbox{iff} & (w,i,{\a v}) \not\models \varphi \\
(w,i,{\a v}) \models \varphi_1 \, \wedge \, \varphi_2 & \mbox{iff} & (w,i,{\a v}) \models\varphi_1 \mbox{ and } (w,i,{\a v}) \models \varphi_2 \\
(w,i,{\a v}) \models \de_{\hspace{-0.05cm}\prec x} \, \varphi & \mbox{iff} &  
   (w,j,{\a v}) \models \varphi \mbox{ for some } j \prec \ve(x){+}i.  \\
\end{array}
\label{equiv}
\begin{array}{rclrcl}
\de_{> x} \, \varphi & \, \equiv \, & \Box_{\leq x} \, \de \X \varphi, & 
\Box_{> x} \, \varphi & \, \equiv \, & \de_{\leq x} \, \Box \X \varphi, 
\\
\varphi \U\!_{\leq x} \, \psi & \, \equiv \, & (\varphi \U \psi) \, \wedge \, \de_{\leq x} \, \psi, \quad 
& \varphi \U\!_{> x} \, \psi & \, \equiv \, & \Box_{\leq x} \left( \varphi \, \wedge \, \X (\varphi \U \psi) \right)
\end{array}

V_{\prec p}(\varphi) \ = \ \set{\ve \mid \Pr (M \models{\a v}(\varphi)) \prec p},

\neg a \wedge \X (\neg a \U\!_{=x} \, a) 
\ \equiv \ 
\X (\neg a \U\!_{\leq x} \, a) \wedge (\neg a \U\!_{> x} \, a),
\label{pltl_d}
\varphi \ ::= \ a \where \neg a \where \varphi \wedge  \varphi \where \varphi  \vee  \varphi \where \X\! \varphi \where \varphi \U \varphi 
\where \varphi \Release \varphi 
\where \Box \varphi \where \de_{\leq x}  \, \varphi \where \de_{\leq c} \, \varphi \where \Box_{\leq c} \, \varphi. 
 \tau({\bf Q}) \ = \ 1-\displaystyle\min_{i,j} \left(\sum_k \min\{{\bf Q}(i,k),{\bf Q}(j,k)\} \right). \mu_{n+1}  =  \sum_{j=0}^{n+1} {\bf i}^T{\bf Q}^j{\bf r} \ \leq \ \sum_{j=0}^{n+1} \tau({\bf Q})^j r_{\max}.
\varphi \ ::= \ a \where \neg a \where \varphi \, \wedge \, \varphi \where \varphi \, \vee \, \varphi \where \X\! \varphi \where \de \varphi \where \de_{\leq x} \, \varphi \where \de_{\leq c} \, \varphi
\label{re}
T(k) = (2^d-1)\cdot T(k{\cdot}2^{{-}d}) + F

\varphi \ ::= \ a \where \neg a \where \varphi \, \wedge \, \varphi \where \varphi \, \vee \, \varphi \where \X\! \varphi \where \varphi \U \varphi 
\where \varphi \Release \varphi 
\where \Box \varphi \where \de_{\leq x} \, \varphi. \footnote{The modalities   and  can be removed with only quadratic blow up.}
1ex] \begin{minipage}{0.5\textwidth}
\begin{itemize}
    \item  iff ,
    \item  iff ,
    \item  iff ,
\end{itemize}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{itemize}
    \item  implies ,
    \item  implies ,
    \item  implies .
\end{itemize}
\end{minipage} \
\Pr(s,q) \ = \ \sum_{(t,q')\in \delta(s,q)} \bfP(s,t) \cdot \Pr(t,q'),

\Paths(s) = \bigcup_{(s,q) \in C} \L_C(s,q)
 
\Pr\bigg(\bigcup_{(s,q)\in C} \L_C(s,q)\bigg) = 1.

 \varphi_1 :=  \bigwedge_{b}\bigg(q_0^b \to \X(\neg q_0^{\bar b} \U\!_{=x}\ q_0^{\bar b}) \wedge \X(q_0^b\U q_0^{\bar b})\bigg).

 \varphi^{bi}:= \bigg( (q_0^b\to \neg q_i^{\bar b}\U q^b_i)\wedge (q_i^b\to \X(\neg q_i^b\U q_0^b)) \wedge (q_i^{+b}\to\X(\neg q_i^{+b}\U q_0^{b}))\\
                \wedge\ (q_i^{-b}\to\X(\neg q_i^{-b}\U q_0^{b})) \wedge (q_i^b \to \X q_i^{+b}) \wedge (q_i^{-b} \to \X q_i^b)\bigg).
  
 \varphi_3 := \bigwedge_b\bigg(q_0^b\to P \wedge \X(P'\U q_0^b)\bigg)

 \varphi_e := \bigwedge_b\bigg( (q_0^b\wedge p_i) \to (\neg q_0^{\bar b}\U p_j \wedge \neg q_0^{\bar b}\U(q_1^{b}\to\X(\neg q_1^b\U_{=x}q_1^{-\bar b})))\bigg) 

 \varphi_e := \bigwedge_b\bigg((q_0^b\wedge p_i) \to (\neg q_0^{\bar b}\U p_j \wedge \X q_1^{-b})\bigg).

\varphi_T:= q_0^0\wedge (\bigwedge_{i=1}^4 \varphi_i) \U p_k.  
 As a satisfiable structure of  encodes a halting computation of  (vice-versa), 
satisfiability of  becomes undecidable. Furthermore,
 if  satisfies  then  is true at some \emph{finite} length of . 
 We can easily construct a
Markov chain  such that the set of finite traces of  is  ( is the set of sets of proposition used).  We know that probability
measure of any finite trace of  is greater than . Thus, we can decide whether  is satisfiable iff we can decide 
 for some valuation . Hence, 
we  conclude that the emptiness problem of  is undecidable. 
\hfill \end{proof}







\section{}
\textbf{Theorem 1.} For  pLTL(F,X),  with .
\begin{proof} 
The direction from right to left is trivial.
Consider the other direction.
Let  be a pLTL(F,X)-formula and assume .
By monotonicity, it suffices to prove that  with  implies .
The proof proceeds in a number of steps. 
(1) We show that it suffices to consider formulas without disjunction. 
(2) We show that if path fragment
, (where LTL(F,X)-formula  is obtained from  by omitting all parameters from ) 
then   with  for every .
(3) We construct a deterministic B\"uchi automaton (DBA)  for  such that its initial and final state are at most  transitions apart.
(4) We show that reachability of a final state in the product of MC  and DBA  implies the existence of a finite path in   
of length at most  satisfying .
\begin{enumerate}
\item
As disjunction distributes over , and , each formula can be written in disjunctive normal form.
Let , where each  is disjunction-free. 
Evidently, .
Assume .
Then,  for some .
Assuming the theorem holds for  (this will be proven below),  with 
.
Since , it follows by monotonicity that , 
and hence, .
It thus suffices in the remainder of the proof to consider disjunction-free formulas.
\item
For pLTL(F,X)-formula , let  be the LTL(F,X)-formula obtained from  by replacing all occurrences of   by , 
e.g., for , . 
We claim that  implies  with  for all . 
This is proven by induction on the structure of . 
The base cases  and  are obvious.
For the induction step, conjunctions,  and  are straightforward.
It remains to consider .
Assume . 
Thus, for some , . 
By induction hypothesis,  with  for each variable  in . 
Thus,  with  and for all  in , .
\item
We provide a DBA
 with  for each LTL(F,X)-formula  using the construction from~\cite{DBLP:journals/tocl/AlurT04}.
We first treat  and .
As every LTL(F,X)-formula can be obtained from ,  and , we then treat these inductive cases.
(Negations are treated similarly.)
For ,  with  and .   For  , the DBA , where ,  and . This completes the base cases.
For the three inductive cases, the DBA is constructed as follows.
\begin{enumerate}
\item
Let .
 where  is fresh, 
 if , , and . 
\item For , the DBA is a standard synchronous product of the DBA for  and .
\item Let .
 where  is fresh,   for all 
 and  for every .
\end{enumerate}
  
A few remarks are in order.
The resulting DBA have a single final state.
In addition, the DBA enjoy the property that the reflexive and transitive closure of the transition relation is a partial order~\cite{DBLP:journals/tocl/AlurT04}.
Formally,  iff  for some . 
The diameter of  is the length of a longest simple path from the initial to the final state.
This implies that
the diameter of  and   is  where  is this diameter of , and
the diameter of  is  where  is the diameter of , .
\item
Let , where each  is disjunction-free, with DBA .
Evidently,  iff  for some disjunct .
Consider the product of MC  and DBA , denoted ; see, e.g., \cite[Def.\ 10.50]{DBLP:books/daglib/0020348}.
By construction,  is partially ordered and has diameter at most .
We have that  iff an accepting state in  is reachable.
Thus, there exists a finite path  in  with , or, .
This concludes the proof. 
\end{enumerate}
 can also be used to show that, if we have a valuation  such that  and for all other variables ,  and 
 then , where  and for , . The argument proceed as induction on .
\hfill 
\end{proof}

\section{}
\textbf{Proposition 5.} The problem  is NP-complete for  pLTL(F,X)
\begin{proof}
 Similar to the NP-hardness proof of satisfiability of LTL(F,X) formulas~\cite[Th.\ 3.7]{SistlaClarke85}, we give a polynomial reduction from the 3-SAT problem.
For 3-CNF formula  with boolean variables , 
we define MC  and pLTL(F,X) formula   such that  is satisfiable iff   is not empty.
Let 3-CNF formula  with , 
where literal  is either  or .
Let MC  with  be:
\begin{itemize}
\item 

\item 
,  for ,  and  for , 
and  (the actual probabilities are not relevant), 
\item
 iff  for some , and  iff  for some , and
 for all .
\end{itemize}
Let pLTL(F,X)-formula . 
Then  is satisfiable iff  is not empty. Evidently,  and  are obtained in polynomial time.

It remains to show membership in NP.
By the proof of Theorem~\ref{FX},  iff there is a finite path of  of length  satisfying 
. 
Thus, we non-deterministically select a path of  of length  and check (using standard algorithms) in polynomial time whether 
it satisfies .  \hfill 
\end{proof}

\section{}
\textbf{Proposition 6.} .
\begin{proof}   
Let  .  is a partially ordered set where  is element-wise comparison. A subset  of  has rank  if the summation of the coordinates of every element of  is .
By~\cite{K1978}, the largest set of incomparable elements (anti-chain) is given by  where  is  if even, else  is . Then  \hfill \end{proof} 



\section{}
\textbf{Theorem 3.}
 where  
if  and  otherwise.

\begin{proof}
We show for , , and for ,
.
Distinguish:
\begin{enumerate}
\item .  
Then, from  an -state in  can be reached within  steps, i.e., .
For this -state, , say, by Proposition~\ref{buchi} it follows .
Together this yields  for each .
For , it follows by Proposition~\ref{buchi} that  for every -state .
Thus, .
\item
.  
As  is accepting, .
Consider a simple path  from  to an -state in .
Let  be the maximal distance between two consecutive -states along this path.
Then it follows  where .
By taking the minimum  over all simple paths between  and , it follows  for each  with .
For , distinguish between  and .
In the former case, it follows (as in the first case) by Proposition~\ref{buchi} that  for all . 
Consider now .
Let .
By contra-position.
Assume .
Let  be a finite path fragment in  where  and  is the first -state along  which belongs to .
Then, by definition of the digraph , the sequence  is a path in  satisfying  for all . 
But then .
Contradiction. \hfill 
\end{enumerate} \end{proof}

\section{}
\textbf{Proposition 9.}
The sets  and  can be determined in polynomial time by a graph analysis of MC .
\begin{proof} 
We argue that  can be determined in polynomial time.
The proof for  goes along similar lines and is omitted here.
We can determine both  and  in linear time.
It remains to obtain  in case .
This can be done as follows.
The distances , required for the function  in the digraph , can be obtained by applying Floyd-Warshall's all-pairs shortest path algorithm on the graph of .
This takes .
To obtain , we use a cost function  which is initially set to  for initial state  and  otherwise.
Let   be a min priority queue, initially containing all vertices of , prioritized by the value of . Algorithm~\ref{buchi-algo} finds 
 in .
\begin{algorithm}
{\small
 \caption{Input: MC   Output: }\label{buchi-algo}
  \begin{algorithmic}[1]
    \State Initialize ,  and .
    \While{ }
      \State ;  ;
      \For{}  \EndFor
    \EndWhile
  \end{algorithmic}
}
\end{algorithm}
Its correctness follows from the invariant . 
Using this we can find the minimum  for which we can reach an accepting BSCC via a finite path satisfying . 
 \hfill 
\end{proof}

\section{}
\noindent
\textbf{Theorem 5.} 
For  pLTL,  with .
\begin{proof} Consider the direction left to right.
 If there exists a reachable maximal SCC  in the cross product  which is not complete then . If every reachable maximal SCC is complete then the model checking task boils down to 
 reachability of such SCC. Thus the existence of a cycle before reaching a complete SCC implies that the probability measure of the set of paths satisfying  is strictly less than  for any 
 value of the parameters. The largest cycle in the product can have at most  states. Thus, if  is less than 1 then  is empty.
 \hfill \end{proof}
 
\end{document}
