\documentclass{article}
\usepackage{amsmath, amsthm, amssymb, amsfonts, bm}
\usepackage{wrapfig}
\usepackage{lipsum}
\usepackage{subcaption}
\usepackage{verbatim}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{mathtools}
\usepackage{array}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{subcaption}
\usepackage[percent]{overpic}
\usepackage[export]{adjustbox}
\usepackage{xr}
\externaldocument{supplementary_material}
\usepackage[numbers]{natbib}
\usepackage[colorlinks]{hyperref}    

\usepackage[final]{neurips_2019}

\usepackage[dvipsnames, table]{xcolor}

\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{url}            \usepackage{booktabs}       \usepackage{nicefrac}       \usepackage{microtype}      \newtheorem{theorem}{Theorem}
\title{Adversarial Robustness through Local Linearization}
\author{Chongli Qin\\DeepMind  
  \And 
  James Martens\\DeepMind  
  \And Sven Gowal \\DeepMind
  \And Dilip Krishnan\\Google 
  \And Krishnamurthy (Dj) Dvijotham \\DeepMind 
  \And Alhussein Fawzi \\DeepMind
  \And Soham De \\DeepMind
  \And Robert Stanforth \\DeepMind 
  \And Pushmeet Kohli \\DeepMind 
  \\ \\
  \texttt{chongliqin@google.com} 
}


\usepackage{graphicx}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem*{cor}{Corollary}

\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\newtheorem{conj}{Conjecture}[section]
\newtheorem{exmp}{Example}[section]

\theoremstyle{remark}
\newtheorem*{rem}{Remark}
\newtheorem*{note}{Note}


\DeclareMathOperator*{\argmax}{\mathrm{argmax}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\br}[1]{\left({#1}\right)}
\newcommand{\abs}[1]{\left\lvert{#1}\right\rvert}\newcommand{\norm}[1]{\left\lVert{#1}\right\rVert}\newcommand{\tmop}[1]{\operatorname{#1}}
\newcolumntype{s}{>{\columncolor[HTML]{FFE4B5}} p{2.3cm}}
\newcolumntype{i}{>{\columncolor[HTML]{FFE4B5}} p{2.3cm}}

\begin{document}

\maketitle
\begin{abstract}
    Adversarial training is an effective methodology for training deep neural networks that are robust against adversarial, norm-bounded perturbations. However, the computational cost of adversarial training grows prohibitively as the size of the model and number of input dimensions increase. Further, training against less expensive and therefore weaker adversaries produces models that are robust against weak attacks but break down under attacks that are stronger. This is often attributed to the phenomenon of {\it gradient obfuscation}; such models have a highly non-linear loss surface in the vicinity of training examples, making it hard for gradient-based attacks to succeed even though adversarial examples still exist. In this work, we introduce a novel regularizer that encourages the loss to behave linearly in the vicinity of the training data, thereby penalizing gradient obfuscation while encouraging robustness. We show via extensive experiments on CIFAR-10 and ImageNet, that models trained with our regularizer avoid gradient obfuscation and can be trained significantly faster than adversarial training. Using this regularizer, we exceed current state of the art and achieve 47\% adversarial accuracy for ImageNet with  adversarial perturbations of radius 4/255 under an untargeted, strong, white-box attack. Additionally, we match state of the art results for CIFAR-10 at 8/255.
\end{abstract}
 \section{Introduction}
In a seminal paper, Szegedy et al.~\citep{szegedy2013intriguing} demonstrated that neural networks are vulnerable to visually imperceptible but carefully chosen \emph{adversarial perturbations} which cause neural networks to output incorrect predictions. After this revealing study, a flurry of research has been conducted with the focus of making networks robust against such adversarial perturbations \cite{kurakin2016adversarial, madry2017towards, moosavi2018robustness, xie2018feature}. Concurrently, researchers devised stronger attacks that expose previously unknown vulnerabilities of neural networks \citep{uesato2018adversarial, carlini2017towards, athalye2018obfuscated, carlini2017adversarial}. 

Of the many approaches proposed~\citep{papernot2016distillation, buckman2018thermometer,dhillon2018stochastic,song2017pixeldefend, ma2018characterizing, moosavi2018robustness}, adversarial training \citep{kurakin2016adversarial, madry2017towards} is empirically the best performing algorithm to train networks robust to adversarial perturbations. However, the cost of adversarial training becomes prohibitive with growing model complexity and input dimensionality. This is primarily due to the cost of computing adversarial perturbations, which is incurred at each step of adversarial training. In particular, for each new mini-batch one must perform multiple iterations of a gradient-based optimizer on the network's inputs to find said perturbations.\footnote{While computing the globally optimal adversarial example is NP-hard~\citep{katz2017reluplex}, gradient descent with several random restarts was empirically shown to be quite effective at computing adversarial perturbations of sufficient quality.}  As each step of this optimizer requires a new backwards pass, the total cost of adversarial training scales as roughly the number of such steps. Unfortunately, effective adversarial training of ImageNet often requires large number of steps to avoid problems of gradient obfuscation~\cite{athalye2018obfuscated, uesato2018adversarial}, making it \emph{much} more expensive than conventional training, almost prohibitively so.


\begin{wrapfigure}{r}{0.4\textwidth}
    \centering
    \includegraphics[width=0.4\textwidth]{figs/ce_loss_landscape_adv_1.pdf}
    \caption{\small{Example of gradient obfuscated surface.}}
    \label{fig:grad_obfs}
\end{wrapfigure}
One approach which can alleviate the cost of adversarial training is training against weaker adversaries that are cheaper to compute. For example, by taking fewer gradient steps to compute adversarial examples during training. However, this can produce models which are robust against weak attacks, but break down under strong attacks -- often due to gradient obfuscation. In particular, one form of gradient obfuscation occurs when the network learns to fool a gradient based attack by making the loss surface highly convoluted and non-linear (see Fig~\ref{fig:grad_obfs}), this has also been observed by Papernot et al~\citep{papernot2017practical}. In turn the non-linearity prevents gradient based optimization methods from finding an adversarial perturbation within a small number of iterations \citep{carlini2017towards,uesato2018adversarial}. In contrast, if the loss surface was \emph{linear} in the vicinity of the training examples, which is to say well-predicted by local gradient information, gradient obfuscation cannot occur. In this paper, we take up this idea and introduce a novel regularizer that encourages the loss to behave linearly in the vicinity of the training data. We call this regularizer the \textit{local linearity regularizer} (LLR).
Empirically, we find that networks trained with LLR exhibit far less gradient obfuscation, and are almost equally robust against strong attacks as they ares against weak attacks. 

The main contributions of our paper are summarized below:
\begin{itemize}
\item We show that training with LLR is significantly faster than adversarial training, allowing us to train a robust ImageNet model with a  speed up when training on 128 TPUv3 cores~\citep{tpu}.
\item We show that LLR trained models exhibit higher robustness relative to adversarially trained models when  evaluated under strong attacks. Adversarially trained models can exhibit a decrease in accuracy of 6\% when increasing the attack strength at test time for CIFAR-10, whereas LLR shows only a decrease of 2\%.
\item We achieve new state of the art results for adversarial accuracy against untargeted white-box attack for ImageNet (with \footnote{This means that every pixel is perturbed independently by up to 4 units up or down on a scale where pixels take values ranging between 0 and 255.}): . Furthermore, we match state of the art results for CIFAR 10 (with ): \footnote{We note that TRADES \cite{zhang2019theoretically} gets 55\% against a much weaker attack; under our strongest attack, it gets 52.5\%.}. 
\item We perform a  large scale evaluation of existing methods for adversarially robust training under consistent, strong, white-box attacks. For this we recreate several baseline models from the literature, training them both for CIFAR-10 and ImageNet (where possible).\footnote{Baselines created are adversarial training, TRADES and CURE \cite{moosavi2018robustness}. To the contrary of CIFAR-10, we are currently unable to achieve consistent and competitive results on ImageNet at  using TRADES.}
\end{itemize}

 \section{Background and Related Work}
We denote our classification function by , mapping input features  to the output logits for classes in set , i.e. , with  being the model parameters and  being the label. Adversarial robustness for  is defined as follows: a network is robust to adversarial perturbations of magnitude  at input  if and only if

In this paper, we focus on  and we use  to denote  for brevity. Given the dataset is drawn from distribution , the standard method to train a classifier  is empirical risk minimization (ERM), which is defined by:
 Here,  is the standard cross-entropy loss function defined by

where  is defined as above, and  is a 1-hot vector representing the class label. While ERM is effective at training neural networks that perform well on holdout test data, the accuracy on the test set goes to zero under adversarial evaluation. This is a result of a distribution shift in the data induced by the attack. To rectify this, adversarial training~\cite{moosavi2018robustness, kurakin2016adversarial} seeks to perturb the data distribution by performing adversarial attacks during training. More concretely, adversarial training minimizes the loss function

where the {\it inner maximization}, , is typically performed via a fixed number of steps of a gradient-based optimization method. One such method is Projected-Gradient-Descent (PGD) which performs the following gradient step:

where . Another popular gradient-based method is to use the sign of the gradient~\citep{goodfellow2014explaining}. 
The cost of solving Eq~\eqref{eq:cross_entropy_loss_adv} is dominated by the cost of solving the inner maximization problem. Thus, the inner maximization should be performed efficiently to reduce the overall cost of training. A naive approach is to reduce the number of gradient steps performed by the optimization procedure. Generally, the attack is weaker when we do fewer steps. If the attack is too weak, the trained networks often display gradient obfuscation as highlighted in Fig~\ref{fig:grad_obfs}. 

Since the invention of adversarial training, a corpus of work has researched alternative ways of making networks robust. One such approach is the TRADES method~\citep{zhang2019theoretically} which is a form of regularization that specifically maximizes the trade-off between robustness and accuracy -- as many studies have observed these two quantities to be at odds with each other~\citep{tsipras2018robustness}. Others, such as work by Ding et al~\citep{ding2018max} adaptively increase the perturbation radius by find the minimal length perturbation which changes the output label. Some have proposed architectural changes which promote adversarial robustness, such as the "denoise" model~\citep{xie2018feature} for ImageNet.



The work presented here is a regularization technique which enforces the loss function to be well approximated by its linear Taylor expansion in a sufficiently small neighbourhood. There has been work before which uses gradient information as a form of regularization~\citep{simard1992tangent, moosavi2018robustness}. The work presented in this paper is closely related to the paper by Moosavi et al~\citep{moosavi2018robustness}, which highlights that adversarial training reduces the curvature of  with respect to . Leveraging an empirical observation (the highest curvature is along the direction ), they further propose an algorithm to mimic the effects of adversarial training on the loss surface. The algorithm results in comparable performance to adversarial training with a significantly lower cost. 
 \section{Motivating the Local Linearity Regularizer}\label{sec:more_linear}
As described above, the cost of adversarial training is dominated by solving the inner maximization problem . Throughout we abbreviate  with . We can reduce this cost simply by reducing the number of PGD (as defined in Eq~\eqref{eq:pgd}) steps  taken to solve . To motivate the local linearity regularizer (LLR), we start with an empirical analysis of how the behavior of adversarial training changes as we increase the number of PGD steps used during training. We find that the loss surface becomes increasingly linear as we increase the number of PGD steps, captured by the local linearity measure defined below.

\subsection{Local Linearity Measure}
Suppose that we are given an adversarial perturbation . The corresponding adversarial loss is given by . If our loss surface is smooth and approximately linear, then  is well approximated by its first-order Taylor expansion .
In other words, the absolute difference between these two values,

is an indicator of how linear the surface is. Consequently, we consider the quantity

to be a measure of how linear the surface is within a neighbourhood . We call this quantity the \textit{local linearity measure}. 

\subsection{Empirical Observations on Adversarial Training}\label{sec:adv_train_analysis}
\begin{figure}[htb]
    \centering
    \hspace{-1cm}
    \begin{subfigure}[b]{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figs/not_linear.pdf}\caption{}\label{subfig:linear_not}
    \end{subfigure}
    \begin{subfigure}[b]{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figs/almost_linear.pdf}\caption{}\label{subfig:linear}
    \end{subfigure}
    \caption{\small{Plots showing that  is large (on the order of ) when we train with just one or two steps of PGD for inner maximization, (\ref{subfig:linear_not}). In contrast,  becomes increasingly smaller (on the order of ) as we increase the number of PGD steps to  and above, (\ref{subfig:linear}). The -axis is the number of training iterations and the -axis is , here  for CIFAR-10.}}
    \label{fig:obfuscation_vs_smooth}
\end{figure}

We measure  for networks trained with adversarial training on CIFAR-10, where the inner maximization  is performed with 1, 2, 4, 8 and 16 steps of PGD.  is measured throughout training on the training set\footnote{To measure  we find  with 50 steps of PGD using Adam as the optimizer and 0.1 as the step size.}. The architecture used is a wide residual network~\citep{zagoruyko2016wide} 28 in depth and 10 in width  (Wide-ResNet-28-10).  The results are shown in Fig~\ref{subfig:linear_not} and \ref{subfig:linear}. Fig~\ref{subfig:linear_not} shows that when we train with one and two steps of PGD for the inner maximization, the local loss surface is extremely non-linear. An example visualization of such a loss surface is given in Fig~\ref{subfig:obfs_landscape}. However, when we train with four or more steps of PGD for the inner maximization, the surface is relatively well approximated by  as shown in Fig~\ref{subfig:linear}. An example of the loss surface is shown in Fig~\ref{subfig:not_obfs_landscape}. For the adversarial accuracy of the networks, see Table~\ref{tab:1248_acc}.
 \section{Local Linearity Regularizer (LLR)}
From the section above, we make the empirical observation that the local linearity measure  decreases as we train with stronger attacks\footnote{Here, we imply an increase in the number of PGD steps for the inner maximization .}. In this section, we give some theoretical justifications of why local linearity  correlates with adversarial robustness, and derive a regularizer from the local linearity measure that can be used for training of robust models.

\subsection{Local Linearity Upper Bounds Adversarial Loss}\label{sec:upper_bound}


The following proposition establishes that the adversarial loss  is upper bounded by the local linearity measure, plus the change in loss as predicted by the gradient (which is given by ).

\begin{prop}\label{Thm1}
 Consider a loss function  that is once-differentiable, and a local neighbourhood defined by . Then for all  

\end{prop}
See Appendix~\ref{app:proof} for the proof.

From Eq~\eqref{eq:upper_bound} it is clear that the adversarial loss tends to , i.e., , as both  and  for all . And assuming  one also has the upper bound .



\subsection{Local Linearity Regularization (LLR)}
Following the analysis above, we propose the following objective for adversarially robust training

where  and  are hyper-parameters to be optimized, and 
 (recall the definition of  from Eq~\eqref{eq:d_lin}). We highlighted  as this is the local linearity term which measures how well approximated the loss is with respect to its linear Taylor approximation.
Concretely, we are trying to find the point  in  where the linear approximation  is maximally violated. To train we penalize both its linear violation  and the gradient magnitude term , as required by the above proposition. We note that, analogous to adversarial training, LLR requires an inner optimization to find  -- performed via gradient descent. However, as we will show in the experiments, much fewer optimization steps are required for the overall scheme to be effective.  Pseudo-code for training with this regularizer is given in Appendix~\ref{app:LLR}.

\subsection{Local Linearity  is a sufficient regularizer by itself}Interestingly, under certain reasonable approximations and standard choices of
loss functions, we can bound  in
terms of . See Appendix~\ref{ap:bounds_on_beta} for details. Consequently, the bound in Eq~\eqref{eq:upper_bound} implies that minimizing 
(along with the nominal loss ) is {\it sufficient} to minimize the adversarial
loss .
This prediction is confirmed by our experiments. However, our experiments also
show that including  in the objective along
with  and  works better in practice on certain
datasets, especially ImageNet. See Appendix~\ref{sec:ablation} for details.

 \section{Experiments and Results}
We perform experiments using LLR on both CIFAR-10~\citep{krizhevsky2009learning} and ImageNet~\citep{deng2009imagenet} datasets. We show that LLR gets state of the art adversarial accuracy on CIFAR-10 (at ) and ImageNet (at ) evaluated under a strong adversarial attack. Moreover, we show that as the attack strength increases, the degradation in adversarial accuracy is more graceful for networks trained using LLR than for those trained with standard adversarial training. Further, we demonstrate that training using LLR is  faster for ImageNet. Finally, we show that, by linearizing the loss surface, models are less prone to gradient obfuscation.

\textbf{CIFAR-10: }The perturbation radius we examine is  and the model architectures we use are Wide-ResNet-28-8, Wide-ResNet-40-8~\citep{zagoruyko2016wide}. Since the validity of our regularizer requires  to be smooth, the activation function we use is softplus function , which is a smooth version of ReLU. The baselines we compare our results against are adversarial training (ADV)~\citep{madry2017towards}, TRADES~\cite{zhang2019theoretically} and CURE~\citep{moosavi2018robustness}. We recreate these baselines from the literature using the same network architecture and activation function. The evaluation is done on the full test set of 10K images.

\textbf{ImageNet:} The perturbation radii considered are  and . The architecture used for this is from \citep{he2016deep} which is ResNet-152. We use softplus as activation function. For , the baselines we compare our results against is our recreated versions of ADV~\citep{madry2017towards} and denoising model (DENOISE)~\citep{xie2018feature}.\footnote{We attempted to use TRADES on ImageNet but did not manage to get competitive results. Thus they are omitted from the baselines.} For , we compare LLR to ADV~\citep{madry2017towards} and DENOISE~\citep{xie2018feature} networks which have been published from the the literature. Due to computational constraints, we limit ourselves to evaluating all models on the first 1K images of the test set.

To make sure that we have a close estimate of the true robustness, we evaluate all the models on a wide range of attacks these are described below.

\subsection{Evaluation Setup}\label{sec:attack_defn}
To accurately gauge the {\it true} robustness of our network, we tailor our attack to give the lowest possible adversarial accuracy. The two parts which we tune to get the optimal attack is the loss function for the attack and its corresponding optimization procedure. The loss functions used are described below, for the optimization procedure please refer to Appendix~\ref{sec:optimization}.

\textbf{Loss Functions:} The three loss functions we consider are summarized in Table~\ref{tab:different_attacks}. We use the difference between logits for the loss function rather than the cross-entropy loss as we have empirically found the former to yield lower adversarial accuracy. 


\begin{table}[htb]
    \centering
    \begin{tabular}{p{3.0cm}||p{6cm}|p{3cm}}
{\bf Attack Name}   &  {\bf Loss Function} & {\bf Metric}\\\hline
       Random-Targeted  &  & Attack Success Rate\\
Untargeted &   & Adversarial Accuracy\\
Multi-Targeted &  & Adversarial Accuracy 
    \end{tabular}
    \vspace{0.2cm}
    \caption{\small{This shows the loss functions corresponding to the attacks we use for evaluation and also the metric we measure on the test set for each of these attacks. Notation-wise,  is the highest logit excluding the logits corresponding to the correct class , note  can change through the optimization procedure. For the Random-Targeted attack,  is a randomly chosen target label that is not  and does not change throughout the optimization.  stands for the set of class labels. For the Multi-Targeted attack we maximize  for all , and consider the attack successful if any of the individual attacks on each each target class  are successful. The metric used on the Random-Targeted attack is the {\it attack success rate}: the percentage of attacks where the target label  is indeed the output label (this metric is especially important for ImageNet at ). For the other attacks we use the adversarial accuracy as the metric which is the accuracy on the test set after the attack.}}\label{tab:different_attacks}
\end{table}
\vspace{-0.5cm}
 
\subsection{Results for Robustness}
\begin{table}[htb]
\centering
\begin{tabular}{ p{2.2cm}||p{2.3cm}|p{2.3cm}|p{2.3cm}|s}
 &\multicolumn{4}{c}{{\bf\textcolor{Mahogany}{CIFAR-10: Wide-ResNet-28-8 (8/255)}}} \\
 \hline
 Methods& Nominal& FGSM-20&Untargeted & Multi-Targeted\\
 \hline
Attack Strength  & & Weak & Strong & Very Strong \\\hline
 ADV\cite{madry2017towards}& 87.25\% & 48.89\%   &  45.92\%& 44.54\%  \\
 CURE\cite{moosavi2018robustness}&   80.76\%  & 39.76\%    &38.87\%& 37.57\% \\
 ADV(S) & 85.11\%  &{\bf 56.76\%}  &  {\bf 53.96\%}& 48.79\%\\
 CURE(S) &   84.31\%  & 48.56\%   & 47.28\% & 45.43\% \\
 TRADES(S) & {\bf 87.40\%} &  51.63 & 50.46\% &  49.48\%\\\
 LLR (S)   &86.83\% & 54.24\% & 52.99\% & {\bf 51.13\%} \\
 \hline
& \multicolumn{4}{c}{{\bf\textcolor{Mahogany}{CIFAR-10: Wide-ResNet-40-8 (8/255)}}} \\
 \hline
 ADV(R)  & 85.58\% & 56.32\%  &52.34\% &   46.89\%   \\
 TRADES(R) & 86.25\% & 53.38\% &  51.76\%&50.84\%\\
 ADV(S) & 85.27\%& {\bf 57.94\%} &{\bf 55.26\%} & 49.79\% \\
 CURE(S) &   84.45\%  & 49.41\%  & 47.69\% & 45.51\% \\
 TRADES(S) & {\bf 88.11\%} & 53.03\% & 51.65\% & 50.53\%\\
 LLR (S)   & 86.28\%& 56.44\%  &  54.95\% & {\bf 52.81\%}\\
  \hline
\end{tabular}
\vspace{0.2cm}
\caption{\small{Model accuracy results for CIFAR-10. Our LLR regularizer performs the best under the strongest attack (highlighted column). (S) denotes softplus activation; (R) denotes ReLU activation; and models with (S, R) are \emph{our implementations}.}}\label{tab:cifar10}
\end{table}
For CIFAR-10, the main adversarial accuracy results are given in Table \ref{tab:cifar10}. We compare LLR training to ADV~\citep{madry2017towards}, CURE~\citep{moosavi2018robustness} and TRADES~\citep{zhang2019theoretically}, both with our re-implementation and the published models \footnote{Note the network published for TRADES~\citep{zhang2019theoretically} uses a Wide-ResNet-34-10 so this is not shown in the table but under the same rigorous evaluation we show that TRADES get 84.91\% nominal accuracy, 53.41\% under Untargeted and 52.58\% under Multi-Targeted. We've also ran DeepFool (not in the table as the attack is weaker) giving ADV(S): 64.29\%, CURE(S): 58.73\%, TRADES(S): 63.4\%, LLR(S): 65.87\%.}. Note that our re-implementation using softplus activations perform at or above the published results for ADV, CURE and TRADES. This is largely due to the learning rate schedule used, which is the similar to the one used by TRADES~\citep{zhang2019theoretically}.

Interestingly, for adversarial training (ADV), using the Multi-Targeted attack for evaluation gives significantly lower adversarial accuracy compared to Untargeted. The accuracy obtained are  and  respectively. Evaluation using Multi-Targeted attack consistently gave the lowest adversarial accuracy throughout. Under this attack, the methods which stand out amongst the rest are LLR and TRADES. Using LLR we get state of the art results with  adversarial accuracy. 

\begin{table}[htb]
\centering
\begin{tabular}{p{2cm}||p{2.3cm}|p{2.3cm}|i| p{2.7cm} }
& \multicolumn{4}{c}{{\bf \textcolor{RoyalBlue}{ImageNet: ResNet-152 (4/255)}}} \\
 \hline
 Methods& PGD steps & Nominal  &Untargeted &Random-Targeted\\
 \hline
   & \multicolumn{3}{c|}{Accuracy} & Success Rate \\\hline
 ADV & 30 &69.20\%  &39.70\%  &  0.50\%  \\
 DENOISE & 30 & 69.70\% & 38.90\% & \textbf{0.40\%} \\
 LLR   &{\bf 2} & {\bf 72.70\%}  &  {\bf 47.00\%}& {\bf 0.40\%}\\
 \hline
 &\multicolumn{4}{c}{{\bf \textcolor{RoyalBlue}{ImageNet: ResNet-152 (16/255)}}} \\
 \hline
 ADV~\cite{xie2018feature}  & 30 & 64.10\%  &  6.30\%&  40.00\%\\
 DENOISE~\cite{xie2018feature} & 30 & {\bf 66.80}\% & {\bf 7.50\%} & {\bf 38.00\%} \\
 LLR  & {\bf 10} & 51.20\% & 6.10\%&  43.80\%\\
\end{tabular}
\vspace{0.2cm}
\caption{\small{LLR gets 47\% adversarial accuracy for 4/255 -- 7.30\% higher than DENOISE and ADV. For 16/255, LLR gets similar robustness results, but it comes at a significant cost to the nominal accuracy. Note Multi-Targeted attacks for ImageNet requires looping over 1000 labels, this evaluation can take up to several days even on 50 GPUs thus is omitted from this table. The column of the strongest attack is highlighted.}}\label{tab:imagenet}\vspace{-0.5cm}
\end{table}

For ImageNet, we compare against adversarial training (ADV)~\citep{madry2017towards}  and the denoising model (DENOISE)~\citep{xie2018feature}. The results are shown in Table~\ref{tab:imagenet}. For a perturbation radius of 4/255, LLR gets 47\% adversarial accuracy under the Untargeted attack which is notably higher than the adversarial accuracy obtained via adversarial training which is 39.70\%. Moreover, LLR is trained with just two-steps of PGD rather than 30 steps for adversarial training. The amount of computation needed for each method is further discussed in Sec~\ref{sec:compute}.

Further shown in Table \ref{tab:imagenet} are the results for . We note a significant drop in nominal accuracy when we train with LLR to perturbation radius 16/255. When testing for perturbation radius of 16/255 we also show that the adversarial accuracy under Untargeted is very poor (below 8\%) for all methods. We speculate that this perturbation radius is too large  for the robustness problem. Since adversarial perturbations should be, {\it by definition}, imperceptible to the human eye, upon inspection of the images generated using an adversarial attack (see Fig~\ref{fig:change_of_visual}) - this assumption no longer holds true. The images generated appear to consist of super-imposed object parts of other classes onto the target image. This leads us to believe that a more fine-grained analysis of what should constitute "robustness for ImageNet" is an important topic for debate. 
\vspace{-0.1cm}
\subsubsection{Runtime Speed}\label{sec:compute}
For ImageNet, we trained on 128 TPUv3 cores~\citep{tpu}, the total training wall time for the LLR network (4/255) is 7 hours for 110 epochs. Similarly, for the adversarially trained (ADV) networks the total wall time is 36 hours for 110 epochs. This is a  speed up.
\vspace{-0.1cm}
\subsubsection{Accuracy Degradation: Strong vs Weak Evaluation}\label{sec:strong_weak}
\begin{figure}[htb]
    \centering
    \hspace{-0.5cm}
    \begin{subfigure}{0.5\textwidth}
    \includegraphics[width=\textwidth]{figs/weak_to_strong_cifar_large.pdf}\caption{CIFAR-10 (8/255)}\label{fig:weak_vs_strong_cifar}
    \end{subfigure}
    \begin{subfigure}{0.5\textwidth}
    \includegraphics[width=\textwidth]{figs/weak_to_strong_imagenet_large.pdf}\caption{ImageNet (4/255)}\label{fig:weak_vs_strong_imagenet}
    \end{subfigure}
    \caption{\small{Adversarial accuracy shown for CIFAR-10, (\ref{fig:weak_vs_strong_cifar}), and ImageNet, (\ref{fig:weak_vs_strong_imagenet}), as we increase the strength of attack. (\ref{fig:weak_vs_strong_cifar}) shows LLR's adversarial accuracy degrades gracefully going from 53.32\% to 51.14\% (-2.18\%) while ADV's adversarial accuracy drops from 54.43\% to 48.79\% (-5.64\%). (\ref{fig:weak_vs_strong_imagenet}) LLR remains 7.5\% higher in terms of adversarial accuracy (47.20\%) compared to ADV (39.70\%). The annotations on each node denotes no. of PGD steps  no. of random restarts (see Appendix~\ref{sec:optimization}). (\ref{fig:weak_vs_strong_cifar}), background color denotes whether the attack is Untargeted (blue) or Multi-Targeted (orange). (\ref{fig:weak_vs_strong_imagenet}), we only use Untargeted attacks.}}
    \label{fig:weak_vs_strong}
\end{figure}
The resulting model trained using LLR degrades gracefully in terms of adversarial accuracy when we increase the strength of attack, as shown in Fig~\ref{fig:weak_vs_strong}. In particular, Fig~\ref{fig:weak_vs_strong_cifar} shows that, for CIFAR-10, when the attack changes from Untargeted to Multi-Targeted, the LLR's accuracy remains similar with only a  drop in accuracy. Contrary to adversarial training (ADV), where we see a  drop in accuracy. We also see similar trends in accuracy in Table~\ref{tab:cifar10}. This could indicate that some level of obfuscation may be happening under standard adversarial training.

As we empirically observe that LLR evaluates similarly under weak and strong attacks, we hypothesize that this is because LLR explicitly linearizes the loss surface. An extreme case would be when the surface is completely linear - in this instance the optimal adversarial perturbation would be found with just one PGD step. Thus evaluation using a weak attack is often good enough to get an accurate gauge of how it will perform under a stronger attack. 

For ImageNet, see Fig~\ref{fig:weak_vs_strong_imagenet}, the adversarial accuracy trained using LLR remains significantly higher (7.5\%) than the adversarially trained network going from a weak to a stronger attack. 
\subsection{Resistance to Gradient Obfuscation}\label{sec:resistance}
\begin{figure}[htb]
    \centering
    \begin{subfigure}{0.24\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figs/ce_loss_landscape_adv_1.pdf}
    \caption{ADV-1}\label{fig:adv1}
    \end{subfigure}
    \begin{subfigure}{0.24\textwidth}
    \includegraphics[width=\textwidth]{figs/ce_loss_landscape_linearize_1.pdf}
    \caption{LLR-1}\label{fig:llr1}
    \end{subfigure}
    \begin{subfigure}{0.24\textwidth}
    \includegraphics[width=\textwidth]{figs/ce_loss_landscape_adv_2.pdf}
    \caption{ADV-2}\label{fig:adv2}
    \end{subfigure}
    \begin{subfigure}{0.24\textwidth}
    \includegraphics[width=\textwidth]{figs/ce_loss_landscape_linearize_2.pdf}
    \caption{LLR-2}\label{fig:llr2}
    \end{subfigure}
    \caption{\small{Comparing the loss surface, , after we train using just 1 or 2 steps of PGD for the inner maximization of either the adversarial objective (ADV)  or the linearity objective (LLR) . Results are shown for image 126 in test set of CIFAR-10, the nominal label is deer. ADV- refers to adversarial training with  PGD steps, similarly with LLR-.}}
    \label{fig:one_step}
\end{figure}
We use either the standard adversarial training objective (ADV-1, ADV-2) or the LLR objective (LLR-1, LLR-2) and taking one or two steps of PGD to maximize each objective. To train LLR-1/2, we only optimize the local linearity , i.e.  in Eq.~\eqref{eq:linearity_attack} is set to zero. We see that for adversarial training, as shown in Figs~\ref{fig:adv1},~\ref{fig:adv2}, the loss surface becomes highly non-linear and jagged -- in other words obfuscated. Additionally in this setting, the adversarial accuracy under our strongest attack is  for both, see Table~\ref{tab:acc_12}. In contrast, the loss surface is smooth when we train using LLR as shown in Figs~\ref{fig:llr1}, \ref{fig:llr2}. Further, Table~\ref{tab:acc_12} shows that we obtain an adversarial accuracy of  with the LLR-2 network under our strongest evaluation. We also evaluate the values of  for the CIFAR-10 test set after these networks are trained. This is shown in Fig~\ref{fig:average_linearity}. The values of  are comparable when we train with LLR using two steps of PGD to adversarial training with 20 steps of PGD. By comparison, adversarial training with two steps of PGD results in much larger values of .
 

 \section{Conclusions}
We show that, by promoting linearity, deep classification networks are less susceptible to gradient obfuscation, thus allowing us to do fewer gradient descent steps for the inner optimization. Our novel linearity regularizer promotes locally linear behavior as justified from a theoretical perspective. The resulting models achieve state of the art adversarial robustness on the CIFAR-10 and Imagenet datasets, and can be trained  faster than regular adversarial training.

%
 
\bibliographystyle{plain}
\begin{thebibliography}{10}

\bibitem{athalye2018obfuscated}
Anish Athalye, Nicholas Carlini, and David Wagner.
\newblock Obfuscated gradients give a false sense of security: Circumventing
  defenses to adversarial examples.
\newblock {\em arXiv preprint arXiv:1802.00420}, 2018.

\bibitem{buckman2018thermometer}
Jacob Buckman, Aurko Roy, Colin Raffel, and Ian Goodfellow.
\newblock Thermometer encoding: One hot way to resist adversarial examples.
\newblock 2018.

\bibitem{carlini2017adversarial}
Nicholas Carlini and David Wagner.
\newblock Adversarial examples are not easily detected: Bypassing ten detection
  methods.
\newblock In {\em Proceedings of the 10th ACM Workshop on Artificial
  Intelligence and Security}, pages 3--14. ACM, 2017.

\bibitem{carlini2017towards}
Nicholas Carlini and David Wagner.
\newblock Towards evaluating the robustness of neural networks.
\newblock In {\em 2017 IEEE Symposium on Security and Privacy (SP)}, pages
  39--57. IEEE, 2017.

\bibitem{deng2009imagenet}
Jia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li~Fei-Fei.
\newblock Imagenet: A large-scale hierarchical image database.
\newblock In {\em 2009 IEEE conference on computer vision and pattern
  recognition}, pages 248--255. Ieee, 2009.

\bibitem{dhillon2018stochastic}
Guneet~S Dhillon, Kamyar Azizzadenesheli, Zachary~C Lipton, Jeremy Bernstein,
  Jean Kossaifi, Aran Khanna, and Anima Anandkumar.
\newblock Stochastic activation pruning for robust adversarial defense.
\newblock {\em arXiv preprint arXiv:1803.01442}, 2018.

\bibitem{ding2018max}
Gavin~Weiguang Ding, Yash Sharma, Kry Yik~Chau Lui, and Ruitong Huang.
\newblock Max-margin adversarial (mma) training: Direct input space margin
  maximization through adversarial training.
\newblock {\em arXiv preprint arXiv:1812.02637}, 2018.

\bibitem{goodfellow2014explaining}
Ian~J Goodfellow, Jonathon Shlens, and Christian Szegedy.
\newblock Explaining and harnessing adversarial examples.
\newblock {\em arXiv preprint arXiv:1412.6572}, 2014.

\bibitem{tpu}
Google.
\newblock Google, 2018.
\newblock \url{https://cloud.google.com/tpu/}, 2018.

\bibitem{he2016deep}
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun.
\newblock Deep residual learning for image recognition.
\newblock In {\em Proceedings of the IEEE conference on computer vision and
  pattern recognition}, pages 770--778, 2016.

\bibitem{katz2017reluplex}
Guy Katz, Clark Barrett, David~L Dill, Kyle Julian, and Mykel~J Kochenderfer.
\newblock Reluplex: An efficient smt solver for verifying deep neural networks.
\newblock In {\em International Conference on Computer Aided Verification},
  pages 97--117. Springer, 2017.

\bibitem{kingma2014adam}
Diederik~P Kingma and Jimmy Ba.
\newblock Adam: A method for stochastic optimization.
\newblock {\em arXiv preprint arXiv:1412.6980}, 2014.

\bibitem{krizhevsky2009learning}
Alex Krizhevsky and Geoffrey Hinton.
\newblock Learning multiple layers of features from tiny images.
\newblock Technical report, Citeseer, 2009.

\bibitem{kurakin2016adversarial}
Alexey Kurakin, Ian Goodfellow, and Samy Bengio.
\newblock Adversarial machine learning at scale.
\newblock {\em arXiv preprint arXiv:1611.01236}, 2016.

\bibitem{ma2018characterizing}
Xingjun Ma, Bo~Li, Yisen Wang, Sarah~M Erfani, Sudanthi Wijewickrema, Grant
  Schoenebeck, Dawn Song, Michael~E Houle, and James Bailey.
\newblock Characterizing adversarial subspaces using local intrinsic
  dimensionality.
\newblock {\em arXiv preprint arXiv:1801.02613}, 2018.

\bibitem{madry2017towards}
Aleksander Madry, Aleksandar Makelov, Ludwig Schmidt, Dimitris Tsipras, and
  Adrian Vladu.
\newblock Towards deep learning models resistant to adversarial attacks.
\newblock {\em arXiv preprint arXiv:1706.06083}, 2017.

\bibitem{martens2010deep}
James Martens.
\newblock Deep learning via hessian-free optimization.
\newblock In {\em ICML}, volume~27, pages 735--742, 2010.

\bibitem{martens2014new}
James Martens.
\newblock New insights and perspectives on the natural gradient method.
\newblock {\em arXiv preprint arXiv:1412.1193}, 2014.

\bibitem{moosavi2018robustness}
Seyed-Mohsen Moosavi-Dezfooli, Alhussein Fawzi, Jonathan Uesato, and Pascal
  Frossard.
\newblock Robustness via curvature regularization, and vice versa.
\newblock {\em arXiv preprint arXiv:1811.09716}, 2018.

\bibitem{papernot2017practical}
Nicolas Papernot, Patrick McDaniel, Ian Goodfellow, Somesh Jha, Z~Berkay Celik,
  and Ananthram Swami.
\newblock Practical black-box attacks against machine learning.
\newblock In {\em Proceedings of the 2017 ACM on Asia conference on computer
  and communications security}, pages 506--519. ACM, 2017.

\bibitem{papernot2016distillation}
Nicolas Papernot, Patrick McDaniel, Xi~Wu, Somesh Jha, and Ananthram Swami.
\newblock Distillation as a defense to adversarial perturbations against deep
  neural networks.
\newblock In {\em 2016 IEEE Symposium on Security and Privacy (SP)}, pages
  582--597. IEEE, 2016.

\bibitem{schraudolph2002fast}
Nicol~N Schraudolph.
\newblock Fast curvature matrix-vector products for second-order gradient
  descent.
\newblock {\em Neural computation}, 14(7):1723--1738, 2002.

\bibitem{simard1992tangent}
Patrice Simard, Bernard Victorri, Yann LeCun, and John Denker.
\newblock Tangent prop-a formalism for specifying selected invariances in an
  adaptive network.
\newblock In {\em Advances in neural information processing systems}, pages
  895--903, 1992.

\bibitem{song2017pixeldefend}
Yang Song, Taesup Kim, Sebastian Nowozin, Stefano Ermon, and Nate Kushman.
\newblock Pixeldefend: Leveraging generative models to understand and defend
  against adversarial examples.
\newblock {\em arXiv preprint arXiv:1710.10766}, 2017.

\bibitem{szegedy2013intriguing}
Christian Szegedy, Wojciech Zaremba, Ilya Sutskever, Joan Bruna, Dumitru Erhan,
  Ian Goodfellow, and Rob Fergus.
\newblock Intriguing properties of neural networks.
\newblock {\em arXiv preprint arXiv:1312.6199}, 2013.

\bibitem{tsipras2018robustness}
Dimitris Tsipras, Shibani Santurkar, Logan Engstrom, Alexander Turner, and
  Aleksander Madry.
\newblock Robustness may be at odds with accuracy.
\newblock {\em stat}, 1050:11, 2018.

\bibitem{uesato2018adversarial}
Jonathan Uesato, Brendan O'Donoghue, Aaron van~den Oord, and Pushmeet Kohli.
\newblock Adversarial risk and the dangers of evaluating against weak attacks.
\newblock {\em arXiv preprint arXiv:1802.05666}, 2018.

\bibitem{xie2018feature}
Cihang Xie, Yuxin Wu, Laurens van~der Maaten, Alan Yuille, and Kaiming He.
\newblock Feature denoising for improving adversarial robustness.
\newblock {\em arXiv preprint arXiv:1812.03411}, 2018.

\bibitem{zagoruyko2016wide}
Sergey Zagoruyko and Nikos Komodakis.
\newblock Wide residual networks.
\newblock {\em arXiv preprint arXiv:1605.07146}, 2016.

\bibitem{zhang2019theoretically}
Hongyang Zhang, Yaodong Yu, Jiantao Jiao, Eric~P Xing, Laurent~El Ghaoui, and
  Michael~I Jordan.
\newblock Theoretically principled trade-off between robustness and accuracy.
\newblock {\em arXiv preprint arXiv:1901.08573}, 2019.

\end{thebibliography}
 \newpage
\appendix
\appendix
\section{Empirical Observations on Adversarial Training: Supplementary}
\begin{figure}[htb]
    \centering
    \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figs/ce_loss_landscape_adv_1.pdf}\caption{1 step}\label{subfig:obfs_landscape}
    \end{subfigure}
    \begin{subfigure}[t]{0.45\textwidth}
    \includegraphics[width=\textwidth]{figs/ce_loss_landscape_adv_8.pdf}
    \caption{8 steps}\label{subfig:not_obfs_landscape}
    \end{subfigure}
    \caption{A plot of  around the image 126 of CIFAR-10 test set which shows that training with just 1 step of PGD for {\it adversarial training} gets highly non-linear loss surface - (\ref{subfig:obfs_landscape}), while training with 8 steps of PGD the surface becomes more smooth - (\ref{subfig:not_obfs_landscape}). (\ref{subfig:obfs_landscape}, \ref{subfig:not_obfs_landscape}) are  projection onto 2D plane, where one direction is the adversarial perturbation while the other is random.}
    \label{fig:loss_landscape_18}
\end{figure}
\begin{table}[htb]
\centering
\begin{tabular}{ p{3.0cm}||p{2.7cm}|p{3.3cm}}
 &\multicolumn{2}{c}{{\bf\textcolor{Mahogany}{CIFAR-10: Wide-ResNet-28-10 (8/255)}}} \\
 \hline
No. of PGD step&  Nominal Accuracy & Adversarial Accuracy (Multi-Targeted)\\
 \hline
1 & 84.42\%& 0.0\%  \\
2 & 83.67\% & 0.0\%  \\
4 & 87.70\%& 45.91\%  \\
8 & 87.20\%& 46.03\%  \\
16 & 86.78\% & 46.14\%  \\
\end{tabular}
\caption{Table showing the corresponding nominal accuracy and adversarial accuracy for networks trained shown in Fig~\ref{fig:obfuscation_vs_smooth}. The Multi-Targeted is described in Sec.~\ref{sec:attack_defn}.}\label{tab:1248_acc}
\end{table}
\section{Local Linearity Upper Bounds Robustness: Proof of Proposition \ref{Thm1}}\label{app:proof}
{\bf Proposition~\ref{Thm1}. }
 {\it  Consider a loss function  that is once-differentiable, and a local neighbourhood defined by . Then for all  }

\begin{proof}
Firstly we note that  can be rewritten as the following: 

Thus we can form the following bound:

where . We note that since

therefore for all 

\end{proof}
\section{Local Linearity  is a sufficient regularizer by itself}\label{ap:bounds_on_beta}
\subsection{A local quadratic model of the loss}

The starting point for proving our bounds will be the following local
quadratic approximation of the loss:

Here,  is the Generalized Gauss-Newton matrix (GGN) \citep{schraudolph2002fast, martens2014new}, and  denotes the error of the approximation.

The GGN is a Hessian-alternative which appears frequently in approximate
2nd-order optimization algorithms for neural networks. It is defined for
losses of the form , where  is convex
in . (Valid examples for  include the standard softmax
cross-entropy error and squared error.) It's given by

where  is the Jacobian of , and  is the Hessian of 
with respect to .

One interpretation of the GGN is that it's the Hessian of a modified loss
, where  is the local
linear approximation of  (given by ). 
For certain standard loss functions (including the ones we consider) it
also corresponds to the Fisher Information Matrix associated with the
network's predictive distribution \citep{martens2014new}.

In the context of optimization, the local quadratic approximation induced by
the GGN tends to work better than the actual 2nd-order Taylor series \citep[e.g.][]{martens2010deep}, perhaps
because it gives a better approximation to  over
non-trivial distances \citep{martens2014new}. (It must necessarily be a worse approximation for very small values of , since the 2nd-order Taylor series is clearly optimal in that respect.)

\subsection{Bounds for common loss functions}

Our basic strategy in proving the following results is to rearrange Eq
\eqref{eqn:ggn-quad-approx} to establish the following bound on the curvature in
terms of  which is defined in Eq~\eqref{eq:d_lin} in the main text:

We then show that for both the squared error and softmax cross-entropy loss
functions, one can bound  in terms of the
curvature  and by extension is bounded by the local linearity measure: . Note that such a bound won't exist for general loss functions.

\begin{prop}
  \label{prop:square_error_bound}Suppose that  is the squared error and  is the output of the neural network. Then for any perturbation vector  we
  have
  
  where  is the error of the local quadratic approximation
  defined in Equation \ref{eqn:ggn-quad-approx}.
\end{prop}

\begin{prop}
  \label{prop:cross_entropy_bound}Suppose that  is the softmax cross-entropy error, where  is a 1-hot target
  vector, and  is the vector of probabilities computed via the softmax
  function. Then for any perturbation vector  we have
  
  where  is the error of the local quadratic approximation
  defined in Equation \ref{eqn:ggn-quad-approx}.
\end{prop}

\begin{rem}
  We note  is just the probability of the target label under the
  model. And so  won't be very big, provided that the model is
  properly classifying the data with some reasonable degree of certainty.
  (Indeed, for highly certain predictions it will be close to .) Thus the
  upper bound given in Proposition \ref{prop:cross_entropy_bound} should
  shrink at a reasonable rate as the regularizer  does,
  provided that error term  is negligable.
\end{rem}

\section{Proofs}

\subsection{Proof of Proposition \ref{prop:square_error_bound}}

\begin{proof}
  For convenience we will write , where
  we have defined .
  
  We observe that for the squared error loss, 
  and  (because ).
  
  Thus by Equation \ref{eqn:curvature-bound} we have
  
  Using these facts, and applying the Cauchy-Schwarz inequality, we get
  
  Taking the square root of both sides yields the claim.
\end{proof}

\subsection{Proof of Proposition \ref{prop:cross_entropy_bound}}

\begin{proof}
  We begin by defining , and observing that for the softmax
  cross-entropy loss, , and  where
  
  Because the entries of  are non-negative and sum to  we can factor
  this as
  
  and where  is defined as the entry-wise square root of the vector . To
  see that this is correct, note that
  
  where we have used the properties of  and , such as ,
  , etc.
  
  Using this factorization we can rewrite the curvature term as
  
  where we have defined  (intuitively, this is ``the
  change in  due to ''). Thus by Equation \ref{eqn:curvature-bound}
  we have
  
  Let , which is well defined because  is
  entry-wise positive (since  must be), and  is a one-hot vector. Using
  said properties of  and  we have that
  
  where  denotes the entry-wise product.
  
  It thus follows that
  
  Using the above facts, and applying the Cauchy-Schwarz inequality, we arrive
  at
  
  where we have used the facts that  and . Taking the square root of both sides yields the claim.
\end{proof}
\section{Local Linearity Regularizer - Algorithm}\label{app:LLR}
\begin{algorithm}[htb]
  \caption{Local Linearization of Network}
  \begin{algorithmic}[1]
    \REQUIRE {Training data X = . Learning rate  and batch size for training  and number of iterations . Number of iterations for inner optimization  and step size  and network architecture parameterized by .}
    \STATE Initialize variables . 
    \FORALL{ }
    \STATE Get mini-batch .
    \STATE Calculte loss wrt to minibatch .
    \STATE Initialize initial perturbation  uniformly in the interval .
	\FORALL{ }
	\STATE Calculate  at .
	\STATE Update 
    \ENDFOR
    \STATE Compute objective 
    \STATE 
    \ENDFOR
  \end{algorithmic}
  \label{alg:learning}
\end{algorithm}
Note .
\section{Experiments and Results: Supplementary}
\subsection{Evaluation Setup}\label{sec:optimization}
\textbf{Optimization:} Rather than using the sign of the gradient (FGSM)~\citep{goodfellow2014explaining}, we do the update steps using Adam \citep{kingma2014adam} as the optimizer. More concretely, the update on the adversarial perturbation is . We have consistently found that using Adam gives a stronger attack compared to the sign of the gradient. For Multi-Targeted (see Table~\ref{tab:different_attacks}), the step size is set to be  and we run for 200 steps. For Untargeted and Random-Targeted, we use a step size schedule setting  up until 100 steps then 0.01 up until 150 steps and 0.001 for the last 50 steps. We find these to give us the best adversarial accuracy evaluation, the decrease in step size is especially helpful in cases where the gradient is obfuscated. Furthermore, we use 20 different random initialization (we term this a {\it random restart}) of the perturbation, , for going through the optimization procedure. We consider an attack successful if any of these 20 random restarts is successful. For CIFAR-10 we also show results for FGSM with 20 steps (FGSM-20) with a step size  as this is a commonly used attack for evaluation.

\subsection{Training and Hyperparameters}
The hyperparameters for  and  are chosen by doing a hyperparameter sweep. 
\paragraph{CIFAR-10:}For all of the baselines we recreated and the LLR network we used the same schedule which is inspired by TRADES~\citep{zhang2019theoretically}. For Wide-ResNet-28-8, we use initial learning rate 0.1 and we decrease after 100 and 105 epochs. We train till 110 epochs. For Wide-ResNet-40-8 we use initial learning rate 0.1 and we decrease after 100 and 105 epochs with a factor of 0.1. We train to 110 epochs. The optimizer we used momentum 0.9. For LLR the  and , the weight placed on the nominal loss  is also 2. We use -regularization of 2e-4. The training is done on a batch size of 256. We also slowly increase the size of the perturbation radius over 15 epochs starting from 0.0 until it gets to 8/255. For Wide-ResNet-28-8, Wide-ResNet-40-8 we train with 10 and 15 steps of PGD respectively using Adam with step size of 0.1. 

\paragraph{ImageNet (4/255):} To train the LLR network the initial learning rate is 0.1, the decay schedule is similar to \citep{xie2018feature}, we decay by 0.1 after 35, 70 and 95 epochs. We train for 100 epochs. The LLR hyperparameters are  and , the weights placed on the nominal loss is 3. We use -regularization of 1e-4. The training is done on batch size of 512. We slowly increase the perturbation radius over 20 epochs from 0 to 4/255. We train with 2 steps of PGD using Adam and step size 0.1. 

\paragraph{ImageNet (16/255):} To train the LLR network the initial learning rate is 0.1, we decay by 0.1 after 17 and 35 epochs and 50 epochs -- we train to 55 epochs. The LLR hyperparameters are  and , the weights placed on the nominal loss is 3. We use -regularization of 1e-4. The training is done on batch size of 512. We slowly increase the perturbation radius over 90 epochs from 0 to 16/255. We train with 10 steps of PGD using Adam with step size of 0.1. 

\paragraph{Batch Normalization}During training we use the local batch statistics at the nominal point. Suppose  denotes the local batch statistics at every layer of the network for point . Let us also denote  to be the loss function corresponding to when we use batch statistics  and . Then the loss we calculate at train time is the following

where  and 

\subsection{Ablation Studies}\label{sec:ablation}
\begin{table}[htb]
\centering
\begin{tabular}{ p{3.8cm}||p{2.3cm}|p{2.3cm}|p{2.7cm}}
 &\multicolumn{3}{c}{{\bf\textcolor{Mahogany}{CIFAR-10: Wide-ResNet-28-8 (8/255)}}} \\
 \hline
 Regularizer& Nominal & Untargeted  & Multi-Targeted\\
 \hline
 & \multicolumn{3}{c}{Accuracy}\\\hline
   & 84.75\%&  50.42\%&  49.38\%  \\
   & 86.83\% &  52.99\% &  51.13\%\\
 \hline
 &\multicolumn{3}{c}{{\bf \textcolor{RoyalBlue}{ImageNet: ResNet-152 (4/255)}}} \\\hline
 Regularizer& Nominal  &Untargeted &Random-Targeted\\
 \hline
 & \multicolumn{2}{c|}{Accuracy} & Success Rate \\\hline
    & 71.40\%&  41.30\%&    1.90\% \\
  & 72.70\% &  47.00\% & 0.40\%\\
\end{tabular}
\caption{By removing  from LLR shown in Eq.~\eqref{eq:linearity_attack}, the adversarial accuracy evaluated using multi-targeted reduces by  for CIFAR-10 while the adversarial reduces by .}\label{tab:ablation}
\end{table}

We investigate the effects of adding the term  into LLR shown in Eq.~\eqref{eq:linearity_attack}. The results are shown in Table~\ref{tab:ablation}. We can see that adding the term  only yields minor improvements to the adversarial accuracy (49.38\% vs 51.13\%) for CIFAR-10, while we get a boost of almost 6\% adversarial accuracy for ImageNet (41.30\% vs 47.00\%).
\subsection{Resistance to Gradient Obfuscation}
\begin{table}[htb]
\centering
\begin{tabular}{ p{2cm}||p{2.3cm}|p{2.3cm}|p{2.3cm}|p{2.3cm}}
&\multicolumn{4}{c}{{\bf\textcolor{Mahogany}{CIFAR-10: Wide-ResNet-28-8 (8/255)}}} \\
 \hline
 Methods& PGD steps & Nominal &Untargeted  & Multi-Targeted\\
 \hline
 ADV-1 & 1& 88.45\%&  0.00\%&  0.00\%  \\
 ADV-2 & 2  & 76.63\%&  0.00\%&  0.00\%  \\\hline
 LLR-1 &1  & 93.03\% &  1.80\% &  1.60\%\\
 LLR-2 & 2  & 90.46\% &  46.47\% &  44.50\%\\
\end{tabular}
\caption{This shows that LLR trained with even just two steps of PGD can get an adversarial accuracy of 44.50\% under the strongest evaluation, while both adversarially trained networks (ADV-1, ADV-2) gets 0.0\%. }\label{tab:acc_12}
\end{table}
\begin{figure}[htb]
    \centering
    \begin{subfigure}{0.47\textwidth}
    \includegraphics[width=\textwidth, trim={2cm, 0, 2cm, 0}, clip]{figs/adv2_global_linear_deerbird.pdf}
    \caption{ADV-2}
    \end{subfigure}\hspace{0.5cm}
    \begin{subfigure}{0.47\textwidth}
    \includegraphics[width=\textwidth, trim={2cm, 0, 2cm, 0}, clip]{figs/llr2_global_linear_deerbird.pdf}
    \caption{LLR-2}
    \end{subfigure}
    \caption{We show adversarial examples arising from training with either 2-step PGD adversarial training or 2-step PGD LLR. For both (a) and (b), the first image is the original, the second is the adversarially perturbed image and the third image to is the scaled adversarial perturbation found using 50 steps of PGD.}
    \label{fig:semantic_image_cifar}
    \includegraphics[width=0.6\textwidth]{figs/hist_two_step_merged.pdf}
    \caption{This is a histogram plot of the values of  on the test set after training is done either with two steps of PGD for the linearity objective (orange); two-steps of PGD for the adversarial objective (blue) or 20 steps of PGD for the adversarial objective (green). The statistics of  after training with 2-steps of PGD with the linearity objective aligns well with training using 20 steps of the adversarial objective. In contrast, training with 2-steps of PGD of the adversarial objective gets very different looking histogram, where we obtain much higher values of . }
    \label{fig:average_linearity}
\end{figure}


In Fig~\ref{fig:semantic_image_cifar} we show the adversarial perturbations for networks ADV-2 and LLR-2. We see that, in contrast to LLR-2, the adversarial perturbation for ADV-2 looks similar to random noise. When the adversarial perturbation resembles random noise, this is often a sign that the network is gradient obfuscated.

Furthermore, we show that the adversarial accuracy for LLR-2 is 44.50\% as opposed to ADV-2 which is 0\%. Surprisingly, even training with just 1 step of PGD for LLR (LLR-1) we obtain non-zero adversarial accuracy.

In Fig~\ref{fig:average_linearity}, we show the values of  we obtain when we train with LLR or adversarial training (ADV). To find  we maximize  by running 50 steps of PGD with step size 0.1. Here, we see that values of  for adversarial training with 20 steps of PGD is similar to LLR-2. In contrast, adversarial training (ADV-2) with just two steps of PGD gives much higher values of .


\subsection{Adversarially Perturbed Images for 16/255}
\begin{figure}[htb]
    \centering
    \includegraphics[width=0.7\textwidth, trim={4cm, 0, 3cm, 0}, clip]{figs/washbasin.pdf}
    \includegraphics[width=0.7\textwidth, trim={4cm, 0, 3cm, 0}, clip]{figs/washer.pdf}
    \includegraphics[width=0.7\textwidth, trim={4cm, 0, 3cm, 0}, clip]{figs/snowmobile.pdf}\caption{Images created with adversarial attack on a LLR model for perturbation radius . The image which is attacked is the 1st of the validation set for ImageNet, the true label is "bobsled". Each row displays the images in the following order: original image, adversarially perturbed image and the adversarial perturbation (scaled). The attack attempts to imprint faint images onto the white background. Additionally, the curb (where we often expect a bobsled to be next to) on the right of the original image has been completely removed by the attack.}
    \label{fig:change_of_visual}
\end{figure}
The perturbation radius 16/255 has become the norm~\citep{kurakin2016adversarial, xie2018feature} to use to gauge how robust a network is on ImageNet. However, to be robust we need to make sure that the perturbation is sufficiently small such that it does not significantly affect our visual perception. We hypothesize that this perturbation radius is outside of this regime. Fig~\ref{fig:change_of_visual} shows that we can find examples which not only wipe out objects (the curbs) in the image, but can actually add faint images onto the white background. This significantly affects our visual perception of the image.



 \end{document}
