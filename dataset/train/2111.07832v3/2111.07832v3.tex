\documentclass{article} \usepackage{iclr2022_conference,times}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{amssymb}\usepackage{pifont}\newcommand{\cmark}{\ding{51}}\newcommand{\xmark}{\ding{55}}\usepackage{makecell}
\usepackage{caption}
\usepackage{color}
\usepackage{colortbl}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{enumitem}
\usepackage{tablefootnote}
\definecolor{cyan}{cmyk}{.3,0,0,0}
\definecolor{lightblue}{HTML}{B0C4DE}
\definecolor{darkblue}{HTML}{177CB0}
\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcounter{rownumbers}
\newcommand\rownumber{\stepcounter{rownumbers}\arabic{rownumbers}}
\usepackage{textcomp}
\usepackage[misc,geometry]{ifsym}
\newcommand{\textapprox}{\raisebox{0.5ex}{\texttildelow}}

\usepackage[unicode=true,colorlinks=true]{hyperref}
              
\usepackage{float}
\usepackage{wrapfig}
\usepackage[ruled]{algorithm2e}
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{darkblue}{#1}}
\SetCommentSty{mycommfont}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\vthetap{{\bm{\theta'}}}
\def\vphi{{\bm{\phi}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\usepackage{bbm}


\makeatletter\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}
	{.25em \@plus1ex \@minus.2ex}{-.5em}{\normalfont\normalsize\bfseries}}\makeatother
	
\newcommand{\cihang}[1]{\textcolor{orange}{[cihang: #1]}}
\newcommand{\kt}[1]{\textcolor{blue}{#1}}
\newcommand{\cw}[1]{\textcolor{purple}{#1}}
\newcommand{\jh}[1]{\textcolor{red}{#1}}
\definecolor{green}{rgb}{0.204,0.659,0.325}
\providecommand{\huiyu}[1]{{\protect\color{green}{Huiyu: #1}}}

\usepackage{soul}
	\definecolor{airforceblue}{rgb}{0.36, 0.54, 0.66}
\newcommand{\wsc}[1]{\textcolor{airforceblue}{#1}}
\newcommand{\wsr}[2]{\st{#1} \textcolor{airforceblue}{#2}}
\newcommand{\ws}[1]{\textcolor{airforceblue}{[WS: #1]}}



\def\ourmethod{{iBOT}\xspace} 

\title{
iBOT \includegraphics[width=0.5cm,height=0.5cm]{pics/ibot.pdf}: 
Image BERT Pre-Training with Online \\ Tokenizer
}


\author{\hspace{-2ex}
\centerline{Jinghao Zhou\textsuperscript{\rm 1} \ Chen Wei\textsuperscript{\rm 2} \ Huiyu Wang\textsuperscript{\rm 2} \ Wei Shen\textsuperscript{\rm 3} \ Cihang Xie\textsuperscript{\rm 4} \ Alan Yuille\textsuperscript{\rm 2} \ Tao Kong\textsuperscript{\rm 1}} \\
\centerline{\hspace{-2ex}\textsuperscript{\rm 1}ByteDance \ \textsuperscript{\rm 2}Johns Hopkins University \ \textsuperscript{\rm 3}Shanghai Jiao Tong University \ \textsuperscript{\rm 4}UC Santa Cruz} \\ 
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy 

\usepackage{xspace}
\makeatletter
\DeclareRobustCommand\onedot{\futurelet\@let@token\@onedot}
\def\@onedot{\ifx\@let@token.\else.\null\fi\xspace}

\def\eg{\emph{e.g}\onedot} \def\Eg{\emph{E.g}\onedot}
\def\ie{\emph{i.e}\onedot} \def\Ie{\emph{I.e}\onedot}
\def\cf{\emph{c.f}\onedot} \def\Cf{\emph{C.f}\onedot}
\def\etc{\emph{etc}\onedot} \def\vs{\emph{vs}\onedot}
\def\wrt{w.r.t\onedot} \def\dof{d.o.f\onedot}
\def\etal{\emph{et al}\onedot}
\makeatother

\begin{document}

\maketitle

{\let\thefootnote\relax\footnotetext{Email: Jinghao Zhou\textless\href{mailto:jensen.zhoujh@gmail.com}{jensen.zhoujh@gmail.com}\textgreater, Tao Kong\textless\href{mailto:kongtao@bytedance.com}{kongtao@bytedance.com}\textgreater.}}

\vspace{-0.1cm}
\begin{abstract}
The success of language Transformers is primarily attributed to the pretext task of masked language modeling (MLM) \citep{bert}, where texts are first tokenized into semantically meaningful pieces.
In this work, we study masked image modeling (MIM) and indicate the advantages and challenges of using a semantically meaningful visual tokenizer.
We present a self-supervised framework \ourmethod that can perform masked prediction with an \textit{online tokenizer}. 
Specifically, we perform self-distillation on masked patch tokens and take the teacher network as the online tokenizer, along with self-distillation on the class token to acquire visual semantics.
The online tokenizer is jointly learnable with the MIM objective and dispenses with a multi-stage training pipeline where the tokenizer needs to be pre-trained beforehand.
We show the prominence of \ourmethod by achieving an \textbf{82.3\%} linear probing accuracy and an \textbf{87.8\%} fine-tuning accuracy evaluated on ImageNet-1K.
Beyond the state-of-the-art image classification results, we underline emerging local semantic patterns, which helps the models to obtain strong robustness against common corruptions and achieve leading results on dense downstream tasks, \eg, 
object detection, instance segmentation, and semantic segmentation.
The code and models are publicly available at \href{https://github.com/bytedance/ibot}{https://github.com/bytedance/ibot}.
\end{abstract}

\vspace{-0.1cm}
\section{Introduction}

\begin{wrapfigure}{r}{7.2cm}
\centering
\vspace{-1.2cm}
\includegraphics[height=7.2cm,width=7.2cm]{pics/params.pdf}
\vspace{-0.8cm}
\caption{\textbf{Linear probing accuracy on ImageNet.} 
We compare \ourmethod with other unsupervised baselines.
}
\vspace{-0.5cm}
\label{fig:param}
\end{wrapfigure}



\underline{M}asked \underline{L}anguage \underline{M}odeling (MLM), which first randomly masks and then reconstructs a set of input tokens, is a popular pre-training paradigm for language models.
The MLM pre-trained Transformers~\citep{bert} have demonstrated their scalability to large-capacity models and datasets, becoming a de-facto standard for lingual tasks.
However, its potential for Vision Transformer (ViT), which recently started to revolutionize computer vision research~\citep{deit, vit}, has been largely underexplored.
Most popular unsupervised pre-training schemes in vision deal with the global views~\citep{mocov3,dino}, neglecting images' internal structures, as opposed to MLM modeling local tokens.  
In this work, we seek to continue the success of MLM and explore \underline{M}asked \underline{I}mage \underline{M}odeling (MIM) for training better Vision Transformers such that it can serve as a standard component, as it does for NLP. 


One of the most crucial components in MLM is the \textit{lingual tokenizer} which splits language into semantically meaningful tokens, \eg, WordPiece~\citep{wordpiece} in BERT. 
Similarly, the crux of MIM lies in a proper design of \textit{visual tokenizer}, which transforms the masked patches to supervisory signals for the target model, as shown in Fig.~\ref{fig:tokenizer}.
However, unlike lingual semantics arising naturally from the statistical analysis of word frequency~\citep{bpe}, 
visual semantics cannot be extracted such easily due to the continuous property of images. Empirically, visual semantics emerges progressively by bootstrapping online representation that enforces a similarity of distorted image views~\citep{moco,byol,swav}.
This property intuitively indicates a multi-stage training pipeline, where we need to first train an off-the-shelf semantic-rich tokenizer before training the target model. However, since acquiring visual semantics is a common end for both the tokenizer and target model, a single-stage training pipeline where the tokenizer and target model can be jointly optimized awaits further exploration.

Previous works partially tackle the above challenges.
Several works use identity mapping as the visual tokenizer, \ie, predicting the raw pixel values~\citep{inpainting,sit}. Such paradigm struggles in semantic abstraction and wastes the capacity at modeling high-frequency details, yielding less competitive performance in semantic understanding~\citep{survey_gen_con}. 
Recently, BEiT~\citep{beit} proposes to use a pre-trained discrete VAE~\citep{dalle} as the tokenizer. Though providing some level of abstraction, the discrete VAE is still found only to capture low-level semantics within local details (as observed by Tab. \ref{tab:components}). 
Moreover, the tokenizer needs to be offline pre-trained with fixed model architectures and extra dataset~\citep{dalle}, which potentially limits its adapativity to perform MIM using data from different domains.


\begin{wrapfigure}{r}{4cm}
\centering
\vspace{-0.4cm}
\includegraphics[height=4cm,width=4cm]{pics/architecture2.pdf}
\vspace{-0.6cm}
\caption{\textbf{Masked image modeling.}  denotes an image and \textit{Tok.} denotes a visual tokenizer. }
\vspace{-0.6cm}
\label{fig:tokenizer}
\end{wrapfigure}

To this end, we present \ourmethod \includegraphics[width=0.3cm,height=0.3cm]{pics/ibot.pdf}, short for \textbf{i}mage \textbf{B}ERT pre-training with \textbf{O}nline \textbf{T}okenizer, a new framework that performs MIM with a tokenizer handling above-mentioned challenges favorably.
We motivate \ourmethod by formulating the MIM as knowledge distillation (KD), which learns to distill knowledge from the tokenizer, and further propose to perform self-distillation for MIM with the help of twin teacher as online tokenizer.
The target network is fed with a masked image while the online tokenizer with the original image. 
The goal is to let the target network recover each masked patch token to its corresponding tokenizer output.
Our online tokenizer naturally resolves two major challenges. 
On the one hand, our tokenizer captures high-level visual semantics progressively learned by enforcing the similarity of cross-view images on class tokens. On the other hand, our tokenizer needs no extra stages of training as pre-processing setup since it is jointly optimized with MIM via momentum update.



The online tokenizer enables \ourmethod to achieve excellent performance for feature representation. Specifically, \ourmethod advances ImageNet-1K classification benchmark under -NN, linear probing and fine-tuning protocols to 77.1\%, 79.5\%, 84.0\% with ViT-Base/16 respectively, which is 1.0\%, 1.3\%, 0.4\% higher than previous best results. 
When pre-trained with ImageNet-22K, \ourmethod with ViT-L/16 achieves a linear probing accuracy of \textbf{82.3\%} and a fine-tuning accuracy of \textbf{87.8\%}, which is 1.0\% and 1.8\% higher than previous best results.
Beyond that, the advancement is also valid when transferring to other datasets or under semi-supervised and unsupervised classification settings. 
Of particular interest, we have identified an emerging part-level semantics that can help the model with image recognition both on global and local scales.
We identify that the semantic patterns learned in patch tokens, which sufficiently lack in the off-line tokenizer as in BEiT~\citep{beit}, helps the model to be advanced in linear classification and robustness against common image corruptions.
When it is transferred to downstream tasks, we show that in downstream tasks related to image classification, object detection, instance segmentation, and semantic segmentation, \ourmethod surpasses previous methods with nontrivial margins.
All of the evidence demonstrates that \ourmethod has largely closed the gap of masked modeling pre-training between language and vision Transformers.



\section{Preliminaries}

\subsection{Masked Image Modeling as Knowledge Distillation}

Masked image modeling (MIM), which takes a similar formulation as MLM in BERT, has been proposed in several recent works~\citep{beit, vimpac}. Specifically, for an image token sequence , MIM first samples a random mask  according to a prediction ratio , where  is the number of tokens. The patch token  where  being , denoted as , are then replaced with a mask token , yielding a corrupted image . MIM is to recover the masked tokens   from the corrupted image , \ie, to maximize: ,
where  holds with an independence assumption that each masked token can be reconstructed separately.
In BEiT \citep{beit},  is modelled as a categorical distribution and the task is to minimize

where  transforms the input to a probability distribution over  dimensions, and  is parameters of a discrete VAE~\citep{dalle} that clusters image patches into  categories and assigns each patch token a one-hot encoding identifying its category.
We note this loss is formulated similarly to knowledge distillation ~\citep{distill}, where knowledge is distilled from a pre-fixed tokenizer parameterized by  to current model parameterized by .

\subsection{Self-Distillation}

Self-distillation, proposed recently in DINO~\citep{dino}, distills knowledge not from posterior distributions  
but past iterations of model itself  and is cast as a \textit{discriminative} self-supervised objective.
Given the training set , an image  is sampled uniformly, over which two random augmentations are applied, yielding two distorted views  and . The two distorted views are then put through a teacher-student framework to get the predictive categorical distributions from the \texttt{[CLS]} token:   and . The knowledge is distilled from teacher to student by minimizing their cross-entropy, formulated as

The teacher and the student share the same architecture consisting of a backbone  (\eg, ViT) and a projection head . The parameters of the student network  are Exponentially Moving Averaged (EMA) to the parameters of teacher network . 
The loss is symmetrized by averaging with another cross-entropy term between  and .



\section{\ourmethod}

We motivate our method by identifying the similar formulation of Eq.~(\ref{eq:lbeit}) and Eq.~(\ref{eq:cls_obj}). A visual tokenizer parameterized by online  instead of pre-fixed  thus arises naturally.
In this section, we present \ourmethod, casting self-distillation as a \textit{token-generation} self-supervised objective and perform MIM via self-distillation. We illustrate the framework of \ourmethod in Fig.~\ref{fig:architecture} and demonstrate the pseudo-code in Appendix~\ref{sec:code}. In Sec.~\ref{sec:implementation}, we briefly introduce the architecture and pre-training setup. 

\subsection{Framework}

\begin{figure}[!t]
\centering
\includegraphics[height=0.3\linewidth]{pics/architecture.pdf}
\vspace{-0.1cm}
\caption{\textbf{Overview of \ourmethod framework, performing masked image modeling with an \textit{online tokenizer}.} 
Given two views  and  of an image , each  view is passed through a teacher network  and a student network . \ourmethod minimizes two losses. The first loss  is self-distillation between cross-view \texttt{[CLS]} tokens.
The second loss  is self-distillation between in-view patch tokens, with some tokens masked and replaced by  for the student network. The objective is to reconstruct the masked tokens with the teacher networks' outputs as supervision.
}
\vspace{-0.4cm}
\label{fig:architecture}
\end{figure}

First, we perform blockwise masking \citep{beit} on the two augmented views  and  and obtain their masked views  and .
Taking  as an example for simplicity, the student network outputs for the masked view  projections of its patch tokens  and the teacher network outputs for the non-masked view  projections of its patch tokens . 
We here define the training objective of MIM in \ourmethod as 

We symmetrize the loss by averaging with another CE term between  and .

The backbone together with the projection head of teacher network  is, therefore, a visual tokenizer that generates online token distributions for each masked patch token. 
The tokenizer used in \ourmethod is jointly learnable to MIM objective without a need of being pre-trained in an extra stage, a bonus feature of which is now its domain knowledge can be distilled from the current dataset rather than fixed to the specified dataset.


To ensure that the online tokenizer is semantically-meaningful, we perform self-distillation on \texttt{[CLS]} token of cross-view images such that visual semantics can be obtained via bootstrapping, as achieved by the majority of the self-supervised methods ~\citep{moco,byol,dino}. 
In practice, \ourmethod works with  in Eq.~(\ref{eq:cls_obj}) proposed in DINO ~\citep{dino}, except that now we have  instead of  as input for the student network. To further borrow the capability of semantics abstraction acquired from self-distillatin on \texttt{[CLS]} token, we share the parameters of projection heads for \texttt{[CLS]} token and patch tokens, \ie, , . We empirically find that it produces better results than using separate heads.

Unlike tokenized words whose semantics are almost certain, image patch is ambiguous in its semantic meaning. Therefore, tokenization as one-hot discretization can be sub-optimal for images. 
In \ourmethod, we use the token distribution after softmax instead of the one-hot token id as a supervisory signal, which plays an important role in \ourmethod pre-training as shown in Tab.~\ref{tab:continuous}. 


\subsection{Implementation}
\label{sec:implementation}

\paragraph{Architecture.} 
We use the Vision Transformers \citep{vit} and Swin Transformers \citep{swin} with different amounts of parameters, ViT-S/16, ViT-B/16, ViT-L/16, and Swin-T/\{7,14\} as the backbone . For ViTs, /16 denotes the patch size being . For Swins,  denotes the window size being  or .
We pre-train and fine-tune the Transformers with -size images, so the total number of patch tokens is . The projection head  is a -layer 
MLPs
with -normalized bottleneck following DINO~\citep{dino}. 
Towards a better design to acquire visual semantics, we studied different sharing strategies between projection heads  and , considering that semantics obtained in distillation on \texttt{[CLS]} token helps the training of MIM on patch tokens. We empirically find that sharing the entire head prompts the best performance. 
We set the output dimension of the shared head to .


\paragraph{Pre-Training Setup.} 
We by default pre-train \ourmethod on ImageNet-1K \citep{imagenet} training set with AdamW \citep{adamw} optimizer and a batch size of . We pre-train \ourmethod with ViT-S/16 for  epochs, ViT-B/16 for  epochs, ViT-L/16 for  epochs, and Swin-T/\{7,14\} for  epochs.
We also pre-train on ImageNet-22K training set with ViT-B/16 for  epochs and ViT-L/16 for  epochs.
The learning rate is linearly ramped up during the first  epochs to its base value scaled with the total batch size: .
We use random MIM, with prediction ratio  set as  with a probability of  and uniformly sampled from range [, ] with a probability of .
We sum  and  up without scaling.




\section{Experiment}
\label{sec:exp}

We first transfer \ourmethod to downstream tasks, following the standard evaluation protocols adopted in prior arts, the details of which are delayed in Appendix~\ref{sec:addimplement}.
We then study several interesting properties of Transformers pre-trained with \ourmethod. 
Finally, we give a brief ablation study on the crucial composing of \ourmethod.

\subsection{Classification on ImageNet-1K}
\label{sec:imagenet}

We consider five classification protocols on ImageNet-1K: -NN, linear probing, fine-tuning, semi-supervised learning, and unsupervised learning.

\begin{table}[tbp]
\begin{minipage}[c]{.52\linewidth}
\captionsetup{width=0.98\linewidth}
\caption{\textbf{-NN and linear probing on ImageNet-1K}.  denotes using selective kernel.  denotes pre-training on ImageNet-22K.}
\label{tab:linear}
\vspace{-0.2cm}
\centering
\setlength{\tabcolsep}{1.2mm}{
\scalebox{0.9}{
\begin{tabular}{llccccc}
Method & Arch. & Par. & im/s & Epo.\tablefootnote{\label{effepo}Effective pre-training epochs accounting for actual trained images/views. See Appenix~\ref{sec:multicrop} for details.} & -NN & Lin. \\
\toprule
\multicolumn{7}{l}{\textit{SSL big ResNets}} \\
MoCov3 & RN50 & 23 & 1237 & 1600 & - & 74.6 \\
SwAV & RN50 & 23 & 1237 & 2400 & 65.7 & 75.3 \\
DINO & RN50 & 23 & 1237 & 3200 & 67.5 & 75.3 \\
BYOL & RN200w2 & 250 & 123 & 2000 & 73.9 & 79.6 \\
SCLRv2 & RN152w3 & 794 & 46 & 2000 & 73.1 & 79.8 \\
\midrule
\multicolumn{7}{l}{\textit{SSL Transformers}} \\
MoCov3 & ViT-S/16 & 21 & 1007 & 1200 & - & 73.4 \\
MoCov3 & ViT-B/16 & 85 & 312 & 1200 & - & 76.7 \\
SwAV & ViT-S/16 & 21 & 1007 & 2400 & 66.3 & 73.5 \\
DINO & ViT-S/16 & 21 & 1007 & 3200 & 74.5 & 77.0 \\
DINO & ViT-B/16 & 85 & 312 & 1600 & 76.1 & 78.2 \\
EsViT & Swin-T/7 & 28 & 726 & 1200 & 75.7 & 78.1 \\
EsViT & Swin-T/14 & 28 & 593 & 1200 & 77.0 & 78.7 \\
\rowcolor{cyan!50}
\ourmethod & ViT-S/16 & 21 & 1007 & 3200 & 75.2 & 77.9 \\
\rowcolor{cyan!50}
\ourmethod & Swin-T/7 & 28 & 726 & 1200 & 75.3 & 78.6 \\
\rowcolor{cyan!50}
\ourmethod & Swin-T/14 & 28 & 593 & 1200 & 76.2 & 79.3 \\
\rowcolor{cyan!50}
\ourmethod & ViT-B/16 & 85 & 312 & 1600 & 77.1 & 79.5 \\
\rowcolor{cyan!50}
\ourmethod & ViT-L/16 & 307 & 102 & 1200 & \bf 78.0 & 81.0 \\
\rowcolor{cyan!50}
\ourmethod & ViT-L/16 & 307 & 102 & 200 & 72.9 & \bf 82.3 \\
\bottomrule
\end{tabular}}}
\end{minipage}\hspace{0.18cm}
\begin{minipage}[c]{.48\linewidth}
\captionsetup{width=.9\linewidth}
\caption{\textbf{Fine-tuning on ImageNet-1K.}}
\label{tab:transfer}
\vspace{-0.2cm}
\centering
\setlength{\tabcolsep}{3.5mm}{
\scalebox{0.87}{
\begin{tabular}{llcc}
Method & Arch. & Epo.\textsuperscript{\ref{effepo}} & Acc. \\
\toprule
\textcolor{gray!80}{Rand.} & \textcolor{gray!80}{ViT-S/16} & \textcolor{gray!80}{-} & \textcolor{gray!80}{79.9} \\
MoCov3 & ViT-S/16 & 600 & 81.4 \\
DINO & ViT-S/16 & 3200 & 82.0 \\
\rowcolor{cyan!50}
\ourmethod & ViT-S/16 & 3200 & \bf 82.3 \\
\midrule
\textcolor{gray!80}{Rand.} & \textcolor{gray!80}{ViT-B/16} & \textcolor{gray!80}{-} & \textcolor{gray!80}{81.8} \\
MoCov3 & ViT-B/16 & 600 & 83.2 \\
BEiT & ViT-B/16 & 800 & 83.4 \\
DINO & ViT-B/16 & 1600 & 83.6 \\
\rowcolor{cyan!50}
\ourmethod & ViT-B/16 & 1600 & \bf 84.0 \\
\midrule
MoCov3 & ViT-L/16 & 600 & 84.1 \\
\rowcolor{cyan!50}
\ourmethod & ViT-L/16 & 1000 & 84.8 \\
BEiT & ViT-L/16 & 800 & \bf 85.2 \\
\bottomrule
\end{tabular}}}
\vspace{-0.15cm}
\captionsetup{width=.88\linewidth}
\caption{\textbf{Fine-tuning on ImageNet-1K.} Pre-training on ImageNet-22K.}
\label{tab:transfer22k}
\vspace{0.05cm}
\centering
\setlength{\tabcolsep}{3.2mm}{
\scalebox{0.87}{
\begin{tabular}{llcc}
Method & Arch. & Epo.\textsuperscript{\ref{effepo}} & Acc. \\
\toprule
BEiT & ViT-B/16 & 150 & 83.7 \\
\rowcolor{cyan!50}
\ourmethod & ViT-B/16 & 320 & \bf 84.4 \\
\midrule
BEiT & ViT-L/16 & 150 & 86.0 \\
\rowcolor{cyan!50}
\ourmethod & ViT-L/16 & 200 & 86.6 \\
\rowcolor{cyan!50}
\ourmethod & ViT-L/16 & 200 & \bf 87.8 \\
\bottomrule
\end{tabular}}}
\end{minipage}
\vspace{-0.2cm}
\end{table}

\paragraph{-NN and Linear Probing.} 
To evaluate the quality of pre-trained features, we either use a -nearest neighbor (-NN) classifier or a linear classifier on the frozen representation. 
We follow the evaluation protocols in DINO~\citep{dino}. For -NN evaluation, we sweep over different numbers of nearest neighbors. 
For linear evaluation, we sweep over different learning rates. 
In Tab.~\ref{tab:linear}, our method reaches a linear probing accuracy 77.9\% with ViT-S/16, 
a linear probing accuracy 79.5\% with ViT-B/16, and a -NN accuracy 78.0\% and linear probing accuracy 81.0\% with ViT-L/16, achieving state-of-the-art performance.
With Swin-T/\{7,14\}, \ourmethod achieves a linear probing accuracy of 78.6\% and 79.3\% respectively.With ViT-L/16 and ImageNet-22K as pre-training data, \ourmethod further achieves a linear probing accuracy \textbf{82.3\%}, surpassing previous state of the art, 81.3\% with Swin-B/14 by EsViT~\citep{esvit}.
A linear probing accuracy of 79.5\% with ViT-B/16 is comparable to 79.8\% by SimCLRv2 with RN152 () but with  less parameters.
We underline that the performance gain over DINO gets larger (0.9\% w/ ViT-S versus 1.3\% w/ ViT-B) with more parameters, suggesting \ourmethod is more scalable to larger models.

\paragraph{Fine-Tuning.} 
We study the fine-tuning on ImageNet-1K and focus on the comparison with self-supervised methods for Transformers and its supervised baseline (\textit{Rand.})~\citep{deit}. 
As shown in Tab.~\ref{tab:transfer}, \ourmethod achieves an 82.3\%, 84.0\%, and 84.8\% top-1 accuracy with ViT-S/16, ViT-B/16, and ViT-L/16, respectively.
As shown in Tab.~\ref{tab:transfer22k}, \ourmethod pre-trained with ImageNet-22K achieves 84.4\% and 86.6\% top-1 accuracy with ViT-B/16 and ViT-L/16, respectively, outperforming ImageNet-22K pre-trained BEiT by 0.7\% and 0.6\%. 
When fine-tuned on an image size of 512, we achieve \textbf{87.8\%} accuracy.
We note that, with ViT-L/16, \ourmethod is 0.4\% worse than BEiT using 1K data but 0.6\% better using 22K data. This implies that \ourmethod requires more data to train larger model.


\begin{table}[tbp]
\begin{minipage}[c]{.45\linewidth}
\setlength{\tabcolsep}{2.6mm}{
\captionsetup{width=1\linewidth}
\caption{\textbf{Semi-supervised learning on ImageNet-1K.} 
1\% and 10\% denotes label fraction. SD denotes self-distillation.
}
\vspace{-0.28cm}
\label{tab:semisup}
\scalebox{0.92}{
\begin{tabular}{llcc}
Method & Arch. & 1\% & 10\% \\
\toprule
SimCLRv2 & RN50 & 57.9 & 68.1 \\
BYOL & RN50 & 53.2 & 68.8 \\
SwAV & RN50 & 53.9 & 70.2 \\
SimCLRv2+SD & RN50 & 60.0 & 70.5 \\
DINO & ViT-S/16 & 60.3 & 74.3 \\
\rowcolor{cyan!50}
\ourmethod & ViT-S/16 & \bf 61.9 & \bf 75.1 \\
\bottomrule
\end{tabular}}}
\end{minipage}\hspace{0.25cm}
\begin{minipage}[c]{.55\linewidth}
\setlength{\tabcolsep}{1.05mm}{
\captionsetup{width=0.88\linewidth}
\caption{\textbf{Unsupervised learning on ImageNet-1K.}  denotes -means clustering on frozen features. }
\vspace{-0.2cm}
\label{tab:unsup}
\centering
\hspace{0.24cm}
\begin{tabular}{llcccc}
Method & Arch. & ACC & ARI & NMI & FMI \\
\toprule
Self-label & RN50 & 30.5 & 16.2 & 75.4 & - \\
InfoMin & RN50 & 33.2 & 14.7 & 68.8 & - \\
SCAN & RN50 & 39.9 & 27.5 & 72.0 & - \\
DINO & ViT-S/16 & 41.4 & 29.8 & 76.8 & 32.8 \\
\rowcolor{cyan!50}
\ourmethod & ViT-S/16 & \bf 43.4 & \bf 32.8 & \bf 78.6 & \bf 35.6 \\
\bottomrule
\end{tabular}}
\end{minipage}
\vspace{-0.2cm}
\end{table}

\paragraph{Semi-Supervised and Unsupervised Learning.} 
For semi-supervised learning, we focus our comparison with methods 
following the \textit{unsupervised pre-train, supervised fine-tune} paradigm.
As shown in Tab.~\ref{tab:semisup}, \ourmethod advances DINO by 1.6\% and 0.8\% using 1\% and 10\% data, respectively, suggesting a higher label efficiency.
For unsupervised learning, we use standard evaluation metrics, including accuracy (ACC), adjusted random index (ARI), normalized mutual information (NMI), and Fowlkes-Mallows index (FMI). 
We compare our methods to SimCLRv2 \citep{simclrv2}, Self-label \citep{self-label}, InfoMin \citep{infomin}, and SCAN \citep{scan}.
As shown in Tab.~\ref{tab:unsup}, we achieve a \textbf{32.8\%} NMI, outperforming the previous state of the art by 1.8\%, suggesting MIM helps the model learn stronger visual semantics on a global scale.

\subsection{Downstream Tasks}
\label{sec:downstream}



\begin{table}
\caption{\textbf{Object detection (Det.) \& instance segmentation (ISeg.) on COCO and Semantic segmentation (Seg.) on ADE20K.} 
We report the results of ViT-S/16 (left) and ViT-B/16 (right).
Seg. denotes using a linear head for semantic segmentation.
}
\vspace{-0.1cm}
\label{tab:detandseg}
\begin{minipage}[c]{.5\linewidth}
\centering
\setlength{\tabcolsep}{0.95mm}{
\begin{tabular}{llcccc}
\multirow{2}{*}{Method} & \multirow{2}{*}{Arch.} & \multirow{2}{*}{Param.} & Det. & ISeg. & \multicolumn{1}{c}{Seg.} \\
\cmidrule(lr){4-4}\cmidrule(lr){5-5}\cmidrule(lr){6-6}
& & & AP & AP & mIoU \\
\toprule
\textcolor{gray!80}{Sup.} & \textcolor{gray!80}{Swin-T} & \textcolor{gray!80}{29} & \textcolor{gray!80}{48.1} & \textcolor{gray!80}{41.7} & \textcolor{gray!80}{44.5} \\
MoBY & Swin-T & 29 & 48.1 & 41.5 & 44.1 \\
\textcolor{gray!80}{Sup.} & \textcolor{gray!80}{ViT-S/16} & \textcolor{gray!80}{21} & \textcolor{gray!80}{46.2} & \textcolor{gray!80}{40.1} & \textcolor{gray!80}{44.5} \\
\rowcolor{cyan!50}
\ourmethod & ViT-S/16 & 21 & \bf 49.4 & \bf 42.6 & \bf 45.4 \\
\bottomrule
\end{tabular}}
\end{minipage}\begin{minipage}[c]{.5\linewidth}
\centering
\setlength{\tabcolsep}{2.4mm}{
\begin{tabular}{lcccc}
\multirow{2}{*}{Method} & Det. & ISeg. & \multicolumn{1}{c}{Seg.} & \multicolumn{1}{c}{Seg.} \\
\cmidrule(lr){2-2}\cmidrule(lr){3-3}\cmidrule(lr){4-4}\cmidrule(lr){5-5}
& AP & AP & mIoU & mIoU \\
\toprule
\textcolor{gray!80}{Sup.} & \textcolor{gray!80}{49.8} & \textcolor{gray!80}{43.2} & \textcolor{gray!80}{35.4} & \textcolor{gray!80}{46.6} \\
BEiT & 50.1 & 43.5 & 27.4 & 45.8 \\
DINO & 50.1 & 43.4 & 34.5 & 46.8 \\
\rowcolor{cyan!50}
\ourmethod & \bf 51.2 & \bf 44.2 & \bf 38.3 & \bf 50.0 \\
\bottomrule
\end{tabular}}
\end{minipage}
\vspace{-0.4cm}
\end{table}

\paragraph{Object Detection and Instance Segmentation on COCO.} 
Object detection and instance segmentation require simultaneous object location and classification.We consider Cascade Mask R-CNN \citep{cascadercnn,maskrcnn} that produces bounding boxes and instance masks simultaneously on COCO dataset \citep{coco}.  
Several recent works \citep{swin,pvt} proposes Vision Transformers that suit dense downstream tasks. To compare, we include the results of supervised Swin-T \citep{swin} which shares approximate parameter numbers with ViT-S/16 and its self-supervised counterpart MoBY \citep{moby} in Tab.~\ref{tab:detandseg}.
\ourmethod improves ViT-S's AP from 46.2 to 49.4 and AP from 40.1 to 42.6, surpassing both supervised Swin-T and its self-supervised counterpart by a nontrivial margin.
With ViT-B/16, \ourmethod achieves an AP of 51.2 and an AP of 44.2, surpassing previous best results by a large margin.

\paragraph{Semantic Segmentation on ADE20K.} 
Semantic segmentation can be seen as a pixel-level classification problem. We mainly consider two segmentation settings on ADE20K dataset \citep{ade20k}. 
First, similar to linear evaluation protocol in classification, we evaluate on the fixed patch features and only fine-tune a linear layer, which gives us a more explicit comparison of the quality of representations. 
Second, we use the task layer in UPerNet \citep{upernet} and fine-tune the entire network. 
From Tab.~\ref{tab:detandseg}, we can see that \ourmethod advances its supervised baseline with ViT-S/16 with a large margin of 0.9 on mIoU, surpassing Swin-T. With ViT-B/16, \ourmethod advances previous best methods DINO by 3.2 on mIoU with UperNet. We notice a performance drop of BEiT using linear head, indicating BEiT's features lack local semantics. As analyzed later, the property of strong local semantics induces a 2.9 mIoU gain compared to the supervised baseline with a linear head.

\begin{table}[tbp]
\caption{\textbf{Transfer learning by fine-tuning pre-trained models on different datasets.} We report Top-1 accuracy of ViT-S/16 (left) and ViT-B/16 (right). }
\vspace{-0.1cm}
\label{tab:transfer2}
\begin{minipage}[c]{.5\linewidth}
\setlength{\tabcolsep}{0.7mm}{
\centering
\begin{tabular}{lcccccc}
Method & Cif & Cif & iNa & iNa & Flwrs & Cars \\
\toprule
\textcolor{gray!80}{Rand.} & \textcolor{gray!80}{99.0} & \textcolor{gray!80}{89.5}& \textcolor{gray!80}{70.7} & \textcolor{gray!80}{76.6} & \textcolor{gray!80}{98.2} & \textcolor{gray!80}{92.1} \\
BEiT & 98.6 & 87.4 & 68.5 & 76.5 & 96.4 & 92.1 \\
DINO & 99.0 & 90.5 & 72.0 & 78.2 & 98.5 & 93.0 \\
\rowcolor{cyan!50}
\ourmethod & \bf 99.1 & \bf 90.7 & \bf 73.7 & \bf 78.5 & \bf 98.6 & \bf 94.0 \\
\bottomrule
\end{tabular}}
\end{minipage}\hspace{0.1cm}
\begin{minipage}[c]{.5\linewidth}
\setlength{\tabcolsep}{0.7mm}{
\centering
\begin{tabular}{lcccccc}
Method & Cif & Cif & iNa & iNa & Flwrs & Cars \\
\toprule
\textcolor{gray!80}{Rand.} & \textcolor{gray!80}{99.0} & \textcolor{gray!80}{90.8} & \textcolor{gray!80}{73.2} & \textcolor{gray!80}{77.7} & \textcolor{gray!80}{98.4} & \textcolor{gray!80}{92.1} \\
BEiT & 99.0 & 90.1 & 72.3 & 79.2 & 98.0 & 94.2 \\
DINO & 99.1 & 91.7 & 72.6 & 78.6 & 98.8 & 93.0 \\
\rowcolor{cyan!50}
\ourmethod & \bf 99.2 & \bf 92.2 & \bf 74.6 & \bf 79.6 & \bf 98.9 & \bf 94.3 \\
\bottomrule
\end{tabular}}
\end{minipage}
\vspace{-0.2cm}
\end{table}

\paragraph{Transfer Learning.}
We study transfer learning where we pre-train on ImageNet-1K and fine-tune on several smaller datasets.We follow the training recipe and protocol used in~\citep{vit}. 
The results are demonstrated in Tab.~\ref{tab:transfer2}. 
While the results on several datasets (\eg, CIFAR10, CIFAR100, Flowers, and Cars) have almost plateaued, \ourmethod consistently performs favorably against other SSL frameworks, achieving state-of-the-art transfer results. We observe greater performance gain over DINO in larger datasets like iNaturalist18 and iNaturalist19, indicating the results are still far from saturation. We also find that with larger models, we typically get larger performance gain compared with DINO (\eg, 1.7\% with ViT/S-16 versus 2.0\% with ViT-B/16 on iNaturalist18, and 0.3\% with ViT/S-16 versus 1.0\% with ViT-B/16 on iNaturalist19).


\subsection{Properties of ViT trained with MIM}
\label{sec:property}
In the previous sections, we have shown the priority of \ourmethod on various tasks and datasets. 
To reveal the strengths of \ourmethod pre-trained Vision Transformers, we analyze its property from several aspects.


\subsubsection{Discovering the Pattern Layout of Image Patches}
\label{sec:patchlayout}

\begin{figure}[!t]
\centering
\includegraphics[width=1.0\linewidth]{pics/layout.pdf}
\vspace{-0.5cm}
\caption{\textbf{Pattern layout of patch tokens.} 
Two left figures showcase patterns, \textit{headlight of the vehicle} and \textit{ear of the dog}, that share part semantics. 
Two right figures showcase patterns, \textit{stripped} and \textit{curly surface}, that share part textures.}
\vspace{-0.5cm}
\label{fig:layout}
\end{figure}

\paragraph{What Patterns Does MIM Learn?} 
The output from the projection head used for self-distillation depicts for patch token a probabilistic distribution.
To help understand what patterns MIM induces to learn, we visualize several pattern layouts. 
We use -epoch pre-trained ViT-S/16 and visualize the top- patches with the highest confidence on ImageNet-1K validation set. We visualize a  context for each  patch (colored orange). 
We observe the emergence of both high-level semantics and low-level details.
As shown in Fig.~\ref{fig:layout}, several patches are grouped with clear semantic meaning, \eg, \textit{headlight} and \textit{dog's ear}. 
Such behavior stands a distinct contrast with the offline tokenizer used in BEiT \citep{beit}, which encapsulates mostly low-level details as shown in Fig.~\ref{fig:layout_dino_beit}. 
Apart from patch patterns that share high-level semantics, we also observe clusters accounting for low-level textures, indicating the diversity of learned part patterns. 
The comparison with previous work \citep{dino, beit} and the visualization of more pattern layouts are provided in Appendix~\ref{sec:patternlayout}.

\paragraph{How Does MIM Help Image Recognition?} 
To illustrate how the property of better part semantics can help image recognition, we use \textit{part-wise linear classification} to study the relationship between representations of patch tokens and \texttt{[CLS]} token. Specifically, we average  patch tokens with the top- highest self-attention scores. 
The results are demonstrated in Fig.~\ref{fig:partlinear}. 
While the performance gap between DINO and \ourmethod is only 0.9\% in the standard setting (77.9\% v.s. 77.0\%) with  token, we observe that \ourmethod outperforms DINO when using the patch representations directly.
We observe that using top- patch tokens yields an optimal result, and \ourmethod is 5.9\% higher than DINO. 
The performance gap becomes more prominent when using fewer patch tokens. When using only the patch token with the highest self-attention score, \ourmethod advances by 17.9\%. 
These results reveal much semantic information in \ourmethod representations for patch tokens, which helps the model to be more robust to the loss of local details and further boosts its performance on image-level recognition.

\subsubsection{Discriminative Parts in Self-Attention Map}
\label{sec:attentionmap}

\begin{figure}[!t]
\begin{minipage}[c]{.5\linewidth}
\centering
\includegraphics[height=0.75\linewidth]{pics/linear_part.pdf}
\vspace{-0.8cm}
\captionsetup{width=.9\linewidth}
\caption{\textbf{Part-wise linear probing accuracy.} Top- tokens with the highest attention scores are averaged for classification. }
\label{fig:partlinear}
\end{minipage}\begin{minipage}[c]{.5\linewidth}
\centering
\includegraphics[height=0.6\linewidth]{pics/attnmap.pdf}
\captionsetup{width=.95\linewidth}
\caption{\textbf{Visualization for self-attention map.} Self-attention map from multiple heads are visualized with different color.}
\label{fig:attn}
\end{minipage}
\vspace{-0.3cm}
\end{figure}

To analyze, we visualize the self-attention map with ViT-S/16. 
We choose \texttt{[CLS]} token as the query and visualize attention maps from different heads of the last layer with different colors, as shown in Fig.~\ref{fig:attn}. 
Of particular interest, we indicate that \ourmethod shows a solid ability to separate different objects or different parts of one object apart. For example, in the leftmost figure, we observe \ourmethod fairly distinct the bird from the tree branch. 
Also, \ourmethod focuses mainly on the discriminative parts of the object (\eg, \textit{the wheel of the car}, \textit{the beak of the bird}).
These properties are crucial for \ourmethod to excel at image recognition, especially in complicated scenarios with object occlusion or distracting instances.
While these properties are not unique strengths brought by MIM and we observe similar behaviors in DINO, we show in Appendix~\ref{sec:attentionmap2} that \ourmethod generally gives better visualized results.

\subsubsection{Robustness}
\label{sec:robustness}

\begin{table}
\caption{\textbf{Robustness evaluation of pre-trained models against background change, occlusion, and out-of-distribution examples.}}
\vspace{-0.2cm}
\label{tab:robustness}
\centering
\setlength{\tabcolsep}{1.2mm}{
\begin{tabular}{lcccccccc|ccccc}
\multirow{2}{*}{Method} & \multicolumn{7}{c}{Background Change} & Clean & \multicolumn{2}{c}{Occlusion} & \multicolumn{2}{c}{Out-of-Dist.} & Clean \\
\cmidrule(lr){2-8}\cmidrule(lr){9-9}\cmidrule(lr){10-11}\cmidrule(lr){12-13}\cmidrule(lr){14-14}
& \it O.F. & \it M.S. & \it M.R. & \it M.N. & \it N.F. & \it O.BB. & \it O.BT. & IN-9 &  &  & IN-A & IN-C  & IN \\
\toprule
DINO & 89.2 & 89.2 & 80.4 & 78.3 & 52.0 & 21.9 & \bf 18.4 & 96.4 & 64.7 & 42.0 & 12.3 & 51.7 & 77.0\\
\rowcolor{cyan!50}
\ourmethod & \bf 90.9 & \bf 89.7 & \bf 81.7 &  \bf 80.3 & \bf 53.5 & \bf 22.7 & 17.4 & \bf 96.8 & \bf 65.9 & \bf 43.4 & \bf 13.8 & \bf 48.1 & \bf 77.9 \\
\bottomrule
\end{tabular}}
\vspace{-0.4cm}
\end{table}

The above-mentioned properties brought by MIM objective can improve the model's robustness to uncommon examples.
We quantitatively benchmark robustness in terms of  aspects: background change, occlusion, and out-of-distribution examples, with a ViT-S/16 pre-trained for  epochs and then linearly evaluated for  epochs.
Results are shown in Tab.~\ref{tab:robustness}.
For background change, we study images under  types of change, detailed in Appendix~\ref{sec:addresult}. \ourmethod is more robust against background changes except for \textit{O.BT.}.
For occlusion, we study the linear accuracy with salient and non-salient patch dropping following \citet{intrig} with an information loss ratio of . \ourmethod has a smaller performance drop under both settings.
For out-of-distribution examples, we study natural adversarial examples in ImageNet-A \citep{imageneta} and image corruptions in ImageNet-C \citep{imagenetc}. \ourmethod has higher accuracy on the ImageNet-A and a smaller mean corruptions error (mCE) on the ImageNet-C.

\subsection{Ablation Study on Tokenizer}
\label{sec:ablation}

In this section, we ablate the importance of using a semantically meaningful tokenizer using a -epoch pre-trained ViT-S/16 with a prediction ratio  and without multi-crop augmentation. 
Additional ablations are given in Appendix ~\ref{sec:addablation}.
\ourmethod works with self-distillation on \texttt{[CLS]} token with cross-view images () to acquire visual semantics. 
To verify, we conduct experiments to perform MIM without  or with alternative models as visual tokenizer. Specifically, \textbf{\Large } denotes a standalone DINO and \textbf{\footnotesize } denotes a pre-tranined DALL-E encoder~\citep{dalle}.
\begin{wraptable}{r}{7.8cm}
\captionsetup{width=.95\linewidth}
\caption{\textbf{Effect of design choices of semantically meaningful tokenization.}}
\vspace{-0.2cm}
\label{tab:components}
\centering
\setlength{\tabcolsep}{0.76mm}{
\begin{tabular}{lcccccc}
Method &  &  & SH & -NN & Lin. & Fin. \\
\toprule
\ourmethod & \cmark & \cmark & \cmark & 69.1 & 74.2 & 81.5 \\
& \cmark & \cmark & \colorbox{cyan!50}{\xmark} & 69.0 & 73.8 & 81.5 \\
& \cmark & \colorbox{cyan!50}{\xmark} & - & 9.5 & 29.8 & 79.4 \\
& \Large  & \colorbox{cyan!50}{\xmark} & - & 44.3 & 60.0 & 81.7 \\
BEiT & \footnotesize  & \colorbox{cyan!50}{\xmark} & - & 6.9 & 23.5 & 81.4 \\
DINO & \colorbox{cyan!50}{\xmark} & \cmark & - & 67.9 & 72.5 & 80.6 \\
BEiT + DINO & \footnotesize  & \cmark & - & 48.0 & 62.7 & 81.2 \\
\toprule
\multicolumn{7}{l}{{\Large }: standalone DINO (w/o mcrop, -epoch)} \\
\multicolumn{7}{l}{{\footnotesize }: pre-trained DALL-E encoder} \\
\end{tabular}}
\vspace{-0.4cm}
\end{wraptable}
We find that performing MIM without  leads to undesirable results of 9.5\% -NN accuracy and 29.8\% linear accuracy, indicating that visual semantics can hardly be obtained with only MIM.
While semantics emerges with a standalone DINO as a visual tokenizer, it is still far from reaching a decent result (44.3\% versus 69.1\% in -NN accuracy).
Comparing \ourmethod with multi-tasking of DINO and BEiT (DINO+BEiT), we see the strengths of merging the semantics acquired by self-distillation with the visual tokenizer with an 11.5\% advance in linear probing and 0.3\% in fine-tuning.
Moreover, we empirically observe a performance improvement using a Shared projection Head (SH) for \texttt{[CLS]} token and patch tokens, which shares the semantics acquired in \texttt{[CLS]} token to MIM.


\section{Related Work}

\paragraph{Visual Representation Learning.} 
Most self-supervised methods assume an augmentation invariance of images and achieve so by enforcing similarity over distorted views of one image while avoiding model collapse.
Avoiding collapse can be achieved by noise-contrastive estimation with negative samples~\citep{instdist,moco,simclr}, introducing asymmetric network~\citep{byol,simsiam}, or explicitly enforcing the distribution of image distribution over the channel to be uniform as well as one-hot~\citep{swav,self-classifier,dino}. 
In fact, the idea of simultaneously enforcing distribution uniform and one-hot is hidden from earlier studies performing representation learning via clustering \citep{deepcluster,swav,self-labelling}, where the cluster assignment naturally meets these two requirements.
Other methods rely on handcrafted pretext tasks and assume the image representation should instead be aware of image augmentation by solving image jigsaw puzzle \citep{jigsaw,iterjigsaw}, predicting rotation \citep{rotnet} or relative position \citep{pos}. 



\paragraph{Masked Prediction in Images.} 
Predicting masked images parts is a popular self-supervised pretext task drawing on the idea of auto-encoding and has been previously achieved by either recovering raw pixels \citep{inpainting,sit,mst} or mask contrastive learning \citep{cpcv2,maskco}. 
Recently, it is formulated into MIM \citep{beit,vimpac} with a discrete VAE \citep{dvae,dalle} as visual tokenizer. As a counterpart of MLM in NLP, MIM eases masked prediction into a classification problem supervised by labels output from the tokenizer, mitigating the problem of excessive focus on high-frequency details.
Concurrently, masked image prediction has been explored in the field of multi-modality, \ie, vision-language representation learning. These methods operate on local regions instead of global images thus reply on pre-trained detection models, \ie, Faster-RCNN \citep{fasterrcnn} to propose regions of interest. \citep{vlbert,vilbert,uniter} perform masked region classification tasking the category distribution output from the detection model as the ground-truth.

\section{Conclusion}
In this work, we study BERT-like pre-training for Vision Transformers and underline the significance of a semantically meaningful visual tokenizer.
We present a self-supervised framework \ourmethod that performs masked image modeling via self-distillation with an online tokenizer, achieving state-of-the-art results on downstream tasks related to classification, object detection, instance segmentation, and semantic segmentation.
Of particular interest, we identify an emerging part-level semantics for models trained with MIM that helps for not only recognition accuracy but also robustness against common image corruptions.
In the future, we plan to scale up \ourmethod to a larger dataset (\eg, ImageNet-22K) or larger model size (\eg, ViT-L/16 and ViT-H/16) and investigate whether MIM can help Vision Transformers more scalable to unlabelled data in the wild.

\textbf{Acknowledgement} Tao Kong is the corresponding author. We would like to acknowledge Feng Wang, Rufeng Zhang, and Zongwei Zhou for helpful discussions. We thank Mathilde Caron, Julien Mairal, and Hugo Touvronfor for sharing details of DINO. We thank Li Dong and Hangbo Bao for sharing details of BEiT. 








\bibliography{iclr2022_conference}
\bibliographystyle{iclr2022_conference}


\newpage
\appendix

\section{Pseudocode}
\label{sec:code}

\setlength{\textfloatsep}{5pt}
\begin{algorithm}[H]
\label{alg:method}

\SetKwInOut{Input}{\textbf{Input}}
\KwIn{

,  \tcp*{student and teacher network}

 \tcp*{center on \texttt{[CLS]} token and patch tokens}

 \tcp*{temperature on \texttt{[CLS]} token for student and teacher network}

 \tcp*{temperature on patch tokens for student and teacher network}

 \tcp*{momentum rate for network}

 \tcp*{momentum rates for center on \texttt{[CLS]} token and patch tokens}}

\BlankLine\BlankLine

.params = .params

\BlankLine\BlankLine

\For {}
{
,  = augment(), augment() \tcp*{random views}

\BlankLine

,  = blockwise\_mask() \tcp*{random block-wise masking}

,  = blockwise\_mask() \tcp*{random block-wise masking}

\BlankLine\BlankLine

,  = (, return\_all\_tok=true) \tcp*{, }

,  = (, return\_all\_tok=true) \tcp*{, }

\BlankLine\BlankLine

,  = (, return\_all\_tok=true) \tcp*{, } 

,  = (, return\_all\_tok=true) \tcp*{, }

\BlankLine\BlankLine

 =  / 2  / 2

 = .sum(dim=1) / .sum(dim=1) / 2

\hskip2.6em .sum(dim=1) / .sum(dim=1) / 2

.mean()  .mean().backward()

\BlankLine\BlankLine

update() \tcp*{student, teacher and center update}

.params =  .params  .params 

 =  cat([, ]).mean(dim=0)

 =  cat([, ]).mean(dim=(0, 1))
}

\BlankLine\BlankLine

\DontPrintSemicolon
\SetKwFunction{FMain}{}
\SetKwProg{Fn}{def}{:}{}
\Fn{\FMain{, , , , }}{
     = .detach();\tcp*{stop gradient}
     = softmax( / , dim=1)\;
     = softmax( / , dim=1);\tcp*{center + sharpen}
    \KwRet  log()).sum(dim=-1);
}

\caption{\ourmethod PyTorch-like Pseudocode w/o multi-crop augmentation}
\end{algorithm}

\section{Multi-Crop}
\label{sec:multicrop}

The advanced performance of several recent state-of-the-art methods~\citep{dino,swav} relies on multi-crop augmentation, as well as \ourmethod. 
In our early experiments, we find the direct usage of multi-crop augmentation leads to instability issues that degrade accuracy. We reveal that these results can be attributed to the distribution mismatch between masked images and non-masked images and can be resolved by minimal changes in \ourmethod framework. 

\begin{figure}[!t]
\centering
\includegraphics[height=0.4\linewidth]{pics/multicrop.pdf}
\vspace{-0.2cm}
\caption{\textbf{Computation pipelines for \ourmethod with or without multi-crop augmentation.} (a) \ourmethod w/o multi-crop augmentation. (b), (c), and (d) are three pipelines w/ multi-crop augmentation. (b) does not perform MIM for local crops, whereas (c) performs MIM for all crops. (d) only performs MIM for one of the two global crops. \ourmethod uses (b) with random MIM.}
\vspace{-0.2cm}
\label{fig:multicrop}
\end{figure}

\begin{figure}[!t]
\centering
\includegraphics[height=0.36\linewidth]{pics/mcrop_nmi.pdf}
\vspace{-0.3cm}
\begin{table}[H]
\centering
\begin{tabular}{cccccc>{\columncolor{cyan!50}}c}
ViT-S/16, 100 epochs & (a) & (b) & (c) & (d) & (e) & (b) w/ rand. MIM \\
\toprule
-NN & 62.1 & 62.0 & 31.9 & 69.8 & 56.6 & 71.5 \\
\end{tabular}
\end{table}
\vspace{-0.5cm}
\caption{\textbf{Training curves of different multi-crop strategy.} }
\label{fig:mcropnmi}
\end{figure}

\paragraph{Stability of MIM Pre-trained with Multi-Crop.} 
We first showcase several practices where training instability occurs, shown in~Fig.~\ref{fig:multicrop}.
To reveal the instability, we monitor the NMI curves during training for each epoch as shown in Fig.~\ref{fig:mcropnmi}. 
The most intuitive ideas are to compute as (b) or (c). 
In (b), MIM is only performed on global crops. This pipeline is unstable during training, and we observe a dip in the NMI training curve. We hypothesize that it can be caused by the distribution mismatch of masked global crops and non-masked local crops. 
To alleviate this, a straightforward solution is to also perform MIM on local crops with an extra computation cost as (c). However, we do not observe this circumvents training instability. We hypothesize that the regions corresponding to patch tokens of the local crops are small in size, in which there exist few meaningful contents to predict. This hypothesis can be supported by the experiments that when we set the local crop scale in (c) from  to , denoted as (e), the performance drop is mitigated.

\paragraph{Stabilizing the Training with Non-Masked Global Crops.} 
Another solution to alleviate the distribution mismatch between masked global crops and non-masked local crops is to train with non-masked global crops, as shown in (d). 
In other words, we perform \textbf{\textit{random MIM}} when training ViT with multi-crop augmentation.
This computation pipeline is stable and achieves a substantial performance gain. In practice, to include non-masked global crops in training, we use (b) and randomly choose a prediction ratio between [, ] for each image. When the ratio  is chosen, the whole framework excludes MIM and can be seen as DINO. When the ratio  is chosen, MIM is performed for both of the two global crops. We observe the latter practice performs sightly better since it is more flexible in task composition and data in a batch is mutually independent.

\paragraph{Range of Scales in Multi-Crop.} We further study the performance with different local and global scale. Following DINO \citep{dino}, we conduct the experiments by tweaking , where  is the scale deviding the local and global crops. The local crops are sampled from (0.05, ) and the global crops are sampled from (, 1).
\vspace{-0.3cm}
\begin{table}[H]
\begin{minipage}[c]{.5\linewidth}
\centering
\begin{tabular}{ccc>{\columncolor{cyan!50}}c}
ViT-S/16, 300 epochs & 0.25 & 0.4 & 0.32\\
\toprule
-NN & 74 & 74.3 & 74.6 \\
\end{tabular}
\end{minipage}\begin{minipage}[c]{.5\linewidth}
\centering
\begin{tabular}{ccc>{\columncolor{cyan!50}}c}
ViT-B/16, 50 epochs & 0.25 & 0.4 & 0.32 \\
\toprule
-NN & 70 & 70.1 & 70.4 \\
\end{tabular}
\end{minipage}
\end{table}
\vspace{-0.6cm}
We empirically find that  yields optimal performance for both small-size and base-size models. Therefore, we use an  of  by default.


\begin{table}[tbp]

\caption{\textbf{-NN and linear probing accuracy on ImageNet-1K without multi-crop augmentation (left) and with multi-crop augmentation (right) multi-crop augmentation}. We split the table into results without or with multi-crop augmentation.}
\label{tab:mcroplinear}
\begin{minipage}[c]{.5\linewidth}
\centering
\setlength{\tabcolsep}{0.6mm}{
\begin{tabular}{llcccc}
Method & Arch & Param. & Epo. & -NN & Linear \\
\toprule
\multirow{3}{*}{MoCov3} & RN50 & 23 & 800 & - & 74.6 \\
 & ViT-S/16 & 21 & 600 & - & 73.4 \\
 & ViT-B/16 & 85 & 600 & - & 76.7 \\
\cmidrule(lr){2-6}
\multirow{2}{*}{DINO} & ViT-S/16 & 21 & 800 & 70.0 & 73.7 \\
 & ViT-B/16 & 85 & 400 & 68.9 & 72.8 \\
\cmidrule(lr){2-6}
\rowcolor{cyan!50}
 & ViT-S/16 & 21 & 800 & \bf 72.4 & \bf 76.2 \\
\rowcolor{cyan!50}
\multirow{-2}{*}{\ourmethod} & ViT-B/16 & 85 & 400 & \bf 71.2 & \bf 76.0 \\
\bottomrule
\end{tabular}}
\end{minipage}\hspace{0.2cm}
\begin{minipage}[c]{.5\linewidth}
\setlength{\tabcolsep}{0.6mm}{
\begin{tabular}{llcccc}
Method & Arch & Param. & Epo. & -NN & Linear \\
\toprule
\multirow{2}{*}{SwAV} & RN50 & 23 & 800 & 65.7 & 75.3 \\
 & ViT-S/16 & 21 & 800 & 66.3 & 73.5 \\
\cmidrule(lr){2-6}
\multirow{3}{*}{DINO} & RN50 & 23 & 800 & 67.5 & 75.3 \\
& ViT-S/16 & 21 & 800 & 74.5 & 77.0 \\
 & ViT-B/16 & 85 & 400 & 76.1 & 78.2 \\
\cmidrule(lr){2-6}
\rowcolor{cyan!50}
& ViT-S/16 & 21 & 800 & \bf 75.2 & \bf 77.9 \\
\rowcolor{cyan!50}
\multirow{-2}{*}{\ourmethod} & ViT-B/16 & 85 & 400 & \bf 76.8 & \bf 79.4 \\
\bottomrule
\end{tabular}}
\end{minipage}
\end{table}

\paragraph{State-of-the-Art Comparison w/o and w/ Multi-Crop.} Including \ourmethod, several recent state-of-the-art works \citep{dino,swav} rely heavily on multi-crop augmentation during pre-training. Except for several specific self-supervised methods \citep{byol}, multi-crop works well on most of the self-supervised methods and consistently yields performance gain \citep{dino}. While a more fair comparison with our methods without multi-crop augmentation can be conducted, we believe it is a unique strength of \ourmethod to work well with multi-crop. In Tab.~\ref{tab:mcroplinear}, we categorize the state-of-the-art comparison into two parts where one for methods without multi-crop and the other with multi-crop. For the former, we mainly compare our method without multi-crop with MoCov3 \citep{mocov3} and DINO without multi-crop. We observe that our method achieves state-of-the-art performance with ViT-S/16 even without multi-crop and comparable performance with ViT-B/16 compared with MoCov3. For the latter, we mainly compare our method with SwAV \citep{swav} and DINO with multi-crop augmentation. We observe that \ourmethod achieves higher performance with 79.4\% of linear probing accuracy when using ViT-S/16.

\paragraph{Effective Training Epochs.}
Due to extra computation costs brought by multi-crop augmentation, different methods with the same pre-training epochs actually see different total numbers of images. To mitigate, we propose to measure the effective training epochs, defined as actual pre-training epochs multiplied with a scaling factor accounting for extra trained images of different resolutions induced by multi-crop augmentation. DINO and \ourmethod are by default trained with  global crops of size  and  local crops of size . Thus  for DINO and \ourmethod.  for SwAV or DINO with RN50 as the backbone and pre-trained with  global crops and  local crops.  for contrastive methods without multi-crop augmentation (\eg, MoCo, SimCLR, BYOL, \etc) and  for non-contrastive methods (\eg, BEiT, Jigsaw, \etc).

\section{Additional Implementations}
\label{sec:addimplement}

\begin{table}[htb]
\begin{minipage}[c]{.55\linewidth}
\captionsetup{width=.95\linewidth}
\caption{\textbf{Different fine-tuning recipes.} LD denotes layerwise learning rate decay. DS denotes mixed-precision training with DeepSpeed.}
\label{tab:recipe}
\vspace{0.07cm}
\centering
\setcounter{rownumbers}{0}
\begin{tabular}{lcccccc}
& Epo. & LD & DS & BEiT & DINO & \ourmethod \\
\toprule
\multicolumn{7}{l}{\textit{ViT-S/16}} \\
\textcolor{orange}{\rownumber} & 300 & 1.0 & \xmark & 81.5 & 81.1 & 81.2 \\
\textcolor{orange}{\rownumber} & 300 & 0.75 & \cmark & \bf 81.7 & 82.0 & 82.3 \\ 
\textcolor{orange}{\rownumber} & 200 & 0.65 & \xmark & 80.7 & - & - \\ 
\textcolor{orange}{\rownumber} & 200 & 0.75 & \xmark & 81.4 & 81.9 & \bf 82.3 \\ 
\textcolor{orange}{\rownumber} & 200 & 0.75 & \cmark & 81.4 & \bf 82.0 & 82.2 \\ 
\textcolor{orange}{\rownumber} & 200 & 0.85 & \xmark & 81.2 & - & - \\ 
\midrule
\multicolumn{7}{l}{\textit{ViT-B/16}} \\
\textcolor{orange}{\rownumber} & 300 & 1.0 & \xmark &  82.1 & 82.8 & 82.4 \\
\textcolor{orange}{\rownumber} & 200 & 0.65 & \cmark & 82.7 & 83.1 & 83.2 \\
\textcolor{orange}{\rownumber} & 100 & 0.65 & \xmark & \bf 83.4 & 83.5 & \bf 84.0 \\
\textcolor{orange}{\rownumber} & 100 & 0.65 & \cmark & 83.2 & \bf 83.6 & 83.8 \\
\bottomrule
\end{tabular}\end{minipage}\hspace{0.1cm}
\begin{minipage}[r]{.45\linewidth}
\captionsetup{width=.95\linewidth}
\caption{\textbf{Evaluation protocols for semi-supervised learning.} \textit{Proj.} denotes fine-tuning from the middle layer of the projection head. LR denotes logistic regression.}
\label{tab:xxx}
\vspace{-0.07cm}
\centering
\setcounter{rownumbers}{0}
\setlength{\tabcolsep}{1.6mm}{
\scalebox{0.96}{
\begin{tabular}{lllccc}
& \multicolumn{2}{l}{Method} & \textit{Proj.} & 1\% & 10\% \\
\toprule
\multicolumn{6}{l}{\textit{frozen features}} \\
\textcolor{orange}{\rownumber} & DINO & + -NN & - & 61.3 & 69.1 \\
\textcolor{orange}{\rownumber} & \ourmethod & + -NN & - & 62.3 & 70.1 \\
\textcolor{orange}{\rownumber} & DINO & + Lin. & - & 60.5 & 71.0 \\
\textcolor{orange}{\rownumber} & \ourmethod & + Lin. & - & 62.5 & 72.2 \\
\textcolor{orange}{\rownumber} & DINO & + LR & - & 64.5 & 72.2 \\
\textcolor{orange}{\rownumber} & \ourmethod & + LR & - & \bf 65.9 & 73.4 \\
\midrule
\multicolumn{6}{l}{\textit{end-to-end fine-tuning}} \\
\textcolor{orange}{\rownumber} & \multicolumn{2}{l}{DINO} & \xmark & 50.6 & 73.2 \\
\textcolor{orange}{\rownumber} & \multicolumn{2}{l}{\ourmethod} & \xmark & 55.0 & 74.0 \\
\textcolor{orange}{\rownumber} & \multicolumn{2}{l}{DINO} & \cmark & 60.3 & 74.3 \\
\textcolor{orange}{\rownumber} & \multicolumn{2}{l}{\ourmethod} & \cmark & 61.9 & \bf 75.1 \\
\bottomrule
\end{tabular}}}
\end{minipage}
\end{table}

\paragraph{Fine-Tuning Recipes of Classification on ImageNet-1K.} 
By default, we follow the fine-tuning protocol in BEiT~\citep{beit} to use a layer-wise learning rate decay, weight decay and AdamW optimizer and train small-, base-size models with , , and  epochs respectively. We sweep over four learning rates .
Comparatively, traditional fine-tuning recipe is is to fine-tune the network for  epochs with a learning rate , no weight decay, and SGD optimizer \citep{deit} (Row \textcolor{orange}{1} versus \textcolor{orange}{8}).
For a fair comparison, we compare the impact of different fine-tuning recipes with different methods, shown in Tab.~\ref{tab:recipe}. 
We empirically find that fine-tuning protocol used in BEiT consistently yields better fine-tuning results and greatly reduces the training epochs. By default, we use a layerwise decay of  with a training epoch of  for ViT-S/16, a layerwise decay of  with a training epoch of  for ViT-B/16, and a layerwise decay of  with a training epoch of  for ViT-L/16.
We report the higher results between using or not using DS since we find it brings different impacts to different methods.

\paragraph{Evaluation Protocols of Semi-Supervised Learning on ImageNet-1K.} 
We study the impact of different evaluation protocols for semi-supervised learning. 
Under conventional semi-supervised evaluation protocol, pre-trained models are end-to-end fine-tuned with a linear classification head. SimCLRv2 \citet{simclrv2} found that keeping the first layer of the projection head can improve accuracy, especially under the low-shot setting. 
We fine-tune the pre-trained model from the first layer of the projection head and verify this conclusion holds true for Vision Transformers. 
We empirically find that Vision Transformer performs better with a frozen backbone with  of training data (62.5\% in row \textcolor{orange}{4} versus 61.9
\% in row \textcolor{orange}{7}). 
In DINO, a logistic regressor built upon the frozen features is found to perform better compared with the multi-class linear classifier upon the frozen features, especially with  data (65.9\% in row \textcolor{orange}{6} versus 62.5\% in row \textcolor{orange}{4}). 
When using  data, we empirically find that \textit{end-to-end fine-tuning} from the first layer of the projection layer yields the best performance (75.1\% in row \textcolor{orange}{10} versus 73.4\% in row \textcolor{orange}{6}). 


\paragraph{Fine-Tuning Recipes of Object Detection and Instance Segmentation on COCO.} 
For both small- and base-size models, we utilize multi-scale training (resizing image with shorter size between  and  while the longer side no larger than ), a learning rate , a weight decay of , and fine-tune the entire network for  schedule (12 epochs with the learning rate decayed by  at epochs  and ). 
We sweep a layer decay rate of \{, , , \}. Note that a layer decay rate of  denotes no layer is decayed.
To produce hierarchical feature maps, we use the features output from layer , , , and , with  deconvolutions,  deconvolution, identity mapping, and max-pooling appended after, respectively. 
We do not use multi-scale testing.

\paragraph{Fine-Tuning Recipes of Semantic Segmentation on ADE20K.} 
For semantic segmentation, we follow the configurations in BEiT \citep{beit}, fine-tuning k iterations with  images and a layer decay rate of . 
We do not use multi-scale training and testing. 
We sweep the learning rate .
Similar to object detection and instance segmentation, to produce hierarchical feature maps, we add additional deconvolution layers after ViT.
\vspace{-0.3cm}
\begin{table}[H]
\centering
\begin{tabular}{cccc}
DINO, w/o \texttt{[LN]} & DINO, w/ \texttt{[LN]} & \ourmethod, w/o \texttt{[LN]} & \ourmethod, w/ \texttt{[LN]} \\
\toprule
33.7 & \bf 34.5  & 37.8 & \bf 38.3 \\
\end{tabular}
\end{table}
\vspace{-0.7cm}
When using linear (Lin.)  as the task layer, we find that appending the last LayerNorm (\texttt{[LN]}) for \texttt{[CLS]} token to each patch tokens before the decoder consistently yields better performance, while we do not spot the substantial gain when with UperNet as the task layer.
By default, we report the segmentation result with \texttt{[LN]} for both linear head for UperNet head.

\paragraph{Part-Wise Linear Probing.} We use the average of the last-layer self-attention map with \texttt{[CLS]} as the query from multiple heads to rank all the patch tokens. We remove the extra LayerNorm (LN) after the final block following MoCov3 \citep{mocov3}. 


\section{Additional Results}
\label{sec:addresult}

In this section, we provide detailed results for dense downstream tasks, \ie, object detection, instance segmentation, and semantic segmentation. We give the complete figures for occlusion robustness analysis. We also provide extra experiments of nearest neighbor retrieval, robustness analysis against occlusion and shuffle.

\begin{table}[!tbp]
\caption{\textbf{Additional object detection, instance segmentation, and semantic segmentation results with small-size models.} We pre-train \ourmethod with ViT-S/16 for 800 epochs.}
\label{tab:detandsegsmall}
\centering
\setlength{\tabcolsep}{1.8mm}{
\begin{tabular}{llccccccccc}
\multirow{2}{*}{Method} & \multirow{2}{*}{Arch.} & \multirow{2}{*}{Param.} & \multicolumn{6}{c}{Det. \& Inst. Seg. w/ Cascade Mask R-CNN} & \multicolumn{2}{c}{Seg. w/ UperNet} \\
\cmidrule(lr){4-9}\cmidrule(lr){10-11}
& & & AP & AP & AP & AP & AP & AP & mIoU & mAcc \\
\toprule
\textcolor{gray!80}{Sup.} & \textcolor{gray!80}{Swin-T} & \textcolor{gray!80}{29} & \textcolor{gray!80}{48.1} & \textcolor{gray!80}{67.1} & \textcolor{gray!80}{52.5} & \textcolor{gray!80}{41.7} & \textcolor{gray!80}{64.4} & \textcolor{gray!80}{45.0} & \textcolor{gray!80}{44.5} & \textcolor{gray!80}{-} \\
MoBY & Swin-T & 29 & 48.1 & 67.1 & 52.1 & 41.5 & 64.0 & 44.7 & 44.1 & -  \\
\midrule
\textcolor{gray!80}{Sup.} & \textcolor{gray!80}{ViT-S/16} & \textcolor{gray!80}{21} & \textcolor{gray!80}{46.2} & \textcolor{gray!80}{65.9} & \textcolor{gray!80}{49.6} & \textcolor{gray!80}{40.1} & \textcolor{gray!80}{62.9} & \textcolor{gray!80}{42.8} & \textcolor{gray!80}{44.5} & \textcolor{gray!80}{55.5} \\
\rowcolor{cyan!50}
\ourmethod & ViT-S/16 & 21 & \bf 49.4 & \bf 68.7 & \bf 53.3 & \bf 42.6 & \bf 65.6 & \bf 45.8 & \bf 45.4 & \bf 56.2 \\
\bottomrule
\end{tabular}}
\end{table}

\begin{table}[!tbp]
\caption{\textbf{Additional object detection, instance segmentation, and semantic segmentation results with base-size models.} We pre-train \ourmethod with ViT-B/16 for 400 epochs.}
\label{tab:detandsegbase}
\centering
\begin{tabular}{llccccccccc}
\multirow{2}{*}{Method} & \multicolumn{6}{c}{Det. \& Inst. Seg. w/ Cascade Mask R-CNN} & \multicolumn{2}{c}{Seg. w/ Lin.} & \multicolumn{2}{c}{Seg. w/ UperNet} \\
\cmidrule(lr){2-7}\cmidrule(lr){8-9}\cmidrule(lr){10-11}
& AP & AP & AP & AP & AP & AP & mIoU & mAcc & mIoU & mAcc \\
\toprule
\textcolor{gray!80}{Sup.} & \textcolor{gray!80}{49.8} & \textcolor{gray!80}{69.6} &  \textcolor{gray!80}{53.8} & \textcolor{gray!80}{43.2} & \textcolor{gray!80}{66.6} & \textcolor{gray!80}{46.5} & \textcolor{gray!80}{35.4} & \textcolor{gray!80}{44.6} & \textcolor{gray!80}{46.6} & \textcolor{gray!80}{57.0} \\
BEiT & 50.1 & 68.5 & 54.6 & 43.5 & 66.2 & 47.1 & 27.4 & 35.5 & 45.8 & 55.9 \\
DINO & 50.1 & 69.5 & 54.3 & 43.4 & 66.8 & 47.0 & 34.5 & 43.7 & 46.8 & 57.1 \\
\rowcolor{cyan!50}
\ourmethod & \bf 51.2 & \bf 70.8 & \bf 55.5 & \bf 44.2 & \bf 67.8 & \bf 47.7 & \bf 38.3 & \bf 48.0 & \bf 50.0 & \bf 60.3 \\
\bottomrule
\end{tabular}
\end{table}

\paragraph{Object Detection, Instance Segmentation, and Semantic Segmentation.} 
We here provide more detailed results on object detection, instance segmentation, and semantic segmentation with small- and base-size models, shown in Tab.~\ref{tab:detandsegsmall} and Tab.~\ref{tab:detandsegbase} respectively. 
Specifically, we include AP and AP for object detection, AP and AP for instance segmentation, mAcc for semantic segmentation.
For object detection (Det.) and instance segmentation (Inst. Seg.), we consider Cascade Mask R-CNN as the task layer. For semantic segmentation (Seg.), we consider two evaluation settings where a linear head (Lin.) and UPerNet are taken as the task layer. 


\begin{table}[!tbp]
\captionsetup{width=0.98\linewidth}
\caption{\textbf{-NN and linear probing on ImageNet-1K with different pre-training datasets}.}
\label{tab:linear22k}
\vspace{-0.2cm}
\centering
\setlength{\tabcolsep}{3mm}{
\scalebox{0.9}{
\begin{tabular}{lccccc}
 Arch. & Pre-Train Data & Param. & Epoch & -NN & Linear \\
\toprule
ViT-S/16 & ImageNet-1K & 21 & 800 & 75.2 & 77.9 \\
ViT-S/16 & ImageNet-22K & 21 & 160 & 69.3 & 76.5 \\
ViT-B/16 & ImageNet-1K & 85 & 400 & 77.1 & 79.5 \\
ViT-B/16 & ImageNet-22K & 85 & 80 & 71.1 & 79.0 \\
ViT-L/16 & ImageNet-1K & 307 & 300 & \bf 78.0 & 81.0 \\
ViT-L/16 & ImageNet-22K & 307 & 50 & 72.9 & \bf 82.3 \\
\bottomrule
\end{tabular}}}
\end{table}

\paragraph{-NN and Linear Probing with ImageNet-22K.} 
We further report -NN and linear probing accuracy on ImageNet-1K with models pre-trained on ImageNet-22K dataset. We empirically observe that ImageNet-1K pre-training incurs better ImageNet-1K -NN and linear probing performance, which is opposite to the fine-tuning performance observed in Table~\ref{tab:transfer} and Table~\ref{tab:transfer22k}. We hypothesize that the data distribution plays a more crucial rule under evaluation protocols based on frozen features, such that models pre-trained with smaller ImageNet-1K dataset consistently achieve better results.

\begin{table}[!tbp]
\caption{\textbf{Effectiveness of pre-trained features on nearest neighbor retrieval.} We report the results on different downstream tasks whose evaluation is based on nearest neighbor retrieval.}
\label{tab:retrival}
\vspace{-0.2cm}
\centering
\begin{tabular}{lccccccc}
\multirow{3}{*}{Method} & \multicolumn{4}{c}{Image Retrieval} & 
\multicolumn{3}{c}{\multirow{2}{*}{Vid. Obj. Segment.}}\\
& \multicolumn{2}{c}{Ox} & \multicolumn{2}{c}{Par}\\
\cmidrule(lr){2-5}\cmidrule(lr){6-8}
& M & H & M & H &  &  &   \\
\toprule
DINO & \bf 37.2 & \bf 13.9 & \bf 63.1 & \bf 34.4 & 61.8 & 60.2 & \bf 63.4 \\
\rowcolor{cyan!50}
\ourmethod & 36.6 & 13.0 & 61.5 & 34.1 & \bf 61.8 & \bf 60.4 & 63.2 \\
\bottomrule
\end{tabular}
\end{table}

\paragraph{Nearest Neighbor Retrieval.} 
Nearest neighbor retrieval is considered using the frozen pre-trained features following the evaluation protocol as in DINO \citep{dino}. 
DINO has demonstrated the strong potential of pre-trained ViT features to be directly used for retrieval. To validate, DINO designed several downstream tasks, including image retrieval and video object segmentation, where video object segmentation can be seen as a dense retrieval task by finding the nearest neighbor between consecutive frames to propagate masks.
We compare \ourmethod with DINO on these benchmarks with the same evaluation settings. 
As demonstrated in Tab.~\ref{tab:retrival}, \ourmethod has comparable results with DINO. While \ourmethod has higher -NN results on Imagenet-1K, the performance is not better for \ourmethod in image retrieval. We empirically find that the results on image retrieval are sensitive to image resolution, multi-scale features, \etc, and the performance varies using pre-trained models with minimal differences on hyper-parameter setup. For this reason, we do not further push \ourmethod for better results.

\paragraph{Robustness against Background Change.} 
Deep models rely on both foreground objects and backgrounds. Robust models should be tolerant to background changes and able to locate discriminative foreground parts.
We evaluate this property on ImageNet-9 (IN-9) dataset~ \citep{bgchallenge}. IN-9 includes  coarse-grained classes and  variants by mixing up the foreground and background from different images. 
\textit{Only-FG (O.F.)}, \textit{Mixed-Same (M.S.)}, \textit{Mixed-Rand (M.R.)}, and \textit{Mixed-Next (M.N.)} are  variant datasets where the original foreground is present but the background is modified, whereas \textit{No-FG (N.F.)}, \textit{Only-BG-B (O.BB.)}, and \textit{Only-BG-T (O.BT.)} are  variants where the foreground is masked.
As shown in Tab.~\ref{tab:robustness}, we observe a performance gain except for \textit{O.BT.}, indicating \ourmethod's robustness against background changes. We note in \textit{O.BT.} neither foreground nor foreground mask is visible, contradicting the pre-training objective of MIM.

\begin{figure}[!tbp]
\centering
\subfigure{\includegraphics[width=0.32\linewidth,height=0.26\linewidth]{pics/random_patchdrop.pdf}}
\subfigure{\includegraphics[width=0.32\linewidth,height=0.26\linewidth]{pics/salient_patchdrop.pdf}}
\subfigure{\includegraphics[width=0.32\linewidth,height=0.26\linewidth]{pics/nonsalient_patchdrop.pdf}}
\vspace{-0.4cm}
\caption{\textbf{Robustness against occlusion.} Model's robustness against occlusion with different information loss ratios is studied.  patch dropping settings: Random Patch Dropping (left), Salient Patch Dropping (middle), and Non-Salient Patch Dropping (right) are considered. }
\label{fig:robustness}
\end{figure}

\paragraph{Robustness against Occlusion.} 
Masked prediction has a natural strength in cases where parts of the image are masked out since the models are trained to predict their original contents. 
We here provide the detailed results of occlusion with different information loss ratios in Fig.~\ref{fig:robustness} under three dropping settings: random, salient, and non-salient. 
We showcase the results of \ourmethod end-to-end fine-tuned or with a linear head over the pre-trained backbone. We include the results of supervised results with both ViT-S/16 and ResNet-50 for comparison.
ViT shows higher robustness compared to its CNN counterpart, \ie, ResNet-50, given that Transformers' dynamic receptive field makes it less dependent on images' spatial structure. 
We empirically find \ourmethod has stronger robustness against occlusion compared to its supervised baseline, consolidating that MIM help to model the interaction between the sequence of image patches using self-attention such that discarding proportion of elements does not degrade the performance significantly.


\begin{figure}[!tbp]
\centering
\includegraphics[width=0.48\linewidth]{pics/shuffle.pdf}
\vspace{-0.4cm}
\caption{\textbf{Robustness against shuffle.} Model's robustness against shuffle with different grid shuffle sizes is studied. }
\label{fig:robustness2}
\vspace{0.2cm}
\end{figure}

\paragraph{Robustness against Shuffle.}
We study the model's sensitivity to the spatial structure by shuffling on input image patches. 
Specifically, we shuffle the image patches with different grid sizes following~\citep{intrig}. 
We showcase the results of \ourmethod end-to-end fine-tuned or with a linear head over the pre-trained backbone. We include the results of supervised results with both ViT-S/16 and ResNet-50 for comparison.
Note that a shuffle grid size of  means no shuffle, and a shuffle grid size of  means all patch tokens are shuffled.
Fig.~\ref{fig:robustness2} suggests that \ourmethod retain accuracy better than its supervised baseline and ResNet-50.
It also indicates that \ourmethod relies less on positional embedding to preserve the global image context for right classification decisions. 



\section{Additional Ablations}
\label{sec:addablation}

In this section, we study the impact of other parameters that we have conducted experiments on. Without extra illustrations, we use -epoch pre-trained ViT-S/16, a prediction ratio  and \underline{without} multi-crop augmentation for the ablative study. 

\begin{table}[!htbp]
\begin{minipage}[c]{.6\linewidth}
\centering
\captionsetup{width=.8\linewidth}
\includegraphics[height=0.6\linewidth]{pics/headarch.pdf}
\vspace{-0.2cm}
\caption{\textbf{Different head sharing strategy.}}
\label{fig:headarch}
\end{minipage}\begin{minipage}[c]{.4\linewidth}
\caption{\textbf{Hard label versus soft label.} \textit{Cen.} denotes centering.  denotes smaller temperature for teacher output.
}
\label{tab:continuous}
\centering
\setlength{\tabcolsep}{0.8mm}{
\begin{tabular}{lcccc}
Method & \textit{Cen.} &  Post Proc. & -NN & Lin. \\
\toprule
& \xmark & softmax & 49.8 & 63.5 \\
& \xmark & hardmax & 64.8 & 71.9 \\
& \xmark & softmax & 69.4 & 73.9 \\
\midrule
& \cmark & softmax & 67.8 & 72.9 \\
& \cmark & hardmax & 68.1 & 73.3 \\
\rowcolor{cyan!50}
\ourmethod & \cmark & softmax & 69.1 & 74.2 \\
\midrule
DINO & - & - & 67.9 & 72.5 \\
\bottomrule
\end{tabular}}

\end{minipage}
\end{table}

\paragraph{Architecture of Projection Head.} 
As mentioned earlier, a shared head can transfer the semantics acquired in \texttt{[CLS]} token to patch tokens, slightly improving the performance. 
We notice that the head for patch tokens in the student network only see the masked tokens throughout the training, the distribution of which mismatches tokens with natural textures. 
Therefore, we conduct an experiment using a non-shared head for the student network but a shared head for the teacher network denoted as \textit{semi-shared head}. 
Their differences are demonstrated in Fig.~\ref{fig:headarch}, where \textit{S} and \textit{T} denotes student and teacher network respectively. The heads with the same index and color denotes they have shared parameters. 
\vspace{-0.3cm}
\begin{table}[H]
\centering
\setlength{\tabcolsep}{1.7mm}{
\begin{tabular}{lcccc>{\columncolor{cyan!50}}c}
Arch. & vanilla & shared & sm. shared & sm. shared & shared \\
\toprule
-NN . & 68.9 & 68.0 & 68.4 & 68.4 & 69.1 \\
Lin. & 73.9 & 73.7 & 73.7 & 73.8 & 74.2 \\
\end{tabular}}
\end{table}
\vspace{-0.7cm}
 denotes only the first  layers out of the -layer MLP share the parameters. However, we do not observe that semi-shared head is better than shared head. By default, we share the entire projection head for \texttt{[CLS]} token and patch tokens.

\paragraph{Comparing MIM with Dense Self-Distillation.} 
To identify the superiority of MIM to model internal structure using over its alternatives, we conduct experiments performing self-distillation on original patch tokens along with the \texttt{[CLS]} token.
We consider two matching strategies to construct patch token pairs for self-distillation.
\vspace{-0.3cm}
\begin{table}[H]
\centering
\begin{tabular}{lccc>{\columncolor{cyan!50}}c}
Arch. & DINO & DINO + \textit{pos.} & DINO + \textit{feat.} & \ourmethod \\
\toprule
-NN & 67.9 & 67.1 (\textcolor{blue}{0.8}) & 68.5 (\textcolor{red}{0.6}) & 69.1 (\textcolor{red}{1.2}) \\
Lin. & 72.5 & 72.5 (\textcolor{red}{0.0}) & 73.4 (\textcolor{red}{0.9}) & 74.2 (\textcolor{red}{1.7}) \\
\end{tabular}
\end{table}
\vspace{-0.6cm}
Specifically, 
\textit{pos.} denotes matching according to the absolute position of two views. Similar to \citet{pixpro}.  is defined as , where  is the position in the original image space and  is euclidean distance. The losses are only computed for the overlapped regions of two views. We do not observe substantial gain brought by matching via patches' absolute position.
\textit{feat.} denotes matching according to the similarity of the backbone similarity of two views. Similar to \citet{densecl}, we match for each patch token  the most similar patch token from another view , where .  is cosine distance. 
Such practice brings a  performance gain in terms of linear probing accuracy, which is also observed by a concurrent work, EsViT \citep{esvit}.
Comparatively, \ourmethod prompts an  gain on linear probing, verifying the necessity and advancement of MIM. 

\paragraph{Hard Label versus Soft Label}
We study the importance of using a continuous token distribution (softmax) instead of a discretized id (hardmax) when performing MIM. 
Results in Tab.~\ref{tab:continuous} indicate continuous tokenization plays a crucial part. We empirically find the improvement brought by centering, whose roles are less important compared to centering in self-distillation on \texttt{[CLS]} token. Only sharpening can produce a -NN accuracy of 69.4 and a linear probing accuracy of 73.9.

\paragraph{Centering and Sharpening.} Different from the \texttt{[CLS]} token, patch tokens do not have certain semantic cluster and vary more widely from each others. We study the impact of several critical parameters that decide the distillation process and customize them for distillation over the patch tokens.
\vspace{-0.3cm}
\begin{table}[H]
\centering
\setlength{\tabcolsep}{1.6mm}{
\begin{tabular}{lccccc>{\columncolor{cyan!50}}c}
 &  &  &  &  &  & \\
 &  &  &  &  &  &  \\
\toprule
-NN & 68.7 & 68.8 & 68.9 & 68.5 & 68.7 & 69.1 \\
Lin. & 74.0 & 73.8 & 73.8 & 73.5 & 73.9 & 74.2 \\
\end{tabular}}
\end{table}
\vspace{-0.7cm}
Specifically, the smoothing momentum for online centering  and sharpening temperature  are studied. Note we keep the parameters for \texttt{[CLS]} token the same as DINO and only study for parameters for the patch tokens. 

\paragraph{Loss Ratio.} We study the impact of different ratio between  and . We keep the base of  to  and scale  with different ratios.
\vspace{-0.3cm}
\begin{table}[H]
\centering
\setlength{\tabcolsep}{1.2mm}{
\begin{tabular}{lcc>{\columncolor{cyan!50}}c}
 /  &  &  &  \\
\toprule
-NN & 68.7 & 69.4 & 69.1 \\
Lin. & 73.8 & 74.1 & 74.2 \\
\end{tabular}}
\end{table}
\vspace{-0.7cm}
We observe that directly adding two losses up without scaling yields the best performance in terms of linear probing accuracy. 

\paragraph{Output Dimension.} 
We follow the structure of projection head in DINO with l2-normalized bottleneck and without batch normalization. We study the impact of output dimension  of the last layer. 
\vspace{-0.3cm}
\begin{table}[H]
\centering
\setlength{\tabcolsep}{2.4mm}{
\begin{tabular}{lcc>{\columncolor{cyan!50}}c}
 &  &  &  \\
\toprule
-NN  & 68.3 & 68.8 & 69.1 \\
Lin. & 74.5 & 74.0 & 74.2 \\
\end{tabular}}
\end{table}
\vspace{-0.7cm}
While our method excludes large output dimensionality since each patch token has an output distribution, we do not observe substantial performance gain brought by larger output dimensions. Therefore, we choose  by default.

\begin{figure}[!tbp]
\begin{minipage}[c]{.5\linewidth}
\centering
\includegraphics[height=0.7\linewidth]{pics/pred_ratio.pdf}
\vspace{-0.2cm}
\captionsetup{width=.9\linewidth}
\caption{\textbf{Impact of the prediction ratio.}  denotes to randomly sample from a region.}
\vspace{-0.2cm}
\label{fig:predratio}
\end{minipage}\begin{minipage}[c]{.5\linewidth}
\centering
\includegraphics[height=0.7\linewidth]{pics/training_epochs.pdf}
\vspace{-0.2cm}
\captionsetup{width=.9\linewidth}
\caption{\textbf{Impact of the training epochs.} Models are ViT-S/16 with multi-crop augmentation.}
\vspace{-0.1cm}
\label{fig:trainepochs}
\end{minipage}
\vspace{-0.2cm}
\end{figure}

\paragraph{Prediction Ratios.}
Masked modeling is based on a formulation of partial prediction, the objective of which is to maximize the log-likelihood of the target tokens conditioned on the non-target tokens. We experiment with different prediction ratios for masked image modeling. The results are shown in Fig.~\ref{fig:predratio}. We observe that the performance is not sensitive to variant prediction ratios between  and . Adding a variance upon the fixed value can also consistently bring a performance gain, which can be explained as stronger data augmentation. The teacher output of non-masked images is now pulled together with the student output of masked images with different ratios. By default, we use  as the prediction ratio. For models with multi-crop augmentation, following the above discussions, we randomly choose a prediction of  or  for each image.

\paragraph{Training Epochs.} 
We provide the linear probing top-1 accuracy with ViT-S/16 pre-trained for different epochs. For comparison, we also include the accuracy curve of other methods with comparable numbers of parameters, \ie, ResNet-50. From Fig.~\ref{fig:trainepochs}, we observe that longer training for  epochs can improve the model's performance. It's north worthy that \ourmethod can achieve a Top-1 accuracy of SwAV \citep{swav} pre-trained with  epochs in less than  epochs. \ourmethod pre-trained with  epochs brings a 0.9\% improvement over previous state-of-the-art method.

\begin{table}[!tbp]
\caption{\textbf{Time and Memory Requirements.} We detail the actual training time (T) and GPU memory (Mem.) of different methods, together with their respective linear probing (Lin.) and fine-tuning (Fin.) accuracy. All methods are trained on two 8-GPU V100 machines with a batch size of 1024. }
\label{tab:requirements}
\begin{center}
\vspace{-0.3cm}
\setlength{\tabcolsep}{1.6mm}{
\begin{tabular}{llccccccc}
Method & Crops Number & T & T & T & Mem. & Lin. & Lin. & Fin. \\
\toprule
BEiT &  & 11.3h & 33.7h & 90.1h  & 5.6G & 20.7 & 24.2 & 81.4 \\
DINO &  & 15.1h & 44.7h & 111.6h & 9.3G & 72.5 & 73.7 & 81.6 \\
\rowcolor{cyan!50}
\ourmethod &  & 15.6h & 47.0h & 126.4h & 13.1G & 74.8 & 76.2 & 82.0 \\
DINO &  & 24.2h  & 72.6h & 180.0h & 15.4G & 76.2 & 77.0 & 82.0 \\
\rowcolor{cyan!50}
\ourmethod &  & 24.3h  & 73.3h & 193.4h & 19.5G & 77.4 & 77.9 & 82.3 \\
\bottomrule
\end{tabular}}
\end{center}
\vspace{-0.3cm}
\end{table}

\paragraph{Time and Memory Requirements.} BEiT is trained with a non-contrastive objective and without multi-crop augmentation, thus it consumes only a memory of 5.6G and takes 90.1h for  epochs. Comparing \ourmethod and DINO with multi-crop augmentation, \ourmethod with MIM induces  more memory requirements and  more actual training time. 
Considering pre-training efficiency (accuracy versus time), 800-epochs pre-trained DINO requiring for 180.0h, while 300-epochs \ourmethod only requires 73.3h with 0.4\% higher linear probing accuracy (77.0 versus 77.4). 


\section{Alternative Tokenizers}
\label{sec:altertokenizer}

\begin{table}[!tbp]
\caption{\textbf{Methodology comparison over different approaches to tokenize the patches.} We report ImageNet-1K -NN, linear and fine-tuning validation accuracy. Models are pre-trained with ViT-S/16 and 300 epochs.}
\label{tab:tokenizer-comparison}
\begin{center}
\vspace{-0.3cm}
\setlength{\tabcolsep}{1.0mm}{
\begin{tabular}{lccc}
Method & -NN & Linear & Fine-Tune \\
\toprule
\textcolor{gray!80}{Rand.} & \textcolor{gray!80}{-} & \textcolor{gray!80}{-} & \textcolor{gray!80}{79.9}\\
MPP \citep{vit} & 16.4 & 37.2 & 80.8 \\
Patch Clustering & 19.2 & 40.1 & 81.3 \\
BEiT \citep{beit} & 6.9 & 24.2 & 81.4 \\
Standalone DINO as tokenizer & 44.3 & 60.0 & 81.7 \\
\rowcolor{cyan!50}
\ourmethod & 70.3 & 74.8 & 81.5 \\
\bottomrule
\end{tabular}}
\end{center}
\end{table}

To investigate how different approaches to tokenize the patches affect MIM, we study several alternatives. In BEiT \citep{beit}, masked patches are tokenized by a DALL-E encoder. MPP \citep{vit} tokenizes the masked patches using their 3-bit mean color. For Patch Clustering, we first perform -Means algorithm to the flattened color vector of each  patch ().  data of ImageNet-1K training set is sampled and clustered. We set  to . During pre-training, each patch is tokenized by the index of its closest centroids. 
Lastly, we use -epoch pre-trained DINO as a standalone tokenizer. Each patch can be tokenized by the argmax of its output from the pre-trained DINO. We use average pooling to aggregate the patch representations. 
From Tab.~\ref{tab:tokenizer-comparison}, we see that all methods achieve decent fine-tuning results compared to the supervised baseline, while only methods tokenized by semantically meaningful tokenizer have proper results on -NN and linear classification.
MPP~\citep{vit} and patch clustering rely purely on offline statistics without the extra stage of online training. We find patch clustering has slightly better performance in all three protocols compared to MPP, suggesting the benefits brought by visual semantics. While BEiT has poor -NN and linear probing accuracy, a good fine-tuning result also suggests relatively low requirements for fine-tuning protocol on high-level semantics.

         
\section{Visualization}
\label{sec:visualiz}

In this section, we first give more visualized pattern layouts and self-attention maps. Beyond that, we consider an additional task of mining sparse correspondences between two images and illustrating the superiority of ViTs by showcasing several visualized results.

\subsection{Pattern Layout}
\label{sec:patternlayout}

\paragraph{Pattern Layout for Patch Tokens.} To illustrate versatile, interesting behaviors \ourmethod has learned, we organize the visualization of pattern layout in two figures. 
In Fig.~\ref{fig:layout2}, we mainly showcase additional pattern layouts that share high-level semantics. 
In Fig.~\ref{fig:layout3}, we mainly showcase additional pattern layouts that share low-level details like color, texture, shape, \etc. Top  patches with the highest confidence over the validation set are visualized with a  context around each  patch token (colored orange).

\paragraph{Composing Images with Representative Patterns.} 
In Fig.~\ref{fig:dpm}, we visualize  patches with the highest self-attention score (with non-overlapped assigned index) and also show the pattern layout of that assigned index. 
The visualized results indicate \ourmethod can only be represented by several representative patches, which helps the model's robustness and performance in recognition. This is also validated by our part-wise linear probing experiments.


\paragraph{Comparison with Other Methods.} We visualize pattern layout for patch tokens using other self-supervised methods \citep{beit,dino} in Fig.~\ref{fig:layout_dino_beit}. For BEiT, the DALL-E encoder generates a discrete number for each patch token. For DINO, we directly use the projection head for \texttt{[CLS]} token and generate a -d probability distribution for each patch token. The index with the highest probability is assigned for the token.


\paragraph{Pattern Layout for \texttt{[CLS]} Token.} We here also provide additional visualization of semantic patterns emerge in \texttt{[CLS]} token, which is obtained via self-distillation on cross-view images. We also observe similar behavior in DINO since it's not a unique property brought by MIM. In fact, semantics are now believed to emerge as long as a similarity between two distorted views of one image is enforced \citep{byol,moco,swav,deepcluster}.

\subsection{Self-Attention Visualizations}
\label{sec:attentionmap2}

Similar to the setting of Sec.~\ref{sec:attentionmap}, we here provided more self-attention map visualization from multiple heads of the last layer in Fig.~\ref{fig:attnmap2}. 



\subsection{Sparse Correspondence.} 
We consider a sparse correspondence task where the overlapped patches from two augmented views of one image, or patches from two images labeled as one class, are required to be matched. 
The correlation is sparse since at most  matched pairs can be extracted with a ViT-S/16 model. 
We visualize  correspondences with the highest self-attention score extracted from \ourmethod with ViT-S/16 pre-trained for  epochs. The score is averaged between multiple heads of the last layer. 
Several sampled sets of image pairs are shown in Fig.~\ref{fig:corresp}. 
We observe empirically that \ourmethod perform well for two views drawn from one image, nearly matched the majority of correspondence correctly. 
In the second column, \ourmethod can match different parts of two instances from the same class (\eg, tiles and windows of two cars) despite their huge differences in texture or color. 
We observe the DINO also has comparable visualized effects, illustrating the representation pre-trained with self-distillation also suits well for retrieval in a patch-level scale.


\newpage

\begin{figure}[!t]
\centering
\includegraphics[width=1\linewidth]{pics/layout2.pdf}
\vspace{-0.6cm}
\caption{\textbf{Visualization for pattern layout of patch tokens that share high-level semantics.} In the first row, we visualize different human-related semantic parts. We observe clear patterns accounting for \textit{human hair}, \textit{human shoulder \& arm}, and \textit{human elbow} respectively in the left, middle, and right figure. In the figures from the second row and the left figure from the the third row, we visualize animal-related semantic parts. \textit{dog's ear}, \textit{dog's nose}, \textit{bird's wing}, and \textit{dragonfly's wing} can be observed. In the rest of figures from the third row, we visualize semantic parts related to outdoor scenes. \textit{front window of the vehicle} and \textit{window of the architecture} can be observed. In the last row, we visualize indoor objects like \textit{ceiling} and \textit{glass bottle}. 
}
\vspace{-0.2cm}
\label{fig:layout2}
\end{figure}

\begin{figure}[!t]
\centering
\includegraphics[width=1\linewidth]{pics/layout3.pdf}
\vspace{-0.2cm}
\caption{\textbf{Visualization for pattern layout of patch tokens that share low-level details.} In the first two columns, we visualize patches that share similar textures. 
In the first figure, \textit{fur of leopard and the skin of lizard} share a similar dotted texture. 
In the second figure, \textit{shell of hedgehog and the skin of elephant} share similar striped texture. 
In the third column, we visualize pattern layouts related to shape. For example, the shape of objects in the left and middle figures share similar curvature. The rightmost patterns clearly depict the shape of a straight line. 
We visualize pattern layout related to color in the last column, where \textit{blue}, \textit{green} and \textit{white} can be observed.}
\vspace{-0.2cm}
\label{fig:layout3}
\end{figure}

\begin{figure}[!t]
\centering
\includegraphics[width=1\linewidth]{pics/dpm.pdf}
\vspace{-0.2cm}
\caption{\textbf{Top- representative patches with each of their pattern layout.} Order index \textcolor{red}{0, 1, 2, 3} are ranked according to its self-attention score. In the top-left corner for each pattern layout subfigure, its order index and cluster index are annotated. In the top panel, we can observe that pattern \textcolor{red}{0,2,3} show explicit semantic information of \textit{nose, eyes, ears} respectively. Interestingly, patch \textcolor{red}{1} also locates around the eyes of the \textit{Samoyed} but its corresponding pattern share visual similarity in shape instead of semantics. This illustrate the diverse behaviour for each learned pattern. In the bottom panel, a \textit{library} is represented by \textcolor{red}{0} \textit{two- or multi-color joints}, \textcolor{red}{1,3} \textit{knurlling texture}, \textcolor{red}{2} \textit{texts}. Similarly, we have patterns \textcolor{red}{0,1,3} focusing more on texture \& color and pattern \textcolor{red}{2} focusing more on semantics. All of these visualized results illustrate versatile behaviour for each index.}
\vspace{-0.2cm}
\label{fig:dpm}
\end{figure}

\begin{figure}[!t]
\centering
\includegraphics[width=1.0\linewidth]{pics/layout_dino_beit.pdf}
\vspace{-0.6cm}
\caption{\textbf{Visualization for pattern layout of patch tokens using BEiT  (top) and DINO (bottom).} 
In the layout extracted from the DALL-E encoder, we observe minimal semantic patterns. In most cases, patches with similar color (\eg, \textit{black area} in left figure) or texture (\eg, \textit{line} in right figure) are clustered. 
In the layout extracted from DINO, while more complex textures are visible, most patches share similar local details instead of high-level semantics. In the right figure, the semantic part \textit{eyes} can be somehow observed, yet it is mixed with plenty of irrelevant semantic parts.}
\vspace{-0.4cm}
\label{fig:layout_dino_beit}
\end{figure}

\begin{figure}[!t]
\centering
\includegraphics[width=1.0\linewidth]{pics/layout_cls.pdf}
\vspace{-0.6cm}
\caption{\textbf{Visualization for pattern layout of \texttt{[CLS]} token.} We here indicate the high quality of semantic layout brought by self-distillation of cross-view images on \texttt{[CLS]} token. This property is not brought by MIM and is also prominent in DINO.}
\vspace{-0.2cm}
\label{fig:layout_cls}
\end{figure}

\begin{figure}[!t]
\centering
\includegraphics[width=1.0\linewidth]{pics/attnmap2.pdf}
\vspace{-0.2cm}
\caption{\textbf{Visualization for self-attention map from Multiple Heads.} 
In the first  columns, we showcase \ourmethod's attention map along with DINO's. In the last  columns, we showcase more attention map from \ourmethod.
We indicate that \ourmethod shows visually stronger ability to separate different objects or different parts of one object apart by giving more attentive visualized results for each part, compared with DINO. 
For example, in the fifth column, there is an attention head in \ourmethod accounting for the \textit{ear of the fox} solely, while in DINO, it emerges with other parts; In the eighth column, \ourmethod separates the \textit{mushroom} into more semantically meaningful parts.
}
\vspace{-0.2cm}
\label{fig:attnmap2}
\end{figure}



\begin{figure}[!t]
\centering
\includegraphics[width=1.0\linewidth]{pics/corresp.pdf}
\vspace{-0.2cm}
\caption{\textbf{Visualization for sparse correspondence.} 
The top panel are images pairs sampled from two views of one image. The extracted correspondence from \ourmethod is mostly correct despite augmentations on scale and color.
The bottom panel are image pairs sampled from two images of one class. The first row is images with salient objects but different sizes, positions and textures. The second row are images draw from animals, and we can observe more clearly that \ourmethod matches the semantic parts of animals correctly (\eg, \textit{tails of the fox}, \textit{beak of the bird}). The third row is human-centered images with human bodies or clothing. The fourth row is natural or domestic scenes where salient objects are invisible. Although no explicit semantic parts can be matched visible to human's understanding, we can still observe the \ourmethod can extract correspondence based on their texture or color (\eg, \textit{wooden texture of signboard and boxes}. All these visual results demonstrate strong capability for \ourmethod in part retrieval or matching in a local scale.}
\vspace{-0.2cm}
\label{fig:corresp}
\end{figure}

\end{document}
