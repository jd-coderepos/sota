
\documentclass[10pt]{article}
\usepackage{amssymb, amsthm}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newtheorem{remark}{Remark}
\newtheorem{example}{Example}


\usepackage{amsmath}

\usepackage{graphicx}

\usepackage{latexsym}

\title{State Complexity of Two Combined Operations: Reversal-Catenation and Star-Catenation}
\author{Bo Cui, Yuan Gao, Lila Kari, and Sheng Yu}

\begin{document}
\maketitle

\begin{abstract}
In this paper, we show that, due to the structural properties of the resulting automaton obtained from a prior operation, the state complexity of a combined operation may not be equal but close to the mathematical composition of the state complexities of its component operations.
In particular, we provide two witness combined operations: reversal combined with catenation and star combined with catenation.
\end{abstract}

\section{Introduction}
State complexity is a type of descriptional complexity based on {\it
deterministic finite automaton} (DFA) model. The state complexity of
an operation on regular languages is the number of states that are
necessary and sufficient in the worst case for the minimal, complete
DFA that accepts the resulting language of the operation. While many
results on the state complexities of individual operations, such as
union, intersection, catenation, star, reversal, shuffle, orthogonal
catenation, proportional removal, and cyclic
shift~\cite{CaSaYu02,DaDoSa08,Domaratzki02,HoKu02,JiJiSz05,JiOk05,Jriaskova05,SaWoYu04,YuZhSa94,Yu01},
have been obtained in the past 15 years, the research of state
complexities of combined operations, which was initiated by A.
Salomaa, K. Salomaa, and S. Yu in 2007~\cite{SaSaYu07}, is
attracting more attention. This is because, in practice, a
combination of several individual operations, rather than only one
individual operation, is often performed in a certain order. For
example, in order to obtain a precise regular expression, a
combination of basic operations is usually required.

In recent
publications~\cite{CGKY10-cat-sr,CGKY10-cat-ui,EGLY2009,GaSaYu08,GaYu09,GaYu10,JiOk07,LiMaSaYu08,SaSaYu07},
it has been shown that the state complexity of a combined operation
is not always a simple mathematical composition of the state
complexities of its component operations.
This is sometimes due to the structural properties of the DFA accepting the resulting language obtained from a prior operation of a combined operation.
For example, the languages that are obtained from performing reversal and reach the upper bound of the state complexity of this operation are accepted by DFAs such that half of their states are final; and the initial state of the DFA accepting a language obtained after performing star is always a final state.
As a result, the resulting language obtained from a prior operation may not be among the worst cases of the subsequent operation.
Since such issues are not concerned by the study of the state complexity of individual operations, they are certainly important in the research of the state complexity of combined operations.
Although the number of combined operations is unlimited and it is impossible to study the state complexities of all of them, the study on combinations of two individual operations is clearly necessary.

In this paper, we study the state complexities of reversal combined with catenation, i.e., , and star combined with catenation, i.e., , for minimal complete DFAs  and  of sizes , respectively.
For , we will show that the general upper bound , which is close to the composition of the state complexities of reversal and catenation , is reachable when , and it can be lower to  and  when  and  and when  and , respectively.
For , we will show that, if  has only one final state and it is also the initial state, i.e., , the state complexity of catenation (also ) is , which is lower than that of catenation .
In the other cases, that is when  contains some final states that are not the initial state, the state complexity of  is  instead of , the composition of the state complexities of star and catenation.

In the next section, we introduce the basic definitions and notations used in the paper.
Then, we prove our results on reversal combined with catenation and star combined with catenation in Sections~\ref{sec:rev-cat} and~\ref{sec:star-cat}, respectively.
We conclude the paper in Section~\ref{sec:conclusion}.

\section{Preliminaries}
A DFA is denoted by a 5-tuple , where  is the finite set of states,  is the finite input alphabet,  is the state transition function,  is the initial state, and  is the set of final states.
A DFA is said to be complete if  is defined for all  and .
All the DFAs we mention in this paper are assumed to be complete.
We extend  to  in the usual way.

A {\it non-deterministic finite automaton} (NFA) is denoted by a 5-tuple , where the definitions of , , , and  are the same to those of DFAs, but the state transition function  is defined as , where  denotes the power set of , i.e. the set of all subsets of .

In this paper, the state transition function  is often extended to . The function  is defined by , for  and .
We just write  instead of  if there is no confusion.

A word  is accepted by a finite automaton if .
Two states in a finite automaton  are said to be {\it equivalent} if and only if for every word , if  is started in either state with  as input, it either accepts in both cases or rejects in both cases.
It is well-known that a language which is accepted by
an NFA can be accepted by a DFA, and such a language is said to be {\it regular}.
The language accepted by a DFA  is denoted by .
The reader may refer to~\cite{HoMoUl01,Yu97} for more
details about regular languages and finite automata.

The {\it state complexity} of a regular language , denoted by
, is the number of states of the minimal complete DFA that
accepts . The state complexity of a class  of regular
languages, denoted by , is the supremum among all , . The state complexity of an operation on regular languages is
the state complexity of the resulting languages from the operation as a function of the state complexity of the operand languages.
Thus, in a certain sense, the state complexity of an operation is a worst-case complexity.

\section{Reversal combined with catenation}\label{sec:rev-cat}
In this section, we study the state complexity of  for an
-state DFA language  and an -state DFA language . We
first show that the state complexity of  is upper bounded
by  in general (Theorem~\ref{L_1^R L_2 upper
bound}). Then we prove that this upper bound can be reached when
 (Theorem~\ref{L_1^R L_2 lower bound}). Next, we
investigate the case when  and  and prove the state
complexity can be lower to  in such a case
(Theorem~\ref{L_1^R L_2 state complexity m=1 n>=1}). Finally, we
show that the state complexity of  is  when  and  (Theorem~\ref{L_1^R L_2 state complexity m>=2
n=1}).


Now, we start with a general upper bound of state complexity of
 for any integers .
\begin{theorem}
\label{L_1^R L_2 upper bound} For two integers , let
 and  be two regular languages accepted by an -state
DFA and an -state DFA, respectively. Then there exists a DFA of
at most  states that accepts .
\end{theorem}
\begin{proof}
Let  be a DFA of  states,
 final states and . Let  be another DFA of  states and .

Let  be an NFA with
 initial states.  if 
where  and . Clearly,


By performing subset construction on NFA , we can get an
equivalent, -state DFA 
such that . Since  has only one final state ,
we know that . Thus,  has
 final states in total. Now we construct a DFA
 accepting the language , where

From the above construction, we can see that all the states in 
starting with  must end with  such that .
There are in total  states which don't meet
this.

Thus, the number of states of the minimal DFA accepting 
is no more than

\end{proof}

This result gives an upper bound for the state complexity of . Next we show that this bound is reachable when .


\begin{theorem}
\label{L_1^R L_2 lower bound} Given two integers , there
exists a DFA  of  states and a DFA  of  states such that
any DFA accepting  needs at least 
states.
\end{theorem}
\begin{proof}
Let  be a DFA, shown in
Figure~\ref{DFAM-rev-cat}, where ,
, and the transitions are given as:
\begin{itemize}
\item 
\item  
\item  \\
 if , 
\item 
\end{itemize}
\begin{figure}[ht]
  \begin{center}
  \includegraphics[scale=0.17]{DFAM-rev-cat.eps}
  \end{center}
  \caption{Witness DFA  of Theorem~\ref{L_1^R L_2 lower bound} showing that the upper bound in Theorem~\ref{L_1^R L_2 upper bound} is reachable when }
\label{DFAM-rev-cat}
\end{figure}

Let  be a DFA, shown in
Figure~\ref{DFAN-rev-cat}, where ,
, and the transitions are given as:
\begin{itemize}
\item 
\item 
\item 
\item 
\end{itemize}
\begin{figure}[ht]
  \begin{center}
  \includegraphics[scale=0.17]{DFAN-rev-cat.eps}
  \end{center}
  \caption{Witness DFA  of Theorem~\ref{L_1^R L_2 lower bound} showing that the upper bound in Theorem~\ref{L_1^R L_2 upper bound} is reachable when }
\label{DFAN-rev-cat}
\end{figure}
Now we design a DFA ,
where , ,
, and the transitions are
defined as:

It is easy to see that  is a DFA that accepts . We prove
that  is minimal before using it.

(I) We first show that every state , is reachable from
. There are three cases.


\begin{itemize}
\item[{\rm 1.}].
 if and only if . 
\item[{\rm 2.}].
Let , . 
\item[{\rm 3.}].
Let , , . , where

\end{itemize}


(II) Any two different states  and  in  are
distinguishable.

Without loss of generality, we may assume that . Let
. Then a string  can distinguish these two states
because


Due to (I) and (II),  is a minimal DFA with  states which
accepts . Now let 
be another DFA, where

and for each state  and each letter 


As we mentioned in last proof, all the states starting with  must end with  such that . Clearly, 
accepts the language  and it has

states. Now we show that  is a minimal DFA.

(I) Every state  is reachable. We
consider the following five cases:

\begin{itemize}

\item[{\rm 1.}], .
 is the sink state of .
.

\item[{\rm 2.}], .
Let , , . Note that , because  guarantees . , where

Please note that  when .

\item[{\rm 3.}], .
In this case, let , , . , where


\item[{\rm 4.}], , .
Let , ,  and ,
, . We can find
a string  such that , where



\item[{\rm 5.}], , , .
Let , ,
 and , , . Since  is in ,
according to the definition of ,  has to be in  as well.
There exists a string  such that , where



\item[{\rm 6.}], , .
Let , ,
 and , , . In this case, we have

where states 
and  have been proved to be reachable in
Case 5.




\end{itemize}

(II) We then show that any two different states  and  in  are
distinguishable.

\begin{itemize}

\item[{\rm 1.}].
Without loss of generality, we may assume that . Let . A string  can distinguish them because


\item[{\rm 2.}], . Without loss of generality, we assume that . Let . Then there always exists a string  such that


\end{itemize}
Since all the states in  are reachable and pairwise
distinguishable, DFA  is minimal. Thus, any DFA accepting
 needs at least  states.
\end{proof}

This result gives a lower bound for the state complexity of
 when . It coincides with the upper bound shown
in Theorem~\ref{L_1^R L_2 upper bound} exactly. Thus, we obtain the
state complexity of the combined operation  for 
and .
\begin{theorem}
\label{L_1^R L_2 state complexity} For any integers ,
let  be an -state DFA language and  be an -state DFA
language. Then  states are both necessary and
sufficient in the worst case for a DFA to accept .
\end{theorem}



In the rest of this section, we study the remaining cases when
either  or .

We first consider the case when  and . In this case,
 or .  holds no matter
 is  or , since 
and . It has been shown in~\cite{YuZhSa94}
that  states are both sufficient and necessary in the worst
case for a DFA to accept the catenation of a 1-state DFA language
and an -state DFA language, .

When  and , it is also easy to see that  state is
sufficient and necessary in the worst case for a DFA to accept
, because  is either  or .
Thus, we have the following theorem concerning the state complexity
of  for  and .



\begin{theorem}
\label{L_1^R L_2 state complexity m=1 n>=1} Let  be a 1-state
DFA language and  be an -state DFA language, . Then
 states are both sufficient and necessary in the worst case
for a DFA to accept .
\end{theorem}

Now, we study the state complexity of  for  and
. Let us start with the following upper bound.

\begin{theorem}
\label{L_1^R L_2 upper bound m>=2 n=1} For any integer , let
 and  be two regular languages accepted by an -state
DFA and a -state DFA, respectively. Then there exists a DFA of at
most  states that accepts .
\end{theorem}

\begin{proof}
Let  be a DFA of  states,
,  final states and . Let  be another DFA
of  state and . Since  is a complete DFA, as we
mentioned before,  is either  or .
Clearly, . Thus, we need to consider
only the case .

We construct an NFA 
with  initial states which is similar to the proof of
Theorem~\ref{L_1^R L_2 upper bound}.  if
 where  and . It is easy
to see that


By performing subset construction on NFA , we get an equivalent,
-state DFA  such that
.  because 
has only one final state . Thus,  has  final states in total.

Define  where , ,

and for any  and ,

The automaton  is exactly the same as  except that 's
 final states are made to be sink states and these sink,
final states are merged into one, since they are equivalent. When
the computation reaches the final state , it remains there.
Now, it is clear that  has
 states and .
\end{proof}
This theorem shows an upper bound for the state complexity of  for  and . Next we prove that this upper bound
is reachable.

\begin{lemma}
\label{L_1^R L_2 lower bound m=2 or 3 n=1}Given an integer  or
, there exists an -state DFA  and a -state DFA  such
that any DFA accepting  needs at least 
states.
\end{lemma}

\begin{proof}
When  and . We can construct the following witness DFAs.
Let  be a DFA, where
, and the transitions are given as:
\begin{itemize}
\item 
\item 
\end{itemize}
Let  be the DFA accepting . Then the resulting DFA for
 is 
where
\begin{itemize}
\item 
\item 
\end{itemize}

When  and . The witness DFAs are as follows. Let
 be a DFA, where
, and the transitions are:
\begin{itemize}
\item 
\item 
\item 
\end{itemize}
Let  be the DFA accepting . The resulting DFA for
 is  where
\begin{itemize}
\item 
\item 
\item 
\end{itemize}
\end{proof}

The above result shows that the bound  is reachable when
 is equal to 2 or 3 and . The last case is  and .

\begin{theorem}
\label{L_1^R L_2 lower bound m>=4 n=1} Given an integer ,
there exists a DFA  of  states and a DFA  of  state such
that any DFA accepting  needs at least 
states.
\end{theorem}

\begin{proof}
Let  be a DFA,
shown in Figure~\ref{DFAM-rev-cat-n=1},
where , , ,
and the transitions are given as:
\begin{itemize}
\item 
\item 
\item 
\item 
\end{itemize}
\begin{figure}[ht]
  \begin{center}
  \includegraphics[scale=0.17]{DFAM-rev-cat-n=1.eps}
  \end{center}
  \caption{Witness DFA  of Theorem~\ref{L_1^R L_2 lower bound m>=4 n=1} showing that the upper bound in Theorem~\ref{L_1^R L_2 upper bound m>=2 n=1} is reachable when  and }
\label{DFAM-rev-cat-n=1}
\end{figure}
Let  be the DFA accepting . Then
. Now we design a DFA  similar to the proof of Theorem~\ref{L_1^R
L_2 lower bound}, where , , , and the
transitions are defined as:

It is easy to see that  is a DFA that accepts . Since the
transitions of  on letters , , and  are exactly the same
as those of DFA  in the proof of Theorem~\ref{L_1^R L_2 lower
bound}, we can say that  is minimal and it has  states,
among which  states are final.


Define  where , ,

and for any  and ,

DFA  is the same as  except that 's  final states
are changed into sink states and merged to one sink, final state, as
we did in the proof of Theorem~\ref{L_1^R L_2 upper bound m>=2 n=1}.
Clearly,  has  states and
. Next we show that  is a minimal DFA.

(I) Every state  is reachable from . The proof is
similar to that of  Theorem~\ref{L_1^R L_2 lower bound}. We consider
the following four cases:

\begin{itemize}
\item[{\rm 1.}].

\item[{\rm 2.}]. 
\item[{\rm 3.}].
Assume that , . Note that 
because all the final states in  have been merged into . In
this case, 
\item[{\rm 4.}].
Assume that , , . , where

\end{itemize}

(II) Any two different states  and  in  are
distinguishable.

Since  is the only final state in , it is inequivalent to
any other state. Thus, we consider the case when neither of  and
 is .

Without loss of generality, we may assume that . Let
.  is always greater than  because all the states
which include  have been merged into . Then a string
 can distinguish these two states because

Since all the states in  are reachable and pairwise
distinguishable,  is a minimal DFA. Thus, any DFA accepting
 needs at least  states.
\end{proof}

After summarizing Theorem~\ref{L_1^R L_2 upper bound m>=2 n=1},
Theorem~\ref{L_1^R L_2 lower bound m>=4 n=1} and Lemma~\ref{L_1^R
L_2 lower bound m=2 or 3 n=1}, we obtain the state complexity of the
combined operation  for  and .

\begin{theorem}
\label{L_1^R L_2 state complexity m>=2 n=1} For any integer , let  be an -state DFA language and  be a -state
DFA language. Then  states are both sufficient and
necessary in the worst case for a DFA to accept .
\end{theorem}

\section{Star combined with catenation}\label{sec:star-cat}
In this section, we investigate the state complexity of  for two DFAs  and  of sizes , respectively.
We first notice that, when , the state complexity of  is 1 for any .
This is because  is complete ( is either  or ), and we have either  or .
Thus,  is always accepted by a 1 state DFA.
Next, we consider the case where  has only one final state and it is also the initial state.
In such a case,  is also accepted by , and hence the state complexity of  is equal to that of .
We will show that, for any  of size  in this form and any  of size , the state complexity of  (also ) is  (Theorems~\ref{thm:star-cat-upper-special} and~\ref{thm:star-cat-lower-special}), which is lower than the state complexity of catenation in the general case.
Lastly, we consider the state complexity of  in the remaining case, that is when  has at least a final state that is not the initial state and .
We will show that its upper bound (Theorem~\ref{thm:star-cat-upper}) coincides with its lower bound (Theorem~\ref{thm:star-cat-lower}), and the state complexity is .

Now, we consider the case where DFA  has only one final state and it is also the initial state, and first obtain the following upper bound of the state complexity of  (), for any DFA  of size .
\begin{theorem}\label{thm:star-cat-upper-special}
For integers  and , let  and  be two DFAs with  and  states, respectively, where  has only one final state and it is also the initial state.
Then, there exists a DFA of at most  states that accepts , which is equal to .
\end{theorem}
\begin{proof}
Let  and .
We construct a DFA  such that

Intuitively,  contains the pairs whose first component is a state of  and second component is a subset of .
Since  is the final state of , without reading any letter, we can enter the initial state of .
Thus, states  such that  can never be reached in , because  is complete.
Moreover,  does not contain those states whose first component is  and second component does not contain .

Clearly,  has  states, and we can verify that .
\end{proof}

Next, we show that this upper bound can be reached by some witness DFAs in the specific form.

\begin{figure}[ht]
  \begin{center}
  \includegraphics[scale=0.17]{DFAA-star-cat-special.eps}
  \end{center}
  \caption{Witness DFA  for Theorem~\ref{thm:star-cat-lower-special} when }
\label{fig:DFAA-star-cat-special}
\end{figure}

\begin{figure}[ht]
  \begin{center}
  \includegraphics[scale=0.17]{DFAB-star-cat-special.eps}
  \end{center}
  \caption{Witness DFA  for Theorem~\ref{thm:star-cat-lower-special} when }
\label{fig:DFAB-star-cat-special}
\end{figure}

\begin{theorem}\label{thm:star-cat-lower-special}
For any integers  and , there exist a DFA  of  states and a DFA  of  states, where  has only one final state and it is also the initial state, such that any DFA accepting the language , which is equal to , needs at least  states.
\end{theorem}
\begin{proof}
When , the witness DFAs used in the proof of Theorem 1 in~\cite{YuZhSa94} can be used to show that the upper bound proposed in Theorem~\ref{thm:star-cat-upper-special} can be reached.

Next, we consider the case when .
We provide witness DFAs  and , depicted in Figures~\ref{fig:DFAA-star-cat-special} and~\ref{fig:DFAB-star-cat-special}, respectively, over the three letter alphabet .

 is defined as  where , and the transitions are given as
    \begin{itemize}
    \item , for ,
    \item , for , where .
    \end{itemize}

 is defined as  where , where the transitions are given as
    \begin{itemize}
    \item , for ,
    \item , for ,
    \item , , for .
    \end{itemize}

    Following the construction described in the proof of Theorem~\ref{thm:star-cat-upper-special}, we construct a DFA  that accepts  (also ).
    To prove that  is minimal, we show that (I) all the states in  are reachable from , and (II) any two different states in  are not equivalent.

    For (I), we show that all the state in  are reachable by induction on the size of .

    The basis clearly holds, since, for any , state  is reachable from  by reading string , and state  can be reached from state  on string , for any  and .

    In the induction steps, we assume that all the states  such that  are reachable.
    Then, we consider the states  where .
    Let  such that .
    We consider the following three cases:
    \begin{enumerate}
    \item  and .
    For any state , state  can be reached as
    
    where  is of size .

    \item  and .
    For any state , state  can be reached from state  by reading string .

    \item .
    In such a case, the first component of state  cannot be .
    Thus, for any state , state  can be reached from state  by reading string .
    \end{enumerate}

    Next, we show that any two distinct states  and  in  are not equivalent.
    We consider the following two cases:
    \begin{enumerate}
    \item .
    Without loss of generality, we assume .
    Then, string  can distinguish the two states, since  and .

    \item  and .
    Without loss of generality, we assume that .
    Then, there exists a state .
    It is clear that, when , string  can distinguish the two states, and when , string  can distinguish the two states since  cannot be .
    \end{enumerate}

    Due to (I) and (II), DFA  needs at least  states and is minimal.
\end{proof}

In the rest of this section, we focus on the case where DFA  contains at least one final state that is not the initial state.
Thus, this DFA is of size at least 2.
We first obtain the following upper bound for the state complexity.

\begin{theorem}\label{thm:star-cat-upper}
Let  be a DFA such that  and , and  be a DFA such that .
Then, there exists a DFA of at most  states that accepts .
\end{theorem}
\begin{proof}
We denote  by . Then, .

We construct a DFA  for the language , where  and  are the languages accepted by DFAs  and , respectively.

Let , where


The initial state  is .

The set of final states is defined to be .

The transition relation  is defined as follows:

where, , , and .

    Intuitively,  is equivalent to the NFA  obtained by first constructing an NFA  that accepts , then catenating this new NFA with DFA  by -transitions.
    Note that, in the construction of , we need to add a new initial and final state .
    However, this new state does not appear in the first component of any of the states in .
    The reason is as follows.
    First, note that this new state does not have any incoming transitions.
    Thus, from the initial state  of , after reading a nonempty word, we will never return to this state.
    As a result, states  such that , , and  is never reached in DFA  except for the state .
    Then, we note that, in the construction of , states  and  should reach the same state on any letter in .
    Thus, we can say that states  and  are equivalent, because either of them is final if , and they are both final states otherwise.
    Hence, we merge this two states and let  be the initial state of .

    Also, we notice that states  such that  can never be reached in , because  is complete.

    Moreover,  does not contain those states whose first component contains a final state of  and whose second component does not contain the initial state of .

    Therefore, we can verify that DFA  indeed accepts , and it is clear that the size of  is
 
\end{proof}

Then, we show that this upper bound is reachable by some witness DFAs.

\begin{figure}[ht]
  \begin{center}
  \includegraphics[scale=0.17]{DFAA-star-cat.eps}
  \end{center}
  \caption{Witness DFA  for Theorem~\ref{thm:star-cat-lower}}
\label{fig:DFAA-star-cat}
\end{figure}

\begin{figure}[ht]
  \begin{center}
  \includegraphics[scale=0.17]{DFAB-star-cat.eps}
  \end{center}
  \caption{Witness DFA  for Theorem~\ref{thm:star-cat-lower}}
\label{fig:DFAB-star-cat}
\end{figure}


\begin{theorem}\label{thm:star-cat-lower}
For any integers , there exist a DFA  of  states and a DFA  of  states such that any DFA accepting  needs at least  states.
\end{theorem}
\begin{proof}
We define the following two automata over a four letter alphabet .

Let , shown in Figure~\ref{fig:DFAA-star-cat}, where , and the transitions are defined as
    \begin{itemize}
    \item , for ,
    \item , , for ,
    \item , for , .
    \end{itemize}

Let , shown in Figure~\ref{fig:DFAB-star-cat}, where , and the transitions are defined as
    \begin{itemize}
    \item , for , ,
    \item , for ,
    \item , for .
    \end{itemize}

    Let  be the DFA accepting the language  which is constructed from  and  exactly as described in the proof of Theorem~\ref{thm:star-cat-upper}.

    Now, we prove that the size of  is minimal by showing that (I) any state in  can be reached from the initial state, and (II) no two different states in  are equivalent.

    We first prove (I) by induction on the size of the second component  of the states in .

    {\bf Basis:} for any , state  can be reached from the initial state  on string .
    Then, by the proof of Theorem 5 in~\cite{YuZhSa94}, it is clear that state  of , where  and , is reachable from state  on strings over letters  and .

    {\bf Induction step:} assume that all the states  in  such that  and  are reachable.
    Then, we consider the states  in  where  and .
    Let  such that .

    Note that states such that  and  are reachable as follows:

Then, states such that  and  can be reached as follows:


Once again, by using the proof of Theorem 5 in~\cite{YuZhSa94}, states  in , where  and , can be reached from the state  on strings over letters  and .

Next, we show that any two states in  are not equivalent.
Let  and  be two different states in .
We consider the following two cases:
\begin{enumerate}
\item .
Without loss of generality, we assume .
Then, there exists a state .
It is clear that string  is accepted by  starting from state , but it is not accepted starting from state .

\item  and .
We may assume that  and let .
Then, state  reaches a final state on string , but state  does not on the same string.
Note that, when , we can say that .
\end{enumerate}

Due to (I) and (II), DFA  has at least  reachable states, and any two of them are not equivalent.
\end{proof}

\section{Conclusion}\label{sec:conclusion}
In this paper, we have studied the state complexities of two combined operations: reversal combined with catenation and star combined with catenation.
We showed that, due to the structural properties of DFAs obtained from reversal and star, the state complexities of these two combined operations are not equal but close to the mathematical compositions of the state complexities of their individual participating operations.
\begin{thebibliography}{9}
\bibitem{CCSY99}
    C. Campeanu, K. Culik, K. Salomaa, S. Yu:
    State complexity of basic operations on finite language,
    in: {\it Proceedings of the Fourth International Workshop on Implementing Automata VIII} 1-11,
    LNCS 2214, 1999, 60-70

\bibitem{CaSaYu02}
    C. Campeanu, K. Salomaa, S. Yu:
    Tight lower bound for the state complexity of shuffle of regular languages,
    {\it Journal of Automata, Languages and Combinatorics} 7 (3) (2002) 303-310

\bibitem{CGKY10-cat-sr}
    B. Cui, Y. Gao, L. Kari, S. Yu:
    State complexity of catenation combined with star and reversal,
    in: {\it Proceedings of DCFS 2010}, Saskatoon, SK, Canada,  August 8-10, 2010

\bibitem{CGKY10-cat-ui}
    B. Cui, Y. Gao, L. Kari, S. Yu:
    State complexity of catenation combined with union and intersection,
    in: {\it Proceedings of CIAA 2010}, Winnipeg, MB, Canada,  August 12-15, 2010

\bibitem{DaDoSa08}
    M. Daley, M. Domaratzki, K. Salomaa:
    State complexity of orthogonal catenation,
    in: {\it Proceedings of DCFS 2008}, Charlottetown, PE, Canada, July 16-18, 2008, 134-144

\bibitem{Domaratzki02}
    M. Domaratzki:
    State complexity and proportional removals,
    {\it Journal of Automata, Languages and Combinatorics} 7 (2002) 455-468

\bibitem{DoOk09}
    M. Domaratzki, A. Okhotin:
    State complexity of power,
    {\it Theoretical Computer Science} 410(24-25) (2009) 2377-2392

\bibitem{EGLY2009}
    Z. \'Esik, Y. Gao, G. Liu, S. Yu:
    Estimation of state complexity of combined operations,
    {\it Theoretical Computer Science} 410 (35) (2009) 3272-3280

\bibitem{GaSaYu08}
    Y. Gao, K. Salomaa, S. Yu:
    The state complexity of two combined operations: star of catenation and star of Reversal,
    {\it Fundamenta Informaticae} 83 (1-2) (2008) 75-89

\bibitem{GaYu09}
    Y. Gao and S. Yu:
    State complexity approximation,
    in:{\it Proceedings of Descriptional Complexity of Formal Systems} (2009) 163-174

\bibitem{GaYu10}
    Y. Gao and S. Yu:
    State complexity of union and intersection combined with star and reversal,
    {\it Computing Research Repository} (2010) arXiv:1006.3755v1

\bibitem{HoKu02}
    M. Holzer, M. Kutrib:
    State complexity of basic operations on nondeterministic finite automata,
    in: {\it Proceedings of International Conference on Implementation and Application of Automata} 2002,
    LNCS 2608, 2002, 148-157

\bibitem{HoMoUl01}
    J. E. Hopcroft, R. Motwani, J. D. Ullman:
    {\it Introduction to Automata Theory, Languages, and Computation (2nd Edition)},
    Addison Wesley, 2001

\bibitem{JiJiSz05}
    J. Jir\'{a}sek, G. Jir\'{a}skov\'{a}, A. Szabari:
    State complexity of concatenation and complementation of regular languages,
    {\it International Journal of Foundations of Computer Science} 16 (2005) 511-529

\bibitem{Jriaskova05}
    G. Jir\'{a}skov\'{a}:
    State complexity of some operations on binary regular languages,
    {\it Theoretical Computer Science} 330 (2005) 287-298

\bibitem{JiOk05}
    G. Jir\'{a}skov\'{a}, A. Okhotin:
    State complexity of cyclic shift,
    in: {\it Proceedings of DCFS 2005}, Como, Italy, June 30-July 2, 2005, 182-193

\bibitem{JiOk07}
    G. Jir\'{a}skov\'{a}, A. Okhotin:
    On the state complexity of star of union and star of intersection,
    {\it Turku Center for Computer Science TUCS Technical Report} No. 825, 2007

\bibitem{LiMaSaYu08}
    G. Liu, C. Martin-Vide, A. Salomaa, S. Yu:
    State complexity of basic language operations combined with reversal,
    {\it Information and Computation} 206 (2008) 1178-1186

\bibitem{PiSh02}
    G. Pighizzini, J. Shallit:
    Unary language operations, state complexity and Jacobsthal's function,
    {\it International Journal of Foundations of Computer Science} 13 (1) (2002) 145-159

\bibitem{SaSaYu07}
    A. Salomaa, K. Salomaa, S. Yu:
    State complexity of combined operations,
    {\it Theoretical Computer Science} 383 (2007) 140-152

\bibitem{SaWoYu04}
    A. Salomaa, D. Wood, S. Yu:
    On the state complexity of reversals of regular languages,
    {\it Theoretical Computer Science} 320 (2004) 293-313

\bibitem{Yu01}
    S. Yu:
    State complexity of regular languages,
    {\it Journal of Automata, Languages and Combinatorics} 6 (2) (2001) 221-234

\bibitem{YuZhSa94}
    S. Yu, Q. Zhuang, K. Salomaa:
    The state complexity of some basic operations on regular languages,
    {\it Theoretical Computer Science} 125 (1994) 315-328

\bibitem{Yu97}
    S. Yu:
    Regular languages,
    in: G. Rozenberg, A. Salomaa (Eds.), {\it Handbook of Formal Languages}, Vol. 1, Springer-Verlag, 1997, 41-110

\bibitem{Yu01}
    S. Yu:
    State complexity of regular languages,
    {\it Journal of Automata, Languages and Combinatorics} 6(2) (2001) 221-234
\end{thebibliography}

\end{document}
