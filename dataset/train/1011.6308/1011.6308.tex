\documentclass{LMCS} 
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{stmaryrd} 
\usepackage{amstext}
\usepackage{xspace}
\usepackage{enumerate}
\usepackage{extarrows}
\usepackage{bbb}
\usepackage{hyperref}

















\def\fps@figure{tp}      \def\fps@table{tp}
\def\topfraction{.98}      \def\bottomfraction{.98}   \def\textfraction{.01}     \def\floatpagefraction{.9}
\newcommand{\pfn}[1]{\mathsf{#1}}  \newcommand{\cfn}[1]{\mathsf{#1}}  \newcommand{\ownfnt}[1]{{\mathsf{#1}}}  

\newcommand{\cbisim}{\sqsubseteq_{\text{\tiny cost}}}
\newcommand{\DPI}{\ensuremath{\pfn{Dpi}}\xspace}
\newcommand{\picost}{\ensuremath{\pfn{Picost}}\xspace}
\newcommand{\forces}{ \mathbin{\models}\;}
\newcommand{\with}{\mathbin \rhd}
\newcommand{\Own}{\ensuremath{\pfn{Own}}\xspace}
\newcommand{\Chan}{\ensuremath{\pfn{Chan}}\xspace}
\newcommand{\News}{\ensuremath{\pfn{News}}\xspace}
\newcommand{\Var}{\ensuremath{\mathsf{Var}}\xspace}
\newcommand{\picalculus}{\namef{Pi-calculus}\xspace}
\newcommand{\subscribe}[3]{\ensuremath{\mathsf{subscribe}({#1},{#2},{#3})}\xspace}
\newcommand{\trf}[3]{\ensuremath{\mathsf{transfer}({\ownfnt{#1}},{\ownfnt #2},{ #3})}\xspace}
\newcommand{\donate}[2]{\ensuremath{\pfn{donate}({ #1},{\ownfnt #2})}\xspace}
\newcommand{\cancom}[3]{({\ownfnt{#1}},{#2},{\ownfnt{#3}}) \xspace}
\newcommand{\cancomin}[2]{({\ownfnt{#1}},{#2}) \xspace}
\newcommand{\cancomout}[2]{({#1},{\ownfnt{#2}}) \xspace}
\newcommand{\ext}[3]{\mathsf{ext}({\ownfnt{#1}},{#2},{\ownfnt{#3}}) \xspace}
\newcommand{\subsc}[1]{\ensuremath{\mathsf{sub}({#1})}}
\newcommand{\ownless}{\preceq^o}

\newcommand{\Act}{\ensuremath{\mathsf{Act}}\xspace}
\newcommand{\record}{{\scriptstyle \mathsf{rec}}}
\newcommand{\Kost}{\ensuremath{K}\xspace}
\newcommand{\cecombine}{\mathbin{\star}}
\newcommand{\cost}[1]{\mathop{\mathsf{weight}(#1)}}
\newcommand{\costN}{\mathsf{weight}}

\newcommand{\nats}{\ensuremath{\bbb N}\xspace}

\newcommand{\ownO}{ {\ownfnt O}}
\newcommand{\sobs}{{\ownfnt e}}

\newcommand{\amort}[1]{\mathrel{\sqsubseteq_{\rm wgt}^{#1}}}
\newcommand{\behav}[1]{\mathrel{\sqsubseteq_{\rm behav}^{#1}}}
\newcommand{\wrongamort}[1]{\mathrel{\sqsubseteq_{\rm not}^{#1}}}
\newcommand{\cxtequiv}[1]{\mathrel{\sqsubseteq_{\rm cxt}^{#1}}}
\newcommand{\Ecxtequiv}[1]{\mathrel{\sqsubseteq_{\rm \sobs cxt}^{#1}}}
\newcommand{\Obscxtequiv}[2]{\mathrel{\sqsubseteq_{#1:\rm cxt}^{#2}}}
\newcommand{\Ocxtequiv}[1]{\Obscxtequiv{\ownO}{#1}}
\newcommand{\Gammaobs}{\Gamma^{\sobs}}
\newcommand{\Deltaobs}{\Delta^{\sobs}}

\newcommand{\Eamort}[1]{\mathrel{\sqsubseteq_{\rm \sobs wgt}^{#1}}}
\newcommand{\aamort}[1]{\mathrel{\sqsubseteq_{\rm awgt}^{#1}}}
\newcommand{\Oamort}[1]{\mathrel{\sqsubseteq_{\rm Owgt}^{#1}}}
\newcommand{\Obsaamort}[2]{\mathrel{\sqsubseteq_{\rm #1 awgt}^{#2}}}
\newcommand{\Oaamort}[1]{\Obsaamort{\ownO}{ #1}}
\newcommand{\Gammadyn}{\Gamma_{\scriptstyle dyn}}



\def\pair(#1,#2){\langle #1 , #2 \rangle}\newcommand{\parrow}{ \mathbin{\rightharpoonup}}
\newcommand{\dom}[1]{\mathop{\text{dom}}(#1)}
\newcommand{\size}[1]{\mathop{|#1|}}
\newcommand{\setof}[2]{\{ \, #1 \, \mid \, #2 \, \}}\newcommand{\sset}[1]{\{ {#1}  \}  } 

\newcommand{\typeletter}[1]{{\mathsf{#1}}}
\newcommand{\tR}{\typeletter{R}}
\newcommand{\tK}{\typeletter{K}}
\newcommand{\tS}{\typeletter{S}}
\newcommand{\tC}{\typeletter{C}}
\newcommand{\tE}{\typeletter{E}}
\newcommand{\tT}{\typeletter{T}}
\newcommand{\ORred}[1]{\ensuremath{\Rulef{(or\textrm{-}#1)}}}\newcommand{\Obs}[1]{\mathbin{\Downarrow^{#1}}}
\newcommand{\SObs}[1]{\mathbin{\downarrow^{#1}}}
\newcommand{\Odel}[1]{\mathop{\pfn{del}}({#1})}

\newcommand{\rbc}{\mathbin{\curlyeqprec_{cbp}}}

\newcommand{\calR}{\mathbin{\mathcal{R}}}
\newcommand{\calS}{\mathcal{S}}
\newcommand{\calC}{\mathcal{C}}
\newcommand{\calD}{\mathcal{D}}
\newcommand{\calO}{\mathcal{O}}


\makeatletter

\usepackage{ifthen}


\newcommand{\pa}[1]{\!\left(#1\right)}
\newcommand{\pc}[1]{\langle#1\rangle}
\newcommand{\Cassoc}[2]{ {{#1}\kern -0.2em : \kern -0.2em {#2}}}
\newcommand{\Cnew}[2]{(\mathop{\pfn{new}} \Cassoc{#1}{#2})}
\newcommand{\CnewNT}[1]{(\pfn{new} {#1})}


\newcommand{\Cnil}{\mathop{\pfn{0}}}
\newcommand{\Cstop}{\mathop{\pfn{stop}}}
\newcommand{\Cpar}{\mathbin{|}}
\newcommand{\Crep}[1]{* \;#1}
\newcommand{\Cmatch}[3]{\pfn{if}\; #1 \; \pfn{then}\; #2\;
                        \pfn{else}\; #3}
\newcommand{\Crec}[2]{\pfn{rec}\;#1.\;#2}
\newcommand{\Cloc}[2]{[#1]_{\ownfnt{#2}}}

























\DeclareSymbolFont{smallcaps}{\encodingdefault}{\rmdefault}{m}{sc}
\DeclareSymbolFontAlphabet\mathsc{smallcaps}
\newcommand{\Rulef}[1]{{\mathsc{#1}}}   \newcommand{\Rred}[1]{\ensuremath{\Rulef{(r\textrm{-}#1)}}}\newcommand{\Rstruct}[1]{\ensuremath{\Rulef{(s\textrm{-}#1)}}}\newcommand{\Rlts}[1]{\ensuremath{\Rulef{(l\textrm{-}#1)}}}

\newcommand{\nowidth}[2][l]{\makebox[0cm][#1]{#2}}\newcommand{\mnowidth}[2][l]{\makebox[0cm][#1]{}}\RequirePackage{ifthen}   \newcommand{\ifemptyelse}[3]{\ifx\@@bullshit#1\@@bullshit#2\else#3\fi}
\newcommand{\ifnotempty}[2]{\ifx\@@bullshit#1\@@bullshit\else#2\fi}
\newenvironment{scope}
  {\bgroup\ignorespaces}
  {\egroup\global\@ignoretrue}

\newbox\@topbox
\newbox\@botbox
\newcommand{\linfer}[3][{}]{\ifemptyelse{#1}{
    \setbox\@topbox\hbox{\renewcommand{\arraystretch}{1}}}{
    \ifemptyelse{#2}{
      \setbox\@topbox\hbox{\renewcommand{\arraystretch}{1}}}{
      \setbox\@topbox\hbox{\renewcommand{\arraystretch}{1}}}
    }
  \setbox\@botbox\hbox{\def\tilde##1{\widetilde{##1}}\renewcommand{\arraystretch}{1}}\ifdim\wd\@botbox<\wd\@topbox \setbox\@botbox\hbox to \wd\@topbox{\box\@botbox\hfil}
  \else
    \setbox\@topbox\hbox to \wd\@botbox{\box\@topbox\hfil}
  \fi
  \frac{\box\@topbox}{\box\@botbox}
  }
\newcommand{\linferSIDE}[4][{}]{\ifemptyelse{#1}{
    \setbox\@topbox\hbox{\renewcommand{\arraystretch}{1}}}{
    \ifemptyelse{#2}{
      \setbox\@topbox\hbox{\renewcommand{\arraystretch}{1}}}{
      \setbox\@topbox\hbox{\renewcommand{\arraystretch}{1}}}
    }
  \setbox\@botbox\hbox{\def\tilde##1{\widetilde{##1}}\renewcommand{\arraystretch}{1}}\ifdim\wd\@botbox<\wd\@topbox \setbox\@botbox\hbox to \wd\@topbox{\box\@botbox\hfil}
  \else
    \setbox\@topbox\hbox to \wd\@botbox{\box\@topbox\hfil}
  \fi
  \frac{\box\@topbox}{\box\@botbox}
  \hbox{\;\footnotesize}}

\newcommand{\slinfer}[2][{}]{\renewcommand{\arraystretch}{1}\begin{array}{l}{\scriptstyle #1}\\#2\end{array}}
\newcommand{\slinferSIDE}[3][{}]{\renewcommand{\arraystretch}{1}\begin{array}{ll}{\scriptstyle #1}\\#2 &#3\end{array}}

\def\mhto{\@transition\mharrowfill}
\def\goesto{\@transition\rightarrowfill}
\def\Goesto{\@transition\Rightarrowfill}
\def\ngoesto{\@transition\nrightarrowfill}
\def\nsgoesto{\@transition\nmapstofill}
\def\comesfrom{\@transition\leftarrowfill}
\def\nGoesto{\@transition\nRightarrowfill}
\def\@transition#1{\@ifnextchar[{\@@transition{#1}}{\@@transition{#1}[]}}
\newbox\@transbox
\newbox\@arrowbox
\def\mharrowfill{\mkern-2mu\mathord-\mkern-2mu}
\def\mapstofill{\mkern-2mu\mathord-\mkern-2mu}
\def\Rightarrowfill{\mkern-2mu\mathord=\mkern-2mu}
\def\nrightarrowfill{\mkern-2mu\mathord-\mkern-2mu\mkern-2mu\mathord-\mkern-2mu}
\def\@@transition#1[#2]{\setbox\@transbox\hbox
{\vrule height 1.2ex depth 1.1ex width          0ex\hskip0.25em\hskip0.25em}  
   \ifdim\wd\@transbox<1.5em
      \setbox\@transbox\hbox to 1.5em{\hfil\box\@transbox\hfil}\fi
   \setbox\@arrowbox\hbox to \wd\@transbox{#1}
   \ht\@arrowbox\z@\dp\@arrowbox\z@
   \setbox\@transbox\hbox{}
   \ht\@transbox\z@\dp\@transbox\z@
   \mathrel{\box\@transbox}}
\def\nxmapsto{\@transition\nmapstofill}
\def\xmapsto{\@transition\mapstofill}
\def\mapstofill{\mkern-2mu\mathord-\mkern-2mu}
\def\nmapstofill{\mkern-2mu\mathord-\mkern-2mu\mkern-2mu\mathord-\mkern-2mu}



\newcommand{\ar}[1]{\mathbin{\xlongrightarrow{ #1}}}  

\newcommand{\arO}[2]{\mathrel{
      \goesto[{#1}]_{\raisebox{7pt}{}}^{\raisebox{-4pt}{}}}}


\newcommand{\arGen}[3]{\mathrel{
      \goesto[{#1}]_{\raisebox{7pt}{}}^{\raisebox{-4pt}{}}}}

\newcommand{\darO}[2]{\mathrel{
      \Goesto[{#1}]_{\raisebox{7pt}{}}^{\raisebox{-4pt}{}}}}

\newcommand{\arstar}[1]{\mathrel{\xlongrightarrow{#1}^{\raisebox{-5pt}{}}}}  \newcommand{\newar}[1]{\mathrel{\overset{ #1}\mapsto}}   \newcommand{\newarstar}[1]{\mathrel{\overset{#1}\mapsto^{\raisebox{-5pt}{}}}}  \newcommand{\arOwn}[2]{\mathbin{\goesto[{#1}]_{\scriptscriptstyle {#2}}}}
\newcommand{\dar}[1]{\xLongrightarrow{\vspace{-2em}#1}}
\newcommand{\darstar}[1]{\xLongrightarrow{#1}^*}
\newcommand{\newdar}[1]{\Goesto[{\vspace{1em}#1}]}  \newcommand{\mhtry}[1]{\mathbin{\stackrel{#1}{\longmapsto}}}
\newcommand{\smalleval}{\longrightarrow}  \newcommand{\csmalleval}[1]{\longrightarrow^{#1}}
\newcommand{\smallevall}{\longrightarrow_{L}}
\newcommand{\smallevalh}{\longrightarrow_{H}}
\newcommand{\structeq}{\equiv}
\newcommand{\lsetbar}{\mathopen{\{\hspace{-.24em}\vert}}
\newcommand{\rsetbar}{\mathclose{\vert\hspace{-.24em}\}}}
\newcommand{\smallscript}{\mathchoice{\scriptstyle}{\scriptstyle}{\scriptscriptstyle}{\scriptscriptstyle}}
\newcommand{\@subst@brackets}[1]{\lsetbar #1 \rsetbar}
\newcommand{\@subst}[2]{{\overset{#2}{\phantom{.}}} \!/\! {\smallscript #1}}
\newcommand{\subst}[2]{\@subst@brackets{\@subst{#1}{#2}}}
\newcommand{\fn}[1]{\mathop{\pfn{fn}}(#1)}
\newcommand{\bn}[1]{\mathop{\pfn{bn}}(#1)}
\newcommand{\name}[1]{\mathop{\pfn{n}}(#1)}
\newcommand{\names}[1]{\mathop{\pfn{n}}(#1)}

\newcommand{\leaveout}[1]{ }










\newcommand{\EndDefBox}{\null\hfill}
\global\let\EndProof\EndProofBox
\newcommand{\boxHere}{\global\let\EndProof\empty\EndDefBox}







\newenvironment{simple-definition}{\begin{defii}\rm}{\end{defii}}










\makeatother




\usepackage{url}



\def\lastname{Hennessy}

\def\doi{7 (1:7) 2011}
\lmcsheading {\doi}
{1--35}
{}
{}
{Jul.~30, 2009}
{Mar.~23, 2011}
{}

\begin{document}

\title[costed computations]{A calculus for costed computations}

\author[M.~Hennessey]{Matthew Hennessy}


\address{Department of Computer Science\\ Trinity College Dublin\\
    Ireland} 

\email{matthew.hennessy@cs.tcd.ie}   
\thanks{The financial support of SFI is gratefully acknowledged.}







\begin{abstract}

We develop a version of the picalculus \picost where  
channels are interpreted as \emph{resources} which have 
costs associated with them. Code runs under the financial
responsibility of \emph{owners}; they   must pay to 
\emph{use} resources, but may profit by \emph{providing} 
them.

We provide a  proof methodology for processes described in \picost
based on bisimulations. The underlying  behavioural theory is justified
via a contextual characterisation. We also demonstrate its usefulness
via examples. 

\end{abstract}

\subjclass{F.3.1, F.3.2, F.3.3}
\keywords{resources, cost, picalculus, bisimulations, amortisation}


\maketitle 


\section{Introduction}


The purpose of this paper is to develop a  behavioural
theory of processes, in which computations depend on the ability to
fund the resources involved. The theory will be based on the
well-known concept of bisimulations, \cite{pimilner}, which
automatically gives a powerful co-inductive proof methodology for
establishing properties of processes; here these properties will
include the cost of behaviour.



 We take as a starting point
the well-known picalculus, \cite{pibook,pimilner}, a language for
describing mobile processes which has a well-developed behavioural
theory. In the picalculus a process is described in terms of its
ability to input and output on \emph{communication channels}. Here we
interpret these channels as \emph{resources}, or services, as for
example in \cite{beppe}. So input along a channel, written as
 in the picalculus, is now interpreted as \emph{providing}
the service , while output, written , is interpreted as
a request to \emph{use} the service .  A process is now determined
by the manner in which it \emph{provides}  services and
\emph{uses} them.
   
Viewed from this perspective, we extend the picalculus in two ways.
Firstly we associate a \emph{cost} with resources; specifically for
each resource we assume that a certain amount of funds  is
charged to \emph{use} it, and an amount  is also required to
\emph{provide} it. Secondly we introduce \emph{principals} or \emph{owners}
who provide the funds necessary for the functioning of resources. 
The novel construct in the language is , representing
the (picalculus) process  running under the financial responsibility 
of . For example in  the use of the resource 
 is only possible if  can fund the charges. Similarly with
 , but here there is also the potential for gain
for owner ; in our formulation  profits from 
any difference between the cost in providing the resource and the 
charge made to use it. 

Our language \picost is presented in Section~\ref{sec:lang}, and is essentially 
a variation on \DPI, a typed distributed version of the picalculus, \cite{dpibook}.
The reduction semantics is given in terms of judgements of the form

where  are \emph{cost environments}. These have a static component, giving
the costs associated with resources, and a dynamic part, which gives the funds available to owners 
and also records expenditure. The usefulness of the language is demonstrated by a series of 
simple examples. 

But the main achievement of the paper is a  behavioural theory, expressed as judgements

indicating that, informally speaking,
\begin{enumerate}[(i)]
\item the process  running relative to the cost environment  is bisimilar, in the
standard sense \cite{ccs}, with process  running relative to 

\item the costs associated with  are no more, and possibly less,  than those
associated with .
\end{enumerate}


 \noindent Influenced by \cite{astrid} we first develop a general framework of
\emph{weighted labelled transition systems} or \emph{wLTSs}, in which
actions, including internal actions, may have multiple weights
associated with them. We then define a notion of \emph{amortised
  weighted bisimulations} between their states, giving rise to a
preorder , meaning that  are bisimilar but in some
sense the behaviours of  are \emph{lighter} than those of . From
this we obtain, in the standard manner, a co-inductive proof
methodology for proving that two systems are related; it is sufficient
to find, or construct, a particular amortised weighted bisimulation 
containing the pair . 

This proof methodology is applied to \picost by first interpreting the
language as an LTS, in agreement with the reduction semantics, and
then interpreting this LTS as a wLTS, giving rise to (parametrised 
versions of) the judgements
(\ref{eq:judge}) above.  But as we will see these judgements can be
interpreted in two ways. If the recorded expenditure represents
\emph{costs} then  can be considered an improvement
on . On the other hand if it represents
\emph{profits} then we have the reverse;  is an
improvement on  as it has the potential to be
heavier.

The details of this theory are given in Section~\ref{sec:lts}, and the
resulting proof methodology is illustrated by examples.  However in
Section~\ref{sec:cxt} we re-examine this proof methodology, in the
light of reasonable properties we would expect of it; and these are
found wanting.  It turns out that the manner in which we generate the
wLTS for \picost from its operational semantics is too coarse. We
show how to generate a somewhat more abstract wLTS, and prove that the
resulting proof methodology is satisfactory, in a precise technical
sense,  by adapting the notion of reduction barbed congruence,
\cite{ht92,pibook,pityping,dpibook}.

\begin{figure}[t]


\caption{Syntax of \picost\label{fig:syn}}
\end{figure}



\section{The language \picost}\label{sec:lang}

\subsection{Syntax:}


We assume a set of \emph{channel} or \emph{resource} names \Chan,
ranged over by   whose use requires some cost,
a distinct set of (value) variables , ranged over by
, and a further distinct set of recursion variables,
;  ranges over \emph{identifiers}, which may be either
resource names or (value) variables.  We also assume a set of
\emph{principals} or \emph{owners} \Own containing at least two
elements, ranged over by , who are
implicitly registered for these resources and who finance their
provision and use. The syntax of \picost is then given in
Figure~\ref{fig:syn}, and is essentially a very minor variation on
\DPI, \cite{dpibook}. The main syntactic category represents code
running under responsibility, with  being the novel
construct. As explained in the Introduction this represents the code
 running under the responsibility of the owner ;
intuitively  is financially responsible for the computation
. Thus in general a system is simply a collection of computation
threads each running under the responsibility of an explicit owner,
which may share private resources. The syntax for these threads is a
version of the well-known picalculus, \cite{pibook}.

The type  of a  resource  describes the costs 
associated with that resource. There is a cost associated with \emph{using}
a resource, and a cost associated with \emph{providing} it; therefore
types take the form

where  are elements from some \emph{cost domain} \Kost.
Here we take \Kost simply to be  ordered in the standard manner, 
but most of our results apply equally well to variations. 



We employ the standard abbreviations associated with the picalculus,
and associated terminology. In particular we assume \emph{Barendregt's
  convention}\label{barendregt}, which implies that bound variables used in terms or
definitions are distinct, and different from any free variables in use
in the current context.  In Figure~\ref{fig:syn} meta-variable 
range over \emph{value expressions}, whose specification we omit; but
they include at least resource names , variables  from
, and elements of . As usual we omit every
occurrence of a trailing  and abbreviate  to  respectively.  We are only interested in
\emph{closed code terms}, those which contain no free occurrences of
variables, which are ranged over by ; we use   
 to denote the set of names from   which occur freely in . 
 In the
sequel we assume all terms are closed.



 
\subsection{Cost environments:}
Since computations have financial implications, the execution of
processes is now relative to a \emph{cost environment} . This
records the financial resources available to principals, and the cost
of providing and using resources; in order to be able to compare the
cost of computations we also assume a component which records the
expenditure as a computation proceeds.
Thus judgements of the reduction semantics take the form

where  are cost environments. 



There are many possibilities for \emph{cost environments}; see \cite{picost} 
for an example which directly associates funds with resources. In the present paper
we define them in such a way that the owners retain total control over their own funds. 

\begin{defi}[Cost environments]\label{def:costenv}
A  \emph{cost environment}  consists
of a 4-tuple   where
\begin{enumerate}[]

\item 


 records the cost of \emph{using} resource ; this is a
\emph{static} component, and will not vary during computations

\item 


 records the cost of \emph{providing} resource ; again
this is a static component

\item 


 records the funds available to owner ; this will vary as computations proceed, as owners will need to
fund their interactions with resources

\item  

  keeps an
account of the expenditure occurred during a computation; of course
this also will vary as a computation proceeds.
\end{enumerate}

\medspace We assume that both functions  have the same
finite domain, but not necessarily that 
whenever these are defined. \boxHere
\end{defi}

We now define some operations on cost environments which will enable
us to reflect their impact on the semantics of our language. The most
important is a partial function, , which informally means that in  owner  has
sufficient funds to cover the cost of using resource  and owner
 has sufficient funds to provide it.  Then  records
the result of the expenditure of both  and  of
those funds. There is also considerable scope as to what happens to
these funds, and how their expenditure is recorded.  Here we take the
view that the provider  gains the cost which the user
expends, to offset  's cost in providing the resource.
\begin{defi}[Resource charging]\label{def:rescharging}
  Let  be the partial function 
over cost environments defined as follows:
 if
\begin{enumerate}[(i)]



\item  and 


\item   is the cost environment obtained from  by 
  \begin{enumerate}[(a)]
  \item decreasing  by the amount  

  \item increasing   by the 
amount , which may of course be negative


  \end{enumerate}

\item 
  Finally there is considerable flexibility in how this resource
  expenditure is recorded in .  We call resource 
  charging  for   \emph{standard} when this is set to ; that is we add to the record the gain
  obtained in using resource .  But in general we allow functions
  , for each resource , in which case we define
   to be . \boxHere
\end{enumerate}
\end{defi}
\noindent
In general we allow the owners  and  in this definition
to coincide. So, for example if 
, then the effect of performing (a) above, 
followed by (b), is that 
 is set to  .
 
The use of two independent charges for each resource,  and
, may seem overly complex. A simpler model can be obtained by
having only one combined charge; effectively we could assume
 to be  for every , and so resource charging simply
transfers the appropriate amount of funds from the user to the
provider; this could be achieved by restricting attention to
\emph{simple types}, resource types  of the form .
Indeed this simplification will be quite useful in order to achieve
some theoretical  properties of our proof methodology; see 
Definition~\ref{def:simpletypes} and Section~\ref{sec:fa}.
Nevertheless 
the use of the two independent charges  and  allows scope for more
interesting examples. In particular it provides considerable scope for variation 
in the manner in which resource expenditure is recorded in the component ;
see Example~\ref{ex:publishing} for an instance.


\leaveout{
The restriction in (i) that the owners   and  be 
different is slightly inconvenient, but as we will see it simplifies the
development of the theory somewhat. This simplification will be a consequence
of  the following result:
\begin{lem}\label{lem:1}
  Suppose  and 
. Then 
. 
\end{lem}
\proof
Ah 
\qed
It is worth pointing out that this result is no longer true if condition
(i) is omitted from Definition~\ref{def:costenv}.
\begin{exa}\label{ex:1}
 A natural definition of  would be to allow
 whenever  is determined
by

with the other components of  being determined 
as in Definition~\ref{def:costenv}.

With this definition Lemma~\ref{lem:1} is no longer true. Let 
be a cost environment with resource  with associated costings 
and , and suppose there are two owners, with funds given by
.  Then there is a cost
environment  such that
\begin{enumerate}[]
\item 

\item 

\item but \textbf{not} .
\end{enumerate}
 is determined by the fact that  and 
.  It follows that 
can not be true as it requires  to be 
, namely . \qed
\end{exa}

}
\noindent
We also need to extend cost environments with new resources.
\begin{defi}[Resource registration]\label{def:resourcereg}
  The cost environment , is only defined if
   is \emph{fresh} to , that is, if  is neither in
   nor in . In this case it gives the new
  cost environment  obtained by adding the new resource, with
  the capabilities determined by .  Formally the dynamic components
of , namely  and , are inherited directly
from , while the static components have the obvious definition; for 
example if  is the type  then  is given by

We also assume that the  resource charging for 
  in  is always standard. \boxHere
\end{defi}

\noindent
Note that every cost environment may be written in the form

where   is a \emph{basic} environment;
that is the static components  and 
are both empty, and so it 
only contains  non-trivial dynamic components. 

\begin{figure}[t]


\caption{Reduction semantics \label{fig:reductions}}


\caption{Structural equivalence of  \label{fig:structeq}}

\end{figure}


\subsection{Reduction semantics:}
The pair  is called a \emph{configuration} provided that
, that is every free
resource name in  is known to the \emph{cost environment} .
The reduction semantics for \picost is then defined as the least
relation over configurations which satisfies the rules in
Figure~\ref{fig:reductions}.  The majority of the rules come directly
from the reduction semantics of \DPI, \cite{dpibook}, and are
housekeeping in nature. The only rule of interest is \Rred{comm},
representing the communication along the channel , or in \picost
the \emph{use} of the resource  by owner  which is
\emph{provided} by owner . However this reduction is only possible
whenever the premise  is
satisfied.
As we have seen, this means that in  owner 
has sufficient funds to cover the cost of using resource  and owner
 has sufficient funds to provide it; and further  records
the result of the expenditure of both  and  of
those funds.


The remainder of the rules are borrowed directly from the standard
reduction semantics of \DPI; note that \Rred{struct} requires a
structural equivalence between terms; this again is the standard one
from \DPI, the definition of which is given  in
Figure~\ref{fig:structeq}. Also the final rule \Rred{new} uses the
registration operation on cost environments, given in
Definition~\ref{def:resourcereg}.
\begin{prop}
  If  is a configuration and 
 
then  is also a configuration.  
\end{prop}
\proof
Straightforward, by induction on the proof that 
.
When handling the rule \Rred{struct} it uses the obvious fact that 
implies that  and  have the same set of free names; this in turn means that
 implies  is a configuration if and only if
 is. 
\qed

The reductions of a configuration affect its cost environment, and
as a sanity check we can describe precisely the kinds of changes which
are possible:\vfill\eject

\begin{prop}\label{prop:red}
  Suppose . Then 
  \begin{enumerate}[\em(i)]
  \item , and  whenever  is a
        configuration
  \item or , for some resource  and owners ,
            and whenever  is a
        configuration  implies  
  \item or , for some (fresh) resource , resource type
  and owners , and whenever  is a
        configuration
        implies 
         
  \end{enumerate}
\end{prop}
\proof
Again this is a simple proof by rule induction on the premise
.  Intuitively possibility (i) corresponds to a move
where no communication occurs, (ii) is when the move is a communication along a channel  known to ,
and (iii) when the communication is along a private internal channel. 
\qed

\subsection{Examples:}\label{sec:examples1}

\newcommand{\Reader}{\pfn{Reader}}
\newcommand{\Store}{\pfn{Store}}
\newcommand{\Library}{\pfn{Library}}
\newcommand{\Sys}{\pfn{Sys}}
\newcommand{\UD}{\pfn{UD}}
\newcommand{\Lib}{\pfn{Lib}}
\newcommand{\GB}{\pfn{Book}}

\newcommand{\local}{\pfn{local}}
\newcommand{\central}{\pfn{central}}

\newcommand{\goLib}{\cfn{goLib}}
\newcommand{\goHome}{\cfn{goHome}}
\newcommand{\reqR}{\cfn{reqR}}
\newcommand{\reqS}{\cfn{reqS}}
\newcommand{\Cname}{\cfn{name}}
\newcommand{\Cbook}{\cfn{book}\xspace}
\newcommand{\Creq}{\cfn{req}}

\newcommand{\Cpublic}{\ownfnt{pub}}
\newcommand{\Clib}{\ownfnt{lib}}
\newcommand{\kate}{\ownfnt{kate}}
\newcommand{\dad}{\ownfnt{dad}}


\newcommand{\news}{\cfn{news}}
\newcommand{\publish}{\cfn{publish}}
\newcommand{\adv}{\cfn{adv}}

Formally \picost has only unary communication, but
in these examples we will informally allow the communication of tuples
along channels. In addition we will use the standard abbreviations
associated with the picalculus.  We also omit types for channels when
they are not relevant; in such cases we assume that they cost nothing
to provide, and that there is no charge for using them.  It will be
convenient to have an \emph{internal choice} operator, with  representing an internal choice between  and .  This can be
taken to be short-hand notation for , where  is a fresh channel.





\begin{figure}[t]


  
  \caption{Running a library}
  \label{fig:lib}
\end{figure}



\begin{exa}[Running a library]\label{ex:lib}
  

Consider the system  from Figure~\ref{fig:lib}, which consists
of three recursive components, a library user , running under
the responsibility of the principal , standing for , 
a library interface  and an auxiliary book depository , both running
under some other principal .

The programming of these components
involves the systematic generation of \emph{reply channels}. Thus for example 
the  gets the name of a book with which to go to the library, generates 
a new reply channel  and submits  this together with the name of the book via 
; it awaits the book and then returns home.  The  is also very simple;
it recursively awaits a request on , consisting of a reply channel and a 
and returns the appropriate book on the channel. Finally the 
service requests at  consisting of a reply channel and a name. The book may be immediately
available, in which case it is returned, or it may be necessary to send a request to the . 

Let us now consider the behaviour of these systems relative to two
cost environments  representing
two different strategies for providing library services.  To focus on
the relative cost of providing these services let us assume that their
use is free, that is  for every resource , where  ranges over
, and that 
the amount of funds available is not an issue, that is 
.  The
cost of providing the services,  is given in the table
below, reflecting on the one hand the relative convenience to the  
of the local services, and on the other the relative convenience to the
authorities in providing central services.


\begin{center}
\begin{tabular}{|l|| c | c|}
\hline
          & &\\\hline
    & 1       &5\\\hline
   & 1       &5\\\hline
     & 3       &1\\\hline
      & 5       &1\\\hline
\end{tabular}
\end{center}
Finally let us take the counters
 to be initially set to . 
Note that  can be written as

where  are the types  respectively,
and  is a basic environment;   has a similar representation, with a slightly different
sequence of types. 


To exercise the system we use

to prod the  into action, 
where  is the name of some book. 
Consider the configuration 

and let us ignore the computation steps involved in generating reply
channels, and general housekeeping such as the unwinding of recursive
definitions, which in any event cost nothing.  Because of the internal
non-determinism in the library service there are essentially two
computations from . If the  is not used then after
three computation steps which require funds it is in the state , where . This represents the overall cost of
this transaction,  of which is paid by  and  by . 

On the other hand if the    is used, then there are 
four computation steps which require funding, after which the state 
 is reached, where .  However using
the central cost environment  the two possibilities
are  and
 respectively.  In each eventuality
the local implementation is more efficient, in the sense that the costs are systematically
lower. 
\boxHere
\end{exa}

The charging regime for resources is such that their use effectively
means a transfer of funds to the \emph{provider} from the \emph{user},
provided the cost of providing the resource is less than the charge
for its use. This enables us to implement a systematic way of
transferring funds between owners.
\begin{exa}[Fund transfer]\label{ex:fund.transfer} 
Consider the systems defined as follows:
  
The size of the transfer from  to  depends on the type  at which the
new channel  is declared. Suppose this type is , and let  be a cost environment
in which  is at least .  Then there is a computation

in which  and .
\boxHere
\end{exa}
\begin{figure}[t]


  
  \caption{Publishing}
  \label{fig:publish}
\end{figure}


\begin{exa}[Publishing]\label{ex:publishing}

  Consider the system  in Figure~\ref{fig:publish}, which has four components:
  \begin{enumerate}[(a)]
  \item publisher:  \emph{uses} a news service via the resource ,
        \emph{uses} an advertising agency via the resource  and \emph{provides} 
         the resource   

 \item news service: \emph{provides} a service via 

 \item ad agency: \emph{provides} a service via 

 \item reader: \emph{uses} the resource 
  \end{enumerate}
The viability of publishing depends of course on the cost associated with these resources.
As an example consider an environment , of the form 
, where these types are
 respectively, and let us assume 
 is initialised to . 
Furthermore, since we are concentrating on the publisher, let us assume that the 
resource charging is defined so that only the effect on the owner  is 
recorded. Refering to Definition~\ref{def:rescharging} this means that resource charging
is standard for  but 
we need to set  to be , if
 is either  or . 

Now consider a computation from the configuration . 
Provided the owners have sufficient funds, specifically  and  must be at least  respectively,
then we have a computation

where ; the record part of the initial
environment was set to , during the computation it was set to 
after the publisher uses the  resource, then to  after
using ; finally, when the reader uses the  resource,
this is increased by  to give .  Because we have defined
expenditure recording to reflect the point of view of the publisher, this
represents the fact that the publisher has made a profit of  as a
result of this sequence of transactions.  Note also that at this point
 is .


We can also see what happens when the costs of using resources is changed. 
Let  be the environment in which  the cost of all three resources are decreased 
by . Then we have the computation

where now ; this represents an increase in profits for the publisher. 
\boxHere
\end{exa}

\begin{exa}[Kickbacks]\label{ex:kickback}

Suppose in Figure~\ref{fig:publish} we change the situation so that the publisher obtains a kickback
from the ad agency when an ad is downloaded. The modified code
is given by

and let  denote the revised system. The size of the kickback depends on the parameters in the 
type . In  the ad agency receives the benefit  for supplying the ad; if we set  to be
 then in  this benefit is split equally with the publisher. 
Under the same assumptions as in Example~\ref{ex:publishing} we have the computations

where now  are   respectively, indicating more profit in each case
for the publisher. 
\boxHere
\end{exa}
\section{Compositional reasoning}\label{sec:lts}

The aim of this section is to develop a proof methodology 
for \picost. The idea is to define a  \emph{behavioural preorder} 

meaning that in some sense  and  offer the same behaviour, but the latter is at least as efficient
as the former, and possibly more.  We follow the standard approach
of defining the preorder (\ref{eq:eff}) as the largest relation
between \picost configurations satisfying a transfer property,
associated with the ability of processes to interact with their
peers. We thereby automatically get a co-inductive proof methodology
for establishing relationships between configurations. 


In fact, referring to (\ref{eq:eff}), it is better to move away from
terminology such as \emph{efficiency} as the interpretation 
depends very much on the nature of the units being
recorded. In Example~\ref{ex:lib} these are \emph{costs} and in such a
scenario it is reasonable to interpret (\ref{eq:eff}) as saying
 is an improvement on  as it
potentially involves less cost. On the other hand in
Example~\ref{ex:publishing} the units are \emph{profit} (for the publisher), and here
 would be considered to be an improvement on
, as there is potential for more profit (for the publisher).

We therefore move to the more neutral terminology of \emph{weights}.
However we can not simply base the formulation of (\ref{eq:eff}) on
the relative weight associated with each individual action, as the
following example shows.  \newcommand{\Up}{\cfn{up}}
\newcommand{\down}{\cfn{down}}

\begin{exa}[Amortising costs]\label{ex:amort}
Consider the simple system 

and let  be an environment in which the unique owner
 has unlimited funds, the use of  costs  and the
use of  costs . If we compare  with
, where  is defined analogously,
then intuitively the latter is more efficient than the former, despite
the fact that in the latter the action  is more expensive; this
is compensated for by the relative costs of the other action .
\boxHere
\end{exa}

The remainder of this section is divided into three subsections. In the
first we present a theory of amortised weighted bisimulations, based on
so-called \emph{weighted labelled transition systems}, wLTSs.  This gives rise
to a parametrised behavioural preorder, which we call the
\emph{amortised weighted bisimulation preorder}.  The aim is to apply
this theory to ; with this in mind, in the second subsection
we present a (detailed) labelled transition semantics for \picost, and
show that it is in agreement with the reduction semantics given in
Figure~\ref{fig:reductions}. In the third section we show how this 
automatically generates a wLTS, which in turn gives us an
amortised weighted bisimulation preorder between \picost configurations. 
We demonstrate the usefulness of the resulting proof methodology
by re-examining the examples from Section~\ref{sec:examples1}.


\subsection{Amortised weighted bisimulations:}

Here we generalise  the concepts of \cite{astrid}; our aim is to apply them 
to \picost but our formulation is at a more abstract level.
\begin{defi}[Weighted labelled transition systems]
An \emph{weighted labelled transition system} or wLTS is a 4-tuple 
 where  is a set of states,
 set of weights, and 
.
Here  denotes a set of action names   to which is added an
extra distinct name  which will represent internal action. 
We normally write  to mean 
. As a default we take the set of weights
to be , the set of integers, both negative and positive. \boxHere
\end{defi}
A wLTS is called \emph{standard} whenever there is a cost function
 with the property that  if
and only if  for every .  So in a standard
wLTS there is a unique weight associated with external actions,
although internal actions may have multiple possible associated
weights, reflecting the different ways in which these actions may be
generated from external moves. The wLTS which we will (eventually)
generate for \picost will be standard, but the development below will
not require that we are working with standard wLTSs.

Relative to a given wLTS \emph{weak moves} are generated in the
standard manner, although the associated weights need to be
accumulated:  is the least relation satisfying:
\begin{enumerate}[]
\item  implies  

\item   implies 

\item   implies 
\end{enumerate}
We also use a variation on the standard notation  from  \cite{ccs};
when  is any action other than  this denotes  , but when it is 
 it means either that  or that  is  and .

\begin{defi}[Amortised weighted bisimulations]\label{def:amort}
  A family of relations  over the states in
  a wLTS is called an \emph{amortised weighted bisimulation} whenever :
\begin{enumerate}[(i)]
\item  implies  for some  such that
    

\item conversely, 
  implies  for some  such that
      \boxHere
\end{enumerate}
\end{defi}
\noindent
Here the parametrisation with respect to \nats puts an extra
requirement on the standard \emph{transfer properties} associated with
bisimulations. In (i) and (ii) above the index  must be in
\nats, that is must be non-negative. So for example if the
amortisation  is 0 then , the weight of the left hand action,
must be greater than or equal to , the weight of the right hand
action. For this reason a standard bisimulation, which ignores the
weights, may not be an amortised weighted bisimulation. But the more
general effect of the parameter  in the definition is to allow a
relaxation in the comparison between the actual weights of the
actions in the processes being compared; this point is explained in
detail in Example~\ref{def:amort.more}.

We can mimic the standard development of bisimulations and
write  to say that there is some amortised
bisimulation  such that .
Weighted bisimulations are (point-wise) closed under unions, and therefore we can
mimic the standard development of \emph{bisimulation equivalence}, \cite{ccs},
to obtain the following:
\begin{prop}\label{prop:amort.prop}\hfill
  \begin{enumerate}[\em(a)]
  \item The family of relations  is an 
amortised  weighted bisimulation.
  \item This family is the largest (point-wise) amortised weighed bisimulation.
  \item If  and  then  for some
         such that .
  \end{enumerate}
\end{prop}
\proof
Straightforward, using standard techniques.
\qed
When we are uninterested in the exact amortisation used we write simply
, meaning that there is some  such that ,
and we refer to this preorder as the \emph{amortised weighted bisimulation preorder}.
\begin{prop}\hfill
  \begin{enumerate}[\em(a)]
  \item  The relations  are reflexive 
  \item  implies 
  \item  whenever  . 
  \end{enumerate}
\end{prop}
\proof
In each case it is sufficient to exhibit a suitable amortised weighted bisimulation, that
is a suitable family of relations over states. For example to prove (b) we let
, for , be the set of pairs  such that
 and 
for some state  and some numbers  such that . 

To show  is an amortised weighted
bisimulation let us suppose  and ; we have to prove

(The proof of the symmetric requirement is similar.)
\begin{enumerate}[(i)]
\item From  we know  such that 


\item From , and the final part of the previous Proposition,
we know  such that 
.
\end{enumerate}
But since  we have
 and the requirement (\ref{req:1}) follows. 

The proof of part (c) is similar using the family of relations
, where  whenever  for some , while the proof of part (a) uses the family
where each  is the identity relation.

 \qed
\begin{exa}[Amortising costs continued]\label{def:amort.more}
  Here we continue with Example~\ref{ex:amort}. Shortly we will see a
  systematic way of associating weights with actions in \picost. But
  informally we can simply say

where  and  are abbreviations for the configurations 
, respectively,
, 
and analogously for . Then relative to this induced 
wLTS we can show that the following is a weighted bisimulation:

It follows that


However 

for any . To see this suppose  is a weighted
bisimulation; we prove by induction on  that

First notice that the pair  can not be in
; this is because the move 

can not be matched by a move

such that 

The only only possible candidate is the move

and  does not exist. 

From this fact it follows immediately that the pair
 can not be in ; 
for matching the move 

would require the impossible, that   be
. In other words we have shown (\ref{eq:fixup}) in the case 
when .

Suppose it is true for ; the proof that it follows for  is
also straightforward. This is because
\begin{enumerate}[]
\item for  to be in  we would
require that  be in 
which contradicts the induction hypothesis

\item for  to be in  we would
require   to be in , which we have
just shown not to be possible.
\end{enumerate}


It  is important that the set of natural numbers  is used in
Definition~\ref{def:amort}, or at least that the family of relations
be parametrised relative to a well-founded order. If instead we
allowed families of relations , where  is the
set of all integers, positive and negative, then

would follow. Simply letting 

for every , we would obtain an extended family of relations trivially
satisfying the requirements in Definition~\ref{def:amort}.
Indeed in general, using  in place of \nats, there would be no difference between 
amortised weighted bisimulations and standard bisimulations (where all weights are ignored). 
 \boxHere
\end{exa}



\subsection{An operational semantics for  \picost}

As a first step in applying the theory of \emph{amortised weighted bisimulations} to 
\picost we give an operational semantics for the language in terms of a 
(standard) LTS. 

In Figure~\ref{fig:lts} and Figure~\ref{fig:ltsB} we
give a set of rules for deriving judgements of the form
 
where  can take one of the forms 
\begin{enumerate}[(i)]
\item  internal action, 
\item input,  :  
input by resource  of  a known or fresh name, or value, where  is the provider
of the resource and  the user

\item output: : 
delivery of a known or fresh name, to resource , where again  
is the provider of the resource and  the user.


\end{enumerate}
We restrict attention to well-formed , that is, in the input and output actions
each  must occur somewhere in , and applications of the rules must preserve
well-formedness. 
However note that because \picost only uses unary communication the vectors 
 will have length either 0 or 1. 


The rules are inherited directly from the corresponding ones for Dpi,
\cite{dpibook}, and for the sake of clarity obvious symmetric rules, such as for 
\Rlts{comm} and \Rlts{cntx}, are omitted; \emph{Barendregt's convention}
is also liberally applied, for example in omitting side-conditions to
\Rlts{cntx}. The only point of interest is the use of the
preconditions  in \Rlts{in}
and \Rlts{out}; communication is only deemed to be possible if it can
be paid for in some manner. 
Note that  in \Rlts{in}, and
 in \Rlts{out} are free meta-variables. So for example the
simple process  can perform the actions

for every owner  such that .
Also in the communication rule \Rlts{comm} any new resources used in the communication,
 remain private but in general the resulting cost environment  
will be different from ; the internal communication involves the use of a resource,
and the change from  to  will reflect the associated costs. 

\begin{figure}[t]

\caption{An action semantics  for \picost: main rules\label{fig:lts}}

\hrulefill

\end{figure}
\begin{figure}

\caption{An action semantics  for \picost: more rules\label{fig:ltsB}}

\hrulefill
\end{figure}



We can perform a number of sanity checks on these rules. For example
one can show that if  then  for some  such 
that , for some , 
where  is the channel used in ; a more detailed analysis of the possible
judgements is given in the two lemmas below.
The actions also preserve configurations:
\begin{prop}
    If  is a configuration and 
 
then  is also a configuration. 
\end{prop}
\begin{proof}
  A straightforward induction on the inference of the judgements.
\end{proof}
We also have a consistency check with respect to the reduction semantics
of Section~\ref{sec:lang}, stated in the theorem below; the proof requires
two technical lemmas. 
\begin{lem}[Deriv-output]\label{lemma:derout1}
  Suppose .
Then
\begin{enumerate}[\em(i)]
\item  for some 
\item  \item 
\item 
\item   
whenever
, for any owner .
\end{enumerate}
\end{lem}
\begin{proof}
  By induction on the derivation of 
   .
\end{proof}

\begin{lem}[Deriv-input]\label{lemma:derin1}
  Suppose .
Then
\begin{enumerate}[\em(i)]
\item  for some 
\item  \item 
\item 
\item   
whenever
, for any owner , 
and types . 
\end{enumerate}
\end{lem}
\begin{proof}
  Again a straightforward induction on the derivation
.
Note that in part ({\emph v}) arbitrary types  can be used because there is no
restriction on the type   in the second part of the rule \Rlts{in} in 
Figure~\ref{fig:lts}. 
\end{proof}



\begin{thm}\label{prop:red.tau}
 if and only if
         for some 
    such that .
 \begin{proof}[(Outline)]

   First we need to show  the auxiliary result that structural
   equivalence is preserved by actions. That is  and  implies  for some  such that ; this
   is proved by induction on the proof of the fact that  from the rules in Figure~\ref{fig:structeq}. Then a
   straightforward proof by induction on the derivation of  from the rules in
   Figure~\ref{fig:reductions} will show that this implies  with ; the
   auxiliary result is required when considering the rule
   .

   To prove the converse we also employ the two previous lemmas, giving
   the structure of input and output actions. Suppose ; we prove by rule induction that
   . The only non-trivial case is
   when this judgement is inferred using the rule \Rlts{comm}, or its dual. So 
without loss of generality we know 
   \begin{enumerate}[]
   \item 
   \item 
   \item 
   \item 
   \end{enumerate}
The previous two lemmas can now be applied to obtain the structure of  and
, up to structural equivalence; by rearranging , again using the structural
equivalence rules, an application of \Rred{comm} followed by one of \Rred{struct} gives the
required 
 .
  \end{proof}
\end{thm}

\subsection{A proof methodology for  \picost}\label{sec:examples}

The operational semantics  given in the previous subsection 
can be used in a straightforward way to obtain a wLTS for \picost 
configurations. It suffices to attach a weight to the actions, which
can be done in a systematic manner: we write 

whenever 
\begin{enumerate}[]
\item  can be deduced
from the rules in Figure~\ref{fig:lts} and Figure~\ref{fig:ltsB}

\item 
\end{enumerate}
Note that the weight associated with an action is ultimately determined by the manner
in which expenditure is recorded in the cost environments; this may reflect the cost of
providing the resource in question, as in Example~\ref{ex:lib}, the profit to be gained
by a particular owner in the use of the resource, as in Example~\ref{ex:publishing}, or 
combinations of such concerns.  

We can now apply Definition~\ref{def:amort} to this wLTS  to obtain 
a family of preorders

between \picost configurations. However we must be somewhat careful here, as some of
the actions used involve bound names; but by a systematic application of \emph{Barendregt's
convention}, mentioned on page~\pageref{barendregt}, confusions between these and free names
can be avoided.

As is well-known, the relations (\ref{eq:amort.picost}) come equipped with a powerful co-inductive
proof methodology. In order to prove 

for a particular  it is sufficient to exhibit a family of relations 
 which satisfy the transfer properties of 
Definition~\ref{def:amort}, such that  contains the pair 
. 
In the remainder of this section we apply this proof methodology to the 
examples in Section~\ref{sec:lang}. This allows us to   now reason about the behaviour of
systems, how they  interact with other systems, rather than reason simply about their computation
runs. 


























































\begin{exa}[Running a library, revisited]\label{ex:libagain}
  Refering to the definitions in Example~\ref{ex:lib}, by exhibiting a witness weighted bisimulation it is
possible to show

This is despite the fact that the local use of the service  is
more expensive than the central use; this is compensated for by the
fact that both  and  are less expensive locally. It
is also worth noting that although the \emph{use} of resources in both
 and  is free, in the generated
wLTS the output actions actually have non-zero weights associated with
them. For example, a typical run in this wLTS from  takes the form

whereas the corresponding local run is 





To compare the efficiency of the library service itself we consider the following definitions

where, as explained in Example~\ref{ex:lib}, 
, are the types  respectively; here the interaction
between the library and the store has been internalised, with  types  reflecting the relative cost of
local and central access.  Both these configurations simply \emph{provide} the service 
, and viewed in isolation the local service is not more efficient than the central one; no matter what
 we choose, we have 

However if we combine the library service with the reader then the overall systems is locally more efficient
than the centralised one:

where

We should point out that in (\ref{ex:a}) and (\ref{ex:b}) we have used the full cost environments
, despite the fact that some of the resources have been restricted in
the systems; this is simply in order to avoid the definition of even more environments. 

As an example of how such statements can be proved see the Section~\ref{app:library} in the appendix for a witness bisimulation which
establishes (\ref{ex:b}).  
\boxHere
\end{exa}




\section{Contextual characterisation}\label{sec:cxt}

In the previous section we have demonstrated that the preorders
 provide a useful co-inductive methodology for comparing the
behaviour of processes, relative to resource costs.  In this section
we critically review its formulation, revealing some significant
inadequacies, and offer a revised version where these are addressed.

Informally we would expect at least the following two properties of
a proof methodology:
\begin{enumerate}[(a)]
\item 
It should support \emph{compositional reasoning}, whereby 
the analysis of process behaviour can be carried out structurally.

\item
\emph{Soundness:}
Any relationship established between the behaviour of processes using the proof methodology should be
justifiable in some independent manner.
\end{enumerate}
Further we could hope for:
\begin{enumerate}[(c)]
\item 
\emph{Completeness:} 
any pair of processes which are intuitively behaviourally related, should be provably related
using our methodology. 
\end{enumerate}

Relative to our language \picost the first criteria, (a), is straightforward 
to formalise, as a property of the preorders .

\begin{defi}[Compositional]\label{def:comp}
  A relation  over \picost configurations is said to be 
\emph{compositional} whenever
  implies 
 \begin{enumerate}[(i)]
 \item 

, provided 
 and  are configurations

\item .
\boxHere
\end{enumerate}

\end{defi}
We could of course  demand that  the relation  should be preserved by all
the  operators in the language, but for the purposes of the discussion to follow it is
sufficient to concentrate on the two most important ones. 

Our first remark is that the relations  are not compositional,
and therefore our proposed proof methodology does not support compositional reasoning. 

\begin{exa}[Non-compositionality]\label{ex:noncomp}
  Let  be a cost environment with two owners  and two resources .  Suppose further that , while ; the
  remaining fields in  are unimportant, but to be definite let us
say that  . Let  be
  another cost environment with the same resources, with both usage
  costs being , and the same  owners, but  with the difference that
  .  Then it is easy to check that

However one can also show that

The problem occurs when we consider the 
action

This can be matched by the action

but at the expense of exhausting all of 's funds.  is
now set to  and therefore the action 

can not be matched by any action from
.


\end{exa}

The other criteria, (b) and (c) above, are more difficult to formalise. But
even in the absence of a precise formalisation we can also show that
our proof methodology  runs into difficulties with them, by
considering a proposed touchstone family of preorders , which incorporate
some intuitive properties which we would expect.
First an easy
example, essentially taken from \cite{pityping}.
\begin{exa}[Problem with output types]\label{ex:types}
  Consider the two configurations  and , denoted by
  
 respectively, where the types  are different, and  has
  sufficient resources for  to be exercised; that is  for some owner  and some
  .

Then it is easy to see that 

for any  because the only actions which the configurations can perform are different;
they are labelled   and  
 respectively. 

However it is difficult to envisage any  context in which these two
configurations can be distinguished; for any reasonable definition of
the touchstone relations we would expect  to be
true.  Thus our proof methodology will not be \emph{complete}. \boxHere
\end{exa}
Our next example focuses on some of the novel features of \picost.
\begin{exa}[Problem with owner identification]\label{ex:own}
  Let  denote the configurations
  
respectively, where  are two different owners, 
and . 

Here again we would expect  to be true because
there is no mechanism in \picost which would enable an observer to discover
who was funding the use of the resource .  However assuming some owner 
has sufficient funds in  to provide the resource , we have

again because the configurations perform different actions, labelled
 and  respectively. \boxHere
\end{exa}

\subsection{Behavioural preorders}

In order to address the inadequacies with our proof methodology let us
first give one possible formalisation of the touchstone family of
behavioural preorders which we have been refering to as 
; we adapt the theory of
\emph{reduction barbed congruences}, \cite{ht92,pibook,pityping} to
\picost, often refered to informally as \emph{contextual equivalences}. 
For simplicity we assume that resource charging is always
standard, and that the only values used are channel/resource names.

We first need to introduce into the reduction semantics some record of the
costs being expended. Let us write 

whenever 

can be deduced from the reduction rules, in Figure~\ref{fig:reductions}, and 
. This is generalised in the obvious manner
to 

by the accumulation of costs. 

\begin{defi}
[Cost improving] We say that the family 
of relations
 over configurations
is \emph{cost improving} whenever 
 for any , then
\begin{enumerate}[(i)]
\item  implies  such that 
      

\item conversely,   implies  such that 
      .
\boxHere
\end{enumerate}
\end{defi}
\noindent
This is a natural generalisation of the notion of \emph{reduction closure}
or \emph{reduction bisimulation} from LTSs to weighted LTSs; for a justification
of its use in defining behavioural preorders see Chapter 2 of \cite{pibook}.

\begin{defi}
[Observations] 
Let us write  whenever
 where 
for some owner 
\begin{enumerate}[(i)]
\item , 
and  does not occur in 

\item  for some  and .
\end{enumerate}
The predicate  is defined in an
analogous manner.  Note that here the owner  has to be able to pay
the appropriate costs for the barb. 

Then we say that the family of relations
 over configurations \emph{preserves
  observations} whenever, for any ,  
 if and only if .
\boxHere
\end{defi}
\noindent
 Note
that unlike \cite{picost} we do not record the cost of making
observations; nor do we observe the owner responsible for the observation.
This means that our notion of barb is more elementary. 


Example~\ref{ex:noncomp} demonstrates that demanding a behavioural
preorder to be compositional, in particular that it be preserved by
arbitrary parallel contexts, is very problematic as intuitively it
gives observers or external users of a system access to all the funds available
to owners of the system. Here we address this issue by defining a relativised
version of compositionality, relativised to the set of owners whose funds are available 
to external users. 


\begin{defi}[-contextual]\label{def:contextual}
Let  be a subset of the owners . A relation 
 over \picost configurations is said to be 
\emph{-contextual} whenever
  implies 
\begin{enumerate}[(i)]
\item 
 for every 
 , provided 
 and  are configurations. 

\item .
\boxHere
\end{enumerate}
\end{defi}


\noindent
Combining these three properties we obtain:
\begin{defi}[The contextual improvement preorder]\label{def:cxtequiv}
  Let  be the largest family (point-wise) of 
   -contextual relations
  over configurations which preserves observations, and is  cost
  improving.\boxHere
\end{defi}
The idea here is that we only consider the behaviour of systems
relative to contexts in which observers, or users of the systems, can
use code running under the financial authority of the owners in
. At one extreme we can take  to be the entire set of
owners  and then observers have access to all owners, and
their funds; this gives Compositionality, as expressed in Definition~\ref{def:comp}. 
The other extreme is when observers have access to
none of the owners users in the systems under observation; in this
case the observers have to provide their own funds, to support
observations. 


We now set ourselves the task of modifying the proof methodology of
Section~\ref{sec:examples} so that the informal properties (a), (b), and (c) are
enforced, relative to the touchstone preorders .
First note that Example~\ref{ex:own} and
Example~\ref{ex:types} still apply when the informal relations
 are instantiated by the formal . But the problems 
presented in 
Example~\ref{ex:noncomp} depend on the choice of observers :

\begin{exa}[Unsoundness]\label{ex:unsound}
  Let  be as defined in Example~\ref{ex:noncomp}. Then we have already argued that

Here we argue that 

whenever . 
For otherwise, this would imply

for any process   which ensures that the configurations are still well-formed.  

However for a contradiction take  to be 

where  is some cost-free fresh channel. 
Then we can make the observation  on the left hand configuration but not on the
right hand one. 
\boxHere
\end{exa}

This example shows that in general -observers  can deplete the resources of any owner
in , which is important if those owners have only finite funds. A significant  consequence 
is given in the next proposition, which limits the applicability of this behavioural preorder for
arbitrary . 
\begin{prop}\label{prop:increase}
  If  for any , then
      for every  in . 
\end{prop}
\begin{proof}
  Suppose   for
  some , with  an owner in .   We prove that  
if and only if  .

  Consider the process , where  is a fresh cost-free channel, where
   is the resource type ; so  costs  to use but
  is free to provide.  Then by compositionality we know

where  denotes the trivial type . 

If   , we have 

and therefore, by the preservation of observations, 

But this is only possible if . 

The converse argument is similar. 
\end{proof}
In effect this means that the behavioural preorders 
can not be used to differentiate between configurations in which
owners from  accrue different levels of funds; a typical case
in point occurs with the systems in Example~\ref{ex:kickback}. For this
reason we are primarily interested in the extreme case, when the observers 
have no access to the funds of the owners in the systems under investigation. 
Let us introduce some special notation for these
situations.

Let  denote some arbitrary owner, intuitively taken to be external to the 
systems under observation.
For an arbitrary cost environment  we use  to denote the 
extended cost environment obtained by adding  to the domain of  
and setting  to be ; in particular  is only defined
whenever  is new to the domain of .   Finally we use the notation

as an abbreviation for

Here the observer has no access to the owners' resources used in the configurations  but has
an infinite amount of resources with which to run experiments. 
\leaveout{
The importance of these external owners is emphasised
by the following results:
\begin{prop}\label{prop:own1}
\qquad
\begin{enumerate}[\em(a)]
\item

  Let , where  and both
   are fresh. 
Then  if and only if .

\item

Suppose , where 
again  is fresh, and 
suppose further that
. Then 
 if and only if
.
\end{enumerate}
\end{prop}
\begin{proof}
  These statements are difficult to prove directly from the definitions, but are straightforward
consequences of the full-abstraction result, Theorem~\ref{thm:fa}. 
\end{proof}
The first result states informally that there is no need to have two external owners, while the
second means that in the presence of an external owner there is no need for the observer to have
access to any other owner with indefinite funds. These, taken together with Proposition~\ref{prop:increase},
means that there is limited use in considering observers with access to owners other than a single 
external one. For this reason we are mainly interested in the behavioural preorders 
. 
}


Our revised proof methodology is based on endowing \picost with the
structure of a different, more abstract, wLTS, which takes into account 
the set of owners whose funds are available to observers, and employing
Definition~\ref{def:amort} to obtain a more abstract family of
co-inductive preorders.
In order to obtain our more abstract wLTS we forget some
of the details in the labels of the actions of the operational
semantics for \picost, given in Figure~\ref{fig:lts} and
Figure~\ref{fig:ltsB}, so that they reflect not what processes can do,
but rather what external observers with access to the funds in  can observe them doing. 
This leads
to \emph{abstract labels} of the following form, ranged over by :
\begin{enumerate}[(a)]
\item internal label  as before

\item input label  

\item output label 

\end{enumerate}
Here only one owner is recorded in the external actions; for input we note 
the user of the resource  while for output it is the producer .

\begin{defi}[-actions]\label{def:aa}
  For each abstract label  let the corresponding -action  be defined by
\begin{enumerate}[(a)]

\item  whenever 
  
can be deduced from the rules, where .


\item 
  whenever    and  can be deduced from the rules for some
  , and some owner ,
where .


\item 
  whenever   and  can be deduced from the rules for  some owner ,
where .
\end{enumerate}
Note that in (a) the set of owners  plays no role, but we leave it
there for the sake of uniformity. \boxHere
\end{defi}

\noindent
This endows \picost configurations with the structure of a more
abstract wLTS, whose actions depend on the set of owners .  We
refer to this as the -wLTS and we write  whenever there is an amortised weighted bisimulation
 in this -wLTS such that .  When  is the singleton set 
where the owner  is fresh, that is  external to the
configurations being compared, we abbreviate this to .



\begin{exa}[Publishing, revisited]\label{ex:publishingagain}
Here we use the notation and definitions from Example~\ref{ex:publishing} and Example~\ref{ex:kickback}.

First we can compare the profits gained by running the publishing system in different
cost environments. As before  let  represent any cost environment of the
form 
, where these types are
 respectively, and let  be the same environment
but with these types changed to . Then it is straightforward to 
exhibit a witness bisimulation to establish

 Recall from Example~\ref{ex:publishing} that in these cost environments we record the costs of the
actions relative to their effect on the funds of  the publisher. So this means that 
that more profit can be gained by the publisher  by using the cost regime underlying the environment
.

To investigate the effect of implementing the \emph{kickback} we consider the two systems

Both these systems \emph{use} the  resource and \emph{provide} the  resource.
Here we can show, for example, that 

provided  is at least . See Section~\ref{sec:app.pub} of the appendix for a description of a witness
bisimulation. Again because of the way in which we have set up the accounting in the cost environments this means 
that the code  is more profitable for the publisher 
than . 
\boxHere 
\end{exa}

The abstract -wLTS has precisely enough information about
actions to characterise the touchstone contextual behavioural
preorder, at least in the extreme case of .
\begin{thm}[Full-abstraction, external case]\label{thm:externalfa}
   For every ,   if and only if 
  . 
\end{thm}
\begin{proof}
  This will follow from the more general full-abstraction result, given in Theorem~\ref{thm:fa}.
\end{proof}
Unfortunately this result is not true for an arbitrary set of external owners . 
Example~\ref{ex:unsound} can be used to show that the -wLTS has not taken into account the fact that 
observers have access to the funds of arbitrary owners in .

\begin{exa}\label{ex:unsound2}
  We use the notation from Example~\ref{ex:unsound}, which in turn is inherited from
Example~\ref{ex:noncomp}. Let  be a set of owners which includes  and the fresh .
Then it is easy to check that

But we have already argued in Example~\ref{ex:unsound} that 

\boxHere
\end{exa}
So we have to revise the -wLTS to take into account the access which observers may have to funds being used by
the systems under investigation. 
\begin{defi}[Fund transfer]\label{def:fundtransfer}
  For every  let  be the partial
  function over cost environments defined by letting  whenever  can be obtained from
   by transferring  funds from owner  to owner
  .  Formally this partial function is only defined when 
  , in which case  
  , when  and
  all other components of  are inherited directly from
  ; when  the operation leaves 
  unchanged.  This leads to a new action over configurations, with a
  new abstract label : we let
 
  whenever , and  are owners 
in , where 
 .
\boxHere
\end{defi}
This gives rise to yet another LTS whose states are \picost
configurations, which we refer to as -awLTS, which induces
another bisimulation preorder. But we also need to take
Proposition~\ref{prop:increase} into account.
\begin{defi}[Abstract weighted bisimulation preorder]\label{def:aamort}
  A family of relations over \picost configurations  is said to be a \emph{-abstract amortised weighted
    bisimulation} whenever
  \begin{enumerate}[(i)]
  \item  implies  for
every  in 

  \item  is an amortised weighted
    bisimulation in -awLTS. 
  \end{enumerate}
We write  to denote the maximal family of such relations. \boxHere
\end{defi}
Note that these relations  actually coincide with  when 
 is the singleton external observer ; this follows because the extra fund transfer actions
have no effect:

if and only if  .

It  also coincides with the preorders used in Section~\ref{sec:examples}, under certain conditions. 


\begin{prop}
Let  be the set of owners used in the two configurations
 and  and suppose that  all owners in  have
  indefinite funds; that is  
for every owner . Then
   implies
. 
\end{prop}
\begin{proof}
  Straightforward.  When funds are unlimited the constraint (i) in
  Definition~\ref{def:aamort} is vacuous, as is the requirement to
  match the fund actions labelled .  The result now
  follows because every concrete action in the wLTS used in Section~\ref{sec:examples}
   is automatically also an abstract action in -awLTS.
\end{proof}
It follows  that the work of Section~\ref{sec:examples}
has not been in vain; the proofs in the examples can be taken to be 
about the more abstract  preorders . 

The remainder of this section is devoted to showing that, subject to a
minor restriction, the co-inductive proof methodology based on
 satisfies the informal criteria (a),
(b), and (c) set out at the begining of this section. It has certain
advantages over that used in Section~\ref{sec:examples}; in matching
input and output moves the principles involved do not have to match
up exactly.  However in the general case it also has a disadvantage with
cost environments in which certain owners have finite funds. If the
observer has access to such owners then is necessary to establish that
the proposed relations between configurations are invariant under the
transfer of funds between them. Of course in the particular case of a
purely external observer, where  is taken to be ,
which is possibly the most interesting case, then this requirement is
vacuous.

\begin{defi}[Simple types] \label{def:simpletypes}
The type  is \emph{simple} whenever , 
meaning that resources of type  cost nothing to provide. 
A cost environment is called \emph{simple} whenever it can be written as
 where  is
a basic environment and all  are simple. 

Restricting attention to simple types we know that for every resource name
  there is some  such that 
 if and only if 
.
\boxHere
\end{defi}

\begin{thm}[Full-abstraction]\label{thm:fa} Assuming simple cost environments, for every 
set of observers  and 
every ,   if and only if 
  . 
\end{thm}
The proof of this result is the subject of the remainder of this section; we will
also see how the restriction to simple types can be lifted, at the expense of a
generalisation of the  fund action  from  Definition~\ref{def:fundtransfer}.

\leaveout{
Before embarking on the proof of Theorem~\ref{thm:fa} we should point out that it has
Proposition~\ref{prop:own1} 
as a direct corollary. For example, using the notation of that proposition, it is simple to
prove that 

if and only if

because every -action is a -action and vice-versa. 
Similar reasoning gives Theorem~\ref{thm:externalfa} as a corollary.
}

\subsection{Full abstraction}\label{sec:fa}

First let us consider criteria (a) above, Compositionality.  
In fact we now  have a parametrised version of this, -contextuality from
Definition~\ref{def:contextual}, which we tackle  in two steps.
First we require a lemma. 
\begin{lem}\label{lem:env.extend}\qquad
  \begin{enumerate}[\em(i)]
  \item   Suppose . Then 
  .

 \item Conversely, suppose ,
       where the label  does not describe a communication along the channel . 
       Then 
       \begin{enumerate}[\em(a)]
       \item 
       \item or the concrete action label  is of the form , in which case
        .
       \end{enumerate}
  \item 
   implies 


  \end{enumerate}
\end{lem}
\proof
   Each statement is  proved by induction on the derivation of the judgement. 
Note that for any  in the domain of , 
 if and only if 
 .\qed

\begin{prop}[-contextual]\label{prop:a.extend}
   implies .
\end{prop}
\proof
  Let  be the family of relations over \picost configurations
defined by letting
  
whenever  
\begin{enumerate}[(i)]
\item either 

\item or .
\end{enumerate}
It is sufficient to show that this satisfies the conditions in
Definition~\ref{def:aamort}. Note that condition (i) of this
definition is trivial.

So suppose  
and   is an abstract action. 
We have to find a matching abstract move
.  
Let us look at the concrete action underlying this abstract action,  . Since we know
   is a configuration  can not describe a communication along , 
and so we can apply part (2) of the previous lemma, to obtain two cases:
\begin{enumerate}[(a)]
\item . In this case the required matching move
can be obtained using the fact that , together with
an application of part (1) of Lemma~\ref{lem:env.extend}. 

\item  is the input action  , and  
. Here we again use 
the fact that 
 to find a matching weak concrete move from 
      labelled
 for some owner . 
Part (3) of Lemma~\ref{lem:env.extend}
can now be used to transform this into a required matching move from 
. In this case the matching will be because of clause (ii) in the 
definition of the family .\qed  
\end{enumerate}

\begin{thm}[-contextual]\label{thm:compositionProof}
  Suppose  and 
  are both configurations, where .  Then  implies .
\end{thm}
\begin{proof}
  We follow the standard proof structure, see Section 2.3 of
  \cite{pibook}, Proposition 6.4 of \cite{pityping}, Proposition 2.21
  of \cite{dpibook};  however the precise details are somewhat
  different.  Let  be the smallest family
  of relations which satisfies:
\begin{enumerate}[(i)]
\item 
 implies
 

\item 
 implies 
, whenever  and 
both   and 
  are  configurations

\item 
 implies 
.
\end{enumerate}
We show that this family satisfies the requirements of Definition~\ref{def:aamort}, up to structural
equivalence, from which
the result will follow.

First note that for any , 

This can be proved by induction on
why , with the base case being
provided by Proposition~\ref{prop:a.extend}.  

So suppose  and ; we have to find a matching abstract  move  such that ; the symmetric requirement, of matching a move from  by a corresponding one from , is treated in
an analogous fashion.

We proceed by induction on why ,
there being three cases, (i), (ii) and (iii) above, to consider.  In the first case
the requirement comes from 
Proposition~\ref{prop:amort.prop}. We concentrate on case (ii), where
we know 
  have the form  respectively,
where  
and we know by induction that 

We now examine why , and to start let us assume that  is the label
, where the reasoning is straightforward. 
This means, by definition, that   is ,  are in  and 
, which in 
turn implies ;
moreover incidently  and  must coincide, although this fact is not required here. 
By induction this can
be matched by an action 

such that 

This matching action can now be transformed into an action of the 
form 

which is easily seen to be the required matching abstract  move.  

Having disposed of this simple case we now know that 
there is a  derivation using the rules from
Figure~\ref{fig:lts}, Figure~\ref{fig:ltsB} of the underlying action

where , and   is the more
concrete version of the label .
If  is responsible for the concrete action (\ref{eq:move}), 
then a straightforward application of the induction hypothesis
will provide the required corresponding move. Suppose instead that  is
responsible, that is (\ref{eq:move}) takes the form

because ; here the reasoning
needs to be more involved. 
\begin{enumerate}[(a)]
\item First suppose this move is external, say an output with label
   being
   for some owner . 
Because we are actually matching -actions we know that this  is actually in . 

 Applying 
  Lemma~\ref{lemma:derout1} we know that  has the form
  , where .
The use of simple types means that  and  for some
, and standard resource charging implies that this  is actually . Thus we have
the external move

and  we know 
by induction  this move can be matched by some 

such that

This matching move actually has the form

with . 

An application of part (iv) of Lemma~\ref{lemma:derin1} or Lemma~\ref{lemma:derout1} gives the move

which can be combined with the pre- and post-  moves in (\ref{eq:move2}) to give

This is the required matching move since we know 

from which

follows by the remark (\ref{eq:extend}) above and the definition of the family .

When the label  in the move (\ref{eq:movePo}) above is an input the argument is very  much the same but
with an application of 
Lemma~\ref{lemma:derin1} in place of Lemma~\ref{lemma:derout1}; it is therefore omitted. 

\item



Now suppose the move from  we are examining is an internal move, taking the form
. Here we apply Theorem~\ref{prop:red.tau} and 
Proposition~\ref{prop:red}, which tell us that there are in principle three 
possibilities, (i), (ii)  or (iii). But an analysis of the proof will show that for processes of the form
 case (i) is actually the only possibility. 
Here   coincides with , implying  incidently that
. As we know  is a configuration we also get

and therefore that 

It is easy to now check that this is the required matching move, since by definition


\end{enumerate}

We are left with the possibility that the underlying action to be matched, (\ref{eq:move}) 
above, involves
communication and therefore takes the form

There are two cases, depending on whether  performs an input or an output. Let us consider the
latter, the former being similar but slightly easier. So we have

with  taking the forms  respectively, for some owner .  
By induction the first move, or rather its abstract version,  can be matched  because  is an owner in , giving 

for some owner , such that 

where . 
Note that the type of the extruded names, , may in general be different than the
types at which they were extruded by , and the owner  may also be different,
thereby a priori complicating matters when we try to combine this action with that from , 
in (\ref{eq:decompose})
above. 

However an application of part (ii) of Lemma~\ref{lemma:derout1}, gives 

and therefore from (\ref{eq:decompose}) and part (v) of Lemma~\ref{lemma:derin1} we get

This concrete move can now be combined with the concrete move (\ref{eq:move3}) to give the required matching
abstract move

\end{proof}
The attentive reader will have noticed that the restriction to \emph{simple} types
was necessary in order to be able to model the use of a resource by  the observers using actions
based on the transfer function 
, which records the transfer of
 funds, the cost of using the resource, from the user to the provider. 
If we drop the restriction  to \emph{simple types},  then the effect of using a resource is more complicated;
a certain amount will be debited to the user, while another  amount, possibly negative,
will be credited to the user. This can be accommodated by a more general transfer function
, leading in turn to a more general abstract arrow in
part (d) of Definition~\ref{def:aa}. With this adjustment compositionality can also be established
for arbitrary types. 

This contextual results leads in a straightforward manner to establishing the second informal criteria, (b):
\begin{thm}[Soundness]
   For every  and every set of owners ,  
  implies  .
\end{thm}
\begin{proof}(Outline)
  It is sufficient to show that the family of relations  satisfies the 
 three defining properties of the family of contextual equivalences. \emph{Cost improving} follows by
 definition, at least up to structural induction, in view of Theorem~\ref{prop:red.tau}, and  the two preceding
results establish -contextuality. The final property, \emph{Preservation of observations}, is also
straightforward, since, for example, the ability to observe  from a configuration coincides with its ability 
to perform some output action on the resource .  
\end{proof}

The final criteria (c), \emph{Completeness}, depends as usual on the ability to define contexts which
capture the effect of  each of the abstract -actions described in Definition~\ref{def:aa}. 
We first make this precise. 

\newcommand{\Csucc}{\cfn{succ}}
\newcommand{\Cfail}{\cfn{fail}}

We use two fresh cost-free resources,   to record the success or failure of
tests, and a third  for housekeeping purposes.
For any  we use   to denote  the cost environment  obtained by adding on these resources. 
Now let  be an abstract action which uses the bound names . Then we say  is definable
relative to 
if for every finite set of names  there exists a system   using only the owners from  such that
\begin{enumerate}[(i)]


\item if  and  then  where  and
  \medskip

\item conversely,  where  and  implies ,
  where , whenever .
\end{enumerate}

\begin{thm}[Definability]\label{thm:definability}
  All input, output and external actions are definable.         
\end{thm}
\begin{proof}(Outline)
  Let us look at two examples. First suppose that  is the label
 where  and  are both in ; 
here  is empty and the set of names  plays no role. 
The definition of  uses a variation on Example~\ref{ex:fund.transfer}. We use

where  is the type .  This ensures that whenever 
evolves at cost  to a configuration   such that   but 
then the newly generated resource  must have been used by  and provided by .
This is
only possible if  can evolve to a configuration in which a transfer of  can be made from
 to ; that is a configuration  such that  .
This in turns implies that we must have  for some 
configuration . Note the cost here is  because all of the resources used by the test 
are cost-free. 

For the second example consider the abstract output action label , where we know  is
in .  Here we let  be

where  is an abbreviation for a series of tests deciding whether or not  is in the finite set 
of names . Intuitively
whenever this is used in a cost environment  satisfying  this test will
fail only when  is instantiated by a fresh name.

Once more it is easy to say that the ability of  to evolve to a configuration
 satisfying  but  coincides with the ability
of  to do a weak concrete move labelled   for some owner  and type
. Moreover the cost of this weak concrete action will be exactly the same as the evolution from 
 , because the interactions with the test  is free. 
\end{proof}

\begin{thm}[Completeness]
   For every   and every set of owners ,   implies 
 .
\end{thm}
\begin{proof}(Outline)
  It suffices to show that the family 
  
satisfies the conditions  in Definition~\ref{def:aamort}.
Note that condition (i) is already established by Proposition~\ref{prop:increase}.
Now suppose

and 

We have to find a matching move from 

which is relatively straightforward because of Theorem~\ref{thm:definability}. As an example
suppose  is the output label  , and so  has the structure
 for some . 
Because of Compositionality we know 

Using the first part of the Definability Theorem we know that, up to structural
equivalence,


Using the properties of the family  this move must be matched by move
 
where 

Moreover we know 
 and  and so  the Definability theorem tells us that
 
where 
 
This would be the required matching move, if we had

whereas (\ref{eq:complete}) only gives us, up to structural equivalence,  

However the so-called \emph{Extrusion Lemma}, see  Proposition 6.7 of \cite{pityping} and Lemma 2.38 of \cite{dpibook},
can easily be adapted to \picost, to show that the required (\ref{eq:complete1}) does indeed follow from
(\ref{eq:complete2})
\end{proof}

\section{Conclusion}

In this paper we have developed a behavioural theory based on
bisimulations for a version of the picalculus, \picost, in which
\begin{enumerate}[]
\item resources have costs associated with them
\item code runs under the financial responsibility of owners, or principals
\item code can only be executed if the owner responsible for it can finance
the available transactions.
\end{enumerate}
The behavioural theory gives rise to a  co-inductive
proof methodology for comparing the costed behaviour of systems.  We
have demonstrated the usefulness of the methodology by treating some
examples, and we have offered at least a preliminary justification for
the theory in terms of contextual requirements, parametrised on sets of
owners. We have provided some evidence that the most appropriate theory 
emerges when this set of observers is taken to be some single external
observer, external to the owners funding the systems being investigated. 
In particular with this particular set of observers there is no need 
to consider the extra actions  when establishing 
bisimulations. 

The language could be extended in many ways without unduely affecting
the underlying theory.  Perhaps the most obvious extension would be
the introduction of \emph{ownership types}, to control which owners
can use which resources; this would help in the modularisation of
systems. One could also introduce a scoping mechanism for owners,
limiting the range within systems of their financial responsibility. 
One effect of such  extensions would be that owners would play
a much more significant role in the (abstract) actions on which
bisimulations are based. Such investigations we leave for future work. 

The language could also be extended with mechanisms whereby processes
could be aware of which owners are funding which resources, and more
importantly base their behaviour on such knowledge. More ambitiously
the semantics of the language could be generalised so that behaviour is 
now dependent on some  \emph{dynamic cost model}. There is considerable 
scope here for inventing more realistic cost models, whereby for example 
costs associated with producing/consuming resources could vary according to
\emph{market dynamics}. It is likely that a probabilistic setting would be
most appropriate for developing such models. 










The underlying theory of \emph{weighted bisimulations} also deserves
attention. For example it is not clear if the theory is decidable,
even for finite-state systems. More generally it would be interesting
to have techniques which would calculate the costs necessary to assign
to actions in order to ensure the equivalence of two systems.
There is already an extensive literature on \emph{weighted automata} \cite{wa}
and  decidability issues concerned with them, which may help in this regard.

\paragraph{Related work:} The research reported in the current paper
grew out of preliminary work reported in \cite{picost}. There a
language  was defined and also given a semantics
relative to \emph{cost environments}. But there are significant
differences.  At the language level the construct central to \picost,
, is absent in ; indeed in the latter
there is no representation of owners being responsible for specific
computations.  The cost environments used are also quite different; in
 funds are associated directly with resources,
which complicates considerably the reduction semantics as the resource
types need to be dynamic.  Here all funds are retained by owners,
which simplifies matters considerably, and this facilities the
introduction of \emph{charges} for resource usage and \emph{benefits}
for resource provision. Finally the behavioural theories are
different.  The concept of \emph{weighted bisimulation} is considerably
more flexible than the \emph{cost bisimulations} of \cite{picost}, as
the latter simply compares the relative cost of performing each
particular action.


\emph{Weighted bisimulations} are a direct generalisation of the
notion of \emph{amortised bisimulations} from \cite{astrid}; these
were originally defined for a version of CCS, \cite{ccs}, in which
only external actions have associated with them a cost. Nevertheless
we believe that our generalisation is significant, at least in that it
will make the concepts more generally applicable. However similar ideas
have a long history in the field of \emph{timed} process calculi; see
for example \cite{Tofts94}. A good survey of the use of
\emph{amortisation} for timed processes can be found in \cite{speed}.

Other resource-aware calculi have already appeared in the
literature. A typical example is the variant of \emph{mobile ambients}
\cite{ambients} from \cite{vladi} in which the resource in question is
\emph{space}, and the processes in the calculi have a \emph{bounded
  capacity} to host incoming ambients.  Another interesting example
may be found in \cite{teller:tcs04}, and related publications, which
develops a version of the picalculus in which unused
resources/channels may be garbage collected.  Of particular interest
to us is the general theory of \emph{resource-based} computation being
developed in \cite{pym}, and related publications. In future work we
hope to adapt their resource-based modal logic to \picost.


\appendix


\section{Some witness bisimulations}


\begin{figure}[t]
  


  \caption{Notation for library code}
  \label{fig:libcode}

\end{figure}

\subsection{The library}\label{app:library}

\newcommand{\BookN}{\ensuremath{\mathsf{BN}}\xspace}
\newcommand{\Books}{\ensuremath{\mathsf{BK}}\xspace}
\newcommand{\Deltadyn}{\Delta_{\scriptstyle dyn}}

Here we revisit the example on running a library, discussed in Example~\ref{ex:lib} and 
Example~\ref{ex:libagain}, and prove

by exhibiting a witness bisimulation.  For convenience we work up to
\emph{structural equivalence} and modulo -moves; essentially
these are moves which have no effect on the overall behaviour of
systems; see \cite{dpibook,groote} for details.  In \picost these include the actions  generated by the rules 
\Rlts{export}, \Rlts{unwind}, \Rlts{split}, \Rlts{match}, \Rlts{mismatch}.
Let us assume a set of book names \BookN, ranged over by  and a
set of books \Books, ranged over by . 

\begin{figure}[t]
  
  \caption{Library systems}
  \label{fig:libconfs}
\end{figure}


Let us write  whenever
\begin{enumerate}[(a)]
\item  has the form 
  
for some basic environment   



\item  has the form 
  
where again  is 
some basic environment. 

\item , with , for
every  in its domain. 
\end{enumerate}
So effectively  must be like  with perhaps a different 
record filed , and  must be like . 
Our witness bisimulation will contain pairs of
the form 

The allowed forms of  are described in Figure~\ref{fig:libconfs}, where for convenience we have omitted 
the explicit occurrence of the local types  after the first line. These in turn use 
notation given in Figure~\ref{fig:libcode} for the various processes.  
The allowed forms for  are identical  except for the use of the local types 
 in place of .

Let the family of relations over configurations  be determined by the following
constraints, where we assume in each clause that :

It is fairly straightforward, although tedious, to prove that
 satisfies the requirements of being  a weak
bisimulation in the wLTS of Section~\ref{sec:examples}, up to structural
equivalence and -moves. This is facilitated by the fact that
the code in each component of the pairs is identical.

Note that the configuration 

-reduces to a configuration of the form  and 

-reduces to one of the form , where ,  
and thus (\ref{ex:app.lib}) above follows. 

\subsection{The publisher}\label{sec:app.pub}



\begin{figure}[t]

  


  \caption{Notation for publisher code}
  \label{fig:pubcode}
\end{figure}



\begin{figure}[t]
  
  \caption{Publishing  systems}
  \label{fig:pubconfs}
\end{figure}


Here we revisit the publishing example developed in Example~\ref{ex:publishing}, Example~\ref{ex:kickback} and
Example~\ref{ex:publishingagain}; by exhibiting a witness bisimulation, again up to structural equivalence and 
-moves, we show that

subject to minor constraints on ; these constraints allow  to be finite. 
The systems  and , in addition to cost-free communications,
\begin{enumerate}[]
\item use resource ; in the definition of the cost environment from Example~\ref{ex:publishing} this is
recorded as a loss of 3, the cost of using . In the abstract wLTS we are using this loss is paid for by
the funds in , while it costs nothing to provide

\item provide resource ; in the cost environment this is recorded as a gain of , namely the difference between
providing it  and using it . Also this gain is added to the funds of .
\end{enumerate}
There are also internal communications which have costs associated with them, namely the use and provision of ; again
this is recorded as a loss of 2 which must be funded by . 

In order to describe the witness bisimulation we use the code abbreviations in Figure~\ref{fig:pubcode} and the  
system definitions in Figure~\ref{fig:pubconfs}. All environments we use have the form 
, and in order to fund the advertising we assume . 
In the witness bisimulation 
 all  are identical and this unique relation  is characterised by the following
constraints:

Here we use  to denote some set of news stories.

It is straightforward to show that this is indeed a weak amortised bisimulation in the abstract wLTS relative to the single
external observer . Since  -reduces to 
and  -reduces to , and 
, the required (\ref{ex:pub.provedagain}) above
follows. 

\section*{Acknowledgments}
The author would like to thank the referees for their very useful comments. 
\bibliographystyle{alpha}



\bibliography{buysell}
 



\end{document}
