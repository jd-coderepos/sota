\documentclass[a4paper]{article}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{graphicx} 
\usepackage{natbib}
\usepackage{fullpage}
\usepackage{authblk}
\usepackage{epstopdf}
\newcommand{\keyword}[1]{\textsf{#1}}
\newcommand{\comment}[1]{}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{claim}{Claim}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\newenvironment{proof}{{\bf Proof:}}{\hfill\rule{1.5mm}{3mm}\vspace{0.1in}}

\newcommand{\qed}{}
\begin{document}
\bibliographystyle{abbrv}

\title{A simpler load-balancing algorithm for range-partitioned data
  in Peer-to-Peer systems}
\author{Jakarin Chawachat\thanks{Corresponding author}}
\author{Jittat Fakcharoenphol}
\affil{Department of Computer Engineering\\
Kasetsart University\\
Bangkok Thailand
}

\maketitle
\let\thefootnote\relax\footnote{ This work has been partially supported by KU-RDI grant number Wor-Tor(Dor) 84.53.\\
\textbf{Email address:} cjakarin@gmail.com (Jakarin Chawachat), jittat@gmail.com (Jittat Fakcharoenphol)}
\begin{abstract}
  Random hashing is a standard method to balance loads among nodes in
  Peer-to-Peer networks. However, hashing destroys locality properties of
  object keys, the critical properties to many applications, more
  specifically, those that require range searching. To preserve a key
  order while keeping loads balanced, Ganesan, Bawa and Garcia-Molina
  proposed a load-balancing algorithm that supports both object
  insertion and deletion that guarantees a ratio of 4.237 between the
  maximum and minimum loads among nodes in the network using constant
  amortized costs. However, their algorithm is not straightforward to
  implement in real networks because it is recursive.  Their algorithm
  mostly uses local operations with global max-min load information.
  In this work, we present a simple non-recursive algorithm using
  essentially the same primitive operations as in Ganesan {\em et
    al.}'s work.  We prove that for insertion and deletion, our
  algorithm guarantees a constant max-min load ratio of 7.464 with
  constant amortized costs.
\end{abstract}

\newcommand{\minbalance}{{\sc MinBalance}}
\newcommand{\split}{{\sc Split}}
\newcommand{\splitmax}{{\sc SplitMax}}
\newcommand{\splitnbr}{{\sc SplitNbr}}
\newcommand{\nbradj}{{\sc NbrAdjust}}
\newcommand{\reorder}{{\sc Reorder}}
\newcommand{\adjload}{{\sc AdjustLoad}}

\section{Introduction}

One of important issues in Peer-to-Peer (P2P) networks is load balancing.
Load balancing is a method that balances loads among nodes in the
networks. In P2P networks, a standard technique usually used
to spread keys over nodes is hashing.  The research on the
construction of distributed hash tables (DHTs) is very active
recently. However, hashing destroys locality properties of keys. This
makes many applications difficult to support a range searching.

Ganesan, Bawa and Garcia-Molina~\cite{GanesanBGM04-vldb} proposed a
sophisticated load-balancing algorithm on top of linearly ordered
buckets. Since the ordering of keys is preserved, item searching is
simple and  range searching is naturally supported.  Their algorithm,
called the {\adjload} algorithm, uses two basic balancing operations,
{\nbradj} and {\reorder} with global max-min information, and can
maintain a good ratio of 4.237 between the maximum and minimum loads
among nodes in the network, while requiring a constant amortized work
per operation. We give the description of their algorithm in
Section~\ref{sect:GBGM}.



Although both operations are easy to state, the {\adjload} algorithm
is recursive; thus, it is not straightforward to implement in
distributed environments.  Also, in the worst case, the {\adjload}
algorithm does not guarantee the number of invoked balancing
operations, the number of updated data (partition change and load
information) and the number of affected nodes.  Since each balancing
operation may require global information, the number of global queries
may be higher than the number of insertions and deletions.

In this paper, we present a simpler, non-recursive load-balancing
algorithm that uses the same primitive operations, {\nbradj} and
{\reorder} as in Ganesan {\em et al.}, but for each insertion or
deletion, primitive operations are called at most once.  
This also implies that our proposed algorithm 
only makes queries to global at most once per insertion or deletion.  

As in Ganesan {\em et al.}, we prove that the ratio between the maximum
load and the minimum load, the imbalance ratio, is at most 7.464 and
the amortized cost of the algorithm is a constant per operation.

Our algorithm uses two high-level operations, {\minbalance} and
{\split}:  

\begin{enumerate}

\item {\bf The {\minbalance} operation} occurs when there is an
  insertion at some node  causing the load of  to be too high;
  in this case, we shall take the node  with the minimum load, transfer
  its load to one of 's neighbors with a lighter load, and let 
  share half the load with .

\item {\bf The {\split} operation} occurs when there is a deletion at
  some node  causing the load of  to be too low; in this case,
  we either let  take some load from one of its neighbors, or
  transfer all 's load to its neighbors and let it share half the
  load with the maximum loaded node.

\end{enumerate}

\textbf{Overview of the techniques.}  When considering only insertion,
the key to proving the imbalance ratio is to analyze how the load of 
neighbors of the minimum loaded node changes over time.  Let 
denote the lightly-loaded neighbor of .  The bad situation can occur
when  takes  entire loads of the minimum loaded nodes (at
various points in time) for too many times; this could cause the load
of  to be too high compared with the minimum load.  We show that this
is not possible because  each time a load is transferred to , the
minimum load is increased to within some constant factor of the load
of , thus keeping the imbalance ratio bounded.

We make an important assumption in our analysis of the insertion-only
case, namely, that the minimum load can never decrease.  For the
general case, this is not true.  We maintain the general analysis
framework by introducing the notion of phases such that within a
phase the minimum load remains monotonically non-decreasing.  To prove
the result in this case, we show that inside a phase, the imbalance
ratio is small; and when we enter a new phase (i.e., when the minimum
load decreases), we are in a good starting condition.


\textbf{Organization.} The remainder of the paper is organized
as follows. In Section~\ref{sec:relatedwork}, we discuss related
work. Section~\ref{sect:model} describes the model, states the basic
definitions and reviews the {\adjload} algorithm. In
Section~\ref{sect:algorithm-insertonly}, we consider the insert-only
case. We propose the {\minbalance} operation, analyze the imbalance
ratio and calculate the cost of the algorithm. In
Section~\ref{sect:algorithm-delete}, we consider the general case,
which has both insertion and deletion.  We propose the {\split}
operation that is used when a deletion occurs and analyze the imbalance
ratio and the cost of the load-balancing algorithm.

\section{Related work}
\label{sec:relatedwork}

Research on complex queries in P2P networks has long been an
interesting problem. It started when Harren {\em et
  al.}~\cite{Harren02complexqueries} argued that  complex queries
are important open issues in P2P networks. After that, much research has appeared on search methods in P2P networks. For more
information, readers are referred to the survey on searching in P2P
networks by Risson and Moors~\cite{Risson06Survey}.

Range searching is one of the search methods that arises in many fields
including P2P systems. Since most data structures for distributed
items are based on distributed hash tables (DHTs)~\cite{Kademlia02, CAN01,
  Pastry01,  Chord03, tapestry04}, early work focused mainly
on building range search data structures on top of DHTs, e.g.,
PHT~\cite{PHT2004} and DST~\cite{DST06}, based on binary search trees
and segment trees, respectively. These data structures do not address a
load-balancing mechanism when supporting insertion and deletion. Moreover,
hot spots may occur when loads are highly imbalanced.

There are other data structures for range searching in P2P networks,
which are not based on DHTs. SkipNet~\cite{SkipNet03}, which is adapted
from Skip Lists~\cite{skiplist90}, can support range searching or load
balancing but not both. Skip Graphs~\cite{Aspnes-SODA03} is also adapted from Skip Lists and
addresses on the range searching but it does not address on load balancing on the number of items per nodes.

Many data structures support efficient range queries and show a good 
load balancing property in experiments, e.g.,
Mercury~\cite{Mercury_sigcomm04}, Baton~\cite{baton05},
 Chordal graph~\cite{Joung08}, Dak~\cite{Dak06} and
Yarqs~\cite{Yarqs09}. However, they do not have any
theoretical guarantees on load distribution among nodes in their data
structures.

There are mainly two groups of researchers trying to address both range searching and
load-balancing theoretically. The former is the group of Karger and Ruhl~\cite{Karger03newalgorithms, 
Karger04simpleefficient}. The latter is the group of Ganesan and Bawa~\cite{Ganesan03} 
and Ganesan, Bawa and Garcia-Molina~\cite{GanesanBGM04-vldb}. 
Both of them use two operations. The first operation balances loads between two consecutive nodes 
by transferring the load from the node with higher load to the node with lower load. For the second operation, a node  
transfers its entire load to its neighbor and relocates its position to share load with 
a node  in a new position.


Karger and Ruhl~\cite{Karger03newalgorithms, Karger04simpleefficient} 
presented the randomized protocol, where each node chooses another node 
to perform a balancing operation at random.  Load balancing operations
should be performed regularly, even when there is no insertion or deletion
at the node.  More precisely, they showed that if each node contacts  
other nodes then the load of each node is between  and 
, where  denotes the average load and  is a 
constant with , with high probability, where the hidden constant
in the  notation depends on .  They also showed that
the cost of load balancing steps can be amortized over the constant costs of 
insertion and deletion.  Again, the constants depend on the value of .
We note that this implies a high probability bound of at least 4,096 for the imbalance ratio.


Ganesan and Bawa~\cite{Ganesan03} and Ganesan, Bawa and
Garcia-Molina~\cite{GanesanBGM04-vldb} proposed a distributed
load-balancing algorithm that works on top of any linear data
structures of items. Their algorithm is recursive and uses 
information about the maximum and minimum-loaded nodes.  They guarantee a
constant imbalance ratio with a constant cost per insertion and
deletion.  The ratio can be adjusted to .  This is much smaller
than that of Karger and Ruhl.  The major drawback is that their
algorithm requires  global knowledge of the maximum and 
minimum-loaded nodes.  
While this issue is important in practice (e.g., when building 
real P2P systems), the cost of finding global information 
can be amortized over the cost of other operations, e.g., node searching.
For completeness, we discuss how to obtain this global information in
Section~\ref{sect:p2p}.

\section{Problem setup, cost model and the algorithm of Ganesan {\em
    et al.}}
\label{sect:model}

In this section, we describe the problem setup, discuss the cost of an
algorithm and review the algorithm of Ganesan {\em et al.}, the
{\adjload} algorithm.

\subsection{Problem setup}

We follow closely the basic setup of~\cite{GanesanBGM04-vldb}.  The
system consists of  nodes and maintains a collection of keys. Let
 be the set of all nodes. The key space is partitioned into 
ranges, with boundaries . Let  be
the -th node that manages a range . For any node , let  be the number of keys stored in . At any point of
time, there is an ordering of the nodes. This ordering defines {\em
  left} and {\em right} relations among nodes and this relation is
crucial to our analysis.

As in previous work, in some operation, a node requires non-local
information, namely the maximum and minimum loads and the
locations of the nodes with the maximum and minimum loads.

When a key is inserted or deleted, the node that manages the range
containing the key must update its data.  After that, the
load-balancing algorithm is invoked. Our goal is to maintain the ratio
of the maximum load to the minimum load, called the imbalance ratio.
We say that a load-balancing algorithm guarantees an \textit{imbalance
  ratio}  if after each insertion or deletion of a key and the
execution of the algorithm,  for some constant .

We assume that, initially, each node has a small constant load, .
As in~\cite{GanesanBGM04-vldb}, we ignore the concurrency issues and
consider only the serial schedule of operations.

\subsection{The cost}

To analyze the cost of a load-balancing algorithm, we follow the three
types of costs discussed in Ganesan {\em et al.}. 

\begin{enumerate}
\item {\bf Data Movement.} Each operation that moves a key from one
  node to another is counted as a unit cost.
\item {\bf Partition Change.}  When load-balancing steps are
  performed, the range of keys stored in each node may change.  This
  change has to be propagated through the system so that the next
  insertion or deletion goes to the right node.  
\item {\bf Load Information.} This work occurs when a node requests
  non-local information, e.g., requesting the node with the
  minimum or maximum load.
\end{enumerate}

In this paper, we analyze the amortized cost of the load-balancing
algorithm, i.e., we consider the worst-case cost of a sequence of 
load-balancing steps instead of a single one.

As in Ganesan {\em et al.}, we first analyze a simpler model that
accounts only for the data movement cost.  For partition change cost and load
information cost, we assume that there is a centralized server which
maintains the partition boundaries of each node and can answer the
request for global information. 

This assumption can be removed as shown in Ganesan {\em et al.}.  For
completeness, we discuss this in Section~\ref{sect:p2p}.

\subsection{The algorithm of Ganesan {\em et al.}}
\label{sect:GBGM}

We briefly review the algorithm introduced
in~\cite{GanesanBGM04-vldb}, the {\adjload} algorithm. The algorithm
uses two basic operations, {\sc NbrAdjust} and {\sc Reorder}
operations, defined as follows.

{\sc NbrAdjust}: \textit{Node  transfers its load to its neighbor
  . This may change the boundary  of  and
  }.

{\sc Reorder}: \textit{ Consider a node  with an empty range
  .   relocates its position and
  separates the range of .  Then, the range  is managed by , whereas the range  is managed by  for some . Finally, rename nodes appropriately.}

For some constant  and , they define a sequence of
thresholds , for all , used to trigger the {\adjload} procedure described later.  When
, they call their algorithm the Doubling Algorithm.  
The {\adjload} procedure works as well when , the golden
ratio. They call their algorithm that operates at that ratio, the
Fibbing Algorithm. They prove that the {\adjload} procedure running on that ratio
would guarantee the imbalance ratio  of .

Given the threshold sequence, the {\adjload} procedure is as follows. When
a node 's load crosses a threshold , the load-balancing
algorithm is invoked on that node. Let  be the lightly-loaded
neighbor of . If the load of  is not too high, the {\sc
  NbrAdjust} operation is applied, following by two recursive calls of 
{\adjload} on  and . Otherwise, it checks the load of the
minimum-loaded node , and if the imbalance ratio is too high, tries to balance the
loads with the {\sc Reorder} operation as follows.
First,  transfers its load to its lightly-loaded neighbor .
Then, the {\sc Reorder} operation is invoked on  and , and
finally another call to the {\adjload} procedure is invoked on node .





\section{The algorithm for the insert-only case}
\label{sect:algorithm-insertonly}

In this section, we present the algorithm for the insert-only case.
This case is simpler to analyze and provides general ideas on how to
deal with the general case. It is also of practical interest because
in many applications, as in a file sharing, deletions rarely occur.

We present the {\minbalance} procedure which uses the same primitive
operations, the {\sc NbrAdjust} and {\sc Reorder} operations. However,
it is simpler than the algorithm {\adjload} of Ganesan {\em et al.}
Notably, the {\minbalance} procedure is not recursive and performs
only a constant number of primitive operations. We prove the bound on
the imbalance ratio of 7.464 and show that the
amortized cost of an insertion is a constant.

\subsection{The MinBalance operation}

After an insertion occurs on any node , the {\minbalance}
operation is invoked. If the load of  is more than  times
 the load of the current minimum-loaded node , node  transfers
its entire load to one of its neighbor nodes, which has a lighter load. 
After that,  halves the load of . We call these steps,  {\minbalance} steps.
Note that this procedure requires  information about the minimum
load; the system must maintain this information.

\begin{algorithm} {\bf Procedure} {\minbalance} 
  \begin{algorithmic}[1]
    \label{alg:minbalance}
    \STATE Let  be the minimum-loaded node in the system.
    \IF{} 
    \STATE //{\minbalance} steps 
    \STATE Let  be the lightly-loaded neighbor of . 
    \STATE Transfer all keys of  to . 
    \STATE Transfer a half-load of  to ,
    s.t.,  and .  
    \STATE \{Rename nodes appropriately.\}
    \ENDIF
  \end{algorithmic}
\end{algorithm}

\subsection{Analysis of the imbalance ratio for the insert-only case}

We assume the notion of time of the system in a natural way.  For
simplicity, we assume that each operation completes instantly.

For any time , let  and  denote the load of node
 after time  and right before time , i.e., 
for some , respectively.  Let  and  denote
the minimum load in the system after time  and right before time
 respectively, i.e.,  and .

We shall prove that the following invariant holds all the time.
\begin{quote} {\sc For any time , the load of any node is not over
     times the minimum load.}
\end{quote}
Note that the ratio of the maximum load to the minimum load is bounded by
, i.e.,  where 
is the maximum load at time .  We  prove this invariant in
Theorem~\ref{thm:maxload}.

\subsubsection{Overview of the analysis}

While the analysis is rather involved, the idea is not very difficult to understand.  
This section gives an short overview to the analysis.

The main idea of the analysis is to prove that the imbalance ratio
remains under a constant after any operation.  We assume that the system starts with a uniform 
load distribution.   We first show the key property for the insert-only case, that is,
the minimum load never decreases.  Then, we analyze how the insertions change the loads of the nodes.

When an insertion occurs on any node , there are two cases
depending on if  calls   {\minbalance} steps or not.  
After insertion, the bound on the load of  itself can be verified easily.

However, the insertion also affects two other nodes, i.e., 
the minimum loaded node  and its lighter neighbor .
When  {\minbalance} steps are invoked, the minimum loaded 
node  transfers its entire load to  and shares a half load of .   
While showing the bound on the load of  is pretty straight-forward,
the bound on  requires more analysis because 
may receive loads many times through out the execution of the algorithm. 
The harder case for showing the bound on  is when  repeatedly takes
loads from its neighbors without any insertions to .  However, in that case,
we know that 's neighbors at some point become the minimum loaded node;
thus, we can establish the bound on the load of  relative to the minimum load and
prove the required ratio.

\subsubsection{The analysis of the imbalance ratio}
First, we show an important property of the minimum load in
the system, i.e., after any operation, the minimum load never
decreases.
\begin{lemma}
\label{lem:minload_not_decrease} 
Suppose . Then the minimum load of the system never decreases.
\end{lemma}

\begin{proof}
  Inserting keys into the system only increases load.  The only steps
  that decrease loads are the  {\minbalance} steps; therefore, we
  consider only these steps.  For each {\minbalance} steps, there are
  three nodes involved, i.e., node  which initiates the 
  {\minbalance} steps at some time , the current minimum-loaded
  node  and node  which is the lightly-loaded neighbor of  at
  time .  First,  transfers its entire keys to ; hence 's
  load increases.  The new load of each of  and  is a half of
  's current load.  Since  invokes the  {\minbalance} steps, its
  load must more than .  Thus, we
  have that after the steps, 's load and 's load are at least 
  as required. \qed
\end{proof}

After an insertion occurs on any node , the load of   changes.
Next lemma guarantees a good ratio on node .

\begin{lemma}
\label{lem:insert-property} 
Consider an insertion occurring on node  at some time .  Suppose
. After an insertion and its corresponding
load-balancing steps, .
\end{lemma}

\begin{proof}
  After an insertion, we consider two cases.  The first case is when the
  {\minbalance} steps are invoked. After that the load of  decreases by half. 
  Note that the load of  after insertion cannot be over
   which comes from the invariant and a key
  insertion. Then, we have that
    
  For any , it follows that . 
  Hence, .
  From the non-decreasing property, we have .
  
  We are left to consider the second case when the {\minbalance} steps
  are not invoked.  From the algorithm, the load of  in this case
  is not over .  Because the minimum load never
  decreases, we have .
\end{proof}

Note that the {\minbalance} procedure ``sees'' the load of the newly inserted node
and the minimum load, while it ignores the load of node , the
previous neighbor of the minimum-loaded node. We define the
{\em min-transfer} event, i.e., we say that a min-transfer event occurs
on node , when the minimum-loaded node transfers its load to ,
its lightly-loaded neighbor. Most of our analysis deals with the load
of nodes suffered from this kind of transfer.

Consider a sequence of min-transfer events occurring on node .
Let  represent the time after the -th min-transfer event occurs
on . Note that before a min-transfer event occurs on , an insertion may
occur on it.  Next lemma shows that the load of  has a good ratio
in this case.

\begin{lemma}
  \label{lem:insert-between-min-transfer}
Suppose that an insertion occurs on node   at some time 
right before the -th min-transfer event occurs on . Then
.
\end{lemma}

\begin{proof}
  From Lemma~\ref{lem:insert-property}, after an insertion occurs
  on  at some time , . The load of 
  increases again when the -th min-transfer event occurs  at
  time .  Thus,
  
  Therefore, we have that  because of the non-decreasing property of the minimum load.
\end{proof}

As the result of Lemma~\ref{lem:insert-between-min-transfer}, later
when dealing with the load of node , we only have to consider the case
that no insertion occurs on  before a min-transfer event occurs
on it.

In our analysis, we categorize a min-transfer event into two types:
the {\em left-transfer} event and the {\em right-transfer} event. The
left-transfer event on  is a min-transfer event that  gets the
keys from the node, which is to the left of  (see
Figure~\ref{fig:1} (a)). The right-transfer event on  is
a min-transfer event that  gets the keys from the node, which is
to the right of  (see Figure~\ref{fig:1} (b)).

\begin{figure}
  \centering \includegraphics[width=0.35\textwidth]{1.eps}
  \caption{(a) The left-transfer event on z. (b) The right-transfer
    event on z.}
  \label{fig:1}
\end{figure}

When a new min-transfer event occurs on , there are two
situations, i.e., the new min-transfer event is the same type as the
previous min-transfer event and the new min-transfer event is the
other type.

The next lemma bounds the load of  when  min-transfer events of
the same type occur on  (probably not one after another).  Note
that, it is straightforward to show that the bound of 
but we need a better bound.


\begin{lemma}
  \label{lem:genneralizemintransfer}
  Suppose  and . Consider the -th, -th, ..., -th min-transfer
  events on . If the -th and  -th
  min-transfer events are of the same type, while the -th,
  -th, ..., -th min-transfer events are of type
  different from that of the -th and  -th events, then
  after the -th min-transfer event, .
\end{lemma}

\begin{proof}
  Without loss of generality, we assume that the -th and 
  -th min-transfer events occurring on  are the
  right-transfer event; and the -th, -th, ...,
  -th are the left-transfer event.  Let  be the
  minimum-loaded node at time .

  We first deal with the case that there exists an insertion occurring
  on  between the -th and  -th min-transfer events.
  Assume that the latest insertion occurs on  right before the
  -th min-transfer event where . From
  Lemma~\ref{lem:insert-between-min-transfer}, after the -th
  min-transfer event, the load of  is not over  times 
  the minimum load at time , i.e.,
	
  

  Since no insertion occurs on  after the -th min-transfer
  event, we have 
	
  
	
  Because the minimum load never decreases, it follows that
	
  

  and finally we have , because .
		
  We are left to consider the case that there is no insertion into 
  between the -th and  -th min-transfer events.  We
  make the first claim.
    
  \begin{claim}\label{clamin:1}
  
\end{claim}
\begin{proof}
  To prove the claim, we note that for any , the load
  of  right before the -th min-transfer event is equal to its
  load after the -th min-transfer event, i.e.,

    

  Also, for any , the load of  after the
  -th min-transfer event increases by the minimum load before time
  , .  Thus,

    

  and from Eq.~(\ref{eqn:l'_l}),

  

  Telescoping, we have
  
  The last step is from the non-decreasing property of the minimum
  load; and the claim follows.
\end{proof}


\begin{figure}
    \centering \includegraphics[width=0.50\textwidth]{2.eps}
    \caption{(a) The -th min-transfer event on z. (b) The node set
       between  and .}
    \label{fig:2}
  \end{figure}

  Now, consider the -th min-transfer event on . Recall that the 
  -th min-transfer event is a right-transfer event.  Let  be the node on
  the right of  right before the -th min-transfer event occurs
  on  (see Figure~\ref{fig:2} (a)).  Note that because the
  -th min-transfer event is a right-transfer event, 
  must become the minimum-loaded node at some point after . Let  be the
  time that  becomes the minimum-loaded node  after .
  Node  plays a crucial role in our analysis.
  
  There are two cases depending on  calls {\minbalance} steps or not.
  
  \textbf{Case 1:}  does not call {\minbalance} steps between time
   and .
  
  In the -th min-transfer event occurring on ,  transfers
  its entire load to  at time , but not . That means the
  load of  right before the -th min-transfer event is not over
  the load of , i.e., . Then, after
  time ,

  

  and from the Claim~\ref{clamin:1},
  
  
  After time ,  becomes the minimum-loaded node at  time .
  Note that  does not call the  {\minbalance} steps. Then, the
  event that may occur on  after time  is an insertion or a
  min-transfer event. Thus, 's load does not decrease. We have
  . Then,
  
  
  
  From the non-decreasing property of the minimum load, we have
   and when , it follows that .

  \textbf{Case 2:}  calls {\minbalance} steps between time 
  and .
  
  Let  be the latest time that  calls  {\minbalance}
  steps. Since {\minbalance} steps are invoked, some insertion must occur
  on . After that, 's load is over  times  the minimum
  load at time . Then, the load of  is divided into halves,
  i.e.,
  
  
  Note that after time ,  does not call {\minbalance} steps
  and it becomes the minimum-loaded node at  time . The event that
  may occur on  after time  is an insertion or a min-transfer
  event. Thus, 's load after time  does not decrease. Therefore,
  .  Moreover, we know that  by the non-decreasing property of the minimum
  load. Then,
  
    
 
  From the invariant, the load of  at time  is not
  over  times  the minimum load at time . We know
  that the minimum load cannot decrease; we have

  
  
    Consider the Claim~\ref{clamin:1}. We divide it by ,
  i.e.,

  
  
  By the non-decreasing property of the minimum load,
  . We have
  
 	
  and from Eq.~(\ref{eqn:1.8}) and~(\ref{eqn:1.10}),

  
  
  From the assumption that , it follows that
  . Then, we have
  
  \end{proof}

Using previous lemmas, we can conclude the bound on the load of 
after a min-transfer event occurring on it.

\begin{lemma}
  \label{lem:min-transfer}
  Suppose . After the -th
  min-transfer event occurs on , 
\end{lemma}

\begin{proof}
  We prove by induction on the number of min-transfer events occurring
  on .
  
  For the base case, the first min-transfer event occurs on .  If
  some insertion occurs on it before the min-transfer event, t
  from Lemma~\ref{lem:insert-between-min-transfer}, 
  . We are left to consider the
  case that no insertion occurs on  before the first min-transfer
  event.  The load of  before the min-transfer event is equal to its
  load at the beginning of the system, . Note that the minimum
  load at time  is also . After the first
  min-transfer event, . Thus, the load of  
   in both cases is not over .
    
  Assume that the load of any node at time  is not over . Consider the -th min-transfer event on
  . There are two cases.

  \begin{figure}
    \centering \includegraphics[width=0.75\textwidth]{3.eps}
    \caption{(a) the -th and -th min-transfer events are the same
      type. (b) the -th and -th min-transfer events are the same
      type but the -th min-transfer event is a different type.
      (c) the -th and -th min-transfer events are the same
      type but the -th min-transfer event is a different type.}
    \label{fig:3}
  \end{figure}

  \textbf{Case 1:} The -th and -th min-transfer events
  are the same type (see Figure~\ref{fig:3} (a)).  From
  Lemma~\ref{lem:genneralizemintransfer}, when set , after the
  -th min-transfer event, . 
  Thus, the lemma holds in this case.

  \textbf{Case 2:} The -th min-transfer event is a different type
  from the -th min-transfer event. If there is any insertion into
   between time  and , from
  Lemma~\ref{lem:insert-between-min-transfer}, 
  .  We consider the -th
  min-transfer event.  There are three sub cases.

  \textbf{Sub case 2.1:} There is no the -th min-transfer event;
  hence, the -th min-transfer event is the first min-transfer event. 
  We can bound the load of  after  like the base case,
  i.e., . The load of 
  increases again when the -th min-transfer event occurs on
  it at time , i.e.,
  
  From the non-decreasing property of the minimum load, we have that . Thus, the lemma
  holds in this sub case.

  \textbf{Sub case 2.2:} The -th min-transfer event is the same
  type as the -th min-transfer event (see Figure~\ref{fig:3} (b)).
  From Lemma~\ref{lem:genneralizemintransfer}, when set , after the
  -th min-transfer event, . The load of   increases again by the
  -th min-transfer event, i.e.,
  
   From the non-decreasing property of the minimum load,
  we have .  Thus,
  the lemma holds in this sub case.

  \textbf{Sub case 2.3:} The -th min-transfer event is a
  different type from the -th min-transfer event, i.e., the
  -th min-transfer event is the same type as the -th
  min-transfer event (see Figure~\ref{fig:3} (c)). From
  Lemma~\ref{lem:genneralizemintransfer}, when set ,  
  after the -th min-transfer event,  and thus, the lemma holds in this sub case.
\end{proof}

We are ready to prove the invariant. Note that a load of any node
may change from insertion or min-transfer event.  From
Lemma~\ref{lem:insert-property} and~\ref{lem:min-transfer}, we can
conclude the invariant, which guarantees the bound of any load in the
system.

\begin{theorem}\label{thm:maxload}
  Consider the insert-only case. Suppose . For any node , after any event at time
  , 
\end{theorem}
	
In our load-balancing algorithm, we want to minimize the number of
moving keys and to guarantee a constant imbalance ratio.  Imbalance
ratio, , is defined as the ratio of the maximum to minimum
load in the system. We show that the imbalance ratio from our
algorithm in the insert-only case is a constant.

\begin{corollary}\label{thm:Imbalance_ratio}
  Consider the insert-only case. Suppose . The imbalance ratio of the algorithm is a constant.
\end{corollary}

\begin{proof}
  Prove directly from Theorem~\ref{thm:maxload}.
\end{proof}

\subsection{Cost of the algorithm in insert-only case}
\label{sect:imbalanceratioproof}

Our algorithm uses two operations, i.e., insert and {\minbalance} operations.
 We consider the cost of each operation. Moving a single
key from one node to another is counted as a unit cost.  We follow the
analysis in~\cite{GanesanBGM04-vldb} based on the potential function
method, and use the same potential function.

\begin{theorem}\label{thm:amortized_cost_insertonly}
   Suppose that . The amortized costs of our algorithm in the insert-only case are
  constant.
\end{theorem}

\begin{proof}
  Let  denote the average load at time  and let  be
  the -th node that manages a range . We consider the
  same potential function as~\cite{GanesanBGM04-vldb}, i.e., , where  is a
  constant to be specific later. We show that the gain in potential
  when an insertion occurs is at most a constant and the drop in
  potential when a {\minbalance} operation occurs pays for the cost
  of the operation.

  \textbf{Insertion:} Consider an insertion of a key occurring on node
   at time  before any load-balancing steps are invoked. Note
  that, the load of all nodes except  does not change during the
  insertion. Thus, the gain in potential, , is

  	

  From the invariant,  . Since 
  , then
  . Hence, 
  
  	

  Since an insertion moves a new key to some node, the actual cost of an
  insertion is a unit cost. Thus, the amortized cost of an insertion is
  bounded by a constant.

  \textbf{MinBalance:} There are three nodes involved, i.e.,
   which calls {\minbalance} steps, the minimum-loaded node 
  and the 's lightly-loaded neighbor . When node  calls
  {\minbalance} steps,  transfers its entire load to . After
  that,  shares a half the load of .  The drop potential is

  	

  From the invariant, we have .
  Since  calls the  {\minbalance} steps, we know that
  . We have  .  Then, 

  

  Again, from the invariant, we have .  Then,

  

  The data movement of {\minbalance} steps is + .  For any  and , we
  have .  Thus, the data movement cost can be
  paid by this drop in potential.
\end{proof}


\section{The algorithm for the general case}
\label{sect:algorithm-delete}

In this section, we consider the general case that supports both insert and delete
operations. In order to deal with the imbalance ratio, after these operations,
load balancing steps are invoked. For insertion, we perform the
{\minbalance} operation presented in the previous section. On the other
hand, for deletion, we present the {\split} operation.

\subsection{The Split operation}

The {\split} operation is invoked after a deletion occurs on any node
. Let  be the lightly-loaded neighbor of . 
The load-balancing steps are called when the load of  is less
than  fractions of the maximum load at that time. There are
two types of load-balancing steps depending on the load of .  If
the load of  is more than  fractions of the maximum load,
 averages out its load with . We call these steps, the
{\splitnbr}. In other case,  transfers its entire load to .
After that,  shares a half load of the maximum-loaded node.  These
steps are called the {\splitmax}. Note that the {\splitnbr} calls
only the {\sc NbrAdjust} operation but the {\splitmax} calls both the
{\sc NbrAdjust} and the {\sc Reorder} operations.

We again note that to be able to perform these operations, the system
must maintain non-local information, i.e., the maximum load.

\begin{algorithm} {\bf Procedure} {\split} 
  \label{alg:split}
  \begin{algorithmic}[1]
    \STATE Let  be the maximum-loaded node in the system. 
    \IF {} 
    \STATE Let  be the lightly-loaded neighbor of . 
    \IF {} 
    \STATE //{\splitmax} steps 
    \STATE Transfer all keys of  to .
    \STATE Transfer a half-load of  to , s.t.,  and . 
    \ELSE 
    \STATE //{\splitnbr} steps 
    \STATE
    Move keys from  to  to equalize load, s.t.,  and .
    \ENDIF
    \STATE \{Rename nodes appropriately.\}
    \ENDIF
  \end{algorithmic}
\end{algorithm}

\subsection{Analysis of imbalance ratio for the general case}

We assume the notion of time and the invariant in the same way as the
previous section. We analyze the imbalance ratio after any event.
In previous section, we analyze the ratio after insertion and
min-transfer event. In this section, we have to deal with deletion
and two more events:
\begin{itemize}
\item The \textit{nbr-transfer} event on node  is the event that
  occurs when  receives load from its neighbor, which invokes the
  {\splitmax} steps, and
\item The \textit{nbr-share} event on node  is the event that occurs
  when  shares load with its neighbor, which invokes the
  {\splitnbr} steps.
\end{itemize}

Let  and  denote the maximum load in the system after
time  and right before time  respectively, i.e.,  and .

\subsubsection{Overview of the analysis}
The major problem for applying the proofs in the insert-only case to
the general case is the assumption that the minimum load cannot
decrease over time.  To handle this, we shall analyze the system in
phases.  Each phase spans the period where the minimum load is non-decreasing;
this allows us to apply mostly the same techniques to the analyze the situation 
when the update does not change the analysis phase.

The only way an update could cause phase change is when there is a deletion
in the minimum loaded node.  In that case, we show that if there is a deletion 
on the minimum loaded node that starts the phase change, the ratio between 
the minimum load and the maximum load is bounded by a constant.  This provides
the sufficient initial condition for the analysis of the next phase.

\subsubsection{Transition between phases}

We shall analyze the transition between two consecutive phases
occurring when the minimum load decreases. 

Consider a deletion occurring on
any nodes. Next lemma shows the load property of any node after
deletion occurring on it.

\begin{lemma}\label{lem:delete-property}
  Suppose . Consider the case that a deletion occurs on
  some node  at some time .  After deletion and its corresponding
  load-balancing steps, . Moreover, the minimum
  load can decrease in the case that  load-balancing steps are not
  invoked.
\end{lemma}

\begin{proof}
  After a deletion occurs on , there are two cases.  The first case is when 
  load-balancing steps are not invoked. In this case, the load of
   after deletion is more than .  Note that at time
  , the only event that occurs in the system is a deletion on .
  Then, the maximum load does not increase, i.e., . We have that .
  
  We are left to consider the second case when  load-balancing
  steps are invoked.  In this case, the load of  is not over
  . Let  be the lightly-loaded neighbor of
   at time . There are two sub cases.

  \textbf{Sub case 1:} Node  calls {\splitmax} steps.  First, 
   transfers its entire load to .  After that,  shares a half 
  load of the maximum-loaded node, i.e., 
  
  In this sub case, the node except 
     that its load increases at time  is . Note
  that,  receives load from , i.e., 
  
    From the assumption that ,  . Since the maximum load does not increase
  at time .  Then, we have .

  \textbf{Sub case 2:} Node  calls {\splitnbr} steps. This sub case
  occurs when . The load of  is shared to
   to balance their loads, i.e., 
  
  In this sub case, there are two nodes involved,  and .  Note that the only node in
  the system that its load increases at time  is .  We know that
  . Then, 's load
  after  load-balancing steps cannot over  because its load
  less than  and its received load cannot over
  .  Since the maximum load does not increase
  at time .  Therefore, we have .
  
  Consider the load of the minimum-loaded node after deletion occurring on it at time
  . When it is more than ,  load-balancing steps
  are not invoked. From the first case, the minimum load can decrease.
  When it is not over ,  load-balancing steps
  are invoked. From the second case, the load after load-balancing
  steps is more than . Thus, the minimum load does not
  decrease after deletion in this case.
\end{proof}


From Lemma~\ref{lem:delete-property}, the minimum load at time  can
decrease in the case that  load-balancing steps are not invoked.
After the minimum load decreases at time , we have
 and the phase changes.  Moreover, the following
condition holds:

At the beginning of each phase at time , the imbalance ratio
guarantee is , i.e.,


\subsubsection{Imbalance ratio inside each phase}
\label{sect:inside-phase}

We prove the same invariant in the previous section, i.e.,
\begin{quote} {\sc For any time , the load of any node is not over
     times  the minimum load,}
\end{quote}
holds after each operation.

At the beginning of each phase, the imbalance load
guarantee is .  At the end, we choose  
such that ; this implies that at the beginning of 
each phase, , as required.

In our analysis later on, we ignore the case of the deletion 
which is not followed with load-balancing steps, because 
the load of the affected can never violate the ratio.  Thus,
the events of this type shall not be considered in our analysis.

To analyze the imbalance ratio, we consider how the load of
each affected node changes. We deal with two easy events first.  
For insertion, we use Lemma~\ref{lem:insert-property} to guarantee 
the load of inserted node and  for deletion, we use 
Lemma~\ref{lem:delete-property} to guarantee the load of deleted node.
For the rest of this section, we are left with the node which effected
from  load-balancing steps.  There are three types of events, i.e.,
 nbr-transfer, nbr-share and min-transfer events.

We summarize the events and how to deal with them as follows.

\begin{itemize}
\item For the {\bf nbr-transfer events}, we focus on a
  lightly-loaded neighbor of the deleted node. It receives an entire load
  of the deleted node.  Lemma~\ref{lem:load-after-splitmax-splitnbr} deals
  with this type of events.
\item For the {\bf nbr-share events}, a lightly-loaded neighbor of the
  deleted node averages out its load with the deleted node. The imbalance
  ratio is also proved in
  Lemma~\ref{lem:load-after-splitmax-splitnbr}.
\item For the {\bf min-transfer events}, we focus on the load of a
  lightly-loaded neighbor of the minimum-loaded node. It receives load
  from the minimum-loaded node.  Lemma~\ref{lem:min-transfer-general}
  deals with this type of events.
\end{itemize}

The next lemma handles the case of  nbr-transfer and nbr-share
events.

\begin{lemma}
  \label{lem:load-after-splitmax-splitnbr}
  Suppose  and . Consider the case that a deletion occurs on node
   at some time  and  calls  load balancing steps. Let 
  be the lightly-loaded neighbor of  at time . Then
   and .
\end{lemma}

\begin{proof}  
  There are two types of load balancing steps after deletion.

  \textbf{Case 1:} Node  invokes {\splitmax} steps and a
  nbr-transfer event occurs on .  This case occurs when
   and . Node 
  proceeds by transferring its entire load to , i.e., 
   
  From the invariant, we have .  Since , it follows that .  Then,
  the load of  at time  is not over . From
  the non-decreasing property of the minimum load, we have
  .  
  
  After that,  shares half a load
  of the maximum-loaded node. From the invariant, we have that
  . When , it follows that
  .  Then, the load of  after deletion is
  not over  and  we have  from the non-decreasing property of the minimum load.

  \textbf{Case 2:} Node  invokes {\splitnbr} steps and a
  nbr-share event occurs on . This case occurs when  and .  From the invariant,
  we have . Node 
  and  share their loads equally, i.e., 
  
  From the assumption that  and , we have that .  
  Moreover, when  and , it follows
  that .  Then, the load
  of  and  after load-balancing steps are not over . From the non-decreasing property of the minimum load, we have
   and .  
\end{proof}


We are left with the min-transfer case. Let  be the min-transfer
event occurring on . Next lemma deals with the case that  is the
first event occurring on  in phase .

\begin{lemma}
  \label{lem:minimum-decrease}
  Consider any phase . Suppose . If the first event
  occurring on  in that phase is the -th min-transfer event, 
  
\end{lemma}

\begin{proof}
  There are two cases to consider.
  First, we consider the case that , i.e., the first phase.
  At the beginning of this phase, the load of any node is equal to . 
  Note that the load of  does not change until the first min-transfer event occurs on it.
  Moreover, at time , the minimum load is
  also  because it cannot decrease and it cannot increase over . 
  When the min-transfer event occurs on , it's load increases, i.e.,
  . From the
  non-decreasing property of the minimum load, we have 
  . From the assumption that , it follows that
  .
	  
  For the case that , let  be the beginning time of phase
  . From the load condition at the beginning of each phase,
   . Therefore, . 
   After the -th min-transfer event occurs on , its load increases,
  i.e., .  Because the minimum load never decreases in each phase,
  we have   as
  required.
\end{proof}

Now, assume that  is not the first event occurring on
 in phase .

Let  be the latest event that occurs on  before an event . The
next lemma considers the case where  is not a min-transfer event,
while Lemma~\ref{lem:genneralizemintransfer2}, which is more involved, considers the case when
 is a min-transfer event.

\begin{lemma}
  \label{lem:event-before-min-transfer}
  Consider any phase. Suppose  and . If any event  except a min-transfer event occurs on
  node  right before the -th min-transfer event, then after the
  -th min-transfer event occurs on , 
\end{lemma}

\begin{proof}
  An event  can be an insertion, or a deletion which is followed with
  load-balancing steps, or  an nbr-transfer event, or an nbr-share event.  
  After event  occurs on  at time ,
  from Lemma~\ref{lem:insert-property} (for insertions) and
  Lemma~\ref{lem:load-after-splitmax-splitnbr} (for other events), we have
  . The load of  increases again
  from  the -th min-transfer event, i.e.,
  . Because the minimum load does not
  decrease in each phase, it follows that .
\end{proof}

Finally, we consider the case when the latest event  before event
 is a min-transfer event.  Recall that we categorize the
min-transfer event into two types: the left-transfer event and the
right-transfer event.  The next lemma is a generalization of
Lemma~\ref{lem:genneralizemintransfer} but it deals more with
deletion, {\splitmax} and {\splitnbr}.

\begin{lemma}
  \label{lem:genneralizemintransfer2}
  Suppose ,
   and . Consider the -th,
  -th, ..., -th min-transfer events on  in
  any phase. If the -th and -th min-transfer
  events are of the same type, while the -th, -th, ...,
  -th min-transfer events are of type different from that of
  the -th and -th events, then after the -th
  min-transfer event, .
\end{lemma}

\begin{proof}
  Without loss of generality, we assume that the -th and 
  -th min-transfer events occurring on  are 
  right-transfer events; and the -th, -th,
  ..., -th are  left-transfer events. Let  be the
  minimum-loaded node at time .
 
  We first deal with the case that there exists an event except the
  min-transfer event occurring on  between the -th and
   -th min-transfer events. Assume that the latest
  event except the min-transfer event occurs on  right before the
  -th min-transfer event where . From
  Lemma~\ref{lem:event-before-min-transfer}, after the -th
  min-transfer event, we have
  
  
  After the -th min-transfer event, only the
  min-transfer event can occur on .  Note that after time ,
  there are at most  min-transfer events occurring on  at
  time . Since, the minimum load never decreases, we have
  that
  
  

  and finally we have , because .
  
  We are left to consider the case that there is no other events
  occurring on  except the min-transfer event between the -th
  and -th min-transfer events. We follow Claim~\ref{clamin:1} in the proof
  of Lemma~\ref{lem:genneralizemintransfer} using the property that in
  each phase the minimum load does not decrease. Then, we have
  
  

  Consider the -th min-transfer event on . Recall that, it is a
  right-transfer event. Let  be the node on the right of 
  right before the -th min-transfer event.  Note
  that, because the -th min-transfer event is also
  a right-transfer event,  must become the minimum-loaded
  node at some point after time .  Let  be the time that  becomes the minimum-loaded
  node after time .
 
  Instead of focusing on node , we consider a set of nodes 
  that arranges in a consecutive order from  to  between
  time  and  (see Figure~\ref{fig:2} (b)). We 
  bound the load of  by the load of node in this set. There are two
  cases.

  \textbf{Case 1:} No nodes in set  calls {\minbalance},
  {\splitmax} and {\splitnbr} steps between time  and
  . In this case, we consider the node . Note that deletion may occur on .  
  There are two sub cases.

  \textbf{Sub case 1.1:} No deletion occurs on  after .
  Consider the -th min-transfer event occurring on . The minimum-loaded
  node at time  transfers its load to . That means
  . Then, we have


and from Eq.~(\ref{eqn:5}), we have



After time , deletion and load-balancing steps do not occur on
.  The operation that can occur on it is an insertion. Then, 's
load does not decrease.  At time ,  becomes the minimum-loaded
node. Then, .  From Eq.~(\ref{eqn:6}), we
have



Because the minimum load does not decrease, we have . When , we have
. Thus, the
lemma holds in this sub case.

\textbf{Sub case 1.2:} Some deletion occurs on  after  but
{\splitmax} and {\splitnbr} steps are not invoked. Let  be the
time that  has the minimum load after deletion occurring on it
between time  and . From Lemma~\ref{lem:delete-property},
the maximum load at time  is not over  times  the load of
 at time .  Then, we have


 Note that the only event that can occur on  between time 
 and  is a min-transfer event. Thus, the load of  after 
 does not decrease. Then, we have . Consider
 Eq.~(\ref{eqn:5}). We have

 

 From Eq.~(\ref{eqn:max_time_t}), we have 
  
 Since in each phase, the minimum load never
 decreases, we have . From the assumption that , it follows that
  and thus, the lemma holds in this sub case.

 \textbf{Case 2:} At least one node in  calls {\minbalance}
 or {\splitmax} or {\splitnbr} steps between time  and
 .  Let  be the latest node in this set that calls 
 load-balancing steps at time .  We consider the case that
 some deletion occurs on  after . We can prove in the same
 way as sub case 1.2 and it follows that .
       
 We are left to consider the case that no deletion occurs on  after
  {\minbalance} or {\splitnbr} or {\splitmax} steps occurring on 
 after .

 \textbf{Sub case 2.1:} Node  calls {\minbalance} steps at time
 . This sub case can be proved in the same way as case 2 in
 Lemma~\ref{lem:genneralizemintransfer}. When ,
 it follows that 
 Thus, the lemma holds in this sub case.

 \textbf{Sub case 2.2:} Node  calls {\splitnbr} steps at time
 . From Lemma~\ref{lem:delete-property}, after {\splitnbr}
 steps, we have .  Note that
 the event that occurs on  after  is the min-transfer
 event. Then, 's load does not decrease after . We have
 . Consider Eq.~(\ref{eqn:5}). Then, it follows that

  

  After time , no load-balancing steps or deletion occurs on .  Then,
 after , 's load never decreases.  Since the -th 
 min-transfer event is a right-transfer event,  must become the 
 minimum-loaded node at some point.  Let  be
 the time that  becomes the minimum-loaded node. 
 It follows that
 .  Then, we have
 . When
 , it follows that  and
 thus, the lemma holds in this sub case.

 \textbf{Sub case 2.3:} Node  calls {\splitmax} steps at time
 . After  calls these steps, it transfers its entire load
 to its neighbor . Then, we have . After
 that,  is relocated. Thus, we consider node  instead. 
 
 We show that  is in . Assume by contradiction that  is not in .
 Note that the position of  can be left or right of .
 Consider the case that  is right of .  can be outside  when 
  must be the rightmost node in . Because  is the rightmost node 
 in , this case contradicts. Consider the case that  is left of . 
 In this case,  must be the leftmost node in  and  transfers its load to the node
 outside . Note that the node which  transfers its load is .
 This contradicts that no events occur on  except the min-transfer event.
  
 Consider the case that some
 deletion occurs on  after . This case can be proved in the same
 way as sub case 1.2.

 Now, we assume  that no deletion occurs on  after
 .  Recall that at time , we have .  Since the -th
 min-transfer event is a right-transfer event,  becomes the
 minimum-loaded node at some point after . Let  be the time that 
 becomes the minimum-loaded node after .  After time
 , load-balancing steps and deletion do not occur on .  Then,
  's load does not decrease.  We have
 .  Moreover, we have
  from the non-decreasing property
 of the minimum load.  Thus, .

 Consider Eq.~(\ref{eqn:5}). We divide it by ,
 i.e.,  

 From the invariant, it follows that  when
 . Recall that .
 Then,


When , it follows that . Then, we
have  Thus,
the lemma holds in this sub case.
\end{proof}


From Lemma~\ref{lem:minimum-decrease},
~\ref{lem:event-before-min-transfer}
and~\ref{lem:genneralizemintransfer2}, we conclude the effect of the
min-transfer event on any node . We omit the proof because it is
similar to the proof of Lemma~\ref{lem:min-transfer}.

\begin{lemma}
  \label{lem:min-transfer-general}
  Consider any phase .  Suppose  and . After the -th min-transfer event occurs on
  , 
\end{lemma}

Finally, we are ready to prove the imbalance ratio guarantee. In each
phase, the load of any node can be changed by insertion, deletion,
nbr-transfer, nbr-share and min-transfer events.  From
Lemma~\ref{lem:insert-property}, \ref{lem:delete-property},
\ref{lem:load-after-splitmax-splitnbr}
and~\ref{lem:min-transfer-general},  we can conclude the upper bound of
load of any node in any phase after these events.

\begin{theorem}\label{thm:maxload2}
  Consider any phase. Suppose  and . For any node , after any event at time
  ,  Thus, the imbalance ratio
  of the algorithm in the general case is a constant.
\end{theorem}	

\subsection{Cost of the algorithm in the general case}
\label{sect:imbalanceratioproof2}

We analyze the cost of our algorithm in the general case. Recall that, the
cost of moving a key from node  to another node  is counted as a unit
cost. In our algorithm, there are four operations, i.e., insertion,
deletion, {\minbalance} and {\split}. Again, we prove the amortized
cost by potential method and use the same potential function of
Ganesan {\em et al.}.

\begin{theorem}\label{thm:amortized_cost} 
 Suppose .  The amortized costs of our algorithm are constant.
\end{theorem}

\begin{proof}
  We use the  potential function in~\cite{GanesanBGM04-vldb}, i.e., , where  is the
  average load at time  and  be the -th node that manages
  a range . We show that the gain in potential
  when insertion or deletion occurs is at most a constant and the drop
  in potential when {\minbalance} or {\split} operation occurs pays
  for the cost of the operation. These imply that the amortized costs
  of insertion and deletion are constant.

  We prove the cost of insertion and {\minbalance} operation in the
  same way as Theorem~\ref{thm:amortized_cost_insertonly}. We are left
  to consider a deletion and {\split} operation.

{\bf Deletion}: When a deletion occurs on  at time , the
gain in potential is at most



  We know that . From the invariant, we have that
   for any node .  Using the
  fact that  where  and
  , we have

  

  Hence, the amortized cost of deletion is a constant because the actual cost
  of deletion is a unit cost.

  {\bf Split}: Consider the load of node , whose calls {\split}
  at time . When its load is less than , 
  load-balancing steps are called.  There are two cases, i.e.,
  {\splitnbr} and {\splitmax} steps.

  {\bf Case {\splitnbr}:} Let  be the lightly-loaded neighbor of
   when  calls {\splitnbr} steps. Node  moves its keys
  to  to balance their loads.  The drop in potential is
    
  
  This case occurs when
   and . Then,
  

  The number of moved keys when {\splitnbr} steps are invoked is
  . For any , we have
  .  Thus,
  the drop in potential pays for the data movement.

  {\bf Case {\splitmax}:} Node  transfers its entire load to its
  adjacent node  and then shares half the load of the
  maximum-loaded node .  The drop in potential is

    

From the algorithm, we know that 
and . Then,


When {\splitmax} steps are invoked, the number of moved keys is
. For any
, it follows that  and thus, the drop in potential pays for the key movement.

Thus, the amortized costs of the algorithm are constant.
\end{proof}

\section{The cost in real networks}
\label{sect:p2p}

In this section, we discuss how Ganesan {\em et
  al.}~\cite{GanesanBGM04-vldb} dealt with  global information and,
again, discuss the comparison between this line of work, which this
paper extends, and the work of Karger and
Ruhl~\cite{Karger03newalgorithms, Karger04simpleefficient} when
considering real networks.

In the P2P networks, there is no centralized server to
provide the information.  If any node requires information about another
node, it must send  messages to that node.  Besides the data
movement cost, there is another cost to be considered, the
communication cost.  The communication cost is defined as a number
of messages that required for complete the operation.

We shall discuss how Ganesan {\em et al.} implement the idea on real
networks.  Their implementation is based on skip
graphs~\cite{Aspnes-SODA03}.  Skip graphs support find operation,
node insertion, and node deletion with  messages with high
probability.  Also adjacent nodes can be contact with  messages.
Ganesan {\em at al.}  use two skip graphs: one where nodes are
ordered by their minimum key in their ranges; another where nodes are
ordered by their loads.  Therefore, global information can be found
with  messages, and each partition change costs at most
 messages.  We note that while this cost is more than the
constant cost of data movement, usually  messages are
required for finding the node for each key, and thus these cost can be
amortized with the searching cost.

As in Ganesan {\em et al.} works, Karger and
Ruhl~\cite{Karger03newalgorithms, Karger04simpleefficient} simplify
the cost model by not considering how one could find a given node in
the system.  Therefore, unless they maintain a global directory of
nodes, using known data structures for p2p systems, they still need
 messages as well.

\bibliography{reorder}
\end{document}
