
\documentclass{article} \usepackage{iclr2021_conference,times}

\usepackage{amsmath,amsfonts,bm}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{adjustbox}
\usepackage{amsthm}


\renewcommand{\arraystretch}{1.3}
\newcommand{\mset}[1]{\left\{\kern-.5em\left\{ #1 \right\}\kern-.5em\right\}}
\newcommand{\mmset}[1]{\{\kern-.4em\{ #1 \}\kern-.4em\}}

\newcommand{\salpp}{SAL}
\newcommand{\sal}{SAL}

\newcommand{\bell}{\mathrm{b}}
\newcommand{\norm}[1]{\left\Vert#1\right\Vert}
\newcommand{\Norm}[1]{\lvert \! \lvert \! \lvert #1 \rvert \! \rvert \! \rvert}
\newcommand{\abs}[1]{\left\vert#1\right\vert}
\newcommand{\babs}[1]{\Big \vert#1 \Big \vert}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\parr}[1]{\left (#1\right )}
\newcommand{\brac}[1]{\left [#1\right ]}
\newcommand{\ip}[1]{\left \langle #1 \right \rangle }
\newcommand{\Real}{\mathbb R}
\newcommand{\Nat}{\mathbb N}
\newcommand{\Complex}{\mathbb C}
\newcommand{\eps}{\varepsilon}
\newcommand{\too}{\rightarrow}
\newcommand{\bbar}[1]{\overline{#1}}
\newcommand{\wt}[1]{\widetilde{#1}} \newcommand{\wh}[1]{\widehat{#1}} \newcommand{\diag}{\textrm{diag}} \newcommand{\off}{\textrm{off}} \newcommand{\din}{d_{\scriptscriptstyle{\textrm{in}}}} \newcommand{\dout}{d_{\scriptscriptstyle{\textrm{out}}}} 

\newcommand{\trace}{\textrm{tr}} \def \bfi{\textbf{\footnotesize{i}}} \newcommand{\one}{\mathbf{1}}
\newcommand{\zero}{\mathbf{0}}
\newcommand{\vcc}[1]{\mathrm{vec}(#1)}
\newcommand{\mat}[1]{\bm{[} #1 \bm{]}}\newcommand{\loss}{\mathrm{loss}}\newcommand{\recloss}{\mathrm{loss}_{\text{R}}}\newcommand{\supp}{\mathrm{supp}}
\newcommand{\yl}[1]{{\color{magenta}{\bf[Yaron:} #1{\bf]}}}
\newcommand{\hb}[1]{{\color{red}{\bf[Heli:} #1{\bf]}}}
\newcommand{\op}[1]{{\color{blue}{\bf[Omri:} #1{\bf]}}}

\def \etal{{et al}.}
\newcommand{\eg}{{e.g.}}
\newcommand{\ie}{{i.e.}}









\newtheorem{theorem}{Theorem}
 \newtheorem{lemma}{Lemma}
 \newtheorem{proposition}{Proposition}
 \newtheorem{corollary}{Corollary}
 \newtheorem{definition}{Definition}








\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{(\ref{#1})}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vSigma{\bm{\Sigma}}
\def\vtheta{{\bm{\theta}}}
\def\veta{{\bm{\eta}}}
\def\valpha{{\bm{\alpha}}}
\def\vgamma{{\bm{\gamma}}}
\def\vdelta{{\bm{\delta}}}
\def\vphi{{\bm{\phi}}}
\def\vpsi{{\bm{\psi}}}
\def\vbeta{{\bm{\beta}}}
\def\vnu{{\bm{\nu}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vell{{\bm{\ell}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vhn{{\hat{\bm{n}}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vhr{{\hat{\bm{r}}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vhx{{\hat{\bm{x}}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}
\def\vec1{{\bm{1}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}
\newcommand{\dist}{\textrm{d}} \newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 \iclrfinalcopy
\usepackage{hyperref}
\usepackage{url}
\usepackage{enumerate}  
\usepackage{wrapfig}
\usepackage{caption}
\usepackage{makecell}
\usepackage{array}
\newcolumntype{?}{!{\vrule width 1pt}}

\title{Formatting Instructions for ICLR 2021 \\ Conference Submissions}







\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}
\renewcommand{\tabcolsep}{1.6pt}
\usepackage{arydshln}
\setlength\dashlinedash{0.5pt}


\title{Global Attention Improves\\ Graph Networks Generalization
}




\author{Omri Puny \ \   Heli Ben-Hamu \ \  Yaron Lipman \\
Weizmann Institute of Science\\
	Rehovot, Israel \\
}



\begin{document}

\maketitle


\begin{abstract}












  This paper advocates incorporating a Low-Rank Global Attention (LRGA) module, a computation and memory efficient variant of the dot-product attention \citep{vaswani2017attention}, to Graph Neural Networks (GNNs) for improving their generalization power. 
  
  To theoretically quantify the generalization properties granted by adding the LRGA module to GNNs, we focus on a specific family of expressive GNNs and show that augmenting it with LRGA provides algorithmic alignment to a powerful graph isomorphism test, namely the 2-Folklore Weisfeiler-Lehman (2-FWL) algorithm. In more detail we: (i) consider the recent Random Graph Neural Network (RGNN) \citep{sato2020random} framework and prove that it is universal in probability; (ii) show that RGNN augmented with LRGA aligns with 2-FWL update step via polynomial kernels; and (iii) bound the sample complexity of the kernel's feature map when learned with a randomly initialized two-layer MLP.
  
  From a practical point of view, augmenting existing GNN layers with LRGA produces state of the art results in current GNN benchmarks. Lastly, we observe that augmenting various GNN architectures with LRGA often closes the performance gap between different models. 
  


  


  
\end{abstract}

\section{Introduction}

In many domains, data can be represented as a graph, where entities interact, have meaningful relations and a global structure. The need to be able to infer and gain a better understanding of such data rises in many instances such as social networks, citations and collaborations, chemoinformatics, epidemiology etc. In recent years, along with the major evolution of artificial neural networks, graph learning has also gained a new powerful tool - graph neural networks (GNNs). Since first originated \citep{Gori2005, Scarselli2009} as recurrent algorithms, GNNs have become a central interest and the main tool in graph learning. 

Perhaps the most commonly used family of GNNs are message-passing neural networks \citep{Gilmer2017}, built by aggregating messages from local neighborhoods at each layer. Since information is only kept at the vertices and propagated via the edges, these models' complexity scales linearly with , where  and  are the number of vertices and edges in the graph, respectively. In a recent analysis of the expressive power of such models, \citep{xu2018how,morris2018weisfeiler} have shown that message-passing neural networks are at most as powerful as the first Weisfeiler-Lehman (WL) test, also known as vertex coloring. The -WL tests, are a hierarchy of increasing power and complexity algorithms aimed at solving graph isomorphism. This bound on the expressive power of GNNs led to the design of new architectures \citep{morris2018weisfeiler,maron2019provably} mimicking higher orders of the -WL family, resulting in more powerful, yet complex, models that scale super-linearly in , hindering their usage for larger graphs.  


Although expressive power bounds on GNNs exist, empirically in many datasets, GNNs are able to fit the train data well. This indicates that the expressive power of these models might not be the main roadblock to a successful generalization. Therefore, we focus our efforts in this paper on strengthening GNNs from a \emph{generalization} point of view. 
Towards improving the generalization of GNNs we propose the Low-Rank Global Attention (LRGA) module which can be augmented to any GNN. Standard dot-product global attention modules \citep{vaswani2017attention} apply  attention matrix to node data with  computational complexity making them impractical for large graphs. To overcome this barrier, we define a -rank attention matrix, where  is a parameter, that requires  memory and can be applied in  computational complexity.


To theoretically justify LRGA we focus on a GNN model family possessing maximal expressiveness (\ie, universal) but vary in the generalization properties of the family members. 
\citep{murphy2019relational,loukas2019graph, dasoulas2019coloring, loukas2020hard} showed that adding node identifiers to GNNs improves their expressiveness, often making them universal. In this work, we prove that even adding \emph{random} features to the network's input, as suggested in \citep{sato2020random}, a framework we call Random Graph Neural Network (RGNN), GNN models are universal in probability. 

The improved generalization properties of LRGA-augmented GNN models is then showcased for the RGNN framework, where we show that augmenting it with LRGA algorithmically aligns with the -folklore WL (FWL) algorithm; -FWL is a strictly more powerful graph isomorphism algorithm than vertex coloring (which bounds message passing GNNs). To do so, we adopt the notion of algorithmic alignment introduced in \citep{Xu2019algoalign}, stating that a neural network aligns with some algorithm if it can simulate it with simple modules, resulting in provable improved generalization. We opt to use monimials in the role of simple modules and prove the alignment using polynomial kernels. Lastly, we bound the sample complexity of the model when learning the -FWL update rule. Although our bound is exponential in the graph size, it nevertheless implies that RGNN augmented with LRGA can provably learn the -FWL step, when training each module independently with two-layer MLP.










We evaluate our model on a set of benchmark datasets including tasks of graph classification and regression, node labeling and link prediction from \citep{dwivedi2020benchmarking, Hu2020}. LRGA improves state of the art performance in most datasets, often with a significant margin. We further perform ablation study in the random features framework to support our theoretical propositions.
\section{Related Work}


\textbf{Attention mechanisms.} The first work to use an attention mechanism in deep learning was \citep{Bahdanau2015a} in the context of natural language processing. Ever since, attention has proven to be a powerful module, even becoming the only component in the transformer architecture \citep{vaswani2017attention}. Intuitively, attention provides an adaptive importance metric for interactions between pairs of elements, \eg, words in a sentence, pixels in an image or nodes in a graph.
A natural drawback of classical attention models is the quadratic complexity generated by computing scores among pairs. Methods to reduce the computation complexity were introduced by \citep{lee2018set} which introduced the set-transformer and addressed the problem by inducing point methods used in sparse Gaussian processes. Linearized versions of attention were suggested by \citep{shen2018} factorizing the attention matrix and normalizing separate components and \citep{katharopoulos2020transformers} suggesting  using fixed feature maps for linearizing the attention module. Our suggested linearized attention differs from those as we do not use fixed feature functions and use different normalization.

\textbf{Attention in graph neural networks. } In the field of graph learning, most attention works \citep{Li2015,Velickovic2018,Abu-El-Haija2018,Bresson2017Gated, Lee2018} restrict learning the attention scores to the local neighborhoods of the nodes in the graph. Motivated by the fact that local aggregations cannot capture long range relations which may be important when node homophily does not hold, global aggregation in graphs using node embeddings have been suggested by \citep{You2019position,Pei2020}. In a way, LRGA combines both approaches, allowing global weighted aggregations via the simple structure of global attention.



\textbf{Generalization in graph neural networks.}
Although being a pillar stone of modern machine learning, the generalization capabilities of NN are still not very well understood, \eg, see \citep{bartlett2017spectrallynormalized,golowich2019sizeindependent}. Due to the irregular structure of graph data and the weight sharing nature of GNN, investigating their generalizing capabilities poses an even greater challenge. Despite the nonstandard setting, few works were able to construct generalization bounds for GNN via \emph{VC dimension} \citep{article}, \emph{uniform stability} \citep{verma2019stability}, \emph{Rademacher Complexity} \citep{garg2020generalization} and \emph{Neural Tangent Kernel} \citep{du2019graph}.








\section{Preliminaries and notations} \label{sec:prelim}
 We denote a graph by  where  is the vertex set of size ,  is the edge set, and adjacency .  represents the input vertex features.  A vertex  carries an input feature vector ; in turn,  represents the output of the  layer of a neural network. 
 
 A common form of evaluating GNNs is by their ability to distinguish different graphs, described by \emph{graph isomorphism} which is an equivalence relation between graphs. The isomorphism type tensor of a graph  is a tensor  which holds the isomorphism types of all pairs . Given a pair , which represents either an edge or a node of graph ,  summarizes all the information this pair carries in graph . More precisely put, \emph{isomorphism type} is an equivalence relation defined by:  and  have the same isomorphism type \emph{iff} the following conditions hold: (i)   ; (ii)  and ; and (iii)   . One way to build an isomorphism type tensor for graph  is 
, where brackets denote concatentation in the feature dimension,  is the identity matrix, , and similarly (with a slight abuse of notation) . 


\section{Low-rank global attention (LRGA)}

\label{sec:model}
We propose the Low-Rank Global Attention (LRGA) module that can augment any graph neural network layer, denoted here generically as , in the following way:

where the brackets denote concatenation along the feature dimension. The LRGA module is defined for an input feature matrix  via 

where  are MLPs operating on the feature dimension, that is , and  is a parameter representing the \emph{rank} of the attention module. Lastly,  is a normalization factor:

where . 
The matrix  can be thought of as a -rank attention matrix that acts globally on the graph's node features.



\textbf{Computational complexity.}\label{s:prelim}
Standard attention models \citep{vaswani2017attention,Luong2015} require explicitly computing the attention score between all possible pairs in the set, meaning that its memory requirement and computational cost scales as . This makes global-attention seem impractical for large sets, or large graphs in our case. We address the global attention computational challenge by working with bounded rank (\ie, ) attention matrices, and avoid the need to construct the attention matrix in memory by replacing the standard entry-wise normalization ( or ) with a the global normalization . In turn, the memory requirement of LRGA is , and using low rank matrix-vector multiplications LRGA allows applying global attention in  computation cost.  

\textbf{Permutation Equivariance.} A common demand from GNN architectures is to respect the graph representation symmetries, namely the ordering of nodes \citep{Maron2019}. As shown in \citep{lee2018set} the set attention module is permutation equivariant. The same matrix product structure of the LRGA makes this module also permutation equivariant. 






\section{Theoretical Analysis} \label{sec: theo_analysis}
In this section we establish the theoretical underpinning for LRGA. Since we want to analyse the generalization power added by LRGA, we focus on a family of GNNs with unbounded expressive power \emph{in probability} (RGNN). Under this model we show the benefit of augmenting GNNs with LRGA in terms of improved generalization via the notion of \textit{algorithmic alignment} with a powerful graph isomorphism testing algorithm (2-FWL). 




\subsection{Random graph neural networks}

We analyse LRGA under the framework of Random Graph Neural Networks (RGNNs):
\begin{definition}[Random Graph Neural Network] Let  be a probability distribution of zero mean and variance , and  a graph. RGNN is a GNN variant with random input features sampled at every forward pass \ie, the input to the network is  where  are i.i.d.~samples .
\end{definition}



RGNN, suggested by \cite{sato2020random}, has related variants \citep{loukas2020hard, loukas2019graph, murphy2019relational} that use node identifiers or distinctive features, which can be viewed as \emph{constant} random features, in order to break symmetry between isomorphic nodes. Such models are proven to be universal but lose their inherent equivariance due to arbitrary prescription of node identifiers. We choose to work in the seemingly more limited setting of RGNN, which allows the network to distinguish between different nodes but does not overfit specific identifiers. Our main claims regarding this framework is that RGNN is both universal in probability and equivariant in expectation. 






\begin{proposition}[Universal]\label{prop:universalGNNS}
RGNN can approximate an arbitrary continuous graph function given random features sampled from a bounded distribution .
\end{proposition}
Here approximation is in a probabilitic sense: Let  be a compact set of graphs, , where  is the adjacency matrix. Then, given a continuous graph function  defined over  and arbitrary , there exist network parameters and  so that , for all graphs . 
Proposition \ref{prop:universalGNNS} holds for GNN variants with a global attribute block such as \citep{battaglia2018relational}. The proof is based on the idea that random features  allow the GNN to transfer the graph's connectivity information to the node features. Once all graph information is encapsulated at the nodes, we exploit the universality of set functions \citep{zaheer2017deep} to get universality. The full proof is in Appendix \ref{app:proof_uni}. To the best of our knowledge this is the first result proving universality under the random feature assumption. 
 
\begin{proposition}[Equivariant in expectation]
RGNN is permutation equivariant in expectation.
\end{proposition}
Changing the random features at each forward pass allows RGNN to preserve equivariance in expectation. Indeed, equivariance of GNN implies that , for any permutation matrix  and input . Taking the expectation of both sides w.r.t.~, noting that  and using linearity of expectation we get equivariance in expectation.  












 


\subsection{RGNN augmented with LRGA aligns with 2-FWL}

In this section we will formulate our main theoretical result, Theorem \ref{thm:algoalign}, stating that augmenting RGNN with LRGA algorithmically aligns with a powerful graph isomorphism testing algorithm called -Folklore Weisfeiler-Lehman (2-FWL) \citep{grohe2015pebble,grohe2017descriptive}. We will first introduce the notion of algorithmic alignment and the 2-FWL algorithm, then formulate our main theorem, and continue in the next section with a proof. 

\textbf{Algorithmic alignment.} The notion of \emph{algorithmic alignment} was introduced in \cite{Xu2019algoalign} and shown (both theoretically and practically) to lead to improved generalization. Intuitively, a neural network  is said to be aligned with an algorithm  if  can simulate  by a composition of modules, and each module is "simple", or learnable, \ie, have bounded (hopefully low) sample complexity. Our definition of algorithmic alignment is a slightly stricter version: 
\begin{definition}[Monomial Algorithmic Alignment]
A neural network  aligns with algorithm  if  can simulate  by learning only monomial functions, \ie, , where , , and .
\end{definition}
To motivate this choice of monomials as "simple" functions we note that \citep{arora2019fine,Xu2019algoalign} show a sample complexity bound for even-power polynomials learned by (two-layer) MLPs and we extend it to general monomials in the following proposition proved in Appendix \ref{app:monomial_sample_complexity}:

\begin{proposition}
Let a two layer MLP trained with gradient descent be denoted as the learning algorithm . The monomial , , of degree , , is PAC learnable with  with a sample complexity bound:

,  is the error parameter and  the failure probability.
\end{proposition}
The asymptotic behaviour of  is out of the scope of this paper. 
Therefore, a monomial algorithmic alignment of  to  means (under the assumptions and sequential training method of Theorem 3.6 in \cite{Xu2019algoalign}) that  is learnable by .  

\textbf{2-Folklore Weisfeiler-Lehman (2-FWL) Algorithm.}
-FWL is part of the -WL hierarchy of polynomial-time (approximate) graph isomorphism iterative algorithms that recolor -tuples of vertices at each step according to neighborhoods aggregation. Upon reaching a stable coloring, the algorithm terminates and if the histograms of colors of two graphs are not the same then the graphs are deemed not isomorphic. The -FWL algorithm is equivalent to -WL, strictly stronger than vertex coloring (2-WL) which bounds the expressive power of GNNs. 

\begin{wrapfigure}[7]{R}{0.3\textwidth}
\vspace{-10pt}
\includegraphics[scale=0.8]{2fwl.pdf}
\vspace{5pt}
\end{wrapfigure}
In more detail, let  represent the isomorphism types of a given graph , that is  represents the isomorphism type of the pair .  The 2-FWL algorithm is initialized with . 
Let  denote the coloring tensor after the  update step. An update step in the algorithm aggregates information from the multiset of neighborhood colors for each pair. We represent the multiset of neighborhood colors of the tuple  with a matrix . That is, any permutation of the rows of  represent the same multiset. The rows of , which represent the elements in the multiset, are , . See the inset for an illustration. 
The -FWL update step of a pair  from  to  concatenates the previous pair's color and an encoding of the multiset of neighborhoods colors:

where  is a multiset injective  map invariant to the row-order of its input.

\textbf{Main result.} Consider the 2-FWL update rule in \eqref{e:FWL_update} and let  denote (arbitrary) single feature dimension pealed off ; we call  a single-head of the update rule. Then,
\begin{theorem} \label{thm:algoalign}
LRGA augmented RGNN algorithmically aligns with a single head 2-FWL update step.
\end{theorem}
A corollary of this theorem is: 
\begin{corollary}
Multi-head LRGA augmented RGNN algorithmically aligns with 2-FWL.
\end{corollary}
Multi-head LRGA is a module of the form , which is an equivalent to multi-head self-attention. In practice, we found single-head LRGA to be on par performance-wise with multi-head LRGA and therefore we focus on the single-head version in the experimental section. 


\subsection{Proof of Theorem \ref{thm:algoalign}}

To prove Theorem \ref{thm:algoalign} we need to show RGNN augmented with LRGA can simulate one head of the 2-FWL update step using only monomials as learnable functions. We achieve that by the following steps: (i) introduce the notion of node factorization to encode  tensor data as node features; (ii) show that RGNN can approximate node factorization of the graph's isomorphism type tensor with a single GNN layer using learnable monomial functions; (iii) show that 2-FWL update step can be formulated using matrix multiplication of monomial functions; and (iv) show LRGA can approximate a single head 2-FWL update step using learnable monomials. 

\textbf{Part (i).} 
We start with the definition of node feature factorization:
\begin{definition}[Node factorization] \label{def:richfeat}
Let  be a tensor.  is called \emph{node factorization} of  if there exists a block structure  so that , where  are index pairs.  \end{definition}
Note that for all  we have .
Lets illustrate the definition with an example. Let  be the adjacency matrix of some graph , and for simplicity assume that there are no node features. Then, the isomorphism type tensor of  is . One possible way of node factoring  is using the SVD decomposition of the adjacency matrix . Note that node factorization is not unique. 


\textbf{Part (ii).}
\begin{proposition}\label{prop: rich_to_random}
RGNN with skip connection can approximate node factorization of the  isomorphism type tensor .
\end{proposition}
\begin{proof}
We will prove the case of graph , \ie, with no vertex features; the general case can be found in Appendix \ref{app: extension_prop_4}. Let   be a random node features matrix sampled i.i.d.~from . 
A single layer of standard message passing can represent , which requires learning only first degree (linear) monomials in the GNN's learnable parts.  Furthermore,  is an approximate node factorization of , since , where the approximation error  can be bounded using the result in Appendix \ref{app:proof_uni}.
\end{proof}


\textbf{Part (iii).}
As shown in \citep{maron2019provably} the encoding function  from the 2-FWL update rule (see \eqref{e:FWL_update}) can be expressed as follows (derivation can be found in Appendix \ref{app:multiset_enc}):
 \\
where for notational simplicity we denote  and . By  we mean that we apply the multi-power  to the feature dimension, \ie, . Therefore, computing the multisets encoding amounts to calculating monomials  and their matrix multiplications . 

\textbf{Part (iv).}
\begin{proposition} \label{prop:poly_kernels}
The node factorization of each head of , the result of -FWL update step, can be approximated via LRGA module applied to  node factorization of . The MLPs in the LRGA approximation need to learn only monomial functions. 
\end{proposition}
\textit{Proof.}
Let  be a node factorization of . The -FWL update step requires computation of polynomials of the form  as shown in \eqref{e:FWL_update_rule_matrix}. Using the node factorization of  , , we can write:
\vspace{-5pt}

where the second equality is using the feature maps  of the (homogeneous) polynomial kernels \citep{Vapnik1998}, ; the third equality is reformulating the feature maps  on the vectors , and ; and the last equality is due to the closure of kernels to multiplication. We denote the final feature map by . 

Now, let  and  then we have:
 where  is applying  to every row of .
Therefore, arbitrary head of , \ie, of the form , can be written directly as a function of  using the feature maps :

A node factorization of the head  is therefore . Recalling the structure of the LRGA module introduced in \eqref{e:lowRankAtt}: , to implement the 2-FWL head the MLPs  need to learn the polynomial feature maps formulated in \eqref{e:Y_beta_gamma}: , , , and . Every coordinate of these feature maps is a monomial (proof of this fact in Appendix \ref{app:feat_map_monomial}). Lastly, 
note that 2-FWL tensors   are insensitive to global scaling and therefore the normalization  has no theoretical influence (it is assumed non-zero). \qedsymbol









\section{Experiments}
We evaluated our method on various tasks including graph regression, graph classification, node classification and link prediction. The datasets we used are from two benchmarks: (i) benchmarking GNNs \citep{dwivedi2020benchmarking}; and (ii) Open Graph Benchmark (OGB) \citep{Hu2020}.  Each benchmark has its own evaluation protocol designed for a fair comparison among different models. These protocols define consistent splits of the data to train/val/test sets, set a budget on the size of the models (OGB), define a stopping criterion for reporting test results and require training with several different initializations to measure the stability of the results. We followed these protocols.\\
\textbf{Random Features Evaluation.} In addition, we also conducted a set of experiments with the random feature framework. In this experiment we focused on the PATTERN node classification dataset from \citep{dwivedi2020benchmarking} and evaluated a variety of models under the RGNN framework.\\
\textbf{Rank Ablation Study.} In this experiment we examined the relation between the rank parameter , which can limit the expressiveness of the attention module, and the network performance. Results are presented in Appendix \ref{sec: Rank_ablation}.\\
\textbf{Implementation details of LRGA.} We implemented the LRGA module according to the description in Section \ref{sec:model} (equations \ref{e:lowRankAtt}, \ref{e:etaNorm}) using the pytorch framework and the DGL \citep{wang2019dgl} and Pytorch geometric \citep{fey2019fast} libraries. Each LRGA module contains  MLPs . Each  is a single layer MLP (linear with ReLU activation). The implementation of a layer is according to \eqref{e:lowRankAtt}, where in practice we added another single layer MLP,  , for the purpose of reducing the feature dimension size. In the OGB benchmark dataset we did not use the skip connections (better performance), and as advised in \citep{wang2019dgl}, we used batch and graph normalization at each layer. \\
\textbf{Baselines.} We compare performance with the following state of the art baselines: \textit{GCN} \citep{Kipf2016}, \textit{GraphSAGE} \citep{Hamilton2017}, \textit{GIN} \citep{xu2018how}, \textit{GAT} \citep{Velickovic2018}, \textit{GatedGCN} \citep{Bresson2017Gated}, \textit{Node2Vec} \citep{grover2016node2vec} , DeepWalk \citep{Perozzi_2014} and \textit{MATRIX FACTORIZATION} \citep{Hu2020}.



\begin{table}[h]
\captionsetup{font=,font=footnotesize}
\caption{Performance on the benchmarking GNN datasets. In bold: better performance between LRGA augmented and vanilla models; note the parameter (\#) budget. Blue represents best performance with the K budget and red with the K budget.}
\label{table: benchmarking}
\vspace{-6pt}
\tiny
\centering
\begin{tabular}{l?c|c?c|c?c|l?c|c?c|c?c|c}
\Xhline{2\arrayrulewidth}
\multirow{2}{*}{\textbf{Model}} & \multicolumn{2}{c?}{\textbf{PATTERN}}   & \multicolumn{2}{c?}{\textbf{CLUSTER}}   & \multicolumn{2}{c?}{\textbf{ZINC}}                        & \multicolumn{2}{c?}{\textbf{MNIST}}     & \multicolumn{2}{c?}{\textbf{CIFAR10}}   & \multicolumn{2}{c}{\textbf{TSP}}        \\ \cline{2-13} 
                                & \textbf{\#} & \textbf{Acc  std}    & \textbf{\#} & \textbf{Acc  std}    & \textbf{\#} & \multicolumn{1}{c?}{\textbf{MAE  std}} & \textbf{\#} & \textbf{Acc  std}    & \textbf{\#} & \textbf{Acc  std}    & \textbf{\#} & \textbf{F1  std}      \\ \Xhline{2\arrayrulewidth}
\textbf{GCN}                    & 100K        & 63.88  0.07          & 101K        & 53.44  2.02          & 103K        & 0.459  0.006                           & 101K        & 90.70  0.21          & 101K        & 55.71  0.38          & 95K         & 0.630  0.001          \\
\textbf{LRGA + GCN}             & 90K         & \textbf{83.09  0.73} & 91K         & \textbf{68.44  0.16} & 92K         & \textbf{0.448  0.009}                  & 91K         & \textbf{97.63  0.11} & 91K         & \textbf{65.80  0.43} & 97K         & \textbf{0.702  0.001} \\ \hline
\textbf{GAT}                    & 109K        & 75.82  1.82          & 110K        & 57.73  0.32          & 102K        & 0.475  0.007                           & 110K        & 95.53  0.20          & 110K        & 64.22  0.45          & 96K         & 0.671  0.002          \\
\textbf{LRGA + GAT}             & 90K         & \textbf{82.54  0.71} & 91K         & \textbf{69.05  0.05} & 92K         & \textbf{0.421  0.020}                  & 90K         & \textbf{97.47  0.16} & 90K         & \textbf{68.00  0.13} & 97K         & \textbf{0.680  0.003} \\ \hline
\textbf{GatedGCN}               & 104K        & 84.48  0.12          & 104K        & 60.40  0.41          & 105K        & 0.375  0.003                           & 104K        & 97.34  0.14          & 104K        & 67.31  0.31          & 97K         & \textbf{\textcolor{blue}{0.808  0.003}} \\
\textbf{LRGA + GatedGCN}        & 93K         & \textbf{\textcolor{blue}{85.09  0.11}} & 93K         & \textbf{\textcolor{blue}{69.28  0.16}} & 94K         & \textbf{\textcolor{blue}{0.355  0.010}}                  & 93K         & \textbf{\textcolor{blue}{98.20  0.03}} & 93K         & \textbf{\textcolor{blue}{70.65  0.18}} & 97K         & 0.807  0.001          \\ \Xhline{2\arrayrulewidth}
\textbf{GCN}                    & 500K        & 71.89  0.33          & 501K        & 68.49  0.97          & 505K        & \textbf{0.367  0.011}                  & 504K        & 91.39  0.25          & 504K        & 54.84  0.44          & -           & -                          \\
\textbf{LRGA + GCN}             & 400K        & \textbf{84.55  0.57} & 400K        & \textbf{76.01  0.67} & 501K        & 0.377  0.009                           & 463K        & \textbf{98.34  0.06} & 463K        & \textbf{68.27  0.46} & -           & -                          \\ \hline
\textbf{GAT}                    & 526K        & 78.27  0.18          & 528K        & 70.58  0.44          & 531K        & 0.384  0.007                           & 441K        & 96.50  0.18           & 442K        & 66.11  0.98          & -           & \textbf{-}                 \\
\textbf{LRGA + GAT}             & 533K        & \textbf{\textcolor{red}{85.82  0.42}} & 267K        & \textbf{76.16  0.34} & 536K        & \textbf{0.360  0.004}                  & 476K        & \textbf{98.41  0.08} & 476K        & \textbf{71.57  0.26} & -           & -                          \\ \hline
\textbf{GatedGCN}               & 502K        & 85.56  0.01          & 502K        & 73.84  0.32          & 504K        & 0.282  0.015                           & 500K        & 98.24  0.04          & 500K        & 71.33  0.39          & -           & -                          \\
\textbf{LRGA + GatedGCN}        & 486K        & \textbf{85.81  0.31} & 438K        & \textbf{\textcolor{red}{76.39  0.13}} & 446K        & \textbf{\textcolor{red}{0.249  0.011}}                  & 486K        & \textbf{\textcolor{red}{98.47  0.16}} & 487K        & \textbf{\textcolor{red}{73.48  0.29}} & -           & -                         
\end{tabular}
\end{table}


\subsection{Benchmarking Graph Neural Networks \citep{dwivedi2020benchmarking}} \label{sec: benchmarking_gnn}
\textbf{Datasets.} 
This benchmark contains  main datasets (full description in appendix \ref{app:dwivedi}) : (i) ZINC, graph regression task of molecular dataset evaluated with MAE metric; (ii) MNIST and CIFAR10, the image classification problem converted to graph classification using a super-pixel representation \citep{Knyazev_superpixel}; (iii) CLUSTER and PATTERN, node classification tasks which aim to classify embedded node structures \citep{abbe2017community}; (iv) TSP, a link prediction variation of the Traveling Salesman Problem \citep{joshi2019efficient} on 2D Euclidean graph. 
\\
\textbf{Evaluation protocol.} All models were evaluated with two different sets of parameter budgets and restrictions. The first set restricted to have roughly  parameters and  layers, while the second set of experiments has a budget of roughly  parameters and up to  layers. The learning rate and its decay are set according to a predetermined scheduler using the validation loss. The stopping criterion is set to when the learning rate reaches a specified threshold. All results are averaged over a set of predetermined fixed seeds and standard deviation is reported as well. 
\vspace{-5pt}

\textbf{Results.} Table \ref{table: benchmarking} summarizes the results of training and evaluating our model according to the evaluation protocol; We observe that LRGA improves GNN performance, often by a large margin, across all models and datasets, besides GCN on ZINC and GatedGCN in TSP, supporting our claim for improved generalization. We further note that SOTA in all datasets except TSP is achieved with LRGA augmented GNNs. In some datasets, such as CLUSTER and PATTERN, LRGA reaches top and roughly equivalent performance for all models it augmented, which emphasizes the empirical contribution of LRGA independently of the GNN variant.





\subsection{Link prediction datasets from the OGB benchmark \citep{Hu2020}}
\begin{wraptable}[9]{r}{0.55\textwidth}
\captionsetup{justification=centering,font=,font=footnotesize}
\vspace{-13pt}

\caption{ Performance on the link prediction tasks from the OGB benchmark}
\vspace{-6pt}
\label{table: ogb}
\begin{adjustbox}{width=0.55\textwidth}
\centering

\begin{tabular}{l?c|c?c|c?c|c}
\Xhline{2\arrayrulewidth}
\multirow{2}{*}{\textbf{Model}} & \multicolumn{2}{c?}{\textbf{ogbl-ppa}}         & \multicolumn{2}{c?}{\textbf{ogbl-collab}} & \multicolumn{2}{c}{\textbf{ogbl-ddi}}   \\ \cline{2-7} 
                                & \textbf{\# Param} & \textbf{Hits@100std}  & \textbf{\# Param}  & \textbf{Hits@50std}   & \textbf{\# Param} & \textbf{Hits@20std}   \\ \Xhline{2\arrayrulewidth}
\textbf{Node2vec}               & 7.3M              & 0.223  0.008          & 30M          & 0.489  0.005          & 645K        & 0.233  0.021          \\
\textbf{DeepWalk}               & 150M              & 0.289  0.015          & 61M          & 0.504  0.003          & 11M         & 0.264  0.061          \\
\textbf{MF}                     & 147M              & 0.323  0.009          & 60M          & 0.389  0.003          & 1.2M        & 0.137  0.047          \\ \Xhline{2\arrayrulewidth}
\textbf{GraphSage}              & 424K              & 0.165  0.024          & 460K         & 0.481  0.008          & 1.4M        & 0.539  0.047          \\
\textbf{GCN}                    & 278K              & 0.187  0.013          & 296K         & 0.447  0.011          & 1.2M        & 0.370  0.050          \\
\textbf{LRGA + GCN}             & 814K              & \textbf{0.342  0.016} & 1M           & \textbf{0.522  0.007} & 1.5M        & \textbf{0.623  0.091}
\end{tabular}
\end{adjustbox}
\end{wraptable}



\textbf{Datasets.} We further evaluate LRGA on semi-supervised learning tasks including graphs with hundreds of thousands of nodes, from the OGB benchmark: (i) ogbl-ppa, a graph of proteins and biological connections as edges ;(ii) ogbl-collab, an authors collaborations graph; (iii) ogbl-ddi drug interaction network. The evaluation metric for all of the tasks is Hits@K; more details in appendix \ref{app:ogb}.  \\
\textbf{Evaluation protocol.}  All models have a hidden layer of size  and the number of layers  is  in ogbl-ppa and ogbl-collab and  in ogbl-ddi. Test results are reported by the best validation epoch averaged over  random seeds. \\
\textbf{Results.} Table \ref{table: ogb} summarizes the results on the link prediction tasks. It should be noted that the first three rows correspond to node embedding methods where the rest are GNNs. Augmenting GCN with LRGA achieves SOTA results on those datasets, while still using order of magnitude less parameters than the node embedding runner-up method.





\subsection{Random Features Ablation}
\begin{wraptable}[14]{r}{0.25\textwidth}
\vspace{-10pt}
\captionsetup{justification=centering,font=footnotesize}
\caption{Random Features Evaluation}
\vspace{-6pt}
\label{table: random_features}
\begin{adjustbox}{width=0.25\textwidth}
\begin{tabular}{l?c}

\Xhline{2\arrayrulewidth}
\multirow{2}{*}{\textbf{Model}} & \textbf{PATTERN}            \\ \cline{2-2} 
                                & \textbf{Acc  std}      \\ \Xhline{2\arrayrulewidth}
\textbf{GCN}                    & 74.891  0.713          \\
\textbf{LRGA + GCN}             & 84.118  1.216 \\ \hline
\textbf{GAT}                    & 81.796  0.661          \\
\textbf{LRGA + GAT}             & 85.905  0.109 \\ \hline
\textbf{GraphSage}              & 85.039  0.068                           \\
\textbf{LRGA + GraphSage}        & 85.229  0.331                  \\ \hline
\textbf{GatedGCN}               & 85.848  0.065          \\
\textbf{LRGA + GatedGCN}        & 85.944  0.664 \\ \hline
\textbf{GIN}                    & 85.760  0.001          \\
\textbf{LRGA + GIN}               & \textbf{86.765  0.065}
\end{tabular}
\end{adjustbox}
\end{wraptable}

In this experiment we wanted to validate the theoretical analysis presented at section \ref{sec: theo_analysis}. The dataset for this evaluation is the PATTERN dataset, which is originally equipped with random features, but in contrast to the RGNN framework those features are sampled only once at the dataset creation stage. We evaluated the different models according to the RGNN framework, \ie, resample the features with every forward pass. The features were sampled from a zero mean Gaussian distribution with variance , where  is the input feature dimension. The evaluation protocol is the same as the one used in section \ref{sec: benchmarking_gnn} and we followed the  budget. As seen from table \ref{table: random_features}, using alternating random features improves performance for all the models. \textit{GIN} and \textit{GraphSage} do not appear in the main table but according to \citep{dwivedi2020benchmarking} achieves  and  respectively. The LRGA augmented RGNN models maintain their superiority (even presenting a small improvement compared to Table \ref{table: benchmarking}) and serve as an empirical validation to our main theorem.



\vspace{-5pt}



\section{Conclusions}
\vspace{-5pt}
In this work, we set ourself in a path for improving the generalization power of GNNs. To do so, we introduced the LRGA module, a global self attention module, which is a variant of the dot-product self-attention with linear complexity. In order to theoretically evaluate the contribution of LRGA we analyzed our model under the RGNN framework, which is proved to be universal \emph{in probability}. Under this framework we were able to show that RGNN augmented with LRGA can align with the powerful 2-FWL isomorphism test by learning simple monomial functions, which have a known sample complexity bound. Under certain conditions the latter provides concrete generalization guarantees for RGNN augmented with LRGA. Empirically, we demonstrated augmenting GNN models with LRGA improves their performance significantly, often achieving SOTA performance.

\newpage









\bibliography{low_rank_attention.bib}
\bibliographystyle{iclr2021_conference}
\appendix

\section{Proof of Proposition \ref{prop:universalGNNS}} \label{app:proof_uni}

\begin{proof}

We will now prove the universality \emph{in probability} over the distribution  of RGNNs.
Let  be a compact set of graphs, , where  are the node features and  is the adjacency matrix and we assume that  is fixed. Consider , a continuous graph function.  is permutation invariant where the permutation acts on all  dimensions, namely,  for all permutation matrices .
RGNN is defined as  where  are i.i.d. samples from .

To prove universality in probability we need to show that RGNN can approximate  to an arbitrary precision  with high probability :

where  are the RGNN network parameters and  is the dimension of the random features of RGNN. 

In fact, a simple RGNN composed of single message passing layer and a global attribute block, a DeepSets network \citep{zaheer2017deep}, suffices. The message passing layer first transfers the graph structural information to the node features by creating a factorized representation of . This means that all the graph information is now stored in a set. Then, using the universality of DeepSets network for invariant set functions we can approximate  to an arbitrary precision. 

 Let us denote the output of the message passing layer of RGNN by . The structural information of the graph can be transferred to the node features using the message passing layer by choosing parameters such that .  is then fed to the DeepSets network, so we have .

Observing the approximation error: 


We can now bound the two terms in the last inequality above. Since  is defined on the compact set  we first make sure that  remains bounded (we assume  can be extended continuously to this domain). Since we assume  is bounded (given , ), we get:




For the second term we can achieve a bound in probability. Since  is a continuous function on a compact set, by the Heine-Cantor theorem, it is uniformly continuous, meaning that 


Setting  we can now choose  such that with probability  we have . 
Let  be the euclidean metric, then, . Since we assume a graph of fixed size ,  and we are left with bounding  in probability. Using Hoeffding's inequality we will be able to find  satisfying the conditions. 


A single entry in  has mean 0 and variance , for simplicity we set .  An entry in  is of the form . Note that all elements of the sum are statistically independent and bounded. Using Hoeffding's inequality:


For :  and for : .

Using union bound over all entries of :

 
Setting  and requiring  we get  where  accumulates all constant factors. Lastly,  is bounded by , so the  we should take is .
Finally, we have that for large enough ,  is arbitrarily small with a high probability. 


For the first term, we note that  is a continuous invariant set function over a bounded domain. Therefore the first term can be bounded by invoking the universal approximation theorem of invariant set functions \citep{zaheer2017deep}, \ie, exist a set of parameters and model size such that the approximation error is less than . 

This concludes the proof. We found that exists a set of network parameters and  such that the approximation error is arbitrarily small. 

\end{proof}


\section{Multiset encoding}\label{app:multiset_enc}
As shown in \cite{maron2019provably} the multiset encoding function, , can be defined using the collection of Power-sum Multi-symmetric Polynomials (PMPs). That is, given a multiset  the encoding is defined by 
where , and  . 

Let us focus on computing a single output coordinate  of the  function applied to a particular multiset . This can be efficiently computed using matrix multiplication \cite{maron2019provably}: Let , where . Then, 

By  we mean that we apply the multi-power  to the feature dimension, \ie, . 
This implies that computing the multisets encoding amounts to calculating monomials  and their matrix multiplications . Thus the -FWL update rule, \eqref{e:FWL_update}, can be written in the following matrix form, where for notational simplicity we denote :
 \\

\section{2-FWL via polynomial kernels}\label{app:feat_map_monomial}
In this section, we give a full characterization of feature maps, , of the final polynomial kernel we use to formulate the 2-FWL algorithm. 
A key tool for the derivation of the final feature map is the multinomial theorem, which we state here in a slightly different form to fit our setting. 

\textbf{Multinomial theorem. } Let us define a set of  variables  composed of products of corresponding  and 's. Then,

where , and the notation . The sum is over all possible  which sum to , in total  elements.

Recall that we wish to compute  as in \eqref{e:phi_beta} in the paper:



We will now follow the equalities in \eqref{e:phi_beta} to derive the final feature map. The second equality is using the feature maps  of the (homogeneous) polynomial kernels \citep{Vapnik1998}, , which can be derived from the multinomial theorem.

Suppose the dimensions of  are  where . Then,  consists of monomials of degree  of the form ,  . In total the size of the feaure map  is .

The third equality is reformulating the feature maps  on the vectors , and .


The last equality is due to the closure of kernels to multiplication. The final feature map, which is the product kernel, is composed of all possible products of elements of the feature maps, \ie,  
where , and  for all . 
The size of the final feature map is  where .


\section{Extension of Proposition \ref{prop: rich_to_random}}\label{app: extension_prop_4}
In this section we would like to extend the proof of proposition \ref{prop: rich_to_random} to the case where the graph is equipped with prior node features , s.t the network's input is . As mentioned in Section \ref{sec:prelim} the isomorphism type of a graph equipped with node features is . Following this description we claim that the node factorization representation of the graph will be of the form , where . To build the isomorphosm tensor we can use the sequence of outer products , where  is the \textit{l}-th column of . This sequence could be represented using the two first components of .
The last two components,  and  allow to approximate in probability  and  as shown in Appendix \ref{app:proof_uni}, which complete the isomorphism tensor construction and conclude that  is a node factorization representation. Lastly, we have to show that we can construct this structure using RGNN, and actually we are left to explain how to add the  vector to the representation. This could be done using a global attribute block as used to proof Proposition \ref{prop:universalGNNS}.

\section{Sample complexity bound of monomials} \label{app:monomial_sample_complexity}
Corollary 6.2 in \citep{arora2019fine} provides a bound on the sample complexity, denoted , of a polynomial   of the form

where , , ;  are the relevant PAC learning constants, and  represents an over-parameterized, randomly initialized two-layer MLP trained with gradient descent. 



It is not immediately clear, however, how to use this theorem to learn an arbitrary monomial  since  has the above particular form. Nevertheless we show how it can be generalized to this case.

Let , and note that there are  elements in . We assume some fixed ordering in  is prescribed. Define the sample matrix (multivariate Vandemonde)  by . Lemma 2.8 in \citep{wendland2004scattered} implies that  is non-singular. Let  (\ie, the induced  matrix norm); note that  is dependant only upon . 
\begin{lemma}\label{lem:poly}
Fix , and let  be arbitrary. Then, there exist coefficients , , so that , for all .
\end{lemma}

\begin{proof}
Using the multinomial theorem we have: , where  are positive multinomial coefficients. This equation defines a linear relation between the monomial basis  and , for . The matrix of this system is  multiplied by a positive diagonal matrix with  on its diagonal. By inverting this matrix and solving this system for  the lemma is proved.  
\end{proof}
We can use this Lemma in the following way: Assume  is even or otherwise consider . Further assume that the MLP  is two-layer,  over-parameterized of the form  (\ie, we assume there is a constant  plugged in an extra  coordinate).
We consider training  with random initialization and gradient descent using data  where  is sampled i.i.d.~from some distribution  over . 

Let  defined as , where  is as promised by Lemma \ref{lem:poly}. Then, the learning setup described above is equivalent to training the MLP  using data of the form , where  is sampled i.i.d.~from a distribution  over  concentrated on the hyperplane . Now using the Corollary 6.2 from \citep{arora2019fine} in our case where  is defined as  where  and by Lemma \ref{lem:poly} there exist  such that .
The sample complexity bound expression by Corollary 6.2 is therefore:



Let us bound the first term in the numerator of the sample complexity expression:


The first inequality is due to , the second is by Lemma \ref{lem:poly} and uniting  into the main term. From the above, the bound follows. 



\section{Rank Ablation Study}\label{sec: Rank_ablation}
\begin{wrapfigure}[17]{H}{0.5\textwidth}
\vspace{-14pt}
\captionsetup{font=footnotesize}
\vspace{-10pt}
\includegraphics[scale=0.4]{new_rank.pdf}
\vspace{-7pt}
\caption{Ablation study on CLUSTER dataset. The X-axis represent the ratio between the rank parameter  and the average graph size . The Y-axis represent the network's accuracy}\label{fig:ablation}
\end{wrapfigure}

We investigated the affects of the attention's rank  on the performance of GNNs augmented with LRGA on the CLUSTER dataset. The dataset contains graphs of  to  nodes (117 nodes in average). Our experimental setting included fixing the GNN's hidden dimensions size and changing . Figure \ref{fig:ablation} shows that accuracy increases with the rank values until it reaches a plateau around  ( where  is the average graph size), a fact that could be attributed to saturating the expressiveness of the LRGA module. Moreover, the maximal accuracy is achieved at a value that corresponds to the maximal graph size in the dataset, smaller than what the theory predicts as a function of the graph size . This rank value is enough to compute any attention function on this graph collection. 


\section{Implementation Details}
In this section we describe the datasets on which we performed our evaluation. In addition, we specify the hyperparameters for the experiments section in the paper. The rest of the model configurations are determined directly by the evaluation protocols defined by the benchmarks. It is worth noting that most of our experiments ran on a single Tesla V- GPU, if not stated otherwise. We performed our parameter search only on  and  (except for CIFAR10 and MNIST were we searched over different dropout values), since the rest of the parameters were dictated by the evaluation protocol. The models sizes were restricted by the allowed parameter budget.

\subsection{Benchmarking Graph Neural Networks \citep{dwivedi2020benchmarking}} \label{app:dwivedi}

\paragraph{Datasets.} 
This benchmark contains  main datasets :
\begin{enumerate}[(i)]
\item \textbf{ZINC}, a molecular graphs dataset with a graph regression task where each node represents an atom and each edge represents a bond. The regression target is a property known as the constrained solubility (with mean absolute error as evaluation metric). Additionally, the node features represent the atom's type ( types) and the edge features represents the type of connection ( types).
The result reported for GCN used  for the K budget and  (network's depth is ) for the K budget. For the GAT network we used  ( attention heads of dimension ) for the K budget and  ( attention heads of dimension ) with  for the K budget. For the GatedGCN network we used  for the K budget and  with  for the K budget. All the models used .

\item  \textbf{MNIST} and \textbf{CIFAR10}, the known image classification problem is converted to a graph classification task using Super-pixel representation \citep{Knyazev_superpixel}, which represents small regions of homogeneous intensity as nodes. The edges in the graph are obtained by applying k-nearest neighbor algorithm on the nodes coordinates. Node features are a concatenation of the Super-pixel intensity (RGB for CIFAR10 and greyscale for MNIST) and its image coordinate. Edges features are the k-nearest distances.
The result reported for GCN used  for the K budget and  with  for the K budget. For the GAT network we used  ( attention heads of dimension ) for the K budget and  ( attention heads of dimension ) with  for the K budget. For the GatedGCN network we used  for the K budget and  with  for the K budget. All the models used .

\item \textbf{CLUSTER} and \textbf{PATTERN}, node classification tasks which aim to identify embedded node structures in stochastic block model graphs \citep{abbe2017community}. The goal of the task is to assign each node to the stochastic block it was originated from, while the structure of the graph is governed by two probabilities that define the inner-structure and cross-structure edges. A single representative from each block is assigned with an initial feature that indicates its block while the rest of the nodes have no features (CLUSTER), while in the PATTERN dataset nodes are assigned with a random value as input feature at the creation stage.
The result reported for GCN used  for the K budget and  with  for the K budget (PATTERN, CLUSTER respectively). For the GAT network we used  ( attention heads of dimension ) for the K budget and  ( attention heads of dimension ,  attention heads of dimension ) with  for the K budget (PATTERN, CLUSTER respectively). For the GatedGCN network we used  for the K budget and  with  for the K budget (PATTERN, CLUSTER respectively).
All the models used .

\item \textbf{TSP}, a link prediction task that tries to tackle the NP-hard classical Traveling Salesman Problem \citep{joshi2019efficient}. Given a 2D Euclidean graph the goal is to choose the edges that participate in the minimal edge weight tour of the graph. The evaluation metric for the task is F score for the positive class.
The result reported for GCN used  . For the GAT network we used  ( attention heads of dimension ). For the GatedGCN network we used .
All the models used .

\end{enumerate}

\subsection{Link prediction datasets from the OGB benchmark \citep{Hu2020}} \label{app:ogb}
\paragraph{Datasets.} In order to provide a more complete evaluation of our model we also evaluate it on semi-supervised learning tasks of link prediction. We searched over the same hyperparameter range  and used  in all tasks. The three datasets were:
\begin{enumerate}[(i)]
    \item \textbf{ogbl-ppa}, an undirected unweighted graph. Nodes represent types of proteins and the edges signify biological connections between proteins. The initial node feature is a 58-dimensional one-hot-vector that indicates the origin specie of the protein. The learning task is to predict new connections between nodes. The train/validation/test split sizes are M/M/M
    . The evaluation metric is called Hits@K \citep{Hu2020}.
    
    \item \textbf{ogbl-collab}, is a graph that represents a network of collaborations between authors. Every author in the network is represented by a node and each collaboration is assigned with an edge. Initial node features are obtained by combining word embeddings of papers by that author (128-dimensional vector). Additionally, each collaboration is described by the year of collaboration and the number of collaborations in that year as a weight. The train/validation/test split sizes are M/K/K. Similarly to the previous dataset, the evaluation metric is Hits@K. 
    \item \textbf{ogbl-ddi} - an undirected  unwighted graph which represent drug-drug interaction. Each Node represents FDA approved or experimental drug. The edges represent interactions between drugs and represent the joint effect of taking both drugs together. The learning task is to predict new drug to drug interactions. The train/validation/test split sizes are M/K/K. The evaluation here is also Hits@K. 
\end{enumerate}


\end{document}
