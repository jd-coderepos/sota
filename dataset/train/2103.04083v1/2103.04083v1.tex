





\documentclass[runningheads]{llncs}
\usepackage{times}
\usepackage{setspace}
\usepackage[breaklinks=true,hidelinks=true]{hyperref}
\usepackage{color}
\usepackage{comment}
\usepackage{url}

\usepackage{booktabs}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{makecell}
\usepackage{subcaption}
\usepackage{multirow}
\usepackage{pbox}


\usepackage[flushleft]{threeparttable}


\usepackage{graphicx,xspace}
\usepackage{epstopdf}
\usepackage{stfloats}
\usepackage[font=small]{caption}
\usepackage{enumitem}
\usepackage{wrapfig}
\usepackage{flushend}
\epstopdfsetup{update}


\newcommand{\todo}[1]{{\color{red}\textbf{#1}}}
\def\st#1{~}
\def\inv{\vspace{0cm}}
\newcommand{\dsnamens}{WAP196k}
\newcommand{\dsname}{{\dsnamens}\ }
\newcommand{\ggnamens}{Google ({\color{red}to be anonymized for blind review})}
\newcommand{\ggname}{{\dsnamens}\ }

\newcommand{\jen}[1]{{\color{blue}[\textbf{Jen:} #1]}}




\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}

\newtheorem{defn}{Definition}
\newtheorem{prop}{Proposition}
\newtheorem{thm}{Theorem}

\newcommand{\bcH}{\mathcal{H}}
\newcommand{\cH}{\mathcal{H}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cU}{\mathcal{U}}
\newcommand{\cX}{\mathcal{X}}
\newcommand{\cD}{\mathcal{D}}
\newcommand{\cT}{\mathcal{T}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cZ}{\mathcal{Z}}
\newcommand{\cY}{\mathcal{Y}}
\newcommand{\cN}{\mathcal{N}}
\newcommand{\cI}{\mathcal{I}}



\makeatletter
\let\overlinewithoriginalheight\overline
\newcommand*\overlinewithlessheight[1]{{\mathpalette\overline@aux{#1}}}
\newcommand*\overline@aux[2]{\begingroup
    \count0=\fam \setbox0=\hbox{}\@tempdima=.4\ht0\setbox0=\hbox{}\advance\@tempdima by .6\ht0\ht0=\@tempdima \usebox0\endgroup }
\let\overline\overlinewithlessheight

\let\underlinewithoriginaldepth\underline
\newcommand*\underlinewithlessdepth[1]{{\mathpalette\underline@aux{#1}}}
\newcommand*\underline@aux[2]{\begingroup
    \count0=\fam
    \setbox0=\hbox{}\@tempdima=.4\dp0\setbox0=\hbox{}\advance\@tempdima by .6\dp0\dp0=\@tempdima
    \usebox0\endgroup }
\let\underline\underlinewithlessdepth
\makeatother



\newcommand*\dbar[1]{\overline{\overline{#1}}}
\newcommand{\harrow}[1]{\mathstrut\mkern2.5mu#1\mkern-11mu\raise1.6ex\hbox{}}
\newcommand{\pirow}{\phi}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqrefs#1#2{equations~\ref{#1} and~\ref{#2}}
\def\Eqref#1{Equation~\eqref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\expected}{E}
\newcommand{\E}{\mathbb{E}} \newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak


\newcommand{\ea}{\emph{et al.}}
\newcommand{\eg}{\emph{e.g.}}
\newcommand{\ie}{\emph{i.e.}}
\newcommand{\iid}{\emph{i.i.d.}}
\newcommand{\wrt}{\emph{w.r.t.}\ }
\newcommand{\cf}{\emph{cf.}\ }

\newcommand{\ind}[1] {\mathbb{I}\{#1\}}
\newcommand{\Ncal}{\mathcal{N}}
\newcommand{\Ucal}{\mathcal{U}}
\newcommand{\Lcal}{\mathcal{L}}
\newcommand{\Ab}{\mA}
\newcommand{\EE}{\mathbb{E}}
\newcommand{\thetab}{\bm{\theta}}
\newcommand{\grad}{\nabla}
 
\pdfinfo{
/Title (Insert Your Title Here)
/Author (Put All Your Authors Here, Separated by Commas)}
\begin{document}
\title{ReadNet: A Hierarchical Transformer Framework for Web Article Readability Analysis}
\titlerunning{ReadNet: A Hierarchical Transformer Framework for Readability Analysis}
\author{
Changping Meng\thanks{This work was done during the summer internships of CM and MC at Google, Mountain View. We thank the anonymous reviewers for their insightful comments.}, Muhao Chen, Jie Mao,Jennifer Neville 
}
\institute{
Department of Computer Science, Purdue University, West Lafayette\\
Department of Computer Science, University of California, Los Angeles\\
Google Inc., Mountain View\\
\{meng40, neville\}@purdue.edu; muhaochen@ucla.edu; mjmjmtl@google.com
}




\maketitle
\begin{abstract}
Analyzing the {\em readability} of articles has been
an important sociolinguistic task.
Addressing this task is necessary to the automatic recommendation of appropriate articles to readers with different comprehension abilities, and it further benefits education systems, web information systems, and digital libraries.
Current methods for assessing readability employ empirical measures or statistical learning techniques that are limited by their ability to characterize complex patterns such as article structures and semantic meanings of sentences.
In this paper, we propose a new and comprehensive framework which uses a hierarchical self-attention model to analyze document readability.
In this model, measurements of sentence-level difficulty are captured along with the semantic meanings of each sentence.
Additionally, the sentence-level features are incorporated to characterize the overall readability of an article with consideration of article structures.
We evaluate our proposed approach on three widely-used benchmark datasets against several strong baseline approaches. Experimental results show that our proposed method achieves the state-of-the-art performance on estimating the readability for various web articles and literature.
\end{abstract}
 \section{Introduction}\label{intro}
Readability is an important linguistic measurement that indicates how easily readers can comprehend a particular document.
Due to the explosion of web and digital information, there are often hundreds of articles describing the same topic, but vary in levels of readability.
This can make it challenging for users to find the articles online that better suit their comprehension abilities.
Therefore, an automated approach to assessing readability is a critical component for the development of 
recommendation strategies for web information systems, including digital libraries and web encyclopedias.


{\em Text readability} is defined as the overall effect of language usage and composition on readers' ability to easily and quickly comprehend the document~\cite{readability}.
In this work, we focus on evaluating document difficulty based on the composition of words and sentences.
Consider the following two descriptions of the concept \emph{rainbow} as an example.



\begin{enumerate}
\item \textbf{A more rigid scientific definition from \emph{English Wikipedia}}: A rainbow is a meteorological phenomenon that is caused by reflection, refraction and dispersion of light in water droplets resulting in a spectrum of light appearing in the sky. 
\item \textbf{A more generic description from the \emph{Simple English Wikipedia}}: A rainbow is an arc of color in the sky that can be seen when the sun shines through falling rain. The pattern of colors starts with red on the outside and changes through orange, yellow, green, blue, to violet on the inside.
\end{enumerate}
Clearly, the first description provides more rigidly expressed contents, but is more sophisticated due to complicated sentence structures and the use of professional words. In contrast, the second description is simpler, with respect to both grammatical and document structures.  From the reader's perspective, the first definition is more appropriate for technically sophisticated audiences, while the second one is suitable for general audiences, such as parents who want to explain rainbows to their young children.

The goal of \emph{Readability Analysis} is to provide a rating regarding the difficulty of an article for average readers.
As the above example illustrates that, many approaches for automatically judging the difficulty of the articles are rooted in two factors: the difficulty of the words or phrases, and the complexity of syntax~\cite{CollinsSurvey}. 
To characterize these factors, existing works~\cite{readability2,readability3} mainly rely on some explicit features such as \emph{Average Syllables Per Word}, \emph{Average Words Per Sentence}, etc. For example, the Flesch-Kincaid index is a representative empirical measure defined as a linear combination of these factors~\cite{chall1995readability}. Some later approaches mainly focus on proposing new features with the latest Coh\-Metrix 3.0~\cite{mcnamara2014automated} providing 108 features, and they combine and use the features using either linear functions or statistical models such as Support Vector Machines or multilayer perceptron~\cite{SVM,collins2005predicting,pitler2008revisiting,pilan2016predicting,CambridgeData}. While these approaches have shown some merits, they also lead to several drawbacks. Specifically (1) they do not consider sequential and structural information, and  (2) they do not capture sentences-level or document-level semantics that are latent but essential to the task~\cite{CollinsSurvey}.





To address these issues, we propose ReadNet, a comprehensive readability classification framework that uses a hierarchical transformer network. The self-attention portion of the transformer encoder is better able to model long-range and global dependencies among words. The hierarchical structure can capture how words form sentences, and how sentences form documents, meanwhile reduce the model complexity exponentially.
Moreover, explicit features indicating the readability of different granularities of text can be leveraged and aggregated from multiple levels of the model.
We compare our proposed model to a number of widely-adopted document encoding techniques,
as well as traditional readability analysis approaches based on explicit features.
Experimental results on three benchmark datasets show that our work properly identifies the document representation techniques,
and achieves the state-of-the-art performance by significantly outperform previous approaches. 










 \section{Related Work}\label{sec:related}
Existing computational methods for readability analysis~\cite{readability2,readability3,readability4,CollinsSurvey,pilan2016predicting} mainly use empirical measures on the symbolic aspects of the text, while ignoring the sequence of words and the structure of the article. The Flesch-Kincaid index~\cite{kincaid1975derivation} and related variations use a linear combination of explicit features.

Although models based on these traditional features are helpful to the quantification of readability for small and domain-specific groups of articles, they are far from generally applicable for a larger body of web articles~\cite{Si2001ASM,CollinsThompson2004ALM,Feng2009}. Because those features or formulas generated from a small number of training text specifically selected by domain experts, they are far from generally representing the readability of large collections of corpora. Recent machine learning methods on readability evaluation are generally in the primitive stage. \cite{franccois2009combining} proposes to combine language models and logistic regression. The existing way to integrate features is through a statistical learning method such as SVM~\cite{ReadingMeasures,SVM,collins2005predicting,pitler2008revisiting,pilan2016predicting,CambridgeData}. 
These approaches ignore the sequential or structural information on how sentences construct articles. Efforts have also been made to select optimal features from current hundreds of features~\cite{de2016all}. Some computational linguistic methods have been developed to extract higher-level language features. The widely-adopted Coh-Metrix~\cite{graesser2004coh,mcnamara2010coh} provides multiple features based on cohesion such as referential cohesion and deep cohesion.

Plenty of works have been conducted on utilizing neural models for sentimental or topical document classification or ranking, while few have paid attention to the readability analysis task.
The convolutional neural network (CNN)~\cite{CNN} is often adopted in sentence-level classification which leverages local semantic features of sentence composition that are provided by word representation approaches. In another line of approaches, a recursive neural network~\cite{socher2013recursive} is adopted, which focuses on modeling the sequence of words or sentences. 
Hierarchical structures of such encoding techniques are proposed to capture structural information of articles, and have been widely used in tasks of document classification~\cite{tang2015document,lin2015hierarchical,chen2019subarticle}, and sequence generation~\cite{li2015hierarchical} and sub-article matching \cite{chen2018neural}. Hierarchical attention network~\cite{RNN} is the current state-of-the-art method for document classification, which employs attention mechanisms on both word and sentence levels to capture the uneven contribution of different words and sentences to the overall meaning of the document.  The Transformer model~\cite{vaswani2017attention} uses multi-head self-attention to perform sequence-to-sequence translation. Self-attention is also adopted in text summarization, entailment and representation~\cite{parikh2016decomposable,li2018hierarchical}. Unlike topic and sentiment-related document classification tasks that focus on leveraging portions of lexemes that are significant to the overall meanings and sentiment of the document, readability analysis requires the aggregation of difficulty through all sentence components. Besides, precisely capturing the readability of documents requires the model to incorporate comprehensive readability-aware features, including difficulty, sequence and structure information, to the corresponding learning framework.
 \section{Preliminary}\label{sec:setting}

  In this section, we present the problem definition, as well as some representative explicit features that are empirically adopted for the readability analysis task.


  \subsection{Problem Definition}

The readability analysis problem is defined as an ordinal regression problem for articles. Given an article with up to  sentences and each sentence with up to  words, an article can be represented as a matrix  whose -th row  corresponds to the -th sentences, and  denotes the -th word of the -th sentence.
  Given an article , a label will be provided to indicate the readability of this article.

We consider the examples introduced in Section~\ref{intro}, where two articles describe the same term ``\textit{rainbow}". The first rigorous scientific article can be classified as ``difficult", and the second general description article can be classified as ``easy". 

Instead of classifying articles into binary labels like ``easy" or ``difficult", more fine-grained labels can help people better understand the levels of readability. For instance, we can map the articles in standardization systems of English tests such as 5-level Cambridge English Exam (CEE),
where articles from professional level English exam (CPE) are regarded than those from introductory English exam (KET).

\iffalse
{\color{red}
We use the following datasets to study readability.
Regular encyclopedias and simplified encyclopedias~\cite{wikidata}: English Wikipedia is the most delicate and well-defined regular encyclopaedia for explaining certain concepts.
Simple English Wikipedia which is the simplified encyclopedia only uses simple words and easy sentence structures to provide a primary understanding of English learners and kids.
We treat the Simple English Wiki page with label 0, while the English Wiki page with label 1. The confidence value of 0 or 1 can be considered as the readability rating in extreme cases.
+CEE. (But another concern is, why do we need to introduce the datasets in detail for twice? You should consider, say, reform this part to an example that illustrates the problem definition.)
}
\fi










\subsection{Explicit Features} \label{indicator}
  Previous works~\cite{kincaid1975derivation,gibson1998linguistic,heilman2007combining,heilman2008analysis,malvern2012measures,CollinsSurvey,graesser2004coh} have proposed empirical features to evaluate readability. Correspondingly, we divide these features into sentence-level features and document-level features. Sentence-level features seek to evaluate the difficulty of sentences. For instance, the sentence-level feature ``number of words" for sentences can be averaged into ``number of words per sentence" to evaluate the difficulty of documents. Document-level features include the traditional readability indices and cohesion's proposed by Coh-Metrix\cite{graesser2004coh}. These features are listed in Table~\ref{tb:features}.

  \begin{table*}[!h]
  	\centering
  	\scriptsize
  	\begin{tabular}{p{0.25\columnwidth}|p{0.75\columnwidth}}
  		{Name} & Description \\
  		\hline
  		\multicolumn{2}{l}{Sentence-level features}\\
  		\hline
  		\#characters\_per\_word &  The average number of characters per word, which provides a character-level measure for the difficulty of words. \\
  		\#syllabi\_per\_word & The average number of syllabi per word, which measures the difficulty of words from the syllabus level. \\
  		\#words& The number of words that measures the verbosity of the sentence. \\
\#long\_words &  The number of words longer than 6 characters in a sentence. \\
  	\#difficult\_words & The number of difficult word in a sentence. Difficult word is a word not listed in the 3000 words for fourth-grade American students.\\
  		\#pronoun & The number of pronoun in a sentence. \\
\hline
  		\multicolumn{2}{l}{Document-level features}  \\
  		\hline
  		Flesch Reading Ease~\cite{kincaid1975derivation} & The United States Military Standard of readability scoring for technical manuals, which is calculated as . \\
  		Flesch-–Kincaid grade level~\cite{kincaid1975derivation} & An empirical readability metric which maps to a U.S. school grade level, calculated as .\\
  		Automated Readability Index~\cite{senter1967automated} & A metric that also produces an approximate representation of the US grade level needed to comprehend the text, calculated as  - 21.43. Instead of considering syllables, this metric more generally characterizes on the character level.\\
  		Coleman-Liau Index~\cite{coleman1975computer} & An index used to gauge the understandability of a text from the character-level: .\\
  		Gunning Fog Index~\cite{gunning1969fog}& ; It estimates the years of formal education a person needs to understand the text on the first reading.\\
  		LIX~\cite{brown2005student} & A measure indicating the difficulty of reading a text based on the proportions of long words and verbosity of sentences: .\\
		RIX~\cite{anderson1983lix} & A metric based on the proportion of long words in text, .\\
  		SMOG Index~\cite{mc1969smog} & A measure of readability that seeks to estimate the years of education needed to understand a piece of writing: .\\
  		Dale Chall Index~\cite{fry1968readability} & . Difficult word is a word not listed in the 3000 words for fourth-grade American students\\
  		Incidence of connectives~\cite{louwerse2001analytic} & 5 numerical features indicate additive, logic, temporal, causal and
negative connectives.\\
  		Logic operator connectivity~\cite{coxhead2000new} & Logical connectives between logical particles such as ``and'', ``if'' proposed by Coh-Metrix. \\
  		Lexical diversity & The character-level density of the lexicon: . \\
  		Content diversity &  . It measures the diversity of content. Content words are adjectives, nouns, verbs and adverbs.\\
  		Incidence of part-of-speech elements & Incidence of word categories (adjectives, nouns, verbs, adverbs, pronouns) per 1000 words
in the text \\
  	\end{tabular}
  	\caption{Explicit Features}\label{tb:features}
  	\vspace{-1cm}
  \end{table*}
Current approaches~\cite{SVM,collins2005predicting,pitler2008revisiting} average the sentence-level features of each sentence to construct document level features.
Furthermore, these features are concatenated with document-level features, and use an SVM to learn on these features. The limitation lies in failing to capture the structure information of sentences and documents. For instance, in order to get the sentence level features for the document, it averages all these features of each sentence. It ignores how these sentences construct an article and which parts of the document more significantly decides the readability of the document. While cohesion features provided by Coh-Metrix tries to captures relationships between sentences, these features mainly depend on the repeat of words across multiple sentences. They did not directly model how these sentences construct a document in perspectives of structure and sequence.

Briefly speaking, existing works are mainly contributing more features as shown in Table~\ref{tb:features}. But the current models used to aggregate these features are based on SVM and linear models. In this work, we target to propose a more advanced model to better combine these features with document information.


  \section{Hierarchical Transformer for Readability Analysis}
 In order to address the limitations of traditional approaches, we propose ReadNet: the Hierarchical Transformer model for readability analysis as shown in Figure~\ref{fig:model}.



The proposed model incorporates the explicit features with a hierarchical document encoder that encodes the sequence and structural information of an article. The first level of the hierarchical learning architecture models the formation of sentences from words. The second level models the formation of the article from sentences. The self-attention encoder (to be described in subsection~\ref{subsec:transformer}) is adapted from the vanilla Transformer encoder~\cite{vaswani2017attention}. The hierarchical structure, attention aggregation layer, combination with explicit features and transfer layer are specially designed for this readability analysis task.

\begin{figure}[!ht]
\centering
    \vspace{-0.5cm}
	\includegraphics[width=0.90\columnwidth]{pic/transModel.pdf}
	\caption{ReadNet: proposed hierarchical transformer model specialized for readability analysis \label{fig:model}}
	\vspace{-0.5cm}
\end{figure}




\iffalse
\subsection{Word Representations}

In this subsection, we first present an effective word embedding technique to indicate word difficulty.

\subsubsection{Difficulty Measurement of Words}
As shown in research~\cite{coxhead2000new,Lexicon},  words with higher frequency in the literature often appear to be easier. The ranking of words based on frequency can be considered as the reverse ranking of difficulty. For instance, using Wikipedia-based datasets~\cite{wikidata} in our training, the most frequent words are stop words such as ``in", ``a", ``is". While those with rare occurrences often include difficult ones such as ``marionette" ``depigmentation".

Assume the corpus has  words. Each word  is ranked by the frequency in descending order with the ranking . We define a difficulty score for word  with Equation~\ref{eq:diff}. In this function, a  function in the numerator is adopted to scale the measure of difficulty. Words with lower ranks are expected to show less variation in difficulty. The  in the denominator is used to normalize the word difficulty score to the range of [0, 1].



 \subsubsection{Word Embeddings for Readability}
 Word embedding techniques play an important role in transforming discrete words from a large corpus into a continuous vector based on their context, hence are the essential feature maps for neural document models.
 \paragraph{Skip-Gram model}
 Existing word embedding approaches seek to capture semantic similarity of words based on their context similarity, and quantify such similarity in the form of vector distances.
 The skip-gram model~\cite{word2vec} is one of the most used word embedding approaches which aims to predict the target word given its context words within a sliding window.

 For a sequence of words , the skip-gram model is trained to maximize the conditional log-likelihood of a word over its context words, which is defined as below:

 

 In the above equation, the sliding window size is . The conditional probability   is a softmax function defined in Equation~\ref{condition} where  and   as ``input" and ``output" vector representations of .

 


 \paragraph{Readability-aware Skip-Gram model}
 the skip-gram model have been extended to support different applications such as topic-aware embeddings~\cite{topicalEmbed,topicalEmbed2}. However, our task requires to incorporate the word difficulty information into the word representations that has not been considered by previous embedding methods.
 For a toy example, consider three phrases ``a nice cat", ``a pretty cat" and ``a gorgeous cat". Simply adopting Skip-Gram model directly obtains very similar embedded vectors for the three words ``nice", ``pretty" and ``gorgeous". If the difficulty information is involved in word embeddings, ``nice" and ``pretty" should be considered closer than ``nice" and ``gorgeous", since ``gorgeous" is a relatively more complicated word.

 In this case, we modify the conditional log likelihood of Skip-Gram as the following

  

\noindent
 where  is a function to indicate the similarity of difficulty between these two words  and . As we have stated that there is {highly negative correlation between difficulty and word frequency}, we adopt Equation~\ref{eq:diff} to estimate the word difficulty as  and .  is defined as follows.
.

 Since it is impossible to enumerate all , we adopt negative sampling for efficient approximiation. The Noise Contrastive Estimation (NCE) technique~\cite{NCE} is used to obtain a computationally efficient term of the softmax log likelihood
   
 for which  is the distribution of words. The goal is to distinguish the target word  and a random word .

\fi
\vspace{-0.5cm}
\subsection{From Words to Sentences}

In this subsection, we introduce the encoding process of sentences in hierarchical mutli-head self-attention. The encoding process has three steps: \textit{1)} the self-attention encoder transforms the input sequence into a series of latent vectors; \textit{2)} the attention layer aggregates the encoded sequential information based on the induced significance of input units; \textit{3)} The encoded information is combined with the explicit features.
\vspace{-0.6cm}
\subsubsection{Transformer Self-Attention Encoder}\label{subsec:transformer}
This encoder is adapted from the vanilla Transformer encoder~\cite{vaswani2017attention}. The input for this encoder is , which represents the -th sentence. 

The Embedding layer encodes each word  into a -dimensional vector based on word embedding. The output is a -dimensional matrix  where  is the embedding dimension and  is the number of words.

The position encoding layer indicates the relative position of each word . The elements of positional embedding matrix  where values in the -th row -th column is defined as follows.	



The embedded matrix  and positional embedding matrix  are added into the initial hidden state matrix .
 will go through a stack of  identical layers. Each layer contains two parts: (i) the Multi-Head Attention donated as function  defined in Equation~\ref{eq:mha}, and (ii) the Position-wise Feed-Forward  defined in Equation~\ref{eq:ffn}. Layer normalization is used to avoid gradient vanishing or explosion.

\emph{Multi-head Self-Attention function}() \cite{vaswani2017attention}  encodes the relationship among query matrix ,  key matrix  and value matrix  from different representation subspaces at different positions. .  is a  weight matrix.  denotes concatenation.  are  weight matrix for head function .  




\emph{Position-wise Feed-Forward Function}  \cite{vaswani2017attention}  adopts two 1-Dimensional convolution layers with kernel size 1 to encode input matrix .


For the -th encoder layer,  is encoded into   according to Equation~\ref{eq:encoder}


\subsubsection{Attention Aggregation Layer}



After  transformer encoder layers, each sentence  is encoded into a -dimensional  matrix .


We first pass  through a feed forward layer with  dimensional weights  and
bias term  to obtain a hidden representation as :

then compute the similarity between  and
the trainable  dimensional context matrix  via

which we use as importance weights to obtain the final embedding of the sentence :




\subsubsection{Combination of explicit features}
The sentence level features  introduced in Section~\ref{indicator} Table~\ref{tb:features} for -th sentence are concatenated by  .

  \subsection{From Sentences to Articles}

The second level of the hierarchical learning architecture is on top of the first layer.  encoded vector  are concatenated as the input for this layer. The structure of second level is the same as the first level. The output of this level is a vector  as the overall embedding of this article.
 




\subsection{Transfer layer}


The goal of the transfer layer is to improve prediction quality on a target task where training data are scarce, while a large amount of other training data are available for a set of related tasks. 

The readability analysis problem suffers from the lack of labeled data. Traditional benchmark datasets labeled by domain experts typically contain a small number of articles. For instance, CEE contains 800 articles and Weebit contains around 8 thousand articles. 
Such quantities of articles are far smaller than those for sentiment or topic-related document classification tasks which typically involve over ten thousand articles even for binary classification \cite{CNN,chen2019subarticle}.
On the other hand, with the emerging of online encyclopedia applications such as Wikipedia, it provides a huge amount of training dataset. For instance, English Wikipedia and Simple-English Wikipedia contain more than 100 thousand articles which can be used to train a deep learning model.


One fully connected layer combines the article embedding vector  and document-level features  from Table~\ref{tb:features} to output the readability label vector  after a Softmax function.  is the weight of the fully connected layer. For dataset with  categories of readability ratings, each document is embedded into  with  dimensions. 


If transfer learning is needed, instead of random initialization, this network is initialized with a pre-trained network based on a larger corpus. During the training process, update the transfer layer while keeping all other layers frozen. If transfer learning is not needed, all layers are updated during the training process.

\subsection{Learning Objective}
Given dataset with  categories of readability ratings, the goal is to minimize ordinal regression loss~\cite{rennie2005loss} defined as Equation~\ref{eq:cross}.   represents the -th dimension of the  vector.  is the true label. The threshold parameter  are also learned automatically from the data.





Here, the objective of learning the readability analysis model is essentially different from that of a regular document classification model, since the classes here do form a partial-order. However, the case of two classes degenerates the learning to the same as that of a binary classifer.

\subsection{Why Hierarchical Self-attention}

For self-attention, the path length in the  computation graph between long-range dependencies in the network is  instead of  for recurrent models such as LSTM. Shorter path length in the computation graph makes it easier to learn the interactions between any elements in the sequence. For readability analysis, modeling the overall interaction between words is more important than modeling the consequent words. For semantic understanding, the consequence of two words such as `` very good '' and ``not good" make distinct semantic meanings.  While for readability analysis, it does not make difference in difficulty to understand it. The overall evaluation of the words difficulties in the sentences matters. 

The hierarchical learning structure benefits in two ways. First, it mimics human reading behaviors, since the sentence is a reasonable unit for people to read, process and understand. People rarely check the interactions between arbitrary words across different sentences in order to understand the article. Second, the hierarchical structure can reduce parameter complexity. For a document with  sentences,  words per sentence,  dimension per word, the parameter complexity of the model is  for single level structure. While for the hierarchical structure, the parameter complexity is .
 \section{Experiments}

In this section, we present the experimental evaluation of the proposed approach.
We first introduce the datasets used for the experiments, followed by the comparison of the proposed approach and baselines based on held-out evaluation, as well as detailed ablation analysis of different techniques enabled by our approach.

\subsection{Datasets}
We use the following three datasets in our experiment. Table~\ref{tb:stat} reports the statistics of the three datasets including the average number of sentences per article  and the average number of words per sentence .

 \textbf{Wiki} dataset ~\cite{wikidata} contains \emph{English Wikipedia} and \emph{Simple English Wikipedia}. Simple English Wikipedia thereof is a simplified version of English Wikipedia which only uses simple English words and grammars. This dataset contains 59,775 English Wikipedia articles and 59,775 corresponding Simple English Wikipedia articles.

 \textbf{Cambridge English Exam (CEE)}~\cite{CambridgeData} categorizes articles based on the criteria of five Cambridge English Exam level  (KET, PET, FCE, CAE, CPE). The five ratings are sequentially from the easiest KET to the hardest CPE. In total, it contains 110 KET articles, 107 PET articles, 153 FCE articles,  263 CAE articles and 155 CPE articles. 
 Even though this dataset designed for non-native speakers may differ from materials for native English speakers, the difficulty between five levels is still comparable.
 We test our model on this dataset in order to check whether our model can effectively evaluate the difficulty of English articles according to an existing standard.

\textbf{Weebit}~\cite{weebit} is one of the largest dataset for readability analysis. It contains 7,676 articles targeted at different age group readers from Weekly Reader magazine and BBC-Bitesize website. Weekly Reader magazine categorizes articles according to the ages of targeted readers in 7-8, 8-9 and 9-10 years old. BBC-Bitesize has two levels for age 11-14 and 15-16. The targeted age is used to evaluate readability levels.

\begin{table*}
	\centering
	\small
	\begin{tabular}{c|cc|ccccc|ccccc}
		\multirow{2}{*}{Datasets}&\multicolumn{2}{c|}{{Wiki}}&\multicolumn{5}{c|}{Cambridge English Exam}&\multicolumn{5}{c}{WeeBit}\\
		\cline{2-13}
		&En & \scriptsize{Simple} En & KET & PET  & FCE  & CAE & CPE& WR 2 & WR 3 & WR 4 & KS3 &GCSE   \\
		\hline
		 & 37.46 &7.74 & 6.30  &8.80 & 16.47 & 10.63 & 16.69  &23.41 & 23.28 & 28.12 & 22.71 & 27.85 \\
		\hline
		 & 17.03& 14.41 &9.40 & 16.63 & 17.96 & 16.39 & 23.47   &12.56 & 13.48 & 16.29 & 20.04 & 18.62\\
		\hline
	\end{tabular}
	\caption{Statistics of datasets {Wiki}, {Cambridge English Exam} and {Weebit} }\label{tb:stat}
	\vspace{-0.5cm}
\end{table*}


\begin{table*}[ht]
\small
\centering
\setlength\tabcolsep{1pt}
\begin{tabular}{c|ccc|ccc|cc}
\multirow{2}{*}{Accuracy}&\multicolumn{3}{c|}{Explicit Features}&\multicolumn{3}{c|}{Semantic Features}&\multicolumn{2}{c}{Explicit+Semantic}\\
\cline{2-9}
&Logistic&SVM&MLP&CNN&LSTM&HATT&HATT+&ReadNet\\
\hline
\multirow{2}*{Wiki}  &0.822 &0.848 &0.819&0.583 &0.849&0.877&0.898& \textbf{0.912 }\\
&\scriptsize{(0.006)}&\scriptsize{(0.008)}&\scriptsize{(0.007)}&\scriptsize{(0.035)} &\scriptsize{(0.007)}&\scriptsize{(0.007)}&\scriptsize{(0.007)}& \textbf{\scriptsize{(0.006)} }\\

\multirow{2}*{CEE}  & 0.462& 0.492&0.475& 0.277 & 0.473& 0.512& 0.513& 0.528 \\
& \scriptsize{(0.027)}& \scriptsize{(0.041)}&\scriptsize{(0.044)}& \scriptsize{(0.031)} & \scriptsize{(0.047)}& \scriptsize{(0.043)}& \scriptsize{(0.041)}& \scriptsize{(0.045)} \\

\multirow{2}*{Weebit} &0.724& 0.846&0.845& 0.635& 0.886 & 0.884 &0.902& \textbf{ 0.917 }\\
&\scriptsize{(0.007)}& \scriptsize{(0.006)}&\scriptsize{(0.006)}& \scriptsize{(0.043)}& \scriptsize{(0.005)} & \scriptsize{(0.007)} &\scriptsize{(0.006)}& \textbf{ \scriptsize{(0.006)}}\\
\hline


\end{tabular}
\caption{Cross-validation classification accuracy and standard deviation ( in parentheses ) on Wikipedia(Wiki), Cambridge English Exam (CEE) and Weebit dataset. We report accuracy on three groups of models: (1) statistical classification algorithms including multi-class logistic regression, Linear SVM and Multilayer Perceptron (MLP); (2) Three types of document classifier CNN, hierarchical GRNN using LSTM cells (LSTM), Hierarchical Attention Network (HATT); (3) Hierarchical Attention Network combined with explicit features(HATT+), and our proposed approach which combines explicit features and semantics with Hierarchical Self-Attention (ReadNet). Transfer learning is not used, and all parameters in the model are initialized randomly (Transfer learning is evaluated separately in Table~\ref{tb:transfer}).  }\label{tbl:cv}
\vspace{-0.5cm}
\end{table*}
 
\begin{table}[!h]
	\centering
	\small
	\setlength\tabcolsep{1pt}
	\begin{tabular}{c|c|c|c|c|c}
		
		& KET & PET & FCE & CAE & CPE \\
		\hline
		Scores & 0.381  0.078 & 0.544  0.092& 0.620  0.054 & 0.671  0.085 & 0.837  0.071 \\
		\hline
	\end{tabular}
	\caption{Average readability scores of 10 randomly selected articles in Cambridge English Test predicted by our model trained using Wikipedia.  PET, KET , FCE, CPE and CAE have increasing difficulty levels according to Cambridge English. The scores are the confidence scores of classified as regular English Wikipedia instead of simple English Wikipedia.}\label{tb:CEPP}
	\vspace{-1.0cm}
\end{table}

\iffalse
\begin{figure}[!h]
	\centering
	\begin{minipage}{1\linewidth}
		\centering
		\begin{subfigure}{0.4\linewidth}
			\includegraphics[width=\linewidth]{pic/ReadNet1000.pdf}
			\caption{Model with 1000 training examples}
		\end{subfigure}
		~
		\begin{subfigure}{0.4\linewidth}
			\includegraphics[width=\linewidth]{pic/ReadNet10000.pdf}
			\caption{Model with 10000 training examples}
		\end{subfigure}
		
		\caption{\small ROC curves (True Pos  False Pos): Wiki Task}  \label{fig:ROCedge}
	\end{minipage}
\end{figure}
\fi



\subsection{Evaluation}
In this subsection, we provide a detailed evaluation of the proposed approach.

\textbf{Baseline approaches}. We compare our proposed approach (denoted ReadNet) against the following baseline methods.
\begin{itemize}
	\item Statistical classification algorithms based on explicit features: this category of baselines including the statistical classification algorithms that are widely adopted in a line of previous works \cite{ReadingMeasures,SVM,collins2005predicting,pitler2008revisiting,pilan2016predicting,CambridgeData}, such as  multi-class Logistic Regression, the Linear SVM, and the Multilayer Perceptron (MLP)~\cite{weebit}. 
Explicit features on which these models are trained have been introduced in Section~\ref{indicator}.
Since this work targets at proposing  a  more  advanced  model to utilize features instead of proposing new features, all these features from Table~\ref{tb:features} are used.

  \item Neural document classifiers: this category of baselines represents the other line of previous works that adopt variants of neural document models for sentence or document classification.
      Corresponding approaches including the Convolutional Neural Networks (CNN) \cite{CNN}, the Hierarchical Gated Neural Network with Long Short-term Memory (LSTM) \cite{tang2015document}, and the Hierarchical Attention Network (HATT) \cite{RNN}.
  	\item The Hierarchical Attention Network combined with explicit features (HATT+), for which we use the same mechanism as our proposed approach to incorporate the explicit features into the representation of each sentence by the attentive RNN.
\end{itemize}

\textbf{Model configurations.}  
For article encoding, we limit the number of sentences of each article to up to 50, zero-pad short ones and truncate over-length ones. According to the data statistics in Table~\ref{tb:stat}, 50 sentences are enough to capture the majority of information of articles in the datasets. For each sentence, we also normalize the number of words to be fed into the model as 50, also via zero-padding and truncating. We fix the batch size to 32, and use Adam~\cite{duchi2011adaptive} as the optimizer with a learning rate 0.001. The epochs of training for the neural models are limited to 300. We set the number of encoder layers  and  to 6. The embedding dimension . Number of heads  in  is 3. CNN adopts the same configuration as~\cite{CNN}. Other statistical classification algorithms are trained until converge. Source code will be available in the final version.

\textbf{Evaluation protocol.} We formalize the task as a classification task following previous works on the three benchmark datasets. In order to provide a valid quantitative evaluation, we have to follow the existing evaluation method to show the advantage of our proposed model compared with the baselines. We adopt 5-fold cross-validation to evaluate the proposed model and baselines. We report the classification accuracy that is aggregated on all folds of validation. 




\textbf{Results.} The results are reported in Table~\ref{tbl:cv}.
Traditional explicit features can provide satisfying results. Since the multi-class logistic regression, SVM and MLP models can combine the features \emph{number of words per sentence} and \emph{number of syllabi per word} which are included in Flesch-Kincaid score, they provide the reasonable result.
	 CNN is only slightly better than random guess.  We assume that this is because CNN does not capture the sequential and structural information of documents. The HATT approach provides the best among models without explicit features. The reasons root in the structure of the model which is able to capture length and structural information of the article. Since it also adopted a hierarchical structure, the conciseness of each sentence and that of the overall article structure is captured, which appears to be significant to the task.
The explicit features further improve the results of HATT as shown by HATT+.
	 Even without explicit features, our proposed approach is better than HATT+.
     HATT has appeared to be successful at highlighting some lexemes and sentence components that are significant to the overall meanings or sentiment of a document. However, unlike topic and sentiment-related document classification tasks, readability does not rely on several consecutive lexemes, but the aggregation of all sentence components. The path length in the computation graph between arbitrary components dependencies in ReadNet is  instead of  for HATT. Shorter path length in the computation graph makes it easier to learn the interactions between any arbitrary words in sentence level, or sentences in document-level.
     






Compared with traditional approaches, the main advantage of the proposed approach is that it uses the document encoder to learn how words are connected into sentences and how sentences are connected into documents. Baseline approaches only use the averaged explicit features of all the sentences. For these datasets, several extremely difficult and complicated sentences usually determine the readability of a document. This useful information is averaged and weakened by the total number of sentences in baselines.

\subsection{Analysis on Transfer Learning}
As shown in Table~\ref{tbl:cv}, the standard deviation of the CEE task is large compared with those in Wiki and Weebit tasks since the quantity of CEE articles is not enough to train a complex deep learning model. Transfer layer in ReadNet is utilized in three steps. First is to train and save the model from larger datasets such as Wiki or Weebit. Then, we initialize the model for CEE task and load the parameter weights from the saved model except for the transfer layer. Eventually on the target task, the transfer layer is trained while keeping all other layers fixed. As shown in Table~\ref{tb:transfer}, loading a pre-trained model based on Weebit or Wiki can increase the accuracy and decrease standard deviation on the CEE task. It is shown that a more accurate and stable model can be achieved by utilizing the transfer layer and well-trained models from related tasks.

\begin{table}[!h]
    \vspace{-0.5cm}
	\centering
	\small
	\begin{tabular}{c|c|c|c}
		
		 & Original & Load Weebit & Load Wiki \\
		\hline
		Accuracy & 0.528 (0.045) & 0.568 (0.012)& 0.561 (0.014)\\
		\hline
	\end{tabular}
	\caption{Accuracy for CEE classification using the transfer layer. Original is the model not using transfer learning, and without loading trained weights from other dataset. \emph{Load Weebit} is to load the parameters weights trained in Weebit except the transfer layer. \emph{Load Wiki} is to load the parameters weights trained in Wiki except the transfer layer. }\label{tb:transfer}
	\vspace{-1.0cm}
\end{table}




Besides directly training and evaluating the same dataset, we also tried the model trained using Wikipedia dataset and evaluate on Cambridge English dataset. 10 articles are randomly selected from each level of Cambridge English Test. The probability of being classified as regular English Wikipedia instead of simple English Wikipedia is treated as the  difficulty score. The average difficulty scores predicted by the model are shown in Table~\ref{tb:CEPP}, which shows that our produced readability score implies correctly the difficulty of English documents for different levels of exams. A larger score indicates higher difficulty. These scores correctly indicate the difficulty levels of these exams.


\iffalse
\subsection{Word Representations}\label{sec:embed}


To show the effectiveness of the readability-aware Skip-Gram (R-S-G) for word representations in the readability analysis task, we compare against the approaches where other word representations are adopted, including the original Skip-Gram (S-G) model and directly represent each word using the readability score (1D) defined by Equation~\ref{eq:diff}.


The results in Table~\ref{tbl:word} show the effects from different word representation approaches on several neural models. We have selected HATT which is the best semantic model and HATT+ which is the second-best model as already shown in Table~\ref{tbl:cv} to compare with the proposed hierarchical self-attention model(ReadNet).
As shown from this table, the readability-aware Skip-Gram approach shows better accuracy than original Skip-Gram approach. The improvement is more noticeable for HATT because HATT does not contain word difficulty features while HATT+ and our proposed model already contain the feature \emph{number of syllables per word} to model the word difficulty.
\fi \section{Conclusion and Future Work}
We have proposed a model to evaluate the readability of articles which can make great contributions to a variety of applications. Our proposed Hierarchical Self-Attention framework outperforms existing approaches by combining hierarchical document encoders with the explicit features proposed by linguistics. For future works, we are interested in providing the personalized recommendation of articles based on the combination of article readability and the understanding ability of the user. Currently, readability of articles only evaluate the texts of articles, other modalities such as images \cite{pezeshkpour2018embedding} and taxonomies \cite{chen2018onto} considered to improve readers' understanding. More comprehensive document encoders such as RCNN \cite{chen2019pipr} and tree LSTM \cite{tai2015improved} may also be considered. 

 \newpage
\bibliographystyle{splncs04}
\begingroup
\bibliography{ref}
\endgroup
 


\end{document}
