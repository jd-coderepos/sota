\documentclass{acmsiggraph}                     









\usepackage{multirow}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{eucal}
\usepackage[latin1]{inputenc}
\usepackage[normalem]{ulem}
\usepackage{tabulary}
\usepackage{graphicx}



\newcommand*{\nopicture}[2][0.9\linewidth]{\framebox{\parbox[b][0.6\linewidth][c]{#1}{
      \begin{center}#2\end{center}
      }}
  }

\newcommand*{\nopicturehalf}[2][0.42\linewidth]{\framebox{\parbox[b][0.4\linewidth][c]{#1}{
      \begin{center}#2\end{center}
      }}
  }

\newcommand*{\nopicturethird}[2][0.3\linewidth]{\framebox{\parbox[b][0.33\linewidth][c]{#1}{
      \begin{center}#2\end{center}
      }}
  }

\newcommand*{\nopicturequarter}[2][0.22\linewidth]{\framebox{\parbox[b][0.28\linewidth][c]{#1}{
      \begin{center}#2\end{center}
      }}
  }


\newcommand*{\nopicturedoubleheight}[2][0.9\linewidth]{\framebox{\parbox[b][1.2\linewidth][c]{#1}{
      \begin{center}#2\end{center}
      }}
  }

\newcommand*{\nopicturehalfdoubleheight}[2][0.45\linewidth]{\framebox{\parbox[b][0.8\linewidth][c]{#1}{
      \begin{center}#2\end{center}
      }}
  }

\newcommand*{\nopicturethirddoubleheight}[2][0.3\linewidth]{\framebox{\parbox[b][0.67\linewidth][c]{#1}{
      \begin{center}#2\end{center}
      }}
  }

\def\fat#1{{\textbf{\textit{#1}}}}

\def\scrfat#1{{\textbf{\textit{\scriptsize{#1}}}}}





\DeclareMathOperator{\myspan}{span}
\newcommand{\spn}[1]{\myspan{\{#1\}}}



\newcommand{\inpr}[1]{\left\langle {#1} \right\rangle}
\newcommand{\sinpr}[1]{\langle {#1} \rangle}
\newcommand{\norm}[1]{\left\|{#1}\right\|}
\newcommand{\snorm}[1]{\|{#1}\|}

\newcommand{\clamp}[1]{\left\lfloor{#1}\right\rfloor}
\newcommand{\costh}[1]{\clamp{\bn(x) \cdot \omega_\text{#1}}}
\newcommand{\ccos}[1]{\clamp{\cos #1}}

\newcommand{\Cp}[0]{C_p[S\times\Omega]}
\newcommand{\LS}[0]{L^2[S\times\Omega]}

\newcommand{\balpha}[0]{\boldsymbol{\alpha}}
\newcommand{\bbeta}[0]{\boldsymbol{\beta}}

\newcommand{\hpsi}[0]{\widetilde{\psi}}

\newcommand{\bsymb}[1]{\mathbf{#1}}
\newcommand{\bB}[0]{\bsymb{B}}
\newcommand{\bC}[0]{\bsymb{C}}
\newcommand{\bG}[0]{\bsymb{G}}
\newcommand{\bI}[0]{\bsymb{I}}
\newcommand{\bL}[0]{\bsymb{L}}
\newcommand{\bM}[0]{\bsymb{M}}
\newcommand{\bP}[0]{\bsymb{P}}
\newcommand{\bR}[0]{\bsymb{R}}
\newcommand{\bS}[0]{\bsymb{S}}
\newcommand{\bT}[0]{\bsymb{T}}
\newcommand{\bV}[0]{\bsymb{V}}

\newcommand{\linop}[1]{\mathcal{#1}}
\newcommand{\opI}[0]{\linop{I}}
\newcommand{\opG}[0]{\linop{G}}
\newcommand{\opM}[0]{\linop{M}}
\newcommand{\opP}[0]{\linop{P}}
\newcommand{\opR}[0]{\linop{R}}
\newcommand{\opS}[0]{\linop{S}}
\newcommand{\opT}[0]{\linop{T}}
\newcommand{\opV}[0]{\linop{V}}

\newcommand{\bbee}[0]{\bsymb{b}}
\newcommand{\bc}[0]{\bsymb{c}}
\newcommand{\be}[0]{\bsymb{e}}
\newcommand{\bg}[0]{\bsymb{g}}
\newcommand{\bi}[0]{\bsymb{i}}
\newcommand{\bl}[0]{\bsymb{l}}
\newcommand{\br}[0]{\bsymb{r}}
\newcommand{\bn}[0]{\bsymb{n}}
\newcommand{\bt}[0]{\bsymb{t}}
\newcommand{\bu}[0]{\bsymb{u}}
\newcommand{\bx}[0]{\bsymb{x}}

\newcommand{\C}[0]{\mathbb{C}}
\newcommand{\E}[0]{\mathbb{E}}
\newcommand{\K}[0]{\mathbb{K}}
\newcommand{\N}[0]{\mathbb{N}}
\newcommand{\R}[0]{\mathbb{R}}
\newcommand{\Z}[0]{\mathbb{Z}}

\newcommand{\omegaout}[0]{\omega_\text{out}}
\newcommand{\omegain}[0]{\omega_\text{in}}
\newcommand{\thetaout}[0]{\theta_\text{out}}
\newcommand{\thetain}[0]{\theta_\text{in}}
 
\ifreviewelse {
    \newcommand{\TODO}[1]{{\textbf{TODO:} \textit{#1}}} }{\newcommand{\TODO}[1]{}                        }

\newcommand{\eqnfix}[0]{\par\vspace{-0.8\baselineskip}} \newcommand{\eqnfixb}[0]{\par\vspace{-0.3\baselineskip}} 



\usepackage{graphicx}
\usepackage{color}
\usepackage{wrapfig}
\usepackage{ifthen}
\usepackage[]{algorithm2e}



\usepackage{parskip}



\usepackage[labelfont=bf,textfont=it]{caption}





\title{A massively parallel algorithm for constructing the BWT of large string sets}




\author{Jacopo Pantaleoni\thanks{e-mail: jpantaleoni@nvidia.com}}



\begin{document}

\newcommand{\picresdir}{final}




\maketitle



\abstract

We present a new scalable, lightweight algorithm to incrementally construct the BWT and FM-index of large string sets such as those produced by Next Generation Sequencing.
The algorithm is designed for massive parallelism and can effectively exploit the combination of low capacity high-bandwidth memory and slower external system memory typical of GPU accelerated systems. Particularly, for a string set of  characters from an alphabet with  symbols, it uses a constant amount of high-bandwidth memory and at most  bits of system memory. Given that deep memory hierarchies are becoming a pervasive trait of high performance computing architectures, we believe this to be a relevant
feature.
The implementation can handle reads of arbitrary length and is up to 2 and respectively 6.5 times faster than state-of-the-art for short and long genomic reads.

\section{Introduction}

Recently, BWT and FM-index construction of very large string sets has become an important building block for bioinformatics applications such as \emph{de novo} assembly \cite{Simpson:2011} and compression of large genomic databases \cite{Cox:2012}.
In this context, a few novel lightweight algorithms have been developed to work specifically with very large collections of relatively short DNA strings, substantially outperforming previously known general purpose algorithms \cite{Bauer:2011,Li:2014}.
However, these algorithms are either serial or offer very limited parallelism.
Liu et al \shortcite{Liu:2014} has recently provided a new massively parallel algorithm that exploits the excellent sorting speed of modern GPUs for blockwise suffix sorting \cite{Karkkainen:2007} but the algorithm's speed is strongly limited by the speed at which suffixes can be gathered from the CPU's memory subsystem, which is several times slower than high bandwidth GPU memory. Moreover, Liu et al's \shortcite{Liu:2014} algorithm is not incremental.
This work provides a novel algorithm, {\bf set-bwte}, that drastically reduces the impact of the external
memory speed bottleneck while allowing to incrementally add new strings to pre-existing indices.
The algorithm can be seen as extending and adapting the {\bf bwte} algorithm by Ferragina et al \shortcite{Ferragina:2012} to string sets and modern parallel architectures with deep memory hierarchies.

\section{Overview}

Let  be an ordered alphabet, with .
For a string , we denote its -th symbol with , and its -th suffix with .

The \emph{suffix array} of  is an array  such that  is the index of the -th smallest suffix of , i.e. .
The \emph{Burrows-Wheeler Transform}, or \emph{BWT} of T is a string B defined as:

The BWT of a string set  is defined as the BWT of the string
_0 \dots S_{m-1} \, where we define the special terminator symbols _i)_{0 \leq i < m }\_{m-1} < c_1cB[0 \dots k-1]{0 = j_0 < \dots < j_K = m}S_{j_k} = S[j_k, j_{k+1})MB_{ext}B_{ext}S_{j_k}n          := j_{k+1} - j_kn_{suf} := \sum_{P \in S_{j_k}}{(1 + |P|)}-1S_{j_k}SA_{int}[0 \dots n_{suf}] :=S_{j_k}B_{int}[0 \dots n_{suf}] := B(S_{j_k}, SA_{int})S_{j_k}B_{ext}g[0 \dots n_{suf}] :=S_{j_k}, B_{ext}gg_{sa}[0 \dots n_{suf}] := \{ g[SA_{int}[0]] \dots g[SA_{int}[n_{suf}]]\}B_{int}B_{ext}g_{sa}B_{ext} := B_{int}, g_{sa}, B_{ext}O(|B_{int}|)O(|B_{ext}|)PC[c]B_{ext}P^kiB_{ext}P^{k-1}j = C[c] + rank(c,i,B_{ext})c = P[k-1].B_{int}B_{ext}M(P_i)_{0 \leq i <  M}B_{ext}0 \dots \sum{(|P_j|+1})0 \dots M-1|P_j|+1[0,M-1]k := |P_j|i := n_{ext}jgj + kik > 0k := k - 1c := P_j[k]i := C[c] + rank(c,i,B_{ext})gj + kiB_{int}[i]g_{sa}[i]B_{ext}B_{ext}B_{ext}p/2pPO\sigmamnll = avg_{j_k}(LCP(S_{j_k}))lLO(m l)O(n)O(n \log(n))O( m l + n \log(n) )O( m L + n^2/M )mlnMK = n / Mn^2 / Mnn^2/Mp n \log(n)pn/MnB_{ext}n3n \log(\sigma)2n \log(\sigma)n\log(\sigma)m$ suffixes,
whereas our algorithm allows for an arbitrary block size).
This can be thought of as the dual of the blockwise suffix sorting \cite{Karkkainen:2007} skeleton employed by Liu et al \shortcite{Liu:2014},
which \emph{gathers} sparse input \emph{suffixes} from system memory.
Besides granting a lower asymptotic bound, we empirically observed that the former can be performed more efficiently on contemporary shared memory multi-core architectures,
where all cores share the overall memory system's bandwidth.
It has to be pointed out, however, that the latter is more scalable to small clusters, where each node can keep a copy of the entire input string-set and perform gathers
independently - whereas scattered insertion in a shared database would necessarily involve inter-node communication. We believe the superior single-node performance
and the incremental capability of our algorithm to be interesting tradeoffs against the better inter-node scalability of the slower, non-incremental blockwise suffix sorting
algorithms.

\begin{figure}
\begin{center}
 \includegraphics[width=75.0mm]{pipeline.jpg}
 \caption{Our parallel pipeline visualized as a DAG. The blue boxes are stages performed by the CPU, the green box is performed on the GPU.}
\end{center}
\end{figure}

\section{Aknowledgements}

We thank Jonathan Cohen for insightful discussions and Heng Li for providing the benchmark datasets and initial feedback.

\bibliographystyle{acmsiggraph}
\bibliography{main}
\end{document}
