

\documentclass[conference]{llncs}


\pagestyle{plain}



\usepackage{makeidx}  \usepackage{algorithm}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{epsfig}
\usepackage{proof}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usetikzlibrary{trees,positioning}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color}
\usepackage{lscape}
\usepackage{multirow}
\usepackage{rotating}
\usepackage{url}
\usepackage{subfigure}
\usepackage{appendix}
\usepackage{listings}
\usepackage{subfig}	


\newcommand{\dkall}{\ensuremath{\text{\textsc{dkal}}}}

\newcommand{\fix}[2]{{\bf FIX}\footnote{{\bf #1:} #2}}

\newcommand{\ux}{\ensuremath{\underline x}}
\newcommand{\ua}{\ensuremath{\underline a}}
\newcommand{\us}{\ensuremath{\underline s}}
\newcommand{\ui}{\ensuremath{\underline i}}
\newcommand{\uj}{\ensuremath{\underline j}}
\newcommand{\ual}{\ensuremath{\underline {\alpha}}}
\newcommand{\ut}{\ensuremath{\underline t}}
\newcommand{\ube}{\ensuremath{\underline {\beta}}}
\newcommand{\ue}{\ensuremath{\underline e}}
\newcommand{\uk}{\ensuremath{\underline k}}
\newcommand{\ul}{\ensuremath{\underline l}}

\newcommand{\Charlie}{\ensuremath \mathtt{Charlie}}
\newcommand{\theCA}{\ensuremath \mathtt{CA}}
\newcommand{\Ed}{\ensuremath \mathtt{Ed}}
\newcommand{\Helen}{\ensuremath \mathtt{Helen}}
\newcommand{\CRep}{\ensuremath \mathtt{CRep}}

\newcommand{\canstoredoc}{\ensuremath \mathsf{cans}}
\newcommand{\ishead}{\ensuremath \mathsf{ish}}
\newcommand{\isemployee}{\ensuremath \mathsf{ise}}
\newcommand{\cert}{\ensuremath \mathsf{cert}}
\newcommand{\anything}{\ensuremath \mathsf{anything}}

\newcommand{\contains}{\ensuremath \mathsf{contains}}
\newcommand{\know}{\ensuremath \mathsf{knows}}
\newcommand{\msg}{\ensuremath \mathsf{msg}}
\newcommand{\e}{\ensuremath \mathsf{edge}}
\newcommand{\principal}{\ensuremath \mathit{Principal}}
\newcommand{\infon}{\ensuremath \mathit{Infon}}
\newcommand{\attribute}{\ensuremath \mathit{Attribute}}
\newcommand{\speech}{\ensuremath \mathit{Speech}}
\newcommand{\info}{\ensuremath \mbox{Infon}}
\newcommand{\atoi}{\ensuremath \mathsf{a2i}}
\newcommand{\stoi}{\ensuremath \mathsf{s2i}}


\newcommand{\knowzero}{\ensuremath \mathsf{uknows}}
\newcommand{\said}{\ensuremath \mathsf{said}}
\newcommand{\tdOn}{\ensuremath \mathsf{tdOn}}
\newcommand{\saidinf}{\ensuremath \mathsf{said*}}
\newcommand{\tdOninf}{\ensuremath \mathsf{tdOn*}}

\newcommand{\CRO}{CRO}
\newcommand{\MSC}{\ensuremath \mathit{MSC}}
\newcommand{\MSCCRO}{\ensuremath \mathit{MSC}_\mathit{CRO}}
\newcommand{\acs}{\ensuremath \mathcal{ACS}}



\newcommand{\lm}{\ensuremath \mathit{lm}}






\newcommand{\cM}{\ensuremath \mathcal M}
\newcommand{\cC}{\ensuremath \mathcal C}
\newcommand{\cN}{\ensuremath \mathcal N}
\newcommand{\cSi}{\ensuremath \mathcal S}
\renewcommand{\int}{\ensuremath {\mathcal I}}

\newcommand{\idx}[2][i]{\ensuremath {#1 \in \{1,\ldots,\mbox{}\}}}
\newcommand{\st}{\; \vert \;}


\newtheorem{fact}{Fact}
\newtheorem{condition}{Condition}
\newtheorem{assumption}{Assumption}
\newtheorem{procedure}{Procedure}


\newcommand{\dkalpf}[3]{\ensuremath{\langle #1, #2, #3 \rangle}}
\newcommand{\dkalp}[2]{\ensuremath{\langle #1, #2 \rangle}}
\newcommand{\dkalt}[2]{\ensuremath{#1 \Longrightarrow #2}}

\begin{document}

\title{
Automated Analysis of Scenario-based Specifications of Distributed
Access Control Policies with Non-Mechanizable Activities \thanks{The work presented in this paper was partially supported by the FP7-ICT-2009-5 Project no.~257876,
 ``SPaCIoS: Secure Provision and Consumption in the Internet of
 Services'', and by the ``Automated Security Analysis of Identity and
 Access Management Systems (SIAM)'' project funded by Provincia
 Autonoma di Trento in the context of the ``Team 2009 - Incoming''
 COFUND action of the European Commission (FP7).}
\\
(Extended Version)} 

\author{Michele Barletta, Silvio Ranise, Luca Vigan\`o} 

\institute{Dipartimento di Informatica, Universit\`a di Verona, Italy
\email{\{michele.barletta,luca.vigano\}@univr.it} \\
FBK-Irst, Trento, Italy \\
\email{ranise@fbk.eu} }

\maketitle



\begin{abstract}
  The advance of web services technologies promises to have
  far-reaching effects on the Internet and enterprise networks
  allowing for greater accessibility of data.  The security challenges
  presented by the web services approach are formidable.  In
  particular, access control solutions should be revised to address
  new challenges, such as the need of using certificates for the
  identification of users and their attributes, human intervention in
  the creation or selection of the certificates, and (chains of)
  certificates for trust management.  With all these features, it is
  not surprising that analyzing policies to guarantee that a sensitive
  resource can be accessed only by authorized users becomes very
  difficult.  In this paper, we present an automated technique to
  analyze scenario-based specifications of access control policies in
  open and distributed systems.  We illustrate our ideas on a case
  study arising in the e-government area.
\end{abstract}

\section{Introduction}

Access control aims at protecting data and resources against
unauthorized disclosure and modifications while ensuring access to
authorized users. An access control request consists of a
\emph{subject} asking to perform a certain \emph{action} on an
\emph{object} of a system. A set of \emph{policies} allows the system
to decide whether access is granted or denied by evaluating some
conditions on the attributes of the subject, the object, and the
environment of the system (such as the identity, role, location, or
time). For centralized systems, identifying subjects, objects, and the
values of the attributes is easy since both subjects and objects can
be adequately classified by identifiers that are assigned by the
system itself. For open and distributed systems such as those based on
web technology, the situation is more complex as web servers receive
and process requests from remote parties that are difficult to
identify and to bind with their attribute values. Hence,
\emph{certificates} or credentials, attesting not only the identity
but also the attributes of parties, must be exchanged to correctly
evaluate access control queries. In many situations, the creation and
exchange of certificates require human intervention, e.g., to issue
and sign a certificate or to pick one in a portfolio of available
credentials. Furthermore---as observed
in~\cite{beyond-proof-compliance} among others---in distributed
systems, a certificate can be accepted or rejected depending on the
\emph{trust relation} between the receiver and its issuer. Additional
flexibility can be gained by chains of credentials and trust. In this
context, guaranteeing that only trusted users can access sensitive
resources becomes a daunting task.

\subsection{Main Contributions} 

In this paper, we propose a technique for the automated analysis of
access control systems (ACS) in presence of human activities for the creation
and exchange of certificates together with trust management. Our
approach combines a logic-based language with model checking based on
\emph{Satisfiability Modulo Theories (SMT)} solving. More precisely, we
follow~\cite{constraintdatalog} and use \emph{Constraint Logic
Programming (CLP)} for the specification of policies and
trust management with ideas adapted from~\cite{GurevichNeeman-dkal}. The
exchange of certificates and their interplay with the set of policies
is modeled as a transition system of the type proposed
in~\cite{lietal2005}. We show that interesting
analysis problems of ACSs can be reduced to reachability problems.
Our main contribution is a decidability result for the (bounded)
reachability problem of a sub-class of transition systems that can
encode the analysis of scenario-based specifications of ACSs,
 i.e.\ situations in which the exchange of certificates is
constrained by a given causality relation. Another contribution is a
technique to reduce the number of possible interleavings while visiting
reachable states.

\subsection{A Motivating Example: the Car Registration Office} 
\label{sec:runningexe}

We consider a simplified version of the
\emph{Car Registration Office} (\CRO{}) application in~\cite{BRV-TR09}.
It consists of a citizen wishing
to register his new car via an on-line service provided by the \CRO{}.  
An employee of the \CRO{}, , checks if the request can be accepted according to
some criteria. If so,  must store the request in a central
repository , which, in turn,
checks if  is entitled to do so. 
To be successful, the storage request must be supported by three certificates:  saying
that  is an employee of the \CRO{},  saying that  is the head of the \CRO{} and  saying that  granted  the permission to store documents
in . 
\begin{figure}[t]
\centering
  \includegraphics[scale=.5]{initialstate2}
  \caption{\label{fig:1}The \CRO{} scenario} 
\end{figure}
Roles certificates must be signed by a
trusted Certification Authority () while 's
permission certificate is signed by ; if these were not the case, the
certificates should be rejected because the principal that signed the
properties is \emph{untrusted}. The generation of certificates
(depicted in Fig.~\ref{fig:1}) is a \emph{non-mechanizable} activity
whose execution depends on decisions that are not modeled in the
system but only on the human behavior.  Another issue is how the
certificates are sent to  in order to support 's storage
request.  It can be  to send the certificates along with the
request (user-pull) or it can be  to collect the necessary
certificates upon reception of 's request (server-pull).

\subsection*{Organization of the paper} 
In Section~\ref{sec:ex-overview}, we give an
overview of the main features of our approach, which we then detail in
Section~\ref{sec:DKAL-light} where we
formalize a class of access control schemas.  In Sections~\ref{sec:symb-exec} and \ref{sec:verification}, we present our main contributions: an automated analysis technique of scenario-based specifications and a heuristics for its scalability.
In Section~\ref{sec:conclusions}, we conclude and discuss related  work.
Formal preliminaries, a complete derivation of the \CRO{} main query and an implementation of the scenario by using DKAL language, can be found in the appendix Section \ref{appx}.

\section{Overview of the Main Features of our Approach}
\label{sec:ex-overview}
Our goal is to automatically analyze situations in which (a)
certificates are created or exchanged because of human intervention, (b)
there is a need to reason about chains of credentials to establish the
validity of a certificate, and (c) message exchanges comply with a
causality relation.
\subsection{Certificates and non-mechanizable activities} 
Inspired by~\cite{constraintdatalog,GurevichNeeman-dkal}, we use a variant of
Constraint Logic Programming (CLP) to abstractly represent certificates
as well as to specify and reason about the trust relationships among
principals and the restrictions on delegating the ability to issue
certificates. 
\begin{example}
\label{ex:certsf}
For the \CRO{} scenario, the three certificates depicted
in Fig.~\ref{fig:1} can be expressed as the following CLP facts: 

where  represents the knowledge of
a principal resulting from non-mechanizable activities only,
called \emph{internal} knowledge, and  is a constructor for the
piece of knowledge about the binding of a property (e.g., being an
employee, ) with a principal (e.g., ).
\qed
\end{example}

\subsection{Exchange of certificates among principals} 
\label{subsec:exchangecerts}
Distributed access control is based on exchanging  certificates among principals
so that access decisions can be taken by one principal with all the necessary information. 
So, we need to specify the actions that change the state of the system,
that is the content of the network and the internal knowledge of the principals involved. 
To this end, we use the notion of transition system introduced in~\cite{lietal2005} for
access control systems as follows. The network of messages is modeled by
a ternary predicate  with three arguments: the sender, the payload, and
the receiver of the message. The action of  sending a message with
payload  to  can be written as a transition

where  represents the knowledge of a principal, both
internal and acquired from the reception of messages from other
principals, and  transforms a piece of knowledge into an
assertion that can be communicated to other principals.  The fact that
internal knowledge is knowledge can be expressed by the CLP rule

and the action of  receiving a message from  with  as payload
is written as

where  is a constructor for the piece of knowledge about the
binding of the utterance  with a principal .  
\begin{example}
\label{ex:certs}
For example, the action of  sending the certificate that 
is an employee to  himself can be formalized as an instance of
(\ref{eq:send-action}), the reception of such a certificate by 
as an instance of (\ref{eq:receive-action}), and the derivation that
 knows that  has uttered (and signed) the property about
 being an employee---formally,
---as an
application of fact (F1) and rule
(\ref{eq:internal-knowledge-is-knowledge}).
Notice that  cannot claim to know that he is an employee since he
does not know whether  is trusted on emitting this type of
utterances.  For this, suitable trust relationships should be
specified. \qed
\end{example}

\subsection{Trust relationships among principals} 
\label{subsec:trustrelations}
We use again CLP rules.
One rule is generic while the others are application dependent. The generic rule is

saying that a principal  may expand its knowledge to include the
piece of information  as soon as another principal  has uttered
 and  is trusted on the same piece of
knowledge  (the last part is encoded by the term
).

\begin{example}
\label{ex:rules}
In the case of the \CRO{}, we need also to consider the following four
specific CLP rules, that encode the trust relationships among the
various principals:


 says that a principal  can store documents in the  if he
is an employee of the \CRO{} and his head permits it, 
says that the content of any utterance of the  is trusted, 
 says that an utterance of
a principal repeating an utterance of the  is trusted, and finally 
 says that the head of the \CRO{} is trusted when emitting an utterance
granting permission to store documents in the  to a principal.
\qed
\end{example}





\subsection{Automated analysis of scenarios}
The formal framework sketched above allows us to develop automated analysis techniques to verify the \emph{availability} (policies suitable for scenario's execution) or the \emph{security}  (critical operations performed by trusted principals) of typical
scenarios in which an ACS should operate.  
Availability implies that
the policies are not too restrictive to prevent the scenario to be
executable while security means that only trusted principals are
granted access to sensitive resources or perform sensitive operations.
Both problems can be reduced to check whether, after performing a
sequence of non-mechanizable activities and exchanging messages among
principals, it is possible to reach a configuration of the network in
which an access control query (e.g., in the \CRO{}, ``Can  store
the citizen's request in ?'') gets a positive or a negative
answer.


In other words, we want to solve problems as stated by the following definition: 
\begin{definition}[Reachability problems] 
\label{def:reachprobs}
Given the following conditions:
\begin{itemize}
\item let the network be initially empty (formally,  is
interpreted as an empty relation),
\item   be a set of facts derived
from non-mechanizable activities (e.g., (F1), (F2) and (F3) described in Example \ref{ex:certsf}),	
\item and  be a conjunction of -facts
describing an access control query (e.g.,  for the \CRO{} example)
\end{itemize}
we aim to check if
does there exist a sequence of  instances of the transition rule
(\ref{eq:send-action}) and a sequence  of -facts
derived from non-mechanizable activities, such that  is satisfied in
the final state?
\end{definition}
To practically answer this question, initially we need to compute the fix-point of the facts in  with the CLP rules (\ref{eq:internal-knowledge-is-knowledge}),
(\ref{eq:receive-action}), (\ref{eq:trust-app}) and those formalizing
specific trust relations.  This process must be repeated at each step
 with the facts describing the content of the network
(derived by applying (\ref{eq:receive-action}) at step ), those
in the set , and the CLP rules.  Since more than one transition
(\ref{eq:send-action}) can be enabled at any given step , it is
necessary, in general, to consider several possible execution paths.

Not surprisingly, the reachability problem turns out to be quite
difficult.
Fortunately, in scenarios with constrained message exchanging (e.g., the user-pull or the
server-pull configurations considered for the \CRO{} above), the
reachability problem becomes simpler. It is possible to fix a bound 
of transitions to consider and apply a reduction technique to decrease 
the number of different execution paths to be explored as we will see in 
Sections~\ref{sec:symb-exec} and~\ref{sec:verification}.

\section{A Class of Access Control Schemas}
\label{sec:DKAL-light}

According to~\cite{lietal2005}, we report, in the following, the definition of \emph{access control schema} (in short ).

\begin{definition}[Access Contro Schema]
\label{acss}
An  is a transition system 
 
where  is a set of states,  is a set of queries,  is a set of state-change rules, and  is the relation establishing if a query
 is satisfied in a given state , written as
. 
\end{definition}

For  and , we write  when the change from  to  is allowed by
. The reflexive and transitive closure of 
is denoted by . 

Given an  , an instance  of the
\emph{reachability problem} (see Definition \ref{def:reachprobs}) (where , , and ) consists of asking whether there exists an  such that
 and .


\subsection{The substrate theory } 
\label{subsec:substh}
We define a class of
s by using formulae of (many-sorted) first-order
logic~\cite{enderton} to represent states and transitions. To do this
formally, we need to introduce a \emph{substrate} theory
, i.e., a set of formulae that abstractly specifies the
basic data-structures and operations relevant for both access control
and trust management. The theory contains a (countably) infinite set of
constants of sort  to identify users, suitable operations to
build  values, 
and the functions , , ,  , that have been already informally described in Section \ref{sec:ex-overview}.

Moreover the substrate theory  contains the
predicate symbol  
that intuitively characterizes the set of ``primitive'' attributes, i.e., those already in the substrate that are not created by the ``function''  (e.g.,  for the \CRO{} example).
So, it is necessary to add to the substrate theory the  following axiom  where  is a variable of
sort  and  is a variable of sort
.\footnote{Indeed, the models of the theory considered here
are a super-class of those considered in~\cite{GurevichNeeman-dkal}.
Here, we trade precision for the possibility of designing an automated
procedure for discharging a certain class of proof obligations that
encode interesting security analysis problems for the class of access
control schemas that we are defining.} 
Another important aspect we want to remark is that, even if in this paper we assume, for the sake of simplicity,
the standard situation (see, e.g., \cite{MauSch96}) where insecure communication channels
between each pair of principals are always available, it is easy to extend the substrate theory
by adding axioms to characterize the ``topology'' of the system. 

We recall that the theory
 identifies a class of structures that are models of
all formulae in  and say that a formula  is
satisfiable modulo  iff there exists a model of
 that makes  true.

\subsection{The set  of states} 
\label{subsec:setofstates}
We consider the two predicate symbols
 and  already introduced in Section \ref{sec:ex-overview}. 
We assume the availability of a finite set  of CLP rules, also called
\emph{policies}, of the form


where  and  are tuples of variables,
 is ,  for , and
 is a quantifier-free formula of the substrate theory
.  We assume  to always contain
(\ref{eq:internal-knowledge-is-knowledge}), (\ref{eq:receive-action}),
and (\ref{eq:trust-app}).  Given a set  of constrained ground facts
and the set  of policies, the set  of states contains
all the constrained ground facts obtained by computing the
least-fixpoint  of the ground
immediate consequence operator on  (see,
e.g., \cite{constraintdatalog}).

\subsection{The set  of queries and the satisfaction relation }
\label{subsec:setofqueries}
A \emph{query} is a conjunction of ground facts of the form
. We define  to be the
standard consequence relation  of first-order
logic~\cite{enderton}.

\subsection{The set  of state-change rules} 
\label{subset:setofstatechangerules}
A \emph{state-change
rule} is a formula of the form

that is usually abbreviated as (\ref{eq:send-action}).  Intuitively,
the unprimed and primed versions of  denote the state of the
network immediately before and after, respectively, of the execution
of the state-change rule.  Let  and  be two states in 
and  be a formula of the form (\ref{eq:change-rule-formula}),
then  iff

When , the state-change rule is \emph{enabled} in
; otherwise (i.e., ) it is \emph{disabled in
  }.  This concludes the definition of our class of access
control schema. 

\subsection{Reachability problems} 
In the class of s defined above, 
policies rely on conditions that are
determined by the exchange of messages (cf.\ predicate  and the
CLP rule (\ref{eq:receive-action})) and non-mechanizable activities
(cf.\ predicate  and the CLP rule
(\ref{eq:internal-knowledge-is-knowledge})). The state-change rules in
 can only modify  and leave  unconstrained since
it is very difficult to model how humans decide to
create a certain certificate. 
Returning to the \CRO{} scenario, consider the assertion of fact (F3) as an example of
a certificate that can be created at any time of the execution sequence of the system. 
To emphasize this aspect, we explicitly define the notion of (instance of)  the reachability problem, although technically it can be derived from that of  reachability problem given at the beginning of this
section.

\begin{definition}[Instance of the reachability problem]
\label{def:instofreachprob}
Given a set  of policies and a query , an
  \textbf{instance of the reachability problem} amounts to
  establishing whether there exist an integer  and constraint (ground)
   facts 
   such that
  
where , , , , , and
   denote uniquely renamed copies of , and
  , respectively, and  is the formula obtained
  from  by replacing each occurrence of the symbol  with
  the renamed copy  (for ).  
  \end{definition}

Intuitively,  is the initial knowledge of the
principals computed from their internal knowledge and the (exhaustive)
application of the policies without any exchange of messages (recall
that, initially, we assume that the network contains no messages).
Then,  is obtained from  by first
applying one of the available state-change rule ()
followed by the exhaustive application of the policies that allows
each principal to possibly derive new knowledge from both the
exchanged messages and their internal knowledge.  The
's for  can be similarly characterized.

When there exists a value of  such that
(\ref{eq:bmc}) holds, we say that  is \emph{reachable}; otherwise
(i.e., when, for every , we have that (\ref{eq:bmc}) does not
hold) we say that  is \emph{unreachable}.  If a bound  on  is
known, we talk of a \emph{bounded} reachability  problem (with
bound ). 
Since the reachability problem is undecidable even without
considering non-mechanizable facts (see~\cite{BRV-TR12} for
details) in the rest of the paper, we prefer to focus on identifying restricted
instances of the (bounded) reachability problem that are useful in
practice and can be automatically solved.

\section{Automated Analysis of Scenario-based Specifications} 
\label{sec:symb-exec}
Web service technology supports the development of distributed systems
using services built by independent parties.  Consequently, service
composition and coordination become an important part of the web
service architecture.  Usually, individual specifications of web
services are complemented by scenario-based specifications so that not
only the intentions of individual services but also their expected
interaction sequences can be documented.  Interestingly, as we will
show below, scenario-based specifications can be exploited to
automatically and efficiently analyze security properties despite the
well-known fact that unforeseen interplays among individually secure
services may open security holes in their composition.  The idea is to
associate a scenario with an instance of a bounded reachability
problem and then consider only the sequences of state-change rules
that are compatible with the scenario itself.

\subsection{Scenarios and bounded reachability problem}  

\begin{figure}[t]
  \centering
  \includegraphics[scale=.6]{msc_csf.pdf} 
  \quad\quad\quad
  \raisebox{1.5cm}{{\begin{tabular}{|c||l|}
    \hline
     &  \\ \hline
     &   \\ \hline
     &  \\ \hline
     &  \\ \hline
     &  \\ \hline
     &  \\ \hline
    \end{tabular}}}
  \caption{\label{fig:msc-cro}A user-pull scenario for the \CRO{}:
     sends to  the certificates for a positive answer to
    the query  }
\end{figure}


In our framework, a scenario is composed of a finite set of principals,
some sequences of state-change rules of finite length, and a query 
that encodes an availability or a security property. Since a
state-change rule (\ref{eq:send-action}) to be enabled requires a
principal to have some internal knowledge, this component of the
scenario implicitly identifies a sequence  of non-mechanizable facts where  is
the length of the longest sequence of state-change rules. 

\begin{example}
An example of informal specification of a scenario is the Message Sequence Chart (MSC)
for the \CRO{} depicted on the left of Fig.~\ref{fig:msc-cro} where the
's are the messages containing the utterances in the table on the
right of the same figure. It is easy to find the instance of
(\ref{eq:send-action}) that allows one to send each message . The
solid lines in the MSC impose an ordering on messages while dashed lines
(called co-regions, see, e.g., \cite{rudolph96}) do not. So, for
example,  can send the two certificates (in messages  and
) about the roles of  and  to  in any order and
these two certificates as well as the one sent by  about
granting the permission to store documents in  (in message )
can be received in any order by . For the \CRO{}, the query
 encodes an availability
property saying that the trusted user  can get the permission of
storing the document in . Since the length of sequence of
state-change rules specified by the scenario is , we can build an
instance of the bounded reachability problem with bound  and the
following sequence of non-mechanizable facts: , , , and  for .
Other sequences are compatible with the scenario above, we just picked
one. Such sequences are finitely many and can be exhaustively enumerated.
\qed
\end{example}


\subsection{Decidability of a class of instances of the reachability problem}
 It would be interesting to find conditions that guarantee the
decidability of this kind of instances of the bounded reachability
problem with a given sequence of non-mechanizable facts. Before doing
this, we need to discuss the following four technical conditions on the
substrate theory .

First, 
the fact that there is a finite and known number of principals
in any scenario can be formalized by requiring the substrate theory
 to be such that: 


where  is a finite set of constants of sort . 
This imposes that there are exactly  principals. 

The second condition
concerns the form of the policies:  {for each CLP rule in
, all the variables in its body but not in its head range
over the set  of principals.} 
For the fix-point computation required to solve an instance of the
reachability problem, variables not occurring in the head of a CLP
rule but only in its body must be eliminated by a suitable (quantifier
elimination) procedure (see, e.g.,~\cite{constraintdatalog}).
Assuming that such variables range only over the set  of
principals---cf.~condition (\textbf{C1})---it is possible to replace
each one of them with the constants in  and take disjunction.


The third and fourth conditions state  respectively that:   { must be closed under sub-structures (see Section \ref{app:infprelim} in Appendix) and 
 must be {locally finite} (see Section \ref{app:infprelim} in Appendix). 
Examples of effectively locally finite
theories are the theory of an enumerated data-type or the theory of
linear orders (cf., e.g., \cite{jsc-ftp09}) for more details).
The last two (more technical) conditions allow us to reduce the
satisfiability of a formula containing universal quantifiers (namely,
those in the CLP rules) to the satisfiability of ground formulae by
instantiating variables with finitely many (representative) terms.
This implies the decidability of the satisfiability modulo
 of (\ref{eq:bmc}) (in the definition of reachability
problem) provided that it is decidable to check the satisfiability
modulo  of ground formulae.
\begin{theorem}
\label{thm3}
  Let  be a finite set of policies,  a query, and
   a sequence of non-mechanizable facts ().  If (\textbf{C1}), (\textbf{C2}), (\textbf{C3}), and
  (\textbf{C4}) are satisfied and the satisfiability modulo
   of ground formulae is decidable, then the instance
  of the bounded reachability analysis problem (with bound ,
  sequence  of non-mechanizable facts, and query
  ) is decidable.
\end{theorem}
The proof of this result uses previous work~\cite{jsc-ftp09} (see Section \ref{proof} in the Appendix)
and yields the correctness of the automated analysis technique in
Fig.~\ref{fig:automated-analysis}.  

This is only a first step towards
the design of a usable automated technique.  In fact, at each
iteration of the procedure, the solution of the bounded reachability
problem (at step 1(c)) requires to compute a fix-point and to check
the satisfiability modulo the substrate theory.  Such activities can
be computationally quite expensive and any means of reducing their
number is obviously highly desirable.



\section{A Reduction Technique}  
\label{sec:verification}
The main drawback of the procedure in Fig.~\ref{fig:automated-analysis}
is step 1 that forces the enumeration of all sequences in .
Unfortunately,  can be very large, e.g., there are 12 execution paths of \CRO{}
that are compatible with the MSC in Fig.~\ref{fig:msc-cro}.
To overcome this problem, in the rest of
this section, we design a reduction technique that allows for the
parallel execution of a group of ``independent'' exchanges of messages
so that several sequences of  can be considered at the same time
in one iteration of step 1 in the algorithm of
Fig.~\ref{fig:automated-analysis}. In this way, the number of fix-point
computations and satisfiability checks may be significantly reduced. The
key to this refinement is a compact representation of the set 
based on an adaptation of Lamport's \emph{happened before} relation
 \cite{lamport-comm}. There are many possible choices to
describe , ranging from MSCs (as done in the previous section)
to BPEL workflows for web services augmented with access control
information~\cite{pacibertino}. We have chosen  as a starting
point because it is at the same time simple and general, and simplifies
the design of our reduction technique.

\begin{figure}[t]
\centering
\begin{minipage}{.9\textwidth}
\underline{\textsf{Input}}: a substrate theory , a set
 of policies, and a scenario = (a finite set  of
principals, a set  of sequences of state-change rules of
finite length, a query )\\
\underline{\textsf{Output}}:  is reachable/unreachable\\
\underline{\textsf{Assumptions}}:  (\textbf{C1}), (\textbf{C2}),
(\textbf{C3}), and  (\textbf{C4}) are satisfied
\begin{enumerate}
\item For each sequence :
\begin{enumerate}
  \item Determine the sequence  of
    non-mechanizable facts that enables the corresponding sequence of
    instances of the state-change rule (\ref{eq:send-action}).
  \item Build an instance of the bounded reachability problem with
    bound , the non-mechanizable facts of the previous
    step, and the given query .
  \item Try to solve the instance of the bounded reachability problem
    built at previous step.
\item If one of the instances at the previous step turns out to be
    solvable, return that the query  is reachable.
\end{enumerate}
\item Return that the query  is unreachable (if step 1(d) is never executed).
\end{enumerate}
\end{minipage}
\caption{\label{fig:automated-analysis}Automated Analysis of Scenario-based Specifications (interleaving semantics)}
\end{figure}


\subsection{The Causality Relation} 
 is a means of ordering a set
 of events based on the potential causal relationship of pairs of
events in a concurrent system. Formally,  is a partial order
on , i.e., it is irreflexive, ( for ),
transitive  
(if  and  then  for ), and 
anti-symmetric (if  then  for ). 

Two distinct events
 and  are \emph{concurrent} if  and
 (i.e., they cannot causally affects each other). 
In the usual interleaving semantics, the set of possible executions can be seen as the set of all
linear orders that extend . Formally,  is a linear
extension of  if  is a total order 
(i.e., a partial order that is also total, for every  we have that
 or ) 
that preserves  (i.e., for every , if , then ). 

For example, if ,  and 
are \emph{concurrent}, then both  and  are possible linear extensions since  and  cannot
causally affects each other. Enumerating all the elements of the set
 of linear extensions of the partial order  can
be done in  constant amortized
time~\cite{pruesse-ruskey} and computing  (i.e., counting
the number of linear extensions of ) is
\#P-complete~\cite{brightwell-winkler}.  

In our framework,  is the set of instances
of the state-change rule (\ref{eq:send-action}) considered in a
scenario-based specification. 
Thus, the relation  must be specialized so that
the following two constraints must hold: 
\begin{description}
\item[(\textbf{COMP1})] the
enabledness of concurrent (according to ) instances of
(\ref{eq:send-action}) must be preserved---i.e., two such instances
should not to causally affect each other by enabling (disabling) a
disabled (enabled, respectively) state-change rule,
\item[(\textbf{COMP2})] any execution of the concurrent events in a (finite)
set , each of which causally affects another event  not in ,
results in a state in which  is enabled.
\end{description}
 
These requirements are
formalized as follows.
\begin{description}
\item[(COMP1)] if  is enabled (disabled) in state  then it is
  still enabled (disabled, respectively) in state  for
   and the same must hold when swapping 
  with .
\item[(COMP2)]  is such that  for
  each  
and there is no  such that
  , then  is enabled in  where
   and .
\end{description}
(\textbf{COMP1}) implies that the execution of either  or 
followed by  or , respectively, will produce two identical
states provided that the two executions start from the same initial
state.  
(\textbf{COMP2}) says that once the action of sending a
message is enabled, it persists to be so; this is related to the fact
that of (\ref{eq:send-action}) can only add messages to .
Although (\textbf{COMP2}) seems to be restrictive at first sight, it
is adequate for checking reachability (safety) properties as we do in
this paper.


\begin{definition}[Causality Relation]
A partial order relation  on a finite set  of instances
of (\ref{eq:send-action}) that satisfies (\textbf{COMP1}) and
(\textbf{COMP2}) is called a causality relation.  
\end{definition}

The tuple
 identifies a scenario (, , ) for
 a finite set of principals,  a ground query, and  is
the set of sequences obtained by enumerating all the linear extensions
of  on .  
Since any linear extension of  is of finite length (as
 is acyclic), we will also call  a
scenario.

We observe that when the state  is given, it is possible to show
that both (\textbf{COMP1}) and (\textbf{COMP2}) are decidable (the
proof is similar to that of Theorem~\ref{thm3}).  In practice, it is
not difficult to argue that (\textbf{COMP1}) and (\textbf{COMP2}) hold
for a given scenario.  

\begin{example}
To illustrate this, we reconsider the scenario
informally specified in Fig.~\ref{fig:msc-cro} for the \CRO
\begin{figure}[t] 
\begin{tabular}{ccc}
    \begin{minipage}{2.9cm}
 \\
\quad\quad \\
\ \\
\\

\\

 is the smallest partial order s.t.: \

     \begin{center}
      -  \\
      - \\
      - 
     \end{center}
    \end{minipage} 
    & \quad &
    \begin{minipage}{.75\textwidth}
      {\footnotesize
      \begin{tabular}{|r|l|}
        \hline
         &  
        \\ \hline
         &  \\
                & 
        \\ \hline
         &  \\
                & 
        \\ \hline
         &  \\
                  & 
        \\ \hline
         &  \\
                  & 
        \\ \hline
         &  \\
        & 
        \\ \hline
        \end{tabular}}
    \end{minipage}
    \end{tabular}
  \caption{\label{fig:msccerts}Formalization of the \CRO{} scenario in Fig.~\ref{fig:msc-cro}}
\end{figure}
and recast it in the formal framework developed above, as shown in
Fig.~\ref{fig:msccerts}.  

There is an obvious correspondence between
the entries of the tables in the two figures. 
The message  is the result of executing ,  of ,  of , 
of ,  of , and  of .  There is also a
correspondence between the MSC in Fig.~\ref{fig:msc-cro} and the
causality relation  in Fig.~\ref{fig:msccerts}.  

Now, we
show that the requirement (\textbf{COMP1}) holds for each pair  of
concurrent rule instances in  as follows.  For  and ,
we have that if the latter is enabled (disabled) before the execution
of the first , it remains enabled (disabled, respectively)
after its execution; the vice versa also holds.  Similar observations
hold also for the remaining pairs of concurrent events in .  

Then, we show that the requirement (\textbf{COMP2}) holds for the events  and
 that are such that .  
When  is
executed,  becomes enabled since the fact
 holds as the result
of executing : by the CLP rule (\ref{eq:receive-action})
it is possible to derive 
that is precisely the enabling condition of .  Similar observations hold for
 and  as well as  and .  Intuitively,
 formalizes the obvious remark that, before  can forward
a certificate to  (about his role, 's role, or the
permission to store documents), he must have preliminarily received it
regardless of the order in which he has received the certificates from
 and .\qed
\end{example}

\subsection{A reduction technique based on causality relations.} 

So far, we have shown that a causality relation can be exploited to compactly
specify a scenario. Here, we show how it can be used to dramatically
reduce the number of fix-point computation and satisfiability checks
required by the analysis technique in
Fig.~\ref{fig:automated-analysis} while preserving its
completeness. The key idea is the following. 

Since pairs of concurrent
rule instances cannot causally affect each other, it is possible to
execute them in \emph{parallel}, i.e.\ adopting a partial order
semantics. In fact, any linearization of the parallel execution, in
the usual interleaving semantics, will yield the same final state
obtained from the parallel execution. This has two advantages. 

First,
a single parallel execution of concurrent events correspond to a
(possibly large) set of linear executions. Second, the length of the
parallel execution is shorter than those of the associated linear
executions.  The number of fix-point computations and satisfiability
checks needed to solve a bounded reachability problem can be reduced
depending on the degree of independence of the rule instances in the
scenario. The price to pay is a modification of the definition of
reachability problem (cf.~the end of Section~\ref{sec:DKAL-light}) to
adopt a partial order semantics. We explain in more detail these ideas
below.

Let  be a (finite) set of policies and  a scenario, where  is a finite set of principals,  is a
finite set of rule instances of (\ref{eq:send-action}),  is
a causality relation, and  a query.  



\begin{definition}[Reachability problem with partial-order semantics compatible
  with the causality relation ]
  \label{def:reachprobswithpartorder}
An instance of this problem 
amounts to establishing whether there exist an integer  and (ground) constraint facts
  s.t.~,
where ,
, and

for  such that any pair  is of
concurrent events ( and ).
\end{definition}


Definition \ref{def:reachprobswithpartorder} is
almost identical to to the Definition \ref{def:instofreachprob}. The main
difference is in allowing the execution of a sequence 
of exchange of messages provided that these are pairwise concurrent
with respect to the causality relation.  Intuitively, we cumulate the
effect of executing the instances  of
(\ref{eq:send-action}) in a single step so that each principal can
derive more knowledge from the exchange of several messages than the
exchange of just one message as it was the case with the definition of
reachability problem in Section~\ref{sec:DKAL-light}.

With this new definition of reachability problem, we propose a
refinement in Fig.~\ref{fig:automated-analysis-refinement} of the
analysis technique in Fig.~\ref{fig:automated-analysis}.
\begin{figure}[t]
\centering
\begin{minipage}{\textwidth}
\underline{\textsf{Input}}: a substrate theory , a set
 of policies, and a scenario
 = (a finite set  of
principals, a finite set  of instances of (\ref{eq:send-action}), a causality relation , a query )\\
\underline{\textsf{Output}}:  is reachable/unreachable\\
\underline{\textsf{Assumptions}}:   (\textbf{C1}), (\textbf{C2}),
(\textbf{C3}), (\textbf{C4}), (\textbf{COMP1}), and (\textbf{COMP2}) are satisfied
\begin{enumerate}
\item Let  be the causality graph associated to
  .
\item Compute the set  of nodes in  with no
  incoming edges and  be the set of rule instances of
  (\ref{eq:send-action}) in  labeling the nodes in .
\item Determine the set  of non-mechanizable facts that enables
  all the rule instances in .
\item Set  and while the set of nodes in  is
  non-empty do
  \begin{enumerate}
    \item Delete from  all the nodes in  and the
      edges whose sources are in  and increment  by .
    \item Compute the set  of nodes in  with no
      incoming edges and  be the set of rule
      instances labeling the nodes in .  
  \end{enumerate}
\item Build an instance of the bounded reachability problem with
  partial order semantics compatible with the causality relation
   with bound , sequence  of
  non-mechanizable facts where  for , and the input query .  At each step  of the bounded
  reachability problem, the rule instances in  must be used
  for parallel execution.
\item If the instance of the bounded reachability problem is solvable,
  then return that the query  is reachable; otherwise, return that
   is unreachable.
\end{enumerate}
\end{minipage}
\caption{\label{fig:automated-analysis-refinement}Automated Analysis of Scenario-based Specifications (partial order semantics)}
\end{figure}
The main differences between the two techniques are the following.  In
input, the scenario is given by using the notion of causality relation
in order to exploit the new definition of reachability problem with
the partial order semantics.  Then, instead of considering all the
possible linear extensions of  (as in
Fig.~\ref{fig:automated-analysis}), sets of pairwise concurrent events
for parallel execution are computed by using the causality relation.
The idea is to use the Hasse diagram , called the
\emph{causality graph} in the following, associated to ,
i.e.\ the transitive reduction of the relation  seen as an
oriented graph.  The crucial observation is that concurrent events can
be identified by looking at those nodes that are not connected by a
path in the causality graph.  Formally, we need the following notion.
An element  is \emph{minimal} in  with respect to  iff
there is no element  such that .  Since  is
finite, minimal elements of  must exist (this is a basic
property of partial orders over finite sets).  In step 2, the rule
instances labeling the minimal elements in  with respect to
, that correspond to nodes with no incoming edges in the
causality graph, are the only that require non-mechanizable facts for
them to be enabled.  In fact, all the rule instances labeling
non-minimal elements with respect to the causality are enabled by the
execution of one or more rule instances that label ancestor nodes in
the causality graph, because of (\textbf{COMP2}).  This is why we
compute  in step 3 while all the other sets of non-mechanizable
facts are vacuosly set to  in step 5.  The rule
instances in  labeling the nodes in  are concurrent
because of (\textbf{COMP1}).  In step 4, we exploit this observation
to compute the other set of concurrent rule instances that can be
executed in parallel by modifying the causality graph: the nodes and
the edges whose sources are in  are deleted from 
so that a the set  of nodes with no incoming edges can be
identified.  The rule instances in  labeling the nodes in
 are the new concurrent events that can be executed in parallel
and so on.  The procedure eventually terminates when no more nodes are
left in the causality graph.  Then, in step 5, the new definition of
bounded reachability problem compatible with the causality relation
 can be exploited by using the sets 
of rules instances to be executed in parallel.  If the instance is
solvable then the query  is reachable, otherwise it is unreachable.
The correctness of the refined analysis in
Fig.~\ref{fig:automated-analysis} stems from the fact that, by
definition of causality relation, there exists an execution in the
interleaving semantics for the concurrent events executed in
parallel---because of (\textbf{COMP1})---and the execution of rule
instances that must happen before (with respect to ), enable
the execution of those that happen afterwards---according to
(\textbf{COMP2}).

We briefly illustrate how the refined version of the automated
analysis works on the scenario in Fig.~\ref{fig:msc-cro} of the
\CRO{}.  According to the causality relation in
Fig.~\ref{fig:msccerts}, , and  are minimal
elements of  (step 2).  Thus, the non-mechanizable fact
 enabling their execution is the conjunction of the following
three facts: ,
, and .  Deleting the nodes labeled by , and  with the corresponding edges in the causality
graph leaves us with a graph containing three isolated nodes labeled
by , and  that can be executed in parallel.
As a consequence, the bound of the reachability problem is  in
which, initially, the parallel execution of , and
 is enabled because of the non-mechanizable facts in 
while the parallel execution of , and  is
enabled, in the following step, because of the three new certificates
available in the net.  Even in this simple example, the savings of the
reduction technique are important: the two-step parallel execution
corresponds to 
 interleavings executions that must be considered
when using the technique in Fig.~\ref{fig:automated-analysis}.

We have implemented a prototype of the procedure above in
WSSMT~\cite{BCRVZ} that uses the SMT solver Z3~\cite{z3} for fix-point
computation and SMT solving.  The time taken to analyze the scenario
in Fig.~\ref{fig:msccerts} with this prototype is negligible; larger
examples are discussed in~\cite{BCRVZ}.

\section{Discussion}
\label{sec:conclusions}
We presented an automated technique to analyze scenario-based
specifications of access control policies in open and distributed
systems that takes into account human activities.  It uses an instance
of CLP to express policies and trust relationships, and reduces the
analysis problem to fix-point computations and satisfiability checks.
The first contribution is the decidability of the analysis of
scenario-based specifications of ACSs.  The second contribution is a
reduction technique that allows us to make the decidability result
useful in practice.\\






There are three main lines of research that are related to our work. 
First, several logic-based frameworks
(e.g.,~\cite{lietal2005,GurevichNeeman-dkal,becker,hurlin,asiaccs11,jsc-ftp09})
have been proposed to specify and analyze authorization policies with
conditions depending on the environment of the system in which they
are enforced.  In principle, it is possible to consider the conditions
depending on the execution of human activities as part of the
environment and then re-use the available specification and analysis
techniques.  The problem in doing this is that the conditions for the
execution of human activities are not explicitly modeled in the
system so that their applicability is unconstrained. This results in
a dramatic increase of the search space that makes the application of
the available technique difficult, if possible at all.  We avoid this
state-explosion problem by considering scenario-based specifications
that allow one to focus on a small sub-set of the possible sequences of
events, as explained in Section~\ref{sec:verification}.  It would be
interesting to adapt the abduction techniques
in~\cite{becker-abd,hurlin} to identify which non-mechanizable facts
need to be generated for the executability of complex scenarios in
which condition (\textbf{COMP2}), about the ``monotonicity'' of the
events (Section~\ref{sec:verification}), does not hold.

The second line of research is related to workflow analysis in
presence of authorization policies, e.g.,~\cite{pacibertino,crampton}.
On the one hand, such works specify the workflow as a partial ordering
on tasks that is similar to the causality relation introduced here.
On the other hand, these works abstract away the data-flow so that
there is no need to specify compatibility conditions on the causality
relation (cf.~(\textbf{COMP1}) and (\textbf{COMP2}) in
Section~\ref{sec:verification}) as we do here because of the modelling
of the exchange of messages among principals.  Another difference is
that the specification of authorization policies is reduced to a
minimum in~\cite{pacibertino,crampton} so as to simplify the study of
the completion problem, i.e., whether there exists at least one
assignment of users to tasks that allow for the execution of the whole
workflow.  Instead, we focus on reachability problems and we model,
besides authorization policies, also trust relationship among
principals.  It would be interesting to study the decidability of the
completion problem also in our richer framework.  

The third line of research concerns the development of (semi) formal techniques
for the analysis of human interventions.
In \cite{diaper90,suokas85} the authors aim to determine how a task is executed by
humans and what special factors are involved to accomplish the goal
the task is supposed to achieve. This line of work is based on informal methods 
to identify and analyze human actions in contrast to our framework that is based
on a logical formalism. 
In \cite{shin06} the authors use graphs and deterministic finite state automata
to model and analyze human behaviors in critical systems.
Although we share the proposed formal approach with them, our framework differs for the capability to analyze systems influenced by non predictable human activities, 
in contrast with those predefined for industrial material-handling processes.
Interesting works in modeling and reasoning about human operators 
are, e.g., \cite{yasmeen11,gunter09}, where the analysis is based on concurrent game structures, a formalism similar to the  we used in Section~\ref{sec:DKAL-light}.
The accurate verification analysis and the decidability result we presented in this paper 
are the major difference that distinguishes our work from their.



\bibliographystyle{abbrv}
\bibliography{biblioext}



\section{Appendix}
\label{appx}
\subsection{Formal preliminaries}
\label{app:infprelim}

We assume some familiarity with the syntactic and semantic notions of
first-order logic~\cite{enderton} and Constraint
Datalog~\cite{constraintdatalog}.

Let  be a signature, i.e., a collection of function and predicate symbols with their arities. 
A \emph{-expression} is an expression (a term, an
atom, a literal, or a formula) built out of the symbols in 
where at most the variables in the sequence  may occur
free. 
We write  to emphasize that  is a
-expression. 
For two disjoint sequences of
variables  and , we write
 to denote their concatenation. 

A -structure  is a \emph{sub-structure} of a
-structure  iff the domain of  is
contained in the domain of  and the interpretations of
the symbols of  in  are restrictions of the
interpretations of these symbols in . A class
 of -structures is \emph{closed under
  sub-structures} iff for every structure , if  is a substructure of 
then . 

Let  and  be two
signatures such that . If  is a
-structure, then  is the \emph{reduct}
of  obtained from  by forgetting the
interpretations of the symbols in .

A \emph{-theory}  is a set of -formulae, called
\emph{axioms}. A -theory  identifies a class
 of -structures that are models of all
formulae in . For each theory  considered in the paper, we
assume that  and we then say that 
is \emph{consistent}. 

A -formula  is
\emph{-satisfiable} iff there exists a -structure
, also called a \emph{-model},
such that . The \emph{satisfiability modulo theory 
  problem}, in symbols, , consists of establishing
the -satisfiability of any quantifier-free -formula. 

A -theory  is \emph{locally finite} if  is finite
and, for every set of constants , there exist finitely
many ground terms , called
\emph{representatives}, such that for every ground -term , we have  for some . If
the representatives are effectively computable from 
and  is computable from , then  is \emph{effectively}
locally finite. 
A theory  admits \emph{quantifier elimination} if for an arbitrary formula ,
possibly containing quantifiers, one can compute a -equivalent
quantifier-free formula .

A formula of the \emph{Bernays-Sch{\"o}nfinkel-Ramsey} (BSR) class is of
the form , where  are (disjoint) tuples of variables and  is a
quantifier-free formula built out of a signature containing only
predicate and constant symbols (i.e., no function symbol occurs in
). Formulae of the BSR class where  is empty are
called \emph{universal}, whereas when  is empty they are
called \emph{existential}. It is easy to show that any theory whose
axioms are universal BSR formulae is effectively locally finite. Satisfiability of
BSR formulae is well-known to be decidable~\cite{ramsey}.

Let  be a -theory and  a tuple of predicate
symbols not in . A \emph{-formula} is a formula
of the form , where  is a
quantifier-free -formula,
, and . Universal and existential
-formulae are defined analogously to the corresponding
sub-classes of BSR formulae. A -formula  is
\emph{-satisfiable} iff there exists a
\,-structure  that satisfies 
and whose reduct  is in .

\begin{theorem}[\cite{jsc-ftp09}]
  \label{th:dec-ext-BSR}
  Let  be an effectively locally finite -theory whose class of models is
  closed under sub-structures, the SMT() problem be decidable, and
   be a finite set of predicate symbols such that
  .  Then, the satisfiability
  of -formulae is decidable.
\end{theorem}

Let  be a -theory.  A \emph{constraint Datalog rule} is a
formula of the form

also written as

where  is an atom for ,
 is a quantifier-free
-formula, called the
\emph{constraint} of the rule, and  are
disjoint tuples of variables; when , the constraint Datalog rule is
also called a \emph{constraint fact}.

The \emph{non-ground Herbrand base} of a set  of constraint
Datalog rules is the set of constraint facts modulo equality. The
\emph{non-ground immediate consequences operator}
 is defined over a collection of constraint
facts  as follows:  contains all the
constraint facts of the form  when  is in ,  is in  for , and  is logically equivalent
(in ) to , where it is implicitly
assumed that the variables in the rule and those in the constraint facts
have been renamed so as to make them pairwise disjoint. It is possible
to show the existence of the least fix-point
 of , which may
be infinite.

It is sometimes possible to show that
 is finite. Let  admit
quantifier-elimination. Let  be a
constraint Datalog rule and  be a constraint fact for  a
-quantifier-free formula,  the arity
of , and . A \emph{constraint rule application}
produces  facts of the form  where  is a quantifier-free
-formula for  () and
 is equivalent (by the elimination of
quantifiers in ) to the formula

where  is the tuple of variables occurring in the body
of the rule but not in the head.  The algorithm to compute the least
fix-point of a set of constraint Datalog rules is given in
Fig.~\ref{fig:fixpoint-comp}. The function  terminates when all
derivable new facts are implied by previously derived facts so that
the least fix-point is reached.
\begin{theorem}[\cite{jsc-ftp09}]
  \label{coro:fixpoint-termination}
  Let  be an effectively locally finite theory that admits
  elimination of quantifiers.  Then, 
  terminates returning a finite set of constraint facts.
\end{theorem}

\begin{figure}[t]
\footnotesize
  \centering
    \begin{minipage}{.3\textwidth}
      \begin{tabbing}
        foo \= foo \= foo \= foo \= foo \= foo \= foo \= foo \= foo \= foo \= \kill
        \textbf{function}  \\
        1 \> ;  ; \\ 2\> \textbf{while}  \textbf{do}\\
        3\>\> \\
        4\>\> \textbf{foreach}  \textbf{do} \\ 
        5\>\>\> \textbf{foreach}  of constraint facts constructed from   \textbf{do}\\
        6\>\>\>\>  constraint facts obtained by constraint rule  \\
        \>\>\>\> \hspace{2.05cm} application between  and  \\
        7\>\>\>\> \textbf{foreach}  \textbf{do} \\ 
        8\>\>\>\> \textbf{if}  \textbf{then} \\ 
        9 \>\>\>\> \\
        10\>\>\>\> \textbf{end} \\
        11\>\>\>\textbf{end}\\
        12\>\>\textbf{end}\\
        13\>\textbf{end}\\
        14\>\textbf{return} 
      \end{tabbing}
    \end{minipage}
  \caption{\label{fig:fixpoint-comp}Least fix-point computation of
    constraint Datalog rules (adapted from~\cite{constraintdatalog}):
     is a set of {constraint facts} and  is a set of {constraint
      Datalog rules.}}
\end{figure}


\subsection{Proof of Theorem~\ref{thm3} }
\label{proof}
\begin{proof}
  By considering Definition \ref{acss} in Section \ref{sec:DKAL-light}, let  be a sequence (possibly containing repetitions) of elements in .  Since  is finite, there
  are finitely many sequences of elements of length . 
  Thus, we can enumerate all of such sequences.  
  Since the value of  is given together with the collection  of
  non-mechanizable facts, it is possible to compute the least fixed point of the set
   of constraints in (\ref{eq:bmc}) by repeatedly
  invoking the function  of
  Fig.~\ref{fig:fixpoint-comp} in Section \ref{app:infprelim} as follows.  Let
   
be the set of constraint facts, generated from the initial state of the system, 
  where  has been obtained from 
  by replacing each constraint Datalog rule  with the set
   where  ranges over the mappings that
  associate the variables occurring in the body of  but not in the
  head of  with the constants of sort  in , 
  satisfying the (\textbf{C1}) requirement.


By Theorem~\ref{coro:fixpoint-termination} in Section \ref{app:infprelim}, the invocation to
   terminates returning the finite set
   of constraint facts.  
  In fact, both  and  are constraint facts,
   is a set of constraint Datalog rules,
  and the substrate theory  satisfy the (\textbf{C4}) requirement.  
  Note that there is no need to eliminate quantifiers during a constraint rule application as all the variables
  occurring in the body of a constraint Datalog rule of
   occur also in its head.  We are
  thus entitled to conclude that  and 
  defined in \eqref{eq:bmc} are equal (modulo variable
  renaming).  Then, let
  
 
   and  are obtained from  and 
  by replacing  and  with  and ,
  respectively.  
  
  Note that  is finite if 
  is so.  Also, the satisfiability of formulae over a signature
  extended with fresh constants is decidable when the satisfiability
  problem of the theory over its original signature is
  decidable~\cite{TinelliZarba}.\footnote{Note that we can extend
    the signatures with fresh (Skolem) constants since we consider all
    the classes of models of the substrate theory .
    The least fix-point semantics is used only when considering the
    constraint Datalog rules specifying the policies, not the
    substrate theory.}  Thus, since the
  -satisfiability is decidable by assumption, it is
  also decidable to check whether  is
  -satisfiable. Hence, we are entitled to conclude
  that  is finite
  since  is so. It is now easy to see that
   terminates for reasons that are
  similar to those discussed for the computation of .
  The only difference is in the constraint Datalog rules derived from
   for which it is not
  difficult to verify that the variables occurring in the body also
  occur in the head; thereby making it unnecessary to eliminate
  quantifiers as for . Thanks to basic properties of
   (see \cite{constraintdatalog}), we can derive that  is equal
  (modulo variable renaming) to .  By a straightforward
  induction, generalizing the previous observations on ,
  it is possible to show that  is a finite set of
  constraint facts equal (modulo variable renaming) to
  , for .

  We are thus left with the problem of checking the
  -satisfiability of the (finite) set 
  for constraint facts, for some .  This can be done as
  follows.  For each constraint fact  in
  , form the formula  by taking the disjunction
  of all 's for .  Then, take the disjunction of all
  the formulae  built at the previous step and build the
  quantifier-free formula .  The satisfiability of the
  -formula  is indeed decidable
  thanks to Theorem~\ref{th:dec-ext-BSR} in Section \ref{app:infprelim}. This concludes the proof.  
\end{proof}



\subsection{Main derivation of \CRO{} scenario}
\label{CR}

In this section, we illustrate the access control layer underlying (a
simplified version of) an e-Government application, first described
in~\cite{avantssar}. We already have a description of the \CRO{} case study in
the body of the paper (see Section~\ref{sec:runningexe}) and here we
show, step by step, the derivation process of its main access control query 
.



\begin{figure}[t] \center
 \subfigure[Informal view of state ]{\includegraphics[scale=.38]{scenarioD51}}\qquad\qquad\qquad
\subfigure[Certificate passing (first step) ]{\includegraphics[scale=.55]{certformulas1}}\qquad\qquad 
\caption{\CRO{} certificate passing representation up to state  \label{fig:CRO1}}
\end{figure}


A scenario of a possible run of the system is illustrated in
Fig.~\ref{fig:CRO1}(a) where, in the displayed state, the three
certificates (), () and () are in 's possession can be derived from the set of non-mechanizable facts as described in Example \ref{ex:certs} of Section \ref{subsec:exchangecerts}.\footnote{Some of the details of
the figure will be made clear below, e.g., the numbering of the states
and the fact that we only show the most interesting states of the
system.}
This is the result of the sending of three messages , , and 
(labeling the arrows in Fig.~\ref{fig:CRO1}(a)) as a consequence of the threefold application of the state-change rule \eqref{eq:send-action}.

After the successful processing of a car registration request,  is
willing to permanently store it in . In order to do this, he
should comply to the  policy that regulates access to its central
database. The decision of  to grant or deny to employees of a
\CRO{} the right to store a processed request in the database is based
on the rules ()--() described in Example \ref{ex:rules} of Section \ref{subsec:trustrelations} 
that we report again, informally, as follows: 
\begin{enumerate}
\item[()] an employee of a \CRO{} can store documents in the ,
if the head of the \CRO{} permits it.
\end{enumerate}
Since the application of () is based on valid certificates, further
policy regulations must specify the trust relationships that allow
 to validate the certificates in its possessions. Such rules are:
\begin{enumerate}
\item[()] certificates signed by  are trusted by anyone, 
\item[()] any certificate signed by  and countersigned by any
principal is trusted as one being signed by  itself, and 
\item[()] concerning the certificates about the permission of storing
documents, the head of a \CRO{} is trusted by anyone.
\end{enumerate}

In order to satisfy the access policies ()--() of ,  is
supposed to forward to  the certificates 
in its possession, after signing each one of them. We want to remark that we preserve the countersign action
as described in the original scenario definition in \cite{avantssar}. As widely discussed in \cite{BRV-TR09},
the role of  is not purely passive but can potentially check the digital signatures of principals 
involved. Even if it is not relevant for our purposes in this paper, it is important to underline the capability of our formalization to model
more complex classes of scenarios.
After receiving 's certificates,  should be able to
grant him the right to store documents in its internal database using all the information
in its possession.






We want to define the \CRO{} scenario as an instance of the  in Definition \ref{acss}.
So, we proceed defining each element of the transition system.

 Let  the effectively locally finite substrate theory underlying the \CRO{} 
as described in Section \ref{subsec:substh}, we take    and  as the two (countably) sets of constants of sort  and  to identify the four principals depicted in
Fig.~\ref{fig:CRO1}(a) and the attributes of being an employee, being an head and
having the right to store a document in the database, needed to built the initial certificates. 
The elements of  depend on the application we are considering and 
to characterize this set as particular primitive elements (not created by the ``function'' ) we have to add to the set  the following axioms:

as described in Section \ref{subsec:substh}.

We proceed with our formalization considering the set  of -atoms
and the set  of -atoms to represent the \textit{state} of the system according to Section \ref{subsec:setofstates}.
The initial situation is represented by the three non-mechanizable facts (as introduced in the Example \ref{ex:certsf}): 

generated by the (arbitrary) human activities of  and , in order to put into the system the credentials needed to fulfill the established goal.
Considering the content of the network we define a state to be to be \textit{initial} if .

Let  be the set of -formulae \eqref{eq:send-action}, \eqref{eq:internal-knowledge-is-knowledge}, \eqref{eq:receive-action}, together with axioms described according to Section \ref{subsec:substh} and application-dependent CLP rules ()-() of Example \ref{ex:rules},
where  and  are variables of sort \mbox{Principal} and  is a
variable of sort . 
Clauses (), () and (), stating the
trust relationship between the various principals, are required to
derive the hypotheses of () in combination with the use of rule
\eqref{eq:trust-app}, as we will see below.

We have now all the information to define the \CRO{} case study as an instance of the  according to Definition \ref{acss}. \\

  Let  be the \CRO{}- with substrate
  theory , where:
\begin{itemize}
\item  is the goal  that must be satisfied, 
\item (), (), () are the non-mechanizable facts declared above,
 \item  represents the first-order formula describing the initial state,
 \item  is the set of -formulae according to the definition above,
 \item  is a (finite) set of state-change rules of the form of (\ref{eq:change-rule-formula}).
\end{itemize}  
  
We can now easily describe the execution of the system representing and collecting the set  of states,
by means of the two predicate symbols  and  which model the \textit{dynamic} part of the access control, unlike the \textit{static} one modeled by the first-order theory  previously defined. 

We will write  for a generic state, to represent the set . 

\begin{figure}[t] 
  \centering
   \includegraphics[scale=.38]{initialstate2}
  \caption{\CRO{} representation of the non-mechanizable facts  in the \textit{initial} state  }
      \label{fig:CROinit}
\end{figure}

The initial situation in Fig.~\ref{fig:CROinit} (that for convenience we report here again) can be formalized by the following initial (symbolic) state:
  
 


Now, applying the rule (\ref{eq:internal-knowledge-is-knowledge}) in Section \ref{subsec:exchangecerts} and computing the fixed point by the  procedure described in Fig. \ref{fig:fixpoint-comp}, 
we derive the following constraint facts: , , and .



 At this point, we are ready to obtain the state  depicted in Fig.~\ref{fig:CRO1}(a) by
repeatedly applying (three times) the state-change rule (\ref{eq:send-action}).
Considering the grounding substitution , we have the
  following instance of (\ref{eq:send-action}):
  
  which is clearly enabled in . The application's effect of  on the constrained facts 
  just calculated in  leads to
  
  where .
  
It is not difficult to see
  that two further applications  (where  are suitable ground substitutions) of
  (\ref{eq:send-action}) allow us to obtain state
  
  which is the formal counterpart of the configuration depicted in Fig.~\ref{fig:CRO1}.  
  
  It is also immediate to see that the repetitive application of the function  in Fig.~\ref{fig:fixpoint-comp} to states  and  generates the following three
  facts (by repeatedly applying clause (\ref{eq:receive-action})):
 
 representing the formal counterpart of certificates (), () and () in Fig. \ref{fig:CRO1}(b).

\begin{figure}[t] \center
 \subfigure[Informal view of state ]{\includegraphics[scale=.38]{scenarioD51_2}}\qquad\qquad\qquad
\subfigure[Certificate passing (second step)]{\includegraphics[scale=.55]{certformulas2}}\qquad\qquad 
\caption{\CRO{} certificate passing representation up to state  \label{fig:CRO2}}
\end{figure}

Applying again the reasoning introduced up to now, 
these last three facts can be used by  to counter-sign the
  certificates and send them to  as depicted in
  Fig.~\ref{fig:CRO2}(a) (by appropriate instances  of rule
  (\ref{eq:send-action}) with  suitable ground substitutions), thereby deriving the
  state
   
  which is the formalization of the configuration in Fig. \ref{fig:CRO2}, where  abbreviates the second component of the state  above. 
At the end of each single application of the state-change rule \eqref{eq:send-action}, the function 
returns (by using clause (\ref{eq:receive-action})) the set of certificates (),() and () represented in Fig.\ref{fig:CRO2}(b). 

 Once the application has reached the state , it is possible for  to
 take the decision to grant or deny to 
the permission to store the processed request in the database.
To this end, we need to validate the certificates that are in possession of
 against the chain of trust relationships represented by the Horn
clauses ()--(). More specifically, first, we consider the trust
relationships concerning the certificates about the roles of the
principals (), () and then the certificate about the permission to store
documents in the database, (). Formally, this can be done by using the Horn
clause (\ref{eq:trust-app}) introduced in Section \ref{subsec:trustrelations}.  

In the
following, we describe which instances of (\ref{eq:trust-app}) need to
be considered and how their hypotheses are discharged.
In order to positively answer the query , we consider the following
instance of (): 

let us call it () (to recall the goal of the reachability analysis problem of Section \ref{sec:DKAL-light}).  We have the problem of discharging the three hypotheses of (), which can be grouped in two categories.  In fact,
the first two concern the roles of the principals (in particular, the
fact that  should be an employee and that  be the head of
the Car Registration Office), while the last is about the permission of
storing documents in the central repository.  We consider each
category in detail.  \\


\paragraph{Validation of certificates about the roles of principals}

Intuitively, we need to apply () and () so as to enable  to
derive the pieces of knowledge that  is an employee (fact ()
below) and that  is the head of the Car Registration Office
(fact () below). Indeed, in the derivation, the certificates () and
() will be used which, in turn, are obtained from () and () via
the applications of the state-change rule (\ref{eq:send-action})
described above. We begin by considering the following instances of
(\ref{eq:trust-app}):

\begin{small}

\end{small}

\noindent 
and notice that the first hypotheses are identical to () and ()
respectively.  The second hypotheses of the two instances above are
identical to the following two instances of ()  and 
.  
So, we are entitled to consider the heads of the two instances of
(\ref{eq:trust-app}) above as derived ground facts; let us call them
() and (), respectively.  Then, consider two more instances of
(\ref{eq:trust-app}):


The first hypotheses of these two ground Horn clauses are identical to
() and () respectively. 

Their second hypotheses are
identical to the following two instances of ()  and
.
As a consequence, we can consider the heads of the last two instances
of (\ref{eq:trust-app}) as derived ground facts; let us call them 
() and (), respectively. 

\paragraph{Validation of certificates about the permission of storing
  documents}  Intuitively, we need to apply () so as to make
immediately available to  the knowledge about the authorization
state concerning the fact that  is permitted to store documents
in the central repository by  (fact () below).
We begin by considering the following instance of ():

\begin{small}

\end{small}

\noindent
Since the hypothesis of this Horn clause is identical to (), we are
entitled to consider the head of this clause as a derived fact; let us
call it ().  Then, consider the following instance of
\eqref{eq:trust-app}:

\begin{small}

\end{small}

\noindent
The first hypothesis of the instance is identical to () and the
second hypothesis is equal to (); thus, we can consider its head as
a derived ground fact, let us call it ().

\paragraph{Putting things together}  At this point, it is sufficient to
observe that the first hypothesis of () is (), the second is (),
and the last is () so that we can consider the head of the rule as a
derived ground fact which is precisely the query that we were
interested to answer, .\\

As a final remark, we observe that it is possible to model several
scenarios by considering alternative ways of distributing the
certificates among the principals.  For example, initially, only the
certificate about his role can be sent to , that concerning the
role of  is sent to her, and that about the permission for
 to store documents in the central repository can be sent to
 directly from .  Indeed, this changes the way in which
we can derive the query of interest as certificates are counter-signed
by different principals so that trust relationships must be chained
differently. 



\subsection{Dkal implementation for \CRO{} scenario}
In this section, we give a concrete implementation of the proposed CRO scenario in Section \ref{sec:runningexe},
by using the DKAL distributed authorization policy language provided by Microsoft Research \cite{msr}. 
The DKAL project page \cite{dkalimpl} contains a downloadable engine (implemented in F) for running and checking DKAL policies. 
We implemented and successfully tested the scenario proposed in this paper, and we give the corresponding code in the following:\\

\hrule
\vspace*{.2cm}
\textbf{Input specification code}
\vspace*{.2cm}
\hrule
\small
\begin{verbatim}
type Principal = Dkal.Principal
type Infon = Dkal.Infon
type Attribute = System.String
type Evidence = Dkal.Evidence

relation hasrole(P: Principal, A: Attribute)
relation haspermission(P: Principal, A: Attribute)

---crep------------
//crep's policy
//rule to learn every justified infon comes from the communication
with X: Infon, E: Evidence
upon X [E]
do learn X [E]

//(P1) rule
with P: Principal, Q: Principal, R: Principal, 
E: Evidence, E1: Evidence, E2: Evidence
if hasrole(P, ish) [E]
  if hasrole(Q, ise) [E1]
    if R said haspermission(Q, cans) [E2]
do once send to ed: haspermission(P, "ok ed, u can write!")

//(P2) rule	
with P: Principal, X: Infon, E: Evidence
upon theca said X [E]
do learn  X

//(P3) rule
with P: Principal, X: Infon, E: Evidence
upon P said theca said X [E]
do learn theca said X

//(P4) rule
with P: Principal, Q: Principal, R: Principal, E: Evidence, E1: Evidence 
if hasrole(P, ish) [E]
learn hasrole(P, ish) -> Q said P said hasrole(R, ise) [E1] 

---ed----------------
//ed's policy
with P: Principal, Q: Principal, R: Principal,  A: Attribute, E: Evidence, X: Infon
upon X -> R said haspermission(P, A) [E]
do once send  to crep: Me said haspermission(Me, A) [E]

with Q: Principal, R: Principal, A: Attribute, E: Evidence, X: Infon
upon Q said hasrole(R, A) [E]
do once say with justification to crep: Q said hasrole(R, A) [E]

---theca-------------
//theca's policy
// internal knowledge about roles of principals

substrate xml("<roleAssignments>
	<roleAssignment id='ed' role='ise' />
	<roleAssignment id='helen' role='ish' />
	</roleAssignments>")
namespaces "roleAssignments"
		
with P: Principal, P1: Principal, A: Attribute, A1: Attribute
if  asInfon({| "roleAssignments" | "//roleAssignment[@role='ise']/@id" | P |}) &&
asInfon({| "roleAssignments" | "//roleAssignment[@id='ed']/@role" | A |}) &&
asInfon({| "roleAssignments" | "//roleAssignment[@role='ish']/@id" | P1 |}) &&
asInfon({| "roleAssignments" | "//roleAssignment[@id='helen']/@role" | A1 |}) 
do say with justification to P: hasrole(P, A)
	   say with justification to P: hasrole(P1, A1)
		
---helen----------------
//helen's policy
// internal knowledge about permissions of principals

substrate xml("<permissionAssignments>
	<permissionAssignment id='ed' perm='cans' />
	</permissionAssignments>")
namespaces "permissionAssignments"

with P: Principal, A: Attribute
if asInfon({| "permissionAssignments" | "//permissionAssignment[@perm='cans']/@id" | P |}) &&
asInfon({| "permissionAssignments" | "//permissionAssignment[@id='ed']/@perm" | A |})
do send with justification to P:
	// delegation to Ed to say haspermission condition must be entailed by Ed's 
	// infostrate
	
	with Q: Principal, A1: Attribute
	Q said haspermission(Q, A1) -> Me said haspermission(P, A)	
	\end{verbatim}
	\hrule
\vspace*{.2cm}
\textbf{Output specification code}
\vspace*{.2cm}
\hrule
\small
\begin{verbatim}
>> From theca to ed:
theca said hasrole(ed, "ise") [ signed by theca 1693769001 ] &&
theca said hasrole(helen, "ish") [ signed by theca 1939556616 ]
 
>> From helen to ed:
with Q: Dkal.Principal, A1: System.String
    Q said haspermission(Q, A1) ->
    helen said haspermission(ed, "cans")
 [ signed by helen -973755704 ]
 
>> From ed to crep:
ed said haspermission(ed, "cans") [ signed by helen -973755704 ] &&
ed said theca said hasrole(ed, "ise") [ signed by theca 1693769001 ] 
                                      [ signed by ed -855343925 ] &&
ed said theca said hasrole(helen, "ish") [ signed by theca 1939556616 ] 
                                         [ signed by ed -14984535 ]
 
>> From crep to ed
ok ed, u can write! 
 
Fixed-point reached
\end{verbatim}


\end{document}
