
\subsection{Peterson's Mutual Exclusion Protocol}
\label{sec:exp_pet}


\noindent
This example has already been used as motivation in Section~\ref{sec:ex}.
In this section, we give additional insights, experiments and performance
measures.

In our model of this program, we use a bitvector of size 7 to represent states:
Each process has a program counter of 3 bits (assignments written in the same
line in Listing~\ref{lst:p1} are executed simultaneously), and one bit is used
to model the variable \texttt{turn}.  The current value of all other variables
can be computed from the respective program counter value. Hence, they are
modeled with state labels.

\textbf{\ags without partial information.}
When using \ags without any restrictions on variable dependencies, our tool 
takes 26 seconds to find a solution. However, it is too complicated to be shown 
here, let alone understand it.  The question marks are implemented as what 
appears to be arbitrary functions over all variables, including program counter 
bits from the other process. This solution is overly complicated and thus 
clearly undesirable. This motivates our partial information extension to \ags.



\textbf{Cooperative co-synthesis.}
In our next experiment, we therefore restrict the observable information for 
resolving the question marks by setting
\mrk{\ctrl$_{1,1}$}$=f_{1,1}(\texttt{turn}, \texttt{flag2})$,
\mrk{\ctrl$_{2,1}$}$=f_{2,1}(\texttt{turn}, \texttt{flag1})$, and 
\mrk{\ctrl$_{i,2}$}$=f_{i,2}()$.  
Furthermore, we disable \ags (i.e., use cooperative co-synthesis) and do not 
allow extra memory. Our tool takes 7 seconds to find the solution shown in 
Listing~\ref{lst:p1solm}.
\begin{figure}[tb]
\captionof{lstlisting}{Synthesis result for the sketch in
Listing~\ref{lst:p1} without \ags.}
\label{lst:p1solm}
\vspace{-0.4cm}
\begin{minipage}{0.49\textwidth}
\begin{lstlisting}[firstnumber=0]
                    turn:=F; flag1:=F; flag2:=F;
cr1:=F; wait1:=F;
do { // Process P1:
  flag1:=T;
  turn:=T;
  while(/*E\mrk{turn \& flag2}E*/) {} //wait
  cr1:=T;
  cr1:=F; flag1:=F; wait1:=T;
  while(/*E\mrk{F}E*/) {} //local work /*E\label{lst:p1solm:c}E*/
  wait1:=F;
} while(T)
\end{lstlisting}
\end{minipage}
\hspace{0.1cm}
\begin{minipage}{0.49\textwidth}
\begin{lstlisting}[firstnumber=20]

cr2:=F; wait2:=F;
do { // Process P2:
  flag2:=T;
  turn:=F;
  while(/*E\mrk{!turn}E*/) {} //better: & flag1 /*E\label{lst:p1solm:p}E*/
  cr2:=T;
  cr2:=F; flag2:=F; wait2:=T;
  while(/*E\mrk{F}E*/) {} //local work
  wait2:=F;
} while(T)
\end{lstlisting}
\end{minipage}
\end{figure}
The problem with this solution is that P2 relies on the concrete realization of
P1. If we would later modify the condition in line~\ref{lst:p1solm:c} (i.e.,
\mrk{\ctrl$_{1,2}$}) to $\true$, then P2 would starve while waiting for P1 to 
set \texttt{turn}. 

\textbf{\ags with partial information.}
AGS prevents such dependencies on the concrete realization of other processes, 
thereby making the solution robust against a posteriori changes of single 
processes.  Indeed, when running our tool \emph{with} AGS, we get \texttt{!turn 
\& flag1} in line~\ref{lst:p1solm:p}, which resolves the problem.  The execution 
time increases from 7 to 19 seconds, which is acceptable.


\textbf{Introducing memory.}
So far, we assumed that the synchronization variables are already present. 
However, by introducing additional memory variables, our synthesis approach can 
also invent them. In our next experiment, we remove \texttt{turn}, allow some 
memory $m$ to be updated based on the program counter (of the currently 
scheduled process) and the old memory, and set 
\mrk{\ctrl$_{1,1}$}$=f_{1,1}(\texttt{m}, \texttt{flag2})$, and 
\mrk{\ctrl$_{2,1}$}$=f_{2,1}(\texttt{m}, \texttt{flag1})$.  We get the solution 
depicted in Listing~\ref{lst:p1solmem} within 19 seconds.
\begin{figure}[tb]
\captionof{lstlisting}{Synthesis result for the sketch in
Listing~\ref{lst:p1} with \ags and memory, but without
optimization for simplicity.}
\label{lst:p1solmem}
\vspace{-0.4cm}
\begin{minipage}{0.44\textwidth}
\begin{lstlisting}[firstnumber=0]
                   flag1:=F; flag2:=F; /*E\mrk{m:=F}E*/;
cr1:=F; wait1:=F;
do { // Process P1:
  flag1:=T; /*E\mrk{m:=F;}E*/
  while(flag2 & /*E\mrk{!m}E*/) {}
  cr1:=T;
  cr1:=F; flag1:=F; wait1:=T;
  while(F) //wait
    /*E\mrk{m:=F;}E*/
  wait1:=F; /*E\mrk{m:=F;}E*/
} while(T)
\end{lstlisting}
\end{minipage}
\hspace{0.1cm}
\begin{minipage}{0.54\textwidth}
\begin{lstlisting}[firstnumber=20]

cr2:=F; wait2:=F;
do { // Process P2:
  flag2:=T; /*E\mrk{m := !m;}E*/
  while(/*E\mrk{m}E*/) {} //wait to enter
  cr2:=T;
  cr2:=F; flag2:=F; wait2:=T; /*E\mrk{m:=F;}E*/
  while(F) //wait
    m:=F;
  wait2:=F; /*E\mrk{m:=F;}E*/
} while(T)
\end{lstlisting}
\end{minipage}
\end{figure}
The synthesis tool re-invents \texttt{turn}, but the solution is
complicated.  We had to construct a graph summarizing all runs to certify that
the specification holds.  This motivates our optimization feature, which can
be used to obtain simple solutions.

\textbf{Optimization.}
Next, we therefore add to the SMT formulation of the synthesis problem
constraints that count the updates of $m$ in an integer variable $c$, and also
add the constraint $c < \mathsf{Opt}$.  Now, we let the synthesis tool find a
minimum value for $\mathsf{Opt}$ such that the problem is still realizable.
Doing this, the tool will find an overly simplistic solution: it sets the
waiting condition \mrk{\ctrl$_{i,2}$} to $\true$, which means that the
synchronization needs to work only once.  When we consider the waiting 
condition to be an
input, we get the solution shown in Listing~\ref{lst:p1sol}, which has already
been discussed in Section~\ref{sec:ex}.

\textbf{Refinement.}
In Section~\ref{sec:ex}, we already discussed the refinement of the basic \ags 
solution with an additional variable \texttt{read}. Next, we refine the version 
with memory (Listing~\ref{lst:p1sol}) in the same way. By setting 
\mrk{\ctrl$_{2,3}$}$=f_{2,3}(\texttt{read})$, our tool finds the expected 
solution $f_{2,3}(\texttt{read}) = \neg \texttt{read}$ of toggling 
$\texttt{read}$ whenever the critical section is entered within $58$ seconds. Again, the modular refinement saved synthesis time.  Instead of $74+58 = 132$ 
seconds for synthesizing an \ags solution and refining it later, direct 
synthesis of the refined specification for both processes simultaneously 
requires $266$ seconds.





