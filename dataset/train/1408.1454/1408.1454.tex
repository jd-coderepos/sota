\documentclass[final,copyright,creativecommons]{eptcs}
\providecommand{\event}{EXPRESS/SOS 2014}



\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{amsfonts,amssymb,mathtools,amsthm}
\usepackage{xspace}
\usepackage{nicefrac}
\usepackage{graphicx}
\usepackage{pifont}
\usepackage{cancel}
\usepackage{tikz}
\usepackage{setspace}
\usepackage{stackrel}
\usepackage{xifthen}
\usepackage{stmaryrd}
\usepackage{multirow}
\usepackage[normalem]{ulem}
\usepackage{float}
\usepackage{paralist}
\usepackage{boxedminipage}



\usepackage{commands}



\title{Matching in the Pi-Calculus}
\author{Kirstin Peters \qquad\qquad Tsvetelina Yonova-Karbe \qquad\qquad Uwe Nestmann
\institute{TU Berlin, Germany}}
\def\titlerunning{Matching in the Pi-Calculus}
\def\authorrunning{K. Peters, T. Yonova-Karbe \& U. Nestmann}



\begin{document}

\maketitle



\begin{abstract}
	We study whether, in the \piCal, the {match prefix}|{a} conditional operator testing two names for (syntactic) {equality}|{is} expressible via the other operators.
	Previously, Carbone and Maffeis proved that matching is \emph{not} expressible this way under rather strong requirements (preservation and reflection of observables).
	Later on, Gorla developed a by now widely-tested set of criteria for encodings that allows much more freedom (\eg instead of direct translations of observables it allows comparison of calculi with respect to reachability of successful states).
    In this paper, we offer a considerably stronger separation result on the non-expressibility of matching using only Gorla's relaxed requirements.
\end{abstract}



\section{Introduction}

In process calculi matching is a simple mechanism to trigger a process if two names are syntactically equal. The match prefix  in the -calculus works as a conditional guard. If the names  and  are identical the process behaves as . Otherwise, the term cannot reduce further.

\paragraph{Motivation.} The principle of matching two names in order to reduce a term is also present in another form in any calculus with channel-based synchronisation, like CCS or the -calculus.
The rule for communication demands identical (i.e.~matching) input/output channel names to be used by parallel processes. For example, the term  may communicate on , but the term  cannot communicate at all. Thus, the \piCal already contains a ``distributed'' form of the match prefix.\footnote{Of course, this observation extends to Linda-like tuple-based communication, and even to Actor-like message routing according to the matching object identity.} However, it is also an ``unprotected'' and therefore non-deterministic form of matching, as  allows for two different communications. This raises the natural question whether the match prefix can be encoded using the other operations of the calculus, or whether it is a basic construct.
Here we show that communication is indeed the \piCal construct that is closest to the match prefix.
Accordingly an encoding of the match prefix would need to translate the prefix into a (set of) communication step(s) on links that result from the translation of the match variables. These links have to be free|to allow for a guarding input to receive a value for a match variable|but they also have to be bound|to avoid unintended interactions between parallel match encodings. This kind of binding cannot be simulated by a \piCal operator different from the match prefix.
Thus the match prefix is a basic construct of the \piCal and cannot be encoded.
Note that, as shown by the use of the match prefix \eg in \cite{milnerParrowWalker92} for a sound axiomatisation of late congruence, in \cite{sangiorgi96} for a complete axiomatisation of open equivalence, {or}|{more recently}|{in} \cite{giunti13} for a session pi-calculus, the match prefix is regarded as useful, \ie it allows for applications that without the match prefix are not possible or more complicated to achieve.
Thus a better understanding of the nature of the match prefix contributes to current research.

\paragraph{Quality criteria.} Of course, we are not interested in trivial or meaningless encodings. Instead we consider only those encodings that ensure that the original term and its encoding show to some extent the same abstract behaviour. To analyse the quality of encodings and to rule out trivial or meaningless encodings, they are evaluated \wrt a set of quality criteria.
Note that stricter criteria that rule out more encoding attempts strengthen an \emph{encodability result}, \ie the proof of the existence of an encoding between two languages that respects the criteria. A stronger encodability result reveals a closer connection between the considered languages.
In contrast weaker criteria strengthen a \emph{separation result}, \ie the proof of the non-existence of an encoding between two languages \wrt the criteria. A stronger separation result illuminates a conceptional difference between two languages, \ie some kind of behaviour of the source language that cannot be simulated by the target language.
Unfortunately there is no consensus about what properties make an encoding ``good'' or ``good enough'' to compare two languages (compare \eg~\cite{parrow08}). Instead we find separation results as well as encodability results with respect to very different conditions, which naturally leads to incomparable results.
Among these conditions, a widely used criterion is \emph{full abstraction}, \ie the preservation and reflection of equivalences associated to the two compared languages. There are lots of different equivalences in the range of \piCal variants. Since full abstraction depends, by definition, strongly on the chosen equivalences, a variation in the respective choice may change an encodability result into a separation result, or vice versa \cite{gorlaNestmann}. Unfortunately, there is neither a common agreement about what kinds of equivalence are well suited for language comparison{|}again, the results are often incomparable.
To overcome these problems, and to form a more robust and uniform approach for language comparison, Gorla \cite{gorla} identifies five criteria as being well suited for separation as well as encodability results. By now these criteria are widely-tested (see \eg~\cite{gorla10}). Here, we rely on these criteria to measure the quality of encodings between variants of the \piCal.
Compositionality and name invariance stipulate structural conditions on a valid encoding. Operational correspondence requires that a valid encoding preserves and reflects the executions of a source term. Divergence reflection states that a valid encoding shall not exhibit divergent behaviour, unless it was already present in the source term. Finally, success sensitiveness requires that a source term and its encoding have exactly the same potential to reach a successful state.

\paragraph{Previous Results.} The question about the encodability of the match prefix is not a new one. In \cite{vig} Philips and Vigliotti proposed an encoding within the mobile ambient calculus (\cite{cardelliGordon00}). The \piCal as target language was considered by Carbone and Maffeis. They proved in \cite{carbone} that there exists no encoding of the \piCal into the \piCal (with only guarded choice and) without the match prefix. However the quality criteria used in \cite{carbone} are more restrictive than the criteria here. In particular they assume that visible communication links, \ie observables, are preserved and reflected by the encoding, \ie a source term and its encoding must have the same observables. This criterion is very limiting (\ie strict) even for an encoding between two variants of the same calculus. Thus, by using weaker quality criteria, we strengthen the separation result presented in \cite{carbone}. Note that we use \cite{carbone} as a base and starting point for our result. We discuss the differences to the proofs of \cite{carbone} in Section~\ref{sec:comparison}.
In the same paper Carbone and Maffeis show that the match prefix can be encoded by polyadic synchronisation.
Another positive result for a variant of the \piCal is presented by Vivas in \cite{vivas}. There, a modified version of the \piCal with a new operator, called blocking, is used to encode the match prefix.
In \cite{bodeiDeganoPriami05} the input prefix of the \piCal is replaced by a selective input that allows for communication only if the transmitted value is contained in a set of names specified in the selective input prefix. Accordingly selective input can be used as conditional guard, which can replace the match prefix. We discuss these encoding approaches and how they are related to our separation result in Section~\ref{sec:encodeMatchInOtherCalculi}.

\paragraph{Overview.} We start with an introduction of the considered variants of the \piCal in \S\ref{sec:processCalculi}. Then \S\ref{sec:quality} introduces the framework of \cite{gorla} to measure the quality of an encoding. Our separation result is presented in \S\ref{sec:encodeMatch}. In \S\ref{sec:discussion} we discuss the relation of our result to related work. We conclude with \S\ref{sec:conclusions}.
The missing proofs and additional material can be found in \cite{pynT14}.



\section{The Pi-Calculus}
\label{sec:processCalculi}

Within this paper we compare two different variants of the \piCal|the full \piCal with (free choice and) the match prefix (\piT) and its variant without the match prefix (\piNM)|as they are described \eg in \cite{milnerParrowWalker92,Milner1999}.

Let  denote a countably infinite set of names and  the set of co-names, \ie . We use lower case letters  to range over names.
Moreover let  denote the set of vectors of names of length . Let  be the set of finite vectors of names. And let  whenever  and .
For simplicity we adapt some set notations to deal with vectors of names, \eg  is the length of the vector ,  holds if the name  occurs in the vector , and  holds if the vectors  and  do not share a name.

\begin{definition}[Syntax]
	The set of process terms of the \emph{full \piCal}, denoted by , is given by
	
	
	\noindent
	where .
	The processes of its subcalculus \piNM, denoted by , are given by the same grammar without the match prefix .
\end{definition}

\noindent
The term  denotes \emph{success} (or \emph{successful termination}). It is introduced in order to compare the abstract behaviour of terms in different process calculi as described in Section~\ref{sec:quality}.
The interpretation of the remaining operators is as usual.
Sometimes we denote the  and  in  as \emph{match variables}.
We use  to range over processes. Let , , and  denote the sets of \emph{free names} in , \emph{bound names} in , and all \emph{names} occurring in , respectively. Their definitions are completely standard, \ie names are bound by restriction and as parameter of input and  for all .

We use , , , \ldots to range over substitutions. A substitution is a finite mapping from names to names defined by a set  of renamings, where the  are pairwise distinct.
 is defined as the result of simultaneously replacing all free occurrences of  by  for , possibly applying alpha-conversion to avoid capture or name clashes. For all names  the substitution behaves as the identity mapping, \ie as empty substitution.
We naturally extend substitutions to co-names, \ie .

As suggested in \cite{gorla} we use a \emph{reduction semantics} to reason about the behaviour of \piT and \piNM.
The \emph{reduction semantics} of \piT and \piNM are jointly given by the transition rules\vspace{0.75em}
\begin{center}
	\vspace{0.75em}\\
	\vspace{0.75em}
\end{center}
where \emph{structural congruence}, denoted by , is the least congruence given by the rules:\vspace{0.75em}

Here , where  denotes alpha-conversion, holds if  can be obtained from  by renaming bound names in , silently avoiding name clashes.
Note that the structural congruence rule  can be applied only in the full \piCal. It is this structural congruence rule (in combination with the last transition rule) that defines the semantics of the match prefix. However we can similarly define the semantics of the match prefix with the reduction rule  without any influences on our results.
A reduction step  then denotes either a communication between an input and output on the same link or an internal step.
Let  (and ) denote the existence (and non-existence) of a step from , \ie there is (no)  such that . Moreover, let  be the reflexive and transitive closure of . We write  if  can perform an infinite sequence of reduction steps. A sequence of reduction steps starting in a term  is called an \emph{execution} of . An execution is either finite, as , or infinite. A finite execution  is \emph{maximal} if it cannot be further extended, \ie if , otherwise it is \emph{partial}.

Traditionally a process term is considered as successful if it has an unguarded occurrence of success (see \eg \cite{gorla}). This is usually formalised as . Because of free choice, we have to adapt the usual definitions of the reachability of success to deal with arbitrary nestings of choice and parallel composition. To do so we recursively define the notion of unguarded subterms.

\begin{definition}[Unguarded Subterms]
	\label{def:unguardedSubterms}
	Let  or . The \emph{set of unguarded subterms of} , denoted by , is recursively defined as:
	\vspace*{-0.6em}
	
	\vspace*{-1.1em}
\end{definition}

\noindent
Note that the sets of unguarded subterms can differ for structural congruent terms. Consider for example  but 
or  but .
Similarly, injective substitutions do not distribute over unguarded subterms.
For example  but .
Moreover note that if  is an unguarded subterm of  then also all unguarded subterms of  are unguarded subterms of .

Then a term is successful if it has an unguarded occurrence of success.

\begin{definition}[Reachability of Success]
	Let  or . Then  is \emph{successful}, denoted by , if .
	\emph{ reaches success}, denoted by , if there is some  such that  and .
	Moreover, we write , if  reaches success in every finite maximal execution.
Let  abbreviate ,  abbreviate , and  abbreviate .
\end{definition}

\noindent
Of course, all proofs in this paper hold similarly for variants of \piT and \piNM with only guarded choice and the traditional definition of a successful term.

The first quality criterion to compare process calculi presented in Section~\ref{sec:quality} is compositionality. It induces the definition of a \piNM-context parametrised on a set of names for each operator of \piT. A \piNM-context  is simply a \piNM-term with  holes. Putting some \piNM-terms  in this order into the holes  of the context, respectively, gives a term denoted by . Note that a context may bind some free names of . The arity of a context is the number of its holes. We extend the definition of unguarded subterms by the equation  to deal with contexts.

The standard notion of equivalence to compare terms of the \piCal is bisimulation. An introduction to bisimulations in the \piCal can be found \eg in \cite{milnerParrowWalker92} or \cite{sang}. For our separation result we require such a standard version of reduction bisimulation, denoted by , on the target language, \ie on \piNM-terms.



\section{Quality of Encodings}
\label{sec:quality}

Within this paper we analyse the existence of an encoding from \piT into \piNM. To measure the quality of such an encoding, Gorla \cite{gorla} suggested five criteria well suited for language comparison. Accordingly, we consider an encoding to be ``valid'', if it satisfies Gorla's five criteria.

We call the tuple , where  is a set of language terms and  is a reduction semantics, a \emph{language}.
An \emph{encoding} from  into  is then a tuple  such that
\begin{compactitem}
	\item  is the translating function,
	\item  is a renaming policy, where  for all ,
	\item and  is a behaviour equivalence on .
\end{compactitem}
We call  the \emph{source language (calculus)} and  the \emph{target language (calculus)}. Accordingly we call the elements of  \emph{source terms} and the elements of  \emph{target terms}.
We use  () to range over source (target) terms.

The main ingredient of an encoding is of course the encoding function  that is a mapping from processes to processes.
However, sometimes it is useful to be able to reserve some names to play a special role in an encoding.
Since most process calculi have infinitely many names in their alphabet, it suffices to shift the set of names  of the target language to the set  to reserve  names. In order to incorporate such ``shifts'' and similar techniques, Gorla introduces a renaming policy , \ie mapping from names to names that specifies the translation of each name of the source language into a name or vector of names of the target language.
Additionally we assume the existence of a behavioural equivalence  on the target language that is a reduction bisimulation. Its purpose is to describe the abstract behaviour of a target process, where abstract basically means with respect to the behaviour of the source term. Therefore it should abstract from ``junk'' left over by the encoding.

\cite{gorla} requires  to map all names to a vector of the same length since this way names are treated uniformly, \ie source names cannot be handled differently by an encoding just because the length of the vector, to that  maps to, is different.
The condition that  for all  ensures that the renaming policy does not relate unrelated source term names.

\begin{definition}[Valid Encoding]
	An encoding from  into  is \emph{valid} if it satisfies:
	\begin{compactenum}
		\item[\textit{Compositionality:}] For each -ary operator  of  and all sets of names  there is a -ary context  such that for all  with  it holds that .
		\item[\textit{Name Invariance:}] For each  and  it holds that
			\vspace*{-0.5em}
			
			\vspace*{-1em}\\
where  is such that  for every .
		\item[\textit{Operational Correspondence:}] 
			\begin{compactenum}
				\item[Complete:] For all , it holds that .
				\item[Sound:] For all , there is  such that  and .
			\end{compactenum}
		\item[\textit{Divergence Reflection:}] For every  with , it holds that .
		\item[\textit{Success Sensitiveness:}] For every , it holds  iff .
	\end{compactenum}
\end{definition}

Intuitively, an encoding is compositional if the translation of an operator is similar for all its parameters. To mediate between the translations of the parameters the encoding defines a unique context for each operator, whose arity is the arity of the operator. Moreover, the context can be parametrised on the free names of the corresponding source term. Note that our result is independent of this parametrisation.
In name invariance the  can be considered as the translation of . The condition  ensures that  introduces no additional renamings between (parts of) translations of source term names. Of course  cannot affect reserved names, \ie for all names  in the domain of  there is a source term name  such that .
Operational correspondence consists of a soundness and a completeness condition. \emph{Completeness} requires that every execution of a source term can be simulated by its translation, \ie the translation does not omit any execution of the source term. \emph{Soundness} requires that every execution of a target term corresponds to some execution of the corresponding source term, \ie the translation does not introduce new executions.
Note that the definition of operational correspondence relies on the equivalence  to get rid of junk possibly left over within executions of target terms. An encoding reflects divergence if it does not introduce divergent executions.
The last criterion states that an encoding preserves the behaviour of the source term if it and its corresponding target term answer the tests for success in exactly the same way.

Success sensitiveness only links the behaviours of source terms and their literal translations but not of their continuations. To do so, Gorla relates success sensitiveness and operational correspondence by requiring that  never relates two processes that differ in the possibility to reach success. More precisely  \emph{respects success} if, for every  and  with  and , it holds that .
By \cite{gorla} a ``good'' equivalence  is often defined in the form of a barbed equivalence (as described e.g. in \cite{milnerSangiorgi92}) or can be derived directly from the reduction semantics and is often a congruence, at least with respect to parallel composition. For the separation results presented in this paper, we require only that  is a success respecting reduction bisimulation, \ie for every  such that ,  iff  and for all  there exists a  such that  and .



\section{The Match Prefix and the Pi-Calculus}
\label{sec:encodeMatch}

Our separation result strongly rests on the criteria compositionality and success sensitiveness.
We also make use of name invariance.
But, as we claim, name invariance is not crucial for the proof. Name invariance defines how a valid encoding has to deal with substitutions. This is used to simplify the argumentation in our proof as explained below.
The last criterion states that source and target terms are related by their ability to reach success.
If we compare \piT and \piNM we observe a difference with respect to successful terms and substitutions.
In \piT a substitution can change the state of a process from unsuccessful to successful. Consider for example the term  and a substitution  such that . The only occurrence of success in  is guarded by a match prefix and thus . But  and thus .
In \piNM, because there is no match prefix, a substitution cannot turn an unsuccessful state into a successful state.

\begin{lemma}
	\label{prop:propequiv}
	Let . Then .
\end{lemma}

In both calculi substitutions may allow us to reach success by enabling a communication step. To do so it has to unify two free names that are the links of an unguarded input and an unguarded output. In the case of \piNM the enabling of such a new communication step is indeed the only possibility for a substitution to influence the reachability of success.
More precisely, if in \piNM a substitution  allows to reach success, \ie if  but , then there is a derivative of  in which  unifies the free link names of an input and an output guard and thus enables a new communication step.

\begin{lemma}
	\label{prop:newCom}
	Let  and  such that  but .
	Then:
	\vspace{-0.5em}
	
\end{lemma}

In the following proofs we often use the term  or a variant of this term as counterexample. To reason about the encoding of this term we analyse the context  that is introduced according to compositionality to translate . Note that this context is parameterised on , which is the set of free names of the encoded term. For example in the case of  the set of free names contains only  and , \ie . Moreover ,  and the continuation of the match prefix are parameters of this context. First we show that this context cannot reach success on its own, \ie without a term in its hole.

\begin{lemma}
	\label{lem:contextCannotReachSuccess}
	Let \encod be a valid encoding from \piT into \piNM.
	Let  be a finite set of names,
	 be names such that ,
	and  be the context that is introduced by  to encode the match prefix . Then  cannot reach success on its own, \ie .
\end{lemma}

Moreover the context introduced to encode the match prefix has to ensure that its hole, \ie the respective encoding of the continuation of the match prefix, is initially guarded and cannot be unguarded by the context on its own.

\begin{lemma}
	\label{lem:contextNotUnguardContinuation}
	Let \encod be a valid encoding from \piT into \piNM.
	Let  be an arbitrary finite set of names,
	 be arbitrary names such that ,
	and  be the context that is introduced by  to encode the match prefix . Then  cannot unguard its hole, \ie  implies  for all .
\end{lemma}

Next we combine our knowledge of the context  and the relationship between substitutions and the reachability of success in \piNM as stated in Lemma~\ref{prop:newCom}. We show that a match prefix  has to be translated into two communication partners, \ie an input and an output, on the translations of  and . Intuitively such a communication is the only way to simulate the test for equality of names that is performed by . Moreover we derive that the respective links of the communication partner have to be free in the context . Intuitively they have to be free, because otherwise no substitution can unify them. Consider for example the term . In order to reach success the term first communicates the name  on . This communication leads to a substitution of the name  by the received value  in the continuation of the input guarded subterm. Only this substitution allows to unguard the only occurrence of success. Hence, to simulate such a behaviour of source terms, the encoding has to translate match prefixes into communication {partners}|{to} simulate the test for {equality}|{and} the links of these communication partners have to be {free}|{to} allow for substitutions induced by communication steps. Note that name invariance allows us to ignore a surrounding {communication}|{as} the step on link  in the example |{and} to concentrate directly on the induced substitution.

To avoid the use of the criterion name invariance it suffices to show that the encodings of  and  differ only by a substitution of (parts of) the translations of  and \footnote{Unfortunately, because of the formulation of compositionality that allows for the contexts to depend on the free names of the term, this task is technically elaborate.} and that the contexts introduced to encode outputs and inputs cannot lead to success themselves, \ie that the encoding of  reaches success iff the encoding of  is unguarded. This suffices to reconstruct the substitution and the conditions on this substitution that are used in Lemma~\ref{lem:matchReqCom} and to prove Lemma~\ref{prop:newCom} and Lemma~\ref{lem:parContextNotRes} \wrt such substitutions. The remaining proofs remain the same.

Note that the appendix provides a more formal formulation of the next lemma.

\begin{lemma}
	\label{lem:matchReqCom}
	Let \encod be a valid encoding from \piT into \piNM.
	Let  be an arbitrary finite set of names,
	 be arbitrary names such that ,
	and  be the context that is introduced by  to encode the match prefix .
	Then there is some  such that  reaches a state with an unguarded and free output and input on the links  and . Moreover  cannot unguard its hole until a substitution unifies these two links.
\end{lemma}

\noindent
A very important consequence of the lemma above is the existence of the index  for all contexts  regardless of  and of the terms that may be inserted in the hole. Note that the ``there is some'' does not necessarily imply that there is just one such . If the renaming policy splits up a source term name into several target term names then different parts of this vector can be used to simulate the test for equality. However, the above lemma states that there is at least one such , \ie at least one part of the translation of source term names is used to implement the required communication partners.

To derive the separation result we need a counterexample that combines two match prefixes in parallel.
Therefore we need some information on the context  that is introduced by  according to compositionality to translate the parallel operator. Note that this context is parameterised on the set  that consists of the free names of the two parallel components that should be encoded. Moreover the two holes serve as placeholders for the encoding of the left and the right hand side of the source term.
Similar to the context introduced to encode the match prefix, the context that is introduced to encode the parallel operator cannot reach success on its own, \ie .

\begin{lemma}
	\label{lem:parContextCannotReachSuccess}
	Let \encod be a valid encoding from \piT into \piNM.
	Let  be a finite set of names
	and  be the context introduced by  to encode the parallel operator.
	Then, .
\end{lemma}

But in contrast to the context introduced in order to encode the match prefix the context  has always, \ie regardless of a substitution, to unguard its holes on its own.

\begin{lemma}
	\label{lem:parContextUnguard}
	Let \encod be a valid encoding from \piT into \piNM.
	Let  be a finite set of names
	and  be the context introduced by  to encode the parallel operator.
	Then there is some  such that  and .
\end{lemma}

Then we need to show that the context  cannot bind the names that are used by the context  to simulate the test for equality. As in the above example , a communication step can unify at runtime the variables of a match prefix. Such a communication step naturally transmits the value for the match variables over a parallel operator, because communication is always between two communication partners that are composed in parallel. If this value is restricted on either side of the parallel operator the communication could not lead to the required unification. The match variables would still be considered as different and the match prefix as not satisfied. Thus for example neither  nor  reach success although in both cases the communication on  is still possible. Of course the term  reaches success. But for cases like this we can construct larger counterexamples as  and to analyse the source term, in order to examine the places at which such a restriction would be allowed, violates the idea of a compositional encoding. Again name invariance allows us to ignore the communication on  and to directly concentrate on the induced substitution.

\begin{lemma}
	\label{lem:parContextNotRes}
	Let \encod be a valid encoding from \piT into \piNM.
	Let  be a finite set of names
	and  be the context that is introduced by  to encode the parallel operator.
	Then  for all  and all ,
	where  is the index that exists according to Lemma~\ref{lem:matchReqCom}.
\end{lemma}

Finally we show that there is no valid encoding from \piT into \piNM, by assuming the contrary and deriving a contradiction. As already mentioned, we use a counterexample that consists of two parallel composed match prefixes. More precisely we use , \ie swap the match variables on the right side. Intuitively the contradiction is derived as follows: Since the context  translates the match variables into free links of unguarded communication partners and because of the swapping of the matching variables on the right side, the parallel composition of the two variants of the context |that are necessary to encode the counterexample|enable wrong communication steps between a communication partner from the left  and a communication partner from the right . We denote such a communication step as wrong, because in this case the communication cannot lead to the unguarding of the encoded continuation  without violating success sensitiveness. In order to reach success, the source term needs a substitution  that unifies the match variables. Unfortunately, the same wrong communication can consume one of the communication partners in  that is necessary to unguard the encoded continuation. A restoration of this communication partner leads by symmetry to divergence which violates the divergence reflection criterion. But without the possibility of a restoration, the wrong communication leads to an unsuccessful execution of . This execution violates the combination of success sensitiveness and operational soundness.

\begin{theorem}
	\label{thm:noEnc}
	There is no valid encoding from \piT into \piNM.
\end{theorem}

\begin{proof}[Proof Sketch]
	Assume the contrary, \ie assume that there is a valid encoding \encod from \piT into \piNM.
	Consider the term  and a substitution  such that .
	
	By Lemma~\ref{lem:parContextUnguard}, there is some  such that  and .
	Because  for all , .
	By Lemma~\ref{lem:matchReqCom}, then there are , , , , , and  such that  and  has an unguarded input as well as an unguarded output on both of the channels  and .
	
	By name invariance, , where \linebreak  for every .
	Hence , \ie the inputs on the channels  and  can communicate between the two instances of the context  in .
	By the argumentation above these communications, \ie there an input from the left  interacts with an output from the right  or vice versa, cannot lead to the unguarding of .
	Note that if either the left  or the right  restores a wrongly consumed input term or output term on  or  then, because , there is an execution there the other side also restores the corresponding counterpart. This leads back to the state before the respective communication step between the left  and the right  and thus to a divergent execution.
	The same holds if the context  restores such an input term or output term.
	But since  has no divergent execution and because of divergence reflection, a divergent execution of  violates our assumption that \encod is a valid encoding.
	Thus  cannot restore a wrongly consumed input term or output term on  or .
	
	By Lemma~\ref{lem:matchReqCom}, only a communication between the terms on channels  and  can unguard the continuation . Hence there is a finite maximal execution of  in which the continuation  is never unguarded.
	Thus, by Lemma~\ref{lem:contextCannotReachSuccess} and Lemma~\ref{lem:parContextCannotReachSuccess}, no success is reached in this execution, \ie .
	But  implies .
	This is a contradiction.
\end{proof}



\section{Discussion}
\label{sec:discussion}

As mentioned above, also Carbone and Maffeis show in \cite{carbone} that the match prefix cannot be encoded within the \piCal. Moreover there are different encodings of the match prefix in modified variants and extensions of the \piCal. In this section we discuss the relation between these results and our separation result.

\subsection{The Match Prefix is a Native Operator of the Pi-Calculus}
\label{sec:comparison}

If we compare the approach in \cite{carbone} with ours, we observe that the considered variants of the \piCal are different.
We consider the full \piCal and its variant without the match prefix as source and target language.
In the literature there are different variants called ``full'' \piCal. We decide on the most general of these variants. In particular we consider a variant of the \piCal with free choice whereas \cite{carbone} allow only guarded choice in their target language.
Note that the source language considered in \cite{carbone} is an asynchronous variant of the \piCal, \ie is less expressive than the source language considered here \cite{palamidessi03,petersNestmann14,petersNestmannGoltz13}.
However, the only (counter)examples we use here are of the form , or  where  is a combination of , , , and parallel composition for an arbitrary  with a fixed set of free names. Thus, our separation result remains valid if we change the source language to the asynchronous variant of the \piCal without choice that is used in \cite{carbone}.
Our target language is also more expressive, because we do not restrict it to guarded choice. More precisely, in \cite{carbone} the \piCal with guarded mixed choice is used. Accordingly, the current result can be considered stronger. However, concentrating only on guarded choice is commonly accepted and, more importantly, it might be easy to adapt the proof in \cite{carbone} to the more expressive target language.

\paragraph{Contribution 1.}
The main difference between the two approaches are the quality criteria, \ie in the conditions that are assumed to hold for all valid encodings.
Similar to \cite{palamidessi03}, Carbone and Maffeis require that an encoding must be uniform and reasonable.
By \cite{carbone} an encoding  is \emph{uniform} if it translates the parallel operator homomorphically, \ie , and if it respects permutations on free names, \ie for all  there is some  such that .
A \emph{reasonable} semantics, by \cite{carbone}, is one which distinguishes two processes  and  whenever there exists a maximal execution of  in which the observables are different from the observables in any maximal execution of .
Furthermore they require that an encoding should be able to distinguish deadlocks from livelocks, which is comparable to divergence reflection.

In contrast to uniformity, name invariance relates the substitution on the source term names with its translation on target term names. Already \cite{gorla} points out that name invariance is a more complex requirement than the above condition; but \cite{gorla} also argues that it is rather more detailed than more demanding. Moreover we claim that name invariance is not crucial for the above separation result.
The first condition of uniformity is a strictly stronger requirement than compositionality for the parallel operator as it is discussed for instance in \cite{petphd}. However the proof in \cite{carbone} does not use the homomorphic translation of the parallel operator.

The criterion on the reasonable semantics used in \cite{carbone} is even more demanding than the first part of uniformity. It states that a source term and its encoding reach exactly the same observables.
It completely ignores the possibility to translate a source term name into a sequence of names or to simulate a source term observable by a set of target term observables even if there is a bijective mapping between an observable and its translation. The proof in \cite{carbone} makes strongly use of this criterion; exploiting the fact that the match variables are free in the match prefix.
Gorla suggests success sensitiveness and operational correspondence instead. Note that we use operational correspondence|or more precisely soundness|only in the last step of the proof to argument that if a source term reaches success in all finite maximal executions its encoding does alike. Hence, for the presented case, the combination of operational soundness and success sensitiveness is a considerably weaker requirement than the variant of reasonableness.

Overall we conclude that, because of the large difference between success sensitiveness and the variant of reasonableness considered in \cite{carbone}, our set of criteria is considerably weaker and thus the presented result is strictly stronger.

\paragraph{Contribution 2.}
The proof in \cite{carbone} is, due to the stricter criteria, shorter and easier to follow than ours. But it also reveals less information on the reason for the separation result. In contrast, the presented approach reflects the intuition that communication is close to the behaviour of the match prefix. We show that among the native operators of the \piCal input and output are the only operators close enough to possibly encode the match operator, where the link names result from the translation of the match variables. But it also reveals the reason why communication is not strong enough.
Translated match variables have to be free in the encoding of the match {prefix}|{to} allow for a guarding input to receive a value for a match {variable}|{but} they also have to be {bound}|{to} avoid unintended interactions between the translated match variables of parallel match encodings.
The other \piCal operators cannot simulate this kind of binding.

\subsection{Encodings of the Match Prefix in Pi-Like Calculi}
\label{sec:encodeMatchInOtherCalculi}

As mentioned in the introduction there are some modifications and extensions of the \piCal that allow for the encoding of the match prefix. We briefly discuss four different approaches and their relation to our separation result.

In \cite{bodeiDeganoPriami05} the input prefix  of the \piCal is replaced by a selective input . A term guarded by  and a term guarded by a matching output prefix  can communicate (if they are composed in parallel and) only if the transmitted value  is contained in  the set  of names specified in the selective input prefix. Accordingly selective input can be used as a conditional guard. As pointed out in \cite{bodeiDeganoPriami05}, selective input allows to encode a match prefix  simply by , where  is the encoding of . Here the test for equality  is transferred into the test . Thus it is not necessary to translate the match variables into communication channels, which allows for this simple encoding.

Mobile ambients \cite{cardelliGordon00} extend the asynchronous \piCal with ambients , \ie sides or locations, that
\begin{inparaenum}[(a)]
	\item can contain processes and other ambients,
	\item can be composed in parallel to other ambients and processes, and
	\item whose name can be restricted to forbid interaction with its environment.
\end{inparaenum}
Moreover there are three additional actions prefixes:
\begin{inparaenum}[(1)]
	\item  allows an ambient to enter another ambient named  by the rule ,
	\item  allows an ambient to exit its own parent named  by the rule , and
	\item  dissolves an ambient with name  by the rule .
\end{inparaenum}
As a consequence, communication steps become locale, \ie can occur only if both communication partners are located in parallel within the same ambient. Hence channel names become superfluous, since communications on different channels can be simulated by communications within different ambients. So the -input  is replaced by  and the asynchronous output  is replaced by .
As pointed out in \cite{vig}, mobile ambients can encode the match prefix. They suggest to encode a match prefix  by the term , where  is the encoding of .
Since there are no channel names, the match variables are translated into the new capabilities of mobile ambients, namely into  and an ambient with name .  can only be reduced if , \ie if either  holds from the beginning or if  and  are unified by a substitution induced by a surrounding input, as \eg in . Note that, to enable this substitution, the match variables  and  {have}|{as} shown in our proof {above}|{to} be translated into free names. Here the ambient  and its restriction ensure that there are no unintended interactions between the translated match variables of parallel match encodings. More precisely the ambient  encapsulates the translation of the test for equality  and the restriction  ensures that the environment cannot interfere, \ie no other action on the names  or  can reduce the  or can target the ambient  inside of , because the restriction forbids other processes to enter . So in mobile ambients it is not necessary to translate the match variables into bound names, which allows for the encoding.

\cite{vivas} extend the pi-calculus with an additional operator  called blocking. Blocking forbids for  to perform a visible action with the blocked name  as subject or bound object. By \cite{vivas} this allows to encode a match prefix  by the term , where  is the encoding of  and . As suggested by our proof above, the match prefix is translated into a communication and the match variables are translated into the channel names of the respective communication partners. To communicate the channel names have to be equal, \ie again either  holds from the beginning or  and  have to be unified by a substitution induced by a surrounding input. To enable such a substitution, the match variables  and  {have}|{as} shown in our proof {above}|{to} be translated into free names. Here the new blocking operator ensures that there are no unintended interactions between the translated match variables of parallel match encodings. More precisely  ensures that  cannot interact with another term over  or |{thus} blocking behaves as a binding operator \wrt reduction {steps}|{but} blocking does not bind the names  and  such that they can be affected by substitution.
Thus our proof explicitly reveals the features that due to \cite{vivas} allow to encode the match prefix by means of blocking.

\cite{carbone} extends the \piCal by so-called polyadic synchronisation, \ie instead of single names as in the \piCal channel names can be constructed by combining several names. Thus \eg in the variant of the \piCal with polyadic synchronisation, where each channel name consists of exactly two names, the input prefix becomes  and the (matching) output prefix becomes . An input and an output guarded term (that are composed in parallel) can communicate if the composed channel names are equal. By \cite{carbone} this extension allows to encode the match prefix. They suggest to translate  by , where  is the encoding of  and . Again, as suggested by our proof above, the match prefix is translated into a communication and the match variables are translated into (parts of) the channel names of the respective communication partners. But polyadic synchronisation allows to combine the free match {variables}|{used} to allow for a guarding input to receive a {value}|{and} the bound name |{used} to avoid unintended interactions between the translated match variables of parallel match {encodings}|{within} a single communication channel.
Again our proof explicitly reveals the features that due to \cite{carbone} allow to encode the match prefix by means of polyadic synchronisation.

\section{Conclusions}
\label{sec:conclusions}

We provide a novel separation result showing that there is no valid encoding from the full \piCal into its variant without the match prefix. In contrast to the former approach in \cite{carbone} we strengthen the result in two ways:
\begin{compactenum}
	\item We considerably weaken the set of requirements, in particular with respect to the criterion that is called reasonable semantics in \cite{carbone}. Instead, we use the framework of criteria designed by Gorla for language comparison.
	\item The so obtained proof reflects our intuition on the match prefix and reveals the problem that prevents its encoding. A valid encoding of the match prefix would need to translate the prefix into a (set of) communication step(s) on links that result from the translation of the match variables. These links have to be free|to allow for a guarding input to receive a value for a match variable|but they also have to be bound|to avoid unintended interactions between parallel match encodings. This kind of binding cannot be simulated by a \piCal operator different from the match prefix.
\end{compactenum}
This further underpins that the match prefix cannot be derived in the \piCal.

In Section~\ref{sec:encodeMatchInOtherCalculi} we discuss four modifications and extensions of the \piCal that allow to encode the match prefix. 
In the first encoding approach the match prefix is replaced by another (more general) conditional guard. But the other approaches use extensions or modifications of the \piCal to encode the match prefix by using features that allow to circumvent the binding problem in the encoding of the match prefix that is pointed out in our proof.
Thus further works can use the here presented explicit formulation of the reason, that forbids for encodings of the match prefix in the \piCal, to encode the match prefix in other calculi.

\addcontentsline{toc}{section}{References}
\bibliographystyle{eptcs}
\bibliography{references}

\end{document}
