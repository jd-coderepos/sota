\documentclass{article}







\usepackage[final]{neurips_2021}



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{xcolor}         \usepackage{graphicx}
\usepackage{subcaption}
\usepackage{svg}
\usepackage{multirow}
\usepackage{wrapfig}

\usepackage{makecell}
\usepackage[ruled,vlined]{algorithm2e}



\newcommand{\ch}[1]{\textcolor{blue}{(#1)}}
\newcommand{\pan}[1]{\textcolor{red}{Pan:(#1)}}
\definecolor{ao(english)}{rgb}{0.0, 0.5, 0.0}
\newcommand{\yh}[1]{\textcolor{ao(english)}{Yuhong:(#1)}}


\title{Generic Neural Architecture Search via Regression}



\author{Yuhong Li, Cong Hao, Pan Li, Jinjun Xiong, Deming Chen\\
 University of Illinois at Urbana-Champaign,
 Georgia Institute of Technology,\\ Purdue University,
 University at Buffalo \\
 leeyh@illinois.edu, callie.hao@ece.gatech.edu, panli@purdue.edu, \\
 jinjun@buffalo.edu, dchen@illinois.edu
}

\begin{document}

\maketitle
\begin{abstract}
Most existing neural architecture search (NAS) algorithms are dedicated to and evaluated by the downstream tasks, e.g., image classification in computer vision. 
However, extensive experiments have shown that, prominent neural architectures, such as ResNet in computer vision and LSTM in natural language processing, are generally good at extracting patterns from the input data and perform well on different downstream tasks. 
In this paper, we attempt to answer two fundamental questions related to NAS. (1) Is it necessary to use the performance of specific downstream tasks to evaluate and search for good neural architectures? (2) Can we perform NAS effectively and efficiently while being agnostic to the downstream tasks?
To answer these questions, we propose a novel and generic NAS framework, termed \textbf{Gen}eric \textbf{NAS} (GenNAS). 
GenNAS does not use task-specific labels but instead adopts \textit{regression} on a set of manually designed synthetic signal bases for architecture evaluation. 
Such a self-supervised regression task can effectively evaluate the intrinsic power of an architecture to capture and transform the input signal patterns, 
and allow more sufficient usage of training samples. Extensive experiments across 13 CNN search spaces and one NLP space demonstrate the remarkable efficiency of GenNAS using regression, in terms of both evaluating the neural architectures (quantified by the ranking correlation Spearman's  between the approximated performances and the downstream task performances) and the convergence speed for training (within a few seconds). For example, on NAS-Bench-101, GenNAS achieves 0.85  while the existing efficient methods only achieve 0.38.
We then propose an automatic task search to optimize the combination of synthetic signals using limited downstream-task-specific labels, further improving the performance of GenNAS.
We also thoroughly evaluate GenNAS's generality and end-to-end NAS performance on all search spaces,
which outperforms almost all existing works with significant speedup. For example, on NASBench-201, GenNAS can find near-optimal architectures within 0.3 GPU hour. Our code has been
made available at: \href{https://github.com/leeyeehoo/GenNAS}{\textit{\color{magenta}{https://github.com/leeyeehoo/GenNAS}}}

\end{abstract}


\section{Introduction}
\label{sec:intro}

Most existing neural architecture search (NAS) approaches aim to find top-performing architectures on a specific downstream task, 
such as image classification~\cite{real2019regularized, zoph2016neural,liu2018darts,cai2018proxylessnas,su2021vision}, semantic segmentation~\cite{liu2019auto,nekrasov2019fast,shaw2019squeezenas}, neural machine translation~\cite{li2021bossnas,wang2020hat,so2019evolved} or more complex tasks like hardware-software co-design~\cite{hao2018deep,hao2019fpga,zhang2019skynet,lin2020mcunet,lin2021mcunetv2}.
They either directly search on the target task using the target dataset (e.g., classification on CIFAR-10 \cite{zoph2016neural,real2017large} ), or search on a \textit{proxy} dataset and then transfer to the target one (e.g. CIFAR-10 to ImageNet) \cite{zoph2018learning,liu2018darts}.
However, extensive experiments show that prominent neural architectures are generally good at extracting patterns from the input data and perform well to different downstream tasks. 
For example, ResNet~\cite{he2016deep} being a prevailing architecture in computer vision, shows outstanding performance across various datasets and tasks~\cite{chen2018encoder,marsden2017resnetcrowd,raghu2019transfusion}, because of its advantageous architecture, the residual blocks.
This observation motivates us to ask the first question: 
\textit{Is there a generic way to search for and evaluate neural architectures without using the specific knowledge of downstream tasks?}

\begin{figure}
\centering
     \begin{subfigure}[b]{0.48\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/classification_vs_regression_a.pdf}
         \caption{Classification}
         \label{fig:introA}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.48\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/classification_vs_regression_b.pdf}
         \caption{Regression}
         \label{fig:introB}
     \end{subfigure}
     \hfill
        \caption{For classification, only  samples near the decision boundary determine the classification accuracy. For regression, all samples equally contribute to the regression accuracy. Therefore, regression is better at leveraging all  training samples than classification to achieve faster convergence.}
        \label{fig:classification_vs_regression}
        \vspace{-8pt}
\end{figure}


Meanwhile, we observe that most existing NAS approaches directly use the \textit{final classification performance} as the metric for architecture evaluation and search, which has several major issues. First, the classification accuracy is dominated by the samples along the classification boundary, while other samples have clearer classification outcomes compared to the boundary ones (as illustrated in Fig.~\ref{fig:introA}). Such phenomena can be observed in the limited number of effective support vectors in SVM~\cite{hearst1998support}, which also applies to neural networks because of the theory of neural tangent kernel~\cite{jacot2018neural}.
Therefore, discriminating performance of classifiers needs many more samples than necessary (the indeed effective ones), causing a big waste.
Second, a classifier tends to discard a lot of valuable information, such as finer-grained features and spatial information, by transforming input representations into categorical labels.
This observation motivates us to ask the second question: \textit{Is there a more effective way that can make more sufficient use of input samples and better capture valuable information?}

To answer the two fundamental questions for NAS, in this work, we propose a \textbf{Gen}eric \textbf{N}eural \textbf{A}rchitecture \textbf{S}earch method, termed \textbf{GenNAS}. GenNAS adopts a \textbf{regression-based proxy task} using \textbf{downstream-task-agnostic synthetic signals} for network training and evaluation. It can efficiently (with near-zero training cost) and accurately \textit{approximate} the neural architecture performance. 

\textbf{Insights}.
\underline{First}, as opposed to classification, regression can efficiently make fully use of all the input samples, which equally contribute to the regression accuracy (Fig.~\ref{fig:classification_vs_regression}b). 
\underline{Second}, regression on properly-designed synthetic signals is essentially evaluating the \textit{intrinsic representation power} of neural architectures, which is to capture and distinguish fundamental data patterns that are agnostic to downstream tasks. 
\underline{Third}, such representation power is heavily reflected in the \textit{intermediate data} of a network (as we will show in the experiments), which are regrettably discarded by classification.

\textbf{Approach}. \underline{First}, we propose a \textit{regression proxy task} as the supervising task to train, evaluate, and search for neural architectures (Fig.~\ref{fig:regression}). Then, the searched architectures will be used for the target downstream tasks.
To the best of our knowledge, we are the first to propose self-supervised regression proxy task instead of classification for NAS.
\underline{Second}, we propose to use \textit{unlabeled synthetic data} (e.g., sine and random signals) as the groundtruth (Fig.~\ref{fig:signals}) to measure neural architectures' intrinsic capability of capturing fundamental data patterns.
\underline{Third}, to further boost NAS performance, we propose a weakly-supervised automatic proxy task search with only a handful of groundtruth architecture performance (e.g. 20 architectures), to determine the best proxy task, i.e., the combination of synthetic signal bases, targeting a specific downstream task, search space, and/or dataset (Fig.~\ref{fig:proxy_search}).


\textbf{GenNAS Evaluation}.
The efficiency and effectiveness of NAS are dominated by \textit{neural architecture evaluation}, which directs the search algorithm towards  top-performing network architectures.
To quantify how accurate the evaluation is, one widely used indicator is the network performance \textit{Ranking Correlation}~\cite{daniel1990applied} between the prediction and groundtruth ranking, defined as Spearman's Rho () or Kendall's Tau (). 
The ideal ranking correlation is 1 when the approximated and groundtruth rankings are exactly the same; achieving large  or  can significantly improve NAS quality~\cite{zhou2020econas, chu2019fairnas, li2020random}.
Therefore, in the experiments (Sec.~\ref{sec:Experiment}), we evaluate GenNAS using the ranking correlation factors it achieves, and then show its end-to-end NAS performance in finding the best architectures.
Extensive experiments are done on 13 CNN search spaces and one NLP space~\cite{klyuchnikov2020bench}.
Trained by the regression proxy task using only a single batch of unlabeled data within a few seconds, GenNAS significantly outperforms all existing NAS approaches on almost all the search spaces and datasets.
For example, GenNAS achieves 0.87  on NASBench-101~\cite{ying2019bench}, while Zero-Cost NAS~\cite{abdelfattah2021zero}, an efficient proxy NAS approach, only achieves 0.38.
On end-to-end NAS, GenNAS generally outperforms others with large speedup.
This implies that the insights behind GenNAS are plausible and that our proposed regression-based task-agnostic approach is generalizable across tasks, search spaces, and datasets.
\vspace{-5pt}

\textbf{Contributions}. We summarize our contributions as follows:

\vspace{-5pt}

\begin{itemize}

\item {To the best of our knowledge, GenNAS is the first NAS approach using regression as the self-supervised proxy task instead of classification for neural architecture evaluation and search. It is agnostic to the specific downstream tasks and can significantly improve training and evaluation efficiency by fully utilizing only a handful of unlabeled data.
}

\item{GenNAS uses synthetic signal bases as the groundtruth to measure the intrinsic capability of networks that captures fundamental signal patterns. Using such unlabeled synthetic data in regression, GenNAS can find the generic task-agnostic top-performing networks and can apply to any new search spaces with zero effort.
}

\item {An automated proxy task search to further improve GenNAS performance.}
 
\item {Thorough experiments show that GenNAS outperforms existing NAS approaches by large margins in terms of ranking correlation with near-zero training cost, across 13 CNN and one NLP space \textit{without} proxy task search. GenNAS also achieves state-of-the-art performance for end-to-end NAS with orders of magnitude of speedup over conventional methods.
}
  
\item {With proxy task search being optional, GenNAS is fine-tuning-free, highly efficient, and can be easily implemented on a single customer-level GPU.
}

\end{itemize}

\section{Related Work}

\textbf{NAS Evaluation.}
Network architecture evaluation is critical in guiding the search algorithms of NAS by identifying the top-performing architectures, which is also a challenging task with intensive research interests.
Early NAS works evaluated the networks by training from scratch with tremendous computation and time cost~\cite{zoph2018learning,real2019regularized}. 
To expedite, weight-sharing among the subnets sampled from a supernet is widely adopted~\cite{liu2018darts,li2020random,cai2018proxylessnas,xu2019pc,li2020edd}.
However, due to the poor correlation between the weight-sharing and the final performance ranking, weight-sharing NAS can easily fail even in simple search spaces~\cite{zela2019understanding,dong2020bench}.
Yu et al.~\cite{yu2019evaluating} further pointed out that without accurate evaluation, NAS runs in a near-random fashion.
Recently, zero-cost NAS methods~\cite{mellor2020neural, abdelfattah2021zero,dey2021fear,li2021flash} have been proposed, which score the networks using their initial parameters with only one forward and backward propagation. Despite the significant speed up, they fail to identify top-performing architectures in large search spaces such as NASBench-101.
To detach the time-consuming network evaluation from NAS, several benchmarks are developed with fully-trained neural networks within the NAS search spaces~\cite{siems2020bench,ying2019bench,dong2020bench,klyuchnikov2020bench,su2021prioritized}, so that researchers can assess the search algorithms alone in the playground. 


\textbf{NAS Transferability.}
To improve search efficiency, proxy tasks are widely used, on which the architectures are searched and then transferred to target datasets and tasks. For example, the CIFAR-10 classification dataset seems to be a good proxy for ImageNet~\cite{zoph2018learning,liu2018darts}. Kornblith et al.~\cite{kornblith2019better} studied the transferability of 16 classification networks on 12 image classification datasets. NASBench-201~\cite{dong2020bench} evaluated the ranking correlations across three popular datasets with 15625 architectures. Liu et al.~\cite{liu2020labels} studied the architecture transferability across supervised and unsupervised tasks.
Nevertheless, training on a downsized proxy dataset is still inefficient (e.g. a few epochs of full-blown training~\cite{liu2020labels}). In contrast, GenNAS significantly improves the efficiency by using a single batch of data while maintaining extremely good generalizability across different search spaces and datasets.


\textbf{Self-supervised Learning.}
Self-supervised learning is a form of unsupervised learning, that the neural architectures are trained with automatically generated labels to gain a good degree of comprehension or understanding~\cite{jing2020self,dosovitskiy2014discriminative,doersch2015unsupervised,wang2015unsupervised, liu2020labels}.
Liu et al.~\cite{liu2020labels} recently proposed three unlabeled classification proxy tasks, including rotation prediction, colorization, and solving jigsaw puzzles, for neural network evaluation.
Though promising, this approach did not explain why such manually designed proxy tasks are beneficial and still used classification for training with the entire dataset.
In contrast, GenNAS uses regression with only a single batch of synthetic data.

\begin{figure}
\centering
     \begin{subfigure}[b]{0.58\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/CNN_Regression.pdf}
         \caption{CNN regression}
         \label{fig:StructureA}
     \end{subfigure}
\begin{subfigure}[b]{0.41\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/RNN_Regression.pdf}
         \caption{RNN regression}
         \label{fig:StructureB}
     \end{subfigure}
        \caption{Regression architectures on CNNs and RNNs. (a) On CNNs, we remove the final classifier and extract multiple stages of intermediate feature map for training. (b) On RNNs, we construct a many-to-many regression task, where the input and output tensors have the same size.}
        \label{fig:regression}
     \vspace{-8pt}
\end{figure}

\section{Proposed GenNAS}
In Section~\ref{sec:genNAS}, we introduce the main concepts of task-agnostic GenNAS: 1) the proposed regression proxy task for both CNN architectures and recurrent neural network (RNN) architectures; 2) the synthetic signal bases used for representing the fundamental data patterns as the proxy task.
In Section~\ref{sec:task_search}, we introduce the automated proxy task search.

\vspace{-4pt}
\subsection{GenNAS} \label{sec:genNAS}

\subsubsection{Regression Architectures} 
\label{sec:regression_arch}

Training using unlabeled regression is the key that GenNAS being agnostic to downstream tasks.
Based on the insights discussed in Section~\ref{sec:intro}, the \textit{principle} of designing the regression architecture is to \textit{fully utilize the abundant intermediate information} rather than the final classifier.


\textbf{Regression on CNNs.}
Empirical studies show that CNNs learn fine-grained high-frequency spatial details in the early layers and produce semantic features in the late layers~\cite{wang2020high}. 
Following this principle, as shown in Fig.~\ref{fig:regression}a,
we construct a Fully Convolutional Network (FCN)~\cite{long2015fully} by removing the final classifier of a CNN, and then extract the FCN's intermediate feature maps from \textit{multiple stages}.
We denote the number of stages as .
\textbf{Inputs}. The inputs to the FCN are unlabeled real images, shaped as a tensor , where  is the batch size, and  and  are the input image size.
\textbf{Outputs}. From each stage  () of the FCN, we first extract a feature map tensor, denoted by ,
and reshape it as  through a convolutional layer  by  (with downsampling if  or ).
The outputs are the tensors , which encapsulate the captured signal patterns from different stages.
\textbf{Groundtruth}. We construct a synthetic signal tensor for each stage as the groundtruth, which serves as part of the \textit{proxy task}. A synthetic tensor is a combination of multiple synthetic signal bases (more details in Section~\ref{sec:signals}), denoted by .
We compare  with  for training and evaluating the neural architectures.
During training, we use MSE loss defined as ;
during validation, we adjust each stage's output importance as  since the feature map tensors of later stages are more related to the downstream task's performance.
The detailed configurations of , , , and  are provided in the experiments.

\vspace{-2pt}
\textbf{Regression on RNNs.}
The proposed regression proxy task can be similarly applied to NLP tasks using RNNs.
Most existing NLP models use a sequence of word-classifiers as the final outputs, whose evaluations are thus based on the word classification accuracy~\cite{hochreiter1997long,mikolov2010recurrent,vaswani2017attention}.
Following the same principle for CNNs, we design a many-to-many regression task for RNNs as shown in Fig.~\ref{fig:regression}b.
Instead of using the final word-classifier's output, we extract the output tensor of the intermediate layer before it.
\textbf{Inputs}. For a general RNN model, the input is a random tensor , where  is the sequence length,  is the batch size, and  is the length of input/output word vectors.
Given a sequence of length , the input to the RNN each time is one slice of the tensor , denoted by , . 
\textbf{Outputs}. The output is , where a slice of  is .
\textbf{Groundtruth}. Similar to the CNN case, we generate a synthetic signal tensor  as the proxy task groundtruth. 


\vspace{-6pt}
\subsubsection{Synthetic Signal Bases}
\label{sec:signals}
\vspace{-4pt}

The proxy task for regression aims to capture the task-agnostic intrinsic learning capability of the neural architectures, i.e., representing various fundamental data patterns.
For example, good CNNs must be able to learn different frequency signals to capture image features~\cite{xu2019frequency}.
Here, we design four types of synthetic signal basis: (1) 1-D frequency basis~(\texttt{Sin1D}); (2) 2-D frequency basis~(\texttt{Sin2D}); (3) Spatial basis~(\texttt{Dot} and \texttt{GDot}); (4) Resized input signal (\texttt{Resize}).
\texttt{Sin1D} and \texttt{Sin2D} represent frequency information, \texttt{Dot} and \texttt{GDot} represent spatial information, and \texttt{Resize} reflects the CNN's scale-invariant capability. The combinations of these signal bases, especially with different sine frequencies, can represent a wide range of complicated real-world signals~\cite{tolstov2012fourier}.
If a network architecture is good at learning such signal basis and their simple combinations, it is more likely to be able to capture real-world signals from different downstream tasks.

Fig.\ref{fig:signalA} depicts examples of synthetic signal bases, where each base is a 2D signal feature map.
\texttt{Sin1D} is generated by  or , and
\texttt{Sin2D} is generated by ,
where  and  are pixel indices.
\texttt{Dot} is generated according to biased Rademacher distribution~\cite{montgomery1990distribution} by randomly setting  pixels to  on zeroed feature maps. 
\texttt{GDot} is generated by applying a Gaussian filter with  on \texttt{Dot} and normalizing between .
The synthetic signal tensor  (the proxy task groundtruth) is constructed by stacking the 2D signal feature maps along the channel dimension (CNNs) or the batch dimension (for RNNs).
Fig.\ref{fig:signals}b shows examples of stacked synthetic tensor  for CNN architectures.
Within one batch of input images, we consider two settings: \texttt{global} and \texttt{local}.
The \texttt{global} setting means that the synthetic tensor is the same for all the inputs within the batch, as the \texttt{Sin2D\,Global} in Fig.~\ref{fig:signalB}, aiming to test the network's ability to capture invariant features from different inputs; the \texttt{local} setting uses different synthetic signal tensors for different inputs, as the \texttt{Dot\,Local} in Fig.\ref{fig:signalB}, aiming to test the network's ability to distinguish between images.
For CNNs, the real images are only used by \texttt{resize}, and both \texttt{global} and \texttt{local} settings are used.
For RNNs, we only use synthetic signals and the \texttt{local} setting, because resizing natural language or time series, the typical input of RNNs, does not make as much sense as resizing images for CNNs. 

\begin{figure}
\vspace{-8pt}
     \centering
     \begin{subfigure}[b]{0.36\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/syntheticA.png}
         \caption{Examples of signal bases}
         \label{fig:signalA}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.61\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/syntheticB1.png}
         \caption{Examples of synthetic signal tensors}
         \label{fig:signalB}
     \end{subfigure}
        \caption{(a) Examples of synthetic signal bases (2D feature maps). (b) Examples of the synthetic signal tensors by stacking 2D feature maps along the channel dimension for CNN architectures. }\label{fig:signals}
        \vspace{-8pt}
\end{figure}


\vspace{-8pt}
\subsection{Proxy Task Search} 
\label{sec:task_search}
\vspace{-4pt}

While the synthetic signals can express generic features, the importance of these features for different tasks, NAS search spaces, and datasets may be different.
Therefore, we further propose a weakly-supervised proxy task search, to automatically find the best synthetic signal tensor, i.e., the best combination of synthetic signal bases.
We define the \textit{proxy task search space} as the parameters when generating the synthetic signal tensors.
As illustrated in Fig.~\ref{fig:proxy_search}, first, we randomly sample a small subset (e.g., 20) of the neural architectures in the NAS search space and obtain their groundtruth ranking on the target task (e.g., image classification).
We then train these networks using different proxy tasks and calculate the performance ranking correlation  of the proxy and the target task.
We use the regularized tournament selection evolutionary algorithm~\cite{real2019regularized} to search for the task that results in the largest , where  is the fitness function.

\begin{wrapfigure}{h}{0.45\textwidth}
\vspace{-16pt}
  \begin{center}
    \includegraphics[width=0.45\textwidth]{images/Proxy_Search.pdf}
  \end{center}
  \caption{Proxy task search.}
  \label{fig:proxy_search}
  \vspace{-16pt}
\end{wrapfigure}



\textbf{Proxy Task Search Space.} 
We consider the following parameters as the proxy task search space.
(1) Noise.
We add noise to the input data following the distribution of parameterized Gaussian or uniform distribution.
(2) The number of channels for each synthetic signal tensor ( in ) can be adjusted. 
(3) Signal parameters, such as the frequency  and phase  in \texttt{Sin}, can be adjusted.
(4) Feature combination.
Each synthetic signal tensor uses either \texttt{local} or \texttt{global}, and tensors can be selected and summed up.
Detailed parameters can be found in the supplemental material.


\vspace{-8pt}
\section{Experiments~\label{sec:Experiment}}
\vspace{-6pt}

We perform the following evaluations for GenNAS.
\underline{First}, to show the \textit{true power of regression}, we use manually designed proxy tasks \textit{without task search} and apply the same proxy task on all datasets and search spaces. We demonstrate that the \textit{GenNAS generally excels in all different cases with zero task-specific cost}, thanks to unlabeled self-supervised regression proxy task.
Specifically, in Section~\ref{sec:ablation-signals}, we analyze the effectiveness of the synthetic signal bases and manually construct two sets of synthetic tensors as the baseline proxy tasks;
in Section~\ref{sec:exp-regression}, we extensively evaluate the proposed regression approach in 13 CNN search spaces and one NLP search space.
\underline{Second}, in Section~\ref{sec:task-search-transfer}, we evaluate the proxy task search and demonstrate the remarkable generalizability by applying one searched task to all NAS search spaces with no change.
\underline{Third}, in Section~\ref{sec:exp-nas-search}, we evaluate GenNAS on end-to-end NAS tasks, which outperforms existing works with significant speedup. 

\textbf{Experiment Setup}. We consider 13 CNN NAS search spaces including NASBench-101~\cite{ying2019bench}, NASBench-201~\cite{dong2020bench}, Network Design Spaces (NDS)~\cite{radosavovic2019network}, and one NLP search space, NASBench-NLP~\cite{klyuchnikov2020bench}. 
All the training is conducted using only one batch of data with batch size 16 for 100 iterations. Details of NAS search spaces and experiment settings are in the supplemental material.



\vspace{-5pt}
\subsection{Effectiveness of Synthetic Signals} 
\label{sec:ablation-signals}
\vspace{-4pt}

The synthetic signal analysis is performed on NASBench-101 using CIFAR-10 dataset.
From the whole NAS search space, 500 network architectures are randomly sampled with a known performance ranking provided by NASBench-101.
We train the 500 networks using different synthetic signal tensors and calculate their ranking correlations with respect to the groundtruth ranking.
Using the CNN architecture discussed in Section~\ref{sec:regression_arch}, we consider three stages,  to  for ; the number of channels is 64 for each stage.
For \texttt{Sin1D} and \texttt{Sin2D}, we set three ranges for frequency : low (L)  , medium (M) , and high (H) .
Within each frequency range, 10 signals are generated using uniformly sampled frequencies.
For \texttt{Dot} and \texttt{GDot}, we randomly set  and  pixels to  on the zeroized feature maps.


\begin{table}
\vspace{-8pt}
\small
  \caption{Ranking correlation (Spearman's ) analysis of different synthetic signals on NASBench-101. }\label{table:signal_ablation}
  \centering
  \scriptsize
\begin{tabular}{cllllllllllll}
\toprule
\multirow{2}{*}{Stage} & \multicolumn{3}{c}{\texttt{Sin1D}} & \multicolumn{3}{c}{\texttt{Sin2D}} & \multicolumn{2}{c}{\texttt{Dot}} & \multicolumn{2}{c}{\texttt{GDot}} & \multirow{2}{*}{\texttt{Resize}} & \multirow{2}{*}{\texttt{Zero}}\\
\cmidrule(r){2-11}
                  &   L    &    M   &   H   &  L     &    M   &   H   &      50\%     &    100\%      &     50\%      &    100\%      &        &           \\
\midrule
 & 0.13 & 0.43 & \textbf{0.64} & 0.14 & 0.53 & {0.63} & 0.55 & 0.62 & 0.18 & 0.16 & 0.56 & 0.17\\
 & 0.03 & 0.52 & \textbf{0.79} & 0.05 & 0.73 & 0.72 & 0.64 & 0.69 & 0.03 & 0.02 & 0.73 & 0.18\\
 & 0.08 & 0.77 & 0.80 & 0.23 & 0.78 & 0.72 & 0.76 & \textbf{0.81} & 0.16 & 0.17 & 0.80 & 0.22\\\midrule
\multicolumn{11}{l}{\textbf{GenNAS-combo:}: \textbf{0.85}} \\
\bottomrule
\end{tabular}
\vspace{-8pt}
\end{table}

The results of ranking correlations are shown in Table~\ref{table:signal_ablation}.
The three stages are evaluated independently and then used together.
Among the three stages,
\texttt{Sin1D} and \texttt{Sin2D} within medium and high frequency work better in  and , while the high frequency \texttt{Dot} and \texttt{resize} work better in . 
The low frequency signals, such as \texttt{GDot}, \texttt{Sin1D}-L, \texttt{Sin2D}-L, and the extreme case \texttt{zero} tensors, result in low ranking correlations; we attribute to their poor distinguishing ability. 
We also observe that the best task in  (0.81) achieves higher  than  (0.64) and  (0.79), which is consistent with the intuition that the features learned in deeper stages have more impact to the final network performance. 

When all three stages are used, where each stage uses its top-3 signal bases,
the ranking correlation can achieve 0.85, higher than the individual stages. This supports our assumption in Section~\ref{sec:regression_arch} that utilizing more intermediate information of a network is beneficial. 
From this analysis, we choose two top-performing proxy tasks in the following evaluations to demonstrate the effectiveness of regression:
\textbf{GenNAS-single} -- the best proxy task with a single signal tensor \texttt{Dot\%100} used only in ,
and \textbf{GenNAS-combo} -- the combination of the three top-performing tasks in three stages.
















\vspace{-10pt}
\subsection{Effectiveness and Efficiency of Regression without Proxy Task Search}
\label{sec:exp-regression}
\vspace{-4pt}




To quantify how well the proposed regression can approximate the neural architecture performance with only one batch of data within seconds, we use the ranking correlation, Spearman's , as the metric~\cite{abdelfattah2021zero, liu2020labels, zela2019understanding}.
We use the two manually designed proxy tasks (GenNAS-single and GenNAS-combo) without proxy task search to demonstrate that \textbf{GenNAS is generic and can be directly applied to any new search spaces with zero task-specific search efforts}.
The evaluation is extensively conducted on 13 CNN search spaces and 1 NLP search space, and the results are summarized in Table~\ref{table:GenNAS_rankingcorrelation}.



\begin{table}[t]
\vspace{-8pt}
\scriptsize
  \caption{\small{GenNAS ranking correlation evaluation using the correlation Spearman’s . \textbf{GenNAS-single} and \textbf{GenNAS-combo} use a single or a combination of synthetic signals that are manually designed \textit{without proxy task search}. \textbf{GenNAS search-N, -D, -R} mean the proxy task is searched on NASBench-101, NDS DARTS design space, and NDS ResNet design space, respectively. 
  The top-1/2/3 results of GenNAS and efficient NAS baselines are highlighted by // respectively for each task. The values with superscripts are obtained after task search  () or transferred () from a previous searched task. Methods like jig@ep10 which is 40x slower compared to the GenNAS in prediction are not considered as efficient ones.
}\normalsize{}
  }
  \label{table:GenNAS_rankingcorrelation}
  \centering
\setlength{\tabcolsep}{3pt}
\resizebox{0.81\textwidth}{!}{\begin{tabular}{lcc|cccc|ccc}
\Xhline{0.8pt}
\multicolumn{10}{l}{\textbf{NASBench-101}} \\ \hline
Dataset & NASWOT & synflow & {jig@ep10} & {rot@ep10} & {col@ep10} & {cls@ep10} & \multicolumn{3}{c}{\textbf{GenNAS}} \\\cline{4-10}
     & ~\cite{mellor2020neural} & ~\cite{abdelfattah2021zero}  &\multicolumn{4}{c}{ slower}    & single & combo & search-N \\\hline
CIFAR-10 & 0.34 & 0.38 &  0.69  & 0.85  & 0.71 &  0.81 &  &  & ^{\dagger s}\\
ImgNet & 0.21 & 0.09 &  0.72 &  0.82  & 0.67  & 0.79 &  &  &  \\
\Xhline{0.8pt}
\vspace{-8pt}
\end{tabular}}
\resizebox{0.81\textwidth}{!}{
\begin{tabular}{lccccccc|ccc}
\Xhline{0.8pt}
\multicolumn{11}{l}{\textbf{NASBench-201}} \\ \hline
Dataset & NASWOT & synflow &jacob\_cov & snip & cls@ep10 & vote & EcoNAS & \multicolumn{3}{c}{\textbf{GenNAS}} \\\cline{9-11}
&&& & & slower & &  slower& single & combo & search-N \\\hline
CIFAR-10 &  & 0.72 &0.76 &0.57&0.75  & 0.81  & 0.81 &0.77 &  &  \\
CIFAR-100 & 0.81& 0.76 &0.70 &0.61&0.75& & 0.75 & 0.69& &  \\
ImgNet16 & & 0.73 &0.73 &0.59&0.68& 0.81& 0.77 &0.70& &  \\
\Xhline{0.8pt}
\end{tabular}}
\resizebox{0.81\textwidth}{!}{
\begin{tabular}{lcccc|ccccc}
\Xhline{0.8pt}
\multicolumn{10}{l}{\textbf{Neural Design Spaces}} \\ \hline
Dataset & NAS-Space & NASWOT & synflow & cls@ep10 &  \multicolumn{5}{c}{\textbf{GenNAS}}  \\ \cline{6-10}
 & & & &  slower& single & combo & search-N & search-D & search-R \\\hline
CIFAR-10 & DARTS & 0.65 & 0.41 & 0.63 & 0.43 & 0.68 & 0.71 & \textbf{0.86} & {0.82} \\
& DARTS-f & 0.31 & 0.09 & 0.82 & 0.51 & {\textbf{0.59}} & {0.53} & {0.58} & 0.52 \\
& Amoeba & 0.33 & 0.06 & 0.67 & 0.52 & 0.64 & {0.68} & {\textbf{0.78}} & {0.72} \\
& ENAS & 0.55 & 0.19 & 0.66 & 0.56 & {0.70} & 0.67 & {\textbf{0.82}} & {0.78} \\
& ENAS-f & 0.43 & 0.26 & {0.86} & 0.65 & 0.65 & {0.67} & {\textbf{0.73}} & {0.67} \\
& NASNet & 0.40 & 0.00 & 0.64 & 0.56 & {0.66} & 0.65 & {\textbf{0.77}} & {0.71} \\
& PNAS & 0.51 & 0.26 & 0.50 & 0.32& 0.58 & {0.59} & {\textbf{0.76}} & {0.71} \\
& PNAS-f & 0.10 & 0.32 & {0.85} & 0.45 & {0.48} & {\textbf{0.56}} & {0.55} & 0.47 \\
& ResNet & 0.26 & 0.22 & 0.65 & 0.34& 0.52 & {0.55} & {0.54} & {\textbf{0.83}} \\
& ResNeXt-A & {0.65} & 0.48 & {0.86} &0.57 & 0.61 & {0.80} & 0.63 &{\textbf{0.84}} \\
& ResNeXt-B & {0.60} & {0.60} & 0.66 & 0.26 & 0.30 & 0.53 & 0.55 & {\textbf{0.71}} \\

\hline

ImageNet & DARTS & 0.66 & 0.21 & -- &0.61 & {0.75} & {0.70} & {\textbf{0.84}} & 0.55 \\
 & DARTS-f & 0.20 & 0.37 & --  &{0.68} & {0.69} & 0.67 & {\textbf{0.69}} &  0.59 \\
 & Amoeba & 0.42 & 0.25 & -- & 0.63 & {0.72} & {0.73} &  {\textbf{0.80}} & 0.67 \\
 & ENAS & {0.69} & 0.17 & -- &0.59 & {0.70} & 0.58 & {\textbf{0.81}} & {0.65} \\
 & NASNet & 0.51 & 0.01 & -- &0.52 &  {0.59} & 0.52 &  {\textbf{0.70}} & {0.61} \\
 & PNAS & {0.60} & 0.14 & -- & 0.28 & 0.39 & {0.45} & {\textbf{0.62}} & 0.40 \\
 & ResNeXt-A & 0.72 & 0.42 & -- & {0.80}& {0.84}& 0.75 & 0.62 & {\textbf{0.87}} \\
 & ResNeXt-B & 0.63 & 0.31 & -- & {0.71}& {\textbf{0.79}} & 0.51 & 0.60 & {0.64} \\
\Xhline{0.8pt}
\end{tabular}}
\resizebox{0.81\textwidth}{!}{
\begin{tabular}{lcccccc|ccc}
\Xhline{0.8pt}
\multicolumn{10}{l}{\textbf{NASBench-NLP}} \\ \hline
Dataset & grad\_norm & snip & grasp & synflow & jacob\_cov & ppl@ep3 & \multicolumn{3}{c}{\textbf{GenNAS}} \\ \cline{8-10}
& & & & & &  slower & single & combo & search \\\hline
PTB & 0.21 & 0.19 & 0.16 & 0.34 & 0.56 & {0.79} &0.73 &{0.74} & {\textbf{0.81}} \\\Xhline{0.8pt}

\end{tabular}}
 \vspace{-14pt}
\end{table}
\normalsize{}


\vspace{-5pt}

\underline{On NASBench-101},
GenNAS is compared with zero-cost NAS~\cite{abdelfattah2021zero, mellor2020neural} and the latest classification based approaches~\cite{liu2020labels}.
Specifically, NASWOT~\cite{mellor2020neural} is a zero-training approach that predicts a network's trained accuracy from its initial state by examining the overlap of activations between datapoints.
Abdelfattah et al.~\cite{abdelfattah2021zero} proposed proxies such as synflow to evaluate the networks, where the synflow computes the summation of all the weights multiplied by their gradients and has the best reported performance in the paper.
Liu et al.~\cite{liu2020labels} used three unsupervised classification training proxies, namely rotation prediction (rot), colorization (col), and solving jigsaw puzzles (jig), and one supervised classification proxy (cls).
\begin{wrapfigure}{h}{0.5\textwidth}
  \vspace{-12pt}
  \begin{center}
\includegraphics[width=0.5\textwidth]{images/nb101cifar.pdf}
  \end{center}
  \vspace{-5pt}

  \caption{The effectiveness of regression-based proxy task. GenNAS significantly outperforms all the existing NAS evaluation approaches regarding ranking correlation, with near-zero training cost.}
  \label{fig:regression-visulization}
\end{wrapfigure}
We report their results after 10 epochs (@ep10) for each proxy.
The results show that GenNAS-single and GenNAS-combo achieve 0.81 and 0.85  on CIFAR-10, and achive 0.73 on ImageNet, respectively, much higher than NASWOT and synflow. It is also comparable and even higher comparing with the classification proxies, cls@ep5 and cls@ep10.
Notably, the classification proxies need to train for 10 epochs using \textit{all training data}, while GenNAS requires only a few seconds, more than 40 faster. 
\underline{On NASBench-201}, we further compare with vote~\cite{abdelfattah2021zero} and EcoNAS~\cite{zhou2020econas}.
EcoNAS is a recently proposed reduced-training proxy NAS approach.
Vote~\cite{abdelfattah2021zero} adopts the majority vote between three zero-training proxies including synflow, jacob\_cov, and snip.
Clearly, GenNAS-combo outperforms all these methods regarding ranking correlation, and is also  faster than EcoNAS and  faster than cls@ep10.
\underline{On Neural Design Spaces}, we evaluate GenNAS on both CIFAR-10 and ImageNet datasets. 
Comparing with NASWOT and synflow, GenNAS-single and GenNAS-combo achieve higher  in almost all cases. 
Also, synflow performs poorly on most of the NDS search spaces especially on ImageNet dataset, while GenNAS achieves even higher .
Extending to NLP search space, \underline{NASBench-NLP}, GenNAS-single and GenNAS-combo achieve 0.73 and 0.74 , respectively, surpassing the best zero-proxy method (0.56). Comparing with the ppl@ep3, the architectures trained on PTB~\cite{marcus1993building} dataset after three epochs, GenNAS is  faster in prediction.

\vspace{-5pt}


Fig.~\ref{fig:regression-visulization} visualizes the comparisons between GenNAS and existing NAS approaches on NASBench-101, CIFAR-10. Clearly, regression-based GenNAS (single, combo) significantly outperforms the existing NAS with near-zero training cost, showing remarkable effectiveness and high efficiency.

\vspace{-13pt}

\subsection{Effectiveness of Proxy Task Search and Transferability}
\label{sec:task-search-transfer}
\vspace{-8pt}


\begin{wrapfigure}{b}{0.42\textwidth}
\vspace{-14pt}
  \begin{center}
    \includegraphics[width=0.43\textwidth]{images/task-search-evolutionary.pdf}
  \end{center}
  \vspace{-10pt}
  \caption{Proxy task search.}
  \label{fig:task-search}
\end{wrapfigure}



\textbf{Effectiveness of Proxy Task Search.} 
While the \textit{unsearched} proxy tasks can already significantly outperform all existing approaches (shown in Section~\ref{sec:exp-regression}), we demonstrate that the proxy task search described in Section~\ref{sec:task_search} can further improve the ranking correlation.
We adopt the regularized evolutionary algorithm~\cite{real2019regularized}. The population size is ; the tournament sample size is ; 
the search runs  iterations. We randomly select 20 architectures with groundtruth for calculating the . More settings can be found in the supplemental material.
Fig.~\ref{fig:task-search} shows the search results averaged from 10 runs with different seeds.
It shows that the regularized evolutionary algorithm is more effective comparing with random search, where the correlations of 20 architectures are  and , respectively.



In the following experiments, we evaluate three searched proxy tasks, denoted by \textbf{GenNAS search-N}, \textbf{-D}, and \textbf{-R}, meaning that the task is searched on \underline{N}ASBench-101, NDS \underline{D}ARTS search space, and NDS \underline{R}esNet search space, respectively.
We study the performance and transferability of the searched tasks on all NAS search spaces. Proxy task search is done on a single GPU GTX 1080Ti. On NASBench-101 (\textbf{GenNAS-N}), ResNeXt (\textbf{GenNAS-R}), and DARTS (\textbf{GenNAS-D}), the search time is 5.75, 4, and 12.25 GPU hours, respectively. Once the proxy tasks is searched, it can be used to evaluate any architectures in the target search space and can be transferred to other search spaces.

\textbf{GenNAS with Searched/Transferred Proxy Task}.
The performance of GenNAS-search-N, -D, and -R proxy tasks is shown in Table~\ref{table:GenNAS_rankingcorrelation}.
First, in most cases, proxy task search improves the ranking correlation. For example, in NDS, using the proxy task searched on DARTS space (search-D) outperforms other GenNAS settings on DARTS-like spaces, while using proxy task search-R on ResNet-like spaces outperforms others as well. 
In NASBench-NLP, the proxy task search can push the ranking correlation to 0.81, surpassing the ppl@ep3 (0.79).
Such results demonstrate the effectiveness of our proposed proxy task search.
Second, the searched proxy task shows great transferability: the proxy task searched on NASBench-101 (search-N) generally works well for other search spaces, i.e., NASBench-201, NDS, and NASBench-NLP.
This further emphasizes that the fundamental principles for top-performing neural architectures are similar across different tasks and datasets.
Fig.~\ref{fig:regression-visulization} visualizes the performance of GenNAS comparing with others.




\begin{table}[]
\vspace{-5pt}
\scriptsize
  \caption{GenNAS end-to-end NAS results comparing with the state-of-the-art NAS approaches, showing test accuracy (\%) on different NAS-spaces and datasets.  denotes a method that is replicated with the same regularized evolutionary algorithm in Section~\ref{sec:exp-nas-search} for fair comparison. On NASBench-201, the GPU hours do not include task search since GenNAS-N is transferred from NASBench-101. The values with superscripts are obtained after task search  () or transferred () from a previous searched task.
  }
  \label{table:GenNAS_NAS_end_to_end}
  \centering
  \scriptsize
\setlength{\tabcolsep}{3pt}
\begin{tabular}{lccccccccc}

\toprule
\multicolumn{6}{l}{\textbf{NASBench-101(CIFAR-10)}} \\ \midrule
Optimal & NASWOT & synflow & Halfway & \textbf{GenNAS-N} \\\midrule
94.32 & 93.300.002 & 91.310.02 & 93.280.002 & \textbf{93.920.004} \\

\toprule
\multicolumn{6}{l}{\textbf{NASBench-201}} \\ \midrule
Dataset & Optimal & RSPS & DARTS-V2 & GDAS & SETN & ENAS & NASWOT & \textbf{GenNAS-N} \\\midrule
CIFAR-10 & 94.37 & 84.073.61  & 54.300.00 & 93.610.09 & 87.640.00 & 53.890.58 & 92.960.80 & \textbf{94.180.10} \\

CIFAR-100 & 73.49 & 58.334.34 & 15.610.00  & 70.610.26 & 56.877.77 & 15.610.00 & 70.031.16 & \textbf{72.560.74} \\

ImgNet16 & 47.31 & 26.283.09  & 16.320.00 & 41.710.98 & 32.520.21 & 14.842.10 & 44.432.07 & \textbf{45.590.54} \\
\midrule
\multicolumn{2}{l}{GPU hours} & 2.2  & 9.9 & 8.8 & 9.5 & 3.9 & 0.1 & 0.3 \\

\toprule
\multicolumn{6}{l}{\textbf{Neural Design Spaces (CIFAR-10)}} \\ \midrule
NAS-Space & Optimal & NASWOT & synflow & cls@ep10 & \textbf{GenNAS-N} & \textbf{GenNAS-R} & \textbf{GenNAS-D} \\\midrule
ResNet & 95.30 & 92.810.10 & 93.520.31  & 94.510.20 & 94.480.24& 94.630.23 &\textbf{94.770.13} \\
ResNeXt-A &94.99 & 93.390.67 & 94.050.48 & 94.24 0.22& 94.250.21 &94.120.20 &\textbf{94.370.14}\\
ResNeXt-B & 95.12 & 93.560.33 & 93.650.64 & 94.330.26 &\textbf{94.290.24}& 94.260.35 &94.230.32\\

\bottomrule
\end{tabular}
\vspace{-8pt}
\end{table}


\vspace{-8pt}

\subsection{GenNAS for End-to-End NAS}
\label{sec:exp-nas-search}






Finally, we evaluate GenNAS on the end-to-end NAS tasks, aiming to find the best neural architectures within the search space.
Table~\ref{table:GenNAS_NAS_end_to_end} summarizes the comparisons with the state-of-the-art NAS approaches, including previously used NASWOT, synflow, cls@ep10, and additionally Halfway~\cite{ying2019bench}, RSPS~\cite{li2020random}, DARTS-V1~\cite{liu2018darts}, DARTS-V2, GDAS~\cite{dong2019searching}, SETN~\cite{dong2019one}, and ENAS~\cite{pham2018efficient}.
Halfway is the NASBench-101-released result using half of the total epochs for network training.
In all the searches during NAS, we do not use any tricks such as warmup selection~\cite{abdelfattah2021zero} or groundtruth query to compensate the low rank correlations. 
We fairly use a simple yet effective regularized evolutionary algorithm~\cite{real2019regularized} and adopt the proposed regression loss as the fitness function. 
The population size is  and the tournament sample size is  with 400 iterations.
On \underline{NASBench-101}, GenNAS finds better architectures than NASWOT and Halfway while being up to 200 faster.
On \underline{NASBench-201}, GenNAS finds better architectures than the state-of-the-art GDAS within 0.3 GPU hours, being  faster.
Note that GenNAS uses the proxy task searched on NASBench-101 and transferred to NASBench-201, demonstrating remarkable transferability.
On \underline{Neural Design Spaces}, GenNAS finds better architectures than the cls@ep10 using labeled classification while being 40 faster.
On \underline{NASBench-NLP}, GenNAS finds architectures that achieve 0.246 (the lower the better) average final regret score , outperforming the ppl@ep3 (0.268) with 192 speed up. The regret score  at the moment  is , where  is the testing log perplexity of the best found architecture according to the prediction by the moment, and  is the lowest testing log perplexity in the whole dataset achieved by LSTM~\cite{hochreiter1997long} architecture. 

On \underline{DARTS search space}, we also perform the end-to-end search on ImageNet-1k~\cite{deng2009imagenet} dataset. We fix the depth (layer) of the networks to be 14 and adjust the width (channel) so that the \# of FLOPs is between 500M to 600M. We evaluate two strategies: one without task search using GenNAS-combo (see Table~\ref{table:signal_ablation}), and the other {GenNAS-D14} with proxy task search on DARTS search space with depth 14 and initial channel 16. The training settings follow TENAS~\cite{chen2021neural}. The results are shown in Table~\ref{table:GenNAS_NAS_Imagenet}. We achieve top-1/5 test error of 25.1/7.8 using GenNAS-combo and top-1/5 test error of 24.3/7.2 using GenNAS-D14, which are on par with existing NAS architectures.  GenNAS-combo is much faster than existing works, while GenNAS-D14 pays extra search time cost. Our next step is to investigate the searched tasks and demonstrate the generalization and transferrability of those searched tasks to further reduce the extra search time cost. 

\begin{table}[]
\scriptsize
  \caption{Comparisons with state-of-the-art NAS methods on ImageNet under the mobile setting.  is the time for proxy task search.
  }
  \label{table:GenNAS_NAS_Imagenet}
  \centering
  \scriptsize
\begin{tabular}{lccccccc}
\toprule
\multirow{2}{*}{Method} & \multicolumn{2}{c}{Test Err. (\%)} & Params & FLOPS(M) & Search Cost & Searched & Searched \\ \cline{2-3} 
                        & top-1          & top-5         &(M)&(M)&(GPU days)&Method&dataset
      \\ \midrule 
NASNet-A~\cite{zoph2018learning} &  26.0 &8.4&5.3&564&~2000&RL&CIFAR-10\\
AmoebaNet-C~\cite{real2019regularized} & 24.3 & 7.6 &  6.4 & 570 & 3150&evolution&CIFAR-10\\
PNAS~\cite{liu2018progressive}&25.8&8.1&5.1&588&225&SMBO&CIFAR-10\\
\midrule
DARTS(2nd order)~\cite{liu2018darts} &26.7& 8.7& 4.7& 574& 4.0& gradient-based&CIFAR-10\\

SNAS~\cite{xie2018snas}&27.3&9.2&4.3& 522& 1.5&gradient-based&CIFAR-10\\
GDAS~\cite{dong2019searching}&26.0&8.5&5.3&581&0.21&gradient-based&CIFAR-10\\
P-DARTS~\cite{chen2019progressive}&24.4&7.4 &4.9 &557 &0.3 &gradient-based &CIFAR-10\\
P-DARTS&24.7&7.5&5.1 &577 &0.3 &gradient-based &CIFAR-100\\
PC-DARTS~\cite{xu2019pc}&25.1 &7.8 &5.3 &586 &0.1 &gradient-based&CIFAR-10\\
TE-NAS~\cite{chen2021neural}&26.2 &8.3 &6.3&-& 0.05& training-free&CIFAR-10\\
\midrule
PC-DARTS&24.2 &7.3 &5.3 &597 &3.8 &gradient-based&ImageNet\\
ProxylessNAS~\cite{cai2018proxylessnas} &  24.9 &7.5 &7.1 &465 &8.3 &gradient-based&ImageNet\\
UNNAS-jig~\cite{liu2020labels}&24.1&-&5.2&567&2&gradient-based&ImageNet\\
TE-NAS& 24.5  &7.5 &5.4 & 599&0.17&training-free&ImageNet\\
\midrule
\textbf{GenNAS-combo} & 25.1&7.8&4.8&559&0.04&evolution+few-shot&CIFAR-10\\
\textbf{GenNAS-D14} & 24.3&7.2&5.3&599&0.7+0.04&evolution+few-shot&CIFAR-10\\
\bottomrule

\end{tabular}
\end{table}

These end-to-end NAS experiments strongly suggest that GenNAS is generically efficient and effective across different search spaces and datasets.

\vspace{-8pt}
\section{Conclusion}
\vspace{-8pt}
In this work, we proposed GenNAS, a self-supervised regression-based approach for neural architecture training, evaluation, and search.
GenNAS successfully answered the two questions at the beginning.
(1) GenNAS \textit{is} a generic task-agnostic method, using synthetic signals to capture neural networks' fundamental learning capability without specific downstream task knowledge.
(2) GenNAS \textit{is} an extremely effective and efficient method using regression, fully utilizing all the training samples and better capturing valued information.
We show the true power of self-supervised regression via manually designed proxy tasks that do not need to search. 
With proxy search, GenNAS can deliver even better results.
Extensive experiments confirmed that GenNAS is able to deliver state-of-the-art performance with near-zero search time, in terms of both ranking correlation and the end-to-end NAS tasks with great generalizability.
\vspace{-4pt}

\section{Acknowledgement}
We thank IBM-Illinois Center for Cognitive Computing Systems Research (C3SR) for supporting this research. 
We thank all reviewers and the area chair for valuable discussions and feedback.
This work utilizes resources~\cite{kindratenko2020hal} supported by the National Science Foundation’s Major Research Instrumentation program, grant \#1725729, as well as the University of Illinois at Urbana-Champaign. P.L. is also partly supported by the 2021 JP Morgan Faculty Award and the National Science Foundation award HDR-2117997.






\bibliographystyle{unsrt}

\begin{thebibliography}{10}

\bibitem{real2019regularized}
Esteban Real, Alok Aggarwal, Yanping Huang, and Quoc~V Le.
\newblock Regularized evolution for image classifier architecture search.
\newblock In {\em Proceedings of the aaai conference on artificial
  intelligence}, volume~33, pages 4780--4789, 2019.

\bibitem{zoph2016neural}
Barret Zoph and Quoc~V Le.
\newblock Neural architecture search with reinforcement learning.
\newblock {\em arXiv preprint arXiv:1611.01578}, 2016.

\bibitem{liu2018darts}
Hanxiao Liu, Karen Simonyan, and Yiming Yang.
\newblock Darts: Differentiable architecture search.
\newblock {\em arXiv preprint arXiv:1806.09055}, 2018.

\bibitem{cai2018proxylessnas}
Han Cai, Ligeng Zhu, and Song Han.
\newblock Proxylessnas: Direct neural architecture search on target task and
  hardware.
\newblock {\em arXiv preprint arXiv:1812.00332}, 2018.

\bibitem{su2021vision}
Xiu Su, Shan You, Jiyang Xie, Mingkai Zheng, Fei Wang, Chen Qian, Changshui
  Zhang, Xiaogang Wang, and Chang Xu.
\newblock Vision transformer architecture search.
\newblock {\em arXiv preprint arXiv:2106.13700}, 2021.

\bibitem{liu2019auto}
Chenxi Liu, Liang-Chieh Chen, Florian Schroff, Hartwig Adam, Wei Hua, Alan~L
  Yuille, and Li~Fei-Fei.
\newblock Auto-deeplab: Hierarchical neural architecture search for semantic
  image segmentation.
\newblock In {\em Proceedings of the IEEE/CVF Conference on Computer Vision and
  Pattern Recognition}, pages 82--92, 2019.

\bibitem{nekrasov2019fast}
Vladimir Nekrasov, Hao Chen, Chunhua Shen, and Ian Reid.
\newblock Fast neural architecture search of compact semantic segmentation
  models via auxiliary cells.
\newblock In {\em Proceedings of the IEEE/CVF Conference on Computer Vision and
  Pattern Recognition}, pages 9126--9135, 2019.

\bibitem{shaw2019squeezenas}
Albert Shaw, Daniel Hunter, Forrest Landola, and Sammy Sidhu.
\newblock Squeezenas: Fast neural architecture search for faster semantic
  segmentation.
\newblock In {\em Proceedings of the IEEE/CVF International Conference on
  Computer Vision Workshops}, pages 0--0, 2019.

\bibitem{li2021bossnas}
Changlin Li, Tao Tang, Guangrun Wang, Jiefeng Peng, Bing Wang, Xiaodan Liang,
  and Xiaojun Chang.
\newblock Bossnas: Exploring hybrid cnn-transformers with block-wisely
  self-supervised neural architecture search.
\newblock {\em arXiv preprint arXiv:2103.12424}, 2021.

\bibitem{wang2020hat}
Hanrui Wang, Zhanghao Wu, Zhijian Liu, Han Cai, Ligeng Zhu, Chuang Gan, and
  Song Han.
\newblock Hat: Hardware-aware transformers for efficient natural language
  processing.
\newblock {\em arXiv preprint arXiv:2005.14187}, 2020.

\bibitem{so2019evolved}
David So, Quoc Le, and Chen Liang.
\newblock The evolved transformer.
\newblock In {\em International Conference on Machine Learning}, pages
  5877--5886. PMLR, 2019.

\bibitem{hao2018deep}
Cong Hao and Deming Chen.
\newblock Deep neural network model and fpga accelerator co-design:
  Opportunities and challenges.
\newblock In {\em 2018 14th IEEE International Conference on Solid-State and
  Integrated Circuit Technology (ICSICT)}, pages 1--4. IEEE, 2018.

\bibitem{hao2019fpga}
Cong Hao, Xiaofan Zhang, Yuhong Li, Sitao Huang, Jinjun Xiong, Kyle Rupnow,
  Wen-mei Hwu, and Deming Chen.
\newblock Fpga/dnn co-design: An efficient design methodology for 1ot
  intelligence on the edge.
\newblock In {\em 2019 56th ACM/IEEE Design Automation Conference (DAC)}, pages
  1--6. IEEE, 2019.

\bibitem{zhang2019skynet}
Xiaofan Zhang, Haoming Lu, Cong Hao, Jiachen Li, Bowen Cheng, Yuhong Li, Kyle
  Rupnow, Jinjun Xiong, Thomas Huang, Honghui Shi, et~al.
\newblock Skynet: a hardware-efficient method for object detection and tracking
  on embedded systems.
\newblock {\em arXiv preprint arXiv:1909.09709}, 2019.

\bibitem{lin2020mcunet}
Ji~Lin, Wei-Ming Chen, Yujun Lin, John Cohn, Chuang Gan, and Song Han.
\newblock Mcunet: Tiny deep learning on iot devices.
\newblock {\em arXiv preprint arXiv:2007.10319}, 2020.

\bibitem{lin2021mcunetv2}
Ji~Lin, Wei-Ming Chen, Han Cai, Chuang Gan, and Song Han.
\newblock Mcunetv2: Memory-efficient patch-based inference for tiny deep
  learning.
\newblock {\em arXiv preprint arXiv:2110.15352}, 2021.

\bibitem{real2017large}
Esteban Real, Sherry Moore, Andrew Selle, Saurabh Saxena, Yutaka~Leon Suematsu,
  Jie Tan, Quoc~V Le, and Alexey Kurakin.
\newblock Large-scale evolution of image classifiers.
\newblock In {\em International Conference on Machine Learning}, pages
  2902--2911. PMLR, 2017.

\bibitem{zoph2018learning}
Barret Zoph, Vijay Vasudevan, Jonathon Shlens, and Quoc~V Le.
\newblock Learning transferable architectures for scalable image recognition.
\newblock In {\em Proceedings of the IEEE conference on computer vision and
  pattern recognition}, pages 8697--8710, 2018.

\bibitem{he2016deep}
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun.
\newblock Deep residual learning for image recognition.
\newblock In {\em Proceedings of the IEEE conference on computer vision and
  pattern recognition}, pages 770--778, 2016.

\bibitem{chen2018encoder}
Liang-Chieh Chen, Yukun Zhu, George Papandreou, Florian Schroff, and Hartwig
  Adam.
\newblock Encoder-decoder with atrous separable convolution for semantic image
  segmentation.
\newblock In {\em Proceedings of the European conference on computer vision
  (ECCV)}, pages 801--818, 2018.

\bibitem{marsden2017resnetcrowd}
Mark Marsden, Kevin McGuinness, Suzanne Little, and Noel~E O'Connor.
\newblock Resnetcrowd: A residual deep learning architecture for crowd
  counting, violent behaviour detection and crowd density level classification.
\newblock In {\em 2017 14th IEEE International Conference on Advanced Video and
  Signal Based Surveillance (AVSS)}, pages 1--7. IEEE, 2017.

\bibitem{raghu2019transfusion}
Maithra Raghu, Chiyuan Zhang, Jon Kleinberg, and Samy Bengio.
\newblock Transfusion: Understanding transfer learning for medical imaging.
\newblock {\em arXiv preprint arXiv:1902.07208}, 2019.

\bibitem{hearst1998support}
Marti~A. Hearst, Susan~T Dumais, Edgar Osuna, John Platt, and Bernhard
  Scholkopf.
\newblock Support vector machines.
\newblock {\em IEEE Intelligent Systems and their applications}, 13(4):18--28,
  1998.

\bibitem{jacot2018neural}
Arthur Jacot, Franck Gabriel, and Cl{\'e}ment Hongler.
\newblock Neural tangent kernel: Convergence and generalization in neural
  networks.
\newblock {\em arXiv preprint arXiv:1806.07572}, 2018.

\bibitem{daniel1990applied}
Wayne~W Daniel et~al.
\newblock Applied nonparametric statistics.
\newblock 1990.

\bibitem{zhou2020econas}
Dongzhan Zhou, Xinchi Zhou, Wenwei Zhang, Chen~Change Loy, Shuai Yi, Xuesen
  Zhang, and Wanli Ouyang.
\newblock Econas: Finding proxies for economical neural architecture search.
\newblock In {\em Proceedings of the IEEE/CVF Conference on Computer Vision and
  Pattern Recognition}, pages 11396--11404, 2020.

\bibitem{chu2019fairnas}
Xiangxiang Chu, Bo~Zhang, Ruijun Xu, and Jixiang Li.
\newblock Fairnas: Rethinking evaluation fairness of weight sharing neural
  architecture search.
\newblock {\em arXiv preprint arXiv:1907.01845}, 2019.

\bibitem{li2020random}
Liam Li and Ameet Talwalkar.
\newblock Random search and reproducibility for neural architecture search.
\newblock In {\em Uncertainty in Artificial Intelligence}, pages 367--377.
  PMLR, 2020.

\bibitem{klyuchnikov2020bench}
Nikita Klyuchnikov, Ilya Trofimov, Ekaterina Artemova, Mikhail Salnikov, Maxim
  Fedorov, and Evgeny Burnaev.
\newblock Nas-bench-nlp: neural architecture search benchmark for natural
  language processing.
\newblock {\em arXiv preprint arXiv:2006.07116}, 2020.

\bibitem{ying2019bench}
Chris Ying, Aaron Klein, Eric Christiansen, Esteban Real, Kevin Murphy, and
  Frank Hutter.
\newblock Nas-bench-101: Towards reproducible neural architecture search.
\newblock In {\em International Conference on Machine Learning}, pages
  7105--7114. PMLR, 2019.

\bibitem{abdelfattah2021zero}
Mohamed~S Abdelfattah, Abhinav Mehrotra, {\L}ukasz Dudziak, and Nicholas~D
  Lane.
\newblock Zero-cost proxies for lightweight nas.
\newblock {\em arXiv preprint arXiv:2101.08134}, 2021.

\bibitem{xu2019pc}
Yuhui Xu, Lingxi Xie, Xiaopeng Zhang, Xin Chen, Guo-Jun Qi, Qi~Tian, and
  Hongkai Xiong.
\newblock Pc-darts: Partial channel connections for memory-efficient
  architecture search.
\newblock {\em arXiv preprint arXiv:1907.05737}, 2019.

\bibitem{li2020edd}
Yuhong Li, Cong Hao, Xiaofan Zhang, Xinheng Liu, Yao Chen, Jinjun Xiong,
  Wen-mei Hwu, and Deming Chen.
\newblock Edd: Efficient differentiable dnn architecture and implementation
  co-search for embedded ai solutions.
\newblock In {\em 2020 57th ACM/IEEE Design Automation Conference (DAC)}, pages
  1--6. IEEE, 2020.

\bibitem{zela2019understanding}
Arber Zela, Thomas Elsken, Tonmoy Saikia, Yassine Marrakchi, Thomas Brox, and
  Frank Hutter.
\newblock Understanding and robustifying differentiable architecture search.
\newblock {\em arXiv preprint arXiv:1909.09656}, 2019.

\bibitem{dong2020bench}
Xuanyi Dong and Yi~Yang.
\newblock Nas-bench-201: Extending the scope of reproducible neural
  architecture search.
\newblock {\em arXiv preprint arXiv:2001.00326}, 2020.

\bibitem{yu2019evaluating}
Kaicheng Yu, Christian Sciuto, Martin Jaggi, Claudiu Musat, and Mathieu
  Salzmann.
\newblock Evaluating the search phase of neural architecture search.
\newblock {\em arXiv preprint arXiv:1902.08142}, 2019.

\bibitem{mellor2020neural}
Joseph Mellor, Jack Turner, Amos Storkey, and Elliot~J Crowley.
\newblock Neural architecture search without training.
\newblock {\em arXiv preprint arXiv:2006.04647}, 2020.

\bibitem{dey2021fear}
Debadeepta Dey, Shital Shah, and Sebastien Bubeck.
\newblock Fear: A simple lightweight method to rank architectures.
\newblock {\em arXiv preprint arXiv:2106.04010}, 2021.

\bibitem{li2021flash}
Guihong Li, Sumit~K Mandal, Umit~Y Ogras, and Radu Marculescu.
\newblock Flash: Fast neural architecture search with hardware optimization.
\newblock {\em ACM Transactions on Embedded Computing Systems (TECS)},
  20(5s):1--26, 2021.

\bibitem{siems2020bench}
Julien Siems, Lucas Zimmer, Arber Zela, Jovita Lukasik, Margret Keuper, and
  Frank Hutter.
\newblock Nas-bench-301 and the case for surrogate benchmarks for neural
  architecture search.
\newblock {\em arXiv preprint arXiv:2008.09777}, 2020.

\bibitem{su2021prioritized}
Xiu Su, Tao Huang, Yanxi Li, Shan You, Fei Wang, Chen Qian, Changshui Zhang,
  and Chang Xu.
\newblock Prioritized architecture sampling with monto-carlo tree search.
\newblock In {\em Proceedings of the IEEE/CVF Conference on Computer Vision and
  Pattern Recognition}, pages 10968--10977, 2021.

\bibitem{kornblith2019better}
Simon Kornblith, Jonathon Shlens, and Quoc~V Le.
\newblock Do better imagenet models transfer better?
\newblock In {\em Proceedings of the IEEE/CVF Conference on Computer Vision and
  Pattern Recognition}, pages 2661--2671, 2019.

\bibitem{liu2020labels}
Chenxi Liu, Piotr Doll{\'a}r, Kaiming He, Ross Girshick, Alan Yuille, and
  Saining Xie.
\newblock Are labels necessary for neural architecture search?
\newblock In {\em European Conference on Computer Vision}, pages 798--813.
  Springer, 2020.

\bibitem{jing2020self}
Longlong Jing and Yingli Tian.
\newblock Self-supervised visual feature learning with deep neural networks: A
  survey.
\newblock {\em IEEE Transactions on Pattern Analysis and Machine Intelligence},
  2020.

\bibitem{dosovitskiy2014discriminative}
Alexey Dosovitskiy, Jost~Tobias Springenberg, Martin Riedmiller, and Thomas
  Brox.
\newblock Discriminative unsupervised feature learning with convolutional
  neural networks.
\newblock Citeseer, 2014.

\bibitem{doersch2015unsupervised}
Carl Doersch, Abhinav Gupta, and Alexei~A Efros.
\newblock Unsupervised visual representation learning by context prediction.
\newblock In {\em Proceedings of the IEEE international conference on computer
  vision}, pages 1422--1430, 2015.

\bibitem{wang2015unsupervised}
Xiaolong Wang and Abhinav Gupta.
\newblock Unsupervised learning of visual representations using videos.
\newblock In {\em Proceedings of the IEEE international conference on computer
  vision}, pages 2794--2802, 2015.

\bibitem{wang2020high}
Haohan Wang, Xindi Wu, Zeyi Huang, and Eric~P Xing.
\newblock High-frequency component helps explain the generalization of
  convolutional neural networks.
\newblock In {\em Proceedings of the IEEE/CVF Conference on Computer Vision and
  Pattern Recognition}, pages 8684--8694, 2020.

\bibitem{long2015fully}
Jonathan Long, Evan Shelhamer, and Trevor Darrell.
\newblock Fully convolutional networks for semantic segmentation.
\newblock In {\em Proceedings of the IEEE conference on computer vision and
  pattern recognition}, pages 3431--3440, 2015.

\bibitem{hochreiter1997long}
Sepp Hochreiter and J{\"u}rgen Schmidhuber.
\newblock Long short-term memory.
\newblock {\em Neural computation}, 9(8):1735--1780, 1997.

\bibitem{mikolov2010recurrent}
Tom{\'a}{\v{s}} Mikolov, Martin Karafi{\'a}t, Luk{\'a}{\v{s}} Burget, Jan
  {\v{C}}ernock{\`y}, and Sanjeev Khudanpur.
\newblock Recurrent neural network based language model.
\newblock In {\em Eleventh annual conference of the international speech
  communication association}, 2010.

\bibitem{vaswani2017attention}
Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones,
  Aidan~N Gomez, Lukasz Kaiser, and Illia Polosukhin.
\newblock Attention is all you need.
\newblock {\em arXiv preprint arXiv:1706.03762}, 2017.

\bibitem{xu2019frequency}
Zhi-Qin~John Xu, Yaoyu Zhang, Tao Luo, Yanyang Xiao, and Zheng Ma.
\newblock Frequency principle: Fourier analysis sheds light on deep neural
  networks.
\newblock {\em arXiv preprint arXiv:1901.06523}, 2019.

\bibitem{tolstov2012fourier}
Georgi~P Tolstov.
\newblock {\em Fourier series}.
\newblock Courier Corporation, 2012.

\bibitem{montgomery1990distribution}
Stephen~J Montgomery-Smith.
\newblock The distribution of rademacher sums.
\newblock {\em Proceedings of the American Mathematical Society},
  109(2):517--522, 1990.

\bibitem{radosavovic2019network}
Ilija Radosavovic, Justin Johnson, Saining Xie, Wan-Yen Lo, and Piotr
  Doll{\'a}r.
\newblock On network design spaces for visual recognition.
\newblock In {\em Proceedings of the IEEE/CVF International Conference on
  Computer Vision}, pages 1882--1890, 2019.

\bibitem{marcus1993building}
Mitchell Marcus, Beatrice Santorini, and Mary~Ann Marcinkiewicz.
\newblock Building a large annotated corpus of english: The penn treebank.
\newblock 1993.

\bibitem{dong2019searching}
Xuanyi Dong and Yi~Yang.
\newblock Searching for a robust neural architecture in four gpu hours.
\newblock In {\em Proceedings of the IEEE/CVF Conference on Computer Vision and
  Pattern Recognition}, pages 1761--1770, 2019.

\bibitem{dong2019one}
Xuanyi Dong and Yi~Yang.
\newblock One-shot neural architecture search via self-evaluated template
  network.
\newblock In {\em Proceedings of the IEEE/CVF International Conference on
  Computer Vision}, pages 3681--3690, 2019.

\bibitem{pham2018efficient}
Hieu Pham, Melody Guan, Barret Zoph, Quoc Le, and Jeff Dean.
\newblock Efficient neural architecture search via parameters sharing.
\newblock In {\em International Conference on Machine Learning}, pages
  4095--4104. PMLR, 2018.

\bibitem{deng2009imagenet}
Jia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li~Fei-Fei.
\newblock Imagenet: A large-scale hierarchical image database.
\newblock In {\em 2009 IEEE conference on computer vision and pattern
  recognition}, pages 248--255. Ieee, 2009.

\bibitem{chen2021neural}
Wuyang Chen, Xinyu Gong, and Zhangyang Wang.
\newblock Neural architecture search on imagenet in four gpu hours: A
  theoretically inspired perspective.
\newblock {\em arXiv preprint arXiv:2102.11535}, 2021.

\bibitem{liu2018progressive}
Chenxi Liu, Barret Zoph, Maxim Neumann, Jonathon Shlens, Wei Hua, Li-Jia Li,
  Li~Fei-Fei, Alan Yuille, Jonathan Huang, and Kevin Murphy.
\newblock Progressive neural architecture search.
\newblock In {\em Proceedings of the European conference on computer vision
  (ECCV)}, pages 19--34, 2018.

\bibitem{xie2018snas}
Sirui Xie, Hehui Zheng, Chunxiao Liu, and Liang Lin.
\newblock Snas: stochastic neural architecture search.
\newblock {\em arXiv preprint arXiv:1812.09926}, 2018.

\bibitem{chen2019progressive}
Xin Chen, Lingxi Xie, Jun Wu, and Qi~Tian.
\newblock Progressive differentiable architecture search: Bridging the depth
  gap between search and evaluation.
\newblock In {\em Proceedings of the IEEE/CVF International Conference on
  Computer Vision}, pages 1294--1303, 2019.

\bibitem{kindratenko2020hal}
Volodymyr Kindratenko, Dawei Mu, Yan Zhan, John Maloney, Sayed~Hadi Hashemi,
  Benjamin Rabe, Ke~Xu, Roy Campbell, Jian Peng, and William Gropp.
\newblock Hal: Computer system for scalable deep learning.
\newblock In {\em Practice and Experience in Advanced Research Computing},
  pages 41--48. 2020.

\bibitem{Radosavovic2020}
Ilija Radosavovic, Raj~Prateek Kosaraju, Ross Girshick, Kaiming He, and Piotr
  Doll{\'a}r.
\newblock Designing network design spaces.
\newblock In {\em CVPR}, 2020.

\bibitem{xie2017aggregated}
Saining Xie, Ross Girshick, Piotr Doll{\'a}r, Zhuowen Tu, and Kaiming He.
\newblock Aggregated residual transformations for deep neural networks.
\newblock In {\em Proceedings of the IEEE conference on computer vision and
  pattern recognition}, pages 1492--1500, 2017.

\bibitem{sutskever2013importance}
Ilya Sutskever, James Martens, George Dahl, and Geoffrey Hinton.
\newblock On the importance of initialization and momentum in deep learning.
\newblock In {\em International conference on machine learning}, pages
  1139--1147. PMLR, 2013.

\bibitem{kingma2014adam}
Diederik~P Kingma and Jimmy Ba.
\newblock Adam: A method for stochastic optimization.
\newblock {\em arXiv preprint arXiv:1412.6980}, 2014.

\bibitem{goldberg1991comparative}
David~E Goldberg and Kalyanmoy Deb.
\newblock A comparative analysis of selection schemes used in genetic
  algorithms.
\newblock In {\em Foundations of genetic algorithms}, volume~1, pages 69--93.
  Elsevier, 1991.

\bibitem{chen2019renas}
Yukang Chen, Gaofeng Meng, Qian Zhang, Shiming Xiang, Chang Huang, Lisen Mu,
  and Xinggang Wang.
\newblock Renas: Reinforced evolutionary neural architecture search.
\newblock In {\em Proceedings of the IEEE/CVF Conference on Computer Vision and
  Pattern Recognition}, pages 4787--4796, 2019.

\bibitem{narayanan2017graph2vec}
Annamalai Narayanan, Mahinthan Chandramohan, Rajasekar Venkatesan, Lihui Chen,
  Yang Liu, and Shantanu Jaiswal.
\newblock graph2vec: Learning distributed representations of graphs.
\newblock {\em arXiv preprint arXiv:1707.05005}, 2017.

\bibitem{he2015delving}
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun.
\newblock Delving deep into rectifiers: Surpassing human-level performance on
  imagenet classification.
\newblock In {\em Proceedings of the IEEE international conference on computer
  vision}, pages 1026--1034, 2015.

\bibitem{glorot2010understanding}
Xavier Glorot and Yoshua Bengio.
\newblock Understanding the difficulty of training deep feedforward neural
  networks.
\newblock In {\em Proceedings of the thirteenth international conference on
  artificial intelligence and statistics}, pages 249--256. JMLR Workshop and
  Conference Proceedings, 2010.

\bibitem{kendall1938new}
Maurice~G Kendall.
\newblock A new measure of rank correlation.
\newblock {\em Biometrika}, 30(1/2):81--93, 1938.

\bibitem{NEURIPS2019_9015}
Adam Paszke, Sam Gross, Francisco Massa, Adam Lerer, James Bradbury, Gregory
  Chanan, Trevor Killeen, Zeming Lin, Natalia Gimelshein, Luca Antiga, Alban
  Desmaison, Andreas Kopf, Edward Yang, Zachary DeVito, Martin Raison, Alykhan
  Tejani, Sasank Chilamkurthy, Benoit Steiner, Lu~Fang, Junjie Bai, and Soumith
  Chintala.
\newblock Pytorch: An imperative style, high-performance deep learning library.
\newblock In H.~Wallach, H.~Larochelle, A.~Beygelzimer, F.~d\textquotesingle
  Alch\'{e}-Buc, E.~Fox, and R.~Garnett, editors, {\em Advances in Neural
  Information Processing Systems 32}, pages 8024--8035. Curran Associates,
  Inc., 2019.

\end{thebibliography}





\appendix
\section{Appendix}
\subsection{NAS Search Spaces}
NASBench-101\footnote{\url{https://github.com/google-research/nasbench}} introduces a large and expressive search space with 423k unique convolutional neural architectures and training statistics on CIFAR-10.
NASBench-201\footnote{\url{https://github.com/D-X-Y/NAS-Bench-201}} contains the training statistics of 15,625 architectures across three different datasets, including CIFAR-10, CIFAR-100, and Tiny-ImageNet-16.
Network Design Spaces (NDS) dataset\footnote{\url{https://github.com/facebookresearch/nds}}~\cite{radosavovic2019network} with PYCLS~\cite{Radosavovic2020} codebase~\footnote{\url{https://github.com/facebookresearch/pycls}} provides trained neural networks from 11 search spaces including DARTS~\cite{liu2018darts}, AmoebaNet~\cite{real2019regularized}, ENAS~\cite{pham2018efficient}, NASNet~\cite{zoph2018learning}, PNAS~\cite{liu2018progressive}, ResNet~\cite{he2016deep}, ResNeXt~\cite{xie2017aggregated}, etc. A search space with "-f" suffix stands for a search space that has fixed number of layers and channels. The ResNeXt-A and ResNeXt-B have different channel-number and group-convolution settings.
NASBench-NLP\footnote{\url{https://github.com/fmsnew/nas-bench-nlp-release}}~\cite{klyuchnikov2020bench} is an NLP neural architecture search space, including 14k recurrent cells trained on the Penn Treebank (PTB)~\cite{marcus1993building} dataset.
\subsection{Experiment Setup}

For \textbf{CNN} architecture training, the learning rate is  and the weight decay is .
Each architecture is trained for 100 iterations on a single batch of data using SGD optimizer~\cite{sutskever2013importance}. All the convolutional architectures use the same setting.
The size of the input images is  and the size of output feature maps is . 
For \textbf{RNN} training, the learning rate is , the weight decay is , the batch size  is 16, and the sequence length  is 8. 
Each architecture is trained for 100 iterations on a single batch of data using the Adam optimizer~\cite{kingma2014adam}.

\subsubsection{Regularized Evolutionary Algorithm}

\begin{algorithm}[]
\small
\SetAlgoLined


 Initialize an empty population queue,  \tcp{The maximum population is }
 
 Initialize an empty set,  \tcp{Will contain all visited individuals}
 
 \For{}{
  RandomInit()
 
  Eval()
 
 Enqueue(, )\tcp{Add individual to the right of }
 
 Add  to 
 } 
 \tcp{Evolve for }
 \For{  }{
 Initialize an empty set, 
 
 \For{  }{
 Add an individual to  from  without replacement.
 
  \tcp{The individual stays in }
 }
 
  the individual with best fitness in 
 
 Mutate()

  Eval()
 
 Enqueue( ,  )
 
 Add  to 

 Dequeue( )\tcp{Remove the oldest individual from the left of }

 }
 
 
 \textbf{return} the individual with best fitness in 
\caption{\label{alg:REA} Regularized Evolutionary Algorithm in  General}
\end{algorithm}

Regularized Evolutionary Algorithm~\cite{real2019regularized} (RE) combines the tournament selection~\cite{goldberg1991comparative} with the aging mechanism which remove the oldest individuals from the population each round. We show a general form of RE in Alg.~\ref{alg:REA}. Aging evolution aims to explore the search space more extensively, instead of focusing on the good models too early. Works~\cite{dong2020bench,ying2019bench,chen2019renas} also suggest that the RE is suitable for neural architecture search. Since we aim to develop a general NAS evaluator (as the fitness function in RE), we conduct fair comparisons between GenNAS and other methods without fine-tuning or any tricks (e.g., warming-up). Hence, we constantly use the setting , ,  for all the search experiments.

\subsubsection{Proxy Task Search}


\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{images/Mutation.pdf}
  \caption{The configuration of a task in JSON style and the illustration of task mutation.}
  \label{fig:task_illustration}
\end{figure}

The configuration of a task is shown in Fig.~\ref{fig:task_illustration}. 
We introduce the detailed settings of different signal bases. 
(1) \texttt{Noise} is chosen from standard \texttt{Gaussian} distribution () or \texttt{uniform} distribution (). The generated noise maps are directly multiplied by the \texttt{level} which can be selected from 0 to 1 with a step of 0.1. (2) \texttt{Sin1D} generates 2D synthetic feature maps using different frequencies choosing from the \texttt{range}, which contains 10 frequencies sampled from , where a and b are sampled from 0 to 0.5 with the constraint . (3) \texttt{Sin2D} uses the similar setting as \texttt{Sin1D}, where both the  and  for a 2D feature map are sampled from the \texttt{range}. (4) {} can be selected from . Other settings are already described in Section 3.1.2. During the mutation, each minimum mutatable block (including signal definitions and the number of channels) has 0.2 probability to be regenerated as shown in Fig.~\ref{fig:task_illustration}. For RNN settings, we search for both the input and output synthetic signal tensors. The dimension  is chosen from .

\subsubsection{End-to-end NAS}
In the end-to-end NAS, GenNAS is incorporated in the RE as the fitness function to explore the search space. 
For \textbf{NASBench-101}, the mutation rate for each vertice is  where . More details of the search space NASBench-101 can be found in the original paper~\cite{ying2019bench}.
For \textbf{NASBench-201}, the mutation rate for each edge is  where . More details of the search space NASBench-101 can be found in the original paper~\cite{dong2020bench}.
For \textbf{NDS} ResNet series, the sub search space consists of 25000 sampled architectures from the whole search space. 
We apply mutation in RE by randomly sampling 200 architectures from the sub search space and choosing the most similar architecture as the child.
For \textbf{NASBench-NLP}, we follow the work~\cite{klyuchnikov2020bench} by using the graph2vec~\cite{narayanan2017graph2vec} features find the most similar architecture as the child. 

\subsection{Additional Experiments}
\begin{figure}[t]
\vspace{-8pt}
     \centering
          \begin{subfigure}[b]{0.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/batchsize.pdf}
         \caption{Regression (GenNAS) ranking correlation averaged from 10  searched tasks using different batch sizes.}
         \label{fig:bs}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/batchsizecls.pdf}
         \caption{Classification task's ranking correlation using the same setting as (a).}
         \label{fig:cls}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/rankdist1.pdf}
         \caption{Classification accuracy vs. GenNS regression loss with batch size 1.}
         \label{fig:dist1}
     \end{subfigure}
     \hfill
     \centering
     \begin{subfigure}[b]{0.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/rankdist16.pdf}
         \caption{Classification accuracy vs. GenNS regression loss with batch size 16.}
         \label{fig:dist16}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/rankdist1024.pdf}
         \caption{Classification accuracy vs. GenNS regression loss with batch size 1024.}
         \label{fig:dist512}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.49\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/iterations.pdf}
         \caption{10 searched tasks' ranking correlation on NASBench-101 using different numbers of iterations.}
         \label{fig:iters}
     \end{subfigure}
      \hfill
     \hfill
        \caption{(a) Regression (GenNAS) ranking correlation averaged from 10 searched tasks on NASBench-101 in terms of Spearman's  with batch size in . (b) Classification task's ranking correlation using the same amount of data in (a). (c) Classification accuracy using a searched task on NASBench-101 with batch size as 1 on CIFAR-10. The y-axis is the groundtruth (CIFAR-10 accuracy) and the x-axis is the GenNAS regression loss. (d) Similar to (c), batch size as 16. (e) Similar to (c), batch size as 1024. (f) 10 searched tasks ranking performance (in terms of Spearman's ) on NASBench-101 using different iterations. }
        \label{fig:bs&iters}
        \vspace{-8pt}
\end{figure}

\subsubsection{Regression vs. Classification Using Same Training Samples}
We study effectiveness of regression using 10 tasks searched on NASBench-101, varying the batch size from 1 to 1024. The ranking correlation achieved by GenNAS using regression is plotted in Fig.~\ref{fig:bs}.
We also plot the classification task performances with single-batch data in Fig.~\ref{fig:cls}.
Apparently, using the same amount of data, the ranking correlation achieved by classification ( around 0.85) is much worse than regression ( around 0.3). 


\subsubsection{Batch Sizes and Iterations}

We show the effect of batch size by using 10 tasks searched on NASBench-101. We use batch sizes varied from 1 to 1024 and plot the ranking results in Fig.~\ref{fig:bs}. We find that 16 as the batch size is adequate for a good ranking performance. Also, we observe a small degradation when batch size increases and then becomes stable as the batch size keeps increasing. Hence, We plot the ranked architecture distribution with a searched task using 1, 16, 1024 as batch size respectively on Fig.~\ref{fig:dist1},~\ref{fig:dist16},~\ref{fig:dist512}. We observe that when only using a single image, the poor-performance architectures can also achieve similar regression losses as the good architectures. It suggests that the task is too easy to distinguish the differences among architectures. Also, 1024 as batch size leads to the higher regression losses of best architectures. It suggests that a very challenging task is also hard for good architectures to learn and may lead to slight ranking performance degradation. In addition, we plot the ranking performance using different numbers of iterations in Fig.~\ref{fig:iters}. It shows that 100 iterations is necessary for the convergence of ranking performance. 


\subsubsection{Sensitivity Studies of Random Seeds and Initialization}



\begin{table}[h]
  \caption{Ranking correlation (Spearman's ) analysis of different 10 seeds across three different search spaces with the searched tasks on them respectively. For the NASBench-101, the 500 architecture samples~\cite{liu2020labels} are constantly used for evaluation. For DARTS and ResNet search spaces, 1000 samples are randomly sampled with different seeds from the evaluated architecture sets provided by NDS~\cite{radosavovic2019network}.}\label{table:seed}
  \centering
  \scriptsize
\begin{tabular}{lccccccccccc}
\toprule
Search Space & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & Average\\\midrule
 NASBench-101& 0.880 &0.850 & 0.875 & 0.869 & 0.872 & 0.874 & 0.877 & 0.863 & 0.872 & 0.872 & 0.8700.008\\
 DARTS  & 0.809 & 0.899 & 0.861 & 0.831 & 0.841 & 0.836 & 0.851 & 0.841 & 0.885 & 0.861& 0.8500.025\\
 ResNet&  0.860 & 0.853 & 0.841 & 0.810 & 0.865 & 0.877 & 0.874 & 0.804 & 0.808 & 0.803 & 0.8400.029\\\bottomrule
\end{tabular}
\end{table}

\textbf{Random Seeds.}
We rerun the 3 searched tasks on their target search spaces (NASBench-101, DARTS, ResNet) for 10 runs with different random seeds. The results are shown in Table~\ref{table:seed}. GenNAS demonstrates its robustness across different random seeds.

\begin{table}[b]
  \caption{Ranking correlation (Spearman's ) analysis of 10 searched tasks on NASBench-101 with different initialization methods.}\label{table:initialization}
  \centering
  \tiny
\begin{tabular}{llccccccccccc}
\toprule
Weight init&Bias init& 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & Average\\\midrule
 Default& Default& 0.835 &0.860 & 0.860 & 0.878 & 0.835 & 0.810 & 0.859 & 0.832 & 0.816 & 0.828 & 0.8410.021\\
 Kaiming  & Default&0.844 & 0.854 & 0.857 & 0.856 & 0.832 & 0.818 & 0.854 & 0.746 & 0.829 & 0.811& 0.8300.032\\
 Xavier&  Default&0.856 & 0.881 & 0.863 & 0.874 & 0.849 & 0.825 & 0.865 & 0.830 & 0.838 & 0.851 & 0.8530.018\\
 Default& Zero&0.867 &0.882 & 0.854 & 0.880 & 0.848 & 0.847 & 0.874 & 0.808 & 0.848 & 0.850 & 0.8560.021\\
 Kaiming  & Zero&0.845 & 0.842 & 0.856 & 0.861 & 0.828 & 0.821 & 0.846 & 0.770 & 0.823 & 0.823& 0.8310.025\\
 Xavier&  Zero&0.859 & 0.876 & 0.869 & 0.879 & 0.839 & 0.842 & 0.861 & 0.828 & 0.846 & 0.843& 0.8540.016\\
 \bottomrule
\end{tabular}
\end{table}

\textbf{Initialization.}
We perform an experiment to evaluate the effects of different initialization for 10 searched tasks on NASBench-101. For the weights, we use the default PyTorch initialization, Kaiming initialization~\cite{he2015delving}, and Xavier initialization~\cite{glorot2010understanding}. For the bias, we use the default PyTorch initialization and zeroized initialization. The results are shown in Table~\ref{table:initialization}. We observe that for some specific tasks (e.g., task 7), Kaiming initialization may lead to lower ranking correlation. Also, zeroized bias initialization slightly increases the ranking correlation. However, overall, GenNAS shows stable performance across different initialization methods.
\subsubsection{Kendall Tau and Retrieving Rates}

For the sample experiments on NASBench-101/201/NLP and NDS, we report the performance of our methods compared to other efficient NAS approaches' in Table~\ref{table:GenNAS_rankingcorrelation_tau} by Kendall ~\cite{kendall1938new}. We define the retrieving rate@topK as , where  is the operator of cardinality, GT@TopK and Pred@TopK are the set of architectures that are ranked in the top-K of groundtruths and predictions respectively. We report the retrieving rate@Top10\% for all the search spaces in Table~\ref{table:GenNAS_rankingcorrelation_retrieve}. Moreover, we report the retrieving rate@Top5\%-Top50\% for GenNAS-COMBO and GenNAS-N on NASBench-101 with other 1000 random sampled architectures in Table~\ref{table:GenNAS_nasbench_top50}.


\subsubsection{End-to-end NAS Architectures}

Here we visualize all the ImageNet DARTS cell architectures: searched by GenNAS-combo, searched by GenNAS-D14 in Fig~\ref{fig:searched_gennas_combo} and Fig~\ref{fig:searched_gennas_D14} respectively.

\begin{figure}[h]
\centering
     \begin{subfigure}[b]{0.48\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/GENNAS_DARTS_14l16c_combo_normal_.pdf}
         \caption{Normal cell}
         \label{fig:COMBOnormal}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.48\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/GENNAS_DARTS_14l16c_combo_reduce_.pdf}
         \caption{Reduce cell}
         \label{fig:COMBOreduce}
     \end{subfigure}
     \hfill
        \caption{Cell architectures (normal and reduce) searched by GenNAS-combo}
        \label{fig:searched_gennas_combo}
\end{figure}

\begin{figure}[h]
\centering
     \begin{subfigure}[b]{0.48\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/GENNAS_DARTS_14l16c_normal.pdf}
         \caption{Normal cell}
         \label{fig:D14NORMAL}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.48\textwidth}
         \centering
         \includegraphics[width=\textwidth]{images/GENNAS_DARTS_14l16c_reduce.pdf}
         \caption{Reduce cell}
         \label{fig:D14REDUCE}
     \end{subfigure}
     \hfill
        \caption{Cell architectures (normal and reduce) searched by GenNAS-D14}
        \label{fig:searched_gennas_D14}
\end{figure}

\begin{table}[!h]
\vspace{-8pt}
\scriptsize
  \caption{GenNAS' ranking correlation evaluation comparing with other efficient NAS approaches using the Kendall .}
  \label{table:GenNAS_rankingcorrelation_tau}
  \centering
\setlength{\tabcolsep}{3pt}

\begin{tabular}{lccccc}
\Xhline{0.8pt}
\multicolumn{6}{l}{\textbf{NASBench-101}} \\ \hline
Dataset & NASWOT & synflow &  \multicolumn{3}{c}{\textbf{GenNAS}} \\\cline{4-6}
     & ~\cite{mellor2020neural} & ~\cite{abdelfattah2021zero} & single & combo & search-N \\\hline
CIFAR-10 & 0.27&	0.24&	0.59&	0.66	& \textbf{0.7}\\
ImgNet & 0.36&	0.14&	0.47&	\textbf{0.54}&	0.53 \\
\Xhline{0.8pt}
\vspace{-8pt}
\end{tabular}

\begin{tabular}{lccccc|ccc}
\Xhline{0.8pt}
\multicolumn{6}{l}{\textbf{NASBench-201}} \\ \hline
Dataset & NASWOT & synflow &jacob\_cov & snip  & EcoNAS & \multicolumn{3}{c}{\textbf{GenNAS}} \\\cline{7-9}
&&& &  &\cite{zhou2020econas}  & single & combo & search-N \\\hline
CIFAR-10 &  0.6&0.52&0.59&0.41&0.62&0.57&	0.67	&\textbf{0.71} \\
CIFAR-100 & 0.63	&0.57&	0.53&	0.46&	0.57&	0.52&	0.63	&\textbf{0.65} \\
ImgNet16 & 0.6&	0.54&	0.56&	0.44&	0.57&	0.53&	0.61	&\textbf{0.67} \\
\Xhline{0.8pt}
\end{tabular}

\begin{tabular}{lccc|ccccc}
\Xhline{0.8pt}
\multicolumn{9}{l}{\textbf{Neural Design Spaces}} \\ \hline
Dataset & NAS-Space & NASWOT & synflow &  \multicolumn{5}{c}{\textbf{GenNAS}}  \\ \cline{5-9}
 & & & & single & combo & search-N & search-D & search-R \\\hline
CIFAR-10 & DARTS & 0.48&	0.3&	0.3	&0.45&	0.52	&\textbf{0.68}&	0.63\\
& DARTS-f & 0.21&	0.09&	0.36	&\textbf{0.43}&	0.37&	0.42&	0.36 \\
& Amoeba &0.21	&0.06&	0.36&	0.47&	0.5&	\textbf{0.59}&	0.53 \\
& ENAS & 0.39&	0.13&	0.39&	0.49&	0.48&	\textbf{0.63}&	0.59 \\
& ENAS-f & 0.31&	0.2&	0.46&	\textbf{0.55}&	0.49&	0.53&	0.48\\
& NASNet &0.3&	0.02&	0.4	&0.5&	0.47&	\textbf{0.58}&	0.52  \\
& PNAS &  0.36&	0.17&	0.22&	0.37&	0.42&	\textbf{0.57}&	0.52\\
& PNAS-f & 0.09&	0.18&	0.31&	0.38&	0.39&	\textbf{0.38}&	0.33 \\
& ResNet & 0.19	&0.14&	0.23&	0.38&	0.38&	0.38&	\textbf{0.64 }\\
& ResNeXt-A &0.46&	0.32&	0.4&	0.5	&0.6	&0.45&	\textbf{0.65} \\
& ResNeXt-B &0.4&	0.43&	0.17&	0.3	&0.37&	0.38&	\textbf{0.52} \\

\hline

ImageNet & DARTS & 0.49	&0.14	&0.43&	0.52&	0.52&\textbf{	0.66}&	0.48 \\
 & DARTS-f & 0.13&	0.25&	0.49&	\textbf{0.57}&	0.48&	0.51&	0.42\\
 & Amoeba & 0.33&	0.17&	0.46&	0.53&	0.55&	\textbf{0.62}&	0.5 \\
 & ENAS &0.51&	0.12&	0.4&	0.47&	0.4	&\textbf{0.63}&	0.48  \\
 & NASNet &0.39	&0.01&	0.36&	0.42&	0.37	&\textbf{0.5}&	0.43  \\
 & PNAS &  0.45&	0.11&	0.19&	0.27&	0.31&	\textbf{0.45}&	0.3\\
 & ResNeXt-A & 0.52	&0.28	&0.61&	\textbf{0.7}	&0.56&	0.44&	0.69\\
 & ResNeXt-B & 0.45&	0.21&	0.53&	0.65&	0.39&	0.43&	\textbf{0.67}\\
\Xhline{0.8pt}
\end{tabular}

\begin{tabular}{lccc}
\Xhline{0.8pt}
\multicolumn{4}{l}{\textbf{NASBench-NLP}} \\ \hline
Dataset  & \multicolumn{3}{c}{\textbf{GenNAS}} \\ \cline{2-4}
 & single & combo & search \\\hline
PTB &  0.43	&0.55&	0.63\\\Xhline{0.8pt}

\end{tabular}
\end{table}

\begin{table}[!h]
\vspace{-8pt}
\scriptsize
  \caption{GenNAS' retrieving rate@top10\% comparing with other efficient NAS approaches. For the NASBench-101 we use the set of 500 architectures that sampled by Liu, et al.~\cite{liu2020labels} for obtaining the ImageNet groundtruth.}
  \label{table:GenNAS_rankingcorrelation_retrieve}
  \centering
\setlength{\tabcolsep}{3pt}

\begin{tabular}{lcccccc}
\Xhline{0.8pt}
\multicolumn{7}{l}{\textbf{NASBench-101}} \\ \hline
Dataset & number  & NASWOT & synflow &  \multicolumn{3}{c}{\textbf{GenNAS}} \\\cline{5-7}
     & of samples& ~\cite{mellor2020neural} & ~\cite{abdelfattah2021zero} & single & combo & search-N \\\hline
CIFAR-10 & 500 & 32\%&	28\%&	58\%&	64\%&	\textbf{68\%}\\
ImgNet &  500 & 36\%&	14\%&	52\%&	54\%&	\textbf{64\%}\\
\Xhline{0.8pt}
\vspace{-8pt}
\end{tabular}

\begin{tabular}{lcccccc|ccc}
\Xhline{0.8pt}
\multicolumn{7}{l}{\textbf{NASBench-201}} \\ \hline
Dataset & number & NASWOT & synflow &jacob\_cov & snip  & EcoNAS & \multicolumn{3}{c}{\textbf{GenNAS}} \\\cline{8-10}
&of samples&&& &  &\cite{zhou2020econas}  & single & combo & search-N \\\hline
CIFAR-10 &  1000 & 43\%&	48\%&	27\%&	27\%&	52\%&	43\%&	36\%&	\textbf{53\%}\\
CIFAR-100 & 1000 & 48\%&	47\%&	23\%&	36\%&	47\%&	46\%&	46\%&	\textbf{58\%}\\
ImgNet16 &1000 & 49\%&	43\%&	33\%&	32\%&	41\%&	48\%&	40\%&	\textbf{51\%}\\
\Xhline{0.8pt}
\end{tabular}

\begin{tabular}{lcccc|ccccc}
\Xhline{0.8pt}
\multicolumn{10}{l}{\textbf{Neural Design Spaces}} \\ \hline
Dataset &number & NAS-Space & NASWOT & synflow &  \multicolumn{5}{c}{\textbf{GenNAS}}  \\ \cline{6-10}
 & of samples&& & & single & combo & search-N & search-D & search-R \\\hline
CIFAR-10 &1000& DARTS & 29\%&10\%&16\%&43\%&45\%&\textbf{59\%}&49\%\\
&1000& DARTS-f & 1\%&5\%&	22\%&	\textbf{33\%}&	18\%&	22\%&	23\%\\
&1000& Amoeba & 20\%&	4\%&	20\%&	39\%&	45\%&	\textbf{50\%}&	40\%\\
&1000& ENAS & 31\%&	6\%&	25\%&	48\%&	41\%&	\textbf{57\%}&	48\%\\
&1000& ENAS-f & 28\%&	2\%&	34\%&	\textbf{45\%}&	42\%&	38\%&	37\%\\
&1000& NASNet &  33\%&	7\%&	27\%&	38\%&	\textbf{46\%}&	52\%&	43\%\\
&1000& PNAS &  24\%&	9\%&	21\%&	39\%&	\textbf{46\%}&	44\%&	37\%\\
&1000& PNAS-f &  6\%&	4\%&	21\%&	27\%&	\textbf{31\%}&	25\%&	22\%\\
&1000& ResNet & 7\%&	4\%&	38\%&	44\%&	38\%&	54\%&	\textbf{64\%}\\
&1000& ResNeXt-A & 28\%&	25\%&	25\%&	\textbf{61\%}&	53\%&	52\%&	58\%\\
&1000& ResNeXt-B & 21\%&	30\%&	10\%&	13\%&	36\%&	40\%&	\textbf{71\%}\\

\hline

ImageNet &121& DARTS & 17\%&	0\%&	50\%&	58\%&	55\%&	\textbf{58\%}&	18\%\\
 &499& DARTS-f & 8\%&	4\%&	33\%&	27\%&	35\%&	\textbf{39\%}&	24\%\\
 &124& Amoeba & 33\%&	0\%&	50\%&	42\%&	58\%&	\textbf{58\%}&	41\%\\
 &117& ENAS &  36\%&	9\%&	18\%&	18\%&	45\%&	\textbf{55\%}&	45\%\\
 &122& NASNet &33\%&	0\%&	42\%&	\textbf{50\%}&	42\%&	33\%&	33\%\\
 &119& PNAS & 10\%&	9\%&	45\%&	36\%&	45\%&	\textbf{55\%}&	9\%\\
 &130& ResNeXt-A & 31\%&	8\%&	67\%&	67\%&	50\%&	33\%&	\textbf{75\%}\\
 &164& ResNeXt-B &38\%&	13\%&	38\%&	50\%&	33\%&	38\%&	\textbf{64\%}\\
\Xhline{0.8pt}
\end{tabular}

\begin{tabular}{lcccccccccc}
\Xhline{0.8pt}
\multicolumn{11}{l}{\textbf{NASBench-NLP}} \\ \hline
Dataset & number& grad& norm&	snip&	grasp&	fisher&	synflow&\multicolumn{3}{c}{\textbf{GenNAS}} \\ \cline{9-11}
 &of samples&&&&&&& single & combo & search \\\hline
PTB &1000& 10\%&	10\%&	4\%&	-&	22\%&	38\%&	38\%&	47\%&	\textbf{63\%}\\\Xhline{0.8pt}

\end{tabular}
\end{table}

\begin{table}[t]
\vspace{-8pt}
\scriptsize
  \caption{Retrieving rate@top5\%-top50\% of GenNAS-combo/N on 1000 randomly sampled architectures on NASBench-101.}
  \label{table:GenNAS_nasbench_top50}
  \centering
\setlength{\tabcolsep}{3pt}

\begin{tabular}{lcccccc}
\Xhline{0.8pt}
Method& @top5\%&	@top10\%& @top20\% & @top30\% & @top40\% & @top50\%
 \\\hline
GenNAS-combo & 0.6&	0.6&	0.73&	0.74&	0.79&	0.82\\
GenNAS-N & 0.56&	0.58&	0.66&	0.76&	0.80&	0.85 \\
\Xhline{0.8pt}
\vspace{-8pt}
\end{tabular}
\end{table}



\subsubsection{GPU Performance}

We use the PyTorch 1.5.0~\cite{NEURIPS2019_9015}, on a desktop with I7-7700K CPU, 16 GB RAM and a GTX 1080 Ti GPU (11GB GDDR5X memory) to evaluate the GPU performance of GenNAS. The results are shown in Table~\ref{table:benchmarkgpu}.

\begin{table}[!h]
\caption{Evaluations of GenNAS' GPU performance. We test GenNAS with 6 different batch sizes from 16 to 96. "A/B" denotes: A (second) as the average one-iteration run time for the search space, and B (GB or gigabyte) as the GPU memory usage. "OOM" means some large models may lead to the out-of-memory issue for the target GPU. }\label{table:benchmarkgpu}
  \centering
  \small
\begin{tabular}{lcccccc}
\toprule
 Search Space&   B-size 16 & B-size 32 &B-size 48 &B-size 64 &B-size 80 &B-size 96 \\\midrule
 NASBench-101& 0.023/0.78 & 0.023/0.92 & 0.023/1.12 & 0.022/1.22 & 0.023/1.41 & 0.023/1.56 \\
 NASBench-201& 0.020/0.77 & 0.020/0.93 & 0.021/1.12 & 0.020/1.24 & 0.020/1.46 & 0.020/1.62 \\
 DARTS& 0.049/1.92 & 0.056/3.39 & 0.069/5.07 & 0.088/6.88 & 0.103/7.62 & OOM \\
 DARTS-f& 0.077/1.42 & 0.088/2.21 & 0.104/3.30 & 0.122/3.79 & 0.145/5.15 & 0.171/6.07 \\
 Amoeba& 0.080/2.53 & 0.103/4.38 & 0.128/6.60 & 0.159/9.25 & 0.194/6.85 & OOM \\
 ENAS& 0.059/2.40 & 0.076/4.31 & 0.090/5.84 & 0.115/7.78 & 0.140/9.15 & OOM \\
 ENAS-f& 0.095/1.67 &0.111/2.58 & 0.134/3.70 & 0.159/4.54 & 0.186/6.31 & 0.216/7.53 \\
 NASNet& 0.061/2.23 & 0.073/3.77 & 0.094/5.83 & 0.116/6.87 & 0.140/8.68 & 0.160/9.30 \\
 PNAS& 0.074/2.52 & 0.097/4.36 & 0.121/6.53 & 0.155/8.23 & 0.189/9.42 & OOM \\
 PNAS-f& 0.114/1.69 & 0.143/2.67 & 0.173/4.03 & 0.208/4.83 & 0.250/6.24 & 0.293/7.45 \\
 ResNet& 0.016/1.28 & 0.016/1.54 & 0.016/2.05 & 0.016/2.34 & 0.016/2.34 & 0.016/2.77 \\
 ResNeXt-A& 0.025/1.65 & 0.025/2.82 & 0.026/4.55 & 0.027/6.86 & 0.028/9.75 & 0.029/5.92 \\
 ResNeXt-B& 0.022/1.98 & 0.022/3.47 & 0.023/5.63 & 0.024/7.33 & 0.027/9.51 & 0.029/5.95 \\
 NASBench-NLP& 0.029/0.90 & 0.029/0.90 & 0.029/0.90 & 0.029/0.90 & 0.029/0.93 & 0.029/0.94\\\bottomrule
\end{tabular}
\end{table}



\end{document}
