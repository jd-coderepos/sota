


\documentclass[envcountsect,orivec]{llncs} \usepackage{etex} \usepackage[]{graphicx}
\pagestyle{headings}


\newif\ifignore \ignorefalse
\newcommand{\auxproof}[1]{
  \ifignore\mbox{}\newline
  \textbf{BEGIN: AUX-PROOF} \dotfill\newline
  {#1}\mbox{}\newline
  \textbf{END: AUX-PROOF}\dotfill\newline
  \fi}
\def\comment#1{\ifignore \marginpar[\renewcommand{\baselinestretch}{0.9}\raggedleft\sloppy{}#1]{\renewcommand{\baselinestretch}{0.9}\raggedright\sloppy{}#1}\fi}





\usepackage{times}


\usepackage{theorem}
\usepackage{fancybox,amssymb,amstext,amsmath,stmaryrd,wasysym,cite,proof,mathtools,multirow,stackrel}
\SetSymbolFont{stmry}{bold}{U}{stmry}{m}{n}
\SetSymbolFont{wasy}{bold}{U}{wasy}{m}{n}
\usepackage{algorithm}
\usepackage{algpseudocode}
\makeatletter
\algrenewcommand\ALG@beginalgorithmic{\footnotesize}
\makeatother


\usepackage[pdftex,all]{xy}
\pdfoptionpdfminorversion=6
\usepackage{xspace}
\allowdisplaybreaks[1] 


\xyoption{v2}
\xyoption{curve}
\xyoption{2cell}
\SelectTips{cm}{}  \UseAllTwocells
\SilentMatrices
\def\labelstyle{\scriptstyle}
\def\twocellstyle{\scriptstyle}
\newdir{ >}{{}*!/-8pt/@{>}}  
\newdir{|>}{!/1.6pt/@{|}*:(1,-.2)@^{>}*:(1,+.2)@_{>}}
\newdir{pb}{:(1,-1)@^{|-}}
\def\pb#1{\save[]+<20 pt,0 pt>:a(#1)\ar@{pb{}}[]\restore}
\newcommand{\shifted}[3]{\save[]!<#1,#2>*{#3}\restore}
\usepackage{wrapfig}
\setlength{\intextsep}{.1\intextsep}
\setlength{\columnsep}{.7\columnsep}
\theorembodyfont{\itshape}
\newtheorem{mytheorem}{Theorem}[section]
\newtheorem{mylemma}[mytheorem]{Lemma}
\newtheorem{myproposition}[mytheorem]{Proposition}
\newtheorem{mysublemma}[mytheorem]{Sublemma}
\newtheorem{mycorollary}[mytheorem]{Corollary}
\theorembodyfont{\rmfamily}
\newtheorem{mynotation}[mytheorem]{Notation}
\newtheorem{myremark}[mytheorem]{Remark}
\newtheorem{myexample}[mytheorem]{Example}
\newtheorem{mydefinition}[mytheorem]{Definition}
\newtheorem{myassumption}[mytheorem]{Assumption}
\newtheorem{myrequirements}[mytheorem]{Requirements}
\newtheorem{myproblem}{Problem}
\newtheorem{mytask}{Task}
\spnewtheorem*{myproof}{Proof}{\itshape}{\rmfamily}
\def\myqedsymbol{\squareforqed}
\def\myqedbox{\squareforqed}
\def\myqed{\qed}



\DeclareMathOperator{\dom}{dom}



\newcommand{\N}{{\mathbb{N}}}
\newcommand{\Z}{{\mathbb{Z}}}
\newcommand{\R}{{\mathbb{R}}}
\newcommand{\B}{{\mathbb{B}}}
\newcommand{\Models}{{ \;\mathbin{\vDash}\; }}
\newcommand{\NModels}{{ \;\mathbin{\nvDash}\; }}
\newcommand{\Defequiv}{\stackrel{\text{def.}}{\equiv}}
\newcommand{\Defiff}{\stackrel{\text{def.}}{\Longleftrightarrow}}
\newcommand{\Var}{\mathbf{Var}}
\newcommand{\ttrue}{\mathrm{t{\kern-1.5pt}t}}
\newcommand{\ffalse}{\mathrm{f{\kern-1.5pt}f}}

\newcommand{\aop}{\mathbin{\mathtt{aop}}}
\newcommand{\bop}{\mathbin{\mathtt{bop}}}
\newcommand{\rop}{\mathrel{\mathtt{rop}}}

\newcommand{\place}{\underline{\phantom{n}}\,}

\newcommand{\STL}{\textbf{STL}}
\newcommand{\Fml}{\mathbf{Fml}}
\newcommand{\FmlNNF}{\mathbf{Fml}_{\mathrm{NNF}}}
\newcommand{\AP}{\mathbf{AP}}
\newcommand{\UntilOp}[1]{\mathbin{\mathcal{U}_{#1}}}
\newcommand{\Release}[1]{\mathbin{\mathcal{R}_{#1}}}
\newcommand{\TUntil}[1]{\mathbin{\overline{\mathcal{U}}_{#1}}}
\newcommand{\TRelease}[1]{\mathbin{\overline{\mathcal{R}}_{#1}}}
\newcommand{\DiaOp}[1]{\Diamond_{#1}}
\newcommand{\BoxOp}[1]{\square_{#1}}
\newcommand{\TDiaOp}[1]{\overline{\Diamond}_{#1}}
\newcommand{\TBoxOp}[1]{\overline{\square}_{#1}}
\newcommand{\Robust}[2]{{ \llbracket #1,\, #2 \rrbracket}}
\newcommand{\sem}[1]{\llbracket #1 \rrbracket} 
\newcommand{\Defeq}{\triangleq}
\newcommand{\Sum}[1]{{\displaystyle{\sum_{#1}}}}
\newcommand{\Lim}[1]{{\displaystyle{\lim_{#1}}}}
\newcommand{\Vee}[1]{{{\bigsqcup_{#1}}}}
\newcommand{\Wedge}[1]{{{\bigsqcap_{#1}}}}
\newcommand{\Frac}[2]{{\displaystyle{\frac{#1}{#2}}}}
\newcommand{\Int}{\displaystyle \int}
\newcommand{\RelSTLbe}{\mathbf{STL}_{\TUntil{I}}}
\newcommand{\RelSTL}{\mathbf{RelSTL}}
\newcommand{\AvSTL}{\textbf{AvSTL}}
\newcommand{\Max}{\mathsf{max}}
\newcommand{\Min}{\mathsf{min}}
\DeclareMathOperator*{\Sup}{\mathsf{sup}}
\DeclareMathOperator*{\Inf}{\mathsf{inf}}
\DeclareMathOperator*{\Minimize}{\mathsf{minimize}}
\DeclareMathOperator*{\Average}{\mathsf{average}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\Expediency}[1]{\overline{E}_{#1}}
\newcommand{\Persistence}[2]{\overline{P}_{{#1}+{#2}}}
\newcommand{\Deadline}[2]{\overline{D}_{{#1}+{#2}}}
\newcommand{\Endurance}[2]{\overline{En}_{{#1}\text{ in }{#2}}}

\newcommand{\Rise}{\mathsf{rise}}
\newcommand{\Fall}{\mathsf{fall}}
\newcommand{\Justafter}{\mathsf{justafter}}
\newcommand{\XJustafter}{\mathsf{Xjustafter}}

\newcommand{\Rnn}{\R_{\ge 0}}
\newcommand{\Rnp}{\R_{\le 0}}
\newcommand{\Succ}{Succ.}


 \title{
Time Robustness in MTL and
\\Expressivity in
  Hybrid System Falsification
}
 \author{
Takumi Akazaki
 \inst{1,2}
\and
Ichiro Hasuo
\inst{1}
 }
 \institute{
The University of Tokyo, Japan
    \and
    JSPS Research Fellow
}


\begin{document}

\maketitle


\begin{abstract}
  Building on the work by Fainekos and Pappas and the one by Donz\'{e}
  and Maler, we introduce , an extension of metric interval
  temporal logic by \emph{averaged} temporal operators.  Its
  expressivity in capturing both space and time robustness helps solving
  \emph{falsification} problems (searching for a critical path in
  hybrid system models); it does so by communicating a designer's intention more
  faithfully to the stochastic optimization engine employed in a
  falsification solver.  We also introduce a sliding window-like
  algorithm that keeps the cost of computing truth/robustness values tractable.
   


\end{abstract}


\section{Introduction}\label{sec:introduction}
\paragraph{Model-Based Development of Hybrid Systems}
The demand for quality assurance of \emph{cyber-physical systems (CPS)} is
ever-rising, now that computer-controlled artifacts---cars, aircrafts,
and so on---serve diverse safety-critical tasks 
everywhere in our daily lives.  In the industry practice of CPS design, deployment
of \emph{model-based development (MBD)} has become a norm. 
In MBD, (physical and costly) testing workbenches are replaced 
by (virtual and cheap) \emph{mathematical models}; 
and this reduces by a great deal the cost of running 
a \emph{development cycle}---design, implementation, evaluation, and redesign.

One of the distinctive features of CPS is that they are \emph{hybrid systems} 
and combine discrete and continuous
dynamics. For MBD of such systems the software \emph{Simulink} has emerged as an
industry standard. In Simulink a designer models a system using block
diagrams---a formalism  strongly influenced by \emph{control theory}---and 
runs \emph{simulation}, that is, numerical solution of the system's dynamics.


\paragraph{Falsification}
The models of most real-world hybrid systems are believed to be beyond
the reach of formal verification.  While this is certainly the case with 
systems as big as a whole car,
a single component of it (like automatic transmission or an engine
controller)  overwhelms the scalability of
the state-of-art formal verification techniques, too.

What is worse, hybrid
system models tend to have \emph{black-box components}. An example is
fuel combustion in an engine.  Such chemical reactions are not easy to
model with
ODEs, and are therefore commonly represented in a Simulink model 
by a \emph{look-up table}---a big table of values obtained by  physical measurements~\cite{DBLP:conf/hybrid/JinDKUB14,HoxhaAF14arch1}. 
The lack of structure in a look-up table poses a
challenge to formal verification:  each entry of the table
calls for separate treatment; and this 
easily leads to state-space explosion.

Under such circumstances,  \emph{falsification} by
stochastic optimization has proved to be a viable
approach to quality
assurance~\cite{DBLP:conf/tacas/AnnpureddyLFS11,DBLP:conf/hybrid/JinDKUB14,HoxhaAF14arch1}. The
problem is formulated as follows:
\begin{quote}
  \underline{\bfseries The falsification problem}

  \begin{tabular}{ll}
    \textbf{Given:} 
    & a \emph{model}  (a function from an input signal \\
    & to  an output signal), and\\
    & a \emph{specification}  (a temporal formula),\\
    \textbf{Answer:} 
    & a \emph{critical path}, that is, an input signal  such\\
    & that the output  does not satisfy  
  \end{tabular}
  \includegraphics[clip,trim=0cm 23.5cm 24.8cm 0cm,width=.24\textwidth]{pics/falsification.pdf}
\end{quote}
Unlike \emph{testing} or \emph{monitoring}---where input  is given and
we check if ---a
falsification solver employs stochastic optimization techniques (like
the Monte-Carlo ones) and iteratively searches for a falsifying input
signal
.

Falsification is a versatile tool in MBD of hybrid systems.  It is
capable of searching for counterexamples, hence revealing potential
faults in the design. One can also take, as a specification ,
the negation  of a desirable property ; then
successful falsification amounts to \emph{synthesis} of an input signal that
satisfies .  Stochastic optimization used in falsification
typically does not rely on the internal structure of models, therefore the
methodology is suited for models with black-box
components. Falsification is fairly scalable, making it 
a realistic option in
the industrial MBD scenarios; see e.g.~\cite{HoxhaAF14arch1,DBLP:conf/hybrid/JinDKUB14}.



The current work aims at enhancing falsification solvers, notable among which are
S-TaLiRo~\cite{DBLP:conf/tacas/AnnpureddyLFS11}
and
BREACH~\cite{DBLP:conf/cav/Donze10}. 
An obvious way to do so is via improvement of stochastic optimization;
see e.g.~\cite{Sankaranarayanan:2012:FTP:2185632.2185653,Zutshi:2014:MSC:2656045.2656061}. Here we take a different, logical approach.

\paragraph{Robustness in Metric Temporal Logics}
Let us turn to a formalism in which a specification
 is expressed. 
\emph{Metric interval temporal logic} 
()~\cite{DBLP:dblp_journals/jacm/AlurFH96}, 
and its adaptation
\emph{signal temporal logic} 
()~\cite{DBLP:conf/formats/MalerN04}, 
are standard temporal logics for (continuous-time) signals. 
However their conventional
semantics---where satisfaction is Boolean---is not suited for
falsification by stochastic optimization. 
This is because a formula , no matter if it is 
\emph{robustly} satisfied and \emph{barely} satisfied, yields the same
truth value (``true''), making it  not amenable to hill climb-style
optimization.

It is  the introduction of \emph{robust semantics} of
~\cite{DBLP:journals/tcs/FainekosP09} that set off the idea of falsification by
optimization. In robust semantics,  a signal  and a
formula  are assigned a continuous truth value 
that designates how robustly the formula is satisfied. Such ``robustness
values'' constitute a sound basis for stochastic optimization.

\begin{wrapfigure}[10]{r}{0pt}
\centering
  \begin{tabular}{c}
    \includegraphics[width=.3\textwidth,natwidth=640,
    natheight=384]{pics/s_rob.pdf}
    \\small
    \begin{array}{rrl}
    \AP \ni 
      & l \,::=\,
      & x < r 
        \mid x \leq r 
        \mid x \geq r 
        \mid x > r 
        \quad \text{ where } x \in \Var, r \in \R\\
      \Fml \ni 
      &\varphi \,::=\,
      & \top
        \mid \bot
        \mid l 
        \mid \neg \varphi 
        \mid \varphi \vee \varphi 
        \mid \varphi \wedge \varphi 
        \mid \varphi \UntilOp{I} \varphi 
        \mid \varphi \TUntil{I} \varphi 
        \mid \varphi \Release{I} \varphi 
        \mid \varphi \TRelease{I} \varphi
    \end{array}
  
    \varphi_1 \to \varphi_2  \equiv  (\neg \varphi_1) \vee \varphi_2
  
    \DiaOp{I} \varphi  \equiv  \top \UntilOp{I} \varphi
  
    \BoxOp{I} \varphi  \equiv  \bot \Release{I} \varphi 
  
    \TDiaOp{I} \varphi  \equiv  \top \TUntil{I} \varphi
  
    \TBoxOp{I} \varphi  \equiv  \bot \TRelease{I} \varphi 
  
      \begin{array}{rll}
        \FmlNNF \ni \varphi &\;::=\;&
        \infty \mid \neg \infty 
        \mid l \mid \neg l \mid \varphi_1 \vee \varphi_2 
        \mid \varphi_1 \wedge \varphi_2 \mid\\
        &&\varphi_1 \UntilOp{I} \varphi_2 \mid \varphi_1 \TUntil{I} \varphi_2
        \mid \varphi_1 \Release{I} \varphi_2 \mid \varphi_1 \TRelease{I} \varphi_2
      \end{array}
    
 \Robust{\sigma}{\varphi}^{+} \ge 0

 \Robust{\sigma}{\varphi}^{-} \le 0

  \Robust{\sigma}{\varphi}^{+} > 0

 \Robust{\sigma}{\varphi}^{-} <0

      \begin{array}{rll}
        \Robust{\sigma}{\top}^{+} & \Defeq & \infty\\
        \Robust{\sigma}{\bot}^{+} & \Defeq & 0\\
        \Robust{\sigma}{x < r}^{+} & \Defeq & 0\sqcup (r - \sigma(0)(x))\\
        \Robust{\sigma}{x \leq r}^{+} & \Defeq & 0\sqcup(r - \sigma(0)(x))\\
        \Robust{\sigma}{x \geq r}^{+} & \Defeq & 0\sqcup(\sigma(0)(x) - r)\\
        \Robust{\sigma}{x > r}^{+} & \Defeq & 0\sqcup( \sigma(0)(x) - r)\\
        \Robust{\sigma}{\neg \varphi}^{+} & \Defeq & - \Robust{\sigma}{\varphi}^{-}\\
        \Robust{\sigma}{\varphi_1 \vee \varphi_2}^{+} & \Defeq & 
        \Robust{\sigma}{\varphi_1}^{+} \sqcup \Robust{\sigma}{\varphi_2}^{+}\\
        \Robust{\sigma}{\varphi_1 \wedge \varphi_2}^{+} & \Defeq & 
        \Robust{\sigma}{\varphi_1}^{+} \sqcap \Robust{\sigma}{\varphi_2}^{+}\\
        \\
      \end{array}
      \quad
      \begin{array}{l}
        \begin{array}{rll}
          \Robust{\sigma}{\varphi_1 \UntilOp{I} \varphi_2}^{+} 
          & \Defeq 
          & \Vee{t \in I} 
            (\Robust{\sigma^t}{\varphi_2}^{+} \sqcap 
            \Wedge{t' \in [0, t)} \Robust{\sigma^{t'}}{\varphi_1}^{+})\\
          \Robust{\sigma}{\varphi_1 \Release{I} \varphi_2}^{+} 
          & \Defeq 
          & \Wedge{t \in I} 
            (\Robust{\sigma^t}{\varphi_2}^{+} \sqcup 
            \Vee{t' \in [0, t)} \Robust{\sigma^{t'}}{\varphi_1}^{+})\\
        \end{array}
        \\
        \begin{array}{l}
          \Robust{\sigma}{\varphi_1 \TUntil{I} \varphi_2}^{+} \Defeq\\
          \quad
          \begin{cases}
            \Frac{1}{b - a} \Int_{a}^{b} 
            \Robust{\sigma}{\varphi_1 \UntilOp{I \cap [0, \tau]} \varphi_2}^{+} d\tau 
            & \text{( is bounded)}\\
            \Robust{\sigma}{\varphi_1 \UntilOp{I} \varphi_2}^{+} 
            & \text{( is unbounded)}\\
          \end{cases}
	  \\
          \Robust{\sigma}{\varphi_1 \TRelease{I} \varphi_2}^{+} \Defeq\\
          \quad
          \begin{cases}
            \Frac{1}{b - a} \Int_{a}^{b} 
            \Robust{\sigma}{\varphi_1 \Release{I \cap [0, \tau]} \varphi_2}^{+} d\tau 
            & \text{( is bounded)}\\
            \Robust{\sigma}{\varphi_1 \Release{I} \varphi_2}^{+} 
            & \text{( is unbounded)}\\
          \end{cases}\\
        \end{array}
      \end{array}
    
        \begin{array}{rll}
        \Robust{\sigma}{\top}^{-} & \Defeq & 0\\
        \Robust{\sigma}{\bot}^{-} & \Defeq & - \infty\\
        \Robust{\sigma}{x < r}^{-} & \Defeq & 0\sqcap( r - \sigma(0)(x))\\
        \Robust{\sigma}{x \leq r}^{-} & \Defeq & 0\sqcap( r - \sigma(0)(x))\\
        \Robust{\sigma}{x \geq r}^{-} & \Defeq & 0\sqcap( \sigma(0)(x) - r)\\
        \Robust{\sigma}{x > r}^{-} & \Defeq & 0\sqcap( \sigma(0)(x) - r)\\
        \Robust{\sigma}{\neg \varphi}^{-} & \Defeq & - \Robust{\sigma}{\varphi}^{+}\\
        \Robust{\sigma}{\varphi_1 \vee \varphi_2}^{-} & \Defeq & 
        \Robust{\sigma}{\varphi_1}^{-} \sqcup \Robust{\sigma}{\varphi_2}^{-}\\
        \Robust{\sigma}{\varphi_1 \wedge \varphi_2}^{-} & \Defeq & 
        \Robust{\sigma}{\varphi_1}^{-} \sqcap \Robust{\sigma}{\varphi_2}^{-}\\
          \\
      \end{array}
      \quad
      \begin{array}{l}
        \begin{array}{rl}
          \Robust{\sigma}{\varphi_1 \UntilOp{I} \varphi_2}^{-} 
          & \Defeq 
            \Vee{t \in I} 
            (\Robust{\sigma^t}{\varphi_2}^{-} \sqcap \Wedge{t' \in [0, t)} \Robust{\sigma^{t'}}{\varphi_1}^{-})\\
          \Robust{\sigma}{\varphi_1 \Release{I} \varphi_2}^{-} 
          & \Defeq  
            \Wedge{t \in I} 
            (\Robust{\sigma^t}{\varphi_2}^{-} \sqcup \Vee{t' \in [0, t)} \Robust{\sigma^{t'}}{\varphi_1}^{-})\\
        \end{array}\\
        \begin{array}{l}
          \Robust{\sigma}{\varphi_1 \TUntil{I} \varphi_2}^{-} \Defeq\\
          \quad
          \begin{cases}
            \Frac{1}{b - a} \Int_{a}^{b} \Robust{\sigma}{\varphi_1 \UntilOp{I \cap [0, \tau]} \varphi_2}^{-} d\tau 
            & \text{( is bounded)}\\
            \Robust{\sigma}{\varphi_1 \UntilOp{I} \varphi_2}^{-} &
            \text{( is unbounded)}\\
          \end{cases}\\
          \Robust{\sigma}{\varphi_1 \TRelease{I} \varphi_2}^{-}  \Defeq\\
          \quad
          \begin{cases}
            \Frac{1}{b - a} \Int_{a}^{b} \Robust{\sigma}{\varphi_1 \Release{I \cap [0, \tau]} \varphi_2}^{-} d\tau 
            & \text{( is bounded)}\\
            \Robust{\sigma}{\varphi_1 \Release{I} \varphi_2}^{-} &
            \text{( is unbounded)}\\
          \end{cases}\\
        \end{array}
      \end{array}
    
  \begin{array}{l}
    \Robust{\sigma}{\TDiaOp{[0, 1]} (x \geq 0)}^{+} \\
    =
    \Int_{0}^{1} \Bigl(\,\Vee{\tau' \in [0 , \tau]} 0\sqcup\,
    \sigma(\tau')(x)\,\Bigr) \,d\tau\enspace, 
  \end{array}
  \qquad\text{and}\qquad
  \begin{array}{l}
    \Robust{\sigma}{\TDiaOp{[0, 1]} (x \geq 0)}^{-}
    \\
    =
    \Int_{0}^{1}\Bigl(\, \Vee{\tau' \in [0 , \tau]} 0
    \sqcap\,\sigma(\tau')(x) 
    \,\Bigr)\,d\tau\enspace .
  \end{array}
\small
    \begin{array}{rclrcl}
      \Robust{\sigma}{\varphi_1 \UntilOp{[t_0,t]} \varphi_2}^{+} 
      &\leq &
      \Robust{\sigma}{\varphi_1 \UntilOp{[t_0,t']} \varphi_2}^{+}
      \quad
      &
      \Robust{\sigma}{\varphi_1 \UntilOp{[t_0,t]} \varphi_2}^{-} 
      &\leq &
      \Robust{\sigma}{\varphi_1 \UntilOp{[t_0,t']} \varphi_2}^{-}
      \\
      \Robust{\sigma}{\varphi_1 \Release{[t_0,t]} \varphi_2}^{+} 
      &\geq&
      \Robust{\sigma}{\varphi_1 \Release{[t_0,t']} \varphi_2}^{+}
      &
      \Robust{\sigma}{\varphi_1 \Release{[t_0,t]} \varphi_2}^{-} 
      &\geq&
      \Robust{\sigma}{\varphi_1 \Release{[t_0,t']} \varphi_2}^{-}
    \end{array}
  
    \Robust{\sigma}{\varphi_1 \UntilOp{[t_0, \infty)} \varphi_2}^{+} 
      =
      \Lim{t \to \infty}
      \Robust{\sigma}{\varphi_1 \TUntil{[t_0, t]} \varphi_2}^{+}
  
    \begin{array}{rcl}
      \forall \sigma.\; \Robust{\sigma}{\varphi}^{+} 
      \leq \Robust{\sigma}{\varphi'}^{+}
      \quad&\text{implies}
      &\quad 
        \forall \sigma.\; \Robust{\sigma}{\C[\varphi]}^{+} 
        \leq
        \Robust{\sigma}{\C[\varphi']}^{+}\enspace;\;\text{and}\\
      \forall \sigma.\; \Robust{\sigma}{\varphi}^{-} 
      \leq \Robust{\sigma}{\varphi'}^{-}
      \quad&\text{implies}
      &\quad 
        \forall \sigma.\; \Robust{\sigma}{\C[\varphi]}^{-} 
        \leq 
        \Robust{\sigma}{\C[\varphi']}^{-} \enspace.
    \end{array}  
  
  \BoxOp{} (
  \mathtt{heavyBraking} \to 
\DiaOp{[0,10]}\mathtt{airbag} )

     \BoxOp{} (
    \mathtt{heavyBraking} \to 
\TDiaOp{[0,10]}\mathtt{airbag} )

 (\DiaOp{[0,5]}\mathtt{airbag})\lor
   (\TDiaOp{[5,5+5]}\mathtt{airbag})

    \BoxOp{} 
    (
    \mathtt{shiftIntoGear_1} \to
\BoxOp{[0,50]}\mathtt{gear_1}\land\TBoxOp{[50,50+\delta]}\mathtt{gear_1}
)

  \begin{array}{rl}
    \C \,::=\,& [\,] \mid \C \vee \varphi \mid \varphi \vee \C 
                \mid \C \wedge \varphi \mid \varphi \wedge \C
                \mid \C \UntilOp{I} \varphi 
                \mid \varphi \UntilOp{I} \C 
                \mid \C \TUntil{I} \varphi 
                \mid \varphi \TUntil{I} \C\\
              & \mid \C \Release{I} \varphi 
                \mid \varphi \Release{I} \C 
                \mid \C \TRelease{I} \varphi
                \mid \varphi \TRelease{I} \C \quad
                \text{ where  is an  formula. }
  \end{array}
  
    \Robust{\sigma}{\C[\TDiaOp{[a,b]}\varphi]}^{+} > 0
  
    \Robust{\sigma}{\C[\DiaOp{[a,b]}\varphi]}^{+} > 0.
  
    b' < b
  
    \Robust{\sigma}{\C[\DiaOp{[a,b']}\varphi]}^{+} > 0
  
    \Robust{\sigma}{\C[\TDiaOp{[a,b]}\varphi]}^{+} > 0
   
    \Robust{\sigma}{\C[\BoxOp{[a,b]}\varphi \wedge \TBoxOp{[b,b+\delta]}\varphi]}^{+} > 0
  
    \Robust{\sigma}{\C[\BoxOp{[a,b]}\varphi]}^{+} > 0 
  
    \Robust{\sigma}{\C[\BoxOp{[a,b']}\varphi]}^{+} > 0 
  
    \Robust{\sigma}{\C[\BoxOp{[a,b]}\varphi \wedge \TBoxOp{[b,b+\delta]}\varphi]}^{+} > 0
  
    \bigl[\,   (t_{0},r_{0}),
      (t_{1},r_{1}),
      \dotsc,
      (t_{n},r_{n})
      \,\bigr]
  
    \sigma(t) = r_{i} 

      \bigl[\,   (t_{0},r_{0}, q_{0}),
        \dotsc,
        (t_{n},r_{n},q_{n})
        \,\bigr]
    
      \sigma(t)= r_{i} + q_{i}(t-t_{i}) 

    \begin{array}{ll}
      &\Robust{\sigma^{u'}}{\varphi_1 \TUntil{[a,b]} \varphi_2} 
      - \Robust{\sigma^u}{\varphi_1 \TUntil{[a,b]} \varphi_2}\\
      =&\Frac{1}{b-a} 
      \bigg( \Int_a^b \Robust{\sigma^{u'}}{\varphi_1 \UntilOp{[a,\tau]} \varphi_2} d\tau 
      - \Int_a^b \Robust{\sigma^{u}}{\varphi_1 \UntilOp{[a,\tau]} \varphi_2} d\tau \bigg)\\
    \end{array}
  
      & \Int_a^b \Robust{\sigma^{u'}}{\varphi_1 \UntilOp{[a,\tau]} \varphi_2} d\tau
      - \Int_a^b \Robust{\sigma^{u}}{\varphi_1 \UntilOp{[a,\tau]} \varphi_2} d\tau\\
      = &
      \Int_a^b 
      \Vee{\tau' \in [a, \tau] }
      \Big( \Robust{\sigma^{u'+\tau'}}{\varphi_2} \wedge \Wedge{\tau'' \in [0, \tau']} \Robust{\sigma^{u'+\tau''}}{\varphi_1} \Big) 
      d\tau \\
      &- \Int_a^b 
      \Vee{\tau' \in [a, \tau] }
      \Big( \Robust{\sigma^{u+\tau'}}{\varphi_2} \wedge \Wedge{\tau'' \in [0, \tau']} \Robust{\sigma^{u+\tau''}}{\varphi_1} \Big) 
      d\tau\\
      =&
      \Int_a^b 
      \Vee{\tau' \in [a, \tau] }
      \Big( \Robust{\sigma^{u'+\tau'}}{\varphi_2} \wedge \Wedge{\tau'' \in [0, \tau']} \Robust{\sigma^{u'+\tau''}}{\varphi_1} \Big) 
      d\tau \\
      &- \Int_a^b 
      \Vee{\tau' \in [a, \tau] }
      \Big( \Robust{\sigma^{u+\tau'}}{\varphi_2} \wedge \Wedge{\tau'' \in [0, \tau']} \Robust{\sigma^{u+\tau''}}{\varphi_1} \Big) 
      d\tau\\
      =&
      \Int_{a+u'}^{b+u'} 
      \Vee{\tau' \in [a+u', \tau] }
      \Big( \Robust{\sigma^{\tau'}}{\varphi_2} \wedge \Wedge{\tau'' \in [u', \tau']} \Robust{\sigma^{\tau''}}{\varphi_1} \Big) 
      d\tau \\
      &- \Int_{a+u}^{b+u} 
      \Vee{\tau' \in [a+u, \tau] }
      \Big( \Robust{\sigma^{\tau}}{\varphi_2} \wedge \Wedge{\tau'' \in [u, \tau']} \Robust{\sigma^{\tau''}}{\varphi_1} \Big) 
      d\tau\\
      =&
      \Int_{b+u}^{b+u'} 
      \Vee{\tau' \in [a+u', \tau] }
      \Big( \Robust{\sigma^{\tau'}}{\varphi_2} \wedge \Wedge{\tau'' \in [u', \tau']} \Robust{\sigma^{\tau''}}{\varphi_1} \Big) 
      d\tau \\
      &+\Int_{a+u'}^{b+u} 
      \Vee{\tau' \in [a+u', \tau] }
      \Big( \Robust{\sigma^{\tau'}}{\varphi_2} \wedge \Wedge{\tau'' \in [u', \tau']} \Robust{\sigma^{\tau''}}{\varphi_1} \Big) 
      d\tau \\
      &- \Int_{a+u'}^{b+u} 
      \Vee{\tau' \in [a+u, \tau] }
      \Big( \Robust{\sigma^{\tau}}{\varphi_2} \wedge \Wedge{\tau'' \in [u, \tau']} \Robust{\sigma^{\tau''}}{\varphi_1} \Big) 
      d\tau\\
      &- \Int_{a+u}^{a+u'} 
      \Vee{\tau' \in [a+u, \tau] }
      \Big( \Robust{\sigma^{\tau}}{\varphi_2} \wedge \Wedge{\tau'' \in [u, \tau']} \Robust{\sigma^{\tau''}}{\varphi_1} \Big) 
      d\tau.\\
    
    \Robust{\sigma^{u'}}{\varphi_1 \TUntil{[a,b]} \varphi_2} 
    - \Robust{\sigma^u}{\varphi_1 \TUntil{[a,b]} \varphi_2}
    = \Frac{C}{b-a} (u' - u)
  
    \BoxOp{} (
    \mathtt{heavyBraking} 
  
    \to \TDiaOp{[0,10]}\mathtt{airbag} )
  
      \def\labelstyle{\textstyle}
      \def\twocellstyle{\textstyle}
      \xymatrix@R=1.5em@C+4em{
        {\begin{array}{c}
           \includegraphics[width=.3\textwidth]{pics/StQ/NewStQ3.png}
           \\
           \bigl[\;(3,0.2)\,(4,0.3)\,(5,0.7)\,(8,0.9)\;\bigr]
         \end{array} 
       }
       \ar@{|->}[r]^-{\text{slide}}_-{\text{backward}}
       \ar@{|->}[d]^-{\text{dequeue }}
       &
       {\begin{array}{c}
          \includegraphics[width=.3\textwidth]{pics/StQ/NewStQ1.png}
          \\
          \bigl[\;(1,0.6)\,(5,0.7)\;\bigr]
        \end{array} 
      }
      \\
      {\begin{array}{c}
         \includegraphics[width=.3\textwidth]{pics/StQ/NewDeq_StQ3.png}
         \\
         \bigl[\;(3,0.2)\,(4,0.3)\,(5,0.7)\;\bigr]
       \end{array} 
     }
     \ar@{|->}[r]^-{
       \begin{array}{r}
         \text{pop }\quad\\
         \text{and }
       \end{array}
     }
     &
     {\begin{array}{c}
        \includegraphics[width=.3\textwidth]{pics/StQ/NewPop_StQ3.png}
        \\
        \bigl[\;(5,0.7)\;\bigr]
      \end{array} 
    }
    \ar@{|->}[u]^-{\text{push }}
  }
-1em]
    a stackqueue
  \end{tabular} 
\end{wrapfigure}
It is enough to know the shape of the blue (partial) signal in
Fig.~\ref{fig:slidingWindow}, at each position of the window.
The blue signal denotes the (black) signal 's
local supremum within the window; more precisely, 
it denotes the value of the signal
 at time , where
 and  is the leftmost position of the window.
We can immediately read off
the signal
 
from the blue signals: 
the former is the latter's value at the
 rightmost position of the window.


The keys in 
the algorithms
in~\cite{DBLP:conf/cav/DonzeFM13,DBLP:journals/njc/Lemire06}
lie in:
\begin{itemize}
 \item use of the \emph{stackqueue} data structure (depicted above on the right) for the
purpose of representing the blue (partial) signal in
Fig.~\ref{fig:slidingWindow}; and 
 \item use of the  operations \emph{push}, \emph{pop} and
       \emph{dequeue} for updating the blue signal.
\end{itemize}
See Fig.~\ref{fig:stackqueueForSlidingWindow}, where each entry of
a stackqueue is a timestamped value . We see that the slide of the window, from top-left to
top-right in Fig.~\ref{fig:stackqueueForSlidingWindow},
is expressed by dequeue, pop and then push operations to stackqueues (in
Fig.~\ref{fig:stackqueueForSlidingWindow}: from top-left to bottom-left,
bottom-right and then top-right).
 Pseudocode for the algorithm is deferred to
Appendix~\ref{appendix:algoDia} due to lack of space.
























































\subsection{An Algorithm for  Robustness}
\label{subsec:algoAvSTL}
It turns out that the last algorithm is readily applicable to 
computing  robustness. Consider an averaged-eventually formula 
 as an example. What we have to compute is
the size of the shaded areas in Fig.~\ref{fig:slidingWindow} (see
also Fig.~\ref{fig:averagedDiamond}); and the shape of the blue 
signals in Fig.~\ref{fig:slidingWindow} carry just enough information
to do so. 



Pseudocode for the adaptation of the previous algorithm 
(in~\S{}\ref{subsec:algoSTL}) to
 is found in
Algorithm~\ref{algo:tdia}.
Its complexity is linear  with respect to the number  of the timestamp
values that represent the  signal .


\begin{algorithm}[tbp]
  \caption{An algorithm for computing }
  \label{algo:tdia}
  \begin{algorithmic}
    \Require An FPC signal 
    given as a sequence  
\Ensure The FPL signal

    \State ;
    \State ; 
    \Comment  is the FPC signal 
\State ;
    \Comment The area of 
    \State ; 
    \Comment The FPC signal 
    \While{}
    \State ;
    \State  the greatest  such that 
    ;

    \State ; \quad ;
    \Comment{Dequeue old elements in }
\State ; \quad ;
    \Comment{Pop small elements in }
    \State ; 
    \State  
    \Comment{Push the left endpoint of the window to }
    \State ;
    \State ;
    \State 
\State 
\EndWhile
  \end{algorithmic}
\end{algorithm}













An algorithm for the averaged-henceforth formula
 is similar. Extensions to
averaged-until and averaged-release operators are possible, too; they
use doubly-linked lists in place of stackqueues (see Appendix~\ref{appendix:algoTUntil}).
Combining with the algorithm in~\S{}\ref{subsec:algoSTL} to deal with
non-averaged temporal operators, we have the following 
complexity result. The complexity is the same as for ~\cite{DBLP:conf/cav/DonzeFM13}.







\begin{mytheorem}\label{thm:complexity_rel}
  Let  be an  formula 
  in which averaged modalities are not nested.
  Let  be a finitely piecewise-constant signal.
Then there exists an algorithm
  to compute
  
  with time-complexity in 
  
  for some constant .

  The same is true for the negative robustness
  .
  \myqed
\end{mytheorem}


\begin{myremark}
 The reason for our restriction to finitely piecewise-constant input
 signals is hinted in Rem.~\ref{rem:DonzeAlgoForPiecewiseLinear}; let us
 further elaborate on it.
 There the averaged modality  turns a piecewise-constant signal into a
 piecewise-linear one
 (Lem.~\ref{lem:preservationOfPiecewiseConstLinear}); and then the
 additional Boolean connectives and non-averaged
 modalities (outside  ) are taken care of by the algorithm
 in~\cite{DBLP:conf/cav/DonzeFM13}, one that is restricted
 to piecewise-linear input.

 It is not methodologically hard to extend this workflow to
 piecewise-\emph{polynomial} input signals (hence to nested averaged
 modalities as well). Such an extension however calls
 for computing local suprema of polynomials, as well as their
 intersections---tasks that are drastically easier with affine
 functions. We therefore expect  the extension to
 piecewise-polynomial signals to be computationally
 much more expensive.
\end{myremark}





































\section{Enhanced Falsification: Implementation and Experiments}
\label{sec:experiments}


\begin{table}[ptb]
  \scriptsize
  \centering
  \begin{minipage}{\textwidth}
    \textbf{Problem 1. } Falsification means finding an input signal 
    that keeps the engine speed  below 2000 rpm, for 
    seconds. The bigger  is, the harder the problem is.
    We applied -refinement.
  \end{minipage}
  \begin{tabular}{c||r|r|r|r|r|r|r|r|r}
    \textbf{Problem 1}
    &\multicolumn{3}{|c|}{} &\multicolumn{3}{|c|}{} &\multicolumn{3}{|c}{}\\ \hline
    Specification & \Succ & Iter. & Time & \Succ & Iter. & Time &
    \Succ & Iter. & Time \\
    to be falsified
    &  & (\Succ) & (\Succ) & & (\Succ) & (\Succ)&  & (\Succ) & (\Succ)\\  \hline\hline
     
    & 100& 128.8& 20.2& 81& 440.9& 82.5& 32& 834.3& 162.9\\
    &    & 128.8& 20.2&   & 309.7& 59.0&   & 482.2&  94.4\\\hline
    
    & 100& 123.9& 22.9& 98& 249.8& 46.1 & 81& 539.6& 110.9\\
    &    & 123.9& 22.9&   & 234.5& 43.4 &   & 431.6&  89.2\\
  \end{tabular}

  \vspace{1em}
  \begin{minipage}{\textwidth}
\textbf{Problem 2.} Falsification means finding an input signal 
    that keeps  within a range of 3500--4500 rpm for 
    consecutive seconds, at a certain stage. 
We applied -refinement.
  \end{minipage}
  \begin{tabular}{c||r|r|r}
    \textbf{Problem 2}
    &\multicolumn{3}{|c}{} \\ \hline
    Specification & \Succ & Iter. & Time\\
    to be falsified
    &  & (\Succ) & (\Succ) \\  \hline\hline
    
    & 45& 625.4& 209.1\\
    &   & 167.7&  56.1\\\hline
    
    & 74& 442.0&  154.3\\
    &   & 245.9&   86.6\\
  \end{tabular}

  \vspace{1em}
  \begin{minipage}{\textwidth}
    \textbf{Problem 3.} Falsification means finding an input signal 
    that shifts the gear into the fourth within  seconds. 
    The smaller  is, the harder the problem is. Here 
    is a propositional variable.
We applied -refinement.
  \end{minipage}
  \begin{tabular}{c||r|r|r|r|r|r|r|r|r}
    \textbf{Problem 3}
    &\multicolumn{3}{|c|}{} &\multicolumn{3}{|c|}{} &\multicolumn{3}{|c}{}\\ \hline
    Specification & \Succ & Iter. & Time & \Succ & Iter. & Time &
    \Succ & Iter. & Time \\
    to be falsified
    &  & (\Succ) & (\Succ) & & (\Succ) & (\Succ)&  & (\Succ) & (\Succ)\\  \hline\hline
     
    & 0& 1000& 166.9& 11& 742.8 & 122.9& 18& 449.0 &  71.8 \\ 
    &  &    --&     --&   & 532.3 &  87.5&   & 387.7 &  61.9 \\ \hline
     
    & 17& 570.1& 94.0& 20& 250.5& 40.3& 20& 107.5& 17.6\\
    
    &   & 494.2& 81.8&   & 250.5& 40.3&   & 107.5& 17.6\\
  \end{tabular}

  \vspace{1em}
  \begin{minipage}{\textwidth}
    \textbf{Problem 4.} Falsification means finding input  
    with which the gear never stays in the third consecutively for  seconds.
The smaller  is, the harder the problem is.
    Here 
    is a propositional variable.
    We applied -refinement.
  \end{minipage}
  \begin{tabular}{c||r|r|r|r|r|r}
    \textbf{Problem 4}
    &\multicolumn{3}{|c|}{} &\multicolumn{3}{|c}{} \\ \hline
    Specification & \Succ & Iter. & Time & \Succ & Iter. & Time \\
    to be falsified
    &  & (\Succ) & (\Succ) & & (\Succ) & (\Succ)\\  \hline\hline
    
    & 14& 556.1& 132.0& 20& 82.8& 20.6\\
    &   & 365.8&  87.1&   & 82.8& 20.6\\\hline
    
    & 20& 105.1&  36.3& 20& 29.7& 10.2\\
    &   & 105.1&  36.3& 20& 29.7& 10.2\\
  \end{tabular}

  \vspace{1em}
  \begin{minipage}{\textwidth}
    \textbf{Problem 5.} Falsification means finding input
    that violates the following requirement: \emph{after the gear is
      shifted, it stays the same for  seconds.}
(the smaller , the harder).
     are propositional variables.
    We applied -refinement.
  \end{minipage}
  \begin{tabular}{c||r|r|r|r|r|r|r|r|r}
    \textbf{Problem 5} ()
    &\multicolumn{3}{|c|}{} &\multicolumn{3}{|c|}{} &\multicolumn{3}{|c}{}\\ \hline
    Specification & \Succ & Iter. & Time & \Succ & Iter. & Time &
    \Succ & Iter. & Time \\
    to be falsified
    &  & (\Succ) & (\Succ) & & (\Succ) & (\Succ)&  & (\Succ) & (\Succ)\\  \hline\hline
    {\scriptsize }
    & 2& 972.5 & 402.5& 19& 356.8& 155.6& 20& 27.4& 11.8\\
    {\scriptsize }
    &  & 724.5 & 297.8&   & 322.9& 140.9&   & 27.4& 11.8\\ \hline
    {\scriptsize }
    & 12& 561.1& 349.1& 20& 93.1& 57.8& 20& 42.7& 26.9\\
    {\scriptsize }
    &   & 268.5& 167.3&   & 93.1& 57.8&   & 42.7& 26.9\\
  \end{tabular}

  \vspace{1em}
  \begin{minipage}{\textwidth}
    \textbf{Problem 6.} 
    Falsification means finding an input signal 
    that steers the vehicle speed  over 85 kph within  seconds,
    while keeping the engine speed  below 4500 rpm.
    The smaller  is, the harder the problem is.
We applied -refinement.
  \end{minipage}
  \begin{tabular}{c||r|r|r|r|r|r}
    \textbf{Problem 6}
    &\multicolumn{3}{|c|}{} &\multicolumn{3}{|c}{} \\ \hline
    Specification & \Succ & Iter. & Time & \Succ & Iter. & Time \\
    to be falsified
    &  & (\Succ) & (\Succ) & & (\Succ) & (\Succ)\\  \hline\hline
    
    & 12& 714.9& 141.4& 17& 374.5& 72.2\\
    &   & 524.9& 108.1&   & 264.1& 51.2\\\hline
    
    &12& 766.7& 149.0& 20& 423.6& 85.7\\
    
    &  & 611.2& 118.9&   & 423.6& 85.7\\
  \end{tabular}
  \caption{Experiment results. Time is in seconds. The ``Succ.''
    columns show how many trials  succeeded among the designated number of trials;
    the ``Iter.'' columns show the average number of iterations of the
    S-TaLiRo loop, executed in each trial (max.\ 1000); and the ``Time'' columns show
    the average time that each trial took. For the last two we also show
    the average over \emph{successful} trials.}
  \label{table:result}
\end{table}

\begin{wrapfigure}[13]{r}{.338\textwidth}
  \includegraphics[clip,trim=0cm 15.5cm 25cm 0cm,width=.338\textwidth]
  {pics/staliroModif.pdf}
  \vspace*{-2em}
  \caption{An overview of S-TaLiRo (from~\cite{WEB:S_TaLiRo}), with our modification}
  \label{fig:staliro}
\end{wrapfigure}
We claim that our logic  achieves a good balance between
expressivity---that communicates a designer's intention more faithfully
to a falsification
solver---and computational cost, thus contributing to the model-based
development of cyber-physical systems. In this section we present our
implementation that combines: 1)
S-TaLiRo~\cite{DBLP:conf/tacas/AnnpureddyLFS11}, one of the
state-of-art falsification solvers that relies on robust MTL semantics and
stochastic optimization;  and 2) the \emph{ evaluator}, 
an implementation of the algorithm
in~\S{}\ref{subsec:algoAvSTL}. Our experiments are on automotive
examples of falsification problems;
the results indicate that (refinement of specifications by)  brings considerable performance
improvement.

\subsubsection{Implementation}
S-TaLiRo~\cite{DBLP:conf/tacas/AnnpureddyLFS11} is 
``a Matlab toolbox that searches for trajectories of minimal robustness
in Simulink/Stateflow''~\cite{WEB:S_TaLiRo}. Recall the formalization of 
a falsification problem (\S{}\ref{sec:introduction}). S-TaLiRo's input
is:  1) a
model  that is a Simulink/Stateflow model; and 2) a specification
 that is an  formula. 

S-TaLiRo employs stochastic simulation in the following 
\emph{S-TaLiRo loop}: 
\begin{enumerate}
 \item Choose an input signal   randomly.
 \item Compute the output signal
        with Simulink.
 \item Compute the robustness
  .
 \item If the robustness is  then return 
  as a critical path. Otherwise choose a new  
  (hopefully with a smaller robustness)
    and go back to Step 2.
\end{enumerate}
Our  modification of S-TaLiRo consists of: 1) changing the specification formalism from
 to  (with the hope that the robustness
 carries more
information to be exploited in stochastic optimization); and 2) using, in
 Step 3 of the above loop, the 
evaluator based on the sliding-window algorithm
in~\S{}\ref{sec:algorithm}. 
See  Fig.~\ref{fig:staliro}.














\subsubsection{Experiments}
As a model  we used the automatic transmission model
from~\cite{HoxhaAF14arch1}, where it is offered ``as benchmarks
        for testing-based falsification''~\cite{HoxhaAF14arch1}.
The same model has been used 
in several works~\cite{DBLP:conf/pts/YangHF12, 6315384, DBLP:conf/hybrid/JinDDS13}.
The model has two input ports (\emph{} and
\emph{}) and six output ports (the engine speed , 
the vehicle speed , and four mutually-exclusive Boolean ports
  for the current gear).
Further illustration  is in Appendix~\ref{appendix:ATModel}.
As a specification  to  falsify, we took six examples from~\cite{HoxhaAF14arch1},
sometimes with minor modifications. They constitute Problems 1--6 in Table~\ref{table:result}.

Our goal is to examine the effect of our modification to S-TaLiRo.
For the  model  (that is fixed) and each of the six specifications
, experiments are done with:
\begin{itemize}
 \item  and the original  formula , as a
       control experiment;
       and
 \item  and the  formula  that is
       obtained from  as a
       refinement. The latter specifically involves \emph{-refinement} and
       \emph{-refinement} described in~\S{}\ref{subsec:soundnessOfEnrichments}.
\end{itemize}
Faster, or more frequent, falsification in the latter setting witnesses
effectiveness of our  approach. We note that
falsifying  indeed means falsifying , because of the
soundness of the refinement (Prop.~\ref{prop:diaRefinement} and~\ref{prop:BoxRefinement}).

A single falsification \emph{trial} consists of at most 1000 \emph{iterations} of the S-TaLiRo
loop. For each specification  (i.e. for each problem in
Table~\ref{table:result}) we made 
20--100 falsification trials, 
sometimes
with different parameter values . We made multiple trials
because of the stochastic nature of S-TaLiRo.












































\subsubsection{Experiment Results and Discussion}
The experiment results are in Table~\ref{table:result}.
We used
Matlab R2014b and
S-TaLiRo ver.1.6 beta
on
ThinkPad T530 with Intel Core i7-3520M 2.90GHz CPU with 3.7GB memory.
The OS is Ubuntu14.04 LTS (64-bit).




 Notable performance improvement is observed in Problems 3--5, 
especially in their harder instances. For
example, our  enrichment made 17 out of 20 trials succeed in
Problem 3 (), while no trials succeeded with the original 
specification. A similar extreme performance gap is observed also in
Problem 5 ().

Such performance improvement in Problems 3--5  is not surprising. The
specifications for these problems
are concerned solely with the propositional variables
 (cf.\ Rem.~\ref{rem:propVar});
and the space
robustness semantics for  assigns to these specifications only 
or 
(but no values in-between) as their
truth 
values. We can imagine such ``discrete'' robustness values give few clues
to stochastic optimization algorithms.

Both of 
 - and
       -refinement
 in~\S{}\ref{subsec:soundnessOfEnrichments}
turn out to be helpful. The latter's effectiveness is observed in
Problems 3--5; the former improves a success rate from 32/100 to 81/100
in Problem 1 (). 

Overall, the experiment results seem to support our claim that the complexity of
(computing robustness values in)  is tractable. There is no big
difference in the time 
each iteration takes, between the  case and the  case.























































































































\section{Conclusions and Future Work}
We introduced , an extension of  with \emph{averaged}
temporal
operators. It adequately captures both space and time robustness; and
we presented an algorithm for computing  robustness that is 
linear-time with respect to the ``size'' of an input signal. Its use
in falsification of CPS is demonstrated by our prototype that modifies S-TaLiRo.

As future work, we wish to compare our averaged temporal operators with
other quantitative temporal operators, among which are the
\emph{discounting}
ones~\cite{DBLP:dblp_journals/jacm/AlurFH96,DBLP:conf/tacas/AlmagorBK14}. The
latter are closely related to \emph{mean-payoff}
conditions~\cite{Ehrenfeucht1979, DBLP:conf/lics/ChatterjeeHJ05} as well
as to \emph{energy
constraints}~\cite{DBLP:conf/formats/BouyerFLMS08,DBLP:conf/hybrid/BrenguierCR14},
all of which are studied principally in the context of automata theory.

Application of  to problems other than falsification is another
important direction. Among them is \emph{parameter synthesis}, another
task that S-TaLiRo is capable of.
We are now looking at application to
\emph{sequence classification} (see
e.g.~\cite{DBLP:conf/hybrid/KongJAGB14}), too,
whose significant role in model-based development of CPS is widely acknowledged.






















\bibliographystyle{plain} \bibliography{./RelSTL} 


\newpage
\appendix
\section{Algorithms}
\subsection{An  Algorithm for Computing
  , from~\cite{DBLP:conf/cav/DonzeFM13}  }
\label{appendix:algoDia}
In Algorithm~\ref{algo:dia} is pseudocode for 
computing the signal ,
 given the signal .
Its intuitions are found
in~\S{}\ref{subsec:algoSTL}.



\begin{algorithm}
  \caption{An algorithm for computing }
  \label{algo:dia}
    \begin{algorithmic}
      \Require A FPC signal  given as a sequence 
       
      \Ensure The FPC signal 
      \State ; 
      \State ; 
      \Comment  is the FPC signal 
      
\State 
      ; 
      \Comment  is the FPC signal 
      \While{}
      \State  the greatest  such that 
      ;
      \State ; \Comment{Dequeue old elements in }
      \State ; 
      \Comment{Pop elements in  that are too small}
      \State ;
      \Comment{Push the left endpoint of the window to }
      \State ;
      \State ;
      \Comment{Add a  timestamped value}
      \EndWhile
    \end{algorithmic}
\end{algorithm}

\subsection{An Algorithm for Computing  }
\label{appendix:algoTUntil}

 Algorithm~\ref{algo:tdia}
is an algorithm for computing 
that is linear-time
with respect to the ``size'' of .
We can compute 
in linear-time, similarly,
by employing a sliding-window 
that stands for a piecewise constant function

The sliding of the window corresponds to the change of the value of .
For efficient implementation of such sliding we rely on the following
proposition. It is derived essentially from 
the equivalence , an equivalence also used  in~\cite{DBLP:conf/cav/DonzeFM13}.
\begin{myproposition}\label{prop:TUntilAlgo}
Assume
that the signal
  is constant
 in the interval . Then we have

\end{myproposition}
\begin{myproof}
  
\end{myproof}

Roughly speaking, the equality~(\ref{eq:propTUntilAlgo}) shows how the
signal \emph{after} sliding ( on the left-hand side) can be computed from
the signal \emph{before} sliding (the first term 

on the right-hand side). 

In Algorithm~\ref{algo:tuntil} pseudocode is found for 
computing 
. Compared to
Algorithm~\ref{algo:tdia} a principal addition is \emph{truncation} of
big elements ( in Algorithm~\ref{algo:tuntil}; it
corresponds
to taking  in~(\ref{eq:propTUntilAlgo})). To realize such a
truncation operation
efficiently, we use a \emph{doubly-linked list} as a data
structure---in place of a stackqueue---so that it allows push and pop
from each side.

It is not hard to see that the time-complexity of
Algorithm~\ref{algo:tuntil} is linear in . Note also that the signal
 
(input to Algorithm~\ref{algo:tuntil}) can be computed
efficiently, from  
the signals  and ,
thanks to the algorithm presented in~\cite{DBLP:conf/cav/DonzeFM13}.
\begin{algorithm}
  \caption{An algorithm for computing }
  \label{algo:tuntil}
  \begin{algorithmic}
    \Require An FPC signal  
    given as a sequence 
    and a signal  
    as 
    \Ensure The FPL signal
    
    \State ;
    \State ;
    \State ; 
    \Comment  is the FPC signal 
\State ;
    \Comment The area of 
    \State ; 
    \Comment  is the FPC signal 
    \While{}
    \State ;
    \State  the greatest  such that 
    \State \qquad \qquad 
    ;
\State ; 
    \Comment{Dequeue old elements in }
    \State ;
\State ; 
    \Comment{Pop small elements in } 
    \State ;
    \State ;
    \State ;
    \Comment{Push the left endpoint of the window to }
    \State ;
    \State ;
    \State ;

    \State ; 
    \Comment{Truncate big elements in }
    \State ;
    \State ;
    \State ;
    \State ;
    \State ;
    \State ;
\State 
\EndWhile
  \end{algorithmic}
\end{algorithm}





\section{Omitted Proofs}
\subsection{Proof of Lem.~\ref{lemma:untilIsMonotone}}
\begin{myproof}
  We only prove the first inequality; the others are similar.

  \myqed
\end{myproof}


\subsection{Proof of Lem.~\ref{lem:CorrespondenceBetweenUntilAndTUntil}}
\begin{myproof}
  We only show the proof of the first equality; the others are similar.
  
  We  first show (LHS)  (RHS).
  
  Now we show the equality (LHS)  (RHS).
  Let 
  
  By Lem.~\ref{lemma:untilIsMonotone}
  
  is monotonically increasing with respect to ,
  hence  is also monotonically increasing with respect to 
  because  is an average of 
  over .
  If  is not bounded, then obviously (LHS)  (RHS).
  Otherwise, if  is bounded,
the increasing function 
  converges to some  as .
By (LHS)  (RHS) (that we have already shown),
   (LHS) for some .
  Here the following statement holds.
  
  Hence, for such  and ,
  
  Therefore we have
  
  and hence .
  Consequently
  (LHS)  (RHS).
  \myqed
\end{myproof}

\subsection{Proof of Prop.~\ref{prop:diaRefinement} and~\ref{prop:BoxRefinement}}
 We start with the following lemmas.
\begin{mylemma}[logical monotonicity]
  \label{lem:monotonicity}
  Let  be a positive context (Def.~\ref{def:context}). We have

\end{mylemma}
\begin{myproof}
  By induction on the construction of the positive context .
  \myqed
\end{myproof}


\begin{mylemma}\label{lem:zeroCorrespondence}
  Let  be  formulas and  be a positive context. Then
  
  implies
  
\end{mylemma}
\begin{myproof}
  Straightforward by induction on the construction of .
  \myqed
\end{myproof}

Now we prove Prop.~\ref{prop:diaRefinement}, soundness and completeness of -refinement.
\begin{myproof} (Of Prop.~\ref{prop:diaRefinement})
  Obviously we have
 ; therefore by Lem.~\ref{lem:monotonicity}, we have  
  
To prove the opposite direction, by Lem.~\ref{lem:zeroCorrespondence}, 
  it suffices to show the following.
  
  Assume .
  Then
  
\end{myproof}


Then we prove Prop.~\ref{prop:BoxRefinement}, soundness and completeness
of -refinement.
\begin{myproof} (Of Prop.~\ref{prop:BoxRefinement})
  From Lem.~\ref{lem:monotonicity}, 
  
  is obvious.
  We want to show the other direction.
  From Lem.~\ref{lem:zeroCorrespondence},
  it suffices to show 
  
  for any .
  Here ,
  hence 
  the above implication holds if so does the following.
    
  In the case of ,
  it obviously holds.
  Otherwise,
  in the case of ,
  we proceed as follows.
  Assume .
  Then 
  
\end{myproof}



\subsection{Proof of Thm.~\ref{thm:complexity_rel}}
\begin{myproof} 
 We obtain the robustness value
 
 via the robustness signals  for subformulas 
 of . This is done by induction on .
 
 Before we hit an averaged modality we use the algorithm from~\cite{DBLP:conf/cav/DonzeFM13} (described
 in~\S{}\ref{subsec:algoSTL}).
 Note that all the signals that we deal with are
 finitely piecewise-constant; by
 analyzing~\cite[Thm.~3]{DBLP:conf/cav/DonzeFM13},
 it is easy to see that the computation of
 has time-complexity in
 . Furthermore, the size of 
  (in the sense of Def.~\ref{def:signal}) is 
 in .


 Once we hit an averaged modality (like  or ),
 it is
 taken care of by  Algorithm~\ref{algo:tdia} (for ), 
 Algorithm~\ref{algo:tuntil} (for ) and their adaptations
 (for  and ). The time-complexity of the computation is
  , and the resulting 
 signal  has the size 
 in .
The difference, however, is that the robustness signal
  is no longer finitely piecewise-constant but is
 piecewise-linear.

 After that we again apply the algorithm from~\cite{DBLP:conf/cav/DonzeFM13} (see~\S{}\ref{subsec:algoSTL}),
 but now to the input signal that is finitely
 piecewise-\emph{linear}. In this case, the
 time-complexity as well as the size of   is shown to be
 in ~\cite[Thm.~3]{DBLP:conf/cav/DonzeFM13}. The extra factor
 is due to the extra timestamped values that arise from 
  two sloped lines crossing each other.
\auxproof{
  First, in the case of  is averaging-free,
  then the statement is obviously true from Thm.~\ref{thm:complexity}.
  Then, let us consider 
  the case of  
  where  is averaging-free.
  Because  is averaging-free,
  we can calculate  
  with time-complexity in 
  
  from Thm.~\ref{thm:complexity}.
  Moreover,
  the number of the timestamps of 
  is bounded above by .
  See Theorem~3 in \cite{DBLP:conf/cav/DonzeFM13}.
  Hence the function
  
  is computed in time 
  from Prop.~\ref{prop:complexity_tdia}.
  By the construction,
  the number of the timestamps of 
  is bounded above by .
  Now we apply Thm.~\ref{thm:complexity},
  and obtain the function .
  The time-complexity of this step is
  
  Hence the total time-complexity is 
  
  Finally, about the case of ,
  we can proof in the same manner.
}  \myqed
\end{myproof}



\section{ The Automatic Transmission
 Model~\cite{HoxhaAF14arch1}}\label{appendix:ATModel}
The model is given by a Simulink diagram in Fig.~\ref{fig:AT}; therein
the block for the digital
   controller of the gear is realized as a Stateflow diagram in
   Fig.~\ref{fig:shiftlogic}. An example of the model's trajectories is
   in Fig.~\ref{fig:trajectory}.

\begin{figure}[hbp]
   \begin{minipage}{.48\textwidth}
     \includegraphics[width=\textwidth]{pics/shiftlogic.png}
     \caption{The automatic transmission model
       from~\cite{HoxhaAF14arch1}: the Stateflow diagram for the digital
       controller of the gear}
     \label{fig:shiftlogic}
   \end{minipage}\quad
   \begin{minipage}{.45\textwidth}
     \includegraphics[trim=0cm 0cm 0cm 2.2cm, width=\textwidth]{pics/trajectory.eps}
     \caption{The automatic transmission model
       from~\cite{HoxhaAF14arch1}: a   trajectory example}
     \label{fig:trajectory}
   \end{minipage}
   \centering
   \includegraphics[trim=0cm 2cm 0cm 0cm, width=.7\textwidth]{pics/AT.png}
   \caption{The automatic transmission model
     from~\cite{HoxhaAF14arch1}: the Simulink diagram}\label{fig:AT}
\end{figure}



\end{document}
