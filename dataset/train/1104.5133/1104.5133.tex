\documentclass{tlp}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{url}
\usepackage[x11names, rgb]{xcolor}
\usepackage{tikz}
\usetikzlibrary{snakes,arrows,shapes}


\clearpage{}\newenvironment{program}{}
\newenvironment{lprogram}{}
\newenvironment{program2c}{}
\newenvironment{program3c}{}
\newenvironment{program4c}{}
\newcommand{\prule}[2]{\ensuremath{#1 &\gets& #2}}
\newcommand{\lprule}[3]{\ensuremath{#1 & #2 &\gets & #3}}
\newcommand{\lwprule}[4]{\ensuremath{#1 & #2 & \stackrel{{#3}}{\gets} & #4}}
\newcommand{\lrule}[3]{\ensuremath{#1\mathrm{:}\,#2\leftarrow#3}}
\newcommand{\naf}[1]{\ensuremath{\textit{not}~#1}}
\newcommand{\tneg}[1]{\ensuremath{\neg{#1}}}
\newcommand{\hbase}[1]{{\ensuremath{{\cal B}_{#1}}}}
\newcommand{\hbases}[1]{{\ensuremath{{\cal B}_{#1}\cup\neg{\cal B}_{#1}}}}
\newcommand{\arule}[2]{\ensuremath{#1\leftarrow #2}}
\newcommand{\larule}[3]{\ensuremath{#1: #2 \leftarrow #3}}
\newcommand{\body}[1]{\ensuremath{B(#1)}}
\newcommand{\head}[1]{\ensuremath{H(#1)}}
\newcommand{\unf}[1]{\ensuremath{\mathcal{U}(#1)}}
\newcommand{\gunf}[1]{\ensuremath{\mathcal{GUS}(#1)}}
\newcommand{\tunf}[1]{\ensuremath{\mathcal{TUS}(#1)}}
\newcommand{\aset}[1]{\ensuremath{\mathcal{A}(#1)}}
\newcommand{\prog}[1]{\ensuremath{P_{\ref{#1}}}}
\newcommand{\mnm}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\dep}[1]{\ensuremath{Dep(#1)}}
\newcommand{\comp}[1]{\ensuremath{comp(#1)}}
\newcommand{\poslit}[1]{\ensuremath{Lit^{+}(#1)}}
\newcommand{\posbody}[1]{\ensuremath{\poslit{\body{#1}}}}
\newcommand{\depgraph}[1]{\ensuremath{G_{#1}}}
\newcommand{\looprules}[2]{R^{+}_{#1}(#2)}
\newcommand{\nonlooprules}[2]{R^{-}_{#1}(#2)}
\newcommand{\loopform}[2]{\mathbb{LF}(#1,#2)}
\newcommand{\loopformprog}[1]{\mathbb{LF}(#1)}
\clearpage{}
\clearpage{}\newcommand{\lattice}{\ensuremath{\mathcal{L}}}
\newcommand{\true}{\ensuremath{\mathbf{t}}}
\newcommand{\false}{\ensuremath{\mathbf{f}}}
\newcommand{\T}{\ensuremath{\mathbf{T}}}
\newcommand{\ground}[1]{\ensuremath{{#1}_{g}}}
\newcommand{\Fuzzy}[1]{\ensuremath{\mathcal{F}({#1})}}
\newcommand{\PFuzzy}[1]{\ensuremath{\mathcal{F_P}({#1})}}

\newcommand{\aggregator}{\ensuremath{\mathcal{A}}}
\newcommand{\supp}[1]{\ensuremath{\mathit{supp}(#1)}}
\newcommand{\fand}{\ensuremath{\wedge}}
\newcommand{\for}{\ensuremath{\vee}}
\newcommand{\fneg}[2]{\ensuremath{\mathcal{N}_{#1}(#2)}}
\newcommand{\lneg}[1]{\fneg{l}{#1}}
\newcommand{\mneg}[1]{\fneg{m}{#1}}
\newcommand{\pneg}[1]{\fneg{p}{#1}}
\newcommand{\fimp}{\ensuremath{\rightarrow}}
\newcommand{\fif}{\ensuremath{\leftarrow}}
\newcommand{\feq}{\ensuremath{\approx}}
\newcommand{\bodyfand}[1]{\pretnorm_{#1}}
\newcommand{\rulefand}[1]{\pretnorm_{#1}}
\newcommand{\rulefimp}[1]{\prefimp_{#1}}
\newcommand{\minsuppint}[2]{{#1}_{s}(#2)}
\newcommand{\kcomp}[2]{Comp_{#1}(#2)}
\newcommand{\fsetminus}{\circleddash}
\newcommand{\pretnorm}{\mathcal{T}}
\newcommand{\pretconorm}{\mathcal{S}}
\newcommand{\prefimp}{\mathcal{I}}
\newcommand{\nfimcons}[1]{\Pi_{#1}}
\newcommand{\lfpnfimcons}[1]{\nfimcons{#1}^{*}}

\clearpage{}
\clearpage{}\newcommand{\bemph}[1]{\textbf{#1}}
\newcommand{\set}[1]{\ensuremath{\{\mathit{#1}\}}}
\newcommand{\tuple}[1]{\ensuremath{\langle{#1}\rangle}}
\newcommand{\setmin}[2]{\ensuremath{#1\!\setminus\!#2}}
\DeclareMathSymbol{\FORALL}   {\mathord}{symbols}{"38}
\DeclareMathSymbol{\EXISTS}   {\mathord}{symbols}{"39}
\newcommand{\SUCHTHAT}{\colon}
\newcommand{\Exists}[2]{\ensuremath{\EXISTS{#1} \SUCHTHAT {#2}}}
\newcommand{\Forall}[2]{\ensuremath{\FORALL{#1} \SUCHTHAT {#2}}}
\newcommand{\Nat}{{\ensuremath{\mathbb{N}}}}
\newcommand{\card}[1]{{\ensuremath{\mid\!{#1}\!\mid}}}
\newcommand{\dom}[1]{{\ensuremath{\mathit{dom}(#1)}}}
\newcommand{\restrict}[2]{{\ensuremath{{#1}\!\!\mid_{#2}}}}
\newcommand{\lfp}[1]{{\ensuremath{{#1}^\star}}}
\newcommand{\claim}[2]{\noindent\paragraph*{Claim {#2}:}{#1}.\newline}
\newcommand{\case}[2]{\noindent\paragraph*{Case {#2}:}{#1}.\newline}

\newcommand{\todo}[1]{\noindent\paragraph{}\textcolor{red}{todo:} #1\newline}
\newcommand{\jeroen}[1]{\noindent\paragraph{}\textsc{jeroen:} #1\newline}
\newcommand{\note}[1]{\noindent\paragraph{}\textsc{note:} #1\newline}

\newcommand{\poset}{\esm{\mc{P}}}              \newcommand{\preorder}{\esm{\mc{P}}}
 \newcommand{\propset}{\esm{\mc{B}}}            \newcommand{\funset}{\esm{F}}          \newcommand{\ruleset}{\esm{R}}
 \newcommand{\rbase}[1]{\esm{\mc{R}_{#1}}}
 \newcommand{\vars}{\propset}                   \newcommand{\expr}[1]{\esm{\mathcal{E}(#1)}}   \newcommand{\evalue}[2]{\esm{[#1]_{#2}}}
 \newcommand{\subexpr}[1]{\ensuremath{\mathit{sub}({#1})}}
 \newcommand{\rulemap}{\esm{\varphi}}           \newcommand{\lattmap}[1]{\esm{\gamma_{#1}}}            \newcommand{\aggr}[1]{\esm{\mc{A}_{#1}}}
 \newcommand{\aggrposet}[1]{\esm{\preorder_{#1}}}
 \newcommand{\aggrfunset}[1]{\esm{F'_{#1}}}
 \newcommand{\aggrrset}[1]{\esm{R_{#1}}}
 \newcommand{\ruleint}[1]{\esm{\rho_{#1}}}
 \newcommand{\zerointerp}{\ensuremath{{\cal I}_{0}}}
 \newcommand{\maxruleint}{\esm{\rho_{\mathbb{1}}}}
 \newcommand{\minruleint}{\esm{\rho_{\mathbb{0}}}}
\newcommand{\nbase}[1]{\esm{\mc{N}_{#1}}}
 \newcommand{\rsbase}[1]{\esm{\rbase{#1}^s}}
 \newcommand{\rrbase}[1]{\esm{\rbase{#1}^r}}
 \newcommand{\rfif}[2]{\esm{#1 \fif_r #2}}
 \newcommand{\sfif}[2]{\esm{#1 \fif_s #2}}
 \newcommand{\lpfif}[3]{\ensuremath{#1 & #2 &\fif& \mathit{#3}}}
 \newcommand{\Opt}[2]{\mathcal{O}pt(#1,#2}
 \newcommand{\awrule}[3]{\ensuremath{#1\stackrel{#2}{\leftarrow}#3}}

\newcommand{\latt}[1]{\esm{\lattice}_{#1}}
 \newcommand{\lattone}{1_\lattice}
 \newcommand{\lattnil}{0_\lattice}
 \newcommand{\LattFuzzy}[2]{\esm{\mc{F}_{#1}(#2)}}


  \newcommand{\ffneg}[1]{\ensuremath{\fneg{#1}}}
  \newcommand{\ffand}[2]{\ensuremath{{#1}\fand{#2}}}
  \newcommand{\ffimp}[2]{\ensuremath{{#1}\fimp{#2}}}
  \newcommand{\ffif}[2]{\ensuremath{{#1}\fif{#2}}}
  \newcommand{\gfand}[2]{\ensuremath{{#1}\fand_{g}{#2}}}
  \newcommand{\gfimp}[2]{\mbox{\ensuremath{{#1}\fimp_{g}{#2}}}}
  \newcommand{\gfif}[2]{\mbox{\ensuremath{{#1}\fif_{g}{#2}}}}
  \newcommand{\exprsubst}[3]{\ensuremath{{#1}_{#2}^{#3}}}
  \newcommand{\gfneg}[1]{\ensuremath{\fneg_g{#1}}}
  \newcommand{\stdneg}[1]{\ensuremath{\fneg_s{#1}}}
  \newcommand{\gneg}{\fneg_g\,}

\newcommand{\infixop}[3]{\esm{{#2}#1#3}}              \newcommand{\mfor}[2]{\infixop{\for_m}{#1}{#2}}       \newcommand{\mfand}[2]{\infixop{\fand_m}{#1}{#2}}     \newcommand{\mfimp}[2]{\infixop{\fimp_m}{#1}{#2}}     \newcommand{\pfand}[2]{\infixop{\fand_p}{#1}{#2}}     \newcommand{\lfand}[2]{\infixop{\fand_l}{#1}{#2}}     \newcommand{\pfimp}[2]{\infixop{\fimp_p}{#1}{#2}}     \newcommand{\lfimp}[2]{\infixop{\fimp_l}{#1}{#2}}     \newcommand{\fzor}{\esm{\vee}}                        \newcommand{\kdfimp}[2]{\infixop{\fimp_{kd}}{#1}{#2}} 
\newcommand{\lfif}[2]{\mbox{\ensuremath{{#1}\fif_{l}{#2}}}} 
  \newcommand{\lpkdfif}[3]{\ensuremath{#1 & #2 &\fif_{kd}&\!\!\!#3}}
  \newcommand{\lplfif}[3]{\ensuremath{#1 & #2 &\fif_{l}&\!\!\!#3}}
  \newcommand{\lpgfif}[3]{\ensuremath{#1 & #2 &\fif_{g}&\!\!\!#3}}
  \newcommand{\lgfif}[3]{\mbox{\ensuremath{#1\mathrm{:}\,{#2}\fif_{g}{#3}}}}
  \newcommand{\llfif}[3]{\mbox{\ensuremath{#1\mathrm{:}\,{#2}\fif_{l}{#3}}}}

\newcommand{\minsupp}[3]{\esm{#1_s(#2,#3)}}
  \newcommand{\imcons}[2]{\esm{\Pi_{#1,#2}}}
  \newcommand{\litrbase}[2]{\esm{#1_{#2}}}
  \newcommand{\lfpimcons}[2]{\esm{\Pi^*_{#1,#2}}}
  \newcommand{\cbase}[1]{{\ensuremath{{\cal C}_{#1}}}}
  \newcommand{\kbase}[1]{{\ensuremath{{\cal K}_{#1}}}}
  \newcommand{\rnocbase}[1]{{\ensuremath{\rbase{#1}\setminus\cbase{#1}}}}
  \newcommand{\inp}[1]{\ensuremath{\in \rbase{#1}}}
  \newcommand{\cimcons}[1]{\esm{\Pi_{#1}}}
  \newcommand{\Lit}[1]{\ensuremath{Lit(#1)}}

\newcommand{\refeq}[1]{(\ref{#1})}
  \newcommand{\refrule}[1]{\ensuremath{\mathit{#1}}}
  
  \newcommand{\rlabel}[1]{(#1){}[[}
  


\newtheorem{definition}{Definition}
 \newtheorem{example}{Example}
 \newtheorem{proposition}{Proposition}
 \newtheorem{corollary}{Corollary}
 \newtheorem{lemma}{Lemma}
\clearpage{}
\clearpage{}

 \newcommand{\esm}[1]{\ensuremath{#1}}	\newcommand{\mc}[1]{\mathcal{#1}}	

\newcommand{\imp}{\Rightarrow}		

\newcommand{\lub}{\esm{\sqcup}}	\newcommand{\glb}{\esm{\sqcap}}	\newcommand{\Lub}{\esm{\bigsqcup}}
  \newcommand{\Glb}{\esm{\bigsqcap}}

\newenvironment{eqproof}{}	\newenvironment{eqproof2}{}	\newcommand{\hint}[1]{\langle \textnormal{#1} \rangle\;}
 
%
\clearpage{}

\title{Reducing Fuzzy Answer Set Programming to Model Finding in Fuzzy Logics}
\author[Jeroen Janssen, Steven Schockaert, Dirk Vermeir and Martine De Cock]{JEROEN JANSSEN\thanks{Funded by a joint Research Foundation-Flanders (FWO) project}\\Dept.~of Computer Science, Vrije Universiteit Brussel\\Pleinlaan 2, 1050 Brussels, Belgium\\
       \email{jeroen.janssen@vub.ac.be}
       \and STEVEN SCHOCKAERT\thanks{Postdoctoral fellow of the Research Foundation-Flanders (FWO)}\\Dept.~of Applied Mathematics and Computer Science, Universiteit Gent\\Krijgslaan 281, 9000 Ghent, Belgium\\
	\email{steven.schockaert@ugent.be}
       \and DIRK VERMEIR\\Dept.~of Computer Science, Vrije Universiteit Brussel\\Pleinlaan 2, 1050 Brussels, Belgium\\
	\email{dirk.vermeir@vub.ac.be}
       \and MARTINE DE COCK\thanks{On leave of absence from Ghent University}\\Institute of Technology, University of Washington\\1900 Commerce Street, WA-98402 Tacoma, USA\\
	\email{mdecock@u.washington.edu}}

  \submitted{August 16, 2010}
  \revised{January 17, 2011}
  \accepted{March 26, 2011}

\begin{document}

\maketitle

\begin{abstract}
 In recent years answer set programming has been extended to deal with multi-valued predicates. The resulting formalisms
allows for the modeling of continuous problems as elegantly as ASP allows for the modeling of discrete problems, by combining the
stable model semantics underlying ASP with fuzzy logics. However, contrary to the case of classical ASP where many
efficient solvers have been constructed, to date there is no efficient fuzzy answer set programming solver. A well-known
technique for classical ASP consists of translating an ASP program  to a propositional theory whose models exactly
correspond to the answer sets of . In this paper, we show how this idea can be extended to fuzzy ASP, paving the way
to implement efficient fuzzy ASP solvers that can take advantage of existing fuzzy logic reasoners. To appear
in Theory and Practice of Logic Programming (TPLP).
\end{abstract}

\begin{keywords}
 Fuzzy Logic, Answer Set Programming, ASSAT
\end{keywords}

\section{Introduction}

Answer Set Programming (ASP), see e.g.~\cite{BaralBook} is a form of non-monotonic reasoning based on the stable model semantics for logic programming \cite{gelfondl88}. Intuitively, in answer set programming one writes a set of rules (the program) such that certain minimal models (the answer sets) of this program correspond to solutions of the problem of interest.


In recent work, logic programming has been extended to handle many different facets of imperfect information. Most
notably are the probabilistic
\cite{baral:plog,damasio-hybridprobabilistic,Fuhr2000,lukasiewicz-probabilistic,Lukasiewicz-DisjunctiveProbabilisticLP,NgSubrahmanian-1993a,NgSubrahmanian-1994a,Straccia:reasoningweb} and possibilistic
\cite{Alsinet:possibilistic,Kim:UAI2010,nicolas:possibilistic-stable-models,Nicolas:AMAI2006}
extensions to handle uncertainty, the fuzzy extensions
\cite{Cao2000,IshizukaMitsuru-1985a,Luka06,LukaStraccia07,LukaStraccia-TopkRetrieval,MadridOjeda-Aciego-2008a,MadridAciego2009,Saad-2009,Straccia:reasoningweb,FASP:amai,Vojtas01,Wagner-1998} which allow to encode the intensity to
which the predicates are satisfied, and, more generally, many-valued extensions
\cite{damasio:sortedmultiadjoint,DamasioMO07,damasio-antitonic,DamasioViegasPereira2001,DamasioPereira-embeddings,vanEmden1986,Fitting1991,KiferLi-1988a,kifer92theory,Lakshmanan1994,LakshmananSadri-1994,LakshmananSadri-1997,LakshmananSadri-2001,PhDLakshmanan,LoyerStraccia-2002a,LoyerStraccia-2003,NerodeRemmelSubrahmanian1997,Shapiro1983,Straccia05queryanswering,straccia-annotated,straccia:fixedpoint,Subrahmanian1994}.
In this paper we focus on a fuzzy extension of ASP, called fuzzy answer set programming (FASP), which combines the
stable model semantics for logic programming with fuzzy logics. More generally, FASP provides a semantics for logic
programs in which the truth of predicates (or propositions) may be graded. Such grades may mean different things in
different applications, but often they are related to the intensity to which a given property is satisfied. From an
application point of view, this is important because it allows to describe continuous phenomena in a logical setting.
Thus a formalism is obtained in which problems with continuous domains can be modeled with the same ease by which
discrete problems can be modeled in classical ASP. 


In recent years, efficient solvers for classical ASP have been developed. Some of these are based on the DPLL algorithm \cite{dpll} such as Smodels \cite{smodels} and DLV \cite{dlv}, others use ideas from SAT solving such as clasp \cite{clasp}, while still others directly use SAT solvers to find answer sets, e.g.~ASSAT \cite{assat-linzhao}, cmodels \cite{cmodels}, and pbmodels \cite{pbmodels}. The SAT based approaches have been shown to be fast, and have the advantage that they can use the high number of efficient SAT solvers that have been released in recent years. The DPLL based solvers have the advantage that they allow a flexible modeling language, since they are not restricted to what can directly and efficiently be translated to SAT, and that they can be optimized for specific types of programs.

Probabilistic ASP can be reduced to classical SAT \cite{Saad:ECSQARU2009}, allowing implementations using regular SAT solvers. Likewise, possibilistic ASP can be reduced to classical ASP \cite{Nicolas:AMAI2006}, which means ASP solvers can be used for solving possibilistic ASP programs. 

In the case of fuzzy ASP programs with a finite number of truth values, it has been shown in \cite{fasp1} that FASP can be solved using regular ASP solvers. Unfortunately, to date, no fuzzy ASP solvers or solving methods have been constructed for programs with infinitely many truth values. Our goal in this paper is to take a first step towards creating such efficient solvers by showing how the idea of translating ASP programs to SAT instances can be generalized to fuzzy answer set programs. In this way we can create fuzzy answer set solvers that use existing techniques for solving fuzzy satisfiability problems, e.g.~based on mixed-integer programming or other forms of mathematical programming.
Specifically, we focus on the ASSAT approach introduced in \cite{assat-linzhao}. While translating ASP to SAT is straightforward when ASP programs do not contain cyclic dependencies, called loops, careful attention is needed to correctly cover the important case of programs with loops. The solution presented by ASSAT is based on constructing particular propositional formulas for any loop in the program. In this paper, we pursue a similar strategy where \bemph{fuzzy loop formulas} are used to correctly deal with loops. Our main contributions can be summarized as follows:

\begin{enumerate}
 \item We define the completion of a fuzzy answer set program in the sense of \cite{FASP:amai}, and show that the answer sets of FASP programs without loops are exactly the models of its completion.
 \item By generalizing the loop formulas from \cite{assat-linzhao}, we then show how the answer sets of arbitrary FASP programs can be found, provided that the fuzzy logical connectives are t-norms. We furthermore show how the ASSAT procedure, which attempts to overcome the problem with an exponential number of loops, can be generalized to the fuzzy case.
\end{enumerate}

We furthermore show that the FASP semantics in terms of unfounded sets \cite{fasp1} coincide with the FASP semantics in terms of fixpoints (see e.g.~\cite{Luka06}). This is necessary because the development of loop formulas can more easily be done using the unfounded semantics, while the generalization of the ASSAT procedure is based on the fixpoint semantics.

The structure of the paper is as follows. Section~\ref{sec:prelims} recalls the basic fuzzy logic operators and Section~\ref{sec:FASP}  recalls the FASP framework from \cite{FASP:amai}. In Section~\ref{sec:FASP} we furthermore show that the unfounded semantics and fixpoint semantics of FASP coincide. Next, we define the completion of a FASP program in Section~\ref{sec:completion} and discuss the problems that occur in programs with loops. Section~\ref{sec:loopelimination} then shows how these problems can be solved by adding loop formulas to the completion. We illustrate our approach on the problem of placing a set of ATM machines on the roads connecting a set of cities  such that each city has an ATM machine nearby in Section~\ref{sec:example}. The reason for restricting our approach to t-norms is discussed in Section~\ref{sec:restrict}. Afterwards, in Section~\ref{sec:related}, we give an overview of related work and then present the conclusions in Section~\ref{sec:conclusion}.


A preliminary version of this paper appeared in \cite{FASP-iclp08}. This paper extends our earlier work by adding proofs,
a detailed use case and a discussion on the problems that occur when programs are allowed to contain t-conorms in the body. Furthermore we improved the presentation by removing the aggregation-based approach that was used in the aforementioned work.

\section{Preliminaries}\label{sec:prelims}



In general, fuzzy logics are logics whose semantics are defined in terms of variables that can take a truth value from the unit interval  instead of only the values  (false) and  (true). Different ways exist to extend the classical logic connectives, leading to different logics with different tautologies and axiomatizations \cite{Hajek98,novak:1999}. We briefly recall the most important concepts related to fuzzy logic connectives.

A \bemph{negator} is a decreasing  mapping  satisfying  and . A negator is called \bemph{involutive} iff . 

A \bemph{triangular norm} (t-norm) is an increasing, commutative and associative  operator  satisfying . Intuitively, this operator corresponds to logical conjunction. In this paper, we restrict ourselves to left-continuous t-norms. As the most commonly used t-norms obey this restriction, this poses no practical constraint. 

A \bemph{triangular conorm} (t-conorm) is an increasing, commutative and associative  operator  satisfying . Intuitively, it corresponds to logical disjunction. 

An \bemph{implicator}  is a  operator that is decreasing in its first and increasing in its second argument, and satisfies ,  and  . Every left-continuous t-norm induces a \bemph{residual implicator} defined by . Furthermore, a left-continuous t-norm  and its residual implicator  satisfy the \bemph{residuation principle}, i.e.~for  in  we have that  iff . For any left-continuous t-norm , its residual implicator  satisfies
 
For a given implicator  its induced negator is the operator  defined by . We summarize some common t-norms, t-conorms, residual implicators, and induced negators in Tables~\ref{tab:fuzzy-operators} and \ref{tab:fuzzy-operators-2}.

\begin{table}

\caption{Common fuzzy t-norms and t-conorms over }
\label{tab:fuzzy-operators}
\end{table}



\begin{table}

\caption{Common residual pairs and induced negators over }
\label{tab:fuzzy-operators-2}
\end{table}

\bemph{The biresiduum} of a residual implicator  is denoted as , and defined by . Note that due to (\ref{eq:resfimpprop}) it follows that  is always equal to either  or . We denote the particular choice of t-norm and implicator using a subscript, when it is not clear from the context, as in .



A \bemph{fuzzy set}  in a universe  is an  mapping. For  we call  the \bemph{membership degree} of  in . For convenience we denote with  the fuzzy set  satisfying  for  and  for . We use  to denote the universe of all fuzzy sets in . The \bemph{support} of a fuzzy set  is defined by . Inclusion of fuzzy sets in the sense of Zadeh is defined as  iff .
Last, in this paper we will write the \bemph{difference}  of two fuzzy sets to denote the fuzzy set defined by .

A \bemph{signature} is a tuple , with  a set of atoms (i.e.~propositional letters),  a set of t-norms,  a set of t-conorms,  a set of implicators, and  a set of negators. Additionally, we demand that  and  are in the signature. A \bemph{fuzzy formula} over a signature  then is either an atom, a value from , or the application of a t-norm or t-conorm from , resp.~, to two formulas, the application of an implicator from  to two formulas, or the application of a negator from  to a single formula. A \bemph{fuzzy theory} over a signature  is a set of fuzzy formulas over . An \bemph{interpretation}  over a signature  is a mapping from  to . It is extended to fuzzy formulas in a straightforward way, i.e.~if  and  are fuzzy formulas, then  (with ),  (with ),  (with ), and  (with ). An interpretation  is a \bemph{model} of a fuzzy formula , denoted , iff . An interpretation  is a model of a fuzzy theory , denoted , iff for each  we have that .

A particular signature leads to a particular fuzzy logic \cite{Hajek98}. For example,      gives rise to G\"odel logic,      gives rise to \L ukasiewicz logic, and      gives rise to product logic. For example, \L ukasiewicz logic is generally considered to be closest in spirit to classical logic, in the sense that many of its important properties are preserved. Another important advantage of \L ukasiewicz logic is that the implicator is continuous, which is not the case for G\"odel or product logic. Reasoning in this logic can be done using mixed integer programming, whereas reasoning in G\"odel logic can be done with the help of boolean SAT solvers. As in the boolean case, satisfiability checking in these three particular logics is NP-complete.

Last, we denote the infimum, resp.~supremum of two elements of  as , resp.~.




\section{Fuzzy Answer Set Programming}\label{sec:FASP}



Over the years many different fuzzy answer set programming formalisms have been developed \cite{Luka06,LukaStraccia07,MadridOjeda-Aciego-2008a,MadridAciego2009,Saad-2009,Straccia:reasoningweb,FASP:amai}. Most of these base their semantics on fixpoints or minimal models, in combination with a reduct operation. The approaches described in \cite{loyer:epistemic,FASP:amai}, however, are constructed from a generalization of unfounded sets. As the development of loop formulas can be done more elegantly when starting from unfounded sets, and we can show that the fixpoint semantics are equivalent to the semantics proposed in \cite{FASP:amai}, we will base our semantics on the latter framework. However, because the generalization of the ASSAT procedure from \cite{assat-linzhao} is based on fixpoint semantics, in this section we also show novel links between the unfounded and fixpoint semantics that ensure the correctness of our generalized procedure. 
First, we recall the main definitions from \cite{FASP:amai}.

A \bemph{literal}\footnote{As usual, we assume that programs have already been grounded.} is either an atom  or a \bemph{constant} from . An \bemph{extended literal} is either a literal (called a \bemph{positive extended literal}) or an expression of the form  (called a \bemph{negative extended literal}), with  an atom and  an arbitrary negator. A \bemph{rule}  is of the form 
  
 where ,  is a literal,  is a set of extended literals,  is an arbitrary t-norm, and  is a rule label. Furthermore, for convenience, we define , and define  as . The literal  is called the \bemph{head}, , of , while the set  is called the \bemph{body}, , of . We use  to denote the set of positive extended literals from the set .
 Given a rule  we denote the t-norm used in its body as ; the residual implicator corresponding to  is denoted as .
 A \bemph{constraint} is a rule with a constant in its head, whereas a \bemph{fact} is a rule with a constant as its body (and no
constant in its head). For convenience, we abbreviate a rule of the form , with  an extended literal, as .
 


 A \bemph{FASP program}  is a finite set of rules. We call a program \bemph{simple} if no rule contains negative extended literals. The set of all atoms occurring in  is called the \bemph{Herbrand Base}  of . Note that the Herbrand Base is finite since we assume that no function symbols occur in the terms of the ungrounded program. For any  we define the set  as the set of rules with atom  in their head. An \bemph{interpretation}  of  is a fuzzy set in . We extend interpretations to constants from , extended literals, and rules as follows:
 \begin{enumerate}
   \item  if 
   \item  if  is a literal
   \item 
\end{enumerate}
 A \bemph{model} of a program  is an interpretation  of  such that for each rule  we have .


 Note that, although each rule in a FASP program can only have a single t-norm in its body, a rule with mixed t-norms, such as , can easily be simulated by introducing a polynomial number of new literals and rules. In the case of rule  we need one new literal  and two new rules  and .
 






\begin{example}\label{ex:prog1}
 Consider the program , which consists of the following set of rules:
 
 Note that rule  is a fact, and rule  a constraint.
The fuzzy sets , and  are interpretations of .
For both interpretations we have that , i.e.~they both are models of the program.
\end{example}







The definition of fuzzy answer sets relies on the notion of \bemph{unfounded sets}, studied in \cite{FASP:amai}, which correspond to sets of ``assumption atoms'' that have no proper motivation from the program.

\begin{definition}[Unfounded sets \cite{FASP:amai}]\label{def:unfounded}
 Let  be a FASP program and let  be an interpretation of . A set  is called \bemph{unfounded} w.r.t.~ iff for each atom  and rule  either:
  \begin{enumerate}
   \item ; or
   \item ; or
   \item 
  \end{enumerate}
 An interpretation  of  is called \bemph{unfounded-free} iff  for any set  that is unfounded w.r.t.~.
\end{definition}

Intuitively, an unfounded set w.r.t.~an interpretation  of a FASP program  is a set of atoms that obtain a value in  that is not motivated by the rules of the program. The first condition of Definition~\ref{def:unfounded} ensures that the values of the literals in  are justified by the values of literals not in .
 The second condition shows that the degree to which a rule can motivate an atom is bounded by the value of its body. The third condition is needed to obtain a proper generalization of the classical definition of unfounded sets~\cite{BaralBook} (see~\cite{FASP:amai} for more details).



\begin{example}\label{ex:prog1-unfounded}
 Consider program  and interpretations  and  from Example~\ref{ex:prog1}. For  we can see that  is an unfounded set, as for rule  and , the only rules with  or  in the head, we have that  and . Since , interpretation  is not unfounded-free. Interpretation , however, is unfounded-free.
\end{example}




As shown in \cite{FASP:amai}, \bemph{answer sets} of FASP programs can be defined as the unfounded-free interpretations, which reflects the intuition that each atom in an answer set should have a proper motivation from the program.

\begin{definition}[Answer Set \cite{FASP:amai}]\label{def:kanswersets}
 Let  be a FASP program. A model  of  is called an \bemph{answer set} iff  is unfounded-free.
\end{definition}

\begin{example}
Consider program  and interpretation  from Example~\ref{ex:prog1}. Since we know from Example~\ref{ex:prog1-unfounded} that  is unfounded-free, it follows that  is an answer set of .
\end{example}

An alternative definition of answer sets, in terms of fixpoints, exists (see for example \cite{Luka06}). We will use this to generalize the ASSAT procedure described in \cite{assat-linzhao}. 

\begin{definition}[Immediate Consequence Operator \cite{Luka06}]\label{def:imcons}
 Let  be a FASP program. The \bemph{immediate consequence operator} of  is the mapping  defined by
  
\end{definition}

As shown in \cite{Luka06}, for simple programs this operator is monotonic and thus has a least fixpoint \cite{tarski:lattice}, denoted as . For these simple programs, \cite{Luka06} then defines the answer sets of a program as the least fixpoints of this operator. Since this operator is monotonic, the least fixpoint is unique and can be found by iteratively applying  from the interpretation  until a fixpoint is encountered. For non-simple programs, \cite{Luka06} defines a reduct operation that transforms a non-simple program into a simple program.

\begin{definition}[Reduct \cite{Luka06}]\label{def:reduct}
 Let  be a FASP program and let  be a rule in , where . The \bemph{reduct} of rule , with respect to an interpretation , is denoted as , and defined by
   
 The reduct of a program  w.r.t.~an interpretation  is defined as .
\end{definition}

\begin{example}\label{ex:prog1-reduct}
Consider program  and interpretation  from Example~\ref{ex:prog1}. The reduct of  with respect to  then is the following program
 
\end{example}

In the following we show the novel result that the semantics in terms of fixpoints coincide with those in terms of unfounded sets.
An important lemma regarding the immediate consequence operator and reduct is the following.

\begin{lemma}\label{lem:notmodel-lfviolated}
 Let  be a FASP program. For any interpretation  of  it holds that  iff .
\end{lemma}
\begin{proof}
 Follows trivially by the construction of  and Definition~\ref{def:reduct}.
\end{proof}

We now show that any answer set is a fixpoint of the immediate consequence operator.

\begin{lemma}\label{lem:unfounded-fixpoint}
 Let  be a FASP program. Then any answer set  of  is a fixpoint of .
\end{lemma}
\begin{proof}
 Let  be an answer set of . We show that  for any , from which the stated readily follows. The proof is split into the case for  and . For any  it must hold that  is not unfounded w.r.t.~,
 meaning that  and there is some  such that . Since , it then follows from (\ref{eq:resfimpprop}) that . As for any  we have , from (\ref{eq:resfimpprop}) it also follows that . Hence  is the supremum of .

 The case for  is as follows. First remark that as , it follows from (\ref{eq:resfimpprop}) and the fact that  for each , that . Hence, . 
\end{proof}

Second we show that answer sets can be characterized in terms of fixpoints of the immediate consequence operator.



\begin{proposition}\label{prop:fixp-charact}
 Let  be a FASP program. An interpretation  is an answer set of  iff .
\end{proposition}
\begin{proof}
 Let  be a model of .
 In \cite{FASP:amai} it was shown that the least fixpoint of  must necessarily be unfounded-free (Proposition~4). As any fixpoint of  is a model of , we only need to show that if  is unfounded-free, it is the least fixpoint of .
 
 Suppose . Then, since any unfounded-free model is a fixpoint of  due to Lemmas~\ref{lem:notmodel-lfviolated} and ~\ref{lem:unfounded-fixpoint}, it holds that some set  exists such that .
 
 Consider then . Surely  and hence . We now show that  is unfounded with respect to , leading to a contradiction. First, we show that for any atom  and rule  it holds that 
  
 as follows
  
\noindent Thus, since it follows from the Definition of  that , we have shown that (\ref{eq:prop:fixp-charact}) holds. From this equation we obtain that
  
 Hence
  
 Which means  is unfounded with respect to , a contradiction.
\end{proof}




\begin{example}
Consider program  and interpretations  and  from Example~\ref{ex:prog1}. Computing the least fixpoint of  and  can be done by iteratively applying these operators, starting from , until we find a fixpoint. Hence for  we obtain in the first iteration . The second iteration gives , hence a fixpoint, meaning  is the least fixpoint of .
Iteratively applying  brings us , which is also a fixpoint of .
\end{example}

\section{Completion of FASP programs}\label{sec:completion}

In this section we show how certain fuzzy answer set programs can be translated to fuzzy theories such that the models of these theories correspond to answer sets of the program and vice versa. Such a correspondence is important as it allows us to find answer sets using fuzzy SAT solvers.

\begin{definition}[Completion of a FASP program]\label{def:kcompletion}
 Let  be a FASP program. The completion of , denoted as , is defined as the following set of fuzzy formulas:

where  is the biresiduum of an arbitrary residual implicator, and  is the residual implicator of the t-norm used in the body of rule .
\end{definition}

The completion of a program consists of two parts, viz.~a part for the literals , and a part for constraints . The constraints part simply ensures that all constraints are satisfied. The literal part ensures two things. By definition of the biresiduum and the fact that  iff  for any residual implicator, we have that  iff  and . Hence, the literal part of the completion establishes that rules are satisfied and second that the value of the literal is not higher than what is supported by the rule bodies.











\begin{example}\label{ex:prog1-completion}
 Consider program  from Example~\ref{ex:prog1}. Its completion is the following set of fuzzy propositions
 
\end{example}

Note that when applying Definition~\ref{def:kcompletion} for a literal  that does not appear in the head of any rule, we get , where we define .

We can now show that any answer set of a program  is a model of its completion .



\begin{proposition}\label{prop:kansset-is-modelcomp}
 Let  be a FASP program and let  be its completion. Then any answer set of 
 is a model of .
\end{proposition}
\begin{proof}
 Suppose  is an answer set of . By Lemma~\ref{lem:unfounded-fixpoint}, it follows that  is a fixpoint of , hence for each , . By construction of  and the fact that  is a model of , it then easily follows that .
\end{proof}

\begin{example}
Consider program  and interpretation  from Example~\ref{ex:prog1}. It is easy to see that  is a model of .
\end{example}

The reverse of Proposition~\ref{prop:kansset-is-modelcomp} is not true in general, which is unsurprising because it is already invalid for classical answer set programming. The problem occurs for programs with ``loops'', as shown in the following example.

\begin{example}
 Consider program  and interpretation  from Example~\ref{ex:prog1}. We can easily see that  is a model of , but, as we have seen in Example~\ref{ex:prog1-unfounded}, it is not an answer set of .
\end{example}

One might wonder whether taking the minimal models of the completion would solve the above problem. The following example shows that the answer is negative.

\begin{example}\label{ex:progmin}
 Consider the following program 
 
 \noindent The completion  is
 
 \noindent Consider now the interpretation . Since  and 
  
 we can see that  is a model of . We show that it is a minimal model as follows. Suppose some  exists. Then we can consider three cases: (i)  and ; (ii)  and ; (iii)  and . In all three cases we obtain that , since  or . Hence  is not a model of  and  is thus a minimal model of .
 However,  is not an answer set of  since .
\end{example}




As in the crisp case however, when a program has no loops in its positive dependency graph, the models of the completion and the answer sets coincide. First we define exactly what a loop of a FASP program is, and then we show that this property indeed still holds for FASP.

\begin{definition}[Loop]\label{def:loop}
 Let  be a FASP program. The \bemph{positive dependency graph} of  is a directed graph  where  iff . For ease of notation we also denote this relation with  for atoms  and  in the Herbrand base of . We call a non-empty set  a \bemph{loop} of  iff for all literals  and  in  there is a path (with length ) from  to  in  such that all vertices of this path are elements of .
\end{definition}

\begin{example}
 Consider program  from Example~\ref{ex:progmin}. The dependency graph of  is pictured in Figure~\ref{fig:depgraph-prog2}. We can see that  is a loop. If this loop was not in the program, its completion would become
 
 This fuzzy theory has no models. Since program  has no answer sets, this means the answer sets coincide with the models of the completion when removing the loop.
\end{example}

\begin{example}
Consider program  from Example~\ref{ex:prog1}. The dependency graph of  is pictured in Figure~\ref{fig:depgraph-prog1}. We can clearly see that there is a loop between nodes  and . Due to this loop, the values of  and  are not sufficiently constrained in the completion.
\end{example}

From the preceding examples one might think that removing the loops from the program would be sufficient to make the models of the completion and the answer sets coincide. However, this is not the case, as the semantics of the program then changes, as illustrated in the following example.

\begin{example}\label{ex:progchange}
 Consider program  consisting of the following rules
 
 Its single answer set is . If we remove rule  or , the answer set of the resulting program is .
\end{example}

\begin{figure}
 \centering
 \includegraphics[scale=0.50]{depgraphex2}
 \caption{Dependency graph of program  from Example~\ref{ex:progmin}}
 \label{fig:depgraph-prog2}
\end{figure}

\begin{figure}
 \centering
 \includegraphics[scale=0.50]{depgraphex}
 \caption{Dependency graph of program~ from Example~\ref{ex:prog1}}
 \label{fig:depgraph-prog1}
\end{figure}

We can now show that for programs without loops the answer sets coincide with the models of their completion. We first introduce two lemmas.

\begin{lemma}\label{lem:noloop-modelcomp-is-ansset-1}
 Let  be a directed graph with a finite set of vertices and  with . If every node in  has at least one outgoing edge to another node in , there must be a loop in .
\end{lemma}
\begin{proof}
 From the assumptions it holds that each  has an outgoing edge to another node in . This means that there is an infinite sequence of nodes  such that  for . Since  is finite, it follows that some vertex occurs twice in this sequence, and hence that there is a loop in .
\end{proof}

\begin{lemma}\label{lem:noloop-modelcomp-is-ansset-2}
 Let  be a FASP program,  an interpretation of  and . Then if  and  is unfounded w.r.t.~ it holds that for each  in  there is some  in  such that . 
\end{lemma}
\begin{proof}
 Assume that , in other words  and . As  is unfounded w.r.t.~, for each  it holds that either\\
\phantom{xx}1. ; or\\
   \phantom{xx}2. ; or\\
   \phantom{xx}3. \\
We can now show that there is at least one rule  that violates the second and third of these conditions, meaning it must satisfy the first. 
  
  From  we know by construction of  that for each , . Hence for each  there is a rule  such that , thus the second condition is violated. Since , it then also follows that the third condition is violated.
  
  In other words there must be some  such that  and . Since  is unfounded w.r.t.~, this means that . Since  implies that  due to the fact that  for any t-norm , we can conclude that there is some  such that .
\end{proof}

Using these lemmas we can now show that the answer sets of any program without loops in its dependency graph coincide with the models of its completion. This resembles Fages' theorem on tight programs in classical ASP \cite{fages:completion}.

\begin{proposition}\label{prop:noloops-ansset-is-modelcomp}
 Let  be a FASP program. If  has no loops in its positive dependency graph it holds that an interpretation  of  is
 an answer set of  iff .
\end{proposition}
\begin{proof}
 We already know from Proposition~\ref{prop:kansset-is-modelcomp} that any answer set of  is necessarily a model of , hence we only need to show that every model of  is an answer set of  under the conditions of this proposition. As , it holds that  is a model of . We show by contradiction that  is unfounded-free. Assume that there is a set  such that  is unfounded w.r.t.~ and . From Lemma~\ref{lem:noloop-modelcomp-is-ansset-2} we know that for each  it holds that there is some rule  such that . Using the definition of , this means that for each such  there is some  such that . This however means that there is a loop in  by Lemma~\ref{lem:noloop-modelcomp-is-ansset-1}, contradicting the assumption.
\end{proof}

Hence, finding the answer sets of a program with no loops in its positive dependency graph can be done by finding models of its completion.

\section{Loop Formulas}\label{sec:loopelimination}

As mentioned in the previous section, sometimes the models of the completion are not answer sets. In this section, we investigate how the solution that has been proposed for boolean answer set programming, viz.~adding loop formulas to the completion \cite{assat-linzhao}, can be extended to fuzzy answer set programming.

For this extension, we start from a partition of the rules whose heads are in some particular loop . Based upon this partition, for every loop  we define a formula in fuzzy logic, such that any model of the completion satisfying these formulas is an answer set.

For any program  and loop  we consider the following partition of the rules in  whose head belongs to the set  (due to \cite{assat-linzhao})
 

Note that this partition only takes the positive occurrences of atoms in the loop into account.
Intuitively, the set  contains the rules that are ``in'' the loop , i.e.~the rules that are jointly responsible for the creation of the loop in the positive dependency graph, whereas the rules in  are the rules that are outside of this loop. We will refer to them as ``loop rules'', resp.~``non-loop rules.''

\begin{example}
Consider program  from Example~\ref{ex:prog1}. It is clear that for the loop  the set of loop rules is  and the set of non-loop rules is .
\end{example}



\begin{example}
Consider program  from Example~\ref{ex:prog1} with interpretations  and  from Example~\ref{ex:prog1} once again. 
It is clear that in  no loop rules were used to derive the values of  and , whereas in  only loop rules are used. 
\end{example}



Hence there is a problem when the value of literals in a loop are only derived from rules in the loop. To solve this problem, we should require that at least one non-loop rule motivates the value of these loop literals. As illustrated in the next example, one non-loop rule is sufficient as the value provided by this rule can propagate through the loop by applying loop rules.

\begin{example}\label{ex:prog2}
 Consider program  from Example~\ref{ex:progchange} again.
 Clearly this program has a loop  with  and . Consider then interpretations  and . We can easily see that  is an answer set of , whereas  is not, although they are both models of . The problem is that in  the values of  and  are higher than what can be derived from the non-loop rule , whereas in  their values are exactly what can be justified from applying rule .
 The latter is allowed, as values are properly supported from outside the loop, while the former is not, as in this case the loop is ``self-motivating''.
\end{example}

To remove the non-answer set models of the completion, we add loop formulas to the completion, defined as follows.

\begin{definition}[Loop Formula]\label{def:loopformula}
 Let  be a FASP program and  a loop of . Suppose that . Then the loop formula induced by loop , denoted by , is the following fuzzy logic formula:
  
 where  is an arbitrary residual implicator. If , the loop formula becomes
  
\end{definition}

 The loop formula proposed for boolean answer set programs in \cite{assat-linzhao} is of the form
  
  
It can easily be seen that (\ref{eq:loopforms}) is a straightforward generalisation of (\ref{eq:loopforms-2}) as the latter is equivalent to
 
Note that this equivalence is preserved in \L ukasiewicz logic, but not in G\"odel or product logic.
 Furthermore, since  only when    , it is easy to see that in the case where , the truth value of all atoms in the loop  is .
 
\begin{example}
 Consider program  and interpretations  and  from Example~\ref{ex:prog1}. The loop formula for its loop  is the fuzzy formula , since . It is easy to see that  does not satisfy this formula, while interpretation  does. 
\end{example}

\begin{example}
 Consider program  from Example~\ref{ex:progchange}. The loop formula for its loop  is the propositional formula , since . Again we see that interpretation  from Example~\ref{ex:prog2} satisfies this loop formula, whereas interpretation  from the same example does not.
\end{example}
 
 We now show that by adding loop formulas to the completion of a program, we get a fuzzy propositional theory that is both sound and complete with respect to the answer set semantics. First we show that this procedure is complete.
 


\begin{proposition}[Completeness]\label{prop:loopforms-complete}
 Let  be a FASP program, let  be the set of all loops of , and define .  For any answer set  of , it holds that . 
\end{proposition}
\begin{proof}
 Suppose  is an answer set of  and . Since any answer set is a model of  according to Proposition~\ref{prop:kansset-is-modelcomp}, this means that . Hence, the loop formula of some loop  in  is not fulfilled; this means:
  
 Consider then the set .
 We show that  is unfounded w.r.t.~, i.e.~we show that for each  and rule , at least one of the conditions of Definition~\ref{def:unfounded} applies.
 
 Since , each rule  must either be in  or in . We consider the following cases:\\
\phantom{xx}1.~If  then by construction of  it holds that .\\
  \phantom{xx}2.~If  and , by construction of  we have that .\\
   \phantom{xx}3.~Suppose  and . Since  for each t-norm , we know that  for each . Hence for each  we have . This means that, since  and thus , we know from the definition of  that .


Now remark that  as  due to  for each .
From the above we can thus conclude that  is unfounded w.r.t.~, and since , that  is not unfounded-free: a contradiction.
\end{proof}

Second we show that adding the loop formulas to the completion of a program is a sound procedure.


\begin{lemma}\label{lem:loopforms-sound-1}
 Let  be a directed graph and , with  finite, such that each node of  has at least one outgoing edge to another node in . Then there is a set  such that  is a maximal loop in  and for each  we have that there is no  for which .
\end{lemma}
\begin{proof}
 From Lemma~\ref{lem:noloop-modelcomp-is-ansset-1} we already know that there must be a loop in . Hence, there must also be a maximal loop in . First, remark that maximal loops must of course be disjoint as otherwise their union would form a bigger loop.
 Consider then the set , which is a collection of disjoint maximal loops  and remaining nodes  (single nodes that are not in any loop). There is an induced graph  of  with nodes  (i.e.~each maximal loop is a single node in the induced graph) and edges  induced as usual (i.e.~ if for some node  in  there is a node  in  such that  and likewise for the nodes in ). Clearly,  is acyclic as otherwise the nodes in  on the cycle would create a bigger loop in . Hence,  has leafs without outgoing edges. However, a leaf cannot be in  since that would imply a node in  without an outgoing edge. Thus we can conclude that all leafs in  are maximal loops in .
\end{proof}







\begin{proposition}[Soundness]\label{prop:loopforms-sound}
 Let  be a FASP program and let  be the set of all loop formulas of . Then for any interpretation  of  it holds that if , then  must be an answer set of .
\end{proposition}

\begin{proof}
 Suppose  and  is not an answer set of . Since any model of  must be a model of , this must mean that  is not unfounded-free, i.e.~that there exists a set  such that  is unfounded w.r.t.~. From Lemma~\ref{lem:noloop-modelcomp-is-ansset-2} we know that for each  there must be some  such that . Hence, by definition of  this means that for each  there is some  such that . Using Lemma~\ref{lem:loopforms-sound-1} this means that there is a set  such that  is a loop in  and for each  there is no  such that . In other words, for each  and rule  we have that
  

Now, consider . Since , we know that . Hence, if  for some rule , we know that . As  is unfounded w.r.t.~, it follows from Definition~\ref{def:unfounded} that .

 Using contraposition, this means that for each  and  we have that
  

 By the definition of , however, we know that for each model of  and for each  and  we have . Hence for each  and  from (\ref{eq:prop:loopforms-sound-2}) we have that
  
 Now, for each  and  by definition of  it holds that , meaning . Thus, , meaning , a contradiction.
\end{proof}



A straightforward procedure for finding answer sets would now be to extend the completion of a program with all possible loop formulas and let a fuzzy SAT solver generate models of the resulting fuzzy propositional theory. The models of this theory are the answer sets of the program, as ensured by Propositions~\ref{prop:loopforms-complete} and \ref{prop:loopforms-sound}. As there may be an exponential number of loops, however, this translation is not polynomial in general. A similar situation arises for classical ASP. The solution proposed in \cite{assat-linzhao} overcomes this limitation by iteratively adding loop formulas. In particular, a SAT solver is first used to find a model of the completion of a classical ASP program. Then it is checked in polynomial time whether this model is an answer set. If this is not the case, a loop formula, which is not satisfied by the model that was found, is added to the completion. The whole process is then repeated until an answer set is found. We will show that a similar procedure can be used to find answer sets of a FASP program.  

Starting from the fixpoint characterization of answer sets of FASP programs, we show that for any given model of the completion that is not an answer set, we can construct a loop that is violated.

\begin{proposition}\label{prop:notmodel-lfviolated}
 Let  be a FASP program. If an interpretation  of  is a model of  and , then some  must exist such that .
\end{proposition}
\begin{proof}
 Suppose  is an interpretation of  and , then from the definition of  and Lemma~\ref{lem:notmodel-lfviolated}, we can easily see that  is a fixpoint of . Since , some  must exist such that .
 
 Consider then the set . It holds that  since  and thus  by definition of . From the proof of Proposition~\ref{prop:fixp-charact} we then also know that for this set  the following property holds
  
 We can then show that there is a loop in  whose loop formula is violated. Since  we know from Lemma~\ref{lem:notmodel-lfviolated} that . From the definition of  this means
  
 Since the supremum is attained because  is finite we obtain
  
 As  this means
  
 Using (\ref{eq:notmodel-lfviolated-1}) it then holds that
   
  From the definition of  we thus get
   
  Using Lemma~\ref{lem:loopforms-sound-1} it follows that there is a set  that is a loop in  such that for each  there is no  such that . In other words, for each  there is no  such that there is a rule  for which . Hence for each  and rule  such that , it follows that .
  From (\ref{eq:notmodel-lfviolated-1}) and using contraposition this means there is some  that is a loop in  and for each  and  if  it must hold that .
  Now, for each  and  by definition it holds that , meaning . Thus, , meaning .
\end{proof}

Now, we can extend the ASSAT-procedure from \cite{assat-linzhao} to fuzzy answer set programs . The main idea of this method is to use fuzzy SAT solving techniques to find models of the fuzzy propositional theory which consists of the completion of , together with the loop formulas of particular maximal loops of . If a model is found which is not an answer set, then we determine a loop that is violated by the model and add its loop formula to the fuzzy propositional theory, after which the fuzzy SAT solver is invoked again. The algorithm thus becomes:

\begin{enumerate}
 \item Initialize 
 \item Generate a model  of , where  is the set of loop formulas of all loops in .
 \item If , return  as it is an answer set. Else, find the loops occurring in , add their loop formulas to  and return to step 2.
\end{enumerate}

The reason that we can expect this process to be efficient is articulated by Proposition~\ref{prop:notmodel-lfviolated}. Indeed, when searching for violated loops, we can restrict our attention to subsets of . Although the worst-case complexity of this algorithm is still exponential, in most practical applications, we can expect  to be small, as well as the number of iterations of the process that is needed before an answer set is found. In \cite{assat-linzhao} experimental evidence for this claim is provided in the case of classical ASP. Last, note that the fuzzy SAT solving technique depends on the t-norms used in the program. If only the \L ukasiewicz t-norm is used, we can use (bounded) mixed integer programming (bMIP) \cite{ManyValuedMixedInteger}. Since Fuzzy Description Logic Solvers are based on the same techniques as fuzzy SAT solvers, we also know that for the
product t-norm we need to resort to bounded mixed integer quadratically constrained programming (bMICQP) \cite{BobilloStraccia}.





\section{Example: the ATM location selection problem}\label{sec:example}

In this section we illustrate our algorithm on a FASP program modeling a real-life problem. Suppose we are tasked with placing  ATM machines  on roads connecting  towns  such that the distance between each town and some ATM machine is minimized, i.e.~we aim to find a configuration in which each town has an ATM that is as close as practically possible. To obtain this we optimize the sum of closeness degrees for each town and ATM. Note that this problem closely resembles the well-known -center selection problem (see e.g.~\cite{AusielloAl:ComplexityAndApproximation}). The difference is that in the -center problem the ATMs need to be placed in towns, where we allow them to be placed on the roads connecting towns. We can model this problem as an undirected weighted graph  where  is the set of vertices and the edge set  connects two towns if they are directly connected by a road. Given a distance function  that models the distance between two towns\footnote{For cities that are not connected the function  models the distance of the shortest path between them.}, the weight of the edge  is given by the normalized distance , where .

Since our FASP programs can only have t-norms in rule bodies, we also need to find a way to sum up the distances between towns and ATM machines. By using the \emph{nearness degree}, or closeness degree, which for a normalized distance  is defined as , we can perform summations of distances in our program. To see this, consider the following derivation:
 
Hence, by applying the \L ukasiewicz t-norm on the nearness degrees, we are summing the distances.

The program  solving the ATM selection problem is given as follows:

\begin{lprogram}
 \lprule{gloc:}{loc(A,T1,T2)}{\pretnorm_l(conn(T1,T2),\beta)\\
 \lprule{gnear:}{locNear(A,T1)}{\lneg{locNear'(A,T1)}}\\
 \lprule{gnear':}{locNear'(A,T1)}{\pretnorm_l(loc(A,T1,T2),\lneg{near(T1,T2)},}\\
   & & & \phantom{\pretnorm_l(}locNear(A,T2)),T1 \neq T2\\
 \lprule{nearr:}{near(T1,T2)}{\pretnorm_l(conn(T1,T3),near(T1,T3),near(T3,T2))}\\
 \lprule{locr:}{loc(A,T1,T2)}{loc(A,T2,T1)}\\
 \lprule{atmr:}{\mathit{ATMNear}(A,T)}{\pretnorm_l(loc(A,T1,T2),locNear(A,T1),near(T,T1))}\\
 \lprule{tDist:}{\mathit{totNear}}{\pretnorm_l(\{ \mathit{ATMNear}(a,t) \mid a \in \mathit{ATM},t \in \mathit{Towns}\})}\\
\end{lprogram}
where 

Note that, due to grounding, a rule such as  actually corresponds to a set of variable-free rules . We will keep referring to the specific grounded instance of a rule by the subscript.

Program  consists of a \emph{generate} and \emph{define} part, which for a specific configuration is augmented with an \emph{input} part consisting of facts. The \emph{generate} part consists of the three rules , , and , which generate a specific configuration of ATMs. The  rule chooses an edge on which the ATM machine  is placed by guessing a location for an ATM that does not yet has an assigned location, as ensured by the  part of this rule. The  and  rules generate a location on this edge where  is placed. Rules  and  originate from the constraint , where  is the distance between  and , if ATM  is placed on the edge between  and . Defining  as the nearness degree between  and  and noting that , we can rewrite this constraint in terms of t-norms and nearness degrees:
 
Hence, the bodies of rules  and  ensure that this constraint is satisfied. The reason we need two rules and cannot directly write a rule with body  is that the syntax does not allow negation in front of arbitrary expressions.


Rule  recursively defines the degree of closeness between two towns based on the known distances for connected towns.  Additionally, since the bodies of rules with the same head are combined using the maximum, the nearness degree obtained by  is always one minus the distance of the shortest path. The  rule makes sure that if an ATM is located on the edge between town  and , it is also recognized as being on the edge between  and , as we are working with an undirected graph. The  rule defines the location between a particular ATM machine and a town. Note that due to rule  this rule also covers the case when  is higher than . The  rule aggregates the total distances such that different answer sets of this program can be compared and ordered. In this way we could for example search for the answer set that has a maximal total degree of nearness, i.e.~in which the distance from the towns to the ATMs is lowest.


Consider the specific configuration  of towns  depicted in Figure~\ref{fig:atm} and suppose . In Figure~\ref{fig:depgraph-atm} we depicted a subset of the dependency graph of the grounded version of , where  is the input part of the problem, given by the following rules

For the configuration depicted in Figure~\ref{fig:atm} the input part  is

It is clear that  contains a number of loops. The completion of  is the following fuzzy propositional theory:
{\allowdisplaybreaks }
where 

Note that e.g.~the  in the right-hand side of the fuzzy proposition with  on the right-hand side stems from the inputs  we added to .
From the completion  we can see that an interpretation  satisfying  can be a model of , which is clearly unwanted as this would overestimate the nearness degrees between towns (i.e.~underestimate the distances). For example, consider 





Note that atoms  for which  are not included in the set notation, which is e.g.~the case for . One can easily verify that  is a model of .
To check whether  is an answer set we compute  by repeatedly applying , starting from the empty set, until we obtain a fixpoint, and check whether . Performing this procedure, we obtain



We can see that , hence  is not an answer set of .
From Proposition~\ref{prop:notmodel-lfviolated} we then know that there must be a loop in  whose loop formula is violated. Looking at the dependency graph, we can see that  contains three loops: ,  and . Their loop formulas are
 
 Clearly, these loop formulas are violated by , hence following the algorithm introduced in
Section~\ref{sec:loopelimination}, we create a new fuzzy propositional theory , and try to
find a model of this new theory. Consider then the following model of this new theory:



One can readily verify that this model is an answer set of , hence the algorithm stops
and returns .

\begin{figure}
 \centering
\begin{tikzpicture}[scale=2.5,auto,swap]
\path (0:0cm) node[draw,shape=circle] (v1) {};
 \path (-18:1.5cm) node[draw,shape=circle] (v2) {};
 \path (18:1.3cm) node[draw,shape=circle] (v0) {};
\draw (v0) -- node {} (v1) (v0) -- node {} (v2) (v1) -- node {}(v2);
\end{tikzpicture}
 \caption{Town configuration for . The weights on the edges denote the nearness degrees between towns ,  and }
 \label{fig:atm}
\end{figure}

\begin{figure}
 \centering
 \includegraphics[scale=0.25]{depgraphATM}
\caption{Dependency graph of }
 \label{fig:depgraph-atm}
\end{figure}

We could have solved this problem using Mixed Integer Programming (MIP)\footnote{Though in general the G\"odel negation  cannot be implemented in MIP, in the ATM example we can implement the  rules using integer variables.}. However, the exact encoding of this problem would be less clear and straightforward to write. The reason for this is that in the MIP translation the loop formulas would need to be explicitly represented in the program, while in FASP this is handled implicitly. Hence, only the implementer of a FASP system needs to handle these loop formulas, not the developer who writes the FASP programs. This is exactly the power of FASP: providing an elegant, concise, and clear modelling language for representing continuous problems, which, thanks to the results in this paper, can be automatically translated to lower-level languages for solving continuous problems, such as MIP.



\section{Discussion}\label{sec:restrict}

The reader might wonder why we limit our approach to FASP programs with t-norms in their body, because at first sight it
seems the presented approach is easily extendable to arbitrary functions. It turns out that this is not the case,
however. Consider FASP with the \L ukasiewicz t-norm in rule bodies. As mentioned before, the completion of such a program, and its loop formulas, are formulas in \L ukasiewicz logic and are implementable using MIP. Now let us consider FASP where both the \L ukasiewicz t-norm and the \L ukasiewicz t-conorm may occur in rule bodies. At first, one would suspect that the loop formulas of such a program would again be formulas in \L ukasiewicz logic.
This turns out to be wrong however. To see this, consider the following rules:
 
One can readily verify that in the answer sets of a program containing these rules, literal  will be equal to  (provided that  does not occur in the head of any other rule). 
However, the negation  cannot be implemented in MIP, as the solution space of a MIP problem is always a topologically closed set (viz.~the union of a finite number of polyhedra), whereas the solution space of a constraint  cannot be represented as a closed set due to the strict negation in the definition of . This means that as soon as the \L ukasiewicz t-conorm is allowed, in general, there will not exist a \L ukasiewicz logic theory such that the models of that theory coincide with the answer sets of a given program. Hence, it is clear that the case where other operators than t-norms are used requires a different strategy.

Finding generalized loop formulas that cover e.g. both the \L ukasiewicz t-norm and t-conorm is not a trivial problem.  To illustrate some of the issues, let us examine two intuitive candidates. First, remark that the loop formulas introduced in Section~\ref{sec:loopelimination} eliminate certain answer sets (i.e.~they are too strict). Consider the following program :



\noindent where . This program has one loop, viz.~ with corresponding loop formula .
Now note that for  the value of  in any answer set is equal to . Hence, the loop formula incorrectly eliminates all answer sets in this case. One might think this can be solved by including a condition in the loop formula: . This formula however fails to eliminate models that are not answer sets (i.e.~it is not strict enough) on the following program:



If  the unique answer set of this program is . However,  is also a model of the completion
of this program and satisfies the above loop formula.

Although again more refined loop formulas can be thought of that handle the latter program correctly, we are pessimistic about the possibility of finding loop formulas that cover all cases.   It appears that such a general solution should be able to capture some underlying idea of recursion:  one loop may justify the truth value of some atom a, up to a certain level, which may then trigger other rules that justify the truth value of a, up to some higher level, etc.

Note that this problem does not occur in classical ASP (or when using the maximum t-conorm), since e.g.  is equivalent to  and , which is indeed why disjunctions in the body of rules are not considered in classical ASP. 

\section{Related Work}\label{sec:related}

The approach to fuzzy answer set programming for which we provided the translation to fuzzy SAT is called an \emph{unweighted implication-based approach}. There also exist \emph{weighted implication-based approaches} (e.g.~\cite{LukaStraccia07,madrid:existenceandunicity,MadridOjeda-Aciego-2008a,MadridAciego2009}), which use rules of the form
 
 where  is a rule label,  is an atom, , for , are extended literals, and . An interpretation  models this rule iff
 
 Since  is the residual implicator of  this is equivalent to 
 
 Hence a weighted rule of the form (\ref{eq:wrule}) above can be simulated by the rule
 
Thus, the translation presented in this paper can equally be applied to weighted implication-based approaches.

In addition to the implication-based approaches (IB) one also finds \emph{annotation-based (AB) approaches} (see e.g.~\cite{straccia-annotated}). In the annotation-based setting a rule is of the form 
 
Such a rule asserts that the value of atom  is at least  if the value of each atom , , is at least . In this setting  is a computable function and  is either a constant or a variable ranging over an appropriate truth domain. Due to the difference in semantics between the IB and AB approaches, our method is not directly applicable to AB frameworks. One can find an in-depth overview of logic programming with fuzzy logic in~\cite{Straccia:reasoningweb}.

In \cite{fasp1}, an implementation method for FASP programs with a finite truth value set is presented, which consists of translating a FASP program to a specific DLVHEX program. For solving continuous problems, however, we need infinite truth values, for which a solving method is much harder to construct. Our method is able to handle continuous problems, and additionally is more flexible than \cite{fasp1} since any method for solving continuous problems can be used as the backend, including fuzzy SAT solvers and the vast body of existing MIP solvers.

Apart from fuzzy answer set programming, in recent years possibilistic and probabilistic answer set programming have been developed. Both of these approaches can be reduced to classical SAT. In the case of probabilistic ASP, there is a direct translation method \cite{Saad:ECSQARU2009}, while a possibilistic ASP program can be translated to an equivalent ASP program, on which the ASSAT procedure can then be applied. 


\section{Conclusion}\label{sec:conclusion}

In this paper we have focused on the translation of FASP programs to particular satisfiability problems. We have introduced the completion of a program and have shown that in the case of programs without loops, the models of the completion are exactly the answer sets. Furthermore, to solve the general problem, we have generalized the notion of loop formulas. This translation is important because it allows to solve FASP programs using fuzzy SAT solvers. Under appropriate restrictions, for example, the satisfiability problems that are obtained can be solved using off-the-shelf mixed integer programming methods.  From an application point of view, this allows us to encode continuous optimization problems in a declarative style which is similar to traditional answer set programming.   This style of encoding problems is often more intuitive, as well as more concise, while the results we have presented ensure that the power of mathematical programming techniques can still be employed to find the solutions.

\section*{Acknowledgment}
The authors would like to thank the anonymous reviewers for their useful suggestions and remarks.
\bibliographystyle{acmtrans}
\bibliography{loops}

\end{document}
