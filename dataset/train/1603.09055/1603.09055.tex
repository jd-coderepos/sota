\documentclass[11pt]{article}

\usepackage{amssymb,
  amsmath,
  amsfonts,
  amsthm}
\usepackage[utf8]{inputenc}

\usepackage[plainpages=false]{hyperref}

\usepackage{booktabs}
\usepackage{mathtools}
\usepackage{authblk}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{xcolor}



\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}


\usepackage{enumitem}

\newlist{conditions}{enumerate}{2}
\setlist[conditions,1]{label=\emph{(\arabic*)}, ref={\arabic*}}
\setlist[conditions,2]{label=\emph{(\arabic*)}, ref={\arabic{conditionsi}.\roman*}}

\renewcommand{\phi}{\varphi}
\newcommand{\modop}{\operatorname{mod}}
\newcommand{\fin}{\textup{Fin}}
\newcommand{\tower}{\textup{tower}}
\newcommand{\conn}{\text{conn}}
\newcommand{\EXP}[1][d]{#1\textnormal{-}\!\operatorname{exp}}

\makeatletter
\let\@@pmod\pmod
\DeclareRobustCommand{\pmod}{\@ifstar\@pmods\@@pmod}
\def\@pmods#1{\mkern4mu({\operator@font mod}\mkern 6mu#1)}
\makeatother


\newcommand{\logic}[1]{\textsc{#1}}
\newcommand{\logl}{\logic{l}}
\newcommand{\FO}{\logic{fo}}
\newcommand{\FOmod}{\logic{fo+mod}}
\newcommand{\MSO}{\logic{mso}}
\newcommand{\CMSO}{\logic{cmso}}

\newcommand{\ordinv}[1]{\textnormal{{\small \textless}-inv-}#1}
\newcommand{\oiFO}{\ordinv{\FO{}}}
\newcommand{\oiMSO}{\ordinv{\MSO{}}}

\newcommand{\ar}{\operatorname{ar}}

\newcommand{\eleq}[1][]{\equiv_{#1}}
\newcommand{\foeleq}[1][]{\eleq[#1]^{\FO{}}}
\newcommand{\msoeleq}[1][]{\eleq[#1]^{\MSO{}}}
\newcommand{\leleq}[1][]{\eleq[#1]^{\logl}}


\newcommand{\types}[1][\sigma,q,d]{\mathcal{T}_{#1}}
\newcommand{\ctypes}[1][\sigma,q,d]{\mathcal{T}^{\conn}_{#1}}
\newcommand{\atleq}{\preceq_{\text{atomic}}}

\newcommand{\maxeq}[1]{\equiv_{{\wedge}#1}}
\newcommand{\redmax}[2]{[#1]_{{\wedge}#2}}
\newcommand{\modeq}[1]{\equiv_{\mathrm{mod}\,#1}}
\newcommand{\redmod}[2]{[#1]_{\mathrm{mod}\,#2}}

\newcommand{\size}[1]{\|#1\|}
\newcommand{\qr}[1]{\operatorname{qr}(#1)}
\newcommand{\qad}[1]{\operatorname{qad}(#1)}

\newcommand{\EF}{Ehrenfeucht-Fraïssé}

\newcommand{\bag}{\mathop\mathrm{bag}}

\newcommand{\st}{\mathbin |}
\newcommand{\absval}[1]{\vert #1 \vert}

\newcommand{\limplies}{\rightarrow}
\newcommand{\lequiv}{\leftrightarrow}

\newcommand{\biglor}{\bigvee}
\newcommand{\bigland}{\bigwedge}

\newcommand{\leqsym}{\logic{\ensuremath{\leq}}}

\newcommand{\I}{\mathcal{I}}

\newcommand{\rela}[2]{\ensuremath{{#1|}_{#2}}}
\newcommand{\relao}[2]{\rela{#1\!}{#2}}

\DeclareMathOperator{\tp}{tp}
\DeclareMathOperator{\rtp}{rtp}

\DeclareMathOperator{\reach}{reach}

\newcommand{\class}[1]{\mathcal{#1}}
\newcommand{\struct}[1]{\mathfrak{#1}}

\newcommand{\AS}{\struct{A}}
\newcommand{\BS}{\struct{B}}
\newcommand{\CS}{\struct{C}}
\newcommand{\FS}{\struct{F}}
\newcommand{\HS}{\struct{H}}
\newcommand{\KS}{\struct{K}}
\newcommand{\TS}{\struct{T}}

\newcommand{\GG}{\struct{G}}
\newcommand{\iso}{\cong}

\newcommand{\td}{\operatorname{td}}
\DeclareMathOperator{\level}{level}
\DeclareMathOperator{\tdroot}{roots}
\DeclareMathOperator{\dist}{dist}

\newcommand{\num}{\operatorname{num}}
\newcommand{\height}{\operatorname{height}}

\newcommand{\set}[1]{\{#1\}}
\newcommand{\setc}[2]{\{#1 \st #2\}}
\newcommand{\lrsetc}[2]{\left\{#1 \st #2\right\}}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Npos}{\mathbb{N}^{+}}

\newcommand{\intersect}{\cap}
\newcommand{\union}{\cup}
\newcommand{\bigunion}{\bigcup}
\newcommand{\disunion}{\sqcup}

\newcommand{\bigo}{O}
\newcommand{\smallo}{o}
\newcommand{\nexp}[1][d]{\ensuremath{#1\textnormal{-}\textsc{exp}}}
\newcommand{\poly}{\text{poly}}

\newcommand{\IONE}{\mathbf{1}}
\newcommand{\ITWO}{\mathbf{2}}
\newcommand{\IONEL}{\IONE_L}
\newcommand{\IONER}{\IONE_R}
\newcommand{\ITWOL}{\ITWO_L}
\newcommand{\ITWOR}{\ITWO_R}

\newcommand{\enc}{\operatorname{enc}} \newcommand{\inc}{\textsc{inc}}
\newcommand{\dec}{\textsc{dec}} \newcommand{\halt}{\textsc{halt}}
\newcommand{\true}{\text{true}} \newcommand{\false}{\text{false}}
\newcommand{\zero}{\text{zero?}}  \newcommand{\streak}{\mathrel{|}}



\begin{document}

\title{Succinctness of Order-Invariant Logics on\\ Depth-Bounded
  Structures\footnote{A  preliminary version of this paper was presented at the
    \textsc{mfcs} 2014 conference~\cite{EickmeyerEH2014}.}} 

\author[1]{Kord Eickmeyer}
\affil[1]{TU Darmstadt, Germany}
\author[2]{Michael Elberfeld}
\affil[2]{RWTH Aachen University, Germany}
\author[3]{Frederik Harwath}
\affil[3]{Goethe University Frankfurt, Germany}


\maketitle

\begin{abstract}
  We study the expressive power and succinctness of order-invariant
  sentences of first-order (FO) and monadic second-order (MSO) logic
  on structures of bounded tree-depth. Order-invariance is undecidable
  in general and, thus, one strives for logics with a decidable syntax
  that have the same expressive power as order-invariant sentences.
  We show that on structures of bounded tree-depth, order-invariant FO
  has the same expressive power as FO. Our proof technique allows for
  a fine-grained analysis of the succinctness of this translation. We
  show that for every order-invariant FO sentence there exists an FO
  sentence whose size is elementary in the size of the original
  sentence, and whose number of quantifier alternations is linear in
  the tree-depth.  We obtain similar results for MSO. It is known that
  the expressive power of MSO and FO coincide on structures of bounded
  tree-depth.  We provide a translation from MSO to FO and we show
  that this translation is essentially optimal regarding the formula
  size.  As a further result, we show that order-invariant MSO has the
  same expressive power as FO with modulo-counting quantifiers on
  bounded tree-depth structures.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

Understanding the \emph{expressivity} of logics on finite structures---the
question of which properties are definable in a certain logic---plays an
important role in database and complexity theory. In the former, logics are used
to formulate queries; in the latter, they describe computational
problems. Moreover, besides just studying a logic's expressivity, understanding
its \emph{succinctness}---the question of how complex definitions of properties
such as queries and problems must be---is a requirement towards (theoretical)
expressivity results of (potential) practical importance. The present work
studies the succinctness of first-order logic (\FO{}) as well as its
succinctness compared to extensions allowing for the use of a linear order and
set quantifiers. This extends and refines recent studies on the expressivity of
these logics~\cite{BenediktSegoufin2009,ElberfeldGT12} on restricted classes of
structures. The structures we consider have bounded tree-depth, which is a graph
invariant that measures how far a graph is from being a star in a similar way as
tree-width measures how far a graph is from being a tree. Our results are
summarised by Figure~\ref{fig:results}.

\begin{figure}[t]
  \begin{center}
    \begin{tabular}{c @{~~~~~~~} c @{~~~~~~~} c @{~~~~~~~} c}
      \toprule
      
      & \oiFO{} & \MSO{} & \oiMSO
      \\
      \midrule
       & \FO{} & \FO{} & \FOmod
      \\
       &  &
       & non-elementary
      \\
       &  &  & \\
      \bottomrule
    \end{tabular}
    \end{center}
  \caption{Summary of our results: A formula  of quantifier
    rank  is translated into a formula  that is equivalent
    to  on structures of tree-depth at most .}
  \label{fig:results}
\end{figure}

In both database and complexity theory, one often assumes that structures come
with a linear order and formulae are allowed to use this order as long as the
properties defined by them do not depend on the concrete interpretation of the
order in a structure. Such formulae are called \emph{order-invariant}. Since
testing order-invariance for given \FO{}-formulae is undecidable in general, one
tries to find logics that have the same expressive power as order-invariant
formulae, but a decidable syntax. Several examples prove that order-invariant
\FO{}-formulae (\oiFO{}) are more expressive than \FO{}-formulae without access
to orders, cf.~\cite{Schweikardt2013}.  A common feature of these separating
examples is that their Gaifman graphs contain large cliques, making them rather
complicated from the point of view of graph structure theory. 

For tree structures, on the other hand, \cite{BenediktSegoufin2009} showed that
the expressivity of \FO{} and \oiFO{} coincide. Following this example, 
we show that on structures of tree-depth at most  each \oiFO{}-sentence can be translated to an \FO{}-sentence
whose size is -fold exponential in the size of the original sentence (Theorem~\ref{thm:oifo-eq-fo}). The importance of the expressivity result is
highlighted by the fact that order-invariance is undecidable even on structures
of tree-depth at most  (Theorem~\ref{thm:ordinv-undecidable}). 

A logic that is commonly studied from the perspectives of algorithm design and
language theory is monadic second-order logic (\MSO{}), which extends
\FO{}-formulae by the ability to quantify over sets of elements instead of just
single elements. While it has a rich expressivity that exceeds that of \FO{}
already on word structures, the expressive powers of \FO{} and \MSO{} coincide
on any class of structures whose tree-depth is bounded~\cite{ElberfeldGT12} by a constant . We
refine this by presenting a translation into \FO{}-formulae of -fold exponential size
(Theorem~\ref{thm:mso-eq-fo}). We prove that this translation is essentially optimal regarding the formula size
(Theorem~\ref{thm:mso-lower-bound}).
Beside the succinctness results, we prove that \oiMSO{} has the same
expressive power as \FOmod{}, the extension of \FO{} by arbitrary
first-order modulo-counting quantifiers, for structures of bounded tree-depth (Theorem~\ref{thm:oimso-eq-fomod}). 

Our results also have implications for \FO{} itself. They imply that the
quantifier alternation hierarchy for \FO{} of \cite{ChandraH1982} collapses on
structures of bounded tree-depth, whereas it is shown in~\cite{ChandraH1982} to
be strict on trees of unbounded height. For structures of bounded tree-depth we
are able to turn any \FO-formula into a formula whose size is bounded by the
quantifier depth of the original formula and whose quantifier alternation depth
is bounded by a linear function in the tree-depth.

A recurring theme in the study of \FO{}, \MSO{}, and their variants is the
question of which graph-theoretical properties can be defined using formulae of
these logics. The main motivation behind these questions lies in the fact that
access to certain tree-decompositions or embeddings of the structure can be used
as a proof ingredient for translating formulae. Independent of the results
stated above, we prove that, for structures of bounded tree-depth, it is
possible to define tree-decompositions of bounded width \emph{and height} in
\FO{} (cf. Section~\ref{sec:canondecomp}).

\paragraph{Proof techniques}

Our proofs use techniques from finite model theory, in particular interpretation
arguments, logical types, and games. Compared to prior works
like~\cite{ElberfeldGT12}, we enrich the application of these techniques by a
quantitative analysis, thereby obtaining succinct translations instead of just
equal expressivity results. The proofs of \cite{ElberfeldGT12} use an involved
constructive variant of the Fefer\-man--Vaught composition theorem, which
complicates a straightforward analysis of the formula size in the translation
from \MSO{} to \FO{}. We also use composition arguments, but we get along with
an easier non-constructive variant. There is another proof of the result of
\cite{ElberfeldGT12} in \cite{GajarskyH2012}, but it relies on involved
combinatorial insights that seem unsuited for both a tight analysis of
succinctness as well as an adaptation to the ordered setting.

The results of \cite{BenediktSegoufin2009} about the expressivity of
\oiFO{} on trees use automata-theoretic and algebraic methods. Since
these methods seem unsuited to obtain succinct formula translations,
we apply and develop techniques that are mainly based on using games:
In order to translate \oiFO-sentences into \FO-sentences, we first
restrict our attention to a certain kind of linear ordering that is
based on the logical types of recursively-defined substructures. Since
the \FO{}-type of ordered structures turns out to be \FO-definable
in the original (unordered) structures,
we are able to prove a
succinct translation from \oiFO{} to \FO.

In order to translate \oiMSO-sentences into \FOmod-sentences, the proof
structure is similar, but we need to add a ``pumping lemma'' for \oiMSO, which
proves the limited expressive power of \oiMSO{} on the recursively considered
substructures.

\paragraph{Organisation of this paper} The paper continues with a background
section and, then, the results related to \oiFO{}, \MSO{}, and \oiMSO{} are
proved in Sections~\ref{sec:oifo}, \ref{sec:mso}, and \ref{sec:oimso},
respectively. Tree-decompositions for structures of bounded tree-depth are
handled in Section~\ref{sec:canondecomp}.

\section{Background}
\label{sec:background}

In the present section, we review definitions and terms related to logical
formulae and structures as well as the notion of tree-depth.

\paragraph{General notation}

The sets of natural numbers with and without  are denoted, respectively, by
 and .  Let  for all  with
, and let . We define the \emph{-fold exponential
function}  recursively by , and .  The \emph{class of functions that grow at most -fold
exponentially} is . If we say that a
relation is an \emph{order}, we implicitly assume that it is linear. Thus an
order is an antisymmetric, transitive, reflexive and total binary relation.

\paragraph{Logic}

For a reference on notation and standard methods in finite model theory, we
refer to the book of \cite{Libkin2004}.  We denote structures by Fraktur
letters  and their universes by the
corresponding latin letters .  Besides the standard logics
 and , we also consider the logic  that is obtained
from  by allowing the use of \emph{modulo-counting quantifiers}
 for each  and .  The meaning of
these quantifiers is that  iff , where  is a structure and  is a tuple of its elements.

We write  for the \emph{quantifier rank} and  for the
\emph{size} (or \emph{length}) of a formula~.  The \emph{quantifier
alternation depth}  of a formula  in \emph{negation normal
form} (\textsc{nnf}, i.e. all negations of  occur directly in front of
atomic formulae) is the maximum number of alternations between - and
-quanti\-fiers on all directed paths in the syntax tree of . If
 is not in \textsc{nnf}, we first find an equivalent formula  in
\textsc{nnf} using a fixed conversion procedure and then define .  If  is a set of formulae, we let  and .

For any logic  and , we write
 for  if -structures  and 
satisfy the same -sentences of quantifier rank at most . The
-equivalence class of  is its \emph{-type} and is
denoted by .  If the logic  has been fixed or the
concrete logic is not important for the discussion, we omit it in this and
similar notation.

For a signature , we denote by  the signature , where  is a binary relation symbol. An
\emph{ordered -structure} is a -structure 
where  is an order on . An \emph{ordered expansion}
 of a -structure  is an expansion of  to an
ordered -structure. A sentence  is
\emph{order-invariant} on a class  of structures if for all
-structures  and all ordered expansions
 and  of  we have  iff .  If  is not
otherwise stated, we assume  to be the class of all finite
structures. The set of all order-invariant  is
denoted by , and for such a  and a -structure
 we write  if  for
some (equivalently, for every) ordered expansion  of ;
 is defined in the same way.

The \emph{restriction} of a binary relation  on a set  to a subset  is the relation . Note
that a substructure of an ordered structure is again an ordered structure.  For
two linear orders  and  on disjoint sets  and ,
we define a linear order  on , the
\emph{(ordered) sum} of  and , as .

If  is a formula and  is a formula with at least
one free variable , then  is the
\emph{relativisation of  to }. We construct  by
replacing subformulae  and  by  and , respectively. Note that  if  is an existential formula; in particular,  where, in this case,  is equivalent to
a universal formula.

We transfer graph theoretic notions from graphs to general structures via the
notion of Gaifman graphs. The \emph{Gaifman graph}  of a structure
 is the simple undirected graph with vertex set  containing an edge
between  iff  and  and  occur together in a tuple in
one of the relations of . The \emph{distance}  between
elements  of  is their distance in , i.e. the length of a
shortest path between  and  in .  Similarly, notions such as
\emph{connectivity} and (connected) \emph{components} of  are defined. Note
that the edge relation of the Gaifman graph is definable by an existential
formula , and this can be used to obtain, for every , an existential formula  such that  iff .

\paragraph{Encoding information about elements in extended
  signatures}

In our proofs we will repeatedly remove single elements  from
structures  and encode information about the relations between
 and the remaining elements into an expansion  of the
structure  (which is the substructure of 
induced on the elements different from ). We do this in such a way
that the -type of  is determined by the -type of
 together with what we call the atomic type of  in
.

The \emph{atomic type}  of an element  of a -structure
 is the set of all  such that 
(where the tuple  has length ). If no confusion seems
likely we omit  and just write . Thus an atomic type is a
subset of , and we identify  with the
-sentence
.

Since we will often need the atomic type of the -minimal element
of a structure, we denote by  the type 
if  is an ordered structure with minimal element .

To encode the relations between the element which is removed and the
remaining elements, we define a signature  which
contains, for each  and each nonempty , a relation symbol  of arity . Given a
structure  and an element  we now obtain a -structure  by setting

Note that , so up to a renaming
of relation symbols,  is an expansion of .

The -type of  is determined by  and the
-type of :
\begin{lemma}
  \label{lem:IndASrtoAS}
  Let  and . Let  and  be
  structures,  and . If
  
  then also
  
\end{lemma}
\begin{proof}
  The same argument works for  and .
  Duplicator has a winning strategy  in the -round
  Ehrenfeucht-Fra\"iss\'e game for  on  and
  . Note that the strategy  is, in particular,
  a winning strategy on  and ,
  because  and  are expansions of these
  structures. Duplicator can win the -round EF-game on  and
   if she plays according to  on 
  and , and if she responds to  with  and vice
  versa.

  We have to argue that this strategy preserves relations between the
  played elements. For relations not involving the removed elements
   and , this is true because  is a winning strategy for the
  -round game on  and . Relations
  involving only the minimal elements are preserved because
  . Relations involving the minimal
  elements and other elements are preserved, because they are encoded
  in the relations  of the extended signature ,
  and these are preserved by .
\end{proof}

The following lemma is easy to prove following these definitions:
\begin{lemma}
  \label{lem:ASrtoAS}
  Let .  For every -sentence  there is an -formula
   of the same quantifier rank and quantifier
  alternation depth such that
  
  for all -structures  and .
\end{lemma}
\begin{proof}
  The proof uses a standard interpretation argument.  It suffices to
  provide quantifier-free formulae with a parameter  which define
  the universe and the relations of  in , provided
  that  is interpreted by the element . The universe is defined
  by the formula . Let . If, for each , we let 
  
  then  is a formula with free variables
   which defines  in .
\end{proof}

\paragraph{Tree-depth}

The following inductive definition is one of several equivalent ways
to define the \emph{tree-depth}  of a graph
(see \cite{NesetrilMendez2012} for a reference on tree-depth):


As usual, the tree-depth  of a relational structure  is
defined by . We let

and for each , we let


As an immediate consequence of the above definition of tree-depth, each  with  contains an element  with . We call these vertices \emph{tree-depth roots}
and denote the set of all such vertices by . By a result of
\cite{BoulandDK12}, the size of  is bounded by a function of 
(independent of the size of ): 

\begin{lemma}[{\cite[Lem. 7]{BoulandDK12}}]
  \label{lem:roots}
  There is a function  such that
   for each connected graph .
\end{lemma}

Note that the definition of  in \cite{BoulandDK12} is slightly
different from ours, but the two definitions are easily seen to be equivalent.

A graph of tree-depth at most  can not contain a path of length
 (cf.~\cite[6.2]{NesetrilMendez2012}). Therefore

for all elements  and  in the same connected component of a
structure  of tree-depth at most , and the formula

defines the reachability relation in these structures:

This (existential) formula allows us to relativise a formula
 to the connected component of :

where  is (the substructure of  induced on) the connected component of
 in .  Since  is existential, we have
 .

Using these observations and the inductive definition of tree-depth,
it is easy to write down an -sentence that defines
 on the class of all finite
-structures. While this na\"ive approach leads to a formula
whose quantifier alternation depth grows linearly with , it is also
possible to construct a \emph{universal} sentence 
defining  as a subclass of ,
cf.~\cite[Section~6.10]{NesetrilMendez2012} for details.
Using this sentence, we construct a sentence that defines the set  for each  with . To this end, we let . 

\section{Order-invariant first-order logic}
\label{sec:oifo}

It is well-known that order-invariance is undecidable on the class 
of all finite -structures, i.e.  there is no algorithm which decides for
a given -sentence if it is order-invariant on
. This leads to the question if the expressive power of
order-invariant sentences on a class  can be captured by a logic with
a decidable syntax.  An answer to this question in the case of the class
 seems out of reach.  We consider the question in the case of
bounded tree-depth structures, i.e.  for some .  More concretely, our aim is a proof of the following theorem:

\begin{theorem}
  \label{thm:oifo-eq-fo}
  For every , every signature , and each sentence
   of , there is an -sentence 
  which is equivalent to  on  and which has
  size  and quantifier-alternation
  depth .
\end{theorem}

The proof of Theorem~\ref{thm:oifo-eq-fo} will be presented in
Section~\ref{sec:oifo-to-fo} below. Before that, we want to motivate
Theorem~\ref{thm:oifo-eq-fo} by showing that the undecidability of
order-invariance holds even for structures of tree-depth 2.

\subsection{Undecidability of order-invariance on structures of tree-depth 2}
\label{sec:undecidability}

As mentioned by \cite{Schweikardt2013}, order-invariance on  is
decidable if the signature  contains only unary relation symbols.  An
ordered -structure in which the unary relations partition the universe
can be regarded as a word. An -sentence  then defines
a language . The sentence  is order-invariant iff the syntactic
monoid of  is commutative, which is decidable.  This argument can be
extended to general -structures and to structures of tree-depth  over
arbitrary signatures.

Hence, order-invariance is decidable on  if . The next
theorem shows that it becomes undecidable for .

\begin{theorem}
  \label{thm:ordinv-undecidable}
  There is a signature  such that order-invariance is undecidable on .
\end{theorem}

The proof of Theorem~\ref{thm:ordinv-undecidable} uses a reduction from the
undecidable halting problem for \emph{counter machines} (cf. \cite{Minsky1967})
with two counters which store natural numbers. A counter machine executes a
\emph{program}, i.e. a finite sequence of the following \emph{instructions}:
\begin{description}
\item[]  increment counter , proceed with next instruction.
\item[] if counter  is not zero: decrement counter ,
  proceed with -th instruction otherwise: proceed with instruction .
\item[] stop the execution. 
\end{description}

The configuration of the machine at any execution step is fully described by
a triple , where  are natural numbers
stored in the counters and  is the number of the next
instruction to be executed. Without loss of generality, we assume
that the last instruction of a program is always the 
instruction and that this instruction occurs nowhere else in the
program. Hence we say that a program \emph{halts} (on empty input) if
it ever reaches its last instruction when run from the initial
configuration . 

\begin{proof}[Proof of Theorem~\ref{thm:ordinv-undecidable}]
  We say that a sentence  is
  \emph{-satisfiable} if it has a model  where
  .  The folklore proof which shows that
  order-invariance on  is undecidable uses a many-one
  reduction from the undecidable finite satisfiability problem to
  order-invariance.  The same kind of argument proves that
  \emph{-satisfiability} (i.e. the problem which asks if a given
  sentence  is -satisfiable) many-one
  reduces to order-invariance on , where  for a unary relation symbol .
  This follows from the fact that  is
  -satisfiable if, and only if, the -sentence
  
  is \emph{not} order-invariant on .

  Hence, to complete the proof of our theorem, it suffices to show
  that the -satisfiability problem is undecidable for some
  signature  to be fixed below. To this end we reduce the
  halting problem for counter machines to -satisfiability.  Let
   be a program. We construct an
  -sentence  which is
  -satisfiable iff  halts.  First we fix an
  encoding of configurations of  by words over a finite alphabet
  . It would be natural to do this by encoding the counter values
  in unary using different symbols; say,  would become
  . We change this representation
  slightly: a configuration  of  is encoded by a word
  
  over the alphabet .
  \footnote{This alphabet depends on the length of
    the given program , but the proof can be
    modified easily to make the alphabet , and therefore the signature , independent of  without increasing the tree-depth of the structures involved.}

  Let  where  is a binary relation
  symbol and , where the  are
  unary relation symbols.  The -structures that we consider
  are \emph{-coloured graphs}, i.e. -structures where
   is the edge relation of a simple undirected graph and where the
  unary predicates are a vertex colouring (i.e. a partition of the
  vertex set). If a vertex of such a graph belongs to a relation
  , we say that it is \emph{-coloured}. The class of
  -coloured graphs is obviously -definable on
  .

  As usual, we identify each non-empty word over the alphabet 
  with an ordered -structure which, in turn, we regard as an
  ordered -coloured graph with no edges.  We refer to vertices
  which are coloured by  as \emph{instruction
    vertices}. If our program  halts after at most  computation
  steps then, with respect to our encoding, there exists a unique word
   which encodes the \emph{run} of , i.e. the finite sequence
  of configurations at time steps . We want to define a
  class of ordered -coloured graphs of maximum degree 
  obtained from the edge-less graph  by adding edges between its
  vertices. These graphs will be called \emph{matching extensions} of
  , since their edge relations will be unions of matchings
  (i.e. edge relations of graphs where each vertex is incident to
  exactly one edge).  Consider any word 
  which encodes a sequence of representations. We phrase the
  description of the execution of the counter machine program 
  given in the definition of counter machines above somewhat more
  formally as conditions under which the sequence 
  is a run of  (i.e. ).  At the same time, we rephrase them
  as statements about the ordered -coloured graph  in a way
  that will be suitable for the definition of our sentence .
  \begin{enumerate}
  \item  and  is a halting configuration,
    i.e.  for some .
  
    With our encoding, this is equivalent to the first vertex of  being
    -coloured and the last vertex being -coloured. (Recall
    that the machine starts with both counters being .)
  
  \item For each  and  one of the
    following statements is true:
    \begin{enumerate}
    \item  and .

      This holds iff we can add edges to  so that all
      -coloured vertices in  are matched with
      all but one of the -coloured vertices in
      , and the -coloured vertices in
       are matched with the -coloured
      vertices in , and the unique instruction vertices
      in  and  have the same colour.
      
    \item  and either  and
      , or  and
      .

      Equivalently, either one of the following statements is true:
      \begin{itemize}
      \item There exists no -coloured vertex in
         and no -col\-oured vertex in
        . Furthermore, the -coloured vertices in
         can be matched with the -coloured
        vertices in . The unique instruction
        vertex in  is -coloured.
      \item There is at least one -coloured vertex in
        . Furthermore, the -coloured vertices in
         can be matched with all but one of the
        -coloured vertices in , and the
        -coloured vertices in  can be
        matched with the -coloured vertices in
        .
        The unique instruction vertex in  is -coloured.
      \end{itemize}
    \item[(c),(d)] Analogous statements to (a), (b) for the case where
       operates on counter .
    \end{enumerate}
  \end{enumerate}
  Now, a \emph{matching extension} of  is an ordered graph
  obtained from  by adding, for each pair of subsequent
  configurations, exactly the edges of a matching witnessing that
   satisfies the conditions (a), (b), (c), and (d). Observe
  that each vertex of a matching extension is contained in at most one
  matching. Hence, any matching extension has maximum degree .
  Using our description above, it is easy to write down a first-order
  sentence  defining the class of all matching extensions of
  . This class is non-empty iff  halts. Hence  is
  -satisfiable iff  halts.
\end{proof}

\subsection{From order-invariant -formulae to -formulae}
\label{sec:oifo-to-fo}

We prove Theorem~\ref{thm:oifo-eq-fo}. The key insight here is that for every
quantifier rank  and every structure  there exists a
class of canonical linear orders  for which the -type of
 is already -definable in . In particular,
 only depends on , even though there may be more than
one such order on .

We call these canonical orders \emph{-orders}. After defining them
formally we will thus prove the following two facts about them:
\begin{enumerate}
\item Expansions by -orders are indistinguishable in
  , i.e. 
  for all finite structures , provided both  and
   are -orders
  (cf.~Lemma~\ref{lem:all-q-orders-are-equivalent}).
\item If the tree-depth of structures is bounded, then the -type
   of an expansion of  by a -order is
  definable in  (Lemmas~\ref{lem:connected-lift}
  and~\ref{lem:counting-formulae}). The proof of
  Theorem~\ref{thm:oifo-eq-fo} easily follows from this.
\end{enumerate}

\paragraph{The definition of -orders}

With an eye towards Section~\ref{sec:oimso}, the notion of -orders
will be defined more generally for logics . We fix arbitrary orders  on the
set of -types over the signature , and
 on the set of atomic -types. For
simplicity we write  for .

To obtain a -order  on a connected structure , we pick a root  of  which has
-minimal atomic type among all roots and for
which the type of -ordered expansions of  is
-minimal among all
-minimal roots. We place this  in front of
the order  and order the remaining elements according to a
(recursively obtained) -order on . On structures with
more than one component, we -order the components individually and
take the sum of their orders, following the -order of
the components:

\begin{definition}[-order]
  \label{def:q-order}
  An \emph{-order} on a -structure  is an
  order  which satisfies the following conditions:
  \begin{conditions}
  \item\label{def:q-order-connected} If  is connected we denote
    by  its -minimal element. Then either
    , or  and the following holds:
    \begin{conditions}
    \item \label{def:q-orders-min-element-is-root}  is a
      -minimal root of , i.e.  and  for all .
    \item \label{def:q-orders-root-q-type} The -type of
      -ordered expansions of  is minimal:
      
      for every  with 
      and every -order  on .
    \item\label{def:q-order-connected-restriction}
       is an -order on
      .
    \end{conditions}
  \item\label{def:q-order-disconnected} If  is not connected, we
    denote its components by  and set
    . Then  is a -order
    if
    \begin{conditions}
    \item each  is a -order of , and
    \item after suitably permuting the components,
      
    \end{conditions}
  \end{conditions}
  The -minimal element of a -order  will be
  denoted by .
\end{definition}

It is plain from the definition above that each structure can be
-ordered. Next we want to show that all -ordered expansions
 of a given structure  have the same -type, and
that the -type of  is also the same
for all -orders  of .

\begin{lemma}
  \label{lem:all-q-orders-are-equivalent}
  Let , . For all
  -orders  of a structure , we have
  
  If  is connected and
  , then also .
\end{lemma}

For the proof, we will need the following composition lemma for
ordered sums, cf.~\cite{Makowsky2004} for a proof.

\begin{lemma}[Composition Lemma]
  \label{lem:ordered-comp-lemma}
  Let ,  and let  be a
  relational signature.  Let ,,,
  be ordered -structures. If 
  
  then
  
\end{lemma}

\begin{proof}[Proof of Lemma~\ref{lem:all-q-orders-are-equivalent}]
  The proof proceeds on the size of . If  then
   and there is nothing to prove.

  Let  and suppose first that  is connected. By
  Definition~\ref{def:q-order},
   and
  
  By symmetry also
  
  so
  
  and, by Lemma~\ref{lem:IndASrtoAS}, .

  Now consider the case where  is not connected, and let
   be the components of .
  By the definition of -orders each  is -ordered, so
  
  for  by what we have just said. Considering the
  way that an -order orders the components of a structure
  according to their -types
  (Part~\ref{def:q-order-disconnected} of
  Definition~\ref{def:q-order}), we obtain that  by repeatedly applying the
  Composition Lemma.
\end{proof}

By Lemma~\ref{lem:all-q-orders-are-equivalent} it makes sense to speak
of the \emph{-order type} of an unordered structure  which we
define as 
If  is connected and , we furthermore define its
\emph{-order root type} as . 
In both cases  is some -order on  and
well-definedness is guaranteed by the Lemma. Note that both these
types are -types. Similarly, the atomic type  of the minimal element in a -ordered expansion of  is 
well-defined.

We set

We say that a sentence  \emph{defines
   on } (and that  is -definable)
if for each , we have

Note that the sentence  must not contain the relation
.

By Lemma~\ref{lem:IndASrtoAS} the atomic type of  and the
-type of  determine the -type of , and
, 
for connected structures  and -orders . Since the
number of atomic -types is , we obtain the following bound on the size of
:

\begin{corollary}
  \label{cor:num-connected-types}
  Let . Then 
\end{corollary}

\subsection{Handling connected structures}

The proof of our main theorem is broken down into two steps. In the first step,
we show how to lift the definability of -types of -ordered structures from
structures of tree-depth  to connected structures of tree-depth .

Again we invoke Lemma~\ref{lem:IndASrtoAS} and
Lemma~\ref{lem:all-q-orders-are-equivalent} to show that -order types can be
broken down into atomic types of roots and -order root types:

\begin{corollary}
  \label{cor:rtp-to-tp}
  Let  and let .  Let
  
  Then for each , we have
  
  iff
  .
\end{corollary}
\begin{proof}
  The ``only-if''-part of the claim is obvious.  Regarding the
  ``if''-part, if 
  
  for some  with ,
  then Lemma~\ref{lem:all-q-orders-are-equivalent} and the definitions
  of  imply that
  .
\end{proof}

\begin{lemma}
  \label{lem:connected-lift}
  Let  with . Let  be one of
   or . If each -type
   is
  -definable on  by a sentence
  , then each -type
   is -definable on
   by a sentence .
  Moreover, defining
  
  we have  and , for a constant  depending only on .
\end{lemma}
\begin{proof}
  In the following, all -types are
  -types.  Let
   and let  be as in
  Corollary~\ref{cor:rtp-to-tp}. We show that, under the assumptions
  of our lemma, the class
   is
  -definable by a sentence  on
  . Taking care of connected structures of
  tree-depth  (i.e. singleton structures) we set
  
  where  defines  on singleton structures.

  For each atomic -type , the following
  -sentence  expresses in a structure
   that :
  
  For each type  the following sentence
  is true in a -structure  if, and only if, there is a root  of
  atomic type  for which  has type , and  is
  -minimal among the types of  for roots  of
  atomic type :
  
  Observe that .
  
  Now we obtain the desired sentence by
  defining .

  Observe that, for some constant  depending only on , , we have
  , , , and  
  .
  The claims about  and  follow from the observations above. 
\end{proof}

\subsection{Handling disconnected structures}

We proceed with the preparations for the second step in the proof of
our main theorem, where we lift the definability of -order types
from connected structures of tree-depth  to disconnected
structures of tree-depth .

For us, a \emph{Boolean query} is an isomorphism-invariant map , where  is the class of all finite structures (i.e. structures
over arbitrary signatures). We will treat maps 
as Boolean queries by assuming that  if  is not a
-structure. The general definition for arbitrary signatures will be
useful in in Section~\ref{sec:mso} below.  We are interested in two kinds of
queries.  As usual, we identify each sentence  with a Boolean query such
that  iff .  Furthermore, we identify each
-order type  with a query such that  iff
. For each structure  and each Boolean query ,
we let  denote the number of components  of  such that
.  For each ordered set  of Boolean
queries, we let .  For
natural numbers  we set

and we extend this relation to tuples  and  by saying
 if, and only if,  for
all components  and .

We show that \FO{} inherits its capability to count the types of
components in -ordered structures from its capability to
distinguish linear orders of different length.  The proof of the
following lemma closely follows a step in the proof of
\cite[Thm. 5.5]{BenediktSegoufin2009}.
Observe that for all , 
 iff 
. 

\begin{lemma}
  \label{lem:cut-determines-type}
  Let ,  and . Then for all , 
  
\end{lemma}
\begin{proof}
  For each component  of , we let  be a
  -order of .
  By Part~\ref{def:q-order-disconnected} of Definition~\ref{def:q-order},
  the -orders on the components of  can be extended to a -order
   on  such that
   for each component  of
  . We proceed analogously to obtain a -order  on
  .  Let ,
  where  and 
  iff .
  We consider words over the alphabet  as structures in the usual way,
  i.e. as ordered structures over a signature containing a unary relation symbol for each type.
  Consider the words  obtained from  and
   by contracting each component  to a single
  element that gets labelled by its -type in the corresponding
  -ordered structure.
  By this construction and by Part \ref{def:q-order-disconnected} of
  Definition~\ref{def:q-order}, we know that 
  
  Since , for each , we have either
   or
  . A folklore result
  (cf. \cite[Ch. 3]{Libkin2004}) tells us that , i.e. Duplicator has a winning strategy in the -round
  EF-game on the two word structures.

  We show that .  To
  this end, consider the following winning strategy for Duplicator in
  the -round EF-game on  and
  . She maintains a \emph{virtual} -round
  EF-game  on  between a \emph{Virtual Spoiler} and
  a \emph{Virtual Duplicator}. When, during the -th round, Spoiler
  chooses an element  in some component  of, say, , she
  lets the Virtual Spoiler play the corresponding position in
   in the -th round of the virtual game. The Virtual
  Duplicator answers in . Duplicator chooses a component
   of  for its reply according to the Virtual Duplicator's
  answer in . The winning strategy on  and 
  ensures that  and
  that all elements of  and  have the same positions in
   and  relative to the elements played in
  the previous rounds. Duplicator uses her winning strategy in the
  -round game on the ordered components to determine the element of
   that she uses as her answer to .
\end{proof}

For a tuple  of natural numbers, denote by  the
tuple obtained from it by replacing all entries  with .  Then
the previous lemma implies that if , then
 determines
. Hence we obtain the following corollary:

\begin{corollary}
  \label{cor:tau-set}
  Let  and let . For each , let
  
  Then for each , we have
  
  Furthermore, .
\end{corollary}

The following lemma will be used in conjunction with the previous corollary to
lift the definability of -types from connected to disconnected structures.
\begin{lemma}
  \label{lem:counting-formulae}
  Let . For all , every
  set of -sen\-tences , and every set
  , there is an -sentence
   such that for each structure  with , we have
  
  Moreover, 
     and
  ,
for a constant  which depends only on .
\end{lemma}
\begin{proof}
  Let .
  Consider some  and let .

  Let . We define a formula , where
  , which states that 
  lie in distinct connected components, each of which satisfies
  :
  
  Observe that  (in particular,
  since  is an existential formula) and that
  ,
  for a constant  depending on  only.

  To obtain a formula which states that either the (pairwise disjoint)
  components of the  are the only components which
  satisfy  or the number of such components is at least ,
  we let
  
  Note that  and
  , for some constant 
  depending on  only. (Note that , so the
  disjunction over  is absorbed by that.) We obtain the desired
  sentence  by setting 
  
  where  is a tuple of  variables. Note that
  \end{proof}

Finally, we can prove our main theorem.

\begin{proof}[Proof of Theorem~\ref{thm:oifo-eq-fo}]
  By induction on the tree-depth , 
  we show that for each signature  and each -sentence  with , there is an -sentence  with  and  such that for each ,
  we have  iff .
  Furthermore, we show that  and .
  To finish the proof, if  is order-invariant, we let , and we obtain that  iff . 

  Let .
  First, for each , we construct a sentence  that
  defines  on . If , observe
  that any \emph{connected} structure  of
  type~ consists of a single element. The atomic -type 
  of this element determines the -type of the unique -order on .
  The -sentence 
  hence defines  on . We obviously have
  , for some absolute
  constant , and  .

  If , we construct an -sentence  inductively for each -type .
  Let . 
  By induction, we obtain , and , and we have .
  We construct  according to Lemma~\ref{lem:connected-lift},
  i.e. we let  for each . Let .
  Then there is a constant  depending only on ,
  such that 
  

  Now consider a sentence .  Let
   be given by Corollary~\ref{cor:tau-set}. We apply
  Lemma~\ref{lem:counting-formulae} with  to obtain a
  sentence .  To see that
   is defined correctly, consider some .  Observe that for each  and each
  component  of , we have  iff
  , and thus .  Then
  
  
  By Lemma~\ref{lem:counting-formulae}, for some constant  depending only on , we
  have
  
  Observe that  by Corollary~\ref{cor:num-connected-types} and that
  . Hence,
  .
  By Corollary~\ref{cor:tau-set}, we also obtain
  .
\end{proof}

\section{Order-invariant monadic second-order logic}
\label{sec:oimso}

\cite[Thm.~4.1]{Courcelle1996} proved that classes of graphs
definable by order-invariant MSO sentences are recognisable. Recognisable sets
of graphs of \emph{bounded tree-width} are conjectured in~\cite[Conjecture
1]{Courcelle1991} to be definable in \MSO{} with modulo-counting (\CMSO{}),
which would imply that  is equivalent to  on these graphs. Note
that it is well-known and easy to see that, regardless of the considered class
of structures, for each sentence of modulo-counting \MSO{} there is an
equivalent \oiMSO{}-sentence. Hence, the difficult part is the construction of
an \CMSO{}-sentence for a given \oiMSO{}-sentence.

While the equivalence of recognisability and definability in \CMSO{} for graphs
of bounded tree-width is still widely considered to be open
(cf.~\cite[p.~574]{CourcelleE2012}), we show that in the further restricted case
of structures of bounded tree-depth,  collapses even to
\emph{first-order} logic with modulo counting (\FOmod{}):

\begin{theorem}
  \label{thm:oimso-eq-fomod}
  For every  and every -sentence  there is an
  -sentence  with 
  which is equivalent to  on .
\end{theorem}

In contrast to the previous sections, we do not analyse the formula size,
because it is known from \cite{GroheSchweikardt05} that (plain) \MSO{} can
define the length of orders non-elementarily more succinct than \FO{}.

For the proof of Theorem~\ref{thm:oimso-eq-fomod}, we proceed similarly to the
last section. Again we need to understand 's capabilities to count the
number of components of a given -type in -ordered structures. However,
this time we need to count not only up to some threshold, but also modulo some
fixed divisor.

For  and , we let  denote the remainder of
the division of  by , and , we
let .
Similarly, we set  if  divides , and extend this notion
to tuples  and  component-wise.

Below, we prove the following Lemma which shows that  inherits its
component counting capabilities in -ordered structures from its
capabilities to distinguish orders of different lengths.

\begin{lemma}
  \label{lem:oimso-cut}
  For each , there is a  such that for all
  -ordered structures  and ,
  
\end{lemma}

In the following, we say that an ordered structure  is
\emph{component ordered}, if the order  is a sum of the
orders on the components of , i.e.  for some enumeration
 of the components of , we have
.  Observe that -ordered structures are
also component ordered.  It will be convenient to have some notation
that allows us to treat component ordered structures similarly to
words. Given two ordered structures  and
, we let ,
where  denotes the disjoint union of  and
 and we consider  as orders on the
components of the disjoint union (via the inclusion mappings for ).  Instead of , we
also write .  Like in the
following definition, we often omit the order to make this notation
less cluttered. For each component ordered structure , we define
its \emph{-th power}  by  and
 if .

The proof of Lemma~\ref{lem:oimso-cut} rests on the following Lemma.

\begin{lemma}[Pumping Lemma]
  \label{lem:pumping-lemma}
  For each , there is a number  such that for
  all component ordered structures  and all , , 
  
\end{lemma}
\begin{proof}
  Let  denote the (finite) set of -types which are
  realised by component ordered -structures.  We lift the
  disjoint union of ordered structures to  by defining
  .  The
  Composition Lemma (Lemma~\ref{lem:ordered-comp-lemma}) shows that
  this operation is well-defined.  It is also associative, so that
   is a finite semigroup.  Hence, there is a
  number  such that for each ,  is
  idempotent (cf. e.g. \cite{Howie1976}), i.e. 
  for each .  Then, for all  as in the
  statement of the lemma, ,
  i.e.  .
\end{proof}

\begin{proof}[Proof of Lemma~\ref{lem:oimso-cut}]
  Let  with
   iff .  For each ,
  fix a connected -ordered structure  whose type is
  .  By repeated application of the
  Composition Lemma, we can assume without loss of generality that
   for each -ordered component  of  or
   with .  Let 
  and let  for each . By
  part~\ref{def:q-order-disconnected} of Definition~\ref{def:q-order},
  we obtain
  
  For each , we have , i.e. there are  and
   such that  and
  . Furthermore, as
  , we have  iff
  .  By repeated application of the Pumping Lemma, we obtain
   Hence, .
\end{proof}

The next lemma is a modulo-counting analogue of
Lemma~\ref{lem:counting-formulae}.

\begin{lemma}
  \label{lem:mod-counting-formulae}
  For all , each set of -sentences
  , and each
  set , there is an
  -sentence  such that for each ,
  
  Furthermore,
  .
\end{lemma}

In contrast to Lemma~\ref{lem:counting-formulae}, the proof of
Lemma~\ref{lem:mod-counting-formulae} is not straightforward, because it is not
obvious how modulo-counting quantifiers can be used to count the number of
components satisfying a given -sentence.  A remedy to this problem is
provided by the following Lemma~\ref{lem:roots}, which shows that the number of
tree-depth roots of each component of a graph (and hence of a structure) can be
bounded in terms of its tree-depth only.

\begin{proof}[Proof of Lemma~\ref{lem:mod-counting-formulae}]  
  Let . For each , let  be given by
  Lemma~\ref{lem:counting-formulae} for , i.e. for each , we have 
  iff .
  Furthermore,
  .  Below, for
  each , ,
  we construct a sentence  such that  iff .  Furthermore,
  .  We
  can then define
  .
  Obviously, .
  
  Consider some ,
  , and let  and .  We define a
  formula , such that , for
   and , iff  belongs to a
  component  of  such that , , and .  Let , let , and let
  1ex]
    \land \ \exists &x_1 \ldots \exists x_k \ \Big( \smashoperator{\bigland_{j\in [k]}} \big(\tilde \tdroot_d(x_j) \land \reach_d(x_j,x) \ \land \ \smashoperator{\bigland_{j,j'\in [k],\, j\neq j'}} x_j \neq x_{j'}\big) \
  Observe that
  
  Let the function  be defined as in Lemma~\ref{lem:roots} and let
  . Let  be such that
  
  Now we define our formula
   as 
   
  Obviously, .

  We show that the formula is defined correctly. Let
  . Recall that, according to
  Lemma~\ref{lem:roots},  for each component
   of .  We partition the set  of components of 
  into pairwise disjoint sets  such that  iff , for each . By
  definition of , the number of elements  such
  that  equals . Hence,  iff for some ,
  we have  for each . This is true iff , since
  
  for  such that 
  for each .
\end{proof}

With these preparations, the proof of Theorem~\ref{thm:oimso-eq-fomod} is very
similar to the proof of Theorem~\ref{thm:oifo-eq-fo}.

\begin{proof}[Proof of Theorem~\ref{thm:oimso-eq-fomod}]
  The proof proceeds by induction on the tree-depth .  We show that for each
  -sentence  with , there is an
  -sentence  such that for each , we have  iff
  .  In particular, if  is order-invariant,
  we let , and we obtain  iff
  .
  
  Let .  We
  construct a sentence  that defines  on
  , for each . If , the type of a
  connected structure of type  is determined by the atomic -type
   of its single element. We let .  If , for each -type , we obtain an -sentence  with
  .
  
  We construct  according to Lemma~\ref{lem:connected-lift},
  i.e. we let  for each . Let .
  Note that . 

  Now consider a sentence .
  Let
   
  where  is given by the Pumping Lemma for .
  We construct  according to Lemma~\ref{lem:mod-counting-formulae}.
  In particular, .
  Consider some .
  Observe that, for each component  of , we have  iff . Hence,
  .
  Thus
   for some structure  with 
  As a consequence of Lemma~\ref{lem:oimso-cut}, this holds iff
  .
\end{proof}

\section{Monadic second-order logic}
\label{sec:mso}

In \cite{ElberfeldGT12} it was proved that each -definable class of
finite graphs of bounded tree-depth is also -definable.  Our approach
towards the results of the previous section can be adapted to obtain another
proof of this result which allows us to give an elementary upper bound on the
size of the -sentence in terms of the quantifier-rank of the
-sentence.  Throughout this section, we assume in all notation whose
definition refers to a logic  that .  We let
 and let
.

\begin{theorem}
  \label{thm:mso-eq-fo}
  Let  and let  be a signature. For each
  -sentence  there is an -sen\-tence  with
   and  that is equivalent
  to  on .
\end{theorem}

We also prove the following theorem in Section~\ref{sec:lower-bounds} below
which shows that the upper bound of Theorem~\ref{thm:mso-eq-fo} is essentially
optimal.

\begin{theorem}
  \label{thm:mso-lower-bound}
  There is a signature  such that for each  there is an
  -sentence  such that each -sentence 
  that is -equivalent to  has size .
\end{theorem}

\subsection{From MSO to FO}

Much of the proof of Theorem~\ref{thm:mso-eq-fo} follows the proof of
Theorem~\ref{thm:oifo-eq-fo}, but we are spared of the complications that arose
in connection with the ordering of structures.  Overall, this makes the proof of
Theorem~\ref{thm:mso-eq-fo} simpler.  On the other hand, the proof of an
analogue to Lemma~\ref{lem:cut-determines-type} becomes somewhat more
complicated.

\paragraph{Counting components}

In Lemma~\ref{lem:cut-determines-type}, we did not use the fact that we consider
only structures of bounded tree-depth. Here naively ignoring the bounded
tree-depth would cause the component counting threshold for -sentences of
quantifier-rank  to depend non-elementarily on . We use the following
lemma to avoid this.

\begin{lemma}
  \label{lem:msocut}
  Let . There is a  such that
  for all structures ,
  
\end{lemma}

Lemma~\ref{lem:msocut} is an easy consequence of the following two lemmas.

\begin{lemma}
  \label{lem:mso-cut-bounded-size}
  Let , , and . Let  be a
  signature. For all structures  whose
  components each contain at most  elements,
  
\end{lemma}

\begin{lemma}
  \label{lem:component-bound}
  Let  and let  be a signature. Each structure
   contains an induced substructure  with
   and . If  is
  connected, there is such a structure  with .
\end{lemma}

Before we prove Lemma~\ref{lem:mso-cut-bounded-size} and
Lemma~\ref{lem:component-bound}, we show how to prove Lemma~\ref{lem:msocut}
with their help. The proof will also use the following variant of a standard
composition lemma, which we take for granted (we use a variant for signatures
with constants, where the constant symbols will be used in the proof of
Lemma~\ref{lem:mso-cut-bounded-size}).

The definition of the disjoint union  of structures  and
 can be extended to signatures with constant symbols, if the constant
symbols of  and  are disjoint.

\begin{lemma}[Composition Lemma]
  Let . Let  be signatures which may
  contain constant symbols, where the constants in  and
   are disjoint. If  are -structures
  and  are -structures such that
   and , then
  
\end{lemma}

\begin{proof}[Proof of Lemma~\ref{lem:msocut}]
  With the help of Lemma~\ref{lem:component-bound} and the Composition
  Lemma, we can assume without loss of generality that  and 
  contain only components of size at most . Let
   as in Lemma~\ref{lem:mso-cut-bounded-size}. Then  and hence the claim follows from
  Lemma~\ref{lem:mso-cut-bounded-size}.
\end{proof}

\begin{proof}[Proof of Lemma~\ref{lem:mso-cut-bounded-size}]
  For the proof, we consider signatures  which contain
  constant symbols. In this case, the components of a
  -structure are not necessarily -structures, because
  they might not contain all constants. Let  denote the
  union of the sets of -types over all signatures . For -structures 
  and , we write  if .

  By induction on , we prove the stronger claim that for each
  signature  \emph{which may contain constant symbols} and all
  -structures  and  whose components each contain at
  most  elements,
   Let
  . Since , there exists a bijection 
  between the sets  of components of  which
  contain constants. Furthermore, this bijection preserves the
  -type of components, i.e. for each component  there
  exists a partial isomorphism  whose domain and codomain are,
  respectively, the set of constants of  and . These
  partial isomorphisms can be extended to a partial isomorphism  of  and  whose domain and
  codomain are, respectively, the set of constants of  and
  . Hence .

  For each , let . Now let . We consider
  the case where  and  contain only components of a single
  -type  over some signature . The
  general case follows by an application of the Composition Lemma. By
  a further application of the Composition Lemma, we can assume that
  all components of  and  are isomorphic to a single
  structure  of type . Now if ,
  then  and  are isomorphic, so we are done. Assume that
  . We show that Duplicator wins the
  -round EF-game on  and .
  
  Consider the first round of the game. Suppose that Spoiler plays a
  point move, i.e. he chooses an element, say, . Duplicator
  chooses an element  corresponding to  in a copy of  in
  . This introduces exactly one component of a new
  isomorphism-type  in each of  and . The
  remaining components of ,  all remain their
  isomorphism-type and there are more than  such
  components. Hence . By
  induction, . So Duplicator wins, if
  she replies by .

  Suppose now that Duplicator plays a set move, say, .
  Since  contains at most  elements, the components of the
  structure  belong to at most  different
  isomorphism-types. Thus the number of -types cannot be greater
  either. For each -type  occurring in , let
   denote the set of components of  whose -type is
  . Duplicator chooses a set  of components of
   and a set of elements  such that , and  for each . Since there are 
  copies of  in , this is possible. Let . We have . So, by induction, . Replying by , Duplicator wins.
\end{proof}

Lemma~\ref{lem:component-bound} is an adaptation of
\cite[Thm. 6.7]{NesetrilMendez2012} from \FO{} to \MSO{}.  Its proof uses the
previous lemma and the following analogue to Lemma~\ref{lem:IndASrtoAS}, which
can be proved like Lemma~\ref{lem:IndASrtoAS}.

\begin{lemma}
  \label{lem:mso-IndASrtoAS}
  Let . Let
   be connected structures with 
  and let ,
  with .
  Then 
\end{lemma}
\begin{proof}[Proof of Lemma~\ref{lem:component-bound}]
  The proof is by induction on the tree-depth .  First, we consider the claim
  about connected structures.  If , then each connected structure with
   has size , i.e. we can set .  Suppose
  now that . Choose a tree-depth root .  By induction,
  since , we obtain an induced substructure  of
   such that  and .  Let  be the substructure of  induced by , i.e. . Since , we
  obtain that  in the same way as in
  Lemma~\ref{lem:IndASrtoAS}. Observe that .

  Consider the case that  is not connected. By the construction
  above, we can replace each component  of  by an induced
  substructure of  on  vertices that has the
  same -type as . By the Composition Lemma, this preserves the
  -type of . Let  denote the maximum
  number of vertices in a component of  after this
  replacement. By Lemma~\ref{lem:mso-cut-bounded-size}, we know that
   for each induced substructure  of 
  such that  for each -type
  , where . Since there are at most 
  non-isomorphic components in  and we have to keep at most 
  copies of each such component, there is such a structure  with
  .
\end{proof}

\paragraph{Finishing the proof}

With the preparations above, the proof of Theorem~\ref{thm:mso-eq-fo} is now
very similar to the proof of Theorem~\ref{thm:oifo-eq-fo}. 

\begin{proof}[Proof of Theorem~\ref{thm:mso-eq-fo}]
  The proof proceeds by induction on the tree-depth , where we also show that
   and . 

  \paragraph{Defining types of connected structures}

  As a first step, we prove that each -type  is
  -equivalent to an -sentence
   such that  and .  For ,
  each structure  of type  consists of a
  single element of some atomic -type . The -sentence
   then defines . Hence
   does not depend on ,
  , and .

  Now suppose that  and let .  Let  be a set that contains
   iff there is a structure  with  which contains a tree-depth root
   such that  and
  .  Observe that, as a consequence of Lemma
  \ref{lem:mso-IndASrtoAS}, for each , we have
   iff  for some .  Now consider a -type 
  and let  be the -sentence, given by
  induction, which is equivalent to  on .  As a consequence of Lemma~\ref{lem:ASrtoAS}, we obtain
  that for all structures  with  and
  all tree-depth roots , we have
   iff .

  Altogether, we obtain that the following -sentence is equivalent to  on :
  
  
  Recall that, by induction, 
  and .  Hence,
  .  Altogether, we obtain that
  .  Using
  Lemma~\ref{lem:mso-IndASrtoAS}, we conclude that
  . By induction, . Hence, .

  \medskip

  \paragraph{Structures with multiple components}
  Consider an -sentence .  Let
  , where
  . Let  be given by
  Lemma~\ref{lem:msocut}.  Let  be the set that contains the
  formulae  for each
  . Hence,  for each .  Let  be a set such that  iff there exists a
  model  of  with
  .  Using
  Lemma~\ref{lem:msocut}, we obtain that  iff
  , for each
  . Hence, the -sentence
   of Lemma~\ref{lem:counting-formulae} is
  equivalent to  on .

  Regarding the size of , note that Lemma~\ref{lem:msocut} implies that
  .
  Since
  
  we obtain that, by the construction of  according to Lemma~\ref{lem:counting-formulae},
  
  and .
\end{proof}

\subsection{A lower bound}
\label{sec:lower-bounds}

The proof of Theorem~\ref{thm:mso-lower-bound} uses an encoding of large natural
numbers  by shallow trees  from \cite[chapter 10.3]{FlumGrohe2004}.
Here, by \emph{trees}, we mean directed trees which are rooted, i.e. trees which
contain a root vertex from which all edges point away.  The encoding is defined
inductively as follows:
\begin{itemize}
\item  is the one-node tree.
\item For , the tree  is obtained by creating a new
  root and attaching to it all trees  such that the -th
  bit in the binary representation of  is .
\end{itemize}
Note that a tree encodes a number with respect to this encoding iff there are no
two distinct isomorphic subtrees whose roots are children of the same
vertex. But we would like to assign a natural number to each tree. To this end,
we reduce each tree  in a bottom-up way to a tree  that encodes
a number:
\begin{itemize}
\item  if , i.e. .
\item If , select one tree  of each
  isomorphism type that occurs among the immediate subtrees of the root of
  . Define  to be a tree whose root has children whose rooted
  subtrees are .  
\end{itemize}
Throughout the following section, we let , where  is a
binary and  are unary relation symbols.  We consider a tree as a
-structure  where  is the edge relation of the tree.  A
\emph{coloured tree} is a finite -structure , where
 is a tree and  (the \emph{red} and the \emph{blue} vertices
of ) form a partition of the vertex set of the tree.  Structures whose
components are (coloured) trees are called (coloured) \emph{forests}.  The
\emph{height}  of a (coloured) tree  is the maximum number of
vertices on a path from the root of  to a leave of .  The
\emph{height}  of a (coloured) forest  is the maximum height
of its components.

From the proof of \cite[Lemma~10.21]{FlumGrohe2004}\footnote{\cite[Lemma~10.21]{FlumGrohe2004}
  makes the assumption that  are encodings of
  numbers  to conclude that , i.e. . If we drop this assumption, we
  obtain our variant of the lemma using exactly the same formula.}, we
obtain the following lemma.

\begin{lemma}
  \label{lem:eq-formula}
  For each , there is an -formula 
  of size  such that for all forests
   with  and all trees  of  with roots
  , respectively, we have:
  
\end{lemma}

Note that  provided that , where .
For each , let  denote a coloured forest that contains exactly the trees  whose vertices all are coloured red, let  denote a
coloured tree with  that contains each of the trees
? as subtrees (e.g. a full -ary
tree) and where all vertices are blue, and let  denote the disjoint
union of  and  disjoint copies of , for each .

\begin{lemma}
  \label{lem:mso-lower-bound-main-lemma}
  For each , there exists an -sentence
   of size  such that  iff .
\end{lemma}
\begin{proof}
  Let  and let  be the
  relativisation of the -formula of Lemma~\ref{lem:eq-formula}
  to a set variable . Let  be an -formula
  which states in a forest  that for each tree  of ,
  the structure induced by  in  is connected, i.e. a tree.
  Let  state that  is a root in the
  subforest induced by .
  We can assume that the size of  and  is independent
  of .
  Now let  be the following sentence:
  
  First we argue that  implies .
  By definition, the red trees contained in  are . Since , we can choose
   pairwise distinct copies  of 
  in . Since all trees 
  occur as subtrees of , for each 
  there is a set  with .  The set  witnesses that .
  
  Now we show that  implies .
  Let  witness that
  . The forest  contains trees
   whose vertices are all red. Hence, and according to the
  choice of  and the choice of , for
  each  there is a
  blue copy  of  in  such that
  . Hence  must contain at least
   copies of , because  induces at most one tree in
  each copy of .
\end{proof}

Using Lemma~\ref{lem:mso-lower-bound-main-lemma}, we can easily finish the proof
of Theorem~\ref{thm:mso-lower-bound}.

\begin{proof}[Proof of Theorem~\ref{thm:mso-lower-bound}]  
  -sentences of quantifier-rank  cannot distinguish 
  from  for each . Hence an -sentence
   that is equivalent to the -sentence  of
  Lemma~\ref{lem:mso-lower-bound-main-lemma} must have quantifier-rank
   and in particular .
\end{proof}

\section{Defining Bounded-Depth Tree-Decompositions in FO}
\label{sec:canondecomp}

For every finite relational signature  and every 
there is a set  of labels such that information
about a -structure  of tree-width at most  may be
encoded into a -labelled tree . This encoding
may be chosen so that the original structure  can be interpreted in
 by an -interpretation. One such encoding is presented in
details in~\cite[Section~11.4]{FlumGrohe2004}.\footnote{That  can
  be -interpreted in  is not proved there but easy to see.}

The question of whether there is an interpretation in the converse
direction, i.e. whether some tree  representing a width-
tree-decomposition of  can be -interpreted in , is still
open. In particular, interpretability of such a decomposition would
imply that recognisability equals -definability for graphs of
bounded tree-width.

In this section we show that for graphs of bounded tree-\emph{depth},
there is even an -interpretation of a bounded-depth
tree-decomposition. Since the interpretation we give here is not
parameterised we obtain a canonical tree-decomposition, though not one
of optimal depth or width. The -interpretation is given by
formulae  and  for every 
such that if  is a -structure of tree-depth at most 
then
\begin{itemize}
\item  defines an equivalence relation  on , 
\item the equivalence classes of  have size bounded by a
  function of ,
\item the relation defined by  is invariant under ,
  i.e. if  and , then
  
\item  defines a rooted tree structure on the quotient structure ,
  in which  is an ancestor of  or vice
  versa whenever  are adjacent in the Gaifman graph of
  .
\end{itemize}
This can be turned into a bounded-depth tree-decomposition in the
usual sense by taking the tree structure on  as the tree
and setting 

as the bag of the node .

The key insight we use is Lemma~\ref{lem:roots} which says that for any fixed
 there are at most  many candidates which may be placed at the root of
a tree-decomposition of  of minimum height. We have already seen at the end
of Section~\ref{sec:background} that there is an -formula
 such that  iff  is such a
candidate. We recursively build a tree-decomposition  of  of
height at most  by placing, in each step, \emph{all} candidate roots into the
root-bag of our tree-decomposition and then recursing on the components of the
remaining graph. Note that even if , not all components of ,
where  is the set of at most  root nodes, necessarily have tree-depth
, so we must be a bit careful which elements we place into the root of the
next level.

We fix a tree-depth  and recursively define \FO-formulae
 for  with the intended meaning that,
in a structure  of tree-depth  with ,
 iff  is on the -th level of the
tree-decomposition, which we denote by : 

Here,  is the free variable of  and  is the free
variable of the formulae used in the restrictions. With the
abbreviations

we define

i.e.  holds iff  and  are in the same connected
component of . We can now define an
equivalence relation on  as follows:

i.e. two elements are equivalent iff they appear on the same level of
our tree-decomposition and are in the same connected component of 
after removing the levels above  and . This is equivalent to
saying that  and  appear in the same node of our
tree-decomposition.

Let  be a formula which expresses
that to elements are adjacent in the Gaifman graph of a structure.
Finally, We define tree edges (directed towards the root) by


\begin{figure}[htb]
\begin{center}
  \resizebox{0.9\textwidth}{!}{\begin{picture}(0,0)\includegraphics{canondecomp2.pdf}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(8129,3871)(-869,7550)
\put(4681,9749){\makebox(0,0)[b]{\smash{{\SetFigFont{14}{16.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(811,9029){\makebox(0,0)[b]{\smash{{\SetFigFont{14}{16.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2836,8984){\makebox(0,0)[b]{\smash{{\SetFigFont{14}{16.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3511,8984){\makebox(0,0)[b]{\smash{{\SetFigFont{14}{16.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6211,9029){\makebox(0,0)[b]{\smash{{\SetFigFont{14}{16.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3196,11144){\makebox(0,0)[b]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2701,9974){\makebox(0,0)[b]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(-809,10874){\makebox(0,0)[rb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(-809,9704){\makebox(0,0)[rb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3196,8894){\makebox(0,0)[b]{\smash{{\SetFigFont{14}{16.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(-854,8714){\makebox(0,0)[b]{\smash{{\SetFigFont{14}{16.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(766,8669){\makebox(0,0)[b]{\smash{{\SetFigFont{14}{16.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(6211,8714){\makebox(0,0)[b]{\smash{{\SetFigFont{14}{16.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2701,7814){\makebox(0,0)[b]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2881,8039){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,.82,0} and  adjacent in Gaifman graph}}}}}
\put(3196,9434){\makebox(0,0)[b]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(-809,7904){\makebox(0,0)[rb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(-719,10604){\makebox(0,0)[lb]{\smash{{\SetFigFont{14}{16.8}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4411,11234){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3196,10289){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3196,9839){\makebox(0,0)[lb]{\smash{{\SetFigFont{12}{14.4}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }
\end{center}
\caption{The canonical tree-decomposition defined in \FO.}
\label{fig:canondecomp}
\end{figure}

\section{Conclusion}
\label{sec:conclusion}

We have investigated the expressive power and the relative
succinctness of different classes of logical formulae on structures of
bounded tree-depth .  In particular, we have shown that, if a class
 of such structures is -definable or
order-invariantly -definable, then it is also
-definable.  For -definable classes, this was already
known. But, in both cases, our approach also shows that the size of
the -sentence which defines  is at most -fold
exponential in the quantifier-rank of a given order-invariant -
or -sentence which defines .  For -formulae,
we have proved that this upper bound on the size of the
-sentence is essentially optimal.  It would be interesting to
know if there is a corresponding lower bound for the result about
order-invariantly -definable classes.

One motivation to consider bounded tree-depth graphs was the role of
these graphs in the theory of sparse graphs which has been outlined in
the book \cite{NesetrilMendez2012}. This link has been exploited in
several results about the algorithmic behaviour of logics on sparse
structures. Can our results on order-invariant -sentences on
bounded tree-depth structures be used to obtain results about such
sentences on more general classes of sparse structures?

An interesting extension of order-invariance is
\emph{addition-invariance} where sentences are not only allowed to use
some linear order but also the graph of the addition operation that is
induced by the embedding of a structure into the natural numbers that
comes with the linear order.  The paper \cite{Schweikardt2010}
obtained a characterisation of the classes of structures which are
addition-invariantly -definable over unary signatures, i.e. on
structures of tree-depth .  Each such class of structures is
definable in , i.e. the extension of 
with nullary predicates , for all positive integers , which
state that the cardinality of a structure is divisible by .  Our
proofs hinge on the composition method and there is no obvious way how
these methods could be extended to addition-invariant formulae.  Does
addition-invariant  have the same expressive power as
 on bounded tree-depth structures?




\
\paragraph{Acknowledgements} 

We want to thank Isolde Adler for bringing the first two authors together with
the third author, and Nicole Schweikardt for her helpful suggestions.

\bibliographystyle{plain}
\bibliography{paper}

\end{document}
