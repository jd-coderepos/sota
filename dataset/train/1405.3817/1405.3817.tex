\documentclass[smallextended]{svjour3}
\smartqed
\usepackage{graphicx}

\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{verbatim}
\usepackage{xspace}
\usepackage{cite}
\usepackage{enumerate}
\usepackage{mathrsfs}
\usepackage[misc]{ifsym}
\usepackage{placeins}

\newenvironment{fact}{Fact}{}

\def\mck{{\sc Edge--Coloring}\xspace}
\def\mco{{\sc Edge--Coloring}\xspace}
\def\mct{{\sc Edge--Coloring}\xspace}
\def\mcpath{{\sc Edge--Coloring(Path)}\xspace}
\def\mctree{{\sc Edge--Coloring(Tree)}\xspace}
\def\mckcol{{\sc Edge--Coloring(-Colorable)}\xspace}
\def\mcclass{{\sc Edge--Coloring(Class)}\xspace}
\newcommand{\mcarg}[1]{{\sc Edge--Coloring(#1)}\xspace}
\def\paths{\text{\sc Path}\xspace}
\def\ceilk{\lceil\sqrt{k}\rceil}


\newcommand{\colorset}{\ensuremath{\operatorname{\mathcal{C}}}\xspace}
\newcommand{\coloring}{\ensuremath{\operatorname{\mathscr{C}}}\xspace}

\newcommand{\ivalue}{\ensuremath{v_{\text{i}}}\xspace}
\newcommand{\fvalue}{\ensuremath{v_{\text{f}}}\xspace}
\newcommand{\surplus}{\ensuremath{v_{+}}\xspace}

\newcommand{\ec}{\ensuremath{E_{+}}\xspace}
\newcommand{\ed}{\ensuremath{E_{+}^{\text{d}}}\xspace}
\newcommand{\er}{\ensuremath{E_{-}}\xspace}
\newcommand{\es}{\ensuremath{E_{+}^{\text{s}}}\xspace}

\def\dc{d_{+}}
\def\dd{d_{+}^{\text{d}}}
\def\dr{d_{-}}
\def\ds{d_{+}^{\text{s}}}

\newcommand{\Ecrit}{\ensuremath{E_{\text{crit}}}\xspace}
\newcommand{\ecrit}{\ensuremath{e_{\text{crit}}}\xspace}

\newcommand{\polvar}{\ensuremath{t}\xspace}

\newcommand{\NF}{\ensuremath{\operatorname{\textsc{Next-Fit}}}\xspace}
\newcommand{\FF}{\ensuremath{\operatorname{\textsc{First-Fit}}}\xspace}
\newcommand{\nf}{\ensuremath{\operatorname{\textsc{NF}}}\xspace}
\newcommand{\ff}{\ensuremath{\operatorname{\textsc{FF}}}\xspace}
\newcommand{\OPT}{\ensuremath{\operatorname{\textsc{Opt}}}\xspace}
\newcommand{\RP}{\ensuremath{\operatorname{\textsc{Rand}}}\xspace}
\newcommand{\ALG}{\ensuremath{\operatorname{\textsc{A}}}\xspace}
\newcommand{\FAIR}{\ensuremath{\operatorname{\textsc{F}}}\xspace}
\newcommand{\DET}{\ensuremath{\operatorname{\textsc{D}}}\xspace}
\newcommand{\RAND}{\ensuremath{\operatorname{\textsc{R}}}\xspace}
\newcommand{\algo}[1]{\ensuremath{\operatorname{\textsc{#1}}}\xspace}

\newcommand{\ab}[1] {\left\vert #1\right\vert}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\DeclareMathOperator{\opt}{OPT}

\DeclareMathOperator{\FFm}{FF}
\DeclareMathOperator{\NFm}{NF}

\DeclareMathOperator{\E}{\mathbb{E}}

\newcommand{\nats}{\ensuremath{\mathbb{N}}\xspace}
\newcommand{\dist}{\ensuremath{\mathcal{P}}\xspace}
\newcommand{\prev}{\ensuremath{\operatorname{prev}}\xspace}
\newcommand{\eis}{\ensuremath{E^{\text{s}}}\xspace}
\newcommand{\eid}{\ensuremath{E^{\text{d}}}\xspace}
\newcommand{\eir}{\ensuremath{E^{\text{r}}}\xspace}
\newcommand{\eic}{\ensuremath{E^{\text{c}}}\xspace}

\usepackage[dvipsnames]{xcolor}
\usepackage{tikz}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{shapes.geometric}

\pgfdeclarelayer{edgelayer}
\pgfdeclarelayer{nodelayer}
\pgfsetlayers{edgelayer,nodelayer,main}

\tikzstyle{none}=[inner sep=0pt]
\definecolor{hexcolor0xffffff}{rgb}{1.000,1.000,1.000}
\definecolor{hexcolor0x000000}{rgb}{0.000,0.000,0.000}
\definecolor{hexcolor0x00ff00}{rgb}{0.000,1.000,0.000}
\definecolor{hexcolor0xffff00}{rgb}{1.000,1.000,0.000}

\tikzstyle{rn}=[circle,fill=hexcolor0xffffff,draw=hexcolor0x000000,line width=0.3 pt, scale=0.3]
\tikzstyle{rn1}=[circle,fill=hexcolor0xffffff,draw=hexcolor0xffffff,line width=0.3 pt, scale=0.3]

\tikzstyle{ed}=[-,draw=hexcolor0x000000,line width=0.700]
\tikzstyle{sed}=[densely dotted,-,draw=hexcolor0x000000,line width=0.700]
\tikzstyle{ned}=[dashed,-,draw=hexcolor0x000000,line width=0.700]



\begin{document}
\journalname{Acta Informatica}

\title{Online Edge Coloring of Paths and Trees with a Fixed Number of Colors \thanks{
A preliminary version of this paper appeared in 12th Workshop on Approximation and Online Algorithms (WAOA 2014), LNCS 8952: 181-192, 2014. \\This work was partially supported by the Villum Foundation and the Danish Council for Independent Research, Natural Sciences.}
}

\author{Lene M. Favrholdt         \and
        Jesper W. Mikkelsen
}

\institute{Lene M. Favrholdt (\Letter) \at
              Department of Mathematics and Computer Science, University of Southern Denmark, \\
Campusvej 55, 5230 Odense M, Denmark\\
Tel.: +45 65 50 23 41      \\
              \email{lenem@imada.sdu.dk}  
           \and
           Jesper W. Mikkelsen \at
              Department of Mathematics and Computer Science, University of Southern Denmark\\
              Campusvej 55, 5230 Odense M, Denmark\\
              \email{jesperwm@imada.sdu.dk}
}

\maketitle

\begin{abstract}
We study a version of online edge coloring, where the goal is to
 color as many edges as possible using only a given number, , of
 available colors.
All of our results are with regard to competitive analysis.
Previous attempts to identify optimal algorithms for this problem
 have failed, even for bipartite graphs.
Thus, in this paper, we analyze even more restricted graph classes,
 paths and trees.
For paths, we consider , and for trees, we consider any .

We prove that a natural greedy algorithm called \FF is optimal among
 deterministic algorithms, on paths as well as trees.
For paths, we give a randomized algorithm, which is optimal and better
 than the best possible deterministic algorithm.
For trees, we prove that to obtain a better competitive ratio than
 \FF, the algorithm would have to be both randomized and
 unfair (i.e., reject  edges that could have been colored), and even
 such algorithms cannot be much better than \FF.
\end{abstract}


\section{Introduction}
In the classical edge coloring problem, the edges of a graph must be
 colored using as {\em few colors} as possible, under the constraint that no
 two adjacent edges receive the same color.
There is a natural dual version of the problem where a fixed number, , of
 colors is given and the goal is to color as {\em many edges} as possible,
 using at most  colors.
Sometimes the classical problem is called the {\em minimization} version and
 the dual problem is called the {\em maximization} version of the problem.

In this paper, we study the following online version of the maximization problem \cite{kedge}: The edges of the graph arrive one by one (in any order), each specified by its endpoints. Immediately upon receiving an edge, the algorithm must either color
 the edge with one of the  colors or reject the edge. 
The decision of which of the  colors to use or to reject the edge
 is irrevocable. 
We call this problem \mck. 
For any class, {\sc Class}, of graphs, we let \mcclass denote the problem
 of \mck restricted to graphs of class {\sc Class}.
For instance, \mcpath is the online problem of properly coloring as many edges
 as possible in a path using only two colors.

\paragraph{Quality measure.}
We measure the quality of an online algorithm, , for \mck using
the standard notion of competitive ratio \cite{CompRatio1,
  CompRatio2}. The competitive ratio compares the performance of
 to that of an optimal offline algorithm, . We denote by
 the number of edges colored by  when given a
sequence, , of edges. Similarly,  is the number
of edges in  colored by . The algorithm  is said
to be \emph{-competitive} if there exists a constant  such that
 for any input sequence
. The \emph{competitive ratio}, , of  is
the supremum over all  for which  is -competitive. 
The competitive ratio of  for \mcclass is denoted by
 .

Note that by this definition, . In particular, upper bounds on the competitive ratio are negative results and lower bounds are positive results.

If the inequality above holds even when , we say that  is \emph{strictly -competitive}. This gives rise to the notion of \emph{strict competitive ratio}. 
The results in this paper are strongest possible in the sense that all positive results hold for the strict competitive ratio and all negative results hold for the competitive ratio.

For randomized algorithms, a similar definition of competitive ratio
is used but  is replaced by the expected value
.


\paragraph{Notation and terminology.}
We label the  colors . For , define . At any fixed point in the processing of the input sequence, we
denote by  the set of colors used at edges incident to the vertex . A color 
is said to be \emph{available} at  if .
Two colorings of a graph are said to be \emph{equivalent} if one can
 be obtained from the other by renaming the colors. 

If  is a vertex in the input graph, we denote by  the number of edges incident to . An \emph{isolated edge}  is an edge such that  at the time when  is revealed.
For any , we let  denote a
 path with  edges labeled such that, for ,  is adjacent to  and .
A \emph{star} with 
edges is the complete bipartite graph .

 
\paragraph{Algorithms.}
An algorithm is called \emph{fair} if it never rejects an edge unless all of the  colors have already been used on adjacent edges.
In \cite{kedge}, the following two fair deterministic algorithms were studied:

\FF (\ff) uses the lowest available color for each edge. It can be viewed as the
natural greedy strategy.

\NF (\nf) remembers the last used color . For each edge, it
uses the first available color in the ordered sequence . For the very first edge, it uses the color .

For \mcpath, we introduce a new family of randomized algorithms:
For ,  is defined as follows.
Whenever an isolated edge is revealed,  uses the color  with
 probability  and the color  with probability . 
All non-isolated edges are colored (with the only remaining color) if
 possible.
Note that  is identical to \FF.

\paragraph{Previous results.}
In \cite{kedge} it is shown that any fair algorithm for \mck has a competitive ratio of at least , and at most  if it is deterministic. The lower bound is tight in the sense that \NF has a competitive ratio of exactly . The competitive ratio of \FF is at most . It remains an open problem whether there is an algorithm with a competitive ratio better than .
It is also shown that no algorithm (even when
allowing randomization) has a competitive ratio better than .

The problem \mckcol is also studied in \cite{kedge}. When the input graph is -colorable, any fair algorithm is shown to have a competitive ratio of at least . Again, the lower bound is tight because \NF has a competitive ratio of . The competitive ratio of \FF is shown to be . An upper bound of  is given for deterministic algorithms in this case. 

We remark that all of the negative results mentioned above hold even if the input graph is bipartite. Thus, contrary to offline edge coloring, the online \mck problem does not appear to be significantly easier when restricted to bipartite graphs.

It is well known that for  (i.e., for the matching problem), the greedy algorithm is an optimal deterministic algorithm with a competitive ratio of .

The {\em relative worst order ratio} \cite{WRdefinition,boyar2007relative} of both the maximization and minimization version of online edge coloring is studied in \cite{kedge2}. For the maximization version, it is shown that \FF and \NF are not (strictly) comparable. This is true even when the input is restricted to bipartite graphs. For the minimization version, \FF is proven better than \NF.

The {\em minimization} version of online edge coloring is studied in
\cite{Bar-Noy}. If an online algorithm never introduces a new color
unless forced to do so, it will never use more than 
different colors on graphs of maximum degree . It is shown in
\cite{Bar-Noy} that no (randomized) online algorithm can do better than this, even
if the input graph is restricted to being a forest.
On any graph, an optimal offline algorithm uses at most 
 colors, and on trees,  colors suffice.
Hence, any algorithm that introduces a new color only when necessary,
 has a competitive ratio of 2, and this is optimal.

 The problem of online {\em vertex} coloring has received much attention in
the minimization version (see 
\cite{kierstead1998coloring} for a survey). 
For interval graphs, it has also been studied in the maximization version:
It follows from a result in~\cite{seatres} that
no deterministic fair algorithm can have a competitive ratio strictly
greater than , even on interval graphs.
In that paper it is also shown that, on -colorable interval graphs,
any fair algorithm has a competitive ratio of at least
. 
In~\cite{seatresTight}, it is shown that for deterministic algorithms,
this lower bound is tight, i.e., any deterministic fair algorithm has
a competitive ratio of exactly  on -colorable interval
graphs.
Since edge coloring is equivalent to vertex coloring of line graphs,
our results and those of~\cite{kedge} and \cite{kedge2} can also
be seen as results on vertex coloring of (subclasses of) line graphs.
In particular, edge coloring a path of
 edges is equivalent to vertex coloring a
path of  vertices.

A study of approximation algorithms for the {\em offline maximization} version of {\em edge} coloring for multigraphs was initiated in \cite{Faprox}. This line of work has been continued in \cite{aprox1, aprox2, aprox3SIDMA, aprox6} for both simple graphs and multigraphs.

\paragraph{Our contribution.}
For \mcpath, we give a -competitive randomized algorithm and
prove that this is optimal. We also show that no deterministic
algorithm can be better than -competitive and observe that
this upper bound is tight, since \FF is -competitive. 
Finally, \NF turns out to be a worst possible fair algorithm with a competitive ratio of .

For \mctree where , we prove that \FF is
-competitive and that no deterministic or fair
algorithm can be better than this.
Thus, an algorithm would have to be both randomized and unfair to
achieve a better competitive ratio than \FF.
However, we show that even such algorithms cannot be better than
-competitive. 
We also show that
any fair algorithm is -competitive
and that the competitive ratio of \NF is no better than this if  is
a square number.
This implies that the competitive ratio of any fair algorithm goes to
 1 as  goes to infinity.

\paths and {\sc Tree} are the first examples of graph classes
for which 
 an optimal deterministic algorithm for \mck has been identified.
\paths is the first graph class for which an optimal randomized
 algorithm has been identified.
It is also the first class for which it has been proven that a
 randomized algorithm can be better than a best possible deterministic
 algorithm.

We remark that all of our results for {\sc path} extend to collections of paths. Similarly, all results for {\sc tree} extend to forests. This is so because our positive results are always for the strict competitive ratio, and because our algorithms will color a single path in a collection of paths exactly as if only the edges of that path had been revealed (similarly for trees).


\section{A Charging Technique for Proving Positive Results}
\label{lowertech}
We will now describe a simple charging technique for proving lower bounds on the competitive ratio. The technique was first used for deterministic algorithms in \cite{kedge}. 
For some , , our goal is to prove that a given
 (possibly randomized) algorithm  is -competitive. 
Assume that the edges of a graph  have been given in some
 order, , and let  be the set of edges colored in some optimal
 solution. 

The \emph{initial value}  of an edge, , is
 e\ALG. 
For deterministic algorithms,  for all .
Note that by
 linearity of expectation, we have . 

The \emph{surplus}  of an edge, , (with respect to ) is 

We let  and  denote the sets of
 edges with positive and negative surplus, respectively.
Clearly, .
For deterministic algorithms,  is exactly those edges in
  that are not colored by the algorithm, and
  is the set of edges colored by the algorithm (assuming
 ).
The total positive surplus  will be redistributed among
 the edges in  according to some strategy. This strategy is
 what needs to be defined when applying the technique. 

The \emph{final value}  of an edge  is the
 total value of  after the redistribution of surplus. 
Since only surplus value is redistributed,  for all . 
Thus, if it can be proven that  for all , then

Thus, it follows that  is (strictly) -competitive.


\section{Coloring of Paths} 
In this section, we study the \mck problem when the input graph is a
path. 
This is only interesting if , since for , any fair algorithm 
colors all edges of any path. In this paper, we consider solely the case where , but we remark that one can use similar techniques to obtain tight bounds on the competitive ratio when . Also, the results for \paths can be extended to graphs of maximum degree .

For \mcpath, our main result is a randomized algorithm with a competitive ratio of  and a proof that this is optimal. Before considering randomized algorithms, we give tight lower and upper bounds on the competitive ratio of deterministic algorithms.

For 2-colorable graphs, the ratios of
 Propositions~\ref{NFlemmapath} and \ref{FFpathlower} both follow
 from~\cite{kedge}.
Clearly, the positive results carry over to paths, but for , the
 graphs used in~\cite{kedge} for the negative results are not connected.
We give simple proofs that the negative results are
 also valid when the graph is a path. 

\begin{proposition} 
\label{NFlemmapath}
For \mcpath, \NF is a worst possible fair algorithm with

\end{proposition}

\begin{proof}
The lower bound for fair algorithms follows, since 
 each rejected edge is adjacent to exactly two colored edges, and each
 colored edge is adjacent to at most two rejected edges.

For the upper bound, consider a path  with  edges.
The adversary first reveals the odd-numbered edges
 in order of increasing indices.
\NF will alternate between the two colors. 
Afterwards, the adversary reveals all the even-numbered edges. These edges must all be rejected by \NF. Thus, the competitive ratio of \NF is at most  which tends to  as  tends to infinity.
\qed
\end{proof}

\begin{proposition}
\label{FFpathlower}
For \mcpath, \FF is an optimal deterministic algorithm with
 
\end{proposition}

\begin{proof}
Since a path is -colorable, the lower bound for \FF follows from a
 result in \cite{kedge} stating that the competitive ratio of \FF is
  for the \mckcol problem.
It also follows from Lemma~\ref{rplower} below, with .

For the upper bound, let  be a deterministic algorithm and let . The adversary first gives  disjoint paths of length two. Call these the \emph{initial paths}. Let  be the set of those initial paths in which both edges have been colored by  and let  be the set of those initial paths in which at least one edge has been rejected. 

In each path in , both colors 1 and 2 are represented.
The adversary reveals an edge connecting the edge with the color  in the path  to the edge with the color  in the path , for . These connecting edges must be rejected by  so the number of colored edges in this component is at most . The adversary also reveals an edge connecting  to , for . Even if all of these connecting edges can be colored, the number of colored edges in this component is at most . 

Finally, if both  and  are non-empty, the adversary connects the two constructed paths by a single edge which may possibly be colored. It follows that the number of colored edges can be at most . Since the total number of edges is , we get an upper bound on the competitive ratio of  which tends to  as  tends to infinity.
\qed\end{proof}

Knowing that no deterministic algorithm can be better than
 -competitive, a natural question to ask is how good a
 randomized algorithm can be. 
To this end, we analyze the family of fair, randomized
 algorithms, , defined in the introduction.

\begin{lemma}
\label{rpupper}
Let . Then,

\end{lemma}

\begin{proof}
The adversary will reveal the edges of a path  with  edges. Consider the following two adversary strategies for doing so:
\begin{enumerate}[(i)]
\item The adversary first reveals all edges  with , followed by all edges  with . Finally, all the remaining edges are revealed.

\item The adversary first reveals all the odd numbered edges and thereafter all the even numbered edges.
\end{enumerate}

If the adversary uses strategy (i), it chooses  such that  divides . Note that each edge  with  has probability  of being colored. It follows that 

If the adversary uses strategy (ii), it makes sure that the number, , of edges in  is odd. Note that each even numbered edge has probability  of being colored. It follows that 



Thus, if , the adversary uses strategy (i) and otherwise it uses strategy (ii). By choosing  sufficiently large, this proves the upper bound.
\qed\end{proof}

\begin{lemma}
\label{rplower}
Let . Then,

\end{lemma}

\begin{proof}
Let  be a path and assume that the edges of  are given to  in some order.
Consider an edge  at the time of its arrival. If two edges adjacent to  have already been revealed, we say that  is a \emph{critical edge}. Denote by  the critical edges of . Note that since  is fair, it will never reject an edge which is not critical.

We let  and apply the charging technique described in Section~\ref{lowertech}. That is, we will define a strategy for distributing the total surplus among the edges of the path such that all edges receive a final value of at least . This will imply that  is -competitive. Note that all non-critical edges have an initial value of  and, hence, a surplus of . Thus, .

Let  be a non-critical edge. Consider the largest connected component  induced by edges from  containing . Let  be the edge in  which was revealed first. We define  to be the length of the shortest path in  containing  and . If  is revealed as an isolated edge, then . We say that  is \emph{odd} if  is odd and that  is \emph{even} if  is even.
The following fact is easily proven by induction on . 

\begin{enumerate}[Fact:]
\item[Fact:] {\em If  is odd, the probability of  being colored with the color  is .\\ If  is even, the probability of  being colored with the color  is .} 
\end{enumerate}

Let  be a critical edge. Denote by  and  the two edges adjacent to . These must both be non-critical and thus must be colored by . The edge  will be colored if and only if  and  are colored with the same color. Note that the random variable denoting the color received by  is independent of the random variable denoting the color received by . We consider two cases:

\paragraph{Case 1:  and  are both odd or both even.} By the fact stated above, the probability of  being colored is . It follows that 
  
Since  and  are non-critical, they both have a surplus of at least . We will transfer a value of  from each of them to the critical edge . Thus, the final value of  is 



\paragraph{Case 2: One of  and  is odd and the other is even.} Without loss of generality, assume that  is odd and that  is even. By the fact stated above, the probability of  being colored is .
Thus,
 
 Since  is even, it must be adjacent to at least one non-critical edge . We transfer a value of  from each of  and  to  and a value of  from  to . Transferring the entire surplus of  from  to  is possible, since  is non-critical and therefore  is the only critical edge adjacent to . 
Thus, the final value of  is 

\qed\end{proof}

Lemmas~\ref{rpupper} and \ref{rplower} immediately imply the following theorem.

\begin{theorem}
\label{rp}
Let . Then,

\end{theorem}

Theorem \ref{rp} shows that, for ,  has a
 competitive ratio of  (where  is the golden ratio). In practice, one might prefer that  is, e.g., a dyadic rational (a rational of the form  for ). It follows from Theorem~\ref{rp} that the competitive ratio of  can be made arbitrarily close to  by choosing a dyadic rational  sufficiently close to the irrational number .

We will now show that  is the best possible competitive ratio of \emph{any} algorithm. In fact, we show that this is true even if the algorithm knows the length of the path in advance (so that only the ordering of the edges is unknown). We will use Yao's minimax principle~\cite{Yao,BE98b}. Informally, this principle allows us to prove an upper bound of  on the achievable \emph{randomized} competitive ratio by exhibiting a probability distribution over permutations of the edges of a path and showing that no \emph{deterministic} algorithm can, in expectation, color more than a fraction of  of the edges of the path.

\begin{theorem}
\label{yao}
If  is a (possibly randomized) algorithm for the problem \mcpath, then
 
\end{theorem}
\begin{proof}
 Let  be a large even integer and consider a path  consisting of  edges. We will define a probability distribution over all permutations of the edges of  by describing a randomized adversary.
 
The adversary reveals the edges of  as follows: First, it reveals  isolated edges  . Afterwards, the adversary picks uniformly at random a set of indices  such that . For each index , the adversary reveals a single edge, , connecting  and  (so that  becomes a subpath of ). 
Let .
For each index , the adversary reveals two edges,  and , connecting  and  (so that  becomes a subpath of ). Note that the resulting path  has  edges.

Let  be any deterministic algorithm, and let  denote the expected number of edges colored by  when the edges of  are revealed as described above. We will show that
  is at most \mbox{}. 
Since by Yao's principle,  (and  can be arbitrarily large), this will complete the proof. 

We first introduce some terminology to describe a coloring produced by .
For any , , we say that  is the \emph{previous} isolated edge of . 
The set of isolated edges is partitioned into the following four sets:
\begin{enumerate}[\eis:]
\item[\eis:] Isolated edges colored with the {\em same} color as the previous isolated edge. 
\item[\eid:] Isolated edges colored {\em differently} from the previous isolated edge. 
\item[\eir:] Isolated edges that are {\em rejected}.
\item[\eic:] Isolated edges that are {\em colored} but whose previous isolated edge is {\em rejected}. 
\end{enumerate}
Clearly, . 

Let  be a random variable denoting the total number of edges rejected by . We will give a lower bound on .
For each isolated edge  with , consider the probability of at least one of  and the edge(s)
connecting  to  being rejected. For each edge in
, the algorithm  makes a rejection with probability
, since it will be forced to do so if
. Conversely, for each edge in , the algorithm 
makes a rejection with probability , since it is forced to
do so if . Also, for each edge in , the algorithm
 makes a rejection with probability . Combining these observations with the linearity of expectation, we get that

Finally, since \OPT can color all  edges of the path, we get that 
 
Since  can be arbitrarily large, this proves the theorem.
\qed\end{proof}

Theorems~\ref{rp} and \ref{yao} together give the following corollary.

\begin{corollary}
For ,  is optimal for \mcpath with\vspace{-1mm}

\end{corollary}


\section{Coloring of Trees}
We will now consider the \mck problem when the input graph is a tree. 
Our main result is a proof that \FF is optimal among deterministic
 as well as fair algorithms. 
We also show that even randomized algorithms that are not fair can
only be slightly better that \FF.
Finally, we show that, for any fixed , \FF has a 
 better competitive ratio than \NF.

First, we give a general upper bound for algorithms that are deterministic and/or fair.

\begin{theorem}
\label{detupper}
If  is a deterministic or fair algorithm and , then 

\end{theorem}
\begin{proof}
The adversary reveals the edges of a tree in  steps, for some large . The set of edges revealed in the th step constitute a star, , with  edges and center vertex . If at least one edge in  is colored, the adversary chooses  for some colored edge  in . Otherwise, it chooses  for an arbitrary edge  in . Note that the adversary is clearly able to identify a colored edge in , if one exists: If \ALG is deterministic, this is trivially true, and if \ALG is fair,  the first  edges of  will be colored. 

The algorithm  may color  edges of . For all other values of , there are two possibilities:
\begin{itemize}
\item  If  colors even a
single edge of , then it can color at most  edges of
.
\item Even if  rejects all edges of , then it can color at most  edges of . 
\end{itemize}
Let  denote the number of stars where \ALG colors no edges.
Then, \ALG colors at most  edges.
On the other hand, in each star, \OPT colors the  edges not incident to other stars, in total  edges. Since  can be arbitrarily large, this shows that the competitive ratio of  is at most .
\qed\end{proof}

Using the charging technique of Section~\ref{lowertech}, we will show that
 Theorem~\ref{detupper} is tight by proving a matching lower bound for \FF.
To this end, we introduce some terminology related to deterministic
 algorithms.

Let  be a deterministic algorithm for \mck, let  be
 a graph, and suppose that  has been given the edges of  in
 some order.
Recall that, since \ALG is deterministic,  denotes the set of
 edges colored by \ALG, and  denotes the set of edges
 colored by \OPT only.
We partition  into the set, \ed, of edges colored by both \ALG
 and \OPT ({\em double colored} edges) and the set, \es, of edges 
 colored by \ALG only ({\em single colored} edges).
Thus, . 
For , let  be the edges in  incident to 
 and let . Define  and  similarly.


\begin{theorem}
\label{fftree}
For , \FF is an optimal deterministic algorithm for \mctree with

\end{theorem}
\def\cmis{\widehat{c}_x}
\def\cmisv{\widehat{c}_v}

\begin{proof}
Fix a tree  and assume that the edges of  have been revealed to \FF in some order. For the analysis, we will view  as a rooted tree by choosing an arbitrary vertex to be the root. When writing , we imply that  is the parent vertex of . 

Following Section~\ref{lowertech}, we set . An edge in  then has a surplus of  and an edge in  has a surplus of . On the other hand, an edge in  has an initial value of zero. 

We will define a strategy to distribute the total positive surplus obtained by \FF among the edges in  such that each edge gets a final value of at least . For ease of presentation, the strategy will be described in a stepwise manner (see Fig.~\ref{surplusfigure} for an illustration of how the strategy works):

\begin{enumerate}[Step 1:]
\item  Consider in turn all edges . Let  be the color assigned to  by \FF and let  be the parent edge of  (if it exists). 
  \begin{enumerate}
  \item If  and  has been colored with a color ,
    then  transfers a value of  to .
  \item Any surplus remaining at  is
    transferred to .
  \end{enumerate}
  For each vertex , let  denote the value transferred
   to  in this step.
\item Consider in turn all vertices . 
  \begin{enumerate}
  \item If the vertex  has a parent edge , then  transfers a
    value of  to . 
  \item Any value remaining at  is distributed equally among the
    child edges of  belonging to .
  \end{enumerate}
  For each edge , let  denote the value transferred from  to  in this step.
\end{enumerate}

\begin{figure}
\begin{tikzpicture}[font=\scriptsize, scale=1.5]

	\begin{pgfonlayer}{nodelayer}

 \node [style=rn1, label={below:}] (le1) at (1,2) {};
 \node [style=rn1, label={below:}] (le2) at (1.6,2) {};
 \draw [style=sed] (le1) to node[label={below:}]{} (le2);

 \node [style=rn1, label={below:}] (le1) at (2,2) {};
 \node [style=rn1, label={below:}] (le2) at (2.6,2) {};
 \draw [style=ed] (le1) to node[label={below:}]{} (le2);


 \node [style=rn1, label={below:}] (le1) at (3,2) {};
 \node [style=rn1, label={below:}] (le2) at (3.6,2) {};
 \draw [style=ned] (le1) to node[label={below:}]{} (le2);

 \node [style=rn1, label={below:\FF coloring}] (la1) at (1,1) {};
\node [style=rn,] (0) at (0, -0) {};
		\node [style=rn] (1) at (0, 1.25) {};
		\node [style=rn] (2) at (1.45, -1) {};
		\node [style=rn] (3) at (0.5, -1) {};
                \node [style=rn] (3a) at (0.5, -2) {};
		\node [style=rn] (4a) at (-0.8, -2) {};
		\node [style=rn] (4b) at (-0.2, -2) {};
                \node [style=rn] (4) at (-0.5, -1) {};
		\node [style=rn] (5) at (-1.45, -1) {};

	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=sed, color=NavyBlue] (0) to node[label={[xshift=-0.13cm, yshift=-0.21cm]}]{}  (1);
		\draw [style=ed, color=BrickRed] (4) to node[label={[xshift=-0.2cm, yshift=-0.21cm]}]{} (0);
		\draw [style=sed, color=Plum] (5) to node[label={[xshift=-0.3cm, yshift=-0.21cm, color=Plum]}]{} (0);
		\draw [style=ned,  ] (3) to node[label={[xshift=-0.13cm, yshift=-0.3cm,color=red]}]{} (0);
		\draw [style=ned,  ] (2) to node[label={[xshift=0.43cm, yshift=-0.3cm,color=red]}]{} (0);

                \draw [style=ed, color=Plum] (4) to node[label={[xshift=-0.2cm, yshift=-0.21cm, color=Plum]}]{} (4a);
                \draw [style=ed, color=NavyBlue] (4) to node[label={[xshift=-0.2cm, yshift=-0.21cm]}]{} (4b);
                \draw [style=ed, color=NavyBlue] (3) to node[label={[xshift=-0.2cm, yshift=-0.21cm]}]{} (3a);
	
	\end{pgfonlayer}

\begin{scope}[shift={(4,0)}]
	\begin{pgfonlayer}{nodelayer}

 \node [style=rn1, label={below:{Surplus of edges}}] (la1) at (1,1) {};
		\node [style=rn, ] (0) at (0, -0) {};
		\node [style=rn,] (1) at (0, 1.25) {};
		\node [style=rn,] (2) at (1.45, -1) {};
		\node [style=rn,] (3) at (0.5, -1) {};
                \node [style=rn,] (3a) at (0.5, -2) {};

		\node [style=rn] (4a) at (-0.8, -2) {};
		\node [style=rn] (4b) at (-0.2, -2) {};
                \node [style=rn,] (4) at (-0.5, -1) {};
		\node [style=rn,] (5) at (-1.45, -1) {};

	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=sed] (0) to node[label={[xshift=-0.13cm, yshift=-0.21cm,color=black]}]{}  (1);
		\draw [style=ed] (4) to node[label={[xshift=-0.2cm, yshift=-0.35cm,color=black]}]{} (0);
		\draw [style=sed] (5) to node[label={[xshift=-0.3cm, yshift=-0.21cm,color=black]}]{} (0);
		\draw [style=ned,  ] (3) to node[label={[xshift=-0.13cm, yshift=-0.3cm,color=black]}]{} (0);
		\draw [style=ned,  ] (2) to node[label={[xshift=0.43cm, yshift=-0.3cm,color=black]}]{} (0);



                \draw [style=ed] (4) to node[label={[xshift=-0.2cm, yshift=-0.45cm,color=black]}]{} (4a);
                \draw [style=ed] (4) to node[label={[xshift=-0.2cm, yshift=-0.45cm,color=black]}]{} (4b);
                \draw [style=ed] (3) to node[label={[xshift=-0.2cm, yshift=-0.45cm,color=black]}]{} (3a);
	
	\end{pgfonlayer}
\end{scope}

\begin{scope}[shift={(0,-4)}]
	\begin{pgfonlayer}{nodelayer}
                \node [style=rn1, label={below:Step 1(a)}] (la1) at (1,1) {};
		\node [style=rn, label={[xshift=0.21cm, yshift=-0.2cm,color=red]}] (0) at (0, -0) {};
		\node [style=rn,] (1) at (0, 1.25) {};
		\node [style=rn,] (2) at (1.45, -1) {};
		\node [style=rn,] (3) at (0.5, -1) {};
                \node [style=rn, label=right:] (3a) at (0.5, -2) {};
		\node [style=rn] (4a) at (-0.8, -2) {};
		\node [style=rn] (4b) at (-0.2, -2) {};
                \node [style=rn,] (4) at (-0.5, -1) {};
		\node [style=rn,] (5) at (-1.45, -1) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=sed] (0) to node[label={[xshift=-0.13cm, yshift=-0.21cm,color=black]}]{}  (1);
		\draw [style=ed] (4) to node[label={[xshift=-0.2cm, yshift=-0.35cm,color=black]}]{} (0);
		\draw [style=sed] (5) to node[label={[xshift=-0.3cm, yshift=-0.21cm,color=black]}]{} (0);

				\draw [style=ned,  ] (3) to node[label={[xshift=-0.13cm, yshift=-0.3cm,color=black]}]{} (0);
		\draw [style=ned,  ] (2) to node[label={[xshift=0.43cm, yshift=-0.3cm,color=black]}]{} (0);

                \draw [style=ed] (4) to node[label={[xshift=-0.2cm, yshift=-0.25cm,color=red]}]{} (4a);
                \draw [style=ed] (4) to node[label={[xshift=-0.2cm, yshift=-0.45cm,color=black]}]{} (4b);
                \draw [style=ed] (3) to node[label={[xshift=-0.2cm, yshift=-0.45cm,color=black]}]{} (3a);
	
	\end{pgfonlayer}
\end{scope}


\begin{scope}[shift={(4,-4)}]
	\begin{pgfonlayer}{nodelayer}
           \node [style=rn1, label={below:Step 1(b)}] (la1) at (1,1) {};
	\node [style=rn, label={[xshift=0.21cm, yshift=-0.2cm,color=red]}] (0) at (0, -0) {};
		\node [style=rn, label={right:{\color{red}}}] (1) at (0, 1.25) {};
		\node [style=rn, label={right:}] (2) at (1.45, -1) {};
		\node [style=rn, label={right:{\color{red}}}] (3) at (0.5, -1) {};
                \node [style=rn, label=right:] (3a) at (0.5, -2) {};
		\node [style=rn] (4a) at (-0.8, -2) {};
		\node [style=rn] (4b) at (-0.2, -2) {};
                \node [style=rn, label={right:{\color{red}}}] (4) at (-0.5, -1) {};
		\node [style=rn, label={right:}] (5) at (-1.45, -1) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=sed] (0) to node[label={[xshift=-0.13cm, yshift=-0.21cm,color=red]}]{}  (1);
		\draw [style=ed] (4) to node[label={[xshift=-0.2cm, yshift=-0.21cm,color=red]}]{} (0);
		\draw [style=sed] (5) to node[label={[xshift=-0.3cm, yshift=-0.21cm,color=red]}]{} (0);

				\draw [style=ned,  ] (3) to node[label={[xshift=-0.13cm, yshift=-0.3cm,color=black]}]{} (0);
		\draw [style=ned,  ] (2) to node[label={[xshift=0.43cm, yshift=-0.3cm,color=black]}]{} (0);

                \draw [style=ed] (4) to node[label={[xshift=-0.2cm, yshift=-0.21cm,color=black]}]{} (4a);
                \draw [style=ed] (4) to node[label={[xshift=-0.2cm, yshift=-0.21cm,color=red]}]{} (4b);
                \draw [style=ed] (3) to node[label={[xshift=-0.2cm, yshift=-0.21cm,color=red]}]{} (3a);
	
	\end{pgfonlayer}
\end{scope}

\begin{scope}[shift={(0,-8)}]
	\begin{pgfonlayer}{nodelayer}
           \node [style=rn1, label={below:Step 2(a)}] (la1) at (1,1) {};
           	\node [style=rn, label={[xshift=0.21cm, yshift=-0.2cm,color=black]}] (0) at (0, -0) {};
		\node [style=rn, label={right:{\color{black}}}] (1) at (0, 1.25) {};
		\node [style=rn, label={right:}] (2) at (1.45, -1) {};
		\node [style=rn, label={right:{\color{red}}}] (3) at (0.5, -1) {};
                \node [style=rn, label=right:] (3a) at (0.5, -2) {};
		\node [style=rn] (4a) at (-0.8, -2) {};
		\node [style=rn] (4b) at (-0.2, -2) {};
                \node [style=rn, label={right:{\color{black}}}] (4) at (-0.5, -1) {};
		\node [style=rn, label={right:}] (5) at (-1.45, -1) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=sed] (0) to node[label={[xshift=-0.13cm, yshift=-0.21cm,color=black]}]{}  (1);
		\draw [style=ed] (4) to node[label={[xshift=-0.2cm, yshift=-0.21cm,color=black]}]{} (0);
		\draw [style=sed] (5) to node[label={[xshift=-0.3cm, yshift=-0.21cm,color=black]}]{} (0);

		\draw [style=ned,] (3) to node[label={[xshift=-0.2cm, yshift=-0.6cm,color=red]}]{} (0);
		\draw [style=ned,  ] (2) to node[label={[xshift=0.43cm, yshift=-0.3cm,color=black]}]{} (0);

                \draw [style=ed] (4) to node[label={[xshift=-0.2cm, yshift=-0.21cm,color=black]}]{} (4a);
                \draw [style=ed] (4) to node[label={[xshift=-0.2cm, yshift=-0.21cm,color=black]}]{} (4b);
                \draw [style=ed] (3) to node[label={[xshift=-0.2cm, yshift=-0.21cm,color=black]}]{} (3a);
	
	\end{pgfonlayer}
\end{scope}

\begin{scope}[shift={(4,-8)}]
	\begin{pgfonlayer}{nodelayer}
           \node [style=rn1, label={below:Step 2(b)}] (la1) at (1,1) {};
		\node [style=rn, label={[xshift=0.21cm, yshift=-0.2cm,color=red]}] (0) at (0, -0) {};
		\node [style=rn, label={right:}] (1) at (0, 1.25) {};
		\node [style=rn, label={right:}] (2) at (1.45, -1) {};
		\node [style=rn, label={right:}] (3) at (0.5, -1) {};
                \node [style=rn, label=right:] (3a) at (0.5, -2) {};
		\node [style=rn] (4a) at (-0.8, -2) {};
		\node [style=rn] (4b) at (-0.2, -2) {};
                \node [style=rn, label={right:}] (4) at (-0.5, -1) {};
		\node [style=rn, label={right:}] (5) at (-1.45, -1) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=sed] (0) to node[label={[xshift=-0.13cm, yshift=-0.21cm,color=black]}]{}  (1);
		\draw [style=ed] (4) to node[label={[xshift=-0.2cm, yshift=-0.21cm,color=black]}]{} (0);
		\draw [style=sed] (5) to node[label={[xshift=-0.3cm, yshift=-0.21cm,color=black]}]{} (0);

		\draw [style=ned,] (3) to node[label={[xshift=-0.2cm, yshift=-0.6cm,color=red]}]{} (0);
		\draw [style=ned,] (2) to node[label={[xshift=0.43cm, yshift=-0.3cm,color=red]}]{} (0);

                \draw [style=ed] (4) to node[label={[xshift=-0.2cm, yshift=-0.21cm,color=black]}]{} (4a);
                \draw [style=ed] (4) to node[label={[xshift=-0.2cm, yshift=-0.21cm,color=black]}]{} (4b);
                \draw [style=ed] (3) to node[label={[xshift=-0.2cm, yshift=-0.21cm,color=black]}]{} (3a);
	
	\end{pgfonlayer}
\end{scope}
\end{tikzpicture}
\caption{Illustration of the steps of the strategy defined in the proof of Theorem~\ref{fftree}. In this example, the number of colors is .}
\label{surplusfigure}
\end{figure}

The following simple but useful properties of the strategy defined
above will be used to prove the theorem.
Each of the four facts gives a lower bound on the value transferred
 from an edge  to its parent vertex, .
Let  denote the color of .
We first state the four facts and then give short proofs.

Let  be the parent edge of  (if it exists). 
If , let  denote the color of .

\begin{enumerate}[Fact 1:]
\item[Fact 1:]
{Assume that . \\
 If ,  does not exist, or , then  contributes
  a value of  to .\\ 
 If , then  contributes a value of at least
   to .
 }
\item[Fact 2:]
{If  or  does not exist, then . 
 } 
\item[Fact 3:]
{Assume that .\\
 If , then  contributes a value of  to
  .
 }
\end{enumerate}

In order to state the next fact, we need to introduce some new
terminology. For , let . That is,  is the
largest color available at  (and  if no colors are
available). If an edge incident to  is colored with a
color , the edge is said to be a \emph{high-colored} edge (with respect to ). There must be exactly  high-colored edges incident to .

\begin{enumerate}[Fact 4:]
\item[Fact 4:]
{Assume that .\\
 If  is high-colored with respect to , then the colored child
  edges of  contribute a total value of at least
   to .
 }
\end{enumerate}

{\em Proof of Fact 1:}
If ,  does not exists, or , then  transfers a value of  to  in Step 1(b). If , then  transfers a value of at most  to  in Step 1(a) and hence  transfers a value of at least  to  in Step 1(b).

{\em 
Proof of Fact 2:}
If , this follows from Fact~1. Otherwise, note that by the definition of \FF, it must hold that . In Step 1, the edges incident to  and  colored with a color in  each transfer a value of at least  to .

{\em Proof of Fact 3:} This follows, since  does not transfer any value to  in Step 1(a).

{\em Proof of Fact 4:}
Since  is high-colored, it follows from the definition of \FF that
 all colors in  are represented at child edges of .
Thus,  has at least  child
 edges with lower colors than the color of .
Since , each of these child edges transfers a value of 
 to  in Step 1(a).

We will combine these facts to show that any edge  gets a final value of at least . 

If , then .
Otherwise, , since \FF is fair.
Hence, Fact~2 implies that . 
Thus,  receives a value of at least  from . 
In particular, we will assume that , since otherwise we are
 done. 
Thus, 

We will now turn to proving that .
This will finish the proof, since it
 means that  gets a final value of
 .

Let  be the parent edge of  (if it exists). The rest of the proof is split into three cases depending on which of the sets , , and  (if any) that contains .

\paragraph{Case 1: .}
Recall that there are  high-colored edges incident to .
Thus,  has at least  high-colored child edges, and at
 least  of them belong to .
By Fact~4,  receives a value of at least  from
 the child edges of each of these at least  edges.
Moreover, by Fact~1, each of the  child edges of 
 belonging to  contributes a value of  to .
Thus, 

Hence, since no value is transferred from  to  in Step 2(a), each child edge of  belonging to  receives a value of at least  from  in Step 2(b).
In particular, 


\paragraph{Case 2:  or  does not exist.}
In this case, since ,  has at least
  high-colored child edges belonging to .
By Fact~4,  receives a value of at least  from
 the child edges of each of these edges.
Note that this value comes solely from child edges of 's
high-colored child edges, not from the high-colored edges
 themselves. 
Therefore, by Fact~3, there is also a contribution of
  from each of 's child edges belonging to .
Finally, there are at least  child edges of  belonging to  (if  exists, there are  such edges, and otherwise there are  such edges). By Fact~1, each of these edges transfers a value of 1 to . Thus, 

Hence, since no value is transferred from  to  in Step 2(a), each
 child edge of  belonging to  receives a value of at least  from  in Step 2(b).
Thus,


\paragraph{Case 3: .}
The only difference to Case 2 is that  has exactly  child
 edges belonging to .
Thus,

Hence, since the value transferred from  to  is smaller than 1,
 each child edge of  belonging to  receives a value larger than
  from .
Thus, again,

\mbox{}\qed\end{proof}

By Theorems~\ref{detupper} and \ref{fftree}, an algorithm for \mctree
 can only be better than \FF, if it is both randomized and unfair.
However, the next result shows that even such algorithms cannot do much better than \FF.

\begin{theorem}
If  is a (possibly randomized) algorithm for \mck and , then
 
\end{theorem}
\begin{proof}
The adversary first reveals the edges of a path , for some large .
Let  be the vertices in the path such that
 , for . 
If , the adversary reveals no more
edges.  
If , then for each , ,
 the adversary reveals  edges constituting a star, , with
 center vertex . 
Let  be the set consisting of the edges of every star  for .

If the adversary only reveals the edges of the path , then  and so . Indeed, \OPT can color all  edges in , since  and so . Assume now that the adversary also reveals the stars. In this case, \OPT rejects all edges of the path and instead colors the  edges of each star. Thus, . Note that each of the edges  is incident to the center vertices of both  and . This implies that . Using the assumption , we get that

Since  can be arbitrarily large, this shows that  cannot be better than -competitive.
\qed\end{proof}

We now show that 
the competitive ratio of any fair algorithm tends to 1 as  tends to infinity.

\begin{theorem}
\label{lowktree}
If  is a fair algorithm, then for any ,

\end{theorem}
\begin{proof}
Assume first that \FAIR is a deterministic algorithm.
Let  be a tree and assume that the edges of  have been revealed to \FAIR in some order. 
For the analysis, we will view  as a rooted tree by choosing an arbitrary vertex to be the root. 
As in the proof of Theorem~\ref{fftree}, we let  imply that  is the parent of .

We will apply the charging technique from Section \ref{lowertech} to show that  is -competitive, where . 
We will use the notation introduced 
just before Theorem~\ref{fftree}.
Recall that all edges in  have an initial value of . Edges in  have a surplus of  and edges in  have a surplus of . Edges in  have an initial value of . The goal is to distribute the surplus from  among the edges in  so that all of them get a final value of at least . To this end, we use the following strategy: 

\begin{enumerate}[Step 1:]
\item  Each edge  transfers its surplus to its
  parent vertex, .\\
 For each vertex , let  denote the value transferred to 
  in this step. 
\item Consider in turn all vertices . 
  \begin{enumerate}
  \item If the vertex  has a parent edge , then  transfers a
    value of  to .
  \item Any value remaining at  is distributed equally among the
    child edges of  belonging to .
  \end{enumerate}
  For each edge , let  denote the value transferred from  to  in this step.
\end{enumerate}
This finishes the description of the strategy. 

Fix an edge . 
In Step 1,  receives .
Thus, in Step 2(a),  receives 
 
from .
We will show that . 
If , this is clearly true.
Thus, we may assume that .
Note that

It follows that we only need to consider the case where , meaning that all of the edges incident to  which have been colored by  have also been colored by \OPT. This implies that the value transferred to  from its colored child edges is  
  
When calculating a lower bound on , we consider four cases.
In each case, we use the following two simple facts.

\begin{enumerate}[Fact 1:]
\item[Fact 1:] .
\item[Fact 2:] .
\end{enumerate}

{\em Proof of Fact 1:}
Note that  is exactly the number of edges incident to  that are colored by \OPT.
Thus, Fact 1 follows trivially, since no algorithm can color more than  edges incident to .

{\em Proof of Fact 2:}
This follows from the fact that the edge  is rejected by the fair algorithm \FAIR.

In what follows, we will rely on the following elementary fact:
Consider a quadratic polynomial  with  and .
If the discriminant , then the polynomial is non-negative.

\paragraph{Case 1: The parent edge of  belongs to .} 
In this case,

Thus, we obtain the following, where the second inequality follows from Fact~2, and the third inequality comes from :

Here, the final inequality (\ref{case1fair}) holds since the numerator of the fraction is a quadratic polynomial in  whose discriminant is zero:
 

\paragraph{Case 2: The parent edge of  belongs to .} 
In this case,

Thus, we obtain the following, where the second inequality follows from Fact~2 and the third inequality comes from :

Here, the final inequality (\ref{case2fair}) holds since the numerator of the fraction is a quadratic polynomial in  whose discriminant is zero: 


\paragraph{Case 3: The parent edge of  belongs to .} 
In this case, we have 
 
Recall that . Thus, if , we are done. Hence, we assume from now on that . By Fact~2, this implies that .
Therefore,  which implies the second to last inequality below. The second inequality below follows from Fact~2 and the third inequality comes from .

Here, 
the final inequality (\ref{case3final}) follows exactly as in Case 2.

\paragraph{Case 4: The parent edge of  does not exist.} 
In this case,
 
Thus,  follows as in Case 3.

\paragraph{Randomized algorithms.}
Assume now that \FAIR is a randomized algorithm.
The above analysis holds for any coloring that \FAIR may produce.
Hence, for any coloring produced by \FAIR, the number of colored edges
 is at least  times the number of edges
 colored by \OPT.
Clearly, this means that the expected number of edges colored by \FAIR
 is at least   times the number of edges
 colored by \OPT.
\qed\end{proof}

We will show that the lower bound of Theorem \ref{lowktree} is essentially tight by providing a matching upper bound on the competitive ratio of \NF when  is a square number. To this end, we will use the following result
 from \cite{kedge}.  
\begin{lemma}[Favrholdt and Nielsen~\cite{kedge}]
If the edges of a graph are colored in such a way that each color is used exactly  or  times for some , then there exists an ordering of the edges such that \NF produces an equivalent coloring.
\label{lmNFlemma}
\end{lemma}

The following corollary follows easily from Lemma \ref{lmNFlemma}.

\begin{corollary}
\label{cor:next-fit}
Consider a graph, , and a coloring, \coloring, of all edges of  using
 at most  colors.
Let  be a graph consisting of  disjoint copies of . 
There exists an ordering of the edges of  such that, for each of
 the  copies of  in , the coloring produced by \NF is
 equivalent to \coloring.
\label{corolNF}
\end{corollary}

\begin{proof}
Let , , \ldots,  denote the  copies of .
Furthermore, let , , \ldots, 
 be the  colorings that can be obtained from \coloring by cyclic
 permutations of the colors .
If, for ,  is assigned the coloring
 , we obtain a coloring of  where all colors are used
 the same number of times.
The result now follows from Lemma~\ref{lmNFlemma}.
\qed\end{proof}

Note that Corollary \ref{corolNF} implies that if  is
some family of graphs and  is closed under disjoint
union, then \NF has the worst possible competitive ratio among fair
algorithms for \mcarg{}. 
This can be seen in the following way:
For any graph, , and any coloring, \coloring, of  produced by a
 fair algorithm, the adversary can do the following:
\begin{itemize}
\item Make  copies of , resulting in a graph .
\item Give the edges of  corresponding to the colored edges of \coloring.
 According to Corollary~\ref{cor:next-fit}, these edges can be given in order, such that the edges of each copy of  receives a coloring equivalent to \coloring.
\item Give the edges of  corresponding to edges that were not colored by \coloring.
 Since \coloring was produced by a fair algorithm, \NF will not be able to color any of these edges.
\end{itemize}
Hence, for any sequence, , of edges and any fair algorithm \FAIR, there is a sequence, , of edges, such that \NF uses just as many colors on  as \FAIR does on , and the optimal number of colors is the same for both sequences.

Even though \text{\sc Tree} is not closed under disjoint union, a forest consisting of  trees may be made into a single tree by revealing  edges connecting the  trees. 
Since this will add at most  to the number of edges colored
by \NF, we may still apply Corollary \ref{corolNF} for the class {\sc Tree}.

\begin{theorem}
\label{upperNFtrees}
For , 

In particular, if  for some integer , then \NF is a worst possible
fair algorithm with

\end{theorem}
\begin{proof}
The lower bound for the case where  is a square number follows from Theorem~\ref{lowktree}. 
For the upper bound, we define a tree  and a subset
 .
We specify a coloring, \coloring, of  with the property that
 each edge in  is adjacent to edges of all  colors.

We first describe  and \coloring.
The tree  contains  \emph{bunches} of stars, for some large . 
Each bunch consists of a set of stars:
\begin{itemize}
\item One {\em large} star with  edges
  colored with .\\
 The center vertex of the large star in bunch , , is
  called .
\item  {\em small} stars, each with  edges
 colored with \,.
\end{itemize}

We now describe .
For each , ,  contains an edge between  and the center vertex of each of the small stars in bunch .
For , there is an edge from  to the center vertex of one of the 
 small stars in the th bunch. 
Note that, after assigning the coloring \coloring to , none of the
 edges in  can be colored.

The adversary will use  disjoint copies, , of
 . 
For each , let  denote the set of edges corresponding to
  and let .
If the edges of  are given
 first, it follows from Corollary~\ref{corolNF} that they can be given
 an order such that the coloring produced by \NF on each  is
 equivalent to \coloring.
Afterwards, no other edges can be colored.

Finally, the  disjoint trees are connected, using  edges
 between vertices that have degree one in the trees.
The resulting tree is called .

Since , we must have  and so the maximum
degree of the graph is . 
Thus, since the graph has no cycles, \OPT colors all edges of the graph.

\NF colors

 edges and rejects  edges. 
Since \OPT colors all edges in the graph, 
  
Thus, 
 
Since  can be arbitrarily large, the result follows.
\qed\end{proof}

Theorem~\ref{upperNFtrees} shows that the bound of Theorem~\ref{lowktree} is tight whenever  is a square number. We will briefly consider the case where  is not a square
number. Any fair algorithm for {\sc Edge--Coloring(Tree)} is just
the greedy matching algorithm. It is observed in several papers that this algorithm is -competitive (for all input graphs) and that no deterministic algorithm can do better, even when the input graph is a tree.  If , but not a square number, then the lower bound from Theorem \ref{lowktree} can be slightly improved by using the fact that  must be an integer. In particular, for , it follows from Theorem~3.1 in~\cite{kedge} that any fair algorithm is -competitive on any class of graphs. Combining this result with Theorem~\ref{detupper} shows that on trees, the competitive ratio of any fair algorithm is exactly .
We show in Theorems~\ref{FAIRk3} and \ref{NFk3} that any fair algorithm for {\sc Edge--Coloring(Tree)} is -competitive, and the competitive ratio of \NF is exactly .
Thus, for , we have completely tight bounds.
For , the difference between our upper and lower bounds is less than  and tends to  as  tends to infinity. Also, we get that \FF has a strictly better competitive ratio than \NF on trees whenever .

\begin{theorem}
\label{FAIRk3}
If  is a fair algorithm, then .
\end{theorem}
\begin{proof}
In order to prove that all fair algorithms are -competitive on trees when , we modify Step~1 of the strategy used in Theorem~\ref{lowktree} for distributing the surplus.  Step~2 is unmodified, but for convenience, we give both steps. Let .
\begin{enumerate}[Step 1:]
\item Each edge  transfers a value of  to its parent vertex, , and a value of  to its child vertex, . Each edge  transfers its surplus of  to its parent vertex, .\\
 For each vertex , let  denote the value transferred to 
  in this step. 
\item Consider in turn all vertices . 
  \begin{enumerate}
  \item If the vertex  has a parent edge , then  transfers a
    value of  to .
  \item Any value remaining at  is distributed equally among the
    child edges of  belonging to .
  \end{enumerate}
  For each edge , let  denote the value transferred from  to  in this step.
\end{enumerate}
This finishes the description of the strategy. 

Fix an edge . We need to show that . First, note that if , then  and we are done. Also, if , then , and again we are done. Thus, we may assume that  and . We now show that  receives a value of at least  in all such cases.

\paragraph{Case 1: .} In this case, , so we just need to show that .
Note that . Thus,  has at least one child edge belonging to .
\begin{itemize} \item {\em Case 1.1: The parent edge of  belongs to .}
  In this case, the parent edge of  contributes a value of  to . 
\begin{itemize}\item {\em Case 1.1.1: .} In this case, , and therefore at least one child edge of  belongs to . It follows that .
\item {\em Case 1.1.2: .} Since  has at least one child edge in , .
\end{itemize}
\item {\em Case 1.2: The parent edge of  belongs to .}
  Since in this case, , it follows that .
  Thus, we have only the following two subcases:
\begin{itemize}\item {\em Case 1.2.1: .} At least one child edge of  must belong to . Thus, .
\item {\em Case 1.2.2: .} Since at least one child edge of  belongs to , .
\end{itemize}
\item {\em Case 1.3: The parent edge of  belongs to .}
  In this case,  has at most two child edges belonging two .
  Furthermore,  has at least two child edges in  and at least one of them belongs to .
  Thus, .

\item {\em Case 1.4:  has no parent edge.} Since , .
\end{itemize}
\paragraph{Case 2: .} In this case, , so  has at least two child edges belonging to . 
Furthermore, .
We show that  in all subcases.
\begin{itemize}
\item {\em Case 2.1: The parent edge of  belongs to .}
\begin{itemize}
\item {\em Case 2.1.1: .} In this case, , and hence .
\item {\em Case 2.1.2: .} In this case, , and hence, .
\item {\em Case 2.1.2: .} Two child edges of  must belong to  and so .
\end{itemize}
\item {\em Case 2.2: The parent edge of  belongs to .}
In this case, . Thus, .

\item {\em Case 2.3: The parent edge of  belongs to .} In this case,  has at least three child edges in , and at least two of them belong to . Moreover,  has at most two child edges belonging to . Thus, .
\item {\em Case 2.4:  has no parent edge.}
  \begin{itemize}
  \item {\em Case 2.4.1: .}
    In this case, .
    Thus, .
  \item {\em Case 2.4.2: .} 
Since , .
  \end{itemize}
\end{itemize}
\qed\end{proof}

We now show that the analysis in Theorem~\ref{FAIRk3} is tight by showing that . This is done by creating an adversary graph which combines the two cases (cases 1.1.2 and 2.1.1) from the proof of Theorem~\ref{FAIRk3} for which the strategy used for distributing the surplus could only guarantee a value of exactly .

\begin{theorem}
\label{NFk3}
 .
\end{theorem}
\begin{proof}
The lower bound follows from Theorem~\ref{FAIRk3}.
For the upper bound, let  be an integer divisible by . 
The adversary graph for  is illustrated in Fig.~\ref{fig:nfk3}.
The adversary first reveals  isolated edges (shown as the top vertical edges in Fig.~\ref{fig:nfk3}). 
For , denote by  the subset of these  edges colored with the color  by \NF. Then, the adversary reveals a path  consisting of  new edges, revealing the edges from left to right. An \emph{inner vertex} of  is a vertex of degree . For each inner vertex  of , the adversary reveals four edges . Note that \NF colors  with the unique color  at  and rejects the other three edges. The adversary then reveals an edge  which is colored with the color  by \NF. Finally, the adversary picks two distinct isolated edges  and reveals two new edges  and . \NF rejects both of these edges. The adversary continues with the next inner vertex (unless  was the last inner vertex) and repeats the above procedure. Note that for each , there are  inner vertices on the path for which . Thus, the adversary does not run out of edges to pick from  (in fact, it uses all  of them). This finishes the description of the adversary strategy. 

\begin{figure}
\centering
\begin{tikzpicture}
	\begin{pgfonlayer}{nodelayer}
		\node [style=rn] (0) at (-2, -0) {};
		\node [style=rn] (1) at (-4, -0) {};
		\node [style=rn] (2) at (-2, 1) {};
		\node [style=rn] (3) at (-3, 1) {};
		\node [style=rn] (4) at (-2.5, 2) {};
		\node [style=rn] (5) at (-1.5, 2) {};
		\node [style=rn] (6) at (-2.5, 3) {};
		\node [style=rn] (7) at (-1.5, 3) {};
		\node [style=rn] (8) at (-2, -1) {};
		\node [style=rn] (9) at (-2.5, -1) {};
		\node [style=rn] (10) at (-1.5, -1) {};
		\node [style=rn, label={above right:}] (11) at (0, -0) {};
		\node [style=rn, label={below:}] (12) at (0, -1) {};
		\node [style=rn, label={below:}] (13) at (-0.5, -1) {};
		\node [style=rn, label={left:}] (14) at (-1, 1) {};
		\node [style=rn, label={below:}] (15) at (0.5, -1) {};
		\node [style=rn, label={right:}] (16) at (0, 1) {};
		\node [style=rn, label={right:}] (17) at (0.5, 2) {};
		\node [style=rn, label={left:}] (18) at (-0.5, 2) {};
		\node [style=rn, label={left:}] (19) at (-0.5, 3) {};
		\node [style=rn, label={right:}] (20) at (0.5, 3) {};
		\node [style=rn] (21) at (2.5, -1) {};
		\node [style=rn] (22) at (1.5, 2) {};
		\node [style=rn] (23) at (2.5, 3) {};
		\node [style=rn] (24) at (2, 0) {};
		\node [style=rn] (25) at (2, -1) {};
		\node [style=rn] (26) at (1, 1) {};
		\node [style=rn] (27) at (2, 1) {};
		\node [style=rn] (28) at (1.5, -1) {};
		\node [style=rn] (29) at (2.5, 2) {};
		\node [style=rn] (30) at (1.5, 3) {};
		\node [style=rn] (31) at (4, -0) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=ed] (0) to (2);
		\draw [style=ed] (2) to (3);
		\draw [style=ed] (1) to node[label={below:}]{} (0);
		\draw [style=ed] (0) to node[label={below:}]{} (11);
		\draw [style=ed] (11) to node[label={below:}]{} (24);
		\draw [style=ed] (24) to node[label={below:}]{} (31);
		\draw [style=ed] (6) to (4);
		\draw [style=ed] (5) to (7);
		\draw [style=ed] (19) to (18);
		\draw [style=ed] (17) to (20);
		\draw [style=ed] (30) to (22);
		\draw [style=ed] (29) to (23);
		\draw [style=ned] (2) to (4);
		\draw [style=ned] (2) to (5);
		\draw [style=ned] (0) to (9);
		\draw [style=ned] (0) to (8);
		\draw [style=ned] (0) to (10);
		\draw [style=ned] (11) to (13);
		\draw [style=ned] (11) to (12);
		\draw [style=ned] (11) to (15);
		\draw [style=ned] (24) to (28);
		\draw [style=ned] (24) to (25);
		\draw [style=ned] (24) to (21);
		\draw [style=ned] (27) to (22);
		\draw [style=ned] (27) to (29);
		\draw [style=ned] (16) to (18);
		\draw [style=ned] (16) to (17);
		\draw [style=ed] (24) to (27);
		\draw [style=ed] (27) to (26);
		\draw [style=ed] (11) to (16);
		\draw [style=ed] (16) to (14);
	\end{pgfonlayer}
\end{tikzpicture}
\caption{The adversary graph used in the proof of Theorem~\ref{NFk3} when . Solid edges are colored by \NF and dashed edges are rejected by \NF.}
\label{fig:nfk3}
\end{figure}

\NF colors the  isolated edges, the  edges of the path , and for each inner vertex  it colors  and . Thus, . On the other hand,  
rejects all edges of the path . Furthermore, for each inner vertex ,  rejects .
The remaining edges form a graph with maximum degree  and hence, \OPT can color all of these  edges.
It follows that . This shows that  cannot be better than -competitive.
\qed\end{proof}


\section{Open Problems}
Finding optimal online algorithms for \mck in general and on other classes of graphs is an interesting open problem. We believe that the techniques used in the proofs of Theorems~\ref{fftree} and \ref{lowktree} can be generalized to, e.g., graphs of bounded degeneracy. In particular, graphs of bounded degeneracy can be oriented so that each vertex has bounded outdegree and the resulting digraph is acyclic. This makes it possible to use strategies for redistributing the surplus similar to the ones we have used for trees.

Deciding whether there is an algorithm better than \FF on trees would
also be interesting.
Such an algorithm could only be significantly better for small values
of , and it would have to be both randomized and unfair.

\paragraph*{Acknowledgment.}
~The authors would like to thank the anonymous reviewers for helpful comments on this work and its presentation.


\bibliographystyle{plain}
\bibliography{refs}

\end{document}
