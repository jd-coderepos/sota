


\documentclass[10pt,francais]{llncs}
\usepackage[a4paper]{geometry}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{aeguill}

\usepackage[frenchb]{babel} \usepackage{multirow}
\usepackage{mathrsfs}
\usepackage{color}
\usepackage{theorem}
\usepackage[french,vlined,ruled]{algorithm2e}
\usepackage{amssymb}

\setlength{\algomargin}{0cm}

\newtheorem{rem}{Remarque}
\newtheorem{prop}{Propri\'et\'e}
\newtheorem{defs}{D\'efinition}
\newtheorem{thm}{Th\'eor\`eme}

\newenvironment{engabstract}{\list{}{\advance\topsep by0.35cm\relax\small
      \leftmargin=1cm
      \labelwidth=0pt
      \listparindent=0pt
      \itemindent\listparindent
      \rightmargin\leftmargin}\item[\hskip\labelsep
                                    \bfseries Abstract]}
    {\endlist}


\pagestyle{plain}

\title{RAPPORT DE RECHERCHE LIPN\\
~\\
Le probl\`eme du plus court chemin contraint}
\author{Olivier Laval\inst{1} \and Sophie Toulouse\inst{1} \and Anass Nagih\inst{2}}
\institute{LIPN, Universit\'e de Paris-Nord\\ 99 avenue Jean-Baptiste Cl\'ement 93430 Villetaneuse, France\\ \email{\{olivier.laval,sophie.toulouse\}@lipn.univ-paris13.fr}
\and LITA, Universit\'e Paul Verlaine\\ Ile du Saulcy 57045 Metz Cedex 01, France\\
\email{anass.nagih@univ-metz.fr}
}



\begin{document}
\date{21 d\'ecembre 2006}
\thispagestyle{plain}
\maketitle
\begin{center}
26 d\'ecembre 2006
\end{center}

\begin{abstract}
Cet article propose un tour d'horizon des m\'ethodes approch\'ees et exactes, de leur performance et de leur complexit\'e th\'eorique, pour diff\'erentes versions du probl\`eme de plus court chemin. L'\'etude propos\'ee est faite dans l'optique d'am\'eliorer la r\'esolution d'un probl\`eme plus g\'en\'eral de couverture dans le cadre d'un sch\'ema de g\'en\'eration de colonnes, dont le plus court chemin appara\^it comme le sous-probl\`eme. 
\end{abstract}

\begin{engabstract}
This article provides an overview of the performance and the theoretical complexity of approximate and exact methods for various versions of the shortest path problem. The proposed study aims to improve the resolution of a more general covering problem within a column generation scheme in which the shortest path problem is the sub-problem.
\end{engabstract}

\section{Introduction}\label{sec-intro}
Un probl\`eme des plus courants en optimisation combinatoire est celui de la recherche de plus courts chemins dans un graphe. Ce probl\`eme se pr\'esente comme suit~: \'etant donn\'e un graphe et une fonction co\^ut sur les arcs, le probl\`eme consiste \`a trouver le chemin le moins co\^uteux d'un sommet choisi \`a un autre. Il se r\'esoud ais\'ement gr\^ace \`a de nombreux algorithmes polynomiaux  (Bellman \cite{Bellman1958}, Dijkstra \cite{Dijkstra1959}, ...). N\'eanmoins, l'ajout de contraintes sur le chemin (essentiellement, des contraintes de type ``sac-\`a-dos'') le rend plus difficile \`a r\'esoudre. Ce rapport de recherche pr\'esente donc diff\'erents algorithmes exacts ou approch\'es pour r\'esoudre le probl\`eme du Plus Court Chemin Contraint (not\'e PCCC par la suite). Ce travail se place dans le cadre plus g\'en\'eral de r\'esolution d'un probl\`eme de couverture de t\^aches par des v\'ehicules qui doivent respecter certaines contraintes dont le PCCC est, dans une d\'ecomposition classique  de type Dantzig Wolfe, le sous-probl\`eme. Aussi, les r\'esultats propos\'es seront le plus souvent compar\'es dans le cadre du d\'eroulement de tels sch\'emas. 
Ce document est organis\'e comme suit~: la deuxi\`eme section pr\'esentera le probl\`eme PCCC de mani\`ere tr\`es g\'en\'erale, avec ses diff\'erentes variantes. Plusieurs m\'ethodes de r\'eduction des instances, qui constituent une \'etape pr\'eliminaire \`a la r\'esolution du probl\`eme, sont expos\'ees dans la troisi\`eme section. La r\'esolution exacte sera abord\'ee dans la quatri\`eme section. Enfin, puisque le probl\`eme est -difficile, la cinqui\`eme section portera sur sa r\'esolution approch\'ee.

\section{Description du probl\`eme}\label{sec-desc}
\subsection{Formalisation}\label{sub-desc-form} 
Soit  un graphe orient\'e o\`u  est l'ensemble des sommets () et  l'ensemble des arcs () et soit  un ensemble de ressources (). \`A chaque arc  sont associ\'es un co\^ut  et un vecteur de consommation de ressource  positif (). Le graphe ne doit pas comporter de cycle absorbant\footnote{Un cycle absorbant est un cycle dont la somme des valuations des arcs est n\'egative.}.\\

Un chemin  entre deux sommets  et  est une s\'equence d'arcs : 

La longueur de ce chemin est alors . Un chemin  allant du sommet  au sommet  a un co\^ut dont la formule est .\\
Soient  et  deux sommets distincts privil\'egi\'es du graphe, appel\'es respectivement source et puits. Le probl\`eme du Plus Court Chemin Contraint (PCCC) consiste alors \`a trouver un chemin de co\^ut minimal entre la source et le puits satisfaisant certaines contraintes de ressource (ces contraintes seront d\'etaill\'ees par la suite). Si l'ensemble  des ressources est vide (), on est ramen\'e au probl\`eme usuel de plus court chemin qui est polynomial (\cite{Bellman1958}, \cite{Dijkstra1959}). En revanche, la consid\'eration d'une seule ressource rend d\'ej\`a le probl\`eme d'optimisation -dur, et ce m\^eme lorsque les co\^uts et les consommations de ressource sont suppos\'es \^{e}tre entiers positifs \cite{Garey1979} \cite{Dror1994}. Enfin, le probl\`eme consistant \`a d\'ecider seulement s'il existe ou non un chemin r\'ealisable est -complet d\`es lors que l'on consid\`ere deux ressources ou plus.

\subsection{Contraintes de ressource}\label{sub-desc-contrainte}
Les contraintes de ressource s'expriment \`a l'aide d'un vecteur consommation de ressource  d\'ependant du chemin consid\'er\'e dont chaque coordonn\'ee repr\'esente une ressource du probl\`eme.

Deux types de contraintes de ressource sont usuellement consid\'er\'es. Tout d'abord, les contraintes de ressource dites {\em finales}, o\`u la somme sur tous les arcs du chemin de la source au puits des quantit\'es de ressource consomm\'ees doit entrer dans une fen\^etre d\'efinie au puits~; ensuite, les contraintes de ressource dites {\em \`a fen\^etres de temps} o\`u, \`a chaque sommet , sont associ\'ees  fen\^etres de ressource , , r\'eduisant l'intervalle des valeurs possibles pour la quantit\'e de ressource~ pouvant \^etre utilis\'ee avant d'atteindre le sommet~. Pour ce type de contrainte, il existe deux m\'ethodes de calcul du vecteur consommation de ressource sur un chemin de la source \`a un sommet :
\begin{itemize}
\item sans attente permise : 
		
\item avec attente : 
		
\end{itemize}
Un chemin de la source au puits est dit r\'ealisable si, en chacun de ses sommets, le vecteur consommation de ressource sur le sous-chemin de  \`a ce sommet est dans la fen\^etre de ressource de ce sommet~; formellement~:


De cette in\'egalit\'e d\'ecoule deux propri\'et\'es g\'en\'erales :
\begin{itemize}
 \item dans les deux m\'ethodes (avec ou sans attente) :

 \item dans la m\'ethode sans attente permise :

\end{itemize}
Les arcs ne v\'erifiant pas ces in\'egalit\'es peuvent \^etre directement supprim\'es car ils n'appartiennent \`a aucune solution r\'ealisable du probl\`eme.

Le premier type de contrainte se ram\`ene ais\'ement au second en attribuant \`a tous les sommets du graphe et pour chaque ressource la fen\^etre , o\`u   est le majorant de consommation d\'efinie au puits pour cette ressource. Toutes les instances consid\'er\'ees dans ce document seront donc, sans mention expresse du contraire, du second type. 

\subsection{Relation avec la g\'en\'eration de colonnes}\label{sub-desc-gc} Dans certaines mod\'elisations de probl\`emes lin\'eaires en nombres entiers dites \`a formulation \og chemins \fg{}, les variables du probl\`eme repr\'esentent des chemins du graphe. Le nombre de chemins dans un graphe \'etant potentiellement exponentiel, il en est de m\^eme du nombre de variables. L'utilisation d'un algorithme de r\'esolution (simplexe par exemple) ne peut \^etre envisag\'ee pour ce mod\`ele puisque ce dernier ne peut \^etre explicit\'e. En revanche, un probl\`eme avec un sous-ensemble de variables de taille raisonnable, appel\'e probl\`eme ma\^itre restreint (PMR), peut \^etre r\'esolu~; la r\'esolution de ce dernier permet de calculer les co\^uts r\'eduits associ\'es \`a chaque arc du graphe, que l'on peut interpr\'eter comme le co\^ut d'opportunit\'e \`a emprunter un arc donn\'e (par le biais d'un chemin utilisant cet arc). La variable pouvant \^etre ajout\'ee au PMR est alors trouv\'ee par r\'esolution du sous-probl\`eme qui consiste en la d\'etermination d'un plus court chemin contraint pour le crit\`ere de co\^ut r\'eduit. Par exemple, dans le cas d'une minimisation, si le co\^ut r\'eduit total d'un chemin est n\'egatif, il est potentiellement am\'eliorant pour le probl\`eme ma\^itre et constitue ainsi un bon candidat \`a \^etre int\'egr\'e au PMR. Dans cette approche appel\'ee {\em g\'en\'eration de colonnes}, l'optimalit\'e est atteinte lorsqu'il n'existe plus de chemin am\'eliorant (chemin de co\^ut r\'eduit n\'egatif si l'on consid\`ere la r\'esolution continue du probl\`eme ma\^{\i}tre). Notons que, pour la convergence, il n'est pas n\'ecessaire de trouver un chemin optimal : un chemin am\'eliorant suffit. De plus, \`a chaque it\'eration, plusieurs chemins am\'eliorants peuvent venir enrichir le PMR. \\
Le probl\`eme de plus court chemin contraint \'etant -difficile, le temps de r\'esolution des sous-probl\`emes n'est pas ma\^itris\'e~; d'o\`u l'int\'er\^et d'utiliser des algorithmes d'approximation, du moins en d\'ebut de sch\'ema, nous permettant de trouver rapidement des chemins am\'eliorants (la r\'solution exacte demeurant in\'evitable en fin de sch\'ema pour prouver l'optimalit\'e). 


\section{R\'eduction du probl\`eme avant sa r\'esolution}\label{sec-reduc}
Quelques travaux pr\'ec\'edant la r\'esolution peuvent \^etre effectu\'es dans le but de r\'eduire le graphe (suppression de sommets ou d'arcs, r\'eduction de l'amplitude des fen\^etres de temps). En outre, ces traitements permettent parfois de d\'etecter les instances non r\'ealisables ({\em i.e.}, instances sur lesquelles tout chemin viole les contraintes de ressource) et d'exhiber un majorant et un minorant.

\subsection{R\'eduction des fen\^etres de temps}\label{sub-reduc-reduc}
Les deux types de contraintes de ressource forment en fait une seule classe de probl\`emes o\`u chaque sommet poss\`ede des fen\^etres de temps. En chaque sommet, les bornes des fen\^etres de temps pour chaque ressource doivent v\'erifier quelques relations d\'ependant de ses pr\'ed\'ecesseurs et de ses successeurs. L'ensemble des pr\'ed\'ecesseurs de  se notera , l'ensemble des ses successeurs . Ainsi, pour une ressource donn\'ee , le minorant d'une fen\^etre du sommet  ne doit pas \^etre plus petit que le minorant d'un pr\'ed\'ecesseur  du sommet auquel le temps de trajet entre les sommets  et  est ajout\'e. Cela donne l'\'equation suivante~:

Une \'equation similaire est valable pour les majorants~:

Maintenant, en consid\'erant les successeurs, le minorant d'un sommet  ne doit pas \^etre plus petit que le minorant d'un successeur  du sommet auquel le temps de trajet de  \`a  est soustrait. Cela donne l'\'equation suivante~:

Une nouvelle \'equation similaire est valable pour les majorants~:

Si, pour un sommet  et une ressource , la condition  est remplie, alors le sommet  doit \^etre supprim\'e du graphe (car il est inaccessible), ainsi que tous ses arcs incidents. De m\^eme, dans le cas o\`u l'attente n'est pas permise, s'il existe un arc  tel que , alors l'arc  peut \^etre supprim\'e.\\

\begin{algorithm}\label{algo-reduction}
\caption{REDUCTION~: R\'eduction des fen\^etres de temps (graphe acyclique)}
\Entree{\\
 et  la fen\^etre de la ressource  pour le sommet ~; les sommets sont num\'erot\'es dans l'ordre topologique}
\BlankLine
\Sortie{\\
 un sous-graphe partiel de  avec les fen\^etres de ressource r\'eduites}
\BlankLine
{}\;
\Repeter{}{
  \;
  \Pour{ allant de  \`a }{
    \Pour{ allant de  \`a }{
      \;
      \PourTous{}{
        \;
        \;
      }
      \lSi{}{}\;
      \lSi{}{}\;
    }
  }
  \Pour{ allant de  \`a }{
    \Pour{ allant de  \`a }{
      \;
      \PourTous{}{
        \;
        \;
      }
      \lSi{}{}\;
      \lSi{}{}\;
    }
  }
  \Si{attente non permise et }{
    \;
    \;
  }
  \Si{}{
    \;
    \;

    \;
  }
}
\end{algorithm}

L'algorithme~\ref{algo-reduction} v\'erifie donc les \'equations pr\'ec\'edentes pour chaque sommet. Dans le cas d'un graphe acyclique, il suffit de traiter les sommets dans l'ordre topologique pour les \'equations utilisant les pr\'edecesseurs, puis dans l'ordre inverse pour les \'equations concernant les successeurs. La proc\'edure recommence si et seulement si un sommet ou un arc peut \^etre supprim\'e. La complexit\'e de cette proc\'edure est donc en . Dans le cas cyclique, rien ne garantit qu'aucune fen\^etre ne pourra encore changer apr\`es l'application de la proc\'edure, et ce m\^eme si celle-ci n'induit pas de suppression de sommets ou d'arcs. La proc\'edure pr\'ec\'edente est donc r\'ep\'et\'ee tant qu'une borne change ou qu'un sommet ou un arc est \'elimin\'e. Pour cet algorithme, la complexit\'e en temps de la boucle \textit{r\'ep\'eter} est en . Une premi\`ere approximation na\"ive du nombre de fois o\`u cette boucle est effectu\'ee dans le cas de fen\^etres enti\`eres est  (r\'eduction d'au moins une unit\'e de la fen\^etre pour un sommet \`a chaque it\'eration). La complexit\'e totale est donc .


\subsection{Pr\'etraitement pour contraintes de ressource finales}\label{sub-reduc-final}
Le but de cette proc\'edure de pr\'etraitement, pr\'esent\'ee dans \cite{Aneja1983} et am\'elior\'ee dans\cite{Dumitrescu2003} est, comme pr\'ec\'edemment, de r\'eduire le graphe mais en plus de fournir un minorant et un majorant pour la valeur du probl\`eme. Elle exploite le fait suivant~: trouver le plus court chemin non contraint entre deux sommets a la m\^eme complexit\'e (et prend aussi le m\^eme temps de calcul) que trouver le plus court chemin entre un sommet et {\em tous} les autres (ou {\em tous les autres} et {\em un} sommet). Les plus courts chemins suivant chaque m\'etrique (co\^ut ou ressource) sont donc calcul\'es entre la source et tous les sommets, ainsi qu'entre tous les sommets et le puits. Ensuite, en recombinant ces plus courts chemins, certains peu co\^uteux mais non r\'ealisables peuvent \^etre d\'etect\'es, ce qui permet d'am\'eliorer le minorant~; inversement,  des solutions r\'ealisables peuvent \^etre exhib\'ees, ce qui fournit un majorant au probl\`eme. Enfin, ce traitement permet d'\'elaguer le graphe en d\'eterminant des arcs et des sommets qui n'appartiennent \`a aucun chemin r\'ealisable ou qui n'appartiennent \`a aucun chemin optimal.\\

\noindent Le d\'eroulement de l'algorithme est le suivant~:
\begin{itemize}
 \item Tout d'abord, les chemins les moins co\^uteux de la source \`a tous les sommets sont calcul\'es. Cela permet \'eventuellement de d\'etecter des instances non r\'ealisables (absence de chemin de la source au puits) ou d'exhiber un chemin optimal (un plus court chemin de la source au puits v\'erifie les contraintes de ressource) ou encore, d'exhiber un chemin non r\'ealisable de co\^ut minimum permettant de mettre \`a jour le minorant pour le probl\`eme.
 \item Ensuite, pour chaque ressource, les chemins les moins consommateurs de cette ressource allant de la source \`a chaque sommet sont calcul\'es. Ils permettent une nouvelle fois de d\'etecter la non faisabilit\'e de l'instance (la valeur du plus court chemin sur une ressource d\'epasse le majorant du puits) ou de mettre \`a jour le majorant du probl\`eme par la consid\'eration d'un chemin r\'ealisable pour toutes les ressources.
 \item Enfin, les chemins les moins co\^uteux et les moins consommateurs en chaque ressource allant de tout sommet au puits sont calcul\'es.
\end{itemize}
D'une part, l'ensemble des chemins ainsi g\'en\'er\'es permet d'am\'eliorer le majorant en recombinant les plus courts chemins pour trouver des chemins r\'ealisables de bon co\^ut~: le principe consiste tout simplement \`a consid\'erer, pour chaque arc  du graphe, les chemins r\'esultant d'une concat\'enation d'un plus court chemin de ~\`a~, de l'arc  et d'un plus court chemin de ~\`a~.

D'autre part, cela permet de tester l'accessibilit\'e ou la pertinence (en incluant l'information apport\'ee par le majorant) de chaque sommet et de chaque arc pour les supprimer si possible~: pour un sommet  ({\em resp.}, pour un arc ), il suffit que, pour une m\'etrique donn\'ee, la valeur du plus court chemin de  \`a  additionn\'e \`a la valeur du plus court chemin de  \`a  ({\em resp.}, \`a la valeur de l'arc  plus la valeur du plus court chemin de  \`a ) soit plus grande que le majorant en co\^ut ou que le majorant pr\'esent sur le puits pour cette m\'etrique pour que ce sommet ({\em resp.}, cet arc) soit supprim\'e.
Cette proc\'edure peut donc renvoyer un constat de non r\'ealisabilit\'e, un chemin optimal ou un minorant et un majorant, ce dernier pouvant \^etre associ\'e \`a un chemin. Une description de ce traitement est propos\'ee par l'algorithme~\ref{algo-pretraitement}, o\`u l'on suppose disposer de deux proc\'edures  et   qui permettent de d\'eterminer respectivement les plus courts chemins de  \`a tous les sommets et les plus courts chemins de tous les sommets \`a , relativement \`a la m\'etrique .\\

Dans le cadre d'un sch\'ema de g\'en\'eration de colonnes, ce traitement permet de d\'etecter une instance non r\'ealisable mais aussi d'\'eliminer des sommets et des arcs n'appartenant pas \`a une solution optimale. De plus, d\`es que la valeur du majorant devient n\'egative, l'\'elimination de sommets et d'arcs non optimaux n'est plus n\'ecessairement opportune si l'objectif est de conserver plusieurs solutions interessantes (de co\^ut n\'egatif). Il suffit alors de rendre stricts les tests sur le majorant dans les blocs d'\'elimination des sommets et des arcs. 

\begin{algorithm}\label{algo-pretraitement}
\caption{PRETRAITEMENT~: Proc\'edure de pr\'etraitement}
\Entree{~\\
-  graphe,
		 fonction de co\^ut sur les arcs, 
		 vecteur des ressources disponibles au puits~\\
}
\BlankLine
\Sortie{ sous-graphe partiel de ~;  et  majorant et minorant du chemin le moins co\^uteux et v\'erifiant les contraintes}
\BlankLine
\;
\;
\Repeter{}{
 \;
\BlankLine
 \tcp{Calcul des plus courts chemins}
 \;
 \;
 \;
 \;
\BlankLine
 \tcp{Consid\'eration de } 
 \lSi{}{
  {L'instance n'est pas r\'ealisable; EXIT}\;
 } 
 \SinonSi{}{
  { est une solution optimale ; EXIT}\;
 }
 \lSinon{{}\;}
\BlankLine

 \tcp{Consid\'eration de }
  \lSi{}{
   {L'instance n'est pas r\'ealisable; EXIT}\;
  }
  \lSi{}{
  	{}\;
  }
\BlankLine
 \tcp{Recombinaison des chemins}
 \PourTous{}{
  \lSi{ et }{
   \;
  }
 }
\BlankLine
 \tcp{\'Elimination de sommets}
 \PourTous{}{
  \Si{}{
   Supprimer le sommet  et tous ses arcs incidents\;
  }
  \Si{}{
   Supprimer le sommet  et tous ses arcs incidents\;
  }
 }
\BlankLine
 \tcp{\'Elimination d'arcs}
 \PourTous{}{
  \Si{}{
   Supprimer l'arc \;
  }
  \SinonSi{}{
   Supprimer l'arc \;
  } 
 }
}
Retourner les bornes  et  ainsi que le chemin correspondant \`a la borne \;

\end{algorithm}


\section{R\'esolution exacte du PCCC}\label{sec-resol} Nous rappelons que le probl\`eme PCCC est -dur, et ce m\^eme pour une seule ressource. Le probl\`eme de d\'ecision associ\'e \`a l'existence d'un chemin de co\^ut inf\'erieur \`a une borne est lui-m\^eme -complet pour le cas de deux ressources ou plus. La r\'esolution exacte de ce probl\`eme peut \^etre men\'ee par la programmation dynamique.

\subsection{Cas g\'en\'eral}\label{sub-resol-progdyn}
La programmation dynamique pour ce probl\`eme permet d'\'elaborer un algorithme pseudo-polynomial\footnote{La complexit\'e d\'epend polynomialement de la taille des instances ainsi que des donn\'ees num\'eriques.} de r\'esolution exacte. La programmation dynamique se fonde sur le principe d'optimalit\'e de Bellman~: toute sous-s\'equence d'une s\'equence optimale est optimale. Cela est directement appliquable au plus court chemin~: si  est un plus court chemin de  \`a , alors  est n\'ecessairement un plus court chemin de  \`a  pour .  Avec l'introduction des contraintes de ressource, on ne peut plus adapter directement ce principe pour propager les meilleurs chemins, puisqu'il faut nuancer la notion d'optimalit\'e des sous-s\'equences par la consid\'eration d'un niveau de consommation de ressource~: si  est un plus court chemin de  \`a  consommant  unit\'es des  ressources, alors   est un plus court chemin de  \`a , parmi les chemins ne consommant pas plus de  unit\'es des ressources. Pour g\'erer les niveaux de consommation de co\^ut et de ressource des sous-s\'equences, la programmation dynamique utilise la notion d'\'etiquettes.
\begin{defs}
\'Etiquette\\
Une \'etiquette est un vecteur repr\'esentant un chemin et dont les coordonn\'ees sont le co\^ut et les consommations des diff\'erentes ressources.\\
 o\`u  est le co\^ut du chemin et  pour  est la consommation de la ressource . 
\end{defs}
\begin{rem}
~\\
A tout chemin r\'ealisable entre  et tout sommet correspond une \'etiquette.
\end{rem}
Les diff\'erents algorithmes de programmation dynamique utilisent ces \'etiquettes, mais il n'est pas forc\'ement n\'ecessaire de toutes les garder~: conserver toutes les \'etiquettes reviendrait \`a \'enum\'erer tous les chemins du graphe. Pour \'eliminer les \'etiquettes inutiles, une relation de dominance est d\'efinie.

\begin{defs}
Relation de dominance~:\\

\end{defs}
Cette relation de dominance induit un ordre partiel appel\'e ordre de Pareto. Toutes les \'etiquettes n'\'etant pas forc\'ement deux \`a deux comparables, cela permet de d\'efinir un ensemble de majorants pour cet ordre.
\begin{defs}
\'Element Pareto-optimal ou non domin\'e :\\
 est Pareto-optimal 
\end{defs}
\begin{defs}
Ensemble Pareto-optimal :\\
Un ensemble Pareto-optimal est un ensemble d'\'el\'ements non domin\'es.\\

\end{defs}
Cette relation de dominance permet de ne g\'en\'erer que les chemins Pareto-optimaux. Pour , la conservation de toutes les \'etiquettes non domin\'ees par  autres permet de s'assurer de trouver les  meilleures solutions et permet ainsi, dans notre sch\'ema de g\'en\'eration de colonnes, d'ins\'erer plusieurs colonnes lors d'une m\^eme it\'eration.

Deux types d'algorithmes de programmation dynamique existent~: algorithmes \`a correction d'\'etiquettes (\cite{Desrosiers1983}) et algorithmes \`a fixation d'\'etiquettes (\cite{Desrochers1988}).

\subsubsection{Algorithme \`a correction d'\'etiquettes \cite{Desrosiers1983}}\label{subsub-resol-progdyn-corr}
~\\
Cet algorithme se nomme ainsi car, \`a chaque it\'eration, il va essayer d'am\'eliorer les \'etiquettes d\'ej\`a existantes. En effet, une liste de sommets sur lesquels il existe des \'etiquettes non encore trait\'ees est maintenue. \`A chaque \'etape, un sommet de cette liste est choisi et les \'etiquettes de ce sommet sont propag\'ees aux successeurs de ce sommet. Pour chacune des \'etiquettes ainsi cr\'e\'ees, un test de dominance est effectu\'e pour \'eliminer les \'etiquettes domin\'ees ou d\'ej\`a obtenues. Si une nouvelle \'etiquette appara\^it, le sommet sur lequel cette \'etiquette est pr\'esente est ajout\'e \`a la liste des sommets \`a traiter.

\begin{algorithm}\label{algo-correction}
\caption{CORRECTION~: Algorithme \`a correction d'\'etiquettes}
\Entree{~\\
- ~: graphe avec R contraintes de ressource\\
-  renvoie l'ensemble des \'etiquettes non domin\'es de }
\BlankLine
\Sortie{Chemin contraint de co\^ ut optimal}
\BlankLine

\tcp{ est l'ensemble des \'etiquettes du sommet , les \'etiquettes \'etant des vecteurs de taille }

\PourTous{}{\;}
\;


\Tq{}{
Choisir \;
\PourTous{}{
	\PourTous{}{
		\Si{}{
			\;
			\;
			\lSi{}{\;}
		}
	}
}
Retourner le chemin ayant le plus petit co\^ut en \; 
} 
\end{algorithm}

\subsubsection{Algorithme \`a fixation d'\'etiquettes \cite{Desrosiers1983}}\label{subsub-resol-progdyn-fix}
~\\
Cet algorithme se nomme ainsi car \`a chaque it\'eration, il va fixer une \'etiquette qui ne pourra plus \^etre modifi\'ee. En effet, une liste d'\'etiquettes non encore trait\'ees est maintenue. \`A chaque \'etape, une \'etiquette (une des non domin\'ees de la liste) est choisie pour \^etre propag\'ee. Les nouvelles \'etiquettes cr\'e\'ees, si elles ne sont pas domin\'ees sur leur sommet, sont rajout\'ees \`a la liste.

\begin{algorithm}\label{algo-fixation}
\caption{FIXATION~: Algorithme \`a fixation d'\'etiquettes}
\Entree{~\\
- ~: graphe avec R contraintes de ressource\\
-  renvoie l'ensemble des \'etiquettes non domin\'es de \\
-  renvoie le sommet d'\'etiquette \\
-  renvoie un \'el\'ement de l'ensemble  minimum pour l'ordre lexicographique}
\BlankLine
\Sortie{Chemin contraint de co\^ ut optimal}
\BlankLine

\tcp{Les \'etiquettes sont des vecteurs de taille .}
\tcp{ est l'ensemble des \'etiquettes du sommet .}
\tcp{ est l'ensemble des \'etiquettes d\'efinitives du sommet .}

\lPourTous{}{\;}
\BlankLine

\BlankLine
\Tq{}{
  \;
  \;
  \PourTous{}{
	  \Si{}{
			\;
			\;
	  }
  }
  \;
}
Retourner le chemin ayant le plus petit co\^ut en \; 
\end{algorithm}

\subsection{Cas d'un graphe acyclique}\label{sub-resol-acycl}
~\\
Dans le cas d'un graphe acyclique, un ordre topologique sur les sommets peut \^etre calcul\'e. L'ensemble des sommets peut alors \^etre num\'erot\'e de  \`a  de sorte que le sommet  soit la source, le sommet  le puits et que les sommets de tout arc  v\'erifie la relation . Cet algorithme de programmation dynamique pour les graphes acycliques va appliquer l'algorithme \`a correction d'\'etiquettes vu pr\'ec\'edemment en parcourant les sommets dans l'ordre topologique. Ainsi, lors du traitement d'un sommet, tous les sommets qui le pr\'ec\`edent dans l'ordre topologique ont leurs \'etiquettes d\'efinitives. Le calcul des \'etiquettes de ce sommet ne se fait donc qu'une seule fois.

\begin{algorithm}\label{algo-acyclique}
\caption{ACYCLIQUE~: Algorithme pour les graphes acycliques}
\Entree{~\\
- ~: graphe acyclique avec R contraintes de ressource, \\
-  renvoie l'ensemble des \'etiquettes non domin\'es de }
\BlankLine
\Sortie{Chemin contraint de co\^ ut optimal}
\BlankLine
\tcp{ est l'ensemble des \'etiquettes du sommet , les \'etiquettes sont des vecteurs de taille }
\;
\PourTous{ allant de  \`a }{
	\;
	\PourTous{}{
		\PourTous{}{
			\Si{}{
    			\;
				\;
			}
		}
	}
	\;		
}
Retourner le chemin ayant le plus petit co\^ut au sommet \;
\end{algorithm}

\subsubsection{Etude de complexit\'e}\label{sub-resol-acycl-complex}
~\\
Pour calculer la complexit\'e en espace, il suffit de calculer le nombre maximum d'\'etiquettes que peut g\'en\'erer cet algorithme. En supposant que chaque sommet est reli\'e \`a tous les sommets le pr\'ec\'edant dans l'ordre topologique, le nombre maximum d'\'etiquettes pour le sommet  () est \'egal au nombre de toutes les \'etiquettes des sommets de plus petit indice ~; la source n'ayant qu'une seule \'etiquette (nulle)~:

Pour trouver le nombre d'\'etiquettes total, il suffit de faire la somme sur tous les sommets~:

Sachant que chaque \'etiquette est un vecteur de taille , la complexit\'e en espace est donc en .

La complexit\'e en temps de l'algorithme pr\'ec\'edent se calcule en prenant le cas du sommet 2 \`a part car il n'y a qu'une seule \'etiquette cr\'e\'ee et donc pas de dominance ( it\`ere les sommets,  les pr\'ed\'ecesseurs,  les \'etiquettes,  et  sont deux it\'erateurs pour faire les comparaisons deux \`a deux lors de la dominance)~:


L'algorithme de programmation dynamique propos\'e pour les graphes acycliques n'est pas polynomial. Les algorithmes pour les graphes g\'en\'eraux ne le sont a fortiori pas non plus. Au vu de ces r\'esultats de complexit\'e, l'\'elagage du graphe a priori en supprimant des sommets ou des arcs est primordial pour r\'eduire le nombre de chemins possibles~; de m\^eme, diminuer l'amplitude des fen\^etres de temps et trouver un bon majorant permet aussi de diminuer le nombre d'\'etiquettes calcul\'ees.

\subsection{ Plus Courts Chemins}\label{sub-resol-kpcc}
Des algorithmes polynomiaux exacts ont \'egalement \'et\'e d\'evelopp\'es pour d\'eterminer, non plus {\em un} plus court chemin, mais les  plus courts chemins de  \`a  (ou de  \`a tout autre sommet). Le meilleur algorithme connu \`a ce jour est celui de Eppstein, \cite{Eppstein1998}, de complexit\'e . Il consiste \`a fabriquer un tas des chemins du graphe stock\'es sous forme implicite et tri\'e selon un certain crit\`ere. L'explicitation d'un chemin du tas se fait ensuite en  o\`u  est la longueur du chemin \`a \'enum\'erer.

Dans le cas du PCCC, cet algorithme peut calculer les consommations de ressource s'additionnant le long de tous les chemins lors de la construction du tas avec une complexit\'e d'ordre . La r\'ecup\'eration de la valeur d'une consommations se fait en temps constant. Ainsi, il est possible de tester la r\'ealisabilit\'e d'un chemin en temps . 

Pour r\'esoudre le probl\`eme par cet algorithme, il faudrait g\'en\'erer le tas de tous les chemins du graphe selon le crit\`ere de co\^ut initial, puis d\'epiler les chemins (dont le nombre total est exponentiel) jusqu'\`a trouver un chemin r\'ealisable, le premier chemin trouv\'e \'etant le chemin optimal. Une telle proc\'edure, de complexit\'e au pire des cas d'ordre exponentiel en temps, pourrait n\'eanmoins consituter une alternative \`a la r\'esolution exacte par programmation dynamique.



\section{R\'esolution approch\'ee du PCCC}\label{sec-approx}

Le probl\`eme du PCCC \'etant -difficile, la recherche s'est dirig\'ee vers la r\'esolution approch\'ee du probl\`eme. Quelques heuristiques existent : aggr\'egation de contraintes de ressource \cite{Nagih2005}, recherche de solutions -r\'ealisable \cite{Avella2002}. Cette section pr\'esentera un sch\'ema d'approximation pour le cas d'une ressource finale puis une g\'en\'eralisation de ce sch\'ema dans le cas de plusieurs ressources.

\subsection{Sch\'ema d'approximation totalement polynomial}\label{sub-approx-fptas}
Un FPTAS ({\em Fully Polynomial Time Approximation Scheme} ou sch\'ema d'approximation totalement polynomial en temps) a tout d'abord \'et\'e pr\'esent\'e par Hassin \cite{Hassin1992} et ensuite am\'elior\'e par diff\'erents auteurs \cite{Phillips1993,Lorenz2001,Ergun2002}. Ce FPTAS se base sur la programmation dynamique avec la technique {\em d'\'echelonnage et d'arrondis} pour trouver une approximation de la solution. Ce FPTAS est utilisable dans le cas de graphes acycliques, avec une seule contrainte de ressource finale. Un ordre topologique sur les sommets est calcul\'e~; l'ensemble des sommets est donc dor\'enavant num\'erot\'e de  \`a  sachant que le sommet  est la source, le sommet  le puits et tout arc  v\'erifie la relation .

\subsubsection{Sch\'ema initial}\label{subsub-approx-fptas-hassin}
La proc\'edure de programmation dynamique sous-jacente est bas\'ee sur le co\^ut et non sur la ressource, comme c'est le cas habituellement~: on cherche \`a d\'eterminer pour  la plus petite consommation de ressource des chemins allant de  \`a  en au plus  unit\'es de co\^ut~; la recherche porte alors sur ,  \'etant optimal d\`es lors que  (i.e., la valeur optimale est le plus petit  pour lequel la consommation de ressource est inf\'erieure \`a la borne du puits). L'utilisation de cette proc\'edure induit donc que les co\^uts sur les arcs sont des entiers strictement positifs.

\begin{algorithm}\label{algo-exact}
\caption{EXACT~: Programmation dynamique bas\'ee sur le co\^ut}
\Entree{Un graphe G acyclique}
\Sortie{Un chemin contraint de co\^ut optimal ()}
\BlankLine

{}\;

{}\;

\lPourTous{}{}\;

\Tq{}
{
	{}\;
	\PourTous{}
	{
	 	\;
	 	\PourTous{}
		{
	  		\lSi{}{}\;
		}
	}
}
Retourner le chemin de co\^ut  correspondant \`a la consommation de ressource 
\end{algorithm}

La complexit\'e de l'algorithme EXACT est  avec . Il s'agit donc d'un algorithme pseudopolynomial, i.e., dont la complexit\'e est polynomiale en la taille de l'instance prise au sens du nombre d'\'el\'ements de la structure \`a coder, mais exponentielle en le logarithme de ses donn\'ees num\'eriques.\\
Une mani\`ere usuelle de se ramener \`a un ordre polynomial de complexit\'e consiste \`a diminuer consid\'erablement l'ordre de grandeur des donn\'ees num\'eriques~; c'est la technique {\emph{ d'\'echelonnage et d'arrondis}. Bien s\^ur, la polynomialit\'e de l'algorithme appliqu\'e \`a l'instance transform\'ee se gagne au prix de l'optimalit\'e~: les solutions obtenues ne sont plus optimales, mais seulement approch\'ees, pour l'instance initiale.\\
Pour le probl\`eme qui nous concerne, on utilise l'algorithme SCALING qui, \'etant donn\'es une borne  et un rationnel ,  remplace chaque co\^ut  par le co\^ut .  

\begin{algorithm}\label{algo-scaling}
\caption{SCALING~: Proc\'edure d'\'echelonnage et d'arrondis}
\Entree{ graphe arc-valu\'e, , }
\BlankLine
\Sortie{ graphe arc-valu\'e}
\BlankLine
\;
\;
\BlankLine
\PourTous{}{
	\Si{}{
		{}\;
		{}\;
	}
}
\end{algorithm}

La complexit\'e de la proc\'edure SCALING est en  (pour chaque arc, une recherche dichotomique dans l'espace ). De plus, la proc\'edure EXACT appliqu\'ee \`a l'instance  n\'ecessiterait un temps , o\`u  d\'esigne la valeur optimale sur . Or, les valeurs de toute solution  sur les instances  et  sont li\'ees par les relations suivantes~:


En particulier, si les chemins  et  sont respectivement optimaux pour les instances  et , alors~:
7pt]
C(\tilde{P}_{s\rightarrow t})
				&\leq 	&\displaystyle\frac{B\delta}{n-1}\widetilde{OPT}+B\delta
				&\leq 	&OPT+B\delta
\end{array}TEST(B,\delta) =\left\{
\begin{array}{ll}
OUI & \textrm{si }\\
NON & \textrm{si }
\end{array}
\right.

\begin{array}{ccccc}
	\tilde{I}
	&\left\{\begin{array}{lclcl}	
		\textrm{OUI}	&\Leftrightarrow	&\widetilde{OPT} >  \tilde{B}\\
		\textrm{NON}	&\Leftrightarrow	&\widetilde{OPT}\leq  \tilde{B}
	\end{array}\right.
	&\Rightarrow
	&I
	&\left\{\begin{array}{l}	
		OPT > B\\
		OPT\leq (1+\delta)B
	\end{array}\right.
\end{array}
\mathcal{O}\left(\log\left(\frac{\log\left(UB/LB\right)}{\log(\rho)}\right)\ \left(\frac{m\ n}{\delta} + \log\left(\log(UB/LB)\right)\right)\right)\mathcal{O}\left(\log\left(\frac{\log(UB/LB)}{\log(\rho)}\right) \left(\frac{m\ n}{\delta}+\log\log\left(\frac{UB}{LB}\right)\right)\right) + 
	\mathcal{O}\left(m\ \left(\rho\ \frac{n}{\varepsilon}\right)\right)\mathcal{O}\left(\log\log\left(\frac{UB}{LB}\right)\left(\frac{m\ n}{\epsilon} + \log\log\left(\frac{UB}{LB}\right)\right)\right)\mathcal{O}\left(m\ n\, \log\log(n)\ +\ \frac{m\ n}{\epsilon}\right)\begin{array}{lcl}
\delta = f(LB,UB) 			&= &\displaystyle\sqrt{\frac{UB}{LB}} -1\
La complexit\'e de DICHO devient ~; par cons\'equent, le sch\'ema dans sa globalit\'e se d\'eroule en temps~:


\subsubsection{\'Etude de la complexit\'e}
Ergun et al. \cite{Ergun2002} effectuent le calcul de complexit\'e de leur sch\'ema en utilisant les valeurs exactes pour  et . Hassin \cite{Hassin1992} utilise une m\'ethode dont la complexit\'e est connue pour trouver une valeur approch\'ee des racines carr\'ees. Ici, l'\'etude commence par choisir de bonnes valeurs approch\'ees des param\`etres du sch\'ema suivant cette m\'ethode avant de faire l'\'etude de la complexit\'e. La recherche des valeurs approch\'ees des racines carr\'ees se fait comme suit :
\begin{itemize}
\itemsep = 0.5ex
\item trouver le premier  tel que .
\item  d'o\`u 
\item  d'o\`u 
\end{itemize}

\noindent D'apr\`es le r\'esultat de la proc\'edure TEST, les bornes sont mises \`a jour :
\begin{itemize}
\item TEST r\'epond OUI :\\
 et \0.1cm]
Cela donne donc 
\end{itemize}
Donc au pire, la plus petite diminution du rapport donne .
On note  le nombre de passages dans la boucle \textit{tant que} de la proc\'edure DICHO. Avant l'ex\'ecution de la proc\'edure DICHO, le rapport du majorant sur le minorant est born\'e par  et apr\`es cette proc\'edure, il est de  donc la valeur de  est born\'ee comme suit :

En posant respectivement ,  et  les valeurs de , du majorant et du minorant de l'\'etape , la complexit\'e de la proc\'edure DICHO s'\'ecrit donc :


On a aussi :

Donc :


 et on rappelle que 

Finalement, cela donne :

La complexit\'e de la proc\'edure DICHO est bien en , ce qui permet d'arriver \`a une complexit\'e totale pour le sch\'ema de .


\subsection{Approche multicrit\`ere}\label{sub-approx-multiobj}
Si le cas d'une ressource se r\'esoud efficacement par la programmation dynamique, en revanche, que peut-on dire du cas de deux ressources ou plus~? Bien s\^ur, puisque d\'ecider m\^eme s'il existe un chemin r\'ealisable est -complet, on ne peut garantir de trouver des solutions approch\'ees en temps polynomial. N\'eanmoins, une mani\`ere de g\'en\'eraliser l'approche pr\'ec\'edente consiste \`a se placer dans le cadre multicrit\`ere. il s'agit d'une relaxation du probl\`eme (on rel\^ache les contraintes de consommation de ressource), mais le fait de conserver la nature multicrit\`ere (les consommations de ressource sont vues comme des crit\`eres \`a optimiser) permet peut-\^etre de mieux parcourir l'ensemble des solutions ou, \`a d\'efaut, d'en dessiner les contours. D\`es le d\'ebut des ann\'ees 80, Hansen s'est int\'ress\'e au probl\`eme de plus court chemin bicrit\`ere en en donnant un FPTAS \cite{Hansen1980}. Pour des probl\`emes plus g\'en\'eraux, Papadimitriou et Yannakakis, \cite{Papadimitriou2000}, ont propos\'e une d\'emonstration g\'eom\'etrique de l'existence d'une fronti\`ere de Pareto approch\'ee de taille polynomiale. Les auteurs ont \'egalement donn\'e des th\'eor\` emes d'existence de proc\'edures polynomiales permettant de construire de telles fronti\`eres, qui s'appliquent notamment \`a notre probl\`eme (ces th\'eor\`emes sont d'ailleurs une forme de g\'en\'eralisation des r\'esultats obtenus par Hassin pour le cas d'une ressource, que l'on peut consid\'erer comme probl\`eme bicrit\`ere). Nous d\'efinissons dans un premier temps le probl\`eme de plus court chemin dans un cadre multicrit\`ere afin d'introduire la notion de fronti\`ere de Pareto approch\'ee. Nous proposons ensuite un algorithme permettant de d\'eterminer une telle fronti\`ere, puis concluons en repla\c{c}ant ces r\'esultats dans le cadre sp\'ecifique de la r\'esolution de \textsc{PCCC}. Dans cette section, on se restreint de nouveau aux contraintes de ressource au puits~; de plus, les graphes sont suppos\'es sans circuit et les donn\'ees num\'eriques rationnelles strictement positives.  


\subsubsection{Plus court chemin multicrit\`ere}\label{subsub-approx-multiobj-pres}
Dans l'approche multicrit\`ere, les probl\`emes consid\'er\'es sont la g\'en\'eralisation \`a plusieurs objectifs des probl\`emes d'optimisation classique. Pour le probl\`eme de plus court chemin, il s'agit donc de d\'eterminer, dans un graphe orient\'e , un chemin de  \`a  qui optimise, non pas une fonction de co\^ut , mais un ensemble de fonctions . Cette version du probl\`eme est not\'ee \textsc{PCC-M}. Les fonctions \`a optimiser sont toutes suppos\'ees \`a valeur dans . De plus, les crit\`eres peuvent \^etre \`a minimiser ou \`a maximiser (par exemple, un crit\`ere souvent pris en consid\'eration pour la construction de chemins est celui de la longueur des chemins, que l'on cherche \`a maximiser). Ainsi, par la suite, on consid\`erera  fonctions  \`a optimiser, sans pr\'esupposer de leur sens d'optimisation (maximiser ou minimiser), ni dans un premier temps de leur interpr\'etation (crit\`ere original du probl\`eme ou relaxation d'une contrainte de ressource). Les ensembles des indices des crit\`eres \`a maximiser et \`a minimiser seront respectivement not\'es  et . Pour tout vecteur  de ,  (resp., ) d\'esigne sa restriction aux indices de  (resp., de ).

La multiplicit\'e des fonctions \`a optimiser fait qu'elles n'induisent plus a priori un ordre complet sur l'ensemble des solutions r\'ealisables~:  et  sont par exemple incomparables dans . \'Evidemment, il est toujours possible de d\'efinir malgr\'e tout un ordre complet, par exemple, en consid\'erant l'ordre lexicographique, ou encore, en consid\'erant, lorsque cela est possible, une combinaison lin\'eaire des crit\`eres \`a optimiser~; auquel cas on se ram\`ene \`a un probl\`eme monocrit\`ere. N\'eanmoins, si l'on souhaite conserver la nature multicrit\`ere du probl\`eme (et c'est notre cas~: la ressource~1 ne doit pas plus exc\'eder sa borne que ne le doit la ressource~2), alors il faut travailler sur l'ordre partiel induit par la relation de dominance, d\'ej\`a pr\'esent\'ee en section \ref{sub-resol-progdyn}. On ne cherche plus d\`es lors \`a d\'eterminer une solution optimale, mais un ensemble de solutions {\em efficaces}, ou non domin\'ees, appel\'e fronti\`ere de Pareto.

\begin{defs}\label{def-pareto}
Fronti\`ere de Pareto pour \textsc{PCC-M}~:\\
Soit  une instance de \textsc{PCC-M}, o\`u  d\'esigne l'ensemble des chemins sur . La fronti\`ere de Pareto de , not\'ee , est l'ensemble des solutions non domin\'ees de . Formellement,  est l'ensemble des chemins  qui v\'erifient pour tout chemin ~:
20pt]
		Alors  							&\exists \ell\in 1,\ldots,R,\ t.q.\ 
			\left\{\begin{array}{llcl}
									&\left(\ell\in \mathscr{R}^{\max}\right) 	&\wedge	&\left(C^\ell(P_{s \to t}) > C^\ell(P'_{s \to t})\right)\\
						\textrm{ou}	&\left(\ell\in \mathscr{R}^{\min}\right)		&\wedge &\left(C^\ell(P_{s \to t}) < C^\ell(P'_{s \to t})\right)
						\end{array}\right.
\end{array}\begin{array}{l}
\forall P'_{s \to t}\in\mathcal{P},\ \exists P_{s \to t}\in  \mathscr{P}_{\varepsilon}(I)\ t.q.~:\7pt]C^r(P'_{s \to t}) > (1-\varepsilon) C^r(P_{s \to t})	&\textrm{si }r\in \mathscr{R}^{\min}\end{array}\right.
\end{array}\mathcal{O}\left(\left(\frac{1}{\varepsilon}\log(MAJ)\right)^R\right)\left\{\begin{array}{lclclc}
			c^r_{i^r} 	&\leq &C^r(P'_{s \to t}) &< &c^{r}_{i^r+1} 	&\textrm{si } r\in \mathscr{R}^{\max}\

L'hypercube  consid\'er\'e consiste alors en le produit cart\'esien des intervalles  pour les indices correspondant \`a un crit\`ere \`a maximiser et  pour les indices correspondant \`a un crit\`ere \`a minimiser. Il existe n\'ecessairement une \'etiquette  correspondant \`a un chemin de  dans  (cette \'etiquette pouvant \^{e}tre celle de )~; alors, par construction~:

10pt]
c^r_{i^r}\geq E^r\textrm{ et }C^r(P'_{s \to t}) > (1-\varepsilon)c^r_{i^r}\  
	\Rightarrow\ C^r(P'_{s \to t}) > (1-\varepsilon)E^r 
&\textrm{si }r\in \mathscr{R}^{\min}
\end{array}\displaystyle{ \otimes_{r\in \mathscr{R}^{\max}}[c^r_{i^r},c^r_{H^r}] \otimes_{r\in \mathscr{R}^{\min}}[c^r_{H^r},c^r_{i^r}]}E_{|\mathscr{R}^{\max}} \geq B_{|\mathscr{R}^{\max}}\textrm{ et }E_{|\mathscr{R}^{\min}} \leq B_{|\mathscr{R}^{\min}}R + \sum_{i=2}^n \left(\sum_{j=1}^{i-1} N_j R + \textrm{C}^2_{N_i} R \right) + N_n R\mathcal{O}\left(R\,M^R\left(n^2+nM^R\right)\right) = 
\mathcal{O}\left( R\, n^{2R+1}\, C_{maj}^{2R} \right)\mathcal{O}\left( mR\, \log\left(\frac{n}{\varepsilon}\right) \right) = \mathcal{O}\left( n^2R\, \log\left(\frac{n}{\varepsilon}\right) \right)\begin{array}{lcl}
\left\{\begin{array}{ll}
\tilde{C}^r(P_{s \to t})\geq \tilde{B}_M	&\forall r\in \mathscr{R}^{\max}\7pt]
			C(P_{s \to t})_{|\mathscr{R}^{\min}}\leq B_{|\mathscr{R}^{\max}}
			\end{array}\right.\7pt]
\exists r\in \mathscr{R}^{\min}, &\tilde{C}^r(P_{s \to t})> \tilde{B}_m
\end{array}\right.	
	&\Rightarrow
		&\left\{\begin{array}{ll}
			\exists r\in \mathscr{R}^{\max}, &C^r(P_{s \to t})< (1+\varepsilon_M)B^r\

Par ailleurs, puisque les valeurs num\'eriques sur  sont born\'ees par , le d\'eroulement de la proc\'edure ACYCLIQUE-M sur  pour le param\`etre  d\'efini par  et  devient polynomial en  et , d'ordre~: 


En cons\'equence de ces deux derni\`eres observations, on peut d\'ecider, pour une instance  d'ordre , un point  et deux param\`etres d'erreur , en temps polynomial en  et en ~:


\begin{algorithm}\label{algo-test-m}
\caption{TEST-M~: Proc\'edure de test approch\'ee sur \textsc{PCC-M}}
\Entree{ instance,  vecteur,  erreurs}
\BlankLine
\Sortie{\\~OUI et un chemin  v\'erifiant
	
\\~NON si tout chemin  v\'erifie  pour un certain crit\`ere  \`a maximiser ou  pour un certain crit\`ere  \`a minimiser.}
\BlankLine
SCALING-M()\;
\BlankLine
; 
\;
\BlankLine
\;
ACYCLIQUE-M()\;
\Si{}
	{Retourner OUI et un chemin d'\'etiquette dans }
\Sinon
	{Retourner NON} 
\end{algorithm}


\paragraph{Sch\'ema complet d'approximation}
Le sch\'ema con\c{c}u consiste \`a op\'erer un quadrillage de l'espace des valeurs, puis \`a appeler la proc\'edure de test approch\'e en le  coin de chaque hypercube issu de ce quadrillage. Pr\'ecis\'ement, l'algorithme PARETO-PCC-M sollicite la proc\'edure QUADRILLAGE  pour les erreurs  et  (on ne fait plus le quadrillage sur , puisque le test en chaque hypercube n'est pas exact, mais approch\'e). Il appelle ensuite la proc\'edure TEST-M sur chaque coin , en invoquant les m\^emes param\`etres d'erreur  et . Les chemins trouv\'es par les appels successifs \`a TEST-M constituent la fronti\`ere de Pareto -approch\'ee.

\begin{algorithm}\label{algo-pareto-pcc-m}
\caption{PARETO-PCC-M~: Fronti\`ere de Pareto -approch\'ee en temps polynomial}
\Entree{ instance,  erreur}
\BlankLine
\Sortie{ Fronti\`ere de Pareto -approch\'ee}
\BlankLine
\;
\;
\;
 QUADRILLAGE()\;
\PourTous{}
{
	\;
	\Si{TEST-M() renvoie un chemin }
		{\;} 
}
\end{algorithm}


Soit  un chemin de  \`a  et soit  son \'etiquette, on consid\`ere le point  caract\'eris\'e par~: 
7pt]
			c^r_{i^r} 	&\geq &C^r(P'_{s \to t}) &> &(1-\varepsilon_m)c^{r}_{i^r} 	&\textrm{si } r\in \mathscr{R}^{\min}
	\end{array}\right.\left\{\begin{array}{ll}
C^r(P_{s \to t})\geq c^r_{i^r}\ \Rightarrow\ C^r(P'_{s \to t})< (1+\varepsilon_M)c^r_{i^r}\leq (1+\varepsilon)C^r(P_{s \to t}) 
&\textrm{si }r\in \mathscr{R}^{\max}\

Sinon, l'existence de  assure que TEST-M a n\'ecessairement renvoy\'e un chemin  pour le point  d\'efini par~:


Ce chemin v\'erifie bien de nouveau~:
7pt]
C^r(P_{s \to t})\leq \frac{1}{1-\varepsilon_m}c^r_{i^r}\ \Rightarrow\ C^r(P'_{s \to t})> (1-\varepsilon_m)^2C^r(P_{s \to t})= (1-\varepsilon)C^r(P_{s \to t}) &\textrm{si }r\in \mathscr{R}^{\min}
\end{array}\right.\mathcal{O}\left( \left(\frac{\log(MAJ)}{\varepsilon}\right)^R 
			\left(Rm\, \log\left(\frac{n}{\varepsilon}\right)\, +\, \frac{Rn^{4R+1}}{\varepsilon^{2R}}\right)\right)
			=\mathcal{O}\left( \left(\frac{\log(MAJ)}{\varepsilon}\right)^R \frac{Rn^{4R+1}}{\varepsilon^{2R}}\right)	
	
\subsubsection{Fronti\`ere de Pareto et PCCC}\label{subsub-approx-multiobj-p3c}
La vision multicrit\`ere du probl\`eme de plus court chemin contraint \`a  ressources peut s'\'enoncer comme le probl\`eme consistant \`a trouver un chemin  qui minimise chaque composante du vecteur . Si l'on dispose d'une fronti\`ere de Pareto -approch\'ee , cela signifie que tout chemin  de  \`a  est repr\'esent\'e par un chemin  de la fronti\`ere  qui consomme au plus  la consommation de  sur chaque crit\`ere. En particulier, si  est r\'ealisable, on d\'eduit que  est -r\'ealisable. 

\section{Synth\`ese}\label{sec-conc}

Le tableau \ref{tab-recap-comp} r\'esume les complexit\'es th\'eoriques des algorithmes de plus court chemin les plus connus ainsi que des algorithmes exacts ou approch\'es pour le PCCC vus dans ce rapport.
\begin{table}
\center

\caption{Diff\'erents algorithmes et leur complexit\'e}\label{tab-recap-comp}
\begin{tabular}{|c|c|c|c|}
\hline
Nombre & Hypoth\`ese & Auteur & \\
de & sur & ou & Complexit\'e en temps\\
ressources & le graphe &  Nom de l'algorithme & \\
\hline
\multirow{2}*{} & \multirow{2}*{} & \multirow{2}*{Bellman\cite{Bellman1958}} & \multirow{2}*{}\\
& & & \\
\hline
\multirow{2}*{} &  & \multirow{2}*{Bellman} & \multirow{2}*{}\\
 & G acyclique & & \\
\hline
\multirow{2}*{} & \multirow{2}*{} & \multirow{2}*{Dijkstra\cite{Dijkstra1959}} & \multirow{2}*{}\\
 & & & \\
\hline
\multirow{2}*{} & \multirow{2}*{} & \multirow{2}*{Dijkstra (tas de Fibonacci)} & \multirow{2}*{}\\
& & & \\
\hline
\multirow{2}*{} & \multirow{2}*{} & \multirow{2}*{Programmation dynamique\cite{Dumitrescu2003}} & \multirow{2}*{}\\
& & & \\
\hline
\multirow{2}*{} & \multirow{2}*{} & \multirow{2}*{Programmation dynamique} & \multirow{2}*{}\\
& & & \\
\hline
\multirow{2}*{} & \multirow{2}*{} & \multirow{2}*{ plus courts chemins\cite{Eppstein1998}} & \multirow{2}*{}\\
& & & \\
\hline
\hline
\multirow{3}*{1} & \multirow{3}*{} & \multirow{3}*{FPTAS\cite{Phillips1993}} & \multirow{3}*{}\\
& & & \\
& & & \\
\hline
\multirow{3}*{1} & \multirow{3}*{} & \multirow{3}*{FPTAS multicrit\`ere\cite{Hansen1980}} & \multirow{3}*{}\\
& & & \\
& & & \\
\hline
\multirow{3}*{1} & \multirow{3}*{} & \multirow{3}*{FPTAS\cite{Hassin1992} \cite{Lorenz2001} \cite{Ergun2002}} & \multirow{3}*{}\\
& & & \\
& & & \\
\hline
\multirow{3}*{} & \multirow{3}*{} & \multirow{2}*{Fronti\`ere Pareto -approch\'ee\cite{Papadimitriou2000}} & \multirow{3}*{}\\
& & & \\
& & & \\
\hline
\end{tabular}
\end{table}


Le but de cette \'etude est d'\'etudier la possibilit\'e de g\'en\'erer des chemins contraints en temps ma\^{\i}tris\'e, dans l'optique d'acc\'el\'erer certains sch\'emas de g\'en\'eration de colonnes impliquant le PCCC comme sous-probl\`eme. Deux avantages pourraient \^etre tir\'es d'une telle d\'emarche~: d'une part, \^etre en mesure de g\'en\'erer une population diversifi\'ee de chemins lors de la phase d'initialisation~; d'autre part, acc\'el\'erer les premi\`eres it\'erations du sch\'ema. Les m\'ethodes les plus r\'epandues \`a ce jour pour r\'esoudre le PCCC, notamment dans ce cadre sp\'ecifique, sont celles de type programmation dynamique, qui offrent des solutions exactes, en temps et en espace exponentiel (ce sont encore ces m\^emes m\'ethodes qui ont inspir\'e les algorithmes approch\'es). Si nous avons \'evoqu\'e quelques m\'ethodes de simplification des instances (section~\ref{sec-reduc}), celles-ci ne garantissent pas pour autant la diminution de la complexit\'e th\'eorique. Quelle alternative avons-nous donc, quitte \`a s'affranchir de l'optimalit\'e, voire, de la r\'ealisabilit\'e~? 

La recherche de plus courts chemins dans le cadre sp\'ecifique du d\'eroulement d'un sch\'ema de g\'en\'eration de colonnes pose deux probl\`emes de nature diff\'erente. D'une part, celle de la difficult\'e intrins\`eque du probl\`eme contraint, \`a partir de 2 ressources~: si l'on souhaite rester dans un ordre polynomial de complexit\'e, il faut s'affranchir de l'exactitude en termes d'optimalit\'e et en termes de r\'ealisabilit\'e. D'autre part, les co\^uts manipul\'es sur les arcs ne sont plus les co\^uts initiaux de l'instance, mais des co\^uts r\'eduits issus de la r\'esolution du (PMR), qui peuvent \^etre n\'egatifs~: les hypoth\`eses faites sur la structure de co\^ut de l'instance initiale ne tiennent donc plus au cours des it\'erations. Or, ces hypoth\`eses interviennent conjointement dans les calculs de complexit\'e et des facteurs d'approximation. De sorte \`a exploiter les r\'esultats d'approximation, il faudrait donc \^etre en mesure de les \'etendre \`a un cadre plus g\'en\'eral (notamment, co\^uts rationnels n\'egatifs et positifs)~; en outre, il faudrait utiliser, voire, d\'efinir, un cadre pertinent pour l'approximation, l'approximation classique supposant des valeurs positives.

La diversification des chemins (notamment, dans la phase d'initialisation) sous-entend un certain balayage de l'espace des solutions. Parmi les approches que nous avons pr\'esent\'ees, la recherche des  plus courts chemins d'une part (section~\ref{sub-resol-kpcc}), d'une fronti\`ere de Pareto -approch\'ee d'autre part (section~\ref{subsub-approx-multiobj-pcc}), vont dans le sens d'une telle exploration. Dans le premier cas, on cherche intensivement les meilleurs chemins contraints en terme de co\^ ut, tandis que dans le second cas, on balaye sporadiquement tout l'espace.

Pour un nombre de ressources  donn\'e, l'algorithme d'Eppstein permet de trier en temps  tous les chemins du graphe suivant le co\^ut (initial, ou r\'eduits dans le cadre de la g\'en\'eration de colonnes). Une fois le tas constitu\'e, il suffit pour trouver le chemin contraint optimal de d\'epiler les chemins jusqu'\`a trouver un chemin r\'ealisable (ou, dans le cadre d'un sch\'ema de g\'en\'eration de colonnes, quand le crit\`ere de co\^ut choisi pour la construction du tas est le co\^ut r\'eduit, l'optimalit\'e est prouv\'ee s'il n'existe pas de chemin r\'ealisable de co\^ut n\'egatif). Rien n'assure n\'eanmoins que les  plus courts chemins, pour  o\`u  polyn\^ome, contiennent ne serait-ce qu'un chemin r\'ealisable pour les ressources (ni un chemin de co\^ut positif pour d\'emontrer l'optimalit\'e du sch\'ema). Par ailleurs, en triant sur le seul crit\`ere de co\^ut, on risque de g\'en\'erer des chemins peu diversifi\'es. Ainsi, en se limitant \`a chercher un nombre polynomial de chemins, on ne garantit pas l'obtention de chemins pertinents~; en prenant au contraire , la construction du tas reste polynomiale en temps et en espace, et l'\'enum\'eration des chemins devient exponentielle en temps mais pas espace~: on n'obtient alors une alternative \`a la r\'esolution exacte par programmation dynamique qui est exponentielle en temps et en espace.

\`A partir de 2 ressources, l'obtention de solutions r\'ealisables n'\'etant plus garantie, l'approche multicrit\`ere semble prometteuse. 
Bien plus que la recherche de la fronti\`ere de Pareto -approch\'ee elle-m\^{e}me, c'est le quadrillage de l'espace des valeurs et l'utilisation de la programmation dynamique sur les instances modifi\'ees qu'il faudra chercher \`a exploiter~: balayer l'espace des valeurs possibles et chercher une solution dans chaque hypercube semble \^etre une bonne strat\'egie en vue de la diversification des chemins d\`es l'initialisation. 



\bibliographystyle{alpha} 
\bibliography{Bibliographie}


\end{document}
