
\documentclass{eptcs}
\usepackage{oldlfont,amssymb,latexsym,euscript,epsf,makeidx}
\usepackage[dvips]{graphicx}
\bibliographystyle{eptcs}
\input{xy}
\xyoption{all}
\def{\ensuremath{] \! ]}}
\def\coprod{\bigoplus}
\def\drestrict{\!\! \upharpoonright \!\!}
\def\sqepsilon{\ensuremath{\sqsubset \!\!\!\!\!\! - }}
\def\sqin{\ensuremath{\sqsubset \!\!\!\!\!\! - }} 
\def\C{{\cal{C}}}
\def\S{{\cal{S}}}
\def\G{{\cal{G}}}
\def\L{{\cal{L}}}
\def\Y{{\mathbf{Y}}}
\def\lra{\longrightarrow}
\def\N{\widetilde{\mathbb{N}_{*}}}
\def\0{0}
\def\k{k}
\def\M{{\cal M}}
\def\1m{\iota}
\def\restrict{\!\! \upharpoonright \!\!}
\def\PCF{{\mathrm{PCF}}}
\def\H{{\cal{H}}}
\def\K{{\cal{K}}}
\def\1{1}

\def\M{{\cal M}}
\def\E{{\cal E}}
\def\restrict{\!\! \upharpoonright \!\!}
\def\PCF{{\mathrm{PCF}}}
\def\updownharpoonright{\upharpoonright \!\! \downharpoonright}
\newcommand{\fst}{{\mathtt{fst}}}
\newcommand{\snd}{{\mathtt{snd}}}
\newcommand{\thro}{{\mathsf{throw}}}
\newcommand{\xs}{{\mathsf{S}}}
\newcommand{\loc}{{\mathsf{loc}}}
\newcommand{\ex}{{\mathsf{Ex}}}
\newcommand{\throwe}{{\mathtt{throw_e}}}
\newcommand{\throwc}{{\mathtt{throw_c}}}
\newcommand{\cse}{{\mathtt{case}}}
\newcommand{\as}{{\mathtt{as}}}
\newcommand{\cont}{{\mathsf{cont}}}
\newcommand{\comp}{{\mathsf{comp}}}
\newcommand{\ug}{\cg^U}
\newcommand{\void}{{\mathtt{void}}}
\newcommand{\match}{{\mathtt{match}}}
\newcommand{\Loc}{\mathsf{Loc}}



\newcommand{\wb}{{\G_{WB}}}
\newcommand{\rec}{{\mathtt{rec}}}
\newcommand{\cwb}{{\cg_{WB}}}
\newcommand{\cgb}{{\cg_{WKB}}}
\newcommand{\cwkb}{{\cg_{WKB}}}
\newcommand{\wkb}{{\mathsf{wkb}}}
\newcommand{\pc}{{\mathsf{pc}}}
\newcommand{\stack}{{\mathsf{stack}}}
\newcommand{\obs}{{\mathrm{obs}}}
\newcommand{\ctch}{{\mathsf{catch}}}
\newcommand{\done}{{\mathsf{done}}}
\newcommand{\emp}{{{0}}}

\newcommand{\CG}{{\cal{CG}}}
\newcommand{\ub}{{\cal{G^U}}}
\newcommand{\dom}{{\mathrm{dom}}}
\newcommand{\ass}{{\mathtt{ass}}}
\newcommand{\lbl}{{\mathsf{label}}}
\newcommand{\throw}{{\mathtt{throw}}}
\newcommand{\cb}{{\cal{CG_{B}}}}
\newcommand{\goto}{{\mathsf{goto}}}
\newcommand{\jus}{{\mathsf{just}}}
\newcommand{\capture}{{\mathtt{capture}}}
\newcommand{\scheme}{{\mathtt{Scheme}}}
\newcommand{\set}{{\mathtt{set}}}
\newcommand{\deref}{{\mathtt{deref}}}
\newcommand{\If}{{\mathtt{If}}}
\newcommand{\jump}{{\mathsf{jump}}}





\newcommand{\trm}{{\mathrm{Tm}}}
\newcommand{\prog}{{\mathrm{Prog}}}
\newcommand{\eval}{{\mathrm{Eval}}}
\newcommand{\lett}{{\mathtt{let}}}
\newcommand{\with}{{\mathtt{with}}}

\newcommand{\fmla}{{\mathrm{Fmla}}}
\newcommand{\pending}{{\mathsf{pending}}}
\newcommand{\ok}{{\mathsf{ok}}}
\newcommand{\caught}{{\mathsf{caught}}}
\newcommand{\store}{{\mathcal{S}}}

\newcommand{\open}{{\mathsf{open}}}
\newcommand{\lamstat}{\lambda_R}
\newcommand{\statcon}{\lambda_{RC}}
\newcommand{\lamex}{\lambda_E}
\newcommand{\lamcon}{\lambda_C}
\newcommand{\statex}{\lambda_{RE}}
\newcommand{\lcre}{\lambda_{RCE}}
\newcommand{\lsrc}{\lesssim_{RC}}
\newcommand{\eqrc}{\simeq_{RC}}
\newcommand{\eqrce}{\simeq_{RCE}}
\newcommand{\spc}{\hspace{2pt}}
\newcommand{\nt}{\mathrm{Nat}}
\newcommand{\inj}{\mathrm{in}}
\newcommand{\inl}{{\mathtt{in_l}}}
\newcommand{\inr}{{\mathtt{in_r}}}
\newcommand{\dist}{\mathrm{dist}}
\newcommand{\ml}{\lambda_{\mathtt{exn}}^{\mathtt{ref}}}
\newcommand{\lom}{\Lambda(\bot)}
\newcommand{\callcc}{{\mathtt{callcc}}}
\newcommand{\quoth}{{\textnormal{'}}}
\newcommand{\nat}{{\mathtt{nat}}}
\newcommand{\Lr}{{\cal{L_R}}}
\newcommand{\Lc}{{\cal{L_{RC}}}}
\newcommand{\Lle}{{\cal{L_X}}}
\newcommand{\Lce}{{\cal{L_{RCE}}}}
\newcommand{\Llce}{{\cal{L_{CX}}}}
\newcommand{\xn}{\ {\mathtt{exn}}}
\newcommand{\nxn}{{\mathtt{new\_exn}}}
\newcommand{\thread}{{\mathsf{thread}}}
\newcommand{\threads}{{\mathsf{threads}}}
\newcommand{\unit}{{\mathtt{unit}}}
\newcommand{\refn}{{\mathtt{ref}}}

\newcommand{\mkxn}{{\mathtt{mkexn}}}
\newcommand{\mkvar}{{\mathtt{mkvar}}}
\newcommand{\var}{{\mathtt{var}}}
\newcommand{\pcf}{{\mathrm{PCF}}}
\newcommand{\callc}{{\mathsf{callcc}}}

\newcommand{\rais}{{\mathtt{raise} }}
\newcommand{\handle}{{\mathtt{handle}}}
\newcommand{\new}{{\mathtt{new}}}
\newcommand{\xcell}{{\mathsf{exn}}}
\newcommand{\cell}{{\mathsf{cell}}}
\newcommand{\raze}{{\mathsf{raise}}}
\newcommand{\handel}{{\mathsf{handle}}}
\newcommand{\ski}{[()]}
\newcommand{\handl}{{\mathbf{handle}}}

\newcommand{\T}{{\mathbf{T}}}
\newcommand{\Na}{{\mathbb{N}}}
\newcommand{\Fam}{{\mathsf{Fam}}}
\newcommand{\fame}{{\mathsf{fam}}}
\newcommand{\boo}{{\mathtt{bool}}}
\newcommand{\catch}{{\mathtt{catch}}}
\newcommand{\com}{{{1}}}
\newcommand{\exn}{{\mathtt{exn}}}
\newcommand{\sqr}{\square}
\newcommand{\tit}{\blacktriangle}
\newcommand{\blob}{\triangle}
\newcommand{\Cu}{{\EuScript C}}
\newcommand{\abort}{{\EuScript A}}
\newcommand{\arl}{{\longrightarrow}}

\newcommand{\ff}{{\mathbf{ff}}}
\newcommand{\tru}{{\mathtt{tt}}}
\newcommand{\pred}{{\mathtt{pred}}\ }
\newcommand{\then}{{\mathtt{then}}}
\newcommand{\IF}{{\ {\mathrm{IF0}}\ }}

\newcommand{\el}{{{\mathtt{else}}}}
\newcommand{\of}{{\ {\mathtt{of}}\ }}
\newcommand{\suc}{{\mathtt{succ}\ }}
\newcommand{\id}{{\mathsf{id}}}
\newcommand{\pre}{{\mathit{pred}}}
\newcommand{\app}{{\mathsf{app}}}
\newcommand{\init}{{\mathbf{0}}}
\newcommand{\dst}{{\mathsf{dst}}}
\newcommand{\inn}{{{\mathtt{in}}}}
\newcommand{\try}{{\mathtt{try}}}
\newcommand{\catchc}{{\mathtt{callcc}}}
\newcommand{\Lx}{{\cal{L}_{X}}}

\newcommand{\A}{{\cal{A}}}
\newcommand{\W}{{\cal{W}}}
\newcommand{\F}{{\cal{F}}}
\newcommand{\Ap}{\mathrm{App}}
\newcommand{\occ}{\mathrm{Occ}}
\newcommand{\copycat}{{\mathtt{copy}}}
\newcommand{\LAMBDA}{\mathtt{LAMBDA}}
\newcommand{\ter}{{\mathbf{1}}}
\newcommand{\caret}{\raisbox{-0.3ex}{\tt\symbol{"5E}}}
\newcommand{\R}{{{R}}}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{remark}[theorem]{Remark}
\newif\ifqed
\newcommand{\qed}{\global\qedfalse\noindent\unskip\penalty50\null\nobreak\hskip1em\nobreak\hfill}
\def\titlerunning{Combining and Relating Control Effects and their Semantics}
\def\authorrunning{J. Laird}
\newcommand{\eqqed}{\global\qedfalse\eqno\Box}

\let\Box\undefined

\DeclareMathSymbol{\Box}{\mathord}{AMSa}{"03}
\newenvironment{proof}[1][Proof]{\global\qedtrue\trivlist\item[\hskip\labelsep\textsc{#1:}]}{\ifqed\qed\fi\endtrivlist}


\begin{document}\title{Combining and Relating Control Effects and their Semantics }
\author{James Laird
\institute{Department of Computer Science, University of Bath, UK}}
\date{}
\maketitle
\begin{abstract}Combining local exceptions and first class continuations leads to programs with complex control flow, as well as the possibility of expressing powerful constructs such as resumable  exceptions.  We describe and compare games models for a  programming language which includes these features, as well as higher-order references. 
They are obtained by contrasting methodologies: by annotating sequences of moves with ``control pointers'' indicating where exceptions are thrown and caught, and by composing the  exceptions and continuations monads.
  

 The former approach allows an explicit representation of control flow in games for exceptions, and hence a straightforward proof of definability (full abstraction) by factorization, as well as offering the possibility of a semantic approach to control flow analysis of exception-handling. However, establishing soundness of such a concrete and complex model is a non-trivial problem. It may be resolved by establishing  a correspondence  with the monad semantics, based on erasing explicit exception moves and replacing them with control pointers.  
\end{abstract}


\section{Introduction}
Control effects such as exceptions and continuations are  key features of higher-order programming languages. They are typically used to recover from errors, and may result in complicated and unpredictable control flow in programs. Therefore, principles for reasoning about notions such as \emph{exception safety} are potentially useful and important. Denotational semantics provides one basis for such principles. Here, broadly speaking, there are two  approaches to describing computational effects.  Constructions such as \emph{monads}, and \emph{continuation-passing-style interpretations} yield  useful algebraic theories for reasoning \emph{soundly} about programs, although they impose additional layers of definition and interpretation through which reasoning about programs must be filtered, particularly in the presence of  properties such as locality. By contrast, \emph{game semantics} provides a framework in which to model combinations of effects more directly by the relaxation of constraints on strategies representing functional programs. This approach has  been used successfully to give \emph{fully abstract} interpretations of many features, including an   account of locality for  features such as state \cite{AHM}. However, the  combinatorial nature of games models means that reasoning about denotations  --- for example, proving basic soundness results --- can be  difficult in the absence of structuring principles.


Thus it can be useful to relate the direct (games) and indirect (monads, CPS) approaches to effects, to gain the advantages of both representations. This paper will do so for exceptions and continuations. In the process, we construct a first fully abstract model for a language which combines continuations and locally declared exceptions, as in Standard ML of New Jersey. Although many control structures can be implemented using either feature, exceptions and continuations exhibit several subtle but significant differences in behaviour: one way of understanding these is by studying the interaction of the two effects in combination. (For example, observing that exceptions break key equational rules which hold for continuations \cite{LE}.) 
Combining exceptions and continuations also provides a way of interpreting further, powerful control constructs: they may be used to macro-express \emph{resumable} exceptions, and implement dynamic delimited control operators such as \emph{prompts} \cite{GRR}.


Exceptions and continuations also provide a test case for semantic theories of  combining  algebraic effects,  studied in detail in \cite{HLPP}. Here we shall simply use the fact that  there is a distributive law of the monad  (exceptions) over   (continuations)  (which exist for objects   and  whenever the relevant categorical constructions do), since the exceptions monad  distributes over any other monad.  Thus we have an exceptions-and-continuations monad .  



How can this monad  be related to a game semantic account?  In the case of  first-class continuations (on their own), there is a simple correspondence between the games and monadic interpretations --- relaxing the \emph{well-bracketing condition} on strategies renders  the lifted sum  monad  introduced in \cite{AMV}  isomorphic to the continuations monad , where  is the  ``one-move game'', giving both direct and indirect (continuation-passing style) interpretations of  call/cc \cite {LT}. 

 
 

The case of exceptions is more complicated.  We may interpret a single global exception by adding to our games distinguished ``exception answer'' moves for each question. Extending the continuations monad with such an answer yields a monad formally equivalent to \footnote{Another approach in \cite{ntex} also uses an exceptions monad on a category of nominal games --- here we focus on more concrete models with implicit state.} In the presence of local state, this is sufficient to macro-express  local exception declaration, as we may use imperative variables both as flags to indicate which exception has been set, and to carry exceptional values. However, this leaves open the problem of identifying the elements of the model definable using local exception handling, and their intrinsic equivalence.  
 


Exceptions have also been more difficult to incorporate into the simple picture of relaxing constraints on strategies to get more powerful effects;  locally declared exceptions can be interpreted directly by relaxing the bracketing condition to a ``weak bracketing'' condition \cite{Lli}, but fully capturing this behaviour also  requires new information to be added to strategies in the form of additional ``control pointers'' attached to sequences. 
 Relaxing the weak bracketing condition also gives a  straightforward and intuitively natural alternative denotation for call-with-current-continuation in the context of exception handling --- playing a control pointer to  a ``closed'' move allows the handler-context to be reset. However, this representation of continuations and exceptions is rather implicit, and does not lend itself to reasoning about equivalence between denotations of programs --- even to the limited extent of  proving soundness with respect to the operational semantics.



The solution adopted here is a  correspondence with the exceptions monad and CPS interpretations, given by relating exception-arenas to control games by replacing exception moves with control pointers (in this case, indicating which question is \emph{pending} when an exception is thrown).  Finally, we prove  full abstraction results for the control games models using \emph{factorization} into the model with only local control defined in \cite{AHM}.  





\section{An Effectful Functional Programming  Language} 
We shall first describe a simply-typed call-by-value programming language  with (locally declared) general references,  first-class continuations and local exceptions (which might be considered as a simply-typed fragment of SML of New Jersey). The core of the language, , is a simply-typed call-by-value -calculus based on the computational -calculus \cite{MogC}.

  \emph{Types} of  are generated  from the product, sum (and their units   and ) and function types:\\
\\
We distinguish \emph{computation} and \emph{value} terms.
\emph{Values} are given by the grammar:\\
\begin{tabular}{l l}
 &\\

\end{tabular}\\ 
\emph{Computations} are given by the grammar:\\
\begin{tabular}{l l}
 &\\

\end{tabular}\\
 Typing judgements, of the form  for computations, and  for values,  are given in Table 1. We write  for , if  is not free in  or . 

\subsection{Computational Effects}
Computational effects  are introduced by adding constructs for declaring references and exceptions, and capturing the current continuation as a first-class function, as follows: 

\paragraph{References} The type  of references to values of type  is \emph{defined}  to be  --- the product of the types of its methods, assignment and dereferencing, which may be recovered by left and right projection, respectively ---  i.e. given  and , we sugar  as , and  as .

Thus the only further  syntax we need to add to our type theory  is a constant (value)  for declaring a new reference. We write      as . 

\paragraph{Exceptions} The type of  of exceptions is similarly defined to be the product    of its method types: \emph{throwing} of type  and \emph{catching}, of type .\footnote{The ``thunked'' empty type  is used to represent the type of computations which do not return a value.}  Given , we sugar    and  as  and , respectively. 

Thus to extend our type theory with exceptions it is sufficent to add a value  for declaring a new exception. 
  
\paragraph{Continuations} As in New Jersey SML, we introduce first-class continuations via a value , which passes a first class representation of the current \emph{continuation} (as a value of type  for arbitrary ) to its argument.  


\begin{table}
\begin{center}
\begin{tabular}{c c c} 
{\Large } & {\Large }  & {\Large }\\\\
{\Large }&  & {\Large } \\\\
{\Large } & & {\Large }  \\\\
{\Large }\mbox{}& & {\Large }\\\\
{\Large } & & {\Large }\\\\
\end{tabular}
\caption{Typing Judgements for Computations and Values}
\end{center}
\end{table}
We make use of the following fragments of  --- the purely functional fragment ,  the fragment   with local control  (i.e. references but no continuations or exceptions, omitting  the constants  and : this is essentially the language   defined  in \cite{AHM}, with its games model), and   the fragment  with continuations and references but no exceptions. 
\subsection{Operational Semantics}
To give an operational semantics for , we introduce constants representing the capacity to read from and write to a location, and raise and handle an exception, and  a new constructor, representing composition with the top-level continuation. 
Let  be the extension of  with:
\begin{itemize}
\item An unbounded set of pairs of constants .
\item An unbounded set of pairs of constants . 
\item An operation  taking computations of type  to computations of type . 


\end{itemize}
\emph{Evaluation contexts}  are given by the grammar:
 
 denotes an evaluation context without a   in the spine --- i.e. given by the above grammar subject to  .  

The  ``small-step'' operational semantics for reducing a term in an environment  (a set of location names  and store , and a set of exception names )  is given in  (Table \ref{ops2}). Variable names not occurring on the left of a rule are assumed fresh.
\begin{table}
\begin{center}
\begin{tabular}{l c l}
&& \\ 
 &&\\
&& \\  &&\\
 &  & \\
&& \\ &&\\ 
 && \\
&& \\
 & & \\
 & & 

\end{tabular}
\caption{Operational Semantics of }\label{ops2}
\end{center} 
\end{table}
For a program (computation) , we write  if  reduces to . Observational approximation and  equivalence are defined with respect to this  notion of convergence:  if for all closing contexts, ,  implies .  if  and .


\subsection{Expressiveness}
We make some remarks on the expressiveness of our language. Although we have used a simplified version of exceptions   which  do not carry explicit  values, we may macro-express value-carrying  exceptions by using references to pass values through the store. For example, for any type , define the type  of exceptions carrying values of type  to be  , so that applying  right-projection to a value raises an exception with that value, and applying left projection to a (thunked) computation captures an exception and returns the value it carries.  Then we may define an object declarating an exception of type  --- 
     



We may represent ML or Java-style exception \emph{handling} --- i.e. including code to be run if only if a given exception is caught --- by using exceptions \emph{or} continuations to escape from the handler context if an exception is not raised, defining e.g.
 


By combining references, exceptions and continuations we may express \emph{resumable exceptions} which may return to the point at which they were raised. 
e.g. define the declaration  as follows: 

Right projection captures the current continuation and raises a (local) exception, left projection traps the exception and returns the continuation from the point it was thrown as a first-class function. 






Finally, we note that exceptions and continuations are used in \cite{GRR} to implement prompts in Standard ML of New Jersey. Prompts are a form of locally declared, dynamically bound, delimited control operator which may be used to express   local exceptions, as defined here, and a \emph{delimited} form of . However, the implementation of prompts in SML uses global variables and is not therefore fully compositional: we leave a semantic investigation of the relationship between exceptions, continuations and delimited control as future work.  
\section{Denotational Semantics: Preliminaries}
First, we fix what we mean by a model of the type-theory  (essentially, a model of the computational -calculus \cite{MogC}): 
\begin{itemize}
\item a category  with finite, distributive  coproducts and products (including terminal and initial objects) and 
\item a strong monad  on  such that for any  and  in , the exponential  exists. 
\end{itemize}
\emph{Types} are interpreted  as objects of   ---   and   are the terminal and initial objects and  ,  and  . \\
For a context , define .  
\begin{itemize}
\item \emph{Values}  are interpreted as morphisms from  to .  
\item \emph{Computations}  are interpreted as  morphisms from  to \Gamma\Gamma,x:T \vdash_v x:T\Gamma \vdash_v \langle U,V \rangle:   S\times T\Gamma \vdash_v \inj_i(V):T_1+ T_2\Gamma \vdash_v \lambda x.M:S \rightarrow T\Gamma \vdash_c \void(V):T\Gamma \vdash_v V:0T\\
 &&\\
&&\Gamma\Gamma \vdash_v V:S_1 \times S_2\Gamma,x:S_1,y:S_2\vdash_c M:T\Gamma \vdash_c \lett \spc M = x\spc \inn\spc N:TM\xymatrix@R=0pt@C=0pt{(\Sigma 0 & \Rightarrow & \Sigma\1) & \Rightarrow & \Sigma\1 \\ 
& & & & \lbl \\
& & \ok \ar@/^1pc/@{-->}[rru] \\
\jump  \ar@/^1pc/@{-->}[rru] \\
& &  & &\caught }. 
\end{proposition}

\section{Control Strategies}
We now extend the game semantics of  with continuations and exceptions, to interpret . We retain the interpretation of -types as (families of) arenas, but change the notion of strategy by  adding control-flow information to justified sequences in the form of ``control pointers''. (These were introduced in  \cite{Lli} in the context of interpreting a call-by-name language without first-class continuations: here, we relax the \emph{weak bracketing condition} imposed in that model.  
\begin{definition}\label{cs} A \emph{control sequence}   over an arena  is an alternating justified  sequence  over , together with a \emph{control pointer} from each question  move  in   either to a unique preceding question (or else to a distinguished root token ) --- such that Opponent moves point to  Player moves or  and Player moves point to Opponent moves. 
\end{definition}
We write  for the set of  control sequences over the  arena . A \emph{control strategy} on  is  a non-empty, even-prefix-closed set of even-length control sequences in ,  satisfying the determinacy and thread-independence conditions. 

In order to use our definition of composition for control strategies, we need to define the restriction operator on control sequences to replace ``dangling'' control pointers, by following back pointers  to hidden moves until an unhidden move is reached. Accordingly, we define the set of  \emph{open questions} of a control sequence  as follows:\\
,\\
, if  is an answer\\ 
 if  is a question with  a control pointer to ,\\ 
, if  points to .\\

We extend the restriction operation to control sequences by requiring that every move in   points to the most recent preceding open move which is in  (if any). 
With this definition of restriction, the original proofs of  well-definedness and associativity of parallel composition plus hiding  \cite{McCT} extend straightforwardly to control strategies.
 




To form a category, we also need to define identity morphisms (and other copycats) as control strategies.  Say that a control sequence   satisfies  (player) \emph{control locality} if every Player question in  points to the pending question: let  be the set of control sequences over  which satisfy this condition. Given a  strategy on , we may define a local control strategy   on  by taking all player-local sequences which correspond to sequences in  when pointers are ignored  i.e. . (In other words, by decorating sequences in  by adding control pointers from each Opponent question to some Player question, and from each Player question to its pending  question.)
 We define the identity control strategy to be  (and similarly for the other copycat strategies giving cartesian closed structure).   So  we may define a cartesian closed category  in which objects are arenas, and morphisms from  to  are  control strategies on . 

We also observe that:
\begin{itemize}
\item The operation  is not functorial: the  arenas  and  are isomorphic in  but not in : the  composition of the images of these isomorphisms under  is not .
 \item  \emph{is} functorial on well-bracketed strategies:  there is a faithful, identity-on-objects functor  sending  to .
\end{itemize}

\subsection{Semantics of Exceptions}
 has structure with which to  model  --- (it is a CCC with a strong lifted sum monad  on . The functor  preserves all of this structure, and hence the meaning of -terms. We interpret new reference declaration, and  call-with-current-continuation by decorating the corresponding underlying strategies with control pointers: i.e.
\begin{itemize}
\item \callcc\xymatrix@R=-1pt@C=5pt{ \Sigma & (\Sigma\0 & \Rightarrow & \Sigma\1 & \times & \Sigma\0) \\ 
q\\
a\\
&& & {\mathsf{try}}  \ar@/_1pc/@{-->}[lllu] \\
&\ok \ar@/^1pc/@{-->}[rru] \\
& & &  & \vdots \\
&& & & & \raze  \ar@/^1pc/@{-->}[lllluu] \\
& & & \caught \ar@/_1pc/@{-->}[uuuu]}\xymatrix@R=-1pt@C=5pt{ \Sigma & (\Sigma_E\0 & \Rightarrow & \Sigma_E\1 & \times & \Sigma_E\0) \\ 
q\\
a\\
&& & {\mathsf{try}}   \\
&\ok  \\
& & &  & \vdots \\
& & & & & \raze   \\
& & & & &  e(\raze)\\
&  e(\ok)\\
& & & \caught}\xymatrix@R=-1pt@C=5pt{ \Sigma_E & (\Sigma_E\0 & \Rightarrow & \Sigma_E\1 & \times & \Sigma_E\0) \\ 
q\\
a\\
& & & {\mathsf{try}}  \\
&\ok  \\
& & &  & \vdots \\
&  e(\ok)\\
& & & e({\mathsf{try}})}\Gamma \vdash M:TM^{E}\lambda ().\new\spc x:=\ff.[\inj_1(\langle \handl(e),\rais(e)\rangle)]  
\end{proposition}



\section{Relating Control Games to the Exception Monad} 
We now relate the monadic and  control-games interpretations of  by  establishing a correspondence between the two models: a meaning-preserving functor into  from a subcategory of   consisting of exception-arenas and \emph{exception-propagating strategies}. 

 A sequence  over  is \emph{exception-propagating} if whenever Opponent raises an exception, Player always propagates it by playing the exception-answer to the pending question, and vice versa. Formally, define the set of exception-propagating sequences to be the least set of justified sequences such that:
\begin{itemize}
\item The empty sequence is exception-propagating, 
\item If  is exception-propagating, and  is not an exception move, then  is exception-propagating.
\item If  (of even length) is exception-propagating then  is exception-propagating, where  is the pending question of .
\end{itemize}
 We write  for the set of exception-propagating control sequences on .
 Recall that we defined   to be the arena obtained by erasing all of the exception-answers in . Given  we define a control sequence  on  by:
\begin{itemize}
\item First, adding a control pointer from each question to its  pending question (or the token  otherwise).
\item Then, deleting all exception answers.   
\end{itemize}
This is a well-defined control sequence; it is alternating since if  is exception-propagating then all exception-moves  in  come in adjacent pairs. Control pointers alternate in polarity  since the pending question is always of opposite polarity to the move about to be played (and there is always a pending question at any Player move). For an example, the first typical play given for the  new-exception strategy  (Fig. 1) is transformed to the typical play given for the corresponding control strategy   


Extend the definition of  to all justified sequences on the exception-arena   by letting , where  is the greatest exception-propagating prefix of . A \emph{strategy}  on  is \emph{exception-propagating} if  is a well-defined (thread-independent) control strategy. In other words:
\begin{itemize}
\item  consists of even-length sequences ---  always propagates exceptions raised by Opponent. 
\item  is even-branching ---  ignores exceptions raised by Opponent once they have been handled (but not their effect on the exception handling context). 
\end{itemize}  
We show that this is a compositional property of strategies, and that the action of  is functorial, based on the following lemma:
\begin{lemma}Given  , if  and  are legal and exception-propagating, then:
\begin{itemize}
\item   is exception-propagating. 
\item .  
\end{itemize}
\end{lemma}
\begin{proof}Since the  and  are exception-propagating, any runs of exception-answers occur in even-length blocks in , and erasing the part in  leaves an exception-propagating sequence.

We show by induction on the length of  that the pending question in  is the pending question in the relevant fragment  or , and so control pointers in  and   agree.  
\end{proof}Based on this lemma, we show:
\begin{proposition}The composition of exception-propagating strategies is exception-propagating. 
\end{proposition}

It is straightforward to verify that the identity strategy is exception propagating, with . Hence:
\begin{itemize}
\item Exception-propagating strategies  form a lluf subcategory  of . 
\item  acts as a functor from  to .
\end{itemize}
 Evidently,   preserves Cartesian closed structure, and . So for -types we have . Moreover, if we  apply  to the exception-completion of a strategy, this is equivalent to decorating with control-pointers to the pending moves --- i.e. . So  preserves the meaning of -terms. It remains to check that this is the case for exception declaration.
\begin{lemma} is exception-propagating, and  . 
\end{lemma}
\begin{proof}
Recall that  is the set of well-bracketed plays . This is evidently exception-propagating, and erasing the exception moves on exception-propagating plays leaves a control sequence  of the form , where  the pending  move in the original sequence becomes the target of a control pointer and hence the most recent open handler as required. 
\end{proof}
Thus we have shown that:
\begin{proposition}Every -term  denotes an exception-propagating strategy such that .  
\end{proposition}
and hence established soundness and adequacy for the exception-arena semantics. 
\begin{proposition} if and only if  is the denotation of a  term .
\end{proposition}
Since  preserves the meaning of -terms, every compact strategy in the image of  is definable --- i.e. all compact, local well-bracketed strategies which also satisfy the following condition:
\begin{description}
\item [Control blindness] is a deterministic strategy on .
\end{description}
\begin{corollary}\label{ldef}Every  compact local, well-bracketed and  control-blind  strategy over an  type-object is definable as a term of . 
\end{corollary}
We now factorize any compact control-blind strategy into the composition of a definable strategy with the denotation of . 
\begin{lemma}For any (compact) control-blind strategy   there is a (finitary) local, well-bracketed  strategy  such that  .
\end{lemma}
\begin{proof}This is essentially the factorization given in \cite{L}: we define a map  from control sequences to Player well-bracketed sequences in  which interjects  after each Opponent question, and blocks of  moves before each Player answer, so that  any intervening questions are closed.






\end{proof}
So it remains to show that control-blind strategies may be factorized as the composition of a local control strategy with the strategy . 
\begin{lemma}For any (compact) control strategy  there is a (compact) control-blind strategy  such that  
\end{lemma}
\begin{proof}
We define a map  from control sequences on  to control sequences on  which makes all control pointers on -moves manifest. It raises an exception before each Opponent move, and handles it  after each -move. The handler which catches the raised exception is determined by the control pointers from -moves in , so that   implies  . Since  , and   , we have   as required
\end{proof}
For any compact strategy,  if and only if .
\end{theorem}





\section{Conclusions and Further Directions}
\paragraph{Model checking exceptions}
Giving different representations of exceptions in games models may be useful in the developing field of program-verification based on semantic games. For example, we may observe that the set of exception-propagating sequences over a finite alphabet (with a specified subset of distinguished exception tokens) is regular, giving a way of extending results characterizing finite-state representable fragments of imperative languages to include local exceptions. On the other hand control pointers describe control flow (and, in particular,  exception handling points) directly, and so adding them to  game semantic approaches to control flow analysis \cite{MH} offers the possibility of reasoning about e.g. exception safety.
\paragraph{Delimited Control}  Further instances of delimited continuations such as locally declared, dynamically bound \emph{prompts} \cite{GRR} could be modelled by a similar analysis relating CPS interpretation to the stateful behaviour in games models.
\paragraph{Good Variables} Languages such as ML and Java have explicit exception types, so that an object of exception type must behave as an exception, whereas there is clearly no such constraint on  objects of the product type which we have used as an exception type. Extending our full abstraction results to such languages is liable to require some characterization of such behavioural constraints. This problem is analogous to the ``good variable'' problem for references, and we may look to research in this area for approaches to model ``good exceptions''  \cite{ntex}. Implementing \emph{wildcard handling} (e.g. Java's ) becomes straightforward when exceptions are passed as names through an exceptions monad, although a wildcard handler typically cannot trap an exception and then discover its name, and so a model should reflect this constraint. 

\bibliography{names}
\section*{Appendix: Soundness for  via CPS translation }
We give an interpretation of  in  --- a  CPS translation corresponding to the action of the CPS monad on our denotational model.  
This acts on types as follows:
\begin{itemize}
\item , ,
\item ,
\item ,
\item .
\end{itemize}
Values  are translated as values  and computations  are translated as \emph{values}  as defined in Table 3.

\begin{table}
\begin{itemize}
\item ,\ \ \  

\item   
\item  ,\ \ \ \  
\item  \ \ \ \  
\item ,\ \ \  .
\item  ,\  \\
 
\item  
 \item     
\end{itemize}
\caption{CPS translation of exception-free terms}
\end{table}
Extending to  by setting   (where  is a variable representing the top-level continuation), we may show that reduction of a term tracks that of its translation: 
\begin{proposition}For any program ,  if and only if   
\end{proposition}
We note that CPS interpretation corresponds (up to isomorphism) to the interpretation of -types and terms:
\begin{proposition}For any -type , there is an isomorphism of arenas \Gamma \vdash M:TM^{C}M \not = \bot$. 
\end{proposition}
\end{document}
