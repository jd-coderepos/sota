
\documentclass{article} \usepackage{iclr2023_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{booktabs}   
\usepackage[pdftex]{graphicx}
\usepackage{url}
\usepackage{multirow}
\usepackage{subcaption}
\usepackage{pifont}\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}
	
\usepackage{color, colortbl}
\definecolor{Gray}{gray}{0.9}
\definecolor{LightCyan}{rgb}{0.88,1,1}
\definecolor{ForestGreen}{rgb}{0.13, 0.54, 0.13}
\definecolor{light-gray}{gray}{0.85}

\title{Jointly Learning Visual and Auditory Speech Representations from Raw Data}





\author{Alexandros Haliassos\textsuperscript{1}\thanks{Work done at Meta AI.}\hspace{-0.15cm}
\And
Pingchuan Ma\textsuperscript{1}\hspace{-0.3cm}
\And
Rodrigo Mira\textsuperscript{1}\hspace{-0.3cm}
\And
Stavros Petridis\textsuperscript{1,2}\hspace{-0.3cm}
\And
Maja Pantic\textsuperscript{1,2} \vspace{0.2cm}
\and
\hspace{3.5cm}\textsuperscript{1}Imperial College London
\and
\textsuperscript{2}Meta AI \hspace{3.5cm} \vspace{0.2cm}
\and
\hspace{2.9cm}{\tt alexandros.haliassos14@imperial.ac.uk}
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
We present RAVEn, a self-supervised multi-modal approach to jointly learn visual and auditory speech representations. Our pre-training objective involves encoding masked inputs, and then predicting contextualised targets generated by slowly-evolving momentum encoders. Driven by the inherent differences between video and audio, our design is \textit{asymmetric} w.r.t. the two modalities' pretext tasks: Whereas the auditory stream predicts both the visual and auditory targets, the visual one predicts only the auditory targets. We observe strong results in low- and high-resource labelled data settings when fine-tuning the visual and auditory encoders resulting from a \textit{single} pre-training stage, in which the encoders are jointly trained. Notably, RAVEn surpasses all self-supervised methods on visual speech recognition (VSR) on LRS3, and combining RAVEn with self-training \textit{using only 30 hours} of labelled data even outperforms a recent semi-supervised method trained on \textit{90,000} hours of non-public data. At the same time, we achieve state-of-the-art results in the LRS3 low-resource setting for auditory speech recognition (as well as for VSR). Our findings point to the viability of learning powerful speech representations entirely from raw video and audio, \textit{i.e.}, without relying on handcrafted features. Code and models are available at \url{https://github.com/ahaliassos/raven}.
\end{abstract}

\section{Introduction}

The sound of someone articulating words coincides with the sight of movements in and around their mouth. Both a recording of a speech waveform and a corresponding silent video of mouth motion provide rich - but not identical - information on which words were uttered. Despite the difficulty of interpreting lip movements compared with an audio waveform, the task of visual speech recognition (VSR; also known as lipreading) has important applications, ranging from recognising utterances in a noisy environment \citep{ma2021end, afouras2018deep, martinez2020lipreading, makino2019recurrent} and aiding people suffering from aphonia (an inability to speak), to transcribing archival silent films and detecting DeepFake videos \citep{haliassos2021lips}.

Auditory (also known as automatic) speech recognition (ASR) and VSR benefit greatly from the combination of high-capacity neural networks and large datasets. Rapid advances of modern hardware are enabling the use of ever-growing, data-hungry networks, but the effort required for transcription hinders the scaling of labelled data along with the models. One way to leverage unlabelled videos for VSR is to use an external ASR model for pseudo-labelling \citep{afouras2020asr, ma2022visual}. However, this requires a large amount of labelled data to train a strong ASR model in the first place, and supervised VSR training with long sequences often poses optimisation problems, requiring costly curriculum learning strategies \citep{chung2017lip, ma2022visual} or pre-training the feature extractor with isolated words \citep{afouras2018deep, ma2021end}.

A solution is to first learn, in a self-supervised way, general representations from large corpora of unlabelled data, and then fine-tune them on smaller labelled datasets \citep{mohamed2022self}. The fine-grained correspondence between the (synchronised) visual and auditory modalities provides a natural source of self-supervision, and can produce highly semantic representations invariant to noise not shared between the modalities. However, approaches leveraging this correspondence either (1) only work for word-level samples rather than continuous speech \citep{chung2016out, chung2019perfect, chung2020seeing}; (2) use handcrafted features (\textit{e.g.,} spectrograms or MFCCs) as their inputs or targets \citep{ma2021lira, shi2022learning}, which contain inductive biases that may influence the learned representations; (3) use multi-stage pre-training procedures \citep{ma2021lira, shi2022learning, pan2022leveraging}; and/or (4) use separate pre-training strategies for VSR and ASR \citep{shi2022learning}, complicating the process of obtaining representations suitable for both tasks.

In this paper, we present a single-stage self-supervised approach that jointly learns visual and auditory speech representations from raw video and audio only. We dub our approach RAVEn (\textbf{R}aw \textbf{A}udio-\textbf{V}isual Speech \textbf{En}coders). It involves a pair of student-teacher networks for each modality, whereby the students encode temporally-masked inputs, and, through the use of lightweight Transformer-based predictors, regress outputs of momentum-based teachers \citep{grill2020bootstrap, caron2021emerging} that are presented with unmasked inputs. Further, given that audio contains more information relevant to speech than video, we propose a learning strategy that accounts for the expected difference in the quality of targets between the modalities. Namely, while the audio student predicts outputs from both video and audio teachers (cross- and within-modal learning), the video student predicts only auditory targets (cross-modal learning). As we show, this setup leads to better downstream performance for both VSR and ASR as opposed to other strategies.

We conduct experiments with models and datasets of different sizes. We find that, when fine-tuning our pre-trained models for VSR and ASR with only 30 hours of labelled data from LRS3 \citep{afouras2018lrs3}, RAVEn surpasses recent self-supervised methods by a large margin in most settings. Coupling pre-training with self-training reaches 23.8\% WER for VSR on LRS3, even outperforming a method trained on \textit{3000} more transcribed hours \citep{serdyuk2021audio}. At the same time, we are better than or on par with the recent AV-HuBERT method \citep{shi2022learning} on ASR, without using a task-dependent pre-training strategy nor handcrafted features. Using the full 433-hour LRS3 dataset for fine-tuning pushes the results even further, achieving 23.1\% / 1.4\% WER for VSR / ASR, respectively. Similarly strong performance is observed on the LRS2 dataset (Appendix \ref{sec:lrs2}).

\section{Related Work}
\paragraph{Masked prediction.} The pre-training task of predicting missing content given masked inputs has proven successful in various domains, such as natural language processing \citep{devlin2018bert, radford2018improving, radford2019language, brown2020language}, image recognition \citep{he2021masked, xie2021simmim, bao2021beit}, and speech recognition \citep{baevski2020wav2vec, hsu2021hubert, shi2022learning}. An important aspect of masked prediction is the nature of the targets. Some works \citep{he2021masked, xie2021simmim} use pixels as targets; others use pre-trained tokenisers \citep{bao2021beit} or modality-specific handcrafted features \citep{wei2021masked, hsu2021hubert, shi2022learning}. Our method, in contrast, generates targets from \textit{raw video and audio} using momentum encoders. 

\paragraph{Self-distillation for unsupervised representation learning.} RAVEn is partly inspired by the success of self-distillation in self-supervised learning with visual data \citep{grill2020bootstrap, caron2021emerging}; such works target invariance w.r.t. image-specific augmentations. In contrast, RAVEn does not rely on domain-specific augmentations but rather on a combination of cross-modal learning and masked prediction to drive representation learning for visual and auditory speech signals. data2vec \citep{baevski2022data2vec} combines masked prediction with a momentum encoder, but, aside from being uni-modal, it is different methodologically in multiple ways. For example, it applies ad-hoc normalisation and averaging techniques to the targets to prevent representation collapse, while our targets are simply the outputs of the encoders, which are regressed via Transformer-based heads.

\paragraph{Self-supervised audiovisual learning.} Audiovisual correspondence has been used to learn global representations for action recognition through the use of clustering \citep{alwassel2020self, asano2020labelling}, contrastive learning \citep{arandjelovic2017look, arandjelovic2018objects, korbar2018cooperative, patrick2020multi, morgado2021audio, ma2021contrastive}, or representation matching \citep{recasens2021broaden}. Cross-modal learning has also found uses in biometric matching \citep{nagrani2018learnable, nagrani2018seeing}, emotion recognition \citep{shukla2021does}, and DeepFake detection \citep{haliassos2022leveraging}. We employ cross- and within-modal losses to learn temporally-varying speech representations.

\paragraph{Self-supervised audiovisual learning for speech recognition.} Earlier audiovisual self-supervised works \citep{chung2016out, chung2019perfect, chung2020seeing} tended to focus on word-level lipreading. Recently, some attention has been paid to the more realistic task of \textit{continuous} speech recognition \citep{ma2021lira, shi2022learning, sheng2021cross, pan2022leveraging, ma2021contrastive}. \citet{sheng2021cross, ma2021contrastive} use contrastive learning and apply their method to VSR. \citet{ma2021lira} predict speech features using an external PASE+ encoder \citep{ravanelli2020multi}. \citet{pan2022leveraging} transfer pre-trained visual and auditory encoders, which were separately trained via contrastive losses. AV-HuBERT \citep{shi2022learning} predicts iteratively-refined cluster assignments from masked audiovisual inputs and achieves impressive VSR and ASR performance. It employs multiple stages of alternating between offline clustering and cluster assignment prediction, and relies on hand-crafted audio features (MFCCs) for cluster initialisation, which is shown to be crucial to the performance \citep{shi2022learning}. We demonstrate that it is possible to jointly learn effective representations for VSR and ASR in a single stage simply from raw video and audio.

\section{Method}
\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{figures/overview_anonym_png.png}
  \caption{\textbf{RAVEn overview}. Given masked video and audio, students predict outputs of unmasked momentum teachers, via shallow Transformer predictors that intake mask tokens. The audio student predicts outputs from both audio and video teachers; the video student predicts only audio targets. Cross-modal losses are applied on all features; the within-modal loss is computed only on masked features. Only the student encoders are fine-tuned for VSR/ASR. Frames blurred for anonymity.}
  \label{fig:overview}
\end{figure}

\subsection{Pre-training}

Our architecture consists of a pair of student-teacher networks per modality (see Figure \ref{fig:overview}). The students intake masked inputs and predict targets formed by teachers receiving unmasked inputs.

\paragraph{Masking.} We employ masking to encourage the students to take context into account when solving the task. Given a grayscale video  with resolution  and  frames, and an audio sample  of length , we randomly sample with probability 0.2 each video frame to be the starting mask index, and if selected, then the consecutive three frames are zeroed out (ablation in Section \ref{sec:pretrain_abl}). A similar mask is applied to the auditory input, except that it is enlarged by a factor of  (since the audio is sampled at 16,000 Hz and the video at 25 fps).

\paragraph{Encoders.} The masked video and audio,  and  respectively, are fed to their corresponding student encoders  and , yielding features  and , where  is the dimensionality of each feature. Both  and  consist of a modality-specific, convolutional feature extractor followed by a temporal encoder, as in related VSR/ASR works \citep{ma2022visual, baevski2020wav2vec}. The video feature extractor is a 2D ResNet18 \citep{he2016deep} with a 3D convolutional stem \citep{petridis2018audio}, outputting an embedding per frame. On the audio side, we use a 1D ResNet18 which produces features at 25 fps, to match the video sampling rate (see Appendix \ref{sec:feature_extractors}). The temporal encoder for each modality is a Transformer \citep{vaswani2017attention} (without a classification head) with hidden size . We use relative positional embeddings \citep{dai2019transformer}, and following \citet{chen2021empirical}, we replace layernorm \citep{ba2016layer} with batchnorm \citep{ioffe2015batch} before each multilayer perceptron (MLP) block (see Appendix \ref{sec:pre_mlp} for a comparison).

\paragraph{Predictors.} 
The students contain Transformer predictors, which regress targets given 1) the encoder outputs corresponding to the unmasked portions of the inputs and 2) mask tokens associated with the masked portions. Note that mask tokens are applied to the predictors rather than the encoders \citep{he2021masked}. This reduces the discrepancy between pre-training and fine-tuning: In both cases, the encoders do not see mask tokens. A predictor that takes representations corresponding to modality  and predicts targets associated with modality  is denoted as . For ease, the application of mask tokens to the encoder outputs is absorbed in the notation. 

Unlike other works which output global representations (one embedding per sample) and thus use MLPs as predictors \citep{grill2020bootstrap, chen2021empirical}, we use Transformers to allow modelling temporal dynamics, which we found greatly improves results. The predictors can be lightweight: Indeed, two-block Transformers with hidden size 512 work optimally in our experiments.

\paragraph{Targets.} The targets are simply the outputs of momentum-based teachers  and  \citep{grill2020bootstrap, caron2021emerging}, which are given as input the unmasked video or audio, in order to force the students to predict the missing information. Each teacher is architecturally identical to its student encoder counterpart. Denoting the parameters of the student encoders and teachers as  and , respectively, at each iteration the following update is performed:

where  specifies the modality and  is a momentum parameter following a cosine schedule from 0.999 to 1. A high value of  leads to slowly-varying teachers and stable targets. The use of momentum-based teachers obviates the need for handcrafted targets or multi-stage training.

\paragraph{Prediction tasks.} The auditory modality contains more information relevant to speech than the visual one: Mouth motion is inherently more ambiguous than a speech waveform due to the presence of homophemes \citep{chung2017lip}. We propose a loss structure which reflects this asymmetry between the modalities. The audio student predicts the targets from both the video and audio teacher, thus benefiting from the ability of cross-modal learning to induce semantic representations, while at the same time being encouraged to retain information from the auditory input that is absent from the visual one. As a result, two predictors are associated with the audio student, one for each target type. On the other hand, the video student only predicts the auditory targets, which are inevitably of higher quality. 

\paragraph{Losses.} The loss function is the negative cosine similarity \citep{grill2020bootstrap}, denoted as sim. Due to the temporal alignment of the inputs, the cosine similarity is applied between pairs of corresponding features and then summed across the time dimension. For the within-modal task (audio-to-audio prediction), the loss is applied only on targets corresponding to masked portions of the input \citep{devlin2018bert}. For the cross-modal tasks, the loss is applied on all targets, which we found to work better. Note that predicting the unmasked portions in cross-modal learning is a non-trivial task (unlike in within-modal learning) and can bolster representation learning.

Denoting the set of mask token indices for audio as , the audio-to-audio prediction loss and cross-modal losses can be respectively expressed as

where , , and sg denotes the ``stop-gradient'' operation, which indicates that no gradient is passed back to the teacher networks..
\paragraph{Objectives.} At each iteration, the objectives for the video and audio students are, respectively,

The teachers are updated via Equation \ref{eq:mom_update}.

\subsection{Fine-tuning} \label{sec:finetune_main}
For fine-tuning, we keep the pre-trained student encoders and discard the rest. We append a linear layer and a Transformer decoder for joint CTC / attention decoding \citep{watanabe2017hybrid}, as in \citet{ma2021end}. Following \citet{ma2021end}, we set the CTC weight to 0.1. We use SentencePiece \citep{kudo2018sentencepiece} subword units with a vocabulary size of 1,000 as our targets.
\paragraph{Self-training.} Combining pre-training with self-training tends to improve results over using either strategy in isolation \citep{xu2021self, shi2022learning}. To that end, we first fine-tune our pre-trained audio encoder on the labelled data, and then use the model for pseudo-labelling the unlabelled data. The pre-trained video and audio models are then fine-tuned using both the labels and pseudo-labels.

\section{Experiments}
\subsection{Setup}
\paragraph{Datasets.} For pre-training, we conduct experiments with LRS3 \citep{afouras2018lrs3} (without the labels) as well as a combination of LRS3 and an English-only version of VoxCeleb2 \citep{DBLP:conf/interspeech/ChungNZ18} curated by \citet{shi2022learning}, which we refer to as LRS3+Vox2-en. The former features 433 hours of footage and the latter 1,759 hours. For fine-tuning, we use the full LRS3 with the labels as our high-resource labelled data setting, as well as a 30-hour subset (the ``trainval'' partition) as our low-resource setting. We present results for the LRS2 dataset \citep{chung2017lip} in Appendix \ref{sec:lrs2}.

\paragraph{Transformer encoder.} We show results for two configurations of the Transformer encoders, Base and Large, with 12 and 24 blocks respectively. The hidden size/MLP size/attention heads are 512/2048/8 for Base and 1024/4096/16 for Large, amounting to 41 million (M) and 328 M parameters, respectively. We note that our Base model is around half the size of the one used by \citet{shi2022learning} and the Large models are similar in size. Training details are provided in Appendix \ref{sec:impl_details}.



\begin{table}[t]
\centering
\resizebox{\linewidth}{!}{
\begin{tabular}[b]{l c c c c c c}\toprule
\multirow{2}{*}{Method} & \multirow{2}{*}{Encoder} & \multirow{2}{*}{LM} & \multirow{2}{*}{Unlab hrs} & \multirow{2}{*}{Lab hrs} & \multicolumn{2}{c}{WER (\%)} \\
\cmidrule(lr){6-7}
& & & & & VSR & ASR \\
\midrule\midrule
\multicolumn{7}{c}{\textcolor{gray}{\textit{supervised}}} \\
\textcolor{gray}{\citet{afouras2018deep}} & \textcolor{gray}{Transformer} & \textcolor{gray}{\cmark} & \textcolor{gray}{-} & \textcolor{gray}{1,519\textsuperscript{*}} & \textcolor{gray}{58.9} & \textcolor{gray}{8.3} \\
\textcolor{gray}{\citet{xu2020discriminative}} & \textcolor{gray}{RNN} & \textcolor{gray}{\xmark} & \textcolor{gray}{-} & \textcolor{gray}{590} & \textcolor{gray}{57.8} & \textcolor{gray}{7.2} \\
\textcolor{gray}{\citet{shillingford2018large}} & \textcolor{gray}{RNN} & \textcolor{gray}{\cmark} & \textcolor{gray}{-} & \textcolor{gray}{3,886\textsuperscript{*}} & \textcolor{gray}{55.1} & \textcolor{gray}{-} \\
\textcolor{gray}{\citet{ma2022visual}} & \textcolor{gray}{Conformer} & \textcolor{gray}{\cmark} & \textcolor{gray}{-} & \textcolor{gray}{813} & \textcolor{gray}{34.7} & \textcolor{gray}{-} \\
\textcolor{gray}{\citet{makino2019recurrent}} & \textcolor{gray}{RNN} & \textcolor{gray}{\xmark} & \textcolor{gray}{-} & \textcolor{gray}{31,000\textsuperscript{*}} & \textcolor{gray}{33.6} & \textcolor{gray}{4.8} \\ 
\textcolor{gray}{\citet{afouras2021sub}} & \textcolor{gray}{Transformer} & \textcolor{gray}{\cmark} & \textcolor{gray}{-} & \textcolor{gray}{2,676\textsuperscript{*}} & \textcolor{gray}{30.7} & \textcolor{gray}{-} \\
\textcolor{gray}{\citet{serdyuk2021audio}} & \textcolor{gray}{Transformer} & \textcolor{gray}{\xmark} & \textcolor{gray}{-} & \textcolor{gray}{90,000\textsuperscript{*}} & \textcolor{gray}{25.9} & \textcolor{gray}{2.3} \\
\textcolor{gray}{\citet{DBLP:journals/corr/abs-2201-10439}} & \textcolor{gray}{Conformer} & \textcolor{gray}{\xmark} & \textcolor{gray}{-} & \textcolor{gray}{90,000\textsuperscript{*}} & \textcolor{gray}{\textbf{19.3}} & \textcolor{gray}{\textbf{1.6}} \\
\midrule\midrule
\multicolumn{7}{c}{\textit{from scratch}} \\
Base model & Transformer & \xmark & - & 30 & 93.4 & 18.5 \\
Large model & Transformer & \xmark & - & 30 & 95.5 & 9.9 \\
\midrule\midrule
\multicolumn{7}{c}{\textit{self-supervised}} \\
\textbf{Base models, less pre-training data} & & & & \\
\citet{ma2021lira} & Transformer & \xmark & 433 & 30 & 71.9\textsuperscript{\textdagger} & - \\
\citet{zhang2022learning} & Transformer & \xmark & 433 & 30 & 67.8 & 10.9 \\
\citet{hsu2021hubert} & Transformer & \xmark & 433 & 30 & - & 5.4 \\
\citet{shi2022learning} & Transformer & \xmark & 433 & 30 & 51.8 & 4.9 \\
\rowcolor{LightCyan}
RAVEn & Transformer & \xmark & 433 & 30 & \textbf{47.0} & \textbf{4.7} \\ \midrule
\textbf{Base models, more pre-training data} & & & & \\
\citet{hsu2021hubert} & Transformer & \xmark & 1,759 & 30 & - & 5.0 \\ 
\citet{shi2022learning} & Transformer & \xmark & 1,759 & 30 & 46.1 & 4.6\textsuperscript{} / \textbf{3.8} \\
\rowcolor{LightCyan}
RAVEn & Transformer & \xmark & 1,759 & 30 & \textbf{40.2} & \textbf{3.8} \\ 
\midrule
\textbf{Large models, more pre-training data} & & & & \\
\citet{hsu2021hubert} & Transformer & \xmark & 1,759 & 30 & - & 3.2 \\ 
\citet{shi2022learning} & Transformer & \xmark & 1,759 & 30 & 32.5 & 2.9 \\
\citet{shi2022learning} w/ self-training & Transformer & \xmark & 1,759 & 30 & 28.6 & - \\
\rowcolor{LightCyan}
RAVEn & Transformer & \xmark & 1,759 & 30 & 32.5 & 2.7 \\
\rowcolor{LightCyan}
RAVEn w/ self-training & Transformer & \xmark & 1,759 & 30 & 24.8 & 2.3 \\
\rowcolor{LightCyan}
RAVEn w/ self-training & Transformer & \cmark & 1,759 & 30 & \textbf{23.8} & \textbf{1.9}  \\
\bottomrule 
\end{tabular}}
\caption{\textbf{LRS3 low-resource setting}. We report results on the test set when fine-tuning on 30 hours of LRS3 with different model sizes and number of unlabelled data hours (Unlab hrs). LM denotes whether or not a language model was used during decoding. We also provide baselines for training our models from scratch (without our pre-training) and results from fully-supervised methods trained on more labelled data hours (Lab hrs) for reference. \textsuperscript{*}Includes non-publicly-available data. \textsuperscript{\textdagger}Result taken from \citet{shi2022learning}. \textsuperscript{}Result with the same pre-training strategy for VSR and ASR.}
\label{table:low_resource}
\end{table}

\subsection{Low-Resource Labelled Data Setting}
We pre-train our models on LRS3 and/or LRS3+Vox2-en and then fine-tune them on the 30-hour LRS3 subset to evaluate performance when labels are scarce. We reports results in Table \ref{table:low_resource}.

Compared with training from scratch, RAVEn pre-training leads to dramatic performance improvements in all configurations. Notably, increasing the model size \textit{hurts} VSR performance when training from scratch, but \textit{improves} it when using pre-training. 

Our Base variant outperforms all related methods on VSR. It surpasses the Base AV-HuBERT model by 4.8\% and 5.9\% WER when using LRS3 and LRS3+Vox2-en, respectively, despite having roughly half the number of parameters. The Large model provides significant boosts over the Base model (32.5\% vs 40.2\% WER) when using LRS3+Vox2-en for pre-training, keeping the number of labelled data points fixed. Self-training further improves WER by 7.7\%, indicating its complementarity with RAVEn pre-training. Finally, using a language model (see Appendix \ref{sec:finetune} for details) leads to a WER of 23.8\%, better than a method \citep{serdyuk2021audio} trained on \textit{90,000} hours of non-public data.

On ASR, RAVEn significantly outperforms the audio-only Hubert \citep{hsu2021hubert} model, and in all cases is better than or on par with AV-HuBERT. Our best ASR model without self-training achieves 2.7\% WER vs AV-HuBERT's 2.9\% WER, despite AV-HuBERT using a different pre-training strategy for VSR than ASR. For example, using the same pre-training hyperparameters increases AV-HuBERT's WER for ASR from 3.8\% to 4.6\% with the Base model \citep{shi2022learning}. In contrast, the video and audio encoders we use for fine-tuning are the result of a \textit{single} pre-training phase, where they were jointly learned. 

All in all, our results suggest that transcribed data, which are costly to obtain, can be largely substituted with raw unlabelled audiovisual data. 



\begin{table}[t]
\centering
\resizebox{\linewidth}{!}{
\begin{tabular}[b]{l c c c c c c}\toprule
\multirow{2}{*}{Method} & \multirow{2}{*}{Encoder} & \multirow{2}{*}{LM} & \multirow{2}{*}{Unlab hrs} & \multirow{2}{*}{Lab hrs} & \multicolumn{2}{c}{WER (\%)} \\
\cmidrule(lr){6-7}
& & & & & VSR & ASR \\
\midrule\midrule
\multicolumn{7}{c}{\textit{semi-supervised (using external models for pseudo-labelling)}} \\
\cite{afouras2020asr} & CNN & \cmark & 344 & 433 & 59.8 & - \\
\cite{ma2022visual} & Conformer & \cmark & 641 & 818 & \textbf{31.5} & - \\
\midrule\midrule
\multicolumn{7}{c}{\textit{from scratch}} \\
Base model & Transformer & \xmark & - & 433 & 87.3 & 2.5 \\
Base model w/ curriculum & Transformer & \xmark & - & 433 & 39.8 & - \\
Large model & Transformer & \xmark & - & 433 & 85.8 & \textbf{2.2}  \\
Large model w/ curriculum & Transformer & \xmark & - & 433 & \textbf{38.8} & -  \\
\midrule\midrule
\multicolumn{7}{c}{\textit{self-supervised}} \\
\textbf{Base models, less pre-training data} & & & & & & \\
\citet{shi2022learning} & Transformer & \xmark & 433 & 433 & 44.0 & - \\
\rowcolor{LightCyan}
RAVEn & Transformer & \xmark & 433 & 433 & \textbf{39.1} & \textbf{2.2} \\ \midrule
\textbf{Base models, more pre-training data} & & & & & & \\
\citet{ma2021lira} & Transformer & \xmark & 1,759 & 433 & 49.6\textsuperscript{\textdagger} & - \\
\citet{hsu2021hubert} & Transformer & \xmark & 1,759 & 433 & - & 2.4 \\ 
\citet{shi2022learning} & Transformer & \xmark & 1,759 & 433 & 34.8 & 2.0 \\
\rowcolor{LightCyan}
RAVEn & Transformer & \xmark & 1,759 & 433 & \textbf{33.1} & \textbf{1.9} \\ 
\midrule
\textbf{Large models, more pre-training data} & & & & & & \\
\citet{hsu2021hubert} & Transformer & \xmark & 1,759 & 433 & - & 1.5 \\ 
\citet{shi2022learning} & Transformer & \xmark & 1,759 & 433 & 28.6 & \textbf{1.3} \\
\citet{shi2022learning} w/ self-training & Transformer & \xmark & 1,759 & 433 & 26.9 & - \\
\rowcolor{LightCyan}
RAVEn & Transformer & \xmark & 1,759 & 433 & 27.8 & 1.4 \\
\rowcolor{LightCyan}
RAVEn w/ self-training & Transformer & \xmark & 1,759 & 433 & 24.4 & 1.4  \\
\rowcolor{LightCyan}
RAVEn w/ self-training & Transformer & \cmark & 1,759 & 433 & \textbf{23.1} & 1.4 \\
\bottomrule 
\end{tabular}}
\caption{\textbf{LRS3 high-resource setting}. We report results on the test set with different model sizes and number of unlabelled data hours (Unlab hrs). Lab hrs denotes the number of labelled hours, and LM denotes whether or not a language model was used during decoding. We provide baselines for training our models from scratch (without our pre-training). \textsuperscript{\textdagger}Result taken from \citet{shi2022learning}.}
\label{table:high_resource}
\end{table}

\subsection{High-Resource Labelled Data Setting}
Table \ref{table:high_resource} reports results when fine-tuning on the full 433 hours of LRS3. Despite increasing the labelled data, training the model \textit{from scratch} still leads to poor performance, as in the low-resource setting. This is likely related to the long utterances in the LRS3 dataset, which may cause optimisation difficulties \citep{ma2022visual}. A potential remedy is to employ curriculum learning, as proposed by \citet{ma2022visual}, by training the network in multiple stages with increasingly longer sequences. We observe that this strategy indeed reduces WER from 87.3\% to 39.8\% for the Base model. Even so, pre-training with the same data used for fine-tuning leads to a better WER of 39.1\%, \textit{without} requiring a curriculum learning procedure. This suggests that self-supervised pre-training can aid optimisability. The impact of pre-training is even more pronounced with the Large model.

RAVEn outperforms AV-HuBERT under all configurations on VSR. Our best result is 23.1\%, achieved using self-training and a language model. We note that unlike methods that use external ASR models \citep{afouras2020asr, ma2022visual} for pseudo-labelling, we do not require extra data for the self-training phase.

We are on par with the state-of-the-art for ASR in the high-resource setting, achieving a WER of 1.4\% with the Large model. This is despite using raw audio as input (rather than spectrograms which \citet{shi2022learning} use). We notice that additionally including self-training and a language model does not reduce the WER, suggesting that the ASR performance may have saturated in our environment.

\subsection{Pre-training Ablations} \label{sec:pretrain_abl} 
Ablations are performed with our Base model in the low-resource setting with LRS3 pre-training using the validation set from \citet{shi2022learning} (as there is no official development set). For more ablations, see Appendix \ref{sec:more_ablations}.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{figures/pred_types_crop.pdf}
  \caption{\textbf{Prediction tasks}. We consider different choices for our prediction tasks, combining cross- and within-modal losses. We find that applying both cross- and within-modal losses for the audio student, and only a cross-modal loss for the video student works best.}
  \label{fig:loss_types}
\end{figure}

\begin{table}
\centering
\begin{tabular}[b]{l c c c c c c}\toprule
\multirow{2}{*}{Setting} & \multicolumn{4}{c}{Prediction tasks} & \multicolumn{2}{c}{WER (\%)} \\ 
\cmidrule(lr){2-5} \cmidrule(lr){6-7}
& V  V & A  A & V  A & A  V & VSR & ASR \\ \midrule
Within-modal & \cmark & \cmark & \xmark & \xmark & 92.7 & 15.5 \\
Cross-modal & \xmark & \xmark & \cmark & \cmark & 40.8 & 14.0 \\
Cross- + within-modal & \cmark & \cmark & \cmark & \cmark & 49.0 & 14.0 \\
Cross- + video within-modal & \cmark & \xmark & \cmark & \cmark & 55.3 & 16.4 \\
\rowcolor{Gray}
Cross- + audio within-modal & \xmark & \cmark & \cmark & \cmark & \textbf{32.9} & \textbf{12.2} \\
\bottomrule 
\end{tabular}
\caption{\textbf{Prediction task} ablations under the LRS3 low-resource setting using our Base model. V  A means that the video student predicts the audio teacher representations. Each prediction loss is associated with a separate predictor.}
\label{table:loss_structure}
\end{table}

\paragraph{Prediction tasks.} We study in Table \ref{table:loss_structure} the impact of cross- and within-modal prediction on the learned representations. Figure \ref{fig:loss_types} illustrates the various prediction tasks we consider. We observe the following. The \textit{within-modal} variant performs decently for ASR but poorly for VSR, which can be explained by the assumption that audio contains more speech information than video. The \textit{cross-modal} variant performs better than within-modal for both modalities. Since lip movements and the corresponding waveform are correlated in terms of lexical content, the representations resulting from cross-modal prediction are expected to capture rich semantic information. At the same time, they are likely to be, to a large extent, invariant to factors unshared between the two modalities, such as visual or auditory noise, benefiting generalisation. Combining \textit{cross- with within-modal} learning hurts VSR relative to only cross-modal prediction. However, cross-modal with within-modal learning \textit{only for audio} achieves the best results. We hypothesise that predicting the auditory targets forces the auditory stream to keep relevant information absent from the visual stream. We note that removing the video-to-video prediction (from row 3 to row 5 in Table \ref{table:loss_structure}) also improves the audio student, as the quality of the visual targets improves. Finally, cross-modal with within-modal learning \textit{only for video} does not perform well, validating that the asymmetry only works one way.

\begin{table}
\begin{subtable}[h]{0.38\textwidth}
\centering
\begin{tabular}[b]{c c c c}\toprule
\multirow{2}{*}{Prob} & \multirow{2}{*}{Length} & \multicolumn{2}{c}{WER (\%)} \\  \cmidrule(lr){3-4}
& & VSR & ASR \\ \midrule
0.1 & 1 & 41.1 & 15.6 \\
\rowcolor{Gray}
0.2 & 3 & \textbf{32.9} & 12.2 \\
0.4 & 5 & 35.7 & \textbf{11.7} \\
\bottomrule 
\end{tabular}
\caption{\textbf{Masking strength} in terms of starting index probability and mask length.}
\label{table:mask_sampling}
\end{subtable}
\hfill
\begin{subtable}[h]{0.3\textwidth}
\centering
\begin{tabular}[b]{l c c}\toprule
\multirow{2}{*}{Position} & \multicolumn{2}{c}{WER (\%)} \\  \cmidrule(lr){2-3}
 & VSR & ASR \\ \midrule
Encoder & 43.1 & 14.0 \\
\rowcolor{Gray}
Predictor & \textbf{32.9} & \textbf{12.2} \\
\bottomrule 
\end{tabular}
\caption{\textbf{Mask token position.} Applying the mask tokens in the predictor works better than in the encoder.}
\label{table:mask_tokens}
\end{subtable}
\hfill
\begin{subtable}[h]{0.3\textwidth}
\centering
\begin{tabular}[b]{l c c}\toprule
\multirow{2}{*}{Loss} & \multicolumn{2}{c}{WER (\%)} \\  \cmidrule(lr){2-3}
 & VSR & ASR \\ \midrule
Masked & 44.3 & 12.6 \\
\rowcolor{Gray}
All & \textbf{32.9} & \textbf{12.2} \\
\bottomrule 
\end{tabular}
\caption{\textbf{Cross-modal loss.} Applying the cross-modal loss for all inputs is superior to applying it only for masked inputs.}
\label{table:mask_loss}
\end{subtable}
\caption{\textbf{Masking} ablations under the LRS3 low-resource setting using our Base model.}
\end{table}

\paragraph{Masking sampling.} Table \ref{table:mask_sampling} studies the effect of different masking strengths by varying the mask length and probability that a given index is chosen as the mask start. We observe that a probability of 0.2 and a length of three video frames (corresponding to 1,920 audio samples) works well. Less masking allows the student to focus less on context and degrades both VSR and ASR. Interestingly, although more masking hurts VSR, it helps ASR, suggesting that an asymmetric masking strategy w.r.t. the two modalities may further improve results. We leave this exploration to future work.

Our masking is less aggressive than what was found to be optimal in related self-supervised image and action recognition literature (where 75\% or even 90\% of the input is masked) \citep{he2021masked, tong2022videomae}. We hypothesise that mouth movements are fast-varying and do not contain much temporal redundancy, and thus such strong masking makes our pretext task overly difficult.

\paragraph{Mask token position.} We investigate in Table \ref{table:mask_tokens} the optimal position of the mask tokens. It is clear that better performance is achieved when applying them in the predictors rather than the encoders. Forgoing the use of mask tokens in the encoders leads to no input discrepancy between pre-training and fine-tuning, since no mask tokens are used during fine-tuning. 

\paragraph{Mask loss.} It is common to apply the loss only on masked inputs for \textit{within-modal} losses \citep{hsu2021hubert, he2021masked}, since predicting targets corresponding to unmasked inputs may be trivial. However, this is not the case for cross-modal prediction, where the targets are not related to the inputs in an obvious way. Indeed, Table \ref{table:mask_loss} shows that applying the loss for both masked and unmasked inputs outperforms applying it only for masked inputs.


\begin{table}
\begin{subtable}[h]{.47\linewidth}
\centering
\begin{tabular}[b]{l c c c}\toprule
\multirow{2}{*}{Predictor type} & \multirow{2}{*}{Params} & \multicolumn{2}{c}{WER (\%)} \\  \cmidrule(lr){3-4}
& & VSR & ASR \\ \midrule
None & 0 & coll.\textsuperscript{} & coll.\textsuperscript{} \\
Linear & 0.3M & 64.4 & 17.7 \\
MLP & 4.2M & 62.6 & 19.0 \\ \midrule
Transformer 1 block & 3.9M & 46.7 & 14.1 \\
\rowcolor{Gray}
Transformer 2 blocks & 7.4M & \textbf{32.9} & \textbf{12.2} \\
Transformer 4 blocks & 14.2M & 46.2 & 13.4 \\
\bottomrule
\end{tabular}
\caption{\textbf{Predictor type.} A lightweight Transformer predictor works better than a linear layer or 2-layer MLP design. \textsuperscript{}Denotes representation collapse.}
\label{table:pred_type}
\end{subtable}
\hfill
\begin{subtable}[h]{.47\linewidth}
\centering
\begin{tabular}[b]{c c c c}\toprule
\multirow{2}{*}{Att dim} & \multirow{2}{*}{MLP dim} & \multicolumn{2}{c}{WER (\%)} \\  \cmidrule(lr){3-4}
& & VSR & ASR \\ \midrule
256 & 1024 & 44.0 & 13.3 \\
\rowcolor{Gray}
512 & 2048 & \textbf{32.9} & \textbf{12.2} \\
1024 & 4096 & 39.1 & 12.3 \\
\bottomrule 
\end{tabular}
\caption{\textbf{Predictor width}. A moderate predictor width works optimally.}
\label{table:pred_width}
\end{subtable}
\caption{\textbf{Predictor capacity} ablations under the LRS3 low-resource setting using our Base model.}
\end{table}

\paragraph{Predictor design.}
Table \ref{table:pred_type} shows the effect of different predictor types. We note that using no predictors at all leads to representation collapse, where all outputs are constant \citep{grill2020bootstrap}. We compare linear layers and 2-layer MLPs (applied independently to each encoder output) with Transformers of varying capacity. Following \citet{grill2020bootstrap}, the MLPs have hidden dimension of 4096 with batchnorm followed by ReLU \citep{nair2010rectified} after the hidden layer. 

We find that a Transformer predictor works significantly better, even when the number of parameters in the (1-block) Transformer and the 2-layer MLP is similar. Interestingly, the ability for the predictors to model temporal dependencies seems to be crucial to our representation learning phase.

A two-block Transformer works optimally (Table \ref{table:pred_type}). A shallower Transformer likely results in representations too specialised to the pretext task. A deeper one might place a lot of the burden on the predictors, leaving the encoder representations too general. Similar conclusions can be drawn regarding the Transformer width (see Table \ref{table:pred_width}). Overall, the lightweight predictor design means that using three predictors (one on the video student side and two on the audio) has relatively little effect on the total computational cost.

\section{Conclusion}
We presented RAVEn, a single-stage method that jointly learns visual and auditory speech representations entirely from raw data. It employs momentum encoders to generate targets, which, given masked inputs, are predicted by Transformer encoders and predictors. Especially salient to the quality of the representations are appropriate masking, lightweight Transformer predictors, and an asymmetric loss structure w.r.t. the visual and auditory modalities. RAVEn achieves strong performance under many settings without requiring multiple pre-training stages, handcrafted audio targets, or separate pre-training strategies for VSR and ASR.

As future work, it would be interesting to examine the effect of sharing weights between the visual and auditory encoders as a way of reducing the memory requirements for pre-training. We would also like to apply RAVEn to other tasks related to speech. We hope our study inspires future research extending beyond speech recognition.

\section*{Ethics Statement}
Despite numerous positive applications, our method can also be misused. For example, lipreading technologies can be employed for surveillance, compromising the public's privacy and trust. This problem is likely to be exacerbated as the quality of CCTV cameras improves over time. Appropriate government regulations will need to be put in place to limit such concerns. Another issue relates to the potential biases embedded in the datasets used. Such biases may have to do with gender, age, or ethnic backgrounds. A specific group being under-represented in the data would likely result in reduced model performance on samples belonging to said group. Making sure that the models are trained on balanced data, or using other bias-reduction techniques, can address such issues. 

Our work used datasets that were made public for research purposes, i.e., LRS2, LRS3, and VoxCeleb2. In particular, we used the cropped face .mp4 videos that were available on the official dataset webpages and which complied with the following licenses: Creative Commons BY-NC-ND 4.0 license and Creative Commons Attribution 4.0 International License, TED terms of use, and BBCs terms of use.

\section*{Reproducibility}
To ensure reproducibility, we provide as many implementation details as possible in the main paper as well as tables showing the hyperparameter values in the appendix. Moreover, we plan on making the code and pre-trained models publicly available.

\section*{Acknowledgements}
Only non-Meta co-authors downloaded, accessed, and used the LRS2 dataset. Only non-Meta authors conducted any of the dataset pre-processing (no dataset pre-processing took place on Metas servers or facilities). 

\bibliography{iclr2023_conference}
\bibliographystyle{iclr2023_conference}

\clearpage
\appendix
\section{Dataset / Implementation Details} \label{sec:impl_details}
\subsection{Datasets}
\paragraph{LRS3.} LRS3 \citep{afouras2018lrs3} is the largest publicly available transcribed audio-visual dataset for continuous speech recognition. It consists of around 430 hours of spoken sentences from TED talks, with a vocabulary of more than 50,000 words uttered by thousands of speakers. The test set contains around 1 hour of utterances with speakers separate from those in the training set.
\paragraph{LRS2.} The 223-hour LRS2 dataset \citep{chung2017lip}, collected from BBC programmes, is the second-largest publicly available transcribed audio-visual dataset for continuous speech recognition. As LRS3, it contains an unconstrained vocabulary and thousands of diverse speakers.
\paragraph{VoxCeleb2.} VoxCeleb2 \citep{DBLP:conf/interspeech/ChungNZ18} is a non-transcribed dataset containing YouTube-downloaded videos. It consists of around 2,500 hours of utterances with over 6,000 speakers. Since VoxCeleb2 is multi-lingual, as mentioned in the main text, we use an English-only version curated by \citet{shi2022learning}, amounting to 1,759 hours.
\subsection{Dataset pre-processing}
We follow common practices in the literature for dataset pre-processing \citep{ma2022visual, shi2022learning, martinez2020lipreading}. We crop a  region centred around the mouth and transform to grayscale. Raw audio is used without any pre-processing nor normalisation. Utterances longer than 24 seconds are split into smaller constituents.

\begin{table}
\centering
\begin{tabular}[b]{l | c}
Hyperparameter & Value \\ \midrule
Training epochs & 150 \\
Warmup epochs & 40 (LRS3), 30 (LRS3+Vox2-en) \\
Optimiser & AdamW \\
Learning rate & 3e-3 (Base), 2e-3 (Large) \\
Optimiser  &  \\
Weight decay & 0.04 \\
Learning rate schedule & Cosine decay \\
Drop path & 0.05 (Base), 0.1 (Large)  \\
Gradient clip & 5.0 \\
Video augmentations & RandomCrop + HorizontalFlip
\end{tabular}
\caption{\textbf{Pre-training settings.}}
\label{table:pretrain_settings}
\end{table}

\begin{table}
\centering
\begin{tabular}[b]{l | c}
Hyperparameter & Value \\ \midrule
Training epochs & 75 (HR), 50 (LR) \\
Warmup epochs & 20 \\
Optimiser & AdamW \\
Learning rate encoder & 2e-3 \\
Learning rate decoder & 6e-3 \\ 
Optimiser  &  \\
Weight decay & 0.04 (HR), 0.1 (LR) \\
Learning rate schedule & Cosine decay \\
Layer-wise learning rate decay & 0.75 (HR), 0.5 (LR) \\
Minimum learning rate & 1e-5 \\
Drop path & 0.2  \\
Gradient clip & 5.0 \\
Video augmentations & RandomCrop + HorizontalFlip + TimeMask \\
Audio augmentations & TimeMask \\
Decoder blocks & 6 (Base), 9 (Large) \\
Decoder hidden size & 256 (LR), 512 (HR, Base), 1024 (HR, Large) \\
Decoder MLP size & 1024 (LR), 2048 (HR, Base), 4096 (HR, Large) \\
Decoder attention heads & 4 (LR), 8 (HR, Base), 16 (HR, Large) \\
\end{tabular}
\caption{\textbf{Fine-tuning settings.} HR denotes high-resource labelled data setting and LR low-resource.}
\label{table:finetune_settings}
\end{table}

\subsection{Pre-training}
Table \ref{table:pretrain_settings} provides the default setting for pre-training. We use the AdamW \citep{loshchilov2017decoupled} optimiser with linear learning rate warmup \citep{goyal2017accurate} and a cosine decay schedule \citep{loshchilov2016sgdr}. During training, we apply random spatial cropping of size  followed by horizontal flipping with probability 0.5. These augmentations are applied in a time-consistent manner across the video clips to maintain temporal coherence. We do not use any augmentations for the raw audio. We also use stochastic depth \citep{huang2016deep} for regularisation, as well as LayerScale \citep{touvron2021going} with coefficient 0.1. We train the Base model with 32 A100 GPUs, and the Large model with 128. It takes around 15 minutes / 1 hour per epoch to pre-train our Base models on LRS3 / LRS3+Vox2-en, and 2 hours per epoch for our Large model on LRS3+Vox2-en.

Our batching process is as follows: The samples are sorted based on their length to minimise zero-padding, and then samples with the same length are randomly shuffled at the beginning of each training epoch. Each batch contains a maximum of 96 / 36 seconds of footage for Base / Large.

\subsection{Fine-tuning / decoding} \label{sec:finetune}
The protocol for fine-tuning is similar to that for pre-training with some exceptions (see Table \ref{table:finetune_settings}). We use a higher learning rate for the decoder than for the pre-trained encoder, since the decoder is randomly-initialised. We also employ layer-wise learning rate decay \citep{clark2020electra}, which we found to reduce overfitting. In addition to the augmentations from the pre-training stage, we apply time masking \citep{ma2022visual} for both video and audio clips. Specifically, for each second of the sample, we use zero-masking with a duration that is uniformly sampled between 0 and 0.4 seconds. Fine-tuning Base (for both VSR and ASR) takes around 30 seconds per epoch in the low-resource setting and 7 minutes per epoch in the high-resource setting. Fine-tuning Large takes approximately 1 minute and 20 minutes per epoch in the low- and high-resource setting, respectively.

\paragraph{CTC/attention decoding.} We use joint CTC/attention decoding to map the input sequence  of length  to a target sequence  of size . The CTC loss during fine-tuning is given by

where  is the set of valid alignments,  is one such alignment, and  is the token at time-step .

The attention loss, computed using the Transformer decoder outputs, can be expressed as


The final loss during fine-tuning is given by , where .

We use the ESPnet framework \citep{watanabe2018espnet} for decoding. We set the beam size to 40. The final score used to choose the most likely sequence is given by , where  and  denote the scores from the CTC and attention branches, respectively, and .  is an optional score from the language model, incorporated through shallow fusion \citep{watanabe2017hybrid}. When using a language model,  is chosen from  using the validation set.

Inference on one A100 GPU (without batching) takes around 3 seconds to decode 10 seconds of footage for Base and 5 seconds for Large.

\paragraph{Language model.} We use a 16-block Transformer-based language model, as proposed by \citet{irie2019language}. The hidden size/MLP size/attention heads are 512/2048/8. The language model is trained on the combination of the following datasets: Librispeech \citep{panayotov2015librispeech}, LRS2/3, TED-LIUM 3 \citep{hernandez2018ted}, VoxForge and Common Voice \citep{ardila2019common}. The total number of characters is 166 million.

\subsection{Feature Extractors} \label{sec:feature_extractors}
The details of the visual and auditory convolutional feature extractors are provided in Tables \ref{table:visual_extractor} and \ref{table:auditory_extractor}, respectively.

\begin{table}[tb]
\begin{subtable}[h]{0.47\linewidth}
\centering
\resizebox{\linewidth}{!}{
\begin{tabular}{c | c | c}
stage & filters & output size  \\ \toprule
conv\textsubscript{1} & , , stride  &  \\ \midrule
pool\textsubscript{1} & max, , stride  &  \\ \midrule
res\textsubscript{1} &  &  \\ \midrule
res\textsubscript{2} &  &  \\ \midrule
res\textsubscript{3} &  &  \\ \midrule
res\textsubscript{4} &  &  \\ \midrule
pool\textsubscript{2} & global spatial average pool &  \\ \midrule
\end{tabular}
}
\caption{\textbf{Visual feature extractor.}}
\label{table:visual_extractor}
\end{subtable}
\hfill
\begin{subtable}[h]{0.47\linewidth}
\centering
\resizebox{\linewidth}{!}{
\begin{tabular}{c | c | c}
stage & filters & output size  \\ \toprule
conv\textsubscript{1} & , , stride  &  \\ \midrule
res\textsubscript{1} &  &  \\ \midrule
res\textsubscript{2} &  &  \\ \midrule
res\textsubscript{3} &  &  \\ \midrule
res\textsubscript{4} &  &  \\ \midrule
pool\textsubscript{2} & average pool, stride 20 &  \\ \midrule
\end{tabular}
}
\caption{\textbf{Auditory feature extractor.}}
\label{table:auditory_extractor}
\end{subtable}
\caption{\textbf{Feature extractors}. We provide details on the convolutional architectures used as the feature extractors for the visual and auditory modalities. Note that the output sizes for both networks match.}
\end{table}

\section{LRS2 Experiments} \label{sec:lrs2}
\begin{table}
\centering
\begin{tabular}[b]{l c c c c c c}\toprule
\multirow{2}{*}{Method} & \multirow{2}{*}{Encoder} & \multirow{2}{*}{LM} & \multirow{2}{*}{Unlab hours} & \multirow{2}{*}{Lab hours} & \multicolumn{2}{c}{WER (\%)} \\
\cmidrule(lr){6-7}
& & & & & VSR & ASR \\
\midrule\midrule
\multicolumn{7}{c}{\textit{supervised}} \\ 
\citet{chung2017lip} & LSTM & \cmark & - & 223 & 70.4 & - \\
\citet{petridis2018audio} & LSTM & \cmark & - & 380 & 63.5 & 8.3 \\
\citet{ren2021learning} & Transformer & \xmark & - & 818 & 49.2 & - \\ 
\citet{yu2020audio} & CNN & \cmark & - & 223 & 48.9 & 6.7 \\
\citet{ma2021end} & Conformer & \cmark & - & 380 & 37.9 & 3.9 \\ 
\citet{afouras2021sub} & Transformer & \cmark & - & 698 & 28.9 & - \\
\citet{ma2022visual} & Conformer & \cmark & - & 818 & 27.3 & - \\
\citet{afouras2021sub} & Transformer & \cmark & - & 2,676\textsuperscript{*} & \textbf{22.6} & - \\
\midrule\midrule
\multicolumn{7}{c}{\textit{semi-supervised (using external models for pseudo-labelling)}} \\
\citet{afouras2020asr} & CNN & \cmark & 777 & 223 & 51.3 & - \\
\citet{ma2022visual} & Conformer & \cmark & 641 & 818 & \textbf{25.5} & - \\
\midrule\midrule
\multicolumn{7}{c}{\textit{self-supervised}} \\
\citet{pan2022leveraging} & Transformer & \xmark & 60,000 & 223 & 43.2 & 2.7 \\
\citet{ma2021lira} & Conformer & \cmark & 433 & 223 & 38.8 & - \\
\rowcolor{LightCyan}
RAVEn (Base) & Transformer & \xmark & 433 & 223 & 32.1 & 3.9 \\
\rowcolor{LightCyan}
RAVEn (Large) & Transformer & \xmark & 1,759 & 223 & 23.2 & 2.5 \\
\rowcolor{LightCyan}
RAVEn (Large) w/ self-training & Transformer & \xmark & 1,759 & 223 & 19.3 & \textbf{2.3} \\
\rowcolor{LightCyan}
RAVEn (Large) w/ self-training & Transformer & \cmark & 1,759 & 223 & \textbf{17.9} & \textbf{2.3} \\
\bottomrule 
\end{tabular}
\caption{\textbf{LRS2 results.} We report results on the test set with different model sizes and number of unlabelled data hours (Unlab hours). Lab hours denotes the number of labelled hours, and LM denotes whether or not a language model was used during decoding. \textsuperscript{*}Includes non-publicly available data.}
\label{table:lrs2}
\end{table}

We report results on the test set of the LRS2 dataset \citep{chung2017lip} in Table \ref{table:lrs2}. After pre-training on the LRS3 or the LRS3+Vox2-en datasets, we fine-tune on the ``pre-training'' and ``training'' sets of LRS2. We observe similar trends as in the LRS3 experiments (Table \ref{table:high_resource}), namely that performance is benefited from large models, large unlabelled datasets, and self-training. We significantly outperform all other methods, including one \citep{pan2022leveraging} pre-trained on 60,000 hours of audio data. 

\section{More Ablations} \label{sec:more_ablations}
\subsection{More pre-training ablations}

\begin{table}
\begin{subtable}[h]{.47\linewidth}
\centering
\begin{tabular}[b]{l c c}\toprule
\multirow{2}{*}{Momentum } & \multicolumn{2}{c}{WER (\%)} \\  \cmidrule(lr){2-3}
& VSR & ASR \\ \midrule
0 & coll.\textsuperscript{} & coll.\textsuperscript{} \\
\rowcolor{Gray}
0.999\textsuperscript{\textdagger} & \textbf{32.9} & \textbf{12.2} \\
1 & 75.0 & 74.0 \\
\bottomrule 
\end{tabular}
\caption{\textbf{Momentum parameter.} It is important for the momentum encoders to slowly evolve during training. \textsuperscript{\textdagger}Follows a cosine schedule with 0.999 as the starting value. \textsuperscript{}Denotes representation collapse.}
\label{table:momentum}
\end{subtable}
\hfill
\begin{subtable}[h]{.47\linewidth}
\centering
\begin{tabular}[b]{l c c}\toprule
\multirow{2}{*}{Norm} & \multicolumn{2}{c}{WER (\%)} \\  \cmidrule(lr){2-3}
& VSR & ASR \\ \midrule
\rowcolor{Gray}
BN & \textbf{32.9} & \textbf{12.2} \\
LN & 39.0 & 12.7 \\
\bottomrule 
\end{tabular}
\caption{\textbf{Pre-MLP normalisation.} Using batchnorm (BN) before the MLPs in the encoder works better than using layernorm (LN).}
\label{table:mlp_norm}
\end{subtable}
\caption{\textbf{More pre-training} ablations under the LRS3 low-resource setting using our Base model.}
\end{table}

\paragraph{Momentum parameter.}
Table \ref{table:momentum} shows the effect of varying the momentum parameter for updating the teacher networks. We show results at three coarse levels: 0 (teacher is a copy of the student at each iteration), 0.999 (with a cosine schedule to 1), and 1 (teacher does not get updated during training). We see that using a momentum value of 0 leads to representation collapse. At the other extreme, a value of 1 does not allow the teacher targets to improve during training, leading to poor representations. A slowly-evolving momentum encoder is most effective.

\paragraph{Pre-MLP normalisation.} \label{sec:pre_mlp}
As mentioned in the main text, we use batchnorm before each MLP module rather than layernorm, a choice inspired by \citet{chen2021empirical}. Table \ref{table:mlp_norm} shows that our method still works with layernorm, but lags behind batchnorm. This is an interesting observation worthy of future exploration. A preliminary hypothesis is that batchnorm may improve the conditioning of the networks at initialisation, leading to better targets at the beginning of training \citep{richemond2020byol}.

\begin{table}
\begin{subtable}[h]{.47\linewidth}
\centering
\begin{tabular}[b]{l c c c}\toprule
\multirow{2}{*}{Encoder LR} & \multirow{2}{*}{Decoder LR} & \multicolumn{2}{c}{WER (\%)} \\  \cmidrule(lr){3-4}
& & VSR & ASR \\ \midrule
\multicolumn{4}{c}{\textit{same LR}} \\ 
 &  & 36.1 & 13.1 \\
 &  & 34.0 & \textbf{12.2} \\
 &  & 34.8 & \textbf{12.2}\\
\midrule
\multicolumn{4}{c}{\textit{different LR}} \\ 
\rowcolor{Gray}
 &  & \textbf{32.9} & \textbf{12.2} \\
\bottomrule 
\end{tabular}
\caption{\textbf{Learning rates (LR) for encoder and decoder.} Using a larger learning rate for the decoder than the encoder is beneficial for VSR.}
\label{table:lr_enc_dec}
\end{subtable}
\hfill
\begin{subtable}[h]{.47\linewidth}
\centering
\begin{tabular}[b]{l c c}\toprule
\multirow{2}{*}{Learning rate decay} & \multicolumn{2}{c}{WER (\%)} \\  \cmidrule(lr){2-3}
& VSR & ASR \\ \midrule
1.0 & 42.4 & 12.5 \\
0.75 & 33.1 & \textbf{11.7} \\
\rowcolor{Gray}
0.50 & \textbf{32.9} & 12.2 \\
0.25 & 33.0 & 12.5 \\
\bottomrule
\end{tabular}
\caption{\textbf{Learning rate decay.} Reducing the learning rate as the encoder depth decreases improves performance.}
\label{table:lr_decay}
\end{subtable}

\begin{subtable}[h]{\linewidth}
\centering
\begin{tabular}[b]{l c c c}\toprule
\multirow{2}{*}{Tokens} & \multirow{2}{*}{LM} & \multicolumn{2}{c}{WER (\%)} \\  \cmidrule(lr){3-4}
& & VSR & ASR \\ \midrule
Character & \xmark & 35.8 & 13.6  \\
Character & \cmark & 32.7 & 11.1 \\
Subword & \xmark & 32.9 & 12.2 \\
Subword & \cmark & \textbf{30.4} & \textbf{10.5} \\
\bottomrule 
\end{tabular}
\caption{\textbf{Tokenisation.} Using subword (SentencePiece) units as targets is better than using characters. A language model (LM) also helps.}
\label{table:tokenisation}
\end{subtable}
\caption{\textbf{Fine-tuning} ablations under the LRS3 low-resource setting using our Base model.}
\end{table}

\subsection{Fine-tuning ablations}
\paragraph{Learning rates.} Table \ref{table:lr_enc_dec} studies the effect of using different learning rates for the encoder and decoder. We find that it is beneficial for VSR to use a higher learning rate for the decoder than the encoder, likely because the encoder is pre-trained, whereas the decoder is randomly-initialised and thus requires a larger learning rate to search for a more effective local optimum.

\paragraph{Learning rate decay.} Table \ref{table:lr_decay} shows the influence of decaying the encoder's learning rate as the depth of the model decreases. The learning rate at block , , is given by , where  is the index of the last block and  is the learning rate decay \citep{clark2020electra}. A decay less than 1 works well for both VSR and ASR, suggesting that during fine-tuning it is useful to employ larger learning rates for the deeper layers, which are more task-specific.

\paragraph{Tokenisation.} In Table \ref{table:tokenisation}, we compare the use of characters with SentencePiece \citep{kudo2018sentencepiece} subword units (vocabulary size of 1,000) as our target tokens. We find that using subword units leads to superior results than character units. This may be explained by the language priors embedded in subword units, which facilitate speech recognition. 

\subsection{Audio-visual fine-tuning}
It is possible to use the learned auditory and visual representations for audio-visual speech recognition. To that end, following \citet{ma2021end}, we concatenate the outputs of the two encoders, feed the resulting embeddings to a 2-layer MLP module with hidden size 4096 and batchnorm, and then fine-tune for speech recognition, as described in Section \ref{sec:finetune_main}. We initialise the video and audio encoders with weights obtained from uni-modal fine-tuning and randomly initialise the rest. We fine-tune for 30 epochs with the hyperparameters used for audio-only fine-tuning, shown in Table \ref{table:finetune_settings}.

\begin{table}
\centering
\begin{tabular}[b]{l c | c}\toprule
Fine-tune setting & Resource & WER (\%) \\
\midrule
Audio-only & Low & 2.6 \\
Audio-visual & Low & 2.5 \\
Audio-only & High & 1.4 \\
Audio-visual & High & 1.4 \\
\bottomrule 
\end{tabular}
\caption{\textbf{Audio vs audio-visual learning on LRS3 test set.}. Including the visual modality for fine-tuning has very little influence in clean conditions.}
\label{table:audiovisual}
\arrayrulecolor{black}
\end{table}

Table \ref{table:audiovisual} shows results in the low- and high-resource settings for the Large model with LRS3+Vox2-en pre-training. Audio-visual training gives marginal improvements (if any) compared to audio-only when the audio is clean (i.e., not noisy), consistent with findings by \citet{ma2021end}. Investigating the impact of audio-visual training and testing on audio corrupted with various noise types, is outside the scope of this work, but is interesting to take up in future work.

\begin{table}
\centering
\resizebox{\linewidth}{!}{
\begin{tabular}[b]{l c}\toprule
Model & Transcription \\
\cmidrule(lr){1-2}
Groundtruth & So what do you think happens to these gals \\
VSR, low-resource, base, LRS3 &  \textcolor{ForestGreen}{So what} \textcolor{red}{did the thing I would see this talk} \\
VSR, high-resource, large, LRS3+Vox2-en & \textcolor{ForestGreen}{So what do you think happens} \textcolor{red}{this is an accident} \\
ASR, low-resource, base, LRS3 & \textcolor{ForestGreen}{So what do you think happens to these} \textcolor{red}{look outs} \\
ASR, high-resource, large, LRS3+Vox2-en & \textcolor{ForestGreen}{So what do you think happens to these gals} \\
\midrule
Groundtruth & project really is to find photographs that were taken before something \\
VSR, low-resource, base, LRS3 &  \textcolor{red}{projects} \textcolor{ForestGreen}{really} \textcolor{red}{has} \textcolor{ForestGreen}{to find photographs} \textcolor{red}{on which I can} \textcolor{ForestGreen}{before something} \\
VSR, high-resource, large, LRS3+Vox2-en & \textcolor{red}{process} \textcolor{ForestGreen}{really is to find photographs that were taken before something} \\
ASR, low-resource, base, LRS3 & \textcolor{ForestGreen}{project really is to find photographs that} \textcolor{red}{we're taking} \textcolor{ForestGreen}{before something} \\
ASR, high-resource, large, LRS3+Vox2-en & \textcolor{ForestGreen}{project really is to find photographs that were taken before something} \\
\midrule
Groundtruth & Why are we embedded in social networks \\
VSR, low-resource, base, LRS3 & \textcolor{ForestGreen}{Why are we} \textcolor{red}{admitted} \textcolor{ForestGreen}{social networks} \\
VSR, high-resource, large, LRS3+Vox2-en & \textcolor{ForestGreen}{Why are we embedded in social networks} \\
ASR, low-resource, base, LRS3 & \textcolor{ForestGreen}{Why are we} \textcolor{red}{in better} \textcolor{ForestGreen}{social networks} \\
ASR, high-resource, large, LRS3+Vox2-en & \textcolor{ForestGreen}{Why are we embedded in social networks} \\
\midrule
Groundtruth & They won the game \\
VSR, low-resource, base, LRS3 & \textcolor{red}{Because I wasn't happy} \\
VSR, high-resource, large, LRS3+Vox2-en & \textcolor{ForestGreen}{They} \textcolor{red}{want to come} \\
ASR, low-resource, base, LRS3 & \textcolor{ForestGreen}{They} \textcolor{red}{want} \textcolor{ForestGreen}{the game} \\
ASR, high-resource, large, LRS3+Vox2-en & \textcolor{ForestGreen}{They won the game} \\
\midrule
Groundtruth & Has it gotten better \\
VSR, low-resource, base, LRS3 & \textcolor{red}{It's not} \textcolor{ForestGreen}{better} \\
VSR, high-resource, large, LRS3+Vox2-en & \textcolor{red}{It's} \textcolor{ForestGreen}{gotten better} \\
ASR, low-resource, base, LRS3 & \textcolor{red}{Is} \textcolor{ForestGreen}{it gotten better} \\
ASR, high-resource, large, LRS3+Vox2-en & \textcolor{ForestGreen}{Has it gotten better} \\
\bottomrule 
\end{tabular}
}
\caption{\textbf{Transcription errors}.}
\label{table:transcriptions}
\end{table}

\section{Analysis of transcription errors}
We provide examples of transcription errors in Table \ref{table:transcriptions}. We consider the Base VSR and ASR models fine-tuned in the low-resource setting (47.0\% and 4.7\% WER, respectively) and the Large VSR and ASR models fine-tuned in the high-resource setting with self-training and a language model (23.1\% and 1.4\% WER, respectively). Although the worst model sometimes makes surprising errors (\textit{e.g.}, ``They won the game''  ``Because I wasn't happy''), most often the errors are related to words that are phonetically similar (\textit{e.g.}, ``were taken''  ``we're taking'', ``embedded''  ``in better'', ``won''  ``want''). As expected, the quality of the transcriptions is higher for ASR than VSR, and it improves as we increase the model size and number of unlabelled data points.  

\begin{table}
\centering
\begin{tabular}[b]{l c c | c c c}\toprule
Method & Encoder & Training dataset & PESQ & STOI & ESTOI \\
\midrule
\citet{mira2022svts} & Conformer & LRS3 & 1.25 & 0.51 & 0.27 \\
\citet{mira2022svts} & Conformer & LRS3+Vox2-en & 1.26 & 0.53 & 0.31 \\
SVTS from scratch & Transformer & LRS3+Vox2-en & 1.26 & 0.53 & 0.30 \\
\rowcolor{LightCyan}
SVTS w/ RAVEn & Transformer & LRS3+Vox2-en & \textbf{1.30} & \textbf{0.56} & \textbf{0.36} \\
\bottomrule 
\end{tabular}
\caption{\textbf{Video-to-speech synthesis on LRS3 test set.} Using RAVEn pre-training for the video encoder provides significant boosts in performance.}
\label{table:video2speech}
\arrayrulecolor{black}
\end{table}

\section{RAVEn for Video-to-Speech Synthesis}
We evaluate here whether RAVEn pre-training can benefit tasks other than speech recognition by considering video-to-speech synthesis, which aims to output the speech waveform given the corresponding silent video of lip movements. We follow the protocol of SVTS \citep{mira2022svts}, the current state-of-the-art method, to perform video-to-speech on the LRS3 test set after training on LRS3+Vox2-en. We study the effect of initialising the video encoder with the weights from our Large pre-trained model. We use the same hyperparameters as \citet{mira2022svts}, except that we use a learning rate of 2e-4 and train only for 30 epochs (rather than 150). We train the ``from scratch'' baseline with a learning rate of 7e-4 for 50 epochs, as training longer resulted in overfitting.

Table \ref{table:video2speech} reports performance based on PESQ \citep{rix2001perceptual}, which measures the perceptual quality of the generated samples, as well as STOI and ESTOI \citep{taal2011algorithm}, which measure their intelligiblity. The results show that using RAVEn pre-training results in significant improvements in performance, compared with training from scratch, across all metrics. In fact, the performance boosts due to RAVEn pre-training (0.04 / 0.03 / 0.06 for PESQ / STOI / ESTOI) are larger than those observed by \citet{mira2022svts} (0.01, 0.02, 0.04) when increasing the training set size by around a factor of 4 (from LRS3 to LRS3+Vox2-en).

\end{document}
