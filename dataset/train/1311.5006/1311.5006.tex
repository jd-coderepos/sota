\documentclass[12pt,a4paper,openright,twoside]{report}
\usepackage[OT1]{fontenc}    \usepackage[italian]{babel}  \usepackage[square]{natbib}  \usepackage{graphicx}        \usepackage{lmodern}         \usepackage{enumitem}        \usepackage{float}           \usepackage{array}           
\renewcommand{\author}   { Andrea Simonetto }
\newcommand  {\subject}  { Deep Inference }
\renewcommand{\title}    { Indagini in Deep Inference }
\newcommand  {\keywords} { Deep Inference, Teoria della dimostrazione, Proof theory, Cut elimination }

\usepackage[pdfmark,          pdfauthor={\author}, pdfkeywords={\keywords},
	pdfsubject={\subject}, pdftitle={\title}]{hyperref}

\usepackage{amsmath,amssymb}  \usepackage{amsthm}           \usepackage{mathrsfs}         \usepackage{cmll}             \usepackage{bussproofs}       \usepackage{virginialake}     \usepackage{iidi}

\newtheorem{thm}{Teorema}[section]
\newtheorem{dfn}[thm]{Definizione}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollario}
\newtheorem{prop}[thm]{Proposizione}

\hyphenation{sil-la-ba-zio-ne pa-ren-te-si com-mu-ta-ti-ve}

\usepackage{indentfirst}       \usepackage{fancyhdr}          \oddsidemargin=30pt \evensidemargin=20pt
\pagestyle{fancy}\addtolength{\headwidth}{20pt}
\renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection \ #1}{}}
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\cfoot{}
\hypersetup {                    bookmarks=true,          colorlinks=true         }
\linespread{1.3}                 
\floatstyle{boxed}
\restylefloat{figure}
\makeatletter
\renewcommand\fs@boxed{\def\@fs@cfont{\bfseries}\let\@fs@capt\floatc@plain
  \def\@fs@pre{\setbox\@currbox\vbox{\hbadness10000
    \moveleft10.4pt\vbox{\advance\hsize by20.8pt
      \hrule \hbox to\hsize{\vrule\kern10pt
        \vbox{\kern10pt\box\@currbox\kern10pt}\kern10pt\vrule}\hrule}}}\def\@fs@mid{\kern10pt}\def\@fs@post{}\let\@fs@iftopcapt\iffalse}

\begin{document}
\begin{titlepage}
	\topmargin=0cm
	\begin{center}
		\mbox{{\large{\textsc{Alma Mater Studiorum  Universit\`a di Bologna}}}}
		\rule[0.1cm]{14.0cm}{0.1mm}
		\rule[0.5cm]{14.0cm}{0.6mm}
		{\small{\bf FACOLT\`A DI SCIENZE MATEMATICHE, FISICHE E NATURALI\\
		Corso di Laurea Magistrale in Informatica}}
	\end{center}
	\vspace{15mm}
	\begin{center}
		{\LARGE{\bf INDAGINI IN}}\\
		\vspace{3mm}
		{\LARGE{\bf DEEP}}\\
		\vspace{3mm}
		{\LARGE{\bf INFERENCE}}\\
		\vspace{19mm} {\large{\bf Tesi di Laurea in Tipi e Linguaggi di Programmazione}}
	\end{center}
	\vspace{40mm}\par\noindent
	\begin{minipage}[t]{0.52\textwidth}
		{\large{\bf Relatore:\\
		Chiar.mo Prof.\\
		Simone Martini}}
	\end{minipage}
	\hfill
	\begin{minipage}[t]{0.52\textwidth}\raggedleft
		{\large{\bf Presentata da:\\
		Andrea Simonetto}}
	\end{minipage}
	\vspace{20mm}
	\begin{center}
		{\large{\bf II Sessione\\
		Anno Accademico 2009/2010}}
	\end{center}
\end{titlepage}
\clearpage{\pagestyle{empty}\cleardoublepage}
\begin{titlepage}
	\thispagestyle{empty}
	\topmargin=5cm
	\raggedleft\large\emph{
		Alla venerata memoria \\
		di mio nonno, Gino Simonetto.} \\
	\vspace{3em}
	\raggedleft\large\emph{
		Wir m\"ussen wissen. Wir werden wissen. \\
		(David Hilbert)} \\
	\newpage
	\clearpage{\pagestyle{empty}\cleardoublepage}
\end{titlepage}
\pagenumbering{roman}

\phantomsection\addcontentsline{toc}{chapter}{Introduzione}
\chapter*{Introduzione}
\rhead[\fancyplain{}{\bfseries INTRODUZIONE}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries INTRODUZIONE}}

La matematica ama parlare di s\'e stessa. Dalla teoria dei numeri -- ritenuta da Gauss la ``regina della matematica'' -- all'analisi -- l'hilbertiana ``sinfonia coerente dell'universo'' -- la matematica pura \`e abituata a porsi ad oggetto delle proprie speculazioni. Anche la \emph{logica matematica} possiede spiccate tendenze narcisistiche\footnote{Secondo Locke, la logica \`e ``l'anatomia del pensiero''. Occorre tuttavia precisare che usando il termine ``logica'', Locke intendeva quella parte di filosofia che studia il ragionamento e l'argomentazione; la logica matematica cominci\`o a fiorire solo un secolo e mezzo dopo la sua morte.}; nondimeno, vista la sua propensione ad affrontare questioni di fondamento, \`e certamente una delle branche che ama maggiormente parlare di matematica. Tra i vari contributi \`e doveroso citare, come esempi eccellenti, l'\emph{aritmetica di Peano} e la \emph{teoria assiomatica degli insiemi} di Zermelo--Fraenkel.

Uno dei concetti cardine di tutta la matematica \`e quello di \emph{dimostrazione}. Per studiare questi oggetti, i logici hanno sviluppato un'infrastruttura nota come \emph{teoria della dimostrazione}. In questa tesi faremo una panoramica sulla teoria della dimostrazione, concentrandoci su uno degli sviluppi pi\`u recenti, una tecnica nota come \emph{deep inference}.

La deep inference \`e una nuova \emph{metodologia} in proof theory utile a progettare \emph{famiglie di sistemi formali} (o \emph{formalismi}) con buone propriet\`a, quali:
\begin{itemize}
	\item l'\emph{efficienza} nella rappresentazione delle dimostrazioni: alcuni sistemi rendono disponibili dimostrazioni pi\`u brevi di quanto possano fare altri (questi aspetti sono studiati in \emph{complessit\`a delle dimostrazioni} o \emph{proof complexity});
	\item \emph{analiticit\`a}: alcuni sistemi vengono naturalmente con algoritmi di \emph{ricerca delle dimostrazioni} (o di \emph{proof search}) \emph{efficienti}, altri no, altri ancora solo con alcuni accorgimenti. L'analiticit\`a \`e la propriet\`a chiave per ottenere algoritmi di proof search efficienti;
	\item l'abilit\`a di esprimere dimostrazioni che sono matematicamente naturali, cio\`e senza artefatti sintattici ``amministrativi'' (si parla in questi casi di \emph{burocrazia delle dimostrazioni}). Uno dei problemi di ricerca principali in proof theory \`e trovare una buona corrispondenza tra le dimostrazioni e il loro significato. In particolare, il problema dell'\emph{identit\`a delle dimostrazioni} \`e prominente, e consiste nel trovare nozioni di equivalenza tra dimostrazioni non banali, supportate da semantiche appropriate alle dimostrazioni e ai sistemi formali.
\end{itemize}

I \emph{formalismi} controllano, in larga parte, la progettazione delle regole d'inferenza. Per esempio, la deduzione naturale prescrive che, per ogni connettivo, siano date due regole: una d'introduzione e una di eliminazione. In tutti i formalismi tradizionali (ma anche in quelli pi\`u moderni derivati dai primi), viene adottato un meccanismo noto come \emph{shallow inference} o \emph{inferenza di superficie}, nel quale le regole di inferenza operano sui connettivi pi\`u prossimi alla radice delle formule -- quando vengono viste come alberi, cio\`e quando ci si concentra sulla loro \emph{struttura sintattica}. 

L'inferenza di superficie \`e una metodologia molto naturale, poich\'e permette di procedere per induzione strutturale diretta sulle formule. Tuttavia non \`e ottimale riguardo alcune propriet\`a dei sistemi formali, quali quelle sopra menzionate. In particolare:
\begin{itemize}
	\item sembra sia incapace di fornire formalismi analitici che siano efficienti riguardo la complessit\`a delle dimostrazioni;
	\item le dimostrazioni tendono ad avere molta burocrazia, cio\`e rappresentazioni sintatticamente complesse degli argomenti matematici.
\end{itemize}

Inoltre la shallow inference fatica a relazionarsi con le logiche modali. Teorie logiche modali possono essere definite nei sistemi di Frege-Hilbert, ma ottenere analiticit\`a per essi \`e una sfida molto ardua, in alcuni casi ancora irrisolta. In pi\`u \`e altrettanto difficile (se non addirittura impossibile) esprimere sistemi formali per logiche non-commutative.

Nel seguito mostreremo alcuni tra i maggiori risultati di teoria della dimostrazione ottenuti mediante un formalismo deep inference, noto come \emph{calcolo delle strutture}. Il calcolo delle strutture \`e un contributo importante nello sviluppo della metodologia deep inference, per la sua semplicit\`a e la sua somiglianza coi formalismi tradizionali. Grazie al calcolo delle strutture, sono stati ottenuti i seguenti risultati:
\begin{itemize}
	\item la logica classica, intuizionista, lineare a alcune logiche modali possono essere espresse in sistemi che godono di analiticit\`a;
	\item \`e possibile esprimere logiche lineari munite di \emph{operazioni} \emph{non-commuta-tive} in sistemi analitici, e si dimostra che queste logiche non possono essere formalizzate analiticamente nel calcolo dei sequenti; inoltre questi sistemi logici sono in forte corrispondenza con le algebre di processo;
	\item sono state sviluppate tecniche nuove e generali di normalizzazione, e sono state scoperte \emph{nozioni del tutto nuove} di normalizzazione, in aggiunta alla tradizionale \emph{cut elimination};
	\item la maggior parte dei sistemi sviluppati sono costituiti interamente da regole d'inferenza \emph{locali}; una regola d'inferenza locale ha \emph{complessit\`a computazionale costante}. La localit\`a \`e una propriet\`a difficile da conseguire, e non \`e ottenibile nel calcolo dei sequenti per la logica classica;
	\item i sistemi ottenuti sono estremamente modulari; questo significa una \emph{forte indipendenza tra le regole d'inferenza};
	\item moti sistemi sono stati implementati, grazie a tecniche che producono regole d'inferenza atte a migliorare l'efficienza senza sacrificare le propriet\`a teoriche;
	\item tutti i sistemi ottenuti sono semplici, nel senso che le regole d'inferenza sono \emph{contenute e intelligibili}.
\end{itemize}

Il calcolo delle strutture \`e una generalizzazione di molti formalismi shallow inference, in particolare del calcolo dei sequenti. Questo significa che ogni dimostrazione data in questi formalismi shallow inference, pu\`o essere ``mimata'' nel calcolo delle strutture, preservandone la complessit\`a e senza perdita di propriet\`a strutturali.

\clearpage{\pagestyle{empty}\cleardoublepage}
\tableofcontents
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries INDICE}}
\clearpage{\pagestyle{empty}\cleardoublepage}

\listoffigures
\clearpage{\pagestyle{empty}\cleardoublepage}


\chapter{Formalismi e metodologie}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\pagenumbering{arabic}


La teoria della dimostrazione nacque sul finire del XIX secolo, ad opera di David Hilbert e dei suoi collaboratori. Fu un periodo in cui la matematica visse una crisi senza precedenti, intaccata in prossimit\`a dei suoi fondamenti logici dal manifestarsi di una serie di paradossi, proprio mentre la scuola intuizionista di Brouwer ne metteva in dubbio alcuni princ\`ipi filosofici basilari, fatti che sommati minavano alla base la maggior parte della matematica esistente. 

Tuttavia, forti evidenze empiriche suffragavano la matematica conosciuta, e molti matematici rifiutarono di abbandonarla o rifondarla: tra loro, Hilbert avanz\`o un programma di salvataggio completo. Egli propose di formulare la matematica classica come teoria formale assiomatica, e in seguito di provarne la \emph{consistenza} (ossia la non contraddittoriet\`a).

Prima della proposta di Hilbert, la consistenza di teorie assiomatiche veniva provata esibendo un ``modello'': data una teoria assiomatica, un \emph{modello} \`e un sistema di oggetti, presi da qualche altra teoria, tali da soddisfare gli assiomi, cio\`e, ad ogni oggetto o nozione primitiva della teoria assiomatica, viene fatto corrispondere un oggetto o una nozione dell'altra teoria, in modo tale che gli assiomi corrispondano a teoremi nell'altra teoria. Se l'altra teoria \`e consistente, anche quella assiomatica deve esserlo. Un esempio famoso \`e dato dalla dimostrazione di Beltrami (1868) della consistenza della geometria iperbolica: egli prov\`o che le rette nel piano non-euclideo della geometria iperbolica, potevano essere rappresentate dalle geodesiche su una superficie di curvatura costante e negativa nello spazio euclideo. Da questo concluse che il piano iperbolico dev'essere consistente, a patto che la geometria euclidea lo sia.

\`E chiaro che il metodo del modello \`e relativo. La teoria assiomatica \`e consistente solo se il suo modello lo \`e. Ma per provare l'assoluta consistenza della matematica classica, il metodo dei modelli non offriva speranze: nessuna teoria matematica era accettabile come modello, poich\'e da ognuna di esse sarebbe fatalmente riemerso il problema di partenza, cio\`e dimostrarne la consistenza.

Hilbert propose di affrontare il problema in maniera diretta: per provare la consistenza di una teoria, si deve dimostrare al suo interno una proposizione sulla teoria stessa, cio\`e un teorema su tutte le possibili dimostrazioni della teoria. La branca di matematica che si occupa di questi aspetti di formalizzazione e riflessione, venne battezzata da Hilbert ``metamatematica'' o ``teoria della dimostrazione''.

Purtroppo il sogno di Hilbert s'infranse nel 1931 con il Secondo Teorema d'Incompletezza di~\cite{God31}, che enuncia l'impossibilit\`a per sistemi abbastanza espressivi da formalizzare l'aritmetica di dimostrare la propria consistenza: purtroppo la quasi totalit\`a della matematica da salvare, passava per l'aritmetica. Tuttavia la teoria della dimostrazione sopravvisse a questo scossone, diventando importante in vari ambiti, tra i quali l'informatica.

In informatica, i dimostratori automatici di teoremi richiedono uno studio della struttura combinatoriale delle dimostrazioni, mentre nella programmazione logica la deduzione \`e usata come fondamento della computazione. Inoltre esistono forti connessioni tra sistemi logici e linguaggi di programmazione funzionali, e tecniche di proof theory sono state utilizzate per porre dei vincoli di complessit\`a computazionale ad alcuni di questi linguaggi (ad esempio in~\cite{Gir95a}).


Uno dei princ\`ipi fondamentali in proof theory \`e che la formalizzazione di una teoria richiede una totale astrazione dal significato, cio\`e un \emph{sistema formale} dovrebbe essere una mera manipolazione simbolica spogliata di ogni interpretazione semantica. Dato un sistema formale, distinguiamo il livello rigoroso del sistema stesso (o \emph{livello oggetto}), dal livello in cui esso viene studiato (il \emph{meta-livello}) espresso nel linguaggio della matematica intuitiva e informale. 

Inoltre, per essere convincenti, gli strumenti usati nelle meta-teorie dovrebbero essere ristretti a tecniche -- chiamate \emph{finitarie} dai formalisti, o, in un accezione pi\`u moderna, \emph{combinatorie} -- che impiegano solo oggetti intuitivi e processi effettivi (in accordo con la scuola intuizionista). Nessuna classe infinita di oggetti deve poter essere trattata come un ``tutto''; le prove di esistenza dovrebbero sempre esibire, almeno implicitamente, un testimone.

La proof theory \`e dunque una collezione di meta-teorie finitarie, espresse nel linguaggio ordinario e con l'ausilio di simboli matematici -- come variabili di meta-livello (o \emph{meta-variabili}) introdotte ove necessario -- tali da caratterizzare le propriet\`a dei vari sistemi formali. In questo capitolo introdurremo le nozioni di base della teoria della dimostrazione, partendo da insiemi finiti e generando quelli infiniti con procedure effettive, calcolabili.

Quella di cui abbiamo discusso finora, va oggi sotto il nome di teoria della dimostrazione \emph{strutturale}, cio\`e un'analisi combinatoriale della struttura delle dimostrazioni formali; gli strumenti centrali sono il \emph{Teorema di eliminazione del taglio} e quello di \emph{normalizzazione}.

Il percorso che seguiremo in questo capitolo \`e liberamente ispirato a~\cite{Kle52}, e si articola in quattro sezioni, le prime tre piuttosto standard, mentre la quarta aggiunta appositamente per trattare il tema della tesi, ossia la deep inference. Nell'ordine:

\begin{enumerate}
	\item si definir\`a uno strumento linguistico formale, in grado di produrre dei \emph{linguaggi oggetto} che costituiranno gli elementi base della logica da indagare;
	\item sar\`a introdotto un livello linguistico formale superiore (o \emph{meta-livello}), tale da permetterci di ragionare sui vari linguaggi oggetto, e saranno date le definizioni e gli strumenti di indagine basilari;
	\item verranno formalizzati i concetti di \emph{deduzione} e di \emph{dimostrazione}, a partire da un generico \emph{linguaggio oggetto}, usando gli strumenti del \emph{meta-livello}, e saranno presi in esame i \emph{formalismi} (i.e. le famiglie di sistemi) esprimibili con tali strumenti;
	\item si definirranno e si metteranno a confronto le due \emph{metodologie di inferenza}: di superficie e di profondit\`a (shallow \emph{versus} deep inference).
\end{enumerate}
Affronteremo il tutto sempre tenedo presente il vincolo di effettiva costruibilit\`a delle procedure e la caratterizzazione combinatoria delle tecniche e degli strumenti via via introdotti, in pieno stile formalista.


\section{Linguaggi formali} 
In questa sezione svilupperemo le basi di linguaggi formali che utilizzeremo da qui in avanti. Alcuni concetti saranno forniti in maniera intuitiva, altri in modo pi\`u preciso: per approfondimenti su linguaggi formali e grammatiche, si rimanda ad~\cite{Aho72, Aho06}.

\begin{dfn}[Alfabeti, stringhe, linguaggi, sottolinguaggi]
Un \emph{alfabeto}  \`e un insieme finito non vuoto di \emph{simboli}. Una \emph{stringa su un alfabeto}\footnote{Per convenzione useremo le lettere minuscole prese dall'inizio dell'alfabeto inglese per denotare i simboli, e le lettere minuscole alla fine dell'alfabeto, di solito , per denotare le stringhe.}  \`e una sequenza finita di simboli scelti da . La \emph{stringa vuota}  \`e la stringa composta da zero simboli; essa \`e una stringa su qualunque alfabeto.

Siano  e  due stringhe su un alfabeto : la loro \emph{concatenazione} (si denota giustapponendo  a ) \`e la stringa . In particolare, per ogni stringa , si ha . Dato un alfabeto , definiamo:


Un \emph{linguaggio}  \emph{su un alfabeto}  \`e un'insieme di stringhe su  (cio\`e ). Infine, dato un linguaggio , si definisce \emph{sottolinguaggio di}  qualunque insieme di stringhe .
\end{dfn}

\begin{dfn}[Grammatiche, linguaggio generato]
Una grammatica \`e una quadrupla , dove:
\begin{itemize}
	\item  \`e un alfabeto di \emph{simboli grammaticali};
	\item  \`e un insieme di simboli, detti \emph{categorie sintattiche} (o \emph{simboli non terminali}, in contrapposizione con gli altri simboli grammaticali , chiamati \emph{simboli terminali});
	\item  \`e una particolare categoria sintattica, chiamata \emph{simbolo iniziale}, che rappresenta il linguaggio da definire;
	\item  \`e un insieme di coppie di stringhe , chiamate \emph{produzioni grammaticali}.  \`e chiamata \emph{testa della produzione}, mentre  \`e il \emph{corpo della produzione}.
\end{itemize}

Data una grammatica , la \emph{riscrittura ad un passo} () \`e un'applicazione di una delle produzioni in . Formalmente: siano , allora:

La \emph{riscrittura multipasso} () \`e la chiusura riflessiva e transitiva di quella ad un passo:

In particolare  per ogni .

Il \emph{linguaggio generato da una grammatica}  (denotato con ) \`e l'insieme delle stringhe di simboli terminali ottenibili tramite riscrittura multipasso a partire dal simbolo iniziale. In simboli:

\end{dfn}

\begin{dfn}[Grammatiche context-free, BNF]
Sia  una grammatica. Una \emph{regola di produzione} \`e \emph{context-free} se \`e della forma  con  e . Una \emph{grammatica} si dice \emph{context-free} se ogni sua regola di produzione \`e context-free.

Un modo compatto ed elegante per scrivere le regole di produzione grammaticale, \`e quello di usare la \emph{forma di Backus-Naur} o \mbox{BNF}~(\cite{Bac60}). Sia  una grammatica e sia:

il suo insieme di produzioni. Allora  in BNF si rappresenta come segue:

\end{dfn}


L'ultimo (ma non ultimo) strumento sintattico che consideriamo, serve per fare emergere le \emph{profonde simmetrie} che soggiacciono ai sistemi logici formali, ed \`e uno degli strumenti pi\`u usati in proof theory: il sequente. I sequenti sono una notazione sintattica, finalizzata ad inserire le formule logiche in ambienti adatti al ragionamento logico-deduttivo. Pi\`u precisamente:

\begin{dfn}[Sequente]\label{def:seq}
Dato un linguaggio , un \emph{sequente} \`e un espressione del tipo:

dove  sono \emph{liste finite} (eventualmente vuote) di stringhe di  -- con le usuali operazioni definite sulle liste:  \`e l'aggiunta di una stringa  in coda ad una lista , mentre  \`e la concatenazione delle liste  e ; non ci sono simboli per la lista vuota.

Il simbolo  \`e noto come \emph{turnstile} o \emph{tornello} e fu originariamente introdotto in~\cite{Fre79}.
\end{dfn}

L'idea intuitiva \`e che il sequente afferma (ipotizza) la deducibilit\`a di almeno una formula logica in  a partire dalle premesse in . Se  e , il sequente  \`e da intendersi come:
\begin{center}
	\textbf{Se}\quad  \emph{e}  \emph{e}  \quad\textbf{allora}\quad  \emph{oppure}  \emph{oppure} 
\end{center}
dove i significati di \emph{``Se \ldots~allora \ldots''}, \emph{``e''} ed \emph{``oppure''} devono essere resi espliciti in maniera formale.

Il sequente avente una lista vuota alla \emph{destra} del tornello (), afferma l'\emph{inconsistenza delle premesse}, quello avente la lista vuota alla \emph{sinistra} del tornello (), afferma che  \`e un \emph{teorema}, ossia che \`e vero a prescindere da ogni premessa. Il \emph{sequente vuoto} (cio\`e avente liste vuote alla \emph{destra} ed alla \emph{sinistra} del tornello) \emph{afferma il falso} (se in un sistema logico-formale si \`e in grado di \emph{dimostrare il falso}, allora esso \`e \emph{inconsistente}).


\section{Meta-livello} 

In questa sezione introdurremo i principali strumenti meta-linguistici: in genere nei testi di logica questo aspetto \`e lasciato perlopi\`u ad un livello intuitivo. Ho cercato, con questa presentazione originale, di renderli pi\`u formali perch\'e, sebbene spesso sottovalutati, ritengo che offrano alcuni interessanti spunti di riflessione.

Osserviamo come, data una grammatica:

al variare di  si producano linguaggi  diversi, seppur correlati tra loro, in funzione di quale categoria sintattica scegliamo come simbolo iniziale.

\begin{dfn}[Meta-variabili, meta-linguaggi, (sotto)formule]
Per ogni categoria sintattica , definiamo un insieme finito  di \emph{meta-variabili} di categoria , che sono dei ``segnaposti'' per una qualche stringa di . Grazie alle meta-variabili, possiamo imporre dei vincoli sulla forma delle stringhe di .

Il \emph{meta-livello linguistico}  \`e quello in cui, giunti ad un certo passo di riscrittura, sostituiamo ad ogni occorrenza di simboli non terminali, una meta-variabile di categoria corrispondente. Il \emph{meta-alfabeto} \`e composto dai terminali e dalle meta-variabili:

mentre il \emph{meta-linguaggio} di  \`e definito da:

dove  sta per ``qualunque sostituzione di metavariabili al posto dei simboli non terminali in ''. In simboli, se  denota un terminale:


Usiamo l'appellativo \emph{formula} per riferirci alle stringhe del meta-linguaggio . Data una formula  appartenente a , per \emph{sottoformula} s'intende una qualunque porzione di , che sia a sua volta compresa in .
\end{dfn}

\`E immediato dimostrare che, data una grammatica , il meta-linguaggio \`e pi\`u ricco del linguaggio, cio\`e che, per ogni :

Infatti, al meta-linguaggio appartengono banalmente tutte le stringhe di  (se spingiamo la riscrittura fino a produrre stringhe di terminali, la funzione  non fa niente), mentre in  non ci sono le meta-variabili e quindi \`e strettamente incluso. 

Le meta-variabili si \emph{istanziano} a stringhe del linguaggio oggetto tramite \emph{unificazione}, grazie alla quale \`e anche possibile eseguire delle \emph{istanze parziali} tra meta-variabili e altre formule del meta-linguaggio.

Osserviamo che i linguaggi sono insiemi infiniti, cos\`i come il loro meta-livello genera insiemi infiniti. Tuttavia la base da cui sono generati questi insiemi (la grammatica) \`e finita e la procedura di generazione \`e concreta. Inoltre per grammatiche context-free verificare se una stringa appartiene o meno al linguaggio generato \`e un problema decidibile (in tempo polinomiale), e l'operazione di unificazione \`e anch'essa effettiva. Insomma, tutti gli strumenti dati fin qui sono \emph{finitari}, in pieno stile formalista.

Il meta-linguaggio ci permette di ragionare induttivamente (ricorsivamente) sulla struttura delle stringhe di un linguaggio. Normalmente l'induzione \`e concentrata sulla parte pi\`u esterna delle formule, cio\`e su quella di superficie: ma la metodologia deep inference aggiunge qualcosa in pi\`u.

\begin{dfn}[Contesti, saturazione, ordine]
Data una grammatica , il \emph{linguaggio dei contesti su} , denotato con , \`e definito come il linguaggio generato dalla grammatica aumentata , dove  \`e un nuovo simbolo terminale chiamato \emph{contesto vuoto}. Un \emph{contesto (generico)} \`e una stringa di  (si indica spesso con  per enfatizzare il fatto che \`e un contesto).

Intuitivamente un contesto \`e una stringa di  con alcuni ``buchi'' (denotati da ) che possono a loro volta essere riempiti con stringhe di . L'operazione di \emph{saturazione di un contesto}  \emph{con una stringa}  si indica con , e consiste nella sostituzione testuale di  al posto di tutte le occorrenze di  dentro ; l'\emph{ordine di un contesto} (in simboli ) \`e il numero di occorrenze di  al suo interno. Ambedue si definiscono formalmente per induzione sulla struttura di  come mostrato in Figura~\ref{fig:satordctx}.

\begin{figure}
\begin{center}
\begin{tabular}{lclclcl}
	\multicolumn{3}{c}{\textbf{Saturazione contesti}} & \hspace{5em} & \multicolumn{3}{c}{\textbf{Ordine contesti}} \\
	 &  &  & &  &  &  \\
	 &  &  & &  &  &  \\
	 &  &  & &  &  & 
\end{tabular}
\end{center}
\caption{Definizioni induttive di \emph{saturazione} e \emph{ordine} di un contesto}
\label{fig:satordctx}
\end{figure}

Infine, sia  un numero naturale: il \emph{linguaggio dei contesti di ordine}  \emph{su}  (i.e. ) \`e cos\`i definito:

\end{dfn}

Data una grammatica , osserviamo che si ha , poich\'e per produrre le stringhe di  non si usa mai la regola di produzione aggiuntiva , ma solo quelle in , esattamente come accade per . Usando un argomento, analogo \`e possibile dimostrare che:

Infatti i contesti di  sono generati usando una (e una sola) volta la regola di produzione aggiuntiva ; in , dove questa regola non \`e presente, tutto quello che \`e possibile fare \`e riscrivere  con una delle altre produzioni di  per , che equivale a sostituire \emph{quella} occorrenza di  con una delle stringhe del linguaggio generato da , cio\`e proprio .

Per  non \`e possibile ottenere risultati analoghi su , poich\'e se da un lato \`e possibile riscrivere occorrenze diverse di  in modi diversi, dall'altro la saturazione di un contesto ammette un solo parametro in  (che viene replicato sempre uguale  volte). Inoltre  \`e un caso triviale, perch\'e la saturazione dei contesti in  non produce effetti (non si fanno sostituzioni). L'unico caso degno di nota \`e : esso rappresenta il punto di contatto tra il concetto di saturazione di un contesto -- i.e. ``sostituzione di \emph{una} variabile (fresca)'' -- e quello pi\`u generale di riscrittura: saturazione di un contesto e riscrittura multipasso coincidono per , cio\`e quando il processo di riscrittura \`e sostituito da quello di saturazione \emph{al pi\`u in un singolo punto}.

I contesti di ordine  su una grammatica sono uno strumento molto potente che ci consente di focalizzare l'attenzione su una porzione specifica di una stringa del linguaggio che dipende dalla sua struttura sottostante, astraendoci dal resto. Per la loro rilevanza, d'ora in poi quando parleremo di \emph{contesti} intenderemo sempre quelli di ordine . 

Anche i contesti sono strumenti di meta-livello, perch\'e trascendono il linguaggio oggetto, per permetterci di ragionare su esso. Per di pi\`u, un contesto pu\`o essere saturato con una qualunque formula di meta-livello: considerare arbitrari contesti ci permette di ragionare su classi di formule molto estese, ossia su formule \emph{immerse} in contesti arbitrari, cio\`e ad \emph{arbitrari livelli di profondit\`a}, concetto cardine di tutta la deep inference. Usando i contesti e il meta-linguaggio, possiamo ragionare per induzione strutturale sulla stringhe del linguaggio \emph{a qualsiasi livello di profondit\`a}. Inoltre, anche i contesti si possono \emph{unificare} con una procedura effettiva.

Al meta-livello ragioniamo su sequenti definiti sul meta-linguaggio. Le definizioni e le tecniche viste in precedenza per singole formule, si estendono in maniera naturale alle liste di formule e ai sequenti: in particolare, \`e possibile l'\emph{unificazione di sequenti} e considerare sequenti composti da formule \emph{immerse in contesti arbitrari} (con procedure effettive).


\section{Sistemi formali e formalismi} 
Le dimostrazioni sono l'oggetto di studio della proof theory; in questa sezione esplicitiamo la nozione di dimostrazione. Il termine ``dimostrare'' deriva dal latino \emph{demonstrare}, composto dalla radice \emph{de-} (di valore intensivo) e da \emph{monstrare} (``mostrare'', ``far vedere''), da cui il significato di \emph{rendere manifesto con fatti e con segni certi}. In matematica una dimostrazione \`e un \emph{processo di deduzione} che, partendo da \emph{premesse} assunte come valide (ipotesi) o da proposizioni dimostrate in virt\`u di tali premesse, determina la necessaria validit\`a di una nuova \emph{proposizione} in funzione della (sola) \emph{coerenza formale} del ragionamento. Le proposizioni saranno dunque stringhe appartenenti ad un linguaggio formale; il processo di deduzione sar\`a scandito dalla corretta applicazione di alcune regole di base in qualche modo riconosciute come elementari e la coerenza formale dovr\`a essere opportunamente formalizzata e funger\`a da argomento a sostegno della bont\`a delle regole scelte.

\begin{dfn}[Regole, derivazioni, dimostrazioni]
Un \emph{sistema formale} \`e una coppia  composta da un \emph{linguaggio}  (generato da qualche grammatica , tipicamente -- ma non necessariamente -- context-free) e da un insieme di regole d'inferenza (o \emph{sistema di deduzione}) . Date le formule , una \emph{regola di inferenza}  \`e un'espressione della forma:
\begin{center}
	\AxiomC{}
	\AxiomC{}
	\AxiomC{}
	\RightLabel{}
	\TrinaryInfC{}
	\DisplayProof{}
\end{center}
dove  sono chiamate \emph{premesse della regola } mentre  ne \`e la \emph{conclusione}. Una regola di inferenza senza premesse (i.e. avente ) \`e chiamata \emph{assioma}, mentre, per , \`e detta \emph{regola d'inferenza propria}. In genere le premesse e la conclusione di  sono formule (o sequenti) aventi una certa forma di superficie -- ed eventualmente, nell'approccio deep inference, immerse in arbitrari contesti. A questo modo di procedere, cio\`e di specificare la \emph{forma} delle (eventuali) ipotesi e della conclusione delle regole d'inferenza, ci si riferisce spesso in letteratura col termine \emph{schema} (p.e. dicendo ``schema d'assioma'').

Un \emph{passo d'inferenza} o \emph{applicazione} o \emph{istanza} di una regola d'inferenza  \`e un'espressione della forma:
\begin{center}
	\AxiomC{}
	\AxiomC{}
	\AxiomC{}
	\RightLabel{}
	\TrinaryInfC{}
	\DisplayProof{}
\end{center}
dove  sono formule ottenute rispettivamente per unificazione (anche parziale, al meta-livello) con . Le stringhe  sono chiamate \emph{premesse dell'applicazione di } mentre  ne \`e la \emph{conclusione}. Indicheremo anche il nome della regola accanto alla barra orizzontale di derivazione, quando questo sar\`a d'aiuto alla comprensione e non sar\`a fonte d'ambiguit\`a.

Una \emph{derivazione}  da una lista di premesse  ad una conclusione  \`e un albero di istanze di regole in , avente  come radice e  come foglie, e indicato con:

Nel seguito ometteremo  e/o  quando questo non comporter\`a ambiguit\`a.



Infine, una \emph{dimostrazione} \`e una derivazione avente per come premesse  solo istanze di assiomi. La indicheremo con:

omettendo  e/o  quando e se necessario.
\end{dfn}

La \emph{derivabilit\`a} in un sistema formale (``da un insieme di formule  \`e possibile derivare la formula '', o anche `` \`e derivabile da '') \`e un concetto sintattico, cos\`i come lo \`e la \emph{dimostrabilit\`a} -- in contrapposizione al concetto di \emph{verit\`a} e a quello di \emph{modello}, che sono invece di natura semantica. Finora non abbiamo mai parlato di verit\`a: in questa sede non ci occuperemo degli aspetti semantici legati ai sistemi formali, che non sono oggetto di studio di proof theory, rimandando per questi ad~\cite{Abr92, Bar77, Cha73}.

Il concetto di derivabilit\`a si estende anche alle regole dei sistemi formali: un regola \`e derivabile quando \`e ottenibile tramite altre regole. Ma una regola pu\`o anche essere \emph{ammissibile} (o \emph{eliminabile}): questo accade quando la sua presenza all'interno del sistema non altera l'insieme di formule dimostrabili, ossia eliminando la regola dal sistema, si riescono a dimostrare \emph{le stesse cose}. Questo vale anche per le regole derivabili, ma mentre in quel caso era sufficiente sostituire la regola con la sua derivazione, per regole ammissibili occorre ristrutturare l'albero di prova.

\begin{dfn}[Regole derivabili e ammissibili]
Una regola  \`e \emph{derivabile} per un sistema  se, per ogni istanza di :

esiste una derivazione:


Una regola  \`e \emph{ammissibile} (o \emph{eliminabile}) per un sistema  se, per ogni dimostrazione  esiste una dimostrazione .
\end{dfn}

In teoria della dimostrazione ci concentriamo (al meta-livello) sulle propriet\`a dei sistemi formali, cio\`e le propriet\`a di cui godono le dimostrazioni espresse in qualche sistema formale. Ma \emph{quale} sistema formale? Seguendo~\cite{TroSch96}, possiamo raggrupparli in alcune grandi famiglie chiamate \emph{formalismi}:
\begin{itemize}
	\item \emph{Sistemi assiomatici} o \emph{sistemi alla Frege-Hilbert}~(\cite{HilAck28, Fre79}): in questo approccio accettiamo un numero molto ristretto di regole d'inferenza proprie (p.e. nella logica proposizionale solo una, il \emph{modus ponens}) mentre il resto del sistema deduttivo sar\`a composto da assiomi; le derivazioni in questo formalismo furono originariamente concepite per rispecchiare le dimostrazioni espresse in linguaggio naturale, obiettivo ambizioso e scarsamente raggiunto da questo approccio in cui le dimostrazioni tendono invece ad essere molto dettagliate e ``pedanti''. \`E l'approccio pi\`u datato e grazie ad esso \`e stato possibile formalizzare con successo sistemi deduttivi rilevanti quali: la logica classica, quella intuizionista ed alcune logiche modali;
	\item \emph{Deduzione naturale}: introdotta nel celebre~\cite{Gen35} (assieme, come vedremo, al \emph{calcolo dei sequenti}) questa famiglia di sistemi \`e pensata per mimare il ragionamento logico-deduttivo umano (da qui l'aggettivo ``naturale''). Non ci sono assiomi e le formule possono essere composte e decomposte (usando il gergo tecnico, rispettivamente \emph{introdotte} ed \emph{eliminate}).

	Un'operazione comune nella pratica matematica \`e quella di \emph{ragionare per assunzioni}: la deduzione naturale mette a disposizione un artificio per compiere questa operazione, e i sistemi espressi in deduzione naturale godono di buone propriet\`a, relativamente semplici da dimostrare (vedi il classico~\cite{Pra65});

	\item \emph{Calcolo dei sequenti}: dovuto a Gentzen, questo \`e lo strumento preferito in teoria della dimostrazione per le ottime propriet\`a di cui gode. Fa tipicamente uso di pochi assiomi (p.e. nella logica proposizionale solo uno, l'assioma \emph{identit\`a}) e molte regole d'inferenza proprie, che permettono di comporre nuove formule a partire dalle premesse (usando la terminologia della deduzione naturale, sono presenti le regole di \emph{introduzione} ma non quelle di \emph{eliminazione}).
\end{itemize}

Volendo aderire ad una visione ``proof theoretical'', ci concentreremo in seguito sul calcolo dei sequenti. \`E tuttavia doveroso osservare che questi formalismi consentono di definire sistemi formali aventi il medesimo potere espressivo: in altre parole, nessuno prevale a priori sugli altri, dipende dal \emph{setting} in cui ci poniamo. 

Inoltre questi sono solo i formalismi ``classici''; esistono altre famiglie di sistemi formali, che possono essere usate per mettere in evidenza altri aspetti importanti del processo deduttivo e delle dimostrazioni. Tra questi \`e doveroso citare le \emph{Proof Nets}, introdotte in~\cite{Gir87} allo scopo di far emergere alcune simmetrie dei sistemi formali che erano ``oscurate'' dal calcolo dei sequenti.

Le tre famiglie sopra descritte adottano tutte shallow inference come specifica delle regole d'inferenza (per quanto questa sia una scelta del tutto arbitraria). Ma l'approccio deep inference apre la via ad (almeno) un quarto formalismo:
\begin{itemize}
	\item \emph{Calcolo delle strutture}: introdotto in~\cite{Gug02}, i sistemi deduttivi in calcolo delle strutture constano di un piccolo numero di assiomi e di regole d'inferenza proprie, e godono di una notevole quantit\`a di propriet\`a, sostanzialmente estendendo quelle studiate per il calcolo dei sequenti. Le nuove prospettive aperte nell'ambito del calcolo delle strutture, ne fanno uno strumento di grande interesse e in continuo sviluppo da parte della comunit\`a scientifica.
\end{itemize}

\newpage

\section{Metodologie: shallow \emph{versus} deep inference} 
Le metodologie guidano la progettazione dei sistemi deduttivi e il processo di inferenza: le due metodologie conosciute allo stato dell'arte sono \emph{shallow} e \emph{deep inference} e le esamineremo a turno. 

\begin{dfn}[Shallow inference]
Per \emph{shallow inference} o \emph{inferenza di superficie}, intendiamo la \emph{metodologia} d'inferenza che interpreta l'insieme delle regole d'inferenza come \emph{schemi} che disciplinano il comportamento della deduzione \emph{in funzione del connettivo principale} delle formule.
\end{dfn}

\begin{figure}[tbhp]
\begin{minipage}[t]{.64\textwidth}
	\begin{center}
	\textbf{Regole d'inferenza}
	
	\begin{tabular}{cc}
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\DisplayProof{} &
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\DisplayProof{} \\\\
		\AxiomC{} \RightLabel{} \UnaryInfC{} \DisplayProof{} &
		\AxiomC{} \AxiomC{} \RightLabel{} \BinaryInfC{} \DisplayProof{} \\\\
		\multicolumn{2}{c}{ \AxiomC{} \AxiomC{} \RightLabel{} \BinaryInfC{} \DisplayProof{}}
	\end{tabular}
	\end{center}
\end{minipage}
\begin{minipage}[t]{.35\textwidth}
	\begin{center}
	\textbf{Gramm. linguaggio}
	
	\footnotesize{(con  infinit\`a numerabile di simboli proposizionali)}
	\end{center}
	\begin{center}
	\textbf{Struttura formula}
	\begin{picture}(120,85)
		\thinlines
		\put(58,71){\makebox(0,0){}}
		\put(28,44){\line(4,3){30}}
		\put(25,38){\makebox(0,0){}}
		\put(25,32){\line(-1,-1){18}}
		\put(25,32){\line(1,-1){18}}
		\put(4,7){\makebox(0,0){}}
		\put(46,7){\makebox(0,3){}}
		\put(88,44){\line(-4,3){30}}
		\put(91,38){\makebox(0,0){}}
		\put(91,32){\line(-1,-1){18}}
		\put(91,32){\line(1,-1){18}}
		\put(70,7){\makebox(0,3){}}
		\put(112,7){\makebox(0,0){}}
	\end{picture}
	\end{center}
\end{minipage}
\caption{Sistema formale in shallow inference ed esempio di formula}
\label{fig:sfef}
\end{figure}

Essendo l'approccio pi\`u datato, \`e anche il pi\`u usato in letteratura, come in \emph{deduzione naturale} (i sistemi \textsf{NK} ed \textsf{NJ} usano shallow inference) e nel \emph{calcolo dei sequenti} (sistemi \textsf{LK}, \textsf{LJ}). Ad esempio: per derivare  con le regole d'inferenza in Figura~\ref{fig:sfef}, consideriamo la struttura della formula  ed osserviamo che il connettivo principale \`e . A questo punto l'unica regola applicabile (i.e. istanziabile, ricordiamo che le regole d'inferenza sono \emph{schemi}) in shallow inference \`e . In questo modo otteniamo:
\begin{center}
	\AxiomC{}
	\UnaryInfC{}
	\DisplayProof{}
\end{center}
Procedendo in maniera analoga osserviamo che ci sono tre regole applicabili per derivare , cio\`e:
\begin{itemize}
	\item  produce la derivazione:
	\begin{center}
		\AxiomC{}
		\UnaryInfC{}
		\UnaryInfC{}
		\DisplayProof{}
	\end{center}
	da cui \`e applicabile solo  che produce una derivazione bloccata (cio\`e un albero le cui foglie non sono istanze di assiomi, n\'e sono derivabili dalle regole del sistema);
	\item  analogo al precedente;
	\item  produce la derivazione:
	\begin{center}
		\alwaysNoLine
		\AxiomC{}
		\UnaryInfC{}
		\AxiomC{}
		\UnaryInfC{}
		\alwaysSingleLine
		\BinaryInfC{}
		\UnaryInfC{}
		\DisplayProof{}
	\end{center}
	in cui \`e possibile applicare  o  sia alla formula  che alla . L'unica combinazione che porta ad una conclusione -- cio\`e in cui ogni foglia \`e un'istanza di  -- \`e un'applicazione di  a  e di  a , ottenendo cos\`i:
	\begin{center}
		\AxiomC{}
		\UnaryInfC{}
		\AxiomC{}
		\UnaryInfC{}
		\BinaryInfC{}
		\UnaryInfC{}
		\DisplayProof{}
	\end{center}
\end{itemize}

La procedura descritta nell'esempio \`e nota come \emph{proof search} ed \`e automatizzabile (p.e. si pu\`o basare sulla risoluzione come avviene in \textsf{PROLOG}) per sistemi \emph{in cui la regola di taglio \`e ammissibile}.

\begin{dfn}[Deep inference] Per \emph{deep inference} o \emph{inferenza di profondit\`a} intendiamo la metodologia in cui le regole d'inferenza si possono applicare ad arbitrari contesti, e quindi ad arbitrari livelli di profondit\`a, in contrapposizione a quanto avviene nell'inferenza di superficie o \emph{shallow inference}. Il ruolo dei contesti \`e quello di permettere l'accesso alla struttura delle formule senza dover usare alberi di derivazione (cio\`e senza decomposizione strutturale delle formule). Per questa ragione le regole d'inferenza in deep inference hanno al pi\`u una premessa: pertanto le derivazioni prendono la forma di liste. Per enfatizzare il fatto che le derivazioni sono \emph{alberi degeneri} (i.e. ogni nodo ha al pi\`u un figlio), usiamo la notazione: 

per indicare una derivazione  che usa le regole in , e avente premessa  e conclusione .
\end{dfn}

Dimostriamo l'analogo della formula di prima, usando il sistema deep inference in Figura~\ref{fig:sf_cos}. Invece dell'implicazione, qui abbiamo solo la negazione sugli atomi, quindi la formula di prima diventa: .

\begin{figure}[t!]
\begin{minipage}[t]{\textwidth}
	\begin{minipage}[t]{.61\textwidth}
		\begin{center}
		\textbf{Regole logiche}
		
		\end{center}
		\begin{center}
		\begin{tabular}{ccc}
			
			& &
			 \\\\
		\end{tabular}
		\end{center}
	\end{minipage}
	\begin{minipage}[t]{.38\textwidth}
		\begin{center}
		\textbf{Grammatica linguaggio}
		
		\footnotesize{(con  infinit\`a numerabile di simboli proposizionali)}
		\end{center}
	\end{minipage}
\end{minipage}
\begin{minipage}[t]{\textwidth}
	\begin{minipage}[t]{.61\textwidth}
		\begin{center}
		\textbf{Regole strutturali}
		\end{center}
		\begin{tabular}{ccc}
			
			& &
			 \\\\
			
			& &
			 \\\\
			
			& &
			
		\end{tabular}
	\end{minipage}
	\begin{minipage}[t]{.38\textwidth}
		\begin{center}
		\textbf{Dimostrazione d'esempio}
		\end{center}
		
	\end{minipage}
\end{minipage}
\caption{Sistema formale in deep inference ed esempio di dimostrazione}
\label{fig:sf_cos}
\end{figure}

In questo caso abbiamo raggruppato le regole d'inferenza in ``regole logiche'' (simili a quelle viste prima) e ``regole strutturali''. Quest'ultime servono a formalizzare il fatto che i connettivi di congiunzione e di disgiunzione godono della propriet\`a commutativa -- rispettivamente regole  e  -- e di quella associativa -- regole  e  -- e che inoltre l'atomo  (risp. ) \`e elemento neutro per il connettivo di congiunzione (risp. disgiunzione). A parte per la propriet\`a commutativa, che \`e intrinsecamente simmetrica, per le altre bisognerebbe specificare anche le regole opposte; ad esempio, per  servirebbe una regola:

Per questa ragione, in deep inference, si \`e soliti \emph{sostituire le regole strutturali con una relazione d'equivalenza} tra formule.

Come possiamo vedere, la dimostrazione della medesima formula di prima \`e completamente mutata: innanzitutto osserviamo che le regole induttive, nel calcolo delle strutture, hanno sempre e solo una premessa ed una conclusione. Questo fa s\`i che le dimostrazioni si sviluppino solo in altezza, collassando il lavoro strutturale svolto dagli alberi, all'interno dei contesti. Inoltre il sistema formale \`e meno rigido di quello visto nell'esempio precedente, nel senso che la metodologia deep inference permette un'applicazione pi\`u capillare delle regole d'inferenza, e quindi in generale un maggior grado di libert\`a e di non-determinismo.


\chapter{Logica classica proposizionale}
In questo capitolo presenteremo una serie di definizioni e risultati tradizionali in proof theory di logica classica proposizionale, e studieremo le propriet\`a formali del suo corrispettivo in deep inference, chiamato Sistema \textsf{SKS}.

Il Sistema che andremo a studiare (chiamato \textsf{LKp}) \`e il frammento proposizionale del Sistema \textsf{LK} di~\cite{Gen35}, il cui nome \`e l'acronimo di \emph{Logik Klassische} ossia ``logica classica'' (mentre la ``p'' sta appunto per proposizionale). Il linguaggio  \`e quello dei sequenti in Definizione~\ref{def:seq}, aventi per formule quelle generate dalla grammatica:

dove  \`e una notazione abbreviata per i caratteri dell'alfabeto inglese, e le produzioni in , sono:

dove  appartiene alla \emph{notazione EBNF} (\emph{BNF estesa}) e significa semplicemente ``qualunque stringa non vuota di caratteri alfabetici''. Solitamente s'introduce un'ulteriore generalizzazione, considerando la produzione  dove  \`e una meta-variabile appartenente ad un insieme  composto da un'infinit\`a numerabile di stringhe (alfabetiche, alfa-numeriche, indicizzate con apici, pedici, \ldots), chiamate genericamente ``simboli proposizionali''. Osserviamo che le stringhe di  sarebbero facilmente ottenibili da una grammatica context-free, questa semplificazione serve solo ad alleggerire la notazione, mentre preserva intatto il carattere finitario del linguaggio oggetto.

Il sistema deduttivo  \`e dato usando forma di superficie dei sequenti. Le regole d'inferenza si possono dividere in quattro gruppi: assiomi, taglio, regole strutturali e regole logiche. 

Le regole strutturali sono di fondamentale importanza, perch\'e permettono di manipolare l'ordine ed il numero delle formule del sequente. Sono tre:
\begin{enumerate}
	\item L'\emph{ordine} delle premesse (e delle conclusioni) \emph{non \`e rilevante}. Da qui otteniamo le regole di \emph{permutazione}:
	\begin{center}
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\DisplayProof{}
		\qquad
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\DisplayProof{}
	\end{center}
	\item Assumere due volte la stessa premessa (o la stessa conclusione) \`e equivalente ad assumerla una volta sola. Questa osservazione ci conduce alle regole di \emph{contrazione}:
	\begin{center}
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\DisplayProof{}
		\qquad
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\DisplayProof{}
	\end{center}
	\item \`E sempre possibile sia aggiungere nuove ipotesi (rafforzare l'antecedente), sia aggiungere nuove conclusioni (indebolire il conseguente). In generale il sequente ne risulter\`a indebolito (in un caso serve un'ipotesi in pi\`u affinch\'e funzioni, nell'altro a parit\`a di ipotesi dimostra una cosa pi\`u vaga, con pi\`u possibili conseguenze). Questa \`e pertanto chiamata regola di \emph{indebolimento}:
	\begin{center}
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\DisplayProof{}
		\qquad
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\DisplayProof{}
	\end{center}
\end{enumerate}

Per individuare gli assiomi, ci poniamo la seguente domanda: quando si pu\`o sostenere che un sequente  \`e \emph{evidentemente} vero? Chiaramente quando , cio\`e quando almeno una delle premesse in  compare tra le conclusioni in . Questo sar\`a l'unico assioma del nostro Sistema, non ci sono altri criteri evidenti per passare dalle premesse alle conclusioni senza fare inferenza. In virt\`u delle regole strutturali, sappiamo che l'ordine non conta: pertanto dimostrare che esiste un  tale che , si pu\`o scrivere: . Inoltre possiamo sempre applicare la regola d'indebolimento a sinistra e a destra, per ottenere alfine:


Quella di taglio \`e un'altra regola fondamentale, che ci si aspetta che sia soddisfatta da ogni sistema deduttivo. Il suo scopo \`e garantire la \emph{componibilit\`a} delle dimostrazioni; questa propriet\`a \`e ampiamente sfruttata nella pratica matematica: per provare un teorema complesso, si pu\`o cominciare dimostrando dei lemmi pi\`u semplici, che possono essere poi composti per ottenere il risultato cercato. La formulazione della \emph{regola di taglio} \`e pertanto la seguente:
\begin{center}
	\AxiomC{}
	\AxiomC{}
	\RightLabel{}
	\BinaryInfC{}
	\DisplayProof{}
\end{center}

Infine le regole logiche sono quelle che specificano il comportamento dei connettivi logici. Come abbiamo gi\`a avuto modo di menzionare, nel calcolo dei sequenti \`e solo possibile \emph{introdurre} nuovi connettivi ma mai di \emph{eliminarli}. Questo fatto \`e alla base di una propriet\`a molto importante, detta \emph{della sottoformula} (vedi Definizione ~\ref{def:subformula}). Le regole d'introduzione dei connettivi saranno classificate in \emph{destre} (indicate con una ``'' a pedice) o \emph{sinistre} (indicate con ``'') a seconda che permettano d'introdurre il connettivo a destra oppure a sinistra del tornello. Vediamole rapidamente, ci sono quattro connettivi nel nostro linguaggio:
\begin{enumerate}
	\item \textbf{Congiunzione}: introdurre una congiunzione a sinistra significa rafforzare la premessa aggiungendo un'ipotesi. Come abbiamo detto in precedenza, il significato intuitivo del sequente va specificato formalmente, e queste regole chiarificano come le formule a sinistra del turnstile siano da considerarsi in congiunzione tra loro:
	\begin{center}
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\DisplayProof{}
		\qquad
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\DisplayProof{}
	\end{center}
	A destra invece, cio\`e per concludere che una congiunzione  vale, sotto un certo insieme di ipotesi, dobbiamo aver dimostrato separatamente i due rami  e  a partire dalle stesse assunzioni, cio\`e:
	\begin{center}
		\AxiomC{}
		\AxiomC{}
		\RightLabel{}
		\BinaryInfC{}
		\DisplayProof{}
	\end{center}

	\item \textbf{Disgiunzione}: il ragionamento e le regole seguono in maniera perfettamente simmetrica quanto visto per la congiunzione. Non c'\`e da sorprendersi, poich\'e la disgiunzione \`e il connettivo duale alla congiunzione, e poich\'e il sequente \`e fatto in modo da rispettare naturalmente tale simmetria. A destra del tornello, le formule sono da considerarsi in disgiunzione tra loro, e quindi abbiamo:
	\begin{center}
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\DisplayProof{}
		\qquad
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\DisplayProof{}
	\end{center}
	mentre a sinistra, se da un set comune di ipotesi  unito ad un'ipotesi  riusciamo a concludere che valgono certe conclusioni , e indipendentemente, dallo stesso set di premesse  unito stavolta ad una formula , siamo in grado di concludere le medesime conclusioni , allora da  e  possiamo concludere che vale , cio\`e:
	\begin{center}
		\AxiomC{}
		\AxiomC{}
		\RightLabel{}
		\BinaryInfC{}
		\DisplayProof{}
	\end{center}

	\item \textbf{Implicazione}: se la virgola a sinistra e a destra del tornello si comportano rispettivamente come una congiunzione e come una disgiunzione, il tornello stesso \`e l'implicazione. Questo fatto \`e reso evidente dalla regola d'introduzione destra della freccia. Infatti, la regola \`e:
	\begin{center}
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\DisplayProof{}
	\end{center}
	cio\`e afferma che se otteniamo una certa conclusione  supponendo  e , con solo  \`e possibile concludere che ``se vale  allora '', cio\`e proprio . Le altre conclusioni in  non giocano alcun ruolo intuitivo per questa regola, se non di preservare una certa omogeneit\`a nella forma del sequente. Abbiamo visto come una formula  sia in grado di passare da sinistra a destra del tornello, tramutandosi in un'implicazione. Anche il passaggio inverso \`e possibile:
	\begin{center}
		\AxiomC{}
		\AxiomC{}
		\RightLabel{}
		\BinaryInfC{}
		\DisplayProof{}
	\end{center}
	Qui si \`e dimostrato che da  si deriva  e, indipendentemente, che da  unito all'ipotesi aggiuntiva  si conclude . Allora da  e supponendo che  implichi  \`e possibile concludere .
	\item \textbf{Negazione}: in virt\`u di quanto visto finora, il comportamento della negazione dovrebbe risultare piuttosto semplice. Infatti, se consideriamo una singola formula, passare da una parte all'altra del tornello significa introdurre una negazione (la negazione di una formula \`e equivalente ad un'implicazione in cui dalla validit\`a della formula si conclude il falso). Formalmente:
	\begin{center}
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\DisplayProof{}
		\qquad
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\DisplayProof{}
	\end{center}
\end{enumerate}

Facciamo un esempio di \emph{regola derivabile} nel Sistema \textsf{LKp}: scriviamo la regola \emph{destra di congiunzione} e la regola di \emph{destra di congiunzione generalizzata}:
\begin{center}
	\AxiomC{}
	\AxiomC{}
	\RightLabel{}
	\BinaryInfC{}
	\DisplayProof{}
	\qquad
	\AxiomC{}
	\AxiomC{}
	\RightLabel{}
	\BinaryInfC{}
	\DisplayProof{}
\end{center}
\begin{itemize}
	\item  \`e banalmente derivabile da , infatti basta porre  e  per ottenere:
	\begin{center}
		\AxiomC{}
		\AxiomC{}
		\RightLabel{}
		\BinaryInfC{}
		\alwaysDoubleLine
		\UnaryInfC{}
		\DisplayProof{}
	\end{center}
	dove la doppia barra orizzontale indica un certo numero applicazioni di regole strutturali, in questo caso \emph{permutazione} e \emph{contrazione}. D'ora in avanti useremo sempre questa convenzione.
	\item  \`e derivabile da :
	\begin{center}
		\AxiomC{}
		\alwaysDoubleLine
		\UnaryInfC{}
		\AxiomC{}
		\UnaryInfC{}
		\RightLabel{}
		\alwaysSingleLine
		\BinaryInfC{}
		\DisplayProof{}
	\end{center}
\end{itemize}

Ragionamenti analoghi valgono per la regole sinistre di disgiunzione e implicazione (generalizzate). Per quanto riguarda le regole \emph{ammissibili}, avremo modo nel seguito di dimostrare \emph{l'ammissibilit\`a della regola di taglio} in \textsf{LKp}.

\begin{dfn}[Propriet\`a della sottoformula]\label{def:subformula}
Si dice che \emph{una regola d'inferenza  gode della propriet\`a della sottoformula} sse per ogni sua istanza:
\begin{center}
	\AxiomC{}
	\AxiomC{}
	\AxiomC{}
	\TrinaryInfC{}
	\DisplayProof{} 
\end{center}
si ha che  sono sottoformule di . Questa definizione si estende naturalmente alle regole del calcolo dei sequenti, imponendo che tutte le formule nelle premesse (sia a destra che a sinistra del turnstile) siano sottoformule di quelle presente nel sequente conclusione.

Inoltre si dice che \emph{un sistema formale gode della propriet\`a della sottoformula} quando tutte le sue regole d'inferenza ne godono.
\end{dfn}

La propriet\`a della sottoformula \`e molto rilevante, perch\'e conferisce ai sistemi una natura ``costruttiva'', il che ha molte importanti ripercussioni sulla meccanizzazione del processo inferenziale e sulla proof search. Un risultato classico \`e il seguente:

\begin{thm}[Consistenza]
Sia dato un sistema formale, espresso mediante il calcolo dei sequenti, non triviale (che non contiene il sequente vuoto tra gli assiomi). Allora, se gode della propriet\`a della sottoformula, esso \`e consistente (cio\`e non permette di derivare il sequente vuoto).
\end{thm}
\begin{proof}
La dimostrazione \`e immediata, poich\'e, se il sequente vuoto non \`e fra gli assiomi del sistema, dev'essere derivato con una regola d'inferenza propria . Ma per la propriet\`a della sottoformula, la regola d'inferenza  pu\`o avere per premesse solo sottoformule di quelle nel sequente vuoto, cio\`e non pu\`o avere premesse, ma  \`e propria per ipotesi. Pertanto il sequente vuoto non \`e derivabile ed il sistema \`e consistente.
\end{proof}

Da una rapida ispezione alle regole del Sistema \textsf{LKp}, ci accorgiamo che la propriet\`a della sottoformula vale per tutte le regole d'inferenza tranne che per la regola di taglio. Infatti  introduce un'arbitraria formula  tra le premesse. Onde preservare la propriet\`a della sottoformula, seguiamo i passi di Gentzen, dimostrando uno dei teoremi centrali della proof theory, noto come ``Gentzen Hauptsatz'', che ci garantisce che la regola di taglio \`e ammissibile all'interno del Sistema.

\section{Eliminazione del taglio}

Ci accingiamo a dimostrare una propriet\`a essenziale per la logica classica (e non solo), chiamata Hauptsatz, o teorema di eliminazione del taglio. L'Hauptsatz presumibilmente traccia il confine tra la logica e la nozione pi\`u ampia di sistema formale. Per sottolinearne l'importanza, Girard usa il motto:
\begin{quote}
	\emph{``A sequent calculus without cut elimination is like a car without engine''}~--~\cite{Gir95}
\end{quote}

\begin{dfn}[Grado, altezza derivazioni]
Il \emph{grado di una formula}  \`e definito per induzione strutturale come segue:
\begin{itemize}
	\item  \qquad per  simbolo proposizionale
	\item 
	\item 
\end{itemize}

Il \emph{grado di un'applicazione della regola di taglio} \`e definito come il grado della formula che elimina.

Il \emph{grado}  \emph{di una derivazione} \`e il massimo tra i gradi delle regole di taglio che vi compaiono. In particolare  se  non fa uso della regola di taglio.

Infine, l'\emph{altezza}  \emph{di una derivazione} \`e quella associata all'albero : se la regola conclusiva di  ha come premesse le derivazioni , allora  (mentre se , cio\`e se  \`e istanza di un assioma, allora ).
\end{dfn}

\begin{lem}~\label{lem:cut_LK1}
Sia  una derivazione della forma seguente:
\begin{center}
	\AxiomC{}
	\AxiomC{}
	\AxiomC{}
	\RightLabel{}
	\TrinaryInfC{}
	\AxiomC{}
	\AxiomC{}
	\AxiomC{}
	\RightLabel{}
	\TrinaryInfC{}
	\RightLabel{}
	\BinaryInfC{}
	\DisplayProof{}
\end{center}
in cui  (la premessa di sinistra del cut) \`e una regola logica ``destra'', mentre  (premessa destra del cut) \`e una regola logica ``sinistra'', tali da introdurre entrambe la formula . Allora esiste una derivazione:

con  e tale che .
\end{lem}
\begin{proof}
Procediamo per casi sulla premessa sinistra dell'applicazione di . Il fatto di concentrarci sulla premessa sinistra \`e del tutto irrilevante, poich\'e grazie alla simmetria delle regole logiche del Sistema \textsf{LKp}, se nella premessa sinistra s'introduce un certo connettivo (con una regola logica ``destra''), questo dovr\`a essere introdotto anche nella premessa di destra (con una regola logica simmetrica ``sinistra'').
\begin{enumerate}
	\item\label{proof:cut_lem1:case:1}  e : qui abbiamo .
	\begin{center}
		\AxiomC{}
		\AxiomC{}
		\RightLabel{}
		\BinaryInfC{}
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\RightLabel{}
		\BinaryInfC{}
		\DisplayProof{}
	\end{center}
	La derivazione  sopra si trasforma in  come segue:
	\begin{center}
		\AxiomC{}
		\AxiomC{}
		\RightLabel{}
		\BinaryInfC{}
		\DisplayProof{}
	\end{center}
	Osserviamo che , cio\`e il grado di  \`e diminuito di un fattore .

	\item\label{proof:cut_lem1:case:2}  e : in maniera simmetrica, qui abbiamo:
	\begin{center}
		\AxiomC{}
		\AxiomC{}
		\RightLabel{}
		\BinaryInfC{}
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\RightLabel{}
		\BinaryInfC{}
		\DisplayProof{}
	\end{center}
	che si trasforma nuovamente in  di grado inferiore:
	\begin{center}
		\AxiomC{}
		\AxiomC{}
		\RightLabel{}
		\BinaryInfC{}
		\DisplayProof{}
	\end{center}

	\item  e : qui abbiamo . Questo \`e il duale del caso \ref{proof:cut_lem1:case:1}:
	\begin{center}
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\AxiomC{}
		\AxiomC{}
		\RightLabel{}
		\BinaryInfC{}
		\RightLabel{}
		\BinaryInfC{}
		\DisplayProof{}
	\end{center}
	che si trasforma in  come segue:
	\begin{center}
		\AxiomC{}
		\AxiomC{}
		\RightLabel{}
		\BinaryInfC{}
		\DisplayProof{}
	\end{center}
	col grado di  diminuito di un fattore .
	\item  e : , caso simmetrico al precendente e duale a \ref{proof:cut_lem1:case:2}, produciamo una derivazione  avente grado pari a , a partire da :
	\begin{center}
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\AxiomC{}
		\AxiomC{}
		\RightLabel{}
		\BinaryInfC{}
		\RightLabel{}
		\BinaryInfC{}
		\DisplayProof{}
	\end{center}
	nel modo seguente:
	\begin{center}
		\AxiomC{}
		\AxiomC{}
		\RightLabel{}
		\BinaryInfC{}
		\DisplayProof{}
	\end{center}

	\item  e : qui abbiamo . La derivazione  pertanto \`e:
	\begin{center}
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\RightLabel{}
		\BinaryInfC{}
		\DisplayProof{}
	\end{center}
	Costruiamo  scambiando le premesse di  e applicando direttamente il taglio, per ottenere una derivazione di grado , come segue:
	\begin{center}
		\AxiomC{}
		\AxiomC{}
		\RightLabel{}
		\BinaryInfC{}
		\alwaysDoubleLine
		\UnaryInfC{}
		\DisplayProof{}
	\end{center}

	\item  e : . Allora :
	\begin{center}
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\AxiomC{}
		\AxiomC{}
		\RightLabel{}
		\BinaryInfC{}
		\RightLabel{}
		\BinaryInfC{}
		\DisplayProof{}
	\end{center}
	si trasforma in  come segue:
	\begin{center}
		\AxiomC{}
		\AxiomC{}
		\RightLabel{}
		\BinaryInfC{}
		\alwaysDoubleLine
		\UnaryInfC{}
		\AxiomC{}
		\UnaryInfC{}
		\alwaysSingleLine
		\RightLabel{}
		\BinaryInfC{}
		\DisplayProof{}
	\end{center}
	osserviamo che in quest'ultimo caso il problema \`e stato risolto usando \emph{due} tagli, entrambi di grado inferiore.
\end{enumerate}
\end{proof}

\begin{dfn}[Rimozione]
Sia  una formula e  una lista di formule: allora  denota  in cui \emph{tutte le occorrenze} della formula  sono state \emph{rimosse}.
\end{dfn}

Il seguente lemma dice che una (eventuale) applicazione della regola di taglio finale pu\`o essere eliminata. La sua complessa formulazione tiene conto delle regole strutturali che possono interferire col taglio.

\begin{lem}\label{lem:cut_LK2}
Sia  una formula di grado , e siano  rispettivamente le dimostrazioni di  e di  ambedue di grado minore di . Allora \`e possibile costruire una dimostrazione  di  di grado minore di .
\end{lem}
\begin{proof}
 \`e costruito per induzione su , ma sfortunatamente non in maniera simmetrica rispetto  e : ad un certo punto la preferenza sar\`a data a  od a , e  sar\`a irreversibilmente affetta da questa scelta.

Siano  e  rispettivamente:

e siano  e . Ci sono vari casi da considerare:
\begin{enumerate}
	\item  \`e un assioma. Ci sono due sottocasi:
	\begin{enumerate}
		\item  prova . Allora la dimostrazione  di  \`e ottenuta da  mediante l'applicazione di regole strutturali.
		\item  prova , con . Anche in questo caso applichiamo regole strutturali a  per ottenere .
	\end{enumerate}
	\item  \`e un assioma. Questo caso \`e del tutto analogo al precedente; \`e interessante notare che se  e  sono entrambi assiomi, abbiamo arbitrariamente privilegiato  (e questo potrebbe avere delle ripercussioni sulla complessit\`a di ).
	\item  \`e una regola strutturale. L'ipotesi induttiva per  e  ci danno una dimostrazione  per . Allora  \`e ottenuto da  mediante regole strutturali. Questo \`e possibile perch\'e, qualunque sia la regola strutturale , questa gode della propriet\`a della sottoformula, e quindi  \`e composto esclusivamente di sottoformule di , cos\`i come  \`e composto solo di sottoformule di . Quindi per ottenere il sequente conclusivo di , non dovr\`a essere tolta alcuna formula presente nella conclusione di , ma al massimo lo si dovr\`a \emph{indebolire}.
	\item  \`e una regola strutturale: analogo al precedente. 
	\item  \`e una regola logica, tranne una regola logica destra che introduce . L'ipotesi induttiva per  e  ci da  dimostrazioni  di . Poich\'e la regola  non introduce nuove occorrenze di  a destra del tornello, questa \`e applicabile alle  per ottenere : .
	\item  \`e una regola logica: analogo al precedente. 
	\item Sia  che  sono regole logiche:  \`e una regola logica destra che introduce , mentre  \`e una regola logica sinistra che introduce . Questo \`e l'ultimo caso rimanente, nonch\'e l'unico interessante, ed \`e simmetrico. Per ipotesi induttiva, applicata a:
	\begin{enumerate}
		\item  e , otteniamo le dimostrazioni  di ; ora, applicando  alle , e usando delle regole strutturali, otteniamo la dimostrazione  di ;
		\item  e , otteniamo le dimostrazioni  di ; ora, applicando  alle , e con l'ausilio di regole strutturali, otteniamo la dimostrazione  di .
	\end{enumerate}
	Ora abbiamo due dimostrazioni,  e , che si concludono come richiesto, se non per un'occorrenza di troppo della formula . Applicando la regola di taglio ad  e , otteniamo una dimostrazione  di:

che con semplici manipolazioni strutturali \`e riducibile a: 

Tuttavia il grado del taglio usato in  \`e troppo elevato (\`e proprio di grado ). Ma questo \`e precisamente il caso in cui si applica il Lemma~\ref{lem:cut_LK1}, grazie al quale il taglio in  pu\`o essere rimpiazzato con una derivazione di grado minore di , e avente la stessa conclusione, dalla quale, mediante regole strutturali, possiamo ottenere .
\end{enumerate}
\end{proof}

Il prossimo lemma, che ci condurr\`a al risultato finale, afferma che \`e sempre possibile trasformare una dimostrazione in modo tale da diminuirne il grado. Formalmente:

\begin{lem}\label{lem:cut_LK3}
Sia  una dimostrazione di grado  per un certo sequente. Allora \`e possibile costruire una dimostrazione  per il medesimo sequente, avente grado inferiore.
\end{lem}
\begin{proof}
Per induzione sull'altezza  della dimostrazione iniziale. Sia  l'ultima regola applicata in  e siano  le premesse di . Abbiamo due casi:
\begin{enumerate}
	\item  non \`e un taglio di grado . Per ipotesi induttiva, abbiamo  di grado minore di , a cui possiamo applicare  per ottenere ;
	\item  \`e un taglio di grado :
	
	Osserviamo che poich\'e il grado di questo  \`e , abbiamo . Per ipotesi induttiva:
	
	hanno grado minore di , e possiamo applicarvi il Lemma~\ref{lem:cut_LK2} per produrre  di grado inferiore a ; con alcune applicazioni di regole strutturali, otteniamo infine .
\end{enumerate}
\end{proof}

\begin{thm}[Gentzen Hauptsatz]\label{thm:haupt_lk}
La regola di taglio \`e ammissibile nel Sistema \textsf{LKp}.
\end{thm}
\begin{proof}
\`E sufficiente iterare l'applicazione del lemma precedente per trasformare una dimostrazione di grado strettamente positivo, in una di grado nullo, e quindi esente da applicazioni della regola di taglio.
\end{proof}

Il processo di eliminazione dei tagli fa esplodere l'altezza delle dimostrazioni. Infatti il Lemma~\ref{lem:cut_LK2} fa crescere l'altezza della prova in modo lineare nel caso peggiore (di un fattore , senza considerare le applicazioni delle regole strutturali). Il Lemma~\ref{lem:cut_LK3} comporta una crescita esponenziale nel caso pessimo, cio\`e ridurre il grado di  pu\`o accrescere l'albero di prova da  a , poich\'e usando il Lemma~\ref{lem:cut_LK2} moltiplichiamo per  ad ogni unit\`a di altezza.

Quindi, mettendo tutto assieme, applicare l'Hauptsatz comporta una crescita iperesponenziale. Partendo da una dimostrazione di grado  e altezza  se ne ottiene una avente altezza , dove:


L'Hauptsatz -- in varie forme, come la normalizzazione nel -calcolo -- \`e utilizzabile come fondamento teorico per la computazione. Per esempio, consideriamo un editor di testo: pu\`o essere visto come un insieme di lemmi generici (corrispondenti alle varie procedure di formattazione, impaginazione, \ldots) che possono essere applicati a input concreti, come una pagina scritta da qualche utente. Il numero di input possibili \`e chiaramente infinito e infatti i lemmi sono fatti per trattare infiniti casi; ma quando eseguiamo il programma su un certo input -- ad esempio per produrre in output una visualizzazione del testo -- i riferimenti a queste infinit\`a scompaiono. Concretamente, questa eliminazione dell'infinito \`e effettuata sostituendo sistematicamente le variabili (gli input dei lemmi) con il testo inserito dall'utente, in altre parole, eseguendo il programma. 

Questo \`e esattamente quello che fa l'algoritmo di eliminazione del taglio. Ecco perch\'e la struttura della procedure di cut elimination \`e cos\`i importante (osservazione fatta nel Lemma~\ref{lem:cut_LK2}). La strategia adottata nel ristrutturare la dimostrazione, effettuando le sostituzioni, produce delle scelte che sono, in generale, irreversibili. Questo pu\`o essere un problema, e si pu\`o risolvere ad esempio usando, al posto del calcolo dei sequenti, la deduzione naturale, che gode della propriet\`a di \emph{confluenza} (o \emph{propriet\`a di Church-Rosser}), la quale garantisce che \emph{le scelte fatte sono sempre reversibili}. Purtroppo la deduzione naturale soffre di altri problemi, e specialmente non gode della propriet\`a della sottoformula, e non si relaziona bene con la simmetria classica (ha molte premesse ma una sola conclusione). L'approccio deep inference pu\`o offrire diversi vantaggi nei confronti di ambedue questi formalismi.

\section{Deep inference e simmetria} 
L'eliminazione del taglio \`e un'idea centrale della proof theory. Se spostiamo tutto alla destra del turnstile e applichiamo qualche regola strutturale, la regola di taglio diventa:

Quando letta dal basso verso l'alto, la regola di taglio introduce una formula arbitraria , insieme alla sua negazione . Osserviamo ora la regola d'identit\`a, manipolata nuovamente per portare tutto a destra del tornello:

Ci accorgiamo che, quando letta dall'alto al basso, anch'essa introduce una formula arbitraria assieme alla sua negazione. \`E chiaro che le due regole sono intimamente correlate. Tuttavia, la loro dualit\`a \`e oscurata dal fatto che le simmetrie verticali sono nascoste nel calcolo dei sequenti: le derivazioni sono alberi, e gli alberi sono verticalmente asimmetrici.

Per rivelare la dualit\`a tra le due regole, occorre ripristinare questa simmetria verticale. La forma ad albero delle derivazioni nel calcolo dei sequenti \`e dovuta alla presenza di regole d'inferenza con due premesse. Per esempio la regola destra di congiunzione, nella versione ad un lato diventa:

in cui \`e presente un'asimmetria: due premesse ma solo una conclusione. O per meglio dire: un connettivo nella conclusione, ma nessuno tra le premesse.

Questa asimmetria pu\`o essere riparata. Sappiamo che la virgola a destra del turnstile corrisponde alla disgiunzione, e che i diversi rami dell'albero di derivazione corrispondono a congiunzioni; pertanto la regola  pu\`o essere riscritta come:


In tal modo andiamo ad indentificare una parte del livello oggetto (i connettivi tra le formule) con il meta-livello (i rami dell'albero di derivazione). Cos\`i facendo rendiamo il sistema ``incompleto'', poich\'e uno degli scopi degli alberi di derivazione \`e quello di permettere alle regole d'inferenza di essere applicate in profondit\`a, seguendo la struttura sintattica delle formule. Consideriamo la derivazione:

in cui la conclusione contiene la sottoformula . Leggendola dal basso all'alto, il motivo per cui la regola  pu\`o essere applicata, \`e che le applicazioni nella derivazione sottostante decompongono il contesto  e ne distribuiscono il contenuto tra le foglie dell'albero di derivazione.

Se vogliamo eliminare la forma ad albero delle derivazioni per ottenere un sistema completamente simmetrico, dobbiamo in qualche modo riconferire alle derivazioni l'abilit\`a di accedere alle sottoformule: questo pu\`o essere fatto direttamente, usando la metodologia deep inference. In questo modo, l'assioma d'identit\`a e la regola di taglio diventano:

da cui \`e evidente il carattere duale delle due: una pu\`o essere ottenuta dall'altra scambiando e negando la premessa e la conclusione. A questa nozione di dualit\`a ci si riferisce con l'aggettivo \emph{contrappositiva}.

Avremo modo di osservare una profonda simmetria, tutte le regole d'inferenza si raggrupperanno in coppie duali, come identit\`a e taglio. Questa dualit\`a si estender\`a naturalmente alle derivazioni: per ottenere la duale di una derivazione, baster\`a negare ogni formula e ``girare la derivazione sottosopra'', cio\`e leggerla dal basso verso l'alto.


\subsection{Sistema SKS generalizzato} 
Presentiamo un sistema formale per la logica classica proposizionale, che da una parte segue la tradizione del calcolo dei sequenti, in particolare possiede una regola di taglio e la sua ammissibilit\`a \`e dimostrata, mentre dall'altra, in contrasto col calcolo dei sequenti, ha regole che si applicano a profondit\`a arbitraria nelle formule e le derivazioni sono alberi degeneri (i.e. liste, le regole hanno al pi\`u una premessa). In questo Sistema potremo osservare una simmetria verticale nelle regole che mancava nel calcolo dei sequenti.

\begin{dfn}[Linguaggio \textsf{SKSg}, equivalenza] Sia  un insieme infinito enumerabile di \emph{simboli proposizionali}. L'insieme degli \emph{atomi}  \`e cos\`i definito:

dove  \`e una \emph{funzione di negazione primitiva sui simboli proposizionali}. La negazione si estende facilmente a tutti gli atomi definendo  per ogni simbolo proposizionale negato .

Siano  simboli costanti o \emph{unit\`a} (che denotano rispettivamente \emph{il vero} ed \emph{il falso}) e sia . Il \emph{linguaggio di \textsf{SKSg}} \`e definito dalle seguenti regole BNF di produzione:

dove  e  denotano rispettivamente la \emph{congiunzione} e la \emph{disgiunzione} delle formule  e . Come prima, dato un contesto  e una formula , indichiamo con  la formula ottenuta saturando il contesto  con la formula . Ad esempio, sia : allora  mentre ; in quest'ultimo caso possiamo adottare la convenzione di \emph{omettere le parentesi graffe attorno ai termini composti} e pertanto di scrivere semplicemente .

Consideriamo due formule equivalenti quando appartengono alla relazione indotta dalle equazioni in Figura~\ref{fig:skseq}.

Infine, una formula \`e in \emph{forma normale negata} quando la negazione occorre solo sui simboli proposizionali.
\end{dfn}

\begin{figure}[t!]
\begin{minipage}[t]{.5\textwidth}
	\textbf{Associativit\`a}
	\begin{center}
		 \\
		 
	\end{center}
	\textbf{Unit\`a}
	\begin{center}
	\begin{tabular}{ccc}
		 & \quad &  \\
		 & \quad & 
	\end{tabular}
	\end{center}
	\textbf{Chiusura contestuale}
	\begin{center}
		\AxiomC{}
		\UnaryInfC{}
		\DisplayProof{}
	\end{center}
	\vspace{.25em}
\end{minipage}
\begin{minipage}[t]{.5\textwidth}
	\textbf{Commutativit\`a}
	\begin{center}
		 \\
		
	\end{center}
	\textbf{Negazione}
	\begin{center}
	\begin{tabular}[c]{ccc}
		 &  &  \\
		 &  &  \\
		 &  &  \\
		 &  &  \\
		 &  & 
	\end{tabular}
	\end{center}
\end{minipage}
\textbf{Equivalenza}
\begin{center}
	
	\qquad\qquad
	\AxiomC{}
	\UnaryInfC{}
	\DisplayProof{}
	\qquad\qquad
	\AxiomC{}
	\AxiomC{}
	\BinaryInfC{}
	\DisplayProof{}
\end{center} 
\caption{Equivalenza tra formule di \textsf{SKSg}}
\label{fig:skseq}
\end{figure}

In virt\`u della propriet\`a associativa, adottiamo la seguente convenzione:

cio\`e scriviamo rispettivamente liste di disgiunzioni e congiunzioni senza curarci di come le sottoformule siano associate tra loro, assumendo quando non specificato che associno a destra.

Osserviamo inoltre che l'equivalenza ci permette di spingere la negazione all'interno delle formule fino a livello degli atomi, scambiando ogni volta congiunzione e disgiunzione in stile De Morgan.

\begin{dfn}[Dualit\`a, simmetria]
Il \emph{duale di una regola} d'inferenza si ottiene scambiando la premessa con la conclusione e negando ambedue. Ad esempio:


Un \emph{sistema deduttivo} \`e \emph{simmetrico} se per ogni regola d'inferenza esso contiene anche la duale.
\end{dfn}

Il Sistema deduttivo \textsf{SKSg} \`e riportato in Figura~\ref{fig:sksg_cos}. Il suo nome \`e un acronimo, in cui la prima ``S'' indica che \`e simmetrico, la ``K'' sta per ``Klassisch'' (come nel Sistema \textsf{LK}) e la ``S'' finale dice che il Sistema \`e espresso nel calcolo delle strutture (il termine ``struttura'' \`e usato per indicare una lista di formule in congiunzione o in disgiunzione). La ``g'' minuscola indica che il Sistema \`e \emph{generalizzato}, che significa che le regole non sono ristrette alla forma atomica.

\`E possibile dimostrare~(\cite{Bru04}) che questo sistema formale cattura tutte le dimostrazioni esprimibili in \textsf{LKp}, passando per un sistema intermedio chiamato calcolo dei sequenti ``ad un lato'' o calcolo dei sequenti di Gentzen-Sch\"utte~(\cite{Sch50, TroSch96}).

\begin{figure}
\begin{tabular}{ccccc}
	 &
	 & 
	 &
	 &
	 \\\\
	\begin{minipage}[c]{6em}\centering(nessuna regola per )\end{minipage} &
	 &
	 &
	 &
	~
\end{tabular}
\caption{Sistema deduttivo \textsf{SKSg}}
\label{fig:sksg_cos}
\end{figure}

Le regole ,  e  sono chiamate rispettivamente \emph{scambio}, \emph{indebolimento} e \emph{contrazione}. Le duali portano lo stesso nome, con l'aggiunta del prefisso ``co-'', ad esempio  \`e chiamata \emph{co-indebolimento}. La regola di scambio \`e duale a s\'e stessa, o \emph{auto-duale}. La sua funzione \`e quella di modellare il comportamento duale di congiunzione e disgiunzione. La sua semantica intesa non \`e facile da cogliere: per una spiegazione dettagliata, si rimanda alla Sezione~\ref{sec:lbv_opi} del presente volume.

Mentre \`e immediato osservare la corrispondenza tra  e  in \textsf{SKS} e le regole di indebolimento e contrazione nel calcolo dei sequenti, le loro duali non hanno corrispettivi in \textsf{LKp}. Il loro ruolo \`e quello di assicurare la simmetria del Sistema; se non siamo interessati alla simmetria, si pu\`o dimostrare che queste regole (e anche il taglio, cio\`e tutte le regole aventi la freccia rivolta verso l'alto) sono ammissibili. Infatti la nozione di dimostrazione \`e inerentemente asimmetrica: il duale di una dimostrazione \emph{non \`e} una dimostrazione, bens\`i \`e una derivazione che si conclude con l'unit\`a , ossia una \emph{refutazione}.

Il primo meta-teorema che andremo a dimostrare, ci d\`a una caratterizzazione del Sistema \textsf{SKSg}, mettendo in relazione il concetto di derivazione con quello di dimostrazione. 

\begin{thm}[Deduzione]~\\
Esiste una derivazione  se e solo se esiste una dimostrazione .
\end{thm}
\begin{proof} 
La dimostrazione  pu\`o essere ottenuta, data una derivazione , come segue:

Osserviamo che grazie alla metodologia deep inference, \`e stato possibile racchiudere l'intera derivazione  all'interno del contesto .

La derivazione  si ottiene da  come segue:

Anche in questo caso la trasformazione ha avuto successo perch\'e \`e stato possibile usare la dimostrazione  nel contesto .
\end{proof}


\subsection{Localit\`a: il Sistema SKS} 
Le regole d'inferenza che duplicano una quantit\`a illimitata di informazione sono problematiche dal punto di vista della complessit\`a e dell'implementazione, ad esempio, della proof search. Nel calcolo dei sequenti, la regola di contrazione:
\begin{center}
	\AxiomC{}
	\RightLabel{}
	\UnaryInfC{}
	\DisplayProof{}
\end{center}
quando letta dall'alto al basso duplica una formula  di dimensione arbitraria. Qualunque sia il meccanismo effettivo che compie questa duplicazione, esso necessita di una visione \emph{globale} delle copie di  presenti: se ad esempio pensiamo di implementare la contrazione su un sistema distribuito, in cui ogni processore ha una quantit\`a limitata di memoria locale, la formula  potrebbe essere replicata in processori diversi. In questo caso nessun processore avrebbe una visone globale delle copie di , e bisognerebbe usare un meccanismo \emph{ad hoc} per gestire questa situazione. Chiamiamo \emph{locali} le regole d'inferenza che non necessitano di una visione globale su formule di dimensione arbitraria, e \emph{non-locali} le altre. 

Mentre \`e possibile utilizzare tecniche per risolvere questa situazione nelle implementazioni, una questione interessante \`e trovare un approccio teorico che sia in grado di eliminare le regole non-locali. Questo \`e possibile, riducendo le regole non-locali alla loro forma atomica. Ad esempio, l'identit\`a:

dove  \`e un simbolo proposizionale.

Operazioni analoghe possono essere fatte anche nel calcolo dei sequenti; l'unica regola problematica \`e, appunto, la contrazione. Essa non pu\`o semplicemente essere ristretta alla forma atomica nel Sistema \textsf{SKSg}. Il problema si risolve inserendo nel Sistema una nuova regola, introdotta in~\cite{BruTiu01} e chiamata \emph{mediale}:

Questa regola non ha analoghi nel calcolo dei sequenti, ma \`e chiaramente corretta, poich\'e \`e derivabile da :


\begin{figure}
\begin{tabular}{ccccccc}
	 & \quad\quad &
	 & \quad\quad &
	 & \quad\quad &
	 \\\\
	\begin{minipage}[c]{6em}\centering(nessuna regola per )\end{minipage} & \qquad\quad &
	 & \quad\quad &
	 & \quad\quad &
	 
\end{tabular}
\vspace{1em}

\caption{Regole del Sistema \emph{locale} \textsf{SKS}}
\label{fig:sks_cos}
\end{figure}

Il prossimo teorema ci garantisce la derivabilit\`a del Sistema locale \textsf{KS} in Figura~\ref{fig:sks_cos}:

\begin{thm}\label{thm:sksg_atomic}
Le regole ,  e  sono derivabili, rispettivamente da , , . Dualmente, le regole ,  e  sono risp. derivabili da , , .
\end{thm}
\begin{proof}
Data un'istanza di una delle seguenti regole:

costruiamo una nuova derivazione per induzione strutturale su :
\begin{itemize}
	\item  \`e un atomo. Allora l'istanza di una regola generale \`e anche un'istanza della corrispettiva in forma atomica.
	\item  o . Allora l'istanza di una regola generale \`e un'istanza della relazione d'equivalenza, con l'eccezione dell'indebolimento quando . Allora la regola d'indebolimento generale \`e sostituita da:
	
	\item . Per ipotesi induttiva, usando rispettivamente le sole regole ,  e , abbiamo:
	
	da cui \`e possibile derivare:
	

	\item . L'ipotesi induttiva \`e identica a quella del caso precedente,	da cui \`e possibile derivare:
	
\end{itemize}

I casi duali si dimostrano allo stesso modo, ``girando sottosopra'' le dimostrazioni e negando tutte le formule.
\end{proof}

Questo \`e un risultato molto significativo e difficilmente ottenibile usando il calcolo dei sequenti. Inoltre la dimostrazione \`e costruttiva e modulare, caratteristiche che ci permetteranno in seguito di utilizzare regole generalizzate con la consapevolezza di poterle sempre sostituire con una procedura effettiva con le loro versioni atomiche.

\subsection{Rompere la simmetria: il Sistema KS} 
Dimostriamo che nel Sistema \textsf{SKS} le regole con la freccia rivolta in alto  sono \emph{ammissibili} (e quindi in particolare anche la regola di taglio lo \`e). Il Sistema risultante dall'eliminazione delle regole  \`e chiamato Sistema \textsf{KS}, ed \`e riportato in Figura~\ref{fig:ks_cos}. 

In questa sezione seguiamo la dimostrazione di~\cite{Bru04}, a cui ho apportato alcune modifiche personali di carattere tecnico.

\begin{lem}\label{lem:sks_cut1}
Ogni regola di \textsf{SKS} \`e derivabile usando solo la sua duale, \emph{identit\`a}, \emph{taglio} e \emph{switch}.
\end{lem}
\begin{proof}
Le regole  e  sono auto-duali, e pertanto banalmente derivabili. Un'istanza di una regola  pu\`o essere sostituita da:

e lo stesso vale per le regole .
\end{proof}

Prima di proseguire con la cut elimination, occorre stabilire una semplice proposizione, valida per la maggior parte dei sistemi espressi col calcolo delle strutture.

\begin{prop}\label{prop:sks_ctx_ins}
Per ogni struttura  e contesto , esiste una derivazione .
\end{prop}
\begin{proof}
Per induzione sulla dimensione del contesto .
\begin{enumerate}
	\item Il caso base \`e , da cui si deriva che esiste una derivazione (vuota) per .
	\item . Allora, per ipotesi induttiva, esiste una derivazione: 
	
	che pu\`o essere usata per costruire:
	
	e  \`e proprio uguale a .
	\item . Qui l'ipotesi induttiva ci d\`a:
	
	che pu\`o essere usata per costruire:
	
\end{enumerate}
\end{proof}

\begin{dfn}[Taglio atomico di superficie]
Un'istanza della regola di taglio atomica  \`e chiamata \emph{shallow} (o \emph{taglio atomico di superficie}) quando \`e della forma:

\end{dfn}

\begin{lem}\label{lem:sks_shallow_cut}
La regola di taglio atomica  \`e derivabile usando \emph{taglio atomico di superficie} e \emph{switch}.
\end{lem}
\begin{proof}
Ogni formula  \`e equivalente a . Per la Proposizione~\ref{prop:sks_ctx_ins}, esiste una derivazione:

Pertanto basta porre  per effettuare la trasformazione:

\end{proof}

\begin{lem}\label{lem:ks_alltrue}
Ogni dimostrazione  pu\`o essere trasformata in .
\end{lem}
\begin{proof}
Risalendo la dimostrazione, sostituiamo nelle regole l'occorrenza di  e le sue copie prodotte per contrazione, con l'unit\`a . Le istanze delle regole  e  rimangono intatte, le istanze di  si riducono ad applicazioni della relazione d'equivalenza . Le altre applicazioni vengono sostituite dalle seguenti derivazioni:

\end{proof}

\begin{figure}{thbs}

~\\

\caption{Regole del Sistema \textsf{KS}}
\label{fig:ks_cos}
\end{figure}

\begin{thm}
Ogni dimostrazione  pu\`o essere trasformata in una dimostrazione .
\end{thm}
\begin{proof}
Grazie al Lemma~\ref{lem:sks_cut1}, sappiamo che l'unica regola da eliminare \`e il taglio . Grazie al Lemma~\ref{lem:sks_shallow_cut} possiamo sostituire tutti i tagli con tagli di superficie. Partendo dall'alto, selezioniamo la prima istanza della regola di taglio:

Applicando due volte il Lemma~\ref{lem:ks_alltrue} a , otteniamo:


Partendo dalla conclusione e risalendo la dimostrazione , sostituiamo l'occorrenza di  e le sue copie prodotte per contrazione, con la formula . Le istanze delle regole  e  rimangono intatte, mentre le istanze di  e  vengono sostituite dalle loro versioni generalizzate:

Le istanze di  sono sostituite da :

Il risultato di questa sostitituzione di  dentro  \`e una dimostrazione , grazie alla quale possiamo costruire:


Ora basta procedere induttivamente verso il basso per rimuovere le rimanenti istanze di . Alla fine di questo procedimento, le regole generalizzate possono essere rimosse usando la procedura descritta nella dimostrazione del Teorema~\ref{thm:sksg_atomic}.
\end{proof}


\chapter{Logica lineare}

La logica lineare \`e un'estensione della logica classica ideata da Jean-Yves Girard verso la fine degli anni '80~(\cite{Gir87, GirLafTay89, Gir95}). La caratteristica peculiare della logica lineare \`e che tratta l'implicazione come \emph{fenomeno causale} anzich\'e (com'\`e pratica comune in matematica) come \emph{concetto stabile}:

Un'implicazione causale non pu\`o essere reiterata, poich\'e le condizioni iniziali sono modificate dopo il suo utilizzo; questo processo di modifica delle premesse (condizioni) \`e noto in fisica come \emph{reazione}\footnote{Quello di reazione \`e un concetto base anche della teoria dei modelli concorrenti, vedi ad esempio~\cite{Mil92, SanWal01}.}. Per esempio, se  \`e ``spendere una moneta nel distributore automatico di bevande (o DAB)'' e  \`e ``prendere un caff\`e'', la moneta viene persa nel processo, che quindi non si pu\`o ripetere una seconda volta. Esistono tuttavia casi, sia in matematica che nella vita reale, in cui le reazioni non esistono o sono trascurabili: ad esempio un lemma che resta sempre vero, o un tecnico che possiede la chiave del DAB e pu\`o recuperare ogni volta la sua moneta. Questi sono i casi che Girard chiama \emph{situazioni}, cio\`e condizioni durature e immutevoli (o {verit\`a stabili}), e sono comunque gestibili in logica lineare tramite speciali connettivi (gli \emph{esponenziali}, ``!'' e ``?''). Gli esponenziali esprimono la reiterabilit\`a di un'azione, ossia l'assenza di reazioni; tipicamente  significa ``spendere quante monete si vogliono''. Usiamo il simbolo  per denotare l'implicazione causale (o \emph{implicazione lineare}); vale la seguente equazione:

cio\`e  \`e causato da un certo numero d'iterazioni di .

Una \emph{azione di tipo } consister\`a nel tirare fuori una certa moneta dalla tasca di qualcuno (ci potrebbero essere diverse azioni di questo tipo, poich\'e potremmo disporre di diverse monete). Analogamente saranno disponibili un certo numero di caff\`e nel distributore automatico, perci\`o ci saranno diverse \emph{azioni di tipo }.

La logica lineare apre nuovi interessanti scenari sulla visione dei connettivi classici: ad esempio esistono \emph{due} congiunzioni ( o ``per'', inteso in senso di moltiplicazione, ed  o ``con'') corrispondenti a due usi radicalmente differenti della parola ``e''. Ambedue le congiunzioni esprimono la disponibilit\`a di due azioni; ma nel caso di , saranno fatte tutt'e due, mentre nel caso di , solo una delle due sar\`a eseguita (ma noi potremo decidere quale). Ad esempio, siano , , :
\begin{center}
\begin{tabular}{lll}
	 & : & spendere una moneta nel DAB \\
	 & : & prendere un caff\`e \\
	 & : & prendere un t\`e 
\end{tabular}
\end{center}
Data un'azione di tipo  e una di tipo , non sar\`a possibile formare un'azione di tipo , poich\'e per una moneta non si potr\`a mai avere ci\`o che ne costa due (sar\`a invece possibile formare un'azione di tipo , cio\`e avere due bevande in cambio di due monete). Comunque potremmo sempre produrre un'azione di tipo  come sovrapposizione delle due. Per eseguire quest'ultima azione dovremmo prima scegliere tra le possibili azioni che vogliamo produrre e in seguito effettuare quella scelta. Questo \`e analogo a quanto accade col costrutto~~ben noto in informatica: infatti, sia la parte~~\dots~che quella~~\dots~sono disponibili, ma solo una di esse verr\`a eseguita. Per quanto ``'' abbia delle ovvie caratteristiche disgiuntive, sarebbe tecnicamente errato vederlo come disgiunzione: infatti in logica lineare sia , sia  sono dimostrabili.

In logica lineare, in maniera del tutto speculare, abbiamo due disgiunzioni, che sono  o ``pi\`u'', e  o ``par'' (mnemonico per \emph{parallelo}).  \`e il duale di ``'' ed esprime la presenza di due opzioni: in questo caso per\`o, non sar\`a possibile scegliere quale delle due eseguire. La differenza tra  e  \`e la stessa che c'\`e in informatica tra nondeterminismo esterno ed interno. Infine  \`e il duale di .

Il pi\`u importante connettivo lineare \`e la \emph{negazione lineare}  o ``nil''. Poich\'e l'implicazione lineare si pu\`o sempre riscrivere come , ``nil'' \`e l'unica operazione negativa della logica lineare. La negazione lineare si comporta come la trasposizione in algebra lineare, esprime cio\`e \emph{dualit\`a}, ovverosia un cambio di prospettiva:
\begin{center}
	\emph{azione di tipo}  = \emph{reazione di tipo} 
\end{center}
La propriet\`a principale di ``nil'' \`e che, come accade in logica classica,  pu\`o essere identificato con  stesso. A differenza della logica classica per\`o, la logica lineare gode di una \emph{semplice interpretazione costruttiva}. Il carattere involutivo di ``nil'' assicura il comportamento \emph{alla De Morgan} per tutti i connettivi ed i quantificatori, ad esempio:

che pu\`o sembrare insolito ad un primo sguardo, specialmente se consideriamo che l'esistenziale in logica lineare \`e un operatore \emph{effettivo}: tipicamente si dimostra  dimostrando  per un certo termine . Questo comportamento di ``nil'' deriva dal fatto che  nega (cio\`e \emph{reagisce con}) una singola azione di tipo , mentre la negazione classica nega solo alcune (non specificate) iterazioni di , che tipicamente porta ad una disgiunzione di lunghezza non specificata. La negazione lineare \`e da un lato pi\`u primitiva, e dall'altro pi\`u forte (e anche pi\`u difficile da trattare) di quella classica.


Grazie alla presenza degli esponenziali, la logica lineare \`e espressiva quanto quella classica o quella intuizionista. Di fatto \`e pi\`u espressiva. Qui bisogna essere cauti: \`e lo stesso problema della logica intuizionista, che \`e anch'essa ``pi\`u espressiva'' di quella classica. Tecnicamente il potere espressivo \`e equivalente: ma i connettivi della logica lineare possono esprimere in maniera primitiva cose che in logica classica possono essere espresse solo tramite complesse traduzioni \emph{ad hoc}. L'introduzione di nuovi connettivi \`e quindi la chiave di volta verso formalizzazioni pi\`u semplici ed efficaci; la restrizione a vari frammenti apre le frontiere a linguaggi con specifico potere espressivo, ad esempio con una complessit\`a computazionale nota~(\cite{Gir98, Laf02, DalBai06}).

Un notevole problema aperto \`e quello di trovare una versione convincente di logica lineare non-commutativa. Anche se molti convengono sul fatto che la non-commutativit\`a ha ragione d'esser considerata a questo livello (esistono svariati esempi di problemi intrinsecamente non-commutativi, si pensi all'operatore di prefisso del -calcolo), semantiche non trivali di non-commutativit\`a non sono note. Unite all'introduzione di una semantica naturale, le metodologie per raggiungere un sistema non-commutativo potrebbero comportare un effettivo guadagno di potere espressivo, in relazione al caso commutativo.

\section{Calcolo dei sequenti lineari}

Definiamo la sintassi della logica lineare classica (o \textsf{CLL}, acronimo di Classical Linear Logic):

\begin{dfn}[Linguaggio \textsf{CLL}] Sia  un insieme infinito enumerabile di \emph{simboli proposizionali}. L'insieme degli \emph{atomi}  \`e cos\`i definito:

dove  \`e una \emph{funzione di negazione primitiva sui simboli proposizionali}. La negazione si estende facilmente a tutti gli atomi definendo  per ogni simbolo proposizionale negato .

Siano  simboli costanti o \emph{unit\`a}, e sia . Il \emph{linguaggio \textsf{CLL} delle formule lineari classiche} \`e cos\`i definito:

\end{dfn}
I connettivi , , , insieme agli elementi neutri  (relativamente a ) e  (relativamente a ) sono chiamati \emph{moltiplicativi}; i connettivi , , insieme agli elementi neutri  (relativamente a ) e  (relativamente a ) sono chiamati \emph{additivi}; i connettivi  e  sono chiamati \emph{esponenziali}. Questa notazione \`e stata scelta perch\'e facile da memorizzare: infatti essa suggerisce che  sia moltiplicativo e congiuntivo, con elemento neutro , mentre  \`e additivo e disgiuntivo, con elemento neutro ; inoltre, anche la distributivit\`a di  su  \`e suggerita dalla notazione.

La negazione si estende alle formule, come mostrato in Figura~\ref{fig:eq_lin}; inoltre l'implicazione lineare \`e definita con l'ausilio di negazione e connettivo ``par''.

\begin{figure}

~\\
\centering
\caption{Definizione di negazione e implicazione lineari}
\label{fig:eq_lin}
\end{figure}

Procediamo mostrando in Figura~\ref{fig:ded_lin} un sistema deduttivo per la logica lineare reminiscente il calcolo dei sequenti di~\cite{Gen35}. Come visto in precedenza, un sequente \`e un'espressione , in cui  e  sono sequenze finite di formule. Il significato inteso di  \`e:

dove il senso di ``e'', ``implica'' e ``oppure'' devono essere specificati formalmente. I sequenti lineari sono ad un lato, cio\`e della forma ; sequenti nella forma generale  si possono ``mimare'' usando .

\begin{figure}[t!]
\textbf{Identit\`a / taglio} \\\\
\begin{minipage}[m]{.5\textwidth}
	\centering
\end{minipage}
\begin{minipage}[m]{.5\textwidth}
	\AxiomC{}
	\AxiomC{}
	\RightLabel{}
	\BinaryInfC{}
	\centering\DisplayProof{} 
\end{minipage}\\\\
\textbf{Regole strutturali}
\begin{center}
	\AxiomC{}
	\RightLabel{}
	\UnaryInfC{}
	\DisplayProof{}
\end{center}
\textbf{Regole logiche} \\\\
\begin{minipage}[m]{.5\textwidth}
	\centering
\end{minipage}
\begin{minipage}[m]{.5\textwidth}
	\AxiomC{}
	\RightLabel{}
	\UnaryInfC{} 
	\centering\DisplayProof{}
\end{minipage}\\\\
\begin{minipage}[m]{.5\textwidth}
	\AxiomC{}
	\AxiomC{}
	\RightLabel{}
	\BinaryInfC{}
	\centering\DisplayProof{} 
\end{minipage}
\begin{minipage}[m]{.5\textwidth}
 	\AxiomC{}
	\RightLabel{}
	\UnaryInfC{} 
	\centering\DisplayProof{}
\end{minipage}\\\\
\begin{minipage}[m]{.5\textwidth}
	\centering 
\end{minipage}
\begin{minipage}[m]{.5\textwidth}
	\centering\textit{(nessuna regola per )}
\end{minipage}\\\\
\begin{minipage}[m]{.5\textwidth}
	\AxiomC{}
	\AxiomC{}
	\RightLabel{}
	\BinaryInfC{}
	\centering\DisplayProof{}
\end{minipage}
\begin{minipage}[m]{.5\textwidth}
	\begin{center}
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\DisplayProof{} \\\vspace{.5em}
		\AxiomC{}
		\RightLabel{}
		\UnaryInfC{}
		\DisplayProof{}
	\end{center}
\end{minipage}\\~\vspace{.8em}~\\
\begin{minipage}[m]{.5\textwidth}
	\AxiomC{}
	\RightLabel{}
	\UnaryInfC{}
	\centering\DisplayProof{}
\end{minipage}
\begin{minipage}[m]{.5\textwidth}
	\AxiomC{}
	\RightLabel{}
	\UnaryInfC{}
	\centering\DisplayProof{}
\end{minipage}\\~\vspace{.3em}~\\
\begin{minipage}[m]{.5\textwidth}
	\AxiomC{}
	\RightLabel{}
	\UnaryInfC{}
	\centering\DisplayProof{}
\end{minipage}
\begin{minipage}[m]{.5\textwidth}
	\AxiomC{}
	\RightLabel{}
	\UnaryInfC{}
	\centering\DisplayProof{}
\end{minipage}
\caption{Sistema deduttivo per \textsf{CLL}}
\label{fig:ded_lin}
\end{figure}

Nel calcolo dei sequenti lineari abbiamo rimosso le regole strutturali di indebolimento (\`e sempre possibile aggiungere una formula nella premessa o nella conclusione del sequente) e contrazione (la molteplicit\`a di una formula non conta) in virt\`u delle critiche mosse dalla scuola lineare. La possibilit\`a di utilizzare queste operazioni \`e tuttavia ripristinata grazie all'introduzione degli operatori  e .

Identit\`a e taglio restano invariate rispetto al Sistema \textsf{LKp}, cos\`i come la regola di permutazione. 

La situazione \`e diversa per quanto riguarda la congiunzione: come avveniva in precedenza, per dimostrare una congiunzione tra  e  bisogna aver dimostrato separatamente sia  che , ma in assenza della regola d'indebolimento, possiamo distinguere il caso in cui le dimostrazioni di  e  siano fatte nello stesso ambiente ( nella regola ), o in ambienti diversi ( e  in ).

Un ragionamento analogo vale per la disgiunzione: in logica lineare possiamo infatti distinguere il caso in cui, nel dimostrare la disgiunzione di  e , disponiamo solo di  (regola ), solo di  (regola ), e quello in cui abbiamo ambedue (regola ).

\`E possibile introdurre nuove formule, indebolendo il sequente, a patto che queste siano ``marcate'' con l'operatore ; per questa classe di formule (chiamate formule ``perch\'e non'' o ``why not'') la molteplicit\`a non \`e rilevante: inoltre ogni formula pu\`o essere trasformata in una \emph{why not} grazie alla regola di \emph{derelizione} . La regola di \emph{promozione}  permette ``aumentare'' la molteplicit\`a di una formula di una quantit\`a arbitraria.

Il Sistema cos\`i ottenuto gode di buone propriet\`a, oltre ad avere una granularit\`a pi\`u fine rispetto alla logica classica. Per \textsf{CLL} \`e possibile dimostrare la \emph{cut elimination}:
\begin{thm}[Hauptsatz lineare]
La regola di taglio lineare \`e eliminabile da \textsf{CLL}.
\end{thm}
\begin{proof}
La dimostrazione segue un argomento del tutto analogo a quello visto per la logica classica nel Teorema~\ref{thm:haupt_lk}, con alcune semplificazioni dovute al fatto di non dover trattare le usuali regole strutturali.
\end{proof}

Nuovamente, la dimostrazione risultante dalla procedura di cut elimination non \`e univocamente determinata, a causa della \emph{permutazione delle regole}. Ad esempio, nella derivazione:
\begin{center}
	\AxiomC{}
	\RightLabel{}
	\UnaryInfC{}
	\AxiomC{}
	\RightLabel{}
	\UnaryInfC{}
	\RightLabel{}
	\BinaryInfC{}
	\DisplayProof{}
\end{center}
non c'\`e nessun modo ovvio di eliminare l'applicazione di , poich\'e le regole  e  non agiscono su  e . Quindi l'idea \`e di ``spingere il cut verso l'alto'':
\begin{center}
	\AxiomC{}
	\AxiomC{}
	\RightLabel{}
	\BinaryInfC{}
	\RightLabel{}
	\UnaryInfC{}
	\RightLabel{}
	\UnaryInfC{}
	\DisplayProof{}
\end{center}
ma cos\`i facendo abbiamo arbitrariamente privilegiato la regola  rispetto alla , mentre l'altra scelta:
\begin{center}
	\AxiomC{}
	\AxiomC{}
	\RightLabel{}
	\BinaryInfC{}
	\RightLabel{}
	\UnaryInfC{}
	\RightLabel{}
	\UnaryInfC{}
	\DisplayProof{}
\end{center}
sarebbe stata altrettanto legittima. La scelta compiuta in questo passo della cut elimination \`e in generale irreversibile: a meno che  o  non siano successivamente eliminate, non sar\`a pi\`u possibili scambiarle. Per eliminare questa fonte di non-determinismo, fu introdotto in~\cite{Gir87} un nuovo formalismo, basato sulla teoria dei grafi, e chiamato \emph{Proof Nets}.

Il Sistema \textsf{CLL} non \`e l'unico rappresentante della classe delle logiche lineari. Vista l'ampia gamma di regole che possiede, questo Sistema pu\`o essere suddiviso in moduli con interessanti propriet\`a computazionali: il punto \`e proprio che la logica lineare \`e in grado di trattare naturalmente con le risorse (rappresentate dalla \emph{molteplicit\`a} delle formule), e per questo ci si riferisce ad essa con l'appellativo \emph{resource-conscious}; in informatica avere coscienza delle risorse significa saper distinguere varie classi di complessit\`a.

Tra i vari sottosistemi, quelli che maggiormente divergono dalla logica classica (e intuizionista), sono chiamati \textsf{LLL} (Light Linear Logic) ed \textsf{ELL} (Elementary Linear Logic)~--~\cite{Gir95a, DanJoi01}. Essi seguono dalla scoperta che, in assenza degli esponenziali, la procedura di eliminazione dei tagli pu\`o essere eseguita in tempo lineare.

Per i nostri scopi, ci occuperemo esclusivamente del frammento moltiplicativo: questo \`e il pi\`u semplice ed il pi\`u piccolo frammento di logica lineare (fu anche il primo che venne trasposto nelle Proof Nets, per via della sua semplicit\`a). Nella fattispecie tratteremo d'ora in avanti il Sistema in Figura~\ref{fig:sys_mllmix}, chiamato \textsf{MLL+mix}, cio\`e \emph{Multiplicative Linear Logic} con l'aggiunta della regola \textsf{mix} che ``fonde'' i sequenti provenienti da due diversi sottoalberi di derivazione. La negazione \`e definita dalle leggi di De Morgan:


\begin{figure}[t!]
\centering\textbf{Grammatica di \textsf{MLL+mix}}\\
\begin{minipage}[m]{.48\textwidth}

\end{minipage}
\begin{minipage}[m]{.48\textwidth}
	\vspace{1.5em}
	\centering\footnotesize{(con  infinit\`a numerabile \\ di simboli proposizionali)}
	\vspace{1em}
\end{minipage}
\begin{center}
	\textbf{Sistema deduttivo}\\
	~\\
	
	\AxiomC{}
	\AxiomC{}
	\RightLabel{}
	\BinaryInfC{} 
	\DisplayProof{} 
 	\AxiomC{}
	\RightLabel{}
	\UnaryInfC{} 
	\DisplayProof{}
	\AxiomC{}
	\AxiomC{}
	\RightLabel{}
	\BinaryInfC{}
	\DisplayProof{}
\end{center}
\caption{Sistema \textsf{MLL+mix}}
\label{fig:sys_mllmix}
\end{figure}

Avremo modo di osservare una natuale corrispondenza di questo Sistema ed il suo corrispettivo in deep inference: il Sistema \textsf{LBV} di~\cite{Gug02}.
\newpage

\section{Sistema LBV}

\`E il pi\`u semplice Sistema deep inference concepibile: un calcolo proposizionale composto da \emph{due operatori duali} (del tutto simili a congiunzione e disgiunzione classici), una \emph{negazione auto-duale} alla De Morgan e una \emph{unit\`a logica}. Come nel caso classico, le formule sono considerate uguali modulo una relazione di equivalenza. Le regole sono l'assioma  per l'unit\`a e la regola di scambio ; inoltre la regola d'identit\`a (chiamata anche \emph{regola d'interazione}) e quella di taglio (o \emph{regola di co-interazione}), nella versione generalizzata:

che tuttavia, come prima, possono essere ridotte alla loro forma atomica, dando origine al Sistema di Figura~\ref{fig:sys_lbv}.

\begin{thm}[Localit\`a di \textsf{LBV+cut}]\label{thm:loc_lbv}
La regola  \`e derivabile da . Dualmente, la regola  \`e derivabile da .
\end{thm}
\begin{proof}
Data l'istanza  procediamo per induzione strutturale su . Il caso duale  si dimostra allo stesso modo.
\begin{description}
	\item[Casi base] ~
	\begin{enumerate}
		\item . Ovvio, poich\'e .
		\item  \`e un atomo: Allora  \`e un'istanza di .
	\end{enumerate}
	\item[Casi induttivi] ~
	\begin{enumerate}[resume]
		\item . Per ipotesi induttiva, abbiamo due derivazioni  e :
		
		da cui \`e possibile ottenere:
		
		\item Infine, il caso  \`e analogo al precedente.
	\end{enumerate}
\end{description}
\end{proof}

\begin{figure}[h!]
\vspace{0.5em}
\textbf{Sintassi} \\
\begin{minipage}[m]{.48\textwidth}
	\vspace{1em}
	\centering 
\end{minipage}
\begin{minipage}[m]{.48\textwidth}
\begin{center}
	\vspace{1em}
	\footnotesize{(con  infinit\`a numerabile \\ di simboli proposizionali)}
\end{center}
\end{minipage}
\\\\\textbf{Sistema deduttivo}
\begin{center}
	
	\qquad
	
	\qquad
	
	\qquad
	
\end{center}
\vspace{.25em}
\begin{minipage}[t]{.5\textwidth}
\textbf{Associativit\`a}

\textbf{Commutativit\`a}

\textbf{Unit\`a}

\end{minipage}
\begin{minipage}[t]{.49\textwidth}
\textbf{Negazione}

\textbf{Congruenza}
\begin{center}
	 \qquad
	\AxiomC{}\AxiomC{}\BinaryInfC{}\DisplayProof{}
\end{center}
\begin{center}
	\AxiomC{}\UnaryInfC{}\DisplayProof{} \qquad
	\AxiomC{}\UnaryInfC{}\DisplayProof{} 
\end{center}
\end{minipage}
\vspace{.45em}
\caption{Sistema \textsf{LBV+cut}, equivalenza tra formule e negazione}
\label{fig:sys_lbv}
\end{figure}

Esiste una corrispondenza 1:1 tra Sistema \textsf{MLL+mix} e Sistema \textsf{LBV}.

\begin{dfn}[Trasformazioni \textsf{LBV}\textsf{MLL}]

Inoltre la definizione di  si estende facilmente ai sequenti:

per ; per  si pone .
\end{dfn}

\begin{thm}[Equivalenza di \textsf{LBV} e \textsf{MLL+mix}]~\\
\begin{enumerate}[label=\roman*)]
	\item Se il sequente  \`e dimostrabile in \textsf{MLL+mix}, allora la struttura  \`e dimostrabile in \textsf{LBV}.
	\item Se la struttura  (in forma normale, con ) \`e dimostrabile in \textsf{LBV}, allora il sequente  \`e dimostrabile in \textsf{MLL+mix}.
\end{enumerate}
\end{thm}

Questo teorema (dimostrato per la prima volta in~\cite{Gug02}) stabilisce una correlazione tra calcolo dei sequenti e calcolo delle strutture; come gi\`a accennato, \`e possibile conseguire un risultato analogo per il Sistema \textsf{SKS}, ma, ad esempio, la propriet\`a di localit\`a non vale per la logica classica proposizionale nel calcolo dei sequenti.

\newpage

\subsection{Eliminazione del taglio} 
L'argomento calssico per dimostrare l'eliminazione del taglio nel calcolo dei sequenti, risiede nel fatto che, quando le formule principali del taglio sono introdotte in entrambi i rami, esse determinano che regole saranno applicate immediatamente sopra a quella di taglio. Questo \`e conseguenza del fatto che le formule hanno un connettivo principale, e le regole logiche si basano solo su quello, e su nessun'altra propriet\`a delle formule.

Questo fatto non vale nel calcolo delle strutture. Per dimostrare la cut elimination nel Sistema \textsf{LBV}, occorre appoggiarsi ad un'altra propriet\`a, scoperta in~\cite{Gug02}, e chiamata \emph{scissione} o \emph{splitting}. Essa \`e una generalizzazione della tecnica vista nella dimostrazione di eliminazione del taglio per il sistema \textsf{SKS}. Si consideri la dimostrazione del sequente:

dove  \`e una formula contenente la sottoformula . Sappiamo per certo che nella dimostrazione ci deve essere un'istanza della regola  che scinde  da  assieme ai rispettivi contesti. Siamo nella seguente situazione:

La derivazione  implementa lo splitting, che \`e ottenuto in due passi:
\begin{enumerate}
	\item riduzione del contesto: se  \`e dimostrabile, allora  pu\`o essere ridotto, risalendo nella dimostrazione, ad un contesto , per un  opportuno, tale che  \`e dimostrabile. Nell'esempio sopra,  \`e ridotto a  per un certo ;
	\item scissione di superficie: se  \`e dimostrabile, allora  pu\`o essere ridotto, risalendo nella dimostrazione, ad una struttura  tali che  e  sono dimostrabili. Nell'esempio,  \`e scisso in .
\end{enumerate}

Grazie al Teorema di splitting, abbiamo la capacit\`a di scindere un copar in due dimostrazioni, una per ogni rispettiva sottoformula: l'importanza di tale capacit\`a ai fini della cut elimination, diventa chiara se consideriamo la regola di taglio nel Sistema \textsf{LBV}:

Il contesto  viene scisso in due componenti  e  tali che esistono le dimostrazioni  e . Ora possiamo sfruttare il fatto che gli atomi  e  possono essere introdotti, rispettivamente nelle conclusioni di  e , solo mediante applicazioni della regola  (fatto non vero, ad esempio, nel Sistema \textsf{KS}). A questo punto siamo in grado di isolare il segmento di dimostrazione che introduce gli atomi che verranno in seguito rimossi dal taglio, e possiamo pertanto trasformare questa sezione per bloccare il flusso degli atomi diretti al taglio sul nascere.

\begin{thm}[Shallow splitting]\label{thm:shallow_split}
Se  \`e dimostrabile in \textsf{LBV}, allora esistono  e  tali che:

e  e  siano entrambi dimostrabili in \textsf{LBV}.
\end{thm}
\begin{proof}
Consideriamo l'ordinamento lessicografico sui naturali:

Vogliamo procedere per induzione completa su due quantit\`a: l'altezza della dimostrazione di  e la \emph{lunghezza delle formule}, definita induttivamente da:

Dato il meta-enunciato:

il teorema \`e equivalente a . Per ipotesi induttiva possiamo suppore di avere una dimostrazione di  per ogni .

La lunghezza di  \`e  e l'altezza della sua dimostrazione \`e . Consideriamo l'istanza dell'ultima regola di questa dimostrazione:

Procediamo per casi su  (assumiamo sempre  e , perch\'e in questi casi il teorema vale banalmente):
\begin{enumerate}
	\item . Questa regola si pu\`o applicare in tre diversi modi:
	\begin{enumerate}[label=\arabic{enumi}.\arabic*.]
		\item all'interno di , cio\`e:
		
		Per ipotesi induttiva esistono ,  tali che:
		
		\`E sufficiente applicare  in coda alla dimostrazione di  per ottenere:
		
		\item all'interno di . Analogo al caso precedente.
		\item all'interno di , cio\`e:
		
		Anche in questo caso procediamo per induzione diretta, a meno di un'applicazione di  in:
		
	\end{enumerate}
	\item . Se la regola si applica all'interno di ,  o , procediamo in maniera del tutto analoga a quanto fatto nel caso . Esistono altre due possibilit\`a:
	\begin{enumerate}[label=\arabic{enumi}.\arabic*.]
		\item , ,  e:
		
		Possiamo applicare l'ipotesi induttiva per ottenere:
		
		Ora possiamo applicare nuovamente l'ipotesi induttiva su  e su : infatti, anche se non conosciamo l'altezza di queste due dimostrazioni, sappiamo che la loro dimensione \`e inferiore a:
		
		perch\'e per ipotesi, l'istanza di  non \`e triviale. Pertanto abbiamo per ipotesi induttiva:
		
		Ora, ponendo  e  otteniamo:
		

		\item  e:
		
		Per ipotesi induttiva abbiamo:
		
		\`E di nuovo \`e possibile applicare l'ipotesi induttiva su  poich\'e:
		
		per ottenere:
		
		Ora possiamo costruire:
		
	\end{enumerate}
\end{enumerate}
\end{proof}

\begin{thm}[Riduzione del contesto]\label{thm:ctx_reduction}
Per ogni struttura  ed ogni contesto  tale che  \`e dimostrabile in \textsf{LBV}, esiste una struttura  tale che, per ogni struttura  esistono le derivazioni:

\end{thm}
\begin{proof}
Per induzione sulla dimensione di . Il caso base \`e triviale, . I casi induttivi sono:
\begin{enumerate}
	\item , per qualche . Se  \`e dimostrabile, allora devono esistere le dimostrazioni di  e di . Applicando l'ipotesi induttiva su , otteniamo  tale che, per ogni :
	
	e tale che  \`e dimostrabile in \textsf{LBV}. Lo stesso argomento si applica quando  con .
	\item , per qualche . Assumiamo che  non sia un par: questa ipotesi non \`e limitativa, perch\'e \`e sempre possibile far ``rientrare'' il parallelo in , lasciando  come copar. Se alla fine di questo processo otteniamo , il teorema \`e banalmente provato. Quindi  con . Per il Teorema~\ref{thm:shallow_split}, esistono:
	
	Ora, applicando l'ipotesi induttiva su , otteniamo:
	
	Analogamente si dimostra  e si usa lo stesso argomento per .
\end{enumerate}
\end{proof}

\begin{cor}[Splitting]\label{cor:splitting}
Per ogni struttura  e  e contesto , se  \`e dimostrabile in \textsf{LBV}, allora esistono due strutture  e  tali che, per ogni struttura , esistono le derivazioni:

\end{cor}
\begin{proof}
Prima si applica il Teorema~\ref{thm:shallow_split}, poi il Teorema~\ref{thm:ctx_reduction}.
\end{proof}

Infine, prima di passare alla cut elimination, occorre enunciare un ultimo semplice risultato.

\begin{prop}\label{prop:lbv_ctx_ins}
Per ogni struttura  e contesto , esiste una derivazione:

\end{prop}
\begin{proof}
Per induzione sulla dimensione del contesto . Questa dimostrazione \`e uguale a quella della Proposizione~\ref{prop:sks_ctx_ins}, che stabilisce la stessa proposizione per il Sistema \textsf{KS}.
\end{proof}

\begin{thm}[Cut elimination]
La regola  \`e ammissibile in \textsf{LBV}.
\end{thm}
\begin{proof}
Consideriamo la dimostrazione:

Per il Corollario~\ref{cor:splitting}, esistono  e  tali che esistono le derivazioni:

Vogliamo individuare, nella dimostrazione , il punto in cui l'atomo  viene introdotto. Certamente deve esistere un contesto  tale che . Inoltre, deve esistere un contesto  tale che:

sia la dimostrazione  in cui abbiamo individuato l'applicazione della regola . Ora, sostituendo in  le occorrenze di  e  con , otteniamo una dimostrazione , grazie alla quale \`e possibile dimostrare:

Analogamente possiamo trasformare la dimostrazione di  in una dimostrazione di  dove . Ora possiamo concludere, esibendo la seguente dimostrazione:

in cui  \`e ottenuta applicando due volte la Proposizione~\ref{prop:lbv_ctx_ins}.

Possiamo ripetere induttivamente l'argomento per ogni dimostrazione di , partendo dall'alto, ed eliminare una per una tutte le istanze di .
\end{proof}

\subsection{Un'interpretazione operazionale}\label{sec:lbv_opi}

Quando lette dal basso all'alto, cio\`e nel verso della \emph{proof search}, le regole d'inferenza possono essere direzionate, trasponendole in \emph{regole di riscrittura}. Questo \`e reso possibile dal fatto che, nel calcolo delle strutture, ogni regola ha sempre \emph{al pi\`u una premessa}. Riscriviamo le regole del Sistema \textsf{LBV} sotto questa nuova prospettiva; la regola d'interazione atomica diventa:

che dice che due atomi di polarit\`a opposta messi in parallelo possono interagire. Abbiamo omesso la chiusura contestuale; nei sistemi di riscrittura si \`e soliti fattorizzare la chiusura contestuale con una regola:
\begin{center}
	\AxiomC{}
	\RightLabel{}
	\UnaryInfC{}
	\DisplayProof{}
\end{center}
che per noi corrisponde moralmente all'impiego della metodologia deep inference.

L'assioma del Sistema \textsf{LBV} non viene trasposto: infatti in questa interpretazione, significa solo che l'unit\`a non pu\`o essere riscritta, e che essa rappresenta l'unico \emph{valore} del Sistema. Procedendo nel processo di riscrittura, potremo in generale imbatterci in situazioni in cui nessuna regola \`e applicabile; l'unico caso ``accettato'' \`e quello di una computazione che termina sul simbolo . Negli altri casi, il processo di riscrittura non avr\`a individuato una dimostrazione, bens\`i una derivazione \emph{bloccata}.

L'equivalenza tra formule, definita come in Figura~\ref{fig:sys_lbv}, \`e nota nel mondo dei sistemi di riscrittura, come \emph{riscrittura modulo} una certa relazione d'equivalenza, come riportato in~\cite{BaaNip98}. Un modo di esprimerla \`e usare la regola:
\begin{center}
	\AxiomC{}
	\AxiomC{}
	\AxiomC{}
	\RightLabel{}
	\TrinaryInfC{}
	\DisplayProof{}
\end{center}

La riscrittura modulo associativit\`a, commutativit\`a e identit\`a \`e delicata, perch\'e non \`e sempre terminante. Per garantire la terminazione occorre imporre dei vincoli sull'applicabilit\`a della regola , come mostrato in~\cite{BaiPetWil89}. Inoltre~\cite{Kah06} ha sviluppato una tecnica per ridurre il non-determinismo dettato dalla fine grana delle regole di \textsf{LBV}.

Se la regola di switch \`e di difficile comprensione quando la si considera come regola d'inferenza, la sua trasposizione in regola di riscrittura offre una prospettiva molto pi\`u intuitiva. Nell'approccio operazionale, consideriamo le due formule all'interno di un ``par'' come due processi paralleli, che girano simultaneamente e che si ``conoscono'' a vicenda (cio\`e che hanno modo di individuarsi, ad esempio possiedono le reciproche coordinate all'interno di una rete), e pertanto sono in grado di interagire. I processi in ``copar'' girano anch'essi in parallelo, ma non hanno la possibilit\`a di comunicare, perch\'e non possiedono l'informazione sulle reciproche coordinate. Oltre all'interazione, l'unica altra operazione possibile per i processi, \`e ``dimenticarsi'': un processo all'interno di un ``par'' pu\`o decidere di eliminare l'informazione sulle coordinate di un'altro processo, o in altre parole, \emph{disconoscerlo}. L'effetto di questo comportamento, \`e inibire ogni possibilit\`a di interazione tra i processi coinvolti.

Questo meccanismo d\`a luogo a una serie di casi. Siano  e  due processi in un'ambiente ``par'':

Cosa possono fare  e  a parte interagire?
\begin{enumerate}[label=\arabic*.]
	\item possono lavorare per conto loro, cio\`e, ai fini del comportamento concorrente, non fare niente. Questo caso va contemplato per completezza dell'interpretazione: ;
	\item  pu\`o disconoscere  o viceversa: in entrambi in casi ;
	\item\label{lbv_opi_sw1} se  \`e una composizione parallela :
	\begin{enumerate}[label=\arabic{enumi}.\arabic*.]
		\item  pu\`o disconoscere : ;
		\item  pu\`o disconoscere : ;
		\item se  \`e una composizione parallela  \ldots
		\item se  \`e un ``copar''  \ldots
		\item se  \`e una composizione parallela  \ldots
		\item se  \`e un ``copar''  \ldots
	\end{enumerate}
	\item\label{lbv_opi_sw2} se  \`e un ``copar'' :
	\begin{enumerate}[label=\arabic{enumi}.\arabic*.]
		\item  pu\`o disconoscere : ;
		\item  pu\`o disconoscere : ;
		\item se  \`e una composizione parallela  \ldots
		\item \ldots
	\end{enumerate}
	\item se  \`e una composizione parallela , si procede in maniera simmetrica rispetto al caso \ref{lbv_opi_sw1};
	\item se  \`e un ``copar'' , simmetricamente rispetto a \ref{lbv_opi_sw2}.
\end{enumerate}

\begin{figure}[t!]
\vspace{.7em}
\begin{minipage}[t]{.7\textwidth}\end{minipage}
\begin{minipage}[t]{.93\textwidth}
 \
\vspace{.6em} \\
dove: \
\vspace{.4em} \\
\begin{tabular}{lrcl}
	&  &  &  \\
	&  &  &  \\
	&  &  & 
\end{tabular}
\end{minipage}
\vspace{.4em}
\caption{Definizione dell'operatore di \emph{merge}}
\label{fig:merge}
\end{figure}

Questa struttura, chiaramente ricorsiva, porta alla definizione di~\cite{Gug02} di \emph{merge set}, riportata in Figura~\ref{fig:merge}. Due processi  e  immersi in un contesto parallelo, possono muovere ad un processo  appartenente al merge set, come prescritto dalla \emph{regola di merge}:


Questa regola \`e abbastanza pesante, poich\'e necessita il ricalcolo del merge set ogni volta che dev'essere applicata. Ecco perch\'e facciamo ricorso alla regola di switch:


\begin{thm}
La regola di merge \`e eliminabile in presenza di .
\end{thm}
\begin{proof}
Siano ,  ed  processi, tali che . Allora:

Vogliamo dimostrare che esiste un cammino:

composto di sole applicazioni di , di  e di .

Procediamo per induzione strutturale su , usando la definizione di merge set di Figura~\ref{fig:merge}:
\begin{enumerate}[label=\arabic*.]
	\item . Allora dev'essere , e quindi ;
	\item . Allora dev'essere  e  o  e . In entrambi i casi ;
	\item  vale banalmente, in quanto  per ogni , ;
	\item . Allora:
	\begin{center}
		\AxiomC{}
		\AxiomC{}
		\AxiomC{}
		\TrinaryInfC{}
		\DisplayProof{}
	\end{center}
	\item . Ci sono due sottocasi da considerare:
	\begin{enumerate}[label=\arabic{enumi}.\alph*.]
		\item  e . Per ipotesi induttiva, sappiamo che  senza usare la regola . Allora possiamo concludere, esibendo:
		\begin{center}
			\AxiomC{\;\;\:}
			\RightLabel{}
			\UnaryInfC{}
			\DisplayProof{}
		\end{center}
		e osservando che ;
		\item  e . Allora, come prima:
		\begin{center}
			\AxiomC{\;\;\;}
			\RightLabel{}
			\UnaryInfC{}
			\DisplayProof{}
		\end{center}
		e .
	\end{enumerate}
	\item . Di nuovo, seguendo la definizione di merge set, ci sono due sottocasi possibili:
	\begin{enumerate}[label=\arabic{enumi}.\alph*.]
		\item  e . Poich\'e , possiamo applicare la regola di switch per ottenere:
		 
		da cui, per ipotesi induttiva immersa nel contesto , possiamo concludere esibendo:
		\begin{center}
			\AxiomC{}
			\RightLabel{}
			\UnaryInfC{}
			\DisplayProof{}
		\end{center}
		\item  e . Allora, grazie alle regole  ed :
		
		da cui concludiamo, grazie all'ipotesi induttiva e a:
		\begin{center}
			\AxiomC{}
			\RightLabel{}
			\UnaryInfC{}
			\DisplayProof{}
		\end{center}
	\end{enumerate}
\end{enumerate}
\end{proof}

Grazie a questo risultato, possiamo appoggiarci sulla pi\`u pratica (nonch\'e locale) regola di switch, eliminando quella di merge. Il sistema cos\`i ottenuto, costituisce una personale interpretazione operazionale del Sistema \textsf{LBV}, reminiscente le algebre di processo, che pu\`o costituire un (ulteriore) ponte tra il mondo della proof theory e quello dei modelli concorrenti, oltre ad un punto di partenza per indagini riguardanti le propriet\`a di complessit\`a della proof search.

\clearpage{\pagestyle{empty}\cleardoublepage}
\phantomsection\addcontentsline{toc}{chapter}{Conclusioni}
\chapter*{Conclusioni}
\rhead[\fancyplain{}{\bfseries CONCLUSIONI}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries CONCLUSIONI}}

La deep inference offre una prospettiva nuova e moderna in teoria della dimostrazione. Grazie a questa metodologia, il lavoro strutturale svolto dagli alberi in shallow inference, viene collassato nell'uso dei contesti, che sono un concetto fondamentale in questo approccio. A questo proposito, \`e interessante osservare come questo metta in relazione diretta il modo di operare tipico in proof theory (con alberi di derivazione) con il mondo dei sistemi di riscrittura. Infatti le derivazione nel calcolo delle strutture possono essere linearizzate, leggendole dal basso in alto (verso della proof search), e le regole d'inferenza si possono vedere come regole di riscrittura; quali corrispondenze si possono trovare in questo senso? A quali sistemi di riscrittura corrispondono i sistemi in calcolo delle strutture, e di quali propriet\`a godono?

Inoltre, osserviamo come, nelle procedure di cut elimination per il calcolo delle strutture, l'attenzione sia posta sugli atomi da eliminare, a conseguenza del fatto che questi sistemi godono di localit\`a. Una sotto-procedura invariante nella cut elimination \`e la discesa nella dimostrazione alla ricerca del taglio, per poi risalire seguendo il flusso degli atomi coinvolti. Da questa osservazione nasce un nuovo filone di ricerca in deep inference che tratta i cosiddetti ``flussi atomici'' o ``atomic flows''; per una introduzione all'argomento, vedere~\cite{Gund09}.

Infine, esistono molti problemi rilevanti riguardanti la complessit\`a delle dimostrazioni, alcuni dei quali ancora aperti, altri gi\`a risolti, ad esempio in~\cite{Jer09, BruGug09, BruGugGunPar09}. Il calcolo delle strutture \`e un formalismo molto espressivo, ma difficile da trattare a causa del forte non-determinismo che comporta la fine grana (i.e. la vasta applicabilit\`a) delle sue regole; \cite{Kah06}~ha ideato una tecnica capace di ridurre questo non-determinismo.

Tutte le fonti e le informazioni riguardanti le ricerche in deep inference, sono reperibili online sulla pagina di Alessio Guglielmi, uno dei maggiori promotori di questo approccio, all'indirizzo:
\begin{center}
	\url{http://alessio.guglielmi.name/res/cos/}
\end{center}


\clearpage{\pagestyle{empty}\cleardoublepage}
\rhead[\fancyplain{}{\bfseries BIBLIOGRAFIA}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries BIBLIOGRAFIA}}
\phantomsection\addcontentsline{toc}{chapter}{Bibliografia}
\bibliographystyle{humanbio}
\bibliography{iidi}


\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter*{Ringraziamenti}
\thispagestyle{empty}

Ringrazio anzitutto i mei genitori Carmen e Roberto, senza i quali tutto questo non sarebbe stato possibile. Con loro, ringrazio tutta la mia famiglia per l'amore che mi hanno dato dacch\'e sono al mondo.

Ringrazio i miei amici per le ore passate a discutere insieme, per aver ascoltato pazientemente i miei vaneggianti sproloqui, ma soprattutto per avermi dato la certezza di aver sempre qualcuno su cui contare.

Infine ringrazio i miei professori, per avermi ascoltato e per la pazienza che hanno avuto nel sopportare questo tremendo rompiscatole. Senza i vostri insegnamenti, ma non solo, senza il vostro esempio, non sarei quello che sono.

Grazie di cuore a tutti quanti, grazie a chi ha sempre creduto in me, grazie a chi non ci ha creduto mai, grazie agli amici ma anche ai nemici, grazie al contributo di tutti perch\'e mi \`e stato indispensabile per raggiungere, oggi, questo risultato.

\end{document}
