\documentclass[letterpaper,11pt]{article}
\bibliographystyle{plain}
\usepackage{amsmath,amssymb,graphicx,latexsym,amsthm,xspace}

\setlength{\floatsep}{4pt}        
\setlength{\dblfloatsep}{3pt}     
\setlength{\textfloatsep}{3pt}    
\setlength{\abovecaptionskip}{3pt}
\setlength{\belowcaptionskip}{3pt}

\setlength{\topmargin}{0in}
\setlength{\textwidth}{6.5in} \setlength{\textheight}{9in}
\setlength{\evensidemargin}{0in}
\setlength{\oddsidemargin}{0in}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{observation}[theorem]{Observation}

\newcommand{\E}{\mathrm{\mathop{E}}}
\newcommand{\Opt}{\mathrm{Opt}}
\newcommand{\poly}{\mathrm{poly}}
\newcommand{\dtv}{d_{TV}}
\newcommand{\sgn}{\mathrm{sgn}}
\newcommand{\cald}{\mathcal{D}}
\newcommand{\calpsat}{\mathcal{P}_{\mathrm{sat}}}
\newcommand{\calpfar}{\mathcal{P}_{\mathrm{far}}}
\newcommand{\caldsat}{\mathcal{D}_{\mathrm{sat}}}
\newcommand{\caldfar}{\mathcal{D}_{\mathrm{far}}}
\newcommand{\calksat}{\mathcal{K}_{\mathrm{sat}}}
\newcommand{\calkfar}{\mathcal{K}_{\mathrm{far}}}
\newcommand{\caltsat}{\mathcal{T}_{\mathrm{sat}}}
\newcommand{\caltfar}{\mathcal{T}_{\mathrm{far}}}
\newcommand{\cy}{\mathrm{cy}}


\newcommand{\calo}{\mathcal{O}}
\newcommand{\cala}{\mathcal{A}}
\newcommand{\calg}{\mathcal{G}}
\newcommand{\calk}{\mathcal{K}}
\newcommand{\cali}{\mathcal{I}}
\newcommand{\calu}{\mathcal{U}}
\newcommand{\calp}{\mathcal{P}}
\newcommand{\bfG}{\mathbf{G}}
\newcommand{\bfX}{\mathbf{X}}
\newcommand{\bfL}{\mathbf{L}}
\newcommand{\bfx}{\mathbf{x}}
\newcommand{\bfy}{\mathbf{y}}
\newcommand{\bfb}{\mathbf{b}}
\newcommand{\bfz}{\mathbf{z}}
\newcommand{\ci}{\perp\!\!\!\perp}
\newcommand{\bit}{\{0,1\}}
\newcommand{\supp}{\mathrm{Supp}}


\newcommand{\mislong}{\textsf{Maximum Independent Set}\xspace}
\newcommand{\mis}{\textsf{MIS}\xspace}

\newcommand{\kcsp}{\textsf{-CSP}\xspace}
\newcommand{\csp}[1]{\textsf{CSP}(#1)\xspace}


\newcommand{\sat}{\textsf{SAT}\xspace}
\newcommand{\xor}{\textsf{XOR}\xspace}
\newcommand{\nae}{\textsf{NAE}\xspace}
\newcommand{\equ}{\textsf{EQU}\xspace}
\newcommand{\txor}{\textsf{-XOR}\xspace}
\newcommand{\kxor}{-\textsf{XOR}\xspace}
\newcommand{\kequ}{-\textsf{EQU}\xspace}
\newcommand{\knae}{-\textsf{NAE}\xspace}

\newcommand{\maxcsp}[1]{\textsf{Max CSP}(#1)\xspace}
\newcommand{\maxnae}{\textsf{Max NAE}\xspace}
\newcommand{\maxcut}{\textsf{Max Cut}\xspace}
\newcommand{\maxequ}{\textsf{Max EQU}\xspace}

\newcommand{\maxkcsp}{\textsf{Max -CSP}\xspace}
\newcommand{\maxkequ}{\textsf{Max -EQU}\xspace}
\newcommand{\maxkxor}{\textsf{Max -XOR}\xspace}

\title{Lower Bounds on Query Complexity for Testing Bounded-Degree CSPs}
\author{Yuichi Yoshida\thanks{This work was conducted while the author was visiting Rutgers University.}\\\\
  School of Informatics, Kyoto University, and\\ Preferred Infrastructure, Inc.\\yyoshida@lab2.kuis.kyoto-u.ac.jp}

\date{}

\begin{document}
\setcounter{page}{0}
\maketitle
\begin{abstract}
  In this paper, we consider lower bounds on the query complexity for testing CSPs in the bounded-degree model.

  First, for any ``symmetric'' predicate  except \equ where , 
  we show that every (randomized) algorithm that distinguishes satisfiable instances of \csp{} from instances -far from satisfiability requires  queries where  is the number of variables and  is a constant that depends on  and .
  This breaks a natural lower bound , which is obtained by the birthday paradox.
  We also show that every one-sided error tester requires  queries for such .
  These results are hereditary in the sense that the same results hold for any predicate  such that .
  For \equ, we give a one-sided error tester whose query complexity is .
  Also, for \txor (or, equivalently \textsf{E2LIN2}), 
  we show an  lower bound for distinguishing instances between -close to and -far from satisfiability.

  Next, for the general \kcsp over the binary domain,
  we show that every algorithm that distinguishes satisfiable instances from instances -far from satisfiability requires  queries.
  The matching NP-hardness is not known, even assuming the Unique Games Conjecture or the -to- Conjecture.
  As a corollary, for \mis on graphs with  vertices and a degree bound ,
  we show that every approximation algorithm within a factor  and an additive error of  requires  queries.
  Previously, only super-constant lower bounds were known.
\end{abstract}
\newpage
\section{Introduction}
\textit{Property testing}~\cite{GGR98} is a relaxation of decision.
We call a randomized algorithm an \textit{-tester} when, 
given an oracle access  to an instance , 
it accepts  if it is -close to a predetermined property with a probability of at least  and rejects  if it is -far from the property with a probability of at least .
An -tester is often referred to as a \textit{tolerant tester}~\cite{PRR06}.
The efficiency of an algorithm is measured by the \textit{query complexity}, which is the number of accesses to .
The definition of farness depends on each model.
A -tester is simply called an \textit{-tester}.

In this paper, we study testers for \kcsp (\textit{constraint satisfaction problems}) in the bounded-degree model and show various lower bounds on the query complexity.
An instance  of \kcsp is a tuple of a set of variables and a set of constraints (functions) over  variables.
Then, we test whether there exists an assignment over variables that satisfies all the constraints.
We only consider Boolean CSPs.
The \textit{degree} of a variable  is the number of constraints in which  appears.
In the \textit{bounded-degree model}~\cite{GR08},
we only consider instances such that the degree of each variable is at most , where  is a predetermined parameter.
By specifying a variable  and an index , the oracle  returns the -th constraint in which  appears.
If there exists no such constraint,  returns some unique symbol.
An instance  is called \textit{-far from satisfiability} if we must remove at least  constraints to make  satisfiable.
An instance  is called \textit{-close to satisfiability} if we can make  satisfiable by removing at most  constraints.
Let  be a predicate (a function).
Then, \csp{} is a sub-problem of \kcsp in which every constraint is specified by the same predicate  and literals on it (see Section~\ref{sec:preliminary} for details).
For a concrete predicate, we often use  as the name of a problem instead of writing \csp{} (e.g., \kxor).

The first contribution of this paper is the development of a new technique to show lower bounds for testing a wide range of \csp{}.
A predicate  is called \textit{symmetric} if the following conditions hold: 
(i)  for any  such that .
(ii)  for any  where .
We assume  throughout this paper.
The simplest symmetric predicates might be \kequ, 
which is satisfied iff the variables are all zeros or all ones,
and \knae,
which is satisfied iff not all of the variables have the same value.
\knae is much related to coloring on -uniform hypergraphs.
We show the next theorem.
\begin{theorem}\label{thr:two-sided}
  Let  be a symmetric predicate except \kequ where .
  Then, for any  and predicate  such that ,
  there exist  and  such that 
  every -tester for \csp{} with a degree bound  requires  queries,
\end{theorem}
We note that a -tester is trivial since no instance can be -far from satisfiability and we can always accept.
Thus, Theorem~\ref{thr:two-sided} excludes the possibility of efficient \textit{non-trivial} testers.
We also stress that it is impossible to get rid of the condition of symmetry since for a certain non-symmetric CSP, 
called \textsf{Dicut}, we have a constant-time non-trivial tester using recent results~\cite{Tre98,Yos10}.
The lower bound  is somewhat surprising since, 
as we will see in Section~\ref{sec:overview}, 
this lower bound implies that even if we find cycles in the instance,
they do not help at all to test the satisfiability.

\kxor is a predicate of arity , 
which is satisfied iff the parity of its variables is .
We show a similar lower bound for \txor.
\begin{theorem}\label{thr:txor}
  For any ,
  there exist  and  such that every -tester for \txor with a degree bound  requires  queries.
\end{theorem}

If an -tester always accepts satisfiable instances,
it is called a \textit{one-sided error tester}.
Otherwise, it is called a \textit{two-sided error tester}.
We give a tight lower bound for one-sided error testers.
\begin{theorem}\label{thr:one-sided}
  Let  be a symmetric predicate except \kequ where .
  Then, for any  and any  such that ,
  there exists  such that
  every one-sided error -tester for \csp{} with a degree bound  requires  queries.
\end{theorem}

On the other hand,
\kequ is an easier problem as stated in the next theorem.
\begin{theorem}\label{thr:equ}
  For any  and ,
  there exists a one-sided error -tester for \kequ with query complexity .
\end{theorem}
\textit{Bipartiteness} is the property of a graph such that the vertex set can be partitioned into two disjoints sets  and  such that every edge connects a vertex of  and a vertex of .
Theorem~\ref{thr:equ} is almost tight since testing bipartiteness is a sub-problem of -\equ and the  lower bound is known for this problem~\cite{GR08}.

The second contribution of this work is a linear lower bound to distinguish satisfiable instances of the general \kcsp from instances much further from satisfiability.
\begin{theorem}\label{thr:kcsp}
  For any  and , 
  there exists  such that 
  every -tester for \kcsp with a degree bound  requires  queries.
\end{theorem}
As a corollary, we show a linear lower bound for approximating \mislong (\mis).
An {\it independent set} of a graph is a vertex set such that any two of its vertices are not adjacent.
\mis is the problem of finding the largest independent set in a graph.
A value  is called an \textit{-approximation} for a value  if .
We call a randomized algorithm an \textit{-approximation algorithm} for \mis if,
given an oracle access  to a graph ,
it computes an -approximation for \mis with a probability of at least .
Similarly to \kcsp, 
by specifying a vertex  and an index ,
the oracle  returns the -th edge in which  appears.
We show the next theorem.
\begin{theorem}\label{thr:mis}
  Every -approximation algorithm for \mislong on graphs with  vertices and a degree bound  requires  queries.
\end{theorem}

\begin{table}[t]
  \caption{Summary of results on query complexity of two-sided error -testers for various problems. Here,  denotes any symmetric predicate with arity  except \kequ.}
  \label{tbl:summary}
  \begin{center}
    \begin{tabular}{|l|l|l|l|l|}
      \hline
      Problem &  &  & Bound & Reference \\
      \hline
      \txor & 0 &  &  & \cite{GR99,GR08}\\ 
      \hline
      \txor &  &  &  & \cite{YI10}\\
      \hline
      \txor &  &  &  & Theorem~\ref{thr:txor} \\
      \hline
      -\xor &  &  &  & \cite{BOT02} \\
      \hline
      \kequ & 0 &  &  & Theorem~\ref{thr:equ}\\
      \hline
      \kequ& 0 &  &  & \cite{GR08} \\
      \hline
      \csp{} & 0 &  &  & Theorem~\ref{thr:two-sided} \\
      \hline
      \kcsp & 0 &  &  & Theorem~\ref{thr:kcsp} \\
      \hline
    \end{tabular}
  \end{center}
\end{table}

\paragraph{Related work:}
There have been several works on testing CSPs.
The summary of known results is shown in Table~\ref{tbl:summary}.
\maxkcsp is an optimization version of \kcsp in which we are to maximize the number of satisfied constraints by an assignment.
Let  be a predicate of arity .
We notice that if there is an approximation algorithm for \maxcsp{} with a factor ,
we have -tester for \csp{}.
Thus, a lower bound for testing \csp{} implies a lower bound for approximating \maxcsp{}.
The NP-hardness of approximation within a certain factor is often shown using a reduction from -\xor.
Using the same reduction, 
for a wide range of ,
it is shown that there exists some  such that any -tester requires  queries~\cite{YI10} (e.g.,  for ~\cite{Has01} and  for -\nae~\cite{Zwi98}).
However, for ,
we did not have any lower bound for -testers.
Theorems~\ref{thr:two-sided} and~\ref{thr:txor} tighten this gap and also imply the new lower bound  for approximating \maxcsp{} within a factor .

Assuming the Unique Games Conjecture~\cite{Kho02}, 
it is NP-hard to distinguish between instances of \maxkcsp whose optimal solutions are  and ~\cite{AM08,ST06}.
Theorem~\ref{thr:kcsp} states a somewhat stronger fact about sublinear time algorithms; i.e., 
it is hard to distinguish \textit{satisfiable instances} from instances whose optimal solutions are at most  with sublinear queries.
No matching NP-hardness is known,
even assuming the -to- Conjecture~\cite{Kho02}.

The concept of -approximation algorithms was introduced in~\cite{CRT01} to approximate the minimum spanning tree of a bounded-degree graph.
Since then, 
numerous -approximation algorithms have been developed for graph problems~\cite{Alo10,CRT01,MR09,NO08,PR07,YYI09}.
For \mis, it is shown that there exists a constant-time -approximation algorithm,
and every -approximation algorithm requires a super-constant number of queries~\cite{Alo10}.
Theorem~\ref{thr:mis} improve this to a linear lower bound at the cost of a slightly weaker approximation factor.

\paragraph{Motivations:}
Among all CSPs, 
we could say that -\xor is the one whose behavior is best understood.
It is NP-hard to distinguish between instances whose optimal solutions (in the sense of \maxkxor) have values  and ~\cite{Has01}.
This fact means that the random assignment achieves the best approximation ratio one can obtain in polynomial time.
The behavior of \maxkxor under linear programmings (LP) and semidefinite programmings (SDP) is also well-studied.
A quality of linear and semidefinite programming are measured by \textit{integrality gap},
which is the ratio of the optimum for those programs to the optimum for the original problem.
The Lovasz-Schrijver hierarchy (LS, LS+), Sherali-Adams hierarchy (SA), Lasserre hierarchy are sequences of relaxations of those programs to obtain tighter approximations.
For all of these hierarchies, the integrality gaps remain  after  rounds of relaxations~\cite{BOG03,GMT09,Sch08}.

Presumably, the reason why \maxkxor is hard to approximate is that the accepting assignments of \kxor contain the support of a -wise independent distribution.
These results are extended to predicates whose accepting assignments contain the support of a pairwise independent distribution~\cite{AM08, GMT09, Tul09}.
For other predicates, however, 
we can approximate better than the random assignment using SDP (e.g., -\nae).
One motivation for this work is to investigate why SDP helps with those predicates.
Theorems~\ref{thr:two-sided} and~\ref{thr:txor} suggest that a few cycles are not sufficient to approximate better than the random assignment.
This holds not only for SDP,
but also for any algorithm.
Also, Theorem~\ref{thr:one-sided} gives us a separation of the ability of polynomial-time algorithms versus sublinear-time one-sided error testers since SDP approximates better than the random assignment in polynomial time.

It is an interesting question whether we can approximate \maxkcsp within a certain factor by sampling a small portion of an instance.
We can approximate the optimal solution of \maxkcsp within an additive error  by sampling  variables and by solving the induced problems~\cite{AdlVKK03}.
Thus, dense instances are easy to approximate with constant queries~\cite{AdlVKK03,AS02,AE02}.
However, little is known for sparse instances.
Solving \maxcut of a sparse graph by sampling is demonstrated in~\cite{BHHS09}.
They showed that the value of Goemans-Williamson SDP~\cite{GW95} for a randomly sampled subgraph of linear size is approximately equal to the SDP value for the original graph.
Our work is a complement of their work.
Theorem~\ref{thr:two-sided} implies that, 
to approximate symmetric \maxkcsp better than the random assignment,
we need to sample  constraints from the instance.

\paragraph{Organization:}
In Section~\ref{sec:preliminary}, 
we define notions used in this paper,
followed by a proof overview of Theorem~\ref{thr:two-sided}, 
which is the main result of this paper.
We give the proof of Theorem~\ref{thr:two-sided} in Section~\ref{sec:two-sided}.
We mention other results in Section~\ref{sec:other}.

\section{Preliminaries}\label{sec:preliminary}
\subsection{Definitions}
We define notions on hypergraphs.
Let  be a vertex set and  be an edge set such that  contains  and  for .
Then, we call  a \textit{hyperpath}.
A hypergraph is called \textit{connected} if, for every two vertices, there is a hyperpath containing them.
Let  be a vertex set and  be an edge set such that  contains  and  for .
Then, we call  a \textit{hypercycle}.
A connected hypergraph is called a \textit{hypertree} if it does not have any hypercycle.
A \textit{hyperforest} is a hypergraph such that each connected component is a hypertree.
Let  be a -uniform hypergraph with  vertices,  edges and  connected components.
We define , which measures how many vertices are deficient compared to a hyperforest (note that any hyperforest with  edges and  connected components has  variables).
We call  a \textit{-expander} if the subgraph of  induced by any  edges contains at least  vertices.

Let  be a predicate.
An instance  of \csp{} is a tuple of a set of variables and a set of constraints.
Here, each constraint  is defined over a -tuple of variables  and is of the form  for some .
We call  a \textit{literal vector} of .
Here,  accounts for the possible negation of .
The \textit{underlying hypergraph} of  is a -uniform hypergraph  in which each variable of  corresponds to a vertex of ,
and for each constraint of the form  in , 
we have an edge  in .

Next, we introduce notions on distributions.
Suppose that  is a distribution generating  (and possibly others).
Let  be the marginal distribution of  under .
Let  denote the marginal distribution of  conditioned on , i.e., .
We often omit the actual value of a random variable if it is unimportant.
For example,  may be written as  and  may be written as .
Let  denote the support of .
If the random variables  and  become independent after conditioning , 
we write .
Let  be a set of random variables.
Then, for ,  denotes the set .

Let  and  be distributions generating a random variable .
The \textit{total variation distance} between  and  is defined as

We note that .
Also, we define  where  is the uniform distribution.
When  is Boolean, .

\subsection{Proof Overview}\label{sec:overview}
We give a proof overview of Theorem~\ref{thr:two-sided}.
To prove the lower bound, we use Yao's minimax principle~\cite{Yao77}.
Specifically, 
we design two distributions  and  of instances of \csp{} so that all instances of  are satisfiable,
while almost all instances of  are -far from satisfiability.
Then, we show that any deterministic algorithm with a sublinear number of queries cannot distinguish between instances chosen from  and instances chosen from .
For underlying hypergraphs of  and , 
we use the same distribution of expanders. 
Thus, if we ignore literal vectors and we only look at variables used in constraints,
we have no hope of distinguishing  from .
We describe how  generates an instance.
First,  chooses an underlying hypergraph .
Then, the set of variables of the instance is .
Then,  first chooses  for each vertex  uniformly at random.
Here, the set  is the supposed solution for the instance.
Next,  chooses a literal vector  for each edge  and adds a constraint  of the form .
 chooses  so that the resulting instance is satisfiable by .
In contrast,  simply generates  uniformly at random for each edge  after choosing an underlying hypergraph.

Any algorithm with query complexity  can be seen as a mapping from \textit{query-answer history}  to  for  and to  for .
A query  is a pair of a variable  and an index , and an answer  is a constraint or the information that there is no constraint there.
To analyze the distribution of the query-answer history of an algorithm running under a distribution of instances,
it is useful to think that there is a randomized process behind the oracle.
That is, when an algorithm asks a query of the oracle, 
the randomized process generates the answer to the query according to some distribution.
We later define a randomized process  (resp., ),
which is equivalent to  (resp., ) in the sense that no matter how an algorithm asks the oracle,
the distribution of instances we finally obtain is the same as  (resp., ).
Let  (resp., ) be the distribution of query-answer history induced by the interaction between an algorithm  and  (resp., ).
We show that when the query complexity of  is  for some ,
 is negligibly small.
Thus, it is impossible to distinguish  from  with high probability.

If we ask at most  queries, 
from the birthday paradox,
the query-answer history does not contain hypercycles with high probability.
From this fact, it is relatively easy to show that we cannot distinguish  from  with  queries.
However, if we ask  queries,
the situation completely changes because of the effect of hypercycles.
For example, suppose that the predicate is \equ and  obtained a constraint  such that variables  already appeared in the query-answer history.
Then,  can calculate the parity , by the propagation, along the constraint  and along a path in the query-answer history.
If they are not the same, the instance must come from .
In other words, if we assume that the instance comes from ,  
we can guess  from the query-answer history.

Can we generalize this algorithm to other predicates?
Though we do not exclude the possibility of sublinear-time algorithms,
we can show that, in general, we need quite a few hypercycles to distinguish  from .
The reason why we were able to use the propagation is that the value of a variable in a predicate \equ uniquely determines the values of other variables.
For other symmetric predicates, however, this is not true.
In fact, the correlation between variables exponentially decays along paths.
Thus, even if variables  and  already appeared in the query-answer history,
the correlation between  and  is tiny (before obtaining ).
Precisely, 
we will show that  is tiny where  is the edge set in the query-answer history.
Thus,  is almost identical to the uniform distribution.
It follows that we cannot distinguish  from  with  queries.

To prove this, we use several facts about expanders.
Note that the lengths of hypercycles are large (roughly, ) in an expander.
Thus, for two adjacent vertices  and ,
the distance between them is at least  after removing the constraint containing them.
Furthermore, the neighborhood of  looks like a hypertree  with depth .
Note that any information from  comes through the leaves of .
Though the number of leaves of  is exponential in the depth, 
we can show that the only tiny portion of them is connected to  (without passing ).
Since such leaves have an exponentially small correlation with ,
we conclude that the correlation between  and  is negligibly small.


\subsection{Properties of }\label{subsec:probability}
We show several lemmas about  and probability distributions.
Due to the space limit, all the proofs are deferred to Appendix~\ref{apx:probability}.
\begin{lemma}\label{lmm:addition}
  Let  and  be distributions generating random variables  and .
  Suppose that , and  for any .
  Then, .
\end{lemma}
\begin{lemma}\label{lmm:serial}
  Let  a distribution generating .
  Suppose that .
  Then,
  
\end{lemma}
\begin{lemma}\label{lmm:product}
  Let  be a distribution generating .
  Suppose that  is equal for every  and  for every .
  Then,
  
\end{lemma}

\section{An  Lower Bound for Two-Sided Error Testers}\label{sec:two-sided}
In this section, 
we give a proof of Theorem~\ref{thr:two-sided}.
A reader can safely assume that a predicate  is symmetric until the proof of Theorem~\ref{thr:two-sided}.

\subsection{Probabilistic Constructions of Expanders}\label{sec:expander}
We introduce a probability distribution  of -regular -uniform multi-hypergraphs with  vertices.
This distribution is used to define  and .
Here, we assume that  is divisible by  (otherwise, no -regular -uniform hypergraph exists).
We construct a hypergraph  as follows.
We start with a set of  vertices  where a vertex  is corresponding to  vertices in .
Then, we partition  into -hyperedges randomly.
Finally, we contract each  vertices of  and let  be the resulting graph.
The proof of the following lemma is deferred to Appendix~\ref{apx:expander}.
\begin{lemma}\label{lmm:expander}
  Let  be a hypergraph chosen uniformly at random from .
  For any ,
  there exists  such that  is a -expander with probability .
\end{lemma}

\subsection{Hard instances}\label{subsec:hard-instance}
As in the proof overview, 
we introduce two distributions  and  of instances of \csp{}.
First, we define a distribution generating instances of \csp{} given an underlying hypergraph.
\begin{definition}
  Let  be a -uniform hypergraph with  vertices.
  Define a distribution  generating an instance  of \csp{} as follows.
  The variable set of  is .
  We choose  uniformly at random.
  For each edge , 
  we choose  uniformly at random from the set .
  Then, we add a constraint  of the form  to .
\end{definition}
\begin{definition}
  Given parameters , 
  define a distribution  generating an instance of \csp{} as follows.
  First, we choose a hypergraph  from .
  Then, an instance is output according to .

  Similarly, define a distribution  generating an instance of \csp{} as follows.
  First, we choose a hypergraph  from .
  Then, for each edge ,
  we choose  uniformly at random and add a constraint  of the form .
\end{definition}
We can describe the generating process of  with a graphical model.
Each vertex in the graphical model corresponds to  or ,
and each edge expresses the dependency between two random variables.
For an exposition of graphical models, see~\cite{Bis06}.
The important fact derived from the graphical model is the following.
\begin{observation}
  Let  be a hypergraph and  be a subgraph of .
  Let  be sets of vertices such that any path in  between  and  passes a vertex of .
  Then,  under .
\end{observation}

From the construction, 
any instance of  is satisfiable.
On the other hand, 
the following lemma is well-known (e.g.,~\cite{Sch08,Tul09}).
We provide a proof for completeness in Appendix~\ref{apx:far}.
\begin{lemma}\label{lmm:far}
  For any , there exists an integer  for which the following holds.
  Let  be an instance of \csp{} chosen from  where  is a predicate.
  Then,  is -far from satisfiability with a probability of .
\end{lemma}

\subsection{Randomized processes equivalent to  and }
We show that, with high probability,
any algorithm  with  queries runs on distributions , or  can find at most  cycles and the lengths of those cycles are .

We define a randomized process , which interacts with , 
so that  answers queries from  while constructing a random graph from .
Thus, the interaction of  with  captures a random execution of  on a graph uniformly distributed in .
Similarly, we define a randomized process , which imitates .

The process  has two stages.
The first stage continues as long as  performs queries, and  answers to those queries.
In the second stage,  determines the rest of the instance.
 internally holds a supposed solution , 
which is hidden from .
Literal vectors are determined so as not to contradict this solution.

First stage of :
Starting from , 
for each query  of ,  proceeds as follows.
For each vertex , 
we define \textit{remaining degree}  as the number of constraints adjacent to  which are not accessed yet by .
We choose  with a probability according to their remaining degrees.
Specifically, 
since the sum of remaining degrees of all vertices at the time that  specifies  is ,
the probability that a vertex  is chosen as  is .
Similarly, the probability that  is chosen as  is  since the sum of the remaining degrees decreases by one.
This process continues until  is chosen.
Finally, form an edge .
For each chosen vertex , 
if the supposed solution  is not determined yet,
 chooses  uniformly at random.
Then,  chooses a literal vector  uniformly at random from .
Finally,  returns the constraint  of the form  to .

Second stage of :
Among all possibilities of the rest of the underlying graph,
 chooses one of them uniformly at random.
Then,  decides  and  randomly in the same way as the first stage.

The process  proceeds in an almost identical manner.
The only difference is that  does not keep track of the supposed solution and always chooses literal vectors uniformly at random.
It is easy to confirm that the following lemma holds using indunction on the number of queries,
and we omit the proof (see Lemma~7.3 of~\cite{GR08} for details).
\begin{lemma}\label{lmm:equivalent}
  For every algorithm , the process  (resp., ) uniformly generates instances of  (resp., ) when interacting with .
  \qed
\end{lemma}
The proofs of the following two lemmas are deferred to Appendices~\ref{apx:few-cycles} and~\ref{apx:large-girth}.
\begin{lemma}\label{lmm:few-cycles}
  Let  and  be the hypergraph induced by the query-answer history after  steps of interactions between an algorithm  and  (or ).
  Then, with a probability of at least , .
\end{lemma}
\begin{lemma}\label{lmm:large-girth}
  Let  and  be the hypergraph induced by the query-answer history after  steps of interactions between an algorithm  and  (or ).
  Then, with a probability of at least , 
  the girth of  is at least .
\end{lemma}

\subsection{Correlation decay along edges of a hypertree}
Let  be an instance of \csp{} generated by .
Suppose that  is a subgraph of the underlying graph of  and  is a hypertree.
Let  be a (arbitrary) root of  and  be a subset of leaves of .
In this subsection,
we consider how the information of  propagates into  along edges of .
Specifically, we calculate .
A proof of the next lemma is given in Appendix~\ref{apx:cannot-guess-tree}.
\begin{lemma}\label{lmm:cannot-guess-tree}
  Let  be a subgraph of a hypergraph .
  If  is a hypertree, 
  then  and  are independent for any  under .
\end{lemma}
From Lemma~\ref{lmm:cannot-guess-tree},
 holds.

Next, we see how  propagates by connecting vertices at a vertex or an edge.
Proofs of next two lemmas are given in Appendices~\ref{apx:merge-vertex}, and~\ref{apx:merge-edge}, respectively.
\begin{lemma}\label{lmm:merge-vertex}
  Let  be a subgraph of a hypergraph .
  Suppose that  is a hypertree.
  Let  be the set of the subtrees obtained by splitting  and  be a subset of the leaves of .
  Then,
  
\end{lemma}
\begin{lemma}\label{lmm:merge-edge}
  Let  be a subgraph of a hypergraph .
  Suppose that  is a hypertree.
  Let  be the set of subtrees obtained by removing .
  Here,  is the root of .
  Let  be a subset of the leaves of .
  Then,
  
  Here,  is a constant, which only depends on the (symmetric) predicate .
  In particular,  if  is not \equ.
\end{lemma}

\subsection{Putting things together}
Let  be the constant determined in Lemma~\ref{lmm:merge-edge}.
\begin{lemma}\label{lmm:E+S-to-v}
  Let  be a subgraph of a hypergraph  with girth  and let  be an edge.
  Then, for any  and , .
\end{lemma}
\begin{proof}
  Let  be a subgraph of  induced by vertices whose distance from  in  is at most .
  Note that  is a hypertree rooted at  since the girth of  is .
  For a leaf  of , let  be the resulting connecting component containing  after removing .
  We define  as a subset of leaves as follows.
  A leaf  is in  iff  contains a vertex of  or  is not a hypertree.
  Once  is connected to all vertices of , 
  each leaf  involves a cycle.
  Thus,  is at most .
  From Lemma~\ref{lmm:serial}, 
  
  For each leaf  of , 
  we can truncate edges of  since they have no information about  from Lemma~\ref{lmm:cannot-guess-tree}.
  Also, .
  Thus, .
  Now, to calculate , 
  we recursively use Lemmas~\ref{lmm:merge-vertex} and~\ref{lmm:merge-edge} from leaves.
  For each leaf  of , 
  we consider  where .
  We note that  for ,
  and  for a leaf .
  Then, it is clear that .
\end{proof}

\begin{lemma}\label{lmm:E-to-e}
  Let  be a subgraph of a hypergraph  with girth  and let  be an edge in a hypercycle of .
  Then, .
\end{lemma}
\begin{proof}
  From Lemma~\ref{lmm:serial},
  .
  Let .
  From Lemma~\ref{lmm:addition}, 
  .
  From Lemma~\ref{lmm:E+S-to-v}, 
  we have  for .
  This inequality holds for  since  is a convex combination of  and .
  Thus, the lemma holds.
\end{proof}

We show a weaker version of Theorem~\ref{thr:two-sided}, which is only for symmetric predicates.
\begin{theorem}\label{thr:two-sided-weak}
  Let  be a symmetric predicate except \kequ where .
  Then, for any ,
  there exist  and  such that 
  every -tester for \csp{} with a degree bound  requires  queries,
  where .
\end{theorem}
\begin{proof}
  Suppose that there exists a deterministic -tester  for \csp{} with query complexity .
  We choose  later.
  From Lemmas~\ref{lmm:few-cycles} and~\ref{lmm:large-girth},
  by union bound,
   finds vertices in the current query-answer history  times at most and the length of found cycles is at least  with a probability .
  In what follows, we condition on these events.

  We consider a decision tree  generated by interactions between  and .
  To define , 
  we suppose that an interaction between  and  proceeds in two steps;
  i.e.,  first returns a set of  variables  that will be used in the answer constraint,
  and then returns a literal vector  for the constraint.
  Corresponding to these two steps,
   has two kinds of vertices, i.e., \textit{S-vertices (state vertices)} and \textit{I-vertices (intermediate vertices)}.
  In any path of the tree from the root to a leaf,
  -vertices and -vertices appear alternately.
  Each -vertex  corresponds to a particular state of the query-answer history.
  When  obtains a set of variables  from ,
  the state proceeds to a -vertex ,
  which is a child of .
  The edge  is associated with  and the transition probability.
  After that,  obtains a literal vector  from .
  Then, the state proceeds to an -vertex ,
  which is a child of .
  The edge  is associated with  and the transition probability.
  The tree  is similarly defined.
  In particular,
   and  are isomorphic.
    
  We consider couplings of corresponding vertices in  and  (one is mapped to another by the isomorphism).
  Suppose that  and  are a pair of coupled -vertices.
  Since the distributions of variables returned by the first step of an interaction are identical between  and ,
  the transition distributions to their children are identical.
  Next, suppose that  and  is a pair of coupled -vertices.
  If the constraint returned by the previous step does not form a new hypercycle,
  the transition distributions to their children are identical.
  If the constraint forms a new hypercycle,
  from Lemma~\ref{lmm:E-to-e},
  the total variation distance between the distributions of literal vectors is at most .
  With the probability corresponding to this distance,
  we suppose that  succeeds in distinguishing  from  and terminates.
  This always makes  more powerful.
  After this modification, 
  the transition distributions to their children become identical.
  After all, for any pair of coupled leaves of  and , 
  the transition probabilities from the root to them are the same.
  Thus, we cannot distinguish  from  if we reach a leaf of the decision tree.

  Thus, it amounts to calculate the sum of the discarded probabilities.
  Suppose any path  from the root to a leaf of .
  Then, since  finds vertices in the query-answer history  times at most,
  the sum of the discarded probability in  is at most .
  Since the tree is a convex combination of paths (with respect to transition probabilities),
  the total discarded probability is at most .
  By choosing , this value becomes a small constant.
  Thus,  where  (resp., ) is the distribution of the query-answer history induced by the  steps of interactions between  and  (resp., ).

  Since  is a -tester, 
  .
  On the other hand, 
  since a  fraction of instances of  is -far from satisfiability,
  .
  This is, however, a contradiction since .
\end{proof}

\begin{proof}[Proof of Theorem~\ref{thr:two-sided}]
Let  be a predicate such that  for a symmetric predicate  except \kequ.
We slightly change the definition of .
That is, for each edge  of ,
we choose  uniformly at random from the set  instead of .
Then, the rest of the proof is the same as the proof of Theorem~\ref{thr:two-sided-weak}.
\end{proof}

\section{Other Results}\label{sec:other}
A proof of Theorem~\ref{thr:txor} is given in Appendix~\ref{apx:txor}.
The proof is similar to the proof of Theorem~\ref{thr:two-sided}.
The modifications we need are the construction of .
Specifically, 
we introduce noise to the literal vector of each constraint with probability  so that we cannot use propagation anymore to guess the value of variables.
A proof of Theorem~\ref{thr:one-sided} is given in Appendix~\ref{apx:one-sided}.
Any one-sided error tester  cannot reject an instance  until  finds the evidence that  is not satisfiable.
For a hard instance, 
we use an instance obtained from , which is defined in Section~\ref{subsec:hard-instance}.
We show that it is far from satisfiability while any linear size sub-instance of it is satisfiable.
This leads to a linear lower bound.
A proof of Theorem~\ref{thr:equ} is given in Appendix~\ref{apx:equ}.
We reduce \kequ to the problem of testing bipartiteness of a graph,
and finally we use a tester for bipartiteness given in~\cite{GR99}.
Proofs of Theorems~\ref{thr:kcsp} and~\ref{thr:mis} are given in Appendix~\ref{apx:kcsp}.
Similar to~\cite{Tul09}, 
we define a predicate  using Hamming code.
Using algebraic properties of Hamming code, 
we show that the \csp{} is hard to test with sublinear queries.
Our proof can be seen as an extension of the proof of~\cite{BOT02}, 
which showed a linear lower bound for testing -\xor.
We prove Theorem~\ref{thr:mis} using a reduction from the hardness of \kcsp.

\newpage

\section*{Acknowledgements}
The author thanks Daisuke Okanohara and Masaki Yamamoto for helpful comments.

\bibliography{arxiv}{}

\newpage
\appendix
\noindent {\bf\Large \appendixname}

\section{Proof of Subsection~\ref{subsec:probability}}\label{apx:probability}

\subsection{Proof of Lemma~\ref{lmm:addition}}
\begin{proof}
  
\end{proof}

\subsection{Proof of Lemma~\ref{lmm:serial}}
\begin{proof}
  We consider the following value.
  
  Then,
  
\end{proof}


\subsection{Proof of Lemma~\ref{lmm:product}}
\begin{proof}
  We use induction on .
  When , we have nothing to prove.

  Suppose that the lemma holds when .
  We will show that the lemma also holds when .
  In fact,
  
  Substituting ,
  we get the desired result.
\end{proof}

\section{Proof of Section~\ref{sec:two-sided}}\label{apx:proof-two-sided}

\subsection{Proof of Lemma~\ref{lmm:expander}}\label{apx:expander}
\begin{proof}
  Fix a set of  (random) hyperedges  and a set of  vertices  where .
  We consider the probability that every hyperedge of  is contained in .
  Since  vertices are involved with at most  hyperedges,  hyperedges determine at most  neighbors, 
  This is upper-bounded by 
  
  
  For a fixed s,  can be chosen in  ways and  can be chosen in  ways.
  Thus, the probability that such an event occurs is upper-bounded by 
  
  for some .

  By summing over ,
  
  The first term is  and the second term is also  by taking  small enough.
\end{proof}

\subsection{Proof of Lemma~\ref{lmm:far}}\label{apx:far}
\begin{proof}
  Let us fix an assignment  over variables and  be a random variable indicating that the constraint  is satisfied by the assignment.
  Then,  and all  are mutually independent since every  is mutually independent.
  Let , 
  then from Hoeffding's inequality, .
  By choosing , 
  the union bound over all  possible assignments over variables yields the desired results.
\end{proof}

\subsection{Proof of Lemma~\ref{lmm:few-cycles}}\label{apx:few-cycles}
\begin{proof}
  After the -th interaction,
  the number of vertices in the query-answer history is at most .
  Thus, the sum of the remaining degrees of those vertices is at most .
  On the other hand, the sum of the remaining degrees of other vertices is at least .
  Thus, the probability that the -th vertex  at the edge for the -th answer is contained in the query-answer history is at most  when .
  Therefore, the expected number of  is at most 
  
  From Markov's inequality, the lemma follows.
\end{proof}
\subsection{Proof of Lemma~\ref{lmm:large-girth}}\label{apx:large-girth}
\begin{proof}
  Let  be the -th query by .
  After the -th interaction,
  the number of vertices in the query-answer history is at most .
  Since the degree is bounded by ,
  the number of vertices in the query-answer history whose distance from  is at most  is at most .
  Thus, the sum of the remaining degrees of such vertices is at most .
  On the other hand, the sum of the remaining degrees of other vertices is at least .
  Thus, the probability that the -th vertex  of the edge for the -th answer is contained in the query-answer history is at most .
  The last inequality is from .
  Therefore, by union bound, the probability that such an event occurs is at most,
  
\end{proof}


\subsection{Proof of Lemma~\ref{lmm:cannot-guess-tree}}\label{apx:cannot-guess-tree}
First, for an edge  and a vertex ,
we show that  and  are independent.
\begin{lemma}\label{lmm:cannot-guess-edge}
  Let  be a hypergraph and let  be an edge of .
  Then, for any vertex ,  and  are independent under .
\end{lemma}
\begin{proof}
  We show that  is uniform after we choose the value of .
  Let  and we assume that  without loss of generality.
  Then,  generates  uniformly at random.
  Let  be the vector of chosen values.
  Then,  chooses  from the set .
  Let  be the size of .
  Here, we separate  into  couples of vectors .
  Let  be the set of such couples.
  Then,  is partitioned into .
  We consider the set .
  Then, it is easy to see that , i.e., every vector from  appears exactly once in .
  Thus, eventually,  is distributed uniformly at random in .
\end{proof}

\begin{proof}[Proof of Lemma~\ref{lmm:cannot-guess-tree}]
  We use induction on the number of edges of .
  When  consists of one edge, 
  the lemma holds from Lemma~\ref{lmm:cannot-guess-edge}.

  Let  be an integer.
  Assume that, 
  for any hypertree  with  and ,
   and  are independent under .
  Let  be a hypertree with  and  be the supposed vertex.
  Since ,
  there exists an edge  such that  contains a leaf,
  but does not contain  as a leaf.
  Let  be the unique vertex that connects  and .
  Note that  may coincides with .
  Then, 
  
  Thus, 
  
  Since ,  from Lemma~\ref{lmm:cannot-guess-edge} and , this is equal to
  
  From the assumption of the induction, we have .
\end{proof}

\subsection{Proof of Lemma~\ref{lmm:merge-vertex}}\label{apx:merge-vertex}
\begin{lemma}\label{lmm:product-tv}
  Let  and  be distributions generating .
  And, suppose that  is given by
  
  Then, .
  The equality only holds when (at least)  of  are .
\end{lemma}
\begin{proof}
  We use induction on .
  When , we have nothing to prove.

  Suppose that the lemma holds when .
  Now, we show that the lemma also holds when .
  For notational simplicity,
  we define .
  Then, .
  Let  be a distribution generating  in such a way that
  
  From the assumption, we have .
  Also,
  
  Let  and  where .
  Then, 
  
  Similarly, .
  Thus, 
  .
  
  We finally remark about the condition that the equality holds.
  We note that the case  and  or vice versa cannot happen since in this case we cannot decide the value of .
  Thus, the equality of (\ref{eqn:leq}) only holds when  or  equals zero.
  Also,  becomes non-zero if  or  is non-zero.
  Thus, the claim holds.
\end{proof}

\begin{proof}[Proof of Lemma~\ref{lmm:merge-vertex}]
  We note that  for  under .
  Since  is uniform from Lemma~\ref{lmm:cannot-guess-tree},
  we have from Lemma~\ref{lmm:product} that
  
  Then, by applying Lemma~\ref{lmm:product-tv}, we have the desired result.
\end{proof}

\subsection{Proof of Lemma~\ref{lmm:merge-edge}}\label{apx:merge-edge}
\begin{proof}
  Let  for .
  Also, we let  where  and .
  Then, from Lemma~\ref{lmm:product}, 
  
  Let , then 
  
  For each , 
  we can think of a random (Boolean) variable that takes  with probability  and  with probability .
  Then,  can be seen as the total variation distance of this random variable.
  Since the probability distribution of this random variable exactly matches the condition of Lemma~\ref{lmm:product-tv} (note that the denominator of  is canceled out), 
  we have
  
  This already indicates that .

  We fix  and let .
  Let  for  chosen later.
  This excludes singular points implied by the left hand side of (\ref{eqn:leq}).
  We define
  
  We can safely state that  in .

  Next, we only consider the domain .
  Other domains (i.e., ) can be treated in the same manner.
  After a calculation,
  we can see that the limit at  exists and the value is less than one when .
  Thus,  is continuous in .
  In particular,  is uniformly continuous.

  We will show that there exists a universal constant  such that  regardless of .
  This concludes the lemma.
  For , 
  we define .
  When , 
  considering the inequality (\ref{eqn:leq2}) in the proof of Lemma~\ref{lmm:product-tv},
  there exists some constant  such that .

  The remaining case is .
  We will show that there exists a constant  such that  for .
  From the uniform continuity of , 
  by choosing  small enough,
  we establish the desired result.

  Let .
  Without loss of generality,
  we can assume that  and .
  For , 
  we consider the following function of  and .
  
  We let .
  If the minimum of  over  is non-negative, 
  we can say that  for .
  Since the denominator of  (after factoring) is non-negative,
  we only consider its numerator .
  We note that  are odd functions and the degrees of  are at most two.
  Thus,  is a linear function of  when we fix .
  Suppose that  for some .
  Then, by moving  to  or ,
  we obtain a smaller value.
  Thus, it suffices to check the case  and .
  When , we have already seen that .
  The case  corresponds to the following question:
  how much can we guess the value of  when we know the actual value of  and we do not know values of other variables?
  For any symmetric predicate except \equ, 
  the choice of  is not unique.
  Thus, we can choose  that only depends on .
\end{proof}

\section{An  Lower Bound for Testing \txor}\label{apx:txor}
In this section, 
we give the proof of Theorem~\ref{thr:txor}.
To make hard instances that are -close to satisfiability,
we slightly modify the construction of .
We use the same  as defined in Section~\ref{sec:two-sided}.
\begin{definition}
  Let  be a graph with  vertices.
  Let  be an error parameter.
  Define a distribution  generating an instance  of \txor as follows.
  The variable set of  is .
  We choose  uniformly at random.
  For each edge , 
  we choose  uniformly at random from the set  with probability ,
  and from the set  with probability .
  Then, we add a constraint  of the form  to .
\end{definition}
\begin{definition}
  Given parameters , 
  define a distribution  generating an instance of \txor as follows.
  First, we choose a graph  from .
  Then, an instance is output according to .
\end{definition}
The following lemma is immediate.
\begin{lemma}\label{lmm:close}
  For any  and , the following holds.
  Let  be an instance of \txor chosen from .
  Then,  is -close to satisfiability with a probability of .
  \qed
\end{lemma}

We use  defined above instead of  defined in Section~\ref{sec:two-sided} to prove Theorem~\ref{thr:txor}.
The proof is almost same as the proof of Theorem~\ref{thr:two-sided}.
A modification occurs only in the proof of Lemma~\ref{lmm:merge-edge}.
The following is an analogue of Lemma~\ref{lmm:merge-edge} for the distribution 
\begin{lemma}\label{lmm:merge-edge-txor}
  Let  be a subgraph of a graph .
  Suppose that  is a tree.
  Let  be the subtree obtained by removing .
  Here,  is the root of .
  Let  be a subset of the leaves of .
  Then,
  
\end{lemma}
\begin{proof}
  For simplicity, 
  we assume that .
  We can prove other cases in the same manner.
  It holds that 
  
  Let .
  Then,
  
  Similarly, .
  Thus, 
  .
\end{proof}
\begin{proof}[Proof of Theorem~\ref{thr:txor}]
  Combining the proof of Theorem~\ref{thr:two-sided} and Lemma~\ref{lmm:merge-edge-txor}, 
  the theorem holds.
  Since we use  instead of  as a decaying factor,
  we need to choose .
\end{proof}


\section{A Linear Lower Bound for One-Sided Error Testers}\label{apx:one-sided}
\begin{theorem}\label{thr:one-sided-weak}
  Let  be any symmetric predicate except \equ where .
  Then,
  for any , 
  there exists  such that any one-sided error -tester for \csp{} with a degree bound  requires  queries.
\end{theorem}
\begin{proof}
  Let  be a given instance.
  Since a one-sided error tester must accept  when  is satisfiable,
  it cannot reject  unless it has found an unsatisfiable sub-instance of .
  We show that for any  there exists  for which the following holds: 
  there exists an instance  of \csp{} with a degree bound  such that any linear-size sub-instance is satisfiable while  is -far from satisfiability.
  The lemma clearly holds from this fact.

  From Lemma~\ref{lmm:far}, 
  for any  and ,
  there exist , and an instance  with a degree bound  such that  is -far from satisfiability and the underlying hypergraph is a -expander.
  Let  be a sub-instance of ,
  and let  and  denote the set of variables and constraints of , respectively.
  We show that  is satisfiable when  by induction on .

  Clearly, any sub-instance with no constraint is satisfiable.
  Suppose that any sub-instance of  with less than  constraints is satisfiable.
  Let  be a sub-instance of  with  constraints.
  Then, since  is a -expander,
  .
  Since , 
  there exists some constraint  such that  shares at most two variables with .
  Suppose that  shares two variables  with .
  Note that  is a symmetric predicate except \equ.
  If  accepts  with , 
  then  accepts  with .
  If not, there exists some  such that  accepts  with .
  Thus,  accepts  with  for some .
  Hence, regardless of the values of ,
  we can satisfy  by appropriately choosing the values of the rest of the variables in .
  Other cases are similar.
  Thus, the induction completes and the theorem follows.
\end{proof}
\begin{proof}[Proof of Theorem~\ref{thr:one-sided}]
  Let  be a predicate such that  for a symmetric predicate  except \kequ.
  As the proof of Theorem~\ref{thr:two-sided},
  We change the definition of .  
  Thus, 
  for each edge  of ,
  we choose  uniformly at random from the set  instead of .
  Then, the rest of the proof is the same as the proof of Theorem~\ref{thr:one-sided-weak}.
\end{proof}

\section{An -Tester for \kequ}\label{apx:equ}
In this section, we prove Theorem~\ref{thr:equ}.
The idea is to transform an instance of \kequ into a graph and use a bipartiteness tester given in~\cite{GR99}.

We define a reduction , which maps an instance  of \kequ to an instance  of -\equ.
The set of variables of  is the same as .
For each constraint in  of the form ,
where each  is a literal,
we simply introduce  constraints in  of the form .

\begin{lemma}\label{lmm:reduction-from-keq}
  If  is a satisfiable instance of \kequ,
  then  is satisfiable.
  On the contrary, if  is -far from satisfiability,
  then  is -far from satisfiability where .
\end{lemma}
\begin{proof}
  Let .
  The former part is obvious.
  Furthermore, if  is satisfiable, then  is satisfiable.

  We show the latter part.
  Suppose that  is not -far from satisfiability.
  Since the degree bound of  is (at most) ,
  we can make  satisfiable by removing less than  constraints.
  Let  be the resulting instance.

  We simulate this removal in .
  That is, for each removed constraint in ,
  we remove the corresponding constraint in .
  Let  be the resulting instance of \kequ.
  The number of removed constraints is at most .
  The important fact is that  is a sub-instance of .
  Since  is satisfiable, 
   is also satisfiable.
  However, this contradicts the fact that  is -far from satisfiability.
\end{proof}

Next,
we define a reduction , which maps an instance  of -\equ to a graph .
First, each literal of  forms a vertex in .
Next, for each variable  of , 
we introduce an edge  in .
We call these edges \textit{variable edges}.
Furthermore, 
for each constraint in  of the form  where  and  are literals,
we introduce two edges  and  in .
We call these edges \textit{constraint edges}.
The supposed bipartition of  is into the set of literals whose values are  (true) and  (false) in the solution of .

\begin{lemma}\label{lmm:reduction-from-2eq}
  If  is a satisfiable instance of \textsf{-\equ},
  then  is satisfiable.
  On the contrary, if  is -far from satisfiability,
  then  is -far from satisfiability where .
\end{lemma}
\begin{proof}
  Let .
  The number of vertices of  is ,
  where  is the number of variables of  and the degree bound  of  is the same as .
  The former part of the lemma is obvious.
  Furthermore, if  is bipartite, then  is satisfiable.
  
  We show the latter part.
  Suppose that  is not -far from satisfiability.
  Let  be the set of edges such that  becomes bipartite by removing  and .
  First, we canonicalize  so that  does not contain variable edges.
  This is done as follows.
  If  contains a variable edge ,
  we exclude the edge from ,
  and instead we add to  every constraint edge of the form  and  where  is a literal.
  This preserves the property that  becomes bipartite by removing .
  Since the degree bound of  is ,
  after canonicalizing , 
  the size of  is at most .
  Let  be the resulting graph after removing .

  We simulate this removal in .
  That is, for each removed edge in ,
  we remove the corresponding constraint in .
  This can be done since we excluded variable edges.
  Let  be the resulting instance of -\equ.
  The number of removed constraints is at most .
  Again,  is a sub-instance of .
  Since  is bipartite, 
   is satisfiable.
  However, this contradicts the fact that  is -far from satisfiability.
\end{proof}

Finally, we use the following algorithm for testing bipartiteness.
\begin{lemma}\cite{GR99}\label{lmm:bipartiteness}
  There exists a one-sided error -tester for bipartiteness whose running time is ,
  where  is the number of vertices.
\end{lemma}
\begin{proof}[Proof of~Theorem~\ref{thr:equ}]
Combining Lemmas~\ref{lmm:reduction-from-keq},~\ref{lmm:reduction-from-2eq}, and~\ref{lmm:bipartiteness}, 
the theorem holds.
\end{proof}

\section{A Linear Lower Bound for Testing \kcsp}\label{apx:kcsp}
In this section, 
we show that there exists a certain predicate  such that,
\csp{} requires linear number of queries to distinguish satisfiable instances from instances -far from satisfiability.
Then, we show the hardness of \mis.
We use a matrix to define the predicate.
\begin{definition}
  For a matrix , a predicate  is defined as
  
  The matrix  is called a \text{generator matrix} of .
\end{definition}
Since , 
we posit that a constraint of an instance of \csp{} is of the form .

As a hard generator matrix, we use a linear code.
A \textit{linear code} of distance  and length  over  is a subspace of  such that every non-zero vector in the subspace has at least  non-zero entries.
We refer to the code below as Hamming code of length .
\begin{fact}
  Let .
  Then, there exists a linear code of distance  and length  over  with dimension .
\end{fact}
In particular,  holds for Hamming code .

We define two distributions  and  of instances of \csp{} using Hamming code .
From Lemma~\ref{lmm:expander}, 
for any  and ,
there exists  such that we have a -uniform -expander  with  vertices and a degree bound .
We use  as an underlying hypergraph of instances generated by  and .
\begin{itemize}
  \item : 
    We choose  for each  uniformly at random. 
    Then, for each edge , 
    we introduce a constraint of the form .
  \item :
    For each edge ,
    we choose  uniformly at random and introduce a constraint of the form .
\end{itemize}
From the construction,
any instance of  is satisfiable.
On the other hand, 
from Lemma~\ref{lmm:far}, 
for any , by appropriately choosing ,
 fraction of instances of  is -far, i.e., -far.

\begin{theorem}\label{thr:generator-hardness}
  Let  be Hamming code.
  Then, for any , 
  there exists  such that every -tester for \csp{} with a degree bound  requires  queries.
\end{theorem}
\begin{proof}
  Let  be an instance chosen from .
  One constraint of \csp{} consists of a chunk of  linear equation.
  Thus, in total, there exists  linear equations in ,
  where  is the number of constraints of .
  We can write these equations in the form  using a matrix  and a vector .
  Here,  is uniquely determined by the underlying hypergraph  regardless of .

  We show that for any set of  constraints of , 
  the corresponding rows in  are linearly independent.
  Suppose that there exists a set  of  constraints whose corresponding rows are linearly dependent.
  Let  denote the set of variables incident to .
  Since every chunk equation comes from a distance- code, every linear combination of rows within a chunk must have at least three elements.
  Hence, the linear combination required to derive  must include at least three elements from each of the  constraints.
  To derive , each of these elements must occur an even number of times,
  and hence  constraints can involve at most  variables in total.
  If we choose , this is impossible.

  Let  be a sub-instance obtained by choosing any  constraints.
  Since the rows of  are linearly independent,  is also uniformly distributed when  is chosen uniformly at random.
  Thus, no algorithm can distinguish instances of  from instances of  with  queries.
  The theorem follows.
\end{proof}

\begin{proof}[Proof of Theorem~\ref{thr:mis}]
Using a modified version of the FGLSS reduction from \maxkcsp to \mis used in~\cite{Tre01}, 
which is tailored for bounded-degree instances,
we have this theorem.
\end{proof}





\end{document}
