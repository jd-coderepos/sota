\documentclass{article}




\usepackage[preprint,nonatbib]{nips_2018}

\usepackage[numbers]{natbib}

\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{amsfonts}       \usepackage{microtype}      

\usepackage{graphicx}
\usepackage{amsmath,amssymb} \usepackage{color}

\usepackage{epsfig}
\usepackage[super]{nth}
\usepackage{booktabs}
\usepackage[format=plain,labelformat=simple,labelfont=bf,labelsep=period,font=small,skip=4pt,compatibility=false]{caption}
\usepackage[font=scriptsize,skip=2pt]{subcaption}

\usepackage{setspace}
\usepackage{nicefrac}

\usepackage{etoolbox}
\usepackage[binary-units]{siunitx}
\sisetup{detect-all=true}
\sisetup{quotient-mode = fraction}
\sisetup{fraction-function = \nicefrac}
\robustify\bfseries
\DeclareSIUnit{\inch}{inch}



\usepackage{float}
\usepackage{algpseudocode,algorithm,algorithmicx}
\newcommand*\Let[2]{\State #1 $\gets$ #2}
\newfloat{algorithm}{t}{lop}
\floatname{algorithm}{Algorithm}
\captionsetup{compatibility=false}


\usepackage[capitalize]{cleveref}
\crefname{section}{Sec.}{Sec.}

\usepackage{wrapfig}

\usepackage{tabularx}
\usepackage{multirow}
\usepackage{todonotes}

\clearpage{}
\usepackage{xspace}
\newcommand{\vs}{\emph{vs.}\@\xspace}
\newcommand{\eg}{\emph{e.\thinspace{}g.}\@\xspace}
\newcommand{\ie}{\emph{i.\thinspace{}e.}\@\xspace}
\newcommand{\iid}{\emph{i.\thinspace{}i.\thinspace{}d.}\@\xspace}
\newcommand{\wrt}{\emph{w.\thinspace{}r.\thinspace{}t.}\@\xspace}
\newcommand{\cf}{\emph{cf.}\@\xspace}
\newcommand{\etc}{\emph{etc}}
\newcommand{\Eq}{Eq.\@\xspace}
\newcommand{\Eqs}{Eqs.\@\xspace}
\newcommand{\Fig}{Fig.\@\xspace}
\newcommand{\Figs}{Figs.\@\xspace}
\newcommand{\Tab}{Tab.\@\xspace}
\newcommand{\Tabs}{Tabs.\@\xspace}
\newcommand{\Sec}{Sec.\@\xspace}
\newcommand{\Secs}{Secs.\@\xspace}
\newcommand{\Def}{Def.\@\xspace}
\newcommand{\resp}{resp.\@\xspace}
\newcommand{\etal}{\emph{et al.}\@\xspace}

\def\d{\text{d}}
\def\tr{^{\textsf{T}}}
\DeclareMathOperator{\vect}{vec}
\DeclareMathOperator{\diag}{diag}

\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\C}{\ensuremath{\mathbb{C}}}

\newcommand{\mv}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\mm}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\ms}[1]{\ensuremath{\boldsymbol{#1}}}
\newcommand{\mt}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\mb}[1]{\ensuremath{\mathbb{#1}}}

\newcommand{\argmin}[1]{\ensuremath{\underset{#1}{\operatorname{arg\,min}}} \thinspace{}}
\newcommand{\argmax}[1]{\ensuremath{\underset{#1}{\operatorname{arg\,max}}} \thinspace{}}



\newcommand{\invisible}[1]{}


\newcommand\x{\mathbf{x}}
\newcommand\y{\mathbf{y}}
\renewcommand\C{\mathbf{C}}

\newcommand{\Cl}{\mathcal{C}}

\newcommand\expert{\phi}
\newcommand\expertparam{\alpha}
\newcommand\allparams{\boldsymbol{\Theta}}
\newcommand\norm[1]{\lVert #1 \rVert}

\newcommand\FoE{\mathrm{\scriptscriptstyle FoE}}
\newcommand\pwMRF{\mathrm{\scriptscriptstyle pwMRF}}

\newcommand\bvector[1]{\begin{bmatrix} #1 \end{bmatrix}}

\newcommand\Gaussian{\mathcal{N}}
\newcommand\relerr{\left<\epsilon\right>}
\newcommand\Var{\text{Var}}
\newcommand\Ind{\mathbb{I}}

\usepackage{ifthen}

\newcommand{\missing}[1]{\textbf{\textcolor{red}{#1}}}

\newcommand{\myparagraph}[1]{\smallskip\noindent\textbf{#1}}


\makeatletter

\newlength\minalignvsep


\def\align@preamble{   &\hfil
    \setboxz@h{\@lign$\m@th\displaystyle{##}$}    \ifnum\row@>\@ne
    \ifdim\ht\z@>\ht\strutbox@
    \dimen@\ht\z@
    \advance\dimen@\minalignvsep
    \ht\strutbox\dimen@
    \fi\fi
    \strut@
    \ifmeasuring@\savefieldlength@\fi
    \set@field
    \tabskip\z@skip
   &\setboxz@h{\@lign$\m@th\displaystyle{{}##}$}    \ifnum\row@>\@ne
    \ifdim\ht\z@>\ht\strutbox@
    \dimen@\ht\z@
    \advance\dimen@\minalignvsep
    \ht\strutbox@\dimen@
    \fi\fi
    \strut@
    \ifmeasuring@\savefieldlength@\fi
    \set@field
    \hfil
    \tabskip\alignsep@
}
\makeatother
\clearpage{}
\clearpage{}\newsavebox\myboxA
\newsavebox\myboxB
\newlength\mylenA
\newcommand*\xoverline[2][0.75]{    \sbox{\myboxA}{$\m@th#2$}    \setbox\myboxB\null    \ht\myboxB=\ht\myboxA    \dp\myboxB=\dp\myboxA    \wd\myboxB=#1\wd\myboxA    \sbox\myboxB{$\m@th\overline{\copy\myboxB}$}    \setlength\mylenA{\the\wd\myboxA}    \addtolength\mylenA{-\the\wd\myboxB}    \ifdim\wd\myboxB<\wd\myboxA       \rlap{\hskip 0.5\mylenA\usebox\myboxB}{\usebox\myboxA}    \else
        \hskip -0.5\mylenA\rlap{\usebox\myboxA}{\hskip 0.5\mylenA\usebox\myboxB}    \fi}


\newcommand{\Wlog}{\emph{W.\thinspace{}l.\thinspace{}o.\thinspace{}g.}\@\xspace}

\newcommand\X{\mathbf{X}}
\newcommand\Y{\mathbf{Y}}
\newcommand\params{\mathbf{\theta}}
\newcommand\pred{g}
\newcommand\E{\mathbb{E}}
\newcommand{\f}{f}
\newcommand{\noise}{\epsilon}
\newcommand{\imtocol}{\text{im2col}}
\newcommand\DD{D}
\newcommand\Pp{\mathbf{P}}
\newcommand\Pd{\tilde{\mathbf{P}}}

\newcommand\dist{d}
\newcommand\KNN{\text{KNN}}
\newcommand\q{q}
\newcommand\kk{k}
\newcommand\db{x}
\newcommand\dbs{X}
\newcommand\mdbs{\bar{X}}
\newcommand\dbI{I}
\newcommand\perm{\pi}
\newcommand\prob{\mathbb{P}}
\newcommand\tcat{t}
\newcommand\Tcat{T}
\newcommand\Cat{\text{Cat}}
\newcommand\logit{\alpha}
\newcommand\mlogit{\bar{\alpha}}
\newcommand\mw{\bar{w}}
\newcommand\Conc{\text{Con}}
\newcommand\tconc{t_{\text{con}}}
\newcommand\G{G}
\newcommand\w{w}
\newcommand\D{D}
\newcommand\nnn{\text{N}^3}
\newcommand\OO{Y}
\newcommand\given{\ | \ }
\newcommand\U{\mathcal{U}}\clearpage{}



\floatstyle{plain}
\newfloat{myalgo}{tbhp}{mya}

\newenvironment{Algorithm}[2][tbh]{\begin{myalgo}[#1]
\centering
\begin{minipage}{#2}
\begin{algorithm}[H]}{\end{algorithm}
\end{minipage}
\end{myalgo}}
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}
\renewcommand{\floatpagefraction}{.8}


\title{Neural Nearest Neighbors Networks}

\author{Tobias Pl\"otz \qquad Stefan Roth \\ Department of Computer Science, TU Darmstadt}


\begin{document}

\maketitle



\begin{abstract}
  Non-local methods exploiting the self-similarity of natural signals have been well studied, for example in image analysis and restoration.
Existing approaches, however, rely on $\kk$-nearest neighbors (KNN) matching in a fixed feature space. 
The main hurdle in optimizing this feature space \wrt application performance is the non-differentiability of the KNN selection rule. 
To overcome this, we propose a continuous deterministic relaxation of KNN selection
that maintains differentiability \wrt pairwise distances, but retains the original KNN as the limit of a temperature parameter approaching zero. 
To exploit our relaxation, we propose the \emph{neural nearest neighbors block} ($\nnn$ block), a novel non-local processing layer that leverages the principle of self-similarity and can be used as building block in modern neural network architectures.\footnote{Code and pretrained models are available at \url{https://github.com/visinf/n3net/}.} 
We show its effectiveness for the set reasoning task of correspondence classification as well as for image restoration, including image denoising and single image super-resolution, where we outperform strong convolutional neural network (CNN) baselines and recent non-local models that rely on KNN selection in hand-chosen features spaces.
 \end{abstract}
\section{Introduction}
The ongoing surge of convolutional neural networks (CNNs) has revolutionized many
areas of machine learning and its applications by enabling unprecedented predictive accuracy. 
Most network architectures focus on local processing by combining convolutional layers and element-wise operations. 
In order to draw upon information from a sufficiently broad context, several strategies, including dilated convolutions \cite{Yu:2015:MSC} or hourglass-shaped architectures \cite{Long:2015:FCN}, have been explored to increase the receptive field size. 
Yet, they trade off context size for localization accuracy.
Hence, for many dense prediction tasks, \eg in image analysis and restoration, stacking ever more convolutional blocks has remained the prevailing choice to obtain bigger receptive fields \cite{Kim:2016:VDSR,Ledig:2017:PRS,Mao:2016:IRU,Timofte:2017:NTI,Zhang:2017:BGD}.

In contrast, traditional algorithms in image restoration increase the receptive field size via non-local processing, leveraging the self-similarity of natural signals.
They exploit that image structures tend to re-occur within the same image \cite{Zontak:2011:ISS}, giving rise to a strong prior for image restoration \cite{Lotan:2016:NMR}.
Hence, methods like non-local means \cite{Buades:2005:NLA} or BM3D \cite{Dabov:2006:IDB} aggregate information across the whole image to restore a local patch. 
Here, matching patches are usually selected based on some hand-crafted notion
of similarity, \eg the Euclidean distance between patches of input intensities. 
Incorporating this kind of non-local processing into neural network architectures for image restoration has only very recently been considered \cite{Lefkimmiatis:2017:NLC,Yang:2018:BM3D}. 
These methods replace the filtering of matched patches with a trainable network, while the feature space on which $\kk$-nearest neighbors selection is carried out is taken to be fixed. 
But why should we rely on a predefined matching space in an otherwise end-to-end trainable neural network architecture? 
In this paper, we demonstrate that we can improve non-local processing
considerably by also optimizing the feature space for matching.

The main technical challenge is imposed by the non-differentiability of the KNN selection rule.
To overcome this, we make three contributions.
First, we propose a continuous deterministic relaxation of the KNN rule,
which allows differentiating the output \wrt pairwise distances in the input space, such as between image patches. 
The strength of the novel relaxation can be controlled by a temperature parameter whose gradients can be obtained as well. 
Second, from our relaxation we develop a novel neural network layer,
called  \emph{neural nearest neighbors block} ($\nnn$ block), which enables end-to-end trainable non-local processing based on the principle
of self-similarity.
Third, we demonstrate that the accuracy of image denoising and single image super-resolution (SISR) can be improved significantly by augmenting strong local CNN architectures with our novel $\nnn$ block, also outperforming strong non-local baselines.
Moreover, for the task of correspondence classification, we obtain significant improvements by simply augmenting a recent neural network baseline with our $\nnn$ block, showing its effectiveness on set-valued data.


 \begin{figure*}[t]
\begin{center}
\begin{subfigure}[b]{0.18\textwidth}
	\centering
	\includegraphics[width=\textwidth]{figures/fig1_1.pdf}
	\caption{Query and database}
	\label{fig:fig1_query_db}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.26\textwidth}
	{\includegraphics[width=\textwidth]{figures/fig1_2.pdf}}
	\caption{KNN selection (Eq.~\ref{eq:knn})}
	\label{fig:fig1_knn}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.26\textwidth}
	\includegraphics[width=\textwidth]{figures/fig1_3.pdf}
	\caption{Stochastic NN (Eqs.~\ref{eq:cat_sample_1} to \ref{eq:neighbor_from_w})}
	\label{fig:fig1_snn}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.26\textwidth}
	\includegraphics[width=\textwidth]{figures/fig1_4.pdf}
	\caption{Continuous NN (Eqs.~\ref{eq:expect_sample_1} to \ref{eq:expect_neighbor_from_w})}
	\label{fig:fig1_cnn}
	\end{subfigure}
\end{center}
   \caption{\emph{Illustration of nearest neighbors selection as paths on the simplex.} 
   The traditional KNN rule \emph{(\subref{fig:fig1_knn})} selects corners of the simplex deterministically based on the distance of the database items $x_i$ to the query item $q$ \emph{(\subref{fig:fig1_query_db})}.
   Stochastic neighbors selection \emph{(\subref{fig:fig1_snn})} performs a random walk on the corners, while our proposed continuous nearest neighbors selection \emph{(\subref{fig:fig1_cnn})} relaxes the weights of the database items into the interior of the simplex and computes a deterministic path. 
   Depending on the temperature parameter this path can interpolate between a more uniform weighting (red) and the original KNN selection (blue).}
\label{fig:fig1}
\vspace{-0.5em}
\end{figure*}

\section{Related Work}
An important branch of image restoration techniques is comprised of \textbf{non-local methods} \cite{Buades:2005:NLA,Dabov:2006:IDB,Lotan:2016:NMR,Zontak:2013:SSN}, driven by the concept of self-similarity.
They rely on similar structures being more likely to encounter within an image than across images \cite{Zontak:2011:ISS}.
For denoising, the non-local means algorithm \cite{Buades:2005:NLA} averages noisy pixels weighted by the similarity of
local neighborhoods.
The popular BM3D method \cite{Dabov:2006:IDB} goes beyond simple averaging by transforming the 3D stack of matching patches and employing a shrinkage function on the resulting coefficients. 
Such transform domain filtering is also used in other image restoration tasks, \eg single image super-resolution \cite{Cruz:2018:SIS}.
More recently, Yang and Sun~\cite{Yang:2018:BM3D} propose to learn the domain transform and activation functions.
Lefkimmiatis~\cite{Lefkimmiatis:2017:NLC,Lefkimmiatis:2018:UDN} goes further by chaining multiple stages of trained non-local modules.
All of these methods, however, keep the standard KNN matching in fixed feature spaces. 
In contrast, we propose to relax the non-differentiable KNN selection rule in order to obtain a fully end-to-end trainable non-local network.



Recently, non-local neural networks have been proposed for higher-level vision tasks such as object detection or pose estimation \cite{Wang:2017:NLN} and, with a recurrent architecture, for low-level vision tasks \cite{Liu:2018:NLR}. 
While also learning a feature space for distance calculation, their aggregation is restricted to a single weighted average of features, a strategy also known as \emph{(soft) attention}. 
Our differentiable nearest neighbors selection generalizes this; our method can recover a single weighted average by setting $\kk{=}1$.
As such, our novel $\nnn$ block can potentially benefit other methods employing weighted averages, \eg for visual question answering \cite{Xu:2016:AA}
and more general learning tasks like 
modeling memory access \cite{Graves:2014:NTM} or sequence modeling \cite{Vaswani:2017:AIA}.
Weighted averages have also been used for building differentiable relaxations
of the $\kk$-nearest neighbors \emph{classifier} \cite{Goldberger:2005:NCA,Ren:2014:LCN,Vinyals:2016:MNF}. 
Note that the crucial difference to our work is that we propose a differentiable relaxation of the KNN \emph{selection rule} where the output is a \emph{set} of neighbors, instead of a \emph{single} aggregation of the labels of the neighbors.
Without using relaxations, Weinberger and Saul~\cite{Weinberger:2009:DML} learn the distance metric underlying KNN classification using a max-margin approach.
They rely on predefined target neighbors for each query item, a restriction that we avoid. 

\myparagraph{Image denoising.}
Besides improving the visual quality of noisy images, the importance of image denoising also stems from the fact that image noise severely degrades the accuracy of downstream computer vision tasks, \eg detection \cite{Diamond:2017:DPO}. 
Moreover, denoising has been recognized as a core module for density estimation \cite{Alain:2014:WRA} and serves as a sub-routine for more general image restoration tasks in a flurry of recent work, \eg \cite{Bigdeli:2017:DMS,Romano:2017:TLE,Zhang:2017:LDC}. 
Besides classical approaches \cite{Donoho:1995:DST,Roth:2009:FEF}, CNN-based methods \cite{Jain:2009:NID,Mao:2016:IRU,Zhang:2017:BGD} have shown strong denoising accuracy over the past years.
 

\section{Differentiable \emph{k}-Nearest Neighbors}
\label{sec:matching}
We first detail our continuous and differentiable relaxation of the
$\kk$-nearest neighbors (KNN) selection rule.
Here, we will make few assumptions on the data to derive a very general result that can be used with many kinds of data, including text or sets.
In the next section, we will then define a non-local neural network layer based on our relaxation.
Let us start by precisely defining KNN selection. 
Assume that we are given a query item $\q$, a database of candidate
items $(\db_i)_{i \in \dbI}$ with indices $\dbI=\{1,\ldots,M\}$ for matching, and a distance metric $\dist(\cdot, \cdot)$ between pairs of items. 
Assuming that $\q$ is not in the database, $\dist$ yields a ranking of the database items
according to the distance to the query. 
Let $\perm_{\q}: \dbI \rightarrow \dbI$ be a permutation 
that sorts the database items by
increasing distance to $\q$:
\begin{align}
\perm_{\q}(i) < \perm_{\q}(i') \;\Rightarrow\; \dist(\q, \db_i) \leq \dist(\q,\db_{i'}), \quad\forall i,i' \in \dbI.
\end{align}
The KNN of $\q$ are then given by the set of the first $\kk$ items \wrt the permutation $\perm_{\q}$
\begin{align}
\KNN(\q) \equiv \{\db_i \; \given \; \perm_{\q}(i) \leq \kk \}. \label{eq:knn}
\end{align}
The KNN selection rule is deterministic but not differentiable. 
This effectively hinders to derive gradients \wrt the distances $\dist(\cdot,\cdot)$. 
We will alleviate this problem in two steps. 
First, we interpret the deterministic KNN rule as a limit of a parametric family of discrete stochastic sampling
processes. 
Second, we derive continuous relaxations for the discrete variables, 
thus allowing to
backpropagate gradients through the neighborhood selection while still preserving
the KNN rule as a limit case.

\myparagraph{KNN rule as limit distribution.}
We proceed by interpreting the KNN selection rule as the limit distribution of $\kk$ categorical distributions that are constructed as follows. 
As in Neighborhood Component Analysis \cite{Goldberger:2005:NCA},
let $\Cat(\w^1 \given \logit^1, \tcat)$
be a categorical distribution over the indices $\dbI$ of the database items, obtained by deriving logits $\logit^1_i$ from the negative distances to the query item $\dist(\q, \db_i)$, scaled with a temperature parameter $\tcat$. 
The probability of $\w^1$ taking a value $i \in \dbI$ is given by:
\begin{align}
\prob\big[\w^1 = i \given \logit^{1}, \tcat\big] &\equiv \Cat(\logit^1, \tcat) = 
\frac{\exp \left(\nicefrac{\logit^1_i}{\tcat} \right)}
{\sum_{i' \in \dbI} \exp \left(\nicefrac{\logit^1_{i'}}{\tcat} \right)} \\
 \text{where}\quad \logit^1_i &\equiv -\dist(\q,\db_i). \label{eq:cat_sample_1}
\end{align}
Here, we treat $\w^1$ as a one-hot coded vector and denote with $\w^1=i$ that the $i$-th entry is set to one while the others are zero. 
In the limit of $\tcat \to 0$, $\Cat(\w^1 \given \logit^1 , \tcat)$ will converge to a deterministic (``Dirac delta'') distribution centered at the index of the database item with smallest distance to $\q$.
Thus we can regard sampling from $\Cat(\w^1 \given \logit^1 , \tcat)$ as a stochastic relaxation of 1-NN \cite{Goldberger:2005:NCA}.
We now generalize this to arbitrary $k$ by proposing an iterative scheme to construct further conditional distributions $\Cat(\w^{j+1} \given \logit^{j+1}, \tcat)$. 
Specifically, we compute $\logit^{j+1}$ by setting the $\w^j$-th entry of $\logit^j$
to negative infinity, thus ensuring that this index cannot be sampled again:
\begin{align}
\logit^{j+1}_i \equiv \logit^j_i + \log(1-\w^j_i) = 
\begin{cases}
\logit^{j}_i, & \text{if } \w^j \neq i \\
-\infty, &\text{if } \w^j = i.
\end{cases} \label{eq:disc_logitadjust}
\end{align}
The updated logits are used to define a new categorical distribution for the
next index to be sampled:
\begin{align}
\prob\big[\w^{j+1} = i \given \logit^{j+1}, \tcat\big] \equiv  \Cat(\logit^{j+1}, \tcat) = 
\frac{\exp \left(\nicefrac{\logit^{j+1}_i}{\tcat} \right)}
{\sum_{i' \in \dbI} \exp \left(\nicefrac{\logit^{j+1}_{i'}}{\tcat} \right)}. \label{eq:cat_sample_iplusone}
\end{align}
From the index vectors $\w^j$, we can define the \emph{stochastic nearest neighbors} $\{\dbs^1, \ldots, \dbs^\kk\}$ of $\q$ using
\begin{align}
\dbs^j \equiv \sum_{i \in \dbI} \w_i^j \db_i. \label{eq:neighbor_from_w}
\end{align}
When the temperature parameter $\tcat$ approaches zero, the distribution over
the $\{\dbs^{1},\dots,\dbs^{\kk}\}$ will be a deterministic distribution centered on the $\kk$ nearest neighbors of $\q$.
Using these stochastic nearest neighbors directly within a deep neural network is problematic, since gradient estimators for expectations over discrete variables are
known to suffer from high variance \cite{Mnih:2016:VIM}. 
Hence, in the following we consider a continuous deterministic relaxation of the discrete random variables.

\myparagraph{Continuous deterministic relaxation.} 
Our basic idea is to replace the one-hot coded weight vectors with their continuous expectations.
This will yield a deterministic and continuous relaxation of the stochastic nearest neighbors that still converges to the hard KNN selection rule in the limit case of $\tcat \to 0$.
Concretely, the expectation $\mw^{1}$ of the first index vector $\w^1$ is given by
\begin{align}
\mw^{1}_i \equiv \E\big[\w^{1}_i \given \logit^{1}, \tcat\big] = \prob\big[\w^{1} = i \given \logit^{1}, \tcat\big].  \label{eq:expect_sample_1}
\end{align}
We can now relax the update of the logits (Eq.~\ref{eq:disc_logitadjust}) by using the expected weight vector instead of the discrete sample as
\begin{align}
\mlogit^{j+1}_i \equiv \mlogit^{j}_i + \log(1- \mw^{j}_i) \quad\text{with}\quad \mlogit^{1}_i \equiv \logit^{1}_i. \label{eq:expect_logitadjust}
\end{align}
The updated logits are then used in turn to calculate the expectation over the next index vector:
\begin{align}
\mw^{j+1}_i \equiv \E\big[\w^{j+1}_i \given \mlogit^{j+1}, \tcat\big] =  \prob\big[\w^{j+1} = i \given \mlogit^{j+1}, \tcat\big].  \label{eq:expect_sample_i}
\end{align}
Analogously to \cref{eq:neighbor_from_w}, we define \emph{continuous nearest neighbors} $\{\mdbs^1,\ldots,\mdbs^\kk\}$ of $\q$ using the $\mw^j$ as
\begin{align}
\mdbs^j \equiv \sum_{i \in \dbI} \mw_i^j \db_i. \label{eq:expect_neighbor_from_w}
\end{align}
In the limit of $\tcat \to 0$, the expectation $\mw^1$ of the first sampled index vector will approach a one-hot encoding of the index of the closest neighbor. 
As a consequence, the logit update in \cref{eq:expect_logitadjust} will also converge to the hard update from \cref{eq:disc_logitadjust}.
By induction it follows that the other $\mw^{j}$ will converge to a one-hot encoding of the closest indices of the $j$-th nearest neighbor.
In summary, this means that our continuous deterministic relaxation still contains the hard KNN selection rule as a limit case.

\myparagraph{Discussion.}
\Cref{fig:fig1} shows the relation between the deterministic KNN selection, stochastic nearest neighbors, and our proposed continuous nearest neighbors.
Note that the continuous nearest neighbors are differentiable \wrt 
the pairwise distances as well as the temperature $\tcat$. 
This allows making the temperature a trainable parameter. Moreover, the
temperature can depend on the query item $\q$, thus allowing to learn for
which query items it is beneficial to average more uniformly across the
database items, \ie by choosing a high temperature, and for which query items
the continuous nearest neighbors should be close to the discrete nearest
neighbors, \ie by choosing a low temperature. 
Both cases have their justification. 
A more uniform averaging effectively allows to aggregate information from many neighbors at once.
On the other hand, the more distinct neighbors obtained with a low temperature allow to first non-linearly process the information before eventually fusing it.


From \cref{eq:expect_neighbor_from_w} it becomes apparent that the
continuous nearest neighbors effectively take $\kk$ weighted averages over
the database items.
Thus, prior work such as non-local networks \cite{Wang:2017:NLN}, differentiable relaxations of the KNN classifier \cite{Vinyals:2016:MNF}, or soft attention-based architectures \cite{Graves:2014:NTM} can be realized as a special case of our architecture with $\kk=1$.
We also experimented with a continuous relaxation of the 
stochastic nearest neighbors
based on approximating the discrete distributions with Concrete distributions
\cite{Jang:2016:CRW,Maddison:2016:TCD}.
This results in a stochastic sampling of weighted averages as opposed to our deterministic nearest neighbors.
For the dense prediction tasks considered in our experiments, we found
the deterministic variant to give significantly better results, see \cref{sec:experiments_ablation}.  \section{Neural Nearest Neighbors Block}
\label{sec:nldn}
In the previous section we made no assumptions about the source of query and database items. 
Here, we propose a new network block, called \emph{neural nearest neighbors block} ($\nnn$ block, \cref{fig:overview_nnnblock}), 
which integrates our continuous and differentiable nearest neighbors selection
into feed-forward neural networks based on the concept of \emph{self-similarity},
\ie query set and database are derived from the same features
(\eg, feature patches of an intermediate layer within a CNN).
An $\nnn$ block consists of two important parts.
First, an embedding network takes the input and produces a feature embedding as well as temperature parameters.
These are used in a second step to compute continuous nearest neighbors feature volumes that are aggregated with the input.
We interleave $\nnn$ blocks with existing local processing networks to form neural nearest neighbors networks ($\nnn$Net) as shown in \cref{fig:overview_nnnnet}.
In the following, we take a closer look at the components of an $\nnn$ block and their design choices.


\begin{figure*}[tb]
\centering
	\begin{subfigure}[b]{0.46\textwidth}
	\includegraphics[width=\textwidth]{figures/nnnblock-crop.pdf}
	\caption{$\nnn$ block}
	\label{fig:overview_nnnblock}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.46\textwidth}
	\includegraphics[width=\textwidth]{figures/nnnnet-crop.pdf}
	\caption{$\nnn$Net}
	\label{fig:overview_nnnnet}
	\end{subfigure}
\caption{\emph{(\subref{fig:overview_nnnblock})} In a neural nearest neighbors ($\nnn$) block (shaded box), 
an embedding network takes the output $\OO$ of a previous layer 
and calculates a pairwise distance matrix $\DD$ between elements in $\OO$ as well as a temperature parameter ($\Tcat$, red feature layer) for each element.
These are used to produce a stack of continuous nearest neighbors volumes $N_1, \dots, N_{\kk}$ (green), 
which are then concatenated with $\OO$.
We build an $\nnn$Net \emph{(\subref{fig:overview_nnnnet})} by interleaving common local processing networks (\eg, DnCNN \cite{Zhang:2017:BGD} or VDSR \cite{Kim:2016:VDSR})
 with $\nnn$ blocks.}
\label{fig:overview}
\vspace{-0.5em}
\end{figure*}




\myparagraph{Embedding network.}
A first branch of the embedding network calculates a feature embedding $E = f_\text{E}(\OO)$.
For image data, we use CNNs to parameterize $f_\text{E}$; for set input we use multi-layer perceptrons.
The pairwise distance matrix $\DD$ can now be obtained by $\DD_{ij} = \dist(E_i, E_j)$,
where $E_i$ denotes the embedding of the $i$-th item and $\dist$ is a differentiable distance function.
We found that the Euclidean distance works well for the tasks that we consider.
In practice, for each query item, we confine the set of potential neighbors to a subset of all items, \eg all image patches in a certain local region. 
This allows our $\nnn$ block to scale linearly in the number of items instead of quadratically.
Another network branch computes a tensor $\Tcat = f_\text{T}(\OO)$ containing the temperature $\tcat$ for each item.
Note that $f_\text{E}$ and $f_\text{T}$ can potentially share weights to some degree.
We opted for treating them as separate networks as this allows for an easier implementation.

\myparagraph{Continuous nearest neighbors selection.}
From the distance matrix $\DD$ and the temperature
tensor $\Tcat$, we compute $\kk$ continuous nearest neighbors feature volumes
$N_1, \dots, N_{\kk}$ from the input features $\OO$ by applying
\cref{eq:expect_sample_1,eq:expect_logitadjust,eq:expect_sample_i,eq:expect_neighbor_from_w} to each item.
Since $\OO$ and each $N_i$ have equal dimensionality, we could use any element-wise operation to aggregate the original features $\OO$ and the neighbors. 
However, a reduction at this stage would mean a very early fusion of features. 
Hence, we instead simply concatenate $\OO$ and the $N_i$ along the feature dimension, which allows further network layers to learn how to fuse the information effectively in a non-linear way. 

\myparagraph{$\nnn$ block for image data.}
The $\nnn$ block described above is very generic and not limited to a certain input domain. 
We now describe minor technical modifications when applying the $\nnn$ block to image data. 
Traditionally, non-local methods in image processing have been applied at the patch-level, \ie the items to be matched consist of image patches instead of pixels. 
This has the advantage of using a broader local context for matching and aggregation.
We follow this reasoning and first apply a strided \texttt{im2col} operation on $E$ before calculating pairwise distances.
The temperature parameter for each patch is obtained by taking the corresponding center pixel in $\Tcat$.
Each nearest neighbor volume $N_i$ is converted from the patch domain to the image domain by applying a \texttt{col2im} operation, where we average contributions of different patches to the same pixel.

 
\section{Experiments}
\label{sec:experiments}
We now analyze the properties of our novel $\nnn$Net and show its benefits over state-of-the-art baselines.
We use image denoising as our main test bed as non-local methods have been well studied there.
Moreover, we evaluate on single image super-resolution and correspondence classification.

\myparagraph{Gaussian image denoising.}
We consider the task of denoising a noisy image $\mm{D}$, which arises
by corrupting a clean image $\mm{C}$ with additive white Gaussian noise of standard deviation $\sigma$:
\begin{align}
\mm{D} = \mm{C} + \mv{N} \quad\text{with}\quad \mv{N}\sim\Gaussian(0,\sigma^2).
\end{align}
Our baseline architecture is the DnCNN model of Zhang \etal~\cite{Zhang:2017:BGD},
consisting of $16$ blocks, each with a sequence of a $3\times3$ convolutional layer with $64$ feature maps, batch normalization \cite{Ioffe:2015:BNA}, and a ReLU activation function.
In the end, a final $3\times3$ convolution is applied, the output of which is 
added back to the input through a global skip connection.

We use the DnCNN architecture to create our $\nnn$Net for image denoising.
Specifically, we use three DnCNNs with six blocks each, \cf \cref{fig:overview_nnnnet}. 
The first two blocks output $8$ feature maps, which are fed into a subsequent $\nnn$ block that computes $7$ neighbor volumes.
The concatenated output again has a depth of $64$ feature channels, matching the depth of the other intermediate blocks.
The $\nnn$ blocks extract $10\times10$ patches with a stride of $5$.
Patches are matched to other patches in a $80\times80$ region, yielding a total of $224$ candidate patches for matching each query patch. More details on the architecture can be found in the supplemental material.

\myparagraph{Training details.}
We follow the protocol of Zhang \etal~\cite{Zhang:2017:BGD} and use the 400 images in the train and test split of the BSD500 dataset for training. 
Note that these images are strictly separate from the validation images. 
For each epoch, we randomly crop $512$ patches of size $80\times80$ from each training image. 
We use horizontal and vertical flipping as well as random rotations $\in \{\ang{0}, \ang{90}, \ang{180}, \ang{270}\}$ as further
data augmentation. 
In total, we train for $50$ epochs with a batch size of $32$,
using the Adam optimizer \cite{Kingma:2014:ADAM} with default parameters
$\beta_1=0.9, \beta_2=0.999$ to minimize the squared error. 
The learning rate is initially set to $10^{-3}$ and exponentially decreased to
$10^{-8}$ over the course of training. 
Following the publicly available implementation of DnCNN \cite{Zhang:2017:BGD},
we apply a weight decay with strength $10^{-4}$ to the weights of the
convolution layers and the scaling of batch normalization layers.

We evaluate our full model on three different datasets:
\emph{(i)} a set of twelve commonly used benchmark images (Set12),
\emph{(ii)} the 68 images subset \cite{Roth:2009:FEF} of the
BSD500 validation set \cite{Martin:2001:BDB}, and
\emph{(iii)} the Urban100 \cite{Huang:2015:SelfEx} dataset, which contains images of urban scenes where repetitive patterns are abundant.

\begin{table*}[tb]
	\caption{PSNR and SSIM \cite{Wang:2003:MSS} on Urban100 for different architectures on gray-scale image denoising ($\sigma{=}25$).}
	\label{tab:ablation_urban_sigma25}
	\footnotesize
	\centering
	\smallskip
	\begin{tabularx}{\linewidth}{@{}l X l S[table-format=2.2] S[table-format=1.3]@{}}
		\toprule
		& Model							& Matching on 	&  {PSNR [dB]}	& {SSIM}	\\ 		\midrule
		\emph{(i)}& 1 $\times$ DnCNN ($d{=}17$)						& {--}						&  29.97		&  0.879 \\ 		\emph{(ii)}& 1 $\times$ DnCNN ($d{=}18$)						& {--}						&  29.92		&  0.885 \\ 						\emph{(iii)}& 3 $\times$ DnCNN ($d{=}6$), KNN block ($k{=}7$)	& noisy input			&  30.07		& 0.891 \\
		\emph{(iv)}& 3 $\times$ DnCNN ($d{=}6$), KNN block ($k{=}7$)	& DnCNN output ($d{=}17$)	&  30.08		& 0.890 \\
		\emph{(v)}& 3 $\times$ DnCNN ($d{=}6$), Concrete block ($k{=}7$)	& learned embedding	&  29.97 		&  0.889 \\
		\midrule
		\emph{(ours light)}& 2 $\times$ DnCNN ($d{=}6$), $\nnn$ block ($k{=}7$)	& learned embedding & 29.99 		& 0.888 \\
		\emph{(ours full)}& 3 $\times$ DnCNN ($d{=}6$), $\nnn$ block ($k{=}7$)	& learned embedding & \bfseries 30.19 		& \bfseries 0.892 \\
		\bottomrule
	\end{tabularx}
\end{table*}

\begin{table}[b]
	\vspace{-0.5em}
	\caption{PSNR (dB) on Urban100 for gray-scale image denoising for varying $\kk$.}
	\label{tab:k_exp}
	\footnotesize
	\centering
	\smallskip
	\begin{tabularx}{\linewidth}{@{} X S[table-format=2.2] @{\hspace{1cm}} S[table-format=2.2] @{\hspace{1cm}} S[table-format=2.2] @{\hspace{1cm}} S[table-format=2.2] @{\hspace{1cm}} S[table-format=2.2] @{\hspace{1cm}} S[table-format=2.2] @{\hspace{1cm}} S[table-format=2.2]@{}}
		\toprule
					&{$\kk=1$}	& {$\kk=2$}	& {$\kk=3$} 	& {$\kk=4$}	&  {$\kk=5$} 	& {$\kk=6$} 	&  {$\kk=7$}	\\
		\midrule
		$\sigma=25$ & 30.17 	& 30.21 	& 30.15		& \bfseries 30.27		& \bfseries 30.27		& 30.22		& 30.19  \\
		$\sigma=50$ & 26.76		& 26.81 	& 26.78		& \bfseries 26.86		& 26.83		& 26.80		& 26.82  \\
		\bottomrule
	\end{tabularx}
																\end{table}


\subsection{Ablation study}
\label{sec:experiments_ablation}
We begin by discerning the effectiveness of the individual components.
We compare our full $\nnn$Net against several baselines: 
\emph{(i,ii)} The baseline DnCNN network with depths $17$ (default) and $18$ (matching the depth of $\nnn$Net). 
\emph{(iii)} A baseline where we replace the $\nnn$ blocks with KNN selection ($\kk=7$) to obtain neighbors for each patch.
Distance calculation is done on the noisy input patches.
\emph{(iv)} The same baseline as \emph{(iii)} but where distances are calculated on denoised patches.
Here we use the pretrained $17$-layer DnCNN as strong denoiser. 
The task specific hand-chosen distance embedding for this baseline should intuitively yield more sensible nearest neighbors matches than when matching noisy input patches.
\emph{(v)} A baseline where we use Concrete distributions \cite{Jang:2016:CRW,Maddison:2016:TCD} to approximately reparameterize the stochastic nearest neighbors sampling. 
The resulting Concrete block has an additional network for estimating the annealing parameter of the Concrete distribution.

\begin{figure*}[tb]
	\begin{subfigure}{0.225\linewidth}
	\includegraphics[width=\textwidth,trim=00 380 724 100,clip]{figures/generated/urban100_sigma50_imgid62_clean.png}
	\caption{Clean}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.225\linewidth}
	{\includegraphics[width=\textwidth,trim=00 380 724 100,clip]{figures/generated/urban100_sigma50_imgid62_BM3D.png}}
	\caption{BM3D (25.21 dB)}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.225\linewidth}
	\includegraphics[width=\textwidth,trim=00 380 724 100,clip]{figures/generated/urban100_sigma50_imgid62_FFDNet.png}
	\caption{FFDNet (24.92 dB)}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.225\linewidth}
	\includegraphics[width=\textwidth,trim=00 380 724 100,clip]{figures/generated/urban100_sigma50_imgid62_NN3D.png}
	\caption{NN3D (25.00 dB)}
	\end{subfigure}
	\\\begin{subfigure}{0.225\linewidth}
	\includegraphics[width=\textwidth,trim=00 380 724 100,clip]{figures/generated/urban100_sigma50_imgid62_noisy.png}
	\caption{Noisy (14.16 dB)}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.225\linewidth}
	\includegraphics[width=\textwidth,trim=00 380 724 100,clip]{figures/generated/urban100_sigma50_imgid62_DnCNN.png}
	\caption{DnCNN (24.76 dB)}
	\end{subfigure} 
	\hfill
	\begin{subfigure}{0.225\linewidth}
	\includegraphics[width=\textwidth,trim=00 380 724 100,clip]{figures/generated/urban100_sigma50_imgid62_UNLNet.png}
	\caption{UNLNet (25.47 dB)}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.225\linewidth}
	\includegraphics[width=\textwidth,trim=00 380 724 100,clip]{figures/generated/urban100_sigma50_imgid62_N3Net.png}
	\caption{$\nnn$Net (25.57 dB)}
	\end{subfigure}
\caption{Denoising results (cropped for better display) and PSNR values on an image from Urban100 ($\sigma=50$).}
\label{fig:denoising_urban100_s50_i62}
\vspace{-0.5em}
\end{figure*}


\begin{table*}[b]
	\vspace{-0.5em}
	\caption{PSNR (dB) for gray-scale image denoising on different datasets. NLNet does not provide a model for $\sigma=70$ and the publicly available UNLNet model was not trained for $\sigma=70$. RED30 does not provide a model for $\sigma=25$ and BSD68 is part of the RED30 training set. Hence, we omit these results.}
	\label{tab:denoising}
	\centering
	\footnotesize
	\smallskip
	\begin{tabularx}{\linewidth}{@{} l X S[table-format=2.2] S[table-format=2.2] S[table-format=2.2] S[table-format=2.2] S[table-format=2.2] S[table-format=2.2] S[table-format=2.2] S[table-format=2.2]@{}}
		\toprule
		Dataset	 & $\sigma$				& {DnCNN} & {BM3D} & {NLNet} & {UNLNet} & {NN3D}  & {RED30} & {FFDNet} & {N$^3$Net (ours)}	\\
		\midrule
		\multirow{ 3}{*}{Set12} & 25  	& 30.44 & 29.96 & 30.31 & 30.27 & 30.45 & {--}			& 30.43 & \bfseries 30.55 \\
		& 50  							& 27.19 & 26.70 & 27.04 & 27.07 & 27.24 & 27.24		& 27.31 & \bfseries 27.43 \\
		& 70  							& 25.56 & 25.21 & {--}     & {--}     & 25.61 & 25.71		& 25.81	& \bfseries 25.90 \\
		\midrule
		\multirow{ 3}{*}{BSD68} & 25  & 29.23 & 28.56 & 29.03 & 28.99 & 29.19 & {--}			& 							29.19 & \bfseries 29.30 \\
								& 50  & 26.23 & 25.63 & 26.07 & 26.07 & 26.19 & {--}			& 26.29 & \bfseries 26.39 \\
								& 70  & 24.85 & 24.46 & {--}     & {--}     & 24.89 & {--}			& 25.04	& \bfseries 25.14 \\
		\midrule
		\multirow{ 3}{*}{Urban100} 	& 25  & 29.97 & 29.71 & 29.92 & 29.80 & 30.09 & {--}										& 29.92 & \bfseries 30.19 \\
									& 50  & 26.28 & 25.95 & 26.15 & 26.14 & 26.47 & 26.32		& 26.52 & \bfseries 26.82 \\
									& 70  & 24.36 & 24.27 & {--}    & {--}    & 24.53 & 24.63			& 24.87	& \bfseries 25.15 \\
		\bottomrule
	\end{tabularx}
\end{table*}

\Cref{tab:ablation_urban_sigma25} shows the results on the Urban100 test set ($\sigma=25$) from which we can infer four insights:
First, the KNN baselines \emph{(iii)} and \emph{(iv)} improve upon the plain DnCNN model, showing that allowing the network to access non-local information is beneficial.
Second, matching denoised patches (baseline \emph{(iv)}) does not improve significantly over matching noisy patches (baseline \emph{(iii)}).
Third, \emph{learning} a patch embedding with our novel $\nnn$ block shows a clear improvement over all baselines.
 We, moreover, evaluate a smaller version of $\nnn$Net with only two DnCNN blocks of depth $6$ (\emph{ours light}). 
This model already outperforms the baseline DnCNN with depth $17$ despite having \emph{fewer layers} ($12$ \vs $17$) and \emph{fewer parameters} ($427$k \vs $556$k).
Fourth, reparameterization with Concrete distributions (baseline \emph{(v)}) performs worse than our continuous nearest neighbors. 
This is probably due to the Concrete distribution introducing stochasticity into the forward pass, leading to a less stable training.
Additional ablations are given in the the supplemental material.


Next, we compare $\nnn$Nets with a varying number of selected neighbors. 
\Cref{tab:k_exp} shows the results on Urban100 with $\sigma \in \{25,50\}$. 
We can observe that, as expected, more neighbors improve denoising results.
However, the effect diminishes after roughly four neighbors and accuracy starts to deteriorate again.
As we refrain from selecting optimal hyper-parameters on the test set, we will stick to the architecture with $\kk=7$ for the remaining experiments on image denoising and SISR.
 

\subsection{Comparison to the state of the art}
We compare our full $\nnn$Net
against state-of-the-art local denoising methods, \ie 
the DnCNN baseline \cite{Zhang:2017:BGD}, the very deep and wide ($30$ layers, $128$ feature channels) RED30 model \cite{Mao:2016:IRU}, and the recent FFDNet \cite{Zhang:2018:FFD}.
 Moreover, we compare against competing non-local denoisers.
These include the classical BM3D \cite{Dabov:2006:IDB}, which uses a hand-crafted
denoising pipeline, and the state-of-the-art trainable non-local models NLNet \cite{Lefkimmiatis:2017:NLC} and UNLNet \cite{Lefkimmiatis:2018:UDN},
both learning to process non-locally aggregated patches.
We also compare against NN3D \cite{Cruz:2018:NRC}, which applies a non-local step on top of a pretrained network. 
For fair comparison, we apply a single denoising step for NN3D using our 17-layer baseline DnCNN.
As a crucial difference to our proposed $\nnn$Net, all of the compared non-local methods use KNN selection on a fixed feature space, thus not being able to learn an embedding for matching. 

\Cref{tab:denoising} shows the results for three different noise levels. 
We make three important observations:
First, our $\nnn$Net significantly outperforms the baseline DnCNN network on all tested noise levels and all datasets. 
Especially for higher noise levels the margin is dramatic, \eg $+0.54 \text{dB } (\sigma=50)$ or $+0.79 \text{dB } (\sigma=70)$ on Urban100.
Even the deeper and wider RED30 model does not reach the accuracy of $\nnn$Net. 
Second, our method is the only trainable non-local model that is able to outperform the local models DnCNN, RED30, and FFDNet.
The competing models NLNet and UNLNet do not reach the accuracy of DnCNN even on Urban100, whereas our $\nnn$Net even fares better than the strongest local denoiser FFDNet.
Third, the post-hoc non-local step applied by NN3D is very effective on Urban100 where self-similarity can intuitively shine. 
However, on Set12 the gains are noticeably smaller whilst on BDS68 the non-local step can even result in degraded accuracy, \eg NN3D
achieves $-0.04 \text{dB}$ compared to DnCNN while $\nnn$Net achieves  $+0.16 \text{dB}$ for $\sigma=50$.
This highlights the importance of integrating non-local processing into an end-to-end trainable pipeline.
\Cref{fig:denoising_urban100_s50_i62} shows denoising results for an image from the Urban100 dataset. 
BM3D and UNLNet can exploit the recurrence of image structures to produce good results albeit introducing artifacts in the windows.
DnCNN and FFDNet yield even more artifacts due to the limited receptive field and NN3D, as a post-processing method, cannot recover from the errors of DnCNN.
In contrast, our $\nnn$Net produces a significantly cleaner image where most of the facade structure is correctly restored.

\subsection{Real image denoising}
To further demonstrate the merits of our approach, we applied the same $\nnn$Net architecture as before to the task of denoising real-world images with realistic noise.
To this end, we evaluate on the recent Darmstadt Noise Dataset \cite{Ploetz:2017:BDA}, consisting of $50$ noisy images shot with four different cameras at varying ISO levels. 
Realistic noise can be well explained by a Poisson-Gaussian distribution which, in turn, can be well approximated by a Gaussian distribution where the variance depends on the image intensity via a linear noise level function \cite{Foi:2008:PPG}. 
We use this heteroscedastic Gaussian distribution to generate synthetic noise for training.
Specifically, we use a broad range of noise level functions covering those that occur on the test images. 
For training, we use the $400$ images of the BSDS training and test splits, $800$ images of the DIV2K training set \cite{Agustsson:2017:NTI}, and a training split of $3793$ images from the Waterloo database \cite{Ma:2017:WED}.
Before adding synthetic noise, we transform the clean RGB images $\Y_{\text{RGB}}$ to $\Y_{\text{RAW}}$ such that they more closely resemble images with raw intensity values:
\begin{equation} 
\Y_{\text{RAW}} = f_c \cdot Y(\Y_{\text{RGB}}) ^ {f_e}, \text{ with } f_c \sim \U(0.25,1) \text{ and } f_e \sim \U(1.25, 10),
\end{equation}
where $Y(\cdot)$ computes luminance values from RGB, the exponentiation with $f_e$ aims at undoing compression of high image intensities, and scaling with $f_c$ aims at undoing the effect of white balancing.
Further training details can be found in the supplemental material.
\setlength\intextsep{0pt}
\begin{wraptable}{r}{0.485\linewidth}
	\vspace{.7em}
	\caption{Results on the Darmstadt Noise Dataset \cite{Ploetz:2017:BDA}.}
	\label{tab:dnd}
	\centering
	\footnotesize
	\smallskip
	\begin{tabularx}{\linewidth}{@{}X S[table-format=2.2] S[table-format=1.4] S[table-format=2.2] S[table-format=1.4]@{}}
		\toprule
		& \multicolumn{2}{c}{Raw} & \multicolumn{2}{c@{}}{sRGB} \\
		\cmidrule(l{0.3cm}r{0.4cm}){2-3}\cmidrule(l{0.3cm}){4-5}
						& {PSNR}  		& {SSIM} 			&  {PSNR}  		& {SSIM} 	\\
		\midrule
		BM3D			& 46.64			& 0.9724		& 37.78			& 0.9308	  \\
		DnCNN 			& 47.37 		& 0.9760		& 38.08 		& 0.9357	  \\
		$\nnn$Net		& \bfseries 47.56			& \bfseries 0.9767		& \bfseries 38.32			& 0.9384	  \\
		\midrule
		TWSC 			& {--}				& {--}				& 37.94			& 0.9403	  \\
		CBDNet 			& {--}				& {--}				& 38.06			& \bfseries 0.9421	  \\

		\bottomrule
	\end{tabularx}
	\end{wraptable}

\vspace{-1em}
We train both the DnCNN baseline as well as our $\nnn$Net with the same training protocol and evaluate them on the benchmark website. 
Results are shown in \cref{tab:dnd}.
$\nnn$Net sets a new state of the art for denoising raw images, outperforming DnCNN and BM3D by a significant margin. 
Moreover, the PSNR values, when evaluated on developed sRGB images, surpass those of the currently top performing methods in sRGB denoising, TWSC \cite{Xu:2018:TWSC} and CBDNet \cite{Guo:2018:TCB}.



\begin{table}[b]
	\vspace{-0.5em}
	\caption{PSNR (dB) for single image super-resolution on Set5.}
	\label{tab:superresolution}
	\centering
	\footnotesize
	\smallskip
	\begin{tabularx}{\linewidth}{@{}X S[table-format=2.2] @{\hspace{1.2cm}} S[table-format=2.2] @{\hspace{0.7cm}} S[table-format=2.2] @{\hspace{0.7cm}} S[table-format=2.2] @{\hspace{0.7cm}} S[table-format=2.2] @{\hspace{1.2cm}} S[table-format=2.2] @{\hspace{0.7cm}} S[table-format=2.2]@{}}
		\toprule
						& {Bicubic} 	& {SelfEx}	&  {WSD-SR} 	& {MemNet} 	& {MDSR}	& {VDSR} & {N$^3$Net}	\\
		\midrule
		$\times2$  		& 33.68		& 36.49		& 37.21		& 37.78		& 38.11	& 37.53	&  37.57 \\
		$\times3$  		& 30.41		& 32.58		& 33.50		& 34.09		& 34.66	& 33.66	&  33.84 \\
		$\times4$  		& 28.43		& 30.31		& 31.39		& 31.74		& 32.50	& 31.35	&  31.50 \\

		\bottomrule
	\end{tabularx}
\end{table}

\subsection{Single image super-resolution}
We now show that we can also augment recent strong CNN models for SISR with our $\nnn$ block.
We particularly consider the common task \cite{Huang:2015:SelfEx,Kim:2016:VDSR} of upsampling a low-resolution image that was obtained from a high-resolution image by bicubic downscaling.
We chose the VDSR model \cite{Kim:2016:VDSR} as our baseline architecture, since
it is conceptually very close to the DnCNN model for image denoising.
The only notable difference is that it has $20$ layers instead of $17$.
We derive our $\nnn$Net for SISR from the VDSR model by stacking three VDSR networks with depth $7$ and inserting two $\nnn$ blocks ($\kk=7$) after the first two VDSR networks, \cf \cref{fig:overview_nnnnet}. 
Following \cite{Kim:2016:VDSR}, the input to our network is the bicubicly upsampled low-resolution image
and we train a single model for super-resolving images with factors $2$, $3$, and $4$.
Further details on the architecture and training protocol can be found in the supplemental material.
Note that we refrain from building our $\nnn$Net for SISR from more recent networks, \eg MemNet \cite{Tai:2017:MPM}, MDSR \cite{Lim:2017:EDR}, or WDnCNN \cite{Bae:2017:BDR}, since they are too costly to train.

We compare our $\nnn$Net against VDSR and MemNet as well as two non-local models: SelfEx \cite{Huang:2015:SelfEx} and the recent WSD-SR \cite{Cruz:2018:SIS}.
\Cref{tab:superresolution} shows results on Set5 \cite{Bevilacqua:2012:LCS}. 
Again, we can observe a consistent gain of $\nnn$Net compared to the strong baseline VDSR for all super-resolution factors, \eg $+0.15 \text{dB}$ for $\times4$ super-resolution.
More importantly, the other non-local methods perform inferior compared to our $\nnn$Net (\eg $+0.36 \text{dB}$ compared to WSD-SR for $\times 2$ super-resolution), showing that learning the matching feature space is superior to relying on a hand-defined feature space.
Further quantitative and visual results demonstrating the same benefits of $\nnn$Net can be found in the supplemental material.

\subsection{Correspondence classification}
As a third application, we look at classifying correspondences between image features from two images as either correct or incorrect.
Again, we augment a baseline network with our non-local block.
Specifically, we build upon the context normalization network \cite{Yi:2018:LFG}, which we call CNNet in the following.
The input to this network is a \emph{set of pairs of image coordinates} of putative correspondences and the output is a probability for each of the correspondences to be correct.
CNNet consists of $12$ blocks, each comprised of a local fully connected layer with $128$ feature channels that processes each point individually, and a context normalization and batch normalization layer that pool information across the whole point set. 
We augment CNNet by introducing a $\nnn$ block after the sixth original block.
As opposed to the $\nnn$ block for the previous two tasks, where neighbors are searched only in the vicinity of a query patch, here we search for nearest neighbors among all correspondences.
We want to emphasize that this is a pure \emph{set reasoning task}.
Image features are used only to determine putative correspondences while the network itself is agnostic of any image content.

For training we use the publicly available code of \cite{Yi:2018:LFG}.
We consider two settings:
First, we train on the training set of the outdoor sequence \emph{St.~Peter} and evaluate on the test set of \emph{St.~Peter} and another outdoor sequence called \emph{Reichstag} to test generalization.
Second, we train and test on the respective sets of the indoor sequence \emph{Brown}.
\Cref{tab:correspondences} shows the resulting mean average precision (MAP) values at different error thresholds (for details on this metric, see \cite{Yi:2018:LFG}).
We compare our $\nnn$Net to the original CNNet and a baseline that just uses all putative correspondences for pose estimation.
As can be seen, by simply inserting our $\nnn$ block we achieve a consistent and significant gain in all considered settings, increasing MAP scores by $10\%$ to $30\%$.
This suggests that our $\nnn$ block can enhance local processing networks in a wide range of applications and data domains.

\begin{table}[tb]
	\caption{MAP scores for correspondence estimation for different error thresholds and combinations of training and testing set. Higher MAP scores are better.}
	\label{tab:correspondences}
	\centering
	\footnotesize
	\smallskip
	\begin{tabularx}{\linewidth}{@{} X S[table-format=1.3] S[table-format=1.3] S[table-format=1.3] @{\hspace{0.75cm}} S[table-format=1.3] S[table-format=1.3] S[table-format=1.3] @{\hspace{0.75cm}} S[table-format=1.3] S[table-format=1.3] S[table-format=1.3] @{}}
		\toprule
		& \multicolumn{3}{c@{\hspace{0.75cm}}}{St.~Peter / St.~Peter} & \multicolumn{3}{c@{\hspace{0.75cm}}}{St.~Peter / Reichstag} & \multicolumn{3}{c}{Brown / Brown} \\
		\cmidrule(l{0.3cm}r{0.9cm}){2-4}\cmidrule(l{0.1cm}r{0.9cm}){5-7}\cmidrule(l){8-10}
		Threshold               & {No Net} 	& {CNNet}		& {N$^3$Net}				& {No Net} 	& {CNNet}		& {N$^3$Net} 				& {No Net} 	& {CNNet}		& {N$^3$Net}	\\
		\midrule
		$5^\circ$ 				& 0.014		& 0.271		& \bfseries 0.316		& 0.0		& 0.173		& \bfseries 0.231		& 0.054		& 0.236		& \bfseries 0.293		\\
		$10^\circ$ 				& 0.030		& 0.379		& \bfseries 0.431		& 0.038		& 0.337		& \bfseries 0.442		& 0.110		& 0.333		& \bfseries 0.391		\\
				$20^\circ$ 				& 0.071		& 0.522		& \bfseries 0.574		& 0.111		& 0.500		& \bfseries 0.601		& 0.232		& 0.463		& \bfseries 0.510		\\
				\bottomrule
	\end{tabularx}
\end{table} \section{Conclusion}
Non-local methods have been well studied, \eg, in image restoration.
Existing approaches, however, apply KNN selection on a hand-defined feature space, which may be suboptimal for the task at hand.
To overcome this limitation, we introduced 
the first continuous relaxation of the KNN selection rule that maintains differentiability \wrt the pairwise distances used for neighbor selection.
We integrated continuous nearest neighbors selection into a novel network block, called $\nnn$ block, which can be used as a general building block in neural networks.
We exemplified its benefit in the context of image denoising, SISR, and correspondence classification, where we outperform state-of-the-art CNN-based methods and non-local approaches.
We expect the $\nnn$ block to also benefit end-to-end trainable architectures for other input domains, such as text or other sequence-valued data. 
\paragraph{Acknowledgments.}
The research leading to these results has
received funding from the European Research Council under
the European Union's Seventh Framework Programme (FP/2007--2013)/ERC Grant agreement No.~307942.
We would like to thank reviewers for their fruitful comments.


\renewcommand\thesection{\Alph{section}}
\setcounter{section}{0}
\newcommand{\citekim}{\cite{{Kim:2016:VDSR}}}



\section{Architectures and Training Details}
A detailed summary of the used architectures can be found in the following tables:\footnote{``Ker.'', ``Str.'', ``Pad.'', and ``Feat.'' refer to the kernel size, stride, padding and number of feature channels, respectively.}
\begin{itemize}
	\item \Cref{tab:arch_distance_net,tab:arch_temperature_net} show the architecture of embedding network and the temperature network within an $\nnn$ block, respectively.
	\item \Cref{tab:arch_dncnn_block} shows the architecture of a DnCNN block used as local processing network in our $\nnn$Net for denoising. 
	The architecture of the whole $\nnn$Net can be found in \cref{tab:arch_nnn_net_denoising}.
	\item \Cref{tab:arch_vdsr_block} shows the architecture of a VDSR block used as local processing network in our $\nnn$Net for single image super-resolution. 
	The architecture of the whole $\nnn$Net can be found in \cref{tab:arch_nnn_net_sr}.
\end{itemize}
Analogously to image denoising, the $\nnn$ blocks for super-resolution extract $10\times10$ patches with a stride of $5$ and patches are matched to other patches in a $80\times80$ region.

\myparagraph{Training details for super-resolution.}
We follow the training protocol of \citekim.
Our training set consists of 291 images: The 200 images of the BSD500 training set and 91 images from \cite{Yang:2010:ISR}.
In each of the 80 training epochs, we randomly crop $3833$ patches of size $80\times80$ from each image and apply data augmentation by flipping and using a rotation $\in \{\ang{0}, \ang{90}, \ang{180}, \ang{270}\}$.
Our batchsize is 32.
As in \citekim, we use the SGD optimizer with momentum of $0.9$ and a weight decay of $10^{-4}$.
The initial learning rate is set to $0.1$ and decayed by a factor of 10 every 20 epochs.
Like \citekim, we apply gradient clipping to stabilize training.

\begin{table*}[h]
\vspace{1em}
\begin{minipage}[t]{0.46\textwidth}
	\caption{Architecture of the embedding block.}
	\label{tab:arch_distance_net}
	\centering
		\smallskip
	\begin{tabular*}{\linewidth}{@{\extracolsep{\stretch{1}}}lcr @{\extracolsep{\stretch{1}}}}
	\toprule
	Type	 		& Ker., Str., Pad.	& Feat. 	\\
	\midrule
	Input			&							& $8$			\\
	Conv/BN/ReLU 	& $3\times 3, 1, 1$ 				& $64$		\\
	Conv/BN/ReLU 	& $3\times 3, 1, 1$ 				& $64$		\\
	Conv		 	& $3\times 3, 1, 1$ 				& $8$			\\
	\bottomrule
	\end{tabular*}

\end{minipage}
\hfill
\begin{minipage}[t]{0.46\textwidth}
	\caption{Architecture of the block for predicting the temperature parameter.}
	\label{tab:arch_temperature_net}
	\centering
		\smallskip
	\begin{tabular*}{\linewidth}{@{\extracolsep{\stretch{1}}}lcr @{\extracolsep{\stretch{1}}}}
	\toprule	
	Type	 		& Ker., Str., Pad.	& Feat.	\\
	\midrule
	Input			&							& $8$			\\
	Conv/BN/ReLU 	& $3\times 3, 1, 1$ 				& $64$		\\
	Conv/BN/ReLU 	& $3\times 3, 1, 1$ 				& $64$		\\
	Conv		 	& $3\times 3, 1, 1$ 				& $1$			\\
	\bottomrule
	\end{tabular*}
	\end{minipage}
	\end{table*}

\begin{table*}[tb]	
\begin{minipage}[t]{0.62\textwidth}
	\caption{Architecture of the 6 layer DnCNN blocks used for $\nnn$Net for image denoising.}
	\label{tab:arch_dncnn_block}
	\centering
		\smallskip
	\begin{tabular*}{\linewidth}{@{\extracolsep{\stretch{1}}}lcr @{\extracolsep{\stretch{1}}}}
	\toprule
	Type	 		& Ker., Str., Pad.	& Feat. 	\\
	\midrule
	Input			&							& $1$ if first block / $64$ else \\
	Conv/BN/ReLU 	& $3\times 3, 1, 1$ 				& $64$		\\
	Conv/BN/ReLU 	& $3\times 3, 1, 1$ 				& $64$		\\
	Conv/BN/ReLU 	& $3\times 3, 1, 1$ 				& $64$		\\
	Conv/BN/ReLU 	& $3\times 3, 1, 1$ 				& $64$		\\
	Conv/BN/ReLU 	& $3\times 3, 1, 1$ 				& $64$		\\ 
	Conv		 	& $3\times 3, 1, 1$ 				& $1$ if last block / $8$ else \\
	Skip 			&							& 			\\
	\bottomrule
	\end{tabular*}
	\end{minipage}
\hfill
\begin{minipage}[t]{0.3\textwidth}
	\caption{Architecture of $\nnn$Net for image denoising.}
	\label{tab:arch_nnn_net_denoising}
	\centering
		\smallskip
	\begin{tabular*}{\linewidth}{@{\extracolsep{\stretch{1}}}lcr @{\extracolsep{\stretch{1}}}}
	\toprule	
	Type	 		& $\kk$						& Feat.	\\
	\midrule
	Input			&							& $1$			\\
	DnCNN block 	& 			 				& $8$			\\
	$\nnn$ block 	& $7$			 				& $64$		\\
	DnCNN block 	& 			 				& $8$			\\
	$\nnn$ block 	& $7$			 				& $64$		\\
	DnCNN block 	& 			 				& $1$			\\
	\bottomrule
	\end{tabular*}
\end{minipage}
\end{table*}


\begin{table*}[tb]	
\begin{minipage}[t]{0.62\textwidth}
	\caption{Architecture of the 7 layer VDSR blocks used for $\nnn$Net for super resolution.}
	\label{tab:arch_vdsr_block}
	\centering
		\smallskip
	\begin{tabular*}{\linewidth}{@{\extracolsep{\stretch{1}}}lcr @{\extracolsep{\stretch{1}}}}
	\toprule
	Type	 		& Ker., Str., Pad.	& Feat. 	\\
	\midrule
	Input			&							& $1$ if first block / $64$ else \\
	Conv/BN/ReLU 	& $3\times 3, 1, 1$ 				& $64$		\\
	Conv/BN/ReLU 	& $3\times 3, 1, 1$ 				& $64$		\\
	Conv/BN/ReLU 	& $3\times 3, 1, 1$ 				& $64$		\\
	Conv/BN/ReLU 	& $3\times 3, 1, 1$ 				& $64$		\\
	Conv/BN/ReLU 	& $3\times 3, 1, 1$ 				& $64$		\\ 
	Conv/BN/ReLU 	& $3\times 3, 1, 1$ 				& $64$		\\ 
	Conv		 	& $3\times 3, 1, 1$ 				& $1$ if last block / $8$ else \\
	Skip 			&							& 			\\
	\bottomrule
	\end{tabular*}
	\end{minipage}
\hfill
\begin{minipage}[t]{0.3\textwidth}
	\caption{Architecture of $\nnn$Net for super resolution.}
	\label{tab:arch_nnn_net_sr}
	\centering
		\smallskip
	\begin{tabular*}{\linewidth}{@{\extracolsep{\stretch{1}}}lcr @{\extracolsep{\stretch{1}}}}
	\toprule	
	Type	 		& $\kk$						& Feat.	\\
	\midrule
	Input			&							& $1$			\\
	VDSR block 	& 			 				& $8$			\\
	$\nnn$ block 	& $7$			 				& $64$		\\
	VDSR block 	& 			 				& $8$			\\
	$\nnn$ block 	& $7$			 				& $64$		\\
	VDSR block 	& 			 				& $1$			\\
	\bottomrule
	\end{tabular*}
	\end{minipage}
\end{table*} \section{Further Analyses on Gaussian Denoising}
\paragraph{Extended ablation study.}
We first conduct further ablation studies on the task of removing additive white Gaussian noise, extending the results of \cref{sec:experiments_ablation} of the main paper. 
We basically want to discern the effect of adding a \emph{single} KNN or $\nnn$ block, respectively, and the effect of training the baseline model on bigger patch sizes. 
\Cref{tab:ablation_rebuttal_urban_sigma25_70} shows these results.
We make the following observations:
First, for $d=6$ our $\nnn$ block outperforms simple stacking of DnCNN networks as well as using a $\KNN$ block by a significant margin, for both $\sigma=25$ and $70$.
Second, for $d=17$ stacking two full networks performs poorly as training becomes more difficult with the increased depth.
Interestingly, $\nnn$ can remedy some of the ill effects.
Third, increasing the receptive field for the baseline DnCNN using more layers does not always help (\cf 2 $\times$ DnCNN, $d=17$ in \cref{tab:ablation_rebuttal_urban_sigma25_70}).
This is in contrast to our approach that allows increasing the receptive field without having many layers or parameters.
Fourth, training on larger patch sizes does not benefit the baseline DnCNN model, \cf baseline \emph{(i)} in \cref{tab:ablation_urban_sigma25} of the main paper.

\paragraph{Runtime overhead.}
For denoising, the runtime of our full model with $\nnn$ increases by $3.5\times$ compared to the baseline DnCNN model ($d=17$).
For KNN this overhead is $2.5\times$.

\paragraph{Learned strength of the continuous relaxation.}
To look into what the network has learned, we consider the maximum weight $\tilde{w}^j = \max_i \mw_i^j$ (\cf Eq.~\ref{eq:expect_neighbor_from_w}) for the $j^\text{th}$ neighbors volume.
For the first $\nnn$ block of our full network for denoising ($\sigma=25$), we have $\tilde{w}^1 \approx 0.21$ and $\tilde{w}^7 \approx 0.11$ on average, while for the \nth{2} block  $\tilde{w}^1 \approx 0.04$ and $\tilde{w}^7 \approx 0.03$.
Thus the network learned that at a lower level a ``harder'' $\nnn$ selection is beneficial while for higher level features the network tends to learn a more uniform weighting.
A completely uniform weighting would correspond to $\tilde{w}=\nicefrac{1}{224}\approx0.004$.

\begin{table}[tb]
	\vspace{-0.5em}
	\caption{PSNR (dB) on Urban100 for different architectures on gray-scale image denoising. 
	Models are trained on $80\times80$ patches.}
	\label{tab:ablation_rebuttal_urban_sigma25_70}
	\small
	\begin{minipage}{\textwidth}		
		\centering
				\smallskip
		\begin{tabularx}{\linewidth}{ @{\extracolsep{\stretch{1}}} l@{\hspace{1.0cm}} S[table-format=2.2] S[table-format=2.2] @{\hspace{1.0cm}} S[table-format=2.2] S[table-format=2.2] @{\extracolsep{\stretch{1}}}}
		\toprule
		{Model}						  	&  {$d{=}6, \sigma{=}25$} &	{$d{=}6, \sigma{=}70$}	&  {$d{=}17, \sigma{=}25$} &	{$d{=}17, \sigma{=}70$}	\\ 		\midrule
		{1 $\times$ DnCNN} &  29.04	& 23.39 & 29.74	& 24.36 \\ 		{2 $\times$ DnCNN} &  29.59	& 24.19 & 29.48	& 13.77\\ 		{2 $\times$ DnCNN, KNN block ($k{=}7$})	&  29.82 & 24.63 & \bfseries 29.85 & 22.49\\ 		{2 $\times$ DnCNN, $\nnn$ block ($k{=}7$)}	&  \bfseries 29.99 & \bfseries 24.91 & 29.82 & \bfseries 24.18\\ 																\bottomrule
		\end{tabularx}
	\end{minipage}
\end{table}
 \section{Super-Resolution Results}
\Cref{tab:superresolution_ext} shows results for single image super-resolution on two further datasets: 
The full BSD500 validation set consisting of 100 images (BSD100), and Urban100.
We observe a consistent gain of $\nnn$Net compared to the very strong baseline VDSR on both datasets and all super-resolution factors.
Moreover, the performance of the other non-local methods falls short compared to both the baseline and our $\nnn$Net. 
\Cref{fig:sr_urban100_f4} shows visual results for our method and VDSR.
We can see that $\nnn$Net produces sharper details than VDSR, leading to perceptually more pleasing images despite the PSNR values being relatively close.
\begin{table*}[tb]
	\caption{PSNR (dB) values for single image super-resolution on Urban100 and BSD100. WSD-SR does not provide results for BSD100.}
	\label{tab:superresolution_ext}
	\centering
	\footnotesize
	\smallskip
	\begin{tabularx}{\linewidth}{@{}X @{\hspace{1.6cm}} X @{\hspace{0.7cm}} S[table-format=2.2] @{\hspace{0.7cm}} S[table-format=2.2] @{\hspace{0.7cm}} S[table-format=2.2] @{\hspace{0.7cm}} S[table-format=2.2] @{\hspace{0.7cm}} S[table-format=2.2] @{\hspace{0.7cm}} S[table-format=2.2] @{\hspace{0.7cm}} S[table-format=2.2]@{}}
		\toprule
		{Dataset}	 & {}				& {Bicubic} 	& {SelfEx}	&  {WSD-SR} 	& {MemNet}	& {MDSR} 	& {VDSR} 	&  {N$^3$Net}	\\
		\midrule
		\multirow{ 3}{*}{Urban100} & $\times2$ 	& 26.88		& 29.54		& 30.29		& 31.31		& 32.84	& 30.76	& 30.80 \\
		& $\times3$ 							& 24.46		& 26.44		& 26.95		& 27.56		& 28.79	& 27.14	& 27.19 \\
		& $\times4$ 							& 23.14		& 24.79		& 25.16		& 25.50		& 26.67	& 25.18	& 25.23 \\
		\midrule
		\multirow{ 3}{*}{BSD100} & $\times2$  	& 29.56		& 31.18		& {--}			& 32.05		& 32.29	& 31.90	& 31.98 \\
								& $\times3$ 	& 27.21		& 28.29		& {--}			& 28.95		& 29.25	& 28.82	& 28.91 \\
								& $\times4$  	& 25.96		& 26.84		& {--}			& 27.38		& 27.72	& 27.29	& 27.34 \\
		\bottomrule
	\end{tabularx}		
\end{table*}



\begin{figure*}[tb]
\centering
\begin{tabular}{c c c c}
	\begin{subfigure}{0.22\textwidth}
	\centering
	\includegraphics[width=\textwidth]{figures/generated/sr_urban100_rgb_fac4_imgid8_clean_crop.png}
	\caption*{Clean}
	\end{subfigure}
	&
	\begin{subfigure}{0.22\textwidth}
	{\includegraphics[width=\textwidth]{figures/generated/sr_urban100_rgb_fac4_imgid8_lowres_crop.png}}
	\caption*{Bicubic (19.75 dB)}
	\end{subfigure}
	&
	\begin{subfigure}{0.22\textwidth}
	\includegraphics[width=\textwidth]{figures/generated/sr_urban100_rgb_fac4_imgid8_VDSR_crop.png}
	\caption*{VDSR (20.86 dB)}
	\end{subfigure}
	&
	\begin{subfigure}{0.22\textwidth}
	\includegraphics[width=\textwidth]{figures/generated/sr_urban100_rgb_fac4_imgid8_N3Net_crop.png}
	\caption*{NN3D (20.99 dB)}
	\end{subfigure}
	\\[5em]
	\begin{subfigure}{0.22\textwidth}
	\centering
	\includegraphics[width=\textwidth]{figures/generated/sr_urban100_rgb_fac4_imgid12_clean_crop.png}
	\caption*{Clean}
	\end{subfigure}
	&
	\begin{subfigure}{0.22\textwidth}
	{\includegraphics[width=\textwidth]{figures/generated/sr_urban100_rgb_fac4_imgid12_lowres_crop.png}}
	\caption*{Bicubic (22.53 dB)}
	\end{subfigure}
	&
	\begin{subfigure}{0.22\textwidth}
	\includegraphics[width=\textwidth]{figures/generated/sr_urban100_rgb_fac4_imgid12_VDSR_crop.png}
	\caption*{VDSR (23.44 dB)}
	\end{subfigure}
	&
	\begin{subfigure}{0.22\textwidth}
	\includegraphics[width=\textwidth]{figures/generated/sr_urban100_rgb_fac4_imgid12_N3Net_crop.png}
	\caption*{NN3D (23.47 dB)}
	\end{subfigure}
	\\[5em]
	\begin{subfigure}{0.22\textwidth}
	\centering
	\includegraphics[width=\textwidth]{figures/generated/sr_urban100_rgb_fac4_imgid21_clean_crop.png}
	\caption*{Clean}
	\end{subfigure}
	&
	\begin{subfigure}{0.22\textwidth}
	{\includegraphics[width=\textwidth]{figures/generated/sr_urban100_rgb_fac4_imgid21_lowres_crop.png}}
	\caption*{Bicubic (27.65 dB)}
	\end{subfigure}
	&
	\begin{subfigure}{0.22\textwidth}
	\includegraphics[width=\textwidth]{figures/generated/sr_urban100_rgb_fac4_imgid21_VDSR_crop.png}
	\caption*{VDSR (29.01 dB)}
	\end{subfigure}
	&
	\begin{subfigure}{0.22\textwidth}
	\includegraphics[width=\textwidth]{figures/generated/sr_urban100_rgb_fac4_imgid21_N3Net_crop.png}
	\caption*{NN3D (29.10 dB)}
	\end{subfigure}
	\\[5em]
	\begin{subfigure}{0.22\textwidth}
	\centering
	\includegraphics[width=\textwidth]{figures/generated/sr_urban100_rgb_fac4_imgid47_clean_crop.png}
	\caption*{Clean}
	\end{subfigure}
	&
	\begin{subfigure}{0.22\textwidth}
	{\includegraphics[width=\textwidth]{figures/generated/sr_urban100_rgb_fac4_imgid47_lowres_crop.png}}
	\caption*{Bicubic (20.03 dB)}
	\end{subfigure}
	&
	\begin{subfigure}{0.22\textwidth}
	\includegraphics[width=\textwidth]{figures/generated/sr_urban100_rgb_fac4_imgid47_VDSR_crop.png}
	\caption*{VDSR (21.23 dB)}
	\end{subfigure}
	&
	\begin{subfigure}{0.22\textwidth}
	\includegraphics[width=\textwidth]{figures/generated/sr_urban100_rgb_fac4_imgid47_N3Net_crop.png}
	\caption*{NN3D (21.43 dB)}
	\end{subfigure}
	\\[5em]
\end{tabular}
\caption{Super-resolution results (cropped for better display) and PSNR values on four images from Urban100 with a super-resolution factor of 4.}
\label{fig:sr_urban100_f4}
\end{figure*} 
\clearpage
\small
\bibliographystyle{plain}
\bibliography{short,clean,papers,external}

\end{document}
