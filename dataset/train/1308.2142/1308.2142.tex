\documentclass{article}
\bibliographystyle{plain}
\usepackage{array}
\usepackage{graphicx}
\usepackage{float}
\usepackage{enumitem}
\setlist{nolistsep}


\newcounter{customenvs}[section]
\renewcommand{\thecustomenvs}{\thesection.\arabic{customenvs}}

\newcommand{\customenvbegin}[1]{\medskip\refstepcounter{customenvs}\noindent\textbf{#1~\thecustomenvs.~}}
\newcommand{\customenvend}{\medskip}

\newcommand{\namedcustomenvbegin}[2]{\medskip\refstepcounter{customenvs}\noindent\textbf{#1~\thecustomenvs~(#2).~}}

\newenvironment{definition}[1]{\namedcustomenvbegin{Definition}{#1}}{\customenvend}
\newenvironment{refquote}[1]{\namedcustomenvbegin{Quote}{#1}}{\customenvend}

\newenvironment{problem}{\customenvbegin{Problem}}{\customenvend}
\newenvironment{lemma}{\customenvbegin{Lemma}}{\customenvend}
\newenvironment{corollary}{\customenvbegin{Corollary}}{\customenvend}
\newenvironment{theorem}{\customenvbegin{Theorem}}{\customenvend}

\newenvironment{example}{\renewcommand{\plotbegin}{\begin{figure}[ht]}\customenvbegin{Example}}{\customenvend}

\newenvironment{proof}{\medskip\noindent\textbf{Proof.~}}{\medskip}

\floatstyle{ruled}
\newfloat{algfloat}{t}{algfloattmp}
\floatname{algfloat}{Algorithm}

\newcounter{algorithms}[section]
\newenvironment{algorithm}[2]{\begin{algfloat}\caption{#1}\medskip{#2}\renewcommand{\theenumi}{\arabic{enumi}}\renewcommand{\labelenumi}{\theenumi}\begin{enumerate}}{\end{enumerate}\medskip\end{algfloat}}

\newcommand{\subroutine}[1]{\end{enumerate}\medskip\textbf{subroutine~}{#1}\renewcommand{\theenumi}{\Roman{enumi}}\renewcommand{\labelenumi}{\theenumi}\begin{enumerate}}


\newcommand{\keywfont}[1]{{\tt {#1}}}

\newcommand{\job}{\keywfont{\phi}}
\newcommand{\type}{\keywfont{type}}
\newcommand{\prefix}{\keywfont{pre}}
\newcommand{\mrotate}{\keywfont{modelRotate}}
\newcommand{\mimprovedrotate}{\keywfont{improvedModelRotate}}
\newcommand{\satassign}{\keywfont{satAssignment}}

\newcommand{\jobfun}[1]{\job({#1})}
\newcommand{\typefun}[1]{\type({#1})}
\newcommand{\prefixfun}[2]{\prefix({#1,#2})}
\newcommand{\mrotatefun}[2]{\mrotate({#1},{#2})}
\newcommand{\mimprovedrotatefun}[3]{\mimprovedrotate({#1},{#2},{#3})}
\newcommand{\satassignfun}[1]{\satassign({#1})}


\newcommand{\flip}{\keywfont{rotate}}
\newcommand{\flipfun}[2]{\flip({#1},{#2})}

\newcommand{\algtab}{\quad~}
\newcommand{\keyword}[1]{\keywfont{#1}}
\newcommand{\ifthenel}[3]{\keyword{if~}{#1}\keyword{~then~}{#2}\keyword{~else~}{#3}}
\newcommand{\ifthen}[1]{\keyword{if~}{#1}\keyword{~then}}
\newcommand{\submit}[1]{\keyword{submit~}{#1}{~to solver}}
\newcommand{\fordo}[1]{\keyword{for~}{#1}\keyword{~do}}
\newcommand{\elseifthen}[1]{\keyword{else if~}{#1}\keyword{~then}}
\newcommand{\appendto}[2]{\keyword{append~}{#1}\keyword{~to~}#2}

\newcommand{\forever}{\keyword{forever do}}
\newcommand{\sat}{\textbf{satisfiable}}
\newcommand{\unsat}{\textbf{unsatisfiable}}
\newcommand{\wait}{\keyword{wait}}
\newcommand{\return}{\keyword{return}}
\newcommand{\elsekw}{\keyword{else}}
\newcommand{\dokw}{\keyword{do}}
\newcommand{\while}{\keyword{while}}
\newcommand{\main}{\keyword{main}}
\newcommand{\pick}{\keyword{pick}}
 \newcommand{\plotbegin}{\begin{figure}[t]}
\newcommand{\plotend}{\end{figure}}

\newcommand{\plotwidth}{\textwidth}
\newcommand{\plot}[4]{\plotbegin\includegraphics[angle=#4,width=\plotwidth]{#1/#2}\caption{#3}\label{fig:#2}\plotend}
\newcommand{\plotcenter}[4]{\plotbegin\begin{center}\includegraphics[angle=#4]{#1/#2}\caption{#3}\label{fig:#2}\end{center}\plotend}

\newcommand{\duoplotwidth}{.45\textwidth}
\newcommand{\duoplot}[6]{\plotbegin
\begin{tabular}{c@{\hspace{.1\textwidth}}c}
\begin{minipage}[t]{0.45\textwidth}
\includegraphics[angle=#6,width=\plotwidth]{#1/#2}\caption{#3}\label{fig:#2}
\end{minipage}&
\begin{minipage}[t]{0.45\textwidth}
\includegraphics[angle=#6,width=\plotwidth]{#1/#4}\caption{#5}\label{fig:#4}
\end{minipage}
\end{tabular}
\plotend}

\newcommand{\texplotfitwidth}[3]{\plotbegin\resizebox{\plotwidth}{!}{\input{#1/#2}}\caption{#3}\label{fig:#2}\plotend} 
\newcommand{\texplot}[3]{\plotbegin\input{#1/#2}\caption{#3}\label{fig:#2}\plotend} 
 \newcommand{\under}[2]{{#1}^{#2}}
\newcommand{\iup}[2]{{#1}{\mid}_{#2}}
\newcommand{\A}{\rho}
\newcommand{\F}{\mathcal{F}}
\newcommand{\Funder}[1]{\under{\F}{#1}}
\newcommand{\Fiup}[1]{\iup{\F}{#1}}
\newcommand{\propagate}[2]{iup(#1,\,#2)}

\newcommand{\true}{\textbf{true}}
\newcommand{\false}{\textbf{false}}
\newcommand{\resop}{\otimes}

\newcommand{\setnext}{,}
\newcommand{\setopen}{\{}
\newcommand{\setclose}{\}}
\newcommand{\pair}[2]{(#1,#2)}
\newcommand{\kripkenot}[1]{\overline{#1}} 


\newcommand{\xor}{\mathtt{xor}} 
\newcommand{\assoc}{assoc}
\newcommand{\assocs}{assocs}
\newcommand{\posedges}{E_P} \newcommand{\posgraph}[1][\F]{G=(\F,\posedges)}
\newcommand{\flipedges}{E_G} \newcommand{\flipgraph}[1][\F]{G=(\F,\flipedges)}

\newcommand{\citecp}{\cite{DBLP:conf/cp/Wieringa12}}

\author{Siert Wieringa\thanks{The work was financially supported by the Academy of Finland, project 139402} \\\medskip \small{Aalto University, Finland} \\\medskip \small{\texttt{siert.wieringa@aalto.fi}}}
\title{Some notes on model rotation}

\begin{document}
\maketitle

\begin{abstract}
Model rotation is an efficient technique for improving MUS finding algorithms.
In previous work we have studied model rotation as an algorithm that traverses a graph which is induced by the input formula.
This document introduces the notion of blocked edges, which are edges in this graph that can never be traversed.
We show the existence of irredundant CNF formulas in which some clauses are unreachable by model rotation.
Additionally, we prove a conjecture by Belov, Lynce and Marques-Silva.
\end{abstract}

\section{Definitions}

A literal  is a Boolean variable  or its negation .
For any literal  it holds that .
A clause  is a non-empty set of literals, representing the disjunction .
A propositional logic formula  is in \emph{Conjunctive Normal Form} (CNF) if it is a conjunction of disjunctions, i.e. a set of clauses.
Throughout this document the word formula always refers to a formula in CNF.

An assignment  is a set of literals such that if  then .
If  then it is said that literal  is assigned the value \true,~if  then  it is said that  assigned value \false.
Assignment  satisfies clause  if there exists a literal  such that .
An assignment satisfies a formula if it satisfies all clauses in the formula.
An assignment  is a \emph{complete assignment} for a formula  if for all  and all  either  or .
A formula  is \emph{equivalent} to a formula , denoted , if for all assignments  it holds that  satisfies  if and only if  satisfies .

A formula that has no satisfying assignments is called unsatisfiable.
A formula  is \emph{minimal unsatisfiable} if it is unsatisfiable and any subformula  is satisfiable.
A \emph{minimal unsatisfiable subset}\footnote{Alternative names are \emph{minimal unsatisfiable subformula} or \emph{minimal unsatisfiable core} (MUC).} (MUS) of a formula  is a formula  that is minimal unsatisfiable.
The concept can be generalized to include satisfiable formulas by considering \emph{minimal equivalent subsets} (MESes) \cite{DBLP:conf/cp/BelovJLM12} instead.
A MES  is a formula such that  and for all  it holds that  (i.e.\ ).

\begin{definition}{\assoc}
An associated assignment (\assoc) for a clause  is a complete assignment  for the formula  that satisfies the formula  and does not satisfy . Let  be the set of all \assocs~for .
\end{definition}

Note that iff a clause  has an \assoc~(i.e. if ) then  occurs in every MES of .
Such clauses are often referred to as \emph{critical clauses} or \emph{transition clauses} (e.g \cite{DBLP:conf/sat/SilvaL11}).
In this work we will refer to such clauses as critical clauses, or more explicitly as \emph{clauses for which an \assoc~exists}.

In \cite{DBLP:conf/sat/SilvaL11} a technique called \emph{model rotation} was introduced,
which shortly after was improved to \emph{recursive model rotation} \cite{DBLP:conf/fmcad/BelovM11}.
Model rotation is an algorithm that given an \assoc~for a clause attempts to find \assocs~for other clauses by negating a single literal.

\begin{definition}{Rotation function}Let  be a function that negates literal  in assignment , i.e.:

\end{definition}

The pseudocode for a basic destructive algorithm extended with model rotation is shown in Alg.~\ref{alg:modelrotate}.
The model rotation subroutine can be thought of as an algorithm that traverses a graph, which we call the \emph{flip graph} \citecp.

\newcommand{\Fexample}{\F_{fig\ref{fig:flipgraph}}}
\plotcenter{.}{flipgraph}{The \emph{flip graph} for }{0}

\begin{algorithm}{Destructive algorithm with recursive model rotation}{Given an unsatisfiable formula :}\label{alg:modelrotate}
  \item 
  \item \while~
  \item \algtab \pick~a clause 
  \item \algtab \ifthen{ is \sat}
  \item \algtab \algtab ~an assignment satisfying 
  \item \algtab \algtab 
  \item \algtab \algtab 
  \item \algtab \elsekw~
  \item \return~
  \subroutine{}  
  \item \fordo{}
  \item \algtab 
  \item \algtab \ifthen{exactly one clause  is not satisfied by  and }
  \item \algtab\algtab 
  \item \algtab\algtab 
\end{algorithm}

\begin{definition}{Flip graph}For a formula  the flip graph  is a graph which has a vertex for every clause, i.e. .
Each edge  is labelled with the set of literals  such that:

The set of edges  of the flip graph is defined by  iff 
\end{definition}

Even though  iff  in this work the flip graph is considered to be a directed graph.
This is useful for defining the \emph{rotation edges}.

\begin{definition}{Rotation edges}Given a formula , let the sets of possible rotation edges\footnote{Note that the set  corresponds to all pairs of clauses  on which resolution  can be performed without creating a tautology.} , and guaranteed rotation edges  be defined as:

\end{definition}

In Fig.~\ref{fig:flipgraph}~the flip graph for an example formula  is given.
Because there are no two clauses  such that  it holds that the set of possible rotation edges  is equal to the set of all edges  in the flip graph.
However, only the solid edges in the figure belong to the set of guaranteed rotation edges .
The dotted edges are not in the set  because the two outgoing edges from vertex  have the same label .
In \citecp~we prove the following theorem:

\begin{theorem}
\label{th:flipedges}
Let  be an unsatisfiable formula and  the set of guaranteed rotation edges it induces.
If  then for any \assoc~ an assignment  such that  is an \assoc~.
\end{theorem}

This theorem implies that if we find an \assoc~for a clause then model rotation is guaranteed to find an \assoc~for all clauses that are reachable from that clause over edges in .
It is shown in \citecp~that typical formulas used for benchmarking MUS finding algorithms contain large numbers of guaranteed rotation edges.
This means that an upperbound can be computed on the minimum number of calls to a SAT solver needed by Alg.~\ref{alg:modelrotate},
which is typically much smaller than the number of clauses in the formula.
We used this observation to argue about the strength of model rotation.

\section{Blocked rotation edges}
In \citecp~we defined a subset of possible rotation edges  on which rotation is guaranteed to succeed.
Here, we discuss the possible existence of edges in  on which rotation is guaranteed to fail.

\begin{definition}{Blocked rotation edge}An edge  is \emph{blocked} if for all  we have , where  is the literal such that .
\end{definition}

\begin{corollary}If and only if  is a blocked edge then  is a blocked edge.\end{corollary}

Naturally, any edge  such that either  or  is a blocked edge.
However, we will show that blocked edges may also exist between two critical clauses.

\begin{lemma}\label{lemma:bidirblocks}If  and for some literal  it holds that  then the edge  is blocked.
\end{lemma}

\begin{proof}
For all  it holds that  and  satisfies , thus  holds.
But then any assignment  contains  and  and therefore does not satisfy .
It follows that no such assignment can be an \assoc~for .
\end{proof}

Note that Lemma \ref{lemma:bidirblocks} provides a sufficient condition for blocking the edge between two critical clauses  and , but that this is not a necessary condition.
For example, the lemma can be generalized by replacing the literal  with any formula  such that  does not occur in  and .

An interesting observation is that we can create an irredundant formula  with a clause  such that for all  all edges  are blocked.
This means that for this formula model rotation starting at  can never find an \assoc~for any other clause, neither can model rotation starting from any other clause result in an \assoc~for clause .

\begin{example}\label{ex:blockedrotation}
Consider the following satisfiable irredundant formula :

Note that this formula represents four equivalences , ,  and .
Together, these make sure that for all  it holds that the edge  is blocked.
The formula can be made minimal unsatisfiable without breaking this property, for example by adding one clause for each of the three satisfying assignments of this formula:

\end{example}

\section{Proof of a conjecture by Belov et al.}
In \cite{DBLP:journals/aicom/BelovLM12} a conjecture is presented that we prove here.
The conjecture states a property of the \emph{rotation graph}, which was defined alongside the conjecture.
Here we state an equivalent definition for the rotation graph using slightly different notation.

\begin{definition}{Rotation graph}\label{def:rotationgraph}
Let  be an unsatisfiable formula, and let  be the set of clauses in  not satisfied by assignment , i.e. .
The rotation graph  is a directed graph which has a vertex for each complete assignment to the variables of .
There exists an edge  if  for some literal .
\end{definition}

A \emph{witness assignment}, as mentioned in the following quote, is exactly the same as an \assoc.

\begin{refquote}{Conjecture found in \cite{DBLP:journals/aicom/BelovLM12}}\label{quote:conjecture}Let  be a minimally unsatisfiable formula, and let  be the rotation graph of . Then, there exists a witness assignment  such that the traversal of  starting from  visits at least one witness assignment for each clause .
\end{refquote}

The possible existence of clauses that are connected only through blocked edges in the flip graph, as in Example~\ref{ex:blockedrotation}, does not disprove this conjecture.
This is because the traversal of the rotation graph as defined here may pass through assignments  for which , i.e. it may perform rotation through assignments that are not an \assoc~for any clause.

\begin{lemma}\label{lemma:inr}
Let  be an unsatisfiable formula, let  be a complete assignment to the variables of , and let  be an \assoc~for some clause , i.e. .
Either  is an \assoc~for clause , or there exists a literal  such that  where .
\end{lemma}

\begin{proof}
Let  such that .
Such a clause must exists because  is both non-empty and not equal to .
As  satisfies  and  does not, it must hold for some  that  and , hence .
\end{proof}

\begin{lemma}\label{lemma:belovpath}
Let  be an unsatisfiable formula, let  be a complete assignment to the variables of , and let  be a clause such that .
For any clause  such that  there exists a path in the rotation graph starting from the vertex corresponding to assignment  to an \assoc~.
\end{lemma}

\begin{proof}
Let  be some clause  such that .
We will show how to construct a rotation path starting from  that is guaranteed to end in an \assoc~for .
For some  let .
The path begins at the vertex corresponding to assignment .
The path is completed when we reach an assignment  that is an \assoc~for .
By combining Definition \ref{def:rotationgraph} and Lemma \ref{lemma:inr} we may observe that if  is not an \assoc~for  then there exists a literal  such that  for .
Hence, the path can proceed from  to . 
At  we repeat the previous, i.e. either we find that  is an \assoc~for  or we compute the next step in the path.
As one element is removed from  in every step the path is guaranteed to end in an \assoc~for .
\end{proof}

Lemma \ref{lemma:belovpath} states that starting from any complete assignment there exists a path to an \assoc~for any arbitrary critical clause. 
Hence, the conjecture in Quote \ref{quote:conjecture}~must hold.
In fact, we can even strengthen the conjecture to the following corollary.

\begin{corollary}\label{cor:belovstrong}Let  be an unsatisfiable formula, and let  be the rotation graph of . 
Starting from any complete assignment to the variables of  (any vertex in ), there exists a path in  that visits an \assoc~for every clause  such that .
\end{corollary}

Clearly, a variant of model rotation that may traverse all edges in the rotation graph (called unrestricted EMR in \cite{DBLP:journals/aicom/BelovLM12}) can reach an \assoc~for any critical clause in the input formula, starting from any complete assignment.

\section{Conclusion}
We have shown that it is possible to construct an irredundant, or even minimally unsatisfiable, formula in which some clauses are not reachable at all by model rotation.
Furthermore, we have proven a conjecture stated in \cite{DBLP:journals/aicom/BelovLM12}.

\bibliography{modelrotate}
\end{document}
