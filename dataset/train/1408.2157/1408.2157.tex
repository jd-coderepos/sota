\documentclass[a4paper,11pt]{article}
\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[utf8]{inputenc}
\usepackage{cellspace}
\usepackage[small,sc]{caption}
\usepackage{booktabs, multicol, multirow}
\usepackage{enumitem}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{restate}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{conjecture}{Conjecture}
\newtheorem{example}{Example}

\newcommand{\F}{\mathbb{F}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\G}{\mathcal{G}}
\newcommand{\GF}{\mathrm{GF}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\colvec}[1]{\begin{bmatrix}#1\end{bmatrix}} 
\newcommand{\mat}[1]{\mathbf{#1}}
\newcommand{\vect}[1]{\boldsymbol{#1}}
\DeclareMathOperator{\poly}{poly}
\DeclareMathOperator{\diag}{diag}

\setlist[1]{itemsep=-4pt}

\begin{document}

\title{Generating -independent variables in constant time}

\author{
	Tobias Christiani\\
	\small \texttt{tobc@itu.dk}\\
	\small IT University of Copenhagen
	\and
	Rasmus Pagh\\
	\small \texttt{pagh@itu.dk}\\
	\small IT University of Copenhagen
\thanks{The research leading to these results has received funding from the European Research Council under the European Union's Seventh Framework Programme (FP7/2007-2013) / ERC grant agreement no. [614331].}
}

\renewcommand\footnotemark{}

\date{\vspace{-5ex}}

\maketitle

\begin{abstract}
The generation of pseudorandom elements over finite fields is fundamental to the time, space and randomness complexity of randomized algorithms and data structures. 
We consider the problem of generating -independent random values over a finite field  in a word RAM model equipped with constant time addition and multiplication in , and present the first nontrivial construction of a generator that outputs each value in \emph{constant time}, not dependent on~.
Our generator has period length  and uses  bits of space, which is optimal up to a  factor.
We are able to bypass Siegel's lower bound on the time-space tradeoff for \mbox{-independent} functions by a restriction to sequential evaluation.  
\end{abstract}

\section{Introduction}
Pseudorandom generators transform a short random seed into a longer output sequence. 
The output sequence has the property that it is indistinguishable from a truly random sequence by algorithms with limited computational resources. 
Pseudorandom generators can be classified according to the algorithms (distinguishers) that they are able to fool.
An algorithm from a class of algorithms that is fooled by a generator can have its randomness replaced by the output of the generator,
while maintaining the performance guarantees from the analysis based on the assumption of full randomness.
When truly random bits are costly to generate or supplying them in advance requires too much space, a pseudorandom generator can reduce the time, space and randomness complexity of an algorithm.

This paper presents an explicit construction of a pseudorandom generator that outputs a -independent sequence of values in \emph{constant time} per value, not dependent on , on a word RAM~\cite{hagerup1998}. 
The generator works over an arbitrary finite field that allows constant time addition and multiplication over  on the word RAM.

Previously, the most efficient methods for generating -independent sequences were either based on multipoint evaluation of degree  polynomials, or on direct evaluation of constant time hash functions.
Multipoint evaluation has a time complexity of  field operations per value while hash functions with constant evaluation time use excessive space for non-constant  by Siegel's lower bound~\cite{siegel2004}.
We are able to get the best of both worlds: constant time generation and near-optimal seed length and space usage. 

\paragraph{Significance.}
In the analysis of randomized algorithms and in the hashing literature in particular, -independence has been the dominant framework for limited randomness. 
Sums of -independent variables have their th moment identical to fully random variables for  which preserves many properties of full randomness.
For output length , -independence yields Chernoff-Hoeffding bounds~\cite{schmidt1995} and random graph properties~\cite{alon2008},
while -independence suffices to fool  circuits~\cite{braverman2010}.

Our generator is particularly well suited for randomized algorithms with time complexity  that use a sequence of -independent variables of length , for non-constant .
For such algorithms, the generation of -independent variables in constant time by evaluating a hash function over its domain requires space  for some constant . 
In contrast, our generator uses space  to support constant time generation. 
Algorithms for randomized load balancing such as the simple process of randomly throwing  balls into  bins fit the above description and presents an application of our generator.
Using the bounds by Schmidt et al.~\mbox{\cite[Theorem 2]{schmidt1995}} it is easy to show that -independence suffices to obtain a maximal load of any bin of  with high probability.
This guarantee on the maximal load is asymptotically the same as under full randomness. 
Using our generator, we can allocate each ball in constant time using space  compared to the lower bound of  of hashing-based approaches to generating -independence. 
In Section \ref{sec:loadbalancing} we show how our generator improves upon existing solutions to a dynamic load balancing problem.

The generation of pseudorandomness for Monte Carlo experiments presents another application.
Limited independence between Monte Carlo experiments can be shown to yield Chernoff-like bounds on the deviation of an estimator from its expected value. 
Consider a randomized algorithm~ that takes  random elements from  encoded as a string  and returns a value in the interval .    
Let  denote the expectation of the value returned by~ under the assumption that  encodes a truly random input.
Define the estimator

Due to a result by Schmidt et al. \cite[Theorem 5]{schmidt1995}, for every choice of constants ,
it suffices that  encodes a sequence of -independent variables over  to yield the following high probability bound on the deviation of  from .

We hope that our generator can be a useful tool to replace heuristic methods for generating pseudorandomness in applications where theoretical guarantees are important. 
In order to demonstrate the practicality of our techniques, we present experimental results on a variant of our generator in Section \ref{sec:experiments}. 
Our experiments show that -independent values can be generated nearly as fast as output from heuristic pseudorandom generators, even for large .

\paragraph{Methods.}
Our construction is a surprisingly simple combination of bipartite unique neigbor expanders with multipoint polynomial evaluation.
The basic, probabilistic construction of our generator proceeds in two steps: 
First we use multipoint evaluation to fill a table with \mbox{-independent} values from a finite field, using an average of  operations per table entry.
Next we apply a bipartite unique neighbor expander with constant outdegree and with right side nodes corresponding to entries in the table and a left side that is  times larger than the right side.
For each node in the left side of the expander we generate a -independent value by returning the sum of its neighboring table entries.
Our main result stated in Theorem 1 uses the same idea, but instead of relying on a single randomly constructed expander graph, 
we employ a cascade of explicit constant degree expanders and show that this is sufficient for constant time generation.   

\paragraph{Relation to the literature.}
Though the necessary ingredients have been known for around 10 years, we believe that a constant time generator has evaded discovery by residing in a blind spot between the fields of hashing and pseudorandom generators. 
The construction of constant time -independent \emph{hash functions} has proven to be a difficult task, and a fundamental result by Siegel~\cite{siegel2004} showed a time-space tradeoff that require hashing-based generators with sequence length  to use  space for some constant . 
On the other hand, from the point of view of pseudorandom generators, a generator of -independent variables, for non-constant~, can not be used as an efficient method of derandomization: 
A lower bound by Chor et al.~\cite{chor1985} shows that the sample space of such generators must be superpolynomial in their output length. 
Consequently, research shifted towards generators that produce other types of outputs such as biased sequences or almost -independent variables \cite{alon1992, naor1993, goldreich2010}. 

It is relevant to ask whether there already exist constructions of constant time pseudorandom generators on the word RAM that can be used instead of generators that output -independent variables. 
For example, Nisan's pseudorandom generator~\cite{nisan1992} uses constant time to generate a pseudorandom word and has remarkably strong properties: 
Every algorithm running in  that uses  random words can have its random input replaced by the output of a constant time generator with seed length . 
The probability that the outcome of the algorithm differs when using pseudorandomness as opposed to statistical randomness is decreasing exponentially in the seed length. 

In spite of this strong result, there are many natural applications where the restrictions on Nisan's model means that we cannot use his generator directly to replace the use of a -generator. 
An example is the analysis that uses a union bound over all subsets of  words of a randomly generated structure described by  words.
Algorithms shown to be derandomized by Nisan's generator are restricted to one-way access to the output of the generator. 
Therefore the output of Nisan's generator can not be used to derandomize an algorithm that tests for the events of the union bound without using excessive space.
In this case, \mbox{-independence} can directly replace the use of full randomness without changing the analysis.
\subsection{Our contribution}
We present three improved constructions of \emph{-generators}, formally defined in Section~\ref{sec:preliminaries}, that are able to generate a sequence of -independent values over a finite field .
Our results are stated in a word RAM model equipped with constant time addition and multiplication in .     
Our main result is a fully explicit generator:
\begin{theorem}\label{thm:explicit}
For every finite field  with constant time arithmetic there exists a data structure that for every choice of  is an explicit constant time -generator.
The generator has range , period , and seed length, space usage and initialization time .
\end{theorem}
We further investigate how the space usage and seed length may be reduced by employing a probabilistic construction that has a certain probability of error:
\begin{theorem} \label{thm:existence}
For every finite field  with constant time arithmetic and every choice of positive constants ,  there exists a data structure 
that for every choice of  is a constant time -generator with failure probability ,
range~, period , seed length , space usage , and initialization time .
\end{theorem}
Finally, we improve existing -generators with optimal space complexity:
\begin{theorem} \label{thm:fastmultipoint}
For every finite field  that supports computing the discrete Fourier transform of length  in  operations, 
there exists a data structure that, for every choice of  and given a primitive element , 
is an explicit ~time -generator with range , period , seed length , space usage , and initialization time .
\end{theorem}

Table~\ref{tab:results} summarizes our results along with previous methods of generating sequences of -independent values over . 
All the methods output sequences that have a length of at least~.

\begin{table}[htpb]
  \centering
  \small
    \begin{tabular}{lllll}
    \toprule
	{\bf Construction}                        & {\bf Time}               & {\bf Space}                     & {\bf Seed length}    & {\bf Comment}  \\ \midrule
    Polynomials \cite{joffe1974,wegman1981}   &                    &                           &                   & \\
	Multipoint \cite{gathen2013}              &  &                    & 			      & \\
	Multipoint \cite{bostan2005}              &    &                           & 		          & Requires . \\ Siegel \cite{siegel2004}                  &                    &          &                & Probabilistic. \\
	Theorem \ref{thm:explicit}                &                    &                 &     & Explicit.  \\
	Theorem \ref{thm:existence}               &                    &   &                & Probabilistic. \\
	Theorem \ref{thm:fastmultipoint}          &               &                           & 
    & Requires , FFT. \\
   \bottomrule
    \end{tabular}
\caption{
Overview of generators that produce a -independent sequence over a finite field . 
We use  to denote an arbitrary positive constant and  and  to denote, respectively, a primitive element and a -th root of unity of .
The unit for space and seed length is the number of elements of  that need to be stored, i.e., a factor  from the number of bits. 
Probabilistic constructions rely on random generation of objects for which no explicit construction is known, and may fail with some probability.
}
\label{tab:results}
\end{table}

\paragraph{Overview of paper}
In Section \ref{sec:preliminaries} we define \mbox{-generators} and related concepts and review results that lead up to our main results.
Section \ref{sec:explicit} presents the details of our explicit construction of constant time generators. 
In Section \ref{sec:probabilistic} we apply the same techniques with a probabilistic expander construction to obtain generators with improved space and randomness complexity. 
Section \ref{sec:faster} presents an algorithm for evaluating a polynomial over all elements of  that improves existing generators with optimal space.
Section \ref{sec:wordRAM} shows how arithmetic over  can be implemented in constant time on a standard word RAM with integer multiplication and also reviews algorithms and the state of hardware support for .
Section \ref{sec:loadbalancing} applies our generator to improve the time-space tradeoff of previous solutions to a load balancing problem.
Section \ref{sec:experiments} presents experimental results on the generation time of different -generators for a range of values of . 
\section{Preliminaries} \label{sec:preliminaries}
We begin by defining two fundamental concepts:
\begin{definition}
A sequence  of  random variables with finite range  is an \emph{-sequence} if the variables at every set of  positions in the sequence are independent and uniformly distributed over . 
\end{definition}
\begin{definition}
A family of functions  is \emph{-independent} if for every set of  distinct inputs  
it holds that  are independent and uniformly distributed over  when  is selected uniformly at random from . 
We say that a function  selected uniformly at random from  is a \emph{-independent function}.
\end{definition}
We now give a formal definition of the generator data structure. 
\begin{definition}
A \emph{-generator} with range , period  and failure probability  is a data structure with the following properties:
\begin{itemize}
\item[--] It supports an initialization operation that takes a random seed  as input.
\item[--] After initialization it supports an \texttt{emit()} operation that returns a value from . 
\item[--] There exists a set  such that  and conditioned on  the sequence  of values returned by \texttt{emit()} is an -sequence. 
\end{itemize}
A -generator is \emph{explicit} if the initialization and emit operation has time complexity  and the probability of failure is zero. 
We refer to a -generator as a constant time -generator if the \texttt{emit()} operation has time complexity , not dependent on .
\end{definition}

A -generator differs from a data structure for representing a -independent hash function by only allowing sequential access to the underlying -sequence. 
It is this restriction on generators that allows us to obtain a better time-space tradeoff for the problem of generating -independent variables than is possible by using a -independent hash function directly as a generator.  
We are interested in the following parameters of -generators: seed length, period, probability of failure, space needed by the data structure, the time complexity of the initialization operation and the time complexity of a single \texttt{emit()} operation.

\paragraph{Model of computation.}
Our results are stated in the word RAM model of computation with word length  bits. 
In addition to the standard bit manipulation and integer arithmetic instructions, we also assume the ability to perform arithmetic operations  over  in constant time. 
In the context of our results that use abelian groups  we assume that an element of  can be stored in a constant number of words and that addition can be performed in constant time. 

Let  denote a field of cardinality  for  prime and  a positive integer.
Constant time arithmetic in  is supported on a standard word RAM with integer multiplication \cite{granlund1994}. 
Section \ref{sec:wordRAM} presents additional details about the algorithms required to implement finite field arithmetic over  and  and how they relate to a standard word RAM with integer multiplication.
\subsection{-independent functions from the literature} \label{sec:hashing}
We now review the literature on -independent functions and how they can be used to construct -generators.
We distinguish between a -independent function  and a -independent hash function by letting the latter refer to a data structure 
that after initialization supports random access to the -sequence defined by evaluating  over~.  
There exists an extensive literature that focuses on how to construct -independent hash functions that offer a favorable tradeoff between representation space and evaluation time \cite{dietzfelbinger2012}. 
We note that a family of -independent hash functions can be used to construct a -generator by setting the seed to a random function in the family.

\paragraph{Constant time -independent hash functions.}
A fundamental cell probe lower bound by Siegel \cite{siegel2004} shows that a data structure to support constant time evaluation of  on every input in  
cannot use less than  space for some constant . 
This bound holds even for amortized constant evaluation time over functions in the family and elements in the domain.
From Siegel's lower bound, it is clear that we cannot use -independent hash functions directly to obtain a constant time -generator that uses only  words of space.

Known constructions of -independent hash functions with constant evaluation time are based on expander graphs.
Siegel \cite{siegel2004} gave a probabilistic construction of a family of \mbox{-independent} hash functions in the word RAM model based on an iterated product of bipartite expander graphs. 
Thorup \cite{thorup2013} showed that a simple tabulation hash function with high probability yields the type of expander graphs required by Siegel's construction.
Unfortunately only randomized constructions of the expanders required by these hash functions is known, introducing a positive probability of error in \mbox{-generators} based on them.

\paragraph{Polynomials.}
Here we briefly review the classic construction of -independent functions based on polynomials over finite fields.  
\begin{lemma}[Joffe \cite{joffe1974}, Carter and Wegman \cite{wegman1981}] \label{lem:kpoly}
For every choice of finite field  and every , let  be the family of polynomials of degree at most  over .
 is a family of -independent functions.
\end{lemma}

An advantage of using families of polynomials as hash functions is that they use near optimal randomness, allow any choice of , and have no probability of failure. 
It can also be noted that in the case where  and we are restricted to linear space , 
polynomial hash functions evaluated using Horner's scheme are optimal \mbox{-independent} hash functions \cite{larsen2012, siegel2004}.   

Using slightly more space and for sufficiently large , a data structure by Kedlaya and Umans \cite{kedlaya2008} supports evaluation of a polynomial of degree  over .
The space usage and preprocessing time of their data structure is  for constant .
After preprocessing a polynomial , the data structure can evaluate  in an arbitrary point of  using time .         

\paragraph{Multipoint evaluation.}
Using algorithms for multipoint evaluation of polynomials we are able to obtain a \mbox{-generator} with  generation time and space usage that is linear in . 
Multipoint evaluation of a polynomial~ of degree at most  in  arbitrary points of~ has a time complexity of  in the word RAM model that supports field operations~\mbox{\cite[Corollary 10.8]{gathen2013}}. 
Bostan and Schost \cite{bostan2005} mention an algorithm for multipoint evaluation of  over a geometric progression of  elements with running time . 
In order to use this method to construct a -generator with period  
it is necessary to know a primitive element  of  so we can perform multipoint evaluation over . 
Given the prime factorization of  there exists a Las Vegas algorithm for finding  with expected running time ~\mbox{\cite[Chapter 11]{shoup2009}}. 
In the following lemma we summarize the properties of -generators based on multipoint evaluation of polynomials over finite fields.         

\begin{lemma}[{Gathen and Gerhard \cite[Corollary 10.8]{gathen2013}, Bostan and Schost \cite{bostan2005}}] \label{lem:multipoint}
For every finite field  there exists for every  and bijection  an explicit -generator with period  and seed length .
The space required by the generator and the initialization and generation time depends on the choice of  and multipoint evaluation algorithm.
\begin{itemize}
\item[--] For arbitrary choice of  there exists a -generator with generation time , intialization time  and space usage . 
\item[--] Given a primitive element  of  and a bijection  there exists a generator with generation time , initialization time  and space usage .
\end{itemize}
\end{lemma}

\paragraph{Space lower bounds.}
Since randomness can be viewed as a resource like time and space, we are naturally interested in generators that can output long -independent sequences using as few random bits as possible. 
Families of \mbox{-independent functions}  with  and  will trivially have to use at least  random bits --- a bound matched by polynomial hash functions. 
We are often interested in generators with , for example if we wish to use a generator for randomized load balancing in the heavily loaded case. 
A lower bound by Chor et al.~\cite{chor1985} shows that even in this case the minimal seed length required for -independence is  for every .
\subsection{Expander graphs}
All graphs in this paper are bipartite with  vertices on the left side,  vertices on the right side and left outdegree .
Graphs are specified by their edge function  where the notation  is used to denote the set .
Let  be a subset of left side vertices. 
For convenience we use  to denote the neighbors of . 
\begin{definition}
The bipartite graph  is \mbox{\emph{-unique}} (-unique) 
if for every  with  there exists  such that  has a unique neighbor in . 
An expander graph is \emph{explicit} if it has a deterministic description and  is computable in time polynomial in . 
\end{definition}
The performance of our generator constructions are directly tied to the parameters of such expanders. 
In particular, we would like explicit expanders that simultanously have a low outdegree , are highly unbalanced and are -unique for  as close to  as possible.
A direct application of a result by Capalbo et al. \cite[Theorem 7.1]{capalbo2002} together with an equivalence relation between different types of expander graphs from Ta-Shma et al. \cite[Theorem 8.1]{tashma2007} yields explicit constructions of unbalanced unique neighbor expanders.\footnote{We state the results here without the restriction from \cite{capalbo2002} that  and  are powers of two. We do this to simplify notation and it only affects constant factors in our results.}  
\begin{lemma}[Capalbo et al. {\cite[Theorem 7.1]{capalbo2002}}] \label{lem:explicit}
For every choice of  and  there exists a -unique expander with  and . For constant  the expander is explicit. 
\end{lemma}
We note the following simple technique for constructing a larger -unique expander from a smaller -unique expander.
\begin{lemma} \label{lem:stacking}
Let  be a -unique expander with  adjacency matrix .
For any positive integer  define  as the bipartite graph with block diagonal adjacency matrix  with  blocks in the diagonal.
Then  is a -unique expander.
\end{lemma}

\paragraph{From expanders to independence.}
By associating each right vertex in a -unique expander with a position in a -sequence over an abelian group , we can generate a -sequence over .
This approach was pioneered by Siegel and has been used in different constructions of families of -independent hash functions~\cite{siegel2004, thorup2013}.    
\begin{lemma}[Siegel {\cite[Lemma 2.6, Corollary 2.11]{siegel2004}}] \label{lem:expanderhashing}
Let  be a -unique expander and let  be a -independent function with range an abelian group. 
Let  be defined as  

Then  is a -independent function.
\end{lemma}
\section{Explicit constant time generators} \label{sec:explicit}
In this section we show how to obtain a constant time \mbox{-generator} by combining an explicit -generator with a cascading composition of unbalanced unique neighbor expanders. 
Our technique works by generating a small number of highly independent elements in an abelian group and then successively applying constant degree expanders to produce a greater number of less independent elements. 
We continue this process up until the point where the final number of elements is large enough to match the cost of generating the smaller batch of highly independent elements.    

The generator has two components.
The first component is an explicit -generator  with period  and range an abelian group .
The second component is an explicit sequence  of unbalanced unique neighbor expanders.
The expanders are constructed such that the left side of the th expander matches the right side of the th expander.
By Lemma \ref{lem:explicit}, for every choice of imbalance , target independence  and length of the expander sequence  there exists a sequence of expanders with the property that 

for  and .
For constant  each expander in the sequence is explicit.

We now combine the explicit -generator  and the sequence of expanders  to define the -independent function .
Let  and assume for simplicity that  divides . 
For each  we use the technique from Lemma \ref{lem:stacking} to construct a -unique expander .
Let  denote a number in  corresponding to a vertex in the right side of . 
We are now ready to give a recursive definition of .

\begin{lemma}
 is -independent. 
\end{lemma}
\begin{proof}
We proceed by induction on . 
By definition,  is -independent.
Assume by induction that  is -independent.
By definition  is a -unique expander.
Applying Lemma \ref{lem:expanderhashing} we have that  is -independent.
\end{proof}

We will now show that  supports fast sequential evaluation and prove that we can use  to construct an explicit constant time -generator from any explicit \mbox{-generator}, for an appropriate choice of .
Divide the domain of each  evenly into  batches of size  corresponding to each block of the adjacency matrix of  used to construct  and index the batches by . 
In order to evaluate  over batch number  it suffices to know  and the values of  over batch number .
Fast sequential evaluation of  is achieved in the following steps.
First we tabulate the sequence of expanders  such that  can be read in  operations.
Secondly, to evaluate  over batch , we begin by tabulating the output of  over batch  and then successively apply our tabulated expanders to produce tables for the output of  over batch .

Given tables for the sequence of expanders and assuming that the generator underlying  has been initialized, we now consider the average number of operations used per output when performing batch-evaluation of .
The number of values output is .
The cost of emitting  values from  is by definition at most .
The cost of producing tables for the output of  for the current batch is given by  for .
The average number of operations used per output when performing batch-evaluation of  is therefore bounded from above by

The following lemma states that we can obtain a constant time -generator from every explicit -generator by setting  and choosing  to be an appropriately large constant.  
\begin{lemma} \label{lem:general}
Let  be an abelian group with constant time addition. 
Suppose there exists an explicit -generator with range , period  and space usage .
Then there exists a positive constant  such that for every  
there exists an explicit constant time -generator with range , period , and seed length, space usage and initialization time .
\end{lemma}
\begin{proof}
The sequence of expanders  with the properties given in \eqref{eq:expandersequence} exists for  and  and is explicit for  constant.
By inserting  into equation \eqref{eq:averagetime} it can be seen that the average number of operations is constant for  and  with constants that depend on the parameters of the -generator. 
The -generator is initialized by initializing the -generator, finding and tabulating the sequence of expanders and producing the first batch of values, all of which can be done in  time and space.
After initialization, each call to \texttt{emit()} will return a value from the current batch and use a constant number of operations for the task of preparing the next batch of outputs.    
\end{proof}

We now show our main theorem about explicit constant time -generators over finite fields. 
The construction uses an explicit -generator based on multipoint evaluation. 
Combined with the approach of Lemma \ref{lem:general} this yields a near-optimal time-space tradeoff for -generation.
\begin{restate}[Repeated]
For every finite field  with constant time arithmetic there exists a data structure that for every choice of  is an explicit constant time -generator.
The generator has range , period , and seed length, space usage and initialization time .
\end{restate}
\begin{proof}
Fix the choice of finite field . 
By Lemma~\ref{lem:multipoint} there exists an explicit -generator in  for  with period  that uses time  to emit  values.
Fix some constant  and let  denote an explicit sequence of constant degree expanders with the properties given by \eqref{eq:expandersequence}.
The average number of operations per -independent value output by  when performing batch evaluation is given by

Setting  and following the approach of Lemma \ref{lem:general} we obtain a -generator with the stated properties. 
\end{proof}
Based on the discussion in a paper by Capalbo \cite{capalbo2005} that introduces unbalanced unique neighbor expanders for concrete values of  and , it appears likely that the constants hidden in Theorem \ref{thm:explicit} for the current best explicit constructions make our explicit generators unsuited for practical use since  is close to  when  is reasonably small. 
The next section explores how randomly generated unique neighbor expanders can be used to show stronger existence results and yield -generators with tractable constants.  
\section{Constant time generators with optimal seed length} \label{sec:probabilistic}
Randomly constructed expanders of the type used in this paper have stronger properties than known explicit constructions, and can be generated with an overwhelming probability of success.
There is no known efficient algorithm for verifying whether a given graph is a unique neighbor expander.
Therefore randomly generated expanders cannot be used to replace explicit constructions without some probability of failure.

In this section we apply the probabilistic method to show the existence of -generators with better performance characteristics than those based on known explicit constructions of expanders. 
We are able to show the existence of constant time generators with optimal seed length that use  words of space for any constant . 
Furthermore, such generators can be constructed for any choice of constant failure probability . 
The generators we consider in this section use only a single expander graph but are otherwise identical to the generators described in Section \ref{sec:explicit}.
Using a single expander graph suffices for constant time generation because the probabilistic constructions are powerful enough to support an imbalance of  while maintaining constant degree.
This imbalance is enough to amortize the cost of multipoint evaluation in a single expansion step as opposed to the sequence of explicit expanders employed in Theorem \ref{thm:explicit}. 
Our arguments are a straightforward application of the probabilistic method, but we include them for completeness and because we are interested in somewhat nonstandard parameters.

We consider the following randomized construction of a -unique expander . 
For each vertex  in , we add an edge between  and each distinct node of  nodes selected uniformly at random from .  
By a standard argument, the graph can only fail to be unique neighbor expander if there exists a subset  of left hand side vertices with  such that  \cite[Lemma 2.8]{siegel2004}.
In the following we assume that . 

If the expression in the outer parentheses in \eqref{eq:probexpander} can be bounded from above by  for , then the expander exists.
We also note that the randomized expander construction can be performed using -independent variables without changing the result in~\eqref{eq:probexpander}. 
Let  be a number that may depend on  and let  denote an upper bound on the probability that the randomized construction fails. 
By setting  we are able to obtain the following expression for the relation between , the imbalance  and the left outdegree bound .

Equation \eqref{eq:expanderparameters} reveals tradeoffs for the parameters of the randomly constructed -unique expander graphs.
For example, increasing  makes it possible to make the graph more unbalanced while maintaining the same upper bound on the probability of failure . 
The increased imbalance comes at the cost of an increase in , the size of the right side of the graph. 
Similarly it can be seen how increasing  can be used to reduce the probability of error.
Setting the parameters to minimize the space occupied by the expander while maintaining constant outdegree and by extension constant generation time, we obtain Theorem~\ref{thm:existence}.  
\begin{restate}[Repeated]
For every finite field  with constant time arithmetic and every choice of positive constants ,  there exists a data structure 
that for every choice of  is a constant time -generator with failure probability ,
range~, period , seed length , space usage , and initialization time .
\end{restate}
\begin{proof}
Let  be a constant and set .
Choosing  to be a sufficiently large constant (dependent on ), equation \eqref{eq:expanderparameters} shows that 
for every  there exists a -unique expander  with  and .
Using multipoint evaluation, the right side vertices of  can be associated with -independent variables over  using  operations.
By the properties of  and applying Lemma \ref{lem:expanderhashing} we are able to generate batches of -independent variables of size  using  operations.
The seed length of  holds by the observation that randomized construction of the expander only requires -independence.
The  initialization time is obtained by using multipoint evaluation to construct a table for .
\end{proof}
\section{Faster multipoint evaluation for -generators} \label{sec:faster}
This section presents an improved generator based directly on multipoint evaluation of a polynomial hash function  over a finite field.
For our purpose of generating an -sequence from , we are free to choose the order of elements of  in which to evaluate .  
We present an algorithm for the systematic evaluation of  over disjoint size  subsets of  using Fast Fourier Transform (FFT) algorithms.
Our technique yields a -generator over  with generation time , and space usage and seed length that is optimal up to constant factors.
The algorithm depends upon the structure of , similarly to other FFT algorithms over finite fields \cite{bhattacharya2004}. 

The nonzero elements of  form a multiplicative cyclic group  of order . 
The multiplicative group has a primitive element  which generates .

For  that divides , we can construct a multiplicative subgroup  of order  with  as the generating element. 
 contains  distinct elements of . 
Define for , 

Viewed as subsets of  the sets  form an exact cover of . 
We now consider how to evaluate a degree  polynomial  in the points of . The polynomial takes the form

Rewriting the polynomial evaluation over  in matrix notation:

We assume that the coefficients of  and  are given and consider algorithms for efficient evaluation of the matrix-vector product.
The coefficients  for  can be found in  operations and define a polynomial . 
Evaluating  over  corresponds to computing the Discrete Fourier Transform over a finite field.
\begin{restate}[Repeated] 
For every finite field  that supports computing the discrete Fourier transform of length  in~ operations, 
there exists a data structure that, for every choice of  and given a primitive element , 
is an explicit ~time -generator with range , period~, seed length , space usage , and initialization time .
\end{restate}
\begin{proof}
Evaluation of  over  takes  operations by assumption. 
For every batch  starting at , the value of  is stored and used to compute the coefficients of  ing  operations.
\end{proof}
We now discuss the validity of the assumption that we are able to compute the DFT over a finite field in  operations.
Assume that  and that  is known.
If  is highly composite there exist Fast Fourier Transforms for computing \eqref{eq:polymatrix} in  field operations~\cite{duhamel1990}.
If  is not highly composite there exists an algorithm for computing the DFT in equation \eqref{eq:polymatrix} in  operations for fields of cardinality  in our model of computation~\cite{preparata1977}. 
For  this reduces to the desired  operations.
\section{Finite field arithmetic on the word RAM} \label{sec:wordRAM}
Throughout the paper we have used as our model of computation a modified word RAM with constant time arithmetic  over a finite field .
In this section we show how our model relates to the more standard  defined as a word RAM with constant time arithmetic  over the integers  for -bit words \cite{hagerup1998}.

Arithmetic over  for prime  is integer arithmetic modulo . 
We now argue that arithmetic operations over  can be performed in  operations in the multiplication model.
Every integer  can be written on the form  for non-negative integers  with .
Assume that  can be represented in a constant number of words.
The problem of computing  can be solved by an integer division and  operations in the multiplication model due to the identity .
An algorithm by Granlund and Montgomery \cite{granlund1994} computes  for any constant  using  operations in the multiplication model which gives the desired result.

Another finite field of interest is  due to the correspondence between field elements and bit vectors of length .
We will argue that a word RAM model that supports constant time multiplication over  is not unrealistic considering current hardware.
Addition in  has direct support in standard CPU instruction sets through the XOR operation.
A multiplication of two elements  and  in  can be viewed as a two-step process.
First, we perform a carryless multiplication  of the representation of  and  as polynomials in . 
Second, we use a modular reduction to bring the product  back into , similarly to modular arithmetic over . 
Recently, hardware manufacturers have included partial support for multiplication in  with the CLMUL instruction for carryless multiplication \cite{gueron2014}. 
The modular reduction step is performed by dividing  by an irreducible polynomial  and returning the remainder.
Irreducible polynomials  that can be represented as sparse binary vectors with constant weight results in a constant time algorithm for modular reduction as presented by Gueron and Kounavis \cite{gueron2014}.
We briefly introduce the computation underlying the algorithm to show that its complexity depends on the number of {\tt 1}s in the binary representation of .
Let  and  be functions that return the  least, respectively most, significant bits of their argument as represented in .  
The complexity of Gueron and Kounavis' algorithm for modular reduction of  is determined by the complexity of evaluating the expression

Evaluating  and  is standard bit manipulation. 
For  of constant weight, the carryless multiplications denoted by  in equation  can be implemented as a constant number of bit shifts and XORs. 
For every  an irreducible trinomial or pentanomial ( of weight at most 5) has been found~\cite{seroussi1998}.
Together with the hardware support for convolutions this allows us to implement fast multiplication over fields of practical interest. 
\section{A load balancing application} \label{sec:loadbalancing}
We next consider how our new generator yields stronger guarantees for load balancing.
Our setting is motivated by applications such as splitting a set of tasks of unknown duration among a set of  machines, in order to keep the load as balanced as possible.
Once a task is assigned to a machine, it cannot be reassigned, i.e., we do not allow \emph{migration}.
For simplicity we consider the \emph{unweighted} case where we strive to keep the \emph{number} of tasks on each machine low, and we assume that  divides  for some field  with constant time operations on a word RAM.
Suppose that each machine has capacity (e.g.~memory enough) to handle  tasks at once, and that we are given a sequence of  tasks , where we identify each task with its duration (an interval in ).
Now let  and suppose that we use our constant time -generator to determine for each  which machine should handle .
(We emphasize that this is done without knowledge of , and without coordination with the machines.)
Compared to using a fully random choice this has the advantage of requiring only  words of random bits, which in turn may make the algorithm faster if random number generation is a bottleneck.
Yet, we are able to get essentially the same guarantee on load balancing as in the fully random case.
To see this let  be the set of tasks active at time , and let  be the subset of  assigned to machine  using our generator.
We have:
\begin{lemma}\label{lem:error}
For , if  then
.
\end{lemma}
\begin{proof}
Since  we have that the assignment of tasks in  to machines is uniformly random and independent.
This means that the number of tasks assigned to each machine follows a binomial distribution with mean , and we can apply a Chernoff bound of  on the probability that more than  tasks are assigned to a particular machine.
A union bound over all  machines yields the result.
\end{proof}

Lemma~\ref{lem:error} allows us to give a strong guarantee on the probability of exceeding the capacity  of a machine at any time, assuming that the average load is bounded by .
In particular, let  be a set of size at most  such that every workload  is equal to  for some .
The existence of  is guaranteed since the  tasks are intervals, and they have at most  end points.
This means that

so a union bound over  gives


For constant  and whenever  and  we get an error probability that is exponentially small in .
Such a strong error guarantee can not be achieved with known constant time hashing methods~\cite{siegel2004,pagh2008,dietzfelbinger2003,thorup2013} in reasonable space, since they all have an error probability that decreases polynomially with space usage.
Even if explicit constructions for the expanders needed in Siegel's hash functions were found, the resulting space usage would be polynomially higher than with our -generator.
\section{Experiments} \label{sec:experiments}
This section contains experimental results of an implementation of a -generator over . 
There are two main components to the generator: an algorithm for filling a table of size  with -independent variables and a bipartite unbalanced expander graph.

For the first component, we use an implementation of Gao-Mateer's additive FFT \cite[Algorithm 2.]{gao2010}.
Utilizing the Gao-Mateer algorithm we can generate a batch of  elements of an -sequence using space  and  operations on a word RAM that supports arithmetic over .
The additive complexity of the FFT algorithm is  while the multiplicative complexity is .
Addition in  is implemented as an XOR-operation on 64-bit words. 
Multiplication is implemented using the PCLMUL instruction along with the techniques for modular reduction by Gueron et
al. \cite{gueron2014} outlined in Section \ref{sec:wordRAM}.

For the second component we introduce a slightly different type of expander graphs that only work in the special case of
fields of characteristic two. 
Let  be a field of characteristic two and let  be a  adjacency matrix of a graph  where each entry of  is viewed as an element of .    
By a similar argument to the one used in Lemma \ref{lem:expanderhashing} the linear system  defines a -sequence if  is a vector of \mbox{-independent} variables over  and  has row rank at least .
We consider randomized constructions of  over  with at most  \texttt{1}s in each row and row rank at least .
It is easy to see that a matrix  over  with these properties also defines a matrix with the same properties over .
Since -uniqueness of  implies that  has row rank , but not the other way around, 
we are able to obtain better performance characteristics of generators over  by focusing on randomized constructions of .

The matrix  is constructed in the following way.
Independently, for each  sample  integers uniformly with replacement from  and define the th row of  as the vector constructed by taking the zero vector and adding~\texttt{1}s in the  positions sampled for row .
Observe that if  does not have row rank at least  then some non-empty subset of at most  rows of  sum to the zero vector.
In order for a non-empty set of vectors over  to sum to the zero vector, the bit-parity must be even in each of the  positions of the sum. 
The sum of any  rows of  corresponds to a balls and bins process that distributes  balls into  bins, independently and uniformly at random.
Let  be an even number. Then there are  ways of ordering the balls into pairs and the probability that the outcome is equal to any particular pairing is . 
This yields the following upper bound on the probability that a subset of  rows sums to zero: 

A comparison between this bound and the bound for -uniqueness from equation \eqref{eq:probexpander} shows that, for each term in the sum, 
the multiplicative factor applied to the binomial coefficient  is exponentially smaller in  for the bound in \eqref{eq:libound}.

The pair-based approach which yields the bound  overestimates the probability of failure on subsets of size , increasingly as  grows large compared to . 
We therefore introduce a different bound based on the Poisson approximation to the binomial distribution: 
the number of balls in each of the  positions can approximately be modelled as independent Poisson distributed variables \cite[Ch. 5.4]{mitzenmacher2005}. 
The probability that that the parity is even in each of the  positions in a sum of  rows is bounded by

where we use the same approach as Mitzenmacher et al.~\cite{mitzenmacher2014}.
For any given subset of rows of , we are free to choose between the two bounds. 
The probability that a randomly constructed matrix  fails to have rank at least  can be bounded from above using a union bound over subsets of rows of .


We now consider the generation time of our implementation. 
Let  denote the time taken by the FFT algorithm to generate a -independent value and let  denote the time it takes to perform  random accesses in a table of size .  
The time taken to generate a value by the implementation of our generator is then given by

In our experiments, the choice of parameters for the expander graphs were based on a search for the fastest generation time over every combination of imbalance  and outdegree .
Given choices of ,  and independence , the size of the right side of the expander  was increased until existence could be guaranteed by the bound in \eqref{eq:combinedbound}.
The generator in the experiments had the restriction that  and we have measured  assuming that
the expander is read sequentially from RAM. 
The experiments were run on a machine with an Intel Core i5-4570 processor with 6MB cache and 8GB of RAM.

Table \ref{tab:experimentalresults} shows the generation time in nanoseconds per 64-bit output using Horner's scheme, Gao-Mateer's FFT and the implementation of our generator (FFT + Expander).
For the implementation of the generator, we also show the parameters of the randomly generated expander that yielded the fastest generation time among expanders in the search space.

The generation time for Horner's scheme is approximately linear in  and logarithmic in  for the FFT, as predicted by theory. 
The FFT is faster than using Horner's scheme already at  and orders of magnitude faster for large .
Using our implementation of Gao-Mateer's FFT algorithm we are able to evaluate a polynomial of degree  in  points in less than a second. 
The same task takes over an hour when using Horner's rule, even with both algorithms using the same underlying implementation of algebraic operations in the field.

For small values of , our generator is an order of magnitude faster than the FFT and comes close to the performance of the 64-bit C++11 implementation of the popular Mersenne Twister.
Our generator uses 25 nanoseconds to output a 1024-independent value. This is equivalent to an output of over 300MB/s.
The Mersenne Twister uses around 4 nanoseconds to generate a 64-bit value.

In practice, the memory hierarchy appears to be the primary obstacle to maintaining a constant generation time as  increases.
Our generator reads the expander graphs sequentially and performs random lookups into the table of -independent values.
As  grows large, the table can no longer fit into cache and for large imbalance , the expander can no longer be stored in main memory.
Searching a wider range of expander parameters could easily yield a faster generation time, potentially at the cost of a larger imbalance  or higher probability of failure .

\begin{table}[htpb]
	\centering
\begin{tabular}{rrr|rrrrr}
	
	\toprule
    
\multirow{2}{*}{} & \multicolumn{1}{c}{Horner} & \multicolumn{1}{c|}{FFT}  & \multicolumn{5}{c}{FFT + Expander}       \\ 
           
& \multicolumn{1}{c}{ns} &   \multicolumn{1}{c|}{ns}  & \multicolumn{1}{c}{} &  \multicolumn{1}{c}{}    & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}    & \multicolumn{1}{c}{ns}    \\ \midrule 
    &       177 &  243  & 64 &  &  8 &    &  15   \\    
    &       361 &  294  & 64 &  &  8 &    &  16   \\ 
    &       730 &  338  & 64 &  &  8 &    &  19   \\ 
    &      1470 &  375  & 64 &  &  8 &   &  23   \\ 
    &      2950 &  412  & 64 &  &  8 &   &  24   \\ 
   &      5902 &  449  & 64 &  &  8 &   &  25   \\ 
   &     11808 &  487  & 32 &  &  8 &   &  35   \\ 
   &     23627 &  523  & 64 &  & 16 &   &  43   \\ 
   &     47183 &  561  & 32 &  & 16 &   &  54   \\ 
   &     94429 &  599  & 64 &  &  8 &   &  68   \\ 
   &    188258 &  638  & 64 &  &  8 &   &  69   \\ 
   &    376143 &  678  & 64 &  &  8 &   &  77   \\ 
   &    751781 &  719  & 64 &  &  8 &   &  85   \\ 
   &   1505016 &  765  & 64 &  &  8 &   &  93   \\ 
   &   3015969 &  808  & 32 &  &  8 &   & 110   \\ 
   &   6082313 &  864  & 64 &  & 16 &   & 175   \\ \bottomrule

\iffalse
   &  12161688 &  943  &    &          &    &             &       \\            
   &  24256125 & 1024  &    &          &    &             &       \\          
   &  48490250 & 1110  &    &          &    &             &       \\          
   &  96996000 & 1237  &    &          &    &             &       \\           
   & 193845000 & 1310  &    &          &    &             &       \\ 
   & 387528000 & 1387  &    &          &    &             &       \\ 
\fi
	\end{tabular}
\caption{Generation time in nanoseconds per 64-bit value using Horner's scheme, Gao-Mateer's FFT and an implementation of our constant-time generator}
\label{tab:experimentalresults}
\end{table}

\section*{Acknowledgment}
We are grateful to Martin Dietzfelbinger who gave feedback on an early version of the paper, allowing us to significantly enhance the presentation.

\bibliographystyle{IEEEtran}
\bibliography{focs}
\end{document}
