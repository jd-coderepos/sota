
\documentclass{article} \usepackage{iclr2020_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\usepackage{enumitem}
\usepackage{times}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{algorithm}
\usepackage{tipa}
\usepackage[noend]{algpseudocode}
\usepackage{makecell}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{subfig}
\usepackage{booktabs}
\usepackage{authblk}
\captionsetup[table]{skip=0pt}
\usepackage{soul}
\usepackage[font=small,labelfont=bf,tableposition=top]{caption}
\usepackage{etoolbox,lipsum}
\algrenewcommand\alglinenumber[1]{\footnotesize #1}



\title{FasterSeg: Searching for Faster Real-time Semantic Segmentation}





\newcommand*\samethanks[1][\value{footnote}]{\footnotemark[#1]}
\author{\textbf{Wuyang Chen$^1$\thanks{Work done during the first two authors' research internships with Horizon Robotics Applied AI Lab.} , Xinyu Gong$^1$\samethanks , Xianming Liu$^2$, Qian Zhang$^2$, Yuan Li$^2$, Zhangyang Wang$^1$}\\ \vspace{-0.8em}
$^1$Department of Computer Science and Engineering, Texas A\&M University\\
$^2$Horizon Robotics Inc.\\
\texttt{{\small \{wuyang.chen,xy\_gong,atlaswang\}@tamu.edu}} \\
\texttt{{\small \{xianming.liu,qian01.zhang,yuan.li\}@horizon.ai}}\\
\texttt{{\small \url{https://github.com/TAMU-VITA/FasterSeg}}}
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}

\maketitle




\begin{abstract}
We present \textbf{FasterSeg}, an automatically designed semantic segmentation network with not only state-of-the-art performance but also faster speed than current methods. Utilizing neural architecture search (NAS), FasterSeg is discovered from a novel and broader search space
integrating
multi-resolution branches, that has been recently found to be vital in manually designed segmentation models. 
To better calibrate the balance between the goals of high accuracy and low latency, we propose a decoupled and fine-grained latency regularization, that effectively overcomes our observed phenomenons that the searched networks are prone to ``collapsing'' to low-latency yet poor-accuracy models. 
Moreover, we seamlessly extend FasterSeg to a new collaborative search (co-searching) framework, simultaneously searching for a teacher and a student network in the same single run. The teacher-student distillation further boosts the student model's accuracy. Experiments on popular segmentation benchmarks demonstrate the competency
of FasterSeg. For example, FasterSeg can run over 30\% faster than the closest manually designed competitor on Cityscapes, while maintaining comparable accuracy.
\end{abstract}\vspace{-0.5em}

\section{Introduction}\vspace{-0.3em}

Semantic segmentation predicts pixel-level annotations of different semantic categories for an image. Despite its performance breakthrough thanks to the prosperity of convolutional neural networks (CNNs) \citep{long2015fully}, as a dense structured prediction task, segmentation models commonly suffer from heavy memory costs and latency, often due to stacking convolutions and aggregating multiple-scale features, as well as the increasing input image resolutions. However, recent years witness the fast-growing demand for real-time usage of semantic segmentation, \textit{e.g.}, autonomous driving. Such has motivated the enthusiasm on designing low-latency, more efficient segmentation networks, without sacrificing accuracy notably \citep{zhao2018icnet,yu2018bisenet}.



The recent success of neural architecture search (NAS) algorithms has shed light on the new horizon in designing better semantic segmentation models, especially under latency of other resource constraints. Auto-DeepLab \citep{liu2019auto} first introduced network-level search space to optimize resolutions (in addition to cell structure) for segmentation tasks. \citet{zhang2019customizable} and \citet{li2019partial} adopted pre-defined network-level patterns of spatial resolution, and searched for operators and decoders with latency constraint. Despite a handful of preliminary successes, we observe that the successful human domain expertise in designing segmentation models appears to be not fully integrated into NAS frameworks yet. For example, human-designed architectures for real-time segmentation \citep{zhao2018icnet,yu2018bisenet} commonly exploit multi-resolution branches with proper depth, width, operators, and downsample rates, and find them contributing vitally to the success: such flexibility has not been unleashed by existing NAS segmentation efforts. Furthermore, the trade-off between two (somewhat conflicting) goals, \textit{i.e.}, high accuracy and low latency, also makes the search process unstable and prone to ``bad local minima'' architecture options. 




As the well-said quote goes: \textit{``those who do not learn history are doomed to repeat it''}. Inheriting and inspired by the successful practice in hand-crafted efficient segmentation, we propose a novel NAS framework dubbed \textbf{FasterSeg}, aiming to achieve extremely fast inference speed and competitive accuracy. We designed a special search space capable of supporting optimization over multiple branches of different resolutions, instead of a single backbone. These searched branches are adaptively aggregated for the final prediction. To further balance between accuracy versus latency and avoiding collapsing towards either metric (\textit{e.g.}, good latency yet poor accuracy), we design a decoupled and fine-grained latency regularization, that facilitates a more flexible and effective calibration between latency and accuracy. Moreover, our NAS framework can be easily extended to a collaborative search (co-searching), \textit{i.e.}, jointly searching for a complex teacher network and a light-weight student network in a single run, whereas the two models are coupled by feature distillation in order to boost the student's accuracy. We summarize our main contributions as follows:
\begin{itemize}
\vspace{-0.7em}
    \item A novel NAS search space tailored for real-time segmentation, where multi-resolution branches
can be flexibility searched and aggregated.
    \vspace{-0.3em}
    \item A novel decoupled and fine-grained latency regularization, that successfully alleviates the ``architecture collapse'' problem in the latency-constrained search.
    \vspace{-0.3em}
    \item A novel extension to teacher-student co-searching for the first time, where we distill the teacher to the student for further accuracy boost of the latter.
    \vspace{-0.3em}
    \item Extensive experiments demonstrating that FasterSeg achieves extremely fast speed (over 30\% faster than the closest manually designed competitor on CityScapes) and maintains competitive accuracy.
    \vspace{-0.8em}
\end{itemize}\vspace{-0.5em}


\section{Related Work}\vspace{-0.7em}

Human-designed CNN architectures achieve good accuracy performance nowadays \citep{he2016deep,chen2018encoder,wang2019deep,sun2019deep}. However, designing architectures to balance between accuracy and other resource constraints (latency, memory, FLOPs, \textit{etc.}) requires more human efforts. To free human experts from this challenging trade-off, neural architecture search (NAS) has been recently introduced and drawn a booming interest \citep{zoph2016neural,brock2017smash,pham2018efficient,liu2018progressive,chen2018searching,bender2018understanding,chen2018joint,gong2019autogan}.
These works optimize both accuracy and resource utilization, via a combined loss function \citep{wu2019fbnet}, or a hybrid reward signal for policy learning \citep{tan2019mnasnet,cheng2018instanas}, or a constrained optimization formulation \citep{dai2019chamnet}.



Most existing resource-aware NAS efforts focus on classification tasks, while semantic segmentation has higher requirements for preserving details and rich contexts, therefore posing more dilemmas for efficient network design. Fortunately, previous handcrafted architectures for real-time segmentation have identified several consistent and successful design patterns. ENet \citep{paszke2016enet} adopted early downsampling, and ICNet \citep{zhao2018icnet} further incorporated feature maps from multi-resolution branches under label guidance. BiSeNet \citep{yu2018bisenet} fused a context path with fast downsampling and a spatial path with smaller filter strides.
More works target on segmentation efficiency in terms of computation cost \citep{he2019knowledge,marin2019efficient} and memory usage \citep{chen2019collaborative}.
Their multi-resolution branching and aggregation designs ensure \textbf{sufficiently large receptive fields} (contexts) while preserving \textbf{high-resolution fine details}, providing important clues on how to further optimize the architecture.

There have been recent studies that start pointing NAS algorithms to segmentation tasks. Auto-DeepLab \citep{liu2019auto} pioneered in this direction by searching the cells and the network-level downsample rates, to flexibly control the spatial resolution changes throughout the network. \citet{zhang2019customizable} and \citet{li2019partial} introduced resource constraints into NAS segmentation. A multi-scale decoder was also automatically searched \citep{zhang2019customizable}. 
However, compared with manually designed architectures, those search models still follow a single-backbone design and did not fully utilize the prior wisdom (\textit{e.g.}, multi-resolution branches) in designing their search spaces.

Lastly, we briefly review knowledge distillation \citep{hinton2015distilling}, that aims to transfer learned knowledge from a sophisticated teacher network to a light-weight student, to improve the (more efficient) student's accuracy. For segmentation, \citet{liu2019structured} and \citet{nekrasov2019fast} proposed to leverage knowledge distillation to improve the accuracy of the compact model and speed-up convergence. There was no prior work in linking distillation with NAS yet, and we will introduce the extension of FasterSeg by integrating teacher-student model collaborative search for the first time.\vspace{-0.5em}




\section{FasterSeg: Faster Real-time Segmentation}\vspace{-1em}

Our FasterSeg is discovered from an efficient and multi-resolution search space inspired by previous manual design successes. 
A fine-grained latency regularization is proposed to overcome the challenge of ``architecture collapse'' \citep{cheng2018instanas}. We then extend our FasterSeg to a teacher-student co-searching framework, further resulting in a lighter yet more accurate student network. \vspace{-1em}




\subsection{Efficient Search Space with Multi-Resolution Branching}\vspace{-0.5em}



The core motivation behind our search space is to search multi-resolution branches with overall low latency, which has shown effective in previous manual design works \citep{zhao2018icnet,yu2018bisenet}. Our NAS framework automatically selects and aggregates branches of different resolutions, based on efficient cells with searchable superkernels. \vspace{-1.3em}

\begin{figure}[ht]
\includegraphics[scale=0.3]{images/supernet.pdf}
\centering \vspace{-1em}
\caption{The multi-resolution branching search space for FasterSeg, where we aim to optimize multiple branches with different output resolutions. These outputs are progressively aggregated together in the head module. Each cell is individually searchable and may have two inputs and two outputs, both of different downsampling rates ($s$). Inside each cell, we enable searching for expansion ratios within a single superkernel. 
}
\label{fig:supernet}
\end{figure}



\begin{wrapfigure}{r}{60mm}
\vspace{-2em}
\begin{center}
	\label{subfig:icnet}
	\includegraphics[width=0.38\textwidth]{images/icnet.pdf}
\hfill
	\label{subfig:bisenet}
	\includegraphics[width=0.43\textwidth]{images/bisenet.pdf}
\caption{{\small Our multi-resolution search space covers existing manual designs for real-time segmentation (unused cells omitted). Top: ICNet \citep{zhao2018icnet}. Bottom: BiSeNet \citep{yu2018bisenet}}}\label{fig:icnet_bisenet}
\vspace{-2em}
\end{center}
\end{wrapfigure}
\vspace{-1.5em}

\subsubsection{Searchable Multi-resolution Branches}\vspace{-0.5em}

Inspired by \citep{liu2019auto}, we enable searching for spatial resolutions within the $L$-layer cells (Figure \ref{fig:supernet}), where each cell takes inputs from two connected predecessors and outputs two feature maps of different resolutions. Hand-crafted networks for real-time segmentation found multi-branches of different resolutions to be effective \citep{zhao2018icnet,yu2018bisenet}. However, architectures explored by current NAS algorithms are restricted to a single backbone.

Our goal is to select $b$ $(b > 1)$ branches of different resolutions in this $L$-layer framework. Specifically, we could choose $b$ different final output resolutions for the last layer of cells, and decode each branch via backtrace (section \ref{sec:decoding}).
This enables our NAS framework to explore $b$ individual branches with different resolutions, which are progressively ``learned to be aggregated'' by the head module (Figure \ref{fig:supernet}).

We follow the convention to increase the number of channels at each time of resolution downsampling. To enlarge the model capacity without incurring much latency, we first downsample the input image to $\frac{1}{8}$ original scale with our stem module, and then set our searchable downsample rates $s \in \{8, 16, 32\}$. Figure \ref{fig:icnet_bisenet} shows that our multi-resolution search space is able to cover existing human-designed networks for real-time segmentation. See Appendix \ref{app:branch_selection_mnasnet} for branch selection details.


\subsubsection{Choosing Efficient operators with large Receptive Fields}


As we aim to boost the inference latency, the speed of executing an operator is a direct metric (rather than indirect metrics like FLOPs) for selecting operator candidates $\mathcal{O}$. Meanwhile, as we previously discussed, it is also important to ensure sufficiently large receptive field for spatial contexts. 
We analyze typical operators, including their common surrogate latency measures (FLOPs, parameter numbers), and their real-measured latency on an NVIDIA 1080Ti GPU with TensorRT library, and their receptive fields, as summarized in Table \ref{table:ops}.


Compared with standard convolution, group convolution is often used for reducing FLOPs and number of parameters \citep{sandler2018mobilenetv2,ma2018shufflenet}. Convolving with two groups has the same receptive field with a standard convolution but is 13\% faster, while halving the parameter amount (which might not be preferable as it reduces the model learning capacity). 
Dilated convolution has an enlarged receptive field and is popular in dense predictions \citep{chen2018encoder,dai2017deformable}. However, as shown in Table \ref{table:ops} (and as widely acknowledged in engineering practice), dilated convolution (with dilation rate 2) suffers from dramatically higher latency, although that was not directly reflected in FLOPs nor parameter numbers. In view of that, we design a new variant called ``zoomed convolution'', where the input feature map is sequentially processed with bilinear downsampling, standard convolution, and bilinear upsampling. This special design enjoys 40\% lower latency and 2 times larger receptive field compared to standard convolution. 
Our search space hence consists of the following operators:\vspace{-0.9em}
\begin{itemize}
    \begin{multicols}{3}
    \item skip connection
    \item 3$\times$3 conv.
    \item 3$\times$3 conv. $\times 2$
    \end{multicols} \vspace{-1.5em}
    \item ``zoomed conv.'': bilinear downsampling + 3$\times$3 conv. + bilinear upsampling\vspace{-0.5em}
    \item ``zoomed conv. $\times 2$'':  bilinear downsampling + 3$\times$3 conv. $\times 2$ + bilinear upsampling
\end{itemize}\vspace{-0.5em}


\begin{wraptable}{r}{90mm}
\vspace{-1.5em}
\scriptsize
\begin{center}
\caption{Specifications of different convolutions. Latency is measured using an input of size 1$\times$256$\times$32$\times$64 on 1080Ti with TensorRT library. Each operator only contains one convolutional layer. The receptive field (RF) is relatively compared with the standard convolution (first row).}
\begin{tabular}{ccccc}
\toprule
Layer Type & Latency (ms) & FLOPs (G) & Params (M) & RF* \\ \midrule
conv. & $0.15$ & $1.21$ & $0.59$ & $1$ \\
conv. group2 & $0.13$ ($-13\%$) & $0.60$ ($-50\%$) & $0.29$ (\textcolor{red}{$-51\%$}) & $1$ \\
conv. dilation2 & $0.25$ (\textcolor{red}{$+67\%$}) & $1.10$ ($-9\%$) & $0.59$ & $2$ \\
zoomed conv. & $0.09$ (\textcolor{green}{$-40\%$}) & $0.30$ ($-75\%$) & $0.59$ & $2$ \\ \bottomrule
\end{tabular}\label{table:ops}
\end{center}
\vspace{-1em}
\end{wraptable}

As mentioned by \citet{ma2018shufflenet}, network fragmentation can significantly hamper the degree of parallelism, and therefore practical efficiency. Therefore, we choose a sequential search space (rather than a directed acyclic graph of nodes \citep{liu2018darts}), \textit{i.e.}, convolutional layers are sequentially stacked in our network. In Figure \ref{fig:supernet}, each cell is differentiable \citep{liu2018darts,liu2019auto} and will contain only one operator, once the discrete architecture is derived (section \ref{sec:decoding}). It is worth noting that we allow each cell to be individually searchable across the whole search space.\vspace{-0.5em}


\subsubsection{Searchable Superkernel for Expansion Ratios}
We further give each cell the flexibility to choose different channel expansion ratios. In our work, we search for the width of the connection between successive cells.
That is however non-trivial due to the exponentially possible combinations of operators and widths.
To tackle this problem, we propose a differentiably searchable superkernel, \textit{i.e.}, directly searching for the expansion ratio $\chi$ within a single convolutional kernel which supports a set of ratios $\mathcal{X} \subseteq N^+$. Inspired by \citep{yu2018slimmable} and \citep{stamoulis2019single}, from slim to wide our connections incrementally take larger subsets of input/output dimensions from the superkernel. During the architecture search, for each superkernel, only one expansion ratio is sampled, activated, and back-propagated in each step of stochastic gradient descent. This design contributes to a simplified and memory-efficient super network and is implemented via the renowned ``Gumbel-Softmax'' trick (see Appendix \ref{app:expansion_ratio} for details).

To follow the convention to increase the number of channels as resolution downsampling, in our search space we consider the
$\mathrm{width} = \chi \times s$, where $s \in \{8, 16, 32\}$. We allow connections between each pair of successive cells flexibly choose its own expansion ratio, instead of using a unified single expansion ratio across the whole search space.\vspace{-0.5em}

\subsubsection{Continuous Relaxation of Search Space}\label{sec:differentiable_space}\vspace{-0.5em}
Denote the downsample rate as $s$ and layer index as $l$. To facilitate the search of spatial resolutions, we connect each cell with two possible predecessors' outputs with different downsample rates:\vspace{-0.3em}
\begin{equation}
    \overline{I}_{s, l} = \beta^0_{s, l}\overline{O}_{\frac{s}{2}\shortrightarrow s, l-1} + \beta^1_{s, l}\overline{O}_{s\shortrightarrow s, l-1}
    \label{eq:cell_input}
\end{equation}
Each cell could have at most two outputs with different downsample rates into its successors:\vspace{-0.4em}
\begin{equation}
\begin{split}
\vspace{-0.5em}
    \overline{O}_{s\shortrightarrow s, l} = \sum_{k=1}^{|\mathcal{O}|}\alpha^k_{s, l}O^k_{s\shortrightarrow s, l}(\overline{I}_{s, l}, \chi^j_{s, l}, \mathrm{stride}=1) \\ 
    \overline{O}_{s\shortrightarrow 2s, l} = \sum_{k=1}^{|\mathcal{O}|}\alpha^k_{s, l}O^k_{s\shortrightarrow 2s, l}(\overline{I}_{s, l}, \chi^j_{s, l}, \mathrm{stride}=2).
\end{split}
\label{eq:cell_output}
\end{equation}
The expansion ratio $\chi^j_{s, l}$ is sampled via ``Gumbel-Softmax'' trick according to $p(\chi=\chi^j_{s, l}) = \gamma^j_{s, l}$. Here, $\alpha$, $\beta$, and $\gamma$ are all normalized scalars, associated with each operator $O^k \in \mathcal{O}$, each predecessor's output $\overline{O}_{l-1}$, and each expansion ratio $\chi \in \mathcal{X}$, respectively (Appendix \ref{app:abc}). They encode the architectures to be optimized and derived.\vspace{-1em}


\subsection{Regularized Latency Optimization with Finer Granularity}

\begin{wrapfigure}{r}{50mm}
\vspace{-3.2em}
\begin{center}
\includegraphics[scale=0.33]{images/lookup_table_corrcoef.pdf}
\end{center}
\vspace{-1.5em}
\caption{Correlation between network latency and its estimation via our latency lookup table (linear coefficient: 0.993). Red line indicates ``$y = x$''.}
\vspace{-1em}
\label{fig:lookup_table}
\end{wrapfigure}

Low latency is desirable yet challenging to optimize. Previous works \citep{cheng2018instanas,zhang2019customizable} observed that during the search procedure, the supernet or search policy often fall into bad ``local minimums'' where the generated architectures are of extremely low latency but with poor accuracy, especially in the early stage of exploration. In addition, the searched networked tend to use more skip connections instead of choosing low expansion ratios \citep{shaw2019squeezenas}. This problem is termed as \textit{``architecture collapse''} in our paper. The potential reason is that, finding architectures with extremely low latency (\textit{e.g.} trivially selecting the most light-weight operators) is significantly easier than discovering meaningful compact architectures of high accuracy.

To address this ``architecture collapse'' problem, we for the first time propose to leverage a fine-grained, decoupled latency regularization. We first achieve the continuous relaxation of latency similar to the cell operations in section \ref{sec:differentiable_space}, via replacing the operator $O$ in Eqn. \ref{eq:cell_input} and \ref{eq:cell_output} with the corresponding latency. We build a latency lookup table that covers all possible operators to support the estimation of the relaxed latency. Figure \ref{fig:lookup_table} demonstrates the high correlation of 0.993 between the real and estimated latencies (see details in appendix \ref{app:latency_estimation}).

\begin{wraptable}{r}{56mm}
\vspace{-1.2em}
\footnotesize
\begin{center}
\caption{Supernet's sensitivity to latency under different granularities. Input size: (1, 3, 1024, 2048).}
\begin{tabular}{cc}\toprule
Granularity & $\Delta \mathrm{Latency}$ (ms) \\ \midrule
$O$ (operator) & 10.42 \\
$s$ (downsample rate) & 0.01 \\
$\chi$ (expansion ratio) & 5.54 \\ \bottomrule
\end{tabular}\label{table:arch_latency}
\end{center}\vspace{-1.2em}
\end{wraptable}

We argue that the core reason behind the ``architecture collapse'' problem is the different sensitivities of supernet to operator $O$, downsample rate $s$, and expansion ratio  $\chi$. Operators like ``3$\times$3 conv. $\times 2$'' and ``zoomed conv.'' have a huge gap in latency. Similar latency gap (though more moderate) exists between slim and wide expansion ratios. However, downsample rates like ``8'' and ``32'' do not differ much, since resolution downsampling also brings doubling of the number of both input and output channels.

We quantitatively compared the influence of $O$, $s$, and $\chi$ towards the \underline{supernet latency}, by adjusting one of the three aspects and fixing the other two. Taking $O$ as the example, we first uniformly initialize $\beta$ and $\gamma$, and calculate $\Delta \mathrm{Latency}(O)$ as the gap between the supernet which dominantly takes the slowest operators and the one adopts the fastest.
Similar calculations were performed for $s$ and $\chi$. Values of $\Delta \mathrm{Latency}$ in Table \ref{table:arch_latency} indicate the high sensitivity of the supernet's latency to operators and expansion ratios, while not to resolutions. Figure \ref{fig:search_curve}(a) shows that the unregularized latency optimization will bias the supernet towards light-weight operators and slim expansion ratios to quickly minimize the latency, ending up with problematic architectures with low accuracy.

Based on this observation, we propose a regularized latency optimization leveraging different granularities of our search space. We decouple the calculation of supernet's latency into three granularities of our search space ($O, s, \chi$), and regularize each aspect with a different factor:
\begin{equation}
    \mathrm{Latency}(O,s,\chi) = w_1 \mathrm{Latency}(O|s,\chi) + w_2 \mathrm{Latency}(s|O,\chi) + w_3 \mathrm{Latency}(\chi|O,s)
\end{equation}
where we by default set $w_1$ = 0.001, $w_2$ = 0.997, $w_3$ = 0.002\footnote{These values are obtained by solving equations derived from Table \ref{table:arch_latency} in order to achieve balanced sensitivities on different granularities: $10.42 \times w_1 = 0.01 \times w_2 = 5.54 \times w_1$, s.t. $w_1 + w_2 + w_3 = 1$.}. This decoupled and fine-grained regularization successfully addresses this ``architecture collapse'' problem, as shown in Figure \ref{fig:search_curve}(b).


\begin{figure}[ht]
\vspace{-1em}
\begin{center}
\subfloat[Naive latency optimization.]{
	\includegraphics[width=0.45\textwidth]{images/search_curve_bad.pdf} }\hfill
\subfloat[Proposed fine-grained latency regularization.]{
	\includegraphics[width=0.45\textwidth]{images/search_curve.pdf} } 
\vspace{-0.5em}
\caption{Comparing mIoU (\%) and latency (ms)  between supernets. The search is conducted on the Cityscapes training set and mIoU is measured on the validation set.}
\vspace{-1em}
\label{fig:search_curve}
\end{center}
\end{figure}


\subsection{Teacher/Student Co-searching for Knowledge Distillation}\label{sec:cosearch_distillation}

\begin{wrapfigure}{r}{50mm}
\vspace{-2em}
\begin{center}
\includegraphics[scale=0.4]{images/cosearch.pdf}
\end{center}
\vspace{-1em}
\caption{Our co-searching framework, which optimizes two architectures during search (left orange) and distills from a complex teacher to a light student during training from scratch (right green).}
\vspace{-1em}
\label{fig:cosearch}
\end{wrapfigure}

Knowledge Distillation is an effective approach to transfer the knowledge learned by a large and complex network (teacher $\mathcal{T}$) into a much smaller network (student $\mathcal{S}$). In our NAS framework, we can seamlessly extend to teacher-student co-searching, \textit{i.e.}, collaboratively searching for two networks in a single run (Figure \ref{fig:cosearch}). Specifically, we search a complex teacher and light-weight student simultaneously via adopting \textbf{two sets of architectures in one supernet}: ($\alpha_\mathcal{T}, \beta_\mathcal{T}$)
and ($\alpha_\mathcal{S}, \beta_\mathcal{S}, \gamma_\mathcal{S}$).
Note that the teacher does not search the expansion ratios and always select the widest one.

This extension does not bring any overhead in memory usage or size of supernet since the teacher and student share the same supernet weights $W$ during the search process. Two sets of architectures are iteratively optimized during search (please see details in Appendix \ref{app:training}), and we apply the latency constraint only on the student, not on the teacher. Therefore, our searched teacher is a sophisticated network based on the same search space and supernet weights $W$ used by the student
.
During training from scratch, we apply a distillation loss from teacher $\mathcal{T}$ to student $\mathcal{S}$:\vspace{-0.5em}
\begin{equation}
\ell_\mathrm{distillation}=\mathbb{E}_{i \in \mathcal{R}} \mathrm{KL}(\mathbf{q}_{i}^{s} || \mathbf{q}_{i}^{t}).
    \label{eq:kl_distill}
\end{equation}
$\mathrm{KL}$ denotes the KL divergence. $\mathbf{q}_{i}^{s}$ and $\mathbf{q}_{i}^{t}$ are predicted logit for pixel $i$ from $\mathcal{S}$ and $\mathcal{T}$, respectively. Equal weights (1.0) are assigned to the segmentation loss and this distillation loss.



\subsection{Deriving Discrete Architectures}\label{sec:decoding}
Once the search is completed, we derive our discrete architecture from $\alpha, \beta$, and $\gamma$:

\begin{itemize}[leftmargin=*]
    \vspace{-1em}
    \item \textbf{$\alpha, \gamma$}: We select the optimum operators and expansion ratios by taking the $\mathrm{argmax}$ of $\alpha$ and $\gamma$. We shrink the operator ``skip connection'' to obtain a shallower architecture with less cells.
    \item \textbf{$\beta$}: Different from \citep{liu2019auto}, for each $\mathrm{cell}_{s, l}$ we consider $\beta^0$ and $\beta^1$ as probabilities of two outputs from $\mathrm{cell}_{\frac{s}{2}, l-1}$ and $\mathrm{cell}_{s, l-1}$ into $\mathrm{cell}_{s, l}$. Therefore, by taking the $l^* = \mathrm{argmax}_l(\beta^0_{s,l})$,
we find the optimum position ($\mathrm{cell}_{s, l^*}$) where to downsample the current resolution ($\frac{s}{2} \rightarrow s$). \footnote{For a branch with two searchable downsampling positions, we consider the argmax over the joint probabilities $(l_1^*,l_2^*) = \mathrm{argmax}_{l_1,l_2}(\beta^0_{s,l_1}\cdot \beta^0_{2s,l_2})$.} \vspace{-0.5em}
\end{itemize}

It is worth noting that, the multi-resolution branches will share both cell weights and feature maps if their cells are of the same operator type, spatial resolution, and expansion ratio. This design contributes to a faster network. Once cells in branches diverge, the sharing between the branches will be stopped and they become individual branches (See Figure \ref{fig:student_arch}).


\section{Experiments}\vspace{-0.5em}

\subsection{Datasets and Implementations}\vspace{-0.5em}

We use the Cityscapes \citep{cordts2016cityscapes} as a testbed for both our architecture search and ablation studies. After that, we report our final accuracy and latency on Cityscapes, CamVid \citep{brostow2008segmentation}, and BDD \citep{yu2018bdd100k}. In all experiments, the class mIoU (mean Intersection over Union per class) and FPS (frame per second) are used as the metrics for accuracy and speed, respectively. Please see Appendix \ref{app:datasets} for dataset details.

In all experiments, we use Nvidia Geforce GTX 1080Ti for benchmarking the computing power. We employ the high-performance inference framework TensorRT v5.1.5 and report the inference speed. During this inference measurement, an image of a batch size of 1 is first loaded into the graphics memory, then the model is warmed up to reach a steady speed, and finally, the inference time is measured by running the model for six seconds. All experiments are performed under CUDA 10.0 and CUDNN V7. Our framework is implemented with PyTorch. The search, training, and latency measurement codes are available at \url{https://github.com/TAMU-VITA/FasterSeg}.\vspace{-0.5em}

\subsection{Architecture Search}\vspace{-0.5em}

We consider a total of $L = 16$ layers in the supernet and our downsample rate $s \in \{8, 16, 32\}$. In our work we use number of branches $b = 2$ by default, since more branches will suffer from high latency. We consider expansion ratio $\chi_{s,l} \in \mathcal{X} = \{4, 6, 8, 10, 12\}$ for any ``downsample rate'' $s$ and layer $l$. The multi-resolution branches have 1695 unique paths. For cells and expansion ratios, we have $(1+4\times5)^{(15+14+13)}+5^3 \approx 3.4\times10^{55}$ unique combinations. This results in a search space in the order of $10^{58}$, which is much larger and challenging, compared with preliminary studies.

\begin{wrapfigure}{r}{82mm}
\vspace{-1.5em}
\begin{center}
\includegraphics[scale=0.26]{images/student.pdf}
\end{center}
\vspace{-1em}
\caption{FasterSeg network discovered by our NAS framework.}
\vspace{-1em}
\label{fig:student_arch}
\end{wrapfigure}

Architecture search is conducted on Cityscapes training dataset. Figure \ref{fig:student_arch} visualizes the best spatial resolution discovered (FasterSeg). Our FasterSeg achieved mutli-resolutions with proper depths. The two branches share the first three operators then diverge, and choose to aggregate outputs with downsample rates of 16 and 32. Operators and expansion ratios are listed in Table \ref{table:student} in Appendix \ref{app:fasterseg}, where the zoomed convolution is heavily used, suggesting the importance of low latency and large receptive field.\vspace{-0.5em}

\begin{wraptable}{r}{86mm}
\vspace{-1.5em}
\footnotesize
\begin{center}
\caption{Ablation studies of different search and training strategies. mIoU is measured on Cityscapes validation set. The input resolution is $1024\times2048$.
$O$: operator; $s$: downsample rate; $\chi$: expansion ratios; $b$: number of branches; ``$\shortrightarrow$'': knowledge distillation.
}
\begin{tabular}{ccccc}
\toprule
Settings & mIoU (\%) & FPS & FLOPs & \#Params\\ \midrule
$O, s | \chi=8, b=1$ & 66.9 & 177.8 & 27.0 G & 6.3 M \\
$O, s | \chi=8, b=2$ & 69.5 & 119.9 & 42.8 G & 10.8 M  \\
\midrule
\multicolumn{5}{c}{Teacher ($\mathcal{T}$) Student ($\mathcal{S}$) Co-searching} \\ \midrule
$\mathcal{S}$: $O, s, \chi | b=2$ & 70.5 & 163.9 & 28.2 G & 4.4 M  \\
$\mathcal{T} \shortrightarrow$ pruned $\mathcal{T}$ & 66.1 & 146.7 & 29.5 G & 4.7 M \\
$\mathcal{T} \shortrightarrow \mathcal{S} (\textbf{FasterSeg})$ & \textbf{73.1} & \textbf{163.9} & 28.2 G & 4.4 M \\ \bottomrule
\end{tabular}\label{table:ablation}
\end{center}
\vspace{-1em}
\end{wraptable}

\subsection{Evaluation of Multi-resolution Search Space and Co-searching}\vspace{-0.5em}
We conduct ablation studies on Cityscapes to evaluate the effectiveness of our NAS framework. More specifically, we examine the impact of operators ($O$), downsample rate ($s$), expansion ratios ($\chi$), and also distillation on the accuracy and latency. When we expand from a single backbone ($b=1$) to multi-branches ($b=2$), our FPS drops but we gain a much improvement on mIoU, indicating the multi-resolution design is beneficial for segmentation task. By enabling the search for expansion ratios ($\chi$), we discover a faster network with FPS 163.9 without sacrificing accuracy (70.5\%), which proves that the searchable superkernel gets the benefit from eliminating redundant channels while maintaining high accuracy. This is our student network ($\mathcal{S}$) discovered in our co-searching framework (see below).

We further evaluate the efficacy of our teacher-student co-searching framework.
After the collaboratively searching, we obtain a teacher architecture ($\mathcal{T}$) and a student architecture ($\mathcal{S}$). As mentioned above, $\mathcal{S}$ is searched with searchable expansion ratios ($\chi$), achieving an FPS of 163.9 and an mIoU of 70.5\%. In contrast, when we directly compress the teacher (channel pruning via selecting the slimmest expansion ratio) and train with distillation from the well-trained original cumbersome teacher, it only achieved mIoU = 66.1\% with only FPS = 146.7, indicating that our architecture co-searching surpass the pruning based compression. Finally, when we adopt the knowledge distillation from the well-trained cumbersome teacher to our searched student, we boost the student's accuracy to 73.1\%, which is our final network \textbf{FasterSeg}. This demonstrates that both a student discovered by co-searching and training with knowledge distillation from the teacher are vital for obtaining an accurate faster real-time segmentation model.\vspace{-0.5em}







\subsection{Real-time Semantic Segmentation}\vspace{-0.5em}

In this section, we compare our FasterSeg with other works for real-time semantic segmentation on three popular scene segmentation datasets. Note that since we target on real-time segmentation, we measure the mIoU without any evaluation tricks like flipping, multi-scale, etc.

\begin{wraptable}{r}{95mm}
\vspace{-1.5em}
\footnotesize
\begin{center}
\caption{mIoU and inference FPS on Ciytscapes validation and test sets.}
\begin{tabular}{ccccc}
\toprule
\multirow{2}{*}{Method} & \multicolumn{2}{c}{mIoU (\%)} & \multirow{2}{*}{FPS} & \multirow{2}{*}{Resolution} \\ \cmidrule{2-3}
 & val & test &  \\ \midrule
ENet \citep{paszke2016enet} & - & 58.3 & 76.9 & 512$\times$1024\\
ICNet \citep{zhao2018icnet} & 67.7 & 69.5 & 37.7 & 1024$\times$2048 \\
BiSeNet \citep{yu2018bisenet} & 69.0 & 68.4 & 105.8 & 768$\times$1536 \\
CAS \citep{zhang2019customizable} & 71.6 & 70.5 & 108.0 & 768$\times$1536 \\
Fast-SCNN \citep{poudel2019fast} & 68.6 & 68.0 & 123.5 & 1024$\times$2048\\
DF1-Seg-d8 \citep{li2019partial} & 72.4 & 71.4 & 136.9 & 1024$\times$2048 \\
FasterSeg (ours) & \textbf{73.1} & \textbf{71.5} & \textbf{163.9} & 1024$\times$2048 \\ \bottomrule
\end{tabular} \label{table:cityscapes}
\vspace{-1em}
\end{center}
\end{wraptable}

\textbf{Cityscapes:}
We evaluate FasterSeg on Cityscapes validation and test sets. We use original image resolution of 1024$\times$2048 to measure both mIoU and speed inference. In Table \ref{table:cityscapes}, we see the superior FPS (163.9) of our FasterSeg, even under the maximum image resolution. This high FPS is over 1.3$\times$ faster than human-designed networks. Meanwhile, our FasterSeg still maintains competitive accuracy, which is 73.1\% on the validation set and 71.5\% on the test set. This accuracy is achieved with only Cityscapes fine-annotated images, without using any extra data (coarse-annotated images, ImageNet, etc.).

\textbf{CamVid:}
We directly transfer the searched architecture on Cityscapes to train on CamVid. Table \ref{table:camvid} reveals that without sacrificing much accuracy, our FasterSeg achieved an FPS of 398.1. This extremely high speed is over 47\% faster than the closest competitor in FPS \citep{yu2018bisenet}, and is over two times faster than the work with the best mIoU \citep{zhang2019customizable}. This impressive result verifies both the high performance of FasterSeg and also the transferability of our NAS framework.




\textbf{BDD:}
In addition, we also directly transfer the learned architecture to the BDD dataset. In Table \ref{table:bdd} we compare our FasterSeg with the baseline provided by \citet{yu2018bdd100k}. Since no previous work has considered real-time segmentation on the BDD dataset, we get 15 times faster than the DRN-D-22 with slightly higher mIoU. Our FasterSeg still preserve the extremely fast speed and competitive accuracy on BDD.\vspace{-0.5em}




\begin{table*}[!htb]
\footnotesize
\begin{minipage}[t]{.48\linewidth}
\centering
\caption{mIoU and inference FPS on CamVid test set. The input resolution is $720\times960$.}
\begin{tabular}{ccc}
\toprule
Method & mIoU (\%) & FPS \\ \midrule
ENet \citep{paszke2016enet} & 68.3 & 61.2 \\
ICNet \citep{zhao2018icnet} & 67.1 & 27.8 \\
BiSeNet \citep{yu2018bisenet} & 65.6 & 269.1 \\
CAS \citep{zhang2019customizable} & \textbf{71.2} & 169.0 \\
FasterSeg (ours) & 71.1 & \textbf{398.1} \\ \bottomrule
\end{tabular} \label{table:camvid}
\end{minipage}\hfill \begin{minipage}[t]{.48\linewidth}
\centering
\caption{mIoU and inference FPS on BDD validation set. The input resolution is $720\times1280$.}
\begin{tabular}{ccc}
\toprule
Method & mIoU (\%) & FPS \\ \midrule
DRN-D-22 \citep{yu2017dilated} & 53.2 & 21.0 \\
DRN-D-38 \citep{yu2017dilated} & \textbf{55.2} & 12.9 \\
FasterSeg (ours) & 55.1 & \textbf{318.0} \\ \bottomrule
\end{tabular} \label{table:bdd}
\end{minipage}\vspace{-0.5em}
\end{table*}



\section{Conclusion}\vspace{-0.5em}
We introduced a novel multi-resolution NAS framework, leveraging successful design patterns in handcrafted networks for real-time segmentation. Our NAS framework can automatically discover FasterSeg, which achieved both extremely fast inference speed and competitive accuracy. Our search space is intrinsically of low-latency and is much larger and challenging due to flexible searchable expansion ratios. More importantly, we successfully addressed the ``architecture collapse'' problem, by proposing the novel regularized latency optimization of fine-granularity. We also demonstrate that by seamlessly extending to teacher-student co-searching, our NAS framework can boost the student's accuracy via effective distillation.

\bibliography{iclr2020_conference}
\bibliographystyle{iclr2020_conference}

\newpage
\appendix

\section{Stem and Head Module}\vspace{-0.7em}
\textbf{Stem:} Our stem module aims to quickly downsample the input image to $\frac{1}{8}$ resolution while increasing the number of channels. The stem module consists of five $3\times3$ convolution layers, where the first, second, and fourth layer are of stride two and double the number of channels.

\textbf{Head:} As shown in Figure \ref{fig:supernet}, feature map of shape ($C_{2s}\times H\times W$) is first reduced in channels by a $1\times1$ convolution layer and bilinearly upsampled to match the shape of the other feature map ($C_s \times 2H \times 2W$). Then, two feature maps are concatenated and fused together with a $3\times3$ convolution layer. Note that we not necessarily have $C_{2s} = 2C_{s}$ because of the searchable expansion ratios.


\section{Branch Selection Criterion}\vspace{-0.7em} \label{app:branch_selection_mnasnet}
Since our searchable downsample rates $s \in \{8, 16, 32\}$ and the number of selected branches $b = 2$, our supernet needs to select branches of three possible combinations of resolutions: \{8, 16\}, \{8, 32\}, and \{16, 32\}. For each combination, branches of two resolutions will be aggregated by our head module.

Our supernet selects the best $b$ branches based on the criterion used in \citep{tan2019mnasnet}:
\begin{equation}
    Target(m) = ACC(m) \times [\frac{LAT(m)}{T}]^w,
\end{equation}
where $m$ is a searched model aggregating $b$ branches, with accuracy $ACC(m)$ and latency $LAT(m)$. $w$ is the weight factor defined as:
\begin{equation}
w = 
\begin{cases}
    \alpha, \hspace{15pt} \mathrm{ if } \hspace{5pt} LAT(m) \leq T \\
    \beta, \hspace{15pt} \mathrm{ otherwise}.
\end{cases}
\end{equation}
We empirically set $\alpha = \beta = -0.07$ and the target latency $T = 8.3$ ms in our work.

\section{``Gumbel-Softmax'' Trick for Searching Expansion Ratios} \vspace{-0.7em} \label{app:expansion_ratio}
Formally, suppose we have our set of expansion ratios $\mathcal{X} \subseteq N^+$, and we want to sample one ratio $\chi$ from $\mathcal{X}$. For each $\chi^i$ we have an associated probability $\gamma^i$, where $\sum_{i=1}^{|\mathcal{X}|} \gamma^i = 1$. ``Gumbel-Softmax'' trick \citep{gumbel1954statistical,maddison2014sampling} helps us approximate differentiable sampling. We first sample a ``Gumbel-Noise'' $o^i = -\mathrm{log}(-\mathrm{log}(u))$ with $u \sim \mathrm{Unif}[0, 1]$. Instead of selecting $\chi^j$ such that $j = \mathrm{argmax}_i(\gamma^i)$, we choose $j = \mathrm{argmax}_i(\frac{\mathrm{exp}(\frac{\mathrm{log}(\gamma^i)+o^i}{\tau})}{\sum_{m=1}^{|\mathcal{X}|}\mathrm{exp}(\frac{\mathrm{log}(\gamma^m)+o^m}{\tau})})$. We set the temperature parameter $\tau = 1$ in our work. 


\section{Normalized scalars $\alpha, \beta, \gamma$}\vspace{-0.7em} \label{app:abc}
$\alpha$, $\beta$, and $\gamma$ are all normalized scalars and implemented as softmax. They act as probabilities associating with each operator $O^k \in \mathcal{O}$, each predecessor's output $\overline{O}_{l-1}$, and each expansion ratio $\chi \in \mathcal{X}$, respectively:
\begin{equation}
\begin{split}
    \sum_{k=1}^{|\mathcal{O}|}\alpha^k_{s, l} = 1, \forall s, l \hspace{15pt} &\mathrm{and} \hspace{15pt} \alpha^k_{s, l} \geq 0, \forall k, s, l \\
    \beta^0_{s, l} + \beta^1_{s, l} = 1, \forall s, l \hspace{15pt} &\mathrm{and} \hspace{15pt} \beta^0_{s, l}, \beta^1_{s, l} \geq 0, \forall s, l \\
    \sum_{j=1}^{|\mathcal{X}|}\gamma^j_{s, l} = 1, \forall s, l  \hspace{15pt} &\mathrm{and} \hspace{15pt} \gamma^j_{s, l} \geq 0, \forall j, s, l, \\
\end{split}
\label{eq:softmax}
\end{equation}
where $s$ is downsample rate and $l$ is index of the layer in our supernet.


\section{Latency Estimation}\vspace{-0.7em} \label{app:latency_estimation}

We build a latency lookup table that covers all possible situations and use this lookup table as building blocks to estimate the relaxed latency. To verify the continuous relaxation of latency, we randomly sample networks of different operators/downsample rates/expansion ratios out of the supernet $\mathcal{M}$, and measured both the real and estimated latency. We estimate the network latency by accumulating all latencies of operators consisted in the network. In Figure \ref{fig:lookup_table}, we can see the high correlation between the two measurements, with a correlation coefficient of 0.993. This accurate estimation of network latency benefits from the sequential design of our search space.





\section{Training}\vspace{-0.7em} \label{app:training}

Given our supernet $\mathcal{M}$, the overall optimization target (loss) during architecture search is:
\begin{equation}
    L = L_{\mathrm{seg}}(\mathcal{M}) + \lambda \cdot Lat(\mathcal{M})
    \label{eq:loss}
\end{equation}
We adopt cross-entropy with ``online-hard-element-mining'' as our segmentation loss $L_{\mathrm{seg}}$. $Lat(\mathcal{M}$) is the continuously relaxed latency of supernet, and $\lambda$ is the balancing factor. We set $\lambda = 0.01$ in our work.

As the architecture $\alpha, \beta$, and $\gamma$ are now involved in the differentiable computation graph, they can be optimized using gradient descent. Similar in \citep{liu2019auto}, we adopt the first-order approximation (\citep{liu2018darts}), randomly split our training dataset into two disjoint sets trainA and trainB, and alternates the optimization between:
\begin{enumerate}
    \item Update network weights $W$ by $\nabla_W L_\mathrm{seg}(\mathcal{M}|W, \alpha, \beta, \gamma)$ on trainA,
    \item Update architecture $\alpha, \beta, \gamma$ by $\nabla_{\alpha, \beta, \gamma} L_\mathrm{seg}(\mathcal{M}|W, \alpha, \beta, \gamma) + \lambda \cdot \nabla_{\alpha, \beta, \gamma} LAT(\mathcal{M}|W, \alpha, \beta, \gamma)$ on trainB.
\end{enumerate}
When we extend to our teacher-student co-searching where we have two sets of architectures ($\alpha_\mathcal{T}, \beta_\mathcal{T}$) and ($\alpha_\mathcal{S}, \beta_\mathcal{S}, \gamma_\mathcal{S}$), our alternative optimization becomes:
\begin{enumerate}
    \item Update network weights $W$ by $\nabla_W L_\mathrm{seg}(\mathcal{M}|W, \alpha_\mathcal{T}, \beta_\mathcal{T})$ on trainA,
    \item Update network weights $W$ by $\nabla_W L_\mathrm{seg}(\mathcal{M}|W, \alpha_\mathcal{S}, \beta_\mathcal{S}, \gamma_\mathcal{S})$ on trainA,
    \item Update architecture $\alpha_\mathcal{T}, \beta_\mathcal{T}$ by $\nabla_{\alpha_\mathcal{T}, \beta_\mathcal{T}, \gamma_\mathcal{T}} L_\mathrm{seg}(\mathcal{M}|W, \alpha_\mathcal{T}, \beta_\mathcal{T})$ on trainB.
    \item Update architecture $\alpha_\mathcal{S}, \beta_\mathcal{S}, \gamma_\mathcal{S}$ by $\nabla_{\alpha_\mathcal{S}, \beta_\mathcal{S}, \gamma_\mathcal{S}} L_\mathrm{seg}(\mathcal{M}|W, \alpha_\mathcal{S}, \beta_\mathcal{S}, \gamma_\mathcal{S}) + \lambda \cdot \nabla_{\alpha_\mathcal{S}, \beta_\mathcal{S}, \gamma_\mathcal{S}} LAT(\mathcal{M}|W, \alpha_\mathcal{S}, \beta_\mathcal{S}, \gamma_\mathcal{S})$ on trainB.
\end{enumerate}

In all search experiments, we first pretrain the supernet without updating the architecture parameter for 20 epochs, then start architecture searching for 30 epochs.


\textbf{Optimizing Multiple Widths}: To train multiple widths within a superkernel, it is unrealistic to accumulate losses from all different width options in the super network. Therefore, we approximate the multi-widths optimization by training the maximum and minimum expansion ratios. During pretraining the super network, we train each operator with the smallest width, largest width, and 2 random widths. When we are searching for architecture parameters, we train each operator with the smallest width, largest width, and the width that is sampled from the current $\gamma$ by Gumbel Softmax.


\section{Benchmark Datasets}\vspace{-0.7em} \label{app:datasets}
\textbf{Cityscapes} \citep{cordts2016cityscapes} is a popular urban street scene dataset for semantic segmentation. It contains high-quality pixel-level annotations, 2,975 images for training and 500 images for validation. In our experiments, we only use the fine annotated images without any coarse annotated image or extra data like ImageNet \citep{deng2009imagenet}. For testing, it offers 1,525 images without ground-truth for a fair comparison. These images all have a resolution of $1024\times2048$ (H$\times$W), where each pixel is annotated to pre-defined 19 classes.
    
\textbf{CamVid} \citep{brostow2008segmentation} is another street scene dataset, extracted from five video sequences taken from a driving automobile. It contains 701 images in total, where 367 for training, 101 for validation and 233 for testing. The images have a resolution of $720\times960$ (H$\times$W) and 11 semantic categories.

\textbf{BDD}: The BDD \citep{yu2018bdd100k} is a recently released urban scene dataset. For the segmentation task, it contains 7,000 images for training and 1,000 for validation. The images have a resolution of $720\times1280$ (H$\times$W) and shared the same 19 semantic categories as used in the Cityscapes.


\section{Architecture Search Implementations}\vspace{-0.7em} \label{app:implementations}
As stated in the second line of Eqn. \ref{eq:cell_output}, a stride 2 convolution is used for all s $\rightarrow$ 2s connections, both to reduce spatial size and double the number of filters. Bilinear upsampling is used for all upsampling operations.


We conduct architecture search on the Cityscapes dataset. We use 160 $\times$ 320 random image crops from half-resolution (512 $\times$ 1024) images in the training set. Note that the original validation set or test set is never used for our architecture search. When learning network weights $W$, we use SGD optimizer with momentum 0.9 and weight decay of 5$\times10^{-4}$. We used the exponential learning rate decay of power 0.99. When learning the architecture parameters $\alpha, \beta, and \gamma$, we use Adam optimizer with learning rate 3$\times10^{-4}$. The entire architecture search optimization takes about 2 days on one 1080Ti GPU.


\section{FasterSeg Structure}\vspace{-0.7em} \label{app:fasterseg}
In Table \ref{table:student} we list the operators ($O$) and expansion ratios ($\chi$) selected by our FasterSeg. The downsample rates $s$ in Table \ref{table:student} and Figure \ref{fig:student_arch} match. We have the number of output channels $\mathrm{c_{out}} = s \times \chi$. We observed that the zoomed convolution is heavily used, suggesting the importance of low latency and large receptive field.



\begin{table*}[!htb]
\footnotesize
\caption{Cells used in FasterSeg. Left: cells for branch with final downsample rate of 16. Right: cells for branch with final downsample rate of 32. $s$: downsample rate. $\chi$: expansion ratio. c\_out: number of output channels.}
\begin{minipage}[t]{.45\linewidth}
\centering
\begin{tabular}{ccccc}
\toprule
Cell & Operator & $s$ & $\chi$ & c\_out \\ \midrule
1 & conv. $\times 2$ & 8 & 4 & 32 \\
2 & conv. $\times 2$ & 8 & 4 & 32 \\
3 & zoomed conv. $\times 2$ & 8 & 4 & 32 \\
4 & zoomed conv. $\times 2$ & 8 & 4 & 32 \\
5 & conv. $\times 2$ & 8 & 4 & 32 \\
6 & conv. $\times 2$ & 8 & 4 & 32 \\
7 & zoomed conv. $\times 2$ & 16 & 4 & 64 \\
8 & zoomed conv. $\times 2$ & 16 & 12 & 192 \\
9 & zoomed conv. $\times 2$ & 16 & 8 & 128 \\ \bottomrule
\end{tabular}
\end{minipage}\hfill \begin{minipage}[t]{.45\linewidth}
\centering
\begin{tabular}{ccccc}
\toprule
Cell & Operator & $s$ & $\chi$ & c\_out \\ \midrule
1 & conv. $\times 2$ & 8 & 4 & 32 \\
2 & conv. $\times 2$ & 8 & 4 & 32 \\
3 & zoomed conv. $\times 2$ & 8 & 4 & 32 \\
4 & zoomed conv. & 8 & 8 & 64 \\
5 & zoomed conv. $\times 2$ & 16 & 4 & 64 \\
6 & zoomed conv. $\times 2$ & 16 & 4 & 64 \\
7 & zoomed conv. $\times 2$ & 16 & 4 & 64 \\
8 & zoomed conv. $\times 2$ & 16 & 4 & 64 \\
9 & zoomed conv. $\times 2$ & 32 & 4 & 128 \\
10 & zoomed conv. $\times 2$ & 32 & 8 & 256 \\ \bottomrule
\end{tabular}
\end{minipage}\label{table:student}
\end{table*}

\section{Visualization}\vspace{-0.7em} \label{app:viz}
We show some visualized segmentation results in Figure \ref{fig:cherry_pick}. From the third to the forth column (``$O, s | \chi=8, b=1$'' to ``$O, s | \chi=8, b=2$''), adding the extra branch of different scales provides more consistent segmentations (in the building and sidewalk area). From the fifth to the sixth column (``$\mathcal{T} \shortrightarrow$ pruned $\mathcal{T}$'' to FasterSeg), our FasterSeg surpasses the prunned teacher network, where the segmentation is smoother and more accurate.

\begin{figure}[ht]
\includegraphics[scale=0.42]{images/cherry_pick.png}
\centering \vspace{-0.1in}
\caption{Visualization on Cityscapes validation set. Columns from left to right correspond to original images, ground truths, and results of ``$O, s | \chi=8, b=1$'', ``$O, s | \chi=8, b=2$'', ``$\mathcal{T} \shortrightarrow$ pruned $\mathcal{T}$'', FasterSeg (see Table \ref{table:ablation} for annotation details). Best viewed in color.}
\label{fig:cherry_pick}
\end{figure}


\end{document}
