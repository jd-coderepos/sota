\documentclass{article}
\pdfoutput=1
\usepackage{iclr2017_conference,times}
\iclrfinalcopy
\usepackage{collcell}
\usepackage{algorithm}
\usepackage{graphicx}

\newlength{\tzerolen}\settowidth{\tzerolen}{0}
\newlength{\mzerolen}\settowidth{\mzerolen}{}
\newcommand{\x}{\hspace*{\tzerolen}}
\newcommand{\xx}{\hspace*{2\tzerolen}}
\newcommand{\z}{\hspace*{\mzerolen}}
\newcommand{\zz}{\hspace*{2\mzerolen}}
\newcommand{\pp}{ \%-p}
\newcommand{\m}[1]{\raisebox{0mm}[0mm][0mm]{#1}}
\newcommand{\ds}[1]{\mbox{#1}}
\newcommand{\trg}{\tilde{z}}
\newcommand{\wf}{W\hspace*{-.4mm}}
\newcommand{\wfin}{W_\mathit{final}}
\newcommand{\loss}{\mathit{loss}}
\newcommand*{\movedown}[1]{\smash{\raisebox{-0.15ex}{#1}}}
\newcolumntype{L}{>{\collectcell\movedown}l<{\endcollectcell}}
\newcolumntype{R}{>{\collectcell\movedown}r<{\endcollectcell}}
\newcolumntype{C}{>{\collectcell\movedown}c<{\endcollectcell}}
\newcommand{\Req}{\textbf{Require:}\hspace*{0.5em}}
\newcommand*\Let[2]{\State #1  #2}
\newcommand{\X}{\hspace*{3mm}}
\newcommand{\XX}{\X\X}
\newcommand{\XXX}{\X\X\X}
\newcommand{\XXZ}{\XXX{} }
\newcommand{\cm}[1]{ #1}
\newcommand{\figalgo}{
\begin{algorithm}[t]
\caption{\label{algo}\ \ 
Temporal ensembling pseudocode. 
Note that the updates of  and  could equally well
be done inside the minibatch loop; in this pseudocode they occur between epochs for clarity.
}
\begin{tabbing}
\Req          \= = training stimuli \hspace*{25mm} \= \\
\Req            \> = set of training input indices with known labels \\
\Req          \> = labels for labeled inputs  \\
\Req       \> = ensembling momentum,  \\
\Req            = unsupervised weight ramp-up function \\
\Req     = stochastic neural network with trainable parameters  \\
\Req            = stochastic input augmentation function \\
\X     \=  \hspace*{5mm}                   \>   \cm{initialize ensemble predictions} \\
\X  \>                                  \>   \cm{initialize target vectors} \\
\X {\bf for}  in  {\bf do} \\
\XX {\bf for} each minibatch  {\bf do} \\
\XXX                            \>\> \cm{evaluate network outputs for augmented inputs} \\
\XXX \=  \>   \cm{supervised loss component} \\
\XXX \>                  \>   \cm{unsupervised loss component} \\
\XXX update  using, e.g., \textsc{Adam}                                \>\> \cm{update network parameters} \\
\XX {\bf end for} \\
\XX \=                                      \>   \cm{accumulate ensemble predictions} \\
\XX \>                                       \>   \cm{construct target vectors by bias correction} \\
\X {\bf end for}\\
\X {\bf return} 
\end{tabbing}
\vspace*{-1.5mm}
\end{algorithm}
}

\newcommand{\figalgopi}{
\begin{algorithm}[t]
\caption{\label{algopi}\ 
-model pseudocode.
}
\begin{tabbing}
\Req          \= = training stimuli \hspace*{25mm} \= \\
\Req            \> = set of training input indices with known labels \\
\Req          \> = labels for labeled inputs  \\
\Req            = unsupervised weight ramp-up function \\
\Req     = stochastic neural network with trainable parameters  \\
\Req            = stochastic input augmentation function \\
\X {\bf for}  in  {\bf do} \\
\XX {\bf for} each minibatch  {\bf do} \\
\XXX                               \>\> \cm{evaluate network outputs for augmented inputs} \\
\XXX                       \>\> \cm{again, with different dropout and augmentation} \\
\XXX \=  \>   \cm{supervised loss component} \\
\XXX \>             \>   \cm{unsupervised loss component} \\
\XXX update  using, e.g., \textsc{Adam}                                \>\> \cm{update network parameters} \\
\XX {\bf end for} \\
\X {\bf end for}\\
\X {\bf return} 
\end{tabbing}
\vspace*{-1.5mm}
\end{algorithm}
}

\newcommand{\figdrawing}{
\begin{figure*}[t]
\centering
\includegraphics[width=0.97\linewidth]{drawing.pdf}
\caption{\label{fig:drawing}Structure of the training pass in our methods. Top: -model. Bottom: temporal ensembling.
Labels  are available only for the labeled inputs, and the associated cross-entropy loss
component is evaluated only for those.
}
\end{figure*}
}

\newcommand{\mbf}[1]{\textrm{\bf #1}}
\newcommand{\tss}{\hspace*{0.66mm}}
\newcommand{\qss}{\tss}
\newcommand{\hsp}{\hspace*{14mm}}
\newcommand{\hspp}{\hspace*{18.3mm}}
\newcommand{\xsp}{\hspace*{2.2mm}}
\newcommand{\tblcifar}{
\begin{table}[t]
\centering
\caption{\label{tbl:cifar}CIFAR-10 results with 4000 labels, averages of 10 runs (4 runs for all labels).
}
\vspace*{\baselineskip}
\begin{tabular}{|L|C|C|}
\hline
		& \multicolumn{2}{C|}{\bf \hspace*{11.4mm} Error rate (\%) with \#  labels \hspace*{11.4mm}} \\
 & \multicolumn{1}{C}{\hspace*{12mm} 4000 \hspace*{12mm}} & \multicolumn{1}{C|}{All (50000)} \\\hline
Supervised-only                      &  &   \\
\hspace*{2ex}with augmentation &  & \\
Conv-Large, -model~\citep{ladder} &  & \\
CatGAN~\citep{catgan}                     &  & \\
GAN of~\cite{googan}\hsp &  & \\
\hline
-model                              &  &  \\
\hspace*{2ex}-model with augmentation      &  &  \\
\hspace*{2ex}Temporal ensembling with augmentation &  & \\
\hline
\end{tabular}
\end{table}
}

\newcommand{\tsss}{\hspace*{0.66mm}}
\newcommand{\qsss}{\tss}
\newcommand{\hsps}{\hspace*{11.4mm}}
\newcommand{\hspq}{\hspace*{7.4mm}}
\newcommand{\xsps}{\hspace*{2.2mm}}
\newcommand{\tblcifarb}{
\begin{table}[t]
\centering
\caption{\label{tbl:cifarb}CIFAR-100 results with 10000 labels, averages of 10 runs (4 runs for all labels).
}
\vspace*{\baselineskip}
\begin{tabular}{|L|C|C|}
\hline
		& \multicolumn{2}{C|}{\bf \hspace*{11.4mm} Error rate (\%) with \#  labels \hspace*{11.4mm}} \\
 & \multicolumn{1}{C}{\hsps{}10000\hsps{}} & \multicolumn{1}{C|}{\hspq{}All (50000)\hspq{}} \\\hline
Supervised-only                                    &  &   \\
\hspace*{2ex}with augmentation                     &  & \\
\hline
-model                                        &  &  \\
\hspace*{2ex}-model with augmentation         &  & \\
\hspace*{2ex}Temporal ensembling with augmentation &  & \\
\hline
\end{tabular}
\end{table}
}

\newcommand{\cbsp}{\hspace*{5.7mm}}
\newcommand{\cbsq}{\hspace*{4.7mm}}
\newcommand{\cbsr}{\hspace*{1mm}}
\newcommand{\cbss}{\hspace*{2ex}}
\newcommand{\tblcifarc}{
\begin{table}[t]
\centering
\caption{\label{tbl:cifarc}CIFAR-100 + Tiny Images results, averages of 10 runs.
}
\vspace*{\baselineskip}
\begin{tabular}{|L|C|C|}
\hline
		& \multicolumn{2}{C|}{\bf\cbsr{}Error rate (\%) with \# unlabeled\cbsr{}} \\
		& \multicolumn{2}{C|}{\bf auxiliary inputs from Tiny Images} \\
 & \multicolumn{1}{C}{\cbsp{}Random 500k\cbsp{}} &\cbsq{}Restricted 237k\cbsq{}\\\hline
-model with augmentation         &  & \\
Temporal ensembling with augmentation\cbss{}&  & \\
\hline
\end{tabular}
\end{table}
}

\newcommand{\zb}{\z\hspace*{0.10mm}}
\newcommand{\tblsvhn}{
\begin{table}[t]
\centering
\caption{\label{tbl:svhn}SVHN results for 500 and 1000 labels, averages of 10 runs (4 runs for all labels).
}
\vspace*{\baselineskip}
\begin{tabular}{|L|L|L|C|}
\hline
		 & \multicolumn{3}{C|}{\bf \xsp Error rate (\%) with \# labels \xsp} \\
\raisebox{1ex}[0mm][0mm]{\bf Model} & \multicolumn{1}{C}{500} & \multicolumn{1}{C}{1000} & \multicolumn{1}{C|}{All (73257)} \\\hline
Supervised-only			           & \tss & \tss & \tss\qss\\
\hspace*{2ex}with augmentation           & \tss & \tss & \tss\qss\\
DGN~\citep{dgn}                                  &                       & \tss & \\
Virtual Adversarial~\citep{vad}                  &                       & \tss & \\
ADGM~\citep{adgm}     &                       & \tss & \\
SDGM~\citep{adgm}          &                       & \tss & \\
GAN of~\cite{googan}\hspp        & \tss  & \tss  & \\
\hline
-model                                     & \tss\qss & \tss\qss & \tss\qss\\
\hspace*{2ex}-model with augmentation        & \tss & \tss & \tss\qss \\
\hspace*{2ex}Temporal ensembling with augmentation        & \tss & \tss & \tss\qss \\
\hline
\end{tabular}
\end{table}
}

\newcommand{\figgraphs}{
\begin{figure*}[t]
\centering \includegraphics[width=1\linewidth]{graph.pdf}
\caption{\label{fig:graphs}Percentage of correct SVHN classifications as a function of training epoch when a part of the labels is randomized. With standard supervised training (left) the classification accuracy suffers when even a small portion of the labels give disinformation, and the situation worsens quickly as the portion of randomized labels increases to 50\% or more. On the other hand, temporal ensembling (right) shows almost perfect resistance to disinformation when half of the labels are random, and retains over ninety percent classification accuracy even when 80\% of the labels are random.
}
\end{figure*}
}

\newcommand{\networkArch}{
\begin{table}[t]
\centering
\caption{\label{tbl:network}The network architecture used in all of our tests.
}
\vspace*{\baselineskip}
\begin{tabular}{|L|L|}
\hline
\textsc{Name} & \textsc{Description} \\
\hline
\raisebox{0mm}[3mm]{}input  &  RGB image \\
noise  & Additive Gaussian noise  \\
conv1a &  filters, , pad = 'same', LReLU ()\\
conv1b &  filters, , pad = 'same', LReLU () \\
conv1c &  filters, , pad = 'same', LReLU () \\
pool1   & Maxpool  pixels \\
drop1   & Dropout,  \\
conv2a &  filters, , pad = 'same', LReLU () \\
conv2b &  filters, , pad = 'same', LReLU () \\
conv2c &  filters, , pad = 'same', LReLU () \\
pool2   & Maxpool  pixels \\
drop2   & Dropout,  \\
conv3a &  filters, , pad = 'valid', LReLU () \\
conv3b &  filters, , LReLU () \\
conv3c &  filters, , LReLU () \\
pool3   & Global average pool (1 pixels) \\
dense & Fully connected \\
output & Softmax \\\hline
\end{tabular}
\end{table}
}
 
\title{Temporal Ensembling for Semi-Supervised Learning}
\author{Samuli Laine\\NVIDIA\\\texttt{slaine@nvidia.com}\\\And Timo Aila\\NVIDIA\\\texttt{taila@nvidia.com}}
\begin{document}
{\flushleft\maketitle}
\ifx\headrulewidth\undefined\else\thispagestyle{fancy}\fi

\begin{abstract} 
In this paper, we present a simple and efficient method for training deep neural networks in
a semi-supervised setting where only a small portion of training data is
labeled. We introduce self-ensembling, where we form a consensus
prediction of the unknown labels using the outputs of the
network-in-training on different epochs, and most importantly, under different
regularization and input augmentation conditions. This ensemble prediction
can be expected to be a better predictor for the unknown labels than the 
output of the network at the most recent training epoch, and can thus be
used as a target for training. 
Using our method, we set new records for two standard semi-supervised
learning benchmarks, reducing the (non-augmented) classification error rate
from 18.44\% to 7.05\% in \ds{SVHN} with 500 labels and from 18.63\% to 16.55\% in \ds{CIFAR-10} with 4000 labels, 
and further to 5.12\% and 12.16\% by enabling the standard augmentations.
We additionally obtain a clear improvement in \ds{CIFAR-100} classification accuracy by using random images from the Tiny Images dataset as unlabeled extra inputs during training.
Finally, we demonstrate good tolerance to incorrect labels.
\end{abstract}

\section{Introduction}
\label{sec:intro}

It has long been known that an ensemble of multiple neural networks generally yields
better predictions than a single network in the ensemble. This effect has also been
indirectly exploited when training a single network through dropout~\citep{srivastava2014}, dropconnect~\citep{dropconnect}, or stochastic depth~\citep{stochdepth} 
regularization methods, and in swapout networks~\citep{swapout}, where training always focuses on a
particular subset of the network, and thus the complete network can be seen as an
implicit ensemble of such trained sub-networks. We extend this idea by forming
ensemble predictions during training, using the outputs of
a single network on different training epochs and under different regularization
and input augmentation conditions. Our training still operates on a single network,
but the predictions made on different epochs correspond to an ensemble prediction of
a large number of individual sub-networks because of dropout regularization.

This ensemble prediction can be exploited for semi-supervised learning where
only a small portion of training data is labeled. If we compare the ensemble prediction 
to the current output of the network being trained, the ensemble prediction is likely
to be closer to the correct, unknown labels of the unlabeled inputs. Therefore the
labels inferred this way can be used as training targets for the unlabeled inputs.
Our method relies heavily on dropout regularization and versatile input augmentation.
Indeed, without neither, there would be much less reason to place confidence in whatever
labels are inferred for the unlabeled training data.

We describe two ways to implement self-ensembling, -model and temporal ensembling.
Both approaches surpass prior state-of-the-art results in semi-supervised learning by a considerable margin. 
We furthermore observe that self-ensembling improves the classification accuracy in fully labeled cases as well, and provides tolerance against incorrect labels.

The recently introduced transform/stability loss of~\cite{sajjadi16} is based on the same
principle as our work, and the -model can be seen as a special case of it.
The -model can also be seen as a simplification of the
-model of the ladder network by~\cite{ladder}, a previously presented network
architecture for semi-supervised learning.
Our temporal ensembling method has connections to
the bootstrapping method of~\cite{reed14} targeted for training
with noisy labels.

\section{Self-ensembling during training}
\label{sec:selfens}

We present two implementations of self-ensembling during training. The first one, -model,
encourages consistent network output between two realizations of the same input
stimulus, under two different dropout conditions. The second method, temporal ensembling,
simplifies and extends this by taking into account the network predictions over multiple previous
training epochs.

We shall describe our methods in the context of traditional image classification networks.
Let the training data consist of total of  inputs, out of which  are labeled.
The input stimuli, available for all training data, are denoted , where .
Let set  contain the indices of the labeled inputs, . For every
, we have a known correct label , where 
is the number of different classes.

\subsection{-model}
\label{sec:pinet}

\figdrawing
\figalgopi

The structure of -model is shown in Figure~\ref{fig:drawing} (top), and the pseudocode in Algorithm~\ref{algopi}.
During training, we evaluate
the network for each training input  twice, resulting in prediction vectors  and .
Our loss function consists of two components. The first component is the standard cross-entropy loss, evaluated for
labeled inputs only. The second component, evaluated for all inputs, penalizes different predictions for the
same training input  by taking the mean square difference between the prediction vectors
 and .\footnote{Squared difference gave slightly but consistently better results than cross-entropy loss in our tests.} To combine the supervised and unsupervised loss terms, we scale the latter
by time-dependent weighting function .
By comparing the entire output vectors  and , we effectively ask the 
``dark knowledge''~\citep{Hinton15} between the two evaluations to be close, which is a much stronger requirement
compared to asking that only the final classification remains the same, which is what happens in traditional training.

It is important to notice that, because of dropout regularization, the network output during training is a 
stochastic variable. Thus two evaluations of the same input  under same network weights
 yield different results. In addition, Gaussian noise and augmentations such as random translation
are evaluated twice, resulting in additional variation. The combination of these
effects explains the difference between the prediction vectors  and . This difference
can be seen as an error in classification, given that the original input  was the same, and thus
minimizing it is a reasonable goal.

In our implementation, the unsupervised loss weighting function  ramps up, starting from zero,
along a Gaussian curve during the first 80 training epochs. 
See Appendix~\ref{sec:Training parameters} for further details about this and other training parameters.
In the beginning the total loss and the learning gradients are thus
dominated by the supervised loss component, i.e., the labeled data only. We have found it to be
very important that the ramp-up of the unsupervised loss component is slow enough---otherwise, the network 
gets easily stuck in a degenerate solution where no meaningful classification of the data is obtained. 

Our approach is somewhat similar to the -model of the ladder network by~\cite{ladder}, but
conceptually simpler. In the -model, the comparison is done directly on network
outputs, i.e., after softmax activation, and there is no auxiliary mapping between the two branches such as
the learned denoising functions in the ladder network architecture.
Furthermore, instead of having one ``clean'' and one ``corrupted'' branch as in -model, we apply
equal augmentation and noise to the inputs for both branches.

As shown in Section~\ref{sec:results}, the -model combined with a good convolutional
network architecture provides a significant improvement over prior art in classification
accuracy.

\subsection{Temporal ensembling}
\label{sec:tempo}

Analyzing how the -model works, we could equally well split the evaluation of the two branches
in two separate phases: first classifying the training set once without updating the weights ,
and then training the network on the same inputs under different augmentations and dropout, using
the just obtained predictions as targets for the unsupervised loss component. As the training targets
obtained this way are based on a single evaluation of the network, they can be expected to be noisy.
Temporal ensembling alleviates this by aggregating the predictions of multiple previous network evaluations
into an ensemble prediction. It also lets us evaluate the network only once during training, gaining
an approximate 2x speedup over the -model.

\figalgo

The structure of our temporal ensembling method is shown in Figure~\ref{fig:drawing} (bottom), and the pseudocode in Algorithm~\ref{algo}.
The main difference
to the -model is that the network and augmentations are evaluated only once per input per epoch, 
and the target vectors  for the unsupervised loss component are based on prior network evaluations
instead of a second evaluation of the network.

After every training epoch, the network outputs  are accumulated into ensemble 
outputs  by updating , where  is a momentum term that
controls how far the ensemble reaches into training history. 
Because of dropout regularization and stochastic augmentation,  thus contains a weighted 
average of the outputs of an ensemble of networks  from previous training epochs, with recent 
epochs having larger weight than distant epochs. For generating the training targets ,
we need to correct for the startup bias in  by dividing by factor .
A similar bias correction has been used in, e.g., Adam~\citep{adam} and mean-only batch normalization~\citep{Salimans16}.
On the first training epoch,  and  are zero as no data from previous epochs is available.
For this reason, we specify the unsupervised weight ramp-up function  to also be zero on the 
first training epoch.

The benefits of temporal ensembling compared to -model are twofold. First, the training is faster
because the network is evaluated only once per input on each epoch. Second, the training targets  can
be expected to be less noisy than with -model. As shown in Section~\ref{sec:results}, we indeed obtain
somewhat better results with temporal ensembling than with -model in the same number of training epochs.
The downside compared to -model is the need to store auxiliary data across epochs, and the new hyperparameter .
While the matrix  can be fairly large when the dataset contains a large number of items and categories, its elements are accessed relatively infrequently. Thus it can be stored, e.g., in a memory mapped file.

An intriguing additional possibility of temporal ensembling is collecting other statistics from the network
predictions  besides the mean. For example, by tracking the second raw moment of the network outputs,
we can estimate the variance of each output component . This makes it possible to reason about the
uncertainty of network outputs in a principled way~\citep{Gal16}. Based on this information, we could, e.g.,
place more weight on more certain predictions vs.~uncertain ones in the unsupervised loss term.
However, we leave the exploration of these avenues as future work.

\section{Results}
\label{sec:results}

Our network structure is given in Table~\ref{tbl:network}, and the test setup and all training parameters are detailed in Appendix~\ref{sec:Training parameters}. We test the -model and temporal ensembling in two image classification tasks, CIFAR-10 and SVHN, and report the mean and standard deviation of 10 runs using different random seeds.

Although it is rarely stated explicitly, we believe that our comparison methods do not use input augmentation, i.e., are limited to dropout and other forms of permutation-invariant noise. Therefore we report the error rates without augmentation, unless explicitly stated otherwise. Given that the ability of an algorithm to extract benefit from augmentation is also an important property, we report the classification accuracy using a standard set of augmentations as well. In purely supervised training the de facto standard way of augmenting the CIFAR-10 dataset includes horizontal flips and random translations, while SVHN is limited to random translations. By using these same augmentations we can compare against the best fully supervised results as well. After all, the fully supervised results should indicate the upper bound of obtainable accuracy. 

\subsection{CIFAR-10}
\tblcifar
CIFAR-10 is a dataset consisting of \m{} pixel RGB images from ten classes.
Table~\ref{tbl:cifar} shows a  percentage point reduction in classification error rate with 4000 labels (400 per class) compared to earlier methods for the non-augmented -model. 

Enabling the standard set of augmentations further reduces the error rate by  percentage points to . Temporal ensembling is slightly better still at , while being twice as fast to train. This small improvement conceals the subtle fact that random horizontal flips need to be done independently for each epoch in temporal ensembling, while -model can randomize once per a pair of evaluations, which according to our measurements is 0.5 percentage points better than independent flips.

A principled comparison with \cite{sajjadi16} is difficult due to several reasons. They provide results only for a fairly extreme set of augmentations (translations, flipping, rotations, stretching, and shearing) on top of fractional max pooling \citep{fmp}, which introduces random, local stretching inside the network, and is known to improve classification results substantially. They quote an error rate of only 13.60\% for supervised-only training with 4000 labels, while our corresponding baseline is 34.85\%. This gap indicates a huge benefit from versatile augmentations and fractional max pooling---in fact, their baseline result is already better than any previous semi-supervised results. By enabling semi-supervised learning they achieve a 17\% drop in classification error rate (from 13.60\% to 11.29\%), while we see a much larger relative drop of 65\% (from 34.85\% to 12.16\%).

\subsection{SVHN}
\tblsvhn
The street view house numbers (SVHN) dataset consists of \m{} pixel RGB images of real-world house numbers, and the task is to classify the centermost digit. 
In SVHN we chose to use only the official 73257 training examples following~\cite{googan}. Even with this choice our error rate with all labels is only  without augmentation.

Table~\ref{tbl:svhn} compares our method to the previous state-of-the-art. With the most commonly used 1000 labels we observe an improvement of  percentage points, from  to  without augmentation, and further to  with standard augmentations. 

We also investigated the behavior with 500 labels, where we obtained an error rate less than half of~\cite{googan} without augmentations, with a significantly lower standard deviation as well. When augmentations were enabled, temporal ensembling further reduced the error rate to . In this test the difference between -model and temporal ensembling was quite significant at  percentage points.

In SVHN \cite{sajjadi16} provide results without augmentation, with the caveat that they use fractional max pooling, which is a very augmentation-like technique due to the random, local stretching it introduces inside the network. It leads to a superb error rate of 2.28\% in supervised-only training, while our corresponding baseline is 3.05\% (or 2.88\% with translations). Given that in a separate experiment our network matched the best published result for non-augmented SVHN when extra data is used (1.69\% from \cite{Lee15}), this gap is quite surprising, and leads us to conclude that fractional max pooling leads to a powerful augmentation of the dataset, well beyond what simple translations can achieve. Our temporal ensembling technique obtains better error rates for both 500 and 1000 labels (5.12\% and 4.42\%, respectively) compared to the 6.03\% reported by Sajjadi et al.~for 732 labels.

\subsection{CIFAR-100 and Tiny Images}
\label{sec:tiny_images}
\tblcifarb
\tblcifarc
The CIFAR-100 dataset consists of \m{} pixel RGB images from a hundred classes. We are not aware of previous semi-supervised results in this dataset, and chose 10000 labels for our experiments. Table~\ref{tbl:cifarb} shows error rates of  and  without and with augmentation, respectively. These correspond to 7.8 and 5.9 percentage point improvements compared to supervised learning with labeled inputs only. 

We ran two additional tests using unlabeled extra data from Tiny Images dataset \citep{Torralba2008}: one with randomly selected 500k extra images, most not corresponding to any of the CIFAR-100 categories, and another with a restricted set of 237k images from 
the categories that correspond to those found in the CIFAR-100 dataset (see appendix~\ref{sec:Training parameters} for details). 
The results are shown in Table~\ref{tbl:cifarc}.
The addition of randomly selected, unlabeled extra images improved the error rate by  percentage points (from  to ), indicating a desirable ability to learn from random natural images. Temporal ensembling benefited much more from the extra data than the -model. Interestingly, restricting the extra data to categories that are present in \mbox{CIFAR-100} did not improve the classification accuracy further. This indicates that in order to train a better classifier by adding extra data as unlabeled inputs, it is enough to have the extra data roughly in the same space as the actual inputs---in our case, natural images. We hypothesize that it may even be possible to use properly crafted synthetic data as unlabeled inputs to obtain improved classifiers.

In order to keep the training times tolerable, we limited the number of unlabeled inputs to 50k per epoch in these tests, i.e., on every epoch we trained using all 50k labeled inputs from CIFAR-100 and 50k additional unlabeled inputs from Tiny Images. The 50k unlabeled inputs were chosen randomly on each epoch from the 500k or 237k extra inputs. In temporal ensembling, after each epoch we updated only the rows of  that corresponded to inputs used on that epoch.

\subsection{Supervised learning}

When all labels are used for traditional supervised training, our network approximately matches the state-of-the-art error rate for a single model in CIFAR-10 with augmentation \citep{Lee15,Mishkin15} at , and without augmentation \citep{Salimans16} at . The same is probably true for SVHN as well, but there the best published results rely on extra data that we chose not to use.

Given this premise, it is perhaps somewhat surprising that our methods reduce the error rate also when all labels are used (Tables~\ref{tbl:cifar} and~\ref{tbl:svhn}). We believe that this is an indication that the consistency requirement adds a degree of resistance to ambiguous labels that are fairly common in many classification tasks, and that it encourages features to be more invariant to stochastic sampling.

\subsection{Tolerance to incorrect labels}
\label{sec:random_labels}
\figgraphs

In a further test we studied the hypothesis that our methods add tolerance to incorrect labels by assigning a random label to a certain percentage of the training set before starting to train. Figure~\ref{fig:graphs} shows the classification error graphs for standard supervised training and temporal ensembling. 

Clearly our methods provide considerable resistance to wrong labels, and we believe this is because
the unsupervised loss term encourages the mapping function implemented by the network to be flat in the vicinity of all input data points, whereas the supervised loss term enforces the mapping function to have a specific value in the vicinity of the labeled input data points. This means that even the wrongly labeled inputs play a role in shaping the mapping function---the unsupervised loss term smooths the mapping function and thus also the decision boundaries, effectively fusing the inputs into coherent clusters, whereas the excess of correct labels in each class is sufficient for locking the clusters to the right output vectors through the supervised loss term. The difference to classical regularizers is that we induce smoothness only on the manifold of likely inputs instead of over the entire input domain. For further analysis about the importance of the gradient of the mapping function, see~\cite{Simard1998}.

\section{Related work}
\label{sec:related}

There is a large body of previous work on semi-supervised learning~\citep{zhu05survey}. 
In here we will concentrate on the ones that are most directly connected to our work.

-model is a subset of a ladder network~\citep{ladder} that introduces lateral connections
into an encoder-decoder type network architecture, targeted at semi-supervised
learning. In -model, all but the highest lateral connections in the ladder
network are removed, and after pruning the unnecessary stages, the remaining network
consists of two parallel, identical branches. One of the branches takes the original
training inputs, whereas the other branch is given the same input corrupted with noise.
The unsupervised loss term is computed as the squared difference between the (pre-activation) output of the clean branch and a denoised (pre-activation) output of the corrupted branch. The denoised estimate is computed from the output of the corrupted branch using a parametric nonlinearity that has 10 auxiliary trainable parameters per unit.
Our -model differs
from the -model in removing the parametric nonlinearity and denoising, having two corrupted paths, and comparing the outputs of
the network instead of pre-activation data of the final layer.

\cite{sajjadi16} recently introduced a new loss function for semi-supervised learning, so
called transform/stability loss, which is founded on the same principle as our work.
During training, they run augmentation and network evaluation  times for each
minibatch, and then compute an unsupervised loss term as the sum of all pairwise squared distances between
the obtained  network outputs. 
As such, their technique follows the general pseudo-ensemble agreement (PEA) regularization framework of~\cite{PseudoEnsembles}.
In addition, they employ a mutual exclusivity loss term~\citep{meloss} that we do not use. Our -model can be seen as a special case of the 
transform/stability loss obtained by setting \mbox{}. The computational cost of
training with transform/stability loss increases linearly as a function of , whereas
the efficiency of our temporal ensembling technique remains constant regardless of how large
effective ensemble we obtain via the averaging of previous epochs' predictions.

In bootstrap aggregating, or {\em bagging}, multiple networks are trained independently
based on subsets of training data~\citep{breiman96}. This results in an ensemble that is more stable
and accurate than the individual networks. Our approach can be seen as pulling the predictions from an
implicit ensemble that is based on a single network, and the variability is a result of evaluating it under
different dropout and augmentation conditions instead of training on different subsets of data.
In work parallel to ours, \cite{Snapshot2017} store multiple snapshots of the network during training, hopefully corresponding to different local minima, and use them as an explicit ensemble.

The general technique of inferring new labels from partially labeled data is often referred to as {\em bootstrapping} or
{\em self-training}, and it was first proposed by~\cite{yarowsky95} in the context of linguistic analysis.
\cite{graphprop} analyze Yarowsky's algorithm and propose a novel graph-based label propagation
approach. Similarly, label propagation methods~\citep{zhuprop02} infer labels for unlabeled training
data by comparing the associated inputs to labeled training inputs using a suitable distance metric. Our
approach differs from this in two important ways. Firstly, we never compare training inputs against each other,
but instead only rely on the unknown labels remaining constant, and secondly, we
let the network produce the likely classifications for the unlabeled inputs instead of providing them through an outside process.

In addition to partially labeled data, considerable amount of effort has been put into dealing with
densely but inaccurately labeled data. This can be seen as a semi-supervised learning task where
part of the training process is to identify the labels that are not to be trusted. For recent work in this area,
see, e.g., \cite{sukhbaatar14} and \cite{patrini16}. 
In this context of noisy labels, \cite{reed14} presented a simple bootstrapping method that trains a classifier
with the target composed of a convex combination of the previous epoch output and the known but potentially noisy
labels. Our temporal ensembling differs from this by taking into account the evaluations over multiple epochs.

Generative Adversarial Networks (GAN) have been recently used for semi-supervised learning with promising 
results~\citep{adgm,catgan,odena16,googan}. It could be an interesting avenue for future work to incorporate a generative 
component to our solution.
We also envision that our methods could be applied to regression-type learning tasks.

\section{Acknowledgements}

We thank the anonymous reviewers, Tero Karras, Pekka J\"{a}nis, Tim Salimans, Ian Goodfellow, as well as Harri Valpola and his colleagues at Curious AI for valuable suggestions that helped to improve this article.

\networkArch

\bibliography{paper}
\bibliographystyle{iclr2017_conference}

\appendix
\section{Network architecture, test setup, and training parameters}
\label{sec:Training parameters}

\newcommand{\wmax}{w_\mathit{max}}
\newcommand{\lmax}{\lambda_\mathit{max}}

Table~\ref{tbl:network} details the network architecture used in all of our tests. It is heavily inspired by 
ConvPool-CNN-C~\citep{springenberg2014} and the improvements made by \cite{Salimans16}. All data layers were 
initialized following \cite{he2015}, and we applied weight normalization and mean-only batch normalization~\citep{Salimans16} 
with momentum  to all of them. We used leaky ReLU~\citep{Maas2013} with  as the non-linearity, and chose
to use max pooling instead of strided convolutions because it gave consistently better results in our experiments. 

All networks were trained using Adam~\citep{adam} with a maximum learning rate of \mbox{}, 
except for temporal ensembling in the SVHN case where a maximum learning rate of \mbox{} worked better. Adam
momentum parameters were set to  and  as suggested in the paper.
The maximum value for the unsupervised loss component was set to , where  is the number of labeled inputs and  is the total number of training inputs.
For -model runs, we used \mbox{} in all runs except for CIFAR-100 with Tiny Images where we set \mbox{}. For temporal ensembling we used \mbox{} in most runs. For the corrupted label test in Section~\ref{sec:random_labels} we used \mbox{} for 0\% and 20\% corruption, and
\mbox{} for corruption of 50\% and higher. For basic CIFAR-100 runs we used \mbox{}, and for CIFAR-100 with Tiny Images we used \mbox{}. The accumulation decay constant 
of temporal ensembling was set to  in all runs.

In all runs we ramped up both the learning rate  and unsupervised loss component weight  during the first 80 epochs
using a Gaussian ramp-up curve , where  advances linearly from zero to one during the ramp-up period.
In addition to ramp-up, we annealed the learning rate  to zero and Adam  to  during the 
last~50 epochs, but otherwise we did not decay them during training. The ramp-down curve was similar
to the ramp-up curve but time-reversed and with a scaling constant of  instead of .
All networks were trained for 300 epochs with minibatch size of 100. 

\textbf{CIFAR-10\ \ \ }
Following previous work in fully supervised learning, we pre-processed the images using ZCA and augmented the dataset using horizontal
flips and random translations. The translations were drawn from  pixels, and were independently applied to both branches in the -model.

\textbf{SVHN\ \ \ }
We pre-processed the input images by biasing and scaling each input image to zero mean and unit variance. 
We used only the 73257 items in the official training set, i.e., did not use the provided
531131 extra items. The training setups were otherwise similar to CIFAR-10 except that horizontal flips were not used.

\textbf{Implementation\ \ \ }
Our implementation is written in Python using Theano \citep{theano} and Lasagne \citep{lasagne}, and is available at {\tt https://github.com/smlaine2/tempens}.

\textbf{Model convergence\ \ \ }
As discussed in Section~\ref{sec:pinet}, a slow ramp-up of the unsupervised cost is very important for getting the models to converge.
Furthermore, in our very preliminary tests with 250 labels in SVHN we noticed that optimization tended to explode during the ramp-up period, and we eventually found that using a lower value for Adam  parameter (e.g.,  instead of ) seems to help in this regard. 

We do not attempt to guarantee that the occurrence of labeled inputs during training would be somehow stratified; with bad luck there might be several consecutive minibatches without any labeled inputs when the label density is very low. Some previous work has identified this as a weakness, and have solved the issue by shuffling the input sequences in such a way that stratification is guaranteed, e.g.~\cite{ladder} (confirmed from the authors). This kind of stratification might further improve the convergence of our methods as well.

\textbf{Tiny Images, extra data from restricted categories\ \ \ }
The restricted extra data in Section~\ref{sec:tiny_images} was extracted from Tiny Images by picking all images with labels corresponding to the 100 categories used in CIFAR-100. As the Tiny Images dataset does not contain CIFAR-100 categories \emph{aquarium\_fish} and \emph{maple\_tree}, we used images with labels \emph{fish} and \emph{maple} instead. The result was a total of 237\,203 images that were used as unlabeled extra data. Table~\ref{tbl:cifarextra} shows the composition of this extra data set.

It is worth noting that the CIFAR-100 dataset itself is a subset of Tiny Images, and we did not explicitly prevent overlap between this extra set and CIFAR-100. This led to approximately a third of the CIFAR-100 training and test images being present as unlabeled inputs in the extra set. The other test with 500k extra entries picked randomly out of all 79 million images had a negligible overlap with CIFAR-100.

\begin{table}[t]
\centering
\caption{\label{tbl:cifarextra}The Tiny Images~\citep{Torralba2008} labels and image counts used in the CIFAR-100 plus restricted extra data tests (rightmost column of Table~\protect\ref{tbl:cifarc}). Note that the extra input images were supplied as unlabeled data for our networks, and the labels were used only for narrowing down the full set of 79 million images.\\
}
\small
\begin{tabular}{|LR|LR|LR|LR|}
\hline
Label & \# & Label & \# & Label & \# & Label & \# \\
\hline
apple & 2242 &baby & 2771 &bear & 2242 &beaver & 2116 \\
bed & 2767 &bee & 2193 &beetle & 2173 &bicycle & 2599 \\
bottle & 2212 &bowl & 2707 &boy & 2234 &bridge & 2274 \\
bus & 3068 &butterfly & 3036 &camel & 2121 &can & 2461 \\
castle & 3094 &caterpillar & 2382 &cattle & 2089 &chair & 2552 \\
chimpanzee & 1706 &clock & 2375 &cloud & 2390 &cockroach & 2318 \\
couch & 2171 &crab & 2735 &crocodile & 2712 &cup & 2287 \\
dinosaur & 2045 &dolphin & 2504 &elephant & 2794 &fish & 3082 \\
flatfish & 1504 &forest & 2244 &fox & 2684 &girl & 2204 \\
hamster & 2294 &house & 2320 &kangaroo & 2563 &keyboard & 1948 \\
lamp & 2242 &lawn\_mower & 1929 &leopard & 2139 &lion & 3045 \\
lizard & 2130 &lobster & 2136 &man & 2248 &maple & 2149 \\
motorcycle & 2168 &mountain & 2249 &mouse & 2128 &mushroom & 2390 \\
oak\_tree & 1995 &orange & 2650 &orchid & 1902 &otter & 2073 \\
palm\_tree & 2107 &pear & 2120 &pickup\_truck & 2478 &pine\_tree & 2341 \\
plain & 2198 &plate & 3109 &poppy & 2730 &porcupine & 1900 \\
possum & 2008 &rabbit & 2408 &raccoon & 2587 &ray & 2564 \\
road & 2862 &rocket & 2180 &rose & 2237 &sea & 2122 \\
seal & 2159 &shark & 2157 &shrew & 1826 &skunk & 2450 \\
skyscraper & 2298 &snail & 2369 &snake & 2989 &spider & 3024 \\
squirrel & 2374 &streetcar & 1905 &sunflower & 2761 &sweet\_pepper & 1983 \\
table & 3137 &tank & 1897 &telephone & 1889 &television & 2973 \\
tiger & 2603 &tractor & 1848 &train & 3020 &trout & 2726 \\
tulip & 2160 &turtle & 2438 &wardrobe & 2029 &whale & 2597 \\
willow\_tree & 2040 &wolf & 2423 &woman & 2446 &worm & 2945 \\
\hline
\end{tabular}
\end{table}

\end{document}
