This section starts with a short introduction to the Coq proof
assistant. It is followed by a brief presentation of the CompCert
architecture and memory model. The language our analyzer operates over
is described at the end of this section.

\subsection{Short Introduction to Coq}
Coq is an interactive theorem prover. It consists in a strongly typed
specification language and a language for conducting machine-checked
proofs interactively.  The Coq specification language is a functional
programming language as well as a language for inductively defining
mathematical properties, for which it has a dedicated type
(\lstinline!Prop!).  Induction principles are automatically generated
by Coq from inductive definitions, thus inductive reasoning is very
convenient.  Data structures may consist of properties together with
dependent types. Coq's type system includes type classes.  Coq
specifications are usually defined in a modular way (\eg using record
types and functors, that are functions operating over structured data
such as records). 
The user is in charge to interactively
build proofs in the system but those proofs are automatically
machine-checked by the Coq kernel. OCaml programs can be automatically
generated by Coq from Coq specifications. This process is called extraction.

\subsection{The CompCert Memory Model}\label{sec:compc-memory-model}

There are 11 languages in the CompCert compiler, including 9
intermediate languages. These languages feature both low-level aspects
such as pointers, pointer arithmetic and nested objects, and
high-level aspects such as separation and freshness guarantees.
A memory model~\cite{Leroy-Appel-Blazy-Stewart-memory-v2} is shared by the semantics of all these languages.
Memory states (of type \lstinline!mem!) are collections of blocks, each block being an array
of abstract bytes. A block represents a C variable or an invocation of \lstinline!malloc!.
Pointers are represented by pairs \lstinline!(b,i)! of a block identifier and
a byte offset  \lstinline!i! within this block.
Pointer arithmetic modifies the offset part of a pointer value,
keeping its block identifier part unchanged.




Values stored in memory are the disjoint union of 32-bit
integers (written as  \lstinline!vint(i)!), 64-bit floating-point numbers,
locations (written as \lstinline!vptr(b,i)!), and the special value \lstinline!undef! representing the
contents of uninitialized memory. Pointer values \lstinline!vptr(b,i)! are
composed of a block identifier \lstinline!b! and an integer byte offset \lstinline!i! within this block. 
Memory chunks appear in memory operations \lstinline!load! and
\lstinline!store!, to describe concisely the size, type and signedness of the value being stored.
\begin{syntaxleft}
\syntaxclass{Values:}
v & ::=  & {\tt vint}(i) \mid {\tt vfloat}(f) \mid {\tt vptr}(b,\ofs) \\
& \mid & {\tt undef}
\syntaxclass{Mem. chunks:}
\chunk & ::= & {\tt Mint8signed} \mid {\tt Mint8unsigned} & 8-bit integers \\
     & \mid& {\tt Mint16signed} \mid {\tt Mint16unsigned} & 16-bit integers \\
     & \mid& {\tt Mint32} & 32-bit integers or pointers \\
     & \mid& {\tt Mfloat32} & 32-bit floats \\
     & \mid& {\tt Mfloat64} & 64-bit floats
\end{syntaxleft}

In CompCert, a 32-bit integer (type \lstinline!int!) is defined as 
a Coq arbitrary-precision integer (type \lstinline!Z!) plus a property called
\lstinline!intrange! that it
is in the range $0$ to $2^{32}$ (excluded). 
The function
\lstinline!signed! (resp.~\lstinline!unsigned!) gives an interpretation of machine 
integers as a signed (resp.~unsigned) integer. The properties 
\lstinline{signed_range} and \lstinline{unsigned_range} are examples
of useful properties for machine integers.


\begin{lstlisting}
Definition max_unsigned : Z := $2^{32}$ - 1.  
Definition max_signed : Z := $2^{31}$  - 1.
Definition min_signed : Z := - $2^{31}$.
Record int := {   intval: Z;
                  intrange: 0 $\leq$ intval < $2^{32}$ }.
Definition unsigned (n: int) : Z := intval n.
Definition signed (n: int) : Z := if unsigned(n) < $2^{31}$ then unsigned(n) 
                                  else unsigned(n) - $2^{32}$.
Theorem signed_range: forall i, min_signed $\leq$ signed(i) $\leq$ max_signed.
  Proof.  (* Proof commands omitted here *)  Qed.
Theorem unsigned_range: forall i, 0 $\leq$ unsigned(i) $\leq$ max_unsigned.
  Proof.  (* Proof commands omitted here *)  Qed.
\end{lstlisting}


\subsection{The CFG Intermediate Language}

The main intermediate language of the CompCert compiler is called
Cminor, a low-level imperative language structured like C into
expressions, statements and functions. Historically, Cminor was the target
language of the compiler front-end. There are four main differences
with C~\cite{Leroy-backend}. First, arithmetic operators are not
overloaded. Second, address computations are explicit, as well as memory access
(using load and store operations). Third, control
structures are if-statements, infinite loops, nested blocks
plus associated exits and early returns. Last, local variables can only
hold scalar values and they do not reside in memory, making it
impossible to take a pointer to a local variable like the C operator
{\tt \&} does. Instead, each Cminor function declares the size of a
stack-allocated block, allocated in memory at function entry and
automatically freed at function return. 
The expression \lstinline!addrstack(n)! returns a pointer within that
block at constant offset \lstinline!n!.


Cminor was designed to be the privileged language for integrating within
CompCert other tools operating over C and other compiler front-ends. For
instance, two front-end compilers from functional languages to Cminor
have been connected to CompCert using Cminor, and a separation logic
has been defined for Cminor~\cite{Appel-Blazy-07}. 
The Concurrent Cminor language extends Cminor with concurrent features
and lies at the heart of the Verified Software Toolchain project~\cite{VST}.

As control-flow is still complex in Cminor (due to the presence of
nested blocks and exits), we have first designed a new
intermediate language called CFG that is adapted for static analysis:
1) its expressions are Cminor expressions (\ie side-effect free
C expressions), 2) its programs are represented by their control flow graphs, with
explicit program points and 3) the control flow is restricted to
simple unconditional and conditional jumps.
The CFG syntax is defined in Figure~\ref{fig:syntax}. Floating-point operators
are omitted in the figure, as our analysis does not compute any information about floats.
Statements include assignment to local variables, memory stores,
if-statements and function calls. 
Expressions include reading local variables, constants and arithmetic
operations, reading store locations, and conditional expressions. 
As in the memory model, loads and stores are parameterized by a memory
chunk $\chunk$.

\begin{figure}
\begin{syntaxleft}
\syntaxclass{Constants:}
 c & ::= & n \alt f & integer and floating-point constants\\
   & \alt & {\tt addrsymbol}(\id,n) &  address of a symbol plus an offset\\
   &\alt & {\tt addrstack}(n) & stack pointer plus a given offset

\syntaxclass{Expressions:}
a & ::=  & \id & variable identifier\\
  & \alt & c & constant\\
  & \alt & \op_1 ~ a & unary arithmetic operation\\
  & \alt & a_1 ~\op_2 ~ a_2 \ & binary arithmetic operation\\
  & \alt & a_1 ? ~ a_2 : a_3 \ & conditional expression\\
  & \alt & {\tt load} (\chunk,a) & memory load 

\syntaxclass{Unary op.:}
\op_1 & ::= & {\tt cast8unsigned} & 8-bit zero extension \\
 & \alt & {\tt cast8signed} & 8-bit sign extension \\
          & \alt & {\tt cast16unsigned} & 16-bit zero extension \\
          & \alt & {\tt cast16signed} & 16-bit sign extension \\
          & \alt & {\tt boolval} & 0 if null, 1 if non-null \\
          & \alt & {\tt negint} & integer opposite \\
          & \alt & {\tt notbool} & boolean negation \\
          & \alt & {\tt notint} & bitwise complement 

\syntaxclass{Binary op.:}
\op_2 & ::=  & \hbox{{\tt +}} \alt \hbox{{\tt -}} \alt \hbox{{\tt *}} \alt \hbox{{\tt /}} \alt \hbox{{\tt \%}}
               & arithmetic integer operators \\ 
      & \alt & \hbox{{\tt <\/<}} \alt \hbox{{\tt >\/>}} \alt 
               \hbox{{\tt \&}} \alt \hbox{{\tt {\char124}}} \alt \hbox{{\tt {\char94}}}
               & bitwise operators\\
          & \alt & \hbox{{\tt /}}_u \alt \hbox{{\tt \%}}_u \alt \hbox{{\tt >\/>}}_u & unsigned operators \\
          & \alt & {\tt cmp}(\cmp)  & integer signed comparisons\\
          & \alt & {\tt cmpu}(\cmp) & integer unsigned comparisons

\syntaxclass{Comparisons:}
\cmp &  ::=  & \hbox{{\tt <}} \alt \hbox{{\tt <=}} \alt \hbox{{\tt >}} \alt \hbox{{\tt >=}} 
               \alt \hbox{{\tt ==}} \alt \hbox{{\tt !=}}   & relational operators 

\syntaxclass{Statements:}
i & ::=  & {\tt skip} (l)& no operation (go to l)\\
  & \alt & {\tt assign} (\id,a, l) & assignment\\
  & \alt & {\tt store} (\chunk, a,a, l) & memory store \\ 
  & \alt & {\tt if} (e, l_{true}, l_{false})  & if statement\\
  & \alt & {\tt call} (\sig,\opt{\id}, a,a*,l) & function call \\
  & \alt & {\tt return} \opt{(a)} & function return

\end{syntaxleft}
\caption{Abstract syntax of CFG}
\label{fig:syntax}
\end{figure}



 
The CFG language is integrated into the CompCert compiler, as shown in Figure~\ref{fig:chain}.
There is a translation from Cminor to CFG and a theorem stating that
any terminating or diverging execution of a CFG program is also a
terminating or diverging execution of the original Cminor program.
Thus, instead of analyzing Cminor programs, we can analyze CFG programs
and use this theorem to propagate the results of the CFG analysis on Cminor programs.
For instance, in order to show that Cminor is memory safe, we only
need to show that CFG is memory safe. 






\begin{figure}
  \centering
\includegraphics[width=.8\textwidth]{CompCert_chain.pdf}  
\caption{Integration of the value analysis in the CompCert toolchain}
 \label{fig:chain}
\end{figure}

For the purpose of the experiments that we conduct in
Section~\ref{sec:exper-eval}, we use an inlining pass recently added
to the CompCert compiler. It was implemented and
proved correct by X.Leroy for another language
of the compiler, RTL, that is similar to CFG except
that it only handles flat expressions. Since our analysis operates on CFG, we have adapted this 
inlining pass to CFG. Adapting
the soundness proof of this transformation to CFG has been left for future work.

The concrete semantics of CFG is defined in small-step style as a
transition relation between execution states.  
An execution state is a tuple called $\sigma$. Among the components of
$\sigma$ are the current program point (\ie a node in the control-flow graph), 
the memory state (type \lstinline!mem!) and the environment
(type \lstinline!env!) mapping program variables to values.  
We use $\sigma.E$ to denote the environment of a state $\sigma$,
and ${\tt dom}(\sigma.E)$ to denote its domain (\ie the set of its
variables). We use 
$\reach{P}$ to denote the set of states belonging to the
execution trace of $P$.

Our value analysis (called {\tt \valanal{}}) computes
for each program point the estimated values of the program variables.
When the value of a variable is an integer \lstinline!i!  or a pointer
value of offset \lstinline!i!, the estimate provides two numerical
ranges \lstinline!signed_range! and
\lstinline!unsigned_range!. The first one over-approximates the signed interpretation of
\lstinline!i! and the other range over-approximates its unsigned
interpretation. We note \lstinline!ints_in_range (signed_range,unsigned_range) i! this fact.
Thus, given a program $P$,  $\valanal{}(P)$ yields a map
such that for each node $l$ in its control flow graph and
 each variable $v$,
$\valanal{}(P)[l,v]$ is a pair of sound ranges for $v$.
The following theorem states the soundness of the value analysis: for
every program state that may be reached during the execution of a program,
any program point and variable, every variable valuation computed
by the analysis is a correct estimation of the exact value
given by the concrete semantics.

\begin{theorem}[Soundness of the value analysis]
Let $P$ be a program, $\sigma\in\reach{P}$ and
$\res=\valanal{} (P)$ be the result of the value
analysis. Then, for each program point $l$, for
each local variable
$v\in{\tt dom}(\sigma.E)$
that contains an integer $i$ {\textup(}\ie
$  \sigma.E(v) = \mathtt{vint}(i) \vee \exists b, \sigma.E(v) = \mathtt{vptr}(b,i) ${\textup)},
the property $(\mathtt{ints\_in\_range}~\res[l,v] ~ i)$ holds. 
\end{theorem} 


\subsection{Overview of a Modular Value Analysis}

Our value analysis is designed in a modular way: a generic fixpoint iterator
operates over generic abstract domains (see Section~\ref{sec:abdom}). The iterator is based on the
state-of-the-art Bourdoncle~\cite{bourdoncle93} algorithm that provides both efficiency
and precision (see Section~\ref{sec:fixpoint}).

The modular design of the
abstract domains is inspired from the design of the Astrée analyzer. It
consists in three layers that are showed in Figure~\ref{fig:couches}. 
The simplest domains are numerical abstract domains made of intervals
of machine integers. These domains are not aware of the C memory model.

\begin{figure}
  \centering
\includegraphics[width=.8\textwidth]{modules.pdf}  
\caption{Design of abstract domains: a three-layer view \label{fig:couches}}
\end{figure}

In a C program, a same piece of data can be used both in signed and
unsigned operations, and the results of these operations differ from
one interpretation to the other.  Thus, we have two numerical abstract
domains, one for each interpretation.  Our analysis computes the
reduced product of the two domains in order to make a continuous
fruitful information exchange between these two domains (see Section~\ref{sec:num-abstract}).

Then, we build abstract domains representing numerical environments.
We provide a non-relational abstraction that is parameterized by a numerical abstract domain.
The last layer is the abstract domain representing memory. It is
parameterized by the previous layer and links
the abstract interpreter with the numerical abstract domains (see Section~\ref{sec:mem-abstract}). 

This modular design is targeted to connect at each layer other
abstract domains.  They are represented in dotted lines in
Figure~\ref{fig:couches}.  For example, several abstract memory models
can be used instead of the current one while maintaining the same
interfaces with the rest of the formal development.  The ultimate goal
is to enhance our current abstract interpreter in order to connect it to a memory
domain \emph{à la} Miné~\cite{mine-LCTES06}.  The current interfaces are
also compatible with any relational numerical abstract domain.  At
the top, more basic numerical abstractions as congruence could be
added and plugged into our reduced product.

