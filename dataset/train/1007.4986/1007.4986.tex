\documentclass{tlp}
\usepackage{aopmath}
\usepackage{amstext}
\usepackage{url}
\usepackage{times}
\usepackage{enumerate}
\usepackage{paralist}
\usepackage{ifpdf}
\ifpdf
\usepackage{microtype}
\fi

\title[Catching the Ouroboros: On Debugging Non-ground Answer-Set Programs]{Catching the Ouroboros: On Debugging Non-ground Answer-Set Programs}
\author[J. Oetsch, J. P\"uhrer, and H. Tompits]{JOHANNES OETSCH, J\"ORG P\"UHRER, AND HANS TOMPITS\thanks{This work was partially supported by the Austrian Science Fund~(FWF) under grant P21698.} \\ 
Technische Universit\"at Wien,\\
Institut f\"ur Informationssysteme~184/3,\\
Favoritenstrasse 9-11, A-1040 Vienna,
Austria,\\
\email{\{oetsch,puehrer,tompits\}@kr.tuwien.ac.at}}



\newcommand{\meta}{\Gamma}
\newcommand{\reif}[1]{\Delta(#1)}
\renewcommand{\L}{\mathcal{L}}
\renewcommand{\P}{\mathcal{P}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\V}{\mathcal{V}}

\newcommand{\commadots}{,\ldots,}
\newcommand{\constant}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\naf}{\mathrm{not}}
\newcommand{\posbody}{B^{+}}
\newcommand{\negbody}{B^{-}}
\newcommand{\head}{H}
\newcommand{\grd}{\mathit{ground}}
\renewcommand{\grd}{\mathit{grd}}
\newcommand{\subst}{\vartheta}
\newcommand{\HB}{\mathcal{B}}
\newcommand{\HU}{\mathcal{U}}

\newcommand{\resp}{resp.,\ }
\newcommand{\wrt}{with respect to}
\newcommand{\iec}{i.e.,\ }
\newcommand{\egc}{e.g.,\ }
\newcommand{\etal}{\emph{et al.\ }}



\newcommand{\NP}{\mbox{NP}}
\newcommand{\coNP}{\mbox{co-NP}}
\newcommand{\D}{\mbox{D}}
\newcommand{\Poly}{\mbox{P}}

\newcommand{\clasp}{{\it clasp}}
\newcommand{\dlv}{{\it DLV}}
\newcommand{\gnt}{{\it GnT}}

\newcommand{\pair}[1]{\ensuremath{\langle #1 \rangle}}



\newcommand{\nop}[1]{}          

\newcommand{\reifsymb}{\varrho}          \newcommand{\reifrule}[1]{\reifsymb_\mathit{rule}(#1)}          \newcommand{\reifprg}[1]{\reifsymb_\mathit{prg}(#1)}          \newcommand{\reifint}[1]{\reifsymb_\mathit{int}(#1)}          


\newcommand{\INPUT}{\reif{P,I}}          

\newcommand{\Unsat}{\mathit{UNSAT}} \newcommand{\UnsatGuess}{\mathit{UNSAT_{guess}}} \newcommand{\UnsatCheck}{\mathit{UNSAT_{check}}} \newcommand{\UnsatAux}{\mathit{UNSAT_{aux}}} \renewcommand{\Unsat}{\gamma_\mathit{unsat}} \renewcommand{\UnsatGuess}{\Unsat^\mathit{guess}} \renewcommand{\UnsatCheck}{\Unsat^\mathit{check}} \renewcommand{\UnsatAux}{\Unsat^\mathit{aux}} 

\newcommand{\Loop}{\mathit{LOOP}} \newcommand{\LoopGuess}{\mathit{LOOP_{guess}}} \newcommand{\LoopCheck}{\mathit{LOOP_{check}}} \newcommand{\LoopAux}{\mathit{LOOP_{aux}}} \renewcommand{\Loop}{\gamma_\mathit{loop}} \renewcommand{\LoopGuess}{\Loop^\mathit{guess}} \renewcommand{\LoopCheck}{\Loop^\mathit{check}} \renewcommand{\LoopAux}{\Loop^\mathit{aux}} 



\newcommand{\Support}{\mathit{SUPPORT}} \newcommand{\SupportGuess}{\mathit{SUPPORT_{guess}}} \newcommand{\SupportCheck}{\mathit{SUPPORT_{check}}} \newcommand{\SupportAux}{\mathit{SUPPORT_{aux}}} \renewcommand{\Support}{\gamma_\mathit{unfd}} \renewcommand{\SupportGuess}{\Support^\mathit{guess}} \renewcommand{\SupportCheck}{\Support^\mathit{check}} \renewcommand{\SupportAux}{\Support^\mathit{aux}} 


\newcommand{\Cons}{\mathit{CONS}}
\renewcommand{\Cons}{\gamma_\mathit{cons}}

\renewcommand{\mathit}[1]{{\text{\it{#1}}}}



\newtheorem{definition}{Definition}
\newtheorem{question}{Question}
\newtheorem{problem}{Problem}



\begin{document}
\label{firstpage}

\submitted{7 February 2010}
\revised{{\rm (}n/a{\rm )}}
\accepted{20 March 2010}

\maketitle



\begin{abstract}
An important issue towards a broader acceptance of answer-set programming (ASP) is the deployment of tools which support the programmer during the coding phase. In particular, methods for \emph{debugging} an answer-set program are recognised as a crucial step in this regard. Initial work on debugging in ASP mainly focused on propositional programs, yet practical debuggers need to handle programs with variables as well. In this paper, we discuss a debugging technique that is directly geared towards non-ground programs. Following previous work, we address the central debugging question why some interpretation is not an answer set. The explanations provided by our method are computed by means of a meta-programming technique, using a uniform encoding of a debugging request in terms of ASP itself. Our method also permits programs containing comparison predicates and integer arithmetics, thus covering a relevant language class commonly supported by all state-of-the-art ASP solvers.
 \end{abstract}

\begin{keywords}
answer-set programming, program analysis, debugging
\end{keywords}

\section{Introduction}

During the last decade, answer-set programming (ASP) has become a well-acknowledged paradigm for 
declarative problem solving. 
Although there exist efficient solvers (see, \egc \citeANP{competition09}~\citeyear{competition09} for an overview) and  a considerable body of literature 
concerning the theoretical foundations of ASP,
 comparably little effort has been spent
on methods to support the development of ASP programs.
Especially novice  programmers, tempted by the intuitive semantics and expressive power of 
ASP, may get disappointed and discouraged soon when
some observed program behaviour diverges from his or her expectations. 
Unlike for other programming languages like Java or C++, there is currently little support for \emph{debugging} a program
 in ASP, \iec  methods to \emph{explain} and \emph{localise} unexpected observations. This  is a clear  shortcoming of ASP and work in this direction has already started~\cite{brain05,syrjaenen06,brain07,mirek07,CaballeroGS08,gebser08,pontelli09,WittocxVD09}.

Most of the current debugging approaches for ASP rely on declarative strategies, focusing on \emph{conceptual errors} of programs, \iec mismatches between the intended meaning and the actual meaning of a program.
In fact, an elegant realisation of declarative debugging is to use ASP itself to debug  programs in ASP. This has been put forth, \egc in the approaches of \citeANP{brain07}~\citeyear{brain07} and \citeANP{gebser08}~\citeyear{gebser08}.
While the former uses a ``tagging'' method to decompose a program and applying various debugging queries, the latter is based on a meta-programming technique, \iec using a program over a meta-language to manipulate a program over an object language (in this case, both the meta-language and the object language are instances of ASP).
Such techniques have the obvious benefits of allowing (i)~to use reliable state-of-the-art ASP solvers as back-end reasoning engines and (ii)~to stay within the same paradigm for both the programming and debugging process.
Indeed, both approaches are realised by the system \texttt{spock}~\cite{spock07}.
However, like most other ASP debugging proposals, \texttt{spock} can deal only with propositional programs which is clearly a limiting factor as far as practical applications are concerned.

In this paper, we present a debugging method for non-ground programs following the methodology of the meta-programming approach of \citeANP{gebser08}~\citeyear{gebser08} for propositional programs.
That is to say, we deal with the problem of finding reasons why some interpretation is \emph{not} an answer set of a given program.
This is addressed by referring to a model-theoretic
characterisation of answer sets due to \citeANP{lee05} \citeyear{lee05}:
An interpretation  is not an answer set of a 
program  iff
(i)~some rule in  is not classically satisfied by  or
(ii)~ contains some loop of  that is unfounded by   \wrt\ .
Intuitively,  Item~(ii) states that some atoms in  are not justified by  in the  sense that
no rules in  can derive them or that some atoms are in  only because they are derived by a set of rules in a  circular way---like the \emph{Ouroboros}, the ancient symbol of a dragon biting its own tail that represents cyclicality and eternity.
This characterisation seems to be quite natural and intuitive for \emph{explaining}
why some interpretation is not an answer set. 
Furthermore, a particular 
benefit is that it can ease the subsequent  \emph{localisation} of errors
since the witnesses why an interpretation is not an answer set, like
rules which are not satisfied, unfounded atoms,  or cyclic rules  responsible for unfounded loops,
can be located in the program or the interpretation.

Although, at first glance, one may be inclined to directly apply the original approach of \citeANP{gebser08}~\citeyear{gebser08}
to programs with variables by simply
grounding them in a preprocessing step, one problem in such an endeavour is that then it is not immediate clear how to 
relate explanations for the propositional program to the non-ground program. The more severe problem, however,
is that the grounding step requires exponential space and time \wrt\ the size of the problem instance which yields a mismatch of the overall complexity as
checking whether an interpretation is an answer set of some (non-ground) program is complete
for ~\cite{eiter04}, and thus the complementary problem why some interpretation is not
an answer set is complete for ---our method to decide this problem accounts
for this complexity bound and avoids exponential space requirements.
Indeed, we devise a \emph{uniform} encoding of our basic debugging problem in terms of a \emph{fixed} disjunctive logic program  and an efficient reification of 
a problem instance as a set  of facts, where  is the program to be debugged and  is the interpretation under consideration.
Explanations why  is not an answer set of  are then obtained by the answer sets of .

We stress that the definition of   is  non-trivial: while the meta-program in the approach of \citeANP{gebser08}~\citeyear{gebser08} for debugging propositional disjunctive programs
could be achieved in terms of a normal non-ground program, \emph{by uniformly encoding a  property, we reach the very limits of disjunctive ASP} and have to rely on advanced saturation techniques that inherently require disjunctions in rule heads~\cite{eiter97}.

Currently, our approach handles disjunctive logic programs with  constraints,
integer arithmetic, comparison predicates, and strong negation, thus covering 
a practically relevant program class. Further language constructs, in particular
aggregates and weak constraints, are left for future work.


\section{Preliminaries}\label{sec:prel}

We deal with \emph{disjunctive logic programs}  which are finite sets of rules of form

where , ``'' denotes \emph{default negation}, and  all  are literals over 
a function-free first-order language . A literal is an atom possibly preceded by the \emph{strong negation} symbol .
In the sequel, we assume that  will be implicitly defined by the considered programs.
For a rule  as above, we define the \emph{head}  of  as , 
the \emph{positive body} as , and  the \emph{negative body} as . 
If ,
  is a \emph{fact}; if  contains no disjunction,  is \emph{normal}; and
if  and ,
 is a \emph{constraint}. For facts, we will omit the symbol .
A literal, rule, or program is \emph{ground} if it contains no variables.
Furthermore, a program is normal if all rules in it are normal. 
Finally, we allow arithmetic and comparison predicate symbols , , , , , , , and~ in programs, but these may appear only positively in rule bodies.

Let  be a set of constants. A \emph{substitution over}  is a function  assigning each variable an element of .
We denote by  the result of applying  to an expression .
The \emph{grounding} of a  program  relative to its Herbrand universe, denoted by , is defined as usual.

An \emph{interpretation}  (over some language ) is a finite and consistent set of ground literals (over ) that does not contain any arithmetic or comparison predicates.
Recall that consistency means that , for any atom .
The satisfaction relation, , between  and a ground atom, a literal, 
a rule, a set of literals, or a program  is defined in the usual manner.
Note that the presence of arithmetic and comparison operators implies that the domain of our language will normally include natural numbers as well as a linear ordering, , 
for evaluating the comparison relations (which coincides with the usual ordering in case of constants which are natural numbers).

For any ground program  and any interpretation , the \emph{reduct}, , of  \wrt\  \cite{gelfond91}
is defined as 
.
An interpretation  is an \emph{answer set} of a program  iff  is  a minimal model of .


We will base our subsequent elaboration on an alternative characterisation of answer sets following \citeN{lee05}, described next.
Given a program ,  the \emph{positive dependency graph} is a directed
graph , where 
(i)~ equals the Herbrand base of the considered language  and
(ii)~ iff  and , for some rule .
A non-empty set  of ground literals is  a \emph{loop}\footnote{Note that loops have first been studied by \citeANP{lin04}~\citeyear{lin04}; different definitions of loops for non-ground programs were given by \citeANP{chen06}~\citeyear{chen06} and \citeANP{lee08}~\citeyear{lee08}.
For our purposes, it suffices to refer to the basic definition for ground programs.} of  a  program  iff,
for each pair ,
there is a path  of length greater than or equal to 0 from  to 
in the positive dependency graph of  such that each literal in 
is in . 

Let  be a program and  and  interpretations. Then,
 is \emph{externally supported by  \wrt\ } iff
there is a rule  
such that
(i)~ and ,
(ii)~,
(iii)~, and
(iv)~.

Intuitively, Items (i)--(iii) express that  is supported by  \wrt\ , in the sense that the grounding of  contains some rule  whose body is satisfied by  (Item~(i)) and which is able to derive some literal in  (Item~(ii)), while all head atoms of  not contained in  are false under .
Moreover, Item~(iv) ensures that this support is external as it is without
reference to the set  itself.

Answer sets are now characterised thus:

\begin{proposition}[\citeNPS{lee05}]\label{prop:lee05}
Let  be a program and  an interpretation. Then,
 is an answer set of  iff
{\rm (}i{\rm )}~ and
{\rm (}ii{\rm )}~every loop of  that is contained in  is externally supported by  \wrt~.
\end{proposition}

We actually make mainly use of the complementary relation of external support: Following \citeN{LeoneRS97}, we call  \emph{unfounded by  \wrt\ } iff  is not externally supported by 
 \wrt\ . 

\section{The basic debugging approach}

As discussed in the introduction, 
we view  an error as a mismatch between the intended answer sets and the observed actual answer sets of some program. 
More specifically, our basic debugging question is why a given interpretation  is not answer set of some program , and
thus we deal with  finding explanations for  not being an answer set of .
Proposition~\ref{prop:lee05} allows us to distinguish between two kinds of such explanations:
(i)~instantiations of rules in  that are not satisfied by  and (ii)~loops of  in  that are unfounded by  \wrt\ .
Although our basic debugging question
allows for different, multi-faceted, answers,
we see two major benefits of referring to this kind of  categorisation:
First, in view of Proposition~\ref{prop:lee05}, these kinds of explanations are
always sufficient to explain why  is not an answer set of , and second,
this method provides \emph{concrete witnesses}, \egc unsatisfied rules or unfounded atoms,
that can help to localise the reason for an error in a program or an interpretation in a rather intuitive way.

Before we introduce the details of our approach, we discuss its virtues compared to a method for debugging non-ground programs which can be obtained using the previous meta-programming technique for propositional programs due to \citeN{gebser08}.

\subsection{Prelude: A case for directly debugging non-ground programs}

Explaining why some interpretation is not an answer set of some program based on the characterisation of \citeN{lee05} has been dealt with in previous work for 
debugging propositional disjunctive logic programs~\cite{gebser08}. 
In principle, we could use this method for debugging non-ground programs as well by employing a preparatory  grounding step.
However, such an undertaking comes at a higher computational cost compared to our approach which respects the
inherent complexity of the underlying tasks.
We lay down our arguments in what follows.

To begin with, let us recall that \citeN{gebser08}
defined a fixed normal non-ground program   and a mapping  from disjunctive propositional programs  and interpretations 
to sets of facts. 
Given a disjunctive program  without variables and some interpretation , explanations
why  is not an answer set of  can then be extracted from the answer sets of . 
Such a problem encoding is 
\emph{uniform} in the sense that  does not depend on the problem instance determined by  and .

To find reasons why some interpretation  is not an answer set of a non-ground program , 
the above approach can be used by computing the answer sets of .
However, in general, the size of  is exponential in the size of , and the computation 
of the answer sets of a ground program requires exponential time with respect
to the size of the program, unless the polynomial hierarchy collapses.
Hence, this outlined approach to compute explanations using a grounding step requires, all in all, \emph{exponential space} and \emph{double-exponential time} with respect to the size of .
But this is a mismatch to the inherent complexity of the overall task, as the following result shows: 

\begin{proposition}
\label{prop:complexity}
Given a program  and an interpretation , deciding whether  is not an answer set of  is -complete. 
\end{proposition}
This property is a consequence of the well-known fact that the complementary problem, \iec checking whether some given interpretation is an answer set of some program, is -complete~\cite{eiter04}.
Hence, checking whether an interpretation is not an answer set of some program 
can be computed in \emph{polynomial space}.

Our approach takes this complexity property into account.  We exploit the expressive power of disjunctive non-ground ASP by providing a
uniform encoding that avoids both exponential space and double-exponential time requirements:
Given a program  and an interpretation , we define an encoding , where  is a fixed disjunctive non-ground program, and  is an efficient encoding  of  and  by means of facts.
Explanations why  is not an answer set of  are determined by the answer sets of .
Since  is fixed, the grounding of  is bounded by a polynomial in the size of  and . Thus, our
approach requires only polynomial space and single-exponential time with respect to  and .

Note that disjunctions can presumably not be avoided in  due to the  -hardness of 
deciding whether an interpretation is not an answer set of some program.
One may ask, however, whether  could be normal in case  is normal.
We have to answer in the negative: answer-set checking for normal programs is complete for , 
even if no negation is used or negation is only used in a stratified way~\cite{eiter04}.
(We recall that  is the class of problems that  can be  decided by a conjunction
of an  and an independent   property.)
Hence,  cannot be normal unless .
However, one could use two independent normal meta-programs to encode our desired task.

A further benefit of debugging a program  directly at the non-ground level is that we can immediately 
relate explanations for errors to first-order expressions in  the considered program,
\egc to rules or literals with variables instead
of their ground instantiations.

In what follows, we give details of  and  and describe their main properties.

\subsection{Construction of the meta-program}
\subsubsection{Reification of input instances}
For realising the encoding  for program  and interpretation ,
we rely on a reification  of  and a reification  of .
The former is, in turn, constructed from reifications  of each individual rule .
We introduce the mappings , , and  in the following.

To begin with, we need unique names for certain language elements.
By an \emph{extended predicate symbol} (EPS) we understand a predicate symbol, possibly preceded by  
the symbol for strong negation.
Let 
 be an injective \emph{labelling function} from the set of program rules, literals, EPSs, and variables to a set of labels
from the symbols in our language . 
Note that we do not need labels for constant symbols since they will serve as unique names for themselves.

A single program rule  is reified by means of facts according to the following definition.
\begin{definition}
Let   be a rule. Then,
\begin{center}

a = L(x_{1},\ldots,x_{n})rLa\!=\!L(x_{1},\ldots, x_{n})rLi \in \{1, \ldots, n\}x_{i}a = L(x_{1},\ldots, x_{n})rLi \in \{1, \ldots, n\}x_{i}xr
\end{center}
\end{definition}
The first fact states that label  denotes a rule.
The next three sets of facts associate labels of the literals in the head, the positive body, and the negative body
to the respective parts of~.
Then, each label of some literal in  is associated with a label for its  EPS.
The following two sets of facts encode the positions of variables and constants in the literals of the rule.
Finally, the last set of facts states which variables occur in the rule .



A program is encoded as follows:
\begin{definition}
Let  be a program. Then, 
\begin{center}
cPL(x_1, \ldots, x_n)PL
\end{center}
\end{definition}

 The first union of facts stem from the reification of the single rules in the program.
The remaining facts  represent the Herbrand universe of the program and 
associate the EPSs occurring in the program with their
arities.

The translation from an interpretation to a set of facts is formalised by the next definition.
\begin{definition}
Let   be an interpretation. Then, 
\begin{center}
a = L(x_{1}, \ldots, x_{n})ILa = L(x_{1},\ldots, x_{n})ILi \in \{1, \ldots, n\}x_{i}
\end{center}
\end{definition}

The first two sets of facts associate the literals in   with their respective labels and 
EPSs.
The last set of facts reifies the internal structure of the literals occurring in . 

\begin{definition}
Let  be a program and  an interpretation. 
Furthermore, let  be the  the maximum of  and the arities of all predicate symbols in .
Then, .

\end{definition}
The literals   are necessary  to add sufficiently many natural numbers to the Herbrand universe of  to carry out correctly all computations in the subsequent program encodings. 
Note that the size of   is always linear in the size
of  and~.

\begin{figure}[t]
\begin{small}
\hrule
.3em]
\UnsatCheck  =  \{ &   \mathit{unsatisfied} \leftarrow  \mathit{satBody}, \naf\ \mathit{satHead},
\\
&
\mathit{satBody} \leftarrow  \naf\ \mathit{unsatPosbody}, \naf\ \mathit{unsatNegbody},\\
&\mathit{satHead}      \leftarrow \mathit{guessRule}(R), \mathit{head}(R,A), \mathit{true}(A),\\
&\mathit{unsatPosbody} \leftarrow \mathit{guessRule}(R),\mathit{posbody}(R,A), 
             \mathit{false}(A),\\
&\begin{array}{@{}r}
\mathit{unsatNegbody} \leftarrow \mathit{guessRule}(R),\mathit{negbody}(R,A), 
                          \mathit{true}(A) \}\mbox{.}
\end{array}
\end{array}\begin{array}{r@{}l}
 \LoopGuess  =  \{ & \mathit{inLoop}(X) \vee \mathit{outLoop}(X) \leftarrow \mathit{int}(X),
\\
&
\mathit{someInLoop} \leftarrow \mathit{inLoop}(X),
\\
&
\leftarrow \naf\ \mathit{someInLoop}, \mathit{int}(X) \}\mbox{.}\
\hrule
\end{small}
\caption{Modules  and  \label{fig:LOOP}.}
\end{figure}
\end{definition}


Intuitively, for a program  and an interpretation ,
  guesses  a non-empty subset  of , represented by  , 
as  a candidate for a loop, and
 defines that  holds if  is a loop of .
More specifically, this check is realised as follows.
Assume  contains  literals.


\begin{enumerate}
\item Guess a set  of  pairs , where  is a rule from  and  is a substitution over the Herbrand universe of .

\item Check, for each , whether there is a path  
in the positive dependency graph of the ground program consisting of rules 
 such that
 starts with   and ends with , and
all literals in  are in . 
A path  is represented by the binary  predicate .
\end{enumerate}

Module  (again omitted for space reasons) defines that (i)~ holds if  and (ii)~ holds  if , where  ,  are literals and
 is the substitution stemming from a pair in  that is associated with an index  by .

\begin{theorem}\label{thm:loop}
For any program  and any interpretation ,
 is a loop of  iff,
for some answer set  of ,  and .
\end{theorem}



We proceed with module  for
checking whether some set  
of ground literals  is unfounded by  \wrt\ an interpretation .  
We later combine this  check  with  to
identify unfounded loops, \iec we will integrate a loop guess with a  check, thus reaching the very limits of disjunctive ASP by uniformly
encoding a  property. 



\begin{figure}[t]
\begin{small}
\hrule
.3em]
\SupportCheck  =  \{ &
\mathit{unfounded} \leftarrow \mathit{unsupp}(R), \mathit{lastR}(R),\\
&\mathit{unsupp}(R)   \leftarrow \mathit{firstR}(R), \mathit{unsuppRule}(R),\\
&\mathit{unsupp}(R_{2})  \leftarrow \mathit{succR}(R_{1},R_{2}), \mathit{unsupp}(R_{1}), \mathit{unsuppRule}(R_{2}),\\
& \mathit{saturate} \leftarrow \mathit{unfounded},\\
 &\mathit{suppSubst}(X,C)  \leftarrow \mathit{variable}(X),\mathit{dom}(C), \mathit{saturate},\\
&\mathit{nsuppSubst}(X,C) \leftarrow \mathit{variable}(X),\mathit{dom}(C), \mathit{saturate}\ \}\cup\\
\{&\mathit{unsuppRule}(R) \leftarrow c_{i}(R) \mid i \in \{1,\ldots, 5\}\}\mbox{.}
\end{array}
\begin{array}{r@{}l}
S_{1} = 
\{& \mathit{pc}(m_1), \mathit{pc}(m_2), \mathit{paper}(p_1), \mathit{bid}(m_1,p_1,2),
\mathit{bid}(m_2,p_1,3), 
 \\&
\mathit{some\_bid}(m_1,p_1), \mathit{some\_bid}(m_2,p_1)  \}\mbox{.} 
\end{array}
E_{1} = (S_{1} \cup \{\mathit{bid}(m_2,p_1,1)\}) \setminus 
            \{ \mathit{some\_bid}(m_2,p_1), \mathit{bid}(m_2,p_1,3)\}r_{1} = \mathit{some\_bid}(M,P) \leftarrow \mathit{bid}(M,P,X)\mbox{.}r_{2} = \mathit{bid}(M,P,1) \leftarrow \naf\ \mathit{some\_bid}(M,P), \mathit{pc}(M),  \mathit{paper}(P)\mbox{.}\mathit{some\_bid}(M,P) \leftarrow \mathit{bid}(M,P,X), X \neq 1\mbox{.}E_{3} = (S_{3} \cup \{\neg\mathit{assigned}(p_1,m_2)\}) \setminus \{\mathit{assigned}(p_1,m_2)\}\leftarrow \mathit{paper}(P), \mathit{pc}(M), \naf\ \mathit{at\_least\_one}(P)
\quad\mbox{and}\quad
\mathit{at\_least\_one}(P) \leftarrow \mathit{assigned}(P,M)\mbox{.}S_{4}=\{\mathit{assigned}(p_1,m_1),\mathit{pc}(m_1),
\mathit{paper}(p_1),
\mathit{author}(p_1,m_1),\mathit{bid}(m_1,p_1,2) \}\mbox{.}E_{4} = S_{4} \cup \{\mathit{conflict\_of\_interest}(m_1,p_1),\mathit{bid}(m_1,p_1,0)\}\{\mathit{conflict\_of\_interest}(m_1,p_1),\mathit{bid}(m_1,p_1,0)\}\mathit{conflict\_of\_interest}(M,P)  \leftarrow \mathit{pc}(M), \mathit{paper}(P), \mathit{author}(M,P)
that should support  because all the facts , , and  should
be contained in . Now, the error is obvious:  does not contain the fact  but ---the order of the arguments was wrong.
After Peppermint Patty fixed that bug, her program is correct.  

\subsection{Some pragmatic issues and future prospects}


For a debugging system of practical value, certain pragmatic aspects have to be taken into account which we briefly sketch in what follows.
To start with, our encodings can be seen as a ``golden design''---tailored towards
clarity and readability---which leaves room for optimisations. 
Related to this issue, solver features like limiting the number of computed answer sets or query answering 
are needed to avoid unnecessary computation and to limit the amount of information presented to the user. 

Our debugging approach requires information about the intended semantics in form of
the interpretation representing a desired answer set.
Typically, answer sets of programs encoding real-world problems tend to  be large
which makes it quite cumbersome to manually create interpretations  from scratch.
It is therefore vital to have convenient means
for obtaining  an intended answer set in the first place.
For this purpose, we envisage a tool-box for managing  interpretations that allows
for their manipulation and storage. 
In such a setting, answer sets of previous versions of the debugged program could be a valuable source of  interpretations which are then tailored towards an intended answer set of the current version.
In addition to manual adaptations, partial evaluation of the program could significantly accelerate the creation of interpretations. 
We plan to further investigate these issues and
aim at incorporating our debugging technique, along with an interpretation management system as outlined, in an integrated development environment (IDE).
Here, an important issue is to achieve a suitable user interface for highlighting the identified unsatisfied rules and unfounded loops  in the source code and for visualising the involved variable substitutions.

\section{Related work}

Besides the debugging approach by \citeN{gebser08}, as already discussed earlier, other related approaches on debugging include the work of \citeANP{pontelli09} \citeyear{pontelli09} on \emph{justifications} for non-ground answer-set programs that can be seen as a complementary approach to ours.
Their goal is to explain the truth values of literals with respect to a given actual answer set of a program.
Explanations are provided in terms of \emph{justifications} which are labelled graphs
whose nodes are truth assignments of possibly default-negated ground atoms.
The edges represent positive and negative support relations between these truth assignments such that every path ends in an assignment which is either assumed or known to hold.
The authors have also introduced justifications for partial answer sets that emerge during the solving process (online justifications), being represented by three-valued interpretations.

The question why atoms are contained or are not contained in an answer set has also been raised by \citeANP{brain05} \citeyear{brain05} who provide algorithms for recursively computing explanations in terms of satisfied supporting rules.
Note that these problems can in principle also be handled by our approach, as illustrated in Section~\ref{sec:peanuts}.
Indeed, consider some program  with answer set  and suppose we want to know why a certain set  of literals is contained in .
Using our approach, explanations why  is not an answer set of  will reveal rules which are unsatisfied under  but which support literals in  under .
Likewise, we can answer the question why expected atoms are missing in an answer set. 

\citeN{syrjaenen06} aims at finding explanations why some propositional program has no answer sets. 
His approach is based on finding minimal sets of constraints such that their removal yields consistency.
Hereby, it is assumed that a program does not involve circular dependencies
between literals through an odd number of negations which might also cause inconsistency.
Finding reasons for program inconsistency can be  handled by our approach when an intended answer set is known, as illustrated by program  in Section~\ref{sec:peanuts}.
Otherwise, an interpretation can be chosen from the answer sets resulting from temporarily removing all constraints from the considered program (providing this yields consistency). 


\citeN{brain07} rewrite a program using some additional control
atoms, called \emph{tags}, that allow, e.g., for switching individual rules on or off and for analysing the resulting answer sets.
Debugging requests in this approach can be posed by adding further rules that can employ tags as well.
One such extension allows also for detecting atoms in unfounded loops.
However, as opposed to our current approach, the individual loops themselves are not identified.

\citeN{CaballeroGS08} developed a declarative debugging approach for datalog
using a classification of error explanations similar to the one by \citeN{gebser08} and our current work.
Their approach is tailored towards query answering  and,
in contrast to our approach, the language is restricted to stratified datalog. 
However, \citeANP{CaballeroGS08} provide an implementation that is based on computing
a graph that reflects the execution of a query.


\citeN{WittocxVD09} show how a calculus can be used for
debugging  first-order theories with inductive definitions in the context of model expansion problems, \iec problems of finding models of a given theory that expand some given interpretation. 
The idea is to trace the proof of inconsistency of such an unsatisfiable model expansion problem.
The authors provide a system that allows for interactively exploring the proof tree.

Besides the mentioned approaches which rely on the semantical behaviour of programs, \citeANP{mirek07} \citeyear{mirek07} use a translation from logic-program rules to natural language in order to detect program errors more easily.
This seems to be a potentially useful feature for an IDE as well, especially for novice and non-expert ASP programmers.

\section{Conclusion}


Our approach for declaratively debugging non-ground an\-swer-set programs
aims at providing intuitive explanations why a given interpretation fails to be an
answer set of the program in development.
To answer this question, we localise, on the one hand, unsatisfied rules
and, on the other hand, loops of the program that are unfounded with respect
to the given interpretation.
As underlying technique, we use a sophisticated meta-programming method
that reflects the complexity of the considered debugging question
which resides on the second level of the polynomial hierarchy.

Typical errors in ASP may have quite different reasons and
many of them could be avoided rather easily in the first place, \egc 
by a compulsory declaration of predicates \cite{brain05},
forbidding uneven loops through negation~\cite{syrjaenen06}, 
introducing type checks, or  defining
program interfaces. 
We plan to realise these kinds of simple prophylactic techniques for our future IDE for ASP that will incorporate our current debugging approach.
In this context,  courses on logic programming at our institute shall provide a permanent testbed for our techniques.
Moreover, as part of an ongoing research project on methods and methodologies for developing answer-set programs~\cite{mmdasp}, we want to put research efforts into methodologies that avoid or minimise debugging needs right from the start.
As a next direct step regarding our  efforts towards debugging,
we plan to extend our approach to language features like aggregates, function symbols, and optimisation techniques such as minimise-statements or weak constraints.






\begin{thebibliography}{}

\bibitem[\protect\citeauthoryear{Brain and {De~Vos}}{Brain and
  {De~Vos}}{2005}]{brain05}
{\sc Brain, M.} {\sc and} {\sc {De~Vos}, M.} 2005.
\newblock Debugging logic programs under the answer-set semantics.
\newblock In {\em Proceedings of the 3rd Workshop on Answer Set Programming:
  Advances in Theory and Implementation {\rm (}ASP'05{\rm )}, Bath, UK, July
  27-29, 2005}. CEUR Workshop Proceedings, vol. 142. CEUR-WS.org, Aachen,
  Germany.

\bibitem[\protect\citeauthoryear{Brain, Gebser, P{\"u}hrer, Schaub, Tompits,
  and Woltran}{Brain et~al\mbox{.}}{2007}]{brain07}
{\sc Brain, M.}, {\sc Gebser, M.}, {\sc P{\"u}hrer, J.}, {\sc Schaub, T.}, {\sc
  Tompits, H.}, {\sc and} {\sc Woltran, S.} 2007.
\newblock Debugging {ASP} programs by means of {ASP}.
\newblock In {\em Proceedings of the 9th International Conference on Logic
  Programming and Nonmonotonic Reasoning {\rm (}LPNMR'07{\rm )}, Tempe, {AZ},
  {USA}, May 15-17, 2007}, {C.~Baral}, {G.~Brewka}, {and} {J.~S. Schlipf}, Eds.
  Lecture Notes in Computer Science, vol. 4483. Springer, Berlin-Heidelberg,
  Germany, 31--43.

\bibitem[\protect\citeauthoryear{Caballero, Garc\'{\i}a-Ruiz, and
  S{\'a}enz-P{\'e}rez}{Caballero et~al\mbox{.}}{2008}]{CaballeroGS08}
{\sc Caballero, R.}, {\sc Garc\'{\i}a-Ruiz, Y.}, {\sc and} {\sc
  S{\'a}enz-P{\'e}rez, F.} 2008.
\newblock A theoretical framework for the declarative debugging of datalog
  programs.
\newblock In {\em Revised Selected Papers of the 3rd International Workshop on
  Semantics in Data and Knowledge Bases {\rm (}SDKB'08{\rm )}, Nantes, France,
  March~29, 2008}, {K.-D. Schewe} {and} {B.~Thalheim}, Eds. Lecture Notes in
  Computer Science, vol. 4925. Springer, Berlin-Heidelberg, Germany, 143--159.

\bibitem[\protect\citeauthoryear{Chen, Lin, Wang, and Zhang}{Chen
  et~al\mbox{.}}{2006}]{chen06}
{\sc Chen, Y.}, {\sc Lin, F.}, {\sc Wang, Y.}, {\sc and} {\sc Zhang, M.} 2006.
\newblock First-order loop formulas for normal logic programs.
\newblock In {\em Proceedings of the 10th International Conference on
  Principles of Knowledge Representation and Reasoning {\rm (}KR'06{\rm )},
  Lake District, UK, June 2-5, 2006}, {P.~Doherty}, {J.~Mylopoulos}, {and}
  {C.~A. Welty}, Eds. AAAI Press, Menlo Park, CA, USA, 298--307.

\bibitem[\protect\citeauthoryear{Denecker, Vennekens, Bond, Gebser, and
  Truszczynski}{Denecker et~al\mbox{.}}{2009}]{competition09}
{\sc Denecker, M.}, {\sc Vennekens, J.}, {\sc Bond, S.}, {\sc Gebser, M.}, {\sc
  and} {\sc Truszczynski, M.} 2009.
\newblock The second answer set programming competition.
\newblock In {\em Proceedings of the 10th International Conference on Logic
  Programming and Nonmonotonic Reasoning {\rm (}LPNMR'09{\rm )}, Potsdam,
  Germany, September 14-18, 2009}, {E.~Erdem}, {F.~Lin}, {and} {T.~Schaub},
  Eds. Lecture Notes in Computer Science, vol. 5753. Springer,
  Berlin-Heidelberg, Germany, 637--654.

\bibitem[\protect\citeauthoryear{Eiter, Faber, Fink, Pfeifer, and
  Woltran}{Eiter et~al\mbox{.}}{2004}]{eiter04}
{\sc Eiter, T.}, {\sc Faber, W.}, {\sc Fink, M.}, {\sc Pfeifer, G.}, {\sc and}
  {\sc Woltran, S.} 2004.
\newblock Complexity of model checking and bounded predicate arities for
  non-ground answer set programming.
\newblock In {\em Proceedings of the 9th International Conference on Principles
  of Knowledge Representation and Reasoning {\rm (}KR'04{\rm )}, Whistler,
  Canada, June 2-5, 2004}, {D.~Dubois}, {C.~A. Welty}, {and} {M.-A. Williams},
  Eds. AAAI Press, Menlo Park, CA, USA, 377--387.

\bibitem[\protect\citeauthoryear{Eiter, Gottlob, and Mannila}{Eiter
  et~al\mbox{.}}{1997}]{eiter97}
{\sc Eiter, T.}, {\sc Gottlob, G.}, {\sc and} {\sc Mannila, H.} 1997.
\newblock Disjunctive datalog.
\newblock {\em ACM Transactions on Database Systems\/}~{\em 22,\/}~3 (Sept.),
  364--418.

\bibitem[\protect\citeauthoryear{Gebser, P{\"u}hrer, Schaub, and
  Tompits}{Gebser et~al\mbox{.}}{2008}]{gebser08}
{\sc Gebser, M.}, {\sc P{\"u}hrer, J.}, {\sc Schaub, T.}, {\sc and} {\sc
  Tompits, H.} 2008.
\newblock A meta-programming technique for debugging answer-set programs.
\newblock In {\em Proceedings of the 23rd {AAAI} Conference on Artificial
  Intelligence {\rm (}AAAI'08{\rm )}, Chicago, IL, USA, July 13-17, 2008},
  {D.~Fox} {and} {C.~P. Gomes}, Eds. AAAI Press, Menlo Park, CA, USA, 448--453.

\bibitem[\protect\citeauthoryear{Gebser, P{\"u}hrer, Schaub, Tompits, and
  Woltran}{Gebser et~al\mbox{.}}{2009}]{spock07}
{\sc Gebser, M.}, {\sc P{\"u}hrer, J.}, {\sc Schaub, T.}, {\sc Tompits, H.},
  {\sc and} {\sc Woltran, S.} 2009.
\newblock spock: {A} debugging support tool for logic programs under the
  answer-set semantics.
\newblock In {\em Revised Selected Papers of the 17th International Conference
  on Applications of Declarative Programming and Knowledge Management and the
  21st Workshop on Logic Programming {\rm (}INAP'07/WLP'07{\rm )},
  W{\"u}rzburg, Germany, October 4-6, 2007}, {D.~Seipel}, {M.~Hanus}, {and}
  {A.~Wolf}, Eds. Lecture Notes in Computer Science, vol. 5437. Springer,
  Berlin-Heidelberg, Germany, 247--252.

\bibitem[\protect\citeauthoryear{Gelfond and Lifschitz}{Gelfond and
  Lifschitz}{1991}]{gelfond91}
{\sc Gelfond, M.} {\sc and} {\sc Lifschitz, V.} 1991.
\newblock Classical negation in logic programs and disjunctive databases.
\newblock {\em New Generation Computing\/}~{\em 9,\/}~3/4, 365--386.

\bibitem[\protect\citeauthoryear{Lee}{Lee}{2005}]{lee05}
{\sc Lee, J.} 2005.
\newblock A model-theoretic counterpart of loop formulas.
\newblock In {\em Proceedings of the 19th International Joint Conference on
  Artificial Intelligence {\rm (}IJCAI'05{\rm )}, Edinburgh, Scotland, UK,
  July~30-August~5, 2005}, {L.~P. Kaelbling} {and} {A.~Saffiotti}, Eds.
  Professional Book Center, Denver, CO, USA, 503--508.

\bibitem[\protect\citeauthoryear{Lee and Meng}{Lee and Meng}{2008}]{lee08}
{\sc Lee, J.} {\sc and} {\sc Meng, Y.} 2008.
\newblock On loop formulas with variables.
\newblock In {\em Proceedings of the 11th International Conference on
  Principles of Knowledge Representation and Reasoning {\rm (}KR'08{\rm )},
  Sydney, Australia, September 16-19, 2008}, {G.~Brewka} {and} {J.~Lang}, Eds.
  AAAI Press, Menlo Park, CA, USA, 444--453.

\bibitem[\protect\citeauthoryear{Leone, Rullo, and Scarcello}{Leone
  et~al\mbox{.}}{1997}]{LeoneRS97}
{\sc Leone, N.}, {\sc Rullo, P.}, {\sc and} {\sc Scarcello, F.} 1997.
\newblock Disjunctive stable models: Unfounded sets, fixpoint semantics, and
  computation.
\newblock {\em Information and Computation\/}~{\em 135,\/}~2, 69--112.

\bibitem[\protect\citeauthoryear{Lin and Zhao}{Lin and Zhao}{2004}]{lin04}
{\sc Lin, F.} {\sc and} {\sc Zhao, Y.} 2004.
\newblock {ASSAT}: Computing answer sets of a logic program with {SAT} solvers.
\newblock {\em Artificial Intelligence\/}~{\em 157,\/}~1--2, 115--137.

\bibitem[\protect\citeauthoryear{Mikitiuk, Moseley, and Truszczynski}{Mikitiuk
  et~al\mbox{.}}{2007}]{mirek07}
{\sc Mikitiuk, A.}, {\sc Moseley, E.}, {\sc and} {\sc Truszczynski, M.} 2007.
\newblock Towards debugging of answer-set programs in the language {PS}pb.
\newblock In {\em Proceedings of the 2007 International Conference on
  Artificial Intelligence {\rm (}ICAI'07{\rm )}, Volume {II}, Las Vegas, NV,
  USA, June 25-28, 2007}, {H.~R. Arabnia}, {M.~Q. Yang}, {and} {J.~Y. Yang},
  Eds. CSREA Press, Bogart, GA, USA, 635--640.

\bibitem[\protect\citeauthoryear{Oetsch, P\"uhrer, and Tompits}{Oetsch
  et~al\mbox{.}}{2010}]{mmdasp}
{\sc Oetsch, J.}, {\sc P\"uhrer, J.}, {\sc and} {\sc Tompits, H.} 2010.
\newblock Methods and methodologies for developing answer-set
  programs---{P}roject description.
\newblock In {\em Technical Communications of the 26th International Conference
  on Logic Programming {\rm (}ICLP'10{\rm)}}, {M.~Hermenegildo} {and}
  {T.~Schaub}, Eds. Leibniz International Proceedings in Informatics (LIPIcs),
  vol.~7. Schloss Dagstuhl--Leibniz-Zentrum f\"ur Informatik, Dagstuhl,
  Germany.

\bibitem[\protect\citeauthoryear{Pontelli, Son, and El-Khatib}{Pontelli
  et~al\mbox{.}}{2009}]{pontelli09}
{\sc Pontelli, E.}, {\sc Son, T.~C.}, {\sc and} {\sc El-Khatib, O.} 2009.
\newblock Justifications for logic programs under answer set semantics.
\newblock {\em Theory and Practice of Logic Programming\/}~{\em 9,\/}~1, 1--56.

\bibitem[\protect\citeauthoryear{Syrj\"anen}{Syrj\"anen}{2006}]{syrjaenen06}
{\sc Syrj\"anen, T.} 2006.
\newblock Debugging inconsistent answer set programs.
\newblock In {\em Proceedings of the 11th International Workshop on
  Non-Monotonic Reasoning {\rm (}NMR'06{\rm )}, Lake District, UK, May 30-June
  1, 2006}, {J.~Dix} {and} {A.~Hunter}, Eds. Institut f{\"u}r Informatik,
  Technische Universit{\"a}t Clausthal, Technical Report, Clausthal, Germany,
  77--83.

\bibitem[\protect\citeauthoryear{Wittocx, Vlaeminck, and Denecker}{Wittocx
  et~al\mbox{.}}{2009}]{WittocxVD09}
{\sc Wittocx, J.}, {\sc Vlaeminck, H.}, {\sc and} {\sc Denecker, M.} 2009.
\newblock Debugging for model expansion.
\newblock In {\em Proceedings of the 25th International Conference on Logic
  Programming {\rm (}ICLP'09{\rm )}, Pasadena, CA, USA, July 14-17, 2009},
  {P.~M. Hill} {and} {D.~S. Warren}, Eds. Lecture Notes in Computer Science,
  vol. 5649. Springer, Berlin-Heidelberg, Germany, 296--311.

\end{thebibliography}
\end{document}