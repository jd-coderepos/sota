\documentclass[11pt,conference,compsoc,onecolumn,romanappendices]{IEEEtran}
\usepackage[cmex10]{amsmath}
\usepackage{amssymb,enumerate,bbm}
\usepackage{amsthm,graphicx,float,mathtools}
\usepackage[ruled,boxed]{algorithm2e}
\usepackage{cite}




\usepackage{fancyhdr}
\fancypagestyle{plain}{\fancyhf{}
  \fancyfoot[C]{\iffloatpage{}{\thepage}}
  \renewcommand{\headrulewidth}{0pt}}
\pagestyle{plain}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}


\newcommand{\nin}{\not\in}
\newcommand{\nocomma}{}
\newcommand{\tmem}[1]{{\em #1\/}}
\newcommand{\tmop}[1]{\ensuremath{\operatorname{#1}}}
\newcommand{\tmstrong}[1]{\textbf{#1}}
\newcommand{\tmtextit}[1]{{\itshape{#1}}}
\newenvironment{enumeratenumeric}{\begin{enumerate}[1.] }{\end{enumerate}}
\newenvironment{enumerateroman}{\begin{enumerate}[i.] }{\end{enumerate}}
\newenvironment{itemizedot}{\begin{itemize} \renewcommand{\labelitemi}{}\renewcommand{\labelitemii}{}\renewcommand{\labelitemiii}{}\renewcommand{\labelitemiv}{}}{\end{itemize}}
\newenvironment{tmindent}{\begin{tmparmod}{1.0em}{1.0em}{0pt} }{\end{tmparmod}}
\newenvironment{fkindent}{\begin{tmparmod}{0.0em}{1.0em}{0pt} }{\end{tmparmod}}
\newenvironment{tmparmod}[3]{\begin{list}{}{\setlength{\topsep}{0pt}\setlength{\leftmargin}{#1}\setlength{\rightmargin}{#2}\setlength{\parindent}{#3}\setlength{\listparindent}{\parindent}\setlength{\itemindent}{\parindent}\setlength{\parsep}{\parskip}} \item[]}{\end{list}}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{remark}{Remark}

\hyphenation{op-tical net-works semi-conduc-tor}
\renewcommand{\citepunct}{,}
\renewcommand\citedash{--}
\IEEEoverridecommandlockouts
\renewcommand{\theequation}{\thesection.}

\clubpenalty=10000
\widowpenalty = 10000

\title{\LARGE Beyond One Third Byzantine Failures}

\author{
\IEEEauthorblockN{
Wang Cheng\IEEEauthorrefmark{1},\quad
Carole Delporte-Gallet\IEEEauthorrefmark{2},\quad
Hugues Fauconnier\IEEEauthorrefmark{3}\ \alpha (p_0) = 0, \alpha (p_0 p) = 0,  \beta (p_0) = 1, \beta (p_0 k) = 0, \beta (p_0 q) = 1,  \alpha (w g p) = \alpha (w g) \nocomma, \alpha (w i p) = \alpha (w i),
       \alpha (w k p) = \alpha (w k),  \beta (w h p) = \beta (w h) \nocomma, \beta (w j p) = \beta (w j),
       \beta (w k p) = \beta (w p),  \alpha (w h k) = \beta (w h k) \nocomma, \alpha (w h q) = \alpha (w h),
       \alpha (w j p) = \beta (w j p) \nocomma, \text{}  \beta (w g k) = \alpha (w g k), \beta (w g q) = \beta (w g), \beta (w i
       p) = \alpha (w i p) .  F (\alpha_k) = \alpha (p_0) = 0,  F (\beta_k) = \beta (p_0) = 1.  \tmop{for} w \in p_0 P^{0 : b} \nocomma, \alpha_x (w) = \left\{
     \begin{array}{ll}
       0 & \tmop{if} \overline{w} < x,\\
       1 & \tmop{otherwise.}
     \end{array} \right.  \tmop{for} w \in p_0 P^{0 : b + 1} \nocomma, \sigma (w) = \left\{
     \begin{array}{ll}
       0 & \tmop{if} p_0 < q_0,\\
       0 & \tmop{if} p_0 = q_0 \tmop{and} w = q_0 \ldots q_i q s, \tmop{with}
       0 \leqslant i \leqslant b, q < q_{i + 1},\\
       1 & \tmop{otherwise.}
     \end{array} \right.  \tmop{for} w \in p_0 P^{0 : b + 1} \nocomma, \phi (w) = \left\{
     \begin{array}{ll}
       1 & \tmop{if} w = q_0 \ldots q_b q \tmop{with} q < q_{b + 1} \tmop{and}
       q \neq q_{b + 2},\\
       \sigma (w) & \tmop{otherwise.}
     \end{array} \right.  \alpha (p_0) = 0, \alpha (p_0 i) = 1, \alpha (p_0 q_i) = \alpha (p_0),
     \beta (p_0) = 1, \beta (p_0 j) = 0, \beta (p_0 q_j) = \beta (p_0),  \alpha (p_0 p_0 i) = \beta (p_0 p_0 i) = 1,  \alpha (p_0 g i) = 1, \alpha (p_0 g q_i) = \alpha (p_0 g), \alpha (p_0
     q_g p) = \alpha (p_0 q_g),  \beta (p_0 h i) = 0, \beta (p_0 h q_i) = \beta (p_0 h), \beta (p_0 q_h p)
     = \beta (p_0 q_h) .  0 = \alpha (p_0) = F (\alpha_i) = F (\beta_i) = \beta (p_0) = 1,  \alpha (p_0) = 0, \alpha (p_0 h) = 1, \alpha (p_0 q_{\alpha}) = 0,  \beta (p_0) = 1, \beta (p_0 i) = 0, \beta (p_0 q_{\beta}) = 1,  \alpha (w h p) = \alpha (w g) \nocomma, \alpha (w i p) = \alpha (w i),
       \alpha (w k p) = \alpha (w k),  \beta (w h p) = \beta (w h) \nocomma, \beta (w i p) = \beta (w i),
       \beta (w j p) = \beta (w j),  \alpha (w g q_{\alpha}) = \alpha (w g), \alpha (w g h) = \beta (w g),
       \alpha (w j p) = \beta (w j p),  \beta (w g q_{\beta}) = \beta (w g), \beta (w g i) = \alpha (w g),
       \beta (w k p) = \alpha (w k p) .  0 = \alpha (p_0) = F (\alpha_h) = F (\beta_h) = \beta (p_0)
     = 1,  \alpha (p_0) = 0, \alpha (p_0 i) = \bot, \alpha (p_0 q) = \alpha (p_0),
     \beta (p_0) = 1, \beta (p_0 i) = \bot, \beta (p_0 q) = \beta (p_0) .  \alpha (w g i) = \beta (w g i) = \bot \nocomma, \alpha (w g q) = \alpha
       (w g) \nocomma, \beta (w g q) = \beta (w g),  \alpha (w h p) = \alpha (w i p) = \beta (w h p) = \beta (w i p) = \bot
       .  0 = \alpha (p_0) = F (\alpha_i) = F (\beta_i) = \beta (p_0) = 1, 
  giving a contradiction.
\end{proof}

\section{Early Decision}\label{app-early}

The work in \cite{dolev1982polynomial,krings1999byzantine} showed that processes
could make an early decision if the number of actual Byzantine failures is less than the
maximal number of failures it can tolerate. We show here how we can achieve early
decision with partial Byzantine failures.

\begin{theorem}
Consider a (n, m, d, b)-system () and  denotes the number of actual
Byzantine processes during an execution. Then Byzantine agreement can be solved in
the following number of rounds:
\begin{itemize}
\item , if ,
\item , if .
\end{itemize}
\end{theorem}

\begin{proof}

First consider . From Lemma \ref
{lemma-lm3}, for any scenario  we have  provided that  is non-Byzantine. By definition , so we have . This means every
non-Byzantine process could get the initial value of the non-Byzantine transmitter 
despite that  might be partial faulty. Thus by applying  to a
-round scenario , we could obtain a -round reliable broadcast
algorithm. If we use this reliable broadcast algorithm as a broadcast
primitive in the early deciding algorithms in
\cite{dolev1982polynomial,krings1999byzantine}, then we could get early
deciding Byzantine agreement for a (n, m, d, b)-system as well. The time
complexity of algorithms in \cite{dolev1982polynomial,krings1999byzantine} is
. Since we replace one round broadcast with three rounds
broadcast, the time complexity of early deciding algorithm with -round
reliable broadcast is .

The result for  follows from the same idea.
\end{proof}

\section{The Eventually Synchronous Case}\label{sec-esyn}

We considered so far synchronous computations. However, it is
also possible to tolerate partial failures in eventually synchronous systems. In this
section, we first present a reliable broadcast implementation that tolerates
partial Byzantine failures. Here, reliable broadcast ensures that if a non-Byzantine
process broadcasts a message then other processes will receive the
same message eventually (no such guarantee for Byzantine processes).
This broadcast primitive thus can be plugged into an
algorithm like \cite{castro1999practical}.

We assume here that after an unknown but finite time the
system become synchronous \cite{lynch1996distributed}.
Within an eventually synchronous system, the processes could not distinguish
message delay from the absence of a message. We consider a \tmem{static} (n,
m, d, b)-system which includes up to  Byzantine processes and up to 
partial faulty processes each of which is associated with up to 
\tmem{fixed} Byzantine links. We first show that the algorithm  and  can be modified to achieve reliable broadcast in an eventually synchronous (n, m,
d, b)-system.

\begin{algorithm}[h]
  {\tmstrong{Assume}}:  is a -round view of process  for a static
  (n, m, d, b)-system with  and  is the
  transmitter.{\hspace*{\fill}}

  {\tmstrong{Code}} for :
  \begin{fkindent}
  \begin{enumeratenumeric}
    \item Waits until receiving more than  values for
     with a same value , then
    output .
  \end{enumeratenumeric}
  \end{fkindent}

  \caption{-round Reliable-Broadcast ()\label{algo-rb2}}
\end{algorithm}

\begin{lemma}
  In  (Algorithm \ref{algo-rb2}), if  and 
  is non-Byzantine, then .
\end{lemma}

\begin{proof}
  As in Lemma \ref{lemma-lm2},  will receive   that equal to  from  correct
  processes. Since , the lemma follows.
\end{proof}

\begin{algorithm}[h]
  {\tmstrong{Assume}}:  is a -round view of process  for a static
  (n, m, d, b)-system with  and  is the
  transmitter.{\hspace*{\fill}}

  {\tmstrong{Code}} for :
  \begin{fkindent}
  \begin{enumeratenumeric}
    \item  initializes an empty set .
    
    \item Waits until receiving  values for  with a same value , then  adds 
     to .
    
    \item Waits until  values in  have a same value ,
    then  outputs .
  \end{enumeratenumeric}
  \end{fkindent}
  \caption{-round Reliable-Broadcast ()\label{algo-rb3}}
\end{algorithm}

\begin{lemma}
  In  (Algorithm \ref{algo-rb3}), if 
  and  is non-Byzantine, then .
\end{lemma}

\begin{proof}
  If  is correct, there are at least  values equal to  in  from correct processes, which implies
   will be added to  eventually.
  
  If  is d-faulty, there are at most  values different from  in . Since , only
   might be added to .
  
  Now consider the transmitter.
  If  is non-Byzantine, all correct processes
  except the one receiving wrong values from  will contribute a value
   to . So  will eventually include at least 
  values equal to  and at most  values different from
  . Since ,  can only be
  .
\end{proof}

If  or  is employed as a broadcast primitive, i.e. a
process broadcasts a message by executing an instance of  or
, then the messages broadcast by non-Byzantine processes will be
received by other non-Byzantine processes as if there are no partial failures. In
this way,  and  could play the role of reliable
broadcast for a (n, m, d, b)-system. We could then use our reliable broadcast
primitive (either RB2 or RB3) within an algorithm such as PBFT \cite{castro1999practical}.
We obtain the following theorem.

\begin{theorem}
  Byzantine agreement can be solved assuming eventually synchronous computation of a static (n, m, d,
  b)-system () if and only if .
\end{theorem}

\begin{proof}   
  The sufficiency follows from the above discussion. The
  necessity comes from Lemma \ref{lemma-impsb1} and Lemma \ref{lemma-impsb2}.
\end{proof}

\end{document}
