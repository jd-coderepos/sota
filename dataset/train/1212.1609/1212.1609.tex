

\documentclass[11pt]{article}\usepackage{amsmath}
\usepackage{graphics}
\usepackage{color}
\usepackage{epsfig}
\usepackage{graphicx}\usepackage{amsfonts}\usepackage{amssymb}
\usepackage{setspace}

\DeclareGraphicsRule{*}{pdftex}{*}{} 


\setlength{\textheight}{8.75in}
\setlength{\columnsep}{2.0pc}
\setlength{\textwidth}{6.0in}
\setlength{\topmargin}{0.25in}
\setlength{\headheight}{0.0in}
\setlength{\headsep}{0.0in}
\setlength{\oddsidemargin}{0.0in}
\setlength{\evensidemargin}{0.0in}
\setlength{\parindent}{1pc}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{claim}{Claim}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{fact}{Fact}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{note}{Note}[section]
\newtheorem{observation}{Observation}[section]
\newtheorem{remark}{Remark}[section]
\newtheorem{proposition}{Proposition}[section]
\newenvironment{proof}{\noindent{\bf Proof.}}{  \rule{2mm}{3mm}}
\newenvironment{claimproof}{{\bf Proof of claim.}}{  \rule{1mm}{3mm}}
\newenvironment{sketchproof}{\vspace*{-.1in}\noindent{\bf Proof sketch.}}{  \rule{2mm}{3mm}}
\newcommand{\esect}[2]{\bigskip \centerline{#1 {\sc #2}}}
\newcommand{\esubsect}[2]{\bigskip \\ #1 {\em #2}}
\newcommand{\set}[1]{ \{ #1 \} }
\newcommand{\A}{ }
\newcommand{\D}{\Delta}
\newcommand{\C}{{\cal C}}
\renewcommand{\P}{{\cal P}}
\renewcommand{\L}{\Lambda}
\renewcommand{\l}{\lambda} 
\newcommand{\eps}{\varepsilon}
\newcommand{\bx}{\bar{x}}
\newcommand{\precs}{ }
\newcommand{\tu}{{\cal T}}







\date{}

\allowdisplaybreaks

\begin{document}

\title{The 2-valued case of makespan minimization with assignment constraints\thanks{This research has been co-financed by the European Union (European Social Fund -- ESF) and
Greek national funds through the Operational Program ``Education and Lifelong Learning'' of the
National Strategic Reference Framework (NSRF) - Research Funding Program:
``{\sl Thalis. Investing in knowledge society through the European Social Fund}''.}}
\author {Stavros G. Kolliopoulos\thanks{Department of Informatics and
Telecommunications, National and Kapodistrian 
University of Athens, Panepistimiopolis Ilissia, Athens
157 84, Greece; (\texttt{www.di.uoa.gr/}\~{\tt sgk}). Part of this
work was done while visiting the 
  IEOR Department, Columbia University, New York, NY 10027.}   
\and Yannis Moysoglou\thanks{ Corresponding author. Department of Informatics and
Telecommunications, National and Kapodistrian 
University of Athens, Panepistimiopolis Ilissia, Athens
157 84, Greece; (\texttt{gmoys@di.uoa.gr.}) } }
\maketitle



\begin{abstract}
We consider  the following   special case of minimizing makespan.  
A set of jobs  
and a set of machines  are given. Each job  can be
scheduled on a  machine
from a subset  of . The processing time of  is the same on
all  machines in  The jobs  are of two sizes, namely  (big) and
 (small). We present  a polynomial-time  algorithm that
approximates the value of the optimal makespan  within a 
factor of  and some further improvements  when every job
can be scheduled on at most two machines. 
\end{abstract} 

{\bf Keywords:} approximation algorithms, scheduling, 
makespan minimization, graph balancing. 


\section{Introduction}


 The problem we  consider is a special case  of makespan minimization,
 i.e., the problem  of scheduling a set of jobs  on a set of
 machines  
 with the objective
 of  minimizing the  maximum machine load.  In the  most
 general case  of \emph{unrelated} machines,  each job  has a
 processing  time    on  machine    An  LP-rounding
 algorithm with an  approximation factor of  along  with a proof of
 -hardness, unless , are two
 classic results of \cite{lenstra}. For more than 20 years, 
no progress has
 been made either  on the approximation of the general  case or on the
 lower bound.

The   lower bound  holds also for  the case with  {\em assignment
  constraints.} In this setting, each  job  can be scheduled on any
machine from a subset  of  . The processing time  of  is the
same for any machine in  
For this case it was recently shown in \cite{svensson} that a strong
LP-relaxation called the configuration LP has an integrality gap of at
most  .   The  proof   of  this  exciting   result  is
non-constructive, in  the sense  that it does  not actually  provide a
polynomial-time algorithm  that finds such a solution.  The best known
polynomial-time  algorithm that  computes a  near-optimal  schedule is
still the -approximation algorithm of \cite{lenstra}. A slight improvement to
 was given by \cite{ShchepinV05}. 

The  makespan  minimization  problem  is  one of  the  most  important
problems  in  scheduling.  Advancement  on the  approximation  of  the
unrelated  case  appears as  one  of the  top    open problems  in
approximation  algorithms in  the  listing of  \cite{sw}.  Due to  the
importance of the problem several special cases have been considered,
where further  restrictions are imposed  either on the sets   or
on the domain of the processing times. 

 In the case of \emph{graph balancing} each job can be scheduled on at
 most  2  machines. One  can  interpret  this  as  the  following
 problem: we are given an undirected graph with weighted edges and we are asked to
 direct  the edges towards  the nodes  so as  to minimize  the maximum
 weighted in-degree over all nodes. An LP-rounding algorithm achieving
 an approximation factor of   was given in \cite{ebenlendr}. The
 LP  used is  that  of \cite{lenstra}  with  the addition  of a valid set of
  inequalities. The considered  LP has an integrality gap  of  when we
 allow jobs that can be scheduled on  machines \cite{svensson}. The
 case of graph balancing with no parallel edges and with integer edge
 weights had been previously considered in
 \cite{asa}  under  the  name  \emph{graph orientation}.  Among  other
 results         \cite{asa}        gave         a        combinatorial
 -approximation algorithm when weights are from the 
 set 


The natural case when jobs can be either ``big'' or ``small'', i.e., the processing
times  can  only take one of two values gives
rise to particularly difficult instances.
The unrelated version of graph balancing with only  distinct
edge weights seems to capture a major portion
of the difficulty of the general scheduling problem on unrelated machines.  It was
 recently shown in  \cite{jose} 
that even when  there are  distinct edge weights and 
an  edge   may  have  different  weights  for   each  endpoint,  the
configuration  LP has  an  integrality gap  of  . 
For scheduling with assignment constraints, 
-hardness    holds also for 
the case when there are
only   distinct processing time values \cite{lenstra} and  the  integrality  gap  of  the
natural LP of
\cite{lenstra}  is  still  \cite{ebenlendr}.


Motivated by the above, 
we study the {\em 2-valued} case of minimizing makespan 
with assignment
constraints, where     jobs are of two sizes,  namely  (big) and
 (small). 
\iffalse ========================================
As mentioned,  the
approximation hardness of the problem is still  unless 
(\cite{lenstra},\cite{ebenlendr})  and  the  integrality  gap  of  the
natural LP of
\cite{lenstra}  is  still  \cite{ebenlendr}.  
=================================== \fi
We 
present a  simple  algorithm for the case when the job sizes are
 and  which approximates the value of the
optimal solution  within a ratio  of  and then  we show
how to use this algorithm as  a black-box subroutine to get an approximation when
the job  sizes are nonnegative  real numbers. Combining  our algorithm
with the non-constructive result of \cite{svensson} we get an improved
non-constructive approximation guarantee  of  for the -valued
case of  makespan with assignment constraints. The  same algorithm can
be used to obtain an efficient  approximation for the -valued
graph balancing, where additionally for every  we have , 
improving and generalizing the result of
\cite{asa}. Note  that even
for the 
2-valued graph
balancing 
it remains {\sf NP}-hard to compute a better than -approximate
solution 
\cite{asa, ebenlendr}.


\section{An algorithm for the case with job sizes from the set  }

This section describes a subroutine which will be used in our
algorithms. 
Apart from a few details, the network construction and the rounding
argument follow from \cite{Kleinberg96a}. 

Similar to \cite{lenstra}, our algorithm takes as a parameter an estimation  of the makespan of the optimal solution. Using binary search, we find the smallest  for which our algorithm returns a (possibly fractional) solution. As we will show, that  is a lower bound to the makespan of the optimal solution.

Here and in the following sections we make the assumption that the optimal makespan is less than twice the size of the biggest job . This is w.l.o.g. since the algorithm 
of \cite{lenstra} returns a solution with makespan at most 
where   is the optimum of the natural LP relaxation for the
problem.  This is formalized in the following lemma. 

\begin{lemma} \cite{lenstra} \label{lemma:add}
If the optimal makespan to an instance of the problem is , where  is the biggest job size, then there is -approximation algorithm. 
\end{lemma}
\iffalse =========================
\begin{proof}
The rounding algorithm of \cite{lenstra} returns a solution with makespan at most . This is clearly a  approximate solution.
\end{proof}
====================== \fi 

The algorithm we describe is used for instances where the sizes of the jobs are integers, either 1 or .
Given  such an  instance  of   the  problem,  we  construct  the  following
multi-level  network. On  the  first  level we  have  a single  source
. On the  next level we have one node  for each  job . For
each such  node   we have a  directed edge  from  to   of
capacity equal  to the size  of job .  On the level after  that, we
have a node  for each  machine  This type of nodes is not
actually representing the  set of machines. Their purpose  is to limit
the amount of flow from big jobs that may enter the machine nodes of
the next level, enforcing  the valid inequality of \cite{ebenlendr} in
our solution.  
We have a a directed  edge of capacity   from a node
 to a node   iff  is a big job that can be scheduled
to machine  . On  the next level  we have  one node   for each
machine .  We have a directed  edge of capacity   from each node
, where job   is a small job, to a node   iff job  can
be scheduled  on . We also  have one directed edge  of capacity 
from   to .  We connect each  machine node   to the
sink  at  the last level using edges of capacity  , where  is
our  estimation for  the makespan.  See Fig.~\ref{fig:graph} 
for an example. Observe that  while the  flow from
small job nodes is routed directly to the machine nodes, the flow from
the big  job nodes is routed  through the nodes   and then to
the machine nodes.  Thus at most  units of flow  from big job nodes
enter each machine node.

\begin{figure}

\begin{center}
\scalebox{.4}{\begin{picture}(0,0)\includegraphics{graph.pdf}\end{picture}\setlength{\unitlength}{4144sp}\begingroup\makeatletter\ifx\SetFigFont\undefined \gdef\SetFigFont#1#2#3#4#5{\reset@font\fontsize{#1}{#2pt}\fontfamily{#3}\fontseries{#4}\fontshape{#5}\selectfont}\fi\endgroup \begin{picture}(10094,7243)(2146,-6821)
\put(8686,-4291){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(11026,-5101){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}machine nodes}}}}}
\put(11026,-1411){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}job nodes}}}}}
\put(5941,-6766){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5716,299){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(7471,-6091){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3871,-5956){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2206,-4381){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(4681,-2086){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(5041,-871){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3241,-781){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(3556,-2086){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\put(2161,-2086){\makebox(0,0)[lb]{\smash{{\SetFigFont{20}{24.0}{\familydefault}{\mddefault}{\updefault}{\color[rgb]{0,0,0}}}}}}
\end{picture} }
\end{center}

\caption{Example network construction for an instance with  jobs and  
machines. Edges have unit capacity unless indicated otherwise.} \label{fig:graph}
\end{figure}

A feasible flow solution is one that sends a 
total amount of flow  equal to the  sum of the
processing times of the jobs. Using binary search we find the minimum
value of  for which such a feasible solution exists. 
This is a lower bound on the optimum. To see why this is true,
consider a solution  to the problem instance with makespan . We
construct the following network flow solution for the network
corresponding to the instance with estimation  or higher: for each job ,
we send from  to  flow equal to the size of . If  is a
small job assigned to machine  by , then we send  unit of
flow from  to . If  is a big job assigned to machine 
by , then we send  units of flow from  to  and
then  units to  from  (there is at most one such big
job for each machine -- recall that because of  Lemma~\ref{lemma:add} we consider only instances with ). We send from each node  to the sink  all amount of flow that  has received, which is at most .
 We
interpret the  network solution naturally as  a fractional assignment:
if a fraction   of the flow that source  sends  to node  is
routed through the machine node  then we assign a fraction  of
job  to machine .
 
\iffalse    ==== We  are only  interested in  instances of  the problem  for  which the
network  has a  feasible solution  for  some value  of the  parameter
. If an instance has no feasible solution for any value of , it
 it is necessary to have at least 2 big jobs scheduled
on  the same  machine. Obtaining  a   approximation  for such  an
instance is trivial via the rounding technique of \cite{lenstra}.
\fi 



\iffalse =========================== condensed ==============
After  solving the  network flow  problem and  obtaining  a fractional
assignment, we  can easily produce the  following integral assignment:
the small jobs are already  integrally assigned to machines because of
flow integrality.  Observe that each  machine has a total  fraction of
big jobs of at most  assigned to it, due to the capacity  of the
edge that connects node  to node . Moreover the fraction
of a  big job that is  assigned to a  machine is a multiple  of ,
again due to  flow integrality. This guarantees that if  a big job 
has a non zero fraction of it  assigned to a machine , then  has
a fraction of  of at least .

The above gives us the following :

\begin{lemma}
Let  be  the fractional assignment that corresponds  to the network
flow solution  of an instance of  the problem. Then for  every big job
 that has  a non zero fractional assignment   to a machine
, .
\end{lemma}
================== ================ \fi 

After  solving  the  network  flow  problem  we  obtain  a  fractional
assignment  in which small jobs are integrally assigned and for  every big job
 that has a non-zero fraction  assigned to machine
 . In particular by flow integrality, if
 then  will be an integral multiple of 

The next lemma shows that we can assign each big job to a machine that
has a fraction of  at least  of it, so that  each machine gets at
most one big job. 
The  proof of the lemma is easy and is omitted. 

\begin{lemma} \label{lemma:easy} 
Let  be the  set of big jobs and  be  the set of machines
that have a non-zero fraction of  a big job. We can find in polynomial
time a feasible schedule of the jobs of  to the machines of  
so that at most  big job is assigned to each machine.
\end{lemma}

\iffalse =========== omit proof ==================
\begin{proof}
We form  the following  bipartite graph   : on  one side
 of  we have one node for each big job , and on the
other side  we have one node for each machine . The
set of edges  is defined as  follows. We have an edge from each big
job node to each machine node  iff the corresponding machine has a non
zero fraction  of that job. Now let  us consider a set  of nodes   and let   be the  set of
neighbor nodes of  , that is   is exactly the set
of  nodes that are  connected to  some node  of .  Then . Let  assume otherwise  that . Since  our network solution  sends  units of  flow through
any node that corresponds to a big job , the total fractions of 
that are assigned to machines  in our fractional assignment  sum up
to .  Thus the  total fraction of  the big  jobs in   that is
assigned  to  the  machines  of    is  .  Since
 there  is at  least one  machine  that is
assigned a total fraction of big jobs greater than , which violates
the property of our fractional assignment discussed above.

Thus the conditions  of Hall's theorem for bipartite  matching hold, so
we  can in  polynomial time  find such  an assignment  of big  jobs to
machines, with each machine getting at most one big job.
\end{proof}
================= End omit proof ============ \fi 

The value of the optimal solution is at least 
the size of a big job. By Lemma~\ref{lemma:easy} 
in our solution we increased the load of a
machine by at most  This results in a  approximation.

\begin{proposition} \label{propos}
The solution we get for an instance of the -valued makespan problem
with job  sizes from the  set  by rounding  the fractional
assignment    resulting from  the  network  flow  solution, has  an
approximation ratio of .
\end{proposition}








\section{The Case With Arbitrary Job Sizes } \label{sec:int}

In this section we will use the algorithm of Proposition~\ref{propos}  to
design an approximation algorithm for  the more general case where the
two job sizes are arbitrary  nonnegative real numbers. Without loss of
generality we assume that . We can easily normalize the job sizes
by dividing them by . We also assume that the size of small jobs is
 for  some . We can reduce  this problem to the
previous one  by changing the size  of small jobs  to either  or   and  use  the previous
algorithm, since  in the modified instance 
the size of the big  jobs is an integer  multiple of the
size of the small jobs. We will use the resulting assignment as a solution
to  our  original  instance. Below  we  prove  by  doing so  that  the
approximation ratio  is bounded by certain expressions.  Later we will
combine those expressions with the result of \cite{svensson} to get an
improved non-constructive approximation guarantee.

\begin{definition}
Let  be the 
 original instance of our problem with job sizes in ,  Let  be the instance where we change the small job sizes to  and  be the instance resulting from changing the small job sizes to . Additionally let  be the factor by which the small jobs in  are greater than the small  jobs in , and  be the factor by which the small jobs in  are smaller than the small jobs in .
\end{definition}

We proceed by bounding the approximation ratio in the case we use the solution of instance  as a solution to . We focus on the load of some machine . Let  be the  cost of the optimal solution of instance  and  be the cost of the optimal solution for the original instance . In the fractional assignment resulting from the solution of the network flow for instance , let  be the total fraction of big jobs that are assigned to . If  then  by flow integrality. Then the load of  due to small jobs is at most . After the rounding the load of  is at most  where the load due to big jobs is  and the load due to small jobs is . If , only small jobs are assigned to machine , then the load of  does not increase during the rounding and thus the total load of  is at most .


If we use the forementioned solution of  as a solution to , since the small
jobs in  are  times greater, the load of a machine  that is assigned a big job 
will be  at most
.  Also we have that . So, regarding the constructed solution for the original instance , the ratio of the load of  to the optimum makespan is . Since  and  we upper bound the former ratio once more (setting  and ) by  . If  is assigned only small jobs, then the corresponding load is at most  in instance  and the corresponding ratio is at most . Clearly , since . Thus we can bound the approximation ratio achieved using the solution of  by the ratio of the first case: .


Now we will make a similar analysis for the case we use the solution
of  as a solution to . Let  be the value of the optimal
solution of  (). We once again focus on the load of a
single machine . Using the same reasoning as above, if  was assigned a non-zero fraction  of  big jobs, we have  by flow integrality. The load of 
after rounding the fractional assignment is at most . The
small jobs of  have size  times the size they have in
. So the load of  for instance  is at most
. As for the value   of the optimal solution of , we know that  (since the optimal solution to  with cost  induces a solution to  which is at most  ). Thus the ratio of the contructed solution to the optimal cost is . Like before, we upper bound the former expression by setting  and  and we get . If  is assigned only small jobs, then the load does not increase during the rounding and is at most  regarding instance . The corresponding load of  in the solution for instance  is at most . The ratio of this case is . Since , . So, once again, the expression that bounds the approximation ratio achieved is .

We use the solution of the instance that achieves the minimum approximation ratio. We have thus proved the following theorem:

\begin{theorem}
For any instance of the 2-valued makespan with assignment constraints
and with job sizes in ,  we can find in polynomial time a solution which has an approximation ratio 
\end{theorem}

The approximation we have achieved so far depends on . We can calculate  
 the worst case approximation given by the above theorem for interval  which contains , by setting the two expressions to be equal, since one is decreasing  and the other is increasing in , for a given interval .

According to the above, the worst approximation achieved for  is for the value of  for which:

\begin{center}
\\
\\
\\
\end{center}


The solution is  .


 The above calculation  gives an approximation guarantee of  for values of  up to . For values of  the small job size is  and therefore it is preferable to use the following:

\begin{theorem}
\cite{svensson} If an instance of the scheduling problem only has job sizes  and , then the configuration LP has integrality gap at most .
\end{theorem}

The above theorem was actually proved in \cite{svensson} with the assumption that . The proof, however, can be easily generalized to the case where  by making some minor changes. The main idea is changing  to  wherever the proof refers to the makespan (i.e., the integrality gap becomes ).
Note that for  the approximation of the above theorem is at most . So the following has been proved:


\begin{theorem}
We can estimate the optimal makespan of a 2-valued  instance with  assignment constraints and with jobs of two sizes within a factor of  in polynomial time.
\end{theorem}



\section{2-valued case of graph balancing}

In this section we present a -approximation for graph balancing instances, where the edge weights belong to the set . Our proof relies on a modification of the proof for the more general case of 2-valued makespan with assignment constraints. We will first prove a tight  approximation when .


Let us  consider the multi-level  network defined above for  this case
where the graph edges take  the role of jobs and the nodes  take the role of
machines. The key difference here is  that for each job node there are
at  most   flow  paths  to the  set  of machine  nodes.  So in  the
fractional solution resulting from the flow solution, for each big job
 there are at most   machines that have nonzero fraction of that
job. Moreover  for each  big job  either there is  one machine  with a
fraction greater  than   of , or  there are   machines with
exactly a   fraction of  each. This is  due to the constraint
enforced by nodes  that each machine may take a total fraction of
big jobs of at most . The small jobs are assigned integrally due to
integrality of flow.

Now we show  how to round the fractional assignment:  for each big job
 for  which there  is a  machine  with  a fraction  greater than
 of   assigned to it, assign   to . As for  the big jobs
that are assigned to  machines with a fraction of exactly , we
consider the graph induced by the corresponding edges (only for those big jobs) and the nodes(machines) covered by those edges. Since
each  node has  degree  at most   (otherwise a machine is assigned at least 3/2 big jobs, which cannot happen),  the graph  is  a collection  of
disjoint paths  and cycles. It is  easy to find a   assignment of
the edges  to the  nodes (i.e., make  a clockwise assignment  on cycles,
direct each path arbitrary and assign each edge to its head).

Note that in the resulting assignment, each node-machine which had a fraction at least  of some big edge-job may end up taking the whole edge-job. We have increased the cost of the fractional solution by  at most and since the cost of the optimal solution is at least , we have achieved a  approximation, matching the lower bound.

\begin{theorem}
For instances of graph balancing in which  we can  find in polynomial time a -approximate solution.
\end{theorem}

As in the previous section, we  use the above algorithm as a black box
to solve the case with edge weights in  or w.l.o.g. in 
Following the exact same  argumentation, we can reduce this case
to the  previous one,  by rounding  the small job  size to  either   or   to  . For both cases, the worst approximation ratio arise again from the case where machine  has a non-zero fraction of big jobs and received a whole big job after the rounding. Now we know that  had at least  fraction of some big job. The
expressions  giving   the  approximation   in  each  case   are 
  and  respectively and are obtained in the same
manner as in Section~\ref{sec:int}. 
Once again we  balance the  expressions in  each
interval  getting the following:

\begin{center}
\\

\end{center}

Assume . Solving the above equation for the intervals, the worst approximation achieved is when , which is less than .

When   we use a different approach: in this case
. If  then it is obvious that we can find
an optimal solution via bipartite maching. If , then we know
that , since there must be a machine with at least 2 jobs
assigned in each solution. Consider the case . If  then  (since we have either  big job and  small in some machine or we have more than 3 small jobs in some machine) and the
algorithm of \cite{lenstra} gives a 
approximation. If  using, e.g., the LP and the cycle canceling
of \cite{ebenlendr} we get a fractional solution of cost  at most   for which the corresponding graph induced on the fractionally assigned nodes (machines) is a forest. Consider a tree , and further consider a leaf node . The load of the integrally assigned jobs of   can either be  or  ( cannot have 2 integrally assigned jobs and one fractionally since ). We assign the fractional job to , resulting to a total load of at most . We do the same in a bottom-up manner for each node of the tree. The resulting approximation is  which is less than  for . If  then the reduction to  done previously gives an approximation of at most . Note that, for all the above, we do not need  to know the value of , we just keep the best solution of the mentioned approaches.

\begin{theorem}
For instances of graph balancing in which the edge weights belong to
the set  we 
can compute in polynomial time  a -approximate solution.
\end{theorem}



\bibliographystyle{plain}


\begin{thebibliography}{1}

\bibitem{asa}
Y.~Asahiro, J.~Jansson, E.~Miyano, H.~Ono, and K.~Zenmyo.
\newblock Approximation algorithms for the graph 
orientation minimizing  the maximum weighted outdegree.
\newblock {\em J. Comb. Optimization,} 22:78--96, 2011. 

\bibitem{ebenlendr}
T.~Ebenlendr, M.~K\v{r}\'{c}al,  and J.~Sgall.
\newblock Graph balancing: a special case of scheduling unrelated parallel
  machines.
\newblock In {\em Proc. 19th  ACM-SIAM
  Symp.  Discr. Algorithms (SODA)}, 483--490, 
  2008.

\bibitem{Kleinberg96a}
J.~M. Kleinberg.
\newblock {\em Approximation algorithms for disjoint paths problems}.
\newblock PhD thesis, MIT, Cambridge, MA, May 1996.

\bibitem{lenstra}
J.~K. Lenstra, D.~B. Shmoys, and \'{E}. Tardos.
\newblock Approximation algorithms for scheduling unrelated parallel machines.
\newblock {\em {Mathematical Programming A}}, 46:259--271, 1990.

\bibitem{ShchepinV05} 
Evgeny V. Shchepin  and Nodari Vakhania.
\newblock An optimal rounding gives a better approximation for scheduling unrelated machines. \newblock {\em Oper. Res. Lett.} 33(2): 127-133 (2005). 

\bibitem{svensson}
O.~Svensson.
\newblock Santa {C}laus schedules jobs on unrelated machines.
\newblock {\em Proc.  43rd ACM Symposium on Theory of Computing 
  (STOC),}  617--626, 2011.

 
\bibitem{jose}
J. Verschae and A. Wiese.
\newblock On the configuration-{LP} for scheduling on unrelated machines.
\newblock In {\em Proceedings of the 19th European Symposium on Algorithms
  (ESA),} 530--542, 2011. 

\bibitem{sw}
David P.~Williamson and  David B.~Shmoys.
\newblock The design of approximation algorithms.
\newblock Cambridge University Press, 2011.



\end{thebibliography}


\end{document}
