
\documentclass{article} \usepackage{iclr2021_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{siunitx}
\usepackage{comment}
\usepackage{enumitem}



\usepackage[T1]{fontenc}
\usepackage[font=small,labelfont=bf,tableposition=top]{caption}

\DeclareCaptionLabelFormat{andtable}{#1~#2  \&  \tablename~\thetable}

\usepackage{blindtext}
\usepackage{longtable}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{hyperref}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{comment}
\usepackage{csquotes}
\usepackage[nopar]{lipsum}
\usepackage{bm}
\usepackage{makecell}


\usepackage[framemethod=tikz]{mdframed}
\usepackage{mathtools}

\usepackage{appendix}
\usepackage{wrapfig}
\usepackage{chngcntr}
\usepackage{etoolbox}

\usepackage[ruled]{algorithm2e}
\usepackage{algpseudocode}
\usepackage[outline]{contour}
\usepackage{lettrine}

\usepackage{tabularx}

\usepackage{listings}
\usepackage{color}

\usepackage{titlesec}
\usepackage[capitalize]{cleveref}



\newcommand{\bb}[1]{\mathbf{#1}}
\newcommand{\bbb}{\bb{b}}
\newcommand{\bgamma}{\b\gamma}
\newcommand{\bbeta}{\b\beta}
\newcommand{\ba}{\bb{a}}
\newcommand{\be}{\bb{e}}
\newcommand{\bx}{\bb{x}}
\newcommand{\bxi}{\bx^{(i)}}
\newcommand{\bxl}{\bx^{(l)}}
\newcommand{\bt}{\bb{t}}
\newcommand{\by}{\bb{y}}
\newcommand{\bv}{\bb{v}}
\newcommand{\bw}{\bb{w}}
\newcommand{\bK}{\bb{K}}
\newcommand{\bQ}{\bb{Q}}
\newcommand{\bV}{\bb{V}}
\newcommand{\bi}{\bb{i}}
\newcommand{\bk}{\bb{k}}
\newcommand{\bq}{\bb{q}}
\newcommand{\bW}{\bb{W}}
\newcommand{\bX}{\bb{X}}
\newcommand{\bc}{\bb{c}}
\newcommand{\bd}{\bb{d}}
\newcommand{\bg}{\bb{g}}
\newcommand{\bo}{\bb{o}}
\newcommand{\bH}{\bb{H}}
\newcommand{\bHW}{\bb{HW}}
\newcommand{\bD}{\bb{D}}
\newcommand{\bh}{\bb{h}}
\newcommand{\br}{\bb{r}}
\newcommand{\bp}{\bb{p}}
\newcommand{\byl}{\by^{(l)}}
\newcommand{\bz}{\bb{z}}
\newcommand{\bzi}{\bz^{(i)}}
\newcommand{\bzl}{\bz^{(l)}}
\newcommand{\bzil}{\bz^{(i,l)}}
\newcommand{\bpa}{\bb{pa}}
\newcommand{\bbf}{\bb{f}}

\newcommand{\bT}{\boldsymbol{\theta}}
\newcommand{\bTl}{\boldsymbol{\theta}^{(l)}}
\newcommand{\boldeta}{\boldsymbol{\eta}}
\newcommand{\balpha}{\boldsymbol{\alpha}}
\newcommand{\bphi}{\boldsymbol{\phi}}
\newcommand{\beps}{\boldsymbol{\epsilon}}
\newcommand{\bepsilon}{\boldsymbol{\epsilon}}
\newcommand{\bepsl}{\beps^{(l)}}
\newcommand{\bepsil}{\beps^{(i,l)}}
\newcommand{\bzeta}{\boldsymbol{\zeta}}
\newcommand{\bzetal}{\zeta^{(l)}}
\newcommand{\bsigma}{\boldsymbol{\sigma}}
\newcommand{\bu}{\boldsymbol{\mu}}
\newcommand{\bzero}{\bb{0}}
\newcommand{\bs}{\mathbf{s}}


\newcommand{\btPa}{\widetilde{\bb{Pa}}}
\newcommand{\btpa}{\widetilde{\bb{pa}}}

\newcommand{\tz}{\widetilde{z}}
\newcommand{\tf}{\widetilde{f}}
\newcommand{\btZ}{\widetilde{\bb{Z}}}
\newcommand{\btz}{\widetilde{\bz}}
\newcommand{\btT}{\widetilde{\bT}}
\newcommand{\tPa}{\widetilde{Pa}}

\newcommand{\pT}{p_{\bT}}
\newcommand{\pTl}{p_{\bT^{(l)}}}
\newcommand{\pA}{p_{\balpha}}
\newcommand{\qT}{q_{\bT}}
\newcommand{\qPhi}{q_{\bphi}}
\newcommand{\qP}{q_{\bphi}}
\newcommand{\qD}{q_\mathcal{D}}
\newcommand{\qDP}{q_{\mathcal{D},\bphi}}
\newcommand{\fT}{\bbf_{\bT}}
\newcommand{\fPhi}{f_{\bphi}}
\newcommand{\fTPhi}{\bbf_{\bT,\bphi}}
\newcommand{\gPhi}{g_{\bphi}}
\newcommand{\hPhi}{h_{\bphi}}
\newcommand{\rPhi}{r_{\bphi}}
\newcommand{\myquad}[1][1]{\hspace*{#1em}\ignorespaces}
\newcommand{\da}{{\scriptscriptstyle\downarrow}}
\newcommand{\ua}{{\scriptscriptstyle\uparrow}}

\newcommand{\op}[1]{\operatorname{#1}}

\usepackage{hyperref}


\newcommand{\nal}[1]{}
\renewcommand{\nal}[1]{\todo[inline,color=green]{\textbf{Nal}: {#1}}}

\title{Colorization Transformer}




\author{Manoj Kumar, Dirk Weissenborn \& Nal Kalchbrenner \\
Google Research, Brain Team \\
\texttt{\{mechcoder,diwe,nalk\}@google.com} \\
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}


\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
We present the Colorization Transformer, a novel approach for diverse high fidelity image colorization based on self-attention. Given a grayscale image, the colorization proceeds in three steps. We first use a conditional autoregressive transformer to produce a low resolution coarse coloring of the grayscale image. Our architecture adopts conditional transformer layers to effectively condition grayscale input. Two subsequent fully parallel networks upsample the coarse colored low resolution image into a finely colored high resolution image. Sampling from the Colorization Transformer produces diverse colorings whose fidelity outperforms the previous state-of-the-art on colorising ImageNet based on FID results and based on a human evaluation in a Mechanical Turk test. Remarkably, in  more than 60\% of cases human evaluators prefer the highest rated among three generated colorings over the ground truth. The code and pre-trained checkpoints for Colorization Transformer are publicly available \href{https://github.com/google-research/google-research/tree/master/coltran}{\color{blue}{at this url}}.



\end{abstract}

\section{Introduction}
\begin{figure}[htp]
\setlength{\lineskip}{0pt}
  \centering
  \includegraphics[width=0.32\textwidth]{first_figure/image_0.pdf}
  \includegraphics[width=0.32\textwidth]{first_figure/image_1.pdf}
  \includegraphics[width=0.32\textwidth]{first_figure/image_2.pdf} \\
  \includegraphics[width=0.32\textwidth]{first_figure/image_3.pdf}
  \includegraphics[width=0.32\textwidth]{first_figure/image_4.pdf}
  \includegraphics[width=0.32\textwidth]{first_figure/image_5.pdf} \\
  \includegraphics[width=0.32\textwidth]{first_figure/image_6.pdf}
  \includegraphics[width=0.32\textwidth]{first_figure/image_7.pdf}
  \includegraphics[width=0.32\textwidth]{first_figure/image_8.pdf} \\
\caption{Samples of our model showing diverse, high-fidelity colorizations.}
\end{figure}




Image colorization is a challenging, inherently stochastic task that requires a semantic understanding of the scene as well as knowledge of the world.
Core immediate applications of the technique include producing organic new colorizations of existing image and video content as well as giving life to originally grayscale media, such as old archival images \citep{tsaftaris2014novel}, videos \citep{geshwind1986method} and black-and-white cartoons \citep{sykora2004unsupervised, qu2006manga, cinarel2017into}.
Colorization also has important technical uses as a way to learn meaningful representations without explicit supervision \citep{zhang2016colorful, larsson2016learning, vondrick2018tracking} or as an unsupervised data augmentation technique, whereby diverse semantics-preserving colorizations of labelled images are produced with a colorization model trained on a potentially much larger set of unlabelled images. 



The current state-of-the-art in automated colorization are neural generative approaches based on log-likelihood estimation \citep{guadarrama2017pixcolor,royer2017probabilistic,ardizzone2019guided}. Probabilistic models are a natural fit for the one-to-many task of image colorization and obtain better results than earlier determinisitic approaches avoiding some of the persistent pitfalls \citep{zhang2016colorful}. Probabilistic models also have the central advantage of producing multiple diverse colorings that are sampled from the learnt distribution. 

In this paper, we introduce the Colorization Transformer (ColTran), a probabilistic colorization model composed only of axial self-attention blocks \citep{ho2019axial, wang2020axial}. The main advantages of axial self-attention blocks are the ability to capture a global receptive field with only two layers and $\mathcal{O}(D \sqrt{D})$ instead of $\mathcal{O}(D^2)$ complexity. They can be implemented efficiently using matrix-multiplications on modern accelerators such as TPUs \citep{jouppi2017indatacenter}.
In order to enable colorization of high-resolution grayscale images, we decompose the task into three simpler sequential subtasks: coarse low resolution autoregressive colorization, parallel color and spatial super-resolution. For coarse low resolution colorization, we apply a conditional variant of Axial Transformer \citep{ho2019axial}, a state-of-the-art autoregressive image generation model that does not require custom kernels \citep{child2019generating}. While Axial Transformers support conditioning by biasing the input, we find that directly conditioning the transformer layers can improve results significantly. Finally, by leveraging the semi-parallel sampling mechanism of Axial Transformers we are able to colorize images faster at higher resolution than previous work \citep{guadarrama2017pixcolor} and as an effect this results in improved colorization fidelity. Finally, we employ fast parallel deterministic upsampling models to super-resolve the coarsely colorized image into the final high resolution output. In summary, our main contributions are:


\begin{itemize}
    \item First application of transformers for high-resolution ($256 \times 256$) image colorization.
    \item We introduce conditional transformer layers for low-resolution coarse colorization in Section \ref{cat}. The conditional layers incorporate conditioning information via multiple learnable components that are applied per-pixel and per-channel. We validate the contribution of each component with extensive experimentation and ablation studies.
    \item We propose training an auxiliary parallel prediction model jointly with the low resolution coarse colorization model in Section \ref{aux_pred_model}. Improved FID scores demonstrate the usefulness of this auxiliary model.
    \item We establish a new state-of-the-art on image colorization outperforming prior methods by a large margin on FID scores and a 2-Alternative Forced Choice (2AFC) Mechanical Turk test. Remarkably, in  more than 60\% of cases human evaluators prefer the highest rated among three generated colorings over the ground truth.
\end{itemize}


\section{Related work}
\label{related_work}
Colorization methods have initially relied on human-in-the-loop approaches to provide hints in the form of scribbles \citep{levin2004colorization, ironi2005colorization, huang2005adaptive, yatziv2006fast, qu2006manga, luan2007natural, tsaftaris2014novel, zhang2017real, ci2018user} and exemplar-based techniques that involve identifying a reference source image to copy colors from \citep{reinhard2001color, welsh2002transferring, tai2005local, ironi2005colorization, pitie2007automated, morimoto2009automatic, gupta2012image, xiao2020example}. Exemplar based techniques have been recently extended to video as well \citep{zhang2019deep}. In the past few years, the focus has  moved on to more automated, neural colorization methods. 
The deterministic colorization techniques such as CIC \citep{zhang2016colorful}, LRAC \citep{larsson2016learning}, LTBC \citep{iizuka2016let}, Pix2Pix \citep{isola2017image} and DC \citep{cheng2015deep, dahl2016automatic} involve variations of CNNs to model per-pixel color information conditioned on the intensity. 

Generative colorization models typically extend unconditional image generation models to incorporate conditioning information from a grayscale image. Specifically, cINN \citep{ardizzone2019guided} use conditional normalizing flows \citep{dinh2014nice}, VAE-MDN \citep{deshpande2017learning, deshpande2015learning} and SCC-DC \citep{Messaoud_2018_ECCV} use conditional VAEs \citep{kingma2013auto}, and cGAN \citep{cao2017unsupervised} use GANs \citep{goodfellow2014generative} for generative colorization. Most closely related to ColTran are other autoregressive approaches such as PixColor \citep{guadarrama2017pixcolor} and PIC \citep{royer2017probabilistic} with PixColor obtaining slightly better results than PIC due to its CNN-based upsampling strategy. ColTran is similar to PixColor in the usage of an autoregressive model for low resolution colorization and parallel spatial upsampling. ColTran differs from PixColor in the following ways. We train ColTran in a completely unsupervised fashion, while the conditioning network in PixColor requires pre-training with an object detection network that provides substantial semantic information. PixColor relies on PixelCNN \citep{oord2016pixel} that requires a large depth to model interactions between all pixels. ColTran relies on Axial Transformer \citep{ho2019axial} and can model all interactions between pixels with just 2 layers. PixColor uses different architectures for conditioning, colorization and super-resolution, while ColTran is conceptually simpler as we use self-attention blocks everywhere for both colorization and superresolution. Finally, we train our autoregressive model on a single coarse channel and a separate color upsampling network that improves fidelity (See: \ref{other_ablations}). The multi-stage generation process in ColTran that upsamples in depth and in size is related to that used in Subscale Pixel Networks \citep{menick2018generating} for image generation, with differences in the order and representation of bits as well as in the use of fully parallel networks.
The self-attention blocks that are the building blocks of ColTran were initially developed for machine translation \citep{vaswani2017attention}, but are now widely used in a number of other applications including density estimation \citep{parmar2018image, child2019generating, ho2019flow++,weissenborn2019scaling} and GANs \citep{zhang2019self}



\section{Background: Axial Transformer}

\subsection{Row and column self-attention}
\label{self_attention}

Self-attention (SA) has become a standard building block in many neural architectures. Although the complexity of self-attention is quadratic with the number of input elements (here pixels), it has become quite popular for image modeling recently \citep{parmar2018image, weissenborn2019scaling} due to modeling innovations that don't require running global self-attention between all pixels. Following the work of \citep{ho2019axial} we employ standard $\bq \bk \bv$ self-attention \citep{vaswani2017attention} within rows and columns of an image. By alternating row- and column self-attention we effectively allow global exchange of information between all pixel positions. For the sake of brevity we omit the exact equations for multihead self-attention and refer the interested reader to the Appendix~\ref{sec:row_col_self_attention} for more details. Row/column attention layers are the core components of our model. We use them in the autoregressive colorizer, the spatial upsampler and the color upsampler.

\subsection{Axial Transformer}
\label{autorec_base}

Ths Axial Transformer \citep{ho2019axial} is an autoregressive model that applies (masked) row- and column self-attention operations in a way that efficiently summarizes all past information $\bx_{i,<j}$ and $\bx_{<i,\cdot}$ to model a distribution over pixel $\bx_{i,j}$ at position $i,j$. Causal masking is employed by setting all $A_{m,n} = 0$ where $n > m$ during self-attention (see Eq.~\ref{eq:attn_matrix}).

\paragraph{Outer decoder.} The outer decoder computes a state $\bs_{o}$ over all previous rows $\bx_{\leq i,\cdot}$ by applying $N$ layers of full row self-attention followed by masked column self-attention. (Eq \ref{outer2}).  $\bs_{o}$  is shifted down by a single row, such that the output context $\bo_{i, j}$ at position $i,j$ only contains information about pixels $\bx_{<i, \cdot}$ from prior rows. (Eq \ref{outer3})
\begin{align}
    \be &= \text{Embeddings}(\bx) \label{outer1}\\
    \bs_{o} &= \text{MaskedColumn}(\text{Row}(\be)) \qquad \times N \label{outer2} \\
    \bo &= \text{ShiftDown}(\bs_{o}) \label{outer3}
\end{align}
\paragraph{Inner decoder.} The embeddings to the inner decoder are shifted right by a single column to mask the current pixel $\bx_{i, j}$. The context $\bo$ from the outer decoder conditions the inner decoder by biasing the shifted embeddings. It then computes a final state $\bh$, by applying $N$ layers of masked row-wise self-attention to infuse additional information from prior pixels of the same row $\bx_{i, <j}$ (Eq \ref{inner1}). $\bh_{i, j}$ comprises information about all past pixels $\bx_{<i}$ and $\bx_{i, <j}$. A dense layer projects $\bh$ into a distribution $p(\bx_{ij})$ over the pixel at position $(i,j)$ conditioned on all previous pixels $\bx_{i,<j}$ and $\bx_{<i,\cdot}$.
\begin{align}
    \bz &= \bo + \text{ShiftRight}(\be) \label{inner1} \\
     \bh &= \text{MaskedRow}(\bz) \qquad \times N \label{inner2}\\
     p(\bx_{ij}) &= \text{Dense}(\bh)
     \label{dense}
\end{align}
\paragraph{Encoder.} As shown above, the outer and inner decoder operate on 2-D inputs, such as a single channel of an image. For multi-channel  RGB images, when modeling the "current channel", the Axial Transformer incorporates information from prior channels of an image (as per raster order) with an encoder. The encoder encodes each prior channel independently with a stack of unmasked row/column attention layers. The encoder outputs across all prior channels are summed to output a conditioning context $\bc$ for the "current channel". The context  conditions the outer and inner decoder by biasing the inputs in Eq \ref{outer1} and Eq \ref{inner1} respectively.

\paragraph{Sampling.} The Axial Transformer natively supports semi-parallel sampling that avoids re-evaluation of the entire network to generate each pixel of a RGB image. The encoder is run once per-channel, the outer decoder is run once per-row and the inner decoder is run once per-pixel. The context from the outer decoder and the encoder is initially zero. The encoder conditions the outer decoder (Eq \ref{outer1}) and the encoder + outer decoder condition the inner decoder (Eq \ref{inner1}). The inner decoder then generates a row, one pixel at a time via \cref{inner1,inner2,dense}. After generating all pixels in a row, the outer decoder recomputes context via \cref{outer1,outer2,outer3} and the inner decoder generates the next row. This proceeds till all the pixels in a channel are generated.
The encoder, then recomputes context to generate the next channel.


\begin{figure}[t]
  \centering
  \includegraphics[width=\textwidth]{auto_color_rebuttal.pdf}
  \caption{Depiction of ColTran. It consists of 3 individual models: an autoregressive colorizer (left), a color upsampler (middle) and a spatial upsampler (right). Each model is optimized independently. The autoregressive colorizer (ColTran core) is an instantiation of Axial Transformer (Sec.~\ref{autorec_base}, \citet{ho2019axial}) with conditional transformer layers and an auxiliary parallel head proposed in this work (Sec.~\ref{cat}). During training, the ground-truth coarse low resolution image is both the input to the decoder and the target. Masked layers ensure that the conditional distributions for each pixel depends solely on previous ground-truth pixels. (See Appendix~\ref{sec:autoregressive models} for a recap on autoregressive models). ColTran upsamplers are stacked row/column attention layers that deterministically upsample color and space in parallel. Each attention block (in green) is residual and consists of the following operations: layer-norm $\rightarrow$ multihead self-attention $\rightarrow$ MLP.}\label{fig:illustration}
\end{figure}

\section{Proposed Architecture}

Image colorization is the task of transforming a grayscale image $x^g \in \mathbb{R}^{H{\times}W{\times}1}$ into a colored image $x \in \mathbb{R}^{H{\times}W{\times}3}$. The task is inherently stochastic; for a given grayscale image $x^g$, there exists a conditional distribution over $x$, $p(x | x^g)$. Instead of predicting $x$ directly from $x^g$, we instead sequentially predict two intermediate low resolution images $x^{s\da}$ and $x^{s\da c\da}$ with different color depth first. Besides simplifying the task of high-resolution image colorization into simpler tasks, the smaller resolution allows for training larger models.

We obtain $x^{s\da}$, a spatially downsampled representation of $x$, by standard area interpolation. $x^{s\da c\da}$ is a 3 bit per-channel representation of $x^{s\da}$, that is, each color channel has only 8 intensities. Thus, there are $8^3=512$ coarse colors per pixel which are predicted directly as a single ``color'' channel. We rewrite the conditional likelihood $p(x | x^g)$ to incorporate the intermediate representations as follows:
\begin{align}
p(x| x^g) &= p(x| x^g) \cdot 1 = p(x| x^g) \cdot p(x^{s\da c\da}, x^{s\da} | x, x^g) = p(x^{s\da c\da}, x^{s\da}, x | x^g) \\
              &= p(x | x^{s\da}, x^g) \cdot p(x^{s\da} | x^{s\da c\da}, x^g) \cdot p(x^{s\da c\da}| x^g)
\end{align}
ColTran core (Section \ref{cat}), a parallel color upsampler and a parallel spatial upsampler (Section \ref{upsamplers}) model $p(x^{s\da c\da}| x^g), p(x^{s\da} | x^{s\da c\da}, x^g)$ and $p(x | x^{s\da})$ respectively. In the subsections below, we describe these individual components in detail. From now on we will refer to all low resolutions as $M \times N$ and high resolution as $H \times W$. An illustration of the overall architecture is shown in Figure~\ref{fig:illustration}.





\subsection{ColTran Core}
\label{cat}

In this section, we describe ColTran core, a conditional variant of the Axial Transformer \citep{ho2019axial} for low resolution coarse colorization. ColTran Core models a distribution $p_c(x^{s\da c\da}|x^g)$ over 512 coarse colors for every pixel, conditioned on a low resolution grayscale image in addition to the colors from previously predicted pixels as per raster order (Eq.~\ref{eq:fc_autoregressive}). 
\begin{align}
  p_c(x^{s\da c\da}|x^g) &= \prod_{i=1}^M\prod_{j=1}^N p_c(x^{s\da c\da}_{ij} | x^{g}, x^{s\da c\da}_{<i}, x^{s\da c\da}_{i, <j}) \label{eq:fc_autoregressive}
\end{align}
\begin{table}
\centering
\small
\begin{tabular}{c  c  c}
\hline \addlinespace[0.1cm]
\textbf{Component} & \textbf{Unconditional} & \textbf{Conditional} \\
\hline \addlinespace[0.1cm]
\textbf{Self-Attention} &
$ \by = \text{Softmax}(\frac{\bq\bk^{\top}}{\sqrt{D}})\bv$ &
$\begin{array} {lcl}
\by = \text{Softmax}(\frac{\bq_c \bk_c^{\top}}{\sqrt{D}})\bv_c\\ \\
\text{where} \quad \forall \bz = \bk, \bq, \bv \\
\bz_c = (\bc U_s^{z}) \odot \bz + (\bc U_b^{z})\\
\end{array}$ \\
\addlinespace[0.1cm]
\hline \addlinespace[0.1cm]
\textbf{MLP} &
$\by = \text{ReLU}(\bb{x} U_1 + \mathbf{b}_1) U_2 + \mathbf{b}_2$&
$\begin{array} {lcl}
\bh = \text{ReLU}(\bb{x} U_1 + \mathbf{b}_1) U_2 + \mathbf{b}_2\\
\by = (\bc U^f_s) \odot \bh + (\bc U^f_b) \\
\end{array}$ \\
\addlinespace[0.1cm]
\hline \addlinespace[0.1cm]
\textbf{Layer Norm} &
$\by = \beta \, \text{Norm}(\bb{x}) + \gamma$&
$\begin{array} {lcl}
\by = \beta_c \, \text{Norm}(\bb{x}) + \gamma_c \\ \\
\text{where} \quad \forall \mu = \beta_c, \gamma_c \\
\bc \in \mathbb{R}^{H \times W \times D} \rightarrow \hat{\bc} \in \mathbb{R}^{HW \times D}\\
\mu = (\mathbf{u} \cdot \hat{\bc}) U^\mu_{d}  \quad \mathbf{u} \in \mathbb{R}^{HW} \\
\end{array}$ \\
\addlinespace[0.1cm]
\hline
\end{tabular}
\caption{We contrast the different components of unconditional self-attention with self-attention conditioned on context $\bb{c} \in \mathbb{R}^{M {\times} N {\times} D}$. Learnable parameters specific to conditioning are denoted by $\mathbf{u}$ and $U_\cdot \in \mathbb{R}^{D {\times} D}$.}
\label{tab:cond_trans}
\end{table}

Given a context representation $\bc \in \mathbb{R}^{M {\times} N {\times} D}$ we propose conditional transformer layers in Table~\ref{tab:cond_trans}. Conditional transformer layers have conditional versions of all components within the standard attention block (see Appendix~\ref{sec:row_col_self_attention}, Eqs.~\ref{eq:qkv}-\ref{eq:attn}).

\textbf{Conditional Self-Attention.} For every layer in the decoder, we apply six $1 {\times} 1$ convolutions to $\bc$ to obtain three scale and shift vectors which we apply element-wise to $\bq$, $\bk$ and $\bv$ of the self-attention operation (Appendix~\ref{self_attention}), respectively.

\textbf{Conditional MLP.}
A standard component of the transformer architecture is a two layer pointwise feed-forward network after the self-attention layer. We scale and shift to the output of each MLP conditioned on $\bc$ as for self-attention.

\textbf{Conditional Layer Norm.}
Layer normalization \citep{ba2016layer} globally scales and shifts a given normalized input using learnable vectors $\beta$, $\gamma$. Instead, we predict $\beta_c$ and $\gamma_c$ as a function of $\bc$. We first aggregate $\bc$ into a global 1-D representation $\overline{\bc} \in \mathbb{R}^{L}$ via a learnable, spatial pooling layer. Spatial pooling is initialized as a mean pooling layer. Similar to 1-D conditional normalization layers \citep{perez2017film, de2017modulating, dumoulin2016learned, huang2017arbitrary}, we then apply a linear projection on $\overline{\bc}$ to predict $\beta_c$ and $\gamma_c$, respectively.

A grayscale encoder consisting of multiple, alternating row and column self-attention layers encodes the grayscale image into the initial conditioning context $\bc^{g}$. It serves as both context for the conditional layers and as additional input to the embeddings of the outer decoder. The sum of the outer decoder's output and $\bc^g$ condition the inner decoder. Figure~\ref{fig:illustration} illustrates how conditioning is applied in the autoregressive core of the ColTran architecture.

Conditioning every layer via multiple components allows stronger gradient signals through the encoder and as an effect the encoder can learn better contextual representations. We validate this empirically by outperforming the native Axial Transformer that conditions context states by biasing (See Section \ref{ablations} and Section \ref{comparison_expts}).

\subsection{Auxiliary parallel model}
\label{aux_pred_model}

We additionally found it beneficial to train an auxiliary parallel prediction model that models $\widetilde{p}_c(x^{s\da c\da})$ directly on top of representations learned by the grayscale encoder  which we found beneficial for regularization (Eq.~\ref{eq:fc_parallel})
\begin{align}
 \widetilde{p}_c(x^{s\da c\da}|x^g) &= \prod_{i=1}^M\prod_{j=1}^N \widetilde{p}_c(x^{s\da c\da}_{ij} | x^{g}) \label{eq:fc_parallel} 
\end{align}
Intuitively, this forces the model to compute richer representations and global color structure already at the output of the encoder which can help conditioning and therefore has a beneficial, regularizing effect on learning.
We apply a linear projection, $U_{\text{parallel}} \in \mathbb{R}^{L {\times} 512}$ on top of $\bc^{g}$ (the output of the grayscale encoder) into a per-pixel distribution over 512 coarse colors. It was crucial to tune the relative contribution of the autoregressive and parallel predictions to improve performance which we study in Section \ref{other_ablations}


\subsection{Color \& Spatial Upsampling}
\label{upsamplers}

In order to produce high-fidelity colorized images from low resolution, coarse color images and a given high resolution grayscale image, we train color and spatial upsampling models. They share the same architecture while differing in their respective inputs and resolution at which they operate. Similar to the grayscale encoder, the upsamplers comprise of multiple alternating layers of row and column self-attention. The output of the encoder is projected to compute the logits underlying the per pixel color probabilities of the respective upsampler. Figure~\ref{fig:illustration} illustrates the architectures

\textbf{Color Upsampler.}
We convert the coarse image $x^{s\da c\da} \in \mathbb{R}^{M \times N {\times} 1}$ of 512 colors back into a 3 bit RGB image with 8 symbols per channel. The channels are embedded using separate embedding matrices to $\bx_k^{s\da c\da} \in \mathbb{R}^{M \times N {\times} D}$, where $k \in {\{R,G,B\}}$ indicates the channel. We upsample each channel individually conditioning only on the respective channel's embedding. The channel embedding is summed with the respective grayscale embedding for each pixel and serve as input to the subsequent self-attention layers (encoder). The output of the encoder is further projected to per pixel-channel probability distributions $\widetilde{p}_{c\ua}(x_k^{s\da}|x^{s\da c\da}, x^g) \in \mathbb{R}^{M \times N {\times} 256}$ over 256 color intensities for all $k \in {\{R,G,B\}}$ (Eq.~\ref{eq:f_cua}).
\begin{align}
  \widetilde{p}_{c\ua}(x^{s\da}|x^g) &= \prod_{i=1}^M\prod_{j=1}^N \widetilde{p}_{c\ua}(x^{s\da}_{ij} | x^{g}, x^{s\da c\da}) \label{eq:f_cua}
\end{align}
\textbf{Spatial Upsampler.} We first naively upsample $x^{s\da} \in \mathbb{R}^{M \times N {\times} 3}$ into a blurry, high-resolution RGB image using area interpolation. As above, we then embed each channel of the blurry RGB image and run a per-channel encoder exactly the same way as with the color upsampler. The output of the encoder is finally projected to per pixel-channel probability distributions $\widetilde{p}_{s\ua}(x_k|x^{s\da}, x^g) \in \mathbb{R}^{H \times W {\times} 256}$ over 256 color intensities for all $k \in {\{R,G,B\}}$. (Eq.~\ref{eq:f_csa})


\begin{align}
  \widetilde{p}_{s\ua}(x|x^g) &= \prod_{i=1}^H\prod_{j=1}^W \widetilde{p}_{s\ua}(x_{ij} | x^{g}, x^{s\da}) \label{eq:f_csa} 
\end{align}

In our experiments, similar to \citep{guadarrama2017pixcolor}, we found parallel upsampling to be sufficient for high quality colorizations. Parallel upsampling has the huge advantage of fast generation which would be notoriously slow for full autoregressive models on high resolution. To avoid plausible minor color inconsistencies between pixels, instead of sampling each pixel from the predicted distribution in (Eq.~\ref{eq:f_csa} and Eq.~\ref{eq:f_cua}), we just use the argmax. Even though this slightly limits the potential diversity of colorizations, in practice we observe that sampling only coarse colors via ColTran core is enough to produce a great variety of colorizations. 

\paragraph{Objective.} We train our architecture to minimize the negative log-likelihood (Eq.~\ref{eq:objective}) of the data. $p_c/\widetilde{p}_c$, $\widetilde{p}_{s\ua}$, $\widetilde{p}_{c\ua}$ are maximized independently and $\lambda$ is a hyperparameter that controls the relative contribution of $p_c$ and $\widetilde{p}_c$
\begin{align}
    \mathcal{L} = (1-\lambda) \log p_{c} + \lambda \log \widetilde{p}_c + \log \widetilde{p}_{c\ua} + \log \widetilde{p}_{s\ua} \label{eq:objective}
\end{align}

\section{Experiments}

\subsection{Training and Evaluation}
We evaluate ColTran on colorizing $256 {\times} 256$ grayscale images from the ImageNet dataset \citep{russakovsky2015imagenet}. We train the ColTran core, color and spatial upsamplers independently on 16 TPUv2 chips with a batch-size of $224$, $768$ and $32$ for 600K, 450K and 300K steps respectively. We use $4$ axial attention blocks in each component of our architecture, with a hidden size of $512$ and $4$ heads. We use RMSprop \citep{tieleman2012lecture} with a fixed learning rate of $3e-4$. We set apart 10000 images from the training set as a holdout set to tune hyperparameters and perform ablations. To compute FID, we generate $5000$ samples conditioned on the grayscale images from this holdout set. We use the public validation set to display qualitative results and report final numbers. 

\begin{figure*}
\centering
\includegraphics[scale=0.44]{ablations_v1.pdf} \hfill
\includegraphics[scale=0.44]{ablations_v2.pdf} \hfill
\includegraphics[scale=0.44]{ablations_v3.pdf}

\caption{Per pixel log-likelihood of coarse colored $64 \times 64$ images over the validation set as a function of training steps. We ablate the various components of the ColTran core in each plot. \textbf{Left:} \textit{ColTran} with Conditional Transformer Layers vs a baseline Axial Transformer which conditions via addition (\textit{ColTran-B}). \textit{ColTran-B 2x} and \textit{ColTran-B 4x} refer to wider baselines with increased model capacity. \textbf{Center:} Removing each conditional sub-component one at a time (\textit{no cLN}, \textit{no cMLP} and \textit{no cAtt}). \textbf{Right:} Conditional shifts only (\textit{Shift}), Conditional scales only (\textit{Scale}), removal of kq conditioning in cAtt (\textit{cAtt, only v}) and fixed mean pooling in cLN (\textit{cLN, mean pool}). See Section \ref{ablations} for more details.}
\label{fig:ablation_v1}
\end{figure*}

\subsection{Ablations of ColTran Core}
\label{ablations}

The autoregressive core of ColTran models downsampled, coarse-colored images of resolution $64 \times 64$ with $512$ coarse colots, conditioned on the respective grayscale image. In a series of experiments we ablate the different components of the architecture (Figure \ref{fig:ablation_v1}). In the section below, we refer to the conditional self-attention, conditional layer norm and conditional MLP subcomponents as cAtt, cLN and cMLP respectively. We report the per-pixel log-likelihood over $512$ coarse colors on the validation set as a function of training steps.


\textbf{Impact of conditional transformer layers.} The left side of Figure~\ref{fig:ablation_v1} illustrates the significant  improvement in loss that ColTran core (with conditional transformer layers) achieves over the original Axial Transformer (marked \textit{ColTran-B}). This demonstrates the usefulness of our proposed conditional layers. Because conditional layers introduce a higher number of parameters we additionally compare to and outperform the original Axial Transformer baselines with 2x and 4x wider MLP dimensions (labeled as \textit{ColTran-B 2x} and \textit{ColTran-B 4x}). Both \textit{ColTran-B 2x} and \textit{ColTran-B 4x} have an increased parameter count which makes for a fair comparison. Our results show that the increased performance cannot be explained solely by the fact that our model has more parameters.

\textbf{Importance of each conditional component.} We perform a leave-one-out study to determine the importance of each conditional component. We remove each conditional component one at a time and retrain the new ablated model. The curves \textit{no cLN}, \textit{no cMLP} and \textit{no cAtt} in the middle of Figure~\ref{fig:ablation_v1} quantifies our results. While each conditional component improves final performance, cAtt plays the most important role.

\textbf{Multiplicative vs Additive Interactions.}  Conditional transformer layers employ both conditional shifts and scales consisting of additive and multiplicative interactions, respectively. The curves \textit{Scale} and \textit{Shift} on the right hand side of Figure~\ref{fig:ablation_v1} demonstrate the impact of these interactions via ablated architectures that use conditional shifts and conditional scales only. While both types of interactions are important, multiplicative interactions have a much stronger impact.

\textbf{Context-aware dot product attention.} Self-attention computes the similarity between pixel representations using a dot product between $\bq$ and $\bk$ (See: Eq~ \ref{eq:attn_matrix}). cAtt applies conditional shifts and scales on $\bq$, $\bk$ and allow modifying this similarity based on contextual information. The curve \textit{cAtt, only v} on the right of Figure~\ref{fig:ablation_v1} shows that removing this property, by conditioning only on $\bv$ leads to worse results.

\textbf{Fixed vs adaptive global representation:} cLN aggregates global information with a flexible learnable spatial pooling layer. We experimented with a fixed mean pooling layer forcing all the cLN layers to use the same global representation with the same per-pixel weight. The curve \textit{cLN, mean pool} on the right of Figure~\ref{fig:ablation_v1} shows that enforcing this constraint causes inferior performance as compared to even having no cLN. This indicates that different aggregations of global representations are important for different cLN layers.

\begin{figure*}
\centering
\includegraphics[scale=0.44]{fid_at_aux_loss.pdf} \hfill
\includegraphics[scale=0.44]{fid_at_aux_loss_v2.pdf} \hfill
\includegraphics[scale=0.44]{fid_vs_loss.pdf}

\caption{\textbf{Left:} FID of generated 64 $\times$ 64 coarse samples as a function of training steps for $\lambda=0.01$ and $\lambda=0.0$. \textbf{Center:} Final FID scores as a function of $\lambda$. \textbf{Right:} FID as a function of log-likelihood.}
\label{fig:ablation_aux_loss}
\end{figure*}

\subsection{Other ablations}
\label{other_ablations}

\paragraph{Auxiliary Parallel Model.} We study the effect of the hyperparameter $\lambda$, which controls the contribution of the auxiliary parallel prediction model described in Section \ref{aux_pred_model}. For a given $\lambda$, we now optimize $\hat{p_{c}}(\lambda) = (1 - \lambda)\log p_{c}(.) + \lambda \log \widetilde{p}_c(.)$ instead of just $\log p_c(.)$. Note that $\widetilde{p}_c(.)$, models each pixel independently, which is more difficult than modelling each pixel conditioned on previous pixels given by $p_{c}(.)$. Hence, employing $\hat{p}_{c}(\lambda)$ as a holdout metric, would just lead to a trivial soluion at $\lambda=0$. Instead, the FID of the generated coarse 64x64 samples provides a reliable way to find an optimal value of $\lambda$. In Figure \ref{fig:ablation_aux_loss}, at $\lambda=0.01$, our model converges to a better FID faster with a marginal but consistent final improvement. At higher values the performance deteriorates quickly.

\paragraph{Upsamplers.} Upsampling coarse colored, low-resolution images to a higher resolution is much simpler. Given ground truth $64 \times 64$ coarse images, the ColTran upsamplers map these to fine grained $256 \times 256$ images without any visible artifacts and FID of 16.4. For comparison, the FID between two random sets of 5000 samples from our holdout set is 15.5. It is further extremely important to provide the grayscale image as input to each of the individual upsamplers, without which the generated images appear highly smoothed out and the FID drops to 27.0. We also trained a single upsampler for both color and resolution. The FID in this case drops marginally to 16.6.



\subsection{Frechet Inception Distance}
\label{comparison_expts}

We compute FID using colorizations of 5000 grayscale images of resolution 256 $\times$ 256 from the ImageNet validation set as done in \citep{ardizzone2019guided}. To compute the FID, we ensure that there is no overlap between the grayscale images that condition ColTran and those in the ground-truth distribution. In addition to ColTran, we report two additional results \textit{ColTran-S} and \textit{ColTran-B}. \textit{ColTran-B} refers to the baseline Axial Transformer that conditions via addition at the input. PixColor samples smaller 28 $\times$ 28 colored images autoregressively as compared to ColTran's 64 $\times$ 64. As a control experiment, we train an autoregressive model on resolution 28 $\times$ 28 (\textit{ColTran-S}) to disentangle architectural choices and the inherent stochasticity of modelling higher resolution images. \textit{ColTran-S} and \textit{ColTran-B} obtains FID scores of 22.06 and 19.98 that significantly improve over the previous best FID of 24.32. Finally, ColTran achieves the best FID score of 19.37. All results are presented in Table~\ref{tab:results} left.

\paragraph{Correlation between FID and Log-likelihood.} For each architectural variant, Figure~\ref{fig:ablation_aux_loss} right illustrates the correlation between the log-likelihood and FID after 150K training steps. There is a moderately positive correlation of 0.57 between the log-likelihood and FID. Importantly, even an absolute improvement on the order of ~0.01 - 0.02 can improve FID significantly. This suggests that designing architectures that achieve better log-likelihood values is likely to lead to improved FID scores and colorization fidelity.

\begin{table}[t]
    \footnotesize
    \centering
    \begin{minipage}{.4\linewidth}
    \begin{tabular}{cc}
        \hline
        \addlinespace[0.05cm]
        \textbf{Models} & \textbf{FID} \\
        \addlinespace[0.05cm]
        \hline
        \addlinespace[0.05cm]
ColTran & \textbf{19.37 $\pm$ 0.09} \\
        ColTran-B & 19.98 $\pm$ 0.20 \\
        ColTran-S & 22.06 $\pm$ 0.13 \\
        \addlinespace[0.05cm]
        \Xhline{2\arrayrulewidth}\addlinespace[0.05cm]\hline
        \addlinespace[0.05cm]
         PixColor [\citenum{guadarrama2017pixcolor}] & 24.32 $\pm$ 0.21 \\
         cGAN [\citenum{cao2017unsupervised}] & 24.41 $\pm$ 0.27 \\
         cINN [\citenum{ardizzone2019guided}] & 25.13 $\pm$ 0.3 \\
         VAE-MDN [\citenum{deshpande2017learning}] & 25.98 $\pm$ 0.28 \\ 
         \addlinespace[0.05cm]
         \hline
         \addlinespace[0.05cm]
         Ground truth & 14.68 $\pm$ 0.15 \\
         Grayscale & 30.19 $\pm$ 0.1 \\
         \addlinespace[0.05cm]
         \hline
         \hline
         \addlinespace[0.05cm]
        \end{tabular} 
        \end{minipage} \hspace{2em}
    \begin{minipage}{.4\linewidth}
        \begin{tabular}{c c}
        \hline
        \addlinespace[0.05cm]
        \textbf{Models} & \textbf{AMT Fooling rate} \\
        \addlinespace[0.05cm]
        \hline
        \addlinespace[0.05cm]
        ColTran (Oracle) &  62.0 \% $\pm$ 0.99\\
        ColTran (Seed 1) &  40.5 \% $\pm$ 0.81 \\
        ColTran (Seed 2) &  \textbf{42.3 \% $\pm$ 0.76} \\
        ColTran (Seed 3) & 41.7 \% $\pm$ 0.83 \\
        \addlinespace[0.05cm]
        \Xhline{2\arrayrulewidth}\addlinespace[0.05cm]\hline
        \addlinespace[0.05cm]
        PixColor [\citenum{guadarrama2017pixcolor}] (Oracle) & 38.3 \% $\pm$ 0.98 \\
        PixColor (Seed 1) & 33.3 \% $\pm$ 1.04 \\
        PixColor (Seed 2) & 35.4 \% $\pm$ 1.01 \\
        PixColor (Seed 3) & 33.2 \% $\pm$ 1.03 \\
        \Xhline{2\arrayrulewidth}\addlinespace[0.05cm]\hline
        \addlinespace[0.05cm]
        CIC [\citenum{zhang2016colorful}] & 29.2 \% $\pm$ 0.98 \\
        LRAC [\citenum{larsson2016learning}] & 30.9 \% $\pm$ 1.02 \\
        LTBC [\citenum{iizuka2016let}] & 25.8 \% $\pm$ 0.97 \\
        \addlinespace[0.05cm]
        \hline
        \hline
        \end{tabular}
    \end{minipage}
    \caption{We outperform various state-of-the-art colorization models both on FID (left) and human evaluation (right). We obtain the FID scores from \citep{ardizzone2019guided} and the human evaluation results from \citep{guadarrama2017pixcolor}. ColTran-B is a baseline Axial Transformer that conditions via addition and ColTran-S is a control experiment where we train ColTran core (See: \ref{cat}) on smaller 28 $\times$ 28 colored images.}
    \label{tab:results}
\end{table}

\subsection{Qualitative Evaluation}
\label{comparison_expts_human}

\paragraph{Human Evaluation.} For our qualitative assessment, we follow the protocol used in PixColor \citep{guadarrama2017pixcolor}. ColTran colorizes 500 grayscale images, with 3 different colorizations per image, denoted as seeds. Human raters assess the quality of these colorizations with a two alternative-forced choice (2AFC) test. We display both the ground-truth and recolorized image sequentially for one second in random order. The raters are then asked to identify the image with fake colors. For each seed, we report the mean fooling rate over 500 colorizations and 5 different raters. For the oracle methods, we use the human rating to pick the best-of-three colorizations. ColTran's best seed achieves a fooling rate of 42.3 \% compared to the 35.4 \% of PixColor's best seed. ColTran Oracle achieves a fooling rate of 62 \%, indicating that human raters prefer ColTran's best-of-three colorizations over the ground truth image itself.

\begin{figure}[t]
\centering
\setlength{\lineskip}{0pt}
    
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/image1.pdf}
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/cmap1.pdf}
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/image2.pdf}  
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/cmap2.pdf}
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/image3.pdf}  
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/cmap3.pdf}
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/image4.pdf}
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/cmap4.pdf}
 \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/image5.pdf}  
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/cmap5.pdf}
\caption{We display the per-pixel, maximum predicted probability over 512 colors as a proxy for uncertainty.}
\label{fig:cmap}
\end{figure}

\paragraph{Visualizing uncertainty.} The autoregressive core model of ColTran should be highly uncertain at object boundaries when colors change. Figure~\ref{fig:cmap} illustrates the per-pixel, maximum predicted probability over 512 colors as a proxy for uncertainty. We observe that the model is indeed highly uncertain at edges and within more complicated textures. 


\section{Conclusion}
We presented the Colorization Transformer (ColTran), an architecture that entirely relies on self-attention for image colorization.
We introduce conditional transformer layers, a novel building block for conditional, generative models based on self-attention. Our ablations show the superiority of employing this mechanism over a number of different baselines. Finally, we demonstrate that ColTran can generate diverse, high-fidelity colorizations on ImageNet, which are largely indistinguishable from the ground-truth even for human raters.
 
\bibliography{iclr2021_conference}
\bibliographystyle{iclr2021_conference}

\newpage
\appendix

\subsubsection*{acknowledgements}
We would like to thank Mohammad Norouzi, Rianne van den Berg, Mostafa Dehghani for their useful comments on the draft and Avital Oliver for assistance in the Mechanical Turk setup.

\subsection*{Changelog}
\begin{itemize}
    \item \textbf{v2:} Dataset Sharding \href{https://github.com/google-research/google-research/commit/9b55abc4c5ce56e05eabf97b38e54ed4f02f1f5c#diff-97a2eb4ed45d676bd37895ab6f334e7bd9f7dd293b30264bbfbb052079f617c4}{\color{blue}{fix}} across multiple TPU workers. This changed the FID scores of ColTran, ColTran-B and ColTran-S from their \textbf{v1} values of 19.71, 21.6 and 21.9 to their \textbf{v2} values of 19.37, 19.98 and 22.06 respecitvely.
\end{itemize}


\section{Code, checkpoints and tensorboard files}

Our implementation is open-sourced in the google-research framework at \href{https://github.com/google-research/google-research/tree/master/coltran}{\color{blue}{https://github.com/google-research/google-research/tree/master/coltran}} with a zip compressed version \href{https://storage.cloud.google.com/gresearch/coltran/coltran.zip}{\color{blue}here}. Our full set of hyperparameters are available \href{https://github.com/google-research/google-research/tree/master/coltran/configs}{\color{blue}{here}}.


We provide pre-trained checkpoints of the colorizer and upsamplers on ImageNet at \href{https://console.cloud.google.com/storage/browser/gresearch/coltran}{\color{blue}{https://console.cloud.google.com/storage/browser/gresearch/coltran}}. 
Finally, reference tensorboard files for our training runs are available at \href{https://tensorboard.dev/experiment/jrf7Og9oTeGEL2KrArQu6Q/#scalars&_smoothingWeight=0}{\color{blue}{colorizer tensorboard}}, \href{https://tensorboard.dev/experiment/H1djRZFXSbmmRMx5eG7hoA/#scalars&_smoothingWeight=0}{\color{blue}{color upsampler tensorboard}} and \href{https://tensorboard.dev/experiment/eZAzlXyESA2lmjmR5hDWNQ/#scalars&_smoothingWeight=0}{\color{blue}{spatial upsampler tensorboard}}.


\section{Exponential Moving Average}
\label{fid:ema}
We found using an exponential moving average (EMA) of our checkpoints, extremely crucial to generate high quality samples. In Figure \ref{fig:misc_expts}, we display the FID as a function of training steps, with and without EMA. On applying EMA, our FID score improves steadily over time.


\begin{figure*}
\centering
\includegraphics[scale=0.45]{polyak.pdf} \,
\includegraphics[scale=0.45]{fid_vs_k.pdf}
\caption{\textbf{Left}: FID vs training steps, with and without polyak averaging. \textbf{Right}: The effect of K in top-K sampling on FID. See Appendix ~\ref{fid:ema} and ~\ref{fid:topk}}
\label{fig:misc_expts}
\end{figure*}

\section{Number of parameters and inference speed}

\paragraph{Inference speed.} ColTran core can sample a batch of 20 64x64 grayscale images in around 3.5 -5 minutes on a P100 GPU vs PixColor that takes ~10 minutes to colorize 28x28 grayscale images on a K40 GPU. Sampling 28x28 colorizations takes around 30 seconds. The upsampler networks take in the order of milliseconds.

Further, in our naive implementation, we recompute the activations, $\bc U_s^{z}, \bc U_b^{z}, \bc U_s^{f}, \bc U_b^{f}$ in Table \ref{tab:cond_trans} to generate every pixel in the inner decoder. Instead, we can compute these activations once per-grayscale image in the encoder and once per-row in the outer decoder and reuse them. This is likely to speed up sampling even more and we leave this engineering optimization for future work.


\paragraph{Number of parameters.}
ColTran has a total of ColTran core (46M) + Color Upsampler (14M) + Spatial Upsampler (14M) = 74M parameters. In comparison, PixColor has Conditioning network (44M) + Colorizer network (11M) + Refinement Network (28M) = 83M parameters.

\section{Lower compute regime}

We retrained the autoregressive colorizer and color upsampler on 4 TPUv2 chips (the lowest configuration) with a reduced-batch size of 56 and 192 each.  For the spatial upsampler, we found that a batch-size of 8 was sub-optimal and lead to a large deterioration in loss. We thus used a smaller spatial upsampler with 2 axial attention blocks with a batch-size of 16 and trained it also on 4 TPUv2 chips.
The FID drops from 19.71 to 20.9 which is still significantly better than the other models in \ref{tab:results}.
We note that in this experiment, we use only 12 TPUv2 chips in total while PixColor \citep{guadarrama2017pixcolor} uses a total of 16 GPUs.

\section{Improved FID with Top-K sampling}
\label{fid:topk}
We can improve colorization fidelity and remove artifacts due to unnatural colors via Top-K sampling at the cost of reduced colorization diversity. In this setting, for a given pixel ColTran generates a color from the top-K colors (instead of 512 colors) as determined by the predicted probabilities. Our results in Figure~\ref{fig:misc_expts} $K = 4$ and $K = 8$ demonstrate a performance improvement over the baseline ColTran model with $K=512$

\section{Additional ablations:}

Additional ablations of our conditional transformer layers are in Figure \ref{fig:ablation_misc} which did not help.

\begin{itemize}
    \item Conditional transformer layers based on Gated layers \citep{oord2016pixel} (\textit{Gated})
    \item A global conditioning layer instead of pointwise conditioning in cAtt and cLN. \textit{cAtt + cMLP, global}
\end{itemize}
.

\begin{figure*}
\centering
\includegraphics[scale=0.44]{ablations_v4.pdf}

\caption{Ablated models. \textit{Gated}: Gated conditioning layers as done in \citep{oord2016pixel} and \textit{cAtt + cMLP, global}: Global conditioning instead of pointwise conditioning in cAtt and cLN.}
\label{fig:ablation_misc}
\end{figure*}


\section{Autoregressive models} \label{sec:autoregressive models}
Autoregressive models are a family of probabilistic methods that model joint distribution of data $P(x)$ or a sequence of symbols $(x_1, x_2, \dots x_n)$ as a product of conditionals $\prod_{i=1}^N P(x_i | x_{<i})$. During training, the input to autoregressive models are the entire sequence of ground-truth symbols. Masking ensures that the contribution of all "future" symbols in the sequence are zeroed out. The outputs of the autoregressive model are the corresponding conditional distributions. $P(x_i | x_{<i})$. Optimizing the parameters of the autoregressive model proceeds by a standard log-likelihood objective.

Generation happens sequentially, symbol-by-symbol. Once a symbol $x_i$ is generated, the entire sequence $(x_1, x_2, \dots x_i)$ are fed to the autoregressive model to generate $x_{i+1}$.

In the case of autoregressive image generation symbols typically correspond to the 3 RGB pixel-channel. These are generated sequentially in raster-scan order, channel by channel and pixel by pixel.


\section{Row/Column Self-attention}\label{sec:row_col_self_attention}

In the following we describe row self-attention, that is, we omit the height dimension as all operations are performed in parallel for each column. Given the representation of a single row within of an image $\bx_{i, \cdot} \in \mathbb{R}^{W {\times} D}$, row-wise self-attention block is applied as follows:
\begin{align}
    [\bq, \bk, \bv] &= \op{LN}(\bx_{i, \cdot}) U_{qkv}
    & U_{qkv} \in \mathbb{R}^{D \times 3 D_h} \label{eq:qkv} \\
    A &= \op{softmax}\left(\bq\bk^\top / \sqrt{D_h}\right)
    & A \in \mathbb{R}^{W \times W} \label{eq:attn_matrix}\\
    \op{SA}(\bx_{i, \cdot}) &= A\bv \label{eq:attn_v} \\
    \op{MSA}(\bx_{i, \cdot}) &= [\op{SA}_1(\bx_{i, \cdot}), \op{SA}_2(\bx_{i, \cdot}), \cdots, \op{SA}_k(\bx_{i, \cdot})] \, U_{out}
    & U_{out} \in \mathbb{R}^{k \cdot D_h \times D}
\end{align}
$\op{LN}$ refers to the application of layer normalization \citep{ba2016layer}. Finally, we apply residual connections and a feed-forward neural network with a single hidden layer and ReLU activation ($\op{MLP}$) after each self-attention block as it is common practice in transformers.
\begin{align}
    \hat{\bx}_{i, \cdot} &= \op{MLP}(\op{LN}(\bx_{i, \cdot}^\prime)) + \bx_{i, \cdot}^\prime &
    \bx_{i, \cdot}^\prime &= \op{MSA}(\bx_{i, \cdot}) + \bx_{i, \cdot} \label{eq:attn}
\end{align}

Column-wise self-attention over $\bx_{\cdot, j} \in \mathbb{R}^{H {\times} D}$ works analogously.



\section{Out of domain colorizations}

\begin{figure*}
\centering
\includegraphics{lsun.pdf}
\caption{We train our colorization model on ImageNet and display high resolution colorizations from LSUN}
\label{fig:lsun}
\end{figure*}

\begin{figure*}
\centering
\includegraphics{celeb_a.pdf}
\caption{We train our colorization model on ImageNet and display low resolution colorizations from Celeb-A}
\label{fig:celeb_a}
\end{figure*}


We use our trained colorization model on ImageNet to colorize high-resolution grayscale images from LSUN $256 \times 256$ \citep{yu2015lsun} and low-resolution grayscale images from Celeb-A \citep{liu2015deep} $64 \times 64$. Note that these models were trained only on ImageNet and not finetuned on Celeb-A or LSUN.



\section{Number of axial attention blocks}

We did a very small hyperparameter sweep using the baseline axial transformer (no conditional layers) with the following configurations:

\begin{itemize}
    \item hidden size = 512, number of blocks = 4
    \item hidden size = 1024, number of blocks = 2
    \item hidden size = 512, number of blocks = 2
\end{itemize}

Once we found the optimal configuration, we fixed this for all future architecture design.




\section{Analysis of MTurk ratings}

\begin{figure*}
  \subfloat
  {\includegraphics[width=0.5\textwidth,height=0.05\textheight]{amt_generated_1.pdf}
  \includegraphics[width=0.5\textwidth,height=0.05\textheight]{amt_generated_2.pdf}
  }
  \qquad
  \subfloat
  {\includegraphics[width=0.5\textwidth,height=0.05\textheight]{amt_ground_1.pdf}
  \includegraphics[width=0.5\textwidth,height=0.05\textheight]{amt_ground_2.pdf}
  }
  \caption{\textbf{Top}: Colorizations \textbf{Bottom}: Ground truth. From left to right, our colorizations have a progressively higher fooling rate.}
\label{fig:mturk_v2}
\end{figure*}

\begin{figure}[htp]
\setlength{\lineskip}{0pt}
  \centering
  \includegraphics[width=0.07\textwidth,height=0.04\textheight]{high_rate/ground_5.pdf}
  \includegraphics[width=0.21\textwidth,height=0.04\textheight]{high_rate/gen_5.pdf} \hfill
  \includegraphics[width=0.07\textwidth,height=0.04\textheight]{high_variance/ground_17.pdf}
  \includegraphics[width=0.21\textwidth,height=0.04\textheight]{high_variance/gen_17.pdf} \hfill
  \includegraphics[width=0.07\textwidth,height=0.04\textheight]{zero_rate/ground_201.pdf}
  \includegraphics[width=0.21\textwidth,height=0.04\textheight]{zero_rate/gen_201.pdf} \\
  \includegraphics[width=0.07\textwidth,height=0.04\textheight]{high_rate/ground_287.pdf}
  \includegraphics[width=0.21\textwidth,height=0.04\textheight]{high_rate/gen_287.pdf} \hfill
  \includegraphics[width=0.07\textwidth,height=0.04\textheight]{high_variance/ground_39.pdf}
  \includegraphics[width=0.21\textwidth,height=0.04\textheight]{high_variance/gen_39.pdf} \hfill
  \includegraphics[width=0.07\textwidth,height=0.04\textheight]{zero_rate/ground_265.pdf}
  \includegraphics[width=0.21\textwidth,height=0.04\textheight]{zero_rate/gen_265.pdf} \\
  \includegraphics[width=0.07\textwidth,height=0.04\textheight]{high_rate/ground_381.pdf}
  \includegraphics[width=0.21\textwidth,height=0.04\textheight]{high_rate/gen_381.pdf} \hfill
  \includegraphics[width=0.07\textwidth,height=0.04\textheight]{high_variance/ground_419.pdf}
  \includegraphics[width=0.21\textwidth,height=0.04\textheight]{high_variance/gen_419.pdf} \hfill
  \includegraphics[width=0.07\textwidth,height=0.04\textheight]{zero_rate/ground_274.pdf}
  \includegraphics[width=0.21\textwidth,height=0.04\textheight]{zero_rate/gen_274.pdf} \\
  \includegraphics[width=0.07\textwidth,height=0.04\textheight]{high_rate/ground_488.pdf}
  \includegraphics[width=0.21\textwidth,height=0.04\textheight]{high_rate/gen_488.pdf} \hfill
  \includegraphics[width=0.07\textwidth,height=0.04\textheight]{high_variance/ground_425.pdf}
  \includegraphics[width=0.21\textwidth,height=0.04\textheight]{high_variance/gen_425.pdf} \hfill
  \includegraphics[width=0.07\textwidth,height=0.04\textheight]{zero_rate/ground_399.pdf}
  \includegraphics[width=0.21\textwidth,height=0.04\textheight]{zero_rate/gen_399.pdf} \\
\caption{In each column, we display the ground truth followed by 3 samples. \textbf{Left:} Diverse and real. \textbf{Center:} Realism improves from left to right. \textbf{Right:} Failure cases}
\label{fig:mturk_v1}
\end{figure}

\begin{figure}[htp]
\centering
\setlength{\lineskip}{0pt}

  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/image1.pdf}
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/cmap1.pdf}
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/image2.pdf}  
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/cmap2.pdf}
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/image3.pdf}  
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/cmap3.pdf}
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/image4.pdf}
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/cmap4.pdf}
 \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/image5.pdf}  
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/cmap5.pdf} \\
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/image6.pdf}
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/cmap6.pdf}
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/image7.pdf}  
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/cmap7.pdf}
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/image8.pdf}  
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/cmap8.pdf}
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/image9.pdf}
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/cmap9.pdf}
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/image10.pdf}
  \includegraphics[width=0.09\textwidth,height=0.05\textheight]{cmap/cmap10.pdf}
\caption{We display the per-pixel, maximum predicted probability over 512 colors as a proxy for uncertainty.}
\label{fig:cmap_aux}
\end{figure}

We analyzed our samples on the basis of the MTurk ratings in Figure \ref{fig:mturk_v1}. To the left, we show images, where all the samples have a fool rate > 60 \%. Our model is able to show diversity in color for both high-level structure and low-level details. In the center, we display samples that have a high variance in MTurk ratings, with a difference of 80 \% between the best and the worst sample. All of these are complex objects, that our model is able to colorize reasonably well given multiple attempts. To the right of Figure \ref{fig:mturk_v1}, we show failure cases where all samples have a fool rate of 0 \%, For these cases, our model is unable to colorize highly complex structure, that would arguably be difficult even for a human.


\section{More probability maps}




We display additional probability maps to visualize uncertainty as done in \ref{comparison_expts_human}.


\section{More samples}

We display a wide-diversity of colorizations from ColTran that were not cherry-picked.
\begin{figure}[htp]
\centering
\setlength{\lineskip}{0pt}

  \includegraphics[width=\textwidth,height=\textheight]{coltran_1.pdf}
\end{figure}

\begin{figure}[htp]
\centering
\setlength{\lineskip}{0pt}

  \includegraphics[width=\textwidth,height=\textheight]{coltran_2.pdf}
\end{figure}

\begin{figure}[htp]
\centering
\setlength{\lineskip}{0pt}

  \includegraphics[width=\textwidth,height=\textheight]{coltran_3.pdf}
\end{figure}

\begin{figure}[htp]
\centering
\setlength{\lineskip}{0pt}

  \includegraphics[width=\textwidth,height=\textheight]{coltran_5.pdf}
\end{figure}

\begin{figure}[htp]
\centering
\setlength{\lineskip}{0pt}

  \includegraphics[width=\textwidth,height=\textheight]{coltran_4.pdf}
\end{figure}




\end{document}
