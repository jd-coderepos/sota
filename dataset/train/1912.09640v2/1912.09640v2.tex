
\documentclass{article} \usepackage{iclr2020_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{url}
\usepackage{color}
\usepackage{xspace}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{algorithm2e}


\definecolor{darkblue}{rgb}{0.0, 0.0, 0.5}
\usepackage[pagebackref=false,colorlinks=true,linkcolor=darkblue,citecolor=darkblue,bookmarks=false]{hyperref}

\newcommand{\prev}[1]{ \textcolor{red}{(prev: #1)}  }
\newcommand{\new}[1]{ \textcolor{blue}{(new: #1)}  }
\newcommand{\jr}[1]{ \textcolor{green}{(jr: #1)}  }
\newcommand{\lxc}[1]{ \textcolor{orange}{(lxc: #1)}  }

\DeclareCaptionLabelFormat{andtable}{#1~#2  \&  \tablename~\thetable}
\newcommand{\flops}{FLOPs\xspace}
\newcommand{\methodname}{AtomNAS\xspace}

\title{AtomNAS: Fine-Grained End-to-End Neural Architecture Search}



\author{Jieru Mei, Yingwei Li, Xiaochen Lian, Xiaojie Jin, Linjie Yang, \\\textbf{Alan Yuille} \textbf{\& Jianchao Yang} \\
Johns Hopkins University\\
ByteDance AI Lab\\
\texttt{\tiny meijieru@gmail.com, yingwei.li@jhu.edu, \{xiaochen.lian, jinxiaojie, linjie.yang\}@bytedance.com, } \\
\texttt{\tiny alan.l.yuille@gmail.com, yangjianchao@bytedance.com}
}





\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}


Search space design is very critical to neural architecture search (NAS) algorithms. We propose a fine-grained search space comprised of atomic blocks, a minimal search unit that is much smaller than the ones used in recent NAS algorithms.
This search space allows a mix of operations by composing different types of atomic blocks, while the search space in previous methods only allows homogeneous operations. Based on this search space, we propose a resource-aware architecture search framework which automatically assigns the computational resources (e.g., output channel numbers) for each operation by jointly considering the performance and the computational cost. In addition, to accelerate the search process, we propose a dynamic network shrinkage technique which prunes the atomic blocks with negligible influence on outputs on the fly. 
Instead of a search-and-retrain two-stage paradigm, our method simultaneously searches and trains the target architecture. 
Our method achieves state-of-the-art performance under several \flops configurations on ImageNet with a small searching cost.
We open our entire codebase at: \url{https://github.com/meijieru/AtomNAS}.

\end{abstract}

\let\thefootnote\relax\footnote{ This work was done during the internship program at Bytedance.}

\section{Introduction}

Human-designed neural networks are already surpassed by machine-designed ones. Neural Architecture Search (NAS) has become the mainstream approach to discover efficient and powerful network structures (\cite{zoph2017nasnet, hieu2018enas, tan2019mnasnet, hanxiao2019darts}). Although the tedious searching process is conducted by machines, humans still involve extensively in the design of the NAS algorithms. Designing of search spaces is critical for NAS algorithms and different choices have been explored. \cite{han2019proxyless} and~\cite{wu2019fbnet} utilize supernets with multiple choices in each layer to accommodate a sampled network on the GPU. \cite{chen2019pdarts} progressively grow the depth of the supernet and remove unnecessary blocks during the search. \cite{mingxing2019efficient} propose to search the scaling factor of image resolution, channel multiplier and layer numbers in scenarios with different computation budgets. \cite{stamoulis2019single_path} propose to use different kernel sizes in each layer of the supernet and reuse the weights of larger kernels for small kernels. ~\cite{howard2019mobilenetv3,tan2019mixnet} adopts Inverted Residuals with Linear Bottlenecks (MobileNetV2 block) \citep{sandler2018mobilenetv2}, a building block with light-weighted depth-wise convolutions for highly efficient networks in mobile scenarios. 


However, the proposed search spaces generally have only a small set of choices for each block. DARTS and related methods~\citep{hanxiao2019darts,chen2019pdarts, liang2019dartsplus} use around 10 different operations between two network nodes. \cite{howard2019mobilenetv3,han2019proxyless,wu2019fbnet,stamoulis2019single_path} search the expansion ratios in the MobileNetV2 block but still limit them to a few discrete values. We argue that search space of finer granularity is critical to find optimal neural architectures. Specifically, the searched building block in a supernet should be as small as possible to generate the most diversified model structures.


We revisit the architectures of state-of-the-art networks (\cite{howard2019mobilenetv3,tan2019mixnet,he2016resnet}) and discover a commonly used building structure: convolution - channel-wise operation - convolution. We reinterpret this building structure as an ensemble of computationally independent blocks, which we call \textit{atomic blocks}. 
As the minimum search unit, the atomic block constitutes a much larger and more fine-grained search space, within which we are able to search for mixed operations (e.g., convolutions with different kernel sizes and their channel numbers).


For the efficient exploration of the new search space, we propose a NAS framework named AtomNAS which applies network pruning techniques to architecture search.
Specifically, we start from an initial large supernet and rewrite every convolution - channel-wise operation - convolution structure of it in the form the weighted sum of atomic blocks; the weights reflect the contribution of the atomic blocks to the network capacity and are called \textit{importance factors}. For each atomic block, a penalty term in proportion to its FLOPs is enforced on its importance factor; effectively, the penalty makes AtomNAS favor atomic blocks with less FLOPs. By minimizing the combination of the original network loss and the total penalty on the weights, AtomNAS is able to learn both the parameters of the network and the weights of the atomic blocks. At the end of the learning, atomic blocks with very small weights (e.g., ) are removed from the network and we obtain the final network which has fewer FLOPs. Since the pruned atomic blocks have little contribution to the network output due to their negligible weights, the final network does not need to be retrained or finetuned.

Training on the large supernet is computationally demanding. We observe that for many pruned atomic blocks, their weights diminish at the early stage of learning and never ``revive" throughout the rest of learning. We propose a dynamic network shrinkage technique which removes those atomic blocks on the fly and greatly reduces the run time of AtomNAS.

In our experiment, our method achieves 75.9\% top-1 accuracy on ImageNet dataset around 360M \flops, which is 0.9\% higher than state-of-the-art model \citep{stamoulis2019single_path}. By further incorporating additional modules, our method achieves 77.6\% top-1 accuracy. It outperforms MixNet by 0.6\% using 363M \flops, which is a new state-of-the-art under the mobile scenario.

In summary, the major contributions of our work are:
\begin{enumerate}
    \item We design a fine-grained search space which includes the exact number of channels and mixed operations (e.g., combination of different convolution kernels).
    \item We propose an NAS framework, AtomNAS. Within the framework, an efficient end-to-end NAS algorithm is proposed which can simultaneously search the network architecture and train the final model. No finetuning is needed after the algorithm finishes.
\item With the proposed search space and AtomNAS, we achieve state-of-the-art performance on ImageNet dataset under mobile setting.
\end{enumerate}


















\section{Related Work}

\subsection{Neural Architecture Search}

Recently, there is a growing interest in automated neural architecture design. Reinforce learning based NAS methods \citep{zoph2017nasnet,tan2019mnasnet,tan2019mixnet,mingxing2019efficient} are usually computational intensive, thus hampering its usage with limited computational budget. To accelerate the search procedure, ENAS \citep{hieu2018enas} represents the search space using a directed acyclic graph and aims to search the optimal subgraph within the large supergraph. A training strategy of parameter sharing among subgraphs is proposed to significantly increase the searching efficiency. The similar idea of optimizing optimal subgraphs within a supergraph is also adopted by ~\cite{hanxiao2019darts,jin2019rc_darts,xu2020pc_darts,wu2019fbnet,zichao2019uniform_sampling,han2019proxyless}. \cite{stamoulis2019single_path,yu2020bignas} further share the parameters of different paths within a block using super-kernel representation.
A prominent disadvantage of the above methods is that their coarse search spaces only support selecting one out of a set of choices (e.g., selecting one kernel size from \{3, 5, 7\}). MixNet tries to benefit from mixed operations by using a predefined set of mixed operations \{\{3\}, \{3, 5\}, \{3, 5, 7\}, \{3, 5, 7, 9\}\}, where the channels are equally distributed among different kernel sizes. Due to this limitation, it is difficult to learn optimal architectures under computational resource constraints. On the contrary, our method takes advantage of the fine-grained search space and is able to search for more flexible network architectures satisfying various resource constraints. The fine-grained search space proposed in this paper is exponentially larger than previous search space. For reference, the total number of possible structures within the experiment is around , compared with  for FBNet.
Recently, to improve the final performance of the searched architectures, \cite{yu2020bignas} utilizes knowledge distillation which is orthogonal to our method. It could be easily integrated into our method by Eq.~(\ref{eq:sparsity}) thanks to the end-to-end learning paradigm of our method.

\subsection{Network pruning}



Assuming that many parameters in the network are unnecessary, network pruning methods start from a computation-intensive model, identify the unimportant connections and remove them to get a compact and efficient network. Early method \citep{song2016deep_compression} simultaneously learns the important connections and weights. However, non-regularly removing connections in these works makes it hard to achieve theoretical speedup ratio on realistic hardwares due to extra overhead in caching and indexing. To tackle this problem, structured network pruning methods \citep{yihui2017channel,zhuang2017slimming,jianhao2017thinet,jianbo2018rethink_smallnorm,gordon2018morphnet} are proposed to prune structured components in networks, e.g. the entire channel and kernel. In this way, empirical acceleration can be achieved on modern computing devices.
\cite{zhuang2017slimming,jianbo2018rethink_smallnorm,gordon2018morphnet} encourage channel-level sparsity by imposing the L-1 regularizer on the channel dimension, which is also used by our method.
Recently, \cite{liu2019rethink_pruning} show that in structured network pruning, the learned weights are unimportant. This suggests structured network pruning is actually a neural architecture search focusing on channel numbers.
Our method jointly searches the channel numbers and a mix of operations, which is a much larger search space.



\section{AtomNAS}

We formulate our neural architecture search method in a fine-grained search space with the atomic block used as the basic search unit. An atomic block is comprised of two convolutions connected by a channel-wise operation. By stacking atomic blocks, we obtain larger building blocks (\textit{e.g.} residual block and MobileNetV2 block proposed in a variety of state-of-the-art models including ResNet, MobileNet V2/V3 \citep{he2016resnet,howard2019mobilenetv3,sandler2018mobilenetv2}. In Section~\ref{sec:fine_grained_search_space}, We first show larger network building blocks (\textit{e.g.} MobileNetV2 block) can be represented by an ensembles of atomic blocks. Based on this view, we propose a fine-grained search space using atomic blocks. In Section~\ref{sec:flops_targeted_slimming}, we propose a resource-aware atomic block selection method for end-to-end architecture search. Finally, we propose a dynamic network shrinkage technique in Section~\ref{sec:dynamic_network_shrinkage}, which greatly reduces the search cost.




\subsection{Fine-Grained Search Space}
\label{sec:fine_grained_search_space}

\begin{figure}[btp]
    \centering
    \includegraphics[width=1.0\textwidth]{figure/atomic_block.pdf}
    \caption{Illustration of the ensemble perspective. Arrow means operators. The structure of two convolutions joined by a channel-wise operation is mathematically equivalent to the ensemble of multiple atomic blocks, according to Eq.~(\ref{eq:atom_block}). Colored rectangles represent tensors, with numbers inside indicating their channel numbers; The shaded path on the right is one example of atomic block.} \label{fig:rethink_inverted_residual}
\end{figure}
Under the typical block-wise NAS paradigm \citep{tan2019mnasnet,tan2019mixnet}, the search space of each block in a neural network is represented as the Cartesian product , where each  is the set of all choices of the -th configuration such as kernel size, number of channels and type of operation. For example,  represents a search space of three types of convolutions by two kernel sizes and four options of channel number. A block in the resulting model can only pick one convolution type from the three and one output channel number from the four values. This paradigm greatly limits the search space due to the few choices of each configuration. Here we present a more fine-grained search space by decomposing the network into smaller and more basic building blocks.


We denote  as a convolution operator, where  is the input tensor and ,  are the input and output channel numbers respectively. A wide range of manually-designed and NAS architectures share a structure that joins two convolutions by a channel-wise operation:



where  is a channel-wise operator. For example, in VGG \citep{simonyan2015vgg} and a Residual Block \citep{he2016resnet},  and  are convolutions and  is one of Maxpool, ReLU and BN-ReLU; in a MobileNetV2 block \citep{sandler2018mobilenetv2},  and  are point-wise convolutions and  is depth-wise convolution with BN-ReLU in the MobileNetV2 block.
Eq.~(\ref{eq:unit}) can be reformulated as follows:

where  is the -th convolution kernel of ,  is the operator of the -th channel of , and  are obtained by splitting the kernel tensor of  along the the input channel dimension. Each term in the summation can be seen as a computationally independent block, which is called {\it atomic block}. Fig.~(\ref{fig:rethink_inverted_residual}) demonstrate this reformulation. By determining whether to keep each atomic block in the final model individually, the search of channel number  is enabled through channel selection, which greatly enlarges the search space. 

This formulation also naturally includes the selection of operators. To gain a better understanding, we first generalize Eq.~(\ref{eq:atom_block}) as:

Note the array indices  are moved to subscripts. In this formulation, we can use different types of operators for ,  and ; in other words, ,  and  can each be a combination of different operators and each atomic block can use different operators such as convolutions with different kernel sizes.

Formally, the search space is formulated as a supernet which is built based on the structure in Eq.~(\ref{eq:unit}); such structure satisfies Eq.~(\ref{eq:compound}) and thus can be represented by atomic blocks; each of ,  and  is a combination of operators. The new search space includes some state-of-the-art network architectures. For example, by allowing  to be a combination of convolutions with different kernel sizes, the MixConv block in MixNet \citep{tan2019mixnet} becomes a special case in our search space. In addition, our search space facilitates discarding any number of channels in , resulting in a more fine-grained channel configuration. In comparison, the channel numbers are determined heuristically in \cite{tan2019mixnet}.









\subsection{Resource-aware atomic block Search}
\label{sec:flops_targeted_slimming}

In this work, we adopt a differentiable neural architecture search paradigm where the model structure is discovered in a full pass of model training. With the supernet defined above, the final model can be produced by discarding part of the atomic blocks during training. Following DARTS (\cite{hanxiao2019darts}), we introduce a importance factor  to scale the output of each atomic block in the supernet. Eq.~(\ref{eq:compound}) then becomes


Here, each  is tied with an atomic block comprised of three operators , and . The importance factors are learned jointly with the network weights. Once the training finishes, the atomic blocks that have negligible effect (i.e., those with factors smaller than a threshold) on the network output are discarded.

We still need to address two issues related to the importance factors 's. The first issue is where in the supernet we should put the ? Let's first consider the case when  only contains linear operations, e.g., convolution, batch normalization and linear activation like ReLU. If  contains at least one BN layer, The scaling parameters in the BN layers can be directly used as such importance factors (\cite{zhuang2017slimming}). If  has no BN layers, which is rare, we can place  anywhere between  and ; however, we need to apply regularization terms to the weights of  and  (e.g., weight decays) in order to prevent weights in  and  from getting too large and canceling the effect of . When  contains non-linear operations, e.g., Swish activation and Sigmoid activation, we can only put  behind .


The second issue is how to avoid performance deterioration after discarding some of the atomic blocks. For example, DARTS discards operations with small scale factors after iterative training of model parameters and scale factors. Since the scale factors of the discarded operations are not small enough, the performance of the network will be affected which needs re-training to adjust the weights again. In order to maintain the performance of the supernet after dropping some atomics blocks, the importance factors  of those atomic blocks should be sufficiently small. Inspired by the channel pruning work in \cite{zhuang2017slimming}, we add L1 norm penalty loss on , which effectively pushes many importance factors to near-zero values. At the end of learning, atomic blocks with  close to zero are removed from the supernet. Note that since the BN scales change more dramatically during training due to the regularization term, the running statistics of BNs might be inaccurate and needs to be calculated again using the training set.

With the added regularization term, the training loss is



where  is the coefficient of L1 penalty term,  is the index set of all atomic blocks, and  is the conventional training loss (e.g., cross-entropy loss combined with 
the regularization term like weight decay and distillation loss.).  is weighted by coefficient  which is proportional to the computation cost of -th atomic block, i.e. . By using computation costs aware regularization, we encourage the model to learn network structures that strike a good balance between accuracy and efficiency.  In this paper, we use FLOPs as the criteria of computation cost. Other metrics such as latency and energy consumption can be used similarly. As a result, the whole loss function  trades off between accuracy and \flops.

















\subsection{Dynamic Network Shrinkage}
\label{sec:dynamic_network_shrinkage}

\begin{figure}[t]
    \centering
    \includegraphics[width=0.5\linewidth]{figure/flops-crop.pdf}
    \caption{\flops change of the supernet during the searching and training for AtomNAS-C. The crossed-out region corresponds to the saved computation compared to training the supernet without the dynamic shrinkage. The region in yellow corresponds to the extra cost compared with training the final model from scratch, the cost of which is the region below the red dashed line.
}
    \label{fig:network_shrinkage}
\end{figure}

\begin{algorithm}[t]
    \SetAlgoLined
Initialize the supernet\ and the exponential moving average\;
        \While{}{
            Update network weights and importance factors  by minimizing the loss function  \;
            Update the  by Eq.~(\ref{eq:alpha})\;
            \If{Total \flops of dead blocks }
            {
                Remove dead blocks from the supernet\;
            }
            Recalculate BN's statistics by forwarding some training examples\;
            Validate the performance of the current supernet\;
        }
    \caption{Dynamic network shrinkage}
    \label{alg:dynamic_network_shrinkage}
\end{algorithm}

Usually, the supernet is much larger than the final search result. We observe that many atomic blocks become ``dead" starting from the early stage of the search, i.e., their importance factors  are close to zero till the end of the search. To utilize computational resources more efficiently and speed up the search process, we propose a dynamic network shrinkage algorithm which cuts down the network architecture by removing atomic blocks once they are deemed ``dead". 

We adopt a conservative strategy to decide whether an atomic block is ``dead": for importance factors , we maintain its momentum  which is updated as

where  is the importance factors at -th iteration and  is the decay term. An atomic block is considered ``dead" if both  and  are smaller than a threshold, which is set to  throughout experiments.

Once the total \flops of ``dead" blocks reach a predefined threshold, we remove those blocks from the supernet. As discussed above, we recalculate BN's running statistics before deploying the network. The whole training process is presented in Algorithm \ref{alg:dynamic_network_shrinkage}.

We show the \flops of a sample network during the search process in Fig.~\ref{fig:network_shrinkage}. We start from a supernet with 1521M \flops and dynamically discard ``dead" atomic blocks to reduce search cost. The overall search and train cost only increases by  compared to that of training the searched model from scratch.






\section{Experiment}

We first describe the implementation details in Section~\ref{sub:impl} and then compare AtomNAS with previous state-of-the-art methods under various \flops constraints in Section~\ref{sub:imagenet_expr}. 
In Section~\ref{sub:analysis}, we provide more detailed analysis about AtomNAS. Finally, in Section~\ref{sub:exp_coco}, we demonstrate the transferability of AtomNAS networks by evaluating them on detection and instance segmentation tasks.



\subsection{Implementation Details}
\label{sub:impl}

The architecture of the supernet we use for the experiments is shown in table on the right of Fig. \ref{fig:tbs}. The supernet contains 21 AtomNAS blocks, the searchable block in our supernet; the picture on the right of Fig. \ref{fig:tbs} illustrates the structure of an AtomNAS block, where  is a  pointwise convolutions that expands the input channel number from  to ;  is a mix of three depth-wise convolutions with kernel sizes of ,  and , and  is another  pointwise convolutions that projects the channel number to the output channel number. Similar to MobileNetV2~\citep{sandler2018mobilenetv2}, if the output dimension stays the same as the input dimension, we use a skip connection to add the input to the output. AtomNAS block is effectively an ensemble of  atomic blocks, whose underlying search space covers the MobileNetV2 block~\citep{sandler2018mobilenetv2} and its multi-kernel variant, MixConv~\citep{tan2019mixnet}. Within AtomNAS block, we are able to optimize the distribution of computation resources (i.e., channel numbers) among the three types of depth-wise convolution.



We use the same training configuration (e.g., RMSProp optimizer, EMA on weights and exponential learning rate decay) as \cite{tan2019mnasnet,stamoulis2019single_path} and do not use extra data augmentation such as MixUp \citep{zhang2018mixup} and AutoAugment \citep{cubuk2018autoaugment}. We find that using this configuration is sufficient for our method to achieve good performance. Our results are shown in Table~\ref{tab:overall_compare} and Table~\ref{tab:bn_calib}. When training the supernet, we use a total batch size of 2048 on 32 Tesla V100 GPUs and train for 350 epochs. For our dynamic network shrinkage algorithm, we set the momentum factor  in Eq.~(\ref{eq:alpha}) to . At the beginning of the training, all of the weights are randomly initialized. To avoid removing atomic blocks with high penalties (i.e., \flops) prematurely, the weight of the penalty term in Eq.~(\ref{eq:sparsity}) is increased from 0 to the target  by a linear scheduler during the first 25 epochs. By setting the weight of the L1 penalty term  to be ,  and  respectively, we obtain networks with three different sizes: AtomNAS-A, AtomNAS-B, and AtomNAS-C. They have the similar \flops as previous state-of-the-art networks under M: MixNet-S \citep{tan2019mixnet}, MixNet-M \citep{tan2019mixnet} and SinglePath \citep{stamoulis2019single_path}. In Appendix \ref{sec:vis}, we visualize the architecture of AtomNAS-C.


\begin{figure}[t]
\centering
\includegraphics[width=0.375\linewidth]{figure/block.pdf}
\qquad
\begin{tabular}[b]{lllll}
\toprule
Input Shape & Block & f & n & stride \\
\midrule
 & 3x3 conv & 32(16) & 1 & 2 \\
 & 3x3 MB & 16 & 1 & 1 \\
 & searchable & 24 & 4 & 2 \\
 & searchable & 40 & 4 & 2 \\
 & searchable & 80 & 4 & 2 \\
 & searchable & 96 & 4 & 1 \\
 & searchable & 192 & 4 & 2 \\
 & searchable & 320 & 1 & 1 \\
 & avgpool & - & 1 & 1 \\
 & fc & 1000 & 1 & - \\
\bottomrule
\end{tabular}
\caption{(Left) The searchable block of the supernet.  and  are fixed to  pointwise convolutions;  here is a mix of three convolutions with kernel sizes of ,  and .  expands the input channel number from  to  and  projects the channel number to the output channel number. If the output dimension
stays the same as the input dimension, we use a skip connection to add the input to the output. (Right) Architecture of the supernet. Column-Block denotes the block type; MB denotes MobileNetV2 block; "searchable" means a searchable block shown on the left.  Column-f denotes the output channel number of a block. Column-n denotes the number of blocks. Column-s denotes the stride of the first block in a stage. The output channel numbers of the first convolution are 16 for AtomNAS-A, 32 for AtomNAS-B and AtomNAS-C.}
\label{fig:tbs}
\end{figure}





\subsection{Experiments on ImageNet}
\label{sub:imagenet_expr}

We apply AtomNAS to search high performance light-weight model on ImageNet 2012 classification task \citep{deng2009imagenet}. Table~\ref{tab:overall_compare} compares our methods with previous state-of-the-art models, either manually designed or searched. 

With models directly produced by AtomNAS, our method achieves the new state-of-the-art under all \flops constraints. Especially, AtomNAS-C achieves  top-1 accuracy with only 360M \flops, and surpasses all other models, including models like PDARTS and DenseNAS which have much higher \flops.



Techniques like Swish activation function \citep{ramachandran2018swish} and Squeeze-and-Excitation (SE) module \citep{hu2018se} consistently improve the accuracy with marginal \flops cost. For a fair comparison with methods that use these techniques, we directly modify the searched network by replacing all ReLU activation with Swish and add SE module with ratio 0.5 to every block and then retrain the network from scratch. Note that unlike other methods, we do not search the configuration of Swish and SE, and therefore the performance might not be optimal. Extra data augmentations such as MixUp and AutoAugment are still not used. We train the models from scratch with a total batch size of 4096 on 32 Tesla V100 GPUs for 250 epochs. 


Simply adding these techniques improves the results further. AtomNAS-A+ achieves  top-1 accuracy with 260M \flops, which outperforms many heavier models including MnasNet-A2. Without extra data augmentations, it performs as well as Efficient-B0 \citep{mingxing2019efficient} by using 130M less \flops. It also outperforms the previous state-of-the-art MixNet-S by . In addition, AtomNAS-C+ improves the top-1 accuracy on ImageNet to , surpassing previous state-of-the-art MixNet-M by  and becomes the overall best performing model under 400M \flops.


Fig.~\ref{fig:overall_imagenet} visualizes the top-1 accuracy on ImageNet for different models. It's clear that our fine-grained search space and the end-to-end resource-aware search method boost the performance significantly.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.7\linewidth]{figure/overall_imagenet-crop.pdf}
    \caption{\flops versus accuracy on ImageNet.  means methods use extra techniques like Swish activation and Squeeze-and-Excitation module.}
    \label{fig:overall_imagenet}
\end{figure}

\begin{table}[t]
\caption{Comparision with state-of-the-arts on ImageNet under the mobile setting.  denotes methods using extra network modules such as Swish activation and Squeeze-and-Excitation module.  denotes using extra data augmentation such as MixUp and AutoAugment.  denotes models searched and trained simultaneously.}
\label{sample-table}
\begin{center}
\begin{tabular}{lllll}
\toprule
Model & Parameters & \flops & Top-1(\%) & Top-5(\%) \\
\midrule
MobileNetV1 \citep{howard2017mobilenet}           & 4.2M & 575M & 70.6 & 89.5 \\
MobileNetV2 \citep{sandler2018mobilenetv2}        & 3.4M & 300M & 72.0 & 91.0 \\
MobileNetV2 (our impl.)                           & 3.4M & 301M & 73.6 & 91.5 \\
MobileNetV2 (1.4) & 6.9M & 585M & 74.7 & 92.5 \\
ShuffleNetV2 \citep{ma2018shufflenet_v2}          & 3.5M & 299M & 72.6 & - \\
ShuffleNetV2 2      & 7.4M & 591M & 74.9 & - \\
\midrule
FBNet-A \citep{wu2019fbnet}         & 4.3M & 249M & 73.0 & - \\
FBNet-C         & 5.5M & 375M & 74.9 & - \\
Proxyless (mobile) \citep{han2019proxyless}                  & 4.1M & 320M & 74.6 & 92.2 \\
SinglePath \citep{stamoulis2019single_path} & 4.4M & 334M & 75.0 & 92.2 \\
NASNet-A \citep{zoph2017nasnet}     & 5.3M & 564M & 74.0 & 91.6 \\
DARTS (second order) \citep{hanxiao2019darts}      & 4.9M & 595M & 73.1 & - \\
PDARTS (cifar 10) \citep{chen2019pdarts}       & 4.9M & 557M & 75.6 & 92.6 \\
DenseNAS-A \citep{fang2019densenas} & 7.9M & 501M & 75.9 & 92.6 \\
FairNAS-A \citep{chu2019fairnas} & 4.6M & 388M & 75.3 & 92.4 \\

\textbf{AtomNAS-A}  & 3.9M & 258M & 74.6 & 92.1 \\
\textbf{AtomNAS-B}  & 4.4M & 326M & 75.5 & 92.6 \\
\textbf{AtomNAS-C}  & 4.7M & 360M & 75.9 & 92.7 \\

\midrule

SCARLET-A \citep{chu2019scarletnas} & 6.7M & 365M & 76.9 & 93.4 \\
MnasNet-A1 \citep{tan2019mnasnet}      & 3.9M & 312M & 75.2 & 92.5 \\
MnasNet-A2      & 4.8M & 340M & 75.6 & 92.7 \\
MixNet-S \citep{tan2019mixnet}      & 4.1M & 256M & 75.8 & 92.8 \\
MixNet-M      & 5.0M & 360M & 77.0 & 93.3 \\
EfficientNet-B0 \citep{mingxing2019efficient} & 5.3M & 390M & 76.3 & 93.2 \\
SE-DARTS+ \citep{liang2019dartsplus} & 6.1M & 594M & 77.5 & 93.6 \\


\textbf{AtomNAS-A+} & 4.7M & 260M & 76.3 & 93.0 \\
\textbf{AtomNAS-B+} & 5.5M & 329M & 77.2 & 93.5 \\
\textbf{AtomNAS-C+} & 5.9M & 363M & 77.6 & 93.6 \\
\bottomrule
\end{tabular}
\end{center}
\label{tab:overall_compare}
\end{table}


\subsection{Analysis}    
\label{sub:analysis}














\subsubsection{Resource-Aware Regularization}

To demonstrate the effectiveness of the resource-aware regularization in Section ~\ref{sec:flops_targeted_slimming}, we compare it with a baseline without \flops-related coefficients , which is widely used in network pruning \citep{zhuang2017slimming,yihui2017channel}.
Table~\ref{tab:equal_baseline} shows the results. First, by using the same L1 penalty coefficient , the baseline achieves a network with similar performance but using much more \flops; then by increasing  to , the baseline obtain a network which has similar \flops but inferior performance (i.e., about  lower). In Fig.~\ref{fig:channel_pie_equal} we visualized the ratio of different types of atomic blocks of the baseline network obtained by . The baseline network keeps more atomic blocks in the earlier blocks, which have higher computation cost due to higher input resolution. On the contrary, AtomNAS is aware of the resource constraint, thus keeping more atomic blocks in the later blocks and achieving much better performance.

\begin{table}[htb]
\caption{Influence of awareness of resource metric. The upper block uses equal penalties for all atomic blocks. The lower part uses our resource-aware atomic block selection.}
\begin{center}
\begin{tabular}{lll}
\toprule
 & \flops & Top-1(\%) \\
\midrule
 & 445M & 76.1 \\
 & 370M & 74.9 \\
\midrule
 & 360M & 75.9 \\
\bottomrule
\end{tabular}
\end{center}
\label{tab:equal_baseline}
\end{table}

\subsubsection{BN Recalibration}

As the BN's running statistics might be inaccurate as explained in Section~\ref{sec:flops_targeted_slimming} and Section~\ref{sec:dynamic_network_shrinkage}, we re-calculate the running statistics of BN before inference, by forwarding 131k randomly sampled training images through the network. Table~\ref{tab:bn_calib} shows the impact of the BN recalibration. The top-1 accuracies of AtomNAS-A, AtomNAS-B, and AtomNAS-C on ImageNet improve by , , and  respectively, which clearly shows the benefit of BN recalibration. 




\begin{table}[htb]
\caption{Influence of BN recalibration.}
\begin{center}
\begin{tabular}{lccc}
\toprule
Model   & w/o Recalibration & w/ Recalibration\\
\midrule
AtomNAS-A  & 73.2 & 74.6 (+1.4) \\
AtomNAS-B  & 73.8 & 75.5 (+1.7) \\
AtomNAS-C  & 74.7 & 75.9 (+1.2) \\
\bottomrule
\end{tabular}
\end{center}
\label{tab:bn_calib}
\end{table}

\subsubsection{Cost of Dynamic Network Shrinkage}
\label{ssub:search_cost}

Our dynamic network shrinkage algorithm speedups the search and train process significantly. For AtomNAS-C, the total time for search-and-training is 25.5 hours. For reference, training the final architecture from scratch takes 22 hours.
Note that as the supernet shrinks, both the GPU memory consumption and forward-backward time are significantly reduced. Thus it's possible to dynamically change the batch size once having sufficient GPU memory, which would further speed up the whole procedure. 


\subsection{Experiments on COCO Detection and Instance Segmentation}
\label{sub:exp_coco}

In this section, we assess the performance of AtomNAS models as feature extractors for object detection and instance segmentation on COCO dataset~\citep{lin2014mscoco}. We first pretrain AtomNAS models (without Swish activation function \citep{ramachandran2018swish} and Squeeze-and-Excitation (SE) module \citep{hu2018se}) on ImageNet, use them as drop-in replacements for the backbone in the Mask-RCNN model~\citep{he2017maskrcnn} by building the detection head on top of the last feature map, and finetune the model on COCO dataset.

We use the open-source code MMDetection~\citep{kai2019mmdetection}. All the models are trained on COCO train2017 with batch size 16 and evaluated on COCO val2017. Following the schedule used in the open-source implementation of TPU-trained
Mask-RCNN \footnote{\url{https://github.com/tensorflow/tpu/tree/master/models/official/mask_rcnn}}, the learning rate starts at  and decreases by a scale of 10 at 15-th and 20th epoch respectively. The models are trained for 23 epochs in total.

Table~\ref{tab:detection} compares the results with other baseline backbone models. The detection results of baseline models are from \cite{stamoulis2019single_path_automl}. We can see that all three AtomNAS models outperform the baselines on object detection task. The results demonstrate that our models have better transferability than the baselines, which may due to mixed operations, a.k.a multi-scale here, are more important to object detection and instance segmentation.

\begin{table}[htbp]
\caption{Comparision with baseline backbones on COCO object detection and instance segmentation. Cls denotes the ImageNet top-1 accuracy; detect-mAP and seg-mAP denotes mean average precision for detection and instance segmentation on COCO dataset. The results of baseline models are from \cite{stamoulis2019single_path_automl}. SinglePath+~\citep{stamoulis2019single_path_automl} contains SE module.}
\begin{center}
\begin{tabular}{lllll}
\toprule
Model & \flops & Cls (\%) & detect-mAP (\%) & seg-mAP (\%)  \\
\midrule
MobileNetV2 \citep{sandler2018mobilenetv2}                           & 301M & 73.6 & 30.5 & - \\
\midrule
Proxyless (mobile) \citep{han2019proxyless}                  & 320M & 74.6 & 32.9 & - \\
Proxyless (mobile) (our impl.)                  & 320M & 74.9 & 32.7 & 30.0 \\
SinglePath+ \citep{stamoulis2019single_path_automl} & 353M & 75.6 & 33.0 & - \\
SinglePath (our impl.) & 334M & 75.0 & 32.0 & 29.7 \\
\midrule
\textbf{AtomNAS-A}  & 258M & 74.6 & 32.7 & 30.1 \\
\textbf{AtomNAS-B}  & 326M & 75.5 & 33.6 & 30.8 \\
\textbf{AtomNAS-C}  & 360M & 75.9 & 34.1 & 31.4 \\
\bottomrule

\end{tabular}
\end{center}
\label{tab:detection}
\end{table}




\section{Conclusion}
In this paper, we revisit the common structure, i.e., two convolutions joined by a channel-wise operation, and reformulate it as an ensemble of atomic blocks. This perspective enables a much larger and more fine-grained search space. For efficiently exploring the huge fine-grained search space, we propose an end-to-end framework named AtomNAS, which conducts architecture search and network training jointly. The searched networks achieve significantly better accuracy than previous state-of-the-art methods while using small extra cost.





\bibliography{iclr2020_conference}
\bibliographystyle{iclr2020_conference}

\appendix
\section{Visualization}\label{sec:vis}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\linewidth]{figure/architecture-crop.pdf}
    \caption{The architecture of AtomNAS-C. Blue, orange, cyan blocks denote atomic blocks with kernel size ,  and  respectively; the heights of these blocks are proportional to their expand ratios.}
    \label{fig:atomnas_m_arch}
\end{figure}

\begin{figure}[btp]
    \begin{subfigure}[b]{\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figure/channel_pie-crop.pdf}
        \caption{AtomNAS-C}
        \label{fig:mmodel_pie}
    \end{subfigure}
\3ex]
    \begin{subfigure}[b]{\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figure/equal_channel_pie-crop.pdf}
        \caption{Baseline}
        \label{fig:channel_pie_equal}
    \end{subfigure}
    \caption{Ratio of different types of atomic blocks in all 21 searchable blocks.
    The text above each pie tells the total number of atomic blocks of the corresponding block in the original supernet. Grey denotes dead atomic blocks; blue, orange, and cyan represent atomic blocks using depth-wise convolutions with kernel size  respectively. Blocks without skip connection are highlighted by bold text.
    (a) Visualization for AtomNAS-C. (b) Visualization for baseline (i.e., without \flops related coefficients ).
    }
\end{figure}



We plot the structure of the searched architecture AtomNAS-C in Fig.~\ref{fig:atomnas_m_arch}, from which we see more flexibility of channel number selection, not only among different operators within each block, but also across the network. In Fig.~\ref{fig:mmodel_pie}, we visualize the ratio between atomic blocks with different kernel sizes in all 21 search blocks. First, we notice that all search blocks have convolutions of all three kernel sizes, showing that AtomNAS learns the importance of using multiple kernel sizes in network architecture. Another observation is that AtomNAS tends to keep more atomic blocks at the later stage of the network. This is because in earlier stage, convolutions of the same kernel size costs more \flops; AtomNAS is aware of this (thanks to its resource-aware regularization) and try to keep as less as possible computationally costly atomic blocks.

\end{document}
