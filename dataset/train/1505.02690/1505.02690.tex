\documentclass[11pt]{article}

\usepackage{fullpage,amsthm}

\ifx\pdftexversion\undefined
  \usepackage[dvips]{graphicx}
\else
  \usepackage[pdftex]{graphicx}
  \DeclareGraphicsRule{*}{mps}{*}{}
\fi



\usepackage{amsmath}
\usepackage{yfonts}
\usepackage{smartref} \usepackage{color}
\usepackage{paralist} \usepackage[cmtip,all]{xy} 

\newfont{\mycrnotice}{ptmr8t at 7pt}
\newfont{\myconfname}{ptmri8t at 7pt}
\let\crnotice\mycrnotice \let\confname\myconfname 

\clubpenalty=10000
\widowpenalty = 10000

\newtheorem{theorem}{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}


\newenvironment{result-repeat}[2]{\begin{trivlist}
\item[\hspace{\labelsep}{\bf\noindent {#1}~\ref{#2} }]\it}{\end{trivlist}}

\newcommand{\comment}[2]{{\bf [[#1--#2]]}}
\newcommand{\eric}[1]{\comment{#1}{Eric}}
\newcommand{\petr}[1]{\comment{#1}{Petr}}

\newcommand{\journalversion}[1]{}

\newcommand{\modif}[1]{{\color{red}{#1}}}
\newcommand{\MP}[1]{\marginpar{\color{red} {#1}}}


\newcommand{\gV}{\textswab{V}}
\newcommand{\bR}{\mathbf{R}}

\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}

\newcommand{\nat}{{\rm I\!N}} 

\newcommand{\mymod}{\mbox{ mod }}
\newcommand{\True}{\mbox{True}}
\newcommand{\False}{\mbox{False}}

\newcommand{\ignore}[1]{}



\renewcommand{\topfraction}{0.9}	\renewcommand{\bottomfraction}{0.8}	\setcounter{topnumber}{2}
    \setcounter{bottomnumber}{2}
    \setcounter{totalnumber}{4}     \setcounter{dbltopnumber}{2}    \renewcommand{\dbltopfraction}{0.9}	\renewcommand{\textfraction}{0.07}	\renewcommand{\floatpagefraction}{0.7}	\renewcommand{\dblfloatpagefraction}{0.7}	





\newcounter{linenum}
\addtoreflist{linenum}
\def\codeTabSpace{\hspace*{6mm}}
\newenvironment{code}{\begin{tabbing}\codeTabSpace \= \hspace*{30mm} \= \hspace*{40mm} \= \hspace*{42mm} \= \kill }{\end{tabbing}}
\newcounter{ind}
\newcommand{\n}{\addtocounter{ind}{7}\hspace*{7mm}}
\newcommand{\p}{\addtocounter{ind}{-7}\hspace*{-7mm}}
\newcommand{\nl}{\\\stepcounter{linenum}{\scriptsize \arabic{linenum}}\>\hspace*{\value{ind}mm}}
\newcommand{\ul}{\\\>\hspace*{\value{ind}mm}}
\newcommand{\bl}{\
\label{execution}
C_0 \goes{\alpha_1} D_1 \goes{\beta_1} C_1 \goes{\alpha_2} D_2 \goes{\beta_2} C_2 \goes{\alpha_3} \cdots \goes{\beta_{c-1}} C_{c-1}

|Q_1\cup\cdots\cup Q_{j-1}| 
&=& k+1-(c-1)m + (j-2)m \\
&&\mbox{(by induction hypothesis \ref{Q1size}, \ref{Qjsize} and \ref{Qdisjoint})}\\
&\leq& k+1 - (c-1)m + (c-3)m\\
&& (\mbox{since }j\leq c-1)\\ 
&=& k+1-2m 
\leq  n-2m\\
&&(\mbox{since }k<n).

&&|Q_1\cup \cdots\cup Q_j\cup P_j|\\
&\leq& k+1-2m +|Q_j| + |P_j|  \\
&&(\mbox{since } |Q_1\cup\cdots\cup Q_{j-1}|\leq k+1-2m)\\
&\leq & k+1-m + r - 1 \\
&&(\mbox{since  and }|P_j|=|A_j| \leq r-1)\\
&=& n -1 \\
&&(\mbox{since }r=n+m-k-1).

r & \leq  \sqrt{m\left(\frac{n}{k}-2\right)}\\
& \leq  \sqrt{m\left(\frac{2n}{k+m}-2\right)} \\
&(\mbox{ since }m\leq k \Rightarrow 
\frac{2n}{k+m}\geq\frac{n}{k} )\\
& = \sqrt{\frac{2m(n-k-m)}{k+m}}\\
\Rightarrow &  r^2-r \leq  \frac{2m(n-k-m)}{k+m}\\
\Rightarrow & \frac{k+m}{m}\cdot\frac{r^2-r}{2} \leq n-k-m\\
\Rightarrow & n  \geq \frac{k+m}{m}\left(m+\frac{r^2-r}{2}\right)\\
&\geq  \ceil{\frac{k+1}{m}}\left(m+\frac{r^2-r}{2}\right).

r -\frac{1}{2} & \leq & \sqrt{2(n-k+1)+\frac{1}{4}}\\
\left(r-\frac{1}{2}\right)^2 & \leq & 2(n-m) + \frac{1}{4}\\
r^2-r & \leq & 2(n-m) \\
n & \geq & m + \frac{r^2-r}{2}\\
n & \geq & \ceil{\frac{k+1}{m}}\left(m+\frac{r^2-r}{2}\right).

So, by Lemma \ref{anonymous-gluing} there exists a sequence of  registers used in some executions of , 
which is impossible since there are only  registers.
\end{proof}
}


\section{Anonymous Algorithm for
Repeated Set Agreement}
\label{m-conc-alg-sec}
\begin{theorem} 
\label{thm:anon-alg}
There is an algorithm that solves
-obstruction-free repeated -set agreement among  processes (for )
using  registers.
\end{theorem}

The anonymous algorithm presented in Figure~\ref{majority} solves
-obstruction-free repeated -set agreement among  processes (for )
using  registers.
The algorithm uses the same basic idea as the one  in Section \ref{linear-space-alg}.
It uses a snapshot object with  components,
which can be built anonymously and non-blocking using  registers \cite{GR07}.
Again, the idea is to allow the first  processes
to choose arbitrary outputs and then ensure that the last  processes
output at most  different values, for a total of at most  different values.

\begin{figure*}
\setcounter{linenum}{0}
\begin{code}
\firstline
Shared variables:\nl
\n  : snapshot object with  components, each initially \nl  
    : register, initially the empty sequence\bl
\p\nl
Persistent local variables:\nl
\n \nl
   \nl
    empty sequence\bl
   
\nl
\p
{\sc Propose}()\nl
\n  write  into \nl
    \nl
    if  then\nl
\n          output the th value in \textit{history} and halt\nl
\p
   
    run the following two threads in parallel until one of them produces an output\nl

    thread 1:\nl
\n      {\it pref}  \nl
         \nl
        loop\nl
\n          update th component of  with value \nl
		     scan  of  \label{snap-anon}\nl
		    if  such that  with  then \nl
\n                \label{line:anon-hist1}\nl
                 output the -th value in  and halt \label{line:anon-exit1}\nl 
\p          if  and every entry of
 is a -tuple then \nl
\n              let  be the most common frequent value in  \nl
                 \label{line:anon-hist2}\nl
                output  and
                halt \label{output-anon} \label{line:anon-exit2} \nl
\p		    if  and  such that  then \nl
\n                {\it pref} \label{change-pref-anon}\nl
\p		     \label{change-index-anon}\nl
\p     end loop\nl
\p  thread 2:\nl
\n       loop \label{line:anon-t2begin}\nl
\n if  then  \nl
           \n              let  be the th element of \nl
                 \label{line:anon-hist3}\nl
                 output  and halt \label{output-anon-2} \label{line:anon-exit3}\nl
\p\p       end loop \label{line:anon-t2end}\nl
\p
\p end {\sc Propose}
\end{code}
\caption{Anonymous algorithm for -obstruction-free repeated -set agreement.\label{majority}}
\end{figure*}

For one-shot -set agreement, processes
alternate between storing their preferred value in a component of the
snapshot object 
and performing a scan of .
The conditions for outputting a value and adopting a new preference differ
from the algorithm in Section \ref{linear-space-alg} to compensate for the lack
of identifiers.
Whenever a process observes  or fewer different values in a scan, it can 
output the one that occurs most frequently.
Otherwise, if a process sees fewer than  copies of its own preference and
at least  copies of another value, it adopts this other value as its preference.

The adaptation of this algorithm to repeated consensus is similar to the
technique used for the non-anonymous case.  There is one additional
complication:  there is no known space-efficient wait-free anonymous snapshot
implementation from registers, so we use a non-blocking implementation.
Therefore, some processes may \emph{starve} while accessing the snapshot
object, under the condition that at least one process manages to
complete infinitely many instances of -set agreement.  

To ensure that starving processes
also complete their {\sc Propose} operations we use one additional
register  where ``fast'' processes write their outputs.
Every process periodically checks  in a parallel thread
(lines~\lref{line:anon-t2begin}-\lref{line:anon-t2begin}) 
and if it finds out that , where  is the 
instance of agreement the process is working on, it outputs the
-th value found in .  
As in the non-anonymous case, the sequence of values that have been
output in the instances of repeated -set agreement the process has
completed so far is stored in a local variable  .
To ensure that  is updated exactly once per
instance of -set agreement, we require that
the threads of a process are scheduled so that the pairs of
lines~\lref{line:anon-hist1}--\lref{line:anon-exit1}, 
\lref{line:anon-hist2}--\lref{line:anon-exit2},
and \lref{line:anon-hist3}--\lref{line:anon-exit3}
are executed without interruption from the process's other thread.


The proof of correctness of our algorithm is given in  Appendix~\ref{anonymous-alg}.

 



\ignore{
\section{Related Work} 

The problem of -set agreement, a generalization of
consensus~\cite{FLP85}, was introduced by Chaudhuri~\cite{Cha93}.
Borowsky and Gafni \cite{BG93b}, Herlihy and Shavit~\cite{HS99}, and
Saks and Zaharoglou~\cite{SZ00} showed that no algorithm can solve
-set agreement using registers for  or more processes, which
implies that no  -obstruction-free -set agreement algorithm
exists for .     
Using the -converge algorithm of Yang et al.~\cite{YNG98},
-obstruction-free -set agreement can be solved using 
single-writer registers (one per process). 

However little has been known about the space complexity of -set
agreement algorithms so far. For the special case of obstruction-free
consensus (), Fich, Herlihy and Shavit~\cite{FHS98} showed 
registers are needed,  while only known upper bound for this case remains .
Delporte et al.~\cite{DFGR13} proposed an algorithm for
obstruction-free -set agreement () that uses 
registers. In this paper, we improve and generalize the algorithm
in~\cite{DFGR13} to all  that uses 
registers. 
We also present a \emph{repeated} -obstruction-free -set
agreement with the same space complexity and provide a very close
lower bound of  registers. The technique we used to derive the
lower bound is inspired by the result of Burns and Lynch on the space
complexity of mutual exclusion~\cite{BL93}. 
In the case of anonymous algorithms, the only lower bound known so far
was  for obstruction-free consensus~\cite{FHS98} and
all known upper bounds use  registers.
}


\section{Concluding Remarks}
\indent 

\journalversion{Could mention that lower bounds apply even for the
weaker termination condition of -obstacle-freedom (also defined by Taubenfeld)
which says that if at most m processes take infinitely many steps, then
some process completes its operation (but starvation of individual processes
is allowed).}

A small gap remains between the upper and lower bounds for non-anonymous repeated
set agreement.
The one-shot algorithm of \cite{DFGR13} uses fewer registers than ours for one special case:  when  and , it uses two registers compared to our three.  This suggests the upper bound could perhaps be improved to .
The gaps are larger for the other scenarios shown in Figure \ref{summary}.
It would be interesting to see if there is an anonymous algorithm that uses
linear space, rather than quadratic space.
Another natural continuation of this work would be to extend the one-shot anonymous
lower bound to the non-anonymous setting.
However, closing the gap for the one-shot setting eludes us still.


\begin{thebibliography}{10}

\bibitem{AAD93}
Yehuda Afek, Hagit Attiya, Danny Dolev, Eli Gafni, Michael Merritt, and Nir
  Shavit.
\newblock Atomic snapshots of shared memory.
\newblock {\em Journal of the ACM}, 40(4):873--890, September 1993.

\bibitem{BG93b}
Elizabeth Borowsky and Eli Gafni.
\newblock Generalized {FLP} impossibility result for -resilient asynchronous
  computations.
\newblock In {\em Proc.~25th ACM Symposium on Theory of Computing}, pages
  91--100, 1993.

\bibitem{Cha93}
Soma Chaudhuri.
\newblock More choices allow more faults: Set consensus problems in totally
  asynchronous systems.
\newblock {\em Information and Computation}, 105(1):132--158, July 1993.

\bibitem{DFGR13}
Carole Delporte-Gallet, Hugues Fauconnier, Eli Gafni, and Sergio Rajsbaum.
\newblock Black art: Obstruction-free k-set agreement with {}.
\newblock In {\em Proc.~1st International Conference on Networked Systems},
  volume 7853 of {\em LNCS}, pages 28--41, 2013.

\bibitem{EFR07}
Faith Ellen, Panagiota Fatourou, and Eric Ruppert.
\newblock Time lower bounds for implementations of multi-writer snapshots.
\newblock {\em Journal of the ACM}, 54(6), December 2007.

\bibitem{FHS98}
Faith~Ellen Fich, Maurice Herlihy, and Nir Shavit.
\newblock On the space complexity of randomized synchronization.
\newblock {\em Journal of the ACM}, 45(5):843--862, September 1998.

\bibitem{GR07}
Rachid Guerraoui and Eric Ruppert.
\newblock Anonymous and fault-tolerant shared-memory computing.
\newblock {\em Distributed Computing}, 20(3):165--177, October 2007.

\bibitem{Her91}
Maurice Herlihy.
\newblock Wait-free synchronization.
\newblock {\em ACM Transactions on Programming Languages and Systems},
  13(1):124--149, January 1991.

\bibitem{HLM03}
Maurice Herlihy, Victor Luchangco, and Mark Moir.
\newblock Obstruction-free synchronization: Double-ended queues as an example.
\newblock In {\em Proc.~23rd International Conference on Distributed Computing
  Systems}, pages 522--529, 2003.

\bibitem{HS99}
Maurice Herlihy and Nir Shavit.
\newblock The topological structure of asynchronous computability.
\newblock {\em Journal of the ACM}, 46(6):858--923, November 1999.

\bibitem{SZ00}
Michael Saks and Fotios Zaharoglou.
\newblock Wait-free -set agreement is impossible: The topology of public
  knowledge.
\newblock {\em SIAM Journal on Computing}, 29(5):1449--1483, 2000.

\bibitem{Tau09a}
Gadi Taubenfeld.
\newblock Contention-sensitive data structures and algorithms.
\newblock In {\em Proc.\ 23rd International Symposium on Distributed
  Computing}, volume 5805 of {\em LNCS}, pages 157--171, 2009.

\bibitem{VA86}
Paul M.~B. Vit{\'{a}}nyi and Baruch Awerbuch.
\newblock Atomic shared register access by asynchronous hardware.
\newblock In {\em Proc.~27th Symposium on Foundations of Computer Science},
  pages 233--243, 1986.

\bibitem{YNG98}
Jiong Yang, Gil Neiger, and Eli Gafni.
\newblock Structured derivations of consensus algorithms for failure detectors.
\newblock In {\em Proc.\ 17th ACM Symposium on Principles of Distributed
  Computing}, pages 297--306, 1998.

\end{thebibliography}




\newpage

\newpage
\appendix

\section{Proof of correctness of repeated set agreement}
\label{app:non-anon-algorithm}

In this section, we prove Theorem~\ref{thm:repeated-alg}.
The pseudocode for our repeated -set agreement algorithm appears in
Figure~\ref{mconc-rep-kset}.  
It essentially follows the pseudocode of the  one-shot algorithm
(Figure~\ref{two-copies}), with additional ``shortcuts'' which a
process may use to adopt a value output previously by another process that has
already reached a higher instance of repeated set agreement. 
Also, a value stored by a process in a lower instance is treated as
.
Thus, a process decides in instance  only if all tuples found in  are stored by
processes in instance  and there are at most  distinct tuples, or
if another process has reached an instance higher than .     
The local variable {\it history} initially stores an empty sequence and the local
variable  is initially 0.  
The local variable {\it i} stores the location that the process updates and is initially 0. 
The values of these three local variables persist from one
invocation of {\sc Propose} to the next.
In particular, this means that the first location  of a 
{\sc Propose} is the last location of the previous {\sc Propose}. 

A process updates components of the shared snapshot object with tuples of the form , where  is the process's preferred value,  is the identifier of the process, 
 indicates which instance of set agreement the process is currently working on,
and \textit{history} is a sequence of output values for instances of set agreement.
We refer to a tuple whose third element is  as a -tuple.

To see that the algorithm satisfies {\bf validity}, first observe
that when a process invokes {\sc Propose} for the th time, the length of its
\textit{history} variable is at least .
The value in every -tuple in  and, thus, put in the th position of a 
process's local variable , is the input value of some process's th invocation
of {\sc Propose}.

The following Lemma reformulates Lemma~\ref{invOne} for
-tuples, showing that  cannot contain more than one distinct -tuple
for a given process.

\begin{lemma}\label{invOne:rep}
Let  be a process identifier and  be a positive integer. In any reachable configuration,
all -tuples with identifier  in  are identical. 
\end{lemma}

\begin{proof}
To derive a contradiction, assume that in some reachable configuration ,
 and  such that
.
Let  be the process with identifier .
By the algorithm,  changes its  variable only when it
switches to a higher instance of repeated agreement.  
Thus,  and we must have .
Let  be reached in some execution at time .
Let  and  be the last update steps before  in which  updates 
 and , respectively.
Without loss of generality, assume that  occurred before .
Then, at some time between  and ,  changes its
{\it pref} variable in instance  (at line~\lref{change-pref-rep}).  
Consider the first time after  when  performs such a change, and let
 and  be the values of 's local variables  and  at
that time. Since (1)  at all times between  and  and
(2)  is obtained between  and ,  must be equal
to . By the algorithm, ; otherwise, the test in line~\lref{cond-rep} would not be satisfied,
and  would not change {\it pref} in line~\lref{change-pref-rep}.
Therefore, in the next iteration of the loop,  will update location .
This update is after  and no later than  (and hence before
), which contradicts the definition of  as the last update
performed by  to  before~.
\end{proof}

To show {\bf -agreement}, we use arguments similar to the proof for the one shot algorithm.
Let .
We call a process \emph{-deciding} if it outputs a value at line \lref{output-rep} (i.e., without
adopting a value from another process's \textit{history} value) during
its th invocation of {\sc Propose}.
If, for a given instance , 
at most  processes are -deciding, 
then -agreement for instance  is immediate since .   
Otherwise, consider an execution in which more than  processes
are -deciding.
Order these processes according to the time that they perform their last scan in instance ,
and let  be the th process in this ordering.
Let  be the set of at most  different tuples that appear in
's final scan and  be the set of values in .  Then, .
We shall show that  and all processes that come later in the ordering
output values in .  
Thus, the total number of output values in instance  
is at most .


\begin{lemma}\label{lem:safety:rep}
After  performs its final scan in instance , 
only -tuples with values in  can appear twice in .
\end{lemma}
\begin{proof}
This proof is analogous to the proof of Lemma \ref{lem:safety} for the one-shot algorithm.
Let  be the configuration just after 's last scan.
We shall show by induction that each configuration
reachable from , only -tuples with values in  can appear in two or more locations of .
For the base case, consider the configuration .
By the definition of ,  contains only tuples with values in ,  
so the claim holds.

For the induction step, suppose the claim holds in all configurations from  to some configuration  reachable from .  Let  be a step that takes the system from  to another configuration .  We must show that the claim holds in configuration .
We need only consider steps  in which some process  stores a tuple  in .

{\sc Case 1}:  is the first time  stores a -tuple after . 
If , then  cannot cause a violation of the claim.
If , then  contains exactly one copy of  in configuration
, so again  preserves the claim.

{\sc Case 2}:  is not the first time  stores a -tuple after .
Let  be the vector obtained by 's
last scan (at line \lref{snap-rep}) before .
Since  is not in the last iteration of the loop during instance ,  must not
satisfy the conditions on line \lref{halt-cond1-rep} or \lref{halt-cond2-rep}.
We show that , and hence  preserves the claim, by considering two subcases.

{\sc Case 2a}:   satisfies the condition on line \lref{cond-rep}. 
Since the condition on line \lref{halt-cond1-rep} is not satisfied and the condition on line
\lref{cond-rep} is satisfied, every tuple in  is a -tuple.
Then,  updates its {\it pref} variable at line \lref{change-pref},
so the value  is the value
of a -tuple that appears twice in .
By the induction hypothesis, .

{\sc Case 2b}:  does not satisfy the condition on line \lref{cond-rep}.

We call an update after  {\it bad} if it stores either a -tuple with 
or a -tuple that is not in .
We first argue that each process can do bad updates to at most one location.
To derive a contradiction, suppose some process does bad updates to two different
locations after .
Consider the first process  to do a bad update to a second location.
Process 's last bad update to one location and its first bad update to the second 
location must be in the same instance of {\sc Propose}, because  must
execute line \lref{change-ind-rep} between them.
Let  be the vector returned by the scan that  performs at line \lref{snap-rep} during the
iteration of the loop when it executes line \lref{change-ind-rep}.
Then,  must not satisfy the conditions on line \lref{halt-cond1-rep} or \lref{cond-rep}.
Recall that at least  processes have updated  for the last time during instance 
prior to .
So at most  processes can do bad updates.
Since no process has done bad updates to two locations before the 's scan obtained the vector ,
and no location of  contains a tuple with instance number greater than ,
at least  locations of  contain -tuples in .
Since , at least two locations of  contain the same -tuple.
This contradicts the fact that  does not satisfy the condition on line \lref{cond-rep}.
Thus, each process can do bad updates to at most one location.

Hence, at all times after , at least  locations have not
had any bad updates performed on them.
Since  did not satisfy the condition on line \lref{halt-cond1-rep},
 must contain at least  -tuples in , and therefore  contains
at least two identical -tuples.
Moreover, some process  satisfied the condition on line \lref{halt-cond2-rep} prior
to the scan that returned , so no component of  contains .
Thus, the only reason  does not satisfy the condition on line \lref{cond-rep}
must be that for some  different from 's position ,
.  Just before taking the scan ,  updates
location  with .  This update occurs after , since  is 
not the first update by  after .  
In the configuration after this update to location ,
both  and  contain .
So, by the induction hypothesis, .
\end{proof}
Lemma~\ref{lem:safety:rep} implies that all -deciding processes after the th  
output values in  and, thus, a total of at most  values are output by 
-deciding processes.
The {\bf -agreement} property follows. 

To prove {\bf -obstruction-freedom}, consider an execution where the set  of 
processes that take infinitely many steps has size at most .
To derive a contradiction, assume that some process in  
completes only a finite number of {\sc Propose} operations. 
Let  be the smallest number such that a process in  does not complete its th {\sc Propose}.
Let  be the set of processes in  that do not complete the th {\sc Propose}.
By the algorithm, no process in  ever witnesses the presence of a
process in a higher instance; otherwise, it would output a value
decided in instance  at line \lref{halt-rep}.
  
Eventually, processes stop storing tuples with instance numbers
 in .  Below we reuse the arguments of the proof of
Lemma~\ref{term-dontchange} to show that at least one process in 
updates each component of  infinitely often.

Recall that each time a process in  executes the loop in
instance , it either keeps its preferred value and increments  (the next location to
update) modulo  or changes its preferred value without modifying  . 
Let   denote the set of processes in  that  increment  infinitely often and
the set  denotes the rest of the processes in , 
i.e., the processes that eventually get stuck
updating to the same location forever.


\begin{lemma}\label{term-dontchange:rep}
.
\end{lemma}
\begin{proof}
The proof is by contradiction.
Assume it is not the case ().

Let  be the set of at most  locations that processes in  eventually settle on.
Note that no process in  can update a location outside of  infinitely often
because then the processes in  would eventually see a tuple with instance number greater
than  and complete their th {\sc Propose} operation.
Let  be a time after which
only processes in  take steps and 
no process updates a location outside of .
Let  be the set of at least  locations that are never changed after .

Since all positions in  that contain tuples of earlier instances
are ignored, we simply reuse the arguments of the proof of
Lemma~\ref{term-dontchange}, to derive a contradiction.
\end{proof}
By Lemma~\ref{term-dontchange:rep}, (1)~there is a time after which only tuples stored
by processes in  are found in scans performed by processes in , 
and all of them are -tuples.
By~Lemma~\ref{invOne:rep}, (2)~all -tuples in  of the same process are identical
and (3)~. (1), (2) and (3) imply that there is a time after which,  whenever a process  performs a scan, 
it finds at most  different -tuples in the returned vector and,
thus, decides, contradicting the definition of .  This completes the proof of the {\bf -obstruction-freedom} property. 

Thus, we have shown that the algorithm solves repeated -set agreement using
a snapshot object with  registers, which can be implemented using
 registers, as described in the proof of Theorem \ref{one-shot-alg}.
This completes the proof of Theorem \ref{thm:repeated-alg}.



 


\section{Proof of correctness of anonymous repeated set agreement}
\label{anonymous-alg}
\indent

To prove Theorem~\ref{thm:anon-alg}, consider our algorithm
in Figure~\ref{majority}.
The algorithm actually uses a non-blocking snapshot object with  components,
which can be built anonymously using  registers \cite{GR07}, plus one additional register.
Each component of the snapshot object is initially .

In this algorithm, a process stores tuples of the form  where 
 is the process's preferred value,  indicates which instance of set
agreement the process is currently working on, and  is a sequence
of output values for instances of set agreement.  We refer to a tuple whose
second element is  as a -tuple.

As an invariant, it is easy to see that each of the following can only store input values
of some process's  invocation of {\sc Propose}:
\begin{itemize}
\item
a process's {\it pref} variable during the process's th invocation of {\sc Propose},
\item
the first component of a -tuple appearing in , and
\item
the th element of any sequence that is stored in a process's {\it history} variable, in the shared variable  or inside a tuple in .
\end{itemize}
{\bf Validity} follows.

Next, we prove the {\bf -agreement} property.
A process is \emph{-deciding} if it outputs a value on line \lref{output-anon}.
Any other process that produces an output for its th {\sc Propose} operation
outputs the same result as some -deciding process, so it suffices to show
that the -deciding processes output at most  different values.
As in Section \ref{linear-space-alg}, we show that the last  -deciding processes output at most  different values, so that the total number of outputs for instance  is at most  values.

If at most  processes are -deciding, then -agreement is trivial for the th instance of set agreement, since
.
So, consider an execution in which more than  processes are -deciding.
Order the -deciding processes according to the time that they perform their last scan in their th invocations of {\sc Propose},
and let  be the th process in this ordering.
Let  be the set of tuples that appear in 's final scan.
Let  be the values that appear in tuples in .
We prove that  and all -deciding processes that come later in the ordering
output values in .

We call an update of  after  a {\it bad update} if it stores
a -tuple with  or a -tuple whose value is not in .

\begin{lemma}
After  performs its final scan in its th {\sc Propose} operation, each process performs bad updates to at most one 
component of .
\end{lemma}
\begin{proof}
To derive a contradiction, assume that some process performs bad updates to two components of  
after 's final scan .
Consider the first process  to do a bad update on a second location.
Let  be the vector returned by the last scan that  performs before its bad update to the second location.
This scan causes  to execute line \lref{change-index-anon}
so that it can perform an update on the second location.
Thus  does not contain any -tuple with .
Since  processes have performed their final scan of their th {\sc Propose}
operation at or before , at most  processes can perform
updates that store -tuples with  after .
By definition of , none of those  processes 
have performed bad updates on two different locations between
 and  's scan that returned .
Since  returned a vector that contained only -tuples,  must contain at most  components
that are either -tuples with  or -tuples with values not in .
So there are at least  locations of  that contain -tuples with values in .
Since , one of the values in  must appear in -tuples stored in at least  locations.
Thus  must adopt a value in  after it obtains the scan , contradicting
the fact that 's next update after this scan uses a value not in .
\end{proof}

It follows that at any time after 's final scan, there are at most 
-tuples in  with values that are not in .
Any -deciding process ordered after  performs a final scan
that returns only -tuples, so one of the values in  must appear in at least
 of them, and is therefore the most frequent value in the scan.
Thus, the value output by any such process must be in .
Hence, the total number of  values output is at most , ensuring that -agreement is satisfied.

Finally, we prove {\bf -obstruction-freedom}.
For this part of the proof, it is convenient to consider lines \lref{snap-anon}
to \lref{change-index-anon} to be a single atomic action.
Since there is only one shared-memory access in this block of code,
there is no loss of generality in this assumption:  every execution
has an equivalent execution where this block is executed atomically,
so if we prove -obstruction-freedom for executions that satisfy this assumption 
then it also holds for all executions.

Consider an execution where at most  processes continue to take steps forever.
Let  be the set of processes that complete infinitely many accesses
to the snapshot object.   is non-empty, since the snapshot implementation
we use is non-blocking, and .
To derive a contradiction, assume
that some process in  never completes one of its {\sc Propose} operations.
Let  be the smallest number such that some process in  does not complete
its th {\sc Propose}.
Let  be the set of processes in  that do not complete their th {\sc Propose}
operation.
Let  be a time after 
\begin{itemize}
\item
every process outside  has stopped performing updates on ,
\item
every process in  has begun its th {\sc Propose} operation, 
\item
every process in  has begun its th {\sc Propose} operation, and
\item
no component of  contains a -tuple for any .
\end{itemize}
It is possible to choose  to satisfy the last condition because
each process in  completes infinitely many iterations of the loop
and therefore updates
every location of  after .
Thus, eventually
all -tuples with  are overwritten.
Note that after , no component of  ever contains a -tuple with .

We say that a value  is a {\it candidate} in a configuration  if it is either the {\it pref} value of some process in 
or it appears in a -tuple in .
We shall prove that there is a configuration after  with at most  candidates.  
After that point, only those  values can appear in -tuples in the snapshot object.
It follows that every process in  completes its th {\sc Propose}
when it next performs a scan, which contradicts the definition of .

\begin{lemma}
\label{disappear}
If, in some configuration  after , a value  is not the 
{\it pref} of any process in  and -tuples with value  appear in fewer than 
 components of the snapshot object, then after some 
time,  will not be a candidate anymore.
\end{lemma}
\begin{proof}
To derive a contradiction, assume that some process in  changes its
local {\it pref} variable to  in some step after .
Consider the first such step by any process after .
Let  be the scan performed in that step.
Between  and , no process executing its th {\sc Propose} stores
a -tuple with value , so the result of  contains -tuples with value 
in at most  components, contradicting the fact that  adopts the value 
in the step when it performs .

Thus, no process in  ever has  as its preferred value after .
So, no -tuple with value  is ever stored in  after .
Since each process in  executes infinitely many steps of its th
{\sc Propose} operation, and increments its index  in every iteration of
the loop, it eventually overwrites every component of .
Thus, there is a time (after ), after which no component of  contains a
-tuple with value .
After this time,  is never a candidate.
\end{proof}

\begin{lemma}
\label{choice-available}
Whenever a process in  performs a scan after , 
there is some value  that appears in -tuples in at least 
 components of .
\end{lemma}
\begin{proof}
To derive a contradiction, suppose there is no such value .  
Consider the configuration  immediately after the scan.
By Lemma \ref{disappear}, only the values stored in {\it pref} variables of processes
in  remain candidates forever.  There are at most  such values.
Thus, there is a time after which every -tuple in  contains only those values.
Whenever a process in  performs a scan after that time, it will
terminate, contradicting our assumption that no process in  ever completes
its th {\sc Propose}.
\end{proof}



For any configuration  and value , let  be the number of components of  that contain -tuples with value  in  plus the number of poised processes that are poised to perform an update and have {\it pref}  in .
The following lemma generalizes Lemma \ref{disappear}.

\begin{lemma}
\label{disappear2}
Consider a value .  If, in some configuration  after , , then after some time,  will no longer be a candidate.
\end{lemma}
\begin{proof}
We first show that if a single step  takes the system from a configuration  to another configuration  and  then .
If  is a step by a process in , it can only decrease .
If  is an update by a process in , 
 may increase by one the number of components of  containing a -tuple with
value , but then  will also decrease the number of processes poised
to store a -tuple with value  by one, so the value of  cannot
be increased by .
Finally, suppose  is an atomic execution of lines \lref{snap-anon}--\lref{change-index-anon}.
In , fewer than  components of  contain -tuples with value
 (since ).  Moreover, by Lemma \ref{choice-available}, there
is a value  such that -tuples with value  appear in at least 
components of the scan performed during .  Thus,
the process performing  adopts some value different from  as its {\it pref}.
So,  cannot increase  for .

Thus, in every configuration reachable from , .
As argued above, any process in  that performs a scan after  adopts
a value different from .
Thus, eventually, no process will have its {\it pref} equal to , and at that time,  will be in at most  components of , so Lemma \ref{disappear} ensures that  will eventually cease to be a candidate.
\end{proof}

Now, consider a configuration  immediately after some process has performed an
update (after ).
There are  registers and at most  processes in  poised
to perform an update.  Thus, .  Therefore, at most  values have .  All other values will eventually cease to be candidates, by Lemma \ref{disappear2}, so eventually there will be at most  candidates.  All processes in  will then terminate when they next perform a scan, which contradicts our definition of .

Thus, we have shown that every process in  completes infinitely many {\sc Propose} operations.
There remains one more thing to show.  There may be some processes not in 
that takes infinitely many steps.  (These are processes that starve in the
non-blocking implementation of the snapshot object.)
We must show that each such process  also completes all of its {\sc Propose} operations.
Processes in  write longer and longer sequences to  infinitely often and processes not in  eventually stop writing to .
Thus, for all ,  will eventually see a sequence in  of length at least ,
and will then complete its th {\sc Propose} operation.

This completes the proof of Theorem \ref{thm:anon-alg}.
We remark that for the one-shot case, the register  is not
required, so we can solve the one-shot version using one less register.
 
\end{document}
