\documentclass{llncs}

\usepackage{amsmath,amssymb,amsfonts}
\usepackage{theorem}
\usepackage{pstricks,pst-node}
\usepackage{listings}

\sloppy

\theorembodyfont{\upshape}
\newtheorem{defs}{Definition}

\renewcommand\floatpagefraction{.9}
\renewcommand\topfraction{.9}
\renewcommand\bottomfraction{.9}
\renewcommand\textfraction{.1}   
\setcounter{totalnumber}{50}
\setcounter{topnumber}{50}
\setcounter{bottomnumber}{50}
\setlength{\textfloatsep}{0.5ex}




\newcommand{\comment}[1]{}
\newcommand{\hi}[1]{\comment{#1}}

\newcommand{\set}[1]{ \{ #1 \} }
\newcommand{\tuple}[1]{\langle {#1} \rangle}

\newcommand{\eg}{\emph{e.g.}}
\newcommand{\ie}{\emph{i.e.}}

\newcommand{\btrue}{\top}
\newcommand{\bfalse}{\bottom}
\newcommand{\band}{\wedge}
\newcommand{\bor}{\vee}
\newcommand{\bnot}{\neg}
\newcommand{\Bimplies}{\Rightarrow}
\newcommand{\vtrue}{\mathsf{true}}
\newcommand{\vfalse}{\mathsf{false}}



\title{-Step Relative Inductive Generalization}
\author{Aaron R. Bradley}
\institute{Dept. of Electrical, Computer \& Energy Engineering \\
University of Colorado at Boulder \\
Boulder, CO 80309 \\
{\tt bradleya@colorado.edu}
}
\date{\today}

\begin{document}

\maketitle
\begin{abstract}
We introduce a new form of SAT-based symbolic model checking.  One
common idea in SAT-based symbolic model checking is to generate new
clauses from states that can lead to property violations.  Our
previous work suggests applying induction to generalize from such
states.  While effective on some benchmarks, the main problem with
inductive generalization is that not all such states can be
inductively generalized at a given time in the analysis, resulting in
long searches for generalizable states on some benchmarks.  This paper
introduces the idea of inductively generalizing states relative to
-step over-approximations: a given state is inductively generalized
relative to the latest -step over-approximation relative to which
the negation of the state is itself inductive.  This idea motivates an
algorithm that inductively generalizes a given state at the highest
level  so far examined, possibly by generating more than one
mutually -step relative inductive clause.  We present experimental
evidence that the algorithm is effective in practice.
\end{abstract}

\newcommand{\vx}{\bar{x}}
\newcommand{\notmodels}[2]{#2 \not\models #1}
\newcommand{\mymodels}[2]{#2 \models #1}

\section{Introduction}

Several themes for SAT-based symbolic model checking
\cite{Burch+Others/1990} have been explored over the past decade
\cite{Biere+Others/1999,Sheeran+Others/2000,McMillan/2002,McMillan/2003,DeMoura+Others/2003,Bradley+Manna/2007}.
A subset of these methods
\cite{McMillan/2002,DeMoura+Others/2003,Bradley+Manna/2007} derive new
search-constraining clauses from discovered states that lead to
property violations.  In previous work, we introduced induction as one
means of generalizing from such states.  Given a cube  that one
would like to exclude because the states that it describes lead to
violations of a desired property, a \emph{minimal inductive subclause}
 of  is a clause whose literals are negations of those
appearing in  () and that is inductive
relative to known reachability information \cite{Bradley+Manna/2007}.
Not all cubes can be inductively generalized at a given time during
proof construction, however.  This inability to inductively generalize
any given cube (whose satisfying states lead to property violations)
limits the applicability of the technique as previously developed
\cite{Bradley+Manna/2007}: on some benchmarks, the model checker
becomes embroiled in long fruitless searches for generalizable cubes.
However, its success on some nontrivial benchmarks indicates that the
fundamental idea of inductive generalization from states is worth
exploring \cite{Bradley/2007}.

We describe in this paper a method based on induction for generalizing
all cubes (unless the asserted property does not hold).  The algorithm
maintains a sequence  of
over-approximations of sets of states reachable in at most  steps, for increasing .  It iteratively generalizes
cubes: a cube  that implies  and that leads in one step to
violating the property is inductively generalized relative to the most
general over-approximation  relative to which the negation of
the state, , is itself inductive.  If , predecessors of
 are treated recursively until  can be inductively generalized
relative to .  We call this process {\it -step relative
  inductive generalization}.  Once  is strengthened to the
point that no -state can transition into a property-violating
state,  is incremented and the generated clauses are propagated
forward through  via implication checks.
The iterations continue until convergence (if the property is
invariant) or until discovery of a counterexample trace (if the
property is not invariant).  Section \ref{sec:main} presents this
algorithm in detail.

The symbolic model checker based on -step relative inductive
generalization is robust.  Section \ref{sec:exp} details our
implementation and experiments on the HWMCC 2008 benchmarks
\cite{hwmcc08}.  Our symbolic model checker outperforms the winner of
the {\it unsat} division and the overall winner of the competition.

\section{Preliminaries}
\label{sec:prelims}

\subsection{Definitions}

A \emph{finite-state transition system}  is described
by a pair of propositional logic formulas: an initial condition
 and a transition relation  over a set of Boolean
variables  and their next-state primed forms 
\cite{Clarke+Others:MC:2000}.  Applying prime to a formula, , is
the same as priming all of its variables.

A state of the system is an assignment of Boolean values to all 
and is described by a \emph{cube} over , which is a conjunction
of literals, each \emph{literal} a variable or its negation.  The
negation of a cube is a \emph{clause}.  An assignment  to all
variables of a formula  either satisfies the formula, denoted
, or falsifies it, denoted .  A
formula  \emph{implies} another formula , written , if every satisfying assignment of  satisfies .

A \emph{trace}  of a transition system , which
may be finite or infinite in length, is a sequence of states such that
 and for each adjacent pair  in the
sequence, .  That is, a trace is the
sequence of assignments in an execution of the transition system.  A
state that appears in some trace of the system is \emph{reachable}.

A safety property  asserts that only -states (states
satisfying ) are reachable.   is \emph{invariant} for the system
if indeed only -states are reachable.  If  is not invariant,
then there exists a finite \emph{counterexample} trace
 such that .

An \emph{inductive} assertion  describes a set of states that
(1) includes all initial states: , and that (2) is
closed under the transition relation: .  An
assertion  is inductive \emph{relative to} another assertion  if
instead of (2), we have that .

An inductive \emph{strengthening} of a safety property  is a
formula  such that  is inductive.  Since ,  is a proof of 's invariance.

\subsection{Inductive Generalization}
\label{subsec:ig}

In previous work, we introduced a technique for discovering a
\emph{minimal inductive subclause}  of a given clause  if one
exists \cite{Bradley+Manna/2007}.  Such a clause  (1) consists only
of literals of  (), (2) is inductive (possibly
relative to known reachability information), and (3) is minimal in
that it does not contain any strict subclauses that are also
inductive.

\emph{Inductive generalization} of a cube  is the process of
finding a minimal inductive subclause  of , if one exists.
The resulting subclause (if one exists) over-approximates the set of
reachable states while excluding .  In practice, a minimal
inductive subclause is typically substantially smaller than the cube
 from which it is extracted.  Hence, it excludes many other states
as well, which is why we say that the inductive subclause generalizes
that  is unreachable.

\section{Algorithm and Analysis}
\label{sec:main}

We describe a complete symbolic model checking algorithm for safety
properties.  Given a transition system  and safety
property , it either generates a formula  such that 
is inductive or it discovers a counterexample trace.

Section \ref{subsec:informal} presents the algorithm informally, while
Section \ref{subsec:illustration} provides an example of its
application.  Then Section \ref{subsec:formal} formally describes and
proves the correctness of the algorithm.

\subsection{Informal Description}
\label{subsec:informal}

The algorithm constructs a sequence  of
over-approximations of the state sets reachable in at most  steps.  It incrementally refines the sequence until some 
converges to an inductive strengthening of , or until it encounters
a counterexample trace.

Initially, , and  for , corresponding to the
assumption that  is invariant.  Let  be the level of , the
frontier of the sequence.  The sequence satisfies the following
invariants: (1) , (2) , and (3) .  If , then 
becomes the new frontier.  Otherwise, there is a state  that leads
in one step to a violation of .

Given such a state , the algorithm finds the highest level  such that  is inductive relative to .  If 
is invariant, such a level exists.  At this level,  can be
inductively generalized relative to .

Inductive generalization produces a clause  that
is inductive relative to .  It asserts that  --- and any
other state  such that  --- is not reachable
within  steps.  Because  has been generalized to ,
 may exclude states that were previously admitted by some  for
.  In other words,  potentially represents new -step
reachability information at every level  up to .  Therefore,
each , for , is strengthened to .

If , then  has been inductively generalized at the highest
possible level, and  no longer admits the state , bringing the
algorithm one step closer to strengthening  such that .

If , then the generalization of  at level  must be pushed
to level .  There must exist some predecessor  of  admitted
by  but excluded by .  This predecessor is one of the
reasons that  is not inductive relative to .  Now
 is considered recursively for inductive generalization.  This
recursion continues until  can be inductively generalized relative
to .

Once  holds, the clauses that have been
generated so far are propagated forward through
: for each clause , if , then  is
conjoined to .  If the clause sets of two adjacent levels,
 and , become equal, then  is an inductive
strengthening of  that proves 's invariance.

If  is not invariant, the algorithm discovers a counterexample
trace, though not necessarily a shortest.  Let  be
a shortest counterexample trace.  The algorithm finds a counterexample
trace when , if not earlier.  For when , each , for
, can be shown to be inductive relative to at most
.  Hence,  (or another 1-step state from another
counterexample trace) must eventually be analyzed during the recursion
associated with inductively strengthening  (or another state from
another counterexample trace) relative to , at which point it
would be found to be reachable from an initial state.

\subsection{An Illustrative Example}
\label{subsec:illustration}

Consider the contrived transition system  with
variables , initial condition

and transition relation

The intention is that  and  --- and thus  --- are always
.  This intention is asserted as the safety assertion .
We apply the algorithm to this transition system to prove the
invariance of .

\begin{enumerate}
\item  is initialized to , each of  to , and  to .

\item  is satisfiable.  One satisfying
  assignment yields the -predecessor .  Is  inductive relative to ?  Yes, as
   implies .  Inductive
  generalization of  relative to  yields the clause , where (1) , and (2)  is
  inductive relative to .  As Table \ref{table:illustration}
  illustrates,  is conjoined at both levels 1 and 2 while still
  maintaining the invariants on the sequence 
  discussed above.  The clause  not only excludes  but also
  many other states, which is the purpose of inductive generalization.

\begin{table}[tb]
\caption{Incremental construction of an inductive strengthening assertion}
\label{table:illustration}
\centering
\vspace{-1ex}

\vspace{1em}
\end{table}

\item  is still satisfiable.  One
  satisfying assignment yields the -predecessor .   is inductive relative to .
  Inductive generalization yields from  the clause , which is also inductive relative to .

\item  is still satisfiable.  One
  satisfying assignment yields the -predecessor ,
  which has predecessor  at level 1.  Hence,
   is not inductive relative to .  However, it is
  inductive relative to , and inductive generalization yields
  from  the clause  at level 0.  As
  Table \ref{table:illustration} indicates,  is only placed at
  level 1 (and implicitly at level 0).

\item The state  is again considered at level 1, but as 
  does not exclude ,  is still not inductive relative
  to .  Therefore  is considered.  But it, too, has a
  predecessor  at level 1.  However, it is inductive relative to ,
  and inductive generalization yields  at level 0.

\item Now either  or  must be considered at level 1.
  Choosing  reveals that  is now inductive relative to
  , and inductive generalization yields  at level 1.  Notice how the deduction of  at level 0
  is crucial to the deduction of  at level 1.

\item To finish this iteration, it remains to address  at level
  1.  With the addition of ,  is inductive relative to
  , and inductive generalization yields again the clause , but now at level 1 instead of level 0.  Inductively
  generalizing cubes at the highest possible levels until convergence
  at  makes it possible to deduce the equivalence , which requires two clauses to express.

\item  is still satisfiable.  One
  satisfying assignment yields the -predecessor , which is inductive relative to .  Inductive
  generalization yields the clause  at level 1.

\item With  at level 1, analysis of the  component of the
  transition system proceeds similarly until  becomes unsatisfiable.

\item Propagation from  to  and from  to 
  reveals that all clauses are inductive and inductively strengthen
  .  Simplifying through subsumption and rewriting the formula
  yields the expected inductive strengthening

of the safety assertion , thus proving its invariance.
\end{enumerate}

\subsection{Formal Presentation and Analysis}
\label{subsec:formal}

We present the algorithm and its proof of correctness simultaneously
with formally annotated pseudocode in Listings
\ref{code:prove}-\ref{code:push} using the classic approach to program
verification \cite{Floyd:Verification:1967,Hoare:Verification:1969}.
All assertions are inductive, but the ranking functions require some
additional reasoning.  For convenience, some assertions are labeled
and subsequently referenced in annotations.

\newcommand{\vmin}{\mathit{min}}
\newcommand{\vrv}{\mathit{rv}}
\newcommand{\vstates}{\mathit{states}}
\lstset{
  mathescape=true,
  basicstyle={\small\ttfamily},
  numbers=right,
  numberstyle={\scriptsize\sffamily},
  numbersep=3pt,
  firstnumber=auto,
  frame=single,
  framesep=2pt
}
\begin{lstlisting}[name=code,caption={The main function},label=code:prove,float=tb]
-post:  iff  is invariant
bool prove():
  if either  or  is satisfiable:
    -assert: there exists a counterexample trace
    return false
   := , clauses() := 
   := , clauses() :=  for all 
  for  =  to :
    -rank: at most 
    -assert (): 
      (1) 
      (2) 
      (3) 
      (4) 
      (5) 
    if not check():
      -assert: there exists a counterexample trace
      return false
    propagate()
    if there exists  such that :
      -assert:
        (1) 
        (2) 
        (3) 
      return true
\end{lstlisting}

Listing \ref{code:prove} presents the top-level function {\tt prove},
which returns  if and only if  is invariant.  First it
looks for 0-step and 1-step counterexample traces.  If none are found,
 are initialized to assume that  is invariant,
while their clause sets are initialized to empty.  As a formula, 
for  is interpreted as .  Then it constructs the sequence of -step
over-approximations starting with .  On each iteration, it first
calls {\tt check}() (Listing \ref{code:check}), which strengthens
 for  so that -states are at least
 steps away from violating .  Then it calls {\tt
  propagate}() (Listing \ref{code:check}) to propagate clauses
forward through  based on their having
become inductive relative to higher levels during the call to {\tt
  check}.  If this propagation yields any adjacent levels that share
all clauses (a simple syntactic check, not a validity check), an
inductive strengthening of  has been discovered.

While the assertions are inductive, an argument needs to be made to
justify the ranking function.  By .{\tt 3}, the state sets
represented by  are nondecreasing with
level.  To avoid termination at the {\tt if} check requires that they
be strictly increasing with level, which is impossible when 
exceeds the number of possible states.  Hence,  is bounded by
, and, assuming that the called functions always
terminate, {\tt prove} always terminates.

\begin{lstlisting}[name=code,caption={The {\tt check} and {\tt propagate} functions},label=code:check,float=tb]
-pre:  
  (1) 
  (2) 
-post: 
  (1) .1-3
  (2) if  then 
  (3) 
  (4) if not  then there exists a counterexample trace
bool check( : level):
  try:
    while  is satisfiable:
      -rank: at most 
      -assert ():
        (1) .1-4
        (2) 
        (3) 
      let  be the predecessor extracted from the witness
      -assert:  or  is inductive relative to 
       := inductive(, , )
      push(, )
      -assert (): 
    return true
  except Counterexample:
    return false

-pre/post:
  (1) .1-3
  (2) 
  (3) 
void propagate( : level):
  for  =  to :
    for each  in clauses():
      -assert: pre/post
      if  is unsatisfiable:
         := 
\end{lstlisting}

For a given level , {\tt check}() (Listing \ref{code:check})
iterates until  excludes all states that can lead to a violation
of  in one step.  Suppose  is one such state.  It is eliminated
by, first, inductively generalizing it at the highest level  at
which  is inductive relative to  through a call to {\tt
  inductive}(, , ) (Listing \ref{code:ig}) and then,
second, pushing for a generalization at level  through a call to
{\tt push}(, ) (Listing \ref{code:push}).  At the
end of the iteration,  excludes  (assertion ).  This
progress implies that the loop can iterate at most as many times as
there are possible states, yielding {\tt check}'s ranking function.

Notice how {\tt check}, according to its postcondition, preserves loop
invariants .{\tt 1-3} while incrementing .{\tt 4-5} to to apply
to an additional step (see postconditions (2) and (3)), unless a
counterexample is found.

\begin{lstlisting}[name=code,caption={-step relative inductive generalization},label=code:ig,float=tb]
-pre:  
  (1) 
  (2) 
  (3)  is inductive relative to 
-post: 
  (1) 
  (2) 
void generate( : state,  : level,  : level):
   := find subclause of  that is inductive relative to 
  for  =  to :
    -assert: 
      (1) 
      (2) 
     := 

-pre:  
  (1) 
  (2) 
  (3)  or  is inductive relative to 
  (4) there is a trace from  to a -state
-post: 
  (1) 
  (2) , 
  (3) 
  (4)  is inductive relative to 
level inductive( : state,  : level,  : level):
  if  and  is satisfiable:
    -assert: there exists a counterexample trace
    raise Counterexample
  for  = max(1, ) to :
    -assert: 
      (1) 
      (2) 
      (3) ,  is inductive relative to 
    if  is satisfiable:
      generate(, , )
      return 
  generate(, , )
  return 
\end{lstlisting}

The functions {\tt inductive} and {\tt generate} (Listing
\ref{code:ig}) perform inductive generalization.  The details of
discovering an inductive subclause are described in previous work
\cite{Bradley+Manna/2007}.  One interesting observation, however, is
that when calling {\tt inductive}, a minimum level  at which
 is inductive relative to  can be supplied.  At
lines 43-44,  by .{\tt 2} and .{\tt 4}
so that  is inductive relative to  by .{\tt 4}.
At lines 127-128,  is inductive relative to  so that
 and thus  is inductive relative to
 by .{\tt 4}.  If , then it is possible that
 is reachable from an initial state, hence the check at line 87.

\begin{lstlisting}[name=code,caption={The {\tt push} function for -step relative inductive generalization},label=code:push,float=tb]
-pre:  
  (1) 
  (2) 
  (3) 
  (4)  is inductive relative to 
  (5) , there is a trace from  to a -state
-post:
  (1) 
  (2) 
void push( : (level, state) set,  : level):
  while true:
    -rank: at most 
    -assert ():
      (1) 
      (2) 
      (3) 
      (4) 
      (5)  is inductive relative to 
      (6)  there is a trace from  to a -state
    (, ) := choose pair from  that minimizes 
    -assert: 
    if :
      return
    if  is satisfiable:
      let  be the predecessor extracted from the witness
      -assert ():
        (1) 
        (2)  or  is inductive relative to 
       := inductive(, , )
       := 
    else:
       := inductive(, , )
      -assert (): 
       := 
\end{lstlisting}

The {\tt push} algorithm (Listing \ref{code:push}) is the key to
``pushing'' inductive generalization to higher levels.  The insight is
simple: if a state  is not inductive relative to , apply
inductive generalization to its predecessors that satisfy .
The complication is that this recursive analysis must proceed in a
manner that terminates despite the presence of cycles in the system's
state graph.  To achieve termination, a set  of pairs  is maintained such that each pair  represents
the knowledge that (1)  is inductive relative to , and (2)
 excludes .  The loop in {\tt push} always selects a pair
 from  such that  is minimal over the set.
Hence, none of the states already represented in  can be a
predecessor of  at level .

Formally, termination of {\tt push} is established by the inductive
assertions .{\tt 2}, which asserts that the set of states
represented in  does not decrease; .{\tt 1}, which
asserts that each state in  is represented by at most one
pair in ; and , which asserts that the level associated
with a state can only increase.  Given that each iteration either adds
a new state to  or increases a level for some state already
in  and that levels peak at , the number of iterations
is bounded by the product of  and the size of the state space.

The inductive proof in Listings \ref{code:prove}-\ref{code:push} and
the termination arguments yield total correctness:

\begin{theorem} 
\label{th:correct}
For finite transition system , the algorithm always
terminates and returns true if and only if safety assertion  is
invariant.
\end{theorem}

\subsection{Variations}

Notice that {\tt inductive} and {\tt generate} (Listing \ref{code:ig})
together generate a subclause of  that is inductive relative
to , where  is the greatest level for which  is
itself inductive relative to .  It is actually possible to find
the highest level  for which  has a subclause that
is inductive relative to  even if  is not itself
inductive relative to  (that is, ).  The difference
between these two approaches is in whether the {\sf down} function of
\cite{Bradley+Manna/2007} is ever applied to .  In the method
of {\tt inductive} and {\tt generate}, it is not; in the variation, it
is.

While generalizing at higher levels is desirable, applying {\sf down}
to large clauses, such as , is the most expensive phase of
inductive generalization in practice.  On particularly large
benchmarks with thousands of latches this phase can take prohibitively
long; for example, on the {\tt neclaftpX00X} benchmarks from HWMCC'08,
this variation does not typically terminate in under 15 minutes.

One might wonder, therefore, if a weaker but faster inductive
generalization procedure could be used.  An obvious such procedure is
the following: rather than using full induction, one could search for
clauses that are established in the next state without assuming them
as inductive hypotheses --- in other words, perform a search for an
implicate subclause (that is also inductive) rather than for an
inductive subclause.  Experiments indicate that using this
generalization yields an overall model checker that is rarely faster
and often significantly slower despite the superior speed of the
individual generalizations.  Of course, a positive spin on this
disappointing result is that full induction is apparently a powerful
generalization technique compared to searching for implicates.

\section{Implementation and Experiments}
\label{sec:exp}

\subsection{Implementation}

We implemented the algorithm using O'Caml for top-level reasoning,
MiniSAT 2.0 for preprocessing the transition relation
\cite{Een+Biere/2005}, and ZChaff for SAT-solving because of its
incremental solving capability \cite{Moskewicz+Others/2001}.  Notice
that the SAT-solving libraries were available before 2008; thus, our
performance on the HWMCC'08 benchmarks reported below cannot be
attributed to superior SAT solvers.

{\bf Preprocessing.}  MiniSAT 2.0 provides an interface for
``freezing'' variables that should not be chosen for elimination
during preprocessing.  We use it to simplify the given transition
relation once and for all \cite{Een+Others/2007}.  Reducing the
transition relation according to the cone-of-influence
\cite{Clarke+Others:MC:2000} followed by preprocessing yielded
significant performance improvements for inductive generalization.  It
is likely that more sophisticated preprocessing would yield better
performance.

{\bf Incremental SAT-Solving.}  Our technique requires solving
hundreds to thousands of SAT problems per second in an incremental
fashion.  While MiniSAT 2.0 provides the ability to maintain context
and change assumptions in the form of literals, only ZChaff, as far as
we know, provides competitive SAT-solving combined with the ability to
push and pop incremental context that includes sets of clauses.  It is
likely that a fully incremental version of a modern SAT solver would
yield better performance.

{\bf Optimizations.}  Given that our algorithm relies on inductive
generalization, we implemented a simple method to extract literal
invariants that are obvious from the structure of the initial
condition and transition relation.  This optimization greatly improved
performance on the {\tt neclaftpX00X} benchmarks.

We implemented binary, rather than linear, search in the function {\tt
  inductive}.

In our implementation of inductive generalization
\cite{Bradley+Manna/2007}, we use a simple threshold to end the search
for a minimal inductive subclause.  If a certain number of randomly
chosen literals (three in our implementation) are determined to be
necessary to yield an inductive subclause, the search for a smaller
inductive subclause ends.  While minimality is no longer guaranteed,
the resulting clauses are sufficiently strong (and probably minimal).

Finally, we implemented a VSIDS-like literal-ordering heuristic to
guide which inductive clauses are discovered from a given cube
\cite{Moskewicz+Others/2001}.  Since a given clause can have many
minimal inductive subclauses, the idea is to focus on those literals
whose negations have appeared most frequently in examined states in
recent history.  Unfortunately, whether the heuristic has any benefit
is unclear.





\subsection{Experiments}

The benchmarks and results from the Hardware Model Checking
Competition 2008 provide a means of comparing different model checking
algorithms \cite{hwmcc08}.  We report our performance on these
benchmarks.

We performed all experiments on a laptop equipped with an Intel Core 2
Duo 2.2 GHz processor, although only one core was used, and 4 GB of
memory.  In the HWMCC'08 competition, entries ran on Pentium IV 3 GHz
processors with 2 GB of memory.  After reading various online forums,
we concluded that our processor provides a speed advantage of
approximately  over the hardware used in the competition.
Thus, rather than counting the number of benchmarks solved in under
900 seconds, we count only those solved in under 500 seconds.

Our implementation constructs proofs of unsatisfiability for 325
benchmarks in under 500 seconds and using at most 1.5 GB of memory,
compared to the 314 solved by {\tt abc}, the winner of the {\it unsat}
division of the competition.  Ten of these benchmarks were not solved
during the competition.  It finds counterexample traces in 234 cases,
surprisingly competitive with BMC \cite{Biere+Others/1999}.  The top
four entries for the satisfiable problems, all based on BMC, found
247, 243, 239, and 239 counterexamples, respectively.  Our total
number of solved problems is thus 559, seven more than {\tt abc}, the
winner of the overall competition.

Table \ref{table:data} presents data for the 38 benchmarks that our
implementation proved unsatisfiable in the allotted time (500 seconds)
and memory (1.5 GB) that were solved by at most three competitors.  The
second column lists those competitors who solved the benchmark, their
time in seconds (unscaled), and their peak memory consumption in MB.
The third through sixth columns list our implementation's time in
seconds {\it scaled by 1.8 to allow for better comparison}, memory
consumption in MB, the number of thousands of SAT instances solved,
and the number of the clauses in the proof, respectively.  Again, the
time for our implementation is multiplied by 1.8, so indicated runtime
can be over 500 seconds despite our setting the timeout at 500
seconds.

\begin{table}[tb]
\label{table:data}
\caption{Solved benchmarks that were solved in HWMCC'08 by at most three solvers}
\centering
\vspace{-1ex}
{\scriptsize
\begin{tabular}{|l|l|r|r|r|r|}
\hline
{\bf Benchmark} & {\bf Solved by} ({\sf solver}/sec/MB) & {\bf Sec} & {\bf MB} & {\bf SC}(k) & {\bf Proof} \\ \hline\hline
{\tt bjrb07amba6andenv} & {\sf abc}/309/166 {\sf pdtravbdd}/19/61 & 462 & 364 & 11 & 269 \\ \hline
{\tt bjrb07amba7andenv} & {\sf abc}/203/180 {\sf pdtravbdd}/242/71 & 169 & 253 & 7 & 221 \\ \hline
{\tt intel006} & {\sf pdtravitp}/348/143 {\sf tipidi}/367/425 & 32 & 79 & 28 & 931 \\ \hline
{\tt intel007} & {\sf pdtravcbq}/881/185 & 541 & 228 & 76 & 2906 \\ \hline
{\tt intel026} & & 261 & 277 & 96 & 1335 \\ \hline
{\tt intel037} & & 207 & 786 & 2 & 157 \\ \hline
{\tt intel054} & {\sf tipidi}/2/8 {\sf tipids}/2/8 {\sf tipind}/2/8 & 414 & 174 & 271 & 4544 \\ \hline
{\tt intel055} & {\sf tipidi}/43/12 {\sf tipids}/43/12 & 39 & 95 & 30 & 615 \\ \hline
{\tt intel056} & {\sf tipidi}/7/13 {\sf tipids}/8/13 & 91 & 79 & 93 & 1597 \\ \hline
{\tt intel057} & {\sf tipidi}/2/6 {\sf tipids}/2/6 {\sf tipind}/2/6 & 176 & 129 & 142 & 2332 \\ \hline
{\tt intel059} & {\sf tipidi}/4/8 {\sf tipids}/4/8 & 46 & 74 & 53 & 982 \\ \hline
{\tt neclabakery001} & {\sf aigtrav}/14/95 {\sf pdtravbdd}/18/54 {\sf tipind}/422/34 & 156 & 233 & 417 & 2755 \\ \hline
{\tt neclaftp1001} & & 84 & 781 & 1 & 669 \\ \hline
{\tt neclaftp1002} & & 284 & 1417 & 3 & 707 \\ \hline
{\tt neclaftp2001} & {\sf tipidi}/839/122 {\sf tipids}/838/122 {\sf tipind}/834/123 & 43 & 466 & 1 & 638 \\ \hline
{\tt neclaftp2002} & {\sf tipind}/898/175 & 248 & 816 & 3 & 644 \\ \hline
{\tt neclatcas1a001} & {\sf tipidi}/0/0 {\sf tipids}/0/0 {\sf tipind}/0/0 & 3 & 56 & 1 & 86 \\ \hline
{\tt neclatcasall001} & {\sf tipidi}/0/0 {\sf tipids}/0/0 {\sf tipind}/0/0 & 45 & 97 & 20 & 279 \\ \hline
{\tt nusmvbrp} & {\sf pdtravbdd}/456/74 {\sf pdtravcbq}/187/283 & 21 & 50 & 56 & 688 \\ \hline
{\tt nusmvguidancep2} & {\sf pdtravbdd}/478/61 {\sf tipidi}/873/394 & 23 & 78 & 16 & 164 \\ \hline
{\tt nusmvguidancep5} & {\sf pdtravbdd}/59/44 & 16 & 70 & 10 & 121 \\ \hline
{\tt nusmvguidancep6} & {\sf abc}/34/35 {\sf pdtravbdd}/54/44 {\sf pdtravitp}/92/177 & 10 & 69 & 8 & 97 \\ \hline
{\tt pdtvisbakery0} & {\sf abc}/21/97 {\sf pdtravbdd}/28/60 & 113 & 164 & 36 & 215 \\ \hline
{\tt pdtvisbakery1} & {\sf abc}/96/97 {\sf pdtravbdd}/44/61 & 144 & 182 & 44 & 308 \\ \hline
{\tt pdtvisbakery2} & {\sf abc}/57/95 {\sf pdtravbdd}/114/64 & 136 & 191 & 42 & 371 \\ \hline
{\tt pdtvisgoodbakery0} & {\sf abc}/45/98 {\sf pdtravbdd}/57/64 & 203 & 202 & 65 & 601 \\ \hline
{\tt pdtvisgoodbakery1} & {\sf abc}/102/95 {\sf pdtravbdd}/51/63 & 142 & 175 & 46 & 458 \\ \hline
{\tt pdtvisgoodbakery2} & {\sf abc}/118/97 {\sf pdtravbdd}/49/60 & 153 & 193 & 47 & 372 \\ \hline
{\tt pdtvisns3p00} & & 244 & 138 & 120 & 1709 \\ \hline
{\tt pdtvisns3p01} & {\sf pdtravcbq}/618/266 {\sf tipids}/670/145 & 352 & 131 & 152 & 2287 \\ \hline
{\tt pdtvisns3p02} & & 196 & 129 & 100 & 1169 \\ \hline
{\tt pdtvisns3p03} & & 230 & 121 & 106 & 1398 \\ \hline
{\tt pdtvisns3p04} & & 550 & 115 & 207 & 2187 \\ \hline
{\tt pdtvisns3p06} & {\sf pdtravcbq}/823/278 & 837 & 164 & 289 & 2845 \\ \hline
{\tt pdtvisns3p07} & & 311 & 131 & 145 & 1453 \\ \hline
{\tt pdtvisrethersqo4} & {\sf abc}/23/15 & 162 & 157 & 341 & 3394 \\ \hline
{\tt pdtvissoap1} & {\sf pdtravitp}/384/520 & 70 & 102 & 42 & 807 \\ \hline
{\tt pdtvissoap2} & & 108 & 101 & 65 & 1789 \\ \hline
 \end{tabular}
\vspace{1em}
}
\end{table}

In case the 1.8 scaling to compensate for different processors is
considered too low, the results for 3.0 scaling are the following: 317
proofs and 228 counterexamples, with 545 benchmarks solved overall.

\section{Related Work}
\label{sec:related}



SAT-based unbounded model checking was the first symbolic model
checking approach based on generating clauses \cite{McMillan/2002}.
It discovers implicates to generalize states leading to property
violations.  The overall iterative structure is the same as standard
symbolic model checking.  In our algorithm, induction is a means not
only for generalizing from states but also for abstracting the system
based on the property, allowing the analysis of large transition
systems.



Our algorithm can be seen as an instance of predicate
abstraction/refinement \cite{Graf+Saidi/1997,Clarke+Others/2003} in
that the minor iterations generate new predicates (clauses) while the
major iterations propagate them.  If the clauses are insufficient for
convergence to an inductive strengthening assertion, the next minor
iteration generates additional clauses that allow propagation to
continue at least one additional step.



The -step over-approximation structure of  is similar to that of interpolation-based model checking
(ITP) \cite{McMillan/2003}, which uses an interpolant from an
unsatisfiable -step BMC query to compute the post-image
approximately.  All states in the image are at least  steps away
from violating the property.  A larger  refines the image by
increasing the minimum distance to violating states.  In our
algorithm, if the frontier is at level , then , for , represents states that are at least  steps from violating
the property.  As  increases, the minimum number of steps from
-states to violating states increases.  In both cases,
increasing  (in ours) or  (in ITP) sufficiently for a correct
system yields an inductive assertion.  However, the algorithms differ
in their underlying ``technology'': ITP computes interpolants from
-step BMC queries, while our algorithm uses inductive
generalization of cubes, which requires only 1-step BMC queries for
arbitrarily large .



Various approaches to generalizing counterexamples to -induction
have been explored
\cite{DeMoura+Others/2003,Awedh+Others/2006,Vimjam+Others/2006}.  Our
work could in principle be applied as a method of strengthening
-induction.  However, the technique already works well on its own
and has the distinct advantage of posing small SAT problems.

Finally, we draw on our previous work on inductive generalization
\cite{Bradley+Manna/2007}.  This paper contributes -step relative
inductive generalization, which guarantees that all examined cubes can
be inductively generalized if the property is invariant.

\section{Conclusion}

The empirical data suggest the effectiveness of -step relative
inductive generalization, a technique unlike --- and therefore
complementary to --- other symbolic model checking methods.  The most
exciting direction for our ongoing research is to parallelize the
algorithm.  Our earlier work on inductive generalization was easily
parallelized and sometimes yielded near-linear scaling with the number
of nodes on hard benchmarks \cite{Bradley/2007}.  The new algorithm,
although more complex in structure, should be similarly parallelizable
since the implementation spends the majority of its time generating
clauses incrementally.

BMC is faster than our implementation at finding counterexample
traces.  We plan to investigate a combination of our algorithm with
BMC in which generated clauses would constrain the SAT search space.

Another direction for research is to apply the idea of finding
-step relative inductive generalizations of states in an
infinite-state setting.

\bibliographystyle{acm}
\begin{thebibliography}{10}

\bibitem{Awedh+Others/2006}
{\sc Awedh, M., and Somenzi, F.}
\newblock Automatic invariant strengthening to prove properties in bounded
  model checking.
\newblock In {\em DAC\/} (2006), ACM Press, pp.~1073--1076.

\bibitem{hwmcc08}
{\sc Biere, A., Cimatti, A., Claessen, K., Jussila, T., McMillan, K., and
  Somenzi, F.}
\newblock Hardware model checking competition, 2008.

\bibitem{Biere+Others/1999}
{\sc Biere, A., Cimatti, A., Clarke, E.~M., and Zhu, Y.}
\newblock Symbolic model checking without {BDD}s.
\newblock In {\em TACAS\/} (London, UK, 1999), Springer-Verlag, pp.~193--207.

\bibitem{Bradley/2007}
{\sc Bradley, A.~R.}
\newblock {\em Safety Analysis of Systems}.
\newblock PhD thesis, Stanford University, May 2007.

\bibitem{Bradley+Manna/2007}
{\sc Bradley, A.~R., and Manna, Z.}
\newblock Checking safety by inductive generalization of counterexamples to
  induction.
\newblock In {\em FMCAD\/} (2007).

\bibitem{Burch+Others/1990}
{\sc Burch, J.~R., Clarke, E.~M., McMillan, K.~L., Dill, D.~L., and Hwang, L.}
\newblock Symbolic model checking:  states and beyond.
\newblock In {\em LICS\/} (1990), pp.~428--439.

\bibitem{Clarke+Others/2003}
{\sc Clarke, E., Grumberg, O., Jha, S., Lu, Y., and Veith, H.}
\newblock Counterexample-guided abstraction refinement for symbolic model
  checking.
\newblock {\em J. ACM 50}, 5 (2003), 752--794.

\bibitem{Clarke+Others:MC:2000}
{\sc Clarke, E., Grumberg, O., and Peled, D.}
\newblock {\em Model Checking}.
\newblock MIT Press, 2000.

\bibitem{Een+Biere/2005}
{\sc E{\'e}n, N., and Biere, A.}
\newblock Effective preprocessing in {SAT} through variable and clause
  elimination.
\newblock In {\em SAT\/} (2005), vol.~3569, Springer, pp.~61--75.

\bibitem{Een+Others/2007}
{\sc E{\'e}n, N., Mishchenko, A., and S{\"o}rensson, N.}
\newblock Applying logic synthesis for speeding up {SAT}.
\newblock In {\em SAT\/} (2007), pp.~272--286.

\bibitem{Floyd:Verification:1967}
{\sc Floyd, R.~W.}
\newblock Assigning meanings to programs.
\newblock In {\em Symposia in Applied Mathematics\/} (1967), vol.~19, American
  Mathematical Society, pp.~19--32.

\bibitem{Graf+Saidi/1997}
{\sc Graf, S., and Saidi, H.}
\newblock Construction of abstract state graphs with {PVS}.
\newblock In {\em CAV\/} (June 1997), O.~Grumberg, Ed., vol.~1254 of {\em
  LNCS}, Springer, pp.~72--83.

\bibitem{Hoare:Verification:1969}
{\sc Hoare, C. A.~R.}
\newblock An axiomatic basis for computer programming.
\newblock {\em Communications of the ACM 12}, 10 (October 1969), 576--580.

\bibitem{McMillan/2002}
{\sc McMillan, K.~L.}
\newblock Applying {SAT} methods in unbounded symbolic model checking.
\newblock In {\em CAV\/} (2002), vol.~2404 of {\em LNCS}, Springer-Verlag,
  pp.~250--264.

\bibitem{McMillan/2003}
{\sc McMillan, K.~L.}
\newblock Interpolation and {SAT}-based model checking.
\newblock In {\em CAV\/} (2003), vol.~2725 of {\em LNCS}, Springer, pp.~1--13.

\bibitem{Moskewicz+Others/2001}
{\sc Moskewicz, M.~W., Madigan, C.~F., Zhao, Y., Zhang, L., and Malik, S.}
\newblock {Chaff: Engineering an Efficient {SAT} Solver}.
\newblock In {\em DAC\/} (2001).

\bibitem{DeMoura+Others/2003}
{\sc Moura, L.~D., Ruess, H., and Sorea, M.}
\newblock Bounded model checking and induction: From refutation to
  verification.
\newblock In {\em CAV\/} (2003), Springer-Verlag, pp.~14--26.

\bibitem{Sheeran+Others/2000}
{\sc Sheeran, M., Singh, S., and St\r{a}lmarck, G.}
\newblock Checking safety properties using induction and a sat-solver.
\newblock In {\em FMCAD\/} (2000), pp.~127--144.

\bibitem{Vimjam+Others/2006}
{\sc Vimjam, V.~C., and Hsiao, M.~S.}
\newblock Fast illegal state identification for improving {SAT}-based
  induction.
\newblock In {\em DAC\/} (2006), ACM Press, pp.~241--246.

\end{thebibliography}

\end{document}
