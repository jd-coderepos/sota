






\documentclass[a4paper,UKenglish]{lipics}

\usepackage{microtype}\usepackage{amsmath,amssymb,graphicx}
\usepackage{algorithm}
\usepackage[noend]{algorithmic}
\usepackage{snapshot}













\newcommand{\IR}{\ensuremath{\mathbb{R}}} 
\newcommand{\IZ}{\ensuremath{\mathbb{Z}}} 
\newcommand{\IN}{\ensuremath{\mathbb{N}}} 
\newcommand{\IS}{\ensuremath{\mathbb{S}}} 
\newcommand{\IC}{\ensuremath{\mathbb{C}}} 
\newcommand{\IB}{\ensuremath{\mathbb{B}}} 



\newcommand{\X}{\ensuremath{\mathbb{x}}} 


\newcommand{\OPT}{\ensuremath{\mbox{\tt OPT}}}
\newcommand{\opt}{\ensuremath{\mbox{\tt opt}}}
\newcommand{\APX}{\ensuremath{\mbox{\tt APX}}}
\newcommand{\apx}{\ensuremath{\mbox{\tt apx}}}

\newcommand{\lee}{\leqslant}
\newcommand{\gee}{\geqslant}
\newcommand{\ceil}[1]{{\left\lceil{#1}\right\rceil}}
\newcommand{\floor}[1]{{\left\lfloor{#1}\right\rfloor}}
\newcommand{\prob}[1]{{\mbox{\tt Pr}[#1]}}
\newcommand{\set}[1]{{\{ #1 \}}}
\newcommand{\iset}[2]{{[#1\,..\,#2]}} 
\newcommand{\seq}[1]{{\left< #1 \right>}}
\newcommand{\provided}{\,|\,}

\newcommand{\eps}{\varepsilon}
\newcommand{\bslash}{\!\setminus\!}
\newcommand{\bigOmega}{{\rm\Omega}}
\newcommand{\etal}{{\em et~al.\/}}
\newcommand{\REM}[1]{}
\newcommand {\backspace}{\vspace{-3.2em}\\}



\newcommand{\eq}{{\ \leftarrow\ }}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\renewcommand{\algorithmicforall}{\textbf{for all}}



\newcommand{\CF}{{\mathscr F}}
\newcommand{\CR}{{\mathscr R}}
\newcommand{\CB}{{\mathscr B}}
\newcommand{\CS}{{\mathscr S}}
\newcommand{\CC}{{\mathscr C}}
\newcommand{\CO}{{\mathscr O}}
\newcommand{\Pol}{{\mathscr P}}

\newcommand{\PolSeg}{{P}}

\newcommand{\CI}{{\mathscr I}}
\newcommand{\CQ}{{\mathscr Q}}


\newcommand{\TA}{{\mathscr A}}
\newcommand{\TB}{{\mathscr B}}
\newcommand{\CH}{{\mathscr CH}}


\newcommand{\Chop}{{\mathscr Chop}}

\newcommand{\gre}{{g}}
\newcommand{\sma}{{s}}
\newcommand{\cfev}{{l}} \newcommand{\sq}{{\CS\CQ}}




\newcommand{\F}{\CF}
\newcommand{\R}{\CR}


\newcommand{\Frechet}{Fr\'echet }
\newcommand{\distF}{\delta_F}
\newcommand{\DoubleB}{Double-TypeB}





\DeclareMathOperator{\Left}{left}
\DeclareMathOperator{\Right}{right}

\newcommand{\Seg}[1]{{\overline{#1}}}
\newcommand{\reach}{{\mathscr R}}






\newcommand{\Dir}{\overrightarrow} 
\newcommand{\ri}{r}
\newcommand{\re}{\ell}

\newcommand{\lei}{\prec}
\newcommand{\lex}{\preceq}
\newcommand{\gei}{\succ}
\newcommand{\gex}{\succeq}



 



\newcommand{\ttt}[1]{\mbox{\scriptsize }}
\newcommand{\PCC}[1]{ \ttt{  \overset{ \curvearrowleft}{P_{#1}}   }}
\newcommand{\PC}[1]{  \ttt {\overset{ \curvearrowright}{P_{#1}}    }}
\newcommand{\reachC}[1]{{\mathscr SC_{#1}}}
\newcommand{\reachCC}[1]{{\overleftarrow{\mathscr R_{#1}}}}
\newcommand{\ap}{\oplus}
\newcommand{\pset}{S}
\newcommand{\Qs}{x} \newcommand{\Ps}{x'} \newcommand{\Good}{\mbox{type A}}
\newcommand{\SemiBad}{\mbox{type B}}
\newcommand{\Bad}{\mbox{type C}}
\newcommand{\Funny}{\mbox{type D}}

\newcommand{\see}{\leadsto}

\newcommand{\notsee}{\nrightarrow}

\newcommand{\Special}{\mbox{special}}
\newcommand{\PST}{P_{st}}

\newcommand{\Enemy}{\mbox{rival}}
\newcommand{\ChUp}{Ch_u}
\newcommand{\ChLo}{Ch_l}
\newcommand{\lme}[1]{{\lambda_{#1}}}
\newcommand{\PP}{ T}
\newcommand{\BounC}{\sigma}

\newcommand{\cone}{\pi_a}
\newcommand{\ctwo}{\pi_b}

\newcommand{\Uone}{\pi_a}
\newcommand{\Utwo}{\pi_b}
\newcommand{\Lone}{\mu_a}
\newcommand{\Ltwo}{\mu_b}
\newcommand{\conc}[2]{{{#1} \oplus {#2}}}























































\bibliographystyle{plain}
\title{Visiting All Sites with Your Dog 
\footnote{Submitted to STACS 2013, on Sep 21, 2012}
\footnote{Research supported by NSERC}}

\author[1]{Anil Maheshwari}
\author[2]{J\"{o}rg-R\"{u}diger Sack }
\author[3]{Kaveh Shahbaz}

\affil[1,2,3]{~School of Computer Scince \\ Carleton University 
\\ Ottawa, Ontario, Canada \\
Email: {\tt \{anil,sack,kshahbaz\}@scs.carleton.ca}}



\keywords{\Frechet Distance, Similarity of Curves}
\serieslogo{}\volumeinfo {Billy Editor, Bill Editors}{2}{Conference title on which this volume is based on}{1}{1}{1}\EventShortName{}
\DOI{10.4230/LIPIcs.xxx.yyy.p}



































































\begin{document}

\maketitle

\begin{abstract}
Given a polygonal curve , a pointset ,
and an ,
we study the problem of finding a polygonal curve 
whose vertices are from  and 
has a \Frechet distance less or equal to  to curve .
In this problem,  must visit every point in 
and we are allowed to reuse points of pointset in building .
First, we show that this problem in NP-Complete. 
Then, we present a polynomial time algorithm for 
a special cases of this problem, when 
 is a convex polygon.
\end{abstract}











\section {Introduction}

Geometric pattern matching and recognition has many applications in 
geographic information systems, computer aided design,
molecular biology, computer vision, traffic control, medical imaging etc.
Usually these patterns consist of line segments and polygonal curves. 
\Frechet metric is one of the most popular ways to measure the similarity of two curves. 
An intuitive way to illustrate the \Frechet distance is as follows.
Imagine a person walking his/her dog, where the person and the dog, 
each travels a pre-specified curve, from beginning to the end, 
without ever letting go off the leash or backtracking.
The \Frechet distance between the two curves is the minimal length of a leash which is necessary.
The leash length determines how similar the two curves are to each other:
a short leash means the curves are similar,
and a long leash means that the curves are different from each other.

Two problem instances naturally arise:  decision and optimization.
In the {\em decision problem}, one wants to decide whether two polygonal curves   and 
are within  \Frechet distance to each other, i.e., if a leash of given length  suffices.
In the {\em optimization problem}, one wants to determine the minimum such .
In~\cite{AltG95}, Alt and Godau gave an  algorithm for the decision problem,
where  is the total number of segments in the curves.
They also solved the corresponding optimization problem in  time.

In this paper, we address the following variant of the \Frechet distance problem.
Consider a point set  and a polygonal curve  in , 
for  being a fixed dimension.
The objective is to decide whether there exists a polygonal curve  within an  -\Frechet
distance to  such that the vertices of  are all chosen from the 
pointset . Curve  has to visit every point of 
and it can reuse points. We show that this problem is NP-Complete. 
We then present a polynomial time decision algorithm for a 
special case of the problem where the input curve  is a convex polygon. 

This paper is organized as follows: in Section \ref{sec:NPComp}, 
we establish our NP-Complete proof for the general case of the problem. 
In Section \ref{sec:SpecialCase}, 
we investigate the special case of the problem.
Finally, we conclude in Section \ref{sec:conc} with some open problems.

\section{General Case is NP-Complete}
\label{sec:NPComp}

\subsection{Preliminaries}
Given two curves ,
the {\em \Frechet distance\/} between  and  is defined as

where  and  range over all strictly monotone increasing continuous functions.
The following two observations are immediate.

\newtheorem{obs}{Observation}

\begin{obs}\label{obs:simple}
	Given four points , if
	 and , then
	. 
\end{obs}




\begin{obs}\label{obs:concat}
Let , , , and  
	be four curves 
	such that  and
	. 
	If the ending point of  (resp., ), 
	is the same as 
	the starting point of   (resp., ),
	then ,
	where  denotes the concatenation of two curves.
\end{obs}





\vspace{0.2 in}
\hspace{-0.2 in}{\bf Notations.}
We denote by , a polygonal curve 
with vertices  in order 
and by  and , we denote 
the starting and ending point of , respectively.
For a curve  and a point , by , 
we mean connecting  to point 
(we use the same notation  to show the concatenation of 
two curves  and ).
Let  denote the  midpoint of the line segment . 
For a point  in the plane, let  and 
denote the  and  coordinate of , respectively.


For two line segments  and , with ,
we denote the intersection point of them. 
Also, 
for a point  and a line segment ,
 denotes the point on  located 
on the perpendicular from  to . Also, 
 denotes the distance 
between  and segment .

\begin{definition} \label{def:feasible}
Given a pointset  in the plane, let 
be a set of polygonal curves  where: 
 

\end{definition}

\begin{definition} \label{def:feasibleNPC}
Given a pointset , a polygonal curve  and a distance , 
a polygonal curve  is called {\em feasible} if: 
 and .
\end{definition}

We show that the problem of deciding whether a 
feasible curve exists or not  is NP-complete.
It is easy to see that this problem is in NP, since 
one can polynomially check whether 
and also , using the algorithm in \cite{AltG95}.


\subsection{Reduction Algorithm}

We reduce in Algorithm~\ref{alg:reduction},
an instance of 3CNF-SAT formula  
to an instance of our problem.
The input is a boolean formula 
 with  clauses  and  variables  
and the output is a pointset ,
a polygonal curve  in the plane and 
a distance .

We construct the pointset  as follows.
For each clause , , in the formula , 
we place three points , refereed by  points, 
in the plane, which are computed
in the -th iteration of Algorithm \ref{alg:reduction} (from line \ref{l:makeSLoop} to line \ref{l:EndLoopPointSet}).
We define  to be .
By , , we denote
a square in the plane, centered at , 
with diagonal . 
We refer to , , as
{\em c-squares}. 
For an example of a pointset  corresponding to a formula, 
see Figure \ref{fig:pathAExample}.


Our reduction algorithm constructs the polygonal curve  
through  iterations. In  the -th iteration, ,
it builds a subcurve  corresponding to  a variable 
 in the formula  and appends that curve to .
In addition to those  subcurves, two curves 
 and  are appended to . 
We will later discus the reason we add those 
two curves to . 
Every subcurve   of  starts at point  
and ends at point .
Furthermore, every   goes through c-squares
 to  in order, enters each   from
the side   and exists that square from 
the side   (for an illustration, see Figure \ref{fig:pathAExample}). 
Curve  itself is built incrementally  
through iterations of the loop at line \ref{l:looptoMakeL} 
of Algorithm \ref{alg:reduction}. 
In the -th iteration, when  goes through ,
three points, which are within  , are added to   
(these three points are computed through lines 
\ref{l:makeclausestart} to \ref{l:makeclauseend}).
Next, before  reaches to ,
two points,  denoted by  and , are added to that curve 
(these two points are computed in lines \ref{l:alpha} 
and \ref{l:beta}).


Since each  corresponds to variable  in our approach, 
this is how we simulate  or  values of :
Consider a point object  
traversing , from starting point  to ending point . 
Consider 
another point object  which wants to 
walk from  to 
on a path whose vertices are from points in  and it wants to stay in distance one 
to . We will show that 
by our construction, object  has two options, either taking 
the path  or the path  
(See Figure \ref{fig:pathAExample} and \ref{fig:pathBExample} for an illustration). 
Choosing path  by  means  and choosing path  means .
We first prove in Lemma \ref{lemma:PathA} that  and 
in Lemma  \ref{lemma:PathB} that .
Furthermore, by
Lemma \ref{lemma:NoSwitchFromAtoB}, we prove that 
that as soon as  chooses 
the path  at point  to walk towards , 
it can not switch to any vertex on path .
In addition, in lemmas \ref{lemma:ABCanSeeC} and \ref{lemma:NOTABCanSeeC}, we prove that 
if  appears in the clause ,
 could visit point  via the path  and not . In contrast, 
when  appears in the clause ,
 could visit point  via the path  and not .
However, when both of   and  does not appear 
in ,  can not take 
or  to visit .









\begin{algorithm} 
\caption {{\sc Reduction Algorithm}} 
\label{alg:reduction}
\algsetup{indent=1.5em}
\begin{algorithmic}[1]
	\baselineskip=1.\baselineskip
	\REQUIRE  3SAT formula  with  clauses  and  variables 
	

	\vspace{0.1in}
		
	\hspace{-0.2in} {\bf Construct pointset :}  

	\STATE  \label{l:init}
	


 
	\STATE  \label{l:makeSStart}

	\FOR { to }   \label{l:makeSLoop}

	\STATE 
		 \STATE 
	

		\IF {( is odd)	}
	   
  
	\STATE , 

	\STATE       		\label{l:ComputeNextEven}
    
		\ELSE
	\STATE ,  
    
	\STATE       		\label{l:ComputeNextOdd}

  




	

	


	\ENDIF
	

  


\STATE 

    \STATE    \label{l:EndLoopPointSet}

	\ENDFOR






	\IF {( is odd)}  \label{l:ComputeV}
	  \STATE   
      \STATE   
		\ELSE
	   \STATE   
      \STATE   
	\ENDIF

	\STATE 
	\STATE 

    \STATE  \label{l:makeSEnd}



 	

\vspace{0.15in}

	\hspace{-0.25in} {\bf Construct polygonal curve :}  

	
	\STATE  \label{l:makeP}

		

	\STATE   


	\FOR {  to   }   \label{l:mainstart}

		\STATE   \label{l:startofL}

		\STATE   \STATE   \label{l:Adduh1toell}
		\FOR { to } \label{l:looptoMakeL}	

	

			\IF { ( and  is odd ) or ( and  is even ) } \label{l:makeclausestart}	
\STATE 
			\ELSIF {{ ( and  is odd ) or ( and  is even ) }}
\STATE 
			\ELSE		
			\STATE 
			\ENDIF \label{l:makeclauseend}


			\IF {}

			\STATE  \label{l:alpha}

			\STATE  \label{l:beta}
			
			\STATE 


			\ENDIF

		
		\ENDFOR
	
		\STATE  \label{l:subcurve}


		\STATE   
		\STATE  
		   
		
		

	\ENDFOR


	\vspace{0.05in}
\RETURN  pointset , polygonal curve  and distance 
	

\end{algorithmic}
\end{algorithm}












































\begin{lemma}\label{lemma:PathA}
Consider any subcurve , ,  
which is built through lines \ref{l:mainstart} to \ref{l:subcurve} 
of Algorithm \ref{alg:reduction}. Let  be the polygonal curve  . Then, .
\end{lemma}


\begin{proof}

We prove the lemma by induction on the number of segments along . 
Consider two point objects  and  
traversing  and , respectively (Figure \ref{fig:pathAExample} depicts an instance of  and ).
We show that  and  can walk
their respective curve, from the beginning to
 end, while keeping distance  to each other. 

The base case of induction trivially holds as follows 
(see Figure \ref{fig:PathAClause1} for an illustration):
Table \ref{tab:BaseCasePathA} lists  pairwise location of 
 and , where the distance of each pair is at most .
Hence,  can walk from  to  on the 
first segment of  (segment ), 
while keeping distance  to .


Assume inductively that  and  have feasibly walked along 
their respective curves, until  reached .
Then, as the induction step, 
we 
show that
 can walk to  and then to  
, while keeping distance  to .
Table \ref{tab:PathA} lists pairwise location 
of  and  such that  could reach  .
One can easily check that the distance between pair of points 
in that table is at most one.
 (For an illustration, see Figure \ref{fig:PathA}). 


\begin{table}[h]
\centering
\begin{tabular}{ r | l | l  }
  & location of  & location of   
 \\
\hline
   if   &  & \\
	&  & \\ 
	&  & \\ 

	&  &  \\





   if   &  &  \\
	&  &\\
	&  &\\
	& &\\
	&  &\\




   if   &  & \\
	&  & \\
	&  & \\

	& &\\
	& &\\
&  &  \\

\hline
	&   s.t.   & \\
	&  	 s.t.   & \\





\hline
if  &      & \\
&  & \\
&  & \\
&  &  \\
&   & \\




if  &  			  & \\
 &  &  \\
 &  &  \\
 &   &  \\






if  &  	  & \\
&  & \\
 & &  \\
 & &  \\
&   &  \\





\hline

	&   s.t.   & \\
	&  	 s.t.   & \\
\hline









 if   &  &  \\
   if   &  & \\
   if   &  & \\

\end{tabular}
\caption{Distance between pair of points is less or equal to one}
\label{tab:PathA}
\end{table}





Finally, if  is an odd number, then  
 is the last segment along , otherwise, 
 is the last one. In any case, 
that edge crosses  the circle , where  is the last vertex of 
 before  (point  is computed in line \ref{l:ComputeV} of 
Algorithm \ref{alg:reduction}). Therefore, 
  can walk to , while keeping distance  to . 


\qed
\end{proof}





\begin{figure}[t]
	\centering
	\includegraphics[width=0.8\columnwidth]{samplePathA}
	\caption{Assume that formula  has four clauses  and , 
where the occurrence of variable   in those clauses is:
, ,  and .  
For each clause , the reduction algorithm places three point  and  in the plane. Blue curve is an example of curve  which corresponds to variable  in . Red curve is curve . 
 }
	\label{fig:pathAExample}
\end{figure}




\begin{lemma}\label{lemma:PathB}
Consider any subcurve , ,  
constructed through lines \ref{l:mainstart} to \ref{l:subcurve} 
of Algorithm \ref{alg:reduction}. Let  be the polygonal curve  . Then, .
\end{lemma}

\begin{proof}
The proof is analogous to the proof of Lemma \ref{lemma:PathA}, see appendix.
\end{proof}





	



\begin{lemma}\label{lemma:NoSwitchFromAtoB}
Consider any curve , , and 
a point object  walking from  to  on . 
Also, imagine two point objects  and 
, walking on curves  and  
(from Lemmas \ref{lemma:PathA} and \ref{lemma:PathB}), respectively
while keeping distance  to . Then,
if  switches to path  or  switches to path , 
they loose distance  to .
\REM{
take any path to a vertex on  and 
stay in distance 1 to . Similarly, 
 can not take any path to a vertex on  and 
stay in distance 1 to .}
\end{lemma}

\begin{proof}
See Appendix.
\end{proof}









For , 
if  is an odd number, set  
and   and
if  is an even number, 
set  
and .




\begin{lemma}\label{lemma:ABCanSeeC}
Consider the curve  from Lemma \ref{lemma:PathA}. Let 
 be a subcurve of  which starts at  and ends at , .
Furthermore, let  be a subcurve of  which starts at  and ends at .
For any curve  , ,
if , 
. 
Similarly, consider the curve  from Lemma \ref{lemma:PathB}. Let 
 be a subcurve of  which starts at  and ends at , .
Furthermore, let  be a subcurve of  which starts at  and ends at .
For any curve  , ,
if ,   
. 

\end{lemma}

\begin{proof}
When  appears in clause , point  is 
a vertex of . 
Since  and  is the  midpoint of 
 ,
 can wait at  while  visits 
When  appears in clause , point  is 
a vertex of . 
Since  and  is the  midpoint of 
 ,
 can wait at  while  visits 
and comes back to 
\end{proof}



\begin{lemma}\label{lemma:NOTABCanSeeC}
Consider curve  (respectively, ).
For any curve , ,
if  and ,   
then  (resp., ) can not be modified to visit .
\end{lemma}
\begin{proof}
This is because 
and .
\end{proof}









\vspace{0.5 in}

\begin{theorem}
Given a formula  with  clauses  and  variables ,
as input let curve  and pointset  be the output of Algorithm \ref{alg:reduction}. 
Then,  is satisfiable iff a 
curve  exists such that 
.
\end{theorem}

\begin{proof}


For : 
Assume that  formula  is satisfied. 
In Algorithm \ref{alg:buildQ}, we show that 
knowing the truth value of the literals in , 
we can build a curve  which 
visits every point in  and .



\begin{algorithm} [h]
\caption {{\sc Build a feasible curve  }} 
\label{alg:buildQ}
\algsetup{indent=1.5em}
\begin{algorithmic}[1]	
		\baselineskip=0.9\baselineskip
	\REQUIRE  Truth table of variables  in 

	\STATE 
	\STATE  \label{l:startPoint}
	 
	\FOR { to }   
	\IF {}
	\STATE 
	\FORALL { clauses, if  }
	\STATE let  be  subcurve of  from 	 to 
	\STATE let  be  subcurve of  from 	 to 
	\STATE   \label{l:visitCone}
	\ENDFOR
	\STATE  \label{l:x1}
	\ELSE 	
	\STATE 
	\FORALL { clauses, if  }
	\STATE let  be  subcurve of  from 	 to 
	\STATE let  be  subcurve of  from 	 to 
	\STATE  \label{l:visitCzero}
	\ENDFOR
	\STATE  \label{l:x0}

	\ENDIF
	\STATE 



	\ENDFOR
	\STATE \label{l:nplusone}
	\STATE 

	\STATE \label{l:nplustwo}
	\STATE   \label{l:endPoint}

	\STATE {\bf return} {\sc Q}  
\end{algorithmic}
\end{algorithm}






First we show , where 
is the output curve of Algorithm \ref{alg:buildQ}.
Recall that by Algorithm \ref{alg:reduction}, 
curve  includes  subcurves  each corresponds 
to a variable . 
Both 
curves  and  start and end at a same point .
For each curve  which is appended to  
in the -th iteration of Algorithm \ref{alg:buildQ} 
(line \ref{l:x1} or line \ref{l:x0}), 
  by Lemma \ref{lemma:ABCanSeeC}. 
Notice that  also includes two additional subcurves  and  whereas there is no variable  and  in formula . These two curves are to resolve two special cases: 
when all variables  are 1,  no  appears in ,
and when all variables  are 0,  no  appears in .
Because of these two curves, 
we add two additional curves in line \ref{l:nplusone}
and \ref{l:nplustwo} to . Finally, by  Observation 
\ref{obs:concat}, .

Next, we show that curve  visits every point in . First of 
all, by the curves added to  
in line \ref{l:nplusone} and \ref{l:nplustwo}, 
all  and , , in  will be visited. 
It is sufficient to show that  will visit all  points in   as well.
Since  formula  is satisfied, every clause  in  must be satisfied 
too. Fix clause . At least one of the literals in 
must have a truth value . If  and , 
then by line \ref{l:visitCone}, curve  visits .
On the other hand, if  and , 
by line \ref{l:visitCzero}, curve  visits . We conclude that 
curve  is feasible.
 

Now we prove the  part:

Let  be a feasible curve with respect to  and pointset .
Notice that curve  consists of  subcurve , 
, each corresponds to one variable . 
From the configuration of each  in c-squares, 
one can easily construct formula  with 
all of its clauses and literals. 


 
Imagine two point objects  
and  walk on  and  respectively. 
We find the truth value of variable  in the formula
by looking at the path that  takes to stay in -\Frechet distance to , 
when  walks on curve  corresponding to .
If  takes path  from Lemma \ref{lemma:PathA} 
while  is walking on  , then ; 
whereas If  takes path  from Lemma \ref{lemma:PathB} 
while  is walking on  , then . 
Object  decides between path  or , 
, when both  and  are at point . 
Lemma \ref{lemma:NoSwitchFromAtoB} ensures that  
once they start walking, 
 can not change its path from  to  
or from  to . 
Therefore, the truth value of a variable  is consistent.


The only thing left to show is the reason that formula  is satisfiable. 
It is sufficient to show every clause of  is satisfiable. 
Consider any clause .
Since curve  is feasible, 
it uses every point in .  
Assume w.l.o.g. that  visits  
when  is walking along curve .  
By Lemmas 
\ref{lemma:NoSwitchFromAtoB} and \ref{lemma:ABCanSeeC},
this only happens when either ( appears in  and )
or ( appears in  and ). 
Therefore,  is satisfiable.












 

The last ingredient of the NP-completeness proof is
to show that the reduction takes polynomial time.  
One can easily see that Algorithm \ref{alg:reduction}
has running time , 
where  is the number of variables in 
the input formula with  clauses.






\end{proof}







To show the correctness of above lemmas, we have implemented our reduction 
algorithm.  We test our algorithm on a 
formula  with four clauses.  
This enables us to check all possible 
configurations of  in Algorithm \ref{alg:reduction}. 
The program generates three sets, a pointset 
, 
a curve set  and a curve set  as follows.

Imagine a polygonal curve which starts from point , 
goes through points in  and ends at . Our 
program generates all possible such curves and keep them in set .
Therefore,  contains almost 1,000,000,000
curves.

\REM{
Each curve  in  is built as follows:

\begin{table}[h]
\centering
\begin{tabular}{ l | c }
  permutations & curves
 \\
\hline
  = all size one permutations of points in  & \\ 
  = all size two permutations of points in   & \\
  = all size three permutations of points in   & \\
		...&...\\
 = all size twelve permutations of points in  &  \\
\end{tabular}
\vspace{0.2 in}
\end{table}




Therefore, the number of curves in  is:
}


Another set  includes all different configuration of curve  
which corresponds to variable  in the formula.
Since  or  or none could appear in one clause 
and the formula has four clauses, the set  contains 81 different curves.


In our application, we compute \Frechet distance between every curve in  and every curve in  . 
The results show that all the curves in 
have \Frechet distance greater than  to curves 
in  except two curves 
and . In other words,  
for only 162 pairs of curves, we got:

   and
   

In addition to above tests, we verified the correctness of 
Lemma \ref{lemma:ABCanSeeC} in different cases. 








\newcommand{\bounC}[1]{{\sigma(\Pol,{#1})}}
\section {Convex Polygon Case}
\label{sec:SpecialCase}

In this section, we address the following problem:
given a convex polygon  and a pointset  in
the plane, 
find a polygonal curve  whose vertices are from ,
and the \Frechet distance between 
and a boundary curve of  is minimum.
Note that each point of  must be used in  and it  
can be used more than once. 
In the decision version of the problem,
we want to decide if there is a polygonal curve  through all points in  
, 
whose \Frechet distance to a polygon's boundary curve 
is at most , for a given . 





\subsection{Preliminaries}
\label{subsec:preliminaries}

We borrow some notations 
from \cite{cccg11}
as we make use of the algorithm in that paper
to solve the decision version of our problem.
For any point  in the plane,
we define 
to be a \emph{ball} of radius  centered at ,
where  denotes  Euclidean distance.
Given a line segment ,
we define 
to be a \emph{cylinder} of radius~ around .

In this section, whenever we say polygon, we mean 
a convex polygon. Also, when we 
say a curve visits a point , we mean that 
 is a vertex of the curve.
We denote by  the convex hull of pointset .

For an interval  of points in  ,
we denote by  and 
the first and the last point of  along , respectively.
Given two points  and  in , 
we say  is {\em before\/} , and denote it by  when
 is located before  on .
Moreover, 
we say  is entirely before  (or  is entirely after ) 
and denote it by , when  is located before  on .

\REM{
Consider two points 
and , . 
We say  is reachable from  (or  can reach  ), 
if a semi-feasible curve  exists 
which ends at point  and visits .
Furthermore, we say point  can directly reach  ,
if  is a reachable point and 
reaches   via edge .
We call an  edge  between points  and , 
 a {\em forward edge} when
 and  are in  and 
( or ). In addition, 
if  
and , , 
and point  reaches  via edge , 
then we call that edge a forward edge too.
We call an  edge , a {\em backward edge} if  and  are both in  and 
. 

Let  and 
 denote the start and end point of polygonal chain 
.
}















\vspace{0.3 in}

\hspace{-0.2 in}{\bf The Decision Algorithm in \cite{cccg11} }
Given a polygonal curve  of size  (with 
starting point  and ending point ), 
a pointset  of size 
and a distance , 
the algorithm in that paper decides in  time,
whether there exists a polygonal curve through some points 
in  in -\Frechet distance to 
. 

Curve  is composed of  
line segments . 
For each segment ,
 denotes the cylinder ,
and  denotes the set .
Furthermore, for each point ,
  denotes the line segment  \cite{cccg11}.
A polygonal curve  is called \emph{semi-feasible} if all its vertices are from  and 
 for a subcurve   starting at .
A point  is called \emph{reachable}, at cylinder ,
if there is a semi-feasible curve ending at  in .


Following is a brief outline of how the decision 
algorithm in \cite{cccg11} works: 
it processes the cylinders one by one from 
 to , and identifies at each cylinder 
all points of  which are reachable at .
The reachable points for each cylinder ,  from 1 to , is maintained in a set
called {\em reachability set}, denoted by .
In the -th iteration of the algorithm,
first all points in 
which are reachable through a point in a set 
, for , are added to  .
These points are called the \emph{entry points} of cylinder . 
We denote, by , the leftmost 
entry point of cylinder , which 
at this step, equal to .
Next,  all points in 
which are reachable through 
are added to .
Finally, the decision algorithm 
returns YES , if  
.





















 




\begin{figure}[t]
	\centering
	\includegraphics[width=0.6\columnwidth]{definition}
	\caption{A problem instance}
	\label{fig:types}
\end{figure}


\subsection {Decision Algorithm}\label{subsec:decAlg}


Let  be a convex polygon of size , 
 be a pointset of size  and  be an input distance. 
For , we call a curve, {\em a boundary curve} of , denote it by ,
if it starts from point  on the boundary of , 
goes around the polygon on the boundary once and ends at 
.



\begin{definition} \label{def:feasible}
Given a pointset , a convex polygon  and a distance ,  
a polygonal curve ,
is called {\em feasible} if 
 and a boundary curve  exists such that 
.
\end{definition}


As the first step of our algorithm, 
we execute the decision algorithm in \cite{cccg11}. 
Note that here as opposed to in \cite{cccg11}, 
the starting and ending point of 
the curve is unclear because the input is a convex polygon.
Which point on the boundary we choose?
The following lemma justifies our choice later:



\begin{lemma} \label{lema:convexhull}
Given a convex polygon , a pointset  and a distance ,
a necessary condition to have a feasible 
curve through  is: 
, 
where  is a vertex of  and  is a point on the boundary of  s.t. .
\end{lemma}




\begin{proof}
See Appendix.
\end{proof}






Let  be the point with 
smallest -coordinate in 
and  be a point on the boundary of 
s.t.   . Furthermore, 
let  (curve  has  line segments
) 
Run the decision algorithm in \cite{cccg11}, 
with parameters  and .
Result is the reachability sets 
 where each  maintains the reachable points at cylinder . 



















\begin{definition}
\label{def:Types}

Consider  two consecutive reachability 
sets   and , .
Let  be a point in . Then, we call 
a  point at  if  there exists a semi-feasible
curve which contains  as its vertex
and ends at .
Otherwise, we call  a  point at  
and we call  the rival of . 
\end{definition}


\begin{obs} \label{obs:orderABC}
Let  and  be  and   points at cylinder , 
respectively. Then, .
\end{obs}

\begin{obs}
A  point  at cylinder  is:
\begin{itemize}
\item a  point at  : when  
doesn't reach to  but it reaches to 
some other point  in  
(see Figure \ref{fig:types}a). 

\item a  point at ,
when  does not reach to 
any point in , 
but it reaches to a point in ,
 (see Figure \ref{fig:types}b).

\item a  point at ,
when  does not reach to 
any point in ,  (see Figure \ref{fig:types}c).

\end{itemize}

\end{obs}

\begin{figure}[t]
	\centering
	\includegraphics[width=0.9\columnwidth]{RedYellow}
	\caption{(a) Point  is a  point at  
(b) Point  is a  point at  (c) Point  is a  point at .}
	\label{fig:types}
\end{figure}


After running the algorithm in \cite{cccg11},
we process the reachability sets , one by one in order, 
and we identify the types of the points for every point in each set. 
Notice that a point  may be located in 
multiple cylinders, so it might be reachable 
at more that one cylinder and thus
be in more than one reachability set.





































\newcommand{\TwiceB}{Twice-TypeB}
\newcommand{\Upper}{\pi}
\newcommand{\Lower}{\mu}



































\newcommand{\Rival}{Rival}

Let  and  be the upper 
and the lower chain of , respectively.  
Let Tube() be the union of all , 
where  is an edge of , .
Tube() and Tube() are defined, analogously.


\begin{definition}
We call a point a  \TwiceB ~point, 
if it is of  at two cylinders.
\end{definition}

\begin{definition}

We call a connected area within Tube(),
shared between two cylinders, one corresponding 
to an edge in  and another corresponding to 
an edge in , a \DoubleB~area, 
if it contains a \TwiceB ~point. 
\end{definition}


\begin{lemma}\label{lemma:twice}
Given a polygon , a pointset  
and , at most two \DoubleB~areas  exists.  
\end{lemma}

\begin{proof}

Assume w.l.o.g. that  is stretched horizontally (see Figure \ref{fig:twice})(In the case that  is vertically stretched, decompose 
it into right and left chains and the rest of 
argument is the same as here).  


Assume for the sake of contradiction,
that there are three such areas and 
a point  is a \TwiceB ~point located in the middle one.
(see Figure \ref{fig:twice}). 
Let  and  be the rivals of  in the upper 
and lower chain of , respectively. 
Assume w.l.o.g. that  and 
are located in two consecutive cylinders (within Tube()) which 
share . 
Similarly, assume w.l.o.g. that  and 
are located in two consecutive cylinders (within Tube()) which 
share .
Since  is a  point and  is the rival of , 
edge  does not cross circle . 
Because of the same reason, edge  does not cross circle . 
This implies that, vertices of  to the right of  has 
a -coordinate less than  and vertices before   
has a -coordinate greater than , meaning that 
has the lowest  coordinate among vertices of .
Therefore, no \DoubleB~area exists to the right of the 
area in which  is located, a contradiction.






\REM{
To prove the lemma, we first investigate a situation where 
a point is in more than one reachability sets and then from there, we establish
the lemma.


If  is in  and , 
then it is  point at .
Let  be a vertex of the polygon and  be 
the circle shared between  and . 

 

One of these two cases may happen here: (i) point  lies in
 (see Figure \ref{fig:twice}a), 
then obviously  is a  point at 
(ii)  point  doesn't lie in
 (see Figure \ref{fig:twice}b), we show 
that although  could not 
cross , 
but still  is a  point at :

Assume for the sake of contradiction, that 
 is  point at .
Thus, by the definition of  points, 
no semi-feasible 
curve exists which contains  as its vertex
and ends at .
Therefore, since , 
it must be located entirely after 
 in 
(for example, in Figure \ref{fig:twice}b,  
can be located at the place where  is). This contradicts 
the fact that  is in (or located within ).
}
\end{proof}



\begin{figure}[t]
	\centering
	\includegraphics[width=1\columnwidth]{H3}
	\caption{Proof of Lemma \ref{lemma:twice}}
	\label{fig:twice}
\end{figure}










\begin{lemma} \label{lemma:last}
There exists a feasible curve iff Algorithm \ref{alg:dec} returns
YES.
\end{lemma}
\begin{proof}
First  :
It is easy to observe that 
conditions in lines  
\ref{l:everyReach},
\ref{l:last},
\ref{l:B3} are necessary
to have a feasible curve 
through .
It suffices to show for the curve 
 built by Algorithm \ref{alg:dec}, .

We show this by induction on the 
number of edges in .
To handle the base case of the induction, assume that 
 has an additional edge consist 
of only point .
Imagine a point object 
walking on the boundary of , starting from 
point  and imagine another point object 
walking on curve  starting from  while 
keeping distance  to  .
Since distance  and  is less 
than  at the start,
the base case of the induction holds. 

We show  can walk the whole  
and ends at .
Assume inductively that in the loop in line \ref{l:forCyl},
we have processed  to  , 
and now we are about to process .
So every point in  is in 
 and  can walk to a point 
in  in  distance to .
Let  be the leftmost point at   such that 
.
If , by Observation \ref{obs:concat}, 
we can add  every point in  to  
and  can proceed to . Otherwise;
	since  is a reachable point, a point 
	 must exist in ,  such that 
	 reach . Assume that 
	 is after all points in direction 
	which can reach to .
	It suffices to show point  is a vertex of , 
	so that in line \ref{l:rightmost}, by reaching to , 
	the algorithm stops removing vertices in 
	and connects  to .
	Two cases happen here: 
     (i) , and  some points in  are 
	 and some are  points.
    Then,  points are removed 
	from  (because they can not reach  by definition), 
	and  will be connected to	 (see Figure \ref{fig:skipped}).
	Therefore,  can walk to the next edge on . 
     (ii) When , , then observe that because of 
the convexity of the polygon,  reach
points in  which can not reach ,  (see Figure \ref{fig:skipped}). 
Therefore,  is a vertex in . 

Now we show that curve  can be modified such 
that it visits every \TwiceB ~point when  walks on 
(with the same argument, curve  can be modified to 
visit all such points when  walks on ).
Let's call \DoubleB~areas, area I and area II.
Let  be the first  point in 
direction  at area I. 
Assume w.l.o.g. that  is in .
Let  be a point after all points in direction 
which can reach .
Because of the convexity of polygon,
point  reaches . 
It is clear that as soon as   reaches , 
it can visit all  points 
at  in sorted  order. 
Let  be the leftmost point 
in  which the last 
  point at  can reach. 
If  is a vertex of , then
 now has all  \TwiceB ~points at area I.
When  is not a vertex of ,
because of the convexity of the polygon, 
still  can be connected to a 
vertex of  which is reachable from . 
Therefore, one can modify curve 
to visit \TwiceB ~points.






:
Let  be a feasible curve through .
Assume that there is  no \TwiceB ~point
among points in . Let  be any point in .
Then, by Lemma \ref{lemma:twice}, if 
 lies in both  and
, then it can be  only 
with respect to one of  or .
Assume w.l.o.g, that  is a  point in the 
upper chain. Therefore,  is a  point in the 
lower chain and  it will be visited by 
. Now, if  there are some \TwiceB ~points in ,
it is easy to show that   will be visited  by one of 
 or  curves in our algorithm.





\REM{
\ref{}   and 
walk along their path, keeping distance 
to each other, until 
  reaches to vertex  in 
and  reaches to point  on the boundary of 
where .
}



\REM{
we can construct a feasible curve:
Lemma \ref{lemma:twice} ensures if a point 
which is  in the upper chain, 
can not be    again in the lower chain
and vice versa, a point 
which is  in the lower chain, 
can not be    again in the upper chain;
unless it is located within  area.

Therefore, we start from point , process 
cylinders one by one and visit all  
points in each cylinder. If we encounter a  point, 
we ignore it, because that point will become  point
later and we can visit it. 
Let  and  denote 
\DoubleB areas.
Now, to take care of \TwiceB ~points, 
build these two curves :
\begin{itemize}
\item : when walking on , ignore rival of  in 
and  and visit those  points. 
\item : when walking on , ignore rival of  in 
and  and visit those  points.
\end{itemize}

Return YES, if any of  or  visits every point in ;
otherwise, return NO. 
}
\end{proof}






\begin{figure}[t]
\centering
	\includegraphics[width=0.8 \textwidth]{skipped2}	
	\caption{Proof of Lemma \ref{lemma:last}, points in the 
shaded area can not reach the leftmost entry point of
the next non-empty cylinder }	
	\label{fig:skipped}
\end{figure}





\begin{algorithm} [h]
\caption {{\sc Decision Algorithm }} 
\label{alg:dec}
\algsetup{indent=1.5em}
\begin{algorithmic}[1]	
		\baselineskip=0.9\baselineskip

	\vspace{0.3em}
	\REQUIRE  A convex polygonal , pointset  and distance 

\STATE let  be the point with 
smallest -coordinate in 
\STATE let  be a point on the boundary of 
s.t.   

\STATE let  (curve  has  line segments) 

\vspace{0.1 in}
	\STATE run the decision algorithm in \cite{cccg11}, 
	with parameters  and 
	\STATE {\bf return} {\sc no} if a point in  
is not in any ,   \label{l:everyReach}

	\STATE {\bf return} {\sc no} if  \label{l:last}
	\STATE process reachability sets from  to  in order, \\to identify types of points in each  \label{l:identifytypes}
	\STATE {\bf return} {\sc no} if a point exists of type   \\ in every cylinder at which that point is reachable  \label{l:B3}

\label{l:typeB}


	
\vspace{0.2 in}
\STATE   \label{l:init1}
	\STATE   \label{l:init1}
 	\FOR { to  } \label{l:forCyl}	
			\STATE let  be a leftmost point at   s.t.    \label{l:leftmost}	
	\IF { }	 \label{l:con}	
			\STATE remove  until a vertex  of  is found s.t.  \label{l:rightmost} \\
	\ENDIF
	\STATE 
 
(every point in  in sorted  order)



	\ENDFOR



	\IF {a \TwiceB ~point exists}
	\STATE  modify  s.t. it visits those points in  \label{l:lasttwo1}
	\STATE  modify  s.t. it visits those points in 
\label{l:lasttwo2}
	\ENDIF
	\STATE {\bf return} {\sc YES} if  or  or  include all points in 

\end{algorithmic}
\end{algorithm}

























\REM{
\hspace{-0.2 in}{\bf Time Complexity}


\begin{lemma}\label{lema:time}
Given a convex polygon  of size , a pointset  of size  
and a distance ,
Algorithm \ref{alg:Dec} decides in  time if a curve 
 exists in -\Frechet distance to boundary curve , 
visiting every point in , 
when  is allowed to cycle the polygon two times.
\end{lemma}


\begin{proof}

Line \ref{l:cccg11} of Algorithm \ref{alg:Dec} takes  time to execute by \cite{cccg11}. We  show that identifying 
,  and  points at each 
cylinder, take the same total time. 

Consider  two consecutive non-empty 
reachability sets   and , .
Let  be a point in  
and  be a point in .
Note that  reaches  in three possible ways:
(i) directly through edge , 
(ii) through one point: , where
 and 
or
, where
 and 
(iii) through two points: 
,
where , , 
and .


It's easy to find out if a point is of  at .
To find out the types of other points at , 
we proceed as follows:
we first sort points of 
 in  order and 
also sort points of  
 in  order. 
For each point 
we find set of points in  
to which  directly reaches.
Among the points in , we find 
the last one, say , 
that can reach   directly.
Any point before 
and  points after  (not entirely after) are of  at .

Let  be the set of point of  located entirely after .  Assume  is the last point in 
which can reach  some point , which is 
located entirely after   in .
For a point , 
if  or  or ,
then  is of  at . 


 \qed


\end{proof}



}



\begin{theorem} \label{thm:main}
	Given a convex polygon  with  edges and a set  of  points, 
	we can decide in  time whether there is feasible curve  through  
	for a given . Furthermore, a feasible curve  which minimizing the 
\Frechet distance to the boundary curve of , can be computed in  time.

\end{theorem}



\section{Conclusions}
\label{sec:conc}
In this paper, we investigate the problem of 
 deciding whether a polygonal curve through a given point set
 exists which is in -\Frechet distance 
to a given curve . We showed that this problem
is NP-Complete. Also, we presented a polynomial 
time algorithm for the special case of the 
problem, when a given curve is a convex polygon. 

Several open problems arise from our work.
From our first result, 
one could investigate some heuristic methods or 
approximation algorithms.
From the second part, in particular, it is interesting 
to study the  problem in the case 
where the input is a monotone polygon, a simple polygon
or a special type of curve.






















\nocite{Simpson}



\begin{thebibliography}{50}
\bibitem{AltG95}
H.~Alt and M.~Godau.
\newblock Computing the {Fr{\'e}chet} distance between two polygonal curves.
\newblock {\em Int. J. of Comput. Geom. Appl.}, 5:75--91, 1995.


\bibitem{cccg11}
A.~Maheshwari, J.~Sack, K.~Shahbaz, and H.~Zarrabi-Zadeh.
\newblock {Staying close to a curve}
\newblock In {\em Proc. 23rd Canadian Conference on Computational Geometry}, pages 170--173,
  2011.

\end{thebibliography}


\clearpage
\appendix








\begin{figure}[t]
	\centering
	\includegraphics[width=0.9\columnwidth]{samplePathB}
	\caption{Red curve is curve . Blue curve is an example of curve  which corresponds to variable  in 
	 formula  with four clauses  and . The occurrence of variable   in the clauses is: 
, ,  and .
}
	\label{fig:pathBExample}
\end{figure}



	

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\columnwidth]{PathAC1}
	\caption{Base case of induction in the proof of Lemma \ref{lemma:PathA}}
	\label{fig:PathAClause1}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.9\columnwidth]{parallelogramForPathA}
	\caption{Proof of Lemma \ref{lemma:PathA}}
	\label{fig:PathA}
\end{figure}
	




\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\columnwidth]{PathBC1}
	\caption{Base case of induction in the proof of Lemma \ref{lemma:PathB} }
	\label{fig:PathBBaseCase}
\end{figure}



\begin{figure}

	\centering
	\includegraphics[width=0.9\columnwidth]{parallelogramForPathB}
	\caption{Proof of Lemma \ref{lemma:PathB}}
	\label{fig:PathB}
\end{figure}

\noindent {\bf  Proof of Lemma \ref{lemma:PathB}}:
\begin{proof}
Consider two point objects  and  
traversing  and , respectively (Figure \ref{fig:pathBExample} depicts an instance of  and ).
To prove the lemma, we show that  and  can walk
their respective curves, from beginning to
the end, while keeping distance  to each other
. 

The base case of induction holds as follows 
(see Figure \ref{fig:PathBBaseCase} for an illustration):
Table \ref{tab:BaseCasePathB} lists  pairwise location of 
 and , where the distance of each pair is less or equal to .
Therefore,  can walk from  to  while
keep distance one to .

\begin{table}[h]
\centering
\begin{tabular}{ r | l | l  }
if    & location of  & location of   
 \\
\hline
    
&   &   \\
&  				  s.t.   & \\

				&     &    \\
&  				 			       &   \\
&     &   \\
&  				 		      &     \\
&   & 	      \\

\hline
if  
&   &   \\
&  				  s.t.   & \\
&  &  \\
&  &  \\
&  &  \\
&  &  \\

\hline
if  &  &   \\
&  				  s.t.   & \\
&  &  \\
&  &  \\
&  &  \\
&  &  \\
&   & 	      \\

\end{tabular}
\vspace{0.2 in}
\caption{Pairwise location of  and , to prove the base case of induction in Lemma \ref{lemma:PathB} }
\label{tab:BaseCasePathB}
\end{table}





Assume inductively that  and  have feasibly walked along 
their respective curves, until  reached .
Then, as the induction step, 
we 
show that
 can walk to  and then to  
, while keeping distance  to .
This is shown in Table \ref{tab:PathB}
 (see Figure \ref{fig:PathB} for an illustration). 


\begin{table}[h]
\centering
\begin{tabular}{ r | l | l  }
  & location of  & location of   
 \\
\hline
   if   &  &  \\
   if   &  & \\
   if   &  & \\

\hline
	&   s.t.   & \\
	&  	 s.t.   & \\

\hline
if  &  				   & \\
&  & \\
&  & \\

&   &  \\
&  & 
 \\




if  &  				   & \\

 &  &  \\
 &  &  \\


 &   &  \\






if  &  				   & \\
&  & \\
 & &  \\
 & &  \\
&   &  \\


\hline

	&   s.t.   & \\
	&  	 s.t.   & \\
\hline




if  &  		 		   & \\

 &  &  \\
 &  &  \\


 &   &  \\






if  &  				 		   &      \\
 &  &  \\
 &  &  \\


 &    &  \\







if  &  				
 		   &     \\
&  & \\
 & &  \\
 & &  \\
&   &  \\


\end{tabular}
\caption{Distance between pair of points is less or equal to one}
\label{tab:PathB}
\end{table}



Finally, if  is an odd number, then  
 is the last segment along , otherwise, 
 is the last one. In any case, 
that edge crosses  circle , where  is the last vertex of 
 before  (point  is computed after the condition checking 
in line \ref{l:ComputeV} of 
Algorithm \ref{alg:reduction}). Therefore, 
  can walk to , while keeping distance  to . 


\qed
\end{proof}




\noindent {\bf  Proof of Lemma \ref{lemma:NoSwitchFromAtoB}}:
\begin{proof}
Notice that we have placed  points far enough from 
 points so that 
no curve can go to 
and come back to  and stay 
in -\Frechet distance to .
Therefore, to prove the lemma, 
we only focus on two consecutive c-squares.
We show that no subcurve  exists such 
that (for an illustration, see Figure \ref{fig:noswitch}) :


\begin{itemize}

\item  because:

\

for all , , point  is always a vertex of . 
A point on  in distance 1 
to  lies before  
in direction , 
while a point on  in distance 1 
to point  lies after  in direction .
Since , 
no subcurve  exists such that 
.


\

\item  or , because:

\

For all , , 
is a vertex of . 
A point on  in distance 1 
to  lies before  
in direction , 
while a point on  in distance 1 
to point  lies after  in direction .
Since  and 
,
no subcurve  exists such that 
.
Similarly,  no subcurve  exists such that 
.

\

\item  or   because:

\

Vertex  of 
guarantees the first part as , 
and vertex  of 
guarantees the second part, 
as .

\

\item ,  because 

\

\item , because  

\

\item  , because  

\

\item  , because  

\

\item  , because  
\end{itemize}

\end{proof}



\begin{figure}
	\centering
	\includegraphics[width=0.9\columnwidth]{NoSwitch}
	\caption{Proof of Lemma \ref{lemma:NoSwitchFromAtoB}}
	\label{fig:noswitch}
\end{figure}





\begin{table}[h]
\centering
\begin{tabular}{ r | l | l  }
if    & location of  & location of   
 \\
\hline
    
&   &   \\
&  				  s.t.   & \\

&   & 	      \\

\hline
if  
&   &   \\
&  				  s.t.   & \\

&  &  \\

\hline
if  &  &   \\
&  				  s.t.   & \\
&  &  \\

\end{tabular}
\vspace{0.2 in}
\caption{Proof of Lemma \ref{lemma:PathA}, the base case of induction}
\label{tab:BaseCasePathA}
\end{table}







\noindent {\bf  Proof of Lemma \ref{lema:convexhull}}:


\begin{proof}
We prove the lemma by induction on the number of 
edges in . 
Let   be the edges of , numbered 
after an arbitrary vertex of  in clockwise order. 
Obviously, to have a feasible curve, 
every point of  must be located within some cylinder .
To establish the lemma, we show that when a feasible curve
exists through , the condition holds. 

Imagine a point object
 which cycles , 
starting from a vertex of 
, say point , and ending at the same point.
Let  be a point on the boundary of  such that 
.
Imagine another point object   
which starts from , 
walks on the boundary of  until it reaches the same point .
Both of the objects walk clockwise. 

To handle the base case of the induction, assume that 
the convex hull has an additional edge consist 
of only  point . Since the distance between
 and  is less 
than  at the start,
the base case of the induction holds. 
Assume inductively that   and 
walk along their path, keeping distance 
to each other, until 
  reaches to vertex  in 
and  reaches to point  on the boundary of 
where .

Let  be the next  vertex  on 
after . If  is located within the same 
cylinder  as , 
then by Observation \ref{obs:concat}, the lemma holds. 
Otherwise, assume that 
 is in ,  and 
 is a point in  where . 
Consider the -ball around each of the vertices of 
the polygon between points  and . 
It suffices to show that edge  crosses 
each of those balls.


Assume, for the sake of contradiction, that edge  
does not cross one of those balls, say the one around 
vertex . 
Assume w.l.o.g. that all points 
in  lie to the right of .
Then, two cases occur as illustrated in Figure \ref{fig:convexHull}: 
case (a), where  lies to the right of , which contradict 
the fact that the polygon is convex;
or case (b), where  lies to the left of , which contradicts 
our assumption that a feasible curve exists, 
because
no point in  is in -distance to vertex .
\qed
\end{proof}



\begin{figure}{t}
	\centering
	\includegraphics[width=0.9\columnwidth]{mainL1}
	\caption{Proof of Lemma \ref{lema:convexhull}}
	\label{fig:convexHull}
\end{figure}


\end{document}
