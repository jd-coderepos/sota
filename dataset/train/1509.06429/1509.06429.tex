\pdfoutput = 1
\documentclass[12pt, a4paper,  oneside, headinclude,footinclude, BCOR5mm]{scrartcl}

\usepackage[
nochapters, beramono, eulermath,pdfspacing, dottedtoc ]{classicthesis} 

\usepackage{bussproofs} 

\usepackage{arsclassica} 

\usepackage[T1]{fontenc} 

\usepackage[utf8]{inputenc} 

\usepackage{graphicx} \graphicspath{{Figures/}} 

\usepackage{enumitem} 

\usepackage{lipsum} 

\usepackage{subfig} 

\usepackage{amsmath,amssymb,amsthm} 

\usepackage{varioref} 

\usepackage{tikz}

\newenvironment{bprooftree}
  {\leavevmode\hbox\bgroup}
  {\DisplayProof\egroup}

\def\SPSB#1#2{\rlap{\textsuperscript{{#1}}}\SB{#2}}
\def\SP#1{\textsuperscript{{#1}}}
\def\SB#1{\textsubscript{{#1}}}
\def\IT#1{\textit{{#1}}}
\def \BF #1{\textbf{{#1}}}



\newtheorem{proposition}{Proposition}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{notation}{Notation}[section]
\newtheorem{example}{Example}[section]
\newtheorem{remark}{Remark}[section]
\newtheorem*{note}{Note}



\title{\normalfont\spacedallcaps{On Computational Paths and the Fundamental Groupoid of a Type}} \author{
   Arthur F. Ramos\SP{*}\\
  \texttt{afr@cin.ufpe.br}
  \and
  Ruy J. G. B. de Queiroz\SP{*}\\
  \texttt{ruy@cin.ufpe.br}
\and
  Anjolina G. de Oliveira\SP{*}\\
  \texttt{ago@cin.ufpe.br}
}



\date{} 



\begin{document}

\maketitle 



{\let\thefootnote\relax\footnotetext{* \textit{Centro de Inform√°tica, Universidade Federal de Pernambuco, Recife-PE, Brazil}}}



\renewcommand{\sectionmark}[1]{\markright{\spacedlowsmallcaps{#1}}} \lehead{\mbox{\llap{\small\thepage\kern1em\color{halfgray} \vline}\color{halfgray}\hspace{0.5em}\rightmark\hfil}} 

\pagestyle{scrheadings} 



\begin{abstract} 

The main objective of this work is to study mathematical properties of computational paths. Originally proposed by de Queiroz \& Gabbay (1994) as `sequences of rewrites', computational paths can be seen as the grounds on which the propositional equality between two computational objects stand. Using computational paths and categorical semantics, we take any type  of type theory and construct a groupoid for this type. We call this groupoid the fundamental groupoid of a type , since it is similar to the one obtained using the homotopical interpretation of the identity type. The main difference is that instead of being just a semantical interpretation, computational paths are entities of the syntax of type theory. We also expand our results, using computational paths to construct fundamental groupoids of higher levels.
\end{abstract}

{\bf Keywords:} Computational paths, fundamental groupoid, equality theory, term rewriting systems, type theory, category theory, higher categorical structures.




\section{Introduction}

There seems to be little doubt that the identity type is one of the most intriguing concepts of  Martin-L\"of's Type Theory. This claim is supported by recent groundbreaking discoveries. In 2005, Vladimir Voevodsky \cite{Vlad1} discovered the Univalent Models, resulting in a new area of research known as Homotopy Type Theory \cite{Steve1}. This theory is based on the fact that a term of some identity type, for example , has a clear homotopical interpretation. The interpretation is that the witness  can be seen as a homotopical path between the points  and  within a topological space . This simple interpretation has made clear the connection between Type Theory and Homotopy Theory, generating groundbreaking results, as one can see in \cite{hott,Steve1}. It is important to emphasize that one important fact of the homotopic interpretation is that the homotopic paths exist only in the semantic sense. In other words, there is no formal entity in the language of type theory that represents these paths. They are not present in the syntax of Type Theory.

Given a space , we can think of a structure  formed by points of the space  and homotopical paths between these points. Using straightforward equations, one can easily prove for  that the groupoid equations hold up to homotopy. We call this \emph{weak} structure (it is weak since the equalities do not hold `on the nose', but only up to homotopy) the fundamental groupoid of the space . Since each type , using the homotopical interpretation, can be semantically interpreted as being a space, we can consider  as being the fundamental groupoid of the type .

As we already mentioned, the paths of the homotopical interpretation do not have a counterpart in the syntax of type theory, but exist only as semantical interpretations. With that in mind, adding the concept of paths to the syntax of type theory was the focus of some of our recent works \cite{Ruy1, Art1en, Ruy5}. In these works, we argued that it is possible to formalize the concept of path as an formal entity of the equality theory. This formal entity, known as computational paths, establishes the equality between two terms of the same type. In fact, we argued that the identity type is just the type of this new entity. That way, we added the concept of path to the syntax of type theory, instead of considering it only as a semantic interpretation.

Our main objective in this work is to construct a fundamental groupoid for a type  using the concept of computational path, yet having the same semantics as in the homotopical interpretation. We will also go a little further, showing that it is possible to construct higher groupoid structures, like the weak 2-groupoid of a type  usually written as .

\section{Computational Paths} \label{path}

As previously mentioned, computational paths will be the main focus here. For that reason, a good understanding of the meaning of this entity is essential. The concept of computational path is inspired on the equality theory of -calculus, known as  \cite{lambda}. This theory estabilishes when two -terms are equal. It establishes a set of axioms and rules of inference that one can use. The idea is that a term  is  to a term  when one can reach  from  after the application of a set of axioms and rules of inference. The application of these axioms and rules of inference generates a path. As a very simple example, since , then we say that  because of the path . A more complex and interesting example will be showed after we formally define a computational path. Since -equality establishes equalities between terms of the -calculus, we need to find an equivalent theory for Type Theory, which establishes equality between terms of the same type. To do that, we just need to translate to Type Theory the axioms and rules of inference of the -equality. For example, for the product type , we obtain the following axioms (one can check the original axioms of  in \cite{lambda}):

\bigskip

\bigskip

\noindent
\begin{bprooftree}
\hskip -0.3pt
\alwaysNoLine
\AxiomC{}
\AxiomC{}
\UnaryInfC{}
\alwaysSingleLine
\LeftLabel{) \ }
\BinaryInfC{}
\end{bprooftree}
\begin{bprooftree}
\hskip 11pt
\alwaysNoLine
\AxiomC{}
\UnaryInfC{}
\alwaysSingleLine
\LeftLabel{ \ }
\UnaryInfC{}
\end{bprooftree}

\bigskip

\noindent
\begin{bprooftree}
\hskip -0.5pt
\AxiomC{}
\LeftLabel{ \ }
\UnaryInfC{}
\end{bprooftree}
\begin{bprooftree}
\hskip 100pt
\AxiomC{}
\AxiomC{}
\LeftLabel{ \ }
\BinaryInfC{}
\end{bprooftree}

\bigskip

\noindent
\begin{bprooftree}
\hskip -0.5pt
\AxiomC{}
\LeftLabel{}
\UnaryInfC{}
\end{bprooftree}
\begin{bprooftree}
\hskip 105pt
\AxiomC{}
\AxiomC{}
\LeftLabel{ \ }
\BinaryInfC{}
\end{bprooftree}

\bigskip

\noindent
\begin{bprooftree}
\hskip -0.5pt
\AxiomC{}
\AxiomC{}
\LeftLabel{ \ }
\BinaryInfC{}
\end{bprooftree}

\bigskip

\noindent
\begin{bprooftree}
\hskip -0.5pt
\AxiomC{}
\LeftLabel{ \ }
\RightLabel {}
\UnaryInfC{}
\end{bprooftree}

\bigskip

 Aside from these axioms, we can also apply a change of bounded variables. To simplify the notation, if not previously mentioned, consider that each computational path that appears in this work is considered modulo change of bounded variables.

\begin{definition}
Let  and  be elements of a type . Then, a \emph{computational path}  from  to  is a composition of applications of the inference rules of the equality theory of type theory. We denote that by .
\end{definition}

The composition is given by applications of the transitive rule. We can better understand this fact by analyzing an example.  consider the construction of the path between  and . Starting from , we have that . Then, we have the path . From , we have that . Therefore, we have a path . We now need to compose these paths. To do this, we can apply the transitivity to obtain the desired path between   and . Hence, the equality is established by the path . So, in the end, a computational path is a term built out of the composition of (definitional) equality identifiers. A notion of canonical (path) identifier will be defined, and a set of reduction rules for (path) terms will be given explicitly.

In our recent works, we argue that computational paths are in fact the formal inhabitants of the identity type, since they can be seen as a `derivation-term' of a proof of propositional equality. Since a path  establishes the equality between  and , then we can think of  as being an object of . One can check \cite{Ruy1, Art1en,Ruy5} for more details.

\section{Reductions between computational paths}

In the previous section, we showed that computational paths establishes the equality between two terms of the same type. In this section, our objective is to investigate if two seemingly different computational paths could be considered equals, i.e., if there is the possibility of establishing a path between paths. Consider the simple case of a reflexive path  that establishes that . If we apply the axiom of symmetry , we obtain the path . Since we applied the axiom  to the trivial case of reflexivity, we obtained a path that is just a redundant form of the reflexivity. In that case, the paths  and  should be considered equals, i.e., it should be possible to reduce  to just . The same thing happens if, given any path , we apply the symmetry two times in succession, obtaining the path . Inverting a path two times is equivalent as just using the original path, i.e.,  should be reduced to .

As one could notice, the aforementioned redundancies have been originated from combination of applications of the axioms of the equality theory for type theory (as instance, the redundancy of our first example has been originated by the combination of applications of reflexivity and symmetry). In the previous section, using the example of the product type , we showed that we have a total of 8 equality axioms. Since we can combine these axioms in different situations, one should expect that the number of possible redundancies might be high. Fortunately, all these redundancies and reductions have already been mapped by \cite{Anjo1} and further developed (and given identifiers) by \cite{Ruy1}. That way, \cite{Anjo1} created a system that maps all these reductions, called , with a total of 39 reduction rules. To construct the fundamental groupoid, 7 rules will be essential. They are as follows:

\begin{itemize}

\item Reductions involving  and :

 \quad 

\item Reductions involving 

 \quad 

 \quad 

\item Reductions involving  and 



\end{itemize}

As one can see, an identifier is given to each reduction rule. For example, our initial examples are resolved by applications of the rule  and the rule  respectively.

It is important to note that the system , is terminating and confluent, as proved in \cite{Anjo1,Ruy2,Ruy3,RuyAnjolinaLivro}.

We call each reduction rule as a rewrite rule and usually abbreviated to -rule. Associated to an -rule, we have the following definitions:

\begin{definition}
Let  and  be computational paths. We say that  (read as:  -contracts to ) iff we can obtain  from  by an application of only one -rule. If  can be reduced to  by finite number of -contractions, then we say that  (read as  -reduces to ).

\end{definition}

\begin{definition}
Let  and  be computational paths. We say that  (read as:  is -equal to ) iff  can be obtained from  by a finite (perhaps empty) series of -contractions and reversed -contractions. In other words,  iff there exists a sequence , with , such that

\centering  or 

\centering  , \quad 
\end{definition}

By definition, the -equality is a class of equivalence, since it was defined as the symmetric, reflexive and transitive closure of -reduction. Since an -equality is given by a sequence of -reductions, we call this sequence an -sequence.

\subsection{Reduction between -equalities}

We showed that it is possible to think of reductions between paths and that these reductions were originated from redundancies caused by the combination of the equality axioms. Since -equalities are transitive, symmetric and reflexive, it is possible to think of reductions between two -sequences. For example, if  is an -sequence, we can think of , which should be equivalent to . In fact, knowing that the  rule resolves this kind of redundancy for computational paths, we can think of a  rule that resolves this redundancy for -sequences. In fact, since our rules that we showed previously only involve transitivity, reflexivity and symmetry, and that -equality has these properties, then we get an -equality version of each rule, only adding the label  to make clear that we are working with -sequences and -equality. In fact, analogously to -equality, we can think of a -equality, which has the same definition, with the difference that we are working with reductions between -sequences. For that reason, -equality is also an equivalence class.

Since -equality forms a new system of rules, it is possible to think of rules that are specific to -equality. In fact, there is a specific rule that will play an essential role in the construction of our higher fundamental groupoid . Consider the example of the path , such that  and . There are two possible -sequences:  and . As one can see, the only difference between these two -sequences are the choice of which term to develop first. Since  and  followed the same reductions (i.e.,  reduced to  in both cases and  to ), then these two -sequences are two ways of expressing the same result. For that reason, there should be a rule that establishes the -equality of these -sequences. We call this rule the independence of choice inside the transitivity, and it is expressed by . Then, we have that  . As one could see, this rule only makes sense in the context of -sequences and, for this reason, it is specific to -equality and -reduction.


\section{The fundamental groupoid of a type: }

In this section, our objective is to show that the computational paths are capable of constructing the fundamental groupoid of a type . The first thing that we should be aware is the idea of equality holding in a weak sense. In the homotopical interpretation, the idea of weak is related to a structure which the equalities only hold up to homotopy. In this work, we will use the term weak to characterize a structure which equalities only hold up to -equality or -equality. If the equalities hold 'on the nose', instead of being weak, we say that the structure is strict.

First, let's recall some basic concepts of category theory \cite{Steve2}:

\begin{definition}

Let  be an arrow of any category.  is called an isomorphism if there exists a  such that  and .  is called the inverse of  and can be written as .

\end{definition}

\begin{definition}
A groupoid is a category in which every arrow is an isomorphism.
\end{definition}

We can now think of a structure  in which the objects are the objects  and the morphisms are the computational paths between these objects:

\begin{proposition}
 is a weak groupoid.
\end{proposition}

\begin{proof}

First, we need to prove that  is a weak category. To do that, we need to define composition of morphisms and the identity arrow. We already know that composition of paths  is given by application of the transitivity, i.e., . The identity morphism of an object  is given by the reflexive path . We need now to check the associative and identity laws. The associativity equation holds weakly, we just need to use the  rule:

\begin{center}
.
\end{center}

Using rules  and , we show that the identity laws also hold weakly:

\begin{center}




\end{center}

With these conditions satisfied, we conclude that  is indeed a weak category. To conclude our proof, we need to show that it also is a weak groupoid. To do that, we need to show that every computational path  has a inverse computational path . Finding  is easy, just put . To show that the equalities of the isomorphism hold weakly, we use rules  and :

\begin{center}





With that, we conclude that  is a weak groupoid.

\end{center}
\end{proof}

Since the groupoid  is constructed from a type  and its objects and equalities between these objects (given by computational paths), we define  as the fundamental groupoid of type .

As proved by \cite{Streicher2}, the groupoid model of a type proves that the uniqueness of identity proofs is not derivable in the syntax of type theory. The construction of the fundamental groupoid of a type based on computational paths makes clear that the addition of computational paths to the syntax of type theory will still refute the uniqueness of identity proofs. In this sense, one can interpret this result as the fact that there may be two computational paths  and  between objects  and  such that  and  are not -equal.

\subsection{The fundamental 2-groupoid  of a type}

Using the homotopical interpretation, one can construct a weak -groupoid of a space . This -groupoid, called the fundamental -groupoid of the space , can be constructed by taking  and adding a groupoid structure to each pair of objects of . In this sense, for each pair of objects , we have a groupoid , in which the objects are homotopical paths between  and  and morphisms are classes of homotopies between these paths. It is a well established fact that  together with the structures  forms a weak , known as  \cite{Tom}.

The objective of this subsection is to show that it is possible to construct, using computational paths, the fundamental -groupoid  of a type . To construct , we can think of the structure  with the addition of substructures  between each pair of objects of . In , objects are computational paths between  and  and morphisms are -equalities modulo -equality.  is a strict groupoid. The proof of this fact is analogous to \textbf{proposition 4.1}. The difference is that instead of using -rules, this proof uses the equivalent -rule. Another difference is that the equations hold strictly, since the morphisms are modulo -equality. Now we can prove the following proposition:

\begin{proposition}

Given any type ,  is a weak -groupoid.

\end{proposition}

\begin{proof}

First of all, we can represent  graphically as follows:

\bigskip

\begin{center}

\begin{tikzpicture}[>=latex,
    every node/.style={auto},
    arrowstyle/.style={double,->,shorten <=3pt,shorten >=3pt},
    mydot/.style={circle,fill}]

    \coordinate[mydot,label=above:](a)  at (0,0);
    \coordinate[mydot,label=above:](b) at (3,0);
    \coordinate[mydot,label=above:](c) at (6,0);
    \coordinate[mydot,label=above:](d) at (9,0);
    \draw[->]   (a) to[bend left=50]  coordinate (s) node[]{}          (b);
    \draw[->]   (a) to coordinate (t) node[label={[label distance=-1cm]43:t}] {}    (b);
    \draw[->]   (a) to[bend right=70]  coordinate (x) node[,swap]{}          (b);
    \draw[->]   (b) to[bend left=50]  coordinate (r) node[]{}          (c);
    \draw[->]   (b) to coordinate (w) node[label={[label distance=-1cm]40:w}] {}    (c);
    \draw[->]   (b) to[bend right=70]  coordinate (y) node[,swap]{}          (c);
    \draw[->]   (c) to[bend left=50]  coordinate (p) node[]{}          (d);
    \draw[->]   (c) to coordinate (q) node[label={[label distance=-1cm]50:q}] {}    (d);
       \draw[->]   (c) to[bend right=70]  coordinate (z) node[,swap]{}          (d);

    \draw[arrowstyle] (s) to node[right]{[} (t);
     \draw[arrowstyle] (t) to node[right]{[} (x);
    \draw[arrowstyle] (r) to node[right]{[} (w);
 \draw[arrowstyle] (w) to node[right]{[} (y);
\draw[arrowstyle] (r) to node[right]{[} (w);
   \draw[arrowstyle] (p) to node[right]{[} (q);
\draw[arrowstyle] (q) to node[right]{[} (z);
\end{tikzpicture}	

\end{center}

We already know that  is a weak groupoid and that  is a strict groupoid. To finish the proof that  is a weak -groupoid, we need to show that  is a bicategory.

As one can check in \cite{Tom}, the proof that a structure is a bicategory follows a considerable number of steps. To achieve this proof, one of the first steps is to define how a -morphism (as we already know, in  -morphisms are -equalities modulo -equality) can be composed horizontally. Given an -sequence  and an -sequence , we define the horizontal composition  as the following -sequence:



With the horizontal composition well defined, we need to check if it is associative and respect the identity laws. For the associativity, we need to show that there is a natural isomorphism  between  and  . To prove that, we will use the well established fact that a natural transformation is a natural isomorphism iff every component is an isomorphism \cite{Steve2}. That way, we only need to prove that there is an isomorphism between every component of  and  . In fact, since we are working in a groupoid structure, we just need to check that there is a morphism between each component (since every morphism is an isomorphism in a groupoid). To do this, we can get a generic component  of   ( being suitable naturals that respect the order of the horizontal composition) and show that it has a morphism to the equivalent component  of  . This morphism is established by  as follows:

\begin{center}

\end{center}

To prove the identity law, we use a similar idea. We need to check the natural isomorphism   between    and . To do that, we prove find a morphism between components  and :

\begin{center}
.
\end{center}

We now need to check the second identity law, i.e., the natural isomorphism  between   and . Taking components  and :

\begin{center}
.
\end{center}

Also associated to the horizontal composition, we need now to check the interchange law, i.e., we need to check:

\begin{center}

\end{center}

From  , we have:

\begin{center}
 

 




\end{center}

From   :

\begin{center}
 

 

 

\end{center}

As one can see, the sole difference between the two results is the order that the internal -sequences have been developed in each transitivity. This is a perfect case to use the independence of choice inside the transitivity, i.e., the -rule known as . By one application of , we conclude that   .

To end our proof, since we are working with a weak structure, we need to check the coherence laws for a bicategory. The coherence laws are given by Mac Lane's pentagon and triangle \cite{Tom}:

\begin{center}
\begin{tikzpicture}[>=latex,
    every node/.style={auto},
    arrowstyle/.style={double,->,shorten <=3pt,shorten >=3pt},
    mydot/.style={circle,fill}]

    \coordinate[mydot,label=left:](a)  at (2,0);
    \coordinate[mydot,label=left:](b) at (0,-3);
    \coordinate[mydot,label=right:](c) at (5,0);
    \coordinate[mydot,label=right:](d) at (7,-3);
     \coordinate[mydot,label=below:](e) at (3.5,-6);

    \draw[->]   (a) to coordinate (s) node[,swap] {}    (b);
    \draw[->]   (a) to coordinate (t) node[,swap] {}    (c);
    \draw[->]   (c) to coordinate (x) node[] {}    (d);
     \draw[->]   (b) to coordinate (y) node[,swap] {}    (e);
     \draw[->]   (d) to coordinate (z) node[] {}    (e);
\end{tikzpicture}

\bigskip

\begin{tikzpicture}[>=latex,
    every node/.style={auto},
    arrowstyle/.style={double,->,shorten <=3pt,shorten >=3pt},
    mydot/.style={circle,fill}]

  \coordinate[mydot,label=left:](a)  at (0,0);
    \coordinate[mydot,label=right:](b) at (2,0);
    \coordinate[mydot,label=below:](c) at (1,-2);

        \draw[->]   (a) to coordinate (s) node[,swap] {}    (b);
       \draw[->]   (a) to coordinate (t) node[,swap] {}    (c);
      \draw[->]   (b) to coordinate (x) node[] {}    (c);
\end{tikzpicture}
\end{center}

We need to show that the diagrams above commute. The equations are straightforward. Starting with the pentagon, we can start from  and go to the right of the diagram:

\begin{center}









\end{center}

Starting from the same  and going bottom left:

\begin{center}



\end{center}

We conclude that the pentagon commutes. For the triangle, we can start with  and go to the right:

\begin{center}





\end{center}

Now starting with the same  and going to to bottom right:

\begin{center}



\end{center}

The triangle also commutes. The coherence laws hold. With that, we finish the proof that  is a weak -groupoid.

\end{proof}

With this proof, we conclude that, using computational paths, it is possible to construct the fundamental -groupoid of a type . In fact, using the same reasoning that led us to come up with -equality, one could think of -equality, -equality, etc. That way, it would be possible to think of the possibility of even higher fundamental groupoids. If we continue this process to the infinite, we would think of a possible weak infinite groupoid , also called weak -groupoid. As a matter of fact, it has already been proved that it is possible to obtain such structure, as shown in \cite{lumsdaine1, Benno}. Our objective, in a future work, is to obtain similar results using the concept of computational paths. The same way that we used to construct the fundamental -groupoid , we could use computational paths and infinite levels of -equalities to construct . The problem is that  is a complex structure and to prove that it is a weak -groupoid is not an easy task. For that reason, obtaining this construct will be the main focus of some of our future works.

\section{Conclusion}

The main objective of this work was to construct a groupoid model for a type using the concept of computational paths. Based on the idea that it is possible to introduce an entity known as computational paths to the syntax of type theory, we used this newly added entity to construct a groupoid model for a type . We have showed that this approach is fundamentally different from the groupoid constructed using homotopical paths, since computational paths are de facto elements of the syntax of type theory, instead of being only semantical interpretations.

To achieve our results, we have showed that it is possible to think of reductions between two different computational paths. Based on these reductions, we have constructed a structure in which objects are elements of a type  and morphisms are computational paths. We have showed that this structure is, in fact, a weak groupoid, and called it the fundamental groupoid of a type . We have gone further, defining a higher structure and proving that this structure is also a groupoid. That way, using computational paths, we have obtained the fundamental -groupoid of the type . A rather natural way forward is to show that it is indeed possible to obtain even higher structures, with the main goal of using computational paths to obtaining a possible fundamental -groupoid.

\bibliographystyle{ieeetr}
\bibliography{Biblio}

\end{document} 