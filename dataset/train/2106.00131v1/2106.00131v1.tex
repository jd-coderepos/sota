
\documentclass{article} \usepackage{iclr2021_conference,times}
\iclrfinalcopy 



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 

\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{bm}
\usepackage[pdftex]{graphicx}


\title{Clustering-friendly Representation Learning via Instance Discrimination and Feature Decorrelation}



\author{Yaling Tao, Kentaro Takagi \& Kouta Nakata \\
Corporate R\&D Center, Toshiba\\
1, Komukai Toshiba-cho, Saiwai-ku, Kawasaki, Kanagawa, Japan\\
\texttt{\{yaling1.tao,kentaro1.takagi,kouta.nakata\}@toshiba.co.jp}}




\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}

\maketitle

\begin{abstract}
Clustering is one of the most fundamental tasks in machine learning. Recently, deep clustering has become a major trend in clustering techniques. Representation learning often plays an important role in the effectiveness of deep clustering, and thus can be a principal cause of performance degradation. In this paper, we propose a clustering-friendly representation learning method using instance discrimination and feature decorrelation. Our deep-learning-based representation learning method is motivated by the properties of classical spectral clustering. Instance discrimination learns similarities among data and feature decorrelation removes redundant correlation among features. We utilize an instance discrimination method in which learning individual instance classes leads to learning similarity among instances. Through detailed experiments and examination, we show that the approach can be adapted to learning a latent space for clustering. We design novel softmax-formulated decorrelation constraints for learning. In evaluations of image clustering using CIFAR-10 and ImageNet-10, our method achieves accuracy of  and , respectively. We also show that the softmax-formulated constraints are compatible with various neural networks.
\end{abstract}

\section{Introduction}



Clustering is one of the most fundamental tasks in machine learning. Recently, deep clustering has become a major trend in clustering techniques.
In a fundamental form, autoencoders are used for feature extraction, and classical clustering techniques such as -means are serially applied to the features.
Recent deep clustering techniques integrate learning processes of feature extraction and clustering, yielding high performance for large-scale datasets such as handwritten digits \cite{hu2017learning, shaham2018spectralnet, DEC, tao2018rdec}. However, those methods have fallen short when targets become more complex, as in the case of real-world photograph dataset CIFAR-10 \cite{krizhevsky2009learning}.
Several works report powerful representation learning leads to improvement of clustering performance on complex datasets \cite{DAC, DCCM}. Learning representation is a key challenge to unsupervised clustering.



In order to learn representations for clustering, recent works utilize metric learning which automatically learns similarity functions from data \cite{DAC, DCCM}. They assign pseudo-labels or pseudo-graph to unlabeled data by similarity measures in latent space, and learn discriminative representations to cluster data. These works improve clustering performance on real world images such as CIFAR-10 and ImageNet-10, and indicate the impact of representation learning on clustering. Although features from learned similarity function and pseudo-labels work well for clustering, algorithms still seem to be heuristic; we design a novel algorithm which is based on knowledge from established clustering techniques. In this work, we exploit a core idea of spectral clustering which uses eigenvectors derived from similarities.





Spectral clustering has been theoretically and experimentally investigated, and known to outperform other traditional clustering methods \cite{von2007tutorial}. The algorithm involves similarity matrix construction, transformation from similarity matrix to Laplacian, and eigendecomposition. Based on eigenvectors, data points are mapped into a lower dimensional representation which carries information of similarities and is preferable for clustering. We bring this idea of eigenvector representation into deep representation learning.



We design the representation learning with two aims: 1) learning similarities among instances; and 2) reducing correlations within features. The first corresponds to Laplacian, and the second corresponds to feature orthogonality constrains in the spectral clustering algorithm. Learning process integrating both is relevant to eigendecomposition of Laplacian matrix in the spectral clustering.

For the first aim, we adopt the instance discrimination method presented in \cite{wu2018unsupervised}, where each unlabeled instance is treated as its own distinct class, and discriminative representations are learned to distinguish between individual instance classes. This numerous-class discriminative learning enables learning partial but important features, such as small foreground objects in natural images. \cite{wu2018unsupervised} showed that the representation features retain apparent similarity among images and improve the performance of image classification by the nearest neighbor method. We extend their work to the clustering tasks.
We clarify their softmax formulation works like similarity matrix in spectral clustering under the condition that temperature parameter , 
which was underexplored in \cite{wu2018unsupervised}, is set to be a larger value .


For the second aim, we introduce constraints which have the effect of making latent features orthogonal. 
Orthogonality is often an essential idea in dimension reduction methods such as principal components analysis,
and it is preferable for latent features to be independent to ensure that redundant information is reduced.
Orthogonality is also essential to a connection between proposed method and spectral clustering, as stated in Section \ref{sec:spectral}.
In addition to a simple soft orthogonal constraint, we design a novel softmax-formulated decorrelation constraint. Our softmax constraint is "softer" than the soft orthogonal constraint for learning independent feature spaces, but realizes stable improvement of clustering performance. 

Finally, we combine instance discrimination and feature decorrelation into learning representation to improve the performance of complex image clustering. 
For the CIFAR-10 and ImageNet-10 datasets, our method achieves accuracy of  and , respectively. Our PyTorch \cite{NEURIPS2019_9015} implementation of IDFD is available
at \url{https://github.com/TTN-YKK/Clustering_friendly_representation_learning}.


Our main contributions are as follows:
\begin{itemize}
\item We propose a clustering-friendly representation learning method combining instance discrimination and feature decorrelation based on spectral clustering properties.
\item We adapt deep representation learning by instance discrimination to clustering and clarify the essential properties of the temperature parameter.
\item We design a softmax-formulated orthogonal constraint for learning latent features and realize stable improvement of clustering performance.
\item Our representation learning method achieves performance comparable to state-of-the-art levels for image clustering tasks with simple -means.
\end{itemize}


\section{Related Work}

Deep clustering methods offer state-of-the-art performance in various fields.
Most early deep clustering methods, such as \cite{vincent2010stacked, tian2014learning}, are two-stage methods that apply clustering after learning low-dimensional representations of data in a nonlinear latent space. The autoencoder method proposed in \cite{hinton2006reducing} is one of the most effective methods for learning representations. Recent works have simultaneously performed representation learning and clustering \cite{song2013auto, DEC, yang2017towards, guo2017IDEC, tao2018rdec}. Several methods based on generative models have also been proposed \cite{jiang2016variational, dilokthanakul2016deep}. These methods outperform conventional methods, and sometimes offer performance comparable to that of supervised learning for simple datasets. Deep-learning-based unsupervised image clustering is also being developed \cite{DAC, DCCM, IIC, gupta2020unsupervised, SCAN}. 

Several approaches focus on learning discriminative representations via deep learning.
\cite{bojanowski2017unsupervised} found a mapping between images on a uniformly discretized target space, and enforced their representations to resemble a distribution of pairwise relationships.
\cite{caron2018deep} applied pseudo-labels to output as supervision by -means and then trained a deep neural network.
\cite{donahue2016adversarial} proposed bidirectional generative adversarial networks for learning generative models that map simple latent distributions to complex real distributions, in order for generators to capture semantic representations.
\cite{hjelm2018learning} proposed deep infomax to maximize mutual information between the input and output of an encoder.
\cite{wu2018unsupervised} was motivated by observations in supervised learning that the probabilities of similar image classes become simultaneously high. They showed that discriminating individual instance classes leads to learning representations that retain similarities among data.


IIC \cite{IIC} and SCAN \cite{SCAN} are two recent works focusing on image clustering and obtained high performance. IIC \cite{IIC} directly learns semantic labels without learning representations based on mutual information between image pairs. SCAN \cite{SCAN} focuses on the clustering phase and largely improved performance based on a given pre-designed representation learning. By contrast, we focus on learning a clustering-friendly representation space where objects can be simply clustered.


Our method exploits the idea of spectral clustering \cite{shi2000normalized, meila2001learning, von2007tutorial, ng2002spectral}. From one perspective, spectral clustering finds a low dimensional embedding of data in the eigenspace of the Laplacian matrix, which is derived from pairwise similarities between data. By using the embedded representations, we can proceed to cluster the data by the -means algorithm in the low-dimensional space. Spectral clustering often outperforms earlier algorithms such as -means once pair similarities are properly calculated.
\cite{shaham2018spectralnet} incorporated the concept of spectral clustering into deep a neural network structure. Similarities were calculated by learning a Siamese net \cite{shaham2018learning} where the input positive and negative pairs were constructed according to the Euclidean distance.


\section{Proposed Method}
\label{sec:method}
Given an unlabeled dataset  and a predefined number of clusters , where  denotes the th sample, we perform the clustering task in two phases, namely, representation learning and clustering. This work focuses on the first phase, which aims to learn an embedding function  mapping data  to representation  so that  is preferable for clustering.  is modeled as a deep neural network with parameter . We use  to denote the whole representation set.

\begin{figure}[h]
  \centering
  \includegraphics[width=\linewidth]{ourModel.png}
  \caption{Pipeline of our method.}
\label{Fig:ourModel}
\end{figure}

\subsection{Instance Discrimination}

We apply the instance discrimination method proposed by \cite{wu2018unsupervised} to learn clustering-friendly representations that capture similarity between instances.
The objective function is formulated based on the softmax criterion. Each instance is assumed to represent a distinct class. For given data , the corresponding representations are , and data  is classified into the th class.
Accordingly, the weight vector for the th class can be approximated by a vector . The probability of representation  being assigned into the th class is

where  measures how well  matches the th class,  is a temperature parameter that controls the concentration of the distribution \cite{hinton2015distilling}, and  is normalized to .

The objective maximizes the joint probability  as

\cite{wu2018unsupervised} shows that features obtained by minimizing the objective retain similarity between image instances and improve the performance of nearest neighbor classification.
For clustering, we note that the parameter , which is underexplored in \cite{wu2018unsupervised}, has a large impact on clustering performance. The effect of  is discussed later and experimental results are shown in \ref{subsubsec:analyzeTau}.

\subsection{Feature Decorrelation}
\label{subsec:FD_FO}
We define a set of latent feature vectors  and use  to denote the th feature vector.
Transposition of latent vectors  coincides with , where  is the dimensionality of representations.

The simple constraint for orthogonal features is,
 

Our novel constraint is based on a softmax formulation of
 
 is analogous to .  measures how correlated a feature vector is to itself and how dissimilar it is to others.  is the temperature parameter.
We formulate the feature decorrelation constraint as
 
Both constrains in Eq. (\ref{eq:Lorth-G}) and Eq. (\ref{eq:Lorth}) aim to construct independent features. Conventionally, it is preferable for features to be independent to ensure that redundant information is reduced,
and orthogonality is a common technique.
Compare Eq. (\ref{eq:Lorth-G}) and Eq. (\ref{eq:Lorth}), we can see that minimizing  and  can result in a similar effect,  and  or , and both try to decorrelate latent features.

Our softmax constraint in Eq. (\ref{eq:Lorth}) shows practical advantages in flexibility and stability.
Eq. (\ref{eq:Lorth-G}) is called a soft orthogonal constraint, but is still strict enough to force the features to be orthogonal. If  is larger than underlying structures that are hidden and unknown, all features are forcibly orthogonalized and the resultant features may not be appropriate. Softmax formulation allows off-diagonal elements to be non-zero and alleviates the problem of strict orthogonality.

Partial derivatives of  and  with respect to  are calculated as

and , where  is an indicator function. Since the derivatives nearly equal zero due to  in the case of , we focus on the case of .
When , the ranges of partial derivatives are  and .
The monotonicity of  can lead to more stable convergence. 
The advantages of  are confirmed by experiments in section \ref{Experiments}.



\subsection{Objective Function and Learning Model}
Combining instance discrimination and feature decorrelation learning, we formulate our objective function  as follows:

Where  is a weight that balances the contributions of two terms  and .

Figure \ref{Fig:ourModel} shows the learning process for the motif of image clustering.
Input images  are converted into feature representations  in a lower -dimensional latent space, via nonlinear mapping with deep neural networks such as ResNet \cite{He2015}.
The -dimensional vectors are simultaneously learned through instance discrimination and feature decorrelation. 
A clustering method, such as classical -means clustering, is then used on the learned representations to obtain the clustering results.

Optimization can be performed by mini-batch training. To compute the probability  in Eq. (\ref{eq:piv}),  is needed for all images. Like \cite{wu2018unsupervised, xiaoli2017joint}, we maintain a feature memory bank for storing them. For  in Eq. (\ref{eq:qmf}), all  of  dimensions in the current mini-batch can be obtained, we simply calculate the  within the mini-batches. 

We combine  and  to formulate an alternative loss  in E.q. (\ref{eq:loss_alternative}),

We refer to representation learning using , , and  loss as instance discrimination and feature decorrelation (IDFD), instance discrimination and feature orthogonalization (IDFO), and instance discrimination (ID), respectively.



\subsection{Connection with Spectral Clustering}
\label{sec:spectral}
We explain the connection between IDFD and spectral clustering. 
We consider a fully connected graph consisting of all representation points, and the similarity matrix  and degree matrix  can be written as
 and .
The loss function of spectral clustering \cite{shaham2018spectralnet} can be reformulated as




where  is Laplacian matrix,  are feature vectors.
Spectral clustering is performed by minimizing  subject to orthogonal condition of , and
when  takes minimum value  become eigenvectors of Laplacian .
According to Section \ref{subsec:FD_FO}, minimizing  can approximate the orthogonal condition.
Under this condition, minimizing  can approximate the minimizing , which is explained as follows.
 
According to Eq.(\ref{eq:Linst}), minimizing loss  means maximizing  and minimizing .
When , we have ,  becomes zero.
We need consider only the influence on  from minimizing .
As  are normalized,  can be rewritten using cosine metric as

then  can be calculated as


According to Eq.(\ref{eq:L_sp_part}), we get  when .
This means  monotonically decreases when we minimize .
Therefore, the impact from minimizing  is good for minimizing .
Even if  is a little smaller than ,
because  controls the scale of derivatives and the range of  where the derivative is negative, large  decreases the scale and  narrows the range,
resulting in a small influence on the total loss.
From this viewpoint, the effectiveness of minimizing  using large  is approximately the same as that of . By adding feature decorrelation constraints, IDFD becomes analogous to spectral clustering.


\section{Experiments}
\label{Experiments}
We conducted experiments using five datasets:
{\bf CIFAR-10} \cite{krizhevsky2009learning}, {\bf CIFAR-100} \cite{krizhevsky2009learning}, {\bf STL-10} \cite{coates2011analysis}, {\bf ImageNet-10} \cite{deng2009imagenet}, and {\bf ImageNet-Dog} \cite{deng2009imagenet}. We adopted ResNet18 \cite{He2015} as the neural network architecture in our main experiments. 
The same architecture is used for all datasets. Our experimental settings are in accordance with that of \cite{wu2018unsupervised}. Data augmentation strategies often used on images are also adopted in experiments. Details about datasets and experimental setup are given in Appendix \ref{appendix_dataset}. 

For IDFD, the weight  is simply fixed at . Orthogonality constraint weights for IDFO were  on CIFAR-10 and CIFAR-100, and  on STL-10 and ImageNet subsets. The weight  was set according to the orders of magnitudes of losses. In the main experiments, we set temperature parameter  for IDFO and IDFD, and  for IDFD. In order to fully investigate our work, we also constructed two versions of instance discrimination (ID) that uses only  loss, ID(original) with small  and ID(tuned) with large .


We compared ID(tuned), IDFO, and IDFD with ID(original) and six other competitive methods, clustering with an autoencoder (AE) \cite{hinton2006reducing}, deep embedded clustering (DEC) \cite{DEC}, deep adaptive image clustering (DAC) \cite{DAC}, deep comprehensive correlation mining (DCCM) \cite{DCCM}, invariant information clustering (IIC) \cite{IIC}, and semantic clustering by adopting nearest neighbors (SCAN) \cite{SCAN} .We use three metrics to measure clustering performance: standard clustering accuracy (ACC), normalized mutual information (NMI), and adjusted rand index (ARI). These metrics give values in , with higher scores indicating more accurate clustering assignments. 

\subsection{Main Results}
\label{results}
Table \ref{tab:results} lists the best performances for each method. The results for the four methods AE, DEC, DAC, and DCCM are cited from \cite{DCCM}, and results for two methods IIC and SCAN are cited from \cite{SCAN}. Comparing these results, we conclude that ID(tuned), IDFO, and IDFD, clearly outperform these methods excluding SCAN for all datasets, according to the metrics ACC, NMI, and ARI.  
For dataset CIFAR-10, ID(tuned), IDFO, and IDFD yielded ACC values of , , and , respectively.
For dataset ImageNet-10, ID(tuned), IDFO, and IDFD achieved ACC values of , , and . The high performance is comparable with that of supervised and semi-supervised methods.
Gaps between the results of ID(tuned) and those of IDFO and IDFD reflect the effect of the feature constraint term. The performance is improved for all datasets by introducing feature orthogonalization and decorrelation.
Impressively, ID(tuned) significantly outperformed ID(original) on all datasets, showing strong impact of temperature parameter. This will be discussed separately in section \ref{subsubsec:analyzeTau}. 

In addition, we note that IDFD differs from SCAN in that IDFD focuses on the representation leaning while SCAN focuses on clustering by given a representation learning. Both SCAN and IDFD demonstrate significant improvement on performance compared with other methods. Results of IDFD and SCAN showed effectiveness of efforts on both representation learning and clustering phases of deep clustering.

\begin{table}
  \caption{Clustering results (\%) of various methods on five datasets.}\label{tab:results}
  \centering
  \scalebox{0.75}{\begin{tabular}{c|ccc|ccc|ccc|ccc|ccc}
    \toprule
    Dataset&\multicolumn{3}{|c|}{CIFAR-10}&\multicolumn{3}{c|}{CIFAR-100}&\multicolumn{3}{c|}{STL-10}&\multicolumn{3}{c|}{ImageNet-10}&\multicolumn{3}{c}{ImageNet-Dog}\\ \hline
    Metric&ACC&NMI&ARI&ACC&NMI&ARI&ACC&NMI&ARI&ACC&NMI&ARI&ACC&NMI&ARI\\
    \midrule
    AE&31.4&23.9&16.9&16.5&10.0&4.8&30.3&25.0&16.1&31.7&21.0&15.2&18.5&10.4&7.3\\
    DEC&30.1&25.7&16.1&18.5&13.6&5.0&35.9&27.6&18.6&38.1&28.2&20.3&19.5&12.2&7.9\\
    DAC&52.2&39.6&30.6&23.8&18.5&8.8&47.0&36.6&25.7&52.7&39.4&30.2&27.5&21.9&11.1\\
    DCCM&62.3&49.6&40.8&32.7&28.5&17.3&48.2&37.6&26.2&71.0&60.8&55.5&38.3&32.1&18.2\\
  	ID(original)&44.0&30.9&22.1		&26.7&22.1&10.8		&51.4&36.2&28.5		&63.2&47.8&42.0		&36.5&24.8&17.2	\\\hline
    IIC&61.7&51.1&41.1&25.7&22.5&11.7&59.6&49.6&39.7&-&-&-&-&-&-\\
    SCAN&88.3&79.7&77.2&50.7&48.6&33.3&80.9&69.8&64.6&-&-&-&-&-&-\\\hline
    ID(tuned)&77.6&68.2&61.6		&40.9&39.2&24.3		&72.6&64.0&52.6		&93.7&86.7&86.5		&47.6&47.0&33.5\\
    IDFO& 82.8& 71.4& 67.9		& 42.5& 43.2&24.4		& 75.6&63.6&56.9		&94.2&87.1&87.6	& 61.2& 57.9& 41.4\\
	IDFD&81.5&71.1&66.3		&42.5&42.6& 26.4		& 75.6& 64.3& 57.5		& 95.4& 89.8& 90.1	&59.1&54.6&41.3\\
  \bottomrule
\end{tabular}}
\end{table}


We also examine the learning stability of ID(tuned), IDFO, and IDFD. Figure \ref{fig:acc_overProcess} illustrates the accuracy on CIFAR-10 running each of ID(tuned), IDFO, and IDFD.
We can see that both IDFO and IDFD obtained higher peak ACC values than ID(tuned). In particular, IDFD yielded higher performance than ID over the entire learning process. IDFO performed better than the other two methods and obtained the highest ACC value in earlier epochs. However, the ACC widely fluctuated over the learning process and dropped in later epochs. As analyzed in \ref{subsec:FD_FO}, our proposed IDFD makes performance higher than ID and more stable than IDFO.

\subsection{Discussion}
\subsubsection{Analysis on Temperature Parameter}
\label{subsubsec:analyzeTau}
Gaps between results of ID(original) and ID(tuned) in Table \ref{tab:results} show strong impact of temperature parameter. 
We theoretically and intuitively analyze the essential change caused by the temperature parameter in this subsection.


First, we consider why instance-level discrimination works and under what conditions.
Difference in the performance of ID(original) and ID(tuned) suggests optimal distribution in latent space changes with the magnitude of . According to empirical investigation and theoretical analysis, we find that a large  in  encourages data points to follow a compact distribution when minimizing the loss, while a small  drives them to follow a uniform distribution. This means minimizing  with a large  can reach a good clustering-friendly solution. This property was explained by demonstrating examples and calculation, details are given in Appendix B.






In the definition of  in Eq. (\ref{eq:piv}), when  is small, we compute softmax on larger logits, resulting in higher prediction, and obtain a more confident model. 
From this viewpoint, we can leverage a small  to decrease class entanglement if we can learn an accurate class-weight vector. In the general classification problem, since the weight of each class can be learned according to the real labels, it is preferable for models to be more confident. Most works therefore recommend setting a small value, such as  \cite{wu2018unsupervised}. 
In clustering, however, instance-level discrimination is used to learn similarity among samples, with only one sample in each class. Because the model is highly confident, 
each sample tends to be completely independent from each other. Similarity among samples is seemingly encouraged to approach close to zero, even for samples from the same class. This clearly deviates from the original intent of adopting instance-level discrimination to learn sample entanglements under the condition that each sample can be discriminative. A larger  than that used for classification is thus needed.

More experiments over different temperature settings on ID and IDFD were conducted on CIFAR-10.
Figure \ref{fig:acc_over_tau} shows the accuracy of ID for .
We calculated the mean and standard deviation of ACC values over the last  epochs for each experiment. From the results, we can see that ID can suffer significant performance degradation when  is too small or too large. This agrees with our analysis above. We also investigate the impact of  by fixing . Figure \ref{fig:acc_over_tau2} shows the accuracy of the IDFD for . Experimental results show that IDFD is relatively robust to the parameter  and enables stable representation learning.

\begin{figure}[htbp]
\begin{tabular}{lcr}
\begin{minipage}{0.34\hsize}
\begin{center}
\includegraphics[width=.9\hsize]{acc_over_epoch}
\caption{ACC values over learning process.}
\label{fig:acc_overProcess}
\end{center}
\end{minipage}
\begin{minipage}{0.33\hsize}
\begin{center}
\includegraphics[width=.9\hsize]{ACC_over_tau_ID.png}
\caption{Accuracy of ID for various  settings.} 
\label{fig:acc_over_tau}
\end{center}
\end{minipage}
\begin{minipage}{0.33\hsize}
\begin{center}
\includegraphics[width=.9\hsize]{ACC_over_tau2_IDFD}
\caption{Accuracy of IDFD for various  settings. } 
\label{fig:acc_over_tau2}
\end{center}
\end{minipage}
\end{tabular}
\end{figure}

\subsubsection{Representation Distribution and Feature Behavior}
Figure \ref{fig:tsne_all} visualizes the results of representations learned in four experiments: (a) ID(original), (b) ID(tuned), (c) IDFO with  and , and (d) IDFD with , , and  on CIFAR-10. 128-dimension representations were embedded into two dimensions by t-SNE (t-distributed stochastic neighbor embedding) \cite{maaten2008visualizing}. Colors indicate ground truth classes. The distributions for the ID(original) and ID(tuned) again show the significant difference between them. Data distribution when  is apparently more clustering-friendly than when . Furthermore, compared with ID(tuned), IDFO and IDFD can separate samples from different classes with certain margins. IDFO tended to construct a patch-like distribution within one class. In contrast, IDFD maintained a tighter connection among samples of the same class and more distinct borders between different classes. 

\begin{figure}[h]
  \centering
  \includegraphics[width=\linewidth]{tsne-all}
  \caption{Distribution of feature representations on CIFAR-10.} 
  \label{fig:tsne_all}
\end{figure}

Figure \ref{fig:imagenet_tsne} shows distribution of feature representations on ImageNet-10 learned by IDFD. We can see that representations of ImageNet-10 are clustering-friendly and even better than that of CIFAR-10. This is consistent with the results in Table \ref{tab:results} evaluated by metrics ACC, NMI, and ARI. In addition to that, we also plot sample images corresponding to points lying near the border between clusters. We can see that these samples are certainly similar in appearance.

\begin{figure}[h] 
  \centering
  \includegraphics[width=\linewidth]{ImageNet10_IDFD}
  \caption{Distribution of feature representations on ImageNet-10 learned by IDFD and samples corresponding to points in some areas.}
  \label{fig:imagenet_tsne}
\end{figure}

\begin{figure}[h] 
  \centering
  \includegraphics[width=\linewidth]{correlation_features_resnet18}
  \caption{Feature correlation matrix on CIFAR-10 with ResNet18}
  \label{fig:feature_corr_resnet18}
\end{figure}



We investigate the effects of orthogonal and decorrelation constraints  and .
Figure \ref{fig:feature_corr_resnet18} illustrates the feature correlations of ID(tuned), IDFO, and IDFD on dataset CIFAR-10.
We see that IDFO clearly decorrelates features and
IDFD retains a moderate level of feature correlation between ID and IDFD.
Taken together with Figure \ref{fig:acc_overProcess}, these results suggest that the softmax formulation of IDFD alleviates the problem of strict orthogonality and enables stable representation learning.

\subsubsection{Investigation for Practical Use}
\label{subsubsec:expented}
We investigate the dependencies of  our method on networks through experiments on other networks: ConvNet \cite{DCCM},
VGG16 \cite{VGG16}, and ResNet34 \cite{He2015}.  Performance was evaluated using the CIFAR-10 dataset. Results listed in Table \ref{tab:results-archtecture} show that IDFD can work on various networks. IDFD outperforms ID(tuned), and FD term shows more obvious effect on these networks. 
We also confirm the effect of cooperation between  and  from the viewpoint of spectral clustering,
combinations of AE and  were evaluated in terms of clustering performance. We found that AE cannot benefit from  as  did. 
This result verified that  has a deep relation with , and IDFD is not a simple combination.
We also investigate the importance of data augmentation in performance through experiments. Due to the page limit, our extended experiments are given in Appendix \ref{expteriment_extend}. 

\begin{table}[h]
  \caption{Clustering results (\%) on various network architectures.}
  \label{tab:results-archtecture}
  \centering
  \scalebox{0.9}{\begin{tabular}{c|ccc|ccc|ccc|ccl}
    \toprule
    Network&\multicolumn{3}{|c|}{ConvNet}&\multicolumn{3}{c|}{VGG16}&\multicolumn{3}{c|}{ResNet18}&\multicolumn{3}{c}{ResNet34}\\ \hline
    Metric               &ACC  &NMI  &ARI              &ACC  &NMI  &ARI           &ACC  &NMI  &ARI             &ACC  &NMI  &ARI             \\
    \midrule
    ID(tuned)                   &26.8 &15.0 &8.9              &39.3 &31.6 &20.9          &77.6 &68.2 &61.6            &80.2 &71.1 &64.6            \\
    IDFD                 &42.0 &32.7 &23.2             &56.8 &46.7 &36.5          &81.5 &71.1 &66.3            &82.7 &73.4 &68.4          \\
  \bottomrule
\end{tabular}}
\end{table}


\section{Conclusion}
We present a clustering-friendly representation learning method combining instance discrimination and feature decorrelation based on spectral clustering properties.
Instance discrimination learns similarities among data and feature decorrelation removes redundant correlation among features. We analyzed why instance discrimination works for clustering and clarified the conditions. We designed a softmax-formulated feature decorrelation constraint for learning the latent space to realize stable improvement of clustering performance. We also explained the connection between our method and spectral clustering.
The proposed representation learning method achieves accuracies comparable to state-of-the-art values on the CIFAR-10 and ImageNet-10 datasets with simple -means. 
We also verified IDFD loss works on multiple neural network structures, and our method is expected to be effective for various kinds of problems. 















\bibliography{refe}
\bibliographystyle{iclr2021_conference}
\newpage
\appendix
\appendix
\pagenumbering{arabic}
\section*{Appendices}

\section{Datasets and Experimental Setup}
\label{appendix_dataset}
Five datasets were used to conduct experiments:
{\bf CIFAR-10} \cite{krizhevsky2009learning}, {\bf CIFAR-100} \cite{krizhevsky2009learning}, {\bf STL-10} \cite{coates2011analysis}, {\bf ImageNet-10} \cite{deng2009imagenet}, and {\bf ImageNet-Dog} \cite{deng2009imagenet}. Table \ref{tab:dataList} lists the numbers of images, number of clusters, and image sizes of these datasets. Specifically, the training and testing sets of dataset STL-10 were jointly used in our experiments. Images from the three ImageNet subsets were resized to . 

\begin{table}[h]
  \caption{Image datasets used in experiments.}
  \label{tab:dataList}
  \centering
  \begin{tabular}{cccl}
    \toprule
    Dataset&Images&Clusters&Image size\\
    \midrule
    CIFAR-10 \cite{krizhevsky2009learning} & 50,000 & 10 &  \\
    CIFAR-100 \cite{krizhevsky2009learning} & 50,000 & 20 &  \\
STL-10 \cite{coates2011analysis} & 13,000 & 10 &  \\
    Imagenet-10 \cite{deng2009imagenet} & 13,000 & 10 &  \\
    Imagenet-Dog \cite{deng2009imagenet} & 19,500 & 15 &  \\
\bottomrule
\end{tabular}
\end{table}

We adopted ResNet \cite{He2015} as the neural network architecture in our main experiments. For simplicity, we used ResNet18, which according to our preliminary experiments yields sufficiently high performance. The same architecture was used for all datasets except the input layer. In accordance with the experimental settings of \cite{wu2018unsupervised}, the dimension of latent feature vectors was set to , and a stochastic gradient descent optimizer with momentum  was used. The learning rate  was initialized to , then gradually scaled down after the first  epochs using a coefficient of  every  epochs. The total number of epochs was set to , and the batch size was set to . Orthogonality constraint weights for IDFO were  for CIFAR-10 and CIFAR-100 and  for the STL-10 and ImageNet subsets. The weight for IDFO  was set according to the orders of magnitudes of the two losses  and . For IDFD, the weight  was simply fixed at . In the main experiments, we set the default temperature parameter value  for ID(tuned), IDFO, and IDFD, and  for IDFD. 


\section{Optimal Solutions of Clustering and Instance Discrimination}
\label{appendix_compact_uniform}
In Section \ref{subsubsec:analyzeTau}, we concluded that minimizing  under the condition that  is large can reach a clustering-friendly solution.
Details about the analysis and calculation was demonstrated by a two-dimensional toy model as follows.

Empirically, we observe that visually similar images tend to get similar assignment probabilities. Similar images can thus be projected to close locations in the latent space. This also motivated ID \cite{wu2018unsupervised}. In the case of ID, similar images  and  yield respective highest probabilities  and , and also receive relatively high  and  values. This property can retain over the process of approximation to the optimal solution. Because instance-level discrimination tries to maximally scatter embedded features of instances over the unit sphere \cite{wu2018unsupervised}, all representations are thus uniformly spread over the latent space with each representation relatively similar to its surroundings, we call this {\it uniform} case. We also consider another case that yields an optimal clustering solution where all samples from the same class are compacted to one point and  clusters are uniformly spread over the space. We call this {\it compact} case. Figure \ref{fig:uniform_compact} shows the representation distributions in the two cases. Because we normalize , two-dimensional representations form a circle. 



\begin{figure}[htbp]
\begin{tabular}{lr}
\begin{minipage}{0.55\hsize}
\begin{center}
\includegraphics[width=\hsize]{uniform_compact}
\caption{Two extreme cases of representation distributions over two-dimensional space. Left: {\it uniform}. Right: {\it compact}. } 
\label{fig:uniform_compact}
\end{center}
\end{minipage}
\begin{minipage}{0.35\hsize}
\begin{center}
\includegraphics[width=\hsize]{integral}
\caption{ with different  settings.} 
\label{fig:integral}
\end{center}
\end{minipage}
\end{tabular}
\end{figure}

In the {\it uniform} case,  representations are uniformly located on a circle with an angular interval of , and the inner product between two neighboring representations is . Without loss of generality, we can start with an arbitrary point  and orderly mark all samples as . The cosine similarity between  and  can then be calculated by . Accordingly, the loss contributed by sample  in the uniform case can be calculated as



Similarly, in the {\it compact} case,  data from the same class are exactly compacted to a point and  corresponding points located on a circle at an angular interval of .  The inner product between an arbitrary start sample  and the -th sample can be calculated as , where . The probability of assigning  to the cluster with  becomes . Accordingly, the loss contributed by sample  in the compact case can be calculated as


Comparing Eq. (\ref{eq:Linst-i-uniform}) and (\ref{eq:Linst-i-compact}), we see that the difference between  and  comes only from the denominator part of the logarithm. These are two discrete forms of the same integral . Clearly,  equals  when . We therefore need to consider only the general case where  is sufficiently large and .

Figure \ref{fig:integral} shows a plot of function values  with different  settings over the domain . We can see that the curve becomes flatter as  increases. 
A flat function  means that for an arbitrary  pair in its domain of definition, we have . In this situation even , the difference between the summations of these two discrete functions is not large. Accordingly, we can say  is approximate to  for a large . In other words, minimizing  can approach the compact situation where same-class samples assemble and differing samples separate. Learning instance-level discrimination for clustering is therefore reasonable.


\section{Extended Experiments}
\label{expteriment_extend}
In Section \ref{subsubsec:expented}, we have reported some investigations of our method for practical use. Details about several important experiments are supplemented as follows.

\subsection{Impact of Network Architecture}
As Table \ref{tab:results-archtecture} shows, IDFD can be applied to various networks, and the performance gaps between IDFD and ID(turned) on networks like ConvNet \cite{DCCM} and VGG16 \cite{VGG16} are more significant than on ResNet \cite{He2015}. 
We added the feature correlation matrix of VGG16 in Figure \ref{fig:feature_corr_vgg16}.
IDFD on VGG16 obtained sparse correlations similar to the case of ResNet18 in Figure~\ref{fig:feature_corr_resnet18}, while ID on VGG16 obtained denser and stronger correlations than ResNet18, presumably constructing redundant features that degraded clustering.
In the case of VGG16, the feature decorrelation term  exhibits a larger effect on clustering performance than that of ResNet.
Our proposed losses work on all network architectures, and we expect to introduce the losses to various networks that are suitable for individual problems. 

\begin{figure}[h]
  \centering
  \includegraphics[width=\linewidth]{correlation_features_vgg16}
  \caption{Feature correlation matrix learned by VGG16 on CIFAR-10.}
\label{fig:feature_corr_vgg16}
\end{figure}

\subsection{Combination of Autoencoder and Feature Decorrelation}
In order to further confirm the cooperation effect of instance discrimination and feature decorrelation from the viewpoint of spectral clustering, a combination of autoencoder and feature decorrelation was evaluated in terms of clustering performance. Autoencoder has been verified by datasets such as handwritten digits to be an effective method for deep clustering. In this experiment, we used ConvNet \cite{DCCM} for the autoencoder architecture and trained it on the CIFAR-10 dataset. We applied -means to representations learned from autoencoder only and autoencoder combined with feature decorrelation, which are called AE and AEFD, respectively. According to our experiments, the ACC value of AE was , and the ACC value of AEFD was . Compared to the improvement from ID to IDFD (from  to  as shown in Table \ref{tab:results-archtecture}), we see that AE cannot benefit from FD as ID. This result again indicates that FD has a deep relation with ID as we analyzed in Section \ref{sec:method}.

\subsection{Impact of Data Augmentation}
For reproduction of our results and practical use, we note that data augmentation (DA) has strong impact on the performance.
DA is known to have impact on image classification and representation learning.
Like in \cite{wu2018unsupervised}, several generic and accepted techniques, such as cropping and grayscale, were used for data augmenting in this work. The details of the augmentation in the original code can be linked to \cite{wu2018unsupervised}. In order to investigate the impact of DA, we conducted experiments on five datasets with and without DA and compared their clustering results.
Table \ref{tab:results-da} shows the results. 
We can see that methods without DA suffered significant performance degradations for clustering, as well as for classification \cite{simCLR}. This reminds us not to ignore the effects of DA in practical use.

\begin{table}[h]
  \caption{Clustering results (\%) with or without data augmentation on five datasets.
  }
  \label{tab:results-da}
  \centering
  \scalebox{0.75}{\begin{tabular}{c|ccc|ccc|ccc|ccc|ccc}
    \toprule
    Dataset      &\multicolumn{3}{|c|}{CIFAR-10}&\multicolumn{3}{c|}{CIFAR-100}&\multicolumn{3}{c|}{STL-10}&\multicolumn{3}{c|}{ImageNet-10}&\multicolumn{3}{c}{ImageNet-Dog}\\ \hline
    Metric       &ACC  &NMI  &ARI         &ACC  &NMI  &ARI          &ACC  &NMI  &ARI      &ACC  &NMI  &ARI                 &ACC  &NMI  &ARI \\
    \midrule
    ID W/O DA    &18.7 &9.5  &4.1         &14.8 &10.7 &3.2          &19.6 &9.0  &3.7      &23.6 &14.1 &6.2                 &12.7 &4.6  &1.9 \\
    IDFD W/O DA  &23.6 &12.1  &6.0       &16.2 &11.6 &4.4          &24.8 &17.6 &8.3     &37.2 &23.8 &15.6                 &15.5 &5.5  &2.5 \\
    ID With DA   &76.6 &65.7 &58.3        &36.7 &35.7 &21.9        &57.1 &49.0 &36.8     &85.8 &79.1 &70.5                &29.4 &16.0 &28.5 \\
IDFD With DA&81.5&71.1&66.3		&42.5&42.6& 26.4		& 75.6& 64.3& 57.5		& 95.4& 89.8& 90.1	&59.1&54.6&41.3\\
  \bottomrule
\end{tabular}}
\end{table}

\begin{figure}[h]
  \centering
  \includegraphics[width=.7\linewidth]{DA_cifar10}
  \caption{Effect of each technique used for DA on CIFAR-10. } 
  \label{fig:da_effect}
\end{figure}


To further find out main factors affecting the performance, we also executed experiments by removing each technique used for DA. Take the example of CIFAR-10, techniques used for data augmentation include: {\it ColorJitter}, {\it RandomResizedCrop}, {\it RandomGrayscale}, and {\it RandomHorizontalFlip}. All these techniques are generic and easy to be implemented. They have been integrated into general deep learning frameworks such as PyTorch. According to our experimental results as shown in Figure \ref{fig:da_effect}, we find that {\it RandomResizedCrop}, {\it RandomGrayscale}, and {\it ColorJitter} have strong effect on image clustering.


For practice, we also applied IDFD to our private images produced by manufacturing process. Generic DA like above were used to these images. IDFD showed good performance on these images according to our experiments. This indicates that our method can be simply applied to practical images.
For other types of data such as text and time series, corresponding data augmentation techniques are needed to cooperate with our method.








 

\end{document}
