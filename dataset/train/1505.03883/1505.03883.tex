\documentclass[10pt,conference]{IEEEtran}


\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
\renewcommand\thesubsubsection{\thesubsection.\arabic{subsubsection}}

\renewcommand\thesectiondis{\arabic{section}}
\renewcommand\thesubsectiondis{\thesectiondis.\arabic{subsection}}
\renewcommand\thesubsubsectiondis{\thesubsectiondis.\arabic{subsubsection}}


\usepackage{verbatim} 
\usepackage{clrscode3e}
\usepackage[pdftex]{graphicx}
\usepackage{setspace}
\usepackage[cmex10]{amsmath}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{subfig}
\usepackage{caption}
\usepackage{paralist}
\usepackage{cases}
\usepackage{cite}
\usepackage{etoolbox}

\usepackage{tikz}

\usepackage{color}

\newcommand{\ceiling}[1]{\left\lceil{#1}\right\rceil}
\newcommand{\floor}[1]{\left\lfloor{#1}\right\rfloor}
\newcommand{\setof}[1]{\left\{{#1}\right\}}
\newcommand{\set}[2]{\{{#1}\mid{#2}\}}

\newcommand{\jj}[1]{\textcolor{blue}{jj: #1 : endjj}}
\newcommand{\kh}[1]{\textcolor{magenta}{kevin: #1 : endkevin}}
\newcommand{\frameworkkq}[1]{}
\newcommand{\frameworkku}[1]{}
\newcommand{\Cong}[1]{\textcolor{red}{cong: #1 : endcong}}


\def\myendproof{{\ \vbox{\hrule\hbox{\vrule height1.3ex\hskip0.8ex\vrule}\hrule }}\par}
 \renewenvironment{proof}{\noindent{\bf Proof. }}{\myendproof}
\newenvironment{appProof}[1]{\noindent{\bf Proof of
     #1. }}{\myendproof\vskip 0.1in}


 \setboolean{ALC@noend}{true}
\providebool{techreport}
\setbool{techreport}{true}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{example}{Example}
\newtheorem{claim}{Claim}
\newtheorem{definition}{Definition}
\newtheorem{rrule}{Rule}
\newtheorem{remark}{Remark}
\newtheorem{observation}{Observation}

\graphicspath{{fig/multiframe/}{fig/arbitrary/}{fig/dag/}} 







\ifbool{techreport}{
\addtolength{\textheight}{14pt}
}{
\addtolength{\textheight}{6pt}
}
\newcommand{\citetechreport}[1]{\ifbool{techreport}{}{ in the report \cite{DBLP:journals/corr/abs-k2q}}}



\usetikzlibrary{arrows,shapes.misc,shapes.arrows,chains,matrix,positioning,scopes,decorations.pathmorphing,shadows}

\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}
\tikzstyle{materia}=[draw, fill=white, text width=1.0em, text centered,
  minimum height=4em,drop shadow]
\tikzstyle{practica} = [materia, text width=18em, minimum width=8em,
align =left,
  minimum height=3em, rounded corners, drop shadow]
\tikzstyle{texto} = [above, text width=6em, text centered]
\tikzstyle{linepart} = [draw, thick, color=blue!50, -latex', dashed]
\tikzstyle{line} = [draw, line width = 2pt, color=blue!50, -latex']
\tikzstyle{ur}=[draw, text centered, minimum height=0.01em]
\newcommand{\blockdist}{1.3}
\newcommand{\edgedist}{1.5}

\newcommand{\practica}[2]{node (p#1) [practica]
  {\\{\footnotesize{#2}}}}

\newcommand{\background}[5]{\begin{pgfonlayer}{background}
\path (#1.west |- #2.north)+(-0.5,0.5) node (a1) {};
\path (#3.east |- #4.south)+(+0.5,-0.25) node (a2) {};
\path[fill=yellow!20,rounded corners, draw=black!50, dashed]
      (a1) rectangle (a2);
    \path (a1.east |- a1.south)+(0.8,-0.3) node (u1)[texto]
{#5};
  \end{pgfonlayer}}

\newcommand{\backgroundB}[5]{\begin{pgfonlayer}{background}
\path (#1.west |- #2.north)+(-0.5,0.5) node (a1) {};
\path (#3.east |- #4.south)+(+0.5,-0.25) node (a2) {};
\path[fill=red!20,rounded corners, draw=black!50, dashed]
      (a1) rectangle (a2);
    \path (a1.east |- a1.south)+(0.5,-0.3) node (u1)[texto]
{#5};
  \end{pgfonlayer}}

\newcommand{\transreceptor}[3]{\path [linepart] (#1.east) -- node [above]
    {\scriptsize Transreceptor #2} (#3);}

\ifbool{techreport}{
\pagestyle{plain}
}{
\pagestyle{empty}
}

\title{\huge \textbf{\textrm{kQ}}: A Quadratic-Form Response Time and Schedulability Analysis Framework for Utilization-Based Analysis}

\author{
    Jian-Jia Chen and Wen-Hung Huang\\
    Department of Informatics\\
    TU Dortmund University, Germany
    \and
    Cong Liu\\
    Department of Computer Science\\
    The University of Texas at Dallas
}
\vspace{3mm}



\begin{document}

\maketitle

\ifbool{techreport}{
\thispagestyle{plain}
}{
\thispagestyle{empty}
}


\begin{abstract}
  In this paper, we present a general response-time analysis and
  schedulability-test framework, called \frameworkkq{} (k to Q). It
  provides automatic constructions of closed-form quadratic bounds or
  utilization bounds for a wide range of applications in real-time
  systems under fixed-priority scheduling. The key of the framework is
  a -point schedulability test or a -point response time
  analysis that is based on the utilizations and the execution times
  of  higher-priority tasks.  The natural condition of
  \frameworkkq{} is a quadratic form for testing the schedulability
  or analyzing the response time. The response time analysis and the
  schedulability analysis provided by the framework can be viewed as a
  ``blackbox'' interface that can result in sufficient
  utilization-based analysis.  Since the framework is independent from
  the task and platform models, it can be applied to a wide range of applications.
\ifbool{techreport}{

We show the generality of \frameworkkq{} by
  applying it to several different task models. \frameworkkq{} produces better uniprocessor and/or multiprocessor schedulability tests  not only for the traditional sporadic task model, but also
   more expressive task models such as the generalized multi-frame task model and the acyclic task model.  Another interesting contribution is that in the past, exponential-time schedulability tests were typically
  not recommended and most of time ignored due to high
  complexity. We have successfully shown that
  exponential-time schedulability tests may lead to good
  polynomial-time tests (almost automatically) by using the
  \frameworkkq{} framework.}{} \ifbool{techreport}{Analogously, a similar concept to test
  only  points with a different formulation has been studied by us in
  another framework, called \frameworkku{}, which provides hyperbolic
  bounds or utilization bounds based on a different formulation of
  schedulability test.  With the quadratic and hyperbolic expressions,
  \frameworkkq{} and \frameworkku{} frameworks can be used to provide
  many quantitive features to be measured, like the total utilization
  bounds, speed-up factors, etc., not only for uniprocessor scheduling
  but also for multiprocessor scheduling. }{}
\end{abstract} 

\section{Introduction}
\label{sec:intro}

Analyzing the worst-case timing behaviour to ensure the timeliness of
embedded systems is essential for building reliable and dependable
components in cyber-physical systems. Due to the interaction and
integration with external and physical devices, many real-time and
embedded systems are expected to handle a large variety of
workloads. Towards such dynamics, several formal
real-time task models are established to represent these workloads with various
characteristics, such as the the generalized multi-frame task
model \cite{DBLP:journals/rts/BaruahCGM99,DBLP:conf/ecrts/StiggeY12} and the self-suspending task model~\cite{suspension}. 
\ifbool{techreport}{
To analyze the worst-case response time or to ensure the timeliness of
the system, for each of these task models, researchers tend to develop
dedicated techniques that result in schedulability tests with
different computation complexity and accuracy of the
analysis. Although many successful results have been developed, after
many real-time systems researchers devoted themselves for many years,
there does not exist a general framework that can provide  efficient and
effective analyses for different task models.}{
Although many successful results have been developed, after
many real-time systems researchers devoted themselves for many years,
there does not exist a general framework that can provide efficient analyses for different task models.
 For analysis techniques developed over the years for analyzing different task models (exhibiting different characteristics though), redundancy may exist in them because many of the developed techniques tend to apply several fundamental analysis frameworks such as the response time analysis and the busy-window analysis  \cite{DBLP:conf/rtss/Lehoczky90}. Our motivation behind this paper is: can we design a general, powerful, yet easy-to-use schedulability analysis framework that is applicable to a wide selection of real-time task models?
}


\ifbool{techreport}{
Prior to this paper, we have presented a  general
schedulability analysis framework \cite{DBLP:journals/corr/abs-1501.07084,ChenHLRTSS2015}, called \frameworkku{}, that can be applied
in uniprocessor scheduling and multiprocessor scheduling, as long as
the schedulability condition can be written in a specific form to
test only  points.  For example, to verify the schedulability of a
(constrained-deadline) sporadic real-time task  under fixed-priority scheduling
in uniprocessor systems, the time-demand analysis (TDA) developed in
\cite{DBLP:conf/rtss/LehoczkySD89} can be adopted.


}{
Motivated by this, we present in this paper a rather general
schedulability analysis framework, called \frameworkkq{} (k to Q), that can be applied
in uniprocessor and multiprocessor scheduling for analyzing various real-time task models. }
The general concept to obtain sufficient schedulability tests in
the 
\frameworkkq{} framework is to test only a subset of time
points for verifying the schedulability. This idea is implemented in
the \frameworkkq{} framework by providing a -point last-release
schedulability test, which only needs to test  points under
\textit{any} fixed-priority scheduling when checking schedulability of
the task with the  highest priority in the system.  Moreover,
this concept is further extended to provide a safe
upper bound of the worst-case response time. The response time
analysis and the schedulability analysis provided by the framework can
be viewed as a ``blackbox'' interface that can result in sufficient
utilization-based analysis. 







\noindent\textbf{Related Work.}
There have been several results in the literature with respect to utilization-based, e.g., \cite{liu1973scheduling,HanTyan-RTSS97,journals/tc/LeeSP04,DBLP:conf/rtas/WuLZ05,kuo2003efficient,bini2003rate,RTSS14a}, and non-utilization-based, e.g., \cite{DBLP:conf/rtss/ChakrabortyKT02,DBLP:conf/ecrts/FisherB05}, schedulability tests for the sporadic real-time task model and its generalizations in uniprocessor systems.
Most of the existing utilization-based schedulability analyses focus
on the total utilization bound. That is, if the total utilization of
the task system is no more than the derived bound, the task system is
schedulable by the scheduling policy. For example, the total
utilization bounds derived in
\cite{liu1973scheduling,HanTyan-RTSS97,DBLP:dblp_journals/tc/BurchardLOS95}
are mainly for rate-monotonic (RM) scheduling, in which the results in
\cite{HanTyan-RTSS97} can be extended for arbitrary fixed-priority
scheduling. Kuo et al. \cite{kuo2003efficient} further improve the
total utilization bound by using the notion of divisibility. Lee et
al. \cite{journals/tc/LeeSP04} use linear programming formulations for
calculating total utilization bounds when the period of a task can be selected.
Moreover, Wu et al. \cite{DBLP:conf/rtas/WuLZ05} adopt the
Network Calculus to analyze the total utilization bounds of several
real-time task models. 

Bini and Buttazzo \cite{DBLP:journals/tc/BiniB04} propose a framework
of schedulability tests that can be tuned to balance the time
complexity and the acceptance ratio of the schedulability test for
uniprocessor sporadic task systems.  The efficient tests in
\cite{DBLP:journals/tc/BiniB04} are based on an observation to test
whether the parameters of a task set fall into a schedulable region of
the fixed-priority scheduling policy.  Our strategy and philosophy are
simpler than \cite{DBLP:journals/tc/BiniB04}.  First, we only look at
the parameters of task  (the task defined as the 
highest priority) that is under analysis by assuming that the
higher-priority tasks are already verified to be schedulable. Second,
similar to our recent general schedulability analysis framework
\frameworkku{} \cite{ChenHLRTSS2015}, we also apply the key idea of evaluating only 
points.  The tunable strategies in \cite{DBLP:journals/tc/BiniB04}
consider to examine a subset of the time points for schedulability
tests.

Distinct from the results in \cite{DBLP:journals/tc/BiniB04}, our
objective in this paper is to find closed-form schedulability tests
and response-time analyses that can be independent from task and
platform models. We target at sufficient schedulability tests and response time analyses that are not exact but can be calculated efficiently in linear-time or polynomial-time complexity.
\ifbool{techreport}{

\noindent{\bf Comparison to \frameworkku{}:} 
Even though \frameworkkq{} and \frameworkku{} share the
same idea to test and evaluate only  points, they are based on
completely different criteria for testing.  In \frameworkku{}, all the testings and
formulations are based on \emph{only the higher-priority task
  utilizations}. In \frameworkkq{}, the testings are based \emph{not
  only on the higher-priority task utilizations, but also on the
  higher-priority task execution times}.  The above difference
in the formulations results in completely different properties and
mathematical closed-forms.  The
natural condition of \frameworkkq{} is a \emph{quadratic form} for testing
the schedulability  or the response
time of a task, whereas the natural condition of \frameworkku{} is a
\emph{hyperbolic form} for testing the schedulability of a task.

\emph{If one framework were dominated by another or these two frameworks
were just with minor difference in mathematical formulations, it
wouldn't be necessary to separate and present
them as two different frameworks.} Both frameworks are in fact needed
and have to be applied for different cases.  Here,
we only shortly explain their differences,
advantages, and disadvantages in this paper.  For completeness, another
document has been prepared in
\cite{DBLP:journals/corr/framework-compare} to present the similarity,
the difference and the characteristics of these two frameworks in details.

Since the formulation of \frameworkku{} is more restrictive than
\frameworkkq{}, its applicability is limited by the possibility to
formulate the tests purely by using higher-priority task utilizations
without referring to their execution times. There are cases, in which
formulating the higher-priority interference by using only task
utilizations for \frameworkku{} is troublesome or over-pessimistic. For such cases,
further introducing the upper bound of the execution time by using
\frameworkkq{} is more precise. Most of the presented cases, except the one in
uniprocessor constrained-deadline systems in Appendix
B\citetechreport{} are in the above category.
Although \frameworkkq{} is more general, it is not as precise as
\frameworkku{}, if we can formulate the schedulability tests into both
frameworks with the same parameters.  In such cases, the same
pseudo-polynomial-time (or exponential time) test is used, and the
utilization bound or speed-up factor analysis derived from the \frameworkku{} framework is, in general,
tighter and better.


In a nutshell, \frameworkkq{} is more general, whereas \frameworkku{} is
more precise. If an exact schedulability test can
be constructed and the test can be converted into \frameworkku{},
e.g., uniprocessor scheduling for constrained-deadline task sets,
then, adopting \frameworkku{} leads to tight results. For example, by using
\frameworkkq{}, we can reach the conclusion that the utilization bound
for rate-monotonic scheduling is , which is
less precise than the Liu and Layland bound ,
 a simple implication by using \frameworkku{}. However, if we
are allowed to change the execution time and period of a task for
different job releases (called acyclic task model in
\cite{DBLP:journals/tc/AbdelzaherSL04}), then the tight utilization bound
 can be easily achieved by using \frameworkkq{}. 

Due to the fact the \frameworkku{} is more precise (with respect to the utilization bound) when the exact
tests can be constructed, even though \frameworkku{} is more
restrictive, both are needed for different
cases. Both \frameworkku{} and \frameworkkq{} are general enough to cover a range of spectrum of
applications, ranging from uniprocessor systems to multiprocessor
systems.  For more information and comparisons, please refer to
\cite{DBLP:journals/corr/framework-compare}.

}{
Although the objective is similar to \frameworkku{}, 
\frameworkkq{} in this paper applies completely different criteria from
\frameworkku{} for testing purposes. In \frameworkku{}, all the
testings and formulations are based on \emph{only the higher-priority
  task utilizations}. In \frameworkkq{}, the testings are based
\emph{not only on the higher-priority task utilizations, but also on
  the higher-priority task execution times}.  The above difference in
the formulations results in completely different properties and
mathematical closed-forms.  The natural condition of \frameworkkq{} is
a \emph{quadratic form} for testing the schedulability, whereas the
natural condition of \frameworkku{} is a \emph{hyperbolic form} for
testing the schedulability or the response time of a task.

The  \frameworkkq{} and \frameworkku{} frameworks do not dominate each other, and should be applied for different cases (i.e., some task models are better handled by one framework than the other).\footnote{For completeness, another document has been prepared in \cite{DBLP:journals/corr/framework-compare} to present the similarity, the difference and the characteristics of these two frameworks in details.}
Since the formulation of \frameworkku{} is more restrictive than
\frameworkkq{} (due to using only higher-priority task utilizations
without referring to their execution times), there are cases, in which
formulating the higher-priority interference by using only task
utilizations for \frameworkku{} is troublesome or over-pessimistic. For such cases,
further introducing the upper bound of the execution time by using
\frameworkkq{} is more precise. 
}



\noindent\textbf{Contributions.}
The key contribution of this paper is a general schedulability and
response-time analysis framework, \frameworkkq{}, that can be easily applied to
analyze a number of complex real-time task models, on both
uniprocessor and multiprocessor systems. 
A key novelty of \frameworkkq{} that allows a rather general analysis framework is that we
do not specifically seek for the total utilization bound. Instead, we
look for the critical value in the specified sufficient schedulability
test while verifying the schedulability of task . This
critical value of task  gives the difficulty of task 
to be schedulable under the scheduling policy. 
We present several properties of \frameworkkq{}, which
provide a series of closed-form solutions to be adopted
for sufficient tests and worst-case response time analyses for
real-time task models, as long as a corresponding -point last-release
schedulability test (Definition~\ref{def:kpoints}) or a -point last-release
response-time analysis (Definition~\ref{def:kpoints-response}) can be
constructed.  \ifbool{techreport}{The generality of \frameworkkq{} is
supported by demonstrating that either new or better results compared to the
state-of-the-art can be easily obtained using \frameworkkq{}.}{Due to
the space constraint, we are only able to provide some simple examples in this paper. More comprehensive examples and applications can be found in the report in     \cite{DBLP:journals/corr/abs-k2q}. The detailed evaluations,
    compared to other approaches, are in
    \cite{DBLP:journals/corr/framework-compare}.} 
\ifbool{techreport}{
Examples include: 
\begin{itemize}
\item Several utilization-based schedulability and response analyses
  for uniprocessor sporadic task systems are provided in Section
  \ref{sec:sporadic}\ifbool{techreport}{}{ and with more complete
    results in Appendix B in \cite{DBLP:journals/corr/abs-k2q}.}  The
  utilization-based worst-case response-time analysis in
  Theorem~\ref{theorem:response-time-sporadic} in Section
  \ref{sec:sporadic} is identical to the response-time analysis by
  Bini et al. \cite{bini-RTSS2015} developed in parallel.
\item We improve the schedulability tests in multiprocessor global
  fixed-priority scheduling in Appendix C. A
  general condition is a quadratic bound. Specifically, we show that the
  speed-up (capacity augmentation) factor of global RM is
   for implicit-deadline sporadic
  task systems, which improves upon the existing best speed-up factor  presented in \cite{DBLP:conf/opodis/BertognaCL05}. \item We provide, to the best of our knowledge, the first polynomial-time
  worst-case response time analysis for sporadic real-time tasks with
  jitters \cite{DBLP:conf/rtss/BaruahCM97,238595} in
  \ifbool{techreport}{Appendix D.}{Appendix D in \cite{DBLP:journals/corr/abs-k2q}.}
\item We also demonstrate how to convert
  exponential-time schedulability tests of generalized multi-frame
  task models
  \cite{DBLP:journals/rts/BaruahCGM99,DBLP:conf/rtcsa/TakadaS97} to
  polynomial-time tests by using the \frameworkkq{} framework in 
  \ifbool{techreport}{Appendix E.}{Appendix E in \cite{DBLP:journals/corr/abs-k2q}.}
\item The above results are for task-level fixed-priority scheduling
  policies. We further explore mode-level fixed-priority scheduling
  policies by
  studying the acyclic task model
  \cite{DBLP:journals/tc/AbdelzaherSL04} and the multi-mode task model
  \cite{DBLP:conf/rtas/DavisFPS14}.\ifbool{techreport}{\footnote{Although
    the focus in \cite{DBLP:conf/rtas/DavisFPS14} is for
    variable-rate-behaviour tasks, we will refer such a model as a
    multi-mode task model.}}{} We conclude a
  quadratic bound and a utilization bound  for RM
  scheduling policy. The utilization bound is the same as the result in
  \cite{DBLP:journals/tc/AbdelzaherSL04}. They can be further
  generalized to handle more generalized task models,
including the digraph task model \cite{DBLP:conf/rtas/StiggeEGY11},
the recurring real-time task model \cite{DBLP:conf/rtss/Baruah10}. 
   This is presented in
  \ifbool{techreport}{Appendix F.}{Appendix F in \cite{DBLP:journals/corr/abs-k2q}.}
\end{itemize}
}{
}


\ifbool{techreport}{The emphasis of this paper is to show the generality of the
\frameworkkq{} framework by demonstrating via several task models. The
tests and analytical results in the framework are with low
complexity, but can still be shown to provide good results through
speed-up factor or utilization bound analyses.  We also note a somehow surprising finding through developing this framework: 
 \emph{in the past, exponential-time schedulability tests were typically
  not recommended and most of time ignored, as this requires very high
  complexity. We have successfully shown in this paper that
  exponential-time schedulability tests may lead to good
  polynomial-time tests (almost automatically) by using the
  \frameworkkq{} framework. Therefore, this framework may also open the
possibility to re-examine some tests with exponential-time complexity to improve their 
applicability.}}{}



\section{Basic Task and Scheduling Models}
\label{sec:model}

This section presents the sporadic real-time task model, as the basis
for our presentations. Even though the framework targets at more
general task models, to ease the presentation flow, we will start with
the sporadic task models.  A sporadic task  is released
repeatedly, with each such invocation called a job. The  job
of , denoted , is released at time  and
has an absolute deadline at time . Each job of any task
 is assumed to have execution time . Here in this paper,
whenever we refer to the execution time of a job, we mean for the
worst-case execution time of the job, since all the analyses we use are safe by only considering the worst-case execution time.  The response time of a job is
defined as its finishing time minus its release time. Successive jobs
of the same task are required to be executed in sequence. Associated with
each task  are a period , which specifies the minimum
time between two consecutive job releases of , and a deadline
, which specifies the relative deadline of each such job, i.e.,
. The worst-case response time of a task 
is the maximum response time among all its jobs. 
The utilization of a task  is defined
as .



A sporadic task system  is an implicit-deadline
system if  holds for each . A sporadic task system
 is a constrained-deadline system if 
holds for each .  Otherwise, such a sporadic task system
 is an arbitrary-deadline system.

A task is said \emph{schedulable} by a scheduling policy if all of its
jobs can finish before their absolute deadlines, i.e., the worst-case
response time of the task is no more than its relative deadline.  A
task system is said \emph{schedulable} by a scheduling policy if all
the tasks in the task system are schedulable. A \emph{schedulability
  test} expresses sufficient schedulability conditions to ensure the feasibility
of the resulting schedule by a scheduling policy. 


Throughout the paper, we will focus on fixed-priority preemptive
scheduling. That is, each task is associated with a priority level\ifbool{techreport}{ (except in Appendix F).}{.}
For a uniprocessor system, the scheduler always dispatches the job
with the highest priority in the ready queue to be executed.  For a
multiprocessor system, we consider multiprocessor global scheduling on
 identical processors, in which each of them has the same
computation power. For global multiprocessor scheduling, there is a
global queue and a global scheduler to dispatch the jobs. We consider
only global fixed-priority scheduling. At any time, the
-highest-priority jobs in the ready queue are dispatched and
executed on these  processors.

Note that the framework is not only limited to the above task and platform models. These terminologies are introduced only for the simplicity of presentation and illustrating some examples. \ifbool{techreport}{}{The applications with other platform and task models can be found\citetechreport{}.}

\ifbool{techreport}{
\noindent{\bf Speed-Up Factor and Capacity Augmentation Factor:}
To quantify the error of the schedulability tests or
the scheduling policies, the concept of resource augmentation by using
speed-up factors \cite{Phillips:stoc97} and the capacity augmentation
factors \cite{Li:ECRTS14} has been adopted.  For example, global DM in
general does not have good utilization bounds to schedule a set of
sporadic tasks on  identical processors, due to ``Dhall's effect'' \cite{doi:10.1287/opre.26.1.127}.  However, if we constrain
the total utilization , the density  for each task , and the
maximum utilization , it is possible to provide the schedulability guarantee
of global RM by setting  to 
\cite{DBLP:conf/rtss/AnderssonBJ01,DBLP:conf/rtss/Baker03,DBLP:conf/opodis/BertognaCL05}. Such
a factor  has been recently named as a \emph{capacity augmentation
  factor} \cite{Li:ECRTS14}.  Note that the capacity augmentation
bound was defined without taking this simple condition

in \cite{Li:ECRTS14}, as they focus on implicit-deadline systems. For
constrained-deadline systems, adding such a new constraint is a
natural extension.

An algorithm  is with speed-up factor : \emph{ If there exists a feasible schedule for the task
    system, it is schedulable by algorithm  by speeding up
    (each processor) to  times as fast as in the original
    platform (speed).}
A sufficient schedulability test for scheduling
algorithm  is with speed-up factor :
\emph{If the task system cannot pass the sufficient
    schedulability test, the task set is not schedulable by any
    scheduling algorithm if (each processor) is slowed down to
     times of the original platform speed.}
Note that if the
capacity augmentation factor is , the speed-up factor is also
upper-bounded by .
}{}

\vspace{-2mm}
\section{Analysis Flow}
\label{sec:flow}

The framework focuses on testing the schedulability and the response
time for a task , under the assumption that the
required properties (i.e., worst-case response time or the
schedulability) of the higher-priority tasks are already verified and
provided. We will implicitly assume that all the higher-priority tasks
are already verified and the required properties are already obtained.
Therefore, this framework has to be applied for each of the given
tasks. To ensure whether a task system is schedulable by the given
scheduling policy, the test has to be applied for all the tasks.  Of
course, the results can be extended to test the schedulability of a
task system in linear time complexity or to allow on-line admission
control in constant time complexity if the schedulability condition
(or with some more pessimistic simplifications) is monotonic. Such
extensions are presented only for trivial cases.


We will only present the schedulability test of a certain task
, that is analyzed, under the above assumption. For
notational brevity, in the framework presentation, we will implicitly
assume that there are  tasks, say  with higher-priority than task . We will use
 to denote the set of these  higher-priority tasks,
when their orderings do not matter. Moreover, we only
consider the cases when , since  is pretty trivial.


\section{\frameworkkq{}}
\label{sec:framework}

This section presents the basic properties of the \frameworkkq{}
framework for testing the schedulability of task  in a given
set of real-time tasks (depending on the specific models given in each
application). Before presenting the
framework, we first give a simple example to explain the underlying
concepts by using an
implicit-deadline sporadic task system , in which  for every . The exact schedulability test to
verify whether task  can meet its deadline under
fixed-priority scheduling on uniprocessor systems is to check

where  is the set of tasks with higher priority than
. Instead of testing all the time points  in the range of
 and , for a sufficient schedulability test, we can greedily
only consider to test the time points  for
 and . If  holds in one of those
 tested time points, then we can conclude that  can be feasibly
scheduled under this scheduling policy.

To implement to above testing concept, we need two definitions: 1)
Definition \ref{def:lease-release} defines the last release time
ordering so that we can formulate the problem with linear algebra, 2)
Definition \ref{def:kpoints} defines an abstracted schedulability test
that can be used to model general schedulability tests regardless of
the task and platform model.
\begin{definition}[Last Release Time Ordering]
\label{def:lease-release}
Let  be the last release time ordering assignment as a bijective
function  to define the last release time ordering
of task  in the window of interest. Last release time orderings are
numbered from  to , i.e., , where 1 is the earliest and  the
latest. \myendproof
\end{definition}

The last release time ordering is a very important property in the
whole framework. When testing the schedulability or analyzing the
worst-case response time of task , we do not need the
priority ordering of the higher-priority tasks in
. But, we need to know how to order the  higher-priority tasks so that we can formulate the test with simple and linear arithmetics based on the total order.
For the rest of this paper, the ordering of the  higher-priority tasks implicitly refers to their last release time ordering (except explanations regarding the last release time ordering when referring to Example \ref{example-3tasks}).
In the \frameworkkq{} framework, we are only interested
to test only  time points. More precisely, we are only interested
to test whether task  can be successfully executed before the
last release time of a higher-priority task in the testing
window. Therefore, the last release time ordering provides a total
order so that we can transform the schedulability tests into the following definition. 


\begin{definition}
  \label{def:kpoints}
  
  A -point last-release schedulability test under a given last release time ordering
   of the  higher-priority tasks is a sufficient
  schedulability test of a fixed-priority scheduling policy, that verifies the existence of   with  such that 
   and 
  where , for , , , , and  are dependent upon the setting
  of the task models and task . \myendproof
\end{definition}


\begin{example}
  \label{example-1} {\bf Implicit-deadline task systems}: For an
  implicit-deadline sporadic task system , suppose that we are
  interested to test whether task  can meet its deadline or
  not under a fixed-priority scheduling algorithm on a uniprocessor
  platform. Let  be  and the tasks in  be
  ordered by  non-decreasingly,
  i.e., .  For a
  specific testing point at time  for a certain ,
  the function  (to quantify the
  workload due to the jobs released by a higher-priority task ) has two cases: 1) if , due to the definition of
   as  and , we know that  is upper bounded
  by ; 2) if , due to the definition of  as
   and , we
  know that  is upper bounded by
  .\footnote{Since  is an integer multiple of , the property  holds.}

  By the above analysis, for a given , we know that
  .  Therefore, we
  know that task  is schedulable by the fixed-priority
  scheduling if there exists  such that
  \normalsize  
  In other words, by the specific index rule of the tasks in
   and setting  and  for every task
   in , we reach a concrete example for
  Definition~\ref{def:kpoints}. \endproof
\end{example}



A concrete example is provided  here
for illustrating Example~\ref{example-1}.
\begin{example}\label{example-3tasks-v0}
  Consider that  and  is . For the two tasks in
  , let  and .  Suppose that .  By the transformation in
  Example~\ref{example-1}, we know that  and . The last release time ordering  of  follows the index, i.e., . Moreover, .
\hfill\myendproof
\end{example}

Similar to Definition~\ref{def:kpoints}, we can also define an
abstracted worst-case response time analysis as follows:
\begin{definition}
  \label{def:kpoints-response}
  A -point last-release response time analysis is a safe response time
  analysis of a fixed-priority scheduling policy under a given last release time
  ordering  of the  higher-priority tasks by finding the
  maximum
  
with  and
  
  where , , , , and  are dependent upon the setting
  of the task models and task . \myendproof
\end{definition}

\begin{example}
  \label{example-response-time} {\bf Response-time for
    constrained-deadline task systems}: Suppose that  is the
  exact worst-case response time for task  and  under uniprocessor
  fixed-priority scheduling. That is, by Eq.~\eqref{eq:TDA-implicit},
  
  for any  and . Similar to
  Example~\ref{example-1}, let  be  and the tasks in
   be ordered by 
  non-decreasingly, i.e., . With the same analysis in Example~\ref{example-1}, we know
  that 
  for  and . As a result, by the specific index rule of
  the tasks in  and setting  and 
  for every task  in , we reach a concrete example
  for Definition~\ref{def:kpoints-response}.
\endproof
\end{example}





\subsection{Important Notes} 
Before presenting the analyses based on Definition~\ref{def:kpoints}
and Definition~\ref{def:kpoints-response}, we would like to first
explain the important assumptions and the flow to use the analytical
results.  Throughout the paper, we implicitly assume that 
when Definition~\ref{def:kpoints} is used. Moreover, we
only consider non-trivial cases, in which  and  for . The definition of 
depends on how Definition~\ref{def:kpoints} is constructed based on
the original schedulability test, usually equal to the length of the
interval (of the points to be tested in the original schedulability test),
e.g.,  in Example~\ref{example-1}.  In most of the cases,
we can set  as . \ifbool{techreport}{
But, it can also be set to other cases, to
be demonstrated in Appendix C for global RM scheduling.  
}{But, it can also be set to other cases, which can be found\citetechreport{}. }


In Definition~\ref{def:kpoints}, the -point last-release
schedulability test is a sufficient schedulability test that tests
only  time points, defined by the  higher-priority tasks and
task . 
Similarly,  in Definition~\ref{def:kpoints-response}, a -point
last-release response time analysis provides a safe response time
by only testing whether task  has already finished earlier at
 points, each defined by a higher-priority task. 


In both cases in Definitions~\ref{def:kpoints} and
\ref{def:kpoints-response}, the last release time ordering  is
assumed to be given. In some cases, this ordering can be easily
obtained. For such cases, all the lemmas in this section can be directly adopted.
However, in most of the cases in our demonstrated task
models, we have to test all possible last release time orderings and
take the worst case. Fortunately, we will show that finding the
worst-case ordering is not a difficult problem, which requires to sort
the  higher-priority tasks under a simple criteria, in Lemmas~\ref{lemma:general-sorting} and~\ref{lemma:general-response-sorting}. 
Therefore, for such cases, the lemmas in this section have to be adopted by combining with Lemma~\ref{lemma:general-sorting}~or~\ref{lemma:general-response-sorting}.


We first assume that the corresponding coefficients  and
 in
Definitions~\ref{def:kpoints}~and~\ref{def:kpoints-response} are
given. How to derive them will be discussed in the following sections.
Clearly their values are highly dependent upon the task models and the
scheduling policies.  Provided that these coefficients ,
, ,  for every higher-priority task  are given, we analyze (1) the response time by finding the
extreme case for a given  (under
Definition~\ref{def:kpoints-response}), or (2) the schedulability by
finding the extreme case for a given  and . Therefore, the
\frameworkkq{} framework provides utilization-based schedulability
analyses and response time analyses automatically if the
corresponding parameters  and  can be defined to
ensure that the tests in Definitions~\ref{def:kpoints}
and~\ref{def:kpoints-response} are safe.

\frameworkkq{} can be used by a wide range of applications, as long
as the users can properly specify the corresponding task properties
 and  and the constant coefficients  and 
of every higher-priority task . More precisely, the formulation in
Definitions~\ref{def:kpoints} and \ref{def:kpoints-response} does not
actually care what  and  actually mean. When sporadic
task models are considered, we will use these two terms as they were
defined in Section~\ref{sec:model}, i.e.,  stands for the
execution time and   is . When we consider more
general cases, such as the generalized multi-frame and multi-mode task
models, we have to properly define the values of  and  to
apply the framework.

The use cases of \frameworkkq{} can be achieved by using
the known schedulability tests (that are in the form of pseudo
polynomial-time or exponential-time tests) or some simple modifications of the existing
results. \ifbool{techreport}{We will provide the explanations of the correctness of the
selection of the parameters,  for a
higher-priority task  to support the correctness of the
results.}{}  
Such a flow actually leads to the elegance and the
generality of the framework, which works as long as
Definition~\ref{def:kpoints} (Definition~\ref{def:kpoints-response},
respectively) can be successfully constructed for the sufficient
schedulability test (response time, respectively) of task  in
a fixed-priority scheduling policy. The procedure is illustrated in Figure~\ref{fig:framework}.
With the availability of the \frameworkkq{} framework, the quadratic
bounds or utilization bounds can be automatically derived as
long as the safe upper bounds  and  can be safely
derived, regardless of the task model or the platforms. 

\ifbool{techreport}{
We are not going to present how to
\emph{systematically and automatically} derive these parameters to be applied for the
\frameworkkq{} framework. For most of the typical schedulability tests
and response time analyses in real-time systems, such a derivation procedure is similar to the
automatic parameter generation for the \frameworkku{} in \cite{DBLP:journals/corr/abs-k2u-automatic}.
}
{
}

\begin{figure}[t]
	\begin{center}
      \begin{tikzpicture}[scale=0.72,transform shape]
\path \practica {1}{\underline{\bf Demonstrated Applications:}
          \begin{tabular}{ll}
          Sec. 5:& Arbitrary-deadline sporadic tasks\\
          Sec. 5:& Multiprocessor RM\\
          App. D\ifbool{techreport}{}{ \cite{DBLP:journals/corr/abs-k2q}}:&
          Periodic tasks with jitters\\
          App. E\ifbool{techreport}{}{ \cite{DBLP:journals/corr/abs-k2q}}:&
          Generalized multiframe\\
          App. F\ifbool{techreport}{}{ \cite{DBLP:journals/corr/abs-k2q}}:&
          Acyclic and Multi-Mode Models\\
          \end{tabular}
        };
        \path (p1.west)+(2.2,-3.8) node(p2)[materia, rounded
        rectangle,text width=7em]{{\bf \\ \\\\\\\\  {\scriptsize(for Lemmas \ref{lemma:framework-general-schedulability}-\ref{lemma:framework-totalU-constrained})}}}; 
        \path (p2.north)+(1.5,0.45) node[text width=16em]{Derive
          parameters\\by \underline{Definitions 2 or 3}};
        \path (p2.east)+(2,0) node(p3)[practica,fill=blue!20,text width=5em,text centered]{\large{\bf \\ framework}}; 


        \path (p3.east)+(0.4,+4) node(p4)[practica,fill=green!30,minimum width=6em,text width=5em,text centered]{Quadratic bound}; 
        \path (p4.south)+(2.3,-1.5) node(p5)[practica,fill=green!30,minimum width=6em,text width=5em,text centered]{Other utilization bounds}; 
        \path (p5.south)+(0,-1.65)
        node(p6)[practica,fill=green!30,minimum width=6em,text
        width=5em,text centered]{Response-time test}; 
        
        \path [line, ->] (p1.west) -- +(-0.3,0) node[black, rotate=90,
        yshift=0.3cm, xshift=-1.6cm]{\footnotesize{define the
             ordering or use Lemma 2 or 7}} -- + (-0.3, -3.6) -- (p2.west);
        \path [line, ->] (p2.east) -- (p3.west);
        \path [line, ->] (p3.east)+(0,0.3) -- node[rotate=80,yshift=0.3cm,black]{Lemma \ref{lemma:framework-general-schedulability}} (p4.south);
        \path [line, ->] (p3.east)+(0,0) -- node[rotate=60,yshift=0.3cm,black]{Lemmas \ref{lemma:framework-constrained-schedulability}-\ref{lemma:framework-totalU-constrained}} (p5.west);
        \path [line, ->] (p3.east)+(0,-0.3) -- node[rotate=5,yshift=0.3cm,black]{Lemma \ref{lemma:framework-general-response}} (p6.west);
      \end{tikzpicture}    
	\end{center}
\vspace{-2mm}
\caption{The \frameworkkq{} framework. }
\label{fig:framework}
\end{figure}

\subsection{Schedulability Test Framework}

This section provides five important lemmas for deriving the
utilization-based schedulability test based on
Definition~\ref{def:kpoints}. Lemma~\ref{lemma:framework-general-schedulability}
is the most general test, whereas
Lemmas~\ref{lemma:framework-constrained-schedulability},
\ref{lemma:framework-totalU-exclusive},~and~\ref{lemma:framework-totalU-constrained} work for certain special
cases when  for any higher-priority
task . Lemma~\ref{lemma:general-sorting} gives the worst-case last release time ordering, 
which can be used when the last release time ordering for testing task  is unknown.
  
\begin{lemma}
\label{lemma:framework-general-schedulability}
For a given -point last-release schedulability test, defined in
Definition~\ref{def:kpoints}, of a scheduling 
algorithm,
in which , and  for any
, , , and , task  is schedulable by the
fixed-priority scheduling
algorithm if the following condition holds

\end{lemma}

\begin{proof}
  We prove this lemma by showing that the condition in
  Eq.~\eqref{eq:schedulability-general} leads to the satisfactions of the
  schedulability conditions listed in
  Eq.~(\ref{eq:precodition-schedulability}) by using contrapositive.
  By taking the negation of the schedulability condition in
  Eq.~(\ref{eq:precodition-schedulability}), we know that if task
   is \emph{not schedulable} by the scheduling policy, then
  for each 
  

  To enforce the condition in
  Eq.~\eqref{eq:lp-init-constraints}, we are going to
  show that  must have some lower bound, denoted as . Therefore, if  is
  no more than this lower bound, then task  is schedulable by the
  scheduling policy.  For the rest of the proof, we replace  with  in
  Eq.~\eqref{eq:lp-init-constraints}, as the infimum and the minimum
  are the same when presenting the inequality with .
 The unschedulability for satisfying Eq.~\eqref{eq:lp-init-constraints} implies that , where  is defined in the optimization problem:


    \mbox{min\;\;} & C_k^*\\
    \mbox{s.t.\;\;} &     C_k^* + \sum_{i=1}^{k-1} \alpha_i t_i^*
    U_i + \sum_{i=1}^{j-1} \beta_i C_i \geq t_j^*,&\forall
    j=1,2,\ldots,
    k-1,   \\
  &t_1^* \geq 0 & \\
  &t_j^* \geq t_{j-1}^*,&\forall j=2,3,\ldots, k-1,\\
    & C_k^* + \sum_{i=1}^{k-1} \alpha_i t_i^* U_i + \sum_{i=1}^{k-1} \beta_i C_i \geq t_k,&   
  
  where  and  are variables,
  , , , and  are constants, and  is
  a given positive constant.  Moreover, it is obvious that relaxing
  the constraint  for  by
  using  does not increase the corresponding objective
  function in the linear programming. 
Therefore, we have

  
    \mbox{min\;\;} & C_k^* \label{eq:precodition-objective}\\
    \mbox{s.t.\;\;} &     C_k^* + \sum_{i=1}^{k-1} \alpha_i t_i^*
    U_i + \sum_{i=1}^{j-1} \beta_i C_i \geq t_j^*,&\forall
    j=1,2,\ldots,
    k-1,     \label{eq:precodition-schedulability-negation-0}\\
  &t_j^* \geq 0,&\forall j=1,2,\ldots, k-1,     \label{eq:precodition-schedulability-negation-1}\\
    & C_k^* + \sum_{i=1}^{k-1} \alpha_i t_i^* U_i + \sum_{i=1}^{k-1} \beta_i C_i \geq t_k.&     \label{eq:precodition-schedulability-negation-2}
  


Let  be a slack variable such that .
  Therefore, we can replace the objective function and the constraints
  with the above equality of . The objective function (i.e.,
  Eq.~\eqref{eq:precodition-objective}) is
  to find the minimum value of  such that
  Eq.~\eqref{eq:precodition-schedulability-negation-0} holds, which is
  equivalent to

{\footnotesize
  
  }





 For notational brevity, let  be .
 Therefore, the linear programming in Eq.~\eqref{eq:lp-init} can be rewritten as follows:
\footnotesize
    \mbox{min } &  
    t_k^* - (\sum_{i=1}^{k-1} \alpha_i U_it_i^* + \sum_{i=1}^{k-1}\beta_i C_i)\\
    \mbox{s.t.} \;\;&
t_k^*- \sum_{i=j}^{k-1} \beta_i C_i \geq t_j^*,
      & \forall 1 \leq j \leq k - 1, \label{eq:lp-framework-general-constraints}\\
&t_j^* \geq 0
      & \forall 1 \leq j \leq k - 1. \label{eq:lp-framework-general-boundaryconstraints}\\
&t_k^* \geq t_k \label{eq:lp-framework-general-slack-constraints}
  
  
  The remaining proof is to solve the above linear programming to obtain the minimum .
Our proof strategy is to solve the linear programming analytically as a function of . This can be imagined as if  is given. At the end, we will prove the optimality by considering all possible .
  This involves three steps:
  \begin{itemize}
  \item Step 1: we analyze certain properties of optimal solutions based on the extreme point theorem for linear programming \cite{luenberger2008linear} under the assumption that  is given as a constant, i.e.,  is known.
  \item Step 2: we present a specific solution in an \emph{extreme point}, as a function of .
  \item Step 3: we prove that the above extreme point solution gives the minimum   if .
  \end{itemize}

 {\bf [Step 1:]} After specifying the value
   as a given constant, the new linear programming without the
  constraint in
  Eq.~\eqref{eq:lp-framework-general-slack-constraints} has only
   variables and  constraints.
Thus, according to the extreme
  point theorem for linear programming \cite{luenberger2008linear},
  the linear constraints form a polyhedron of feasible solutions. The
  extreme point theorem states that either there is no feasible
  solution or one of the extreme points in the polyhedron is an
  optimal solution when the objective of the linear programming is
  finite. To satisfy Eqs.~\eqref{eq:lp-framework-general-constraints} and~\eqref{eq:lp-framework-general-boundaryconstraints}, we know that 
   for , due to , , and  for . As a result, the objective of the above linear programming is finite 
  since a feasible solution has to satisfy  for ,.

According to the extreme point theorem, one of the extreme points is
the optimal solution of Eq.~\eqref{eq:lp-framework-general}.  There
are  variables with  constraints in
Eq.~\eqref{eq:lp-framework-general}. An extreme point must have at
least  \emph{active} constraints in
Eqs.~\eqref{eq:lp-framework-general-constraints}
and~\eqref{eq:lp-framework-general-boundaryconstraints}, in which
their  are set to equality .


{\bf [Step 2:]} 
One special extreme point solution by setting  is to put  for every , i.e.,

which implies that

The above extreme point solution is always feasible in the linear programming due to the assumption that  
.
  Therefore,  in this extreme point solution, the objective function of Eq.~\eqref{eq:lp-framework-general} by rephrasing based on the condition in Eq.~\eqref{eq:3rdperiodrelation} is 
  {\small }
which means that .

{\bf [Step 3:]}
The rest of the proof shows that other feasible extreme point
solutions (that allow  to be  for some higher-priority task
) are with worse objective values for
Eq.~\eqref{eq:lp-framework-general}.  Under the assumption that
, if  is set to ,
there are two cases: (1)  or
(2) . In the former case, we
can simply set  to  to
improve the objective function without introducing any violation of
the constraints. In the latter case, the value of  can only be
set to  in any feasible solutions. Therefore, we conclude that any
other feasible extreme point solutions for Eq.~\eqref{eq:lp-framework-general}
are worse.

Note that the above solution of  is still a function of . We  need to find the minimization of  with respect to  based on the fact .
Due to the assumption that  and , we know that . Therefore,  when  and , which concludes the proof.
\end{proof}

Lemma~\ref{lemma:framework-general-schedulability} can be applied only
when the last release time ordering of the  higher-priority tasks
is given. We demonstrate the importance of the last release time
ordering by using the following example.\footnote{To demonstrate the impact of the last release time ordering, we use the original task indexes before applying  or  whenever referring to Example~\ref{example-3tasks}.}

\begin{example}\label{example-3tasks}
  Consider that  and  is . For the two tasks in
  , let  and .  Suppose that .  By the transformation in
  Example~\ref{example-1}, we know that  and 
  for . 

There are two last release time orderings. Suppose that  
 and
. That is, the
last release time ordering is  in , and the
last release time ordering is  in .
\hfill\myendproof
\end{example}

Now, we can use Lemma~\ref{lemma:framework-general-schedulability}
based on  and :
\begin{compactitem}
\item For , the schedulability condition in
  Lemma~\ref{lemma:framework-general-schedulability} shows that task
   in Example~\ref{example-3tasks} can meet the deadline if .
\item For , the schedulability condition in
  Lemma~\ref{lemma:framework-general-schedulability} shows that task
   in Example~\ref{example-3tasks} can meet the deadline if .
\end{compactitem}

The immediate question is whether both   based on
 and  based on  are safe. When ,
the transformation in Example~\ref{example-1} in fact adopts the last
release time ordering . Therefore,
Lemma~\ref{lemma:framework-general-schedulability} is only safe under
 in this example. As a result, the test in
Lemma~\ref{lemma:framework-general-schedulability} for the above
example is only valid when we apply .

However, in practice, we usually do not know how these tasks are indexed according to the required last release in the window of interest. It may seem at first glance that we need to test all the possible orderings. Fortunately, with the following lemma, we can safely consider only one specific last release time ordering of the  higher-priority tasks. 
\begin{lemma}
  \label{lemma:general-sorting}
  The worst-case ordering  of the  higher-priority tasks under the schedulability condition in Eq.~\eqref{eq:schedulability-general} in Lemma~\ref{lemma:framework-general-schedulability} is to order the tasks in a non-increasing order of ,
 in which  and  for any , .
\end{lemma}
\begin{proof}
This lemma is proved by showing that the schedulability condition in
  Lemma~\ref{lemma:framework-general-schedulability}, i.e., , is minimized, when the  higher-priority tasks are indexed in a non-increasing order of .  Suppose that there are two adjacent tasks  and  with .  Let us now examine the difference of  by swapping the index of task  and task .

  It can be easily observed that the other tasks  with  and  do not change their corresponding values
   in both
  orderings (before and after swapping  and ).
  The difference in the term  before and after swapping tasks 
  and   (before - after)  is 
  \normalsize
Therefore, we reach the conclusion that swapping  and  in the ordering makes the schedulabilty condition more stringent. By applying the above swapping repetitively, we reach the conclusion that ordering the tasks 
in a non-increasing order of  has the most stringent schedulability condition in Eq.~\eqref{eq:schedulability-general}.  
\end{proof}

We again use the configuration in Example~\ref{example-3tasks} to
demonstrate the rationale behind Lemma~\ref{lemma:general-sorting}. In
this example, let us consider that . When , the
transformation in Example~\ref{example-1} in fact adopts the last
release time ordering , i.e.,  is schedulable if . The schedulability condition based on the last
release time ordering , i.e.,  is schedulable if , is always worse than that based on  by
Lemma~\ref{lemma:general-sorting}. Therefore, it is always safe to use
, even though it can be sometimes more pessimistic, e.g., when
 is .

\subsection{Different Utilization Bounds}
The analysis in Lemma~\ref{lemma:framework-general-schedulability} uses the execution time and the utilization of the tasks in  to build an upper bound of  for  schedulability tests. It is also very convenient in real-time systems to build schedulability tests only based on utilization of the tasks. We explain how to achieve that in the following lemmas under the assumptions that , and  for any . 
These lemmas are useful when we are interested to derive utilization bounds, speed-up factors, resource augmentation factors, etc., for a given scheduling policy by defining the coefficients  and  according to the scheduling policies independently from the detailed parameters of the tasks. 
 Since the property repeats in all the statements, we make a formal definition before presenting the lemmas.
\begin{definition}
  \label{def:alpha-upper-bound}
  Lemmas~\ref{lemma:framework-constrained-schedulability} to
  \ref{lemma:framework-totalU-constrained} are based on the
  following -point last-release schedulability test of a scheduling
  algorithm, defined in Definition~\ref{def:kpoints}, in which , and  for
  any , , , and .
\end{definition}



\begin{lemma}
\label{lemma:framework-constrained-schedulability}
For a given -point last-release schedulability test of a scheduling 
algorithm, with the properties in Definition~\ref{def:alpha-upper-bound}, 
task  is schedulable by the scheduling
algorithm if the following condition holds
{\small }
\end{lemma}
\begin{proof}
  The condition in Eq.~\eqref{eq:schedulability-constrained} comes by reformulating the proof of Lemma~\ref{lemma:framework-general-schedulability} with  instead of . All the procedures remain the same, and, therefore,  for task  in the right-hand side of Eq.~\eqref{eq:schedulability-general} can be replaced by .

   We focus on the condition in Eq.~\eqref{eq:schedulability-constrained-2} by showing that . This condition clearly holds when  since . We consider . This is due to
   
where  follows from the fact .
\end{proof}


Lemma~\ref{lemma:framework-constrained-schedulability} provides a
schedulability test based on a quadratic form by using only the
utilization of the higher-priority tasks with the properties in
Definition~\ref{def:alpha-upper-bound}. The following two lemmas are
applicable for testing the utilization bound(s), i.e., the summation
of the task utilization. 

\begin{lemma}
\label{lemma:framework-totalU-exclusive}
For a given -point last-release schedulability test of a scheduling 
algorithm, with the properties in Definition~\ref{def:alpha-upper-bound}, 
task  is schedulable by the scheduling
algorithm if 

\end{lemma}
\begin{proof}
  This can be formally proved by using the Lagrange Multiplier
  Method. However, it can also be proved by using a simpler
  mathematical observation. Suppose that  is
  given. For given  and , we know that
  Eq.~\eqref{eq:schedulability-constrained-2} becomes
  . That
  is, only the last term 
  depends on how  values are actually assigned. Moreover,
   is a well-known convex function with
  respect to . That is,  for any . Therefore,  is minimized
  when .

Hence, what we have to do is to find the infimum  such that the
condition in Eq.~\eqref{eq:schedulability-constrained-2} does not
hold. That is,

 This means that as long as  is no more
than such infimum , the condition in
Eq.~\eqref{eq:schedulability-constrained-2} always holds and the
schedulability can be guaranteed. 
Provided that  is given, we can simply solve the above problem by finding the  with 
. There are two roots in the above quadratic equation. 
The smaller root, i.e., the right-hand side of Eq.~\eqref{eq:schedulability-totalU-exclusive}, is the infimum by definition.
\end{proof}

\begin{lemma}
\label{lemma:framework-totalU-constrained}
For a given -point last-release schedulability test of a scheduling 
algorithm, with the properties in Definition~\ref{def:alpha-upper-bound}, 
provided that , 
then task  is schedulable by the scheduling
algorithm if  
{\small
 
}
\end{lemma}
\begin{proof}
  The proof is similar to the proof of Lemma~\ref{lemma:framework-totalU-exclusive}, but slightly more involved. We detail the proof in Appendix A.
\end{proof}

\begin{comment}
\begin{lemma}
\label{lemma:framework-totalU-constrained-beta}
For a given -point last-release schedulability test of a scheduling  
algorithm, with the properties in Definition~\ref{def:alpha-upper-bound}, 
provided that , then task  is schedulable by the scheduling
algorithm if  
{\small
 
}
\end{lemma}
\begin{proof}
  The proof is similar to that of
  Lemma~\ref{lemma:framework-totalU-constrained}, and is in Appendix
  A.
\end{proof}
\end{comment}

\ifbool{techreport}{
By the fact that ,
which is an increasing function with respect to , and the fact that
 is a decreasing function with respect to , we know
that the right-hand side of
Eq.~\eqref{eq:schedulability-totalU-constrained} (when
) decreases with
respect to . Similarly, the right-hand side of
Eq.~\eqref{eq:schedulability-totalU-exclusive} also decreases with
respect to . Therefore, for evaluating the utilization bounds, it
is alway safe to take  as a safe upper bound. The
right-hand side of Eq.~\eqref{eq:schedulability-totalU-exclusive}
converges to  when .  The right-hand side of
Eq.~\eqref{eq:schedulability-totalU-constrained}  (when
) converges to
 when
.
}


\subsection{Response Time Analysis Framework}

We now further discuss the utilization-based response-time analysis
framework. 
\begin{lemma}
\label{lemma:framework-general-response}
For a given -point response time analysis, defined in
Definition~\ref{def:kpoints-response}, of a scheduling 
algorithm,
in which ,  for any
,  and , the response time to execute  for task
 is at most

\end{lemma}
\begin{proof}
  The proof is similar to the proof of
  Lemma~\ref{lemma:framework-general-schedulability}.  The detailed
  proof is in Appendix A.
\end{proof}

We use the same example in Example~\ref{example-3tasks} by setting
 to demonstrate how to use
Lemma~\ref{lemma:framework-general-response}.  By the transformation
in Example~\ref{example-response-time}, we know that  and
 for .  Now, we can use
Lemma~\ref{lemma:framework-general-response} based on  and
 (defined in Example~\ref{example-3tasks}) to calculate the
worst-case response time:
\begin{compactitem}
\item For , the response-time analysis in
  Lemma~\ref{lemma:framework-general-response} shows that the response
  time of task  in Example~\ref{example-3tasks} is upper
  bounded by .
\item For , the response-time analysis in
  Lemma~\ref{lemma:framework-general-response} shows that the response
  time of task  in Example~\ref{example-3tasks} is upper
  bounded by . 
\end{compactitem}

Not all the last release time orderings are safe for the worst-case
response time analysis. Fortunately, similar to
Lemma~\ref{lemma:general-sorting}, we can safely consider only one
specific last release time ordering of the  higher-priority tasks
as shown in the following lemma.
\begin{lemma}
  \label{lemma:general-response-sorting}
  The worst-case ordering  of the  higher-priority tasks
  under the response bound in
  Eq.~\eqref{eq:schedulability-general-response} in Lemma~\ref{lemma:framework-general-response} is to order the tasks in a non-increasing order of ,
 in which  and  for any , .
\end{lemma}
\begin{proof}
  The ordering of the  higher-priority tasks in the indexing rule
  only matters for the term , which was already
  proved in the proof of Lemma~\ref{lemma:general-sorting} to be
  minimized by ordering the tasks in a non-increasing order of
  . Clearly, the minimization of
   also leads to the maximization of
  Eq.~\eqref{eq:schedulability-general-response}, which concludes
  the proof.
\end{proof}

As a result, thanks to the help of
Lemma~\ref{lemma:general-response-sorting}, we can conclude that
 in the example in this subsection is a safe last release time
ordering to use Lemma~\ref{lemma:framework-general-response} for the
worst-case response time analysis.














\ifbool{techreport}{
\begin{table*}[t]
\renewcommand{\arraystretch}{1.2}
  \centering
  \scalebox{0.8}{
\begin{tabular}{|p{8cm}|c|c|p{4cm}|}
    \hline
    \hline
    Model &  &  & c.f.\\ 
    \hline
    \hline
  Uniprocessor Sporadic Tasks&  &  &
  Theorems \ref{theorem:schedulability-sporadic-arbitrary} and
  \ref{theorem:response-time-sporadic}\\
    \hline
   Multiprocessor Global RM/DM for Sporadic Tasks &  &
    &
   Theorems~\ref{thm:multiprocessor-GRM-M-1-carry-k2q},~\ref{thm:multiprocessor-GRM-M-1-carry-k2q-V2},~\ref{thm:multiprocessor-grm-sporadic-tight},and~\ref{thm:multiprocessor-gdm-sporadic-tight}\\
    \hline 
  Uniprocessor Periodic Tasks with Jitters&  &  &
  Theorem~\ref{theorem:response-time-PJ}\\
    \hline
  Uniprocessor Generalized Multi-Frame, Acyclic, and Mode-Change
  Tasks&  &  & 
  Theorems~\ref{theorem:response-time-sporadic-gmf},
  \ref{theorem:schedulability-mode-change}, and \ref{theorem:schedulability-mode-change-rm}.\\
    \hline 
    \hline
  \end{tabular}
}
  \caption{\small The  and  parameters in our demonstrated task models.}
  \label{tab:alpha-beta}
\end{table*}
}{}

\section{Applications by Using Sporadic Task Models}
\label{sec:sporadic}

This section demonstrates how to use the \frameworkkq{} framework to
derive utilization-based schedulability and response-time
analyses for sporadic task systems in uniprocessor and multiprocessor
systems. As sporadic real-time task models are the simplest scenarios
that can demonstrate how to use \frameworkkq{}, the content here is
merely for explaining how to use the framework, but not for
demonstrating the generality or superiority of \frameworkkq{}.

\subsection{Uniprocessor Constrained-Deadline Systems} 

\begin{theorem}
\label{theorem:sporadic-constrained-pessimistic}
Task  in a sporadic task system with constrained deadlines is
schedulable by the fixed-priority scheduling algorithm if
 and

in which the  higher-priority tasks in  are indexed
in a non-increasing order of .
\end{theorem}
\begin{proof}
  This comes from
  Lemma~\ref{lemma:framework-general-schedulability}~and~\ref{lemma:general-sorting}
  based on the setting  and  to satisfy
  Definition~\ref{def:kpoints}.\footnote{If  for a certain
    task  in , we can simply set  to .}
\end{proof}

\begin{theorem}
\label{theorem-rm}
Task  in a sporadic constrained-deadline task system with is
schedulable by the rate-monotonic (RM) scheduling algorithm if

or
 
or

\end{theorem}
\begin{proof}
  Under RM scheduling, we know that . Therefore,  can be set to  and 
  can be set to  in
  Definition~\ref{def:alpha-upper-bound}. Eq.~\eqref{eq:rm-qb0} is due
  to Lemma~\ref{lemma:framework-constrained-schedulability},
  Eq.~\eqref{eq:rm-qb1} is due to
  Lemma~\ref{lemma:framework-totalU-exclusive}, and
  Eq.~\eqref{eq:rm-qb2} is due to
  Lemma~\ref{lemma:framework-totalU-constrained}.
\end{proof}

\ifbool{techreport}{
The above result in Theorem~\ref{theorem-rm} leads to the utilization
bound  for implicit-deadline sporadic task systems under
RM scheduling.  This analysis is less precise than the Liu and Layland
bound , a simple implication by using
\frameworkku{}. However, if we are allowed to change the execution
time and period of a task for different job releases (called acyclic
task model in \cite{DBLP:journals/tc/AbdelzaherSL04}), then the tight
utilization bound  can be easily achieved by using
\frameworkkq{}, detailed in Appendix F\citetechreport{}.
}
{}
\subsection{Uniprocessor Arbitrary-Deadline Systems}  

\ifbool{techreport}{ For a specified fixed-priority scheduling algorithm, let 
be the set of tasks with higher priority than . We now
classify the task set  into two subsets:
\begin{itemize}
\item  consists of the higher-priority tasks with periods
  smaller than .
\item  consists of the higher-priority tasks with periods
  larger than or equal to .
\end{itemize}
}
{}


The
exact schedulability analysis for arbitrary-deadline task sets under
fixed-priority scheduling has been developed in
\cite{DBLP:conf/rtss/Lehoczky90}. The schedulability analysis is to
use a \emph{busy-window} concept to evaluate the worst-case response
time. That is, we release all the higher-priority tasks together with
task  at time  and all the subsequent jobs are released as
early as possible by respecting to the minimum inter-arrival time. The
busy window finishes when a job of task  finishes before the
next release of a job of task . It has been shown in
\cite{DBLP:conf/rtss/Lehoczky90} that the worst-case response time of
task  can be found in one of the jobs of task  in the
busy window. 

For the -th job of task  in the busy window, the finishing
time  is the minimum  such that
 
and, hence, its response time is . The busy window
of task  finishes on the -th job if . 


\ifbool{techreport}{ We can create a virtual
sporadic task  with execution time ,
relative deadline , and period . 
For notational brevity, suppose that there are  tasks in
. 
We have then the
following theorem. 

\begin{theorem}
\label{theorem:schedulability-sporadic-arbitrary}
Task  in a sporadic task system is
schedulable by the fixed-priority scheduling algorithm if
 and

in which , and the  higher-priority tasks in  are indexed
in a non-decreasing order of .
\end{theorem}
\begin{proof}
  The analysis is based on the observation to test whether the busy
  window can finish within interval length , which was also
  adopted in \cite{conf:/rtns09/Davis} and
  \cite{ChenHLRTSS2015}. By setting , and indexing the tasks in
  a non-decreasing order of  leads to the satisfaction of
  Definition~\ref{def:kpoints} with  and .
\end{proof}

Analyzing the schedulability by using
Theorem~\ref{theorem:schedulability-sporadic-arbitrary} can be good if
 is small. However, as the busy window may be
stretched when  is large, we further present how to
safely estimate the worst-case response time. 
}{
}
Suppose that 
for a higher-priority task . We index the tasks such that the
last release ordering  of the  higher-priority tasks is with
 for . Therefore, we know that
 is upper bounded by finding the maximum
  
with  and
  
Therefore, the above derivation of  satisfies
Definition~\ref{def:kpoints-response} with , and
 for any higher-priority task . However, it should
be noted that the last release time ordering  is actually unknown
since  is unknown. Therefore, we have to apply
Lemma~\ref{lemma:general-response-sorting} for such cases to obtain
the worst-case release time ordering, i.e., the  higher-priority tasks are ordered
  in a non-increasing order of their periods.

\begin{lemma}
  \label{lemma:finishing-time-sporadic-h}
  Suppose that . Then, for any
   and , we have
  
  where the  higher-priority tasks are ordered
  in a non-increasing order of their periods.
\end{lemma}
\begin{proof}
  This comes from the above discussions with , 
  by applying Lemmas~\ref{lemma:framework-general-response} and
  \ref{lemma:general-response-sorting} when . The case when  has a
  safe upper bound  in Eq.~\eqref{eq:R-k-h}.
\end{proof}

\begin{theorem}
  \label{theorem:response-time-sporadic}
  Suppose that . The worst-case
  response time of task  is at most
  
  where the  higher-priority tasks are ordered
  in a non-increasing order of their periods.
\end{theorem}
\begin{proof}
  This can be proved by showing that  is maximized
  when  is , where  is derived by using
  Lemma~\ref{lemma:finishing-time-sporadic-h}.  The first-order
  derivative of  with respect to  is
  .
  There are two cases:

\noindent{\bf Case 1:} If , then . Therefore,
   is a decreasing function of . Therefore, the
  response time is maximized when  is .

  \noindent{\bf Case 2:} If , then we know
  that . Therefore,  remains the same
  regardless of .

  Therefore, for both cases, the worst-case response time of task
   can be safely bounded by Eq.~\eqref{eq:R-k}. Moreover,
  since the worst case happens when , we do not have to check the
  length of the busy window, and we reach
  our conclusion.
\end{proof}

\ifbool{techreport}{ 

\begin{corollary}
  \label{corollary:arbitrary-response-schedulability}
  Task  in a sporadic task system is schedulable by the
  fixed-priority scheduling algorithm if 
  and 
  
  where the  higher-priority tasks are ordered
  in a non-increasing order of their periods.
\end{corollary}

\noindent{\bf Remarks:} 
The utilization-based worst-case response-time analysis in  
Theorem~\ref{theorem:response-time-sporadic} is analytically tighter  
than the best known result, , by Bini et  
al. \cite{bini2009response}. 
 Lehoczky \cite{DBLP:conf/rtss/Lehoczky90} also provides the total
utilization bound of RM scheduling for arbitrary-deadline systems. The
analysis in \cite{DBLP:conf/rtss/Lehoczky90} is based on the Liu and
Layland analysis \cite{liu1973scheduling}. The resulting utilization
bound is a function of . When
 is , it is an implicit-deadline system. The utilization
bound in \cite{DBLP:conf/rtss/Lehoczky90} has a closed-form when
 is an integer. However, calculating the utilization bound for
non-integer  is done asymptotically for  with
a complicated analysis. 
}{
\noindent{\bf Some Remarks:} In parallel, Bini et
al. \cite{bini-RTSS2015} have recently also developed a similar
worst-case response time bound, i.e., their Theorem 1 in
\cite{bini-RTSS2015} is very similar to our
Theorem~\ref{theorem:response-time-sporadic}. Although the proofs are
completely different, we reach the same bound. They also show that the
response-time bound is the tightest continuous function upper bounding
the exact response time of sets of tasks with full utilization when
there are only two tasks in the system. Note that we can obtain different
utilization-based tests by exploiting different properties in the
\frameworkkq{} framework. 
}

\begin{comment}
Bini \cite{DBLP:journals/tc/Bini15} provides a total utilization bound
of RM scheduling, based on the quadratic response time analysis in
\cite{bini2009response}, that works for any arbitrary ratio of
. However, the analysis in
\cite{DBLP:conf/rtss/Lehoczky90,DBLP:journals/tc/Bini15} considers the
whole task set to define  in the schedulability analysis. In
fact, for testing the schedulability of task , we only have to
consider , which is defined as  in
the following corollary.

\begin{corollary}
  \label{corollary:arbitrary-utilization-schedulability}
  Task  in a sporadic task system with  is schedulable by rate-monotonic scheduling
  algorithm in uniprocessor systems if 
{\small  
}
or 
{\small
 
 }
\end{corollary}
\begin{proof}
  Under RM scheduling, we know that . The resulting schedulability condition in
  Corollary~\ref{corollary:arbitrary-response-schedulability} is
  identical to
  Lemma~\ref{lemma:framework-constrained-schedulability}. Therefore,
  we can directly apply Lemmas~\ref{lemma:framework-totalU-exclusive}
  and \ref{lemma:framework-totalU-constrained-beta} to derive the two
  utilization bounds in Eq.~\eqref{eq:arbitrary-RM-utilization-exclusive}
  and~\eqref{eq:arbitrary-RM-totalU-constrained-beta}, respectively.
\end{proof}
\end{comment}






\subsection{Multiprocessor Implicit-Deadline Systems}  

We now present how to use \frameworkkq{} to analyze the schedulability
for implicit-deadline sporadic task systems under global
rate-monotonic (global RM) scheduling. Here, we start from the
pseudo-polynomial-time schedulability test by Guan et
al. \cite{DBLP:conf/rtss/GuanSYY09} that we only have to consider
 tasks with carry-in jobs, for constrained-deadline (hence, also
for implicit-deadline) task sets.  More precisely, we can define two
different time-demand functions, depending on whether task  is
with a carry-in job or not:\footnote{This is an over-approximation of
  the linear function used by Guan et
  al. \cite{DBLP:conf/rtss/GuanSYY09}.}

and

Moreover, we can further over-approximate , since  . Therefore, a sufficient schedulability test for testing task  with  for global RM is to verify whether 

for all  with .

This leads to the following theorem by using
Lemma~\ref{lemma:framework-general-schedulability}. 

\begin{theorem}
\label{thm:multiprocessor-GRM-M-1-carry-k2q}
Task  in a sporadic implicit-deadline task system is
schedulable by global RM on  processors if  and

by indexing the  higher-priority tasks in a non-decreasing order
of  for every  and by putting the 
higher-priority tasks with the largest execution times into .
\end{theorem}
\begin{proof}
  It is not necessary to enumerate all 
  with  if we can construct the task set  with the maximum .  To use \frameworkkq{}, we are certain about which tasks
  should be put into the carry-in task set  by assuming that
   and  are both given. That is, we simply have to put the
   higher-priority tasks with the largest execution times into
  . This can be imagined as if we increase the execution
  time of task  from  to . Moreover, we have  and  for every task  in this case. 

  Therefore, based on the test in
  Eq.~\eqref{eq:grm-multiprocessor-M-1-carryin}, we have the 
  last release time ordering defined by indexing the 
  higher-priority tasks in a non-decreasing order of
   for every . By adopting
  Lemma~\ref{lemma:framework-general-schedulability} with
   and , we know that
  task  is schedulable by global RM if  and 

  By reorganizing the above inequality, we reach the conclusion.
\end{proof}

We can always take the pessimistic last release time ordering in
Lemma~\ref{lemma:general-sorting}, for concluding the following theorem.

\begin{theorem}
\label{thm:multiprocessor-GRM-M-1-carry-k2q-V2}
Task  in a sporadic implicit-deadline task system is
schedulable by global RM on  processors if the condition in
Eq.~\eqref{eq:schedulability-GRM-M-1-carry-k2q} holds by indexing the
 higher-priority tasks in a non-increasing order of , for
every .
\end{theorem}
\begin{proof}
  This is proved based on the same argument in Theorem~\ref{thm:multiprocessor-GRM-M-1-carry-k2q} by adopting Lemmas~\ref{lemma:framework-general-schedulability}~and~\ref{lemma:general-sorting}.
\end{proof}

We can of course revise the statement in
Theorems~\ref{thm:multiprocessor-GRM-M-1-carry-k2q}~and~\ref{thm:multiprocessor-GRM-M-1-carry-k2q-V2}
by adopting Lemma~\ref{lemma:framework-constrained-schedulability} and
Lemma~\ref{lemma:framework-totalU-exclusive} to construct
schedulability tests by using only the utilization of the higher-priority tasks.


{\bf Evaluation Results} We conduct experiments using synthesized task
sets for evaluating the tests in
Theorem~\ref{thm:multiprocessor-GRM-M-1-carry-k2q} and
Theorem~\ref{thm:multiprocessor-GRM-M-1-carry-k2q-V2}.  We first
generated a set of sporadic tasks. The cardinality of the task set was
 times the number of processors, i.e., 40 tasks on 8 multiprocessor
systems.  The UUniFast-Discard method~\cite{davis2011improved} was
adopted to generate a set of utilization values with the given goal.
We used the approach suggested by Davis et
al.~\cite{davis2008efficient} to generate the task periods according
to a uniform distribution in the range of the logarithm of the task periods (i.e.,
log-uniform distribution).  The order of magnitude  to
control the period values between the largest and smallest periods is
parameterized in evaluations, (e.g.,  for ,  for
, etc.).  We evaluate these tests in uniprocessor systems with .  The execution time
was set accordingly, i.e., .  Tasks' relative deadlines
were equal to their periods.

The evaluated tests for  tasks in  with  are:
\begin{itemize}
\item \emph{BCL}: the linear-time test in Theorem 4 in~\cite{bertogna2006new}.
\item \emph{FF}: the pseudo-polynomial-time forced-forward (FF) analysis in Eq. (5) in \cite{DBLP:journals/rts/BaruahBMS10}.
\item \emph{BAK}: the  test in Theorem 11 in~\cite{baker2006analysis}.
\item \emph{Guan}: the pseudo-polynomial-time response time analysis\cite{DBLP:conf/rtss/GuanSYY09}.
\item \emph{QB-BC} (from \frameworkkq{}):
  Eq.~\eqref{eq:schedulability-GRM-M-1-carry-k2q} in
  Theorem~\ref{thm:multiprocessor-GRM-M-1-carry-k2q}. This requires to
  sort the higher-priority tasks to define the proper last release
  ordering and the  carry-in jobs; therefore, the time complexity is  for a
  task set with  tasks.
\item \emph{QB-BC2} (from \frameworkkq{}):
  Eq.~\eqref{eq:schedulability-GRM-M-1-carry-k2q} in
  Theorem~\ref{thm:multiprocessor-GRM-M-1-carry-k2q-V2} by always
  using the worst-case release time ordering, which is the reverse
  order of the given priority assignment. The schedulability test can
  be implemented in  time complexity by using proper data
  structures, provided that the RM priority order is given.\footnote{The time complexity is mainly due to the
    calculation of  to get the  tasks with the maximum
    carry-in execution time since the other operations can be done in
     time complexity by using proper data structures to
    calculate the values when we intend to test task 
    after task . Specifically, due to the predefined last
    release time ordering, when we intend to test task 
    after task , we only have to insert task  to be
    indexed as  and updating from   to  (under the new ordering) takes only constant time
    complexity.  Finding task set  can be implemented by
    using a min heap to store the  tasks in . When we move
    from testing task  (when ) to task ,
    we need to compare whether  is larger than the minimum
    execution time of the tasks in the heap. If no, we keep the same
    task set ; if yes, we pop out the task with the minimum
    execution time in the heap, and insert task  into the
    heap.  By using the heap, this operation requires time complexity
    . Calculating  from  with
    the help of the heap can be done in  time complexity. }
\end{itemize}

Figure~\ref{fig:mul-2} depicts the result of the performance
comparison. In all the cases, we can see that QB-BC is superior to all
the other polynomial-time tests.  QB-BC2 is slightly worse than QB-BC
but the time complexity is lower.  Since QB-BC and QB-BC2 are designed
from a more pessimistic test than the analysis by Guan et
al. \cite{DBLP:conf/rtss/GuanSYY09} in pseudo-polynomial time, they 
are worse. But, we note that
there is a significant gap in time complexity between QB-BC, QB-BC2,
and Guan.  Overall, the tests derived by using the \frameworkkq{}
framework perform reasonably well with their low time complexity.


\begin{figure*}[t]
  \centering
  \includegraphics[width=0.9\textwidth]{k2q.pdf}
  \caption{Acceptance ratio comparison on implicit-deadline 8 multiprocessor systems.}
  \label{fig:mul-2}
\end{figure*}


\section{Conclusion and Extensions}

In this paper, we present a general response-time analysis and
schedulability-test framework, called \frameworkkq{}. Thanks to the independence
upon the task and platform models in the framework, \frameworkkq{} can be viewed as a
``block-box'' interface that can result in sufficient
utilization-based analyses for a wide range of applications in
real-time systems under fixed-priority scheduling.  We believe that
the \frameworkkq{} framework has high potential to be adopted to solve
several other problems for analyzing other task models in real-time
systems with fixed-priority scheduling.  The framework can be used,
once the corresponding -point last-release scheduling test or
response time analysis can be constructed.  


Moreover, our proposed frameworks,
\frameworkku{} and \frameworkkq{},
provide a solid mathematical foundation for deriving polynomial-time utilization-based
schedulability tests and response time analyses almost
\emph{automatically}. That is, utilization-based analyses are almost
automatically derived if the schedulability tests can be formulated
in the scope of the frameworks.
\ifbool{techreport}{
We have demonstrated several applications in this paper. Some models
  have introduced pretty high dynamics, but we can still handle the
  response time analysis and schedulability test with proper
  constructions so that the \frameworkkq{} framework is applicable.
Therefore, with the presented approach, some difficult schedulability
test and response time analysis problems may be solved by building a good (or
exact) exponential-time test and using the approximation in the
\frameworkkq{} framework.  With the quadratic and hyperbolic
expressions, \frameworkkq{} and \frameworkku{} frameworks can be used
to provide many quantitive features to be measured, like the total
utilization bounds, speed-up factors, etc., not only for uniprocessor
scheduling but also for multiprocessor scheduling.
}{
Due to the space limitation, we are only able to summarize some results
  herein, but not to provide details. The detailed evaluations,
  compared to other approaches are in
  \cite{DBLP:journals/corr/framework-compare}. There are more
  applications presented in the report
  \cite{DBLP:journals/corr/abs-k2q}, including
\begin{compactitem}
\item more explorations for uniprocessor fixed-priority scheduling in
  Appendix B\citetechreport{}.  
\item an extension to adopt the force-forward schedulability analysis for multiprocessor global fixed-priority scheduling in
  Appendix C\citetechreport{}.  
\item the first polynomial-time worst-case response time analysis, to
  the best of our knowledge, for sporadic real-time tasks with jitters
  Appendix D\citetechreport{}.  
\item a demonstration on converting
  exponential-time schedulability tests of generalized multi-frame
  task models
  \cite{DBLP:journals/rts/BaruahCGM99,DBLP:conf/rtcsa/TakadaS97} to
  polynomial-time tests in 
  Appendix E\citetechreport{}.
\item mode-level fixed-priority scheduling
  policies by
  studying the acyclic task model
  \cite{DBLP:journals/tc/AbdelzaherSL04} and the multi-mode task model
  \cite{DBLP:conf/rtas/DavisFPS14} in Appendix F\citetechreport{}.
\end{compactitem}
}

When adopting \frameworkkq{} for schedulability tests, we assume that
 is specified in
Lemma~\ref{lemma:framework-general-schedulability}. In this paper, we
do not explore how to configure the best value of  and its last
release time ordering  such that the resulting quadratic form is
the best. Therefore, the combination of \frameworkkq{}/\frameworkku{}
and the tunable approach by Bini and Buttazzo
\cite{DBLP:journals/tc/BiniB04} can be an interesting future research
direction, as this can potentially balance the schedulability test and
the time complexity for concrete applications. Essentially, this
combination is to search the proper settings of different  values
such that the associated last release time ordering  can be 
less pessimistic, as demonstrated by several cases regarding Example~\ref{example-3tasks} in Section~\ref{sec:framework}.

 \begin{spacing}{0.9}
   \noindent{\small {\bf Acknowledgement}: This paper has been
     supported by NSF grant CNS 1527727 and DFG, as part of the Collaborative Research Center
     SFB876 (http://sfb876.tu-dortmund.de/), and the priority program
     "Dependable Embedded Systems" (SPP 1500 -
     http://spp1500.itec.kit.edu). \ifbool{techreport}{}{We would also like to thank the
     anonymous reviewers for their valuable comments to improve the
     presentation of the paper.}
  }
 \end{spacing}

\footnotesize
\vspace{-0.1in}
\begin{spacing}{0.98}
\def\IEEEbibitemsep{-1pt}
\bibliographystyle{abbrv}
\bibliography{ref,real-time}
\end{spacing}
\normalsize

\ifbool{techreport}{}{\vspace{-0.2in}}
\section*{Appendix A: Proofs}










\begin{appProof}{Lemma \ref{lemma:framework-totalU-constrained}}
 Similar to the proof of Lemma~\ref{lemma:framework-totalU-exclusive}, we only have to consider the cases when  is set to  to make the schedulability condition the most difficult, where . Suppose that  is . Then, we are looking for the infimum  such that .

  To solve this, we start with . Our objective becomes to minimize . By finding , we know that . Therefore,
  
Since , we know that .
  Whether we should take the above solution only depends on whether  or not. If , then we can conclude the solution directly; otherwise, if , we should set  to . That is, by reorganizing Eq.~\eqref{eq:y-and-k} (under the assumption  and ), examining whether  is equivalent to testing
, which implies to test whether . If , then   since  due to the assumption .
Therefore, there are two cases:\\
\noindent {\bf Case 1:} If  and , then, for such a case  derived from Eq.~\eqref{eq:y-and-k} is negative. We should set  to . The remaining procedure here is the same as in solving the quadratic equation in the proof of Lemma~\ref{lemma:framework-totalU-exclusive} by setting  to . This leads to the first condition in Eq.~\eqref{eq:schedulability-totalU-constrained}.\\
\noindent{\bf Case 2:} If   or ,
then, we have the
conclusion that  and . We just have to sum up the above derived 
and .  This leads to the second condition in
Eq.~\eqref{eq:schedulability-totalU-constrained} directly.
\end{appProof}

\begin{comment}
\begin{appProof}{Lemma \ref{lemma:framework-totalU-constrained-beta}}
  The procedure is identical to the proof of
  Lemma~\ref{lemma:framework-totalU-constrained} by putting
  .  We only have to consider the cases
  when  is set to  to make the schedulability
  condition the most difficult, where . Suppose
  that  is . Then, we are looking for the infimum
   such that .

  To solve this, we start with . Our objective becomes to minimize . By finding , we know that . Therefore,
  

  Whether we should take the above solution depends on whether  or not. If , then we can conclude the solution directly; otherwise, if , we should set  to . That is, by reorganizing Eq.~\eqref{eq:y-and-k-beta}, we are examining whether 


Therefore, there are two cases:\\
\noindent
{\bf Case 1:} If , then, for such a case  derived from Eq.~\eqref{eq:y-and-k-beta} is negative. We should set  to . The procedure here is the same as in solving the quadratic equation in the proof of Lemma~\ref{lemma:framework-totalU-exclusive} by setting  to . This leads to the first condition in Eq.~\eqref{eq:schedulability-totalU-constrained-beta}.\\
\noindent{\bf Case 2:} If , then, we have the conclusion that  and . We just have to sum up the above derived  and . This leads to the second condition in Eq.~\eqref{eq:schedulability-totalU-constrained-beta}.
\end{appProof}
\end{comment}

\begin{appProof}{Lemma \ref{lemma:framework-general-response}}
 Definition \ref{def:kpoints-response} leads to the following optimization problem:

  
    \mbox{sup\;\;} & C_k + \sum_{i=1}^{k-1} \alpha_i t_i^* U_i + \sum_{i=1}^{k-1} \beta_i C_i \\
    \mbox{such that\;\;} &     C_k + \sum_{i=1}^{k-1} \alpha_i t_i^*
    U_i + \sum_{i=1}^{j-1} \beta_i C_i > t_j^* ,&\forall j=1,\ldots,
    k-1,  \\
&t_j^* \geq 0,&\forall j=1,\ldots, k-1,     
  
\noindent where  and are variables,
  , , ,  for higher-priority task
   and  are constants.
  For the rest of the proof, we replace  with  in
  Eq.~(\ref{eq:lp-init-response0}), as the supermum
  and the maximum are the same when presenting the inequality with
  .  We can also further drop the condition , which just makes the resulting solution more pessimistic. This
  results in the following linear programming, which has a safe upper bound of
  Eq.~\eqref{eq:lp-init-response0},

  
    \mbox{maximize\;\;} & C_k + \sum_{i=1}^{k-1} \alpha_i t_i^* U_i + \sum_{i=1}^{k-1} \beta_i C_i \\
    \mbox{such that\;\;} &     C_k + \sum_{i=1}^{k-1} \alpha_i t_i^*
    U_i + \sum_{i=1}^{j-1} \beta_i C_i \geq t_j^* ,\forall j=1,\ldots,
    k-1.    \label{eq:lp-constraint-response}
  

  The linear programming in Eq.~(\ref{eq:lp-init-response}) (by
  replacing  with  and supremum with maximum) has 
  variables and  constraints. Like the proof of Lemma~\ref{lemma:framework-general-schedulability}, we again adopt the extreme point
  theorem for linear programming \cite{luenberger2008linear} to solve
  the linear programming. Suppose that  is a feasible solution for the linear programming in
  \eqref{eq:lp-init-response} and . By the satisfaction of
  Eq.~\eqref{eq:lp-constraint-response}, we know that
  
  As a result, we have . That is, any feasible solution of
  Eq.~\eqref{eq:lp-init-response} has  for
  any . Under the assumption that  and , 
 the  above linear programming has a bounded objective function.

  The only extreme point solution is to put  for every
  . Since the objective function is bounded, by the
  extreme point theorem \cite{luenberger2008linear}, we know
  that this extreme point solution is the optimal solution for the
  linear programming in Eq.~\eqref{eq:lp-init-response}. For such a solution, we know that

and 
 
where  and  are defined as  for notational brevity. 
Therefore, we know that

Clearly, the above extreme point solution is always feasible when
.
Therefore,  in this extreme point solution, the objective function of
the linear programming is

{\footnotesize  }
  which concludes the proof.  
\end{appProof}

\ifbool{techreport}{}{\end{document}}






\section*{Appendix B: Quadratic Bound for Uniprocessor
  Constrained-Deadline Tasks}

To verify the schedulability of a
(constrained-deadline) sporadic real-time task  under fixed-priority scheduling
in uniprocessor systems, the time-demand analysis (TDA) developed in
\cite{DBLP:conf/rtss/LehoczkySD89} can be adopted.
 That is, if

then task  is schedulable under the fixed-priority scheduling algorithm, where  is the set of tasks with higher priority than , , , and  represent 's relative deadline, worst-case execution time, and period, respectively. 
For a constrained-deadline task , the schedulability test in
Eq.~\eqref{eq:exact-test-constrained-deadline}  is equivalent to the
verification of the existence of  such that

We can then create a virtual sporadic task  with execution
time , relative
deadline , and period . It is
clear that the schedulability test to verify the schedulability of
task  under the interference of the higher-priority tasks
 is the same as that of task  under the
interference of the higher-priority tasks .
For notational brevity, suppose that there are  tasks in
. 


\begin{theorem}
\label{theorem:sporadic-general-v2}
Task  in a sporadic task system with constrained deadlines is
schedulable by the fixed-priority scheduling algorithm if
 and

in which the  higher-priority tasks in  are indexed
in a non-decreasing order of .
\end{theorem}
\begin{proof}
Setting , and indexing the
tasks in a non-decreasing order of  leads to the satisfaction of
Definition~\ref{def:kpoints} with  and .
\end{proof}

\begin{corollary}
\label{corollary-rm}
Task  in a sporadic task system with implicit deadlines is
schedulable by the RM scheduling algorithm if
Lemmas~\ref{lemma:framework-general-schedulability},~\ref{lemma:framework-constrained-schedulability},
\ref{lemma:framework-totalU-exclusive},
or~\ref{lemma:framework-totalU-constrained} holds by setting
 as , , and .
\end{corollary}

The above result in Corollary~\ref{corollary-rm} leads to the
utilization bound  (by using
Lemma~\ref{lemma:framework-totalU-constrained} with  and
) for RM scheduling, which is worse than the existing
Liu and Layland bound  \cite{liu1973scheduling}. 


\section*{Appendix C: Multiprocessor DM/RM Scheduling}

This part demonstrates how to use the \frameworkkq{} framework for multiprocessor
global fixed-priority scheduling. We consider that the system has 
identical processors. For global fixed-priority scheduling, there is a
global queue and a global scheduler to dispatch jobs. We
demonstrate the applicability for constrained-deadline and
implicit-deadline sporadic systems under global fixed-priority
scheduling. Specifically, we will present how to apply the
framework to obtain speed-up and capacity augmentation factors for
global DM and global RM.

The success of the scheme depends on a corresponding
exponential-time test. Here we will use the property to be presented
in Lemma~\ref{lemma:multiprocessor-grm-sporadic-pushforward}, based on
the \emph{forced-forward} algorithm proposed by Baruah et
al. \cite{DBLP:journals/rts/BaruahBMS10} to characterize the workload
of higher-priority tasks. The method in
\cite{DBLP:journals/rts/BaruahBMS10} to analyze fixed-priority
scheduling is completely different from ours, as they rely on the
demand bound functions of the tasks. 

The following
lemma provides a sufficient test based on the observations by Baruah
et al. \cite{DBLP:journals/rts/BaruahBMS10}.
The construction of the following lemma is based 
on a minor change of the forced-forward algorithm. 



\begin{lemma}
\label{lemma:multiprocessor-grm-sporadic-pushforward} 
Let  be .   
Task  in a sporadic task system with constrained deadlines  is
schedulable by a global fixed-priority (workload conserving)
scheduling algorithm on
 processors if

\end{lemma}
\begin{proof}
  This is proved by contrapositive. If task  is not
  schedulable by the global fixed-priority scheduling, we will show that there exist  and  such that for all , the condition  holds. The proof is mainly based on the forced-forward algorithm for the analysis of global DM by Baruah et al. in \cite{DBLP:journals/rts/BaruahBMS10}, by making some further annotations.

  If  is not schedulable by global DM, let  be the first time at which
  task  misses its absolute deadline, i.e., .  Let 
  be the arrival time of this job of task .  For notational
  brevity, let this job be , which arrives at time  and has
  not yet been finished at time . By definition, we know that
   is . Due to the fixed-priority and
  workload-conserving scheduling policy and the constrained-deadline setting, removing (1) all the other jobs of task  (except the one arriving at time ), (2) all the jobs arriving no earlier than ,  and (3) lower-priority jobs does not change the unschedulability of job . Therefore, the rest of the proof only considers the jobs from .

  Now, we expand the window of interest by using a slightly
  different algorithm from that proposed in
  \cite{DBLP:journals/rts/BaruahBMS10}, also illustrated with the
  notation in Figure~\ref{fig:force-forward}, as in Algorithm~\ref{alg:feasibility-analysis2}. The difference is only in the setting
``strictly less than  units'', whereas the setting in \cite{DBLP:journals/rts/BaruahBMS10} uses 
``strictly less than  units'' for a
certain .
For notationaly brevity,  is the utilization of the task that generates
job .

 \begin{algorithm}[h]
   \caption{(Revised) Forced-Forward Algorithm}
   \label{alg:feasibility-analysis2}
    \begin{algorithmic}[1]\footnotesize
        \FOR {}
          \STATE let  denote a job that 
          \begin{compactitem}[-]
          \item arrives at some time-instant ;
          \item has an absolute deadline after ;
          \item has not completed execution by ; and
          \item has executed for strictly less than 
	 units over the interval , where  is the utilization of the task that generates job .
          \end{compactitem}

          \IF {there is no such a job}
          \STATE ; break;
          \ENDIF
      \ENDFOR
     \end{algorithmic}
     \end{algorithm}

     Suppose that the forced-forward algorithm terminates with  equals to . We now examine the schedule in the interval . Since  belong to , we know that  for . Let  be the total length of the time interval over  during which  is executed. By the choice of , it follows that
\ifbool{techreport}{}{MJ_\ell(z_\ell, z_{\ell-1}]J_\ellz_{\ell^*}z_0MJ_1J_1'J_1'z_{\ell^*}z_0(z_0-z_{\ell^*}) \cdot \Delta_k^{\max}J_1'z_{0}\tau_ii=1,2,\ldots,k-1J_i^\flat\tau_i\tau_ir_i^\flatr_i^\flat < z_{\ell^*}r_i^\flat+T_i > z_{\ell^*}d_i^\flat\tau_iz_{\ell^*}d_i^\flat = r_i^\flat + T_iz_{\ell^*}J_i^\flat(z_{\ell^*}-r_i^\flat)\cdot U_iz_{\ell^*}J_i^\flatz_{\ell^*}(d_i^\flat - z_{\ell^*})\cdot U_iJ_i^\flatd_i^\flatz_{\ell^*}W_i'(t)\tau_ii=1,2,\ldots,k-1(z_\ell^*, z_\ell^*+t)J_1'J_1J_1'z_{\ell^*}z_0\Delta_k^{\max} (z_0-z_{\ell^*}) +
  \frac{ \sum_{\tau_i \in hp(\tau_k)}W_i'(t) }{M} >  t0 < t \leq z_{\ell^*}-z_0J_1'y=z_{1}-z_{\ell^*}y \geq 0\omega_i = d_i^\flat - z_{\ell^*}0 \leq \omega_i \leq T_ii=1,2,\ldots, k-1\tau_ky \geq 00 \leq \omega_i \leq T_ii=1,2,\ldots, k-10 < t \leq D_k+y\Delta_k^{\max} (D_k+y) +
  \frac{ \sum_{\tau_i \in hp(\tau_k)} \omega_i\cdot U_i+ \ceiling{\frac{t-\omega_i}{T_i}} C_i }{M}  \leq t\tau_kr_kr_k+D_kr_ky[r_k, r_k+D_k)[r_k-y,
r_k+D_k)\omega_i\omega_i T_i\tau_ir_k-y[r_k-y,
r_k+D_k)\omega_i T_ir_k-y+\omega_i\tau_ky \geq 00 \leq \omega_i \leq T_i,
\forall \tau_i \in hp(\tau_k)\Delta_k^{\max} \cdot(D_k+y)\tau_ky \geq 00 \leq
\omega_i \leq T_i\tau_ii=1,2,\ldots,k-1\omega_ikU_k^{\max}\max_{j=1}^{k} U_j\tau_kMy\omega_iy\omega_ii=1,2,\ldots,k-1y \geq 00 \leq \omega_i \leq T_it_kT_k+yt_i\omega_i +
  \floor{\frac{T_k+y-\omega_i}{T_i}}T_ii=1,2,\ldots,k-1t_1 \leq t_2 \leq \ldots \leq t_ki < j\omega_i\cdot U_i+
  \ceiling{\frac{t_j-\omega_i }{T_i}} C_i \leq \omega_i\cdot U_i+
  (\floor{\frac{t_i-\omega_i }{T_i}}+1)C_i  = t_i U_i + C_ii
  \geq j\omega_i\cdot U_i+
  \ceiling{\frac{t_j-\omega_i }{T_i}} C_i \leq \omega_i\cdot U_i+
  (\ceiling{\frac{t_i-\omega_i }{T_i}})C_i  = t_i U_iy\omega_it_j \in
\setof{t_1, t_2, \ldots t_k}T_k \geq T_iC_i = U_i T_i \leq U_i T_k \leq U_i (T_k+y) = U_i t_ki=1,2,\ldots,k-1t_j \in
\setof{t_1, t_2, \ldots t_k}\alpha_i = \frac{1}{M}\beta \leq \frac{1}{M}i=1,2,\ldots,k-1y\omega_iy\omega_iy\omega_ik-1y\omega_i\frac{3+\sqrt{7}}{2}\approx 2.823\sum_{\tau_i} \frac{C_i}{M T_i} \leq \frac{1}{b}U_k^{\max} \leq \max_{\tau_i} U_i \leq \frac{1}{b}2-\sqrt{2+U_k^{\max}}k\rightarrow \infty\tau_k\frac{1}{b} \leq
  2-\sqrt{2+\frac{2}{b}}x =
  2-\sqrt{2+2x}x = 3-\sqrt{7}\frac{3+\sqrt{7}}{2}\approx 2.823\Delta_k^{\max}\max_{j=1}^{k-1} \{U_j, \frac{C_k}{D_k}\}\tau_kM\sum_{i=1}^{k} U_i \leq M\sum_{i=1}^{k-1}\frac{C_i}{D_k} \leq Mk-1t_k=D_k+y\alpha_i=\frac{1}{M}\beta_i = \frac{1}{M}\frac{\beta_i C_i}{\alpha_i U_i}=T_iy \geq 0\Delta_k^{\max} \leq 1 -
  \frac{1}{M}\sum_{i=1}^{k-1} \left( U_i + \frac{C_i}{D_k+y}\right )+
  \frac{1}{M^2}\left(\sum_{i=1}^{k-1} U_i (\sum_{\ell=i}^{k-1}
    \frac{C_\ell}{D_k+y})\right)\tau_k\sum_{i=1}^{k-1} U_i \leq M C_i \frac{\sum_{\ell=1}^{i} U_\ell}{M}  \leq C_i\vec{a}\vec{b}(k-1)\sum_{i=1}^{k-1} a_i \sum_{\ell=i}^{k-1} b_\ell = \sum_{i=1}^{k-1} b_i \sum_{\ell=1}^{i} a_\elly0y0\sum_{i=1}^{k} U_i \leq M\sum_{i=1}^{k-1}\frac{C_i}{D_k}
  \leq M1\tau_k\tau_k\Delta_k^{\max} > \frac{1}{3}\frac{1}{M}\sum_{i=1}^{k-1}  U_i > \frac{1}{3}\frac{1}{M}\sum_{i=1}^{k-1}  \frac{C_i}{D_k} > \frac{1}{3}3\sum_{j=1}^{k} U_j\leq \frac{M}{2}(1-U_k^{\max})+U_k^{\max}\frac{(1-x)}{2} \leq 2-\sqrt{2+2x}0 \leq x \leq 12.8232.668\tau_n\tau_{n-1}\tau_n\tau_n333O(k\log k)\varsigma\tau_iU_i > \varsigma\varsigma\varsigma=\frac{2}{3+\sqrt{7}}\approx 0.3542xz_\ellJ_\ellz_{\ell-1}J_{\ell-1}J_{3}z_2J_2z_1J_1z_0\cdot\cdot\cdot\cdot\cdot\cdot\cdot\cdot\cdot\cdot\tau_iT_iC_iD_iL_iL_ih\tau_kR_{k,h}th\tau_k\max\{(h-1)T_k-L_k,
0\}R_{k,h}-\max\{(h-1)T_k-L_k,
0\}\tau_khR_{k,h} \leq \max\{h T_k-L_k, 0\}R_{k,h}k-10 \leq t_1
  \leq t_2 \leq \cdots \leq t_{k-1} \leq t_{k}R_{k,h}\tau_iR_{k,h}t_i=(\ceiling{\frac{R_{k,h}+L_i}{T_i}}-1)T_i-L_ik-1t_it_i(\ceiling{\frac{R_{k,h}+L_i}{T_i}}-1) C_i =
  \frac{t_i+L_i}{T_i} T_iU_i = t_i U_i +
  L_i U_i\tau_i0t_iL_iU_i + t_i U_iR_{k,h}R_{k,h}\sum_{i=1}^{k-1}  U_i \leq 1h \geq 1C_k > 0k-1\alpha_i=1\beta_i=1\sum_{i=1}^{k-1} 
  U_i < 1\sum_{i=1}^{k-1} U_i = 1R_{k,h}=\infty\sum_{i=1}^{k} U_i \leq 1\tau_kk-1h^*=\floor{\frac{L_k}{T_k}}+1h^*(h^*-1)T_k-L_k \leq 0h^*T_k-L_k > 0h \leq h^*\max\left\{(h^*-1)T_k-L_k, 0\right\}0R_{k,h}-0hh^*h \leq h^*R_{k,h}-((h-1)T_k - L_k)hh \geq h^*+1\frac{C_k}{1-\sum_{i=1}^{k-1} U_i} - T_k =
\frac{C_k - (1-\sum_{i=1}^{k-1} U_i) T_k }{1-\sum_{i=1}^{k-1}
  U_i}R_{k,h}-(h-1)T_khh^*+1h
\geq h^*+1hh^*h^*+1\tau_im_i(C_{i,0}, D_{i,0}, T_{i,0}, C_{i,1},
D_{i,1}, T_{i,1},
\ldots, C_{i,m_i-1}, D_{i,m_i-1}, T_{i,m_i-1})j\tau_iC_{i,(j\mod
  m_i)}j\tau_it\tau_i(j+1) \mod m_it+T_jD_{i,j} \leq T_{i,j}h\tau_kh\tau_k\tau_i\tau_i{\sc rbf}(i, q, t)\tau_itq\theta(i,q,t)\ell\sum_{j=q}^{\ell} T_{i,(j\mod m_i)} \geq t\theta(i,q,t)\tau_itq\tau_ih\tau_kq_irbf(i,t) =
\max_{q=0}^{m_i-1}rbf(i,q,t)2k\tau_iq\tau_iD_{k,h}D_{k,h}m_i\tau_iU_{i,k,h}C_{i,k,h}U_{i,k,h}\cdot t_{i,q} \geq
rbf(i,q,t_{i,q})U_{i,k,h}\cdot t_{i,q} + C_{i,k,h}\geq
rbf(i,q,t_{i,q}+\epsilon) = rbf(i,q,D_{k,h})\tau_i\tau_iU_{i,k,h}\cdot t + C_{i,k,h}h\tau_k\pik-1t_{1,q_1} \leq t_{2,q_2} \leq \cdots \leq t_{k-1,q_{k-1}}
\leq t_k = D_{k,h}t_{j,q_j}U_{i,k,h}C_{i,k,h}q_ik-1U_{i,k,h}C_{i,k,h}q\sum_{i=1}^{k-1} C_{i,k,h} < D_{k,h}h\tau_kk-1\frac{C_{i,k,h}}{U_{i,k,h}}\tau_i\pi\alpha_i=\beta_i=1t_{i,q}rbf(i,q,t)O(m_i)U_{i,k,h}C_{i,k,h}O(m_i^2)O(m_i)t_{i,0}rbf(i, 0, t_{i,0})O(m_i)t_{i,q}rbf(i,q,t_{i,q})O(m_i)O(\sum_{i=1}^{k-1}m_i + k \log k)U_{i,k,h}C_{i,k,h}\tau_iD_{k,h}\tau_iU_i\tau_i\tau_itC_{i,t}\frac{C_{i,t}}{U_i}\tau_it+\frac{C_{i,t}}{U_i}\tau_im_i\tau_i=\{\tau_{i,0}=\setof{C_{i,0}, D_{i,0},
  T_{i,0}}, \tau_{i,1}=\setof{C_{i,1}, D_{i,1}, T_{i,1}}, \ldots,
\tau_{i,m_i-1}=\setof{C_{i,m_i-1}, D_{i,m_i-1}, T_{i,m_i-1}}\}C_{i,j}T_{i,j}D_{i,j}\tau_{i,j}\tau_i\tau_{i,j}tt+D_{i, j}\tau_it+T_{i,j}D_{i,j} \leq T_{i,j}\tau_{k,h}hp(\tau_{k,h})\tau_{k,h}\tau_{k,h}\tau_{k,h}hp(\tau_{k,h})k-1\tau_{k,h}hp(\tau_{k,h})\setminus\setof{\tau_{k,h}}load(i, t)\tau_i\tau_{i,j} \in hp(\tau_{k,h})0ttn_{i,q}\tau_{i,q}C_i^{\max}(\tau_{k,h})\tau_i\tau_{k,h}\max_{\tau_{i,j} \in hp(\tau_{k,h})} C_{i,j}iU_i^{\max}(\tau_{k,h})\tau_i\tau_{k,h}\max_{\tau_{i,j} \in
  hp(\tau_{k,h})} \frac{C_{i,j}}{T_{i,j}}iC_{i}^{\max}(\tau_{k,h})U_i^{\max}(\tau_{k,h})\tau_{k,h}C_{i}^{\max}U_i^{\max}\tau_it_i\tau_{k,h}\tau_{k,h}d_{k,h}\tau_{k,h}a_1=d_{k,h}-D_{k,h}hp(\tau_{k,h})\tau_{k,h}hp(\tau_{k,h})a_1d_{k,h}a_0a_1\tau_{k,h}a_0hp(\tau_{k,h})a_0d_{k,h}a_1-a_0y\tau_id_{k,h}a_0+t_i\tau_it_i00 \leq t_i < y + D_{k,h}a_00\tau_itt_iload(i,t)\tau_itt_iload(i,t_i)+C_i^{\max}rbf(i, t_i, t)\tau_it\tau_{k,h}\tau_ka_1load(k, y)\tau_{k,h}(a_0, d_{k,h}]t(a_0, d_{k,h}]tload(i, t)load(i,t)t\left(\max_{\tau_{i,j} \in
    hp(\tau_{k,h})}\{\frac{C_{i,j}}{T_{i,j}}\}\right)\cdot t =
U_i^{\max}\cdot t\tau_i\tau_{k,h}C_i^{\max} = \max_{\tau_{i,j} \in hp(\tau_{k,h})}
  C_{i,j}U_i^{\max} = \max_{\tau_{i,j} \in hp(\tau_{k,h})}
  \frac{C_{i,j}}{T_{i,j}}k-1\tau_{k,h}\Delta_k^{\max}\max\{\max_{\tau_{k,j} \in hp(\tau_{k,h})}\{
  \frac{C_{k,j}}{T_{k,j}}\}, \frac{C_{k,h}}{D_{k,h}}\}\sum_{i=1}^{k-1} C_i^{\max} < D_{k,h}\tau_{k,h}\sum_{i=1}^{k-1} U_i^{\max} \leq 1k-1\frac{C_i^{\max}}{U_i^{\max}}\tau_it_i\tau_it_it_1
  \leq t_2 \leq \ldots \leq t_{k-1} \leq D_{k,h}+y = t_kt_j \in \setof{t_1, t_2, \ldots, t_k}\Delta_{k}^{\max}(D_{k,h}+y) + \sum_{i=1}^{k-1} U_i^{\max}t_i +
  \sum_{i=1}^{j-1} C_i^{\max}\leq t_j\alpha_i=1\beta_i=1y0\sum_{i=1}^{k-1} U_i^{\max} \leq 1\tau_i\tau_{k,h}U_i^{\max} = \max_{\tau_{i,j} \in hp(\tau_{k,h})}
  \frac{C_{i,j}}{T_{i,j}}k-1\tau_{k,h}U_k^{\max}\max\{\max_{\tau_{k,j} \in hp(\tau_{k,h})}\{
  \frac{C_{k,j}}{T_{k,j}}\}, \frac{C_{k,h}}{T_{k,h}}\}\sum_{i=1}^{k} U_i^{\max}\leq 1\tau_{k,h}T_{i,j} \leq T_{k,h}\tau_{i,j}hp(\tau_{k,h})C_i^{\max} \leq
  T_{k,h} U_i^{\max}\alpha =1\beta =1hp(\tau_{k,h})\sum_{i=1}^{k} U_i\leq 1kU_1, U_2, \ldots, U_k\tau_kkU_k\sum_{i=1}^{k} U_iH_1\sum_{i=1}^{k} U_i^2H_21-2H_1+U_k+0.5H_1^2+0.5H_2-0.5U_k^2U_k1-U_kU_kU_k \leq 12-\sqrt{2}k \rightarrow \infty$) in
\cite{DBLP:journals/tc/AbdelzaherSL04,HuangC-RTCSA15} for such a task model. Our
results here are more generic than \cite{DBLP:journals/tc/AbdelzaherSL04} and can also be easily applied for any
(mode-level or task-level) fixed-priority scheduling.


\end{document}
