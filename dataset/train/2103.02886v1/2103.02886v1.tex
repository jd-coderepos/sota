\documentclass{article}

\PassOptionsToPackage{numbers}{natbib}


\usepackage{amsmath,amssymb,graphicx,color,algorithm,subfig, algpseudocode,booktabs,bm,relsize,enumitem,multirow,amsthm,epsfig,caption}
\DeclareMathOperator*{\argmax}{argmax}
\DeclareMathOperator*{\argmin}{argmin}
\newcommand{\theHalgorithm}{\arabic{algorithm}}





\usepackage[final]{neurips_2020}



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{wrapfig}
\usepackage{bbm}
\usepackage{subfloat}

\usepackage{graphicx}
\newsavebox{\measurebox}

\hypersetup{colorlinks=true}
\hypersetup{citecolor=blue}
\hypersetup{linkcolor=blue}

\title{Improving Computational Efficiency in Visual Reinforcement Learning via Stored Embeddings}























































\author{\qquad
  \textbf{Lili Chen}
  \qquad
  \textbf{Kimin Lee}
  \qquad
  \textbf{Aravind Srinivas}
  \qquad
  \textbf{Pieter Abbeel}
  \qquad
  \\
  University of California, Berkeley \vspace{.1em}\\
}

\begin{document}

\maketitle

























\begin{abstract}



Recent advances in off-policy deep reinforcement learning (RL) have led to impressive success in complex tasks from visual observations. Experience replay improves sample-efficiency by reusing experiences from the past, and convolutional neural networks (CNNs) process high-dimensional inputs effectively. However, such techniques demand high memory and computational bandwidth. In this paper, we present Stored Embeddings for Efficient Reinforcement Learning (SEER), a simple modification of existing off-policy RL methods, to address these computational and memory requirements.
To reduce the computational overhead of gradient updates in CNNs, we freeze the lower layers of CNN encoders early in training due to early convergence of their parameters. Additionally, we reduce memory requirements by storing the low-dimensional latent vectors for experience replay instead of high-dimensional images, enabling an adaptive increase in the replay buffer capacity, a useful technique in constrained-memory settings. In our experiments, we show that SEER does not degrade the performance of RL agents while significantly saving computation and memory across a diverse set of DeepMind Control environments and Atari games. Finally, we show that SEER is useful for computation-efficient transfer learning in RL because lower layers of CNNs extract generalizable features, which can be used for different tasks and domains. 
\end{abstract}

\section{Introduction}




Success stories of deep reinforcement learning (RL) from high dimensional inputs such as pixels or large spatial layouts include achieving superhuman performance on Atari games~\citep{mnih2015human, schrittwieser2019mastering,  badia2020agent57}, grandmaster level in Starcraft II~\citep{vinyals2019grandmaster} and grasping a diverse set of objects with impressive success rates and generalization with robots in the real world~\citep{kalashnikov2018qt}.
Modern off-policy RL algorithms~\citep{mnih2015human, hessel2018rainbow, hafner2018learning, hafner2019dream, srinivas2020curl, kostrikov2020image, laskin2020reinforcement} have improved the sample-efficiency of agents that process high-dimensional pixel inputs with convolutional neural networks (CNNs; \citealt{lecun1998gradient}) using past experiential data that is typically stored as raw observations in a replay buffer~\citep{lin1992self}.
However, these methods demand high memory and computational bandwidth, which makes deep RL inaccessible in several scenarios, such as learning with much lighter on-device computation (e.g. mobile phones or other light-weight edge devices).


For compute- and memory-efficient deep learning, 
several strategies, such as network pruning~\citep{han2015deep, frankle2018lottery}, quantization~\citep{han2015deep,iandola2016squeezenet} and freezing~\citep{yosinski2014transferable,46337} 
have been proposed in supervised learning and unsupervised learning for various purposes (see Section~\ref{sec:ref} for more details).
In computer vision, 
\citet{46337} and \citet{brock2017freezeout} showed that the computational cost of updating CNNs can be reduced by freezing lower layers earlier in training, and \citet{han2015deep} introduced a deep compression, which reduces the memory requirement of neural networks by producing a sparse network.
In natural language processing,
several approaches~\citep{tay2019lightweight,sun2020mobilebert} have studied improving the computational efficiency of Transformers~\citep{vaswani2017attention}.
In deep RL, however, developing compute- and memory-efficient techniques has received relatively little attention despite their serious impact on the practicality of RL algorithms.



In this paper, we propose {\bf S}tored {\bf E}mbeddings for {\bf E}fficient {\bf R}einforcement Learning (SEER),
a simple technique to reduce computational overhead and memory requirements that is compatible with various off-policy RL algorithms~\citep{haarnoja2018soft,hessel2018rainbow,srinivas2020curl}.
Our main idea is to freeze the lower layers of CNN encoders of RL agents early in training, which enables two key capabilities: 
(a) compute-efficiency: reducing the computational overhead of gradient updates in CNNs; 
(b) memory-efficiency: saving memory by storing the low-dimensional latent vectors to experience replay instead of high-dimensional images. Additionally, we leverage the memory-efficiency of SEER to adaptively increase replay capacity, resulting in improved sample-efficiency of off-policy RL algorithms in constrained-memory settings. SEER achieves these improvements without sacrificing performance due to early convergence of CNN encoders. 

The main contributions of this paper are as follows:
\begin{itemize} [leftmargin=5.5mm]
    \item We present SEER, a compute- and memory-efficient technique that can be used in conjunction with most modern off-policy RL algorithms~\citep{haarnoja2018soft,hessel2018rainbow}.
    \item We show that SEER significantly reduces computation while matching the original performance of existing RL algorithms on both continuous control tasks from DeepMind Control Suite~\citep{tassa2018deepmind} and discrete control tasks from Atari games~\citep{bellemare2013arcade}.
    \item We show that SEER improves the sample-efficiency of RL agents in constrained-memory settings by enabling an increased replay buffer capacity.
    \item Finally, we show that SEER is useful for compute-efficient transfer learning, highlighting the generality and transferability of encoder features.
\end{itemize}

















\section{Related work} \label{sec:ref}

{\bf Off-policy deep reinforcement learning.} The most sample-efficient RL agents often use off-policy RL algorithms, a recipe for improving the agent's policy from experiences that may have been recorded with a different policy~\citep{sutton2018reinforcement}. Off-policy RL algorithms are typically based on Q-Learning~\citep{watkins1992q} which estimates the optimal value functions for the task at hand, while actor-critic based off-policy methods~\citep{lillicrap2015continuous, schulman2017equivalence, haarnoja2018soft} are also commonly used. 
In this paper we will consider Deep Q-Networks (DQN;~\citealt{mnih2015human}),which combine the function approximation capability of deep convolutional neural networks (CNNs; \citealt{lecun1998gradient}) with Q-Learning along with the usage of the experience replay buffer~\citep{lin1992self} as well as off-policy actor-critic methods~\citep{lillicrap2015continuous,haarnoja2018soft}, which have been proposed for continuous control tasks.

Taking into account the learning ability of humans and practical limitations of wall clock time for deploying RL algorithms in the real world, particularly those that learn from raw high dimensional inputs such as pixels~\citep{kalashnikov2018qt}, the sample-inefficiency of off-policy RL algorithms has been a research topic of wide interest and importance~\citep{lake2017building, kaiser2019model}. To address this, several improvements in pixel-based off-policy RL have been proposed recently: algorithmic improvements such as Rainbow~\citep{hessel2018rainbow} and its data-efficient versions~\citep{van2019use}; using ensemble approaches based on bootstrapping~\citep{osband2016deep, lee2020sunrise}; combining RL algorithms with auxiliary predictive, reconstruction and contrastive losses~\citep{jaderberg2016reinforcement, higgins2017darla, oord2018representation, yarats2019improving, srinivas2020curl, stooke2020decoupling}; using world models for auxiliary losses and/or synthetic rollouts~\citep{sutton1991dyna, ha2018world, kaiser2019model, hafner2019dream}; using data-augmentations on images~\citep{laskin2020reinforcement, kostrikov2020image}.




{\bf Compute-efficient techniques in machine learning.} 
Most recent progress in deep learning and RL has relied heavily on the increased access to more powerful computational resources. To address this, \citet{mattson2019mlperf} presented MLPerf, a fair and precise ML benchmark to evaluate model training time on standard datasets, driving scalability alongside performance, following a recent focus on mitigating the computational cost of training ML models.
Several techniques, such as pruning and quantization \citep{han2015deep,frankle2018lottery,blalock2020state,iandola2016squeezenet,tay2019lightweight} have been developed to address compute and memory requirements. \citet{46337} and \citet{brock2017freezeout} proposed freezing earlier layers to remove computationally expensive backward passes in supervised learning tasks, motivated by the bottom-up convergence of neural networks. This intuition was further extended to recurrent neural networks \citep{morcos2018insights} and continual learning \citep{pellegrini2019latent}, and \citet{yosinski2014transferable} study the transferability of frozen and fine-tuned CNN parameters. \citet{fang2019scene} store low-dimensional embeddings of input observations in scene memory for long-horizon tasks. We focus on the feasibility of freezing neural network layers in deep RL and show that this idea can improve the compute- and memory-efficiency of many off-policy algorithms using standard RL benchmarks.






\begin{figure*} [t] \centering
\subfloat[SEER before freezing.]
{
\includegraphics[width=0.45\textwidth]{draft_figures/before.pdf} 
\label{fig:main_transfer_stand_to_walk}} 
\subfloat[SEER after freezing.]
{
\includegraphics[width=0.45\textwidth]{draft_figures/after.pdf} 
\label{fig:main_transfer_stand_to_cheetah}} 
\caption{Illustration of our framework.
(a) Before the encoder is frozen,
all forward and backward passes are active through the network, and we store images in the replay buffer.
(b) After freezing,
we store latent vectors in the replay buffer, 
and remove all forward and backward passes through the encoder. We remark that more samples can be stored in the replay buffer due to the relatively low dimensionality of the latent vector.} \label{fig:main_figure}
\end{figure*}

\section{Background} \label{sec:background}



We formulate visual control task as a partially observable Markov decision process (POMDP; \citealt{sutton2018reinforcement, kaelbling1998planning}).
Formally, at each timestep , the agent receives a high-dimensional observation , which is an indirect representation of the state , and chooses an action  based on its policy .
The environment returns a reward  and the agent transitions to the next observation .
The return  is the total accumulated rewards from timestep  with a discount factor .
The goal of RL is to learn a policy  that maximizes the expected return over trajectories.
By following the common practice in DQN~\citep{mnih2015human}, we handle the partial observability of environment using stacked input observations, which are processed through the convolutional layers of an encoder .


{\bf Soft Actor-Critic}. SAC~\citep{haarnoja2018soft} is an off-policy actor-critic method based on the maximum entropy RL framework \citep{ziebart2010modeling}, which encourages robustness to noise and exploration by maximizing a weighted objective of the reward and the policy entropy.
To update the parameters, SAC alternates between a soft policy evaluation and a soft policy improvement.
At the soft policy evaluation step,
a soft Q-function, which is modeled as a neural network with parameters , is updated by minimizing the following soft Bellman residual:
 \label{eq:sac_critic_tot} 
where  is a transition,
 is a replay buffer,
 are the delayed parameters,
and  is a temperature parameter.
At the soft policy improvement step,
the policy  with its parameter  is updated by minimizing the following objective:

Here, the policy is modeled as a Gaussian with mean and covariance given by neural networks.

{\bf Deep Q-learning.} DQN algorithm~\citep{mnih2015human} learns a Q-function, which is modeled as a neural network with parameters ,
by minimizing the following Bellman residual:

where  is a transition,
 is a replay buffer, 
and  are the delayed parameters.
Rainbow DQN integrates several techniques,
such as double Q-learning~\citep{van2016deep} and distributional DQN~\citep{bellemare2017distributional}.
For exposition, we refer the reader to \citet{hessel2018rainbow} for more detailed explanations of Rainbow DQN.





\section{SEER: Stored Embeddings for Efficient Reinforcement Learning}

In this section, we present SEER: {\bf S}tored {\bf E}mbeddings for {\bf E}fficient {\bf R}einforcement Learning, which can be used in conjunction with most modern off-policy RL algorithms, such as SAC~\citep{haarnoja2018soft} and Rainbow DQN~\citep{hessel2018rainbow}.
Our main idea is to freeze lower layers during training and only update higher layers, which eliminates the computational overhead of computing gradients and updating in lower layers.
We additionally improve the memory-efficiency of off-policy RL algorithms by storing low-dimensional latent vectors in the replay buffer instead of high-dimensional pixel observations. See Figure \ref{fig:main_figure} and 
Appendix \ref{appendix:pseudocode} for more details of our method.

\subsection{Freezing encoder for saving computation and memory} \label{sec:freezing_encoder}

We process high-dimensional image input with an encoder  to obtain , which is used as input for policy  and Q-function  as described in Section \ref{sec:background}. In off-policy RL, 
we store transitions  in the replay buffer  to improve sample-efficiency by reusing experience from the past.
However, processing high-dimensional image input  is computationally expensive. 
To handle this issue, after  updates,
we freeze the parameters of encoder , and only update the policy and Q-function.
We remark that this simple technique can save computation without performance degradation because the encoder is modeled as deep convolutional neural networks, while a shallow MLP is used for policy and Q-function. Freezing lower layers of neural networks also has been investigated in supervised learning based on the observation that neural networks converge to their final representations {\em from the bottom-up}, i.e., lower layers converge very early in training~\citep{46337}. For the first time, we show the feasibility and effectiveness of this idea in pixel-based reinforcement learning (see Figure~\ref{fig:transfer_dmc_walk} for supporting experimental results) and present solutions to its RL-specific implementation challenges. 






Moreover, in order to save memory, 
we consider storing (compressed) latent vectors instead of high-dimensional image inputs.
Specifically, 
each experience in  is replaced by the latent transition , and the replay capacity is increased to  (see Section~\ref{sec:detail} for more details). 
Thereafter, for each subsequent environment interaction, 
the latent vectors  and  are computed prior to storing  in . During agent updates, the sampled latent vectors are directly passed into the policy  and Q-function , bypassing the encoder convolutional layers. Since the agent samples and trains with latent vectors after freezing, we only store the latent vectors and avoid the need to maintain large image observations in .




\subsection{Additional techniques and details for SEER} \label{sec:detail}

\textbf{Data augmentations.} Recently, various data augmentations~\citep{srinivas2020curl, laskin2020reinforcement,kostrikov2020image} have provided large gains in the sample-efficiency of RL from pixel observations.
However, SEER precludes data augmentations because we store the latent vector instead of the raw pixel observation.
We find that the absence of data augmentations could decrease sample-efficiency in some cases, e.g., when the capacity of  is small.
To mitigate this issue,
we perform  number of different data augmentations for each input observation  and store  distinct latent vectors .
We find empirically that  achieves competitive performance to standard RL algorithms in most cases.

\textbf{Increasing replay capacity.} 
By storing the latent vector in the replay buffer,
we can adaptively increase the capacity (i.e., total number of transitions), which is determined by the size difference between the input pixel observations and the latent vectors output by the encoder, with a few additional considerations.
The new capacity of the replay buffer is
\begin{center}
    ,
\end{center}
where  is the capacity of the original replay buffer,  is the size of the raw observation,  is the size of the latent vector, and  is the number of data augmentations. 
The number of encoders  is algorithm-specific and determines the number of distinct latent vectors encountered for each observation during training.
For Q-learning algorithms , whereas for actor-critic algorithms  if the actor and critic each compute their own latent vectors. Some algorithms employ a target network for updating the  Q-function~\citep{mnih2015human,haarnoja2018soft}, 
but we use the same latent vectors for the online and target networks after freezing to avoid storing target latent vectors separately and find that tying their parameters does not degrade performance.\footnote{We remark that the higher layers of the target network are not tied to the online network after freezing.}
The factor of 4 arises from the cost of saving floats for latent vectors, while raw pixel observations are saved as integer pixel values. We assume the memory required for actions and rewards is small and only consider only the memory used for observations. 

\begin{figure*} [t] \centering
\includegraphics[width=1\textwidth]{rebuttal/dm_flop_total.pdf}
\caption{Learning curves for CURL with and without SEER, where the x-axis shows estimated cumulative FLOPs. The dotted gray line denotes the encoder freezing time . 
The solid line and shaded regions represent the mean and standard deviation, respectively, across five runs.}
\label{fig:main_dmc}
\vspace{-0.1in}
\end{figure*}

\begin{figure*} [t] \centering
\includegraphics[width=1\textwidth]{rebuttal/atari_flop_total.pdf}
\caption{Learning curves for Rainbow with and without SEER, where the x-axis shows estimated cumulative FLOPs. The dotted gray line denotes the encoder freezing time . The solid line and shaded regions represent the mean and standard deviation, respectively, across five runs.}
\label{fig:main_atari}
\vspace{-0.1in}
\end{figure*}



\section{Experimental results}


We designed our experiments to answer the following questions: 
\begin{itemize} [leftmargin=8mm] \setlength\itemsep{0.1em}
  \item Can SEER reduce the computational overhead of various off-policy RL algorithms for both continuous (see Figure~\ref{fig:main_dmc}) and discrete (see Figure~\ref{fig:main_atari}) control tasks?
  \item Can SEER reduce the memory consumption and improve the sample-efficiency of off-policy RL algorithms by adaptively increasing the buffer size (see Figure~\ref{fig:memory_atari} and Figure~\ref{fig:memory_dmc})?
  \item Can SEER be useful for compute-efficient transfer learning (see Figure~\ref{fig:transfer_dmc_walk})?
  \item Do CNN encoders of RL agents converge early in training (see Figure~\ref{fig:attention_viz} and Figure~\ref{fig:svcca_viz})? 
\end{itemize}

\begin{table*}[]
\centering
\small
\begin{tabular}{l|ll|ll}
\toprule
 & \multicolumn{2}{c|}{Scores at 45T FLOPs} & \multicolumn{2}{c}{Scores  at 500K environment steps (0.07GB)} \\ \cline{2-5} 
 & Rainbow         & Rainbow+SEER         
 & Rainbow                 & Rainbow+SEER                  \\
 \midrule
Alien &  &   &  &   \\
Amidar &  &   &            &   \\
BankHeist &  &   &              &  \\
CrazyClimber &  &    &  &    \\
Krull &  &    &             &   \\
Qbert &  &   &             &   \\
RoadRunner &  &   &        &   \\
Seaquest &  &   &              &   \\
 \bottomrule
\end{tabular}
\caption{Scores on Atari games at 45T FLOPs corresponding to Figure \ref{fig:main_atari} and at 500K environment interactions in the constrained-memory setup (0.07GB) corresponding to Figure \ref{fig:memory_atari}. The results show the mean and standard deviation averaged five runs, and the best results are indicated in bold.} \label{tbl:main_atari}
\vspace{-0.1in}
\end{table*}

\begin{figure*} [ht] \centering
\includegraphics[width=1\textwidth]{rebuttal/atari_mem_total.pdf}
\caption{Comparison of the sample-efficiency of Rainbow with and without SEER in constrained-memory (0.07 GB) settings. The dotted gray line denotes the encoder freezing time . The solid line and shaded regions represent the mean and standard deviation, respectively, across five runs.} \label{fig:memory_atari}
\vspace{-0.1in}
\end{figure*}

\begin{figure*} [t] \centering
\subfloat[Cartpole-swingup]
{
\includegraphics[width=0.24\textwidth]{rebuttal/mem_cart.pdf} 
\label{fig:memory_dmc_cart}} 
\subfloat[Finger-spin]
{
\includegraphics[width=0.24\textwidth]{rebuttal/mem_finger.pdf}
\label{fig:memory_dmc_finger}} 
\subfloat[Reacher-easy]
{
\includegraphics[width=0.24\textwidth]{rebuttal/mem_reac.pdf}
\label{fig:memory_dmc_reacher}} 
\\
\subfloat[Walker-walk]
{
\includegraphics[width=0.24\textwidth]{rebuttal/mem_walk.pdf}
\label{fig:memory_dmc_walk}} 
\subfloat[Cheetah-run]
{
\includegraphics[width=0.24\textwidth]{rebuttal/mem_cheetah.pdf}
\label{fig:memory_dmc_cheetah}}
\caption{Comparison of the sample-efficiency of CURL with and without SEER in constrained-memory settings. The dotted gray line denotes the encoder freezing time . The solid line and shaded regions represent the mean and standard deviation, respectively, across five runs.} \label{fig:memory_dmc}
\vspace{-0.1in}
\end{figure*}

\subsection{Setups} \label{setups}

\textbf{Compute-efficiency.} 
We first demonstrate the compute-efficiency of SEER on the DeepMind Control Suite (DMControl; \citealt{tassa2018deepmind}) and Atari games~\citep{bellemare2013arcade} benchmarks.
DMControl is commonly used for benchmarking sample-efficiency for image-based continuous control methods.
For DMControl experiments,
we consider a state-of-the-art model-free RL method, which applies contrastive learning (CURL; ~\citealt{srinivas2020curl}) to SAC~\citep{haarnoja2018soft}, using the image encoder architecture from
SAC-AE~\citep{yarats2019improving}.
For evaluation,
we compare the computational efficiency of CURL with and without SEER by measuring floating point operations (FLOPs).\footnote{We explain our procedure for counting the number of FLOPs in Appendix \ref{appendix:flop_counting}.}
For discrete control tasks from Atari games,
we perform similar experiments comparing the FLOPs required by Rainbow~\citep{hessel2018rainbow} with and without SEER. For all experiments, we use the hyperparameters and architecture of data-efficient Rainbow \citep{van2019use}. 


\textbf{Memory efficiency.} We showcase the memory efficiency of SEER with a set of constrained-memory experiments in DMControl. For Cartpole and Finger, the memory allocated for storing observations is constrained to 0.03 GB, corresponding to an initial replay buffer capacity . For Reacher and Walker, the memory is constrained to 0.06 GB for an initial capacity of . In this constrained-memory setting, we compare the sample-efficiency of CURL with and without SEER.
As an upper bound, we also report the performance of CURL without memory constraints, i.e., the replay capacity is set to the number of training steps.
For Atari experiments,
the baseline agent is data-efficient Rainbow and the memory allocation is 0.07 GB, corresponding to initial replay capacity . 
The other hyperparameters are the same as those in the compute-efficiency experiments. 

The encoder architecture used for our experiments with CURL is used in \citet{yarats2019improving}. It consists of four convolutional layers
with 3 x 3 kernels and 32 channels, with the ReLU activation applied after each conv layer. The architecture used for our Rainbow experiments is from \citet{van2019use}, consisting of a convolutional layer with 32 channels followed by a convolutional layer with 64 channels, both with 5 x 5 kernels and followed by a ReLU activation. For SEER, we freeze the first fully-connected layer in CURL experiments and the last convolutional layer of the encoder in Rainbow experiments. We present the best results across various values of the encoder freezing time . See Appendices \ref{appendix:dmc_implementation_details} and  \ref{appendix:atari_implementation_details} for more hyperparameters and Appendix \ref{appendix:source_code} for source code.



\subsection{Improving compute- and memory-efficiency} \label{main_exps}

Experimental results in DMControl and Atari showcasing the computational efficiency of SEER are provided in Figures \ref{fig:main_dmc} and Figure \ref{fig:main_atari}. 
CURL and Rainbow both achieve higher performance within significantly fewer FLOPs when combined with SEER in DMControl and Atari, respectively.
Additionally, Table \ref{tbl:main_atari} compares the performance of Rainbow with and without SEER at 45T (4.5e13) FLOPs. In particular, the average returns are improved from 145.8 to 276.6 compared to baseline Rainbow in BankHeist and from 2325.5 to 4123.5 in Qbert. We remark that SEER achieves better computational efficiency while maintaining the agent's final performance and comparable sample-efficiency (see Appendix \ref{appendix:additional_figures2} for corresponding figures).

Experimental results in Atari and DMControl showcasing the sample-efficiency of SEER in the constrained-memory setup are provided in Figure~\ref{fig:memory_atari} and Figure~\ref{fig:memory_dmc}. CURL and Rainbow achieve higher final performance and better sample-efficiency when combined with SEER in DMControl and Atari, respectively. 
Additionally, Table \ref{tbl:main_atari} compares the performance of unbounded memory Rainbow and constrained-memory (0.07 GB) Rainbow with and without SEER at 500K interactions. In particular, the average returns are improved from 10498.0 to 17620.0 compared to baseline Rainbow in CrazyClimber and from 2430.5 to 3231.0 in Qbert.
Although we disentangle the computational and memory benefits of SEER in these experiments, 
we also highlight the computational gain of SEER in constrained-memory settings (effectively combining the benefits) in Appendix \ref{appendix:additional_figures1}.


\subsection{Freezing larger convolutional encoders} \label{impala}
\begin{wrapfigure}{r}{0.48\textwidth} \centering
\vspace{-20mm}
\subfloat[Cartpole-swingup]
{
\includegraphics[width=0.22\textwidth]{rebuttal/impala_cartpole.png} 
\label{fig:impala_cartpole}} 
\subfloat[Walker-walk]
{
\includegraphics[width=0.22\textwidth]{rebuttal/impala_walker.png} 
\label{fig:impala_walker}} 
\vspace{-1mm}
\caption{Learning curves using IMPALA architecture, where the x-axis shows estimated cumulative FLOPs. The dotted gray line denotes the encoder freezing time . The solid line and shaded regions represent the mean and standard deviation, respectively, across three runs.}
\vspace{-0.2in}
\end{wrapfigure} \label{fig:impala_plots}

We also verify the benefits of SEER using deeper convolutional encoders, which are widely used in a range of applications such as visual navigation tasks and favored for their superior generalization ability.
Specifically, 
we follow the setup described in Section \ref{setups} and replace the SAC-AE architecture (4 convolutional layers) with the IMPALA architecture \citep{espeholt2018impala} (15 convolutional layers containing residual blocks~\citep{he2016deep}).
Figure \ref{fig:impala_plots} shows the computational efficiency of SEER in Cartpole-swingup and Walker-walk with the IMPALA architecture. CURL achieves higher performance within significantly fewer FLOPs when combined with SEER.
We remark that the gains due to SEER are more significant because computing and updating gradients for large convolutional encoders is very computationally expensive.





\subsection{Improving compute-efficiency in transfer settings}

\begin{wrapfigure}{r}{0.48\textwidth} \centering
\vspace{-10mm}
\subfloat[To Walker-walk]
{
\includegraphics[width=0.22\textwidth]{rebuttal/rebuttal_walkerstand_to_walkerwalk.png} 
\label{fig:transfer_dmc_walk}} 
\subfloat[To Hopper-hop]
{
\includegraphics[width=0.22\textwidth]{rebuttal/rebuttal_walkerstand_to_hopperhop.png} 
\label{fig:transfer_dmc_hopper}} 
\caption{Comparison of the computational efficiency of agents trained from scratch with CURL and agents trained with CURL+SEER from Walker-stand pretraining. The solid line and shaded regions represent the mean and standard deviation, respectively, across three runs.}
\vspace{-0.2in}
\end{wrapfigure}

We demonstrate, as another application of our method, that SEER increases compute-efficiency in the transfer setting: utilizing the parameters from Task A on unseen Tasks B.
Specifically,
we train a CURL agent for 60K environment interactions on Walker-stand; 
then, we only fine-tune the policy and Q-functions on unseen tasks using network parameters from Walker-stand.
To save computation, during fine-tuning, we freeze the encoder parameters.
Figure \ref{fig:transfer_dmc_walk} shows the computational gain of SEER in task transfer (i.e., Walker-stand to Walker-walk similar to \citet{yarats2019improving}), and domain transfer (i.e., Walker-stand to Hopper-hop) is shown in Figure \ref{fig:transfer_dmc_hopper}. Due to the generality of CNN features,
we can achieve this computational gain using a pretrained encoder.
For the task transfer setup, we provide more analysis on the number of frozen layers and freezing time hyperparameter  in Appendix \ref{appendix:additional_transfer_dmc}.





\subsection{Encoder analysis}

In this subsection we present visualizations to verify that the neural networks employed in deep reinforcement learning indeed converge {\em from the bottom up}, similar to those used in supervised learning \citep{46337}. 
Figure \ref{fig:attention_viz} shows the spatial attention map for two Atari games and one DMControl environment at various points during training. Similar to \citet{laskin2020reinforcement} and \citet{zagoruyko2016paying}, we compute the spatial attention map by mean-pooling the absolute values of
the activations along the channel dimension and follow with a 2-dimensional spatial softmax.
The attention map shows significant change in the first  of training, and remains relatively unchanged thereafter, suggesting that the encoder converges to its final representations early in training. Figure \ref{fig:svcca_viz} shows the SVCCA \citep{46337} score, a measure of neural network layer similarity, between a layer and itself at time  and . The convolutional layers of the encoder achieve high similarity scores with themselves between time  and , while the higher layers of the policy and Q-network continue to change throughout training. In our DMControl environments we freeze the convolutional layers and the first fully-connected layer of the policy and Q-network (denoted fc1). Although the policy fc1 continues to change, the convergence of the Q-network fc1 and the encoder layers allow us to achieve our computational and memory savings with minimal performance degradation.

\begin{figure} [ht] \centering
\subfloat[Spatial attention map]
{
\includegraphics[width=0.5\textwidth]{draft_figures/attention_figure_final.pdf} 
\label{fig:attention_viz}} 
\subfloat[SVCCA similarity scores]
{
\includegraphics[width=0.46\textwidth]{draft_figures/svcca_figure_final.pdf} 
\label{fig:svcca_viz}} 
\caption{Visualizations of encoder features throughout training. (a) Spatial attention map from CNN encoders. (b) SVCCA \citep{46337} similarity scores between each layer and itself at time  and  throughout training for Walker-walk task.} \label{fig:viz}
\end{figure}

\section{Discussion} \label{discussion}
In this paper, we proposed a technique that reduces computation requirements for visual reinforcement learning, which we hope serves to facilitate a shift toward more compute-efficient RL. In this section, we highlight other techniques for reducing training time. For experimentation in computationally intensive environments, \citet{obando2020revisiting} propose to use small- and medium-scale experiments, which could reproduce the conclusions of the Rainbow DQN paper in Atari games. For faster training time in a particular experiment, one can also lower the resolution of the input images. In Figures \ref{fig:reduce_res_cartpole} and \ref{fig:reduce_res_walker} we show that reducing the resolution by a factor of 2, from  to  (and scaling crops appropriately) produces significant compute-efficiency gain in DeepMind Control Suite without sacrificing performance, and emphasize that this technique can be combined with SEER for further improved efficiency. We remark that the additional gain from SEER is larger in more complex environments (e.g., Walker) where learning requires more steps. However, we find that naive resolution reduction may not generally be applicable across environments and may require domain knowledge in order to prevent excessive information loss. In Figures \ref{fig:reduce_res_alien}, \ref{fig:reduce_res_amidar}, and \ref{fig:reduce_res_qbert} we show that resolution reduction by a factor of 2, from  to , results in noticeably worse performance in several Atari games. In contrast, SEER successfully improves compute-efficiency without sacrificing performance in these games (see Figure~\ref{fig:main_atari}). Overall, SEER is highly generalizable across visual domains, and can be easily combined with other modifications.

\begin{figure*} [t] \centering
\subfloat[Cartpole-swingup]
{
\includegraphics[width=0.24\textwidth]{rebuttal/reduce_res_cartpole.png} 
\label{fig:reduce_res_cartpole}} 
\subfloat[Walker-walk]
{
\includegraphics[width=0.24\textwidth]{rebuttal/reduce_res_walker.png} 
\label{fig:reduce_res_walker}}
\\
\subfloat[Alien]
{
\includegraphics[width=0.24\textwidth]{rebuttal/reduce_res_alien.png} 
\label{fig:reduce_res_alien}} 
\subfloat[Amidar]
{
\includegraphics[width=0.24\textwidth]{rebuttal/reduce_res_amidar.png} 
\label{fig:reduce_res_amidar}}
\subfloat[Qbert]
{
\includegraphics[width=0.24\textwidth]{rebuttal/reduce_res_qbert.png} 
\label{fig:reduce_res_qbert}}
\caption{Evaluation of the compute-efficiency of CURL (top) and Rainbow (bottom) with original and reduced (by factor of 2) resolutions. The solid line and shaded regions represent the mean and standard deviation, respectively, across five runs.} \label{fig:reduce_res_results}
\end{figure*}

\section{Conclusion}
We presented SEER, a simple but powerful modification of off-policy RL algorithms that significantly reduces computation and memory requirements while maintaining state-of-the-art performance. We leveraged the intuition that CNN encoders in deep RL converge to their final representations early in training to freeze the encoder and subsequently store latent vectors to save computation and memory. In our experimental results, we demonstrated the compute- and memory-efficiency of SEER in various DMControl environments and Atari games, and proposed a technique for compute-efficient transfer learning. With SEER, we highlight the potential for improvements in compute- and memory-efficiency in deep RL that can be made without sacrificing performance, in hopes of making deep RL more practical and accessible in the real world. 

\section{Acknowledgements}
We would like to thank Kourosh Hakhamaneshi and Fangchen Liu for providing helpful feedback and suggestions.
We would also like to thank Denis Yarats for the IMPALA encoder architecture implementation and Kai Arulkumaran for help with modifying the Rainbow DQN codebase.






\bibliography{main}
\bibliographystyle{icml2021}

\newpage
\appendix
\onecolumn

\begin{center}{\bf {\LARGE Appendix}}
\end{center}

\section{Source Code} \label{appendix:source_code}
We provide source code in \url{https://github.com/lili-chen/SEER}.

\section{Algorithm} \label{appendix:pseudocode}
We detail the specifics of modifying off-policy RL methods with SEER in Algorithm \ref{lever_pseudocode}. For concreteness, we describe SEER combined with deep Q-learning methods.

\begin{algorithm*}
\caption{Stored Embeddings for Efficient Reinforcement Learning (DQN Base Agent)}\label{euclid}
\begin{algorithmic}[1]
\State Initialize replay buffer  with capacity 
\State Initialize action-value network  with parameters  and encoder  with parameters 
\For{each timestep }
    \State Select action: 
    \State Collect observation  and reward  from the environment by taking action 
    \If{}
        \State Store transition  in replay buffer 
    \Else
        \State Compute latent states 
        \State Store transition  in replay buffer 
    \EndIf
    \State \textsc{// Replace pixel-based transitions with latent trajectories}
    \If{}
        \State Compute latent states 
        \State Replace  with latent transitions 
        \State Increase the capacity of  to 
    \EndIf
    \State \textsc{// Update parameters of Q-network with sampled images or latents}
    \For{each gradient step}
        \If{}
            \State Sample random minibatch 
            \State Calculate target 
            \State Perform a gradient step on 
        \Else
            \State Sample random minibatch 
            \State Calculate target 
            \State Perform a gradient step on 
        \EndIf
    \EndFor
    
\EndFor
\item[]
\end{algorithmic} \label{lever_pseudocode}
\end{algorithm*} 

\section{Calculation of Floating Point Operations} \label{appendix:flop_counting}
We consider each backward pass to require twice as many FLOPs as a forward pass. \footnote{This method for FLOP calculation is used in \url{https://openai.com/blog/ai-and-compute/}.} Each weight requires one multiply-add operation in the forward pass. In the backward pass, it requires two multiply-add operations: at layer , the gradient of the loss with respect to the weight at layer  and with respect to the output of layer () need to be computed. The latter computation is necessary for subsequent gradient calculations for weights at layer (). 

We use functions from \citet{huang2018condensenet} and \citet{jeong2019training} to obtain the number of operations per forward pass for all layers in the encoder (denoted ) and number of operations per forward pass for all MLP layers (denoted ). 


We denote the number of forward passes per training update , the number of backward passes per training update , and the batch size . We assume the number of updates per timestep is 1. Then, the number of FLOPs per iteration before freezing at time  is:
\begin{center}
    
\end{center}
where the last term is for the single forward pass required to compute the policy action. For the baseline, FLOPs are computed using this formula throughout training.

SEER reduces computational overhead by eliminating most of the encoder forward and backward passes. The number of FLOPs per iteration after freezing is:
\begin{center}
    
\end{center}
where  is the number of data augmentations and  is the number of networks as described in Section ~\ref{sec:detail}. The forward and backward passes of the encoder for training updates are removed, with the exception of the forward pass for computing the policy action and the  term at the end that arises from calculating latent vectors for the current observation.

At freezing time , we need to compute latent vectors for each transition in the replay buffer. This introduces a one-time cost of () FLOPs, since the number of transitions in the replay buffer is , where  is the initial replay capacity. 





\section{Transfer Setting Analysis} \label{appendix:additional_transfer_dmc}


In Figure \ref{fig:transfer_dmc_walk} we show the computational efficiency of SEER on Walker-walk with Walker-stand pretrained for 60K steps, with four convolutional layers frozen. We provide analysis for the number of layers frozen and number of environment interactions before freezing  in Figure \ref{fig:transfer_dmc_ablation}. We find that freezing more layers allows for more computational gain, since we can avoid computing gradients for the frozen layers without sacrificing performance. Longer pretraining in the source task improves compute-efficiency in the target task; however, early convergence of encoder parameters enables the agent to learn a good policy even with only 20K interactions before transfer.

We remark that \citet{yosinski2014transferable} examine the generality of features learned by neural networks and the feasibility of transferring parameters between similar image classification tasks. \citet{yarats2019improving} show that transferring encoder parameters pretrained from Walker-walk to Walker-stand and Walker-run can improve the performance and sample-efficiency of a SAC agent. For the first time, we show that encoder parameters trained on simple tasks can be useful for compute-efficient training in complex tasks and new domains. 



\begin{figure} [t] \centering
\subfloat[Number of frozen layers.]
{
\includegraphics[width=0.4\textwidth]{rebuttal/walker_layer_ablation.png}} 
\subfloat[Freezing time hyperparameter .]
{
\includegraphics[width=0.4\textwidth]{rebuttal/walker_time_ablation.png}} 
\caption{(a) Analysis on the number of frozen convolutional layers in Walker-walk training from Walker-stand pretrained for 60K steps. (b) Analysis on the number of environment steps Walker-stand agent is pretrained prior to Walker-walk transfer, where the first four convolutional layers are frozen.} \label{fig:transfer_dmc_ablation}
\end{figure}














\section{Compute-Efficiency in Constrained-Memory Settings} \label{appendix:additional_figures1}
In our main experiments, we isolate the two major contributions of our method, reduced computational overhead and improved sample-efficiency in constrained-memory settings. In Figure \ref{fig:memory_flops_atari} we show that these benefits can also be combined for significant computational gain in constrained-memory settings. 



\begin{figure*} [t] \centering
\subfloat[Alien]
{
\includegraphics[width=0.22\textwidth]{rebuttal/alien_sb_flops.png} 
\label{fig:app_atari_alien}} 
\subfloat[Amidar]
{
\includegraphics[width=0.22\textwidth]{rebuttal/amidar_sb_flops.png} 
\label{fig:app_atari_amidar}} 
\subfloat[BankHeist]
{
\includegraphics[width=0.22\textwidth]{rebuttal/bank_heist_sb_flops.png} 
\label{fig:app_atari_bank}} 
\subfloat[CrazyClimber]
{
\includegraphics[width=0.22\textwidth]{rebuttal/crazy_climber_sb_flops.png} 
\label{fig:app_atari_crazy}} 
\\
\subfloat[Krull]
{
\includegraphics[width=0.22\textwidth]{rebuttal/krull_sb_flops.png} 
\label{fig:app_atari_krull}} 
\subfloat[Qbert]
{
\includegraphics[width=0.22\textwidth]{rebuttal/qbert_sb_flops.png} 
\label{fig:app_atari_qbert}} 
\subfloat[RoadRunner]
{
\includegraphics[width=0.22\textwidth]{rebuttal/road_runner_sb_flops.png} 
\label{fig:app_atari_road}} 
\subfloat[Seaquest]
{
\includegraphics[width=0.22\textwidth]{rebuttal/seaquest_sb_flops.png} 
\label{fig:app_atari_sea}} 
\caption{Comparison of Rainbow in constrained-memory settings with and without SEER, where the x-axis shows estimated cumulative FLOPs, corresponding to Figure \ref{fig:memory_atari}. The dotted gray line denotes the encoder freezing time . The solid line and shaded regions represent the mean and standard deviation, respectively, across five runs.} \label{fig:memory_flops_atari}
\end{figure*}

\section{Sample-Efficiency Plots} \label{appendix:additional_figures2}
In section \ref{main_exps} we show the compute-efficiency of our method in DMControl and Atari environments. We show in Figure \ref{fig:main_samples_dmc} that our sample-efficiency is very close to that of baseline CURL \citep{srinivas2020curl}, with only slight degradation in Cartpole-swingup and Walker-walk. In Atari games (Figure \ref{fig:main_samples_atari}), we match the sample-efficiency of baseline Rainbow \citep{hessel2018rainbow} very closely, with no degradation.



\section{General Implementation Details} \label{appendix:freezing_details}
SEER can be applied to any convolutional encoder which compresses the input observation into a latent vector with smaller dimension than the observation. We generally freeze all the convolutional layers and possibly the first fully-connected layer. In our main experiments, we chose to freeze the first fully-connected layer for DM Control experiments and the last convolutional layer for Atari experiments. We made this choice in order to simultaneously save computation and memory; for those architectures, if we freeze an earlier layer, we save less computation, and the latent vectors (convolutional features) are too large for our method to save memory. In DM Control experiments, the latent dimension of the first fully-connected layer is 50, which allows a roughly 12X memory gain. In Atari experiments, the latent dimension of the last convolutional layer is 576, which allows a roughly 3X memory gain.

\begin{figure*} [t] \centering
\subfloat[Cartpole-swingup]
{
\includegraphics[width=0.24\textwidth]{rebuttal/cartpole_lb_samples.png} 
\label{fig:app2_dmc_cart}} 
\subfloat[Finger-spin]
{
\includegraphics[width=0.24\textwidth]{rebuttal/finger_lb_samples.png} 
\label{fig:app2_dmc_finger}}
\subfloat[Reacher-easy]
{
\includegraphics[width=0.24\textwidth]{rebuttal/reacher_lb_samples.png} 
\label{fig:app2_dmc_reacher}} 
\\
\subfloat[Cheetah-run]
{
\includegraphics[width=0.24\textwidth]{rebuttal/cheetah_lb_samples.png} 
\label{fig:app2_dmc_cheetah}} 
\subfloat[Walker-walk]
{
\includegraphics[width=0.24\textwidth]{rebuttal/walker_lb_samples.png} 
\label{fig:app2_dmc_walk}} 
\caption{Comparison of the sample-efficiency of CURL with and without SEER, corresponding to Figure \ref{fig:main_dmc}. The dotted gray line denotes the encoder freezing time . The solid line and shaded regions represent the mean and standard deviation, respectively, across five runs.} \label{fig:main_samples_dmc}
\end{figure*}

\begin{figure*} [t] \centering
\subfloat[Alien]
{
\includegraphics[width=0.22\textwidth]{rebuttal/alien_lb_samples.png} 
\label{fig:app2_atari_alien}} 
\subfloat[Amidar]
{
\includegraphics[width=0.22\textwidth]{rebuttal/amidar_lb_samples.png} 
\label{fig:app2_atari_amidar}} 
\subfloat[BankHeist]
{
\includegraphics[width=0.22\textwidth]{rebuttal/bank_heist_lb_samples.png} 
\label{fig:ap2_bank}} 
\subfloat[CrazyClimber]
{
\includegraphics[width=0.22\textwidth]{rebuttal/crazy_climber_lb_samples.png} 
\label{fig:app2_crazy}} 
\\
\subfloat[Krull]
{
\includegraphics[width=0.22\textwidth]{rebuttal/krull_lb_samples.png} 
\label{fig:app2_krull}} 
\subfloat[Qbert]
{
\includegraphics[width=0.22\textwidth]{rebuttal/qbert_lb_samples.png} 
\label{fig:app2_qbert}} 
\subfloat[RoadRunner]
{
\includegraphics[width=0.22\textwidth]{rebuttal/road_runner_lb_samples.png} 
\label{fig:app2_road}} 
\subfloat[Seaquest]
{
\includegraphics[width=0.22\textwidth]{rebuttal/seaquest_lb_samples.png} 
\label{fig:app2_sea}} 
\caption{Comparison of the sample-efficiency of Rainbow with and without SEER, corresponding to Figure \ref{fig:main_atari}. The dotted gray line denotes the encoder freezing time . The solid line and shaded regions represent the mean and standard deviation, respectively, across five runs.} \label{fig:main_samples_atari}
\end{figure*}

\section{DMControl Implementation details} \label{appendix:dmc_implementation_details}
We use the network architecture in \url{https://github.com/MishaLaskin/curl} for our CURL \citep{srinivas2020curl} implementation. We show a full list of hyperparameters in Table \ref{tbl:dmc_hyperparameters}.

\begin{table*}[ht]
\caption{Hyperparameters used for DMControl experiments. Most hyperparameter values are unchanged across environments with the exception of initial replay buffer size, action repeat, and learning rate.}
\vskip 0.15in
\begin{center}
\begin{small}
\begin{tabular}{ll}
\toprule
\textbf{Hyperparameter} & \textbf{Value}  \\
\midrule
Augmentation    & Crop  \\ 
Observation rendering    &   \\ 
Observation down/upsampling    &  \\ 
Replay buffer size in Figure \ref{fig:main_dmc}   & Number of training steps \\ 
Initial replay buffer size in Figure \ref{fig:memory_dmc}  &  cartpole, swingup; cheetah, run; finger, spin \\
 &  reacher, easy; walker, walk \\
Number of updates per training step  &  \\
Initial steps    &   \\ 
Stacked frames    &   \\ 
Action repeat    &  finger, spin; walker, walk\\
 &  cheetah, run; reacher, easy  \\
 &  cartpole, swingup \\
Hidden units (MLP)    &   \\ 
Evaluation episodes    &   \\ 
Evaluation frequency    &  cartpole, swingup \\ 
 &  cheetah, run; finger, spin; reacher, easy; walker, walk \\
Optimizer    & Adam  \\ 
   &   \\
   &   \\
Learning rate  &  cheetah, run \\ 
&  cartpole, swingup; finger, spin; reacher, easy; walker, walk \\
Learning rate () &  \\
Batch Size    &  cheetah, run \\
&  cartpole, swingup; finger, spin; reacher, easy; walker, walk \\
 function EMA  &  \\
Critic target update freq &  \\
Convolutional layers &  \\
Number of filters &  \\
Non-linearity & ReLU \\
Encoder EMA  &  \\
Latent dimension &  \\
Discount  &  \\
Initial temperature &  \\
Freezing time  in Figure \ref{fig:main_dmc} 
 &  cartpole, swingup \\
 &  finger, spin; reacher, easy \\
 &  walker, walk  \\
 &  cheetah, run \\
Freezing time  in Figure \ref{fig:memory_dmc} 
 &  cartpole, swingup \\
 &  finger, spin \\
 &  reacher, easy  \\
 &  cheetah, run; walker, walk  \\
\bottomrule
\end{tabular}
\end{small}
\label{tbl:dmc_hyperparameters}
\end{center}
\vskip -0.1in
\end{table*} 

\section{Atari Implementation details} \label{appendix:atari_implementation_details}
We use the network architecture in \url{https://github.com/Kaixhin/Rainbow} for our Rainbow \citep{hessel2018rainbow} implementation and the data-efficient Rainbow \citep{van2019use} encoder architecture and hyperparameters. We show a full list of hyperparameters in Table \ref{tbl:atari_hyperparameters}. 

\begin{table*}[ht]
\caption{Hyperparameters used for Atari experiments. All hyperparameter values are unchanged across environments with the exception of encoder freezing time.}
\vskip 0.15in
\begin{center}
\begin{small}
\begin{tabular}{ll}
\toprule
\textbf{Hyperparameter} & \textbf{Value}  \\
\midrule
Augmentation    & None  \\ 
Observation rendering    &   \\ 
Replay buffer size in Figure \ref{fig:main_atari}   & Number of training steps \\ 
Initial replay buffer size in Figure \ref{fig:memory_atari}  &  \\
Number of updates per training step  &  \\
Initial steps    &   \\ 
Stacked frames    &   \\ 
Action repeat    &  \\
Hidden units (MLP)    &   \\ 
Evaluation episodes    &   \\ 
Evaluation frequency    &   \\ 
Optimizer    & Adam  \\ 
   &   \\
Learning rate  
&  \\ 
Learning rate () &  \\
Batch Size    &    \\ 
Multi-step returns length &  \\
Critic target update freq &  \\
Convolutional layers &  \\
Number of filters &  \\
Non-linearity & ReLU \\
Discount  &  \\
Freezing time  in Figure \ref{fig:main_atari} 
 &  Alien; Amidar; BankHeist; Krull; RoadRunner; Seaquest \\
 &  CrazyClimber; Qbert \\
Freezing time  in Figure \ref{fig:memory_atari} 
 &  Amidar; BankHeist; Krull; RoadRunner \\
 &  Alien; CrazyClimber; Qbert \\
 &  Seaquest  \\
\bottomrule
\end{tabular}
\end{small}
\label{tbl:atari_hyperparameters}
\end{center}
\vskip -0.1in
\end{table*} 

\end{document}
