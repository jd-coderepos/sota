
\documentclass{article} \usepackage{iclr2022_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{relsize}
\usepackage[T1]{fontenc}
\usepackage[scaled=0.90]{inconsolata}

\usepackage{hyperref}
\usepackage{url}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{hhline}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{grffile}

\definecolor{Belize}{RGB}{41,128,185}

\newcommand{\mr}[2]{\multirow{#1}{*}{#2}}
\newcommand{\mc}[3]{\multicolumn{#1}{#2}{#3}}

\newcommand{\xx}{\mathbf{x}}
\newcommand{\ff}{\mathbf{f}}
\newcommand{\zz}{\mathbf{z}}
\newcommand{\FF}{\mathbf{F}}
\newcommand{\GGG}{\mathbf{G}}
\newcommand{\GG}{\mathbf{GNN}}
\newcommand{\uu}{\mathbf{u}}
\newcommand{\ee}{\mathbf{e}}
\newcommand{\hh}{\mathbf{h}}
\newcommand{\ttt}{\mathbf{t}}

\newcommand{\mm}{\mathbf{m}}
\newcommand{\aaa}{\mathbf{a}}

\newcommand{\N}{\mathcal{N}}

\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newcommand{\lz}[1]{\textcolor{blue}{#1}}
\newcommand{\ad}[1]{\textcolor{Belize}{#1}}
\newcommand{\bw}[1]{\textcolor{purple}{#1}}
\newcommand{\as}[1]{\textcolor{brown}{#1}}
\newcommand{\TODO}[1]{\textcolor{red}{TODO: #1}}

\DeclareMathOperator{\F}{f}
\DeclareMathOperator{\Fint}{f_{int}}
\DeclareMathOperator{\Fupdate}{f_{update}}
\DeclareMathOperator{\TU}{TripletUpdate}
\DeclareMathOperator{\EU}{EdgeUpdate}
\DeclareMathOperator{\NU}{NodeUpdate}
\DeclareMathOperator{\GU}{GlobalUpdate}

\DeclareMathOperator{\TA}{TripletAggr}
\DeclareMathOperator{\EA}{EdgeAggr}
\DeclareMathOperator{\NA}{NodeAggr}
\DeclareMathOperator{\GA}{GlobalAggr}

\DeclareMathOperator{\AllReduce}{AllReduce}


\title{Towards Training Billion Parameter Graph Neural Networks for Atomic Simulations}



\author{Anuroop Sriram$^\dagger$, Abhishek Das$^\dagger$, Brandon M. Wood$^{\ddagger \rightarrow \dagger}$, Siddharth Goyal$^\dagger$, C. Lawrence Zitnick$^\dagger$ \\
$^\dagger$Meta FAIR \\
$^\ddagger$National Energy Research Scientific Computing Center (NERSC) \\
\texttt{\{anuroops,abhshkdz,bmwood,sidgoyal,zitnick\}@fb.com} \\
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}

\maketitle

\begin{abstract}

Recent progress in Graph Neural Networks (GNNs) for modeling atomic simulations
has the potential to revolutionize catalyst discovery, which is a key step in
making progress towards the energy breakthroughs needed to combat climate change.
However, the GNNs that have proven most effective for this task are memory
intensive as they model higher-order interactions in the graphs such as those
between triplets or quadruplets of atoms, making it challenging to scale these models.
In this paper, we introduce \emph{Graph Parallelism}, a method to distribute input
graphs across multiple GPUs, enabling us to train very large GNNs with hundreds
of millions or billions of parameters. We empirically evaluate our method by
scaling up the number of parameters of the recently proposed DimeNet++ and
GemNet models by over an order of magnitude. On the large-scale Open Catalyst 2020 (OC20) dataset,
these graph-parallelized models lead to relative improvements of 1) $15\%$ on
the force MAE metric for the S2EF task and 2) $21\%$ on the AFbT metric for the
IS2RS task, establishing new state-of-the-art results.

\end{abstract}

\section{Introduction}
\label{sec:intro}

Graph Neural Networks (GNNs)~\citep{gori2005new,zhou2020graph} have emerged
as the standard architecture of choice for modeling atomic systems, with
a wide range of applications from protein structure prediction to catalyst discovery and drug design~\citep{schutt2017quantum,gilmer2017neural,jorgensen2018neural,zitnick2020introduction,schutt2017schnet,xie2018crystal}.
These models operate on graph-structured inputs, where nodes of the graph
represent atoms, and edges represent bonds or atomic neighbors. Despite their
widespread success and the availability of large molecular datasets, training massive GNNs (with up to billions of
parameters) is an important but under-explored area. Success of
similarly large models in computer vision, natural language processing, and speech
recognition~\citep{shoeybi2020megatronlm,huang2019gpipe,brown2020language,zhai2021scaling}
suggests that scaling up GNNs could yield significant performance gains.

Most previous approaches to scaling GNNs have focused on scaling small models (with up to a few million parameters) to massive graphs. These methods generally assume that we are working with a large, fixed graph, leading to the development of methods like neighborhood sampling~\citep{jangda2021accelerating,zheng2021distdgl}
~\citep{Jia2020ImprovingTA,Ma2019NeuGraphPD,tripathy2020reducing}.
These methods do not apply to atomic simulation datasets that contain millions of smaller graphs
where it is necessary to consider the entire graph for prediction. Our focus is on the complementary problem of scaling to very large models for a dataset of many moderately-sized graphs ($\sim1k$ nodes, $500k$ edges).

Another limitation of existing methods is that they focus on scaling simple GNN architectures such as Graph Convolutional Networks (GCNs) that only represent lower-order interactions~\textit{i.e.}, representations for nodes and edges, that are then updated by passing messages between neighboring nodes.
In practice, the most successful GNNs used for atomic systems also model higher-order interactions between atoms, such as the interactions between triplets or quadruplets of atoms~\citep{klicpera_dimenetpp_2020,klicpera2021gemnet,liu2021spherical}.
These interactions are necessary to capture the geometry of the underlying system,
critical in making accurate predictions. Scaling such GNN architectures is challenging because even moderately-sized graphs can contain a large number of higher-order interactions. For example, a single graph with $1k$ nodes could contain several million triplets of atoms.
In this paper, we introduce \emph{Graph Parallelism}, an approach to scale up
such GNNs with higher-order interactions to billions of parameters,
by splitting up the input graph across multiple GPUs.


We benchmark our approach by scaling up two recent GNN architectures -- DimeNet++~\citep{klicpera_dimenetpp_2020} and GemNet-T~\citep{klicpera2021gemnet} -- on the Open Catalyst (OC20) dataset~\citep{OC20}.
The OC20 dataset, aimed at discovering new catalyst materials for renewable energy storage,
consists of $134M$ training examples spanning a wide range of adsorbates and catalyst materials.
A GNN that can accurately predict per-atom forces and system energies on OC20
has the potential to replace the computationally expensive quantum chemistry calculations based on Density Functional Theory (DFT) that are currently the bottleneck in computational catalysis. Our large-scale, graph-parallelized models lead to relative improvements of
1) $15\%$ for predicting forces on the force MAE metric (S2EF task), and 2) $21\%$ on the AFbT metric for predicting relaxed structures (IS2RS task), establishing new state-of-the-art results on this dataset.










\section{Graph Parallelism}
\label{sec:graphparallel}

\subsection{Extended Graph Nets}
\label{sec:egn}

\cite{battaglia2018relational} introduced a framework called Graph Network (GN) that provides a general abstraction for many popular Graph Neural Networks (GNNs) operating on edge and node representations of graphs. We build on their work and define the Extended Graph Network (EGN) framework to include GNNs that also operate on higher order terms like triplets or quadruplets of nodes.

In the Graph Network (GN) framework, a graph is defined as a $3$-tuple $\GGG = (\uu, V, E)$, where $\uu$ represents global attributes about the entire graph; $V = \{\vv_i\}_{i=1:N^v}$ is the set of all nodes, with $\vv_i$ representing the attributes of node $i$; and $E = \{(\ee_k, r_k, s_k)\}_{k=1:N^e}$ is the set of all edges where $\ee_k$ represents the attributes for the edge from node $s_k$ to $r_k$. A GNN then contains a series of GN blocks
that iteratively operate on the input graph, updating the various representations.

In our \emph{Extended Graph Network (EGN)} framework, a graph is defined as a $4$-tuple $\GGG = (\uu, V, E, T)$, where $\uu, V,$ and $E$ are defined as in the Graph Network, and $T = \{(\ttt_m, e_{m_1}, e_{m_2}, \ldots)\}$ is the set of higher-order interaction terms involving edges indexed by $m_1, m_2, \ldots$.

As a concrete example, consider an atomic system represented as a graph in this framework with the nodes representing the atoms and the edges representing atomic neighbors. The node attributes $v_i$ and edge attributes $e_k$ could represent the atom's atomic numbers and distances between atoms respectively. The higher order interactions could represent triplets of atoms, \textit{i.e.}, pairs of neighboring edges with $\ttt_m$ representing the bond angle, which is the angle between edges that share a common node.
Finally, the global attribute $\uu$
can represent the energy of the system. For clarity of exposition, we will limit our discussion to triplets in the rest of the paper, but higher order interactions can be handled in a similar manner. We denote these triplets as $(\ttt_m, e_{m_1}, e_{m_2})$.

In the EGN framework, GNNs then contain a series of \emph{EGN blocks} that iteratively update the graph. Each EGN block consists of several \emph{update} and \emph{aggregation} functions that are applied to transform an input graph $(\uu, V, E, T)$ into an output graph $(\uu', V', E', T')$. Each EGN block starts by updating the highest order interactions, which are then aggregated before updating the next highest order interaction. For instance, the triplet representations are first updated (using $\TU$ function) and then aggregated ($\TA$) at each edge. These aggregated representations are then used to update the edge representation ($\EU$). Next, the edges going into a node are aggregated and used to update the node representations, and so on. This is illustrated in figure \ref{fig:egn_block}.











Many GNNs can be cast in the EGN framework using appropriate update and aggregation functions.





\begin{figure}[h]
\centering
    \begin{subfigure}[b]{0.9\textwidth}
        \centering
        \includegraphics[width=\textwidth]{extended_graph_nets.pdf}
        \caption{Forward computation of an EGN block. First, each triplet representation is updated ($\TU$ function),
        followed by aggregation of these updated representations ($\TA$).
        Next, these aggregated values are used to update edge representations ($\EU$), followed by edge aggregation ($\EA$),
        and finally node and global updates.}
        \label{fig:egn_block}
    \end{subfigure}

    \vspace{0.2cm}
    \begin{subfigure}[b]{0.9\textwidth}
    \centering
    \includegraphics[width=\textwidth]{graph_parallel.pdf}
    \caption{Distributed computation of an EGN block. The graph is split up among the different GPUs such that processing unit $p$ contains its subset of triplets $T^{(p)}$ in memory, along with all edges $E$ and nodes $V$. The triplet attributes are updated in parallel, followed by a triplet aggregation to locally update the edge attributes. Next, an {\tt allreduce} operation is performed to update all edge attributes globally. We continue this process to update the node and global attributes.}
    \label{fig:graph_parallel}

    \end{subfigure}

    \label{Sequential and distributed computation of an EGN block.}
\end{figure}

\subsection{Graph Parallelism for Extended Graph Nets}
\label{sec:gp-egn}

Training large EGNs can be challenging even on moderately sized graphs because of the large memory footprint required in storing and updating the representation for each triplet, edge, and node. In many applications, the number of edges is one or two orders of magnitude larger than the number of nodes, while the number of triplets is one or two orders of magnitude larger than the number of edges. Thus, storing and updating the triplet representations is often the bottleneck in terms of GPU memory and compute. Many recent methods such as \citep{klicpera_dimenetpp_2020,klicpera2021gemnet} overcome this problem by using a very low-dimensional representation for the triplets. However, we found this to significantly reduce model capacity leading to underfitting for some applications with large training datasets. It is necessary to overcome these memory limitations for better generalization.

One way to avoid the memory limits is to distribute the computation across multiple GPUs. For a graph neural network, a natural choice to distribute the computation is by splitting the graph.
The update functions in an EGN are easy to apply in parallel since they are applied independently for each triplet, edge, or node. It is substantially more challenging to apply the aggregations in parallel. To simplify parallel aggregation, we restrict ourselves to aggregation functions that are commutative and associative. This is not limiting in practice since most popular GNN architectures use sum or mean aggregations which can be implemented in this manner.

We will now describe the implementation of the distributed EGN block. Suppose we have access to $P$ processing units that we wish to split the graph computation over. Each unit $p$ is responsible for computing the updates to a subset of triplets, edges and nodes, that we denote by $T^{(p)}, E^{(p)},$ and $V^{(p)}$, respectively. At the beginning of computation, we split the graph so that the processing unit $p$ contains its subset of triplets $T^{(p)}$ in memory, along with the entire set of edges $E$ and nodes $V$. During the forward pass, we first update each set of triplets $T^{(p)}$ in parallel to obtain $T'^{(p)}$, followed by a local triplet aggregation. Next, an all-reduce operation is performed on these locally aggregated triplet representations to obtain globally aggregated triplet representations. These globally aggregated representations are then used to update edges in parallel, and the process is repeated for nodes and ultimately for the global graph level representation.
Figure~\ref{fig:graph_parallel} shows this.















In this framework, the highest order interaction attributes are never communicated across processors. Therefore, the communication time is bound by the number of lower order node interactions. In our example, the triplet representations are not communicated, while the edge and node representations are communicated once per EGN block, making the total communication cost equal to $O(N_v D_v + N_e D_e)$, where $D_v$ and $D_e$ are the dimensions of node and edge representations. This makes it possible to work with a large number of triplets and large triplet representations. In section \ref{sec:gp_atoms}, we show concrete instantiations of this framework for two contemporary GNNs.





\section{Graph Parallelism for Atomic Simulations} \label{sec:gp_atoms}

In this section, we present two concrete examples of using GNNs for the problem of predicting the energy and the forces for an atomic system, modeled as a graph whose nodes represent the atoms and whose edges represent the atoms' neighbors. The GNN takes such a graph as input and predicts the energy of the entire system as well as a 3D force vector on each atom. Two paradigms have been proposed in the literature, that we call \emph{energy-centric} and \emph{force-centric} approaches. These approaches differ in how they estimate forces and whether they are energy conserving, which is an important physical property. We begin by describing the components shared by both approaches, followed by one recent model in each paradigm.

\subsection{Inputs and Outputs}

The inputs to the network are 3D positions $\xx_i \in \R^3$ and atomic number $z_i$ for each atom $i \in \{1\ldots n\}$.
The outputs are the per-atom forces $\ff_i \in \R^3$ and the energy $E \in \R$ of the entire structure. The distance between atoms $i$ and $j$ is denoted as $d_{ij} = || \xx_i - \xx_j ||$. If edges $(i, j)$ and $(j, k)$ exist, then $(i, j, k)$ defines a \emph{triplet} in the graph and we denote the angle between the edges as $\alpha_{kj,ji}$.

The input graph is constructed with each atom $t$ (\emph{target}) as a node and the edges representing the atom's neighbors $s \in N_t$ where $N_t$ contains all atoms $s$ (\emph{source}) within a distance $\delta$, which is treated as a hyperparameter. Each edge has a corresponding message $m_{st}$ that passes information from source atom $s$ to target atom $t$.

\subsection{Estimating Forces and Energy}

As previously stated, there are two paradigms for estimating the energy and forces for an atomic system: \emph{energy-centric} and \emph{force-centric}. In energy-centric models, the model first computes the energy $E$ by applying a forward pass of the GNN: $E = \GG(\xx, \zz)$, where $\xx$, and $\zz$ represent the atomic positions and atomic numbers respectively. The forces are then computed as the negative gradient of the energy with respect to atomic positions by using backpropagation: $\ff = -\nabla_{\xx} E$.

In force-centric models, the energy and forces are both computed directly during the forward propagation: $E, \FF = \GG(\xx, \zz)$ where $\FF$ represents the matrix of all atomic forces. Force-centric models tend to be more efficient in terms of computation time and memory usage compared to the energy-centric models. However, energy-centric models guarantee that the forces are energy conserving which is an important physical property satisfied by atomic systems. In this work, we demonstrate the benefits of scaling up GNNs in both paradigms.

\subsection{Energy-Centric model: DimeNet++}

DimeNet++~\citep{klicpera_dimenetpp_2020} is a recently proposed energy-centric model for atomic systems. In this model, the edges are represented by a feature representation $\mm_{ji}$, which are iteratively updated using both directional information (via bond angles) as well as the interatomic distances. The edges are initially represented using a radial basis function (RBF) representation $\ee^{(ji)}_{RBF}$ of their lengths $d_{ji}$. The triplets are represented using a spherical basis function (SBF) expansion $\aaa^{(kj,ji)}_{SBF}$ of the distances $d_{kj}$ as well as bond angles $\alpha_{(kj,ji)}$. In each block, the messages are updated as:
\begin{equation}
    \mm_{ji}' = \Fupdate (\mm_{ji}, \sum_{k\in \N_j \textbackslash \{i\}} \Fint(\mm_{kj}, \ee^{(ji)}_{RBF}, \aaa^{(kj,ji)}_{SBF}))
\end{equation}
where the interaction function $\F_{int}$ corresponds to the $\TU$ function, the summation corresponds to the $\TA$ function, and the update function $\F_{update}$ to the $\EU$ function respectively. The interaction function consists of a Hadamard product of the embeddings, followed by a multi-layer perceptron. To speed up these computations, the embeddings are projected down to a smaller dimension before computing interactions, and later projected back up.

The updated messages are then fed as input to an output block that sums them up per atom $i$ to obtain a per-atom representation: $\hh_i = \sum_j \mm'_{ji}$ ($\EA$ function). These are then transformed by another MLP to obtain the node representation $\vv'_i$ ($\NU$ function).

Thus, DimeNet++ is a case of EGN, and we closely follow the recipe from Sec.~\ref{sec:gp-egn} to parallelize it.

\subsection{Force-Centric model: GemNet}

GemNet~\citep{klicpera2021gemnet} extends DimeNet++ in a number of ways, including the addition of quadruplets as well as a force-centric version. Here, we focus only on the force-centric GemNet-T model since it was recently shown to obtain state-of-the-art results on the OC20 dataset\footnote{{\href{https://opencatalystproject.org/leaderboard.html}{\tt opencatalystproject.org/leaderboard.html}}}. GemNet-T largely follows the structure of the DimeNet++ model, but includes some modifications.

First, GemNet-T uses a bilinear layer instead of the Hadamard product for the interaction function. This is made efficient by optimally choosing the order of operations in the bilinear function to minimize computation. Second, GemNet-T maintains an explicit embedding for each atom that is first updated by aggregating the directional embeddings involving that atom, similar to DimeNet++. Next, the updated atom embedding is used to update each of the edge embeddings. This creates a second edge update function, $\EU'$, that is run after the node embeddings are updated. Third, GemNet makes use of symmetric message passing, that is the messages $\mm_{ji}$ and $\mm_{ij}$ that are on the same edge, but in different directions, are coupled.
In a parallel implementation, this step requires an additional all-reduce step since messages $\mm_{ji}$ and $\mm_{ij}$ could be on different processors.

Thus, GemNet-T largely follows the EGN framework, with a few minor deviations from the standard formulation. The distributed EGN implementation described in section \ref{sec:gp-egn} can be used for the GemNet-T as well, but with additional communication steps to account for the second edge update function and symmetric message passing.

\section{Experiments}


In this section, we present the results of our scaling experiments on the Open Catalyst 2020 (OC20) dataset~\citep{OC20}. The OC20 dataset contains over 130 million atomic structures used to train models for predicting forces and energies during structure relaxations. We report results for three tasks: 1) Structure to Energy and Forces (S2EF) that involves predicting energy and forces for a given structure; 2) Initial Structure to Relaxed Energy (IS2RE) that involves predicting the relaxed energy for a given initial structure; and 3) Initial Structure to Relaxed Structure (IS2RS) which involves performing a structure relaxation using the predicted forces. DimeNet++ and GemNet-T are the current state-of-the-art energy-centric and force-centric models respectively.

\subsection{Experimental Setup}

\textbf{DimeNet++-XL}. Our DimeNet++ model consists of $B=4$ interaction blocks, with a hidden dimension of $H = 2048$, an output block dimension of $D = 1536$, and intermediate triplet dimension of $T = 256$. This model has about $240M$ parameters, which is over $20\times$ larger than the DimeNet++-large model used in~\citep{OC20}. We call this model \emph{DimeNet++-XL}. The model was trained with the AdamW optimizer~\citep{kingma2014adam,loshchilov2019decoupled} starting with an initial learning rate of $10^{-4}$, that was multiplied by $0.8$ whenever the validation error plateaus. The model was trained with an effective batch size of 128 on 256 Volta 32GB GPUs with a combination of data parallel and graph parallel training: each graph was split over 4 GPUs with data parallel training across groups of 4 GPUs.

\textbf{GemNet-XL}. Our GemNet model consists of $B = 6$ interaction blocks, with an edge embedding size of $E=1536$, triplet embedding size of $T=384$ and embedding dimension of the bilinear layer of $B=192$. We found that it was beneficial to use a small atom embedding size of $A=128$, much smaller than the previous SOTA GemNet model\footnote{\href{https://discuss.opencatalystproject.org/t/new-gemnet-dt-code-results-model-weights/102}{\tt discuss.opencatalystproject.org/t/new-gemnet-dt-code-results-model-weights/102}}. This model has roughly 300M parameters, which is about $10\times$ larger than the previous SOTA model. However, since we reduced the atom embedding dimension and increased the edge and triplet dimensions, the total amount of compute and memory usage is significantly larger. We call this model \emph{GemNet-XL}. We followed the same training procedure as with DimeNet++, except for a starting learning rate of $2\times10^{-4}$.



\subsection{Structure to Energy and Forces (S2EF)}
The Structure to Energy and Forces task takes an atomic structure as input and predicts the energy of the entire structure and per-atom forces. The S2EF task has four metrics: the energy and force Mean Absolute Error (MAE), the Force Cosine Similarity, and the Energy and Forces within a Threshold (EFwT). EFwT indicates the percentage of energy and force predictions below a preset threshold.

Table \ref{tab:s2ef_results} compares the top models on the Open Catalyst Project leaderboard$^1$ with the GemNet-XL model. GemNet-XL obtains a roughly $16\%$ lower force MAE and an $8\%$ lower energy MAE relative to the previous state-of-the-art. Further, GemNet-XL improves the EFwT metric more than $50\%$ relative to the previous best, although the value is still very small. These results indicate that model scaling is beneficial for the S2EF task.

\begin{table*}[t]
    \centering
    \renewcommand{\arraystretch}{1.0}
    \setlength{\tabcolsep}{5pt}
    \renewcommand{\arraystretch}{1.0}
    \setlength{\tabcolsep}{6pt}
    \resizebox{0.97\linewidth}{!}{
    \begin{tabular}{lrrrrrr}
        \toprule
        \mr{2}{\textbf{Model}} & \mr{2}{\textbf{\#Params}} & \mr{2}{\textbf{Training GPU-days}} & \mc{4}{c}{\textbf{S2EF Test}}\\
        & & & Energy MAE (eV)$\downarrow$ & Force MAE (eV/A)$\downarrow$ & Force Cos$\uparrow$ & EFwT$\uparrow$\\
        \midrule
        ForceNet-Large~\citep{hu2021forcenet} & 34.8M & 194 & 2.2628	 &0.03115	& 0.5195	& 0.01\% \\
        DimeNet++-Large~\citep{klicpera_dimenetpp_2020} & 10.8M & 1600 & 31.5409	& 0.03132	& 0.5440	& 0.00\% \\
        SpinConv~\citep{shuaibi_rotation_2021} & 8.9M & 76 & 0.3363 &	0.02966 &	0.5391 &	0.45\%	\\
        GemNet-T~\citep{klicpera2021gemnet} & 31M & 47 & 0.2924 & 0.02422 &	0.6162	& 1.20\% \\
        \midrule
GemNet-XL & 300M & 1962 & \textbf{0.2701} & \textbf{0.02040} & \textbf{0.6603} & \textbf{1.81\%} \\
        \bottomrule
\end{tabular}}
    \caption{Experimental results on the S2EF task comparing our GemNet-XL to the top entries on the Open Catalyst leaderboard, showing metrics averaged across the 4 test datasets.}
    \label{tab:s2ef_results}
    \vspace{-5pt}
\end{table*}

\subsection{Initial Structure to Relaxed Structure (IS2RS)}
The Initial Structure to Relaxed Structure (IS2RS) task involves taking an initial atomic structure and predicting the atomic structure that minimizes the energy. This is performed by iteratively predicting the forces on each atom and then using these forces to update the atomic positions. This process is repeated until convergence or 200 iterations. There are three metrics for this task: Average Distance within Threshold (ADwT), that measures the fraction of final atomic positions within a distance threshold of the ground truth; Forces below Threshold (FbT), which measures whether a true energy minimum was found (\textit{i.e.}, forces are smaller than a preset threshold); and, the Average Forces below Threshold (AFbt), which averages the FbT over several thresholds.

\begin{table*}[t]
    \centering
    \renewcommand{\arraystretch}{1.0}
    \setlength{\tabcolsep}{6pt}
\small
    \begin{tabular}{lrcrrr}
        \toprule
        \mr{2}{\textbf{Model}} & \mr{2}{\textbf{\#Params}} & \textbf{Training} & \mc{3}{c}{\textbf{IS2RS Test}} \\
        & & \textbf{Dataset} & AFbT$\uparrow$ & ADwT$\uparrow$ & FbT$\uparrow$ \\
        \midrule
        SpinConv~\citep{shuaibi_rotation_2021} & 8.9M & S2EF-All & 16.67\% &	53.62\% &	0.05\% \\
        DimeNet++~\citep{klicpera_dimenetpp_2020} & 1.8M & S2EF 20M + MD	& 17.15\%	& 47.72\%	& 0.15\% \\
        DimeNet++-large~\citep{klicpera_dimenetpp_2020} & 10.8M & S2EF-All & 21.82\% & 51.68\% & 0.40\% \\
        GemNet-T~\citep{klicpera2021gemnet} & 31M & S2EF-All &	27.60\%	& 58.68\%	& 0.70\% \\
        \midrule
        DimeNet++-XL & 240M & S2EF 20M + MD & \textbf{33.44\%} & 59.21\% & \textbf{1.25\%} \\
        GemNet-XL & 300M & S2EF-All & 30.82\% & \textbf{62.65\%} & 0.90\%\\
        \bottomrule
    \end{tabular}
\caption{Results on the IS2RS task comparing our models to the top entries on the Open Catalyst leaderboard, showing metrics averaged across the 4 test datasets. The DimeNet++ and DimeNet++-XL models were trained on the S2EF 20M + MD dataset, that contains additional molecular dynamics data and has been shown to be helpful for the IS2RS task~\citep{OC20}.}
    \label{tab:is2rs_results}
    \vspace{-15pt}
\end{table*}


\begin{table*}[h]
    \centering
    \renewcommand{\arraystretch}{1.0}
    \setlength{\tabcolsep}{6pt}
\small
    \begin{tabular}{llrr}
        \toprule
        \mr{2}{\textbf{Model}} & \mr{2}{\textbf{Approach}} & \mc{2}{c}{\textbf{IS2RE Test}}\\
        & & Energy MAE (EV)$\downarrow$ & EwT$\uparrow$ \\
        \midrule
        SpinConv~\citep{shuaibi_rotation_2021} & Relaxation & 0.4343	& 7.90\% \\
        GemNet-T~\citep{klicpera2021gemnet} & Relaxation & 0.3997	& 9.86\% \\
        Noisy Nodes~\citep{godwin_iclr22} & Direct	& 0.4728	& 6.50\%	\\
        3D-Graphormer~\citep{graphormer} & Direct	& 0.4722	& 6.10\%	\\
        \midrule
        GemNet-XL & Relaxation & \textbf{0.3712} & \textbf{11.13\%} \\
        GemNet-XL-FT & Direct & 0.4623 & 5.60\% \\
        \bottomrule
    \end{tabular}
\caption{Results on the IS2RE task comparing our GemNet-XL to the top entries on the Open Catalyst leaderboard, showing metrics averaged across the 4 test datasets.}
    \label{tab:is2re_results}
\end{table*}

Table \ref{tab:is2rs_results} shows the results on the IS2RS task, comparing our models with the top few models on the Open Catalyst leaderboard. Both the DimeNet++-XL and GemNet-XL models outperform all existing models. The DimeNet++-XL model obtains a relative improvement of 53\%  on the AFbT metric, and more than triples the FbT metric compared to the DimeNet-large model. The GemNet-XL model obtains similar improvements compared to the smaller GemNet-T model. These results underscore the importance of model scaling for this task.

\subsection{Initial Structure to Relaxed Energy (IS2RE)}

The Initial Structure to Relaxed Energy (IS2RE) task takes an initial atomic structure and attempts to predict the energy of the structure after it has been relaxed. Two approaches can be taken to address this problem, the direct and the relaxation approaches~\citep{OC20}. In the direct approach, we treat this task as a regression problem, and train a model to directly estimate the relaxed energy for a given atomic structure. The relaxation approach first estimates the relaxed structure (IS2RS task) after which the energy is estimated using the relaxed structure as input. Relaxation approaches typically outperform the direct approaches, though they are generally two orders of magnitude slower during inference time due to the need to estimate the relaxed structure.

Table \ref{tab:is2re_results} compares our GemNet-XL model to the top three models from the Open Catalyst Project leaderboard. There are two metrics for the IS2RE task: energy Mean Absolute Error (MAE) and the Energy within Threshold (EwT) which measures the percentage of time the predicted energy is within a threshold of the true energy. Table \ref{tab:is2re_results} shows that the GemNet-XL model obtains a roughly 8\% lower energy MAE and a 12\% higher EwT compared to the previous best, which is the smaller GemNet-T model, demonstrating the benefits of scaling up IS2RE models.

Since direct IS2RE models are very fast at inference time, there are applications where they are more useful than relaxation based approaches.
It is possible to convert a trained S2EF model into a direct IS2RE model by fine-tuning it on the IS2RE training data. We finetune our GemNet-XL model in this manner for 5 epochs, starting with an initial learning rate of $3\times10^{-5}$ that is exponentially decayed by multiplying with $0.95$ at the end of each epoch. The resuting model -- GemNet-XL-FT -- obtains a relative improvement of ${\sim}2\%$ on energy MAE compared to
3D-Graphormer~\citep{graphormer}, the current state-of-the-art direct approach (Table \ref{tab:is2re_results}).




\begin{table*}[t]
    \centering
    \renewcommand{\arraystretch}{1.0}
    \setlength{\tabcolsep}{6pt}
    \resizebox{0.97\linewidth}{!}{
    \begin{tabular}{c|c|c|c|c|c|c|c}
        \toprule
        \textbf{\#Blocks} & \textbf{Node Dim} & \textbf{Edge Dim} & \textbf{Trip Dim} & \textbf{Bil Dim} & \textbf{Params} & \textbf{\#GP GPUs} & \textbf{\#GP+DP GPUs}\\
        \midrule
        3 & 1280 & 768 & 128 & 64 & 125M & 1 & 32 \\
        4 & 1536 & 1024 & 192 & 96 & 245M & 2 & 64 \\
        6 & 1792 & 1184 & 288 & 160 & 480M & 4 & 128 \\
        8 & 2320 & 1302 & 512 & 288 & 960M & 8 & 256 \\
        \bottomrule
    \end{tabular}
    }
    \caption{Model hyperparameters for the scaling analysis. ``\#GP GPUs'' denotes the number of GPUs over which the graph is distributed over for pure graph parallel training on a single node. ``\#GP+DP GPUs'' denotes the total number of GPUs used to train with graph parallel training together with 32-way data parallel training.}
    \label{tab:scaling_models}
    \vspace{-14pt}
\end{table*}




\begin{figure}[h]
     \begin{subfigure}[b]{0.5\textwidth}
         \centering
         \includegraphics[scale=0.3]{efficiency.pdf}
         \caption{Weak scaling efficiency.}
\label{fig:weak_scaling}
     \end{subfigure}
     \quad
     \begin{subfigure}[b]{0.5\textwidth}
         \centering
         \includegraphics[scale=0.3]{scaling.pdf}
         \caption{Comparison of graph and pipeline parallel training.}
\label{fig:gp_ddp}
     \end{subfigure}

\caption{\textbf{Left:} Weak scaling efficiency measured by scaling the model size proportional to the number of GPUs. \textbf{Right:} Comparing graph parallelism with pipeline parallelism. Solid blue, green and red curves show the scaling performance of graph, pipeline, and graph+pipeline parallel training. Dashed lines show the same with 32-way data parallel training. We do not show the results of training the largest models with pipeline parallelism as those runs ran out of GPU memory.}
\vspace{-10pt}
\end{figure}

\subsection{Scaling Analysis}
\label{sec:scaling}

Weak scaling studies the effect on the throughput when computation is scaled proportional to the number of processors. We study weak scaling efficiency in terms of scaling the model size proportional to the number of GPUs. For these experiments, we use 4 different GemNet-T models, ranging from 120M parameters to nearly 1B parameters (see Table~\ref{tab:scaling_models}).

We train increasingly larger models on multiple GPUs that do not fit on a single GPU. Figure~\ref{fig:weak_scaling} shows that we are able to obtain a scaling efficiency of roughly $79\%$ with 8 GPUs for our largest model with nearly a billion parameters. This shows that our graph parallel training can be scaled up to billion parameter GemNet-T models while obtaining reasonably good scaling performance.

Figure~\ref{fig:weak_scaling} further shows the scaling efficiency for each model combining graph parallelism with 32-way data parallelism. Pure data parallel training with 32 GPUs obtains a scaling efficiency of $75\%$ for the smallest model, showing the effect of network communication and load imbalance between the GPUs. Combining graph and data parallel training with 256 GPUs only reduces the scaling efficiency to $47\%$ for the largest model compared to the 1 GPU case, suggesting the graph parallelism is promising for training extremely large models on hundreds of GPUs.

Finally, figure~\ref{fig:gp_ddp} shows the raw performance of running these models on V100 GPUs in terms of TeraFLOPs per second as a function of the number of GPUs. On a single GPU, the 120M parameter GemNet-T sustains 32 TeraFLOPs or roughly $25\%$ of the theoretical peak FLOPS for a single GPU, and is thus a strong baseline. With 256 GPUs, the largest model sustains $3.5$ PetaFLOPs.

Figure~\ref{fig:gp_ddp} compares graph and pipeline parallelism~\citep{huang2019gpipe} showing that graph parallelism outperforms pipeline parallelism for the models that we consider. Since each graph in the training data contains different numbers of nodes, edges and triplets, load balancing across GPUs is difficult for pipeline parallelism. Graph parallelism is able to overcome this problem since the nodes, edges and triplets of a given batch are always distributed evenly across the GPUs, helping it outperform pipeline parallelism.
It is possible, however, that pipeline parallelism might outperform graph parallelism for very deep GNNs since inter-GPU communication overhead for pipeline parallelism is independent of the number of blocks.
Figure ~\ref{fig:gp_ddp} also shows results with graph and pipeline parallelism combined,
indicating that these methods are complementary to each other.











\section{Related Work}
\label{sec:related}

\paragraph{GNNs for simluating atomic systems}
Many GNN based approaches have been proposed for the task of estimating atomic properties such as~\citep{schutt2017quantum,gilmer2017neural,jorgensen2018neural,schutt2017schnet,schutt2018schnet,xie2018crystal,qiao2020orbnet,klicpera2020directional}, where the atoms are represented by nodes and neighboring atoms are connected by edges. An early approach for force estimation was the SchNet model \cite{schutt2017schnet}, which computed forces using only the distance between atoms without the use of angular information. SchNet proposed the use of differentiable edge filters which enabled constructing energy-conserving models by estimating forces as the gradient of the energy.
Subsequent work~\citep{klicpera_dimenetpp_2020,klicpera2020directional,klicpera2021gemnet,liu2021spherical} has extended on the SchNet model by adding bond angles and dihedral angles, which has resulted in improved performance. These models make use of higher order interactions among nodes which make them highly compute and memory intensive. An alternate approach for estimating forces is to directly regress the forces as an output of the network. While this approach does not enforce energy conservation or rotational equivariance, recent work~\citep{hu2021forcenet} has shown that such models can still accurately predict forces.

\textbf{Distributed GNN Training}.
Research on distributed GNN training has focused on the regime of training small models on a single, large graph, for instance
by sampling local neighborhoods around nodes to create mini-batches~\citep{jangda2021accelerating,zhang2020agl,zhu2019aligraph}.
While these approaches can scale to very large graphs,
they are not suitable for the task of modeling atomic systems where it is important to consider the entire graph for predicting the energy and forces.

An alternate line of work, that is more similar to ours, keeps the entire graph in memory by efficiently partitioning the graph among multiple nodes \citep{Jia2020ImprovingTA,Ma2019NeuGraphPD,tripathy2020reducing}. These methods still operate in a single graph regime that is partitioned ahead of time. Thus the focus of that work is on finding efficient partitions of the graph, which is not applicable to our problem since we operate on millions of graphs.
Further, these works do not train very large GNNs, or GNNs that operate on higher-order interactions (\textit{e.g.} triplets), that are important for atomic systems.


\textbf{Model Parallelism}.
methods focus on training large models that do not fit entirely on one GPU (even with a batch size of 1).
GPipe~\citep{huang2019gpipe} splits different sequences of layers into different processors, and splits each training mini-batch into micro-batches to avoid idle time per GPU.
Megatron-LM~\citep{shoeybi2020megatronlm} splits the model breadth-wise, where Transformer layer weights are partitioned
across multiple GPUs to distribute computation.
We see model and graph parallelism as complementary approaches that can be combined to train even larger models.
\section{Discussion}
We presented Graph Parallelism, a new method for training large GNNs for modeling atomic
simulations, where modeling higher-order interactions between atoms (triplets / quadruplets) is critical.
We showed that training larger DimeNet++ and GemNet-T models can yield significant improvements on the OC20 dataset.
Although we demonstrated graph parallelism for just two GNNs, it is broadly applicable to a host of message-passing GNNs, including equivariant networks,
that can be cast in the GN / EGN framework (Sec.~\ref{sec:egn}) by appropriately picking update and aggregate functions.


Further, it is possible to combine graph parallelism with model parallel methods such as GPipe~\citep{huang2019gpipe}
to train even larger models, which could yield further improvements,
as briefly explored in Sec~\ref{sec:scaling}.
For force-centric GNNs,
it should be possible to use graph parallel for `breadth-wise' scaling~\textit{i.e.}, to split higher-order computations (\textit{e.g.} triplets)
across GPUs, and GPipe for `depth-wise' scaling~\textit{i.e.}, to scale to larger number of message-passing blocks,
sequentially split across GPUs.
For energy-centric GNNs \textit{e.g.}, DimeNet++, this combination is less obvious since these models
require an additional backward pass through the network to compute forces as gradients of
energy with respect to atomic positions.
Energy-centric GNNs are common for atomic systems because they enforce the physical constraint of energy conservation.
As we demonstrate with our DimeNet++-XL experiments, graph parallelism is applicable to energy-centric GNNs.

We see scaling to large model sizes as a necessary (but not sufficient) step to effectively
model atomic simulations from large, diverse datasets of adsorbates and catalysts.
Further progress may require marrying large scale with ways to better capture 3D geometry and physical priors.

The carbon emissions from training large deep learning models are non-trivial and the work we have presented here is no exception~\citep{strubell_arxiv19, schwartz_arxiv19}. We estimate that training our GemNet-XL model with Tesla v100 32 GB GPUs on cloud resources in the US ranges from 3490 - 8052 kg of CO$_2$ eq. ~\citep{lacoste2019quantifying}. In the worst case, the emissions are roughly equivalent to 16 round trip flights from Los Angeles to New York. Assuming that the training time is fixed, emissions largely depend on the carbon intensity of the energy generation in a given region and the percentage of emissions offset with other investments by the resource provider. When choosing compute resources we recommend evaluating the stated carbon offset commitments and if possible, consider running experiments in regions that have more sustainable energy generation.
The compute resources we utilized for this paper were committed to be $100\%$ offset.

\bibliography{graphparallel}
\bibliographystyle{iclr2022_conference}

\clearpage

\appendix
\section{Appendix}
\subsection{Additional results}

Tables \ref{tab:s2ef_results_full}, \ref{tab:is2re_results_full} and \ref{tab:is2rs_results_full} show results from each of the four test sets for the S2EF, IS2RE and IS2RS tasks respectively. DimeNet++-XL and GemNet-XL achieve the best results for each test set along each metric.

\begin{table*}[htb]
\centering
    \renewcommand{\arraystretch}{1.0}
    \setlength{\tabcolsep}{5pt}
    \renewcommand{\arraystretch}{1.0}
    \setlength{\tabcolsep}{6pt}
\begin{tabular}{l|cccc}
        \toprule
        \mr{2}{\textbf{Model}} & \mc{4}{c}{\textbf{S2EF Test}}\\
        & Energy MAE (EV)$\downarrow$ & Force Cos$\uparrow$ & Force MAE (EV/A)$\downarrow$ & EFwT$\uparrow$\\
        \midrule
        \mc{5}{c}{\textbf{ID}} \\
        GemNet-T &	0.2257	& 0.637	& 0.02099	& 2.4\% \\
        SpinConv & 0.2612 & 0.5479 & 0.02689 & 0.82\% \\
        ForceNet-Large & 2.0674	& 0.533 & 0.02782	& 0.02\% \\
        DimeNet++-large & 29.3333 & 0.5633 & 0.02807 & 0\% \\
        GemNet-XL & \textbf{0.2120} & \textbf{0.6759} & \textbf{0.0181} & \textbf{3.30\%} \\
        \midrule
        \mc{5}{c}{\textbf{OOD Ads}} \\
        GemNet-T & 0.2099 &	0.6242 & 0.02186 & 1.15\% \\
        SpinConv & 0.2752 & 0.5345 & 0.02769 & 0.38\% \\
        ForceNet-Large & 2.4188	& 0.5212	& 0.02834 & 0.01\% \\
        DimeNet++-large & 30.0338 & 0.5503 &	0.02896 & 0\% \\
        GemNet-XL & \textbf{0.1980} & \textbf{0.6642} & \textbf{0.0186} & \textbf{1.62\%} \\
        \midrule
        \mc{5}{c}{\textbf{OOD Cat}} \\
        GemNet-T & 0.3403 & 0.5813 & 0.02445 & 0.93\% \\
        SpinConv & 0.3501 & 0.5187 & 0.02849 & 0.46\% \\
        ForceNet-Large & 2.0203	& 0.4936 & 0.03089 & 0.01\% \\
        DimeNet++-Large & 30.0437	& 0.5109	& 0.0312 & 0\% \\
        GemNet-XL & \textbf{0.3083} & \textbf{0.6306} & \textbf{0.0206} & \textbf{1.72\%} \\
        \midrule
        \mc{5}{c}{\textbf{OOD Both}} \\
        GemNet-T & 0.3937 & 0.6221 & 0.02956 & 0.3\% \\
        SpinConv & 0.4585 & 0.5554 & 0.03556 & 0.14\% \\
        Forcenet-Large &	2.5447	& 0.5302 & 0.03754 & 0\% \\
        DimeNet++-Large & 36.7529 & 0.5517 & 0.03705 & 0\% \\
        GemNet-XL & \textbf{0.362} & \textbf{0.6704} & \textbf{0.0245} & \textbf{0.61\%} \\
        \bottomrule
    \end{tabular}
\caption{Full set of results on the S2EF task comparing our GemNet-XL to the top three entries on the Open Catalyst leaderboard, showing metrics from each test set. }
    \label{tab:s2ef_results_full}
\end{table*}

\begin{table*}[t]
\centering
    \renewcommand{\arraystretch}{1.0}
    \setlength{\tabcolsep}{6pt}
\begin{tabular}{l|l|cc}
        \toprule
        \mr{2}{\textbf{Model}} & \mr{2}{\textbf{Approach}} & \mc{2}{c}{\textbf{IS2RE Test}}\\
        & & Energy MAE (EV)$\downarrow$ & EwT$\uparrow$ \\
        \midrule
        \mc{4}{c}{\textbf{ID}} \\
        GemNet-T & Relaxation & 	0.3901	& 12.37\% \\
        SpinConv & Relaxation & 	0.4207	& 9.4\%	\\
        Noisy Nodes & Direct & 0.4776	& 5.71\% \\
        GemNet-XL & Relaxation & \textbf{0.3764} & \textbf{13.25\%} \\
        GemNet-XL-FT & Direct & 0.4194 & 7.52\% \\

        \midrule
        \mc{4}{c}{\textbf{OOD Ads}} \\
        GemNet-T & Relaxation &	0.3907	& 9.11\% \\
        SpinConv & Relaxation & 	0.4381	& 7.47\% \\
        Noisy Nodes & Direct &	0.5646	& 3.49\% \\
        GemNet-XL & Relaxation & \textbf{0.3677} & \textbf{10.00\%} \\
        GemNet-XL-FT & Direct & 0.5258 & 3.95\% \\

        \midrule
        \mc{4}{c}{\textbf{OOD Cat}} \\
        GemNet-T & Relaxation &	0.4339 &	10.09\% \\
        SpinConv & Relaxation & 0.4579	& 8.16\% \\
        Noisy Nodes & Direct &	0.4932	& 5.02\% \\
        GemNet-XL & Relaxation & \textbf{0.4022} & \textbf{11.61\%} \\
        GemNet-XL-FT & Direct & 0.4373 & 6.76\% \\

        \midrule
        \mc{4}{c}{\textbf{OOD Both}} \\
        GemNet-T & Relaxation &	0.3843	& 7.87\% \\
        SpinConv & Relaxation & 0.4203	& 6.56\% \\
        Noisy Nodes & Direct & 0.5042	& 3.82\% \\
        GemNet-XL & Relaxation & \textbf{0.3383} & \textbf{9.65\%} \\
        GemNet-XL-FT & Direct & 0.4665 & 4.19\% \\

        \bottomrule
    \end{tabular}
\caption{Experimental results on the IS2RE task comparing our GemNet-XL to the top three entries on the Open Catalyst leaderboard, showing metrics from each test set. }
    \label{tab:is2re_results_full}
\end{table*}


\begin{table*}[t]
\centering
    \renewcommand{\arraystretch}{1.0}
    \setlength{\tabcolsep}{6pt}
\begin{tabular}{lrccc}
        \toprule
        \mr{2}{\textbf{Model}} & \textbf{Training} & \mc{3}{c}{\textbf{IS2RS Test}} \\
        & \textbf{Dataset} & AFbT$\uparrow$ & ADwT$\uparrow$ & FbT$\uparrow$ \\
        \midrule
        \mc{5}{c}{\textbf{ID}} \\
        GemNet-T & S2EF-ALL & 33.75\% & 59.18\% & 2.0\% \\
        DimeNet++-large & S2EF-ALL & 25.65\% & 52.45\% & 1.0\% \\
        SpinConv & S2EF-ALL & 21.10\% &	53.68\% & 0.2\%	\\
        DimeNet++ & S2EF 20M + MD & 21.08\% & 48.6\% & 0.2\% \\
        DimeNet++-XL & S2EF 20M + MD & \textbf{40.00\%} & 59.90\% & \textbf{2.4\%} \\
        GemNet-XL & S2EF-ALL & 34.61 & \textbf{62.73\%} & \textbf{2.4\%} \\

        \midrule
        \mc{5}{c}{\textbf{OOD Ads}} \\
        GemNet-T & S2EF-ALL & 26.84\% & 54.59\% & 0.2\% \\
        DimeNet++-large & S2EF-ALL & 20.73\% & 48.47\% & 0.4\% \\
        SpinConv & S2EF-ALL & 15.70\% &	48.87\% & 0.0\%	\\
        DimeNet++- & S2EF 20M + MD & 17.05\% & 42.98\% & 0.0\% \\
        DimeNet++-XL & S2EF 20M + MD & \textbf{36.01\%} & 55.68\% & \textbf{1.6\%} \\
        GemNet-XL & S2EF-ALL & 30.32\% & \textbf{58.57\%} & 0.6\% \\

        \midrule
        \mc{5}{c}{\textbf{OOD Cat}} \\
        GemNet-T & S2EF-ALL & 24.69\% &	58.71\%	& 0.4\% \\
        DimeNet++-large & S2EF-ALL & 20.24\% & 50.99\% & 0\% \\
        SpinConv & S2EF-ALL & 15.86\% &	53.92\% & 0\%	\\
        DimeNet++- & S2EF 20M + MD & 16.43\% & 48.19\% & 0\% \\
        DimeNet++-XL & S2EF 20M + MD &  \textbf{29.62\%} & 58.43\% & \textbf{0.6\%} \\
        GemNet-XL & S2EF-ALL & 29.33\% & \textbf{62.60\%} & 0.2\% \\

        \midrule
        \mc{5}{c}{\textbf{OOD Both}} \\
        GemNet-T & S2EF-ALL & 25.11\% &	62.23\%	& 0.2\% \\
        DimeNet++-large & S2EF-ALL & 20.67\% & 54.82\% & 0.2\% \\
        SpinConv & S2EF-ALL & 14.01\% &	58.03\% & 0\%	\\
        DimeNet++- & S2EF 20M + MD & 14.02\% & 51.09\% & \textbf{0.4\%} \\
        DimeNet++-XL & S2EF 20M + MD & 28.14\% & 62.85\% & \textbf{0.4\%} \\
        GemNet-XL & S2EF-ALL & \textbf{29.02\%} & \textbf{66.72\%} & \textbf{0.4\%} \\

        \bottomrule
    \end{tabular}
\caption{Experimental results on the IS2RS task comparing our models to the top four entries on the Open Catalyst leaderboard, showing metrics for each test dataset. The DimeNet++ and DimeNet++-XL models were trained on the S2EF 20M + MD dataset, that contains additional molecular dynamics data, which has been shown to be helpful for the IS2RS task.}
    \label{tab:is2rs_results_full}
\end{table*}

\end{document}
