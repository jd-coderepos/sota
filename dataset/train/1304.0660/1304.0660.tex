\documentclass{llncs}




\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xspace}
\usepackage{stmaryrd}
\usepackage[usenames]{color}\usepackage{gastex}
\usepackage{cite}
\usepackage{caption}

\usepackage[usenames]{color}\usepackage{gastex}
\usepackage{url}
\usepackage{relsize}
\usepackage{graphicx}
\usepackage{latexsym}
\usepackage{boxedminipage}

\usepackage{multicol}
\usepackage{wrapfig}


\usepackage[nounderscore]{syntax}










\newcommand{\ignore}[1]{}
\newcommand{\tuple}[1]{\langle #1 \rangle}



\newcommand{\lub}{\sqcup}
\newcommand{\glb}{\sqcap}
\newcommand{\true}{\textit{true}}
\newcommand{\false}{\textit{false}}
\newcommand{\proj}{\downarrow}




\newcommand{\Strand}{\textsc{Strand}\xspace}
\newcommand{\libalf}{\textsc{libALF}\xspace}

\newcommand{\A}{\mathcal{A}}
\newcommand{\B}{\mathcal{B}}
\newcommand{\AEL}{\A_\text{el}}
\newcommand{\yblank}{-}
\newcommand{\blank}{\underline{b}}
\newcommand{\Lval}{L_{\text{v}}}



\newcommand{\next}{\texttt{next}}
\newcommand{\df}{\mathit{df}}
\newcommand{\DF}{\mathit{DF}}
\newcommand{\Loc}{\mathit{Loc}}
\newcommand{\PV}{\mathit{PV}}
\newcommand{\dom}{\mathbb{D}}
\newcommand{\DV}{\mathit{DV}}
\newcommand{\data}{\texttt{data}}
\newcommand{\new}{\texttt{new}}
\newcommand{\nil}{{\texttt{nil}}}
\newcommand{\pc}{\mathit{pc}}
\newcommand{\heap}{H}

\newcommand{\pval}{\mathit{pval}}
\newcommand{\dval}{\mathit{dval}}
\newcommand{\PC}{\mathit{PC}}


\newcommand{\dirty}{\mathit{dirty}}
\newcommand{\nilnode}{\mathit{nilnode}}

\newcommand{\run}{\rho}\newcommand{\QSDA}{\mbox{\sc QSDA}}
\newcommand{\EQSDA}{\mbox{\sc EQSDA}}



\newcommand{\F}{\mathcal{F}}
\newcommand{\HC}{\mathcal{H}} 




\pagestyle{plain}


\begin{document}




\title{Quantified Data Automata on Skinny Trees:\\
an Abstract Domain for Lists}


\author{
Pranav Garg\inst{1}, P. Madhusudan\inst{1}, Gennaro Parlato\inst{2}}

\institute{University of Illinois at Urbana-Champaign, USA\\
\and University of Southampton, UK}




\maketitle

\begin{abstract}
We propose a new approach to heap analysis through an abstract domain
of automata, called \emph{automatic shapes}. The abstract domain uses a particular kind of automata, called \emph{quantified data automata on skinny trees} (\QSDA s), that allows to define universally quantified properties of singly-linked lists.
To ensure convergence of the abstract fixed-point computation, we introduce a sub-class of \QSDA s called elastic \QSDA s, which also form an abstract domain.
We evaluate our approach on several list manipulating programs and we show that the proposed domain is powerful enough to prove a large class of these programs correct.
\end{abstract}




\section{Introduction}



The abstract analysis of heap structures is an important problem in program verification as dynamically evolving heap is ubiquitous in modern programming, either in terms of low level pointer manipulation or in object-oriented programming.
Abstract analysis of the heap is hard because abstractions need to represent the heap that is of unbounded size, and must capture both the \emph{structure} of the heap as well as the unbounded \emph{data} stored in the heap. While several data-domains have been investigated for data stored in static variables, the analysis of unbounded structure and unbounded data that a heap contains has been less satisfactory. The primary abstraction that has been investigated is the rich work on \emph{shape analysis}~\cite{shapeanalysis}. However, unlike abstractions for data-domains (like intervals, octagons, polyhedra, etc.), shape analysis requires carefully chosen \emph{instrumentation} predicates to be given by the user, and often are particular to the program that is being verified. Shape analysis techniques typically \emph{merge} all nodes that satisfy the same unary predicate, achieving finiteness of the abstract domain, and interpret the other predicates using a 3-valued (must, must not, may) abstraction. Moreover, these instrumentation predicates often require to be encoded in particular ways
(for example, capturing binary predicates as particular kinds of unary predicates) so as to not lose precision.


For instance, consider a sorting algorithm that has an invariant of the form:\\
\\
which says that the sub-list before pointer  is sorted.
In order to achieve a shape-analysis algorithm that discovers this invariant
 (i.e., captures this invariant precisely during the analysis),
we typically need instrumentation predicates such as ,
, etc.
The predicate  says that the element that is at  is less than
or equal to the data stored in every cell between  and .
These instrumentation predicates are clearly too dependent on the precise program and property
 being verified.



In this paper, we investigate an abstract domain for heaps that works \emph{without
user-defined instrumentation predicates} (except we require that the user fix an
abstract domain for data, like octagons, for comparing data elements).



We propose a radically new approach to heap analysis through an abstract domain
of automata, called \emph{automatic shapes} (automatic because we use automata).
The abstract domain uses a particular kind of automata, called \emph{quantified data automata}, that define, logically, universally quantified properties of heap structures. In this paper, we restrict our attention to heap structures that
have only \emph{one pointer field}; our analysis is hence one that can be used to analyze
properties of heaps containing lists, with possible aliasing (merging) of them,
especially at intermediate stages in the program. One-pointer heaps can be viewed
as \emph{skinny trees} (trees where the number of branching nodes is bounded).



Automata, in general, are classical ways to capture an infinite set of objects using
finite means. A class of (regular) skinny trees can hence be represented using tree
automata, capturing the structure of the heap. While similar ideas have been
explored before in the literature~\cite{forest-automata}, our main aim is to also represent properties of
the \emph{data} stored in the heap, building automata that can express
universally quantified properties on lists, in particular those
of the form\\\newline
 \\\newline
where  is the set of static pointer variables in the program.
The  formulas express structural constraints on the quantified variables
and the pointer variables, while the  formulas express properties about the
data stored at the nodes pointed to by these pointers. In this paper, we investigate
an abstract domain that can infer such quantified properties, parameterized by an abstract
numerical domain  for the data formulas and by the number of quantified variables .



The salient aspect of the automatic shapes that we build is that (a) there is no requirement
from the user to define instrumentation predicates for the structural 
formulas; (b) since the abstraction will not be done by merging unary predicates and since
the automata can define how data stored at \emph{multiple} locations on the heap are related,
there is no need for the user to define carefully crafted unary predicates that relate structure and data
(e.g., like the unary predicate  defined above that says that the location  is sorted with respect
to all successive locations that come after  but before ). Despite this lack of help
from the user, we show how our abstract domain can infer properties of a large number
of list-manipulating programs adequately to prove interesting quantified properties.



The crux of our approach is to use a class of automata, called quantified data automata on skinny trees (\QSDA),
to express a class of single-pointer heap structures and the data contained in them. \QSDA s read skinny
trees with data along with \emph{all} possible valuations of the quantified variables, and for each of them
check whether the data stored in these locations (and the locations pointed to by pointer variables in the
program) relate in particular ways defined by the abstract data-domain . We show that the
class of \QSDA s (over a data-domain  and a set of variable ) forms an abstract
data domain lattice. Along with the natural concretization and abstraction relations, this class forms
a Galois connection with respect to the class of concrete single-pointer heap data structures.



We further show, for a simple heap-manipulating programming language, that we can define an abstract
post operator over the abstract domain of \QSDA s. This abstract post preserves the structural aspects of the
heap \emph{precisely} (as \QSDA s can have an arbitrary number of states to capture the evolution of the
program) and that it soundly abstracts the quantified data properties. The abstract post is nontrivial
to define and show it effective as it requires automata-theoretic operations that need to simultaneously
preserve structure as well as data properties; this forms the hardest technical aspect of our paper.
We thus obtain an effective abstract interpretation using the domain of \QSDA s.



Traditionally, in order to handle loops and reach termination, abstract domains require some form of widening.
Our notion of widening is \emph{directed by decidability considerations}. Assume that the programmer computes
a \QSDA\ as an invariant for the program at a particular point, where there is an assertion expressed as
a quantified property  over lists (such as  ``the list pointed to by \emph{head} is sorted'').
In order to verify that the abstraction proves the assertion, we will have to check if the language of lists
accepted by the \QSDA\ is contained in the language of lists that satisfy the property . However, this is in
general \emph{undecidable}. Our aim is to \emph{overapproximate} the \QSDA\ into a larger language accepted
by a particular kind of data automata, called  {\em elastic} \QSDA\ (\EQSDA) for which this inclusion problem is
decidable (for an appropriately chosen language for expressing assertions).



This \emph{elastification} will in fact serve as the basis for widening as well, as there are only a \emph{finite} number of
elastic \QSDA s that express structural properties, discounting the data-formulas. Consequently, we
can combine the elastification procedure (which overapproximates a \QSDA\ into an elastic \QSDA) and
widening over the numerical domain for the data in order to obtain widening procedures that can be
used to accelerate the computation for loops. In fact, the domain of \EQSDA s can be seen as an abstract
domain, and there is a natural abstract interpretation between \QSDA s and \EQSDA s, where the \EQSDA s permit
widening procedures. We show a unique elastification theorem that shows
that for any \QSDA, there is a unique elastic \QSDA\ that over-approximates it. This elastification is in fact
the abstract map  that connects \QSDA s with \EQSDA s (the  map being identity, as \EQSDA s are also
\QSDA s).



We also show that \EQSDA\ properties over lists can be translated to a decidable fragment of the logic {\sc Strand}~\cite{popl11} over lists, and hence
inclusion checking an elastic \QSDA\ with respect to any assertion that is also written using the decidable
sublogic of {\sc Strand} over lists is decidable. The notion of \QSDA s and elasticity are extensions
of recent work in~\cite{CAVQDA}, where such notions were developed for \emph{words}
(as opposed to trees) and where the automata were used for \emph{learning} invariants from examples and counter-examples.



We implement our abstract domain and transformers and show, using a suite of list-manipulating programs,
that our abstract interpretation is able to prove the naturally required (universally-quantified) properties of these programs.
While
several earlier approaches (such as shape analysis) can tackle the correctness of these programs as well, our abstract
analysis is able to do this \emph{without} requiring program-specific help from the user (for example, in terms of
instrumentation predicates in shape analysis, and in terms of guard patterns in the work by Bouajjani et al~\cite{celia}).

\paragraph{\bf Related Work.}

Shape analysis~\cite{shapeanalysis} is the one of the most well-known technique for synthesizing invariants about dynamically evolving heaps. However, shape analysis requires user-provided instrumentation predicates which are often too particular to the program being verified. Hence coming up with these instrumentation predicates is not an easy task.
In recent work~\cite{sas10,chang-rival,celia,gulwani08}, several abstract domains have been explored which combine the shape and the data constraints.
Though some of these domains~\cite{sas10,chang-rival} can handle heap structures more complex than singly-linked lists, all these domains require the user to provide a set of data predicates~\cite{gulwani08} or a set of structural guard patterns~\cite{celia} or predicates over both the structure and the data constraints~\cite{sas10,chang-rival}.
In contrast, the only assistance our technique requires from the user is specifying the number of universally quantified variables.

For singly-linked lists,~\cite{rama} introduces a family of abstractions based on a set of instrumentation predicates which track uninterrupted list segments. However these abstractions only handle structural properties and not the more-complex quantified data properties.
Several separation logic based shape analysis techniques have also been developed over the years~\cite{distefano,guo,berdine,slayer}. But they too mostly handle only the shape properties (structure) of the heap.



Our automaton model for representing quantified invariants over lists is inspired by the decidable fragment of \Strand~\cite{popl11} and can track invariants with guard constraints of the form  or  for a universal variable  and some term . These structural constraints on the guard are very similar to array partitions in~\cite{gopan,halbwachs-pldi08,cousot-logozzo}. However, our automata model is more general. For instance, none of these related works can handle sortedness of arrays which requires quantification over more than one variable.

Techniques based on \emph{Craig's interpolation} have recently emerged as an orthrogonal way for synthesizing quantified invariants over arrays and lists~\cite{mcmillan06,mcmillan08,natasha,podelski}.
These methods use different heuristics like term abstraction~\cite{podelski} or introduction of existential ghost variables~\cite{natasha} or finding interpolants over a restricted language~\cite{mcmillan06,mcmillan08} to ensure the convergence of the interpolant from a small number of spurious counter-examples.
The shape analysis proposed in~\cite{podelski07} is also counter-example driven.~\cite{podelski07} requires certain quantified predicates to be provided by the user. Given these predicates, it uses a CEGAR-loop for incrementally improving the precision of the abstract transformer and also discovering new predicates on the heap objects that are part of the invariant.

Automata based abstract interpretation has been explored in the past~\cite{forest-automata} for inferring shape properties about the heap. However, in this paper we are interested in strictly-richer universally quantified properties on the data stored in the heap.~\cite{streaming-transducer} introduces a streaming transducer model for algorithmic verification of single-pass list-processing programs. However the transducer model severely constrains the class of programs it can handle; for example,~\cite{streaming-transducer} disallows repeated or nested list traversals which are required in sorting routines, etc.

In this paper we introduce a class of automata called quantified skinny-tree data automata (QSDA) to capture universally quantified properties over skinny-trees. The QSDA model is an extension of recent work in~\cite{CAVQDA} where a similar automata model was introduced for words (as opposed to trees). Also,
the automata model in~\cite{CAVQDA} was parameterized by a \emph{finite} set of data formulas and was used for \emph{learning} invariants from examples and counter-examples. In contrast, we extend the automata in~\cite{CAVQDA} to be instantiated with a (possibly-infinite) abstract domain over data formulas and develop a theory of abstract interpretation over QSDAs.










\section{Programs Manipulating Heap and Data}


We consider sequential programs manipulating acyclic singly-linked data structures. A {\em heap structure} is composed of locations (also called nodes). Each location is endowed  with a {\em pointer field}  that points to another location or it is undefined,  and a {\em data field} called  that takes values from a potentially infinite domain  (i.e. the set of integers). For simplicity we assume a special location, called , that models an un-allocated memory space. We assume that the  pointer field of  is undefined. Besides the heap structure, a program also has a finite number of {\em pointer variables} each pointing to a location in the heap structure, and a finite number of {\em data variables} over . In our programming language  we do not have procedure calls, and we handle non-recursive procedures calls by inlining the code at call points. In the rest of the section we formally define the syntax and semantics of these programs.



\begin{wrapfigure}[9]{r}[20pt]{83mm}
\vspace{-1.2cm}
  \centering
\scriptsize
  \begin{grammar}
    <prgm> ::=  pointer ; data ;  <pc\_stmt>
\vspace{-0.2cm}


    <pc\_stmt> ::=  <stmt>;
\vspace{-0.2cm}

      <stmt> ::= <ctrl\_stmt> | <heap\_stmt>
\vspace{-0.2cm}



     <ctrl\_stmt> ::= <data\_expr>  {\tt skip}
  {\tt assume}(<pred>) \alt {\tt if} <pred> {\tt then} <pc\_stmt> {\tt else} <pc\_stmt> {\tt fi}
\alt {\tt while} <pred> {\tt do} <pc\_stmt> {\tt od}

\vspace{-0.2cm}


     <heap\_stmt> ::= \mbox{}  \mbox{}    \mbox{} \alt \mbox{}  \mbox{}  \mbox{} \alt 

\end{grammar}
\vspace{-0.5cm}

\caption{Simple programming language.}
\label{grammar}
\end{wrapfigure}




\ignore{



\begin{wrapfigure}[h]{r}[20pt]{83mm}
  \begin{center}
\vspace*{-35pt}

{\bf \scriptsize
  \begin{grammar}
    <prgm> ::=  pointer ; data ;  <pc\_stmt>


\vspace*{-5pt}
    <pc\_stmt> ::=  <stmt>;

  \vspace*{-5pt}
      <stmt> ::= <ctrl\_stmt> | <heap\_stmt>

  \vspace*{-5pt}

     <ctrl\_stmt> ::= <data\_expr>  {\tt skip}
     {\tt assume}(<pred>) \alt {\tt if} <pred> {\tt then} <pc\_stmt> {\tt else} <pc\_stmt> {\tt fi}
\alt {\tt while} <pred> {\tt do} <pc\_stmt> {\tt od}

  \vspace*{-5pt}


     <heap\_stmt> ::= \mbox{}  \mbox{}    \mbox{} \alt \mbox{}  \mbox{}  \mbox{} \alt 







\end{grammar}
}

  \end{center}


\end{wrapfigure}
}



\paragraph{Syntax.}
The syntax of programs is defined by the BNF grammar of Figure~\ref{grammar}.
A program starts with the declaration of pointer variables among which one called , followed by a declaration of data variables. Data variables range over a potentially infinite data domain . We assume a language of data expressions built from data variables and terms of the form
 (with ) using operations over .
Predicates in our language are either data predicates built from predicates over  or structural predicates concerning the heap built from atoms of the form , , and  , for some . Thereafter, there is a non-empty list of labelled statements of the form
 where  is the {\em program counter} and  defines a language of either C-like statements or statements which modify the heap.  We do not have an explicit statement to {\em free} locations of the heap: when a location is no longer reachable from any location pointed by a pointer variable we assume that it automatically disappears from the memory. For a program , we denote with  the set of all program counters of  statements.
Figure~\ref{fig:prog}(a) shows the code for program \emph{sorted list-insert} which is a running example in the paper. The program inserts a \emph{key} into the sorted list pointed to by variable \emph{head}.

\paragraph{Semantics.} A {\em configuration}  of a program  with set of pointer variables  and data variables  is a tuple  where
\begin{itemize}
\item  is the program counter of the next statement to be executed;

\item  is a {\em heap configuration} represented by a tuple  where (1)  is a finite set of heap locations containing a special element called , (2)  is a partial map defining an edge relation among locations such that the graph  is acyclic, and (3)  is a  map that associates each location of  with a data value in ;
\item  associates each pointer variable of  with a location in . If  we say that node  is {\em pointed} by variable . Furthermore, each node in  is reachable from a node pointed by a variable in . There is no outgoing () edge from location  and there is a  edge from the location pointed by  to ;
\item  is a valuation map for the data variables.
\end{itemize}


Figure~\ref{fig:prog}(b) graphically shows a progam configuration which is reachable at program counter  of the program in Figure~\ref{fig:prog}(a) (as explained later we encode the data variable \emph{key} as a pointer variable in the heap configuration).
The {\em transition relation} of a program , denoted  for each statement  of , is defined as usual.  The control-flow statements update the program counter, possibly depending on a predicate (condition).
The assignment statements update the variable valuation or the heap structure other than moving to the next program counter. A formal semantics of programs can be found in Appendix~\ref{semantics}.
Let us define the concrete transformer . The concrete semantics of a program is given as the least fixed point of a set of equations of the form . 




To simplify the presentation of the paper, we assume that our programs do not have data variables. This restriction, indeed, does not reduce their expressiveness: we can always transform a program  into an {\em equivalent} program  by translating each data variable  into a pointer variable that will now point to a fresh node in the heap structure, in  which the value  is now encoded by . The node pointed by  is not pointed by any other pointer, further,  points to . Obviously, wherever  is used in  will now be replaced by  in . 







\section{Quantified Skinny-Tree Data Automata} \label{sec:qda}
In this section we define {\em quantified skinny-tree data automata} (\QSDA s, for short), an accepting  mechanism  of program configurations (represented as special labelled trees) on which we can express properties of the form \\
   ,
where variables  range over the set of locations of the heap,  represent quantifier-free structural constraints among the pointer variables and the universally quantified variables , and  (called {\em data formulas}) are quantifier-free formulas that refer to the data stored at the locations pointed either by the universal variables  or the pointer variables, and compare them using operators over the data domain.  In the rest of this section, we first define {\em heap skinny-trees} which are a suitable labelled tree encodings for program configurations; we then define {\em valuation trees} which are heap skinny-trees by adding to the labels an instantiation of the universal variables. {\em Quantified skinny-tree data automata} is a mechanism designed to recognize valuation trees. The {\em language} of a \QSDA\ is the set of all heap skinny-trees such that all valuation trees deriving from them are accepted by the \QSDA. Intuitively, the heap skinny-trees in the language defined by the \QSDA\ are all the program configurations that verify the formula .


Let  be a tree. A node  of  is {\em branching} whenever  has more than one child. For a given natural number ,   is  -{\em skinny} if it contains at most  branching nodes.








\begin{figure}[tb]
\framebox{
\scriptsize
\begin{minipage}{330pt}



\begin{multicols}{2}


{\tt pointer} , , , ;\\
{\tt data} ;\\
\\
{\tt 1}:\hspace*{0.11truecm}   := ;\\
{\tt 2}:\hspace*{0.13truecm}  {\tt while} (\\
\hspace*{1.0truecm}) {\tt do}\\
{\tt 3}:\hspace*{0.4truecm}  := ;\\
{\tt 4}:\hspace*{0.4truecm} ;\\
\hspace*{0.34truecm} {\tt od}\\
{\tt 5}:\hspace*{0.13truecm} {\texttt new} ;\\
{\tt 6}:\hspace*{0.11truecm}  := ;\\
{\tt 7}:\hspace*{0.11truecm}  := ;\\
{\tt 8}:\hspace*{0.13truecm} {\tt if} (  ) {\tt then}\\
{\tt 9}:\hspace*{0.4truecm}  := ;\\
\hspace*{0.34truecm} {\tt else}\\
{\tt 10}: \hspace*{0.19truecm}  := ;\\
\hspace*{0.34truecm} {\tt fi}\\



\columnbreak



\begin{picture}(177,49)(0,-49)
\setlength{\unitlength}{0.32mm}

\node[Nw=9.0,Nh=9.0,NLangle=130.0,NLdist=19.0,ilength=10.0,iangle=137.0,flength=8.0,Nmarks=if](n0)(16.0,-19.76){\scriptsize }
\nodelabel[NLangle=0.0](n0){\scriptsize }

\node[Nw=9.0,Nh=9.0,NLangle=130.0,NLdist=17.0,ilength=10.0,Nmarks=i](n1)(72.0,-19.76){\scriptsize }
\imark[ilength=10.0,iangle=137.0](n1)
\nodelabel[NLangle=0.0](n1){\scriptsize }

\node[Nw=9.0,Nh=9.0,NLangle=130.0,NLdist=17.0,ilength=10.0,iangle=137.0,flength=8.0,Nmarks=if](n2)(96.0,-19.76){\scriptsize }
\nodelabel[NLangle=0.0](n2){\scriptsize }

\node[Nw=9.0,Nh=9.0,NLangle=180.0,NLdist=22.0,Nmarks=i,ilength=8.0](n3)(84.0,-39.76){\scriptsize }
\nodelabel[NLangle=0.0](n3){\scriptsize }

\nodelabel[NLangle=211.0,NLdist=250.0](n3){\large (a)}
\nodelabel[NLangle=180.0,NLdist=130.0](n3){\large (b)}
\nodelabel[NLangle=224.0,NLdist=185.0](n3){\large (c)}
\nodelabel[NLangle=260.0,NLdist=130.0](n3){\large (d)}




\node[Nw=9.0,Nh=9.0,NLangle=130.0,NLdist=18.0,ilength=10.0,iangle=135.0,Nmarks=i](n4)(147.99,-20.0){\scriptsize }
\imark[ilength=8.0](n4)
\nodelabel[NLangle=0.0](n4){\scriptsize \
\textit{Strengthen} =   \lambda y. \lambda L_f. \big\{ (t', &\varphi') ~ | ~ \varphi': \varphi'' \sqcap \phi, ~(t', \varphi'') \in L_f,  \nonumber \\
	  		& \phi: \bigsqcap \{ \exists d. \varphi[y\rightarrow\data/d] ~|~ (t, \varphi) \in L_f, t \downharpoonright_y = t' \downharpoonright_y \}   \big\} \nonumber

\Delta_0^{\text{el}}(a) =& ~R_{\blank}(\Delta_0(a)) \nonumber \\
\Delta_1^{\text{el}}(S, a) =&
\begin{cases}
R_{\blank}(\Delta_1(S,a)) & \mbox{if } a \not= \blank \\
S  & \mbox{if } a = \blank \mbox{ and  is defined  for some } \\
\mbox{undefined}  & \mbox{otherwise.} \\
\end{cases} \nonumber \\
\Delta_i^{\text{el}}(S_1, \ldots, S_i, a) =& ~R_{\blank}(\Delta_i(S_1, \ldots, S_i, a )) \mbox{ for } i \in [2, k] \nonumber
I =
\exists  b_1 \ldots b_k. \forall y_1 \ldots y_{\ell}. \big(
\bigwedge_f (\wedge_i \phi_{if} \Rightarrow f(q_f)) \wedge (\bigvee_f \wedge_i \phi_{if} )
\big)

A key property in the decidable fragment of \Strand is that universal quantification is not permitted to be over elements that are only a bounded distance away from each other. See~\cite{CAVQDA} for a proof that the structural constraints  are such that  falls in the decidable fragment of \Strand.


\section{Experimental Evaluation}


We implemented the abstract domain over \QSDA s and \EQSDA s presented in this paper, and evaluated them on several list-manipulating programs. We now first present the implementation details followed by our experimental results.
Our prototype implementation along with the experimental results and programs can be found at \url{http://web.engr.illinois.edu/~garg11/qsdas.html}.




\paragraph{\bf Implementation details.}
Given a program  we compute the abstract semantics of the program over the abstract domain  over \EQSDA s.
A program is a sequence of statements as defined by the grammar in Figure~\ref{grammar}. In addition to those statements, a program is also annotated with a pre-condition and a bunch of assertions.
The pre-condition formulas belong to a fragment of \Strand over lists and can express quantified properties like sortedness of lists, etc. Given a pre-condition formula , we construct the smallest \EQSDA\ (with respect to the partial-order defined on the \QSDA s) which accepts all the heap skinny-trees which satisfy .
This \EQSDA\ gives us an abstraction of the initial configurations of the program. Starting from these configurations we compute the abstract semantics of the program over . The assert statements in the program are ignored during the fix-point computation. Once the convergence of the fix-point has been achieved, the \EQSDA s can be converted back into decidable \Strand formulas (as described in Section~\ref{sec-translation}) and the \Strand decision procedure can be used for validating the assertions.

We recall that the abstract domain  is an abstraction of . So, as much as possible, we want to compute the abstract semantics over the more concrete domain out of the two, i.e. .
Therefore, for every statement in the program we apply the abstract transformer   (and not the more abstract ). The intermediate semantic facts (\QSDA s) in our analysis are thus not necessarily elastic.
However to ensure convergence of the analysis, the \QSDA s at the header of the loops are first abstracted to elastic \QSDA s using  before the join.



Our abstract domains are parameterized by a quantifier-free domain  over the data formulas. In our experiments, we instantiate  with the octagon abstract domain~\cite{octagon} from the Apron library~\cite{apron}. It is sufficient to capture the pre/post-conditions and the invariants of all our programs.


\begin{table*}[thb]
	\centering


{\scriptsize
\begin{tabular}{|l| r | r | r | r|| r | r |r||}
	\hline
	~~~Programs & \#PV & \#Y & \#DV & Property~~ & \#Iter & Max. size & Time (s) \\
	 & & & & checked~~~ & & of QSDA & \\  \hline \hline

{\sc init}	& 2 & 1 & 1 & {\sc Init, List} & 4 & 19 & 0.0 \\	\hline
{\sc add-head} & 2 & 1 & 1 & {\sc Init, List} & - & 11 & 0.1  \\ \hline
{\sc add-tail}  & 3 & 1 & 1 & {\sc Init, List} & 4 & 29 & 0.1  \\ \hline
{\sc delete-head} & 2 & 1 & 1 & {\sc Init, List} & - & 10 & 0.0 \\ \hline
{\sc delete-tail}  & 4 & 1 & 1 & {\sc Init, List} & 5 & 51 & 0.5  \\ \hline
{\sc max}	& 2 & 1 & 1 & {\sc Max, List} & 4 & 19 & 0.1   \\ \hline
{\sc clone}    & 4 & 1 & 1 & {\sc Init, List} & 4 & 44 & 0.7  \\ \hline
{\sc fold-clone}  & 5 & 1 & 1 & {\sc Init, List} & 5 & 57 &  3.2 \\ \hline
{\sc copy-Ge5}  &  4 & 1 & 0 & {\sc Gek, List} & 9 & 53 & 2.6  \\ \hline
{\sc fold-split} & 3 &  1 & 1 & {\sc Gek, List} & 4 & 33 & 0.3 \\ \hline
{\sc concat}  & 4 & 1 & 1 & {\sc Init, List} & 5 & 44 & 0.7 \\ \hline
{\sc sorted-find} & 2 & 2 & 2 & {\sc Sort, List} & 5 & 38 & 0.3 \\ \hline
{\sc sorted-insert} & 4 & 2 & 1 & {\sc Sort, List} & 6 & 163 & 5.8 \\ \hline
{\sc bubble-sort} & 4 & 2 & 1 & {\sc Sort, List} & 5/18 & 191 & 42.8 \\ \hline
{\sc sorted-reverse} & 3 & 2 & 0 & {\sc Sort, List} & 5 & 43 & 1.5 \\ \hline
{\sc expressOS-lookup-prev} & 3 & 2 & 1 & {\sc Sort, List} & 6 & 73 & 2.2 \\ \hline \hline

{\sc gslist-append} & 4 & 0 & 1 & {\sc List} & 8 & 3 & 0.0 \\ \hline
{\sc gslist-prepend} & 2 & 0 & 1 & {\sc List} & - & 3 & 0.0  \\ \hline
{\sc gslist-last} & 3 & 0 & 0 & {\sc Last, List} & 3 & 7 & 0.0 \\ \hline
{\sc gslist-free} & 3 & 0 & 0 & {\sc Empty, List} & 1 & 3 & 0.0 \\ \hline
{\sc gslist-position} &4 & 0 & 0 & {\sc List} & 3 & 13 &  0.0 \\ \hline
{\sc gslist-reverse} & 3 & 0 & 0 & {\sc List} & 3 & 5 & 0.0 \\ \hline
{\sc gslist-custom-find} &3 & 1 & 1 & {\sc Gek, List}  & 4 & 29 & 0.1 \\ \hline
{\sc gslist-nth} & 3 & 0 & 1 & {\sc List} & 3 & 7 & 0.0 \\ \hline
{\sc gslist-remove} & 4 & 0 & 1 & {\sc List} & 4 & 10 & 0.0 \\ \hline
{\sc gslist-remove-link} & 5 & 0 & 0 & {\sc List} & 4 & 16 & 0.0 \\ \hline
{\sc gslist-remove-all} & 5 & 1 & 1 & {\sc Gek, List} & 5 & 51 & 0.6 \\ \hline
{\sc gslist-insert-sorted} & 5 & 2 & 1 & {\sc Sort, List} & 6 & 279 & 27.4 \\ \hline

	\end{tabular}
}
	\caption{\small Experimental results. Property checked --- {\sc List}: the return pointer points to a list; {\sc Init}: the list is properly initialized with some key; {\sc Max}: returned value is the maximum of all data values in the list; {\sc Gek}: the list (or some parts of the list) have data values greater than or equal to a key ; {\sc Sort}: the list is sorted; {\sc Last}: returned pointer is the last element of the list; {\sc Empty}: the returned list is empty.}
	\label{results}
\end{table*}



\paragraph{\bf Experimental results} We evaluate our abstract domain on a suite of list-manipulating programs (see Table~\ref{results}). For every program we report the number of pointer variables (PV), the number of universal variables (Y), the number of data variables (DV) and the property being checked for the program. We also report the number of iterations required for the fixed-point to converge, the maximum size of the intermediate QSDAs and finally the time taken, in seconds, to analyze the programs.


The names of the programs in Table~\ref{results} are descriptive, and we only describe some of them. The program {\sc copy-Ge5} is from~\cite{celia} and copies from a list only those entries into a new list whose data value is greater than or equal to . Similarly, the program {\sc fold-split}~\cite{celia} splits a list into two lists--one which has only those entries whose data values are greater than or equal to a key  and the other list with entries whose data value is less than . The program {\sc expressOS-lookup-prev} is a method from the module cachePage in a verified-for-security platform for mobile applications~\cite{asplos13}. The module cachePage maintains a cache of the recently used disc pages as a priority queue based on a sorted list. This method returns the correct position in the cache at which a disc page could be inserted.
The programs in the second part of the table are various methods adapted from the Glib list library which comes with the GTK+ toolkit and the Gnome desktop environment. The program {\sc gslist-custom-find} finds the first node in the list with a data value greater  or equal to  and {\sc gslist-remove-all} removes all elements from the list whose data value is greater  or equal to . The programs {\sc gslist-insert-sorted} and {\sc sorted-insert} insert a key into a sorted list.

All experiments were completed on an Intel Core i5 CPU at 2.4GHz with 6Gb of RAM. The number of iterations is left blank for programs which do not have loops.
{\sc bubble-sort} program converges on a fix-point after 18 iterations of the inner loop and 5 iterations of the outer loop.
The size of the intermediate QSDAs depends on the number of universal variables and  the number of pointer variables and largely governs the time taken for the analysis of the programs.
For all programs, our prototype implementation computes their abstract semantics in reasonable time.
Moreover we manually verified that the final \EQSDA s in all the programs were sufficient for proving them correct (this validity check for assertions can be mechanized in the future). The results show that the abstract domain we propose in this paper is reasonably efficient and powerful enough to prove a large class of programs manipulating singly-linked list structures.


\newpage
\bibliographystyle{abbrv}
\bibliography{sample}
\newpage
\appendix

\section{Formal Semantics of Programs}\label{semantics}













In this appendix we describe the concrete semantics of the primitive statements in our programming language defined in Figure~\ref{grammar}.
Let us assume that there is a special program configuration  to which the progam transitions to on encountering a memory error. 

\begin{definition}[Strongest post-condition ]
Let  be a non- program configuration where . Then for any statement  ,  is the strongest post-condition of  with respect to the statement , written as , iff  where  and  is the updated program counter and 
one of the following holds:


\begin{itemize}

\item  (or ) and   and  and  (or .




\item  and  and  and if  and , then . If  or , then  is \emph{Error}.

\item  (or ) and  and  and  and  and if  and  and if  (or ), then . If  or , then  is .

\item  and  and ,  and  and .


\item  and  and  and  if , then .
If  or  then  is .


\item  and  and  and  and  and  if  then .
If  or if  then  is .

\item  and .



\item  and  and .

\item  and  and .

\end{itemize}

\end{definition}



\section{Proof of Theorem~\ref{thmelastification}}\label{app-elastification}

Note that  is elastic by definition of . It
is also clear that  because for each
run of  using states  the run of  on the
same input uses sets  such that , and by
definition  implies .

Now let  be an EQSDA with . Let  be a valuation tree 
accepted by  and let  be the
state of  reached on reading .  We want to show that .  Let  be the state reached in  on . We show that
 implies  for each . From this we obtain
 because  is
the least formula that is implied by all the  for .




Pick some state . By definition of  we
can construct a valuation tree  that leads to the state  in
 and has the following property: if all letters of the form
 and those that have a single child are removed from  and from , then the two
remaining trees have the same symbolic trees. In other words,  and  can be
obtained from each other by inserting and/or removing
-letters.

Since  is elastic,  also leads to  in . From this we
can conclude that  because otherwise there
would be a model of  that is not a model of  and by
changing the data values in  accordingly we could produce an input
that is accepted by  and not by .
\qed


\section{Construction of the Strengthen Operator}\label{app-strengthen}

Given a QSDA , we give below a high level sketch of how to construct the QSDA  accepting the following language of formula words: .
The construction of the QSDA  takes place in two steps. 

In the first step, we construct a QSDA  which accepts ()-labelled formula trees of the form . 

And in the second step, we take the cross-product of this automaton  with the initial automaton  to get the QSDA  such that if the symbolic tree  is mapped by  to data-formula  and the symbolic tree  is mapped by  to the data-formula , then  is mapped in the new automata  to the data-formula .
The required cross-product of two QSDAs is similar to the algorithm for computing intersection of tree automata.
The automata which computes the cross-product simulates the transitions of both the automata  and . 
However, since  accepts trees which do not have the variable  labeling them, the cross-product automata on a label  which contains  simulates the transitions of  on the label , but simulates the transition of  on the label .
 The states in the cross-product automaton are labeled with the meet of the data-formulas labeling the states of the two individual automata. 

So now let us describe the construction of the automaton . The QSDA  accepts symbolic trees of the form  if . Hence,  is an automaton which simulates the transitions of  on a symbolic tree, except when it reads a node in the tree labeled with label  which contains variable . When this happens,  simulates the transitions of  on the label .
The data-formulas mapped to each state in  is obtained by existentially quantifying out  from the data-formulas mapping the corresponding states in . 
Note that the transition relation of  we just described might be non-deterministic; the same symbolic tree  might be mapped to more than one data-formula eg.  and  and so on. We want the automata  to map  to the meet of all these formulas. This can be achieved by determinizing the transition relation of the QSDA, very similar to the determinization procedure of a tree automata. In addition, for a set of states in the deterministic automata, we label it with the meet of the data-formulas labeling each state in the set in the original non-deterministic automata.
In this way, the transition relation could be determinized to obtain QSDA . This completes the construction of .


\section{Construction of the Abstract Transformer}\label{app-construction}

First let us introduce some preliminary notation.
For a set S, let  denote the  cartesian power of .
For an n-tuple , let us define  for  as the projection onto the  component of the tuple i.e. . 
When the set  can be uniquely distinguished from all other components  of the -tuple ,  is also used to denote the  component of the tuple . For a tuple ,  is used to denote the tuple which is same as  except at the  components where the tuple  takes the value  respectively.


For a function , where , which maps a domain  to an -tuple , let  for  be defined such that  for all .
Also for a function , let us denote  as the function which is same as  but with its domain restricted to the set . for a given function , let us also define  as the function which is same as  except at the domain elements , \ldots,  where  takes the value , \ldots, .







We now present the construction of the abstract transformer for each case of the statement . 
Let the input \QSDA\ be of the form  where  and . Let us view  as a set of boolean vectors where the  bit in a vector indicates whether the pointer  belongs to the vector or not.
The output \QSDA\ after the execution of  is of the form  where:
\newline\newline
{\bf Case 1} (): 
The evaluation function  of the automaton depends on whether  co-occurs with  or not. To facilitate this, we split each state into two states . 
 Regarding the transition relation, for all transitions ,
\begin{itemize}
\item if , .
\item if  and  and , then   .
\item if  and  and , then   .

\item if  and  then there exists a state ,  such that . Correspondingly, we add transitions    and   .
\end{itemize}

The type  for every state  is:

p_j \in \mathcal{T}(q), p_i \notin \mathcal{T}(q)p_j \notin \mathcal{T}(q), p_i \in \mathcal{T}(q)\\
The evaluation function depends on whether the pointer  is  or not. 
Hence, . Otherwise, .
\newline\newline
{\bf Case 2} (): Firstly, . The automaton transitions to a state of the form  on reading the pointer variable . This is like guessing the state in which the automaton transitions to, on reading variable . After reading , the automaton
reads variable  and transitions from state  to a state of the form  where  is basically a pointer variable or a universal variable which is co-read with . The variable  is used later when defining the evaluation functions for states . 


More formally, for all transitions ,
\begin{itemize}
\item if  then .
\item if  and  then  .
\item if  and  then there exists a state  such that . 
Accordingly we add the transition,   if there exists a variable  such that  and . Otherwise the transition  .

This covers the case when state  was reached immediately after reading variable . For the other case, we add transitions 
     for all .
\end{itemize}

Note that the final evaluation formula is only associated with states of the form  or . For all  such that  and , . Otherwise, .
For all other states, the evaluation formula is .


Finally, for all , the type associated with  is given as:\\
q' \in Q, p_m \notin \mathcal{T}(q')q' = (q,*), q \in Qq' = (q, v), q \in Q, v \in PV \cup Y \cup \{-\}\\
\newline\newline
{\bf Case 3} ( ): The statement  allocates a new node which is pointed to by variable  and is added as a child to the root of data trees accepted by the original automaton. The universal variables, apart from the nodes already present in the data trees, now also have to valuate over the newly allocated node. The set of states of the new automaton is  where . The states of the form  are used to accept valuation trees where univeral variable  valuates over the newly allocated node whereas the other universal variables valuate over the existing nodes present in the heap tree. The states  are used to accept valuation trees where none of the universal variable valuates to the newly allocated node. The state  is used to transition the automaton to a special state on reading the new node labeled with pointer variable  i.e.  for all . Also for all transitions ,
\begin{itemize}
\item if ,  for all . 
\item if ,  for all .
\end{itemize}

The final evaluation formula is given as: \\
q \in Q, \hat{y} = y \in Yq \in Q, \hat{y} = -q = \hat{q}\\

Also the types for each state in the new automaton are:\\
q = \hat{q}, \hat{y} = -q = \hat{q}, \hat{y} = y \in Yq \in Q, {root} \notin \mathcal{T}(q), \hat{y} = -q \in Q, {root} \notin \mathcal{T}(q), \hat{y} = y \in Yq \in Q, {root} \in \mathcal{T}(q)\\
\newline\newline
{\bf Case 4} ():
Firstly, . 
From the semantics of the strongest-post, we know that the new automaton removes any sub-tree rooted at  and attaches it as an additional child to a node labelled with variable .
States of the form  are special states in which the automaton transitions to on reading the variable .
If  accepts a tree  rooted at  then the state  where  accepts a tree which has  as an additional child to an internal node labelled with . On the other hand, if  then  accepts a tree which had its subtree , rooted at , removed.
Describing the transition relation in detail, for a transition :
\begin{enumerate}
\item if ,  then we add the same transition to the new automaton i.e. .
\item if  and 
    \begin{itemize}
	\item and if  then the automaton should transition to a state of the form ; therefore . \item otherwise, there exists a state  such that . In case , in the original automaton, accepted trees rooted at , the new automaton should remove  from the left hand side of the transition and should transition to a state  via      . To handle the other case, where  accepted trees which were not rooted at , the transitions       are added for all .
    \end{itemize}

\item if  and 
	\begin{itemize}
	\item and if  then the new automaton should accept a tree at  which has an additional child  rooted at . Since all trees rooted at  are accepted at states of the form  (the first subcase of 2 above), transition  is added for all .
	\item otherwise, there exists a state  such that  and the fact, that any node labelled with  in the tree accepted at  has as an additional child a tree  rooted at , is propagated recursively via the transitions  for all . 
	\end{itemize}

\item if 
	\begin{itemize}
	\item and  (reagrdless of the value of ) no transition is added to , as any heap configuration accepted by the original automaton via this transition leads to a cycle on the execution of statement .
	\item otherwise if  and , there will exist a state  such that . The corresponding state in the new transition will be  if  was the state of the original automaton which accepted the internal subtree  rooted at . Since , an additional state  is added to the left hand side of the transition to ensure that the new automaton accepts the tree which has  as an additional child to a node labelled with . Formally,    for all .

	\item otherwise if  and there exists a state  such that  then the transition remains unchanged i.e.     .

	\item otherwise if  and there exist states  such that  and , then the transition          is added for all . Note that  accepts a tree which has an additional child (accepted at ) at a node labelled with  (explained in case 3 above) and  accepts a tree where the internal subtree rooted at  and accepted at  has been removed (explained in the second subcase of 2 above). Note that if  then the state  is removed from the left hand side of the transition  i.e.     .
    	\end{itemize}

\end{enumerate}

The final evaluation formula is unchanged for the states , it is \emph{false} for the newly added states i.e.  and  \emph{false}. The type  for the new automaton is defined as:\\
q \in Qq = (\hat{q},*), \hat{q} \in Qq = (q_1, q_2),  p_i \in \mathcal{T}(q_1)q = (q_1, q_2), p_m \in \mathcal{T}(q_1)\\
\newline\newline
{\bf Case 5} (): On execution of this statement, the structure component of the data trees accepted by the automaton is unchanged; however the final evaluation function has to now record the fact that the value of the data pointed by variable  is assigned  the value of . If, for a particular valuation tree,  is co-read with variable  before it is accepted at state ,  should also record that  the data value pointed by variable   is now assigned to . So the new automaton needs to track the set of variables which are co-read with  for a particular valuation tree. Hence . Regarding the transition relation, for all transitions ,
\begin{itemize}
\item if , .
\item otherwise if  
	\begin{itemize}
	\item and if  then  where . \item otherwise if  then there exists a state  such that . Consequently, we add transitions  for all .
	\end{itemize}
\end{itemize}

The final evaluation function  is given as:  for all ;  where  and includes variable . The type for each state of the new automaton is also same as the type in the original automaton i.e.  for all ; while  for all  in the remaining states.
\newline\newline
{\bf Case 6} ( \emph{assume}  ): 
The output QSDA is obtained by removing from the input QSDA, transitions where variables  and  do not occur together. Formally,  and for all transitions  in the input QSDA,  iff . 
\newline\newline
{\bf Case 7} ( \emph{assume}  ): 
The output QSDA is obtained by removing from the input QSDA, transitions where variables  and   occur together. Formally,  and for all transitions  in the input QSDA,  iff  or  or both. 
\newline\newline
{\bf Case 8} ( \emph{assume}  ): 
In this case,  and the transitions  is same as .
The type 
 and for all .
\newline\newline
\noindent The transition relation  thus constructed might need to be determinized to obtain . 
For a symbolic tree  and formulas  such that  belong to the language, the determinization procedure maps  to the formula . The determinization procedure is similar to the powerset construction for determinizing tree automata; except for any set of states, the final evaluation function is now assigned to be the join of the formulas being mapped to the individual states in the set.





 








\end{document}
