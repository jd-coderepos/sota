
\documentclass{article} \usepackage{iclr2020_conference,times}



\usepackage{amsmath,amsfonts,bm}

\usepackage{amsthm}

\newtheorem{theorem}{Theorem}\newtheorem{definition}[theorem]{Definition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}

\newcommand{\textred}[1]{\textcolor{red}{#1}}
\newcommand{\textcyan}[1]{\textcolor{black}{#1}}
\newcommand{\textblue}[1]{\textcolor{blue}{#1}}
\newcommand{\camera}[1]{\textcolor{black}{#1}}
\newcommand{\ghl}[1]{\textcolor{cyan}{GHL: #1}}
\newcommand{\tsj}[1]{\textcolor{green}{TSJ: #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vomega{{\bm{\omega}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak

\def\idx{{\texttt{idx}}} 
\usepackage{hyperref}
\usepackage{url}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{tikz}

\usepackage{url}            \usepackage{booktabs}       

\usepackage{enumitem}
\newcommand{\xref}[1]{\S\ref{#1}}
\usepackage{cleveref}
\newcommand{\one}{\mathbb{I}}
\usepackage{subcaption}



\title{Oblique Decision Trees from Derivatives of ReLU Networks}



\author{Guang-He Lee \& Tommi S. Jaakkola \\
Computer Science and Artificial Intelligence Lab\\
MIT\\
\texttt{\{guanghe,tommi\}@csail.mit.edu} \\
}


\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
We show how neural models can be used to realize piece-wise constant functions such as decision trees. The proposed architecture, which we call locally constant networks, builds on ReLU networks that are piece-wise linear and hence their associated gradients with respect to the inputs are locally constant. We formally establish the equivalence between the classes of locally constant networks and decision trees. Moreover, we highlight several advantageous properties of locally constant networks, including how they realize decision trees with parameter sharing across branching / leaves. Indeed, only $M$ neurons suffice to implicitly model an oblique decision tree with $2^M$ leaf nodes. The neural representation also enables us to adopt many tools developed for deep networks (e.g., DropConnect~\citep{wan2013regularization}) while implicitly training decision trees. We demonstrate that our method outperforms alternative techniques for training oblique decision trees in the context of molecular property classification and regression tasks.\footnote{\camera{Our implementation and data are available at \url{https://github.com/guanghelee/iclr20-lcn}.}}
\end{abstract}

%
 \section{Introduction}

Decision trees~\citep{cart84} employ a series of simple decision nodes, arranged in a tree, to transparently capture how the predicted outcome is reached. Functionally, such tree-based models, including random forest~\citep{breiman2001random}, realize piece-wise constant functions. Beyond their status as de facto interpretable models, they have also persisted as the state of the art models in some tabular~\citep{sandulescu2016predicting} and chemical datasets~\citep{wu2018moleculenet}. Deep neural models, in contrast, are highly flexible and continuous, demonstrably effective in practice, though lack transparency. We merge these two contrasting views by introducing a new family of neural models that implicitly learn and represent oblique decision trees. 

Prior work has attempted to generalize classic decision trees by extending coordinate-wise cuts to be weighted, linear classifications. The resulting family of models is known as oblique decision trees~\citep{murthy1993oc1}. However, the generalization accompanies a challenging combinatorial, non-differentiable optimization problem over the linear parameters at each decision point. Simple sorting procedures used for successively finding branch-wise optimal coordinate cuts are no longer available, making these models considerably harder to train. While finding the optimal oblique decision tree can be cast as a mixed integer linear program~\citep{bertsimas2017optimal}, scaling remains a challenge.  

In this work, we provide an effective, implicit representation of piece-wise constant mappings, termed \emph{locally constant networks}. Our approach exploits piece-wise linear models such as ReLU networks as basic building blocks. Linearity of the mapping in each region in such models means that the gradient with respect to the input coordinates is locally constant. We therefore implicitly represent piece-wise constant networks through gradients evaluated from ReLU networks. We prove the equivalence between the class of oblique decision trees and these proposed locally constant neural models. However, the sizes required for equivalent representations can be substantially different. For example, a locally constant network with $M$ neurons can implicitly realize an oblique decision tree whose explicit form requires $2^M-1$ oblique decision nodes. The exponential complexity reduction in the corresponding neural representation illustrates the degree to which parameters are shared across the locally constant regions.
 
Our locally constant networks can be learned via gradient descent, and they can be explicitly converted back to oblique decision trees for interpretability. For learning via gradient descent, however, it is necessary to employ some smooth annealing of piece-wise linear activation functions so as to keep the gradients themselves continuous. Moreover, we need to evaluate the gradients of all the neurons with respect to the inputs. To address this bottleneck, we devise a dynamic programming algorithm which computes all the necessary gradient information in a single forward pass. A number of extensions are possible. For instance, we can construct \emph{approximately} locally constant networks by switching activation functions, or apply helpful techniques used with normal deep learning models (e.g., DropConnect~\citep{wan2013regularization}) while implicitly training tree models. 


We empirically test our model in the context of molecular property classification and regression tasks~\citep{wu2018moleculenet}, where tree-based models remain state-of-the-art. We compare our approach against recent methods for training oblique decision trees and classic ensemble methods such as gradient boosting~\citep{friedman2001greedy} and random forest. Empirically, a locally constant network always outperforms alternative methods for training oblique decision trees by a large margin, and the ensemble of locally constant networks is competitive with classic ensemble methods. 

\iffalse In summary, our main contributions are as follows:
\vspace{-2mm}
\begin{itemize}[leftmargin=4mm]
\item Flexible neural models that entail locally constant mappings and enable novel extensions. 
\vspace{-1mm}
\item Theoretical analyses that illuminate the properties of locally constant networks. 
\vspace{-1mm}
\item Empirical demonstration of the state-of-the-art optimization and generalization performance. 
\vspace{-2mm}
\end{itemize}
\fi












%
 \vspace{-1mm}
\section{Related Work}
\vspace{-1mm}
Locally constant networks are built on a mixed integer linear representation of piece-wise linear networks, defined as any feed-forward network with a piece-wise linear activation function such as ReLU~\citep{nair2010rectified}. One can specify a set of integers encoding the active linear piece of each neuron, which is called an activation pattern~\citep{raghu2017expressive}. The feasible set of an activation pattern forms a convex polyhedron in the input space~\citep{lee2018towards}, where the network degenerates to a linear model. The framework motivates us to leverage the locally invariant derivatives of the networks to construct a locally constant network. The activation pattern is also exploited in literature for other purposes such as 
deriving robustness certificates~\citep{weng2018towards}. We refer the readers to the recent work~\citep{lee2018towards} and the references therein. 

\camera{Locally constant networks use the gradients of deep networks with respect to inputs as the representations to build discriminative models. Such gradients have been used in literature for different purposes. They have been widely used for local sensitivity analysis of trained networks~\citep{simonyan2013deep, smilkov2017smoothgrad}. When the deep networks model an energy function~\citep{lecun2006tutorial}, the gradients can be used to draw samples from the distribution specified by the normalized energy function~\citep{du2019implicit, song2019generative}. The gradients can also be used to train generative models~\citep{goodfellow2014generative} or perform knowledge distillation~\citep{pmlr-v80-srinivas18a}.}

The {class} of locally constant networks is equivalent to the class of oblique decision trees. 
There are some classic methods that also construct neural networks that reproduce decision trees~\citep{sethi1990entropy, brent1991fast, cios1992machine}, by utilizing step functions and logic gates (e.g., \texttt{AND}/\texttt{NEGATION}) as the activation function. The methods were developed when back-propagation was not yet practically useful, and the motivation is to exploit effective learning procedures of decision trees to train neural networks. Instead, our goal is to leverage the successful deep models to train oblique decision trees. 
\camera{Recently, \cite{yang2018deep} proposed a network architecture with $\argmax$ activations to represent classic decision trees with coordinate cuts, but their parameterization scales exponentially with input dimension. In stark contrast, our parameterization only scales linearly with input dimension (see our complexity analyses in \xref{sec:learning}).}

Learning oblique decision trees is challenging, even for a greedy algorithm; for a single oblique split, there can be $\sum_{k=0}^D \binom{N}{k}$ different ways to separate $N$ data points in $D$-dimensional space~\citep{vapnik1971growth} (cf. $N D$ possibilities for coordinate-cuts). Existing learning algorithms for oblique decision trees include greedy induction, global optimization, and iterative refinements on an initial tree. We review some representative works, and refer the readers to the references therein.

Optimizing each oblique split in greedy induction can be realized by coordinate descent~\citep{murthy1994system} or a coordinate-cut search in some linear projection space~\citep{menze2011oblique, wickramarachchi2016hhcart}. However, the greedy constructions tend to get stuck in poor local optimum. There are some works which attempt to find the global optimum given a fixed tree structure by formulating a linear program~\citep{bennett1994global} or a mixed integer linear program~\citep{bertsimas2017optimal}, but the methods are not scalable to ordinary tree sizes (e.g., depth more than 4). The iterative refinements are more scalable than global optimization, where CART~\citep{cart84} is the typical initialization. \citet{carreira2018alternating} develop an alternating optimization method via iteratively training a linear classifier on each decision node, which yield the state-of-the-art empirical performance, but the approach is only applicable to classification problems. 
\citet{norouzi2015efficient} proposed to do gradient descent on a sub-differentiable upperbound of tree prediction errors, but the gradients with respect to oblique decision nodes are unavailable whenever the upperbound is tight. In contrast, our method conducts gradient descent on a differentiable relaxation, which is gradually annealed to a locally constant network.

%
 \vspace{-1mm}
\section{Methodology}
\vspace{-1mm}
In this section, we introduce the notation and basics in \xref{sec:notation}, construct the locally constant networks in \xref{sec:local_linear}-\ref{sec:lcn}, analyze the networks in \xref{sec:repr-theory}-\ref{sec:inductive-bias}, and develop practical formulations and algorithms in \xref{sec:standard}-\ref{sec:learning}. Note that we will propose two (equivalent) architectures of locally constant networks in \xref{sec:lcn} and \xref{sec:standard}, which are useful for theoretical analyses and practical purposes, respectively. 



\subsection{Notation and basics}\label{sec:notation}

The proposed approach is built on feed-forward networks that yield piece-wise linear mappings. Here we first introduce a canonical example of such networks, and elaborate its piece-wise linearity. We consider the densely connected architecture~\citep{huang2017densely}, where each hidden layer takes as input all the previous layers; it subsumes other existing feed-forward architectures such as residual networks~\citep{he2016deep}. For such a network $f_\theta: \sR^D \to \sR^L$ with the set of parameters $\theta$, we denote the number of hidden layers as $M$ and the number of neurons in the $i^\text{th}$ layer as $N_i$; we denote the neurons in the $i^\text{th}$ layer, before and after activation, as $\vz^i \in \sR^{N_i}$ and $\va^i \in \sR^{N_i}$, respectively, where we sometimes interchangeably denote the input instance $\vx$ as $\va^0 \in \sR^{N_0}$ with $N_0 \triangleq D$. To simplify exposition, we denote the concatenation of $(\va^0, \va^1, \dots, \va^i)$ as $\tilde \va^i \in \sR^{\tilde N_i}$ with $\tilde N_i \triangleq \sum_{j=0}^i N_i$, $\forall i \in \{0, 1, \dots, M\}$. The neurons are defined via the weight matrix $\mW^i \in \sR^{N_i \times \tilde N_{i-1}}$ and the bias vector $\vb^i \in \sR^{N_i}$ in each layer $i \in [M] \triangleq \{1, 2, \dots, M\}$. Concretely,
\begin{equation}
\va^0 \triangleq \vx, \;\;\vz^i \triangleq \mW^i \tilde \va^{i-1} + \vb^i, \;\; \va^i \triangleq \sigma(\vz^i), \forall i \in [M], \label{eq:forward}
\end{equation}
where $\sigma(\cdot)$ is a point-wise activation function. Note that both $\va$ and $\vz$ are functions of the specific instance denoted by $\vx$, where we drop the functional dependency to simplify notation. We use the set $\gI$ to denote the set of all the neuron indices in this network $\{(i, j) | j \in [N_i], i \in [M]\}$. In this work, we will use ReLU~\citep{nair2010rectified} as a canonical example for the activation function
\begin{equation}
\va^i_j = \sigma(\vz^i)_j \triangleq \max(0, \vz^i_j), \forall (i, j) \in \gI, \label{eq:activation}
\end{equation}
but the results naturally generalize to other piece-wise linear activation functions such as leaky ReLU~\citep{maas2013rectifier}. The output of the entire network $f_\theta(\vx)$ is the affine transformation from all the hidden layers $\tilde \va^M$ with the weight matrix $\mW^{M+1} \in \sR^{L \times \tilde N_{M}}$ and bias vector $\vb^{M+1} \in \sR^{L}$. 
 \vspace{-1mm}
\subsection{Local linearity}\label{sec:local_linear}
\vspace{-1mm}
It is widely known that the class of networks $f_\theta(\cdot)$ yields a piece-wise linear function. The results are typically proved via associating the end-to-end behavior of the network with its activation pattern -- which linear piece in each neuron is activated; once an activation pattern is fixed across the entire network, the network degenerates to a linear model and the feasible set with respect to an activation pattern is a natural characterization of a locally linear region of the network. 



Formally, we define the activation pattern as the \camera{collection of activation indicator functions for each neuron $\vo^i_j: \sR^D \to \{0, 1\}, \forall (i, j) \in \gI$ (or, equivalently, the derivatives of ReLU units; see below)}\footnote{Note that each $\vo^i_j$ is again a function of $\vx$, where we omit the dependency for brevity.}:
\begin{align}
\vspace{-1mm}
    \vo^i_j = \frac{\partial \va^i_j}{\partial \vz^i_j} \triangleq 
    \one[\vz^i_j \geq 0],
\forall (i, j) \in \gI, \label{eq:actpattern}
\vspace{-1mm}
\end{align}
where $\one[\cdot]$ is the indicator function. Note that, for mathematical correctness, we \emph{define} $\partial \va^i_j / \partial \vz^i_j = 1$ at $\vz^i_j = 0$; this choice is arbitrary, and one can change it to $\partial \va^i_j / \partial \vz^i_j = 0$ at $\vz^i_j = 0$ without affecting most of the derivations.
Given \camera{a \emph{fixed} activation pattern $\bar \vo^i_j \in \{0, 1\}, \forall (i, j)$}, we can specify a feasible set in $\sR^D$ that corresponds to this activation pattern 
$\{\vx \in \sR^D | \vo^i_j = \bar \vo^i_j, \forall (i, j) \in \gI\}$ (note that each $\vo^i_j$ is a function of $\vx$). Due to the fixed activation pattern, the non-linear ReLU can be re-written as a \emph{linear} function for all the inputs \emph{in the feasible set}. For example, for an $\bar \vo^i_j = 0$, we can re-write $\va^i_j = 0 \times \vz^i_j$. As a result, the network has a consistent end-to-end linear behavior across the entire feasible set. One can prove that all the feasible sets partition the space $\sR^D$ into disjoint convex polyhedra\footnote{The boundary of the polyhedron depends on the specific definition of the activation pattern, so, under some definition in literature, the resulting convex polyhedra may not be disjoint in the boundary.}, which realize a natural representation of the locally linear regions. Since we will only use the result to motivate the construction of locally constant networks, we refer the readers to \citet{lee2018towards} for a detailed justification of the piece-wise linearity of such networks. 






 \vspace{-1mm}
\subsection{Canonical locally constant networks}\label{sec:lcn}
\begin{figure}
\vspace{-2mm}
\centering
\includegraphics[width=1\linewidth]{img/toy_examplev2.pdf}
	\caption{Toy examples for the equivalent representations of the same mappings for different $M$. Here the locally constant networks have 1 neuron per layer. We show the locally constant networks on the LHS, the raw mappings in the middle, and the equivalent oblique decision trees on the RHS.\!\!\!\!\!}\label{fig:toy_example}
    \vspace{-3mm}
\end{figure}

Since the ReLU network $f_\theta(\vx)$ is piece-wise linear, it immediately implies that its derivatives with respect to the input $\vx$ is a piece-wise constant function. Here we use $J_\vx f_\theta (\vx) \in \sR^{L \times D}$ to denote the Jacobian matrix (i.e., $[J_\vx f_\theta (\vx)]_{i,j} = \partial f_\theta(\vx)_i / \partial \vx_j$), and we assume the Jacobian is consistent with Eq.~(\ref{eq:actpattern}) at the boundary of the locally linear regions. Since any function taking the piece-wise constant Jacobian as input will remain itself piece-wise constant, we can construct a variety of locally constant networks by composition.

However, in order to simplify the derivation, we first make a trivial observation that the activation pattern in each locally linear region is also locally invariant. More broadly, any invariant quantity in each locally linear region can be utilized so as to build locally constant networks. We thus define the locally constant networks as any composite function that leverage the local invariance of piece-wise linear networks. For the theoretical analyses, we consider the below architecture.

\textbf{Canonical architecture.} We denote $\tilde \vo^M \in \{0, 1\}^{\tilde N_M}$ as the concatenation of $(\vo^1,\dots,\vo^M)$.
We will use the composite function $g(\tilde \vo^M)$ as the canonical architecture of locally constant networks for theoretical analyses, where $g: \{0, 1\}^{\tilde N_M} \to \sR^L$ is simply a table.


Before elucidating on the representational equivalence to oblique decision trees, we first show some toy examples of the canonical locally constant networks and their equivalent mappings in Fig.~\ref{fig:toy_example}, which illustrates their constructions when there is only $1$ neuron per layer (i.e., $\vz^i = \vz^i_1$, and similarly for $\vo^i$ and $\va^i$). When $M=1$, $\vo^1 = 1 \Leftrightarrow \vx_1 - \vx_2 + 1 \geq 0$, thus the locally constant network is equivalent to a linear model shown in the middle, which can also be represented as an oblique decision tree with depth $=1$. When $M > 1$, the activations in the previous layers control different linear behaviors of a neuron with respect to the input, thus realizing a hierarchical structure as an oblique decision tree. For example, for $M=2$, $\vo^1 = 0 \Leftrightarrow \vz^1 < 0 \Rightarrow \vz^2 = -4\vx_1 + \vx_2 + 4$ and $\vo^1 = 1 \Leftrightarrow \vz^1 \geq 0 \Rightarrow \vz^2 = -3 \vx_2 + 8$; hence, it can also be interpreted as the decision tree on the RHS, where the \emph{concrete realization} of $\vz^2$ depends on the previous decision variable $\vz^1 \geq 0$. Afterwards, we can map either the activation patterns on the LHS or the decision patterns on the RHS to an output value, which leads to the mapping in the middle.  \vspace{-1mm}
\subsection{Representational equivalence}\label{sec:repr-theory}

In this section, we prove the equivalence between the class of oblique decision trees and the class of locally constant networks. We first make an observation that any unbalanced oblique decision tree can be re-written to be balanced by adding dummy decision nodes $\vzero^\top\vx \geq -1$. 
Hence, we can define the \emph{class} of oblique decision trees with the balance constraint:
\begin{definition}
The class of oblique decision trees contains any functions that can be procedurally defined (with some depth $T \in \sZ_{>0}$) for $\vx \in \sR^D$:
\begin{enumerate}
\vspace{-2mm}
    \item $\vr_1 \triangleq \one [ \vomega_{\varnothing}^\top \vx + \beta_{\varnothing} \geq 0]$, where $\vomega_{\varnothing} \in \sR^D$ and $\beta_\varnothing \in \sR$ denote the weight and bias of the root decision node.
\vspace{-1.5mm}
    \item For $i \in (2,3,\dots, T), \vr_i \triangleq \one [ \vomega_{\vr_{1:i-1}}^\top \vx + \beta_{\vr_{1:i-1}} \geq 0]$, where $\vomega_{\vr_{1:i-1}} \in \sR^D$ and $\beta_{\vr_{1:i-1}} \in \sR$ denote the weight and bias for the decision node after the decision pattern $\vr_{1:i-1}$.
\vspace{-1.5mm}
    \item $v: \{0, 1\}^T \to \sR^L$ outputs the leaf value $v(\vr_{1:T})$ associated with the decision pattern $\vr_{1:T}$. \!\!\!\!\!
\vspace{-2mm}
\end{enumerate}
\end{definition}
The class of locally constant networks is defined by the \emph{canonical architecture} with finite $M$ and $N_i, \forall i \in [M]$. We first prove that we can represent any oblique decision tree as a locally constant network. Since a typical oblique decision tree can produce an arbitrary weight in each decision node (cf. the structurally dependent weights in the oblique decision trees in Fig.~\ref{fig:toy_example}), the idea is to utilize a network with only $1$ hidden layer such that the neurons do not constrain one another. Concretely,
\begin{theorem}
The class of locally constant networks $\supseteq$ the class of oblique decision trees. 
\end{theorem}
\vspace{-4mm}
\begin{proof}
For any oblique decision tree with depth $T$, it contains $2^{T}-1$ weights and biases. We thus construct a locally constant network with $M=1$ and $N_1 = 2^{T}-1$ such that each pair of $(\vomega, \beta)$ in the oblique decision tree is equal to some $\mW^1_{k, :}$ and $\vb^1_k$ in the constructed locally constant network. 

For each leaf node in the decision tree, it is associated with an output value $\vy \in \sR^L$ and $T$ decisions; the decisions can be written as $\mW^1_{\idx[j], :} \vx + \vb^1_{\idx[j]} \geq 0$ for $j \in \{1,2,\dots,T'\}$ and $\mW^1_{\idx[j], :} \vx + \vb^1_{\idx[j]} < 0$ for $j \in \{T'+1, T'+2,\dots,T\}$ for some index function $\idx: [T] \to [2^{T}-1]$ and some $T' \in \{0, 1,\dots, T\}$. We can set the table $g(\cdot)$ of the locally constant network as
\begin{align*}
\vspace{-1.5mm}
    \vy, \text{ if}
    \begin{cases}
    \vo^1_{\idx[j]} = 1 (\Leftrightarrow \mW^1_{\idx[j], :} \vx + \vb^1_{\idx[j]} \geq 0), \text{for }j \in \{1,2,\dots,T'\}, \text{ and}\\
    \vo^1_{\idx[j]} = 0 (\Leftrightarrow \mW^1_{\idx[j], :} \vx + \vb^1_{\idx[j]} < 0), \text{for }j \in \{T'+1, T'+2,\dots,T\}.
    \end{cases}
\vspace{-0.5mm}
\end{align*}
As a result, the constructed locally constant network yields the same output as the given oblique decision tree for all the inputs that are routed to each leaf node, which concludes the proof. 
\end{proof}
\vspace{-2mm}
Then we prove that the class of locally constant networks is a subset of the class of oblique decision trees, which simply follows the construction of the toy examples in Fig.~\ref{fig:toy_example}. 
\begin{theorem}
The class of locally constant networks $\subseteq$ the class of oblique decision trees. \label{theorem:convert}
\end{theorem}
\vspace{-2mm}
\begin{proof}
\vspace{-2mm}
For any locally constant network, it can be re-written to have $1$ neuron per layer, by expanding any layer with $N_i > 1$ neurons to be $N_i$ different layers such that they do not have effective intra-connections. 
Below the notation refers to the converted locally constant network with $1$ neuron per layer. 
We define the following oblique decision tree with $T=M$ for $\vx \in \sR^D$:
\begin{enumerate}
\vspace{-2mm}
    \item $\vr_1 \triangleq \vo^1_1 = \one [ \vomega_{\varnothing}^\top \vx + \beta_{\varnothing} \geq 0]$ with $ \vomega_{\varnothing} = \mW^1_{1,:}$ and $\beta_\varnothing = \vb^1_1$.\!\!\!\!
\vspace{-1mm}
    \item For $i \in (2,3,\dots,M), \vr_i \triangleq \one [ \vomega_{\vr_{1:i-1}}^\top \vx + \beta_{\vr_{1:i-1}} \geq 0]$, where $\vomega_{\vr_{1:i-1}} = \nabla_\vx \vz^i_1$ and $\beta_{\vr_{1:i-1}} = \vz^i_1 - (\nabla_\vx \vz^i_1)^\top \vx$. Note that $\vr_i = \one[ \vz^i_1 \geq 0] = \vo^i_1$.
\vspace{-1mm}
    \item $v = g$.
\vspace{-2mm}
\end{enumerate}
Note that, in order to be a valid decision tree, $\vomega_{1:\vr_{i-1}}$ and $\beta_{1:\vr_{i-1}}$ have to be unique for all $\vx$ that yield the same decision pattern $\vr_{1:i-1}$. To see this, for $i \in (2,3,\dots,M)$, as $\vr_{1:i-1} = (\vo^1_1,\dots,\vo^{i-1}_1)$, we know each $\vz^i_1$ is a fixed affine function given an activation pattern for the preceding neurons, so $\nabla_\vx \vz^i_1$ and $\vz^i_1 - \vx^\top \nabla_\vx \vz^i_1$ are fixed quantities given a decision pattern $\vr_{1:i-1}$. 

Since $\vr_{1:M} = \tilde \vo^M$ and $v = g$, we conclude that they yield the same mapping. 
\end{proof}
\vspace{-2mm}
Despite the simplicity of the proof, it has some practical implications:
\begin{remark}\label{remark:equivalence}
The proof of Theorem~\ref{theorem:convert} implies that we can train a locally constant network with $M$ neurons, and convert it to an oblique decision tree with depth $M$ (for interpretability).
\vspace{-1mm}
\end{remark}
\begin{remark}
The proof of Theorem~\ref{theorem:convert} establishes that, given a fixed number of neurons, it suffices (representationally) to only consider the locally constant networks with one neuron per layer. 
\label{remark:one-neuron}
\end{remark}
\vspace{-1mm}
Remark~\ref{remark:one-neuron} is important for learning small locally constant networks (which can be converted to shallow decision trees for interpretability), since representation capacity is critical for low capacity models. In the remainder of the paper, we will only consider the setting with $N_i = 1, \forall i \in [M]$.
















































 \vspace{-1mm}
\subsection{Structurally shared parameterization}\label{sec:inductive-bias}

Although we have established the exact \emph{class-level} equivalence between locally constant networks and oblique decision trees, once we restrict the depth of the locally constant networks $M$, it can no longer re-produce all the decision trees with depth $M$. The result can be intuitively understood by the following reason: we are effectively using $M$ pairs of (weight, bias) in the locally constant network to implicitly realize $2^{M}-1$ pairs of (weight, bias) in the corresponding oblique decision tree. Such exponential reduction on the effective parameters in the representation of oblique decision trees yields ``dimension reduction'' of the model capacity. This section aims to reveal the implied shared parameterization embedded in the oblique decision trees derived from locally constant networks.

In this section, the oblique decision trees and the associated parameters refer to \emph{the decision trees obtained via the proof of Theorem~\ref{theorem:convert}}. We start the analysis by a decomposition of $\vomega_{\vr_{1:i}}$ among the preceding weights $\vomega_{\varnothing},\vomega_{\vr_{1:1}},\dots,\vomega_{\vr_{1:r-1}}$. To simplify notation, we denote $\vomega_{\vr_{1:0}} \triangleq \vomega_\varnothing$.
Since $\vomega_{\vr_{1:i}} = \nabla_\vx \vz^{i+1}_1$ and $\vz^{i+1}_1$ is an affine transformation of the vector $(\va_0, \va^1_1,\dots, \va_1^i)$, 
\begin{align*}
\vspace{-1mm}
    \vomega_{\vr_{1:i}} \! = \! \nabla_\vx \vz^{i+1}_1 \! = \! \mW^{i+1}_{1, 1:D} \! + \! \sum_{k=1}^{i} \mW^{i+1}_{1, D+k} \! \times \! \frac{\partial \va^k_1}{\partial \vz^k_1} \! \times \! \nabla_\vx \vz^k_1 
    \! = \! \mW^{i+1}_{1, 1:D} \! + \! \sum_{k=1}^{i} \! \mW^{i+1}_{1, D+k} \! \times \! \vr_k \! \times \! \vomega_{\vr_{1:k-1}}, 
\vspace{-1mm}
\end{align*}
where we simply re-write the derivatives in terms of tree parameters. Since $\mW^{i+1}_{1, 1:D}$ is fixed for all the $\vomega_{\vr_{1:i}}$, the above decomposition implies that, in the induced tree, all the weights $\vomega_{\vr_{1:i}}$ in \emph{the same depth} $i$ are restricted to be a linear combination of the fixed basis $\mW^{i+1}_{1, 1:D}$ and the corresponding preceding weights $\vomega_{\vr_{1:0}},\dots,\vomega_{\vr_{1:i-1}}$.\!
We can extend this analysis to compare weights in same layer, and we begin the analysis by comparing weights whose $\ell_0$ distance in decision pattern is $1$. 
To help interpret the statement, note that $\vomega_{\vr_{1:j-1}}$ is the weight 
that leads to the decision $\vr_j$ (or $\vr'_j$; see below).
\begin{lemma}
For an oblique decision tree with depth $T > 1$, $\forall i \in [T-1]$ and any $\vr_{1:i}$, $\vr_{1:i}'$ such that $\vr_{k} = \vr_{k}'$ for all $k \in [i]$ except that $\vr_{j} \neq \vr_{j}'$ for some $j \in [i]$, we have
\vspace{-1mm}
\begin{equation*}
    \vomega_{\vr_{1:i}} - \vomega_{\vr_{1:i}'} =  \alpha \times \vomega_{\vr_{1:j-1}},\text{ for some } \alpha \in \sR.
\end{equation*}
\vspace{-6mm}
\label{lemma:structural-constraint}
\end{lemma}
The proof involves some algebraic manipulation, and is deferred to Appendix~\ref{appendix:proof:structural-constraint}. Lemma~\ref{lemma:structural-constraint} characterizes an interesting structural constraint embedded in the oblique decision trees realized by locally constant networks, where the structural discrepancy $\vr_j$ in decision patterns ($\vr_{1:i}$ versus $\vr'_{1:i}$) is reflected on the discrepancy of the corresponding weights (up to a scaling factor $\alpha$). The analysis can be generalized for all the weights in the same layer, but the message is similar. 
\begin{proposition}
For the oblique decision tree with depth $T > 1$, $\forall i \in [T-1]$ and any $\vr_{1:i}$, $\vr_{1:i}'$ such that $\vr_{k} = \vr_{k}'$ for all $k \in [i]$ except for $n \in [i]$ coordinates $j_1,\dots,j_n \in [i]$, we have
\vspace{-1mm}
\begin{align}
    \vomega_{\vr_{1:i}} - \vomega_{\vr_{1:i}'} =  \sum_{k=1}^n \alpha_k \times \vomega_{\vr_{1:j_k-1}},\text{ for some } \alpha_k \in \sR, \forall k \in [n].
\end{align}
\vspace{-6mm}
\label{prop:structural-constraint}
\end{proposition}
The statement can be proved by applying Lemma~\ref{lemma:structural-constraint} multiple times. 

\textbf{Discussion.}
Here we summarize this section and provide some discussion.
Locally constant networks implicitly represent oblique decision trees with the same depth and structurally shared parameterization. In the implied oblique decision trees, the weight of each decision node is a linear combination of a shared weight across the whole layer and all the preceding weights. The analysis explains how locally constant networks use only $M$ weights to model a decision tree with $2^M-1$ decision nodes; it yields a strong regularization effect to avoid overfitting, and helps computation by exponentially reducing the memory consumption on the weights. 









 \vspace{-1mm}
\subsection{Standard locally constant networks and extensions}\label{sec:standard}

The simple structure of the \emph{canonical} locally constant networks is beneficial for theoretical analysis, but the structure is not practical for learning since the \emph{discrete} activation pattern does not exhibit gradients for learning the networks. Indeed, $\nabla_{\tilde \vo^M} g(\tilde \vo^M)$ is undefined, which implies that $\nabla_{\mW^i} g(\tilde \vo^M)$ is also undefined. Here we present another architecture that is equivalent to the \emph{canonical} architecture, but exhibits sub-gradients with respect to model parameters and is flexible for model extension. 

\textbf{Standard architecture.} 
We assume $N_i=1, \forall i \in [M]$. We denote the Jacobian of all the neurons after activation $\tilde \va^M$ as $J_\vx \tilde \va^M \in \sR^{M \times D}$, and denote $\vec J_\vx \tilde \va^M$ as the vectorized version. We then define the standard architecture as $g_\phi(\vec J_\vx \tilde \va^M)$, where $g_\phi: \sR^{(M \times D)} \to \sR^{L}$ is a fully-connected network.

We abbreviate the standard locally constant networks as \textbf{\textsc{Lcn}}. Note that each $\va^i_1$ is locally linear and thus the Jacobian $J_\vx \tilde \va^M$ is locally constant.
We replace $\tilde \vo^M$ with $J_\vx \tilde \va^M$ as the invariant representation for each locally linear region\footnote{In practice, we also include each bias $\va^i_1 - (\nabla_\vx \va^i_1)^\top \vx$, which is omitted here to simplify exposition.},
and replace the table $g$ with a differentiable function $g_\phi$ that takes as input real vectors. The gradients of \textsc{Lcn} with respect to parameters is thus established through the derivatives of $g_\phi$ and the mixed partial derivatives of the neurons (derivatives of $\vec J_\vx \tilde \va^M$). 


\textcyan{Fortunately, all the previous analyses also apply to the standard architecture, due to a fine-grained equivalence between the two architectures.}
\begin{theorem}
\textcyan{Given any fixed $f_\theta$, any canonical locally constant network $g(\tilde \vo^M)$ can be equivalently represented by a standard locally constant network $g_\phi(\vec J_\vx \tilde \va^M)$, and vice versa.}
\label{thm:architecture_equivalence}
\end{theorem}
\textcyan{Since $f_\theta$ and $g$ control the decision nodes and leaf nodes in the associated oblique decision tree, respectively (see Theorem~\ref{theorem:convert}), Theorem~\ref{thm:architecture_equivalence} essentially states that both architectures are equally competent for assigning leaf nodes. Combining Theorem~\ref{thm:architecture_equivalence} with the analyses in \xref{sec:repr-theory}, we have class-level equivalence among the two architectures of locally constant networks and oblique decision trees. The analyses in \xref{sec:inductive-bias} are also inherited since the analyses only depend on decision nodes (i.e., $f_\theta$).}

\textcyan{The core ideas for proving Theorem~\ref{thm:architecture_equivalence} are two-fold: 1) we find a bijection between the activation pattern $\tilde \vo^M$ and the Jacobian $\vec J_\vx \tilde \va^M$, and 2) feed-forward networks $g_\phi$ can map the (finitely many) Jacobian $\vec J_\vx \tilde \va^M$ as flexibly as a table $g$. The complete proof is deferred to Appendix~\ref{appendix:proof:architect}.}





















\textbf{Discussion.} The standard architecture yields a new property that is only partially exhibited in the canonical architecture. For all the decision and leaf nodes which no training data is routed to, there is no way to obtain learning signals in classic oblique decision trees. However, due to shared parameterization (see \xref{sec:inductive-bias}), locally constant networks can ``learn'' all the decision nodes in the implied oblique decision trees (if there is a way to optimize the networks), and the standard architecture can even ``learn'' all the leaf nodes due to the parameterized output function $g_\phi$.


\textbf{Extensions.} The construction of (standard) locally constant networks enables several natural extensions due to the flexibility of the neural architecture and the interpretation of decision trees. The original locally linear networks (\textbf{\textsc{Lln}}) $f_\theta$, which outputs a linear function instead of a constant function for each region, can be regarded as one extension. Here we discuss two examples.
\begin{itemize}[leftmargin=4mm]
\vspace{-2mm}
    \item {Approximately locally constant networks (\textbf{\textsc{Alcn}})}: we can change the activation function while keeping the model architecture of \textsc{Lcn}. For example, we can replace ReLU $\max(0, x)$ with softplus $\log(1 + \exp(x))$, which will lead to an approximately locally constant network, as the softplus function has an approximately locally constant derivative for inputs with large absolute value. Note that the canonical architecture (tabular $g$) is not compatible with such extension. 
\vspace{-1mm}
    \item Ensemble locally constant networks (\textbf{\textsc{Elcn}}): since each \textsc{Lcn} can only output $2^M$ different values, it is limited for complex tasks like regression (akin to decision trees). We can instead use an additive ensemble of \textsc{Lcn} or \textsc{Alcn} to increase the capacity. We use $g^{[e]}_{\phi}(\vec{J}_\vx \tilde \va^{M, [e]})$ to denote a base model in the ensemble, and denote the ensemble with $E$ models as $\sum_{e=1}^E g^{[e]}_{\phi}(\vec{J}_\vx \tilde \va^{M, [e]})$. 
\vspace{-2mm}
\end{itemize}
 \vspace{-1mm}
\subsection{Computation and learning}\label{sec:learning}
\vspace{-1mm}
\camera{In this section, we discuss computation and learning algorithms for the proposed models. In the following complexity analyses, we assume $g_\phi$ to be a linear model.}

\camera{\textbf{Space complexity.} The space complexity of \textsc{Lcn} is $\Theta(MD)$ for representing decision nodes and $\Theta(MDL)$ for representing leaf nodes. In contrast, the space complexity of classic oblique decision trees is $\Theta((2^M - 1) D)$ for decision nodes and $\Theta(2^M L)$ for leaf nodes. Hence, our representation improves the space complexity over classic oblique decision trees exponentially.}

\textbf{Computation \camera{and time complexity}.}
\textsc{Lcn} and \textsc{Alcn} are built on the gradients of all the neurons $\vec{J}_\vx \tilde \va^M = [\nabla_\vx \va^M_1,\dots,$ $\nabla_\vx \va^1_1]$, which can be computationally challenging to obtain. Existing automatic differentiation (e.g., back-propagation) only computes the gradient of a scalar output. Instead, here we propose an efficient dynamic programming procedure which only requires a forward pass:
\begin{enumerate}
\vspace{-2mm}
    \item $\nabla_\vx \va^1_1 = \vo^1_1 \times \mW^1$.
\vspace{-1mm}
    \item $\forall i \in \{2,\dots,M\}, \nabla_\vx \va^i_1 = \vo^i_1 \times (\mW^i_{1, 1:D} + \sum_{k=1}^{i-1} \mW^i_{1, D+k} \nabla_\vx \va^k_1)$,
\vspace{-2.5mm}
\end{enumerate}
The complexity of the dynamic programming is $\Theta(M^2)$ due to the inner-summation inside each iteration. Straightforward back-propagation re-computes the partial solutions $\nabla_\vx \va^k_1$ for each $\nabla_\vx \va^i_1$, so the complexity is $\Theta(M^3)$. We can parallelize the inner-summation on a GPU, and the complexity of the dynamic programming and straightforward back-propagation will become $\Theta(M)$ and $\Theta(M^2)$, respectively. Note that the complexity of a forward pass of a typical network is also $\Theta(M)$ on a GPU. \camera{The time complexity of learning \textsc{Lcn} by (stochastic) gradient descent is thus $\Theta(M \tau)$, where $\tau$ denotes the number of iterations. In contrast, the computation of existing oblique decision tree training algorithms is typically data-dependent and thus the complexity is hard to characterize.} 


\textbf{Training \textsc{Lcn} and \textsc{Alcn}.} Even though \textsc{Lcn} is sub-differentiable, whenever $\vo^i_1 = 0$, the network does not exhibit useful gradient information for learning each locally constant representation $\nabla_\vx \va^i_1$ (note that $\vec{J}_\vx \tilde \va^M = [\nabla_\vx \va^1_1,\dots,\nabla_\vx \va^M_1]$), since, operationally, $\vo^i_1 = 0$ implies $\va^i_1 \gets 0$ and there is no useful gradient of $\nabla_\vx \va^i_1 = \nabla_\vx 0 = \vzero$ with respect to model parameters. To alleviate the problem, we propose to leverage softplus as an infinitely differentiable approximation of ReLU to obtain meaningful learning signals for $\nabla_\vx \va^i_1$. Concretely, we conduct the annealing during training:
\begin{align}
\vspace{-2mm}
    \va^i_1 = \lambda_t \max(0, \vz^i_1) + (1-\lambda_t) \log (1 + \exp(\vz^i_1)), \forall i \in [M], \lambda_t \in [0, 1], \label{eq:annealing}
\vspace{-2mm}
\end{align}
where $\lambda_t$ is an iteration-dependent annealing parameter. Both \textsc{Lcn} and \textsc{Alcn} can be constructed as a special case of Eq.~(\ref{eq:annealing}). We train \textsc{Lcn} with $\lambda_t$ equal to the ratio between the current epoch and the total epochs, and \textsc{Alcn} with $\lambda_t = 0$. Both models are optimized via stochastic gradient descent. 

We also include DropConnect~\citep{wan2013regularization} to the weight matrices $\mW^i \gets \text{drop}(\mW^i)$ during training. Despite the simple structure of DropConnect in the locally constant networks, it entails a structural dropout on the weights in the corresponding oblique decision trees (see \xref{sec:inductive-bias}), which is challenging to reproduce in typical oblique decision trees. In addition, it also encourages the exploration of parameter space, which is easy to see for the raw \textsc{Lcn}: the randomization enables the exploration that flips $\vo^i_1 = 0$ to $\vo^i_1 = 1$ to establish effective learning signal. Note that the standard DropOut~\citep{srivastava2014dropout} is not ideal for the low capacity models that we consider here. 

\textbf{Training \textsc{Elcn}.} Since each ensemble component is sub-differentiable, we can directly learn the whole ensemble through gradient descent. However, the approach is not scalable due to memory constraints in practice. Instead, we propose to train the ensemble in a boosting fashion:
\begin{enumerate}
\vspace{-3mm}
    \item We first train an initial locally constant network $g^{[1]}_{\phi}(\vec{J}_\vx \tilde \va^{M, [1]})$.
\vspace{-2mm}
    \item For each iteration $e' \in \{2,3,\dots,E\}$, we incrementally optimize $\sum_{e=1}^{e'} g^{[e]}_{\phi}(\vec{J}_\vx \tilde \va^{M, [e]})$.
\vspace{-3mm}
\end{enumerate}
Note that, in the second step, only the latest model is optimized, and thus we can simply store the predictions of the preceding models without loading them into the memory. Each partial ensemble can be directly learned through gradient descent, without resorting to complex meta-algorithms such as adaptive boosting~\citep{freund1997decision} or gradient boosting~\citep{friedman2001greedy}.  \vspace{-1mm}













 \section{Experiment}
\begin{table}
\caption{Dataset statistics}\label{tab:statistics}
  \centering
  \begin{tabular}{lcccccccccccc}
    \toprule
    \small Dataset                & \small {Bace} & \small {HIV} & \small {SIDER} & \small {Tox21} & \small {PDBbind}\\
    \midrule
    \small Task                   & \multicolumn{4}{c}{(Multi-label) binary classification} & \small Regression \\
    \small Number of labels       & \small 1 & \small 1 & \small 27 & \small 12 & \small 1 \\
    \small Number of data         & \small 1,513 & \small 41,127 & \small 1,427 & \small 7,831 & \small 11,908 \\
\bottomrule
  \end{tabular}
\end{table}

\begin{table}
  \caption{Main results. The $1^\text{st}$ section refers to (oblique) decision tree methods, the $2^\text{nd}$ section refers to single model extensions of \textsc{Lcn}, the $3^\text{rd}$ section refers to ensemble methods, and the last section is \textsc{Gcn}. The results of \textsc{Gcn} are copied from \citep{wu2018moleculenet}\camera{, where the results in SIDER and Tox21 are not directly comparable due to lack of standard splittings.} The best result in each \camera{section} is in bold letters.}\label{tab:main}
  \centering
  \begin{tabular}{lcccccccccccc}
    \toprule
    \small Dataset      & \small {Bace (AUC)} & \small {HIV (AUC)} & \small {SIDER (AUC)} & \small {Tox21 (AUC)} & \small {PDBbind (RMSE)}\\
    \midrule
    \textsc{Cart}       & \small 0.652 $\pm$ 0.024 & \small 0.544 $\pm$ 0.009 & \small 0.570 $\pm$ 0.010 & \small 0.651 $\pm$ 0.005 & \small 1.573 $\pm$ 0.000\\
    \textsc{Hhcart}     & \small 0.545 $\pm$ 0.016 & \small 0.636 $\pm$ 0.000 & \small 0.570 $\pm$ 0.009 & \small 0.638 $\pm$ 0.007 & \small 1.530 $\pm$ 0.000\\
    \textsc{Tao}        & \small 0.734 $\pm$ 0.000 & \small 0.627 $\pm$ 0.000 & \small 0.577 $\pm$ 0.004 & \small 0.676 $\pm$ 0.003 & \small Not applicable\\
    \textsc{Lcn}        & \small \bf 0.839 $\pm$ 0.013 & \small \bf 0.728 $\pm$ 0.013 & \small \bf 0.624 $\pm$ 0.044 & \small \bf 0.781 $\pm$ 0.017 & \small \bf 1.508 $\pm$ 0.017\\
    \midrule
    {\textsc{Lln}}      & \small 0.818 $\pm$ 0.007 & \small 0.737 $\pm$ 0.009 & \small \bf 0.677 $\pm$ 0.014 & \small 0.813 $\pm$ 0.009 & \small 1.627 $\pm$ 0.008\\
    \textsc{Alcn}       & \small \bf 0.854 $\pm$ 0.007 & \small \bf 0.738 $\pm$ 0.009 & \small 0.653 $\pm$ 0.044 & \small \bf 0.814 $\pm$ 0.009 & \small \bf 1.369 $\pm$ 0.007\\
    \midrule
    \textsc{Rf}         & \small 0.869 $\pm$ 0.003 & \small \bf 0.796 $\pm$ 0.007 & \small 0.685 $\pm$ 0.011 & \small \bf 0.839 $\pm$ 0.007 & \small 1.256 $\pm$ 0.002\\
    \textsc{Gbdt}       & \small 0.859 $\pm$ 0.005 & \small 0.748 $\pm$ 0.001 & \small 0.668 $\pm$ 0.014 & \small 0.812 $\pm$ 0.011 & \small 1.247 $\pm$ 0.002\\
    \textsc{Elcn}     & \small \bf 0.874 $\pm$ 0.005 & \small 0.757 $\pm$ 0.011 & \small \bf 0.685 $\pm$ 0.010 & \small 0.822 $\pm$ 0.006 & \small \bf {1.219 $\pm$ 0.007} \\
    \midrule
    \textsc{Gcn}        & \small 0.783 $\pm$ 0.014 & \small 0.763 $\pm$ 0.016   & \small *0.638 $\pm$ 0.012 & \small *0.829 $\pm$ 0.006 & \small 1.44 $\pm$ 0.12\\
    \bottomrule
  \end{tabular}
\end{table}

Here we evaluate the efficacy of our models (\textsc{Lcn}, \textsc{Alcn}, and \textsc{Elcn}) using the chemical property prediction datasets from MoleculeNet~\citep{wu2018moleculenet}, where random forest performs competitively. We include $4$ (multi-label) binary classification datasets and $1$ regression dataset. The statistics are available in Table~\ref{tab:statistics}. We follow the literature to construct the feature~\citep{wu2018moleculenet}. Specifically, we use the standard Morgan fingerprint~\citep{rogers2010extended}, 2,048 binary indicators of chemical substructures, for the classification datasets, and `grid features' (fingerprints of pairs between ligand and protein, see \citet{wu2018moleculenet}) for the regression dataset. Each dataset is splitted into (train, validation, test) sets under the criterion specified in MoleculeNet. 

We compare \textsc{Lcn} and its extensions (\textsc{Lln}, \textsc{Alcn}, and \textsc{Elcn}) with the following baselines: 
\begin{itemize}[leftmargin=4mm]
\vspace{-2mm}
    \item (Oblique) decision trees: \textsc{Cart} (\citet{cart84}), \textsc{Hhcart} (\citet{wickramarachchi2016hhcart}; oblique decision trees induced greedily on linear projections), and \textsc{Tao} (\citet{carreira2018alternating}; oblique decision trees trained via alternating optimization).
\vspace{-1mm}
    \item Tree ensembles: \textsc{Rf} (\citet{breiman2001random}; random forest) and \textsc{Gbdt} (\citet{friedman2001greedy}; gradient boosting decision trees).
\vspace{-1mm}
    \item Graph networks: \textsc{Gcn} (\citet{duvenaud2015convolutional}; graph convolutional networks on molecules). 
\vspace{-2mm}
\end{itemize}
For decision trees, \textsc{Lcn}, \textsc{Lln}, and \textsc{Alcn}, we tune the tree depth in $\{2,3,\dots,12\}$. For \textsc{Lcn}, \textsc{Lln}, and \textsc{Alcn}, we also tune the DropConnect probability in $\{0, 0.25, 0.5, 0.75\}$. Since regression tasks require precise estimations of the prediction values while classification tasks do not, we tune the number of hidden layers of $g_\phi$ in $\{0,1,2,3,4\}$ (each with $256$ neurons) for the regression task, and simply use a linear model $g_\phi$ for the classification tasks. For \textsc{Elcn}, we use \textsc{Alcn} as the base model, tune the ensemble size $E \in \{2^0, 2^1,\dots,2^6\}$ for the classification tasks, and $E \in \{2^0, 2^1, \dots, 2^9\}$ for the regression task. To train our models, we use the cross entropy loss for the classification tasks, and mean squared error for the regression task. Other minor details are available in Appendix~\ref{appendix:exp:implementation}.

We follow the chemistry literature~\citep{wu2018moleculenet} to measure the performance by AUC for classification, and root-mean-squared error (RMSE) for regression. For each dataset, we train a model for each label, compute the mean and standard deviation of the performance across $10$ different random seeds, and report their average across all the labels within the dataset. The results are in Table~\ref{tab:main}. 

Among the (oblique) decision tree training algorithms, our \textsc{Lcn} achieves the state-of-the-art performance. The continuous extension (\textsc{Alcn}) always improves the empirical performance of \textsc{Lcn}, which is expected since \textsc{Lcn} is limited for the number of possible outputs (leaf nodes). Among the ensemble methods, the proposed \textsc{Elcn} always outperforms the classic counterpart, \textsc{Gbdt}, and sometimes outperforms \textsc{Rf}. Overall, \textsc{Lcn} is the state-of-the-art method for learning oblique decision trees, and \textsc{Elcn} performs competitively against other alternatives for training tree ensembles. 




\textbf{Empirical analysis.} Here we analyze the proposed \textsc{Lcn} in terms of the optimization and generalization performance in the large HIV dataset. We conduct an ablation study on the proposed method for training \textsc{Lcn} in Figure~\ref{fig:analysis:lcn}. Direct training (without annealing) does not suffice to learn \textsc{Lcn}, while the proposed annealing succeed in optimization; even better optimization and generalization performance can be achieved by introducing DropConnect, which corroborates our hypothesis on the exploration effect during training in \xref{sec:learning} and its well-known regularization effect. Compared to other methods (Fig.~\ref{fig:analysis:train}), only \textsc{Tao} has a comparable training performance. In terms of generalization (Fig.~\ref{fig:analysis:test}), all of the competitors do not perform well and overfit fairly quickly. In stark contrast, \textsc{Lcn} outperforms the competitors by a large margin and gets even more accurate as the depth increases. This is expected due to the strong regularization of \textsc{Lcn} that uses a linear number of effective weights to construct an exponential number of decision nodes, as discussed in \xref{sec:inductive-bias}. Some additional analysis and the visualization of the tree converted from \textsc{Lcn} are included in Appendix~\ref{appendix:exp:analysis}.\!\!\!\!\!

\begin{figure}
\centering
	\captionsetup[subfigure]{aboveskip=-0pt,belowskip=-0pt}
    \begin{subfigure}{.32\textwidth}
		\centering
\includegraphics[width=1\linewidth]{img/HIV_lr_curve.pdf}
		\caption{\small Learning curve of \textsc{Lcn}}\label{fig:analysis:lcn}
	\end{subfigure}
    ~
    \begin{subfigure}{.32\textwidth}
		\centering
		\includegraphics[width=1\linewidth]{img/HIV_Training_complexity.pdf}
		\caption{\small Training performance}\label{fig:analysis:train}
	\end{subfigure}
    ~
    \begin{subfigure}{.32\textwidth}
		\centering
		\includegraphics[width=1\linewidth]{img/HIV_Testing_complexity.pdf}
		\caption{\small Testing performance}\label{fig:analysis:test}
	\end{subfigure}
	\caption{Empirical analysis for oblique decision trees on the HIV dataset. Fig.~\ref{fig:analysis:lcn} is an ablation study for \textsc{Lcn} and  Fig.~\ref{fig:analysis:train}-\ref{fig:analysis:test} compare different training methods.}\label{fig:analysis:all}
\end{figure} \section{Discussion and conclusion}
We create a novel neural architecture by casting the derivatives of deep networks as the representation, which realizes a new class of neural models that is equivalent to oblique decision trees. The induced oblique decision trees embed rich structures and are compatible with deep learning methods. This work can be used to interpret methods that utilize derivatives of a network, such as training a generator through the gradient of a discriminator~\citep{goodfellow2014generative}. The work opens up many avenues for future work, from building representations from the derivatives of neural models to the incorporation of more structures, such as the inner randomization of random forest. 

\subsubsection*{Acknowledgments}
\camera{GH and TJ were in part supported by a grant from Siemens Corporation. The authors thank Shubhendu Trivedi and Menghua Wu for proofreading, and thank the anonymous reviewers for their helpful comments.}




\bibliography{iclr2020_conference}
\bibliographystyle{iclr2020_conference}

\newpage

\appendix
\section{Proofs}
\subsection{Proof of Lemma~\ref{lemma:structural-constraint}}
\label{appendix:proof:structural-constraint}
\begin{proof}
We fix $j$ and do induction on $i$. Without loss of generality, we assume $1 = \vr_j \neq \vr'_j = 0$.

If $i=j$, since $\vr'_j = 0$, we have
\begin{align*}
\begin{cases}
    \vomega_{\vr_{1:i}} = \mW^{i+1}_{1, 1:D} + \sum_{k=1}^{i} \mW^{i+1}_{1, D+k} \times \vr_{k} \times \vomega_{\vr_{1:k-1}},\\
    \vomega_{\vr'_{1:1}} = \mW^{i+1}_{1, 1:D} + \sum_{k=1}^{i-1} \mW^{i+1}_{1, D+k} \times \vr_{k} \times \vomega_{\vr_{1:k-1}}.
    \end{cases}
\end{align*}
Hence, we have $\vomega_{\vr_{1:i}} - \vomega_{\vr'_{1:1}} = (\mW^{i+1}_{1, D+i} \times \vr_{i})  \times \vomega_{\vr_{1:i-1}} = \alpha \times \vomega_{\vr_{1:j-1}}$. 

We assume the statement holds for \emph{up to} some integer $i \geq j$:
\begin{equation*}
    \vomega_{\vr_{1:i}} - \vomega_{\vr_{1:i}'} =  \alpha \times \vomega_{\vr_{1:j-1}},\text{ for some } \alpha \in \sR.
\end{equation*}
For $i+1$, we have 
\begin{align*}
    \small 
    \vomega_{\vr_{1:i+1}} = & \mW^{i+2}_{1, 1:D} + \sum_{k=1}^{i+1} \mW^{i+2}_{1, D+k} \times \vr_{k} \times \vomega_{\vr_{1:k-1}} \\
    = & \mW^{i+2}_{1, 1:D} + \sum_{k=1}^{j-1} \mW^{i+2}_{1, D+k} \times \vr_{k} \times \vomega_{\vr_{1:k-1}} + \mW^{i+2}_{1, D+j} \times \vr_{j} \times \vomega_{\vr_{1:j-1}}\\
    & + \sum_{k=j+1}^{i+1} \mW^{i+2}_{1, D+k} \times \vr_{k} \times \vomega_{\vr_{1:k-1}}\\
    = & \mW^{i+2}_{1, 1:D} + \sum_{k=1}^{j-1} \mW^{i+2}_{1, D+k} \times \vr'_{k} \times \vomega_{\vr'_{1:k-1}} + \mW^{i+2}_{1, D+j} \times \vr_{j} \times \vomega_{\vr_{1:j-1}}\\
    & + \sum_{k=j+1}^{i+1} \mW^{i+2}_{1, D+k} \times \vr'_{k} \times (\vomega_{\vr'_{1:k-1}} + \alpha_k \times \vomega_{\vr_{1:j-1}}), \text{for some $\alpha_k \in \sR$}\\
    = & \mW^{i+2}_{1, 1:D} + \sum_{k=1}^{i+1} \mW^{i+2}_{1, D+k} \times \vr'_{k} \times \vomega_{\vr'_{1:k-1}}\\
    & + (\mW^{i+2}_{1, D+j} \times \vr_{j} + \sum_{k=j+1}^{i+1} \mW^{i+2}_{1, D+k} \times \vr_{k} \times \alpha_k) \times \vomega_{\vr_{1:j-1}}\\
    = & \vomega_{\vr'_{1:i+1}} + \alpha \times \vomega_{\vr_{1:j-1}}, \text{for some $\alpha \in \sR$}
\end{align*}
The proof follows by induction.
\end{proof}

\subsection{Proof of Theorem~\ref{thm:architecture_equivalence}}\label{appendix:proof:architect}

\begin{proof}
We first prove that we can represent any $g_\phi(\vec J_\vx \tilde \va^M)$ as $g(\tilde \vo^M)$. Note that for any $\vx$ mapping to the same activation pattern $\tilde \vo^M$, the Jacobian $\vec J_\vx \tilde \va^M$ is constant. Hence, we may re-write the standard architecture $g_\phi(\vec J_\vx \tilde \va^M)$ as $g_\phi(\vec J(\tilde \vo^M))$, where $\vec J(\tilde \vo^M)$ is the Jacobian corresponding to the activation pattern $\tilde \vo^M$. Then we can set $g(\cdot) \triangleq g_\phi(\vec J(\cdot))$, which concludes the first part of the proof. 

To prove the other direction, we first prove that we can also write the activation pattern as a function of the Jacobian. We prove this by layer-wise induction (note that $\tilde \vo^M = [\vo^1_1,\dots,\vo^M_1]$ and $\vec J_\vx \tilde \va^M = [\nabla_\vx \va^1_1,\dots,\nabla_\vx \va^M_1]$):
\begin{enumerate}[leftmargin=4mm]
    \item The induction hypothesis ($i \geq 2$) is that $[\vo^1_1,\dots,\vo^{i-1}_1]$ is a function of $[\nabla_\vx \va^1_1, \dots, \nabla_\vx  \va^{i-1}_1]$.\!\!\!\!\!
    \item If $\mW^1 = \textbf{0}$ (zero vector), $\vz^1_1$, $\va^1_1$, and $\vo^1_1$ are constant (thus being a function of $\nabla_\vx \va^1_1$). Otherwise, $\nabla_\vx \va^1_1 = \textbf{0} \Leftrightarrow \vo^1_1 = 0$ and $\nabla_\vx \va^1_1 = \mW^1 \Leftrightarrow \vo^1_1 = 1$, so $\vo^1_1$ can be written as a function of $\nabla_\vx \va^1_1$.\!\!\!\!\!
    \item Assume that we are given $[\nabla_\vx \va^1_1, \dots, \nabla_\vx  \va^{i-1}_1]$ and the corresponding $[\vo^1_1,\dots,\vo^{i-1}_1]$.
    
    If either $\vo^i_1 = 0$ or $\vo^i_1 = 1$ is infeasible (but not both), by induction hypothesis, $[\vo^1_1,\dots,\vo^{i}_1]$ can be written as a function of $[\nabla_\vx \va^1_1, \dots , \nabla_\vx  \va^{i}_1]$. 
    
    If $\vo^i_1 = 1$ for some $\vx'$ and $\vo^i_1 = 0$ for some $\vx''$, we claim that $\vo^i_1 = 1 \Rightarrow \nabla_\vx \va^i_1 \neq \textbf{0}$:
    
    If $\vo^i_1 = 1$ and $\nabla_\vx \va^i_1 = \textbf{0}$, we have $\vo^i_1 = 1 \Rightarrow \va^i_1 = \vz^i_1 \geq 0$ and $\textbf{0} = \nabla_\vx \va^i_1 = \nabla_\vx \vz^i_1$, which implies that the bias (of $\vz^i$, given $[\vo^1_1,\dots,\vo^{i-1}_1]$) $\vz^i_1 - (\nabla_\vx \vz^i_1)^\top \vx \geq 0$. Note that both $\nabla_\vx \vz^i_1$ and $\vz^i_1 - (\nabla_\vx \vz^i_1)^\top \vx$ are constant given $[\vo^1_1,\dots,\vo^{i-1}_1]$, regardless of $\vo^i_1$. Hence, given $[\vo^1_1,\dots,\vo^{i-1}_1]$, we have $\vz^i_1 = \vz^i_1 - (\nabla_\vx \vz^i_1)^\top \vx \geq 0$ and $\vo^i_1 = 0$ is infeasible ($\Rightarrow\!\Leftarrow$). 


    Note that, given fixed $[\vo^1_1,\dots,\vo^{i-1}_1]$, $\nabla_\vx \va^i_1 \neq \textbf{0}$ has a unique value in $\sR^d$. Combining the result $\vo^i_1 = 1 \Rightarrow \nabla_\vx \va^i_1 \neq \textbf{0}$ with $\vo^i_1 = 0 \Rightarrow \nabla_{\vx} \va^i_1 = \textbf{0}$, there is a bijection between $\vo^i_1$ and $\nabla_\vx \va^i_1$ in this case, which implies that $[\vo^1_1,\dots,\vo^{i}_1]$ can be written as a function of $[\nabla_\vx \va^1_1, \dots , \nabla_\vx  \va^{i}_1]$.\!\!\!
\end{enumerate}

The derivation implies that we may re-write the canonical architecture $g(\tilde \vo^M)$ as $g(\tilde \vo(\vec J_\vx \tilde \va^M))$, where $\tilde \vo(\vec J_\vx \tilde \va^M)$ is the activation pattern corresponding to the Jacobian $\vec J_\vx \tilde \va^M$. Hence, it suffices to establish that there exists a feed-forward network $g_\phi$ such that $g_\phi(\vec J_\vx \tilde \va^M) = g(\tilde \vo(\vec J_\vx \tilde \va^M))$ for at most $2^M$ distinct $\vec J_\vx \tilde \va^M$, which can be found by the Theorem 2.5 of \citet{hornik1989multilayer} or the Theorem 1 of \citet{zhang2016understanding}.
\end{proof}

\vspace{-1mm}
\section{Implementation details}\label{appendix:exp:implementation}
\vspace{-1mm}
Here we provide the full version of the implementation details.

For the baseline methods:
\begin{itemize}[leftmargin=4mm]
\vspace{-1mm}
    \item \textsc{Cart}, \textsc{Hhcart}, and \textsc{Tao}: we tune the tree depth in $\{2,3,\dots,12\}$.
\vspace{-1mm}
    \item \textsc{Rf}: we use the \texttt{scikit-learn}~\citep{pedregosa2011scikit} implementation of random forest. We set the number of estimators as $500$.
\vspace{-1mm}
    \item \textsc{Gbdt}: we use the \texttt{scikit-learn}~\citep{pedregosa2011scikit} implementation of gradient boosting trees. We tune the number of estimators in $\{2^3, 2^4,\dots,2^{10}\}$.
\vspace{-1mm}
\end{itemize}
For \textsc{Lcn}, \textsc{Lln}, and \textsc{Alcn}, we run the same training procedure. For all the datasets, we tune the depth in $\{2,3,\dots,12\}$ and the DropConnect probability in $\{0, 0.25, 0.5, 0.75\}$. 
The models are optimized with mini-batch stochastic gradient descent with batch size set to $64$. For all the classification tasks, we set the learning rate as $0.1$, which is annealed by a factor of $10$ for every $10$ epochs ($30$ epochs in total). For the regression task, we set the learning rate as $0.0001$, which is annealed by a factor of $10$ for every $30$ epochs ($60$ epochs in total).

Both \textsc{Lcn} and \textsc{Alcn} have an extra fully-connected network $g_\phi$, which transforms the derivatives $\vec{J}_\vx \tilde \va^M$ to the final outputs. Since regression tasks require precise estimation of prediction values while classification tasks do not, we tune the number of hidden layers of $g_\phi$ in $\{0,1,2,3,4\}$ (each with $256$ neurons) for the regression dataset, and simply use a linear $g_\phi$ for the classification datasets. 


For \textsc{Elcn}, we fix the depth to $12$ and tune the number of base models $E \in \{2^0, 2^1,\dots,2^6\}$ for the classification tasks, and $E \in \{2^0, 2^1, \dots, 2^9\}$ for the regression task. 
We set the DropConnect probability as $0.75$ to encourage strong regularization for the classification tasks, and as $0.25$ to impose mild regularization for the regression task (because regression is hard to fit).
We found stochastic gradient descent does not suffice to incrementally learn the \textsc{Elcn}, so we use the AMSGrad optimizer~\citep{reddi2019convergence} instead. We set the batch size as $256$ and train each partial ensemble for $30$ epochs. The learning rate is $0.01$ for the classification tasks, and $0.0001$ for the regression task.

To train our models, we use the cross entropy loss for the classification tasks, and mean squared error for the regression task.

\vspace{-1mm}
\section{Supplementary empirical analysis and visualization}\label{appendix:exp:analysis}
\vspace{-1mm}

\begin{table}[t]
  \vspace{-2mm}
  \caption{Analysis for ``unobserved decision patterns'' of \textsc{Lcn} in the Bace dataset.}\label{tab:appendix:analysis}
  \vspace{-2mm}
  \centering
  \begin{tabular}{lcccccccccccc}
    \toprule
    \small Depth                                            & \small 8      & \small 9      & \small 10     & \small 11     & \small 12\\ \midrule
    \small \# of possible patterns                          & \small 256    & \small 512    & \small 1024   & \small 2048   & \small 4096\\ \small \# of training patterns                          & \small  72    & \small  58    & \small   85   & \small  103   & \small 86\\
    \small \# of testing patterns                           & \small  32    & \small 31     & \small  48    & \small 49     & \small 40 \\
    \small \# of testing patterns - training patterns       & \small  5     & \small  2     & \small  11    & \small 8      & \small 11 \\
    \small Ratio of testing points w/ unobserved patterns   & \small 0.040  & \small 0.013  & \small 0.072  & \small 0.059  & \small 0.079 \\
    \midrule
    \small Testing performance - observed patterns          & \small 0.8505 & \small 0.8184 & \small 0.8270 & \small 0.8429 & \small 0.8390\\
    \small Testing performance - unobserved patterns        & \small 0.8596 & \small 0.9145 & \small 0.8303 & \small 0.7732 & \small 0.8894\\
    \bottomrule
  \end{tabular}
  \vspace{-5mm}
\end{table}


\subsection{Supplementary empirical analysis}

In this section, we investigate the learning of ``unobserved branching / leaves'' discussed in \xref{sec:standard}. The ``unobserved branching / leaves'' refer to the decision and leaf nodes of the oblique decision tree converted from \textsc{Lcn}, such that there is no training data that are routed to the nodes. It is impossible for traditional (oblique) decision tree training algorithms to learn the values of such nodes (e.g., the output value of a leaf node in the traditional framework is based on the training data that are routed to the leaf node). However, the shared parameterization in our oblique decision tree provides a means to update such unobserved nodes during training (see the discussion in \xref{sec:standard}). 

Since the above scenario in general happens more frequently in small datasets than in large datasets, we evaluate the scenario on the small Bace dataset (binary classification task). Here we empirically analyze a few things pertaining to the unobserved nodes:
\begin{itemize}[leftmargin=4mm]
\vspace{-1mm}
    \item \# of training patterns: the number of distinct end-to-end activation / decision patterns $\vr_{1:M}$ encountered in the training data.
\vspace{-1mm}
    \item \# of testing patterns: the number of distinct end-to-end activation / decision patterns $\vr_{1:M}$ encountered ib the testing data.
\vspace{-1mm}
    \item \# of testing patterns - training patterns: the number of distinct end-to-end activation / decision patterns $\vr_{1:M}$ that is only encountered in the testing data but not in the training data.
\vspace{-1mm}
    \item Ratio of testing points w/ unobserved patterns: the number of testing points that yield unobserved patterns divided by the total number of testing points. 
\vspace{-1mm}
    \item Testing performance - observed patterns: here we denote the number of testing data as $n$, the prediction and label of the $i^\text{th}$ as $\hat y_i \in [0, 1]$ and $y_i \in \{0, 1\}$, respectively. We collect the subset of indices $I$ of the testing data such that their activation / decision patterns $\vr_{1:M}$ are observed in the training data, and then compute the performance of their predictions. Since the original performance is measured by AUC, here we generalize AUC to measure a subset of points $I$ as:
    \begin{align}
        \frac{\sum_{i \in I} \sum_{j=1}^n \bigg( \one[y_i > y_j] \Big(\one[\hat y_i > \hat y_j] + 0.5 \one[\hat y_i = \hat y_j] \Big) + \one[y_i < y_j] \Big(\one[\hat y_i < \hat y_j] + 0.5 \one[\hat y_i = \hat y_j] \Big) \bigg) }{\sum_{i \in I} \sum_{j=1}^n \bigg( \one[y_i > y_j] + \one[y_i < y_j] ) \bigg)}.
    \end{align}
    When $I = [n]$, the above measure recovers AUC. 
\vspace{-1mm}
    \item Testing performance - unobserved patterns: the same as above, but use $I$ for the testing data such that their activation / decision patterns $\vr_{1:M}$ are \emph{unobserved} in the training data.
\vspace{-1mm}
\end{itemize}
The results are in Table~\ref{tab:appendix:analysis}. There are some interesting findings. For example, there is an exponential number of possible patterns, but the number of patterns that appear in the dataset is quite small. The ratio of testing points with unobserved patterns is also small, but these unobserved branching / leaves seem to be controlled properly. They do not lead to completely different performance compared to those that are observed during training. 

\subsection{Visualization}\label{appendix:visualization}

Here we visualize the learned locally constant network on the HIV dataset in the representation of its equivalent oblique decision tree in Fig.~\ref{fig:visualization}. Since the dimension of Morgan fingerprint~\citep{rogers2010extended} is quite high (2,048), here we only visualize the top-K weights (in terms of the absolute value) for each decision node. We also normalize each weight such that the $\ell_1$ norm of each weight is $1$. Since the task is evaluated by ranking (AUC), we visualize the leaf nodes in terms of the ranking of output probability among the leaf nodes (the higher the more likely). 


Note that a complete visualization requires some engineering efforts. Our main contribution here is the algorithm that transforms an \textsc{Lcn} to an oblique decision tree, rather than the visualization of oblique decision trees, so we only provide the initial visualization as a proof of concept. 



\begin{figure}
\vspace{-1mm}
	\centering
	\includegraphics[width=1.5\linewidth,angle=90,origin=c]{img/visual_tree.pdf}
	\caption{Visualization of learned locally constant network in the representation of oblique decision trees using the proof of Theorem~\ref{theorem:convert}. The number in the leaves indicates the ranking of output probability among the $16$ leaves (the exact value is not important). See the descriptions in Appendix~\ref{appendix:visualization}.}\label{fig:visualization}
    \vspace{-2.5mm}
\end{figure}
 

\end{document}
