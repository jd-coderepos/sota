\documentclass[envcountsame]{llncs}
\pagestyle{plain}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[noadjust]{cite}
\usepackage[retainorgcmds]{IEEEtrantools}
\usepackage{enumerate}
\usepackage{algorithm}
\usepackage[noend]{algorithmic}
\usepackage{centernot}
\usepackage{color}
\usepackage{soul}
\usepackage[absolute]{textpos}

\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{automata}
\usetikzlibrary{fit}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}




\usepackage[textwidth=3.5cm, shadow, disable]{todonotes}

\floatname{algorithm}{Procedure}








\let\originalleft\left
\let\originalright\right
\renewcommand{\left}{\mathopen{}\mathclose\bgroup\originalleft}
\renewcommand{\right}{\aftergroup\egroup\originalright}

\spnewtheorem{fclaim}{Faulty Claim}{\itshape}{\rmfamily}

\newcommand*{\eventually}{\LTLdiamond}
\newcommand*{\globally}{\LTLsquare}
\newcommand*{\once}{\LTLdiamondminus}
\newcommand*{\henceforth}{\LTLsquareminus}
\newcommand*{\nextx}{\LTLcircle}
\newcommand*{\prevy}{\LTLcircleminus}

\newcommand*{\until}{\mathbin{\mathcal{U}}}
\newcommand*{\since}{\mathbin{\mathcal{S}}}

\newcommand*{\weventually}{\LTLdiamond^{\mkern-4mu w}}
\newcommand*{\wglobally}{\LTLsquare^{\mkern-4mu w}}
\newcommand*{\wonce}{\LTLdiamondminus^{\mkern-4mu w}}
\newcommand*{\whenceforth}{\LTLsquareminus^{\mkern-4mu w}}
\newcommand*{\wuntil}{\mathbin{\mathcal{U}^w}}
\newcommand*{\wsince}{\mathbin{\mathcal{S}^w}}


\newcommand*{\modelsfs}{\mathbin{\models_{\mkern-6mu f}^{\mkern-6mu +}}}
\newcommand*{\modelsfn}{\mathbin{\models_{\mkern-6mu f}^{\mkern-6mu \phantom{+}}}}
\newcommand*{\modelsfw}{\mathbin{\models_{\mkern-6mu f}^{\mkern-6mu -}}}

\newcommand*{\first}{\mathcal{B}^\rightarrow}
\newcommand*{\pfirst}{\mathcal{B}^\leftarrow}


\newcommand*{\earlier}{\mathfrak{E}}
\newcommand*{\newer}{\mathfrak{N}}
\newcommand*{\guntil}{\mathbin{\mathfrak{U}}}
\newcommand*{\gsince}{\mathbin{\mathfrak{S}}}

\newcommand*{\ltl}{\textmd{\textsf{LTL}}}
\newcommand*{\ltlpast}{\textmd{\textsf{LTL[]}}}

\newcommand*{\mitl}{\textmd{\textsf{MITL}}}
\newcommand*{\mitllu}{\textmd{}}
\newcommand*{\mtl}{\textmd{\textsf{MTL}}}
\newcommand*{\mtlunit}{\textmd{\textsf{MTL[]}}}
\newcommand*{\mtlpast}{\textmd{\textsf{MTL[]}}}
\newcommand*{\mtlpastcnt}{\textmd{\textsf{MTL[]}}}
\newcommand*{\mtlpastg}{\textmd{\textsf{MTL[]}}}
\newcommand*{\mtlpastgli}{\textmd{\textsf{MTL[]}}}
\newcommand*{\mtlbpast}{\textmd{\textsf{MTL[]}}}
\newcommand*{\mtlenpast}{\textmd{\textsf{MTL[]}}}
\newcommand*{\mitlpast}{\textmd{\textsf{MITL[]}}}

\newcommand*{\fo}{\textmd{\textsf{FO[]}}}
\newcommand*{\foone}{\textmd{\textsf{FO[]}}}


\newcommand*{\sqcupsqcap}{{\sqcup}{\mkern-3mu \sqcap}}
\newcommand*{\sqcapsqcup}{{\sqcap}{\mkern-3mu \sqcup}}



\let\doendproof\endproof
\renewcommand\endproof{~\hfill\qed\doendproof}

\newcommand{\qedhere}{\begingroup \let\mathqed\math@qedhere
    \let\qed@elt\setQED@elt \QED@stack\relax\relax \endgroup
} 

\usepackage[bookmarks=false]{hyperref}
\usepackage[all]{hypcap}

\title{The Cyclic-Routing UAV Problem is -Complete}
\author{Hsi-Ming Ho and Jo\"el Ouaknine}
\institute{Department of Computer Science, University of Oxford \\ Wolfson Building, Parks Road, Oxford, OX1 3QD, UK}
\begin{document}
\maketitle
\thispagestyle{plain}
\begin{abstract}
Consider a finite set of targets, with each target assigned a
\emph{relative deadline}, and each pair of targets assigned a fixed
transit \emph{flight time}. Given a flock of identical UAVs, can
one ensure that every target is repeatedly visited by some UAV at
intervals of duration at most the target's relative deadline? The
\mbox{\emph{\textbf{Cyclic-Routing UAV Problem}} \textsc{(cr-uav)}} is the question of
whether this task has a solution.

This problem can straightforwardly be solved in  by
modelling it as a network of timed automata. The special case of there
being a single UAV is claimed to be -complete in the
literature. In this paper, we show that the \textsc{cr-uav} Problem is in
fact -complete even in the single-UAV case.
\end{abstract}

\section{Introduction}

Unmanned aerial vehicles (UAVs) have many uses, ranging from civilian
to military operations. Like other autonomous systems, they are
particularly well-suited to `dull, dirty, and/or dangerous'
missions~\cite{UAVS}.  A common scenario in such missions is that a
set of targets have to be visited by a limited number of UAVs.  This
has given rise to a large body of research on \emph{path planning} for
UAVs.\footnote{\url{http://scholar.google.com/} lists thousands of papers on the subject.} Depending on the specific application at hand, paths of UAVs
may be subject to various complex constraints, e.g., related to kinematics or
fuel (see, e.g.,~\cite{Alighanbari2003, Elizabeth2012, Yang2002,
  Richards2002}).


In this work, we consider the \emph{Cyclic-Routing UAV Problem} (\textsc{cr-uav})~\cite{Drucker2010}:
the decision version of a simple \emph{recurrent}
UAV path-planning problem in which each target must be visited not only
once but repeatedly, i.e., at intervals of prescribed maximal duration. 
Problems of this type have long been considered in many other fields
such as transportation~\cite{Orlin1982, Wollmer1990} and
robotics~\cite{Crama1997, Kats1997}.  More recently, a number of
game-theoretic frameworks have been developed to study similar
problems in the context of security~\cite{Tsai2009, Jain2010,
  Basilico2012}.





A special case of the problem (with a single UAV) is considered
in~\cite{Basilico2009, Basilico2012, Fargeas2013}, and is claimed to
be -complete in~\cite{Basilico2012}.  However, the proof
of -membership in~\cite{Basilico2012} is not
detailed.\footnote{A counterexample to a crucial claim
  in~\cite{Basilico2012} is given in Appendix~\ref{app:cex}.}  The
main result of the present paper is that the \textsc{cr-uav} Problem is
in fact -complete, even in the single-UAV case.
We note that this problem can be seen as a recurrent variant of the
decision version of the \emph{Travelling Salesman Problem with Time
  Windows} (\textsc{tsptw}) with upper bounds only (or \emph{TSP with Deadlines}~\cite{Bockenhauer2007}).  Its
-hardness hence stems from recurrence: the decision
version of the (non-recurrent) \textsc{tsptw} Problem is
-complete~\cite{Savelsbergh1985}.



-membership of the (general) \textsc{cr-uav} Problem
follows straightforwardly by encoding the problem as the existence of
infinite paths in a network of timed automata; we briefly sketch the
argument in the next section. The bulk of the paper is then
devoted to establishing -hardness of the single-UAV
case. This is accomplished by reduction from the \textsc{periodic sat}
Problem, known to be -complete~\cite{Orlin1981}.

\section{Preliminaries}



\subsection{Scenario}

Let there be a set of targets and a number of identical UAVs.  Each
target has a \emph{\textbf{relative deadline}}: an upper bound
requirement on the time between successive visits by UAVs.  The UAVs
are allowed to fly freely between targets, with a \emph{\textbf{flight
    time}} given for each pair of targets: the amount of time
required for a UAV to fly from one of the targets to the other. We
assume that flight times are symmetric, that they obey the triangle
inequality, and that the flight time from target  to target  is
zero iff  and  denote the same target. In other words, flight
times are a metric on the set of targets. The goal is to decide
whether there is a way to coordinate UAVs such that no relative
deadline is ever violated. We make a few further assumptions:
\begin{itemize}
\item Initially, each UAV starts at some target; there may be more
  than one UAV at the same target.
\item The first visit to each target must take place at the latest by
  the expiration time of its relative deadline.
\item The UAVs are allowed to `wait' as long as they wish at any given
  target. 
\item Time units are chosen so that all relative deadlines and flight
  times are integers, and moreover all relative deadlines are
  interpreted as closed constraints (i.e., using non-strict inequalities).
\end{itemize}


\subsection{Modelling via Networks of Timed Automata}\label{subsec:membership}

We briefly sketch how to model the \textsc{cr-uav} Problem as the
existence of infinite non-Zeno paths in a network of B\"uchi timed
automata, following the notation and results of~\cite{Alur1998}, from
which -membership immediately follows.

Intuitively, one ascribes a particular timed automaton to each UAV and
to each target. Each UAV-automaton keeps track of the location of its
associated UAV, and enforces flight times by means of a single clock,
which is reset the instant the UAV leaves a given target. Each
target-automaton is likewise equipped with a single clock, keeping
track of time elapsed since the last visit by some UAV\@. The action
of a UAV visiting a target is modelled by synchronising on a
particular event; when this takes place, provided the target's
relative deadline has not been violated, the target resets its
internal clock and instantaneously visits a B\"uchi
location. Similarly, the action of a UAV leaving a target is modelled
by event synchronisation. Finally, since multiple UAVs may visit a
given target simultaneously, each target is in addition equipped with
a counter to keep track at any time of whether or not it is currently
being visited by some UAV.

The given instance of the \textsc{cr-uav} Problem therefore has a
solution iff there exists a non-Zeno run of the resulting network of
timed automata in which each B\"uchi accepting location is visited
infinitely often. By Thm.~ of \cite{Alur1998}, this can be decided in
.

It is worth noting that, since all timing constraints are closed by
assumption, standard digitisation results apply (cf.~\cite{Henzinger1992}) and
it is sufficient to consider integer (i.e., discrete) time. In the
next section, we therefore present a discrete graph-based (and
timed-automaton independent) formulation of the problem specialised to
a single UAV, in order to establish -hardness.

\subsection{Weighted Graph Formulation}

The solution to a single-UAV instance of the \textsc{cr-uav} Problem
consists of an infinite path from target to target in which each
target is visited infinitely often, at time intervals never greater
than the target's relative deadline. One may clearly assume that the
UAV never `lingers' at any given target, i.e., targets are visited
instantaneously.  Formally, a single-UAV instance of the \textsc{cr-uav} Problem can be
described as follows. Let  be a set of  vertices, with
each vertex  assigned a strictly positive integer weight
 (intuitively, the relative deadline of target
). Consider a weighted undirected clique over , i.e., to each
pair of vertices  with , one assigns a strictly
positive integer weight  (intuitively, the flight
time from  to ). In addition we require that  be
symmetric and satisfy the triangle inequality.








Let  be an instance of
the above data. Given a finite path  in (the clique associated
with) , the \emph{\textbf{duration}}  of  is
defined to be the sum of the weights of the edges in . A
\emph{\textbf{solution}} to  is an infinite path  through  with the
following properties:
\begin{itemize}
\item  visits every vertex in  infinitely often;
\item Any finite subpath of  that starts and ends at
  consecutive occurrences of a given vertex  must have duration at
  most .
\end{itemize}

\begin{definition}[The \textsc{cr-uav} Problem with a Single UAV]
Given  as described above, does  have a solution?
\end{definition}

As pointed out in~\cite{Fargeas2013}, if a
solution exists at all then a \emph{periodic} solution can be found, i.e., an
infinite path in which the targets are visited repeatedly in the same
order.




\subsection{The \textsc{periodic sat} Problem}

\textsc{periodic sat} is one of the many -complete
problems introduced in~\cite{Orlin1981}.  In the following definition
(and in the rest of this paper), let  be a finite set of
variables and let  be the set of variables obtained
from  by adding a superscript  to each variable.


\begin{definition}[The \textsc{periodic sat} Problem~\cite{Orlin1981}]
Consider a CNF formula  over . Let  be the formula obtained from
 by replacing all variables  by
 and all variables  by .
Is there an assignment of  such
that  is satisfied?
\end{definition}








\section{-Hardness}

In this section, we give a reduction from the \textsc{periodic sat}
Problem to the \textsc{cr-uav} Problem with a single UAV\@.
Consider a CNF formula 
over  and .  Without loss of generality, we assume that
each clause  of  is non-trivial (i.e.,  does not
contain both positive and negative occurrences of a variable) and , . We can construct an instance  of the \textsc{cr-uav}
Problem (with the largest constant having magnitude  and ) such that  is satisfiable
if and only if  has a solution.

The general idea of the reduction can be described as follows. We
construct \emph{variable gadgets} that can be traversed in two
`directions' (corresponding to assignments  and
 to variables). A \emph{clause vertex} is visited if
the corresponding clause is satisfied by the assignment.  Crucially,
we use \emph{consistency gadgets}, in which we set the relative
deadlines of the vertices carefully to ensure that the directions of
traversals of the variable gadgets for  (corresponding
to a particular assignment of variables) in a given iteration is
consistent with the directions of traversals of the variable gadgets
for  in the next iteration.

\subsection{The Construction}

We describe and explain each part of  in detail.
The reader is advised to glance ahead to Figure~\ref{fig:stack} to form an
impression of .  Note that for ease of presentation, we temporarily
relax the requirement that  be a metric and describe  as an incomplete graph.\footnote{In
  the single-UAV case, if the  of some edge is greater
  than any value in , that edge can simply be seen as
  non-existent.}  In what follows, let  and


\subsubsection{Variable Gadgets}
For each variable , we construct (as a subgraph of ) a \emph{variable gadget}.
It consists of the following vertices (see Figure~\ref{fig:vargadget}):
\begin{itemize}
\item Three vertices on the left side ()
\item Three vertices on the right side ()
\item A `\emph{clause box}' () for each 
\item A `\emph{separator box}' () for each 
\item A vertex at the top ( if ,  otherwise)
\item A vertex at the bottom ().
\end{itemize}

\begin{figure}[h]
\centering
\begin{tikzpicture}[-,>=stealth', auto, transform shape, node distance=2.5cm, scale=0.9,
                    semithick, every state/.style={fill=none,draw=black,text=black,shape=circle,scale=0.3}]

\node[state]               (vsrc)  {};
\node[state]			   (v5i) [above=.5cm of v5] {};

\node[state]			   (v4) [left of =v5] {};
\node[state]			   (v4o) [above=.5cm of v4] {};
\node[state]			   (v3i) [above=.5cm of v3] {};

\node[state]			   (v2) [left of =v3] {};
\node[state]			   (v2o) [above=.5cm of v2] {};
\node[state]			   (v1i) [above=.5cm of v1] {};

\node[state]			   (v1') [left=2cm of v1] {};
\node[state]			   (v1'o) [below=.5cm of v1'] {};
\node[state]			   (v6i) [below=.5cm of v6] {};

\node[state]				(v7) [right of =v6] {};
\node[state]			   (v7o) [below=.5cm of v7] {};
\node[state]			   (v8i) [below=.5cm of v8] {};

\node[state]				(v9) [right of =v8] {};
\node[state]			   (v9o) [below=.5cm of v9] {};
\node[state]			   (v10i) [below=.5cm of v10] {};

\node[state]				(v10') [right=2cm of v10] {};
\node[state]			   (v10'o) [below=.5cm of v10'] {};

\node (box1) [draw=gray!50, fit=(v3i) (v4i), dashed, line width=1mm, inner sep=3mm] {};
\node (box2) [draw=gray!50, fit=(v7i) (v8i), dashed, line width=1mm, inner sep=3mm] {};


\node[state, draw=none]				 (p') [below=3cm of ]  {};

\node[state, draw=none]			   (oup') [above right=.6cm and .2cm of p'] {};

\node[state, draw=none]			   (idown) [above left=.6cm and .2cm of p] {};



\path (vsrc) edge node [swap] {\scriptsize } (v1'i.north)
		(vsrc) edge node {\scriptsize } (v10'i.north)

        (v1'i) edge node [right=-1mm] {\scriptsize } (v1'o)

        (v1i) edge node [right=-1mm] {\scriptsize } (v1o)

        (v2i) edge node [right=-1mm] {\scriptsize } (v2o)

        (v3i) edge node [right=-1mm] {\scriptsize } (v3o)

        (v4i) edge node [right=-1mm] {\scriptsize } (v4o)

        (v5i) edge node [right=-1mm] {\scriptsize } (v5o)

        (v6i) edge node [right=-1mm] {\scriptsize } (v6o)

        (v7i) edge node [right=-1mm] {\scriptsize } (v7o)

        (v8i) edge node [right=-1mm] {\scriptsize } (v8o)

        (v9i) edge node [right=-1mm] {\scriptsize } (v9o)

        (v10i) edge node [right=-1mm] {\scriptsize } (v10o)

        (v10'i) edge node [right=-1mm] {\scriptsize } (v10'o)

        (v1i) edge node [below=-1mm] {\scriptsize } (v3i)
        (v3i) edge node [below=-1mm] {\scriptsize } (v5i)
        (v5i) edge node [below=-1mm] {\scriptsize } (v6o)
        (v6o) edge node [below=-1mm] {\scriptsize } (v8o)
        (v8o) edge node [below=-1mm] {\scriptsize } (v10o)


        (v1o) edge node [swap, below=-1mm] {\scriptsize } (v3o)
        (v3o) edge node [swap, below=-1mm] {\scriptsize } (v5o)
        (v5o) edge node [swap, below=-1mm] {\scriptsize } (v6i)
        (v6i) edge node [swap, below=-1mm] {\scriptsize } (v8i)
        (v8i) edge node [swap, below=-1mm] {\scriptsize } (v10i)


        (v1'o.south) edge node [swap] {\scriptsize } (vsnk)
        (v10'o.south) edge node {\scriptsize } (vsnk)

		  (v1'o) edge [dotted] node {} (idown)

		  (v1'i) edge [dotted] node {} (oup)

		  (v10'o) edge [dotted] node {} (idown')

		  (v10'i) edge [dotted] node {\mathit{Row}_i = \bigcup_{j \in \{1, \ldots, h\}} \mathit{CB}_i^j \cup \bigcup_{j \in \{0, \ldots, h\}} \mathit{SB}_i^j\mathit{Row}_{i + m} = \bigcup_{j \in \{1, \ldots, h\}} \mathit{CB}_{i + m}^j \cup \bigcup_{j \in \{0, \ldots, h\}} \mathit{SB}_{i + m}^j
x_1^0, x_2^0, \ldots, x_m^0, x_1^1, x_2^1, \ldots, x_m^1 \,.
};
\node[state]			   (v5i) [above=.5cm of v5] {};

\node[state]			   (v4) [left of =v5] {};
\node[state]			   (v4o) [above=.5cm of v4] {};

\node (box1) [draw=gray!50, fit=(v4o) (v5o), dashed, line width=1mm, inner sep=3mm] {};
\node [xshift=1.5mm, yshift=-1.5mm] at (cj.south east) {};


\path   (vii') edge [->, line width=1mm] node {\scriptsize } (v4o)
        (vio') edge node [swap] {\scriptsize } (v4i)
		  (v5i) edge [->, line width=1mm] node {\scriptsize } (vii)
        (vio) edge node {\scriptsize } (v5o)
			
        (v4) edge [->, line width=1mm] node [swap] {\scriptsize } (v4i)
        (v4o) edge [->, line width=1mm] node [swap] {\scriptsize } (v4)

        (v4i) edge node [swap] {\scriptsize } (v5o)
        (v5i) edge node [swap] {\scriptsize } (v4o)

        (v4i) edge [->, line width=1mm] node [swap] {\scriptsize } (cj.north west)
        (cj.north east) edge [->, line width=1mm] node [swap] {\scriptsize } (v5o)

        (v5) edge [->, line width=1mm] node {\scriptsize } (v5i)
        (v5o) edge [->, line width=1mm] node {\scriptsize } (v5);

\end{tikzpicture}
\caption{The variable occurs positively in }
\label{fig:detour}
\end{minipage}
\begin{minipage}[b]{0.5\linewidth}
\centering
\begin{tikzpicture}[-,>=stealth', auto, transform shape, node distance=7cm, scale=0.9,
                    semithick, every state/.style={fill=none,draw=black,text=black,shape=circle,scale=0.3}]

\node[state]			   (p) {};

\node[state]			   (oup) [above right of =p] {};

\node[state]			   (odown) [below right of =p] {};
\node[state, draw=none]			   (v3i) [above=.5cm of v3] {};

\node[state]			   (v2) [left of =v3] {};
\node[state]			   (v2o) [above=.5cm of v2] {};
\node[state]			   (v1i) [above=.5cm of v1] {};

\node[state]			   (v0) [left=2cm of v1] {};
\node[state]			   (v0o) [below=.5cm of v0] {};
\node[state]				(vb1)	[below right=2cm and 2.5cm of v2] {};


\node[state]			   (v5) [below right=2cm and 2.5cm of vt1] {};
\node[state]			   (v5o) [above=.5cm of v5] {};
\node[state, draw=none]			   (v4i) [above=.5cm of v4] {};

\node[state]			   (v6) [right of =v5] {};
\node[state]			   (v6o) [below=.5cm of v6] {};
\node[state]			   (v7i) [above=.5cm of v7] {};



\node[state]			   (v2') [below left=2cm and 2.5cm of vt2] {};
\node[state]			   (v2o') [above=.5cm of v2'] {};
\node[state, draw=none]			   (v3i') [above=.5cm of v3'] {};

\node[state]			   (v1') [left of =v2'] {};
\node[state]			   (v1o') [below=.5cm of v1'] {};
\node[state]			   (v0i') [above=.5cm of v0'] {};

\node[state]				(vb1')	[below right=2cm and 2.5cm of v2'] {};
\node[state]			   (v5i') [below=.5cm of v5'] {};

\node[state, draw=none]			   (v4') [left of =v5'] {};
\node[state, draw=none]			   (v4o') [below=.5cm of v4'] {};
\node[state]			   (v6i') [above=.5cm of v6'] {};

\node[state]			   (v7') [right=2cm of v6'] {};
\node[state]			   (v7o') [below=.5cm of v7'] {};

\node[state]			   (idown') [above left=.6cm and .4cm of p'] {};


\node[state]			   (iup') [below left=.6cm and .4cm  of p'] {};


\node[state]				 (p) [below=2.85cm of ]  {};

\node[state]			   (oup) [above right=.6cm and .4cm of p] {};

\node[state]			   (odown) [below right=.6cm and .4cm of p] {} (v0i.north)
	     (v0i) edge [->, line width=1mm] node {} (v0o)

	     (v1i) edge [->, line width=1mm] node {} (v1o)

	     (v2i) edge [->, line width=1mm] node {} (v2o)

	     (v1i) edge node {} (v2i)

	     (v2i) edge node {} (v3i)
	     (v0o.south) edge node {} (v0i'.north)
	     (v0i') edge [->, draw=black!50, line width=1mm] node {} (v0o')

	     (v1i') edge [->, draw=black!50, line width=1mm] node {} (v1o')

	     (v2i') edge [->, draw=black!50, line width=1mm] node {} (v2o')

	     (v2o') edge [->, draw=black!50, line width=1mm] node {} (v2i')

	     (v3o') edge [->, draw=black!50, line width=1mm] node {} (v3i')
	     (v0o'.south) edge [->, draw=black!50, line width=1mm] node {} (v7i.north)
	     (v7i) edge [->, line width=1mm] node {} (v7o)

	     (v6) edge [->, line width=1mm] node {} (v6)

	     (v5) edge [->, line width=1mm] node {} (v5)

	     (v4i) edge [->, line width=1mm] node {} (v5i)

	     (v5i) edge [->, line width=1mm] node {} (v6i)
	     (v7o.south) edge  [->, line width=1mm] node {} (v7i'.north)
	     (v7i') edge [->, draw=black!50, line width=1mm] node {} (v7o')

	     (v6o') edge [->, draw=black!50, line width=1mm] node {} (v6i')

	     (v5') edge [->, draw=black!50, line width=1mm] node {} (v5')

	     (v4i') edge node {} (v4o')

	     (v5i') edge node {} (v5o')
	     (v7o'.south) edge node {} (oup)
		  (idown) edge [->, line width=1mm] node {} (odown)
		  (iup) edge [->, draw=black!50, line width=1mm] node {} (idown)
	     (v1o) edge node {} (oup)
	     (oup) edge [->, line width=1mm] node {} (iup)
	     (v1o') edge [->, draw=black!50, line width=1mm] node {} (v0i')
	     (v1i') edge node {} (oup')
		  (idown') edge [->, line width=1mm] node {} (odown')
		  (iup') edge [->, draw=black!50, line width=1mm] node {} (idown')
		  (v7o) edge node {} (oup')
	     (oup') edge [->, line width=1mm] node {} (iup')
		  (v7o') edge [->, draw=black!50, line width=1mm] node {} (v6o')
	     (v7i') edge node {} (odown');

\end{tikzpicture}
\caption{Connecting the variable gadgets for  and  to  and }
\label{fig:connectaux}
\end{figure}
The vertices 
are connected to certain vertices in the variable gadget for ---this allows  and  to be traversed `from above'. Similarly,
the edges connected to  allow  and  to be traversed `from below'.
Formally,  if
\begin{itemize}
\item 
\item 
\item 
\item .
\end{itemize}
Two parts of an intended path, which we will explain in more detail later, is also illustrated in Figure~\ref{fig:connectaux}.

Finally, there is a vertex  with  connected to  and 
with two edges, both with  equal to .
The  of all the missing edges are 
(note that the largest value in  is less than , so these edges can never be taken).
This completes the construction of . An example with 
is given in Figure~\ref{fig:stack}, where vertices in  (shared by two variable gadgets) are depicted as solid circles.


\begin{figure}[h]
\centering
\begin{tikzpicture}[-,>=stealth', auto, transform shape, node distance=.6cm, scale=0.7,
                    semithick, every state/.style={fill=none,draw=black,text=black,shape=circle, scale=0.3}]



\node[state, draw=none]			   (v3) {};
\node[state, draw=none]			   (v3o) [below=.25cm of v3] {};
\node[state]			   (v0i) [above=.4cm of v0] {};

\node[state]				(vt1)	[above=1cm of v3] {};


\node[state]			   (v7) [right=2.5cm of v3] {};
\node[state]			   (v7o) [below=.4cm of v7] {};
\node[state, draw=none]			   (v3i2) [above=.25cm of v32] {};


\node[state]			   (v02) [left=2.5cm of v32] {};
\node[state]			   (v0o2) [below=.4cm of v02] {};
\node[state]				(vb2)	[below=1cm of v32] {};
\node[state]			   (v7i2) [above=.4cm of v72] {};




\node[state, draw=none]			   (v33) [below=1cm of vb2] {};
\node[state, draw=none]			   (v3o3) [below=.25cm of v33] {};
\node[state]			   (v0i3) [above=.4cm of v03] {};

\node[state, fill=black]				(vt3)	[above=1cm of v33] {};


\node[state]			   (v73) [right=2.5cm of v33] {};
\node[state]			   (v7o3) [below=.4cm of v73] {};
\node[state, draw=none]			   (v3i4) [above=.25cm of v34] {};


\node[state]			   (v04) [left=2.5cm of v34] {};
\node[state]			   (v0o4) [below=.4cm of v04] {};
\node[state]				(vb4)	[below=1cm of v34] {};
\node[state]			   (v7i4) [above=.4cm of v74] {};


\node[state]				(vmid)	[right=8cm of vt4] {};
\node[state, draw=none]			   (v3i5) [above=.25cm of v35] {};


\node[state]			   (v05) [left=2.5cm of v35] {};
\node[state]			   (v0o5) [below=.4cm of v05] {};
\node[state]				(vb5)	[below=1cm of v35] {};
\node[state]			   (v7i5) [above=.4cm of v75] {};




\node[state, draw=none]			   (v36) [below=1cm of vb5] {};
\node[state, draw=none]			   (v3o6) [below=.25cm of v36] {};
\node[state]			   (v0i6) [above=.4cm of v06] {};

\node[state, fill=black]				(vt6)	[above=1cm of v36] {};


\node[state]			   (v76) [right=2.5cm of v36] {};
\node[state]			   (v7o6) [below=.4cm of v76] {} (v0)
		  (v0) edge node {} (v7)
		  (v7) edge node {} (v02)
		  (v02) edge node {} (v72)
		  (v72) edge node {} (v03)
		  (v03) edge node {} (v73)
		  (v73) edge node {} (v04)
		  (v04) edge node {} (v74)
		  (v74) edge node {} (v05)
		  (v05) edge node {} (v75)
		  (v75) edge node {} (v06)
		  (v06) edge node {} (v76)
		  (v76) edge node {} (v7o6)
		  (v7o6.south) edge node [swap, near start, fill=white, inner sep=1pt] {\small } (vb6)
		  (v0o6.south) edge node [near start] {\small } (vb6)
		  


;

\end{tikzpicture}
\caption{An example with . Solid circles denote shared vertices .}
\label{fig:stack}
\end{figure}

The rest of this section is devoted to the proof of the following proposition.
\begin{proposition}\label{prop:iff}
 is satisfiable iff  has a solution.
\end{proposition}
\subsection{The Proof of Proposition~\ref{prop:iff}}

We first prove the forward direction. Given a satisfying assignment of
, we construct a solution  as follows:  starts from 
and goes through the variable gadgets for  in order,
eventually reaching . Each variable gadget is traversed according to the
truth value assigned to its corresponding variable. In such a traversal,
both  and  are visited once
(see the thick arrows in Figure~\ref{fig:connectaux} for the situation when  is assigned 
and  is assigned ).
Along the way from  to ,  detours at certain times and `hits' each clause vertex
exactly once as illustrated by the thick arrows in Figure~\ref{fig:detour}
(this can be done as  is satisfied by the assignment).
Then  goes back to  through  and starts over again, this time following 
the truth values assigned to variables in , and so on.
One can verify that this describes a solution to .

Now consider the other direction. Let 

be a periodic solution to  where each \emph{segment} ,  is a
finite subpath visiting only vertices in .





\begin{proposition}\label{prop:tborbt}
In , either of the following holds:
\begin{itemize}
\item All ,  starts with  and ends with 
\item All ,  starts with  and ends with .
\end{itemize}
\end{proposition}
\begin{proof}
See Appendix~\ref{app:tborbt}.
\end{proof}
We therefore further assume that  satisfies the first case of the proposition above
(this is sound as a periodic solution can be `reversed' while remaining a valid solution).
We argue that  `witnesses' a satisfying assignment of .
\todo{should this be called a lemma?}
\begin{proposition}\label{prop:exact}
In each segment , each vertex in  appears twice
whereas other vertices in  appear once.
\end{proposition}
\begin{proof}
See Appendix~\ref{app:cnt}.
\end{proof}
Based on this proposition, we show that  cannot `jump' between variable gadgets via clause vertices.
It follows that the traversal of each  must be done in a single pass.

\begin{proposition}\label{prop:nojump}
In each segment , if  is entered from a clause box (in some variable gadget), the edge that
immediately follows must go back to the same clause box.
\end{proposition}
\begin{proof}
Consider a  `box' formed by a separator box
and (the left- or right-) half of a clause box.
Note that except for the four vertices at the corners, no vertex in this  box is 
connected to the rest of the graph. Recall that if each vertex in this  box is to be
visited only once (as enforced by Proposition~\ref{prop:exact}),
it must be traversed in the patterns illustrated in Figures~\ref{fig:pat1} and~\ref{fig:pat2}.

\begin{figure}[h]
\begin{minipage}[b]{0.5\linewidth}
\centering
\begin{tikzpicture}[-,>=stealth', auto, transform shape, node distance=2.5cm,
                    semithick, every state/.style={fill=none,draw=black,text=black,shape=circle,scale=0.3}]

\node[state, draw=none]	   (vi) 								{\LARGE };
\node[state, draw=none]	   (vii) [above=.37cm of vi]	{\LARGE };
\node[state, draw=none]	   (vio) [below=.37cm of vi]	{\LARGE };

\node[state]			   (v7) [left of =vi] {};
\node[state]			   (v7o) [above=.5cm of v7] {};
\node[state]			   (v6i) [above=.5cm of v6] {};

\node[state]			   (v5) [left of =v6] {};
\node[state]			   (v5o) [below=.5cm of v5] {} (v5i)
        (vio') edge node [swap] {\scriptsize } (vii)
        (vio) edge node {\scriptsize } (v5i)
        (v5o) edge [line width=1mm] node {\scriptsize } (v6i)
        (v6o) edge [line width=1mm] node {\scriptsize } (v7i)
        (v7o) edge [line width=1mm] node {\scriptsize } (v6i)
        (v6o) edge [line width=1mm] node {\scriptsize } (v7o)
        (v7i) edge node {\scriptsize };
\node[state]			   (v7i) [below=.5cm of v7] {};

\node[state]			   (v6) [left of =v7] {};
\node[state]			   (v6o) [below=.5cm of v6] {};
\node[state]			   (v5i) [above=.5cm of v5] {};


\node[state, draw=none]	   (vi') [left of =v5]				{\LARGE };
\node[state, draw=none]	   (vii') [above=.37cm of vi']	{\LARGE };
\node[state, draw=none]	   (vio') [below=.37cm of vi']	{\LARGE };





\path   (vii') edge node {\scriptsize } (v5o)
		  (v7o) edge node {\scriptsize } (v7i)
			
        (v5) edge [line width=1mm] node {\scriptsize } (v5)

        (v6) edge [line width=1mm] node {\scriptsize } (v6)

        (v7) edge [line width=1mm] node {\scriptsize } (v7)

        (v5i) edge [line width=1mm] node {\scriptsize } (v5o)

        (v6i) edge node {\scriptsize } (v6o);


\end{tikzpicture}
\caption{Pattern `'}
\label{fig:pat2}
\end{minipage}
\end{figure}

\begin{figure}[h]
\centering
\begin{tikzpicture}[-,>=stealth', auto, transform shape, node distance=2.5cm, scale=0.8,
                    semithick, every state/.style={fill=none,draw=black,text=black,shape=circle,scale=0.3}]



\node[state]	   (vi) 								{\phantom{\LARGE }};
\node[state]	   (vii) [above=.5cm of vi]	{\phantom{\LARGE }};
\node[state]	   (vio) [below=.5cm of vi]	{\phantom{\LARGE }};

\node[state]	   (viinv) 	[right of =vi]				{\phantom{\LARGE }};
\node[state]	   (viiinv) [above=.5cm of viinv]	{\phantom{\LARGE }};
\node[state]	   (vioinv) [below=.5cm of viinv]	{\phantom{\LARGE }};

\node[state, draw=none]	   (viinv2) 	[right of =viinv]			{\LARGE };
\node[state, draw=none]	   (viiinv2) [above=.5cm of viinv2]	{\LARGE };
\node[state, draw=none]	   (vioinv2) [below=.5cm of viinv2]	{\LARGE };

\node[state]			   (v7) [left of =vi] 		{\phantom{\LARGE }}; 
\node[state]			   (v7i) [below=.5cm of v7] {\phantom{\LARGE }}; 
\node[state]			   (v7o) [above=.5cm of v7] {\phantom{\LARGE }}; 

\node[state]			   (v6) [left of =v7] 			{\phantom{\LARGE }}; 
\node[state]			   (v6i) [above=.5cm of v6] {\phantom{\LARGE }}; 
\node[state]			   (v6o) [below=.5cm of v6] {\phantom{\LARGE }}; 

\node[state]			   (v5) [left of =v6] 		  {\phantom{\LARGE }};  
\node[state]			   (v5i) [above=.5cm of v5] {\phantom{\LARGE }};    
\node[state]			   (v5o) [below=.5cm of v5] {\phantom{\LARGE }};    

\node[state]			   (v4) [left of =v5] 		 {\phantom{\LARGE }};    
\node[state]			   (v4i) [below=.5cm of v4] {\phantom{\LARGE }};     
\node[state]			   (v4o) [above=.5cm of v4] {\phantom{\LARGE }};     

\node[state]			   (v3) [left of =v4] 			{\phantom{\LARGE }};      
\node[state]			   (v3i) [above=.5cm of v3] {\phantom{\LARGE }};      
\node[state]			   (v3o) [below=.5cm of v3] {\phantom{\LARGE }};      

\node[state]			   (v2) [left of =v3]		  {\phantom{\LARGE }};       
\node[state]			   (v2i) [below=.5cm of v2] {\phantom{\LARGE }};         
\node[state]			   (v2o) [above=.5cm of v2] {\phantom{\LARGE }};         

\node[state]	   (vi') [left of =v2]			 {\phantom{\LARGE }};       
\node[state]	   (vii') [above=.5cm of vi']	{\phantom{\LARGE }};         
\node[state]	   (vio') [below=.5cm of vi']	{\phantom{\LARGE }};         

\node[state]	   (vi'inv) 	[left of =vi']			 {\phantom{\LARGE }};       
\node[state]	   (vii'inv) [above=.5cm of vi'inv]	{\phantom{\LARGE }};         
\node[state]	   (vio'inv) [below=.5cm of vi'inv]	{\phantom{\LARGE }};         

\node[state, draw=none]	   (vi'inv2) 	[left of =vi'inv]			 {\LARGE };       
\node[state, draw=none]	   (vii'inv2) [above=.5cm of vi'inv2]	{\LARGE };         
\node[state, draw=none]	   (vio'inv2) [below=.5cm of vi'inv2]	{\LARGE };         

\node[state]				 (cj) [below=2cm of ]  {} (v2o)
        (vio') edge node [swap] {\scriptsize } (vii)
        (vio) edge node {\scriptsize } (vii)
        (vi) edge node {\scriptsize } (viiinv)
        (viinv) edge node {\scriptsize } (vii')
        (vi') edge node {\scriptsize } (vii'inv)
        (vi'inv) edge node {\scriptsize } (viiinv)
        (vio) edge node {\scriptsize } (vii'inv)
        (vio') edge node {\scriptsize } (viiinv2)
        (vioinv) edge node {\scriptsize } (vii'inv2)
        (vio'inv) edge node {\scriptsize } (v2i)
        (v2o) edge node {\scriptsize } (v3i)
        (v3o) edge node {\scriptsize } (v4i)
        (v4o) edge node {\scriptsize } (v5i)
        (v5o) edge node {\scriptsize } (v6i)
        (v6o) edge node {\scriptsize } (v7i)
        (v7o) edge node {\scriptsize } (v3o)
        (v3i) edge node {\scriptsize } (v4o)
        (v4i) edge node {\scriptsize } (v5o)
        (v5i) edge node {\scriptsize } (v6i)
        (v6o) edge node {\scriptsize } (v7o)
        (v7i) edge node {\scriptsize } (cj.north west)
        (cj.north east) edge node [swap] {\scriptsize v \in \bigcup_{i \in \{1, \ldots, m\}} \{\mathit{pvt}_i^L, \mathit{pvt}_i^R\} \bigcup_{i \in \{1, \ldots, m\}} \{\mathit{pvt}_i^L, \mathit{pvt}_i^R\} 
2 (3m+1)l + l \leq \mathit{dur}(v \leadsto v') \leq 2 (3m+2)l + l + 2h.
};
\node[state, draw=none]			   (v3i) [above=.25cm of v3] {};

\node[state, draw=none]			   (v2) [left of =v3] {};
\node[state, draw=none]			   (v2o) [above=.25cm of v2] {};
\node[state, draw=none]			   (v1i) [above=.25cm of v1] {};

\node[state]			   (v0) [left=1cm of v1] {};
\node[state]			   (v0o) [below=.4cm of v0] {};
\node[state]				(vb1)	[below right=1cm and 1.25cm of v2] {};
\node[state, draw=none]			   (v5i) [below=.25cm of v5] {};

\node[state, draw=none]			   (v4) [left of =v5] {};
\node[state, draw=none]			   (v4o) [below=.25cm of v4] {};
\node[state, draw=none]			   (v6i) [above=.25cm of v6] {};

\node[state]			   (v7) [right=1cm of v6] {};
\node[state]			   (v7o) [below=.4cm of v7] {} (v0i.north)
		  (v0i) edge [->, line width=1mm] node {} (v0o)
		  (v7i) edge [->, line width=1mm] node {} (v7o)
		  (v7o.south) edge [->, line width=1mm] node {};
\node[state, draw=none]			   (v3i) [above=.25cm of v3] {};

\node[state, draw=none]			   (v2) [left of =v3] {};
\node[state, draw=none]			   (v2o) [above=.25cm of v2] {};
\node[state, draw=none]			   (v1i) [above=.25cm of v1] {};

\node[state]			   (v0) [left=1cm of v1] {};
\node[state]			   (v0o) [below=.4cm of v0] {};
\node[state]				(vb1)	[below right=1cm and 1.25cm of v2] {};
\node[state, draw=none]			   (v5i) [below=.25cm of v5] {};

\node[state, draw=none]			   (v4) [left of =v5] {};
\node[state, draw=none]			   (v4o) [below=.25cm of v4] {};
\node[state, draw=none]			   (v6i) [above=.25cm of v6] {};

\node[state]			   (v7) [right=1cm of v6] {};
\node[state]			   (v7o) [below=.4cm of v7] {} (v7i.north)
		  (v0i) edge [->, line width=1mm] node {} (v0o)
		  (v7i) edge [->, line width=1mm] node {} (v7o)
		  (v0o.south) edge [->, line width=1mm] node {};
\node[state]				(v0l)	[left=2cm of v0] {};
\node[state]				(v0r)	[right=2cm of v0] {};
\node[state]				(v1)	[below=2cm of v0] {};
\node[state]				(v2)	[below=2cm of v1] {};
\node[state]				(v2l)	[left=2cm of v2] {};
\node[state]				(v2r)	[right=2cm of v2] {};
\node[state]				(v3)	[below=2cm of v2] {};
\node[state]				(v4)	[below=2cm of v3] {};
\node[state]				(v4l)	[left=2cm of v4] {};
\node[state]				(v4ll)	[left=2cm of v4l] {};
\node[state]				(v4r)	[right=2cm of v4] {};
\node[state]				(v4rr)	[right=2cm of v4r] {};

\node[state]				(vb)	[below=2cm of v4] {};

\node[state]				(vm)	[right=11cm of v2] {};


\node [xshift=3mm] at (vm.east) {\small };
\node [yshift=3mm] at (vt.north) {\small };
\node [yshift=-3mm] at (vb.south) {\small };


\path   (vm) edge node [swap, pos=0.4] {\small } (vt)
		  (vm) edge node [pos=0.4] {\small } (vb)
		  (vt) edge (v0l)
		  (vt) edge (v0r)
		  (v0l) edge (v1)
		  (v0r) edge (v1)
		  (v1) edge (v2l)
		  (v1) edge (v2)
		  (v1) edge (v2r)
		  (v2l) edge (v3)
		  (v2)  edge (v3)
		  (v2r) edge (v3)
		  (v3) edge (v4ll)
		  (v3) edge (v4l)
		  (v3) edge (v4)
		  (v3) edge (v4r)
		  (v3) edge (v4rr)
		  (v4ll)  edge (vb)
		  (v4l)   edge (vb)
		  (v4)    edge (vb)
		  (v4r)   edge (vb)
		  (v4rr)  edge (vb)
;

\end{tikzpicture}
\caption{The instance }
\label{fig:prime}
\end{figure}

(\emph{Sketch.}) See Figure~\ref{fig:prime} for an illustrated example where .
The -th `diamond' (in top-down order) has  branches where  is the -th prime.
The relative deadlines are set as indicated, each unlabelled edge has  set to , and
each missing edge has  set to the `shortest distance' between the two relevant vertices.
It can be shown that a solution must be an infinite repetition of either (i) from  through all the diamonds to , to
 and to  again, or (ii) from  through all the diamonds to , to  and to  again.
Furthermore, in each diamond one must go straight down, and only the edges shown in the figure can be used.
It can be shown that the shortest period of a solution to  is bounded below by .
On the other hand, the number of vertices and the largest constant in  are both .
\end{proof}


\section{Proof of Proposition~\ref{prop:tborbt}}\label{app:tborbt}

\begin{lemma}\label{lem:toporbot}
Each segment  must start with and end with  or .
\end{lemma}


\begin{lemma}\label{lem:atleast3mp1}
The time needed from  or  to any other vertex is at least .
\end{lemma}


\begin{lemma}\label{lem:atleast14t}
The time needed from  to any other vertex is at least .
\end{lemma}


\begin{lemma}\label{lem:segmorethanone}
Each segment  must contain more than one vertex.
\end{lemma}
\begin{proof}
By Lemma~\ref{lem:toporbot}, without loss of generality let , a single vertex. It is easy to see
that  must end with  and  must start with , otherwise
the relative deadline of  will be violated. Now consider  (with ).
By Lemma~\ref{lem:atleast3mp1} and the fact that ,
the relative deadline of  is violated for sure even if  visits 
immediately after . This is a contradiction.
\end{proof}

\begin{proposition}\label{prop:bound}
For each segment , .
\end{proposition}
\begin{proof}
By Lemma~\ref{lem:segmorethanone} we have .
For the upper bound, note that 
and .
\end{proof}

\begin{proposition}\label{prop:leastonce}
Each segment  contains all vertices in  with relative deadlines less or equal than .
\end{proposition}
\begin{proof}
Let  be a vertex missing in  with 
. By Lemmas~\ref{lem:toporbot},~\ref{lem:atleast3mp1} and~\ref{lem:segmorethanone},
.
We have .
By Lemma~\ref{lem:atleast14t},  must be greater than 
for any , which is a contradiction.
\end{proof}

By Proposition~\ref{prop:leastonce}, we first derive a (crude) lower bound on .
The sum of the minimum times needed to enter and leave every  and
the minimum times needed to enter and leave both ends of  gives


\begin{proposition}\label{prop:tbonce}
,  and each  appears once in each segment .
\end{proposition}
\begin{proof}
Without loss of generality, assume one of these vertices appears more than once in .
By a similar argument as above, we derive that  is at least .
This contradicts Proposition~\ref{prop:bound}.
\end{proof}

By the proposition above, we can revise our lower bound in Eq.(\ref{eq:eq1}) by noting that
 must start and end with different vertices. This gives


Now without loss of generality let  ends with  and  starts with .
By Eq.(\ref{eq:eq2}),
,
and hence .
By Proposition~\ref{prop:tbonce},  can only appear at both ends of ,
hence its relative deadline must be violated. This is a contradiction. Proposition~\ref{prop:tborbt} is hence proved.

\section{Proof of Proposition~\ref{prop:exact}}\label{app:cnt}


Now we refine our lower bound in Eq.(\ref{eq:eq2}) by taking into account other vertices in variable gadgets
and consistency gadgets with  less or equal to  (by Proposition~\ref{prop:leastonce}).
As many of these vertices are adjacent, we only accumulate the minimum times needed to enter them.
This gives an extra time of  (note that by Proposition~\ref{prop:tbonce},
only one of the four vertices connected to a shared vertex has been entered and cannot be included
in the calculation). In total, we have

 
\begin{proposition}\label{prop:32once}
Each segment  contains all vertices with relative deadlines equal to , i.e.,
clause vertices and vertices in
.
\end{proposition}
\begin{proof}
Assume that there is such a vertex  not appearing in .
By Eq.(\ref{eq:eq3}), we have .
By Lemma~\ref{lem:atleast3mp1}, the relative deadline of  must be violated as
. 
This is a contradiction.
\end{proof}

Based on the previous proposition, we can further refine our lower bound on the duration of a segment.
The minimum times needed to enter
\begin{itemize}
\item clause vertices , 
\item vertices in 
\end{itemize}
can now be included in the calculation. We have

\begin{proposition}\label{prop:pivotmoreonce}
In each segment , each vertex in  appears more than once.
\end{proposition}
\begin{proof}
Let there be such a vertex  appearing only once in a segment.
By Lemma~\ref{lem:atleast3mp1}, there are two occurrences of  in  separated by at least
.
This exceeds all possible values of .
\end{proof}

By the proposition above, we assume that each vertex in  appears twice in a segment.
Counting each such vertex once again gives an extra time of . The sum of this with Eq.(\ref{eq:eq4})
matches the upper bound in Proposition~\ref{prop:bound}.
Any more visit to a vertex in 
will immediately contradict Proposition~\ref{prop:bound}. Proposition~\ref{prop:exact} is hence proved.


\end{document}
