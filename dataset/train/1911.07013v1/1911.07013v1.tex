

\documentclass{article}
\usepackage[final]{neurips_2019}



\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      

\usepackage{times}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{array}
\usepackage{multirow}
\usepackage{color,soul}
\usepackage{makecell}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{mathtools}

\newtheorem{thm}{Theorem}[]


\newcommand*{\affaddr}[1]{#1} \newcommand*{\affmark}[1][*]{\textsuperscript{#1}}
\newcommand*{\email}[1]{\texttt{#1}}
\newcommand*{\vect}[1]{\textbf{#1}}


\title{Understanding and Improving Layer Normalization}


\author{
Jingjing Xu\affmark[1], \ 
Xu Sun\affmark[1,2]\thanks{Corresponding author.}, \ 
Zhiyuan Zhang\affmark[1], \ 
Guangxiang Zhao\affmark[2], \
Junyang Lin\affmark[1] \
\\ 
\affmark[1] MOE Key Lab of Computational Linguistics, School of EECS, Peking University  \\
\affmark[2] Center for Data Science, Peking University \\
\footnotesize \email{\{jingjingxu,xusun,zzy1210,zhaoguangxiang,linjunyang\}@pku.edu.cn }\\
}
\date{}

\begin{document}
\maketitle


\begin{abstract}

Layer normalization (LayerNorm) is a technique to normalize the distributions of intermediate layers.
It enables smoother gradients, faster training, and better generalization accuracy. 
However, it is still unclear where the effectiveness stems from.
In this paper, our main contribution is to take a step further in understanding LayerNorm.  Many of previous studies believe that the success of LayerNorm comes from  forward normalization. Unlike them, we find that the derivatives of the mean and variance are more important than forward normalization by re-centering and re-scaling backward gradients. Furthermore, we find that the parameters of LayerNorm, including the bias and gain, increase the risk of over-fitting and do not work in most cases. Experiments show that a simple version  of LayerNorm (LayerNorm-simple) without the bias and gain outperforms LayerNorm on four datasets. It obtains the state-of-the-art performance on En-Vi machine translation. 
To address the over-fitting problem, we propose a new normalization method, Adaptive Normalization (AdaNorm), by replacing the bias and gain with a new transformation function. Experiments show that AdaNorm demonstrates better results than LayerNorm  on seven out of eight datasets. 






\end{abstract}

\section{Introduction}





Neural network training has long been a focus in Deep Learning research area. 
One of the prominent progress is the application of normalization methods. 
Initially, \citet{ioffe2015batch} introduce the concept of normalizing layers with the proposed Batch Normalization (BatchNorm). It is widely believed that by controlling the mean and variance of layer inputs across mini-batches, BatchNorm stabilizes the distribution and improves training efficiency. 
Following this work, \citet{lei2016layer} point out its limitation in Recurrent Neural Networks (RNN) and propose Layer Normalization (LayerNorm) that is performed across the neurons in a layer.
LayerNorm is adaptive to RNN and self-attention-based models. 
A typical example is its application in the state-of-the-art framework, Transformer~\citep{DBLP:conf/nips/VaswaniSPUJGKP17}.
LayerNorm enables faster training of Transformer and is irreplaceable in this framework. 

Despite its great success, it is still unclear why LayerNorm is so effective. 
The widely accepted explanation is that forward normalization brings distribution stability~\citep{ioffe2015batch, lei2016layer}. Recent studies show that the effects of BatchNorm are not related to the stability of input distribution~\citep{zhang2016understanding,santurkar2018does}. 
They also propose that the reason why BatchNorm is effective is that normalization smooths the optimization landscape. 
However, it is still unclear whether these theories can explain the success of LayerNorm. 


The main contribution of this paper is to explore how LayerNorm works.
Through a series of analyses, we find that the derivatives of the mean and variance are important by re-centering and re-scaling backward gradients. Furthermore, it is beyond our expectation that the bias and gain do not work in most cases. The details of our findings are illustrated below.


\textbf{The derivatives of the mean and variance are more important to LayerNorm than forward normalization.} Many of the previous studies believe that the forward normalization is the only decisive factor to LayerNorm. It makes the input distribution more stable, thus brings better convergence. Unlike them, our experimental results show that forward normalization has little to do with the effectiveness and  the derivatives of the mean and variance play a significant role in LayerNorm. To illustrate how these derivatives work, we propose DetachNorm, which adds an additional detaching operation to LayerNorm to change the mean and variance from variables to constants.
It preserves the re-centering and re-scaling fact but cuts off the derivative of the mean and variance with respect to the input.
DetachNorm performs worse than LayerNorm on six out of eight datasets.
This proves that the derivatives of the mean and variance are useful to LayerNorm. 
Furthermore, to investigate the reason for the above observation, we analyze the gradients in LayerNorm and DetachNorm, and find that the derivatives of means re-center gradients and the derivatives of variances re-scale gradients.
 

\textbf{The parameters of LayerNorm, including the bias and gain, increase the risk of over-fitting and do not work in most cases.} The bias and gain are applied for affine transformation on normalized vectors. They are expected to enhance the expressive power by re-shaping the distribution.  To evaluate their effects on results, we build a simple version of LayerNorm (LayerNorm-simple) by removing the bias and gain.
Our experimental results show that LayerNorm-simple achieves better results than LayerNorm on four datasets. It even achieves the state-of-the-art performance on En-Vi machine translation.   By comparing loss curves of LayerNorm with and without the bias and gain, we find that the bias and gain cause over-fitting. 
We speculate the reason of over-fitting is mainly that the bias and gain are learned from the training set and cannot adjust themself towards different input distributions when testing.


Motivated by this assumption, we propose a novel normalization method,  Adaptive Normalization (AdaNorm). AdaNorm replaces the bias and gain with a new transformation function. This function adaptively adjusts scaling weights based on input values. 
We evaluate AdaNorm and LayerNorm on eight datasets, covering tasks of machine translation, language modeling, text classification, image classification, and dependency parsing.  Results show that AdaNorm achieves better results on seven datasets. 



\section{Preliminaries}
In this section, we first review the algorithm of LayerNorm and then introduce the datasets and models used in the following analysis sections. 

\subsection{LayerNorm Algorithm}
Let  be the vector representation of an input of size  to normalization layers. LayerNorm re-centers and re-scales input  as

where  is the output of a LayerNorm layer.  is a dot production operation.  and  are the mean and standard deviation of input. 
Bias  and gain  are parameters with the same dimension .  

\subsection{Experimental Setup}

To investigate how LayerNorm works, we conduct a series of experiments in this paper. 
Since LayerNorm is a default setting in Transformer~\citep{DBLP:conf/nips/VaswaniSPUJGKP17} and Transformer-XL~\citep{dai2019transformer}, which have shown state-of-the-art results on a variety of tasks (e.g., machine translation), we primarily consider normalization on Transformer and Transformer-XL networks. 
Also, 
to avoid the impact of model architecture, 
we evaluate the effects of normalization on feed-forward neural networks and convolutional neural networks. Here list the datasets and models. More details can be found at the Appendix.

\textbf{Machine translation} includes three widely-used datasets,  WMT English-German (En-De), IWSLT 14 German-English (De-En)~\citep{cettolo2014iwslt} and IWSLT 15 English-Vietnamese (En-Vi)~\citep{cettolo2015iwslt}.  For all dataset, 
we use the setting of PreNorm where normalization is applied before each layer.   We re-implement Transformer with the released code of Fairseq~\citep{ott2019fairseq}\footnote{https://github.com/pytorch/fairseq}. 
The evaluation metric is BLEU~\citep{DBLP:conf/acl/PapineniRWZ02}. 
  
  
For En-De dataset, we use the same dataset splits and the same compound splitting following previous work~\citep{DBLP:conf/nips/VaswaniSPUJGKP17}. BPE is used to get vocabularies. We use the shared embedding setting and the vocabulary size is 32,765. We use ``transformer\_wmt\_en\_de\_big\_t2t'' as our basic model.   The dropout rate is 0.3. The learning rate is 0.001. The training batch size is  4,096 tokens. We use optimizer Adam with  and .  The number of warmup steps is 4K. 



The De-En dataset is provided by the IWSLT 2014 Evaluation Campaign.  We use the same dataset splits following previous work~\citep{ott2019fairseq,DBLP:journals/corr/RanzatoCAZ15,DBLP:conf/emnlp/WisemanR16}. It contains 153K sentences for training, 7K sentences for validation, and 7K sentences for testing. BPE is used to get vocabularies. We use the shared embedding setting and the vocabulary size is 10,149. We use ``transformer\_iwslt\_de\_en'' as our basic model.  The dropout rate is 0.3. The attention dropout rate is  0.1. The activation dropout is 0.1. The initialization learning rate is 1e-07 and the learning rate is 0.0015. The training batch size is  4,096 tokens. We  update gradients for every 2 steps. The number of warmup steps is 8K. 


  The En-Vi dataset contains 133K training sentence pairs provided by the IWSLT 2015 Evaluation Campaign. We use TED
tst2012 (1,553 sentences) as the validation set  and TED tst2013 (1,268 sentences) as the test set. BPE is used to get input and output vocabularies. The English and Vietnamese vocabulary sizes are 7,669 and 6,669 respectively.  The dropout rate is 0.1. The learning rate is 0.001. The training batch size is  4,096 tokens. The number of warmup steps is 8K. We use ``transformer\_wmt\_en\_de'' as our basic model. We use optimizer Adam with  and . 







 \textbf{Language modeling} includes a large dataset, Enwiki8\footnote{http://mattmahoney.net/dc/text.html} that contains 100M bytes of unprocessed Wikipedia text. 
We implement a  12-layer Transformer-XL model. The dimension of each layer is 512. Multi-head attention contains 8 heads and the dimension of each head is 64. The dropout rate is 0.1. The batch size is 22. We use optimizer Adam with a learning rate 0.00025. 
We use the average number of Bits-Per-Character (BPC) as the evaluation metric~\citep{DBLP:journals/corr/abs-1808-04444,dai2019transformer}.  

 \textbf{Text classification} includes two sentence classification datasets:  RT~\citep{PangLee}, and SST5~\citep{socher2013recursive}. RT is a binary  sentiment classification dataset from online movie reviews. We randomly divide all examples into 8,608 for training, 964 for validation, and 1,089 for testing.  SST5 is a single-sentence classification dataset built on movie reviews.  We run experiments on a five label set.   We build a Transformer model with a 4-layer encoder. The batch size is 4,096 tokens. The word embedding dimension is 128 and the hidden dimension is 128. The dropout rate is 0.2.   We use  optimizer Adam with  = 0.9,   = 0.998. Normalization is applied before each layer. Accuracy is the evaluation metric. 


 \textbf{Image classification} includes a widely-used dataset, MNIST~\citep{lecun1998gradient}. It consists of 55,000 training images, 5,000 validation images, and additional 10,000 testing images.  We implement a 3-layer convolutional neural network for classification. The first 2D-convolution layer has 1 in-channel, 20 out-channels. The second 2D-convolution layer has 20 in-channels, 50 out-channels. We flatten the output of the second 2D-convolution layer and send it to a linear layer. The batch size is  . We use  optimizer Adam with a learning rate of . We apply LayerNorm before the activation in every linear layer. We train the model for  epochs.  Normalization is applied before each layer. Accuracy is the evaluation metric.  
 
 
\textbf{Dependency parsing} includes a dataset, English Penn TreeBank (PTB)~\citep{DBLP:journals/coling/MarcusSM94}.  We follow the standard split of the corpus with sections 2-21 as the training set (39,832 sentences, 1,900,056 transition examples), section 22 as the validation set (1,700 sentences, 80,234 transition examples), and section 23 as the testing set (2,416 sentences, 113,368 transition examples). We implement a  MLP-based parser following the work~\citep{DBLP:conf/emnlp/ChenM14}.   The dimension of the hidden state is , the batch size is , the dropout rate is . We use optimizer Adam and initialize the learning rate to . We apply normalization before activation in every linear layer.  Following the work~\citep{DBLP:conf/emnlp/ChenM14}, we use  Unlabeled Attachment Score (UAS) as the evaluation metric. 





  
  



  
\section{Understanding LayerNorm}
To investigate how LayerNorm facilitates training, we conduct ablation studies to
observe each part's contribution to the performance. In this section, we analyse the effects of the bias and gain, forward normalization, and backward normalization.


\begin{table}[h]
\small
\setlength{\tabcolsep}{2.5pt}
\centering
\caption{ The bias and gain do not work on six out of eight datasets.  ``w/o Norm'' is a naive model without LayerNorm. ``LayerNorm-simple'' is a variant of LayerNorm that drops the bias and gain. ``(+)'' means higher is better. ``(-)'' means lower is better. }
  \scalebox{0.95}
    {
 \begin{tabular}{c|ccc|c|ccc|c}
  \toprule  \multirow{2}{*}{Models}&\multicolumn{3}{c|}{Machine Translation} &\multicolumn{1}{c|}{Language Modeling} &\multicolumn{3}{c|}{ Classification}  & Parsing  \\
  \cmidrule{2-9}
 & En-De(+) & De-En(+) & En-Vi(+) & Enwiki8(-) & RT(+)  & SST5(+) &  MNIST(+) & PTB(+) \\
    \midrule   Model Layers  & 12 & 12 & 12 & 12 & 4 & 4 & 3 & 3\\
   \midrule   w/o Norm  &Diverge & 34.0 & 28.4 & \textbf{1.04} & 76.85 & 38.55 & \textbf{99.14} &88.31\\ 
  LayerNorm  & 28.3 & \textbf{35.5} &  31.2& 1.07 & \textbf{77.21} & 39.23   & 99.13 & 89.12\\
  


  LayerNorm-simple  & \textbf{28.4} & \textbf{35.5} & \textbf{31.6} &1.07 & 76.66 & 
  \textbf{40.54} & 99.09 & \textbf{89.19}\\



  \bottomrule \end{tabular}}
  
  \label{tab:bias}
  \end{table}


\subsection{The Effect of the Bias and Gain in LayerNorm }
The bias and gain do not work in most cases. From Table~\ref{tab:bias},
it can be found that LayerNorm is an effective approach. It brings large performance improvements on six out of eight datasets compared with the naive baseline without LayerNorm (``w/o Norm''). By comparing LayerNorm and LayerNorm-simple, we find that dropping the bias and gain (``LayerNorm-simple'') does not  decrease the performance on six datasets. Surprisingly, LayerNorm-simple  outperforms LayerNorm on four datasets, even with a 0.4 BLEU improvement on En-Vi and a 1.31 ACC improvement on SST-5. Also, it needs to notice that 31.6 achieved by LayerNorm-simple is the state-of-the-art result on En-Vi machine translation. 



Furthermore, we find that the bias and gain increase the risk of over-fitting. 
Initially, considering that input information may be lost when normalizing input distributions, the bias and gain are designed for affine transformation on normalized vectors to enhance the expressive power. However, since the bias and gain are learned from the training set and they ignore the input distributions of the testing data, the risk of over-fitting may increase in LayerNorm.
It is verified by convergence curves in Figure~\ref{fig:wb}. 
LayerNorm achieves lower training loss (or BPC) but higher validation loss (or BPC) than LayerNorm-simple on En-Vi, Enwiki8.  These results indicate that current affine transformation mechanism has a potential risk of over-fitting and needs to be further improved. 


  
\begin{figure}[ht]
\centering
\small
\begin{minipage}{.4\textwidth}
  \centering
  \includegraphics[width=\linewidth]{En-Vi-wb.pdf}
\end{minipage}\begin{minipage}{.4\textwidth}
  \centering
  \includegraphics[width=\linewidth]{Enwiki8-wb.pdf}
\end{minipage}

\caption{Convergence curves of LayerNorm and LayerNorm-simple on En-Vi, Enwiki8. Lower is better. The bias and gain increase the risk of over-fitting. }

 \label{fig:wb}
 \vspace{-0.1in}
\end{figure}





  


\subsection{The Effect of Forward Normalization}








 
For easier analysis, we only consider LayerNorm without the bias and gain here. Let  be the normalized vector, the calculation process of LayerNorm without the bias and gain can be written as

where  is the input vector and  is the dimension of .  and  are the mean and standard deviation of . Then, suppose  and  are the mean and variance of . It is easy to verify 

Eq.~(\ref{mean}) shows that normalization re-centers and re-scales input vector~. By now,  a widely accepted belief is that the effectiveness of LayerNorm comes from steady layer distributions brought by forward normalization~\citep{lei2016layer}.
To evaluate whether forward normalization explains the effectiveness of LayerNorm, we need to separate the effect on forward layer inputs and that on backward gradients. In this paper, we design a new method, called DetachNorm. The difference between LayerNorm and DetachNorm is that DetachNorm detaches the derivatives of the mean and variance\footnote{In our implementation, we detach the derivative of standard deviation, the square root of variance. }. Detaching  derivatives means treating the mean and variance as changeable constants, rather than variables, which do not require gradients in backward propagation.   The calculation of DetachNorm can be written as 

where  and  are the mean and standard deviation of input , as calculated in Eq.~(\ref{lay}). The function  can be seen as a special copy function, which copies the values of  and  into constants   and . In all, DetachNorm keeps the same forward normalization fact as LayerNorm does, but cuts offs the derivatives of the mean and variance. 



\begin{table}[t]
\small
\setlength{\tabcolsep}{3pt}
\centering
\caption{ The derivatives of the mean and variance matter. ``w/o Norm'' is the naive model without normalization. ``DetachNorm'' is a variant of ``LayerNorm-simple''. It detaches the derivatives of the mean and variance. 
``(+)'' means higher is better. ``(-)'' means lower is better. The top table shows the effect of forward normalization. The bottom table shows the effect of the derivatives of the mean and variance. }
  \scalebox{0.95}
    {
 \begin{tabular}{c|ccc|c|ccc|c}
  \toprule  \multirow{2}{*}{Models}&\multicolumn{3}{c|}{Machine Translation} &\multicolumn{1}{c|}{Language Modeling} &\multicolumn{3}{c|}{ Classification}  & Parsing  \\
  \cmidrule{2-9}
 & En-De & De-En(+) & En-Vi(+) & Enwiki8(-) & RT(+)  & SST5(+) & MNIST(+) & PTB(+) \\
    \midrule   Model Layers &12 & 12 & 12 & 12 & 4 & 4 & 3 & 3\\
   \midrule   w/o Norm  & Diverge & \textbf{34.0} & \textbf{28.4} & \textbf{1.04} & \textbf{76.85} & 38.55 &\textbf{99.14} &88.31\\
\midrule
  DetachNorm & Diverge &33.9 & 27.7 & 1.12 & 76.40 &  \textbf{40.04}&99.10&\textbf{89.79}\\
  Improvement & -- &-0.1 &-0.7  & -0.08 & -0.45 & 1.49  & -0.04 & \textbf{1.48} \\
  
  \bottomrule
  \bottomrule
  \multirow{2}{*}{Models}&\multicolumn{3}{c|}{Machine Translation} &\multicolumn{1}{c|}{Language Modeling} &\multicolumn{3}{c|}{ Classification}  & Parsing  \\
  \cmidrule{2-9}
&En-De & De-En(+) & En-Vi(+) & Enwiki8(-) & RT(+)  & SST5(+)  & MNIST(+) & PTB(+) \\
    \midrule   Model Layers  &12& 12 & 12 & 12 & 4 & 4 & 3 & 3\\
\midrule 
DetachNorm & Diverge & 33.9 & 27.7 & 1.12 &76.40 & 40.04&\textbf{99.10}&\textbf{89.79}\\
\midrule
  LayerNorm-simple  & \textbf{28.4} & \textbf{35.5} &\textbf{31.6} &\textbf{1.07} & \textbf{76.66} & \textbf{40.54} & 99.09 & 89.19\\
  Improvement & -- &\textbf{1.6} & \textbf{3.9} & \textbf{0.05} & \textbf{0.26} & \textbf{0.50}&  -0.01 & -0.60 \\  
  \bottomrule \end{tabular}}
\label{tab:detach}
  \end{table}
  



Since DetachNorm keeps the same re-centering  and re-scaling way in forward propagation as LayerNorm-simple does, the gap between DetachNorm and  ``w/o Norm''  shows the effect of forward normalization. As we can see, DetachNorm perform worse than ``w/o Norm'', showing that forward normalization has little to do with the success of LayerNorm. 

Furthermore, the only difference between DetachNorm and LayerNorm-simple lies in that DetachNorm detaches the derivatives of the mean and variance. As shown in Table~\ref{tab:detach}, DetachNorm performs worse than LayerNorm-simple on six datasets. It is mainly because that DetachNorm converges to  much worse local optima compared with LayerNorm-simple, as shown in Figure~\ref{fig:detach}. The gap between DetachNorm and LayerNorm-simple shows the effectiveness of the derivatives of the mean and variance.  By comparing the achieved improvements, we find that the derivatives of the mean and variance bring higher improvements than forward normalization does.


\begin{figure}[t]
\centering
\small
\begin{minipage}{.4\textwidth}
  \centering
  \includegraphics[width=\linewidth]{de-en-detach.pdf}

  
\end{minipage}\begin{minipage}{.4\textwidth}
  \centering
  \includegraphics[width=\linewidth]{en-vi-detach.pdf}
\end{minipage}

\caption{Convergence curves of LayerNorm-simple and DetachNorm on two translation datasets. }


 \label{fig:detach}
\end{figure}
These results demonstrate that the derivatives of the mean and variance play a significant role. In addition, the extremely worse results of DetachNorm on En-De, De-En and En-Vi indicate that the derivatives of the mean and variance may be more important for deeper models. In the following section, we will give a detailed analysis of why and how the derivatives of the mean and variance contribute to the performance. 
















\subsection{The Effect of the Derivatives of the Mean and Variance}
To understand how the derivatives of the mean and variance work, we analyze the gradients of LayerNorm-simple and DetachNorm. According to the chain rule, the gradient of  is\footnote{When calculating the gradient, we adopt the denominator layout.}
where  is the loss function,  is the input vector and  is the normalized vector. We here analyze the effect of detaching the derivatives of the mean and variance on backward gradients. Our results are summarized in the following theorem, whose proof is listed in 
the Appendix.

\begin{thm}
\label{thm1}
Given , let  and  be the mean and variance of .  For the case of detaching the derivatives of  and ,  suppose  is the gradient of  with mean   and variance . 
We have   and .


\quad (1) For the case of standard LayerNorm-simple, suppose  is the gradient of  with mean  and variance . 
\begin{center}
We have  and .  
\end{center}

 \quad(2) For the case of detaching the derivative of , suppose  is the gradient of  with mean  and variance .
\begin{center}
We have  and .
\end{center}
 \quad(3) For the case of detaching the derivative of , suppose  is the gradient of  with mean  and variance . 
\begin{center}
We have  and .
\end{center}

\end{thm}

By comparing the case of detaching the derivative of  with that of LayerNorm-simple in Theorem~\ref{thm1}, we find that the derivative of  re-centers  to zero. 
By comparing the case of detaching the derivative of  with of LayerNorm-simple, we find that  the derivative of  reduces the variance of , which can be seen a kind of re-scaling.  We refer to gradient re-centering and re-scaling as gradient normalization.




To further evaluate the effect of gradient normalization on model performance, we test the derivatives of the mean and variance separately. Table~\ref{tab:meanorvariance} shows that detaching the derivative of variance decreases the performance significantly on deeper networks. Therefore, it is necessary to control the variance of gradients for deeper networks. 

In conclusion,  LayerNorm normalizes forward layer inputs and backward gradients. The derivatives of the mean and variance play more important roles than forward normalization in LayerNorm. Furthermore, unlike previous work~\citep{santurkar2018does} only noticing that normalization smooths gradients, this paper provides deeper insight about how normalization impacts backward gradients. 

























\begin{table}[h]
\small
\setlength{\tabcolsep}{3pt}
\centering
  \caption{The derivative of variance is more important than that of mean for deeper networks. ``(+)'' means higher is better. ``(-)'' means lower is better. }
  \scalebox{0.95}{
 \begin{tabular}{lccc|c|ccc|c}
  \toprule  \multirow{2}{*}{Models}&\multicolumn{3}{c|}{Machine Translation} &\multicolumn{1}{c|}{Language Model} &\multicolumn{3}{c|}{Classification}&Parsing   \\
 \cmidrule{2-9}
 & En-De(+) & De-En(+) & En-Vi(+) & Enwiki8(-) & RT(+)  & SST5(+) &  MNIST(+) & PTB(+) \\
  \midrule  Model Layers  & 12 & 12 & 12 & 12 & 4 & 4  & 3 & 3\\
    \midrule 
LayerNorm-simple  & \textbf{28.4} &35.5 & \textbf{31.6} &\textbf{1.07} & 76.66 & 40.54 & 99.09 & 89.19\\
  Detach Mean & 28.3 & \textbf{35.6}&31.3 &\textbf{1.07} & 75.02& 40.99& \textbf{99.25} & 89.45\\
  Detach Variance & Diverge &34.2 & 29.8 &1.10&\textbf{77.04} &\textbf{41.74} &99.10 & \textbf{89.80} \\
\bottomrule \end{tabular}}

  \label{tab:meanorvariance}
  \end{table}
 


 




 \section{AdaNorm}
AdaNorm adopts a new transformation function which can adaptively control scaling weights towards different inputs.\footnote{Our code is released at \url{https://github.com/lancopku/AdaNorm}}



 


 
\subsection{AdaNorm Algorithm}
Formally, let    be the normalized vector  where  and  are the mean and variance of the input . We use  , a function with respect to input , to replace the bias and gain with the following equation: 

where  is the output of AdaNorm and  is a dot product operation. Unlike the bias and gain being fixed in LayerNorm,  can adaptively adjust  scaling weights based on  inputs. To keep the stability of training, we expect that  has some features. First,  must be differentiable. Second, we expect that the average scaling weight is fixed, namely the average of  is a constant  where . Third, we expect that the average of  is bounded, which can avoid the problem of exploding loss. Namely, we require that there exists a constant  such that . Theorem~\ref{thm21} proves that there exists a unique solution which can satisfy these requirements. The proof is listed in 
the Appendix.
\begin{thm}
\label{thm21}
Suppose  is derivable, ,  , and  , where  is the hidden size. There exists only one solution:
\begin{center}
   
\end{center}
which can satisfy these requirements.
\end{thm}
Since   will undesirably change the direction of vector, we expect that  holds, which means  must hold. Due to the symmetry of ,  is required to hold too. Based on Chebyshev's Inequality, we have 

where  is the variance of  and  is the dimension of .
Based on Eq. (3), we can verify . If we expect that  holds with a probability higher than ,  should be choose based on Eq.~(\ref{inq}). Namely, we choose

Given an input vector , the complete calculation process of AdaNorm is

where  is a hyper-parameter.  is a dot product operation.   is recommended to set as .  To prevent the introduced term  dismissing the feature of gradient re-centering and re-scaling,  we detach the gradient of    and only treat it as a changeable constant in implementation. 






  





 
\begin{table}[h]
\small
\setlength{\tabcolsep}{3pt}
\centering
  \caption{Results of LayerNorm and AdaNorm. ``(+)'' means higher is better. ``(-)'' means lower is better.  AdaNorm outperforms LayerNorm on  seven datasets.  }
  \scalebox{0.95}{
 \begin{tabular}{lccc|c|ccc|c}
  \toprule  \multirow{2}{*}{Models}&\multicolumn{3}{c|}{Machine Translation} &\multicolumn{1}{c|}{Language Model} &\multicolumn{3}{c|}{Classification}  & Parsing  \\
 \cmidrule{2-9}
 & En-De(+) & De-En(+) & En-Vi(+) & Enwiki8(-)  & RT(+)  & SST5(+)  & MNIST(+)  & PTB(+) \\
  \midrule  

  w/o Norm & Diverge & 34.0 & 28.4 & \textbf{1.04} & 76.85& 38.55 & 99.14 &88.31\\
LayerNorm & 28.3 &35.5 &31.2 & 1.07& 77.21& 39.23 & 99.13  & 89.12\\
LayerNorm-simple & 28.4 & 35.5 & \textbf{31.6} & 1.07 & 76.66& \textbf{40.54}& 99.09 & 89.19 \\
AdaNorm  &\textbf{28.5} &\textbf{35.6} & 31.4 & {1.07} & \textbf{77.50}&  \textbf{40.54}  &  \textbf{99.35}  & \textbf{89.23} \\
\bottomrule \end{tabular}
}
  \label{tab:layercomp}
  \end{table}
  
  
  
\subsection{Comparison between AdaNorm and LayerNorm }
The comparison between LayerNorm and AdaNorm is shown in Table~\ref{tab:layercomp}.\footnote{For AdaNorm implementation, Kaiming initialization  and the setting of prenorm are recommended. } AdaNorm outperforms LayerNorm on seven datasets, with 0.2 BLEU on En-De, 0.1 BLEU on De-En, 0.2 BLEU on En-Vi, 0.29 ACC on RT, 1.31 ACC on SST, 0.22 ACC on MNIST, and 0.11 UAC on PTB. Unlike LayerNorm-simple only performing well on bigger models, AdaNorm achieves more balanced results. Figure~\ref{fig:test2} shows the loss curves of LayerNorm and AdaNorm on the validation set of En-Vi, PTB, and De-En. Compared to AdaNorm, LayerNorm has lower training loss but higher validation loss. Lower validation loss proves that AdaNorm  has better convergence.




\begin{figure}[h]

\centering
\small

\begin{minipage}{0.32\textwidth}
  \centering
  \includegraphics[width=\linewidth]{En-Vi-adanorm.pdf}
\end{minipage}
\begin{minipage}{.32\textwidth}
  \centering
  \includegraphics[width=\linewidth]{PTB-adanorm.pdf}
\end{minipage}
\begin{minipage}{.32\textwidth}
  \centering
  \includegraphics[width=\linewidth]{De-en-adanorm.pdf}
\end{minipage}\caption{Loss curves of LayerNorm and AdaNorm on En-Vi, PTB, and De-En.}

\label{fig:test2}
\end{figure}




 













  





























\section{Related Work}

Deep neural networks have outperformed shallow models in a variety of fields, such as natural language processing~\citep{sutskever2014sequence,bahdanau2014neural, devlin2018bert}, computer vision~\citep{he2016deep,huang2017densely}, etc. The improvement mainly comes from the stronger expressive power of deep layers. However, with the increase of depth, the network training process becomes complicated and requires advanced architectural techniques. One of the important techniques of such advances is normalization.   


Currently, it is widely accepted that normalization layers assist training by smoothing gradients, enabling large learning rates, accelerating convergence, and improving generalization results~\citep{DBLP:journals/corr/abs-1901-09321}. 
First introduced by~\citet{ioffe2015batch}, BatchNorm fixes layer distributions to reduce ICS (Internal Covariate Shift), a phenomenon that the upper layers need to continuously adapt to the new distributions of lower layers.  
Following this work, several normalization methods have been proposed, like instance normalization~\citep{DBLP:journals/corr/UlyanovVL16} and group normalization~\citep{DBLP:conf/eccv/WuH18}. In addition, there are several studies exploring better activation functions~\citep{klambauer2017self} or initialization methods~\citep{DBLP:journals/corr/abs-1901-09321} to avoid the dependency on normalization layers. 


LayerNorm is proposed to expand BatchNorm into RNN. LayerNorm normalizes the mean and variance of all summed inputs to the neurons in one layer. Unlike BatchNorm that depends on the size of mini-batch, LayerNorm has fewer limitations. LayerNorm is adaptive to RNN and self-attention-based models. It has been applied to the state-of-the-art frameworks such as  Transformer~\citep{DBLP:conf/nips/VaswaniSPUJGKP17}, BERT~\citep{devlin2018bert}, and Transformer-XL~\citep{dai2019transformer}. LayerNorm brings better performance and is irreplaceable in these frameworks. 



Despite the good performance, it is still unclear how layer normalization works. 
~\citet{ioffe2015batch} claim that the effectiveness of BatchNorm comes from reducing ICS. 
It has been a popular belief about BatchNorm~\citep{santurkar2018does}. 
However, some recent studies point out that the success of BatchNorm relates to the smoother gradients and has little to do with reducing ICS~\citep{santurkar2018does,DBLP:conf/nips/BjorckGSW18}. Although these studies provide a pioneering perspective to understand BatchNorm, there still remain some unanswered questions, such as how BatchNorm helps smooth gradients. 
Also, there are little work studying whether these theories can explain the success of LayerNorm. In this paper, we take a further step to a better understanding of LayerNorm. 

\section{Conclusion}
In this paper, we investigate how layer normalization works.  Based on a series of experiments and theoretical analysis, we summarize some interesting conclusions. 
We find that the derivatives of the mean and variance are important to the success of LayerNorm by re-centering and re-scaling backward gradients. Furthermore, experiments show that the bias and gain increase the risk of over-fitting and do not work in most cases. To address this problem, we propose a normalization method AdaNorm. It replaces the bias and gain in LayerNorm with a new adaptive transformation function that can update scaling weights based on input values.
Experiments show that AdaNorm outperforms LayerNorm on seven datasets. In the future work, we would like to explore more alternatives to LayerNorm from the perspective of gradient normalization.


\section*{Acknowledgments}

We thank all reviewers for providing the thoughtful and constructive suggestions. This work was supported
in part by National Natural Science Foundation of
China (No. 61673028).  










\bibliographystyle{abbrvnat}
\bibliography{nips}

\clearpage

\section{Appendix}
\subsection{Experimental Settings}
\subsubsection{Neural Machine Translation}
For neural machine translation tasks, we re-implement Transformer with the released code of Fairseq~\citep{ott2019fairseq}\footnote{https://github.com/pytorch/fairseq}.  \\\textbf{IWSLT 2015 English-Vietmanese Translation} It contains 133K training
sentence pairs provided by the IWSLT 2015 Evaluation Campaign. Following
the pre-processing steps in the work of ~\cite{DBLP:conf/icml/RaffelLLWE17}, we use TED
tst2012 (1,553 sentences) as the validation set  and TED tst2013 (1,268 sentences)
as the test set. BPE is used to get input and output vocabularies. The English and Vietnamese vocabulary sizes are 7,669 and 6,669 respectively.  The dropout rate is 0.1. The learning rate is 0.001. The training batch size is  4,096 tokens. The number of warmup steps is 8K. We use ``transformer\_wmt\_en\_de'' as our basic model. The setting of PreNorm is adopted. We use optimizer Adam with  and .   For AdaNorm, the hyper-parameter  is set to 1.
We average the last 10 checkpoints for evaluation and set the beam size to 5. 

\textbf{IWSLT 2014 German-English Translation} It is provided by the IWSLT 2014 Evaluation Campaign.  We use the same dataset splits following previous work~\citep{ott2019fairseq,DBLP:journals/corr/RanzatoCAZ15,DBLP:conf/emnlp/WisemanR16}. It contains 153K sentences for training, 7K sentences for validation, and 7K sentences for testing. BPE is used to get vocabularies. We use the shared embedding setting and the vocabulary size is 10,149. We use ``transformer\_iwslt\_de\_en'' as our basic model. The setting of PreNorm is adopted.   The dropout rate is 0.3. The attention dropout rate is  0.1. The activation dropout is 0.1. The initialization learning rate is 1e-07 and the learning rate is 0.0015. The training batch size is  4,096 tokens. We use optimizer Adam with  and .  We  update the gradients for every 2 steps. The number of warmup steps is 8K. For AdaNorm, the hyper-parameter  is set to 2. We average the last 10 checkpoints for evaluation and set the beam size to 5. 



\textbf{WMT English-German Translation} Following previous work~\citep{DBLP:conf/nips/VaswaniSPUJGKP17}, we use the same dataset splits and the same compound splitting.  The pre-processing code is provided by Fairseq.  BPE is used to get vocabularies. We use the shared embedding setting and the vocabulary size is 32,765. We use ``transformer\_wmt\_en\_de\_big\_t2t'' as our basic model. The setting of PreNorm is adopted.   The dropout rate is 0.3. The learning rate is 0.001. The training batch size is  4,096 tokens. We use optimizer Adam with  and .  The number of warmup steps is 4K. For AdaNorm, the hyper-parameter  is set to 2. We average the last 10 checkpoints for evaluation and set the beam size to 4.  





\subsubsection{Language Modeling}
\textbf{Enwiki-8}\footnote{http://www.mattmahoney.net/dc/text.html} This is a character-level language model dataset with 100M bytes.  We use the same preprocessed dataset as in the work~\citep{DBLP:conf/iclr/ChungAB17}.  We use the code provided by Transformer-XL\footnote{https://github.com/kimiyoung/transformer-xl }. We use the default hyper-parameters in the code. The model contains 12 decoder layers and the dimension of each layer is 512. Multi-head attention contains 8 heads and the dimension of each head is 64. The dropout rate is 0.1. The batch size is 22. We use optimizer Adam  with a learning rate 0.00025.  For AdaNorm, the hyper-parameter  is set to 1. We choose the best checkpoint on the validation set to evaluate the result on the test set.

\subsubsection{Classification}





\textbf{RT} The rating inference dataset~\citep{PangLee} is a binary  sentiment classification dataset from online movie reviews. Due to the lack of the standard split, we randomly divide all examples into 8,608 for training, 964 for validation, and 1,089 for testing. We implement a 4-layer Transformer encoder. The setting of PreNorm is adopted. The batch size is 4,096 tokens. The word embedding dimension is 128,  the hidden dimension is 128. The dropout rate is 0.2.   The optimization method is Adam optimizer  with  = 0.9,   = 0.998. For AdaNorm, the hyper-parameter  is set to 0.3. 

\textbf{SST} The Stanford sentiment treebank~\citep{socher2013recursive} is a single-sentence classification dataset built on movie reviews.  We run experiments on a five label set. It provides the standard spit, with 8,544 for training, 1,101 for validation, and 2,210 for testing. We use the same model structure in RT. For AdaNorm, the hyper-parameter  is set to 0.3. The rest of parameters are set exactly the same as in RT settings. 

\textbf{MNIST Image Recognition} \quad The MNIST handwritten digit dataset~\citep{lecun1998gradient} consists of 55,000 training images, 5,000 validation images, and additional 10,000 testing images. This task aims to recognize the numerical digit (0-9) of each image. We implement a CNN based classifier. The first 2D-convolution layer has 1 in-channel, 20 out-channels. The second 2D-convolution layer has 20 in-channels, 50 out-channels. We flatten the output of the second 2D-convolution layer and send it to a linear layer. The batch size is  . We use Adam optimizer with a learning rate of . We apply LayerNorm before activation in every linear layer. When applying AdaNorm, we set hyper-parameter  to 2. We train the model for  epochs. We choose the best checkpoint on the validation set for evaluation.

\subsubsection{Dependency Parsing}
\textbf{Transition-based Dependency Parsing} Following previous work, we use English Penn TreeBank (PTB)~\citep{DBLP:journals/coling/MarcusSM94} for experiments. We follow the standard split of the corpus with sections 2-21 as the training set (39,832 sentences, 1,900,056 transition examples), section 22 as the validation set (1,700 sentences, 80,234 transition examples), and section 23 as the testing set (2,416 sentences, 113,368 transition examples). We implement a  MLP-based parser following the work~\citep{DBLP:conf/emnlp/ChenM14}.   The dimension of the hidden state is , the batch size is , the dropout rate is . We use optimizer Adam and initialize the learning rate to . We apply LayerNorm before activation in every linear layer. When applying AdaNorm, we set hyper-parameter  to 1. We train  epochs on the training set. We evaluate the model on the development set every epoch and find the best checkpoint to evaluate the test results.




\clearpage
\subsection{Proof of Theorem 1}
\begin{proof}
Define . It is easy to verify


The forward propagation 


Calculating the gradient in backward propagation


To conclude


If we detach the gradient of  and , in backward propagation

namely


Calculating  and 


To conclude,  and .


\textbf{Proof of (1)}

(1) In standard layernorm, we do not detach the gradients of  and , in backward propagation


Define , we can verify that


Therefore, 


For any vector  vertical to  and  (  is vertical to ), we have


We expand  and  to a standard orthogonal basis , then for any vector , we have


Therefore, 


To conclude,  and .

\textbf{Proof of (2)}
(2) If we detach the gradients of , in backward propagation


Define , then


Therefore, 


Consider


Therefore, 


To conclude, , .

\textbf{Proof of (3)}

(3) If we detach the gradient of , in backward propagation


Define , we can verify that


Therefore, 


For any vector  vertical to 


Note that , namely  is vertical to  and , therefore



To conclude  and .

\end{proof}

\clearpage
\subsection{Proof of Theorem 2}

\begin{proof}
Assume . Because  is derivable, asuume . It is easy to verify


Differential on both sides of following three equations


In -dim Euclidean space, note that , namely  and  are vertical. We expand  and  to an orthogonal basis . Suppose  and , we have


Accoring to Eq.~\ref{beta}, . Because it holds in spite of , . Therefore, . Namely


Consider 


If we set , then  and  hold. Under this circumstances


Therefore  holds for any , when  approches infinity, we have .
, therefore . Let , therefore , then


Namely  can hold if . To conclude  is the only solution.
\end{proof}


\end{document}
