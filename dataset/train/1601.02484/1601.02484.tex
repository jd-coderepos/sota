








\newif\ifdraft \draftfalse

\documentclass[runningheads]{llncs}
\usepackage{url}
\usepackage{xspace}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{proof}
\usepackage{monadicLens}
\usepackage{graphicx}
\usepackage{br}

\usepackage[sectionbib]{natbib}




\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}{\@namedef{lhs2tex.lhs2tex.sty.read}{}\newcommand\SkipToFmtEnd{}\newcommand\EndFmtInput{}\long\def\SkipToFmtEnd#1\EndFmtInput{}}\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

\@ifundefined{mathindent}{\newdimen\mathindent\mathindent\leftmargini}{}

\def\resethooks{\global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]{\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]{\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]{\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{\let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{\let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{\textbf{To do:}~#1}

\EndFmtInput
\makeatother
\ReadOnlyOnce{polycode.fmt}\makeatletter

\newcommand{\hsnewpar}[1]{{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

\newcommand{\hscodestyle}{}



\newcommand{\sethscode}[1]{\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}



\newenvironment{compathscode}{\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\pboxed}{\endpboxed\let\hspost\pboxed}{\endpboxed\parray}{\endparray\parray}{\endparray\pboxed}{\endpboxed\def\column##1##2{}\let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\ }

\newcommand{\inlinehs}{\sethscode{inlinehscode}}



\newenvironment{joincode}{\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
\orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}{\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}

\makeatother
\EndFmtInput


\ReadOnlyOnce{forall.fmt}\makeatletter



\let\HaskellResetHook\empty
\newcommand*{\AtHaskellReset}[1]{\g@addto@macro\HaskellResetHook{#1}}
\newcommand*{\HaskellReset}{\HaskellResetHook}

\global\let\hsforallread\empty

\newcommand\hsforall{\global\let\hsdot=\hsperiodonce}
\newcommand*\hsperiodonce[2]{#2\global\let\hsdot=\hscompose}
\newcommand*\hscompose[2]{#1}

\AtHaskellReset{\global\let\hsdot=\hscompose}

\HaskellReset

\makeatother
\EndFmtInput












































\def\get#1{\Varid{get}_{\mskip-2mu#1}}
\def\set#1{\Varid{set}_{\mskip-2mu#1}}

























































\def\commentbegin{\quad}
\def\commentend{}




\title{Reflections on monadic lenses}
\def\oxford{\inst{1}}
\def\edinburgh{\inst{2}}

\author{Faris~Abou-Saleh\oxford \and 
  James~Cheney\edinburgh \and 
  Jeremy~Gibbons\oxford \and 
  James~McKinna\edinburgh \and 
  Perdita~Stevens\edinburgh}
\authorrunning{F.\,Abou-Saleh,
  J.\,Cheney,
  J.\,Gibbons,
  J.\,McKinna,
  P.\,Stevens}
\institute{University of Oxford, \email{firstname.lastname@cs.ox.ac.uk}
\and University of Edinburgh, \email{firstname.lastname@ed.ac.uk}
}


\begin{document}
\maketitle

\begin{abstract}
  Bidirectional transformations (bx) have primarily been modeled as
  pure functions, and do not account for the possibility of the
  side-effects  that are available in most programming languages. Recently
  several formulations of bx that use monads to account for effects
  have been proposed, both among practitioners and in academic
  research. The combination of bx with effects turns out to be
  surprisingly subtle, leading to problems with some of these
  proposals and increasing the complexity of others. This paper
  reviews the proposals for monadic lenses to date,
and offers some improved definitions, paying particular attention to
  the obstacles to naively adding monadic effects to existing
  definitions of pure bx such as lenses and symmetric lenses, and the
  subtleties of equivalence of symmetric bidirectional transformations
  in the presence of effects.
\end{abstract}



\if 0

Bidirectional transformations (bx) have primarily been modeled as pure
functions, and do not account for the possibility of the side-effects
that are available in most programming languages. Recently several
formulations of bx that use monads to account for effects have been
proposed, both among practitioners and in academic research. The
combination of bx with effects turns out to be surprisingly subtle,
leading to problems with some of these proposals and increasing the
complexity of others. This paper reviews the proposals for monadic
lenses to date, and offers some improved definitions, paying
particular attention to the obstacles to naively adding monadic
effects to existing definitions of pure bx such as lenses and
symmetric lenses, and the subtleties of equivalence of symmetric
bidirectional transformations in the presence of effects.

\fi
\section{Introduction}

Programming with multiple concrete representations of the same conceptual
information is a commonplace, and challenging, problem. It is commonplace
because data is everywhere, and not all of it is relevant or appropriate
for every task: for example, one may want to work with only a subset of
one's full email account on a mobile phone or other low-bandwidth device.
It is challenging because the most direct approach to mapping data across
sources \ensuremath{\Conid{A}} and \ensuremath{\Conid{B}} is to write separate functions,
one mapping to \ensuremath{\Conid{B}} and one to \ensuremath{\Conid{A}},
following some (not always explicit) specification of what it
means for an \ensuremath{\Conid{A}} value and a \ensuremath{\Conid{B}} value to be \emph{consistent}. Keeping
these transformations coherent with each other, and with the specification,
is a considerable maintenance burden, yet it remains the main approach
found in practice.

Over the past decade, a number of promising proposals to ease
programming such \emph{bidirectional transformations} have emerged,
including \emph{lenses}~\citep{lens-toplas}, bx based on consistency
relations~\citep{stevens09:sosym}, \emph{symmetric
  lenses}~\citep{symlens}, and a number of variants and
extensions (e.g.~\citep{pacheco14pepm,johnson14bx}).  
Most of these proposals consist of an interface
with pure functions and some equational laws that characterise
good behaviour; the interaction of bidirectionality with
other effects has received comparatively little attention.  




Some programmers and researchers have already proposed ways to combine
lenses and monadic effects~\citep{reddit,pacheco14pepm}.  Recently, we
have proposed symmetric notions of bidirectional computation based on
\emph{entangled state monads}~\citep{cheney14bx2,abousaleh15mpc} and
\emph{coalgebras}~\citep{abousaleh15bx}.  As a result, there are now
several alternative proposals for bidirectional transformations with
effects.  While this diversity is natural and healthy, reflecting an
active research area, the different proposals tend to employ somewhat
different terminology, and the relationships among them are not well
understood.  Small differences in definitions can have
disproportionate impact.  



In this paper we summarise and compare the existing proposals, offer
some new alternatives, and attempt to provide general and useful
definitions of ``monadic lenses'' and ``symmetric monadic lenses''.
Perhaps surprisingly, it appears challenging even to define the
composition of lenses in the presence of effects, especially in the
symmetric case.  We first review the definition of pure asymmetric
lenses and two
prior
proposals for extending them with monadic effects. These
definitions have some limitations, and we propose a new definition of
monadic lens that overcomes them.  

Next we consider the symmetric case. The effectful bx and coalgebraic
bx in our previous work are symmetric, but their definitions rely on
relatively heavyweight machinery (monad transformers and morphisms,
coalgebra).  It seems natural to ask whether just adding monadic
effects to symmetric lenses in the style of Hofmann et al.~\citep{symlens} would also
work.  We show that, as for asymmetric lenses, adding monadic effects 
to symmetric lenses is challenging, and give examples illustrating
the problems with the most obvious generalisation.
We then briefly discuss our recent work on symmetric forms of bx with
monadic effects~\citep{cheney14bx2,abousaleh15mpc,abousaleh15bx}.
Defining composition for these approaches also turns out to be tricky,
and our definition of monadic lenses arose out of exploring this
space.  The essence of composition of symmetric monadic bx, we now
believe, can be presented most easily in terms of monadic lenses, by
considering \emph{spans}, an approach also advocated (in the pure
case) by \citet{johnson14bx}.

Symmetric pure bx need to be equipped with a notion of equivalence, to
abstract away inessential differences of representation of their
``state'' or ``complement'' spaces.  As noted by \citet{symlens} and \citet{johnson14bx},
isomorphism of state spaces is unsatisfactory, and there are competing
proposals for equivalence of symmetric lenses and spans.  In the case
of spans of monadic lenses, the right notion of equivalence seem even
less obvious.  We compare three, increasingly coarse, equivalences
of spans based on isomorphism (following~\citet{abousaleh15mpc}), span
equivalence (following~\citet{johnson14bx}), and bisimulation
(following~\citet{symlens} and \citet{abousaleh15bx}).  In addition, we show a (we
think surprising) result: in the pure case, span equivalence and
bisimulation equivalence coincide.


In this paper we employ Haskell-like notation to describe and compare
formalisms, with a few conventions: we write function composition \ensuremath{\Varid{f}\hsdot{\mathbin{\cdot}}{\mathrel{.}}\Varid{g}} with a centred dot, and use a lowered dot for field lookup
\ensuremath{\Varid{x}\mathord{.}\Varid{f}}, in contrast to Haskell's notation \ensuremath{\Varid{f}\;\Varid{x}}.  Throughout the
paper, we introduce a number of different representations of lenses,
and rather than pedantically disambiguating them all, we freely
redefine identifiers as we go.  We assume familiarity with common uses
of monads in Haskell to encapsulate
effects (following \citet{DBLP:conf/afp/Wadler95}), and with the
\ensuremath{\mathbf{do}}-notation (following Wadler's
monad comprehensions~\citet{DBLP:journals/mscs/Wadler92}).
Although some of these ideas are present or implicit in recent
papers~\citep{symlens,johnson14bx,cheney14bx2,abousaleh15mpc,abousaleh15bx},
this paper reflects our desire to clarify these ideas and expose them
in their clearest form --- a desire that is strongly influenced by
Wadler's work on a wide variety of related
topics~\citep{DBLP:journals/mscs/Wadler92,DBLP:conf/fp/KingW92,DBLP:conf/afp/Wadler95},
and by our interactions with him as a colleague.


\section{Asymmetric monadic lenses}\label{sec:asymmetric}

Recall that a \emph{lens}~\citep{lens-toplas,foster10ssgip} is a pair of functions, usually called
\emph{get} and \emph{put}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{28}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[B]{}\mathbf{data}\;\alpha\mathbin{\leadsto}\beta\mathrel{=}\Conid{Lens}\;\{\mskip1.5mu {}\<[28]\>[28]{}\Varid{get}\mathbin{::}\alpha\to \beta,\Varid{put}\mathbin{::}\alpha\to \beta\to \alpha\mskip1.5mu\}{}\<[E]\ColumnHook
\end{hscode}\resethooks
satisfying (at least) the following \emph{well-behavedness} laws:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{3}{@{}>{\hspre}l<{\hspost}@{}}\column{12}{@{}>{\hspre}c<{\hspost}@{}}\column{12E}{@{}l@{}}\column{16}{@{}>{\hspre}l<{\hspost}@{}}\column{31}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[3]{}\mathsf{(GetPut)}{}\<[12]\>[12]{}\quad{}\<[12E]\>[16]{}\Varid{put}\;\Varid{a}\;(\Varid{get}\;\Varid{a}){}\<[31]\>[31]{}\mathrel{=}\Varid{a}{}\<[E]\\
\>[3]{}\mathsf{(PutGet)}{}\<[12]\>[12]{}\quad{}\<[12E]\>[16]{}\Varid{get}\;(\Varid{put}\;\Varid{a}\;\Varid{b}){}\<[31]\>[31]{}\mathrel{=}\Varid{b}{}\<[E]\ColumnHook
\end{hscode}\resethooks
The idea is that a lens of type \ensuremath{\Conid{A}\mathbin{\leadsto}\Conid{B}} maintains a source of type
\ensuremath{\Conid{A}}, providing a view of type \ensuremath{\Conid{B}} onto it; the well-behavedness laws
capture the intuition that the view faithfully reflects the source: if
we ``get'' a \ensuremath{\Varid{b}} from a source \ensuremath{\Varid{a}} and then ``put'' the same \ensuremath{\Varid{b}} value
back into \ensuremath{\Varid{a}}, this leaves \ensuremath{\Varid{a}} unchanged; and if we ``put'' a \ensuremath{\Varid{b}} into
a source \ensuremath{\Varid{a}} and then ``get'' from the result, we get \ensuremath{\Varid{b}} itself.
Lenses are often
equipped with a \ensuremath{\Varid{create}} function
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{28}{@{}>{\hspre}l<{\hspost}@{}}\column{69}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[B]{}\mathbf{data}\;\alpha\mathbin{\leadsto}\beta\mathrel{=}\Conid{Lens}\;\{\mskip1.5mu {}\<[28]\>[28]{}\Varid{get}\mathbin{::}\alpha\to \beta,\Varid{put}\mathbin{::}\alpha\to \beta\to \alpha,{}\<[69]\>[69]{}\Varid{create}\mathbin{::}\beta\to \alpha\mskip1.5mu\}{}\<[E]\ColumnHook
\end{hscode}\resethooks
 satisfying an additional law:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{5}{@{}>{\hspre}l<{\hspost}@{}}\column{14}{@{}>{\hspre}c<{\hspost}@{}}\column{14E}{@{}l@{}}\column{18}{@{}>{\hspre}l<{\hspost}@{}}\column{34}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[5]{}\mathsf{(CreateGet)}{}\<[14]\>[14]{}\quad{}\<[14E]\>[18]{}\Varid{get}\;(\Varid{create}\;\Varid{b}){}\<[34]\>[34]{}\mathrel{=}\Varid{b}{}\<[E]\ColumnHook
\end{hscode}\resethooks
When the distinction is important, we use the term \emph{full} for
well-behaved lenses equipped with a \ensuremath{\Varid{create}} operation.  It is easy to show that
the source and view types of a full lens must either both be empty or
both non-empty, and that the \ensuremath{\Varid{get}} operation of a full lens is
surjective.


Lenses have been investigated extensively; see for example \citet{foster10ssgip} for a recent tutorial overview.  For the
purposes of this paper, we just recall the definition of
\emph{composition} of lenses:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{3}{@{}>{\hspre}l<{\hspost}@{}}\column{28}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[3]{}(\mathbin{;})\mathbin{::}(\alpha\mathbin{\leadsto}\beta)\to (\beta\mathbin{\leadsto}\gamma)\to (\alpha\mathbin{\leadsto}\gamma){}\<[E]\\
\>[3]{}\Varid{l}_{1}\mathbin{;}\Varid{l}_{2}\mathrel{=}\Conid{Lens}\;{}\<[28]\>[28]{}(\Varid{l}_{2}\mathord{.}\Varid{get}\hsdot{\mathbin{\cdot}}{\mathrel{.}}\Varid{l}_{1}\mathord{.}\Varid{get})\;{}\<[E]\\
\>[28]{}(\lambda \Varid{a}\;\Varid{c}\to \Varid{l}_{1}\mathord{.}\Varid{put}\;\Varid{a}\;(\Varid{l}_{2}\mathord{.}\Varid{put}\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;\Varid{a})\;\Varid{c}))\;{}\<[E]\\
\>[28]{}(\Varid{l}_{1}\mathord{.}\Varid{create}\hsdot{\mathbin{\cdot}}{\mathrel{.}}\Varid{l}_{1}\mathord{.}\Varid{create}){}\<[E]\ColumnHook
\end{hscode}\resethooks
which preserves well-behavedness.  




\subsection{A naive approach}\label{sec:naive-lens}

As a first attempt, consider simply adding a monadic effect \ensuremath{\mu} to
the result types of both \ensuremath{\Varid{get}} and \ensuremath{\Varid{put}}.  
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{35}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[B]{}\mathbf{data}\;\monadic{\alpha\rightsquigarrow_0\beta}{\mu}\mathrel{=}MLens_0\;\{\mskip1.5mu {}\<[35]\>[35]{}\Varid{mget}\mathbin{::}\alpha\to \mu\;\beta,\Varid{mput}\mathbin{::}\alpha\to \beta\to \mu\;\alpha\mskip1.5mu\}{}\<[E]\ColumnHook
\end{hscode}\resethooks
Such an approach has been considered and discussed in some recent
Haskell libraries and online discussions~\citep{reddit}.  A natural
question arises immediately: what laws should a lens \ensuremath{\Varid{l}\mathbin{::}\monadic{\Conid{A}\rightsquigarrow_0\Conid{B}}{\Conid{M}}} satisfy?  The following generalisations of the laws appear natural:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{3}{@{}>{\hspre}l<{\hspost}@{}}\column{12}{@{}>{\hspre}l<{\hspost}@{}}\column{46}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[3]{}\mathsf{(MGetPut_0)}{}\<[12]\>[12]{}\quad\mathbf{do}\;\{\mskip1.5mu \Varid{b}\leftarrow \Varid{mget}\;\Varid{a};\Varid{mput}\;\Varid{a}\;\Varid{b}\mskip1.5mu\}{}\<[46]\>[46]{}\mathrel{=}\Varid{return}\;\Varid{a}{}\<[E]\\
\>[3]{}\mathsf{(MPutGet_0)}{}\<[12]\>[12]{}\quad\mathbf{do}\;\{\mskip1.5mu \Varid{a'}\leftarrow \Varid{mput}\;\Varid{a}\;\Varid{b};\Varid{mget}\;\Varid{a'}\mskip1.5mu\}{}\<[46]\>[46]{}\mathrel{=}\mathbf{do}\;\{\mskip1.5mu \Varid{a'}\leftarrow \Varid{mput}\;\Varid{a}\;\Varid{b};\Varid{return}\;\Varid{b}\mskip1.5mu\}{}\<[E]\ColumnHook
\end{hscode}\resethooks
that is, if we ``get'' \ensuremath{\Varid{b}} from \ensuremath{\Varid{a}} and then ``put'' the same \ensuremath{\Varid{b}}
value back into \ensuremath{\Varid{a}}, this has the same effect as just returning \ensuremath{\Varid{a}}
(and doing nothing else), and if we ``put'' a value  and then
``get'' the result, this has the same effect as just returning 
after doing the ``put''.  
The obvious generalisation of composition from the pure case for these
operations is:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{3}{@{}>{\hspre}l<{\hspost}@{}}\column{31}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[3]{}(\mathbin{;})\mathbin{::}\monadic{\alpha\rightsquigarrow_0\beta}{\mu}\to \monadic{\beta\rightsquigarrow_0\gamma}{\mu}\to \monadic{\alpha\rightsquigarrow_0\gamma}{\mu}{}\<[E]\\
\>[3]{}\Varid{l}_{1}\mathbin{;}\Varid{l}_{2}\mathrel{=}MLens_0\;{}\<[31]\>[31]{}(\lambda \Varid{a}\to \mathbf{do}\;\{\mskip1.5mu \Varid{b}\leftarrow \Varid{l}_{1}\mathord{.}\Varid{mget}\;\Varid{a};\Varid{l}_{2}\mathord{.}\Varid{mget}\;\Varid{b}\mskip1.5mu\})\;{}\<[E]\\
\>[31]{}(\lambda \Varid{a}\;\Varid{c}\to \mathbf{do}\;\{\mskip1.5mu \Varid{b}\leftarrow \Varid{l}_{1}\mathord{.}\Varid{mget}\;\Varid{a};\Varid{b'}\leftarrow \Varid{l}_{2}\mathord{.}\Varid{mput}\;\Varid{b}\;\Varid{c};\Varid{l}_{1}\mathord{.}\Varid{mput}\;\Varid{a}\;\Varid{b'}\mskip1.5mu\}){}\<[E]\ColumnHook
\end{hscode}\resethooks

This proposal has at least two apparent problems.  First, the
\ensuremath{\mathsf{(MGetPut_0)}} law appears to sharply constrain \ensuremath{\Varid{mget}}: indeed, if \ensuremath{\Varid{mget}\;\Varid{a}}
has an irreversible side-effect then \ensuremath{\mathsf{(MGetPut_0)}} 
cannot hold.  This
suggests that \ensuremath{\Varid{mget}} must either be pure, or have side-effects that
are reversible by \ensuremath{\Varid{mput}}, ruling out behaviours such as performing I/O
during \ensuremath{\Varid{mget}}.  Second, it appears difficult to compose these
structures in a way that preserves the laws, unless we again make
fairly draconian assumptions about \ensuremath{\mu}.  
In order to show \ensuremath{\mathsf{(MGetPut_0)}} for the composition \ensuremath{\Varid{l}_{1}\mathbin{;}\Varid{l}_{2}}, it seems necessary to be able to commute \ensuremath{\Varid{l}_{2}\mathord{.}\Varid{mget}} with \ensuremath{\Varid{l}_{1}\mathord{.}\Varid{mget}}
and we also need to know that doing \ensuremath{\Varid{l}_{1}\mathord{.}\Varid{mget}} 
twice is the same as doing it
just once. Likewise, to show \ensuremath{\mathsf{(MPutGet_0)}} we need to commute \ensuremath{\Varid{l}_{2}\mathord{.}\Varid{mget}} with
\ensuremath{\Varid{l}_{1}\mathord{.}\Varid{mput}}.  



\subsection{Monadic put-lenses}

\citet{pacheco14pepm} proposed a variant of lenses
called \emph{monadic putback-oriented lenses}.  For the purposes of
this paper, the putback-orientation of their approach is irrelevant:
we focus on their use of monads, and we provide a slightly simplified
version of their definition:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{35}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[B]{}\mathbf{data}\;\monadic{\alpha\rightsquigarrow_1\beta}{\mu}\mathrel{=}MLens_1\;\{\mskip1.5mu {}\<[35]\>[35]{}\Varid{mget}\mathbin{::}\alpha\to \beta,\Varid{mput}\mathbin{::}\alpha\to \beta\to \mu\;\alpha\mskip1.5mu\}{}\<[E]\ColumnHook
\end{hscode}\resethooks
The main difference from their version is that we remove the \ensuremath{\Conid{Maybe}}
type constructors from the return type of \ensuremath{\Varid{mget}} and the first
argument of \ensuremath{\Varid{mput}}.
Pacheco et al. state laws for these monadic lenses.  First, they
assume that the monad \ensuremath{\mu} has a \emph{monad membership} operation 
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{3}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[3]{}(\in)\mathbin{::}\alpha\to \mu\;\alpha\to \Conid{Bool}{}\<[E]\ColumnHook
\end{hscode}\resethooks
satisfying the following two laws:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{3}{@{}>{\hspre}l<{\hspost}@{}}\column{17}{@{}>{\hspre}l<{\hspost}@{}}\column{41}{@{}>{\hspre}c<{\hspost}@{}}\column{41E}{@{}l@{}}\column{46}{@{}>{\hspre}l<{\hspost}@{}}\column{58}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[3]{}({\in}\text{-ID}){}\<[17]\>[17]{}\quad\Varid{x}\in\Varid{return}\;\Varid{x}{}\<[41]\>[41]{}\Leftrightarrow{}\<[41E]\>[46]{}\Conid{True}{}\<[E]\\
\>[3]{}({\in}\text{-}{\bind }){}\<[17]\>[17]{}\quad\Varid{y}\in(\Varid{m}\bind \Varid{f}){}\<[41]\>[41]{}\Leftrightarrow{}\<[41E]\>[46]{}\exists \Varid{x}\hsforall \hsdot{\mathbin{\cdot}}{\mathrel{.}}{}\<[58]\>[58]{}\Varid{x}\in\Varid{m}\mathrel{\wedge}\Varid{y}\in(\Varid{f}\;\Varid{x}){}\<[E]\ColumnHook
\end{hscode}\resethooks
Then the laws for \ensuremath{MLens_1} 
(adapted from \citet[Prop. 3, p49]{pacheco14pepm}) are as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{3}{@{}>{\hspre}l<{\hspost}@{}}\column{14}{@{}>{\hspre}c<{\hspost}@{}}\column{14E}{@{}l@{}}\column{18}{@{}>{\hspre}l<{\hspost}@{}}\column{40}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[3]{}\mathsf{(MGetPut_1)}{}\<[14]\>[14]{}\quad{}\<[14E]\>[18]{}\Varid{v}\mathrel{=}\Varid{mget}\;\Varid{s}{}\<[40]\>[40]{}\Longrightarrow\Varid{mput}\;\Varid{s}\;\Varid{v}\mathrel{=}\Varid{return}\;\Varid{s}{}\<[E]\\
\>[3]{}\mathsf{(MPutGet_1)}{}\<[14]\>[14]{}\quad{}\<[14E]\>[18]{}\Varid{s'}\in\Varid{mput}\;\Varid{s}\;\Varid{v'}{}\<[40]\>[40]{}\Longrightarrow\Varid{v'}\mathrel{=}\Varid{mget}\;\Varid{s'}{}\<[E]\ColumnHook
\end{hscode}\resethooks
In the first law we correct an apparent typo in the original paper,
as well as removing the \ensuremath{\Conid{Just}} constructors from both laws.  By making \ensuremath{\Varid{mget}}
pure, this definition avoids the immediate problems with composition
discussed above, and Pacheco et al. outline a proof that their laws
are preserved by composition.  However, it is not obvious how to
generalise their approach beyond monads that admit a sensible \ensuremath{\in}
operation.

Many interesting monads do have a sensible \ensuremath{\in} operation
(e.g. \ensuremath{\Conid{Maybe}}, \ensuremath{[\mskip1.5mu \mskip1.5mu]}).  Pacheco et al. suggest that \ensuremath{\in} can be
defined for any monad as , where
 is what they call a ``(polymorphic) algebra for the monad at hand,
essentially, a
 of type \ensuremath{\Varid{m}\;\Varid{a}\to \Varid{a}} for any type \ensuremath{\Varid{a}}.''
However, this
definition doesn't appear satisfactory for monads such as \ensuremath{\Conid{IO}}, for
which there is no such (pure) function: the \ensuremath{({\in}\text{-ID})} law can
never hold in this case.  It is not clear that we can define a useful
\ensuremath{\in} operation directly for \ensuremath{\Conid{IO}} either: given that \ensuremath{\Varid{m}\mathbin{::}\Conid{IO}\;\Varid{a}}
could ultimately return any \ensuremath{\Varid{a}}-value, 
it seems safe, if perhaps
overly conservative, to define \ensuremath{\Varid{x}\in\Varid{m}\mathrel{=}\Conid{True}} for any \ensuremath{\Varid{x}} and
\ensuremath{\Varid{m}}. This satisfies the \ensuremath{\in} laws, at least, if we make a
simplifying assumption that all types are inhabited, and indeed, it
seems to be the only thing we could write in Haskell that would
satisfy the laws, since we have no way of looking inside the monadic
computation \ensuremath{\Varid{m}\mathbin{::}\Conid{IO}\;\Varid{a}} to find out what its eventual return value
is. But then the precondition of the \ensuremath{\mathsf{(MPutGet_1)}} law is always true, which
forces the view space to be trivial.  These complications suggest, at
least, that it would be advantageous to find a definition of monadic
lenses that makes sense, and is preserved under composition, for any
monad.




\subsection{Monadic lenses}

We propose the following definition of monadic lenses for any monad \ensuremath{\Conid{M}}:
\begin{definition}[monadic lens]
A \emph{monadic lens} from source type \ensuremath{\Conid{A}} to view type \ensuremath{\Conid{B}} in
which the put operation may have effects from monad \ensuremath{\Conid{M}} (or
``\ensuremath{\Conid{M}}-lens from \ensuremath{\Conid{A}} to \ensuremath{\Conid{B}}''), is represented by the type \ensuremath{\monadic{\Conid{A}\rightsquigarrow\Conid{B}}{\Conid{M}}}, where 
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{33}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[B]{}\mathbf{data}\;\monadic{\alpha\rightsquigarrow\beta}{\mu}\mathrel{=}\Conid{MLens}\;\{\mskip1.5mu {}\<[33]\>[33]{}\Varid{mget}\mathbin{::}\alpha\to \beta,\Varid{mput}\mathbin{::}\alpha\to \beta\to \mu\;\alpha\mskip1.5mu\}{}\<[E]\ColumnHook
\end{hscode}\resethooks
(dropping the \ensuremath{\mu} from the return type of \ensuremath{\Varid{mget}}, compared to the definition in Section~\ref{sec:naive-lens}).
We say that \ensuremath{\Conid{M}}-lens \ensuremath{\Varid{l}} is \emph{well-behaved} if it satisfies
\savecolumns
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{11}{@{}>{\hspre}c<{\hspost}@{}}\column{11E}{@{}l@{}}\column{15}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[B]{}\mathsf{(MGetPut)}{}\<[11]\>[11]{}\quad{}\<[11E]\>[15]{}\mathbf{do}\;\{\mskip1.5mu \Varid{l}\mathord{.}\Varid{mput}\;\Varid{a}\;(\Varid{l}\mathord{.}\Varid{mget}\;\Varid{a})\mskip1.5mu\}\mathrel{=}\Varid{return}\;\Varid{a}{}\<[E]\\
\>[B]{}\mathsf{(MPutGet)}{}\<[11]\>[11]{}\quad{}\<[11E]\>[15]{}\mathbf{do}\;\{\mskip1.5mu \Varid{a'}\leftarrow \Varid{l}\mathord{.}\Varid{mput}\;\Varid{a}\;\Varid{b};\Varid{k}\;\Varid{a'}\;(\Varid{l}\mathord{.}\Varid{mget}\;\Varid{a'})\mskip1.5mu\}{}\<[E]\\
\>[15]{}\mathrel{=}\mathbf{do}\;\{\mskip1.5mu \Varid{a'}\leftarrow \Varid{l}\mathord{.}\Varid{mput}\;\Varid{a}\;\Varid{b};\Varid{k}\;\Varid{a'}\;\Varid{b}\mskip1.5mu\}{}\<[E]\ColumnHook
\end{hscode}\resethooks
\endswithdisplay
\end{definition}
Note that in \ensuremath{\mathsf{(MPutGet)}}, we use a continuation \ensuremath{\Varid{k}\mathbin{::}\alpha\to \beta\to \mu\;\gamma} to quantify over all possible subsequent computations in which
\ensuremath{\Varid{a'}} and \ensuremath{\Varid{l}\mathord{.}\Varid{mget}\;\Varid{a'}} 
might appear.  In fact, using the laws of monads
and simply-typed lambda calculus we can prove this law from just the
special case \ensuremath{\Varid{k}\mathrel{=}\lambda \Varid{a}\;\Varid{b}\to \Varid{return}\;(\Varid{a},\Varid{b})}, so in the sequel when we
prove \ensuremath{\mathsf{(MPutGet)}} we may just prove this case while using the strong
form freely in the proof.

The ordinary asymmetric lenses are exactly the monadic lenses over
\ensuremath{\mu\mathrel{=}\Conid{Id}}; the laws then specialise to the standard
equational laws.  Monadic lenses where \ensuremath{\mu\mathrel{=}\Conid{Id}} are called
\emph{pure}, and we may refer to ordinary lenses as pure lenses also.
\begin{definition}
We can also define an operation that lifts a pure lens to a monadic lens:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[B]{}\Varid{lens2mlens}\mathbin{::}\Conid{Monad}\;\mu\Rightarrow \alpha\mathbin{\leadsto}\beta\to \monadic{\alpha\rightsquigarrow\beta}{\mu}{}\<[E]\\
\>[B]{}\Varid{lens2mlens}\;\Varid{l}\mathrel{=}\Conid{MLens}\;(\Varid{l}\mathord{.}\Varid{get})\;(\lambda \Varid{a}\;\Varid{b}\to \Varid{return}\;(\Varid{l}\mathord{.}\Varid{put}\;\Varid{a}\;\Varid{b})){}\<[E]\ColumnHook
\end{hscode}\resethooks
\endswithdisplay
\end{definition}
\begin{lemma}\label{lem:lens2mlens-wb}
  If \ensuremath{\Varid{l}\mathbin{::}\Conid{Lens}\;\alpha\;\beta} is well-behaved, then so is \ensuremath{\Varid{lens2mlens}\;\Varid{l}}.
\end{lemma}
\begin{example}
  To illustrate, some simple pure lenses include:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[B]{}id_{\mathrm{l}}\mathbin{::}\alpha\mathbin{\leadsto}\alpha{}\<[E]\\
\>[B]{}id_{\mathrm{l}}\mathrel{=}\Conid{Lens}\;(\lambda \Varid{a}\to \Varid{a})\;(\lambda \anonymous \;\Varid{a}\to \Varid{a}){}\<[E]\\blanklineskip]\>[4]{}\Varid{r}_{0}\mathord{.}\Varid{get}\;(\Varid{s}_{1},\Varid{s}_{2}){}\<[27]\>[27]{}\mathrel{=}\Varid{r}_{1}\mathord{.}\Varid{get}\;\Varid{s}_{1}{}\<[46]\>[46]{}\quad{}\<[46E]\>[50]{}\quad{}\<[50E]\>[62]{}\Varid{r}_{0}\mathord{.}\Varid{get}\;(\Varid{s}_{1},\Varid{s}_{2}){}\<[80]\>[80]{}\mathrel{=}\Varid{r}_{2}\mathord{.}\Varid{get}\;\Varid{s}_{2}{}\<[E]\\
\>[4]{}\Varid{fst}\;(\Varid{r}_{0}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;\Varid{b}){}\<[27]\>[27]{}\mathrel{=}\Varid{r}_{1}\mathord{.}\Varid{put}\;\Varid{s}_{1}\;\Varid{b}{}\<[46]\>[46]{}\quad{}\<[46E]\>[50]{}\quad{}\<[50E]\>[56]{}\Varid{snd}\;(\Varid{r}_{0}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;\Varid{b}){}\<[80]\>[80]{}\mathrel{=}\Varid{r}_{2}\mathord{.}\Varid{put}\;\Varid{s}_{2}\;\Varid{b}{}\<[E]\\
\>[4]{}\Varid{fst}\;(\Varid{r}_{0}\mathord{.}\Varid{create}\;\Varid{b}){}\<[27]\>[27]{}\mathrel{=}\Varid{r}_{1}\mathord{.}\Varid{create}\;\Varid{s}_{1}{}\<[46]\>[46]{}\quad{}\<[46E]\>[50]{}\quad{}\<[50E]\>[59]{}\Varid{snd}\;(\Varid{r}_{0}\mathord{.}\Varid{create}\;\Varid{b}){}\<[80]\>[80]{}\mathrel{=}\Varid{r}_{2}\mathord{.}\Varid{create}\;\Varid{b}{}\<[E]\ColumnHook
\end{hscode}\resethooks
In addition, it follows that:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[B]{}\Varid{l}_{0}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;\Varid{a}\mathrel{=}(\Varid{l}_{1}\mathord{.}\Varid{put}\;\Varid{s}_{1}\;\Varid{a},\Varid{l}_{2}\mathord{.}\Varid{put}\;\Varid{s}_{2}\;\Varid{a})\in\Conid{R}{}\<[E]\\
\>[B]{}\Varid{r}_{0}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;\Varid{b}\mathrel{=}(\Varid{r}_{1}\mathord{.}\Varid{put}\;\Varid{s}_{1}\;\Varid{b},\Varid{r}_{2}\mathord{.}\Varid{put}\;\Varid{s}_{2}\;\Varid{b})\in\Conid{R}{}\<[E]\\
\>[B]{}\Varid{l}_{0}\mathord{.}\Varid{create}\;\Varid{a}\mathrel{=}(\Varid{l}_{1}\mathord{.}\Varid{create}\;\Varid{a},\Varid{l}_{2}\mathord{.}\Varid{create}\;\Varid{a})\in\Conid{R}{}\<[E]\\
\>[B]{}\Varid{r}_{0}\mathord{.}\Varid{create}\;\Varid{b}\mathrel{=}(\Varid{r}_{1}\mathord{.}\Varid{create}\;\Varid{b},\Varid{r}_{2}\mathord{.}\Varid{create}\;\Varid{b})\in\Conid{R}{}\<[E]\ColumnHook
\end{hscode}\resethooks
which also implies the following identities, which we call \emph{twists}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[B]{}\Varid{r}_{1}\mathord{.}\Varid{get}\;(\Varid{l}_{1}\mathord{.}\Varid{put}\;\Varid{s}_{1}\;\Varid{a})\mathrel{=}\Varid{r}_{0}\mathord{.}\Varid{get}\;(\Varid{l}_{1}\mathord{.}\Varid{put}\;\Varid{s}_{1}\;\Varid{a},\Varid{l}_{2}\mathord{.}\Varid{put}\;\Varid{s}_{2}\;\Varid{a})\mathrel{=}\Varid{r}_{2}\mathord{.}\Varid{get}\;(\Varid{l}_{2}\mathord{.}\Varid{put}\;\Varid{s}_{2}\;\Varid{a}){}\<[E]\\
\>[B]{}\Varid{l}_{1}\mathord{.}\Varid{get}\;(\Varid{r}_{1}\mathord{.}\Varid{put}\;\Varid{s}_{1}\;\Varid{b})\mathrel{=}\Varid{l}_{0}\mathord{.}\Varid{get}\;(\Varid{r}_{1}\mathord{.}\Varid{put}\;\Varid{s}_{1}\;\Varid{b},\Varid{r}_{2}\mathord{.}\Varid{put}\;\Varid{s}_{2}\;\Varid{b})\mathrel{=}\Varid{l}_{2}\mathord{.}\Varid{get}\;(\Varid{r}_{2}\mathord{.}\Varid{put}\;\Varid{s}_{2}\;\Varid{b}){}\<[E]\\
\>[B]{}\Varid{r}_{1}\mathord{.}\Varid{get}\;(\Varid{l}_{1}\mathord{.}\Varid{create}\;\Varid{a})\mathrel{=}\Varid{r}_{0}\mathord{.}\Varid{get}\;(\Varid{l}_{1}\mathord{.}\Varid{create}\;\Varid{a},\Varid{l}_{2}\mathord{.}\Varid{create}\;\Varid{a})\mathrel{=}\Varid{r}_{2}\mathord{.}\Varid{get}\;(\Varid{l}_{2}\mathord{.}\Varid{create}\;\Varid{a}){}\<[E]\\
\>[B]{}\Varid{l}_{1}\mathord{.}\Varid{get}\;(\Varid{r}_{1}\mathord{.}\Varid{create}\;\Varid{b})\mathrel{=}\Varid{l}_{0}\mathord{.}\Varid{get}\;(\Varid{r}_{1}\mathord{.}\Varid{create}\;\Varid{b},\Varid{r}_{2}\mathord{.}\Varid{create}\;\Varid{b})\mathrel{=}\Varid{l}_{2}\mathord{.}\Varid{get}\;(\Varid{r}_{2}\mathord{.}\Varid{create}\;\Varid{b}){}\<[E]\ColumnHook
\end{hscode}\resethooks
 
It suffices to
  construct a span \ensuremath{\Varid{sp}\mathrel{=}(\Varid{l},\Varid{r})\mathbin{::}\Conid{S}_{1}\mathbin{{\reflectbox{}}}\Conid{R}\mathbin{{\rightsquigarrow}}\Conid{S}_{2}} satisfying \ensuremath{\Varid{l}\mathbin{;}\Varid{l}_{1}\mathrel{=}\Varid{r}\mathbin{;}\Varid{l}_{2}} and \ensuremath{\Varid{l}\mathbin{;}\Varid{r}_{1}\mathrel{=}\Varid{r}\mathbin{;}\Varid{r}_{2}}.
Define \ensuremath{\Varid{l}} and \ensuremath{\Varid{r}} as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{3}{@{}>{\hspre}l<{\hspost}@{}}\column{23}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[3]{}\Varid{l}\mathord{.}\Varid{get}{}\<[23]\>[23]{}\mathrel{=}\Varid{fst}{}\<[E]\\
\>[3]{}\Varid{l}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;\Varid{s}_{1}'{}\<[23]\>[23]{}\mathrel{=}\Varid{l}_{0}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;\Varid{s}_{1}'){}\<[E]\\
\>[3]{}\Varid{l}\mathord{.}\Varid{create}\;\Varid{s}_{1}{}\<[23]\>[23]{}\mathrel{=}\Varid{l}_{0}\mathord{.}\Varid{create}\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;\Varid{s}_{1}){}\<[E]\\blanklineskip]\>[3]{}\Varid{r}\mathord{.}\Varid{get}{}\<[23]\>[23]{}\mathrel{=}\Varid{snd}{}\<[E]\\
\>[3]{}\Varid{r}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;\Varid{s}_{2}'{}\<[23]\>[23]{}\mathrel{=}\Varid{l}_{0}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;(\Varid{l}_{2}\mathord{.}\Varid{get}\;\Varid{s}_{2}'){}\<[E]\\
\>[3]{}\Varid{r}\mathord{.}\Varid{create}\;\Varid{s}_{2}{}\<[23]\>[23]{}\mathrel{=}\Varid{l}_{0}\mathord{.}\Varid{create}\;(\Varid{l}_{2}\mathord{.}\Varid{get}\;\Varid{s}_{2}){}\<[E]\ColumnHook
\end{hscode}\resethooks

Notice that by construction \ensuremath{\Varid{l}\mathbin{::}\Conid{R}\mathbin{\leadsto}\Conid{S}_{1}} and \ensuremath{\Varid{r}\mathbin{::}\Conid{R}\mathbin{\leadsto}\Conid{S}_{2}}, that
is, since we have used \ensuremath{\Varid{l}_{0}} and \ensuremath{\Varid{r}_{0}} to define \ensuremath{\Varid{l}} and \ensuremath{\Varid{r}}, we do not
need to do any more work to check that the pairs produced by \ensuremath{\Varid{create}}
and \ensuremath{\Varid{put}} remain in \ensuremath{\Conid{R}}.  Notice also that \ensuremath{\Varid{l}} and \ensuremath{\Varid{r}} only use the lenses \ensuremath{\Varid{l}_{1}} and \ensuremath{\Varid{l}_{2}}, not \ensuremath{\Varid{r}_{1}} and \ensuremath{\Varid{r}_{2}}; we will show nevertheless that they satisfy the required properties.



First, to show that \ensuremath{\Varid{l}\mathbin{;}\Varid{l}_{1}\mathrel{=}\Varid{r}\mathbin{;}\Varid{l}_{2}}, we proceed as follows for each
  operation.
For \ensuremath{\Varid{get}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}c<{\hspost}@{}}\column{BE}{@{}l@{}}\column{4}{@{}>{\hspre}l<{\hspost}@{}}\column{6}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[4]{}(\Varid{l}\mathbin{;}\Varid{l}_{1})\mathord{.}\Varid{get}\;(\Varid{s}_{1},\Varid{s}_{2}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{l}_{1}\mathord{.}\Varid{get}\;(\Varid{l}\mathord{.}\Varid{get}\;(\Varid{s}_{1},\Varid{s}_{2})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  definition of \ensuremath{\Varid{l}\mathord{.}\Varid{get}\mathrel{=}\Varid{fst}}, \ensuremath{\Varid{fst}} commutes with \ensuremath{\Varid{get}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{l}_{0}\mathord{.}\Varid{get}\;(\Varid{s}_{1},\Varid{s}_{2}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  reverse reasoning  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}(\Varid{r}\mathbin{;}\Varid{l}_{2})\mathord{.}\Varid{get}\;(\Varid{s}_{1},\Varid{s}_{2}){}\<[E]\ColumnHook
\end{hscode}\resethooks
For \ensuremath{\Varid{put}}, we have:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}c<{\hspost}@{}}\column{BE}{@{}l@{}}\column{4}{@{}>{\hspre}l<{\hspost}@{}}\column{6}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[4]{}(\Varid{l}\mathbin{;}\Varid{l}_{1})\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;\Varid{a}{}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{l}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;(\Varid{l}_{1}\mathord{.}\Varid{put}\;\Varid{s}_{1}\;\Varid{a}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{l}_{0}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;(\Varid{l}_{1}\mathord{.}\Varid{put}\;\Varid{s}_{1}\;\Varid{a})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  \ensuremath{\mathsf{(PutGet)}} for \ensuremath{\Varid{l}_{1}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{l}_{0}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;\Varid{a}{}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  \ensuremath{\mathsf{(PutGet)}} for \ensuremath{\Varid{l}_{2}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{l}_{0}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;(\Varid{l}_{2}\mathord{.}\Varid{get}\;(\Varid{l}_{2}\mathord{.}\Varid{put}\;\Varid{s}_{2}\;\Varid{a})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{r}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;(\Varid{l}_{2}\mathord{.}\Varid{put}\;\Varid{s}_{2}\;\Varid{a}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}(\Varid{r}\mathbin{;}\Varid{l}_{2})\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;\Varid{a}{}\<[E]\ColumnHook
\end{hscode}\resethooks
Finally, for \ensuremath{\Varid{create}} we have:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}c<{\hspost}@{}}\column{BE}{@{}l@{}}\column{4}{@{}>{\hspre}l<{\hspost}@{}}\column{6}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[4]{}(\Varid{l}\mathbin{;}\Varid{l}_{1})\mathord{.}\Varid{create}\;\Varid{a}{}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{l}\mathord{.}\Varid{create}\;(\Varid{l}_{1}\mathord{.}\Varid{create}\;\Varid{a}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{l}_{0}\mathord{.}\Varid{create}\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;(\Varid{l}_{1}\mathord{.}\Varid{create}\;\Varid{a})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  \ensuremath{\mathsf{(CreateGet)}} for \ensuremath{\Varid{l}_{1}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{l}_{0}\mathord{.}\Varid{create}\;\Varid{a}{}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  \ensuremath{\mathsf{(CreateGet)}} for \ensuremath{\Varid{l}_{2}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{l}_{0}\mathord{.}\Varid{create}\;(\Varid{l}_{2}\mathord{.}\Varid{get}\;(\Varid{l}_{2}\mathord{.}\Varid{create}\;\Varid{a})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{r}\mathord{.}\Varid{create}\;(\Varid{l}_{2}\mathord{.}\Varid{create}\;\Varid{a}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}(\Varid{r}\mathbin{;}\Varid{l}_{2})\mathord{.}\Varid{create}\;\Varid{a}{}\<[E]\ColumnHook
\end{hscode}\resethooks


Next, we show that \ensuremath{\Varid{l}\mathbin{;}\Varid{r}_{1}\mathrel{=}\Varid{r}\mathbin{;}\Varid{r}_{2}}.  
For \ensuremath{\Varid{get}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}c<{\hspost}@{}}\column{BE}{@{}l@{}}\column{4}{@{}>{\hspre}l<{\hspost}@{}}\column{6}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[4]{}(\Varid{l}\mathbin{;}\Varid{r}_{1})\mathord{.}\Varid{get}\;(\Varid{s}_{1},\Varid{s}_{2}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{r}_{1}\mathord{.}\Varid{get}\;(\Varid{l}\mathord{.}\Varid{get}\;(\Varid{s}_{1},\Varid{s}_{2})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  definition of \ensuremath{\Varid{l}\mathord{.}\Varid{get}\mathrel{=}\Varid{fst}}, \ensuremath{\Varid{fst}} commutes with \ensuremath{\Varid{r}_{1}\mathord{.}\Varid{get}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{r}_{0}\mathord{.}\Varid{get}\;(\Varid{s}_{1},\Varid{s}_{2}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  reverse above reasoning  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}(\Varid{r}\mathbin{;}\Varid{r}_{2})\mathord{.}\Varid{get}\;(\Varid{s}_{1},\Varid{s}_{2}){}\<[E]\ColumnHook
\end{hscode}\resethooks
For \ensuremath{\Varid{put}}, we have:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}c<{\hspost}@{}}\column{BE}{@{}l@{}}\column{4}{@{}>{\hspre}l<{\hspost}@{}}\column{6}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[4]{}(\Varid{l}\mathbin{;}\Varid{r}_{1})\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;\Varid{b}{}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{l}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;(\Varid{r}_{1}\mathord{.}\Varid{put}\;\Varid{s}_{1}\;\Varid{b}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{l}_{0}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;(\Varid{r}_{1}\mathord{.}\Varid{put}\;\Varid{s}_{1}\;\Varid{b})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Twist equation  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{l}_{0}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;(\Varid{l}_{2}\mathord{.}\Varid{get}\;(\Varid{r}_{2}\mathord{.}\Varid{put}\;\Varid{s}_{2}\;\Varid{b})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{r}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;(\Varid{r}_{2}\mathord{.}\Varid{put}\;\Varid{s}_{2}\;\Varid{b}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}(\Varid{r}\mathbin{;}\Varid{r}_{2})\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;\Varid{b}{}\<[E]\ColumnHook
\end{hscode}\resethooks
Finally, for \ensuremath{\Varid{create}} we have:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}c<{\hspost}@{}}\column{BE}{@{}l@{}}\column{4}{@{}>{\hspre}l<{\hspost}@{}}\column{6}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[4]{}(\Varid{l}\mathbin{;}\Varid{r}_{1})\mathord{.}\Varid{create}\;\Varid{b}{}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{l}\mathord{.}\Varid{create}\;(\Varid{r}_{1}\mathord{.}\Varid{create}\;\Varid{b}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{l}_{0}\mathord{.}\Varid{create}\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;(\Varid{r}_{1}\mathord{.}\Varid{create}\;\Varid{b})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Twist equation  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{l}_{0}\mathord{.}\Varid{create}\;(\Varid{l}_{2}\mathord{.}\Varid{get}\;(\Varid{r}_{2}\mathord{.}\Varid{create}\;\Varid{b})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{r}\mathord{.}\Varid{create}\;(\Varid{r}_{2}\mathord{.}\Varid{create}\;\Varid{b}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}(\Varid{r}\mathbin{;}\Varid{r}_{2})\mathord{.}\Varid{create}\;\Varid{b}{}\<[E]\ColumnHook
\end{hscode}\resethooks


We must also show that \ensuremath{\Varid{l}} and \ensuremath{\Varid{r}} are well-behaved full lenses.  
To show that \ensuremath{\Varid{l}} is well-behaved, we proceed as follows.
For \ensuremath{\mathsf{(GetPut)}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}c<{\hspost}@{}}\column{BE}{@{}l@{}}\column{4}{@{}>{\hspre}l<{\hspost}@{}}\column{5}{@{}>{\hspre}l<{\hspost}@{}}\column{6}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[4]{}\Varid{l}\mathord{.}\Varid{get}\;(\Varid{l}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;\Varid{s}_{1}'){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{fst}\;(\Varid{l}_{0}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;\Varid{s}_{1}')){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  \ensuremath{\Varid{fst}} commutes with \ensuremath{\Varid{put}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{l}_{1}\mathord{.}\Varid{put}\;\Varid{s}_{1}\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;\Varid{s}_{1}')){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  \ensuremath{\mathsf{(GetPut)}} for \ensuremath{\Varid{l}_{1}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{5}{}\<[5]\>[5]{}\Varid{s}_{1}'{}\<[E]\ColumnHook
\end{hscode}\resethooks
For \ensuremath{\mathsf{(PutGet)}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}c<{\hspost}@{}}\column{BE}{@{}l@{}}\column{4}{@{}>{\hspre}l<{\hspost}@{}}\column{6}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[4]{}\Varid{l}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;(\Varid{l}\mathord{.}\Varid{get}\;(\Varid{s}_{1},\Varid{s}_{2})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{l}_{0}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;\Varid{s}_{1}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Eta-expansion for pairs  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}(\Varid{fst}\;(\Varid{l}_{0}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;\Varid{s}_{1})),\Varid{snd}\;(\Varid{l}_{0}\mathord{.}\Varid{put}\;(\Varid{s}_{1},\Varid{s}_{2})\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;\Varid{s}_{1}))){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  \ensuremath{\Varid{fst}}, \ensuremath{\Varid{snd}} commutes with \ensuremath{\Varid{put}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}(\Varid{l}_{1}\mathord{.}\Varid{put}\;\Varid{s}_{1}\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;\Varid{s}_{1}),\Varid{l}_{2}\mathord{.}\Varid{put}\;\Varid{s}_{2}\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;\Varid{s}_{1})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  \ensuremath{\Varid{l}_{1}\mathord{.}\Varid{get}\;\Varid{s}_{1}\mathrel{=}\Varid{l}_{2}\mathord{.}\Varid{get}\;\Varid{s}_{2}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}(\Varid{l}_{1}\mathord{.}\Varid{put}\;\Varid{s}_{1}\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;\Varid{s}_{1}),\Varid{l}_{2}\mathord{.}\Varid{put}\;\Varid{s}_{2}\;(\Varid{l}_{2}\mathord{.}\Varid{get}\;\Varid{s}_{2})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  \ensuremath{\mathsf{(PutGet)}} for \ensuremath{\Varid{l}_{1},\Varid{l}_{2}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}(\Varid{s}_{1},\Varid{s}_{2}){}\<[E]\ColumnHook
\end{hscode}\resethooks
For \ensuremath{\mathsf{(CreateGet)}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}c<{\hspost}@{}}\column{BE}{@{}l@{}}\column{4}{@{}>{\hspre}l<{\hspost}@{}}\column{6}{@{}>{\hspre}l<{\hspost}@{}}\column{7}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[4]{}\Varid{l}\mathord{.}\Varid{create}\;(\Varid{l}\mathord{.}\Varid{get}\;(\Varid{s}_{1},\Varid{s}_{2})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[7]{}\mbox{\commentbegin  Definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\Varid{l}_{0}\mathord{.}\Varid{create}\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;\Varid{s}_{1}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[7]{}\mbox{\commentbegin  Eta-expansion for pairs  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}(\Varid{fst}\;(\Varid{l}_{0}\mathord{.}\Varid{create}\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;\Varid{s}_{1})),\Varid{snd}\;(\Varid{l}_{0}\mathord{.}\Varid{create}\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;\Varid{s}_{1}))){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[7]{}\mbox{\commentbegin  \ensuremath{\Varid{fst}}, \ensuremath{\Varid{snd}} commutes with \ensuremath{\Varid{put}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}(\Varid{l}_{1}\mathord{.}\Varid{create}\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;\Varid{s}_{1}),\Varid{l}_{1}\mathord{.}\Varid{create}\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;\Varid{s}_{1})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  \ensuremath{\Varid{l}_{1}\mathord{.}\Varid{get}\;\Varid{s}_{1}\mathrel{=}\Varid{l}_{2}\mathord{.}\Varid{get}\;\Varid{s}_{2}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}(\Varid{l}_{1}\mathord{.}\Varid{create}\;(\Varid{l}_{1}\mathord{.}\Varid{get}\;\Varid{s}_{1}),\Varid{l}_{1}\mathord{.}\Varid{create}\;(\Varid{l}_{2}\mathord{.}\Varid{get}\;\Varid{s}_{2})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  \ensuremath{\mathsf{(CreateGet)}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}(\Varid{s}_{1},\Varid{s}_{2}){}\<[E]\ColumnHook
\end{hscode}\resethooks
Finally, notice that \ensuremath{\Varid{l}} and \ensuremath{\Varid{r}} are defined symmetrically so
essentially the same reasoning shows \ensuremath{\Varid{r}} is well-behaved.


To conclude, \ensuremath{\Varid{sp}\mathrel{=}(\Varid{l},\Varid{r})} constitutes a span of lenses witnessing that
\ensuremath{\Varid{sp}_{\mathrm{1}}\equiv_{\mathrm{s}} \Varid{sp}_{\mathrm{2}}}.
 \end{proof}

\if 0

\jrcnote{TODO: The following is out of date, and needs to be updated
  if we are keeping these results.}
\restatableTheorem{thm:roundtripping-span-slens1}
\begin{thm:roundtripping-span-slens1}
  If \ensuremath{\Varid{sp}\mathbin{::}\Conid{A}\mathbin{{\reflectbox{}}}\Conid{S}\mathbin{{\rightsquigarrow}}\Conid{B}} is well-behaved, then \ensuremath{\Varid{sp}\equiv \Varid{slens2span}\;(\Varid{span2slens}\;\Varid{sp})}.  
\end{thm:roundtripping-span-slens1}
\begin{proof}
  Take \ensuremath{\Varid{sl}\mathrel{=}\Varid{span2slens}\;\Varid{sp}} and \ensuremath{\Varid{sp'}\mathrel{=}\Varid{slens2span}\;\Varid{sl}}.  Observe that their types are:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[B]{}\Varid{sl}\mathbin{::}\Conid{A}\mathbin{\stackrel{\Conid{Maybe}\;\Conid{S}}{\longleftrightarrow}}\Conid{B}{}\<[E]\\
\>[B]{}\Varid{sp'}\mathbin{::}\Conid{A}\mathbin{{\reflectbox{}}}\Conid{S'}\mathbin{{\rightsquigarrow}}\Conid{B}{}\<[E]\ColumnHook
\end{hscode}\resethooks
where \ensuremath{\Conid{S'}} is the set of all consistent triples \ensuremath{(\Varid{a},\Varid{b},\Varid{mc})} such that \ensuremath{\Varid{sl}\mathord{.}\Varid{mput}_\mathrm{R}\;(\Varid{a},\Varid{mc})\mathrel{=}(\Varid{b},\Varid{mc})} and \ensuremath{\Varid{sl}\mathord{.}\Varid{mput}_\mathrm{L}\;(\Varid{b},\Varid{mc})\mathrel{=}(\Varid{a},\Varid{mc})}.  It is easy to see by the definition of \ensuremath{\Varid{span2slens}} that \ensuremath{\Varid{mc}} is of the form \ensuremath{\Conid{Just}\;\Varid{s}} for some \ensuremath{\Varid{s}} in every consistent triple \ensuremath{(\Varid{a},\Varid{b},\Varid{mc})}, and moreover that consistency entails that \ensuremath{\Varid{a}\mathrel{=}\Varid{sp}\mathord{.}\Varid{left}\mathord{.}\Varid{get}\;\Varid{s}} and \ensuremath{\Varid{b}\mathrel{=}\Varid{sp}\mathord{.}\Varid{right}\mathord{.}\Varid{get}\;\Varid{s}}.

Therefore, it suffices to exhibit an isomorphism between \ensuremath{\Conid{S}} and \ensuremath{\Conid{S'}} that maps the operations of \ensuremath{\Varid{sp}} onto those of \ensuremath{\Varid{sp'}}.  We define an isomorphism \ensuremath{\Varid{h}\mathbin{::}\Conid{S}\to \Conid{S'}} on the state spaces as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[B]{}\Varid{h}\;\Varid{s}\mathrel{=}(\Varid{sp}\mathord{.}\Varid{left}\mathord{.}\Varid{get}\;\Varid{s},\Varid{sp}\mathord{.}\Varid{right}\mathord{.}\Varid{get}\;\Varid{s},\Conid{Just}\;\Varid{s}){}\<[E]\\
\>[B]{}\Varid{h}^{-1}\;(\Varid{a},\Varid{b},\Conid{Just}\;\Varid{s})\mathrel{=}\Varid{s}{}\<[E]\ColumnHook
\end{hscode}\resethooks

It is straightforward (but tedious) to verify that \ensuremath{\Varid{h}\mathbin{;}\Varid{sp}\mathord{.}\Varid{left}\mathrel{=}\Varid{sp'}\mathord{.}\Varid{left}} and \ensuremath{\Varid{h}\mathbin{;}\Varid{sp}\mathord{.}\Varid{right}\mathrel{=}\Varid{sp'}\mathord{.}\Varid{right}}.
\jrcnote{Show one side?}
\end{proof}

\restatableTheorem{thm:roundtripping-span-slens2}
\begin{thm:roundtripping-span-slens2}
  If \ensuremath{\Varid{sl}\mathbin{::}\Conid{SLens}\;\Conid{C}\;\Conid{A}\;\Conid{B}} is well-behaved then \ensuremath{\Varid{sl}\equiv_{\mathrm{sl}} \Varid{span2slens}\;(\Varid{slens2span}\;\Varid{sl})}.
\end{thm:roundtripping-span-slens2}
\begin{proof}
Take  \ensuremath{\Varid{sp}\mathrel{=}\Varid{slens2span}\;\Varid{sl}} and \ensuremath{\Varid{sl'}\mathrel{=}\Varid{bx2slens}\;\Varid{sp}}.  Observe that their types are:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[B]{}\Varid{sp}\mathbin{::}\Conid{A}\mathbin{{\reflectbox{}}}\Conid{S}\mathbin{{\rightsquigarrow}}\Conid{B}{}\<[E]\\
\>[B]{}\Varid{sl}\mathbin{::}\Conid{A}\mathbin{\stackrel{\Conid{Maybe}\;\Conid{S'}}{\longleftrightarrow}}\Conid{B}{}\<[E]\ColumnHook
\end{hscode}\resethooks
where \ensuremath{\Conid{S'}} is the set of consistent triples \ensuremath{(\Varid{a},\Varid{b},\Varid{c})} where \ensuremath{\Varid{sl}\mathord{.}\Varid{put}_\mathrm{R}\;(\Varid{a},\Varid{c})\mathrel{=}(\Varid{b},\Varid{c})} and \ensuremath{\Varid{sl}\mathord{.}\Varid{put}_\mathrm{L}\;(\Varid{b},\Varid{c})\mathrel{=}(\Varid{a},\Varid{c})}.

Towards showing that \ensuremath{\Varid{sl}} and \ensuremath{\Varid{sl'}} are equivalent (according to
Definition~\ref{def:hpw-equiv}), we need a relation on the state
spaces \ensuremath{\Conid{S}} and \ensuremath{\Conid{Maybe}\;\Conid{S'}}. Define relation \ensuremath{\Varid{r}} as \ensuremath{\{\mskip1.5mu (\Varid{sl}\mathord{.}\Varid{missing},\Conid{Nothing})\mskip1.5mu\}\cup\{\mskip1.5mu (\Varid{s},\Conid{Just}\;(\Varid{a},\Varid{b},\Varid{s}))\mid (\Varid{a},\Varid{b},\Varid{s})\in\Conid{S'}\mskip1.5mu\}}.

We now proceed to check the conditions on \ensuremath{\Varid{r}} needed to conclude \ensuremath{\Varid{sl}\equiv_{\mathrm{sl}} \Varid{sl'}}.  First, for part (a), note that \ensuremath{\Varid{sl'}\mathord{.}\Varid{missing}\mathrel{=}\Conid{Nothing}}, so \ensuremath{(\Varid{sl}\mathord{.}\Varid{missing},\Varid{sl'}\mathord{.}\Varid{missing})\in\Varid{r}}.

Next, for part (b), we wish to show that \ensuremath{\Varid{sl}\mathord{.}\Varid{put}_\mathrm{R} \sim_{\Varid{r}} \Varid{sl'}\mathord{.}\Varid{put}_\mathrm{R}}.
Suppose that \ensuremath{(\Varid{s}_{1},\Varid{s}_{2})\in\Varid{r}}, and let \ensuremath{\Varid{x}} be given. 
Let
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}\column{11}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[B]{}(\Varid{y},\Varid{s}_{1}'){}\<[11]\>[11]{}\mathrel{=}\Varid{sl}\mathord{.}\Varid{put}_\mathrm{R}\;(\Varid{x},\Varid{s}_{1}){}\<[E]\\
\>[B]{}(\Varid{y'},\Varid{s}_{2}'){}\<[11]\>[11]{}\mathrel{=}\Varid{sl'}\mathord{.}\Varid{put}_\mathrm{R}\;(\Varid{x},\Varid{s}_{2}){}\<[E]\ColumnHook
\end{hscode}\resethooks
We need to show that \ensuremath{\Varid{y}\mathrel{=}\Varid{y'}} and \ensuremath{(\Varid{s}_{1}',\Varid{s}_{2}')\in\Varid{r}}.  There are two cases: either \ensuremath{\Varid{s}_{2}\mathrel{=}\Conid{Nothing}} or \ensuremath{\Varid{s}_{2}\mathrel{=}\Conid{Just}\;\Varid{s}}.

Case \ensuremath{\Varid{s}_{2}\mathrel{=}\Conid{Nothing}}: \jrcnote{TODO: Redo this?}
We first simplify as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}c<{\hspost}@{}}\column{BE}{@{}l@{}}\column{4}{@{}>{\hspre}l<{\hspost}@{}}\column{6}{@{}>{\hspre}l<{\hspost}@{}}\column{9}{@{}>{\hspre}l<{\hspost}@{}}\column{42}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[4]{}\Varid{sl'}\mathord{.}\Varid{put}_\mathrm{R}\;(\Varid{x},\Conid{Nothing}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{let}\;{}\<[9]\>[9]{}(\Varid{b'},\Varid{s'})\mathrel{=}bx\mathord{.}\Varid{igetR}\;(bx\mathord{.}\Varid{initL}\;\Varid{x})\;\mathbf{in}\;(\Varid{b'},\Conid{Just}\;\Varid{s'}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  definition of \ensuremath{bx\mathord{.}\Varid{igetR}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{let}\;(\Varid{b'},\Varid{s'})\mathrel{=}\Varid{gets}\;\Varid{snd3}\;(bx\mathord{.}\Varid{initL}\;\Varid{x})\;\mathbf{in}\;(\Varid{b'},\Conid{Just}\;\Varid{s'}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  definition of \ensuremath{\Varid{initL}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{let}\;(\Varid{b'},\Varid{s'})\mathrel{=}\Varid{gets}\;\Varid{snd3}\;({}\<[42]\>[42]{}\mathbf{let}\;(\Varid{b},\Varid{c})\mathrel{=}\Varid{sl}\mathord{.}\Varid{put}_\mathrm{R}\;(\Varid{x},\Varid{sl}\mathord{.}\Varid{missing})\;\mathbf{in}\;(\Varid{x},\Varid{b},\Varid{c})){}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{in}\;(\Varid{b'},\Conid{Just}\;\Varid{s'}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  rearrange \ensuremath{\mathbf{let}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{let}\;{}\<[9]\>[9]{}(\Varid{b},\Varid{c})\mathrel{=}\Varid{sl}\mathord{.}\Varid{put}_\mathrm{R}\;(\Varid{x},\Varid{sl}\mathord{.}\Varid{missing}){}\<[E]\\
\>[9]{}(\Varid{b'},\Varid{s'})\mathrel{=}\Varid{gets}\;\Varid{snd3}\;(\Varid{x},\Varid{b},\Varid{c}){}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{in}\;(\Varid{b'},\Conid{Just}\;\Varid{s'}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  simplify \ensuremath{\Varid{gets}\;\Varid{snd3}\;(\Varid{x},\Varid{b},\Varid{c})\mathrel{=}(\Varid{b},(\Varid{x},\Varid{b},\Varid{c}))}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{let}\;{}\<[9]\>[9]{}(\Varid{b},\Varid{c})\mathrel{=}\Varid{sl}\mathord{.}\Varid{put}_\mathrm{R}\;(\Varid{x},\Varid{sl}\mathord{.}\Varid{missing}){}\<[E]\\
\>[9]{}(\Varid{b'},\Varid{s'})\mathrel{=}(\Varid{b},(\Varid{x},\Varid{b},\Varid{c})){}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{in}\;(\Varid{b'},\Conid{Just}\;\Varid{s'}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  simplify  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{let}\;{}\<[9]\>[9]{}(\Varid{b},\Varid{c})\mathrel{=}\Varid{sl}\mathord{.}\Varid{put}_\mathrm{R}\;(\Varid{x},\Varid{sl}\mathord{.}\Varid{missing})\;\mathbf{in}\;(\Varid{b},\Conid{Just}\;(\Varid{x},\Varid{b},\Varid{c})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  assumption  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{let}\;(\Varid{b},\Varid{c})\mathrel{=}(\Varid{y},\Varid{s}_{1}')\;\mathbf{in}\;(\Varid{b},\Conid{Just}\;(\Varid{x},\Varid{b},\Varid{c})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  simplify  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}(\Varid{y},\Conid{Just}\;(\Varid{x},\Varid{y},\Varid{s}_{1}')){}\<[E]\ColumnHook
\end{hscode}\resethooks
Thus, \ensuremath{\Varid{y'}\mathrel{=}\Varid{y}} and \ensuremath{\Varid{s}_{2}'\mathrel{=}\Conid{Just}\;(\Varid{x},\Varid{y},\Varid{s}_{1}')}.  Moreover, \ensuremath{(\Varid{s}_{1}',\Conid{Just}\;(\Varid{x},\Varid{b},\Varid{s}_{1}'))\in\Varid{r}}.  


Case \ensuremath{\Varid{s}_{2}\mathrel{=}\Conid{Just}\;\Varid{s}}. \jrcnote{TODO: Redo?} We first simplify as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}c<{\hspost}@{}}\column{BE}{@{}l@{}}\column{4}{@{}>{\hspre}l<{\hspost}@{}}\column{6}{@{}>{\hspre}l<{\hspost}@{}}\column{9}{@{}>{\hspre}l<{\hspost}@{}}\column{33}{@{}>{\hspre}l<{\hspost}@{}}\column{34}{@{}>{\hspre}l<{\hspost}@{}}\column{E}{@{}>{\hspre}l<{\hspost}@{}}\>[4]{}\Varid{sl'}\mathord{.}\Varid{put}_\mathrm{R}\;(\Varid{x},\Conid{Just}\;\Varid{s}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{let}\;(\Varid{b},\Varid{s'})\mathrel{=}\mathbf{do}\;\{\mskip1.5mu bx\mathord{.}\Varid{isetL}\;\Varid{x};bx\mathord{.}\Varid{igetR}\mskip1.5mu\}\;\Varid{s}\;\mathbf{in}\;(\Varid{b},\Conid{Just}\;\Varid{s'}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  Definition  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{let}\;(\Varid{b},\Varid{s'})\mathrel{=}\mathbf{do}\;\{\mskip1.5mu {}\<[33]\>[33]{}(\Varid{a},\Varid{b},\Varid{c})\leftarrow \Varid{get};{}\<[E]\\
\>[33]{}\mathbf{let}\;(\Varid{b'},\Varid{c'})\mathrel{=}\Varid{sl}\mathord{.}\Varid{put}_\mathrm{R}\;(\Varid{x},\Varid{c});{}\<[E]\\
\>[33]{}\Varid{set}\;(\Varid{x},\Varid{b'},\Varid{c'});{}\<[E]\\
\>[33]{}(\Varid{a''},\Varid{b''},\Varid{c''})\leftarrow \Varid{get};\Varid{return}\;\Varid{b''}\mskip1.5mu\}\;\Varid{s}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{in}\;(\Varid{b},\Conid{Just}\;\Varid{s'}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  \ensuremath{\Varid{labelSG}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{let}\;(\Varid{b},\Varid{s'})\mathrel{=}\mathbf{do}\;\{\mskip1.5mu {}\<[33]\>[33]{}(\Varid{a},\Varid{b},\Varid{c})\leftarrow \Varid{get};{}\<[E]\\
\>[33]{}\mathbf{let}\;(\Varid{b'},\Varid{c'})\mathrel{=}\Varid{sl}\mathord{.}\Varid{put}_\mathrm{R}\;(\Varid{x},\Varid{c});{}\<[E]\\
\>[33]{}\Varid{set}\;(\Varid{x},\Varid{b'},\Varid{c'});\Varid{return}\;\Varid{b'}\mskip1.5mu\}\;\Varid{s}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{in}\;(\Varid{b},\Conid{Just}\;\Varid{s'}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  \ensuremath{\Varid{s}\mathrel{=}(\Varid{a}_{0},\Varid{b}_{0},\Varid{c}_{0})}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{let}\;(\Varid{b},\Varid{s'})\mathrel{=}\mathbf{do}\;\{\mskip1.5mu {}\<[33]\>[33]{}(\Varid{a},\Varid{b},\Varid{c})\leftarrow \Varid{get};{}\<[E]\\
\>[33]{}\mathbf{let}\;(\Varid{b'},\Varid{c'})\mathrel{=}\Varid{sl}\mathord{.}\Varid{put}_\mathrm{R}\;(\Varid{x},\Varid{c});{}\<[E]\\
\>[33]{}\Varid{set}\;(\Varid{x},\Varid{b'},\Varid{c'});\Varid{return}\;\Varid{b'}\mskip1.5mu\}\;(\Varid{a}_{0},\Varid{b}_{0},\Varid{c}_{0}){}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{in}\;(\Varid{b},\Conid{Just}\;\Varid{s'}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  definition of \ensuremath{\Varid{get}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{let}\;(\Varid{b},\Varid{s'})\leftarrow \mathbf{do}\;\{\mskip1.5mu {}\<[34]\>[34]{}\mathbf{let}\;(\Varid{b'},\Varid{c'})\mathrel{=}\Varid{sl}\mathord{.}\Varid{put}_\mathrm{R}\;(\Varid{x},\Varid{c}_{0});{}\<[E]\\
\>[34]{}\Varid{set}\;(\Varid{x},\Varid{b'},\Varid{c'});\Varid{return}\;\Varid{b'}\mskip1.5mu\}\;(\Varid{a}_{0},\Varid{b}_{0},\Varid{c}_{0}){}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{in}\;(\Varid{b},\Conid{Just}\;\Varid{s'}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  lift \ensuremath{\mathbf{let}} out of \ensuremath{\mathbf{do}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{let}\;{}\<[9]\>[9]{}(\Varid{b'},\Varid{c'})\mathrel{=}\Varid{sl}\mathord{.}\Varid{put}_\mathrm{R}\;(\Varid{x},\Varid{c}_{0}){}\<[E]\\
\>[9]{}(\Varid{b},\Varid{s'})\mathrel{=}\mathbf{do}\;\{\mskip1.5mu {}\<[34]\>[34]{}\Varid{set}\;(\Varid{x},\Varid{b'},\Varid{c'});\Varid{return}\;\Varid{b'}\mskip1.5mu\}\;(\Varid{a}_{0},\Varid{b}_{0},\Varid{c}_{0}){}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{in}\;(\Varid{b},\Conid{Just}\;\Varid{s'}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  definition of \ensuremath{\Varid{set}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{let}\;{}\<[9]\>[9]{}(\Varid{b'},\Varid{c'})\mathrel{=}\Varid{sl}\mathord{.}\Varid{put}_\mathrm{R}\;(\Varid{x},\Varid{c}_{0}){}\<[E]\\
\>[9]{}(\Varid{b},\Varid{s'})\mathrel{=}\mathbf{do}\;\{\mskip1.5mu {}\<[34]\>[34]{}\Varid{return}\;\Varid{b'}\mskip1.5mu\}\;(\Varid{x},\Varid{b'},\Varid{c'})\;\mathbf{in}\;(\Varid{b},\Conid{Just}\;\Varid{s'}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  definition of \ensuremath{\Varid{return}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{let}\;{}\<[9]\>[9]{}(\Varid{b'},\Varid{c'})\mathrel{=}\Varid{sl}\mathord{.}\Varid{put}_\mathrm{R}\;(\Varid{x},\Varid{c}_{0}){}\<[E]\\
\>[9]{}(\Varid{b},\Varid{s'})\mathrel{=}\Varid{return}\;(\Varid{b'},(\Varid{x},\Varid{b'},\Varid{c'}))\;\mathbf{in}\;\Varid{return}\;(\Varid{b},\Conid{Just}\;\Varid{s'}){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  inline \ensuremath{\mathbf{let}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{let}\;(\Varid{b'},\Varid{c'})\mathrel{=}\Varid{sl}\mathord{.}\Varid{put}_\mathrm{R}\;(\Varid{x},\Varid{c}_{0})\;\mathbf{in}\;\Varid{return}\;(\Varid{b'},\Conid{Just}\;(\Varid{x},\Varid{b'},\Varid{c'})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  assumption  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}\mathbf{let}\;(\Varid{b'},\Varid{c'})\mathrel{=}(\Varid{y},\Varid{s}_{1}')\;\mathbf{in}\;(\Varid{b'},\Conid{Just}\;(\Varid{x},\Varid{b'},\Varid{c'})){}\<[E]\\
\>[B]{}\mathrel{=}{}\<[BE]\>[6]{}\mbox{\commentbegin  inline \ensuremath{\mathbf{let}}  \commentend}{}\<[E]\\
\>[B]{}\hsindent{4}{}\<[4]\>[4]{}(\Varid{y},\Conid{Just}\;(\Varid{x},\Varid{y},\Varid{s}_{1}')){}\<[E]\ColumnHook
\end{hscode}\resethooks
Thus, \ensuremath{\Varid{y'}\mathrel{=}\Varid{y}} and \ensuremath{\Varid{s}_{2}\mathrel{=}\Conid{Just}\;(\Varid{x},\Varid{y},\Varid{s}_{1}')}.  Moreover, \ensuremath{(\Varid{s}_{1}',\Conid{Just}\;(\Varid{x},\Varid{y},\Varid{s}_{1}'))\in\Varid{r}}.  
Therefore, in either case \ensuremath{\Varid{sl}\mathord{.}\Varid{put}_\mathrm{R} \sim_{\Varid{r}} \Varid{sl'}\mathord{.}\Varid{put}_\mathrm{R}} holds.  
The proof of part (c), that \ensuremath{\Varid{sl}\mathord{.}\Varid{put}_\mathrm{L} \sim_{\Varid{r}} \Varid{sl'}\mathord{.}\Varid{put}_\mathrm{L}} holds, is similar, so we conclude that \ensuremath{\Varid{sl}\equiv \Varid{sl'}}.
\end{proof}
\fi



\end{document}
