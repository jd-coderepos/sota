\documentclass[twocolumn]{article}

\usepackage[english]{babel}
\usepackage{amsmath,amssymb,amsthm}
\usepackage[algo2e,lined,linesnumbered,ruled,noend]{algorithm2e}
\usepackage{graphicx}
\graphicspath{{./pics/}}

\usepackage{float}

\usepackage{subfigure}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{theorem}{Theorem}

\usepackage{placeins}
\usepackage{url}

\pagestyle{headings}
\newcounter{observationctr} \setcounter{observationctr}{0}
\newenvironment{observation}[1] {
\refstepcounter{observationctr}\vspace{0.2cm}\noindent{\bf Observation \arabic{observationctr}. }#1}{\par}

\newcommand{\depends}[1]{}

\newcommand{\state}[3]{\ensuremath{(#2^{#3})#1}}
\newcommand{\uim}{\state{u}{i}{-}}
\newcommand{\vim}{\state{v}{i}{-}}
\newcommand{\wim}{\state{w}{i}{-}}
\newcommand{\uip}{\state{u}{i}{+}}
\newcommand{\vip}{\state{v}{i}{+}}
\newcommand{\wip}{\state{w}{i}{+}}
\newcommand{\uimm}{\state{u}{(i-1)}{-}}
\newcommand{\vimm}{\state{v}{(i-1)}{-}}
\newcommand{\wimm}{\state{w}{(i-1)}{-}}
\newcommand{\uimp}{\state{u}{(i-1)}{+}}
\newcommand{\vimp}{\state{v}{(i-1)}{+}}
\newcommand{\wimp}{\state{w}{(i-1)}{+}}
\newcommand{\uipm}{\state{u}{(i+1)}{-}}
\newcommand{\vipm}{\state{v}{(i+1)}{-}}
\newcommand{\wipm}{\state{w}{(i+1)}{-}}
\newcommand{\uipp}{\state{u}{(i+1)}{+}}
\newcommand{\vipp}{\state{v}{(i+1)}{+}}
\newcommand{\wipp}{\state{w}{(i+1)}{+}}

\usepackage{tikz}
\usetikzlibrary{shapes}
\usetikzlibrary{arrows,petri,topaths}
\usetikzlibrary{decorations.pathmorphing}
\usetikzlibrary{decorations.markings}
\tikzstyle{vertex}=[circle, draw, inner sep=0pt, minimum size=6pt]
\newcommand{\vertex}{\node[vertex]}

\newcommand{\G}{\mathcal{G}}
\newcommand{\T}{\mathcal{T}}
\newcommand{\F}{\mathcal{F}}
\newcommand{\pre}{pre}
\newcommand{\post}{post}
\newcommand{\adds}{\ensuremath{\overset{+}{\gets}}} 

\SetKwFor{ForAll}{forall}{do}{end forall}

\SetKwComment{com}{//}{}
 \SetKwComment{point}{}{}
 \SetKwFor{UpOnTimer}{New round}{do}{end}
 \SetKwInput{Init}{Initial state}
  \SetKwInput{Sending}{Sending}
    \SetKwInput{Reception}{Reception}
      \SetKwInput{compute}{Computation on a node }
  \SetKwInput{PreCompute}{Pre-compute on a node }
    \SetKwInput{PostCompute}{Post-compute on a node }
    \SetKwInput{Round}{Forever Do}
    \SetKwInput{Initialization}{Initialization}
    \SetKwInput{Round}{Execution of a round (forever loop)}
\SetKwInput{Data}{Each node has}
 

\let\oldnl\nl
\newcommand{\nonl}{\renewcommand{\nl}{\let\nl\oldnl}}

\newcommand{\comm}[1]{\com{\ \color{gray}#1}}
 
\begin{document}

\title{Maintaining a Distributed Spanning Forest in Highly Dynamic Networks
\thanks{A preliminary version of this work (without proofs of correctness and much revisited since) was presented at the 18th Int. Conf. on Principles of Distributed Systems (OPODIS, 2014).}
}

\author{Matthieu Barjon, Arnaud Casteigts, Serge Chaumette, Colette Johnen, and Yessin M. Neggaz\bigskip\\
LaBRI, CNRS, University of Bordeaux}
\date{}

\maketitle

\begin{abstract}
  Highly dynamic networks are characterized by frequent changes in the availability of communication links. These networks are often partitioned into several components, which split and merge unpredictably. We present a distributed algorithm that maintains a forest of (as few as possible) spanning trees in such a network, with no restriction on the rate of change. Our algorithm is inspired by high-level graph transformations, which we adapt here in a (synchronous) message passing model for dynamic networks. The resulting algorithm
has the following properties: First, every decision is purely local---in each round, a node only considers its role and that of its neighbors in the tree, with no further information propagation (in particular, no wave mechanisms). Second, whatever the rate and scale of the changes, the algorithm guarantees that, by the end of every round, the network is covered by a forest of spanning trees in which 1) no cycle occur, 2) every node belongs to exactly one tree, and 3) every tree contains exactly one root (or token). 
We primarily focus on the correctness of this algorithm, which is established rigorously. While performance is not the main focus, we suggest new complexity metrics for such problems, and report on preliminary experimentation results validating our algorithm in a practical scenario.
\end{abstract}



\section{Introduction}

The current development of mobile and wireless technologies enables direct {\it ad hoc} communication between various kinds of mobile entities, such as vehicles, smartphones, terrestrian robots, flying robots, or satellites. In all these contexts, the set of communication links between entities (network topology) changes continuously. Not only changes are frequent, but in general they are unpredictable and can make the network partitioned at any time. Clearly, the usual assumption of connectivity does not hold here. Also, the classical view of a network whose dynamics corresponds to {\em failures} is no longer suitable in these scenarios, where dynamics is the norm rather than the exception. 

This shift in paradigm impacts algorithms and the definition of problems all together. What does it mean, for instance, to elect a leader in a partitioned network? Is the objective to distinguish a unique global leader, whose leadership materialize over time and space, or is it rather to {\em maintain} a unique leader in each connected component, deleting one when two partitions merge and creating a new one when a partition splits? 
The same remark holds for spanning trees. Should an algorithm construct a unique, global tree whose logical edges survive network intermittence, or should it build and maintain a {\em forest} of trees, each of which spans a (as large as possible) part of the network in a classical way? Both viewpoints make sense, and have been considered {\it e.g.} in~\cite{AE84,CFMS12} (former interpretation) or ~\cite{Awerbuch08,CCGP13} (second interpretation).

In this paper, we focus on the second interpretation, which reflects a variety of scenarios where the expected output of the algorithm should relate to the {\em immediate} configuration of the network ({\it e.g.} several subgroups of robots or drones, each subgroup having a spanning tree for coordination). A particular feature of this type of algorithms is that termination never occurs. More significantly, and perhaps differently to self-stabilization, it may happen that the execution never stabilizes ({\it i.e.}, changes are too frequent to converge to a {\em single} tree per component). This precludes approaches where the computation of a new solution requires the previous computation to have completed, which is an important fact. 


The present work is an attempt at understanding what can still be computed (and guaranteed) in terms of spanning trees in such dynamic networks, with no assumptions as to the rate of change, their simultaneity, or global connectivity. In this seemingly chaotic context, we present an algorithm that strives to maintain as few trees per components as possible, while {\em always} guaranteeing key properties.

\subsection{Related work}

Several works have addressed the spanning tree problem in dynamic networks, with different goals and assumptions. Burman and Kutten~\cite{asynchronous} and Kravchik and Kutten~\cite{synchronous} consider a self-stabilizing approach where the legal state corresponds to having a (single) minimum spanning tree and the faults are topological changes. The strategy consists in recomputing the entire tree when a change occurs. This general approach, sometimes called the ``blast away'' approach, is meaningful if stable periods of time exist, which is not the case in (unrestricted) highly dynamic networks.

A number of spanning tree algorithms use random walks for their elegance and simplicity, as well as for their inherent locality. In particular, approaches that involve multiple coalescing random walks allow for uniform initialization (each node starts in the same state) and topology independence (same strategy whatever the graph). Pionneering studies involving such processes include Bar-Ilan and Zernik~\cite{BZ89} (for the problem of election and spanning tree), Israeli and Jalfon~\cite{IJ90} (mutual exclusion), and Chapter 14 of Aldous and Fill~\cite{AF02} (general analysis). 

The principle of using coalescing random walks to build spanning trees in mildly dynamic networks was used by Baala et al.~\cite{mosbah-tree} and Abbas et al.~\cite{Baala03}, where tokens are annexing territories gradually by capturing each other. Regarding dynamicity, both algorithms require the nodes to know (an upper bound on) the cover time of the random walk, in order to regenerate a token if they have not been visited for some time. Besides the strength of this assumption (akin to knowing the number of nodes , or the size of components in our case), the efficiency of the timeout approach decreases dramatically with the rate of topological changes. In particular, if they are more frequent than the cover time (itself in ), then the tree is constantly fragmented into ``dead'' root-less ({\it i.e.} leader-less) pieces.







Another algorithm based on random walks is proposed by Bernard et al.~\cite{BBS13}. Here, the tree is constantly redefined as the token moves (in a way that reminds the snake game). Since the token moves only over present edges, those edges that have disappeared are naturally cleaned out of the tree as the walk proceeds. Hence, the algorithm can tolerate failure of the tree edges. However it still suffers from detecting the disappearance of tokens using timeouts based on the cover time, which as we have seen, suits only slow dynamics.





A recent work by Awerbuch et al.~\cite{Awerbuch08} addresses the maintenance of {\em minimum} spanning trees in dynamic networks. The paper shows that a solution to the problem can be updated after a topological change using  messages (and same time), while the  messages of the ``blast away'' approach was thought to be optimal. (This demonstrates, incidentally, the revelance of {\em updating} a solution rather than recomputing it from scratch in the case of minimum spanning trees.) The algorithm has good properties for highly dynamic networks. For instance, it considers as natural the fact that components may split or merge perpetually. Furthermore, it tolerates new topological events while an ongoing update operation is executing. In this case, update operations are enqueued and consistently executed one after the other. While this mechanism allows for an arbitrary number of topological events {\em at times}, it still requires that such burst of changes are only episodical and that the network remains eventually stable for (at least) a linear amount of time in the number of nodes, in order for the update operations to complete and thus the logical tree to be consistent with physical reality.

All the aforementioned algorithms either assume that {\em global update} operations (e.g. wave mechanisms) can be performed regularly, or that some node can collect {\em global information} about the tree structure. As far as dynamics is concerned, this forbids arbitrary and ever going changes to occur in the network. 
 



\subsection{A high-level (graph-level) mechanism.}
\label{sec:principle}



A high-level graph scheme was proposed in~\cite{CCGP13} for the maintenance of a spanning forest (not necessarily minimum) in unrestricted dynamic networks, using a coarse grain interaction model inspired from graph relabeling systems~\cite{GRS01} (bearing some common traits with so-called population protocols~\cite{AAD+06}). It can be described informally as follows. Initially every node hosts a token and is the {\em root} of its own individual tree. Whenever two roots/tokens are located at both {\em endpoints} of a same edge (see merging rule on Figure~\ref{fig:scheme}), one of them is destroyed and the underlying node selects the other as parent: both trees (of arbitrary size) are merged locally and instantly. In absence of merging opportunity, the tokens execute a random walk within their own tree in the hope for (farther) merging opportunities (see circulation rule on Figure~\ref{fig:scheme}). As they circulate, the tokens flip (again, locally) the parent-child relations so that a directed path from any node in the tree towards its root is maintained. The fact that the random walk takes place {\em within the tree} (as opposed to the whole network) is crucial for this property. In fact, this simple feature is what enables to recover a consistent state immediately after an edge of the tree has disappeared. Indeed, it suffices for the child side of the lost edge to regenerate a new token/root, while being safe that no other node in the tree can do so (see reparation rule on Figure~\ref{fig:scheme}). In conclusion, this scheme allows for {\em all} operations to be handled in a purely localized fashion (let apart global convergence).

\begin{figure}[h]
  \centering
  \subfigure[Merging rule]{
    \begin{tikzpicture}[scale=.8]
      \clip (-2,-1.2) rectangle (1,.2);
      \tikzstyle{every node}=[draw,circle,fill=black!80,inner sep=1.8pt]
      \path (-1,0) node (v11) {};
      \path (.1,0) node (v12) {};
      \path (-1,-1) node (v21) {};
      \path (.1,-1) node[fill=white] (v22) {};
      \draw[dashed] (v11)-- coordinate[midway](mid1) (v12);
      \draw[very thick,<-] (v21)-- coordinate[midway](mid2)(v22);
      \draw[thick, gray!70, shorten >=6pt, shorten <=6pt] (mid1) edge[->] (mid2);
      \tikzstyle{every node}=[font=\footnotesize,above=2pt]
    \end{tikzpicture}
  }\hspace{1cm}
  \subfigure[Circulation rule]{
    \begin{tikzpicture}[scale=.8]
      \clip (-2.3,-1.2) rectangle (1.3,.2);
      \tikzstyle{every node}=[draw,circle,fill=black!80,inner sep=1.8pt]
      \path (-1,0) node (v11) {};
      \path (.1,0) node[fill=white] (v12) {};
      \path (-1,-1) node[fill=white] (v21) {};
      \path (.1,-1) node (v22) {};
      \draw[very thick,<-] (v11)--(v12);
      \draw[very thick,->] (v21)--(v22);
      \draw[thick, gray!70, shorten >=6pt, shorten <=6pt] (mid1) edge[->] (mid2);
      \tikzstyle{every node}=[font=\footnotesize,above=2pt]
    \end{tikzpicture}
  }\hspace{1cm}
  \subfigure[Regeneration rule]{
    \begin{tikzpicture}[scale=.8]
      \clip (-3.3,-1.2) rectangle (.3,.2);
      \tikzstyle{every node}=[draw,circle,fill=black!80,inner sep=1.8pt]
      \path (-2,0) node[fill=white] (v11) {};
      \path (-2,-1) node (v21) {};
      \tikzstyle{every node}=[]
      \path (-.9,0) node[gray] (v12) {\hspace{-1.1cm} \LARGE };
      \draw[very thick, ->] (v11)--(v12);
      \draw[thick, gray!70, ->, shorten >=4pt, shorten <=4pt] (v11)--(v21);
    \end{tikzpicture}
  }
  \caption{\label{fig:scheme} Spanning forest principle (high-level representation). {\it Black nodes are those having a token. Black directed edges denote child-to-parent relationships. Gray vertical arrows represent transitions.}}
\end{figure}


More precisely, at a graph level, this scheme guarantees that the network remains covered by a spanning forest at any time, in which 1) no cycle ever appears, 2) maximal subtrees always are directed rooted trees (with a token at the root), and 3) every node always belongs to such a tree, and so, whatever the rate and scale of topological changes. As to performance, analyzing it requires first to define what metric is relevant in this context. It is not expected that the rate of changes allows {\em any} algorithm to converge towards a single tree per connected component (which is, in a sense, the optimal state in such problem). Before such concerns, a more important question remained to be answered as to whether such a mechanism could be implemented in more conventional message passing models.

\subsection{Our contribution.}

We present the first adaptation of the above mechanism into the synchronous message passing model from~\cite{KLO10}. Due to the loss of atomicity (in particular, the loss of exclusivity) in the interaction, the algorithm turns out to be much more sophisticated than its graph-level counterpart. While still reflecting the same abstract principle, it faces problems that require conceptual differences. In particular, the original model prevented (conveniently) a node to select a parent at the same time as it is itself selected as parent by another node, thereby making cycle avoidance straightforward. One of the ingredients in the new algorithm to circumvent this type of problem is an original technique (referred to as the {\em unique score} technique) that consists of maintaining, network-wide, a set of {\tt score} variables that always remain a permutation of the set of nodes IDs. This mechanism allows us to break symmetry and avoid the formation of cycles in a context where IDs alone did not suffice. (We believe this technique is of independent interest.)
The paper is organized as follows. In Section~\ref{sec:model}, we present the synchronous message passing model from~\cite{KLO10}, slightly adapted (in an equivalent way) and notations that we use throughout the paper. Then, Section~\ref{sec:algorithm} presents the algorithm, whose correctness analysis is developped through Section~\ref{sec:correctness}. Finally, Section~\ref{sec:simulation} discussed some aspects regarding to performance, which includes preliminary experimental results, which can be seen as (partial) practical validation of our algorithm.


\section{Model and notations}
\label{sec:model}

The network is represented by a graph sequence , such that , where  is a fixed set of vertices and  is a dynamically changing set of undirected edges. 
Following Kuhn et al.~\cite{KLO10}, we consider a synchronous (rounded) computational model, where in each round , the set of edges  determines what nodes communicate. At the beginning of each round, each node sends a message that was prepared at the end of the previous round. This message is sent to all its neighbors in , although the list of these neighbors is a priori {\em unknown} to the node. Then, it receives all messages sent by its neighbors (in the same round), and finally computes its new state and its message for the next round. Due to the reciprocity of undirected links, a node {\em can} determine upon reception which nodes have received its own message. In summary, each round corresponds to three phases {\tt (send, receive, compute)}, which corresponds to a rotation of the original model of~\cite{KLO10} where the phases are {\tt (compute, send, receive)}. This adaptation is not necessary, but makes the expression of our algorithm and of its correctness simpler. In particular, correctness predicates are satisfied by the {\em end} of each round (as opposed to the middle of each round if the original model had been used).




The nodes possess unique identifiers taken from a totally ordered set; that is, for any two nodes  and , it either holds that  or . A node can specify what neighbor its message is intended to (although all neighbors will receive it) by setting the {\tt target} field of that message. Symmetrically, the  of the emitter of a message can be read in the {\tt sender} field of that message. Since the edges are undirected, if  receives a message from  at round , then  also receives a message from  at round . We call this property the principle of \textit{reciprocity}.


Globally, the progress of the execution is represented as a sequence of {\em configurations} , where each  captures the state of all nodes at the end of round   (except for , the initial state). We use interchangeably the terminology ``after round '' and ``at/by the end of round '', and similarly for ``before round '' and ``at the beginning of round ''.


\section{The Algorithm}
\label{sec:algorithm}

In this section, we present a message passing algorithm which adapts (``implements'' in the theoretical sense) the spanning forest mechanism described in Section~\ref{sec:principle} into the synchronous model from~\cite{KLO10}. We first describe the variables present at each node, then the structure of a message, and finally the algorithm itself with both an informal description and detailed listings of pseudo-code.

\subsection{State variables}
\label{sec:variables}

Besides the {\tt ID} variable, which we assume is externally initialized, each node has a set of variables which reflect its situation in the tree:
\texttt{status} accounts for the possession of a token ({\tt T} if it has a token, {\tt N} if it does not);
\texttt{parent} contains the {\tt ID} of this node's parent ( if it has none); \texttt{children} contains the set of this node's children ( if it has none).
Observe that both variables {\tt status} and {\tt parent} are somewhat redundant, since in the spanning forest principle (see Section~\ref{sec:principle}) the possession of a token is equivalent to being a root. Our algorithm enforces this equivalence, yet, keeping both variables separated simplifies the description of the algorithm and our ability to think of it intuitively.
Variable {\tt neighbors} contains the set of nodes from which a message was received in the last reception. These neighbors may or may not belong to the same tree as the current node. Variable {\tt contender} contains the {\tt ID} of a neighbor that the current node considers selecting as parent in the next round (or  if there is no such node). Finally, the variable {\tt score} is the main ingredient of our cycle-avoidance mechanism, whose role is described below. 

\subsubsection{Initial values:} All the nodes are uniformly initialized. They are initially the root of their own individual tree ({\it i.e.} , , and ). They know none of their neighbors (), have no contenders (), and their {\tt score} is set to their own {\tt ID}.


\subsection{Structure of a message (and associated variables)}

Messages are composed of a number of fields: {\tt sender} is the ID of
the sending node; {\tt senderStatus} its status (either {\tt T} or
{\tt N}); and {\tt score} its score when the message was prepared. The
field {\tt action} is one of . Informally,
 messages are sent by a root node to another root node to
signify that it ``adopts'' it as a parent (merging operation); 
messages are sent by a root node to circulate the token to one of its
children (circulation operation);  messages are sent by a node
by default, when none of the other messages are sent, to make its
presence and status known by its neighbors. Finally, {\tt target} is
the ID of the neighbor to which a FLIP or a SELECT message are
intended ( for HELLO messages).

Received messages are stored in a variable \texttt{mailbox}, which is
a map collection whose {\em keys} are the senders ID ({\it i.e.,} a
message whose sender ID is  can be accessed as {\tt mailbox[]}).
In each round, the algorithm makes use of a {\tt RECEIVE()} function
that clears the mailbox and fill it with all the messages received in
that round (one for each physical neighbor). A node can thus update
the set of its neighbors by fetching the {\em keys} of its mailbox.
Similarly, it can eliminate from its list of children those nodes which
are no more neighbor.

As mentioned above, every node prepares at the end of a round the message to
be sent at the beginning of the next round. This message is stored in
a variable \texttt{outMessage}. We allow the short hand  to define a new message  whose emitter is node  (with status  and score ); target is node ; and action is .


\subsubsection{Initial values:} The mailbox is initially empty ({\tt mailbox} ) and \texttt{outMessage} is initialized to the tuple .

\subsection{Description of the algorithm}

The algorithm implements the general scheme presented in
Section~\ref{sec:principle}. In this Section we explain how each of
the three core operations ({\em merging}, {\em circulation}, {\em
  regeneration}) is implemented. Then we discuss the specificities of
the merging operation in more detail and the problems that arise due
to its entanglement with the circulation operation, a fact due to the
loss of atomicity in the message passing model. The resulting solution
is substantially more sophisticated than its original scheme, and yet
it faithfully reflects the same high-level principle. Let us start
with some generalities. In each round, each node broadcasts to its
neighbors a message containing, among others, its status ({\tt T} or
{\tt N}) and an action (SELECT, FLIP, or HELLO). Whether or not the
message is intended to a specific  (which is the case for
SELECT and FLIP messages), all the nodes who receive it can possibly
use this information for their own decisions. More generally, based on
the received information and the local state, each node computes at
the end of the round its new status and the local structure of its
tree (variables \texttt{children} and \texttt{parent}), then it
prepares the next message to be sent. We now describe the three
operations. Throughout the explanations, the reader is invited to
refer to Figure~\ref{fig:example}, where an example of execution
involving all of them is shown. All details are also given in the
listings of Algorithm~\ref{algo:main} and~\ref{algo:functions}.

\begin{figure*}[h]
  \centering
  \subfigure[Round ]{
    \begin{tikzpicture}[yscale=1.1,xscale=1]
      \vertex[fill] (4) at (1,1) [label=above:] {};
      \vertex[fill] (1) at (0,1) [label=above:] {};
      \vertex[fill] (2) at (1,0) [label=below:] {};
      \vertex[fill] (3) at (0.3,0.3) [label=below:] {};
      \vertex[fill] (6) at (2,0.5) [label=above:] {};
      \vertex[fill] (5) at (2,-0.7) [label=below:] {};
      \vertex[fill] (7) at (2.5,-1.5) [label=below:] {};
      \vertex[fill] (8) at (1.5,-1.2) [label=below:] {};
      \path[gray]
      (1) edge node[auto] {} (4)  
      (6) edge node[sloped,above, midway] {} (4)
      (2) edge node[sloped,below, midway] {} (6)
      (2) edge (3)
      (4) edge node[sloped,below, midway] {} (3)
      (1) edge (3)
      (4) edge (2)
      (5) edge (7)
      (8) edge node[sloped,below, midway] {} (7)
      (8) edge node[sloped,above, midway] {} (5)
      ;
    \end{tikzpicture}
  }\hspace{40pt}
  \subfigure[Round ]{
    \begin{tikzpicture}[yscale=1.1,xscale=1]
      \vertex[] (4) at (1,1) [label=above:] {};
      \vertex[] (1) at (0,1) [label=above:] {};
      \vertex[] (2) at (1,0) [label=below:] {};
      \vertex[] (3) at (0.3,0.3) [label=below:] {};
      \vertex[fill] (6) at (2,0.5) [label=above:] {};
      \vertex[] (5) at (2,-0.3) [label=below right:] {};
      \vertex[] (7) at (2.5,-1.5) [label=below:] {};
      \vertex[fill] (8) at (1.5,-1.2) [label=below:] {};
      \path[gray]
      (1) edge (4)
      (6) edge (4)
      (2) edge node[sloped,above, midway] { } (6)
      (2) edge (3)
      (4) edge (3)
      (1) edge (3)
      (4) edge (2)
      (5) edge (7)
      (8) edge (7)
      (8) edge  node[sloped,above, midway] { }  (5)
      (5) edge node[sloped,above, midway] {}   (6)(5) edge (2)
      ;

      \draw[very thick,->] (4) -- (6);
      \draw[very thick,->](3) -- (4);
      \draw[very thick,->](1) -- (4);
      \draw[very thick,->](2) -- (6);
      \draw[very thick,->](5) -- (8);
      \draw[very thick,->](7) -- (8);
    \end{tikzpicture}
  }\hspace{40pt}
  \subfigure[Round ]{
    \begin{tikzpicture}[yscale=1.1,xscale=1]
      \vertex[] (4) at (1,1) [label=above:] {};
      \vertex[] (1) at (0,1) [label=above:] {};
      \vertex[fill] (2) at (1,0) [label=below:] {};
      \vertex[] (3) at (0.3,0.3) [label=below:] {};
      \vertex[] (6) at (2,0.5) [label=above:] {};
      \vertex[fill] (5) at (2,-0.3) [label=below right:] {};
      \vertex[] (7) at (2.5,-1.5) [label=below:] {};
      \vertex[] (8) at (1.5,-1.2) [label=below:] {};
      \path[gray]
      (1) edge (4)
      (6) edge (4)
      (2) edge node[sloped,above, midway] { } (6)
      (2) edge (3)
      (4) edge (3)
      (1) edge (3)
      (4) edge (2)
      (5) edge (7)
      (8) edge (7)
      (8) edge (5)
      (6) edge node[sloped,below, midway] { } (5)
      (2) edge (5)
      ;
      
      \draw[very thick,->] (4) -- (6);
      \draw[very thick,->](3) -- (4);
      \draw[very thick,->](1) -- (4);
      \draw[very thick,<-](2) -- (6);
      \draw[very thick,<-](5) -- (8);
      \draw[very thick,->](7) -- (8);
    \end{tikzpicture}
  }

  \subfigure[Round ]{
    \begin{tikzpicture}[yscale=1.1,xscale=1]
      \vertex[] (4) at (0.6,1.3) [label=above:] {};
      \vertex[] (1) at (-0.5,1.1) [label=above:] {};
      \vertex[] (2) at (1.2,0) [label=below:] {};
      \vertex[] (3) at (0.3,0.3) [label=below:] {};
      \vertex[fill] (6) at (2,0.5) [label=above:] {};
      \vertex[] (5) at (2,-0.3) [label=below right:] {};
      \vertex[] (7) at (2.5,-1.5) [label=below:] {};
      \vertex[] (8) at (1.5,-1.2) [label=below:] {};
      \path[gray]
      (1) edge (4)
      (2) edge (6)
      (2) edge (3)
      (4) edge (3)
      (1) edge (3)
      (5) edge (7)
      (8) edge (7)
      (8) edge (5)
      (6) edge node[sloped,below, xshift=-2pt,midway] { }  (5)
      (2) edge (5)
      ;
      \draw[dashed,-] (4) --  (2);
      \draw[very thick, dashed,->] (4) -- node[sloped,above, midway] { }   (6);
      \draw[very thick,->] (5) -- (6);
      \draw[very thick,->](3) -- (4);
      \draw[very thick,->](1) -- (4);
      \draw[very thick,->](2) -- (6);
      \draw[very thick,<-](5) -- (8);
      \draw[very thick,->](7) -- (8);
    \end{tikzpicture}
  }\hspace{25pt}
  \subfigure[Round ]{
    \begin{tikzpicture}[yscale=1.1,xscale=1]
      \vertex[fill] (4) at (0.6,1.3) [label=above:] {};
      \vertex[] (1) at (-0.5,1) [label=above:] {};
      \vertex[] (2) at (1,0) [label=below:] {};
      \vertex[] (3) at (0.3,0.3) [label=below:] {};
      \vertex[] (6) at (2,0.5) [label=above:] {};
      \vertex[fill] (5) at (2,-0.3) [label=below right:] {};
      \vertex[] (7) at (2.5,-1.5) [label=below:] {};
      \vertex[] (8) at (1.5,-1.2) [label=below:] {};
      \path[gray]
      (1) edge node[sloped,above, midway] { }   (4)
      (2) edge (6)
      (2) edge (3)
      (4) edge (3)
      (1) edge (3)
      (5) edge (7)
      (8) edge (7)
      (8) edge node[sloped,above, midway] { }   (5)
      (6) edge (5)
      (2) edge (5)
      ;
      
      \draw[very thick,<-] (5) -- (6);
      \draw[very thick,->](3) -- (4);
      \draw[very thick,->](1) -- (4);
      \draw[very thick,->](2) -- (6);
      \draw[very thick,<-](5) -- (8);
      \draw[very thick,->](7) -- (8);
    \end{tikzpicture}
  }\hspace{25pt}
  \subfigure[Round ]{
    \begin{tikzpicture}[yscale=1.1,xscale=1]
      \vertex[] (4) at (0.6,1.3) [label=above:] {};
      \vertex[fill] (1) at (-0.5,1) [label=above:] {};
      \vertex[] (2) at (1,0) [label=below:] {};
      \vertex[] (3) at (0.3,0.3) [label=below:] {};
      \vertex[] (6) at (2,0.5) [label=above:] {};
      \vertex[] (5) at (2,-0.3) [label=below right:] {};
      \vertex[] (7) at (2.5,-1.5) [label=below:] {};
      \vertex[fill] (8) at (1.5,-1.2) [label=below:] {};
      \path[gray]
      (1) edge node[sloped,above, midway] { } (4)
      (2) edge (6)
      (2) edge (3)
      (4) edge (3)
      (1) edge (3)
      (5) edge (7)
      (8) edge (7)
      (8) edge node[sloped,above, midway] { } (5)
      (6) edge (5)
      (2) edge (5)
      ;
      
      \draw[very thick,<-] (5) -- (6);
      \draw[very thick,->](3) -- (4);
      \draw[very thick,<-](1) -- (4);
      \draw[very thick,->](2) -- (6);
      \draw[very thick,->](5) -- (8);
      \draw[very thick,->](7) -- (8);
    \end{tikzpicture}
  }

  \caption{Example of execution of the algorithm which illustrates all types of operations: parent selection (), token circulation (), and tree disconnection (). {\it The first two symbols represent FLIP or SELECT messages to be sent in the \underline{next} round. Black (resp. white) nodes are those (not) having a token at the \underline{beginning} of the round. Tree edges are represented by bold directed edges. Dash edges have just disappeared.}}
  \label{fig:example}
\end{figure*}

\subsubsection{Merging:} 
If a root ({\it i.e.} a node having a token), say , detects the
existence of a neighbor root with higher {\tt score} than its own,
then it considers that node as a possible \texttt{contender}, {\it
  i.e.} as a node that it might select as a parent in the next round.
If several such roots exist, then the one with highest score, say ,
is chosen. At the beginning of the next round,  sends a 
message to  to inform it that it is its new parent. Two cases are
possible: either the considered edge is still present in that round,
or it disappeared in-between both rounds. If it is still present, then
 receives the message and adds  to its children list, among others
(Line~\ref{line:addChild}). As for , it sets its {\tt parent}
variable to  and its {\tt status} to N
(Lines~\ref{line:testadoptparent} and~\ref{line:becomeOrdinary}). If
the edge disappeared, then  does not receive the message, which is
lost. However, due to the reciprocity of message exchange,  does
not receive a message from  either and thus simply does not
executes the corresponding changes. By the end of the round, either
the trees are properly merged, or they are properly separated.


\subsubsection{Circulation:} If a root  does not detect another
root with higher score, then it selects one of its children at random,
if it has any (see Line~\ref{line:prepareFlip}), otherwise it simply
remains root. Randomness is not a strict requirement of our algorithm
and replacing it with any deterministic strategy would not affect
correctness of the algorithm. Once the child is chosen, say , the
root prepares a FLIP message intended to , and sends it at the
beginning of the next round. Two cases are again possible, whether or
not the edge  is still present in that round. If it is still
present, then  receives the message, it updates its status and adds
 to its children list, among others (Lines~\ref{line:becomeRoot}
and Line~\ref{line:addChild}). As for , it sets its {\tt parent}
variable to  and its {\tt status} to N
(Lines~\ref{line:testadoptparent} and~\ref{line:becomeOrdinary}). If
the edge disappeared, then  can detect it as before simply does not
executes the corresponding changes. Node , on the other hand,
detects that the edge leading to its current parent disappeared, thus
it regenerates a token (discussed next). Notice that in the absence of
a merging opportunity, a node receiving the token in round  will
immediately prepare a FLIP message to circulate the token in the next
round. Unless the tree is composed of a single node, the tokens are
thus moved in each round. In order for them to remain detectable in
this case, the status announced in  messages is {\tt T} (whereas
it is {\tt N} for  messages).


\SetKwRepeat{Repeat}{repeat}{}\begin{algorithm2e*}[h]
  
\BlankLine
    \medskip


  \Repeat{}{
  \texttt{SEND(outMessage);}
  \BlankLine

  \texttt{mailbox  RECEIVE();}\hfill\comm{Received messages, indexed by sender ID}
  \BlankLine

  \texttt{neighbors  mailbox.keys();}\hfill\comm{All the senders IDs} \label{line:neighbors}
  \texttt{children}  \texttt{children}  \texttt{neighbors}\medskip\\   \label{line:intersection}

    \BlankLine
    
    \comm{Regenerates a token if parent link is lost}\smallskip
    \If{\texttt{status}=N  \texttt{parent}  \texttt{neighbors}}{
      \texttt{BECOME\_ROOT()};\label{line:become}\\
    }
    \BlankLine
    \comm{Checks if the outgoing FLIP or SELECT (if any) was successful}\smallskip
    
    \If{\texttt{outMessage.action  \{FLIP,SELECT\}  outMessage.target  neighbors\label{line:testadoptparent}}}{
      \texttt{ADOPT\_PARENT(outMessage)}\label{line:becomeOrdinary}
    }
    \BlankLine

    \comm{Processes the received messages}\smallskip    
    
    \texttt{contender} ;\\
    \texttt{contenderScore} ;\\
    \ForAll{\texttt{message}  \texttt{mailbox}}{
      \eIf{\texttt{message.target} = \texttt{ID}}{
        \If{\texttt{message.action} = FLIP}{
          \texttt{BECOME\_ROOT();}\label{line:becomeRoot}
        }
        \texttt{ADOPT\_CHILD(message);}\label{line:addChild}\hfill\comm{called for both FLIP or SELECT} 
      }{
        \If{\texttt{message.status\,=\,T  message.score \,contenderScore}\label{line:mergingDetection}}{
          \texttt{contender  message.ID;}\\
          \texttt{contenderScore  message.score;}
        }
      }
    }
  

    \comm{Prepares the message to be sent}\smallskip
    \texttt{outMessage }\\
    \If{\texttt{status}  T}{
      \eIf{\texttt{contenderScore  score}}{
        \texttt{PREPARE\_MESSAGE(SELECT, contender)}; \label{line:prepareSelect}
      }{
        \If{\texttt{children} }{
          \texttt{PREPARE\_MESSAGE(FLIP, random(children))};\label{line:prepareFlip}
}
      }
    }
    
    \If{\texttt{outMessage} }{
      \texttt{PREPARE\_MESSAGE(HELLO, )}
    }
  }
  \caption{\label{algo:main}Main Algorithm}
\end{algorithm2e*}





\subsubsection{Regeneration:} The first thing a non-root node does after receiving the messages of the current round is to check whether the edge leading to its current parent is still present. If the edge disappeared, then the node regenerates a root directly (Line~\ref{line:become}). A nice property of the spanning forest principle is that this cannot happen twice in the same tree. And if a tree is broken into several pieces simultaneously, then each of the resulting subtree will have exactly one node performing this operation.


\subsubsection{The unique score technique:}
Unlike the high-level graph model from~\cite{CCGP13}, in which the merging operation involved two nodes in an {\em exclusive} way, the non-atomic nature of message passing allows for a {\em chain} of selection that may involve an arbitrary long sequence of nodes (e.g.  selects ,  selects , and so on). This has both advantages and drawbacks. On the good side, it makes the initial merging process very fast (see rounds  and  in Figure~\ref{fig:example} to get an example). On the bad side, it is the reason why scores need to be introduced to avoid cycles. Indeed, relying only on a mere comparison of {\tt ID} to avoid cycles is not sufficient. Consider a chain of selection in round  that ends up at some root node . Nothing prevents  to have passed the token to a lower-ID child, say , in the previous round  (that same round when 's status  was overheard by the next-to-last root in the chain). Now, nothing again prevents  to have selected one of the nodes in the selection chain in round , thereby creating a cycle. The score mechanism prevents such a situation by enforcing that after each FLIP, the new root has a larger score than its predecessor (see Lines~\ref{line:min-score} and~\ref{line:max-score} in Algorithm~\ref{algo:functions}). The score mechanism also guarantees that the current set of scores (network-wide) is always a permutation of the initial set of scores. Hence, scores are always unique. All of these elements are crucial ingredients in the proofs of correctness of Section~\ref{sec:correctness}.







\section{Correctness analysis}
\label{sec:correctness}

This section establishes a number of key properties about the spanning forest algorithm. In particular, we prove the claims regarding what property is {\em always} satisfied, regardless of the rate of changes. Because the proofs are technical, we provide first a preamble that includes helping definitions and a less technical outline of the proof. Then, the proof is described through two main parts called {\em consistency} and {\em correctness}, in reference to aspects defined in the preamble.

\subsection{Preamble and outline of the proof}
We first define a handful of instrumental concepts that help minimize the number of properties to be proven. Then, as we start formulating the key properties to be proved, we adopt concise notations regarding the state of the system. Precisely, we denote by  (resp. ) the value of variable  at node  before (resp. after) 
round . Notice that for any node , round , and variable , we have . 
We use whichever notation is the most convenient in the given context.

\subsubsection{Helping definitions}

These definitions are not specific to our algorithm, they are general graph concepts that simplify the subsequent proofs.

\begin{definition}[Pseudotree and pseudoforest]
\label{def:pseudoforest}
A directed graph whose vertices have outdegree at most 1 is a {\em pseudoforest}.
A vertex whose outdegree is 0 is called a {\em root}.
The weakly connected components of a pseudoforest are called {\em pseudotrees}.
\end{definition}


\begin{lemma}
\label{lem:one_root}
  A pseudotree has at most one root.
\end{lemma}

\begin{proof}
   By definition, a pseudotree  is connected, thus . If  has several roots, then at least two nodes in  have no outgoing edge. Since the others have at most one, we must have , which is a contradiction.
 \end{proof}


\begin{lemma}
\label{lem:pseudotree_tree}
If a pseudotree  contains a root , then it has no cycle.
\end{lemma}

\begin{proof} Let  be the set of nodes at distance  from . Since  has outdegree , there is an edge from each node in  to . Since  is a pseudotree, these nodes have no other outgoing edge than those ending up in . The same argument can be applied inductively, all nodes at distance  having no other outgoing edges than those ending up in .
 \end{proof}

\begin{definition}[Correct tree and correct forest]
\label{def:forest}
At the light of Lemma~\ref{lem:one_root} and~\ref{lem:pseudotree_tree}, we define a {\em correct tree} (or simply a {\em tree}) as a pseudotree in which a root can be found. We naturally define a {\em correct forest} (or simply a {\em forest}) as a pseudoforest whose pseudotrees are trees.

\end{definition}

Finally, because forests are considered in a spanning context, we say that a pseudoforest  is a correct forest {\em on graph}  iff  is a correct forest {\em and}  is a subgraph of . Defining correct trees as pseudotrees in which a root can be found is the key. When the moment arrives, this will allow us to reduce the correctness of our algorithm to the presence of a root in each pseudotree.




\subsubsection{Consistency}

At the end of a round, the state of an edge (whether it belongs to a tree, and if so, in what direction) must be consistently decided at both endpoints:

\begin{definition}[forest consistency]
The configuration 
is forest consistent if and only if for all nodes ,
.
\end{definition}

The proof of forest consistency is inductively established by Theorem~\ref{th:consistency}, based on consistency of the initial configuration (Lemma \ref{lem:C0-forestConsistency}) and the maintenance the consistency over the rounds (Lemma \ref{lem:consistency}).
Forest consistency allows us to reduce the output of interest of the algorithm after each round  to the mere \texttt{parent} variable. 

At the end of round , the values of all \texttt{parent} variables should be consistent with the underlying graph .


\begin{definition}[graph consistency]
The configuration 
is graph consistent if and only if for all nodes ,
.
\end{definition}

This property is established by Corollary \ref{co:consistency}.
Graph consistency allows us to say that the output of the algorithm forms a pseudoforest on .

 
\begin{definition}[Resulting forest]
  \label{def:F_i}
  Given a round , occurring on graph , the graph  such that  is called the {\em pseudoforest} resulting from round~. 
\end{definition}

\FloatBarrier

As explained in Section~\ref{sec:variables}, the variables {\tt parent} and {\tt status} are somewhat redundant, since the possession of a token is synonymous with being a root. The equivalence between both variables after each round is established in Lemma~\ref{lem:L5} (state consistency). The main advantage of this equivalence is that it allows us to formulate and prove a large number of lemmas using either variable, depending on which is the most convenient in the given context.

\subsubsection{Outline of the proof}


In this section, we prove that the resulting forest is always correct (Definition \ref{def:forest}). 
To achieve that goal, 
we first define a validity criterion at the node level, which recursively ensures the correctness of the pseudotree this node belongs to thanks to Definition~\ref{def:forest} ({\it i.e.} the existence of a root implies correctness).



\begin{definition}
A node  is said to be valid at the beginning of round  if either  or  is valid. 
\end{definition}


\begin{algorithm2e}[h]








	\SetKwBlock{Begin}{}{}

        \texttt{procedure BECOME\_ROOT}
  \Begin{
  \texttt{status}  T\;
  \texttt{parent} \;
  } 
  \bigskip

  \texttt{procedure ADOPT\_PARENT(outMessage)}\Begin{
  \texttt{status  N}\;
  \texttt{parent  outMessage.target}\;
  \If{\texttt{outMessage.action = FLIP}}{
    \texttt{children  childrenparent\;}
    \texttt{score  min(score, mailbox[parent].score)\;\label{line:min-score}}
  }
  }
  \bigskip

  \texttt{procedure ADOPT\_CHILD(message)}
  \Begin{
  \texttt{children.add(message.ID)\;}
  \If{\texttt{message.action = FLIP}}{
    \texttt{score  max(score, message.score)\;\label{line:max-score}}
  }
  }
  \bigskip

  \texttt{procedure PREPARE\_MESSAGE(action, target)}
  \Begin{
  \Switch{\texttt{action}}{
    \Case{\texttt{SELECT}}{
      \texttt{outMessage  (ID, N, SELECT, target, score)}\; 
}
  \Case{\texttt{FLIP}}{
  \texttt{outMessage  (ID, T, FLIP, target, score)}\;
  }
  \Case{\texttt{HELLO}}{
  \texttt{outMessage  (ID, status, , , score)}\;
  }
  }
  }
  \caption{Functions called in Algorithm~\ref{algo:main}.}
  \label{algo:functions}
\end{algorithm2e}

The correctness of the whole forest can thus be established through showing that, first, it is initially correct (Lemma~\ref{lem:initial_forest}) and, second, if it is correct after round , then it is correct after round  (Theorem~\ref{lem:nodes_validity}). The latter is difficult to prove, and it involves a number of intermediate steps that correspond to a case analysis based on every action a node can perform (sending FLIP messages, SELECT messages, etc.).

We first prove that a node  that sends a successful FLIP to 
in a round, is valid at the end of that round
(Lemma \ref{lem:FLIP-valid}) because at the end of that round  is a root.
The proof relies on the fact that during a given round, a node cannot receive a FLIP and send a SELECT or a FLIP
(Lemma  \ref{lem:2FLIPs}). 

We then prove some necessary properties on the {\tt score} variable at each node.
For instance, a node changes its score at most once during a round
(Lemma \ref{lem:NO-FLIP-SCORE} and \ref{lem:change_score-once}).
Also, the set of all scores are a permutation of the node identifiers after each round (Lemma \ref{lem:permutation}).

Then we prove that a node that sends a successful SELECT in a round , is valid at the end of that 
round (Lemma~\ref{lem:select_valid}). This part is the most technical and is the one that proves that chains of selection can not create cycles thanks to the property that score variables remain a permutation of all nodes IDs.

Finally, we prove that all roots at the beginning of a round
are still valid at the end of the round (Lemma \ref{lem:T-vald}).
Therefore, if all nodes are valid at the beginning of round, 
then they are also valid at the end of the round 
(Theorem \ref{lem:nodes_validity}). Since they are initially valid (Lemma~\ref{lem:initial_forest}), we conclude by induction on the number of rounds.










































































\subsection{Consistency (detailed proofs)}
\begin{lemma}
  \label{lem:C0-forestConsistency}
  \label{lem:initial_forest}
The configuration  is forest consistent and graph consistent.
In , the resulting pseudoforest is correct.
\end{lemma}
\begin{proof}
  The {\tt parent} variable is initialized to . So, the configuration  is forest consistent and graph consistent.
Any node  belonging to the pseudotree . 
Each of these pseudotrees contains  a root ( itself) and is therefore a correct tree.
 \end{proof}






We say that  {\em sends a FLIP} (resp. {\em SELECT}) in round  if and only if  (resp. {\em SELECT}). We say that it sends it {\em to node}  if and only if . Finally the FLIP or SELECT is said to be {\em successful} (resp. {\em failed}) if  (resp. ).
 
\begin{lemma}[state consistency]
\label{lem:L5}
For all round , for all node ,

\end{lemma}

\begin{proof}
Initially, at any node ,  and . The change of  to  always comes with the assignment of a non-null  () to  (procedure \texttt{ADOPT\_PARENT()}), and assigning the value  to  is always followed by the change of  to  (procedure \texttt{BECOME\_ROOT()}). So at any configuration,  if and only if .
 \end{proof}


\begin{lemma}
  \label{lem:FLIP-PROCEDURE}
  If  does not send a FLIP or SELECT in round , then  does not execute
the procedure \texttt{ADOPT\_PARENT()} during round .
\end{lemma}

\begin{proof}
The execution of the procedure \texttt{ADOPT\_PARENT()} by 
is conditioned by the sending of a SELECT or a FLIP by  during the current round (line \ref{line:testadoptparent}).
 \end{proof}

\begin{observation}
\label{obs:message_pepared}
At time where a node  prepares its message to be
sent during the round , we have 
(resp. ).
\end{observation}

\begin{lemma}
  \label{lem:FLIP-SELECT-T}
  If  sends a FLIP or SELECT in round , then .
\end{lemma}

\begin{proof}
 sends in round  the message prepared in round . If  sends a FLIP or a SELECT in round  then in round  \texttt{PREPARE\_MESSAGE()} is called  with FLIP or SELECT as action (lines \ref{line:prepareSelect} or \ref{line:prepareFlip}). Both instructions are conditioned by .
\end{proof}


\begin{lemma}
  \label{lem:T-if-T}
  If  sends a message containing  in round , then .
\end{lemma}
\begin{proof}
The procedure \texttt{PREPARE\_MESSAGE()} is executed by a node  in round  to construct 
the message  to be sent in round .
In all cases \texttt{PREPARE\_MESSAGE()} sets  to  only if .
\end{proof}



\begin{lemma}
\label{lem:select-score}
If  sends a SELECT to  in round , then 
.
\end{lemma}

\begin{proof}
The value of the  field in the message sent by a node  in round  
is .


Assumes that the node   sends a SELECT to  in a round .
So, during the round ,  sets its  variable to  and its  
variable to 
 being the message sent by  at the begining of round .
From that time to the end of round ,  is not modified.

So , if  sends 
a SELECT to  in a round .
 \end{proof}



\begin{lemma}
  \label{lem:cond-single-Flip}
If at the beginning of round , the configuration 
is forest  consistent then only 
 can  send a FLIP at destination of  during the round .
\depends{\ref{th:consistency}}
\end{lemma}

\begin{proof}
A node  can prepare a FLIP message to the node  
at then end of round  only if .
We have  according to the hypothesis (forest consistency at the beginning of round). 
Therefore, only the node   can prepare 
a FLIP message at destination of , 
at the end of round .
 \end{proof}



\subsubsection{Graph consistency:}
\begin{lemma}
  \label{lem:add_parent}
Let  be a node such that .
Then  sends a successful FLIP or SELECT to  during the round .
\end{lemma}
\begin{proof}
The only change of  by  to a non-null identifier  in 
a round  is at the execution of the procedure \texttt{ADOPT\_PARENT()} 
which is conditioned by the reception of a message from  (line \ref{line:becomeOrdinary}).
If  receives the message of  during round  then  effectively receives the
message sent by  (\textit{reciprocal reception property}).
\end{proof}


\begin{lemma}
  \label{lem:keep_parent}
Let  be a node such that .
We have .
\end{lemma}
\begin{proof}
By Lemma \ref{lem:L5}, we have .
So,  does not send a FLIP or SELECT during the round  
(Lemma \ref{lem:FLIP-SELECT-T}).
Then,  does not execute \texttt{ADOPT\_PARENT()} during the round 
according to Lemma  \ref{lem:FLIP-PROCEDURE}.
Since  we conclude that
 does not execute the procedure \texttt{BECOME\_ROOT()} during the round .
So  did receive a message from  in round .
We have .
 \end{proof}


\begin{corollary}[graph consistency]
\label{co:consistency}
Every configuration is graph consistent.
\end{corollary}
\begin{proof}
The configuration reached after any round is graph consistent
(Lemmas \ref{lem:add_parent} and \ref{lem:keep_parent}).
 \end{proof}

\subsubsection{Forest consistency:}


\begin{lemma}
\label{lem:N-parent}
If  then  or .
\depends{ }
\end{lemma}

\begin{proof}
According to Lemma \ref{lem:L5}, we have , so 
u cannot send a  FLIP or a SELECT in round  (by Lemma \ref{lem:FLIP-SELECT-T}).
Therefore,  does not execute \texttt{ADOPT\_PARENT()} in round  
(Lemma \ref{lem:FLIP-PROCEDURE}). We conclude that 
 or .
 \end{proof}




\begin{lemma}
\label{lem:cond-2FLIPs}
Assume that at the beginning of round , the configuration is forest consistent. If  receives a FLIP in round , then it does not send a FLIP nor a SELECT in round .
\depends{\ref{th:consistency},  \ref{lem:FLIP-SELECT-T}, \ref{lem:L5}}
\end{lemma}


\begin{proof}
We will establish the contraposition of the lemma statement: 
if  sends a FLIP or a SELECT in round , then it does not receive a FLIP in round .
By Lemma \ref{lem:FLIP-SELECT-T}, we have .
According to Lemma \ref{lem:L5}, .
Thus according to the hypothesis (forest consistency at the beginning of round), for any node , .
Therefore no node has prepared a FLIP message at destination of , 
in round .
So  cannot receive a FLIP in round .
 \end{proof}


\begin{lemma}
 \label{lem:add_parent_add_child}
Assume that at the beginning of round , the configuration is forest consistent. If in round ,  changes  to  then 
 : 
.
\end{lemma}
\begin{proof}
 sets  to  only if the FLIP or SELECT was successful 
(Lemma \ref{lem:add_parent}). 
Therefore  has received the FLIP or SELECT message sent by .
 
The addition of a node  to  by  is done during
the excution of the procedure \texttt{ADOPT\_CHILD()} which is 
conditioned by the reception of a FLIP or a SELECT message  from   
(, line \ref{line:addChild}). 
The procedure \texttt{ADOPT\_CHILD()} is executed after line \ref{line:intersection}
which is the only instruction that could remove  from . 
So, . 
We have .
 \end{proof}




\begin{lemma}
  \label{lem:add_child_add_parent}
Assume that at the beginning of round , the configuration is forest consistent. If in round ,  adds  to  then  : .
\depends{\ref{lem:cond-2FLIPs}}
\end{lemma}
\begin{proof}
  adds  to  only if it excutes the procedure 
\texttt{ADOPT\_CHILD()}
 which is conditioned by the reception of a FLIP or a SELECT 
sent by .
As the reception of messages is reciprocal, 
 also receives in round  a message from . This satisfies the condition for  to execute the procedure 
\texttt{ADOPT\_PARENT()} which sets  to .



Only the execution of \texttt{BECOME\_ROOT()} (at line \ref{line:becomeRoot}) 
could modify the value of .
This procedure would be executed only if  has received
 a FLIP during round  which cannot be the case.
 Notice that  does not receive a FLIP during the round  (Lemma \ref{lem:cond-2FLIPs}).
 \end{proof}


\begin{lemma}
  \label{lem:rem_parent_rem_child}
Assume that at the beginning of round , the configuration is forest consistent. If in round ,  changes  from  to another value then 
 : 
.
\end{lemma}

\begin{proof}
If  changes  then we have  (Lemma \ref{lem:N-parent}).
Only the execution of \texttt{BECOME\_ROOT()} by  sets  
to . The procedure \texttt{BECOME\_ROOT()} is executed
in two cases: at the detection of a disconnection (line \ref{line:become}), and
at the reception of a FLIP message (line \ref{line:becomeRoot}).

In the first case, the \textit{reciprocal reception property} ensures that  
does not receive the message sent by .
So,   removes  from  (line \ref{line:intersection}).

In the second case,  receives a FLIP from  (Lemma 
 \ref{lem:cond-single-Flip}).
According to the \textit{reciprocal reception property},  receives the message sent by  during the round .
So,  executes \texttt{ADOPT\_PARENT()} which removes 
 (i.e. ) from  (line \ref{line:becomeOrdinary}).
 \end{proof}


\begin{lemma}
  \label{lem:rem_child_rem_parent}
Assume that at the beginning of round , the configuration is forest consistent.  
 If in round ,  removes  from  
then  : .
\end{lemma}
\begin{proof}
 removes  from  in two cases: 
at the detection of a disconnection 
( does not receive a message from , line \ref{line:intersection}), and
when  executes (\texttt{ADOPT\_PARENT()}, line \ref{line:becomeOrdinary}) 

In the first case, the \textit{reciprocal reception property} ensures that 
 does not receive the message sent by  during the round .
So,  becomes a root : it executes the procedure
\texttt{BECOME\_ROOT()} (line \ref{line:become}).

In the second case,  executes \texttt{ADOPT\_PARENT()}.
So  did send a successful FLIP or SELECT (Lemma \ref{lem:FLIP-PROCEDURE}).
As  removes  from  during the execution of
\texttt{ADOPT\_PARENT()},
  we have  and
 (see the procedure \texttt{ADOPT\_PARENT()}).
So  sends
a successful FLIP to   during round .
Therefore, in round ,  
executes the procedure \texttt{BECOME\_ROOT()} (line \ref{line:becomeRoot}):
 sets  to .
 \end{proof}


\begin{lemma}[Forest Consistency]
\label{lem:consistency}
Let  be a round starting from a forest consistent configuration.
The configuration reached at the end of round  is forest consistent
\depends{\ref{lem:add_parent_add_child}, \ref{lem:add_child_add_parent}, \ref{lem:rem_parent_rem_child}, \ref{lem:rem_child_rem_parent}}
\end{lemma}
\begin{proof}
The configuration after the round  is forest consistent according 
to Lemmas \ref{lem:add_parent_add_child}, \ref{lem:add_child_add_parent}, 
\ref{lem:rem_parent_rem_child}, \ref{lem:rem_child_rem_parent}. 
Notice that in the case where  does not change the value of its parent variable (\textit{resp}. 
 stays  in ) during round , at the end of round  the forest consistency 
property is preserved according to the contraposition of Lemma \ref{lem:rem_child_rem_parent} 
(\textit{resp}. contraposition of Lemma \ref{lem:rem_parent_rem_child}) and the hypothesis.
 \end{proof}

\begin{theorem}[Consistency]
\label{th:consistency}
Every configuration is forest consistent.
\end{theorem}
\begin{proof}
 is forest consistent (Lemma \ref{lem:C0-forestConsistency}).
The configuration reached after any round is 
forest consistent (Lemma \ref{lem:consistency}).
 \end{proof}








\subsection{Correctness (detailed proofs)}


\subsubsection{Correctness of the resulting forest after token circulation:}

\begin{lemma}
  \label{lem:single-Flip}
  Let  be a node. Only 
 can  send a FLIP at destination of  during the round .
\depends{\ref{th:consistency}, \ref{lem:cond-single-Flip})}
\end{lemma}

\begin{proof}
At the beginning of round , the configuration is forest consistent
(Theorem \ref{th:consistency}).
Therefore, only the node   can prepare 
a FLIP message at destination of , 
at the end of round  (Lemma \ref{lem:cond-single-Flip}).
 \end{proof}

\begin{lemma}
 \label{lem:2FLIPs}
 If  receives a FLIP in round , then it does not 
send a FLIP nor a SELECT in round .
\depends{\ref{th:consistency},  \ref{lem:FLIP-SELECT-T}, \ref{lem:L5}}
\end{lemma}
\begin{proof}
At the beginning of round , the configuration is forest consistent
(Theorem \ref{th:consistency}).
Therefore no node has prepared a FLIP message at destination of , 
in round  (Lemma \ref{lem:cond-2FLIPs}).
 \end{proof}


\begin{lemma}[Adoption]
\label{lem:adoption}
If  sends a successful FLIP or SELECT to  in round , then  and .
\depends{\ref{lem:2FLIPs}}
\end{lemma}

\begin{proof}
In round ,  or SELECT  
and . 
During the round ,  executes the procedure \texttt{ADOPT\_PARENT()} 
(line \ref{line:becomeOrdinary})  
which sets  to . 
According to Lemma \ref{lem:2FLIPs},  did not receive any FLIP 
message during the round .
Only an execution of \texttt{BECOME\_ROOT()} by  
at line \ref{line:becomeRoot} can 
change the value of  
during the round . This line is not executed during round .
 \end{proof}

\begin{lemma}
\label{lem:received-FLIP}
  If  sends a successful FLIP to , then .
\depends{\ref{lem:2FLIPs}, \ref{lem:single-Flip}}
\end{lemma}

\begin{proof}
 received  in round , so .
 executes the procedure \texttt{BECOME\_ROOT()} 
that changes  to . 
After the execution of line \ref{line:becomeOrdinary}, 
no instruction can set  to 
until the end of round . So .
 \end{proof}


\begin{lemma}
  \label{lem:FLIP-valid}
  If  sends a successful FLIP in round , then  is valid after round .
\depends{\ref{lem:adoption}, \ref{lem:received-FLIP}}
\end{lemma}

\begin{proof}
By Lemmas \ref{lem:adoption} and \ref{lem:received-FLIP} 's parent has a status  after round .
 \end{proof}

\subsubsection{Proofs on score permutations:}



\begin{lemma}
\label{lem:received-FLIP-score}
  If  sends a successful FLIP to , then .
\depends{\ref{lem:2FLIPs}, \ref{lem:single-Flip}}
\end{lemma}

\begin{proof}
 sent a message  to  at the beginning of round  
such that  FLIP,   and . 
 received  in round , so .
 executes the procedure
\texttt{ADOPT\_CHILD()} at line \ref{line:addChild} 
in round . 
This procedure sets the current score of  
to , as .
After the execution of this instruction, we have
. 
We notice that after this operation, no instruction 
can change the value of   
(Lemma \ref{lem:single-Flip}.
 \end{proof}



\begin{lemma}
\label{lem:NO-FLIP-SCORE}
 unless  sends 
or receives a successful FLIP in round .
\depends{\ref{lem:change_score}}
\end{lemma}
\begin{proof}

 changes its  value only by executing \texttt{ADOPT\_PARENT()} or \texttt{ADOPT\_CHILD()}. Both instructions that changes  value in these procedures (Algorithm \ref{algo:functions}, line \ref{line:becomeOrdinary}, \ref{line:addChild}) are conditioned by .
\end{proof}

\begin{lemma}
  \label{lem:change_score-once}
A node  changes  at most once during a round.
\depends{\ref{lem:NO-FLIP-SCORE}, \red{lem:single-Flip}, \ref{lem:2FLIPs}}
\end{lemma}

\begin{proof}
A node sends at most one  FLIP message during a round.
A node receives at most one FLIP message during a round 
(Lemma \ref{lem:single-Flip}).
Either a node receives a FLIP, sends one, or it does not receive and does not send a FLIP during a given
round (Lemma \ref{lem:2FLIPs}).
So, according to Lemma \ref{lem:NO-FLIP-SCORE}, 
a node changes  at most once during a round.
 \end{proof}

\begin{lemma}
  \label{lem:permutation}
  Before each round, the set of scores is a permutation of the set of identifiers. 
\depends{\ref{lem:change_score_once}}
\end{lemma}

\begin{proof}
After the initialization in each node , . A node  changes its score only by executing \texttt{ADOPT\_PARENT()} or \texttt{ADOPT\_CHILD()}.
We will do a proof by induction.
We assume at the beginning of round , the set of scores is a a permutation of the set of indentifiers.
We have for any node , .

According to Lemma \ref{lem:NO-FLIP-SCORE}, only a node sending or receiving a successful FLIP may change its  value. 
Assume that the node  changes its  value during round . Without lost of generality, we assume 
sends the successful FLIP to a node  in round .

By hypothesis,  changes its  to  during the execution of \texttt{ADOPT\_PARENT()} in round . We have . 
 executes the procedure
\texttt{ADOPT\_CHILD()} at line \ref{line:addChild} 
in round . 
This procedure sets the current score of  
to , as .
After the execution of this instruction, we have
. 

According lemma \ref{lem:change_score-once}, we have 
 and . 
\end{proof}


\subsubsection{Correctness of the resulting forest after mergings:}

In lemmas \ref{lem:selected-T} and  \ref{lem:selected-N}, we establish that
if  sends a successful SELECT to  in round  either  or . In the first case, we have , and in the second case, 
we have .
Let  be a series of nodes  such that   
and such that  sends a successful SELECT to  during the round .
As a 's subchain of nodes having strictly increasing scores at the beginning of round  
may be built:  has not loop. So  ends by a node having a token : all nodes on that chain are valid.







\begin{lemma}
  \label{lem:send-T-become-N-parent-T}
  If  sends a message containing  in round  and , let , then .
\end{lemma}

\begin{proof}
If  sends a message containing  in round , then . If , then  has executed \texttt{ADOPT\_PARENT()} in round , because it is the only procedure that sets  to .
 executes \texttt{ADOPT\_PARENT()} only if it has sent a FLIP message  to a node  ( SELECT because ), and if  has received the message  (\textit{reciprocal reception property}). At the reception of  by ,  executes \texttt{BECOME\_ROOT()} (line 16) which sets  to  and from this line until the end of the round no instruction can change  to . So .


At the execution of \texttt{ADOPT\_PARENT()} by ,  sets  to . After this instruction there is only \texttt{BECOMES\_ROOT()} that can modifie the value of , and which is conditioned by the reception of a FLIP message. According to lemma \ref{lem:2FLIPs}  cannot call \texttt{BECOMES\_ROOT()} because it cannot receive a FLIP message. So .

So, if  sends a message containing  in round  and , and , then .
 \end{proof}

\begin{lemma}
\label{lem:sendT}
If  sends a message containing 
in round  and , let , then .
\depends{\ref{lem:received-FLIP}, \ref{lem:T-if-T}}
\end{lemma}

\begin{proof}
  We have  because in round ,  cannot be modified after the execution of \texttt{PREPARE\_MESSAGE()}. 
If  
then  sends a FLIP message to one of its children, named , in round .
Either , then ,  and
 
(see Lemmas \ref{lem:received-FLIP} and \ref{lem:received-FLIP-score}).
Otherwise .
 \end{proof}


\begin{lemma}
 \label{lem:selected-was-T}
If  sends a successful SELECT to  in round  then .
\depends{\ref{lem:T-if-T}}
\end{lemma}
\begin{proof}
    Node  prepared a SELECT message to  in round ,
    thus it had , which implies it received from  
    a message containing . We have then  because after the execution of \texttt{PREPERE\_MESSAGE()} by  in round ,  cannot be changed. 
 \end{proof}


\begin{lemma}
 \label{lem:selected-T}
If  sends a successful SELECT to  in round  and , then .
\depends{\ref{lem:select-score}, \ref{lem:T-T-keep-score}, \ref{lem:selected-was-T}}
\end{lemma}

\begin{proof}
    By Lemma~\ref{lem:selected-was-T} . Then Lemmas~\ref{lem:select-score} and~\ref{lem:NO-FLIP-SCORE} respectively imply that  and .
 \end{proof}


\begin{lemma}
 \label{lem:selected-N}
If  sends a successful SELECT to  in round  and  
, then let . 
It holds that  
and .
\depends{\ref{lem:select-score}, \ref{lem:sendT}, \ref{lem:selected-was-T}, \ref{lem:send-T-become-N-parent-T}}
\end{lemma}
\begin{proof}
    By Lemma~\ref{lem:selected-was-T} we have . 
    Then Lemmas~\ref{lem:select-score} and~\ref{lem:sendT} respectively imply that  and .  
Lemma \ref {lem:send-T-become-N-parent-T}  implies that .
 \end{proof}




\begin{lemma}[Cancellation]
  \label{lem:CANCEL}
  If  sends a failed FLIP or SELECT in round , then .
\depends{\ref{lem:FLIP-SELECT-T}}
\end{lemma}

\begin{proof}
By lemma \ref{lem:FLIP-SELECT-T}, we have . 
 did not receive the message from  implies that . 
So, in round ,  ( did not receive 
the message from ).
Only during the execution of \texttt{ADOPT\_PARENT()},
called in line \ref{line:becomeOrdinary},  can change its  to .
This procedure is not executed during the round .
 \end{proof}

\begin{lemma}[Conservation]
  \label{lem:conservation}
  If  and  does not send a FLIP or SELECT in round , then .
\end{lemma}

\begin{proof}
By lemma \ref{lem:FLIP-PROCEDURE},  does not execute the procedure \texttt{ADOPT\_PARENT()} during the round .
 can set \texttt{status} variable to  only if it executes \texttt{ADOPT\_PARENT()}. 
 \end{proof}


\begin{lemma}
  \label{lem:all-but-SELECT-valid}
  If  and  does not send a successful SELECT in round , then  is valid after the round .
\end{lemma}

\begin{proof}
According to Lemma \ref{lem:FLIP-valid}, after the successful sending of a FLIP message in round ,  is valid at the end of round . 
If  sends a failed SELECT or a failed FLIP then  is valid after the round  by Lemma~\ref{lem:CANCEL}.
otherwise,  did not send a SELECT or a FLIP during the round :
it is also valid at the end of the round by Lemma~\ref{lem:conservation}.
 \end{proof}

\begin{lemma}
\label{lem:select_valid}
If a node sends a successful SELECT in round ,
then it is valid at the end of round . 
\depends{\ref{lem:permutation}, \ref{lem:regeneration}, \ref{lem:adoption}, \ref{lem:send-T-become-N-parent-T}, \ref{lem:selected-T}, \ref{lem:selected-N}, \ref{lem:all-but-SELECT-valid}}
\end{lemma}

\begin{proof}
Let  be the set of nodes that send a successful  
SELECT in round  and are not valid at the end of round . We will prove, by contradiction, that  is empty. Assume  is non-empty and consider the node in  that had the largest score at the beginning of round (say, node ). Such a node exists by Lemma~\ref{lem:permutation}. We will prove that  is valid after the round, which is a contradiction. Let  be the recipient of 's successful SELECT. By Lemma~\ref{lem:adoption} , thus is enough to show that  is valid after round  to get our contradiction. Let us examine both cases whether  or .

If , then either  also sends a successful SELECT in round , or it does not. If it does not, then it is valid after round  (Lemma~\ref{lem:all-but-SELECT-valid}). 
If it does, then it must be valid otherwise  is not maximal in  (Lemma~\ref{lem:selected-T}).

If , then let . Two cases are considered, whether  or not. If  then  because the condition forces  to call the procedure \texttt{BECOME\_ROOT()} in line~\ref{line:become} which makes it take the status . After,  can takes the status , only during the execution of the procedure \texttt{ADOPT\_PARENT()}
in line~\ref{line:becomeOrdinary}. 
This procedure is called by  only 
if  did send a FLIP or a SELECT 
at the beginning of round  by lemma  \ref{lem:FLIP-PROCEDURE}. 
By Lemma~\ref{lem:FLIP-SELECT-T}, 
this cannot happen.
Thus  is valid after round~. If , we use the fact that  (Lemma~\ref{lem:send-T-become-N-parent-T}) to apply the same idea as we did above: either  also sends a successful SELECT in round~, or it does not. If it does not, then it is valid after round~ (Lemma~\ref{lem:all-but-SELECT-valid}). If it does, then it must be valid otherwise  is not maximal in  (Lemma~\ref{lem:selected-N}).
 \end{proof}

\subsubsection{Correctness of resulting forest:}

\begin{lemma}
\label{lem:T-vald}
If  then  is valid after round . 
\depends{  \ref{lem:CANCEL}, \ref{lem:FLIP-valid}, \ref{lem:conservation}, \ref{lem:select_valid}}
\end{lemma}
\begin{proof}
According to Lemma \ref{lem:select_valid}, after the successful sending of a SELECT message in round ,  is valid at the end of round . 
According to Lemma \ref{lem:FLIP-valid}, after the successful sending of a FLIP message in round ,  is valid at the end of round . 
If  sends a failed SELECT or a failed FLIP then  is valid after the round by Lemma~\ref{lem:CANCEL}.
In otherwise,  is also valid the round by Lemma~\ref{lem:conservation}.

 \end{proof}


\begin{theorem}[Resulting forest correctness]
  \label{lem:nodes_validity}
  If all nodes are valid at the beginning of the the round , then 
all nodes are valid after round .
\depends{ \ref{lem:T-vald}, \ref{lem:N-parent} }
\end{theorem}
\begin{proof}

Assume that  a node  is invalid after round .
According to Lemma \ref{lem:T-vald}, .

Let  be the finite series of nodes such 
that for ,
, , and .
This series exists because  is valid at the beginning of round .

Let  be the infinite series of nodes such 
that for all 
,  and 
. 
This series exists because  is invalid (by hypothesis).

According to Lemma \ref{lem:N-parent}, , .
According to Lemma \ref{lem:T-vald},  is valid.
So all nodes of the series  are valid.
There is a contradiction.
 \end{proof}


\section{Convergence and preliminary discussion on performance}
\label{sec:simulation}

Our main focus in this paper was to present the spanning forest algorithm and prove that it guarantees a number of key properties, whatever the dynamics. Somewhat ironically, the same properties are satisfied even if the algorithm does nothing beyond initialization: every node remains forever a single-node tree, which satisfies all the predicates. Naturally, one expects more than this from an algorithm, which brings us to topics related to convergence and performance. We offer here a preliminary discussion on these topics, starting with what quality metric is adapted in such as context and how our algorithm behaves in this respect.


\subsection{What metric does make sense?}
\label{sec:metric}

The natural way to define an optimal (at least, irreductible) state in a spanning forest problem for partitioned networks is to have every connected component spanned by a {\em single} tree. However, even though 
one expects changes to obey some natural constraints depending on the mobility scenario, it is unreasonable to expect that an algorithm (however good it be) has sufficient time to converge towards an irreductible state in-between changes. Another remark is that the execution of algorithms for this type of problems never terminates; they are ever going.

In this context, a reasonable metric for evaluating our algorithm (or comparing two algorithms) is rather the average {\em number} of trees in each connected component, taken {\it e.g.} over the execution or in a stationary regime (if a stochastic model of dynamic networks is used for generating an infinite lifetime network). This being said, if the network {\em were} to stabilize, then one would indeed expect that a single tree to span each component. Both aspects are now discussed.


\subsection{Convergence in case of network stability} At an abstract level, the spanning forest algorithm presented in this paper relies on random walks in trees. Since trees are bipartite graphs, it may so happen that two tokens never meet (at both extremities of a common edge), although their trees could have been merged. 
Standard techniques exist for preventing periodic walks, such as stopping the tokens occasionally (also called lazy walks). This variant is easy to incorporate in the existing algorithm, by having a node decide whether or not circulating the token (FLIP messages) with some probability. Apart from this, markov chain theory tells us that (again, if the graph does not change) the tokens {\em will} eventually meet and thus every component will eventually be spanned by a single tree. The speed of this convergence relates to the area of coalescing random walks (see {\it e.g.}~\cite{Cooper13}), which is out of the scope of this paper (and beyond our technical skills).

\subsection{A practical scenario}
We verified the applicability of our algorithm in a real world
scenario. The algorithm was implemented\footnote{The source code of our algorithm is available upon request.} using the JBotSim library~\cite{C13} and 
tested against the {\tt Infocomm06} dataset~\cite{infocom06}. This well known dataset is a record of the communication links among devices given to
  people during the {\sc Infocomm} conference in 2006.
The update rate for the links is every 120 seconds, which means that
the presence time of an edge is a multiple of 120 seconds, a somewhat
optimistic value. 
To counterbalance this, we chose pessimistic options as to the number of 
rounds the nodes can perform in one second: 10 rounds (mildly pessimistic) or 1 round (very pessimistic).
In each case, we measured the average number of trees per connected
component over the execution (as discussed in Section~\ref{sec:metric}). The results are shown on Figures~\ref{fig:infocomm10} and~\ref{fig:infocomm1}, in which every point corresponds an average over 100 executions. 
\begin{figure}[h]
\center
\includegraphics[scale=0.45]{infocomm10}
\caption{Number of roots per connected components, assuming 10 rounds per second.}
\label{fig:infocomm10}
\end{figure}
\begin{figure}[h]
\center
\includegraphics[scale=0.45]{infocomm1}
\caption{Number of roots per connected components, assuming only 1 round per second.}
\label{fig:infocomm1}
\end{figure}

As one can see, the number of trees per connected component is often close to  ( in average in the first case, and  in the second case). Furthermore, the algorithm achieves an optimal configuration of a single spanning tree per connected component  about  of the time in the first case ( in the second case), which implies that the algorithm may be relevant in practical scenarios and thus worth further investigation regarding its performance.
 




















\section*{Acknowledgment}
{\small This work was partially supported by ANR projects ESTATE (ANR-16-CE25-0009-03) and DESCARTES (ANR-16-CE40-0023).
}

\bibliographystyle{plain}
\bibliography{spanning-forest}







































\end{document}
