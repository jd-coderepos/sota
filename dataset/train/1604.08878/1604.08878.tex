\providecommand{\keywords}[1]{\textbf{\textit{Keywords:}} #1}
\documentclass[12pt]{article}
\title{Stack and register complexity of radix conversions}
\author{Motoya Machida\footnote{Tennessee Tech.\ University, email: {\tt mmachida@tntech.edu}}\and 
Alexander Y.~Shibakov\footnote{Tennessee Tech.\ University, email: {\tt ashibakov@tntech.edu}, Corresponding author}}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\begin{document}
\maketitle
\begin{abstract}
We investigate the question of computational resources (such as stacks
and counters) necessary to perform radix conversions. To this end it
is shown that no PDA can compute the significand of the best
-digit floating point approximation of a power of an
incommensurable radix. This extends the results of W.~Clinger. We also
prove that a two counter machine with input is capable of such conversions. On
the other hand we note a curious asymmetry with respect to the order in
which the digits are input by showing that a two counter machine can
decode its input online if the digits are presented in the
most-to-least significant order while no such machine can decode its input in this
manner if the digits are presented in the least-to-most significant
order. Some structural results about two counter machines (with input) are also
established.
\end{abstract}
\keywords{floating point arithmetic, radix conversions, push-down automata, two counter machines}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{proposition}{Proposition}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{question}{Question}

\def\ttd{{\tt d}}
\def\ttD{{\tt D}}
\def\ttC{{\tt C}}
\def\ttb{{\tt b}}
\def\dg#1{\mathop{\to}\limits^{#1}}
\def\df#1{\mathop{\Rightarrow}\limits^{#1}}
\def\ndf#1{\mathop{\Rightarrow}\limits^{#1}\varnothing}
\def\nndf#1{\mathop{\not\Rightarrow}\limits^{#1}}
\def\dgn#1{\mathop{\to}\limits^{d_{#1}}}
\def\gstop{\diamond}

\section{Introduction}
Among D.~Matula's pioneering papers that laid the foundation of
modern floating-point arithmetic is \cite{Matulainout}, that investigates the
subject of radix conversions. A number of different authors produced a
variety of results dealing with the efficiency and precision issues of
conversions of floating-point numbers between different radices. The
two papers that formed the basis for subsequent work in this area are
\cite{Steele} and \cite{Clinger}. 

While the subject of principal concern for most authors working in
the field of computer arithmetic is the efficiency (both time and
space) of the algorithms performing such conversions, the question of
minimal `resources' needed for such computations was raised already by
D.~Matula in \cite{Matulainout} and further investigated by W.~Clinger
in \cite{Clinger}.

W.~Clinger's results in \cite{Clinger} have been used to justify the
use of infinite precision 
arithmetic by all known algorithms dealing with radix
conversions. One of his lemmas states that there
is no finite automaton that consumes a string of digits representing
an exponent and outputs the first digit of the best approximation of
the corresponding power of some {\ttD} in a radix that is not
commensurable with {\ttD}. He provides a separate proof for each direction of the input 
(i.e.~least or most significant digit first) and then points
out that his proof of the former is
somewhat incomplete in the sense that it does not work for all possible radix
combinations, although it does succeed for the most common case of base 10
being used for the exponent encoding and 2 for the new radix. Somewhat less important,
the proof only deals with case of the precision
of the converted result being  and not  as would seem
intuitively sufficient.

\iffalse
W.~Clinger's results can be restated by borrowing the language of automatic
sequences (see \cite{Allouche} for a reference) as follows.
Given positive integers {\tt D} and {\tt d} let  be
defined so that for some ,  is the best
1-digit (for simplicity, assume , and pick rounding to even
to settle ambiguous cases) approximation of
. Then Lemma~8 of \cite{Clinger} implies that 
 is not -automatic for any integer
. Using the robustness of -automaticity (see
\cite{Allouche}, Theorem~5.2.3), one can see that the case of the
least-significant digit first exponent input now follows from the general
properties of -automaticity, and does not require a separate
number theoretic argument such as Lemma~10 of \cite{Clinger}. 
\fi

W.~Clinger's results can be restated by borrowing the language of automatic
sequences (see \cite{Allouche} for a reference) as follows.
Given positive integers {\tt D} and {\tt d} let  be
defined so that for some ,  is the best
1-digit (pick rounding to even to settle ambiguous cases)
approximation of  if ;
otherwise, it represents the best 2-digit approximation.
Then Lemma~8 of \cite{Clinger} implies that 
 is not -automatic for any integer
. Using the robustness of -automaticity (see
\cite{Allouche}, Theorem~5.2.3), one can see that the case of the
least-significant digit first exponent input now follows from the general
properties of -automaticity, and does not require a separate
number theoretic argument such as Lemma~10 of \cite{Clinger}. 

The simple argument above shows that W.~Clinger's results indeed imply
that a fixed amount of memory is not enough to implement basic radix
conversions. From the computability perspective
though, it is still interesting to investigate how complex radix
conversion algorithms must be. Here, we use {\it complex\/} in a naive
sense, as a measure of the sophistication of the computational
`machinery' involved in implementing an algorithm. To be somewhat more
precise, having seen that a finite automaton cannot perform the
computations we require, one can ask whether a push-down automaton is
enough. An automaton with two stacks? Two counters? Questions like
these have been posed before. As an example, see~\cite{holkutr}, whose authors
investigate the register complexity of programs composed of various
looping constructs.
 
A push-down automaton (PDA for short, see \cite{hum}) can produce output
using a function that decodes its final state
in a manner similar to a deterministic finite automaton with output (DFAO,
see \cite{Allouche}).

In this paper we aim at establishing a `computability boundary' for
the task of radix conversions in the sense just outlined. We show that
the addition of a stack is not enough to carry out the required
computations.

In the second part of the paper we turn our attention to automata with
two {\it counters\/} (i.e.~two stacks whose stack alphabets consist of
a single symbol). We define a {\it two counter Minsky machine with
  input\/} (TCMI) by analogy with DFAO and provide a simple proof that such a
machine can compute any radix conversions. The subject of two counter
machines has a long history dating back to the original paper by
M.~Minsky~\cite{Minsky}. A curious phenomenon was noted early on (see
\cite{Schroep}, \cite{Bardz}, and \cite{ibarra}) that the full power of
a two counter machine can only be `tapped' via an exponential encoding
of its input and output. Without such an encoding, even the simplest
functions like  are not computable by a TCM (see \cite{Schroep},
\cite{Bardz}, \cite{ibarra} for this and many other results of the same
flavor).

The addition of an input brings about a new level of complexity
because an encoding is supplied automatically. As an
example, to the best of the authors' knowledge, it is still unknown
whether a TCM can compute  when given  in one of the counters
(see \cite{Schroep}). On the other hand, a TCMI can simply count the
zeros in its input to output  when the input is the digits of
 in radix 2 (the subject of using a different radix is a separate
problem). 

We show (see~Proposition~\ref{mosttoleast}) that whenever the digits of 
(in an arbitrary positive integer radix ) are input starting
with the most significant digit, a TCMI can compute the value of 
{\it online\/}, i.e.~the value of  is available in one of the
counters as soon as the input is stopped (i.e.~no {\tt stop} marker is
necessary). Somewhat surprisingly, it can be shown that no TCMI is
capable of such a feat if the digits of  are input starting with the
{\it least\/} significant one (see Theorem~\ref{tcexact}). It is
unknown to the authors whether a TCMI can compute the value of  if
a {\tt stop} marker is a part of the input alphabet along with the
radix  digits. We also present some evidence that a TCMI may in
some sense be
computationally {\it weaker\/} than TCM when the input to the TCMI is 
presented least significant digit first. Namely we show (see
Theorem~\ref{mmach} and Theorem~\ref{tcmio}) that for an
unbounded function  computable by a TCM (in the sense that such a
TCM halts with the value of  after having been `loaded'  in
one of its counters) a TCMI that outputs  upon being
presented the digits of  in least to most significant order exists
if and only if a
TCMI exists that can compute  using the same input (in which case a
TCMI can obviously compute ). This
asymmetry with respect to the order in which the input is presented is
rather unexpected in light of the result about the robustness of
automatic sequences mentioned above and the intuitive perception that
a DFAO has a very limited `memory' compared to a TCMI.  

Before proceeding with the formal definitions and statements of the
main results of this work, it is instructive to take another
look at the arguments in \cite{Clinger}. The core of W.~Clinger's proof
is formed by his Lemma~9 (see \cite{Clinger} or Lemma~\ref{ecli} below
for a slightly weaker statement) 
and {\it Kronecker's lemma\/} each highlighting different aspects of
the dynamic behavior of irrational numbers such as  for
an {\it incommensurable\/} pair  (the irrationality of
 can be taken as the definition of
incommensurability of such a pair). 

Such dynamic behavior manifests
itself in many areas of science and mathematics. For some interesting
connections to other areas of mathematics see, for example,
\cite{Arnold}, Ch.~3, Exercise~4 that illustrates a curious relationship
between Poincar\'e's recurrence theorem (similar in spirit to
Kronecker's lemma) and the digits of powers
of~2. Also closely related to this subject is {\it Benford's law\/} of digit 
distribution (see \cite{Benford} and
\cite{Newcomb}, as well as \cite{Hill}; \cite{Rauchetal} provides a
curious application of Benford's law to economic forensics) which
emphasizes a statistical facet of  type dynamics.

On the other hand, a simple but clever Lemma~9 of \cite{Clinger}
quickly leads to deep number theoretic questions such as the normality
and automaticity of  and similar numbers, automaticity of the digit sequence
of , etc.\ (see \cite{Allouche}) if one wishes to obtain a
stronger inequality.
 
\section{Basic definitions and notation}\label{autom}
To provide some motivation for the results in this section let us begin
by restating the problem of {\it 
  computing\/} a conversion as a problem of {\it recognizing\/} the
digits of the result of the conversions. Lemma~10 of \cite{Clinger},
declared `redundant' above takes on unexpected significance as it
seems that the part of the proof in \cite{Clinger} based on
Kronecker's lemma (see \cite{Hardy}) does not lend itself to a similar
generalization. 

Below we use the notation , where , and  is a
letter in some alphabet , to mean a string in  that
is a concatenation of  copies of .

\iffalse
Given the `input radix' {\tt D}, the `output radix' {\tt d}, and the
`exponent radix' , consider the following language  where {\tt 1} and {\tt 0} are
-digits. This language can be partitioned into , , where 

We again assume  for simplicity. It is easy to see that if
one of  is not a regular language, then the sequence  above is not -automatic thus proving that radix
conversions cannot be computed using finite automata. For some
combinations of  and {\tt d} we have the following stronger statement:
\begin{lemma}\label{cling}Provided , some of  are not context-free.
\end{lemma}
\begin{proof}Suppose  is context free for each . Then,
  the standard pumping lemma for CFL's (see \cite{hum}) implies that for
  each such  there
  exist  such that for any  . Putting  to be the product of all 's
  we conclude that for a large enough , if 
  then so is . Using Lemma~9 of \cite{Clinger} there
  is an arbitrarily large  such that

The same argument as that of Lemma~10 of \cite{Clinger} shows that
this contradicts  and  both being
in .
\end{proof}
\fi

Following the established tradition, we also use  to
denote the fractional part of 
(i.e.~). This should not cause any confusion
with the use of  as a regular expression for a string of
's. Note that  is continuous at
every  such that .

Given the `input radix' {\tt D}, the `output radix' {\tt d}, and the
`exponent radix' , consider the following language  where {\tt 1} and {\tt 0} are
-digits.
Let  be fixed.
This language can be partitioned into ,
, where 

We again assume that  if .
It is easy to see that if
one of  is not a regular language,
then the sequence 
above is not -automatic thus proving that radix
conversions cannot be computed using finite automata. For some
combinations of  and {\tt d} we have the following stronger statement:
\begin{lemma}\label{cling}
Suppose that  and  are incommensurable.
Provided , some of  are not context-free.
\end{lemma}
\begin{proof}Suppose  is context free for each
.
Then Lemma~\ref{cycle} implies that for
each such  there
exist  such that for any  . Putting  to be the product of all 's
  we conclude that for a large enough , if 
  then so is . Using Lemma~9 of \cite{Clinger} there
  is an arbitrarily large  such that

The same argument as that of Lemma~10 of \cite{Clinger} shows that
this contradicts  and  both being
in .
\end{proof}

A slightly surprising feature of the proof above is its dependence on
a particular relationship between the different 
radices. Intuitively, no such dependence should exist. The
trivial nature of the languages  also suggests that the
inequality of Lemma~9 of \cite{Clinger} could be improved if more had been
known about the distribution of -digits of  for
different radices . It seems, however, that even the most basic
questions of this kind (such as, how often, if at all, a certain
digit appears in the decimal expansion of ) are rather
hard (see~\cite{Allouche} or \cite{Hardy} for some examples).

We use standard definitions for most concepts appearing in this paper
as well as their natural extensions. If
 is a string of -digits for some radix , we write
 to indicate the value of the corresponding
number in radix  where we assume that the least significant
digit of  is the leftmost one. If the least significant digit of 
is the rightmost one we let  stand for the value
of  in radix .

In the proofs below we only use the natural correspondence between
PDAs and CFLs (see \cite{hum}) and thus do not need the definition of
a PDA. Since  a {\it deterministic\/} PDA provides a good introduction
to two counter machines treated later let us define this narrower
concept.

A {\it deterministic push-down automaton\/} (see \cite{hum}, we assume
for simplicity that the stack is changed one symbol at a time)  is defined as a 7-tuple  where  is a finite set of
{\it states},  is the {\it input alphabet},  is the {\it stack alphabet},
 is the {\it initial state},  is the {\it start
  symbol\/},  is a set of {\it final states\/}, and the
partial function

is a collection of {\it moves\/}. Some additional restrictions are
placed on : each move  is either a {\it pop
  move\/} (where ), i.e.~``if the input symbol is , the top stack symbol is
 and the current state is , remove  from the stack and go to
state '', a {\it
  push move\/} with a similar natural meaning, namely, ``under
the circumstances as above, push  on the stack'', or a {\it no change
  move\/}. If , the interpretation of
 is ``ignore the input for the moment, do
something to the stack and go to
the next state ''. We require that whenever  is
defined, no other  is defined (i.e.~the DPDA is
never asked to choose whether or not to consume the input). Such moves
are called {\it -moves\/}
and can be thought of as the post- or preprocessing performed by the
DPDA. Naturally, when the stack is empty, no pop moves are
possible. Empty stack can be recognized when the special symbol 
is on top of the stack.  cannot be popped or pushed.

The input alphabet is 
everywhere below, where  is some fixed radix.
The existence of -moves is the reason the input alphabet
includes a {\it stop
  marker\/}, , to give  one more chance at processing the
stack it has accumulated. We will assume that  means the input
is finished and that it appears only once at the end of the input. This
is not part of a standard DPDA definition but is assumed everywhere
below. If the sequence of -moves following
the appearance of  in the input does not affect the stack, we
say that  processes its input {\it online} (this concept becomes
much more important for two counter machines with input defined later).



One can view  as a machine (which is, indeed, the terminology often
used in this context) that starts in  with only  on the
stack then reads and processes its input one
symbol at a time, until it sees  (in the general case this is
unnecessarily restrictive but we will always follow this convention) upon
which it enters the final phase of processing consisting of some
-moves until it ends up in one of the states in . The
particular state of  at the end of the computation is 's {\it
output\/} and can be thought of as a finite encoding of the result 
is built to produce.

\iffalse
Following the established tradition, we also use  to
denote the fractional part of 
(i.e.~). This should not cause any confusion
with the use of  as a regular expression for a string of
's. Note that  is continuous at
every  such that .
\fi

\section{Radix conversions and PDAs}

To show that PDAs cannot compute radix conversions, we again restate
the computation problem as a recognition problem for the languages
defined below.
\begin{definition}Let , , and  be fixed radices. Let
   if  and  if . Define 
  to consist of all sequences of -digits  such that the best -digit
  approximation in radix  of  is
   if  or  if .  can be defined similarly with  instead.
\end{definition}
Just as before, it is immediate that if one of the 's or 's
is not context-free there is no PDA that computes the best -digit
floating point approximation of  where  is presented in
radix  in the appropriate order.

\iffalse To show that one of the 's as well as one of the 's is not
context-free we use the following strong generalization of Ogden's lemma
(see \cite{hum} and \cite{Kracht}). Recall that for a , the pair  is
a {\it pumping pair\/} if for every  .

\begin{theorem}[Manaster-Ramer, Moshier, and Zeitman, see
    \cite{Kracht}]\label{inpum}
Let  be a CFL. Then there exists a number  such that if  and we are given  occurrences of letters in  there are
 independent pumping pairs, each of which contains at least one and
at most  of the occurrences.
\end{theorem}

For the proof below we only use the following properties of the
pumping pairs above:
they are disjoint, nonempty, can be pumped independently (in a natural sense),
and  can be arbitrarily large.

\begin{lemma}\label{cycle}Suppose each ,  is
  context-free. Then there exists a  such that for any
 there exists an  such that for
  some  the word  has length
   and there is a  such that for every
   every .
\end{lemma}
\begin{proof}
Since each  is context-free one can use Theorem~\ref{inpum} to find
an  with the property stated in the lemma. Let  be a
positive integer divisible by every . Put  and
pick  large enough so that  is divisible by
 and . Suppose  for some
. Label all  letters in . Find 
disjoint independently pumpable pairs using Theorem~\ref{inpum}. Since
the pairs are disjoint the choice of  implies that there exists at
least one, say  such that both  and  consist only of the
's between  and  in  and either 
or  is nonempty. In addition, both  and  consist of labeled
digits only. Therefore for some  and every  the words . Now put .
\end{proof}
Note that a similar proof can produce  and  such that  instead and  replaces .
\fi 

To show that one of the 's as well as one of the 's is not
context-free we modify the standard pumping lemma (see e.g., Theorem~7.18 of~\cite{hum})
to pump without disrupting the prefix and the suffix. The result of
the lemma is also a corollary of a very powerful {\it Multiple Pumping
  Lemma\/} (see \cite{Kracht}, Theorem~1.82). The proof of the
Multiple Pumping Lemma has not been published, however, so we present
the following direct proof instead.

\begin{lemma}\label{cycle}
Suppose that  is a CFL.
Let  and  be fixed.
Then there exists a number  such that
if  with  then
we can find  satisfying
 for .
\end{lemma}
\begin{proof}
If 
then the claim is obvious from the standard pumping lemma.
Thus, we assume .
The proof follows that of Theorem~7.18
of~\cite{hum} almost exactly, 
using a Chomsky normal form (CNF) grammar which expresses .

Let the CNF grammar have  variables,
and set  and .
Suppose that  with .
Then the longest path of a parsing binary tree for 
has  edges with ,
containing  productions
of the form 
or  for ,
starting from the root .
We can find 
a list of consecutive variables
 of size at least 
such that the subtree  generates a substring of 
for every ,
and consequently we can find 
such that .


We write the yields of the subtrees 
and  as  and  respectively.
As in the proof of the standard pumping lemma we have
 and  for any ,
where .

Furthermore, one of the following cases must hold for :
({\it i\/})  with ;
({\it ii\/})  with suffix  of  and ;
or
({\it iii\/})  with prefix  of  and .
Now we can find an appropriate 
as required. Namely,
if ({\it i\/}) holds then we put ;
if ({\it ii\/}) holds then  so put ;
if ({\it iii\/}) holds put  since .
\end{proof}

Next we proceed with the number theoretic results that take advantage
of the combinatorial lemma above. The first statement is the
famous Kronecker's lemma in a slightly weaker form than the original
(see~\cite{Hardy} for the full version and the proof).

\begin{lemma}[Kronecker's lemma, see~\cite{Hardy}] The set
   is dense in  for
  every irrational .
\end{lemma}

The following lemma is an easy corollary of \cite{Clinger},
Lemma~9 whose proof is based on the analysis of the fractional part of
 presented in radix .

\begin{lemma}[\cite{Clinger}]\label{ecli}Let  be irrational,  be a
  natural number. Then there exist
  infinitely many  such that for ,
  :

\end{lemma}

Unfortunately, the inequality above is too weak for our goals and has
to be amended. At present we do not have the number theoretic tools to
produce a `clean' proof of a better inequality and have to take an
indirect approach, instead, by modifying a few digits of the number. The first
modification puts the iterate of  in one of the two ranges. It
seems that it should be possible to ensure that it ends up in a
specific range, however it is unclear how to do that at the moment.
 
\begin{lemma}\label{qrational}
Let  be irrational,  be an integer. Then there exists
an integer  and an infinite sequence  of
integers such that either 
 or

\end{lemma}
\begin{proof}
Using Lemma~\ref{ecli} find an infinite sequence  such that
. Using the
sequential compactness of , and picking a
convergent subsequence if necessary, assume that
 exists
and . If  is irrational, use Kronecker's
lemma to find  such that . Otherwise, 
where  and  are relatively prime and . Let integers  and
 be chosen so that ; then . Thus
 or  depending on the signs of  and
. After multiplying  by  if necessary, we can assume
. Putting , we have
. 

Now, for each , either

or
. Thus,
after possibly choosing a proper subsequence, either
 or
.
\end{proof}

The second modification establishes the desired inequality.
\begin{lemma}\label{normalize}
Let  be irrational,  and , 
be such that  and either  or
. Then there is an increasing
subsequence ,  and an integer  such
that
.
\end{lemma}
\begin{proof}
The only nontrivial case is
. Picking
a subsequence if necessary, assume  (the other case
is similar) and
 exists. Using Kronecker's lemma, pick an integer 
so that . Then 
for some integer  so .
Put  and
.

Now  and
.
Thus  and
 imply
. Hence
. 
\end{proof}

The lemma below deals with pairs of irrationals. It establishes a
finite bound on the number of iterations required to put each in a
desired `slot'.
\begin{lemma}\label{mixing}Let  be irrational,
, . Then there
exists an  such that for any
 satisfying
 and
 there exists a  such that  and
.
\end{lemma}
\begin{proof}Kronecker's lemma implies the existence of
 such that for any  the set 
 has the property
 and 
 Now consider two cases. 

(1) . Let  be such 
that . Let
 for some integer .
Then .
Also
. Thus .

(2) . Let  be such that
 is in  and
 for some integer .
Then

and . Hence
.
\end{proof}
Note that the choice of  in the lemma above implies that
.

The results above are put to use in the following theorem. Recall that
an {\it -digit best floating point approximation\/} in radix  to a real  is a
floating point number  such that
 where ,  and where
 only if . Such an approximation
is unique whenever  which is the only case we need below.
\begin{theorem}\label{pdacs}
If  and  are incommensurable,  or  
then there are  such that  and
 are not context-free.
\end{theorem}
\begin{proof}
Put  and  where  is the radix in which the exponent is
presented and  is as in Lemma~\ref{cycle}. Use
Lemma~\ref{qrational} to find a sequence of 's and a  such
that either  or

holds. Now apply Lemma~\ref{normalize} and possibly rename the terms
of the sequence to find  so that 
.

Picking another subsequence if necessary assume
 
(the case of the opposite inequality is similar).
Suppose  are chosen so that . Omitting finitely many initial
terms of the sequence if necessary, one can find an  such
that  for all
. Apply Lemma~\ref{mixing} to find an
 such that for any  there exists a
 with the property that 
 and
. Thinning out the
sequence again one can assume that there is an integer  such
that for every   and
.
 
\iffalse Let  be the -digits of , and  be
the -digits of . Use Lemma~\ref{cycle} to find  and  then pick 
large enough so that , and  satisfies an additional
property mentioned below.
Lemma~\ref{cycle} implies that both 
 and 
 are in the same
 (or  after the strings
have been reversed accordingly and the remark after Lemma~\ref{cycle}
has been 
applied). Thus the -significands of 
and  are the same. 
\fi 

Let  be the -digits of , and  be the -digits
of .
Use Lemma~\ref{cycle}, and choose  so that
.
Then pick  large enough so that , and 
satisfies an additional property mentioned below.
Lemma~\ref{cycle} implies that both

and

are in the same 
(or  after the strings have been reversed accordingly).
Thus the -significands of 
and  are the same. 

First suppose ,
, and
, where
, , . Now

therefore picking  with  implies
that the first digit of the significand of (the best approximation of)
 is . Let 
and suppose it is possible to choose  so that
. Then for some 
. Let  be
chosen large enough so that 
. Now

and
. Thus
the first digit of the significand of
 is between  and 
contradicting our assumption.

The case of  is somewhat special since the first digit of the
significand is always . In this case we pick
 for ,  and 
so that . An argument
similar to the one for  shows that the second digit of the
significand of  is  while the
second digit of the significand of 
is~.

To complete the proof it is sufficient, for every , to pick
 ( in the case ) so that 
 and 
(respectively  and
 for ).

Consider three cases.

(1) . Put . Now it can be easily
verified that . Since  decreases as
 increases for any  it follows that
. A simple computation also shows that 
 for .

(2) . We must pick an  so that 
. That such  exists
follows from  and .

(3) . We must pick  so that
. The existence of
 is a consequence of  and
.
\end{proof}

\section{Clinger's problem for two counter machines}

Implicit in~\cite{Clinger} is the following problem.
\begin{definition}
Consider the problem of determining whether a
specific class of machines can compute the best -digit
approximation in radix  to ,
where  and  are integers and  is positive. If a machine from a given class can
compute the significand of the best approximation we say that such a machine
``solves Clinger's problem of the floating point arithmetic''.
\end{definition}

D.~Matula (see \cite{Matulainout} and \cite{Clinger})
demonstrated that this problem can be solved by a deterministic finite
automaton (DFA) if  and  are commensurable.
By Theorem~\ref{pdacs} we now know precisely that it is the only affirmative result
for PDA (or DFA), which we state as the following corollary.
\begin{corollary}
Clinger's problem of the floating point arithmetic can be solved by a PDA
(or DFA) if and only if  and  are commensurable.
\end{corollary}

Having seen that a DPDA is too limited to
compute radix conversions, it is natural to seek a more powerful
machine to accomplish the task. A straightforward modification of the
DPDA concept immediately leads to the definition of a {\it
  deterministic push-down automaton with two stacks} (DPDA2S for short). Such automata,
however, are {\it too\/} powerful for our purposes. To limit
their computational power we can consider DPDA2S whose stack
alphabets are limited to two symbols each (two, because we need a
special  that indicates the bottom of each stack). It is easy to
see that the configuration of such an automaton can be described by its
current state and the two values representing the number of symbols other
than  currently on the stack. Hence, each stack acts simply as a
{\it counter\/} and the construction just presented defines a {\it two
counter machine with input\/} or TCMI for short.

A TCMI is capable of carrying out very sophisticated
computations even when no input is present. Indeed, when the
only moves a TCMI is allowed are -moves, we arrive at the
concept of a {\it two register Minsky\/} machine (TCM). As M.~Minsky showed
in \cite{Minsky}, for any recursive function  there is a TCM that
computes  in the sense that a computation that starts with 
in one register (counter) and zero in the other terminates with the
value of  in one of the registers and zero in the
other (\cite{Minsky} used  to encode the output but  is
enough, see \cite{Bardz}). Another result in \cite{Minsky} shows that the addition of yet
another, third register would allow such a machine to compute 
directly, starting with  (rather than ).

A number of authors had proved that the addition of a third register is
indeed necessary, and that the exponential encoding cannot be bypassed if
one wishes to retain the full computational power of a TCM (see
\cite{Schroep}, \cite{ibarra}, \cite{Bardz}, and \cite{holkutr}). The authors of
\cite{ibarra} prove that even a {\it characteristic function\/} of the
set of exact squares, for example, is not computable by a TCM. Neither
are elementary functions such as , , or  (see
\cite{Bardz} and \cite{Schroep}).

A TCM can be thought of as a program in a simple language
, , {\bf if  then goto
  }, {\bf goto },  where  can be one of
the two variables. A TCMI extends this language to include a number of `{\bf if
   goto }' commands, one for each possible value  of the
special input variable . It is convenient to think of a TCMI as a
collection of several TCM's sharing the two counters, each TCM
dedicated to the processing of a specific input symbol. If such a TCM
that processes the stop marker,  never changes the counters, we say that the
TCMI processes its input {\it online} by analogy with the DPDA case.
After each TCM is done with the processing it arrives at a line (which
we will think of as a state, ) with one of the input commands. We
will refer to such a line as a {\it wait state\/}.


\iffalse To show that a TCMI is capable of performing the task of radix
conversions, we present a brief sketch of the proof of the following
proposition. Note that this result can be improved in a variety of ways, one
of which would be to allow a TCMI to consume {\it two\/} numbers
separated by a stop marker and then produce the significand of the
corresponding floating point number in a new radix.

\begin{proposition}\label{tcmo}
For every combination of radices , , and
  , and any precision  there exists a TCMI that
  computes the significand of the best -digit approximation of  in radix
   online, where  is
  presented in radix  whether least or most significant digit first. 
\end{proposition}
\begin{proof}
The methods of \cite{Minsky} show that a TCM can simultaneously
compute the values of {\it multiple\/} recursive functions
 by keeping its input encoded in the form
. Thus if  holds the value of the
number input `so far',  holds the number of digits seen (to take
into account any leading zeros), and  represents the significand
of the best -digit approximation using some encoding, the
computation can proceed by decoding the value of  using
successive divisions (of which there could only be a bounded number as
there are only finitely many values a significand can assume).

Now, upon seeing the next digit the appropriate TCM simply increments
, and computes the new value of  using a straightforward
computation followed by  which is obviously a recursive function
of .
\end{proof}
\fi 

We can show that a TCMI is capable of performing the task
of radix conversions, and present a brief sketch of the proof of the
following proposition.
\begin{proposition}\label{tcmo}
For every combination of radices , , and
  , and any precision 
Clinger's problem of the floating point arithmetic can be solved
by a TCMI online.
\end{proposition}
\begin{proof}
The methods of \cite{Minsky} show that a TCM can simultaneously
compute the values of {\it several\/} recursive functions
 by keeping its input (and output) encoded in the form
. It should be noted that the original
arguments of \cite{Minsky} used a more sophisticated encoding, namely  for the output but
several authors (see e.g.~\cite{Bardz}) had observed that  used
for the input as well as  for the output where  is some prime would
suffice. 

Thus if  holds the value of the
number input `so far',  holds the number of digits seen (to take
into account any leading zeros in the case of a least significant
digit first input), and  represents the significand
of the best -digit approximation using some encoding, the
computation can proceed by decoding the value of  using
successive divisions (of which there could only be a bounded number as
there are only finitely many values a significand can assume).

Now, upon seeing the next digit the TCMI simply increments
 (multiplying the counter by ), and computes the new value of
 using a straightforward computation followed by the computation
of  which is obviously a recursive function of .
\end{proof}

\section{Counting and the asymmetry of input}

It is still unknown (at least to the authors) whether a TCM is capable
of {\it decoding\/} its own output, i.e., for example to halt with the
value of  after having started with  in one of the registers.
It {\it is} known that a TCM is incapable of computing  (see \cite{Schroep}) but as R.~Schroeppel points out
in \cite{Schroep} these problems are not equivalent since a TCM that
computes  from  is not even assumed to halt on any input other than
.

It is thus natural to ask whether a TCMI exists that decodes its
{\it input\/}, i.e.~terminates with the value of  after being input the
digits of  followed by . This problem can be thought of as a
conversion to radix 1 if desired. If the nature of the input is
restricted, such decoders are certainly possible (see
Proposition~\ref{mosttoleast} below). 


Let a TCMI  compute the value of  after being input the
digits of  in some radix  followed by . If the digits
are assumed to be presented starting with the least significant one,
we say that  {\it counts in radix \/} or simply {\it counts
  in \/}. If the digits are presented starting with the most
significant one we say that  {\it counts in  in reverse}.
We have the following simple statement. Recall that computing {\it
  online\/} means that upon the input of  the values of the
registers do not change.
\begin{proposition}\label{mosttoleast}
For any radix  there exists a TCMI that counts in  online
in reverse.
\end{proposition}
\begin{proof}
When it is input  the TCMI multiplies the value it has computed so
far by  and adds  to the result.
\end{proof}

The authors of \cite{ibarra} introduce a number of tools that simplify
dealing with TCM's one of which is the idea of a {\it normalized\/}
TCM (called nTCM below). By requiring that each individual TCM in a TCMI be
normalized we arrive at the definition of a normalized TCMI or
nTCMI. While this concept is not required to carry out the proofs
below, the handling of some border cases is simplified when a TCMI is
actually an nTCMI so we tacitly assume that each TCMI is normalized
(we only need this concept in Lemma~\ref{linper} below). Since one of
the results in \cite{ibarra} is the fact that each TCM can be replaced
by an equivalent nTCM, this is not a significant restriction, and we
thus omit the definition of nTCM  and nTCMI here.

To simplify the notation, we will often record a configuration of a
TCMI  as  where  is the state,  and 
are the values of the counters, and  is an integer index. Using this notation
define  and . It is
often important to know which counter holds the smaller (larger)
value. We denote the index of the corresponding
counter as 
( respectively). Sometimes we
know only that one of the values is the value of the first counter,
therefore the other value is the contents of the other, such as 
and  for . In such cases we write
, omitting the comma. Thus  regardless of what  is.

To facilitate the handling of arguments involving computations performed by
 we introduce the notation  meaning
 will reach the configuration (although not necessarily halt)  if started in
 and being input . If  and  we write
 instead.
 
Finally, each computation is analyzed in terms of {\it stages\/} or
{\it phases\/} such that during each phase the values of both counters
are nonempty. To simplify the terminology we introduce the notation
 to mean that the first time  enters
a configuration  such that  after having
started in  and while being input  ( can be a
string so such a configuration can be encountered before  is fully
consumed), this configuration is . If
having started in  and being input a string  the machine never reaches a
configuration with one of the counters empty, we write . 

The analysis of a TCMI differs from that of a TCM in one important
aspect: a TCM is usually started with at least one counter empty and
terminates in a similar state. Simple arguments show that a TCM
performing any useful computation can be restricted to operating in
this manner (see Lemmas~\ref{fstg} and \ref{lstg} below for one
reason this is so). A TCMI is a different matter though. Imagine a
TCMI that counts the number of {\tt 0}'s in its input in one counter and the number
of {\tt 1}'s in the other, then multiplies the first value by the
last digit seen (to make the example nontrivial assume that the radix
is ) in the input and adds the two results. 
Even though the final output of the computation
is a single value, it is 
unclear if the same result can be achieved by a TCMI that keeps only
one of the counters nonempty before the next digit is input. 

If in all such cases
one of the values is bounded by a single constant this value can be
kept in the final control `buffer' instead, while emptying the
corresponding counter. The advantage of this would be the availability 
of various reduction results for TCMs such as the one in
\cite{Schroep} (see the proof of Theorem~\ref{tcexact} below)
for the analysis of the TCMI.

Our first goal is to show that such a bound exists {\it for every TCMI that
counts in some radix } thus showing that the anomaly
described above does not occur in such TCMIs.

The following lemma is a corollary of Lemma~2.2 of \cite{ibarra} (see
also \cite{ibarra}, Lemma~2.3 and the definition of an MP1RM in \cite{Schroep} and below).
\begin{lemma}\label{linper}
Let  be the number of states of some nTCM . Let , ,  list all the stages of some computation
performed by . Suppose  and  for all . 
Then there exist integer , , , and  such that for any
 and any computation , ,  such that , , and   and  for .
\end{lemma}

The next statement describes what happens when both counters hold
large enough values. As for most results of this kind, its proof is
based on cycle analysis of the machine. 
\begin{lemma}\label{fstg}
Let  be the number of states of some TCM . Let ,  be a configuration of  with the following
properties.  eventually reaches a waiting state when starting in . There exists a  such that
, ,  lists an initial stage of the computation
performed by , where  for , and
either  or  halts in  with . Then every configuration  with ,  has the same property and one of
the following two cases holds.
\begin{itemize}
\item[{\rm(1)}] There exist , , with the property that  and
   for any computation ,
  ,  such that ,
  . Moreover , ,  for ,
  and  halts in .

\item[{\rm(2)}] There exist integers , 
  with the following properties. Suppose , . Then 
   and 
  the following additional properties hold.
\begin{itemize}
\item[{\rm(a)}] If  then  and
   for some . Moreover there exist an  and a state  such that
  , and whenever , , the state
   and .

\item[{\rm(b)}] 
  If  then both  and
  there exist , , , and states  and  
  with the following properties. Suppose  for
  some , . Put . Then
   and .
  Moreover if  is replaced by a larger value, the length of the
  computation and the final state will not change and the expression above will remain
  valid. There also exists a constant  such that 
  implies . Finally, if  then ,  is
  independent of , and .

\end{itemize}
\end{itemize}
\end{lemma}
\begin{proof}
Suppose (1) does not hold. Then  does not reach a halting state
before one of the counters is empty. Since , . 
Therefore  enters
a loop and passes through the following sequence of states (we are
assuming  must halt eventually):
,
where , , and  for some  and
 such that . 
Thus  will reach the configuration  with 
and  for  for some .
 
Suppose . Note then both
. Otherwise the counters will be incremented
indefinitely and the loop will not terminate. Thus for any configuration  with ,  there is a state  such
that  with . 

To prove (b) assume  for some , , and
. Let  be . As long as counter~
stays nonempty throughout the whole computation, the value of  does not affect
the final state. Therefore,  depends only on the value of
counter~ at the beginning of the last (possibly incomplete) iteration of the loop.
But this value is easily seen to be the same for any  under the
conditions listed above. It remains to pick . Let ,  be the
amount counter~ is incremented by before  enters the loop and let
 be the value of counter~ at the beginning of the last
(possibly incomplete) iteration of the loop. Note that  and 
do not depend on the values of  and  as long as the
conditions above hold (i.e.\ counter~ is emptied first). Now
 for some  independent of  and
such that . Note that making the value of  larger at
the beginning of the computation does not affect the argument above.

To find  simply note that it is sufficient to pick  large enough
to ensure that counter~ is nonempty after the loop has run  times.

If  then .
That  follows from a simple observation that the values of
both counters before the final iteration of the loop are the same
whether  started in  or .
Thus (b) holds.

Now suppose . Then, say  and
. Thus counter~1 will be emptied first as long as
 (to ensure that the value of counter~2 cannot become 0
during the first iteration of the loop). Now the argument similar to
that for case~(b) above finishes the proof of case~(a).

If  then  would result in an infinite
loop. Therefore  and counter~2 is emptied first. The rest
of the argument is similar to the one for case~(b) using the remark in
the previous paragraph.
\end{proof}

If a TCM goes through a configuration with an empty counter, the final
smaller value of the counter will be bounded. This is the statement of
the following lemma. 
\begin{lemma}\label{lstg}
Let  be the number of states of some TCM . Let , ,  list a nontrivial last stage of some computation
performed by  (i.e.\ ,  for all  and
 halts in ). Then  and any computation , ,  such that , , and 
satisfies  and  for . 
\end{lemma}
\begin{proof}
First observe that the length of the last stage must be less than
 in order for  to halt in  (otherwise  would have entered a
loop which either does not terminate or empties one of the
counters). Thus  and both  and  are the contents of the counter that was
nonzero at the beginning of the appropriate computation (i.e.\ the
()th
counter, we also use  here). Since the sequence of
states  passes through must be identical in both cases, the other
counter gets incremented exactly the same number of times in either
computation.
\end{proof}

\begin{corollary}\label{zstg}
Let  be the number of states of some TCM  and  be an input symbol. Suppose
 and
. Then .
\end{corollary}

To ensure the applicability of Lemma~\ref{linper} the following
statement is used.
\begin{lemma}\label{lprefix}
For any  there exists a constant  such that any configuration 
that  passes through after inputting a string of digits longer than
 satisfies .
\end{lemma}
\begin{proof}
Otherwise  would output the same value for some strings of
different lengths, a contradiction.
\end{proof}

We can now turn our attention to the existence of the bound mentioned above.
\def\sgn{\mathop{{\rm sgn}}}
\begin{lemma}\label{boundt}
Suppose there exists a TCMI  that counts in some radix . Let
 list all the waiting states of . Then
there is a constant  such that for any input

the bound  holds for  and .
\end{lemma}

Before proceeding with the proof of Lemma~\ref{boundt} some
preliminary properties need to be established.
\begin{lemma}\label{unper}
Suppose, using the notation of Lemma~\ref{boundt} there is no  with
the claimed property. Then there exist a digit sequence , 
a state , a constant , an index ,
and  and , , with the following
properties. 
\begin{itemize}
\item[(1)] for any  there exists a digit sequence  such that
 where ,
;

\item[(2)]
 provided , .

\end{itemize}
\end{lemma}

\begin{proof}
Let  be an input such that  and
. If follows from Lemma~\ref{zstg} that there
exists a string  such that ,  so that  and  
for any  such that . Let  and 
 for some
. 

Since  one can apply Lemma~\ref{fstg}(1) to
find  and  such that  and

whenever . An easy inductive argument shows that
,
where  and  or
. Let  be such that . For
  ,  put 
 and
. Then
, therefore there exists an
 such that . Since  the sequence of
states  for some
 such that . Let  be the
smallest such that  has the desired properties. Put
,
 if  and
 if , where . It follows from 
that . Put . 

One can assume that the length of  is less than  using
the following construction. Suppose  is longer than 
and assume for the moment that  is large enough as explained
below. Among the first  states in  find one, say  that
repeats at least twice. Let  be the `contribution' to the value
of counter~ by the
subsequence of  that starts with  and ends just before
 is reached again. If  pick the corresponding
input digits as  and redefine . Otherwise shorten
 by removing the subsequence. This will only increase ,
and, if  is large enough will not cause counter  to
become 0 (counter  will only get larger than  where  is
the first state after the subsequence above). Now .  
An argument similar to that of the proof of  shows that .

That  for any ,  now follows from . Since 
is shorter than , counter  will not become empty while the
digits of  are input, whereas counter  values will only
increase if  is trimmed as discussed above. Hence the
sequence of states  follows in  is the
same as long as  and  are large enough.

We have shown that for any  there are  of length less than , ,
, ,  and ,
 that satisfy property~(2) in the statement of
the lemma, as well as an  such that  where ,
. Pick , , , , , and  such
that 
for arbitrarily large . For any  let  be an input such that 
 where ,
.

To show that  suppose . Let
. Then  where ,
.  Consider what happens after the following input:
. In the trivial case of 
inputting multiple copies of  does not change the
configuration  enters after inputting . Thus  produces the
same value regardless of , a contradiction. Hence either  or
.  If , since ,
Lemma~\ref{fstg}(1) shows that  for some small  and  whose value does not depend
on  and  as long as . Since
 for some ,  the
proof below will remain essentially the same if we assume that
. In this case
Lemma~\ref{fstg}(2) applies since otherwise  would imply
. Pick  and  as in Lemma~\ref{fstg}, note
that  for
arbitrarily large  and pick and integer  such that 
divides .  Let , , , set
 and consider the following cases,
depending on .

First suppose . Suppose  and use
Lemma~\ref{fstg}, property~(a) to conclude that ,
 where  and 
depend only on , , and . The state  does not depend
on the value of .

Second suppose  and use (b) of
Lemma~\ref{fstg}. If  then
 does not depend on  (see below) so we can assume
. Then Lemma~\ref{fstg} implies that
 where  does not depend on
. Since 
and

the state  or  does not depend on  according to the
remark at the end of the statement for case~(b) of Lemma~\ref{fstg}.
 
Finally suppose  for some
. If  is large enough then
 and

with  where  is given by Lemma~\ref{fstg}(1)(b).  Thus
 for all such  and
 where  and 
depend only on , , and .

Thus in all cases  arrives at the configuration
 where  and  are independent of
 and  stays the same for all  larger than some
constant. If  is allowed to continue then following the input of
 it will produce the value of  where  is the largest integer such that
 and  is the length of
. It is now a simple matter to construct a TCM  that will
compute the function  contradicting Theorem~3.4
of \cite{ibarra}.  will first test  to see if it is large
enough to satisfy . If not,  will use its finite control
to compute . Otherwise, it will compute the value of  and
place it in the appropriate counter. It will then pass the computation
on to  by putting  in counter  and emptying the other
counter. After  is finished,  will (after inputting 
and waiting for  to finish again) compute  from the
result produced by  which requires only a finite number of
multiplications, additions and divisions by fixed constants. Thus
. In this case  implies that for large enough 's
 is bounded, whereas 's output is unbounded for long enough
's, a contradiction.
\end{proof}

We can now proceed with the proof of Lemma~\ref{boundt}.

\begin{proof}[Proof of Lemma~\ref{boundt}]
Suppose the contrary and use Lemma~\ref{unper} to find , ,
, ,  and , with the
appropriate properties.  Let  be large enough. Consider what
happens when the input  for small enough  is
followed by  (the conditions on  and  are
discussed below).  Just as in the proof of Lemma~\ref{unper}, let
 for appropriately chosen ,
 and , let and  and  be the constants
provided by Lemma~\ref{fstg}(2) for the last stage of this
computation. Note that these constants are the same for all
configurations  such that
.

We assume, as in Lemma~\ref{unper} that both  is a multiple of
,  (if  is 0, the appropriate
requirement is considered satisfied automatically). Now consider the
following three cases.

(1)  and . Then
 where both 
and  depend only on the value of . Moreover,
 where the
state , and the constants  and  depend only on the value of
, provided  (if  this
inequality is automatically satisfied).

(2)  and . Then
 where  does not depend on 
or , , and  depends only
on  which is bounded by .

(3)  and . Using (b) of Lemma~\ref{fstg}
choosing  and  so that  one can show that
 where  does not depend on
 or ,  depends only on .

Construct an infinite sequence of strings  satisfying the following properties. There are , and
 such that for each   where
, either  or the remainder
, and  provided  is not 0. Note that all
 satisfy the same property (1)--(3) mentioned
above.

Note that the conditions above and the cases~(1)--(3) discussed before
the previous paragraph imply for some state 
.

Using Lemma~\ref{lprefix} to ensure that all the configurations 
enters after  have at least one counter
larger than  and taking a large enough  consider the output of
 given the input . Using Lemma~\ref{linper} find
the constants , , , and  with the property that the output
of  is  where  is
the first configuration  enters after  has been input
such that .

By taking a multiple of  we can assume that every appropriate
constant mentioned below divides . Next revisit the three cases
above.

(1) Find  large enough so that one can find  and  as
described below, where  that are both solutions of
 for some .  To see that this is
possible note that  so either  (which is
impossible) or .  Let  and let
 where . Now
put , . It is easy to see that 
so the existence of a large enough  so that the conditions in
case~(1) above are satisfied is immediate.  Then, on the one hand, 
should output  using the choice
of , , , and . One the other hand,  will output
 where ,
, , and  is the length of 
and  is the length of . Thus  and  but  while . Since , , and
 are fixed and  increases indefinitely as the length of 
increases choosing a large enough  results in a contradiction.

(2) Find  large enough so that one can find small enough  and
, where  that are both solutions of  for some . That such
solutions exist follows from  and  for some integer  and . The rest is
similar to case~(1).

(3) Similar to case~(1) with  replacing .
\end{proof}

The following theorem is a corollary of Lemma~\ref{boundt}.
\begin{theorem}\label{tcmired}
If there exists a TCMI that counts in some radix  then
there exists a TCMI  that counts in  such that
 where  for every input .
\end{theorem}
\begin{proof}
Use Lemma~\ref{boundt} to find  and change the finite control of the
original TCMI so that all counter values less than  are kept in the
buffers in the finite control.
\end{proof}

The utility of the theorem above lies in the idea that each
computation performed by a TCMI between inputting two successive
digits is a computation of a new value based on the intermediate
result of the previous computation, i.e.\ only one value is needed to
represent the intermediate result. Hence, if the TCM `responsible' for
each digit can be
simulated by some other machine under the assumption that it starts
with one empty register, the TCMI can now also be simulated by a family of
such machines.

Paper~\cite{Schroep} introduced the concept of a so-called {\it more
  powerful one register machine\/} or MP1RM. This machine with a
somewhat tongue-in-cheek name has a single register  and allows the
following operations: , , 
{\bf if  then  else goto }, {\bf
  {\rm;} goto }, {\bf goto }, {\bf
  halt}. We can now extend the definition of MP1RM by adding `{\bf if
 then goto }' commands, analogous to the way 
a TCMI is derived from a TCM. Naturally there are only finitely
many constants  and  allowed.

Thus extended, an MP1RM becomes an
{\it MP1RM with input\/} or MP1RMI. Other definitions (such as counting
in some radix) can be naturally extended to MP1RMIs as
well. R.~Schroeppel shows in \cite{Schroep} that every TCM can be
emulated with an MP1RM.
\begin{theorem}\label{tcexact}
There is no MP1RMI (therefore no TCMI) that counts online in some
radix .
\end{theorem}
\begin{proof}
Suppose such a machine  exists. Let  be the product of all the
constants mentioned in the instruction set of 
(see the description of an MP1RM above) as well as the input radix, . 
First show that there exists a strictly
increasing finite sequence , and a waiting state  of
 such that  enters  after counting to 
(which can be picked arbitrarily large) as
well as after counting to  for arbitrarily
large  and some strictly increasing . If
there is no such , one can construct, by induction, a finite
increasing sequence  such that for any  and any
waiting state  of , the waiting state  enters after counting
to  is different from . A contradiction. 

Let  be the waiting state mentioned above, let  
be the appropriate sequence and let  be the number of steps
it takes  to process the next input digit, 1, after it has counted to
. Thus, after starting in  and
 in its only register, after inputting 1, 
will output (in the register)  where  is
the smallest power such that .

Pick , where , to
be specified later,
depends only on the computation  performs to input the last digit
of , such that 
enters  after counting to 
for some . Note that the only (meaningful) 
branching can be performed by the various  instructions. By
arranging  to be large enough we can assume that the
sole register of  is never equal 0 during the processing of the
last input digit of
. It is easy to see that after counting to
 and inputting 1,  must
stop after the same  steps as it did after counting to
 and inputting 1. Indeed,  is in the same
waiting state  before inputting 1 in both cases. Now, our choice of  and
 imply that the remainders of the 
instructions are unaffected by the addition of .

Therefore, after counting to 
and inputting 1,  will count to
 for some integer
 and  such that  divides . Note that
both  and  are determined by the computation  performs after
counting to  and inputting 1. Thus choosing
 large enough, it can be arranged that
, where  is the
smallest such that . One way to see this is by
noting that if  is large enough so that the representation of
 in radix  has more than  initial zeroes then the
required property holds. 
\end{proof}

The theorem above can be extended in a number of ways. With a slightly
more complicated technique one can show that if the intermediate
values differ from the online values by a bounded constant, the same
result holds, i.e.~such a machine cannot count in , or if the
TCM stage that processes  has a bounded number of {\it
  reversals\/} (or stages as they are called above), the result still
holds. If, on the other hand, there are no other restrictions on this
post-processing stage, new ideas are needed to establish the
nonexistence of such machines. Note that computations
with MP1RMs can be very (potentially infinitely) long. In fact, the history
of the famous {\it Collatz conjecture\/} or the  problem (see
\cite{Leht} for a discussion and a bibliography) shows that
even analyzing the length of the computation performed by the simplest
MP1RMs is very hard.

The last simple result shows that in order for TCMIs to be able to
perform computations of the same level of sophistication as TCMs
when the input is presented starting with the least significant digit,
they need to be able to count in the appropriate radix. This can be
viewed as a `factorization' theorem where a computation on the input
is split into a decoding stage followed by the actual computation.
\begin{theorem}\label{mmach}
Suppose, for a total function  with an unbounded range there exists a
TCM  that computes . If  is some radix and there is a TCMI  such that
 for
every string of -digits then there
exists a TCMI  that counts in . 
\end{theorem}
\begin{proof}
Using Theorem~3.4 of \cite{ibarra} find , , and  such that
 for all . Note that it follows from the proof of
\cite{ibarra}, Theorem~3.4 that . It is not very difficult to create a finite
control that for any input  holds  most significant digits of the expression
 for any initial substring  of  and
correctly updates them upon the input of 
the next digit  of . The constant  is chosen large enough so
that all the relevant constants (, , ,  and some of
their products and sums) can be represented in under 
-digits. Note that the  least significant digits held by the
finite control are the actual digits of the value of . Now the TCMI  will utilize the finite control just
built to feed the digits of  to the input of
 with some delay and wait for  to compute .  then subtracts 
and divides by  to compute .
\end{proof}

Using the  in the statement of the previous theorem as a
`back-end' to  to convert between  and  (and bypassing
 in the case of a leading  which can be flagged by 's
finite control) one can show that  cannot compute the value of
 online.

\begin{theorem}\label{tcmio}
Suppose, for a total function  with an unbounded range there exists a
TCM  that computes . Then for any radix  there is no TCMI  such that
 for every string of
-digits.
\end{theorem}
\begin{proof}
Otherwise using the proof of the previous theorem and the remark that
follows it one can construct a TCMI that counts online in 
contradicting Theorem~\ref{tcexact}.
\end{proof}

\section{Open Questions}

We conclude this paper with some questions we have been unable to
answer despite our best efforts.

It is easy to see that the languages  defined in
Section~\ref{autom} are context free if and only if they are
regular. It would be surprising if the answer to the question below is
affirmative, however, the authors do not know how to show that it is negative.

\begin{question}
Do there exist incommensurable radices , , a radix , and a precision  
such that all 's for  are regular assuming  if ?
\end{question}

The proof of Theorem~\ref{pdacs} establishes that neither  nor 
is context-free. It is not clear at the moment how to show that all
nontrivial 's and 's fail to be context-free.
\begin{question}
Given a radix  is it true that every  and ,
 is not a CFL?
\end{question}

It would also be interesting to know more about the computational
power of TCMI.

\begin{question}
Does there exist a TCMI that counts in some radix ?
\end{question}
\bibliography{pda2}{}
\bibliographystyle{plain}
\end{document}
