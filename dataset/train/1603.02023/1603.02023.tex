


Recall from Section III that, in the delay-free case, we had
plant  over ,
specification , prohibitible event set ,
and forcible event set . 

Now for  let  be partitioned as
, where

is the subset of communication events with bounded
delay and  the subset of those with unbounded delay.
First, the new plant  including both the plant components of  and the channels is

where  is the ATG displayed in Fig. \ref{fig:channel}.
The event set  of  is .
Since none of the added events  and  is
forcible, or prohibitible, the new subset of forcible events and prohibitible
events are unchanged, i.e.  and
. So  and 
(as defined in (\ref{eq:disforce})) are also unchanged. Following the allocation policy for building distributed
control architecture, we choose  (resp. )
to be the subset of forcible (resp. prohibitible) events for component  in
the new plant, i.e.,

Since  and , ()
are pairwise disjoint, so are   and .
Therefore, 
and .








The specification imposed on  is not changed, but should be extended
to the new event set , i.e. the specification
,
where  is the natural projection.


As we have mentioned, a consequence of
introducing the communication channels is that the agents  ()
have distinct observable event sets. Hence the local preemptors/controllers to be allocated to different
agents will be required to have different observable event sets. To address this, rather than synthesizing
a monolithic supervisor for a single observable event subset , we propose to synthesize  decentralized
supervisors one for each observable event set  () given by


 For the synthesis of decentralized supervisors,
it is proved in \cite{RudWon:1992,ParkChoi09} that a set of decentralized supervisors exists
which synthesizes a language  if and only if 
is coobservable, controllable and -closed. Like observability, coobservability is not closed under
set union; consequently when  is not coobservable, there generally does not exist the supremal coobservable
(and controllable, -closed) sublanguage of , and there is no
existing algorithm that computes a coobservable sublanguage of . In this paper, we employ the concept
of (timed) relative coobservability \cite{CaiZW16}, which is stronger
than coobservability (thus only a sufficient condition for existence of
decentralized supervisors), but the supremal (timed) relatively coobservable sublanguage always exists.
Let  and 
be an ambient language. A sublanguage  is {\it timed relatively coobservable} (with respect to , 
and , ), or simply timed -coobservable, if
for every  and
every pair of strings  with 
there holds

Namely, relative coobservability of  requires that  be relatively observable with
respect to each  and , .
It is proved in
\cite{CaiZW16} that there always exists a unique supremal
relatively coobservable sublanguage of a given language, which may be effectively computed  by an algorithm in \cite{CaiZW16}. Since relative coobservability is stronger
than coobservability, the supremal relatively coobservable (and controllable, -closed) sublanguage is guaranteed
to be coobservable (and controllable, -closed), and
thereby ensures the existence of decentralized supervisors \cite{RudWon:1992,ParkChoi09}. 

For the new plant  and specification language ,
write  for the
family of relatively coobservable (and controllable, -closed) sublanguages of .
Then  is nonempty
(the empty language  belongs) and has a unique
supremal element

Let the generator  be such that

We call  the {\it controllable and coobservable
behavior}, and assume that .\footnote{The introduced
bounded/unbounded communication delays may cause ,
which means that the delay requirements are too strong to be satisfied. In that case,
we shall weaken the delay requirements by either decreasing delay bounds of bounded-delay channels
(when the delay bound of an event  needs to be decreased to 0, we do not employ a channel model
for , and consequently events  and  defined in the channel model are also removed from the alphabet)
or reducing the number of unbounded-delay channels, until we
obtain a nonempty . }

Next, for each observable event set  (),
we construct as in (\ref{eq:posup}) a {\it partial-observation decentralized supervisor}
 defined over . It is well-known \cite{RudWon:1992,LinWon95}
that such constructed decentralized supervisors 
collectively achieve the same controlled behavior as 
does.
The control actions of the supervisor 
include (i) preempting event  via forcible events in  (as in (\ref{eq:new_forci_event_k}))
and (ii) disabling prohibitible events in  (as in (\ref{eq:new_prohib_event_k})).

Finally, we apply the localization procedure developed in Section IV to decompose,
one at a time, each decentralized supervisor , .
The result is a set of partial-observation local preemptors , one for each forcible
event , as well as a set of partial-observation local controllers , one for each .
Owing to 
(resp. ),
one local preemptor  (resp. one local controller )
will be owned by precisely one agent.

The following is the main result of this section, which asserts that the collective controlled
behavior of the resulting partial-observation local preemptors and local controllers, communicated
through the introduced channels with bounded/unbounded delays, is identical to that of {\bf NSUP}.

\begin{theorem} \label{thm:coobs_equ}
The set of partial-observation local preemptors  and the set of partial-observation local
controllers  derived above
are equivalent to the controllable and coobservable behavior  in (\ref{eq:new_monosup}) with respect to
the plant , i.e.

with

where 
and .
\end{theorem}

The proof of Theorem~\ref{thm:coobs_equ}, presented below, is similar to that of Theorem
\ref{thm:equ}, which relies on the facts that (i) for each forcible
event, there is a corresponding partial-observation local preemptor that
preempts event  consistently with {\bf NSUP}, and (ii)
for each prohibitible event, there is a corresponding partial-observation
local controller that disables/enables it consistently with
. 

By the above localization approach, each agent  () acquires
a set of partial-observation local preemptors 
and a set of partial-observation local controllers .
Thus we obtain a distributed control architecture for multi-component TDES under partial observation and communication delay.

\vspace{2em}
\noindent {\it Proof of Theorem~\ref{thm:coobs_equ}}: The equality of (\ref{eq:sub2:coobsequv}) and the ()
direction of (\ref{eq:sub1:coobsequv}) may be verified analogously
as in the proof of Theorem 1. Here we prove () of (\ref{eq:sub1:coobsequv})
by induction, i.e. .

For the {\bf base step}, note that none of ,  and
 is empty; and thus the empty string  belongs to all
of them. For the {\bf inductive step}, suppose that ,  and  for arbitrary event ; we must show that . Since , we consider the following three cases.

(i) . Since  is controllable, and
 (i.e. ), we have
. That is, .

(ii) . By the hypothesis that ,
for every forcible event , ,
, i.e. . Let ; then . The rest of the proof is similar to
case (ii) of proving Theorem~\ref{thm:equ}, with  and 
replaced by  and  respectively.


(iii) . There must exist a partial-observation local
controller  for . It follows from  that  and
. So  and ,
namely,  and . Let ; then
 (because ).
The rest of the proof is similar to that
in \cite{ZhangCW17} for untimed DES. \hfill 









