\documentclass[sigconf]{acmart}
\usepackage{booktabs} \usepackage{multirow}
\usepackage{color}
\usepackage{subfigure} \usepackage{array}
\usepackage{breqn}
\usepackage{{inputenc}}
\usepackage{balance}
\usepackage{multirow,tabularx}
\usepackage{longtable}
\usepackage{booktabs,longtable}
\usepackage{hhline}
\usepackage[flushleft]{threeparttable}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{thmtools}
\usepackage{enumitem}
\usepackage{verbatim}
\usepackage{amsfonts}
\usepackage{hyperref}
\hypersetup{colorlinks=false,linkcolor=blue,urlcolor=blue,citecolor=red}
\epstopdfsetup{update}

\newcommand\norm[1]{\left\lVert#1\right\rVert}
\newcommand{\Lapl}{\mathbf{\mathop{\mathcal{L}}}}
\newcommand{\Trans}[1]{{#1}^{\top}}
\newcommand{\Trace}[1]{tr\left({#1}\right)}
\newcommand{\Bracs}[1]{\left({#1}\right)}
\newcommand{\Mat}[1]{\mathbf{#1}}
\newcommand{\MatS}[3]{\mathbf{#1}^{#2}_{#3}}
\newcommand{\Space}[1]{\mathbb{#1}}
\newcommand{\Set}[1]{\mathcal{#1}}
\newcommand{\vectornorm}[1]{\left|\left|#1\right|\right|}
\newcommand{\bpi}{\boldsymbol{\pi}}
\newcommand{\BlockMat}[2]{\left[\begin{matrix}#1\\#2\end{matrix}\right]}
\newcommand{\BlockMatSquare}[4]{\left[\begin{matrix}#1 & #2\\#3 & #4\end{matrix}\right]}

\newcommand{\ie}{\emph{i.e., }}
\newcommand{\eg}{\emph{e.g., }}
\newcommand{\etal}{\emph{et al.}}
\newcommand{\st}{\emph{s.t. }}
\newcommand{\etc}{\emph{etc.}}
\newcommand{\wrt}{\emph{w.r.t. }}
\newcommand{\cf}{\emph{cf. }}
\newcommand{\aka}{\emph{aka. }}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]


\hyphenpenalty=10000
\tolerance=5000


\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08emT\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\copyrightyear{2020} \acmYear{2020} \setcopyright{acmlicensed}\acmConference[SIGIR '20]{Proceedings of the 43rd International ACM SIGIR Conference on Research and Development in Information Retrieval}{July 25--30, 2020}{Virtual Event, China} \acmBooktitle{Proceedings of the 43rd International ACM SIGIR Conference on Research and Development in Information Retrieval (SIGIR '20), July 25--30, 2020, Virtual Event, China} \acmPrice{15.00} \acmDOI{10.1145/3397271.3401063} \acmISBN{978-1-4503-8016-4/20/07}

\begin{document}
\fancyhead{}

\title{LightGCN: Simplifying and Powering Graph Convolution Network for Recommendation}


\author{Xiangnan He}
\affiliation{
\institution{University of Science and Technology of China}
}\email{xiangnanhe@gmail.com}

\author{Kuan Deng}
\affiliation{
\institution{University of Science and Technology of China}
}\email{dengkuan@mail.ustc.edu.cn}



\author{Xiang Wang}
\affiliation{
\institution{National University of Singapore}
}\email{xiangwang@u.nus.edu}


\author{Yan Li}
\affiliation{
\institution{Beijing Kuaishou Technology \\Co., Ltd.}
}\email{liyan@kuaishou.com}

\author{Yongdong Zhang}
\affiliation{
\institution{University of Science and Technology of China}
}\email{zhyd73@ustc.edu.cn}

\author{Meng Wang}
\authornote{Meng Wang is the corresponding author.}
\affiliation{
\institution{Hefei University of Technology}
}\email{eric.mengwang@gmail.com
}



\setcounter{page}{1}
\pagenumbering{Roman}

\begin{abstract}
Graph Convolution Network (GCN) has become new state-of-the-art for collaborative filtering. Nevertheless, the reasons of its effectiveness for recommendation are not well understood. 
Existing work that adapts GCN to recommendation lacks thorough ablation analyses on GCN, which is originally designed for graph classification tasks and equipped with many neural network operations. 
However, we empirically find that the two most common designs in GCNs --- feature transformation and nonlinear activation --- contribute little to the performance of collaborative filtering. Even worse, including them adds to the difficulty of training and degrades recommendation performance. 

In this work, we aim to simplify the design of GCN to make it more concise and appropriate for recommendation. We propose a new model named LightGCN, including only the most essential component in GCN --- neighborhood aggregation --- for collaborative filtering. Specifically, LightGCN learns user and item embeddings by linearly propagating them on the user-item interaction graph, and uses the weighted sum of the embeddings learned at all layers as the final embedding. 
Such simple, linear, and neat model is much easier to implement and train, exhibiting substantial improvements (about 16.0\% relative improvement on average) over Neural Graph Collaborative Filtering (NGCF) --- a state-of-the-art GCN-based recommender model --- under exactly the same experimental setting. Further analyses are provided towards the rationality of the simple LightGCN from both analytical and empirical perspectives. Our implementations are available in both TensorFlow\footnote{\url{https://github.com/kuandeng/LightGCN}} and PyTorch\footnote{\url{https://github.com/gusye1234/pytorch-light-gcn}}. 


\end{abstract}
\begin{CCSXML}
	<ccs2012>
	<concept>
	<concept_id>10002951.10003317.10003347.10003350</concept_id>
	<concept_desc>Information systems~Recommender systems</concept_desc> <concept_significance>500</concept_significance>
	</concept>
	</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Information systems~Recommender systems}
\vspace{-5pt}
\keywords{Collaborative Filtering, Recommendation, Embedding Propagation, Graph Neural Network}
\maketitle


\section{Introduction}
To alleviate information overload on the web, recommender system has been widely deployed to perform personalized information filtering~\cite{PinSage,YoutubeRS, PeterRec}.
The core of recommender system is to predict whether a user will interact with an item, e.g., click, rate, purchase, among other forms of interactions. As such, collaborative filtering (CF), which focuses on exploiting the past user-item interactions to achieve the prediction, remains to be a fundamental task towards effective personalized recommendation~\cite{NCF,VACF,NGCF,CMN}. 

The most common paradigm for CF is to learn latent features (a.k.a. embedding) to represent a user and an item, and perform prediction based on the embedding vectors~\cite{NCF,DBLP:conf/www/ChengDZK18}.
Matrix factorization is an early such model, which directly projects the single ID of a user to her embedding~\cite{MF}.  Later on, several research find that augmenting user ID with the her interaction history as the input can improve the quality of embedding. For example, SVD++~\cite{SVD++} demonstrates the benefits of user interaction history in predicting user numerical ratings, and Neural Attentive Item Similarity (NAIS)~\cite{NAIS} differentiates the importance of items in the interaction history and shows improvements in predicting item ranking. 
In view of user-item interaction graph, these improvements can be seen as coming from using the subgraph structure of a user --- more specifically, her one-hop neighbors --- to improve the embedding learning. 

To deepen the use of subgraph structure with high-hop neighbors, Wang et al.~\cite{NGCF} recently proposes NGCF and achieves state-of-the-art performance for CF. It takes inspiration from the Graph Convolution Network (GCN)~\cite{GCN,GraphSAGE}, following the same propagation rule to refine embeddings: feature transformation, neighborhood aggregation, and nonlinear activation. Although NGCF has shown promising results, we argue that its designs are rather heavy and burdensome --- many operations are directly inherited from GCN without justification. As a result, they are not necessarily useful for the CF task. To be specific, GCN is originally proposed for node classification on attributed graph, where each node has rich attributes as input features; whereas in user-item interaction graph for CF, each node (user or item) is only described by a one-hot ID, which has no concrete semantics besides being an identifier. In such a case, given the ID embedding as the input, performing multiple layers of nonlinear feature transformation --- which is the key to the success of modern neural networks~\cite{ResNet} --- will bring no benefits, but negatively increases the difficulty for model training. 

To validate our thoughts, we perform extensive ablation studies on NGCF. With rigorous controlled experiments (on the same data splits and evaluation protocol), we draw the conclusion that the two operations inherited from GCN --- feature transformation and nonlinear activation --- has no contribution on NGCF's effectiveness. Even more surprising, removing them leads to significant accuracy improvements. This reflects the issues of adding operations that are useless for the target task in graph neural network, which not only brings no benefits, but rather degrades model effectiveness. Motivated by these empirical findings, we present a new model named LightGCN, including the most essential component of GCN --- neighborhood aggregation --- for collaborative filtering. Specifically, after associating each user (item) with an ID embedding, we propagate the embeddings on the user-item interaction graph to refine them. We then combine the embeddings learned at different propagation layers with a weighted sum to obtain the final embedding for prediction. The whole model is simple and elegant, which not only is easier to train, but also achieves better empirical performance than NGCF and other state-of-the-art methods like Mult-VAE~\cite{VACF}. 

To summarize, this work makes the following main contributions:
\begin{itemize}\item We empirically show that two common designs in GCN, feature transformation and nonlinear activation, have no positive effect on the effectiveness of collaborative filtering. 
    \item We propose LightGCN, which largely simplifies the model design by including only the most essential components in GCN for recommendation.
    \item We empirically compare LightGCN with NGCF by following the same setting and demonstrate substantial improvements. In-depth analyses are provided towards the rationality of LightGCN from both technical and empirical perspectives. 
\end{itemize}

%
 \section{Preliminaries}\label{sec:preliminaries}

We first introduce NGCF~\cite{NGCF}, a representative and state-of-the-art GCN model for recommendation. We then perform ablation studies on NGCF to judge the usefulness of each operation in NGCF. The novel contribution of this section is to show that the two common designs in GCNs, feature transformation and nonlinear activation, have no positive effect on collaborative filtering. 

\subsection{NGCF Brief}\label{ss:ngcf}
In the initial step, each user and item is associated with an ID embedding. Let  denote the ID embedding of user  and  denote the ID embedding of item . Then NGCF leverages the user-item interaction graph to propagate embeddings as:

where  and  respectively denote the refined embedding of user  and item  after  layers propagation,  is the nonlinear activation function,
 denotes the set of items that are interacted by user ,  denotes the set of users that interact with item , and  and  are trainable weight matrix to perform feature transformation in each layer. 
By propagating  layers, NGCF obtains
 embeddings to describe a user () and an item (). It then concatenates these  embeddings to obtain the final user embedding and item embedding, using inner product to generate the prediction score. 


NGCF largely follows the standard GCN~\cite{GCN}, including the use of nonlinear activation function  and feature transformation matrices  and . However, we argue that the two operations are not as useful for collaborative filtering. In  semi-supervised node classification, each node has rich semantic features as input, such as the title and abstract words of a paper. Thus performing multiple layers of nonlinear transformation is beneficial to feature learning. Nevertheless, in collaborative filtering, each node of user-item interaction graph only has an ID as input which has no concrete semantics. In this case, performing multiple nonlinear transformations will not contribute to learn better features; even worse, it may add the difficulties to train well. In the next subsection, we provide empirical evidence on this argument. 

\begin{table}[t]
\caption{Performance of NGCF and its three variants.}
\vspace{-10px}
\label{tab:pre}
\begin{tabular}{l|c c|c c}
\hline
 & \multicolumn{2}{c|}{\textbf{Gowalla}} & \multicolumn{2}{c}{\textbf{Amazon-Book}} \\ \hline
 & \textbf{recall} & \textbf{ndcg} &  \textbf{recall} & \textbf{ndcg} \\ \hline\hline
NGCF &  0.1547 & 0.1307 & 0.0330 & 0.0254 \\ \hline 
NGCF-f    & 0.1686 & 0.1439 & 0.0368 & 0.0283 \\ 
NGCF-n & 0.1536 & 0.1295 & 0.0336 & 0.0258 \\  
NGCF-fn   & 0.1742 & 0.1476 & 0.0399 & 0.0303 \\ \hline
\end{tabular}\end{table}


\begin{figure*}[t]
	\centering
	\subfigure[Training loss on Gowalla]{\includegraphics[width=0.235\textwidth]{gowalla_tr_loss.pdf}}
	\subfigure[Testing recall on Gowalla]{\includegraphics[width=0.235\textwidth]{gowalla_recall.pdf}}
	\subfigure[Training loss on Amazon-Book]{\includegraphics[width=0.235\textwidth]{amazon-book_tr_loss.pdf}}
	\subfigure[Testing recall on Amazon-Book]{\includegraphics[width=0.235\textwidth]{amazon-book_recall.pdf}}
	\vspace{-15pt}
	\caption{Training curves (training loss and testing recall) of NGCF and its three simplified variants.} \vspace{-10pt}
	\label{fig:train-epochs}
\end{figure*}

\subsection{Empirical Explorations on NGCF} \label{ss:ngcf_study}
We conduct ablation studies on NGCF to explore the effect of nonlinear activation and feature transformation. We use the codes released by the authors of NGCF\footnote{\url{https://github.com/xiangwang1223/neural_graph_collaborative_filtering}}, running experiments on the same data splits and evaluation protocol to keep the comparison as fair as possible. 
Since the core of GCN is to refine embeddings by propagation, we are more interested in the embedding quality under the same embedding size. Thus, we change the way of obtaining final embedding from concatenation (i.e., ) to sum (i.e., ).
Note that this change has little effect on NGCF's performance, but makes the following ablation studies more indicative of the embedding quality refined by GCN. 

We implement three simplified variants of NGCF:
\begin{itemize}[leftmargin=*]
\item NGCF-f, which removes the feature transformation matrices  and .
\item NGCF-n, which removes the non-linear activation function .
\item NGCF-fn, which removes both the feature transformation matrices and non-linear activation function. 
\end{itemize}

For the three variants, we keep all hyper-parameters (e.g., learning rate, regularization coefficient, dropout ratio, etc.)  same as the optimal settings of NGCF. 
We report the results of the 2-layer setting on the Gowalla and Amazon-Book datasets in Table \ref{tab:pre}. 
As can be seen, removing feature transformation (i.e., NGCF-f) leads to consistent improvements over NGCF on all three datasets. In contrast, removing nonlinear activation does not affect the accuracy that much. However, if we remove nonlinear activation on the basis of removing feature transformation (i.e., NGCF-fn), the performance is improved significantly. From these observations, we conclude the findings that: 

(1) Adding feature transformation imposes negative effect on NGCF, since removing it in both models of NGCF and NGCF-n improves the performance significantly; 

(2) Adding nonlinear activation affects slightly when feature transformation is included, but it imposes negative effect when feature transformation is disabled. 

(3) As a whole, feature transformation and nonlinear activation impose rather negative effect on NGCF, since by removing them simultaneously, NGCF-fn demonstrates large improvements over NGCF (9.57\% relative improvement on recall). 

To gain more insights into the scores obtained in Table \ref{tab:pre} and understand why NGCF deteriorates with the two operations, we plot the curves of model status recorded by training loss and testing recall in Figure \ref{fig:train-epochs}. 
As can be seen, NGCF-fn achieves a much lower training loss than NGCF, NGCF-f, and NGCF-n along the whole training process. Aligning with the curves of testing recall, we find that such lower training loss successfully transfers to better recommendation accuracy.
The comparison between NGCF and NGCF-f shows the similar trend, except that the improvement margin is smaller. 

From these evidences, we can draw the conclusion that the deterioration of NGCF stems from the training difficulty, rather than overfitting. 
Theoretically speaking, NGCF has higher representation power than NGCF-f, since setting the weight matrix  and  to identity matrix  can fully recover the NGCF-f model. However, in practice, NGCF demonstrates higher training loss and worse generalization performance than NGCF-f. 
And the incorporation of nonlinear activation further aggravates the discrepancy between representation power and generalization performance. To round out this section, we claim that when designing model for recommendation, it is important to perform rigorous ablation studies to be clear about the impact of each operation. Otherwise, including less useful operations will complicate the model unnecessarily, increase the training difficulty, and even degrade model effectiveness.  \section{Method}\label{sec:method}
The former section demonstrates that NGCF is a heavy and burdensome GCN model for  collaborative filtering.
Driven by these findings, we set the goal of developing a light yet effective model by including the most essential ingredients of GCN for recommendation. 
The advantages of being simple are several-fold --- more interpretable, practically easy to train and maintain, technically easy to analyze the model behavior and revise it towards more effective directions, and so on. 

In this section, we first present our designed \textit{Light Graph Convolution Network} (LightGCN) model, as illustrated in Figure~\ref{fig:LightGCN}.
We then provide an in-depth analysis of LightGCN to show the rationality behind its simple design. 
Lastly, we describe how to do model training for recommendation. 

\subsection{LightGCN}
The basic idea of GCN is to learning representation for nodes by smoothing features over the graph~\cite{GCN,SGCN}. 
To achieve this, it performs graph convolution iteratively, i.e., aggregating the features of neighbors as the new representation of a target node. 
Such neighborhood aggregation can be abstracted as:

The AGG is an aggregation function --- the core of graph convolution --- that considers the -th layer's representation of the target node and its neighbor nodes. Many work have specified the AGG, such as the weighted sum aggregator in GIN~\cite{GIN}, LSTM aggregator in GraphSAGE~\cite{GraphSAGE}, and bilinear interaction aggregator in BGNN~\cite{BGNN} etc. However, most of the work ties feature transformation or nonlinear activation with the AGG function. Although they perform well on node or graph classification tasks that have semantic input features, they could be burdensome for collaborative filtering (see preliminary results in Section~\ref{ss:ngcf_study}).

\begin{figure}[t]
\centering
	\small	
	\includegraphics[width=0.48\textwidth]{LightGCN.pdf}\vspace{-5pt}
	\caption{An illustration of LightGCN model architecture. 
In LGC, only the normalized sum of neighbor embeddings is performed towards next layer; other operations like self-connection, feature transformation, and nonlinear activation are all removed, which largely simplifies GCNs. In Layer Combination, we sum over the embeddings at each layer to obtain the final representations.}\vspace{-10pt}
	\label{fig:LightGCN}
\end{figure}

\subsubsection{Light Graph Convolution (LGC)}
In LightGCN, we adopt the simple weighted sum aggregator and abandon the use of feature transformation and nonlinear activation. The graph convolution operation (a.k.a., propagation rule~\cite{NGCF}) in LightGCN is defined as:

The symmetric normalization term  follows the design of standard GCN~\cite{GCN}, which can avoid the scale of embeddings increasing with graph convolution operations; other choices can also be applied here, such as the  norm, while empirically we find this symmetric normalization has good performance (see experiment results in Section~\ref{ss:ablation-symmetric}). 

It is worth noting that in LGC, we aggregate only the connected neighbors and do not integrate the target node itself (i.e., self-connection). This is different from most existing graph convolution operations~\cite{NGCF,GCN,GAT,GraphSAGE, BGNN} that typically aggregate extended neighbors and need to handle the self-connection specially. 
The layer combination operation, to be introduced in the next subsection, essentially captures the same effect as self-connections. Thus, there is no need in LGC to include self-connections. 

\subsubsection{Layer Combination and Model Prediction} In LightGCN, the only trainable model parameters are the embeddings at the 0-th layer, i.e.,  for all users and   for all items. When they are given, the embeddings at higher layers can be computed via LGC defined in Equation~(\ref{eq:LGC}). 
After  layers LGC, we further combine the embeddings obtained at each layer to form the final representation of a user (an item):

where  denotes the importance of the -th layer embedding in constituting the final embedding. 
It can be treated as a hyper-parameter to be tuned manually, or as a model parameter (e.g., output of an attention network~\cite{ACF}) to be optimized automatically. In our experiments, we find that setting  uniformly as  leads to good performance in general. Thus we do not design special component to optimize , to avoid complicating LightGCN unnecessarily and to keep its simplicity.  
The reasons that we perform layer combination to get final representations are three-fold. (1) With the increasing of the number of layers, the embeddings will be over-smoothed~\cite{DeepInsights}. Thus simply using the last layer is problematic. (2) The embeddings at different layers capture different semantics. E.g., the first layer enforces smoothness on users and items that have interactions, the second layer smooths users (items) that have overlap on interacted items (users), and higher-layers capture higher-order proximity~\cite{NGCF}. Thus combining them will make the representation more comprehensive. (3) Combining embeddings at different layers with weighted sum captures the effect of graph convolution with self-connections, an important trick in GCNs (proof sees Section~\ref{ss:relation-sgcn}).

The model prediction is defined as the inner product of user and item final representations: 

which is used as the ranking score for recommendation generation. 

\subsubsection{Matrix Form} We provide the matrix form of LightGCN to facilitate implementation and discussion with existing models. Let the user-item interaction matrix be  where  and  denote the number of users and items, respectively, and each entry  is 1 if  has interacted with item  otherwise 0. We then obtain the adjacency matrix of the user-item graph as 

Let the -th layer embedding matrix be , where  is the embedding size.  
Then we can obtain the matrix equivalent form of LGC as:

where  is a  diagonal matrix, in which each entry  denotes the number of nonzero entries in the -th row vector of the  adjacency matrix  (also named as degree matrix). Lastly, we get the final embedding matrix used for model prediction as:

where  is the symmetrically normalized matrix.

\subsection{Model Analysis}
We conduct model analysis to demonstrate the rationality behind the simple design of LightGCN. 
First we discuss the connection with the Simplified GCN (SGCN)~\cite{SGCN}, which is a recent linear GCN model that integrates self-connection into graph convolution; this analysis shows that by doing layer combination, LightGCN subsumes the effect of self-connection thus there is no need for LightGCN to add self-connection in adjacency matrix. 
Then we discuss the relation with the Approximate Personalized Propagation of Neural Predictions (APPNP)~\cite{ICLR19-APPNP}, which is recent GCN variant that addresses oversmoothing by inspiring from Personalized PageRank~\cite{haveliwala2002topic}; this analysis shows the underlying equivalence between LightGCN and APPNP, thus our LightGCN enjoys the sames benefits in propagating long-range with controllable oversmoothing. 
Lastly we analyze the second-layer LGC to show how it smooths a user with her second-order neighbors, providing more insights into the working mechanism of LightGCN.  

\subsubsection{Relation with SGCN}\label{ss:relation-sgcn} In \cite{SGCN}, the authors argue the unnecessary complexity of GCN for node classfication and propose SGCN, which simplifies GCN by removing nonlinearities and collapsing the weight matrices to one weight matrix. The graph convolution in SGCN is defined as\footnote{The weight matrix in SGCN can be absorbed into the 0-th layer embedding parameters, thus it is omitted in the analysis.}:

where  is an identity matrix, which is added on  to include self-connections. 
In the following analysis, we omit the  terms for simplicity, since they only re-scale embeddings. In SGCN, the embeddings obtained at the last layer are used for downstream prediction task, which can be expressed as:

The above derivation shows that, inserting self-connection into  and propagating embeddings on it, is essentially equivalent to a weighted sum of the embeddings propagated at each LGC layer. 

\subsubsection{Relation with APPNP}\label{ss:APPNP} In a recent work \cite{ICLR19-APPNP}, the authors
connect GCN with Personalized PageRank~\cite{haveliwala2002topic}, inspiring from which they propose a GCN variant named APPNP that can propagate long range without the risk of oversmoothing. 
Inspired by the teleport design in Personalized PageRank, APPNP complements each propagation layer with the starting features (i.e., the 0-th layer embeddings), which can balance the need of preserving locality (i.e., staying close to the root node to alleviate oversmoothing) and leveraging the information from a large neighborhood. The propagation layer in APPNP is defined as:

where  is the teleport probability to control the retaining of starting features in the propagation, and  denotes the normalized adjacency matrix. In APPNP, the last layer is used for final prediction, i.e., 

Aligning with Equation~(\ref{eq:E_LGCN}), we can see that by setting  accordingly, LightGCN can fully recover the prediction embedding used by APPNP. 
As such, LightGCN shares the strength of APPNP in combating oversmoothing --- by setting the  properly, we allow using a large  for long-range modeling with controllable oversmoothing. 

Another minor difference is that APPNP adds self-connection into the adjacency matrix. However, as we have shown before, this is redundant due to the weighted sum of different layers. 

\subsubsection{Second-Order Embedding Smoothness} \label{ss:second-order}
Owing to the linearity and simplicity of LightGCN, we can draw more insights into how does it smooth embeddings. Here we analyze a 2-layer LightGCN to demonstrate its rationality. Taking the user side as an example, intuitively, the second layer smooths users that have overlap on the interacted items. More concretely, we have:

We can see that, if another user  has co-interacted with the target user , the smoothness strength of  on  is measured by the coefficient (otherwise 0):

This coefficient is rather interpretable: the influence of a second-order neighbor  on  is determined by 1) the number of co-interacted items, the more the larger; 2) the popularity of the co-interacted items, the less popularity (i.e., more indicative of user personalized preference) the larger; and 3) the activity of , the less active the larger. 
Such interpretability well caters for the assumption of CF in measuring user similarity~\cite{CSE,Wang:2006} and evidences the reasonability of LightGCN. 
Due to the symmetric formulation of LightGCN, we can get similar analysis on the item side. 

\subsection{Model Training}
The trainable parameters of LightGCN are only the embeddings of the 0-th layer, i.e.,  ; in other words, the model complexity is same as the standard matrix factorization (MF).
We employ the \textit{Bayesian Personalized Ranking} (BPR) loss~\cite{BPRMF}, which is a pairwise loss that encourages the prediction of an observed entry to be higher than its unobserved counterparts:

where  controls the  regularization strength. We employ the Adam~\cite{Adam} optimizer and use it in a mini-batch manner.
We are aware of other advanced negative sampling strategies which might improve the LightGCN training, such as the hard negative sampling~\cite{rendle2014improving} and adversarial sampling~\cite{Ding2019IJCAI}. We leave this extension in the future since it is not the focus of this work. 

Note that we do not introduce dropout mechanisms, which are commonly used in GCNs and NGCF. The reason is that we do not have feature transformation weight matrices in LightGCN, thus enforcing  regularization on the embedding layer is sufficient to prevent overfitting. 
This showcases LightGCN's advantages of being simple --- it is easier to train and tune than NGCF which additionally requires to tune two dropout ratios (node dropout and message dropout) and normalize the embedding of each layer to unit length. 

Moreover, it is technically viable to also learn the layer combination coefficients , or parameterize them with an attention network. However, we find that learning  on training data does not lead improvement. This is probably because the training data does not contain sufficient signal to learn good  that can generalize to unknown data. We have also tried to learn  from validation data, as inspired by \cite{lambdaOpt} that learns hyper-parameters on validation data. The performance is slightly improved (less than ). We leave the exploration of optimal settings of  (e.g., personalizing it for different users and items) as future work.  \section{Experiments}\label{sec:experiments}
We first describe experimental settings, and then conduct detailed comparison with NGCF~\cite{NGCF}, the method that is most relevant with LightGCN but more complicated (Section~\ref{ss:exp-ngcf}). We next compare with other state-of-the-art methods in Section \ref{ss:exp-SOTA}. To justify the designs in LightGCN and reveal the reasons of its effectiveness, we perform ablation studies and embedding analyses in Section \ref{ss:exp-ablation}. The hyper-parameter study is finally presented in Section \ref{ss:exp-hyper}. 

\begin{table}[t]
\caption{Statistics of the experimented data.}
\vspace{-10px}
\label{tab:dataset}
\begin{tabular}{l|r|r|r|r}
\hline
\multicolumn{1}{c|}{\textbf{Dataset}} & \multicolumn{1}{c|}{\textbf{User \#}} & \multicolumn{1}{c|}{\textbf{Item \#}} & \multicolumn{1}{c|}{\textbf{Interaction \#}} & \multicolumn{1}{c}{\textbf{Density}} \\ \hline\hline
Gowalla &  &  &  &  \\ \hline
Yelp2018 &  &  &  &  \\ \hline
Amazon-Book &  &  &  &  \\ \hline
\end{tabular}
\vspace{-15px}
\end{table}

\subsection{Experimental Settings}\label{ss:setting}
To reduce the experiment workload and keep the comparison fair, we closely follow the settings of the NGCF work~\cite{NGCF}. We request the experimented datasets (including train/test splits) from the authors, for which the statistics are shown in Table~\ref{tab:dataset}. 
The Gowalla and Amazon-Book are exactly the same as the NGCF paper used, so we directly use the results in the NGCF paper. The only exception is the Yelp2018 data, which is a revised version. According to the authors, the previous version did not filter out cold-start items in the testing set, and they shared us the revised version only. Thus we re-run NGCF on the Yelp2018 data.
The evaluation metrics are recall@20 and ndcg@20 computed by the all-ranking protocol --- all items that are not interacted by a user are the candidates. 


\begin{table*}[t]
\caption{Performance comparison between NGCF and LightGCN at different layers.}
\vspace{-10px}
\label{tab:overall}
\resizebox{0.9\textwidth}{!}{
\begin{tabular}{c|c|l | l|l | l| l | l}
\hline
 \multicolumn{2}{c|}{\textbf{Dataset}}
 & \multicolumn{2}{c|}{\textbf{Gowalla}} & \multicolumn{2}{c|}{\textbf{Yelp2018}} & \multicolumn{2}{c}{\textbf{Amazon-Book}} \\ \hline
 \textbf{Layer \#} & \textbf{Method} 
 & \textbf{recall} & \textbf{ndcg} & \textbf{recall} & \textbf{ndcg} & \textbf{recall} & \textbf{ndcg} \\ \hline\hline
\multirow{2}{*}{\textbf{1 Layer}} & NGCF &  
0.1556 & 0.1315 & 0.0543 & 0.0442 & 0.0313 & 0.0241
 \\ 
&LightGCN & 0.1755(+12.79\%) & 0.1492(+13.46\%) & 0.0631(+16.20\%) & 0.0515(+16.51\%) & 0.0384(+22.68\%) & 0.0298(+23.65\%) \\ \hline
\multirow{2}{*}{\textbf{2 Layers}} & NGCF &  
0.1547 & 0.1307 & 0.0566 & 0.0465 & 0.0330 &	0.0254 \\
&LightGCN & 0.1777(+14.84\%) & 0.1524(+16.60\%) & 0.0622(+9.89\%) & 0.0504(+8.38\%) & 0.0411(+24.54\%) & 0.0315(+24.02\%) \\  \hline
\multirow{2}{*}{\textbf{3 Layers}} & NGCF &  
0.1569 & 0.1327 & 0.0579 & 0.0477 & 0.0337 & 0.0261 \\ 
&LightGCN & 0.1823(+16.19\%) & 0.1555(+17.18\%) & 0.0639(+10.38\%) & 0.0525(+10.06\%) & 0.0410(+21.66\%) & 0.0318(+21.84\%) \\ \hline
\multirow{2}{*}{\textbf{4 Layers}} & NGCF &  
0.1570 & 0.1327 & 0.0566 & 0.0461 & 0.0344 & 0.0263\\
&LightGCN & 0.1830(+16.56\%) & 0.1550(+16.80\%) & 0.0649(+14.58\%) & 0.0530(+15.02\%) & 0.0406(+17.92\%) & 0.0313(+18.92\%) \\ \hline
\end{tabular}}\vspace{+2pt}
\\\small{*The scores of NGCF on Gowalla and Amazon-Book are directly copied from Table 3 of the NGCF paper (\url{https://arxiv.org/abs/1905.08108})} \vspace{-5pt}
\end{table*}

  
\subsubsection{Compared Methods} The main competing method is NGCF, which has shown to outperform several methods including GCN-based models GC-MC~\cite{GC-MC} and PinSage~\cite{PinSage}, neural network-based models NeuMF~\cite{NCF} and CMN~\cite{CMN}, and factorization-based models MF~\cite{BPRMF} and HOP-Rec~\cite{HOP-rec}.
As the comparison is done on the same datasets under the same evaluation protocol, we do not further compare with these methods. In addition to NGCF, we further compare with two relevant and competitive CF methods:
\begin{itemize}[leftmargin=*]
\item Mult-VAE~\cite{VACF}. This is an item-based CF method based on the variational autoencoder (VAE). 
It assumes the data is generated from a multinomial distribution and using variational inference for parameter estimation. 
We run the codes released by the authors\footnote{\url{https://github.com/dawenl/vae_cf}}, tuning the dropout ratio in , and the  in . The model architecture is the suggested one in the paper: . 
\item GRMF~\cite{rao2015collaborative}. This method smooths matrix factorization by adding the graph Laplacian regularizer.
For fair comparison on item recommendation, we change the rating prediction loss to BPR loss. The objective function of GRMF is:

where  is searched in the range of . 
Moreover, we compare with a variant that adds normalization to graph Laplacian: , which is termed as GRMF-norm. 
Other hyper-parameter settings are same as LightGCN. 
The two GRMF methods benchmark the performance of smoothing embeddings via Laplacian regularizer, while our LightGCN achieves embedding smoothing in the predictive model. 
\end{itemize}

\subsubsection{Hyper-parameter Settings} 
Same as NGCF, the embedding size is fixed to 64 for all models and the embedding parameters are initialized with the Xavier method~\cite{Xarvier}. We optimize LightGCN with Adam~\cite{Adam} and use the default learning rate of 0.001 and default mini-batch size of 1024 (on Amazon-Book, we increase the mini-batch size to 2048 for speed). The  regularization coefficient  is searched in the range of , and in most cases the optimal value is . 
The layer combination coefficient  is uniformly set to  where  is the number of layers. We test  in the range of 1 to 4, and satisfactory performance can be achieved when  equals to 3. 
The early stopping and validation strategies are the same as NGCF. Typically, 1000 epochs are sufficient for LightGCN to converge. Our implementations are available in both TensorFlow\footnote{\url{https://github.com/kuandeng/LightGCN}} and PyTorch\footnote{\url{https://github.com/gusye1234/pytorch-light-gcn}}. 


\begin{figure*}[t]
	\centering
	\subfigure{\includegraphics[width=0.24\textwidth]{Gowalla_training_loss.pdf}} 
	\subfigure{\includegraphics[width=0.24\textwidth]{Gowalla_recall_20.pdf}} 
	\subfigure{\includegraphics[width=0.24\textwidth]{Amazon-Book_training_loss.pdf}}
	\subfigure{\includegraphics[width=0.24\textwidth]{Amazon-Book_recall_20.pdf}}
	\vspace{-15pt}
	\caption{Training curves of LightGCN and NGCF, which are evaluated by training loss and testing recall per 20 epochs on Gowalla and Amazon-Book (results on Yelp2018 show exactly the same trend which are omitted for space).} \vspace{-10pt}
	\label{fig:curve}
\end{figure*}

\subsection{Performance Comparison with NGCF}\label{ss:exp-ngcf}
We perform detailed comparison with NGCF, recording the performance at different layers (1 to 4) in Table \ref{tab:overall}, which also shows the percentage of relative improvement on each metric. 
We further plot the training curves of training loss and testing recall in Figure~\ref{fig:curve} to reveal the advantages of LightGCN and to be clear of the training process. 
The main observations are as follows:
\begin{itemize}[leftmargin=*]
    \item In all cases, LightGCN outperforms NGCF by a large margin. For example, on Gowalla the highest recall reported in the NGCF paper is 0.1570, while our LightGCN can reach 0.1830 under the 4-layer setting, which is  higher. On average, the recall improvement on the three datasets is  and the ndcg improvement is , which are rather significant.
    \item Aligning Table \ref{tab:overall} with Table \ref{tab:pre} in Section~\ref{sec:preliminaries}, we can see that LightGCN performs better than NGCF-fn, the variant of NGCF that removes feature transformation and nonlinear activation. As NGCF-fn still contains more operations than LightGCN (e.g., self-connection, the interaction between user embedding and item embedding in graph convolution, and dropout), this suggests that these operations might also be useless for NGCF-fn. 
    \item Increasing the number of layers can improve the performance, but the benefits diminish. The general observation is that increasing the layer number from 0 (i.e., the matrix factorization model, results see \cite{NGCF}) to 1 leads to the largest performance gain, and using a layer number of 3 leads to satisfactory performance in most cases. This observation is consistent with NGCF's finding.
\item Along the training process, LightGCN consistently obtains lower training loss, which indicates that LightGCN fits the training data better than NGCF. Moreover, the lower training loss successfully transfers to better testing accuracy, indicating the strong generalization power of LightGCN. In contrast, the higher training loss and lower testing accuracy of NGCF reflect the practical difficulty to train such a heavy model it well. Note that in the figures we show the training process under the optimal hyper-parameter setting for both methods. Although increasing the learning rate of NGCF can decrease its training loss (even lower than that of LightGCN), the testing recall could not be improved, as lowering training loss in this way only finds trivial solution for NGCF. 
\end{itemize}



\subsection{Performance Comparison with State-of-the-Arts}\label{ss:exp-SOTA}
Table \ref{tab:overall} shows the performance comparison with competing methods. We show the best score we can obtain for each method. We can see that LightGCN consistently outperforms other methods on all three datasets, demonstrating its high effectiveness with simple yet reasonable designs. Note that LightGCN can be further improved by tuning the  (see Figure \ref{fig:layer-combination} for an evidence), while here we only use a uniform setting of  to avoid over-tuning it. Among the baselines, Mult-VAE exhibits the strongest performance, which is better than GRMF and NGCF. 
The performance of GRMF is on a par with NGCF, being better than MF, which admits the utility of enforcing embedding smoothness with Laplacian regularizer. 
By adding normalization into the Laplacian regularizer, GRMF-norm betters than GRMF on Gowalla, while brings no benefits on Yelp2018 and Amazon-Book. 



\begin{table}[h]
\caption{The comparison of overall performance among LightGCN and competing methods.}\vspace{-8pt}
\label{tab:overall}
\resizebox{0.48\textwidth}{!}{
\begin{tabular}{l|c c|c c|c c}
\hline
\textbf{Dataset} & \multicolumn{2}{c|}{\textbf{Gowalla}} & \multicolumn{2}{c|}{\textbf{Yelp2018}} & \multicolumn{2}{c}{\textbf{Amazon-Book}} \\ \hline
\textbf{Method} & \textbf{recall} & \textbf{ndcg} & \textbf{recall} & \textbf{ndcg} & \textbf{recall} & \textbf{ndcg} \\ \hline\hline
NGCF & 0.1570 & 0.1327 & 0.0579 & 0.0477 & 0.0344 & 0.0263 \\ \hline
Mult-VAE   & 0.1641	& 0.1335 & 0.0584 & 0.0450 &  0.0407 & 0.0315\\ \hline
GRMF & 0.1477 & 0.1205 & 0.0571 & 0.0462 & 0.0354 &
0.0270\\ 
GRMF-norm & 0.1557 & 0.1261 & 0.0561 & 0.0454
 & 0.0352 & 0.0269\\\hline
LightGCN & \textbf{0.1830} & \textbf{0.1554} & \textbf{0.0649} & \textbf{0.0530} & \textbf{0.0411} & \textbf{0.0315} \\\hline
\end{tabular}
}
\end{table}

\subsection{Ablation and Effectiveness Analyses}\label{ss:exp-ablation}
We perform ablation studies on LightGCN by showing how layer combination and symmetric sqrt normalization affect its performance. To justify the rationality of LightGCN as analyzed in Section \ref{ss:second-order}, we further investigate the effect of embedding smoothness --- the key reason of LightGCN's effectiveness. 




\begin{figure*}[t]
	\centering
	\subfigure{\includegraphics[width=0.24\textwidth]{recall_Gowalla_single.pdf}} 
	\subfigure{\includegraphics[width=0.24\textwidth]{ndcg_Gowalla_single.pdf}} 
	\subfigure{\includegraphics[width=0.24\textwidth]{recall_Amazon-book_single.pdf}}
	\subfigure{\includegraphics[width=0.24\textwidth]{ndcg_Amazon-book_single.pdf}}
	\vspace{-15pt}
	\caption{Results of LightGCN and the variant that does not use layer combination (i.e., LightGCN-single) at different layers on Gowalla and Amazon-Book (results on Yelp2018 shows the same trend with Amazon-Book which are omitted for space).} \vspace{-5pt}
	\label{fig:layer-combination}
\end{figure*}

\subsubsection{Impact of Layer Combination} Figure \ref{fig:layer-combination} shows the results of LightGCN and its variant LightGCN-single that does not use layer combination (i.e.,  is used for final prediction for a -layer LightGCN). We omit the results on Yelp2018 due to space limitation, which show similar trend with Amazon-Book. We have three main observations:
\begin{itemize}[leftmargin=*]
\item Focusing on LightGCN-single, we find that its performance first improves and then drops when the layer number increases from 1 to 4. The peak point is on layer 2 in most cases, while after that it drops quickly to the worst point of layer 4. This indicates that smoothing a node's embedding with its first-order and second-order neighbors is very useful for CF, but will suffer from over-smoothing issues when higher-order neighbors are used. 
\item Focusing on LightGCN, we find that its performance gradually improves with the increasing of layers. Even using 4 layers, LightGCN's performance is not degraded. This justifies the effectiveness of layer combination for addressing over-smoothing, as we have technically analyzed in Section~\ref{ss:APPNP} (relation with APPNP). 
\item Comparing the two methods, we find that LightGCN consistently outperforms LightGCN-single on Gowalla, but not on Amazon-Book and Yelp2018 (where the 2-layer LightGCN-single performs the best). Regarding this phenomenon, two points need to be noted before we draw conclusion: 1) LightGCN-single is special case of LightGCN that sets  to 1 and other  to 0; 2) we do not tune the  and simply set it as  uniformly for LightGCN. As such, we can see the potential of further enhancing the performance of LightGCN by tuning . 
\end{itemize}


\begin{table}
\caption{Performance of the 3-layer LightGCN with different choices of normalization schemes in graph convolution.}\vspace{-8pt}
\label{tab:norm-3}
\resizebox{0.48\textwidth}{!}{
\begin{tabular}{l|c c|c c|c c}
\hline
\textbf{Dataset} & \multicolumn{2}{c|}{\textbf{Gowalla}} & \multicolumn{2}{c|}{\textbf{Yelp2018}} & \multicolumn{2}{c}{\textbf{Amazon-Book}} \\ \hline
\textbf{Method} & \textbf{recall} & \textbf{ndcg} & \textbf{recall} & \textbf{ndcg} & \textbf{recall} & \textbf{ndcg} \\ \hline\hline
LightGCN--L &  0.1724 & 0.1414
 & 0.0630 & 0.0511 & \textbf{0.0419} & \textbf{0.0320}\\ 
LightGCN--R & 0.1578 & 0.1348
 & 0.0587 & 0.0477 & 0.0334 & 0.0259\\ 
LightGCN- &0.159 & 0.1319
   &0.0573 & 0.0465 & 0.0361 & 0.0275\\ \hline
LightGCN-L    & 0.1589 & 0.1317 & 0.0619 & 0.0509
 & 0.0383 &	0.0299 \\ 
LightGCN-R   & 0.1420 & 0.1156 & 0.0521 & 0.0401
 & 0.0252 &	0.0196
 \\ \hline\hline
LightGCN & \textbf{0.1830} & \textbf{0.1554} & \textbf{0.0649} & \textbf{0.0530} & 0.0411 & 0.0315 \\ \hline 
\end{tabular}
}
\small{Method notation: -L means only the left-side norm is used, -R means only the right-side norm is used, and - means the  norm is used.}
\end{table}
\subsubsection{Impact of Symmetric Sqrt Normalization}\label{ss:ablation-symmetric}
In LightGCN, we employ symmetric sqrt normalization  on each neighbor embedding when performing neighborhood aggregation (cf. Equation~(\ref{eq:LGC})). To study its rationality, we explore different choices here. We test the use of normalization only at the left side (i.e., the target node's coefficient) and the right side (i.e., the neighbor node's coefficient). 
We also test  normalization, i.e.,  removing the square root. 
Note that if removing normalization, the training becomes numerically unstable and suffers from not-a-value (NAN) issues, so we do not show this setting. 
Table \ref{tab:norm-3} shows the results of the 3-layer LightGCN. We have the following observations:
\begin{itemize}[leftmargin=*]
    \item The best setting in general is using sqrt normalization at both sides (i.e., the current design of LightGCN). Removing either side will drop the performance largely.
    \item The second best setting is using  normalization at the left side only (i.e., LightGCN--L). This is equivalent to normalize the adjacency matrix as a stochastic matrix by the in-degree. 
    \item Normalizing symmetrically on two sides is helpful for the sqrt normalization, but will degrade the performance of  normalization. 
\end{itemize}

\subsubsection{Analysis of Embedding Smoothness} 
As we have analyzed in Section~\ref{ss:second-order}, a 2-layer LightGCN smooths a user's embedding based on the users that have overlap on her interacted items, and the smoothing strength between two users  is measured in Equation~(\ref{eq:c_vu}). We speculate that such smoothing of embeddings is the key reason of LightGCN's effectiveness. To verify this, we first define the smoothness of user embeddings as:

where the  norm on embeddings is used to eliminate the impact of the embedding's scale. Similarly we can obtained the definition for item embeddings. 
Table~\ref{tab:Smoothness} shows the smoothness of two models, matrix factorization (i.e., using the  for model prediction) and the 2-layer LightGCN-single (i.e., using the  for prediction). 
Note that the 2-layer LightGCN-single outperforms MF in recommendation accuracy by a large margin. As can be seen, the smoothness loss of LightGCN-single is much lower than that of MF. This indicates that by conducting light graph convolution, the embeddings become smoother and more suitable for recommendation. 


\begin{table}[t]
\caption{Smoothness loss of the embeddings learned by LightGCN and MF (the lower the smoother).}\vspace{-8pt}
\label{tab:Smoothness}
\begin{tabular}{l|c|c|c}
\hline
\textbf{Dataset} & \multicolumn{1}{c|}{\textbf{Gowalla}} & \multicolumn{1}{c|}{\textbf{Yelp2018}} & \multicolumn{1}{c}{\textbf{Amazon-book}}\\ \hline
&\multicolumn{3}{c}{\textbf{Smoothness of User Embeddings}}\\ \hline
MF & 15449.3 & 16258.2 & 38034.2  \\ \hline
LightGCN-single & 12872.7 & 10091.7 & 32191.1 \\ \hline
&\multicolumn{3}{c}{\textbf{Smoothness of Item Embeddings}}\\ \hline
MF & 12106.7 & 16632.1 & 28307.9  \\ \hline
LightGCN-single & 5829.0 & 6459.8 & 16866.0 \\ \hline
\end{tabular}
\vspace{-5pt}
\end{table}



\subsection{Hyper-parameter Studies}\label{ss:exp-hyper}
When applying LightGCN to a new dataset, besides the standard hyper-parameter learning rate, the most important hyper-parameter to tune is the  regularization coefficient . 
Here we investigate the performance change of LightGCN w.r.t. . 

As shown in Figure \ref{fig:reg},
LightGCN is relatively insensitive to  --- even when  sets to 0, LightGCN is better than NGCF, which additionally uses dropout to prevent overfitting\footnote{Note that Gowalla shows the same trend with Amazon-Book, so its curves are not shown to better highlight the trend of Yelp2018 and Amazon-Book.}. 
This shows that LightGCN is less prone to overfitting --- since the only trainable parameters in LightGCN are ID embeddings of the 0-th layer, the whole model is easy to train and to regularize. The optimal value for Yelp2018, Amazon-Book, and Gowalla is , , and  , respectively. When  is larger than , the performance drops quickly, which indicates that too strong regularization will negatively affect model normal training and is not encouraged. 

\begin{figure}[t]
	\centering
	\subfigure{\includegraphics[width=0.23\textwidth]{recall_20_reg.pdf}} 
	\subfigure{\includegraphics[width=0.23\textwidth]{ndcg_20_reg.pdf}} 
	\vspace{-15pt}
	\caption{Performance of 2-layer LightGCN w.r.t. different regularization coefficient  on Yelp and Amazon-Book.} \vspace{-10pt}
	\label{fig:reg}
\end{figure}

%
 \section{Related Work}\label{sec:related}


\subsection{Collaborative Filtering}
Collaborative Filtering (CF) is a prevalent technique in modern recommender systems~\cite{YoutubeRS,PinSage}.
One common paradigm of CF model is to parameterize users and items as embeddings, and learn the embedding parameters by reconstructing historical user-item interactions.
For example, earlier CF models like matrix factorization (MF)~\cite{MF,BPRMF} project the ID of a user (or an item) into an embedding vector. The recent neural recommender models like NCF~\cite{NCF} and LRML~\cite{tay2018latent} use the same embedding component, while enhance the interaction modeling with neural networks. 






Beyond merely using ID information, another type of CF methods considers historical items as the pre-existing features of a user, towards better user representations.
For example,  FISM~\cite{FISM} and SVD++~\cite{SVD++} use the weighted average of the ID embeddings of historical items as the target user's embedding. 
Recently, researchers realize that historical items have different contributions to shape personal interest.
Towards this end, attention mechanisms are introduced to capture the varying contributions, such as ACF~\cite{ACF} and NAIS~\cite{NAIS}, to automatically learn the importance of each historical item. 
When revisiting historical interactions as a user-item bipartite graph, the performance improvements can be attributed to the encoding of local neighborhood --- one-hop neighbors --- that improves the embedding learning.

\subsection{Graph Methods for Recommendation}
Another relevant research line is exploiting the user-item graph structure for recommendation.
Prior efforts like ItemRank~\cite{ItemRank}, use the label propagation mechanism to directly propagate user preference scores over the graph, \ie encouraging connected nodes to have similar labels.
Recently emerged graph neural networks (GNNs) shine a light on modeling graph structure, especially high-hop neighbors, to guide the embedding learning~\cite{GCN,GraphSAGE}.
Early studies define graph convolution on the spectral domain, such as Laplacian eigen-decomposition~\cite{DBLP:journals/corr/BrunaZSL13} and Chebyshev polynomials~\cite{FirstGCN}, which are computationally expensive.
Later on, GraphSage~\cite{GraphSAGE} and GCN~\cite{GCN} re-define graph convolution in the spatial domain, i.e., aggregating the embeddings of neighbors to refine the target node's embedding. Owing to its interpretability and efficiency, it quickly becomes a prevalent formulation of GNNs and is being widely used~\cite{DeepInf,Feng2019TOIS,zhao2019cross}.
Motivated by the strength of graph convolution, recent efforts like NGCF~\cite{NGCF}, GC-MC~\cite{GC-MC}, and PinSage~\cite{PinSage} adapt GCN to the user-item interaction graph, capturing CF signals in high-hop neighbors for recommendation.


It is worth mentioning that several recent efforts provide deep insights into GNNs~\cite{DeepInsights,ICLR19-APPNP,SGCN}, which inspire us developing LightGCN. Particularly, Wu et al.~\cite{SGCN} argues the unnecessary complexity of GCN, developing a simplified GCN (SGCN) model by removing nonlinearities and collapsing multiple weight matrices into one. 
One main difference is that LightGCN and SGCN are developed for different tasks, thus the rationality of model simplification is different. Specifically, SGCN is for node classification, performing simplification for model interpretability and efficiency. In contrast, LightGCN is on collaborative filtering (CF), where each node has an ID feature only. Thus, we do simplification for a stronger reason: nonlinearity and weight matrices are useless for CF, and even hurt model training. For node classification accuracy, SGCN is on par with (sometimes weaker than) GCN. While for CF accuracy, LightGCN outperforms GCN by a large margin (over 15\% improvement over NGCF). 
Lastly, another work conducted in the same time~\cite{LR-GCCF} also finds that the nonlinearity is unnecessary in NGCF and develops linear GCN model for CF. In contrast, our LightGCN makes one step further --- we remove all redundant parameters and retain only the ID embeddings, making the model as simple as MF. 








 \section{Conclusion and Future Work} \label{sec:conclusion}
In this work, we argued the unnecessarily complicated design of GCNs for collaborative filtering, and performed empirical studies to justify this argument. 
We proposed LightGCN which consists of two essential components --- light graph convolution and layer combination. 
In light graph convolution, we 
discard feature transformation and nonlinear activation --- two standard operations in GCNs but inevitably increase the training difficulty. In layer combination, we construct a node's final embedding as the weighted sum of its embeddings on all layers, which is proved to subsume the effect of self-connections and is helpful to control oversmoothing. 
We conduct experiments to demonstrate the strengths of LightGCN in being simple: easier to be trained, better generalization ability, and more effective. 

We believe the insights of LightGCN are inspirational to future developments of recommender models. With the prevalence of linked graph data in real applications, graph-based models are becoming increasingly important in recommendation;
by explicitly exploiting the relations among entities in the predictive model, they are advantageous to traditional supervised learning scheme like factorization machines~\cite{FM,NFM} that model the relations implicitly. 
For example, a recent trend is to exploit auxiliary information such as item knowledge graph~\cite{KGAT}, social network~\cite{GCNSocial} and multimedia content~\cite{MMGCN} for recommendation, where GCNs have set up the new state-of-the-art. 
However, these models may also suffer from the similar issues of NGCF since the user-item interaction graph is also modeled by same neural operations that may be unnecessary. We plan to explore the idea of LightGCN in these models. Another future direction is to personalize the layer combination weights , so as to enable adaptive-order smoothing for different users (e.g., sparse users may require more signal from higher-order neighbors while active users require less). Lastly, we will explore further the strengths of LightGCN's simplicity, studying whether fast solution exists for non-sampling regression loss~\cite{he2019fast} and streaming it for online industrial scenarios. 

\noindent\textbf{Acknowledgement}. The authors thank Bin Wu, Jianbai Ye, and Yingxin Wu for contributing to the implementation and improvement of LightGCN. This work is supported by the National Natural Science Foundation of China (61972372, U19A2079, 61725203). 

\bibliographystyle{ACM-Reference-Format}
\balance

\bibliography{ms}
\balance
\scriptsize

\end{document}
