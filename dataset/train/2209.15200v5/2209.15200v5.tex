\documentclass{article} \usepackage{iclr2023_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{setspace}


\usepackage{hyperref}
\usepackage{url}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{booktabs} \usepackage{multirow}
\title{An efficient encoder-decoder architecture with top-down attention for speech separation}
\iclrfinalcopy


\author{Kai Li, Runxuan Yang \& Xiaolin Hu\thanks{Corresponding author.} \\
1. Department of Computer Science and Technology, Institute for AI,  \\ BNRist,
Tsinghua University, Beijing 100084, China \\
2. Tsinghua Laboratory of Brain and Intelligence (THBI), \\ IDG/McGovern Institute for Brain Research, Tsinghua University, Beijing 100084, China \\
3. Chinese Institute for Brain Research (CIBR), Beijing 100010, China \\
\texttt{\{lk21,yangrx20\}@mails.tsinghua.edu.cn} \\
\texttt{xlhu@tsinghua.edu.cn} \\
}



\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}


\maketitle

\begin{abstract}
Deep neural networks have shown excellent prospects in speech separation tasks. 
However, obtaining good results while keeping a low model complexity remains challenging in real-world applications. 
In this paper, we provide a bio-inspired efficient encoder-decoder architecture by mimicking the brain's top-down attention, called TDANet, with decreased model complexity without sacrificing performance. The top-down attention in TDANet is extracted by the global attention (GA) module and the cascaded local attention (LA) layers. The GA module takes multi-scale acoustic features as input to extract global attention signal, which then modulates features of different scales by direct top-down connections. The LA layers use features of adjacent layers as input to extract the local attention signal, which is used to modulate the lateral input in a top-down manner.
On three benchmark datasets, TDANet consistently achieved competitive separation performance to previous state-of-the-art (SOTA) methods with higher efficiency. Specifically, TDANet's multiply-accumulate operations (MACs) are only 5\% of Sepformer, one of the previous SOTA models, and CPU inference time is only 10\% of Sepformer. In addition, a large-size version of TDANet obtained SOTA results on three datasets, with MACs still only 10\% of Sepformer and the CPU inference time only 24\% of Sepformer.
Our study suggests that top-down attention can be a more efficient strategy for speech separation.
\end{abstract}

\section{Introduction}
In cocktail parties, people's communications are inevitably disturbed by various sounds \citep{bronkhorst2015cocktail, cherry1953some}, such as environmental noise and extraneous audio signals, potentially affecting the quality of communication. Humans can effortlessly perceive the speech signal of a target speaker in a cocktail party to improve the accuracy of speech recognition \citep{haykin2005cocktail}. In speech processing field, the corresponding challenge is to separate different speakers' audios from the mixture audio, known as \textit{speech separation}.

Due to rapid development of deep neural networks (DNNs), DNN-based speech separation methods have significantly improved \citep{luo2019conv, luo2020dual, tzinis2020sudo, Chen2020, subakan2021attention, hu2021speech, li2022design}. As in natural language processing, the SOTA speech separation methods are now embracing increasingly complex models to achieve better separation performance, such as DPTNet \citep{Chen2020} and Sepformer \citep{subakan2021attention}. These models typically use multiple transformer layers \citep{vaswani2017attention} to capture longer contextual information, leading to a large number of parameters and high computational cost and having a hard time deploying to edge devices. We question whether such complexity is always needed in order to improve the separation performance. 


Human brain has the ability to process large amounts of sensory information with extremely low energy consumption \citep{attwell2001energy, howarth2012updated}. We therefore resort to our brain for inspiration. Numerous neuroscience studies have suggested that in solving the cocktail part problem, the brain relies on a cognitive process called {\it top-down attention} \citep{wood1995cocktail,haykin2005cocktail,fernandez2015top}. It enables human to focus on task-relevant stimuli and ignore irrelevant distractions. Specifically, top-down attention modulates (enhance or inhibit) cortical sensory responses to different sensory information \citep{gazzaley2005top,johnson2005attention}. With neural modulation, the brain is able to focus on speech of interest and ignore others in a multi-speaker scenario \citep{mesgarani2012selective}.

We note that encoder-decoder speech separation networks (e.g., SuDORM-RF \citep{tzinis2020sudo} and A-FRCNN \citep{hu2021speech}) contain top-down, bottom-up, and lateral connections, similar to the brain's hierarchical structure for processing sensory information \citep{park2013structural}. These models mainly simulate the interaction between lower (e.g., A1) and higher (e.g., A2) sensory areas in primates, neglecting the role of higher cortical areas such as frontal cortex and occipital cortex in accomplishing challenging auditory tasks like the cocktail party problem \citep{bareham2018role, cohen2005auditory}. But they provide good frameworks for applying top-down attention mechanisms.



\begin{figure}[ht]
\centering
\includegraphics[width=0.8\linewidth]{./all_structure.pdf}
\caption{Main architecture of TDANet.  and  denote the number of channels and length of features, respectively. By down-sampling  times, TDANet contains  features with different temporal resolutions. Here, we set  to 3. The red, blue, and orange arrows indicate bottom-up, top-down, and lateral connections, respectively. (a) The structure of the encoder, where ``DWConv" denotes a depthwise convolutional layer with a kernel size of 5 and stride size of 2 followed by GLN. (b) The ``Up-sample" layer denotes nearest neighbor interpolation. (c) The structure of decoder, where the LA layer adaptively modulates features of different scales by a set of learnable parameters.}
\label{fig:all_structure}
\end{figure}

In the speech separation process, the encoder and decoder information are not always useful, so we need an automatic method to modulate the features transmitted by the lateral and top-down connections. We propose an encoder-decoder architecture equipped with top-down attention for speech separation, which is called TDANet. 
As shown in Figure~\ref{fig:all_structure}, TDANet adds a global attention (GA) module to the encoder-decoder architecture, which modulates features of different scales in the encoder top-down through the attention signal obtained from multi-scale features.  The modulated features are gradually restored to high-resolution auditory features through local attention (LA) layers in the top-down decoder.
The experimental results demonstrated that TDANet achieved competitive separation performance on three datasets (LRS2-2Mix, Libri2Mix \citep{cosentino2020librimix}, and WHAM! \citep{Wichern2019}) with far less computational cost. Taking LRS2-2Mix dataset as an example -- when comparing with Sepformer, TDANet's MACs are only 5\% of it and CPU inference time is only 10\% of it.



\section{Related work}
In recent years, DNN-based speech separation methods have received widespread attention, and speech separation performance has been substantially improved. Existing DNN-based methods are categorized into two major groups: time-frequency domain \citep{hershey2016deep,chen2017deep,yu2017permutation} and time domain \citep{luo2019conv, luo2020dual, tzinis2020sudo, Chen2020, subakan2021attention, hu2021speech}. Time domain methods obtain better results compared to time-frequency domain methods as they avoid explicit phase estimation.
Recently, time domain methods Sepformer \citep{subakan2021attention} and DPTNet \citep{Chen2020} replace LSTM layers with transformer layers to avoid performance degradation due to long-term dependencies and to process data in parallel for efficiency. These methods achieve better separation performance, but the number of model parameters and computational cost become larger due to additional transformer layers. Although large-scale neural networks can achieve better performance in various tasks such as BERT \citep{bert} and DALLÂ·E 2 \citep{ramesh2022hierarchical}, it is also an important topic to design lightweight models that can be deployed to low-resource platforms.

The encoder-decoder speech separation model SuDORM-RF \citep{tzinis2020sudo} achieves a certain extent of trade-off between model peformance and complexity, but its performance is still far from SOTA methods. Other researchers have designed a fully recurrent convolutional neural network A-FRCNN \citep{hu2021speech} with an asynchronous update scheme and obtained competitive separation results with a relatively small number of parameters, but the computational complexity still has room to improve. 


Some earlier works \citep{xu2018modeling, shi2018listen, shi2019ones} make use of top-down attention in designing speech separation models, but they only consider the projection of attentional signals to the top layer of the multilayer LSTM and without applying attention to lower layers. These approaches may not fully take advantage of top-down attention. In addition, these approaches have a large gap in model performance and complexity with recent models including SuDORM-RF and A-FRCNN. 

For a survey on the use of top-down attention in other domains, see Appendix~\ref{sec:a-rw}





\section{Method}
\begin{figure}[ht]
\centering
\includegraphics[width=0.75\linewidth]{pipeline.pdf}
\caption{The overall pipeline for the speech separation task. We assume that the mixture audio contains two speakers here. The parameters are shared between the two audio decoders.}
\label{fig:pipeline}
\end{figure}

\subsection{Overall Pipeline}

Given an audio containing multiple speakers, the speech separation methods aim to extract different speakers' utterances and route them to different output channels. Let  be a multi-speaker time-domain audio signal with the length :

consisting of  speaker signals  plus the noise signal . We expect the separated speeches  from all speakers to be closer to target speeches .

Our proposed method uses the same three-part pipeline as in Conv-TasNet \citep{luo2019conv}: \textit{an audio encoder}, \textit{a separation network} and \textit{an audio decoder}. The audio encoder transforms  into a frame-based -dimensional embedding sequence  with length , called mixture audio embedding, which can be implemented using a 1-D convolutional layer with kernel size  and stride size . Similar to existing separation methods \citep{luo2019conv, luo2018tasnet, luo2020dual, subakan2021attention, Chen2020, li2022use}, instead of directly estimating the target speech embeddings, we use a DNN-based separation network  to generate a set of masks  associated with the target speakers. Each target speech embedding  is generated by applying the corresponding mask  to the mixture audio embedding :

where  denotes element-wise product. Finally, the target waveform  is reconstructed using the target speech embedding  through an audio decoder, which can be implemented using a 1-D transposed convolutional layer with the same kernel and stride sizes as the audio encoder.

Overall there are three main components: (a) encoder (see Section~\ref{sec:dbc}), (b) global attention (GA) module (see Section~\ref{sec:sa}) and (c) decoder (see Section~\ref{sec:lft}). The process detail is as follows. First, the encoder obtains multi-scale features using the bottom-up connections. Second, the GA module extracts global features at the top layer using multi-scale features, and then the global features are used as attention to modulate features from different scales using top-down connections.
Third, the adjacent layer features are used as the input into the decoder to extract the acoustic features through LA layers. This completes one cycle of information processing inside TDANet. Similar to A-FRCNN \cite{hu2021speech}, we cycle TDANet several times and use the output features from the last cycle as the separation network output (see Section~\ref{sec:re}).

\subsection{Encoder of TDANet}
\label{sec:dbc}
The encoder of TDANet is designed for extracting features at different temporal resolutions.
Lower layers have higher temporal resolutions, while higher layers have lower temporal resolutions.  
The encoder works as follows (see Figure ~\ref{fig:all_structure}a). For a mixture audio embedding , the encoder processes  in a bottom-up manner step by step. The bottom-up connections in the encoder are implemented by down-sampling layers, which consist of a 1-D convolutional layer followed by a global layer normalization (GLN) \citep{luo2019conv} and PReLU. To efficiently expand the perceptual field, these convolutional layers use dilation convolution with  kernels with size 5, stride size 2 and dilation size 2 instead of standard convolution to aggregate longer contexts. In this way, we obtain features with different resolutions , where  denotes the number of down-sampling.

\subsection{Global attention (GA) module of TDANet}
\label{sec:sa}
The GA module works in two steps: 
\begin{enumerate}
    \item[(1)] It receives multi-scale features  as input and computes global feature ;
    \item[(2)] It uses the  as top-down attention to modulate , controlling the redundancy of information passed to the decoder.
\end{enumerate}

\textbf{Details of the first step in the GA module}: Taking multi-scale features  as input, we use the average pooling layers to compress these features in temporal dimension from  to  for reducing computational cost. The features with different temporal resolutions are fused into the global feature  by a summation operation. The calculation of global feature can be written as:

where  denotes the average pooling layer.  will be treated as input to the transformer layer to obtain the speaker's acoustic patterns from global contexts. 

The transformer layer contains two components: multi-head self-attention (MHSA) and feed-forward network (FFN) layers, as shown in Figure~\ref{fig:tl}. The MHSA layer is the same as the encoder structure defined in Transformer \citep{vaswani2017attention}. This layer has been widely used in recent speech processing tasks \citep{Chen2020, subakan2021attention, lam2021sandglasset}. First, the position information  of different frames is added to global feature  to get , . Then, each attention head calculates the dot product attention between all elements of  in different feature spaces to direct model focus to different aspects of information. Finally, the output  of MHSA is fed into GLN and then connected  through the residual connection to obtain .

\begin{wrapfigure}{tr}{0.55\textwidth}
  \vspace{-10pt}
\centering
\includegraphics[width=0.8\linewidth]{tl.pdf}
\caption{The structure of transformer layer.}
\label{fig:tl}
\end{wrapfigure}


The FFN layer followed by MHSA layer consists of three convolutional layers. First,  is processed in a  convolutional layer with GLN mapped to the -dimensional representation space. Then, the second convolutional layer composed of a  depthwise convolutional layer followed by GLN extracts relationship among  sequences. Finally, a  convolutional layer followed by GLN compresses the -dimensional features into -dimensions to obtain  and also use a residual connection to alleviate the vanishing gradient problem.

\begin{wrapfigure}{tr}{0.55\textwidth}
  \vspace{-10pt}
\centering
\includegraphics[width=0.8\linewidth]{lft.pdf}
\caption{The structure of LA layer in the decoder, where ``Conv1D" denotes the  depthwise convolutional layer followed by GLN.}
\label{fig:lft}
\end{wrapfigure}



\textbf{Details of the second step in the GA module}: We use  as top-down attention (see Figure \ref{fig:all_structure}b) to modulate  before adding it to the decoder. Specifically, we up-sample  along the time dimension using nearest neighbor interpolation to obtain the same time dimension as , and then use the Sigmoid function to obtain the attention signal. In this way, the multi-scale semantic information of  can guide the local features  to focus more on feature details that may be lost in the bottom-up path in order to improve quality of separated audios. The modulated features are calculated as:

where  denotes nearest neighbor interpolation,  stands for the Sigmoid function and  denotes element-wise product. The modulated features  are used as input to the decoder to extract different speakers' features.

The GA module functions as higher cortical areas such as frontal cortex and occipital cortex in the brain which play an important role in accomplishing complicated sensory tasks. Here, it is only designed for top-down modulation in performing speech separation tasks \citep{bareham2018role, cohen2005auditory}. 


\subsection{Decoder of TDANet}
\label{sec:lft}

The decoder progressively extracts acoustic features through top-down connections whose core component is the LA layer, as shown in Figure~\ref{fig:all_structure}c. The LA layer uses a small amount of parameters ( 0.01M) to generate adaptive parameters  and  as local top-down attention to perform affine transformation on features from the current layer to reconstruct fine-grained features. Figure \ref{fig:lft} shows detailed architecture of the LA layer. First, LA layer uses  1-D kernels with length 5 to perform convolution in temporal dimension using features , resulting in . Meanwhile, another identical 1-D convolutional layer followed by GLN and Sigmoid uses   as input, resulting in attention signal . Consequently,

where  and  denote two different parameters of 1-D convolutional layers followed by GLN. ,  and  have the same dimensions. The learnable parameters are used to adaptively modulate  via a top-down local attention . This process is formulated by 

After the feature extraction from the highest layer to the lowest layer, the output of the decoder use  convolutional layers with  kernels with length of 1 and stride of 1 followed by an activation function (ReLU) to obtain  masks , respectively.

\subsection{Unfolding method of TDANet}
\label{sec:re}


Clearly, the bottom-up, lateral and top-down connections (Figure~\ref{fig:all_structure}) make TDANet a recurrent model. We need to unfold it through time for training and testing. We adopt the unfolding scheme summation connection (SC) as in A-FRCNN \citep{hu2021speech}. Figure \ref{fig:all_structure} shows a single block in the whole unfolding scheme. We repeat the block  times (weight sharing), such that the model's input adds up with each block's output as the next block's input.

\section{Experiment Configurations}
\subsection{Dataset Simulations}
We evaluated TDANet and other existing methods on three datasets: LibriMix, WHAM!, LRS2-2Mix). The speaker identities of \texttt{training/validation} set and \texttt{test} set are non-intersecting, meaning unseen speaker data from the training phase were used during testing.

\textbf{Libri2Mix} \citep{cosentino2020librimix}. In this dataset, the target speech in each mixture audio was randomly selected from a subset of LibriSpeech's train-100 \citep{panayotov2015librispeech} and mixed with uniformly sampled Loudness Units relative to Full Scale (LUFS) \citep{series2011algorithms} between -25 and -33 dB. Each mixture audio contains two different speakers and have a duration of 3 seconds with 8 kHz sample rate.

\textbf{WHAM!} \citep{Wichern2019}. This dataset acts as a noisy version of WSJ0-2Mix \citep{hershey2016deep}. In the WSJ0-2Mix dataset, the overlap between two speaker audios in the mixture is 100\%, which is too idealistic, and thus model trained on this dataset does not achieve generalization to speeches from a broader range of speakers \citep{cosentino2020librimix}. In the WHAM! dataset, speeches were mixed with noise recorded in scenes such as cafes, restaurants and bars. The signal-to-noise ratio of the noise was uniformly sampled between -6db and 3db, making it more challenging mixture audios than WSJ0-2Mix. Each mixture audio contains two different speakers and have a duration of 4 seconds with 8 kHz sample rate.

\textbf{LRS2-2Mix}. The LRS2 dataset \citep{afouras2018deep} contains thousands of video clips acquired through BBC. LRS2 contains a large amount of noise and reverberation interference, which is more challenging and closer to the actual environment than the WSJ0 \citep{garofolo1993csr} and LibriSpeech \citep{panayotov2015librispeech} corpora. We created a new speech separation dataset, LRS2-2Mix, using the LRS2 corpus, where the training set, validation set and test set contain 20000, 5000 and 3000 utterances, respectively. The two different speaker audios from different scenes with 16 kHz sample rate were randomly selected from the LRS2 corpus and were mixed with signal-to-noise ratios sampled between -5 dB and 5 dB. The data were simulated using a script consistent with WSJ0-2Mix\footnote{\url{http://www.merl.com/demos/deep-clustering/create-speaker-mixtures.zip}}. The length of mixture audios is 2 seconds. It is publicly available\footnote{\url{https://drive.google.com/file/d/1dCWD5OIGcj43qTidmU18unoaqo_6QetW/view}}.

\subsection{Model and training Configurations}
We set the kernel size  of the \textit{audio encoder} and \textit{audio decoder} in the overall pipeline to 4 ms and stride size  to 1 ms. The number of down-sampling  was set to 4. The number of channels  of all convolutional layers in each layer was set to 512, and the SC method proposed by A-FRCNN \citep{hu2021speech} was used to unfold  times at the macro level. For the MHSA layer, we set the number of attention heads to 8, the dimension to 512, and used sine and cosine functions with different frequencies for the position encoding. The mask of the MHSA layer was disabled because our task allows the model to see future information. In addition, we set the number of channels for the three convolutional layers in the FFN layer to (512, 1024, 512), the kernel sizes to (1, 5, 1), the stride sizes to (1, 1, 1), and the bias settings to (False, True, False). To avoid overfitting, we set the probability of all dropouts to 0.1.

We trained all models for 500 epochs. The batch size was set to 1 at the utterance level. Our proposed model used the Adam \citep{kingma2015adam} optimizer with an initial learning rate of 0.001. We used maximization of scale-invariant signal-to-noise ratio (SI-SNR) \citep{hershey2016deep} as the training goal (See Appendix~\ref{sec:a-tm} for details). Once the best model was not found for 15 successive epochs, we adjusted the learning rate to half of the previous one. Moreover, we stopped training early when the best model was not found for 30 successive epochs. During the training process, we used gradient clipping with a maximum L2 norm of 5 to avoid gradient explosion. For all experiments, we used  GeForce RTX 3080 for training and testing. The PyTorch implementation of our method is publicly available\footnote{\url{https://cslikai.cn/project/TDANet/}}. This project is under the MIT license.

\subsection{Evaluation Metrics}
In all experiments, we report the results of scale-invariant signal-to-noise ratio improvement (SI-SNRi) \citep{le2019sdr} and signal-to-distortion ratio improvement (SDRi) \citep{vincent2006performance} used to measure clarity of separated audios. For measuring model efficiency, we report the processing time consumption per second (real-time factor, RTF) for all models, indicated by ``RTF" in the tables throughout this paper. It was calculated by processing ten audio tracks of 1 second in length and 16 kHz in sample rate on CPU and GPU (total processing time / 10), represented as ``CPU RTF" and ``GPU RTF", respectively. The numbers were then averaged after running 1000 times. Also, we used the parameter size and the number of MACs to measure the model size, where the MACs were calculated using the open-source tool PyTorch-OpCounter\footnote{\url{https://github.com/Lyken17/pytorch-OpCounter}}. This toolkit is used under the MIT license.

\section{Results}
\subsection{Ablation study}
To better understand the effectiveness of top-down attention, we investigated the impacts of two types of attention components in the model for separation performance, including GA module and LA layer. All experimental results were obtained by training and testing on the LRS2-2Mix dataset.

\begin{table}[ht]
\vspace{-1.0em}
\caption{Comparison over separation performance and efficiency among different types of top-down attention. ``" indicates the case where a component is used in the TDANet. ``" indicates the opposite. }
\label{table:ab}
\footnotesize
\begin{center}
\begin{tabular}{ccccccc}
\toprule
GA module & LA layer & SI-SNRi (dB) & SDRi (dB) & Params (M) & MACs (G/s) & CPU RTF (s) \\
\midrule
 & & 10.1 & 10.5 & \textbf{0.7} & \textbf{2.5} & \textbf{0.65}\\
  &      & 12.4        & 12.7      & 2.3        & 4.6        & 0.79        \\
 &       & 11.9        & 12.2      & \textbf{0.7}        & 2.6        & 0.65        \\
  &      & \textbf{13.2}         & \textbf{13.5}      & 2.3        & 4.7        & 0.79        \\
\bottomrule
\end{tabular}
\end{center}
\vspace{-1.0em}
\end{table}

We first constructed a control model that does not contain the GA module and LA layer. It takes the top-layer features of the encoder as input to the decoder. Note that excluding the LA layer means removing the gray box in Figure~\ref{fig:lft}. This architecture then becomes a typical U-Net \citep{ronneberger2015u}, similar to a basic block used as in SuDORM-RF \citep{tzinis2020sudo}. From Table~\ref{table:ab}, it is seen that SI-SNRi of this model is only 10.1 dB.

When only adding the GA module into TDANet, the SI-SNRi increased by 2.3 dB compared to when it was absent (Table~\ref{table:ab}). The GA module contains a transformer layer and top-down projections. We are interested in whether the performance improvement came from the transformer layer or the top-down projections. Table~\ref{table:tl} from Appendix~\ref{sec:a-tl} demonstrates that the performance improvement is independent of the transformer layer. When only adding the LA layer, we observed that the SI-SNRi increased by 1.8 dB without increasing computational cost. We noticed that the GA module had larger impact on performance improvement. One possible explanation is that the GA module modulates on a wide range of features, while the LA layer only focuses on adjacent ones. When both GA module and LA layer were used, the performance were the best.










More ablation studies and discussions are reported in Appendix~\ref{sec:ae}. Firstly, we observed that multi-scale features using summation fusion strategy as GA module input were efficient for performance improvement without significantly increasing computational cost (Appendix~\ref{sec:a-ga}). Secondly, TDANet obtained the best separation performance when both MHSA and FFN layers were present in the GA module (Appendix~\ref{sec:a-tl-c}). Thirdly, we found that top-down attention is essential in improving separation performance (Appendix~\ref{sec:a-tda-ga-de}). Finally, we discussed the possible reasons for the effectiveness of LA and further verified its performance on SuDoRM-RF (Appendix~\ref{sec:a-tda-ga-de}).




\subsection{Comparisons with state-of-the-art methods}

We conducted extensive experiments to quantitatively compare speech separation performance of our proposed TDANet with some existing speech separation models on three datasets. The results are shown in Table~\ref{table:allmodel}. We selected some typical models that have shown good separation performance, including BLSTM-TasNet \citep{luo2018tasnet}, Conv-TasNet \citep{luo2019conv}, SuDORM-RF \citep{tzinis2020sudo}, DualPathRNN \citep{luo2020dual}, DPTNet \citep{Chen2020}, Sepformer \citep{subakan2021attention}, and A-FRCNN \citep{hu2021speech}. SuDORM-RF contains two variants with good performance, suffixed with 1.0x and 2.5x, indicating that these variants consist of 16 and 40 blocks, respectively. A-FRCNN has a suffix ``16" denoting that the model is expanded 16 times at the macro level. LRS2-2Mix is the newly proposed speech separation dataset in this paper, so none of these models reported results on this dataset.

\textbf{Separation performance}. TDANet obtained competitive separation performance with much lower complexity than previous SOTA models on the three datasets (see Table~\ref{table:allmodel}), clearly demonstrating the importance of top-down attention for the encoder-decoder network. On the LRS2-2Mix dataset, TDANet lost only 0.3 dB SI-SNRi in separation performance but with only 8\% of number of parameters compared to Sepformer, one of previous SOTA models. On the other two datasets, TDANet also obtained competitive results compared to previous SOTA models.


Some audio examples from LRS2-2Mix separated by different models are provided in \textbf{Supplementary Material}. In most examples, we found that separation results with TDANet sound better than those from other models. 


\begin{table}[ht]
\vspace{-1.0em}
\caption{Quantitative comparison between TDANet and other existing models on three datasets (test set). ``-" indicates that their results have not been reported in other papers. ``*" denotes that they were not reported in the original paper but were trained and tested using the Asteroid Toolkit \citep{Pariente2020Asteroid}. The results of DPTNet on Libri2Mix and WHAM! datasets were reported in \citep{yao2022stepwise}, but not in the original paper. ``" denotes that the results of Sepformer were trained and tested using the SpeechBrain Toolkit \citep{ravanelli2021speechbrain}}
\label{table:allmodel}
\footnotesize
\centering
\begin{tabular}{cccccccc}
\toprule
\multirow{2}{*}{Model [Authors, Years]} & \multicolumn{2}{c}{LRS2-2Mix} & \multicolumn{2}{c}{Libri2Mix} & \multicolumn{2}{c}{WHAM!} & Params  \\ \cmidrule(r){2-3} \cmidrule(r){4-5} \cmidrule(r){6-7}
                       & SI-SNRi        & SDRi         & SI-SNRi         & SDRi        & SI-SNRi       & SDRi      &       (M)                                    \\
\midrule
BLSTM-TasNet [Luo et al, 2018]        & 6.1*           & 6.8*         & 7.9             & 8.7         & 9.8           & -         & 23.6                                    \\
Conv-TasNet  [Luo et al, 2019]         & 10.6*          & 11.0*        & 12.2            & 12.7        & 12.7          & -         & 5.6                                   \\
SuDoRM-RF1.0x [Tzinis et al, 2020]        & 11.0*          & 11.4*        & 13.5            & 14.0        & 12.9          & 13.3      & 2.7                                  \\
SuDoRM-RF2.5x  [Tzinis et al, 2020]          & 11.3*          & 11.7*        & 14.0            & 14.4        & 13.7          & 14.1      & 6.4                            \\
DualPathRNN  [Luo et al, 2020]          & 12.7*          & 13.0*        & 16.1            & 16.6        & 13.7          & 14.1      & 2.7                              \\
DPTNet [Chen et al, 2020] & 13.3*         & 13.6*       & 16.7            & 17.1        & 14.9          & 15.3      & 2.7                           \\
A-FRCNN-16 [Hu et al, 2021]         & 13.0*          & 13.3*        & 16.7            & 17.2        & 14.5          & 14.8      & 6.1                                 \\
Sepformer   [Subakan et al, 2021]          & 13.5           & 13.8        & 16.5            & 17.0        & 14.4          & 15.0     & 26.0                                 \\
\midrule
TDANet (\textit{ours})        & 13.2           & 13.5         & 16.9            & 17.4        & 14.8          & 15.0      & 2.3                                  \\
TDANet Large (\textit{ours})       & \bf 14.2           & \bf 14.5         & \bf 17.4            & \bf 17.9        & \bf 15.2          & \bf 15.4      & 2.3     \\         
\bottomrule
\end{tabular}
\vspace{-1.5em}
\end{table}

\textbf{Separation effciency}. In addition to number of model parameters, MACs as well as training and inference time are also important indicators of model complexity, as models with a small amount of parameters may also have a large number of MACs and could be slow to train and infer. By using RTF and MACs as metrics, we evaluated complexity of pervious models (Table~\ref{table:eff}). We observed that TDANet outperformed the previous SOTA models in model complexity. For example, compared to DPTNet and Sepformer, TDANet's MACs are 5\% of them, and backward time is 13\% and 47\% of them, respectively, significantly reducing the time consumption during training. In addition, compared with A-FRCNN and SuDORM-RF 2.5x, TDANet's GPU inference time is 19\% and 18\% of them, GPU training time is 47\% and 37\% of them, and CPU inference time is 15\% and 46\% of them, respectively. These results suggest that TDANet can be more easily deployed to low-resource devices. 

In addition, we verified the performance of TDANet model at low latency (causal) in Appendix~\ref{sec:a-causal}, and the results show that TDANet can still obtain better performance than the lightweight models (SuDORM-RF and A-FRCNN).


\textbf{Large-size version}. For the proposed method, we also constructed a large-size version of TDANet, namely TDANet Large, by modifying the kernel length of the \textit{audio encoder} and \textit{audio decoder} from 4ms to 2ms and the stride size from 2ms to 0.5ms. Note that this does not change the model size while also increasing complexity \citep{tzinis2020sudo,luo2020dual,bahmaninezhad2019unified}. TDANet Large obtained SOTA separation performance without a significant increase in computational cost on all three datasets (see Table~\ref{table:allmodel} and Table~\ref{table:eff}). 
TDANet Large can still maintain a small computational complexity compared to other existing lightweight models. For example, the inference time on the GPU is about 3 times faster, and MACs are about 14 times smaller compared to A-FRCNN. We supplement the results for other models (A-FRCNN and Sepformer) with different kernel size and stride size; see Appendix~\ref{sec:a-L} for details.




\begin{table}[ht]
\vspace{-1.0em}
\caption{Comparison of inference time and MACs on the LRS2-2Mix test set. The test environment for feedforward RTF (F GPU RTF) and backward RTF (B GPU RTF) is Nvidia GeForce RTX 2080 Ti, while the test environment for CPU RTF is Intel(R) Xeon(R) Silver 4210 CPU @ 2.20GHz, single-threaded.}
\label{table:eff}
\footnotesize
\centering
\begin{tabular}{ccccc}
\toprule
Model             & F GPU RTF   (ms) & B GPU RTF   (ms) & CPU RTF (s) & MACs (G/s) \\
\midrule
BLSTM-TasNet      & 233.85           & 654.14           & 5.9      & 43.0   \\
Conv-TasNet       & 15.28            & 56.91            & 0.82   & 10.2     \\
SuDoRM-RF  1.0x   & 27.86            & 95.37            & 0.75    & 4.6    \\
SuDoRM-RF  2.5x   & 64.70            & 228.57           & 1.73    & 10.1    \\
DualPathRNN       & 88.79            & 241.54           & 8.13    & 85.3    \\
DPTNet            &  103.26           &   689.06         &  10.49   & 102.5     \\
A-FRCNN-16        & 61.16            & 183.65           & 5.32    & 125.3    \\
Sepformer         & 65.61            & 184.91           & 7.55    & 86.9    \\
\midrule
TDANet (\textit{ours})  & 11.76            & 86.56            & 0.79  & 4.7      \\
TDANet Large (\textit{ours}) & 23.77            & 97.92            & 1.78    & 9.1    \\
\bottomrule
\end{tabular}
\vspace{-1.5em}
\end{table}

\section{Conclusions}
To fill the gap between the performance of SOTA and lightweight models, we designed an encoder-decoder speech separation network with top-down global attention and local attention, inspired by our brain's top-down attention for solving the cocktail party problem. Our extensive experimental results showed that TDANet could significantly reduce model complexity and inference speed while ensuring separation performance. 


Limitations: The TDANet only reflects certain working principles of the auditory system and is not a faithful model of the auditory system. For example, it requires a bottom-up encoder and a top-down decoder, and it is unclear how such components are implemented in the brain. 


\section*{Acknowledgments}
This work was supported by the National Key Research and Development Program of China (No. 2021ZD0200301) and the National Natural Science Foundation of China (Nos. 61836014, 62061136001, U19B2034).


\bibliography{iclr2023_conference}
\bibliographystyle{iclr2023_conference}

\appendix

\section{Related works in other fields}
\label{sec:a-rw}

To the best of our knowledge, there is no existing method on speech separation that uses top-down attention in an encoder-decoder architecture. Thus, we investigated the use of global top-down attention (similar to top-down attention in the GA module) in hierarchical models in other domains, e.g., image segmentation \cite{chen2016attention,sinha2020multi} and image fusion \cite{li2022mafusion}. However, these methods are all feed-forward network structures. Besides, these methods use different scale features to obtain the corresponding top-down attention respectively and use top-down attention to modulate the features in a complicated way. Furthermore, we surveyed local top-down attention approaches (similar to the LA layer) in other domains, such as SENet \citep{hu2018squeeze}, Highway network \citep{srivastava2015highway} and GRCNN \citep{wang2021convolutional}. These methods introduce the attention mechanism (gate) to achieve filtering and integration of information flow in order to obtain better performance. In this paper, we focus on designing simple neural networks by using multi-scale features as top-down attention to achieve good results with high efficiency.

\section{Training Method}
\label{sec:a-tm}
We apply the permutation-invariant training (PIT) method \citep{yu2017permutation} to solve the permutation problem \citep{hershey2016deep} in order to maximize the scale-invariant signal-to-noise ratio (SI-SNR) \citep{le2019sdr}. The SI-SNR for each speaker is defined as:

where

In the above equation,  denotes the inner product and  denotes the -norm.

\section{Additional experiments}
\label{sec:ae}
\subsection{Effect of transformer layer in the GA module}
\label{sec:a-tl}

The GA module contains a transformer layer and top-down projections. We are interested in whether the performance gain is from the transformer layer or the top-down projections. For TDANet with only the GA module, we removed top-down projections from the GA module, keeping only the transformer layer. When the transformer layer is present, we take the output of it as the decoder input. When the transformer layer is absent, we use the top-layer features of the encoder as input of the decoder. Table 4 shows the experimental results. We found that the presence of the transformer layer does not significantly affect separation performance; both configurations yielded poor results compared with the configuration with top-down projections (SI-SNRi 12.4 dB, Table~\ref{table:ab}). These results further demonstrate the importance of top-down global attention.
\begin{table}[ht]
\caption{Effect of transformer layer. ``TL" denotes transformer layer in the GA module on the LRS2-2Mix dataset.}
\label{table:tl}
\footnotesize
\begin{center}
\begin{tabular}{cccccc}
\toprule
TL & SI-SNRi (dB) & SDRi (dB) & Params (M) & MACs (G/s) & CPU RTF (s) \\
\midrule
 & \textbf{10.3} & \textbf{10.7} & 2.3 & 4.6 & 0.77\\
 & 10.1 & 10.5 & \textbf{0.7} & \textbf{2.5} & \textbf{0.65}\\
\bottomrule
\end{tabular}
\end{center}
\end{table}

\subsection{Effect of multi-scale input to GA module}
\label{sec:a-ga}
To examine the influence on separation performance between two different features as input to the GA module: multi-scale fused features  and top-layer features  (ResNet-style encoder), we experimented with each of them separately. The experimental results are shown in Table~\ref{table:dbc-1}. We chose  instead of  because the former achieved better separation performance (0.4 dB ) without a remarkable increase in computational cost. One possible explanation is that we added dense connections to the ResNet-style structure to project features at different temporal scales to the top layer, which is similar to DenseNet \cite{huang2017densely}, boosting the back-propagation of gradients and making the network easier to train. Another possible explanation is that, in a ResNet-style structure, features may lose details gradually while propagating bottom-up. Using skip connections to project to the top layer enables more efficient use of multi-scale features.


\begin{table}[ht]
\caption{Comparison over separation performance and model complexity between different multi-scale fused top-layer features used for input into the GA module on the LRS2-2Mix dataset.}
\label{table:dbc-1}
\begin{center}
\begin{tabular}{cccccc}
\toprule
Methods & SI-SNRi (dB) & SDRi (dB) & Params (M) & MACs (G/s) & CPU RTF (s) \\
\midrule
 & \bf 13.2         & \bf 13.5      & \bf 2.3        & \bf 4.7        & 0.79        \\
        & 12.8         & 13.1      & 2.3        & 4.7        & \bf 0.74       \\
\bottomrule
\end{tabular}
\end{center}
\end{table}

In addition, we investigated two different strategies for multi-scale feature fusion: summation and concatenation. Table~\ref{table:dbc-2} shows the results. Summation outperformed concatenation in terms of both separation performance and computational efficiency. Therefore, we employed summation operation as the fusion strategy.

\begin{table}[ht]
\caption{Comparison over separation performance and model complexity between different fusion strategies on the LRS2-2Mix dataset.}
\label{table:dbc-2}
\begin{center}
\begin{tabular}{cccccc}
\toprule
Fusion strategy & SI-SNRi (dB) & SDRi (dB) & Params (M) & MACs (G/s) & CPU RTF (s) \\
\midrule
Summation       & \bf 13.2         & \bf 13.5      & \bf 2.3        & \bf 4.7        & \bf 0.79        \\
Concatenation   & 13.0         & 13.3      & 3.6        & 6.1        & 0.83      \\
\bottomrule
\end{tabular}
\end{center}
\end{table}

\subsection{Effect of transformer layer components}
\label{sec:a-tl-c}

The transformer layer contains two components: MHSA and FFN layers. We have investigated the effectiveness of MHSA and FFN layers on separation performance and inference efficiency in Table~\ref{table:mse}. We used the TDANet with both GA module and LA layers as the control model. When we remove MHSA and FFN layers from GA, the top-layer features of the encoder are used as top-down global attention. We observed that the these layers played a critical role in improving separation performance. When 
adding either MHSA or FFN layer, we observed that the impact of FFN ( 1.3 dB) on performance was more significant than that of MHSA ( 0.7 dB). One possible reason may be that the perceptual field of the top-layer features is already large enough so that the transformer structure, known to be good at modeling long sequences, does not improve separation performance as much. 


\begin{table}[ht]
\caption{Comparison on the importance of MHSA and FFN layers on the LRS2-2Mix dataset.}
\label{table:mse}
\begin{center}
\begin{tabular}{ccccccc}
\toprule
MHSA & FFN    & SI-SNRi (dB) & SDRi (dB) & Params (M) & MACs (G/s) & CPU RTF (s) \\
\midrule
 &    & 11.2         & 11.5      & \textbf{0.2}        & \textbf{2.6}        & \textbf{0.68}        \\

 &      & 11.9         & 12.2      & 1.3        & 3.6        & 0.73        \\
 &  & 12.5         & 12.8      & 1.3        & 3.7        & 0.73        \\

 &  & \textbf{13.2}         & \textbf{13.5}      & 2.3        & 4.7        & 0.79        \\
\bottomrule
\end{tabular}
\end{center}
\end{table}


\subsection{Advantages of top-down attention in the GA module and decoder}
\label{sec:a-tda-ga-de}









We verify the effect of global top-down attention on SuDoRM-RF. We found that adding top-down attention to the SuDoRM-RF can also improve separation performance, as shown in Table~\ref{table:sudoatt}.

\begin{table}[ht]
\caption{Comparison on the importance of top-down attention (TDA) on SuDoRM-RF on the LRS2-2Mix dataset.}
\label{table:sudoatt}
\begin{center}
\begin{tabular}{ccccc}
\toprule
Models & SI-SNRi (dB) & SDRi (dB) & Params (M) & MACs (G/s) \\
\midrule
SuDoRM-RF 1.0x & 11.0 & 11.4 & 2.7 & 4.6 \\
SuDoRM-RF 1.0x + TDA & \textbf{11.9} & \textbf{12.3} & \textbf{2.7} & \textbf{4.6} \\
\bottomrule
\end{tabular}
\end{center}
\end{table}



We add LA layers to the decoder of SuDoRM-RF to verify the importance of the LA layer. We found that adding LA layers can also improve separation performance, as shown in Table~\ref{table:lft}.

\begin{table}[ht]
\caption{Comparison on the importance of LA layers on SuDoRM-RF on the LRS2-2Mix dataset.}
\label{table:lft}
\begin{center}
\begin{tabular}{ccccc}
\toprule
Models & SI-SNRi (dB) & SDRi (dB) & Params (M) & MACs (G/s) \\
\midrule
SuDoRM-RF 1.0x & 11.0 & 11.4 & 2.7 & 4.6 \\
SuDoRM-RF 1.0x + LA & 11.7 & 12.0 & 3.3 & 4.9 \\
\bottomrule
\end{tabular}
\end{center}
\end{table}

\section{TDANet in low latency case}
\label{sec:a-causal}
For the real-time problem, we tried to modify SuDoRM-RF \citep{tzinis2020sudo}, A-FRCNN \citep{hu2021speech} and TDANet to causal versions. We replaced the standard convolutional layers in both models with causal convolutional layers to mask out future information (modified from SuDoRM-RF\footnote{\url{https://github.com/etzinis/sudo_rm_rf/blob/master/sudo_rm_rf/dnn/models/causal_improved_sudormrf_v3.py}}). We supplemented the experiments with SuDoRM-RF (causal), A-FRCNN-16 (causal) and TDANet (causal). 
The results are shown in Table~\ref{table:causal}. The results show that modifying the models to causal versions degrade the separation performance to varying degrees (compare Table~\ref{table:allmodel} and Table~\ref{table:causal}). However, TDANet is still able to obtain better performance than SuDoRM-RF and A-FRCNN.

\begin{table}[ht]
\caption{Comparison on separation performance of different models at low latency on the LRS2-2Mix dataset.}
\label{table:causal}
\begin{center}
\begin{tabular}{ccccc}
\toprule
Models & SI-SNRi (dB) & SDRi (dB) & Params (M) & MACs (G/s) \\
\midrule
SuDoRM-RF 2.5x (causal) & 4.2 & 5.1 & 6.4 & 10.1 \\
A-FRCNN-16 (causal) & 8.9 & 9.5 & 6.1 & 125.3 \\ 
TDANet (causal) & 9.5 & 10.0 & 2.3 & 4.7 \\
\bottomrule
\end{tabular}
\end{center}
\end{table}

\section{Different settings of the hyperparameter }
\label{sec:a-L}
For the hyperparameter , different models have different settings in their original papers. We compare the results of TDANet and the SOTA model Sepformer and lightweight model A-FRCNN with different values of . It is seen from the Table~\ref{table:L} that, for any model, when  is larger, the inference speed is faster, but the separation performance goes down. In addition, for any  value, our proposed TDANet achieves the best results with the highest efficiency.

\begin{table}[ht]
\caption{Comparison on separation performance of models with different 's on the LRS2-2Mix dataset.}
\label{table:L}
\begin{center}
\begin{tabular}{cccccc}
\toprule
Name       & SI-SNRi & SDRi & Params (M) & MACs (G/s) & Inference Time (s) \\
\midrule
\multicolumn{6}{c}{ ms}                                                 \\
\midrule
A-FRCNN-16 & 12.5    & 12.8 & 6.2        & 37.3       & 1.32               \\
Sepformer  & 12.0    & 12.3 & 26.0       & 23.5       & 1.89               \\
TDANet     & 13.2    & 13.5 & 2.3        & 4.7        & 0.79               \\
\midrule
\multicolumn{6}{c}{ ms}                                                 \\
\midrule
A-FRCNN-16 & 12.9    & 13.2 & 6.2        & 61.5       & 2.43               \\
Sepformer  & 12.6    & 12.9 & 26.0       & 49.0       & 3.13               \\
TDANet     & 14.2    & 14.5 & 2.3        & 9.1        & 1.78               \\
\midrule
\multicolumn{6}{c}{ ms}                                                 \\
\midrule
A-FRCNN-16 & 13.0    & 13.3 & 6.1        & 125.3      & 5.32               \\
Sepformer  & 13.5    & 13.8 & 26.0       & 86.9       & 7.55               \\
TDANet     & 14.9    & 15.2 & 2.3        & 18.1       & 2.42               \\
\bottomrule
\end{tabular}
\end{center}
\end{table}

\end{document}
