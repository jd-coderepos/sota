\documentclass[11pt]{article}
\usepackage{lgrind}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage[linesnumbered,algonl,boxed, ruled]{algorithm2e}
\usepackage{amssymb}
\usepackage{color}
\usepackage{mdframed, framed}
\usepackage{caption}
\usepackage{lineno}



\setlength{\textwidth}{6.8in}
\setlength{\textheight}{9.3in}
\setlength{\oddsidemargin}{-0.15in}
\setlength{\evensidemargin}{-0.15in}
\setlength{\topmargin}{-0.8in}
\renewcommand{\proofname}{\emph{Proof}:}
\newcommand{\R}{{\cal R}}
\newcommand{\OO}{{\cal O}}
\newcommand{\KK}{\mathcal{K}}
\newcommand{\LL}{\mathcal{L}}
\newcommand{\BB}{\mathcal{B}}
\newcommand{\FF}{\mathcal{F}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\MM}{\mathcal{M}}
\newcommand{\GG}{\mathcal{G}}
\newcommand{\UU}{\mathcal{U}}
\newcommand{\VV}{\mathcal{V}}
\newcommand{\SSS}{\mathcal{S}}
\newcommand{\PP}{\mathcal{P}}
\newcommand{\CON}{\mbox{Con}}
\newcommand{\JJ}{\mathcal{J}}

\newcommand{\REL}{\mathbf{REL}}
\newcommand{\PSR}{\mathbf{PSR}}
\newcommand{\PREL}{\mathbf{PREL}}



\newtheorem{theorem}[figure]{Theorem}
\newtheorem{fact}[figure]{Fact}
\newtheorem{definition}[figure]{Definition}
\newtheorem{property}[figure]{Property}
\newtheorem{lemma}[figure]{Lemma}
\newtheorem{claim}[figure]{Claim}
\newtheorem{observation}[figure]{Observation}
\newtheorem{corollary}[figure]{Corollary}








\title{A Polynomial Time Algorithm for Finding Area-Universal
\\ Rectangular Layouts}

\date{}
\author{
Jiun-Jie Wang\\
State University of New York  at Buffalo, Buffalo, NY 14260, USA.\\
Email: jiunjiew@buffalo.edu
}
\begin{document}
\maketitle

\begin{abstract}
A rectangular layout  is a rectangle partitioned into
disjoint smaller rectangles so that no four smaller rectangles meet at
the same point. Rectangular layouts were originally used as floorplans in VLSI design
to represent VLSI chip layouts. More recently, they are used in graph
drawing as rectangular cartograms. In these applications, an area
 is assigned to each rectangle , and the actual area of
 in  is required to be . Moreover, some applications
require that we use combinatorially equivalent rectangular layouts
to represent multiple area assignment functions.  is called
{\em area-universal} if any area assignment to its rectangles can be
realized by a layout that is combinatorially equivalent to .

A basic question in this area is to determine if a given plane graph 
has an area-universal rectangular layout or not. A fixed-parameter-tractable
algorithm for solving this problem was obtained in \cite{EMSV12}.
Their algorithm takes  time (where  is the
maximum number of degree 4 vertices in any minimal separation component),
which is exponential time in general case. It is an open problem to find a
true polynomial time algorithm for solving this problem.
In this paper, we describe such a polynomial time algorithm.
Our algorithm is based on new studies of properties of area-universal
layouts. The polynomial run time is achieved by exploring
their connections to the {\em regular edge labeling} construction.

\end{abstract}




\section{Introduction}\label{sec:Intro-universal}
A {\em rectangular layout}  is a partition of a rectangle 
into a set  of disjoint smaller
rectangles by vertical and horizontal line segments so that no
four smaller rectangles meet at the same point.
An {\em area assignment function} of a rectangular layout 
is a function . We say 
is a {\em rectangular cartogram} for  if the area of each
 equals to . We also say 
{\em realizes} the area assignment function .

Rectangular cartograms were introduced in \cite{Ra34} to display
certain numerical quantities associated with geographic regions.
Each rectangle  represents a geographic region. Two regions are
geographically adjacent if and only if their corresponding rectangles
share a common boundary in . The areas of the rectangles
represent the numeric values being displayed by the cartogram.

In some applications, several sets of numerical data must be displayed
as cartograms of the same set of geographic regions. For example,
three figures in \cite{Ra34} are the cartograms of land area,
population, and wealth within the United States. In such cases, we
wish to use cartograms whose underlying rectangular layouts are
{\em combinatorially equivalent} (to be defined later).
Fig \ref{fig:layout} (1) and (2) show two combinatorially
equivalent layouts with different area assignments.
The following notion was introduced in \cite{EMSV12}.

\begin{figure}[t]
\begin{center}
\includegraphics[width=0.45\textwidth, angle =0]{layout}
  \centering
\caption{Examples of rectangular layout: (1) and (2) are
two combinatorially equivalent layouts with different
area assignments. Both are area-universal layouts.
(3) A layout that is not area-universal.}
\label{fig:layout}
\end{center}
\end{figure}
\begin{definition}
A rectangular layout  is {\em area-universal} if any
area assignment function  of  can be realized by a
rectangular layout that is {\em combinatorially equivalent} to .
\end{definition}



A natural question is: which layouts are area-universal?
A nice characterization of area-universal rectangular layouts was
discovered in \cite{EMSV12}:

\begin{theorem}\label{thm:universal}
A rectangular layout  is area-universal if and only
if every maximal line segment in  is a side of at
least one rectangle in .
(A maximal line segment is a line segment in  that cannot
be extended without crossing other line segments in .)
\end{theorem}

In Fig \ref{fig:layout}, the layouts (1) and (2) are area-universal,
but the layout (3) is not. (The maximal vertical line segment 
is not a side of any rectangle.)

For a plane graph , we say a rectangular layout  {\em represents}
 if the following hold: (1) The set of smaller rectangles of 
one-to-one corresponds to the set of vertices of ; and
(2) two vertices  and  are adjacent in  if and only if their
corresponding rectangles in  share a common boundary. In other words,
if  represents , then  is the dual graph of small rectangles in .

Area-universal rectangular layout representations of graphs are useful
in other fields \cite{Mu08}. In VLSI design, for example \cite{YS95},
the rectangles in  represent circuit components, and the common
boundary between rectangles in  model the adjacency requirements
between components. In early VLSI design stage, the chip areas of circuit
components are not known yet. Thus, at this stage, only the relative
positions of the components are considered. At later design stages, the
areas of the components (namely, the rectangles in ) are specified.
An area-universal layout  enables the realization of the area
assignments specified at later design stages. Thus, the ability of
finding an area-universal layout at the early
design stage will greatly simplify the design process at later stages.
The applications of rectangular layouts and cartograms in building design
and in tree-map visualization can be found in \cite{EM79,BHW00}.
Heuristic algorithms for computing the coordinates of a rectangular layout
that realizes a given area assignment function were presented in \cite{WKC88,KS07}.

A plane graph  may have many rectangular layouts. Some of them
may be area-universal, while the others are not. Not every plane graph
has an area-universal layout. In \cite{Ri87}, Rinsma described an
outerplanar graph  and an area assignment to its vertices such that
no rectangular layout realizes the area assignment.
Thus it is important to determine if  has an area-universal layout
or not. Based on Theorem \ref{thm:universal}, Eppstein et al.
 described an algorithm that finds an area-universal
layout for  if one exists. Their algorithm takes 
time, where  is the maximum number of degree 4 vertices in any minimal
separation component. For a fixed , the algorithm runs in polynomial
time. However, their algorithm takes exponential time in general case.

In this paper, we describe the first polynomial-time algorithm for
solving this problem. Our algorithm is based on studies of properties of
area-universal layouts and their connection to the {\em regular edge
labeling} construction.
The paper is organized as follows. In \S \ref{sec:pre-universal}, we introduce
basic definitions and preliminary results. \S \ref{sec:outline} outlines
a Face-Addition algorithm with exponential time that determines if 
has an area-universal rectangular layout. \S \ref{sec:concept} introduces the
concepts of forbidden pairs, -pairs and -triples that are extensively used
in our algorithm. In \S \ref{sec:impl}, we describe how to convert
the Face-Addition algorithm with exponential time to an algorithm with
polynomial time.

\section{Preliminaries}\label{sec:pre-universal}


In this section, we give definitions and important preliminary results.
Definitions not mentioned here are standard. A graph  is called
{\em planar} if it can be drawn on the plane with no edge
crossings. Such a drawing is called a {\em plane embedding} of .
A {\em plane graph} is a planar graph with a fixed plane embedding.
A plane embedding of  divides the plane into a number of connected
regions. Each region is called a {\em face}. The unbounded region is called
the {\em exterior face}. The other regions are called {\em interior faces}.
The vertices and edges on the exterior face are called {\em exterior
vertices and edges}. Other vertices and edges are called {\em interior vertices
and edges}. We use {\em cw} and {\em ccw} as the abbreviation of {\em clockwise}
and {\em counterclockwise}, respectively.

For a simple path  of , the {\em length}
of  is the number of edges in .  is called \emph{chord-free} if
for any two vertices  with , the edge .
A {\em triangle} of a plane graph  is a cycle  with three edges.
 divides the plane into its interior and exterior regions.
A {\em separating triangle} is a triangle in  such that
there are vertices in both the interior and the exterior of .

When discussing the rectangular layout  of a plane graph , we can simplify
the problem as follows. Let  be the four designated exterior vertices of 
that correspond to the four rectangles in  located at the southwest,
northwest, northeast and southeast corners, respectively. Let the
{\em extended graph}  be the graph obtained from  as follows:

\begin{enumerate}
\item Add four vertices  and four edges
 into .
\item
Connect  to every vertex of  on the exterior face between  and 
in cw order.
Connect  to every vertex of  on the exterior face between  and 
in cw order.
Connect  to every vertex of  on the exterior face between  and 
in cw order.
Connect  to every vertex of  on the exterior face between  and 
in cw order.
\end{enumerate}

See Figs \ref{fig:REL} (1) and (2) for an example.
It is well known \cite{KK85} that
 has a rectangular layout  if and only if  has a
rectangular layout , where the rectangles corresponding to
 are located at the west, north, east and south boundary
of , respectively.
Not every plane graph has rectangular layouts. The following
theorem characterizes the plane graphs with rectangular layouts.

\begin{figure}[t]
\begin{center}
\includegraphics[width=0.8\textwidth, angle =0]{REL}
  \centering
\caption{Examples of rectangular layout and . (1) Rectangular
layout ; (2) The graph corresponding to  with
an  ; (3) the graph  of ; (4) the
graph  of .}
\label{fig:REL}
\end{center}
\end{figure}

\begin{theorem}\label{thm:proper} \cite{KK85}
A plane graph  has a rectangular layout  with
four rectangles on its boundary if and only if:
\begin{enumerate}
\item Every interior face of  is a triangle and the exterior face
of  is a quadrangle; and \item  has no separating triangles.
\end{enumerate}
\end{theorem}

A plane graph that satisfies the conditions in Theorem \ref{thm:proper}
is called a {\em proper triangular plane graph}. From now on we
only consider such graphs.

Our algorithm relies heavily on the concept of the \emph{regular edge
labeling} () introduced in . s have also been
studied by Fusy \cite{Fu06,Fu09}, who refers them as {\em transversal
structures}.  are closely related to several other edge
coloring structures of planar graphs that can be used to describe
straight line embeddings of orthogonal polyhedra \cite{Ep10,EM10}.

\begin{definition}\label{def:REL}
Let  be a proper triangular plane graph.
A regular edge labeling   of
 is a partition of the interior edges of  into two
subsets  of directed edges such that:

\begin{itemize}
\item For each interior vertex , the edges incident to 
appear in ccw order around  as follows: a set of
edges in  leaving ; a set of edges in  leaving ;
a set of edges in  entering ; a set of edges in  entering .
(Each of the four sets contains at least one edge.)

\item Let  be the four exterior vertices in
ccw order. All interior edges incident to  are
in  and entering . All interior edges incident to
 are in  and entering . All interior edges incident
to  are in  and leaving . All interior edges
incident to  are in  and leaving .
\end{itemize}
\end{definition}

Fig \ref{fig:REL} (2) shows an example of . (The green solid
lines are edges in . The red dashed lines are edges in .)
It is well known that every proper triangular plane graph  has a
, which can be found in linear time \cite{He93,KH97}. Moreover,
from a  of , we can construct a rectangular layout 
of  in linear time \cite{He93,KH97}. Conversely, if we have a
rectangular layout  for , we can easily obtain a  
of  as follows. For each interior edge  in , we label
and direct  according to the following rules.  Let  and 
be the rectangle in  corresponding to  and  respectively.

\begin{itemize}
\item  If  is located below  in , the edge 
is in  and directed from  to .
\item   If  is located to the right of  in ,
the edge  is in  and directed from  to .
\end{itemize}

The   obtained as above is called the {\em  derived from }.
(See Fig \ref{fig:REL} (1) and (2)).

\begin{definition}
Let  and  be two rectangular layouts of a proper triangular
plane graph . We say  and  are {\rm combinatorially
equivalent} if the s of  derived from  and
from   are identical.
\end{definition}

Thus, the s of  one-to-one correspond to
the combinatorially equivalent rectangular layouts of .
We can obtain two directed subgraphs  and  of  from
an   as follows.

\begin{itemize}
\item The vertex set of  is . The edge set of  consists of
the edges in  with direction in , and the four exterior edges
directed as: .
\item The vertex set of  is . The edge set of  consists of
the edges in  with direction in , and the four exterior edges
directed as: .
\end{itemize}

Fig \ref{fig:REL} (3) and (4) show the graph  and 
for the  shown in Fig \ref{fig:REL} (2).
For each face  in , the boundary of  consists of two
directed paths. They are called the two {\em sides} of .
Each side of  contains at least two edges. Similar properties
hold for the faces in  \cite{Fu06,Fu09,He93,KH97}.

\begin{definition}
A   of  is called {\em slant}
if for every face  in either  or , at least one
side of  contains exactly two directed edges.
\end{definition}

Theorem \ref{thm:universal} characterizes the area-universal layouts in terms
of maximal line segments in . The following lemma characterizes
area-universal layouts in term of the  derived from .

\begin{lemma}\label{lemma:slant}
A rectangular layout  is area-universal if and
only if the   derived from  is slant.
\end{lemma}
\begin{proof}
Note that each face in  (, respectively) corresponds
to a maximal vertical (horizontal, respectively) line
segment in . (In the graph  in Fig
\ref{fig:REL} (3), the face  with the vertices 
corresponds to the vertical line segment that is on the left side
of the rectangle  in Fig \ref{fig:REL} (1)).

Assume  is area-universal. Consider a face  in . Let
 be the maximal vertical line segment in  corresponding to
. Since  is area-universal,  is a side of a rectangle
 in . Without loss of generality, assume  is to the left
of . Then the left side of the face  consists
of exactly two edges. Thus  satisfies the slant property.
Similarly, we can show  also satisfies the slant property.

Conversely, assume  is a slant . The above argument can be
reversed to show that  is area-universal.
\end{proof}

The  shown in Fig \ref{fig:REL} (2) is not slant because
the slant property fails for one  face.
So the corresponding layout shown in Fig \ref{fig:REL} (1)
is not area-universal. By Lemma \ref{lemma:slant}, the problem of
finding an area-universal layout for  is the same as the problem
of finding a slant  for . From now on, we consider the
latter problem and  always denotes a proper triangular plane graph.

\section{Face-Addition Algorithm with Exponential Time}\label{sec:outline}

In this section, we outline a Face-Addition procedure that generates
a slant   of  through a sequence of steps.
The procedure starts from the directed path consisting of two edges
. Each step maintains a partial
slant  of . During a step, a face  of  is added to the
current graph, resulting in a larger partial slant . When  is
added, its right side is already in the current graph. The edges on the
left side of  are placed in  and directed upward. The edges
of  in the interior of  are placed in  and directed to the
left. The process ends when the left boundary  is reached. With this informal description in mind,
we first introduce a few definitions. Then we will formally
describe the Face-Addition algorithm (which takes exponential time).

\begin{figure}[t]
\begin{center}
\includegraphics[width=0.4\textwidth, angle =0]{gadget}
\centering
\caption{(1)  a fan  has the back boundary  and the front boundary ;
(2)  a mirror fan  has the back boundary  and the front boundary .}
\label{fig:gadget}
\end{center}
\end{figure}

Consider a face  of  added during the above procedure.
Because we want to generate a slant  , at least one side of
 must be a path of length 2. This motivates the following definition.
Figs \ref{fig:gadget} (1) and (2)
show examples of a fan and a mirror fan, respectively.

\begin{definition}\label{def:gadget}
Let  be three vertices of  such that
 and  are two neighbors of  and .
Let  be the path consisting of the neighbors 
of  in cw order between  and .
Let  be the path consisting of the neighbors 
of  in ccw order between  and . Note that since  has no
separating triangles, both  and  are chord-free.
\begin{enumerate}

\item The directed and labeled subgraph
of  induced by the vertices 
is called the {\em fan at} 
and denoted by , or simply .

\begin{itemize}
\item The \emph{front boundary} of , denoted by ,
consists of the edges in  directed from  to  in cw order.
The edges in  are colored green.

\item The \emph{back boundary} of , denoted by ,
consists of two directed edges  and .
The edges in  are colored green.

\item The \emph{inner edges} of , denote by , are the edges
between  and the vertices  that are on the path
. The inner edges are colored red and directed away from .
\end{itemize}

\item The directed and labeled
subgraph of  induced by the vertices 
is called the {\em mirror fan at} 
and denoted by , or simply .

\begin{itemize}
\item The \emph{front boundary} of , denoted by ,
consists of two directed edges  to .
The edges in  are colored green.

\item The \emph{back boundary} of , denoted by , consists
of the edges in  directed from  to  in ccw order.
The edges in  are colored green.

\item The \emph{inner edges} of , denote by , are the edges
between  and the vertices  that are on the path
. The inner edges are colored red and directed into .
\end{itemize}
\end{enumerate}
\end{definition}

Both  and  are
called a {\em gadget at }. We use  to
denote either of them. The vertices other than  and 
are called the {\em internal vertices} of the gadget.
If a gadget has only one inner edge, it can be called either
a fan or a mirror fan. For consistency, we call it a fan.
We use  to denote the {\em initial fan}, and
 to denote the {\em final mirror fan}.
The following observation is clear:

\begin{observation}\label{obs:slant}
For a slant , each face  of  is a gadget of .
\end{observation}

The  shown in Fig \ref{fig:REL} (2) is generated by adding the
gadgets: , ,
, , , .
The following lemma is needed later.

\begin{lemma}\label{lemma:number}
The total number of gadgets in  is at most .
\end{lemma}

\begin{proof}
Let  denote the degree of the vertex  in . For each
, there are at most 
gadgets with  as its middle element. Thus the total number of gadgets
of  is at most
.
\end{proof}

\begin{definition}\label{def:cut}
A \emph{cut}  of  is a directed path from  to  that is
the left boundary of the subgraph of  generated during the
Face-Addition procedure. In particular,
 denotes the {\em initial cut} and
 denotes the {\em final cut}.
\end{definition}

Let  be a cut of . For any two vertices  of , 
denotes the subpath of  from  to . The two paths  and 
enclose a region on the plane. Let  denote the subgraph
of  induced by the vertices in this region (including its boundary).

Consider a cut  generated by Face-Addition procedure
and a gadget . In order for Face-Addition procedure
to add  to , the following conditions must be satisfied:
\begin{description}
\item[A1:] no internal vertices of  are in ; and
\item[A2:] the back boundary  is contained in ; and
\item[A3:]  is {\em valid} for  (the meaning of {\em valid}
will be defined later).
\end{description}

If  satisfies the conditions A1, A2 and A3, Face-Addition
procedure can add  to the current graph  by {\em stitching}
 with the corresponding vertices on . (Intuitively we are
{\em adding a face of }.) Let  denote the new subgraph
obtained by adding  to . The new cut of ,
denoted by , is the concatenation of three subpaths
.

The conditions A1 and A2 ensure that  is a cut. Any gadget
 satisfying A1 and A2 can be added during a step while still maintaining
the slant property for . However, adding such a  may destroy the
slant property for  faces. The condition A3 that  is {\em valid}
for  is to ensure the slant property for  faces. (The 
shown in Fig \ref{fig:REL} (2) is not slant. This is because the gadget
 is not valid, as we will explain later.)
This condition will be discussed in \S \ref{sec:concept}.

After each iteration of Face-Addition procedure, the edges of
the current cut  are always in  and directed from 
to . All  faces  in  are {\em complete}
(i.e. both sides of  are in ). Some  faces in
 are complete. Some other  faces  in  are
{\em open}. (i.e. the two sides of  are not completely in .)

\begin{definition}
Any subgraph  generated during the execution of
Face-Addition procedure is called a {\em partial slant}
 of , which satisfies the following conditions:
\begin{enumerate}
\item Every complete  and  face in  satisfies
the slant  property.
\item For every open  face  in , at least one
side of  has exactly one edge.
\end{enumerate}
\end{definition}

The intuitive meaning of a partial slant   is that it is
{\em potentially possible to grow} a complete slant  of  from
. The left boundary of a partial slant   is called
the {\em cut associated with}  and denoted by .

\begin{definition}
\label{def:G-tilde}
\begin{enumerate}
\item  denotes the set of all partial slant s of 
that can be generated by Face-Addition procedure.
\item .
\end{enumerate}
\end{definition}

Observe that every slant   of  is in . This is because
 is generated by adding a sequence of gadgets 
to the initial gadget .
So if we choose this particular  during the th step, we will get 
at the end. Thus  has a slant  if and only if .
Note that Face-Addition procedure works only if we know the correct
gadget addition sequence. Of course, we do not know such a sequence.
The Face-Addition algorithm, described in Algorithm
\ref{alg:face-addition}, generates all members in .

\begin{algorithm}[htb]
\caption{Face-Addition algorithm with Exponential Time}
\label{alg:face-addition}

Initialize ,
and \;

\Repeat{no such  and  can be found}
{
Find a gadget  of  and an  such that
the conditions A1, A2 and A3 are satisfied for  and \;

Add  into ,
and add the partial slant   into \;
}

 has a slant  if and only if the final gadget \;
\end{algorithm}

Because  can be exponentially large, Algorithm
\ref{alg:face-addition} takes exponential time.

\section{Forbidden Pairs, -Pairs, -Triples, Chains and Backbones}
\label{sec:concept}

In this section, we describe the conditions for adding a gadget to a
partial slant  , while still keeping the slant
 property for  faces. (In other words, the condition A3.)

\subsection{Forbidden Pairs}\label{sec:forbidden}

Consider a  and its associated cut .
Let  be an edge of . We use  to denote the
open  face in  with  as its open left boundary.
The {\em type} of  specifies the lengths of the
lower side  and the upper side  of :

\begin{itemize}
\item Type (1,1):  and .
\item Type (1,2):  and .
\item Type (2,1):  and .
\item Type (2,2):  and .
\end{itemize}

Note that the type of every open  face in a partial slant
 cannot be . Based on the properties of , we
have the following (see Fig \ref{fig:face-type}):

\begin{observation}
Let  and  be an edge on .
\begin{itemize}
\item If  is the last edge of  of a fan or a mirror fan ,
the type of  is (2,1).
\item If  is a middle edge of  of a fan ,
the type of  is (1,1).
\item If  is the first edge of  of a fan or a mirror fan ,
the type of  is (1,2).
\end{itemize}
\end{observation}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.40\textwidth, angle =0]{face-type}
  \centering
\caption{The types of open  faces:
(1) Faces defined by edges on the front boundary of a fan;
(2) Faces defined by edges on the front boundary of a mirror fan.}
\label{fig:face-type}
\end{center}
\end{figure}
\vspace{-0.25in}

\begin{definition}\label{def:forbidden}
A pair  of two gadgets of  is called a {\em forbidden pair} if either
(1) the first edge of  is the last edge of ; or
(2) the last edge of  is the first edge of .
\end{definition}

\begin{lemma}\label{lemma:forbidden}
If a partial   contains a forbidden pair ,
then  is not slant.
\end{lemma}

\begin{proof}
Case 1: Suppose the first edge  of  is the last edge
of  (see Fig \ref{fig:forbbiden} (1)). Let  be the
first edge of . The type of  is
 (regardless of whether  is a fan or a mirror fan). Note
that  extends .
The length of the upper side of  is increased
by 1. Thus the type of  is  and
the slant property for  face fails.

Case 2: Suppose the last edge  of  is the first edge
of  (see Fig \ref{fig:forbbiden} (2)). Let  be
the last edge of . The type of 
is  (regardless of whether  is a fan or a mirror fan).
Note that  extends .
The length of the lower side of  is increased
by 1. Thus the type of  is  and
the slant property for  face fails.
\end{proof}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.38\textwidth, angle =0]{forbidden-pairs2}
  \centering
\caption{The proof of Lemma \ref{lemma:forbidden}: (1)  is
a fan; (2)  is a mirror fan.}
\label{fig:forbbiden}
\end{center}
\end{figure}


In the   shown in Fig \ref{fig:REL} (2), 
is a forbidden pair. So  is not a slant .

\subsection{The Condition A3}

The following lemma specifies a necessary
and sufficient condition for adding a fan into , and
a sufficient condition for adding a mirror fan into .

\begin{lemma}\label{lemma:valid-fan}
Let  and  be its associated cut.
Let  be a gadget and . Suppose that the conditions
A1 and A2 are satisfied for  and .
\begin{enumerate}
\item A fan  can be added to  (i.e.  satisfies the condition A3)
{\bf if and only if} there exists a gadget  such that
.
\item A mirror fan  can be added to  (i.e.  satisfies the
condition A3) {\bf if} there exists a gadget  such that
.
\end{enumerate}
\end{lemma}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.95\textwidth, angle =0]{feasibl-2}
\centering
\caption{(1) and (2) open faces defined by edges on the front boundary of a fan ;
(3) and (4) open faces defined by edges on the front boundary of a mirror fan .}
\label{fig:feasible}
\end{center}
\end{figure}
\vspace{-0.2in}

\begin{proof} If part of (1): Suppose there exists a gadget 
such that .
(Figs \ref{fig:feasible} (1) and (2) show two examples. In Fig
\ref{fig:feasible} (1),  is a fan. In Fig \ref{fig:feasible} (2),
 is a mirror fan). Let  be the edges in .
Let  be the two edges in . Let  be
the new cut after adding . For each , the type
of  is .

\begin{itemize}
\item  extends , and
add 1 to the length of the upper side of .
\item  extends , and
add 1 to the length of the lower side of .
\end{itemize}

Regardless of where  are located on , and regardless
of whether  is a fan (see Fig \ref{fig:feasible} (1)) or a mirror fan
(see Fig \ref{fig:feasible} (2)), the type of 
is ; and the type of  is .
Thus .

Only if part of (1): Suppose that there exists no gadget 
such that . Let  be the two
edges of .  must be on the front boundary
of some gadget  in .  must be on the front boundary of some
gadget  in . Clearly .
(If , we would have ).
Then either  or  must be a forbidden pair.
By Lemma \ref{lemma:forbidden},  cannot be added to .

(2) Let  be a mirror fan. Suppose there exists a gadget 
such that  (see Fig \ref{fig:feasible} (3)).
Similar to the proof of the if part of (1), we can show
.
\end{proof}

By Lemma \ref{lemma:valid-fan}, the only way to add a fan  to 
is by the existence of a gadget  such that . For a mirror fan , there is another
condition for adding  to  which we discuss next.

Let  be the vertices of  from lower
to higher order. Let  and  be the first and the last edge of .
Imagine we walk along  from  to . On the right
side of , we pass through a sequence of gadgets in  whose front
boundary (either a vertex or an edge) touches . Let
,
where  and ,
denote this gadget sequence. Note that some gadgets in
 may appear multiple times in the sequence.
(See Fig \ref{fig:chain} (1) for an example.)

Consider a mirror fan  to be added to . Note that 
is a subsequence of . Let  and  be the lowest and the highest vertex
of . Let  be the first edge and  be the last edge of . When walking
along  from  to , we pass through a subsequence
of the gadgets in  on the right of .
Let 
denote this gadget subsequence, where:

\begin{itemize}
\item  is the gadget such that .
\item  is the gadget such that .
\end{itemize}

In Fig \ref{fig:chain} (1), if we add a mirror fan  with
, then .


\begin{lemma}\label{lemma:mirror-fan}
Let  and  be its associated cut.
Let  be a mirror fan and . Suppose that the conditions
A1 and A2 are satisfied for  and . Let
.
Then  can be added to  (i.e.  satisfies the condition A3)
{\bf if and only if} neither  nor  is a forbidden pair.
\end{lemma}

\begin{proof}
First suppose that  can be added to  to form a larger partial slant .
Then, by Lemma \ref{lemma:forbidden}, neither  nor 
is a forbidden pair.
Conversely, suppose that neither  nor 
is a forbidden pair. Let  be the edges of .
The type of  is either  or .
The type of  is either  or .
(Fig \ref{fig:feasible} (4) shows an example.)
Let  be the two edges in .
After adding  to , the types of  and
 becomes  and , respectively.
They still keep the slant property for  faces. Moreover, for each
edge ,  becomes
a valid complete  face after adding  to . Hence
  is a partial slant  of .
\end{proof}

\subsection{Connections, Chains and Backbones}
\label{subsec:chains}

Given an  and a gadget , it is straightforward to check
if the conditions in Lemmas \ref{lemma:valid-fan} and \ref{lemma:mirror-fan}
are satisfied. However, as described before, maintaining the set 
requires exponential time. So we must find a way to check the conditions in
Lemmas \ref{lemma:valid-fan} and \ref{lemma:mirror-fan} without explicit
representation of .

Consider two  such that  but
.
Clearly this implies .
By Lemmas \ref{lemma:valid-fan} and \ref{lemma:mirror-fan},
a gadget  can be added to  if and only if  can be added to .
Thus, whether  can be added to an  is completely determined
by the structure of gadgets in . There may be exponentially
many  with . Instead of
keeping information of all these , we only need to keep the information
of the structure of . This is the main idea for converting
Algorithm \ref{alg:face-addition} to a polynomial time algorithm.
In order to describe the structure of ,
we need the following terms and notations.

\begin{definition}\label{def:connection}
Let  and  be a gadget with .
\begin{itemize}
\item If  contains only one gadget , and the
conditions A1, A2 and A3 are satisfied, then  is called a
{\em -pair}. We use  to denote a -pair.

\item If  contains at least two gadgets, and the conditions
A1, A2 and A3 are satisfied, then  is called a {\em -triple}.
We use  to denote a {\em -triple}.

\item A -pair  or a -triple  is
called a {\em connection} and denoted by .

\item For a connection ,
where ,
the {\em front boundary} of , denoted by 
or , is the concatenation of the paths
, , .

\item For a connection , where
,
, the {\em front boundary} of , denoted by
 or , is the concatenation of the paths
.
\end{itemize}
\end{definition}




\begin{figure}[t]
\begin{center}
\includegraphics[width=0.5\textwidth, angle =0]{chain-2}
  \centering
\caption{(1)  is obtained by adding gadgets
, in this order, to .
;
 and
.
The pair  belongs to the -pair ,
the triple  belongs to the -triple
, the triple  belongs to the
-triple ,
the pair  belongs to the -triple ,
the pair  belongs to the -pair  and
the pair  belongs to the -pair .
(2) The -pair  is a fractional connection
with two pockets:  is bounded by  and 
and  is bounded by  and .
}
\label{fig:chain}
\end{center}
\vspace{-0.2in}
\end{figure}
It is tempting to think that if all gadgets in  have
been added into , then  has been constructed. Unfortunately,
this is not true. In order to form , the gadgets in 
must have been added to  in the following way: When walking
along  from  to , the gadgets in 
form a sequence 
of connections such that each consecutive pair  or
triple  of gadgets belong to a 
(); and each consecutive pair 
share a common gadget in .
(See Fig \ref{fig:chain} (1) for an illustration).

Note that when the pair  and the pair 
belong to the same connection , it means  and 
are the same gadget and  is a -pair.
In this case, we keep only one  in the sequence
.
As seen in Fig \ref{fig:chain} (1), in addition to these connections
 (), some gadget pairs (or triples) that are not
consecutive in  may also form additional connections.
(In Fig \ref{fig:chain} (1), the gadgets  and  are not consecutive
in . But they form a -pair ). Let 
denote the set of connections formed by the gadgets in .
(By this definition, each  has at least two
gadgets in ).
It is the structure of  that determines if a new gadget  can be
added to  or not. In general, the connections in  cannot be
described as a simple linear structure. To describe it precisely, we need the
following definitions.

Consider a connection . If 
is a contiguous subpath of ,  is called a {\em contiguous
connection}. If not,  is called a {\em fractional connection}.
(In Fig \ref{fig:chain} (1), the -pair  is a
fractional connection.
Because the cut  are
 and  and , they are not a contiguous subpath of .)
Consider a fractional connection
. Let  and  be the lowest and the highest vertices
of  respectively. When walking along 
from  to , we encounter  multiple times.
The subpath  can be divided into a number of subpaths that are
alternatively on , not on ,
on . There exist at least two vertices  in
 such that .
For each such pair of vertices , the interior region bounded by
the subpaths  and  is called a {\em pocket},
denoted by , of .
Fig \ref{fig:chain} (2) shows a fractional connection  (the -pair
) with two pockets  and .

A connection  is called
\emph{maximal} if it is not contained in any pocket of .
A maximal connection can be either contiguous or
fractional. A non-maximal connection  is either
completely contained in some pocket  formed by a subpath of 
and a maximal fractional connection  (namely all gadgets
of  are contained in ); or partially contained in 
(namely some gadget of  is contained in 
and some gadget of  is shared with ).
(In Fig \ref{fig:chain} (2), the -pair  and the -triple
 are partially contained in the pocket . The -triple
 and the -pair  are completely contained in
). Note that a pocket may contain other smaller pockets. In general,
the pockets of  are nested in a forest-like structure.

The way to deal with fractional connections is very similar to contiguous connections.
Hence in the following paragraphs, we will assume there are no fractional connections.

\begin{definition}\label{def:lessthan}
Let two gadgets  belong to a connection .
We say  { \em precedes}  on  and write
 if the following conditions hold:
(1)  is contiguous on ;
(2) When walking along , we encounter the gadget 
before .
\end{definition}

Depending on the types of connections and their positions on a cut ,
there are five cases for the relation .
(They are shown in Fig \ref{fig:order}.)



\begin{figure}[t]
\begin{center}
\includegraphics[width=0.75\textwidth, angle =0]{order}
  \centering
\caption{(1) Case 1:  is a  and
;
(2) Case 2:  is a  and
;
(3) Case 3:  is a  and
;
(4) Case 4:  is a  and
;
(4) Case 5:  is a  and
.}

\label{fig:order}
\end{center}
\end{figure}

\begin{definition}\label{def:chain}
Given a partial slant   with its associated cut ,
a sequence of gadgets  in 
is called a chain of  and denoted by \emph{chain}()
if the following conditions hold:
\begin{enumerate}
\item  and

\item for each ,
either  or  belongs to
a connection .
\end{enumerate}
\end{definition}

In Fig \ref{fig:chain} (1),

is a chain of  where we have the -pair ,
the -triple ,
the -triple ,
the -triple ,
the -pair 
and
the -pair .









Because the way a partial slant   is constructed,
the following property is clear.
\begin{property}\label{prop:chain}
Given a partial slant   with its associated cut ,
the 
is a chain of .
\end{property}













Given a partial slant   with its associated cut ,
if we can add a gadget  to ,
then it implies that back boundary  of  is a part of .
Let  be a subsequence of 
consisting of gadgets in  that touch .
We can define an order  which is similar to .


\begin{definition}\label{def:lessthan-L}
Given a mirror fan  with ,
let two gadgets  belong to a connection .
We say  { \em precedes}  on  and write
 if the following conditions hold:
(1)  is contiguous on ;
(2) When walking along , we encounter the gadgets 
before .
\end{definition}


\begin{definition}\label{def:backbone}
Let  be a mirror fan with . A 
consists of a sequence of gadgets 
in  such that
\begin{enumerate}
\item ,

\item for each ,
either  or  belongs to
a connection  and

\item Neither  nor  is a forbidden pair.
\end{enumerate}
\end{definition}

In Fig \ref{fig:chain} (1), consider the mirror fan  with .
We have: 
 where  is the
-pair ,
 is the -pair  and
.


Based on above discussion, we can restate Lemma \ref{lemma:mirror-fan}
as follows:

\begin{lemma}\label{lemma:valid-mirror-fan}
Let  and . Let  be a mirror fan with
. Suppose that the conditions A1 and A2 are satisfied for
 and . Let .
Then  forms a -triple (i.e.  satisfies the
condition A3) if and only if there exists a 
consisting of gadgets in  and connections in .
Note that each gadget and connection in 
belong to the same partial slant  .
\end{lemma}




\section{Face-Addition Algorithm with Polynomial Time}\label{sec:impl}

We will present our polynomial time Face-Addition algorithm in this section.
In \S \ref{sec:algorithm},
we will describe the algorithm to find a superset of chains.
In \S \ref{sec:triple},
we will give more details of key procedures in \S \ref{sec:algorithm}.
In \S \ref{sec:conflict-rel},
we will present an example that Algorithm \ref{alg:efficient} may
combine two subchains of two different partial s into a chain which only
satisfies the order  in Property \ref{prop:chain}
(there exist gadgets coming from different chains).
In \S \ref{sec:backtrack-conflict-gadgets},
we will describe a backtracking algorithm to check
whether whether a chain in the superset of chains constructed
by Algorithm \ref{alg:efficient} corresponds
to a slant  or not.
Also, we will give runtime analysis of the backtracking algorithm.


\subsection{Polynomial Time algorithm}\label{sec:algorithm}

The polynomial time Face-Addition algorithm is described in
Algorithm \ref{alg:efficient}.

\begin{algorithm}[ht]
\caption{Face-Addition Algorithm with Polynomial Time}
\label{alg:efficient}


\KwIn {A proper triangular plane graph }



Set  and \;

\Repeat{no such gadget  can be found}
{
Find a gadget  such that:\

\begin{description}
\item [either:] there exist v--pairs 
with  (v--pairs are defined later)\;

add  into  (if it's not already in
; add all such v--pairs  into \;

\item[or:]  is a mirror fan and there exist v--triples
 with  (v--triples
are defined later)\;

add  into  (if it's not already
in ); add all such v--triples  into \;
\end{description}
}

\uIf { is not in }
{
 has no slant \;
}
\Else{
Backtrack each v-chain of  (v-backbone of ) to
check whether  corresponds a slant 
in Algorithm \ref{alg:backtrack-conflict-gadgets};
}
\end{algorithm}

Algorithm \ref{alg:efficient} emulates the operations of Algorithm
\ref{alg:face-addition} without explicitly maintaining the set .
Instead, it keeps two sets: (1) a set  of gadgets of 
which contains the gadgets in the set  defined in \S
\ref{sec:outline}, and (2) a set  of connections of 
which contains the connections in the set  defined in \S
\ref{subsec:chains}.
In \S \ref{subsec:chains}, many concepts (cut, chain, backbone  etc.)
were defined referring to a .
We now need counterparts of these concepts without referring to
a specific . For a concept {\em x} defined previously, we will use
{\em virtue x} or simply {\em v-x} for the counterpart of .
(For example, v-cut for {\em virtue cut}, v-chain for {\em virtue chain},
v-backbone for {\em virtue backbone}).
A v--pair (v--triple, respectively) is similar to a -pair
(-triple, respectively) but without referring to a specific .
Whenever Algorithm \ref{alg:face-addition} adds a gadget  to
 through a -pair (or a -triple, respectively),
Algorithm \ref{alg:efficient} adds  into  and add a
corresponding v--pair (or v--triple, respectively) into .

Initially,  is empty and  contains only the
initial fan . In each step, the algorithm
finds either new v--pairs  with ;
or new v--triples  with .
In either case, it adds  into .
But instead of using a , Algorithm \ref{alg:efficient}
relies on the information stored in  and  to
find v--pairs and v--triples.

Fix a step in Algorithm \ref{alg:efficient} and consider the sets
 and  after this step.
Any simple path  in  from  to  is called a {\em v-cut}
of . A gadget pair  is called a {\em v--pair} if
 and .
For a v-cut , define:


Let  and  be the first and the last edge of .
A subset of gadgets 
is called a {\em v-support} of  if the following conditions hold:
\begin{itemize}
\item The gadgets in  can be arranged into a sequence 
such that
,  and, when walking along
 from  toward , we encounter these gadgets in this order.

\item Any two (or three) consecutive gadgets 
(or ) belong to a connection in .
\end{itemize}

If a set  of connections formed by the gadgets in a v-support of 
satisfies the structure property described in Definition \ref{def:chain},
 is called a {\em v-chain} of .  Clearly, any chain is also a
v-chain.

Let  be a mirror fan with . Let  and  be
the lowest and the highest vertex of , and  and 
the first and the last edge of , respectively. Define:


A subset of gadgets 
is called a {\em v-support} of  if the following conditions hold:
\begin{itemize}
\item The gadgets in  can be arranged into a sequence  such that
,  and, when walking along 
from  toward , we encounter these gadgets in this order.

\item Any two (or three) consecutive gadgets 
(or ) belong to a connection in .
\end{itemize}

If a set  of connections formed by the gadgets in a v-support of 
only satisfies the order property  and
the third property described in Definition \ref{def:backbone},
 is called a {\em v-backbone} of . If there is a
v-, we call  a {\em v--triple}.
Both v--pairs and v--triples are called v-connections.

First, we bound the number of loop iterations in Algorithm \ref{alg:efficient}.
By Lemma \ref{lemma:number}, the number of gadgets in  is at most
. So the number of v--pairs is at most  and the
number of v--triples is at most . Hence  contains
at most  elements. Since each iteration adds at least either
a v--pair or a v--triple into , the number of
iterations is bounded by .

We need to describe how to perform the operations in the loop body,
which is clearly dominated by finding v--pairs and
finding v--triples. Given two gadgets ,  and the sets
 and , it is easy to check if 
is a v--pair (i.e.  and )
in polynomial time. However,
finding v--triples ( is
much more difficult. In \S \ref{sec:triple}, we show this can be done,
in polynomial time, by finding a v- consisting of
connections in . This will establish the polynomial run time of
the repeat loop of Algorithm \ref{alg:efficient}.
\begin{lemma}\label{lemma:sufficient}
Let  be the set of all v-backbones of .
(Because  is a v-cut,
each v-backbone of  is actually a v-chain of .)
For each  with its associated cut ,
there exists a v-chain  (which is a v-backbone
of ) generated by Algorithm \ref{alg:face-addition}
such that .
\end{lemma}

\begin{proof}
For each mirror fan  with ,
if  is in some partial slant ,
then its backbone follows the order .
So we have  and
.
Since we use the two supersets  and 
of  and  to find v-backbones of  (chains of ),
we immediately have:


\end{proof}


In this subsection, we have described Algorithm \ref{alg:efficient}
which constructs
(1) the set  of v-chains such that
chain() of each partial   with its
associated cut  is included in ,
(2) the set  of v-connections containing
each connection ,
(3) the set  of gadgets containing
each gadget .

Lemma \ref{lemma:sufficient} states that any chain is a v-chain.
But the reverse is not necessarily true.
In \S \ref{sec:conflict-rel}, we provide
an example that a v-chain
is not equal to the chain of
the associated cut of any partial slant .
Thus we need to check whether a v-chain constructed by
Algorithm \ref{alg:efficient} is really
a chain of a slant   of .
In \S \ref{sec:backtrack-conflict-gadgets},
we describe a backtracking algorithm to detect all such v-chains.

\subsection{Algorithm for Finding v-Backbones and v--triples}
\label{sec:triple}

Consider a gadgets  with the back boundary .
Let  and  be the lowest and the highest vertex of ,
 and  the first
and the last edge of . In this subsection,
we show how to check whether  is a v--triple or not
in polynomial time.
By the definition of v--triples,
this is equivalent to finding
s by using the v-connections in .

Let  be the set of gadgets in  that can be in
any . From the conditions described in
Definition \ref{def:backbone},  contains the gadgets
 that satisfy the following conditions:

\begin{itemize}
\item The front boundary of  intersects  and  belongs to
some v-connection .

\item the front boundary of  contains ;
and  is not a forbidden pair.

\item the front boundary of  contains ;
and;
and  is not a forbidden pair.
\end{itemize}







To determine which gadgets in  can form
a v-backbone of , we construct a directed acyclic graph
  as follows:

\begin{definition}\label{gra:L}
Given a triple  with ,
the \emph{backbone graph}  of  is defined as follows:
\begin{itemize}

\item  and

\item 


belongs to a v-connection  and
 is contiguous on  

\end{itemize}
\end{definition}
A \emph{source} (\emph{sink}, respectively) vertex
has no incoming (outgoing, respectively) edges in .
The intuitive meaning of a directed path 
from the source to the sink
is that  corresponds to a v-backbone of  and
for each vertex ,  corresponds a gadget in a v-backbone
and  is equal to the intersection  of 
and the front boundary of .
Moreover, for different v--triples of 
,
we have vertices  and 
in  to represent 
such that  and  represent different subpaths in :
one is

and the other one is

where the vertex  represents the mirror fan in 
and  represents the mirror fan in .

\begin{lemma}\label{lemma:GL}
 is acyclic and can be constructed in  time.
\end{lemma}

\begin{proof}
Consider a . Knowing , we can easily determine
if  is in  in constant time. So we can identify
the set  in  time.
For two vertices  and  in , the edge
 exists if and only if the following
two conditions are satisfied:
(1)  and  belong to some v-connection in ;
(2)  is contiguous on ; and
(2) when walking along  upwards, we encounter the gadgets 
before .
These two conditions can be easily checked in constant time.
So the set  can be determined
in  time. Thus  can be constructed
in  time.

The edge directions of  are defined by the relation .
Since  is acyclic,  is acyclic.
\end{proof}



\begin{lemma}\label{lemma:feasibility}
Given a triple  with , let  be the graph
defined in Definition \ref{gra:L}.

\begin{enumerate}
\item Each directed path from the source to the sink
in  corresponds to the v--triple .





\item The v--triple  corresponds to a set of
directed paths from  to  in .

\end{enumerate}
\end{lemma}

\begin{proof}
Statement 1.
Consider any directed path  from the source  to the sink
 in .
Since each directed edge  in 
follows the order  on ,
each directed path from  to  is a v-backbone of 
and  is a v--triple.

Statement 2: Consider a v--triple . This means
that there exists a v-backbone
 on .
Because each  on  is a directed edge 
in ,
we have that

is a directed path from  to  in .

Note that there may exist multiple paths in  from  to
. All these paths correspond to the same v--triple
. The intuitive meaning of this fact is as follows.
When we add  via the v--triple , even though
the gadgets  and  are fixed, the v-connections and gadgets in the
s between  and 
may be different. But as long as they form a valid
, we can add .
\end{proof}


The following Algorithm \ref{alg:triple}  finds
v--triples  by finding s.

\begin{algorithm}[htb]
\caption{~Find v--triples}
\label{alg:triple}

\KwIn {A triple  with  and the set  of
v-connections}

From the connections in , identify the set \;

Construct the directed graph  as in Definition \ref{gra:L}\;

By using Lemma \ref{lemma:feasibility},
return whether  is --triple or not\;
\end{algorithm}

\begin{theorem}\label{thm:time}
Given a gadgets triple ,
Algorithm \ref{alg:triple} can successfully test whether 
is a v--triple  in polynomial time.
\end{theorem}

\begin{proof}
The correctness of the algorithm follows from Lemma
\ref{lemma:feasibility}. By Lemma \ref{lemma:GL}, the steps
1 and 2 can be done in polynomial time.


Step 3:
Since  is acyclic,
we can use breadth-first search to find whether
 is reachable from .
Then  is
a v--triple if and only if
 is reachable from .
This step is carried out by calling breadth-first search which
takes polynomial time.
So the total time for this step is polynomial.

Note that the total number of source to sink paths in  can be exponential.
However, we only
need to find one path from  to .

\end{proof}

\subsection{An Example that A v-Chain Does Not Have
A Slant }\label{sec:conflict-rel}
In this subsection, we present an example to show
why a v-chain defined in the last subsection does not necessarily
have a corresponding partial slant .
Imagine that we have two v-chains  and .
Suppose that  can be partitioned into
 and
 can be partitioned into

such that ,
then we may have another two v-chains

and .
However, both of the two v-chains can't correspond any partial slant .
Fig \ref{fig:conflict} (3) shows a v-chain 
which can't have a corresponding partial slant  where
 from  and  from  shares a common gadget .








\begin{figure}[t]
\centering
\includegraphics[width=0.85\textwidth, angle =0]{conflict}
\caption{(1) is a partial slant   which
consists of gadgets ;
(2) is a partial slant   which
consists of gadgets ;
(3)  is a v-chain where
 is a subchain of  and
 is a subchain of .
However, the v-chain is not coming from the same partial slant .
 can be added into  only when  have been
added into .
The order of added gadgets in  is:
.
But,  and each gadget of  can not coexist in the
same  because
some faces of  and each gadget of 
overlap.
}\label{fig:conflict}
\end{figure}


\subsection{An Algorithm to Find Conflicting Gadgets via Backtracking}\label{sec:backtrack-conflict-gadgets}

In the last subsection,
we know that each v-chain of  only contains partial information of a
complete slant .
In this subsection, we use a recursive constructive definition
to define a \emph{hierarchal v-chain}
which represents
sufficient information of a complete   and
can be represented by a DAG
as follows:
\begin{definition}\label{def:h-v-chain}
Given the final mirror fan  with ,
a \emph{hierarchal v-chain}  of  is a DAG
recursively defined as follows:
\begin{enumerate}
\item The \emph{root} 
is a sequence of pairs 
where
\begin{enumerate}
\item  is a v-chain
 of  and

\item each  is a portion of the front boundary  of .
\end{enumerate}


\item 

\begin{enumerate}
\item select a gadget  such that
\begin{enumerate}
\item  and
\item there exist a sequence of pairs

where each  is a vertex of  and
,
\end{enumerate}



\item create a vertex  consisting of a sequence of pairs

where
\begin{enumerate}
\item 
is a v-backbone of  and
\item each  is a portion
of the front boundary  of ,
\end{enumerate}

\item add  into  and
for each ,
add an arc  into . And,

\item change  to 
where  and  are the first and the last vertices of , respectively.

\end{enumerate}

\end{enumerate}


\end{definition}
Intuitively a hierarchal v-chain  is a hierarchal decomposition of
a complete slant   and
the root  of  represents a chain() of 's associated cut .
In the following definition,
a hierarchial structure  consists of a set of DAGs (backbone graphs)
and  can implicitly store all possible hierarchal v-chains .


\begin{definition}
 is a DAG where

\begin{enumerate}

\item for each vertex ,  represents a DAG
 over  where
\begin{enumerate}
\item every vertex 
is a pair  and  is a portion
of the front boundary  of ,

\item for each arc  in ,  associates with a DAG 
(the associated DAG of  is denoted by ),
the source of  is the starting vertex  of  and
the sink of  is the ending vertex  of .
\end{enumerate}

\item an ordered pair  belongs to  if there exists an arc  in  such that
's associated DAG  is equal to .
\end{enumerate}
We call an ordered pair vertices  a  of .
Also, for each arc ,
let  be the maximal subgraph of  which
can be reached from  via super arcs.
\end{definition}






From now on,
(1) when we mention a DAG  from an arc, it means that
the arc  is in the DAG represented by a vertex in ,
(2) when we mention a DAG  represented by a vertex ,
it means that the vertex  is a vertex in , and
(3) we use the term  to represent the DAG
in the root of the hierarchal structure .

Given a fan  and an arc 
(1)  is a \emph{complete arc} on  if
,
(2)  is a \emph{left partial arc} on  if
 and ,
(3)  is a \emph{right partial arc} on  if
 and , and
(4)  is \emph{minimal} if
 is a contiguous path.
Algorithm \ref{alg:backtrack-conflict-gadgets}
emulates the growing process of all hierarchal v-chains  as follows:
\begin{enumerate}
\item add the root  into  and
let  be the backbone graph 
of .
Now,  and
the root  of each hierarchal v-chain  is a directed path ,
and vice versa.

\item iteratively selects a gadget 
(to be defined in Definition \ref{def:removable-gadget})
such that
\begin{description}
\item [if]  is a mirror fan and has a path
,
(1) add a vertex  into ,
(2) let  be the backbone graph  of ,
(3) change  to ,
(4) add a super arc from  to  in  and
(5) let  be  where .
The backbone graph of  is embedded into .
See Fig \ref{fig:expand} as an example.



\item [Otherwise,]  is a fan.
For each maximal path 
where the gadget  of each  is equal to ,
(1) merge ,
(2) add an arc  between  and 
and (3) set 
(the backbone graph of )
where  is a v--pair in .
The backbone graph of  is embedded into .
Figs \ref{fig:merge} (1) and (2) show an example of 
before merging  and
Figs \ref{fig:merge} (3) and (4) show an example of 
after merging .
\end{description}
\end{enumerate}

\begin{figure}[t]
\centering
\includegraphics[width=0.75\textwidth, angle =0]{expand2}
\caption{(1) and (2) show a -triple  and
suppose that  has a directed path   ;
(3) and (4) show that after removing , we add a new arc  into
 and
 becomes   . And,
   is a directed path in 
where   
is a v-backbone of .
}
\label{fig:expand}
\end{figure}



\begin{figure}[t]
\centering
\includegraphics[scale=0.75, angle =0]{merge2}
\caption{
(1) and (2) are an example of , complete arcs and partial arcs;
(3) and (4) are an example to explain how  changes its structure after removing
a fan ;
(1) and (2):  is a directed path 
where  is a left partial arc on ,
 are complete arcs on  and
 is a right partial arc on .
Also,   
is a directed path in ,
 is a directed path in ,
 is a directed path in  and
 is a directed path in ;
(3) and (4): after removing the fan ,
change the vertices  and  to
 and , respectively
where  is the intersection of the back boundary 
and the front boundary ,
and  is a -pair in .
Also, the arcs  are replaced by the arc 
and  is the path .
}
\label{fig:merge}
\end{figure}

The next definition
defines a \emph{removable} gadget 
which can be selected in Algorithm \ref{alg:backtrack-conflict-gadgets}
and add the backbone graph  into  .
Intuitively a \emph{removable} gadget  means that
all gadgets  which are connections  in 
have been selected and removed from Algorithm \ref{alg:backtrack-conflict-gadgets}.

\begin{definition}\label{def:removable-gadget}
In Algorithm \ref{alg:backtrack-conflict-gadgets},
we say a gadget  is \emph{removable} from a DAG  
if there exists a vertex  and
we cannot find a vertex  from another DAG  in 
such that
 and  belong to some connection .
Note that the vertex  can also be selected from .
\end{definition}


Now we give the definition of a \emph{conflicting} hierarchal v-chain  which
cannot form a slant  . An example for
a \emph{conflicting} hierarchal v-chain  has been shown in Fig \ref{fig:conflict}.
\begin{definition}\label{def:non-conflicting-v-chain}
A hierarchal v-chain 
is \emph{conflicting} on a gadget  if
there exist pairs  and  where
 and  are two vertices in 
such that
\begin{enumerate}
\item if ,  and  overlap at least one face.
\item Otherwise (),  and  overlap at least two vertices.
\end{enumerate}
Note that  might be equal to .
Moreover, we say
the vertex  is \emph{conflicting} to  on 
if  and  satisfy one of the above two conditions.
On the other hand,
we say  is \emph{compatible} to  on 
if  is not conflicting to  on .
And,
for a hierarchal v-chain , we say  is \emph{compatible} on 
if  is not conflicting on .
\end{definition}


Next we can start to define that
 is  on a gadget 
as follows:
\begin{definition}
Given a hierarchal structure  and a gadget ,
we say  is \emph{compatible} on  if
\begin{enumerate}
\item there exists a directed path  such that
for each vertex ,
each vertex  other than 
is compatible to  on . And,
\item for each arc ,
the hierarchal substructure  of  is also compatible on .
\end{enumerate}
We say (1) a directed path  is \emph{compatible} on 
if  satisfies the conditions 1 and 2. And,
(2) a directed path  is \emph{conflicting} on 
if  violates the condition 1 or the condition 2.
Moreover, an arc  is \emph{compatible}
on  if
 is compatible on .
On the other hand,  is \emph{conflicting} on  if
 is not compatible on .
\end{definition}

From the above definition of a compatible hierarchal structure ,
we immediately have a recursive procedure to check whether
there exists a compatible path  on  in  as follows:
for each directed path ,
recursively check each arc  whether the DAG 
( is the root's associated DAG in )
has a compatible directed path on  or not.
Then  is conflicting on  if and only if  becomes disconnected
after removing all conflicting arcs  on  from .
It is stated in Property \ref{prop:connected-v-chain}.


Briefly speaking, Algorithm \ref{alg:backtrack-conflict-gadgets} iteratively
removes the root  of a conflicting hierarchal-v-chain  from .
Also, we utilize Algorithms \ref{alg:EXPAND} and
\ref{alg:MERGE} to adjust the structure of .
Moreover, after recursively adjusting 
(it means that via adjusting , we also
adjust the structure of ), we have the following fact:
for each , if there does not exist
a directed path between  and  in  before removing  from ,
then  remains disconnected to  in  after removing  from .
At the end of Algorithm \ref{alg:backtrack-conflict-gadgets},
we can conclude that
each connected path 
has a corresponding compatible hierarchal v-chain .
The intuitive meaning of a path 
keeps its connectivity after removing 
is that
 can add  into its corresponding hierarchal v-chain .

How to efficiently
check whether a directed path  is compatible on  or not?
We can recursively
check whether there exists a compatible directed path  on 
for each complete and partial arcs .
In Observations \ref{obs:complete-edge} and \ref{obs:partial-edge},
we describe the recursive formulas to
check complete arcs and partial arcs
whether they are compatible on  or not.
After we check all complete arcs and partial arcs,
we keep all compatible arcs on  in  and
check whether there exists a directed path
from source to sink in .
(The root  of a compatible hierarchal v-chain .)
The recursive procedures to check
directed paths, complete arcs and partial arcs on  in 
are described
in Lemmas \ref{lemma:proper-chain}, \ref{lemma:complete-edge} and \ref{lemma:partial-edge},
respectively.

\begin{algorithm}[t]
\caption{Find Conflicting Gadgets via Backtracking Algorithm}
\label{alg:backtrack-conflict-gadgets}

\KwIn{Sets  and }

Add the backbone graph  of  into .
\;

\While{the initial fan  is not removable from }
{
Find a removable gadget  from \;

\uIf { is a mirror fan}
{
\For{ each -triple }
{
EXPAND  in  by Algorithm \ref{alg:EXPAND}\;
}
}
\ElseIf{ is a fan}
{
\For{ each -pair }
{
Recursively check whether
each complete arc and partial arc in  are compatible on  or not
by Algorithm \ref{alg:MERGE}\;

}
Recursively delete all complete arcs on  from \;
}

Remove  from  and
all connections  and  from \;

}



\uIf {there exists a path 
where each 
is a complete arc on }
{
 have an area-universal rectangular layout\;
}
\Else
{
 does not have any area-universal rectangular layout\;
}
\end{algorithm}


The main task for EXPAND operation in Algorithm \ref{alg:EXPAND} is to add the backbone graph of a mirror fan into .
See Fig \ref{fig:expand} as an example for EXPAND operation.

\begin{algorithm}[t]
\caption{EXPAND a mirror fan in }
\label{alg:EXPAND}

\KwIn {The hierarchal structure  with the root  and
a -triple }

Add the backbone graph  into  as a vertex \;

\For{each DAG  such that
there is a subpath  in 
where  and  are portions of  and , respectively}
{

Replace  by
 in \;

Set  and
add a super arc from  to  in \;

Add an arc from the starting vertex of  to the source vertex of  and
an arc from the sink vertex of  to the ending vertex of  in \;

Remove the vertex  from \;
}
\end{algorithm}

In the following lemma,
we describe the recursive structure of a compatible directed path .
A simple way to explain Lemma \ref{lemma:proper-chain} is that
to recursively check a compatible directed path  in 
is equal to,
for each arc ,
recursively check whether there exists a compatible directed path  in .
In general, each directed path  can be decomposed into five parts:
(1) the subpath from source which doesn't have any partial arc and complete arc on ,
(2) the subpath which only has a left partial arc on ,
(3) the subpath which only has complete arcs on ,
(4) the subpath which only has a right partial arc on  and
(5) the subpath to sink which doesn't have any partial arc and complete arc on .
Because each arc  in a compatible directed path 
must be compatible on  ,
it implies that
 must have at least one directed path from source to sink which is compatible on .
We describe their recursive structures of complete arcs and partial arcs on  in Observations
\ref{obs:complete-edge}, \ref{obs:minimal-complete-edge}, \ref{obs:partial-edge} and \ref{obs:minimal-partial-edge}.
From the above discussion, we immediately have Lemma \ref{lemma:proper-chain}.

\begin{lemma}\label{lemma:proper-chain}
Given a fan ,
suppose there is a directed path
  

where the arcs  and  are the left and right partial arcs on , respectively, and
each arc  is a complete arc on .
Then,  is the root  of a compatible hierarchal v-chain  on  if and and if
\begin{itemize}
\item for each complete arc ,
there is a compatible directed path  on 
(see Observations \ref{obs:complete-edge} and \ref{obs:minimal-complete-edge}
for more details of a complete arc),
\item for the left partial arc ,
there is a compatible directed path  on 
(see Observations \ref{obs:partial-edge} and \ref{obs:minimal-partial-edge}
for more details of a left partial arc) and
\item for the right partial arc ,
there is a compatible directed path  on 
(see Observations \ref{obs:partial-edge} and \ref{obs:minimal-partial-edge}
for similar details of a right partial arc).
\end{itemize}
\end{lemma}


Given a complete arc  on ,
each arc  is also a complete arc on .
And, we know that if we want to guarantee that a complete arc  is compatible, we
must recursively check whether  can have a directed path which only consists of
compatible complete arcs on .
Obviously, to recursively check a compatible complete arc on 
is a recursive procedure implemented by dynamic programming technique.
Also, the base case for the recursive procedure
is that a complete arc on  whose two end vertices  and 
have that  is contiguous on the front boundary of . It means that
 is compatible on .
See Fig \ref{fig:merge} as an example of a complete arc.

From the above discussion, we can describe recursive structures of a compatible
complete arc on  in Observations \ref{obs:complete-edge} and \ref{obs:minimal-complete-edge}:





\begin{observation}\label{obs:complete-edge}
Given a fan , a complete arc
 is compatible on  if and only if
there exists a directed path 
where
\begin{itemize}
\item the source vertex of  is the starting vertex of ,
\item the sink vertex of  is the ending vertex of  and
\item each  is a compatible complete arc on .
\end{itemize}
\end{observation}

\begin{observation}\label{obs:minimal-complete-edge}
Given a fan ,
a minimal complete arc  is compatible on 
if and only if
 is contiguous on the front boundary  of 
(the last vertex of  overlaps the first vertex of ).
\end{observation}


Based on Observations \ref{obs:complete-edge} and \ref{obs:minimal-complete-edge},
we can check a complete arc  on  whether it is compatible
on  or not via Lemma \ref{lemma:complete-edge}.

\begin{lemma}\label{lemma:complete-edge}
Given a fan ,
we can recursively check whether each complete arc  on 
satisfies structure described in Observations \ref{obs:complete-edge} and \ref{obs:minimal-complete-edge} as follows:
\begin{enumerate}
\item recursively check whether each arc  satisfies the structures in Observations \ref{obs:complete-edge}
and \ref{obs:minimal-complete-edge},
\item keep all arcs passing the above tests in , and
\item check whether  has a directed path from source to sink. If yes, keep  in .
Otherwise, delete  from .
\end{enumerate}
\end{lemma}

For a left partial arc  on ,
because  is equal to ,
each directed path  in  can be partitioned into
(1) the subpath that consists of neither complete arcs nor partial arcs on ,
(2) the left partial arc on  and
(3) the subpath that only consists of complete arcs on .
See Fig \ref{fig:merge} as an example of a left partial arc.
Similarly, to check a compatible left partial arc on  is a recursive procedure
which can be implemented by dynamic programming technique.
Also, the base case for the recursive procedure
is a left partial arc  on 
which has (1)  is a v-connection in  and
(2)  is contiguous on the front boundary  of the connection .
It means that  is compatible on .
See Fig \ref{fig:merge} for examples of a left partial arc and a minimal left partial arc.
From the above discussion, we can describe recursive structures of a compatible
left partial arc on  in Observations \ref{obs:partial-edge} and \ref{obs:minimal-partial-edge}:


\begin{observation}\label{obs:partial-edge}
Given a fan  and a left partial arc  on ,
a left partial arc  is
compatible on  if and only if
there exists a directed path 
in  where
\begin{itemize}
\item the source vertex of  is the starting vertex of ,
\item the sink vertex of  is the ending vertex of ,
\item for each , 
is an arc where  and ,
\item the arc  is a compatible left partial arc on , and
\item each arc  is a compatible complete arc on .
\end{itemize}
\end{observation}


\begin{observation}\label{obs:minimal-partial-edge}
Given a fan ,
a minimal left partial arc  on 
is a compatible left partial arc on  if and only if
(1)  is a connection in  and
(2)  is contiguous on the front boundary  of the connection 
(the last vertex of  overlaps the first vertex of ).
\end{observation}


Based on Observations \ref{obs:partial-edge} and \ref{obs:minimal-partial-edge},
we can recursively check whether a partial arc 
is compatible on  or not via Lemma \ref{lemma:partial-edge}.

\begin{lemma}\label{lemma:partial-edge}
Given a fan ,
we can recursively check whether a partial arc  on 
satisfies the structures in Observations \ref{obs:partial-edge} and \ref{obs:minimal-partial-edge} as follows:
\begin{enumerate}
\item recursively check whether
each partial arc  on 
satisfies the structures in Observations \ref{obs:partial-edge} and \ref{obs:minimal-partial-edge},
\item recursively check whether
each complete arc  on  satisfies the structures
in Observations \ref{obs:complete-edge} and \ref{obs:minimal-complete-edge},
\item keep all arcs passing the above tests in , and
\item check whether  has a directed path from source to sink. If yes, keep  in .
Otherwise, delete  from .
\end{enumerate}
\end{lemma}

There are three main tasks of MERGE operation in Algorithm \ref{alg:MERGE}.
The first one is to recursively check each complete arc on a removable gadget .
The second one is to recursively check each partial arc on .
The final one is to remove  and maintain the connectivity
for each compatible directed path
in .
What we do in the final for loop is to
reconnect a new arc between a left partial arc  and a right partial arc 
if and only if there exists a compatible directed path from  to .
See Fig \ref{fig:merge} as an examples for Algorithm \ref{alg:MERGE}.

\begin{algorithm}[t]
\caption{MERGE  via Dynamic Programming}
\label{alg:MERGE}

\KwIn{The hierarchal structure  with the root  and a -pair }


\For {each complete arc  on }
{
Recursively check 
whether  is compatible on  or not
(this recursive check follows Lemma \ref{lemma:complete-edge})\;
}

\For {each partial arc  on }
{Recursively check 
whether  is compatible on  or not
(this recursive check follows Lemma \ref{lemma:partial-edge})\;
}

\For {each pair of left partial arc 
and right partial arc  in 
    such that  and  remain connected in }
{

      Change  and  to
       and
      , respectively\;

      Add an arc  into the graph  and
      let  be the directed path
      \;
}

\end{algorithm}

Note that the connectivity between  and  is based on the arcs
which are compatible on 
in Algorithm \ref{alg:MERGE}.


There are two important properties for the correctness of Algorithm \ref{alg:backtrack-conflict-gadgets}.
The first one states that
we can eliminate each conflicting directed path  (hierarchal v-chain ) on  via removing  from .
The second one states that
the number of directed paths (hierarchal v-chains) decreases
during Algorithm \ref{alg:backtrack-conflict-gadgets} executes.

\begin{property}\label{prop:connected-v-chain}
For each DAG ,
a directed path 
is conflicting on  if and only if  becomes disconnected after removing  from .
\end{property}

\begin{property}\label{prop:dummy-v-chain}
For each DAG ,
if any two vertices  are
disconnected, then  and  remain disconnected
after removing  from .
\end{property}

From the above two properties, we can see that
if we can recursively guaranteed that
for each compatible arc  on , 
has Properties \ref{prop:connected-v-chain} and \ref{prop:dummy-v-chain},
then each compatible directed path  on 
is also a compatible hierarchal v-chain on .
And, in the final "for" loop of Algorithm \ref{alg:MERGE},
it connects a new arc between  and 
if and only if there is a compatible directed path on  from  and .
Hence
it guarantees that no pair of vertices  turns into connected if
 and  are disconnected
before removing conflicting arcs on .

\begin{theorem}\label{thm:backtracking}
Algorithm \ref{alg:backtrack-conflict-gadgets} can successfully
check whether there exists a directed path 
such that  has a corresponding slant .
\end{theorem}

\begin{proof}

The correctness of Algorithm \ref{alg:backtrack-conflict-gadgets}
is based on Properties \ref{prop:connected-v-chain} and
\ref{prop:dummy-v-chain}.
Clearly, from Property \ref{prop:connected-v-chain},
each conflicting directed path 
(the root  of each hierarchal v-chain ) on 
becomes disconnected after removing a removable gadget 
and from Property \ref{prop:dummy-v-chain},
it remains disconnected in the following steps.
Hence in the final step of Algorithm \ref{alg:backtrack-conflict-gadgets},
each connected directed path  has been proven that
 corresponds to the root  of a compatible hierarchal v-chain on 
for every gadget .
Also,
if a directed path , corresponds to the root 
of a hierarchal v-chain , keeps its connectivity
after recursively removing a gadget  from , then
this hierarchal v-chain  can add the gadget  into its corresponding slant .
Hence we can have that each connected directed path in 
has a corresponding slant  .



\end{proof}

Theorem \ref{thm:backtracking} has proven that
we can backtrack all directed paths 
to know whether  represents
the chain of a partial slant  .

\begin{theorem}\label{thm:backtracking-time}
The time complexity of Algorithm \ref{alg:backtrack-conflict-gadgets} is polynomial bound.
\end{theorem}

\begin{proof}



Let  be the number of iterations in Algorithm \ref{alg:backtrack-conflict-gadgets}
and , be the size of  in the -th iteration.
The time analysis of backtracking is based on three parts:
(1)  is polynomial bound,
(2) each , is polynomial bound and
(3) time complexity  in each -th iteration is polynomial bound.


Obviously, the number  of total iterations is bounded by the number of connections .
By Lemma \ref{lemma:number}, the number of gadgets in  is at most  and the number
of connections in  is at most .
Hence  polynomially grows with respect to the number of 's vertices .

For each -th iteration, we either execute EXPAND or MERGE operations to adjust ' structure.
When Algorithm \ref{alg:backtrack-conflict-gadgets} executes EXPAND operation on a removable gadget  with the back boundary ,
we add 's backbone graph  into  where 's size (the number of vertices
in ) is polynomial bound.
Since the number  of total iterations is polynomial bound,
the total vertices added into  in all EXPAND operations are bounded
by the summation of all backbone graphs's size.
Hence, the summation of all backbone graphs's size is polynomial bound.

When Algorithm \ref{alg:backtrack-conflict-gadgets} executes MERGE operation
on a removable gadget  with a -pair ,
we replace each maximal compatible directed path  on  in  by
an arc  between the two end vertices of  where
each arc in  is a complete arc on , and
add  into  where  consists of the newly-added vertex .
Note that the added vertex  only connects to the two end vertices  and  of ,
and cannot be connected to other vertices in  in following iterations.
Also,  is removed from  when removing a removable gadget  from .
Hence the total number of newly-added arcs  are summation of all backbone graphs's size and
it is polynomial bound.
Also, the size of all added  is polynomial bound.

Because the total vertices added into  are polynomial bound during each iteration
and the number  of iterations is polynomial bound,
the maximum of 's size is polynomial bound of each iteration
in Algorithm \ref{alg:backtrack-conflict-gadgets}.
Hence each number , of vertices of  in
each -th iteration is polynomial bound.

Now we analyze the time complexity of each iteration.
When Algorithm \ref{alg:backtrack-conflict-gadgets} executes EXPAND operation on a removable gadget  with the back boundary ,
we take polynomial time to add the 's backbone graph  into 
because 's size is polynomial bound.

When Algorithm \ref{alg:backtrack-conflict-gadgets} executes MERGE operation on a removable gadget ,
the tasks of MERGE operation consist of
(1) recursively checking each complete arc on  in 
by Lemma \ref{lemma:complete-edge},
(2) recursively checking each partial arc on  in  by Lemma \ref{lemma:partial-edge} and
(3) check that for each DAG ,
whether there exists a directed path
from the source to the sink in 
after removing all conflicting complete and partial arcs from .

The total work of a MERGE operation can be simply described as follows:
check each DAG  whether  has at least one connected
directed path from the source to the sink in .
And, it can be done by executing a breadth-first search in 
since  is a DAG. Hence the complexity of the total work of a MERGE operation
is polynomial bound as .
Note that the order to check each DAG 
is a bottom-up traversal in  as follows:
a DAG  is ready to check if and only if
every DAG , has been checked.



Because each iteration takes polynomial time as ,
the total time complexity of all  iterations in Algorithm \ref{alg:backtrack-conflict-gadgets}
is also polynomial bound.

\end{proof}

Theorem \ref{thm:backtracking-time} has proven that
the time complexity of Algorithm \ref{alg:backtrack-conflict-gadgets}
is polynomial bound.
\clearpage

\bibliographystyle{plain}
\begin{thebibliography}{5}

\bibitem{BHW00}
M. Bruls, K. Huizing, and J. J. van Wijk, \newblock Squarified treemaps,
in Proceedings of the Eurographics
and IEEE TCVG Symposium on Visualization,
Springer, 2000, pp. 33-42.

\bibitem{EM79}
C. F. Earl and L. J. March,
\newblock Architectural applications of graph theory,
\newblock Applications of Graph Theory,
R. Wilson and L. Beineke, eds., Academic Press, London, 1979, pp. 327-355.

\bibitem{DD07}
Erik D. Demaine and Martin L. Demaine;
\newblock Jigsaw Puzzles, Edge Matching, and Polyomino Packing: Connections and Complexity,
\newblock{Graphs and Combinatorics},
23 [Supple], 2007, Digital Object Identifier
(DOI) 10.1007/s00373-007-0713-4.

\bibitem{EMSV12}
D. Eppstein, E. Mumford, B. Speckmann, and K. Verbeek,
\newblock Area-universal and constrained rectangular layouts,
\newblock {\em SIAM J. Comput.} 41, no. 3, 2012, pp. 537-564.

\bibitem{Ep10}
D. Eppstein,
\newblock Regular labelings and geometric structures,
in Proceedings of the 22nd Canadian
Conference on Computational Geometry, 2010, pp. 125-130.

\bibitem{EM10}
D. Eppstein and E. Mumford,
\newblock Steinitz theorems for orthogonal polyhedra,
in Proceedings of the 26th ACM Symposium on Computational
Geometry, 2010, pp. 429-438.

\bibitem{Fu06}
\'{E}. Fusy
\newblock Transversal structures on triangulations, with application to
straight-line drawing,
in Proceedings of the 13th International Symposium on Graph Drawing (GD 2005),
Lecture Notes in Comput. Sci. 3843, Springer, Berlin, 2006, pp. 177-188.

\bibitem{Fu09}
\'{E}. Fusy,
\newblock Transversal structures on triangulations: A combinatorial study
and straight-line drawings,
\newblock {\em Discrete Math}. 309, 2009, pp. 1870-1894.

\bibitem{He93}
X. He,
\newblock On finding the rectangular duals of planar triangular graphs,
\newblock {\em SIAM J. Comput.} 22, no. 6, 1993, 1218-1226.

\bibitem{KH97}
G. Kant and X. He,
\newblock Regular edge labeling of 4-connected plane graphs and its applications in
graph drawing problems,
\newblock {\em Theoret. Comput. Sci}. 172, (1997), pp. 175-193.



\bibitem{KS07}
M. van Kreveld and B. Speckmann,
\newblock On rectangular cartograms,
\newblock {\em Computational Geometry} 37, 2007, 175-187.

\bibitem{KK85}
K. Ko\'{z}mi\'{n}ski and E. Kinnen
\newblock Rectangular duals of planar graphs,
\newblock {\em Networks} 5, 1985, pp. 145-157.

\bibitem{Mu08}
E. Mumford,
\newblock Drawing graphs for cartographic applications,
Ph.D. thesis, Technische Universiteit
Eindhoven, Eindhoven, The Netherlands, 2008.

\bibitem{Ra34}
E. Raisz,
\newblock The rectangular statistical cartogram,
\newblock {\em Geographical Review} 24 (2), 1934, 292-296.

\bibitem{Ri87}
I. Rinsma,
\newblock Nonexistence of a certain rectangular floorplan with
specified areas and adjacency,
\newblock {\em Environ. Plann. B} 14, 1987, pp. 163-166.

\bibitem{WKC88}
S. Wimer, I. Koren, and I. Cederbaum,
\newblock Floorplans, planar graphs, and layouts,
\newblock {\em IEEE Trans.  Circuits Syst.} 35, 1988, pp. 267-278.

\bibitem{YS95}
G. K. H. Yeap and M. Sarrafzadeh,
\newblock Sliceable floorplanning by graph dualization,
\newblock {\em SIAM J.  Disc. Math.} 8, 1995, pp. 258-280.

\end{thebibliography}
\end{document}
