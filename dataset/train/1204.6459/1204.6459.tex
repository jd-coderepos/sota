\documentclass[runningheads,11pt]{llncs}
\usepackage{amsmath,amssymb,amsfonts,mathrsfs}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage[dvips,vmargin={1in,1in},hmargin={1in,1in}]{geometry}


\newcommand{\eqdef}{\stackrel{\text{def}}{=}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\F}{\ensuremath{\mathbb{F}}}
\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}}

\newcommand{\set}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\card}[1]{\left | #1 \right |}
\newcommand{\sym}{\ensuremath{\mathfrak{S}}}
\newcommand{\prob}{\ensuremath{\textsf{Prob}}}
\newcommand{\diag}{\ensuremath{\textsf{diag}}}
\newcommand{\code}[1]{\ensuremath{\mathscr{#1}}}
\newcommand{\Csec}{\code{C}_{\text{sec}}}
\newcommand{\Cpub}{\code{C}_{\text{pub}}}
\newcommand{\CC}{\code{C}}
\newcommand{\sqc}[1]{<#1^2>}
\newcommand{\scp}[2]{#1\cdot #2}
\newcommand{\bscp}[2]{(#1.#2)}

\newcommand{\cwp}{\star}
\newcommand{\dual}[1]{\ensuremath{{#1}^\bot}}
\newcommand{\wt}[1]{\ensuremath{\textsf{wt}(#1)}}
\newcommand{\dist}{\ensuremath{\textsf{dist}}}


\newcommand{\word}[1]{\ensuremath{\boldsymbol{#1}}}
\newcommand{\av}{\word{a}}
\newcommand{\bv}{\word{b}}
\newcommand{\alphav}{\word{\alpha}}
\newcommand{\betav}{\word{\beta}}
\newcommand{\lambdav}{\word{\lambda}}
\newcommand{\deltav}{\word{\delta}}
\newcommand{\cv}{\word{c}}
\newcommand{\dv}{\word{d}}
\newcommand{\ev}{\word{e}}
\newcommand{\fv}{\word{f}}
\newcommand{\gv}{\word{g}}
\newcommand{\gvp}{\word{g_p}}
\newcommand{\hv}{\word{h}}
\newcommand{\hvp}{\word{h_p}}
\newcommand{\mv}{\word{m}}
\newcommand{\pv}{\word{p}}
\newcommand{\qv}{\word{q}}
\newcommand{\rv}{\word{r}}
\newcommand{\sv}{\word{s}}
\newcommand{\uv}{\word{u}}
\newcommand{\vv}{\word{v}}
\newcommand{\wv}{\word{w}}
\newcommand{\xv}{\word{x}}
\newcommand{\yv}{\word{y}}
\newcommand{\zv}{\word{z}}
\newcommand{\zvp}{\word{z_p}}

\newcommand{\Gv}{\word{G}}
\newcommand{\Mv}{\word{M}}
\newcommand{\Pv}{\word{P}}
\newcommand{\Qv}{\word{Q}}
\newcommand{\Sv}{\word{S}}
\newcommand{\Vv}{\word{V}}
\newcommand{\Xv}{\word{X}}
\newcommand{\Yv}{\word{Y}}
\newcommand{\Zv}{\word{Z}}

\newcommand{\mat}[1]{\ensuremath{\boldsymbol{#1}}}
\newcommand{\Gp}{\mat{G}}
\newcommand{\Gs}{\mat{G}_s}
\newcommand{\Am}{\mat{A}}
\newcommand{\Bm}{\mat{B}}
\newcommand{\Cm}{\mat{C}}
\newcommand{\Dm}{\mat{D}}
\newcommand{\Em}{\mat{E}}
\newcommand{\Fm}{\mat{F}}
\newcommand{\Gm}{\mat{G}}
\newcommand{\Hm}{\mat{H}}
\renewcommand{\Im}{\mat{I}}
\newcommand{\Lm}{\mat{L}}
\newcommand{\Mm}{\mat{M}}
\newcommand{\Nm}{\mat{N}}
\newcommand{\Om}{\mat{O}}
\newcommand{\Pm}{\mat{P}}
\newcommand{\Pim}{\mat{\Pi}}
\newcommand{\phim}{\mat{\phi}}
\newcommand{\Qm}{\mat{Q}}
\newcommand{\Rm}{\mat{R}}
\newcommand{\Sm}{\mat{S}}
\newcommand{\Tm}{\mat{T}}
\newcommand{\Um}{\mat{U}}
\newcommand{\Vm}{\mat{V}}
\newcommand{\Wm}{\mat{W}}
\newcommand{\Xm}{\mat{X}}
\newcommand{\Ym}{\mat{Y}}
\newcommand{\Zm}{\mat{Z}}
\newcommand{\Gms}{\mat{G_{sec}}}
\newcommand{\Gmp}{\mat{G_{pub}}}
\newcommand{\Hms}{\mat{H_{sec}}}
\newcommand{\Hmp}{\mat{H_{pub}}}

\newcommand{\ft}{GF(2)}
\newcommand{\ff}[1]{GF(#1)}
\newcommand{\fq}{GF(q)}
\newcommand{\fqm}{GF(q^m)}
\newcommand{\GRS}[3]{\text{\bf GRS}_{#1}(#2,#3)}
\newcommand{\RS}[2]{\text{\bf RS}_{#1}(#2)}

\newcommand{\poly}{\ensuremath{\textsf{poly}}}
\newcommand{\setup}{\texttt{Setup}}
\newcommand{\generate}{\texttt{Generate}}
\newcommand{\decrypt}{\texttt{Decrypt}}
\newcommand{\encrypt}{\texttt{Encrypt}}
\newcommand{\pk}{\ensuremath{\textsf{pk}}}
\newcommand{\sk}{\ensuremath{\textsf{sk}}}
\newcommand{\sign}{\texttt{Sign}}
\newcommand{\verify}{\texttt{Verify}}
\newcommand{\success}{\texttt{Succ}}


\spnewtheorem{assumption}[theorem]{Assumption}{\bfseries}{\itshape}
\spnewtheorem{fact}[theorem]{Fact}{\bfseries}{\itshape}
\newtheorem{expfact}{Experimental fact}


\begin{document}


\title{ A Distinguisher-Based Attack on a Variant of McEliece's
  Cryptosystem Based on Reed-Solomon Codes
} 

\author{Val\'erie Gauthier\inst{1}, Ayoub Otmani\inst{1} \and Jean-Pierre Tillich\inst{2}}
\institute{
GREYC - Universit\'e de Caen - Ensicaen\\
Boulevard Mar\'echal Juin, 14050 Caen Cedex, France.\\
\email{valerie.gauthier01@unicaen.fr, ayoub.otmani@unicaen.fr},
\and
SECRET Project - INRIA Rocquencourt \\ 
Domaine de Voluceau, B.P. 105   
78153 Le Chesnay Cedex - France \\
\email{jean-pierre.tillich@inria.fr}
}

\maketitle
\begin{center}
  \date{}
\end{center}

\begin{abstract}
Baldi et \textit{al.} proposed a variant of McEliece's cryptosystem. The main idea is to 
replace its permutation matrix by adding to it a rank  matrix. 
The motivation for this change is twofold: it would allow the use of codes that were shown to be insecure 
in the original McEliece's cryptosystem, and it would reduce the key size while keeping 
the same security against generic decoding attacks. The authors suggest to use generalized Reed-Solomon 
codes instead of Goppa codes. The public code built with this method is not anymore a generalized Reed-Solomon code. 
On the other hand, it contains a very large secret generalized Reed-Solomon code. 
In this paper we present an attack that is built upon a distinguisher which is able
to identify elements of this secret code.  
The distinguisher is constructed by considering the code generated by component-wise products of codewords of the public code
(the so-called ``square code''). By using square-code dimension considerations, the initial generalized Reed-Solomon code can be
recovered which permits to decode any ciphertext. A similar technique
has already been successful for mounting an attack \cite{GOT:eprint12} against a homomorphic
encryption scheme suggested by \cite{BL12}. This work can be
viewed as another illustration of how a distinguisher of Reed-Solomon
codes can be used to devise an attack on cryptosystems based on them. 
 \end{abstract}



\textbf{Keywords.} Code-based cryptography, McEliece, distinguisher.


\section{Introduction}
 



Reed-Solomon codes have been suggested for the first time in a public-key
cryptosystem in \cite{Niederreiter86} but it was shown to be insecure in 
\cite{SidelShesta92}. The attack recovers the underlying Reed-Solomon
allowing the decoding of any encrypted data obtained from a McEliece-type 
cryptosystem based on them. The McEliece cryptosystem
\cite{McEliece78} on the other hand uses Goppa codes.
Since its apparition, it has withstood many attacks and after more than thirty years now, it still belongs 
to the very few unbroken public key cryptosystems. This situation substantiates the claim that inverting 
the encryption function, and in particular recovering the private key from public data, is intractable. 

No significant  breakthrough has been observed with respect to the problem of 
recovering the private key \cite{Gib91,LS01}. This has led to claim that the generator matrix of a binary Goppa 
code does not disclose any visible structure that an attacker could exploit. This is strengthened by the fact that Goppa codes
share many characteristics with random codes: for instance they asymptotically meet the Gilbert-Varshamov bound, they typically have 
a trivial permutation group, \textit{etc.}  
This is the driving motivation for conjecturing the hardness of the Goppa code distinguishing problem, which asks whether a Goppa code can be 
distinguished from a random code. This has become 
a classical belief in code-based cryptography, and semantic security
in the random oracle model \cite{NojimaIKM08}, CCA2 security in the standard model \cite{DowsleyMN09} and security in the random oracle model 
against existential forgery \cite{Dallot07} of the signature scheme \cite{CouFinSen01} are now proved by using this assumption.

\medskip

In \cite{FGOPT11a}, an algorithm  that manages to 
distinguish between a random code and a Goppa code has been introduced.
This work without undermining the security of \cite{McEliece78}
prompts to wonder whether it would be possible to devise an attack based 
on such a distinguisher. 
It was found out in \cite{MP12a} that our distinguisher \cite{FGOPT11a} has an equivalent but simpler description
in terms of the component-wise product of codes. This notion was first put forward in coding theory to unify many 
different algebraic decoding algorithms \cite{Pel92,Kot92a}. Recently, it was used in \cite{CMP11}
to study the security of cryptosystems based on Algebraic-Geometric codes.
Powers of codes are also studied in the context of secure multi-party computation (see for example \cite{Cramer09,Cramer11}).
This distinguisher is even more powerful in the case of Reed-Solomon codes 
than for Goppa codes because,
whereas for Goppa codes it is only successful for rates close to , it can distinguish 
Reed-Solomon codes of any rate from random codes. 

\medskip





In this paper we propose a cryptanalysis against 
a variant of McEliece's cryptosystem \cite{McEliece78} proposed  in \cite{BBCRS11a} which is based on 
on the aforementioned version of our
distinguisher presented in \cite{MP12a}.
The main idea of this proposal is to replace the permutation matrix used to hide the secret generator matrix by another matrix of the form  
where  is a permutation matrix and  is a rank  matrix. 
The motivation for this change is twofold: it would allow the use of codes that were shown to be insecure 
in the original McEliece's cryptosystem. It also allows  to reduce the size of the keys which is a major drawback in code-based 
cryptography. In this new setting it was suggested  to use generalized Reed-Solomon codes. The public code obtained 
with this method is not anymore a generalized Reed-Solomon code. On the other hand, it contains a very large secret generalized Reed-Solomon code. Our attack consists is identifying this secret Reed-Solomon code by picking
at random a very small number of elements of the public code and computing the dimension of the vector space
generated by component-wise products of these elements with the public code. This technique is precisely what enables
to distinguish a Reed-Solomon code from a random code. In the case at hand, the dimension of the vector space
is much smaller when all elements belong to the secret Reed-Solomon code than in the generic case. This is precisely
what allows to recover the secret Reed-Solomon code.
 Once this secret code is obtained, it is then possible to completely recover the initial generalized Reed-Solomon code by using the 
square-code construction as in \cite{Wie10}. We are then able to decode any ciphertext.


\medskip


It should also be pointed out that the properties of Reed-Solomon codes with respect to the component-wise product of codes have 
already been used to cryptanalyze a McEliece-like scheme  \cite{BL05} based on subcodes of Reed-Solomon codes
\cite{Wie10}. The use of this product is nevertheless different in
\cite{Wie10} from the way we use it here.
Note also that our attack is not an 
adaptation of  the Sidelnikov and Shestakov approach \cite{SidelShesta92}. 
Our approach is completely new: it illustrates how a distinguisher
that detects an abnormal behavior can be used to recover the private
key. It should also be added that a very similar technique has been successful to attack \cite{GOT:eprint12} a homorphic
encryption scheme based on Reed-Solomon codes \cite{BL12}.




\medskip

\paragraph{\bf Organisation of the paper.} In Section~\ref{sec:basics} we recall important notions from coding theory. 
In Section~\ref{sec:schemeit} we describe 
the cryptosystem proposed in \cite{BBCRS11a} and in
Section~\ref{sec:attack_Baldi}  we explain an attack of this system.
 
\section{Reed-Solomon Codes and the Square Code}
\label{sec:basics}
We recall in this section a few relevant results and definitions from coding theory and bring in the
fundamental notion which is used in the attack, namely the square code.
A linear \emph{code}  of {\em length}  and {\em dimension}  over a finite field  of  elements is a subspace of dimension  of the full
space . 
 It is generally specified by a 
full-rank matrix called a generator matrix which is a  matrix  (with ) over  whose
rows span the code:
 
 It can also be specified by a {\em parity-check} matrix , which is a matrix whose right kernel is equal to 
 the code, that is
 
 where  stands for the column vector which is the transpose of the row vector .
 The {\em rate} of the code is 
given by the ratio .
Code-based public-key cryptography focuses on linear codes that have a polynomial time decoding algorithm. The role of decoding 
algorithms is to correct  errors of prescribed weight. We say that a decoding algorithm
corrects  errors if it recovers  from the
knowledge of  for all possible
 of weight at most . 


Reed-Solomon codes form a special case of codes with a very powerful low complexity decoding algorithm.
It will be convenient to use the definition of Reed-Solomon codes and generalized Reed-Solomon codes as
{\em evaluation codes} 
\begin{definition}[Reed-Solomon code and generalized Reed-Solomon code] \label{defGRS}
Let  and  be integers such that  where  is a power of
a prime number.
Let  be an -tuple of distinct elements of
. 
The \emph{Reed-Solomon} code   of dimension  is the set of 

when  ranges over all polynomials of degree 
with coefficients in .
The generalized Reed-Solomon code  of dimension  is associated to a couple 
 where  is chosen as above and
the entries  are arbitrary non zero elements in . 
It is defined as the set of  
where  ranges over all polynomials of degree 
with coefficients in .
\end{definition}

Generalized Reed-Solomon codes are quite important in coding theory
due to the conjunction of several factors such as:
\begin{enumerate}
\item Their minimum distance  is maximal among all codes of the
  same dimension  and length   because  is equal to .
\item They can be efficiently decoded in polynomial time when the number of errors
is less than or equal to . 
\end{enumerate}
It has been suggested to use them in a public-key cryptosystem for the first time in \cite{Niederreiter86} but 
it was discovered that this scheme is insecure in \cite{SidelShesta92}. Sidelnikov and Shestakov namely showed that it is 
possible  
to recover in polynomial time for any generalized Reed-Solomon code a possible couple  which defines it.
This is all what is needed to decode efficiently such codes and is therefore enough to break the Niederreiter cryptosystem suggested in 
\cite{Niederreiter86} or a McEliece type cryptosystem \cite{McEliece78} when Reed-Solomon are used instead of Goppa codes.

We could not find a way to adapt the Sidelnikov and Shestakov approach 
for recovering the secret Generalized Reed-Solomon code from the public generating matrix  in the 
Baldi et \textit{al.} scheme. 
However a Reed-Solomon displays a quite peculiar property with respect to the component-wise
product which is denoted by   for two vectors 
  and  and which is defined by
 . This can be seen by bringing in the following definition


\begin{definition}[Star product of codes -- Square code]
Let  and  be two codes of length . The
\emph{star product code} denoted by  of  and  is the vector space
spanned by all products  where  and  range over  and  respectively.
When ,   is called the \emph{square code} of 
and is denoted by .
\end{definition}


It is clear that  is also generated by the 's where the 's and the
's form a basis of  and  respectively.
Therefore
\begin{proposition}
  
\end{proposition}
We expect that the square code when applied to a random linear code should be a code of dimension of
order . Actually it can be shown by the proof technique of 
\cite{FGOPT11a}  that with probability 
going to  as  tends to infinity, the square  
code is of dimension  when  is of the form , see also
\cite{MP12a}.
 On the other hand generalized Reed Solomon codes behave
in a completely different way

\begin{proposition}\label{prop:square}
.
\end{proposition}

This follows immediately from the definition of a generalized Reed Solomon code as an evaluation code since
the star product of two elements  and  of  where
 and  are two polynomials of degree at most  is of the form 

where  is a polynomial of degree . Conversely, any element of the form 
where  is a polynomial of degree less than or equal to   is a linear combination of star products of two elements of .

This proposition shows
that the square code is only of dimension  when , which is quite unusual.
This property can also be used in the case . To see this, consider the dual of the Reed-Solomon code.
The {\em dual}  of a code  of length  over  is defined by 
 
where  stands for the standard inner product between elements of .
The dual of a generalized Reed-Solomon code is itself a generalized Reed-Solomon code, see
\cite[Theorem 4, p.304]{MacSloBook}


 \begin{proposition}\label{pr:dual}
 
 where the length of  is  and  is a certain element of  depending 
 on  and .
 \end{proposition}

 Therefore when  a Reed-Solomon code  can also be distinguished from 
 a random linear code of the same dimension by computing the dimension of
 . We have in this case
 
 and we obtain a code of dimension .

 The star product of two codes is the fundamental notion used in the decoding algorithm based on an error correcting pair
 \cite{Pel92,Kot92a} which unifies common ideas to many algebraic
 decoding algorithms. It has been used for the first time to 
cryptanalyze a McEliece-like scheme \cite{BL05} based on subcodes of Reed-Solomon codes
 \cite{Wie10}. The use of the star product is nevertheless different in \cite{Wie10} from the way we use it here. In this paper,
 the star product is used to identify  for a certain subcode   of a generalized Reed-Solomon code 
 a possible pair . This is achieved by computing  which in the case which is considered turns out to 
 be equal to  which is equal to . The Sidelnikov and Shestakov algorithm is then 
 used on   to recover a possible  pair to describe  as a generalized Reed-Solomon
 code. From this, a possible  pair for which  is deduced.


\section{Baldi et \textit{al.} Variant of McEliece's Cryptosystem} \label{sec:schemeit}

The cryptosystem proposed by Baldi et \textit{al.}  in \cite{BBCRS11a} is a variant of McEliece's cryptosystem \cite{McEliece78}. The main idea is to replace the permutation matrix used to hide the secret generator matrix by one of the form  where
 is a permutation matrix and  is a rank-one matrix. From
the authors' point of view, this new kind of transformations would
allow to use  families of codes that were shown insecure in the
original McEliece's cryptosystem. In particular, it would become possible to use generalized Reed-Solomon codes in this new framework.
The scheme can be summarized as follows.

\begin{description}
	\item \textbf{Secret key.} 
          \begin{itemize}
          \item  is a generator matrix of a generalized
            Reed-Solomon code of length  and dimension  over ,  
          \item  where
             is an  permutation matrix, 
          \item  is a rank-one matrix over  such that 
            is invertible, 
          \item  is a  random invertible  matrix over .
          \end{itemize}
        \item \textbf{Public key.} . 
          
	\item \textbf{Encryption.} The ciphertext  of a plaintext
           is obtained by drawing at random 
          in  of weight less than or equal  to  and computing
          . 
          
	\item \textbf{Decryption.} It consists in performing the three
          following steps:
	\begin{enumerate}
	\item Guessing the value of  ;
	\item Calculating 
	and using the decoding algorithm of the generalized Reed-Solomon code to recover
	 from the knowledge of ;
	\item Multiplying the result of the decoding by  to recover .
	\end{enumerate}
\end{description}

The first step of the decryption, that is guessing the value , boils down to trying  elements (in the worst case) since
 is of rank . Indeed, there exist 
  and  in 
 such that  . Therefore  where 
 is an element of . The second step of the decryption can also be
 performed efficiently because  is of weight less than or
 equal to , and  errors can be corrected
 in polynomial time in a generalized Reed-Solomon code of length  and dimension   by well-known standard decoding algorithms. 

 


\section{Attack on the Baldi et \textit{al.} Cryptosystem Using GRS Codes}\label{sec:attack_Baldi}

\subsection{Case where }
We define  and  to be the codes
generated by the matrices  and  respectively. 
We denote by  the length of these codes and by  their 
dimension. We  assume in this subsection that

As explained in Section \ref{sec:schemeit},  is a GRS code. 
It is also assumed in \cite{BBCRS11a} that the matrix  is invertible. It will be convenient to bring in the code
. The matrix
 is assumed to be of rank one. From Lemma~\ref{lem:RPi-1}
in Appendix~\ref{appendixBaldi}, the matrix  is also of rank one. Hence
there exist  and  in  such that:

This code , being a permutation of a generalized Reed-Solomon code, is itself a generalized Reed-Solomon 
code. So there are elements  and  in  such that
. 
There is a simple relation between  and  as explained
by the following lemma.
\begin{lemma}\label{lem:structure}
Let . For any
 in  there exists  in  such that: 

\end{lemma}
The proof of this lemma is given in Appendix~\ref{appendixBaldi}. From now on we make the assumption that 

If this is not the case then  and there is 
straightforward attack by applying the Sidelnikov and Shestakov algorithm
\cite{SidelShesta92}. It  finds  that expresses  as . This
allows to easily decode . 

\medskip

Our attack relies on identifying a code of dimension 
that is both a subcode of   and the
Generalized Reed-Solomon code . It consists more precisely of
codewords  with  in  such that  
. This particular code which is denoted by
 is hence:
 
where  denotes the vector space spanned by . 
It is a subspace of  of codimension  if .
This strongly suggests that  should have an unusual
low dimension since   has dimension   by
Proposition \ref{prop:square}. 
More  exactly we have here:


\begin{proposition}
\label{prop:dimension_sqCpub}
\begin{enumerate}
\item[]
\item 
\item 
\end{enumerate}
\end{proposition}

\medskip

The first fact follows immediately from Lemma \ref{lem:structure} and the proof
of this proposition is given in Appendix~\ref{appendixBaldi}. Experimentally it has been observed that the upper-bound 
is quite sharp. Indeed, the dimension of  has always been
found\footnote{There are however cases where the dimension might be
  even smaller. Let us take for instance
 for some integer  
where . From Proposition~\ref{prop:square} we know that
 and it can be checked similarly that 
. It follows immediately from the first statement of
Proposition \ref{prop:dimension_sqCpub} that the dimension of 
 is upperbounded by  which can be obviously smaller than
.} to be equal to  in all our experiments when choosing randomly the
codes and . 

\medskip

The second observation is that when a basis 
 of  is chosen and  other random elements , then we may expect that 
the dimension of the vector space generated by all products  with  in  and  in 
 is the dimension of the full space  when
. This is indeed the case when  
but it is not true for  since we have the following result.
\begin{proposition}\label{prop:three} Let  be the linear code spanned by . It holds that

\end{proposition}
An explanation of this phenomenon is given in Appendix~\ref{appendixBaldi}. Experimentally, it turns out that almost always this upper-bound
is quite tight and the dimension is generally . But if we assume
now that , ,  all belong to
, which happens with probability  since  is 
a subspace of  of codimension  (at least when ),
then the vectors  generate a subspace with  a much
smaller dimension.
\begin{proposition}\label{prop:attack}
If  is in  for  in 
then for all  in 
:

and if  is the linear code spanned by  then

\end{proposition}


The proof of this proposition is straightforward and is given in Appendix~\ref{appendixBaldi}. The upper-bound 
given in \eqref{eq:consequence} on the dimension
follows immediately from \eqref{eq:idea}. This leads to Algorithm \ref{algo:Clambdaperp} which computes
a basis of . It is essential that the condition
in \eqref{eq:small_rate} holds in order to distinguish the case when the 
dimension is less than or equal to  from higher dimensions.
\begin{algorithm}[h]
  {\bf Input: } A basis  of .\\
  {\bf Output : } A basis  of .

  \begin{algorithmic}[1]
  \REPEAT \label{re}
   \FOR{}
   \STATE{Randomly choose  in }
   \ENDFOR
   \STATE{ }
\UNTIL{ and }
  \STATE{}
  \STATE{}
  \WHILE{}
    \REPEAT
  \STATE{Randomly choose  in }   
  \STATE{}
\UNTIL{ \AND }
  \STATE{}
  \STATE{}
  \ENDWHILE
    \RETURN{;}
  \end{algorithmic}
  \caption{\label{algo:Clambdaperp}Recovering .}
\end{algorithm}

The first phase of the attack, namely finding a suitable triple  runs 
in expected time of the form  because 
each test in the \textbf{repeat} loop \ref{re} has a chance of
 to succeed. Indeed, 
 is of codimension  in  and therefore
a fraction  of elements of  belongs to .
The whole algorithm runs in expected time of the form 
 since
 and the first phase of the attack  
is dominant in the complexity. Once  is
recovered, it still remains to recover the secret code and . 
The problem at hand can be formulated like this: we know a very large subcode,
namely ,
of a GRS code that we want to recover. This is exactly the problem which was solved in \cite{Wie10}. Applying the approach of this paper to our 
problem amounts to compute   which turns out to be 
equal to  (see \cite{MMP11a} for more details). 
It suffices to use the Sidelnikov and Shestakov algorithm
\cite{SidelShesta92} to compute a 
pair  describing 
as a GRS code.  From this, we deduce a pair  defining 
the secret code  as a GRS code. The final phase, that is, recovering a possible
 pair and using it to decode the public code , is detailed in Appendix \ref{sec:appendix_C}.





\subsection{Using duality when the rate is larger than }

The codes suggested in \cite[\S5.1.1,\S5.1.2]{BBCRS11a} are all of rate significantly larger than ,
for instance Example 1 p.15 suggests a GRS code of length , dimension  over , 
whereas Example 2. p.15 suggests a GRS code of length , dimension  over .
The attack suggested in the previous subsection only applies to rates smaller than .
There is a simple way to adapt the previous attack for this case by
considering the dual   of the public code. Note that by
Proposition \ref{pr:dual},  there exists  in  for which
we have . Moreover,
 displays a similar structure as .
\begin{lemma}\label{lem:structure_dual}
For any  from  there exists an element  in  such that:

\end{lemma}



The proof of this lemma is given in Appendix~\ref{appendixBaldi}. It implies that the whole approach of the previous subsection can be 
carried out over . It allows to recover the secret code  and therefore also . This attack needs
that , that is . In summary, there is an attack as soon as  is outside a narrow interval around
 which is  . We have implemented
this attack on magma for the aforementioned set of parameters suggested
in \cite{BBCRS11a}, namely , ,  
and the average running time over 25 attacks was about 2 weeks.






\newpage

\bibliographystyle{alpha}
\bibliography{crypto}

\newpage
\appendix
  
\newpage 

 \section{Proofs of Section \ref{sec:attack_Baldi}} \label{appendixBaldi}
 
 The first result that will be used throughout this section is a lemma expressing
  in terms of two vectors in :
 \begin{lemma}
 \label{lem:RPi-1}
 Assume that  is of rank , then  is of rank  and there exist  and  in  such that
 
 \end{lemma}
 \begin{proof}
 The dimension of the column space of  is the same as the dimension of the column space of
 . Since  is of rank , this column space has dimension  which implies
 that  is also of rank . From the fact that the column space of  is of dimension , this implies 
 that we can find  and  in  such that 
 
 We let  and .
 \qed
 \end{proof}
 
 From now on we define
 
 
We will also need the following lemma
\begin{lemma}
\label{lem:inverse}
If  is invertible, then so is  and

\end{lemma}
\begin{proof}
We first observe that 
. Therefore
 is invertible if and only if  is invertible.
Moreover

\qed
\end{proof}
 \subsection{Proof of Lemma \ref{lem:structure}}
 
 Let 
 
 Let  be an element of .
 Since  we obtain
  and therefore
 
 From this obtain that there exists  in  such that
 
 
 \subsection{Proof of Proposition \ref{prop:dimension_sqCpub}}
 
 Let  and  be two elements in . By applying Lemma \ref{lem:structure} to them we know that there exist two elements
  and  in  such that
 
 This implies that
 
 
 It will be convenient to bring the notation
 
 In other words with this notation,  is generated by the
 's for  in . 
 Since , there exists  such that
 .
 For  in , let 
 
 
We claim that 
\begin{lemma}\label{lem:dimension}
Let  be the vector space generated by the 's for  in .
The dimension of  is less than or equal to .
\end{lemma}
 \begin{proof}
 We prove that  is generated by the 's for  in .
 This can be proved by noticing that 
 
 \qed
 \end{proof}
 To simplify notation we assume here that  takes precedence over the dot product, that is 
 .
 Observe now that Equation \eqref{eq:long_expression} implies that 
  belongs to .
 The space generated by the 's has therefore a dimension which is is upper-bounded by
 .
 
 
 
 \subsection{Proof of Proposition \ref{prop:three}}
 This follows immediately from the fact that we can express
  in terms of the 's, say
 
 We observe now that we have the following three  relations between the 
's:

\eqref{eq:crossproduct} can be verified as follows

The two remaining identities can be proved in a similar fashion.

\subsection{Proof of Proposition \ref{prop:attack}}
Assume that the 's all belong to . For every  there exists
 in  such that .
We obtain now

This proves the first part of the proposition, the second part follows immediately from 
the first part since it implies that the dimension of
the vector space generated by the 's is upperbounded by the
sum of the dimension of  (that is ) and the dimension of the 
vector space spanned by the 's (which is at most ).

\subsection{Proof of Lemma \ref{lem:structure_dual}}

The key to Lemma \ref{lem:structure_dual} is the fact that the
dual of  is equal to 
. Indeed  and therefore for any element 
of  there exists an  element  of  such that 
. Observe now that every element  in  satisfies
 and that

Therefore . This discussion implies that
there exists an element  in  such that
 
 

\newpage
\section{Recovering  and  from  and }
\label{sec:appendix_C}





\subsection{The structure of  and }

The attack which was given in Section \ref{sec:attack_Baldi} enables to find  and  
which is equal to the intersection . From this we deduce 
 and . These intersections are related to
 and  by

\begin{lemma}
\label{lem:intersection}

\end{lemma}

\begin{proof}
Since it is assumed that , we deduce that
 is a subcode of 
of dimension . Let  be an element of . Notice now that 
 belongs to  from Lemma \ref{lem:structure} and
that   since  by definition of . Therefore .
Since  by assumption, we obtain that . 
This implies that  because the dimension of  is  as explained above.
This proves Equation \eqref{eq:intersection_CC}. 

To prove Equation  \eqref{eq:intersection_CCperp}, let us first compute the
dimension of :

Let  . We first claim that . 

If this were not the case we would have  which would imply that
 and . Consider now an element  of . By Lemma
\ref{lem:structure_dual} we know that there exists  in  such that
. Since , this would imply that  and 
that  would also be in . This would prove that  which would itself 
imply that . This is a contradiction.

We finish the proof similarly to the previous case by invoking Lemma \ref{lem:structure_dual} for an element
 in  and arguing that:\\
(i)  is in  by Lemma \ref{lem:structure_dual},\\
(ii)  because  and therefore .
The equality of both subspaces is proved by a dimension argument (both have dimension ).
\qed
\end{proof}

\subsection{Recovering a valid  pair}

Choose now an arbitrary element  in  and 
choose  any element  in  and any element
 in  such that

 This is obviously possible by arguing on the dimensions of  and
 .
 We are going to show that up to a multiplicative 
constant these two elements can be chosen as a valid  pair, where we use the following definition

\begin{definition}[valid  pair for ]
We say that a couple  of elements of  forms a 
valid  pair for  if and only if \\
(i) ,\\
(ii) for any element  in  there
exists an element  in  such that .
\end{definition}
We will see in Subsection \ref{ss:breaking_Baldi} that we can easily decode  the public code  with the help of 
such a valid  pair.

We first observe that
\begin{lemma}
There exist  and  in ,  in ,  in  such that

\end{lemma}

\begin{proof}
 is a subspace of dimension  which contains  and , 
and therefore also .  does not belong to  since  is assumed to be outside
. This implies that

Since  does not belong to  by definition, there necessarily exist 
 in  and  in  such that

The statement on  is proved similarly.
\qed
\end{proof}

Choose now an arbitrary element  in . Let 

This definition make sense because  by choice of  and
 because  and by the characterization of
the intersection  of Lemma \ref{lem:intersection}.
\begin{proposition}
\label{prop:attack_Baldi}
 is a valid  pair for .
\end{proposition}

\begin{proof}
The first property of an  pair is clearly met:

by using \eqref{eq:av0bv0}.

Let us now prove that for every  in , we have

First consider a  which belongs to . We have

because  from the characterization of  given in Lemma
\ref{lem:intersection} and  because  belongs to  and 
 belongs to . This implies

which belongs to  by definition of .

Let us prove now that 
 also belongs to .
For this purpose we are going to prove that  is orthogonal to all elements of 
.
We achieve this by first proving that  is orthogonal to any element  in the 
intersection :

because  from the fact that  and  and
 by using the characterization of  given in 
Lemma \ref{lem:intersection}. We finish the proof
by  proving that  is also orthogonal to :

This implies that  belongs to . 
Notice now that the mapping 
 is a one-to-one linear mapping whose inverse is given by
 where 
 since  by using 
\eqref{eq:av0bv0}. We have therefore proved that a basis of  is transformed into a basis of  by the mapping
. By linearity of the mapping, we deduce that for any element  in  there
exists an element  in  such that .
\qed
\end{proof}

\subsection{Decoding the public code}\label{ss:breaking_Baldi}

Assume that we have a valid  pair for , say it is .
We want to decode the vector  where  is an error of a certain Hamming weight which 
can be corrected by the decoding algorithm chosen for  and  is an element of the public code. We know that there exists 
 in  such that 

We compute  for all elements 
 in . One of these elements  is equal to   and 
we obtain  in this case. Decoding  in  will reveal  and
this gives  by using \eqref{eq:cv_pv}.

 



\end{document}
