\documentclass{LMCS}
\pdfoutput=1


\def\doi{8(4:8)2012}
\lmcsheading {\doi}
{1--33}
{}
{}
{Oct.~14, 2011}
{Oct.~17, 2012}
{}
 
\usepackage{tikz}
\usetikzlibrary{arrows,automata,shapes,patterns}

\usepackage{latexsym,amssymb,amsmath,ae,aeguill,amscd,stmaryrd,multirow}



\usepackage{enumerate}
\usepackage{hyperref}


\theoremstyle{plain}\newtheorem{proposition}[thm]{Proposition}
\def\eg{{\em e.g.}}
\def\cf{{\em cf.}}

\usepackage{defs}

\begin{document}

\title[Off-line test selection with test purposes 
for non-det. timed automata]{Off-line Test Selection with Test Purposes 
for Non-Deterministic Timed Automata\rsuper*}
\thanks{This work was partly funded by the French project TESTEC (ANR-07-TLOG-022).}

\author[N.~Bertrand]{Nathalie Bertrand\rsuper a}	\address{{\lsuper{a,b}}Inria Rennes - Bretagne Atlantique, Rennes, France}\email{\{nathalie.bertrand, thierry.jeron\}@inria.fr}  

\author[T.~J\'eron]{Thierry J\'eron\rsuper b}	\address{\vskip-6 pt}	

\author[A.~Stainer]{Am\'elie Stainer\rsuper c}	\address{{\lsuper c}University of Rennes 1,  Rennes, France}	\email{amelie.stainer@inria.fr}  


\author[M.~Krichen]{Moez Krichen\rsuper d}	\address{{\lsuper d}University of Sfax, Tunisia}	\email{moez.krichen@redcad.org}  





\keywords{Conformance testing, timed automata, partial observability, urgency,
approximate determinization, game, test purpose}
\subjclass{D.2.4, D.2.5, D.4.7, F.1.1}
\titlecomment{{\lsuper*}This article is based on the material of the TACAS conference paper~\cite{BertrandJeronStainerKrichen-TACASS2011}}




\begin{abstract} 
  \noindent This article proposes novel off-line test generation
  techniques from non-deter\-ministic timed automata with inputs and
  outputs (TAIOs) in the formal framework of the \tioco\, conformance
  theory.  In this context, a first problem is the determinization of
  TAIOs, which is necessary to foresee next enabled actions after an
  observable trace, but is in general impossible because not all timed
  automata are determinizable. This problem is solved thanks to an
  approximate determinization using a game approach.
The algorithm performs an io-abstraction which preserves the
    \tioco\, conformance relation and thus guarantees the soundness of
    generated test cases.
A second problem is the selection of test cases from a TAIO
    specification.  The selection here relies on a precise description
    of timed behaviors to be tested which is carried out by expressive
    test purposes modeled by a generalization of TAIOs.  Finally, an
    algorithm is described which generates test cases in the form of
    TAIOs equipped with verdicts, using a symbolic co-reachability
    analysis guided by the test purpose.  Properties of test cases are
    then analyzed with respect to the precision of the approximate
    determinization: when determinization is exact,
which is the case on known determinizable classes, in addition to
    soundness, properties characterizing the adequacy of test cases
    verdicts are also guaranteed.
\end{abstract}

\maketitle

\section*{Introduction}
\label{sec-intro}




Conformance testing is the process of testing whether some
implementation of a software system 
behaves correctly with respect to its specification.
In this testing framework, 
implementations are considered as {\em black boxes}, \ie the source
code is unknown, only their interface with the environment is known
and used to interact with the tester.  In {\em formal model-based conformance testing},
models are used to  describe  testing artifacts
(specifications, implementations, test cases, ...). 
Moreover, conformance is formally defined as a relation 
between implementations and specifications 
which reflects what are the correct behaviors of the implementation
with respect to those of the specification.
Defining such a relation requires the hypothesis that the implementation
behaves as a model.
Test cases with verdicts, which will be executed against the implementation
in order to check conformance, are generated automatically from the 
specification. 
Test generation algorithms should then ensure
properties relating verdicts of executions of test cases 
with the conformance relation (\eg~soundness),
thus improving the quality of testing compared to manual writing of test cases.

For timed systems, model-based conformance testing has already been
explored in the last decade, with different models and conformance
relations (see \eg~\cite{DBLP:conf/formats/SchmaltzT08} for a
survey), and various test generation
algorithms (e.g.~\cite{BrionesBrinksma-FATES05,KrichenTripakis09,NielsenSkou-STTT03}).
In this context, a very popular model is {\em timed automata with
  inputs and outputs} (TAIOs), a variant of {\em timed automata}
(TAs)~\cite{AlurDill94}, in which the alphabet of observable actions is
partitioned into inputs and outputs.  
We consider here a very general model,
partially observable and non-deterministic TAIOs with
invariants for the modeling of urgency.
We resort to the \tioco\, conformance relation defined for TAIOs~\cite{Krichen-Tripakis-2004}, which is equivalent to the \rtioco\, relation~\cite{Larsen-Mikucionis-Nielsen-2004}.
This relation compares the observable behaviors of timed systems,
made of inputs, outputs and delays, restricting attention to what happens 
after specification traces.
Intuitively, an implementation conforms to a specification if after 
any observable trace of the specification,
outputs and delays observed on the implementation after this trace should 
be allowed  by the specification.

One of the main difficulties encountered in test generation for those
partially observable, non-deterministic TAIOs is determinization.
In fact determinization 
is required in order to foresee the next enabled actions during
execution, and thus to emit a correct verdict depending on whether 
actions observed on the implementation 
are allowed by the specification model after the current observable behavior.
Unfortunately, TAs (and thus TAIOs) are not determinizable in general~\cite{AlurDill94}: the class of deterministic TAs is a strict subclass of TAs. 
Two different approaches have been taken for test generation from timed models,
which induce different treatments of non-determinism. 
\begin{iteMize}{}
\item 
In {\em off-line test generation} test cases are first generated as
timed automata (or timed sequences, or timed transition systems) 
and subsequently
executed on the implementation.  One advantage is that test cases can
be stored and further used \eg~for regression testing and serve for
documentation.  However, due to the non-determinizability of TAIOs,
the approach has often been limited to deterministic or determinizable TAIOs 
(see \eg~\cite{KhoumsiJeronMarchand-FATES03,NielsenSkou-STTT03}).
A notable exception is~\cite{KrichenTripakis09} where the problem is solved by the
use of an over-approximate determinization with fixed resources 
(number of clocks and maximal constant): 
a deterministic automaton with those resources is built, 
which simulates the behaviors of the non-deterministic one.
Another one is 
~\cite{DavidLarsenLiNielsen-ICST09} where winning strategies of
 timed games are used as test cases.
\item In {\em on-line test generation}, test cases are generated
  during their execution.  After the current observed trace, enabled
  actions after this trace are computed from the specification model
  and, either an allowed input is sent to the implementation, or a
  received output or an observed delay is checked.  This technique can
  be applied to any TAIO, as possible observable actions are computed
  only along the current finite execution (the set of possible states
  of the specification model after a finite trace, and their enabled
  actions are finitely representable and computable), thus
  avoiding a complete determinization.  On-line test generation is of
  particular interest to rapidly discover errors, can be applied
    to large and non-deterministic systems, but may sometimes be
  impracticable due to a lack of reactivity (the time needed to
  compute successor states on-line may sometimes be incompatible with
  real-time constraints).
\end{iteMize}
Our feeling is that off-line test generation from timed models 
did not receive much attention because of the inherent difficulty 
of determinization. 
However, recent works on approximate determinization of timed automata~\cite{KrichenTripakis09,BertrandStainerJeronKrichen-FOSSACS2011} 
open the way to new research approaches and results in this domain.





\subsection*{Contribution} 
In this paper, we propose to generate test cases off-line for the whole class of
non-deterministic TAIOs, in the formal context of the \tioco\, conformance
theory.  The determinization problem is tackled thanks to an
approximate determinization with fixed resources in the spirit 
of~\cite{KrichenTripakis09}, using a game
approach allowing to more closely simulate the non-deterministic TAIO~\cite{BertrandStainerJeronKrichen-FOSSACS2011}.
Our approximate determinization method is more precise
than~\cite{KrichenTripakis09} (see~\cite{BertrandStainerJeronKrichen-FOSSACS2011,BertrandStainerJeronKrichen-RR2010} for details), preserves the richness of our model by dealing with partial
observability and urgency, and can be adapted to testing by  
a different treatment of inputs, outputs and delays.  
Determinization is exact for known classes of determinizable TAIOs
(\eg~event-clock TAs, TAs with integer resets, strongly non-Zeno TAs) if
resources are sufficient. 
In the general case, determinization may over-approximate outputs and delays
and under-approximate inputs.
More precisely, it produces a deterministic {\em io-abstraction} of the TAIO 
for a particular {\em io-refinement} relation
which generalizes the one of~\cite{David-Larsen-etal-HSCC10}.  
As a consequence, if test cases are
generated from the io-abstract deterministic TAIO and are sound
for this TAIO, they are guaranteed to be sound for
the original (io-refined) non-deterministic TAIO.


Behaviors of specifications to be tested are identified by means of test purposes. Test purposes are often used in testing practice, 
and are particularly useful when one wants to focus testing
on particular behaviors, \eg~corresponding to requirements 
or suspected behaviors of the implementation.
In this paper they are defined as {\em open timed automata with inputs and
  outputs} (OTAIOs), a model generalizing TAIOs, allowing to precisely
target some behaviors according to actions and clocks of the
specification as well as proper clocks.  
Then, 
in the same spirit as for the TGV tool in the untimed case~\cite{jard04a},  
test selection is performed by a construction relying 
on a co-reachability analysis. 
Produced test cases are in the form of TAIOs, 
while most approaches generate less elaborated 
test cases in the form of timed traces or trees.
In addition to soundness, 
when determinization is exact, 
we also prove an exhaustiveness property,
and two other properties on the adequacy of test case verdicts.
To our knowledge, this whole work constitutes the most general and
advanced off-line test selection approach for TAIOs.

This article is a long version
of~\cite{BertrandJeronStainerKrichen-TACASS2011}. In addition to the
proofs of key properties, it also contains much more details,
explanations, illustrations by examples, complexity considerations,
and a new result on exhaustiveness of the test generation method.

\subsection*{Outline}
The paper is structured as follows. In the next section we introduce
the model of OTAIOs, its semantics, some notations and operations on this model
and the model of TAIOs.
Section 2 recalls the \tioco\, conformance theory for TAIOs, including 
properties of test cases 
relating conformance and verdicts, and introduces an io-refinement
relation which preserves \tioco. Section 3 presents our game approach for
the approximate determinization compatible with the io-refinement.  In
Section 4 we detail the test selection mechanism using test purposes
and prove some properties on generated test cases.
Section 5 discusses some issues related to test case execution 
and test purposes and some related work.


\section{A model of  open timed automata with inputs/outputs}
Timed automata (TAs)~\cite{AlurDill94} is 
a usual model for time constrained systems.
In the context of model-based testing, TAs have been extended 
to timed automata with inputs and outputs (TAIOs) 
whose sets of actions are partitioned into 
inputs, outputs and unobservable actions.
In this section, we further extend TAIOs by partitioning the set of clocks into proper clocks (\emph{i.e.},
controlled by the automaton) and observed clocks (\emph{i.e}, owned by
some other automaton).  
The resulting model of {\em open timed
    automata with inputs/outputs} (OTAIOs for short), allows one to
  describe observer timed automata that can test clock values from
  other automata.
While the sub-model of TAIOs (with only proper
clocks) is sufficient for most testing artifacts (specifications,
implementations, test cases) observed clocks of OTAIOs will be useful
to express test purposes whose aim is to focus on the timed behaviors
of the specification.  Like in the seminal paper for
TAs~\cite{AlurDill94}, we consider OTAIOs and TAIOs with location
invariants to model urgency.


\subsection{Timed automata with inputs/outputs}

We start by introducing notations and useful definitions concerning
TAIOs and OTAIOs.

Given  a finite set of {\it clocks}, 
a {\it clock valuation} is a
mapping , where  
is the set of non-negative real numbers.  
 stands for the valuation assigning  to all clocks.
If  is a valuation over
 and , then  denotes the valuation which assigns
to every clock  the value .
For  we write  for the valuation
equal to  on  and 
assigning  to all clocks of .
Given  a non-negative integer, an {\it -bounded guard} (or
simply guard) over  is a finite conjunction of constraints of the
form  where  and . 
Given  a guard and  a valuation, we write  if  satisfies .  We sometimes abuse notations and write  for
the set of valuations satisfying .  Invariants are restricted
cases of guards: given , an {\em -bounded invariant} over
 is a finite conjunction of constraints of the form 
where  and .  
We denote by  (resp.  )
the set of -bounded guards (resp. invariants) over .




In the sequel, we write  for the disjoint union of sets,
  and use it, when appropriate, to insist on the fact that sets are
  disjoint.



\begin{defi}[OTAIO]
\label{def-ta}
An {\em open timed automaton with inputs and outputs} (OTAIO) is a tuple
 
such that: 
\begin{iteMize}{}
\item  is a finite set of {\em locations}, 
with  the {\em initial location}, 
\item ,  and  
are disjoint finite  {\em alphabets} of
{\em input actions} (noted ), 
{\em output actions} (noted ),
and {\em internal actions} (noted ). 
We note  
for the alphabet of observable actions,
and  
for the whole set of actions.
\item  and  are disjoint finite sets of {\em proper
    clocks} and {\em observed clocks}, respectively.  We note  for the whole set of {\em clocks}.
\item  is the {\em maximal constant} of , 
and we will refer to  as the {\em resources} of ,
\item  is a mapping  which labels each location with an {\em -bounded invariant}, 
\item  is a finite set of {\em edges} where {\em guards} 
are defined on ,
but {\em resets} are restricted to proper clocks in .
\end{iteMize}
\end{defi}\medskip





\noindent One of the reasons for introducing the OTAIO model is to have a
uniform model (syntax and semantics) that will be next specialized for
particular testing artifacts.  In particular, an OTAIO with an empty
set of observed clocks  is a classical TAIO, and will be the
model for specifications, implementations and test cases.  The
partition of actions reflects their roles in the testing context: the
tester cannot observe internal actions, but controls inputs and
observes outputs (and delays).  The set of clocks is also partitioned
into {\em proper clocks}, \ie usual clocks controlled by the system
itself through resets, as opposed to {\em observed clocks} referring
to proper clocks of another OTAIO (\eg~ modeling the system's
environment).  These cannot be reset to avoid intrusiveness, but
synchronization with them in guards and invariants is allowed.
This partition of clocks will be useful for test purposes which
  can have, as observed clocks, some proper clocks of specifications,
  with the aim of selecting time constrained behaviors of
  specifications to be tested.


\begin{figure}[htbp]
\begin{center}
\scalebox{0.65}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

  \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
\node[state, fill=white] (B) [right of=A, node distance=3cm, yshift=1cm] {};
  \node[state, fill=white] (C) [right of=B, node distance=4cm, yshift=0cm] {};
  \node[state, fill=white] (D) [right of=C, node distance=3cm, yshift=0cm] {};
  \node[state, fill=white] (E) [right of=D, node distance=3cm, yshift=0cm] {};
  \node[state, fill=white] (F) [right of=A, node distance=3cm, yshift=-1cm] {};
  \node[state, fill=white] (G) [right of=F, node distance=4cm, yshift=0cm] {};
  \node[state, fill=white] (H) [right of=G, node distance=3cm, yshift=0cm] {};
  \node[state, fill=white] (I) [right of=H, node distance=3cm, yshift=0cm] {};
  \node[state, fill=white, color=white] (A') [left of=A, node distance=2cm, yshift=0cm] {};
  \node[fill=white] (Ae) [above of=A, node distance=.8cm, yshift=0cm] {};
  \node[fill=white] (Ce) [below of=C, node distance=.8cm, yshift=0cm] {};
  \node[fill=white] (De) [below of=D, node distance=.8cm, yshift=0cm] {};
  \node[fill=white] (Ge) [below of=G, node distance=.8cm, yshift=0cm] {};
  \node[fill=white] (He) [below of=H, node distance=.8cm, yshift=0cm] {};
  
  \path (A') edge node [above] {} (A)
        (A) edge node [above,sloped] {} (B)    
        (B) edge node [above] {} (C)   
        (C) edge node [above] {} (D)   
        (D) edge node [above] {} (E)   
        (C) edge [loop above] node [above] {} (C)    
        (A) edge node [above,sloped] {} (F)    
        (F) edge node [above] {} (G)   
        (G) edge node [above] {} (H)   
        (H) edge node [above] {} (I)   
;
\end{tikzpicture}
}
\caption{Specification }\label{ExSpec}
\end{center}
\end{figure}

\begin{exa}
Figure~\ref{ExSpec} represents a TAIO for a specification 
that will serve as a running example in this paper.
Its clocks are , its maximal constant is , 
it has a single input , 
a single output  and 
one internal action .
Informally, its behavior is as follows.
It may stay in the initial location  while ,
and at , has the choice, either to go to  with action ,
or go to  with action  while resetting .
In , it may receive  and move to  
when  is between  and , and reset .
In  it may stay while  and, 
either send  and go to  at , 
or loop silently when   while resetting .
This means that  can be sent at any integer delay after entering
.
In  it may stay while  and move to  when sending .
In , one can move to  before  by receiving  
and resetting  . Due to invariants  in  and 
, the subsequent behavior consists in the immediate 
transmission of two 's.
\end{exa}

\subsection{The semantics of OTAIOs}
Let
 be an OTAIO.
The semantics of  is a {\it timed transition system}
 
where
\begin{iteMize}{}
\item 
 is the set of {\em states} \ie
pairs  consisting in a location and a valuation of clocks;
\item  is the {\em initial state}; 
\item 
 is the set of transition {\em labels}
consisting in either a delay  or a pair   formed by 
an edge  and a set  of observed clocks;
\item 
the  transition relation 
 is the smallest set of the following moves:
\begin{iteMize}{}
\item
{\em Discrete moves:} 
 
whenever there exists  
such that , 
 is an arbitrary subset of observed clocks, 
 and .
Note that  is unconstrained as observed clocks are not controlled by  but by a peer OTAIO. 
\item
{\em Time elapse:}

for  if  
.
\end{iteMize}
\end{iteMize}\medskip
The semantics of OTAIOs generalizes the usual semantics of TAIOs.
The difference lies in the treatment of the additional observed clocks
as the evolution of those clocks is controlled by a peer OTAIO.
The observed clocks evolve at the same speed as the proper clocks, 
thus continuous moves are simply extended to proper and observed clocks.
For discrete moves however, resets of observed clocks are uncontrolled,
thus all possible resets have to be considered.


A  {\it partial run} of  is a finite sequence of subsequent moves
in .
For example 
. 
The sum of 
delays in  is noted  . 
A {\em run} is a partial run starting in .
A state  is {\em reachable} if there exists a run leading to . 
A  state  is {\em co-reachable} from a set  if there is 
a partial run from   to a state in .
We note  the set of reachable states and 
 the set of states co-reachable  from .

A (partial) {\em sequence} is a projection of a (partial) run where
states are forgotten, and discrete transitions are abstracted to
actions and proper resets which are grouped with observed resets.  
As an example, the
sequence corresponding to a run 

 is  where 
 for all .  We then note .  We write  
if there exists
 such that  .  We note 
(respectively ) the set of sequences (resp. partial
sequences) of . For a sequence , 
denotes the sum of delays in .

For a (partial) sequence , 
 denotes the observable behavior obtained by erasing internal actions
and summing delays between observable ones. It is defined inductively as follows:
\begin{iteMize}{}
\item 
,
\item
,
\item 
,
\item 
 if .
\end{iteMize}
For example  and
.  When a trace ends by a
-delay, we sometimes omit it and write \eg~ for .

When concatenating two traces, the last delay of the first trace and
the initial delay of the second one must be added up as follows: if
 and
 then
.  Concatenation allows one to define the notion of prefix. Given a
  trace ,  is a \emph{prefix} of  if there
  exists some  with . Under
  this definition,  is a prefix of .

For a run  projecting onto a sequence , 
we also write  for .  
The set of traces of runs of  is denoted by

\footnote{Notice that formally, a trace always ends with a delay, which can be .
This technical detail is useful later to define verdicts as soon as possible 
without waiting for a hypothetical next action.
}. 



 Two OTAIOs are said
\emph{equivalent} if they have the same sets of traces.

Let  be a trace, 
and  be a state, 
\begin{iteMize}{}
\item 
 denotes the set of
states where  can stay after observing the trace .
\item
 is the set of
enabled delays in  with no  observable action.
\item   (and ) for the set of
outputs and delays (respectively inputs) that can be observed from
.  
For , 
and .
\end{iteMize}
Using these last definitions, 
we will later describe 
the set of 
possible outputs and delays after the trace 
by  .

Notice that all notions introduced for OTAIOs apply to the subclass of TAIOs. 



\subsection{Properties and operations}
A TAIO  is {\em deterministic} (and called a DTAIO) whenever for
any  is a
singleton\footnote{Determinism is only defined (and used in the
  sequel) for TAIOs.  For OTAIOs, the right definition would consider
  the projection of  which forgets values of
  observed clocks, as these introduce ``environmental''
  non-determinism.}.  A TAIO  is {\it determinizable} if there
exists an equivalent DTAIO.  It is well-known that some timed automata
are not determinizable~\cite{AlurDill94}; moreover, the
determinizability of timed automata is an undecidable problem, even
with fixed resources~\cite{Tripakis-ipl06,Finkel-formats06}.

 



An OTAIO  is said {\em complete} if in every location ,
 and for every action , the
disjunction of all guards of transitions leaving  and labeled
by  is .  
This entails that 
,
where  is the projection 
that removes resets of proper clocks in .
This means that  is universal for all the behaviors of its environment.


An OTAIO  is {\em input-complete} in a state , if
 .  
An OTAIO   is input-complete if it is input-complete in all its
reachable states.

An OTAIO
 is {\em non-blocking} if .
This means that it never  blocks the evolution of time, waiting for an input.


For modeling the behavior of composed systems, in particular for
modeling the execution of test cases on implementations, we introduce
the classical parallel product. This operation
consists in the synchronization of two TAIOs on complementary
  observable actions (\eg~ , the emission of  and  its reception)
and induces the intersection of the sets of
traces. It is only defined for \emph{compatible} TAIOs,
  \emph{i.e.}
  
  for  such that ,
  ,
   and
  . 
  \begin{defi}[Parallel product]
\label{def:product}
 The \emph{parallel product} of two compatible TAIOs
   
    
is a TAIO  where:
\begin{iteMize}{}
\item , ,
\item , 
 and 

\item 
\item 
\item  
\item  is the smallest relation such that:
\begin{iteMize}{}
\item for ,  
if  and 
 then
, \ie complementary actions synchronize, corresponding to a communication; 
\item for , ,
if 
then 
, 
\ie internal actions of  progress independently;
\item for , ,
if 
then 
, 
\ie internal actions of  progress independently.
\end{iteMize}
\end{iteMize}
\end{defi}\medskip

\noindent By the definition of the transition relation  of ,
TAIOs synchronize exactly on complementary observable actions and time, 
and evolve independently on internal actions. 
As a consequence, the following equality on traces holds:






Notice that the definition is not absolutely symmetrical, 
as the  direction (input/output) of actions of the product is chosen 
with respect to .
The technical reason is that, 
in the execution of a test case on an implementation,
we will need to keep the directions of actions of the implementation. 

\begin{center}
\begin{figure}[hbt]
\scalebox{0.65}{
\begin{minipage}{0.52\textwidth}
\begin{center}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

   \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
  \node[state, fill=white] (B) [below of=A, node distance=2cm, yshift=0cm] {};
  \node[fill=white] (B') [left of=B, node distance=1.1cm] {};
  \node[state, fill=white] (D) [below of=A, node distance=2cm, xshift=2cm] {};
  \node[state, fill=white] (C) [below of=B, node distance=2cm, yshift=0cm] {};
  \node[fill=white] (C'') [left of=C, node distance=1.1cm] {};
  \node[fill=white] (A') [left of=A, node distance=1.5cm, yshift=1cm] {};
  \node[state, fill=white, color=white, scale=.5] (G) [above of=A, node distance=3cm, yshift=0cm] {};
  \node[fill=white] (C') [left of=C, node distance=3cm, yshift=-.5cm] {};
 
  \path (A) edge node [left] {} (B)
        (A) edge node [above, sloped] {} (D)
        (B) edge node [left] {} (C)
        (G) edge node [right] {} (A)
;
\end{tikzpicture}
\end{center}
\end{minipage}
\begin{minipage}{0.52\textwidth}
\begin{center}
 \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

   \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
  \node[fill=white] (A'') [left of=A, node distance=1.1cm] {};
  \node[state, fill=white] (B) [below of=A, node distance=2cm, yshift=0cm] {};
  \node[state, fill=white] (C) [below of=B, node distance=2cm, yshift=0cm] {};
  \node[state, fill=white] (D) [below of=B, node distance=2cm, xshift=2cm] {};
  \node[fill=white] (A') [left of=A, node distance=1.5cm, yshift=1cm] {};
  \node[state, fill=white, color=white, scale=.5] (G) [above of=A, node distance=3cm, yshift=0cm] {};
  \node[fill=white] (C') [left of=C, node distance=3cm, yshift=-.5cm] {};
 
  \path (A) edge node [left] {} (B)
        (B) edge node [left] {} (C)
        (B) edge node [above, sloped] {} (D)
        (G) edge node [right] {} (A)
;
\end{tikzpicture}
\end{center}
\end{minipage}
 \begin{minipage}{0.52\textwidth}
 \begin{center}
 \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

   \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
  \node[fill=white] (A'') [left of=A, node distance=1.1cm] {};
  \node[state, fill=white] (B) [below of=A, node distance=2cm, yshift=0cm] {};
  \node[fill=white] (B') [left of=B, node distance=1.1cm] {};
  \node[state, fill=white] (C) [below of=B, node distance=2cm, yshift=0cm] {};
  \node[fill=white] (C'') [left of=C, node distance=1.1cm] {};
  \node[fill=white] (A') [left of=A, node distance=2cm, yshift=1cm] {};
  \node[state, fill=white, color=white, scale=.5] (G) [above of=A, node distance=3cm, yshift=0cm] {};
  \node[fill=white] (C') [left of=C, node distance=3cm, yshift=-.5cm] {};


  \path (A) edge node [left] {} (B)
        (B) edge node [left] {} (C)
        (G) edge node [right] {} (A)
;
\end{tikzpicture} \end{center}
 \end{minipage}}

 \caption{Example of a parallel product .}\label{ex_prodpar}\end{figure}   
 \end{center}


\begin{exa}

  The Figure~\ref{ex_prodpar} gives a very simple illustration of the
  parallel product. The intersection of the sets of traces is
  clear. Indeed, the parallel product recognizes exactly all
    prefixes of the trace .  

\end{exa}

We now define a product operation on OTAIOs which extends the
classical product of TAs, with a particular attention to observed
clocks. This product is used later in the paper, to model the action of a test purpose which observes the clocks of a specification.

\begin{defi}[Product]\label{def_product}
Let 
 ,
, be two OTAIOs with same alphabets and disjoint sets of proper clocks ().
Their {\em product} 
is the OTAIO 
 where:
\begin{iteMize}{}
\item 
; 
\item 
;
\item 
, ;
\item 
;
\item
;
\item 
 if
, i=1,2.
\end{iteMize}
\end{defi}


Intuitively,  and  synchronize on both
time and common actions (including internal
ones\footnote{Synchronizing internal actions allows for more
    precision in test selection. This justifies to have a set of
    internal actions in the TAIO model.}).   may
observe proper clocks of  using its observed clocks
, and {\em vice versa}.  The set
of proper clocks of  is the union
of proper clocks of  and , and observed
clocks of  are observed clocks of
any OTAIO which are not proper.  For example, the OTAIO in
Figure~\ref{ExProd} represents the product of the TAIO  in
Figure~\ref{ExSpec} and the OTAIO  of Figure~\ref{ExObj}.

\begin{center}
\begin{figure}[hbt]
\scalebox{0.65}{
\begin{minipage}{0.52\textwidth}
\begin{center}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

   \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
  \node[state, fill=white] (B) [below of=A, node distance=2cm, yshift=0cm] {};
  \node[state, fill=white] (C) [below of=B, node distance=2cm, yshift=0cm] {};
  \node[fill=white] (A') [left of=A, node distance=1.5cm, yshift=1cm] {};
  \node[state, fill=white, color=white, scale=.5] (G) [above of=A, node distance=3cm, yshift=0cm] {};
  \node[fill=white] (C') [left of=C, node distance=3cm, yshift=-.5cm] {};
 
  \path (A) edge node [left] {} (B)
        (B) edge node [left] {} (C)
        (G) edge node [right] {} (A)
;
\end{tikzpicture}
\end{center}
\end{minipage}
\begin{minipage}{0.52\textwidth}
\begin{center}
 \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

   \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
  \node[state, fill=white] (B) [below of=A, node distance=2cm, yshift=0cm] {};
  \node[state, fill=white] (C) [below of=B, node distance=2cm, yshift=0cm] {};
  \node[fill=white] (A') [left of=A, node distance=1.5cm, yshift=1cm] {};
  \node[state, fill=white, color=white, scale=.5] (G) [above of=A, node distance=3cm, yshift=0cm] {};
  \node[fill=white] (C') [left of=C, node distance=3cm, yshift=-.5cm] {};
 
  \path (A) edge node [left] {} (B)
        (B) edge node [left] {} (C)
        (G) edge node [right] {} (A)
;
\end{tikzpicture}
\end{center}
\end{minipage}
 \begin{minipage}{0.52\textwidth}
 \begin{center}
 \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

   \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
  \node[state, fill=white] (B) [below of=A, node distance=2cm, yshift=0cm] {};
  \node[state, fill=white] (C) [below of=B, node distance=2cm, yshift=0cm] {};
  \node[fill=white] (A') [left of=A, node distance=2cm, yshift=1cm] {};
  \node[state, fill=white, color=white, scale=.5] (G) [above of=A, node distance=3cm, yshift=0cm] {};
  \node[fill=white] (C') [left of=C, node distance=3cm, yshift=-.5cm] {};


  \path (A) edge node [left] {} (B)
        (B) edge node [left] {} (C)
        (G) edge node [right] {} (A)
;
\end{tikzpicture} \end{center}
 \end{minipage}}

 \caption{Example of a product .}\label{ex_prod}\end{figure}   
 \end{center}

Contrary to the parallel product, 
the set of traces of the product of two OTAIOs 
is not the intersection of the sets of traces of these TAIOs,
as illustrated by the following example. 

\begin{exa}
  Figure~\ref{ex_prod} artificially illustrates the notion of product
  of two OTAIOs.  One can see that  is a trace of
   and  but is not a trace of .  Indeed, in
  ,  is the trace of a sequence where 
  is not reset at the first action. Unfortunately, the clock  is
  observed by  but is a proper clock of
   which resets it at the first action. As a
  consequence,  cannot be a trace of the product
  . In fact, the second edge
    in  can never be fired, since clocks  and  agree on their values and cannot be
  simultaneously smaller than  and equal to .
\end{exa}

On the other hand, sequences are more adapted to express the underlying operation.
 To compare the sets of sequences of
   with the sets of sequences of
  its factors, we introduce an operation that lifts the sets of clocks
  of factors to the set of clocks of the product: for 
  defined on , and ,
   denotes
  an automaton identical to 
  but defined on
  .  The effect on the semantics is to
  duplicate moves of  with unconstrained resets in
  , so that
  
  strongly bisimulates .  
  The equivalence just consists in ignoring values of added clocks which do not interfere in the guards.
  Similarly
   is
  defined on .  
  Both
   and
   have
  sequences in
  . They synchronize on both delays and common actions with their resets.
The effect of the product is to restrict the respective environments  (observed clocks) 
by imposing the resets of the peer TAIO. 
The sequences of the product  are then characterized by\\

 meaning that the product of OTAIOs is the adequate operation for
intersecting sets of sequences. 


\ignore{On the other hand, the product is the right operation for
intersecting sets of sequences.
In fact, let  (respectively
) denote the same
TAIO  (resp.  ) defined on
 (resp. on
).  Then we get: 

}

An OTAIO  equipped 
with a set of states  can play the role of an acceptor.
A run is  {\em accepted} in  if it ends in .
 denotes the set of sequences of accepted runs
and  the set of their traces.
By abuse of notation, if  is a subset of locations in ,
we note  for  and 
similarly for . 
Note that for the product , if  and 
are subsets of states of  and  respectively, additionally to~(\ref{eq-seq}), the following equality holds:




\section{Conformance testing theory}
\label{sec-conformance}

In this section, we recall the conformance theory for timed automata
based on the conformance relation \tioco~\cite{KrichenTripakis09}
 that formally defines the set of correct
implementations of a given TAIO specification.   is a natural
extension of the  relation of Tretmans~\cite{Tretmans-SCT96} to timed
systems.  We then define test cases, formalize their executions,
verdicts and expected properties relating verdicts to conformance. 
Finally, we introduce a refinement
relation between TAIOs that preserves \tioco, and will be useful in proving 
test case properties.

\subsection{The \tioco~conformance theory}
We consider that the specification is given as a  (possibly
non-deterministic) TAIO .
The implementation is a black box, unknown
except for its alphabet of observable actions, which is the same as
the one of .  
As usual, in order to formally
reason about conformance, we assume that the implementation can be
modeled by an (unknown) TAIO.
Formally:
\begin{defi}[Implementation]
Let  be a specification TAIO.
An implementation of  is an input-complete and non-blocking TAIO

with same observable alphabet as  ( and ).
 denotes the set of possible implementations of .
\end{defi}

The requirements that an implementation is input-complete and non-blocking
will ensure that the execution of a test case on  does not
block before verdicts are emitted.  


Among the possible implementations in , 
the conformance relation  (for {\em timed input-output conformance})~\cite{KrichenTripakis09} 
formally defines which ones conform to ,
naturally extending the classical  relation of Tretmans~\cite{Tretmans-SCT96} to timed
systems:
\begin{defi}[Conformance relation]
Let  be a TAIO representing the specification and  be an implementation of . We say that  conforms to  and write
.
\end{defi}

Note that \tioco\, is equivalent to the \rtioco\, relation  that was defined
independently in~\cite{Larsen-Mikucionis-Nielsen-2004} (see~\cite{DBLP:conf/formats/SchmaltzT08}).
Intuitively,  conforms to  if after any timed trace enabled
in , every output or delay of  is specified in . 
This means that  may accept more inputs than ,
but is authorized to send less outputs, 
or send them during a more restricted time interval. 
The intuition is illustrated on the following simple example:

\begin{exa}
Figure~\ref{imps} represents a specification  and two possible 
implementations  and .
Note that  and  should be input-complete, but for simplicity of figures, 
we omit some inputs and consider that missing inputs loop 
to the current location. It is easy to see that  conforms to .
Indeed, it accepts more inputs, which is allowed
(after the trace ,  can receive  and 
while  only accepts ), 
and emits the output  during a more restricted interval 
of time ( is included in ).
On the other hand  does not conform to  for 
two reasons:
  may send a new output  
and may send  during a larger time interval 
(\eg~
is not included in ~). 
\end{exa}


\begin{center}
\begin{figure}[hbt]
\scalebox{0.65}{
\begin{minipage}{0.45\textwidth}
\begin{center}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

   \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
  \node[state, fill=white] (B) [below of=A, node distance=2cm, yshift=0cm] {};
  \node[state, fill=white] (C) [below of=B, node distance=2cm, yshift=0cm] {};
  \node[fill=white] (C') [left of=C, node distance=1.5cm, yshift=0cm] {};
  \node[state, fill=white, color=white, scale=.5] (G) [left of=A, node distance=3cm, yshift=0cm] {};
 
  \path (A) edge node [left] {} (B)
        (B) edge node [left] {} (C)
        (G) edge node [above] {} (A)
;
\end{tikzpicture}
\end{center}
\end{minipage}
\begin{minipage}{0.45\textwidth}
\begin{center}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

   \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
  \node[state, fill=white] (B) [below of=A, node distance=2cm, yshift=0cm] {};
  \node[state, fill=white] (C) [below of=B, node distance=2cm, yshift=0cm] {};
  \node[fill=white] (C') [left of=C, node distance=1.5cm, yshift=0cm] {};
  \node[state, fill=white, color=white, scale=.5] (G) [left of=A, node distance=3cm, yshift=0cm] {};
   \node[state, fill=white] (D) [right of=B, node distance=2cm, yshift=0cm] {};
  \path (G) edge node [above] {} (A)
        (A) edge node [left] {} (B)
        (B) edge node [left] {} (C)
        (A) edge node [right] {} (D)
;
\end{tikzpicture}
\end{center}
\end{minipage}
 \begin{minipage}{0.45\textwidth}
 \begin{center}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

   \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
  \node[state, fill=white] (B) [below of=A, node distance=2cm, yshift=0cm] {};
  \node[state, fill=white] (C) [below of=B, node distance=2cm, yshift=0cm] {};
  \node[fill=white] (C') [left of=C, node distance=1.5cm, yshift=0cm] {};
  \node[state, fill=white, color=white, scale=.5] (G) [left of=A, node distance=3cm, yshift=0cm] {};
  \node[state, fill=white] (D) [right of=C, node distance=2cm, yshift=0cm] {};
 
  \path (G) edge node [above] {} (A)
        (A) edge node [left] {} (B)
        (B) edge node [left] {} (C)
        (B) edge node [right] {} (D)        
;
 \end{tikzpicture}
 \end{center}
 \end{minipage}}

 \caption{Example of a specification  and two implementations  and .}\label{imps}\end{figure}   
 \end{center}
In practice, conformance is checked by test cases run on implementations.
In our setting, we define test cases as deterministic TAIOs
equipped with verdicts defined by a partition of states.

\begin{defi}[Test suite, test case]
Given a specification TAIO , 
a {\em test suite} is a set of {\em test cases},
where 
a {\em test case} is a pair 
consisting of:
\begin{iteMize}{}
\item a deterministic TAIO 
,
\item a partition  of the set of states 
.
States outside  are called {\em verdict states}. 
\end{iteMize} 
We also require that
\begin{iteMize}{}
\item 
 and ,
\item 
 is non-blocking, (\eg\  for all ),\item 
  is input-complete in all  states, 
meaning that it is ready to receive any input from the implementation
before reaching a verdict.
\end{iteMize}
\end{defi}\medskip


\noindent In the following, for simplicity we will sometimes abuse notations and
write  instead of .  Let us give some intuition about the different verdicts of test
cases.  states are those where the test case rejects an
implementation.  The intention is thus to detect a non-conformance.
 and  states are linked to test purposes (see
Section~\ref{sec-generation}): the intention is that  states
should be those where no non-conformance has been detected and the
test purpose is satisfied, whereas  states should be those
states where no non-conformance has been detected, but the test
purpose cannot be satisfied anymore.   states are all other
states.  We insist on the fact that those are intentional
characterizations of the verdicts. Properties of test cases defined
later specify whether these intentions are satisfied by test cases.
We will see that it is not always the case for all properties.



The execution of a test case  on an implementation 
is  modeled by the parallel product ,
which entails that .
The facts that  is input-complete (in  states) 
and non-blocking 
while  
 is input-complete (in all states) and non-blocking
ensure that no deadlock occurs before a verdict is reached.



We say that the verdict of an execution of trace ,
noted , is , ,  or 
if  is included in the corresponding states
set~\footnote{Note that  being deterministic,  is a singleton.}.  
We write 
if some execution  of  leads  to a 
state, \ie when , which means that there exists  such that 
.
\ignore{~\footnote{The execution of a test case  
on an implementation 
is usually modeled by the standard parallel composition . 
Due to space limitations,  is not defined here,
but we use its trace properties: .}.}
Notice that this is only a possibility to reach the
 verdict among the infinite set of executions of .  
Hitting one of these executions is not ensured both because 
of the lack of control of  
on  and of timing constraints imposed by these executions.


We now introduce soundness, a crucial property ensured by our test generation method. 
We also introduce exhaustiveness 
 and strictness that will be ensured  
when determinization is exact (see Section~\ref{sec-generation}).

\begin{defi}[Test suite soundness, exhaustiveness and strictness]
A  test suite  for  is:
\begin{iteMize}{}
\item {\em sound} if
, , ,
\item {\em exhaustive} if 
, , ,
\item {\em strict} if  .
\end{iteMize}
\end{defi}

Intuitively, soundness means that no conformant implementation can be
rejected by the test suite, \ie any failure of a test case during its
execution characterizes a non-conformance.  Conversely, exhaustiveness means
that every non-conformant implementation may be rejected by the test
suite.  Remember that the definition of 
indicates only a possibility of reject.  Finally, strictness means
that non-conformance is detected once it occurs.  In fact,  means that there is a trace common to 
and  which does not conform to .  The universal
quantification on  and  implies that any such trace will
fail . In particular, this implies that failure will be detected
as soon as it occurs.  





\begin{center}
\begin{figure}[hbt]
\scalebox{0.65}{
\begin{minipage}{0.7\textwidth}
\begin{center}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

   \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
  \node[state, fill=white] (B) [below of=A, node distance=2.5cm, yshift=0cm] {};
  \node[state, fill=white] (C) [below of=B, node distance=2.5cm, yshift=0cm] {};
  \node[fill=white] (C') [left of=C, node distance=2cm, yshift=0cm] {};
  \node[state, fill=white, color=white, scale=.5] (G) [left of=A, node distance=3cm, yshift=0cm] {};
   \node[state, fill=white] (D) [right of=B, node distance=2cm, yshift=1.25cm] {};
   \node[state, fill=white] (E) [right of=C, node distance=2cm, yshift=0cm] {};
  \path (G) edge node [above] {} (A)
        (A) edge node [left] {} (B)
        (B) edge node [left] {} (C)
        (A) edge node [above] {} (D)
        (B) edge node [below] {} (D)
        (B) edge node [right] {} (E)
;
\end{tikzpicture}
\end{center}
\end{minipage}}
 \begin{minipage}{0.5\textwidth}

 \end{minipage}
 \caption{Example of a sound but not strict test suite for the specification  (Figure~\ref{imps}).}\label{ex_sound}\end{figure}   
 \end{center}


\begin{exa}
Figure~\ref{ex_sound} represents a test suite composed of a single test case  for the specification  of the Figure~\ref{imps}. Indeed,  is a TAIO which is input-complete in the  states.
 is sound because
the  states of  are reached only when a conformance error occurs,
\eg~on trace . 
However, this test case can observe non-conformant traces without detecting them, hence  is not strict. For example, ,  and  are non-conformant traces that do not imply a   verdict. 
These traces are \eg~traces of  (Figure~\ref{imps}) which should allow
to detect that .
\end{exa}

\subsection{Refinement preserving \tioco}
We introduce an io-refinement relation between two TAIOs, a
generalization to non-deterministic TAIOs of the 
io-refinement  between DTAIOs introduced
in~\cite{David-Larsen-etal-HSCC10}, itself a generalization of
alternating simulation~\cite{Alur-Henzinger-Kupferman-Vardi-CONCUR98}.
Informally  io-refines  if  specifies more inputs and allows 
less outputs and delays.
As a consequence,  if  and  are specifications,
 is more restrictive than  with respect to conformance.
We thus prove that io-abstraction (the inverse relation) preserves \tioco:
if  conforms to , it also conforms to any io-abstraction
 of .  This will  ensure that  soundness of test cases is
preserved by the approximate determinization defined in Section~\ref{sec-determinisation}.


\begin{defi}
  Let  and  be two TAIOs with same input and output alphabets,
  we say that  {\em io-refines}  (or  {\em io-abstracts}
  ) and note  if

\end{defi}

As we will see below,  is a preorder relation.  
Moreover, as condition (ii)
is always satisfied if  is input-complete, for ,  is equivalent to .
By transitivity of , it follows that io-refinement preserves
conformance (see Proposition~\ref{prop:tioco-alt-sim}).

\begin{lem}
The io-refinement  is a preorder relation.
\end{lem}
\begin{proof}
The relation  is trivially reflexive and we prove that it is transitive.

Suppose that  and .
By definition of  we have:

We want to prove that  thus that

In order to  prove , 
let , and examine the two cases: 
\begin{iteMize}{}
\item If  then  and  
imply     and 
. Thus 
 and we are done.
\item If , 
there exist  
and  such that 
 with  
and   .
As , by  we get that . 
But as , and , 
the condition  induces that ,
and then .
We deduce that  ,  and thus
 .
\end{iteMize}
The proof of  is similar.
\end{proof}



\begin{prop}
\label{prop:tioco-alt-sim}
If  then  , 
.
\end{prop}
\begin{proof}


This proposition is a direct consequence of the transitivity of .
In fact when  is input-complete, by definition , thus condition (ii) of  
trivially holds:
.
Thus  (which is defined by ) is equivalent to .
Now suppose  and  then the transitivity of  gives .
\end{proof}


\begin{figure}[htb]
\scalebox{0.65}{
\begin{minipage}{0.45\textwidth}
\begin{center}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

   \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
  \node[state, fill=white, color=white, scale=.5] (G) [left of=A, node distance=3cm, yshift=0cm] {};
    \node[fill=white] (C) [right of=A, node distance=1cm, yshift=-.5cm] {};
 
  \path (A) edge [loop above] node [right, pos=.8] {} (A)
        (G) edge node [above] {} (A)
;
\end{tikzpicture}
\end{center}
\end{minipage}
\begin{minipage}{0.45\textwidth}
\begin{center}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

   \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
  \node[state, fill=white] (B) [right of=A, node distance=2cm, yshift=0cm] {};
  \node[state, fill=white, color=white, scale=.5] (G) [left of=A, node distance=3cm, yshift=0cm] {};
    \node[fill=white] (C) [right of=B, node distance=1cm, yshift=-.5cm] {};
 
  \path (A) edge [loop above] node [right, pos=.8] {} (A)
        (G) edge node [above] {} (A)
        (A) edge node [above] {} (B)
        (B) edge [loop above] node [right, pos=.8] {} (B)
;
\end{tikzpicture}
\end{center}
\end{minipage}}
\caption{Counter-example to converse of Proposition~\ref{prop:tioco-alt-sim}.}
\label{fig-counter-ex}
\end{figure}

\paragraph{\bf Remark:} unfortunately, the converse of
Proposition~\ref{prop:tioco-alt-sim} is in general false, already in
the untimed case.  
This is illustrated 
in Figure~\ref{fig-counter-ex}.
It is clear that the automaton   accepts all implementations.
 also accepts all implementations as,
from the conformance point of view, when a
specification does not specify an input after a trace, this is
equivalent to specifying this input and then to accept the universal
language on .  
Thus
.
However 
 as 
 
but  .
Notice that this example also works for the untimed case in the  conformance theory.


As a corollary of Proposition~\ref{prop:tioco-alt-sim}, we get that
io-refinement preserves soundness of test suites:
\begin{cor}
\label{cor}
If  
then any sound test suite for  is also sound for .
\end{cor}
\begin{proof}
Let  be a  sound test suite for .
By definition, for any , for any , .
As we have , by Proposition~\ref{prop:tioco-alt-sim}, 
we obtain 
which implies 
that for any , for any , .
Thus  is also sound for .
\end{proof}
In the sequel, this corollary will justify 
our methodology:
from  a non-deterministic TAIO, 
build a deterministic io-abstraction  of ,
then any test case generated from  and sound
is also sound for .
 

\section{Approximate determinization preserving conformance}
\label{sec-determinisation}

We recently proposed a game approach to determinize or provide a
deterministic over-approximation for TAs~\cite{BertrandStainerJeronKrichen-FOSSACS2011}.
Determinization is exact on all known classes of determinizable TAs
(\eg  ~event-clock TAs, TAs with integer resets, strongly non-Zeno TAs) if
resources (number and clocks and maximum constant) are sufficient.  
This
method can be adapted to the context of testing for building a
deterministic io-abstraction of a given TAIO. Thanks to
Proposition~\ref{prop:tioco-alt-sim}, the construction preserves
.



The approximate determinization uses the classical region\footnote{Note that it could be adapted to zones with some loss in precision.}
construction~\cite{AlurDill94}.  As for classical timed automata, the
regions form a partition of valuations over a given set of clocks
which allows to make abstractions in order to decide properties such as
the reachability of a
location.  We note  the set of regions over clocks  with maximal
constant .  A region  is a {\em time-successor} of a region 
if .  Given
   a set of clocks, a relation over  is a finite conjunction 
  of atomic constraints of the form  where ,
   and . When all constants  belong
  to  for some constant  we denote by
   for the set of relations over .
Given a region , we write  for the smallest
relation in  containing . 



\subsection{A game approach to determinize timed automata}
The technique presented
in~\cite{BertrandStainerJeronKrichen-FOSSACS2011} applies first to
TAs, \ie the alphabet only consists of one kind of actions (say output
actions), and the invariants are all trivial. Given such a TA
 over set of clocks , a deterministic TA 
with a new set of clocks  is built, with  as often as possible, or .
Resources of  are fixed, and the goal is to simulate the clocks of  by choosing
the right resets in .  To this aim, letting , a finite
2-player zero-sum turn-based safety game

is built. The two players, Spoiler and Determinizator, alternate moves, the
objective of player Determinizator being to remain in a set of safe
states
where intuitively, for sure no over-approximation has been performed.
In this game, every strategy for Determinizator yields a deterministic
automaton  with , and every
winning strategy induces a deterministic TA  equivalent to
. It is well known that for safety games, winning strategies can be
chosen positional (\emph{i.e.}, only based on the current state) and
computed in linear time in the size of the arena (see
\emph{e.g.}~\cite{mazala-lncs2500}).


The game 
is defined as follows: 
\begin{iteMize}{}
\item  is the set of states of Spoiler.  Each state
  is a pair  where  is a region over
  , and  is a finite set of \emph{configurations}
  of the form  where  is a location of ,  is
  a relation over  with respect to the maximal
  constant , and  is a boolean marker ( or
  ).  A state of Spoiler thus constitutes a state estimate of
  , and the role of the marker  is to indicate whether
  over-approximations possibly happened.
\item  is the
  set of states of Determinizator. Each state 
  consists of a state of Spoiler, together with an action and a region
  over  which role is to remember the last move of Spoiler.
\item , the
  initial state of the game, is a state of Spoiler consisting of a
  single configuration with
the initial location  of , the simple relation 
over : , a marker  (no over-approximation was done so far),
together with the null region over .
\item  and  are inductively defined from  as follows:
\begin{iteMize}{}
\item moves of Spoiler are pairs  and the successor of a
  state  by the move  is simply
  , \ie a copy of  together with a
  challenge for Determinizator consisting in an action  and a
  region , a time-successor of ;
\item moves of Determinizator are resets  and
  the successor of a state  by the
  reset , is the state of Spoiler
   where  and

In words,  is the set of elementary successors of
configurations in  by  and by resetting .  An
elementary successor of a configuration  by a transition
 exists only if the guard  over  induced by the guard  over  through
the relation  intersects . 
Intuitively, the transition is possible in  according to the
state estimate  and the region . The resulting configuration  is such that:
\begin{iteMize}{}
\item  is
the location reached by the transition; 
\item  is the relation between
clocks in  and  after the moves of the two players, that
is after satisfying the guard  in , resetting  and ; 
\item  is a boolean set to
 if both  and the induced guard 
over  implies .  Intuitively,  becomes  when
   encodes more values than , thus an over-approximation
  possibly happens.\end{iteMize}
\end{iteMize}
Note that during the construction of  and , the
states of Determinizator whose successors by  have an empty
set of configurations are removed, together with the moves in
 leading to them.  Indeed these moves have no counterpart in
.
\item . Bad states Determinizator wants to avoid are states where
all configurations are marked , \ie configurations where
an approximation possibly happened.
Note that a single configuration marked  in a state is enough to
ensure that no over-approximation happened. Indeed, for any path in
the game leading to such a state, starting from a -marked
configuration, and taking elementary predecessors, one can build
backwards a sequence of configurations following this path. By
definition of the marker's update, these configurations are all marked
, and the sequence thus corresponds to real traces in the
non-deterministic automaton.
\end{iteMize}



\begin{exa} Figure~\ref{fig:ex-ta} represents a simple non-deterministic timed automaton . 
\begin{figure}[htbp]
\begin{center}
\scalebox{0.65}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

  \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
  \node[state, fill=white] (B) [right of=A, node distance=4cm, yshift=1.5cm] {};
  \node[state, fill=white] (C) [right of=A, node distance=4cm, yshift=-1.5cm] {};
  \node[state, fill=white] (D) [right of=A, node distance=8cm] {};
  \node[state, fill=white, color=white] (E) [left of=A, node distance=1.5cm, yshift=0cm] {};
\node[state, fill=white, color=white] (F) [right of=D, node distance=1.5cm, yshift=0cm] {}
;
  
  \path (A) edge node [above,sloped] {} (B)
        (E) edge (A)
        (A) edge [loop above] node [above] {} (A)
        (A) edge node [below,sloped] {} (C)
	(B) edge node [above,sloped] {} (D)
	(C) edge node [below,sloped] {} (D)      
        (D) edge (F)
;
\end{tikzpicture}}
\caption{Non-deterministic timed automaton .  }\label{fig:ex-ta}
\end{center}
\end{figure}
Let us explain how to construct the game
 for  with resources ,
that is a single clock  and maximal constant .  We only detail
part of the construction in Figure~\ref{fig:ex-game}, but the complete
game can be found in~\cite{BertrandStainerJeronKrichen-FOSSACS2011}.
 \begin{figure}[htb]
\begin{center}
\scalebox{.65}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                     semithick]

   \tikzstyle{every state}=[text=black]

   \node[state, fill=white] [rectangle] (A) {};
   \node[state, fill=white] (A1) [right of=A, node distance=5cm,  
yshift=0cm] {};
   \node[rectangle] (B) [below of=A1, node  
distance=2cm, xshift=0cm] {};
    \node[state, fill=white] [rectangle] (C)  [right of=A1, node  
distance=3.9cm, xshift=0cm] {};
   \node[state, fill=white] (C1)  [right of=C, node distance=5.2cm,  
yshift=0cm] {};
   \node[state, fill=GrisC!90!black] [rectangle] (C11) [right of=C1, node  
distance=4cm, xshift=0cm] {};
   \node[rectangle] (C12) [below of=C1, node  
distance=2cm, xshift=0cm] {};
   \node (C2) [below of=C, node distance=2cm,  
xshift=0cm] {};
   \node (C111) [below of=C11, node distance=2cm,  
xshift=0cm] {};
   \node[fill=white, color=white] (H) [above of=A, node  
distance=1.5cm] {};

   \path (H) edge node [left] {} (A)
         (A) edge node [above] {} (A1)
         (C) edge node [above] {} (C1)
         (C) edge [dashed] node [left] {} (C2)            
         (A1) edge node [above] {} (C)
        (A1) edge [dashed] node [left] {} (B)
         (C1) edge node [above] {} (C11)
         (C11) edge [dashed] node [left] {} (C111)
        (C1) edge [dashed] node [left] {}  (C12)
;

\end{tikzpicture}}
\caption{Part of the game .}
\label{fig:ex-game}
\end{center}
\end{figure}

As defined above, the initial state of the game is simply
. 

From , the only move of Spoiler compatible with behaviors of
 is .
Corresponding transitions in   lead to
locations ,  and , and only in this last
location  has been reset.  Each transition of  yields a
configuration in the next state of Spoiler, and assuming
Determinizator chooses to reset , the three different
configurations are the following:
 \begin{iteMize}{}
 \item one with location , where  (no reset in ) and  (reset in ),
 \item one with location , where  and ,
 \item and one with location , where  (reset in ) and
   .
 \end{iteMize} 
 In the two first configurations, the new relation is
 , that is , and in the
 last configuration, the new relation is simply . As a
 consequence the successor state is . Note that all
 markers are  since the guard on  faithfully represented the
 ones on . 

 From state , if Spoiler chooses the move , it is not
 obvious to which transitions in  this corresponds, and we thus
 explain in details how to compute the successor state. 
First observe that the only configuration in  from which an 
 action is possible is the first one, with location . In this
 configuration, the relation is .  Let us now explain what
 guard over  is induced by the relation  and the region
 .
\begin{figure}[htbp]
\begin{center}
\scalebox{.65}{
\begin{tikzpicture}[scale=2]
\draw [fill=blue!30,color=blue!30]
(0,1) -- (2.9,1) -- (2.9,0) -- (0,0) -- (0,1);

\draw (-0.3,.5) node[right] {\Large{}};
  
\draw [fill=yellow!30,color=yellow!30]
(1,1) -- (2.9,2.9) -- (2.9,1.9) -- (2,1) -- (1,1);

\draw[fill=green!30,color=green!30]
(0,0) -- (1,1) -- (2,1) -- (1,0) -- (0,0);

\begin{scope}[opacity=.6]



\draw [pattern=dots,pattern color =blue]
(0,1) -- (2.9,1) -- (2.9,0) -- (0,0) -- (0,1);
\draw [pattern=north east lines, pattern color=orange]
      (0,0) -- (2.9,2.9) -- (2.9,1.9) -- (1,0) -- (0,0);

\end{scope}
\draw (2.2,1.7) node[right] {\Large{}};
     
  \draw (.7,.5) node[right] {\Large{}};
 \draw[style=help lines] (0,0) grid (2.9,2.9);

  \draw[->] (-0.2,0) -- (3,0) node[right] {\Large{}};
  \draw[->] (0,-0.2) -- (0,3) node[above] {\Large{}};

  \foreach \x/\xtext in {1/1, 2/2}
    \draw[shift={(\x,0)}] (0pt,2pt) -- (0pt,-2pt) node[below] {};

  \foreach \y/\ytext in {1/1, 2/2}
    \draw[shift={(0,\y)}] (2pt,0pt) -- (-2pt,0pt) node[left] {};
\draw[line width= 4pt,color=green!75!black] (0,0) -- (2,0);
  \draw (0.5,-.4) node[right] {\Large{}};
  \draw[line width= 4pt,color=blue] (0,0) -- (0,1);
\end{tikzpicture}}\caption{Construction of the induced guard.
}\label{fig:ind-guard}
\end{center}
\end{figure}
Figure~\ref{fig:ind-guard} illustrates this computation.  The dotted
area represents the set of the valuations over  satisfying
the guard  and the dashed area represents the relation
. The induced guard  (\ie the guard
over  encoded by the guard  on  through the relation ) is
then the projection over clock  of the intersection of these two
areas. In this example, the induced guard is . Therefore, the
transitions of  corresponding to the choice of Spoiler 
are as before the three ones originating in , but this time they
are over-approximated. Indeed, the induced guard 
is not included in the original guard  in , \ie~{\em a priori}
 encodes more values than .  As a consequence, all the
configurations in Spoiler's successor state are marked .
Last, let us detail how the new relations are computed.
Assuming Determinizator chooses not to reset  leads to state ,
in which for the configuration with location , the relation is
the smallest one containing , namely
. The relation for the last configuration in  is
, which is same as
, namely .

\end{exa}



As explained earlier, a strategy for Determinizator chooses in each
state of  a set  of clocks to reset.  With
every strategy  for Determinizator we associate the TA
 obtained by merging a transition of Spoiler
with the transition chosen by Determinizator just after.  The
following theorem links strategies of Determinizator with
deterministic over-approximations of the original traces language and
enlightens the interest of the game:
\begin{thm}[\cite{BertrandStainerJeronKrichen-FOSSACS2011}]
\label{th:game}Let  be a TA, and . For any
strategy  of Determinizator in
,  is a
deterministic timed automaton over resources  and satisfies
. 
Moreover, if  is winning, then
.
\end{thm}
When there is no winning strategy, one can either try to increase
  resources (number of clocks and/or maximal constant), or try to
  choose the best losing strategy, which is a concern.  Indeed, the
  language inclusion seems to be a good criterion to compare two
  losing strategies, but it is not a total ordering.  Alternatively,
  one can use the natural heuristics which tends to lose as late as
  possible (see~\cite{BertrandStainerJeronKrichen-RR2010}).  In
  particular, for a game with  clocks and same maximal constant as
  the original timed automaton, there is a strategy which ensures not
  to lose before  moves (of each players): by choosing to reset a
  new clock at each of its moves, Determinizator ensures 
to perfectly  encode all clocks of the original timed automaton. 
Other
  alternatives would be to consider heuristics based on quantitative
  measures over languages.


\subsection{Extensions to TAIOs and adaptation to \tioco}
In the context of model-based testing, the above-mentioned
determinization technique must be adapted to TAIOs, as detailed
in~\cite{BertrandStainerJeronKrichen-RR2010}, and summarized below.  
The model of TAIOs
is an expressive model of timed automata incorporating internal actions and
invariants.  
Moreover, inputs and outputs must be treated differently
in order to build
from a TAIO  a DTAIO  such that ,
and then to preserve \tioco.


\ignore{
In the context of model-based testing, the alphabet of actions is
partitioned into inputs and outputs \NB{(and internal actions)}. In
order to construct from a specification an approximation while 
preserving conformance, input and output actions have to be treated
differently: successors by outputs need to be over-approximated to
allow for more behaviors whereas successors by inputs must be
under-approximated to specify less behaviors (\NB{clarifier
  encore}). Moreover, it is necessary to be able to deal with models incorporating
internal actions and invariants, since they increase the expressive
power of the specifications by allowing silent transitions and notions
of urgency.


The game approach can be adapted to deal with these issues and the
extensions, detailed in~\cite{BertrandStainerJeronKrichen-RR2010}, are summarized below.  }


\begin{iteMize}{}
\item
\textit{Internal actions} are naturally part of the specification
  model.  They cannot be observed during test executions and should
  thus be removed during determinization.  In order to do so, a
  closure by internal actions is performed for each state during the
  construction of the game, that is, in each state, all the configurations reachable by internal
  actions are added to the set of configurations. To this attempt, states of the game have to be extended since internal 
actions might be enabled from a subset of time-successors 
of the region associated with the state.  Therefore, each
configuration is associated with a proper region which is a
time-successor of the initial region of the state.
The closure by internal actions is effectively computed the same way
as successors in the original construction when Determinizator is
  not allowed to reset any clock.
It is well known that timed automata with silent transitions are
  strictly more expressive than standard timed
  automata~\cite{BerardGastinPetit-STACS96}.  Therefore, our
  approximation can be coarse, but it performs as well as possible
  with its available clock information.
\item
\textit{Invariants} are classically used to model urgency in timed
  systems.
Taking into account urgency of outputs is quite important, indeed
  without the ability to express it, for instance, any dummy system would conform to all specifications. Ignoring all
  invariants in the approximation as done in~\cite{KrichenTripakis09}
  surely yields an io-abstraction: delays (considered as outputs) are
  over-approximated.  In order to be more precise, while preserving
  the io-abstraction relation , with each state of the game
  is associated the most restrictive invariant containing invariants
  of all the configurations in the state.  In the computation of the
  successors, invariants are treated as guards and their validity is
  verified at both ends of the transition.  A state whose
  invariant is strictly over-approximated is treated as unsafe in the
  game.
\item
Rather than over-approximating a given TAIO , we aim here at
building a DTAIO  \textit{io-abstracting}  ().
Successors by outputs are over-approximated as in the original game,
while successors by inputs must be under-approximated. The over-approximated closure by silent transitions is not suitable to under-approximation.
Therefore, states of the game are extended to contain both over-approximated and under-approximated closures.
Thus, the
unsafe successors by an input (where possibly an over-approximation
would occur), are not built.
\end{iteMize}
\begin{exa}
\label{exa3.3}
Figure~\ref{ExProddet} represents a non-deterministic
  timed automaton  that has invariants and internal actions. It
  is a sub-automaton of the timed automaton we use in the next section
  (see Figure~\ref{ExProd}) to illustrate the approximate
  determinization for our test selection.
\begin{figure}[htbp]
\begin{center}
\scalebox{0.65}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

  \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
  \node[state, fill=white] (B) [right of=A, node distance=3.5cm, yshift=1cm] {};
  \node[state, fill=white] (C) [right of=B, node distance=4.5cm, yshift=0cm] {};
  \node[state, fill=white] (F) [right of=A, node distance=3.5cm, yshift=-1cm] {};
  \node[state, fill=white] (G) [right of=F, node distance=4.5cm, yshift=0cm] {};
  \node[state, fill=white, color=white] (A') [left of=A, node distance=2cm, yshift=0cm] {};
  \node[fill=white] (Ae) [below of=A, node distance=.9cm, yshift=0cm] {};
  \node[fill=white] (Ce) [below of=C, node distance=.9cm, yshift=0cm] {};
  \node[fill=white] (Ge) [below of=G, node distance=.85cm, yshift=0cm] {};
  
  \path (A') edge node [above] {} (A)
        (A) edge node [above,sloped] {} (B)    
        (B) edge node [above] {} (C)   
        (C) edge [loop above] node [above] {} (C)    
        (A) edge node [above,sloped] {} (F)    
        (F) edge node [above] {} (G)   
;

\end{tikzpicture}}
\caption{Non-deterministic timed automaton  (with invariants and
  internal actions).  }\label{ExProddet}
\end{center}
\end{figure}

Using this automaton , let us illustrate how the game
construction is adapted to deal with internal actions and invariants,
by detailing part of the game  represented in
Figure~\ref{ExJeudet}.
\begin{figure}[htbp]
\begin{center}
\scalebox{0.7}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

  \tikzstyle{every state}=[text=black]

  \node[state, fill=white] [rectangle] (A)
  {};
  \node[state, fill=white] (AB) [right of=A, node distance=4.8cm, yshift=0cm] {};
  \node[state, fill=white] [rectangle] (B1) [right of=AB, node distance=3.8cm, yshift=1cm] {};
  \node[state, fill=white] (AC) [right of=A, node distance=4.8cm, yshift=-2cm] {};
  \node[fill=white] (C2) [below of=AC, node distance=2cm, yshift=0cm] {};
  \node[state, fill=GrisC!90!black,inner xsep=0] [rectangle] (C1) [right of=AC, node distance=4.2cm, yshift=0cm] {};
  \node[state, fill=white, color=white] (A') [left of=A, node distance=3.7cm, yshift=0cm] {};
    \node[fill=white] (Ae) [below of=A, node distance=1.2cm, yshift=0cm] {};
   \node[fill=white] (C1e) [below of=C1, node distance=1.7cm, xshift=0cm] {};
  \node[fill=white] (B1e) [below of=B1, node distance=.9cm, yshift=0cm] {};
  \node[rectangle] (B2) [above of=AB, node distance=2cm] {};
  
    \path (A') edge node [above] {} (A)
        (A) edge node [above] {} (AB)    
        (AB) edge node [above,pos=.3] {} (B1)   
        (AB) edge [dashed] node [right] {} (B2)   
        (A) edge node [below, sloped] {} (AC)   
        (AC) edge node [above] {} (C1)   
        (AC) edge [dashed] node [right] {} (C2)    
;

\end{tikzpicture}}
\caption{Part of the game .
}\label{ExJeudet}
\end{center}
\end{figure}

A state of Spoiler in the game is a triple  where
 (resp. ) is the under-approximated (resp. over-approximated) closure by unobservable
actions of the successors by some observable action,  is the invariant and  is the marker which indicates a risk of
approximation of the invariant. The invariant and the marker of
Spoiler's states are written below the states.

In the initial state of the game, . Moreover, an internal action  can be fired for
 along two different edges, which add two configurations,
associated with the region  (because  in the first
configuration). Determinizator cannot reset  along an internal
action, hence the relation for the configuration with location
 is . Note that the region  is associated with
the two last configurations in the initial state, reflecting that the
internal action fired and thus the least value for  is .  Also
in this case, the closure (by internal actions) is not approximated,
hence .  
On the other hand, it may be surprising that the invariant of this
initial state is  whereas the invariant of the initial state of
 is .  In fact, the invariant of a state is the smallest
invariant containing the union, over all its configurations, of induced
invariants.  On this example, after an internal action from ,
delays are not constrained anymore in  and 
(invariants are ).  Thus the invariant in the initial state of
the game is not approximated, so its marker is .


From this initial state, Spoiler can choose the regions  or
 together with action . For , this can only happen
from the configuration with location . Indeed, the relation  and the guard  induce a guard  which is not
compatible with the outgoing edge from  in . The
computation of the successor state, \eg~when Determinizator chooses to
reset , is simple: no internal action is fireable and the
invariant in  is precisely expressed by . The situation
is more complex when Spoiler chooses the region : in this case
there are two successors by the observable action  (leading to
locations  and ), and for the first one internal actions
may follow. We thus have to compute the closure by internal actions of
the successor configuration by observable action . Before
computing the closure, and assuming that Determinizator resets clock
, the successor state is composed of two configurations:
 and  together with region
. Along the -loop on location ,  is reset in
 whereas  cannot be reset in the game (because it is an
internal action). Starting from configuration  and performing once the internal action , the
resulting configuration is thus . This
computation is iterated to obtain the closure by internal actions,
which in such a case, will depend on the maximal constant (here
). Indeed, after , the next
configuration is  and starting from
 the effect of one internal action would
yield to . However,  cannot be
expressed in , so it is approximated by the least
relation of  containing it, that is
. Similarly, region  is approximated by . As a
consequence, the configuration  is
approximated by  in . Note that
this latter configuration is in  and thus separated
from configurations in  by two horizontal lines on
Figure~\ref{ExJeudet}.
Moreover, taking the union of all the invariants, we obtain  as
invariant for this state, but since it is approximated for the last
configuration , its marker is .
\end{exa}

All in all, these modifications allow to deal with the full TAIO model
with invariants, internal transitions and inputs/outputs.  In
particular, the treatment of invariants is consistent with the
io-abstraction: delays are considered as outputs, thus
over-approximated.
Figure~\ref{ExJeu} represents a part of this game for the TAIO of Figure~\ref{ExProd}.
The new game then enjoys the following nice
property:\begin{prop}[\cite{BertrandStainerJeronKrichen-RR2010}]
\label{altSim}
  Let  be a TAIO, and . 
  For any
  strategy  of Determinizator in the game
  ,  is a
  DTAIO over resources  with . 
  Moreover, if  is winning, then
  .
\end{prop}

In other words, the approximations produced by our method are
deterministic io-abstractions of the initial specification, hence the
approximate determinization preserves
\tioco~(Proposition~\ref{prop:tioco-alt-sim}), and conversely,
sound test cases of the approximate determinization remain sound for the original specification (Corollary~\ref{cor}).  Note that the proof of
proposition~\ref{altSim} in~\cite{BertrandStainerJeronKrichen-RR2010}
considers a stronger refinement relation, thus implies the same result
for the present refinement relation. In comparison with our method,
the algorithm proposed in~\cite{KrichenTripakis09} always performs an
over-approximation, and thus preserves \tioco~only if the
specification is input-complete; moreover all invariants are
set to  in the resulting automata, so the construction does
not preserve urgency.

\ignore{
\subsection{Properties}

\TJ{A revoir et reduire}
The algorithm proposed in~\cite{KrichenTripakis09} is an over-approximation,
thus preserves \tioco\; only if the specification is input-complete. 
Moreover it does not preserve urgency. 
On the contrary, our method always preserves \tioco, 
and incorporates urgency as much as possible.





\paragraph{Urgency and internal actions}
Concerning expressivity, modeling urgency is quite important. Without
the ability to express urgency, for instance, any system doing nothing
would  conform to any specification. It
is classical to use invariants to model urgency. Our determinization
method allows to preserve them as much as possible. Moreover, in
practice, not all actions are observable. Specifications naturally can
include internal actions but they cannot be observed during test
executions. In the determinization step, these internal actions are
seen as silent transitions.  It is well known that timed automata with silent transitions are
strictly more expressive than standard timed automata~\cite{BerardGastinPetit-STACS96}. 
Therefore, of course, our approximation can be coarse, but it
performs as well as possible with its available clock information.
\paragraph{Conformance}
For test generation, the most important property is the soundness of
the test cases. As a consequence, when generating tests from an
approximation, the approximation should preserve soundness. In other
words, approximation must preserve {\tioco}.  The approximations
produced by our method are deterministic abstractions of the initial
specification, hence, our approach preserves conformance.
Approximations can be more or less precise, information contained in
the game states allows to establish finer verdicts, ensuring in some
cases the strictness of a test.
}


\subsection*{Complexity} The number of regions (resp. relations)
  over a set of clocks is exponential in the number of clocks. Thus,
  the number of possible configurations in the game is at most exponential in the
  cardinality of  and linear in the number of locations in
  . As a consequence, the size of the game (\emph{i.e.}, number of
  states in the arena) is at most doubly exponential in 
  and exponential in . In particular this bound also holds
  for the size of the generated deterministic TAIO, for every
  \emph{memoryless} strategy of Determinizator. The overall complexity
  of this io-abstracting determinization algorithm is thus doubly
  exponential in the size of the instance (original TAIO and
  resources).


\section{Off-line test case generation}
\label{sec-generation}
In this section, we describe the off-line generation of test cases from 
timed automata specifications and test purposes.
We first define test purposes, their role in test generation 
and their formalization as OTAIOs.
We then detail the process of
off-line test selection guided by test purposes, which uses 
the approximate determinization just defined.
We also prove properties of generated test cases with respect 
to conformance and test purposes.

\subsection{Test purposes}

In testing practice, especially when test cases are
generated manually, each test case has a particular objective,
informally described by a sentence called test purpose.
In formal test generation, test purposes should be formal models 
interpreted as means to select behaviors to be tested,
either focusing on usual behaviors, or on suspected errors in
implementations~\cite{jard04a}, thus typically reachability properties.  
They complement other selection mechanisms 
such as coverage methods~\cite{Zhu-Hall-May-97} which, contrary to test purposes,
are most often based on syntactical criteria rather than semantic aspects.
Moreover, the set of goals
covering a given criterion  (\eg~states, transitions, etc) 
may be translated into a set of test purposes,
each test purpose focusing on one such goal.

As test purposes are selectors of behaviors, 
a natural way to formalize them is to use a logical formula
characterizing a set of behaviors 
or an automaton accepting those behaviors.
In this work we choose to describe test purposes as OTAIOs equipped 
with accepting states.
The motivation is to use a model close to the specification model,
easing the description of targeted specification behaviors.
The following definition formalizes test purposes, 
and some alternatives are discussed in Section~\ref{sec-discuss}. 

\begin{defi}[Test purpose]
 Let   be a TAIO specification.
 A {\em test purpose} for  is a pair
   where:
\begin{iteMize}{}
\item  is a complete OTAIO (in
  particular  for any ) with
   ( observes proper clocks of ) and
  ,
\item
   is a subset of trap locations.
\end{iteMize}
\end{defi}

In the following, we will sometimes abuse notations and use 
instead of the pair .  During the test generation
process, test purposes are synchronized with the specification, and
together with their  locations, they will play the role of
acceptors of timed behaviors.  They are non-intrusive in order not to
constrain behaviors of the specification.  This explains why they are
complete, thus allowing all actions in all locations, and are not
constrained by invariants.  They observe behaviors of specifications
by synchronizing with their actions (inputs, outputs and internal
actions) and their proper clocks (by the definition of 
the product (Definition~\ref{def_product}), observed clocks of
 are proper clocks of , which mean that  does not reset
those clocks).  However, in order to add some flexibility in the
description of timed behaviors, they may have their own proper clocks.


\begin{figure}[htbp]
\begin{center}
\scalebox{0.65}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

  \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
\node[state, fill=white] (B) [right of=A, node distance=3cm, yshift=0cm] {};
  \node[state, fill=white] (C) [right of=B, node distance=4cm, yshift=0cm] {};
  \node[state, fill=white] (D) [right of=C, node distance=3cm, yshift=0cm] {};
  \node[state, fill=white] (E) [right of=D, node distance=3cm, yshift=0cm] {};
  \node[state, fill=white] (F) [below of=B, node distance=2cm, yshift=0cm] {};
\node[state, fill=white, color=white] (A') [left of=A, node distance=2cm, yshift=0cm] {};


  \path (A') edge node [above] {} (A)
        (A) edge node [above] {} (B)    
        (B) edge node [above] {} (C)   
        (C) edge node [above] {} (D)   
        (D) edge node [above] {} (E)   
(A) edge node [right] {othw} (F)    
        (B) edge node [right] {othw} (F)   
        (C) edge node [right] {othw} (F)   
        (D) edge node [right] {othw} (F)   
        (F) edge [loop left] node [left] {} (F) 
        (E) edge [loop right] node [right] {} (E) 
;

\end{tikzpicture}
}
\caption{Test purpose .
}\label{ExObj}
\end{center}
\end{figure}

\begin{exa} 
Figure~\ref{ExObj} represents a test purpose  for the specification 
of Figure~\ref{ExSpec}. This one has no proper clock and observes the unique
clock  of .  It accepts sequences where  occurs at ,
followed by an input  at  (thus focusing on the lower branch
of  where  is reset), and two subsequent 's. The label  (for otherwise) on a transition is an abbreviation for the complement of specified transitions leaving the same location.
For example in location ,  stands for 
.
\end{exa}

\subsection{Principle of test generation}

Given a specification TAIO  and a test purpose , the aim is to build a sound and, if possible strict 
test case  focusing on behaviors accepted by .  
As  accepts sequences of , but  test cases observe timed traces,
the intention is that  should deliver  verdicts 
on traces of sequences of  accepted by  in .  
This property is formalized by the following definition: 
\begin{defi}
\label{def:precise}
A test suite  for  and  is said to be {\em precise} 
if for any test case  in ,
for any timed observation  in , 

if and only if 
.
\end{defi}

Let  be the specification
TAIO, and  be a test purpose for ,
with its set  of accepting locations.  The generation of
a test case  from  and  proceeds in several steps.
First, sequences of  accepted by  are identified by the
computation of the product  of those OTAIOs.  Then a
determinization step is necessary to characterize conformant traces as
well as traces of accepted sequences.  Then the resulting
deterministic TAIO  is transformed into a test case TAIO 
with verdicts assigned to states.  Finally, the test case  is
obtained by a selection step which tries to avoid some 
verdicts.  The different steps of the test generation process from
 and  are detailed in the following paragraphs.


\subsubsection*{Computation of the product:} 
First, the product 
is built
(see Definition~\ref{def_product} for the definition of the product), 
associated with the set
of marked locations .
Let . 
As , we get  and , thus  is in fact a TAIO.

The effect of the product is to unfold 
and to mark locations of the product by , 
so that sequences of  accepted by  are identified.
As  is complete, 
,
thus, by the properties of the product (see equation~\ref{eq-seq}),
 
\ie the sequences of the product after removing resets of proper clocks of 
are the sequences of .
As a consequence 
, which entails that  and 
define the same sets of conformant implementations.  

 Considering accepted sequences of the product , 
by equation~\ref{eq-seq-acc} we  get the equality
, 
which induces the desired characterization of accepted traces: 
.

Using the notation  
for the set of prefixes
of traces in a set of traces ,
we note 
for the set of traces of  which are not prefixes of accepted traces of .
In the sequel, 
the principle of test selection will be to try to select traces in
 (and assign to them the  verdict)
and to try to avoid or at least detect (with an  verdict) 
those traces in , as
these traces cannot be prefixes of traces of sequences satisfying the test purpose.

\begin{exa}
Figure~\ref{ExProd} represents the product  for the specification
 in Figure~\ref{ExSpec} and the test purpose  in
Figure~\ref{ExObj}. 
As  describes one branch of , the product is very simple in this case,
\eg~intersection of guards are trivial.
The only difference with  is the  tagging with .
\end{exa}


\begin{figure}[htbp]
\begin{center}
\scalebox{0.65}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

  \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
  \node[state, fill=white] (B) [right of=A, node distance=3.5cm, yshift=1cm] {};
  \node[state, fill=white] (C) [right of=B, node distance=4.5cm, yshift=0cm] {};
  \node[state, fill=white] (D) [right of=C, node distance=3cm, yshift=0cm] {};
  \node[state, fill=white] (E) [right of=D, node distance=3cm, yshift=0cm] {};
  \node[state, fill=white] (F) [right of=A, node distance=3.5cm, yshift=-1cm] {};
  \node[state, fill=white] (G) [right of=F, node distance=4.5cm, yshift=0cm] {};
  \node[state, fill=white] (H) [right of=G, node distance=3cm, yshift=0cm] {};
  \node[state, fill=white] (I) [right of=H, node distance=3cm, yshift=0cm] {};
  \node[state, fill=white, color=white] (A') [left of=A, node distance=2cm, yshift=0cm] {};
  \node[fill=white] (Ae) [above of=A, node distance=.9cm, yshift=0cm] {};
  \node[fill=white] (Ce) [below of=C, node distance=.9cm, yshift=0cm] {};
  \node[fill=white] (De) [below of=D, node distance=.9cm, yshift=0cm] {};
  \node[fill=white] (Ge) [below of=G, node distance=.85cm, yshift=0cm] {};
  \node[fill=white] (He) [below of=H, node distance=.85cm, yshift=0cm] {};
  
  \path (A') edge node [above] {} (A)
        (A) edge node [above,sloped] {} (B)    
        (B) edge node [above] {} (C)   
        (C) edge node [above] {} (D)   
        (D) edge node [above] {} (E)   
        (C) edge [loop above] node [above] {} (C)    
        (A) edge node [above,sloped] {} (F)    
        (F) edge node [above] {} (G)   
        (G) edge node [above] {} (H)   
        (H) edge node [above] {} (I)   
;

\end{tikzpicture}}
\caption{Product .
}\label{ExProd}
\end{center}
\end{figure}

\subsubsection*{Approximate determinization of  into :}
We now want to transform  into a deterministic TAIO 
such that , which  by Proposition~\ref{prop:tioco-alt-sim})
will entail that implementations conformant to  (thus to ) 
are still conformant to . 
If  is already deterministic, we simply take .
Otherwise, 
the approximate determinization of Section~\ref{sec-determinisation} provides a solution.
The user fixes some resources ,
then a deterministic io-abstraction   of  with  resources  is computed.
By Proposition~\ref{altSim}, we thus get that   io-abstracts .
 is equipped with the set of marked locations 
consisting of locations in  containing some configuration
whose location is in . 
As a consequence traces of  which are traces of sequences accepted by  
in  are accepted by  in ,  formally 
.
This means that extra accepted traces may be added due to over-approximations, 
some traces may be lost (including accepted ones) 
by under-approximations, but if the under-approximation preserves
some traces that are accepted in , these are still accepted in .   
If the determinization is exact (or  is already deterministic), 
of course we get more precise relations between the traces and accepted traces of  and ,
namely
  and
.  

\ignore{
\textcolor{red}{
\TJ{on devrait caracteriser
 les traces acceptees dans  par rapport a celles de . 
Or si on a fait une sous-approximation, on peut perdre des traces acceptees,
alors que si on a fait une sur-approximation, on peut en ajouter.
}.
}
}


\begin{exa}
Figure~\ref{ExJeu}
partially represents the game  for the TAIO  of Figure~\ref{ExProd} where,
for readability reasons, some behaviors not co-reachable from
 (dotted green states) are omitted.
Notice that the construction of the initial part of the game was explained  
in Example~\ref{exa3.3}.
A strategy  for Determinizator is represented by bold arrows.
 is not winning (the unsafe configuration, in gray, is unavoidable from the initial state), 
and in fact an approximation is performed.
, represented in Figure~\ref{fig:dp} 
is simply obtained from  and the strategy  
by merging transitions of Spoiler and those of Determinizator in the strategy.
\end{exa}





\begin{figure}[htbp]
\begin{center}
\scalebox{0.7}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

  \tikzstyle{every state}=[text=black]

  \node[state, fill=white] [rectangle] (A)
  {};
\node[state, fill=white] (AB) [right of=A, node distance=4.8cm, yshift=0cm] {};
  \node[state, fill=white] [rectangle] (B1) [right of=AB, node distance=3.3cm, yshift=.7cm] {};
  \node[state, fill=white] (AC) [right of=A, node distance=4.8cm, yshift=-3cm] {};
  \node[fill=white] (C2) [left of=AC, node distance=3cm, yshift=.5cm] {};
  \node[state, fill=GrisC!90!black,inner xsep=0] [rectangle] (C1) [below of=A, node distance=5cm, yshift=0cm] {};
  \node[state, fill=white] (C1F) [right of=C1, node distance=1.6cm, yshift=-3.5cm] {};
\node[state, fill=white] [rectangle] (F) [right of=C1F, node distance=4.5cm, yshift=-0cm] {};
  \node[state, fill=white] (FH) [below of=F, node distance=2.8cm, xshift=2.5cm] {};
  \node[state, fill=green, pattern color= green!75!black, pattern=crosshatch dots] [rectangle] (H) [right of=FH, node
  distance=3.8cm, yshift=0cm]
  {};
\node[color=white] (A') [left of=A, node distance=3.5cm, yshift=0cm] {};
  \node[state, fill=white] (B1V) [right of=B1, node distance=4.2cm, yshift=0cm] {};
  \node[state, fill=white] [rectangle] (V) [right of=B1V, node distance=3cm, yshift=-2cm] {};
  \node[state, fill=white] (VW) [right of=V, node distance=.7cm, yshift=-2cm] {};
  \node[state, fill=green, pattern color= green!75!black, pattern=crosshatch dots] [rectangle] (W) [below of=VW, node distance=2cm, xshift=-.2cm] {};
\node[fill=white] (Ae) [below of=A, node distance=1.2cm, yshift=0cm] {};
   \node[fill=white] (C1e) [above of=C1, node distance=1.7cm, xshift=0cm] {};
   \node[fill=white] (He) [below of=H, node distance=1cm, yshift=0cm] {};
   \node[fill=white] (We) [below of=W, node distance=.8cm, yshift=0cm] {};
  \node[fill=white] (Fe) [above of=F, node distance=.9cm, yshift=0cm] {};
\node[fill=white] (Ve) [above of=V, node distance=.8cm, xshift=1cm] {};
  \node[fill=white] (B1e) [above of=B1, node distance=.8cm, yshift=0cm] {};


  
\node[state, fill=white] [rectangle] (B2) [right of=AB, node distance=3.3cm, yshift=-1.5cm] {};
  \node[state, fill=white] (B2V2) [right of=B2, node distance=4cm, yshift=-1.5cm] {};
  \node[state, fill=white] [rectangle] (V2) [left of=B2V2, node distance=4cm, yshift=-1cm] {};
  \node[state, fill=white] (V2W2) [right of=V2, node distance=4cm, yshift=-1.5cm] {};
  \node[state, fill=green, pattern color=green!75!black, pattern=crosshatch dots] [rectangle] (W2) [below of=V2W2, node distance=1cm, xshift=-4cm] {};
  \node[fill=white] (V2e) [above of=V2, node distance=.8cm, yshift=0cm] {};
  \node[fill=white] (W2e) [above of=W2, node distance=.8cm, yshift=0cm] {};
  \node[fill=white] (B2e) [above of=B2, node distance=.8cm, yshift=0cm] {};
  
  
  \node[fill=white] [ellipse] (D2) [below of=C1, node distance=3.5cm, xshift=-3cm] {};
  \node[fill=white] [ellipse] (D3) [below of=C1, node distance=3.5cm, xshift=-1.5cm] {};
  \node[fill=white] [ellipse] (D4) [below of=C1, node distance=3.5cm, xshift=0cm] {};
  
  \node[state, fill=white] (F2H2) [right of=F, node distance=5.5cm, yshift=0cm] {};
  \node[state, fill=white] [rectangle] (H21) [right of=F2H2, node distance=4cm, yshift=1cm] {}; 
    \node[state, fill=white] [rectangle] (H22) [right of=F2H2, node distance=4cm, yshift=-1cm] {}; 
  
  \node[state, fill=white] (F3H3) [below of=F, node distance=2.7cm, xshift=-1cm] {};
    \node[state, fill=white] [rectangle] (H31) [left of=F3H3, node distance=3.8cm, yshift=-1cm] {}; 
    \node[state, fill=white] [rectangle] (H32) [left of=F3H3, node distance=3.8cm, yshift=1cm] {}; 
    
    
   \node[fill=white] (H21e) [below of=H21, node distance=.85cm, yshift=0cm] {};
   \node[fill=white] (H22e) [below of=H22, node distance=.85cm, yshift=0cm] {};
   \node[fill=white] (H31e) [below of=H31, node distance=.85cm, yshift=0cm] {};
   \node[fill=white] (H32e) [below of=H32, node distance=.85cm, yshift=0cm] {};

  
  \path (A') edge node [above] {} (A)
        (A) edge node [above] {} (AB)    
        (AB) edge [line width=2pt] node [above,pos=.3] {} (B1)   
        (AB) edge node [above] {} (B2)   
        (A) edge node [above, sloped] {} (AC)   
        (AC) edge [line width=2pt] node [above] {} (C1)    
        (AC) edge node [above] {} (C2)    
         (C1) edge node [above,sloped] {} (D2)      
         (C1) edge node [sloped, above] {} (D3)      
         (C1) edge node [sloped, above] {} (D4)    
         (C1) edge node [sloped, above] {} (C1F)       
         (F) edge node [sloped,above] {} (FH)    
         (C1F) edge [line width=2pt] node [above,pos=.3] {} (F)     
         (C1F) edge [bend right] node [above,pos=.3] {} (F)    
         (FH) edge [bend left, line width=2pt] node [above,pos=.3] {} (H)     
         (FH) edge [bend right] node [below,pos=.3] {} (H)    
         (F) edge node [above,sloped] {} (F2H2)      
         (F) edge node [sloped, above] {} (F3H3)     
         (B1) edge node [above] {} (B1V)       
         (V) edge node [right, pos=.6] {} (VW)        
        (B1V) edge [line width=2pt] node [below,pos=.3] {} (V)    
        (VW) edge [bend right, line width=2pt] node [left] {} (W)    
        (B1V) edge [bend left] node [above] {} (V) 
        (VW) edge [bend left] node [right] {} (W) 
(B2) edge node [below, sloped] {} (B2V2)       
         (V2) edge node [below, sloped] {} (V2W2)        
        (B2V2) edge [line width=2pt] node [above,pos=.3] {} (V)    
        (V2W2) edge [line width=2pt] node [above,pos=.4] {} (W)    
        (B2V2) edge node [below] {} (V2) 
        (V2W2) edge node [below] {} (W2) 
        (F2H2) edge [line width=2pt] node [above] {} (H21)    
        (F2H2) edge node [below] {} (H22) 
        (F3H3) edge [line width=2pt] node [below] {} (H31)    
        (F3H3) edge node [above] {} (H32) 

;

\end{tikzpicture}}
\caption{Game .
}\label{ExJeu}
\end{center}
\end{figure}




\begin{figure}[htbp]
\begin{center}
\scalebox{0.65}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

  \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
  \node[state, fill=white] (B) [right of=A, node distance=4cm,
yshift=1.2cm] {};


  \node[state, fill=white] (B1) [above left of=B, node distance=1.8cm,
yshift=1.2cm] {\scriptsize{}};
  \node[state, fill=white] (B2) [above of=B, node distance=1.8cm,
yshift=1.2cm] {\scriptsize{}};
  \node[state, fill=white] (B3) [above right of=B, node distance=1.8cm,
yshift=1.2cm] {\scriptsize{}};


  \node[state, fill=white] (C) [right of=B, node distance=3.5cm,
yshift=0cm] {};

  \node[state, fill=white] (C1) [above  of=C, node distance=1.8cm,
yshift=.9cm] {\scriptsize{}};
  \node[state, fill=white] (C2) [above right of=C, node distance=1.8cm,
yshift=.9cm] {\scriptsize{}};

  \node[state, fill=white] (D) [right of=C, node distance=3.5cm,
yshift=0cm] {\scriptsize{}};
\node[state, fill=white] (F) [right of=A, node distance=4cm,
yshift=-.9cm] {};

  \node[state, fill=white] (G) [right of=F, node distance=3.5cm,
yshift=0cm] {};


\node[fill=white] (Ci) [below of=C, node distance=.8cm, yshift=0cm] {};
 \node[fill=white] (Fi) [below of=F, node distance=.8cm, yshift=0cm] {};
\node[fill=white] (Gi) [below of=G, node distance=.8cm, yshift=0cm] {};



  \node[state, fill=white] (H) [right of=G, node distance=3.5cm,
yshift=0cm] {\scriptsize{\bf }};
  \node[state, fill=white, color=white] (A') [left of=A, node
distance=1.8cm, yshift=0cm] {};


  \path (A') edge node [above] {} (A)
        (A) edge node [below,sloped] {} (F)
        (F) edge node [above] {} (G)
        (G) edge node [above] {} (H)
(A) edge node [above,sloped] {} (B)
        (B) edge node [above] {} (C)
        (C) edge node [above] {} (D);

\path       (B) edge node [left] {\scriptsize{}} (B1)
        (B) edge node [above] {\scriptsize{}} (B2)
        (B) edge node [right] {\scriptsize{}} (B3)
        (C) edge node [left] {\scriptsize{}} (C1)
        (C) edge node [right] {\scriptsize{}} (C2)
;




\end{tikzpicture}}
\end{center}
\caption{Deterministic automaton .}
\label{fig:dp}
\end{figure}


\subsubsection*{Generating   from :}
The next step consists in building a test case  from .
The main point is the computation of verdicts.
  verdicts are simply defined from .
 verdicts that should detect unexpected outputs and delays, 
rely on a complementation. The difficult part is the computation of  
 states
which should detect when  is not reachable 
(or equivalently 
 states, those states where  is still reachable)
and thus relies on an analysis of the co-reachability to locations .
Another interesting point is the treatment of invariants.
First  will have no invariants 
(which ensures that it is non-blocking).
Second, invariants in  
are shifted to guards in  and
in the definition of 
so that 
test cases check that  the urgency specified in  is satisfied by .


The test case constructed from

and  is the pair 
where:
\begin{iteMize}{}
\item  is the TAIO
such that: 
\begin{iteMize}{}
\item  where  is a new
location; 
\item  is the initial location;
\item  and
, \ie input/output alphabets
are mirrored in order to reflect the opposite role of actions in the
synchronization of  and ; 
\item  and
; 
\item ; 
\item  for any ; 
\item  where

\end{iteMize}
\item 
  is the partition of  defined as follows:
\begin{iteMize}{}
\item ,
\item , 
\item ;
\item ,
 \end{iteMize}
\end{iteMize}\medskip

\noindent The important points to understand in the construction of  are
the completion to  and the computation of ,
which, together with ,  define  by complementation.  

For the
completion to , the idea is to detect unspecified outputs and delays 
with respect to .  
Remember that outputs of  are inputs of . 
Moreover, authorized delays in  are defined by invariants, 
but remember that test cases have no invariants (they are  in all locations).
First, all states in , \ie
states where the invariant runs out, are put into 
which reflects the counterpart in  of the urgency in . 
Then, in each location , the invariant  in  is
removed and shifted to guards of all transitions leaving  in
, as defined in .
Second, in any location , for each input , a transition
leading to  is added, labeled with , and whose guard is
the conjunction of  
with the negation of the disjunction of all guards of transitions labeled
by  and leaving  (thus  if no -action leaves
), as defined in .  
It is then easy to see that  is input-complete in all states.

 




The computation of  is based on an analysis of the
co-reachability to .  
 contains all states co-reachable from locations in .  
Notice that the set of states , and thus ,
can be computed symbolically as usual in the region graph
of , or more efficiently using zones.

\begin{exa}
  Figure~\ref{fig:tca} represents the test case  obtained from
  .  For readability reasons, we did not represent transitions in
  , except the one leaving .  In fact these are
  removed in the next selection phase as they are only fireable from
  states where a verdict has already been issued.  The rectangles
  attached to locations represent the verdicts in these locations when
  clock  progresses between 0 and 2, and after 2: dotted green for
  , black for , blue grid for  and
  crosshatched red for .  For example, in , the
  verdict is initially , becomes  if no  is
  received immediately, and even  if no  is received before
  one time unit.  Notice that in order to reach a  verdict, one
  should initially send  after one and strictly before two time
  units, and expect to receive two consecutive 's immediately
  after.
\end{exa}

\begin{figure}[htbp]
\begin{center}
\scalebox{0.65}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

  \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
  \node[state, fill=white] (B) [right of=A, node distance=4cm,
yshift=1.2cm] {};


  \node[state, fill=white] (B1) [above left of=B, node distance=1.8cm,
yshift=1.2cm] {\scriptsize{}};
  \node[state, fill=white] (B2) [above of=B, node distance=1.8cm,
yshift=1.2cm] {\scriptsize{}};
  \node[state, fill=white] (B3) [above right of=B, node distance=1.8cm,
yshift=1.2cm] {\scriptsize{}};


  \node[state, fill=white] (C) [right of=B, node distance=3.5cm,
yshift=0cm] {};

  \node[state, fill=white] (C1) [above  of=C, node distance=1.8cm,
yshift=.9cm] {\scriptsize{}};
  \node[state, fill=white] (C2) [above right of=C, node distance=1.8cm,
yshift=.9cm] {\scriptsize{}};



  \node[state, fill=white] (D) [right of=C, node distance=3.5cm,
yshift=0cm] {\scriptsize{}};
  \node[state, fill=white] (E) [below of=A, node distance=2cm, xshift=0cm]
{};
  \node[state, fill=white] (F) [right of=A, node distance=4cm,
yshift=-.9cm] {};



  \node[state, fill=white] (G) [right of=F, node distance=3.5cm,
yshift=0cm] {};



  \node[state, fill=white] (H) [right of=G, node distance=3.5cm,
yshift=0cm] {\scriptsize{\bf }};
  \node[state, fill=white, color=white] (A') [left of=A, node
distance=1.8cm, yshift=0cm] {};

  \node[fill=white] (Ge) [below of=A, node distance=4.45cm, xshift=7cm]
{\large{}};
  \node[fill=white] (He) [below of=A, node distance=3.75cm, xshift=7cm]
{\large{}};
  \node[fill=white] (Ie) [below of=A, node distance=3.05cm, xshift=6cm]
{\large{}};

  \path (A') edge node [above] {} (A)
        (A) edge node [below,sloped] {} (F)
        (F) edge node [above] {} (G)
        (G) edge node [above] {} (H)
        (A) edge node [left] {} (E)
        (A) edge node [above,sloped] {} (B)
        (B) edge node [above] {} (C)
        (C) edge node [above] {} (D);

\path       (B) edge node [left] {\scriptsize{}} (B1)
        (B) edge node [above] {\scriptsize{}} (B2)
        (B) edge node [right] {\scriptsize{}} (B3)
        (C) edge node [left] {\scriptsize{}} (C1)
        (C) edge node [right] {\scriptsize{}} (C2)
;

\def\rectanglepath{-- ++(.5cm,0cm) -- ++(0cm,.5cm) -- ++(-.5cm,0cm) -- cycle}
\def\rectanglepathone{-- ++(.5cm,0cm) -- ++(0cm,.5cm) -- ++(-.5cm,0cm) -- cycle}
\def\rectanglepathtwo{-- ++(1cm,0cm) -- ++(0cm,.5cm) -- ++(-1cm,0cm) -- cycle}
\def\rectanglepaththree{-- ++(1.5cm,0cm) -- ++(0cm,.5cm) -- ++(-1.5cm,0cm) -- cycle}

\draw [fill=black,color=black] (-1.1,.68) \rectanglepathtwo;
\draw [fill=blue!80!white,color=blue!80!white,pattern color=blue,pattern=grid] (-.1,.68) \rectanglepathone;

\draw [fill=red,color=red,pattern color=red,pattern=crosshatch] (-1.1,-3.21) \rectanglepaththree;


\draw [fill=blue!80!white,color=blue!80!white,pattern color=blue,pattern=grid] (3.3,0.1) \rectanglepaththree;


\draw [fill=blue!80!white,color=blue!80!white,pattern color=blue,pattern=grid] (6.8,0.1) \rectanglepathone;
\draw [fill=red,color=red,pattern color=red,pattern=crosshatch] (7.3,0.1) \rectanglepathtwo;


\draw [fill=green,color=gray,pattern=crosshatch dots,pattern color=green!75!black] (10.3,2.05) \rectanglepaththree;



\draw [fill=red,color=red,pattern color=red,pattern=crosshatch] (3.3,-2.04) \rectanglepaththree;


\draw [fill=red,color=red,pattern color=red,pattern=crosshatch] (6.8,-2.04) \rectanglepaththree;


\draw [fill=green,color=gray,pattern=crosshatch dots,pattern color=green!75!black] (10.3,-2.25) \rectanglepaththree;



\draw [fill=blue!80!white,color=blue!80!white,pattern color=blue,pattern=grid] (1.9,4.25) \rectanglepaththree;
\draw [fill=blue!80!white,color=blue!80!white,pattern color=blue,pattern=grid] (8.1,4.0) \rectanglepaththree;





\def\rectanglepath2{-- ++(.06cm,0cm) -- ++(0cm,.5cm) -- ++(-.06cm,0cm) -- cycle}


\draw [fill=black,color=black] (3.3,0.1) \rectanglepath2;
\draw [fill=black,color=black] (6.8,0.1) \rectanglepath2;

\draw [fill=black,color=black] (3.3,-2.04) \rectanglepath2;
\draw [fill=black,color=black] (6.8,-2.04) \rectanglepath2;



\end{tikzpicture}}
\end{center}
\caption{Test case  with verdicts}
\label{fig:tca}
\end{figure}
















\ignore{
\begin{figure}[htbp]
\begin{center}
\scalebox{0.65}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

  \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
  \node[state, fill=white] (B) [right of=A, node distance=4cm,
yshift=.9cm] {};
  \node[state, fill=white] (C) [right of=B, node distance=3.5cm,
yshift=0cm] {};
  \node[state, fill=white] (D) [right of=C, node distance=3.5cm,
yshift=0cm] {};
  \node[state, fill=white] (E) [below of=A, node distance=2cm, xshift=0cm]
{};
  \node[state, fill=white] (F) [right of=A, node distance=4cm,
yshift=-.9cm] {};
  \node[state, fill=white] (G) [right of=F, node distance=3.5cm,
yshift=0cm] {};
  \node[state, fill=white] (H) [right of=G, node distance=3.5cm,
yshift=0cm] {};
  \node[state, fill=white, color=white] (A') [left of=A, node
distance=1.8cm, yshift=0cm] {};
  \node[fill=white] (Ge) [below of=A, node distance=3.2cm, xshift=6cm]
{\large{}};
  \node[fill=white] (He) [below of=A, node distance=2.5cm, xshift=6cm]
{\large{}};
  \node[fill=white] (Ie) [below of=A, node distance=1.8cm, xshift=6cm]
{\large{}};

  \path (A') edge node [above] {} (A)
        (A) edge node [above,sloped] {} (B)
        (B) edge node [above] {} (C)
        (C) edge node [above] {} (D)
        (A) edge node [left] {} (E)
        (A) edge node [below,sloped] {} (F)
        (F) edge node [above] {} (G)
        (G) edge node [above] {} (H)
;

\end{tikzpicture}}
\caption{Test case }
\label{fig:tc}
\end{center}
\end{figure}
}

\subsubsection*{Selection of :}
So far, the construction of  determines , but does
not perform any selection of behaviors.  A last step consists in
trying to control the behavior of  in order to avoid 
states (thus stay in ),
because reaching  means that  is unreachable, thus  
cannot be satisfied anymore.  
To this aim, guards of transitions of  are refined in the final
test case  in two complementary ways.  First, transitions leaving
a verdict state (,  or ) are useless, because
the test case execution stops when a verdict is issued.  Thus for each
transition, the guard is intersected with the predicate characterizing
the set of valuations associated with  in the source location.
This does not change the verdict of traces.  
Second, transitions
arriving in  states and carrying outputs can be avoided
(outputs are controlled by the test case), thus for any transition
labeled by an output, the guard is intersected with the predicate
characterizing  and  states in the target location (\ie~
states that are not in , as  cannot be reached by an
output).  The effect is to suppress some traces leading to 
states.  
All in all, traces in  are exactly those of  that
traverse only  states (except for the last state), 
and do not end in  with an output.
This selection does not impact on the properties of test suites
(soundness, strictness, precision and exhaustiveness) as will be seen later.

\begin{exa}
Figure~\ref{fig:tc} represents the test case obtained after this selection phase.
One can notice that locations  and 
have been removed since they can only be reached from  states, 
thus a verdict will have been emitted before reaching those locations.
The avoidance of  verdicts by outputs cannot be observed on this example.
However,  with a small modification of  
consisting in adding initially the reception of an   before one time unit, 
and not followed by two 's but \eg~one , the resulting transition 
labeled with  in  could be cut, producing the same . 
\end{exa}











\begin{figure}[htbp]
\begin{center}
\scalebox{0.65}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
                    semithick]

  \tikzstyle{every state}=[text=black]

  \node[state, fill=white] (A) {};
  \node[state, fill=white] (B) [right of=A, node distance=4cm,
yshift=1.2cm] {};


  \node[state, fill=white] (C) [right of=B, node distance=3.5cm,
yshift=0cm] {};



  \node[state, fill=white] (D) [right of=C, node distance=3.5cm,
yshift=0cm] {\scriptsize{}};
  \node[state, fill=white] (E) [below of=A, node distance=2cm, xshift=0cm]
{};
  \node[state, fill=white] (F) [right of=A, node distance=4cm,
yshift=-.9cm] {};



  \node[state, fill=white] (G) [right of=F, node distance=3.5cm,
yshift=0cm] {};



  \node[state, fill=white] (H) [right of=G, node distance=3.5cm,
yshift=0cm] {\scriptsize{\bf }};
  \node[state, fill=white, color=white] (A') [left of=A, node
distance=1.8cm, yshift=0cm] {};

  \node[fill=white] (Ge) [below of=A, node distance=4.45cm, xshift=7cm]
{\large{}};
  \node[fill=white] (He) [below of=A, node distance=3.75cm, xshift=7cm]
{\large{}};
  \node[fill=white] (Ie) [below of=A, node distance=3.05cm, xshift=6cm]
{\large{}};

  \path (A') edge node [above] {} (A)
        (A) edge node [below,sloped] {} (F)
        (F) edge node [above] {} (G)
        (G) edge node [above] {} (H)
        (A) edge node [left] {} (E)
        (A) edge node [above,sloped] {} (B)
        (B) edge node [above] {} (C)
        (C) edge node [above] {} (D);



\def\rectanglepath{-- ++(.5cm,0cm) -- ++(0cm,.5cm) -- ++(-.5cm,0cm) -- cycle}
\def\rectanglepathone{-- ++(.5cm,0cm) -- ++(0cm,.5cm) -- ++(-.5cm,0cm) -- cycle}
\def\rectanglepathtwo{-- ++(1cm,0cm) -- ++(0cm,.5cm) -- ++(-1cm,0cm) -- cycle}
\def\rectanglepaththree{-- ++(1.5cm,0cm) -- ++(0cm,.5cm) -- ++(-1.5cm,0cm) -- cycle}


\draw [fill=black,color=black] (-1.1,.68) \rectanglepath;
\draw [fill=black,color=black] (-.6,.68) \rectanglepath;
\draw [fill=blue!80!white,color=blue!80!white,pattern color=blue,pattern=grid] (-.1,.68) \rectanglepathone;

\draw [fill=red,color=red,pattern color=red,pattern=crosshatch] (-1.1,-3.21) \rectanglepaththree;


\draw [fill=blue!80!white,color=blue!80!white,pattern color=blue,pattern=grid] (3.3,0.1) \rectanglepaththree;


\draw [fill=blue!80!white,color=blue!80!white,pattern color=blue,pattern=grid] (6.8,0.1) \rectanglepathone;
\draw [fill=red,color=red,pattern color=red,pattern=crosshatch] (7.3,0.1) \rectanglepathtwo;


\draw [fill=green!200,color=gray,pattern=crosshatch dots,pattern color=green!75!black] (10.3,2.05) \rectanglepaththree;



\draw [fill=red,color=red,pattern color=red,pattern=crosshatch] (3.3,-2.04) \rectanglepaththree;


\draw [fill=red,color=red,pattern color=red,pattern=crosshatch] (6.8,-2.04) \rectanglepaththree;


\draw [fill=green!200,color=gray,pattern=crosshatch dots,pattern color=green!75!black] (10.3,-2.25) \rectanglepaththree;







\def\rectanglepath2{-- ++(.06cm,0cm) -- ++(0cm,.5cm) -- ++(-.06cm,0cm) -- cycle}

\draw [fill=black,color=black] (3.3,0.1) \rectanglepath2;
\draw [fill=black,color=black] (6.8,0.1) \rectanglepath2;

\draw [fill=black,color=black] (3.3,-2.04) \rectanglepath2;
\draw [fill=black,color=black] (6.8,-2.04) \rectanglepath2;


\end{tikzpicture}}
\end{center}
\caption{Final test case  after selection}
\label{fig:tc}
\end{figure}



\begin{rem}
Notice that in the example, falling into  in  
 could be avoided by adding the invariant ,
with the effect of forcing to output .
More generally, invariants can be added to locations by rendering outputs 
urgent 
in order to avoid , while taking care of keeping test cases non-blocking, \ie\ by ensuring that an output can be done just before the invariant becomes false.
More precisely,  is the projection of  on  if 
 is reachable by letting time elapse and it preserves the non-blocking
property,  otherwise.
\end{rem}



\subsection*{Complexity}
Let us discuss the complexity of the construction of  from
  . Note that the size of TAIO  is linear in the size of
   but the difficulty lies in the computation of
  . Computing  is immediate. 
The set  can be computed in polynomial time (more
  precisely in ). To
  explain this, observe that guards in the TAIO  are regions and
  with each location  is associated an initial region 
  such that guards of transitions leaving  are time successors of
  . Thus during the computation of , for each
  location , one only needs to consider these  different regions in order to determine the
  latest time-successor  of  which is
  co-reachable from . Then  states with location 
  are exactly those within regions that are time-predecessors of
  . For the same reason (number of possible guards
  outgoing a given location)  can be computed in
  polynomial time. Last the  verdicts in locations (except for
  ) are computed in linear time by complementing the
  invariants in .
The test selection can be done by inspecting all transitions: a
  transition is removed if either the source state is a verdict state,
  or it corresponds to an output action and the successor are
   states. This last step thus only requires linear time.
To conclude, the overall complexity of construction of  from
   is polynomial.  

\subsection{Test suite properties}
We have presented the different steps for the generation of 
a TAIO test case from a TAIO specification and an OTAIO test purpose.
The following results express their properties.

\begin{thm}\label{theorem-TC}
  Any test case  built by the procedure is sound for .
  Moreover, if  is an exact approximation of  (\ie
  ), the test case  is also strict
  and precise for  and .
\end{thm}

The proof is detailed below, but we first give some intuition.
As a preamble, notice that, as explained in the paragraph on test selection, 
traces of  are not affected by the construction of .
In particular, the transitions considered in the proof are identical in  and .
Soundness comes from 
the construction of  in  and preservation of soundness by the approximate determinization  of 
given by Corollary~\ref{cor}.
When  is an exact determinization of ,
 and  have same traces, which also equal traces of  
since  is complete. 
Strictness then comes from the fact that  and  
 have the same non-conformant traces,
which are captured by the definition of  in .
Precision comes from  and from the definition of .

When  is not exact however, there is a risk that some
behaviors allowed in  are not in , thus some
non-conformant behaviors are not detected, even if they are executed
by .
Similarly, some  verdicts may be produced for non-accepted 
or even non-conformant behaviors.
However, if a trace in  is present in  and observed during testing, 
a  verdict will be delivered. In other words, precision 
is not  always satisfied, but the ``only if'' direction of 
precision (Definition~\ref{def:precise}) is satisfied.






\begin{proof}

{\bf Soundness:}
To prove soundness, we need to show that for any ,
 implies .

Assuming that , there exists a trace
.  By the
construction of the set  in , there are two cases: either
 leads to a location  in , or
 leads to a state with location .  In the first case,
 where  and  violates the invariant in the location of , and
in the second case, by the construction of ,
 where  and  is unspecified in .  In both cases,
by definition, this means that , which
proves that  is sound for .  Now, as  is an
io-abstraction of  (\ie~ ), by
Corollary~\ref{cor} this entails that  is sound for .
Finally, we have , which trivially implies
that , and thus that  is also sound for .

{\bf Strictness:}
For strictness, in the case where  is an exact approximation of , 
we need to prove that for any ,
 implies that .
Suppose that  . 
By definition, there exists
 and  such that .  
Since  is an exact approximation of , we have 
the equalities , thus  and .  
By construction of  in , it
follows that  which, together with
, implies that .  Thus
 is strict.  

{\bf Precision:}
To prove precision, in the case of exact determinization, 
we have to show that 
for any trace ,
.
The definition of 
  in  
implies that a  verdict is produced for  
exactly when  which equals
   when  is exact.
\end{proof}

\begin{exa}
The test case  of Figure~\ref{fig:tc} comes from an approximate determinization. 
However, the approximation comes after reaching  states.
More precisely, in the gray state of the game in Figure~\ref{ExJeu},
the approximation starts in the time interval .
This state corresponds to location  in 
where the verdict is  as soon as a non null delay is observed.
The test case is thus strict and precise, despite the over-approximation
in the determinization phase.
\end{exa}



In the following, we prove an exhaustiveness property of our test generation method when determinization is exact.
For technical reasons, we need to restrict to a sub-class of TAIOs defined below.
We discuss this restriction later.

\begin{defi}
We say that an OTAIO  is {\em repeatedly observable}
if from any state of , there is a future observable transition,
\ie~ 
, there exists  such that 
 and  .  
\end{defi}


\begin{thm}[Exhaustiveness]
\label{th:exhaustiveness}
Let  be a repeatedly observable TAIO which can be exactly
determinized by our approach.  Then the set of test cases that can be
generated from  by our method is exhaustive.
\end{thm}

\begin{proof}
  Let
  
  be the TAIO specification, and
  
  any non-conformant implementation in .  The idea is
  now to prove that from  and , one can build a test purpose
   such that the test case  built from  and  may
  detect this non-conformance, \ie~.

  By definition of , there exists  and  such that
   but .  Since  is repeatedly observable, there also exists
   and  such that
  .

  As  can be determinized exactly by our approach, there must
  exist some resources  and a strategy  for
  Determinizator in the game  such that
  .



  From the non-conformant implementation , a test purpose
   can be built, with ,  and , and
   but none of its prefixes
  is in .  The construction of  relies on
  the region graph of .  First a TAIO 
  is built which recognizes exactly the traces read along the path
  corresponding to  in the region graph of
  , followed by a transition  with the
  guard corresponding to the one in .  In
  particular it recognizes the trace .  The test
  purpose  is then built such that  accepts in
  its states  the traces of .  Note that 
  should be complete for , thus locations of  should be
  completed by adding loops without resets for all actions in
  , and adding, for all observable actions, transitions
  to a trap location guarded with negations of their guards in .

  Now consider our test generation method applied to  and .
  First  is built, and we consider the game
   with  and
  .  One can then define a strategy  composed
  of the strategy  for the  first clocks, and following the
  resets of  (which is deterministic) for the other clocks
  corresponding to those in .  The construction of
   following the strategy  thus ensures that
   and .

  Finally, let  be the test case built from .  Observe that
  , but . As a consequence, . 
Moreover we have , hence 
   and as
  , we can conclude that  .
\end{proof}

\subsection*{Discussion:}
The hypothesis that  is repeatedly observable is in fact not
restrictive for a TAIO that is determinizable by our approach.
Indeed, such a TAIO can be transformed into a repeatedly observable
one with same conformant implementations, by first determinizing it,
and then completing it as follows.  In all locations, a transition
labeled by an input is added, which goes to a trap state looping for
all outputs, and is guarded by the negation of the union of guards of
transitions for this input in the deterministic automaton.


When  cannot be determinized exactly, the risk is that 
some non-conformance may be undetectable.
However, 
the theorem can be generalized to non-determinizable automata with no resets on internal action.
Indeed, in this case, in the game with resources , 
where  is the length of the finite non-conformant trace ,
the strategy consisting in resetting a new clock at each observable
action allows to remain exact until the observation of non-conformance
(see remark after Theorem~\ref{th:game}).  The proof of
theorem~\ref{th:exhaustiveness} can be adapted using this strategy.







\section{Discussion and related work}
\label{sec-discuss}

\subsection*{Alternative definitions of test purposes}
The definition of test purposes depends on the semantic level at which
behaviors to be tested are described (\eg~sequences, traces).  This
induces a trade-off between the precision of the description of
behaviors, and the cost of producing test suites.  In this work, test
purposes recognize timed sequences of the specification , by a
synchronization with actions and observed clocks.  They also have
their own proper clocks for additional precision.  The advantage is a
fine tuning of selection.  The price to be paid is that, for each test
purpose, the whole sequence of operations, including determinization
which may be costly, must be done.  An alternative is to define test
purposes recognizing timed traces rather than timed sequences.  In
this case, selection should be performed on a deterministic io-abstraction  of
 obtained by an approximate determinization of .  
Then, test purposes should not refer to 's clocks as these
are lost by the approximate determinization.  Test purposes should
then either observe 's clocks, and thus be defined after
determinization, or use only proper clocks in order not to depend on
, at the price of further restricting the expressive power of test
purposes.  In both cases, test purposes should preferably be
deterministic in order to avoid a supplementary determinization after
the product with .  The main advantage of these approaches is that
the specification is determinized only once, which reduces the cost of
producing a test suite.  However, the expressive power of test
purposes is reduced.



\subsection*{Test execution}
Once test cases are selected, it remains to execute them on a real
implementation.  As a test case is a TAIO, and not a simple timed
trace, a number of decisions still need to be taken at each state of
the test case: (1) whether to wait for a certain delay, or to receive
an input or to send an output (2) which output to send, in case there
is a choice.  It is clear that different choices may lead to different
behaviors and verdicts.  Some of these choices can be made either
randomly (\eg~choosing a random time delay, choosing between outputs,
etc), or can be pre-established according to user-defined strategies.
One such policy is to apply a technique similar to the control
approach of~\cite{DavidLarsenLiNielsen-ICST09} whose goal is to avoid
.


Moreover, the tester's time observation capabilities are limited in
practice: testers only dispose of a finite-precision digital clock (a
counter) and cannot distinguish among observations which elude their
clock precision.  Our framework may take this limitation into account.
In~\cite{KrichenTripakis09} assumptions on the tester's digital clock
are explicitly modeled as a special TAIO called , synchronized
with the specification before test generation, then relying to the
untimed case.  We could imagine to use such a  automaton
differently, by synchronizing it with the resulting test case after
generation.



\subsection*{Related work}
As mentioned in the introduction, off-line test selection is in
general restricted to deterministic automata or known classes of
determinizable timed automata.  An exception is the work
of~\cite{KrichenTripakis09} which relies on an over-approximate
determinization.  Compared to this work, our approximate
determinization is more precise (it is exact in more cases), it copes
with outputs and inputs using over- and under-approximations, and
preserves urgency in test cases as much as possible.  Another
exception is the work of~\cite{DavidLarsenLiNielsen-ICST09}, where the
authors propose a game approach whose effect can be understood as a
way to completely avoid , with the possible risk of
missing some or even all traces in
.  Our selection, which allows
to lose this game and produce an  verdict when this happens,
is both more liberal and closer to usual practice.


In several related
works~\cite{KoneCastanetLaurencot-IC3N98,EnNouaryDssouli-Testcom2001},
test purposes are used for test case selection from TAIOs.  In all
these works, test purposes only have proper clocks, thus cannot
observe clocks of the
specification. \ignore{ The advantage of our definition is its generality and a fine
  tuning of selection.  One could argue that the cost of producing a
  test suite can be heavy, as for each test purpose, the whole
  sequence of operations, including determinization, must be done.  In
  order to avoid this, an alternative would be to define test purposes
  recognizing timed traces and perform selection on the approximate
  determinization  of .  But then, the test purpose should not
  use 's clocks as these are lost by determinization.  Then, test
  purposes are either defined after determinization and observe 's
  clocks, or their expressive power is further restricted by using
  only proper clocks in order not to depend on .  }




It should be noticed that selection by test purposes can be used for 
test selection with respect to coverage criteria~\cite{Zhu-Hall-May-97}.
Those coverage criteria define a set of  elements (generally syntactic ones) 
to be covered (\eg~locations, transitions, branches, etc). 
Each element can then be translated into a test purpose, 
the produced test suite covering the given criteria.


\section{Conclusion}
\label{sec-conclusion}


In this article, we presented a complete formalization and operations
for the automatic off-line generation of test cases from
non-deterministic timed automata with inputs and outputs (TAIOs).  The
model of TAIOs is general enough to take into account non-determinism,
partial observation and urgency.  One main contribution is the ability
to tackle any TAIO, thanks to an original approximate determinization
algorithm.  Another main contribution is the selection of test cases
with expressive test purposes described as OTAIOs having the ability
to precisely select behaviors to be tested based on clocks and actions
of the specification as well as proper clocks.  Test cases are
generated as TAIOs using a symbolic co-reachability analysis of the
observable behaviors of the specification guided by the test purpose.

A first perspective of this work is to implement the approach in a
test generation tool.  Currently, the approximate determinization has
been prototyped in Python thanks to a binding of the UPPAAL DBM
library~\cite{uppaal-dbm}.  Other perspectives could be to combine
this approach with the one of~\cite{jeannet05a} for models with data,
for the generation of test cases from models with both time and data
in the spirit of~\cite{amost}, but generalized to non-deterministic
models.


\paragraph{Acknowledgements:} we would like to thank the reviewers for their constructive comments 
that allowed us to improve this article.


\bibliographystyle{abbrv}
\bibliography{tacas}

\end{document}
