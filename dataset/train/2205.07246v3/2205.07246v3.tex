
\documentclass{article} \usepackage{iclr2023_conference,times}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}
\usepackage{booktabs}  
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{cases}
\usepackage{mathrsfs}
\usepackage{subeqnarray}
\usepackage{multirow}
\usepackage{color}
\usepackage{newfloat}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{bbm}
\usepackage{etex}
\usepackage{subfigure}
\usepackage{wrapfig}
\usepackage{xspace}
\usepackage[etex=true,export]{adjustbox}
\usepackage{authblk}
\usepackage[capitalize,noabbrev]{cleveref}
\usepackage{graphicx}

\usepackage{enumitem}
\setlist{leftmargin=4mm}
\renewcommand{\labelitemi}{\raisebox{.3ex}{\rule{.8ex}{.8ex}}}


\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{assumption}[theorem]{Assumption}
\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}

\usepackage[textsize=tiny]{todonotes}
\newcommand{\algorithmname}{Algorithm}
\newcommand{\equationname}{Eq.}
\newcommand{\ourmethod}{FreeMatch\xspace}

\newcommand{\hwx}[1]{{\color{blue}{[(HWX): #1]}}}
\newcommand{\revision}[1]{{\color{black}{#1}}}










\title{FreeMatch: Self-adaptive Thresholding for Semi-supervised Learning}



\author{
\textbf{Yidong Wang}\thanks{\scriptsize{Equal Contribution: yidongwang37@gmail.com, haoc3@andrew.cmu.edu; work done when Yidong was a research intern at MSRA.}}, \textbf{Hao Chen}, \textbf{Qiang Heng}, \textbf{Wenxin Hou}, \textbf{Yue Fan}, \\ \textbf{Zhen Wu}, \textbf{Jindong Wang}\thanks{\scriptsize{Correspondence to: jindong.wang@microsoft.com}}, \textbf{Marios Savvides}, \textbf{Takahiro Shinozaki}, \\ \textbf{Bhiksha Raj}, \textbf{Bernt Schiele}, \textbf{Xing Xie}
}
\affil{\small{Microsoft Research Asia, Tokyo Institute of Technology, Carnegie Mellon University, \\ North Carolina State University, Microsoft STCA,\\ Max-Planck-Institut für Informatik, Nanjing University}}




\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy \begin{document}


\maketitle

\begin{abstract}
    Semi-supervised Learning (SSL) has witnessed great success owing to the impressive performances brought by various methods based on pseudo labeling and consistency regularization.
However, we argue that existing methods might fail to utilize the unlabeled data more effectively since they either use a pre-defined / fixed threshold or an ad-hoc threshold adjusting scheme, resulting in inferior performance and slow convergence. We first analyze a motivating example to obtain intuitions on the relationship between the desirable threshold and model's learning status. Based on the analysis, we hence propose \emph{FreeMatch} to adjust the confidence threshold in a self-adaptive manner according to the model's learning status. We further introduce a self-adaptive class fairness regularization penalty to encourage the model for diverse predictions during the early training stage. Extensive experiments indicate the superiority of FreeMatch especially when the labeled data are extremely rare. FreeMatch achieves \textbf{5.78}\%, \textbf{13.59}\%, and \textbf{1.28}\% error rate reduction over the latest state-of-the-art method FlexMatch on CIFAR-10 with 1 label per class, STL-10 with 4 labels per class, and ImageNet with 100 labels per class, respectively. Moreover, FreeMatch can also boost the performance of imbalanced SSL. The codes can be found at \url{https://github.com/microsoft/Semi-supervised-learning}.\footnote{Note the results of this paper are obtained using TorchSSL~\citep{zhang2021flexmatch}. We also provide codes and logs in USB~\citep{wang2022usb}.}
\end{abstract}


\section{Introduction}

The superior performance of deep learning heavily relies on supervised training with sufficient labeled data~\citep{he2016deep,vaswani2017attention,dong2018speech}.
However, it remains laborious and expensive to obtain massive labeled data.
To alleviate such reliance, semi-supervised learning (SSL)~\citep{zhu2005semi,zhu2009introduction,sohn2020fixmatch,rosenberg2005semi,gong2016multi,kervadec2019curriculum,dai2017good} is developed to improve the model's generalization performance by exploiting a large volume of unlabeled data.
Pseudo labeling \citep{lee2013pseudo,xie2020self,mclachlan1975iterative,rizve2020defense} and consistency regularization \citep{bachman2014learning,samuli2017temporal,sajjadi2016regularization} are two popular paradigms designed for modern SSL.
Recently, their combinations have shown promising results \citep{xie2020unsupervised,sohn2020fixmatch,pham2021meta,xu2021dash,zhang2021flexmatch}. The key idea is that the model should produce similar predictions or the same pseudo labels for the same unlabeled data under different perturbations following the smoothness and low-density assumptions in SSL~\citep{chapelle2006ssl}.



A potential limitation of these threshold-based methods is that they either need a \textit{fixed threshold} \citep{xie2020unsupervised,sohn2020fixmatch,zhang2021flexmatch,guo2022class} or an \textit{ad-hoc threshold adjusting scheme} \citep{xu2021dash} to compute the loss with only confident unlabeled samples.
Specifically, UDA \citep{xie2020unsupervised} and FixMatch \citep{sohn2020fixmatch} retain a fixed high threshold to ensure the quality of pseudo labels.
However, a fixed high threshold ()  could lead to low data utilization in the early training stages and ignore the different learning difficulties of different classes.
Dash \citep{xu2021dash} and AdaMatch \citep{berthelot2021adamatch} propose to gradually grow the fixed \textit{global} (dataset-specific) threshold as the training progresses.
Although the utilization of unlabeled data is improved, their ad-hoc threshold adjusting scheme is arbitrarily controlled by hyper-parameters and thus disconnected from model's learning process.
FlexMatch \citep{zhang2021flexmatch} demonstrates that different classes should have different \textit{local} (class-specific) thresholds.
While the local thresholds take into account the learning difficulties of different classes, they are still mapped from a \emph{pre-defined fixed} global threshold. Adsh \citep{guo2022class} obtains adaptive thresholds from a pre-defined threshold for imbalanced Semi-supervised Learning by optimizing the the number of pseudo labels for each class. In a nutshell, these methods might be incapable or insufficient in terms of adjusting thresholds according to model's learning progress, thus impeding the training process especially when labeled data is too scarce to provide adequate supervision.

\begin{figure}[t!]
\label{fig:two_moon}
\centering    
\hfill
\subfigure[Decision boundary]{\label{fig:two_moon_a}\includegraphics[width=0.25\textwidth]{figures/two_moon_seed1_label2_color_diff.png}}
\hfill
\subfigure[Self-adaptive fairness]{\label{fig:two_moon_b}\includegraphics[width=0.25\textwidth]{figures/two_moon_seed42_label4_fairness.png}}
\hfill
\subfigure[Confi. threshold]{\label{fig:two_moon_c}\includegraphics[width=0.2\textwidth]{figures/two_moon_seed1_label2_thresh.pdf}}
\hfill
\subfigure[Sampling rate]{\label{fig:two_moon_d}\includegraphics[width=0.2\textwidth]{figures/two_moon_seed1_label2_sample.pdf}}
\vspace{-.1in}
\caption{Demonstration of how FreeMatch works on the ``two-moon'' dataset. (a) Decision boundary of FreeMatch and other SSL methods. (b) Decision boundary improvement of self-adaptive fairness (SAF) on two labeled samples per class. (c) Class-average confidence threshold. (d) Class-average sampling rate of FreeMatch during training. The experimental details are in Appendix \ref{append-twomoon}. }
\vspace{-.3in}
\end{figure}



For example, as shown in Figure \ref{fig:two_moon_a}, on the ``two-moon'' dataset with only 1 labeled sample for each class, the decision boundaries obtained by previous methods fail in the low-density assumption. Then, two questions naturally arise: \emph{1) Is it necessary to determine the threshold based on the model learning status?} and \emph{2) How to adaptively adjust the threshold for best training efficiency?}

In this paper, we first leverage a motivating example to demonstrate that different datasets and classes should determine their global (dataset-specific) and local (class-specific) thresholds based on the model's learning status.
Intuitively, we need a low global threshold to utilize more unlabeled data and speed up convergence at early training stages.
As the prediction confidence increases, a higher global threshold is necessary to filter out wrong pseudo labels to alleviate the confirmation bias \citep{arazo2020pseudo}.
Besides, a local threshold should be defined on each class based on the model's confidence about its predictions.
The ``two-moon'' example in \cref{fig:two_moon_a} shows that the decision boundary is more reasonable when adjusting the thresholds based on the model's learning status.

We then propose \emph{\ourmethod} to adjust the thresholds in a \emph{self-adaptive} manner according to learning status of each class~\citep{guo2017calibration}.
Specifically, \ourmethod uses the self-adaptive thresholding (SAT) technique to estimate both the global (dataset-specific) and local thresholds (class-specific) via the exponential moving average (EMA) of the unlabeled data confidence.
To handle barely supervised settings \citep{sohn2020fixmatch} more effectively, we further propose a class fairness objective to encourage the model to produce fair (i.e., diverse) predictions among all classes (as shown in \cref{fig:two_moon_b}).
The overall training objective of \ourmethod maximizes the mutual information between model's input and output \citep{bridle1991unsup}, producing confident and diverse predictions on unlabeled data.
Benchmark results validate its effectiveness.
To conclude, our contributions are:
\begin{itemize}
\item Using a motivating example, we discuss \emph{why} thresholds should reflect the model's learning status and provide some intuitions for designing a threshold-adjusting scheme.
    \item We propose a novel approach, \ourmethod, which consists of Self-Adaptive Thresholding (SAT) and Self-Adaptive class Fairness regularization (SAF). SAT is a threshold-adjusting scheme that is \emph{free} of setting thresholds manually and SAF encourages diverse predictions. 
    \item Extensive results demonstrate the superior performance of \ourmethod on various SSL benchmarks, especially when the number of labels is very limited (e.g, an error reduction of \textbf{5.78}\% on CIFAR-10 with 1 labeled sample per class).
\end{itemize}





\section{A Motivating Example}
\label{seq:theory}
In this section, we introduce a binary classification example to motivate our threshold-adjusting scheme. Despite the simplification of the actual model and training process, the analysis leads to some interesting implications and provides insight into how the thresholds should be set. 

We aim to demonstrate the necessity of the self-adaptability and increased granularity in confidence thresholding for SSL.
Inspired by \citep{yang2020rethinking}, we consider a binary classification problem where the true distribution is an even mixture of two Gaussians (i.e., the label  is equally likely to be positive () or negative ()). The input  has the following conditional distribution:


We assume  without loss of generality.
Suppose that our classifier outputs confidence score ,
where  is a positive parameter that reflects the model learning status and it is expected to gradually grow during training as the model becomes more confident. Note that  is in fact the Bayes' optimal linear decision boundary.  We consider the scenario where a fixed threshold  is used to generate pseudo labels. A sample  is assigned pseudo label  if  and  if . The pseudo label is  (masked) if .

\textbf{We then derive the following theorem to show the necessity of self-adaptive threshold:}


\begin{theorem}
\label{theorem1}
For a binary classification problem as mentioned above, the pseudo label  has the following probability distribution:

where  is the cumulative distribution function of a standard normal distribution. Moreover,  increases as  gets smaller.
\end{theorem} 





The proof is offered in Appendix \ref{append-proof}.
\cref{theorem1} has the following implications or interpretations:
\begin{enumerate}[label=(\roman*)]
\setlength\itemsep{0em}
    \item Trivially, unlabeled data utilization (sampling rate)  is directly controlled by threshold . As the confidence threshold  gets larger, the unlabeled data utilization gets lower. At early training stages, adopting a high threshold may lead to low sampling rate and slow convergence since  is still small.
    
    \item More interestingly,  if . In fact, the larger  is, the more imbalanced the pseudo labels are. This is potentially undesirable in the sense that we aim to tackle a balanced classification problem. Imbalanced pseudo labels may distort the decision boundary and lead to the so-called pseudo label bias. An easy remedy for this is to use class-specific thresholds  and  to assign pseudo labels.
   
    \item The sampling rate  decreases as  gets smaller. In other words, the more similar the two classes are, the more likely an unlabeled sample will be masked. As the two classes get more similar, there would be more samples mixed in feature space where the model is less confident about its predictions, thus a moderate threshold is needed to balance the sampling rate. Otherwise we may not have enough samples to train the model to classify the already difficult-to-classify classes.
\end{enumerate} 

The intuitions provided by \cref{theorem1} is that at the early training stages,  should be low to encourage diverse pseudo labels, improve unlabeled data utilization and fasten convergence.
However, as training continues and  grows larger, a consistently low threshold will lead to unacceptable confirmation bias.
Ideally, the threshold  should increase along with  to maintain a stable sampling rate throughout.
Since different classes have different levels of intra-class diversity (different ) and some classes are harder to classify than others ( being small), a fine-grained \emph{class-specific} threshold is desirable to encourage fair assignment of pseudo labels to different classes.
The challenge is how to design a threshold adjusting scheme that takes all implications into account, which is the main contribution of this paper.
We demonstrate our algorithm by plotting the average threshold trend and marginal pseudo label probability (i.e. sampling rate) during training in \cref{fig:two_moon_c} and \ref{fig:two_moon_d}.
To sum up, we should determine global (dataset-specific) and local (class-specific) thresholds by estimating the learning status via predictions from the model.
Then, we detail \ourmethod. \looseness=-1

\section{Preliminaries}
\label{sec-pre}

In SSL, the training data consists of labeled and unlabeled data.
Let  and \footnote{.} be the labeled and unlabeled data, where  and  is their number of samples, respectively. 
The supervised loss for labeled data is:

where  is the batch size,  refers to cross-entropy loss,  means the stochastic data augmentation function, and  is the output probability from the model.

For unlabeled data, we focus on pseudo labeling using cross-entropy loss with confidence threshold for entropy minimization. We also adopt the ``Weak and Strong Augmentation'' strategy introduced by UDA \citep{xie2020unsupervised}. Formally, the unsupervised training objective for unlabeled data is:

We use  and  to denote abbreviation of  and , respectively.  is the hard ``one-hot'' label converted from ,  is the ratio of unlabeled data batch size to labeled data batch size, and  is the indicator function for confidence-based thresholding with  being the threshold.
The weak augmentation (i.e., random crop and flip) and strong augmentation (i.e., RandAugment \cite{cubuk2020randaugment}) is represented by  and  respectively. 


Besides, a fairness objective  is usually introduced to encourage the model to predict each class at the same frequency, which usually has the form of  \citep{krause2010disc}, where  is a uniform prior distribution. One may notice that using a uniform prior not only prevents the generalization to non-uniform data distribution but also ignores the fact that the underlying pseudo label distribution for a mini-batch may be imbalanced due to the sampling mechanism. The uniformity across a batch is essential for fair utilization of samples with per-class threshold, especially for early-training stages.



\section{FreeMatch}

\begin{figure}[!t]
    \centering
    \includegraphics[width=0.6\textwidth]{figures/pipelinev4.pdf}
    \caption{Illustration of Self-Adaptive Thresholding (SAT). \ourmethod adopts both global and local self-adaptive thresholds computed from the EMA of prediction statistics from unlabeled samples. Filtered (masked) samples are marked with red X.
    }
    \label{fig:pipeline}
    \vspace{-.1in}
\end{figure}

\subsection{Self-Adaptive Thresholding}

We advocate that the key to determining thresholds for SSL is that thresholds should reflect the learning status.
The learning effect can be estimated by the prediction confidence of a well-calibrated model \citep{guo2017calibration}.
Hence, we propose \textit{self-adaptive thresholding} (SAT) that automatically defines and adaptively adjusts the confidence threshold for each class by leveraging the model predictions during training.
SAT first estimates a global threshold as the EMA of the confidence from the model.
Then, SAT modulates the global threshold via the local class-specific thresholds estimated as the EMA of the probability for each class from the model.
When training starts, the threshold is low to accept more possibly correct samples into training.
As the model becomes more confident, the threshold adaptively increases to filter out possibly incorrect samples to reduce the confirmation bias.
Thus, as shown in \cref{fig:pipeline}, we define SAT as  indicating the threshold for class  at the -th iteration. 





\paragraph{Self-adaptive Global Threshold}

We design the global threshold based on the following two principles.
First, the global threshold in SAT should be related to the model's confidence on unlabeled data, reflecting the overall learning status.
Moreover, the global threshold should stably increase during training to ensure incorrect pseudo labels are discarded.
We set the global threshold  as average confidence from the model on unlabeled data, where  represents the -th time step (iteration).
However, it would be time-consuming to compute the confidence for all unlabeled data at every time step or even every training epoch due to its large volume.
Instead, we estimate the global confidence as the exponential moving average (EMA) of the confidence at each training time step.
We initialize  as  where  indicates the number of classes.
The global threshold  is defined and adjusted as:

where  is the momentum decay of EMA.

\paragraph{Self-adaptive Local Threshold}

The local threshold aims to modulate the global threshold in a class-specific fashion to account for the intra-class diversity and the possible class adjacency.
We compute the expectation of the model’s predictions on each class  to estimate the class-specific learning status:

where  is the list containing all .
Integrating the global and local thresholds, we obtain the final self-adaptive threshold  as: 

where  is the Maximum Normalization (i.e., ). 
Finally, the unsupervised training objective  at the -th iteration is:




\subsection{Self-Adaptive Fairness}
\label{sec-fairness}

We include the class fairness objective as mentioned in \cref{sec-pre} into FreeMatch to encourage the model to make diverse predictions for each class and thus produce a meaningful self-adaptive threshold, especially under the settings where labeled data are rare.
Instead of using a uniform prior as in \citep{arazo2020pseudo}, we use the EMA of model predictions  from \revision{Eq.~\ref{eq-salt}} as an estimate of the expectation of prediction distribution over unlabeled data.
We optimize the cross-entropy of  and  over mini-batch as an estimate of .
Considering that the underlying pseudo label distribution may not be uniform, we propose to modulate the fairness objective in a self-adaptive way, i.e., normalizing the expectation of probability by the histogram distribution of pseudo labels to counter the negative effect of imbalance as:

Similar to , we compute  as:


The self-adaptive fairness (SAF)  at the -th iteration is formulated as:

where . SAF encourages the expectation of the output probability for each mini-batch to be close to a marginal class distribution of the model, after normalized by histogram distribution.
It helps the model produce diverse predictions especially for barely supervised settings \citep{sohn2020fixmatch}, thus converges faster and generalizes better.
This is also showed in \cref{fig:two_moon_b}.



The overall objective for \ourmethod at -th iteration is:

where  and  represents the loss weight for  and  respectively.
With  and , \ourmethod maximizes the mutual information between its outputs and inputs.
We present the procedure of \ourmethod in \cref{alg:freematch} of Appendix.

\section{Experiments}

\subsection{Setup}

We evaluate \ourmethod on common benchmarks: CIFAR-10/100~\citep{krizhevsky2009learning}, SVHN~\citep{netzer2011reading}, STL-10~\citep{coates2011analysis} and ImageNet~\citep{deng2009imagenet}.
Following previous work~\citep{sohn2020fixmatch,xu2021dash,zhang2021flexmatch,oliver2018realistic}, we conduct experiments with varying amounts of labeled data. In addition to the commonly-chosen labeled amounts, following~\citep{sohn2020fixmatch}, we further include the most challenging case of CIFAR-10: each class has only \emph{one} labeled sample.

For fair comparison, we train and evaluate all methods using the unified codebase TorchSSL~\citep{zhang2021flexmatch} with the same backbones and hyperparameters.
Concretely, we use Wide ResNet-28-2 \citep{zagoruyko2016wide} for CIFAR-10, Wide ResNet-28-8 for CIFAR-100, Wide ResNet-37-2~\citep{zhou2020time} for STL-10, and ResNet-50~\citep{he2016deep} for ImageNet. We use SGD with a momentum of  as optimizer. The initial learning rate is  with a cosine learning rate decay schedule as , where  is the initial learning rate,  is the current (total) training step and we set  for all datasets.
At the testing phase, we use an exponential moving average with the momentum of  of the training model to conduct inference for all algorithms.
The batch size of labeled data is  except for ImageNet where we set .
We use the same weight decay value, pre-defined threshold , unlabeled batch ratio  and loss weights introduced for Pseudo-Label \citep{lee2013pseudo},  model \citep{rasmus2015semi}, Mean Teacher \citep{tarvainen2017mean}, VAT \citep{miyato2018virtual}, MixMatch \citep{berthelot2019mixmatch}, ReMixMatch \citep{berthelot2019remixmatch}, UDA \citep{xie2020unsupervised}, FixMatch \citep{sohn2020fixmatch}, and FlexMatch \citep{zhang2021flexmatch}.

We implement MPL based on UDA as in \citep{pham2021meta}, where we set temperature as 0.8 and  as 10. We do not fine-tune MPL on labeled data as in \citep{pham2021meta} since we find fine-tuning will make the model overfit the labeled data especially with very few of them. For Dash, we use the same parameters as in \citep{xu2021dash} except we warm-up on labeled data for 2 epochs since too much warm-up will lead to the overfitting (i.e. 2,048 training iterations).
For \ourmethod, we set  for all experiments. Besides, we set  for CIFAR-10 with 10 labels, CIFAR-100 with 400 labels, STL-10 with 40 labels, ImageNet with 100k labels, and all experiments for SVHN. For other settings, we use .
For SVHN, we find that using a low threshold at early training stage impedes the model to cluster the unlabeled data, thus we adopt two training techniques for SVHN: (1) warm-up the model on only labeled data for 2 epochs as Dash; and (2) restrict the SAT within the range .
The detailed hyperparameters are introduced in Appendix \ref{append-hyper}.
We train each algorithm 3 times using different random seeds and report the best error rates of all checkpoints~\citep{zhang2021flexmatch}.











\begin{table}[!t]
\centering
\caption{Error rates on CIFAR-10/100, SVHN, and STL-10 datasets. The fully-supervised results of STL-10 are unavailable since we do not have label information for its unlabeled data. \textbf{Bold} indicates the best result and \underline{underline} indicates the second-best result. \revision{The significant tests and average error rates for each dataset can be found in Appendix~\ref{append-sig}}.}
\label{tab-main}
\resizebox{\textwidth}{!}{\begin{tabular}{l|cccc|ccc|ccc|cc}
\toprule
Dataset & \multicolumn{4}{c|}{CIFAR-10}& \multicolumn{3}{c|}{CIFAR-100}& \multicolumn{3}{c|}{SVHN} & \multicolumn{2}{c}{STL-10} \\ \cmidrule(r){1-1}\cmidrule(lr){2-5}\cmidrule(lr){6-8}\cmidrule(lr){9-11}\cmidrule(l){12-13}\,

\# Label & \multicolumn{1}{c}{10} & \multicolumn{1}{c}{40} & \multicolumn{1}{c}{250}  & \multicolumn{1}{c|}{4000} & \multicolumn{1}{c}{400}  & \multicolumn{1}{c}{2500}  & \multicolumn{1}{c|}{10000} & \multicolumn{1}{c}{40}  & \multicolumn{1}{c}{250}   & \multicolumn{1}{c|}{1000} & \multicolumn{1}{c}{40}  & \multicolumn{1}{c}{1000}\\ \cmidrule(r){1-1}\cmidrule(lr){2-5}\cmidrule(lr){6-8}\cmidrule(lr){9-11}\cmidrule(l){12-13} \,
 
 Model \citep{rasmus2015semi} & 79.18{\scriptsize 1.11} & 74.34{\scriptsize 1.76} & 46.24{\scriptsize 1.29} & 13.13{\scriptsize 0.59} & 86.96{\scriptsize 0.80} & 58.80{\scriptsize 0.66} & 36.65{\scriptsize 0.00} & 67.48{\scriptsize 0.95} & {13.30\scriptsize 1.12} & 7.16{\scriptsize 0.11}  & 74.31{\scriptsize 0.85} & 32.78{\scriptsize 0.40} \\
Pseudo Label \citep{lee2013pseudo} & 80.21{\scriptsize 0.55}& 74.61{\scriptsize 0.26}  & 46.49{\scriptsize 2.20} & 15.08{\scriptsize 0.19} & 87.45{\scriptsize 0.85} & 57.74{\scriptsize 0.28} & 36.55{\scriptsize 0.24} & 64.61{\scriptsize 5.6} & 15.59{\scriptsize 0.95}  & 9.40{\scriptsize 0.32}  & 74.68{\scriptsize 0.99} & 32.64{\scriptsize 0.71} \\
VAT \citep{miyato2018virtual} & 79.81{\scriptsize 1.17} & 74.66{\scriptsize 2.12} & 41.03{\scriptsize 1.79} & 10.51{\scriptsize 0.12} & 85.20{\scriptsize 1.40} & 46.84{\scriptsize 0.79} & 32.14{\scriptsize 0.19} & 74.75{\scriptsize 3.38} & 4.33{\scriptsize 0.12} & 4.11{\scriptsize 0.20} & 74.74{\scriptsize 0.38}  & 37.95{\scriptsize 1.12} \\
MeanTeacher \citep{tarvainen2017mean} & 76.37{\scriptsize 0.44} & 70.09{\scriptsize 1.60} & 37.46{\scriptsize 3.30} & 8.10{\scriptsize 0.21} & 81.11{\scriptsize 1.44} & 45.17{\scriptsize 1.06} & 31.75{\scriptsize 0.23} & 36.09{\scriptsize 3.98} & 3.45{\scriptsize 0.03} & 3.27{\scriptsize 0.05}  & 71.72{\scriptsize 1.45} & 33.90{\scriptsize 1.37} \\
 MixMatch \citep{berthelot2019mixmatch} & 65.76{\scriptsize 7.06} & 36.19{\scriptsize 6.48} & 13.63{\scriptsize 0.59} & 6.66{\scriptsize 0.26} & 67.59{\scriptsize 0.66} & 39.76{\scriptsize 0.48} & 27.78{\scriptsize 0.29} & 30.60{\scriptsize 8.39} & 4.56{\scriptsize 0.32} & 3.69{\scriptsize 0.37}  & 54.93{\scriptsize 0.96} & 21.70{\scriptsize 0.68} \\
 ReMixMatch \citep{berthelot2019remixmatch} & 20.77{\scriptsize 7.48} & 9.88{\scriptsize 1.03} & 6.30{\scriptsize 0.05} & 4.84{\scriptsize 0.01} & 42.75{\scriptsize 1.05} & \textbf{26.03}{\scriptsize 0.35} & \textbf{20.02}{\scriptsize 0.27} & 24.04{\scriptsize 9.13} & 6.36{\scriptsize 0.22}  & 5.16{\scriptsize 0.31} & 32.12{\scriptsize 6.24} & 6.74{\scriptsize 0.14} \\
 UDA \citep{xie2020unsupervised} & 34.53{\scriptsize 10.69} & 10.62{\scriptsize 3.75} & 5.16{\scriptsize 0.06} & 4.29{\scriptsize 0.07} & 46.39{\scriptsize 1.59} & 27.73{\scriptsize 0.21} & 22.49{\scriptsize 0.23} & 5.12{\scriptsize 4.27} & \textbf{1.92}{\scriptsize 0.05} & \textbf{1.89}{\scriptsize 0.01}  & 37.42{\scriptsize 8.44} & 6.64{\scriptsize 0.17} \\
 FixMatch \citep{sohn2020fixmatch} & 24.79{\scriptsize 7.65} & 7.47{\scriptsize 0.28} & \textbf{4.86}{\scriptsize 0.05} & 4.21{\scriptsize 0.08} & 46.42{\scriptsize 0.82} & 28.03{\scriptsize 0.16} & 22.20{\scriptsize 0.12} & 3.81{\scriptsize 1.18} & 2.02{\scriptsize 0.02}  & \underline{1.96}{\scriptsize 0.03} & 35.97{\scriptsize 4.14} & 6.25{\scriptsize 0.33} \\
 Dash \citep{xu2021dash} & 27.28{\scriptsize 14.09} & 8.93{\scriptsize 3.11} & 5.16{\scriptsize 0.23} & 4.36{\scriptsize 0.11} & 44.82{\scriptsize 0.96} & 27.15{\scriptsize 0.22} & 21.88{\scriptsize 0.07} & \underline{2.19}{\scriptsize 0.18} & 2.04{\scriptsize 0.02} & 1.97{\scriptsize 0.01}  & 34.52{\scriptsize 4.30} & 6.39{\scriptsize 0.56} \\
 MPL \citep{pham2021meta} & 23.55{\scriptsize 6.01} & 6.62{\scriptsize 0.91} & 5.76{\scriptsize 0.24} & 4.55{\scriptsize 0.04} & 46.26{\scriptsize 1.84} & {27.71\scriptsize 0.19} & 21.74{\scriptsize 0.09} & 9.33{\scriptsize 8.02} & 2.29{\scriptsize 0.04} & 2.28{\scriptsize 0.02}  & 35.76{\scriptsize 4.83} & 6.66{\scriptsize 0.00} \\
 FlexMatch \citep{zhang2021flexmatch} & \underline{13.85}{\scriptsize 12.04} & \underline{4.97}{\scriptsize 0.06} & 4.98{\scriptsize 0.09} & \underline{4.19}{\scriptsize 0.01} & \underline{39.94}{\scriptsize 1.62} & 26.49{\scriptsize 0.20} & 21.90{\scriptsize 0.15} & 8.19{\scriptsize 3.20} & 6.59{\scriptsize 2.29} & 6.72{\scriptsize 0.30} & \underline{29.15}{\scriptsize 4.16} & \underline{5.77}{\scriptsize 0.18} \\
 \ourmethod & \textbf{8.07}{\scriptsize 4.24} & \textbf{4.90}{\scriptsize 0.04} & \underline{4.88}{\scriptsize 0.18} & \textbf{4.10}{\scriptsize 0.02} & \textbf{37.98}{\scriptsize 0.42} & \underline{26.47}{\scriptsize 0.20} & \underline{21.68}{\scriptsize 0.03} & \textbf{1.97}{\scriptsize 0.02} & \underline{1.97}{\scriptsize 0.01} & \underline{1.96}{\scriptsize 0.03} & \textbf{15.56}{\scriptsize 0.55} & \textbf{5.63}{\scriptsize 0.15} \\
\midrule\,
Fully-Supervised    & \multicolumn{4}{c|}{4.62{\scriptsize 0.05}} & \multicolumn{3}{c|}{19.30{\scriptsize 0.09}}  & \multicolumn{3}{c|}{2.13{\scriptsize 0.01}} & \multicolumn{2}{c}{-}\\
\bottomrule
\end{tabular}
}
\vspace{-0.2in}
\end{table}


\subsection{Quantitative Results}

The Top-1 classification error rates of CIFAR-10/100, SVHN, and STL-10 are reported in \cref{tab-main}.
The results on ImageNet with 100 labels per class are in \cref{tab-imagenet}.
We also provide detailed results on precision, recall, F1 score, and confusion matrix in Appendix \ref{append-detail-result}.
These quantitative results demonstrate that \ourmethod achieves the best performance on CIFAR-10, STL-10, and ImageNet datasets, and it produces very close results on SVHN to the best competitor. On CIFAR-100, \ourmethod is better than ReMixMatch when there are 400 labels. The good performances of ReMixMatch on CIFAR-100 (2500) and CIFAR-100 (10000) are probably brought by the mix up~\citep{zhang2017mixup} technique and the self-supervised learning part.
On ImageNet with 100k labels, \ourmethod significantly outperforms the latest counterpart FlexMatch by \textbf{1.28}\%\footnote{Following \citep{zhang2021flexmatch}, we train ImageNet for  iterations like other datasets for a fair comparison. We use 4 Tesla V100 GPUs on ImageNet. }.
We also notice that \ourmethod exhibits fast computation in ImageNet from \cref{tab-imagenet}.
Note that FlexMatch is much slower than FixMatch and \ourmethod because it needs to maintain a list that records whether each sample is clean, which needs heavy indexing computation budget on large datasets.

\begin{wraptable}{r}{0.38\textwidth}
    \centering
    \vspace{-.1in}
    \caption{Error rates and runtime on ImageNet with 100 labels per class.}
    \label{tab-imagenet}
    \resizebox{0.35\textwidth}{!}{\begin{tabular}{l|ccc}
        \toprule
                  & Top-1  & Top-5  & \begin{tabular}{@{}c@{}} Runtime \\ (sec./iter.) \end{tabular} \\ \midrule
        FixMatch  & 43.66 & 21.80 & \textbf{0.4}                       \\
        FlexMatch & 41.85 & 19.48 & 0.6                        \\
        FreeMatch & \textbf{40.57} & \textbf{18.77} & \textbf{0.4}                        \\ \bottomrule
    \end{tabular}
    }
\end{wraptable}

Noteworthy is that, \ourmethod consistently outperforms other methods by a large margin on settings with \emph{extremely limited labeled data}: \textbf{5.78}\% on CIFAR-10 with 10 labels, \textbf{1.96}\% on CIFAR-100 with 400 labels, and surprisingly \textbf{13.59}\% on STL-10 with 40 labels.
STL-10 is a more realistic and challenging dataset compared to others, which consists of a large unlabeled set of 100k images.
The significant improvements demonstrate the capability and potential of \ourmethod to be deployed in real-world applications.\looseness=-1



\subsection{Qualitative Analysis}
We present some qualitative analysis: Why and how does \ourmethod work? What other benefits does it bring?
We evaluate the class average threshold and average sampling rate on STL-10 (40) (i.e., 40 labeled samples on STL-10) of \ourmethod to demonstrate how it works aligning with our theoretical analysis.
We record the threshold and compute the sampling rate for each batch during training.
The sampling rate is calculated on unlabeled data as . We also plot the convergence speed in terms of accuracy and the confusion matrix to show the proposed component in \ourmethod helps improve performance. From \cref{sub-threshold} and \cref{sub-sample-rate}, one can observe that the threshold and sampling rate change of \ourmethod is mostly consistent with our theoretical analysis. That is, at the early stage of training, the threshold of \ourmethod is relatively lower, compared to FlexMatch and FixMatch, resulting in higher unlabeled data utilization (sampling rate), which fastens the convergence. As the model learns better and becomes more confident, the threshold of \ourmethod increases to a high value to alleviate the confirmation bias, leading to stably high sampling rate. Correspondingly, the accuracy of \ourmethod increases vastly (as shown in \cref{sub-acc}) and resulting better class-wise accuracy (as shown in \cref{sub-cf}). Note that Dash fails to learn properly due to the employment of the high sampling rate until 100k iterations. 

To further demonstrate the effectiveness of the class-specific threshold in \ourmethod, we present the t-SNE~\citep{van2008visualizing} visualization of features of FlexMatch and \ourmethod on STL-10 (40) in \cref{fig:stl10_tsne} of \cref{sec:tsne}. We exhibit the corresponding local threshold for each class. Interestingly, FlexMatch has a high threshold, i.e., pre-defined , for class  and class , yet their feature variances are very large and are confused with other classes. This means the class-wise thresholds in FlexMatch cannot accurately reflect the learning status. In contrast, \ourmethod clusters most classes better. Besides, for the similar classes  that are confused with each other, \ourmethod retains a higher average threshold  than  of FlexMatch, enabling to mask more wrong pseudo labels. \revision{We also study the pseudo label accuracy in Appendix~\ref{sec:placc} and shows FreeMatch can reduce noise during training.} 



\begin{figure}[t!]
\hfill
\subfigure[Confidence threshold]{
\includegraphics[width=0.22\linewidth]{figures/stl10_40_1_threshold.pdf}
\label{sub-threshold}
}
\hfill
\subfigure[Sampling rate]{
\includegraphics[width=0.22\linewidth]{figures/stl10_40_1_sample_rate.pdf}
\label{sub-sample-rate}
}
\hfill
\subfigure[Accuracy]{
\includegraphics[width=0.22\linewidth]{figures/stl10_40_acc_convergence.pdf}
\label{sub-acc}
}
\hfill
\subfigure[Confusion matrix]{
\includegraphics[width=0.22\linewidth]{figures/stl10_40_cm.pdf}
\label{sub-cf}
}
\hfill
\vspace{-.1in}
\caption{How FreeMatch works in STL-10 with 40 labels, compared to others. (a) Class-average confidence threshold; (b) class-average sampling rate; (c) convergence speed in terms of accuracy; (d) confusion matrix, where fading colors of diagonal elements refer to the disparity of accuracy.}
\label{fig:stl10-threshold-sample}
\vspace{-.2in}
\end{figure}







\subsection{Ablation Study}

\paragraph{Self-adaptive Threshold}












We conduct experiments on the components of SAT in \ourmethod and compare to the components in FlexMatch \citep{zhang2021flexmatch}, FixMatch \citep{sohn2020fixmatch}, Class-Balanced Self-Training (CBST)~\citep{zou2018unsupervised}, and Relative Threshold (RT) in AdaMatch~\citep{berthelot2021adamatch}. The ablation is conducted on CIFAR-10 (40 labels).

\begin{wraptable}{r}{0.3\textwidth}
    \centering
    \vspace{-.2in}
    \caption{Comparison of different thresholding schemes.}
    \label{tab:ablation_threshold}
    \resizebox{0.3\textwidth}{!}{\begin{tabular}{@{}lc}
        \toprule
        Threshold                             & CIFAR-10 (40)        \\ \midrule
         (FixMatch)                          & 7.47\scriptsize{0.28}    \\
         (FlexMatch)       & 4.97\scriptsize{0.06}  \\
          & 5.13\scriptsize{0.03} \\
         (Global)                            & 6.06\scriptsize{0.65} \\
           & 8.40\scriptsize{2.49}\\
         CBST  & 16.65\scriptsize{2.90} \\
         RT (AdaMatch)    & 6.09\scriptsize{0.65}\\
        SAT (Global and Local) & \textbf{4.92}\scriptsize{0.04}  \\ \bottomrule
    \end{tabular}
    }
\vspace{-.1in}
\end{wraptable}

As shown in \tablename~\ref{tab:ablation_threshold}, 
SAT achieves the best performance among all the threshold schemes.
Self-adaptive global threshold  and local threshold  themselves also achieve comparable results, compared to the fixed threshold , demonstrating both local and global threshold proposed are good learning effect estimators. When using CPL   to adjust , the result is worse than the fixed threshold and exhibits larger variance, indicating potential instability of CPL. AdaMatch~\citep{berthelot2021adamatch} uses the RT, which can be viewed as a global threshold at -th iteration computed on the predictions of labeled data without EMA, whereas FreeMatch conducts computation of  with EMA on unlabeled data that can better reflect the overall data distribution. For class-wise threshold, CBST~\citep{zou2018unsupervised} maintains a pre-defined sampling rate, which could be the reason for its bad performance since the sampling rate should be changed during training as we analyzed in Sec.~\ref{seq:theory}. 
Note that we did not include  in this ablation for a fair comparison. \revision{Ablation study in Appendix~\ref{sec:ablation-threshold} and ~\ref{sec:ablation-ema} on FixMatch and FlexMatch with different thresholds shows SAT serves to reduce hyperparameter-tuning computation or overall training time in the event of similar performance for an optimally selected threshold.}
\looseness = -1
\vspace{-0.15in}



\begin{wraptable}{r}{0.3\textwidth}
    \centering
\caption{Comparison of different class fairness items.}
    \vspace{-.1in}
    \label{tab:ablation_fairnes}
    \resizebox{0.3\textwidth}{!}{\begin{tabular}{@{}lc}
        \toprule
         Fairness             & CIFAR-10 (10)      \\ \midrule
         w/o fairness & 10.37\scriptsize{7.70}   \\
         & 9.57\scriptsize{6.67} \\
         & 12.07\scriptsize{5.23} \\
        DA (AdaMatch) & 32.94\scriptsize{1.83} \\
         DA (ReMixMatch) & 11.06\scriptsize{8.21}\\
        SAF                 & \textbf{8.07}\scriptsize{4.24}\\\bottomrule
    \end{tabular}
    }
    \vspace{-.2in}
\end{wraptable}
\paragraph{Self-adaptive Fairness}

As illustrated in Table~\ref{tab:ablation_fairnes}, we also empirically study the effect of SAF on CIFAR-10 (10 labels). We study the original version of fairness objective as in \citep{arazo2020pseudo}. Based on that, we study the operation of normalization probability by histograms and show that countering the effect of imbalanced underlying distribution indeed helps the model to learn and diverse better.
One may notice that adding original fairness regularization alone already helps improve the performance. Whereas adding normalization operation in the log operation hurts the performance, suggesting the underlying batch data are indeed not uniformly distributed.
We also evaluate Distribution Alignment (DA) for class fairness in ReMixMatch \citep{berthelot2019remixmatch} and AdaMatch \citep{berthelot2021adamatch}, showing inferior results than SAF.
A possible reason for the worse performance of DA (AdaMatch) is that it only uses labeled batch prediction as the target distribution which cannot reflect the true data distribution especially when labeled data is scarce and changing the target distribution to the ground truth uniform, i.e., DA (ReMixMatch), is better for the case with extremely limited labels. \revision{We also proved SAF can be easily plugged into FlexMatch and bring improvements in Appendix~\ref{sec:ablation-safflexfree}.} The EMA decay ablation and performances of imbalanced settings are in Appendix \ref{sec:ablation-ema} and Appendix \ref{sec:ablation-imbssl}. \looseness=-1








\section{Related Work}





To reduce confirmation bias~\citep{arazo2020pseudo} in pseudo labeling, confidence-based thresholding techniques are proposed to ensure the quality of pseudo labels \citep{xie2020unsupervised,sohn2020fixmatch,zhang2021flexmatch,xu2021dash}, where only the unlabeled data whose confidences are higher than the threshold are retained. UDA \citep{xie2020unsupervised} and FixMatch \citep{sohn2020fixmatch} keep the fixed pre-defined threshold during training. FlexMatch \citep{zhang2021flexmatch} adjusts the pre-defined threshold in a class-specific fashion according to the per-class learning status estimated by the number of confident unlabeled data. A co-current work Adsh \citep{guo2022class} explicitly optimizes the number of pseudo labels for each class in the SSL
objective to obtain adaptive thresholds for imbalanced Semi-supervised Learning. However, it still needs a user-predefined threshold. Dash \citep{xu2021dash} defines a threshold according to the loss on labeled data and adjusts the threshold according to a fixed mechanism. A more recent work, AdaMatch~\citep{berthelot2021adamatch}, aims to unify SSL and domain adaptation using a pre-defined threshold multiplying the average confidence of the labeled data batch to mask noisy pseudo labels. It needs a pre-defined threshold and ignores the unlabeled data distribution especially when labeled data is too rare to reflect the unlabeled data distribution. Besides, distribution alignment~\citep{berthelot2019remixmatch,berthelot2021adamatch} is also utilized in Adamatch to encourage fair predictions on unlabeled data.
Previous methods might fail to choose meaningful thresholds due to ignorance of the relationship between the model learning status and thresholds. \cite{chen2020self,kumar2020understanding} try to understand self-training / thresholding from the theoretical perspective. 
A motivation example is used to derive implications for adjusting threshold according to learning status.


Except consistency regularization, entropy-based regularization is also used in SSL. Entropy minimization \citep{grand2004ent} encourages the model to make confident predictions for all samples disregarding the actual class predicted.
Maximization of expectation of entropy \citep{krause2010disc, arazo2020pseudo} over all samples is also proposed to induce fairness to the model, enforcing the model to predict each class at the same frequency. But previous ones assume a uniform prior for underlying data distribution and also ignore the batch data distribution. Distribution alignment \citep{berthelot2019remixmatch} adjusts the pseudo labels according to labeled data distribution and the EMA of model predictions. 
\looseness=-1
%
 

\section{Conclusion}
\label{sec-conclusion}
We proposed \ourmethod that utilizes self-adaptive thresholding and class-fairness regularization for SSL.
\ourmethod outperforms strong competitors across a variety of SSL benchmarks, especially in the barely-supervised setting.
We believe that confidence thresholding has more potential in SSL.
A potential limitation is that the adaptiveness still originates from the heuristics of the model prediction, and we hope the efficacy of \ourmethod inspires more research for optimal thresholding. 




\bibliography{iclr2023_conference}
\bibliographystyle{iclr2023_conference}


\newpage

\appendix

\section{Experimental details of the  ``two-moon'' dataset.}
\label{append-twomoon}
We generate only two labeled data points (one label per each class, denoted by black dot and round circle) and 1,000 unlabeled data points (in gray) in 2-D space. We train a 3-layer MLP with 64 neurons in each layer and ReLU activation for 2,000 iterations. The red samples indicate the different samples whose confidence values are above the threshold of FreeMatch but below that of FixMatch. The sampling rate is computed on unlabeled data as . Results are averaged 5 times.

\section{Proof of Theorem~\ref{theorem1}}
\label{append-proof}
\textbf{Theorem 2.1}
\emph{For a binary classification problem as mentioned above, the pseudo label  has the following probability distribution:

where  is the cumulative distribution function of a standard normal distribution. Moreover,  increases as  gets smaller.}


\begin{proof}


A sample  will be assigned pseudo label 1 if 

which is equivalent to

Likewise,  will be assigned pseudo label -1 if

which is equivalent to

If we integrate over , we arrive at the following conditional probabilities:

Recall that , therefore

Now, let's use  to denote , to show that  increases as  gets smaller, we only need to show  gets bigger. We write  as

where  are positive constants. We futher only need to show that  is monotone increasing on . Take the derivative of , we have

where  is the probability density function of a standard normal distribution. Since , we have , and the proof is complete.

\end{proof}

\section{Algorithm}

We present the pseudo algorithm of \ourmethod. Compared to FixMatch, each training step involves updating the global threshold and local threshold from the unlabeled data batch, and computing corresponding histograms. FreeMatchs introduce a very trivial computation budget compared to FixMatch, demonstrated also in our main paper.

\begin{algorithm}[h]
\caption{FreeMatch algorithm at -th iteration.}
\label{alg:freematch}
\begin{algorithmic}[1]
\STATE \textbf{Input:} Number of classes , labeled batch , unlabeled batch , unsupervised loss weight , fairness loss weight , and EMA decay .
\STATE Compute  for labeled data \\ 
       


\STATE Update the global threshold \\
       
\COMMENT{ is an abbreviation of , shape of :  }
\STATE Update the local threshold \\
       
\COMMENT{Shape of : }
\STATE Update histogram for  \\
       
\COMMENT{Shape of : }
\FOR{ to }
\STATE 
\COMMENT{Calculate SAT}
\ENDFOR 
\STATE Compute  on unlabeled data \\ 
         
\STATE Compute expectation of probability on unlabeled data \\ 
        
\COMMENT{ is an abbr. of , shape of : }
\STATE Compute histogram for  \\ 
       
\COMMENT{Shape of : }
\STATE Compute  on unlabeled data \\ 
       
\STATE \textbf{Return:} 
\end{algorithmic}
\end{algorithm}



\section{Hyperparameter setting}
\label{append-hyper}

For reproduction, we show the detailed hyperparameter setting for \ourmethod in \tablename~\ref{tab-para-algo-depen} and \ref{tab-para-algo-inde}, for algorithm-dependent and algorithm-independent hyperparameters, respectively.

\begin{table}[!htbp]
\centering
\caption{Algorithm dependent hyperparameters.}
\label{tab-para-algo-depen}
\begin{adjustbox}{width=0.8\columnwidth, center}
\begin{tabular}{cccccc}
\toprule
Algorithm &  \ourmethod \\\cmidrule(r){1-1} \cmidrule(lr){2-2}
Unlabeled Data to Labeled Data Ratio (CIFAR-10/100, STL-10, SVHN)    &  7 \\
\cmidrule(r){1-1}\cmidrule(lr){2-2}
Unlabeled Data to Labeled Data Ratio (ImageNet)    &  1 \\
\cmidrule(r){1-1}\cmidrule(lr){2-2}
Loss weight  for all experiments    &  1 \\
\cmidrule(r){1-1}\cmidrule(lr){2-2}
Loss weight  for CIFAR-10 (10), CIFAR-100 (400), STL-10 (40), ImageNet (100k), SVHN   &  0.01 \\
\cmidrule(r){1-1}\cmidrule(lr){2-2}
Loss weight  for others   &  0.05 \\
\cmidrule(r){1-1}\cmidrule(lr){2-2}
Thresholding EMA decay for all experiments  & 0.999 \\
\bottomrule
\end{tabular}
\end{adjustbox}
\end{table}

\begin{table}[!htbp]
\centering
\caption{Algorithm independent hyperparameters.}
\label{tab-para-algo-inde}
\begin{adjustbox}{width=0.65\columnwidth, center}
\begin{tabular}{cccccc}\toprule
Dataset &  CIFAR-10 & CIFAR-100 & STL-10 & SVHN & ImageNet \\\cmidrule(r){1-1} \cmidrule(lr){2-2}\cmidrule(lr){3-3}\cmidrule(lr){4-4}\cmidrule(lr){5-5}\cmidrule(l){6-6}
Model    &  WRN-28-2 & WRN-28-8 & WRN-37-2 & WRN-28-2 & ResNet-50 \\\cmidrule(r){1-1} \cmidrule(lr){2-2}\cmidrule(lr){3-3}\cmidrule(lr){4-4}\cmidrule(lr){5-5}\cmidrule(l){6-6}
Weight decay&  5e-4  & 1e-3 & 5e-4 & 5e-4 & 3e-4\\ \cmidrule(r){1-1} \cmidrule(lr){2-2}\cmidrule(lr){3-3}\cmidrule(lr){4-4}\cmidrule(lr){5-5}\cmidrule(l){6-6}
Batch size & \multicolumn{4}{c}{64} & \multicolumn{1}{c}{128}\\\cmidrule(r){1-1} \cmidrule(lr){2-5} \cmidrule(l){6-6}
Learning rate & \multicolumn{5}{c}{0.03}\\\cmidrule(r){1-1} \cmidrule(l){2-6}
SGD momentum & \multicolumn{5}{c}{0.9}\\\cmidrule(r){1-1} \cmidrule(l){2-6}
EMA decay & \multicolumn{5}{c}{0.999}\\
\bottomrule
\end{tabular}
\end{adjustbox}
\end{table}

Note that for ImageNet experiments, we used the same learning rate, optimizer scheme, and training iterations as other experiments, and a batch size of 128 is adopted, whereas, in FixMatch, a large batch size of 1024 and a different optimizer is used. From our experiments, we found that training ImageNet with only  is not enough, and the model starts converging at the end of training. Longer training iterations on ImageNet will be explored in the future. Single NVIDIA V100 is used for training on CIFAR-10, CIFAR-100, SVHN and STL-10. It costs about 2 days to train on CIFAR-10 and SVHN. 10 days are needed for the training on CIFAR-100 and STL-10.


\section{Extensive Experiment Details and Results}

We present extensive experiment details and results as complementary to the experiments in the main paper.

\subsection{Significant Tests}
\label{append-sig}
\revision{
We did significance test using the Friedman test. We choose the top 7 algorithms on 4 datasets (i.e., ). Then, we compute the F value as , which is clearly larger than the thresholds  and . This test indicates that there are significant differences between all algorithms. 
}



\revision{
To further show our significance, we report the average error rates for each dataset in \cref{tb-sig-mer}. We can see FreeMatch outperforms most SSL algorithms significantly.
}
\begin{table}[]
\centering
\caption{The average error rates for each dataset.}
\label{tb-sig-mer}
\begin{tabular}{c|ccccc}
\toprule
\textbf{}    & CIFAR-10 & CIFAR-100 & SVHN & STL-10 & Total Average \\
\midrule
 Model  & 53.22             & 60.80              & 29.31         & 53.55           & 49.19                  \\
Pseudo Label & 54.10             & 60.58              & 29.87         & 53.66           & 49.59                  \\
VAT          & 51.50             & 54.73              & 27.73         & 56.35           & 47.17                  \\
MeanTeacher  & 48.01             & 52.68              & 14.27         & 52.81           & 41.54                  \\
MixMatch     & 30.56             & 45.04              & 12.95         & 38.32           & 31.07                  \\
ReMixMatch   & 10.45             & 29.60              & 11.85         & 19.43           & 17.08                  \\
UDA          & 13.65             & 32.20              & 2.98          & 22.03           & 17.02                  \\
FixMatch     & 10.33             & 32.22              & 2.60          & 21.11           & 15.67                  \\
Dash         & 11.43             & 31.28              & 2.07          & 20.46           & 15.56                  \\
MPL          & 10.12             & 31.90              & 4.63          & 21.21           & 16.04                  \\
FlexMatch    & 7.00              & 29.44              & 7.17          & 17.46           & 14.40                  \\
FreeMatch    & \textbf{5.49}          & \textbf{28.71}          & \textbf{1.97}      & \textbf{10.60}       & \textbf{11.26} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{CIFAR-10 (10) Labeled Data}

Following \citep{sohn2020fixmatch}, we investigate the limitations of SSL algorithms by giving only \textbf{one labeled training sample per class}. The selected 3 labeled training sets are visualized in Figure~\ref{fig-cifar10}, which are obtained by \citep{sohn2020fixmatch} using ordering mechanism~\citep{carlini2019distribution}.

\begin{figure}[h]
    \centering
    \includegraphics{figures/cifar10_10_samples.pdf}
    \caption{CIFAR-10 (10) labeled samples visualization, sorted from the most prototypical dataset (first row) to least prototypical dataset (last row).}
    \label{fig-cifar10}
\end{figure}



\subsection{Detailed Results}
\label{append-detail-result}
To comprehensively evaluate the performance of all methods in a classification setting, we further report the precision, recall, f1 score, and AUC (area under curve) results of CIFAR-10 with the same 10 labels, CIFAR-100 with 400 labels, SVHN with 40 labels, and STL-10 with 40 labels.
As shown in \cref{tb-prf1_1} and \ref{tb-prf1_2}, \ourmethod also has the best performance on precision, recall, F1 score, and AUC in addition to the top1 error rates reported in the main paper.

\begin{table}[h]
\centering
\caption{Precision, recall, f1 score and AUC results on CIFAR-10/100. }
\begin{adjustbox}{width=0.7 \columnwidth,center}
\label{tb-prf1_1}
\begin{tabular}{l|cccc|cccc}
\toprule
Datasets & \multicolumn{4}{c|}{CIFAR-10 (10)} & \multicolumn{4}{c}{CIFAR-100 (400)} \\ 
\cmidrule(r){1-1} \cmidrule(lr){2-5} \cmidrule(lr){6-9} 
Criteria & \multicolumn{1}{c}{Precision}  &  \multicolumn{1}{c}{Recall}  &	\multicolumn{1}{c}{F1 Score}  &	\multicolumn{1}{c}{AUC}  & \multicolumn{1}{c}{Precision}  &  \multicolumn{1}{c}{Recall}  &	\multicolumn{1}{c}{F1 Score}  &	\multicolumn{1}{c}{AUC} \\
\cmidrule(r){1-1} \cmidrule(lr){2-5} \cmidrule(lr){6-9}

UDA &0.5304 &0.5121 &0.4754 &0.8258 &0.5813 &0.5484 &0.5087 &0.9475  \\
FixMatch  &0.6436 &0.6622 &0.6110 &0.8934 &0.5574 &0.5430 &0.4946 &0.9363 \\
Dash  &0.6409 &0.5410 &0.4955 &0.8458 &0.5833 &0.5649 &0.5215 &0.9456 \\
MPL  &0.6286 &0.6857 &0.6178 &0.7993 &0.5799 &0.5606 &0.5193 &0.9316 \\
FlexMatch  &0.6769 &0.6861 &0.6780 &0.9126 &0.6135 &0.6193 &0.6107 &0.9675 \\
FreeMatch  &\textbf{0.8619} &\textbf{0.8593} &\textbf{0.8523} &\textbf{0.9843} &\textbf{0.6243} &\textbf{0.6261} &\textbf{0.6137} & \textbf{0.9692} \\

\bottomrule
\end{tabular}
\end{adjustbox}
\end{table}

\begin{table}[h]
\centering
\caption{Precision, recall, f1 score and AUC results on SVHN and STL-10. }
\begin{adjustbox}{width=0.7 \columnwidth,center}
\label{tb-prf1_2}
\begin{tabular}{l|cccc|cccc}
\toprule
Datasets & \multicolumn{4}{c|}{SVHN (40)} & \multicolumn{4}{c}{STL-10 (40)} \\ 
\cmidrule(r){1-1} \cmidrule(lr){2-5} \cmidrule(lr){6-9} 
Criteria & \multicolumn{1}{c}{Precision}  &  \multicolumn{1}{c}{Recall}  &	\multicolumn{1}{c}{F1 Score}  &	\multicolumn{1}{c}{AUC}  & \multicolumn{1}{c}{Precision}  &  \multicolumn{1}{c}{Recall}  &	\multicolumn{1}{c}{F1 Score}  &	\multicolumn{1}{c}{AUC} \\
\cmidrule(r){1-1} \cmidrule(lr){2-5} \cmidrule(lr){6-9}

UDA &\textbf{0.9783} &0.9777 &0.9780 &0.9977 &0.6385 &0.5319 &0.4765 &0.8581\\
FixMatch   &0.9731 &0.9706 &0.9716 &0.9962 &0.6590 &0.5830 &0.5405 &0.8862 \\
Dash  &0.9782 &0.9778 &0.9780 &0.9978 &0.8117 &0.6020 &0.5448 &0.8827 \\
MPL  &0.9564 &0.9513 &0.9512 &0.9844 &0.6191 &0.5740 &0.4999 &0.8529 \\
FlexMatch  &0.9566 &0.9691 &0.9625 &0.9975 &0.6403 &0.6755 &0.6518 &0.9249 \\
FreeMatch  &\textbf{0.9783} &\textbf{0.9800} &\textbf{0.9791} &\textbf{0.9979} &\textbf{0.8489} &\textbf{0.8439} &\textbf{0.8354} &\textbf{0.9792} \\

\bottomrule
\end{tabular}
\end{adjustbox}
\end{table}












\subsection{Ablation of pre-defined thresholds on FixMatch and FlexMatch}
\label{sec:ablation-threshold}
\revision{
As shown in \cref{tab-fixflextau}, the performance of FixMatch and FlexMatch is quite sensitive to the changes of the pre-defined threshold .
}
\begin{table}[]
\centering
\caption{FixMatch and FlexMatch with different thresholds on CIFAR-10 (40).}
\label{tab-fixflextau}
\begin{tabular}{c|cc}
\toprule
\textbf{} & \textbf{FixMatch} & \textbf{FlexMatch} \\
\midrule
0.25            & 11.76±0.60        & 18.84±0.36         \\
0.5             & 16.29±0.31        & 14.16±0.21         \\
0.75            & 15.61±0.23        & 6.08±0.17          \\
0.95            & 7.47±0.28         & 4.97±0.06          \\
0.98            & 8.01±0.91         & 5.40±0.11         \\
\bottomrule
\end{tabular}
\end{table}


\subsection{Ablation on EMA decay on CIFAR-10 (40)}
\label{sec:ablation-ema}

We provide the ablation study on EMA decay parameter  in \cref{eq-global} and \cref{eq-salt}. One can observe that different decay  produces the close results on CIFAR-10 with 40 labels, indicating that \ourmethod is not sensitive to this hyper-parameter. A large  is not encouraged since it could impede the update of global / local thresholds.


\begin{table}[!h]
    \centering
    \vspace{-.1in}
    \caption{Error rates of different thresholding EMA decay.}
    \label{tab:ablation_threshold_ema}
    \resizebox{0.35\textwidth}{!}{\begin{tabular}{@{}lc}
        \toprule
        Thresholding EMA decay                             & CIFAR-10 (40)        \\ \midrule
        0.9                          &   4.94\scriptsize{0.06}  \\
        0.99                        &   4.92\scriptsize{0.08} \\
        0.999 & \textbf{4.90}\scriptsize{0.04}  \\
        0.9999 &  5.03\scriptsize{0.07} \\ \bottomrule
        \end{tabular}
    }
\end{table}

\subsection{Ablation of SAF on FlexMatch and FreeMatch}
\label{sec:ablation-safflexfree}
\revision{
In \cref{tab-safflexfree}, we present the comparison of different class fairness objectives on CIFAR-10 with 10 labels. FreeMatch is better than FlexMatch in both settings. In addition, SAF is also proved effective when combined with FlexMatch.
}
\begin{table}[]
\centering
\caption{FixMatch and FlexMatch with different thresholds on CIFAR-10 (40).}
\label{tab-fixflextau}
\begin{tabular}{c|cc}
\toprule
\textbf{} & \textbf{FixMatch} & \textbf{FlexMatch} \\
\midrule
0.25            & 11.76±0.60        & 18.84±0.36         \\
0.5             & 16.29±0.31        & 14.16±0.21         \\
0.75            & 15.61±0.23        & 6.08±0.17          \\
0.95            & 7.47±0.28         & 4.97±0.06          \\
0.98            & 8.01±0.91         & 5.40±0.11         \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[]
\centering
\caption{Ablation of SAF on FlexMatch and FreeMatch on CIFAR-10 (10) }
\label{tab-safflexfree}
\begin{tabular}{c|cc}
\toprule
Fairness Objective & FlexMatch & FreeMatch \\
\midrule
w/o SAF                     & 13.85±12.04        & 10.37±7.70         \\
w/ SAF                      & 12.60±8.16         & 8.07±4.24          \\ 
\bottomrule
\end{tabular}
\end{table}


\subsection{Ablation of Imbalanced SSL}
\label{sec:ablation-imbssl}
\begin{table}[]
    \centering
    \caption{
    Error rates (\%) of imbalanced SSL using 3 different random seeds. }
    \label{tab:lt_result}
    \resizebox{0.5\textwidth}{!}{\begin{tabular}{l|ll|ll}
        \toprule
         Dataset & \multicolumn{2}{c|}{CIFAR-10-LT} & \multicolumn{2}{c}{CIFAR-100-LT} \\ \midrule
         Imbalance  & \multicolumn{1}{c}{50}  & \multicolumn{1}{c|}{150} & \multicolumn{1}{c}{20}  & \multicolumn{1}{c}{100} \\ 
         \midrule
        FixMatch  &  
        18.5\scriptsize{0.48} &
        31.2\scriptsize{1.08} &
        49.1\scriptsize{0.62} &
        \textbf{62.5}\scriptsize{0.36} \\
        FlexMatch  & 17.8\scriptsize{0.24} &  
        29.5\scriptsize{0.47} & 
        48.9\scriptsize{0.71} &  
        62.7\scriptsize{0.08} \\ 
        FreeMatch  & 
        \textbf{17.7}\scriptsize{0.33} &
        \textbf{28.8}\scriptsize{0.64} &
        \textbf{48.4}\scriptsize{0.91} &
        \textbf{62.5}\scriptsize{0.23} \\
        \midrule
        FixMatch w/ ABC & 
        14.0\scriptsize{0.22} &
        \textbf{22.3}\scriptsize{1.08} &
        46.6\scriptsize{0.69} &
        \textbf{58.3}\scriptsize{0.41} \\
        FlexMatch w/ ABC & 
        14.2\scriptsize{0.34} &
        23.1\scriptsize{0.70} &
        46.2\scriptsize{0.47} &
        58.9\scriptsize{0.51} \\
        FreeMatch w/ ABC & 
        \textbf{13.9}\scriptsize{0.03} &
        \textbf{22.3}\scriptsize{0.26} &
        \textbf{45.6}\scriptsize{0.76} &
        58.9\scriptsize{0.55} \\
        
        \bottomrule
    \end{tabular}
    }\end{table}
To further prove the effectiveness of \ourmethod, We evaluate \ourmethod on the imbalanced SSL setting \cite{kim2020distribution,wei2021crest,lee2021abc,fan2021cossl}, where the labeled and the unlabeled data are both imbalanced. We conduct experiments on
CIFAR-10-LT and CIFAR-100-LT with different imbalance ratios. The imbalance ratio used on CIFAR datasets is defined as  where  is the number of samples on the head (frequent) class and  the tail (rare).
Note that the number of samples for class  is computed as , where  is the number of classes.
Following \citep{lee2021abc,fan2021cossl}, 
we set  for CIFAR-10 and  for CIFAR-100, and the number of unlabeled data is twice as many for each class.
We use a WRN-28-2~\citep{zagoruyko2016wide} as the backbone. 
We use Adam~\citep{kingma2014adam} as the optimizer. 
The initial learning rate is  with a cosine learning rate decay schedule as , where  is the initial learning rate,  is the current (total) training step and we set  for all datasets.
The batch size of labeled and unlabeled data is 64 and 128, respectively. 
Weight decay is set as 4e-5.
Each experiment is run on three different data splits, and we report the average of the best error rates.

The results are summarized in Table \ref{tab:lt_result}. Compared with other standard SSL methods, FreeMach achieves the best performance across all settings.
Especially on CIFAR-10 at imbalance ratio 150, FreeMatch outperforms the second best by .
Moreover, when plugged in the other imbalanced SSL method~\citep{lee2021abc}, FreeMatch still attains the best performance in most of the settings.









\subsection{T--SNE Visualization on STL-10 (40)}
\label{sec:tsne}

We plot the T--SNE visualization of the features on STL-10 with 40 labels from FlexMatch \citep{zhang2021flexmatch} and \ourmethod. \ourmethod shows better feature space than FlexMatch with less confusing clusters.

\begin{figure}[!t]
\centering    

\hfill
\subfigure[FlexMatch (train, test)]{\includegraphics[width=0.45\textwidth]{figures/stl10_tsne/flex_stl10.png}}
\hfill
\subfigure[\ourmethod (train, test)]{\includegraphics[width=0.45\textwidth]{figures/stl10_tsne/free_stl10.png}}
\hfill
\caption{T-SNE visualization of FlexMatch and \ourmethod features on STL-10 (40). Unlabeled data is indicated by gray color. Local threshold  for each class is shown on the legend.}
\label{fig:stl10_tsne}
\end{figure}


\subsection{Pseudo Label accuracy on CIFAR-10 (10)}
\label{sec:placc}
\revision{
We average the pseudo label accuracy with three random seeds and report them in Figure~\ref{fig-placc}. This indicates that mapping thresholds from a high fixed threshold like FlexMatch did can prevent unlabeled samples from being involved in training. In this case, the model can overfit on labeled data and a small amount of unlabeled data. Thus the predictions on unlabeled data will incorporate more noise. Introducing appropriate unlabeled data at training time can avoid overfitting on labeled datasets and a small amount of unlabeled data and bring more accurate pseudo labels.
}
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/cifar10_pl_acc.pdf}
    \caption{CIFAR-10 (10) Pseudo Label accuracy visualization.}
    \label{fig-placc}
\end{figure}


\subsection{CIFAR-10 (10) Confusion Matrix}

We plot the confusion matrix of FreeMatch and other SSL methods on CIFAR-10 (10) in Figure~\ref{fig-conf}. It is worth noting that even with the least prototypical labeled data in our setting, \ourmethod still gets good results while other SSL methods fail to separate the unlabeled data into different clusters, showing inconsistency with the low-density assumption in SSL.



\begin{figure}[!t]
\centering
\subfigure[The most prototypical labeled samples]{\includegraphics[width=1\textwidth]{figures/cf/1strow.png}}
\\
\subfigure[The second-most prototypical labeled samples]{\includegraphics[width=1\textwidth]{figures/cf/2ndrow.png}}
\\
\subfigure[The least prototypical labeled samples]{\includegraphics[width=1\textwidth]{figures/cf/3rdrow.png}}
\\
\caption{Confusion matrix on the test set of CIFAR-10 (10). Rows correspond to the rows in \cref{fig-cifar10}. Columns correspond to different SSL methods.}
\label{fig-conf}
\end{figure}


\end{document}
