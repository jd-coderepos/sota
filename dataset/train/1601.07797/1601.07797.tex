\documentclass[11pt,a4paper]{paper}

\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{amsmath,amsthm,amsfonts}
\usepackage{microtype}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage{fullpage}


\graphicspath{{./pictures/}}

\usepackage[usenames,dvipsnames]{xcolor}

\usepackage{xspace}

\usepackage{cite}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{claim}[theorem]{Claim}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{lemma}[theorem]{Lemma}

\newcommand{\mathset}[1]{\ensuremath {\mathbb {#1}}}
\newcommand{\N}{\mathset {N}}
\newcommand{\eps}{\ensuremath {\varepsilon}}

\setlength{\fboxsep}{.5pt}

\newcommand{\R}{\mathset{R}}

\newcommand\A{{\mathcal A}}
\newcommand\B{{\mathcal B}}
\newcommand\C{{\mathcal C}}
\newcommand\D{{\mathcal D}}
\newcommand\E{{\mathcal E}}
\renewcommand\S{{\mathcal S}}


\DeclareMathOperator{\dist}{d}
\DeclareMathOperator{\NIL}{NIL}
\DeclareMathOperator{\PD}{PD}
\DeclareMathOperator{\lr}{lr}
\DeclareMathOperator{\rr}{rr}
\DeclareMathOperator{\myr}{r}
\DeclareMathOperator{\myl}{l}
\DeclareMathOperator{\dl}{dl}
\DeclareMathOperator{\dr}{dr}
\DeclareMathOperator{\NN}{NN}
\DeclareMathOperator{\poly}{poly}
\DeclareMathOperator{\pop}{pop}
\DeclareMathOperator{\topstack}{top}
\DeclareMathOperator{\CD}{\mathcal{D}}
\DeclareMathOperator{\Q}{\mathcal{Q}}
\DeclareMathOperator{\wspdone}{wspd1}
\DeclareMathOperator{\wspdtwo}{wspd2}

\usepackage{ifdraft}
\newcommand{\remarkcmd}[3]{\ifoptionfinal{}{\textcolor{blue}{\textsc{#1 #2:}}
  \textcolor{red}{\textsf{#3}}}}
\newcommand{\haim}[2][says]{\remarkcmd{Haim}{#1}{#2}}
\newcommand{\paul}[2][says]{\remarkcmd{Paul}{#1}{#2}}
\newcommand{\liam}[2][says]{\remarkcmd{Liam}{#1}{#2}}
\newcommand{\wolfgang}[2][says]{\remarkcmd{Wolfgang}{#1}{#2}}


\title{Reachability Oracles for Directed
  Transmission Graphs\footnote{ 
  This work is supported in part by GIF
  projects 1161 and 1367, DFG project MU/3501/1 and 
  ERC StG 757609.
  A preliminary version appeared as
  Haim Kaplan, Wolfgang Mulzer, Liam Roditty, and Paul Seiferth.
  \emph{Spanners and Reachability Oracles for Directed Transmission Graphs.}
  Proc.\@ 31st SoCG, pp.~156--170.}}

\author{Haim Kaplan\thanks{School of Computer Science, Tel Aviv University,
 Israel, \texttt{haimk@post.tau.ac.il}} \and
 Wolfgang Mulzer\thanks{Institut f\"ur Informatik,
Freie Universit\"at Berlin,
  Germany,
  \texttt{[mulzer,pseiferth]@inf.fu-berlin.de}} \and
Liam Roditty\thanks{Department of Computer Science, Bar Ilan University,
  Israel
  \texttt{liamr@macs.biu.ac.il}} \and
Paul Seiferth\footnotemark[3]}
\begin{document}
\maketitle

\begin{abstract}
Let  be a set of  points
in  dimensions
such that each point  has an
\emph{associated radius} .
The \emph{transmission graph}  for  is the
directed graph with vertex set
 such that there is
an edge from  to  if and only if
, for any .

A \emph{reachability oracle} is a data structure
that decides for any two vertices 
whether  has a path from  to .
The quality of the oracle is measured
by the space requirement ,
the query time , and the preprocessing time.
For transmission graphs of one-dimensional point sets, we 
can construct in  time
an oracle with  and .
For planar point sets, the ratio  between the largest and
the smallest associated radius turns out to be an important
parameter. We present three data
structures whose quality depends on :
the first works only for  and achieves  with
 and preprocessing time ;
the second data structure gives

 and ;
the third data structure is randomized with
 and

and answers queries correctly with high probability.
\end{abstract}

\section{Introduction}

Representing the connectivity of a graph in a space efficient, 
succinct manner, while supporting fast queries, is
one of the most fundamental data structure questions on graphs.
For an undirected graph,
it suffices to compute the connected components and
to store with each vertex a label for the respective component.
This leads to a linear-space data
structure that can  decide in constant time if any two given vertices are
connected. For directed graphs, however, connectivity is not a 
symmetric relation any more,
and the problem turns out to be much more challenging.
Thus, if  is a directed graph, we say that a vertex  can 
\emph{reach} a vertex  if there is a directed path in 
from  to . Our goal is to construct a \emph{reachability oracle},
a space efficient data structure  that answers
\emph{reachability queries}, i.e., that determines for any pair of
query vertices  and  whether  can reach . The quality of a
reachability oracle for a graph with  vertices is measured by three
parameters: the \emph{space} , the \emph{query time}  and the
\emph{preprocessing time}.  The simplest solution stores for
each pair of vertices whether they can reach each other, leading to a
reachability oracle with  space and constant query time.
For sparse graphs with  edges, storing just the graph and 
performing a breadth first search for a query yields an  space 
oracle with  query time.
Interestingly, other than that, we are not aware of any better solutions
for general directed graphs,
even sparse ones; see Cohen et al.~\cite{CohenHaKaZw03} for 
partial results. Thus, any result that
simultaneously achieves subquadratic space and sublinear query time would be of
great interest. A lower bound by P\v{a}tra\c{s}cu~\cite{Patrascu11} shows
that we cannot hope for  query time with  space in sparse 
graphs,
but it does not rule out constant time queries with slightly superlinear space.
In the absence of progress towards
non-trivial reachability oracles or better lower bounds, solutions for special
cases become important.
For directed planar graphs, after a long line of 
research~\cite{ArikatiEtAl96,Frederickson87,Djidjev96,ChenXu00,Thorup04},
Holm, Rotenberg and Thorup presented a reachability oracle with 
constant query time and  preprocessing time and space 
usage~\cite{Holm2015}. This data structure, as well as most other 
previous  reachability oracles,  can also return the approximate 
shortest path distance between the query vertices.

\emph{Transmission graphs} constitute a graph class that shares many
similarities with planar graphs:
let  be a set of points where each point  has a (transmission) radius
 associated
with it. The transmission graph has vertex set  and a
\emph{directed} edge between two distinct points  if and only if
,
where  denotes the Euclidean distance between  and . 
Transmission graphs are a common model for directed sensor 
networks~\cite{KaplanEtAl15,PelegRoditty10,RickenbachEtAl09}.
In this geometric context, it is natural to consider a more general
type of query where the target point is an arbitrary point in the plane 
rather than a vertex of the graph. In this case, a vertex  can 
reach a \emph{point}  if there is a \emph{vertex}  
such that  reaches  and such that . We call such 
queries \emph{geometric reachability queries} and we call oracles that 
can answer such queries \emph{geometric reachability oracles}. To avoid
ambiguities, we sometimes use the term \emph{standard} reachability 
query/oracle when referring to the case where the query consists of 
two vertices.

\paragraph*{Our Results.}
An extended abstract of this work was presented
at the 31st International Symposium on Computational
Geometry~\cite{KaplanMuRoSe15}. 
This abstract also discusses the problem of constructing
sparse \emph{spanners} for transmission graphs. While we were preparing the
journal version, it turned out that a full description of 
our results would yield a large and unwieldy manuscript. Therefore,
we decided to split our study on transmission graphs into two parts,
the present paper that deals with the construction of efficient 
reachability oracles, and a companion paper that studies fast algorithms
for spanners in transmission graphs~\cite{KaplanEtAl15}.

In Section~\ref{sec:1d} we will see that one-dimensional 
transmission graphs
admit a rich structure that
can be exploited to construct a simple linear space geometric reachability
oracle with constant query time, and   preprocessing time.

In two dimensions, the situation is more involved.
Here, it turns out that the \emph{radius ratio} , the ratio of the
largest and the smallest transmission radius of a point in , is
an important parameter.
We consider first the case where . In this case,
the transmission graph has a lot
of structure: from the presence of two crossing edges  and
, we can conclude that additional edges between
, , , and  must be present.
Using this structural information, we can turn the
transmission graph into a planar graph in  time,
while preserving the reachability relation
and keeping the number of vertices linear in .
As mentioned above, for planar graphs there is a linear time
construction of a reachability oracle with linear space, and
constant query time~\cite{Holm2015}. Thus, our transformation together with
this construction yields a standard
reachability oracle with linear space, constant query time 
and  preprocessing time. Furthermore, in the companion paper
we show that any standard reachability oracle can be
transformed into a  geometric one by paying an \emph{additive}
overhead of  to the query time and of 
to the space~\cite{KaplanEtAl15}. We apply this transformation to the reachability oracle that we get
by planarizing the transmission graph and get a geometric oracle that requires  
space,  preprocessing time, and  answers geometric queries in  time  and standard queries in  time.
 Section~\ref{sec:psisqrt3} presents this result.


When , we do not know how to obtain a planar graph representing
the reachability relation of .
Fortunately, we can use a theorem by Alber and Fiala that allows us
to find a small and balanced separator with respect to the area of the union
of the disks~\cite{AlberFiala04}. This leads to
a standard reachability oracle with query time 
and space and preprocessing time ,
see Section~\ref{sec:psiconst}.
When  is even larger, we
can use random sampling combined with a quadtree of logarithmic
depth
to obtain a standard reachability oracle with query time ,
space , and
preprocessing time . Refer to
Section~\ref{sec:psipoly}.
Again, we can transform both oracles
into  geometric reachability oracles using the result from the
companion paper~\cite{KaplanEtAl15}. Since the overhead is
additive, the transformation does not affect the performance bounds.


\section{Preliminaries and Notation}
\label{sec:prelims}

Unless stated otherwise, we let  denote a set of
 points in the plane,
and we assume that for each point , we have an
\emph{associated radius} .
Furthermore, we assume that the input is scaled so that the smallest
associated radius is .
The elements in  are called \emph{vertices}.
The \emph{radius ratio}  of  is defined as
 (the 
smallest radius is ).
Given a point  and a radius , we denote by 
the closed disk with center  and radius . If , we
use  as a shorthand for . We write
 for the boundary circle of .

Our constructions for the two-dimensional reachability oracles make extensive
use of planar grids. For ,
we denote by   the \emph{grid at level }. It consists of
axis-parallel squares with diameter  that partition the
plane in grid-like fashion (the \emph{cells}).
Each grid  is aligned so that the origin lies at the corner of a cell.
We assume that our model of computation allows to
 find
the grid cell containing a given point
  in constant time.

In the one-dimensional case, our construction immediately yields a geometric
reachability oracle. In the two-dimensional case, we are only able to
construct standard reachability oracles directly. However, we can use the following
result from our companion paper to transform these oracles into geometric reachability
oracles in a black-box fashion~\cite{KaplanEtAl15}.

\begin{theorem}[Theorem~4.3 in \cite{KaplanEtAl15}]
\label{thm:geometricreachability}
Let  be the transmission graph for a set  of  points in the plane with radius
ratio . Given a reachability oracle for  that uses  space and
has query time , we can compute in  time a
geometric reachability oracle with   space and
query time .
\end{theorem}

To achieve a fast preproccesing time, we need  a sparse approximation of
the transmission graph . Let 
be constant.
A -\emph{spanner} for  is a sparse subgraph  such
that for any pair of vertices  and  in  we have  where  and  denote the shortest path distance in
 and in , respectively. In our
companion paper we show that -spanners for transmission graphs can be
constructed efficiently~\cite{KaplanEtAl15}.
\begin{theorem}[Theorem~3.12 in~\cite{KaplanEtAl15}]
\label{thm:2dspanner}
  Let  be the transmission graph for a set  of
   points in the plane
  with radius ratio . For any fixed ,
  we can compute
  a -spanner for  with  edges in  time
  using   space.
\end{theorem}

\section{Reachability Oracles for 1-dimensional Transmission Graphs}
\label{sec:1d}
In this section, we prove the existence of efficient reachability
oracles for one-dimensional transmission graphs and show that they
can be computed quickly.
\begin{theorem}
\label{thm:1doracle}
Let  be the transmission graph of an -point set .
Given the point set  with the associated radii,
we can construct in  time a geometric reachability oracle for
 that requires   space and can answer a query in   time.
\end{theorem}

We begin with a simple structural observation. 
For , let 
be the set of all vertices that are reachable from ,
and let  denote the
union of their associated disks. Then,  is an interval.

\begin{lemma}\label{obs:reachIB}
Let . There exist two points  such
that .
For any point , the vertex  can reach  if and only if
.
\end{lemma}

\begin{proof}
Let  and
.
From the definition, it follows that .
Conversely, let , and assume
w.l.o.g that  lies to the left of . Let  be the
vertex that defines , i.e.,
.
By definition, there is a path 
from  to  in .
Since  is a transmission graph, we have ,
for , so the disks
 cover the entire interval . Thus, there is a 
with . This means that .
Similarly, we have that ,
so 
The second statement of the lemma is now immediate.
\end{proof}

Lemma~\ref{obs:reachIB} suggests the following reachability
oracle with  space
and  query time:
for each , store
the endpoints  and . 
Given a query , where  is a vertex and  a point in ,
we return YES if and only if .
It only remains to compute the interval endpoints 
 and  for all  efficiently.

\begin{lemma}
\label{lem:findlr}
We can find the left interval endpoint , 
for each , in  total time.
An analogous statement holds for the right interval 
endpoints , for .
\end{lemma}

\begin{proof}
Let  be the vertices in ,
sorted in ascending order of the left endpoints of
their associated disks: .
Let  be the \emph{transpose graph} for  in which the 
directions of all edges are reversed. We perform a
depth-first search in  with start vertex , and 
we denote the set of all vertices
encountered during this search by . 
By construction,  contains exactly those vertices from which
 is reachable in , so
 if and only if .
For each vertex , 
no vertex in  is reachable from , i.e., 
.
Thus, we can repeat the procedure with the remaining
vertices to obtain all left interval endpoints.
The right interval endpoints are computed analogously.

For an efficient implementation, we store 
the -balls around the vertices in  in an 
\emph{interval tree} ~\cite{4M}. When a vertex  is visited
for the first time, we delete the corresponding -ball from
. When we need to find an outgoing edge in  from
a vertex , we 
use  to find one ball that contains . This
can be done in  time. Since the depth-first search
algorithm traverses at most  edges, this results in running
time .
\end{proof}


\section{Reachability Oracles for 2-dimensional Transmission Graphs}
\label{sec:2d}
In the following sections we present three different geometric reachability
oracles for
transmission graphs in . By Theorem~\ref{thm:geometricreachability}, we
can focus on the construction of standard reachability oracles since they can
be extended easily to geometric ones. This has no effect on the space required and the time bound for a
query, expect for the oracle given
in Section~\ref{sec:psisqrt3}. This oracle  applies for , it needs   space and has  query time.
Thus, when we apply the transformation from an oracle that can answer standard reachability queries to
an oracle that can answer geometric reachability queries, we increase the query time of this oracle to .

\subsection{ is
less than }
\label{sec:psisqrt3}
Suppose that . In this case, we show that
we can make  planar by
first removing unnecessary edges and then resolving edge crossings
by adding  additional vertices.
This will not change the reachability relation between
the original vertices. The existence of efficient reachability
oracles then follows from known results for directed planar graphs.
The main goal is to prove the following lemma.

\begin{lemma}\label{lem:planarization}
Let  be a set of  points in  with  and let
 be the transmission graph for  . We can compute, in   time,
 a plane
graph  such that
\begin{enumerate}[(i)]
\item  and ;
\item ; and
\item for any ,  can reach  in  if and only if  can
reach  in .
\end{enumerate}
\end{lemma}
Given Lemma~\ref{lem:planarization}, we can obtain our reachability
oracle from known results.

\begin{theorem}
\label{thm:2doraclesmall}
Let  be the transmission graph for a set  of
 points in  of radius ratio  less than
.
Then, we can construct in
 time a standard reachability oracle for  with 
and  or a geometric reachability oracle for  with  and .
\end{theorem}
\begin{proof}
We apply Lemma~\ref{lem:planarization}
and construct the distance oracle of Holm, Rotenberg, and Thorup for
the resulting graph~\cite{Holm2015}.
This distance oracle can be constructed in linear time, it needs
linear space, and it has constant query time. The result for the geometric
reachability oracle follows from Theorem~\ref{thm:geometricreachability}.
\end{proof}

We prove
Lemma~\ref{lem:planarization} in three steps. First, we show how to
make  sparse without changing the set of
reachable  pairs. Then, we show how to turn  into a planar graph.
Finally, we argue that we can combine these two operations to
get the desired result.

\paragraph*{Obtaining a Sparse Graph.}
We construct a subgraph
 with the same reachability relation as  but with
 edges and  edge crossings.
The bounded number of crossings allows us to obtain a planar
graph later on.
Consider the grid  (as defined in Section~\ref{sec:prelims}), 
and let  be a grid cell.
We say that an edge  of  \emph{lies in}
 if both endpoints are contained in
.
The \emph{neighborhood}  of  consists of
the  block of cells in  with  at the center.
Two grid cells are \emph{neighboring} if they lie in each
other's neighborhood.
Since a cell in  has side length ,
the two endpoints of every edge in  must lie in neighboring
grid cells.\footnote{Since the maximum edge length in  is ,
and since ,
the neighborhood  needs to contain three cells in each
direction around .}

\begin{figure}[htb]
\centering
\includegraphics{2doracle-planarization}
\caption{The vertices and edges of two neighboring cells of  (left) and
 of  (right)}

 \label{fig:planarization}
\end{figure}

The subgraph  has vertex set , and we pick its edges as follows (see also
Figure~\ref{fig:planarization}):
for each non-empty cell , we
set , and
we compute the
Euclidean minimum spanning tree (EMST)  of .
For each edge  of , we add the directed edges
 and  to .
Then, for every cell
,
we check if there are any edges from  to  in . If so, we
add an arbitrary such edge to . We denote by
  the set of edges  such that  and  are in different cells.
The following lemma summarizes the properties of
.

\begin{lemma}
\label{lem:pruning}
The graph  has the following properties.
\begin{enumerate}[(i)]
\item for any two vertices  and ,  can reach  in  if and only if  can reach  in ;
\item  has  edges;
\item  can be constructed in  time;
and
\item the straight line embedding of  in the plane
has  edge crossings.
\end{enumerate}
\end{lemma}

\begin{proof}
(i): All edges of  are also edges of :
inside a non-empty cell ,  induces
a clique in , and the edges of  between cells
lie in  by construction. It follows that
if  can reach  in  then  can reach  in .

To show the converse let
 be an edge in . We show that there
is a path from  to  in .
If  lies in a cell  of ,
we take the path from  to  along the EMST .
If  goes from a cell  to
another cell , then
there is an edge  from
 to  in , and
we take the path in  from  to ,
then the edge , and finally the path
in  from  to .

(ii): For a nonempty cell ,
we create  edges inside . Furthermore,
since  is constant,
there are   edges between points in   and points in other cells.
Thus,  has  edges.

(iii): Since we assumed that we can find the cell for a vertex
 in constant time, we can easily compute the sets
, for every nonempty ,  in
 time.
Computing the EMST  for a cell  requires
 time, which sums to
   time for all cells.
To find the edges of  (i.e., edges between neighboring cells)
we build a Voronoi diagram together with a point location
structure for each set .
This takes   time for all cells.
Let  and  be two neighboring cells.
For each point in , we locate the nearest neighbor in
 using the Voronoi diagram of .
If there is a point  whose nearest neighbor
 lies in , we add the edge  to , and
we proceed to the next pair of neighboring cells.
Since  is constant,
a point participates in  point location queries, each taking
  time. The total running
time of all point location queries is .

(iv):
Clearly each such crossing involves at least one edge of  (the set of edges between points in different cells).
Each edge  of  intersects  cells  (this holds for edges in  and trivially holds for edges inside cells). Each intersection of  with an edge of  must occur in one of these  cells that  intersects.
On the other hand, each cell  intersects only  edges of . So there are only  intersections per edge of .
\end{proof}



\paragraph*{Making  Planar.}
We now describe how to turn a graph , embedded in the plane, into a planar graph. (This transformation can be applied to
any graph embedded in the plane. But Lemma \ref{lem:globalreachability} applies only if  is a transmission graph.)
Suppose an edge 
and an edge  of 
cross at a point .
To eliminate this crossing, we add the intersection 
point  as a new vertex to the graph, and we replace
 and  by the four new
edges , , 
and .
Furthermore, if  is an edge of , we replace it by
the two edges , ,
and if  is an edge of , we replace it by
the two edges , . See Figure~\ref{fig:resolving}.
We say that this \emph{resolves} the crossing between  and .
Let  be the graph obtained by iteratively resolving all
crossings in .
\begin{figure}[htb]
\centering
\includegraphics[scale=1.3]{2doracle-resolving}
\caption{Resolving a crossing. Since the edge  exists, we also add  and
 as edges.}
\label{fig:resolving}
\end{figure}

First, we want to show that resolving crossings keeps the \emph{local}
reachability relation between the four vertices of the crossing edges.
Intuitively speaking, the  restriction 
forces the vertices to be close together. This guarantees the existence of
additional edges between  in , and these edges
justify the new paths introduced by resolving the crossing.

To formally prove this, we first need a geometric observation.
For a point ,
let  and  be the disk and the circle around
 with radius .

\begin{lemma}
\label{lem:calculus}
Let  be two points in  with .
\begin{enumerate}[(i)]
\item Let , and let   for
some  such that
 and  lie on different
 sides of the line through  and .  Then . See Figure \ref{fig:calculusa1}.
\item Let
. Then, . See Figure \ref{fig:calculusa}.
\end{enumerate}
\end{lemma}

\begin{proof}
(i): Let   be the intersection point
of the line segments  and .
Then .
Using that  and , the Pythagorean Theorem
gives . Similarly, we can compute  as a function of :
 with  we get .
We want to show that

which holds since .

(ii): Let   be the intersection point
of  and .
Use the Pythagorean Theorem in the triangles  and  in  Figure~\ref{fig:calculusa}
we get that .
\end{proof}

\begin{figure}[hbt]
\centering
\begin{subfigure}[b]{0.5\textwidth}
\centering
  \includegraphics[scale=0.53]{circleintersection2}
  \caption{}
\label{fig:calculusa1}
\end{subfigure}
\begin{subfigure}[b]{0.45\textwidth}
  \includegraphics[scale=0.5]{circleintersection1}
\caption{}
\label{fig:calculusa}
\end{subfigure}
\caption{The cases (i) and (ii) of Lemma~\ref{lem:calculus}.}
\end{figure}


\begin{lemma}
\label{lem:resolving}
Suppose that  and  are
edges in a transmission graph  that cross.
Let  be the transmission graph induced by
 and .  If , then  reaches  in
 and  reaches  in .
\end{lemma}

\begin{proof}
We may assume that . Furthermore, we assume that 
. This does
not add new edges and thus reachability in the new graph
implies reachability in .
We show that if either  does not reach  (case 1)
or  does not reach  (case 2), then . Hence
 cannot be an edge of  despite our assumption.

Case 1:  does not reach .
Then we have , , 
and .
Equivalently this gives 
and .
Thus, the positions of  and  that minimize 
are the intersections 
and  on different sides of
the line through  and .
To further  minimize , observe that  depends on the distance
of  and  and that  strictly decreases as  grows, i.e.,
as  approaches .
For the limit case , we are in the situation
of Lemma~\ref{lem:calculus}(i) with  and 
and thus we would get .
But since , we must have  and by
strict monotonicity, it follows that ,
as desired.

Case 2:  does not reach . Then we have
, ,  and .
We scale everything, such that , and we reduce
,  once again to .
Now, the positions of  and  minimizing  are
. As above,
further minimizing  gives .
By Lemma~\ref{lem:calculus}(ii), we have  and
thus  cannot be an edge of  (note that even after scaling we have
 since we assumed that ).
\end{proof}

Recall that we iteratively resolve crossings in  and call the resulting graph
. Next, we show that for any , if  can
reach  in , then  can also reach  in .
This seems to be a bit more difficult than what one might expect, because
when resolving the crossings, we introduce new vertices and edges
to which Lemma~\ref{lem:resolving} is not directly applicable 
(since the intermediate graph is not a transmission graph). Thus, 
a priori, we cannot exclude the possiblity that there are new 
reachabilities in  that use the additional 
vertices and edges.

\begin{lemma}
\label{lem:globalreachability}
Let  be a transmission graph of a set  of points with . Let 
be the planar graph obtained from  by resolving all crossings as described above. Then,
for any two points  ,  can reach  in  if and only if 
can reach  in .
\end{lemma}

\begin{proof}
If  and can reach  in  then it immediately follows from our construction that  can reach
 in . We now prove the converse.

Each edge  of  lies on an edge  of  with the
same direction as . We call  the \emph{supporting edge} of .
Consider a path  from  to  in .
A \emph{supporting switch} on  is a pair of consecutive edges 
 on 
such that the supporting edge of  and the supporting edge of  are different.

A pair  such that  can reach
 in , but not in  is called a
\emph{bad pair}.
The proof is by contradition. We assume that there exists a bad pair and  among all bad pairs,
we pick a pair 
and a path  from  to  (in ) such that
 consists of  a
minimum number of \emph{supporting switches}, among all paths (in ) between bad pairs.
Let  be the supporting switches 
along  and let
  be the
sequence of supporting edges as they are visited along
 (, ).
That is  is on , for ,  and  are on , and
 is on .
Let  be the common vertex of  and . The vertex  is on the segments  and
.

\begin{figure}[htb]
\centering
\includegraphics[scale=1.0]{globalreachability-path}
\caption{A path (blue) with  supporting edges that is in
 but not in .}
\label{fig:globalreachability-path}
\end{figure}

\begin{claim}
The following holds in :
\textbf{(P1)}  reaches ;
\textbf{(P2)}  reach ;
\textbf{(P3)}   and  do not reach ; and
\textbf{(P4)} there is no edge ,
for .
Furthermore, for , we have that
\textbf{(P5)}
the vertex  is in the interior of
 and

and \textbf{(P6)}  lies in the interior of
.
\end{claim}

\begin{proof}
\textbf{P1} and \textbf{P2} follow from the minimality of ,
and \textbf{P3} follows from \textbf{P2}.
For \textbf{P4}, assume
that  contains an edge , for .
By \textbf{P1},  reaches  in  and thus  reaches ,
despite \textbf{P3}.
For \textbf{P5}, notice that if  is not in the interior of 
 and
, then
. But then, by \textbf{P1},  reaches
, despite \textbf{P3}.
\textbf{P6}
is immediate from \textbf{P5} and the fact that 
 cannot be equal to .
\end{proof}

By Lemma~\ref{lem:resolving}, we have ,
since for two crossing edges () no new 
reachabilities between the endpoints are created.
We now argue that the path  cannot exist.
Since  and  cross,
Lemma~\ref{lem:resolving} implies that  contains at least one
of
,
or . This is because by Lemma~\ref{lem:resolving}, in the 
induced subgraph for , , , , the vertex 
 can reach , and this requires that at least one of the edges
, or  be present.
By \textbf{P3}, neither
 nor 
exist.
There are two cases, depending on whether  contains
, or 
(see Fig.~\ref{fig:globalreachability}).
Each case  leads to a contradiction with the minimality of .
\begin{figure}[htb]
\centering
\includegraphics[scale=0.7]{globalreachability}
\caption{Either  or  locks  in
the corresponding triangle.}
\label{fig:globalreachability}
\end{figure}

\textbf{Case 1.}  contains .
Consider the triangle .
Since , we have
.
Thus, by \textbf{P3}, none of 
may lie inside .
By \textbf{P6}, 
intersects the boundary of  in the line segment
.
First, suppose that . In this case
 (otherwise  could reach ).
Thus,  intersects the boundary of 
twice, so  either intersects
  or .
In both cases, Lemma~\ref{lem:resolving} shows that  reaches
. Thus, we must have .

We now prove that the intersection  of
 and  must
lie in .
If
  intersects 
once, then ,
and therefore , that by \textbf{P6} must lie on the segment
, is in . So assume that
 intersects
 twice, and let  be the second intersection
point of  with the boundary of . We claim that  follows 
along . Assume otherwise, then since by \textbf{P6},   follows
  on ,
we can construct a path with fewer supporting switches than :
If , we omit
 and
if ,
we omit 
and substitute  by .
By the same argument,  cannot follow  on
.
Thus,  lies on
the line segment .
This concludes the proof that
 .
Now, consider the segment . Since we observed that
, we have that 
intersects , and we can again replace  by a path with fewer supporting 
switches from  to .

\textbf{Case 2.}  contains .
Consider the triangle
. We claim
that .
Then the  argument continues analogously  to
Case 1. In particular, 
\textbf{P3} still shows that none of 
may lie inside . The case  
can again be ruled out, because then  would have to
intersect either  or , and 
Lemma~\ref{lem:resolving} would show that  can reach .
For , we can again show that 
 would have to lie inside  (otherwise,
we could obtain bad pair with fewer supporting switches
by either omitting  or omitting  and 
substituting  by ). Thus, by considering
the segment , we could again find 
a bad pair with fewer supporting switches.

We now show that
that .
If  then  and we are done.
Otherwise,
let  be the disk with center  and 
on its boundary. We claim that  contains .
Let  be the intersection of  with .
Since , . Therefore
 and
.
This implies that  is contained in  and therefore
 is contained in  as required.
\end{proof}

\paragraph*{Putting it together.}
Let  be a transmission graph of a set  of points, given 
by the point set  and the associated radii.
To prove Lemma~\ref{lem:planarization}, we first construct the sparse
subgraph  of  as in Lemma~\ref{lem:pruning} in time .
Then we iteratively resolve the crossings in  to obtain
.
Since  has  crossings that can be found in  time,
this takes  time.

The graph  is not necessarily a transmission graph. Therefore, we cannot 
directly apply Lemma~\ref{lem:globalreachability} to 
and conclude that  preserves the reachability relation
(between points of ) of  and therefore of
. Nevertheless, in the following lemma, we will
prove  that  and  do have the same reachability 
relation between points of .
\begin{lemma}
Let  be a transmission graph on a set  of points. Let  be a sparse subgraph of  constructed  as in Lemma~\ref{lem:pruning}
and let  be the planar graph obtained by resolving the crossings in  as described above.
Then for any two points  ,  can reach  in  if and only if 
can reach  in .
\end{lemma}
\begin{proof}
Let  be the graph obtained by resolving the crossings
in , as described above.  If  can reach  in , then by 
Lemma~\ref{lem:pruning},  can reach  in , and by the definition of
the way we resolve  crossings,  can reach  also in .

Conversely,
if  can reach 
in ,
then  can reach  in , because a subdivision of every edge
of  is contained in . Therefore,
by Lemma \ref{lem:globalreachability},  can reach  in .
\end{proof}


\subsection{Polynomial Dependence on }
\label{sec:psiconst}
We now present a standard reachability oracle whose performance parameters
depend polynomially on the radius ratio .
Together with Theorem~\ref{thm:geometricreachability} we will obtain the
following result:
\begin{theorem}
\label{thm:2doraclefixed}
Let  be the transmission graph for a set 
of  points.
We can construct a geometric reachability oracle for 
with  and  in
time .
\end{theorem}

Our approach is based on a geometric separator theorem for
planar disks.
Let  be the set of disks associated with the points in .
For a subset  of  we write
 and we let
 be the area occupied by .
Alber and Fiala show how to find a separator for 
with respect to  \cite{AlberFiala04}.

\begin{theorem}[Theorem~4.12 in~\cite{AlberFiala04}]
\label{thm:diskseparator}
There exist positive constants  and  such
that the following holds:
let  be a set of  disks and let   be the ratio of the largest
and the smallest radius in .
Then we can find in   time
a partition  of  satisfying
(i) ,
(ii)  and
(iii) .
\end{theorem}
Since any directed path in  lies completely in , any path from
a vertex of a disk in  to a vertex of a disk in  needs to use at least one vertex of a disk in , see
Figure~\ref{fig:separator}.
(Notice that there may not be a path from a center  of a disk in  to another center  of a disk in   containing only centers of disks in . It may be that every path from  to  goes through a center corresponding to a disk in .)
 Since  is small, we can approximate 
with a few grid cells. We choose the diameter of the cells small enough such that
all vertices in one cell form a clique and are equivalent in terms of reachability.
We can thus pick one vertex per cell and store the
reachability information for it. Applying this idea
recursively gives a separator tree
that allows us to answer reachability queries efficiently. The details follow.

\begin{figure}[htb]
\centering
\includegraphics[scale=0.9]{2doracle-separator}
\caption{Any path from  to  needs to use at least
one vertex of . Since  is small, we can approximate  with
few grid cells.}
\label{fig:separator}
\end{figure}

\paragraph*{Preprocessing Algorithm and Space Requirement.}
For the preprocessing phase, consider the grid  whose
cells have diameter .
All vertices in a single cell form a  clique in , so the reachability information of all vertices in a grid cell is the same and it
suffices to compute this information only
for one such vertex. For each non-empty cell
, we pick an arbitrary vertex 
as the \textit{representative} of .
For a subset  of disks we denote the
 set of  representatives of the non-empty cells containing centers of the disks in  by .

We recursively create a separator tree 
that contains all the required reachability information.
Each node   of  corresponds to an induced subgraph of the transmission graph and
the root corresponds to the entire transmission graph.
We construct the tree top down. Let  be the subgraph associated with a node  and let
 be the set of disks of the vertices of .
We compute a separator   and subsets , satisfying the conditions of Theorem~\ref{thm:diskseparator} for .
Let  be all cells in  containing centers of disks of
 . Let  be the set of representatives of ,
and let  be all disks with centers in  (Note that  contains ).
For each , we store all the disk centers of
 that  can
reach and all the disk centers of
 that can reach  in .
We recursively compute separator trees for  the transmission graphs induce by the centers of  and
the centers of
. The roots of these trees are children of  in .

To obtain the  required reachability information at a node  of ,
we compute a -spanner  for the transmission
graph , as in Theorem~\ref{thm:2dspanner}.
Since we are only
interested in the reachability properties of the spanner,
 (or any constant) suffices.
For each ,
we compute a BFS tree in  with root . Next, we reverse all
edges in , and we again compute BFS-trees for all 
in the transposed graph. This gives the required reachability
information for .

As  has  levels,
the total running time for computing the spanners is
.
Since the spanners are sparse, the time for computing a single BFS-tree
associated with a node  is . It follows that
 the time for computing all
BFS-trees at  is  and the time to compute all BFS trees of all nodes  of
the separator tree  is
. To bound this sum,
we need the
following lemma.

\begin{lemma}
\label{lem:diskunioncover}
Let  be a set of  disks with radius at least . Then
the number of cells in  that intersect
 is .
\end{lemma}

\begin{proof}
Let  be the set of all cells that intersect
. For , the \emph{neighborhood}
of  is defined as the region consisting of
 and its eight surrounding cells.
Let  be a maximal subset of cells
in  whose neighborhoods are pairwise disjoint.
Then, .
Now, let .
Since all disks in  have radius at
least , there is a disk  (not necessarily
in ) of radius
exactly  such that 
and such that  intersects the boundary of .
Thus, the intersection of  and the neighborhood
of  contributes at least  to .
Since the neighborhoods for the cells in  are pairwise disjoint,
it follows that , as claimed.
\end{proof}

Now, by Lemma~\ref{lem:diskunioncover}, we have .
Thus, if we denote by  the nodes of the separator tree at level
 of the recursion, we get that
the sum  is proportional to

Thus, the total preprocessing time is
.
The space requirement is also bounded by
the preprocessing time.

\paragraph*{Query Algorithm.}
Let  be given. We assume that  and  are the representatives of their cells. (Otherwise
we replace either  or  by its representative.)
Let  and  be the nodes in  with
 and .
Let  be least common ancestor of  and . We can find  by
 walking up the tree starting from  and  in  time.
Let  be the  path from  to the root
of . We check for each 
whether  can reach  and whether  can reach . If so,
we return YES.
If there is no such vertex
 then we return NO.
Since  increases geometrically along , the running time
is dominated by the time for processing the root, which is
.
Bounding  by ,  we get that the total query time is
.

It remains to argue that our query algorithm is correct.
By construction, it follows
that we return YES only if there is a path from  to .
Now, suppose there is a path  in  from  to ,
where  and  are representatives of their grid cells with .
Let  be the nodes in  with
 and . Let 
be their least common ancestor, and  be the path from 
to the root.
By construction,  contains a disk 
of a vertex  in .
Let  be the node of  closest to the root such that
 contains such a disk, and let  be a vertex on  with
.
Let  be the representative of the cell  containing .
Since the vertices in  constitute a clique,
 can reach  and  can reach  in
.
Thus, when walking along , the algorithm will discover  and
the path from  to .
Theorem~\ref{thm:2doraclefixed} now follows.


\subsection{Logarithmic Dependence on }
\label{sec:psipoly}

Finally, we improve the dependence on  to be logarithmic,
at the cost of a slight increase at the exponent of .
We prove the following theorem by constructing a standard reachability oracle and
then using Theorem~\ref{thm:geometricreachability}.
\begin{theorem}
\label{thm:2doraclebounded}
Let  be the transmission graph for a
set  of  points in the plane.
We can construct a geometric reachability oracle for 
with  and
 that answers all
queries correctly with high probability.
The preprocessing time is
.
\end{theorem}

We scale everything such that the smallest radius in
 is .
Our approach is as follows: let .
If there is a --path  with  ``many'' vertices, we detect
this by taking a large enough
random sample  and by storing the
reachability information for every vertex in .
If there is a path from  to  with ``few'' vertices, then 
must be ``close'' to , where ``closeness'' is defined relative to
the largest radius along the path. The radii of the point of  can lie in
 different scales, and for each scale we
store local information to find such a ``short'' path.

\paragraph*{Long Paths.}
Let  be a parameter to be
determined later.
First, we show that a random sample can be used to detect paths with
many vertices.

\begin{lemma}\label{lem:sampling}
We can sample a set  of size  such that
the following holds with  probability
at least : For any two points
, if there is a path  from  to  in  with
at least  vertices, then .
\end{lemma}

\begin{proof}
We take  to be a random subset of size
  vertices from .
Now fix  and  and let  be a path from  to  with
 vertices.
The probability that  contains no vertex from  is
 by our choice of .
Since there are  ordered vertex pairs, the union bound
shows that the probability that  fails to detect a pair of
vertices connected by a long path is at most
.
\end{proof}

We draw a sample  as in Lemma~\ref{lem:sampling}, and for
each , we store two Boolean arrays that indicate for each
 whether  can reach  and whether  can reach
. This requires  space.
It remains to deal with vertices that are connected by a path with
fewer than  vertices.

\paragraph{Short Paths.}
Let . We consider the  grids
 (recall that the cells in  have
diameter ). For each cell , let
 be the vertices  with .
The set  forms a clique in , and for each
, the disk  contains the cell
. For every  and for every 
with ,
we fix an arbitrary  \emph{representative point}
.

The \emph{neighborhood}  of  is defined
as the set of all cells in  that have distance at most
 from . We have
.
Let  be the vertices
that lie in the cells of .

For every vertex , and
for every  we store two sorted lists of representative of cells
 such that . The first list
contains all  representatives , such that   and  can reach  .
The second list contains all
 representatives ,  such that   and    can reach .
A vertex  belongs to 
sets , so the total space is
.

\paragraph*{Performing a Query.}
Let  be given. To decide whether  can reach ,
we first check the Boolean tables for all  points
in . If there
is an  such that  reaches
 and  reaches , we return YES. If not,
for ,
we consider the list of representatives
that are reachable from  in their neighborhood at level  and
the list of representatives that can reach  in their
neighborhood at level . We check
whether these lists contain a common element. Since the lists are
sorted, this can be done in time linear in their size.
If we find a common representative for some , we return YES.
Otherwise, we return NO.

We now prove the correctness of the query algorithm. First note that we
return YES, only if there is a path from  to
.  Now suppose that there is a path  from  to .
If  has at least  vertices,
then by Lemma~\ref{lem:sampling}, the sample  hits 
with probability at least , and the algorithm returns YES.
If  has less than  vertices, let  be the
vertex of  with the largest radius,
and let  be such that the radius of  lies in .
Let  be the cell of  that contains .
Since  has at most  vertices, and since each edge
of  has length at most , the path  lies
entirely in   and in particular
 both  and  are in
. Since  and since
 forms a clique in , the representative point
 of  can be reached from  and can reach .
It follows from the definition of the sorted lists of representatives stored with  and , that
  is
contained in the list of representatives  reachable  from  and in the
list of representatives that can reach .
Our query algorithm detects this when it checks
whether the corresponding
lists for  and  at level , have a nonempty intersection.

\paragraph*{Time and Space Requirements.}
We consider first the query time. To test if there is a long path from
 to  we traverse , and for every  we test,
 in  time, whether
 can reach  and whether  can reach .
This takes  time.
To test if there is a short path from  to  we use
the lists of reachable representatives associated with  and  at each of the  grids.
At each level
we step through two lists of size . So
in total we spend  time.
We choose  to balance the times we spend to detect short and long paths.
That is  satisfies

This yields .
This choice of  results in a space bound of
.

For the preprocessing algorithm, we first compute the reachability arrays
for each . To do so, we build a 2-spanner  for 
as in Theorem~\ref{thm:2dspanner} in   time.
Then,
for each  we perform a BFS search in  and its transposed graph.
This gives all vertices that  can reach and
all vertices that can reach 
in  total time.
For the short paths, the preprocessing algorithm goes as follows:
For each  and
for each cell  that has a representative ,
we compute a 2-spanner  as in Theorem~\ref{thm:2dspanner} for
.
For each representative , we do a BFS search in  and
the transposed graph, each starting from . This gives all
 that can reach 
and that are reachable from  via a short path.
The running time is dominated by the time for constructing the
spanners. Since each point  is contained in

different , and
since constructing  takes

time, the bound on the  preprocessing time stated in
Theorem~\ref{thm:2doraclebounded} follows.

\section{Conclusion}
Transmission graphs constitute a natural class of
directed graphs for which non-trivial reachability
oracles can be constructed. As mentioned in the
introduction, it seems to be a very challenging
open problem to obtain similar results for general directed
graphs.  We believe that our results only scratch
the surface of the possibilities offered by transmission graphs,
and several interesting open problems remain.

All our results on 2-dimensional transmission graphs depend on the radius ratio .
Whether this dependency can be avoided is a major open question.
Our most efficient reachability oracle is for . In this case
the reachability relation in a transmission graph with  vertices can be represented
by the reachability relation in a planar graph with  vertices.
However, it is not clear to us that the upper bound of  in this result is
tight.
Can we obtain a similar construction for, say, ? Is there
 a way to represent the reachability relation in \emph{any} transmission graph, regardless of ,
by the reachability relation in a planar graph with  vertices?
This would immediately imply a non-trivial reachability oracle for any value
of .

Conversely, it is interesting to see if we can represent
the reachability relation of an arbitrary directed graph
using a transmission graph. If this is possible, the relevant questions
are how many vertices such a transmission graph must have, what is the required
radius ratio, and how fast can we compute it. A representation with not too many
vertices and low radius ratio would lead to efficient reachability oracles for
general directed graphs.

\paragraph*{Acknowledgments.}
We like to thank G\"unter Rote and the anonymous reviewers 
for valuable comments, in particular for pointing out a
drastic simplification for the one-dimensional reachability oracle.

\bibliographystyle{abbrv}
\bibliography{literature}
\end{document}
