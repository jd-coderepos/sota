
\documentclass[10pt]{article} \usepackage[accepted]{tmlr}




\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{hyperref}
\usepackage{url}


\title{A Generalist Agent}


\RequirePackage{authblk}
\setcounter{Maxaffil}{0}
\setlength{\affilsep}{0.2em}
\renewcommand\Authfont{\normalfont\bfseries\fontsize{9}{13}\selectfont}
\renewcommand\Affilfont{\normalfont\fontsize{8}{10}\selectfont}
\makeatletter
\renewcommand\AB@affilsepx{, \protect\Affilfont}
\makeatother
\renewcommand\Authands{ and }

\author[*,]{Scott Reed}
\author[*]{Konrad~\.Zo\l{}na}
\author[*]{Emilio~Parisotto}
\author[]{Sergio~Gómez~Colmenarejo}
\author[ \hspace{-1ex}]{Alexander~Novikov}
\author[ \hspace{-1ex}]{Gabriel~Barth-Maron}
\author[ \hspace{-1ex}]{Mai~Giménez}
\author[ \hspace{-1ex}]{Yury~Sulsky}
\author[ \hspace{-1ex}]{Jackie~Kay}
\author[ \hspace{-1ex}]{Jost~Tobias~Springenberg}
\author[ \hspace{-1ex}]{Tom~Eccles}
\author[ \hspace{-1ex}]{Jake~Bruce}
\author[ \hspace{-1ex}]{Ali~Razavi}
\author[ \hspace{-1ex}]{Ashley~Edwards}
\author[ \hspace{-1ex}]{Nicolas~Heess}
\author[ \hspace{-1ex}]{Yutian~Chen}
\author[ \hspace{-1ex}]{Raia~Hadsell}
\author[ \hspace{-1ex}]{Oriol~Vinyals}
\author[ \hspace{-1ex}]{Mahyar~Bordbar}
\author[]{Nando~de~Freitas}

\affil[*]{Equal contributions}
\affil[]{Equal senior contributions}
\affil[ ]{All authors are affiliated with DeepMind \hskip 1.5cm \textit{reedscot@deepmind.com}}

\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\def\month{11}  \def\year{2022} \def\openreview{\url{https://openreview.net/forum?id=1ikK0kHjvj}} 


\usepackage[normalem]{ulem}
\useunder{\uline}{\ul}{}
\usepackage{xcolor}
\usepackage{subcaption,booktabs}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{listings}
\usepackage{array}
\usepackage{algpseudocode}
\usepackage{tocloft}
\usepackage{etoc}
\usepackage{setspace}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{kantlipsum, lipsum}
\usepackage{dsfont}
\usepackage{float}
\usepackage{graphicx}
\usepackage[justification=raggedright,font=small]{caption}
\usepackage{makecell}

\newcommand{\model}{{Gato}}
\newcommand{\dmlab}{{DM Lab}}
\newcommand{\atari}{{ALE Atari}}
\newcommand{\ataritwo}{{ALE Atari Extended}}
\newcommand{\ataribreakout}{{ALE Atari Breakout Variations}}
\newcommand{\sokoban}{{Sokoban}}
\newcommand{\babyai}{{BabyAI}}
\newcommand{\dmcontrol}{{DM Control Suite}}
\newcommand{\dmcontrolpixels}{{DM Control Suite Pixels}}
\newcommand{\dmcontrolrandomsmall}{{DM Control Suite Random Small}}
\newcommand{\dmcontrolrandomlarge}{{DM Control Suite Random Large}}
\newcommand{\metaworld}{{Meta-World}}
\newcommand{\procgen}{{Procgen Benchmark}}
\newcommand{\stacksim}{{RGB Stacking simulator}}
\newcommand{\stackreal}{{RGB Stacking real robot}}
\newcommand{\mrl}{{Modular RL}}
\newcommand{\mpg}{{DM Manipulation Playground}}
\newcommand{\playroom}{{Playroom}}

\newcommand{\expect}[2]{\mathds{E}_{{#1}} \left[ {#2} \right]}
\newcommand{\myvec}[1]{\boldsymbol{#1}}
\newcommand{\myvecsym}[1]{\boldsymbol{#1}}

\graphicspath{{figures/}}

\begin{document}

\maketitle

\begin{abstract}
Inspired by progress in large-scale language modeling, we apply a similar approach towards building a single generalist agent beyond the realm of text outputs.
The agent, which we refer to as \model, works as a multi-modal, multi-task, multi-embodiment generalist policy.
The same network with the same weights can play Atari, caption images, chat, stack blocks with a real robot arm and much more, deciding based on its context  whether to output text, joint torques, button presses, or other tokens.
In this report we describe the model and the data, and document the current capabilities of \model.
\end{abstract}

\begin{figure*}[ht]
\vskip -0.35cm
    \includegraphics[width=\textwidth]{figures/data_sequences.pdf}
    \caption{{\bf A generalist agent.} \model{} can sense and act with different embodiments across a wide range of environments using a single neural network with the same set of weights. \model{} was trained on 604 distinct tasks with varying modalities, observations and action specifications.}
\vskip -0.35cm
\end{figure*}

\section{Introduction}
\label{sec:introduction}


There are significant benefits to using a single neural sequence model across all tasks.
It reduces the need for hand crafting policy models with appropriate inductive biases for each domain.
It increases the amount and diversity of training data since the sequence model can ingest any data that can be serialized into a flat sequence.
Furthermore, its performance continues to improve even at the frontier of data, compute and model scale~\citep{kaplan2020scaling, hoffmann2022training}.
Historically, generic models that are better at leveraging computation have also tended to overtake more specialized domain-specific approaches~\citep{sutton2019bitter}, eventually.

In this paper, we describe the current iteration of a general-purpose agent which we call \model{}, instantiated as a single, large, transformer sequence model.
With a single set of weights, \model{} can engage in dialogue, caption images, stack blocks with a real robot arm, outperform humans at playing Atari games, navigate in simulated 3D environments, follow instructions, and more.

While no agent can be expected to excel in all imaginable control tasks, especially those far outside of its training distribution, we here test the hypothesis that training an agent which is generally capable on a \emph{large number} of tasks is possible; and that this general agent can be adapted with little extra data to succeed at an even larger number of tasks.
We hypothesize that such an agent can be obtained through scaling data, compute and model parameters, continually broadening the training distribution while maintaining performance, towards covering any task, behavior and embodiment of interest.
In this setting, natural language can act as a common grounding across otherwise incompatible embodiments, unlocking combinatorial generalization to new behaviors.


We focus our training at the operating point of model scale that allows real-time control of real-world robots, currently around 1.2B parameters in the case of~\model{}.
As hardware and model architectures improve, this operating point will naturally increase the feasible model size, pushing generalist models higher up the scaling law curve.
For simplicity~\model{} was trained offline in a purely supervised manner; however, in principle, there is no reason it could not also be trained with either offline or online reinforcement learning (RL). 


\begin{figure*}[t]
    \raggedleft
    \vskip 0.35cm
    \includegraphics[width=\linewidth]{figures/diagram_train.pdf}
    \vskip 0.35cm
    \caption{{\bf Training phase of \model{}}. Data from different tasks and modalities is serialized into a flat sequence of tokens, batched, and processed by a transformer neural network akin to a large language model. Masking is used such that the loss function is applied only to target outputs, i.e. text and various actions.}
    \label{fig:calm-diagram}
\end{figure*}

\section{Model}
\label{sec:model}


The guiding design principle of \model{} is to train on the widest variety of relevant data possible, including diverse modalities such as images, text, proprioception, joint torques, button presses, and other discrete and continuous observations and actions. 
To enable processing this multi-modal data, we serialize all data into a flat sequence of tokens.
In this representation, \model{} can be trained and sampled from akin to a standard large-scale language model.
During deployment, sampled tokens are assembled into dialogue responses, captions, button presses, or other actions based on the context.
In the following subsections, we describe \model{}'s tokenization, network architecture, loss function, and deployment.
\vskip 0.4cm
\subsection{Tokenization}\label{sec:tokenization}
\vskip 0.2cm
There are infinite possible ways to transform data into tokens, including directly using the raw underlying byte stream.
Below we report the tokenization scheme we found to produce the best results for \model{} at the current scale using contemporary hardware and model architectures.
\begin{itemize}
    \item Text is encoded via SentencePiece~\citep{kudo-richardson-2018-sentencepiece} with 32000 subwords into the integer range [0, 32000).
    \item Images are first transformed into sequences of non-overlapping  patches in raster order, as done in ViT~\citep{dosovitskiy2020image}. Each pixel in the image patches is then normalized between  and divided by the square-root of the patch size (i.e.\ ).
    \item Discrete values, e.g. Atari button presses, are flattened into sequences of integers in row-major order. The tokenized result is a sequence of integers within the range of .
    \item Continuous values, e.g. proprioceptive inputs or joint torques, are first flattened into sequences of floating point values in row-major order. The values are mu-law encoded to the range   if not already there (see Figure~\ref{fig:proprio_tokenization} for details), then discretized to 1024 uniform bins. The discrete integers are then shifted to the range of . 
\end{itemize}

\noindent After converting data into tokens, we use the following canonical sequence ordering.
\begin{itemize}
    \item Text tokens in the same order as the raw input text.
    \item Image patch tokens in raster order.
    \item Tensors in row-major order.
    \item Nested structures in lexicographical order by key.
    \item Agent timesteps as observation tokens followed by a separator, then action tokens.
    \item Agent episodes as timesteps in time order.
\end{itemize}

\noindent Further details on tokenizing agent data are presented in the supplementary material (Section~\ref{sec:tokenization_appendix}).
\vskip 0.4cm
\subsection{Embedding input tokens and setting output targets}
\label{sec:embed}
\vskip 0.2cm
After tokenization and sequencing, we apply a parameterized embedding function  to each token (i.e. it is applied to both observations and actions) to produce the final model input.
To enable efficient learning from our multi-modal input sequence  the embedding function performs different operations depending on the modality the token stems from:



\begin{itemize}
\item Tokens belonging to text, discrete- or continuous-valued observations or actions for any time-step are embedded via a lookup table into a learned vector embedding space. Learnable position encodings are added for all tokens based on their local token position within their corresponding time-step. 
\item Tokens belonging to image patches for any time-step are embedded using a single ResNet~\citep{he2016deep} block to obtain a vector per patch. For image patch token embeddings, we also add a learnable within-image position encoding vector.
\end{itemize}
We refer to appendix Section~\ref{sec:position_encodings} for full details on the embedding function.

As we model the data autoregressively, each token is potentially also a target label given the previous tokens.
Text tokens, discrete and continuous values, and actions can be directly set as targets after tokenization.
Image tokens and agent nontextual observations are not currently predicted in \model{}, although that may be an interesting direction for future work.
Targets for these non-predicted tokens are set to an unused value and their contribution to the loss is masked out.
\vskip 0.4cm
\subsection{Training}
\vskip 0.2cm
Given a sequence of tokens  and parameters , we model the data using the chain rule of probability:

Let  index a training batch of sequences .
We define a masking function  such that  if the token at index  is either from text or from the logged action of an agent, and  otherwise.
The training loss for a batch  can then be written as


As described above, \model{}'s network architecture has two main components: the parameterized embedding function which transforms tokens to token embeddings, and the sequence model which outputs a distribution over the next discrete token.
While any general sequence model can work for next token prediction, we chose a transformer~\citep{vaswani2017attention} for simplicity and scalability.
\model{} uses a 1.2B parameter decoder-only transformer with 24 layers, an embedding size of 2048, and a post-attention feedforward hidden size of 8196 (more details in Section~\ref{app:trans_hparams}).

Because distinct tasks within a domain can share identical embodiments, observation formats and action specifications, the model sometimes needs further context to disambiguate tasks.
Rather than providing e.g. one-hot task identifiers, we instead take inspiration from ~\citep{sanh2022multitask,wei2021finetuned,brown2020language} and use prompt conditioning.
During training, for  of the sequences in each batch, a prompt sequence is prepended, coming from an episode generated by the same source agent on the same task.
Half of the prompt sequences are from the end of the episode, acting as a form of goal conditioning for many domains; and the other half are uniformly sampled from the episode.
During evaluation, the agent can be prompted using a successful demonstration of the desired task, which we do by default in all control results that we present here.

Training of the model is performed on a 16x16 TPU v3 slice for 1M steps with batch size 512 and token sequence length , which takes about 4 days.
Architecture details can be found in Section~\ref{app:model_arch}.
Because agent episodes and documents can easily contain many more tokens than fit into context, we randomly sample subsequences of  tokens from the available episodes.
Each batch mixes subsequences approximately uniformly over domains (e.g. Atari, MassiveWeb, etc.), with some manual upweighting of larger and higher quality datasets (see Table~\ref{table:datasets} in Section~\ref{sec:datasets} for details).
\vskip 0.4cm
\subsection{Deployment}
\label{sec:evaluation_protocol}
\vskip 0.2cm
\begin{figure*}[t]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/eval4x.png}
	\caption{\textbf{Running \model{} as a control policy.} \model{} consumes a sequence of interleaved tokenized observations, separator tokens, and previously sampled actions to produce the next action in standard autoregressive manner. The new action is applied to the environment -- a game console in this illustration, a new set of observations is obtained, and the process repeats.}
	\label{fig:evaluation}
\end{figure*}

Deploying \model{} as a policy is illustrated in Figure~\ref{fig:evaluation}.
First a prompt, such as a demonstration, is tokenized, forming the initial sequence.
By default, we take the first 1024 tokens of the demonstration.
Next the environment yields the first observation which is tokenized and appended to the sequence.
\model{} samples the action vector autoregressively one token at a time.
Once all tokens comprising the action vector have been sampled (determined by the action specification of the environment), the action is decoded by inverting the tokenization procedure described in Section~\ref{sec:tokenization}.
This action is sent to the environment which steps and yields a new observation.
The procedure repeats.
The model always sees all previous observations and actions in its context window of 1024 tokens.
We found it beneficial to use transformer XL memory during deployment, although it was not used during training~\citep{dai2019transformer}.


\section{Datasets}
\label{sec:datasets}


\model{} is trained on a large number of datasets comprising agent experience in both simulated and real world environments, as well as a variety of natural language and image datasets.
The datasets we use and their attributes are listed in Table~\ref{table:datasets}.
The approximate number of tokens per control dataset is computed assuming the tokenization mechanism described in Section~\ref{sec:tokenization}.


\begin{table*}
    \caption{
    {\bf Datasets.}
    Left: Control datasets used to train \model{}. Right: Vision \& language datasets. Sample weight means the proportion of each dataset, on average, in the training sequence batches.\label{table:datasets}}
    \centering
    \scalebox{0.9}{
    \begin{tabular}[t]{|l|c|c|c|c|}
          \hline
          Control environment & Tasks & Episodes & \makecell{Approx. \\ Tokens} & \makecell{Sample \\ Weight} \\ 
          \hline
          \dmlab{} & 254 & 16.4M & 194B & 9.35\% \\
          \atari{} & 51  & 63.4K & 1.26B & 9.5\% \\
          \ataritwo{} & 28  & 28.4K & 565M & 10.0\% \\  \sokoban{} & 1   & 27.2K & 298M & 1.33\% \\
          \babyai{} & 46  & 4.61M & 22.8B & 9.06\% \\
          \dmcontrol{}  & 30  & 395K  & 22.5B & 4.62\% \\
          \dmcontrolpixels{} & 28  & 485K & 35.5B & 7.07\% \\
          \dmcontrolrandomsmall{} & 26  & 10.6M & 313B & 3.04\% \\
          \dmcontrolrandomlarge{} & 26  & 26.1M & 791B & 3.04\% \\
          \metaworld{} & 45  & 94.6K & 3.39B & 8.96\% \\
          \procgen{} & 16  & 1.6M  & 4.46B & 5.34\% \\
          \stacksim{} & 1   & 387K  & 24.4B & 1.33\% \\
          \stackreal{} & 1   & 15.7K & 980M  & 1.33\% \\
          \mrl{} & 38  & 843K  & 69.6B & 8.23\% \\
          \mpg{} & 4   & 286K  & 6.58B & 1.68\% \\
          \playroom{} & 1 & 829K & 118B & 1.33\% \\
          \hline
          Total               & 596 & 63M & 1.5T & 85.3\% \\
          \hline
    \end{tabular}}
    \scalebox{0.9}{
    \begin{tabular}[t]{|l|c|}
        \hline
        Vision / language dataset & \makecell{Sample \\ Weight} \\ 
        \hline
        MassiveText & 6.7\%  \\
        M3W & 4\% \\  
        ALIGN & 0.67\% \\
        MS-COCO Captions  & 0.67\% \\
        Conceptual Captions & 0.67\% \\
        LTIP& 0.67\% \\
        OKVQA & 0.67\% \\
        VQAV2 & 0.67\% \\
        \hline
        Total & 14.7\% \\
        \hline
    \end{tabular}
    }
\end{table*}
\vskip 0.4cm
\subsection{Simulated control tasks}
\vskip 0.2cm
Our control tasks consist of datasets generated by specialist SoTA or near-SoTA reinforcement learning agents trained on a variety of different environments.
For each environment we record a subset of the experience the agent generates (states, actions, and rewards) while it is training. 

The simulated environments include
\metaworld{}~\citep{yu2020meta} introduced to benchmark meta-reinforcement learning and multi-task learning, 
\sokoban{}~\citep{racaniere2017imagination} proposed as a planning problem,
\babyai{}~\citep{chevalier2018babyai} for language instruction following in grid-worlds,
the \dmcontrol{}~\citep{tunyasuvunakool2020dmcontrol} for continuous control, as well as
\dmlab{}~\citep{beattie2016deepmind} designed to teach agents navigation and 3D vision from raw pixels with an egocentric viewpoint.
We also use the Arcade Learning Environment~\citep{bellemare2013arcade} with classic Atari games (we use two sets of games that we call \atari{} and \ataritwo{}, see Section~\ref{sec:atari_details} for details).
We as well include the \procgen{}~\citep{cobbe2020leveraging} and  \mrl{}~\citep{huang2020one}.
We also include four tasks using a simulated Kinova Jaco arm from \mpg{}, as introduced in~\cite{zolna2020offline}.
Section~\ref{sec:data-collection} includes a more in-depth description of these control tasks, along with what RL agent was used to generate the data.

We found it effective to train on a filtered set of episodes with returns at least 80\% of the expert return for the task.
The expert return measures the maximum sustained performance that the expert agent can achieve.
We define it as the maximum over the set of all windowed average returns calculated over all the collected episodes for a task:

where  it the total number of collected episodes for the task,  is the window size, and  is the total return for episode .
To obtain accurate estimates, in practice, we set  to be  of the total data amount or a minimum of 1000 episodes (i.e. ).
\vskip 0.4cm
\subsection{Vision and language}
\label{sec:vision-and-language}
\vskip 0.2cm
\model{} is trained on MassiveText~\citep{rae2021scaling}, a collection of large English-language text datasets from multiple sources: web pages, books, news articles, and code.


We also included several vision-language datasets in \model{}'s training.
ALIGN~\citep{jia2021scaling} consists of 1.8B images and their alternative text (alt-text) annotations. 
LTIP (Long Text \& Image Pairs), consists of 312 million images with captions~\citep{Alayrac2022FlamingoAV}.
Conceptual captions~\citep{sharma-etal-2018-conceptual} and COCO captions~\citep{chen2015microsoft} are captioning datasets with 3.3M and 120k image-text pairs respectively.
The MultiModal MassiveWeb (M3W) dataset~\citep{Alayrac2022FlamingoAV} includes 43M webpages where both text and images were extracted. 
We also included visual question-answering datasets. In particular OKVQA~\citep{marino2019ok} and VQAv2~\citep{antol2015vqa}
with 9K and 443K triplets of images, questions, and answers.
To form a training episode from these, we sample five (image, text) pairs, tokenize them, concatenate, and then pad or randomly crop to the required training sequence length.
\vskip 0.4cm
\subsection{Robotics - RGB Stacking Benchmark (real and sim)}
\vskip 0.2cm
As a testbed for taking physical actions in the real world, we chose the robotic block stacking environment introduced by~\citet{lee2021beyond}. The environment consists of a Sawyer robot arm with 3-DoF cartesian velocity control, an additional DoF for velocity, and a discrete gripper action. The robot's workspace contains three plastic blocks colored red, green and blue with varying shapes.
The available observations include two 128  128 camera images, robot arm and gripper joint angles as well as the robot's end-effector pose. Notably, ground truth state information for the three objects in the basket is not observed by the agent. Episodes have a fixed length of 400 timesteps at 20 Hz for a total of 20 seconds, and at the end of an episode block positions are randomly re-positioned within the workspace. The robot in action is shown in Figure~\ref{fig:stack_strike_cage}. There are two challenges in this benchmark: \emph{Skill Mastery} (where the agent is provided data from the 5 test object triplets it is later tested on) and \emph{Skill Generalization} (where data can only be obtained from a set of training objects that excludes the 5 test sets).

We used several sources of training data for these tasks. In Skill Generalization, for both simulation and real, we use data collected by the best generalist sim2real agent from \citet{lee2021beyond}. We collected data only when interacting with the designated RGB-stacking \emph{training objects} (this amounts to a total of 387k successful trajectories in simulation and 15k trajectories in real). For Skill Mastery we used data from the best per group experts from \citet{lee2021beyond} in simulation and from the best sim2real policy on the real robot (amounting to 219k trajectories in total). Note that this data is only included for specific Skill Mastery experiments in Section~\ref{sec:skill_mastery}.

\begin{figure}
    \includegraphics[width=\textwidth]{figures/skill_generalization_challenge}
    \caption{{\bf RGB Stacking environment with the Sawyer robot arm.} Blocks vary along several shape axes, with 5 held out test triplets. The goal is to stack red on blue, ignoring green. \label{fig:stack_strike_cage}}
\end{figure}

\section{Capabilities of the generalist agent}
\label{sec:results}


In this section, we summarize the performance of \model{} when trained on the above described data. That is, all results across all tasks are derived from a single pretrained model with a single set of weights. Results with fine-tuning will be presented in Section~\ref{sec:additional_results}.
\vskip 0.4cm
\subsection{Simulated control tasks}\label{sec:simulated_control_task}
\vskip 0.2cm
Figure \ref{fig:indist_barplot} shows the number of distinct control tasks for which \model{} performs above a given score threshold, relative to expert performance demonstrated in \model{}'s training data.


We report performance as a percentage, where  corresponds to the per-task expert and  to a random policy.
For each simulated control task we trained our model on, we roll out the \model{} policy on the corresponding environment 50 times and average the defined scores.
As shown in Figure~\ref{fig:indist_barplot}, \model{} performs over 450 out of 604 tasks at over a  expert score threshold.


\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{figures/barplot_domains}
    \caption{
    {\bf \model{}'s performance on simulated control tasks.} Number of tasks where the performance of the pretrained model is above a percentage of expert score, grouped by domain. Here values on the x-axis represent a specific percentage of expert score, where 0 corresponds to random agent performance. The y-axis is the number of tasks where the pretrained model's mean performance is equal to or above that percentage. That is, the width of each colour band indicates the number of tasks where \model{}'s mean performance is above a percentage of the maximum score obtained by a task-specific expert.
    \label{fig:indist_barplot}}
\end{figure}

In \atari{}~\citep{bellemare2013arcade} \model{} achieves the average human (or better) scores for 23 Atari games\footnote{The full list of games: Assault, Atlantis, Bank heist, Battle zone, Bowling, Crazy climber, Defender, Fishing derby, Gopher, Hero, Ice hockey, Jamesbond, Kangaroo, Kung fu master, Name this game, Pong, Road runner, Robotank, Tennis, Time pilot, Up n down, Wizard of wor, Zaxxon.}, achieving over twice human score for 11 games.
While the single-task online RL agents which generated the data still outperform \model{}, this may be overcome by adding capacity or using offline RL training rather than purely supervised (see Section~\ref{sec:specialist_agents} where we present a specialist single domain \atari{} agent achieving better than human scores for 44 games).


On BabyAI~\citep{chevalier2018babyai} \model{} achieves over 80\% of expert score for nearly all levels\footnote{The only three tasks below 80\% success rate are GoToImpUnlock (59\%), Unlock (74\%), and BossLevel (75\%).}.
For the most difficult task, called BossLevel, \model{} scores 75\%.
The two other published baselines we could find, BabyAI 1.0 and BabyAI 1.1~\citep{hui2020babyai}, scored 77\% and 90\%, respectively, having trained on this single task alone using a million demonstrations.


On Meta-World~\citep{yu2020meta} \model{} achieves more than 50\% for all 44 out of 45 tasks that we trained on, over 80\% for 35 tasks, and over 90\% for 3 tasks.
On canonical DM Control Suite~\citep{tassa2018deepmind}, \model{} achieves better than 50\% of the expert score on 21 out of 30 tasks from state, and more than 80\% for 18 tasks.
\begin{figure*}[hbtp]
    \centering
    \includegraphics[width=\linewidth]{figures/image_captions_v3.pdf}
    \caption{{\bf Image captions generated by \model{}.} \model{} prompted to be an image captioner, describing the first several held-out images from MS-COCO. We report the first three captions sampled using temperature 0.9, without cherry-picking. The prompt is shown in the appendix.
    \label{fig:vlm_caption_samples}}
\bigskip
\includegraphics[width=\linewidth]{figures/dialogue_examples_g1.pdf}
    \caption{\textbf{Chitchat with \model{}.} Dialogues with \model{} when it is prompted to be a chat bot. Usually \model{} replies with a relevant response, but is often superficial or factually incorrect, which could likely be improved with further scaling. We used the same prompt as in~\citet{rae2021scaling}.
    \label{fig:chatbot_samples}}
\end{figure*}
\vskip 0.4cm
\subsection{Robotics}
\label{robotics_zeroshot}
\vskip 0.2cm
First person teleoperation enables the collection of expert demonstrations. However, such demonstrations are slow and costly to collect. 
Data-efficient behavior cloning methods are therefore desirable for training a generalist robot manipulator and offline pretraining is thus a well-motivated area of research.
To that end, we evaluated \model{} on the established RGB Stacking benchmark for robotics.
\vskip 0.4cm
\subsubsection*{Skill Generalization Performance}
\vskip 0.2cm
The Skill Generalization challenge from the RGB Stacking robotics benchmark tests the agent's ability to stack objects of previously unseen shapes. The agent is trained on a dataset consisting of episodes of the robot stacking objects with a variety of different shapes. Five triplets of object shapes are, however, not included in the training data and serve as test triplets.
We evaluated the trained generalist for 200 episodes per test triplet on the real robot. Table~\ref{table:skill_generalization} shows that our generalist agent's success rate on each test triplet is comparable to the single task BC-IMP (filtered BC) baseline in \cite{lee2021beyond}.

\begin{table*}
    \caption{{\bf \model{} real robot Skill Generalization results.} In addition to performing hundreds of other tasks, \model{} also stacks competitively with the comparable published baseline. \label{table:skill_generalization}}
    \centering
    \sc
    \scalebox{0.9}{
    \begin{tabular}{l|r|r|r|r|r|r}
          \toprule
          Agent & Group 1 & Group 2 & Group 3 & Group 4 & Group 5 & Average \\ 
          \midrule
          \model{}                     & \textbf{24.5}\% & 33\%            & \textbf{50.5}\% & 76.5\%          & \textbf{66.5}\% & \textbf{50.2}\% \\
          BC-IMP~\citep{lee2021beyond} & 23\%            & \textbf{39.3}\% & 39.3\%          & \textbf{77.5}\% & 66\% & 49\% \\
          \bottomrule
    \end{tabular}}
\end{table*}

\vskip 0.4cm
\subsection{Text samples}
\vskip 0.2cm
The model demonstrates rudimentary dialogue and image captioning capabilities. Figure \ref{fig:vlm_caption_samples} contains a representative sample of \model{}'s image captioning performance. Figure \ref{fig:chatbot_samples} shows some hand-picked examples of plain text dialogue exchange.


\section{Analysis}
\label{sec:additional_results}
\subsection{Scaling Laws Analysis}\label{sec:scaling_law_analysis}
\vskip 0.2cm
\begin{figure*}[bp]
    \centering
    \includegraphics[width=0.4\linewidth]{figures/paper_scaling_law}
    \caption{
    {\bf Model size scaling laws results.} In-distribution performance as a function of tokens processed for 3 model scales. 
    Performance is first mean-aggregated within each separate control domain, and then mean-aggregated across all domains.
    We can see a consistent improvement as model capacity is increased for a fixed number of tokens.
    }
    \label{fig:scaling_law}
\end{figure*}

In Figure~\ref{fig:scaling_law}, we analyze the aggregate in-distribution performance of the pretrained model as a function of the number of parameters in order to get insight into how performance could improve with increased model capacity.
We evaluated 3 different model sizes (measured in  parameter count):
a \texttt{79M model}, 
a \texttt{364M model},
and a \texttt{1.18B model} (\model{}). 
We refer to Section~\ref{app:model_arch} for details on the three model architectures.

Here, for all three model sizes we plot the normalized return as training progresses.
To get this single value, for each task we calculate the performance of the model as a percentage of expert score (the same as done in Section~\ref{sec:simulated_control_task}).
Then for each domain listed in Table~\ref{table:datasets} we average the percentage scores across all tasks for that domain.
Finally, we mean-aggregate the percentage scores across all domains.
We can see that for an equivalent token count, there is a significant performance improvement with increased scale.
\vskip 0.4cm
\subsection{Out of distribution tasks}\label{sec:ood_results}
\vskip 0.2cm
In this section we want to answer the following question: \emph{Can our agent be used to solve a completely new task efficiently?}
For this reason, we held-out all data for four tasks from our pre-training set: \texttt{cartpole.swingup} (\dmcontrol{} domain), \texttt{assembly-v2} (\metaworld{} domain), \texttt{order\_of\_apples\_forage\_simple} (\dmlab{} domain), and \texttt{boxing} (\atari{} domain).
These four tasks will serve as testbeds for evaluating the out-of-distribution capabilities of \model{}.


Ideally, the agent could potentially learn to adapt to a new task via conditioning on a prompt including demonstrations of desired behaviour. 
However, due to accelerator memory constraints and the extremely long sequence lengths of tokenized demonstrations, the  maximum context length possible does not allow the agent to attend over an informative-enough context. 
Therefore, to adapt the agent to new tasks or behaviours, we choose to fine-tune the agent's parameters on a limited number of demonstrations of a single task, and then evaluate the fine-tuned model's performance in the environment.
Fine-tuning is very similar to pretraining with minor changes, such as different learning rate schedule; see Section~\ref{sec:finetuning_setup} for details.


We want to measure how choice of data used during pretraining influences post-fine-tuning performance.
To this end, we compare \model{} (trained on \textit{all data}) to variants trained on ablated datasets:
\begin{enumerate}
\item A model pretrained only on data from the same domain as the task to be fine-tuned on, \textit{same domain only data}.
\item A model pretrained only on non-control data, \textit{no control data}.
\item A model fine-tuned from scratch, i.e.\ no pretraining at all, \textit{scratch}.
\end{enumerate}

Considering as all these experiments require training a new model from scratch and then also fine-tuning, we present results using the less compute-intensive \texttt{364M} parameter architecture described in Section~\ref{sec:scaling_law_analysis}.
Results are shown in Figure~\ref{fig:ood_ablations}.
\begin{figure*}[t]
    \includegraphics[width=\linewidth]{figures/ood_ablations}    
    \caption{
    {\bf Few-shot performance, ablating over various pretraining settings.} Orange corresponds to the base \model{} pretrained on all data. Red is trained from scratch only on the few-shot data. \texttt{364M} parameter variants of \model{} were used for this experiment to save compute.
    \label{fig:ood_ablations}}
\end{figure*}


Fine-tuning performance on both \texttt{cartpole.swingup} and \texttt{assembly-v2} tasks, both of which do not require image processing, present similar trends.
Pretraining on all the datasets yields the best results, followed by pretraining on the same domain only. This difference is smaller for \texttt{assembly-v2} but consistent for all few shot datasets.
For these non-image-based environments, we see either no benefit (\texttt{cartpole.swingup}) or even negative transfer (\texttt{assembly-v2}) when pretraining on \textit{no control} datasets, which only contain images and text data.


Results for \dmlab{} \texttt{order\_of\_apples\_forage\_simple} are slightly different.
Pretraining on \dmlab{} data only is already enough to approach the maximum reward of 19 and hence there is no observable benefit of adding data from different environments.
What is different when compared to previously analysed no-vision environments is that pretraining on \textit{no control} data helps,
which can be possibly explained by the fact that agents in the \dmlab{} environment are fed images which, despite being simulated, are natural looking.
Therefore, transfer from image captioning or visual grounded question answering tasks is possible.


We were not able to observe any benefit from pretraining on \texttt{boxing}.
The randomly initialized model seems to work better than any of the pretrained variants considered.
We hypothesise that this is caused by the game's input images being visually very distinct from the other data, suggesting transfer is difficult.
We discuss this Atari challenge further in our related work section.
\vskip 0.4cm
\subsection{Fine-tuning on Robotic Stacking Tasks}
\label{sec:skill_gen}
\vskip 0.2cm
Section~\ref{robotics_zeroshot} demonstrates that the base \model{} capable of a diverse array of tasks can perform competitively on the RGB Stacking Skill Generalization benchmark.
In this section, we would like to answer the following question:
\emph{How does our agent improve on robotics tasks when allowed to fine-tune similarly to how we fine-tune on new tasks in Section~\ref{sec:ood_results}?}
We consider different model sizes and analyse the impact of pretraining datasets on the Skill Generalization benchmark, as well as a novel out of distribution task. Further analysis of fine-tuning with dataset ablations is in Appendix \ref{sec:sim_ablations_appendix}.
\subsubsection*{Skill Generalization}
\begin{figure*}[t]
    \vskip -0.5cm
    \centering
    \begin{tabular}{p{0.4\linewidth} p{0.4\linewidth}}
    \vspace{0pt} \includegraphics[width=1\linewidth]{figures/skill_gen_real_fewshot} &
    \vspace{0pt} \includegraphics[width=1\linewidth]{figures/skill_gen_sim_ablations}
    \end{tabular}
    \caption{
    {\bf Robotics fine-tuning results.}
    Left: Comparison of real robot Skill Generalization success rate averaged across test triplets for \model{},
    expert, and CRR trained on 35k expert episodes (upper bound).
    Right: Comparison of simulated robot Skill Generalization success rate averaged across test triplets for a series of ablations on the number of parameters, including scores for expert and a BC baseline trained on 5k episodes.
    }
    \label{fig:skill_generalization}
\end{figure*}
First, we would like to show that fine-tuning on object-specific data, similarly to what was done by \citet{lee2022spend}, is beneficial.
Therefore, we fine-tuned \model{} separately on five subsets of demonstrations from the \textit{test} dataset.
Each subset was obtained by random partitioning of a test dataset consisting of demonstrations gathered by a generalist sim-to-real agent stacking real test objects.
We consider this setting, which is comparable to the fine-tuning baselines on RGB stacking tasks from~\citep{lee2022spend}; and use the 5k dataset that their behavior cloning 5k results are obtained with.
To best match their experiments, we change our return filtering scheme during training: instead of using only successful stacks, we condition on the normalized return of the episode.


Figure \ref{fig:skill_generalization} compares the success rate of \model{} across different fine-tuning data regimes to the sim-to-real expert and a Critic-Regularized Regression (CRR)~\citep{wang2020critic} agent trained on 35k episodes of all test triplets.
\model{}, in both reality and simulation (red curves on the left and right figure, respectively), recovers the expert's performance with only 10 episodes, and peaks at 100 or 1000 episodes of fine-tuning data, where it exceeds the expert.
After this point (at 5000), performance degrades slightly but does not drop far below the expert's performance.


\subsubsection*{Fine-tuning and Model Size}

To better understand the benefit of large models for few-shot adaptation in robotics domains, we conducted an ablation on model parameter size.
This section focuses on in-simulation evaluation.
Figure \ref{fig:skill_generalization} compares the full \texttt{1.18B} parameter \model{} with the smaller \texttt{364M} and \texttt{79M} parameter variants for varying amounts of fine-tuning data.
Although the \texttt{364M} model overfits on one episode, causing performance to drop, there is a clear trend towards better adaptation with fewer episodes as the number of parameters is scaled up.
The \texttt{79M} model performs clearly worse than its bigger counterparts.
The results suggest that the model's greater capacity allows the model to use representations learned from the diverse training data at test time.


\subsubsection*{Adaptation to Perceptual Variations}

While the Skill Generalization task is an effective benchmark for motor Skill Generalization to shape variations, it does not test the agent's ability to adapt to perceptual variations and permutations in the objective specification.
To further evaluate \model{}'s generalization capabilities, we devised a new task in the RGB stacking benchmark where the goal is to stack the blue object on the green object, for test triplet 1 (see Figure~\ref{fig:real_robot_blue_on_green}).
First, we used a 3D mouse to collect 500 demonstrations of this task on the real robot, for a total of 2 hours and 45 minutes of demonstration data, and fine-tuned \model{} on these episodes.
Notably, all of the simulated and real robotics data in the pretraining set shows the robot successfully stacking the red object on the blue object, and the data does not include the object shapes in the test set.
We found that additionally adding simulated demonstrations of the stack blue on green task to the fine-tuning dataset improved performance, and 10\% was an ideal sampling ratio for this data.
\begin{figure*}
    \centering
    \includegraphics[width=0.98\linewidth]{figures/real_robot_blue_on_green}    
    \caption{
    {\bf Comparing training/test task goal variations.}
    Top: the standard ``stack red on blue'' task tested in the Skill Generalization benchmark. Bottom: the novel ``stack blue on green'' task demonstrating \model{}'s out of distribution adaptation to perceptual variations.
    \label{fig:real_robot_blue_on_green}}
\end{figure*}

We achieved a final 60\% success rate after evaluating fine-tuned \model{} on the real robot, while a BC baseline trained from scratch on the blue-on-green data achieved only 0.5\% success (1/200 episodes).
Qualitatively, the BC baseline would consistently move towards the blue object and occasionally pick it up and place it on top of the green object, but a full, stable stack was almost never achieved.
\vskip 0.4cm
\subsection{Robotics: Skill Mastery}
\label{sec:skill_mastery}
\vskip 0.2cm
Similarly to the Skill Generalization challenge discussed in Section~\ref{robotics_zeroshot}, the Skill Mastery challenge consists in training a robotic arm to stack blocks of different shapes.
However, the Skill Mastery allows the agent to train on data involving the object shapes used for evaluation, i.e. the \emph{test} set in Skill Generalization becomes a part of the Skill Mastery \emph{training} set.
Thus, this challenge serves to measure \model{}'s performance on in-distribution tasks (possibly with initial conditions not seen in the training demonstrations). 
Our Skill Mastery results use an earlier version of the \model{} architecture described in Appendix \ref{sec:skill_mastery_architecture}, with no fine-tuning.

\begin{table*}[t]
    \caption{{\bf Real robot Skill Mastery results.} \model{} is competitive with the filtered BC baseline. \label{table:skill_mastery}}
    \centering
    \sc
    \scalebox{0.9}{
    \begin{tabular}{l|r|r|r|r|r|r}
    \toprule
    Agent                        & Group 1         & Group 2         & Group 3         & Group 4        & Group 5         & Average \\
    \midrule
    \model{}                     & 58\%            & 57.6\%          & \textbf{78.5}\% & \textbf{89} \% & \textbf{95.1}\% & \textbf{75.6}\% \\
    BC-IMP~\citep{lee2021beyond} & \textbf{75.6}\% & \textbf{60.8}\% & 70.8\%          & 87.8\%         & 78.3\%          & 74.6\% \\
    \bottomrule
    \end{tabular}
    }
\end{table*}

Table~\ref{table:skill_mastery} compares the group-wise success percentage and the average success across object groups for \model{} and the established BC-IMP baseline.
\model{} exceeds or closely matches BC-IMP's performance on all but one training triplet.
\vskip 0.4cm
\subsection{Specialist single-domain multi-task agents}
\label{sec:specialist_agents}
\vskip 0.2cm
In this section we show results obtained with two specialist (rather than generalist) agents.
Both of them were trained on data from a single domain only and rolled out 500 times for each training task without any per-task fine-tuning.


\subsubsection*{\metaworld}

The first agent uses the smallest architecture introduced in Section~\ref{sec:scaling_law_analysis}, i.e. \texttt{79M} parameters, and is trained on all 50 \metaworld{} tasks.
While \model{} has access to the state of the MuJoCo physics engine and unlimited task seeds, the agent presented here has no access to any extra features or tasks and uses the canonical API as in~\citep{yu2020meta}.
This experiment is to show that the architecture proposed in our paper can be used to obtain state-of-the-art agents also at small scale.
The training procedure was to train single-task MPO \citep{abdolmaleki2018maximum} experts on each of the MT-50 tasks individually, recording the trajectories produced while training.
This experience is then combined, or distilled, into a single agent, which achieves 96.6\% success rate averaged over all 50 tasks.
To the best of our knowledge this agent is the first one to accomplish nearly 100\% average success rate simultaneously (multi-task) for this benchmark.
See Table~\ref{tab:metaworld} in the supplementary material (Section~\ref{sec:mt50_results}) for the full list of tasks and corresponding success rates of our agent.


\subsubsection*{\atari{}}

We also trained a specialist agent on all 51 \atari{} tasks.
As the Atari domain is much more challenging than \metaworld{}, we used the \model{} architecture with \texttt{1.18B} parameters.


The resulting agent performs better than the average human for 44 games (see Section~\ref{sec:simulated_control_task} for details on our evaluation and scoring).
We want to note that the performance of online experts used to generate training data for the other 7 games were also below the average human.
Hence, the specialist Atari agent achieved better than human performance for all games where data contained super-human episodes.


The specialist Atari agent outperforms our generalist agent \model{}, which achieved super-human performance on 23 games.
It suggests that scaling \model{} may result in even better performance.
We, however, purposely restricted \model{}'s size such that it can be run in real-time on the real robot.
\vskip 0.4cm
\subsection{Attention Analysis}
\label{sec:attention}
\vskip 0.2cm
We rendered the transformer attention weights over the image observations for various tasks, to gain a qualitative sense of how Gato attends to different regions of the image across tasks (see Figure~\ref{fig:attention}).
Further details and visualizations for more tasks can be found in Appendix~\ref{attention_appendix}.
These visualizations clearly show that attention tracks the task-relevant objects and regions.

\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{figures/gato_attention_vis.pdf} 
    \caption{
    {\bf Attention maps.} Time-lapse attention maps from selected heads at the first layer for Atari Breakout and RGB Stacking.
    \small}
    \label{fig:attention}
\end{figure}
\vskip 0.4cm
\subsection{Embedding Visualization}
\label{sec:tsne}
\vskip 0.2cm
To understand how Gato encodes differently information per task, we visualized per-task embeddings.


We analysed 11 tasks.
For each task, we randomly sample 100 episodes and tokenize each of them.
Then, from each episode we take a subsequence of 128 tokens, compute their embeddings (at layer 12, which is half the total depth of the transformer layers) and average them over the sequence.
The averaged embeddings for all tasks are used as input to PCA, which reduces their dimensionality to 50.
Then, T-SNE is used to get the final 2D embeddings.


Figure \ref{fig:tsne} shows the final T-SNE embeddings plotted in 2D, colorized by task.
Embeddings from the same tasks are clearly clustered together, and task clusters from the same domain and modality are also located close to each other. Even held-out task (\texttt{cartpole.swingup}) is clustered correctly and lays next to another task from \dmcontrolpixels{}.


\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{figures/gato_tsne.png} 
    \caption{
    {\bf Embedding visualization.} T-SNE visualization of embeddings from different tasks. A large part of the vision-language embeddings (M3W) overlaps with the language cluster (MassiveText). Other tasks involving actions fall in their own cluster.
    \small}
    \label{fig:tsne}
\end{figure}

\section{Related Work}
\label{sec:related}


The most closely related architectures to that of \model{} are Decision Transformers~\citep{chen2021decision,reid2022can,zheng2022online,furuta2021generalized} and Trajectory Transformer~\citep{janner2021offline}, which showed the usefulness of highly generic LM-like architectures for a variety of control problems.
~\model{} also uses an LM-like architecture for control, but with design differences chosen to support multi-modality, multi-embodiment, large scale and general purpose deployment.
Pix2Seq~\citep{chen2021pix2seq} also uses an LM-based architecture for object detection.
Perceiver IO~\citep{jaegle2021perceiver} uses a transformer-derived architecture specialized for very long sequences, to model any modality as a sequence of bytes.
This and similar architectures could be used to expand the range of modalities supported by future generalist models.


\model{} was inspired by works such as GPT-3~\citep{brown2020language} and Gopher~\citep{rae2021scaling}, pushing the limits of generalist language models; and more recently the  Flamingo~\citep{Alayrac2022FlamingoAV} generalist visual language model.
\citet{chowdhery2022palm} developed the 540B parameter Pathways Language Model (PalM) explicitly as a generalist few-shot learner for hundreds of text tasks.
Future work should consider how to unify these text capabilities into one fully generalist agent that can also act in real time in the real world, in diverse environments and embodiments.



\model{} also takes inspiration from recent works on multi-embodiment continuous control.
\citet{huang2020one} used message passing graph networks to build a single locomotor controller for many simulated 2D walker variants.
\citet{kurin2020my} showed that transformers can outperform graph based approaches for incompatible (i.e.\ varying embodiment) control, despite not encoding any morphological inductive biases.
\citet{devin2017learning} learn a modular policy for multi-task and multi-robot transfer in simulated 2D manipulation environments.
\citet{chen2018hardware} train a universal policy conditioned on a vector representation of robot hardware, showing successful transfer both to simulated held out robot arms, and to a real world sawyer robot arm.

A variety of earlier generalist models have been developed that, like \model{}, operate across highly distinct domains and modalities.
NPI~\citep{reed2016neural} trained a single LSTM~\citep{hochreiter1997long} to execute diverse programs such as sorting an array and adding two numbers, such that the network is able to generalize to larger problem instances than those seen during training.
\citet{kaiser2017one} developed the MultiModel that trains jointly on 8 distinct speech, image and text processing tasks including classification, image captioning and translation.
Modality-specific encoders were used to process text, images, audio and categorical data, while the rest of the network parameters are shared across tasks.
\citet{schmidhuber2018one} proposed ``\emph{one big net for everything}'', describing a method for the incremental training of an increasingly general problem solver.
\citet{keskar2019ctrl} proposed controllable multi-task language models that can be directed according to language domain, subdomain, entities, relationships
between entities, dates, and task-specific behavior.

In this discussion, it is important to distinguish between one single multi-task network architecture versus one single neural network with the same weights for all tasks.
Several poplar RL agents achieve good multi-task RL results within single domains such as Atari57 and DMLab~\citep{espeholt2018impala,song2019v,hessel2019multi}.
However, it is much more common to use the same policy architecture and hyper-parameters across tasks, but the policy parameters are different in each task \citep{mnih2015human,tassa2018deepmind}. 
This is also true of state-of-the-art RL methods applied to board games \citep{schrittwieser2020mastering}. Moreover, this choice has been adopted by off-line RL benchmarks \citep{gulcehre2020rl,fu2020d4rl} and recent works on large sequence neural networks for control, including decision transformers \citep{chen2021decision,reid2022can,zheng2022online} and the Trajectory Transformer of \cite{janner2021offline}. In contrast, in this work we learn a single network with the same weights across a diverse set of tasks. 

Recent position papers advocate for highly generalist models, notably \cite{schmidhuber2018one} proposing one big net for everything, and \cite{bommasani2021opportunities} on foundation models.
However, to our knowledge there has not yet been reported a single generalist trained on hundreds of vision, language and control tasks using modern transformer networks at scale.

``Single-brain''-style models have interesting connections to neuroscience.
\cite{mountcastle1978organizing} famously stated that ``\emph{the processing function of neocortical modules is qualitatively similar in all neocortical regions.
Put shortly, there is nothing intrinsically motor about the motor cortex, nor sensory about the sensory cortex}''.
Mountcastle found that columns of neurons in the cortex behave similarly whether associated with vision, hearing or motor control.
This has motivated arguments that we may only need one algorithm or model to build intelligence \citep{hawkins2004intelligence}.

Sensory substitution provides another argument for a single model \citep{bach2003sensory}. For example, it is possible to build tactile visual aids for blind people as follows. The signal captured by a camera can be sent via an electrode array on the tongue to the brain. The visual cortex learns to process and interpret these tactile signals, endowing the person with some form of ``vision''. Suggesting that, no matter the type of input signal, the same network can process it to useful effect.

Our work is based on deep autoregressive models, which have a long history and can be found in generative models of text, images, video and audio. Combining autoregressive generation with transformers \citep{vaswani2017attention,devlin2018bert} has been of enormous impact in language modelling \citep{brown2020language,rae2021scaling}, protein folding \citep{jumper2021highly}, vision-language models \citep{tsimpoukelli2021multimodal, wang2021simvlm,Alayrac2022FlamingoAV}, code generation \citep{chen2021evaluating,li2022competition}, dialogue systems with retrieval capabilities \citep{nakano2021webgpt,thoppilan2022lamda}, speech recognition~\citep{pratap2020massively}, neural machine translation~\citep{johnson2019massively} and more \citep{bommasani2021opportunities}. Recently researchers have explored task decomposition and grounding with language models \citep{huang2022language,ahn2022can}. 

\cite{li2022pre} construct a control architecture, consisting of a sequence tokenizer, a pretrained language model and a task-specific feed-forward network. They apply it to VirtualHome and BabyAI tasks, and find that the inclusion of the pretrained language model improves generalisation to novel tasks. Similarly, \cite{parisi2022unsurprising} demonstrate that vision models pretrained with self-supervised learning, especially crop segmentations and momentum contrast \citep{he2020momentum}, can be effectively incorporated into control policies.

As mentioned earlier, transfer in Atari is challenging.
\cite{rusu2016progressive} researched transfer between randomly selected Atari games. They found that Atari is a difficult domain for transfer because of pronounced differences in the visuals, controls and strategy among the different games.
Further difficulties that arise when applying behaviour cloning to video games like Atari are discussed by \cite{kanervisto2020benchmarking}.

There has been great recent interest in data-driven robotics~\citep{cabi2019scaling,chen2021learning}. However,
\cite{bommasani2021opportunities} note that in robotics ``\emph{the key stumbling block is collecting the right data. Unlike language and vision data, robotics data is neither plentiful nor representative of a sufficiently diverse array of
embodiments, tasks, and environments}''. Moreover, every time we update the hardware in a robotics lab, we need to collect new data and retrain. We argue that this is precisely why we need a generalist agent that can adapt to new embodiments and learn new tasks with few data.   

Generating actions using an autoregressive model can lead to causal ``self-delusion'' biases when there are confounding variables \citep{ortega2021shaking}. For example, sampling actions can condition the model to solve the wrong task when multiple tasks share similar observation and actions specifications. As explained in Section~\ref{sec:model}, we use prompt engineering in ambiguous tasks, conditioning our model on a successful demonstration. This screens off confounding variables, reducing self-delusions. Another solution which we did not explore in this work is to use counterfactual teaching, where we train a model online using instantaneous expert feedback. We leave this for future investigation.


\section{Broader Impact}
\label{sec:safety}


Although generalist agents are still only an emerging area of research, their potential impact on society calls for a thorough interdisciplinary analysis of their risks and benefits. 
For the sake of transparency, we document the intended use cases of \model{} in the model card in Appendix \ref{app:model_card}.
However, the tools for mitigating harms of generalist agents are relatively underdeveloped, and require further research before these agents are deployed.


Since our generalist agent can act as a vision-language model, it inherits similar concerns as discussed in~\citep{weidinger2021ethical,bommasani2021opportunities,rae2021scaling,Alayrac2022FlamingoAV}.
In addition, generalist agents can take actions in the the physical world; posing new challenges that may require novel mitigation strategies.
For example, physical embodiment could lead to users anthropomorphizing the agent, leading to misplaced trust in the case of a malfunctioning system, or be exploitable by bad actors.
Additionally, while cross-domain knowledge transfer is often a goal in ML research, it could create unexpected and undesired outcomes if certain behaviors (e.g. arcade game fighting) are transferred to the wrong context.
The ethics and safety considerations of knowledge transfer may require substantial new research as generalist systems advance.

Technical AGI safety~\citep{bostrom2017superintelligence} may also become more challenging when considering generalist agents that operate in many embodiments. 
For this reason, preference learning, uncertainty modeling and value alignment~\citep{russell2019human} are especially important for the design of human-compatible generalist agents. 
It may be possible to extend some of the value alignment approaches for language~\citep{ouyang2022training, kenton2021alignment} to generalist agents.
However, even as technical solutions are developed for value alignment, generalist systems could still have negative societal impacts even with the intervention of well-intentioned designers, due to unforeseen circumstances or limited oversight~\citep{amodei2016concrete}. 
This limitation underscores the need for a careful design and a deployment process that incorporates multiple disciplines and viewpoints.

Understanding how the models process information, and any emergent capabilities, requires significant experimentation. 
External retrieval~\citep{borgeaud2021improving,menick2022teaching,nakano2021webgpt,thoppilan2022lamda} has been shown to improve both interpretability and performance, and hence should be considered in future designs of generalist agents.


Although still at the proof-of-concept stage, the recent progress in generalist models suggests that safety researchers, ethicists, and most importantly, the general public, should consider their risks and benefits.
We are not currently deploying \model{} to any users, and so anticipate no immediate societal impact.
However, given their potential impact, generalist models should be developed thoughtfully and deployed in a way that promotes the health and vitality of humanity. 


\section{Limitations and Future work}
\subsection{RL data collection}
\vskip 0.2cm
Gato is a data-driven approach, as it is derived from imitation learning. While natural language or image datasets are relatively easy to obtain from the web, a web-scale dataset for control tasks is not currently available.
This may seem at first to be problematic, especially when scaling Gato to a higher number of parameters.


That being said, there has already been extensive investigation into this issue.
Offline RL aims at leveraging existing control datasets, and its increasing popularity has already resulted in the availability of more diverse and larger datasets.
Richer environments and simulations are being built (e.g. Metaverse), and increasing numbers of users already interact with them among thousands of already deployed online games (e.g. there exists a large dataset of Starcraft 2 games).
Real-life data has also been already stored for ML research purposes; for example, data for training self-driving cars is acquired from recording human driver data.
Finally, while Gato uses data consisting of both observations and corresponding actions, the possibility of using large scale observation-only data to enhance agents has been already studied \citep{baker2022video}.
Thanks to online video sharing and streaming platforms such as Youtube and Twitch, observation-only datasets are not significantly more difficult to collect than natural language datasets, motivating a future research direction to extend Gato to learn from web data.


While the previous paragraph focuses on alleviating drawbacks of data collection from RL agents, it is important to note that this approach presents a different set of tradeoffs compared to scraping web data and can be actually more practical in some situations.
Once the simulation is set up and near SOTA agent trained, it can be used to generate massive amounts of high quality data.
That is in contrast to the quality of web data which is notorious for its low quality.


In short, we believe that acquiring suitable data is another research question on its own, and this is an active area of research with growing momentum and importance.
\vskip 0.4cm
\subsection{Prompt and short context}
\vskip 0.2cm
Gato is prompted with an expert demonstration, which aids the agent to output actions corresponding to the given task.
This is particularly useful since there is otherwise no task identifier available to the agent (that is in contrast to many multi-task RL settings).
Gato infers the relevant task from the observations and actions in the prompt.


However, the context length of our agent is limited to 1024 tokens which translates to the agent sometimes attending to only a few environment timesteps in total.
This is especially the case for environments with image observations, where depending on the resolution each observation can result in more than one hundred tokens each.
Hence for certain environments only a short chunk of a demonstration episode fits in the transformer memory. 


Due to this limited prompt context, preliminary experiments with different prompt structures resulted in very similar performance.
Similarly, early evaluations of the model using prompt-based in-context learning on new environments did not show a significant performance improvement compared to prompt-less evaluation in the same setting.


Context-length is therefore a current limitation of our architecture, mainly due to the quadratic scaling of self-attention.
Many recently proposed architectures enable a longer context at greater efficiency and these innovations could potentially improve our agent performance.
We hope to explore these architectures in future work.



\section{Conclusions}
\label{sec:conclusions}


Transformer sequence models are effective as multi-task multi-embodiment policies, including for real-world text, vision and robotics tasks.
They show promise as well in few-shot out-of-distribution task learning.
In the future, such models could be used as a default starting point via prompting or fine-tuning to learn new behaviors, rather than training  from scratch.


Given scaling law trends, the performance across all tasks including dialogue will increase with scale in parameters, data and compute.
Better hardware and network architectures will allow training bigger models while maintaining real-time robot control capability.
By scaling up and iterating on this same basic approach, we can build a useful general-purpose agent. 

\newpage
\section*{Acknowledgments}
We would like to thank Dan Horgan, Manuel Kroiss, Mantas Pajarskas, and Thibault Sottiaux for their help with data storage infrastructure; Jean-Baptiste~Lespiau and Fan Yang for help on concurrent evaluation; Joel Veness for advising on the model design; Koray Kavukcuoglu for helping inspire the project and facilitating feedback; Tom~Erez for advising on the agent design and task selection for continuous control; Igor~Babuschkin for helping code the initial prototype;  Jack~Rae for advising on the transformer language model codebase; Thomas~Lampe for building robot infrastructure and advising on real robotics experiments; Boxi~Wu for input on ethics and safety considerations; Pedro A. Ortega for advice in regard to causality and self-delusion biases.
\section*{Author Contributions}
\noindent \textbf{Scott Reed} developed the project concept, wrote the initial prototype, and led the project overall. \\
\noindent \textbf{Konrad \.Zo\l{}na} led architecture development for vision and text, built infrastructure for tokenization and prompting, and contributed heavily to overall agent development and evaluation. \\
\noindent \textbf{Emilio Parisotto} led work on optimizing the transformer architecture, ran the largest number of experiments, and analyzed scaling law properties and in-distribution agent performance. \\
\noindent \textbf{Sergio Gómez Colmenarejo} was the technical lead, responsible for creating a scalable data loader and evaluator supporting hundreds of tasks at once, and for the initial robot integration with \model{}. \\
\noindent \textbf{Alexander Novikov} developed the model including the sampler for the initial prototype, carried out experiments focusing on robotics, and created visualizations. \\
\noindent \textbf{Gabriel Barth-Maron} built scalable storage infrastructure to provide \model{} with SoTA-level agent experience in Atari and other domains. \\
\noindent \textbf{Mai Giménez} conducted large scale agent data collection, built substantial data loading infrastructure, and integrated large scale visual-language datasets into the training of \model{}. \\
\noindent \textbf{Yury Sulsky} contributed broadly to the \model{} codebase including a bespoke distributed training sequence loader, and led the development of benchmarks for out-of-distribution generalization, and the training of competitive baseline agents. \\
\noindent \textbf{Jackie Kay} supported physical robotics infrastructure, conducted numerous evaluations and experiments to analyze the generalization properties of \model{}, and contemplated broader ethical impact. \\
\noindent \textbf{Jost Tobias Springenberg} guided \model{}'s deployment to the physical robot, provided strong existing baselines for block stacking, and advised on model development and experimental design. \\
\noindent \textbf{Tom Eccles} developed the \model{} dialogue and image captioning demonstrations, allowing users to easily probe the vision and language capacities of agents in development. \\
\noindent \textbf{Jake Bruce} contributed to agent design as well as control datasets and environments with randomized physics and morphology variations. \\
\noindent \textbf{Ali Razavi} helped in exploring vision architectures. \\
\noindent \textbf{Ashley Edwards} contributed to the first prototype of \model{} that worked on Atari, in addition to exploring alternative network architectures and training objectives. \\
\noindent \textbf{Nicolas Heess} advised on agent design, experiment design and task selection, especially for continuous control applications.  \\
\noindent \textbf{Yutian Chen} advised on model design and experiments, and provided feedback in regular meetings. \\
\noindent \textbf{Raia Hadsell} advised on the design and planning of robotics efforts.\\
\noindent \textbf{Oriol Vinyals} advised on all aspects of the project, especially model architecture, training strategies and benchmark design. \\
\noindent \textbf{Mahyar Bordbar} was the primary project manager; eliciting key goals, tracking progress, facilitating presentations and feedback, and coordinating resource planning. \\
\noindent \textbf{Nando de Freitas} oversaw the project from its inception.

\newpage
\bibliography{main}
\bibliographystyle{tmlr}

\clearpage
\appendix

{\LARGE \bf \noindent Supplementary Material}

\section{Model card}
\label{app:model_card}
We present a model card for \model{} in Table~\ref{tab:model_card}.



\begin{longtable}{p{.30\textwidth}|p{.65\textwidth}}
\caption{\textbf{\model{} Model Card.} We follow the framework proposed in \citep{mitchell2019model}.} \label{tab:model_card}\\ 
\toprule
\multicolumn{2}{c}{\textbf{Model details}}\\
\midrule
Organization                      & DeepMind \\
\midrule
Model Date                        & May 2022 \\
\midrule
Model Type                        & Transformer with ResNet patch embedding for multi-task, multi-modal behavior cloning. \\
\midrule
Model Version                     & Initial release. \\
\midrule
Feedback on the Model             & reedscot@google.com \\

\toprule
\multicolumn{2}{c}{\textbf{Intended Uses}}\\
\midrule
Primary Intended Uses   & Learn to accomplish a wide variety of tasks from expert demonstrations, such as playing video games, controlling simulated embodiments, and real world block stacking. \\
\midrule
Primary Intended Users  & DeepMind Researchers. \\
\midrule
Out-of-Scope Uses       & Not intended for commercial or production use. Military uses are strictly prohibited. \\

\toprule
\multicolumn{2}{c}{\textbf{Factors}}\\
\midrule
 Relevant Factors   & Salient factors that may alter model performance are: agent embodiment in control data,
 training data token amount and diversity, performance of expert in training data and prompts (filtered by success rate),
 and any factors inherited by vision \& language datasets described in Section~\ref{sec:vision-and-language}.
 See Section~\ref{sec:ood_results}, in particular Figure~\ref{fig:ood_ablations}, for a detailed discussion of factors relating to training data diversity. \\
\midrule
Evaluation Factors  & Reported factors are: number of input tokens, proportion of data from different domains, agent performance.
Many relevant factors are left for future work as use cases develop. \\ 

\toprule
\multicolumn{2}{c}{\textbf{Metrics}}\\
\midrule
Model Performance Measures & We chose to report episode return for our control tasks.
We decided not to report validation loss over held-out data because we found that it did not correlate well with episode return
on the held-out tasks.\\
\midrule
Decision thresholds                       & N/A \\
\midrule
Approaches to Uncertainty and Variability & The reported values do not take into consideration model uncertainty as they are evaluations of a single model.
It is prohibitive for us to collect the full suite of results with multiple models, however we have not observed statistically significant
variations between different models evaluated on subsets of our benchmarks. 
We account for environment noise in the control tasks we use for evaluation by averaging returns across multiple episodes.
To reduce variance introduced when selecting datasets of the limited demonstrations used during fine-tuning
we generate 3 independent sets of datasets.
The model is fine-tuned separately on each set of datasets and we take the mean performance across all of them. \\

\toprule
\multicolumn{2}{c}{\textbf{Evaluation Data}}\\
\midrule
Datasets      & \model{} is evaluated on in and out of distribution simulated control tasks,
see Section~\ref{sec:simulated_control_task} and Section~\ref{sec:ood_results} for further details about these tasks.
We also evaluated on the Skill Generalization challenge from the RGB Stacking robotics benchmark,
see Section~\ref{robotics_zeroshot} and Section~\ref{sec:skill_gen} for details. \\
\midrule
Motivation    & We evaluated on the in-distribution simulated control and robotics tasks to understand on how well
\model{} handles multi-modal and multi-task learning.
We evaluated on out of distribution simulated control and robotics tasks to understand how well \model{} can adapt to entirely new tasks. \\
\midrule
Preprocessing & Observations from evaluation tasks are tokenized into a stream of discrete embeddings before being input to \model{}. 
Section~\ref{sec:tokenization} and Section~\ref{sec:embed} go into details of how different modalities are tokenized and combined. \\

\toprule
\multicolumn{2}{c}{\textbf{Training Data}}\\
\midrule
Datasets      & We use a diverse and large number of datasets for training \model{}. These include data from agent experience on both simulated and real world environments, along with a variety of natural language and image datasets.
See Table~\ref{table:datasets} for details on our training datasets. \\
\midrule
Motivation    & To create a multi-modal, multi-task, multi-embodiment generalist policy we collected as much, diverse, data
as possible. Joint training on all the datasets has produced a single network, \model{}, which is capable of playing Atari,
captioning images, chat, stacking blocks with a real robot arm, and more.
See Section~\ref{sec:datasets} for a more detailed discussion of our training datasets. \\
\midrule
Preprocessing & The multi-modal training data is tokenized into a stream of discrete embeddings. 
Section~\ref{sec:tokenization} and Section~\ref{sec:embed} go into details of how different modalities are tokenized and combined. \\

\toprule
\multicolumn{2}{c}{\textbf{Quantitative Analyses}}\\
\midrule
Unitary Results & We present several evaluations of \model{} against different benchmarks.
See Figure~\ref{fig:indist_barplot} for an analysis of \model{}'s performance on in distribution control tasks.
Sections~\ref{sec:ood_results},~\ref{sec:skill_gen}, and~\ref{sec:skill_mastery} analyze performance on out of distribution control tasks.
Finally, see Section~\ref{sec:scaling_law_analysis} for a discussion on how model scale affects in-distribution performance. \\


\toprule
\multicolumn{2}{c}{\textbf{Ethical Considerations}}\\
\midrule
Data            & The vision and language datasets used include racist, sexist, and otherwise harmful context.  \\
\midrule
Risks and Harms & In addition to the potential harms of toxic image and language training data, \model{}'s real world embodiment introduces physical safety harms due to misuse or malfunctioning. \\

\midrule
Mitigations     & No mitigation of bias introduced by vision and language data beyond the filtering of sexually explicit content, as in \cite{Alayrac2022FlamingoAV}. Physical risk is mitigated through safety measures implemented by robotics environment designers. \\

\toprule
\multicolumn{2}{c}{\textbf{Caveats and Recommendation}}\\
\midrule
Future work & The interaction of diverse training data domains and the different affordances faced in evaluation is poorly understood, and potential ethical and safety risks arise as the generalist's capabilities grow. \\

\bottomrule

\end{longtable} \newpage

\section{Agent Data Tokenization Details}
\label{sec:tokenization_appendix}
In this section we provide additional details on our tokenization schemes.
Our agent data is sequenced as follows:
\begin{itemize}
    \item \textbf{Episodes} are presented to the agent in order of time (timesteps).
    \item \textbf{Timesteps} in turn are presented in the following order:
    \begin{itemize}
        \item \textbf{Observations} () are ordered lexicographically by key, each item is sequenced as follows:
        \begin{itemize}
            \item Text tokens () are in the same order as the raw input text.
            \item Image patch tokens  () are in raster order.
            \item Tensors () (such as discrete and continuous observations) are in row-major order.
        \end{itemize}
        \item \textbf{Separator} (); a designated separator token is provided after observations.
        \item \textbf{Actions} ( are tokenized as discrete or continuous values and in row-major order.
    \end{itemize}
\end{itemize}
A full sequence of tokens is thus given as the concatenation of data from T timesteps: 

where  is the total number of tokens. 

Each floating point element of tensors in the observation sequence is mu-law companded as in WaveNet~\citep{oord2016wavenet}:

with parameters  and .
(If the floating-point tensor is in the action set, we do not need to compand the elements in the sequence because actions are only defined in the range  for all our environments.)
All the elements are subsequently clipped so that they fall in the set . Finally, they are discretized using bins of uniform width on the domain . We use 1024 bins and shift the resulting integers so they are not overlapping with the ones used for text tokens. The tokenized result is therefore a sequence of integers within the range of .


See Figure~\ref{fig:proprio_tokenization} and Figure~\ref{fig:image_tokenization} for visualizations of tokenizing and sequencing values (both discrete and continuous) and images.
See Section~\ref{app:model_arch} for details about local position encodings referenced in the figures.

\begin{figure}
    \centering
    \includegraphics[width=0.9\linewidth]{figures/proprio_tokenized.png} \caption{{\bf A visualization of tokenizing and sequencing continuous values, e.g. proprioception.}
    \label{fig:proprio_tokenization}}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=0.9\linewidth]{figures/image_tokenized} \caption{{\bf A visualization of tokenizing and sequencing images and discrete values.}
    \label{fig:image_tokenization}}
\end{figure}

\newpage
\section{Model Architecture}
\label{app:model_arch}
\subsection{Transformer Hyperparameters}\label{app:trans_hparams}
\vskip 0.2cm
\begin{table}[h]
	\caption{\textbf{\model{} transformer hyperparameters.} 
	\label{tab:hparams1}}
	\centering
    \sc
    \scalebox{0.9}{
    \begin{tabular}{l|ccc}
    \toprule
    \textbf{Hyperparameter} & \makecell{\textbf{\model} \\ \texttt{1.18B}} & \texttt{364M} & \texttt{79M}  \\
    \midrule
    Transformer blocks      & 24 & 12 & 8 \\
    Attention heads         & 16 & 12 & 24 \\
    Layer width             & 2048 & 1536 & 768 \\
    Feedforward hidden size & 8192 & 6144 & 3072 \\
    Key/value size          & 128 & 128 & 32 \\
    \midrule
    Shared embedding        & \multicolumn{3}{c}{True} \\
    Layer normalization     & \multicolumn{3}{c}{Pre-norm} \\
    Activation Function     & \multicolumn{3}{c}{GEGLU} \citep{shazeer2020glu} \\ 
    \bottomrule
    \end{tabular}}
\end{table}

The transformer hyperparameters of \model{} are presented in Table~\ref{tab:hparams1}. We also list the hyperparameters of smaller architecture variants used in Section~\ref{sec:additional_results}.


\begin{figure}[t]
    \centering
    \includegraphics[width=0.45\linewidth]{figures/resnet_column} \caption{
    {\bf Architecture of the ResNet block used to convert tokenized image patches into token embeddings.} This block uses the v2 ResNet architecture~\citep{he2016identity},  GroupNorm \citep{wu2018group} (instead of LayerNorm \citep{ba2016layer}) normalization, and GELU \citep{hendrycks2016gaussian} (instead of RELU) activation functions.
    \small}
    \label{fig:resnet_decoder}
\end{figure}

\vskip 0.4cm
\subsection{Embedding Function}
\vskip 0.2cm
The ResNet block uses the v2 architecture~\citep{he2016identity}, contains GroupNorm~\citep{wu2018group} with 32 groups instead of LayerNorm~\citep{ba2016layer}, and GELU~\citep{hendrycks2016gaussian} activation functions instead of RELU. The block is diagrammed in Figure~\ref{fig:resnet_decoder}. 

\vskip 0.4cm
\subsection{Position Encodings}
\vskip 0.2cm
\label{sec:position_encodings}

After tokens are mapped into token embeddings, two position encodings are added to the token embeddings (when applicable) to provide temporal and spatial information to the model. These are described below.
\subsubsection*{Patch Position Encodings}
\begin{figure}[t]
    \centering
    \includegraphics[width=0.8\linewidth]{figures/patch_positions}
    \caption{
    {\bf Patch position encodings.}
    Calculating patch position encodings  (red) within the global image (far left). The relative row and column positions (i.e.\ positions normalized between ) are first discretized using uniform binning and used to index a learnable row and column position encoding. These two encodings are then added to the token embedding corresponding to the patch.
    \small}
    \label{fig:pos_encs}
\end{figure}


These position encodings convey information about a patch's global position within the image from which the patch was extracted. First, the relative row and column intervals of the patch are calculated by normalizing the patch's pixel intervals by the image resolution. The row and column normalized intervals are then quantized into a vocabulary size (we use 128) and are used to index a row and column table of learnable position encodings. The method in which the quantized row and column intervals are converted into indices depends on whether we are training or evaluating the model: during training a random index is uniformly sampled from the quantized interval, while during evaluation we deterministically take the (rounded) mean of the interval. Once row and column position encoding are retrieved from the embedding table, they are added onto the token embedding produced by the resnet embedding function, as described previously.

To more concretely demonstrate this process, we provide an example in Figure~\ref{fig:pos_encs}. We will follow the process with the patch highlighted in red on the left of the subfigure. The image is of resolution  and each patch is , meaning there are  patches total. The highlighted patch starts at pixel row interval  and pixel column interval . Normalized, the row interval is therefore  and the column interval is . We then separately quantize the intervals into 128 uniformly spaced bins, with the resulting quantized row interval being  and the quantized column interval being . During training, we uniformly sample integers between the quantized row intervals, whereas during testing we would use the means, which are index 48 for row position and index 64 for column position. The row and column positions are finally used to index separate row and column position encoding tables to produce learnable embeddings which are added onto the corresponding patch token embedding.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/local_position_encodings} 
    \caption{
    {\bf Local position encodings.}
    An example demonstrating how local position encodings are defined within each time-step's observation and action token subsequences. Note that no position encodings are added to action tokens.
    \small}
    \label{fig:local_pos_encs}
\end{figure}

\subsubsection*{Local Observation Position Encodings}

The local observation position encoding adds positional information about where observation tokens are positioned within the local time-step they were an element of. First, we reiterate that, during tokenization, for each time-step all elements of the observation set are tokenized into sequences and concatenated into an observation sequence. Each token in this observation sequence is given an index which corresponds to the sequence order, i.e.\ the first token is 0 and the last is the length of the observation sequence minus one. After embedding, for any tokens that were a part of an observation set, the corresponding observation token index is used to index an embedding table of learnable position encodings, with one embedding for every possible observation token index (in practice we simply set the table size to a large value like 512). The position encoding is then added onto the observation token embedding to produce the final token embedding. Note that all action tokens are given the same position encoding regardless of their position in the time-step sequence. We illustrate an example of this process in Figure~\ref{fig:local_pos_encs}.


\section{Pretraining Setup} 
\label{sec:pretraining_setup}

\noindent \textbf{Optimizer: }
For all models we use the AdamW \citep{loshchilov2019adamw} optimizer with a linear warm-up and cosine schedule decay. The linear warmup lasts for  steps, starting from a learning rate of \texttt{1e-7} and ending at a different maximum learning rate depending on the model (see Table~\ref{tab:hparams}). 
This learning rate is then cosine decayed by a factor 10x over 1,000,000 steps.
The AdamW optimizer has parameters ,  and ~\texttt{1e-8}. We use a batch size of  and a sequence length of  tokens for all models.

\noindent \textbf{Regularization:}
We train with an AdamW weight decay parameter of 0.1. Additionally, we use stochastic depth \citep{huang2016stochasticdepth} during pretraining, where each of the transformer sub-layers (i.e. each Multi-Head Attention and Dense Feedforward layer) is skipped with a probability of 0.1.


\begin{table}[ht]
	\caption{\textbf{Learning rate schedule hyperparameters for the different model scales.}}
    \centering
    \sc
    \scalebox{0.9}{
    \begin{tabular}{l|ccc}
    \toprule
    \textbf{Hyperparameter} & \makecell{\textbf{\model} \\ \texttt{1.18B}} & \texttt{364M} & \texttt{79M}  \\
    \midrule
    Maximum Learning Rate & 1e-4 & 2e-4 & 1e-4 \\
    Minimum Learning Rate & 1e-5 & 2e-5 & 1e-5 \\
    \bottomrule
    \end{tabular}}
    \label{tab:hparams}
\end{table}

\section{Fine-tuning Setup} 
\label{sec:finetuning_setup}

\noindent \textbf{Optimizer: }
For all models we use the Adam \citep{kingma2014adam} optimizer with a constant learning rate of \texttt{1e-5}.
The Adam optimizer has parameters ,  and ~\texttt{1e-8}. We use a batch size of  and a sequence length of  tokens for all models.
We train for 10,000 gradient steps.

\noindent \textbf{Regularization:}
We use dropout \citep{srivastava14adropout} with a rate of 0.1.

\noindent \textbf{Evaluation:} We evaluate agent every 100 learning steps. Each evaluation reports the average of 10 runs of a given checkpoint.
The moving average of 5 such scores is computed (to gather 50 runs together).
The final fine-tuning performance is defined as the maximum of these smoothed scores.

\noindent \textbf{Datasets:} We generated data for the fine-tuning tasks the same way we did for the other tasks (see Section 3.1 for details). Instead of using all the data for a fine-tuning task, we discarded all but 2000 best episodes (leading to the highest returns). The fine-tuning datasets were created in the following way. We randomly took 1000 episodes (out of 2000 preselected episodes), then a subset of 100 episodes from the selected episodes, then 10, 5, 3, and finally a single episode. We repeated this procedure 3 times to obtain 3 series of cascading subsets for each task. Each subset is used to conduct one fine-tuning experiment, and each is reported on our plots in Section \ref{sec:ood_results} as a separate point.

\noindent \textbf{Task settings:} We have not altered any of the tasks and used their canonical versions. As 3 out of 4 tasks are open sourced, they do not need further explanation. For the fourth task, DMLab \texttt{order\_of\_apples\_forage\_simple}, the goal is to collect apples in the right order, green ones first followed by the gold one.

\section{Data Collection Details}
\label{sec:data-collection}
\subsection{Atari}
\label{sec:atari_details}
\vskip 0.2cm
We collect two separate sets of Atari environments.
The first (that we refer to as \atari{}) consists of 51 canonical games from the Arcade Learning Environment \citep{bellemare2013arcade}.
The second (that we refer to as \ataritwo{}) is a set of alternative
games\footnote{Basic Math, Breakout, Crossbow, Darkchambers, Entombed, ET, Flag Capture, Human Cannonball, Klax, Laser Gates, Ms. Pac-Man, Solaris, Space War.}
with their game mode and difficulty randomly set at the beginning of each episode.

For each environment in these sets we collect data by training a Muesli~\citep{hessel2021muesli} agent for 200M total environment steps. We record approximately 20,000 random episodes generated by the agent during training.
\vskip 0.4cm
\subsection{Sokoban}
\vskip 0.2cm
Sokoban is a planning problem~\citep{racaniere2017imagination}, in which the agent has to push boxes to target
locations. Some of the moves are irreversible and consequently
mistakes can render the puzzle unsolvable. Planning ahead of time is therefore necessary to succeed at this puzzle.
We use a Muesli~\citep{hessel2021muesli} agent to collect training data.
\vskip 0.4cm
\subsection{BabyAI}
\vskip 0.2cm
BabyAI is a gridworld environment whose levels consist of instruction-following tasks that are described by a synthetic language. We generate data for these levels with the built-in BabyAI bot. 
The bot has access to extra information which is used to execute optimal solutions, see Section C in the appendix of~\citep{chevalier2018babyai} for more details about the bot. We collect 100,000 episodes for each level.
\vskip 0.4cm
\subsection{DeepMind Control Suite}
\vskip 0.2cm
The DeepMind Control Suite \citep{tunyasuvunakool2020dmcontrol, tassa2018deepmind} is a set of physics-based simulation environments. For each task in the control suite we collect two disjoint sets of data, one using only state features and another using only pixels.
We use a D4PG~\citep{barth2018distributed} agent to collect data from tasks with state features, and an MPO~\citep{abdolmaleki2018maximum} based agent to collect data using pixels.

We also collect data for randomized versions of the control suite tasks with a D4PG agent. These versions randomize the actuator gear, joint range, stiffness, and damping, and geom size and density.
There are two difficulty settings for the randomized versions. The small setting scales values by a random number sampled from the union of intervals .
The large setting scales values by a random number sampled from the union of intervals .
\vskip 0.4cm  \subsection{DeepMind Lab}
\vskip 0.2cm
DeepMind Lab~\citep{beattie2016deepmind} is a first-person 3D environment designed to teach agents
3D vision from raw pixel inputs with an egocentric viewpoint, navigation, and planning.


We trained an IMPALA~\citep{espeholt2018impala} agent jointly on a set of 18 parent DM Lab levels that generate maps procedurally for each new episode.
Data was collected by executing the agent on these 18 levels, as well as an additional set of 237 levels handcrafted to test a diverse set of skills.


The 18 parent levels are characterized by high diversity of generated maps.
The difference between the levels is rooted in hyper-parameters used in a generation process.
These hyper-parameters control high-level characteristics such as types of structures spawned, difficulty of language instructions, or presence of specific tools.
The parent levels were developed to improve performance of RL agents trained online on them.


In contrast to the parent levels, each of the additional handcrafted 237 levels uses almost the same map, and the main differences between instances of the same level map are aesthetics such as colors of walls or lighting conditions.
The maps are \emph{not} procedurally generated and were designed to test a diverse set of skills such as walking up stairs or using specific tools.
They are similar to levels presented in Figure~3, Figure~7 and Figure~8 in aforementioned paper by~\citet{beattie2016deepmind}.


Additional information on the 18 parent levels (and their relation to the other levels) is presnted in details in the NeurIPS Workshop talk \emph{A Methodology for RL Environment Research} by Daniel Tanis\footnote{Available at \url{https://neurips.cc/virtual/2021/workshop/21865\#wse-detail-22801}.}.


In total, we collected data for 255 levels from the DeepMind Lab (18 parent levels and 237 handcrafted levels), 254 of which were used while training \model. The remaining level was used for out of distribution evaluation.


\vskip 0.4cm
\subsection{Procgen Benchmark}
\vskip 0.2cm
Procgen \citep{cobbe2020leveraging} is a suite of 16 procedurally generated Atari-like environments, which was proposed to benchmark sample efficiency
and generalization in reinforcement learning. Data collection was done while training a R2D2~\citep{kapturowski2018recurrent} agent
on each of the environments. We used the hard difficulty setting for all environments except for maze and heist, which we set to easy.


\vskip 0.4cm
\subsection{Modular RL}
\vskip 0.2cm
Modular RL~\citep{huang2020one} is a collection of MuJoCo~\citep{todorov2012mujoco} based continuous control environments, composed of three sets of variants of the OpenAI Gym~\citep{brockman2016openai} Walker2d-v2, Humanoid-v2, and Hopper-v2.
Each variant is a morphological modification of the original body: the set of morphologies is generated by enumerating all possible subsets of limbs, and
keeping only those sets that a) contain the torso, and b) still form a connected graph.
This results in a set of variants with different input and output sizes, as well as different dynamics than the original morphologies.
We collected data by training a single morphology-specific D4PG agent on each variant for a total of 140M actor steps, this was done for 30 random seeds per variant.
\vskip 0.4cm
\subsection{DeepMind Manipulation Playground}
\vskip 0.2cm
The DeepMind Manipulation Playground~\citep{zolna2021task} is a suite of MuJoCo based simulated robot tasks.
We collect data for 4 of the Jaco tasks (box, stack banana, insertion, and slide) using a
Critic-Regularized Regression (CRR) agent~\citep{wang2020critic} trained from images on human demonstrations.
The collected data includes the MuJoCo physics state, which is we use for training and evaluating \model{}.
\vskip 0.4cm
\subsection{Meta-World}
\vskip 0.2cm
Meta-World~\citep{yu2020meta} is a suite of environments\footnote{We used a version from July 23rd 2021, specifically the following version: \url{https://github.com/rlworkgroup/metaworld/commit/a0009ed9a208ff9864a5c1368c04c273bb20dd06}.} for benchmarking meta-reinforcement learning and multi-task learning.
We collect data from all train and test tasks in the MT50 mode by training a MPO agent~\citep{abdolmaleki2018maximum} with
unlimited environment seeds and with access to state of the MuJoCo physics engine. The collected data also contains the MuJoCo physics engine state.

\section{Real robotics evaluation details}

In the real world, control is asynchronous; physics does not wait for computations to finish. Thus, inference latency is a concern for evaluating a large model for real world tasks. In robotics, a fast control rate is thought to be critical for reacting to dynamic phenomena. The robot setup for RGB stacking has a 20Hz control rate (0.05 second timestep) by design. In order to reach an acceptable margin of latency, we modified inference at evaluation time by shortening the context length to 1. We also implemented a parallel sampling scheme where all the action tokens are zeroed out in the input sequences during training so we can sample all tokens corresponding to a robot action in a single model inference step instead of autoregressively as it's done in other domains. We found that the \texttt{1.18B} parameter model was able to run on the hardware accelerators in our robots (NVidia GeForce RTX 3090s), but still overran the 20Hz control rate by a small amount (\texttildelow 0.01 seconds). 

We use the sparse reward function described in \cite{lee2021beyond} for data filtering. We only select trajectories with \emph{final} task success; that is, a sparse reward of 1 on the final timestep.

\section{Skill Mastery architecture}
\label{sec:skill_mastery_architecture}

The numbers reported for the Skill Mastery benchmark were collected by executing a model zero-shot that used an earlier version of the \model{} architecture. Instead of the ResNet patch embedding, a similar architecture using a local transformer was used to embed image patch tokens. The local position embeddings and patch position embeddings were not used. These changes were implemented and found to improve \model{}'s performance after the pretraining data was changed (as we decided to focus on Skill Generalization instead of Skill Mastery challenge), which is why they are presented as the final architecture of our full model.

\clearpage
\section{Additional robotics ablations}
\label{sec:sim_ablations_appendix}

We conducted a series of ablations in simulation to better understand the effect of diverse pretraining data in the robotics domain (see Figure~\ref{fig:sim_data_ablations}). We included the same baselines as in Section~\ref{sec:ood_results}, selecting the \texttt{364M} parameter size variant, as well as an additional baseline trained with control suite data only.
The DM Control-only agent is superior to the base \model{} at zero-shot transfer and with a lot of fine-tuning data, suggesting that \model{} may not be using the representations learned from the text-based datasets when adapting to robotics tasks. The same domain only agent performs the best overall, matching the CRR baseline at 1 fine-tuning episode and outperforming it with more data, suggesting that \model{} at current scale can trade its generalization capacity for data-efficient and effective few-shot adaptation. 


\begin{figure*}[t]
    \includegraphics[width=\linewidth]{figures/skill_gen_sim_data_ablations}    
    \caption{{\bf Few-shot performance of \model{} for Skill Generalization in simulation.} Each test set object is plotted separately. We ablate over different pretraining datasets.
    \label{fig:sim_data_ablations}}
\end{figure*}

\section{Attention visualization} \label{attention_appendix}

\begin{figure*}[t]
    \centering
    \includegraphics[width=0.99\linewidth]{figures/gato_attention_vis_app.pdf}
    \caption{
    {\bf Attention maps.} Time-lapse attention maps from selected heads at the first layer for Atari Breakout, Boxing, Pong, Freeway, Procgen CoinRun, Bossfight, RGB Stacking, and DM Control Suite Cheetah.
    \small}
    \label{fig:attention_app}
\end{figure*}

To render the transformer attention weights, we retrieved the cross-attention logits, a tensor with dimension  where  is the number of heads and  is the number of tokens in a sequence. The th entry of this matrix can be interpreted as the amount that head  attends to token  from token .
Due to Gato's image tokenization scheme, there are multiple tokens per timestep. Therefore to render the attention for a particular timestep, we took the sub-matrix that corresponds to that timestep. We then applied a softmax over the rows of this matrix to normalize the relevant values. Because we are only interested in attention to the previous tokens, we excluded the diagonal by setting it to negative infinity before softmax.

To measure the importance of each patch, we averaged the attention weights over the corresponding column. Because Gato uses a causal transformer, the attention matrix is lower triangular, so the mean was only considered over the sub-column below the diagonal of the matrix.
This corresponds to the average attention paid to particular patch over a whole timestep.

Using this method, we found the attention maps at the first layer the transformer to be most interpretable, agreeing with the findings of \citet{abnar2020quantifying}. Certain heads clearly track task-specific entities and regions of the image. Figure \ref{fig:attention_app} shows the attention maps for manually selected heads at the first layer for several tasks.


\clearpage
\section{Detailed results for specialist \metaworld{} agent}\label{sec:mt50_results}

The specialist \metaworld{} agent described in Section~\ref{sec:specialist_agents} achieves 96.6\% success rate averaged over all 50 \metaworld{} tasks.
The detailed success rates are presented in Table~\ref{tab:metaworld}.
We evaluated agent 500 times for each task.
\begin{table}[ht]
	\caption{\textbf{Success rates of specialist \metaworld{} agent.} Averaged over 500 evaluations.\label{tab:metaworld}}
	\vspace{-0.2cm}
    \centering
    \sc
    \scalebox{0.9}{
    \begin{tabular}{l|r}
    \toprule
    \textbf{Task name} & \textbf{Success rate} \\
    \midrule
    assembly-v2 & 0.980 \\
    basketball-v2 & 0.964 \\
    bin-picking-v2 & 0.954 \\
    box-close-v2 & 0.958 \\
    button-press-topdown-v2 & 0.996 \\
    button-press-topdown-wall-v2 & 0.998 \\
    button-press-v2 & 0.996 \\
    button-press-wall-v2 & 1.000 \\
    coffee-button-v2 & 1.000 \\
    coffee-pull-v2 & 0.980 \\
    coffee-push-v2 & 0.974 \\
    dial-turn-v2 & 0.916 \\
    disassemble-v2 & 0.924 \\
    door-close-v2 & 0.994 \\
    door-lock-v2 & 0.986 \\
    door-open-v2 & 1.000 \\
    door-unlock-v2 & 0.994 \\
    drawer-close-v2 & 1.000 \\
    drawer-open-v2 & 0.992 \\
    faucet-close-v2 & 0.982 \\
    faucet-open-v2 & 0.996 \\
    hammer-v2 & 0.998 \\
    hand-insert-v2 & 0.960 \\
    handle-press-side-v2 & 0.972 \\
    handle-press-v2 & 0.946 \\
    handle-pull-side-v2 & 0.992 \\
    handle-pull-v2 & 0.992 \\
    lever-pull-v2 & 0.980 \\
    peg-insert-side-v2 & 0.992 \\
    peg-unplug-side-v2 & 0.994 \\
    pick-out-of-hole-v2 & 0.966 \\
    pick-place-v2 & 0.990 \\
    pick-place-wall-v2 & 0.986 \\
    plate-slide-back-side-v2 & 1.000 \\
    plate-slide-back-v2 & 0.994 \\
    plate-slide-side-v2 & 1.000 \\
    plate-slide-v2 & 0.984 \\
    push-back-v2 & 0.984 \\
    push-v2 & 0.944 \\
    push-wall-v2 & 0.784 \\
    reach-v2 & 0.796 \\
    reach-wall-v2 & 0.802 \\
    shelf-place-v2 & 0.958 \\
    soccer-v2 & 0.968 \\
    stick-pull-v2 & 0.882 \\
    stick-push-v2 & 0.966 \\
    sweep-into-v2 & 0.962 \\
    sweep-v2 & 0.948 \\
    window-close-v2 & 1.000 \\
    window-open-v2 & 1.000 \\
    \midrule
    \textbf{Average} & \textbf{0.966} \\
    \bottomrule
    \end{tabular}}
\vspace{-0.7cm}
\end{table}

\newpage
\section{Per-domain results for \model{}}

We describe performance of \model{} for simulated control tasks in Section~\ref{sec:simulated_control_task}.
In Table~\ref{tab:per-task-results}, we present normalized per-domain results.
We evaluated agent 50 times for each task.



\begin{table}[ht]
	\caption{\textbf{Normalized \model{} per-domain scores.} Averaged over 50 evaluations.\label{tab:per-task-results}}
    \centering
    \sc
    \scalebox{0.9}{
    \begin{tabular}[t]{l|r}
    \toprule
    Control environment & Normalized Score (in \%) \\
    \midrule
    \dmlab{} & 91.4 \\
    \atari{} & 30.9 \\
    \ataritwo{} & 57.8 \\
    \sokoban{} & 68.0 \\
    \babyai{} & 93.2 \\
    \dmcontrol{} & 63.6 \\
    \dmcontrolpixels{} & 26.3 \\
    \metaworld{} & 87.0 \\
    \procgen{} & 60.8 \\
    \stacksim{} & 58.0 \\
    \mrl{} & 62.9 \\
    \mpg{} & 83.8 \\
    \bottomrule
    \end{tabular}}
\end{table}

\end{document}
