\documentclass{llncs}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[lined,noend,ruled,linesnumbered,commentsnumbered]{algorithm2e}
\usepackage{microtype}






\usepackage{epsfig}
\usepackage{epstopdf}







\newcommand{\Osymbol}{{\mathcal O}}
\newcommand{\BO}[1]{\Osymbol\left(#1\right)}
\newcommand{\TO}[1]{\tilde{\Osymbol}\left(#1\right)}
\newcommand{\SO}[1]{{o}\left(#1\right)}
\newcommand{\BT}[1]{{\Theta}\left(#1\right)}
\newcommand{\BOM}[1]{\Omega\left(#1\right)}
\newcommand{\sort}[1]{\text{sort}\left({#1}\right)}


\newcommand{\E}[1]{\mathbb{E}\left[#1\right]}
\newcommand{\EC}[2]{\mathbb{E}\left[#1 \vert #2\right]}
\newcommand{\V}[1]{\text{Var}\left(#1\right)}
\newcommand{\VC}[2]{\text{Var}\left(#1 \vert #2\right)}
\newcommand{\CV}[1]{\text{Cov}\left(#1\right)}
\renewcommand{\Pr}[1]{\text{Pr}\left[#1\right]}

\newcommand{\ms}[1]{{#1}}

\newcommand{\SimJoin}{\textsc{OSimJoin}}
\newcommand{\ASimJoin}{\textsc{ASimJoin}}



 \pagestyle{plain}
\begin{document}

\title{I/O-Efficient Similarity Join\thanks{The research leading to these results has received
funding from the European Research Council under the EU 7th Framework Programme, ERC grant agreement no.~614331.}}
\date{}

\author{Rasmus Pagh \and Ninh Pham \and Francesco Silvestri\thanks{In part supported by University of Padova project CPDA121378 and by MIUR of Italy project AMANDA while working at the University of Padova.} \and Morten St{\"o}ckel\thanks{Supported by the Danish National Research Foundation / Sapere Aude program.}}

\institute{IT University of Copenhagen, Denmark}

\maketitle



\begin{abstract}

We present an I/O-efficient algorithm for computing similarity joins based on locality-sensitive hashing (LSH).
In contrast to the filtering methods commonly suggested our method has provable sub-quadratic dependency on the data size.
Further, in contrast to straightforward implementations of known LSH-based algorithms on external memory, our approach is able to take significant advantage of the available internal memory: Whereas the time complexity of classical algorithms includes a factor of , where  is a parameter of the LSH used, the I/O complexity of our algorithm merely includes a factor , where  is the data size and  is the size of internal memory. 
Our algorithm is randomized and outputs the correct result with high probability.
It is a simple, recursive, cache-oblivious procedure, and we believe that it will be useful also in other computational settings such as parallel computation.

\end{abstract}

\keywords{Similarity join; locality sensitive hashing; cache aware; cache oblivious;}



\section{Introduction}

The ability to handle noisy or imprecise data is becoming increasingly important in computing.
In database settings this kind of capability is often achieved using similarity join primitives that replace equality predicates with a condition on similarity.
To make this more precise consider a space  and a distance function .
The {\em similarity join\/} of sets  is the following:
Given a radius , compute the set 

This problem occurs in numerous applications, such as web deduplication~\cite{Bayardo_WWW07,Henzinger_SIGIR06,Xiao_WWW08}, document clustering~\cite{Broder_NETWORK97}, data cleaning~\cite{Arasu_VLDB06,Chaudhuri_ICDE06}. 
As such applications arise in large-scale datasets, the problem of scaling up similarity join for different metric distances is getting more important and more challenging.


Many known similarity join techniques (e.g.,~prefix filtering~\cite{Arasu_VLDB06,Chaudhuri_ICDE06}, positional filtering~\cite{Xiao_WWW08}, inverted index-based filtering~\cite{Bayardo_WWW07}) are based on \emph{filtering} techniques that often, but not always, succeed in reducing computational costs.
If we let  these techniques generally require  comparisons for worst-case data.
Another  approach is \emph{locality-sensitive hashing} (LSH) where candidate output pairs are generated using collisions of carefully chosen hash functions. The LSH is defined as follows.
\begin{definition}\label{def:LSH}
Fix a distance function .
For positive reals , and , a family of functions  is \emph{-sensitive} if for uniformly chosen  and all :
\begin{itemize}
	\item If  then ;
	\item If  then .
\end{itemize}
We say that  is \textit{monotonic} if  is a non-increasing function of the distance function .
We also say that  uses space  if a function  can be stored and evaluated using space~.
\end{definition}

LSH is able to break the  barrier in cases where for some constant  the number of pairs in  is not too large.
In other words, there should not be too many pairs that have distance within a factor  of the threshold, the reason being that such pairs are likely to become candidates, yet considering them does not contribute to the output.
For notational simplicity, we will talk about \emph{far} pairs at distance
greater than  (those that should not be reported), \emph{near} pairs at
distance at most  (those that should be reported), and \emph{-near} pairs
at distance between  and  (those that should not be reported but the
LSH provides no collision guarantees).

\smallskip

\textbf{Our contribution.}
In this paper we study I/O-efficient similarity join methods based on LSH.
That is, we are interested in minimizing the number of I/O operations where a block of  points from  is transferred between an external memory and an internal memory with capacity for  points from .
Our main result is the first \emph{cache-oblivious} algorithm for similarity join that has \textit{provably} sub-quadratic dependency on the data size  and at the same time inverse polynomial dependency on .
In essence, where previous methods have an overhead factor of either  or  we obtain an overhead of , where  is a parameter of the LSH employed, strictly improving both. 
We show:
\begin{theorem}\label{thm:main}
Consider , let , assume  and that there exists a monotonic -sensitive family of functions with respect to distance measure , using space  and with . 
Let .
Then there exists a cache-oblivious randomized algorithm computing  (w.r.t.~) with probability  using

\end{theorem}
We  conjecture that the bound in Theorem~\ref{thm:main} 
is close to the best possible for the class of ``signature based''
algorithms that work by generating a set of LSH values 
(from a black-box and monotonic family) and checking all pairs that collide. 
Our conjecture is based on an informal argument, given in full in Section~\ref{sec:exp}. 
We describe a worst-case input, where it seems significant advances are required to beat 
Theorem~\ref{thm:main} asymptotically. Further, we observe that for  our bound coincides with
the optimal bound of reading the input, and when  our bound coincides with the bounds of the best
known internal memory algorithms.

\smallskip

It is worth noting that whereas most methods in the literature focus on a single (or a few) distance measure, our method works for an arbitrary space and distance measure that allows LSH, e.g.,~Hamming, Manhattan~(), Euclidean~(), Jaccard, and angular metric distances. 
Since our approach makes use of LSH as a black box, the problem of reporting the complete join result with certainty would require major advances in LSH methods (see~\cite{Pacuk_COCOON16,Pagh_SODA16} for recent progress in this direction).

A primary technical hurdle in the paper is that we cannot use any kind of strong concentration bounds on the number of points having a particular value, since hash values of an LSH family may be correlated \emph{by definition}. 
Another hurdle is \emph{duplicate elimination} in the output stemming from pairs having multiple LSH collisions. 
However, in the context of I/O-efficient algorithms it is natural to not require the {\em listing\/} of all near pairs, but rather we simply require that the algorithm {\em enumerates\/} all such near pairs.
More precisely, the algorithm calls for each near pair  a function \texttt{emit}. 
This is a natural assumption in external memory since it reduces the I/O complexity. 
In addition, it is desired in many applications where join results are intermediate results pipelined to a subsequent computation, and are not required to be stored on external memory.
Our upper bound can be easily adapted to list all instances by increasing the I/O complexity of an \textit{unavoidable} additive term of  I/Os.


\smallskip

\textbf{Organization.}
The organization of the paper is as follows. 
In Section~\ref{sec:RelatedWork}, we briefly review related work. 
Section~\ref{sec:OurAlgorithms} describes our algorithms including a warm-up cache-aware approach and the main results, a cache-oblivious solution, its analysis, and a randomized approach to remove duplicates. 
Section~\ref{sec:exp} provides some discussions on our
algorithms with some real datasets.
Section~\ref{sec:concl} concludes the paper.

\section{Related Work}\label{sec:RelatedWork}

In this section, we briefly review LSH, the computational I/O model, and some
state-of-the-art similarity join techniques.


\smallskip

\textbf{Locality-sensitive hashing (LSH).}
LSH was originally introduced by Indyk and Motwani~\cite{Indyk_STOC98} for
similarity search problems in high dimensional data. 
This technique obtains a sublinear (i.e.,~) time complexity by increasing the gap of collision probability between near points and far points using the LSH family as defined in Definition~\ref{def:LSH}. 
The gap of collision probability is polynomial, with an exponent of  dependent on .  

It is worth noting that the standard LSHs for metric distances, including Hamming~\cite{Indyk_STOC98}, ~\cite{Datar_SOCG04}, ~\cite{Andoni_FOCS06,Datar_SOCG04}, Jaccard~\cite{Broder_NETWORK97} and angular distances~\cite{Charikar_STOC02} are \textit{monotonic}. 
These common LSHs are space-efficient, and use space comparable to that required to store a point, except the LSH of~\cite{Andoni_FOCS06} which requires space .
We do not explicitly require the hash values themselves to be particularly small.
However, using universal hashing we can always map to small bit strings while introducing no new collisions with high probability. 
Thus we assume that  hash values fit in one memory block.








\smallskip

\textbf{Computational I/O model.}
We study algorithms for similarity join in the \emph{external memory model}, which has been widely adopted in the literature (see, e.g., the survey by
Vitter~\cite{Vitter08}).
The external memory model consists of an internal memory of  words and an external memory of unbounded size. 
The processor can only access data stored in the internal memory and move data between the two memories in blocks of size .
For simplicity we will here measure block and internal memory size in units of points from , such that they can contain  points and  points, respectively.

The \emph{I/O complexity} of any algorithm is defined as the number of input/output blocks moved between the two memories by the algorithm. 
The \emph{cache-aware} approach makes explicit use of the parameters  and   to achieve its I/O complexity, whereas the \textit{cache-oblivious} one~\cite{frigo1999cache} does not explicitly use any model parameters. 
The latter approach is desirable as it implies optimality on all levels of the memory hierarchy and does not require parameter tuning when executed on different physical machines. 
Note that the cache-oblivious model assumes that the internal memory is \emph{ideal} in the sense that it has an optimal cache-replacement policy. Such cache-replacement policy can evict the block that is used furthest in the future, and can place a block anywhere in the cache (full associativity). 



\smallskip

\textbf{Similarity join techniques.}
We review some state-of-the-art of similarity join techniques most closely related to our work.

\begin{itemize}
	\item \textbf{Index-based similarity join.}
A popular approach is to make use of indexing techniques to build a data structure for one relation, and then perform queries using the points of the other relation.
The indexes typically perform some kind of \emph{filtering} to reduce the number of points that a given query point is compared to (see, e.g.,~\cite{Bayardo_WWW07,Chaudhuri_ICDE06,Gionis_VLDB99}).
Indexing can be space consuming, in particular for LSH, but in the context of similarity join this is not a big concern since we have many queries, and thus can afford to construct each hash table ``on the fly''.
On the other hand, it is clear that index-based similarity join techniques will not be able to take significant advantage of internal memory when .
Indeed, the query complexity stated in~\cite{Gionis_VLDB99} is  I/Os.
Thus the I/O complexity of using indexing for similarity join will be high.
\item \textbf{Sorting-based.}\label{sec:sorting}
The indexing technique of~\cite{Gionis_VLDB99} can be adapted to compute similarity joins more efficiently by using the fact that many points are being looked up in the hash tables.
This means that all lookups can be done in a batched fashion using sorting.
This results in a dependency on  that is  I/Os, where  is a parameter of the LSH family.
\item \textbf{Generic joins.}\label{sec:generic}
When  is close to  the I/O-complexity can be improved by using general join operators optimized for this case.
It is easy to see that when  is an integer, a nested loop join requires  I/Os.
Our cache-oblivious algorithm will make use of the following result on cache-oblivious nested loop joins:

\begin{theorem}(He and Luo~\cite{he2006cache})\label{thm:co-nested-loop}
	Given a similarity join condition, the join of relations  and  can be computed by a cache-oblivious algorithm in
	 
		This number of I/Os suffices to generate the result in memory, but may not suffice to write it to disk.
\end{theorem}

We note that a similarity join can be part of a multi-way join involving more than two relations. For the class of \emph{acyclic joins}, where the variables compared in join conditions can be organized in a tree structure, one can initially apply a \emph{full reducer}~\cite{Yannakakis_VLDB81} that removes tuples that will not be part of the output. This efficiently reduces any acyclic join to a sequence of binary joins. Handling cyclic joins is much harder (see e.g.~\cite{Ngo_SIGMOD13}) and outside the scope of this paper.

\end{itemize}







\section{Our Algorithms}\label{sec:OurAlgorithms}

In this section we describe our I/O efficient algorithms.
We start in Section~\ref{sec:simple} with a warm-up cache-aware algorithm. It  uses an LSH family where the value of the collision probability is set to be a function of the internal memory size.
Section~\ref{sec:cacheobl} presents our main result, a recursive and cache-oblivious algorithm, which uses the LSH with a black-box approach and does not make any assumption on the value of collision probability. 
Section~\ref{sec:analysisIO} describes the analysis and Section~\ref{sec:remove-duplicates} shows how to reduce the expected number of times of emitting near pairs. 

\subsection{Cache-aware algorithm: \ASimJoin\ }\label{sec:simple}

We will now describe a simple cache-aware algorithm called \ASimJoin, which achieves the {worst case} I/O bounds as stated in Theorem~\ref{thm:main}. 
\ASimJoin\ relies on an -sensitive family  of hash functions with the following properties:  and , for a suitable value . 
Given an arbitrary monotonic -sensitive family , the family  can be built by concatenating  hash functions from . 
For simplicity, we assume that  is an integer and thus the probabilities  and  can be exactly obtained. 
Nevertheless, the algorithm and its analysis can be extended to the general case by increasing the I/O complexity by a factor at most  in the worst case; in practical scenarios, this factor is a small constant~\cite{Broder_NETWORK97,Datar_SOCG04,Gionis_VLDB99}.

\SetCommentSty{}
\begin{algorithm}[!t]
\label{alg:ASimJoin}
\SetAlgoRefName{\ASimJoin}
\SetKwSty{text}
\caption{ are the input sets.}\label{algo:awaresimjoin}
\small

\SetKwBlock{K}{\textbf{Repeat}  times}{}
\K{\label{step:logNrepeat}
	Associate to each point in  and  a counter initially set to \;
	
	\SetKwBlock{R}{\textbf{Repeat}  times}{}
	\R{\label{step:Arepeat}
	
		Choose  uniformly at random\label{step:A1}\;
		Use  to partition (in-place)  and  in buckets ,  of points with the hash value~\label{step:A2}\;

		\SetKwBlock{RR}{\textbf{For} each hash value  generated in the previous step \label{step:A3}}{}
		\RR{
				\tcc{For simplicity we assume that }Split  and  into chunks  and  of size at most \;
				\SetKwBlock{F}{\textbf{For} every chunk  of }{}
				\F{
					Load in memory \;
					\SetKwBlock{FF}{\textbf{For} every chunk  of  do}{}
					\FF{
						Load in memory \;
						Compute  and emit all near pairs. For each far pair, increment the associated counters by 1\;
						Remove from  and
 all points with the associated counter larger than , and write
 back to 	   	
						external
memory\label{step:remove}\;
						}		
					Write  back to external memory\;
					}				
				}
			}
	}
\end{algorithm}

\ASimJoin\ assumes that each point in  and  is associated with a counter initially set to 0. 
This counter can be thought as an additional dimension of the point which hash functions and comparisons do not take into account.
The algorithm repeats  times the following procedure.
A hash function is randomly drawn from the -sensitive family, and it is used for partitioning the sets  and  into buckets of points with the same hash value.
We let  and  denote the buckets respectively containing points of  and  with the same hash value .
Then, the algorithm iterates through every hash value and, for each hash value , it uses a double nested loop for generating all pairs of points in .
The double nested loop loads consecutive chunks of  and  of size at most : the outer loop runs on the smaller set (say ), while the inner one runs on the larger one (say ).
For each pair , the algorithm emits the pair if ,  increases by~1 counters associated with  and  if ,
or ignores the pair if  .
Every time the counter of a point exceeds , the point is considered to be
far away from all points and will be removed from the bucket. 
Chunks will be moved back in memory when they are no more needed. 
The entire \ASimJoin\ algorithm is repeated  times to find all
near pairs with high
probability. 
The following theorem shows the I/O bounds of the cache-aware approach.



\begin{theorem}\label{thm:aware}
Consider  and let  be sufficiently large. 
Assume there exists a monotonic -sensitive family of functions with respect to distance measure  with  and , for a suitable value .
With probability , the \ASimJoin\ algorithm enumerates all near pairs 
using

\end{theorem}


\begin{proof}

We observe that the I/O cost of Steps~\ref{step:A1}-\ref{step:A2}, that is of partitioning sets  and  according to a hash function , is  for  repetitions\footnote{We let  be shorthand for the I/O complexity \cite{Vitter08} of sorting  points.}. 

We now consider the I/O cost of an iteration of the loop in Step~\ref{step:A3} for a given hash value . 
When the size of one bucket (say ) is smaller than , we are able to load the whole  into the internal memory and then load consecutive blocks of  to execute join operations. 
Hence, the I/O cost of this step is at most .
The total I/O cost of the  iterations of Step~\ref{step:A3} among
all possible hash values where at least one bucket has size smaller than 
is at most   I/Os.

The I/O cost of Step~\ref{step:A3} when both buckets  and  are larger than  is . 
This means that the amortized cost of each pair in  is . 
Therefore the amortized I/O cost of all iterations of Step~\ref{step:A3}, when there are no bucket size less than , can be upper bounded by multiplying the total number of generated pairs by .
Based on this observation, we classify and enumerate generated pairs into three groups: near pairs, -near pairs and far pairs. We denote by ,  and  the respective size of each group, and upper bound these quantities to derive the proof.
\begin{enumerate}

\item \emph{Number of near pairs.} By definition, LSH gives a lower bound on the probability of collision of near pairs. 
It may happen that the collision probability of near pairs is~1. 
Thus, two near points might collide in all  repetitions of
Step~\ref{step:Arepeat} and in all  repetitions of
Step~\ref{step:logNrepeat}. 
This means that . Note that this
bound is a deterministic worst case bound.

\item \emph{Number of -near pairs}. Any -near pair from  appears in a bucket with probability at most  due to monotonicity of our LSH family. 
Since we have  repetitions, each -near pair collides at most~2 in
expectation. 
In other words, the expected number of -near pair collisions among 
repetitions is at most .
By using the Chernoff bound~\cite[Exercise 1.1]{PanconesiDubhashiBook} with
 independent  repetitions (in Step~\ref{step:logNrepeat}), we
have 




\item \emph{Number of far pairs}. If  is far away from all
points, the expected number of collisions of  in  hash table (including
duplicates) is at most , since then the point is removed by
Step~\ref{step:remove}.
Hence the total number of examined far pairs is .


\end{enumerate}
Therefore, by summing the number of near pairs , -near pairs , and far pairs , and multiplying these quantities by the amortized I/O complexity , we upper bound the I/O cost of all iterations of Step~\ref{step:A3}, when there are no buckets of size less than , is

with probability at least .
By summing all the previous bounds, we get the claimed I/O bound with high probability.



We now  analyze the probability to enumerate all near pairs.
Consider one iteration of Step~\ref{step:logNrepeat}. A near pair is not emitted
if at least one of the following events happen:
\begin{enumerate}
 \item The two points do not collide in the same bucket in each of the 
iterations of Step~\ref{step:Arepeat}. This happens with probability
.
 \item One of the two points is removed by Step~\ref{step:remove} because it
collides with more than  far points.
By the Markov's inequality and since there are at most  far points, the
probability that  collides with at least  points in the  iterations
is at most . Then, this event happens with probability at most .
\end{enumerate}
Therefore, a near pair does not collide in one  iteration of
Step~\ref{step:logNrepeat} with probability at most  and never
collides in the  iterations with probability at most .
Then, by an union bound, it follows that all near pairs (there are at most 
of them) collide with probability at least  and the theorem
follows.
\qed
\end{proof}

As already mentioned in the introduction, a near pair  can be emitted many times during the algorithm since points  and  can be hashed on the same value in  rounds of Step~\ref{step:Arepeat}, where  denotes the actual collision probability.
A simple approach for avoiding duplicates is the following: for each near pair found during the -th iteration of Step~\ref{step:Arepeat}, the pair is emitted only if the two points did not collide by all hash functions used in the previous  rounds.
The check starts from the hash function used in the previous round and backtracks until a collision is found or there are no more hash functions. This approach increases the worst case complexity by a factor .
Section~\ref{sec:remove-duplicates} shows a more efficient randomized algorithm that reduces the number of replica per near pair to a constant. 
This technique also applies to the cache-oblivious algorithm described in the next section.





\subsection{Cache-oblivious algorithm: \SimJoin\ }\label{sec:cacheobl}

The above cache-aware algorithm uses an -sensitive family of functions , with   and , for partitioning the initial sets into smaller buckets, which are then efficiently processed in the internal memory using the nested loop algorithm. 
If we know the internal memory size , this LSH family can be constructed by concatenating  hash functions from any given primitive -sensitive family . Without knowing  in the cache-oblivious setting, such family cannot be built. Therefore, we propose \SimJoin, a cache-oblivious algorithm that efficiently computes the similarity join without knowing the internal memory size  and the block length .

\SimJoin\ uses as a black-box a given monotonic -sensitive family .\footnote{The monotonicity requirement can be relaxed to the following:  for every two pairs  and  where  and . A monotonic LSH family clearly satisfies this assumption.}
The value of  and  can be considered constant in a practical scenario.
As common in cache-oblivious settings, we use a recursive approach for splitting the problem into smaller and smaller subproblems that at some point will fit the internal memory, although this point is not known in the algorithm.
We first give a high level description of the cache-oblivious algorithm and an intuitive explanation. 
We then provide a more detailed description and analysis.

\begin{algorithm}[!t]
\SetAlgoRefName{\SimJoin}
\SetKwSty{text}
\caption{ are the input sets, and  is the recursion depth.}\label{algo:simjoin}
\small

\textbf{If} , \textbf{then} swap (the references to) the sets such that \label{step:begin}\;

\textbf{If}  or , \textbf{then} compute  using the
algorithm of Theorem~\ref{thm:co-nested-loop} and return\label{step:basecase}\;

Pick a random sample  of  points from  (or all points if )\label{step:sample}\;

Compute  containing all points of  that have distance smaller than  to at least half points in \label{step:estimate}\;  


Compute  using the algorithm of Theorem~\ref{thm:co-nested-loop}\label{step:nested-loop}\;

\SetKwBlock{R}{\textbf{Repeat}  times\label{step:repeat}}{}
\R{
 Choose  uniformly at random\label{step:repeat1}\;
 Use  to partition (in-place)  and  in buckets ,  of points with hash value~\label{step:repeat2}\;
 \textbf{For} each  where  and  are nonempty, recursively call \newline {\sc \SimJoin\ }\label{step:repeat3}\;
}

\end{algorithm}

\SimJoin\ receives in input the two sets  and  of similarity join, and a parameter  denoting the depth in the recursion tree (initially, ) that is used for recognizing the base case. 
Let  , , and denote with  and  two global values that are kept invariant in the recursive levels and computed using the initial input size . 
For simplicity we assume that  and  are integers, and further assume without loss of generality that the initial size  is a power of two. 
Note that, if  is not an integer, the last iteration in Step~\ref{step:repeat} can be performed with a random variable  such that .

\SimJoin\ works as follows. 
If the problem is currently at the recursive level  or , the recursion ends and  the problem is solved using the cache-oblivious nested loop described in Theorem~\ref{thm:co-nested-loop}. 
Otherwise, the following operations are executed.
By exploiting sampling, the algorithm identifies a subset  of  containing (almost) all points that are near or -near to a constant fraction of points in  (Steps~\ref{step:sample} -- \ref{step:estimate}).
Then we compute  using the cache-oblivious nested-loop of Theorem~\ref{thm:co-nested-loop} and remove points in  from  (Step~\ref{step:nested-loop}).
Subsequently, the algorithm repeats  times the following operations: a hash function is extracted from the -sensitive family and used for partitioning  and  into buckets, denoted with  and  with any hash value  (Steps~\ref{step:repeat1} -- \ref{step:repeat2});
then, the join  is computed recursively by \SimJoin (Step~\ref{step:repeat3}).

The explanation of our approach is the following. 
By recursively partitioning input points with hash functions from , the algorithm decreases the probability of collision between two far points. 
In particular, the collision probability of a far pair is  at the -th recursive level.
On the other hand, by repeating the partitioning  times in each level, the algorithm  guarantees that a near pair is enumerated with constant probability since the probability that a near pair collide is  at the -th recursive level.
It deserves to be noticed that the collision probability of far and near pairs at the recursive level  is  and , respectively, which are asymptotically equivalent to the values in the cache-aware algorithm. 
In other words, the partitioning of points at this level is equivalent to the one in the cache-aware algorithm with collision probability for a far pair .
Finally, we observe that, when a point in  becomes close to many points in , it is more efficient to detect and remove it, instead of propagating it down to the base cases. 
This is due to the fact that the collision probability of very near pairs is always large (close to~1) and the algorithm is not able to split them into subproblems that fit in memory.







\subsection{I/O Complexity and Correctness of \SimJoin\ }\label{sec:analysisIO}

\subsubsection{Analysis of I/O Complexity.}

We will bound the \emph{expected} number of I/Os of the algorithm rather than the worst case. 
This can be converted to an high probability bound by running  parallel instances of our algorithm 
(without loss of generality we assume that the optimal cache replacement 
splits the cache into  parts that are assigned
to each instance).
The total execution stops when the first parallel instance terminates, which with probability at least 
 is within a logarithmic factor of the expected I/O bound (logarithmic factors 
are absorbed in the -notation).

For notational simplicity, in this section we let  and  denote the initial input sets and let  and  denote the subsets given in input to a particular recursive subproblem (note that, due to Step~\ref{step:begin},   can denote a subset of  but also of ; similarly for ). 
We also let  denote the sampling of  in Step~\ref{step:sample}, and with  the subset of  computed in Step~\ref{step:estimate}. 
Lemma~\ref{lemma:sample} says that two properties of the choice of random sample in Step~\ref{step:sample} are almost certain, and the proof relies on Chernoff bounds on the choice of . 
In the remainder of the paper, we assume that Lemma~\ref{lemma:sample} holds and refer to this event as  holding with probability .


\begin{lemma}\label{lemma:sample}
With probability at least  over the random choices in Step~\ref{step:sample},
the following bounds hold for every  subproblem \SimJoin:


\end{lemma}

\begin{proof}



Let  be a point which is -near to at most one sixth of the points in , 
i.e.,~.
The point  enters  if there are at least  -near points in 
 and this happens, for a 
Chernoff bound~\cite[Theorem 1.1]{PanconesiDubhashiBook},  with probability at most .
Each point of   appears in at most  subproblems 
and there are at most  points in .
Therefore, with probability , we have that 
in every subproblem \SimJoin no point with at most  -near 
points in  is in . Hence each point in  has at least   -near 
points in , and the bound in Equation~\ref{eq:manyclose} follows.


We can similarly show that,  with probability , we have that 
in every subproblem \SimJoin all points with at least   -near 
points in  are in . Then, each point in  has 
far points in  and Equation~\ref{eq:manyfar} follows.
\qed

\end{proof}

To analyze the number of I/Os for subproblems of size more than  we bound the cost in terms of different types of \emph{collisions} of pairs in  that end up in the same subproblem of the recursion. 
We say that  \emph{is in} a particular subproblem \SimJoin if . 
Observe that a pair  is in a subproblem if and only if  and  have colliding hash values on every step of the call path from the initial invocation of \SimJoin.

\newcommand{\C}[2][i]{C_{#1}\left({#2} \right)}
\begin{definition}

Given  let  be the number of times a pair in  is in a call to \SimJoin\ at the -th level of recursion. 
We also let , with , denote the number of times a pair in  is in a call to \SimJoin\ at the -th level of recursion where the smallest input set has size in  if , and in  if . 
The count is over all pairs and with multiplicity, so if  is in several subproblems at the -th level, all these are counted.

\end{definition}

Next we bound the I/O complexity of \SimJoin\ in terms of  and , for any . 
We will later upper bound the expected size of these quantities in Lemma~\ref{lemma:expectation} and then get the claim of Theorem~\ref{thm:main}. 

\begin{lemma}\label{lem:collision-bound}

Let  and . Given that  holds,  the I/O complexity of \SimJoin is


\end{lemma}

\begin{proof} 



To ease the analysis we assume that no more than 1/3 of internal memory is used to store blocks containing elements of  and , respectively. 
Since the cache-oblivious model assumes an optimal cache replacement policy this cannot decrease the I/O complexity. 
Also, internal memory space used for other things than data (input and output buffers, the recursion stack of size at most ) is less than  by our assumption that . 
As a consequence, we have that the number of I/Os for solving a subproblem \SimJoin\  where  and  is , including all recursive calls. 
This is because there is space  dedicated to both input sets and only I/Os for reading the input are required. 
By charging the cost of such subproblems to the writing of the inputs in the parent problem, we can focus on subproblems where the largest set (i.e., ) has size more than .
We notice that the cost of Steps~\ref{step:sample}--\ref{step:estimate} is dominated by other costs by our assumption that the set  fits in internal memory, which implies that it suffices to scan data once to implement these steps. 
This cost is clearly negligible with respect to the remaining steps and thus we ignore them.

We first provide an upper bound on the I/O complexity required  by all subproblems at a recursive level above . 
Let \SimJoin\  be a recursive call at the -th recursive level, for . 
The I/O cost of the nested loop join in Step~\ref{step:nested-loop} in \SimJoin\  is  by Theorem~\ref{thm:co-nested-loop}. 
We can ignore the  term since it is asymptotically negligible with respect to the cost of each iteration of Step~\ref{step:repeat}, which is upper bounded later. 
By Equation~\ref{eq:manyclose}, we have that  contains more than
 pairs, and thus the cost of Step~\ref{step:nested-loop} in \SimJoin is . 
This means that we can bound the total I/O cost of all executions of Step~\ref{step:nested-loop} at level  of the recursion with  since each near pair  appears in   subproblems at level .

The second major part of the I/O complexity is the cost of preparing recursive calls in \SimJoin (i.e., Steps~\ref{step:repeat1}--\ref{step:repeat2}). 
In fact, in each iteration of Step~\ref{step:repeat}, the I/O cost is , which includes the cost of hashing and of sorting to form buckets. 
Since each point of  and  is replicated in  subproblems in Step~\ref{step:repeat}, we have that each point of the initial sets  and  is replicated  times at level . 
Since the average cost per entry is , we have that the total cost for preparing  recursive calls at level
 is .
By summing the above terms, we have that the total I/O complexity of all subproblems in the -th recursive level is upper bounded by:



We now focus our analysis to  bound the I/O complexity required by all subproblems at a recursive level below .
Let again \SimJoin be a recursive call at the -th recursive level, for .
We observe that (part of) the cost of a subproblem at level  can be upper bounded by a suitable function of collisions among far points in
\SimJoin\ .
More specifically, consider an iteration of Step~\ref{step:repeat} in a subproblem at level . 
Then, the cost for preparing the recursive calls and for performing Step~\ref{step:nested-loop} in each  subproblem (at level ) generated during the iteration, can be upper bounded as

since each near pair in  is found in Step~\ref{step:nested-loop} in at most one subproblem at level  generated during the iteration. 
Since we have that , we easily get that the above bound can be rewritten as . 
We observe that this bound holds even when : in this case the cost includes all I/Os required for solving the subproblems at level  called in the iteration and which are solved using the nested loop in Theorem~\ref{thm:co-nested-loop} (see Step~\ref{step:basecase}). 
By Lemma~\ref{lemma:sample}, we have that the above quantity can be upper bounded with the number of far collisions between  and , getting . 

Recall that  denotes the number of times a pair in  is in a call to \SimJoin\ at the -th level of recursion where the smallest input set has size in  if , and in  if . 
Then, the total cost for preparing the recursive calls in Steps~\ref{step:repeat1}--\ref{step:repeat2} in all subproblems at level  and for performing Step~\ref{step:nested-loop} in all subproblems at level  is:\footnote{We note that the true input size of a subproblem is 
and not . However, the expected value of  is computed assuming the worst case where there are no close pairs an thus .}

The  factor in the above bound follows since far collisions at level  are used for amortizing the cost of Step~\ref{step:nested-loop} for each one of the  iterations of Step~\ref{step:repeat}.

To get the total I/O complexity of the algorithm we sum the I/O complexity required by each recursive level. 
We bound the cost of each level as follows:
for a level  we use the bound in Equation~\ref{eq:belowL}; 
for a level  we use the bound in Equation~\ref{eq:aboveL}; 
for level , we use the bound given in Equation~\ref{eq:aboveL} to which we add the first term in Equation~\ref{eq:belowL} since  the cost of
Step~\ref{step:nested-loop} at level  is not included in Equation~\ref{eq:aboveL} (note that the addition of Equations~\ref{eq:belowL}
and~\ref{eq:aboveL} gives a weak upper bound for level ).
The lemma follows.\qed
\end{proof}


We will now analyze the expected sizes of the terms in Lemma~\ref{lem:collision-bound}. 
Clearly each pair from  is in the top level call, so the number of collisions is . 
But in lower levels we show that the expected number of times that a pair collides either decreases or increases geometrically, depending on whether the collision probability is smaller or larger than  (or equivalently, depending on whether the distance is greater or smaller than the radius ). 
The lemma follows by expressing the number of collisions of the pairs at the -th recursive level as a \emph{Galton-Watson branching process}~\cite{harris2002theory}. 


\begin{lemma}\label{lemma:expectation}
Given that  holds, for each  we have

\begin{enumerate}
	\item \label{eq:numfar};
	\item  \label{eq:numcnear};
	\item \label{eq:numnear};
	\item , for any \label{eq:numfarK}.
\end{enumerate}
\end{lemma}

\begin{proof}

Let  and . 
We are interested in upper bounding the number of collisions of the pair at the -th recursive level. 
We envision the problem as \emph{branching process} (more specifically a Galtonâ€“Watson process, see e.g.~\cite{harris2002theory}) where the expected number of children (i.e., recursive calls that preserve a particular collision) is  for random . 
It is a standard fact from this theory that the expected population size at generation  (i.e., number of times  is in a problem at recursive level ) is ~\cite[Theorem 5.1]{harris2002theory}. 
If , we have that  and each far pair appears at most  times in expectation at level , from which follows Equation~\ref{eq:numfar}. 
Moreover, since the probability of collisions is monotonic in the distance, we have that   if , and  if , from which follow Equations~\ref{eq:numcnear} and~\ref{eq:numnear}.

In order to get the last bound we observe that each entry of  and  is replicated  times at level . 
Thus, we have that  is the total maximum number of far collisions in subproblems at level  where the smallest input set has size in . 
Each one of these collisions survives up to level  with probability , and thus the expected number of these collisions is . \qed

\end{proof}


We are now ready to prove the I/O complexity of \SimJoin\ as claimed in Theorem~\ref{thm:main}.
By the linearity of expectation and Lemma~\ref{lem:collision-bound}, we get that the expected I/O complexity of \SimJoin\ is

where . 
Note that  we have  and
. By plugging in the
bounds on the expected number of collisions given in Lemma~\ref{lemma:expectation}, we get the claimed result.



\subsubsection{Analysis of Correctness.}\label{sec:correctness}
The following lemma shows that \SimJoin\ outputs with probability 
all  near pairs,  as claimed in Theorem~\ref{thm:main}.
\begin{lemma}\label{lem:prob}
Let  and . Executing  independent 
repetitions of \SimJoin(R,S,0) outputs  with probability at least .
\end{lemma}
\begin{proof}
We now argue that a pair  with  is output with probability .
Let  be the number of subproblems at the level  containing .
By applying Galton-Watson branching process, we get that .
If  then in fact there is positive constant probability that  survives indefinitely, i.e., does not go extinct~\cite{harris2002theory}.
Since at every branch of the recursion we eventually compare points that collide under all hash functions on the path from the root call, this implies that  is reported with a positive constant probability.

In the \emph{critical case} where  we need to consider the variance of , which by~\cite[Theorem 5.1]{harris2002theory} is equal to , where  is the variance of the number of children (hash collisions in recursive calls).
If  is integer, the number of children in our branching process follows a binomial distribution with mean~1.
This implies that .
Also in the case where  is not integer, it is easy to see that the variance is bounded by 2. That is, we have , which by Chebychev's inequality means that for some integer :

Since we have  then , and since  is non-increasing with  this implies that .
Furthermore, the recursion depth  implies the probability that a near pair is found is .
Thus, by repeating  times we can make the error probability  for a particular pair and  for the entire output by applying the union bound.
\end{proof}

\subsection{Removing duplicates}\label{sec:remove-duplicates}

Given two near points  and , the definition of LSH requires their collision probability .
If , our \SimJoin\ algorithm can emit  many times. 
As an example suppose that the algorithm ends in one recursive call: then, the pair  is expected to be in the same bucket for  iterations of Step~\ref{step:repeat} and thus it is emitted  times in expectation. 
Moreover, if the pair is not emitted in the first recursive level, the expected number of emitted pairs increases as  since the pair  is contained in  subproblems at the -th recursive level.
A simple solution requires to store all emitted near pairs on the external memory, and then using a cache-oblivious sorting algorithm~\cite{frigo1999cache} for removing repetitions. 
However, this approach requires  I/Os, where  is the expected average replication of each emitted pair, which can dominate the complexity of \SimJoin.
A similar issue appears in the cache-aware algorithm \ASimJoin\ as well: a near pair is emitted at most  times since there is no recursion and the  partitioning of the two input sets is repeated only  times.

If the collision probability  can be explicitly computed in  time and no I/Os for each pair , it is possible to emit each near pair once in expectation without storing near pairs on the external memory. 
We note that the collision probability can be computed for many metrics, including Hamming~\cite{Indyk_STOC98},  and ~\cite{Datar_SOCG04},
Jaccard~\cite{Broder_NETWORK97}, and angular~\cite{Charikar_STOC02} distances. 
For the cache-oblivious algorithm, the approach is the following: for each near pair  that is found at the -th recursive level, with
, the pair is emitted with probability ; otherwise, we ignore it.
For the cache-aware algorithm, the idea is the same but a near pair is emitted with probability  with . 

\begin{theorem}
The above approaches guarantee that each near pair is emitted with constant probability in both \ASimJoin\ and \SimJoin.
\end{theorem}
\begin{proof}
The claim easily follows for the cache-aware algorithm: indeed the two points of a near pair  have the same hash value in  (in expectation) of the  repetitions of Step~\ref{step:Arepeat}. 
Therefore, by emitting the  pair with probability  we get the claim.

We now focus on the cache-oblivious algorithm, where the claim requires a more articulated proof. 
Given a near pair , let  and  be random variables denoting respectively the number of subproblems at level  containing the pair , and the number of subproblems at level  where  is not found by the cache-oblivious nested loop join algorithm in Theorem~\ref{thm:co-nested-loop}.
Let also  be a random variable denoting the actual number of times the pair  is emitted at level . 
We have followings properties: 
\begin{enumerate}
	\item  since a near pair is emitted with probability  only in those subproblems where the pair is found by the join algorithm.
	\item  since a near pair is in the same bucket with probability  (it follows from the previous analysis based on standard branching).
	\item  since each pair exists at the beginning of the algorithm.
	\item  since each pair surviving up to the last recursive level is found by the nested loop join algorithm.
\end{enumerate}

We are interested in upper bounding  by induction that

for any .
For  (i.e., the first call to \SimJoin) and note that , the equality is verified since


We now consider a generic level . 
Since a pair  propagates in a lower recursive level with probability , we have  
Thus,

By exploiting the inductive hypothesis, we get

Since , we have  and the claim follows. \qed
\end{proof}

We observe that the proposed approach is equivalent to use an LSH where  for each near pair.
Finally, we  remark that this approach does not avoid replica of the same near pair when the algorithm is repeated for increasing the collision probability of near pairs. 
Thus, the probability of emitting a pair is at least  as shown in the second part of Section~\ref{sec:correctness} and  repetitions of \SimJoin\ suffices to find all pairs with high probability (however, the expected number of replica of a given near pair becomes , even with the proposed approach).

\section{Discussion}\label{sec:exp}

We will argue informally that our I/O complexity of Theorem~\ref{thm:main} is
close to the optimal. For simple arguments, we split the I/O complexity of our
algorithms in two parts:



We now argue that  I/Os are necessary. 
First, notice that we need  I/Os per hash function for transferring data between memories, computing and writing hash values to disk to find collisions. 
Second, since each I/O brings at most  points in order to compute the distance with  points residing in the internal memory, we need  I/Os to examine  pairs. 
This means that when the collision probability of far pairs  and the number of collisions of far pairs is at most  in expectation, we only need  I/Os to detect such far pairs. 
Now we consider the case where there are  pairs at distance . 
Due to the monotonicity of LSH family, the collision probability for each such pair must be  to ensure that  I/Os suffices to examine such pairs.
In turn, this means that the collision probability for near pairs within distance  must be at most .
So we need  repetitions (different hash functions) to expect at least one collision for any near pair.

Then, a worst-case data set can be given so that we might need to examine, for each of the  hash functions, a constant fraction the pairs in  whose collision probability is constant.
For example, this can happen if  and  include two clusters of very near points.
One could speculate that some pairs could be marked as ``finished'' during computation such that we do not have to compute their distances again.
However, it seems hard to make this idea work for an arbitrary distance measure where there may be very little structure for the output set, hence the  additional I/Os per repetition is needed. 





In order to argue that the term  is needed, we consider the case where all pairs in  have distance  for a value  small enough to make the collision probability of pair at distance  indistinguishable from the collision probability of pair at distance~.
Then every pair in  must be brought into the internal memory to ensure the correct result, which requires  I/Os. 
This holds for \emph{any} algorithm enumerating or listing the near pairs. 
Therefore, there does not exist an algorithm that beats the quadratic dependency on  for such worst-case input sets, unless the distribution of the input is known beforehand. 
However, when  is subquadratic regarding , a potential approach to achieve subquadratic dependency in expectation for similarity join problem is filtering invalid pairs based on their distances --- currently LSH-based method is the only way to do this.

Note that when  our I/O cost is  as we would expect, since just reading the input is optimal. 
At the other extreme, when  our bound matches the time complexity of internal memory techniques. 
When  are bounded by  then our algorithm achieves subquadratic dependency on . 
Such an assumption is realistic in some real-world datasets as shown in the experimental evaluation section.



\smallskip

\ms{To complement the above discussion we will evaluate our complexity by computing explicit constants and then evaluating the total number of I/Os spent by analyzing real datasets. Performing these ``simulated experiments'' has the advantage over real experiments that we are not impacted by any properties of a physical machine.}
We again split the I/O complexity of our algorithms in two parts:

and carry out experiments to demonstrate that the first term  often dominates the second term  in real datasets. 
In particular, we depict the cumulative distribution function (cdf) in log-log scale of all pairwise distances (i.e., , ) and all pairwise similarities (i.e., Jaccard and cosine) on two commonly used datasets: Enron Email\footnote{https://archive.ics.uci.edu/ml/datasets/Bag+of+Words} and MNIST\footnote{http://yann.lecun.com/exdb/mnist/}, as shown in Figure~\ref{fig:SSJ}.
Since the Enron data set does not have a fixed data size per point, we consider a version of the data set where the dimension has been reduced such that each vector has a fixed size.


\begin{figure*}[t]
\centering
\includegraphics[width=1.0\textwidth]{SSJ1.eps}
\caption{The cumulative distributions of pairwise similarities and pairwise distances on samples of 10,000 points from Enron Email and MNIST datasets. We note that values decrease on the x-axis of Figure 1.a, while they increase in Figure 1.b.}
\label{fig:SSJ}
\end{figure*}

Figure~\ref{fig:SSJ}.a shows an inverse \textit{polynomial} relationship with a small exponent  between similarity threshold  and the number of pairwise similarities greater than .  
The degree of the polynomial is particularly low when . 
This setting  is commonly used in many applications for both Jaccard and cosine similarities~\cite{Arasu_VLDB06,Bayardo_WWW07,Xiao_WWW08}. Similarly, Figure~\ref{fig:SSJ}.b also shows a \textit{monomial} relationship between the distance threshold  and the number of pairwise distances smaller than . 
In turn, this means that the number of -near pairs  is not much greater than . 
In other words, the second term  is often much smaller than the first term .

Finally, for the same data sets and metrics, we simulated the cache-aware algorithm with explicit constants and examined the I/Os cost to compare with a standard nested loop method (Section~\ref{sec:generic}) and a lower bound on the standard LSH method (Section~\ref{sec:sorting}).
We set the cache size , which is reasonable for judging a number of cache misses since the size ratio between CPU caches and RAM is in that order of magnitude.
In general such setting allows us to investigate what happens when the data size is much larger than fast memory.
For simplicity we use  since all methods contain a multiplicative factor  on the I/O complexity. 
The values of  were computed using good LSH families for the specific metric and parameters  and .
These parameters are picked according to Figure~\ref{fig:SSJ} such that the number of -near pairs are only an order of magnitude larger than the number of near pairs.

The I/O complexity used for nested loop join is  (here we assume both sets have size ) and the complexity for the standard LSH approach is \emph{lower bounded} by .
This complexity is a lower bound on the standard sorting based approaches as it lacks the additional cost that depends on how LSH distributes the points.
Since  we can bound the -factor of the sorting complexity and use  since  points read and written twice. 
The I/O complexity of our approach is stated in Theorem~\ref{thm:aware}. 
The computed I/O-values in Figure~2 show that the complexity of our algorithm is lower than that of all instances examined.
Nested loop suffers from quadratic dependency on , while the standard LSH bounds lack the dependency on . 
Overall the I/O cost indicates that our cache-aware algorithm is practical on the examined data sets.

\begin{figure*}[t]
\begin{center}
\resizebox{\columnwidth}{!}{\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline
Data set & Metric &  &  &  &  &  & Standard LSH & Nested loop & ASimJoin\\
\hline
\hline
Enron & Jaccard &  &  &  &  &  &  I/Os &  I/Os &  I/Os\\
\hline
Enron & Cosine &  &  &  &  &  &  I/Os &  I/Os &  I/Os\\
\hline
MNIST & L1 &  &  &  &  &  &  I/Os &  I/Os &  I/Os\\
\hline
\end{tabular}}
\label{fig:ASSJ}
\caption{A comparison of I/O cost for similarity joins on the standard LSH, nested loop and \ASimJoin\ algorithms.}
\end{center}
\end{figure*}




\section{Conclusion}\label{sec:concl}
In this paper we examine the problem of computing the similarity join of two relations in an external memory setting. 
Our new cache-aware algorithm of Section~\ref{sec:simple} and cache-oblivious algorithm of Section~\ref{sec:cacheobl} improve upon current state of the art by around a factor of  I/Os unless the number of -near pairs is huge (more than ).
We believe this is the first cache-oblivious algorithm for similarity join, and more importantly the first subquadratic algorithm whose I/O performance improves significantly when the size of internal memory grows.


It would be interesting to investigate if our cache-oblivious approach is also practical --- this might require adjusting parameters such as .
Our I/O bound is probably not easy to improve significantly, but interesting open problems are to remove the error probability of the algorithm and to improve the implicit dependence on dimension in  and . Note that our work assumes for simplicity that the unit of  and  is number of points, but in general we may get tighter bounds by taking into account the gap between the space required to store a point and the space for hash values.
Also, the result in this paper is made with general spaces in mind and it is an interesting direction to examine if the dependence on dimension could be made explicit and improved in specific spaces.


\bibliographystyle{plain}
\bibliography{simjoin}

\end{document}
