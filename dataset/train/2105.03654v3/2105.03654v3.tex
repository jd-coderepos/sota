

\documentclass[11pt,a4paper]{article}
\usepackage[hyperref]{acl2021}
\usepackage{times}
\usepackage{latexsym}
\renewcommand{\UrlFont}{\ttfamily\small}



\usepackage{amsmath,amsfonts,bm}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}


\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{equation~\ref{#1}}
\def\Eqref#1{Equation~\ref{#1}}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{\textnormal{d}}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{\textnormal{w}}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 \usepackage{microtype}
\usepackage{bbm}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{booktabs}
\usepackage{xparse}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usepackage{natbib}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz-dependency}
\usepackage{wrapfig}
\usepackage{pgfplots}
\pgfplotsset{compat=1.17} 
\usepackage[T1]{fontenc}
\usepackage{subfiles}
\usepackage{readarray}
\usepackage{xcolor}
\usepackage{import}
\usepackage{hhline}
\usepackage{enumitem}
\usepackage{boldline}
\usepackage{mathtools}
\usepackage{colortbl}

\aclfinalcopy \def\aclpaperid{1229} 

\setlength\titlebox{6cm}
\newcommand{\xvec}{\mathbf{x}}
\newcommand{\yvec}{\mathbf{y}}
\newcommand{\cvec}{\mathbf{c}}
\newcommand{\evec}{\mathbf{e}}
\newcommand{\zvec}{\mathbf{z}}
\newcommand{\mVec}{\mathbf{s}}
\newcommand{\tvec}{\mathbf{t}}
\newcommand{\rvec}{\mathbf{r}}
\newcommand{\dvec}{\mathbf{d}}
\newcommand{\mcL}{\mathcal{L}}
\newcommand{\mcR}{\mathcal{R}}
\newcommand{\mcT}{\mathcal{T}}
\newcommand{\mcY}{\mathcal{Y}}
\newcommand{\mcV}{\mathcal{V}}
\newcommand{\mcC}{\mathcal{C}}
\newcommand{\mcA}{\mathcal{A}}
\newcommand{\mcZ}{\mathcal{Z}}
\newcommand{\mcU}{\mathcal{U}}
\newcommand{\context}{\mathbf{y}_{\mathrm{c}}}
\newcommand{\embcontext}{\mathbf{\tilde{y}}_{\mathrm{c}}}
\newcommand{\inpcontext}{\mathbf{\tilde{x}}}
\newcommand{\start}{\mathbf{\tilde{y}}_{\mathrm{c0}}}
\newcommand{\End}{\mathrm{\texttt{</s>}}}
\newcommand{\Score}{\text{Score}}
\newcommand{\Uvec}{\mathbf{U}}
\newcommand{\Evec}{\mathbf{E}}
\newcommand{\Gvec}{\mathbf{G}}
\newcommand{\Fvec}{\mathbf{F}}
\newcommand{\Pvec}{\mathbf{P}}
\newcommand{\mvec}{\mathbf{m}}
\newcommand{\pvec}{\mathbf{p}}
\newcommand{\Vvec}{\mathbf{V}}
\newcommand{\Wvec}{\mathbf{W}}
\newcommand{\hvec}{\mathbf{h}}
\newcommand{\wvec}{\mathbf{w}}
\newcommand{\uvec}{\mathbf{u}}
\newcommand{\vvec}{\mathbf{v}}
\newcommand{\bvec}{\mathbf{b}}
\newcommand{\reals}{\mathbb{R}}



\newcommand\BibTeX{B\textsc{ib}\TeX}

\title{Improving Named Entity Recognition by \\ External Context Retrieving and Cooperative Learning}



\author{Xinyu Wang$^{\diamond\ddagger}$, Yong Jiang$^{\dagger}$\textsuperscript{$\ast$}, Nguyen Bach$^{\dagger}$, Tao Wang$^{\dagger}$,\\
\textbf{Zhongqiang Huang$^{\dagger}$, Fei Huang$^{\dagger}$,  Kewei Tu$^{\diamond}$}\thanks{\hspace{1mm} Yong Jiang and Kewei Tu are the corresponding authors. $^{\ddagger}$: This work was conducted when Xinyu Wang was interning at Alibaba DAMO Academy. } \\
 $^\diamond$School of Information Science and Technology, ShanghaiTech University \\
 Shanghai Engineering Research Center of Intelligent Vision and Imaging \\
 Shanghai Institute of Microsystem and Information Technology, Chinese Academy of Sciences \\
 University of Chinese Academy of Sciences \\
 $^\dagger$DAMO Academy, Alibaba Group \\
  {\tt \{wangxy1,tukw\}@shanghaitech.edu.cn, yongjiang.jy@alibaba-inc.com} \\
  {\tt \{nguyen.bach,leeo.wangt,z.huang,f.huang\}@alibaba-inc.com} \\
}
\date{}

\begin{document}
\maketitle
\begin{abstract}


Recent advances in Named Entity Recognition (NER) show that document-level contexts can significantly improve model performance. In many application scenarios, however, such contexts are not available. In this paper, we propose to find external contexts of a sentence by retrieving and selecting a set of semantically relevant texts through a search engine, with the original sentence as the query. We find empirically that the contextual representations computed on the retrieval-based input view, constructed through the concatenation of a sentence and its external contexts, can achieve significantly improved performance compared to the original input view based only on the sentence. Furthermore, we can improve the model performance of both input views by Cooperative Learning, a training method that encourages the two input views to produce similar contextual representations or output label distributions. Experiments show that our approach can achieve new state-of-the-art performance on 8 NER data sets across 5 domains.\footnote{Our newest code is publicly available at \url{https://github.com/modelscope/AdaSeq/tree/master/examples/RaNER}. The older version: \url{https://github.com/Alibaba-NLP/CLNER}.}

\end{abstract}

\section{Introduction}
Pretrained contextual embeddings such as ELMo \citep{peters-etal-2018-deep}, Flair \citep{akbik-etal-2018-contextual} and BERT \citep{devlin-etal-2019-bert} have significantly improved the accuracy of Named Entity Recognition (NER) models. Recent work \citep{devlin-etal-2019-bert,yu-etal-2020-named,yamada-etal-2020-luke} found that including document-level contexts of the target sentence in the input of contextual embeddings methods can further boost the accuracy of NER models. 
However, there are a lot of application scenarios in which document-level contexts are unavailable in practice. For example, there are sometimes no available contexts in users' search queries, tweets and short comments in various domains such as social media and E-commerce domains. When professional annotators annotate ambiguous named entities in such cases, they usually rely on domain knowledge for disambiguation. This kind of knowledge can often be found through a search engine. Moreover, when the annotators are not sure about a certain entity, they are usually encouraged to find related knowledge through a search engine \citep{wang-etal-2019-crossweigh}. Therefore, we believe that NER models can benefit from such a process as well. 


\begin{figure}[t]
	\centering
	\includegraphics[scale=0.215]{motivating.pdf}
	\caption{A motivating example from WNUT-17 dataset. The retrieved texts help the model to correctly predict the named entities of ``democrats'' and ``republican''.}
	\label{fig:motivate}
\end{figure}

In this paper, we propose to improve NER models by retrieving texts related to the input sentence by an off-the-shelf search engine. We re-rank the retrieved texts according to their semantic relevance to the input sentence and select several top-ranking texts as the external contexts. Consequently, we concatenate the input sentence and external contexts together as a new retrieval-based input view and feed it to the pretrained contextual embedding module, so that the resulting semantic representations of the input tokens can be improved. The token representations are then fed into a CRF layer for named entity prediction. A motivating example is shown in Figure \ref{fig:motivate}.

Moreover, we consider utilizing the new input view to improve model performance with the original input view that does not have external contexts. This can be useful in application scenarios when external contexts are unavailable or undesirable (e.g., in time-critical scenarios). To this end, we propose Cooperative Learning (CL) that encourages the two input views to produce similar predictions. We propose two approaches to CL which minimize either the $L_2$ distances between the token representations of the two input views or the Kullback–Leibler (KL) divergence between the prediction distributions of the two input views during training. 

Our experiments show that including the retrieved external contexts can significantly improve the accuracy of NER models on 8 NER datasets from 5 domains. With CL, the accuracy of the NER models with both input views can be further improved. Our approaches outperform previous state-of-the-art approaches in each domain. 

The contributions of this paper are:
\begin{enumerate}[leftmargin=*]
    \item We propose a simple and straight-forward way to improve the contextual representation of an input sentence through retrieving related texts using a search engine. We take the retrieved texts together with the input sentence as a new retrieval-based view.
    \item 
We propose Cooperative Learning to jointly improve the accuracy of both input views in a unified model. We propose two approaches in CL based on the $L_2$ norm and KL divergence respectively. CL can utilize unlabeled data for further improvement.
\item We show the effectiveness of our approaches in several NER datasets across 5 domains and our approaches achieve state-of-the-art accuracy. By leveraging a large amount of unlabeled data, the performance can be further improved. \end{enumerate}
\begin{figure*}[ht]
	\centering
	\includegraphics[scale=0.45]{framework.pdf}
	\caption{The architecture of our framework. An input sentence $\xvec$ is fed into a search engine to get $k$ related texts. The related texts are then fed into the re-ranking module. The framework selects $l$ highest ranking related texts output from the re-ranking module and feeds the texts to a transformer-based model together with the input sentence. Finally, we calculate the negative likelihood loss $\mcL_{\text{NLL}}$ and $\mcL_{\text{NLL-EXT}}$ together with the CL loss (either $\mcL_{\text{CL-}L_2}$ or $\mcL_{\text{CL-KL}}$).}
	\label{fig:architecture}
\end{figure*}

\section{Framework}
Given a sentence of $n$ tokens $\vx = \{x_1, \cdots, x_n\}$, the input sentence is fed into a search engine as a query. The search engine returns the top $k$ relevant texts $\{\hat{\vx}_1, \cdots, \hat{\vx}_k\}$. Our framework feeds these texts into a re-ranking model. We concatenate $l$ top-ranking texts output from the re-ranking model as the external contexts. The NER model is fed with either an input view with the input sentence (original input view) or a concatenation of the input sentence and external contexts (retrieval-based input view) as input. The model outputs the predictions of labels $\vy = \{y_1, \cdots, y_n\}$ at each position based on the CRF layer. To further improve the model, we use Cooperative Learning to train a unified model that is strong in both input views. With CL, the model is additionally constrained to be consistent in the internal representations or the output distributions of both input views. The architecture of our framework is shown in Figure \ref{fig:architecture}.

\subsection{Re-ranking}
Given an input sentence as a search query, the search engine returns ranked relevant texts. However, the off-the-shelf search engine is highly optimized for a fast speed over a large set of documents, so it may sometimes produce semantically irrelevant results or rank the results using inaccurate relevance scores.
Since the NER task targets at semantically recognizing named entities, it is more helpful if the relevant texts are semantically similar to the input sentence. Therefore, we need to re-rank the retrieved texts so that the most semantically relevant texts are chosen. We propose to apply BERTScore \citep{Zhang*2020BERTScore:} to score the relatedness of each retrieved text to the input sentence. BERTScore is a language generation metric that calculates a sum of cosine similarity between token representations of two sentences. Therefore, it is more likely that the search query and the retrieved texts have strong semantic relations when BERTScore is large. The token representations are generated from pretrained contextual embeddings such as BERT. Given the corresponding pre-normalized token representations $\{\rvec_1, \cdots, \rvec_n\}$ of the input sentence $\vx$ and the pre-normalized token representations $\{\hat{\rvec}_1, \cdots, \hat{\rvec}_m\}$ of a certain retrieved text $\hat{\vx}$ with $m$ words, the Precision (P), Recall (R) of BERTScore measure the semantic similarities from one to another:
\begin{align*} &\text{R} =\frac{1}{n} \sum_{x_i \in \vx}   \max_{\hat{x}_j \in \hat{\vx}} \rvec_i^\top \hat{\rvec}_{j};\;\;
    \text{P} = \frac{1}{m}  \sum_{\hat{x}_j\in \hat{\vx}}   \max_{x_i\in \vx}  \rvec_{i}^\top \hat{\rvec}_{j}
\end{align*}
 We re-rank the retrieved texts by the F1 scores $\text{F1}{=} 2\frac{\text{P} \cdot \text{R} }{\text{P} + \text{R} }$ and concatenate $l$ top-ranking texts $\{\hat{\vx}_1, \cdots, \hat{\vx}_l\}$ with F1 scores together as the external contexts:
\begin{displaymath}
\tilde{\vx} = [sep\_token; \hat{\vx}_1; \cdots; \hat{\vx}_l]
\end{displaymath} 
where $sep\_token$ is a special token representing a separate of sentences in the transformer-based pretrained contextual embeddings (for example, ``[SEP]'' in BERT).


\subsection{NER Model}
We solve the NER task as a sequence labeling problem. We apply a neural model with a CRF layer, which is one of the most popular state-of-the-art approaches to the task \citep{lample-etal-2016-neural,ma-hovy-2016-end,akbik-etal-2019-pooled}. In the sequence labeling model, the input sentence $\vx$ is fed into a transformer-based pretrained contextual embeddings model to get the token representations $\{\vv_1, \cdots, \vv_n\}$ by $\vv_i {=} \text{embed}_i (\vx)$.
The token representations are fed into a CRF layer to get the conditional probability $p_\theta(\vy|\vx)$:
\begin{align}
    \psi(y', y, \vv_i) &= \exp(\Wvec_{y}^{T} \vv_i + \bvec_{y',y}) \label{eq:psi}\\
    p_\theta(\vy|\vx) &= \frac{\prod\limits_{i=1}^{n} \psi(y_{i-1}, y_i, \vv_i)}{\sum\limits_{\vy' \in \mathcal{Y}(\vx)} \prod\limits_{i=1}^{n} \psi(y'_{i-1}, y'_i, \vv_i)}\nonumber
\end{align}
where $\psi$ is the potential function and $\theta$ represents the model parameters. $\mathcal{Y}(\vx)$ denotes the set of all possible label sequences given $\vx$. $y_0$ is defined to be a special start symbol. $\Wvec^{T}\in \sR^{t\times d}$ and $\bvec \in \sR^{t \times t}$ are parameters computing emission and transition scores respectively. $d$ is the hidden size of $\vv$ and $t$ is the size of the label set. During training, the negative log-likelihood loss for the input sequence with gold labels $\vy^*$ is defined by:
\begin{align}
\mcL_{\text{NLL}}(\theta) = - \log p_\theta(\vy^*|\vx) \label{eq:nll_loss}
\end{align}

In our approach, we concatenate the external contexts $\tilde{\vx}$ at the end of the input sentence $\vx$ to form the retrieval-based input view. The token representations are now given by:
\begin{displaymath}
\{\vv_1^{\prime},\cdots,\vv^{\prime}_n,\cdots\} = \text{embed} ([\vx;\tilde{\vx}])
\end{displaymath}
The architecture of our NER model is shown in Figure \ref{fig:ner}. Now the conditional probability $p_\theta(\vy|\vx)$ becomes $p_\theta(\vy|\vx, \tilde{\vx})$. 
The loss function in Eq. \ref{eq:nll_loss} becomes:
\begin{align}
\mcL_{\text{NLL-EXT}}(\theta) = - \log p_\theta(\vy^*|\vx,\tilde{\vx}) \label{eq:nll_loss_x}
\end{align}




\subsection{Cooperative Learning}
In practice, there are two application scenarios for the NER model: 1) offline prediction, which requires high accuracy of the prediction but the prediction speed is less emphasized; 2) online serving, which requires a faster prediction speed. The retrieval-based input view meets the requirement of the first scenario for its strong token representations. However, it does not meet the requirement of the second scenario. The external contexts are usually significantly longer than the input sentence and a search engine may not meet the latency requirements. These two issues significantly slow down the prediction speed of the model. Therefore, it is essential to improve the accuracy of the original input views in a unified model to meet these two scenarios.



\begin{figure}[t]
	\centering
	\includegraphics[scale=0.28]{transformer_structure.pdf}
	\caption{An illustration of our NER model architecture. ``[CLS]'' and ``[SEP]'' are an example of cls token and sep token in the embedding. }
	\label{fig:ner}
\end{figure}


Cooperative Learning targets at using the retrieval-based input view to help improve the accuracy of the model when there are no external contexts available. CL adds constraints between the internal representations or the output distributions between two input views to enforce that the predictions of both views should be near. The objective function of CL is calculated by:
\begin{align}
\mcL_{\text{CL}}(\theta)&=D(h([\vx;\tilde{\vx}]), h([\vx])) \label{eq:cl_loss}
\end{align}
where $D$ is a distance function between a function $h$ with different inputs. Because the representations or the distributions with retrieval-based input view are usually informative, we do not backpropagate the gradient through $h([\vx;\tilde{\vx}])$. We propose two approaches for CL.

\paragraph{Token Representations:} Stronger token representations usually lead to better accuracy on the task. Therefore, CL constrains the token representations of two input views to be similar. This helps the model learn to predict the token representations with external contexts even if the contexts are not available. In this approach, $D$ is the $L_2$ norm to represent the distances of the token representations:
\begin{align}
\mcL_{\text{CL-$L_2$}}(\theta)&=\sum_{i=1}^n||\vv_{i}^{\prime}-\vv_{i}||_2^2 \label{eq:L2_loss}
\end{align}

\paragraph{Label Distributions:} Since CL enforces the label predictions of both input views to be similar, a straight-forward approach is constraining the label distributions predicted by the model to be similar with the two input views. In this approach, we use the KL divergence as the function $D$. Then objective function in Eq. \ref{eq:cl_loss} becomes the KL divergence between $p_\theta(\vy|\vx, \tilde{\vx})$ and $p_\theta(\vy|\vx)$:
\begin{align}
\mcL_{\text{CL-KL}}(\theta)&{=}\sum_{\mathclap{\vy \in \mcY(\vx)}} \text{KL}(p_\theta(\vy|\vx, \tilde{\vx})||p_\theta(\vy|\vx)) \label{eq:cl_kl_loss}
\end{align}
With the CRF layer, the loss function is difficult to calculate because the output space of $p_\theta(\vy|\bullet)$ is exponential in size. To alleviate this issue, we calculate the KL divergence between the marginal distributions $q_\theta(y_i|\vx,\tilde{\vx})$ and $q_\theta(y_i|\vx)$ at each position of the sentence to approximate Eq. \ref{eq:cl_kl_loss}. The marginal distributions can be obtained using the forward-backward algorithm:
\begin{align}
\alpha(y_k)&=\sum\limits_{\{y_0,\dots,y_{k-1}\}} \prod\limits_{i=1}^{k} \psi(y_{i-1}, y_i, \vv_i)\nonumber\\
\beta(y_k) &= \sum\limits_{\{y_{k+1},\dots,y_n\}} \prod\limits_{i=k+1}^{n} \psi(y_{i-1}, y_i, \vv_i)\nonumber\\
q_\theta(y_k|\vx)
&\propto \alpha(y_k) \times \beta(y_k) \label{eq:posterior}  \end{align}
As mentioned earlier, we do not back-propagate the gradient through $p_\theta(\vy|\vx, \tilde{\vx})$. Therefore calculating the KL divergence is equivalent to calculating the cross-entropy loss between $q(\vy|\vx, \tilde{\vx})$ and $q(\vy|\vx)$:
\begin{align}
\mcL_{\text{CL-KL}}{(}\theta{)}{=}{-}{\sum_{\mathclap{i=1}}^{n}}{\sum_{\mathclap{y_i=1}}^{t}} q_\theta(y_i|\vx,\tilde{\vx}){\log} q_\theta(y_i|\vx) \label{eq:cl_posterior_loss}
\end{align}
Together with the negative log-likelihood losses in Eq. \ref{eq:nll_loss}, \ref{eq:nll_loss_x}, the total loss in training is a summation of label losses and a CL loss:
\begin{align}
\mcL(\theta) = \mcL_{\text{NLL}}(\theta) + \mcL_{\text{NLL-EXT}}(\theta) + \mcL_{\text{CL}}(\theta) \label{eq:final_loss}
\end{align}
where $\mcL_{\text{CL}}(\theta)$ can be one of the CL loss in Eq. \ref{eq:L2_loss}, \ref{eq:cl_posterior_loss} or a summation of both of them.

\section{Experiments}


\begin{table*}[t]
\centering
\small
\begin{tabular}{l|ccccccc}
\hlineB{4}
& \textbf{\# Train} & \textbf{\# Dev} & \textbf{\# Test} & \textbf{\# Entity Labels} & \textbf{Avg. Length} & \textbf{Avg. Length w/ Context}\\
\hline
\textbf{\textsc{WNUT-16}} & 2,394 & 1,000 & 3,849 & 10 & 19.41 & 138.58 \\ 
\textbf{\textsc{WNUT-17}} & 3,394 & 1,009 & 1,287 & 6 & 18.48 & 139.49 \\
\textbf{\textsc{CoNLL-03}} & 14,987 & 3,466 & 3,684 & 4 & 13.64 & 116.23\\ 
\textbf{\textsc{CoNLL++}} & 14,987 & 3,466 & 3,466 & 4 & 13.64 & 116.23\\ 
\textbf{\textsc{BC5CDR}} & 4,560 & 4,581 & 4,797 & 2 & 25.91 & 144.13\\ 
\textbf{\textsc{NCBI}} & 5,424 & 923 & 940 & 1 & 25.01 & 135.76 \\ 
\textbf{\textsc{E-Commerce}} & 38,959 & 5,000 & 5,000 & 26 & 2.54 & 124.61\\ 
\hlineB{4}
\end{tabular}
\caption{Statistics of the dateset split, number of entity types and the average lengths with and without external contexts.}
\label{tab:stat}
\end{table*}


\subsection{Settings}
\paragraph{Datasets} To show the effectiveness of our approach, we experiment on 8 NER datasets across 5 domains:
\begin{itemize}[leftmargin=*]
\item {\bf Social Media}: We use WNUT-16 \citep{strauss-etal-2016-results} and WNUT-17 \citep{derczynski-etal-2017-results} datasets collected from social media. We use the standard split for these datasets.
    \item {\bf News}: We use CoNLL-03 English \cite{tjong-kim-sang-de-meulder-2003-introduction} dataset and CoNLL++ \citep{wang-etal-2019-crossweigh} dataset. The CoNLL-03 dataset is the most popular dataset for NER. CoNLL++ is a revision of the CoNLL-03 datasets. \citet{wang-etal-2019-crossweigh} fixed annotation errors on the test set by professional annotators and improved the quality of the training data through their CrossWeigh approach. We use the standard dataset split for these datasets.
    \item {\bf Biomedical}: We use BC5CDR \citep{li2016biocreative} and NCBI-disease \citep{dougan2014ncbi} datasets, which are two popular biomedical NER datasets. We merge the training and development data as training set following \citet{nooralahzadeh-etal-2019-reinforcement}.
    \item {\bf Science and Technology}: We use CBS SciTech News dataset collected by \citet{jia-etal-2019-cross}. The dataset only contains the test set with the same label set as the CoNLL-03 dataset. We use the dataset to evaluate the effectiveness of cross-domain transferability from the news domain.
    \item {\bf E-commerce}: We collect and annotate an internal dataset from one anonymous E-commerce website. The dataset contains 25 named entity labels for goods in short texts. We also collect 300,000 unlabeled sentences for semi-supervised training.
\end{itemize}
We show the statistics of the datasets in Table \ref{tab:stat}.

\paragraph{Annotations of the E-commerce dataset}
We manually labeled the user queries through crowdsourcing from \url{www.aliexpress.com}, which is a real-world E-commerce website. For each query, we asked one annotator to label the entities and ask another annotator to check the quality. After that, we randomly select 10\% of the dataset and ask the third annotator to check the accuracy. As a result, the overall averaged query-level accuracy\footnote{the accuracy of a query counts 1.0 if all the entities in the query are correctly recognized and 0.0 otherwise.} is 95\%. The dataset will not be released due to user privacy.

\paragraph{Retrieving and Ranking} We use an internal E-commerce search engine for the E-commerce dataset. For the other datasets, we use Google Search as the search engine. Google Search is an off-the-shelf search engine and can simulate the offline search over various domains.
We use summarized descriptions from the search results as the retrieved texts\footnote{If the descriptions are not available, we use the titles of the results instead.}. As Google Search limits the maximal length of searching queries to 32 words, we chunk a sentence into multiple sub-sentences based on punctuation if the sentence is longer than 30, feed each sub-sentence to the search engine, and retrieve up to 20 results. We filter the retrieved texts that contain any part of the datasets. Our re-ranking module selects top $6$ relevant texts\footnote{We determined that $6$ is a reasonable number based on preliminary experiments.} as the external contexts of the input sentence and chunk the external contexts if the total sub-token lengths of the input sentence and external contexts exceeds 510.

\paragraph{Model Configurations}
For the re-ranking module, we use Roberta-Large \citep{liu2019roberta} for token representations which is the default configuration in the code\footnote{\url{https://github.com/Tiiiger/bert_score}} of BERTScore \citep{Zhang*2020BERTScore:}. For token representations in the NER model, we use pretrained Bio-BERT \citep{lee2020biobert} for datasets from the biomedical domain and use XLM-RoBERTa \citep{conneau-etal-2020-unsupervised} for datasets from other domains. 

\paragraph{Training} 
During training, we fine-tune the pretrained contextual embeddings by AdamW \citep{loshchilov2018decoupled} optimizer with a batch size of $4$. We use a learning rate of $5\times 10^{-6}$ to update the parameters in the pretrained contextual embeddings. For the CRF layer parameters, we use a learning rate of $0.05$. We train the NER models for $10$ epochs for the datasets in Social Media and Biomedical domains while we train the NER models for $5$ epochs for other datasets for efficiency as these datasets have more training sentences.


\begin{table*}[ht!]
\centering
\setlength\tabcolsep{5pt}
\small
\begin{tabular}{l||cc|cc|cc|c}
\hlineB{4}
& \multicolumn{2}{c|}{\textbf{Social Media}} & \multicolumn{2}{c|}{\textbf{News}} & \multicolumn{2}{c|}{\textbf{Biomedical}} & \multirow{2}{*}{\textbf{E-commerce}}\\
& WNUT-16 & WNUT-17 & CoNLL-03 & CoNLL++ & BC5CDR & NCBI & \\
\hline\hline
\citet{zhou-etal-2019-dual} & 55.43 & 42.83 & - & - & - & - & - \\
\citet{nguyen-etal-2020-bertweet} & 52.10 & 56.50 & - & - & - & - & - \\
\citet{nie-etal-2020-named} & 55.01 & 50.36  & - & - & - & - & -  \\
\hline
\citet{baevski-etal-2019-cloze} & - & - & 93.50 & - & - & - & -  \\
\citet{wang-etal-2019-crossweigh} & - & - & 93.43 & 94.28 & - & - & -  \\
\citet{li-etal-2020-dice} & - & - & 93.33 & - & - & - & -  \\
\hline
\citet{nooralahzadeh-etal-2019-reinforcement} & - & - & - & - & 89.93 & - & - \\
Bio-Flair \shortcite{sharma2019bioflair} & - & - & - & - & 89.42 & 88.85 & - \\
Bio-BERT \shortcite{lee2020biobert} & - & - & - & - & - & 87.70 & - \\
\hline\hline
  \multicolumn{8}{c}{Evaluation: {\sc \textbf{w/o Context}}}\\
\hline
{\bf\textsc{LUKE}} \shortcite{yamada-etal-2020-luke} & 54.04 & 55.22 & 92.42 & 93.99 & 89.18 & 87.62 & 77.64 \\
{\bf\textsc{w/o Context}} & 56.04 & 57.86 & 93.03 & 94.20 & 90.52 & 88.65 & 81.47\\
{\bf\textsc{CL-$L_2$}} & 57.35\rlap{$^{\dagger}$} & 58.68\rlap{$^{\dagger}$} & 93.08  & 94.38\rlap{$^{\dagger}$} & 90.70\rlap{$^{\dagger}$} & 89.20\rlap{$^{\dagger}$} & 82.43\rlap{$^{\dagger}$}\\
{\bf\textsc{CL-KL}} & 58.14\rlap{$^{\dagger}$} & 59.33\rlap{$^{\dagger}$} & 93.21\rlap{$^{\dagger}$}  & 94.55\rlap{$^{\dagger}$} & 90.73\rlap{$^{\dagger}$} & \textbf{89.24}\rlap{$^{\dagger}$} & 82.31\rlap{$^{\dagger}$}\\
\hline
  \multicolumn{8}{c}{Evaluation: {\sc \textbf{w/ Context}}}\\
\hline
{\bf\textsc{w/ Context}} & 57.43\rlap{$^{\dagger}$} & 60.20\rlap{$^{\dagger}$} & 93.27\rlap{$^{\dagger}$} & 94.56\rlap{$^{\dagger}$} & 90.76\rlap{$^{\dagger}$} & 89.01\rlap{$^{\dagger}$} & 83.15\rlap{$^{\dagger}$}\\
{\bf\textsc{CL-$L_2$}} & 58.61\rlap{$^{\dagger}$} & 60.26\rlap{$^{\dagger}$} & 93.47\rlap{$^{\dagger}$} & 94.62\rlap{$^{\dagger}$} & \textbf{90.99}\rlap{$^{\dagger}$} & 89.22\rlap{$^{\dagger}$} & 83.87\rlap{$^{\dagger}$}\\
{\bf\textsc{CL-KL}} & \textbf{58.98}\rlap{$^{\dagger}$} & \textbf{60.45}\rlap{$^{\dagger}$} & \textbf{93.56}\rlap{$^{\dagger}$} & \textbf{94.81}\rlap{$^{\dagger}$} & 90.93\rlap{$^{\dagger}$} & 88.96\rlap{$^{\dagger}$} & \textbf{83.99}\rlap{$^{\dagger}$}\\
\hlineB{4}
\end{tabular}
\caption{A comparison among recent state-of-the-art models, the baseline and our approaches. ${\dagger}$ represents the model is significantly stronger than the baseline model ({\bf\textsc{w/o Context}}) with $p<0.05$ on Student's T test.}
\label{tab:main}
\end{table*}






\subsection{Results}
We experiment on the following approaches:
\begin{itemize}[leftmargin=*]
\item {\sc\textbf{LUKE}} is a very recent state-of-the art model on CoNLL-03 NER dataset proposed by \citet{yamada-etal-2020-luke}. We use the same parameter setting as \citet{yamada-etal-2020-luke} and use a single sentence as the input instead of taking document-level contexts in the dataset as in \citet{yamada-etal-2020-luke} for fair comparison.
    \item {\sc\textbf{w/o Context}} represents training the NER model without external contexts (Eq. \ref{eq:nll_loss}), which is the baseline of our approaches. 
    \item {\sc\textbf{w/ Context}} represents training the NER model with external contexts (Eq. \ref{eq:nll_loss_x}). 
    \item {\sc\textbf{CL-$L_2$}} represents minimizing the $L_2$ distance between token representations (Eq. \ref{eq:L2_loss}).
    \item {\sc\textbf{CL-KL}} represents minimizing the KL divergence (Eq. \ref{eq:cl_posterior_loss}) between CRF output distributions.
\end{itemize}
Besides, we also compare our approaches with previous state-of-the-art approaches over entity-level F1 scores\footnote{We do not compare the results from previous work such as \citet{yu-etal-2020-named,luoma-pyysalo-2020-exploring,yamada-etal-2020-luke} that utilizes the document-level contexts in CoNLL-03 NER here. We conduct a comparison with these approaches in Appendix \ref{app:versus}. }.
During the evaluation, our approaches are evaluated using inputs without external contexts ({\sc\textbf{w/o Context}}) and inputs with them ({\sc\textbf{w/ Context}}). We report the results averaged over 5 runs in our experiments. The results are listed in Table \ref{tab:main}\footnote{For the result of Bio-BERT \citep{lee2020biobert} on NCBI-disease dataset, we report the results reported in official code (\url{https://github.com/dmis-lab/biobert}). The results (89.71 in NCBI-disease) reported in the paper used token-level F1 score instead of entity-level F1 score.}. With the external contexts, our models with CL outperform previous state-of-the-art approaches on most of the datasets. Our approaches significantly outperform the baseline that is trained without external contexts. 
Comparing with LUKE, our approaches and our baseline outperform LUKE in all the cases. The possible reason is that LUKE is pretrained only using long word sequences, which makes the model prone to fail to capture the information of entities based on short sentences\footnote{We have confirmed with the authors of LUKE \citep{yamada-etal-2020-luke} that the accuracy on the CoNLL-03 dataset is consistent with their experimental results.}. For our approaches, with CL, the accuracy can be improved on both input views comparing with {\sc \textbf{w/o Context}} and {\sc \textbf{w/ Context}}, which shows adding constraints between the two views during training helps the model better utilize the original text information. For the two constraints in CL, we find that \textbf{CL-KL} is relatively stronger than \textbf{CL-$L_2$} in a majority of the cases. 




\begin{table}[t!]
\centering
\setlength\tabcolsep{5pt}
\small
\begin{tabular}{l|cc}
\hlineB{4}
 & \multicolumn{2}{c}{Evaluation} \\
 & \multicolumn{2}{c}{\textbf{Science and Technology}} \\
 \hline
Approach & {\sc \textbf{w/o Context}} & {\sc \textbf{w/ Context}} \\
\hline\hline
\citet{jia-etal-2019-cross} & 73.59 & - \\
\hline
{\sc\textbf{w/o Context}} & 75.87 & 75.74  \\
{\sc\textbf{w/ Context }} & 75.72 & 75.94  \\
{\sc\textbf{CL-$L_2$ }} & 76.16 & 76.10  \\
{\sc\textbf{CL-KL }} & \textbf{76.37} & \textbf{76.38}  \\
\hlineB{4}
\end{tabular}
\caption{A comparison of different approaches in transfer learning. The models are trained on the CoNLL-03 dataset.}
\label{tab:transfer}
\end{table}



\subsection{Cross-Domain Transfer}
For cross-domain transfer, we train the models on the CoNLL-03 datasets, evaluate the accuracy on the CBS SciTech News dataset, and compare the results with those in \citet{jia-etal-2019-cross}. We evaluate our approaches with each input view and the results are shown in Table \ref{tab:transfer}. Our approaches can improve the accuracy in cross-domain evaluation. The external contexts during evaluation can help to improve the accuracy of {\sc\textbf{w/ Context}}. However, the gap between the two input views for the CL approaches is diminished. The observation shows that CL is able to improve the accuracy in cross-domain transfer for both views and eliminate the gap between the two views. 



\begin{table}[t!]
\centering
\setlength\tabcolsep{5pt}
\small
\begin{tabular}{l|cc}
\hlineB{4}
 & \multicolumn{2}{c}{Evaluation} \\
 \hline
Approach & {\sc \textbf{w/o Context}} & {\sc \textbf{w/ Context}} \\
\hline\hline
{\sc\textbf{CL-$L_2$}} & 82.43 & 83.87  \\
{\sc\textbf{CL-KL}} & 82.31 & 83.99  \\
\hline
{\sc\textbf{CL--$L_2$+Semi}} & \textbf{82.88}\rlap{$^{\dagger}$} & 83.92  \\
{\sc\textbf{CL-KL+Semi}} & 82.58\rlap{$^{\dagger}$} & \textbf{84.10}  \\
\hlineB{4}
\end{tabular}
\caption{A comparison between of CL approaches with and without semi-supervised learning. {\sc \textbf{Semi}} represents the approaches with semi-supervised learning. ${\dagger}$ represents the approach is significantly ($p<0.05$) stronger than the approach without semi-supervised learning with the same input view.}
\label{tab:semi}
\end{table}

\subsection{Semi-supervised Cooperative Learning}
Cooperative learning can take advantage of large amounts of unlabeled text for further improvement. We jointly train on the labeled data and unlabeled data in training to form a semi-supervised training manner. During training, we alternate between minimizing the loss (Eq. \ref{eq:final_loss}) for labeled data and the CL loss for unlabeled data (Eq. \ref{eq:cl_loss}). We conduct the experiment on the E-commerce dataset as an example. Results in Table \ref{tab:semi} show that the accuracy of both input views can be improved especially for the input without external contexts, which shows the effectiveness of CL in semi-supervised learning.

\section{Analysis}
We use the WNUT-17 dataset in the analysis.
\subsection{Comparison of Re-ranking Approaches}
Various re-ranking approaches may affect the token representations of the model. We compare our approach with three other re-ranking approaches. The first is the ranking from the search engine without any re-ranking approaches. The second is re-ranking through a fuzzy match score. The approach has been widely applied in a lot of previous work \citep{gu2018search,zhang-etal-2018-guiding,hayati-etal-2018-retrieval,xu-etal-2020-boosting}. The third is BERTScore with tf-idf importance weighting which makes rare words more indicative than common words in scoring. We train our models ({\sc \textbf{w/ Context}}) with external contexts from these re-ranking approaches and report the averaged and best results on WNUT-17 in Table \ref{tab:ranking}. Our results show that re-ranking with BERTScore performs the best, which shows the semantic relevance is helpful for the performance. However, for BERTScore with the tf-idf weighting, the accuracy of the model drops significantly (with $p<0.05$). The possible reason might be that the tf-idf weighting gives high weights to irrelevant texts with rare words during re-ranking.


\begin{table}[t]
\centering
\small
\begin{tabular}{l|cccc}
\hlineB{4}
& \textbf{SE} & \textbf{FM} & \textbf{BS} & \textbf{BS+tf-idf}\\
\hline
\textbf{\textsc{Avg.}} & 59.95 & 59.54 & \textbf{60.20} & 59.71 \\ 
\hline
\textbf{\textsc{Best}} & 61.79 & 60.89 & \textbf{62.29} & 60.96 \\ 
\hlineB{4}
\end{tabular}
\caption{A comparison of different re-ranking approaches by the F1 scores on WNUT-17. \textbf{SE}: Search engine. \textbf{FM}: Fuzzy match score. \textbf{BS}: BERTScore.}
\label{tab:ranking}
\end{table}

\begin{table}[t]
\centering
\setlength\tabcolsep{5pt}
\small
\begin{tabular}{l|c}
\hlineB{4}
& WNUT-17 \\
\hline
\textbf{w/ Context (Ours)} & \textbf{60.20} \\
\hline
\textbf{w/o Context } & 57.86 \\
\textbf{w/ Context (Dataset)} & 57.21\\
\textbf{w/ Context (Generated)} & 57.71\\
\textbf{w/ Context (Random Retrieved)} & 57.53 \\
\textbf{w/ Context (Random Data)} & 47.69\\
\hlineB{4}
\end{tabular}
\caption{A comparison among different contexts types.}
\label{tab:random}
\end{table}

\subsection{How the Context Quality Affects Accuracy}
We analyze how the NER model will perform when the quality of external contexts varies. We train and evaluate the NER model in four conditions with various contexts. The first one takes each dataset split as a document and encodes each sentence with document-level contexts. In this case, we encode the document-level contexts following the approach of \citet{yamada-etal-2020-luke}. The second one uses GPT-2 \citep{radford2019language} to generate 6 relevant sentences as external contexts. The other two conditions randomly select from the retrieved texts or the dataset as external contexts. Results in Table \ref{tab:random} show that all these conditions result in inferior accuracy comparing with the model without any external context. However, our external contexts are more semantically relevant to the input sentence and helpful for prediction.








\begin{table}[t]
\centering
\setlength\tabcolsep{5pt}
\small
\begin{tabular}{l|cc}
\hlineB{4}
 & \multicolumn{2}{c}{Evaluation} \\
 \hline
Approach & {\sc \textbf{w/o Context}} & {\sc \textbf{w/ Context}} \\
\hline\hline
{\sc\textbf{w/o Context }} & 57.86 & 59.40  \\
{\sc\textbf{w/ Context }} & 57.46 & 60.20  \\
{\sc\textbf{w/o CL}} & 58.14 & 59.64 \\
{\sc\textbf{CL-$L_2$ + CL-KL}} & 58.69 & 60.16 \\
\hline
{\sc\textbf{CL-$L_2$ }} & 58.68 & 60.26  \\
{\sc\textbf{CL-KL }} & \textbf{59.33} & \textbf{60.45}  \\
\hlineB{4}
\end{tabular}
\caption{An ablation study of the training and prediction of models.}
\label{tab:ablation}
\end{table}

\subsection{Ablation Study}
To show the effectiveness of CL, we conduct three ablation studies for our approach. The first one is training the NER model based on one view and predict on the other. The second is jointly training both views without the CL loss term (removing $\mcL_{\text{CL}}(\theta)$ in Eq. \ref{eq:final_loss}). The final one is using both CL losses to train the model ($\mcL_{\text{CL}}(\theta)=\mcL_{\text{CL-$L_2$}}(\theta)+\mcL_{\text{CL-KL}}(\theta)$ in Eq. \ref{eq:final_loss}). Results in Table \ref{tab:ablation} show that the external context can help to improve the accuracy even when the NER model is trained without the contexts. However, when the model is trained with the external contexts, the accuracy of the model drops when predicting the inputs without external contexts. In joint training without CL, the accuracy of the model over inputs without contexts can be slightly improved but the accuracy over inputs with contexts drops, which shows the benefit of adding CL. For the model trained with both CL losses, we find no improvement over the models trained with a single CL loss. 


\section{Related Work}
\paragraph{Named Entity Recognition}
Named Entity Recognition \citep{Sundheim1995NamedET} has been studied for decades. Most of the work takes NER as a sequence labeling problem and applies the linear-chain CRF \citep{10.5555/645530.655813} to achieve state-of-the-art accuracy \citep{ma-hovy-2016-end,lample-etal-2016-neural,akbik-etal-2018-contextual,akbik-etal-2019-pooled,wang-etal-2020-more}. 
Recently, the improvement of accuracy mainly benefits from stronger token representations such as pretrained contextual embeddings such as BERT \citep{devlin-etal-2019-bert}, Flair \citep{akbik-etal-2018-contextual} and LUKE \citep{yamada-etal-2020-luke}. Very recent work \citep{yu-etal-2020-named,yamada-etal-2020-luke} utilizes the strength of pretrained contextual embeddings over long-range dependency and encodes the document-level contexts for token representations to achieve state-of-the-art accuracy on CoNLL 2002/2003 NER datasets \citep{tjong-kim-sang-2002-introduction,tjong-kim-sang-de-meulder-2003-introduction}. 

\paragraph{Improving Models through Retrieval}
Retrieving related texts from a certain database (such as the training set) has been widely applied in tasks such as neural machine translation \citep{gu2018search,zhang-etal-2018-guiding,xu-etal-2020-boosting}, text generation \citep{weston-etal-2018-retrieve,kim-etal-2020-retrieval}, semantic parsing \citep{hashimoto2018retrieve,guo-etal-2019-coupling}. Most of the work uses the retrieved texts to guide the generation or refine the retrieved texts through the neural model, while we take the retrieved texts as the contexts of the input sentence to improve the semantic representations of the input tokens.
For the re-ranking models, fuzzy match score \citep{gu2018search,zhang-etal-2018-guiding,hayati-etal-2018-retrieval,xu-etal-2020-boosting}, attention mechanisms \citep{cao-etal-2018-retrieve,cai-etal-2019-retrieval}, and dot products between sentence representations \citep{lewis2020retrieval,xu-etal-2020-boosting} are usual scoring functions to re-rank the retrieved texts. Instead, we use BERTScore to re-rank the retrieved texts instead as BERTScore evaluates semantic correlations between the texts based on pretrained contextual embeddings.


\paragraph{Multi-View Learning}
Multi-View Learning is a technique applied to inputs that can be split into multiple subsets. Co-training \citep{blum1998combining} and co-regularization \citep{sindhwani2005co} train a separate model for each view. These approaches are semi-supervised learning techniques that require two independent views of the data. The model with higher confidence is applied to construct additional labeled data by predicting on unlabeled data. \citet{sun2013survey} and \citet{xu2013survey} have extensively studied various multi-view learning approaches. \citet{hu2021multi} shows the effectiveness of multi-view learning on cross-lingual structured prediction tasks. Recently, \citet{clark-etal-2018-semi} proposed Cross-View Training (CVT), which trains a unified model instead of multiple models and targets at minimizing the KL divergence between the probability distributions of the model and auxiliary prediction modules. Comparing with CVT, CL targets at improving the accuracy of two kinds of inputs rather than only one of them. We also propose to minimize the distance of token representations between different views in addition to KL-divergence. Besides, CL utilizes the external contexts and therefore we do not need to construct auxiliary prediction modules in the model. Moreover, CVT cannot be directly applied to our transformer-based embeddings. Finally, our decoding layer in the model uses the CRF layer instead of the simple Softmax layer as in CVT. The CRF layer is stronger but more difficult for KL-divergence computation.

\paragraph{Knowledge Distillation}
Knowledge distillation \citep{Bucilua:2006:MC:1150402.1150464,44873} transfers the knowledge of ``teacher'' models to smaller ``student'' models through minimizing the KL divergence of prediction probability distribution between the models. In speech recognition \citep{Huang2018} and natural language processing \citep{wang-etal-2020-structure,wang2020structural}, the marginal probability distribution of the linear-chain CRF layer has been applied to distill the knowledge between teacher models and student models. Comparing with these approaches, our approaches train a single unified model instead of transferring the knowledge between two models. We also show that the accuracy of both views can be improved with our approaches, unlike in knowledge distillation only the student model is updated and improved.

\section{Conclusion}
In this paper, we propose to improve the NER model's accuracy by retrieving related contexts from a search engine as external contexts of the inputs. To improve the robustness of the models when no external contexts are available, we propose Cooperative Learning. Cooperative Learning adds constraints between two input views over either the token representations or label distributions of both input views to be consistent. Empirical results show that our approach significantly outperforms the baseline models and previous state-of-the-art approaches on the datasets over 5 domains. We also show the effectiveness of Cooperative Learning in a semi-supervised training manner. 

\section*{Acknowledgments}
This work was supported by the National Natural Science Foundation of China (61976139) and by Alibaba Group through Alibaba Innovative Research Program. We thank Kaibo Zhang for his help in crawling related texts from Google Search and thank Jiong Cai and Zhuo Chen for their comments and suggestions on writing. 



\bibliographystyle{acl_natbib}
\bibliography{anthology,acl2021}

\newpage

\appendix

\begin{table}[t]
\centering
\small
\begin{tabular}{l|c}
\hlineB{4}
 Approach & CoNLL-03 \\
 \hline
\citet{yu-etal-2020-named}\rlap{$^{\dagger}$} & 93.50\\
\citet{yamada-etal-2020-luke} & 94.30\\
\citet{luoma-pyysalo-2020-exploring}\rlap{$^{\dagger}$} & 93.74\\
\citet{wang2020automated} & \textbf{94.60}\\
{\sc\textbf{w/ Doc Context}} & 94.12 \\
\hline
{\sc\textbf{w/o Context }} & 93.30 \\
{\sc\textbf{w/ Context }} & 93.55 \\
{\sc\textbf{CL-$L_2$ }} & 93.68  \\
{\sc\textbf{CL-KL }} & 93.85  \\
\hlineB{4}
\end{tabular}
\caption{A comparison of retrieved contexts and document-level contexts. ${\dagger}$: These approaches are trained on training and development sets.}
\label{tab:document}
\end{table}

\section{Retrieved Contexts Versus Document-level contexts on CoNLL-03}
\label{app:versus}
We conduct a comparison between our retrieved contexts and the document-level contexts on CoNLL-03 datasets. In Table \ref{tab:document}, we report the best model on development set following \citet{yamada-etal-2020-luke}. Comparing with previous state-of-the-art approaches with encoding document-level contexts, our approaches are competitive and even stronger than some of the previous approaches utilizing maximal document-level contexts. Comparing with our model trained on document-level contexts ({\sc\textbf{w/ Doc Context}}), we find that there is still a gap between the document-level contexts and retrieved contexts but our CL approaches can reduce the gap between these two contexts.


\end{document}
