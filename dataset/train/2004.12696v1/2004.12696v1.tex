
\documentclass{article} \usepackage{iclr2020_conference,times}

\iclrfinalcopy


\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{subcaption}
\usepackage{graphicx}
\usepackage{amsmath,amsfonts,bm}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{natbib}
\usepackage{multirow}
\usepackage{xcolor}
\usepackage{mathtools, nccmath}
\usepackage[shortlabels]{enumitem}
\usepackage{colortbl}
\usepackage{arydshln}


\usepackage{pifont}
\newcommand{\chk}{{\centering\checkmark}}
\newcommand{\xmark}{\ding{55}}
\newcommand{\crs}{{\centering\xmark}}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}

\newcommand{\zT}{z_{\mathcal{T}}}
\newcommand{\aT}{a_{\mathcal{T}}}
\newcommand{\zS}{z_{\mathcal{S}}}

\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{(\ref{#1})}
\def\Eqref#1{~(\ref{#1})}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{$\eta$}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{d}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{w}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\newcommand{\CI}{\perp\!\!\!\perp}

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{thmtools}
\usepackage{thm-restate}

\newtheorem{defi}{Definition}
\newtheorem{thm}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{fact}{Fact}
\newtheorem{remark}{Remark}
\newtheorem{lemm}{Lemma}
\newtheorem{coro}{Corollary}

\newtheorem{innercustomthm}{Proposition}
\newenvironment{customprop}[1]
  {\renewcommand\theinnercustomthm{#1}\innercustomthm}
  {\endinnercustomthm}

\newtheorem{innercustomlemma}{Lemma}
\newenvironment{customlemma}[1]
  {\renewcommand\theinnercustomlemma{#1}\innercustomlemma}
  {\endinnercustomlemma}

\newtheorem{innercustomcoro}{Corollary}
\newenvironment{customcoro}[1]
  {\renewcommand\theinnercustomcoro{#1}\innercustomcoro}
  {\endinnercustomcoro}



\newcommand{\nt}{n}
\newcommand{\supp}{l}
\definecolor{green3}{rgb}{0,0.6,0}
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}\PackageWarning{TODO:}{#1!}}
\newcommand{\yang}[1]{\textcolor{blue}{Yang: #1}}
\newcommand{\shell}[1]{\textcolor{orange}{Shell: #1}}
\newcommand{\PGM}[1]{\textcolor{green3}{Pablo: #1}}
\newcommand{\GO}[1]{\textcolor{green3}{Guillaume: #1}}
\newcommand{\AD}[1]{\textcolor{green3}{Andreas: #1}}

\title{Empirical Bayes Transductive Meta-Learning with Synthetic Gradients}



\author{
  Shell Xu Hu$^1$ \,\, Pablo G. Moreno$^2$ \,\, Yang Xiao$^1$ \,\, Xi Shen$^1$ \\
  \hspace{0.03mm} \textbf{Guillaume Obozinski$^3$ \,\, Neil D. Lawrence$^4$ \,\, Andreas Damianou$^2$}\\
    \And
  $^1$Ã‰cole des Ponts ParisTech \\
  Champs-sur-Marne, France \\
  \texttt{\{xu.hu, yang.xiao, xi.shen\}@enpc.fr} 
    \And
  $^2$Amazon \\
  Cambridge, United Kingdom \\
  \texttt{\{morepabl, damianou\}@amazon.com}\\
    \And
  $^3$Swiss Data Science Center \\
  Lausanne, Switzerland \\
  \texttt{guillaume.obozinski@epfl.ch}
    \And
  $^4$University of Cambridge \\
  Cambridge, United Kingdom \\
  \texttt{ndl21@cam.ac.uk}
}





\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}


\maketitle


\begin{abstract}
We propose a meta-learning approach that learns from multiple tasks in a transductive setting, by leveraging the unlabeled query set in addition to the support set to generate a more powerful model for each task. To develop our framework, we revisit the empirical Bayes formulation for multi-task learning. The evidence lower bound of the marginal log-likelihood of empirical Bayes decomposes as a sum of local KL divergences between the variational posterior and the true posterior on the query set of each task.
    We derive a novel amortized variational inference that couples all the variational posteriors via a meta-model, which consists of a synthetic gradient network and an initialization network. Each variational posterior is derived from synthetic gradient descent to approximate the true posterior on the query set, although where we do not have access to the true gradient.  
Our results on the Mini-ImageNet and CIFAR-FS benchmarks for episodic few-shot classification outperform previous state-of-the-art methods.
    Besides, we conduct two zero-shot learning experiments to further explore the potential of the synthetic gradient.
\end{abstract}


\section{Introduction}




While supervised learning of deep neural networks can achieve or even surpass human-level performance \citep{he2015delving,devlin2018bert},
they can hardly extrapolate the learned knowledge beyond the domain where the supervision is provided.
The problem of solving rapidly a new task
after learning several other similar tasks is called \emph{meta-learning} \citep{schmidhuber1987,bengio1991learning,thrun1998learning}; typically, the data is presented in a two-level hierarchy such that each data point at the higher level is itself a dataset associated with a task,
and the goal is to learn a \emph{meta-model} that generalizes across tasks.
In this paper, we mainly focus on \emph{few-shot learning} \citep{vinyals2016matching}, an instance of meta-learning problems,
where a task $t$ consists of 
a \emph{query set} ${\displaystyle d_t := \{(x_{t,i}, y_{t,i})\}_{i=1}^{n}}$ serving as the test-set of the task
and a \emph{support set} ${\scriptstyle d_t^{l} := \{(x_{t,i}^{l}, y_{t,i}^{l})\}_{i=1}^{\nt^l}}$ serving as the train-set.
In \emph{meta-testing}\footnote{To distinguish from testing and training within a task, meta-testing and meta-training are referred to as testing and training over tasks.}, 
one is given the support set and the inputs of the query set $x_t := \{x_{t,i}\}_{i=1}^{\nt}$, and asked to predict the labels $y_t := \{ y_{t,i} \}_{i=1}^{\nt}$.
In \emph{meta-training}, $y_t$ is provided as the ground truth.
The setup of few-shot learning is summarized in Table~\ref{tab:fs}.

\begin{table}[ht]
    \centering
	\begin{tabular}{lccc}
    \toprule
        & \multicolumn{1}{c}{\textbf{Support set}} & \multicolumn{2}{c}{\textbf{Query set}} \\
        & $d_t^{l} := \{(x_{t,i}^{l}, y_{t,i}^{l})\}_{i=1}^{\nt^l}$ & $x_t := \{x_{t,i}\}_{i=1}^{\nt}$ & $y_t = \{ y_{t,i} \}_{i=1}^{\nt}$ \\
    \midrule
	    Meta-training & \chk & \chk & \chk \\
	    Meta-testing & \chk & \chk & \crs \\
	\bottomrule
    \end{tabular}
    \caption{The setup of few-shot learning. If task $t$ is used for meta-testing, $y_t$ is not given to the model.}
\label{tab:fs}
\end{table}

A important distinction to make is whether a task is solved in a \emph{transductive} or \emph{inductive} manner, 
that is, whether $x_t$ is used. The inductive setting is what was originally proposed by \citet{vinyals2016matching},
in which only $d_t^l$ is used to generate a model.
The transductive setting, as an alternative, has the advantage of being able to see partial or all points in $x_t$ before making predictions.
In fact, \citet{nichol2018first} notice that most of the existing meta-learning methods involve transduction unintentionally
since they use $x_t$ implicitly via the \emph{batch normalization} \citep{ioffe2015batch}.
Explicit transduction is less explored in meta-learning, the exception is \citet{liu2018learning}, 
who adapted the idea of label propagation \citep{zhu2003semi} from graph-based semi-supervised learning methods.
We take a totally different path that meta-learn the ``gradient'' descent on $x_t$ without using $y_t$.


Due to the hierarchical structure of the data, it is natural to formulate meta-learning by 
a \emph{hierarchical Bayes} (HB) model \citep{good1980some,berger1985}, 
or alternatively, an empirical Bayes (EB) model \citep{robbins1985empirical,kucukelbir2014population}. 
The difference is that the latter restricts the learning of meta-parameters to point estimates.
In this paper, we focus on the EB model, as it largely simplifies the training and testing without losing the strength of the HB formulation.

The idea of using HB or EB for meta-learning is not new: \citet{amit2018meta} derive an objective similar to that of HB 
using PAC-Bayesian analysis; \citet{grant2018recasting} show that MAML \citep{finn2017model} can be understood as a EB method;
\citet{ravi2018amortized} consider a HB extension to MAML and compute posteriors via amortized variational inference.
However, unlike our proposal, these methods do not make full use of the unlabeled data in query set. 
Roughly speaking, they construct the variational posterior as a function of the labeled set $d_t^\supp$ without taking advantage of the unlabeled set $x_t$. 
The situation is similar in gradient based meta-learning methods 
\citep{finn2017model,ravi2016optimization,li2017meta,nichol2018first,flennerhag2019transferring} 
and many other meta-learning methods \citep{vinyals2016matching,snell2017prototypical,gidaris2018dynamic}, 
where the mechanisms used to generate the task-specific parameters 
rely on groundtruth labels, thus, there is no place for the unlabeled set to contribute. 
We argue that this is a suboptimal choice,
which may lead to overfitting when the labeled set is small
and hinder the possibility of zero-shot learning (when the labeled set is not provided).

In this paper, we propose to use synthetic gradient \citep{jaderberg2017decoupled} 
to enable transduction, such that the variational posterior is implemented as a function of the labeled set $d_t^\supp$ and the unlabeled set $x_t$.
The synthetic gradient is produced by chaining the output of a gradient network into auto-differentiation, 
which yields a surrogate of the inaccessible true gradient.
The optimization process is similar to the inner gradient descent in MAML, but it iterates on the unlabeled $x_t$ rather than on the labeled $d_t^\supp$,
since it does not rely on $y_t$ to compute the true gradient.
The labeled set for generating the model for an unseen task is now optional, which is only used to compute the initialization of model weights in our case. In summary, our main contributions are the following:   
\begin{enumerate}
    \item In section~\ref{sec:model} and section~\ref{sec:alg}, 
        we develop a novel empirical Bayes formulation with transduction for meta-learning.
        To perform amortized variational inference, we propose a parameterization for the variational posterior 
        based on synthetic gradient descent, which incoporates the contextual information from all the inputs of the query set.
    \item In section~\ref{sec:theory}, we show in theory that a transductive variational posterior yields better generalization performance.
        The generalization analysis is done through the connection between empirical Bayes formulation and
        a multitask extension of the information bottleneck principle.
        In light of this, we name our method \emph{synthetic information bottleneck} (SIB).
    \item In section~\ref{sec:exp}, we verify our proposal empirically. 
        Our experimental results demonstrate that our method significantly outperforms the state-of-the-art meta-learning methods 
        on few-shot classification benchmarks under the one-shot setting. 
\end{enumerate}


\begin{figure*}[t]
	\centering
	\begin{minipage}{.28\textwidth}
		\centering
		\includegraphics[width=0.9\linewidth]{./figures/gm_crop2.pdf}\\
        (a) Graphical model of EB
	\end{minipage}
	\hfill
	\begin{minipage}{.35\textwidth}
		\centering
		\includegraphics[width=1.0\linewidth]{./figures/MAML.pdf}\\
        (b) MAML
	\end{minipage} 
	\hfill
	\begin{minipage}{.35\textwidth}
		\centering
		\includegraphics[width=1.0\linewidth]{./figures/SIB2.pdf}\\
        (c) Our method (SIB)
	\end{minipage}
    \caption{\textbf{(a)} The generative and inference processes of the empirical Bayes model 
    are depicted in solid and dashed arrows respectively, 
    where the meta-parameters are denoted by dashed circles due to the point estimates.
    A comparison between MAML \eqref{eq:maml} and our method (SIB) \eqref{eq:sib} is shown in \textbf{(b)} and \textbf{(c)}.
    MAML is an inductive method since, for a task $t$, it first constructs the variational posterior (with parameter $\theta^K$) as a function of the support set $d_t^\supp$,
    and then test on the unlabeled $x_t$; while SIB uses a better variational posterior as a function of both $d_t^\supp$ and $x_t$:
    it starts from an initialization $\theta_t^0(d_t^\supp)$ generated using $d_t^\supp$, and then yields $\theta_t^K$ by running $K$ synthetic gradient steps on $x_t$.
    }
\label{fig:intro}
\end{figure*}


 \section{Meta-learning with transductive inference}
\label{sec:model}

The goal of meta-learning is to train a \emph{meta-model} on a collection of tasks,
such that it works well on another disjoint collection of tasks.
Suppose that we are given a collection of $N$ tasks for training. 
The associated data is denoted by $\gD := \{d_t := (x_t, y_t) \}_{t=1}^N$. 
In the case of few-shot learning, 
we are given in addition a support set $d_t^\supp$ in each task. 
In this section, we revisit the classical empirical Bayes model for meta-learning. Then, 
we propose to use a transductive scheme in the variational inference by implementing the variational posterior as a function of $x_t$. 


\subsection{Empirical Bayes model}

Due to the hierarchical structure among data, it is natural to 
consider a hierarchical Bayes model with the marginal likelihood
\begin{align}
    p_f(\gD) = \int_\psi p_f(\gD | \psi) p(\psi)
    = \int_\psi \Big[ \prod_{t=1}^N \int_{w_t} p_f(d_t| w_t) p(w_t | \psi) \Big] p(\psi).
\end{align}
The generative process is illustrated in Figure~\ref{fig:intro} (a, in red arrows):
first, a \emph{meta-parameter} $\psi$ (i.e., hyper-parameter) is sampled from the \emph{hyper-prior} $p(\psi)$;
then, for each task, a \emph{task-specific parameter} $w_t$ is sampled from the \emph{prior} $p(w_t | \psi)$;
finally, the dataset is drawn from the \emph{likelihood} $p_f(d_t | w_t)$. Without loss of generality, we assume the log-likelihood model factorizes as 
\begin{align}
    \label{eq:lik}
    \log p_f(d_t | w_t) &= \sum_{i=1}^{\nt} \log p_f(y_{t,i} | x_{t,i}, w_t) + \log p(x_{t,i} | w_t), \notag \\
    &= \sum_{i=1}^{\nt} -\frac{1}{n} \ell_t\big( \hat{y}_{t,i}(f(x_{t,i}), w_t), y_{t,i} \big) + \,\text{constant}.
\end{align}
It is the setting advocated by \citet{minka2005discriminative}, 
in which the generative model $p(x_{t,i} | w_t)$ can be safely ignored since 
it is irrelevant to the prediction of $y_t$.
To simplify the presentation, 
we still keep the notation $p_f(d_t | w_t)$ for the likelihood of the task $t$ and 
use $\ell_t$ to specify the discriminative model, which is also referred to as
the \emph{task-specific loss}, e.g., the cross entropy loss. The first argument in $\ell_t$ is the prediction, denoted by $\hat{y}_{t,i} = \hat{y}_{t,i}(f(x_{t,i}), w_t)$, 
which depends on the \emph{feature representation} $f(x_{t,i})$ and the \emph{task-specific weight} $w_t$. 

Note that rather than following a fully Bayesian approach, 
we leave some random variables to be estimated in a frequentist way, 
e.g., $f$ is a \emph{meta-parameter} of the likelihood model shared by all tasks, 
for which we use a point estimate.
As such, the posterior inference about these variables will be largely simplified.
For the same reason, we derive the \emph{empirical Bayes} \mbox{\citep{robbins1985empirical,kucukelbir2014population}}
by taking a point estimate on $\psi$. The marginal likelihood now reads as
\begin{align}
    \label{eq:eb}
    p_{\psi, f}(\gD) = \prod_{t=1}^N \int_{w_t} p_f(d_t| w_t) p_\psi(w_t).
\end{align}
We highlight the meta-parameters as subscripts of the corresponding distributions to distinguish from random variables.
Indeed, we are not the first to formulate meta-learning as empirical Bayes.
The overall model formulation is essentially the same as the ones considered by 
\citet{amit2018meta,grant2018recasting,ravi2018amortized}. 
Our contribution lies in the variational inference for empirical Bayes.

\subsection{Amortized inference with transduction}
\label{sec:avi}

As in standard probabilistic modeling, 
we derive an \emph{evidence lower bound} (ELBO) on the log version of \eqref{eq:eb}
by introducing a variational distribution $q_{\theta_t}(w_t)$ for each task with parameter $\theta_t$: 
\begin{align}
    \label{eq:vae}
    \log p_{\psi, f}(\gD) &\geq \sum_{t=1}^N \Big[ \E_{w_t \sim q_{\theta_t}} \big[ \log p_f(d_t | w_t) \big] - D_\text{KL}\big(q_{\theta_t}(w_t) \| p_\psi(w_t) \big) \Big].
\end{align}
The variational inference amounts to maximizing the ELBO with respect to $\theta_1, \ldots, \theta_N$, which 
together with the maximum likelihood estimation of the meta-parameters, we have the following optimization problem:
\begin{align}
    \label{eq:vi}
\min_{\psi,f} \min_{\theta_1, \ldots, \theta_N} \frac{1}{N} \sum_{t=1}^N \Big[ \E_{w_t \sim q_{\theta_t}} \big[ -\log p_f(d_t | w_t) \big] + D_\text{KL}\big(q_{\theta_t}(w_t) \| p_\psi(w_t) \big) \Big]. 
\end{align}
However, the optimization in \eqref{eq:vi}, as $N$ increases, becomes more and more expensive in terms of the memory footprint and the computational cost.
We therefore wish to bypass this heavy optimization
and to take advantage of the fact that
individual KL terms indeed share the same structure.
To this end, instead of introducing $N$ different variational distributions, 
we consider a parameterized family of distributions in the form of $q_{\phi(\cdot)}$, 
which is defined implicitly by a deep neural network $\phi$ taking as input either $d_t^l$ or $d_t^l$ plus $x_t$,
that is, $q_{\phi(d_t^l)}$ or $q_{\phi(d_t^l, x_t)}$.
Note that we cannot use entire $d_t$,
since we do not have access to $y_t$ during meta-testing.
This amortization technique was first introduced in the case of \emph{variational autoencoders} \citep{kingma2013auto,rezende2014stochastic},
and has been extended to Bayesian inference in the case of \emph{neural processes} \citep{garnelo2018neural}.

Since $d_t^\supp$ and $x_t$ are disjoint, the inference scheme is \emph{inductive} for a variational posterior $q_{\phi(d_t^\supp)}$.
As an example, MAML \citep{finn2017model} takes $q_{\phi(d_t^\supp)}$ as the Dirac delta distribution,
where $\phi(d_t^\supp) = \theta_t^K$, is the $K$-th iterate of the stochastic gradient descent
\begin{align}
    \label{eq:maml}
    \theta_t^{k+1} = \theta_t^k + \eta \, \nabla_{\theta} \E_{w_t \sim q_{\theta_t^k}}\Big[ \log p(d_t^\supp | w_t) \Big] \,\,\text{with}\,\,\theta_t^0 = \phi, \,\,\text{a learnable initialization}.
\end{align}

In this work, we consider a \emph{transductive} inference scheme with variational posterior $q_{\phi(d_t^l, x_t)}$.
The inference process is shown in Figure~\ref{fig:intro}(a, in green arrows).
Replacing each $q_{\theta_t}$ in \eqref{eq:vi} by $q_{\phi(d_t^l, x_t)}$,
the optimization problem becomes
\begin{align}
    \label{eq:avi}
    \min_{\psi,f} \min_{\phi} \frac{1}{N} \sum_{t=1}^N \Big[ \E_{w_t \sim q_{\phi(d_t^l, x_t)}} \big[ -\log p_f(d_t | w_t) \big] + D_\text{KL}\big(q_{\phi(d_t^l, x_t)}(w_t) \| p_\psi(w_t) \big) \Big].
\end{align}
In a nutshell, the meta-model to be optimized includes the feature network $f$, the hyper-parameter $\psi$ from the empirical Bayes formulation and the amortization network $\phi$ from the variational inference.

 \section{Unrolling exact inference with synthetic gradients}
\label{sec:alg}

It is however non-trivial to design a proper network architecture for $\phi(d_t^l, x_t)$, since $d_t^l$ and $x_t$ are both sets.
The strategy adopted by neural processes \citep{garnelo2018neural} is to aggregate the information from all individual examples via an averaging function.
However, as pointed out by \citet{kim2019attentive}, such a strategy tends to underfit $x_t$ 
because the aggregation does not necessarily attain the most relevant information for identifying the task-specific parameter.
Extensions, such as attentive neural process \citep{kim2019attentive} and set transformer \citep{lee2019set}, may alleviate this issue but come at a price of $O(n^2)$ time complexity.
We instead design $\phi(d_t^l, x_t)$ to mimic the exact inference $\argmin_{\theta_t} D_\text{KL}(q_{\theta_t}(w_t) \| p_{\psi, f}(w_t | d_t))$
by parameterizing the optimization process with respect to $\theta_t$. More specifically,
consider the gradient descent on $\theta_t$ with step size $\eta$:
\begin{align}
    \label{eq:gd}
    \theta_t^{k+1} = \theta_t^{k} - \eta \, \nabla_{\theta_t} D_\text{KL}\Big( q_{\theta_t^{k}}(w) \,\|\, p_{\psi, f}(w \,|\, d_t) \Big).
\end{align}
We would like to unroll this optimization dynamics up to the $K$-th step such that $\theta_t^K = \phi(d_t^l, x_t)$
while make sure that $\theta_t^K$ is a good approximation to the optimum $\theta_t^\star$,
which consists of parameterizing 
\begin{quote}
    (a) the \textbf{initialization} $\theta_t^0$ and 
    (b) the \textbf{gradient} $\nabla_{\theta_t} D_\text{KL}( q_{\theta_t}(w_t) \,\|\, p_{\psi, f}(w_t | d_t) )$.
\end{quote}
By doing so, $\theta_t^K$ becomes a function of $\phi$, $\psi$ and $x_t$\footnote{
$\theta_t^K$ is also dependent of $f$. We deliberately remove this dependency to simplify the update of $f$.}, 
we therefore realize $q_{\phi(d_t^l, x_t)}$ as $q_{\theta_t^K}$.

For (a), we opt to either let $\theta_t^0 = \lambda$ to be a global data-independent initialization as in MAML \citep{finn2017model}
or let $\theta_t^0 = \lambda(d_t^\supp)$ with a few supervisions from the support set,
where $\lambda$ can be implemented by a permutation invariant network described in \citet{gidaris2018dynamic}. 
In the second case, the features of the support set will be first averaged in terms of their labels
and then scaled by a learnable vector of the same size.

For (b), the fundamental reason that we parameterize the gradient is because we do not have access to $y_t$ during the meta-testing phase, although
we are able to follow \eqref{eq:gd} in meta-training to obtain $q_{\theta_t^\star}(w_t) \propto p_f(d_t | w_t) p_{\psi}(\rw_t)$.
To make a consistent parameterization in both meta-training and meta-testing, we thus do not touch $y_t$ when constructing the variational posterior.  
Recall that the true gradient decomposes as
\begin{align}
\nabla_{\theta_t} D_\text{KL}\Big( q_{\theta_t} \| p_{\psi, f} \Big) = 
    \E_\epsilon \Big[ \frac{1}{n} \sum_{i=1}^{\nt} \frac{\partial \ell_t(\hat{y}_{t,i}, y_{t,i})}{\partial \hat{y}_{t,i}}  
    \frac{\partial \hat{y}_{t,i}}{\partial w_t} 
    \frac{\partial w_t(\theta_t, \epsilon)}{\partial \theta_t} \Big]
    + \nabla_{\theta_t} D_\text{KL}\Big( q_{\theta_t} \| p_{\psi} \Big)
\end{align}
under a reparameterization $w_t = w_t(\theta_t, \epsilon)$ with $\epsilon \sim p(\epsilon)$,
where all the terms can be computed without $y_{t}$ 
except for $\frac{\partial \ell_t}{\partial \hat{y}_{t,i}}$.
Thus, we introduce a deep neural network $\xi(\hat{y}_{t,i})$ to synthesize it.
The idea of synthetic gradients was originally proposed by \citet{jaderberg2017decoupled} to 
parallelize the back-propagation. Here, the purpose of $\xi(\hat{y}_{t,i})$ is to update $\theta_t$ regardless of the groundtruth labels,
which is slightly different from its original purpose. 
Besides, we do not introduce an additional loss 
between $\xi(\hat{y}_{t,i})$ and $\frac{\partial \ell_t}{\partial \hat{y}_{t,i}}$
since $\xi(\hat{y}_{t,i})$ will be driven by the objective in \eqref{eq:avi}.
As an intermediate computation, the synthetic gradient is not necessarily a good approximation to the true gradient.



\begin{figure*}[t]
    \centering
    \includegraphics[width=1.0\linewidth]{./figures/synth_grad_comp_graph_crop}\\
    \caption{The computation graph to compute the negative ELBO, 
    where the input and output of the synthetic gradient module are highlighted in red.
    The detach() is used to stop the back-propagation down to the feature network.
Note that we do not include every computation for simplicity.
    }
	\label{fig:cg}
\end{figure*}


To sum up, we have derived a particular implementation of $\phi(d_t^l,x_t)$ by parameterizing the exact inference update, 
namely \eqref{eq:gd}, without using the labels of the query set,
where the meta-model $\phi$ includes an initialization network $\lambda$ and a synthetic gradient network $\xi$,
such that $\phi(x_t) = \theta_t^K$, the $K$-th iterate of the following update: 
\begin{align}
    \label{eq:sib}
    \theta_t^{k+1} = \theta_t^k - \eta \, \Big[ 
    \E_\epsilon \Big[ {\frac{1}{n} \sum_{i=1}^{\nt}} \xi(\hat{y}_{t,i}) \frac{\partial \hat{y}_{t,i}}{\partial w_t} 
    \frac{\partial w_t(\theta_t^{k}, \epsilon)}{\partial \theta_t} \Big]
    + \nabla_{\theta_t} D_\text{KL}\Big( q_{\theta_t^k} \| p_{\psi} \Big)
    \Big].
\end{align}
The overall algorithm is depicted in Algorithm~\ref{alg:sib}. 
We also make a side-by-side comparison with MAML shown in Figure~\ref{fig:intro}.
Rather than viewing \eqref{eq:sib} as an optimization process, it may be more precise to think of it as a part of the computation graph created in the forward-propagation. 
The computation graph of the amortized inference is shown in Figure~\ref{fig:cg},

As an extension, if we were deciding to estimate the feature network $f$ in a Bayesian manner, 
we would have to compute higher-order gradients as in the case of MAML.
This is inpractical from a computational point of view and needs technical simplifications \citep{nichol2018first}. 
By introducing a series of synthetic gradient networks in a way similar to \citet{jaderberg2017decoupled}, the computation will be decoupled into computations within each layer, and thus becomes more feasible. 
We see this as a potential advantage of our method
and leave this to our future work\footnote{We do not insist on Bayesian estimation of the feature network because 
most Bayesian versions of CNNs underperform their deterministic counterparts.}.

\begin{algorithm}[t]
  \caption{Variational inference with synthetic gradients for empirical Bayes}
  \label{alg:sib}
  \begin{algorithmic}[1]
    \State \textbf{Input}: the dataset $\gD$; the step size $\eta$; the number of inner iterations $K$; pretrained $f$.
    \State Initialize the meta-models $\psi$, and $\phi = (\lambda, \xi)$.
    \While{not converged}
      \State Sample a task $t$ and the associated query set $d_t$ (plus optionally the support set $d_t^\supp$).
      \State Compute the initialization $\theta_t^0 = \lambda$ or $\theta_t^0 = \lambda(d_t^\supp)$.
      \For{$k = 1,\ldots,K$} 
        \State Compute $\theta_t^k$ via \eqref{eq:sib}.
      \EndFor
      \State Compute $w_t = w_t(\theta_t^K, \epsilon)$ with $\epsilon \sim p(\epsilon)$.
      \State Update $\psi \leftarrow \psi - \eta \,\nabla_\psi D_\text{KL}( q_{\theta_t^K(\psi)} \| p_{\psi} )$.
      \vspace{-0.2mm}
      \State Update $\phi \leftarrow \phi - \eta \,\nabla_\phi D_\text{KL}( q_{\phi(x_t)} \| p_f \cdot p_{\psi} )$.
      \State Optionally, update $f \leftarrow f + \eta \,\nabla_f \log p_f(d_t | w_t)$.
    \EndWhile
\end{algorithmic}
\end{algorithm}














 \section{Generalization analysis of empirical Bayes via the connection to information bottleneck}
\label{sec:theory}

The learning of empirical Bayes (EB) models follows the frequentist's approach,
therefore, we can use frequentist's tool to analyze the model.
In this section, we study the generalization ability of the empirical Bayes model
through its connection to a variant of the information bottleneck principle \citet{Achille17,tishby2000information}. 

\paragraph{Abstract form of empirical Bayes}
From \eqref{eq:eb}, we see that the empirical Bayes model implies a simpler joint distribution since
\begin{align}
    \label{eq:decomp}
    \log p_{\psi,f}(w_1, \ldots, w_N, \gD) = \sum_{t=1}^N \log p_{f}(d_t | w_t) + \log p_{\psi}(w_t),
\end{align}
which is equal to the log-density of $N$ iid samples drawn from the joint distribution
\begin{align}
p(w, d, t) \equiv p_{\psi,f}(w, d, t) = p_{f}(d| w, t) p_{\psi,f}(w) p(t)\footnote{
    When the context is clear, we ignore the parameters and write $p_{\psi,f}(w, d, t) = p(w,d,t)$.}
\end{align}
up to a constant if we introduce a random variable to represent the task and assume $p(t)$ is an uniform distribution.
We thus see that this joint distribution embodies the \emph{generative process} of empirical Bayes. 
Correspondingly, there is another graphical model of the joint distribution characterizes
the \emph{inference process} of the empirical Bayes:
\begin{align}
q(w,d,t) \equiv q_\phi(w, d, t) = q_\phi(w | d,t) q(d|t) q(t), 
\end{align}
where $q_\phi(w | d,t)$ is the abstract form of the variational posterior with amortization,
includes both the inductive form and the transductive form.
The coupling between $p(w,d,t)$ and $q(w,d,t)$ is due to $p(t) \equiv q(t)$ as we only have access to tasks through sampling.

We are interested in the case that the number of tasks $N \rightarrow \infty$,
such as the few-shot learning paradigm proposed by \citet{vinyals2016matching},
in which the objective of \eqref{eq:avi} can be rewritten in an abstract form of
\begin{align}
    \label{eq:popeb}
    \E_{q(t)} \E_{q(d|t)} \Big[ \E_{q(w|d,t)} \big[ -\log p(d | w, t) \big] + D_\text{KL}\big(q(w | d, t) \| p(w) \big)
    \Big].
\end{align}
In fact, optimizing this objective is the same as optimizing \eqref{eq:avi} from
a stochastic gradient descent point of view.

The learning of empirical Bayes with amortized variational inference 
can be understood as a variational EM in the sense that
the E-step amounts to aligning $q(w | d,t)$ with $p(w | d, t)$ while the M-step amounts to adjusting the likelihood $p(d | w, t)$ and the prior $p(w)$.



\paragraph{Connection to information bottleneck}
The following theorem shows the connection between \eqref{eq:popeb} and the information bottleneck principle.


\begin{restatable*}{thm}{ebibt}
    \label{thm:ib}
    Given distributions $q(w | d, t)$, $q(d|t)$, $q(t)$, $p(w)$ and $p(d | w, t)$, we have
\begin{align}
    \label{eq:ib}
\eqref{eq:popeb} \geq I_q(w; d | t) + H_{q}(d | w, t),
\end{align}
    where $I_q(w; d | t) := D_\text{KL}\big( q(w,d | t) \| q(w | t) q(d | t) \big)$ is the conditional mutual information
    and $H_{q}(w | d, t) := \E_{q(w, d, t)} [-\log q(w | d, t)]$ is the conditional entropy.
The equality holds when 
    $$
    \forall t \colon D_\text{KL}(q(w|t) \| p(w)) = 0 \,\,\text{and}\,\, D_\text{KL}(q(d|w,t) \| p(d|w,t)) = 0.
    $$
\end{restatable*}
In fact, the lower bound on \eqref{eq:popeb} is an extention of the information bottleneck principle \citep{Achille17} under the multi-task setting,
which, together with the synthetic gradient based variational posterior, 
    inspire the name \textbf{synthetic information bottleneck} of our method.
The tightness of the lower bound depends on both 
the parameterizations of $p_f(d | w, t)$ and $p_\psi(w)$ 
as well as the optimization of \eqref{eq:popeb}.
It thus can be understood as how well we can align the inference process with the generative process.
    From an inference process point of view, for a given $q(w | d, t)$, the optimal likelihood and prior have been determined.
    In theory, we only need to find the optimal $q(w | d, t)$ using the information bottleneck in \eqref{eq:ib}.
    However, in practice, minimizing \eqref{eq:popeb} is more straightforward.

\paragraph{Generalization of empirical Bayes meta-learning}
    The connection to information bottleneck suggests that we can eliminate $p(d|w,t)$ and $p(w)$ from 
    the generalization analysis of empirical Bayes meta-learning and define the generalization error by $q(w, d, t)$ only.
    To this end, we first identify the \emph{empirical risk} for a single task $t$ with respect to particular weights $w$ and dataset $d$ as 
\begin{align}
L_t(w, d) := \frac{1}{\nt} \sum_{i=1}^{\nt} \ell_t(\hat{y}_i(f(x_i),w), y_i).
\end{align}
    The \emph{true risk} for task $t$ with respect to $w$ is then the expected empirical risk $\E_{d \sim q(d | t)} L_t(w, d)$.
    Now, we define the \emph{generalization error} with respect to $q(w, d, t)$ as 
    the average of the difference between the true risk and the empirical risk over all possible $t, d, w$:
\begin{align}
    \text{gen}(q) &:= 
    \E_{q(t) q(d|t) q(w|d,t)} \Big[ \E_{d \sim q(d | t)} L_t(w, d) - L_t(w, d) \Big] \notag \\
    &=  \E_{q(t) q(d|t) q(w|t)} L_t(w, d) -  \E_{q(t) q(d|t) q(w|d,t)} L_t(w, d),
\end{align}
where $q(w|t)$ is the \emph{aggregated posterior} of task $t$.

Next, we extend the result from \citet{xu2017information} and derive a data-dependent upper bound for $\text{gen}(q)$ using mutual information.
\begin{restatable*}{thm}{genmi}
    Denote by $z = (x, y)$.
    If $\ell_t(\hat{y}_i(f(x_i),w), y_i) \equiv \ell_t(w, z_i)$ is $\sigma$-subgaussian under $q(w|t)q(z|t)$, 
then $L_t(w, d)$ is $\sigma/\sqrt{n}$-subgaussian under $q(w|t)q(d|t)$ due to the iid assumption, and
    \begin{align}
        \big| \text{gen}(q) \big| \leq \sqrt{\frac{2\sigma^2}{n} I_q(w; d | t)}.
    \end{align}
\end{restatable*}

Plugging this back to Theorem~\ref{thm:ib}, we obtain a different interpretation for the empirical Bayes ELBO.

\begin{coro}
    \label{thm:gen}
    If $\ell_t$ is chosen to be the negative log-likelihood, minimizing the population objective of empirical Bayes meta-learning
    amounts to minimizing both the expected generalization error and the expected empirical risk:
    \begin{align}
\eqref{eq:popeb} \geq \frac{n}{2\sigma^2} \text{gen}(q)^2 + \E_{q(t) q(d|t) q(w|d,t)} L_t(w, d).
    \end{align}
\end{coro}



The Corollary \ref{thm:gen} suggests that \eqref{eq:popeb} amounts to minimizing a regularized empirical risk minimization.
In general, there is a tradeoff between the generalization error and the empirical risk 
controlled by the coefficient $\frac{n}{2 \sigma^2}$, where $n = |d|$ is the cardinality of $d$.
If $n$ is small, then we are in the overfitting regime. 
This is the case of the inductive inference with variational posterior $q(w | d^l, t)$, 
where the support set $d^l$ is fairly small by the definition of few-shot learning.
On the other hand, if we were following the transductive setting, we expect to achieve a small generalization error since the implemented variational posterior is a better approximation to $q(w | d, t)$.
However, keeping increasing $n$ will potentially over-regularize the model and thus yield negative effect.
An empirical study on varying $n$ can be found in Table~\ref{tab:abn} in Appendix~\ref{sec:varyn}.


 \section{Experiments}
\label{sec:exp}
In this section, we first validate our method on few-shot learning, 
and then on zero-shot learning (no support set and no class description are available). 
Note that many meta-learning methods cannot do zero-shot learning since they rely on the support set.

\subsection{Few-shot classification}
\label{sec:few}

\begin{table}[t]
\centering
\footnotesize
\scalebox{0.9}{
\begin{tabular}{ p{4.35cm} c c c c c }
\toprule
 & & \multicolumn{2}{c}{\textbf{MiniImageNet, 5-way}} & \multicolumn{2}{c}{\textbf{CIFAR-FS, 5-way}} \\
 \textbf{Method} & \textbf{Backbone} & 1-shot & 5-shot & 1-shot & 5-shot \\
\midrule
Matching Net~\citep{vinyals2016matching} & Conv-4-64 & 44.2\% & 57\% & -- & -- \\
MAML~\citep{finn2017model} & Conv-4-64 & 48.7$\pm$1.8\% & 63.1$\pm$0.9\% & 58.9$\pm$1.9\% & 71.5$\pm$1.0\% \\
Prototypical Net~\citep{snell2017prototypical} & Conv-4-64 & 49.4$\pm$0.8\% & 68.2$\pm$0.7\% & 55.5$\pm$0.7\% & 72.0$\pm$0.6\% \\
Relation Net~\citep{sung2018learning} & Conv-4-64 & 50.4$\pm$0.8\% & 65.3$\pm$0.7\% & 55.0$\pm$1.0\% & 69.3$\pm$0.8\% \\
GNN~\citep{Satorras2017FewShotLW} & Conv-4-64 & 50.3\% & 66.4\% & 61.9\% & 75.3\% \\
R2-D2~\citep{Bertinetto2018MetalearningWD} & Conv-4-64 & 49.5$\pm$0.2\% & 65.4$\pm$0.2\% & 62.3$\pm$0.2\% & 77.4$\pm$0.2\% \\
TPN~\citep{liu2018learning} & Conv-4-64 & 55.5\% & 69.9\% & -- & -- \\
\citet{gidaris2019boosting} & Conv-4-64 & 54.8$\pm$0.4\% & \textbf{71.9$\pm$0.3\%} & 63.5$\pm$0.3\% & \textbf{79.8$\pm$0.2\%} \\ \hline

\rowcolor[gray]{.9} SIB $K$=0 ($\textit{Pre-trained feature}$) & Conv-4-64 & 50.0$\pm$0.4\% & 67.0$\pm$0.4\% & 59.2$\pm$0.5\% & 75.4$\pm$0.4\%\\
\rowcolor[gray]{.9} SIB $\eta$=1e-3, $K$=3 & Conv-4-64 & \textbf{58.0$\pm$0.6\%} & 70.7$\pm$0.4\% & \textbf{68.7$\pm$0.6\%} & 77.1$\pm$0.4\%\\ \midrule
\rowcolor[gray]{.9} SIB $\eta$=1e-3, $K$=0 & Conv-4-128 & 53.62 $\pm$ 0.79\% & 71.48 $\pm$ 0.64\% & -- & --\\ 
\rowcolor[gray]{.9} SIB $\eta$=1e-3, $K$=1 & Conv-4-128 & 58.74 $\pm$ 0.89\% & 74.12 $\pm$ 0.63\% & -- & --\\ 
\rowcolor[gray]{.9} SIB $\eta$=1e-3, $K$=3 & Conv-4-128 & 62.59 $\pm$ 1.02\% & 75.43 $\pm$ 0.67\% & -- & --\\ 
\rowcolor[gray]{.9} SIB $\eta$=1e-3, $K$=5 & Conv-4-128 & \textbf{63.26 $\pm$ 1.07\%} & \textbf{75.73 $\pm$ 0.71\%} & -- & --\\ \midrule

TADAM~\citep{Oreshkin2018TADAMTD} & ResNet-12 & 58.5$\pm$0.3\% & 76.7$\pm$0.3\% & -- & -- \\
SNAIL~\citep{Santoro2017ASN} & ResNet-12 & 55.7$\pm$1.0\% & 68.9$\pm$0.9\% & -- & -- \\
MetaOptNet-RR~\citep{lee2019meta} & ResNet-12 & 61.4$\pm$0.6\% & 77.9$\pm$0.5\% & 72.6$\pm$0.7\% & 84.3$\pm$0.5\% \\
MetaOptNet-SVM                     & ResNet-12 & 62.6$\pm$0.6\% & 78.6$\pm$0.5\% & 72.0$\pm$0.7\% & 84.2$\pm$0.5\% \\
CTM~\citep{li2019ctm} & ResNet-18 & 64.1$\pm$0.8\% & \textbf{80.5$\pm$0.1\%} & -- & -- \\

\citet{qiao2018few} & WRN-28-10 & 59.6$\pm$0.4\% & 73.7$\pm$0.2\% & -- & --\\
LEO~\citep{rusu2018metalearning} & WRN-28-10 & 61.8$\pm$0.1\% & 77.6$\pm$0.1\% & -- & -- \\
\citet{gidaris2019boosting} & WRN-28-10 & 62.9$\pm$0.5\% & 79.9$\pm$0.3\% & 73.6$\pm$0.3\% & \textbf{86.1$\pm$0.2\%} \\ \hline

\rowcolor[gray]{.9} SIB $K$=0 ($\textit{Pre-trained feature}$) & WRN-28-10 & 60.6$\pm$0.4\% & 77.5$\pm$0.3\% & 70.0$\pm$0.5\% & 83.5$\pm$0.4\% \\
\rowcolor[gray]{.9} SIB $\eta$=1e-3, $K$=1 & WRN-28-10 & 67.3$\pm$0.5\% & 78.8$\pm$0.4\% & 76.8$\pm$0.5\%& 84.9$\pm$0.4\%\\
\rowcolor[gray]{.9} SIB $\eta$=1e-3, $K$=3 & WRN-28-10 & 69.6$\pm$0.6 \% & 78.9$\pm$0.4\% & 78.4$\pm$0.6\% & 85.3$\pm$0.4\%\\
\rowcolor[gray]{.9} SIB $\eta$=1e-3, $K$=5 & WRN-28-10 & \textbf{70.0$\pm$0.6\%} & 79.2$\pm$0.4\% & \textbf{80.0$\pm$0.6\%}& 85.3$\pm$0.4\% \\

\bottomrule
\end{tabular}}
\caption{Average classification accuracies (with 95\% confidence intervals) on the test-set of MiniImageNet and CIFAR-FS. 
    For evaluation, we sample 2000 and 5000 episodes respectively for MiniImageNet and CIFAR-FS 
    and test three different architectures as the feature extractor: Conv-4-64, Conv-4-128 and WRN-28-10. 
    We train SIB with learning rate $0.001$ and try different numbers of synthetic gradient steps $K$.}
\label{tab:tab-1}
\end{table}


We compare SIB with state-of-the-art methods on few-shot classification problems.
Our code is available at \url{https://github.com/amzn/xfer}.

\subsubsection{Setup}

\paragraph{Datasets}
We choose standard benchmarks of few-shot classification for this experiment.
Each benchmark is composed of disjoint training, validation and testing classes. 
\textbf{MiniImageNet} is proposed by \citet{vinyals2016matching}, which contains 100 classes, 
split into 64 training classes, 16 validation classes and 20 testing classes;
each image is of size 84$\times$84. 
\textbf{CIFAR-FS} is proposed by~\citet{Bertinetto2018MetalearningWD}, 
which is created by dividing the original CIFAR-100 into 
64 training classes, 16 validation classes and 20 testing classes; 
each image is of size 32$\times$32.


\paragraph{Evaluation metrics} In few-shot classification, 
a task (aka episode) $t$ consists of a \emph{query set} $d_t$ and a \emph{support set} $d_t^\supp$. 
When we say the task $t$ is \emph{$k$-way-$n^\supp$-shot} we mean that 
$d_t^\supp$ is formed by first sampling $k$ classes from a pool of classes;
then, for each sampled class, $n^\supp$ examples are drawn and a new label taken from $\{0, \ldots, k-1\}$ is assigned to these examples.
By default, each query set contains $15k$ examples.
The goal of this problem is to predict the labels of the query set, which are provided as ground truth during training.
The evaluation is the average classification accuracy over tasks.


\paragraph{Network architectures}
Following \citet{gidaris2018dynamic,qiao2018few,gidaris2019boosting}, we implement $f$ by a 4-layer convolutional network (Conv-4-64 or Conv-4-128\footnote{
    Conv-4-64 consists of 4 convolutional blocks each implemented with a $3 \times 3$ convolutional layer followed by BatchNorm + ReLU + $2 \times 2$ 
    max-pooling units. All blocks of Conv-4-64 have 64 feature channels. 
    Conv-4-128 has 64 feature channels in the first two blocks and  128 feature channels in the last two blocks.
})
or a WideResNet (WRN-28-10) \citep{zagoruyko2016wide}. We pretrain the feature network $f(\cdot)$ on the 64 training classes for a stardard $64$-way classification.
We reuse the feature averaging network proposed by \citet{gidaris2018dynamic} as our initialization network $\lambda(\cdot)$, 
which basically averages the feature vectors of all data points from the same class and then scales each feature dimension differently by a learned coefficient.
For the synthetic gradient network $\xi(\cdot)$, we implement a three-layer MLP with hidden-layer size $8k$.
Finally, for the predictor $\hat{y}_{ij}(\cdot, w_i)$, we adopt the cosine-similarity based classifier advocated by \citet{chen2019closer} and \citet{gidaris2018dynamic}.


\paragraph{Training details}
We run SGD with batch size $8$ for 40000 steps, where the learning rate is fixed to $10^{-3}$. During training, we freeze the feature network.
To select the best hyper-parameters, we sample 1000 tasks from the validation classes and reuse them at each training epoch. 



\subsubsection{Comparison to state-of-the-art meta-learning methods}
\label{sec:sota}

In Table~\ref{tab:tab-1},
we show a comparison between the state-of-the-art approaches 
and several variants of our method (varying $K$ or $f(\cdot)$).
Apart from SIB, TPN~\citep{liu2018learning} and CTM~\citep{li2019ctm} are also transductive methods.

First of all, comparing SIB ($K=3$) to SIB ($K=0$), 
we observe a clear improvement, 
which suggests that, by taking a few synthetic gradient steps,
we do obtain a better variational posterior as promised.
For 1-shot learning, SIB (when $K=3$ or $K=5$) significantly outperforms previous methods 
on both MiniImageNet and CIFAR-FS. 
For 5-shot learning, the results are also comparable. 
It should be noted that the performance boost is consistently observed 
with different feature networks,
which suggests that SIB is a general method for few-shot learning.

However, we also observe a potential limitation of SIB:
when the support set is relatively large, e.g., 5-shot,
with a good feature network like WRN-28-10,
the initialization $\theta_t^0$ may already be close to some local minimum,
making the updates later less important.

For 5-shot learning, SIB is sligtly worse than CTM~\citep{li2019ctm} and/or \citet{gidaris2019boosting}.
CMT~\citep{li2019ctm} can be seen as an alternative way to incorporate transduction -- 
it measures the similarity between a query example and the support set while making use of intra- and inter-class relationships.  
\citet{gidaris2019boosting} uses in addition the self-supervision as an auxilary loss to learn a richer and more transferable feature model.
Both ideas are complementary to SIB. We leave these extensions to our future work.


\subsection{Zero-shot regression: spinning lines} 


\begin{figure*}[ht]
	\centering
	\begin{minipage}{.32\textwidth}
		\centering
		\includegraphics[width=1.0\linewidth]{./figures/sib_eval.pdf}
	\end{minipage} 
	\hfill
	\begin{minipage}{.32\textwidth}
		\centering
		\includegraphics[width=1.0\linewidth]{./figures/sib_dyn.pdf}
	\end{minipage}
	\hfill
	\begin{minipage}{.32\textwidth}
		\centering
		\includegraphics[width=1.0\linewidth]{./figures/pred_comparison.pdf}
	\end{minipage}
	\caption{\textbf{Left}: the mean-square errors on $D_\text{test}$,
        $\E_t D_\text{KL}(q_{\theta_t^K}(w_t) \| p(w_t|d_t))$, $D_\text{KL}(p_\psi(w) \| p(w))$ and the estimate
        of $I(w; d) \approx \E_t D_\text{KL}(q_{\theta_t^K}(w_t) \| p_\psi(w_t))$.
		\textbf{Middle}: the predicted $y$'s by $y = \theta_t^k x$ for $k = 0,\ldots,4$. \textbf{Right}: the predictions of SIB.}
	\label{fig:toy}
\end{figure*}


Since our variational posterior relies only on $x_t$, SIB is also applicable to zero-shot problems (i.e., no support set available).
We first look at a toy multi-task problem, where $I(w_t; d_t)$ is tractable.

Denote by $D_\text{train} := \{ d_t \}_{t=1}^N$ the train set, which consists of datasets of size $n$: $d = \{ (x_i, y_i) \}_{i=1}^n$.
We construct a dataset $d$ by firstly sampling iid Gaussian random variables as inputs: $x_i \sim \mathcal{N}(\mu, \sigma^2)$.
Then, we generate the weight for each dataset by calculating the mean of the inputs and shifting with a Gaussian random variable $\epsilon_w$:
$
w = \frac{1}{n} \sum_i x_i + \epsilon_w, \, \epsilon_w \sim \mathcal{N}(\mu_w, \sigma_w^2).
$
The output for $x_i$ is $y_i = w \cdot x_i.$
We decide ahead of time the hyperparameters $\mu, \sigma, \mu_w, \sigma_w$ for generating $x_i$ and $y_i$. 
Recall that a weighted sum of iid Gaussian random variables is still a Gaussian random variable.
Specifically, if $w = \sum_i c_i x_i$ and $x_i \sim \mathcal{N}(\mu_i, \sigma_i^2)$, 
then $w \sim \mathcal{N}(\sum_i c_i \mu_i, \sum_i c_i^2 \sigma_i^2)$.
Therefore, we have $p(w) = \mathcal{N}(\mu + \mu_w, \frac{1}{n}\sigma^2 + \sigma_w^2)$.
On the other hand, if we are given a dataset $d$ of size $n$, the only uncertainty about $w$ comes from $\epsilon_w$,
that is, we should consider $x_i$ as a constant given $d$.
Therefore, the posterior $p(w | d) = \mathcal{N}(\frac{1}{n} \sum_{i=1}^n x_i + \mu_w, \sigma_w^2)$.
We use a simple implementation for SIB:
The variational posterior is realized by
    \begin{align}
    \label{eq:toy}
        q_{\theta_t^K}(w) = \mathcal{N}(\theta_t^K, \sigma_w), \,\,
        \theta_t^{k+1} = \theta_t^{k} - 10^{-3} \sum_{i=1}^n x_i \xi(\theta_t^{k} x_i),\,\,\text{and}\,\, \theta_t^0 = \lambda \in \R;
    \end{align}
$\ell_t$ is a mean squared error, implies that $p(y|x,w) = \mathcal{N}(w x, 1)$;
$p_\psi(w)$ is a Gaussian distribution with parameters $\psi \in \R^2$;
The synthetic gradient network $\xi$ is a three-layer MLP with hidden size $8$.

In the experiment, we sample $240$ tasks respectively for both $D_\text{train}$ and $D_\text{test}$.
We learn SIB and BNN on $D_\text{train}$ for $150$ epochs using the ADAM optimizer \citep{kingma2014adam}, with learning rate $10^{-3}$
and batch size $8$.
Other hyperparameters are specified as follows:
$n = 32, K=3, \mu=0, \sigma=1, \mu_w=1, \sigma_w=0.1.$
The results are shown in Figure~\ref{fig:toy}. On the left, both 
$D_\text{KL}(q_{\theta_t^K}(w_t) \| p(w_t|d_t))$ and $D_\text{KL}(p_\psi(w) \| p(w))$ are close to zero
indicating the success of the learning. 
More interestingly, in the middle, we see that $\theta_t^0, \theta_t^1, \ldots, \theta_t^4$ evolves gradually towards the ground truth,
which suggests that the synthetic gradient network is able to identify the descent direction after meta-learning.





 

\section{Conclusion}

We have presented an empirical Bayesian framework for meta-learning. 
To enable an efficient variational inference, we followed the amortized inference paradigm,
and proposed to use a transductive scheme for constructing the variational posterior.
To implement the transductive inference, we make use of two neural networks:
a synthetic gradient network and an initialization network,
which together enables a synthetic gradient descent on the unlabeled data 
to generate the parameters of the amortized variational posterior dynamically.
We have studied the theoretical properties of the proposed framework 
and shown that it yields performance boost on MiniImageNet and CIFAR-FS for few-shot classification.





\bibliography{refs}
\bibliographystyle{iclr2020_conference}


\appendix
\section*{Appendix}
\renewcommand{\thesubsection}{\Alph{subsection}}

\subsection{Proofs}

\ebibt
\begin{proof}
    Denote by $q(w | t) := \E_{q(d|t)} q(w | d, t) q(d | t)$ the aggregated posterior of task $t$.
    \eqref{eq:popeb} can be decomposed as
\begin{align}
    &\E_{q(t)} \E_{q(d|t)} \Big[ 
        \E_{q(w|d,t)} \big[ -\log p(d | w, t) \big] + D_\text{KL}\big(q(w | d, t) \| p(w) \big)
    \Big] \\ 
    &= \E_{q(t)} \E_{q(d|t)} \E_{q(w|d,t)} \Big[ \log \frac{q(w | d, t)q(w | t)}{p(d | w, t) p(w) q(w | t)} \Big] \\
    &= \E_{q(t)} \E_{q(d|t)} \E_{q(w|d,t)} \Big[ \log \frac{q(w | d, t)}{q(w | t)} \Big] 
    + \E_{q(t)} \E_{q(d|t)} \E_{q(w|d,t)} \Big[ -\log p(d | w, t) \Big] \notag \\
    &\quad + \E_{q(t)} \E_{q(d|t)} \E_{q(w|d,t)} \Big[ \log \frac{q(w | t)}{p(w)} \Big] \\
    &= I_q(w; d | t) + H_{q,p}(d | w, t) + \E_{q(t)} D_\text{KL}(q(w|t) \| p(w)) \\
    &\geq I_q(w; d | t) + H_{q,p}(d | w, t) \label{eq:ibt}.
\end{align}
    The inequality is because $D_\text{KL}(q(w|t) \| p(w)) \geq 0$ for all $t$'s.
    Besides, we used the notation $H_{q,p}$, which is the conditional cross entropy. Recall that $D_\text{KL}\big(q(d | w, t) \| p(d | w, t) \big) = -H_q(d | w, t) + H_{q,p}(d | w, t) \geq 0$.
    We attain the lower bound as desired if this inequality is applied to replace $H_{q,p}(d | w, t)$ by $H_q(d | w, t)$.
\end{proof}

The following lemma and theorem show the connection between $I_q(w; d | t)$ and the generalization error.
We first extend \citet[Lemma 4.2]{xu2016information}.
\begin{lemm} 
    \label{thm:subg}
    If, for all $t$, $f_t(X, Y)$ is $\sigma$-subgaussain under $P_X \otimes P_Y$, then 
    \begin{align}
        \Big| \E_{P(T)} \Big[ \E_{P(X,Y | T)} f_T(X, Y) - \E_{P(X | T)P(Y | T)} f_T(X,Y) \Big] \Big|  \leq \sqrt{2\sigma^2 I(X; Y | T)}.
    \end{align}
\end{lemm}
\begin{proof}
    The proof is adapted from the proof of \citet[Lemma 4.2]{xu2016information}.
    \begin{align}
        LHS &\leq \E_{P(T)} \Big| \E_{P(X,Y | T)} f_T(X, Y) - \E_{P(X | T)P(Y | T)} f_T(X,Y) \Big| \\
        &\leq \E_{P(T)} \sqrt{2 \sigma^2 D_\text{KL}(P(X,Y|T) \| P(X|T) P(Y|T)) } \\
        &\leq \sqrt{2\sigma^2 \E_{P(T)} D_\text{KL}(P(X,Y|T) \| P(X|T) P(Y|T))} \\
        &= \sqrt{2\sigma^2 I(X;Y|T)}.
    \end{align}
    The second inequality was due to the Donsker-Varadhan variational representation of KL divergence and the definition of subgaussain random variable.
\end{proof}

\genmi
\begin{proof}
    First, if $\ell_t(\hat{y}(f(x),w), y)$ is $\sigma$-subgaussian under $q(w|t)q(z|t)$, by definition,
    \begin{align}
        \E_{q(w|t)q(z|t)} \exp({\lambda \ell_t(w, z)}) \leq \exp({\lambda \E_{q(w|t)q(z|t)} \ell_t(w,z)}) \exp({\lambda^2 \sigma^2/2})
    \end{align}
    It is straightforward to show $L_t(w, d)$ is $\sigma/\sqrt{n}$-subgaussian since
    \begin{align}
        \E_{q(w|t)q(d|t)} \exp({\lambda L_t(w, d)}) &= \prod_{i=1}^n \E_{w,z_i} \exp(\frac{\lambda}{n} \ell_t(w, z_i)) \\
        &\leq \prod_{i=1}^n \exp\Big( \frac{\lambda}{n} \E_{w, z_i} \ell_t(w, z_i) + \frac{\lambda^2 \sigma^2}{2n^2} \Big) \\
        &= \exp\Big( \lambda \E_{w, z} \ell_t(w, z) \Big) \exp(\frac{\lambda^2 \sigma^2}{2n}) \\
        &= \exp\Big( \lambda \E_{q(w|t) q(d|t)} L_t(w, d) \Big) \exp(\frac{\lambda^2 (\sigma/\sqrt{n})^2}{2}).
    \end{align}
    By Lemma~\ref{thm:subg}, we have
    \begin{align}
        \big| \text{gen}(q) \big| &= \Big| \E_{q(t)} \Big[ \E_{q(w|d , t)q(d|t)} L_t(w, d) - \E_{q(w|t)q(d|t)} L_t(w,d) \Big] \Big| \\
        &\leq \sqrt{\frac{2\sigma^2}{n} I(w; d | t)}
    \end{align}
    as desired.
\end{proof}






\subsection{Zero-shot classification: unsupervised multi-source domain adaptation}

\begin{table}[t]
\centering
\footnotesize
\scalebox{0.9}{
\begin{tabular}{ p{5cm} c c c c c }
\toprule
    Method & Art & Cartoon & Sketch & Photo & Average \\
\midrule
    JiGen~\citep{carlucci2019domain} & 84.9\%  & 81.1\% & 79.1\% & 98.0\% & 85.7\% \\
    Rot~\citep{xu2019self} & 88.7\% & 86.4\% & 74.9\% & 98.0\% & 87.0\% \\ 
    \hline
    \rowcolor[gray]{.9} SIB-Rot $K=0$ & 85.7\% & 	86.6\% & 	80.3\% & 	98.3\% & 	87.7\% \\
    \rowcolor[gray]{.9} SIB-Rot $K=3$ & \textbf{88.9\%} & \textbf{89.0\%} & \textbf{82.2\%} & \textbf{98.3\%} & \textbf{89.6\%} \\
\bottomrule
\end{tabular}
}
\caption{Multi-source domain adaptation results on PACS with ResNet-18 features.
Three domains are used as the source domains keeping the fourth one as target.}
\label{tab:uda}
\end{table}


A more interesting zero-shot multi-task problem is unsupervised domain adaptation.
We consider the case where there exists multiple source domains and a unlabeled target domain.
In this case, we treat each minibatch as a task. This makes sense because the difference in statistics between two minibatches 
are much larger than in the traditional supervised learning.
The experimental setup is similar to few-shot classification described in Section~\ref{sec:few},
except that we do not have a support set and the class labels between two tasks are the same.
Hence, it is possible to explore the relationship between class labels and \emph{self-supervised} labels to implement 
the initialization network $\lambda$ without resorting to support set.
We reuse the same model implementation for SIB as described in Section~\ref{sec:few}. The only difference is the initialization network.
Denote by $z_t := \{ z_{t,i} \}_{i=1}^n$ the set of self-supervised labels of task $t$, 
the initialization network $\lambda$ is implemented as follows:
\begin{align}
    \label{eq:ssup}
    \theta_t^0 = \lambda - \eta \, \nabla_{\theta} L_t\Big( \hat{z}_t\big( \hat{y}_t(f(x_t), w_t(\theta, \epsilon)), f(x_t)\big), z_t \Big),
\end{align}
where $\lambda$\footnote{$\lambda$ is overloaded to be both the network and its parameters.} 
is a global initialization similar to the one used by MAML; 
$L_t$ is the self-supervised loss, $\hat{z}_t$ is the set of predictions of the self-supervised labels. 
One may argue that $\theta_t^0 = \lambda$ would be a simpler solution. 
However, it is insufficient since the gap between two domains can be very large.
The initial solution yielded by \eqref{eq:ssup} is more dynamic in the sense that 
$\theta_t^0$ is adapted taking into account the information from $x_t$.

In terms of experiments, we test SIB on the PACS dataset \citep{li2017deeper},
which has 7 object categories and 4 domains (Photo, Art Paintings, Cartoon and Sketches),
and compare with state-of-the-art algorithms
for unsupervised domain adaptation. 
We follow the standard experimental setting \citep{carlucci2019domain}, where 
the feature network is implemented by ResNet-18. 
We assign a self-supervised label $z_{t,i}$ to image $i$ by rotating the image
by a predicted degree. This idea was originally proposed by \citet{gidaris2018unsupervised} for representation learning
and adopted by \citet{xu2019self} for domain adaptation.
The training is done by running ADAM for $60$ epochs with learning rate $10^{-4}$.
We take each domain in turns as the target domain. The results are shown in Table~\ref{tab:uda}.
It can be seen that SIB-Rot ($K=3$) improves upon the baseline SIB-Rot ($K=0$) for zero-shot classification,
which also outperforms state-of-the-art methods when the baseline is comparable.



\subsection{Importance of synthetic gradients}
To further verify the effectiveness of the synthetic gradient descent,
we implement an inductive version of SIB inspired by MAML,
where the initialization $\theta_t^0$ is generated exactly the same way as SIB using $\lambda(d_t^\supp)$,
but it then follows the iterations in \eqref{eq:maml} as in MAML rather than follows the iterations in \eqref{eq:sib}
as in standard SIB.

We conduct an experiment on CIFAR-FS using Conv-4-64 feature network.
The results are shown in Table~\ref{tab:tab-2}.
It can be seen that there is no improvement over SIB ($K=0$) 
suggesting that the inductive approach is insufficient.

\label{sec:cifar}
\begin{table}[ht]
\centering
\footnotesize
\begin{tabular}{ c c | c c | c c | c c}
\toprule
 & & \multicolumn{2}{c|}{\textbf{inductive SIB}} & \multicolumn{4}{c}{\textbf{SIB}} \\
 & & \multicolumn{2}{c|}{\textbf{Training on 1-shot}} & \multicolumn{2}{c|}{\textbf{Training on 1-shot}} & \multicolumn{2}{c}{\textbf{Training on 5-shot}} \\
 & & \multicolumn{2}{c|}{\textbf{Testing on}} & \multicolumn{2}{c|}{\textbf{Testing on}} & \multicolumn{2}{c}{\textbf{Testing on}} \\
  $K$ & $\eta$ & 1-shot & 5-shot & 1-shot & 5-shot & 1-shot & 5-shot \\
\midrule
0 & - & 59.7$\pm$0.5\% & 75.5$\pm$0.4\% & 59.2$\pm$0.5\% & 75.4$\pm$0.4\% & 59.2$\pm$0.5\% & 75.4$\pm$0.4\% \\\hdashline

1 & 1e-1 & 59.8$\pm$0.5\% & 71.2$\pm$0.4\% & 65.3$\pm$0.6\% & 75.8$\pm$0.4\% & 64.5$\pm$0.6\% & 77.3$\pm$0.4\% \\
3 & 1e-1 & 59.6$\pm$0.5\% & 75.9$\pm$0.4\% & 65.0$\pm$0.6\% & 75.0$\pm$0.4\% & 64.0$\pm$0.6\% & 77.0$\pm$0.4\% \\
5 & 1e-1 & 59.9$\pm$0.5\% & 74.9$\pm$0.4\% & 66.0$\pm$0.6\% & 76.3$\pm$0.4\% & 64.0$\pm$0.5\% & 76.8$\pm$0.4\% \\\hdashline

1 & 1e-2 & 59.7$\pm$0.5\% & 75.5$\pm$0.4\% & 67.8$\pm$0.6\% & 74.3$\pm$0.4\% &  63.6$\pm$0.6\%& 77.3$\pm$0.4\% \\
3 & 1e-2 & 59.5$\pm$0.5\% & 75.8$\pm$0.4\% & 68.6$\pm$0.6\% & 77.4$\pm$0.4\% & 67.8$\pm$0.6\% & 78.5$\pm$0.4\% \\
5 & 1e-2 & 59.8$\pm$0.5\% & 75.7$\pm$0.4\% & 67.4$\pm$0.6\% & 72.6$\pm$0.6\% & 67.7$\pm$0.7\% & 77.7$\pm$0.4\% \\\hdashline

1 & 1e-3 & 59.5$\pm$0.5\% & 75.6$\pm$0.4\% & 66.2$\pm$0.6\% & 75.7$\pm$0.4\% & 64.6$\pm$0.6\% & 78.1$\pm$0.4\% \\
3 & 1e-3 & 59.9$\pm$0.5\% & 75.9$\pm$0.4\% & 68.7$\pm$0.6\% & 77.1$\pm$0.4\% & 66.8$\pm$0.6\% & 78.4$\pm$0.4\% \\
5 & 1e-3 & 59.4$\pm$0.5\% & 75.7$\pm$0.4\% & 69.1$\pm$0.6\% & 76.7$\pm$0.4\% & 66.7$\pm$0.6\% & 78.5$\pm$0.4\% \\\hdashline

1 & 1e-4 & 58.8$\pm$0.5\% & 75.5$\pm$0.4\% & 59.0$\pm$0.5\% & 75.7$\pm$0.4\% & 59.3$\pm$0.5\% & 75.7$\pm$0.4\% \\
3 & 1e-4 & 59.4$\pm$0.5\% & 75.9$\pm$0.4\% & 58.9$\pm$0.5\% & 75.6$\pm$0.4\% & 59.3$\pm$0.5\% & 75.9$\pm$0.4\% \\
5 & 1e-4 & 59.3$\pm$0.5\% & 75.3$\pm$0.4\% & 60.1$\pm$0.5\% & 76.0$\pm$0.4\% & 60.5$\pm$0.5\% & 76.4$\pm$0.4\% \\
\bottomrule
\end{tabular}
\caption{Average 5-way classification accuracies (with 95\% confidence intervals) with Conv-4-64 on the test set of CIFAR-FS. For each test, we sample 5000 episodes containing 5 categories (5-way) and 15 queries in each category. We report the results with using different learning rate $\eta$ as well as  different number of updates $K$. Note that $K=0$ is the performance only using the pre-trained feature. }
\label{tab:tab-2}
\end{table}


\subsection{Varying the size of the query set}
\label{sec:varyn}
We notice that changing the size of $d_t$ (i.e., $n$) 
during training does make a difference on testing.
The results are shown in Table~\ref{tab:abn}.

\begin{table}[ht]
    \centering
    \footnotesize
    \begin{tabular}{ l| r r |r r }
    \toprule
    \multicolumn{1}{l|}{\multirow{ 2}{*}{$n$} } & \multicolumn{2}{c|}{5-way, 5-shot} & \multicolumn{2}{c}{5-way, 1-shot}\\
     & Validation & Test & Validation & Test \\
    \midrule
    3 & 77.97 $\pm$ 0.34\% & 75.91 $\pm$ 0.66\% & 63.60 $\pm$ 0.52\% & 61.32 $\pm$ 1.02\% \\
    5 & 78.14 $\pm$ 0.35\% & 76.01 $\pm$ 0.66\% & 64.67 $\pm$ 0.55\% & 62.50 $\pm$ 1.02\% \\
    10 & \textbf{78.30 $\pm$ 0.35\%} & \textbf{76.22 $\pm$ 0.66\%} & \textbf{65.34 $\pm$ 0.56\%} & \textbf{63.22 $\pm$ 1.04\%} \\
    15 & 77.53 $\pm$ 0.35\% & 75.43 $\pm$ 0.67\% & 65.14 $\pm$ 0.55\% & 62.59 $\pm$ 1.02\% \\
    30 & 76.21 $\pm$ 0.35\% & 74.04 $\pm$ 0.67\% & 63.37 $\pm$ 0.53\% & 60.96 $\pm$ 0.98\% \\
    45 & 75.65 $\pm$ 0.36\% & 73.27 $\pm$ 0.66\% & 62.08 $\pm$ 0.51\% & 59.59 $\pm$ 0.93\% \\
    \bottomrule
    \end{tabular}
    \caption{Average classification accuracies on the validation set and the test set of Mini-ImageNet
    with backbone Conv-4-128. We modify the number of query images, i.e., $n$, for each episode to study the effect on generalization.}
    \label{tab:abn}
\end{table}
 
\end{document}
