
\documentclass{article} \usepackage{iclr2020_conference,times}

\iclrfinalcopy


\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{subcaption}
\usepackage{graphicx}
\usepackage{amsmath,amsfonts,bm}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{natbib}
\usepackage{multirow}
\usepackage{xcolor}
\usepackage{mathtools, nccmath}
\usepackage[shortlabels]{enumitem}
\usepackage{colortbl}
\usepackage{arydshln}


\usepackage{pifont}
\newcommand{\chk}{{\centering\checkmark}}
\newcommand{\xmark}{\ding{55}}
\newcommand{\crs}{{\centering\xmark}}

\newcommand{\figleft}{{\em (Left)}}
\newcommand{\figcenter}{{\em (Center)}}
\newcommand{\figright}{{\em (Right)}}
\newcommand{\figtop}{{\em (Top)}}
\newcommand{\figbottom}{{\em (Bottom)}}
\newcommand{\captiona}{{\em (a)}}
\newcommand{\captionb}{{\em (b)}}
\newcommand{\captionc}{{\em (c)}}
\newcommand{\captiond}{{\em (d)}}

\newcommand{\newterm}[1]{{\bf #1}}

\newcommand{\zT}{z_{\mathcal{T}}}
\newcommand{\aT}{a_{\mathcal{T}}}
\newcommand{\zS}{z_{\mathcal{S}}}

\def\figref#1{figure~\ref{#1}}
\def\Figref#1{Figure~\ref{#1}}
\def\twofigref#1#2{figures \ref{#1} and \ref{#2}}
\def\quadfigref#1#2#3#4{figures \ref{#1}, \ref{#2}, \ref{#3} and \ref{#4}}
\def\secref#1{section~\ref{#1}}
\def\Secref#1{Section~\ref{#1}}
\def\twosecrefs#1#2{sections \ref{#1} and \ref{#2}}
\def\secrefs#1#2#3{sections \ref{#1}, \ref{#2} and \ref{#3}}
\def\eqref#1{(\ref{#1})}
\def\Eqref#1{~(\ref{#1})}
\def\plaineqref#1{\ref{#1}}
\def\chapref#1{chapter~\ref{#1}}
\def\Chapref#1{Chapter~\ref{#1}}
\def\rangechapref#1#2{chapters\ref{#1}--\ref{#2}}
\def\algref#1{algorithm~\ref{#1}}
\def\Algref#1{Algorithm~\ref{#1}}
\def\twoalgref#1#2{algorithms \ref{#1} and \ref{#2}}
\def\Twoalgref#1#2{Algorithms \ref{#1} and \ref{#2}}
\def\partref#1{part~\ref{#1}}
\def\Partref#1{Part~\ref{#1}}
\def\twopartref#1#2{parts \ref{#1} and \ref{#2}}

\def\ceil#1{\lceil #1 \rceil}
\def\floor#1{\lfloor #1 \rfloor}
\def\1{\bm{1}}
\newcommand{\train}{\mathcal{D}}
\newcommand{\valid}{\mathcal{D_{\mathrm{valid}}}}
\newcommand{\test}{\mathcal{D_{\mathrm{test}}}}

\def\eps{{\epsilon}}


\def\reta{{\textnormal{}}}
\def\ra{{\textnormal{a}}}
\def\rb{{\textnormal{b}}}
\def\rc{{\textnormal{c}}}
\def\rd{{d}}
\def\re{{\textnormal{e}}}
\def\rf{{\textnormal{f}}}
\def\rg{{\textnormal{g}}}
\def\rh{{\textnormal{h}}}
\def\ri{{\textnormal{i}}}
\def\rj{{\textnormal{j}}}
\def\rk{{\textnormal{k}}}
\def\rl{{\textnormal{l}}}
\def\rn{{\textnormal{n}}}
\def\ro{{\textnormal{o}}}
\def\rp{{\textnormal{p}}}
\def\rq{{\textnormal{q}}}
\def\rr{{\textnormal{r}}}
\def\rs{{\textnormal{s}}}
\def\rt{{\textnormal{t}}}
\def\ru{{\textnormal{u}}}
\def\rv{{\textnormal{v}}}
\def\rw{{w}}
\def\rx{{\textnormal{x}}}
\def\ry{{\textnormal{y}}}
\def\rz{{\textnormal{z}}}

\def\rvepsilon{{\mathbf{\epsilon}}}
\def\rvtheta{{\mathbf{\theta}}}
\def\rva{{\mathbf{a}}}
\def\rvb{{\mathbf{b}}}
\def\rvc{{\mathbf{c}}}
\def\rvd{{\mathbf{d}}}
\def\rve{{\mathbf{e}}}
\def\rvf{{\mathbf{f}}}
\def\rvg{{\mathbf{g}}}
\def\rvh{{\mathbf{h}}}
\def\rvu{{\mathbf{i}}}
\def\rvj{{\mathbf{j}}}
\def\rvk{{\mathbf{k}}}
\def\rvl{{\mathbf{l}}}
\def\rvm{{\mathbf{m}}}
\def\rvn{{\mathbf{n}}}
\def\rvo{{\mathbf{o}}}
\def\rvp{{\mathbf{p}}}
\def\rvq{{\mathbf{q}}}
\def\rvr{{\mathbf{r}}}
\def\rvs{{\mathbf{s}}}
\def\rvt{{\mathbf{t}}}
\def\rvu{{\mathbf{u}}}
\def\rvv{{\mathbf{v}}}
\def\rvw{{\mathbf{w}}}
\def\rvx{{\mathbf{x}}}
\def\rvy{{\mathbf{y}}}
\def\rvz{{\mathbf{z}}}

\def\erva{{\textnormal{a}}}
\def\ervb{{\textnormal{b}}}
\def\ervc{{\textnormal{c}}}
\def\ervd{{\textnormal{d}}}
\def\erve{{\textnormal{e}}}
\def\ervf{{\textnormal{f}}}
\def\ervg{{\textnormal{g}}}
\def\ervh{{\textnormal{h}}}
\def\ervi{{\textnormal{i}}}
\def\ervj{{\textnormal{j}}}
\def\ervk{{\textnormal{k}}}
\def\ervl{{\textnormal{l}}}
\def\ervm{{\textnormal{m}}}
\def\ervn{{\textnormal{n}}}
\def\ervo{{\textnormal{o}}}
\def\ervp{{\textnormal{p}}}
\def\ervq{{\textnormal{q}}}
\def\ervr{{\textnormal{r}}}
\def\ervs{{\textnormal{s}}}
\def\ervt{{\textnormal{t}}}
\def\ervu{{\textnormal{u}}}
\def\ervv{{\textnormal{v}}}
\def\ervw{{\textnormal{w}}}
\def\ervx{{\textnormal{x}}}
\def\ervy{{\textnormal{y}}}
\def\ervz{{\textnormal{z}}}

\def\rmA{{\mathbf{A}}}
\def\rmB{{\mathbf{B}}}
\def\rmC{{\mathbf{C}}}
\def\rmD{{\mathbf{D}}}
\def\rmE{{\mathbf{E}}}
\def\rmF{{\mathbf{F}}}
\def\rmG{{\mathbf{G}}}
\def\rmH{{\mathbf{H}}}
\def\rmI{{\mathbf{I}}}
\def\rmJ{{\mathbf{J}}}
\def\rmK{{\mathbf{K}}}
\def\rmL{{\mathbf{L}}}
\def\rmM{{\mathbf{M}}}
\def\rmN{{\mathbf{N}}}
\def\rmO{{\mathbf{O}}}
\def\rmP{{\mathbf{P}}}
\def\rmQ{{\mathbf{Q}}}
\def\rmR{{\mathbf{R}}}
\def\rmS{{\mathbf{S}}}
\def\rmT{{\mathbf{T}}}
\def\rmU{{\mathbf{U}}}
\def\rmV{{\mathbf{V}}}
\def\rmW{{\mathbf{W}}}
\def\rmX{{\mathbf{X}}}
\def\rmY{{\mathbf{Y}}}
\def\rmZ{{\mathbf{Z}}}

\def\ermA{{\textnormal{A}}}
\def\ermB{{\textnormal{B}}}
\def\ermC{{\textnormal{C}}}
\def\ermD{{\textnormal{D}}}
\def\ermE{{\textnormal{E}}}
\def\ermF{{\textnormal{F}}}
\def\ermG{{\textnormal{G}}}
\def\ermH{{\textnormal{H}}}
\def\ermI{{\textnormal{I}}}
\def\ermJ{{\textnormal{J}}}
\def\ermK{{\textnormal{K}}}
\def\ermL{{\textnormal{L}}}
\def\ermM{{\textnormal{M}}}
\def\ermN{{\textnormal{N}}}
\def\ermO{{\textnormal{O}}}
\def\ermP{{\textnormal{P}}}
\def\ermQ{{\textnormal{Q}}}
\def\ermR{{\textnormal{R}}}
\def\ermS{{\textnormal{S}}}
\def\ermT{{\textnormal{T}}}
\def\ermU{{\textnormal{U}}}
\def\ermV{{\textnormal{V}}}
\def\ermW{{\textnormal{W}}}
\def\ermX{{\textnormal{X}}}
\def\ermY{{\textnormal{Y}}}
\def\ermZ{{\textnormal{Z}}}

\def\vzero{{\bm{0}}}
\def\vone{{\bm{1}}}
\def\vmu{{\bm{\mu}}}
\def\vtheta{{\bm{\theta}}}
\def\va{{\bm{a}}}
\def\vb{{\bm{b}}}
\def\vc{{\bm{c}}}
\def\vd{{\bm{d}}}
\def\ve{{\bm{e}}}
\def\vf{{\bm{f}}}
\def\vg{{\bm{g}}}
\def\vh{{\bm{h}}}
\def\vi{{\bm{i}}}
\def\vj{{\bm{j}}}
\def\vk{{\bm{k}}}
\def\vl{{\bm{l}}}
\def\vm{{\bm{m}}}
\def\vn{{\bm{n}}}
\def\vo{{\bm{o}}}
\def\vp{{\bm{p}}}
\def\vq{{\bm{q}}}
\def\vr{{\bm{r}}}
\def\vs{{\bm{s}}}
\def\vt{{\bm{t}}}
\def\vu{{\bm{u}}}
\def\vv{{\bm{v}}}
\def\vw{{\bm{w}}}
\def\vx{{\bm{x}}}
\def\vy{{\bm{y}}}
\def\vz{{\bm{z}}}

\def\evalpha{{\alpha}}
\def\evbeta{{\beta}}
\def\evepsilon{{\epsilon}}
\def\evlambda{{\lambda}}
\def\evomega{{\omega}}
\def\evmu{{\mu}}
\def\evpsi{{\psi}}
\def\evsigma{{\sigma}}
\def\evtheta{{\theta}}
\def\eva{{a}}
\def\evb{{b}}
\def\evc{{c}}
\def\evd{{d}}
\def\eve{{e}}
\def\evf{{f}}
\def\evg{{g}}
\def\evh{{h}}
\def\evi{{i}}
\def\evj{{j}}
\def\evk{{k}}
\def\evl{{l}}
\def\evm{{m}}
\def\evn{{n}}
\def\evo{{o}}
\def\evp{{p}}
\def\evq{{q}}
\def\evr{{r}}
\def\evs{{s}}
\def\evt{{t}}
\def\evu{{u}}
\def\evv{{v}}
\def\evw{{w}}
\def\evx{{x}}
\def\evy{{y}}
\def\evz{{z}}

\def\mA{{\bm{A}}}
\def\mB{{\bm{B}}}
\def\mC{{\bm{C}}}
\def\mD{{\bm{D}}}
\def\mE{{\bm{E}}}
\def\mF{{\bm{F}}}
\def\mG{{\bm{G}}}
\def\mH{{\bm{H}}}
\def\mI{{\bm{I}}}
\def\mJ{{\bm{J}}}
\def\mK{{\bm{K}}}
\def\mL{{\bm{L}}}
\def\mM{{\bm{M}}}
\def\mN{{\bm{N}}}
\def\mO{{\bm{O}}}
\def\mP{{\bm{P}}}
\def\mQ{{\bm{Q}}}
\def\mR{{\bm{R}}}
\def\mS{{\bm{S}}}
\def\mT{{\bm{T}}}
\def\mU{{\bm{U}}}
\def\mV{{\bm{V}}}
\def\mW{{\bm{W}}}
\def\mX{{\bm{X}}}
\def\mY{{\bm{Y}}}
\def\mZ{{\bm{Z}}}
\def\mBeta{{\bm{\beta}}}
\def\mPhi{{\bm{\Phi}}}
\def\mLambda{{\bm{\Lambda}}}
\def\mSigma{{\bm{\Sigma}}}

\DeclareMathAlphabet{\mathsfit}{\encodingdefault}{\sfdefault}{m}{sl}
\SetMathAlphabet{\mathsfit}{bold}{\encodingdefault}{\sfdefault}{bx}{n}
\newcommand{\tens}[1]{\bm{\mathsfit{#1}}}
\def\tA{{\tens{A}}}
\def\tB{{\tens{B}}}
\def\tC{{\tens{C}}}
\def\tD{{\tens{D}}}
\def\tE{{\tens{E}}}
\def\tF{{\tens{F}}}
\def\tG{{\tens{G}}}
\def\tH{{\tens{H}}}
\def\tI{{\tens{I}}}
\def\tJ{{\tens{J}}}
\def\tK{{\tens{K}}}
\def\tL{{\tens{L}}}
\def\tM{{\tens{M}}}
\def\tN{{\tens{N}}}
\def\tO{{\tens{O}}}
\def\tP{{\tens{P}}}
\def\tQ{{\tens{Q}}}
\def\tR{{\tens{R}}}
\def\tS{{\tens{S}}}
\def\tT{{\tens{T}}}
\def\tU{{\tens{U}}}
\def\tV{{\tens{V}}}
\def\tW{{\tens{W}}}
\def\tX{{\tens{X}}}
\def\tY{{\tens{Y}}}
\def\tZ{{\tens{Z}}}


\def\gA{{\mathcal{A}}}
\def\gB{{\mathcal{B}}}
\def\gC{{\mathcal{C}}}
\def\gD{{\mathcal{D}}}
\def\gE{{\mathcal{E}}}
\def\gF{{\mathcal{F}}}
\def\gG{{\mathcal{G}}}
\def\gH{{\mathcal{H}}}
\def\gI{{\mathcal{I}}}
\def\gJ{{\mathcal{J}}}
\def\gK{{\mathcal{K}}}
\def\gL{{\mathcal{L}}}
\def\gM{{\mathcal{M}}}
\def\gN{{\mathcal{N}}}
\def\gO{{\mathcal{O}}}
\def\gP{{\mathcal{P}}}
\def\gQ{{\mathcal{Q}}}
\def\gR{{\mathcal{R}}}
\def\gS{{\mathcal{S}}}
\def\gT{{\mathcal{T}}}
\def\gU{{\mathcal{U}}}
\def\gV{{\mathcal{V}}}
\def\gW{{\mathcal{W}}}
\def\gX{{\mathcal{X}}}
\def\gY{{\mathcal{Y}}}
\def\gZ{{\mathcal{Z}}}

\def\sA{{\mathbb{A}}}
\def\sB{{\mathbb{B}}}
\def\sC{{\mathbb{C}}}
\def\sD{{\mathbb{D}}}
\def\sF{{\mathbb{F}}}
\def\sG{{\mathbb{G}}}
\def\sH{{\mathbb{H}}}
\def\sI{{\mathbb{I}}}
\def\sJ{{\mathbb{J}}}
\def\sK{{\mathbb{K}}}
\def\sL{{\mathbb{L}}}
\def\sM{{\mathbb{M}}}
\def\sN{{\mathbb{N}}}
\def\sO{{\mathbb{O}}}
\def\sP{{\mathbb{P}}}
\def\sQ{{\mathbb{Q}}}
\def\sR{{\mathbb{R}}}
\def\sS{{\mathbb{S}}}
\def\sT{{\mathbb{T}}}
\def\sU{{\mathbb{U}}}
\def\sV{{\mathbb{V}}}
\def\sW{{\mathbb{W}}}
\def\sX{{\mathbb{X}}}
\def\sY{{\mathbb{Y}}}
\def\sZ{{\mathbb{Z}}}

\def\emLambda{{\Lambda}}
\def\emA{{A}}
\def\emB{{B}}
\def\emC{{C}}
\def\emD{{D}}
\def\emE{{E}}
\def\emF{{F}}
\def\emG{{G}}
\def\emH{{H}}
\def\emI{{I}}
\def\emJ{{J}}
\def\emK{{K}}
\def\emL{{L}}
\def\emM{{M}}
\def\emN{{N}}
\def\emO{{O}}
\def\emP{{P}}
\def\emQ{{Q}}
\def\emR{{R}}
\def\emS{{S}}
\def\emT{{T}}
\def\emU{{U}}
\def\emV{{V}}
\def\emW{{W}}
\def\emX{{X}}
\def\emY{{Y}}
\def\emZ{{Z}}
\def\emSigma{{\Sigma}}

\newcommand{\etens}[1]{\mathsfit{#1}}
\def\etLambda{{\etens{\Lambda}}}
\def\etA{{\etens{A}}}
\def\etB{{\etens{B}}}
\def\etC{{\etens{C}}}
\def\etD{{\etens{D}}}
\def\etE{{\etens{E}}}
\def\etF{{\etens{F}}}
\def\etG{{\etens{G}}}
\def\etH{{\etens{H}}}
\def\etI{{\etens{I}}}
\def\etJ{{\etens{J}}}
\def\etK{{\etens{K}}}
\def\etL{{\etens{L}}}
\def\etM{{\etens{M}}}
\def\etN{{\etens{N}}}
\def\etO{{\etens{O}}}
\def\etP{{\etens{P}}}
\def\etQ{{\etens{Q}}}
\def\etR{{\etens{R}}}
\def\etS{{\etens{S}}}
\def\etT{{\etens{T}}}
\def\etU{{\etens{U}}}
\def\etV{{\etens{V}}}
\def\etW{{\etens{W}}}
\def\etX{{\etens{X}}}
\def\etY{{\etens{Y}}}
\def\etZ{{\etens{Z}}}

\newcommand{\pdata}{p_{\rm{data}}}
\newcommand{\ptrain}{\hat{p}_{\rm{data}}}
\newcommand{\Ptrain}{\hat{P}_{\rm{data}}}
\newcommand{\pmodel}{p_{\rm{model}}}
\newcommand{\Pmodel}{P_{\rm{model}}}
\newcommand{\ptildemodel}{\tilde{p}_{\rm{model}}}
\newcommand{\pencode}{p_{\rm{encoder}}}
\newcommand{\pdecode}{p_{\rm{decoder}}}
\newcommand{\precons}{p_{\rm{reconstruct}}}

\newcommand{\laplace}{\mathrm{Laplace}} 

\newcommand{\E}{\mathbb{E}}
\newcommand{\Ls}{\mathcal{L}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\emp}{\tilde{p}}
\newcommand{\lr}{\alpha}
\newcommand{\reg}{\lambda}
\newcommand{\rect}{\mathrm{rectifier}}
\newcommand{\softmax}{\mathrm{softmax}}
\newcommand{\sigmoid}{\sigma}
\newcommand{\softplus}{\zeta}
\newcommand{\KL}{D_{\mathrm{KL}}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\standarderror}{\mathrm{SE}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\normlzero}{L^0}
\newcommand{\normlone}{L^1}
\newcommand{\normltwo}{L^2}
\newcommand{\normlp}{L^p}
\newcommand{\normmax}{L^\infty}

\newcommand{\parents}{Pa} 

\newcommand{\CI}{\perp\!\!\!\perp}

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Tr}{Tr}
\let\ab\allowbreak
 
\usepackage{thmtools}
\usepackage{thm-restate}

\newtheorem{defi}{Definition}
\newtheorem{thm}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{fact}{Fact}
\newtheorem{remark}{Remark}
\newtheorem{lemm}{Lemma}
\newtheorem{coro}{Corollary}

\newtheorem{innercustomthm}{Proposition}
\newenvironment{customprop}[1]
  {\renewcommand\theinnercustomthm{#1}\innercustomthm}
  {\endinnercustomthm}

\newtheorem{innercustomlemma}{Lemma}
\newenvironment{customlemma}[1]
  {\renewcommand\theinnercustomlemma{#1}\innercustomlemma}
  {\endinnercustomlemma}

\newtheorem{innercustomcoro}{Corollary}
\newenvironment{customcoro}[1]
  {\renewcommand\theinnercustomcoro{#1}\innercustomcoro}
  {\endinnercustomcoro}



\newcommand{\nt}{n}
\newcommand{\supp}{l}
\definecolor{green3}{rgb}{0,0.6,0}
\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}\PackageWarning{TODO:}{#1!}}
\newcommand{\yang}[1]{\textcolor{blue}{Yang: #1}}
\newcommand{\shell}[1]{\textcolor{orange}{Shell: #1}}
\newcommand{\PGM}[1]{\textcolor{green3}{Pablo: #1}}
\newcommand{\GO}[1]{\textcolor{green3}{Guillaume: #1}}
\newcommand{\AD}[1]{\textcolor{green3}{Andreas: #1}}

\title{Empirical Bayes Transductive Meta-Learning with Synthetic Gradients}



\author{
  Shell Xu Hu \,\, Pablo G. Moreno \,\, Yang Xiao \,\, Xi Shen \\
  \hspace{0.03mm} \textbf{Guillaume Obozinski \,\, Neil D. Lawrence \,\, Andreas Damianou}\\
    \And
  Ã‰cole des Ponts ParisTech \\
  Champs-sur-Marne, France \\
  \texttt{\{xu.hu, yang.xiao, xi.shen\}@enpc.fr} 
    \And
  Amazon \\
  Cambridge, United Kingdom \\
  \texttt{\{morepabl, damianou\}@amazon.com}\\
    \And
  Swiss Data Science Center \\
  Lausanne, Switzerland \\
  \texttt{guillaume.obozinski@epfl.ch}
    \And
  University of Cambridge \\
  Cambridge, United Kingdom \\
  \texttt{ndl21@cam.ac.uk}
}





\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}


\maketitle


\begin{abstract}
We propose a meta-learning approach that learns from multiple tasks in a transductive setting, by leveraging the unlabeled query set in addition to the support set to generate a more powerful model for each task. To develop our framework, we revisit the empirical Bayes formulation for multi-task learning. The evidence lower bound of the marginal log-likelihood of empirical Bayes decomposes as a sum of local KL divergences between the variational posterior and the true posterior on the query set of each task.
    We derive a novel amortized variational inference that couples all the variational posteriors via a meta-model, which consists of a synthetic gradient network and an initialization network. Each variational posterior is derived from synthetic gradient descent to approximate the true posterior on the query set, although where we do not have access to the true gradient.  
Our results on the Mini-ImageNet and CIFAR-FS benchmarks for episodic few-shot classification outperform previous state-of-the-art methods.
    Besides, we conduct two zero-shot learning experiments to further explore the potential of the synthetic gradient.
\end{abstract}


\section{Introduction}




While supervised learning of deep neural networks can achieve or even surpass human-level performance \citep{he2015delving,devlin2018bert},
they can hardly extrapolate the learned knowledge beyond the domain where the supervision is provided.
The problem of solving rapidly a new task
after learning several other similar tasks is called \emph{meta-learning} \citep{schmidhuber1987,bengio1991learning,thrun1998learning}; typically, the data is presented in a two-level hierarchy such that each data point at the higher level is itself a dataset associated with a task,
and the goal is to learn a \emph{meta-model} that generalizes across tasks.
In this paper, we mainly focus on \emph{few-shot learning} \citep{vinyals2016matching}, an instance of meta-learning problems,
where a task  consists of 
a \emph{query set}  serving as the test-set of the task
and a \emph{support set}  serving as the train-set.
In \emph{meta-testing}\footnote{To distinguish from testing and training within a task, meta-testing and meta-training are referred to as testing and training over tasks.}, 
one is given the support set and the inputs of the query set , and asked to predict the labels .
In \emph{meta-training},  is provided as the ground truth.
The setup of few-shot learning is summarized in Table~\ref{tab:fs}.

\begin{table}[ht]
    \centering
	\begin{tabular}{lccc}
    \toprule
        & \multicolumn{1}{c}{\textbf{Support set}} & \multicolumn{2}{c}{\textbf{Query set}} \\
        &  &  &  \\
    \midrule
	    Meta-training & \chk & \chk & \chk \\
	    Meta-testing & \chk & \chk & \crs \\
	\bottomrule
    \end{tabular}
    \caption{The setup of few-shot learning. If task  is used for meta-testing,  is not given to the model.}
\label{tab:fs}
\end{table}

A important distinction to make is whether a task is solved in a \emph{transductive} or \emph{inductive} manner, 
that is, whether  is used. The inductive setting is what was originally proposed by \citet{vinyals2016matching},
in which only  is used to generate a model.
The transductive setting, as an alternative, has the advantage of being able to see partial or all points in  before making predictions.
In fact, \citet{nichol2018first} notice that most of the existing meta-learning methods involve transduction unintentionally
since they use  implicitly via the \emph{batch normalization} \citep{ioffe2015batch}.
Explicit transduction is less explored in meta-learning, the exception is \citet{liu2018learning}, 
who adapted the idea of label propagation \citep{zhu2003semi} from graph-based semi-supervised learning methods.
We take a totally different path that meta-learn the ``gradient'' descent on  without using .


Due to the hierarchical structure of the data, it is natural to formulate meta-learning by 
a \emph{hierarchical Bayes} (HB) model \citep{good1980some,berger1985}, 
or alternatively, an empirical Bayes (EB) model \citep{robbins1985empirical,kucukelbir2014population}. 
The difference is that the latter restricts the learning of meta-parameters to point estimates.
In this paper, we focus on the EB model, as it largely simplifies the training and testing without losing the strength of the HB formulation.

The idea of using HB or EB for meta-learning is not new: \citet{amit2018meta} derive an objective similar to that of HB 
using PAC-Bayesian analysis; \citet{grant2018recasting} show that MAML \citep{finn2017model} can be understood as a EB method;
\citet{ravi2018amortized} consider a HB extension to MAML and compute posteriors via amortized variational inference.
However, unlike our proposal, these methods do not make full use of the unlabeled data in query set. 
Roughly speaking, they construct the variational posterior as a function of the labeled set  without taking advantage of the unlabeled set . 
The situation is similar in gradient based meta-learning methods 
\citep{finn2017model,ravi2016optimization,li2017meta,nichol2018first,flennerhag2019transferring} 
and many other meta-learning methods \citep{vinyals2016matching,snell2017prototypical,gidaris2018dynamic}, 
where the mechanisms used to generate the task-specific parameters 
rely on groundtruth labels, thus, there is no place for the unlabeled set to contribute. 
We argue that this is a suboptimal choice,
which may lead to overfitting when the labeled set is small
and hinder the possibility of zero-shot learning (when the labeled set is not provided).

In this paper, we propose to use synthetic gradient \citep{jaderberg2017decoupled} 
to enable transduction, such that the variational posterior is implemented as a function of the labeled set  and the unlabeled set .
The synthetic gradient is produced by chaining the output of a gradient network into auto-differentiation, 
which yields a surrogate of the inaccessible true gradient.
The optimization process is similar to the inner gradient descent in MAML, but it iterates on the unlabeled  rather than on the labeled ,
since it does not rely on  to compute the true gradient.
The labeled set for generating the model for an unseen task is now optional, which is only used to compute the initialization of model weights in our case. In summary, our main contributions are the following:   
\begin{enumerate}
    \item In section~\ref{sec:model} and section~\ref{sec:alg}, 
        we develop a novel empirical Bayes formulation with transduction for meta-learning.
        To perform amortized variational inference, we propose a parameterization for the variational posterior 
        based on synthetic gradient descent, which incoporates the contextual information from all the inputs of the query set.
    \item In section~\ref{sec:theory}, we show in theory that a transductive variational posterior yields better generalization performance.
        The generalization analysis is done through the connection between empirical Bayes formulation and
        a multitask extension of the information bottleneck principle.
        In light of this, we name our method \emph{synthetic information bottleneck} (SIB).
    \item In section~\ref{sec:exp}, we verify our proposal empirically. 
        Our experimental results demonstrate that our method significantly outperforms the state-of-the-art meta-learning methods 
        on few-shot classification benchmarks under the one-shot setting. 
\end{enumerate}


\begin{figure*}[t]
	\centering
	\begin{minipage}{.28\textwidth}
		\centering
		\includegraphics[width=0.9\linewidth]{./figures/gm_crop2.pdf}\\
        (a) Graphical model of EB
	\end{minipage}
	\hfill
	\begin{minipage}{.35\textwidth}
		\centering
		\includegraphics[width=1.0\linewidth]{./figures/MAML.pdf}\\
        (b) MAML
	\end{minipage} 
	\hfill
	\begin{minipage}{.35\textwidth}
		\centering
		\includegraphics[width=1.0\linewidth]{./figures/SIB2.pdf}\\
        (c) Our method (SIB)
	\end{minipage}
    \caption{\textbf{(a)} The generative and inference processes of the empirical Bayes model 
    are depicted in solid and dashed arrows respectively, 
    where the meta-parameters are denoted by dashed circles due to the point estimates.
    A comparison between MAML \eqref{eq:maml} and our method (SIB) \eqref{eq:sib} is shown in \textbf{(b)} and \textbf{(c)}.
    MAML is an inductive method since, for a task , it first constructs the variational posterior (with parameter ) as a function of the support set ,
    and then test on the unlabeled ; while SIB uses a better variational posterior as a function of both  and :
    it starts from an initialization  generated using , and then yields  by running  synthetic gradient steps on .
    }
\label{fig:intro}
\end{figure*}


 \section{Meta-learning with transductive inference}
\label{sec:model}

The goal of meta-learning is to train a \emph{meta-model} on a collection of tasks,
such that it works well on another disjoint collection of tasks.
Suppose that we are given a collection of  tasks for training. 
The associated data is denoted by . 
In the case of few-shot learning, 
we are given in addition a support set  in each task. 
In this section, we revisit the classical empirical Bayes model for meta-learning. Then, 
we propose to use a transductive scheme in the variational inference by implementing the variational posterior as a function of . 


\subsection{Empirical Bayes model}

Due to the hierarchical structure among data, it is natural to 
consider a hierarchical Bayes model with the marginal likelihood

The generative process is illustrated in Figure~\ref{fig:intro} (a, in red arrows):
first, a \emph{meta-parameter}  (i.e., hyper-parameter) is sampled from the \emph{hyper-prior} ;
then, for each task, a \emph{task-specific parameter}  is sampled from the \emph{prior} ;
finally, the dataset is drawn from the \emph{likelihood} . Without loss of generality, we assume the log-likelihood model factorizes as 

It is the setting advocated by \citet{minka2005discriminative}, 
in which the generative model  can be safely ignored since 
it is irrelevant to the prediction of .
To simplify the presentation, 
we still keep the notation  for the likelihood of the task  and 
use  to specify the discriminative model, which is also referred to as
the \emph{task-specific loss}, e.g., the cross entropy loss. The first argument in  is the prediction, denoted by , 
which depends on the \emph{feature representation}  and the \emph{task-specific weight} . 

Note that rather than following a fully Bayesian approach, 
we leave some random variables to be estimated in a frequentist way, 
e.g.,  is a \emph{meta-parameter} of the likelihood model shared by all tasks, 
for which we use a point estimate.
As such, the posterior inference about these variables will be largely simplified.
For the same reason, we derive the \emph{empirical Bayes} \mbox{\citep{robbins1985empirical,kucukelbir2014population}}
by taking a point estimate on . The marginal likelihood now reads as

We highlight the meta-parameters as subscripts of the corresponding distributions to distinguish from random variables.
Indeed, we are not the first to formulate meta-learning as empirical Bayes.
The overall model formulation is essentially the same as the ones considered by 
\citet{amit2018meta,grant2018recasting,ravi2018amortized}. 
Our contribution lies in the variational inference for empirical Bayes.

\subsection{Amortized inference with transduction}
\label{sec:avi}

As in standard probabilistic modeling, 
we derive an \emph{evidence lower bound} (ELBO) on the log version of \eqref{eq:eb}
by introducing a variational distribution  for each task with parameter : 

The variational inference amounts to maximizing the ELBO with respect to , which 
together with the maximum likelihood estimation of the meta-parameters, we have the following optimization problem:

However, the optimization in \eqref{eq:vi}, as  increases, becomes more and more expensive in terms of the memory footprint and the computational cost.
We therefore wish to bypass this heavy optimization
and to take advantage of the fact that
individual KL terms indeed share the same structure.
To this end, instead of introducing  different variational distributions, 
we consider a parameterized family of distributions in the form of , 
which is defined implicitly by a deep neural network  taking as input either  or  plus ,
that is,  or .
Note that we cannot use entire ,
since we do not have access to  during meta-testing.
This amortization technique was first introduced in the case of \emph{variational autoencoders} \citep{kingma2013auto,rezende2014stochastic},
and has been extended to Bayesian inference in the case of \emph{neural processes} \citep{garnelo2018neural}.

Since  and  are disjoint, the inference scheme is \emph{inductive} for a variational posterior .
As an example, MAML \citep{finn2017model} takes  as the Dirac delta distribution,
where , is the -th iterate of the stochastic gradient descent


In this work, we consider a \emph{transductive} inference scheme with variational posterior .
The inference process is shown in Figure~\ref{fig:intro}(a, in green arrows).
Replacing each  in \eqref{eq:vi} by ,
the optimization problem becomes

In a nutshell, the meta-model to be optimized includes the feature network , the hyper-parameter  from the empirical Bayes formulation and the amortization network  from the variational inference.

 \section{Unrolling exact inference with synthetic gradients}
\label{sec:alg}

It is however non-trivial to design a proper network architecture for , since  and  are both sets.
The strategy adopted by neural processes \citep{garnelo2018neural} is to aggregate the information from all individual examples via an averaging function.
However, as pointed out by \citet{kim2019attentive}, such a strategy tends to underfit  
because the aggregation does not necessarily attain the most relevant information for identifying the task-specific parameter.
Extensions, such as attentive neural process \citep{kim2019attentive} and set transformer \citep{lee2019set}, may alleviate this issue but come at a price of  time complexity.
We instead design  to mimic the exact inference 
by parameterizing the optimization process with respect to . More specifically,
consider the gradient descent on  with step size :

We would like to unroll this optimization dynamics up to the -th step such that 
while make sure that  is a good approximation to the optimum ,
which consists of parameterizing 
\begin{quote}
    (a) the \textbf{initialization}  and 
    (b) the \textbf{gradient} .
\end{quote}
By doing so,  becomes a function of ,  and \footnote{
 is also dependent of . We deliberately remove this dependency to simplify the update of .}, 
we therefore realize  as .

For (a), we opt to either let  to be a global data-independent initialization as in MAML \citep{finn2017model}
or let  with a few supervisions from the support set,
where  can be implemented by a permutation invariant network described in \citet{gidaris2018dynamic}. 
In the second case, the features of the support set will be first averaged in terms of their labels
and then scaled by a learnable vector of the same size.

For (b), the fundamental reason that we parameterize the gradient is because we do not have access to  during the meta-testing phase, although
we are able to follow \eqref{eq:gd} in meta-training to obtain .
To make a consistent parameterization in both meta-training and meta-testing, we thus do not touch  when constructing the variational posterior.  
Recall that the true gradient decomposes as

under a reparameterization  with ,
where all the terms can be computed without  
except for .
Thus, we introduce a deep neural network  to synthesize it.
The idea of synthetic gradients was originally proposed by \citet{jaderberg2017decoupled} to 
parallelize the back-propagation. Here, the purpose of  is to update  regardless of the groundtruth labels,
which is slightly different from its original purpose. 
Besides, we do not introduce an additional loss 
between  and 
since  will be driven by the objective in \eqref{eq:avi}.
As an intermediate computation, the synthetic gradient is not necessarily a good approximation to the true gradient.



\begin{figure*}[t]
    \centering
    \includegraphics[width=1.0\linewidth]{./figures/synth_grad_comp_graph_crop}\\
    \caption{The computation graph to compute the negative ELBO, 
    where the input and output of the synthetic gradient module are highlighted in red.
    The detach() is used to stop the back-propagation down to the feature network.
Note that we do not include every computation for simplicity.
    }
	\label{fig:cg}
\end{figure*}


To sum up, we have derived a particular implementation of  by parameterizing the exact inference update, 
namely \eqref{eq:gd}, without using the labels of the query set,
where the meta-model  includes an initialization network  and a synthetic gradient network ,
such that , the -th iterate of the following update: 

The overall algorithm is depicted in Algorithm~\ref{alg:sib}. 
We also make a side-by-side comparison with MAML shown in Figure~\ref{fig:intro}.
Rather than viewing \eqref{eq:sib} as an optimization process, it may be more precise to think of it as a part of the computation graph created in the forward-propagation. 
The computation graph of the amortized inference is shown in Figure~\ref{fig:cg},

As an extension, if we were deciding to estimate the feature network  in a Bayesian manner, 
we would have to compute higher-order gradients as in the case of MAML.
This is inpractical from a computational point of view and needs technical simplifications \citep{nichol2018first}. 
By introducing a series of synthetic gradient networks in a way similar to \citet{jaderberg2017decoupled}, the computation will be decoupled into computations within each layer, and thus becomes more feasible. 
We see this as a potential advantage of our method
and leave this to our future work\footnote{We do not insist on Bayesian estimation of the feature network because 
most Bayesian versions of CNNs underperform their deterministic counterparts.}.

\begin{algorithm}[t]
  \caption{Variational inference with synthetic gradients for empirical Bayes}
  \label{alg:sib}
  \begin{algorithmic}[1]
    \State \textbf{Input}: the dataset ; the step size ; the number of inner iterations ; pretrained .
    \State Initialize the meta-models , and .
    \While{not converged}
      \State Sample a task  and the associated query set  (plus optionally the support set ).
      \State Compute the initialization  or .
      \For{} 
        \State Compute  via \eqref{eq:sib}.
      \EndFor
      \State Compute  with .
      \State Update .
      \vspace{-0.2mm}
      \State Update .
      \State Optionally, update .
    \EndWhile
\end{algorithmic}
\end{algorithm}














 \section{Generalization analysis of empirical Bayes via the connection to information bottleneck}
\label{sec:theory}

The learning of empirical Bayes (EB) models follows the frequentist's approach,
therefore, we can use frequentist's tool to analyze the model.
In this section, we study the generalization ability of the empirical Bayes model
through its connection to a variant of the information bottleneck principle \citet{Achille17,tishby2000information}. 

\paragraph{Abstract form of empirical Bayes}
From \eqref{eq:eb}, we see that the empirical Bayes model implies a simpler joint distribution since

which is equal to the log-density of  iid samples drawn from the joint distribution

up to a constant if we introduce a random variable to represent the task and assume  is an uniform distribution.
We thus see that this joint distribution embodies the \emph{generative process} of empirical Bayes. 
Correspondingly, there is another graphical model of the joint distribution characterizes
the \emph{inference process} of the empirical Bayes:

where  is the abstract form of the variational posterior with amortization,
includes both the inductive form and the transductive form.
The coupling between  and  is due to  as we only have access to tasks through sampling.

We are interested in the case that the number of tasks ,
such as the few-shot learning paradigm proposed by \citet{vinyals2016matching},
in which the objective of \eqref{eq:avi} can be rewritten in an abstract form of

In fact, optimizing this objective is the same as optimizing \eqref{eq:avi} from
a stochastic gradient descent point of view.

The learning of empirical Bayes with amortized variational inference 
can be understood as a variational EM in the sense that
the E-step amounts to aligning  with  while the M-step amounts to adjusting the likelihood  and the prior .



\paragraph{Connection to information bottleneck}
The following theorem shows the connection between \eqref{eq:popeb} and the information bottleneck principle.


\begin{restatable*}{thm}{ebibt}
    \label{thm:ib}
    Given distributions , , ,  and , we have

    where  is the conditional mutual information
    and  is the conditional entropy.
The equality holds when 
    
\end{restatable*}
In fact, the lower bound on \eqref{eq:popeb} is an extention of the information bottleneck principle \citep{Achille17} under the multi-task setting,
which, together with the synthetic gradient based variational posterior, 
    inspire the name \textbf{synthetic information bottleneck} of our method.
The tightness of the lower bound depends on both 
the parameterizations of  and  
as well as the optimization of \eqref{eq:popeb}.
It thus can be understood as how well we can align the inference process with the generative process.
    From an inference process point of view, for a given , the optimal likelihood and prior have been determined.
    In theory, we only need to find the optimal  using the information bottleneck in \eqref{eq:ib}.
    However, in practice, minimizing \eqref{eq:popeb} is more straightforward.

\paragraph{Generalization of empirical Bayes meta-learning}
    The connection to information bottleneck suggests that we can eliminate  and  from 
    the generalization analysis of empirical Bayes meta-learning and define the generalization error by  only.
    To this end, we first identify the \emph{empirical risk} for a single task  with respect to particular weights  and dataset  as 

    The \emph{true risk} for task  with respect to  is then the expected empirical risk .
    Now, we define the \emph{generalization error} with respect to  as 
    the average of the difference between the true risk and the empirical risk over all possible :

where  is the \emph{aggregated posterior} of task .

Next, we extend the result from \citet{xu2017information} and derive a data-dependent upper bound for  using mutual information.
\begin{restatable*}{thm}{genmi}
    Denote by .
    If  is -subgaussian under , 
then  is -subgaussian under  due to the iid assumption, and
    
\end{restatable*}

Plugging this back to Theorem~\ref{thm:ib}, we obtain a different interpretation for the empirical Bayes ELBO.

\begin{coro}
    \label{thm:gen}
    If  is chosen to be the negative log-likelihood, minimizing the population objective of empirical Bayes meta-learning
    amounts to minimizing both the expected generalization error and the expected empirical risk:
    
\end{coro}



The Corollary \ref{thm:gen} suggests that \eqref{eq:popeb} amounts to minimizing a regularized empirical risk minimization.
In general, there is a tradeoff between the generalization error and the empirical risk 
controlled by the coefficient , where  is the cardinality of .
If  is small, then we are in the overfitting regime. 
This is the case of the inductive inference with variational posterior , 
where the support set  is fairly small by the definition of few-shot learning.
On the other hand, if we were following the transductive setting, we expect to achieve a small generalization error since the implemented variational posterior is a better approximation to .
However, keeping increasing  will potentially over-regularize the model and thus yield negative effect.
An empirical study on varying  can be found in Table~\ref{tab:abn} in Appendix~\ref{sec:varyn}.


 \section{Experiments}
\label{sec:exp}
In this section, we first validate our method on few-shot learning, 
and then on zero-shot learning (no support set and no class description are available). 
Note that many meta-learning methods cannot do zero-shot learning since they rely on the support set.

\subsection{Few-shot classification}
\label{sec:few}

\begin{table}[t]
\centering
\footnotesize
\scalebox{0.9}{
\begin{tabular}{ p{4.35cm} c c c c c }
\toprule
 & & \multicolumn{2}{c}{\textbf{MiniImageNet, 5-way}} & \multicolumn{2}{c}{\textbf{CIFAR-FS, 5-way}} \\
 \textbf{Method} & \textbf{Backbone} & 1-shot & 5-shot & 1-shot & 5-shot \\
\midrule
Matching Net~\citep{vinyals2016matching} & Conv-4-64 & 44.2\% & 57\% & -- & -- \\
MAML~\citep{finn2017model} & Conv-4-64 & 48.71.8\% & 63.10.9\% & 58.91.9\% & 71.51.0\% \\
Prototypical Net~\citep{snell2017prototypical} & Conv-4-64 & 49.40.8\% & 68.20.7\% & 55.50.7\% & 72.00.6\% \\
Relation Net~\citep{sung2018learning} & Conv-4-64 & 50.40.8\% & 65.30.7\% & 55.01.0\% & 69.30.8\% \\
GNN~\citep{Satorras2017FewShotLW} & Conv-4-64 & 50.3\% & 66.4\% & 61.9\% & 75.3\% \\
R2-D2~\citep{Bertinetto2018MetalearningWD} & Conv-4-64 & 49.50.2\% & 65.40.2\% & 62.30.2\% & 77.40.2\% \\
TPN~\citep{liu2018learning} & Conv-4-64 & 55.5\% & 69.9\% & -- & -- \\
\citet{gidaris2019boosting} & Conv-4-64 & 54.80.4\% & \textbf{71.90.3\%} & 63.50.3\% & \textbf{79.80.2\%} \\ \hline

\rowcolor[gray]{.9} SIB =0 () & Conv-4-64 & 50.00.4\% & 67.00.4\% & 59.20.5\% & 75.40.4\%\\
\rowcolor[gray]{.9} SIB =1e-3, =3 & Conv-4-64 & \textbf{58.00.6\%} & 70.70.4\% & \textbf{68.70.6\%} & 77.10.4\%\\ \midrule
\rowcolor[gray]{.9} SIB =1e-3, =0 & Conv-4-128 & 53.62  0.79\% & 71.48  0.64\% & -- & --\\ 
\rowcolor[gray]{.9} SIB =1e-3, =1 & Conv-4-128 & 58.74  0.89\% & 74.12  0.63\% & -- & --\\ 
\rowcolor[gray]{.9} SIB =1e-3, =3 & Conv-4-128 & 62.59  1.02\% & 75.43  0.67\% & -- & --\\ 
\rowcolor[gray]{.9} SIB =1e-3, =5 & Conv-4-128 & \textbf{63.26  1.07\%} & \textbf{75.73  0.71\%} & -- & --\\ \midrule

TADAM~\citep{Oreshkin2018TADAMTD} & ResNet-12 & 58.50.3\% & 76.70.3\% & -- & -- \\
SNAIL~\citep{Santoro2017ASN} & ResNet-12 & 55.71.0\% & 68.90.9\% & -- & -- \\
MetaOptNet-RR~\citep{lee2019meta} & ResNet-12 & 61.40.6\% & 77.90.5\% & 72.60.7\% & 84.30.5\% \\
MetaOptNet-SVM                     & ResNet-12 & 62.60.6\% & 78.60.5\% & 72.00.7\% & 84.20.5\% \\
CTM~\citep{li2019ctm} & ResNet-18 & 64.10.8\% & \textbf{80.50.1\%} & -- & -- \\

\citet{qiao2018few} & WRN-28-10 & 59.60.4\% & 73.70.2\% & -- & --\\
LEO~\citep{rusu2018metalearning} & WRN-28-10 & 61.80.1\% & 77.60.1\% & -- & -- \\
\citet{gidaris2019boosting} & WRN-28-10 & 62.90.5\% & 79.90.3\% & 73.60.3\% & \textbf{86.10.2\%} \\ \hline

\rowcolor[gray]{.9} SIB =0 () & WRN-28-10 & 60.60.4\% & 77.50.3\% & 70.00.5\% & 83.50.4\% \\
\rowcolor[gray]{.9} SIB =1e-3, =1 & WRN-28-10 & 67.30.5\% & 78.80.4\% & 76.80.5\%& 84.90.4\%\\
\rowcolor[gray]{.9} SIB =1e-3, =3 & WRN-28-10 & 69.60.6 \% & 78.90.4\% & 78.40.6\% & 85.30.4\%\\
\rowcolor[gray]{.9} SIB =1e-3, =5 & WRN-28-10 & \textbf{70.00.6\%} & 79.20.4\% & \textbf{80.00.6\%}& 85.30.4\% \\

\bottomrule
\end{tabular}}
\caption{Average classification accuracies (with 95\% confidence intervals) on the test-set of MiniImageNet and CIFAR-FS. 
    For evaluation, we sample 2000 and 5000 episodes respectively for MiniImageNet and CIFAR-FS 
    and test three different architectures as the feature extractor: Conv-4-64, Conv-4-128 and WRN-28-10. 
    We train SIB with learning rate  and try different numbers of synthetic gradient steps .}
\label{tab:tab-1}
\end{table}


We compare SIB with state-of-the-art methods on few-shot classification problems.
Our code is available at \url{https://github.com/amzn/xfer}.

\subsubsection{Setup}

\paragraph{Datasets}
We choose standard benchmarks of few-shot classification for this experiment.
Each benchmark is composed of disjoint training, validation and testing classes. 
\textbf{MiniImageNet} is proposed by \citet{vinyals2016matching}, which contains 100 classes, 
split into 64 training classes, 16 validation classes and 20 testing classes;
each image is of size 8484. 
\textbf{CIFAR-FS} is proposed by~\citet{Bertinetto2018MetalearningWD}, 
which is created by dividing the original CIFAR-100 into 
64 training classes, 16 validation classes and 20 testing classes; 
each image is of size 3232.


\paragraph{Evaluation metrics} In few-shot classification, 
a task (aka episode)  consists of a \emph{query set}  and a \emph{support set} . 
When we say the task  is \emph{-way--shot} we mean that 
 is formed by first sampling  classes from a pool of classes;
then, for each sampled class,  examples are drawn and a new label taken from  is assigned to these examples.
By default, each query set contains  examples.
The goal of this problem is to predict the labels of the query set, which are provided as ground truth during training.
The evaluation is the average classification accuracy over tasks.


\paragraph{Network architectures}
Following \citet{gidaris2018dynamic,qiao2018few,gidaris2019boosting}, we implement  by a 4-layer convolutional network (Conv-4-64 or Conv-4-128\footnote{
    Conv-4-64 consists of 4 convolutional blocks each implemented with a  convolutional layer followed by BatchNorm + ReLU +  
    max-pooling units. All blocks of Conv-4-64 have 64 feature channels. 
    Conv-4-128 has 64 feature channels in the first two blocks and  128 feature channels in the last two blocks.
})
or a WideResNet (WRN-28-10) \citep{zagoruyko2016wide}. We pretrain the feature network  on the 64 training classes for a stardard -way classification.
We reuse the feature averaging network proposed by \citet{gidaris2018dynamic} as our initialization network , 
which basically averages the feature vectors of all data points from the same class and then scales each feature dimension differently by a learned coefficient.
For the synthetic gradient network , we implement a three-layer MLP with hidden-layer size .
Finally, for the predictor , we adopt the cosine-similarity based classifier advocated by \citet{chen2019closer} and \citet{gidaris2018dynamic}.


\paragraph{Training details}
We run SGD with batch size  for 40000 steps, where the learning rate is fixed to . During training, we freeze the feature network.
To select the best hyper-parameters, we sample 1000 tasks from the validation classes and reuse them at each training epoch. 



\subsubsection{Comparison to state-of-the-art meta-learning methods}
\label{sec:sota}

In Table~\ref{tab:tab-1},
we show a comparison between the state-of-the-art approaches 
and several variants of our method (varying  or ).
Apart from SIB, TPN~\citep{liu2018learning} and CTM~\citep{li2019ctm} are also transductive methods.

First of all, comparing SIB () to SIB (), 
we observe a clear improvement, 
which suggests that, by taking a few synthetic gradient steps,
we do obtain a better variational posterior as promised.
For 1-shot learning, SIB (when  or ) significantly outperforms previous methods 
on both MiniImageNet and CIFAR-FS. 
For 5-shot learning, the results are also comparable. 
It should be noted that the performance boost is consistently observed 
with different feature networks,
which suggests that SIB is a general method for few-shot learning.

However, we also observe a potential limitation of SIB:
when the support set is relatively large, e.g., 5-shot,
with a good feature network like WRN-28-10,
the initialization  may already be close to some local minimum,
making the updates later less important.

For 5-shot learning, SIB is sligtly worse than CTM~\citep{li2019ctm} and/or \citet{gidaris2019boosting}.
CMT~\citep{li2019ctm} can be seen as an alternative way to incorporate transduction -- 
it measures the similarity between a query example and the support set while making use of intra- and inter-class relationships.  
\citet{gidaris2019boosting} uses in addition the self-supervision as an auxilary loss to learn a richer and more transferable feature model.
Both ideas are complementary to SIB. We leave these extensions to our future work.


\subsection{Zero-shot regression: spinning lines} 


\begin{figure*}[ht]
	\centering
	\begin{minipage}{.32\textwidth}
		\centering
		\includegraphics[width=1.0\linewidth]{./figures/sib_eval.pdf}
	\end{minipage} 
	\hfill
	\begin{minipage}{.32\textwidth}
		\centering
		\includegraphics[width=1.0\linewidth]{./figures/sib_dyn.pdf}
	\end{minipage}
	\hfill
	\begin{minipage}{.32\textwidth}
		\centering
		\includegraphics[width=1.0\linewidth]{./figures/pred_comparison.pdf}
	\end{minipage}
	\caption{\textbf{Left}: the mean-square errors on ,
        ,  and the estimate
        of .
		\textbf{Middle}: the predicted 's by  for . \textbf{Right}: the predictions of SIB.}
	\label{fig:toy}
\end{figure*}


Since our variational posterior relies only on , SIB is also applicable to zero-shot problems (i.e., no support set available).
We first look at a toy multi-task problem, where  is tractable.

Denote by  the train set, which consists of datasets of size : .
We construct a dataset  by firstly sampling iid Gaussian random variables as inputs: .
Then, we generate the weight for each dataset by calculating the mean of the inputs and shifting with a Gaussian random variable :

The output for  is 
We decide ahead of time the hyperparameters  for generating  and . 
Recall that a weighted sum of iid Gaussian random variables is still a Gaussian random variable.
Specifically, if  and , 
then .
Therefore, we have .
On the other hand, if we are given a dataset  of size , the only uncertainty about  comes from ,
that is, we should consider  as a constant given .
Therefore, the posterior .
We use a simple implementation for SIB:
The variational posterior is realized by
    
 is a mean squared error, implies that ;
 is a Gaussian distribution with parameters ;
The synthetic gradient network  is a three-layer MLP with hidden size .

In the experiment, we sample  tasks respectively for both  and .
We learn SIB and BNN on  for  epochs using the ADAM optimizer \citep{kingma2014adam}, with learning rate 
and batch size .
Other hyperparameters are specified as follows:

The results are shown in Figure~\ref{fig:toy}. On the left, both 
 and  are close to zero
indicating the success of the learning. 
More interestingly, in the middle, we see that  evolves gradually towards the ground truth,
which suggests that the synthetic gradient network is able to identify the descent direction after meta-learning.





 

\section{Conclusion}

We have presented an empirical Bayesian framework for meta-learning. 
To enable an efficient variational inference, we followed the amortized inference paradigm,
and proposed to use a transductive scheme for constructing the variational posterior.
To implement the transductive inference, we make use of two neural networks:
a synthetic gradient network and an initialization network,
which together enables a synthetic gradient descent on the unlabeled data 
to generate the parameters of the amortized variational posterior dynamically.
We have studied the theoretical properties of the proposed framework 
and shown that it yields performance boost on MiniImageNet and CIFAR-FS for few-shot classification.





\bibliography{refs}
\bibliographystyle{iclr2020_conference}


\appendix
\section*{Appendix}
\renewcommand{\thesubsection}{\Alph{subsection}}

\subsection{Proofs}

\ebibt
\begin{proof}
    Denote by  the aggregated posterior of task .
    \eqref{eq:popeb} can be decomposed as

    The inequality is because  for all 's.
    Besides, we used the notation , which is the conditional cross entropy. Recall that .
    We attain the lower bound as desired if this inequality is applied to replace  by .
\end{proof}

The following lemma and theorem show the connection between  and the generalization error.
We first extend \citet[Lemma 4.2]{xu2016information}.
\begin{lemm} 
    \label{thm:subg}
    If, for all ,  is -subgaussain under , then 
    
\end{lemm}
\begin{proof}
    The proof is adapted from the proof of \citet[Lemma 4.2]{xu2016information}.
    
    The second inequality was due to the Donsker-Varadhan variational representation of KL divergence and the definition of subgaussain random variable.
\end{proof}

\genmi
\begin{proof}
    First, if  is -subgaussian under , by definition,
    
    It is straightforward to show  is -subgaussian since
    
    By Lemma~\ref{thm:subg}, we have
    
    as desired.
\end{proof}






\subsection{Zero-shot classification: unsupervised multi-source domain adaptation}

\begin{table}[t]
\centering
\footnotesize
\scalebox{0.9}{
\begin{tabular}{ p{5cm} c c c c c }
\toprule
    Method & Art & Cartoon & Sketch & Photo & Average \\
\midrule
    JiGen~\citep{carlucci2019domain} & 84.9\%  & 81.1\% & 79.1\% & 98.0\% & 85.7\% \\
    Rot~\citep{xu2019self} & 88.7\% & 86.4\% & 74.9\% & 98.0\% & 87.0\% \\ 
    \hline
    \rowcolor[gray]{.9} SIB-Rot  & 85.7\% & 	86.6\% & 	80.3\% & 	98.3\% & 	87.7\% \\
    \rowcolor[gray]{.9} SIB-Rot  & \textbf{88.9\%} & \textbf{89.0\%} & \textbf{82.2\%} & \textbf{98.3\%} & \textbf{89.6\%} \\
\bottomrule
\end{tabular}
}
\caption{Multi-source domain adaptation results on PACS with ResNet-18 features.
Three domains are used as the source domains keeping the fourth one as target.}
\label{tab:uda}
\end{table}


A more interesting zero-shot multi-task problem is unsupervised domain adaptation.
We consider the case where there exists multiple source domains and a unlabeled target domain.
In this case, we treat each minibatch as a task. This makes sense because the difference in statistics between two minibatches 
are much larger than in the traditional supervised learning.
The experimental setup is similar to few-shot classification described in Section~\ref{sec:few},
except that we do not have a support set and the class labels between two tasks are the same.
Hence, it is possible to explore the relationship between class labels and \emph{self-supervised} labels to implement 
the initialization network  without resorting to support set.
We reuse the same model implementation for SIB as described in Section~\ref{sec:few}. The only difference is the initialization network.
Denote by  the set of self-supervised labels of task , 
the initialization network  is implemented as follows:

where \footnote{ is overloaded to be both the network and its parameters.} 
is a global initialization similar to the one used by MAML; 
 is the self-supervised loss,  is the set of predictions of the self-supervised labels. 
One may argue that  would be a simpler solution. 
However, it is insufficient since the gap between two domains can be very large.
The initial solution yielded by \eqref{eq:ssup} is more dynamic in the sense that 
 is adapted taking into account the information from .

In terms of experiments, we test SIB on the PACS dataset \citep{li2017deeper},
which has 7 object categories and 4 domains (Photo, Art Paintings, Cartoon and Sketches),
and compare with state-of-the-art algorithms
for unsupervised domain adaptation. 
We follow the standard experimental setting \citep{carlucci2019domain}, where 
the feature network is implemented by ResNet-18. 
We assign a self-supervised label  to image  by rotating the image
by a predicted degree. This idea was originally proposed by \citet{gidaris2018unsupervised} for representation learning
and adopted by \citet{xu2019self} for domain adaptation.
The training is done by running ADAM for  epochs with learning rate .
We take each domain in turns as the target domain. The results are shown in Table~\ref{tab:uda}.
It can be seen that SIB-Rot () improves upon the baseline SIB-Rot () for zero-shot classification,
which also outperforms state-of-the-art methods when the baseline is comparable.



\subsection{Importance of synthetic gradients}
To further verify the effectiveness of the synthetic gradient descent,
we implement an inductive version of SIB inspired by MAML,
where the initialization  is generated exactly the same way as SIB using ,
but it then follows the iterations in \eqref{eq:maml} as in MAML rather than follows the iterations in \eqref{eq:sib}
as in standard SIB.

We conduct an experiment on CIFAR-FS using Conv-4-64 feature network.
The results are shown in Table~\ref{tab:tab-2}.
It can be seen that there is no improvement over SIB () 
suggesting that the inductive approach is insufficient.

\label{sec:cifar}
\begin{table}[ht]
\centering
\footnotesize
\begin{tabular}{ c c | c c | c c | c c}
\toprule
 & & \multicolumn{2}{c|}{\textbf{inductive SIB}} & \multicolumn{4}{c}{\textbf{SIB}} \\
 & & \multicolumn{2}{c|}{\textbf{Training on 1-shot}} & \multicolumn{2}{c|}{\textbf{Training on 1-shot}} & \multicolumn{2}{c}{\textbf{Training on 5-shot}} \\
 & & \multicolumn{2}{c|}{\textbf{Testing on}} & \multicolumn{2}{c|}{\textbf{Testing on}} & \multicolumn{2}{c}{\textbf{Testing on}} \\
   &  & 1-shot & 5-shot & 1-shot & 5-shot & 1-shot & 5-shot \\
\midrule
0 & - & 59.70.5\% & 75.50.4\% & 59.20.5\% & 75.40.4\% & 59.20.5\% & 75.40.4\% \\\hdashline

1 & 1e-1 & 59.80.5\% & 71.20.4\% & 65.30.6\% & 75.80.4\% & 64.50.6\% & 77.30.4\% \\
3 & 1e-1 & 59.60.5\% & 75.90.4\% & 65.00.6\% & 75.00.4\% & 64.00.6\% & 77.00.4\% \\
5 & 1e-1 & 59.90.5\% & 74.90.4\% & 66.00.6\% & 76.30.4\% & 64.00.5\% & 76.80.4\% \\\hdashline

1 & 1e-2 & 59.70.5\% & 75.50.4\% & 67.80.6\% & 74.30.4\% &  63.60.6\%& 77.30.4\% \\
3 & 1e-2 & 59.50.5\% & 75.80.4\% & 68.60.6\% & 77.40.4\% & 67.80.6\% & 78.50.4\% \\
5 & 1e-2 & 59.80.5\% & 75.70.4\% & 67.40.6\% & 72.60.6\% & 67.70.7\% & 77.70.4\% \\\hdashline

1 & 1e-3 & 59.50.5\% & 75.60.4\% & 66.20.6\% & 75.70.4\% & 64.60.6\% & 78.10.4\% \\
3 & 1e-3 & 59.90.5\% & 75.90.4\% & 68.70.6\% & 77.10.4\% & 66.80.6\% & 78.40.4\% \\
5 & 1e-3 & 59.40.5\% & 75.70.4\% & 69.10.6\% & 76.70.4\% & 66.70.6\% & 78.50.4\% \\\hdashline

1 & 1e-4 & 58.80.5\% & 75.50.4\% & 59.00.5\% & 75.70.4\% & 59.30.5\% & 75.70.4\% \\
3 & 1e-4 & 59.40.5\% & 75.90.4\% & 58.90.5\% & 75.60.4\% & 59.30.5\% & 75.90.4\% \\
5 & 1e-4 & 59.30.5\% & 75.30.4\% & 60.10.5\% & 76.00.4\% & 60.50.5\% & 76.40.4\% \\
\bottomrule
\end{tabular}
\caption{Average 5-way classification accuracies (with 95\% confidence intervals) with Conv-4-64 on the test set of CIFAR-FS. For each test, we sample 5000 episodes containing 5 categories (5-way) and 15 queries in each category. We report the results with using different learning rate  as well as  different number of updates . Note that  is the performance only using the pre-trained feature. }
\label{tab:tab-2}
\end{table}


\subsection{Varying the size of the query set}
\label{sec:varyn}
We notice that changing the size of  (i.e., ) 
during training does make a difference on testing.
The results are shown in Table~\ref{tab:abn}.

\begin{table}[ht]
    \centering
    \footnotesize
    \begin{tabular}{ l| r r |r r }
    \toprule
    \multicolumn{1}{l|}{\multirow{ 2}{*}{} } & \multicolumn{2}{c|}{5-way, 5-shot} & \multicolumn{2}{c}{5-way, 1-shot}\\
     & Validation & Test & Validation & Test \\
    \midrule
    3 & 77.97  0.34\% & 75.91  0.66\% & 63.60  0.52\% & 61.32  1.02\% \\
    5 & 78.14  0.35\% & 76.01  0.66\% & 64.67  0.55\% & 62.50  1.02\% \\
    10 & \textbf{78.30  0.35\%} & \textbf{76.22  0.66\%} & \textbf{65.34  0.56\%} & \textbf{63.22  1.04\%} \\
    15 & 77.53  0.35\% & 75.43  0.67\% & 65.14  0.55\% & 62.59  1.02\% \\
    30 & 76.21  0.35\% & 74.04  0.67\% & 63.37  0.53\% & 60.96  0.98\% \\
    45 & 75.65  0.36\% & 73.27  0.66\% & 62.08  0.51\% & 59.59  0.93\% \\
    \bottomrule
    \end{tabular}
    \caption{Average classification accuracies on the validation set and the test set of Mini-ImageNet
    with backbone Conv-4-128. We modify the number of query images, i.e., , for each episode to study the effect on generalization.}
    \label{tab:abn}
\end{table}
 
\end{document}
