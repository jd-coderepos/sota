
\NeedsTeXFormat{LaTeX2e}

\documentclass{new_tlp}

\usepackage{url,graphicx}

\hyphenation{either}
\providecommand\AMSLaTeX{AMS\,\LaTeX}
\newcommand\eg{\emph{e.g.}\ }
\newcommand\etc{\emph{etc.}}
\newcommand\bcmdtab{\noindent\bgroup\tabcolsep=0pt\begin{tabular}{@{}p{10pc}@{}p{20pc}@{}}}
\newcommand\ecmdtab{\end{tabular}\egroup}
\newcommand\rch[1]{#1\hspace{1em}}
\newcommand\lra{\ensuremath{\quad\longrightarrow\quad}}

  \title[Combinatorial Search With Picat]
        {Combinatorial Search With Picat}

  \author[N.-F. Zhou]
         {NENG-FA ZHOU\\
         Brooklyn College and Graduate Center \\
         The City University of New York\\
         \email{nzhou@acm.org}}

\jdate{February 2014}
\pubyear{2014}
\pagerange{\pageref{firstpage}--\pageref{lastpage}}
\doi{XXX}

\newtheorem{lemma}{Lemma}[section]

\begin{document}

\label{firstpage}

\maketitle

  \begin{abstract}
Picat, a new member of the logic programming family, follows a different doctrine than Prolog in offering the core logic programming concepts: arrays and maps as built-in data types; implicit pattern matching with explicit unification and explicit non-determinism; functions for deterministic computations; and loops for convenient scripting and modeling purposes. Picat provides facilities for solving combinatorial search problems, including a common interface with CP, SAT, and MIP solvers, tabling for dynamic programming, and a module for planning. Picat's planner module, which is implemented by the use of tabling, has produced surprising and encouraging results. Thanks to term-sharing and resource-bounded tabled search, Picat overwhelmingly outperforms the cutting-edge ASP and PDDL planners on the planning benchmarks used in recent ASP competitions.
  \end{abstract}



\section{Introduction}
Picat is a simple, and yet powerful, logic-based multi-paradigm programming language. The desire for a logic-based general-purpose programming language that is as powerful as Python for scripting, and on a par with OPL \cite{Hentenryck02} and MiniZinc \cite{NethercoteSBBDT07} for modeling combinatorial problems, led to the design of Picat. Early attempts to introduce arrays and loops into Prolog for modeling failed to produce a satisfactory language: most noticeably, array accesses are treated as functions only in certain contexts; and loops require the declaration of global variables in ECLiPSe \cite{Schimpf02} and local variables in B-Prolog \cite{Zhou12}. 

Picat departs from Prolog in many aspects, including the successful introduction of arrays and loops. Picat uses pattern-matching rather than unification in the selection of rules. Unification might be a natural choice in Horn clause resolution \cite{kowalski1971} for theorem proving, but its power is rarely needed for general programming tasks. Pattern-matching rules are fully indexed, and therefore Picat can be more scalable than Prolog. Unification can be considered as an equation over terms \cite{Colmerauer84}, and just like constraints over finite domains, Picat supports unification as an explicit call.

Non-determinism, a powerful feature of logic programming, makes concise solutions possible for many problems, including simulation of non-deterministic automata, parsers of ambiguous grammars, and search problems. Nevertheless, non-determinism is not needed for deterministic computations. In Prolog, Horn clauses are backtrackable by default. As it is undecidable to detect determinism in general \cite{Debray88}, programmers tend to excessively use the cut operator to prune unnecessary clauses. Picat supports explicit non-determinism, which renders the cut operator unnecessary. Rules are deterministic unless they are explicitly denoted as backtrackable. 

Picat supports functions, like many other logic-based languages, such as Curry \cite{Hanus13}, Erlang \cite{Armstrong13}, and Mozart-Oz \cite{RoyH2004}. In Prolog, it's often that queries fail, but the system gives no clue about the source of the failure. Functions should be used instead of relations, unless multiple answers are required. Functions are more convenient to use than predicates because (1) functions are guaranteed to succeed with a return value; (2) function calls can be nested; and (3) the directionality of functions enhances the readability.

Many combinatorial problems can be formulated as constraint satisfaction problems (CSPs). There are three kinds of systematic solvers for solving CSPs, namely, Constraint Programming (CP), Mixed Integer Programming (MIP), and SAT solving. CP uses constraint propagation to prune search spaces, and uses heuristics to guide search \cite{Rossi06}. MIP relies on LP relaxation and branch-and-cut to find optimal integer solutions \cite{Appa10}. SAT performs unit propagation and clause learning to prune search spaces, and employs heuristics and learned clauses to perform non-chronological backtracking \cite{MalikZ09}. No solver is superior all the time; sometimes, extensive experimentation is necessary to find a suitable solver.

Picat provides a common interface with CP, SAT, and MIP solvers for solving CSPs. For each solver, Picat provides a separate module of built-ins for creating decision variables, specifying constraints, and invoking the solver. The common interface allows for seamless switching from one solver to another. The basic language constructs, such as arrays and loops, make Picat a powerful modeling language for these solvers.

Tabling \cite{warren92} can be used to cache the results of certain calculations in memory and reuse them in subsequent calculations through a quick table lookup. As computer memory grows, tabling is becoming increasingly important for offering dynamic programming solutions for many problems. Picat's tabling system is inherited from B-Prolog \cite{zhou08tab}. 

Picat has a planner module. For a planning problem, the programmer only needs to specify conditions on the final states and the set of actions, and to call the planner on an initial state to find a plan or an optimal plan. The planner, which is implemented by the use of tabling, performs a state-space search and tables every state that is encountered during search. 

A joint effort by the system and the programmer is needed to deal with the state explosion problem. The Picat system stores all structured ground terms in a table, so ground terms that are shared by states are only tabled once. The enhanced {\it hash-consing} technique \cite{ZhouH12} also stores hash codes in order to speed up computation of hash codes and equality tests of terms. The Picat system also performs {\it resource-bounded tabled search}, which prunes parts of the search space that cannot lead to acceptable plans. In order to exploit these techniques, the programmer needs to design a good representation for states that facilitates sharing and removes symmetries. For certain problems, the programmer can also employ domain knowledge and heuristics to help prune the search space. 

Picat's planner has produced surprising and encouraging results. It overwhelmingly outperforms the cutting-edge ASP and PDDL planners on many benchmarks used in recent ASP and IPC competitions. The Picat encodings of the benchmarks, which are as compact as the ASP and PDDL encodings, are available at \url{picat-lang.org}.

This paper gives an overview of Picat's facilities for combinatorial search. It also offers a glimpse of the language features. The readers are referred to \cite{PicatGuide,Kjellerstrand14} for the details of the language.

\section{\label{sec:overview}An Overview of Picat}
Picat follows a different doctrine than Prolog in offering the core logic programming concepts. This section gives a brief overview of Picat's basic language constructs. The facilities for combinatorial search, including tabling, solver modules for CSPs, and a module for planning, will be described later. Other features of Picat, which are not covered in this overview, include assignments, global maps, action rules for defining event-driven actors, a simple module system, modules for everyday programming tasks ({\tt basic}, {\tt math}, {\tt io}, {\tt util}, and {\tt os}), and a module for probabilistic reasoning and learning with PRISM \cite{prism:website}. 

\subsection{Logic Variables and Data Types}
A logic variable is a value holder, and a value is a term, which can be another variable. In addition to the basic data types in Prolog, Picat also provides strings, arrays, and maps. A double-quoted string is represented as list of single-character atoms, and all of the built-ins on lists, such as the concatenation function \verb-++-, can also be applied to strings. An \emph{array} takes the form \texttt{\{,,\}}. In the current implementation, an array is a special structure with the name \texttt{`\{\}'}. A \emph{map} is a hash-table that is represented as a structure, containing a set of key-value pairs. 

Picat allows function calls in arguments. For this reason, it requires structures to be preceded with a dollar sign in order for them to be treated as data. For example, \verb+XIXIXIA_1.f(A_2,\ldots,A_k)f(A_1,A_2,\ldots,A_k)A_1A_1fA.AttrAttrf(\ldots)(A,Attr)Head, Cond\ \ BodyHead, Cond\ \ BodyHeadp(t_1,\ldots,t_n)pnCondCCHeadCondCVPatternVPatternVPatternPatternVPatternCCBodyCCBodyBodyCCXYX=YCondCondBodyFExp, Cond\ \ BodyFf(t_1,\ldots, t_n)ExpCondBodyFExpE_1D_1Cond_1\ldotsE_nD_nCond_nGoalE_i\ in\ D_iCond_iE_iD_iGoalE_1 \in D_1\ldotsE_n \in D_nCond_1\ldotsCond_nTE_1D_1Cond_1\ldotsE_nD_nCond_nTE_1 \in D_1\ldotsE_n \in D_nTXYXYXXYXVsDVsDVsDE_1\ R\ E_2E_1E_2ROptionsVarsVarsOptionsEEQ[I]-I : I in 1..N]),
            all_different([\lceil log_2(n)\rceiln\neqx>yx+y=z\leM_{1},M_{2},\ldots,M_{n}M_{i}M_{n}SLimitPlanPlanCostPlanSPlanCostPlanLimitSLimitPlanPlanCostLimitN\times Ns([Stop|To],ORobotLocs),
    Action = [From|Stop],
    ActionCost = 1,
    choose_move_dest(From,ORobotLocs,Stop).
action(s(FromTo@[From|_],ORobotLocs),NextState,Action,ActionCost) => 
    NextState = $s(FromTo,ORobotLocs2),
    Action = [RFrom|RTo],
    ActionCost = 1,
    select(RFrom, ORobotLocs,ORobotLocs1),
    choose_move_dest(RFrom,[From|ORobotLocs1],RTo),
    ORobotLocs2 = insert_ordered(ORobotLocs1,RTo).
\end{verbatim}
\end{center}
\caption{\label{fig:ricochet}A Picat program for the Ricochet Robots problem.}
\end{figure}

The program can be improved by using a heuristic function. At the end of each rule for {\tt action}, the following condition can be added:
\begin{verbatim}
    current_resource() > heuristic_val(NextState)
\end{verbatim}
This ensures that the resource limit is greater than the estimated number of steps required to transform {\tt NextState} to a final state. For example, the current state is at least three steps away from the final state if the target robot is not in the same row or the same column, and the target position has no obstacle around it.

Picat has demonstrated a surprising performance on many benchmarks. For the four planning benchmarks used in the ASP'13 competition ({\it Nomystery}, {\it Ricochet}, {\it Sokoban}, and {\it Solitaire}), Picat is one to three orders of magnitude faster than Potassco, the winner of the competition. FastDownward, a winner of IPC'11, also competed in the ASP'11 Model\&Solve competition. The competition results on the planning benchmarks showed that FastDownward was not as competitive as the best-performing ASP solvers. On the Ricochet benchmark, both Picat and Potassco solved all 30 instances that were used in the ASP competition; on average, Potassco took 49.5 seconds per instance, while Picat took 9.3 seconds when no heuristic was used, and 2.2 seconds when the above heuristic was used. 

\section{Conclusion}
This paper has presented the Picat language, focusing on its modeling and solving power for combinatorial problems. Lorenz Schiffmann wrote the following in his review of an alpha release of Picat in June 2013, which nicely summarizes the features of Picat: {\it The Picat language is really cool; it's a very usable mix of logic, functional, constraint, and imperative programming. Scripts can be made quite short but also easily readable. And the built-in tabling is really cool for speeding up recursive programs. I think Picat is like a perfect Swiss army knife that you can do anything with.} 

Future work includes engineering an optimizing SAT compiler; applying tabled planning to more domains, including model-checking domains; automatic translation of action languages, such as PDDL and HTN, to Picat; and program analyzers in Picat, both for Picat itself, and for other languages.

\section*{Acknowledgements}
As acknowledged in the User's Guide \cite{PicatGuide}, many people have contributed in one form or another to the Picat project. The author thanks Jonathan Fruhman, Hakan Kjellerstrand, and Yanhong Annie Liu for reviewing this paper. This work was supported in part by the NSF under grant number CCF1018006.

\begin{thebibliography}{}

\bibitem[\protect\citeauthoryear{Appa, Pitsoulis, and Williams}{Appa
  et~al\mbox{.}}{2010}]{Appa10}
{\sc Appa, G.~M.}, {\sc Pitsoulis, L.}, {\sc and} {\sc Williams, H.~P.} 2010.
\newblock {\em Handbook on Modelling for Discrete Optimization}.
\newblock Springer.

\bibitem[\protect\citeauthoryear{Armstrong}{Armstrong}{2013}]{Armstrong13}
{\sc Armstrong, J.} 2013.
\newblock {\em Programming Erlang (2nd edition)}.
\newblock Pragmatic Press.

\bibitem[\protect\citeauthoryear{Bart{\'a}k and Zhou}{Bart{\'a}k and
  Zhou}{2014}]{BartakZ14}
{\sc Bart{\'a}k, R.} {\sc and} {\sc Zhou, N.-F.} 2014.
\newblock Using tabled logic programming to solve the {Petrobras} planning
  problem.
\newblock In {\em ICLP}.

\bibitem[\protect\citeauthoryear{Butko, Lehmann, and Ramenzoni}{Butko
  et~al\mbox{.}}{2005}]{ButoLR05}
{\sc Butko, N.}, {\sc Lehmann, K.~A.}, {\sc and} {\sc Ramenzoni, V.} 2005.
\newblock Ricochet robots - a case study for human complex problem solving.
\newblock {\em Project Thesis from the Complex Systems Summer School. Santa Fe
  Institute\/}.

\bibitem[\protect\citeauthoryear{Colmerauer}{Colmerauer}{1984}]{Colmerauer84}
{\sc Colmerauer, A.} 1984.
\newblock Equations and inequations on finite and infinite trees.
\newblock In {\em {Proceedings of FGCS}}. ICOT, 85--99.

\bibitem[\protect\citeauthoryear{Debray}{Debray}{1989}]{Debray88}
{\sc Debray, S.~K.} 1989.
\newblock Static inference of modes and data dependencies in logic programs.
\newblock {\em ACM Trans. Program. Lang. Syst.\/}~{\em 11,\/}~3, 418--450.

\bibitem[\protect\citeauthoryear{Dovier, Formisano, and Pontelli}{Dovier
  et~al\mbox{.}}{2011}]{DFP11}
{\sc Dovier, A.}, {\sc Formisano, A.}, {\sc and} {\sc Pontelli, E.} 2011.
\newblock Perspectives on logic-based approaches for reasoning about actions
  and change.
\newblock In {\em LNCS}. Vol. 6565. 259--279.

\bibitem[\protect\citeauthoryear{Fodor and Kifer}{Fodor and
  Kifer}{2010}]{FodorK10}
{\sc Fodor, P.} {\sc and} {\sc Kifer, M.} 2010.
\newblock Tabling for transaction logic.
\newblock In {\em PPDP}. 199--208.

\bibitem[\protect\citeauthoryear{Gavanelli}{Gavanelli}{2007}]{Gavanelli07}
{\sc Gavanelli, M.} 2007.
\newblock The log-support encoding of {CSP} into {SAT}.
\newblock In {\em CP}. 815--822.

\bibitem[\protect\citeauthoryear{Gebser, Jost, Kaminski, Obermeier, Sabuncu,
  Schaub, and Schneider}{Gebser et~al\mbox{.}}{2013}]{Gebser13}
{\sc Gebser, M.}, {\sc Jost, H.}, {\sc Kaminski, R.}, {\sc Obermeier, P.}, {\sc
  Sabuncu, O.}, {\sc Schaub, T.}, {\sc and} {\sc Schneider, M.} 2013.
\newblock Ricochet robots: A transverse {ASP} benchmark.
\newblock In {\em LPNMR}.

\bibitem[\protect\citeauthoryear{Gebser, Kaminski, Kaufmann, and Schaub}{Gebser
  et~al\mbox{.}}{2012}]{gekakasc12a}
{\sc Gebser, M.}, {\sc Kaminski, R.}, {\sc Kaufmann, B.}, {\sc and} {\sc
  Schaub, T.} 2012.
\newblock {\em Answer Set Solving in Practice}.
\newblock Synthesis Lectures on Artificial Intelligence and Machine Learning.
  Morgan and Claypool Publishers.

\bibitem[\protect\citeauthoryear{Guo and Gupta}{Guo and Gupta}{2008}]{GuoG08}
{\sc Guo, H.-F.} {\sc and} {\sc Gupta, G.} 2008.
\newblock Simplifying dynamic programming via mode-directed tabling.
\newblock {\em Softw., Pract. Exper.\/}~{\em 38,\/}~1, 75--94.

\bibitem[\protect\citeauthoryear{Hanus}{Hanus}{2013}]{Hanus13}
{\sc Hanus, M.} 2013.
\newblock Functional logic programming: From theory to {Curry}.
\newblock In {\em Programming Logics}. 123--168.

\bibitem[\protect\citeauthoryear{Hentenryck}{Hentenryck}{2002}]{Hentenryck02}
{\sc Hentenryck, P.~V.} 2002.
\newblock Constraint and integer programming in {OPL}.
\newblock {\em INFORMS Journal on Computing\/}~{\em 14}, 2002.

\bibitem[\protect\citeauthoryear{Hewitt}{Hewitt}{1969}]{Hewitt69}
{\sc Hewitt, C.} 1969.
\newblock Planner: A language for proving theorems in robots.
\newblock In {\em IJCAI}. 295--302.

\bibitem[\protect\citeauthoryear{Huang}{Huang}{2008}]{Huang08}
{\sc Huang, J.} 2008.
\newblock Universal {Booleanization} of constraint models.
\newblock In {\em CP}. 144--158.

\bibitem[\protect\citeauthoryear{Ianni and Krennwallner}{Ianni and
  Krennwallner}{2013}]{ASP13}
{\sc Ianni, G.} {\sc and} {\sc Krennwallner, T.} 2013.
\newblock {ASP} competition 2013.

\bibitem[\protect\citeauthoryear{Kautz and Selman}{Kautz and
  Selman}{1992}]{KautzS92}
{\sc Kautz, H.~A.} {\sc and} {\sc Selman, B.} 1992.
\newblock Planning as satisfiability.
\newblock In {\em ECAI}. 359--363.

\bibitem[\protect\citeauthoryear{Kjellerstrand}{Kjellerstrand}{2014}]{Kjellerstrand14}
{\sc Kjellerstrand, H.} 2014.
\newblock My first look at {Picat} as a modeling language for constraint
  solving and planning.
\newblock In {\em www.hakank.org}.

\bibitem[\protect\citeauthoryear{Korf}{Korf}{1985}]{Korf85}
{\sc Korf, R.~E.} 1985.
\newblock Depth-first iterative-deepening: An optimal admissible tree search.
\newblock {\em Artif. Intell.\/}~{\em 27,\/}~1, 97--109.

\bibitem[\protect\citeauthoryear{Kowalski}{Kowalski}{1979}]{Kowalski79}
{\sc Kowalski, R.} 1979.
\newblock {\em Logic for Problem Solving}.
\newblock North Holland, Elsevier.

\bibitem[\protect\citeauthoryear{Kowalski and Kuehner}{Kowalski and
  Kuehner}{1971}]{kowalski1971}
{\sc Kowalski, R.} {\sc and} {\sc Kuehner, D.} 1971.
\newblock Linear resolution with selection function.
\newblock {\em Artificial Intelligence\/}~{\em 2,\/}~3--4, 227--260.

\bibitem[\protect\citeauthoryear{Lifschitz}{Lifschitz}{2002}]{Lifschitz02}
{\sc Lifschitz, V.} 2002.
\newblock Answer set programming and plan generation.
\newblock {\em Artif. Intell.\/}~{\em 138,\/}~1-2, 39--54.

\bibitem[\protect\citeauthoryear{Malik and Zhang}{Malik and
  Zhang}{2009}]{MalikZ09}
{\sc Malik, S.} {\sc and} {\sc Zhang, L.} 2009.
\newblock {Boolean} satisfiability: from theoretical hardness to practical
  success.
\newblock {\em Commun. ACM\/}~{\em 52,\/}~8, 76--82.

\bibitem[\protect\citeauthoryear{Metodi and Codish}{Metodi and
  Codish}{2012}]{MetodiC12}
{\sc Metodi, A.} {\sc and} {\sc Codish, M.} 2012.
\newblock Compiling finite domain constraints to {SAT} with {BEE}.
\newblock {\em TPLP\/}~{\em 12,\/}~4-5, 465--483.

\bibitem[\protect\citeauthoryear{Michie}{Michie}{1968}]{Michie68}
{\sc Michie, D.} 1968.
\newblock ``memo'' functions and machine learning.
\newblock {\em Nature\/}, 19--22.

\bibitem[\protect\citeauthoryear{Nethercote, Stuckey, Becket, Brand, Duck, and
  Tack}{Nethercote et~al\mbox{.}}{2007}]{NethercoteSBBDT07}
{\sc Nethercote, N.}, {\sc Stuckey, P.~J.}, {\sc Becket, R.}, {\sc Brand, S.},
  {\sc Duck, G.~J.}, {\sc and} {\sc Tack, G.} 2007.
\newblock Minizinc: Towards a standard {CP} modelling language.
\newblock In {\em CP}. 529--543.

\bibitem[\protect\citeauthoryear{Rintanen}{Rintanen}{2012}]{Rintanen12}
{\sc Rintanen, J.} 2012.
\newblock Planning as satisfiability: Heuristics.
\newblock {\em Artif. Intell.\/}~{\em 193}, 45--86.

\bibitem[\protect\citeauthoryear{Rossi, van Beek, and Walsh}{Rossi
  et~al\mbox{.}}{2006}]{Rossi06}
{\sc Rossi, F.}, {\sc van Beek, P.}, {\sc and} {\sc Walsh, T.} 2006.
\newblock {\em Handbook of Constraint Programming}.
\newblock Elsevier.

\bibitem[\protect\citeauthoryear{Roy and Haridi}{Roy and
  Haridi}{2004}]{RoyH2004}
{\sc Roy, P.~V.} {\sc and} {\sc Haridi, S.} 2004.
\newblock {\em Concepts, Techniques, and Models of Computer Programming}.
\newblock MIT Press.

\bibitem[\protect\citeauthoryear{Sato, Zhou, Kameya, and Yizumi}{Sato
  et~al\mbox{.}}{2012}]{prism:website}
{\sc Sato, T.}, {\sc Zhou, N.-F.}, {\sc Kameya, Y.}, {\sc and} {\sc Yizumi, Y.}
  2012.
\newblock The {PRISM} user's manual.
\newblock {http://sato-www.cs.titech.ac.jp/prism/}.

\bibitem[\protect\citeauthoryear{Schimpf}{Schimpf}{2002}]{Schimpf02}
{\sc Schimpf, J.} 2002.
\newblock Logical loops.
\newblock In {\em {ICLP}}. 224--238.

\bibitem[\protect\citeauthoryear{Shapiro}{Shapiro}{1989}]{SHA89}
{\sc Shapiro, E.} 1989.
\newblock The family of concurrent logic programming languages.
\newblock {\em ACM Comput. Surveys\/}~{\em 21}, 412--510.

\bibitem[\protect\citeauthoryear{Tamaki and Sato}{Tamaki and
  Sato}{1986}]{Tamaki86}
{\sc Tamaki, H.} {\sc and} {\sc Sato, T.} 1986.
\newblock {OLD resolution with tabulation}.
\newblock In {\em {ICLP}}. 84--98.

\bibitem[\protect\citeauthoryear{Tamura, Taga, Kitagawa, and Banbara}{Tamura
  et~al\mbox{.}}{2009}]{TamuraTKB09}
{\sc Tamura, N.}, {\sc Taga, A.}, {\sc Kitagawa, S.}, {\sc and} {\sc Banbara,
  M.} 2009.
\newblock Compiling finite linear {CSP} into {SAT}.
\newblock {\em Constraints\/}~{\em 14,\/}~2, 254--272.

\bibitem[\protect\citeauthoryear{Warren}{Warren}{1974}]{warplan}
{\sc Warren, D. H.~D.} 1974.
\newblock {WARPLAN}: A system for generating plans.
\newblock Tech. Rep. DCL Memo 76, University of Edinburgh.

\bibitem[\protect\citeauthoryear{Warren}{Warren}{1992}]{warren92}
{\sc Warren, D.~S.} 1992.
\newblock Memoing for logic programs.
\newblock {\em Comm. of the ACM, Special Section on Logic Programming\/}~{\em
  35}, 93--111.

\bibitem[\protect\citeauthoryear{Zhou}{Zhou}{2006}]{zhou06ar}
{\sc Zhou, N.-F.} 2006.
\newblock Programming finite-domain constraint propagators in action rules.
\newblock {\em TPLP\/}~{\em 6,\/}~5, 483--508.

\bibitem[\protect\citeauthoryear{Zhou}{Zhou}{2012}]{Zhou12}
{\sc Zhou, N.-F.} 2012.
\newblock The language features and architecture of {B-Prolog}.
\newblock {\em TPLP, Special Issue on {Prolog} Systems\/}~{\em 12,\/}~1-2,
  189--218.

\bibitem[\protect\citeauthoryear{Zhou and Dovier}{Zhou and
  Dovier}{2013}]{ZhouD13}
{\sc Zhou, N.-F.} {\sc and} {\sc Dovier, A.} 2013.
\newblock A tabled {Prolog} program for solving {Sokoban}.
\newblock {\em Fundam. Inform.\/}~{\em 124,\/}~4, 561--575.

\bibitem[\protect\citeauthoryear{Zhou and Fruhman}{Zhou and
  Fruhman}{2014}]{PicatGuide}
{\sc Zhou, N.-F.} {\sc and} {\sc Fruhman, J.} 2014.
\newblock {A User's Guide to Picat} (picat-lang.org).

\bibitem[\protect\citeauthoryear{Zhou and Have}{Zhou and Have}{2012}]{ZhouH12}
{\sc Zhou, N.-F.} {\sc and} {\sc Have, C.~T.} 2012.
\newblock Efficient tabling of structured data with enhanced hash-consing.
\newblock {\em TPLP\/}~{\em 12,\/}~4-5, 547--563.

\bibitem[\protect\citeauthoryear{Zhou, Sato, and Shen}{Zhou
  et~al\mbox{.}}{2008}]{zhou08tab}
{\sc Zhou, N.-F.}, {\sc Sato, T.}, {\sc and} {\sc Shen, Y.-D.} 2008.
\newblock Linear tabling strategies and optimizations.
\newblock {\em TPLP\/}~{\em 8,\/}~1, 81--109.

\end{thebibliography}
\end{document}
