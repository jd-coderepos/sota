
As we have seen, there is vast space of fpc's
and there are many ways to derive new fpc's.
The question is whether all these fpc's are indeed new.
So we have to prove that they are not -convertible.

For the \bohm{} sequence we did this by an ad hoc argument
based on a syntactic invariant; 
and this method works fine to establish lots of non-equations
between the alleged `new' fpc's that we constructed above.
Still, the question remains whether there are 
not more `strategic' ways of proving such inequalities. 

In this section we propose a more strategic way 
to discriminate terms with respect to -conversion.
The idea is to extract from a -term more than just its ,
but also how the  was formed; 
one could say, in what tempo, or in what rhythm.
A  is formed from static pieces of information,
but these are rendered in a clock-wise fashion,
where the ticks of the internal clock are head reduction steps.

In the sequel we write  for
the term  where the root is \emph{annotated with }.
Here, term formation binds stronger than annotation .
For example  stands for the term 
(that is, annotating the (non-displayed) application symbol in-between  and ,
in contrast to ).
Moreover, for an annotated term  we use 
to denote the term obtaind from  by dropping all annotations (including annotations of substerms).

\begin{definition}[Clocked \bohm{} trees]\label{def:cbohm}
  Let  be a -term.
  The \emph{clocked \bohm{} tree  of }
  is an annotated potentially infinite term defined as follows.
  If  has no hnf, then define  as .
Otherwise,
  there is a head reduction  to hnf.
  Then we define 
   as the term .
\end{definition}
\noindent
The (non-clocked) \boehm{} tree of a -term 
can be obtained by dropping the annotations:
.



\begin{figure}[ht!]
  \begin{center}
  \begin{tikzpicture}[level distance=7mm,inner sep=1mm]
\node  {} \annotatednode{}{2}
        child { node {} }
        child { node {} \annotatednode{}{1}
          child { node {} }
          child { node {} \annotatednode{}{1}
            child { node {} }
            child { node {} \annotatednode{}{1}
}
          }
        };
\end{tikzpicture}
  \begin{tikzpicture}[level distance=7mm,inner sep=1mm]
\node {} \annotatednode{}{2}
        child { node {} }
        child { node {} \annotatednode{}{2}
          child { node {} }
          child { node {} \annotatednode{}{2}
            child { node {} }
            child { node {} \annotatednode{}{2}
}
          }
        };
\end{tikzpicture}
  \caption{\mbox{Clocked \bohm{} trees of  and .}}
  \vspace{-4ex}
  \label{fig:boem:y0:y1}
  \end{center}
\end{figure}
Let us consider the fpc's  of Curry and  of Turing.
We have  
where , and

Therefore we obtain 



For  where  we get:

Hence, .
Figure~\ref{fig:boem:y0:y1} displays the 
clocked \bohm{} trees of  (left) and  (right).

The following definition captures the well-known \boehm{} equality
of -terms.
\begin{definition}
  -terms  and  are \emph{-equal},
  denoted ,
  if .
\end{definition}

If  and  are not -equal then .
More generally, if for some , 
 then .
This method is know as \emph{\bohm-out technique}~\cite{bare:1984}.

Below, we refine this approach by comparing
the clocked \bohm{} trees  and 
instead of the ordinary (non-clocked) \boehm{} trees.
In general, 
does not always imply that .
Nevertheless, for a large class of -terms, called `simple' below,
this implication will turn out to be true.


We lift relations over natural numbers to relations over clocked \boehm{} trees.

\newcommand{\scbt}{T}
\newcommand{\cbt}{\sub{\scbt}}
\newcommand{\acbt}{\cbt{1}}
\newcommand{\bcbt}{\cbt{2}}

\begin{definition}
  Let  and  be clocked \boehm{} trees
  with ,
  ,
  and .

  We use  to denote that either
  both  and  are not annotated,
  or 
  both are annotated, and
  
  and 
  with .
  If  for every , 
  we write .



  We write , and say \emph{ holds eventually},
  if there exists a depth level 
  such that   for all positions  with .
\end{definition}

Next, we lift relations over clocked \bohm{} trees to -terms.
\begin{definition}
  Let ,  be -terms, and .

  We write  whenever ,
  and we have that .
  
  We write  if ,
  and for infinitely many  we have
  .
\end{definition}



In case of  () we say that 
 has a \emph{faster} (\emph{slower}) clock than .


\begin{proposition}\label{prop:clocks}
  Clocks are accelerated under reduction, 
  that is, , and slowing down under expansion.
\end{proposition}

\begin{proof}
  We proceed by an elementary diagram construction.
Whenever we have co-initial steps  and ,
  then by orthogonal projection~\cite{terese:2003}
  there exist joining steps  and .
  Note that the head step 
  cannot be duplicated, only erased in case of an overlap.
  This leads to the elementary diagram displayed in Figure~\ref{fig:elementary:diagram}.
\begin{figure}[ht!]
  \begin{center}
  \begin{tikzpicture}[thick,node distance=17mm]
    \node (M) {};
    \node (M1) [right of=M] {};
    \node (M2) [below of=M] {};
    \node (M') [below of=M1] {};
    \draw [->,shorten >= 1mm] (M) -- (M1) node [pos=.95,below] {};
    \draw [->] (M) -- (M2); \fill [fill=white,draw=black] () circle (1mm);
    \draw [->,shorten >= 2mm] (M2) -- (M') node [pos=.9,below] {} node [pos=.9,above] {};
    \draw [->] (M1) -- (M'); \fill [fill=white,draw=black] () circle (1mm);
  \end{tikzpicture}
  \vspace{-2ex}
  \caption{Elementary diagram.}
  \vspace{-2ex}
  \label{fig:elementary:diagram}
  \end{center}
  \end{figure}

  We have .
  By induction on the length of the rewrite sequence 
  it suffices to show that  implies .
  Let .
  If  has no hnf, then the same holds for , and hence .
  Therefore assume that there exists a head rewrite sequence 
   to hnf.
  We have 

  Using the elementary diagram above ( times),
  we can project  over ,
  and obtain
  , 
  
  with .
  Then
  
  and .
  Since  and  is in hnf,
  we get  for every .
  Co-recursively applying the same argument to 
  yields .
\end{proof}

While  does not imply ,
the following theorem allows us to use clocked \bohm{} trees
for discriminating -terms:
\begin{theorem}\label{thm:general}
  Let  and  be -terms.
  Assume there exists a reduct  of 
  such that for no reduct  of  we have
  .
  Then .
\end{theorem}
\begin{proof}
  If  then  and 
  for some . Hence  by Proposition~\ref{prop:clocks}.
\end{proof}

\noindent
The theorem allows us to pick 
while having to show that  for all reducts  of .
The latter condition is in general difficult to prove.
However, the theorem is of use if one of the terms 
has a manageable set of reducts, and this term happens to have slower clocks.

For a large class of -terms it turns out that clocks are invariant under reduction.
We call these terms `simple'.
\begin{definition}
  A redex  is called:
  \begin{enumerate}\setlength{\itemsep}{0ex}
    \item \emph{linear} if  has at most one occurrence in ;
    \item \emph{call-by-value} if  is a normal form; and
    \item \emph{simple} if it is linear or call-by-value.
  \end{enumerate}
\end{definition}


The definition of simple redexes generalizes the well-known notions
of call-by-value and linear redexes. 
Next, we define simple \emph{terms}.
Intuitively, we call a term  `simple' if every reduction
admitted by  only contracts simple redexes.
The following definition further generalises this intuition by considering
only standard reductions (to normal form):
\begin{definition}[Simple terms]
  A -term  is \emph{simple}
  if either  has no hnf, 
  or the head reduction to hnf 
  contracts only simple redexes,
  and  are simple terms.
\end{definition}

All the fpc's in this paper are either simple or have simple reducts.
The clock of simple -terms is invariant under reduction,
that is, when ignoring finite prefixes of the clocked \bohm{} trees
(by reducing a term we can always make the clock values
in a finite prefix equal to ).
\begin{proposition}\label{prop:simple}
  Let ,  be -terms such that  is a simple term and .
  Then , that is, the clocks of  and  are eventually equal.
\end{proposition}
\begin{proof}
  The proof is a straightforward extension of the proof of~Proposition~\ref{prop:clocks}
  with the observation that for simple terms ,
  rewriting  to hnf:
   
  does not duplicate redexes.
  Hence, the elementary diagrams
  are now of the form displayed in Figure~\ref{fig:elementary:diagram:simple}.
  \begin{figure}[ht!]
  \begin{center}
  \begin{tikzpicture}[thick,node distance=17mm]
    \node (M) {};
    \node (M1) [right of=M] {};
    \node (M2) [below of=M] {};
    \node (M') [below of=M1] {};
    \draw [->,shorten >= 1mm] (M) -- (M1) node [pos=.95,below] {};
    \draw [->] (M) -- (M2); 
    \draw [->] (M2) -- (M') node [midway,above] {};
    \draw [->] (M1) -- (M') node [midway,right] {};

    \begin{scope}[xshift=4cm]
    \node (M) {};
    \node (M1) [right of=M] {};
    \node (M2) [below of=M] {};
    \node (M') [below of=M1] {};
    \draw [->,shorten >= 1mm] (M) -- (M1) node [pos=.95,below] {};
    \draw [->] (M) -- (M2); 
    \draw [->,shorten >= 1mm] (M2) -- (M') node [pos=.9,below] {};
    \draw [->] (M1) -- (M');
    \end{scope}
  \end{tikzpicture}
  \vspace{-2ex}
  \caption{Elementary diagrams for simple .}
  \vspace{-2ex}
  \label{fig:elementary:diagram:simple}
  \end{center}
  \end{figure}
  
  That is, whenever we have co-initial steps  and 
  and  is a simple term,
  then either the steps cancel each other out  (if both are the same step),
  or they can be joined by single steps .

  As a consequence, when projecting  over a rewrite sequence 
  then either  or
  there has been cancellation and .
  Every cancellation decreases the number of steps ,
  and hence there can only finitely many cancellations.
  This implies the claim that  is equal to 
  modulo a finite prefix, that is, .
\end{proof}

Reduction accelerates clocks, i.e., .
Moreover, for simple terms the clock is invariant under reduction, see Proposition~\ref{prop:simple}.
Hence if a term  has a simple reduct , then  has the fastest clock reachable from  
modulo a finite prefix. This justifies the following convention.
\begin{convention}
  The \emph{(minimal) clock} of a -term  with a simple reduct 
  is , the clocked BT of .
\end{convention}


For simple terms we obtain the following theorem:
\begin{theorem}\label{thm:simple}
  Let  and  be -terms.
  If there exists a reduct  of 
  and a simple reduct  of  such that
  , then .
\end{theorem}
\begin{proof}
  Assume . Then  and by confluence they have a common reduct
  .
  Since  is simple, we have  by Proposition~\ref{prop:simple}.
Hence,  implies ,
  which would contradict  obtained by Proposition~\ref{prop:clocks}.
\end{proof}
Theorem~\ref{thm:simple} significantly reduces 
the proof obligation in comparison to Theorem~\ref{thm:general}.
We can pick any simple reduct  of ,
instead of having to reason about all reducts  of .
For the case that both  and  are simple, there is no need to look for reducts:
\begin{proposition}\label{cor:simple:simple}
  For simple terms  and ,
   implies .
\end{proposition}
\begin{proof}
  Assume  then  for a common reduct .
  Then  by Proposition~\ref{prop:simple}. 
  Hence  which contradicts .
\end{proof}

\begin{example}\label{ex:boehm:seq}
  Let .
  We compute the clocks of the fpc's 
   of the \boehm{} sequence.
We first reduce 
  with 
  and  to a simple term:
  
  where .
  We compute the clock:
  
  We find 
  .
  Hence, for  the clock of  is .
\end{example}
\noindent
By Theorem~\ref{thm:simple}, Example~\ref{ex:boehm:seq}
and Figure~\ref{fig:boem:y0:y1} we obtain an alternative 
proof for Theorem~\ref{thm:boehm:seq}: the \boehm{} sequence contains no duplicates.

\begin{example}\label{ex:scott:seq}
  Let .
  We compute the clocks of the fpc's 
  
  of the Scott sequence; so where .
  We first reduce  to a simple term:
  
  where .
  We abbreviate .
  Then we compute the clocks for , , and :
  
  respectively.
  For all three cases, we find: 
\end{example}
\noindent
Using Theorem~\ref{thm:simple} we infer from Example~\ref{ex:scott:seq}
and Figure~\ref{fig:boem:y0:y1} (recall that  and ):
\begin{corollary}
  The Scott sequence contains no duplicates.  
\end{corollary}

Plotkin~\cite{plot:2007} asked:
Is there an fpc  such that

or in other notation: ,
where 
.
The terms  and  have the same \boehm{} tree,
which is the solution of .

The terms  and  are not simple.
An extension of our clock method can be given 
which restricts the clock comparison to single paths in the clocked \boehm{} tree
along which there is no duplication of redexes.
We leave this extension to future work.
Using this extension would allow us to settle 
the question in the negative for all simple fpc's.
For Turing's fpc  this is seen by computing 
the clocked BT's of  and .
Recall  with .

Note that for  developing the left branch takes six steps,
whereas the right only needs three.
The clocked BT's for  and  are depicted in Figure~\ref{fig:plotkin}
using hnf-notation (see~\cite{bare:1984} or~\cite{bare:klop:2009}).

\begin{figure}[ht!]
\begin{center}
  \begin{tikzpicture}[level distance=7mm,inner sep=0.5mm,
                      level 1/.style={sibling distance=18mm},
                      level 2/.style={sibling distance=9mm},
                      level 3/.style={sibling distance=4.5mm},
                      level 4/.style={sibling distance=2.25mm}
                     ]
    \node  {} \annotatednode{}{3}
      child { node {} \annotatednode{}{3}
        child { node {} \annotatednode{}{3}
          child { node {} }
          child { node {} }
        }
        child { node {} \annotatednode{}{3}
          child { node {} }
          child { node {} }
        }
}
      child { node {} \annotatednode{}{3}
        child { node {} \annotatednode{}{3}
          child { node {} }
          child { node {} }
        }
        child { node {} \annotatednode{}{3}
          child { node {} }
          child { node {} }
        }
      };
  \end{tikzpicture}\quad
  \begin{tikzpicture}[level distance=7mm,inner sep=0.5mm,
                      level 1/.style={sibling distance=18mm},
                      level 2/.style={sibling distance=9mm},
                      level 3/.style={sibling distance=4.5mm},
                      level 4/.style={sibling distance=2.25mm}
                     ]
    \node  {} \annotatednode{}{6}
      child { node {} \annotatednode{}{6}
        child { node {} \annotatednode{}{6}
          child { node {} }
          child { node {} }
        }
        child { node {} \annotatednode{}{3}
          child { node {} }
          child { node {} }
        }
}
      child { node {} \annotatednode{}{3}
        child { node {} \annotatednode{}{6}
          child { node {} }
          child { node {} }
        }
        child { node {} \annotatednode{}{3}
          child { node {} }
          child { node {} }
        }
      };
  \end{tikzpicture}
\caption{Clocked BT's for  and .}
\label{fig:plotkin}
\end{center}
\end{figure}

We conjecture that for no fpc , ;
maybe this requires an extension of the proof in~\cite{intri:1997}.


