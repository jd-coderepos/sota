

\documentclass[creativecommons]{eptcs/eptcs}
\providecommand{\event}{LFMTP 2015}



\usepackage[pdftex]{virginialake}
\usepackage{mathdesign}
\usepackage{amsthm}
\usepackage{graphics}
\usepackage{microtype}
\usepackage{eucal}
\usepackage{eufrak}
\usepackage{xspace}

\newcommand{\bs}[0]{\fontseries{b}\selectfont}
\newcommand{\sbs}[0]{\fontseries{b}\fontshape{sl}\selectfont}
\newcommand{\nbs}[0]{\fontseries{b}\fontshape{n}\selectfont}
\newcommand{\mc}[1]{}
\newcommand{\mmc}[1]{\mathcal{#1}}
\newcommand{\mb}[1]{}
\newcommand{\mmb}[1]{\mathbb{#1}}
\newcommand{\mi}[1]{}
\newcommand{\mmi}[1]{\mathit{#1}}
\newcommand{\mf}[1]{}
\newcommand{\mmf}[1]{\mathfrak{#1}}
\newcommand{\mn}[1]{}
\newcommand{\mmn}[1]{\mathnormal{#1}}
\newcommand{\mmr}[1]{{\rm #1}}

\newcommand{\mA}{\mathcal{A}}
\newcommand{\mU}{\mathcal{U}}
\newcommand{\mE}{\mathcal{E}}
\newcommand{\mF}{\mathcal{F}}
\newcommand{\mG}{\mathcal{G}}
\newcommand{\mH}{\mathcal{H}}
\newcommand{\mI}{\mathcal{I}}
\newcommand{\mJ}{\mathcal{J}}
\newcommand{\mK}{\mathcal{K}}
\newcommand{\mP}{\mathcal{P}}
\newcommand{\mQ}{\mathcal{Q}}
\newcommand{\mR}{\mathcal{R}}
\newcommand{\mS}{\mathcal{S}}
\newcommand{\mV}{\mathcal{V}}
\newcommand{\fkP}{\mathfrak{P}}
\newcommand{\fkp}{\mathfrak{p}}
\newcommand{\fkq}{\mathfrak{q}}

\newcommand{\etal}{\textit{et al.}}
\newcommand{\qt}[1]{\textit{``\hspace*{0.2ex}#1\hspace*{0.1ex}''}}
\newcommand{\rnm}[1]{\textbf{\textit{#1}}}

\newcommand{\cmt}[1]{{\color{red}[#1]}}
\newcommand{\cmtout}[1]{}

\newcommand{\qqquad}[0]{\quad\quad\quad}
\newcommand{\qqqquad}[0]{\qquad\qquad}
\newcommand{\hps}[1]{\hspace*{#1ex}}
\newcommand{\hns}[1]{\hspace*{-#1ex}}

\newcommand{\grdef}[0]{\mathrel{\raise.5pt\hbox{}{=}}}
\newcommand{\mmid}{\:\mid\:}

\newcommand{\rar}{\longrightarrow}
\newcommand{\ral}{\longleftarrow}
\newcommand{\req}{\longleftrightarrow}

\newcommand{\Set}{\textbf{\textit{Set}}\xspace}

\renewcommand{\qed}{\hfill }
\newcommand{\qeq}{\hfill \rule{1.2ex}{1.2ex}}

\newcommand{\gseq}[2]{{#1 \hspace*{1pt}\vdash #2}}
\newcommand{\fseq}[2]{{#1 \hspace*{1pt}\vDash #2}}
\newcommand{\rseq}[1]{\vdash #1}

\newcommand{\fv}[1]{\mbox{\rm fv()}}
\newcommand{\bv}[1]{\mbox{\rm bv()}}

\newcommand{\esub}[1]{[#1]}
\newcommand{\msub}[1]{\{#1\}}
\newcommand{\rdc}[0]{\mathbin{\,\rightarrow\,}}
\newcommand{\rdcb}[0]{\rdc_{\!\!\beta}}
\newcommand{\pr}[1]{\langle\hspace*{0.1ex}#1\hspace*{0.1ex}\rangle}
\newcommand{\fst}[0]{\mathord{\texttt{fst\,}}\xspace}
\newcommand{\snd}[0]{\mathord{\texttt{snd\,}}\xspace}
\newcommand{\don}[0]{\mathord{\triangleright\;}}
\newcommand{\nod}[0]{\mathord{\triangleleft\;}}
\newcommand{\din}[0]{\mathord{\scalebox{0.9}{\texttt{\,in\,}}}\xspace}
\newcommand{\pcp}[0]{\mathord{\scalebox{0.9}{\texttt{\,@\,}}}\xspace}
\newcommand{\typ}[0]{\scalebox{0.9}{\texttt{type}}}
\newcommand{\els}[0]{\varepsilon}
\newcommand{\inl}[0]{\mathord{\scalebox{0.9}{\texttt{inl\,\,}}}\xspace}
\newcommand{\inr}[0]{\mathord{\scalebox{0.9}{\texttt{inr\,\,}}}\xspace}
\newcommand{\prl}[0]{\mathord{\scalebox{0.9}{\texttt{prl\,\,}}}\xspace}
\newcommand{\prr}[0]{\mathord{\scalebox{0.9}{\texttt{prr\,\,}}}\xspace}
\newcommand{\refl}[0]{\mathord{\scalebox{0.9}{\texttt{refl\,\,}}}\xspace}
\newcommand{\spt}[3]{#1[#2 \mid #3]}

\newcommand{\trm}[1]{{\color{red} #1}}
\newcommand{\chk}[0]{\mathbin{\Leftarrow}}
\newcommand{\syn}[0]{\mathbin{\Rightarrow}}

\newcommand{\NJ}{\textbf{NJ}\xspace}
\newcommand{\LF}{\textbf{{LF}}\xspace}
\newcommand{\LJ}{\textbf{{LJ}}\xspace}
\newcommand{\LJT}{\textbf{{LJT}}\xspace}
\newcommand{\LJF}{\textbf{{LJF}}\xspace}
\newcommand{\muLJ}{\textbf{{LJ}}\xspace}
\newcommand{\muMALL}{\textbf{{MALL}}\xspace}
\newcommand{\lbar}[0]{\smash{\overline{\lambda}}}


\newcommand{\imp}[0]{\rightarrow\xspace}
\newcommand{\nfy}[0]{\mathord{\uparrow}}
\newcommand{\pfy}[0]{\mathord{\downarrow}}



\newcommand{\iaxrule}[2]{
  \vlinf{\rnm{#1}}{}{#2}{}}
\newcommand{\irule}[3]{
  \vlinf{\rnm{#1}}{}{#2}{#3}}
\newcommand{\iruleq}[3]{
  \vliqf{\rnm{#1}}{}{#2}{#3}}
\newcommand{\iruule}[4]{
  \vliinf{\rnm{#1}}{}{#2}{#3}{#4}}
\newcommand{\iruuleq}[4]{
  \vliiqf{\rnm{#1}}{}{#2}{#3}{#4}}
\newcommand{\iruuule}[5]{
  \vliiinf{\rnm{#1}}{}{#2}{#3}{#4}{#5}}
\newcommand{\iruuuleq}[5]{
  \vliiiqf{\rnm{#1}}{}{#2}{#3}{#4}{#5}}
\newcommand{\iruuuule}[6]{
  \vliiinf{\rnm{#1}}{}{#2}{#3}{#4}{#5 \quad #6}}
\newcommand{\iruuuuleq}[6]{
  \vliiiqf{\rnm{#1}}{}{#2}{#3}{#4}{#5 \quad #6}}

\newcommand{\gseqaxrule}[3]{
  \iaxrule{#1}{\gseq{#2}{#3}}}
\newcommand{\gseqrule}[5]{
  \irule{#1}{\gseq{#2}{#3}}{\gseq{#4}{#5}}}
\newcommand{\gseqruleq}[5]{
  \iruleq{#1}{\gseq{#2}{#3}}{\gseq{#4}{#5}}}
\newcommand{\gseqruule}[7]{
  \iruule{#1}{\gseq{#2}{#3}}{\gseq{#4}{#5}}{\gseq{#6}{#7}}}
\newcommand{\gseqruuleq}[7]{
  \iruuleq{#1}{\gseq{#2}{#3}}{\gseq{#4}{#5}}{\gseq{#6}{#7}}}
\newcommand{\gseqruuule}[9]{
  \iruuule{#1}{\gseq{#2}{#3}}{\gseq{#4}{#5}}{\gseq{#6}{#7}}{\gseq{#8}{#9}}}
\newcommand{\gseqruuuleq}[9]{
  \iruuuleq{#1}{\gseq{#2}{#3}}{\gseq{#4}{#5}}{\gseq{#6}{#7}}{\gseq{#8}{#9}}}

\newcommand{\fseqaxrule}[3]{
  \iaxrule{#1}{\fseq{#2}{#3}}}
\newcommand{\fseqrule}[5]{
  \irule{#1}{\fseq{#2}{#3}}{\fseq{#4}{#5}}}
\newcommand{\fseqruleq}[5]{
  \iruleq{#1}{\fseq{#2}{#3}}{\fseq{#4}{#5}}}
\newcommand{\fseqruule}[7]{
  \iruule{#1}{\fseq{#2}{#3}}{\fseq{#4}{#5}}{\fseq{#6}{#7}}}
\newcommand{\fseqruuleq}[7]{
  \iruuleq{#1}{\fseq{#2}{#3}}{\fseq{#4}{#5}}{\fseq{#6}{#7}}}

\newcommand{\ider}[1]{\vlderivation{#1}}

\newcommand{\gdin}[4]{
  \vlin{\rnm{#1}}{}{\gseq{#2}{#3}}{#4}}
\newcommand{\gdiq}[4]{
  \vliq{\rnm{#1}}{}{\gseq{#2}{#3}}{#4}}
\newcommand{\gdiin}[5]{
  \vliin{\rnm{#1}}{}{\gseq{#2}{#3}}{#4}{#5}}
\newcommand{\gdiiq}[5]{
  \vliiq{\rnm{#1}}{}{\gseq{#2}{#3}}{#4}{#5}}
\newcommand{\gdax}[3]{
  \vlin{\rnm{#1}}{}{\gseq{#2}{#3}}{\vlhy{}}}
\newcommand{\gdtree}[3]{
  \vltr{#1}{\gseq{#2}{#3}}{\vlhy{}}{\vlhy{}}{\vlhy{}}}
\newcommand{\gdtreeh}[4]{
  \vltr{#1}{\gseq{#2}{#3}}{\vlhy{}}{#4}{\vlhy{}}}
\newcommand{\gdtrees}[4]{
  \vltr{#1}{\gseq{#2}{#3}}{\vlhy{}}{\vlhy{\hspace{#4}}}{\vlhy{}}}
\newcommand{\gdend}[2]{
  \vlhy{\gseq{#1}{#2}}}
\newcommand{\gprf}[3]{
  \vlhy{\begin{array}{c}{#1}\\\gseq{#2}{#3}\\\end{array}}}

\newcommand{\idin}[3]{
  \vlin{\rnm{#1}}{}{#2}{#3}}
\newcommand{\idiq}[3]{
  \vliq{\rnm{#1}}{}{#2}{#3}}
\newcommand{\idid}[3]{
  \vlid{\rnm{#1}}{}{#2}{#3}}
\newcommand{\idiin}[4]{
  \vliin{\rnm{#1}}{}{#2}{#3}{#4}}
\newcommand{\idax}[2]{
  \vlin{\rnm{#1}}{}{#2}{\vlhy{}}}
\newcommand{\idtrees}[3]{
  \vltr{#1}{#2}{\vlhy{}}{\vlhy{\hspace{#3}}}{\vlhy{}}}
\newcommand{\idtreec}[5]{
  \vltr{#1}{#2}{#3}{#4}{#5}}
\newcommand{\iddef}[4]{
  \vldf{#1}{}{#2}{#4}{#3}}
\newcommand{\idend}[1]{\vlhy{#1}}
\newcommand{\idde}[3]{\vlde{#1}{}{#2}{#3}}
\newcommand{\iprf}[2]{\vlpr{#1}{}{#2}}

\newcommand{\cidin}[3]{\idin{#1}{\cxi{#2}}{#3}}
\newcommand{\cidiq}[3]{\idiq{#1}{\cxi{#2}}{#3}}
\newcommand{\cidiin}[4]{\idin{#1}{\cxi{#2}}{#3}{#4}}
\newcommand{\cidax}[2]{\idax{#1}{\cxi{#2}}}
\newcommand{\cidtrees}[3]{\idtrees{#1}{\cxi{#2}}{#3}}
\newcommand{\cidend}[1]{\idend{\cxi{#1}}}
\newcommand{\cidde}[3]{\idde{#1}{\cxi{#2}}{#3}}
\newcommand{\ciprf}[2]{\iprf{#1}{\cxi{#2}}}

\newcommand{\pirule}[3]{\irule{#1}{\ctx{\pi}{#2}}{\ctx{\pi}{#3}}}
\newcommand{\nirule}[3]{\irule{#1}{\ctx{\eta}{#2}}{\ctx{\eta}{#3}}}
\newcommand{\piarule}[4]{\irule{#2}{\ctx{\pi_{#1}}{#3}}{\ctx{\pi_{#1}}{#4}}}
\newcommand{\niarule}[4]{\irule{#2}{\ctx{\eta_{#1}}{#3}}{\ctx{\eta_{#1}}{#4}}}
\newcommand{\piruleq}[3]{\iruleq{#1}{\ctx{\pi}{#2}}{\ctx{\pi}{#3}}}

\newcommand{\pidin}[3]{\idin{#1}{\cpi{#2}}{#3}}
\newcommand{\pidiq}[3]{\idiq{#1}{\cpi{#2}}{#3}}
\newcommand{\pidend}[1]{\idend{\cpi{#1}}}
\newcommand{\pidde}[2]{\idde{#1}{\cpi{#2}}}
\newcommand{\piprf}[2]{\iprf{#1}{\cpi{#2}}}
\newcommand{\nidin}[3]{\idin{#1}{\ceta{#2}}{#3}}
\newcommand{\nidiq}[3]{\idiq{#1}{\ceta{#2}}{#3}}
\newcommand{\nidend}[1]{\idend{\ceta{#1}}}
\newcommand{\niprf}[2]{\iprf{#1}{\ceta{#2}}}

 
\title{Sequent Calculus and Equational Programming \\
  {\rm \normalsize (work in progress)}}
\def\titlerunning{Sequent Calculus and Equational Programming}
\author{Nicolas Guenot and Daniel Gustafsson
\institute{IT University of Copenhagen}
\email{\{ngue,dagu\}@itu.dk}}
\def\authorrunning{N.Guenot and D. Gustafsson}

\begin{document}
\vlnosmallleftlabels

\maketitle

\begin{abstract}
Proof assistants and programming languages based on type theories usually come
in two flavours: one is based on the standard natural deduction presentation
of type theory and involves eliminators, while the other provides a syntax in
\emph{equational} style. We show here that the equational approach corresponds
to the use of a focused presentation of a type theory expressed as a sequent
calculus.~A typed functional language is presented, based on a sequent calculus,
that we relate to the syntax and internal language of Agda. In particular, we
discuss the use of patterns and case splittings, as well as rules implementing
inductive reasoning and dependent products and sums.
\end{abstract}



\section{Programming with Equations}
\label{sec:progeq}

Functional programming has proved extremely useful in making the task of writing
correct software more abstract and thus less tied to the specific, and complex,
architecture of modern computers. This, is in a large part, due to its extensive
use of types as an abstraction mechanism, specifying in a crisp way the intended
behaviour of a program, but it also relies on its \emph{declarative} style, as
a mathematical approach to functions and data structures. However, the vast gain
in expressivity obtained through the development of \emph{dependent types} makes
the programming task more challenging, as it amounts to the question of proving
complex theorems --- as illustrated by the double nature of proof
assistants such as Coq~\cite{dowek:al:93:coq} and Agda~\cite{norell:phd}.
Keeping this task as simple as possible is then of the highest importance, and
it requires the use of a clear declarative style.

There are two main avenues for specifying a language of proofs, or programs,
that is abstract enough to support complex developments involving dependent
types. The first approach, chosen by the Coq project, is to have a language
of \emph{tactics} that partially automate the construction of proofs --- that
is, to mechanically construct complex programs based on the composition of a
few generic commands. While this takes the development task closer to the
usual idea of proving a mathematical theorem, the second approach is to take
the programming viewpoint: although Coq allows to directly write proof terms,
this is better illustrated by Agda, where a syntax inspired by Haskell
\cite{haskell:www} provides a clear \emph{equational} style.

Our goal here is to investigate the relations between the equational style
of dependently-typed functional programming as found in Agda to the
proof-theoretical description of intuitionistic logic given in the sequent
calculus. In particular, we claim that a \emph{focused} sequent calculus,
akin to the \LJF system of Liang and Miller
\cite{liang:miller:09:focpol}, offers a logical foundation of choice for the
development of a practical dependently-typed language. We intend to support this
claim by showing how the equational syntax of Agda and the internal structure
of its implementation correspond to a computational interpretation of such
a calculus --- for an extended for of intuitionistic logic including
dependencies and (co)induction. As it turns out, the use of left rules
rather than eliminations for \emph{positive} connectives such as disjunction,
in sequent calculus, yields a simpler syntax. In general, beyond the use
of \emph{spines} in applications, as in \LJT \cite{herbelin:94:chseq} and
quite common in the implementation of functional programming languages or
proof assistants, the structure of the sequent calculus is much closer to
the equational style of programming than natural deduction, the standard
formalism in which type theory is usually expressed \cite{martinloef:84:itt}.
Using~a focused system rather than a plain sequent calculus based on \LJ
provides a stronger structure, and emphasizes the importance of
\emph{polarities}, already observed in type theory
\cite{abel:pientka:thibodeau:setzer:14:copat}.

Beyond the definition of a logical foundation for a functional language in
equational style, giving a proof-theoretical explanation for the way Agda
is implemented requires to accomodate in the sequent calculus both dependent
types and a notion of inductive definition. This is not an easy task, although
there has been some work on dependent types in the sequent calculus
\cite{dyckhoff:lengrand:mckinna:11:focpts} and there is a number of
approaches to inductive definitions in proof theory, including focused
systems \cite{baelde:12:mumall}. For example, the system found in
\cite{dyckhoff:lengrand:mckinna:11:focpts} is based on \LJT but is limited
to  and does not support , while \cite{dyckhoff:pinto:98:seqdep}
has both, but requires an intricate mixture of natural deduction and sequent
calculus to handle . Induction is even more complex
to handle, since there are several approaches, including
definitions \cite{schroeder-heister:93:defr} or direct least and
greatest fixpoints as found in \muMALL \cite{baelde:12:mumall} and
\muLJ \cite{baelde:phd}. From the viewpoint of proof-theory, the least
fixpoint operator  seems to be well-suited, as it embodies
the essence of induction, while the greatest fixpoint  allows to
represent coinduction. However, these operators are not used the same way
as inductive definitions found in Agda or other languages or proof assistants
--- they seem more primitive, but the encoding of usual constructs in terms
of fixpoints is not obvious. Even more complicated is the question of using
fixpoints in the presence of dependent types, and this has only been studied
from the type-theoretic viewpoint in complex systems such as the \emph{Calculus
of Inductive Constructions} \cite{coquand:paulin:88:cic}. In the end, what
we would like to obtain is a proof-theoretical understanding of the
equational style of dependent and (co)inductive programming, related to the
goals of the Epigram project. In particular, we consider that the sequent
calculus, with its use of left rules, provides access to the
\emph{``left''} of equations in a sense similar to what is
described in \cite{mcbride:mckinna:04:left}.

Here, we will describe the foundamental ideas for using a variant of \LJF
as the basis for the design of a dependently-typed programming language.
We start in Section \ref{sec:focpsc} by considering a propositional system
and show how the shape of sequent calculus rules allows to type terms in
equational style.~This is made even more obvious by the use of pattern
in the binding structure of the calculus. Then, in Section \ref{sec:depind}
we discuss the extension of this system to support dependent types and
induction, problems related to patterns in this setting, as well as the
question of which proof-theoretical approach to induction and coinduction
is better suited for use in a such a language. Finally, we conclude by
the review of some research problems opened by this investigation, and
an evaluation of the possible practical applications to languages and
proofs assistants.



\section{Focusing and Polarities in the Sequent Calculus}
\label{sec:focpsc}

We start our investigation with a propositional intuitionistic system presented
as a focused sequent calculus. It is a variant of \LJF \cite{liang:miller:09:focpol}
to which we assign a term language extending the -calculus of
Herbelin~\cite{herbelin:94:chseq}. Unlike the calculus based on \LJT, this system
has positive disjunctions and conjunctions  and , but it has
no positive atoms. We use the following grammar of formulas:

where  and  are called \emph{polarity shifts} and are meant to
maintain an explicit distinction between the two categories of formulas,
negatives and positives. This is not absolutely necessary, but it clarifies
the definition of a focused system by linking the \emph{focus} and \emph{blur}
rules to actual connectives. Note that this was also used in the presentation
of a computational interpretation of the full \LJF system
\cite{brockn:guenot:gustafsson:15:ljfoc}.

\newpage

\begin{figure}[t]
\centerline{
}
\caption{Typing rules for a pattern-based -calculus based on }
\label{figproplam}
\end{figure}

The rules we use in this system are shown in Figure \ref{figproplam}, where
the term assignment is indicated in red and several turnstiles are used to
distinguish an inversion phase  from a focused phase . In this
syntax, brackets are used to pinpoint the precise formula under focus. The
extended -calculus we use to represent proofs is based on the
following grammar:
0.1em]
  p,q & x & (p,q) & \spt{x}{p}{q} \0.1em]
  k,m & \els & t::k & \hspace*{0.5pt}\prl k \;\mmid\; \prr k \,\mmid\, \kappa p.t \\
\end{array}\begin{array}{l}
  \mathtt{f~:~(\mathbb{N}\;\times\;\mathbb{N})~\uplus~\mathbb{N}~\imp~\mathbb{N}} \\
  \mathtt{f~(inl~(x,y))~=~x~+~y} \\
  \mathtt{f~(inr~z)~=~z}
\end{array}\iruule{}{\gseq{\Psi \mmid \Gamma}{\trm{p=d \din t}:N}}
    {\fseq{\Psi}{\trm{d}:[P]} \quad}
    {\gseq{\Psi \mmid \Gamma,\trm{p}:P}{\trm{t}:N}}
  \qquad\quad
  \iruule{}{\gseq{\Psi \mmid \Gamma}{\trm{t\;k}:M}}
    {\gseq{\Psi \mmid \Gamma}{\trm{t}:N} \quad}
    {\fseq{\Psi,[N]}{\trm{k}:M}}(\lambda p.t)\;(d :: k) ~~\rdc~~ (p=d \din t)\;k(\don d)\;(\kappa p.t) ~~\rdc~~ p=d \din t\gseqrule{}{\Psi \mmid \Gamma,\trm{p \!\pcp q}:P}{\trm{t}:N}
    {\Psi \mmid \Gamma,\trm{p}:P,\trm{q}:P}{\trm{t}:N}-0.3em]
    \\
    \iruule{}{\gseq{\Psi \mmid \Gamma,\Delta\msub{d/x}}{\trm{x=d \din t}:B\msub{d/x}}}
      {\fseq{\Psi}{\trm{d}:[A]} \quad}
      {\gseq{\Psi \mmid \Gamma,\trm{x}:A,\Delta}{\trm{t}:B}}
    \qquad\quad
    \iruule{}{\gseq{\Psi \mmid \Gamma}{\trm{t\;k}:B}}
      {\gseq{\Psi \mmid \Gamma}{\trm{t}:A} \quad}
      {\fseq{\Psi,[A]}{\trm{k}:B}}\\
  \end{array} \\
  \\
  \hline
\end{array}\lambda\lbar\Pi(x:P).Npxdp\Pi(x:P).N\Sigma\land\times\prr\!\!\!\!\Sigma(x:N).MNxM\Sigma(x:P).Q\times\SigmayQ\Sigma\veeCC\msub{t/x}\kappa x.t\mu\muB\mu a.B\mu\nu\lbar\rnm{K}$. This axiom is undesirable in homotopy type theory,
and thus the restriction of dependent pattern matching has been studied
\cite{cockx:devriese:piessens:14:nok}. But this was achieved by restricting
unification in the splitting rules, and as Agda has no explicit calculus for
splitting, this was somewhat hidden. The framework we want to develop
provides a calculus and could thus help making this restriction simpler.

\vspace*{0.3em}
{\bf Acknowledgements}. This work was funded by the grant number 10-092309
from the Danish Council for Strategic Research to the \emph{Demtech} project.
\vspace*{-0.6em}

\begin{raggedright}
\bibliographystyle{eptcs/eptcs.bst}
\bibliography{cite}
\end{raggedright}

\end{document}
