

\newcommand{\AJMRequirePackage}{}
\let\AJMRequirePackage=\RequirePackage
\def\RequirePackage#1{\typeout{Loading of package `#1' deferred (don't forget it in defs.sty)}}
\documentclass[copyright,creativecommons]{eptcs}
\let\RequirePackage=\AJMRequirePackage
\let\usepackage=\RequirePackage
\providecommand{\event}{LFMTP 2011} \usepackage{defs}

\title{An Improved Implementation and \titlebreak
       Abstract Interface for Hybrid}
\author{Alan J. Martin
\institute{Department of Mathematics and Statistics,\\
University of Ottawa, Canada}
\email{amart045@site.uottawa.ca}
\and
Amy P. Felty
\institute{School of Electrical Engineering and Computer Science and\\
Department of Mathematics and Statistics,\\
University of Ottawa, Canada}
\email{afelty@site.uottawa.ca}
}

\def\titlerunning{An Improved Implementation and Abstract Interface
  for Hybrid}
\def\authorrunning{Alan J. Martin \& Amy P. Felty}

\begin{document}
\maketitle

\begin{abstract}
Hybrid is a formal theory implemented in Isabelle\slash HOL that provides
an interface for representing and reasoning about object languages using
higher-order abstract syntax (HOAS).  This interface is built around an
HOAS variable-binding operator that is constructed definitionally from
a de~Bruijn index representation.  In this paper we make a variety of
improvements to Hybrid, culminating in an abstract interface that on one
hand makes Hybrid a more mathematically satisfactory theory, and on the
other hand has important practical benefits.  We start with a modification
of Hybrid's type of terms that better hides its implementation in terms
of de~Bruijn indices, by excluding at the type level terms with dangling
indices.  We present an improved set of definitions, and a series of new
lemmas that provide a complete characterization of Hybrid's primitives
in terms of properties stated at the HOAS level.  Benefits of this new
package include a new proof of adequacy and improvements to reasoning
about object logics.  Such proofs are carried out at the higher level
with no involvement of the lower level de~Bruijn syntax.
\end{abstract}


\section{Introduction}

Hybrid is a system developed to specify and reason about logics,
programming languages, and other formal systems expressed in
higher-order abstract syntax (HOAS).  It is implemented as a formal
theory in Isabelle/HOL~\cite{nipkow/paulson/wenzel:2002}.  By
providing HOAS in a modern proof assistant, Hybrid automatically gains
the latter's capabilities for meta-theoretical reasoning.  This
approach is intended to provide advantages in flexibility and proof
automation, in contrast to systems that directly implement logical
frameworks, which must build their own meta-reasoning layers from the
ground up.  Building a system such as Hybrid within a general purpose
theorem prover poses a variety of challenges.  Our goal in this work
is to improve the implementation and interface of Hybrid's basic
theory, bringing it to a point where its potential advantages can be
more fully realized.

Using HOAS, binding constructs in the represented language (the
\emph{object logic} or OL) are encoded using the binding constructs
provided by an underlying -calculus or function space of the
meta-logic, thus representing the arguments of these constructs as
functions of the meta-level.  Isabelle/HOL implements an extension of
higher-order logic, where the function types are ``too large'' for
HOAS in two senses.  First, they contain elements with irreducible
occurrences of logical constants, which do not represent syntax.
Second, the function space  has larger
cardinality than , so a variable-binding operator represented as
a functional  of type 
cannot be injective.  This makes it unsuitable for syntax, for we
cannot uniquely recover the argument  from a term of the form
.  Our work builds directly on the original Hybrid
system~\cite{ambler/crole/momigliano:2002}, whose solution to both
problems is to use only a \emph{subset} of the funtion type,
identified by a predicate called .  It builds a type
 of terms with an HOAS variable-binding operator
\emph{definitionally} in terms of a de Bruijn index representation.

In earlier work joint with Alberto Momigliano, we gave a system
presentation of Hybrid~\cite{momigliano/martin/felty:2008}, which
built on the original Hybrid and serves as a starting point for the
work presented here.  In this paper, we fill in many details that
could not be described in a short system description, as well as make
significant further improvements, allowing us to complete a
characterization of Hybrid's type  in terms of properties
stated at the HOAS level.  In the new Hybrid, the type , its
constructors, and these properties form an abstract interface that
allows users to reason at the higher level with no involvement of the
lower level implementation details.  This interface was motivated by
and is illustrated by a new proof of representational adequacy for
Hybrid~\cite[Sect.~3.4]{martin:2010a} that does not make any reference
to de Bruijn syntax.

We start in \abbrevref{sec:hybrid-overview} by giving an abstract view
of Hybrid that motivates and explains the interface.
Sections~\ref{sec:hybrid-defn-deBruijn}--\ref{sec:hybrid-abstr2-and-abstr-LAM}
fill in many of the details of its implementation.
The type  implementing the de Bruijn index representation is
defined in \abbrevref{sec:hybrid-defn-deBruijn}, along with a
predicate  to keep track of dangling indices.  The original
Hybrid~\cite{ambler/crole/momigliano:2002} used a datatype
corresponding to our  directly as .
\abbrevref{sec:hybrid-defn-expr} defines the new version of
, which excludes at the type level terms with dangling
indices. This simplifies the representation of object languages by
eliminating the need to carry a predicate for this purpose (called
 in~\cite{ambler/crole/momigliano:2002}) along with
Hybrid terms in meta-theoretic reasoning.
Section~\ref{sec:hybrid-defn-abstr-LAM} defines Hybrid's variable
binding operator  and the  predicate.  These
definitions support a stronger injectivity property, presented in
Sect.~\ref{sec:hybrid-defn-LAM-inject} with only one 
premise rather than two.  This property was also proved
in~\cite{momigliano/martin/felty:2008}; the results here generalize
and simplify these definitions as well as simplify other related
Hybrid internals.  (In particular, we eliminate the need for the
auxiliary function  defined
in~\cite{momigliano/martin/felty:2008} using the function package first
introduced in Isabelle/HOL 2007, and we eliminate some other auxiliary
functions by using a more systematic treatment of .)

In \abbrevref{sec:hybrid-abstr2-and-abstr-LAM}, we formally prove that
a version of  for two-argument functions (as described
in~\cite{momigliano/ambler/crole:2002}) is equivalent to a conjunction
of one-argument  conditions on ``slices'' of the function
(fixing one argument).  We use this result to prove a case-distinction
lemma for functions satisfying , and a lemma that enables
compositional proof of  conditions at the HOAS level,
without conversion to de Bruijn indices as required
in~\cite{ambler/crole/momigliano:2002}.  These two lemmas represent
important new results that complete the abstract interface for Hybrid.

In \abbrevref{sec:conclude}, we discuss related work as well as
ongoing work with Hybrid.

The Isabelle/HOL 2011 theory file for the present version of Hybrid is
available online at:
\begin{center}
\url{http://hybrid.dsi.unimi.it/download/Hybrid.thy}
\end{center}
and a more thorough presentation can be found in the first author's
Ph.D.\ thesis~\cite{martin:2010a,martin:2010b}.
In addition to the results described here, this theory file also
replaces tactic-style proofs of the original version of Hybrid with
Isar proofs.  This style of proof is both more readable and more
robust against changes to the underlying proof assistant.  It also
includes rewrite rules for Isabelle's simplifier to convert
automatically between HOAS at type  and de Bruijn indices at
type .  With the improvements allowing users to work
exclusively at the HOAS level, this is no longer needed, and only
included for illustrative purposes.


\section{An Abstract View of Hybrid}
\label{sec:hybrid-overview}

We use a pretty-printed version of Isabelle\slash HOL concrete syntax
in this and the following sections.
A double colon  separates a term from its type, and the arrow
 is used in function types.
We stick to the usual logical symbols for connectives and quantifiers
(, , , , , .
Free variables (upper-case) are implicitly universally quantified
(from the outside).
The sign \ (Isabelle meta-equality) is used for equality by
definition, and  for Isabelle meta-level implication.
In the notation , the square
brackets are used to group premises to abbreviate nested implications;
in its expanded form, it is .
Similarly,  abbreviates the type
.
The keyword  introduces a new datatype, while
 introduces a recursively defined function.
We freely use infix notations, often without explicit declarations.
Other syntax is intrduced as it appears.

Isabelle\slash HOL already has extensive support for first-order abstract
syntax, in the form of its  package.  Hybrid may be viewed
as an attempt to approximate a  definition that is not
well-formed because of its higher-order features:
\begin{Display} \formal
\par\nopagebreak

\end{Display}
where  represents constants, from an OL-specific type 
(typically a trivial ;  may be used to represent
free variables, from a countably infinite type \ (actually
a synonym for ;  represents pairing, which is sufficient
to encode list- or tree-structured syntax; and  represents variable
binding in HOAS style, using the bound variable of an Isabelle\slash HOL
-abstraction to represent a bound variable of the object language.\footnote{While  and  were inspired by the untyped -calculus, in Hybrid they are used only as syntax, without built-in notions
    of -conversion, normal forms, etc.}

It should be noted that Hybrid only approximates \emph{one} such
pseudo-datatype, not the  package with its ability
to define multiple types for first-order abstract syntax.  That is,
Hybrid is \emph{untyped}, so predicates rather than types must be used
to distinguish different kinds of OL terms encoded into .

The problem with the above definition
is , whose argument type includes a negative occurrence
of \ (underlined above).  This is essential for HOAS, but it is not
permitted in a  definition
\cite[Sect.~2.6]{nipkow/paulson/wenzel:2011}, and it will require modifications
to some of the properties expected for a constructor of a datatype;
we will return to this issue later.

Hybrid does provide a type  with operators , ,
, and  of the appropriate types.  This type and the latter
three operators can be used directly as a representation of the untyped
-calculus.
When encoding OLs in general, however, it is usual to represent each OL
construct as a list built using  and headed by a  term
identifying the particular construct.  
To illustrate this idea, we take the untyped -calculus as our
OL with its usual named-variable syntax, using capital letters for
variables (,  and
-abstraction ( to avoid confusion with
Isabelle's  operator.  In this form, an object language term
  ,
for example, can be represented as

where  and  for
distinct constants .  We may use Isabelle's ability
to define abbreviations and infix notations to recover a reasonable concrete
syntax:
  
Note that although de Bruijn indices do not appear in such terms, numbers
can appear as arguments to Hybrid's  operator, which is
included to allow a representation of free variables that is distinct
from bound variables.

We now turn to the properties required of  and its operators
to function as HOAS.  We motivate the
requirements by considering adequacy, an important meta-theoretic
property.  This can take several forms, but the proof presented
in~\cite{martin:2010a} uses bijectivity of a set-theoretic semantics on
a -calculus-like subset of the Isabelle\slash HOL terms of
type , called the \defterm{syntactic terms}:
  
where  (with possible subscripts) stands for a syntactic term,
 for a variable of type ,  for a constant of
type , and  for a natural-number constant.
Note that  is an informal mathematically defined set; it is not a
formal Isabelle\slash HOL definition.

However, open terms present a complication.  Suppose we have a theory where
the semantics is bijective on \emph{closed} syntactic terms, which it maps
to a set .  Then it will map \emph{open} terms with  free variables
to functions from the Cartesian power  to .  But there are many
such functions that do not correspond to syntactic terms; for example, the
function  corresponding to the Isabelle\slash HOL term
  
of type .  Indeed, there are a countable infinity of
syntactic terms, while the set of functions from  to  is
uncountable for .

Thus, Hybrid must define a \emph{subset} of the function space to be used as
its representation for open syntactic terms.  This is done using a predicate
.  The functions satisfying
 will be those of the form
 where  is
a syntactic term with (at most) one free variable ; we call these the
\emph{syntactic functions}.\footnote{Previous work called such functions \emph{abstractions}
    \cite{ambler/crole/momigliano:2002}~-- thus the predicate name
    ; and called functions not satisfying 
    \emph{exotic terms} \cite{ambler/crole/momigliano:2002,despeyroux/felty/hirschowitz:1995}.
}
(Syntactic terms with more than one free variable can be handled one variable
at a time.)

In the first-order case, three properties hold of a type defined using
Isabelle\slash HOL's : \emph{distinctness} of the
datatype constructors, \emph{injectivity} of each constructor, and an
\emph{induction principle}.
In the case of Hybrid, distinctness of all the operators and injectivity of
the first-order operators (i.e., all except  are straightforward
to achieve, e.g.:
\begin{Display} \formal
\par\nopagebreak

\end{Display}
(These properties are used as rewrite rules for Isabelle's simplifier, to
reduce equalities of Hybrid terms with known operators on both sides; typically
this results in equalities where one side is just an Isabelle\slash HOL
variable, which can then be eliminated by substitution.\footnote{Indeed, most use of Hybrid's lemmas in object-language work is automated
    using Isabelle's simplifier and classical reasoner, and as a result,
    direct references to Hybrid's lemmas may be rare.})

Injectivity of  must be restricted to functions satisfying
; indeed, it can be proven in Isabelle\slash HOL that no
\vadjust{\pagebreak[3]}injective function from  to  exists,
by formalizing Cantor's diagonal argument.  As mentioned earlier, our
improved version requires an 
condition for only one side of the equality:
  
Requiring only a single condition
reduces the need for explicit  conditions in object-language
encodings, because they can be transported across equalities of 
terms.  It is achieved by adding to the type  an additional
constant , and defining  to take the value  on
functions not satisfying .  (The constant  will sometimes
appear as an additional case alongside the operators of Hybrid, in lemmas
that impose an  condition for the  case.  We also include
it among the syntactic terms.)

Since  appears as a premise of injectivity---and it would in any
case be needed to state properties of open syntactic terms---we must also
include properties sufficient to characterize it.  While Hybrid proves a
number of lemmas regarding  for convenience and proof automation,
the desired characterization can be given in a single statement:
{\setbox0=\hbox{}
 \xdef\ajmtemp{\the\wd0}}
\begin{Display} \formal
\notationII  ( \par\nopagebreak
\notationII  ( \isaholexists\ \localvar{a}. {} \par\nopagebreak
\notationII  ( \isaholexists\ \localvar{n}. {} \par\nopagebreak
\notationII  ( \isaholexists\ \localvar{S}\ \localvar{T}. {} \par\nopagebreak
\notationII  ( \isaholexists\ \localvar{W}. {} \par\nopagebreak
\notationII  ( 
\end{Display}

Once again the  case complicates matters: the underlined occurrence
of  applies  to a function
  .
This should be possible by using type classes to give a polymorphic definition
for , but that is future work.  The present version of Hybrid
instead replaces  with
  .

As for induction, it can take several forms.  First, a kind of size
induction on  is available, similar to size induction for
types defined by Isabelle\slash HOL's datatype package.  This
induction has limited applicability in the higher-order setting,
although it was used in the proof of adequacy~\cite{martin:2010a}.
We also retain an induction principle from the original version of
Hybrid~\cite{ambler/crole/momigliano:2002} where the first-order
induction cases are standard, while the  case is:


A common form of induction used in many case studies involves some
form of structural induction on the encoding of the inference rules of
an OL.  For this kind of reasoning, a \emph{two-level} approach is
adopted, similar in spirit to other systems such as
\emph{Twelf}~\cite{pfenning/schurmann:1999} and
\emph{Abella}~\cite{gacek:2008}.  An intermediate layer between the
meta-logic (Isabelle/HOL) and the OL, called a \emph{specification
  logic}, is defined inductively in Isabelle/HOL.  This middle layer
allows succinct and direct encodings of object logic inference rules,
which are also defined as inductive definitions.  
Successful applications of this kind of induction can be found
in~\cite{felty/momigliano:2008,martin:2010a}, for example.

Finally, Hybrid aims to build  and its operators definitionally
in Isabelle\slash HOL.  While the description above is an informal but
reasonably complete specification of Hybrid, it is not directly usable
as a definition because it is circular: the arguments of  and
 may themselves contain , and injectivity of 
depends on .  It could be formalized as an axiomatic theory,
leaving consistency as a meta-theoretical problem; but instead, Hybrid is
built definitionally in terms of a \emph{first-order} representation of
variable binding based on de~Bruijn indices.  The definitions and lemmas
involved in achieving this are the subject of the next sections.


\section{De Bruijn syntax}
\label{sec:hybrid-defn-deBruijn}

The Hybrid theory defines the type  in terms of an Isabelle\slash
HOL datatype , which represents abstract syntax using a nameless
first-order representation of bound variables called \defterm{de~Bruijn
indices} \cite{debruijn:1972}.

This approach differs from the original version of Hybrid
\cite{ambler/crole/momigliano:2002}, which used a datatype corresponding
to our  directly as ; the significance of this difference
will be explained in Sections \ref{sec:hybrid-defn-expr}~and~\ref{sec:hybrid-defn-LAM-inject}.  However, the datatype itself is very
similar, and this section follows \cite{ambler/crole/momigliano:2002} closely.

\begin{Defn}
\label{defn:hybrid-dB-type} \formal
\par\nopagebreak
\par\nopagebreak \par\nopagebreak[3]
\par\nopagebreak
\par\nopagebreak

\end{Defn}

The constructors , , and  correspond to the
operators , , and  on type , which
were discussed in \abbrevref{sec:hybrid-overview} and will be defined later.
The one significant difference is that the argument of  is a
type parameter , rather than a particular type .  This
will actually be true for  as well, and it allows Hybrid to be
defined as an OL-independent Isabelle\slash HOL theory, and later used
with OL-specific constants.  (We will frequently omit this type parameter,
except where it occurs in formal definitions or it is instantiated.)

The other three constructors (, , and  will
all be used in the definition of .  The constant  will
be a placeholder for  applied to a non-syntactic function; it was
not present in \cite{ambler/crole/momigliano:2002}, and its significance
will be explained later.  The constructor  functions as a
nameless binder, while  represents the variable implicitly
bound by the  enclosing  node.
If there are not enough  nodes, then it is called a
\defterm{dangling index}.

As an example, consider the term
  
The underlined occurrences of  and  both
refer to the variable bound by the outer \ (also underlined), while
the other occurrence of  refers to the variable bound by
the inner .   is a dangling index, because there
are only 2 enclosing  nodes.

To keep track of dangling indices, we define a predicate
  
such that  is true if enclosing the term  in
 or more  nodes would result in a term without dangling
indices.  (We omit the formal definition, which is straightforward.)
A term with no dangling indices is called \defterm{proper}, and we may
define an abbreviation
  .
These notions are standard for abstract syntax based on de~Bruijn indices
\cite{ambler/crole/momigliano:2002}.


\section{The type \ldquo expr\rdquo\ of proper de Bruijn terms}
\label{sec:hybrid-defn-expr}

Defining a type designed specifically to represent syntax has been
used in a variety of approaches to reasoning about the
-calculus and other object logics
(e.g.~\cite{Norrish:HOSC2006,Urban:JAR2008}).
Here, we use Isabelle\slash HOL's
 mechanism to define  as a bijective image of the
set of proper terms of type .\footnote{The version of
   presented here is a modification of the one used
  in~\cite{momigliano/martin/felty:2008}.}
That eliminates the 
conditions in object-language work using Hybrid, at the expense of
having to convert terms between  and  in defining
 and .  This is a good trade-off, because those
definitions are internal to Hybrid and need only be made once.  It also
turns out to be essential for strengthening the quasi-injectivity property
of , as described in \abbrevref{sec:hybrid-defn-LAM-inject}.

\begin{Defn}
\label{defn:hybrid-expr-type} \formal

\end{Defn}

This  statement first demands a proof that the specified set
is nonempty (which is trivial here).  Then it introduces the type ,
the functions  and ,
and axioms stating that they are inverse bijections between the type 
and the set .
(Although axioms are used, the overall
mechanism is a form of definitional extension and preserves consistency
of the theory.)

We may now define all of the first-order operators of Hybrid (i.e., all
except , with its functional-type argument) in the obvious way.

\begin{Defn}
\label{defn:hybrid-fo-ops} \formal
{\setbox0=\hbox{\qquad}
 \xdef\ajmtemp{\the\wd0}}
\makebox[\ajmtemp][l]{}\par\nopagebreak[3]
\makebox[\ajmtemp][l]{}\par\nopagebreak[3]
\makebox[\ajmtemp][l]{}\par\nopagebreak
\par\nopagebreak[3]
\makebox[\ajmtemp][l]{}
\end{Defn}

 is defined as if it were a separate operator, and it will sometimes
be treated as such, but it will also be generated by  applied to a
non-syntactic function.

The functions  and  translate these operators to the
corresponding constructors of \ (\abbrevref{defn:hybrid-dB-type})
and vice versa.  This is formalized by a set of lemmas that follow
straightforwardly from the definitions, of which we present just those
for \ ( as an example.

\begin{Lem}
\label{lem:hybrid-expr-dB-simps-ex} \formal
 \par\nopagebreak[3]

\end{Lem}

Distinctness and injectivity for these operators follow from the corresponding
properties of .  In \abbrevref{sec:hybrid-defn-LAM-inject}, we will
extend these results to  as well.

The  premises in the lemma above are needed because the
-generated function  is undefined on terms with
dangling indices.  These premises could be eliminated by defining a
more tightly-specified version of , satisfying the same
-generated axioms while preserving the structure of its
argument except for any dangling indices.  This was done in the previous
version of Hybrid~\cite{momigliano/martin/felty:2008}
(with the help of an auxiliary function called .  However, with a
more systematic treatment of  and some additional lemmas for it,
this was found to be unnecessary.

All versions of Hybrid follow a general pattern of making definitions and
proving lemmas first for arbitrary levels, and then deriving the desired
results for proper terms as corollaries.  In the present version, arbitrary
levels are handled by recursion and induction over de~Bruijn syntax, using
the type  and the predicate , while the results for proper
terms are stated at type .


\section{Definition of \ldquo abstr\rdquo\ and \ldquo LAM\rdquo}
\label{sec:hybrid-defn-abstr-LAM}

We now turn to the task of defining  and .
The main ideas are from \cite{ambler/crole/momigliano:2002}, but the
details of the definitions and proofs are original.  There are some
improvements over the original version of Hybrid, which will be described
in this section and \abbrevref{sec:hybrid-defn-LAM-inject}.

Since we will be defining  and  in terms of de~Bruijn
syntax, the definition of syntactic functions from
\abbrevref{sec:hybrid-overview} is not directly usable here:
we need an analogous definition using de~Bruijn syntax in place of .

For recursion, we must work with -valued functions (arbitrary levels)
rather than -valued functions.  However, the argument type need not
also be , and in fact it will be more convenient to work with functions
of type .  This simplifies the treatment of 
by avoiding negative occurrences of the type .

Thus we define the \defterm{syntactic -terms}, as a subset of
Isabelle\slash HOL terms of type , using variables of type 
converted via :
  
where  (with possible subscripts) stands for a syntactic -term,
 for a variable of type ,  for a constant of
type , and  and  for natural-number constants.
We define the \defterm{syntactic -functions} as the functions of type
 of the form , where  is
a syntactic -term with (at most) one free variable .
Such functions mix de~Bruijn indices ( with HOAS (using the
Isabelle\slash HOL bound variable  to represent an object-language
variable).

We define a predicate  to recognize the syntactic
-functions, which formally defines the so-far only
informally identified set.  We also define an auxiliary predicate
 needed in the definition of :

\begin{Defn}
\label{defn:hybrid-ordinary} \formal
\par\nopagebreak
\par\nopagebreak
\par\nopagebreak

\end{Defn}

\begin{Defn}
\label{defn:hybrid-Abstr} \formal
\par\nopagebreak

      where  is\/ , , ,
      or\/ \par\nopagebreak
\par\nopagebreak[3]
\par\nopagebreak
\par\smallskip\pagebreak[0]
\end{Defn}

Syntactically, the defining equations for  have the form of
recursion on the \emph{body} of a \hbox{-abstraction}.
Mathematically, they define  by recursion on the
\emph{common structure} of all the values of the function , i.e.,
on the common structure (if any) of  for all .
The predicate  recognizes those functions that match one of
the first three equations, so that the condition 
on the last equation may be read as ``otherwise''; that equation corresponds
to the variable case for syntactic -terms as defined above.

This definition is formalized with the help of Isabelle\slash HOL's
 command.  It demands proofs of pattern completeness,
compatibility, and termination (not shown), and then in addition to
defining  and proving its defining equations, it automatically
generates structural induction and case-distinction rules for the type
 corresponding to the pattern of recursion used
in the definition; these are called  and
 respectively, and will be referred to
later.

We may now define the predicate  in terms of  by
using post-\break composition with  to convert its function argument
from the type  to .

\begin{Defn}
\label{defn:hybrid-abstr} \formal
\par\nopagebreak

\end{Defn}

Note that unlike the situation in \cite{ambler/crole/momigliano:2002},
the definition of  does not need to impose a constraint on the
argument of , because in the case of  dangling
indices are excluded by the type of the function .

\begin{Lem}
\label{lem:hybrid-Abstr-const} \formal

\end{Lem}


The lemma  shows that any constant function of type
 satisfies .  It is used to prove a similar
property for , and will later be used directly as well.
It is proved by induction on  using \abbrevref{defn:hybrid-Abstr}
(.

\begin{Lem}
\label{lem:hybrid-abstr-simps-part1} \formal \par\nopagebreak[3]
\par\nopagebreak[3]

\end{Lem}


The lemma  is a corollary of ,
while the other two lemmas are proved directly, using
Definitions \ref{defn:hybrid-abstr} (
and \ref{defn:hybrid-Abstr} (.

These lemmas allow  conditions for syntactic functions to be
proved compositionally without unfolding the definition, except when
the body of the function contains a  subterm that involves the
function argument (so that it is not just a constant).  In that case,
previous versions of Hybrid required unfolding the definitions of 
and  to convert HOAS to de~Bruijn syntax.  The present work improves
on that situation by providing a compositional rule also for the 
case (\abbrevref{lem:hybrid-abstr-LAM} in
\abbrevref{sec:hybrid-abstr2-and-abstr-LAM}).

The lemma  will be important for Hybrid terms with nested
 operators, to show that the argument of an inner  satisfies
 when its body contains a bound variable from an outer ;
such a bound variable is a placeholder for an arbitrary term of type
, which is exactly the role of  in .

We now define the function , using the same form of recursion
that was used in the definition of .

\begin{Defn}
\label{defn:hybrid-LAM} \formal
\par\nopagebreak
\par\nopagebreak[3]
\par\nopagebreak

\end{Defn}

The function , like , first composes   with the
given function.  It then applies the auxiliary function  and
converts the resulting term from type  to type .

The function  first checks if its argument satisfies ,
and produces  if not.  (This is equivalent to checking if the
argument of  satisfies .)  The original version of
Hybrid~\cite{ambler/crole/momigliano:2002} did not do this check (and did
not have the constant , making it impossible to determine from
 whether  was a syntactic function or not.  We include
these features to support the stronger injectivity property for 
proved in \abbrevref{sec:hybrid-defn-LAM-inject}.

If its argument does satisfy , then  applies another
auxiliary function , defined by recursion, to convert HOAS to
de~Bruijn syntax; i.e., to convert the variable represented by the
function argument into a dangling de~Bruijn index.  It then applies a
new  node to bind the variable and obtain a proper de~Bruijn~term.

\begin{Defn}
\label{defn:hybrid-Lbind} \formal
\par\nopagebreak

      where  is\/ , , ,
      or\/ \par\nopagebreak
\par\nopagebreak[3]
\par\nopagebreak
 \end{Defn}

The auxiliary function  extracts the common structure of the
values of its function argument, replacing indecomposable uses of the bound
variable (i.e., functions that do not match any of the first three equations)
with .  This is a dangling de~Bruijn index, and  is
incremented each time the recursion passes an  node so that all
such instances of  will refer to the  node added by
.  The  condition checked in the definition of
 ensures that the last equation will be applied only when
.

\begin{Lem}
\label{lem:hybrid-Lbind-const} \formal

\end{Lem}


The lemma  shows that applying  to
a constant function of type  gives the constant value
of that function.  It is proved by induction on .
This lemma will be important for Hybrid terms with nested 
operators, to allow the argument of an outer  to satisfy 
when its bound variable occurs in the scope of an inner .

\begin{Lem}
\label{lem:hybrid-dB-LAM} \formal
\par\nopagebreak

\end{Lem}

The lemma  combines unfolding of \abbrevref{defn:hybrid-LAM}
( and  with cancellation of the functions  and
, using the fact that both  and
 are proper.  (Dangling indices are
excluded from  by its type, and the one introduced
by  is bound by the enclosing~.)
The lemma  is a weaker version intended as a conditional
rewrite rule for Isabelle's simplifier, to do the unfolding only if the
 condition simplifies to .

With the definitions above, Hybrid terms using \ (i.e., closed
syntactic terms) are provably equal to the corresponding de~Bruijn syntax
representations, converted to the type  using the function
.  (This is much the same situation as in
\cite{ambler/crole/momigliano:2002}, except for the type conversion
which was not necessary there.)  Thus, starting from two \emph{distinct}
representations for free variables, we have established two \emph{ambiguous}
representations for bound variables, in the sense that any given element
of  may be viewed as having either form.
In the following sections, we will state results using
the HOAS representation~( but use the de~Bruijn syntax
representation~(/ in proofs by induction, aiming to
characterize the former representation so that it stands on its own.

All versions of Hybrid have used essentially the same form of recursion to
define  and , and the corresponding form of induction
to prove their properties.  However, the means of formalizing it have varied
greatly.  The original version \cite{ambler/crole/momigliano:2002} used
inductively-defined predicates and induction on those predicates; the
following version \cite{momigliano/martin/felty:2008}
used primitive recursion and induction on an auxiliary datatype ;
while the present version avoids many of the complications of the previous
approaches with the help of the  command.

A predicate called  has also been present in all versions of
Hybrid, though it originally included the variable case as well.
Removing this case allowed  to be generalized to -valued
functions on any type; this will allow us to reuse it for binary functions in
\abbrevref{sec:hybrid-abstr2-and-abstr-LAM}.  (It is also reused for -ary
functions in \cite[Sect.~3.3]{martin:2010a}.)


\section{Injectivity of \ldquo LAM\rdquo}
\label{sec:hybrid-defn-LAM-inject}

As stated in \abbrevref{sec:hybrid-overview}, Hybrid proves injectivity of
 restricted to functions of type  satisfying
.  Improving on \cite{ambler/crole/momigliano:2002}, this property
is strengthened by requiring only one  premise, using the fact
that  maps functions not satisfying  to a recognizable
placeholder term .

We begin with an injectivity result for arbitrary de~Bruijn levels.
To state this result concisely, we first define an abbreviation 
for pointwise application of  to a function:

\begin{Defn}
\label{defn:hybrid-Level} \formal
\par\nopagebreak[3]

\end{Defn}

\begin{Lem}
\label{lem:hybrid-abstr-lbind-inject} \formal
\par\nopagebreak 
\end{Lem}

This lemma is proved by a straightforward  induction on
 using 
(from \abbrevref{defn:hybrid-Abstr}).

\begin{Theo}[Injectivity of ]
\label{theo:hybrid-LAM-inject} \formal

\end{Theo}

\begin{Proof}
If one of  and  satisfies  and the other does not,
then by \abbrevref{lem:hybrid-dB-LAM} (, one of the terms
 and  is of the form
 for some , while the other is .
But these terms cannot be equal, which contradicts the premise
.  Thus the original assumption must be false,
and we must have both  and .

We apply  to both sides of the equality 
and simplify using \ (\abbrevref{lem:hybrid-dB-LAM})
to obtain
  
 is a datatype constructor and thus injective, so we may cancel it:
  
We have  and  by
unfolding \abbrevref{defn:hybrid-abstr} (, and we also have
 and  since terms
converted from type  are proper by \autoref{defn:hybrid-expr-type}.
Thus we may apply the preceding lemma ( to deduce
.  Since  is injective, it can be canceled
to obtain , as was to be proven.
\end{Proof}

Note that  is only injective on functions from 
to  whose values are proper terms, i.e., those that factor through
, because any pre-existing dangling indices at level 1 would be
indistinguishable from those resulting from conversion of the HOAS variable.
For example,
  
Thus, without the  limiting  to proper terms,
we would not be able to avoid conditions on both  and ;
at best, we could replace one  condition
with something like .

The advantage of an injectivity property that can work with a condition on
only one of  and  is that it simplifies the elimination rules
for inductively-defined predicates on Hybrid terms, such as the formalization
of evaluation for Mini-ML with references in \cite[Sect.~5.3]{martin:2010a}.
As a result,  conditions are more often available where they are
needed, without having to add them as premises.

Distinctness of  from the first-order operators of
\autoref{defn:hybrid-fo-ops} follows straightforwardly from
\autoref{defn:hybrid-LAM}, except that  is distinct from
 only under the premise .


\section{Characterizing \ldquo abstr\rdquo}
\label{sec:hybrid-abstr2-and-abstr-LAM}

In \abbrevref{sec:hybrid-defn-abstr-LAM}, an incomplete set of simplification
rules for  was provided as \abbrevref{lem:hybrid-abstr-simps-part1}.
The missing case is .

Both previous versions of Hybrid
\cite{ambler/crole/momigliano:2002,momigliano/martin/felty:2008}
relied on conversion from HOAS to de~Bruijn syntax to handle this case.
That is sufficient for proving that particular syntactic functions satisfy
,
but it is less useful for partially-specified functions as found in
inductive proofs.

We could obtain a compositional introduction rule for this case by defining
a predicate
  
generalizing , and proving
  
This was done by Momigliano et al.\ \cite{momigliano/ambler/crole:2002};
their formal theory  is available online~\cite{felty/momigliano:2010}.
However, the  case arises again for , and for any
higher-arity generalization.  There are several ways to address this:

\begin{itemize}
\item Use Isabelle\slash HOL's axiomatic type classes to define a polymorphic
  predicate generalizing  to curried functions of arbitrary arity.
  This looks like a promising approach, but it remains as future work.
\item Find a single type that can represent functions of arbitrary arity,
  and generalize Hybrid's constructs to that type.  (Some experimental work
  has been done in that direction \cite[Sect.~3.3]{martin:2010a}.)  Such a
  type is also useful as a representation of open terms for induction.
\item Prove a result that reduces  to .  This
  seems to be the most direct solution, and it is the approach we take
  in the present work.
\end{itemize}

In this section, we will represent functions of two arguments using pairs,
rather than in the usual curried form, so that we may reuse
\abbrevref{defn:hybrid-ordinary} ( and some technical lemmas
(left unstated as they are mathematically trivial), all of which refer to
the polymorphic type .

\begin{Defn} \formal
\par\nopagebreak

\end{Defn}

The predicate  generalizes  to functions on the
Cartesian product type ; it corresponds to
 \cite{momigliano/ambler/crole:2002}.  It is defined in
the same way as , composing  with its argument and
then applying a recursively-defined auxiliary predicate .

\begin{Defn} \formal
\par\nopagebreak

      where  is\/ , , ,
      or\/ \par\nopagebreak
\par\nopagebreak[3]
\par\nopagebreak

\end{Defn}

The predicate  is similar to , except that it has
\emph{two} variable cases:  and , or
equivalently,  and .

\begin{Lem}\formal
\label{lem:hybrid-abstr2-is-componentwise}

\end{Lem}

This lemma shows that if a two-argument function satisfies  in
each argument for any fixed value of the other argument, then it satisfies
.  (And the converse, which is easier.)
We omit the formal proof, but note that it is fairly long and requires
several lemmas.

Having thus reduced  to componentwise ,
we may now derive the desired simplification rule for the case
.

\begin{Lem}
\label{lem:hybrid-abstr-LAM} \formal
\par\nopagebreak 
\end{Lem}

This lemma provides a compositional rule for proving  conditions
on functions of the form , via the reverse
direction of the biconditional.  Both directions are also used in the proof
of adequacy.  It was proved with the help of (a variant of)
\autoref{lem:hybrid-abstr2-is-componentwise}.

We consider a small example, the term ,
illustrating  by proving that the argument of the outer
 satisfies , without the use of de~Bruijn syntax:
{\setbox0=\hbox{}
 \xdef\ajmtemp{\the\wd0}}
\begin{Display} \formal
\makebox[\ajmtemp][l]{}\par\nopagebreak
\makebox[\ajmtemp][l]{}\par\nopagebreak
\makebox[\ajmtemp][l]{}\par\nopagebreak\vspace{4pt}
\makebox[\ajmtemp][l]{}\par\nopagebreak
\makebox[\ajmtemp][l]{}\par\nopagebreak
\makebox[\ajmtemp][l]{}\par\nopagebreak\vspace{4pt}
\makebox[\ajmtemp][l]{}
\end{Display}

Not only does the lemma  allow  statements
to be proved without the use of de~Bruijn syntax, but it also
completes the task of characterizing  on its own terms~--
that is, without reference to the underlying de~Bruijn syntax.
This is demonstrated in \cite{martin:2010a} by the fact that representational
adequacy follows from Hybrid's lemmas concerning the type ,
and it is a significant improvement over both previous versions of Hybrid
\cite{ambler/crole/momigliano:2002,momigliano/martin/felty:2008}.

We also obtain the characterization of  stated in
\abbrevref{sec:hybrid-overview} as a corollary of :

\begin{Lem}
\label{lem:hybrid-expand-abstr} \formal
\par\nopagebreak
\par\nopagebreak[3]
\par\nopagebreak[3]
\par\nopagebreak

\end{Lem}

\section{Conclusion}
\label{sec:conclude}

Hybrid is the first approach to formalizing variable-binding
constructs that is both based on full HOAS and is built definitionally
in a general-purpose proof assistant (Isabelle\slash HOL).  More
recently, Popescu et. al. have developed an approach motivated by a
new proof of strong normalization for System F that takes advantage of
HOAS techniques~\cite{popescu/gunter/osborn:2010}.  It is also
definitional, implements full HOAS, and is implemented in Isabelle/HOL,
though the details of the formalizations as well as the case studies
carried out in each system are quite different.  A more
in-depth comparison is the subject of future work.

There are many other related approaches, and we mention only a few
here. See~\cite{felty/momigliano:2008, martin:2010a} for a fuller
discussion.  Systems that implement logics designed specifically for
reasoning using HOAS include Twelf~\cite{pfenning/schurmann:1999} (one
of the most mature systems in this category),
Abella~\cite{gacek:2008}, and Beluga~\cite{pientka/dunfield:2010}.
These systems have the advantage of being purpose-built for reasoning
about formal systems, but this can also be a disadvantage in that they
cannot exploit the extensive libraries of formalized mathematics
available for proof assistants such as Isabelle\slash HOL.
For a comparison of Hybrid to Twelf and Beluga,
see~\cite{felty/pientka:ITP2011}.
The nominal datatype package~\cite{Urban:JAR2008} implements a
different approach which seeks to formalize equivalence of classes of
terms up to renaming of bound variables, and also the Barendregt
variable convention, using concepts from nominal
logic~\cite{GabbayPitts:FAC2002,Pitts:IandC2003}.

There are several versions of Hybrid based on the Coq proof assistant.
One such version \cite{felty/momigliano:2008} closely follows the
structure of the Isabelle\slash HOL version; another implements a
constructive variant of Hybrid for Coq~\cite{capretta/felty:2006} that
aims to leverage the use of dependent types to simplify and provide
new ways to specify OLs.  There have also been a number of
applications and case studies for Hybrid, the largest being the
comparison of five formalizations of subject reduction for Mini-ML
with references~\cite{martin:2010a}, which uses
the improved Hybrid described in this paper.  Future work includes
porting other applications to use the new Hybrid.  This will be
straightforward since they are simpler and will be further simplified
by the new interface.  Future work also includes carrying out new
case studies to further illustrate the benefits of the new Hybrid.

Although we have significantly improved Hybrid, there is always room
for further improvement.  For example, the induction principle
discussed at the end of Sect.~\ref{sec:hybrid-overview} (the one whose
 case is displayed) falls back to
named (or numbered) variables for inductive proofs, which means giving
up some of the advantages of HOAS.  We are working on a more general
approach to induction that preserves the HOAS feature of substitution
by function application.  In fact, we have proved an induction
principle for a type that represents -ary functions on the type
~\cite{martin:2010a}, which we hope will serve as the basis
for general induction principles for HOAS in Hybrid.  Its integration
into Hybrid remains as future work.  As another example, we mentioned
that Hybrid is untyped, requiring predicates to be introduced to
distinguish different kinds of OL terms encoded into .  On
one hand, these well-formedness predicates can provide a convenient
form of induction within the context of the two-level approach; on the
other hand this is a potential area for improvement.  Some work in
this direction has been done in the Coq version of
Hybrid~\cite{capretta/felty:2009}.

\begin{thebibliography}{10}
\providecommand{\bibitemdeclare}[2]{}
\providecommand{\urlprefix}{Available at }
\providecommand{\url}[1]{\texttt{#1}}
\providecommand{\href}[2]{\texttt{#2}}
\providecommand{\urlalt}[2]{\href{#1}{#2}}
\providecommand{\doi}[1]{doi:\urlalt{http://dx.doi.org/#1}{#1}}
\providecommand{\bibinfo}[2]{#2}

\bibitemdeclare{inproceedings}{ambler/crole/momigliano:2002}
\bibitem{ambler/crole/momigliano:2002}
\bibinfo{author}{Simon Ambler}, \bibinfo{author}{Roy Crole} \&
  \bibinfo{author}{Alberto Momigliano} (\bibinfo{year}{2002}):
  \emph{\bibinfo{title}{Combining Higher Order Abstract Syntax with Tactical
  Theorem Proving and (Co)Induction}}.
\newblock In: {\sl \bibinfo{booktitle}{15th International Conference on Theorem
  Proving in Higher Order Logics}}, {\sl \bibinfo{series}{LNCS}}
  \bibinfo{volume}{2410}, \bibinfo{publisher}{Springer}, pp.
  \bibinfo{pages}{13--30}, \doi{10.1007/3-540-45685-6\_3}.

\bibitemdeclare{article}{debruijn:1972}
\bibitem{debruijn:1972}
\bibinfo{author}{N.~G. de~Bruijn} (\bibinfo{year}{1972}):
  \emph{\bibinfo{title}{Lambda-calculus notation with nameless dummies: a tool
  for automatic formula manipulation with application to the {Church-Rosser}
  theorem}}.
\newblock {\sl \bibinfo{journal}{Indagationes Mathematicae}}
  \bibinfo{volume}{34}(\bibinfo{number}{5}), pp. \bibinfo{pages}{381--392}.

\bibitemdeclare{inproceedings}{capretta/felty:2006}
\bibitem{capretta/felty:2006}
\bibinfo{author}{Venanzio Capretta} \& \bibinfo{author}{Amy~P. Felty}
  (\bibinfo{year}{2007}): \emph{\bibinfo{title}{Combining de {B}ruijn Indices
  and Higher-Order Abstract Syntax in {C}oq}}.
\newblock In: {\sl \bibinfo{booktitle}{Types for Proofs and Programs, Intl.\
  Workshop, TYPES 2006}}, {\sl \bibinfo{series}{LNCS}} \bibinfo{volume}{4502},
  \bibinfo{publisher}{Springer}, pp. \bibinfo{pages}{63--77},
  \doi{10.1007/978-3-540-74464-1\_5}.

\bibitemdeclare{inproceedings}{capretta/felty:2009}
\bibitem{capretta/felty:2009}
\bibinfo{author}{Venanzio Capretta} \& \bibinfo{author}{Amy~P. Felty}
  (\bibinfo{year}{2009}): \emph{\bibinfo{title}{Higher-Order Abstract Syntax in
  Type Theory}}.
\newblock In: {\sl \bibinfo{booktitle}{Logic Colloquium '06}}, {\sl
  \bibinfo{series}{ASL Lecture Notes in Logic}}~\bibinfo{volume}{32},
  \bibinfo{publisher}{Cambridge University Press}, pp. \bibinfo{pages}{65--90}.

\bibitemdeclare{inproceedings}{despeyroux/felty/hirschowitz:1995}
\bibitem{despeyroux/felty/hirschowitz:1995}
\bibinfo{author}{Jo{\"e}lle Despeyroux}, \bibinfo{author}{Amy Felty} \&
  \bibinfo{author}{Andr{\'e} Hirschowitz} (\bibinfo{year}{1995}):
  \emph{\bibinfo{title}{Higher-Order Abstract Syntax in {Coq}}}.
\newblock In: {\sl \bibinfo{booktitle}{2nd International Conference on Typed
  Lambda Calculi and Applications}}, {\sl \bibinfo{series}{LNCS}}
  \bibinfo{volume}{902}, \bibinfo{publisher}{Springer}, pp.
  \bibinfo{pages}{124--138}, \doi{10.1007/BFb0014049}.

\bibitemdeclare{misc}{felty/momigliano:2010}
\bibitem{felty/momigliano:2010}
\bibinfo{author}{Amy Felty} \& \bibinfo{author}{Alberto Momigliano}
  (\bibinfo{year}{2010}): \emph{\bibinfo{title}{Web appendix of the paper
  ``{H}ybrid: a Definitional Two Level Approach to Reasoning with Higher Order
  Abstract Syntax''~\cite{felty/momigliano:2008}}}.
\newblock
  \bibinfo{howpublished}{\url{http://hybrid.dsi.unimi.it/jar/index.html}}.

\bibitemdeclare{inproceedings}{felty/pientka:ITP2011}
\bibitem{felty/pientka:ITP2011}
\bibinfo{author}{Amy Felty} \& \bibinfo{author}{Brigitte Pientka}
  (\bibinfo{year}{2010}): \emph{\bibinfo{title}{Reasoning with Higher-Order
  Abstract Syntax and Contexts: A Comparison}}.
\newblock In: {\sl \bibinfo{booktitle}{International Conference on Interactive
  Theorem Proving}}, {\sl \bibinfo{series}{LNCS}} \bibinfo{volume}{6172},
  \bibinfo{publisher}{Springer}, pp. \bibinfo{pages}{227--242},
  \doi{10.1007/978-3-642-14052-5\_17}.

\bibitemdeclare{unpublished}{felty/momigliano:2008}
\bibitem{felty/momigliano:2008}
\bibinfo{author}{Amy~P. Felty} \& \bibinfo{author}{Alberto{\strut} Momigliano}
  (\bibinfo{year}{2010}): \emph{\bibinfo{title}{{H}ybrid: A Definitional
  Two-Level Approach to Reasoning with Higher-Order Abstract Syntax}},
  \doi{10.1007/s10817-010-9194-x}.
\newblock \bibinfo{note}{To appear in \emph{Journal of Automated Reasoning}.
  Available at Springer Online First
  (\url{http://www.springerlink.com/content/92q14113413462t0/)}}.

\bibitemdeclare{article}{GabbayPitts:FAC2002}
\bibitem{GabbayPitts:FAC2002}
\bibinfo{author}{Murdoch Gabbay} \& \bibinfo{author}{Andrew~M. Pitts}
  (\bibinfo{year}{2002}): \emph{\bibinfo{title}{A New Approach to Abstract
  Syntax with Variable Binding}}.
\newblock {\sl \bibinfo{journal}{Formal Aspects of Computing}}
  \bibinfo{volume}{13}(\bibinfo{number}{3--5}), pp. \bibinfo{pages}{341--363},
  \doi{10.1007/s001650200016}.

\bibitemdeclare{inproceedings}{gacek:2008}
\bibitem{gacek:2008}
\bibinfo{author}{Andrew Gacek} (\bibinfo{year}{2008}):
  \emph{\bibinfo{title}{The {Abella} Interactive Theorem Prover (System
  Description)}}.
\newblock In: {\sl \bibinfo{booktitle}{4th Intl.\ Joint Conf.\ on Automated
  Reasoning}}, {\sl \bibinfo{series}{LNCS}} \bibinfo{volume}{5195},
  \bibinfo{publisher}{Springer}, pp. \bibinfo{pages}{154--161},
  \doi{10.1007/978-3-540-71070-7\_13}.

\bibitemdeclare{misc}{martin:2010b}
\bibitem{martin:2010b}
\bibinfo{author}{Alan~J. Martin} (\bibinfo{year}{2010}):
  \bibinfo{howpublished}{\url{http://hybrid.dsi.unimi.it/martinPhD/}}.
\newblock \bibinfo{note}{{I}sabelle\slash {HOL} theory files}.

\bibitemdeclare{phdthesis}{martin:2010a}
\bibitem{martin:2010a}
\bibinfo{author}{Alan~J. Martin} (\bibinfo{year}{2010}):
  \emph{\bibinfo{title}{Reasoning Using Higher-Order Abstract Syntax in a
  Higher-Order Logic Proof Environment: Improvements to {H}ybrid and a Case
  Study}}.
\newblock Ph.D. thesis, \bibinfo{school}{University of Ottawa}.

\bibitemdeclare{article}{momigliano/ambler/crole:2002}
\bibitem{momigliano/ambler/crole:2002}
\bibinfo{author}{Alberto Momigliano}, \bibinfo{author}{Simon Ambler} \&
  \bibinfo{author}{Roy~L. Crole} (\bibinfo{year}{2002}):
  \emph{\bibinfo{title}{A {H}ybrid Encoding of {H}owe's Method for Establishing
  Congruence of Bisimilarity}}.
\newblock {\sl \bibinfo{journal}{Electronic Notes in Theoretical Computer
  Science}} \bibinfo{volume}{70}(\bibinfo{number}{2}), pp.
  \bibinfo{pages}{60--75}, \doi{10.1016/S1571-0661(04)80506-1}.
\newblock \bibinfo{note}{Proceedings of LFM'02}.

\bibitemdeclare{article}{momigliano/martin/felty:2008}
\bibitem{momigliano/martin/felty:2008}
\bibinfo{author}{Alberto Momigliano}, \bibinfo{author}{Alan~J. Martin} \&
  \bibinfo{author}{Amy~P. Felty} (\bibinfo{year}{2008}):
  \emph{\bibinfo{title}{Two-Level {H}ybrid: A System for Reasoning Using
  Higher-Order Abstract Syntax}}.
\newblock {\sl \bibinfo{journal}{Electronic Notes in Theoretical Computer
  Science}} \bibinfo{volume}{196}, pp. \bibinfo{pages}{85--93},
  \doi{10.1016/j.entcs.2007.09.019}.
\newblock \bibinfo{note}{Proceedings of LFMTP'07}.

\bibitemdeclare{book}{nipkow/paulson/wenzel:2002}
\bibitem{nipkow/paulson/wenzel:2002}
\bibinfo{author}{Tobias Nipkow}, \bibinfo{author}{Lawrence~C. Paulson} \&
  \bibinfo{author}{Markus Wenzel} (\bibinfo{year}{2002}):
  \emph{\bibinfo{title}{Isabelle/{HOL}: A Proof Assistant for Higher-Order
  Logic}}.
\newblock {\sl \bibinfo{series}{LNCS}} \bibinfo{volume}{2283},
  \bibinfo{publisher}{Springer}.

\bibitemdeclare{misc}{nipkow/paulson/wenzel:2011}
\bibitem{nipkow/paulson/wenzel:2011}
\bibinfo{author}{Tobias Nipkow}, \bibinfo{author}{Lawrence{\strut}~C. Paulson}
  \& \bibinfo{author}{Markus Wenzel} (\bibinfo{year}{2011}):
  \emph{\bibinfo{title}{Isabelle's Logics: {HOL}}}.
\newblock
  \bibinfo{howpublished}{\url{http://isabelle.in.tum.de/doc/logics-HOL.pdf}}.
\newblock \bibinfo{note}{Accessed July 2011}.

\bibitemdeclare{article}{Norrish:HOSC2006}
\bibitem{Norrish:HOSC2006}
\bibinfo{author}{Michael Norrish} (\bibinfo{year}{2006}):
  \emph{\bibinfo{title}{Mechanising -Calculus using a Classical First
  Order Theory of Terms with Permutations}}.
\newblock {\sl \bibinfo{journal}{Journal of Higher Order Symbolic Computation}}
  \bibinfo{volume}{19}(\bibinfo{number}{2--3}), pp. \bibinfo{pages}{169--195},
  \doi{10.1007/s10990-006-8745-7}.

\bibitemdeclare{inproceedings}{pfenning/schurmann:1999}
\bibitem{pfenning/schurmann:1999}
\bibinfo{author}{Frank Pfenning} \& \bibinfo{author}{Carsten Sch{\"u}rmann}
  (\bibinfo{year}{1999}): \emph{\bibinfo{title}{System Description: {T}welf~---
  {A} Meta-Logical Framework for Deductive Systems}}.
\newblock In: {\sl \bibinfo{booktitle}{16th Intl.\ Conf.\ on Automated
  Deduction}}, {\sl \bibinfo{series}{LNCS}} \bibinfo{volume}{1632},
  \bibinfo{publisher}{Springer}, pp. \bibinfo{pages}{202--206},
  \doi{10.1007/3-540-48660-7\_14}.

\bibitemdeclare{inproceedings}{pientka/dunfield:2010}
\bibitem{pientka/dunfield:2010}
\bibinfo{author}{Brigitte Pientka} \& \bibinfo{author}{Joshua Dunfield}
  (\bibinfo{year}{2010}): \emph{\bibinfo{title}{Beluga:A Framework for
  Programming and Reasoning with Deductive Systems (System Description)}}.
\newblock In: {\sl \bibinfo{booktitle}{5th International Joint Conference on
  Automated Reasoning}}, {\sl \bibinfo{series}{LNCS}} \bibinfo{volume}{6173},
  \bibinfo{publisher}{Springer}, pp. \bibinfo{pages}{15--21},
  \doi{10.1007/978-3-642-14203-1\_2}.

\bibitemdeclare{article}{Pitts:IandC2003}
\bibitem{Pitts:IandC2003}
\bibinfo{author}{Andrew~M. Pitts} (\bibinfo{year}{2003}):
  \emph{\bibinfo{title}{Nominal Logic, a First Order Theory of Names and
  Binding}}.
\newblock {\sl \bibinfo{journal}{Information and Computation}}
  \bibinfo{volume}{186}(\bibinfo{number}{2}), pp. \bibinfo{pages}{165--193},
  \doi{10.1016/S0890-5401(03)00138-X}.

\bibitemdeclare{inproceedings}{popescu/gunter/osborn:2010}
\bibitem{popescu/gunter/osborn:2010}
\bibinfo{author}{Andrei Popescu}, \bibinfo{author}{Elsa~L. Gunter} \&
  \bibinfo{author}{Christopher~J. Osborn} (\bibinfo{year}{2010}):
  \emph{\bibinfo{title}{Strong Normalization for System {F} by {HOAS} on Top of
  {FOAS}}}.
\newblock In: {\sl \bibinfo{booktitle}{25th Annual IEEE Symposium on Logic in
  Computer Science}}, pp. \bibinfo{pages}{31--40}, \doi{10.1109/LICS.2010.48}.

\bibitemdeclare{article}{Urban:JAR2008}
\bibitem{Urban:JAR2008}
\bibinfo{author}{Christian Urban} (\bibinfo{year}{2008}):
  \emph{\bibinfo{title}{Nominal Techniques in Isabelle/HOL}}.
\newblock {\sl \bibinfo{journal}{Journal of Automated Reasoning}}
  \bibinfo{volume}{40}(\bibinfo{number}{4}), pp. \bibinfo{pages}{327--356},
  \doi{10.1007/s10817-008-9097-2}.

\end{thebibliography}


\end{document}
