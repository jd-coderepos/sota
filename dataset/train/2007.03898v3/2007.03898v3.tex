\documentclass{article}





\usepackage[final, nonatbib]{neurips_2020}





\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc}    \usepackage{hyperref}       \usepackage{url}            \usepackage{booktabs}       \usepackage{amsfonts}       \usepackage{nicefrac}       \usepackage{microtype}      \usepackage{threeparttable}




\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{color,soul}
\usepackage{array}
\usepackage{enumitem}
\usepackage{adjustbox}
\usepackage{wrapfig}
\usepackage{tikz}
\usetikzlibrary{automata,calc,backgrounds,arrows,positioning, shapes.misc,quotes,arrows.meta, shapes.geometric}




\newcommand{\var}{\text{Var}}
\newcommand{\cov}{\text{Cov}}
\newcommand{\vc}[1]{{\pmb{#1}}}
\newcommand{\x}{{\pmb{x}}}
\newcommand{\y}{{\pmb{y}}}
\renewcommand{\t}{{\pmb{t}}}
\newcommand{\z}{{\pmb{z}}}
\newcommand{\Z}{\pmb{Z}}
\newcommand{\train}{\text{train}}
\newcommand{\val}{\text{val}}
\newcommand{\gen}{\text{gen}}
\newcommand{\KL}[2]{\text{KL}\!\left(#1 || #2\right)}
\newcommand{\h}{{\pmb{h}}}
\renewcommand{\a}{{\pmb{a}}}
\renewcommand{\b}{{\pmb{b}}}
\renewcommand{\d}{{\pmb{d}}}
\renewcommand{\i}{{\pmb{i}}}
\newcommand{\m}{{\pmb{m}}}
\newcommand{\e}{{\pmb{e}}}
\newcommand{\g}{{\pmb{g}}}
\newcommand{\w}{{\pmb{w}}}
\newcommand{\q}{{\pmb{q}}}
\newcommand{\W}{{\pmb{W}}}
\newcommand{\A}{{\pmb{A}}}
\newcommand{\I}{{\pmb{I}}}
\newcommand{\btheta}{{\pmb{\theta}}}
\newcommand{\bzeta}{{\pmb{\zeta}}}
\newcommand{\bmu}{{\pmb{\mu}}}
\newcommand{\bSigma}{{\pmb{\Sigma}}}

\newcommand{\bphi}{{\pmb{\phi}}}
\renewcommand{\L}{{\mathcal{L}}}
\newcommand{\Ld}{{\mathcal{L}_d}}
\newcommand{\Ln}{{\mathcal{L}_n}}
\newcommand{\U}{{\mathcal{U}}}
\newcommand{\N}{{\mathcal{N}}}
\newcommand{\R}{{\mathbb{R}}}
\newcommand{\E}{{\mathbb{E}}}
\newcommand{\ent}[1]{\mathcal{H}(#1)}
\newcommand{\xent}[2]{\mathcal{H}\left(#1 || #2\right)}
\newcommand{\bhat}[2]{D_B(#1, #2)}

\newcommand{\KARSTEN}[1]{{\color{red}{[Karsten: #1]}}}
\newcommand{\JK}[1]{{\color{cyan}{[Jan: #1]}}}

\setlength{\textfloatsep}{0.5cm}


\title{NVAE: A Deep Hierarchical Variational Autoencoder }



\author{Arash Vahdat, Jan Kautz \\
  NVIDIA \\
  \texttt{\{avahdat,  jkautz\}@nvidia.com} \\
}

\begin{document}

\maketitle

\begin{abstract}
Normalizing flows, autoregressive models, variational autoencoders (VAEs), and deep energy-based models are among competing likelihood-based frameworks for deep generative learning. Among them, VAEs have the advantage of fast and tractable sampling and easy-to-access encoding networks. However, they are currently outperformed by other models such as normalizing flows and autoregressive models. While the majority of the research in VAEs is focused on the statistical challenges, we explore the orthogonal direction of carefully designing neural architectures for hierarchical VAEs. We propose Nouveau VAE (NVAE), a deep hierarchical VAE built for image generation using depth-wise separable convolutions and batch normalization. NVAE is equipped with a residual parameterization of Normal distributions and its training is stabilized by spectral regularization. We show that NVAE achieves state-of-the-art results among non-autoregressive likelihood-based models on the MNIST, CIFAR-10, CelebA 64, and CelebA HQ datasets and it provides a strong baseline on FFHQ. For example, on CIFAR-10, NVAE pushes the state-of-the-art from 2.98 to 2.91 bits per dimension, and it produces high-quality images on CelebA HQ as shown in Fig.~\ref{fig:teaser}. To the best of our knowledge, NVAE is the first successful VAE applied to natural images as large as 256$\times$256 pixels. The source code is available at {\color{blue}\url{https://github.com/NVlabs/NVAE}}.
 \end{abstract}
\section{Introduction}
The majority of the research efforts on improving VAEs~\cite{kingma2014vae, rezende2014stochastic} is dedicated to the statistical challenges, such as reducing the gap between approximate and true posterior distributions~\cite{rezendeICML15Normalizing, kingma2016improved, gregor2015draw, cremer18amortization, marino18amortized, maaloe16auxiliary, ranganath16hierarchical, vahdat2019UndirectedPost}, formulating tighter bounds~\cite{burda2015importance, li2016renyi, bornschein2016bidirectional, masrani2019thermodynamic}, reducing the gradient noise~\cite{roeder2017sticking, tucker2018doubly}, extending VAEs to discrete variables~\cite{maddison2016concrete, jang2016categorical, rolfe2016discrete, Vahdat2018DVAE++, vahdat2018dvaes, tucker2017rebar, grathwohl2017backpropagation}, or tackling posterior collapse~\cite{bowman2016generating, razavi2019collapse, gulrajani2016pixelvae,lucas2019collapse}. The role of neural network architectures for VAEs is somewhat overlooked, as most previous work borrows the architectures from classification tasks. 

\begin{figure}[!h]
\centering
\hspace{-0.2cm}
\begin{subfigure}[b]{.24\textwidth}
\centering
\includegraphics[trim={0cm 0cm 0cm 0cm}, clip=True,height=3.4cm]{images/teaser/bn_tr_0_6_340.png}
\end{subfigure}
\begin{subfigure}[b]{.24\textwidth}
\centering
\includegraphics[trim={0cm 0cm 0cm 0cm}, clip=True,height=3.4cm]{images/teaser/bn_tr_0_5_185.png}
\end{subfigure}
\begin{subfigure}[b]{.24\textwidth}
\centering
\includegraphics[trim={0cm 0cm 0cm 0cm}, clip=True,height=3.4cm]{images/teaser/bn_tr_0_8_108.png}
\end{subfigure}
\begin{subfigure}[b]{.24\textwidth}
\centering
\includegraphics[trim={0cm 0cm 0cm 0cm}, clip=True,height=3.4cm]{images/teaser/bn_tr_0_7_140.png}
\end{subfigure}

\caption{256$\times$256-pixel samples generated by NVAE, trained on CelebA HQ~\cite{karras2018progressive}.}
\label{fig:teaser}
\vspace{-0.3cm}
\end{figure} 
However, VAEs can benefit from designing special network architectures as they have fundamentally different requirements. First, VAEs maximize the mutual information between the input and latent variables~\cite{barber2004IM, alemi2016info}, requiring the networks to retain the information content of the input data as much as possible. This is in contrast with classification networks that discard information regarding the input~\cite{shwartz2017IB}. Second, VAEs often respond differently to the over-parameterization in neural networks. Since the marginal log-likelihood only depends on the generative model, overparameterizing the decoder network may hurt the test log-likelihood, whereas powerful encoders can yield better models because of reducing the amortization gap~\cite{cremer18amortization}. Wu et al.~\cite{wu2016quantitative} observe that the marginal log-likelihood, estimated by non-encoder-based methods, is not 
sensitive to the encoder overfitting (see also Fig.~9 in \cite{rolfe2016discrete}).
Moreover, the neural networks for VAEs should model long-range correlations in data~\cite{dieleman2018longrange, chen2018pixelsnail, sadeghi2019pixelvae++}, requiring the networks to have large receptive fields. Finally, due to the unbounded Kullbackâ€“Leibler (KL) divergence in the variational lower bound, training very deep hierarchical VAEs is often unstable. The current state-of-the-art VAEs~\cite{kingma2016improved, maaloe2019biva} omit batch normalization (BN)~\cite{ioffe2015batch} to combat the sources of randomness that could potentially amplify their instability. 

In this paper, we aim to \textit{make VAEs great again} by architecture design. We propose Nouveau VAE (NVAE), a deep hierarchical VAE with a carefully designed network architecture that produces high-quality images. NVAE obtains the state-of-the-art results among non-autoregressive likelihood-based generative models, reducing the gap with autoregressive models. The main building block of our network is depthwise convolutions~\cite{vanhoucke2014depth, chollet2017xception} that rapidly increase the receptive field of the network without dramatically increasing the number of parameters. 

In contrast to the previous work, we find that BN is an important component of the success of deep VAEs. We also observe that instability of training remains a major roadblock when the number of hierarchical groups is increased, independent of the presence of BN. To combat this, we propose a residual parameterization of the approximate posterior parameters to improve minimizing the KL term, and we show that spectral regularization is key to stabilizing VAE training. 


In summary, we make the following contributions: i) We propose a novel deep hierarchical VAE, called NVAE, with depthwise convolutions in its generative model. ii) We propose a new residual parameterization of the approximate posteriors. iii) We stabilize training deep VAEs with spectral regularization. iv) We provide practical solutions to reduce the memory burden of VAEs. v) We show that deep hierarchical VAEs can obtain state-of-the-art results on several image datasets, and can produce high-quality samples even when trained with the original VAE objective. To the best of our knowledge, NVAE is the first successful application of VAEs to images as large as 256$\times$256 pixels.

\textbf{Related Work:} Recently, VQ-VAE-2~\cite{razavi2019generating} demonstrated high-quality generative performance for large images. Although VQ-VAE's formulation is motivated by VAEs, its objective does not correspond to a lower bound on data log-likelihood. In contrast, NVAE is trained directly with the VAE objective. Moreover, VQ-VAE-2 uses PixelCNN~\cite{van2016pixel} in its prior for latent variables up to 128$\times$128 dims that is very slow to sample from, while NVAE uses an unconditional decoder in the data space. 

Our work is related to VAEs with inverse autoregressive flows (IAF-VAEs)~\cite{kingma2016improved}. NVAE borrows the statistical models (i.e., hierarchical prior and approximate posterior, etc.etc) from IAF-VAEs. But, it differs from IAF-VAEs in terms of i) neural networks implementing these models, ii) the parameterization of approximate posteriors, and iii) scaling up the training to large images. Nevertheless, we provide ablation experiments on these aspects, and we show that NVAE outperform the original IAF-VAEs by a large gap. Recently, BIVA~\cite{maaloe2019biva} showed state-of-the-art VAE results by extending bidirectional inference to latent variables. However, BIVA uses neural networks similar to IAF-VAE, and it is trained on images as large as 64$\times$64 px. To keep matters simple, we use the hierarchical structure from IAF-VAEs, and we focus on carefully designing the neural networks. We expect improvements in performance if more complex hierarchical models from BIVA are used. Early works DRAW~\cite{gregor2015draw} and Conv DRAW~\cite{gregor2016ConvDraw} use recurrent neural networks to model hierarchical dependencies.
 \vspace{-0.5cm}
\section{Background}\label{sec:bg}
Here, we review VAEs, their hierarchical extension, and bidirectional encoder networks~\cite{kingma2016improved, sonderby2016ladder}.

The goal of VAEs~\cite{kingma2014vae} is to train a generative model in the form of $p(\x, \z) = p(\z) p(\x|\z)$ where $p(\z)$ is a prior distribution over latent variables $\z$ and $p(\x |\z)$ is the likelihood function or decoder that generates data $\x$ given latent variables $\z$. Since the true posterior $p(\z|\x)$ is in general intractable, the generative model is trained with the aid of an approximate posterior distribution or encoder $q(\z|\x)$.

In deep hierarchical VAEs~\cite{gregor2015draw, ranganath16hierarchical, kingma2016improved, sonderby2016ladder, klushyn19hierarchicalprior}, to increase the expressiveness of both the approximate posterior and prior, the latent variables are partitioned into disjoint groups, $\z = \{ \z_1, \z_1, \dots, \z_L \}$, where $L$ is the number of groups. Then, the prior is represented by $p(\z) = \prod_l p(\z_l|\z_{<l})$ and the approximate posterior by $q(\z|\x) = \prod_l q(\z_l|\z_{<l}, \x)$ where each conditional in the prior ($p(\z_l|\z_{<l}$) and the approximate posterior ($q(\z_l|\z_{<l}, \x)$) are represented by factorial Normal distributions. We can write the variational lower bound $\L_{\text{VAE}}(\x)$ on $\log p(\x)$ as:
\begin{equation} \label{eq:hvae}
\footnotesize
    \L_{\text{VAE}}(\x) := \E_{q(\z|\x)}\left[ \log p(\x|\z) \right] - \KL{q(\z_1|\x)}{p(\z_1)} - \sum_{l=2}^L \E_{q(\z_{<l}|\x)} \left[ \KL{q(\z_l|\x, \z_{<l})}{p(\z_l|\z_{<l})} \right],
\end{equation}\begin{wrapfigure}{r}{6.0cm}
\vspace{-0.6cm}
\hspace{-0.2cm}
\begin{subfigure}[b]{.25\textwidth}
\centering
    \setlength{\belowcaptionskip}{0pt}
\includegraphics[trim={4.6cm 4.6cm 15.cm 3.7cm},clip=True,height=5.6cm]{images/networks.pdf}
    \caption{\small Bidirectional Encoder}
    \label{fig:encoder_net}
\end{subfigure}\begin{subfigure}[b]{.19\textwidth}
\centering
    \setlength{\belowcaptionskip}{0pt}
\includegraphics[trim={15.8cm 4.5cm 7.7cm 3.7cm},clip=True,height=5.6cm]{images/networks.pdf}
    \caption{Generative Model}
    \label{fig:generative_net}
\end{subfigure}
\caption{The neural networks implementing an encoder $q(\z|\x)$ and generative model $p(\x, \z)$ for a 3-group hierarchical VAE. 
\raisebox{-3pt}{\protect\tikz \protect\node [draw,scale=0.5,diamond,thick]{\bf r};} denotes residual neural networks, \raisebox{-3pt}{\protect\tikz \protect\node [draw,scale=0.6,circle,thick]{+};} denotes feature combination (e.g., concatenation), and \raisebox{-2pt}{\protect\tikz \protect\node [draw,scale=0.6,thick]{h};} is a trainable parameter.}
\label{fig:model}
\vspace{-0.6cm}
\end{wrapfigure}
where $q(\z_{<l}|\x) := \prod_{i=1}^{l-1} q(\z_i|\x, \z_{<i})$ is the approximate posterior up to the $(l-1)^{th}$ group. The objective is trained using the reparameterization trick~\cite{kingma2014vae, rezende2014stochastic}. 

The main question here is how to implement the conditionals in $p(\x, \z)$ and $q(\z|\x)$ using neural networks. For modeling the generative model, a top-down network generates the parameters of each conditional. After sampling from each group, the samples are combined with deterministic feature maps and passed to the next group (Fig.~\ref{fig:generative_net}). For inferring the latent variables in $q(\z|\x)$, we require a bottom-up deterministic network to extract representation from input $\x$. Since the order of latent variable groups are shared between $q(\z|\x)$ and $p(\z)$, we also require an additional top-down network to infer latent variables group-by-group. To avoid the computation cost of an additional top-down model, in bidirectional inference~\cite{kingma2016improved}, the representation extracted in the top-down model in the generative model is reused for inferring latent variables (Fig.~\ref{fig:encoder_net}). IAF-VAEs~\cite{kingma2016improved} relies on regular residual networks~\cite{he2016deep} for both top-down and bottom-up models without any batch normalization, and it has been examined on small images only.



 \section{Method}\label{sec:method}
In this paper, we propose a deep hierarchical VAE called NVAE that generates large high-quality images. NVAE's design focuses on tackling two main challenges: (i) designing expressive neural networks specifically for VAEs, and (ii) scaling up the training to a large number of hierarchical groups and image sizes while maintaining training stability. NVAE uses the conditional dependencies from Fig.~\ref{fig:model}, however, to address the above-mentioned challenges, it is equipped with novel network architecture modules and parameterization of approximate posteriors. Sec.~\ref{sec:nvae_net} introduces NVAE's residual cells. Sec.~\ref{sec:nvae_kl} presents our parameterization of posteriors and our solution for stable training.


\subsection{Residual Cells for Variational Autoencoders}\label{sec:nvae_net}
One of the key challenges in deep generative learning is to model the long-range correlations in data. For example, these correlations in the images of faces are manifested by a uniform skin tone and the general left-right symmetry. In the case of VAEs with unconditional decoder, such long-range correlations are encoded in the latent space and are projected back to the pixel space by the decoder. 

A common solution to the long-range correlations is to build a VAE using a hierarchical multi-scale model. Our generative model starts from a small spatially arranged latent variables as $\z_1$ and samples from the hierarchy group-by-group while gradually doubling the spatial dimensions. This multi-scale approach enables NVAE to capture global long-range correlations at the top of the hierarchy and local fine-grained dependencies at the lower groups.

\subsubsection{Residual Cells for the Generative Model}
In addition to hierarchical modeling, we can improve modeling the long-range correlations by increasing the receptive field of the networks. Since the encoder and decoder in NVAE are implemented by deep residual networks~\cite{he2016deep}, this can be done by increasing the kernel sizes in the convolutional path. However, large filter sizes come with the cost of large parameter sizes and computational complexity. In our early experiments, we empirically observed that depthwise convolutions outperform regular convolutions while keeping the number of parameters and the computational complexity orders of magnitudes smaller\footnote{A $k\times k$ regular convolution, mapping a $C$-channel tensor to the same size, has $k^2 C^2$ parameters and computational complexity of $O(k^2 C^2)$ per spatial location, whereas a depthwise convolution operating in the same regime has $k^2 C$ parameters and $O(k^2 C)$ complexity per location.}. However, depthwise convolutions have limited expressivity as they operate in each channel separately. To tackle this issue, following MobileNetV2~\cite{sandler2018mobilenetv2}, we apply these convolutions after expanding the number of channels by a $1\times 1$ regular convolution and we map their output back to original channel size using another $1\times 1$ regular convolution. 

\textbf{Batch Normalization:} The state-of-the-art VAE~\cite{kingma2016improved, maaloe2019biva} models have omitted BN as they observed that ``the noise introduced by batch normalization hurts performance''~\cite{kingma2016improved} and have relied on weight normalization (WN)~\cite{salimans16weight} instead. In our early experiments, we observed that the negative impact of BN is during evaluation, not training. Because of using running statistics in BN, the output of each BN layer can be slightly shifted during evaluation, causing a dramatic change in the network output. To fix this, we adjust the momentum hyperparameter of BN, and we apply a regularization on the norm of scaling parameters in BN layers to ensure that a small mismatch in statistics is not amplified by BN. This follows our network smoothness regularization that is discussed in Sec.~\ref{sec:nvae_kl}.

\textbf{Swish Activation:} The Swish activation~\cite{ramachandran2017swish}, $f(u) = \frac{u}{1 + e^{-u}}$, has been recently shown promising results in many applications~\cite{tan2019efficientnet, chen2019residualflows}. We also observe that the combination of BN and Swish outperforms WN and ELU activation~\cite{clevert2015fast} used by the previous works~\cite{kingma2016improved, maaloe2019biva}.

\textbf{Squeeze and Excitation (SE):} SE~\cite{hu2017squeeze} is a simple channel-wise gating layer that has been used widely in classification problems~\cite{tan2019efficientnet}. We show that SE can also improve VAEs. 

\textbf{Final cell:} Our residual cells with depthwise convolutions are visualized in Fig.~\ref{fig:cells}(a). Our cell is similar to MobileNetV2~\cite{sandler2018mobilenetv2}, with three crucial differences; It has two additional BN layers at the beginning and the end of the cell and it uses Swish activation function and SE.

\subsubsection{Residual Cells for the Encoder Model}
We empirically observe that depthwise convolutions are effective in the generative model and do not improve the performance of NVAE when they are applied to the bottom-up model in encoder. Since regular convolutions require less memory, we build the bottom-up model in encoder by residual cells visualized in Fig.~\ref{fig:cells}(b). We empirically observe that BN-Activation-Conv performs better than the original Conv-BN-Activation~\cite{he2016deep} in regular residual cells. A similar observation was made in~\cite{he2016identity}.

\begin{figure}
\vspace{-1cm}
\centering
\begin{subfigure}[b]{.55\textwidth}
\centering
    \setlength{\belowcaptionskip}{0pt}
    \includegraphics[trim={16.6cm 2cm 4cm 2cm}, clip,scale=0.42,angle=90,origin=b]{images/cells.pdf}
    \caption{Residual Cell for NVAE Generative Model}
    \label{fig:cell_dec}
\end{subfigure} \hspace{0.2cm}
\begin{subfigure}[b]{.4\textwidth}
\centering
    \setlength{\belowcaptionskip}{0pt}
    \includegraphics[trim={3cm 6cm 16cm 3cm}, clip,scale=0.42,angle=90,origin=b]{images/cells.pdf}
    \caption{Residual Cell for NVAE Encoder}
    \label{fig:cell_enc}
\end{subfigure}
\caption{The NVAE residual cells for generative and encoder models are shown in (a) and (b). The number of output channels is shown above.  The residual cell in (a) expands the number of channels $E$ times before applying the depthwise separable convolution, and then maps it back to $C$ channels. The cell in (b) applies two series of BN-Swish-Conv without changing the number of channels.}
\label{fig:cells}
\vspace{-0.2cm}
\end{figure}

\subsubsection{Reducing the Memory Requirements}
The main challenge in using depthwise convolutions is the high memory requirement imposed by the expanded features. To tackle this issue, we use two tricks: (i) We define our model in mixed-precision using the NVIDIA APEX library~\cite{apex}. This library has a list of operations (including convolutions) that can safely be cast to half-precision floats. This enables us to reduce the GPU memory by 40\%. (ii) A careful examination of the residual cells in Fig.~\ref{fig:cells} reveals that one copy of feature maps for each operation is stored for the backward pass\footnote{Swish cannot be done in place and it requires additional memory for the backward pass.}. To reduce the memory, we fuse BN and Swish and we store only one feature map for the backward pass, instead of two. This trick is known as gradient check-pointing~\cite{chen2016training, martens2012training} and it requires recomputing BN in the backward pass. The additional BN computation does not change the training time significantly, but it results in another 18\% reduction in memory usage for our model on CIFAR-10. These two tricks together help us roughly double the training throughput using a larger batch size (from 34 images/sec to 64 images/sec).


\subsection{Taming the Unbounded KL Term}\label{sec:nvae_kl}

In practice, training deep hierarchical VAE poses a great optimization challenge due to unbounded KL from $q(\z_l|\x, \z_{<l})$ to $p(\z_l|\z_{<l})$ in the objective. It is common to use two separate neural networks to generate the parameters of these distributions. However, in the case of a large number of latent variable groups, keeping these distributions in harmony is very challenging. If the encoder and decoder produce distributions far from each other during training, the sharp gradient update, resulting from KL, will push the model parameters to an unstable region, from which it is difficult to recover. Here, we propose two approaches for improving KL optimization and stabilizing the training.


\textbf{Residual Normal Distributions:}
We propose a residual distribution that parameterizes $q(\z|\x)$ relative to $p(\z)$. Let $p(z^i_l|\z_{<l}) := \N \left(\mu_i(\z_{<l}), \sigma_i(\z_{<l}) \right)$ be a Normal distribution for the $i^\textrm{th}$ variable in $\z_l$ in prior. We define
$q(z^i_l|\z_{<l}, \x) := \N \left(\mu_i(\z_{<l}) + \Delta \mu_i(\z_{<l}, \x), \sigma_i(\z_{<l}) \cdot\Delta \sigma_i(\z_{<l}, \x) \right)$,    
where $\Delta \mu_i(\z_{<l}, \x)$ and $\Delta \sigma_i(\z_{<l}, \x)$ are the relative location and scale of the approximate posterior with respect to the prior. With this parameterization, when the prior moves, the approximate posterior moves accordingly, if not changed. The benefit of this formulation can be also seen when we examine the KL term in $\L_{\text{VAE}}$:
\begin{equation}\label{eq:res_norm_kl}
\KL{q(z^i|\x)}{p(z^i)} =  \frac{1}{2}\left( \frac{\Delta \mu_i^2}{\sigma_i^2} + \Delta \sigma_i^2 - \log \Delta \sigma_i^2 - 1  \right),
\end{equation}
where we have dropped subscript $l$ and the dependencies for the ease of notation. As we can see above, if $\sigma_i$, generated by the decoder, is bounded from below, the KL term mainly depends on the relative parameters, generated by the single encoder network. We hypothesize that minimizing KL in this parameterization is easier than when $q(z^i_l|\z_{<l}, \x)$ predicts the absolute location and scale. With a similar motivation, a weighted averaging of approximate posterior and prior parameters is also introduced in \cite{sonderby2016ladder}.



\textbf{Spectral Regularization (SR):}
The residual Normal distributions do not suffice for stabilizing VAE training as KL in Eq.~\ref{eq:res_norm_kl} is still unbounded. To bound KL, we need to ensure that the encoder output does not change dramatically as its input changes. This notion of smoothness is characterized by the Lipschitz constant. We hypothesize that by regularizing the Lipschitz constant, we can ensure that the latent codes predicted by the encoder remain bounded, resulting in a stable KL minimization. 

Since estimating the Lipschitz constant of a network is intractable, we use the SR~\cite{yoshida2017spectral} that minimizes the Lipschitz constant for each layer. Formally, we add the term $\L_{SR} = \lambda \sum_i s^{(i)}$ to $\L_{\text{VAE}}$, where $s^{(i)}$ is the largest singular value of the $i^\textrm{th}$ conventional layer, estimated using a single power iteration update~\cite{yoshida2017spectral, miyato2018spectral}. Here, $\lambda$ controls to the level of smoothness imposed by $\L_{SR}$.


\textbf{More Expressive Approximate Posteriors with Normalizing Flows:}
In NVAE, $p(\z)$ and $q(\z|\x)$ are modeled by autoregressive distributions among groups and independent distributions in each group. This enables us to sample from each group in parallel efficiently. But, it also comes with the cost of less expressive distributions.
A simple solution to this problem is to apply a few additional normalizing flows to the samples generated at each group in $q(\z|\x)$. Since they are applied only in the encoder network, i) we can rely on the inverse autoregressive flows (IAF)~\cite{kingma2016improved}, as we do not require the explicit inversion of the flows, and ii) the sampling time is not increased because of the flows. 




 \begin{table*}
\caption{Comparison against the state-of-the-art likelihood-based generative models. The performance is measured in bits/dimension (bpd) for all the datasets but MNIST in which negative log-likelihood in nats is reported (lower is better in all cases). NVAE outperforms previous non-autoregressive models on most datasets and reduces the gap with autoregressive models. } \label{table:main_res}
\centering
\resizebox{0.9\linewidth}{!}{
\begin{tabular}{lcccccc}
        \toprule
        {\bf Method} & {\bf MNIST}  & {\bf CIFAR-10} & {\bf ImageNet} & {\bf CelebA} & {\bf CelebA HQ} & {\bf FFHQ} \\
                     & 28$\times$28& 32$\times$32 & 32$\times$32 & 64$\times$64 & 256$\times$256 & 256$\times$256 \\
        \midrule
        NVAE w/o flow      & \bf 78.01 & 2.93 & - & 2.04 & - & 0.71 \\
        NVAE w/ $\ $ flow  & 78.19 & \bf 2.91 & 3.92 & \bf 2.03 & \bf 0.70 & \bf 0.69 \\
        \midrule
        \multicolumn{6}{l}{\bf VAE Models with an Unconditional Decoder} \\
        BIVA~\cite{maaloe2019biva}               & 78.41 & 3.08 & 3.96 & 2.48 &- &- \\
        IAF-VAE~\cite{kingma2016improved}        & 79.10 & 3.11 & - & - & - &- \\
        DVAE++~\cite{Vahdat2018DVAE++}           & 78.49 & 3.38 & - & - & - &- \\
        Conv Draw~\cite{gregor2016ConvDraw}      & - & 3.58 & 4.40 & - & - &- \\
        \midrule
        \multicolumn{6}{l}{\bf Flow Models \underline{without} any Autoregressive Components in the Generative Model} \\
        VFlow~\cite{chen2020vflow}             & - & 2.98 & - & - & -  & - \\
        ANF~\cite{huang2020anf}                & - & 3.05 & 3.92 & - & 0.72 & - \\
        Flow++~\cite{ho19flow++}    & - & 3.08 & \bf 3.86 & -    & - & - \\
        Residual flow~\cite{chen2019residualflows}      & - & 3.28 & 4.01 & - & 0.99 & -  \\
        GLOW~\cite{kingma2018glow}               & - & 3.35 & 4.09 & - & 1.03 & - \\
        Real NVP~\cite{dinh2016realnvp}           & - & 3.49 & 4.28 & 3.02 & -    & - \\
        \midrule
        \midrule
        \multicolumn{6}{l}{\bf VAE and Flow Models with Autoregressive Components in the Generative Model} \\
        $\delta$-VAE~\cite{razavi2019collapse} & - & 2.83  & 3.77  & - & - & -\\
        PixelVAE++~\cite{sadeghi2019pixelvae++}
                          & 78.00 & 2.90  & -  & - & - & -\\
        VampPrior~\cite{tomczak2018VampPrior}         & 78.45 & - & - & - & - & - \\
        MAE~\cite{ma2019mae}               & 77.98 & 2.95 & - & - & - & -\\
        Lossy VAE~\cite{chen2016lossy}         & 78.53 & 2.95 & - & - & -  & -\\
        MaCow~\cite{ma19MaCow}             & - & 3.16 & - & - & 0.67 & - \\
        \midrule
        \multicolumn{6}{l}{\bf Autoregressive Models} \\
        SPN~\cite{menick2018spn}                & - & - & 3.85 & - & 0.61 & - \\
        PixelSNAIL~\cite{chen2018pixelsnail}         & - & 2.85 & 3.80 & - & - & - \\
        Image Transformer~\cite{parmar2018image}  & - & 2.90 & 3.77 & - & - & -\\
        PixelCNN++~\cite{salimans2017pixelcnn++}         & - & 2.92 & - & - & - & -\\
        PixelRNN~\cite{van2016pixel}           & - & 3.00 & 3.86 & - & - & -\\
        Gated PixelCNN~\cite{van2016conditional}     & - & 3.03 & 3.83 & - & - & -\\
        \bottomrule
        
        
    \end{tabular}}
\end{table*}
 
\captionsetup{skip=2pt}

\section{Experiments}\label{sec:expr}

In this section, we examine NVAE on several image datasets. We present the main quantitative results in Sec.~\ref{sec:main_res}, qualitative results in Sec.~\ref{sec:qual_res} and ablation experiments in Sec.~\ref{sec:ab_res}.

\subsection{Main Quantitative Results}\label{sec:main_res}
We examine NVAE on the dynamically binarized MNIST~\cite{lecun1998mnist}, CIFAR-10~\cite{krizhevsky2009cifar}, ImageNet $32\times32$~\cite{deng2009imagenet}, CelebA $64\times64$~\cite{liu2015celeba, larsen2016autoencoding}, CelebA HQ 256$\times$256~\cite{karras2018progressive}, and FFHQ 256$\times$256~\cite{karras2019style} datasets. All the datasets except FFHQ are commonly used for evaluating likelihood-based generative models. FFHQ is a challenging dataset, consisting of facial images. We reduce the resolution of the images in FFHQ to 256$\times$256. To the best of our knowledge, NVAE is the first VAE model trained on FFHQ. 

We build NVAE using the hierarchical structure shown in Fig.~\ref{fig:model} and residual cells shown in Fig.~\ref{fig:cells}.
For large image datasets such as CelebA HQ and FFHQ, NVAE consists of 36 groups of latent variables starting from $8\times8$ dims, scaled up to $128\times128$ dims with two residual cells per latent variable groups. The implementation details are provided in Sec.~\ref{app:imp_det} in Appendix.

The results are reported in Table~\ref{table:main_res}. NVAE outperforms the state-of-the-art non-autoregressive flow and VAE models including IAF-VAE~\cite{kingma2016improved} and BIVA~\cite{maaloe2019biva} on all the datasets, but ImageNet, in which NVAE comes second after Flow++\cite{ho19flow++}. On CIFAR-10, NVAE improves the state-of-the-art from 2.98 to 2.91 bpd. It also achieves very competitive performance compared to the autoregressive models.  Moreover, we can see that NVAE's performance is only slightly improved by applying flows in the encoder, and the model without flows outperforms many existing generative models by itself. This indicates that the network architecture is an important component in VAEs and a carefully designed network with Normal distributions in encoder can compensate for some of the statistical challenges.

\subsection{Qualitative Results}\label{sec:qual_res}
\begin{figure}[t]
\vspace{-0.5cm}
\centering
\begin{subfigure}[b]{.32\textwidth}
\centering
    \setlength{\belowcaptionskip}{1pt}
    \vspace{-0.4cm}
    \includegraphics[trim={0cm 0cm 0cm 0cm}, clip=True,height=4.5cm]{images/mnist.png}
    \caption{MNIST ($t = 1.0$)}
    \label{fig:mnist}
\end{subfigure}
\begin{subfigure}[b]{.32\textwidth}
\centering
    \setlength{\belowcaptionskip}{1pt}
    \vspace{-0.4cm}
    \includegraphics[trim={0cm 0cm 0cm 0cm}, clip=True,height=4.5cm]{images/cifar10.png}
    \caption{CIFAR-10 ($t = 0.7$)}
    \label{fig:cifar10}
\end{subfigure}
\begin{subfigure}[b]{.32\textwidth}
\centering
    \setlength{\belowcaptionskip}{1pt}
    \includegraphics[trim={0cm 0cm 0cm 0cm}, clip=True,height=4.5cm]{images/celeba_bn_tr_0.6_8.png}
    \caption{CelebA 64 ($t = 0.6$)}
    \label{fig:celeba64}
\end{subfigure} \\
\begin{subfigure}[b]{.49\textwidth}
\centering
    \setlength{\belowcaptionskip}{1pt}
    \includegraphics[trim={0cm 0cm 0cm 0cm}, clip=True,height=4.5cm]{images/bn_tr_0_6_0.png}
    \caption{CelebA HQ ($t = 0.6$)}
    \label{fig:celeba_hq}
\end{subfigure}
\begin{subfigure}[b]{.49\textwidth}
\centering
    \setlength{\belowcaptionskip}{1pt}
    \includegraphics[trim={0cm 0cm 0cm 0cm}, clip=True,height=4.5cm]{images/bn_tr_0_5_4.png}
    \caption{FFHQ ($t = 0.5$)}
    \label{fig:ffhq}
\end{subfigure} \\
\begin{subfigure}[b]{.49\textwidth}
\centering
    \setlength{\belowcaptionskip}{1pt}
    \includegraphics[trim={0cm 0cm 0cm 0cm}, clip=True,height=4.5cm]{images/macow.png}
    \caption{MaCow~\cite{ma19MaCow} trained on CelebA HQ ($t = 0.7$)}
    \label{fig:macow}
\end{subfigure}
\begin{subfigure}[b]{.49\textwidth}
\centering
    \setlength{\belowcaptionskip}{1pt}
    \includegraphics[trim={0cm 0cm 0cm 0cm}, clip=True,height=4.5cm]{images/glow.png}
    \caption{Glow~\cite{kingma2018glow} trained on CelebA HQ ($t = 0.7$)}
    \label{fig:glow}
\end{subfigure}
\caption{(a)-(e) Sampled images from NVAE with the temperature in prior ($t$). (f)-(g) A few images generated by MaCow~\cite{ma19MaCow} and Glow~\cite{kingma2018glow} are shown for comparison (images are from the original publications). NVAE generates diverse high quality samples even with a small temperature, and it exhibits remarkably better hair details and diversity (best seen when zoomed in).}
\label{fig:main_qual}
\end{figure} 
For visualizing generated samples on challenging datasets such as CelebA HQ, it is common to lower the temperature of the prior to samples from the potentially high probability region in the model~\cite{kingma2018glow}. This is done by scaling down the standard deviation of the Normal distributions in each conditional in the prior, and it often improves the quality of the samples, but it also reduces their diversity.

In NVAE, we observe that if we use the single batch statistics during sampling for the BN layers, instead of the default running averages, we obtain much more diverse and higher quality samples even with small temperatures\footnote{For the evaluation in Sec.~\ref{sec:main_res}, we do use the default setting to ensure that our reported results are valid.}. A similar observation was made in BigGAN~\cite{brock2018biggan} and DCGAN~\cite{radford2015dcgan}. However, in this case, samples will depend on other data points in the batch. To avoid this, similar to BigGAN, we readjust running mean and standard deviation in the BN layers by sampling from the generative model 500 times for the given temperature, and then we use the readjusted statistics for the final sampling\footnote{This intriguing effect of BN on VAEs and GANs requires further study in future work. We could not obtain the same quantitative and qualitative results with instance norm which is a batch-independent extension to BN.}. We visualize samples with the default BN behavior in Sec.~\ref{app:temp} in the appendix.

Fig.~\ref{fig:main_qual} visualizes the samples generated by NVAE along with the samples from MaCow~\cite{ma19MaCow} and Glow~\cite{kingma2018glow} on CelebA HQ for comparison. As we can see, NVAE produces high quality and diverse samples even with small temperatures. 


\subsection{Ablation Studies}\label{sec:ab_res}
\begin{figure}[t]
\vspace{-0.5cm}
\centering
\begin{subfigure}[b]{.49\textwidth}
\centering
    \setlength{\belowcaptionskip}{1pt}
    \vspace{-0.6cm}
    \includegraphics[trim={0cm 0cm 0cm 0cm}, clip=True,height=3.5cm]{images/reconstruction.png}
    \caption{Reconstruction results (best seen when zoomed in).}
    \label{fig:recon_hq}
\end{subfigure}
\begin{subfigure}[b]{.49\textwidth}
\centering
    \setlength{\belowcaptionskip}{1pt}
    \vspace{-0.6cm}
    \includegraphics[trim={0cm 0.3cm 0cm 0.3cm}, clip=True,height=3.5cm]{images/kl.pdf}
    \caption{Average KL per group.}
    \label{fig:kl_groups}
\end{subfigure}
\caption{(a) Input input on the left and reconstructed images on the right for CelebA HQ. (b) KL per group on CIFAR-10.}
\label{fig:recon_kl}
\end{figure} 
In this section, we perform ablation experiments to provide a better insight into different components in NVAE. All the experiments in this section are performed on CIFAR-10 using a small NVAE, constructed by halving the number of channels in residual cells and removing the normalizing flows.

\begin{wraptable}{r}{5.cm}
\vspace{-4mm}
\centering
{\footnotesize
\setlength{\tabcolsep}{2pt}
\caption{\small Normalization \& activation}\label{table:ab_act}
    \begin{tabular}{lccc}
    \toprule
    Functions    & $L=10$ & $L=20$ & $L=40$ \\
    \midrule
    WN + ELU     & 3.36  & 3.27  & 3.31  \\
    BN + ELU     & 3.36  & 3.26  & 3.22  \\
    BN + Swish   & \bf 3.34  & \bf 3.23  & \bf 3.16  \\
    \bottomrule
    \end{tabular}}
\vspace{-4mm}
\end{wraptable}
\textbf{Normalization and Activation Functions:} We examine the effect of normalization and activation functions on a VAE with cells visualized in Fig.~\ref{fig:cell_enc} for different numbers of groups ($L$). ELU with WN and data-dependent initialization were used in IAF-VAE~\cite{kingma2016improved} and BIVA~\cite{maaloe2019biva}. As we can see in Table~\ref{table:ab_act}, replacing WN with BN improves ELU's training, especially for $L=40$, but BN achieves better results with Swish. 


\begin{wraptable}{r}{5.4cm}
\vspace{-5mm}
\centering
{\footnotesize
\setlength{\tabcolsep}{1pt}
\caption{\small Residual cells in NVAE}\label{table:cells}
    \begin{tabular}{ccccc}
    \toprule
    Bottom-up    & Top-down & Test & Train & Mem. \\
    model    & model & (bpd) & time (h) & (GB) \\
    \midrule
    Regular      & Regular   & 3.11  & 43.3  & 6.3  \\
    Separable    & Regular   & 3.12  & 49.0  & 10.6 \\
    Regular      & Separable & \bf 3.07  & 48.0  & 10.7 \\
    Separable    & Separable & \bf 3.07  & 50.4  & 14.9 \\
    \bottomrule
    \end{tabular}
}
\vspace{-4mm}
\end{wraptable}\textbf{Residual Cells:} In Table~\ref{table:cells}, we examine the cells in Fig~\ref{fig:cells} for the bottom-up encoder and top-down generative models. Here, ``Separable'' and ``Regular'' refer to the cells in Fig.~\ref{fig:cell_dec} and Fig.~\ref{fig:cell_enc} respectively. We observe that the residual cell with depthwise convolution in the generative model outperforms the regular cells, but it does not change the performance when it is in the bottom-up model. Given the lower memory and faster training with regular cells, we use these cells for the bottom-up model and depthwise cells for the top-down model. 


\begin{wraptable}{r}{5.3cm}
\vspace{-4mm}
\centering
{\footnotesize
\setlength{\tabcolsep}{1pt}
\caption{\small The impact of residual dist.}\label{table:res_dist}
    \begin{tabular}{lccccc}
    \toprule
    Model    & \# Act. & \multicolumn{3}{c}{Training} & Test\\
             &   $\z$   &  KL & Rec. & $\L_{\text{VAE}}$ & LL\\
    \midrule
    w/$\ \ $ Res. Dist.  & 53   &\bf 1.32  & 1.80  & \bf 3.12 & \bf 3.16 \\
    w/o Res. Dist.     & 54   & 1.36  & 1.80  & 3.16 & 3.19 \\
    \bottomrule
    \end{tabular}
}
\vspace{-4mm}
\end{wraptable}\textbf{Residual Normal Distributions:} A natural question is whether the residual distributions improve the optimization of the KL term in the VAE objective or whether they only further contribute to the approximate posterior collapse. In Table~\ref{table:res_dist}, we train the 40-group model from Table~\ref{table:ab_act} with and without the residual distributions, and we report the number of active channels in the latent variables\footnote{To measure the number of the active channels, the average of KL across training batch and spatial dimensions is computed for each channel in latent variables. A channel is considered active if the average is above 0.1.}, the average training KL, reconstruction loss, and variational bound in bpd. Here, the baseline without residual distribution corresponds to the parameterization used in IAF-VAE~\cite{kingma2016improved}. As we can see, the residual distribution does virtually not change the number of active latent variables or reconstruction loss. However, it does improve the KL term by 0.04 bpd in training, and the final test log-likelihood by 0.03 bpd (see Sec.~\ref{app:res_dist} in Appendix for additional details).

\begin{wraptable}{r}{3.5cm}
\vspace{-5mm}
\centering
{\footnotesize
\setlength{\tabcolsep}{2pt}
\caption{\small SR \& SE}\label{table:comp}
    \begin{tabular}{lc}
    \toprule
    Model    & Test NLL  \\
    \midrule
    NVAE          & \bf 3.16  \\
    NVAE w/o SR     & 3.18 \\
    NVAE w/o SE     & 3.22  \\
    \bottomrule
    \end{tabular}
}
\vspace{-8mm}
\end{wraptable}\textbf{The Effect of SR and SE:} In Table~\ref{table:comp}, we train the same 40-group model from Table~\ref{table:ab_act} without spectral regularization (SR) or squeeze-and-excitation (SE). We can see that removing any of these components hurts performance. Although we introduce SR for stabilizing training, we find that it also slightly improves the generative performance (see Sec.~\ref{app:sr_stable} in the appendix for an experiment, stabilized by SR).


\textbf{Sampling Speed:} Due to the unconditional decoder, NVAE's sampling is fast. On a 12-GB Titan V GPU, we can sample a batch of 36 images of the size 256$\times$256 px in 2.03 seconds (56 ms/image). MaCow~\cite{ma19MaCow} reports 434.2 ms/image in a similar batched-sampling experiment ($\sim\!8\times$ slower). 

\textbf{Reconstruction:}
Fig.~\ref{fig:recon_hq} visualizes the reconstruction results on CelebA HQ datasets. As we can see, the reconstructed images in NVAE are indistinguishable from the training images. 

\textbf{Posterior Collapse:}
Since we are using more latent variables than the data dimensionality, it is natural for the model to turn off many latent variables. However, our KL balancing mechanism (Sec.~\ref{app:imp_det}) stops a hierarchical group from turning off entirely. In Fig.~\ref{fig:kl_groups}, we visualize KL per group in CIFAR-10 (for 30 groups). Note how most groups obtain a similar KL on average, and only one group is turned off. We apply KL balancing mechanism only during KL warm-up (the first $\sim$ 25000 iterations). In the remaining iterations, we are using the original VAE objective without any KL balancing (Eq.~\ref{eq:hvae}).







 \section{Conclusions}
\vspace{-0.2cm}
In this paper, we proposed Nouveau VAE, a deep hierarchical VAE with a carefully designed architecture. NVAE uses depthwise separable convolutions for the generative model and regular convolutions for the encoder model. We introduced residual parameterization of Normal distributions in the encoder and spectral regularization for stabilizing the training of very deep models. We also presented practical remedies for reducing the memory usage of deep VAEs, enabling us to speed up training by $\sim\!2\times$. NVAE achieves state-of-the-art results on MNIST, CIFAR-10, CelebA 64, and CelebA HQ-256, and it provides a strong baseline on FFHQ-256. To the best of our knowledge, NVAE is the first VAE that can produce large high-quality images and it is trained without changing the objective function of VAEs. Our results show that we can achieve state-of-the-art generative performance by carefully designing neural network architectures for VAEs. The future work includes scaling up the training for larger images, experimenting with more complex normalizing flows, automating the architecture design by neural architecture search, and studying the role of batch normalization in VAEs. We have released our source-code to facilitate research in these directions. \section*{Impact Statement}

This paper's contributions are mostly centered around the fundamental challenges in designing expressive neural architectures for image VAEs, and the ideas, here, are examined on commonly used public datasets. This work has applications in content generation, computer graphics, data augmentation, semi-supervised learning, and representation learning.

VAEs are known to represent the data distribution more faithfully than commonly used generative adversarial networks (GANs), as VAEs do not suffer from the mode collapse problem. Thus, in the long run, enabling VAEs to generate high-quality images will help us reduce bias in the generated content, produce diverse output, and represent minorities better.

One should also take into consideration that VAEs are trained to mimic the training data distribution, and, any bias introduced in data collection will make VAEs generate samples with a similar bias. Additional bias could be introduced during model design, training, or when VAEs are sampled using small temperatures. Bias correction in generative learning is an active area of research, and we recommend the interested readers to check this area~\cite{grover2019bias} before building applications using this work.

\section*{Acknowledgements}
The authors would like to thank Karsten Kreis and Margaret Albrecht for providing feedback on the early version of this work. They also would like to extend their sincere gratitude to Sangkug Lym for providing suggestions for accelerating NVAE. Last but not least, they are grateful to Sabu Nadarajan, Nithya Natesan, Sivakumar Arayandi Thottakara, and Jung Seok Jin for providing compute support.
 
\bibliographystyle{unsrt}
{\small
\bibliography{generative}}


\clearpage
\appendix
\section{Additional Implementation Details}\label{app:imp_det}

\textbf{Warming-up the KL Term:} Similar to the previous work, we warm-up the KL term at the beginning of training~\cite{sonderby2016ladder}. Formally, we optimize the following objective:
\begin{equation*}
\E_{q(\z|\x)}\left[ \log p(\x|\z) \right] - \beta \KL{q(\z|\x)}{p(\z)},
\end{equation*}
where $\beta$ is annealed from 0 to 1 at the first 30\% of training. 

\textbf{Balancing the KL Terms:} In hierarchical VAEs, the KL term is defined by:
\begin{equation*}
\KL{q(\z|\x)}{p(\z)} = \sum_{l=1}^L \E_{q(\z_{<l}|\x)} \left[ \KL{q(\z_l|\x, \z_{<l})}{p(\z_l|\z_{<l})} \right],
\end{equation*}
where each $\KL{q(\z_l|\x, \z_{<l})}{p(\z_l|\z_{<l})}$ can be thought as the amount of information encoded in the $l^{th}$ group. In deep hierarchical VAEs, during training, some groups of latent variables can easily become deactivated by matching the approximate posterior with the prior (i.e., posterior collapse). One simple solution is to use KL balancing coefficients \cite{Vahdat2018DVAE++, chen2016lossy} to ensure that an equal amount of information is encoded in each group using:
\begin{equation*}
\KL{q(\z|\x)}{p(\z)} = \sum_{l=1}^L \gamma_l \ \E_{q(\z_{<l}|\x)} \left[ \KL{q(\z_l|\x, \z_{<l})}{p(\z_l|\z_{<l})} \right].
\end{equation*}
The balancing coefficient $\gamma_l$ is set to a small value when the KL term is small for that group to encourage the model to use the latent variables in that group, and it is set a large value when the KL term is large. The KL balancing coefficients are only applied during the KL warm-up period, and they are set to 1 afterwards to ensure that we optimize the variational bound. DVAE++~\cite{Vahdat2018DVAE++} sets $\gamma_l$ proportional to $\E_{\x\sim\mathcal{M}} \left[ \E_{q(\z_{<l}|\x)} \left[ \KL{q(\z_l|\x, \z_{<l})}{p(\z_l|\z_{<l})} \right] \right]$ in each parameter update using the batch $\mathcal{M}$. However, since we have latent variable groups in different scales (i.e., spatial dimensions), we observe that setting $\gamma_l$ proportional to also the size of each group performs better, i.e., $\gamma_l \propto s_l \ \E_{\x\sim\mathcal{M}} \left[ \E_{q(\z_{<l}|\x)} \left[ \KL{q(\z_l|\x, \z_{<l})}{p(\z_l|\z_{<l})} \right] \right]$ 

\textbf{Annealing $\pmb{\lambda}$:} The coefficient of the smoothness loss $\lambda$ is set to a fixed value in $\{10^{-2}, 10^{-1}\}$ for almost all the experiments. We used $10^{-1}$ only when training was unstable at $10^{-2}$. However, on Celeb-A HQ and FFHQ, we observe that training is initially unstable unless for $\lambda \in \{1, 10\}$   which applies a very strong smoothness. For these datasets, we anneal $\lambda$ with exponential decay from $10$ to a small value shown in Table.~\ref{table:hyper} in the same number of iterations that the KL coefficient is annealed. Note that the smoothness loss is applied to both encoder and decoder. We hypothesize that a sharp decoder may require a sharp encoder, causing more instability in training.

\textbf{Weight Normalization (WN):} WN cannot be used with BN as BN removes any scaling of weights introduced by WN. However, previous works have seen improvements in using WN for VAEs. In NVAE, we apply WN to any convolutional layer that is not followed by BN, e.g., convolutional layers that produce the parameters of Normal distributions in encoder or decoder. 

\textbf{Inverse Autoregressive Flows (IAFs):} We apply simple volume-preserving normalizing flows of the form $\z' = \z + \b(\z)$ to the samples generated by the encoder at each level, where $\b(\z)$ is produced by an autoregressive network.  In each flow operation, the autoregressive network is created using a cell similar to Fig.~\ref{fig:cells} (a) with the masking mechanism introduced in PixelCNN~\cite{van2016pixel}. In the autoregressive cell, BN is replaced with WN, and SE is omitted, as these operations break the autoregressive dependency. We initially examined non-volume-preserving affine transformations in the form of $\z' = \a(\z) \odot \z + \b(\z)$, but we did not observe any improvements. Similar results are reported by Kingma et al.~\cite{kingma2016improved} (See Table 3).

\textbf{Optimization:} For all the experiments, we use the AdaMax~\cite{kingma2014adam} optimizer for training with the initial learning rate of $0.01$ and with cosine learning rate decay. For FFHQ experiments, we reduce the learning rate to $0.008$ to further stabilize the training.

\textbf{Image Decoder $p(\x|\z):$} For all the datasets but MNIST, we use the mixture of discretized Logistic distribution~\cite{salimans2017pixelcnn++}. In MNIST, we use a Bernoulli distribution. Note that in all the cases, our decoder is unconditional across the spatial locations in the image. 

\textbf{Evaluation:} For estimating log-likelihood on the test datasets in evaluation, we use importance weighted sampling using the encoder~\cite{burda2015importance}. We use 1000 importance weighted samples for evaluation.

\textbf{Channel Sizes:} We only set the initial number of channels in the bottom-up encoder. When we downsample the features spatially, we double the number of channels in the encoder. The number of channels is set in the reverse order for the top-down model.

\textbf{Expansion Ratio $E$:} The depthwise residual cell in Fig.~\ref{fig:cell_dec} requires setting an expansion ratio $E$. We use $E=6$ similar to MobileNetV2~\cite{sandler2018mobilenetv2}. In a few cells, we set $E=3$ to reduce the memory. Please see our code for additional details.

\textbf{Datasets:} We examine NVAE on the dynamically binarized MNIST~\cite{lecun1998mnist}, CIFAR-10~\cite{krizhevsky2009cifar}, ImageNet $32\times32$~\cite{deng2009imagenet}, CelebA $64\times64$~\cite{liu2015celeba, larsen2016autoencoding}, CelebA HQ~\cite{karras2018progressive}, and FFHQ 256$\times$256~\cite{karras2019style}. For all the datasets but FFHQ, we follow Glow~\cite{kingma2018glow} for the train and test splits. In FFHQ, we use 63K images for training, and 7K for test. Images in FFHQ and CelebA HQ are downsampled to $256\times256$ pixels, and are quantized in 5 bits per pixel/channel to have a fair comparison with prior work~\cite{kingma2018glow}.

\textbf{Hyperparameters:} Given a large number of datasets and the heavy compute requirements, we do not exhaustively optimize the hyperparameters. In our early experiments, we observed that the larger the model is, the better it performs. We often see improvements with wider networks, a larger number of hierarchical groups, and more residual cells per group. However, they also come with smaller training batch size and slower training. We set the number of hierarchical groups to around 30, and we used two residual cells per group. We set the remaining hyperparameters such that the model could be trained in no more than about a week. Table.~\ref{table:hyper} summarizes the hyperparameters used in our experiments.

\begin{table*}
\caption{A summary of hyperparameters used in training NVAE with additional information. $D^2$ indicates a latent variable with the spatial dimensions of $D\times D$. As an example, the MNIST model consists of 15 groups of latent variables in total, covering two different scales. In the first scale, we have five groups of $4\times 4 \times 20$-dimensional latent variables (in the form of height$\times$width$\times$channel). In the second scale, we have 10 groups of $8\times8\times20$-dimensional variables.} \label{table:hyper}
\centering
\resizebox{0.98\linewidth}{!}{
\begin{threeparttable}
\setlength{\tabcolsep}{3pt}
\def\arraystretch{1.2}\begin{tabular}{lcccccc}
        \toprule
        {\bf Hyperparamter} & {\bf MNIST}  & {\bf CIFAR-10} & {\bf ImageNet} & {\bf CelebA} & {\bf CelebA HQ} & {\bf FFHQ} \\
                     & 28$\times$28& 32$\times$32 & 32$\times$32 & 64$\times$64 & 256$\times$256 & 256$\times$256 \\
        \midrule
        \# epochs    & 400 & 400 & 45 & 90 & 300 & 200\\ \hline
        batch size per GPU  & 200 & 32 & 24 & 16 & 4 & 4\\ \hline
        \# normalizing flows   & 0 & 2 & 2 & 2 & 4 & 4 \\ \hline
        \# latent variable scales  & 2 & 1 & 1 & 3 & 5 & 5 \\ \hline
        \multirow{2}{*}{\# groups in each scale}  & \multirow{2}{*}{5, 10} & \multirow{2}{*}{30} & \multirow{2}{*}{28} & \multirow{2}{*}{5, 10, 20} & 4, 4, 4, & 4, 4, 4, \\
                             &  & & & & 8, 16 & 8, 16 \\ \hline
        \multirow{2}{*}{spatial dims of $\z$ in each scale} & \multirow{2}{*}{4$^2$, 8$^2$} & \multirow{2}{*}{16$^2$}  & \multirow{2}{*}{16$^2$} & \multirow{2}{*}{8$^2$, 16$^2$, 32$^2$} & 8$^2$, 16$^2$, 32$^2$, & 8$^2$, 16$^2$, 32$^2$, \\
                         &  & & &  & 64$^2$, 128$^2$  & 64$^2$, 128$^2$ \\ \hline
        \# channel in $\z$  & 20 & 20 & 20 & 20 & 20 & 20\\ \hline
        \# initial channels in enc.      & 32 & 128 & 192 & 64 & 30 & 30 \\
        \hline
        \# residual cells per group & 1 & 2 & 2 & 2 & 2 & 2 \\ \hline
        $\lambda$                  & 0.01 & 0.1 & 0.01 & 0.1 & 0.01 & 0.1 \\ \hline
        GPU type    & 16-GB V100 & 16-GB V100 & 32-GB V100 & 16-GB V100 & 32-GB V100 & 32-GB V100\\ \hline
        \# GPUs                & 2 & 8 & 24 & 8 & 24\tnote{*} & 24\tnote{*} \\ \hline
        total train time (h)   & 21 & 55 & 70 & 92 & 94 & 160\\ 
        \bottomrule
        \end{tabular}
        \begin{tablenotes}\footnotesize
        \item[*] A smaller model with 24 initial channels instead of 32, could be trained on only 8 GPUs in the same time (with the batch size of 6). The smaller models obtain only 0.01 bpd higher negative log-likelihood on these datasets.
        \end{tablenotes}
        \end{threeparttable}
}
\end{table*} 

\section{Additional Experiments and Visualizations}
In this section, we provide additional insights into NVAE.

\subsection{Is NVAE Memorizing the Training Set?}
In VAEs, since we can compute the log-likelihood on a held-out set, we can ensure that the model is not memorizing the training set. In fact, in our experiments, as we increase the model capacity (depth and width), we never observe any overfitting behavior especially on the datasets with large images. In most cases, we stop making the model large because of the compute and training time considerations. However, since the images generated by NVAE are realistic, this may raise a question on whether NVAE memorizes the training set.

In Fig.~\ref{fig:dup}, we visualize a few samples generated by NVAE and the most similar images from the training data. For measuring the similarity, we downsample the images by 4$\times$, and we measure $L_2$ distance using the central crop of the images. Since images are aligned, this way we can compare images using the most distinct facial features (eyes, nose, and mouth). As we can see, the sampled images are not present in the training set.


\begin{figure}
\centering
\includegraphics[scale=0.5]{images/duplicate.pdf}
\caption{Top retrieved images from the training set are visualized for samples generated by NVAE in each row. The generated instances do not exist in the training set (best seen when zoomed in).}
\label{fig:dup}
\end{figure}

\subsection{Changing the Temperature of the Prior in NVAE}\label{app:temp}
It is common to lower the temperature of the prior when sampling from VAEs on challenging datasets. In Fig.~\ref{fig:bn_temp}, we examine different temperatures in the prior with different settings for the batch norm layers.

\begin{figure}
\centering
\includegraphics[trim={2.5cm 8cm 1cm 0cm}, clip=True,height=16.5cm]{images/bn.pdf}
\caption{Randomly sampled images from NVAE with different temperatures in the prior for the CelebA HQ dataset (best seen when zoomed in). In the batch normalization layers during sampling, we examine two settings: i) the default mode that uses the running averages from training (on the left), and ii) readjusted mode in which the running averages are re-tuned by sampling from the model 500 times with the given temperature (on the right). Readjusted BN statistics improve the diversity and quality of the images, especially for small temperatures.}
\label{fig:bn_temp}
\end{figure} 
\subsection{Additional Generated Samples}
In Fig.~\ref{fig:more_res1} and Fig.~\ref{fig:more_res2}, we visualize additional generated samples by NVAE, trained on CelebA HQ. In these figures, we use higher temperatures ($t \in \{0.6, 0.7, 0.8, 0.9\}$), but we manually select the samples.

\begin{figure}
\centering
\hspace{-0.9cm}
\includegraphics[trim={2.5cm 2.0cm 2.5cm 1.cm},clip=True,scale=0.89]{images/teaserf2.pdf}
\caption{Additional 256$\times$256-pixel samples generated by NVAE, trained on CelebA HQ~\cite{karras2018progressive}. In this figure, we use higher temperatures ($t \in \{0.6, 0.7, 0.8, 0.9\}$), but we manually select the samples.}
\label{fig:more_res1}
\vspace{-0.3cm}
\end{figure}

\begin{figure}
\centering
\hspace{-0.9cm}
\includegraphics[trim={2.5cm 2.0cm 2.5cm 1.cm},clip=True,scale=0.89]{images/teaserf1.pdf}
\caption{Additional 256$\times$256-pixel samples generated by NVAE, trained on CelebA HQ~\cite{karras2018progressive}. In this figure, we use higher temperatures ($t \in \{0.6, 0.7, 0.8, 0.9\}$), but we manually select the samples.}
\label{fig:more_res2}
\vspace{-0.3cm}
\end{figure} 
\subsection{More on the Impact of Residual Normal Distributions}\label{app:res_dist}
Fig.~\ref{fig:res_dist} visualizes the total number of active channels in all latent variables during training. Here, we compare the residual Normal distributions against the model that predicts the absolute parameters of the Normal distributions in the approximate posterior. This figure corresponds to the experiment that we reported in Table.~\ref{table:res_dist}. As we can see, in the initial stage of training, the model without residual distributions turns off more latent variables. 

\begin{figure}
\centering
\includegraphics[trim={0cm 0cm 0cm 0cm}, clip=True,height=7.cm]{images/res_dist.pdf}
\caption{The total number of active channels in $\z$ is reported for two models with and without residual distributions. The model with residual distribution keeps more latent variables active in the KL warm-up phase (up to 8K iterations), and it achieves a better KL value at the end of the training (see Table.~\ref{table:res_dist})}
\label{fig:res_dist}
\end{figure} 
\subsection{Stabilizing the Training with Spectral Regularization}\label{app:sr_stable}
In our experiments, we came across many cases whose training was unstable due to the KL term, and it was stabilized by spectral regularization. Initially, instead of spectral regularization, we examined common approaches such as gradient clipping or limiting the parameters of the Normal distributions to a small range. But, none could stabilize the training without negatively affecting the performance. Fig.~\ref{fig:sr_stable} shows an experiment on the FFHQ dataset. The training is stabilized by increasing the spectral regularization coefficient ($\lambda$) from 0.1 to 1.0.

\begin{figure}[!h]
\centering
\begin{subfigure}[b]{.99\textwidth}
\centering
\includegraphics[trim={0cm 0cm 0cm 0cm}, clip=True,height=5.4cm]{images/sr_kl.pdf}
\end{subfigure} 
\caption{An example experiment on the FFHQ dataset. All the hyper-parameters are identical between the two runs. However, training is unstable due to the KL term in the objective. We stabilize the training by increasing the spectral regularization coefficient $\lambda$. }
\label{fig:sr_stable}
\vspace{-0.3cm}
\end{figure} 
\subsection{Long-Range Correlations}\label{app:scales}
NVAE's hierarchical structure is composed of many latent variable groups operating at different scales. For example, on CelebA HQ $256\times 256$, the generative model consists of five scales. It starts from a spatially arranged latent variable group of the size $8\times 8$ at the top, and it samples from the hierarchy group-by-group while gradually doubling the spatial dimensions up to $128\times 128$. 

A natural question to ask is what information is captured at different scales. In Fig.~\ref{fig:scales}, we visualize how the generator's output changes as we fix the samples at different scales. As we can see, the global long-range correlations are captured mostly at the top of the hierarchy, and the local variations are recorded at the lower groups.

\begin{figure}[!h]
\centering
\includegraphics[trim={2.5cm 9cm 0cm 1cm}, clip=True,height=15.cm]{images/hierarchy.pdf}
\caption{Where does our hierarchical model capture long-range correlations? NVAE on CelebA HQ consists of latent variable groups that are operating at five scales (starting from $8\times8$ up to $128\times128$). In each row, we fix the samples at a number of top scales and we sample from the rest of the hierarchy. As we can see, the long-range global structure is mostly recorded at the top of the hierarchy in the $8\times8$ dimensional groups. The second scale does apply some global modifications such as changing eyes, hair color, skin tone, and the shape of the face. The bottom groups capture mostly low-level variations. However, the lowest scale can still make some subtle long-range modifications. For example, the hair color is slightly modified when we are only sampling from the lowest scale in the last row. This is potentially enabled because of the large receptive field in our depthwise separable residual cell.}
\label{fig:scales}
\vspace{-0.3cm}
\end{figure}  \end{document}
