\documentclass[11pt]{article}

\usepackage{fullpage}
\usepackage{amssymb,amsmath}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{array}
\usepackage{xspace}
\usepackage{color,soul}
\usepackage{paralist,mdwlist}

\usepackage{tikz}
\usetikzlibrary{arrows,decorations.pathmorphing,backgrounds,positioning,fit,through}

\definecolor{nym-blue}{HTML}{003581}
\definecolor{nym-orange}{HTML}{F47937}
\definecolor{whitesmoke}{HTML}{F5F5F5}







\sloppy





\newtheorem{lemma}{Lemma}
\newtheorem{observation}[lemma]{Observation}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{property}{Property}
\newtheorem{corollary}{Corollary}
\newtheorem{proposition}{Proposition}







\newcommand{\eqdf}{\stackrel{\scriptscriptstyle \triangle}{=}}
\newcommand{\argmin}{\ensuremath{\mbox{argmin}}}
\newcommand{\argmax}{\ensuremath{\mbox{argmax}}}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\paren}[1]{\left( #1 \right)}
\newcommand{\bit}{\set{0,1}}
\newcommand{\inv}[1]{\frac{1}{#1}}
\newcommand{\abs}[1]{\left| #1 \right|}
\newcommand{\ceil}[1]{\left\lceil {#1} \right\rceil}
\newcommand{\floor}[1]{\left\lfloor {#1} \right\rfloor}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\threehalves}{\frac{3}{2}}

\newcommand{\naturals}{\mathbb{N}}
\newcommand{\rationals}{\mathbb{Q}}
\newcommand{\reals}{\mathbb{R}}
\newcommand{\integers}{\mathbb{Z}}



\newcommand{\strip}{\textsc{Strip Cover}\xspace}
\newcommand{\sosc}{\textsc{OnceSC}\xspace}
\newcommand{\srsc}{\textsc{RadSC}\xspace}
\newcommand{\stsc}{\textsc{TimeSC}\xspace}
\newcommand{\sosclong}{\textsc{Set Once Strip Cover}\xspace}
\newcommand{\srsclong}{\textsc{Set Radius Strip Cover}\xspace}
\newcommand{\stsclong}{\textsc{Set Time Strip Cover}\xspace}

\newcommand{\partition}{\textsc{Partition}\xspace}

\newcommand{\rr}{\textsc{RoundRobin}\xspace}
\newcommand{\RR}{\textsc{RR}\xspace}
\newcommand{\all}{\textsc{All}}
\newcommand{\opt}{\textsc{Opt}\xspace}

\newcommand{\calT}{\mathcal{T}}
\newcommand{\E}{\mathbb{E}}



\newcommand{\dror}[1]{\sethlcolor{yellow}\hl{Dror: #1}}
\newcommand{\ben}[1]{\sethlcolor{green}\hl{Ben: #1}}



\begin{document}

\title{\bf Set It and Forget It: \\
Approximating the Set Once Strip Cover Problem}

\author{Amotz Bar-Noy \\
Department of Computer Science \\
The Graduate Center of the CUNY \\
New York, NY 10016, USA \\
\texttt{amotz@sci.brooklyn.cuny.edu}
\and
Ben Baumer \\
Department of Mathematics \& Statistics \\
Smith College \\
Northampton, MA 01063, USA \\
\texttt{bbaumer@smith.edu}
\and
Dror Rawitz \\
School of Electrical Engineering \\
Tel Aviv University \\
Tel-Aviv 69978, Israel \\
\texttt{rawitz@eng.tau.ac.il}
}



\begin{titlepage}

\maketitle

\begin{abstract}
We consider the \sosclong problem, in which  wireless sensors are
deployed over a one-dimensional region. Each sensor has a fixed
battery that drains in inverse proportion to a radius that can be set
just once, but activated at any time.  The problem is to find an
assignment of radii and activation times that maximizes the length of
time during which the entire region is covered.  We show that this
problem is NP-hard. Second, we show that \rr, the algorithm in which
the sensors take turns covering the entire region, has a tight
approximation guarantee of  in both \sosclong and the
more general \strip problem, in which each radius may be set
finitely-many times. Moreover, we show that the more general class of
\emph{duty cycle} algorithms, in which groups of sensors take turns
covering the entire region, can do no better. Finally, we give an
optimal -time algorithm for the related \srsclong
problem, in which sensors must be activated immediately.
\end{abstract}



\medskip
\noindent
\textbf{Keywords}:
wireless sensor networks,
strip cover,
barrier coverage,
network lifetime.

\thispagestyle{empty}
\end{titlepage}




\section{Introduction}

Suppose that  sensors are deployed over a one-dimensional
region that they are to cover with a wireless network. Each sensor is
equipped with a finite battery charge that drains in inverse
proportion to the sensing radius that is assigned to it, and each
sensor can be activated only once.  In the \sosclong (\sosc) problem,
the goal is to find an assignment of radii and activation times that
maximizes the \emph{lifetime} of the network, namely the length of
time during which the entire region is covered.

Formally, we are given as input the locations  and
battery charges  for each of  sensors. While we
cannot move the sensors, we do have the ability to set the sensing
radius  of each sensor and the time  when it should
become active.  Since each sensor's battery drains in inverse
proportion to the radius we set (but cannot subsequently change), each
sensor covers the region  for
 time units.  Our task is to devise an algorithm that
finds a schedule 
for any input , such that  is completely covered for as
long as possible.




\paragraph*{\bf Motivation.}
Scheduling problems of this ilk arise in many applications,
particularly when the goal is \emph{barrier coverage}
(see~\cite{cardei2004coverage,wang2006survey} for surveys,
or~\cite{kumar2007barrier} for motivation).  Suppose that we have a
highway, supply line, or fence in territory that is either hostile or
difficult to navigate.  While we want to monitor activity along this
line, conditions on the ground make it impossible to systematically
place wireless sensors at specific locations.  However, it is feasible
and inexpensive to deploy adjustable range sensors along this line by,
say, dropping them from an airplane flying overhead
(e.g.~\cite{cardei2005improving,saipulla2009barrier,taniguchi2011uniform}).
Once deployed, the sensors send us their location via GPS, and we wish
to send a single radius-time pair to each sensor as an assignment.
Replacing the battery in any sensor is infeasible. How do we construct
an assignment that will keep this vital supply line completely
monitored for as long as possible?



\paragraph*{\bf Models.}
While the focus of this paper is the \sosc problem, we touch upon
three closely related problems. In each problem the location and
battery of each sensor are fixed, and a solution can be viewed as a
finite set of radius-time pairs.
In \sosc, both the radii and the activation times are variable, but
can be set only once. In the more general \strip problem, the radius
and activation time of each sensor can be set finitely many times. On
the other hand, if the radius of each sensor is fixed and given as
part of the input, then we call the problem of assigning an activation
time to each sensor so as to maximize network lifetime \stsclong
(\stsc).  \srsclong (\srsc) is another variant of \sosc in which all
of the sensors are scheduled to activate immediately, and the problem
is to find the optimal radial assignment.
Figure~\ref{fig:schematic} summarizes the important
differences between related problems and illustrates their
relationship to one another.

\begin{figure}[t]
\centering
		\begin{tikzpicture}[xscale=1.5,yscale=1.5
, arrow/.style={->,draw=nym-orange,line width=1pt,bend angle=90}
				, popup/.style={rounded corners,draw=nym-blue,very thick,text width=4.8cm,text centered,fill=whitesmoke,text=nym-blue,font=\fontsize{7}{9}\selectfont}
				]
				\node[popup] (ar-rsc) at (4,4) {\strip:\\radii \& activation times\\can be set finitely many times};
				\node[popup] (set-once) at (4,3) {\sosclong (\sosc):\\radii \& activation times\\can be set only once};
				\node[popup] (rsc) at (2,2) {\stsclong (\stsc, RSC):\\radii are fixed\\activation times are variable};
				\node[popup] (all) at (6,2) {\srsclong (\srsc):\\radii can be set only once\\activation is immediate};
\path[arrow] (rsc) edge (set-once);
				\path[arrow] (all) edge (set-once);
				\path[arrow] (set-once) edge (ar-rsc);
\end{tikzpicture} \caption{Relationship of Problem Variants.}
\label{fig:schematic}
\end{figure}



\paragraph*{\bf Related work.}
\stsc,
which is known as \textsc{Restricted Strip Covering},
was shown to be NP-hard by Buchsbaum et
al.~~\cite{buchsbaum2007restricted}, who also gave an -approximation algorithm.  Later, a constant factor approximation
algorithm was discovered by Gibson and
Varadarajan~\cite{gibson2009decomposing}.



Close variants of \srsc have been the subject of previous work.
Whereas \srsc requires \emph{area} coverage, Peleg and
Lev-Tov~\cite{lev2005polynomial} studied \emph{target} coverage.  In
this problem the input is a set of  sensors and a finite set of 
points on the line that are to be covered, and the goal is to find the
radial assignments with the minimum sum of radii.  They used dynamic
programming to devise a polynomial time alorithm.  Bar-Noy et
al.~\cite{bar2009cheap} improved the running time to .
Recently, Bar-Noy et al.~\cite{BRT13} considered an extension of \srsc
in which sensors are mobile.

\strip was first considered by Bar-Noy and
Baumer~\cite{barnoy2011maximizing}, who gave a  lower
bound on the performance of \rr, the algorithm in which the sensors
take turns covering the entire region (see Observation~\ref{obs:rr}),
but were only able to show a corresponding upper bound of .
The similar \textsc{Connected Range Assignment} (CRA) problem, in
which radii are assigned to points in the plane in order to obtain a
connected disk graph, was studied by Chambers et
al.~\cite{chambers2011connecting}. They showed that the best one
circle solution to CRA also yields a -approximation
guarantee, and in fact, the instance that produces their lower bound
is simply a translation of the instance used in
Observation~\ref{obs:rr}.

The notion of \emph{duty cycling} as a mean to maximize network
lifetime was also considered in the literature of discrete geometry.  In
this context, maximizing the number of covers  serves as a proxy
for maximizing the actual network lifetime.
Pach~\cite{pach1986covering} began the study of decomposability of
multiple coverings.
Pach and T\'{o}th~\cite{pach2009decomposition} showed that a -fold
cover of translates of a centrally-symmetric open convex polygon can
be decomposed into  covers. This
was later improved to the optimal  covers by Aloupis et
al.~\cite{aloupis2010decomposition}, while Gibson and
Varadarajan~\cite{gibson2009decomposing} showed the same result
without the centrally-symmetric restriction.

Motivated by prior invocations of duty
cycling~\cite{slijepcevic2001power,perillo2003optimal,abrams2004set,cardei2005improving,cardei2006improving,cardei2005maximum},
Bar-Noy et al.~\cite{BBR12} studied a duty cycle variant of \sosc with
unit batteries in which sensors must be grouped into shifts of size at
most  that take turns covering .  (\rr is the only possible
algorithm when .)  They presented a polynomial-time algorithm for
 and showed that the approximation ratio of this algorithm is
 for .  It was also shown that its approximation
ratio is at least , for , and ,
for . A fault-tolerance model, in which smaller shifts are more
robust, was also proposed.



\paragraph*{\bf Our results.}
We introduce the \textsc{Set Once} model that corresponds to the case
where the scheduler does not have the ability to vary the sensor's
radius once it has been activated.  We show that \sosc is NP-hard
(Section~\ref{sec:hardness}) and that \rr is a
-approximation algorithm for both \sosc and \strip
(Section~\ref{sec:rr}).  This closes a gap between the best previously
known lower and upper bounds ( and , resp.) on the
performance of this algorithm.
Our analysis of \rr is based on the following approach:  We slice an
optimal schedule into strips in which the set of active sensors is
fixed.  For each such strip we construct an instance with unit
batteries and compare the performance of \rr to the \srsc optimum of
this instance.
In Section~\ref{sec:dc} we show that the class of duty cycle
algorithms cannot improve on this  guarantee.
In Section~\ref{sec:srsc}, we provide an -time
algorithm for \srsc.  We note that the same approach would work for
the case where, for every sensor , the th battery is drained in
inverse proportion to , for some .






\section{Preliminaries}
\label{sec:prelim}

\paragraph*{\bf Problems.}
The \textsc{Set Once Strip Cover} (abbreviated \sosc) is defined as
follows. Let  be the interval that we wish to cover.
Given is a vector  of  sensor
locations, and a corresponding vector  of battery charges, with  for all .  We
assume that  for every .  We
sometimes abuse notation by treating  as a set.  An instance of the
problem thus consists of a pair , and a solution is an
assignment of radii and activation times to sensors.  More
specifically a solution (or \emph{schedule}) is a pair  where  is the \emph{radius} of sensor  and
 is the \emph{activation time} of . Since the radius of
each sensor cannot be reset, this means that sensor  becomes active
at time , covers the \emph{range}  for  time units, and then becomes inactive since
it has exhausted its entire battery.

Any schedule can be visualized by a space-time diagram in which each
coverage assignment can be represented by a rectangle. It is customary
in such diagrams to view the sensor locations as forming the
horizontal axis, with time extending upwards vertically. In this case,
the coverage of a sensor located at  and assigned the radius
 beginning at time  is depicted by a rectangle with
lower-left corner  and upper-right corner
. Let the set of all points
contained in this rectangle be denoted as .
A point  in space-time is \emph{covered} by a schedule  if . The
\emph{lifetime} of the network in a solution  is the
maximum value  such that every point  is
covered. Graphical depictions of two schedules are shown below in
Figure~\ref{fig:rr}.

In \sosc our goal is to find a schedule  that maximizes
the lifetime . Given an instance , the optimal lifetime
is denoted by .  (We sometimes use , when the
instance is clear from the context.)

The \srsclong (\srsc) problem is a variant of \sosc in which
, for every .  Hence, a solution is simply a radial
assignment .  \stsclong (\stsc) is another variant in which the
radii are given in the input, and a solution is an assignment of
activation times to sensors.


\strip is a generalization of \sosc in which a sensor's radius may be 
changed finitely many times.  In this case a solution is a vector of
piece-wise constant functions , where  is the
sensing radius of sensor  at time . The solution is feasible if
 is covered for all , and if , for every .
The segment  is covered at time , if 
.



\paragraph*{\bf Maximum lifetime.}
The best possible lifetime of an instance  is .
We state this formally for \sosc, but the same holds for the other
variants.


\begin{observation}
\label{obs:lifetime}
The lifetime of a
\sosc instance  is at most .
\end{observation}
\begin{proof}
Consider an optimal solution  for  with lifetime
.  A sensor  covers an interval of length  for
 time.  The lifetime 
is at most the total area of space-time covered by the sensors, which
is at most .
\end{proof}



\paragraph*{\bf Round Robin.} 
We focus on a simple algorithm we call \rr.  The \rr algorithm forces
the sensors to take turns covering , namely it assigns, for every
,  and .  
The lifetime of \rr is thus

Notice that Observation~\ref{obs:lifetime} implies an upper bound of
 on the approximation ratio of \rr, since , for every
.
A lower bound of  on the approximation guarantee of \rr
was given in~\cite{barnoy2011maximizing} using the two sensor instance
, .  The relevant schedules
are depicted graphically in Figure~\ref{fig:rr}.

\begin{observation}[\cite{barnoy2011maximizing}]
\label{obs:rr}
The approximation ratio of \rr is at least .
\end{observation}

\begin{figure}[t]
\centering
\subfloat[]{			\begin{tikzpicture}[xscale=3.25, yscale=1,
				coverage/.style={circle,draw=blue!50,fill=blue!20,thick,opacity=0.5},
				lifetime/.style={->,dashed,thick,gray},
				sensor/.style={circle,draw=black,fill=red!50,thick,opacity=0.75,inner sep=0pt,minimum size=2mm}]
				\draw[step=.5cm,gray,very thin] (0,0) grid (1, 4);	
				\draw[-] (0,0) -- (1,0) coordinate (x axis);
				\foreach \x/\xtext in {0, 0.25/\frac{1}{4}, 0.5/\frac{1}{2}, 0.75/\frac{3}{4}, 1}
					\draw (\x,3.5pt) -- (\x,-3.5pt) node[anchor=north] {};
				\draw[-] (0,0) -- (0,4) coordinate (y axis);
				\foreach \y/\ytext in {0, 1, 2, 3, 4}
					\draw (1pt,\y) -- (-1pt,\y) node[anchor=east] {};
				\coordinate (a) at (0,0);	
				\coordinate (b) at (1,0);	
				\coordinate [label=below left:] (s1) at (1/4, 0);
				\coordinate [label=below right:] (s2) at (3/4, 0);
				\draw [coverage] (0,0) rectangle (1/2, 4);
				\draw [coverage] (1/2,0) rectangle (1,4);
\node [sensor] at (s1) [] {};
\node [sensor] at (s2) [] {};
				\draw [lifetime] (s1) -- (1/4,4);
				\draw [lifetime] (s2) -- (3/4,4);
			\end{tikzpicture} } 
\hspace{30pt}
\subfloat[]{			\begin{tikzpicture}[xscale=3.25, yscale=1,
				coverage/.style={circle,draw=blue!50,fill=blue!20,thick,opacity=0.5},
				lifetime/.style={->,dashed,thick,gray},
				sensor/.style={circle,draw=black,fill=red!50,thick,opacity=0.75,inner sep=0pt,minimum size=2mm}]
				\draw[step=.5cm,gray,very thin] (0,0) grid (1, 4);	
				\draw[-] (0,0) -- (1,0) coordinate (x axis);
				\foreach \x/\xtext in {0, 0.25/\frac{1}{4}, 0.5/\frac{1}{2}, 0.75/\frac{3}{4}, 1}
					\draw (\x,3pt) -- (\x,-3pt) node[anchor=north] {};
				\draw[-] (0,0) -- (0,4) coordinate (y axis);
				\foreach \y/\ytext in {0, 1, 2, 3, 4}
					\draw (1pt,\y) -- (-1pt,\y) node[anchor=east] {};
				\coordinate (a) at (0,0);	
				\coordinate (b) at (1,0);	
				\coordinate [label=below left:] (s1) at (1/4, 0);
				\coordinate [label=below right:] (s2) at (3/4, 0);
				\draw [coverage] (-1/2,0) rectangle (1, 4/3);
				\draw [coverage] (0,4/3) rectangle (3/2,8/3);
\node [sensor] at (s1) [] {};
\node [sensor] at (s2) [] {};
				\draw [lifetime] (s1) -- (1/4,4/3);
				\draw [lifetime] (3/4,4/3) -- (3/4,8/3);
			\end{tikzpicture} }
\caption{\rr vs.\ \opt with  and 
.  The sensors are indicated by (red) dots.  Each of the
(blue) rectangles represents the active coverage region for one
sensor.  The dashed gray arrow helps to clarify which sensor is active
at a particular point in time.}
\label{fig:rr}
\end{figure}	

Given an instance  of \sosc, let  be the
total battery charge of the system and  be the average of the 's, weighted by
their respective battery charge.  We define the following lower bound
on :


\begin{lemma}
\label{lemma:convex}
, for every \sosc instance .
\end{lemma}
\begin{proof}
We have that

where the inequality is due to 
an implication of the Cauchy-Schwarz Inequality: , for any
positive .
\end{proof}

\iffalse 

\begin{lemma}(Convexity)
Let , where  is the average of the
's in . Then .
\end{lemma}		
\begin{proof}
Let . Since  is a convex function,

See Figure \ref{fig:convexity} for an illustration.
\end{proof}

\fi 




\section{Set Once Hardness Result}
\label{sec:hardness}

In this section we show that \sosc is NP-hard.  This is done using a
reduction from \partition.
	
\begin{theorem}
\label{thm:hardness}
\sosc is NP-hard.
\end{theorem}	
\begin{proof}Let  be a given instance of \partition, and
define .  We create an instance of
\sosc by placing  sensors with battery  at , and two
additional sensors equipped with battery  at  and
, respectively.  That is, the instance of \sosc consists
of sensor locations  and batteries .  We show that  if and only if the maximum
possible lifetime of  is achievable for the \sosc instance.
		
First, suppose , hence there exist two non-empty
disjoint subsets , such that ,
and .  Schedule the
sensors in  to iteratively cover the region
.  Since all of these sensors are located at
, this requires that each sensor's radius be set to ,
i.e. , for every .
Since the sum of their batteries is , this region can be covered
for exactly  time units.  With the help of the additional sensors
located at  and , whose radii are also set to
, the sensors in  can thus cover
 for  time units (see Figure~\ref{fig:hardness} for an
example).  Next, the sensors in  can cover  for an
additional  time units, since they all require a radius of
, for every .  Thus, the total lifetime
is .

\begin{figure}[t]
\centering		
\begin{tikzpicture}[domain=0:1,xscale=4.5, yscale=0.1	
		,coverage/.style={circle,draw=blue!50,fill=blue!20,thick,opacity=0.5}
		,lifetime/.style={->,dashed,thick,gray}
		,sensor/.style={circle,draw=black,fill=red!50,thick,opacity=0.75,inner sep=0pt,minimum size=2mm}
		,moved/.style={circle,draw=black,fill=blue!50,thick,opacity=0.75,inner sep=0pt,minimum size=2mm}]
	\draw[step=1cm,gray,very thin] (0,0) grid (1, 40);	
\draw[-] (0,0) -- (1,0) coordinate (x axis);
		\foreach \x/\xtext in {0, 0.33333/\frac{1}{3}, .666666/\frac{2}{3}, 1}
			\draw (\x, 16pt) -- (\x, -16pt) node[anchor=north] {};
	\draw[-] (0,0) -- (0,40) coordinate (y axis);
		\foreach \y/\ytext in {0, 10, 20, 30, 40}
			\draw (0.5pt,\y) -- (-0.5pt,\y) node[anchor=east] {};
\draw [coverage] (0,0) rectangle (1/3, 30);
	\draw [coverage] (1/3,0) rectangle (2/3, 18);
	\draw [coverage] (1/3,18) rectangle (2/3, 30);
	\draw [coverage] (2/3,0) rectangle (1, 30);
	\draw [coverage] (0,30) rectangle (1, 32);
	\draw [coverage] (0,32) rectangle (1, 40);
	\node [sensor] (s1) at (1/6, 0) [label=below:] {};
	\node [sensor] (s2) at (1/2, 0) [label=below:] {};
	\node [sensor] (s3) at (1/2, 1) [] {};
	\node [sensor] (s4) at (1/2, 2) [] {};
	\node [sensor] (s5) at (1/2, 3) [] {};
	\node [sensor] (s6) at (5/6, 0) [label=below:] {};
	\draw [lifetime] (s1) -- (1/6,30);
	\draw [lifetime] (1/2,0) -- (1/2,18);
	\draw [lifetime] (1/2,18) -- (1/2,30);
	\draw [lifetime] (5/6,0) -- (5/6,30);
	\draw [lifetime] (1/2,30) -- (1/2,32);
	\draw [lifetime] (1/2,32) -- (1/2,40);
\end{tikzpicture} \caption{Proof of NP-hardness.  is a given instance 
of \textsc{Partition}, and  is the translated \sosc
instance.}  
\label{fig:hardness}
\end{figure}


Now suppose that for such a \sosc instance, the lifetime of  is
achievable. Since the maximum possible lifetime is achievable, no
coverage can be wasted in the optimal schedule. In this case the radii
of the sensors at  and  must be exactly
, since otherwise, they would either not reach the endpoints
, or extend beyond them. Moreover, due the fact that all of
the other sensors are located at , and their coverage is thus
symmetric with respect to , it cannot be the case that sensor
 and sensor  are active at different times. Thus, the solution
requires a partition of the sensors located at  into two
groups: the first of which must work alongside sensors  and 
with a radius of  and a combined lifetime of ; and the
second of which must implement \rr for a lifetime of . The
batteries of these two partitions form a solution to \partition.
\end{proof}






\section{Round Robin}
\label{sec:rr}

We show in Appendix~\ref{sec:hardness} that \sosc is NP-hard, so 
we turn our attention to approximation algorithms.  While \rr is among
the simplest possible algorithms (note that its running time is
exactly ), the precise value of its approximation ratio is not
obvious (although it is not hard to see that  is an upper bound).
In~\cite{barnoy2011maximizing} an upper bound of  and a lower
bound of  were shown.
In this section, we show that the approximation ratio of \rr in \sosc
is exactly .
The structure of the proof is as follows.  We start with an optimal
schedule , and cut it into disjoint time intervals, or strips, such
that the same set of sensors is active within each time interval.
Each strip induces a \srsc instance  and a corresponding solution
.
Next, we show that for any such instance , there exists a
unit-battery instance  with the same optimum lifetime. Finally,
we prove a lower bound on the performance of \rr on such unit battery
instances. By combining these results, we prove that .






\subsection{Cutting the Schedule into Strips}

Given an instance , and a solution  with
lifetime , let  be the set of times until  in which a
sensor was turned on or off, namely
.
Let , where , for every . 
Next, we partition the time interval  into the sub-intervals
, for every .  

Next, we define a new instance for every sub-interval.  For every , let  be the set of sensors
that participate in covering  during the th sub-interval of
time, i.e.,
.
Also, let , and let  be the
energy that was consumed by sensor  during the th sub-interval,
i.e., .  Observe that  is a
valid instance of \srsc, for which , where  for every sensor  such that , is a solution
that achieves a lifetime of exactly .
Figure \ref{fig:strip_cut} 
provides an illustration of this procedure.

\begin{figure}[t]
\centering		
\subfloat[An optimal schedule ]{\begin{tikzpicture}[domain=0:1,xscale=3.5, yscale=0.35
		,coverage/.style={circle,draw=blue!50,fill=blue!20,thick,opacity=0.5}
		,lifetime/.style={->,dashed,thick,gray}
		,sensor/.style={circle,draw=black,fill=red!50,thick,opacity=0.75,inner sep=0pt,minimum size=2mm}
		,moved/.style={circle,draw=black,fill=blue!50,thick,opacity=0.75,inner sep=0pt,minimum size=2mm}]
	\def\maxT{10}
	\def\T{8.749078}
	\def\xa{0.2293328}
	\def\xb{0.2951739}
	\def\xc{0.499632}
	\def\xd{0.5197192}
	\def\xe{0.5370125}
	\def\xf{0.6695036}
	\def\xg{0.7662748}
	\draw[step=1cm,gray,very thin] (0,0) grid (1, \maxT);	
\draw[-] (0,0) -- (1,0) coordinate (x axis);
		\foreach \x/\xtext in {0, 1}
			\draw (\x, 8pt) -- (\x, -8pt) node[anchor=north] {};
	\draw[-] (0,0) -- (0,\maxT) coordinate (y axis);
		\foreach \y/\ytext in {0, 2, ..., \maxT}
			\draw (0.25pt,\y) -- (-0.25pt,\y) node[anchor=east] {};	
	\def\wa{3.724797}
	\def\wb{6.750549}
	\def\wc{7.112631}
	\draw (1pt,0) -- (-1pt,0) node[anchor=east] {};
	\draw (1pt,\wa) -- (-1pt,\wa) node[anchor=east] {};
	\draw (1pt,\wb) -- (-1pt,\wb) node[anchor=east] {};
	\draw (1pt,\wc) -- (-1pt,\wc) node[anchor=east] {};
	\draw (1pt,\T) -- (-1pt,\T) node[anchor=east] {};
	\node [] at (-0.21, 0.5*\T) [label=left:] {};
	\draw [<->] (-0.2,0) -- (-0.2,\T);
	\draw [coverage] (-0.03913823, 0) rectangle (0.4978038, 3.724797);
	\draw [lifetime] (0.2293328, 0) -- (0.2293328, 3.724797);
	\node [sensor] (s1) at (0.2293328, 0) [label=below left:] {};
	\draw [coverage] (0, 3.724797) rectangle (0.5903477, 7.112631);
	\draw [lifetime] (0.2951739, 3.724797) -- (0.2951739, 7.112631);
	\node [sensor] (s2) at (0.2951739, 0) [label=below:] {};
	\draw [coverage] (-0.0007360573, 6.750549) rectangle (1, 8.749078);
	\draw [lifetime] (0.499632, 6.750549) -- (0.499632, 8.749078);
	\node [sensor] (s3) at (0.499632, 0) [label=below:] {};
	\draw [coverage] (0.3390073, 3.724797) rectangle (1, 6.750549);
	\draw [lifetime] (0.6695036, 3.724797) -- (0.6695036, 6.750549);
	\node [sensor] (s6) at (0.6695036, 0) [label=below:] {};
	\draw [coverage] (0.4978038, 0) rectangle (1.034746, 3.724797);
	\draw [lifetime] (0.7662748, 0) -- (0.7662748, 3.724797);
	\node [sensor] (s7) at (0.7662748, 0) [label=below:] {};
\end{tikzpicture}

 }
\hspace{40pt}
\subfloat[One strip of that schedule ]{\begin{tikzpicture}[domain=0:1,xscale=3.5, yscale=0.35
		,coverage/.style={circle,draw=blue!50,fill=blue!20,thick,opacity=0.5}
		,lifetime/.style={->,dashed,thick,gray}
		,sensor/.style={circle,draw=black,fill=red!50,thick,opacity=0.75,inner sep=0pt,minimum size=2mm}
		,moved/.style={circle,draw=black,fill=blue!50,thick,opacity=0.75,inner sep=0pt,minimum size=2mm}]
	\def\maxT{10}
	\def\T{12.53535}
	\def\xa{0.2293328}
	\def\xb{0.2951739}
	\def\xc{0.499632}
	\def\xd{0.5197192}
	\def\xe{0.5370125}
	\def\xf{0.6695036}
	\def\xg{0.7662748}
	\draw[step=1cm,gray,very thin] (0,0) grid (1, \maxT);	
\draw[-] (0,0) -- (1,0) coordinate (x axis);
		\foreach \x/\xtext in {0, 1}
			\draw (\x, 8pt) -- (\x, -8pt) node[anchor=north] {};
	\draw[-] (0,0) -- (0,\maxT) coordinate (y axis);
		\foreach \y/\ytext in {0, 2, ..., \maxT}
			\draw (0.25pt,\y) -- (-0.25pt,\y) node[anchor=east] {};
	\def\wa{3.724797}
	\def\wb{6.750549}
	\draw (1pt,\wa) -- (-1pt,\wa) node[anchor=east] {};
	\draw (1pt,\wb) -- (-1pt,\wb) node[anchor=east] {};
	\node [] at (-0.21, 5.2) [label=left:] {};
	\draw [<->] (-0.2,3.724797) -- (-0.2,6.750549);
	\draw [coverage] (0, 3.724797) rectangle (0.5903477, 6.750549);
	\draw [lifetime] (0.2951739, 3.724797) -- (0.2951739, 6.750549);
	\node [sensor] (s2) at (0.2951739, 0) [label=below:] {};
	\draw [coverage] (0.3390073, 3.724797) rectangle (1, 6.750549);
	\draw [lifetime] (0.6695036, 3.724797) -- (0.6695036, 6.750549);
	\node [sensor] (s6) at (0.6695036, 0) [label=below:] {};
\end{tikzpicture}

 }
\caption{Cutting an optimal schedule into strips. Note that coverage 
overlaps may occur in both the horizontal and vertical directions in
the optimal schedule, but only horizontally in a strip.}
\label{fig:strip_cut}
\end{figure}

We further modify the instance  and the solution
 as follows:
\begin{itemize*}
\item Starting with , remove sensor  from the instance, if 
      the interval  is covered during 
      without .
\item Decrease the battery and the radius of the left-most sensor as 
      much as possible, and also decrease the battery and the radius
      of the right-most sensor as much as possible.
\end{itemize*}


\begin{observation}
\label{obs:annoying}
Let sensors  and  be the leftmost and rightmost sensors in
.  Then, either  or the interval
 is only covered by sensor .  Also, either
 or the interval  is only
covered by sensor .
\end{observation}



For now, it is important to note only that  is the \rr lifetime of the th strip,
which is a specific \srsc instance  with the properties outlined
above.


\iffalse 

\begin{proof}
The theorem now follows from the upper bound and
Lemmas~\ref{lemma:dror}, \ref{lemma:strip_all}, and
\ref{lemma:strip_split}.  Suppose to the contrary that .  Then there must exist some strip  in which .  By Lemma~\ref{lemma:strip_split},
, while .  However, by Lemma~\ref{lemma:dror}, .  Thus, 

a contradiction.  Finally, Lemma \ref{lemma:strip_all} implies that
. 
\end{proof}

\fi 





\subsection{Reduction to Set Radius Strip Cover with Uniform Batteries}

Given the \srsc instance  and a solution , we
construct an instance  with unit size
batteries and a \srsc solution , such that the lifetime of
 is . That is, the optimal lifetime of  is
exactly the same as for , but it uses only unit batteries.

Let  denote the optimal \srsc lifetime.  We assume that  and  for every , since
\begin{inparaenum}[(i)]
\item  for every ,
\item , and
\item .
\end{inparaenum}

The instance  is constructed as follows.  We replace each sensor
 such that  with  unit battery sensors whose
average location is .  These unit battery sensors are called the
\emph{children} of .  To do this, we divide the interval  into  equal sub-intervals, and
place a unit battery sensor in the middle of each sub-interval.
Observe that child sensors may be placed outside , namely to
the left of  or to the right of .
The solution  is defined as follows.  For any child  of a
sensor  in , we set .  An example
is shown in Figure~\ref{fig:strip_split}.


\begin{figure}[t]
\centering		
\begin{tikzpicture}[domain=0:1,xscale=8, yscale=0.3
		,coverage/.style={circle,draw=blue!50,fill=blue!20,thick,opacity=0.5}
		,lifetime/.style={->,dashed,thick,gray}
		,sensor/.style={circle,draw=black,fill=red!50,thick,opacity=0.75,inner sep=0pt,minimum size=2mm}
		,moved/.style={circle,draw=black,fill=blue!50,thick,opacity=0.75,inner sep=0pt,minimum size=2mm}]
	\draw[step=1cm,gray,very thin] (0,0) grid (1, 6);	
	\draw[step=1cm,gray,very thin] (0,10) grid (1, 16);	
\draw[-] (0,0) -- (1,0) coordinate (x axis);
		\foreach \x/\xtext in {0, .5/\frac{1}{2}, 1}
			\draw (\x, 8pt) -- (\x, -8pt) node[anchor=north] {};
	\draw[-] (0,10) -- (1,10) coordinate (x axis);
		\foreach \x/\xtext in {0, .5/\frac{1}{2}, 1}
			\draw (\x, 10.2) -- (\x, 9.8) node[anchor=north] {};
	\draw[-] (0,0) -- (0,6) coordinate (y axis);
		\foreach \y/\ytext in {0, 6/12, 10/0, 16/12}
			\draw (0.25pt,\y) -- (-0.25pt,\y) node[anchor=east] {};
	\node [] at (-0.1, 3) [label=left:] {};
	\node [] at (-0.1, 13) [label=left:] {};
	\draw [<->] (-0.1,0) -- (-0.1,6);
	\draw [<->] (-0.1,10) -- (-0.1,16);
	\draw [coverage] (0,0) rectangle (1/6, 6);
	\draw [coverage] (1/6,0) rectangle (2/6, 6);
	\draw [coverage] (2/6,0) rectangle (3/6, 6);
	\draw [coverage] (11/24,0) rectangle (15/24, 6);
	\draw [coverage] (15/24,0) rectangle (19/24, 6);
	\draw [coverage] (19/24,0) rectangle (23/24, 6);
	\draw [coverage] (23/24,0) rectangle (27/24, 6);
	\draw [coverage] (0,10) rectangle (1/2, 16);
	\draw [coverage] (11/24,10) rectangle (27/24, 16);
	\node [sensor] (si11) at (1/12, 0) [label=below:] {};
	\node [sensor] (si12) at (3/12, 0) [label=below:] {};
	\node [sensor] (si13) at (5/12, 0) [label=below:] {};
	\node [sensor] (si21) at (13/24, 0) [label=below:] {};
	\node [sensor] (si22) at (17/24, 0) [label=below:] {};
	\node [sensor] (si23) at (21/24, 0) [label=below:] {};
	\node [sensor] (si24) at (25/24, 0) [label=below:] {};
	\draw [lifetime] (si11) -- (1/12,6);
	\draw [lifetime] (si12) -- (3/12,6);
	\draw [lifetime] (si13) -- (5/12,6);
	\draw [lifetime] (si21) -- (13/24,6);
	\draw [lifetime] (si22) -- (17/24,6);
	\draw [lifetime] (si23) -- (21/24,6);
	\draw [lifetime] (si24) -- (25/24,6);
	\node [sensor] (si1) at (1/4, 10) [label=below:] {};
	\node [sensor] (si2) at (19/24, 10) [label=below:] {};
	\draw [lifetime] (si1) -- (1/4,16);
	\draw [lifetime] (si2) -- (19/24,16);
	\draw [dotted] (si1) -- (si11);
	\draw [dotted] (si1) -- (si12);
	\draw [dotted] (si1) -- (si13);
	\draw [dotted] (si2) -- (si21);
	\draw [dotted] (si2) -- (si22);
	\draw [dotted] (si2) -- (si23);
	\draw [dotted] (si2) -- (si24);
\end{tikzpicture} \caption{Reduction of a non-uniform battery strip  to a uniform 
battery instance : At the top, , while at the bottom, .}
\label{fig:strip_split}
\end{figure}





\begin{lemma}
\label{lemma:unit-sol}
The lifetime of  is .
\end{lemma}
\begin{proof}
First, the  children of a sensor  in  cover the
interval .  Also, a child  of
 survives  time units.
\end{proof}

Next, we prove that the lower bound on the performance of \rr may only
decrease.

\begin{lemma}
\label{lemma:unit-convex}
.
\end{lemma}
\begin{proof}
Let  be the \rr radii of .
Observe that if , it follows that

and that if , we have that

Hence, 

and the lemma follows.
\end{proof}




\subsection{Analysis of Round Robin for Unit Batteries}

For the remainder of this section, we assume that we are given a unit
battery instance  that corresponds to the th strip.  (We drop
the subscript  and go back to  for readability.)  Recall that  is not necessarily equal to , since some children 
could have been created outside  in the previous step.  We show
that .

Let  and let  be the indices of the left-most and right-most sensors in
, respectively.  

\begin{lemma}
\label{lemma:Delta}
.
\end{lemma}
\begin{proof}
By Observation~\ref{obs:annoying} either  and hence none
of its children are located to the left of , or the points to the
left of  are only covered by sensor , which means that
the gaps between 's children to the left of zero also appears
between its children within .  (Recall that , for
all .)  The same argument can be used for the right-most sensor.
\end{proof}

As illustrated in Figure~\ref{fig:delta_definition}, we define


and



\begin{figure}[t]
\centering		
\begin{tikzpicture}[domain=0:1,xscale=10, yscale=1
,sensor/.style={circle,draw=black,fill=red!50,thick,opacity=0.75,inner sep=0pt,minimum size=2mm}
,moved/.style={circle,draw=black,fill=blue!50,thick,opacity=0.75,inner sep=0pt,minimum size=2mm}]
\draw[-] (0,0) -- (1,0) coordinate (x axis);
	\foreach \x/\xtext in {0, 0.5/\frac{1}{2}, 1}
		\draw (\x,1pt) -- (\x,-1pt) node[anchor=north] {};
\node [sensor] (s0) at (-0.05, 0) [label=below:] {};
\node [sensor] (s1) at (0.07, 0) [label=below:] {};
\node [sensor] (s2) at (0.19, 0) [label=below:] {};
\node [sensor] (s3) at (0.28, 0) [label=below:] {};
\node [sensor] (s4) at (0.44, 0) [label=below:] {};
\node [sensor] (s5) at (0.6, 0) [label=below:] {};
\node [sensor] (s6) at (0.76, 0) [label=below:] {};
\node [sensor] (s7) at (0.92, 0) [label=below:] {};
\draw[|-|] (-0.05, 1/2) -- (0.07, 1/2) node[above] at (0.01,1/2) {};
\draw[|-|] (0.07, 1/2) -- (0.19, 1/2) node[above] at (0.13,1/2) {};
\draw[|-|] (0.19, 1/2) -- (0.28, 1/2) node[above] at (0.245,1/2) {};
\draw[|-|] (0.28, 1/2) -- (0.44, 1/2) node[above] at (0.36,1/2) {};
\draw[|-|] (0.44, 1/2) -- (0.6, 1/2) node[above] at (0.53,1/2) {};
\draw[|-|] (0.6, 1/2) -- (0.76, 1/2) node[above] at (0.68,1/2) {};
\draw[|-|] (0.76, 1/2) -- (0.92, 1/2) node[above] at (0.84,1/2) {};
\draw[|-|] (0.92, 1/2) -- (1, 1/2);
\end{tikzpicture} \caption{Illustration of the gaps in a unit battery instance . 
Note that  and .  , since sensor 
is closer to  than sensor .  Also, .  Hence,
.}
\label{fig:delta_definition}
\end{figure}


We describe the optimal \srsc lifetime in terms of .

\begin{lemma}
\label{lemma:unit-opt}
The optimum lifetime of  is .
\end{lemma}
\begin{proof}
To verify that  can be achieved, consider the solution in
which  for all .  Clearly,  is covered,
and all sensors die after  time units.  Now suppose that a
solution  exists with lifetime strictly greater than .
Hence .  By definition,  must
equal , , or the maximum internal gap.  If the
latter, then there exists a point  between the two
sensors forming the maximum internal gap that is uncovered. On the
other hand, if , then if , 0
is uncovered, and otherwise, there is a point in  that is
uncovered.  A similar argument holds if .
\end{proof}

In the next definition we transform  into an instance  by
pushing sensors away from , so that each internal gap between
sensors is of equal width.
See Figure~\ref{fig:stretching} for an illustration. 

\begin{definition}
For a given instance , let  be a sensor whose location is
closest to .  Then we define the \emph{stretched} instance 
of  as follows:
 
\end{definition}	

\begin{figure}[t]
\centering
\subfloat[An instance ]{\begin{tikzpicture}[domain=0:1,xscale=3.9, yscale=1.2
		,sensor/.style={circle,draw=black,fill=red!50,thick,opacity=0.75,inner sep=0pt,minimum size=2mm}
		,moved/.style={circle,draw=black,fill=blue!50,thick,opacity=0.75,inner sep=0pt,minimum size=2mm}]
\draw[-] (0,0) -- (1,0) coordinate (x axis);
		\foreach \x/\xtext in {0, 0.5/\frac{1}{2}, 1}
			\draw (\x,1pt) -- (\x,-1pt) node[anchor=north] {};
	\draw[-] (0,0) -- (0,2) coordinate (y axis);
		\foreach \y/\ytext in {0, 1, 2}
			\draw (1pt,\y) -- (-1pt,\y) node[anchor=east] {};
	\draw[color=red,very thick,domain=0:0.5] plot (\x,{1/(1-\x)}) node[right] {};
	\draw[color=red,very thick,domain=0.5:1] plot (\x,1/\x) node[right] {};
\def\a{0.44}
	\def\d{0.25}
	\def\dd{0.125}
	\node [sensor] (s1) at (0.07, 0) [label=above:] {};
	\node [sensor] (s2) at (0.19, 0) [label=above:] {};
	\node [sensor] (s3) at (\a, 0) [label=above:] {};
	\node [sensor] (s4) at (0.6, 0) [label=above:] {};
	\node [sensor] (s5) at (0.78, 0) [label=above:] {};
	\node [sensor] (s6) at (0.91, 0) [label=above:] {};
\draw[|-|] (\a, 2/3) -- (\a - \d, 2/3) node[above] at (\a - \dd,2/3) {};
\end{tikzpicture} }
\hspace{40pt}
\subfloat[The stretched instance ]{\begin{tikzpicture}[domain=0:1,xscale=3.9, yscale=1.2
		,sensor/.style={circle,draw=black,fill=red!50,thick,opacity=0.75,inner sep=0pt,minimum size=2mm}
		,moved/.style={circle,draw=black,fill=blue!50,thick,opacity=0.75,inner sep=0pt,minimum size=2mm}]
\draw[-] (0,0) -- (1,0) coordinate (x axis);
		\foreach \x/\xtext in {0, 0.5/\frac{1}{2}, 1}
			\draw (\x,1pt) -- (\x,-1pt) node[anchor=north] {};
	\draw[-] (0,0) -- (0,2) coordinate (y axis);
		\foreach \y/\ytext in {0, 1, 2}
			\draw (1pt,\y) -- (-1pt,\y) node[anchor=east] {};
	\draw[color=red,very thick,domain=-0.06:0.5] plot (\x,{1/(1-\x)}) node[right] {};
	\draw[color=red,very thick,domain=0.5:1.2] plot (\x,1/\x) node[right] {};
\def\a{0.44}
	\def\d{0.25}
	\def\dd{0.125}
	\def\h{0.6}
	\node [moved] (s1) at (\a - 2*\d, 0) [label=above:] {};
	\node [moved] (s2) at (\a - \d, 0) [label=above:] {};
	\node [sensor] (s3) at (\a, 0) [label=above:] {};
	\node [moved] (s4) at (\a + \d, 0) [label=above:] {};
	\node [moved] (s5) at (\a + 2*\d, 0) [label=above:] {};
	\node [moved] (s6) at (\a + 3*\d, 0) [label=above:] {};
\draw[|-|] (\a - 2*\d, \h) -- (\a - \d, \h) node[above] at (\a - 3*\dd, \h) {};
	\draw[|-|] (\a, \h) -- (\a - \d, \h) node[above] at (\a - \dd, \h) {};
	\draw[|-|] (\a, \h) -- (\a + \d, \h) node[above] at (\a + \dd, \h) {};
	\draw[|-|] (\a + \d, \h) -- (\a + 2*\d, \h) node[above] at (\a + 3*\dd, \h) {};
	\draw[|-|] (\a + 2*\d, \h) -- (\a + 3*\d, \h) node[above] at (\a + 5*\dd, \h) {};
\end{tikzpicture} }
\vspace{-5pt}
\caption{Transformation of instance  to stretched instance . The sensor closest to  () remains in place, while the other sensors are placed at increasing intervals of  away from . The \rr lifetime of a sensor is shown as a continuous function of its location .}
\label{fig:stretching}
\end{figure}
	




\begin{observation}
Let  be a stretched instance of .  Then  and .
\end{observation}


\begin{lemma}
\label{lemma:stretch}
Let  be the stretched instance of .  Then,  and .
\end{lemma}
\begin{proof}
First, by construction, the internal gaps in  are of length
 and .  Thus, by
Lemma~\ref{lemma:unit-opt}, .
By Lemma~\ref{lemma:Delta} we know that the sensors moved away from
, hence  and .
\end{proof}

Now we are ready to bound .
	
\begin{lemma}
\label{lemma:ratio}
, for every instance  of \srsc, where sensors may be located outside
.
\end{lemma}
\begin{proof}
By Lemma~\ref{lemma:stretch} we may assume that the instance is
stretched.  
First, suppose that  is even.  Since  is a stretched instance,
it must be the case that exactly half of the sensors lie to the left
of , and exactly half lie to the right.
Hence,

where we have used the fact that since the sequence is stretched
.  Furthermore, since , it now follows that

		
If  is odd, then w.l.o.g.\ 
there are  sensors to the left of , and
 to the right.  Then

We have two cases. 
If , then there are  gaps of size , as
well as one gap of size at most . Since the gaps cover the
entire interval, we have that .
It follows that .  Thus, we can
demonstrate the same bound, since

Finally, we consider the case where .  For some , we can set .
Since sensors  and  are of distance  from
one another, it follows that

Moreover, we will show that , and thus
.  To see this, note first
that it follows from the definition of a stretch sequence and the
assumption that  that 
and .  Hence their difference is

However since , it must be the case
that , and this implies that .

Finally, a computation similar to the one above reveals that

As this is the same bound that we obtained in the even case, we
similarly achieve the same  bound. 
\end{proof}

\subsection{Putting It All Together}

It remains only to connect the pieces we have accumulated in the previous three sections. 

\begin{lemma}
\label{lemma:strip}
, for every strip .  
\end{lemma}

\begin{proof}
The result follows immediately from Lemmas~\ref{lemma:unit-sol},
\ref{lemma:unit-convex}, and ~\ref{lemma:ratio}.
\end{proof}

Our main result now follows from our construction. 

\begin{theorem}
\label{thm:main}
\rr is a -approximation algorithm for \sosc.
\end{theorem}
\begin{proof}
First, observe that 

By Lemmas~\ref{lemma:convex} and~\ref{lemma:strip} we have that

and we are done.
\end{proof}




\subsection{Strip Cover}


Theorem~\ref{thm:main} readily extends to the \strip problem. 

\begin{theorem}
\rr is a -approximation algorithm for \strip.
\end{theorem}


\iffalse 

We also show that there is a gap between the lifetime of optimal
solutions of \sosc and \strip.

\begin{lemma}
\label{lemma:general}
There exists an instance  for which the ratio between the
optimal value for \strip and the optimal value of \sosc is 
.
\end{lemma}
\begin{proof}Consider the instance with three sensors where  and .

In \strip all can work together with radii  for  time
units, and then the second sensor can survive for  more time units
with by adjusting its radius to .  Hence we get a lifetime of
 which is the best possible.

On the other hand, in \sosc sensor  has two radial options,
 and .  If the radius of sensor  is set to
, then all sensors work together for  time units.
Otherwise, if its radius is set to  then it works alone for 
time units.  The other sensors can work for an additional  units,
and once again we get  units of lifetime. See Figure~\ref{fig:sosc-gap}. 
\end{proof}

\begin{figure}[t]
\centering
\subfloat[]{\input{tikz/strip_opt}}
\subfloat[]{\input{tikz/sosc_opt}}
\caption{An optimal \sosc solution is at least a  approximation of an optimal \strip solution.}
\label{fig:sosc-gap}
\end{figure}

\fi 



\section{Duty Cycle Algorithms}
\label{sec:dc}

In this paper we analyzed the \rr algorithm in which each
sensor works alone.  One may consider a more general version of this
approach, where a schedule induces a partition of the sensors into
sets, or \emph{shifts}, and each shift works by itself.  In \rr each
shift consists of one active sensor.  We refer to such an algorithm as a
\emph{duty cycle} algorithm.

In this section we show that, in the worst case, no duty cycle
algorithm outperforms \rr.  More specifically, we show that the
approximation ratio of any duty cycle algorithm is at least
.

\begin{lemma}
\label{lemma:DC}
The approximation ratio of any duty cycle algorithm is at least
 for both \sosc and \strip.
\end{lemma}
\begin{proof}Consider an instance where  and .  An optimal solution is obtained by
assigning ,  and .  That is, sensor  covers the interval
 for  time units, sensors  covers  until time
, and sensors  covers  from time  to .  This
solution is optimal in that it achieves the maximum possible lifetime
of .

\begin{figure}[t]
\centering
\subfloat[]{			\begin{tikzpicture}[xscale=3.5, yscale=0.4,
				coverage/.style={circle,draw=blue!50,fill=blue!20,thick,opacity=0.5},
				lifetime/.style={->,dashed,thick,gray},
				sensor/.style={circle,draw=black,fill=red!50,thick,opacity=0.75,inner sep=0pt,minimum size=2mm}]
				\def\T{8}
				\draw[step=1cm,gray,very thin] (0,0) grid (1, \T);	
				\draw[-] (0,0) -- (1,0) coordinate (x axis);
				\foreach \x/\xtext in {0, 0.5/\frac{1}{2}, 1}
					\draw (\x, 7pt) -- (\x, -7pt) node[anchor=north] {};
				\draw[-] (0,0) -- (0,8) coordinate (y axis);
				\foreach \y/\ytext in {0, 2,..., \T}
					\draw (1pt,\y) -- (-1pt,\y) node[anchor=east] {};
				\coordinate (a) at (0,0);	
				\coordinate (b) at (1,0);	
				\draw [coverage] (0,0) rectangle (1/2, \T);
				\draw [coverage] (1/2,0) rectangle (1, 4);
				\draw [coverage] (1/2,4) rectangle (1, \T);
				\node [sensor] (s1) at (1/4, 0) [label=below:] {};
				\node [sensor] (s2) at (3/4, 0) [label=below:] {};
				\node [sensor] (s3) at (3/4, 0.4) [label=right:] {};
				\draw [lifetime] (s1) -- (1/4,\T);
				\draw [lifetime] (s2) -- (3/4,4);
				\draw [lifetime] (3/4,4) -- (3/4,\T);
			\end{tikzpicture} }
\subfloat[]{			\begin{tikzpicture}[xscale=3, yscale=0.4,
				coverage/.style={circle,draw=blue!50,fill=blue!20,thick,opacity=0.5},
				lifetime/.style={->,dashed,thick,gray},
				sensor/.style={circle,draw=black,fill=red!50,thick,opacity=0.75,inner sep=0pt,minimum size=2mm}]
				\def\T{8}
				\draw[step=1cm,gray,very thin] (0,0) grid (1, \T);	
				\draw[-] (0,0) -- (1,0) coordinate (x axis);
				\foreach \x/\xtext in {0, 0.5/\frac{1}{2}, 1}
					\draw (\x, 7pt) -- (\x, -7pt) node[anchor=north] {};
				\draw[-] (0,0) -- (0,8) coordinate (y axis);
				\foreach \y/\ytext in {0, 2,..., \T}
					\draw (1pt,\y) -- (-1pt,\y) node[anchor=east] {};
				\draw [coverage] (-1/2,0) rectangle (1, 8/3);
				\draw [coverage] (0,8/3) rectangle (3/2, 12/3);
				\draw [coverage] (0,12/3) rectangle (3/2, 16/3);
				\coordinate (a) at (0,0);	
				\coordinate (b) at (1,0);	
				\node [sensor] (s1) at (1/4, 0) [label=below:] {};
				\node [sensor] (s2) at (3/4, 0) [label=below:] {};
				\node [sensor] (s3) at (3/4, 0.4) [label=right:] {};
				\draw [lifetime] (s1) -- (1/4,8/3);
				\draw [lifetime] (3/4,8/3) -- (3/4,4);
				\draw [lifetime] (3/4,4) -- (3/4,16/3);
			\end{tikzpicture} }
\caption{Best schedule vs.\ best duty cycle schedule. 
Here  and .}
\label{fig:DC}
\end{figure}

On the other hand, the best duty cycle algorithm is \rr, which
achieves a lifetime of  time units.  (The shifts  and
 would also result in a lifetime of  time units.)
Both schedules are shown in Figure~\ref{fig:DC}.
\end{proof}




\section{Set Radius Strip Cover}
\label{sec:srsc}

In this section we present an optimal -time algorithm
for the \srsc problem.
Recall that in \srsc we may only set the radii of the sensors since
all the activation times must be set to 0.  More specifically, we
assign non-zero radii to a subset of the sensors which we call \emph{active}, while the rest of
the sensors get  and do not participate in the cover. 


Given an instance , a radial assignment  is called
\emph{proper} if the following conditions hold:
\begin{enumerate*}
\item Every sensor is either inactive, or exhausts its battery by 
      time , where  is the lifetime of . That is, ,
\item No sensor's coverage is superfluous. That is, for every active 
      sensor  there is a point  such that  and , for every active .
\end{enumerate*}

\begin{lemma}
\label{lemma:proper}
There is
a proper optimal assignment for every \srsc instance.
\end{lemma}
\begin{proof}Let  be a \srsc instance, and let  be an optimal
assignment for  with lifetime .  We first define the assignment
 and show that it is feasible.  Since  has lifetime
, any point  is covered by some sensor  throughout
the time interval .  It follows that .  Hence, , and thus 
has lifetime .
Next, we construct an assignment .  Initially, .
Then starting with , we set  as long as 
remains feasible.  Clearly, .  Furthermore,
for every sensor  there must be a point  such that , for every active , since
otherwise  would have been deactivated.  Hence,  is a
proper assignment with lifetime , and is thus optimal.
\end{proof}


Given a proper optimal solution, we add two dummy sensors, denoted 
and , with zero radii and zero batteries at  and at ,
respectively.  The dummy sensors are considered active.
We show that the optimal lifetime of a given instance is determined by
at most two active sensors.

\begin{lemma}
\label{lemma:pair}
Let  be the optimal lifetime of a given \srsc instance .
There exist two sensors , where ,
such that .
\end{lemma}
\begin{proof}Let  be the proper optimal assignment, whose existence is
guaranteed by Lemma~\ref{lemma:proper}.  We claim that there exist two
neighboring active sensors  and , where , such that .  The lemma follows, since  and
.

Observe that if , for two neighboring
active sensors  and , then there is a point in the interval
 that is covered by neither  and , but is covered by
another sensor.  This means that either  or  is redundant, in
contradiction to  being proper. Hence, , for every two neighboring active sensors  and .

Let .  If , then we are done.  Otherwise,
we define the assignment .   is feasible
since , for every two neighboring active sensors  and
. Furthermore, the lifetime of  is , in
contradiction to the optimality of .
\end{proof}

Lemma~\ref{lemma:pair} implies that there are  possible
lifetimes.  This leads to an algorithm for solving \srsc.

\begin{theorem}
\label{thm:srsc}
There exists an -time algorithm for solving \srsc.
\end{theorem}
\begin{proof}First if , then  and we
are done.
Otherwise, let , for every  such that .  After sorting the set
, perform a binary search to find the largest
potentially feasible lifetime.  The feasibility of candidate 
can be checked using the assignment , for every sensor .

There are  candidates, each takes  to compute, and
sorting takes  time.  Checking the feasibility of a
candidate takes  time, and thus the binary search takes .  Hence, the overall running time is .
\end{proof}



\section{Discussion and Open Problems}

We have shown that \rr, which is perhaps the simplest possible
algorithm, has a tight approximation ratio of  for both
\sosc and \strip.  We have also shown that \sosc is NP-hard, but it
remains to be seen whether the same is true for \strip.  Future work
may include finding algorithms with better approximation ratios for
either problem. However, we have eliminated duty cycle algorithms as
candidates.
Observe that both \sosc and \stsc are NP-hard, while \srsc can be
solved in polynomial time.  This suggests that hardness comes from
setting the activation times.

We have assumed that the battery charges dissipate in direct
inverse proportion to the assigned sensing radius (e.g. ). It is natural to suppose that an exponent could factor into
this relationship, so that, say, the radius drains in quadratic
inverse proportion to the sensing radius (e.g. ).
One could expand the scope of the problem to higher
dimensions. Before moving both the sensor locations and the
region being covered to the plane, one might consider moving one but
not the other. This yields two different problems: 1) covering the
line with sensors located in the plane; and 2) covering a region of
the plane with sensors located on a line.









\bibliographystyle{abbrv}
\bibliography{references}



\end{document}
