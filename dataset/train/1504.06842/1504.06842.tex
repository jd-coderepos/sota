









\documentclass[english,runningheads,11pt]{llncs-revised}
\usepackage{tabularx,booktabs,multirow,delarray,array}
\usepackage{graphicx,amssymb,amsmath,amssymb}
\usepackage{latexsym}
\usepackage[in]{fullpage}

\def\calP{\mathcal{P}}
\def\calR{\mathcal{R}}
\def\calF{\mathcal{F}}
\def\calC{\mathcal{C}}
\def\st{-}
\def\hatd{\hat{d}}

\newcommand{\TT}{\mbox{}}
\newcommand{\SF}{\mbox{}}
\newcommand{\vtd}{\mbox{}}
\newcommand{\htd}{\mbox{}}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\newtheorem{observation}{Observation}
\newenvironment{myproof}{\noindent {\textbf{Proof:}}\rm}{\hfill \rm}



\begin{document}

\title{An Optimal Algorithm for Minimum-Link Rectilinear Paths in Triangulated Rectilinear Domains\thanks{A preliminary version of
this paper will appear in the Proceedings of the 42nd International Colloquium on Automata, Languages, and Programming (ICALP 2015).
}
}

\author{Joseph S.B. Mitchell\inst{1}
\and
Valentin Polishchuk\inst{2}
\and
Mikko Sysikaski\inst{3}
\and
Haitao Wang\inst{4}
}

\institute{
Stony Brook University, Stony Brook,  NY 11794, USA\\
\email{jsbm@ams.stonybrook.edu}\\
\and
Link\"{o}ping University, Link\"{o}ping, Sweden\\
\email{valentin.polishchuk@liu.se}\\
\and
Google, Zurich, Switzerland\\
\email{mikko.sysikaski@gmail.com}\\
\and
Utah State University, Logan, UT 84322, USA\\
\email{haitao.wang@usu.edu}\\
}


\maketitle

\pagestyle{plain}
\pagenumbering{arabic}
\setcounter{page}{1}


\vspace{-0.2in}
\begin{abstract}
We consider the problem of finding minimum-link
rectilinear paths in rectilinear polygonal domains in the plane.
A path or a polygon is rectilinear if all its edges are axis-parallel.
Given a set  of  pairwise-disjoint rectilinear polygonal obstacles
with a total of  vertices in the plane, a {\em minimum-link rectilinear
path} between two points is a rectilinear path that avoids all
obstacles with the minimum number of edges.
In this paper, we present a new algorithm for finding minimum-link rectilinear paths among .
After the plane is triangulated, with respect to any source point ,  our algorithm
builds an -size data structure in  time, such
that given any query point , the number of edges of a minimum-link
rectilinear path from  to  can be computed in
 time and the actual path can be output in additional time
linear in the number of the edges of the path. The previously best algorithm
computes such a data structure in  time.
\end{abstract}



\section{Introduction}
\label{sec:intro}

Paths with few turns have applications in a variety of areas,
including VLSI design, computer vision,
cartography, geographical information systems, robotics, computer
graphics, image processing, and solid modeling
\cite{ref:ArkinLo95,ref:DjidjevAn92,ref:GuibasAp93,ref:KolarovOn91,ref:McMasterAu87,ref:NatarajanOn91,ref:ReifMi87,ref:SuriMi87,ref:TamassiaOn86}.
Finding paths with few turns (or
minimum-link paths) has received much attention, e.g.,
\cite{ref:AdegeestMi94,ref:ArkinLo95,ref:DasGe91,ref:deBergOn91,ref:deRezendeRe89,ref:ElGindyHi85,ref:GhoshCo91,ref:ImaiEf86,ref:LingasOp95,ref:MaheshwariLi00,ref:MitchellMi14,ref:MitchellMi92,ref:ReifMi87,ref:SchuiererAn96,ref:SuriA86,ref:SuriMi87,ref:SuriOn90}.
In this paper, we enrich the literature by presenting a new algorithm for
finding the minimum-link rectilinear paths among rectilinear polygonal
domains in the plane.


Given a set  of  pairwise-disjoint polygonal obstacles with
a total of  vertices in the plane,
the plane minus the interior of all obstacles is called the {\em free space}.
The {\em link distance} of a
path is defined to be the number of edges (also called {\em links})
in the path. A {\em minimum-link path} (or {\em min-link} path)
between two points  and  is a path from  to  in the free space
with the minimum link distance.
The {\em min-link path query} problem is to construct a data structure (called
{\em link distance map}) with respect to a given {\em source} point
, such that for any query point , a min-link path from 
to  can be quickly computed. In the following, we say a
link distance map has the {\em standard query performance} if given any
, the link distance of a min-link \st\ path can be computed in
 time and the actual path can be output in additional time
linear in the link distance of the path.

A polygon (or path) is {\em rectilinear} if all its edges are
axis-parallel.   is a {\em rectilinear
polygonal domain} if every obstacle of  is rectilinear
(e.g., see Fig.~\ref{fig:rectilinear}).
The {\em rectilinear version} of the min-link path/query problem is to
find min-link {\em rectilinear} paths in rectilinear polygonal domains.
Rectilinear polygons are commonly used as
approximations to arbitrary simply polygons; and they arise naturally
in domains dominated by Cartesian coordinates, such as raster
graphics, VLSI design (as mentioned earlier), robotics, or architecture.


\begin{figure}[t]
\begin{minipage}[t]{\linewidth}
\begin{center}
\includegraphics[totalheight=1.1in]{rectilinear.eps}
\caption{\footnotesize Illustrating a rectilinear min-link path in
a rectilinear polygonal domain.}
\label{fig:rectilinear}
\end{center}
\end{minipage}
\vspace*{-0.15in}
\end{figure}


\subsection{Previous Work}

Linear-time algorithms have been given for finding min-link paths in simple polygons
\cite{ref:GhoshCo91,ref:HershbergerCo94,ref:SuriA86,ref:SuriMi87,ref:SuriOn90}.
The link distance map can also be built in
linear time \cite{ref:SuriA86,ref:SuriMi87,ref:SuriOn90} for simple
polygons, with the standard query performance.
For polygonal domains, the problem becomes much more
difficult.
Mitchell, Rote, and Woeginger \cite{ref:MitchellMi92}
gave an  time
algorithm for finding min-link paths, where 
is the inverse Ackermann function; a link distance map with slightly more
construction time is also given in \cite{ref:MitchellMi92}.
As shown by Mitchell, Polishchuk, and Sysikaski
\cite{ref:MitchellMi14}, finding
min-link paths in polygonal domains is 3SUM-hard.


The rectilinear min-link path problems have also been studied.
For simple rectilinear polygons, de Berg \cite{ref:deBergOn91}
presented an algorithm that can build an -size
link distance map in  time and  space, with the standard query
performance. The construction time was later reduced
to  time by Lingas, Maheshwari, and Sack
\cite{ref:LingasOp95}, and by Schuierer \cite{ref:SchuiererAn96}.

For rectilinear polygonal domains, Imai and
Asano \cite{ref:ImaiEf86} presented an   time and space
algorithm for finding min-link rectilinear paths.
Later, Das and Narasimhan \cite{ref:DasGe91} described an
improved algorithm of  time and  space; Sato,
Sakanaka, and Ohtsuki \cite{ref:SatoA87} gave a similar algorithm with the same
performance.
Recently, Mitchell, Polishchuk, and Sysikaski \cite{ref:MitchellMi14}
presented a simpler algorithm of  time and  space.
Link distance maps of -size can also be built in 
time and  space \cite{ref:DasGe91,ref:MitchellMi14}.
As shown in \cite{ref:DasGe91,ref:MaheshwariLi00}, the problem of finding min-link
rectilinear paths in rectilinear polygonal domains has a lower bound
of  on the running time. Therefore, the algorithms in
\cite{ref:DasGe91,ref:MitchellMi14,ref:SatoA87} are optimal only if
.

However, since the value  can be substantially smaller than
, it is desirable to have an
algorithm whose running time is bounded by , where 
is a function of .


In addition, the -oriented version of the min-link paths problems have also been
considered \cite{ref:AdegeestMi94,ref:HershbergerCo94,ref:MitchellMi14},
where the edges of the paths are allowed to have 
different directions. Our rectilinear version is essentially a special
case of the -oriented version with .
	



\subsection{Our Results}
We consider the rectilinear min-link paths in a rectilinear domain .
After the free space of  is triangulated,
our algorithm builds a link distance map in
 time and  space, with the standard query performance.
The triangulation can be done
in  time or 
time for any  \cite{ref:Bar-YehudaTr94}.
Hence, our result is an improvement over the previous 
time algorithms \cite{ref:DasGe91,ref:MitchellMi14,ref:SatoA87}, especially
 when  is substantially smaller than , e.g., if  for any
, our algorithm runs in  time.







\subsection{Algorithm Overview}
Our idea is to combine Das and
Narasimhan's algorithmic scheme
\cite{ref:DasGe91} and a {\em corridor structure} of polygonal
domains.  The corridor structure and its extensions have been used to solve
shortest path problems, e.g.,
\cite{ref:ChenTw14,ref:ChenA11ESA,ref:KapoorAn97,ref:MitchellSe95};
however, to the best of our knowledge, it was not used to tackle
min-link path problems. The corridor structure partitions the free
space of  into  corridors and  ``junction''
rectangles that connect all corridors.


The algorithm in \cite{ref:DasGe91} (which we call the DN algorithm) sweeps the free space, from the source point , to build the map.
The sweep is controlled in a global way so that the time is bounded by
. This global sweeping on the entire free space restricts the DN algorithm from being implemented in  time because each operation takes  time and there are  operations. Using the corridor structure, our algorithm avoids the global sweeping on the entire free space.
When the sweep is in junction rectangles, we control the sweep in a global way as
in the DN algorithm. However, when the sweep enters a corridor,
we process the corridor independently and ``locally'' without considering the
space outside the corridor. Since a
corridor is a simple polygon, we are able to design a
faster algorithm for processing the sweep in it.
When we finish processing a corridor, we arrive at a junction rectangle.
Next, we pick an unprocessed junction
rectangle that currently has the smallest link distance to  to
``resume'' the sweep. This is somewhat similar to Dijkstra's shortest path algorithm.
In this way, there are only  operations that need to be performed in logarithmic time each.


To achieve the  time bound, we have to implement the algorithm in a very careful manner. For example, we need an efficient
algorithm to compute link distance maps in corridors (i.e.,
simple rectilinear polygons).
Although efficient algorithms are available for computing the link
distance maps in simple polygons, e.g.,
\cite{ref:deBergOn91,ref:HershbergerCo94,ref:LingasOp95,ref:SchuiererAn96},
they are not suitable for our main algorithmic scheme, which requires
an algorithm with some special properties. Specifically, let
 be a corridor. Suppose there are 
pairwise-disjoint segments on a vertical edge  (called a
``door'') of  and these segments are considered as ``light sources'', stored in a balanced binary search tree.  We
want to build a link distance map in , and obtain a balanced
binary search tree storing the light sources (let  be their number)
going out of  through another vertical edge 
(another ``door'') of . Our goal is to design
a ``corridor-processing'' algorithm for the above problem with running time
, where  is the number of vertices of . We derive such an
algorithm, which might be of independent interest.




The rest of the paper is organized as follows.
In Section \ref{sec:pre}, we define notation and
review the DN algorithm \cite{ref:DasGe91}.
In Section \ref{sec:mainscheme}, we introduce the corridor structure
and present the main scheme of our algorithm while leaving our
algorithms for processing corridors in Section \ref{sec:algocorridor}.
Section \ref{sec:conclude} concludes the paper.

\section{Preliminaries}
\label{sec:pre}

For simplicity of discussion,
let  be a large rectangle that contains all obstacles of
 and let  denote the free space of  in . Note that our algorithm can handle the case where  is an arbitrary rectilinear polygon, but for simplicity of discussion, we consider the case where  is a rectangle.
We assume  has been triangulated. Let  be a given source
point in .  For ease of exposition, we make a general position
assumption that no three vertices of  have
the same - or -coordinate; the assumption can be lifted without
affecting the performance of the algorithm asymptotically although
more tedious discussions would be needed.
In the following, paths always refer to
rectilinear paths in . For any point  in
, a path from  to  is also referred to as an -
path. An edge of a path is also called a {\em link} of the path.

Consider any point .
An \st\ path  is called a {\em horizontal-start-vertical-end}
path (or {\em h-v-path} for short)
if the first link of  (i.e., the edge incident to ) is
horizontal and the last link of  (i.e., the edge incident to ) is
vertical. The {\em h-h-paths}, {\em v-h-paths}, and {\em v-v-paths} are
defined analogously.
To make it consistent, if  is an h-h-path of  links,
we also consider it to be an h-v-path of  links (i.e., we
enforce an additional edge of zero length at the end of the path), and
similarly, it is also considered to be an v-h-path of  links and
a v-v-path of  links. A {\em min-link h-v-path} from  to  is an h-v-path from  to  with
the minimum number of links. The {\em min-link h-h-paths}, {\em min-link v-h-paths}, and {\em min-link v-v-paths} are
defined analogously.
To find a min-link \st\ path, our algorithm will
find the following four \st\ paths: a min-link h-v-path,   a min-link
h-h-path,  a min-link v-v-path, and a min-link v-h-path. Clearly,
among the above four paths, the one with the minimum number of links
is a min-link \st\ path.



To answer the min-link query, our algorithm will compute four link
distance maps of  size each: an {\em  h-h-map}, an {\em h-v-map}, a {\em v-h-map},
and a {\em v-v-map}, defined as follows. The h-h-map is a
decomposition of  into regions such that for any region ,
the link distances of the min-link h-h-paths from  to all points in
 are the same. The other three maps are defined analogously.
In addition, we build linear-size point location data structures
\cite{ref:EdelsbrunnerOp86,ref:KirkpatrickOp83} on these maps in linear
time.  With the above four maps, for any query point , we determine the region
containing  in each map and the one
with the smallest link distance gives our sought min-link \st\ path
distance.

The {\em vertical visibility decomposition} of , denoted by
,
is obtained by extending each vertical edge of the obstacles in
 until it hits either another obstacle or
the boundary of  (e.g., see Fig.~\ref{fig:vtd}).
We call the above edge extensions the {\em diagonals}.
We consider the source  as a special obstacle and extend a vertical diagonal
through .
Since  has been triangulated,   can be obtained in
 time \cite{ref:Bar-YehudaTr94,ref:ChazelleTr91,ref:ChazelleTr84,ref:FournierTr84}.
In ,  is decomposed into rectangles,
also called {\em cells}. Due to our general position
assumption, each vertical side of a cell may contain at most two diagonals.
The horizontal visibility decomposition of , denoted by , is
defined similarly by extending the horizontal edges of .

Our v-v-map is on , i.e., for each cell  of
, the
link distances of the min-link v-v-paths from  to all points in 
that are not on diagonals
are the same and we denote this distance by , and for
each diagonal  of , the
link distances of the min-link v-v-paths from  to all points on 
are the same and we denote this distance by . In fact, it holds that ,
where  and  are the two cells on the left and right of ,
respectively.
The goal of our algorithm for computing the v-v-map is to compute
 for each cell  and  for each
diagonal  of .  In
addition, we also need to maintain some path information to retrieve
an actual path for each query.

Similarly, our h-v-map is also on , but the h-h-map and the v-h-map
are both on .

\begin{figure}[t]
\begin{minipage}[t]{\linewidth}
\begin{center}
\includegraphics[totalheight=1.8in]{vtd.eps}
\caption{\footnotesize Illustrating the vertical visibility
decomposition of . }
\label{fig:vtd}
\end{center}
\end{minipage}
\vspace{-0.15in}
\end{figure}



In Section \ref{sec:DN}, we review and discuss the DN algorithm \cite{ref:DasGe91} in a way that will help us to introduce our algorithm later. The DN algorithm only labels the diagonals of .
Das and Narasimhan \cite{ref:DasGe91} claimed that queries can be
answered by using only the distance values on the diagonals. However,
this is not clear to us. We, instead, also label the cells
as discussed above. We will show in Section \ref{sec:labelcell} that the DN algorithm can be easily
adapted to computing the link distances for the cells too. We will also discuss in Section \ref{sec:labelcell} how to maintain path information to retrieve an actual path for each query.


\subsection{The DN Algorithm}
\label{sec:DN}


The DN algorithm also computes the four maps discussed above. We consider the
v-v-map first. The algorithm works on the vertical visibility
decomposition  and the goal is to compute  for each
diagonal .
To simplify the notation, unless otherwise
stated, we use  to refer to .
Initially, all diagonals have distance value
 except , where  is the diagonal through .
Note that if a diagonal  is on a side  of a cell, then
whenever  is updated,  is automatically set to .

The DN algorithm has many phases. In the -th phase for , the
algorithm determines the set  of diagonals  whose distances
 are equal to , and these diagonals are then ``labeled''
with distance  (e.g., see Fig.~\ref{fig:DN}). Initially, , and  consists of
the only diagonal through . As discussed in \cite{ref:DasGe91},
if we put light sources on the diagonals in ,
then  consists of all new diagonals that will get illuminated with light emanating horizontally from the light sources.

Consider a general -th phase for .
We assume  has been determined. There are
two procedures: {\em right-sweep} and {\em left-sweep}. In the
right-sweep (resp., left-sweep), we illuminate the diagonals in the direction
from left to right (resp., from right to left).
The right-sweep procedure starts from the
{\em locally-rightmost} diagonals of , defined as follows.
Consider any diagonal  in . Let  be the cell of  on the
right of , i.e.,  is on the left side of .
Let  be the right side of . If \footnote{
Alternatively, one may replace  by 
for the definition, but we choose to use  only for
making our discussion later easier and this will not affect the
algorithm running time.}, then  is a {\em locally-rightmost} diagonal of .
Similarly, the left-sweep starts from the {\em
locally-leftmost} diagonals of . Both
locally-leftmost and locally-rightmost diagonals are referred to as
{\em locally-outmost} diagonals. Below, we first discuss the
right-sweep.

\begin{figure}[t]
\begin{minipage}[t]{0.60\linewidth}
\begin{center}
\includegraphics[totalheight=2.0in]{DN.eps}
\caption{\footnotesize Illustrating the DN algorithm: all diagonals
have been labeled. Note that the three thick dash-dotted diagonals
(labeled ) are swept twice in the second phase.}
\label{fig:DN}
\end{center}
\end{minipage}
\hspace*{0.05in}
\begin{minipage}[t]{0.38\linewidth}
\begin{center}
\includegraphics[totalheight=1.5in]{cell.eps}
\caption{\footnotesize Illustrating a cell  where  is on the
left side of .}
\label{fig:cell}
\end{center}
\end{minipage}
\vspace{-0.15in}
\end{figure}

For each
locally-rightmost diagonal , we put a rightward ``light beam'' on
, and let  denote the beam;
we also call  the {\em generator} of the beam.
Formally, we may define the beam as the segment  associated with the rightward
direction. Initially we insert all locally-rightmost
diagonals into a min-heap  whose ``keys'' are the -coordinates of the
diagonals (i.e., the leftmost diagonal is at the root).
By using , the diagonals involved in the right-sweep will be processed from left to
right. As discussed in \cite{ref:DasGe91}, this can control the
right-sweep in a global manner and thus avoid the same
diagonal being processed many times.
Although initially each diagonal of  has only one
beam, later we will insert more diagonals into  and a
diagonal  may have more than one beam,
in which case  denotes the set of beams on .

As long as  is not empty, we repeatedly do the following.

We obtain the leftmost diagonal  of  and remove it from .
Let  be the cell on the right of  (e.g., see Fig.~\ref{fig:cell}).
We {\em process}  in the following way. Intuitively we want to
propagate the beams of  to other diagonals in .
Let  and  denote the left and right sides of , respectively.
Note that  is on .  Recall that each cell side has at
most two diagonals.

If  has another diagonal  (e.g., see Fig.~\ref{fig:cell}) and  has
not been labeled (i.e., ), then we set . The beam set
 of  is set to 
since there is no beam from  illuminating .
Further, although , we associate the {\em
leftward direction} with it, because
if later the left-sweep procedure does not illuminate , 
will be a locally-leftmost diagonal of  and
generate a leftward beam in the next phase.
We ``temporarily'' mark  as a locally-leftmost
diagonal.
We say ``temporarily'' because  may not be
locally-leftmost any more after the left-sweep procedure, as discussed later.

If  has been labeled, then  must be . To see this, because we are currently at the -th phase, any diagonal that has been labeled must have a distance value at most . But if , then  has already been processed, and since  and  are on the same cell side, we must have already obtained , contradicting with . Hence, . In this case, we do nothing on .


Next, we consider the diagonals on
the right side  of . Depending on the values
of , there are several cases. Since we are at the -th
phase, either  or .


\begin{enumerate}
\item
If , then we do nothing on  because all diagonals on  have already
been processed.

\item
If ,
then we set . If  does not have any diagonals,
we are done. Otherwise, for each diagonal
 on , we determine the portions of beams of  that can
illuminate , which are the rightward projections of  on
 (beams of  may be ``narrowed'' or ``split'', e.g., see Fig.~\ref{fig:beams}). We use
 to denote the above portions of . It is
possible that  is empty.

If , then we temporarily mark  as a locally-rightmost diagonal
and set  with the {\em rightward
direction}; otherwise, we set  and insert  to
 (later we will propagate the beams of  further to the
right).


\begin{figure}[t]
\begin{minipage}[t]{\linewidth}
\begin{center}
\includegraphics[totalheight=1.3in]{beams.eps}
\caption{\footnotesize Illustrating some beam operations in a right-sweep procedure: In (a) and (b), beams are {\em split}, and some beams are ``narrowed'' and some beams ``terminate'' at obstacle edges; in (c), beams are {\em merged}.}
\label{fig:beams}
\end{center}
\end{minipage}
\vspace{-0.15in}
\end{figure}


\item
If , this case happens because 
was illuminated by beams from another diagonal  on .
Hence, each diagonal  on
 may already have a non-empty . But  may receive
more beams from . We first determine  (as defined
above) and then
do a ``merge'' operation by merging  with  (e.g., see Fig.~\ref{fig:beams}).
Finally, we set  to the above merged set of beams (with the
rightward direction). Due to the merge operation,
 may contain more than one beam.

If  was empty before the merge and becomes non-empty after the
merge, then we insert  into . If  is still empty after
the merge, then we temporarily mark  as a locally-rightmost diagonal.
If  was non-empty before the merge, then  is already in
, so we do not need to insert it into  again.
\end{enumerate}

The above finishes the processing of .  The right-sweep is done
once  becomes empty. For the implementation, we
need to maintain the beams of  on each diagonal . To this end,
as in \cite{ref:DasGe91}, we can use
a balanced binary search tree (e.g., a 2-3-4 tree \cite{ref:CLRS09}) such that we can perform
the ``merge'', ``split'', ``insertion'',
``deletion'', and ``search'' operations each in logarithmic time.


The left-sweep procedure is similar. However, there is one
subtle thing. If the sweep encounters a diagonal  that has been
labeled by the right-sweep, then this is ignored and
we keep sweeping as if  were not labeled.
As discussed in
\cite{ref:DasGe91}, the reason for this is that the left-sweep may reach more
cells than the right-sweep (e.g., see Fig.~\ref{fig:DN}). In this way, each diagonal
can be processed at most twice in a phase. But no diagonal can be
processed in more than one phase.
Also, suppose a diagonal  was temporarily marked as a locally-outmost diagonal during the right-sweep; if  is illuminated again in the left-sweep but  is not marked locally-outmost in the left-sweep, then we clear the previous mark on  (i.e.,  is not considered locally-outmost  any more).
After the left-sweep, the
remaining locally-outmost diagonals are exactly those that will be
used in the next phase.

The above describes the -th phase of the algorithm. The algorithm
is done after all diagonals are labeled.
Due to that heaps are used to control the sweep procedures and balanced binary
search tree are used to support beam operations, the total time of the
algorithm is  because each diagonal can be processed at most
twice in the entire algorithm (once by a left-sweep procedure and
once by a right-sweep procedure). Clearly, the space is .

For computing the h-v-map, the algorithm is similar except that  now consists of all
diagonals that intersect , where  is the horizontal line segment
extended from  until it hits the obstacles, and in each -th
phase for , the value  is set to  for
any diagonal  in . The algorithms for computing
h-h-map and v-h-map in  are symmetric.

\subsection{Labeling Cells and Retrieving Paths}
\label{sec:labelcell}

We first show how to slightly modify the DN algorithm to label cells.
We only discuss the v-v-map since the other maps are similar.


Recall that for each cell  of , all the points
in  that are not on the diagonals have the same distance values.
Hence, to compute , it is sufficient to know the distance
value for any arbitrary point in  that is not on any diagonal. To this end,
for each cell , we add a
vertical segment in  with its upper endpoint on the upper side of
 and its lower endpoint on the lower side of  such that the
segment is not overlapped with the left side or the right side of ;
hence, no point of the segment is on any diagonal, and
we call the segment a ``fake diagonal''. Let  denote
 with all fake diagonals.
We run the DN algorithm on  and treat all fake diagonals
as ``ordinary diagonals'' to label all diagonals and fake diagonals of
. Finally, we label each cell of
 with the same distance value as its fake diagonal.
Since the total number of fake diagonals are , the running time is still
 and the space is .

To obtain an actual min-link v-v-path from  to , we need to
maintain additional information on our v-v-map. No details
on this are given in \cite{ref:DasGe91}.
We briefly discuss it below for the completeness
of this paper. Essentially, when we
label the cell sides (and the fake diagonals), we need to record how
we reach there. Specifically, suppose we label a diagonal  on the
right side of a cell in a right-sweep procedure due
to a beam from a diagonal on the left side of the cell; then we record any such
beam at  (it is sufficient to record any
point on  in the beam) along with its
generator, and in the case where  is empty,
 is a locally-outmost diagonal and the path should make a turn
there. Further, for each locally-outmost diagonal , it is reached by a beam that illuminates the
cell side containing  and we record that beam for  so that we know the turn on  is for that beam.
With this path information, for any query point ,
we can easily retrieve an actual
min-link v-v-path from  back to  in time we claimed before. We omit the
details.


\section{The Main Scheme of Our Algorithm}
\label{sec:mainscheme}



In this section, we focus on the main scheme of our algorithm while leaving
the algorithms for processing corridors in
Section \ref{sec:algocorridor}. We first introduce the corridor
structure.

\subsection{The Corridor Structure}
\label{sec:corridor}

The corridor structure in rectilinear domains is similar to that
in general polygonal domains \cite{ref:KapoorAn97}.
Let  be the dual graph of the vertical visibility
decomposition  (see
Fig.~\ref{fig:graphG}), i.e., each node of
 corresponds to a cell of  ,
and each edge of  connects two
nodes corresponding to two cells sharing the same diagonal.
Based on , we obtain a {\em corridor graph}  as follows (see
Fig.~\ref{fig:reduceG}). First, we
remove every degree-one node from  along with its incident edge;
repeat this process until no degree-one node exists. Second,
remove every degree-two node from 
and replace its two incident edges by a
single edge; repeat this process until no degree-two node exists. The
remaining graph is . The cells in  corresponding to the nodes
in  are called {\em junction cells} (see Fig.~\ref{fig:reduceG}).
We consider the diagonal through  as a degenerate junction cell.
Similar to the corridor structure in the
general polygonal domains \cite{ref:KapoorAn97},
the graph  has  nodes and  edges.
The removal of all junction cells from  results in 
{\em corridors}, each of which corresponds to an edge of .


\begin{figure}[t]
\begin{minipage}[t]{0.49\linewidth}
\begin{center}
\includegraphics[totalheight=1.6in]{graphG.eps}
\caption{\footnotesize Illustrating the vertical visibility
decomposition (the
dashed segments are diagonals) and its dual graph . }
\label{fig:graphG}
\end{center}
\end{minipage}
\hspace{0.02in}
\begin{minipage}[t]{0.49\linewidth}
\begin{center}
\includegraphics[totalheight=1.6in]{reduceG.eps}
\caption{\footnotesize Illustrating the graph ,
and the corridor (shaded by slashes)
bounded by  and .
}
\label{fig:reduceG}
\end{center}
\end{minipage}
\end{figure}


The boundary of any corridor  consists of four parts (see
Fig.~\ref{fig:reduceG}): (1) The boundary portion of an obstacle , from
a point  to a point ; (2) a diagonal ; (3) the
boundary portion of an obstacle  from  to a point ; (4) a
diagonal .  The two diagonals 
and  are called the {\em doors} of the corridor .
The corridor  is a simple rectilinear polygon.



\subsection{The Main Idea}
\label{sec:main}

We focus on computing the v-v-map on , and
the other three maps can be computed similarly.
Our goal is to label  for each diagonal  of , i.e., compute the
distance value .
As discussed in Section \ref{sec:labelcell}, the same algorithm
can be used to label cells as well. As in the DN algorithm
each diagonal  will maintain a beam set .




Here is some intuition that motivates us to improve the DN algorithm.
When we are running the DN algorithm, a sweep
procedure will enter each corridor though one of its two doors, and the
procedure will either sweep the entire corridor and leave the corridor
through the other door, or terminate inside the corridor (in which case
the sweep ``hits'' another sweep that entered the corridor through the
other door and both sweeps terminate after ``collision'').  This means that if we can
determine the beams and the distance values at the doors of a corridor,
then we can process the corridor independently in a more efficient way since
the corridor is a simple rectilinear polygon.


Our algorithm follows the similar scheme as the DN algorithm. The
sweep in the junction cells is still processed and
controlled in a global manner in each phase.
However, whenever the sweep enters a corridor through one of its doors, the corridor will
be processed independently by using our more efficient {\em
corridor-processing} algorithm given in Section \ref{sec:algocorridor}
(one may view that the sweep procedure jumps from one junction cell to
another through the corridor connecting them).
We should point out that since
in the DN algorithm a diagonal may be processed twice in the two
sweep procedures in the same phase, an entire corridor may be processed twice in
the same phase (that case happens {\em only if} the beams on a door
can illuminate the other door directly, and vice versa).

The running time of our algorithm is . More specifically, since
there are  junction cells, the time spent on processing the
diagonals in all
junction cells is , and the processing on all corridors
takes  time because the number of vertices of all
corridors is , in addition to another  time spent on
maintaining the beams on all diagonals.

\subsection{The Algorithm}

To help the reader understand the algorithm, we first describe the first few
steps of the algorithm and then delve into the details of the general steps.

Initially, we set  to  and  for each diagonal  except
that  and , where  is the diagonal through .
In our discussion of the corridor structure,  is
considered as a degenerate junction cell. Here, for ease of
discussion, we assume  is in the interior of a corridor  as shown
in Fig.~\ref{fig:reduceG}. We first process , i.e., label
all diagonals in .  For the purpose of describing our algorithm,
one may assume we still use the DN algorithm to process ,
and later we will replace the DN algorithm by our
new and more efficient corridor-processing algorithm in Section \ref{sec:algocorridor}.


Denote by  and  the two doors of  (e.g., see
Fig.~\ref{fig:reduceG}). Suppose after the above processing of
,  and  for some integers 
and .  Since  is obtained ``locally'' in ,
i.e.,  is the link distance of the {\em local} min-link v-v-path from
 to  in , it may not be ``set correctly'', i.e., it may not be
the link distance of the {\em global} min-link v-v-path from   to  in
. The value  has the same issue. However, we show
below the at least one of  and  must have been set
correctly.

Without loss of generality, assume .

\begin{observation}\label{obser:10}
If , then the value  has been set correctly.
\end{observation}
\begin{proof}
Let  be any global min-link v-v-path from  to  in . For any subpath  of ,
we use  to denote the link distance of .
If  is in
, then our observation follows. Otherwise,  must cross one of
the doors of . Let  be the first
point on a door of the corridor if we go from  to  along
, and let  denote the sub-path of  from  to . If  is on , then  is a min-link v-v-path from 
to . Since  and  is the link distance of the local
min-link v-v-path from  to  in , we have , and thus our observation follows. If 
is on , then . Therefore,  and our observation also follows.\qed
\end{proof}

Another way to see the observation is that if we were running the DN algorithm,
after the -th phase, neither  nor  is labeled, and
no diagonal outside the corridor is labeled either. In the -th
phase,  will be labeled and thus  is set
correctly.


After the processing of , the beams on , i.e.,
, have also been obtained.
The next step is to process the diagonal  by propagating the
beams of  outside the corridor.



Next, we describe the details of the general steps of our algorithm.

We use a min-heap  to maintain the diagonals in all junction cells where the ``keys'' are the distance values the diagonals currently have (and these values may not be set correctly), with the {\em smallest} key at the root of .  Since there are  junction cells, the size of  is always .
Each diagonal  in  is also associated with its beam set
 (along with its direction).
As in the DN algorithm, it is possible that  is empty,
in which case  might be a locally-outmost
diagonal, but it is also associated with a
direction for generating a beam towards that direction  in the next phase.



If some diagonals of  have the same
keys, we break the ties by applying the following rules. Consider
two diagonals  and  in  with . If
 and  are both empty or both non-empty, then we break ties
arbitrarily. Otherwise, without loss of generality, assume  is
not empty but  is empty. Then, we consider the key of  to be {\em smaller}
than that of  in .
The reason is as follows. Since  and ,
the current sweep procedure should be over {\em before}
processing  while the sweep
should continue {\em after} processing , and thus, we
should process  before .  Therefore,
our way of resolving ties in  is crucial and consistent with the DN algorithm.
In the following, to differentiate from keys of other heaps, for any diagonal , even if  is not in , we consider  along with  as the {\em global-key} of , and whenever we compare the global-keys of diagonals, we always follow the above rules.


Consider any corridor  with two doors  and . Suppose
the beams of  are going inside , and we want to
{\em process}  (i.e., compute the v-v-map in ) using the beams of .
We say the above way of processing  is in the {\em direction} from
 to . As will be seen later,
a corridor may be processed twice: once
from  to  and the other from  to . Due
to the special geometric structure of the corridor, we have the
following observation that will be useful later.

\begin{observation}\label{obser:20}
Suppose  and  are the two doors of a corridor , and the
direction of the beams of  is towards the inside of . Then after  is
processed by using , the beam set of  is not empty.
\end{observation}
\begin{proof}
Let  denote the vertical visibility decomposition of the
corridor .
Consider the cell  of  that contains .
Without loss of generality, assume  is on the right side of
. Denote by  the right side of .

We claim that  is the entire right side of , i.e.,  is .
Indeed, according to our corridor structure,  is an extension of a
vertical obstacle edge  and one endpoint  of  is also an endpoint of
 and the other endpoint of  is outside the corridor . This
means  is also an endpoint of  and
the other endpoint  of  than  is not on  but on
another obstacle edge . Due to our general position assumption
that no two vertical edges are collinear,  must be in the interior of
, implying that  is also an endpoint of . Hence, we obtain .


Note that we obtain the beam set of  from the rightward beams of
the diagonals on the left side of . Now that  is
the entire right side of ,  will receive all beams of any
diagonal on the left side of . Hence, the beam set of  cannot be empty.\qed
\end{proof}

To show the correctness of our algorithm, we will argue that
our algorithm is consistent with the DN algorithm.
We will show that after the algorithm finishes, each diagonal
in any junction cell is {\em correctly labeled}, i.e.,
both its distance value and its beam set are the same as those in the
DN algorithm.  Let  be the diagonal in the root of .
Our algorithm will maintain the following three invariants.

\begin{enumerate}
\item
The diagonal  is correctly labeled. Further,
for any other diagonal  in a junction cell, if the global-key of  is no larger than that of , then  has been  correctly labeled.




\item
For any diagonal  in a junction cell, if  and
the global-key of  is larger than that of , then  is in .

\item
For any corridor  with two doors  and , if  is
processed in the direction from  to ,
then  will never be processed from  to  again in the entire
algorithm (although  may be processed later in the other direction from  to ).
\end{enumerate}

Initially . Recall that  and .
We consider the diagonal  through  as a degenerate junction cell. Specifically, we consider  as two duplicate diagonals with one generating a rightward beam and the other generating a leftward beam from the entire . We insert these two diagonals into .
Clearly all algorithm invariants hold.
In the following we will describe the details of our algorithm. To
avoid the tedious discussion, we
will not explicitly explain that the algorithm invariants are
maintained after each step, but rather discuss it briefly later after the algorithm
description.

As long as  is not empty, we repeatedly do the following.

By an extract-min operation on , we obtain the diagonal  of  with
the smallest global-key and remove it from . We assume  for some integer .
If we were running the DN algorithm, we are currently working on the
-th phase. There are two cases depending on
whether .

\subsubsection{}




We first discuss our algorithm for the case where . If we were running the DN algorithm, we would be in the ``middle''
of the -th phase (because  implies that all locally-outmost diagonals
have already been processed). So we
should continue the left-sweep and right-sweep of the -th phase.
The first question is where we should start the sweep.
Let  be the set of all diagonals in  that have the same global-keys as  (according to our way of comparing global-keys, for each diagonal , it holds that
 and ).
By the first algorithm invariant, all diagonals in  have been correctly
labeled. Due to our corridor structure, the sweeps of the -th phase
``paused'' at the diagonals in . To continue the -th phase, we
``resume'' the sweeps from these diagonals. Unlike the DN algorithm
where we complete the right-sweep before we start the left-sweep,
here, before the pause, we may have already done some left-sweep and
right-sweep. Hence, the two sweeps may be somehow ``interleaved'' and
our algorithm will need to take care of this situation.

Due to our way of breaking ties in , the diagonals of  can be found by
continuing the extract-min operations on  in  time (i.e., all diagonals of  are removed from ). We also let  contain .
Let  (resp., ) be the subset of the diagonals of  whose beams are rightward (resp., leftward).
Intuitively, the right-sweep (resp., left-sweep) paused at the diagonals in  (resp., ), and thus,
we resume it from the diagonals in  (resp.,
). Below we focus on the right-sweep, and the left-sweep is very similar.


Recall that in the right-sweep of the DN algorithm we use a heap
 to guide the procedure. Here we do the same thing and
process the diagonals of  from left to right.
We build a heap  by inserting the diagonals of , and the
``keys'' of diagonals in  are
their -coordinates such that the leftmost diagonal is at the root.
(Similarly, we build a heap  on  for the left-sweep.)



The algorithm essentially performs the -th phase as the DN
algorithm. But since here the right-sweep and left-sweep may be
interleaved, in the following discussion, some diagonals may have two
sets of beams with opposite directions. However, our algorithm makes
sure that if a diagonal  has
two sets of beams with opposite directions, it will not be in
 (i.e., it has been removed from ), but in both  and 
if  has not been processed yet.
To differentiate the two sets of beams, we use  (resp., ) to denote the beam set of any diagonal  in  (resp., ), meaning that the direction of
the beams is rightward (resp., leftward).


During the right-sweep, if we find a new diagonal  that has the same global-key as , then  will be inserted to  and  will be removed from  if it is already in . Hence, all diagonals of  have the same global-key as . In fact,  maintains all diagonals in junction cells that will be processed in the subsequent right-sweep of the -th phase.

As long as  is not empty, we repeatedly do the following.

We obtain the leftmost diagonal  of  (which is at the root of )
and remove it from . The beams of  may
enter either a junction cell or a corridor. In the sequel,
we discuss how to process  in these two cases.

\paragraph{The beams of  entering a junction cell.}
Let  denote the junction cell that the beams of  enter.
In this case, our way of processing  is similar to
the DN algorithm. Let  and  denote the left and
right sides of , respectively. Note that  is on the left side
. Recall that each cell side may have two diagonals. To process
, we update the labels of all other diagonals of , as
follows.

Suppose there is another diagonal  on  (e.g., see Fig.~\ref{fig:cell}).

If , we set  and
 with the leftward direction. Then, we insert  into
.

If  but , then we set
 and  (with the leftward direction).
Since  was greater than  but not , by the second algorithm invariant,
 is already in the heap .
Hence, after  and   are reset as above, we do
a ``decrease-key'' operation on  in  since the global-key of  has been decreased.

If , we do nothing.


Next, we consider the diagonals on the right side  of . Depending on the
distance value , there are several cases. Note that if
, then
 automatically got the value  because a diagonal  on
 was labeled with the same distance value.

\begin{enumerate}
\item
If , then we set . If  does not
have any diagonals, then we are done with processing . Otherwise,
for each diagonal  on , we set  and determine
, i.e., the portion of  that can illuminate .


If , then we set  and insert  to  (note that  has the same global-key as ).
Otherwise, we set  with the rightward direction and insert  into , because the global-key of  is larger than that of  and the right-sweep should stop at . Note that before the insertion,  was not in  as  was .

\item
If  but , then the algorithm is
similar as above. For each diagonal  on ,  was equal to , and now we set  and determine .

If ,
we set  and insert  into .
Since  was equal to , the global-key of  was larger than that of  and  was not . By the second algorithm invariant,  was already in .
Hence, we remove  from . Note that we can perform a remove operation on  in
 by doing a decrease-key operation followed by an extract-min
operation \cite{ref:CLRS09}.

If , we set .
Since   was already in ,
after setting  and  ,  we need to do a
decrease-key operation on  in .

\item
If , we do nothing.

\item
If , due to that the left and right sweeps are
interleaved,  may have got labeled from the right-sweep, the
left-sweep, or both.
We discuss the three cases below. The algorithm for this case is also simple, but we need a few more words to explain why the algorithm works in that way.

\begin{enumerate}
\item
If  got the value  by the right-sweep only, as in
our discussions in the right-sweep of the DN algorithm,
this case happens because  was illuminated by beams from
another diagonal  on the left side . Hence, for each
diagonal  on ,  and  have been set.
Further, if , then  is in ; otherwise 
is in .

For each diagonal  on ,
we first determine , and then set  by merging the
original  with . If  was non-empty
before the merge, we do nothing since it is already in .
If  was empty before the
merge and becomes non-empty after the merge, then we insert  into
 and remove it from .
If  is still empty after the merge, then we do nothing
since it is already in .

\item
If  got the value  by the left-sweep only, then 
was illuminated by beams from its right. As discussed in the DN
algorithm, if the right-sweep procedure sweeps a diagonal  on ,
the fact that  was swept already by the left-sweep procedure
should be ignored in the sense that we should keep propagating the
beams of  to the right of . The details are given below.

For each diagonal  on , we first determine .

\begin{itemize}
\item
If , then we set 
and insert  into . If  was already in , then we remove
it from .

\item
If , no beam from  illuminates .
At first sight, it seems that we should insert  into 
with an empty beam set and the rightward direction.
Below we elaborate on whether we should do so.

Note that  is a door of a corridor  that is locally on the
right of .  It is possible that  got labeled
because the left-sweep was from , in which case
 is not empty by Observation \ref{obser:20},
and thus,  must be already in  (since )
and we do not need to insert  to  because  will be processed in the left-sweep of the current phase.

On the other hand, if  has another diagonal , then it is
possible that  got labeled because of the processing of the
corridor on the right of  during the left-sweep. In this case,  may have got
labeled because of the processing of , in which case as in
the DN algorithm the beam set of  must be empty and rightward, and thus 
is already in  with  and the rightward direction and we do
not insert  into  again. But if  has not been labeled yet,
then we insert  into  with  and the rightward
direction. Therefore, for the case where  has another diagonal
, if  is already in , we do
nothing; otherwise we insert  to .

It is also possible that  got labeled ``simultaneously'' because
of the processing of the two corridors on the right of  and ,
in which case by Observation \ref{obser:20} we again have , and thus  is already in . Hence, we do not need to insert  to .

In summary, for the case ,  if  is in
neither  nor , then we insert  into  with
 and the rightward direction; otherwise we do
nothing.

\end{itemize}

\item
If  got the value  by both the right-sweep and the
left-sweep, this is a combination case of the above two cases.

For each diagonal  on , we determine , and
then set  by merging the original  with .

If  was non-empty before the merge, then we do nothing since
 is already in .

If  was empty before the merge and becomes non-empty
after the merge, then we insert  into . Further, if  is
in , then we remove it from .

If  is still empty after the merge, as in the above second
case, we do the following. If  is in neither
 nor , then we insert  into  with
 and the rightward direction; otherwise we do
nothing.
\end{enumerate}
\end{enumerate}

We are done with processing  when the beams  of  enter
a junction cell.

\paragraph{The beams of  entering a corridor.}
Let  denote the corridor that the beams enter.
We process  using the beams of .
Again, one may assume we still use the DN algorithm to process ,
and later we will replace it by our corridor-processing
algorithm in Section \ref{sec:algocorridor}.

Let  be the distance value labeled on the other door  of 
by the above processing and let  denote the corresponding beam set
on . Let  and  be the original distance
value and beam set at  before the processing of .
By the third algorithm invariant, this is the first time  is processed in the direction from  to . Hence, if , then the value  must be obtained by the sweep
from outside , i.e., beams in  are towards the inside of .

Due to the above processing of , we have obtained another distance value  and beam set  for . Hence, we need to update the label of  and possibly insert  to some heap.
Depending on the value of , there are several cases.


\begin{enumerate}
\item
If  is , then we set  and .
If , then we insert  into .
If , since ,  must be
illuminated directly by the beams in  and the beams of  are still towards right.
By Observation \ref{obser:20}, .
Hence we obtain  (we set  to 
because the beams of  are rightward).  Finally, we insert  into .

\item
If , then the global-key of  is smaller than that of  because . By the first algorithm invariant,  has been
correctly labeled. Recall that the direction of  is towards the inside of .
Also by the first algorithm invariant,  is
correctly labeled, and the direction of the beam set of  is
towards the inside of . This means we have computed complete information on the
two doors of  for the min-link v-v-paths from  to the points
inside . Hence, we can do a ``post-processing'' step to
compute the v-v-map in  by using the beams of  and
. We will give a {\em corridor-post-processing} algorithm for this step later in Section \ref{sec:algocorridor}.

\item
If , then  has been labeled in the current phase.

If , then the global-key of  is the same as that of . By
the first algorithm invariant,  has been correctly labeled. Then, as
above, since both  and  have been correctly
labeled, we do a ``post-processing'' to compute the
v-v-map in  using  and .

If , then the global-key of  is strictly larger than that of
. By the second algorithm invariant,  is already in .
If , then we do nothing.
If , then as in the above first case, we set ;
finally, we insert  into  and remove  from .


\item
The remaining case is when  and .
We claim that this case can never happen.

Indeed, assume to the contrary that this case happens. Recall that the beams of  are towards the inside of the corridor . Let  be the junction cell that contains . Without loss of generality, assume  is on the left side of .
Clearly,  got labeled after some diagonal  in  was processed.
Since the beams of  that illuminate  must be towards the cell , they
are from the corridor that is bounded by . By Observation
\ref{obser:20}, the beam set of  is not empty. Hence, it must be
the case that . Since we use the heap  to guide the main algorithm and we are currently processing the diagonal  with , all diagonals of junction cells that have been processed must have distance values at most . However, the above shows that the diagonal 
has been processed with , incurring contradiction. Therefore, the case where  and
 cannot happen.
\end{enumerate}

The above finishes the processing of the diagonal . The
right-sweep procedure is done after the heap  becomes empty.
Afterwards we do the left-sweep from the diagonals of  using the heap  in the
symmetric way. We omit the details.

This finishes our algorithm in the case in which  is not empty
for the diagonal  at the root of . We briefly discuss that
after the above processing our algorithm invariants still hold.

Indeed, before the diagonals of  are processed, if we were running
the DN algorithm, at some moment during the -th phase, the
diagonals of  would be labeled the same as in our algorithm. Our algorithm
processes the diagonals of  in a way consistent with the DN
algorithm. Based on our previous discussion on how the sweep procedures of the DN
algorithm can sweep the corridors, after all diagonals of  are
processed, the diagonals in  with the smallest global-key must have been
correctly labeled because if we were running the DN algorithm, at some
moment the algorithm would label them in the same way. Also, since we
process diagonals in the order of their global-keys, any
diagonal that has global-key smaller than that of the root of  must have
been processed and labeled correctly. Hence, the first algorithm
invariant follows. For the second invariant, whenever a diagonal has
its distance value set to non-infinity for the first time, it is
always inserted into .
For the third invariant, as discussed in
the algorithm description, a corridor  is processed only if a
door  of  is processed and beams of  are towards
. Although  may be processed in the algorithm twice, it is
processed only once in either the right-sweep or the left-sweep.
Hence, with beams towards the inside of ,  is only
processed once in the entire algorithm, implying that  is
processed only once in the entire algorithm in the direction from  to
the other door of .


\subsubsection{}

In the sequel, we discuss the case where .
The algorithm is simpler in this case.  First,
we find the set  of diagonals in  that have the same global-key as , which can be done in  time by keeping doing the extract-min operations (i.e., all diagonals of  are removed from ). We also let  contain . According to our way of comparing global-keys, all
diagonals of  have empty beam sets. If we were running the DN
algorithm, the diagonals of  would be locally-outmost
and we would be about to start the -th phase (not the -th phase).
As in the previous case, we run the two sweep procedures
starting from the diagonals of .
Let  (resp., ) be the subset of diagonals of  whose beam directions
are rightward (resp., leftward).  We build a min-heap  (resp., )
on the diagonals of  (resp., ).
Below, we only discuss the right-sweep since the left-sweep is similar.

Since we are doing the right-sweep in the -th phase, each
diagonal of  will generate a beam from the entire diagonal, and
all new diagonals illuminated in the right-sweep will
get distance value  instead of .
From now on, we associate each diagonal of  with the beam, i.e.,
for each ,  now consists of the only beam on  although it was
empty in the -th phase. Since each diagonal of  originally got an empty beam set (at the end of the -th phase), by Observation \ref{obser:20}, the beam of  cannot be towards a junction cell and thus it must be towards the inside of a corridor.

As long as  is not empty, we repeatedly do the following.

We obtain the leftmost diagonal  of  (which is at the root) and remove it from . Let  denote the corridor that the beams of  enter.
We process the corridor  using the beams of .
Again, one may assume we still use the DN algorithm to process ,
and later we will replace it by our corridor-processing
algorithm in Section \ref{sec:algocorridor}.


Let  be the distance on the other door  obtained by the above
processing and let  be the corresponding beam set.
Let  and  be the original distance value and beam set
at .
Again, by the third algorithm invariant, this is the the first
time  is processed in the direction from  to ; hence,
if , then  must be labeled by a sweep from outside 
and the beams of  must enter .
Depending on the value of , we may need to update the label of  in several cases.


\begin{enumerate}
\item
If , we set  and . Note that
. Hence, the global-key of  is strictly larger than that of , which has distance value .
We insert  into  (not ).



\item
If , then since , the global-key of  is no larger than that of  regardless of whether  is empty or not. By the first algorithm invariant,  has been correctly labeled. We do a ``post-processing'' to compute the
v-v-map in  by using the beams of  and . Again, we will give a {\em corridor-post-processing} algorithm for this step later in Section \ref{sec:algocorridor}.




\item
The remaining case is when  and .
By the same argument as in the previous case where
, this case cannot happen.
\end{enumerate}


The above describes the right-sweep procedure. The
left-sweep is similar.

This finishes our discussion in the case in which  is empty for
the diagonal  at the root of . As in the previous case, all
algorithm invariants hold.



The algorithm finishes if all three heaps , , and  become
empty. After that, for each diagonal  in a junction cell, 
and  have been correctly computed. During the algorithm
some corridors have been labeled correctly while others are left for
post-processing.



Specifically, consider any corridor  and let  and  be
its two doors with their beam sets  and . If  is not left for a post-processing, then  has been processed either from  to  or from  to  and the v-v-map in  has been computed after the processing. Suppose the above processing is from  and . Then,  is processed using the beams of  and  is obtained after the processing.
We will show in Section
\ref{sec:algocorridor} that our corridor-processing algorithm on  runs in  time, where  is the number of vertices of ,
, and .
If  is left for a post-processing, i.e., to compute the
v-v-map in  by using  and , we will show in
Section \ref{sec:algocorridor} that our
corridor-post-processing algorithm runs in  time.




\begin{lemma}
Given , our algorithm computes the v-v-map on  in  time.
\end{lemma}
\begin{proof}
Recall that the beams in our algorithm are generated by
locally-outmost diagonals. We say that two beams are {\em different}
if they do not have the same generator. We say a diagonal is {\em generated}
by a corridor if the generator of the
diagonal is in the corridor.

We first prove a {\em claim} that the
number of different beams at the diagonals in all junction cells is . To see this, a key
observation is that since a corridor is a simple rectilinear polygon,
it can only generate at most two new beams that can
go out of the corridor in the entire algorithm. Specifically, consider a
corridor  with doors  and . Suppose the algorithm
processes  in the direction from  to . Then, as will be seen later in Section \ref{sec:algocorridor}, if some beams of  can directly illuminate , then all beams of
 are from  (although some beams may become narrowed) and there is no new beam generated by ;
otherwise all beams of  terminate inside  and
 will only have one beam coming out of the corridor through  (this is because  is a simple rectilinear polygon).
Since any corridor can be processed at most twice,
it can generate at most two new beams.
Since there are  corridors, the total number of beams on
the diagonals of junction cells is .

To obtain the running time of the algorithm, we analyze the
time we spent on junction cells and the corridors separately. Due to the above
claim, the size of  for each diagonal  in any junction cell
is . Since there are  diagonals in all junction cells,
the total time we spent on processing them is .

For the time we spent on all corridors, it is the sum of the time
of our corridor-processing algorithm and corridor-post-processing
algorithm on all corridors.

Let  denote the set of the diagonals in all junction cells.
Define , , , , , , , and  the same as before. Suppose
 has been post-processed. Then the
corridor-post-processing algorithm on  takes
 time. The sum of the term  overall all
corridors is . All beams of  and  are terminated
inside  after the post-processing. Since the number of beams that are terminated inside corridors is no more than the number of different beams at the diagonals in all junction cells, by the above claim, the number of beams on the
diagonals of  that are terminated inside corridors is . Hence, the sum of
 (resp., ) over all corridors that have been post-processed
is , and the sum of  over all
corridors that have been post-processed is . Note that
each corridor can be post-processed at most once. This proves
that the total time of the corridor-post-processing algorithm in the
entire algorithm is .

We can use the similar approach to analyze the total time of the
corridor-processing algorithm. Suppose  has been processed by
the corridor-processing algorithm in
the direction from  to . Then, the running time of the
algorithm on  is  time. Similarly,
the sum of  over all corridors is .
After the processing of , the number of beams of  that
have been terminated in  is at least . Since the the number of beams on the
diagonals of  that are terminated inside corridors is , the sum of the term
 over all corridors that have been processed is . The
sum of the additional term  over all corridors is clearly .
Therefore, although a corridor may be processed twice, the total time
of the corridor-processing algorithm in the entire algorithm is
.

The lemma thus follows.\qed
\end{proof}


The above computes the v-v-map on . Again, the above algorithm only labels diagonals.
Using the similar approaches as discussed in Section \ref{sec:labelcell},
we can also label cells and maintain path information within the same running time asymptotically. We omit the details.

The other three maps can be computed similarly. For computing the
h-v-map on , one difference is on the initial steps, as follows. Initially, we let  generate two beams that are two horizontal rays towards right and left, respectively. We set the distance value of  to , where  is the vertical diagonal through . Then, we consider  as two duplicate diagonals associated with the above two beams respectively, and insert the two duplicate diagonals into the heap . The remaining algorithm is the same as before except that we replace the distance values  and  in the algorithm description with  and , respectively. The h-h-map and v-h-map on  can be computed in symmetric ways.

We thus obtain the main result of this paper.


\begin{theorem}
Given a set of  pairwise-disjoint rectilinear polygonal obstacles with a total of  vertices in the plane, after the free space is triangulated,
we can construct a link distance map with respect to any given source point  in  time, such that
for any query point , the link distance of a min-link rectilinear \st\ path  can be computed in  time
and  can be output in additional time linear in its link distance.
\end{theorem}


\section{The Algorithms for Processing Corridors}
\label{sec:algocorridor}

In this section, we present our corridor-processing algorithm and
corridor-post-processing algorithm. In fact, as shown later, the second algorithm is
simply to run the first one twice from the two doors. Below, we discuss the
corridor-processing algorithm first.





Let  be any corridor with two doors  and  and
their beam sets  and . Let  be the number of vertices of ,
, and .
Suppose we
want to process   to compute the labels of all diagonals,
by using the beams in  and the distance
value  of . In particular,
we want to obtain the beam set  and the distance value
 for .
Our algorithm is conceptually similar to the DN algorithm if we apply
it on , but our approach is more efficient due to a better implementation by making
use of the simplicity of the corridor (one crucial property is that there will be no merge
operations on the beam sets).



Denote by  the vertical decomposition of  (e.g.,
see Fig.~\ref{fig:simDec}). Note that although  and  are
now on the boundary of , we still consider them as diagonals.
Let  denote the cell of  that contains .
Starting from , we
propagate the beams from  to all other cells one by one until
all diagonals have been labeled.





\begin{figure}[t]
\begin{minipage}[t]{\linewidth}
\begin{center}
\includegraphics[totalheight=1.2in]{simDec.eps}
\caption{\footnotesize Illustrating : the two doors are
shown with thick segments.  }
\label{fig:simDec}
\end{center}
\end{minipage}
\vspace{-0.15in}
\end{figure}

Consider any diagonal  of  such that  is not 
or . Since  is simply connected,
 divides  into two polygons, and we use  to refer
to the one that does not contain . Clearly, for any point , any path from  to  must intersect . Consider any
cell  of . The cell  may have diagonals on both its
two vertical sides. It is not difficult to see that  has one and only one diagonal 
such that  is in , and we call that diagonal the {\em
entrance diagonal} of . Other diagonals of  are called {\em
exit diagonals} of .  For example, in Fig.~\ref{fig:simDec},  is the
entrance diagonal of , and  and  are exit
diagonals. Note that every diagonal
is an entrance diagonal of one and only one cell. In particular,
we consider  as the entrance diagonal of .


A general step of our algorithm works as follows. Consider a cell 
and suppose the entrance diagonal  of  has been labeled, i.e.,
 and  are available (and the beams of  are stored
in a balanced binary search tree ).
Initially,  is the cell  and  is .
Our goal for processing  is to label
all exit diagonals in .


Denote by  and  the
left and right sides of , respectively. Without loss of generality, we assume 
is on  (e.g., see Fig.~\ref{fig:simDec}).
Thus, the beams of  are rightward.
The distance values of the exit diagonals are easy to compute. If 
is empty, then we need to generate a single beam from the entire  and
every exit diagonal of  obtains the distance value ; otherwise,
every exit diagonal of  obtains the distance value .
Below, we focus on computing the beam sets of the exit
diagonals.

Suppose  has another diagonal . Then, regardless of
whether  is empty, we set  (and ), which
can be done in only constant time.

Now consider any diagonal  on .  First, we want to compute , i.e., the portions of the beams of  that can illuminate , and set . If , then since we generate a single beam from
,  has at most one beam
and can be computed in constant time.

In the sequel we consider the case where
. Our main effort is on handling this case.
Recall that the beams of  are stored in a
balanced binary search tree . We add two special pointers to
 that point to
the lowest beam and the highest beam of  respectively so that we
can access these beams in constant time. Note that with these special
pointers, we can still perform the previous operations on
 each in logarithmic time.

Depending on whether  has one or two diagonals, there are two
cases.

If  has only one diagonal , let  be the obstacle edge on  such that 
is the vertical extension of  (e.g., see Fig.~\ref{fig:case10}). Clearly,  is the union of  and .
Without loss of generality, assume  is lower than .

Suppose  is a beam in  and  is the rightward
projection of  on . For any line segment  on ,
we say that  {\em intersects}  if 
intersects  properly, and  {\em fully intersects}  if  is
contained in .



Below we let  denote the lowest beam of
, which can be obtained in constant time by using the special
pointers on .
We first check whether  intersects .
Depending on how  intersects , there are three cases. The correctness of our setting in all these cases is based on that  consists of  and  from top to bottom (e.g., see Fig.~\ref{fig:case10}).

\begin{enumerate}
\item
If  does not intersect , then every beam of  fully
intersects . Thus we have  and . This can be done in constant time.

\item
If  intersects  but does not fully intersects , then we
set  and , but we also change 's length to that of its
portion intersecting .
This can be done in constant time.

\item
If  fully intersects  (so  ``terminates'' at ), then depending on whether  has only one beam, there are further two subcases.

If  has only one beam, which is , then we simply set  and  since  terminates at .

Otherwise, we have . In this subcase, as before we use a split
operation on  to obtain  and  in  time.
Note that since  terminates at ,  is not in , and thus
. This will be useful to our time analysis on the split operations.
\end{enumerate}


\begin{figure}[t]
\begin{minipage}[t]{0.49\linewidth}
\begin{center}
\includegraphics[totalheight=1.2in]{case10.eps}
\caption{\footnotesize The right side  of  consists of  and  from top to bottom.}
\label{fig:case10}
\end{center}
\end{minipage}
\hspace*{0.02in}
\begin{minipage}[t]{0.49\linewidth}
\begin{center}
\includegraphics[totalheight=1.2in]{case20.eps}
\caption{\footnotesize The right side  of  consists of , , and  from top to bottom.  }
\label{fig:case20}
\end{center}
\end{minipage}
\vspace{-0.15in}
\end{figure}

If  has another diagonal ,
without loss of generality, we assume  is the lower one.
Let  be the obstacle edge on . Then   consists of ,
, and  from top to bottom (e.g., see Fig.~\ref{fig:case20}).

Again, let  denote the lowest beam of . Depending on how 
intersects , there are three cases. In every case below, we will also obtain a tree 
of beams that will be used later to compute the beams of .

\begin{enumerate}
\item
If  does not intersect , then we have  and
. We set .

\item
If  intersects  but does not fully intersects , then  consists of a
single beam that is the portion of  intersecting .
It is straightforward to construct .
We set  but also change the length of  to that of the portion of 
not intersecting . All above can be done in constant time.

\item
If  fully intersects , then we further check whether the
{\em highest} beam  of  intersects .

If  fully intersects , then we have  and
. Also, .

If  intersects  but does not fully intersect , then we
set  and  but also change 's length to
that of its portion intersecting . Also, we let   only
include the portion of  not intersecting . All this can be done in constant time.

If  does not intersect ,
then as before we use a split operation that split
 into two trees: , which consists of the beams of
, and ,
which consists of the rest of the beams of . This can be done in  time.
Let  be the set of beams in .
Note that since  fully intersects , 
is not in , and since  does not intersect ,  is
not in . Hence, we have  and , which will be useful to our time analysis on the split operations. Further, since  fully intersects  but  does not intersect , we have  in this case, implying that .
\end{enumerate}

Next, we compute  and  from the beams in the tree , in
the same way as the previous case where  only contains one
diagonal. Namely, we first check how the lowest beam of 
intersects  and then proceed accordingly for the three cases.


The above labels all exit diagonals of the cell . Based on our above algorithm, an easy observation is that if , then  for each exit diagonal  of .

Next, from each exit diagonal of ,
we proceed with the same procedure. The algorithm is done once
all diagonals have been labeled. The following lemma analyzes the running time of the algorithm.

\begin{lemma}
Our corridor-processing algorithm on  runs in  time.
\end{lemma}
\begin{proof}
We make a few
observations on our algorithm. First,
for any diagonal , if computing  does not need a split
operation, then it takes only constant time to do so.
Second, for any diagonal  of , 
always hold, and if , then the beams of  are from
. Third, for any diagonal , if  is obtained by a split
operation on a beam set , then  and .

The first two observations imply that if there are  split
operations in the entire algorithm, then the total running
time is . We claim that .

Indeed, by the second and the third observation, if a split operation is performed on  for some diagonal , then all beams of  must be originally from , and further, the split operation splits  into two sets such that the number of beams in each set is at most . Therefore, it can be verified that if , then , and otherwise, . In either case, .

We conclude that the algorithm runs in  time.\qed
\end{proof}

Next, we present our corridor-post-processing algorithm. Again,
consider the corridor  as above, but now  and
 are also given as input and the beams of  are towards
the inside of .
Our goal is to compute the distance values for
all diagonals of  by using the beams of  and .
An easy solution is to use our above corridor-processing algorithm to process
 twice, once only using  and  and once only using
 and . Then, each diagonal  has
been labeled twice, and we finally set  to the smaller distance value
labeled above. Clearly, the total running time is bounded by
.

\section{Conclusions}
\label{sec:conclude}

We presented a new algorithm for computing minimum
link paths in rectilinear polygonal domains. The algorithm
matches the  time lower bound \cite{ref:MaheshwariLi00}
if the triangulation of the free space can be done optimally in  time.
Our algorithm can also build the minimum-link distance map for a fixed source point to answer minimum link
path queries.


It would be interesting to see if our approach can be extended to work in a -oriented world \cite{ref:AdegeestMi94,ref:HershbergerCo94,ref:MitchellMi14}; one main stumbling block is that the DN algorithm does not generalize to  orientations. Another intriguing open problem is whether a result similar to ours, could be possible for paths and domains with unrestricted orientations \cite{ref:MitchellMi92}, e.g., whether there exists an -time algorithm for the problem where  is subquadratic (the 3SUM-hardness reduction \cite{ref:MitchellMi14} for the problem shows that  essentially cannot be subquadratic).












\bibliographystyle{plain}
\bibliography{reference}











\end{document}
