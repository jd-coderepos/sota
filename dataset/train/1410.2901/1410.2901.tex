\documentclass[a4paper,11pt]{llncs}
\pdfoutput=1
\usepackage{times}
\usepackage{alltt}

\usepackage{latexsym}
\usepackage[all]{xy}
\usepackage{graphicx}

\usepackage{ntheorem}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{stmaryrd}
\usepackage{moreverb,epsfig,url}
\usepackage[curve]{xypic}
\usepackage{tikz}
\usetikzlibrary{trees}
\usetikzlibrary{arrows}
\usepackage{listings}
\lstset{language=[objective]caml}




\setlength{\oddsidemargin}{15mm}
\setlength{\evensidemargin}{15mm}
\setlength{\textwidth}{130mm}
\setlength{\textheight}{210mm}
\setlength{\topmargin}{10mm}

\definecolor{myviolet}{rgb}{.82, .0 ,.76}
\definecolor{myorange}{rgb}{1., .25 ,.0}
\definecolor{myblue}{rgb}{.01, .72 ,.625}
\definecolor{mygrey}{rgb}{.6, .6 ,.6}
\definecolor{myyellow}{rgb}{.75, .8 ,.0}
\definecolor{mygreen}{rgb}{.2, .8 ,.0}
\definecolor{mybrown}{rgb}{.68,.3,.1}
\definecolor{OliveGreen}{rgb}{.0, 0.36, 0.16}
\definecolor{mypink}{rgb}{.9, .0 ,.4}
\renewcommand{\equiv}{=}

\newcommand{\ded}{\vdash}
\newcommand{\spf}{\:\Longrightarrow\:}
\newcommand{\fps}{\:\Longleftarrow\:}
\newcommand{\imp}{\Rightarrow}
\newcommand{\dbf}{\:\Longleftrightarrow\:}

\newcommand{\DELTA}{\Lambda}
\newcommand{\orient}[1]{\overleftrightarrow{#1}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\B}{\mathcal{B}}
\newcommand{\Q}{\mathcal{Q}}
\def \R {\mathcal{R}}
\def \card {{\rm \mathcal{C}ard}}
\def \Pow {\mathcal{P}}
\newcommand{\bottom}{\perp}
\newcommand{\match}{\unlhd}

\renewcommand{\varepsilon}{\epsilon}
\newcommand{\epsifree}{\smash{\not}\varepsilon}
\newcommand{\Lang}{\mathcal{L}}
\newcommand{\Lange}{\mathcal{L}^{\epsifree}}
\renewcommand{\S}{\mathcal{S}}
\newcommand{\desc}{\R^*}
\newcommand{\edesc}{\R_E^*}
\newcommand{\irr}{IRR}
\newcommand{\nf}{\R^!}

\newcommand{\pack}{{\cal P}_{\F,\Q}}
\newcommand{\lp}{\langle}
\newcommand{\rp}{\rangle}

\newcommand{\timbuk}{{\sf Timbuk}}
\newcommand{\coq}{{\sf Coq}}
\newcommand{\autowrite}{Autowrite}
\newcommand{\addtrans}{{\sf addtrans}}
\newcommand{\modify}{{\sf modify}}
\newcommand{\modifySLT}{{\sf modifySLT}}


\newcommand{\F}{{\cal F}}
\newcommand{\myF}{{\cal K}}
\newcommand{\X}{{\cal X}}
\newcommand{\Y}{{\cal Y}}
\newcommand{\C}{{\cal C}}
\newcommand{\D}{{\cal D}}
\newcommand{\T}{{\cal T}}
\newcommand{\TF}{{\cal T(F)}}
\newcommand{\TFP}{{\cal T(F')}}
\newcommand{\TFX}{{\cal T(F, X)}}
\newcommand{\TFQ}{{\cal T(F \cup Q)}}
\newcommand{\TFq}{{\cal T(F_Q)}}
\newcommand{\TFfq}{{\cal T(F\cup F_Q)}}
\newcommand{\TFQX}{{\cal T(F \cup Q,X)}}
\newcommand{\TFQp}{{\cal T(F \cup Q')}}
\newcommand{\TC}{{\cal T(C)}}
\newcommand{\et}{\mbox{ and }}
\newcommand{\sth}{\mbox{ s.t. }}
\newcommand{\oute}{\mbox{ or }}
\newcommand{\ou}{\; \vee \;}

\def\langtermesclos#1{\T(#1)}
\def\langtermesaux(#1,#2){\T(#1, #2)}
\def\sorts{\mathcal S}
\def\myTF{\langtermesclos\myF}
\def\myTFX{\langtermesaux(\myF,\X)}
\def\myTFs{\myTF^\sorts}
\def\ETF{E^{r}}
\def\Ec{E^c}
\def\Ed{E^{\#}}
\def\Ecp{E^c_{{\mathcal F}}}
\def\Ecpy{E^c_{\myF}}
\def\Ecps{E^c_{{\myF,\sorts}}}
\def\Ecf{E^c_{\F}}
\def\Ecc{E^c_{\C}}
\def\Eccs{E^c_{\C,\sorts}}
\def\TFS{\TF^\sorts}
\def\TCS{\TC^\sorts}
\def\TFXS{\TFX^\sorts}

\newcommand{\rep}[2]{\llbracket #1 \rrbracket_{#2}}
\DeclareMathOperator{\lirr}{I\textsc{rr}}
\newcommand{\airr}[1]{\A_{\lirr(#1)}}

\def\ERcp{\overrightarrow{\Ecp}}
\def\ERcpy{\overrightarrow{\Ecpy}}
\def\ERcps{\overrightarrow{\Ecps}}
\def\ERcf{\overrightarrow{\Ecf}}
\def\ERcc{\overrightarrow{\Ecc}}
\def\ERccs{\overrightarrow{\Eccs}}

\newcommand{\rw}{\rightarrow}
\newcommand{\lw}{\leftarrow}
\newcommand{\simp}{\leadsto}
\newcommand{\Norm}{Norm}
\newcommand{\norm}{Norm}
\newcommand{\nr}{E}
\newcommand{\comp}{{\cal C}}
\def\simpleq#1#2{\mathcal S_{#1}\left(#2\right)}
\newcommand{\aapprox}{{\cal A}_{\R, \nr}}
\newcommand{\bapprox}{{\cal B}_{\R, \nr}}
\newcommand{\aapproxEb}{{\cal A}_{\R, E_\B}}
\newcommand{\aapproxEx}{{\cal A}_{\R, \emptyset}}
\newcommand{\aapproxG}{{\cal A}_{\R\cup\R^G, \nr}}
\newcommand{\aapproxGB}{{\cal A}_{\R\cup\R^G, E_\B \cup \Ed}}
\newcommand{\aapproxGEx}{({\cal A}^G)_{\R\cup\R^G, \emptyset}}
\newcommand{\aapproxETF}{{\cal A}_{\R, E\cup\ETF}}
\newcommand{\aaex}{{\cal A}_{\R}}
\newcommand{\bbex}{{\cal B}_{\R}}
\newcommand{\bpprox}{{\cal B}_{\R, \nr}}
\newcommand{\xor}{\otimes}
\newcommand{\class}[1]{\textbf{\textsf{#1}}}
\def\build#1_#2^#3{\mathrel{
    \mathop{\kern 0pt#1}\limits_{#2}^{#3}}}

\def\CM#1{\build\hbox to 10mm {\rightarrowfill}_{}^{CM#1}}

\newcommand{\rws}[3]{\mathrel{{\build{\rightarrow}_{#1}^{#2}}\mskip-2mu_{#3}}}

\newcommand{\relseq}{\rws{}{}{\R_1;\ldots;\R_n}}
\newcommand{\relseqb}{\rws{}{}{\R_1;\R_2}}
\newcommand{\normra}{\rw^!_{\R_1}}
\newcommand{\normrb}{\rw^!_{\R_2}}
\newcommand{\normrc}{\rw^!_{\R_3}}
\newcommand{\normrnun}{\rw^!_{\R_{n-1}}}
\newcommand{\normrn}{\rw^!_{\R_n}}



\newcommand{\joinable}[2]{\mathrel{{\build{\leftrightarrow}_{#1}^{#2}}}}


\newcommand{\asim}{\lhd^{\epsifree}}\newcommand{\fasim}{\lhd}



\newcommand{\rwAne}{\rightarrow^{\not\epsilon}_{\A}}
\newcommand{\rwBne}{\rightarrow^{\not\epsilon}_{\B}}
\newcommand{\rwBnestar}{\rightarrow^{\not\epsilon\: *}_{\B}}
\newcommand{\rwne}{\rightarrow^{\not\epsilon\: *}_{\simpleq E \A}}
\newcommand{\rwAi}{\rightarrow_{\A^i}}
\newcommand{\rwDne}{\rightarrow^{\not\epsilon}_{\Delta}}
\newcommand{\rwD}{\rightarrow_{\Delta}}
\newcommand{\rwAnestar}{\rightarrow^{\not\epsilon\: *}_{\A}}
\newcommand{\rwAznestar}{\rightarrow^{\not\epsilon\: *}_{\A_0}}
\newcommand{\rwAanestar}{\rightarrow^{\not\epsilon\: *}_{\A_1}}
\newcommand{\rwAbnestar}{\rightarrow^{\not\epsilon\: *}_{\A_2}}
\newcommand{\rwDnestar}{\rightarrow^{\not\epsilon\: *}_{\Delta}}
\newcommand{\rwDanestar}{\rightarrow^{\not\epsilon\: *}_{\Delta'_\A}}
\newcommand{\rwnestar}{\rightarrow^{\not\epsilon\: *}}
\newcommand{\rwepsi}{\stackrel{\epsilon}{\rightarrow}}
\newcommand{\rwAp}{\rightarrow_{\A'}}
\newcommand{\rwApne}{\rightarrow^{\not\epsilon}_{\A'}}
\newcommand{\rwApnestar}{\rightarrow^{\not\epsilon\: *}_{\A'}}

\newcommand{\rwApp}{\rightarrow_{\aapprox^p}}
\newcommand{\rwAppnestar}{\rightarrow^{\not\epsilon\: *}_{\aapprox^p}}
\newcommand{\rwRE}{\rightarrow_{\R/E}}
\newcommand{\rwAa}{\rightarrow_{\aapprox^*}}
\newcommand{\rwB}{\rightarrow_{\B}}
\newcommand{\rwBp}{\rightarrow_{\B'}}
\newcommand{\rwG}{\mathrel{{\build{\rightarrow}_{G}^{}}}}

\newcommand{\rwl}[3]{\mathrel{{\build{\longrightarrow}_{#1}^{#2}}\mskip-2mu_{#3}}}
\newcommand{\myrightarrow}[1]{\rwl{}{#1}{}}

\newcommand{\arity}{{\mathcal Ar}}
\newcommand{\dom}{{\mathcal Dom}}
\newcommand{\pos}{{\mathcal Pos}}
\newcommand{\posleq}{\preceq}
\newcommand{\posl}{\prec}
\newcommand{\posf}{\pos_{\F}} 
\newcommand{\posx}{\pos_{\X}} 
\newcommand{\var}{{\mathcal Var}}
\newcommand{\ran}{{\mathcal Ran}}
\newcommand{\Root}{{\mathcal Root}}
\newcommand{\Card}{{\mathcal Card}}
\newcommand{\rwR}{\rws{}{}{\R}}
\newcommand{\rwA}{\rws{}{}{\A}}
\newfont{\amstoto}{msbm10}
\newcommand{\NN}{\mbox{\amstoto\char'116}}
\newcommand{\sep}{\; | \;}
\newcommand{\dsep}{\; || \;}

\newcommand{\true}{\mbox{\it true}}
\newcommand{\false}{\mbox{\it false}}
\newcommand{\aut}{\langle \F, \Q, \Q_f, \Delta \rangle} 







\newenvironment{procedure}[1]{\noindent {\bf Procedure~#1}}{}


\newcommand{\Decompose}{{\bf Decompose}}
\newcommand{\Clash}{{\bf Clash}}
\newcommand{\Configuration}{{\bf Configuration}}
\newcommand{\Distributivity}{{\bf Distributivity}}
\newcommand{\Simplifyone}{{\bf Simplify~1}}
\newcommand{\Simplifytwo}{{\bf Simplify~2}}
\newcommand{\cale}[1]{\vrule height #1 depth 5pt width 0pt}
\newcommand{\deduc}[2]{}

\newcommand{\Sub}{{\cal S}ub}

\lstdefinelanguage{yswhile}{morekeywords={if,else,while,then,endif,do,done, true, false, skip, Sequence, var, input, output},sensitive=true,morecomment=[n]{//}{},morestring=[d]"}[keywords,comments,strings]

\lstset{language=yswhile, basicstyle=\ttfamily, mathescape=true,numbers=left,
numberstyle=\tiny,
stepnumber=1,
numbersep=5pt}

\def\timFont{\bf}
\newcommand{\Ops}{{\timFont Ops}}
\newcommand{\Vars}{{\timFont Vars}}
\newcommand{\TRS}{{\timFont TRS}}
\newcommand{\Automaton}{{\timFont Automaton}}
\newcommand{\Set}{{\timFont Set}}
\newcommand{\States}{{\timFont States}}
\newcommand{\FinalStates}{{\timFont Final States}}
\newcommand{\Transitions}{{\timFont Transitions}}
\newcommand{\Equations}{{\timFont Equations}}
\newcommand{\Rules}{{\timFont Rules}}

\def\arobase{\symbol{64}}


\theoremstyle{plain}

\newtheorem*{lemma*}{Lemma}
\newtheorem*{theorem*}{Theorem}
 


\author{Thomas Genet}
\title{Towards Static Analysis of Functional Programs
\\ using Tree Automata Completion\thanks{This paper has been published in the
  Workshop on Rewriting Logic and Applications\cite{Genet-WRLA14}.}}

\institute{INRIA/IRISA, Universit\'e de Rennes, France\\
{\tt genet@irisa.fr}}

\begin{document}

\maketitle

\begin{abstract}
This paper presents the first step of a wider research effort to 
apply tree automata completion to the static analysis of functional programs. 
Tree Automata Completion is a family of techniques for computing or
approximating the set of terms reachable by a rewriting relation. 
The completion algorithm we focus on is parameterized by a set  of equations
controlling the precision of the approximation and influencing its termination.
For completion to be used as a static analysis, the first step is to guarantee
its termination. In this work, we thus give a sufficient condition on  and
 for completion algorithm to always terminate. 
In the particular setting of functional programs, this condition can be 
relaxed into a condition on  and  (terms built on the set of
constructors) that is closer to what is done in the field of static analysis,
where abstractions are performed on data.
\end{abstract}


\section{Introduction}
Computing or approximating the set of terms reachable by rewriting
has more and more applications. For a Term Rewriting System (TRS)  and a
set of terms , the set of reachable terms is . This set can be computed exactly for
specific classes of ~\cite{Genet-Habil} but, in general, it has to be
approximated. Applications of the approximation of  are ranging from
cryptographic protocol verification~\cite{avispa}, to static
analysis of various programming languages~\cite{BoichutGJL-RTA07}
or to TRS termination proofs~\cite{GeserHWZ-RTA05}. Most of
the techniques compute such approximations using tree automata as the core
formalism to represent or approximate the (possibly) infinite set of terms
. Most of them also rely on a Knuth-Bendix completion-like algorithm
completing a tree automaton  recognizing  into an automaton 
recognizing exactly, or over-approximating, the set . As a result,
these techniques can be refered as {\em tree automata completion}
techniques~\cite{Genet-RTA98,Takai-RTA04,FeuilladeGVTT-JAR04,BoichutCHK-IJFCS09,GenetR-JSC10,Lisitsa-RTA12}.
A strength of this algorithm, and at the same time a weakness, is that its
precision is parameterized by a function~\cite{FeuilladeGVTT-JAR04} or a set of
equations~\cite{GenetR-JSC10}. It is a strength because tuning the approximation
function (or equations) permits to adapt the precision of completion to a
specific goal to tackle. This is what made it successful for program and
protocol verification. On the other hand, this is a weakness because it is
difficult to guarantee its termination.

\noindent
In this paper, we define a simple
sufficient condition on the set of equations for the 
tree automata completion algorithm to terminate. This condition, which is strong
in general, reveals to be natural and well adapted for the approximation of
reachable terms when TRSs encode typed functional programs. We thus obtain a way to automatically
over-approximate the set of all reachable program states of a functional 
program, or even restrict it to the set of all results. Thus we can
over-approximate the image of a functional program.

\section{Related work}


{\em Tree automata completion}. 
With regards to most papers about
completion~\cite{Genet-RTA98,Takai-RTA04,FeuilladeGVTT-JAR04,BoichutCHK-IJFCS09,GenetR-JSC10,Lisitsa-RTA12},
our contribution is to give the first criterion {\em on the approximation} for the
completion to terminate. Note that it is possible to guarantee termination of
the completion by inferring an approximation adapted to the TRS under
concern, like in~\cite{OehlCKS-FASE03}. In this case, given a TRS, the approximation is
fixed and unique. Our solution is more flexible because it lets the user change
the precision of the approximation while keeping the termination
guarantee. In~\cite{Takai-RTA04}, T.~Takai have a completion parameterized by a
set of equations. He also gives a termination proof for its completion but only
for some restricted classes of TRSs. Here our termination proof holds for any 
left-linear TRS provided that the set of equations satisfy some properties.

\medskip
\noindent {\em Static analysis of functional programs}.  With regards to static
analysis of functional programs using grammars or automata, our contribution is
in the scope of data-flow analysis techniques, rather than control-flow
analysis. More precisely, we are interested here in predicting the results of a
function~\cite{OngR-POPL11}, rather than predicting the control
flow~\cite{Kobayashi-JACM13}. Those two papers, as well 
as many other ones, deal with higher order functions using complex higher-order
grammar formalisms (PMRS 
and HORS). Higher-order functions are not in the scope of the solution we
propose here. However, we obtained some preliminary results suggesting that an
extension to higher order functions is possible and gives relevant results (see
Section~\ref{sec:further}). Furthermore, using equations, approximations are
defined in a more declarative and flexible way than in~\cite{OngR-POPL11}, where
they are defined by a dedicated algorithm. Besides, the verification mechanisms
of~\cite{OngR-POPL11} use automatic abstraction refinement. This can be also
performed in the completion setting~\cite{BoichutBGL-ICFEM12} and adapted to
the analysis of functional programs~\cite{GenetS-rep13}. Finally, using a simpler
(first order) formalism, {\em i.e.} tree automata, makes it easier to take into
account some other aspects like: evaluation strategies and built-ins types (see
Section~\ref{sec:further}) that are not considered by those papers.

\section{Background}
\label{sec:bg}

In this section, we introduce some definitions and concepts that will
be used throughout the rest of the paper (see
also~\cite{BaaderN-book98,TATA}). Let  be a
finite set of symbols, each associated with an arity function, and let
 be a countable set of {\em variables}.  denotes the set of
{\em terms} and  denotes the set of {\em ground terms} (terms
without variables). The set of variables of a term  is denoted by
. A {\em substitution} is a function  from  into
, which can be uniquely extended to an endomorphism of . A
{\em position}  for a term  is a finite word over . The empty
sequence  denotes the top-most position. The set  of
positions of a term  is inductively defined by  if  or  is a constant and  otherwise.  If
, then  denotes the subterm of  at position
 and  denotes the term obtained by replacement of the
subterm  at position  by the term .


A {\em term rewriting system} (TRS)  is a set of {\em rewrite
  rules} , where , , and
.  A rewrite rule  is {\em
  left-linear} if each variable of  occurs only once in .  A TRS  is left-linear if
every rewrite rule  of  is left-linear.  The TRS
 induces a rewriting relation  on terms as follows. Let
 and ,  denotes that there
exists a position  and a substitution  such that
 and .
Given a TRS ,  can be split into two disjoint sets  and . All symbols
occurring at the root position of left-hand sides of rules of  are in
.  is the set of defined symbols of ,  is the set of
constructors. Terms in  are called {\em data-terms}.  
The reflexive transitive closure of  is denoted by
 and  denotes that  and  is
irreducible by . The set of irreducible terms w.r.t. a TRS  is denoted
by .
The set of -descendants of a set of ground
terms  is .  
A TRS  is sufficiently complete if for all
,
. 

An {\em equation set}  is a set of {\em
  equations} , where .  
The relation  is the smallest congruence such that for all
substitution  we have . Given a TRS 
and a set of equations , a term  is rewritten modulo 
into , denoted , if there exist  and
 such that . The reflexive transitive closure
 of  is defined as usual except that reflexivity is extended to
terms equal modulo , {\em i.e.} for all  if  then .
The set of
-descendants modulo  of a set of ground terms  is 

Let  be a countably infinite set of symbols with arity , called {\em states}, such
that .   is called the set of {\em
  configurations}. A {\em transition} is a rewrite rule , where  is
a configuration and  is state.  A transition is {\em normalized} when ,  is of arity , and . An {\em -transition} is a transition of the form 
where  and  are states. 
A bottom-up non-deterministic finite tree automaton ({\em tree automaton} for short)
over the alphabet  is a tuple ,
where  is a finite subset of ,  is a finite set of normalized transitions and
-transitions. The transitive and reflexive {\em rewriting relation}
on  induced by the set of transitions  (resp. all transitions
except -transitions) is denoted by 
(resp. ). When  is attached to a tree automaton  we also
note those two relations  and , respectively. A tree
automaton  is complete if for all  there exists a state  of 
such that . The language (resp. -language) recognized by
 in a state  is 
(resp. ). A state
 of an automaton  is {\em reachable} (resp. -reachable) if
 (resp. ). 
We define .  
A set of transitions  is
-deterministic if there are no two normalized transitions in 
with the same left-hand side.  A tree automaton  is
-deterministic if its set of transitions is -deterministic.
Note that if  is -deterministic then for all states  of
 such that , we have .


  
\section{Tree Automata Completion Algorithm}
\label{chap:theo}

Tree Automata Completion algorithms were proposed
in~\cite{Jacquemard-RTA96,Genet-RTA98,Takai-RTA04,GenetR-JSC10}. They
are very similar to a Knuth-Bendix completion except that they run on two distinct
sets of rules: a TRS  and a set of transitions  of a tree automaton
. 




\newcommand{\oldcomp}{{\cal C}_{\R,\alpha}}
\renewcommand{\nr}{\alpha}
\renewcommand{\comp}{{\cal C}_{\R,\alpha}}
\renewcommand{\desc}[1]{#1^{*}}


Starting from a tree automaton  and a left-linear
TRS , the algorithm computes a tree automaton 
such that  or . 
The algorithm iteratively computes tree automata ,
, \ldots such that  until we get an automaton  with 
and . For all , if  and , then . Thus, if
 is a fixpoint then it also verifies .
To construct  from , we achieve a {\em completion step}
which consists in finding {\em critical pairs} between  and
. A critical pair is a triple  where ,  and  such that  and .  For  to be recognized by the same state and
thus model the rewriting of  into , it is enough to add the
necessary transitions to  to obtain  such that . In~\cite{Takai-RTA04,GenetR-JSC10}, critical pairs are
joined in the following way: 


\noindent
From an algorithmic point of view, there remains two problems to solve: find
all the critical pairs  and find the transitions
to add to  to have . The first
problem, called matching, can be efficiently solved using a specific
algorithm~\cite{FeuilladeGVTT-JAR04,Genet-Habil}. The second problem is solved
using Normalization.


\label{sec-tac}
\renewcommand{\oldcomp}{{\cal C}_{\R,\alpha}}
\renewcommand{\nr}{\alpha}
\renewcommand{\comp}{{\cal C}_{\R,\alpha}}
\renewcommand{\desc}[1]{#1^{*}}
\renewcommand{\desc}{\R^*}
\renewcommand{\nr}{E}
\renewcommand{\comp}{{\cal C}}


\subsection{Normalization}
\label{sec-norm}
The normalization function replaces subterms either by states of 
(using transitions of ) or by new states. A state  of  is used to
normalize a term  if . Normalizing by reusing states of
 and transitions of  permits to preserve the -determinism of
. Indeed,  can be kept deterministic during completion though
 cannot.

\begin{definition}[New state]
  Given a set of transitions , a new state (for ) is a state 
of  not occurring in left or right-hand sides of rules of
  ~\footnote{Since  is a countably infinite set of 
states,  and  are finite, a new state can always be found.}.
\end{definition}

\noindent
We here define normalization as a bottom-up process. This definition is simpler and
equivalent to top-down definitions~\cite{GenetR-JSC10}. In the recursive call,
the choice of the context  may be non deterministic but all the
possible results are the equivalent modulo state renaming. 

\begin{definition}[Normalization]
\label{def:normalization}
Let  be a set of transitions defined on a set of states , . Let  be a non empty context of
,  of arity 
, and . The normalization function is inductively
defined by:
\begin{enumerate}
\item 

\item  
\begin{tabular}[t]{l}
     \\
    
\end{tabular} 

where either () or ( is a new state for
 and
).
\end{enumerate} 
\end{definition}

\noindent
In the second case of the definition, if there are several states  such that , we arbitrarily choose one of them. We illustrate the above definition on the
normalization of a simple transition.
\begin{example}
Given , 

\end{example}



\subsection{One step of completion}
\label{sec:eqcompletionalgo}

A step of completion only consists in joining critical pairs. We first need to
formally define the substitutions under concern: {\em state substitutions}.


\begin{definition}[State substitutions, ]
\label{def:qsubst}
A {\em state substitution} over an automaton
 with a
set of states  is a function . We can extend this definition to a morphism
.
We denote by  the set of state substitutions built over  and .
\end{definition}












\begin{definition}[Set of critical pairs]
Let a TRS  and a tree automaton . The set of critical
pairs between  and  is . 
\end{definition}

\noindent
Recall that the completion process builds a sequence
 of automata such that if 
and  then . One step of completion,
{\em i.e.} the process computing  from , is defined as follows.
Again, the following definition is a simplification of the definition of~\cite{GenetR-JSC10}.


\begin{definition}[One step of completion]
\label{def:completion-one-step}
  Let  be a tree automaton, 
   be a left-linear TRS. 
The one step completed automaton is   where  is inductively defined by:
\begin{itemize}
\item 
\item  where 




 if there exists  s.t. , and
otherwise

 where  is a new state for
  
  
  
\end{itemize}
\end{definition}

\begin{example}
Let  be a tree automaton with . If  then  with , because  and . We have  and there exists no
  state  such that . Hence,
  . Since
  , we
  get that .
\end{example}


\subsection{Simplification of  Tree Automata by Equations}
\label{sec:simplif}
In this section, we define the {\em simplification} of tree automata 
w.r.t. a set of equations . This operation permits to
over-approximate languages that cannot be recognized {\em exactly} using tree
automata completion, {\em e.g.} non regular languages. The simplification operation
consists in finding -equivalent terms recognized in  by different states
and then by merging those states together. The merging of states is performed
using renaming of a state in a tree automaton.


\label{sec:merging}
\begin{definition}[Renaming of a state in a tree automaton]
  Let  be set of states,  be a
  tree automaton, and  a function . We denote by
   the tree automaton where every occurrence of  is
  replaced by  in ,  and in every left and right-hand
  side of every transition of . 
\end{definition}
If there exists a bijection  such that  then  and
 are said to be {\em equivalent modulo renaming}. 
Now we define the {\em simplification relation} which merges states in a tree
automaton according to an equation. Note that it is not required for equations
of  to be linear.

\begin{definition}[Simplification relation]
\label{def:simprel}
  Let  be a tree automaton and  be
  a set of equations. For , ,  such that , , 
 and  then  can be {\em simplified} into , denoted by
.
\end{definition}

\begin{example}
  Let  and  be the tree automaton with set of
  transitions . We can perform a simplification step using the equation
   because we found a substitution  such that:  and 
  Hence, \footnote{or ,
any of  or  can be used for renaming.}
\end{example}


\noindent
As stated in~\cite{GenetR-JSC10}, simplification
 is a terminating relation (each step suppresses a state) and it
enlarges the language recognized by a tree automaton, {\em i.e.} if 
then . Furthermore, no matter how
simplification steps are performed, the obtained automata are equivalent modulo
state renaming. In the following,  denotes that  and  is irreducible by . We denote by  any automaton  such that . 




\begin{theorem}[Simplified Tree Automata~\cite{GenetR-JSC10}]
  \label{theorem:canonical}
  Let  be tree automata and  be a set of 
  equations. If  and  then
 and  are equivalent modulo state renaming.
\end{theorem}




\subsection{The full Completion Algorithm}
\label{sec:completion}

\begin{definition}[Automaton completion]
\label{def:completion}
Let  be a tree automaton,  a left-linear TRS and  a set of equations. 
\begin{itemize}
\item 
\item , for 
\end{itemize}
If there exists  such that , then we
denote  by .
\end{definition}
In practice, checking if  is sufficient to know
that  is a fixpoint. However, a fixpoint cannot always be finitely
reached\footnote{See~\cite{Genet-Habil}, for classes of  for which a
  fixpoint always exists.}. To ensure termination, one can provide a set of
approximating equations to overcome infinite rewriting and 
completion divergence. 

\begin{example}
  Let ,  and  be
  the tree automaton with set of transitions , {\em i.e.} . The completion ends
  after two completion steps on  which is a fixpoint. Completion
  steps are summed up in the following table. To simplify the presentation, we do
  not repeat the common transitions:  and  columns
  are supposed to contain all transitions of .
The automaton  is exactly  since
simplification by equations do not apply. Simplification has been applied on
 to obtain .

\noindent
{\small
\begin{center}
\begin{tabular}{||r||r|r||r|r||}
\hline 
 &  &  &  & \\
\hline
 &  &  &  & \\
 &  &  &  &  \\ 
 &  &  &  &  \\
            &  &  &  & \\
\hline
\end{tabular}
\end{center}}
\end{example}

\noindent
Now, we recall the lower and upper bound theorems.  Tree automata completion of
automaton  with TRS  and set of equations  is lower bounded by
 and upper bounded by . The lower bound theorem 
ensures that the completed automaton  recognizes all -reachable
terms (but not all -reachable terms). The upper bound theorem guarantees
that all terms recognized by  are only -reachable terms. 

\begin{theorem}[Lower bound~\cite{GenetR-JSC10}]
  \label{completeness}
  Let  be a left-linear TRS,  be a tree automaton and  be a set of
  equations. If completion terminates on  then
.
\end{theorem}


\noindent
The upper bound theorem states the precision result of
completion. It is defined using the -coherence property.
The intuition behind -coherence is the following: in the tree automaton
-transitions represent rewriting steps and normalized transitions
recognize -equivalence classes. More precisely, in a -coherent tree
automaton, if two terms  are recognized into the same state   using
only normalized transitions then they belong to 
the same -equivalence class. Otherwise, if at least one
-transition is necessary to recognize, say,  into  then at
least one step of rewriting was necessary to obtain  from . 


\begin{theorem}[Upper bound~\cite{GenetR-JSC10}]
  \label{correctness}
  Let  be a left-linear TRS,  a set of equations and  a
  -coherent tree automaton. For any :
 and  is -coherent. \end{theorem}




\section{Termination criterion for a given set of equations}
\label{sec:termCrit}
\renewcommand{\desc}{\R^*}

Given a set of
equations , the effect of the simplification with  on a tree automaton is
to merge two distinct states recognizing instances of the left and right-hand
side for all the equations of . In this section, we give a sufficient
condition on  and on the completed tree automata  for the tree
automata completion to always terminate. The intuition behind this condition is
simple: if the set of equivalence classes for , {\em i.e.} ,  is finite then so should be
the set of new states used in completion. However, this is not true in general
because simplification of an automaton with  does not necessarily merge all
-equivalent terms.

\begin{example}
\label{ex:compNotEcompat}
  Let  be the tree automaton with set of transitions ,  and let . The set of transitions of  is . We have ,  and  but on the
  automaton , no simplification situation (as described by
  Definition~\ref{def:simprel}), can be found because the term  is not
  recognized by . Hence, the simplified automaton is
   where  and  are recognized by different states.
\end{example}

\noindent
There is no simple solution to have a simplification algorithm
merging all states recognizing -equivalent terms (see
Section~\ref{sec:further}). 
Having a complete automaton  solve the above problem but leads to rough
approximations (see~\cite{Genet-rep13}).
In the next section, we propose to give some simple restrictions on  to
ensure that completion terminates. In Section~\ref{sec:functional}, we will see 
how those restrictions can easily be met for ``functional'' TRS, {\em i.e.} a
typed first-order functional program translated into a TRS. 

\subsection{General criterion}
What Example~\ref{ex:compNotEcompat} shows is that, for a simplification with
 to apply, it is necessary that both sides of the equation are recognized by
the tree automaton. In the following, we will define a set  of {\em
  contracting} equations so that this property is true. What
Example~\ref{ex:compNotEcompat} does not show is that, by default, tree automata
are not -compatible. In particular, any non -deterministic automaton does not
satisfy the reflexivity of . For instance, if an automaton  has two
transitions  and , since  for all , for  to
be -compatible we should have .  To enforce
-determinism by automata simplification, we define a set of {\em reflexivity equations} as follows.

\begin{definition}[Set of reflexivity equations ]
For a given set of symbols , fn, where  are pairwise
distinct variables.
\end{definition}

\noindent
Note that for all set of equations , the relation  is trivially equivalent to
. Furthermore, simplification with  transforms 
all automaton into an -deterministic automaton, as stated in the
following lemma.

\begin{lemma}
\label{lem:etf_det}
For all tree automaton  and all set of equation , if 
and  then  is -deterministic. 
\end{lemma}

\begin{proof} Shown by induction on the height of terms
 (see~\cite{Genet-rep13} for details). 
\end{proof}
\noindent
We now define sets of contracting equations. Such sets are defined for
a set of symbols  which can be a subset of . This will be used later
to restrict contracting equations to the subset of constructor symbols of .

\begin{definition}[Sets of contracting equations for , ]
Let . A set of equations is contracting for ,
denoted by , if all equations of  are of the form  with  a linear term, , and 
if the set of normal forms of  w.r.t. the TRS  is finite.

\end{definition}

\noindent
Contracting equations, if defined on ,  define an upper bound on the number
of states of a simplified automaton.

\begin{lemma}
\label{lem:cardComp}
Let  be a tree automaton and  a set of contracting equations for
. If  then the simplified automaton 
is an -deterministic automaton having no more states than terms in
.  
\end{lemma}
\begin{proof}
  First, assume for all state  of , . Then, for all terms  such that , we know
  that  is not in normal form w.r.t. . As a result, the left-hand side
  of an equation of  can be applied to . This means that there exists an
  equation , a ground context  and a substitution  such
  that . Furthermore, since , we know
  that  and that there exists a state 
  such that  and . From , we know that all subterms of
   are recognized by at least one state in . Thus, there
  exists a state  such that . We thus
  have a situation of application of the equation  in the
  automaton. Since  is simplified, we thus know that . As
  mentioned above, we know that . Hence
  . If
   is not in normal form w.r.t.  then we can do the same reasoning
  on  until getting a term that is in
  normal form w.r.t.  and recognized by the same state . Thus, this
  contradicts the fact that  recognizes no term of .

Then, by definition of ,  is finite. Let  be the subset of  recognized by . Let  be the states recognizing 
respectively. We know that there is a finite set of states recognizing  because  and Lemma~\ref{lem:etf_det} entails that  is
-deterministic. Now, for all terms  recognized by a state  in , {\em i.e.} ,  we can use a reasoning similar to the
one carried out above and show that  is equal to one state of  recognizing normal forms of  in . Finally, there
are at most  states in . 
\end{proof}


\noindent
Now it is possible to state the Theorem guaranteeing the termination of
completion if the set of equations  contains a set of contracting equations
 for  and a set of reflexivity equations. 

\begin{theorem}
\label{th:termFinite}
Let  be a tree automaton,  a left linear TRS and  a set of
equations. If , then completion of  by  and
 terminates.\end{theorem}

\begin{proof}
For completion to diverge it must produce infinitely many new states. This is
impossible if  contains  and  (see
Lemma~\ref{lem:cardComp}). 
\end{proof}

\subsection{Criterion for Functional TRSs}
\label{sec:functional}
Now, we consider functional programs viewed as TRSs. We assume that such
TRSs are left-linear, which is a common assumption on TRSs obtained from
functional programs~\cite{BaaderN-book98}. In this section, we will restrict
ourselves to sufficiently complete TRSs obtained from functional programs and
will refer to them as {\em functional TRSs}. For TRSs representing functional programs,  
defining contracting equations of  on  rather than
on  is enough to guarantee termination of completion. This is more convenient and
also closer to what is usually done in static analysis where abstractions are
usually defined on data and not on function applications.
Since the TRSs we consider are sufficiently complete, any term of  can be
rewritten into a data-term of . As above, using equations of  we are going to
ensure that the data-terms of the computed languages will be
recognized by a bounded set of states. To lift-up this property to  it is
enough to ensure that  if  then 
and  are recognized by equivalent states. This is the role of the set of
equations .

\begin{definition}[]
Let  be a TRS, the set of -equations is .
\end{definition}





\begin{theorem}
\label{th:termComplete}
Let  be a tree automaton,  a sufficiently complete left-linear TRS and  a set of equations.
If  with  contracting then completion of  by  and 
terminates.\end{theorem}

\begin{proof}
  Firstly, to show that the number of states recognizing terms
  of  is finite we can do a proof similar to the one of
  Lemma~\ref{lem:cardComp} . Let  be the finite set of normal forms
  of  w.r.t. . Since , like in the proof
  of Lemma~\ref{lem:cardComp}, we can show that in any completed automaton,
  terms of  are recognized by no more states than terms in . Secondly,
  since  is sufficiently complete, for all terms  we
  know that there exists a term  such that . The
  fact that  guarantees that  and  will be recognized by
  equivalent states in the completed (and simplified) automaton. Since the
  number of states necessary to recognize  is finite, so is the number of
  states necessary to recognize terms of . 
\end{proof}


\noindent
Finally, to exploit the types of the functional program, we now see  as a
many-sorted signature whose set of sorts is . Each symbol  is associated to a profile  where  and  is the arity of . 
Well-sorted terms are inductively defined as follows:  is a
well-sorted term of sort  if  and
 are well-sorted terms of sorts ,
respectively. We denote by ,  and  the set of well-sorted
terms, ground terms and constructor terms, respectively. Note that we have
,  and .  
We assume that  and  are {\em sort preserving}, {\em
  i.e.} that for all rule  and all equation , ,  and  have the same sort and so do  and . 
Note that well-typedness of the functional program entails the well-sortedness
of . We
still assume that the (sorted) TRS is sufficiently 
complete, which is defined in a similar way except that it holds only for
well-sorted terms, {\em i.e.}  for all  there exists a term
 such that .
We slightly refine the definition of contracting equations as follows. For all
sort , if  has a unique constant symbol we note it .

\begin{definition}[Set  of contracting equations for  and ]
Let . The set of well-sorted equations  is {\em
  contracting} (for ) if its equations are of the form (a)  with  linear and , or
(b)  with  of sort , and if the set of normal forms of 
w.r.t. the TRS   is
finite.
\end{definition}

\noindent
The termination theorem for completion of sorted TRSs is similar to the
previous one except that
it needs -coherence of  to ensure that terms
recognized by completed automata are well-sorted (see~\cite{Genet-rep13} for proof).

\begin{theorem}
\label{th:termSort}
Let  be a tree automaton recognizing well-sorted terms,  a sufficiently
complete sort-preserving left-linear TRS and  a sort-preserving set of
equations. If  with  contracting and  is
-coherent then completion of  by  and   
terminates.\end{theorem}

\subsection{Experiments}
\label{sec:experiments}
The objective of data-flow analysis is to predict the set of all program states
reachable from a language of initial function calls, {\em i.e. } to over-approximate
 where  represents the functional program and  the
language of initial function calls. In this setting, we automatically
compute an automaton  over-approximating . But we
can do more. Since
we are dealing with left-linear TRS, it is possible to build 
recognizing . Finally, since tree automata are closed under all boolean
operations, we can compute an approximation of all the results of the function
calls by computing the tree automaton recognizing the intersection between
 and . 

Here is an example of application of those theorems.
Completions are performed using \timbuk.
All the  automata and intersections were
performed using Taml. 
Details can be found in~\cite{GenetS-rep13}. 


{\footnotesize
\begin{alltt}
\Ops append:2 rev:1 nil:0 cons:2 a:0 b:0   \Vars X Y Z U Xs    
\TRS R
append(nil,X)->X     append(cons(X,Y),Z)->cons(X,append(Y,Z))                         
rev(nil)->nil        rev(cons(X,Y))->append(rev(Y),cons(X,nil))

\Automaton A0 \States q0 qla qlb qnil qf qa qb \FinalStates q0 \Transitions
rev(qla)->q0         cons(qb,qnil)->qlb    cons(qa,qla)->qla    nil->qnil
cons(qa,qlb)->qla    a->qa                 cons(qb,qlb)->qlb    b->qb

\Equations E \Rules    cons(X,cons(Y,Z))=cons(Y,Z)  append(nil,X)=X                             rev(X)=rev(X)   
append(cons(X,Y),Z)=cons(X,append(Y,Z))     cons(X,Y)=cons(X,Y)    
rev(nil)=nil                                append(X,Y)=append(X,Y)                     
rev(cons(X,Y))=append(rev(Y),cons(X,nil))   a=a  b=b  nil=nil                            
\end{alltt}
}

\noindent
In this example, the TRS  encodes the classical {\em reverse} and {\em
  append} functions. The language recognized by automaton  is the set of
terms of the form  . Note that there are at
least one  and one  in the list. We assume that  and
sorts for symbols are the following: , , , ,  and . Now, to use Theorem~\ref{th:termSort}, we need to prove each of
its assumptions.  The set  of equations contains ,  and
. The set of Equations  is contracting because the automaton
 recognizes a finite language. This automaton can be computed
using Taml: it is the intersection between the automaton
\footnote{Such an automaton has one
  state per sort and one transition per constructor. For instance, on our
  example  will have transitions: , ,
   and .}  recognising  and the
automaton :

{\footnotesize
\begin{alltt}
\States q2 q1 q0 \FinalStates q0 q1 q2 
\Transitions b->q2 a->q2 nil->q1 cons(q2,q1)->q0
\end{alltt}
}

\noindent
The language of  is well-sorted and  and  are sort preserving.  We can
prove sufficient completeness of  on  using, for instance,
Maude~\cite{maude-manual} or even \timbuk~\cite{Genet-RTA98} itself. 
The last
assumption of Theorem~\ref{th:termSort} to prove is that  is
-coherent. This can be shown by remarking that each state  of 
recognizes at least one term and if  and  then . For instance  and  and . Thus, completion is guaranteed to terminate:
after 4 completion steps (7~ms) we obtain a fixpoint automaton 
with 11 transitions. To restrain the language to normal forms it is
enough to compute the intersection with .
Since we are dealing with sufficiently complete TRSs, we know that
. Thus, we can use again  for the
intersection that is:
 
{\footnotesize
\begin{alltt}
\States q3 q2 q1 q0  \FinalStates q3  \Transitions a->q0  nil->q1  b->q2  
cons(q0,q1)->q3  cons(q0,q3)->q3  cons(q2,q1)->q3  cons(q2,q3)->q3
\end{alltt}
}
 
\noindent
which recognizes any (non empty) flat list of  and . Thus, our analysis  preserved
the property that the result cannot be the empty list but lost the order of the
elements in the list. This is not surprising because
the equation {\tt \footnotesize cons(X, cons(Y, Z))=cons(X, Z)}
makes  equal to . It is possible to refine
by hand  using the following equations: {\tt \footnotesize
  cons(a,cons(a,X))=cons(a,X)}, {\tt \footnotesize cons(b,cons(b,X))=cons(b,X)},
  {\tt \footnotesize cons(a,cons(b,cons(a,X)))=cons(a,X)}.
This set of equations avoids the previous problem. Again, 
 verifies the conditions of Theorem~\ref{th:termSort} and completion is
still guaranteed to terminate. The result is the automaton  having 19
transitions. This time, intersection with  gives:
 
{\footnotesize
\begin{alltt}
\States q4 q3 q2 q1 q0  \FinalStates q4  \Transitions a->q1  b->q3  nil->q0  
cons(q1,q0)->q2  cons(q1,q2)->q2  cons(q3,q2)->q4  cons(q3,q4)->q4
\end{alltt}  
}
 
\noindent
This automaton exactly recognizes lists of the form  with at
least one  and one , as expected. Hopefully, refinement of equations
can be automatized in completion~\cite{BoichutBGL-ICFEM12} and can be used here,
see~\cite{GenetS-rep13} for examples. More examples can be found in the
\timbuk~3.1 source distribution.


\section{Conclusion and further research}
\label{sec:further}

In this paper we defined a criterion on the set of approximation equations to
guarantee termination of the tree automata completion. When dealing with, so called,
functional TRS this criterion is close to what is generally expected in static
analysis and abstract interpretation: a finite model for an infinite
set of data-terms. This work is a first step to use
completion for static analysis of functional programs. There remains some
interesting points to address.

\medskip
\noindent
{\em Dealing with higher-order functions}. Higher-order
functions can be encoded into first order TRS using a simple encoding 
borrowed from~\cite{Jones-Book87}: defined symbols become constants, constructor
symbols remain the same, and an additional {\em application} operator '\arobase'
of arity 2 is introduced. On all the examples
of~\cite{OngR-POPL11}, 
completion and this simple encoding produces exactly the same
results~\cite{GenetS-rep13}. 

\medskip
\noindent
{\em Dealing with evaluation strategies}. The technique proposed here, as well
as~\cite{OngR-POPL11}, over-approximates the set of results for all evaluation
strategies. As far as we know, no static analysis technique for functional
programs can take into account evaluation strategies. 
However, it is possible to restrict the completion algorithm to
recognize only innermost descendants~\cite{GenetS-rep13}, {\em i.e.}
call-by-value results. If the approximation is precise enough, any non
terminating program with call-by-value will have an empty set of
results. An open research direction is to use this to prove non termination
of functional programs by call-by-value strategy.

\medskip
\noindent {\em Dealing with built-in types}. Values manipulated by {\em real} functional
programs are not always terms or trees. They can be numerals or be terms
embedding numerals. In~\cite{GenetGLM-CIAA13}, it has been shown that completion
can compute over-approximations of reachable terms embedding built-in
terms. The structural part of the term is approximated using tree automata
and the built-in part is approximated using lattices and abstract
interpretation.



\medskip
\noindent
Besides, there remain some interesting theoretical points to solve. In
section~\ref{sec:termCrit}, we saw that having a finite  is not enough to guarantee the termination of
completion. This is due to the fact that the simplification algorithm does not
merge all states recognizing -equivalent terms. Having a simplification
algorithm ensuring this property is not trivial. First,  the theory defined 
by  has to be decidable. Second, even if  is decidable, finding all the 
-equivalent terms recognized by the tree automaton is an open problem.
Furthermore, proving that  is finite, is itself difficult. This
question is undecidable in general~\cite{TisonPrivate}, but can be answered for
some particular . For instance, if  can be oriented into
a TRS  which is terminating, confluent and such that  is finite
then  is finite~\cite{TisonPrivate}.

\medskip
\noindent
{\bf Acknowledgments} Many thanks to the referees for their detailed comments.


\bibliographystyle{plain}
{\small \bibliography{sabbrev,eureca,genet}}


\end{document}
