\documentclass{LMCS}
\usepackage{logiclmcs}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{url}
\usepackage{soul,color}
\usepackage[utf8]{inputenc}
\usepackage{enumerate,hyperref}

\def\doi{6 (4:1) 2010}
\lmcsheading {\doi}
{1--26}
{}
{}
{Sep.~17, 2010}
{Oct.~20, 2010}
{}   

\begin{document}






\newcommand{\hhl}[1]{\hl{#1}}

\newcommand{\debug}[1]{#1}

\addtolength\marginparwidth{2cm}
\newcommand{\luc}[1]{\debug{\marginpar{\tiny {\bf Luc}: #1}}}
\newcommand{\mikolaj}[1]{\debug{\marginpar{\tiny Mikolaj: #1}}}

\newcommand{\botcomp}{{H_\bot}}

\newcommand{\reorder}{\mathrm{reorder}}
\newcommand{\lgreensim}{\sim_{\mathcal L}}
\newcommand{\rgreensim}{\sim_{\mathcal R}}
\newcommand{\lex}{<_\mathrm{lex}}
\newcommand{\lexeq}{\leq_\mathrm{lex}}
\newcommand{\bigpiece}{\mathcal T}
\newcommand{\miff}{\mbox{iff}}
\newcommand{\pen}{n}
\newcommand{\hole}{\Box}
\newcommand{\ltrivial}{\mathcal L}
\newcommand{\rtrivial}{\mathcal R}

\newcommand{\rlogic}{\mathcal R}
\newcommand{\llogic}{\mathcal L}


\newcommand{\tlf}{\mathsf{F}}
\newcommand{\tle}{\mathsf E}
\newcommand{\tlu}{\mathsf U}
\newcommand{\tlex}{\mathsf{EX}}
\newcommand{\tlspider}[1]{\mathsf{E}^{#1}\mathsf{X}}
\newcommand{\tlef}{\mathsf{EF}p}
\newcommand{\tlleaf}{\mathsf{L}^{\downarrow}}
\newcommand{\tlfup}{\mathsf{F}^{\uparrow}}
\newcommand{\tlfh}{\mathsf{F}^{\rightarrow}}
\newcommand{\tlfhb}{\mathsf{F}^{\leftarrow}}
\newcommand{\tlag}{\mathsf{AG}}
\newcommand{\freef}[1]{#1^\Delta}
\newcommand{\tlsib}{\mathsf S}

\newcommand{\Stwo}{\ensuremath{\Sigma_2(<)}\xspace}
\newcommand{\Ptwo}{\ensuremath{\Pi_2(<)}\xspace}
\newcommand{\Dtwo}{\ensuremath{\Delta_2(<)}\xspace}
\newcommand{\Stwol}{\ensuremath{\Sigma_2(<,\lex)}\xspace}
\newcommand{\Ptwol}{\ensuremath{\Pi_2(<,\lex)}\xspace}
\newcommand{\Dtwol}{\ensuremath{\Delta_2(<,\lex)}\xspace}

\newcommand{\lgreen}{\le_\ltrivial}
\newcommand{\rgreen}{\le_\rtrivial}
\newcommand{\lgreeng}{\ge_\ltrivial}
\newcommand{\rgreeng}{\ge_\ltrivial}

\newcommand{\rsim}{\sim_{\rtrivial}}

\newcommand{\pieces}{\mathit{pieces}}
\newcommand{\subforest}{\leq}
\newcommand{\piece}{\preceq}
\newcommand{\pieceneq}{\prec}

\newcommand{\stab}{\mathit{stab}}
\newcommand{\sstab}{\mathit{sstab}}
\newcommand{\inter}{\Delta_2}

\newcommand{\mand}{\ \mbox{and}\ } \newcommand{\first}{\mathit{new}}

\title{Tree languages defined in first-order logic with one quantifier
alternation}
\author[M.~ Boja{\'n}czyk]{Miko{\l}aj Boja{\'n}czyk\rsuper a}	\address{{\lsuper a}Warsaw University}	\email{bojan@mimuw.edu.pl}  \thanks{{\lsuper a}Supported by Polish government grant
 no. N206 008 32/0810.}	

\author[L.~Segoufin]{Luc Segoufin\rsuper b}	\address{{\lsuper b}INRIA - LSV}
\urladdr{http://www-rocq.inria.fr/segoufin}
\thanks{{\lsuper b}Work partially funded by the AutoMathA
programme of the ESF}	

\begin{abstract}
  We study tree languages that can be defined in . These are tree
  languages definable by a first-order formula whose quantifier prefix is
  , and simultaneously by a first-order formula whose
  quantifier prefix is . For the quantifier free part we
  consider two signatures, either the descendant relation alone or together
  with the lexicographical order relation on nodes. We provide an effective
  characterization of tree and forest languages
  definable in . This characterization is in terms of algebraic
  equations. Over words, the class of word languages definable in 
  forms a robust class, which was given an effective algebraic characterization
  by Pin and Weil~\cite{weilpinpoly}.
\end{abstract}
\keywords{first-order logic on trees, forest algebra}
\subjclass{F.4.3,F.4.1}

\maketitle

\section{Introduction}

We say a logic  has a decidable characterization inside a logic  if the following
decision problem is decidable: ``given as input a formula of the logic ,
decide if it is equivalent to some formula of the logic ''. We are interested in the case when the logic  is MSO on words or trees, and  represents some fragment of . 

This type of problem has been successfully studied in the case when  is
MSO on finite words. In other words , represents the class of regular
word languages.  Arguably best known is the result of McNaughton, Papert and
Sch\"utzenberger~\cite{schutzenberger,mcnaughton}, which says that the
following two conditions on a regular word language  are equivalent: a) 
can be defined in first-order logic with order and label tests; b) the
syntactic semigroup of  does not contain a non-trivial group. Since
condition b) can be effectively tested, the above theorem gives a decidable
characterization of first-order logic. This result demonstrates the importance
of this type of work: a decidable characterization not only gives a better
understanding of the logic in question, but it often reveals unexpected
connections with algebraic concepts.  During several decades of research,
decidable characterizations have been found for fragments of first-order logic
with restricted quantification and various signatures (typically subsets of the
order relation and the successor relation), as well as a large group of
temporal logics, see \cite{pin-survey} and \cite{wilke} for references.


An important part of this research has been devoted to the quantifier
alternation hierarchy, where each level counts the alterations between
 and  quantifiers in a first-order formula in prenex normal
form. The quantifier free part of such a formula is  built using a binary
predicate  representing the linear order on the word. Formulas that have
 alternations (and therefore  blocks of quantifiers) are called  if they begin with , and
 if they begin with~. For instance, the word property ``some
position has label '' can be defined by a  formula , while the language ``nonempty words with at most two positions that
do not have label '' can be defined by the  formula



A lot of attention has been devoted to analyzing the low levels of the
quantifier alternation hierarchy for word languages.  The two lowest levels are easy: a word
language is definable in  (resp.~) if and only if it is
closed under inserting (removing) letters. Both properties can be tested in
polynomial time based on a recognizing automaton, or semigroup.  However, just
above , and even before we get to , we already find two important classes of languages.  A fundamental
result, due to Simon~\cite{simonpiecewise}, says that a language is defined by
a Boolean combination of  formulas if and only if its syntactic
monoid is -trivial. Above the Boolean combination of ,
we find , i.e.~languages that can be defined simultaneously in
 and . As we will describe later on, this class turns
out to be surprisingly robust, and it is the focus of this paper. Another
fundamental result, due to Pin and Weil~\cite{weilpinpoly}, says that a regular
language is in  if and only if its syntactic monoid is in {\sc
  DA}.  The limit of our knowledge is level : it is decidable if a
language can be defined on level ~\cite{arfi91,weilpinpoly}, but
there are no known decidable characterization for Boolean combinations of
, for , for , and upwards.


For trees even less is known.  No decidable characterization has been
found for what is arguably the most important proper subclass of
regular tree languages, first-order logic with the descendant
relation, despite several attempts.  Similarly open are chain logic
and the temporal logics CTL, CTL* and PDL.  However, there has been
some recent progress.  In~\cite{efextcs}, decidable characterizations
were presented for some temporal logics, while Benedikt and
Segoufin~\cite{segoufinfo} characterized tree languages definable in
first-order logic with the successor relation (but without the
descendant relation).

This paper is part of a program to understand the expressive power of
first-order logic on trees, and the quantifier alternation hierarchy
in particular. The idea is to try to understand the low levels of the
quantifier alternation hierarchy before taking on full first-order
logic (which is contrary to the order in which word languages were
analyzed). We focus on two signatures. The first signature contains
unary predicates for label tests and the ancestor order on nodes,
denoted . The second signature assumes that the trees have an order
on siblings, which induces a lexicographical linear order on nodes,
denoted .  Both signatures generalize the linear order on words.
As shown in~\cite{forestexp}, there is a reasonable notion of
concatenation hierarchy for tree languages that corresponds to the
quantifier alternation hierarchy. Levels  and 
are as simple for trees as they are for words. A recent
result~\cite{simontrees} extends Simon's theorem to trees, by giving a
decidable characterization of tree languages definable by a Boolean
combination of  formulas, and also a decidable
characterization of Boolean combinations of 
formulas.  There is no known decidable characterization of tree
languages definable in  for .

The contribution of this paper is a decidable characterization of tree
languages definable in \Dtwo, i.e.~definable both in \Stwo
and .  We also provide a decidable characterization of tree
languages definable in \Dtwol.


As we signaled above, for word languages the class
 is well studied and important, with numerous equivalent
characterizations.  Among them one can
find~\cite{weilpinpoly,therienwilkefo2,turtle,EVW02}: a) word
languages that can be defined in the temporal logic with operators
 and ; b) word languages that can be defined by a
first-order formula with two variables, but with unlimited quantifier
alternations; c) word languages whose syntactic semigroup belongs to
the semigroup variety DA; d) word languages recognized by two-way
ordered deterministic automata; e) a certain form of ``unambiguous''
regular expressions.

It is not clear how to extend some of these concepts to trees. Even when
natural tree counterparts exist, they are not equivalent. For instance, the
temporal logic in a) can be defined for trees---by using operators ``in some
descendant'' and ``in some ancestor''.  This temporal logic was studied
in~\cite{fo2tree}, however it was shown to have an expressive power
incomparable with that of \Dtwo. A characterization of \Dtwo was left
as an open problem, one which is solved here.

We provide an algebraic characterization of tree languages definable in \Dtwo
and in \Dtwol. This characterization is effectively verifiable if the language
is given by a tree automaton. It is easy to see that the word setting can be
treated as a special case of the tree setting. Hence our characterization
builds on the one over words.  However the added complexity of the tree setting
makes both formulating the correct condition and generalizing the proof quite
nontrivial.


\section{Trees forests and languages}
In this section, we present some basic definitions regarding trees. We also present the formalism of forest algebra, which is used in  our characterizations.


\subsection{Trees, forests and contexts}
In this paper we work with finite, unranked, ordered trees and forests
over a finite alphabet  Formally, these are expressions defined
inductively as follows: If  is a forest and  then  is
a tree.  If  is a finite sequence of trees, then
 is a forest.  This applies as well to the empty
sequence of trees, which is called the {\it empty forest,} and denoted
0 (and which provides a place for the induction to start).  Forests
and trees alike will be denoted by the letters  When
necessary, we will  remark which forests are trees, i.e.~contain
only one tree in the sequence.



The notion of node, as well as the descendant and ancestor relations are
defined in the usual way. We write  to say that  is a strict ancestor of
 or, equivalently, that  is a strict descendant of . As usual, we
write  when  or .  The parent of a node  is its
immediate ancestor. Two nodes  and  are \emph{siblings} if they have the
same parent.  We also use the lexicographic order on nodes, written .
Recall that  holds if either , or there are nodes 
and  such that  is a sibling to the left of .

If we take a forest and replace one of the leaves by a special symbol
, we obtain a \emph{context.}  Contexts will be denoted
using letters . A forest  can be substituted in place of the
hole of a context , the resulting forest is denoted by .
 There is a natural composition operation on contexts: the
context  is formed by replacing the hole of  with .
This operation is associative, and satisfies  for all
forests  and contexts  and .



We say a forest  is an \emph{immediate piece} of a forest  if
 can be decomposed as  and  for some context ,
some label , and some forest . The reflexive transitive closure
of the immediate piece relation is called the \emph{piece}
relation. We write  to say that  is a piece of . In
other words, a piece of  is obtained by removing nodes from .
We extend the notion of piece to contexts. In this case, the hole must
be preserved while removing the nodes. The notions of piece for
forests and contexts are related, of course. For instance, if , 
are contexts with , then . Also, conversely,
if , then there are contexts  with  and
. (For instance, one can take  and .)
The picture below depicts two contexts, the left one being a piece of
the right one, as can be seen by removing the white nodes.
\medskip
\begin{center}
  \includegraphics[scale=0.8]{piece}
 \end{center}
We will be considering three types of languages in the paper:
 \emph{forest languages} i.e.~sets of forests, denoted ;
 \emph{context languages}, i.e.~sets of contexts, denoted , and
 \emph{tree languages}, i.e.~sets of trees, denoted . Note that a
 forest language can contain trees.

\subsection{Forest algebras}
\label{sec:forest-algebra}
{\it Forest algebras} were introduced by Boja\'nczyk and Walukiewicz as an
algebraic formalism for studying regular tree languages~\cite{forestalgebra}.  Here
we give a brief summary of the definition of these algebras and their important
properties.  A forest algebra consists of a pair  of finite monoids,
subject to some additional requirements, which we describe below.  We write the
operation in  multiplicatively and the operation in  additively, although
 is not assumed to be commutative.  We accordingly denote the identity of
 by  and that of  by 0.
We require that  act on the left of .  That is, there is a map
 
 such that 
 
 for all  and  We further require that this action be {\it
   monoidal,} that is,

 for all  and that it be {\it faithful,} that is,
 if  for all  then 
Finally we require that for every   contains elements 
 and  defined by
 
 for all 

 A morphism  of forest algebras is actually a
 pair  where  is a monoid morphism between  and
  and  is a monoid morphism between  and , such that
  for all   However, we will
 abuse notation slightly and denote both component maps by 

 Let  be a finite alphabet, and let us denote by  the set of
 forests over  and by  the set of contexts over  Each of
 these is a monoid, with the operations being forest concatenation and
 context composition, respectively. The pair , with forest
 substitution as action, forms a forest algebra, which we denote
 



 We say that a forest algebra  {\it recognizes} a forest
 language  if there is a morphism
  and a subset  of  such that
  A forest language is regular, i.e.~recognized by any of the many equivalent notions of automata for unranked trees that can be found in the literature, if and only if it is
 recognized by a finite forest algebra~\cite{forestalgebra}.

 Given any finite monoid , there is a number  (denoted by
  when  is understood from the context) such that for all elements
  of ,  is an idempotent: .
 Therefore for any forest algebra  and any element  of  and  of
  we will write  and  for the corresponding
 idempotents. The element  is idempotent with respect to the
 operation in . The element , which is the same as
  and the same as , is idempotent with
 respect to the operation in .


 Given a forest language  we define an equivalence relation  on
  by setting  if and only if for every context  the forests  and  are either both in  or both outside of 
 We further define an equivalence relation on , also denoted
  by setting  if for all   This pair of equivalence relations defines a congruence of
 forest algebras on  and the quotient  is
 called the {\it syntactic forest algebra} of  Each equivalence
 class of  is called a \emph{type}.


 We now extend the notion of piece to elements of a forest algebra . The
 general idea is that a context type  is a piece of a context type  if
 one can construct a term (using elements of  and ) which evaluates to
 , and then take out some parts of this term to get .
\begin{def}\label{df:piece-alg}
  Let  be a forest algebra. We say  \emph{is a piece}
  of , denoted by , if there is an alphabet 
  such that  and  hold for some morphism
  
  and some contexts  over .  The relation  is
  extended to  by setting  if  and  for
  some context types .
\end{def}

\section{Logic}
The focus of this paper is the expressive power of first-order logic
on trees.  A forest can be seen as a logical relational structure.
The domain of the structure is the set of nodes. (We allow empty
domains, which happens when an empty forest  is considered.) We
consider two different signatures. Both of them contain a unary
predicate  for each symbol  of the alphabet , as well as a
binary predicate  for the ancestor relation. Furthermore, the
second signature also contains a binary predicate  for the
lexicographic order on nodes.  A formula without free variables over
these signatures defines a set of forests, these are the forests where
it is true.  We are particularly interested in formulas of low
quantifier complexity.  A  formula is a formula of the form

where  is quantifier free.  Languages defined in 
are closed under disjunction and conjunction, but not necessarily
negation. The negation of a  formula is called a 
formula, equivalently this is a formula whose quantifier prefix is
.  A forest property is called  if it
can be expressed both by a  and a  formula.
We will use \Stwo and \Stwol to specify which predicates are used in
the signature, similarly for  and .

With limited quantification, the choice of signature is a delicate
question. For instance, adding a child relation changes the expressive power.

\subsection{The problem}

We want an algorithm deciding whether a given regular forest language is
definable in \Dtwol and another one for deciding whether it is in \Dtwo.

As noted earlier, the corresponding problem for words was solved by
Pin and Weil~\cite{weilpinpoly}: a word language  is definable in
\Dtwo if and only if its syntactic monoid  belongs to the
variety DA, i.e.~it satisfies the identity

\noindent
for all . The power  means that
the identity holds for sufficiently large powers (in different
settings,  is defined in terms of idempotent powers, but the
condition on sufficiently large powers is good enough here).  Since
one can effectively test if a finite monoid satisfies the above
property (it is sufficient to verify the power ), it is
decidable whether a given regular word language is definable in
\Dtwo. We assume that the language  is given by its syntactic
monoid and syntactic morphism, or by some other representation, such
as a finite automaton, from which these can be effectively computed.



We will show that a similar characterization can be found for forests;
although the identities will be more involved.  For decidability, it
is not important how the input language is represented. In this paper,
we will represent a forest language by a forest algebra that
recognizes it.  Forest algebras are described in the next section.

\subsection{Tree languages.}
We give an algorithm which says when a forest language belongs to a class , which is either \Dtwo or \Dtwol.
What about tree languages? There are two ways of getting a class of tree languages from a class of forest languages . 
\begin{enumerate}[(1)]
\item The class of tree languages that belong to .
\item The class of tree languages of the form , where  is an alphabet,   is the set of all trees over alphabet , and  is a forest language over .
\end{enumerate}
Our algorithm gives a decision procedure under the first definition. The usual understanding of  tree languages definable in \Dtwo or \Dtwol corresponds to the second definition.

Fortunately, the two  definitions are equivalent when  is either \Dtwo or \Dtwol. This is because in both cases,    is closed under intersection and contains the languages  .  

Closure under intersection is immediate. Why does  contain the languages ? Since \Dtwo is the less powerful logic, it suffices to show how to define  using a \Stwo formula, and also using a \Ptwo formula. The \Stwo
formula says there exists a node that is an ancestor of all other
nodes, while the \Ptwo formula says that for every two nodes, there
exists a common ancestor. 

In general, the definitions of tree language classes are not equivalent. Consider as  the class of forest languages defined by purely existential formulas. In particular, if a language  contains a tree , then it also contains the forest . This means that under the first definition, the only tree languages we get are the empty tree languages. Under the second definition, we get some more tree languages, such as ``trees with at least two nodes''.





\subsection{Basic properties of \texorpdfstring{}{Pi1} and  \texorpdfstring{}{Sigma2}}
Most of the proofs in the paper will work with \Stwo or \Stwol formulas. We
present some simple properties of such formulas in this section.

Apart from defining forest languages, we will also be using formulas to define
languages of contexts. To define a context language we use formulas with a free
variable; such a formula is said to hold in a context if it is true when the
free variable is mapped to the hole of the context.§ For instance, the formula
 with a free variable  defines the set
of contexts where every ancestor of the hole has label .

We begin by describing the expressive power of  purely universal formulas .
\begin{lem}\label{lem:pi1-lemma}
  A forest language is closed under pieces if
  and only if it is definable in .  Likewise for
  context languages.
\end{lem}
\begin{proof}
  It is clear that a forest language definable in  is closed under
  pieces as the models of a  formula are closed under substructures.

  For the converse, let  be a forest language that is closed under pieces,
  and let  be its syntactic algebra.  Thanks to a
  pumping argument, any forest has a piece with the same type, but at most
   nodes.  Let  be the finite set of forests with at most
   nodes that are outside . Thanks to the pumping argument, a
  forest belongs to  if and only if it has no piece in the set . The
  latter is a property that can be expressed in .
  
  If, additionally, the language  is commutative, then we do not need
  to worry about the lexicographic order when talking about the pieces
  in , only the descendant order is relevant.
\end{proof}

We now turn to the formulas from . We begin  with \Stwol,
since it has the  better closure properties.
\begin{lem}\label{fact:simple-lex}
  Let  be context languages and  be forest languages. If
  these languages are all definable in \Stwol, then so are
\begin{enumerate}[\em(1)]
\item the forest language ,
\item the forest language ,
\item the context language ,
\item the forest language ,
\item the context language ,
\end{enumerate}
\end{lem}

\proof
  We only do the proof for , the others are treated similarly. 
When does a forest  belong to ? There must exist two siblings  and  such that the set, call it , of gray nodes in the picture below
\medskip
\begin{center}
\includegraphics[scale=0.8]{relativize}
\end{center}
describes a forest in , and the other nodes describe a context in . Below
we define this property more precisely, and show that it can be defined in
\Stwol.

First, we want to say that the nodes  and  are siblings. This can be
expressed by a formula, call it , of \Stwol. The formula
quantifies existentially a common ancestor and uses universal quantification to
check that this common ancestor is a parent of both nodes:


Next, we describe the set .  Membership  is defined by a quantifier-free formula 


Next, we say what it means for the part inside  describes a forest in . Suppose that the forest language  is defined by a formula  of \Stwol. To say that  describes a forest in  we use the formula    obtained from  by restricting quantification to nodes satisfying .  Note that    has free variables  from . Since  is quantifier-free, the formula  is also in \Stwol.

Finally, we  say that the part outside   describes a context in . The idea is that the hole of this context corresponds to the set . The logical formula is constructed below. Suppose that  is a formula of \Stwol that describes . Note that this formula has a free variable, as with formulas for contexts, which corresponds to the hole. Let  be the formula obtained from  by restricting quantification to nodes not satisfying . The remaining question is: which node should we use for ? Any node from  will do, since for each node ,  all nodes from  have the same relationship to , with respect to the descendant and lexicographic orders. We use the node  for .

Summing up, the formula for  is written below.


\subsection{\texorpdfstring{}{Sigma2} expressions.}
In the proofs, it will sometimes be more convenient to use a type of regular expression instead of formulas. These are called  \emph{ forest expressions} and \emph{ context
  expressions}, and are defined below by mutual recursion:
  \begin{enumerate}[]
  \item Any forest (respectively, context) language that is closed
    under pieces is a  forest (respectively, context)
    expression.  For any label ,  is a
     context expression. Likewise for , the language containing only the empty context.
\item If  are  context expressions and  are
   forest expressions, then
  \begin{enumerate}[]
  \item  is a  context expression;
\item  is a  forest expression;
\item  is a  forest expression.
\item  is a  forest expression. 
\item  is a  forest expression. 
\item  is a  forest expression. 
\item  is a  forest expression. 
  \end{enumerate}
  \end{enumerate}
From Lemmas~\ref{lem:pi1-lemma} and~\ref{fact:simple-lex}  it follows that languages defined by   forest
and context expressions are definable in \Stwol.



\section{Characterization of \texorpdfstring{\Dtwol}{Dtwol}}
\label{sec:char-inter}
The main result of this paper is the following theorem:

\begin{thm}[Effective characterization of  with descendant
  and lexicographic orders]\label{thm:main}\ \vspace{-0.3cm} \\ 
 A forest language is definable in \Dtwol if and only if its syntactic
  forest algebra satisfies the following  identity, called the
   identity,
  
\end{thm}

Before we prove the main theorem, we state and prove
an important corollary.
\begin{cor}\label{cor:decid}
  It is decidable whether a forest language can be defined in \Dtwol.
\end{cor}
\begin{proof}
  We assume that the language is represented as a forest algebra. This
  representation can be computed based on other representations, such
  as automata or monadic second-order logic. 

  Once the forest algebra is given, the  identity can be
  tested in polynomial time by searching through all elements of the
  algebra. The relation  can be computed in polynomial time,
  using a fixpoint algorithm as in~\cite{fo2tree}.
\end{proof}



The following lemma gives the easier implication from the main theorem.

\begin{lem}\label{lemma:correctness}
  Let  be a formula of \Stwol and let  be two
contexts. For  sufficiently large, forests  satisfying  are closed under replacing
 with .
\end{lem}
\begin{proof}
  Assume that  is , with  quantifier-free.  Any first-order definable
  tree language is aperiodic~\cite{schutzenberger}, i.e.~there is a number  such that any
  context  can be replaced by  without affecting membership
  in the language, for any . We set .

 Consider a forest  that satisfies . We want to show that
 the forest  also satisfies . By aperiodicity, it
 is sufficient to show that 
 for some numbers ,  satisfies .

 Because  satisfies  we can fix  nodes 
 that make  true. By the choice of ,
  can be decomposed as  such that  and the
 middle  part contains none of the nodes . We show that
  satisfies , which will conclude the proof
 of the lemma.

 We identify the nodes of  with the nodes of  outside the inserted
 context .  Consider the valuation of the variables  that
 we fixed above. We show that this valuation, when seen as nodes of , makes
  true. Indeed, for any valuation for the variables 
 in , we show that the valuation makes the quantifier-free part 
 true. This is obvious if none of the  are in  because  holds
 in  and the insertion of  does not affect the relationship  and
  between the selected nodes.  If some of the  are in  then one
 of the contexts  in the middle block  of  does not contain any
 variable. As removing the context  that does not contain any variable does
 not affect the relationship  and  between the selected nodes, 
 holds on  iff it holds on .
 Moreover, because  is a piece of , replacing  by   does
 not affect the relationship  and  between the selected nodes and therefore
 holds on  iff it holds on .
 Hence  must hold with the new valuation.
\end{proof}

The rest of the paper contains the more difficult implication of
Theorem~\ref{thm:main} which is a consequence of the proposition below.

\begin{prop}\label{prop:bottom-up}
  Fix a morphism , with 
  satisfying the  identity.  For each , the set 
   of forests  with type  is definable by a  forest
  expression, and thus also by a formula of \Stwol.
\end{prop}


Before proving this proposition, we show how it concludes the proof of
Theorem~\ref{thm:main}.  Since  expressions allow union, the
above proposition shows that any language recognized by  can
be defined by a  forest expression. In particular, if  is
recognized by , then both  and its complement can be
defined by  forest expressions, and consequently formulas of
\Stwol.  Since the complement of a \Stwol formula is a \Ptwol
formula, we get the right-to-left implication in
Theorem~\ref{thm:main}.

The rest of the paper is devoted to showing
Proposition~\ref{prop:bottom-up}. The proof is by induction on two
parameters.  For the second parameter, we need to define a pre-order on . We say that a type  is
\emph{reachable from} a type  if there is a context type  such
that . If  and  are mutually reachable from each other,
then we write . Note that  is an equivalence relation.
Note also that if  is reachable from , then  is a piece of
. We write  for the set of types  that can be reached
from every type . Note that  is not empty, since it
contains the type , for any enumeration
. 




The proof of Proposition~\ref{prop:bottom-up} is by induction on the
size of the algebra  and then on the position of  in the
reachability pre-order. The two parameters are ordered
lexicographically, the most important parameter being the size of the
algebra. That is we will either decrease the size of the algebra or
stay within the same algebra, but go from a type  to a type 
such that  is reachable from  but not vice versa. As far as 
is concerned, the induction corresponds to a bottom-up pass, where
types close to the leaves are treated first.




Part of the  induction proof is presented in Section~\ref{sec:induction-step}.
However, the induction breaks down for types from , which are
treated in Section~\ref{sec:top-down}.



\section{Types  outside \texorpdfstring{}{Hbot}}\label{sec:induction-step}


In this section we prove Proposition~\ref{prop:bottom-up} for forest types outside . We fix such a forest type  for the rest of the section. By induction assumption, for each type  from
which  is reachable, we have a  forest expression defining the
language  of forests of type . (The case when there are no
such types  corresponds to the induction base, which is treated the
same way as the induction step.) In this section we assume that  is
outside , and we will produce a  forest expression
for . The case where  is in  will be treated in
Section~\ref{sec:top-down}.

In the following, we will be using the \emph{stabilizer} of ,
defined as

We say that a context type  stabilizes  if it belongs to the
stabilizer of .  The key lemma is that the  identity
implies that the stabilizer is a submonoid of .

\begin{lem}\label{lemma:closed-under-comp}
  The stabilizer of  only depends on the -class of . In
  particular, it is a  submonoid of .
\end{lem}
\begin{proof}
  We need to show that if  then
  . Assume . Then . Hence we have  such that  and
  . This implies that  and therefore
  . From the  identity we have that
  
  Hence  is reachable from . Since  is clearly reachable
from , we get   and .

To see that  is a submonoid consider . We need to
show that . Let . Because  we have . As  we have  and hence .
\end{proof}

Recall now the piece order on forest types from the end of
Section~\ref{sec:forest-algebra}, which corresponds to removing nodes
from a forest. We say a set  of forest types is
\emph{closed under pieces} if any piece of a forest type 
also belongs to . A similar definition is also given for sets of
context types. Another consequence of the  identity is:

\begin{lem}\label{lemma:closed-under-piece}
  Each stabilizer is closed under pieces.
\end{lem}
\begin{proof}
  We need to show that if  stabilizes , then each piece  of
   also stabilizes . By definition of the stabilizer we have a
  context type  such that . We are looking for a context type  such
  that . From  we get . Hence by the
   identity we have  as desired.
\end{proof}

We now consider two possible cases: either , or not. Equivalently,
we could have asked if  stabilizes . Again equivalently, we could
have asked if  stabilizes . When , we will conclude by
induction on the size of the algebra. When , we will conclude
by induction on the reachability pre-order. These cases are treated separately
in Sections~\ref{sec:h-does-not-preserve-itself}
and~\ref{sec:h-preserves-itself}, respectively.

\subsection{\texorpdfstring{}{h+h sim h}}
\label{sec:h-preserves-itself}
Let  be the set of pieces of . By assumption that ,
we know that both  and  stabilize . 
\begin{lem}\label{lem:sub-forest-algebra}
  If  then  is a forest
  algebra.
\end{lem}
\begin{proof}
    We need to show that the two sets are closed under all operations:

  The first of the above inclusions follows from
  Lemma~\ref{lemma:closed-under-comp}. For the second inclusion, we
  note that  is a piece of  by assumption on . In
  particular, each forest type in  is a piece of . For the
  third inclusion,  implies that both  and
   stabilize . Since by
  Lemma~\ref{lemma:closed-under-piece} the stabilizer is closed under
  pieces, we get the third inclusion. For the last inclusion, consider
   and . We need to show that . This holds because  is a piece of , which is a piece of
   as .
\end{proof}


Recall that in this section we are dealing with the case when  is
outside , i.e.~there are some forest types that can be
reached from  but not vice versa. In this case we show that  is a proper
subset of . To see this, we show that for , . Assume for contradiction that . Then  is a
piece of  and because  and  is closed
under pieces (Lemma~\ref{lemma:closed-under-piece}), we infer  and  is reachable from , a contradiction.

Therefore the algebra from the above lemma is a
proper subalgebra of the original .  Furthermore, this algebra
contains all pieces of ; so it still recognizes the language ;
at least as long as the alphabet in the morphism is reduced to include
only letters that can appear in .  We can then use the induction
assumption on the smaller algebra to get a  forest
expression for .


\subsection{\texorpdfstring{}{h+h notsim h}}
\label{sec:h-does-not-preserve-itself}

For , we write  for the set of contexts of type . For
, we write  for the set of forests of type , and
 for the set of trees of type .



Let  be the set of forest types  such that  is reachable from
 but not vice-versa.  By induction assumption,  for each ,
the  language 
is definable by a  forest expression. Our
goal is to give a  forest expression for .

\begin{lem}\label{lem:decompo-nonminim}
  Any forest  of type  can be decomposed as , with  a
  forest whose type is  reachable from , and which furthermore is:
\begin{enumerate}[\em(1)]
\item A tree  with the type of  in ; or
\item A forest  with the types of  in .
\end{enumerate}
\end{lem}
\begin{proof}
  Consider decompositions of  as . Among such decompositions,
  take a decomposition where the forest  has a type reachable from
  , but  has no subforest with a type reachable from . Such  a
  decomposition always exists as  is of type . If 
  is a tree, we get case (1), if  is a forest, we get case (2).
\end{proof}

Note that in the above lemma, the type of the context  must
stabilize , since both the type of  and the type of the whole
forest  are in the class of . Therefore, thanks to the above
lemma, the set  of forests with type  can be decomposed as

Note that ,  and  can all be written as
 forest expressions thanks to the induction assumption from
Proposition~\ref{prop:bottom-up}.  The only thing that remains is
showing that the context language  can be defined by a 
context expression.  For this, we use the following proposition.




\begin{prop}\label{prop:context-expression}
  For any , the language  of contexts of type  is
  defined by a finite union of concatenations of the form  where each context language  is either:
  \begin{enumerate}[\em(1)]
  \item A singleton language  for some ; or
\item A context language closed under pieces; or
\item  A  context  language    
  or  for  some .
  \end{enumerate}
\end{prop}


The proof of this proposition will be presented in
Section~\ref{sec:treat-cont-like-words}. Meanwhile, we show how the
proposition gives a  context expression for each language 
in~(\ref{eq:lh-nonmaximal-decomp}). The singleton languages, and the
languages closed under pieces are  context expressions by
definition.  The only potential problem is with the languages  or  that appear in the proposition.  Since the
context types  that appear in~(\ref{eq:lh-nonmaximal-decomp})
stabilize , the forest type  has to be such that  or
 stabilizes . In either case,  cannot be reachable
from , since  and the stabilizer is closed under
pieces. As  is obviously reachable from , the language  is
definable by a  forest expression thanks to the induction
assumption from Proposition~\ref{prop:bottom-up}. Finally,  is
the intersection of  with the set of all trees, which is
definable by a  forest expression.


\section{Treating contexts like words}
\label{sec:treat-cont-like-words}
In this section, we prove Proposition~\ref{prop:context-expression}.
The basic idea is that a context is treated as a word, whose letters are smaller contexts.
The proof strategy is as follows. First, in Section~\ref{sec:inter-words}, we
present the characterization of \Dtwo for words, which was shown by Pin and
Weil in~\cite{weilpinpoly}. This characterization is slightly strengthened to
include what we call stratified monoids, which are used to model the contexts
that appear in Proposition~\ref{prop:context-expression}.  Then, in
Section~\ref{sec:proof-prop-refpr}, we apply the word result, in its
strengthened form, to prove Proposition~\ref{prop:context-expression}.

\subsection{\texorpdfstring{\Dtwo}{Dtwol} for words}
\label{sec:inter-words}
In this section we present the characterization of \Dtwo for words,
extended to stratified monoids.  A \emph{stratified monoid} is a
monoid  along with a pre-order  that satisfies the following
property:

A subset  is called \emph{downward closed under } if for every , and every , we also have .
 
\begin{prop}\label{prop:word-da}
  Let  be an alphabet (possibly infinite), and let  be a morphism into a stratified monoid  that satisfies
  the identity
  
  For any , the language  is defined by a
  finite union of expressions
  
  where each  is of the form  for some , and each  is of the form  for
  some  downward closed under .
\end{prop}

The difference between the above result and the main technical result
in Pin and Weil is twofold. First, we use infinite alphabets here.
Second, we use stratified monoids to get a
stronger conclusion, where the letters in the blocks  are
downward closed.  Both differences are necessary for our application
to context languages.

Our proof is a straightforward adaptation of a proof of Th\'erien and Wilke
in~\cite{therienwilkefo2}, which analyzed the languages recognized by
semigroups in DA. 

  Before proving this result, we remark how
  Proposition~\ref{prop:word-da} gives the
characterization of \Dtwo presented by Pin and Weil:
\begin{cor}[Pin and Weil~\cite{weilpinpoly}]
  A word language (over a finite alphabet) is definable \Dtwo if and only if
  its syntactic monoid satisfies the identity~(\ref{eq:da}).
\end{cor}
\begin{proof}
  The only if implication is shown using a standard
  Ehrenfeucht-Fraïssé argument, we only consider the if implication.

  Let then  be a language recognized by a morphism
  , with  satisfying (\ref{eq:da}). We can see
  this  as a stratified monoid under the identity pre-order. By
  applying Proposition~\ref{prop:word-da}, we see that each inverse
  image  is defined by an expression as in
  Proposition~\ref{prop:word-da} (the downward closure is a vacuous
  condition, since the order is trivial). Since each such expression
  is clearly expressible in \Stwo, we get that  is definable
  in \Stwo. Furthermore, by Proposition~\ref{prop:word-da} also
  the complement of  is definable in \Stwo, and therefore 
  is also definable in \Ptwo.
\end{proof}


We now proceed to the proof of Proposition~\ref{prop:word-da}.  The proof is by
induction on the size of  or, equivalently, the number of
elements in the monoid that correspond to single letters. In the proof
of Thérien and Wilke, the induction was simply on the size of the alphabet,
but this will not work here, since the alphabet is infinite.

 We use the term
\emph{ word expression} for the word expressions as in the
statement of the Proposition~\ref{prop:word-da}. It is not difficult to
show that languages defined by  word expressions are closed under
union, intersection and concatenation.

We will use the following notation. Given two elements  and  of  we
say that  if there exist  such that  and . We
say that  if there exist  such that 
and . These are the left and right Green's relations.

A classical consequence of aperiodicity, itself a consequence
of~(\ref{eq:da}), is:


  We will also use the following property of monoids
  satisfying~(\ref{eq:da}), which can be proved along the lines of
  Lemma~\ref{lemma:closed-under-comp}.



\begin{lem}\label{lemma:wilke3}
  For all , the language  is
  definable by a  word expression. 
\end{lem}
\begin{proof}
  Let  be the set of letters  of  such that . In other words, , where  is the set
  .

  We will show that . Stated differently, a word belongs  if
  and only if all of its letters belong to .


  Thanks to~(\ref{eq:wilke1}), for all  we have . Hence by induction on the length of  we can prove
  . For the converse implication, let  be a word outside ,
  of the form  with  and . Then
 for some , and from the discussion above we
have . Hence by~(\ref{eq:wilke1}) and by hypothesis on ,  and  cannot be in .

  

 To conclude, we need to show that  is closed under .
 Indeed, let  and let . By assumption on the
 monoid being stratified, we have . In
 particular, we have 
 
 From the above it follows that , which gives
  by~(\ref{eq:wilke1}), and hence .
\end{proof}

Note that by~(\ref{eq:wilke1}) we have  whenever .

\begin{lem}\label{lemma:wilke4}
  For any , the following language can be defined by a
   word expression:

\end{lem}


Before we give the proof, we show how it concludes the proof of
Proposition~\ref{prop:word-da}. Consider the set  . Each word  in this set can be written as  where  is the
smallest prefix of  such that . Hence we have:

Since  word expressions are closed under union and concatenation, the
above language is definable by a  word expression  thanks to
Lemmas~\ref{lemma:wilke3} and \ref{lemma:wilke4}.  Using a symmetric version of
Lemma~\ref{lemma:wilke3} and Lemma~\ref{lemma:wilke4} for , we can get
an  word expression for . But we also know
from~(\ref{eq:wilke2}) that

and the result follows by closure of  word expressions under
intersection.


\medskip
\begin{proof}[Proof of Lemma~~\ref{lemma:wilke4}]
  We say that  is \emph{a prefix} of  if there exists 
  such that . This defines a pre-order in . The proof is by
  induction on the position of  relative to this pre-order.

  The induction base is when  has no proper prefixes: If  then .
  In this case the language  contains at most the empty word, since the
  condition on  is infeasible.  Clearly both languages
   and  are  word expressions.

Assume now that  is not minimal. Each word  of  can be written as
 where ,  and . Furthermore,  can be
written as  where  is the smallest prefix of  such that
. We therefore have:

where the union is taken for  such that ,
 a prefix of  and for  with . By induction the language  is definable by a
 word expression. It is also clear that . Recall from the proof of Lemma~\ref{lemma:wilke3} that
 where  for some .
Therefore we also have .
From~(\ref{eq:wilke1}) and the fact that  we know that , therefore  is a proper subset of . Let 
be the restriction of  to . We have
, from induction on the size of
the alphabet in Proposition~\ref{prop:word-da} we obtain a 
word expression for . This concludes the proof of this lemma
as  word expressions are closed under concatenation and union.
\end{proof}




\subsection{Proof of Proposition~\ref{prop:context-expression}}
\label{sec:proof-prop-refpr}
We now proceed to show how the word result stated in
Proposition~\ref{prop:word-da} can be lifted to the context result in
Proposition~\ref{prop:context-expression}. Proposition~\ref{prop:context-expression}
says that for any context type , the set of contexts of type 
  is described by a finite union of expressions of the form  where each  is either: a singleton language ; or
closed under pieces; or an expression  or .

The basic idea is that we treat the context as a word over an infinite
alphabet, which we call . This alphabet has two kinds of letters.
Both kinds are contexts:
\begin{enumerate}[]
\item Contexts of the form , for .
\item Contexts of the form  or , for  a tree
  over .
\end{enumerate}

Consider now the morphism , which is simply 
restricted to the contexts in~.  Every context  in  can be
decomposed as . In particular, we have


We can treat  as a stratified monoid, by using the piece relation
 as the pre-order. By applying Proposition~\ref{prop:word-da}, we
see that the inverse image  can be presented as a
finite union of expressions of the form:
  
  where  are elements of , and  are
  a subsets of  that are downward closed under .

  We need to show that the expressions used above are of the three
  forms allowed by Proposition~\ref{prop:context-expression}.
  Consider first an expression , where  is closed under pieces. Since  is closed under
  pieces (as a set of context types), then so is the language  (as a set of contexts).  Consider next an
  expression of the form . This context language
  is a union of languages of the first (singleton) and third ( or ) types described in
  Proposition~\ref{prop:context-expression}.  The union is not a
  problem for a  word expression, since union distributes
  across concatenation.


















\section{Types in \texorpdfstring{}{Hbot}}
\label{sec:top-down}

\def\ordereq{\sim}
\def\order{\leq}

Recall that in Section~\ref{sec:induction-step}, we managed to find a
 forest expression for each set , assuming  was
outside . Our techniques failed for forest types , i.e.~forest types reachable from every other forest type.
In this section, we deal with these forest types.

In order to deal with the types from , we will have to do a different
induction, this time on context types.  This induction, stated in 
Proposition~\ref{prop:contexts}, is expressed in terms of an equivalence
relation .  Given a context type  and two forest
types , we write 

We extend this equivalence relation to context types, by

By abuse of notation, we also lift the equivalence relation 
to forests, considering two forests  equivalent when their forest
types are equivalent. It is this meaning that is used in the statement
below.
\begin{prop}\label{prop:contexts}
  For any context type , every equivalence class of forests under
   is forest language definable by a  forest
  expression.
\end{prop}

From Proposition~\ref{prop:contexts} we immediately obtain a
 forest expression for , as the equivalence class of
 containing , where .  Hence the proof of
Proposition~\ref{prop:contexts} ends the proof of
Proposition~\ref{prop:bottom-up}.  We note that the proof of
Proposition~\ref{prop:contexts} will be using the  forest
expressions  for types  that have been developed
in Section~\ref{sec:induction-step}. In particular if an equivalence
class of  is contained in , then it can easily
be defined by the disjunction of all the  forest expressions
corresponding to each type. The difficulty is to handle equivalence
classes that intersect .

The rest  of Section~\ref{sec:top-down} is devoted to proving Proposition~\ref{prop:contexts}.
The proof uses the following pre-order on context types. We say that a
context type  is a \emph{prefix} of a context type  if there exists a context type 
such that  (we also say that  is an \emph{extension} of
). We overload the use of
 and denote by  the equivalence relation induced by
the prefix pre-order, i.e.~ holds if  is both a prefix
and an extension of .
The proof of Proposition~\ref{prop:contexts} is by induction on the
position of 
 in the prefix pre-order,  starting with context types that have no
proper extension, and ending at the context type   that has no
proper prefix.

\subsection{ The induction base}
The base of the induction in the proof of Proposition~\ref{prop:contexts} is
when the context type  has no proper extension, i.e.~ holds for
all extensions  of . We will show that such a context type is necessarily
\emph{constant}, i.e.~ holds for all forest types .  This
gives the induction base, since for a constant context type , there is only one
equivalence class of , and this class is, by definition, the set of all
forests, which can be defined by a  forest expression (it is closed under pieces).

\begin{lem}\label{lemma:minimal-then-constant}
  A context type has no proper extension if and only if it is constant.
\end{lem}

The if direction is immediate: if a context type  is constant, then
 holds for all context types , and therefore  has no
proper extension. For the converse implication, as well as in the rest
of Section~\ref{sec:top-down}, we will use the notion of stabilizers
for context types:

When , we say that \emph{ stabilizes }.  As for
stabilizers of forest types (recall Lemma~\ref{lemma:closed-under-comp} and
Lemma~\ref{lemma:closed-under-piece}), the  identity implies that the
stabilizer  is a submonoid of  and it is closed under pieces.  The
following lemma implies Lemma~\ref{lemma:minimal-then-constant}, since its
assumptions are met by a context type without proper extensions.
Recall that
 is the equivalence class of  that contains all types reachable
from any other type.




\begin{lem}\label{lemma:at-least-one-disjoint}
  If both  and  intersect , then
  the context type  is constant.
\end{lem}
\proof
  First note that if some context type in 
  stabilizes , then all context types in 
  stabilize , likewise for . This is because the
  stabilizer is closed under pieces, and every type in  is
  a piece of every type in .

  
 Let , for some arbitrary enumeration  of . As we
  noted above, both  and  stabilize . Therefore,
  
  The context type  is constant,
  since any forest type  is a piece of , and therefore
  by~(\ref{eq:swallow}) we have
  
Hence the context type  is constant as it is equal to  for some context type .\qed


\subsection{The induction step}
We now proceed to the induction step in
Proposition~\ref{prop:contexts}.  Recall that our goal is to find a
 forest expression for every equivalence class of
. For a forest language , we denote by  the union
of equivalence classes of  that intersect , i.e.

We use a similar notation  for languages of contexts.  We say
that a forest language is a \emph{-overapproximation}
of a forest language  if it contains , but is contained in
. In other words, a -overapproximation may add forests to
, but it adds no new forest types, at least as far as the context
type  is concerned.  Note that a language may have several
-overapproximations.
\begin{prop}\label{prop:overapprox}
  For every , some -overapproximation of  can be
  defined by a  forest expression.
\end{prop}

\newcommand{\overap}[1]{\hat{#1}} The above result concludes
the proof of Proposition~\ref{prop:contexts}. To see this, consider an equivalence
class consisting of forest types . The set of
forests with a type in the class is by definition equal to
. By definition of -overapproximation this
set is also equal to  where  is any -overapproximation of . Hence it is definable by a
 forest expression by Proposition~\ref{prop:overapprox}.

The rest of this section is devoted to proving
Proposition~\ref{prop:overapprox}. 

When  is outside , then  itself, which is its own
-overapproximation, is definable by a  forest expression
by the results from the previous sections. The problem is when  is
in .  Because  has some proper extension, from
Lemma~\ref{lemma:at-least-one-disjoint} we know that at least one of   or  is disjoint with the stabilizer of . Without loss of generality we assume

In other words, if the type of a context stabilizes , then it is
possible that some tree to the left of the hole has a type in ,
however all trees to the right of the hole must have types outside .

In order to obtain a -overapproximation of  for  we
will use the following decomposition of forests with types in .



\begin{lem}\label{lemma:decomp}
  Any forest  of type in  has a decomposition   where  is a context whose type stabilizes , and   is a forest of type   in   that has one of the two forms below.
  \begin{enumerate}[\em(1)]
\item\label{item:decomp2bis}  with  the type of the forest  outside ; or
	\item\label{item:decomp2}  with  the type of the context  not stabilizing
	    ; or
	\item\label{item:decomp3bis}  with the types of the forests  outside ; or
\item\label{item:decomp3}   and \begin{enumerate}[]
	\item if  has  type in , then the type of   does not stabilize .
		\item if  has  type in , then the type of   does not stabilize .
\end{enumerate}
  \end{enumerate}
\end{lem}
\begin{proof}
Consider the set  of all possible pairs  such that , the type of  preserves  and the type of  is in .  Take a pair  that is maximal in the following sense: if  is a nonempty context, then  has no pair with  on the first coordinate. 


Suppose  is a tree of the form .  If  has a type outside
, we get item~(\ref{item:decomp2bis}). If  has type in
, then by maximality, the context type of  does not stabilize ,
and therefore  has a type that does not stabilize , so we get
item~(\ref{item:decomp2}).

Suppose    is a forest of at least two trees.
Consider any partition of  into two nonempty forests .
If both   have type outside , then we get item~(\ref{item:decomp3bis}). Otherwise, we get case~(\ref{item:decomp3}) by maximality of .
\end{proof}


From Lemma~\ref{lemma:decomp}, we have for :

where  stands for the set of all forests  that have type  and that
satisfy one of the conditions~(\ref{item:decomp2bis})-(\ref{item:decomp3}) of
Lemma~\ref{lemma:decomp}.
To get the -overapproximation of  we will use
-overapproximations for the smaller expressions above, as stated by the
following two lemmas. The first lemma is concerned with languages of the form .

\begin{lem}\label{lemma:y-approx}
  For every , some -overapproximation  of  can be
  defined by a  forest expression.
\end{lem}

For the second lemma, concerning , we need a more careful
statement. The overapproximation that we give is not really an
overapproximation of , but it is an overapproximation that works
as long as a forest of type in  is inserted into the hole.
\begin{lem}\label{lemma:k-approx}
  For any , one can define a  context
  expression  such that for any forest  of type in
  ,  is a -overapproximation of .
\end{lem}


These two lemmas are proved in Sections~\ref{sec:proof-lemma-y}
and~\ref{sec:proof-lemma-k}, respectively. First we show how they
complete the proof of Proposition~\ref{prop:overapprox}. We write  for the
set of all forests with a type in . We claim that the  following
language

is a -overapproximation of . 

The first property required from a -overapproximation, , is immediate. For the second part, , we need a bit more effort. We show a stronger result, namely that for
any  and  as in the summation above, we have

This completes the proof of , since
 distributes across union.  To prove the above, we apply the
properties of   and  to get

To complete the proof, we would like to replace  by  in
the last expression above. This can be done thanks to the following
easily verifiable consequence of the fact that  is a congruence for
forest algebras.
\begin{fact}
 For any set of contexts  and set of languages , we have
 .
\end{fact}

Thanks to Lemmas~\ref{lemma:k-approx} and~\ref{lemma:y-approx}, the
only thing keeping  from being defined by a 
forest expression is  the language . We deal with this
language in the following lemma.

\begin{lem}
 The language     is definable by a
  forest expression.
\end{lem}
\begin{proof}
  A subforest of  is a forest  such that  for some context
  .  Take a forest  and consider a subforest
   of  that is in , but has no proper subforests in
  .  Then either  is a tree  with , or  with . Therefore, a
  forest is in   if and only if it has a subforest in
  
  Containing such a subforest can be expressed by a  forest
  expression, by prefixing the set above with the set of all contexts.
  The expressions for  and  are 
  forest expressions by the results from the section on types outside .
\end{proof}

\subsubsection{Proof of Lemma~\ref{lemma:k-approx}}
\label{sec:proof-lemma-k}
Our goal in this section is to prove Lemma~\ref{lemma:k-approx}, which
says that for any context type  stabilizing , there is a
 context expression  such that for any forest
 with a type in ,  is a
-overapproximation of .

We apply Proposition~\ref{prop:context-expression} to get an
expression for the context language  of the form
 The problem with the expression above is that it may use,
in some of the subexpressions , languages
 or   that involve  forest types , and we do not know
how to describe types in . This is where the
overapproximation comes in. We show that if the languages for types in
 are overapproximated, then the result satisfies the
properties required by Lemma~\ref{lemma:k-approx}. A more detailed
argument is described below.

We say a context language  satisfies (*) if it has the property
required from  by Lemma~\ref{lemma:k-approx}, namely
\begin{quote}
	(*) there
	is a  context expression  such that for any
	forest  with a type in , the language  is a
	-overapproximation of .	
\end{quote}
  It is not difficult to see that
property (*) is preserved by unions and compositions of context
languages. In particular, in order to prove
Lemma~\ref{lemma:k-approx}, it suffices to show (*) is satisfied by
all languages  that appear in~(\ref{eq:ku-decomp}).

The only problem with the overapproximation is when  is of
the form  or , for . In all
the other cases,  is known to be definable by a 
context expression, and no overapproximation is needed. Note that
by~(\ref{eq:assumption-left}), the expressions  cannot be
used, since a forest type from  cannot appear to the right
of the hole in a context type that stabilizes . Therefore, to complete
the proof of Lemma~\ref{lemma:k-approx}, it remains to show that for
any , the context language  satisfies
(*).

In the following, we use an equivalence relation . This is defined
to be the intersection of all equivalence relations , for context
types  that do not stabilize  (and hence  is a strict prefix of ).
For a forest language , we write

By the induction assumption in Proposition~\ref{prop:contexts}, each
equivalence class of  is definable by a  forest
expression and therefore so is each language , as a union of
equivalence classes of . We will show that, for any , the context language  satisfies (*) with
.  Assume that the type of  is
 in . Then we have:

The first inequality is clear. For the second inequality, we need to
show that 

This inclusion holds because we have:

In the second equality, we used the definition of  and the
assumption that  does not stabilize . The latter
follows from assumption~(\ref{eq:assumption-left}) since the type of
 is in .

\subsubsection{Proof of Lemma~\ref{lemma:y-approx}}
\label{sec:proof-lemma-y}
In this section, we show that for every type ,
a -overapproximation of  can be defined by a  forest
expression. Recall that the language  was defined based on a case
distinction in Lemma~\ref{lemma:decomp}, and therefore it can be decomposed into a union of four languages, one for each of the four cases in the lemma.  As
-overapproximations are closed under union, for each of these
languages, we provide a -overapproximation defined by a 
forest expression.



For the languages corresponding to cases (\ref{item:decomp2bis}) and (\ref{item:decomp3bis}), we use the assumption that  can be defined by a  expression for every type . The interesting cases are (\ref{item:decomp2}) and~(\ref{item:decomp3}).


The language corresponding to  case (\ref{item:decomp2}) is a union of forest languages of the form

ranging over letters  such that   does not stabilize
   ,  and forest types  with . We treat each language  separately.

It may be the case that  belongs to  and therefore we
have no  forest expression for . However, we can
use overapproximation.  As  does not stabilize , we can apply
the induction assumption in Proposition~\ref{prop:contexts} and obtain
a  forest expression for .  But then the
 forest expression   is
a -overapproximation of . It clearly contain  so
it remains to show that it is included in . To see this consider a forest  of type  and an arbitrary . As  does not stabilize
,  does not stabilize . Hence by the choice of  we have
 and  is in .






It remains to consider the case of  (\ref{item:decomp3}),
where have a union of sets

ranging over  that satisfy the two implications in item (\ref{item:decomp3}) of  Lemma~\ref{lemma:decomp}. We do each pair  separately. 
We consider three subcases.


The first subcase is when .
Therefore we have a  forest expression for . In
this case we claim that

is a -overapproximation of of .  The first
requirement of  -overapproximation, 

is immediate. For the other requirement, we need to show that for any
forests  and , the type of
 is -equivalent to .  From , we know that the type of  is , but all we know
about  is that its type  satisfies . Consider an arbitrary . Since  does not stabilize
, we also have  does not stabilize . Hence from  we get .

The second subcase, when , is treated as above by symmetry.

The third subcase is when both  and  are in .
As a consequence of  and the second condition of item~(\ref{item:decomp3}) in Lemma~\ref{lemma:decomp} is that

We claim that a -overapproximation of  is 

As before, the problem boils down to showing that for any forests 

the types  of  and  of  satisfy . In other words, we need to show that for an arbitrary  

Since , then by~(\ref{eq:case-with-intersection}) the context
type  does not stabilize  and therefore the same holds for
. Hence, we can use the assumption on 
to infer

In a similar way, we use , the
assumption~(\ref{eq:assumption-left}), and , to
complete the proof of this case, and of  Lemma~\ref{lemma:y-approx}.



\section{No lexicographic order }\label{sec:nolex}
In this section, we consider the logic \Dtwo where only the descendant
order, and not the lexicographic order, is available. We give an
effective characterization in the following theorem.
\begin{thm}[Effective characterization of  with  the descendant
order only]\label{thm:main-commutative}\ \\
 A forest language is definable in \Dtwo if and only if its syntactic
  forest algebra satisfies the  identity, as well as
  horizontal commutativity:

\end{thm}





The ``only if'' implication is easy: we have already shown that the 
identity must hold in the syntactic forest algebra of a language definable in
\Dtwol, and \Dtwo is a fragment of \Dtwol. Horizontal commutativity must
also hold: the logic only has the descendant relation, and therefore its
formulas are invariant under rearranging sibling subtrees.

The ``if'' implication is a minor variation on the work done in the
previous sections.  Recall that we proved before that if the syntactic
forest algebra of a language  satisfies the  identity,
then both  and its complement can be defined by  forest
expressions. We apply this result also in our case. The problem is
that the  forest expressions are not commutative, and thus
need not be definable in \Stwo.  We will show, however, that their
commutative closure can be defined in \Stwo. Here, we use the term
\emph{commutative closure of } for the smallest language that
contains  and is closed under rearranging sibling subtrees.


\begin{prop}
  The commutative closure of a  forest expression is
  definable in \Stwo.
\end{prop}
Before we prove this proposition, we remark that this is not a
completely generic result. For instance consider the following language over a one letter alphabet: ``Each node is a
leaf or has two children, and some leaf has an even number of
ancestors''. This language is definable in  and is horizontally
commutative (the formula comes from Potthoff~\cite{potthoff}). However, this language cannot be defined in . Actually,   an Ehrenfeucht-Fraiss\'e argument shows that every   first-order formula, that has  quantifier depth   and only uses the
descendant order, will give the same result for all balanced binary trees of depths larger than .


The proof of the above proposition is by induction on the size of the
 forest expression. 

The base case is when the   expression is either , or a language that is closed under pieces. In the first
case, the language is clearly definable in \Stwo. In the second case,
we revisit the proof of Lemma~\ref{lem:pi1-lemma}, which showed that a
language  that is closed under pieces is definable in . If
we take the commutative closure of , we get a commutative language closed
under pieces. In the proof of Lemma~\ref{lem:pi1-lemma}, we
constructed the  formula by  forbidding a finite number of
pieces; in the commutative case the formula does not need to worry
about the order of siblings in the forbidden pieces.

In the induction step, we have to consider the operations that are
allowed by  expressions: union, intersection, (horizontal)
concatenation

and (vertical) composition

for a forest languages  and context languages . Union and intersection are easy. Concatenation and composition are more problematic. Actually, 
 is not closed under these two operations. For instance, the
languages

are both definable in , but their concatenation

is not, since it does not contain the forest . 

Nevertheless, if we use commutative closure, the problem disappears. That
is, we will show that if the languages  are definable in
\Stwo, then the commutative closure of each of the languages
in~(\ref{eq:concat}) and~(\ref{eq:compos}) can be defined in \Stwo.
We only do the cases  and , the language  is 
done the same way.


\begin{lem}\label{oplus-forests}
  If forest languages  are definable in \Stwo,  then so is the
  commutative closure of .
\end{lem}
\begin{proof}
We write  for the commutative closure of .


Consider first the case when  is a \emph{tree} language definable in
\Stwo. In this case, the formula for  formula places an
existentially quantified variable over the root of one tree, and then
relativizes the formulas for  and , respectively, to the nodes
the are not descendants (respectively, are descendants), of this
existentially quantified root.

For the general case, we use the following lemma on forest languages definable in .
\begin{lem}\label{lem:experimental}
	Every forest language  definable in  can be written
	as a finite union of languages , where
	 is a forest language definable in , and   are tree
	languages definable in \Stwo.
\end{lem}
\begin{proof}
	The statement of the lemma immediately follows from the following claim on formulas of . We claim that any formula    of  is equivalent to a finite disjunction of formulas of the form
	
	where  ,  and  are formulas such that
	\begin{enumerate}[]
		\item Each formula  has all  quantification  relativized to descendants of .
		\item The formula  has all quantification relativized to nodes that are not descendants of any of the nodes .
	\end{enumerate}
	The idea, of course, is that the  describe the roots of the trees
        that contain the existentially quantified nodes  in the
        original formula  of . The straightforward proof of the
        claim is omitted. The finite disjunction ranges over all possible
        repartitions of the nodes  into distinct trees.
\end{proof}



From this normal form, since  distributes across union, it
suffices to give a \Stwo formula for languages of the form
  
  where the  languages are tree languages definable in \Stwo and where
   are forest languages definable in . By the technique
  shown at the beginning of the proof, it is sufficient to obtain a formula for
  . But the language  is closed under pieces,
  and therefore it is definable in .
\end{proof}

\begin{lem}
  If context languages  are definable in \Stwo,  then so is the
  commutative closure of .
\end{lem}
\begin{proof} 
We write  for the commutative closure of .

Consider first the case when either  or  is a language . The formula places a variable on node corresponding to , and relativizes the formula for the remaining context language
to the remaining nodes. 

Consider now the general case. Again, we use a normal form lemma for languages definable in .  This lemma is prove the same way as Lemma~\ref{lem:experimental}.
\begin{lem}\label{lem:experimental2}
	Every context language  definable in  can be  written as  a finite union
	of languages of the kinds
	
	where  and  are context language and forest languages definable in
	\Stwo.	
\end{lem}


We now use Lemma~\ref{lem:experimental2} to finish the proof of Lemma~\ref{lem:experimental2}. We want to show that  is definable in . We apply Lemma~\ref{lem:experimental2} to the languages  and .
Since the operation  distributes across union, we can assume
that  the unions describing  and  use just one language, of either of the two kinds. We have four cases to consider, we only do the most difficult
one

This language is the same as 

Let  be the \Stwo formula defining the context language , 
obtained from the first case considered in the proof.  Let  be the \Stwo formula
defining  obtained in the same way. Both of these formulas have a free variable, which describes the hole of the context. Using
Lemma~\ref{oplus-forests} we also have a \Stwo formula 
defining .


The desired \Stwo formula puts an existentially quantified variable  on the
node corresponding to , another existentially quantified
variable  on the node corresponding to , and then runs
three subformulas, for , , and , on the remaining nodes, appropriately relativizing the quantification. More specifically, this is the formula

where  is the  formula stating that  is a proper ancestor of  and there are no nodes in between,  is constructed from  by relativizing
all quantification to the ancestors of ,  is constructed from  by relativizing
all quantification to the descendants of , and  is
constructed from  by relativizing all quantification to the
nodes that are neither ancestor of  nor descendant of .
\end{proof}





\newcommand{\ign}[1]{}
\ign{
We now want to show Proposition~\ref{prop:bottom-up} in the case where
 is commutative. For this we need to find for each type  a \Stwo
formula for the language  of forests of type .  We revisit the
proof of Proposition~\ref{prop:bottom-up} for \Stwol presented in the
previous sections for the non commutative case and adapt it to the
case of \Stwo.  The structure of the proof is the same, it goes by
induction on the size of the algebra  and then on the position
of  in the reachability pre-order define earlier. Again we have to
distinguish the case where  is minimal from the other cases. As the
algebra still satisfies the identity~(\ref{eq:swallow}) all the
properties that were obtained as a consequence of this identities
remain valid. In particular
Lemmas~\ref{lemma:closed-under-comp},~\ref{lemma:closed-under-piece},~\ref{lem:sub-forest-algebra}
and the results of Section~\ref{sec:treat-cont-like-words} remain
true.  However we are now limited to the composition properties stated
in Lemma~\ref{fact:simple}, and not the more powerful ones stated in
Lemma~\ref{fact:simple-lex}.  


\subsection{Non minimal types}
\label{sec:induction-step-nolex}

Let  be a non minimal type. We distinguish again two cases depending on whether
 or not.

\subsubsection{}
\label{sec:h-preserves-itself-nolex}

Let  be the set of pieces of
. Lemmas~\ref{lem:sub-forest-algebra}
and~\ref{lemma:closed-under-piece} remain true, so  is a
strict sub-algebra of  and we obtain by induction a \Stwo
formula for .

\subsubsection{}
\label{sec:h-does-not-preserve-itself-nolex}

Recall that for , we write  for the set of contexts of type 
and  that for , we write  for the set of forests of type . For 
and , we write  for the set of forests  of type 
that can be decomposed as , with each  a tree with of
type in .

Let  be the set of forest types  such that  is reachable from
 but not vice-versa.  By induction assumption, each language 
with  is definable in \Stwo. Our goal is to give a
formula for .

\begin{lem}\label{lem:decompo-nonminim-nolex}
A forest has type  if and only if it belongs to  or a
language , with  and  stabilizing .
\end{lem}
\vspace{-.2cm}
\begin{proof}
  Let  be a forest of type , and choose  a subtree of  that has a
  type equivalent to , but no subtree with a type equivalent to . If such
   does not exist, then  belongs to  as a concatenation of trees
  with type in .  By minimality,  must belong to  for some . Let  be the context such that .  Since the type of  is
  equivalent to , and the type of  is , then the of  must
  stabilize ,  and therefore also stabilize  by
  Lemma~\ref{lemma:closed-under-comp}.
\end{proof}

In Lemmas~\ref{lemma:sigma2-forest} and \ref{lemma:cont-def}, we will
show that the languages  and  above can be defined in
\Stwo. Proposition~\ref{prop:bottom-up} then follows by closure of \Stwo
under finite union and Lemma~\ref{fact:simple}.
To be more precise, we only give an approximation
 of the language , however all forests in the
approximation have type , which is all we need.

As in Section~\ref{sec:h-does-not-preserve-itself}, the fact that  can be
expressed in \Stwo is a consequence of
Proposition~\ref{prop:context-expression-nolex}.

\begin{lem}\label{lemma:cont-def}
 If     stabilizes  then the context language  is definable in \Stwo.
\end{lem}
\begin{proof}
  From Proposition~\ref{prop:context-expression-nolex} and its proof,
  we know that  can be defined by a finite union of expressions
  of the form  where each  is either
  definable in \Stwo, or of the form  for some type , or of the form  where  is the
  infinite alphabet of letters of the form  or ,
  for  a tree and  and  a subset of  closed under
  pieces. In this later case we know that  is definable in
  .
 
  We are looking for a \Stwo formula for . By closure under union of \Stwo
  and item 3 of Lemma~\ref{fact:simple} it is sufficient to obtain a \Stwo
  formula for any expression of the form  where each 
  is either  for some type  or of the form .

  Consider an expression
  
 Split  the contexts that form the  letters in 
  into two  parts: the set   of  those contexts of the
  form  and the set   of contexts of the form
  or . If we set  to be  and likewise for , we can decompose  as 
  
 As context
  languages included in  can be used for composition by item 3 of
  Lemma~\ref{fact:simple}, it remains to show that context languages of the form
  
 are
  definable in \Stwo, where .


  Consider one of the tree language . Since ,  and . But  is not reachable from  because
  otherwise, as  is closed under pieces,  would be in
   and that would contradict . Hence by the induction
  assumption from Proposition~\ref{prop:bottom-up},  is definable in
  \Stwo.

  Now the \Stwo formula for  guesses the roots of the trees in  and verify that any other tree belongs to  . The former property is in \Stwo by the remark above and the
  latter can be shown to be in  as in the proof of Lemma~\ref{lem:pi1}.
\end{proof}

We now construct a \Stwo formula approximating .

\begin{lem}\label{lemma:sigma2-forest}
  For any type , there is a formula   of 
  \Stwo such that:
\begin{itemize}
  \item Any forest   satisfies  and,
\item any forest satisfying  has type .
\end{itemize}
\end{lem}
\vspace{-.2cm}
\begin{proof}
  The proof of the lemma is in two steps.  In the first step, we
introduce a condition (*) on a forest , and show that: a) any
forest in  satisfies (*); and b) any forest satisfying (*) has
type . Then we will show that condition (*) can be expressed in
\Stwo. Recall that we are now dealing with an algebra such that .


 \begin{quote}
(*) For some , the forest  can be decomposed, modulo
    commutativity, as the concatenation  of trees
    , with types , such that
  \begin{enumerate}
\item .
\item Each type from  is represented at most  times in
.
  \item If a tree  is a piece of , then
     holds for some type  that occurs
     times in the sequence .
  \end{enumerate}
  \end{quote}

We first show that condition (*) is necessary. Let  be
all the trees in a forest , and let  be
the types of these trees.  Without loss of generality, we may assume
that trees are ordered so that for some , each type of  with
 already appears  times in . It is not hard to see that identity~(\ref{eq:swallow}) implies aperiodicity of the monoid , i.e.~
 
In particular, it follows that  since all of
 are swallowed by the above. It remains to show
item 3 of condition (*). Let then  be the piece of a tree 
with . We get the desired result since the type of  already
appears in .

We now show that condition (*) implies . Let then  and  be as in (*). We will show that for any , we have , which shows that the type of  is . By
item 3,  holds for some some type  that occurs
 times in the sequence . By~(\ref{eq:aperio}),
we have . It therefore remains to show
that :

In the above we have used identity~(\ref{eq:swallow}). Note that the
requirement in~(\ref{eq:swallow}) was satisfied, since  implies .


It now remains to show that forests satisfying condition (*) can be defined in
\Stwo. Note that  cannot exceed , and therefore there
is a finite number of cases to consider for . Fix some sequence
.  The only nontrivial part is to provide a \Stwo formula
that describes the set of forests  that satisfy item 3
of condition (*). From this construction, the formula for (*) follows by
closure of \Stwo under finite union and  (recall
Fact~\ref{fact:simple}), as well as the assumption that each type in  can be
defined in \Stwo.

In order to define forests as in item 3 we use a  formula that forbids
the appearance of certain pieces of bounded size inside . Let  be the types in  that appear at least 
times. We claim that a sequence of trees  satisfies item 3
if and only if it satisfies item 3 with respect to pieces  that have at most
 nodes. The latter property can be expressed by a  formula.
The reason for this is that, thanks to a pumping argument, any tree has a piece
that has the same type, but at most  nodes.\luc{do we need more
  details for the pumping argument?}
\end{proof}

\subsection{Minimal types}

It remains to compute a \Stwo formula for  where  is a minimal type.
As in Section~\ref{sec:top-down} this is done using another induction on
contexts, using the same pre-order as in Section~\ref{sec:top-down}, and taking
 in the proposition below. In the remaining part of this section we
denote by  the set of minimal types of  and by  the set of non minimal
types of .

\begin{prop}\label{prop:contexts-nolex}
  For any context \hhl{type} , every equivalence class of  is definable in
  \Stwo.
\end{prop}

The rest of this section is devoted to prove this proposition. We first prove
the base case and then move to the induction step. Note that the structure of
the proof is the same as for Section~\ref{sec:top-down} but this proof has to
be modified in order to use weaker compositions properties.

\subsubsection{ The induction base}

The base case is when  is minimal. In this case the context \hhl{type}  is constant
and hence  is easily definable in \Stwo.  The fact that  minimal
implies  constant is a simple consequence of the following lemma, itself a
consequence of commutativity of  and
Lemma~\ref{lemma:at-least-one-disjoint}.

\begin{lem}\label{lemma:at-least-one-disjoint-nolex}
  If  intersect , then the context \hhl{type}  is constant.  
\end{lem}

\subsubsection{The induction step}

We now proceed to the induction step, and assume that  is not
minimal. As previously let  be the set of minimal types. Recall that 
denotes the forests of type . We write  the trees of type .

As in Section~\ref{sec:top-down}, Proposition~\ref{prop:contexts-nolex} follows
from the following Proposition.

\begin{prop}\label{prop:overapprox-nolex}
 For every , some -overapproximation of  is definable in \Stwo.
\end{prop}

As before, this proposition is simple for  not minimal as no
overapproximation is needed in this case. We therefore only consider the case
where  is minimal. In this case as we can only use Lemma~\ref{fact:simple}
for composing languages we need to decompose minimal forests in a more precise
way then what we did in Lemma~\ref{lemma:decomp}.

\begin{lem}\label{lemma:decomp-context-nolex}
Any forest of minimal type satisfies one of the two cases below:

\noindent
In the first case, the forest is of the form  where  and either
\begin{enumerate}
 \item [(i)] 
 \item [(ii)] the type of  is not in ,
 \item [(iii)]  where  is a \emph{tree} of type  and  not minimal or,
 \item [(iv)]  where  is a tree of minimal type and  is a forest
   of minimal type.
\end{enumerate}

\noindent
In the second case, it is a forest  verifying item (iii) and (iv) above.
\end{lem}
\begin{proof}
  Let  be a forest of minimal type. From Lemma~\ref{lemma:decomp} we know
  that  is of the form  with  and  in one of the forms
  (1)-(4) mentioned in this lemma. If (1) or (2) hold,  with  or
   and correspond to items (i) and (ii) above. It (3) holds
   with the type of  being  and  not
  minimal. Therefore the first tree of  has a type satisfying condition
  (iii) of the lemma. If this tree has no parent in  we are in the second
  case item (iii) of the lemma, otherwise we are in the first case item (iii).
  Otherwise (4) hold and  where both have minimal types. Therefore
  (iv) holds and depending on whether  has a parent in  we are in the
  first or second case of the lemma.
\end{proof}

From Lemma~\ref{lemma:decomp-context-nolex} we have:



where  is the set of forests of type  verifying conditions (iii) and
(iv) of Lemma~\ref{lemma:decomp-context-nolex}.

\noindent
Because  is of the form  for some  and , it follows
immediately from the proof of Lemma~\ref{lemma:y-approx} that there exists a
-overapproximation  of  that is definable in \Stwo. By
induction we also have a -overapproximation  of  for any
 such that . From Lemma~\ref{lemma:proper-stabilizer}
below we know that  is definable in \Stwo. By putting all this together
this immediately yield a -overapproximation of  that is definable in
\Stwo by Lemma~\ref{fact:simple}.

\begin{lem}  \label{lemma:proper-stabilizer}
If , then  is definable in .
\end{lem}
\begin{proof}
  The proof is the same as for Lemma~\ref{lemma:cont-def}.
  Recall that from Proposition~\ref{prop:context-expression-nolex} we can decompose
   as a finite union of expressions of the form  where each  is either of the form , or  for some type , or is definable in .

  We show that because  is not minimal then the blocks  must be
  such that  is not minimal, and hence  is definable in \Stwo by
  induction on Proposition~\ref{prop:bottom-up}. Once this is done the rest of
  the proof is copied from the proof of Lemma~\ref{lemma:cont-def}.

  Assume to the contrary that  with  minimal. As  then  is in . From
  Lemma~\ref{lemma:at-least-one-disjoint-nolex} this implies that  is
  minimal.
\end{proof}
}

\section{Discussion}
\label{sec:conclusion}
In this paper we considered a signature with the descendant and
lexicographic orders. It would be interesting to know what happens in
the presence of other predicates such as the closest common ancestor,
next sibling or child.

Probably the most natural continuation of this work would be an
effective characterization of \Stwo or \Stwol. Note that this would
strengthen our result: a language  is definable in  if
and only if both  and its complement are definable
in~. We conjecture that, as in the case for
words~\cite{arfi91}, the characterization of \Stwol requires replacing
the equivalence in the  identity by a one-sided implication,
which says that a language definable in \Stwol is closed under
replacing  by , for .





\begin{thebibliography}{10}
\bibitem{arfi91}
M.~Arfi.
\newblock Op{\'e}rations polynomiales et hi{\'e}rarchies de concat{\'e}nation.
\newblock {\em Theor. Comput. Sci.}, 91(1):71--84, 1991.

\bibitem{segoufinfo}
M.~Benedikt and L.~Segoufin.
\newblock {Regular tree languages definable in FO and in FO+mod}.
\newblock To appear in {\em ACM Transactions on Computational Logic
  (TOCL)}. 2009.



\bibitem{fo2tree}
M.~Boja\'nczyk.
\newblock Two-way unary temporal logic over trees.
\newblock In {\em Logic in Computer Science}, pages 121--130, 2007.

\bibitem{forestexp}
M.~Boja\'nczyk.
\newblock Forest expressions.
\newblock In {\em Computer Science Logic}, volume 4646 of {\em Lecture Notes in
  Computer Science}, pages 146--160, 2007.

\bibitem{efextcs}
M.~Boja\'nczyk and I.~Walukiewicz.
\newblock Characterizing {EF} and {EX} tree logics.
\newblock {\em Theoretical Computer Science}, 358(2-3):255--273, 2006.

\bibitem{forestalgebra}
M.~Boja\'nczyk and I.~Walukiewicz.
\newblock Forest algebras.
\newblock In {\em Automata and Logic: History and Perspectives}, pages 107 --
  132. Amsterdam University Press, 2007.

\bibitem{simontrees}
M.~Boja\'nczyk,  L.~Segoufin, and H.~Straubing.
\newblock Piecewise testable tree languages.
\newblock In {\em Logic in Computer Science}, 2008

\bibitem{EVW02}
K.~Etessami, M.~Y. Vardi, and T.~Wilke.
\newblock First-order logic with two variables and unary temporal logic.
\newblock {\em Inf. Comput.}, 179(2):279--295, 2002.


\bibitem{mcnaughton}
R.~McNaughton and S.~Papert.
\newblock {\em Counter-Free Automata}.
\newblock MIT Press, 1971.

\bibitem{pin-survey}
J.-\'E. Pin.
\newblock Logic, semigroups and automata on words.
\newblock {\em Annals of Mathematics and Artificial Intelligence}, 16:343--384,
  1996.

\bibitem{weilpinpoly}
J.-\'E. Pin and P.~Weil.
\newblock Polynomial closure and unambiguous product.
\newblock {\em Theory Comput.~Systems}, 30:1--30, 1997.

\bibitem{potthoff}
A.~Potthoff
\newblock First-order logic on finite trees.
\newblock In {\em TAPSOFT}, volume 915 of {\em Lecture Notes in
  Computer Science}, pages 125--139, 1995.


\bibitem{schutzenberger}
M.~P. Sch\"utzenberger.
\newblock On finite monoids having only trivial subgroups.
\newblock {\em Information and Control}, 8:190--194, 1965.

\bibitem{turtle}
T.~Schwentick, D.~Th\'erien, and H.~Vollmer.
\newblock Partially-ordered two-way automata: A new characterization of DA.
\newblock In {\em Devel. in Language Theory}, pages 239--250, 2001.

\bibitem{simonpiecewise}
I.~Simon.
\newblock Piecewise testable events.
\newblock In {\em Automata Theory and Formal Languages}, pages 214--222, 1975.

\bibitem{therienwilkefo2}
D.~Th\'erien and T.~Wilke.
\newblock Over words, two variables are as powerful as one quantifier
  alternation.
\newblock In {\em STOC}, pages 256--263,
  1998.

\bibitem{wilke}
T.~Wilke.
\newblock Classifying discrete temporal properties.
\newblock In {\em Symposium on Theoretical Aspects of Computer Science}, volume
  1563 of {\em Lecture Notes in Computer Science}, pages 32--46, 1999.

\end{thebibliography}



\end{document}
