\def\labelitemii{}
\newcommand{\next}{N}
\newcommand{\nextstate}{{\mbox{\rm Nustate}}}


In a
`cut and paste' method, given an input string ,
one replaces a substring  of  with another
string , so  is changed to a string .
Given that the crossing sequences around  and 
are compatible, the computations on  and  should be similar.


We consider partial computations of ,
where  is a 1-tape Turing machine.
By `partial' is meant that they begin at initial configurations
but do not necessarily end in halting computations.
Associated with every partial computation
is the list of crossing sequences generated by
the computation.

Recall that a crossing sequence is a sequence of the form
 where  is a single bit
and  are states of .  The leading bit
is always given, but if  then the sequence is considered empty.

In this section we assume that the squares are indexed
so the first square scanned has index .

\numpara
\label{par: alternating list}
Given an input string ,
there is a unique computation (possibly infinite) on input .
Suppose the initial tape contents are presented as
, where 
and  and ;
the other  are blank.
Assume that in any partial computation under consideration,
only squares indexed between  and  are
scanned, perhaps not all of them.

\numpara
\label{par: specification}
Now suppose that we are given an alternating list
of crossing sequences  and symbols ,
 where
the leading bit in  is  if  and  if ,
and the input string  is .

Also, those  such that  is nonempty
form a contiguous (possibly empty) interval,
and  and  are empty, with leading
bits  and  respectively.

\numpara
\label{par: full verification}
{\bf Full verification.}
Given this data, it is easy to trace the computation
on input  and produce a sequence of sextuples
 giving the square scanned
and the quintuple applied at the first, second, \ldots steps.
At the same time the procedure can check the state  against
the relevant crossing sequence ( is not checked).

This can be done by maintaining
the index of the current square, the current state,
and arrays  and .
The array  gives the current tape contents, and
 gives the number of states currently cancelled from
. The procedure is simple and we omit the details.

The procedure should continue until either

\begin{itemize}
\item
it reaches a halting configuration,
\item
it attempts to check  against a state in some 
where  has reached the height of , meaning
that all states in  have been `cancelled,' or
\item
it checks  against a state in some  and
discovers a mismatch.
\end{itemize}

In the first two cases, if all states in all the 
have been cancelled, it reports `consistent,' else
it reports `inconsistent.'  In the third case, it
reports `inconsistent.'

\numpara
\label{par: local verification}
{\bf Local verification.}
Next let us fix some , and consider
how this procedure affects the -th square: the relevant
data and variables are
  Let us
suppose, omitting some simple variants,
that , so the square is first entered
from the left.  When the square is first entered,
 has just been cancelled from   and ,
and a quintuple  applies, say.
 , and the next square scanned is 
depending on :  is cancelled from  or 
as appropriate, and the next time the square is entered,
 is taken from  or .  The procedure
continues until there is a mismatch
or it attempts to check  against  or 
when all of it has already been cancelled.  At this
point, if there is a mismatch, or not both these
crossing sequences have been fully cancelled, it reports
`inconsistent,' else it reports `consistent.'  Let
us call this procedure a {\em local verification} at the
-th square.

\begin{definition}
\label{def: consecutive triple}
\label{def: compatible}
Given the data (\ref{given data}), i.e.,
 a {\em consecutive triple} is a triple
 where .

The consecutive triple
 is
{\em compatible} if the local verification at the -th square
reports `consistent.'
\end{definition}

\begin{theorem}
\label{thm: nasc for consistency}
The data (\ref{given data}) is consistent with
a partial computation on input  if and only
if for each  between  and  the consecutive triple
 is compatible.  In this case
the local verification at  also computes the
contents of the -th square at the end of the
partial computation, and identifies the unique square
at which the partial computation ends.
\end{theorem}

{\bf Proof.}
If the data in (\ref{given data}) is consistent
with a partial computation on input ,  the local
verification at every square will have the same effect as
the full verification and report `consistent,'
so  are compatible
and the final value of  will be the same as
in the full verification.

Granted that the data is consistent, the
unique -th square at which the partial computation
ends is easily determined from 
by checking the final head-movement across
the st and th crossing points.

Otherwise, the full verification would
report inconsistency.  Suppose it terminates
at the -th square.
Up to this point, its actions at the -th square
are the same as the local verification procedure on that square, so the local
verification at  will terminate and report inconsistency for
the same reason, and  are incompatible.
{\bf Q.E.D.}\medskip


The Jurdzi\'nski-Lory\'s proof uses a kind of pumping lemma
and a kind of splicing lemma.  The pumping lemma is

\begin{corollary}
\label{cor: pumping}
{\bf (Pumping Lemma).}
Suppose that  is an input string and 
where  and in some partial
computation on input , the -crossing
sequence equals the -crossing sequence.
Explicitly, suppose the data

describes a
partial computation on input . Write
 and .
Let .

Then   and  are the - and -crossing
sequences respectively, and
 is
produced by a partial computation on input .

Furthermore, if  are the tape contents
at the end of the first partial computation, then
 are the
contents at the end of the second.
\end{corollary}

{\bf Proof.}  From Theorem \ref{thm: nasc for consistency},
all triples  from the list in Equation
(\ref{eq: pumping data 1}) are compatible.  Since
, the same goes for the list in Equation
(\ref{eq: pumping data 2}), so they are produced by
a partial computation on input .  The remark about
the final tape contents also holds because they
can be calculated by the local verification. {\bf Q.E.D.}\medskip

The other cut-and-paste result is restricted to
our reduction machine .
Recall
(Paragraph \ref{par: hom h})
that  is a homomorphism which erases blank symbols,
and a blank symbol may differ from the specific
blank .

\begin{definition}
\label{def: residue}
Let  be a reduction machine
with initial redex   = uvwTc_1u,vwc_2uv,wzTz|u|+1|uv|TTv=\alpha\beta\beta\ell = |h(\alpha)| + 1\ell=0qT(u,v,w)Tv|v|q\ellx_1x_2T_1T_2\lambda, \cent t_1 x_1 t_2 \-residue
at time  and the
the ,\lambda T_2x_1x_2\tmx_1x_2T_1T_2\tmuvwu'v'w'tt'vv'uvwuv'w\tm |v|, c_1, h(z), c_2, \ell, q x = a_1\ldots a_nv = a_i \ldots a_jx' = b_1\ldots b_{n'}v' = b_{i'} \ldots b_{j'}c_i = c'_{i'}c_j = c'_{j'}x' = uv'wx'vv'vv'\ell=0vv'*(\lambda,\cent t_1 uv'wt_2\-residue
is the same as the , \lambda)uvwuv'wzz'vv'\ell>0kk'vv'z\alpha\beta|\alpha|=kz\alpha'\beta'|\alpha'|=k'h(\alpha) = h(\alpha')h(\beta)=h(\beta')*uvwuv'w$ have the same irreducible reduct. {\bf Q.E.D.}\medskip
