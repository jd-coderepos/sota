\def\labelitemii{$\diamond$}
\newcommand{\next}{N}
\newcommand{\nextstate}{{\mbox{\rm Nustate}}}


In a
`cut and paste' method, given an input string $x$,
one replaces a substring $v$ of $x$ with another
string $v'$, so $x=uvw$ is changed to a string $x' = uv'w$.
Given that the crossing sequences around $v$ and $v'$
are compatible, the computations on $x$ and $x'$ should be similar.


We consider partial computations of $M$,
where $M$ is a 1-tape Turing machine.
By `partial' is meant that they begin at initial configurations
but do not necessarily end in halting computations.
Associated with every partial computation
is the list of crossing sequences generated by
the computation.

Recall that a crossing sequence is a sequence of the form
$$ s, p_1, \ldots, p_k $$ where $s$ is a single bit
and $p_1,\ldots, p_k$ are states of $M$.  The leading bit
is always given, but if $k=0$ then the sequence is considered empty.

In this section we assume that the squares are indexed
so the first square scanned has index $1$.

\numpara
\label{par: alternating list}
Given an input string $x$,
there is a unique computation (possibly infinite) on input $x$.
Suppose the initial tape contents are presented as
$a_{K}\ldots a_N$, where $K \leq 1$
and $N \geq |x|$ and $x = a_1 \ldots a_{|x|}$;
the other $a_i$ are blank.
Assume that in any partial computation under consideration,
only squares indexed between $K$ and $N$ are
scanned, perhaps not all of them.

\numpara
\label{par: specification}
Now suppose that we are given an alternating list
of crossing sequences $c_i$ and symbols $a_i$,
\begin{equation}
\label{given data}
c_{K-1} , a_K, c_K, \ldots, a_N, c_N,
\end{equation} where
the leading bit in $c_i$ is $0$ if $i < 1$ and $1$ if $i\geq 1$,
and the input string $x$ is $a_1\ldots a_{|x|}$.

Also, those $i$ such that $c_i$ is nonempty
form a contiguous (possibly empty) interval,
and $c_K$ and $c_N$ are empty, with leading
bits $0$ and $1$ respectively.

\numpara
\label{par: full verification}
{\bf Full verification.}
Given this data, it is easy to trace the computation
on input $x$ and produce a sequence of sextuples
$$ i_{r-1}~ p_{r-1}~ a_{r-1} ~ a_r~ \mu_r~ p_r,
\quad r = 1,2,\ldots $$ giving the square scanned
and the quintuple applied at the first, second, \ldots steps.
At the same time the procedure can check the state $p_r$ against
the relevant crossing sequence ($p_0 = q_0$ is not checked).

This can be done by maintaining
the index of the current square, the current state,
and arrays $A_i,~K\leq i \leq N$ and $I_i, K-1 \leq i \leq N$.
The array $A_i$ gives the current tape contents, and
$I_i$ gives the number of states currently cancelled from
$c_i$. The procedure is simple and we omit the details.

The procedure should continue until either

\begin{itemize}
\item
it reaches a halting configuration,
\item
it attempts to check $p_r$ against a state in some $c_i$
where $I_i$ has reached the height of $c_i$, meaning
that all states in $c_i$ have been `cancelled,' or
\item
it checks $p_r$ against a state in some $c_i$ and
discovers a mismatch.
\end{itemize}

In the first two cases, if all states in all the $c_i$
have been cancelled, it reports `consistent,' else
it reports `inconsistent.'  In the third case, it
reports `inconsistent.'

\numpara
\label{par: local verification}
{\bf Local verification.}
Next let us fix some $k, ~ K\leq k \leq N$, and consider
how this procedure affects the $k$-th square: the relevant
data and variables are
$$ k, c_{k-1}, I_{k-1}, q, A_k, c_k, I_k.$$  Let us
suppose, omitting some simple variants,
that $k\geq 2$, so the square is first entered
from the left.  When the square is first entered,
$q$ has just been cancelled from $c_{k-1}$  and $A_k=a_k$,
and a quintuple $q a_k a' \mu q'$ applies, say.
$A_k:= a',$ $q:=q'$, and the next square scanned is $k\pm 1$
depending on $\mu$: $q'$ is cancelled from $c_k$ or $c_{k-1}$
as appropriate, and the next time the square is entered,
$q$ is taken from $c_{k}$ or $c_{k-1}$.  The procedure
continues until there is a mismatch
or it attempts to check $q'$ against $c_{k-1}$ or $c_k$
when all of it has already been cancelled.  At this
point, if there is a mismatch, or not both these
crossing sequences have been fully cancelled, it reports
`inconsistent,' else it reports `consistent.'  Let
us call this procedure a {\em local verification} at the
$k$-th square.

\begin{definition}
\label{def: consecutive triple}
\label{def: compatible}
Given the data (\ref{given data}), i.e.,
$
c_{K-1}, a_K, c_k, \ldots, a_N, c_N, 
$ a {\em consecutive triple} is a triple
$c_{k-1},a_k,c_k$ where $K\leq k \leq N$.

The consecutive triple
$$ c_{k-1}, a_k, c_{k} $$ is
{\em compatible} if the local verification at the $k$-th square
reports `consistent.'
\end{definition}

\begin{theorem}
\label{thm: nasc for consistency}
The data (\ref{given data}) is consistent with
a partial computation on input $x$ if and only
if for each $k$ between $K$ and $N$ the consecutive triple
$$ c_{k-1}, a_k, c_k $$ is compatible.  In this case
the local verification at $k$ also computes the
contents of the $k$-th square at the end of the
partial computation, and identifies the unique square
at which the partial computation ends.
\end{theorem}

{\bf Proof.}
If the data in (\ref{given data}) is consistent
with a partial computation on input $x$,  the local
verification at every square will have the same effect as
the full verification and report `consistent,'
so $c_{k-1}, a_k, c_k$ are compatible
and the final value of $A_k$ will be the same as
in the full verification.

Granted that the data is consistent, the
unique $k$-th square at which the partial computation
ends is easily determined from $k, c_{k-1}, a_k, c_k$
by checking the final head-movement across
the $k-1$st and $k$th crossing points.

Otherwise, the full verification would
report inconsistency.  Suppose it terminates
at the $k$-th square.
Up to this point, its actions at the $k$-th square
are the same as the local verification procedure on that square, so the local
verification at $k$ will terminate and report inconsistency for
the same reason, and $c_{k-1}, a_k, c_k$ are incompatible.
{\bf Q.E.D.}\medskip


The Jurdzi\'nski-Lory\'s proof uses a kind of pumping lemma
and a kind of splicing lemma.  The pumping lemma is

\begin{corollary}
\label{cor: pumping}
{\bf (Pumping Lemma).}
Suppose that $x$ is an input string and $x=uvw$
where $v\not=\lambda$ and in some partial
computation on input $x$, the $u,vw$-crossing
sequence equals the $uv,w$-crossing sequence.
Explicitly, suppose the data
\begin{equation}
\label{eq: pumping data 1}
c_{K-1}, a_K, c_k, \ldots, a_N, c_N, 
\end{equation}
describes a
partial computation on input $x$. Write
$x = a_1 \ldots a_n$ and $v = a_{i+1} \ldots a_j$.
Let $x' = uw= a_1 \ldots a_i a_{j+1} \ldots a_n$.

Then $i<j,$ $c_i$ and $c_j$ are the $u,vw$- and $uv,w$-crossing
sequences respectively, and
\begin{equation}
\label{eq: pumping data 2}
c_{K-1}, a_K, c_K, \ldots, a_{i-1}, c_i, a_j, c_{j+1}, \ldots, a_N, c_N
\end{equation} is
produced by a partial computation on input $x'$.

Furthermore, if $a'_K \ldots a'_N$ are the tape contents
at the end of the first partial computation, then
$$ a'_k \ldots a'_i a'_{j+1} \ldots a'_N$$ are the
contents at the end of the second.
\end{corollary}

{\bf Proof.}  From Theorem \ref{thm: nasc for consistency},
all triples $c_{k-1}, a_k, c_k$ from the list in Equation
(\ref{eq: pumping data 1}) are compatible.  Since
$c_i = c_j$, the same goes for the list in Equation
(\ref{eq: pumping data 2}), so they are produced by
a partial computation on input $x'$.  The remark about
the final tape contents also holds because they
can be calculated by the local verification. {\bf Q.E.D.}\medskip

The other cut-and-paste result is restricted to
our reduction machine $\tm$.
Recall
(Paragraph \ref{par: hom h})
that $h$ is a homomorphism which erases blank symbols,
and a blank symbol may differ from the specific
blank $B$.

\begin{definition}
\label{def: residue}
Let $\tm$ be a reduction machine
with initial redex  $\cent t_1 x t_2 \$ = uvw$ and suppose that
a computation is executed up to a time $T$.
Let $c_1$ be the $u,vw$-crossing sequence at that point,
and $c_2$ the $uv,w$-crossing sequence, and suppose
that $z$ is the tape contents between these crossing points
at time $T$ (i.e., $z$ is the string occupying
squares $|u|+1$ to $|uv|$ at time $T$).


If at time $T$, the square being scanned is one of these
squares, write $v=\alpha\beta$ where this square
is the first in $\beta$ and let $\ell = |h(\alpha)| + 1$;
otherwise let $\ell=0$.

Let $q$ be the state at time $T$.

Then the data
$$ |v|, c_1, h(z), c_2, \ell, q $$ is called a {\em residue} or
$(u,v,w)$-residue (at time $T$).
\end{definition}

The residue is associated with a distinguished substring $v$ of
the initial redex.  It includes $|v|$, $q$, and $\ell$,
to simplify the `splicing lemma'
(\ref{lem: splicing}) below.

\begin{lemma}
\label{lem: grand residue}
Suppose $x_1$ and $x_2$ are input strings,
and there exist times $T_1$ and $T_2$
such that the $\lambda, \cent t_1 x_1 t_2 \$,\lambda $-residue
at time $T_1$ and the
the $\lambda, \cent t_1 x_2 t_2 \$,\lambda $-residue
at time $T_2$ are the same.  Then $x_1$ and $x_2$
possess the same irreducible reduct, so $\tm$
accepts $x_1$ iff it accepts $x_2$.
\end{lemma}

{\bf Proof.} The respective initial redexes lead
to configurations
at times $T_1$ and $T_2$ which are the same except
for occurrences of blank symbols,  which don't
affect the outcome of the computations
(Paragraph \ref{par: blank symbols dont affect outcome}).
{\bf Q.E.D.}\medskip

\begin{lemma}
\label{lem: splicing}
{\bf (splicing lemma).}
Let $\tm$ be a reduction machine.
Given two computations, with inputs factorised as
$uvw$ and $u'v'w'$,
suppose that at some time $t$ in the first
computation, and another time $t'$ in the second,
the residue of $v$ in the first
coincides with the residue of $v'$ in the second.
Then $uvw$ and $uv'w$ possess the same irreducible
reduct, so $\tm$ either accepts or rejects both
strings.
\end{lemma}

{\bf Proof.}
Suppose the common residue is
$ |v|, c_1, h(z), c_2, \ell, q $.
Associated with the first computation suppose we have the
data
\begin{equation}
\label{eq: presplice 1}
 c_{K-1}, a_K, \ldots, a_N, c_N,
\end{equation} $x = a_1\ldots a_n$,
and $v = a_i \ldots a_j$.  Similarly, for the second, we have the data
\begin{equation}
\label{eq: presplice 2}
c'_{K'-1}, b_{K'}, \ldots, b_{N'}, c'_{N'},
\end{equation}
$x' = b_1\ldots b_{n'}$,
and $v' = b_{i'} \ldots b_{j'}$.  We are given
that $c_i = c'_{i'}$ and $c_j = c'_{j'}$.
By
Theorem \ref{thm: nasc for consistency}, each consecutive
triple in both lists of data is compatible.  Corresponding
to the input $x' = uv'w$ we have the list
\begin{equation}
\label{eq: postsplice}
c_{K-1}, a_K, \ldots, a_i, c_i,
b_{i'+1}, c_{i'+1}, \ldots, b_{j'}, c_{j'},
a_{j+1}, \ldots a_N, c_N,
\end{equation} and each consecutive triple
in this list is compatible.  Therefore
by Theorem \ref{thm: nasc for consistency},
there is a partial
computation on input $x'$ which produces the crossing
sequences (\ref{eq: postsplice}).

The residues include the lengths of $v$ and $v'$, so
$v$ and $v'$ have the same length.

The tape squares where these partial computations end
are determined by the local verifications (Theorem
\ref{thm: nasc for consistency}).  If $\ell=0$ then
the first computation ends outside the range of $v$,
so the third computation ends outside the range of $v'$,
at the same square according to the local verifications.
Therefore

\vspace*{6pt}
($*$)\hspace*{1cm}
\begin{minipage}{5in}
at the end of the third computation, the
$(\lambda,\cent t_1 uv'wt_2\$, \lambda)$-residue
is the same as the $(\lambda, \cent t_1 uvwt_2\$, \lambda)$-residue at the end of the
first computation.
\end{minipage}
\hfil
\vspace*{6pt}

\noindent
From Lemma \ref{lem: grand residue},
$uvw$ and $uv'w$ have the same irreducible reduct.

Let $z$ and $z'$ be
the string in the squares originally occupied by $v$
and $v'$ in the first two computations.

If $\ell>0$ then the first and second computations
end at positions $k$ and $k'$, say, within the ranges
of $v$ and $v'$ respectively.  Factorise $z$ as $\alpha\beta$
where $|\alpha|=k$, and $z$ as $\alpha'\beta'$ where $|\alpha'|=k'$.
Then from the residue, $h(\alpha) = h(\alpha')$ and $h(\beta)=h(\beta')$.
Again we reach the conclusion ($*$), so $uvw$ and
$uv'w$ have the same irreducible reduct. {\bf Q.E.D.}\medskip
