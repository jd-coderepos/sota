\documentclass{LMCS}

\def\doi{8(4:6)2012}
\lmcsheading {\doi}
{1--46}
{}
{}
{Jan.~14, 2011}
{Oct.~11, 2012}
{}
 
\usepackage{prooftree,amsmath,amssymb,xcolor,xspace,url}\usepackage{enumerate,hyperref}

\ifx\pdftexversion\undefined
\usepackage[dvips]{graphicx}
\else
\usepackage{graphicx}
\DeclareGraphicsRule{*}{mps}{*}{}
\fi
\usepackage{xy}
\xyoption{all}


\usepackage{xspace}

\newcommand{\CODE}[1]{{\tt #1}}
\newcommand{\PARTY}[1]{{\tt #1}}
\newcommand{\MASTER}[1]{{\tt #1}}

\newcommand{\labelx}[1]{\label{#1}}
\newcommand{\rtsyntax}[1]{\colorbox{lightgray}{\ensuremath{#1}}}
\newcommand{\ptilde}[1]{{\ensuremath{#1}}}
\newcommand{\kf}[1]{\textup{\textsf{#1}}\xspace}
\newcommand{\constf}[1]{\textup{\textsf{#1}}}
\newcommand{\sr}[4]{\ensuremath{\bar{#1}[#2](#3).#4}}
\newcommand{\Ias}{\ensuremath{\alpha}}
\newcommand{\ssa}[4]{\ensuremath{#1[#2](#3).#4}}
\newcommand{\pp}{\ensuremath{\at{\p}}}
\newcommand{\si}[2]{\ensuremath{#1[#2]}}
\newcommand{\sI}[1]{\ensuremath{\s^#1}}
\newcommand{\sj}[3]{\ensuremath{\bar{#1}[#2]:#3}}
\newcommand{\sii}{\si{\s}{\p}}
\newcommand{\siiv}{\si{\s}{\pv}}
\newcommand{\sij}{\si{\s}{\p_j}}
\newcommand{\siq}{\si{\s}{\q}}
\newcommand{\siip}{\si{\s'}{\p'}}
\newcommand{\sipp}{\si{\s'}{\p}}
\newcommand{\ccc}{\ensuremath{c}}
\newcommand{\pset}{\ensuremath{\Pi}}
\newcommand{\inpset}[2][\Pi]{\ensuremath{\p_#2 \in #1}}
\newcommand{\kinpset}{\inpset{k}}
\newcommand{\out}[4]{\ensuremath{#1!\langle \p,#2\rangle;#4}}
\newcommand{\outp}[3]{\ensuremath{#1!\langle \p,#2\rangle}}
\newcommand{\outs}[4]{\ensuremath{#1!\langle #3,#2\rangle;#4}}
\newcommand{\e}{\ensuremath{e}}
\newcommand{\inp}[4]{\ensuremath{#1?( #3,#2);#4}}
\newcommand{\inpp}[3]{\ensuremath{#1?( #3,#2)}}
\newcommand{\inps}[4]{\ensuremath{#1?( #3,#2);#4}}
\newcommand{\x}{\ensuremath{x}}
\newcommand{\participant}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\q}{\ensuremath{\participant{q}}}
\newcommand{\p}{\ensuremath{\participant{p}}}
\newcommand{\sd}[4]{\ensuremath{#1!\langle\! \langle#3,#2\rangle \!\rangle;#4}}
\newcommand{\rd}[4]{\ensuremath{#1?(\!(#3,#2)\!);#4}}
\newcommand{\z}{\ensuremath{z}}
\newcommand{\pc}{\Par}
\newcommand{\s}{\ensuremath{s}}
\newcommand{\X}{\ensuremath{X}}
\newcommand{\Y}{\ensuremath{Y}}
\newcommand{\defX}{\ensuremath{\kf{def} \ \Ddef\ \kf{in}\ }}
\newcommand{\Xsignature}{\ensuremath{\XX(\at{x}, \at{\y})}}
\newcommand{\Ddef}{\ensuremath{\Xsignature=\PP}}
\newcommand{\Ddefp}{\ensuremath{\Xsignature=\PP'}}
\newcommand{\defIn}[1]{\ensuremath{\kf{def} \ #1 \ \kf{in}\ }}
\newcommand{\defD}{\ensuremath{\kf{def}\ \DD \ \kf{in}\ }}
\newcommand{\DdefD}{\ensuremath{\kf{def}\ \Ddef \ \kf{in}\ }}
\newcommand{\defDp}{\ensuremath{\kf{def}\ \DD' \ \kf{in}\ }}
\newcommand{\proccall}[3]{\ensuremath{#1\langle\ptilde{#2},\ptilde{#3}\rangle}}
\newcommand{\proccallw}[3]{\ensuremath{#1\langle\ptilde{#2},\ptilde{#3}\rangle}}
\newcommand{\proccalldots}[3]{\ensuremath{#1\langle\ptilde{#2},\ptilde{#3}\rangle}}

\newcommand{\indexed}[4]{\ensuremath{\{#1_#3 : #2_#3\}_{#3 \in #4}}}

\newcommand{\values}{\ensuremath{\at{v}}}
\newcommand{\trival}[3]{\ensuremath{(#3,#2, #1)}}
\newcommand{\labval}[2]{\ensuremath{(#1, #2)}}
\newcommand{\anglep}[2]{\ensuremath{\langle #1, #2\rangle}}
\newcommand{\valheap}[3]{\ensuremath{( #3,#2,#1 )}}
\newcommand{\valheapj}[2]{\ensuremath{( #2,\{j\},#1 )}}
\newcommand{\valheapLess}[3]{\ensuremath{( #3,\p\setminus j,#1 )}}
\newcommand{\delheap}[3]{\ensuremath{(#3,{#2},#1 )}}
\newcommand{\labheap}[3]{\ensuremath{( #3,#2,#1 )}}
\newcommand{\labheapj}[2]{\ensuremath{( #2,\{j\},#1 )}}
\newcommand{\lsel}[4]{\ensuremath{#1 \oplus \anglep{#3}{#2};#4}}
\newcommand{\lbranch}[2]{\ensuremath{#1 \&
({#2},\indexed{l}{\PP}{i}{I})}}
\newcommand{\lbranchi}[2]{\ensuremath{#1 \&
({#2},\indexed{l}{\PP}{i}{I})}}
\newcommand{\lbranchk}[2]{\ensuremath{#1 \&
({#2},\indexed{l}{\PP}{k}{K})}}
\newcommand{\Pifthenelse}[3]{\ensuremath{\kf{if}\ #1\ \kf{then}\ #2\ \kf{else}\ #3}}
\newcommand{\inact}{\ensuremath{\mathbf{0}}}
\newcommand{\nuc}[2]{\ensuremath{(\nu #1)#2}}
\newcommand{\AND}[2]{\ensuremath{#1\ \kf{and}\ #2}}
\newcommand{\NOT}[1]{\ensuremath{\kf{not}\ #1}}
\newcommand{\true}{\kf{true}}
\newcommand{\false}{\kf{false}}

\newcommand{\Num}{\kf{Num}}

\newcommand{\h}{\ensuremath{h}}
\newcommand{\mg}{\ensuremath{m}}
\newcommand{\va}{\ensuremath{v}}
\newcommand{\at}[1]{\ensuremath{\ptilde{#1}}}
\newcommand{\atw}[1]{\ensuremath{\ptilde{#1}}}
\newcommand{\Co}[1]{\ensuremath{C[#1]}}
\newcommand{\Par}{\ensuremath{\ |\ }}
\newcommand{\cas}{\ensuremath{r}}
\newcommand{\eq}{\ensuremath{\emptyset}}

\newcommand{\RECSEQ}[4]{\ensuremath{\mathbf{R} \ #1\ \lambda #2.\lambda #3.#4}}
\newcommand{\RECSEQP}[4]{\ensuremath{\mathbf{R} \ #1\ \lambda #2.\lambda #3.#4}}

\newcommand{\redsym}{\ensuremath{\longrightarrow}}
\newcommand{\red}[2]{\ensuremath{#1\redsym#2}}
\newcommand{\redM}[2]{\ensuremath{#1\redsym^*#2}}
\newcommand{\set}[1]{\ensuremath{\{#1\}}}
\newcommand{\sub}[2]{\ensuremath{\{#1/#2\}}}
\newcommand{\subO}[2]{\ensuremath{\set{\!\{#1/#2\}\!}}}

\newcommand{\sep}{\ensuremath{~\mathbf{|}~ }}

\newcommand{\Implies}{\ensuremath{\quad \Rightarrow \quad }}

\newcommand{\qbot}{\ensuremath{\epsilon}}
\newcommand{\mqueue}[2]{\ensuremath{#1 : #2}}
\newcommand{\emptyqueue}[1]{\mqueue{\s}{\qbot}}
\newcommand{\queue}{\ensuremath{\h}}
\newcommand{\stdqueue}{\mqueue{\s}{\queue}}
\newcommand{\qcomp}[2]{\ensuremath{#1 \cdot#2}}
\newcommand{\qtail}[1]{\ensuremath{\qcomp{\queue}{#1}}}
\newcommand{\qhead}[1]{\ensuremath{\qcomp{#1}{\queue}}}

\newcommand{\qappend}[1]{\mqueue{\s}{\qtail{#1}}}
\newcommand{\qpop}[1]{\mqueue{\s}{\qhead{#1}}}

\newcommand{\subst}[2]{\ensuremath{\{#1 / #2\}}}
\newcommand{\remove}[2]{\ensuremath{#1 \backslash \{#2\}}}

\newcommand{\freen}[1]{\ensuremath{\text{fn}(#1)}}
\newcommand{\dpv}[1]{\ensuremath{\text{dpv}(#1)}}
\newcommand{\fpv}[1]{\ensuremath{\text{fpv}(#1)}}
\newcommand{\rrule}[1]{[\text{#1}]}

\newcommand{\G}{\ensuremath{G}}
\newcommand{\Gv}[4]{\ensuremath{#1\to\p:\langle#3\rangle.#4}}
\newcommand{\U}{\ensuremath{U}}
\newcommand{\sid}[1]{\ensuremath{\textup{pn}(#1)}}
\newcommand{\pro}[2]{\ensuremath{#1\upharpoonright#2}}
\newcommand{\Ga}{\ensuremath{\Gamma}}
\newcommand{\D}{\ensuremath{\Delta}}
\newcommand{\Dp}{\ensuremath{\D'}}
\newcommand{\T}{\ensuremath{T}}
\newcommand{\TQ}{\ensuremath{{\tt{T}}}}
\newcommand{\TG}{\ensuremath{{\mathsf{T}}}}
\newcommand{\Tp}{\ensuremath{T'}}
\newcommand{\ST}{\ensuremath{S}}
\newcommand{\TT}{\atw{\T}}
\newcommand{\SST}{\atw{S}}
\newcommand{\UT}{\ensuremath{U}}
\newcommand{\oT}[2]{\ensuremath{\;!\langle #2,#1\rangle}}
\newcommand{\iT}[2]{\ensuremath{? \langle #2,#1 \rangle}}
\newcommand{\oTG}[2]{\ensuremath{\;\natural\langle #2,#1\rangle}}
\newcommand{\oTGp}[2]{\ensuremath{\;\natural'\langle #2,#1\rangle}}
\newcommand{\an}[1]{\ensuremath{\langle #1\rangle}}
\newcommand{\de}[3]{\ensuremath{#1\vdash#2:#3}}
\newcommand{\der}[3]{\ensuremath{#1\vdash#2\triangleright#3}}
\newcommand{\dom}[1]{\ensuremath{dom( #1)}}
\newcommand{\ty}{\textbf{t}}
\newcommand{\End}{\kf{end}}
\newcommand{\Bool}{\kf{bool}}
\newcommand{\Nat}{\kf{nat}}
\newcommand{\Int}{\kf{int}}


\newcommand{\SelType}[2]{\ensuremath{\oplus(#1,#2)}}

\newcommand{\seltype}{\ensuremath{\oplus \langle \p,\{l_i:\T_i\}_{i\in
I} \rangle }}
\newcommand{\seltypeG}{\ensuremath{\oplus(\p,\{l_i:\pro{\G_i}\q\}_{i\in I})}}
\newcommand{\seltypeT}{\ensuremath{\oplus\{l_i:\pro{\T_i}\q\}_{i\in I}}}
\newcommand{\seltypeTp}{\ensuremath{\oplus\{l_i:\T_i\}_{i\in I}}}
\newcommand{\seltypeq}{\ensuremath{\oplus\langle\p,l\rangle;\T}}
\newcommand{\seltypeqj}{\ensuremath{\oplus\langle\{j\},l\rangle;\T}}
\newcommand{\seltypep}{\ensuremath{\oplus(\p,l);\T'}}
\newcommand{\seltypezp}{\ensuremath{\oplus(\p,l:\T_0;\T')}}
\newcommand{\seltypez}{\ensuremath{\oplus(\p,l:\T_0)}}
\newcommand{\seltypei}{\ensuremath{\oplus\langle\p,l_i\rangle;\T_i}}
\newcommand{\seltypej}{\ensuremath{\oplus(\pv,l_j);\T_j}}
\newcommand{\seltypesi}{\ensuremath{\oplus(\pv,l_{i})}}
\newcommand{\seltypesip}{\ensuremath{\oplus(\pv,l_{i'})}}
\newcommand{\seltypesipj}{\ensuremath{\oplus(\pv\setminus j,l_{i'})}}
\newcommand{\seltypes}{\ensuremath{\oplus\langle\pv,l\rangle}}
\newcommand{\seltypesem}{\ensuremath{\oplus(\emptyset,l)}}
\newcommand{\seltypesemZ}{\ensuremath{\oplus(\emptyset,Z)}}
\newcommand{\branchtype}{\ensuremath{\&\langle\p,\{l_k:\T_k\}_{k\in K}\rangle}}
\newcommand{\branchtypeG}{\ensuremath{\&\langle\p,\{l_i:\pro{\G_i}\q\}_{i\in I}\rangle}}
\newcommand{\branchtypeT}{\ensuremath{\&\{l_i:\pro{\T_i}\q\}_{i\in I}}}
\newcommand{\branchtypeTp}{\ensuremath{\&\{l_i:\T'_i\}_{i\in I}}}
\newcommand{\branchtypes}{\ensuremath{\&\{l_i:\T_i\}_{i\in I}}}
\newcommand{\branchtypesG}{\ensuremath{\&\{l_i:\TG_i\}_{i\in I}}}

\newcommand{\Xtype}{\ensuremath{\X : \SST\;\TT}}

\newcommand{\trule}[1]{\text{\footnotesize{\ensuremath{\lfloor\text{\sc{#1}}\rfloor}}}}

\newcommand{\scripttrule}[1]{\text{\scriptsize{\ensuremath{\lfloor\text{\sc{#1}}\rfloor}}}}

\newcommand{\tfrule}[1]{{\text{\scriptsize[\text{\sc{#1}}]}}}
\newcommand{\tftrule}[1]{{\text{\footnotesize[\text{\sc{#1}}]}}}
\newcommand{\ins}{\ensuremath{:}}
\newcommand{\equivT}[2]{\ensuremath{#1\approx #2}}
\newcommand{\derqq}[4]{\ensuremath{#1 \vdash_{#2} #3 \triangleright #4}}
\newcommand{\derq}[3]{\ensuremath{#1 \vdash_{\set\s} #2 \triangleright #3}}
\newcommand{\ms}[2]{\ensuremath{{#1}\setminus{#2}}}
\newcommand{\coe}[2]{\ensuremath{\mathsf{co}({#1},{#2})}}
\newcommand{\Ltypes}{\mathcal{L}_{\T}}
\newcommand{\Qtypes}{\mathcal{Q}_{\T}}
\newcommand{\Dcomp}{\ensuremath{\ast}}
\newcommand{\Tcomp}{\ensuremath{;}}
\newcommand{\dual}[2]{\ensuremath{{#1}\bowtie{#2}}}
\newcommand{\ifthen}[2]{If {#1}, then {#2}.}
\newcommand{\cleq}{\ensuremath{\sqsubseteq}}
\newcommand{\sered}[2]{\ensuremath{{#1}~\Rightarrow~{#2}}}
\newcommand{\seredstar}[2]{\ensuremath{{#1}~\Rightarrow^*~{#2}}}


\newcommand{\cu}{\ensuremath{\lambda}}
\newcommand{\cuu}{\ensuremath{\lambda'}}
\newcommand{\B}{\ensuremath{\mathcal{B}}}
\newcommand{\M}{\ensuremath{\mathcal{N}}}
\newcommand{\Or}{\ensuremath{\mathcal{R}}}
\newcommand{\Se}{\ensuremath{\mathcal{S}}}
\newcommand{\V}{\ensuremath{\mathcal{V}}}
\newcommand{\Th}{\ensuremath{\Theta}}
\newcommand{\semicolumn}{\textup{\texttt{;}}}
\newcommand{\dere}[2]{\ensuremath{\Th\,\vdash #1\; \blacktriangleright\; #2 \,;\,\M\,;\,\B}}
\newcommand{\dereprime}[1]{\ensuremath{\Th\,\vdash #1\; \blacktriangleright\;
\Or' \,;\,\M'\,;\,\B'}}
\newcommand{\dereb}[3]{\ensuremath{\Th\,\vdash #1 \;\blacktriangleright\; #2 \,;\,\M\,;\,#3}}
\newcommand{\derep}[4]{\ensuremath{#1\,\vdash #2 \;\blacktriangleright\; #3 \,;\;#4\,;\;\B}}
\newcommand{\derepb}[5]{\ensuremath{#1\,\vdash #2 \;\blacktriangleright\; #3 \,;\;#4\,;\;#5}}
\newcommand{\deri}[5]{\ensuremath{#1\,\Mapsto #2 \;;\; #3 \,;\;#4\,;\;#5}}
\newcommand{\sdeletecha}[2]{{#1}\setminus{#2}}
\newcommand{\co}[2]{\ensuremath{{#1}\prec{#2}}}
\newcommand{\pre}[2]{\ensuremath{\mathsf{pre}({#1},{#2})}}
\newcommand{\deletecha}[2]{{#1}\setminus\!\!\!\setminus {#2}}
\newcommand{\edeletecha}[2]{{#1}\fatbslash {#2}}
\newcommand{\cl}[1]{\ensuremath{{#1}^+}}
\newcommand{\derf}[3]{\ensuremath{#1\,\semicolumn\,\B\vdash#2\blacktriangleright#3}}
\newcommand{\derg}[2]{\ensuremath{#1\blacktriangleright#2}}
\newcommand{\sn}[1]{\ensuremath{{\sf{cf}}(#1)}}

\newcommand{\dera}[3]{\ensuremath{#1\,\semicolumn\,\sdeletecha\B\Ia\vdash#2\blacktriangleright#3}}
\newcommand{\deraa}[2]{\ensuremath{\Th\,\semicolumn\,\B,\Ia~\vdash#1\blacktriangleright#2}}

\newcommand{\derab}[2]{\ensuremath{\Th~\sharp~\B,\Ib~\natural~\Se'\vdash#1\blacktriangleright#2}}
\newcommand{\nk}[1]{\ensuremath{\ell(#1)}}
\newcommand{\gen}[2]{\ensuremath{  #1 \propto #2 }}

\newcommand{\prule}[1]{\{\text{\textup{\sc{#1}}}\}}

\newcommand{\cadd}{\ensuremath{\cdot}}
\newcommand{\leqor}{\ensuremath{\preceq}}
\newcommand{\ready}{ready}
\newcommand{\nind}{\indent\indent\indent}
\newcommand{\E}{\ensuremath{\mathcal{E}}}
\newcommand{\C}{\ensuremath{\mathcal{C}}}
\newcommand{\cq}{channel qualifier}
\newcommand{\cqs}{\ensuremath{\zeta}}
\newcommand{\Uc}{\ensuremath{\uplus}}

\newcommand{\outS}[3]{\ensuremath{#1!\langle #2\rangle;#3}}
\newcommand{\inpS}[3]{\ensuremath{#1?( #2);#3}}
\newcommand{\sdS}[3]{\ensuremath{#1!\langle\! \langle#2\rangle \!\rangle;#3}}
\newcommand{\rdS}[3]{\ensuremath{#1?(\!(#2)\!);#3}}
\newcommand{\lselS}[3]{\ensuremath{#1 \oplus {#2};#3}}
\newcommand{\lbranchS}[1]{\ensuremath{#1 \& \indexed{l}{\PP}{i}{I}}}
\newcommand{\tos}[1]{\ensuremath{\circledS(#1)}}
\newcommand{\toss}{\ensuremath{\circledS}}
\newcommand{\tsn}[3]{\ensuremath{\lfloor#1~\ddagger~ #2\rfloor(#3)}}
\newcommand{\lbrancht}[2]{\ensuremath{#1 \&
(#2, \set{l_i:\tsn\T\y{\PP_i}}_{i\in I})}}
\newcommand{\pref}{{\sf{pref}}}
\newcommand{\tsnn}[3]{\ensuremath{\lfloor\!\lfloor#1~\ddagger~ #2\rfloor\!\rfloor(#3)}}
\newcommand{\seltypess}{\ensuremath{\oplus\langle\p,\{l_i:\T_i\}_{i\in I}\rangle}}
\newcommand{\lsels}[4]{\ensuremath{#1 \oplus \anglep{#2}{#3};#4}}
\newcommand{\tons}{\ensuremath{\circledR}}
\newcommand{\ton}[1]{\ensuremath{\circledR(#1)}}
\newcommand{\tsnX}[3]{\ensuremath{\lfloor#1~\natural~ #2~\natural~ \X\rfloor(#3)}}
\newcommand{\gsn}[3]{\ensuremath{\lfloor#1~\dagger~ #2\rfloor(#3)}}
\newcommand{\gsns}[2]{\ensuremath{\lfloor#1~\dagger~ #2\rfloor}}
\newcommand{\tsns}[2]{\ensuremath{\lfloor#1~\ddagger~ #2\rfloor}}
\newcommand{\gsni}[4]{\ensuremath{\lfloor#1~\dagger~ #2\rfloor_{#3}(#4)}}

\newcommand{\tl}{\ensuremath{\blacktriangleright}}
\newcommand{\varass}[1]{\X[#1]\, \tl \,\Or\, ; \,\M\, ; \,\B}
\newcommand{\varassp}[1]{\X[#1]\, \tl \,\Or'\, ; \,\M'\, ; \,\B'}

\renewcommand{\r}{\ensuremath{r}}

\newcommand{\init}{initialisation}
\newcommand{\adde}[2]{\ensuremath{#1\bar{\cup}\set{#2}}}
\newcommand{\as}[1]{\ensuremath{#1^\star}}
\newcommand{\orl}{\ensuremath{~\vee~}}
\newcommand{\andl}{\ensuremath{~\wedge~}}
\newcommand{\st}[1]{\ensuremath{\varoast(#1)}}
\newcommand{\nt}[1]{\ensuremath{\varodot(#1)}}
\newcommand{\sm}[2]{\ensuremath{#1-#2}}
\newcommand{\ns}[2]{\ensuremath{\boxast(#1,#2)}}
\newcommand{\rmb}[3]{\ensuremath{\langle#1;#2;#3\rangle}}
\newcommand{\com}[2]{\ensuremath{#1\asymp#2}}
\newcommand{\stn}[1]{\ensuremath{\not\!\!\varoast(#1)}}
\newcommand{\Un}[2]{\ensuremath{#1\bigoplus#2}}
\newcommand{\Ur}[4]{\ensuremath{\boxtimes(#1,#2,#3,#4)}}
\newcommand{\Um}[4]{\ensuremath{\boxdot(#1,#2,#3,#4)}}
\newcommand{\Ub}[4]{\ensuremath{\boxplus(#1,#2,#3,#4)}}

\newcommand{\ENCan}[1]{\langle #1 \rangle}
\newcommand{\TO}[2]{#1\to #2}
\newcommand{\GS}[3]{\TO{#1}{#2}\colon \!\ENCan{#3}}
\newcommand{\GB}[2]{\TO{#1}{#2}\colon\! \indexed{l}{\G}{k}{K}}
\newcommand{\GR}[4]{\RECSEQP{#1}{#2}{#3}{#4}}
\newcommand{\GM}[2]{\mu #1.#2}
\newcommand{\Lout}[3]{\ensuremath{!\langle #1,#2\rangle;#3}}
\newcommand{\Loutt}[2]{\ensuremath{!\langle #1,#2\rangle}}
\newcommand{\Lin}[3]{\ensuremath{?\langle #1,#2\rangle;#3}}
\newcommand{\Linn}[2]{\ensuremath{?\langle #1,#2\rangle}}
\newcommand{\Lsel}[2]{\ensuremath{\oplus\langle#1,\{l_k:#2\}_{k\in
K}\rangle}}
\newcommand{\LselSingle}[2]{\ensuremath{\oplus\langle{#1,#2}\rangle}}
\newcommand{\Lbranch}[2]{\ensuremath{\&\langle#1,\{l_k:#2\}_{k\in K}\rangle}}
\newcommand{\LselI}[4]{\ensuremath{\oplus\langle#1,\{l_{#3}:#2\}_{#3\in #4}\rangle}}
\newcommand{\LbranchI}[4]{\ensuremath{\&\langle#1,\{l_{#3}:#2\}_{{#3}\in #4}\rangle}}
\newcommand{\LR}[4]{\RECSEQP{#1}{#2}{#3}{#4}}
\newcommand{\LM}[2]{\ensuremath{\mu #1.#2}}
\newcommand{\Pout}[4]{\ensuremath{#1!\langle #2,#3\rangle;#4}}
\newcommand{\Pin}[4]{\ensuremath{#1?(#2,#3);#4}}
\newcommand{\Pdel}[4]{\ensuremath{#1!\langle\!\langle #2,#3\rangle\!\rangle;#4}}
\newcommand{\Prec}[4]{\ensuremath{#1?\langle\!\langle #2,#3\rangle\!\rangle;#4}}
\newcommand{\Psel}[4]{\ensuremath{#1\oplus\langle#2,#3\rangle;#4}}
\newcommand{\Pbranch}[2]{\ensuremath{#1\&(#2,\{l_k:\PP_k\}_{k\in K})}}
\newcommand{\APP}{\;}
\newcommand{\etc}{\ensuremath{\ldots}}
\newcommand{\mar}[1]{\ensuremath{\langle #1 \rangle}}
\newcommand{\ftv}{\kf{ftv}}
\newcommand{\fv}{\kf{fv}}
\newcommand{\fn}{\kf{fn}}
\newcommand{\pid}{\kf{pid}}
\newcommand{\IF}{\kf{if}}
\newcommand{\THEN}{\kf{then}}
\newcommand{\ELSE}{\kf{else}}
\newcommand{\DEF}{\kf{def}}
\newcommand{\IN}{\kf{in}}

\newcommand{\y}{\ensuremath{y}}
\newcommand{\Ia}{\ensuremath{a}}
\newcommand{\Ib}{\ensuremath{b}}
\newcommand{\Ic}{\ensuremath{c}}
\newcommand{\Iu}{\ensuremath{u}}
\newcommand{\Iv}{\ensuremath{v}}
\newcommand{\Iw}{\ensuremath{w}}
\newcommand{\ii}{\ensuremath{i}}
\newcommand{\jj}{\ensuremath{j}}
\newcommand{\kk}{\ensuremath{k}}
\newcommand{\Ll}{\ensuremath{l}}
\newcommand{\n}{\ensuremath{\mathrm{n}}}
\newcommand{\m}{\ensuremath{\mathrm{m}}}
\newcommand{\nn}{\ensuremath{n}}
\newcommand{\mm}{\ensuremath{m}}
\newcommand{\pv}{\ensuremath{\at{\hat{\p}}}}
\newcommand{\qq}{\ensuremath{\at{\q}}}
\newcommand{\qv}{\ensuremath{\at{\hat{\q}}}}
\newcommand{\uu}{\ensuremath{u}}
\newcommand{\xx}{\ensuremath{\mathbf{x}}}
\newcommand{\yy}{\ensuremath{\mathbf{y}}}
\newcommand{\zz}{\ensuremath{\mathbf{z}}}
\newcommand{\uuu}{\ensuremath{\mathbf{u}}}
\newcommand{\vvv}{\ensuremath{\mathbf{v}}}
\newcommand{\www}{\ensuremath{\mathbf{w}}}
\newcommand{\II}{\ensuremath{I}}
\newcommand{\K}{\ensuremath{\kappa}} 
\newcommand{\PP}{\ensuremath{P}}
\newcommand{\QQ}{\ensuremath{Q}}
\newcommand{\Q}{\ensuremath{Q}}
\newcommand{\R}{\ensuremath{R}}
\newcommand{\DD}{\ensuremath{D}}
\newcommand{\XX}{\ensuremath{\mathbb{X}}}
\newcommand{\Ty}{\ensuremath{\tau}}
\newcommand{\Names}{\ensuremath{\mathcal{P}}}
\newcommand{\Env}{\kf{Env}}
\newcommand{\Type}{\kf{Type}}
\newcommand{\GType}{\Type}
\newcommand{\LType}{\Type}
\newcommand{\SType}{\Type}
\newcommand{\PType}{\Type}
\newcommand{\PRType}{\Type}
\newcommand{\Alice}{\ensuremath{\mathtt{Alice}}}
\newcommand{\Bob}{\ensuremath{\mathtt{Bob}}}
\newcommand{\Carol}{\ensuremath{\mathtt{Carol}}}
\newcommand{\W}{\ensuremath{\mathtt{W}}}
\newcommand{\Worker}{\ensuremath{\mathtt{Worker}}}
\newcommand{\Buyer}{\ensuremath{\mathtt{Buyer}}}
\newcommand{\Supp}{\ensuremath{\mathtt{Supp}}}
\newcommand{\Manu}{\ensuremath{\mathtt{Manu}}}
\newcommand{\Participant}[1]{\ensuremath{\mathtt{#1}}}
 
\newcommand{\bit}[1]{\ensuremath{\text{bit}_{#1}}}
\newcommand{\flip}[1]{\ensuremath{\text{flip}_{#1}}}

\newcommand{\subT}{\ensuremath{\leq}}
\newcommand{\RHD}{\,\ensuremath{\blacktriangleright}\,}
\newcommand{\bnfor}{~\ensuremath{~\vert~}~} 
\newcommand{\op}{~\texttt{op}~}
\newcommand{\eval}{\ensuremath{\Downarrow}}
\newcommand{\minus}[1]{\ensuremath{#1^{-}}}
\newcommand{\proj}[1]{\ensuremath{\upharpoonright #1}}

\newcommand{\AT}[2]{#1\! : \! #2}

\newcommand{\tii}{\ensuremath{\mathtt{i}}}
\newcommand{\tjj}{\ensuremath{\mathtt{j}}}
\newcommand{\tkk}{\ensuremath{\mathtt{k}}}
\newcommand{\CONSTRAINT}[3]{\ensuremath{\{\AT{#1}{#2} \ | \ #3\}}} 
\newcommand{\PRED}{\ensuremath{\mathtt{P}}}

\newcommand{\eg}{e.g.~}

\newtheorem{DUM}{dummy}[section]{}{}
\newtheorem{DEFINITION}[DUM]{Definition}{}{}
\newtheorem{THM}[DUM]{Theorem}{}{}
\newtheorem{LEM}[DUM]{Lemma}{}{}
\newtheorem{PROP}[DUM]{Proposition}{}{}
\newtheorem{COR}[DUM]{Corollary}{}{}
\newtheorem{EX}[DUM]{Example}{}{}
\newtheorem{REM}[DUM]{Remark}{}{}
\newtheorem{CON}[DUM]{Conventions}{}{}

\newcommand{\proves}{\vdash}                        \newcommand{\judg}{{J}}
\newcommand{\VEC}{\tilde}

\newcommand{\betared}{\ensuremath{\longrightarrow_\beta}}

\newcommand{\WHNF}[1]{\ensuremath{\text{whnf}(#1)}}
\newcommand{\NF}[1]{\ensuremath{\text{nf}(#1)}}
\newcommand{\WB}{\approx}
\newcommand{\LITEQ}{\equiv}

\newcommand{\MERGE}[1]{\ensuremath{#1}}
\newcommand{\FOREACH}[3]{\ensuremath{\mathtt{foreach}(#1 #2)\{#3\}}}

\newcommand{\mergeop}{\ensuremath{\bowtie}}
\newcommand{\mergecup}{\ensuremath{\sqcup}}

\newcommand{\ParT}{U_p}

\newcommand{\equivwf}{\equiv_{\text{wf}}}
\newcommand{\gequivwf}{\equiv}
\newcommand{\gequivnf}{\equiv^\diamond}

\newcommand{\termsize}[1]{|#1|}
\newcommand{\inductiontermsize}[1]{\vert\vert #1 \vert\vert}
\newcommand{\judgementsize}[1]{w(#1)}
\newcommand{\reductionsize}[1]{\mu(#1)}
\newcommand{\headreductionsize}[1]{\mu^\circ(#1)}
\newcommand{\inductionreductionsize}[1]{\mu^\star(#1)}


\newcommand{\dkr}{\color{red}}
\newcommand{\Todo}[2]{\ifmc{\color{blue}[{\bf\dkr#1 }{#2}]}\fi}
\newcommand{\MD}[1]{\Todo{Malo}{#1}}
\newcommand{\NY}[1]{\Todo{Nobuko}{#1}}
\newcommand{\RH}[1]{\Todo{Ray}{#1}}
\newcommand{\AB}[1]{\Todo{Andi}{#1}}

\newif\ifmc
\mcfalse \newcommand{\ny}[1]
{\ifmc{\color{magenta}{#1}}\else{#1}\fi}

\newcommand{\Poutend}[3]{\ensuremath{#1!\langle #2,#3\rangle}}







\newcommand{\valheaps}[3]{\ensuremath{( #3,#2,#1 )}}
 



\title[Parameterised Multiparty Session Types]{Parameterised Multiparty Session Types}
\thanks{The work is partially supported by EPSRC EP/G015635/1 and EP/F003757/1.}


\author[P.-M.~Deni\'elou]{Pierre-Malo Deni\'elou}

\author[N.~Yoshida]{Nobuko Yoshida}

\author[A.~Bejleri]{Andi Bejleri}

\author[R.~Hu]{Raymond Hu}
\address{Department of Computing, Imperial College London, 180 Queen's
  Gate, LONDON, SW7 2AZ, UK}
\email{\{malo, yoshida, rhu\}@doc.ic.ac.uk, andi.bejleri06@imperial.ac.uk}

\begin{document}


\begin{abstract}
\noindent
For many application-level distributed protocols and parallel algorithms, the
set of participants, the number of messages or the interaction structure are
only known at run-time.
This paper proposes a dependent type theory for multiparty sessions which can
statically guarantee type-safe, deadlock-free multiparty interactions among
processes whose specifications are parameterised by indices.
We use the primitive recursion operator from G\"odel's System  to
express a wide range of communication patterns while keeping type checking
decidable.
To type individual distributed processes, a parameterised global type is
projected onto a generic generator which represents a class of all possible
end-point types.
We prove the termination of the type-checking algorithm in the
full system with both multiparty session types and recursive types.
We illustrate our type theory through non-trivial
programming and verification examples
taken from parallel algorithms and web services usecases.
\end{abstract}



















 \keywords{Session Types, Dependent Types, The Pi-Calculus, G\"odel T, Parallel Algorithms, FFT, Web services}
\subjclass{F.3.3, D.1.3, F.1.1, F.1.2}

\maketitle

\section{Introduction}
\label{sec:introduction}
\noindent
As the momentum around communications-based computing grows, the need
for effective frameworks to
globally {\em coordinate} and {\em structure} the application-level
interactions is pressing. The structures of interactions are naturally distilled as
{\em protocols}. Each protocol describes a bare skeleton of how
interactions should proceed, through e.g.
sequencing, choices and repetitions.
In the theory of multiparty session types~\cite{CHY07,BC07,BettiniCDLDY08LONG},
such protocols can be captured as types for interactions,
and type checking can statically ensure runtime safety and fidelity
to a stipulated
protocol.

One of the particularly challenging aspects of protocol descriptions
is the fact that many actual communication protocols are
highly {\em parametric}
in the sense that the number of participants  and
even the interaction structure itself are not fixed at design time.
Examples include parallel algorithms such as
the Fast  Fourier Transform (run on any number of
communication nodes depending on resource availability)
and Web
services such as business negotiation involving an
arbitrary number of sellers and buyers.
This nature is important, for instance,
for the programmer of a parallel algorithm
where the size or shape of the communication topology,
or the number of available threads might
be altered depending on the number
of available cores in the machine.
Another scenario is web services where the
participant sets may be known at design time,
or instantiated later.
This paper introduces a robust dependent type theory
which can statically ensure communication-safe, deadlock-free process
interactions which follow parameterised multiparty protocols.

We illustrate the key ideas of our proposed parametric type structures
through examples. Let us first consider a simple protocol where
participant  sends a message of type  to participant
.  To develop the code for this protocol, we start by specifying
the global type, which can concisely and clearly describe a high-level
protocol for multiple participants
\cite{CHY07,BettiniCDLDY08LONG,esop09}, as follows ( denotes
protocol termination):
-2ex]
\end{array}

\begin{array}{rclcl}
G_3
& = & \MERGE{G_1;G_2} & = & \GS{\Alice}{\Bob}{\Nat}.\GS{\Bob}{\Carol}{\Nat}.\End
\end{array}

\label{alice-bob-carol}
\Pi n.\FOREACH{\ii}{<n}{\MERGE{G_1;G_2}}

\label{ex:sequence}
\Pi n.(\FOREACH{\ii}{<n}{\GS{\W[\ii+1]}{\W[\ii]}{\Nat}})
\qquad
\begin{minipage}{10em}
\xymatrix@C=15pt{
  *+[F]{{\footnotesize \n}}\ar[r]
  &*+[F]\txt{\footnotesize \n-1}\ar[r]
  &{\ldots}\ar[r]
  &*+[F]\txt{\footnotesize 0}}
\end{minipage}
-2ex]
\end{tabular}
\end{center}
\caption{Global type reduction}\label{fig:globalreduction}
\end{figure}
 

 

The grammar of global types () is given in Figure~\ref{fig:global}.
{\em Parameterised principals}, written , can be indexed by one or more parameters, \eg . Index
 ranges over index variables , naturals  or
arithmetic operations.  A global interaction can be a message exchange
(), where  denote the sending and receiving
principals,  the payload type of the message and  the subsequent
interaction.  Payload types  are either value types  (which contain
base type  and session channel types ), or 
{\em end-point types} 
(which correspond to the behaviour of one of the session participants and will
be explained in \S~\ref{sec:typing}) for
delegation. Branching () allows the session to follow one of the different 
paths in the interaction ( is a ground and finite set of integers). 
 is a recursive type where   
type variable  
is guarded in the standard way 
(they only appear under some prefix)
 \cite{PierceBC:typsysfpl}.

The main novelty is the primitive recursive operator
 from G\"odel's System
~\cite{GirardJY:protyp} 
whose reduction semantics is given in Figure~\ref{fig:globalreduction}.  
Its parameters are a global type , an index variable
 with range ,
 a type variable for recursion  and a recursion body
.\footnote{We distinguish recursion and primitive recursion in order to get
  decidability results, see \S~\ref{sec:subjectreduction}. } 
When applied to an index , its semantics corresponds to the
repetition -times of the body , with the index variable  value
going down by one at each iteration, from  to . The final
behaviour is 
given by  when the index reaches . 
The index sorts comprise the set of natural numbers and its restrictions by predicates () that are, in our case, conjunctions of inequalities.   represents first-order indices operators
(such as , , ,...). 
We often omit  and  in our examples. 

Using , we define the product, composition, repetition and test
operators as syntactic sugar (seen in \S~\ref{sec:introduction}):
{\footnotesize
1mm]
\MERGE{G_1;G_2} & = &
\GR{\G_2}{\ii}{\xx}{\G_1\sub{\xx}{\End}} \ 1 \ 
& \IF\ \jj \ \THEN\ \G_1 \ \ELSE \ \G_2 & = &
\GR{\G_2}{\ii}{\xx}{\G_1}\APP \jj
\end{array}
\label{parallel_seq}
 \Pi n.(\FOREACH{\ii}{<n}{\GS{\W[n-\ii]}{\W[n-\ii-1]}{\Nat}})
-4ex]
\begin{tabular}{@{}c@{\qquad}c}
{\bf \textsf (a) Ring}\
      \Pi \AT{n}{I}.(&\FOREACH{i<n}{}{\GS{\W[n-i-1]}{\W[n-i]}{\Nat}};\\
      & \GS{\W[n]}{\W[0]}{\Nat}.\End) \\
    1ex]
\begin{minipage}{8em}{\small
\xymatrix@C=15pt{
  &  & *+[F]{\small \Alice}\ar[dl]\ar[dll]\ar[dr] & & \\
*+[F]{\small 0} &*+[F]{\small 1} & *{\cdots} & *+[F]{\small n-1} \\
}}
\end{minipage}
&\hspace{-4em} 
\begin{minipage}{25em}{\small}
\end{minipage}
\-5ex]
\begin{minipage}{8em}\xymatrix@C=10pt@R=10pt{
  *{\W[n][m]\hspace{-1em}}&*[F]{\hole} \ar[r]\ar[d]
  &*[F]{\hole}\ar[r]\ar[d]
  &{\ldots}\ar[r]
  &*[F]{\hole}\ar[d]
  &\\
  &*[F]{\hole}\ar[r]\ar[d]
  &*[F]{\hole}\ar[r]\ar[d]
  &{\ldots}\ar[r]
  &*[F]{\hole}\ar[d]
  &\\
  &{:}\ar[d]
  &{:}\ar[d]
  &{\ddots}
  &{:}\ar[d]
  &\\
  &*[F]{\hole}\ar[r]
  &*[F]{\hole}\ar[r]
  &{\ldots}\ar[r]
  &*[F]{\hole}
  & *{\hspace{-1em}\W[0][0]}
}
\end{minipage}
&\hspace{-3em}
\begin{minipage}{20em}{\small
}
\end{minipage}
\end{tabular}
\vspace{-4.5ex}
\caption{Parameterised multiparty protocol on a mesh topology}\label{fig:examples}
\end{figure}


\iffalse
\\
{\bf \textsf (b) Multicast}\\
\xymatrix@C=15pt{
   & *+[F]{\small \Alice}\ar[dr]\ar[dl]\ar[drr] & & \\
*+[F]{\small \m-(n-1)} &  {\ldots} & *+[F]{\small \m-1} & *+[F]{\small \m} \\
}\\
\begin{minipage}{10em}{\small}
\end{minipage}

\begin{figure*}\centering
\begin{tabular}{@{\,}c@{\quad\quad}c}
{\bf \textsf (a) Ring} & 
{\bf \textsf (c) Mesh} \\
\begin{tabular}{c}
\xymatrix@C=15pt{
  *+[F]{\small \n}\ar[r]
  &*+[F]\txt{\small \n-1}\ar[r]
  &{\ldots}\ar[r]
  &*+[F]\txt{\small 0}\ar@/^1.5pc/[lll]}\
      \Pi \AT{n}{I}.(& \RECSEQ{\GS{\W[0]}{\W[n]}{\Nat}.\End\\
        &\quad }{i}{\xx}{\GS{\W[i+1]}{\W[i]}{\Nat}.\xx}\APP \\
      &n)\\
    
      \Pi n.(& \RECSEQ{\End\\
        &\quad }{\AT{\ii}{\II}}{\xx}{\GS{\Alice}{\W[\m-\ii]}{\Nat}.\xx}\APP \\
      &n)
    
      &\Pi n.\Pi m. \\
      &\ (\RECSEQ{ \\
    & \quad (\RECSEQ{\End}{k}{\zz}{\GS{\W[0][k+1]}{\W[0][k]}{\Nat}.\zz}\APP m)\\
    & \quad }{i}{\xx}{ \\
      & \qquad (\RECSEQ{(\GS{\W[i+1][0]}{\W[i][0]}{\Nat}.\xx)\\
        & \quad \qquad  }{j}{\yy}{ \\
        & \qquad \qquad  \GS{\W[i+1][j+1]}{\W[i][j+1]}{\Nat}.\\
        & \qquad \qquad  \GS{\W[i+1][j+1]}{\W[i+1][j]}{\Nat}.\yy} \\
      & \qquad \APP m}) \\
    & \quad \APP n) 
   -3ex]
\caption{Parameterised multiparty protocols}\label{fig:examples}
\end{figure*}
\fi

\subsection{Examples of parameterised global types}
\label{sub:globalexample}
\noindent                                                                                                                                              
We present some examples of global types that implement some communication
patterns specific to typical network topologies found in classical parallel
algorithms textbooks \cite{FThomson}.

\paragraph{\bf Ring - Figure~\ref{fig:examples}(a)}
The ring pattern consists of  workers (named , ,\ldots
,) that each talks to its
two neighbours: the worker  communicates with the worker 
and  (, with the exception of  and 
who share a direct link. 
The type specifies that the first message is sent by  to , and the
last one is sent from  back to . To ensure the presence of all
three roles in the workers of this topology, the parameter domain  is set to
.




\paragraph{\bf Multicast - Figure~\ref{fig:examples}(b)}
The multicast session consists of  sending a message to 
workers \W. The first message is thus sent from \Alice\ to ,
then to , until .  
Note that, while the index  bound by the iteration
 decreases from 
 to , the index  in  increases from  to
. 


\paragraph{\bf Mesh  - Figure~\ref{fig:examples}(c)}
The session presented in Figure~\ref{fig:examples}(c) describes a particular
protocol over a standard mesh topology~\cite{FThomson}. In this two dimensional
array of workers \W, each worker receives messages from his left and top
neighbours (if they exist) before sending messages to his right and bottom (if
they exist). Our session takes two parameters  and  which represent the
number of rows and the number of columns. Then we have two iterators that repeat
 and
 for all  and . The communication flow goes from the top-left worker  and
converges towards the bottom-right worker  
in  steps of asynchronous message exchanges.


\subsection{Process syntax}
\label{sec:usersyntax}

\begin{figure}[t]
\centering
\begin{tabular}{l@{\quad}|l}
\begin{tabular}{@{}r@{\;}c@{\;}l@{\quad}l}
\ccc & ::=  & \y \sep \s[\p] & Channels \1mm]
\Iv & ::=  &  & Values\1mm]
 \mm & ::=  & (\qv,\pv,\va) \sep  (\qv,\pv,\s[\pv'])  \sep
 (\qv,\pv,\Ll) 
& Messages in transit \1mm] \multicolumn{2}{l}{    ::=   \hspace{1em} 
  Expressions}\1mm]
\end{tabular}
\end{tabular}
\caption{Syntax for user-defined and run-time processes}\label{fig:syntax}
\end{figure}

 
The syntax of expressions and processes is given in Figure~\ref{fig:syntax},
extended from \cite{BettiniCDLDY08LONG}, adding the primitive recursion operator and
a new request process.  Identifiers  can be variables  or
channel names . Values  are either channels  or natural numbers .
Expressions  are built out of indices
, values , variables , session end points (for delegation) and
operations over expressions.
Participants  can include indices which 
are substituted by values and evaluated during reductions (see 
the next subsection). 
In processes, sessions are asynchronously initiated by . 
It spawns, for each of the , 
\footnote{Since the set of principals is parameterised, we allow some syntactic
sugar to express ranges of participants that depend on parameters.}
a request that is accepted by the participant through . 
Messages
are sent by  to the participant  
and received by  from the participant .  
Selection , and branching , allow a
participant to choose a branch from those supported by another.  Standard
language constructs include recursive processes , restriction
 and
,  and
parallel composition .
The primitive recursion operator  takes as
parameters a process , a function taking an index parameter  and a
recursion variable . A queue  stores the asynchronous messages in
transit.


\label{par:annotated}
An {\em annotated}  is the result of annotating 's bound names and
variables by their types or ranges as in e.g.~ or
 or 
.
We omit the annotations 
unless needed.  We often omit  and the participant  from the session
primitives.  Requests, session restriction and channel queues appear only at
runtime, as explained below.



\subsection{Semantics}
\label{subsec:semantics}

\iffalse
\begin{figure}[t]
\centering
\small
\begin{tabular}{cr}
     \red{\Iv\op\Iv'}
     {\Iv''} \quad \text{with  corresponding to }
     & [Op]
 \1.5mm]
  \red{\GR{P}{\ii}{X}{Q}\APP \n+1}{P\sub{\n}{\ii}\sub{\GR{P}{\ii}{X}{Q}\APP \n}{X}} & [SuccR]
  \1.5mm]
          & [Join]
\1.5mm]
\red{\lsel{\sii}{l}{\q}{\PP} \Par \stdqueue}
    {\PP \Par \qappend{\labheap{l}{\q}{\p}}}
    & [Label]
\1.5mm]
\lbranchk{\sii}{\q} \Par \qpop{\labheap{l_{k_0
}}{\p}{\q}}
     \ \  & [Branch]
\1.5mm]
   \red{\PP}{\PP'} \Implies \red{\PP \Par \Q}{\PP' \Par \Q}
   &[Par]\1.5mm]
    & [Context]
 \1.5mm]
 \red{\GR{P}{\ii}{X}{Q}\APP \n+1}
{Q\sub{\n}{\ii}\sub{\GR{P}{\ii}{X}{Q}\APP \n}{X}}
    & [SuccR]
\1.5mm]
          & [Join]
\1.5mm]
\red{\lsel{\siiv}{l}{\qv}{\PP} \Par \stdqueue}
    {\PP \Par \qappend{\labheap{l}{\qv}{\pv}}}
    & [Label]
\1.5mm]
\lbranchk{\siiv}{\qv} \Par \qpop{\labheap{l_{k_0
}}{\pv}{\qv}}
     \ \  & [Branch]
\1.5mm]
   \red{\PP}{\PP'} \Implies \red{\PP \Par \Q}{\PP' \Par \Q}
   &[Par]\1.5mm]
  & [Context]
 \
\bar{\Ia}[\pv_0,..,\pv_\n] \redsym (\nu \s)(
        s : \qbot \pc \sj{\Ia}{\pv_0}{\s} \pc ...\pc
        \sj{\Ia}{\pv_\n}{\s})
2mm]
  \2mm]
   
   \
\begin{array}{l}
\Pi n.(\RECSEQ{\End}{i}{\xx}{}\GS{\Alice}{\Bob}{\Nat}.
\GS{\Bob}{\Carol}{\Nat}.\xx \APP n)
\end{array}

\begin{array}{lll}
\Alice(\nn) = \sr{a}{\participant{a},\participant{b},\participant{c}}
\y(\RECSEQP{\inact}{\ii}{\X}{\outS{\y}{\participant{b},\e[i]}}\X\APP n)\1mm]
\Carol(\nn) = \ssa{a}{\participant{c}}
\y(\RECSEQP{\inact}{\ii}{\X}{\inpS{\y}{\participant{b},z}}\X\APP n)
\end{array}

\begin{array}{llrlll}
\Pi \nn.(\Pifthenelse{\nn=0 & }{ & \inact & \\
& }{ &(\mathbf{R} &
(\sr{a}{\W[\nn],..,\W[0]}{y}{\outS{\y}{\W[\nn-1],v}\inact}
\1mm]
& & & \lambda {\ii}.\lambda{\X}.(
\ssa{a}{\W[\ii+1]}{y}{\inpS{y}{\W[\ii+2],z}\outS{\y}{\W[\ii],z}\inact \pc X}) {\quad \nn-1})}
\end{array}

\begin{array}{l}
\sr{a}{\W[2],\W[1],\W[0]}{y}{\outS{\y}{\W[1],v}}\inact \pc
\ssa{a}{\W[0]}{y}{\inpS{y}{\W[1],z}}\inact \pc
\ssa{a}{\W[1]}{y}{\inpS{y}{\W[2],z}\outS{\y}{\W[0],z}}\inact
\end{array}

\begin{array}{ll}
\red{}{} &(\nu \s)(s : \qbot \pc \outS{\si\s {\W[2]}}{\W[1],v}\inact \pc \sj{\Ia}{\W[1]}{\s}\pc \sj{\Ia}{\W[0]}{\s}\pc \\
 & \qquad
\ssa{a}{\W[0]}{y}{\inpS{y}{\W[1],z}}\inact \pc \ssa{a}{\W[1]}{y}{\inpS{y}{\W[2],z}\outS{\y}{\W[0],z}}\inact)\\
\red{}{} & (\nu \s)(s : \qbot \pc \outS{\si\s {\W[2]}}{\W[1],v}\inact \pc \sj{\Ia}{\W[1]}{\s}\pc\\
 &  \qquad \inpS{\si\s {\W[0]}}{\W[1],z}\inact \pc
\ssa{a}{\W[1]}{y}{\inpS{y}{\W[2],z}\outS{\y}{\W[0],z}}\inact)\\
\red{}{}^* & (\nu \s)(s : \qbot \pc \outS{\si\s {\W[2]}}{\W[1],v}\inact \pc \inpS{\si\s {\W[0]}}{\W[1],z}\inact \pc
\inpS{\si\s {\W[1]}}{\W[2],z}\outS{\si\s {\W[1]}}{\W[0],z}\inact)\\
\red{}{}^* &
(\nu \s)(s :  \qbot \pc \inpS{\si\s {\W[0]}}{\W[1],z}\inact \pc
\outS{\si\s {\W[1]}}{\W[0],v}\inact) \\
\red{}{}^* & \equiv \inact
\end{array}

\begin{array}{lllll}
\Pi \nn.(\mathbf{R} &
\sr{a}{\W[0], ..., \W[\nn]}{y}{\outS{\y}{\W[1],v}\inpS{y}{\W[\nn],z}P}\1mm]
& \quad \lambda {\ii}.\lambda{\X}.(
\ssa{a}{\W[\ii+1]}{y}{\inpS{y}{\W[\ii],z}\outS{\y}{\W[\ii+2],z} \pc X}) {\quad \nn-1} )
\end{array}
2mm]
{\small

}

The complete implementation can be generated using the following process:

{\small
1mm]
\qquad\qquad\qquad\qquad~~  \lambda \jj.\lambda \Y.(\PP_{\text{center}}(\ii, \jj) | \Y)\\
\qquad\qquad\qquad\qquad \mm-1)\\
\qquad\qquad \nn-1)\\
\end{array}
\begin{array}{l@{\hspace{-4em}}l}
&\Pi n.  \\
& \FOREACH{\ii}{<2^n}{\GS{i}{i}{\Nat}};\\
& \FOREACH{l}{<n}{\\
  & \hspace{0.5em} \FOREACH{i}{<2^l}{ \\
    & \hspace{0.9em} \FOREACH{j}{<2^{n-l-1}}{ \\
      &  \hspace{1.2em} \GS{i*2^{n-l}+j}{i*2^{n-l}+2^{n-l-1}+j}{\Nat}  \\
      &  \hspace{1.2em} \GS{i*2^{n-l}+2^{n-l-1}+j}{i*2^{n-l}+j}{\Nat}  \\
      &  \hspace{1.2em} \GS{i*2^{n-l}+j}{i*2^{n-l}+j}{\Nat}  \\
      &  \hspace{1.2em} \GS{i*2^{n-l}+2^{n-l-1}+j}{i*2^{n-l}+2^{n-l-1}+j}{\Nat} 
}}}\\
\end{array}\begin{array}{@{\hspace{-3em}}l} \ \Pout{\y}{\p}{\x_{\overline{\pp}}}{}\\
 \ \FOREACH{l}{<n}{\\
 \quad
    \Pifthenelse{\bit{n-l}(\pp)=0\\
 \quad}{\Pin{\y}{\p}{\x}{\Pout{\y}{\p+2^{n-l-1}}{\x}{\\
 \hspace{3.3em}\Pin{y}{\p+2^{n-l-1}}{\z}{\Pout{\y}{\p}{\x+\z\,\omega_N^{g(l,\pp)}}{}}}}\\
\quad}{\Pin{\y}{\p}{\x}{\Pin{y}{\p-2^{n-l-1}}{\z}{\\
\hspace{3.3em}\Pout{\y}{\p-2^{n-l-1}}{\x}
      {\Pout{\y}{\p}{\z+\x\,\omega_N^{g(l,\pp)}}{}}}}}};\\
\ \Pin{\y}{\p}{\x}{\Pout{r_{\p}}{0}{x}}\inact
\end{array}
X_k = f(\omega_N^k) 
-3ex]
\noindent
with  one of the -th primitive
roots of unity. The DFT can be seen as a polynomial interpolation on the
primitive roots of unity or as the application of the square matrix
 to the vector .

\paragraph{\bf FFT and the butterfly network} 
We present the radix-2 variant of the Cooley-Tukey algorithm~\cite{CT65}. It uses a divide-and-conquer strategy based on the following equation (we use
the fact that ):

1mm]
& = &\sum_{j=0}^{N/2-1}x_{2j}\,\omega_{N/2}^{jk}
  + \omega_N^k\sum_{j=0}^{N/2-1}x_{2j+1}\,\omega_{N/2}^{jk}
\end{array}
1mm]
 \proj{\qq} \ = 
&  \IF\ \qq=\pp\ \THEN\ \Lsel{\p'}{\G_k\proj{\qq}}\\
 & \ELSE\IF\ \qq=\pp' \THEN\ \Lbranch{\p}{\G_k\proj{\qq}} \\
 & \ELSE\  \
\begin{array}{lll}
\TO{\W[0]}{\W[1]}: & \{\mathsf{ok}:\TO{\W[1]}{\W[2]}:\ENCan{\Bool}, & \ \mathsf{quit}:\TO{\W[1]}{\W[2]}:\ENCan{\Nat}\}
\end{array}

\begin{prooftree}
{\forall i\in (K \cap J). T_i\mergeop T_i' \quad 
\forall k\in (K \setminus J), \forall j.(J \setminus K).l_k \not = l_j
}
\justifies 
{\langle\p,\{l_k:T_k\}_{k\in K}\mergeop 
\&\langle\p,\{l_j:T_j'\}_{j\in J}\rangle
}
\end{prooftree}

\begin{array}{lll}
\Lbranch{\p}{\T_k}\mergecup 
\&\langle\p,\{l_j:T_j'\}_{j\in J}\rangle \ = \\ 
\quad \&\langle\p,\{l_i:T_i\mergecup T_i'\}_{i\in K\cap J}
\cup \{l_k:T_k\}_{k\in K\setminus J}
\cup \{l_j:T_j'\}_{j\in J\setminus K}\rangle\
and homomorphic for other types (i.e. 
 where  is a context for local types). 
\end{DEFINITION}
The mergeability relation states that two types are identical up to their
branching types where only branches with distinct labels are allowed to be
different.  By this extended typing condition, we can modify our previous global
type example to add  and  labels to notify
. We get:

{\small}

Then  can have the type  which
could not be obtained through the original projection rule
in~\cite{CHY07,BettiniCDLDY08LONG}.
This projection is sound 
up to branching subtyping 
(it will be proved in Lemma \ref{lem:mergeability} later).

\subsection{Type system (1): environments, judgements and kinding}
\noindent 
This subsection introduces the environments and kinding systems. 
Because free indices appear both in terms (e.g.
participants in session initialisation) and in types, the formal definition of
what constitutes a valid term and a valid type are interdependent and
both in turn require a careful definition of a valid global type.

\paragraph{\bf Environments}
One of the main differences with previous session type systems is that session
environments  can contain dependent {\em process types}.  The grammar of environments, process
types and kinds are given below.
\begin{center}
\small
\begin{tabular}{ll}
\begin{tabular}{rcl@{\quad}l}
\D & ::= &  \sep \D, \ccc:\T\
\begin{array}{l}
\kappa ::= \Pi \jj:I.\kappa \sep \Type 
\quad \quad \quad 
\ParT :: = \Nat \sep \Pi\AT{\ii}{\II}.{U_p}\\
\end{array}

\begin{array}{c}
\begin{prooftree}
{- }
\justifies
{\emptyset \vdash \Env} \using\scripttrule{ENul}
\end{prooftree}
\quad 
\begin{prooftree}
{\Gamma \models \mathtt{P}}
\justifies
{\Gamma,\mathtt{P} \vdash \Env} \using\scripttrule{EPre}
\end{prooftree}
\quad 
\begin{prooftree}
{\Gamma \vdash S \RHD \GType \quad u\not\in \dom{\Gamma} }
\justifies
{\Gamma,\AT{u}{S} \vdash \Env} \using\scripttrule{ESort}
\end{prooftree}
\\ 
\\ 
\begin{prooftree}
{\Gamma \vdash I \quad i\not\in \dom{\Gamma}}
\justifies
{\Gamma,i:I \vdash \Env} \using\scripttrule{EIndex}
\end{prooftree}
\quad 
\begin{prooftree}
{\Gamma \vdash \tau\RHD \kappa \quad X\not\in \dom{\Gamma} }
\justifies
{\Gamma,X:\tau \vdash \Env} \using\scripttrule{VEnv}
\end{prooftree}
\end{array}
3ex]
\begin{prooftree}
{\Gamma, \ii:\II \vdash \Ty \RHD \K}
\justifies
{\Gamma \vdash \Pi\AT{\ii}{\II}.\Ty \RHD \Pi\AT{\ii}{\II}.\K} \using\scripttrule{KPProd}
\end{prooftree}
\end{array}
GT\tau\G_1\equiv\G_2\equiv\GR{\G_1}{\AT{\ii}{\II}}{\xx}{\G_1'}
\equivwf \GR{\G_2}{\AT{\ii}{\II}}{\xx}{\G_2'}I\II\Gamma\proves \Env\Gamma\tau\jj = 0P\Ty\sub{0}{\jj}Q\Ty\sub{\ii+1}{\jj}\Gamma,
\ii\!\!:\!\!\minus{\II},\X\!\!:\!\!\Ty\sub{\ii}{\jj}\Ty\sub{\ii}{\jj}XX\equiv\Delta\WB \Delta'\LM{\xx}{\T}T\sub{\LM{\xx}{\T}}{\xx}\{\pp_0,..,\pp_n\}\mathtt{pid}(\G)\{\p_0,..,\p_\n\}\GG'\TypeG\Delta\End\Delta\ \End\text{ only}\forall c \in \dom{\Delta}.\Delta(c)=\End\Ga
\subseteq \Ga'\AT{u}{S}\in \Ga\AT{u}{S}\in \Ga'\Ga \subseteq \Ga'\Ga'\Gamma\Ga \subseteq \Ga'\Ga'\proves \Env\Gamma \proves \judg\Gamma' \proves \judg\Gamma,\AT{u}{U},\Gamma' \proves \judgu\not\in \fv(\Gamma', \judg)\cup \fn(\Gamma', \judg)\Gamma,\Gamma' \proves \judg\Gamma \proves J\Gamma \proves \Env\Gamma \proves \G \RHD \K\Gamma \proves \K\Gamma \proves \G \equiv \G'\Gamma \proves G \RHD \K\Gamma \proves P \rhd \Ty\Gamma \proves \Ty \RHD \K\Gamma,\AT{u}{U},\Gamma' \proves \judg\Gamma \proves U\equiv
U'\Gamma,\AT{u}{U'},\Gamma' \proves \judg\Gamma,\AT{\ii}{\II},\Gamma' \proves \judg\Gamma\models
\AT{\ii}{\II}=
\AT{\ii}{\II'}\Gamma,\AT{\ii}{\II'},\Gamma' \proves \judg\Gamma,\PRED,\Gamma' \proves \judg\Gamma\models
\PRED=\PRED'\Gamma,\PRED',\Gamma' \proves \judg\Gamma \vdash \GR{\G}{\AT{\ii}{\II^-}}{\xx}{\G'}  
\RHD \Pi\AT{\jj}{\II}. \K\Gamma \vdash  
\Pi\AT{\jj}{\II}. \K\Gamma, \ii:\II^- \vdash \G' \RHD \K\subst{i+1}{j}\Gamma, \ii:\II^- \vdash \K\subst{i+1}{j}\II^-\Gamma, \jj:\II \vdash \K\Gamma\vdash \Pi\AT{\jj}{\II}.\K{\Ga,\ptilde{\ii}:\II,\Ga'}\proves_\Sigma {\judg}\Ga\models \n: \II{\Ga,(\Ga'\subst{\n}{\ii})}\proves_\Sigma \judg\subst{\n}{\ii}\Ga\models \n: \II\derqq{\Ga,(\Ga'\subst{\n}{\ii})}{\Sigma}{\PP\subst{\n}{\ii}}{\Ty\subst{\n}{\ii}}\Gamma,\Gamma'\sub{\n}{k} \vdash
(\RECSEQP{\PP}{\ii}{\X}{\QQ})\sub{\n}{k} \rhd 
(\Pi \AT{\jj}{\II}.\Ty)\sub{\n}{k}\mathcal{T}\redsym\G\redsym \G'\T\redsym \T'\Gamma\proves G \RHD \KG'= \WHNF{G}G \redsym^\ast G'\not\redsym\mathcal{T}\G\redsym \G_i\G_1=\G_2\G\redsym \G_ii=1,2\G_i\redsym^\ast \G'\redsym\judgementsize{\cdot}\judgementsize{\Gamma \proves G_1 \gequivwf G_2}=
\judgementsize{\Gamma \proves G_1 \equivwf G_2}+1\judgementsize{\Gamma \proves G_1 \equivwf G_2}=
\omega\cdot(\inductionreductionsize{G_1}+\inductionreductionsize{G_2})+
\inductiontermsize{G_1}+\inductiontermsize{G_2}+1
|\cdot|\termsize{\Nat}=1\termsize{\mar\G}= \termsize{G}+1\termsize{\GS{\p}{\p'}{\U}.\G}=
   2+\termsize{\U}+\termsize{\G}\termsize{\GB{\p}{\p'}}=2+\Sigma_{k\in K} (1+ \termsize{G_k})\termsize{\GM{\xx}{\G}}=\termsize{\G}+2\termsize{\xx}=\termsize{\n}=\termsize{\End}=1\termsize{\G\APP \tii}=\termsize{G}+2\fv(\tii)=\emptyset\termsize{\G\APP \tii}=\inductiontermsize{G}+2\fv(\tii)\not=\emptyset\termsize{\GR{\G}{\AT{\ii}{\II}}{\xx}{\G'}}=
   4+\inductiontermsize{G}+\inductiontermsize{G'}\termsize{\Lout{\p}{\U}{\T}}=3+\termsize{\U}+\termsize{\T}\termsize{\Lin{\p}{\U}{\T}}=3+\termsize{\U}+\termsize{\T}\termsize{\Lsel{\p}{\T_k}}= \termsize{\Lbranch{\p}{\T_k}}
     =2+\Sigma_{k\in K}(1+\termsize{T_k})\termsize{\LM{\xx}{\T}} =\termsize{\T}+2\termsize{\xx}=\termsize{\n}=\termsize{\End}=1\termsize{T\APP \tii}=\termsize{T}+2\fv(\tii)=\emptyset\termsize{T\APP \tii}=\inductiontermsize{T}+2\fv(\tii)\not=\emptyset\termsize{\GR{\T}{\AT{\ii}{\II}}{\xx}{\T'}}=
   4+\inductiontermsize{T}+\inductiontermsize{T'}\termsize{\Pi\AT{\ii}{\II}.{U_p}}= 2 + \termsize{U_p}\termsize{\emptyset}=0\termsize{\Delta,\AT{c}{\T}}=\termsize{\Delta}+\termsize{\T}+1\termsize{\Pi\AT{\ii}{\II}.\tau}= 2 + \termsize{\tau}\vert\vert\cdot\vert\vert\inductiontermsize{\GR{\G}{\AT{\ii}{\II}}{\xx}{\G'}}=
   \Sigma_{\n \in I}\termsize{{\GR{\G}{\AT{\ii}{\II}}{\xx}{\G'}} \n}I\inductiontermsize{\GR{\T}{\AT{\ii}{\II}}{\xx}{\T'}}=
   \Sigma_{\n \in I}\termsize{{\GR{\G}{\AT{\ii}{\II}}{\xx}{\G'}} \n}I\inductiontermsize{G}=\termsize{G}\reductionsize{\cdot}\reductionsize{\GS{\p}{\p'}{\U}.\G}=\inductionreductionsize{G}\reductionsize{\GB{\p}{\p'}}=\Sigma_{i\in I}\inductionreductionsize{G_i}\reductionsize{\GM{\xx}{\G}}=\inductionreductionsize{G}\reductionsize{\G\APP \tii}=m+\inductionreductionsize{G}\reductionsize{\GR{\G}{\AT{\ii}{\II}}{\xx}{\G'}}=
   \inductionreductionsize{G}+\inductionreductionsize{G'}\reductionsize{\xx}=\reductionsize{\End}=0\reductionsize{\T\APP \tii}=n+\inductionreductionsize{T}\reductionsize{\GR{\T}{\AT{\ii}{\II}}{\xx}{\T'}}=
   \inductionreductionsize{T}+\inductionreductionsize{T'}\reductionsize{G}\inductionreductionsize{\cdot}\inductionreductionsize{\GR{\G}{\AT{\ii}{\II}}{\xx}{\G'}}=
  \Sigma_{\n \in I} \reductionsize{\GR{\G}{\AT{\ii}{\II}}{\xx}{\G'} \n}\inductionreductionsize{\GR{\T}{\AT{\ii}{\II}}{\xx}{\T'}}=
  \Sigma_{\n \in I} \reductionsize{\GR{\T}{\AT{\ii}{\II}}{\xx}{\T'} \n}\inductionreductionsize{G}=\reductionsize{G}mn\longrightarrow\G\APP \tii\T\APP \tii\termsize{G}G\omega^2\inductiontermsize{G}G\reductionsize{\G}\redsymG\inductionreductionsize{\G}\redsymG\judgementsize{\Gamma \proves G_1 \equivwf G_2}\inductionreductionsize{\G}\inductiontermsize{G}\termsize{G}\reductionsize{\G}\inductiontermsize{G}\inductionreductionsize{\G}\inductionreductionsize{\G}e1e0\WHNF{G_1}=G_1\WHNF{G_2}=G_2\WHNF{G_1} \not = G_1G_1\redsym G_1'\inductionreductionsize{\WHNF{G_i}} < \inductionreductionsize{G_i}i=1,2\inductiontermsize{\WHNF{G_i}} \leq 
\inductiontermsize{G_i}G\inductiontermsize{G}< \omegaG_{1k}G_{2k}\Gamma \proves G_{ik}\RHD \Type\reductionsize{G_{ik}}=\inductionreductionsize{G_{ik}}\termsize{G_{ik}}=\inductiontermsize{G_{ik}}II{m_{i\n}}\GR{\G_i}{\AT{\ii}{\II}}{\xx}{\G_i'}\, \n\GR{\G_i}{\AT{\ii}{\II}}{\xx}{\G_i'}\, \n 
 \redsym^\ast G_{i\n}'' \not\redsym\n\in II=[0,\ldots,\m]{m_{i\n}}\GR{\G_i}{\AT{\ii}{\II}}{\xx}{\G_i'}\, \n\GR{\G_i}{\AT{\ii}{\II}}{\xx}{\G_i'}\, \n 
 \redsym^\ast G_{i\n}'' \not\redsym\n\in IG_i\tii_i\not\redsym\inductionreductionsize{G_i \tii_i}=\inductionreductionsize{G_i}G_i\inductiontermsize{G_i}=\termsize{G_i}G_i\tii_i\tii_i\m\m\inductiontermsize{G_i\, \tii_i}=\inductiontermsize{G_i}+2G_i\tii_i\n\inductiontermsize{G_i\, \tii_i}=\inductiontermsize{G_i}+2\Gamma\models \PRED\Gamma\proves G \equiv G'\mu \AT{X}{\tau}.\PP\RECSEQP{\PP}{\AT{\ii}{\II}}{\X}{\QQ}\X^\tau\Gamma\models \PREDP\Gamma\proves P\rhd \emptyset\Gamma\models \PRED\lambda\tau \WB \tau'\tftrule{Tvar}\tau\tau'X^{\tau'}\tftrule{Teq}\tftrule{TInit,TReq,TAcc}\tftrule{TIn,TRecep}x\tftrule{TRec}X\tftrule{TRec}X\Gamma\Gamma \vdash \uu:\mar{\G}\Gamma \vdash \PP \rhd \D, \y:T\Gamma \vdash \G \proj{\p_0} \equiv T\alpha \equiv \beta\alpha\beta\Gamma \proves \p_i\rhd \Nat\Gamma \models \pid(\G)=\{\p_0..\p_\n\}\Gamma \vdash \PP\rhd \D,\ccc:\T,\y:\T'\Gamma\proves T_0\equiv \T'P\not = X\Gamma\models \PRED\subT\sqcup_{k\in K}  \G_k\proj{\qq}\sqcap \{T\ | \ \forall k\in K.T \subT (G_k\proj{\qq}) \}G_1\proj{\p} \mergeop G_2\proj{\p}\Gamma \proves G_iGG\proj{\p}=\sqcap \{T\ | \ T \subT G_i\proj{\p} \ (i=1,2)\}\sqcap\subTG_1\proj{\p}G_2\proj{\p}G_1 = \TO{\p'}{\p}\colon\! \indexed{l}{{\G'}}{k}{K}G_2 = \TO{\p'}{\p}\colon\! \indexed{l}{{\G''}}{j}{J}G_1\proj{\p} \mergeop G_2\proj{\p}\G'_{k}\proj{\p}=T_{k}\G''_{j}\proj{\p}=T_{j}'\mergeopG_1\proj{\p}= \langle\p',\{l_k:T_{k}\}_{k\in K}\rangleG_2\proj{\p}=\&\langle\p',\{l_j:T_{j}'\}_{j\in J}\rangle\forall i\in (K \cap J). T_i\mergeop T_i'\forall k\in (K \setminus J),\forall j\in (J \setminus K).l_k \not = l_jT_k\mergeop T_j'I=K \cup Ji\in K \cap JT''_{i}=T_{i}\sqcap T'_{i}i\in K, i\not\in JT''_{i}=T_{i}i\in J, i\not\in KT''_{i}=T'_{i}G_{0i}\proj{\p}=T''_iG\proj{\p}=\sqcap \{T\ | \ T \subT G_i\proj{\p} \ (i=1,2)\}\equiv\bullet\sered{\set{\si{\s}{\pv}:\Lout{\qv}{\U}{\T},\si{\s}{\qv}:\Lin{\pv}{\U}{\T'}}}{\!\set{\si\s\pv: \T, \si\s{\qv}:\T'}}\sered{\set{\si{\s}{\pv}:\Lout{\pv}{\U}{\Lin{\pv}{\U}{\T'}}}}
{\!\set{\si\s\pv: \T'}}\sered{\set{\si\s\pv:\Lsel{\qv}{\T_k}}}{\set{\si\s\pv:\LselSingle{\qv}{l_j};T_j}}\sered{\set{\si\s\pv:\LselSingle{\qv}{l_j};T,
\si\s{\qv}:\branchtype}}{\set{\si\s\pv:\T, \si\s{\qv}:\T_j}}\sered{\D\cup\D''}{\D'\cup\D''}\sered{\D}{\D'}\qv\pvl_j\qv \sii:\T\in\Delta\pro{\T}\q\not=\End \siq:\T'\in\Delta\dual{\pro{\T}\q}{\pro{\T'}\p}\pro{\T}\q\dual{}{}\pro{\T}\qT\q\pro{\G}\q\dual{\pro{\T}\q}{\pro{\T'}\p}\T\q\T'\p\G\p,\q \in \G\p \neq \q\dual{\pro{(\pro{\G}{\p})}{\q}}{\pro{(\pro{\G}{\q})}{\p}}\derqq\Ga{\Sigma}\PP\D\PP\equiv{\PP'}\Ty'\seredstar\Ty\Ty'\Ty'\Sigma\derqq\Ga{}{\GR{P}{\ii}{X}{Q}\APP \n+1}{\tau}\red{\GR{P}{\ii}{X}{Q}\APP \n+1}
{Q\sub{\n}{\ii}\sub{\GR{P}{\ii}{X}{Q}\APP \n}{X}}\Ty'\Ty \equiv (\Pi\AT{\jj}{\II}.\Ty') \n+1 \equiv \Ty'\subst{\n+1}{\jj}\Ga{\models}{\n+1:\II}\Ga{\models}{\n: \minus{\II}}\Gamma, \X:\Ty'\sub{\ii}{\jj}\sub{\n}{\ii}  \vdash \QQ\sub{\n}{\ii}  \rhd
  \Ty'\sub{\ii+1}{\jj}\sub{\n}{\ii}\n\n=0\Gamma  \vdash \QQ\sub{1}{\ii}\sub{P}{X}  \rhd
  \Ty'\sub{1}{\jj}\n\geq 1\n\derqq\Ga{}{\GR{P}{\ii}{X}{Q}\APP \n}{\Ty'\sub{\n}{\jj}}\Gamma\vdash \QQ\sub{\n}{\ii}\sub{\GR{P}{\ii}{X}{Q}\ \n}{X}  \rhd
 \Ty'\sub{\n+1}{\jj}\derqq{\Ga}{\emptyset}{\sr\Ia{\p_0,..,\p_\n}{\y}{\PP}}{\D}\D'\leq\D\coe{(\s[\pp_0]:\G \proj{\pp_0},
  ... , \s[\pp_n]:\G\proj{\pp_n})}{\s}\Gamma \vdash _{} \sj{\Ia}{\p}{\s} \pc \ssa\Ia{\p}{\y}{\PP}\rhd
\D\D=\D',\s[\pp]:\T\derqq{\Ga}{\Sigma}{\out{\si{\s}{\q}}{\e}{\p}{\PP} \Par
\mqueue{\s}{\queue}}{\D}\Sigma=\set{\s}\D=\D_2\Dcomp\D_1(\D_2\Tcomp\set{ \si{\s}{\q} : \oT{\SST}{\p}})\Dcomp
(\D_1',\si{\s}{\q}:\T){=}\D_2\Dcomp( \D_{1}',\si{\s}{\q} : \oT{\SST}{\p};\T).\derqq{\Ga}{\Sigma}{\inp{\sii}{\x}{\q}{\PP} \Par
\qpop{\valheaps{\va}{\set\p}{\q}} }{\D}\Sigma=\set\s\D=\D_2\Dcomp\D_1\D\SST=\SST'\der{\Ga}{\PP\subst{\ptilde{\va}}{\ptilde{\x}}}{\D_1',\si{\s}{\p}:\T}{(\set{\siq :\oT{\SST}{\p}}\Dcomp
 \D_2')\Dcomp(\D_1',\s [\p]:\iT{\ptilde{\ST}}\q;\T)}~\Rightarrow{
 \D_2'\Dcomp(\D_1',\si{\s}{\p}:\T)}.PPP\Gamma \proves^\star P \rhd \Delta\Delta\tau\Delta\Delta=\emptyset\Delta'PP \redsym^\ast QQP\Gamma \vdash^\star P \rhd \emptysetP\redsym^\ast QQ\equiv \inactQ\redsym RRG(n)=\FOREACH{\ii}{<n}{\GS{\Alice}{\Bob}{\Nat}.\GS{\Bob}{\Carol}{\Nat}}G(n)\Delta(\ii+1)y:\!\Lout{\Bob}{\Nat}{(\RECSEQ{\End}{j}{\xx}{\Lout{\Bob}{\Nat}{\xx}} \APP \ii)}\Gamma\vdash \inact  \rhd \Delta(0)\Bob(n)\Carol(n)nn\geq 2\W[n]\W[0]\W[\pp]\p\n\p\n\II\W[\pp]nn,m\geq 2\ppT[\p][n][m]T'[\p][n][m]\n,
\m \geq 2\p(\prod n.\prod m.T[\p][n][m])\n \m \redsym^\ast T_{\n, \m}\not\redsym(\prod n.\prod m.T'[\p][n][m]) \n \m \redsym^\ast T_{\n, \m}\not\redsym\p=\W[n][m]\Lout{\W[\n-1][\m]}{\Nat}{\Lout{\W[\n][\m-1]} {\Nat}{\inact}}\p=\W[0][k+1]1 \leq k+1 \leq \m-1\p=\W[0][k+1]\G \proj{\p}P_{\text{fft}}P(n,\p,x_{\overline{\p}},y,r_\pp)GnP_{\text{fft}}\mr_\pp\m\emptyset \proves P_{\text{fft}} \APP \m\rhd \emptysetP_{\text{fft}} \APP  \m \longrightarrow^\ast QQ\longrightarrow^\ast
(\Poutend{r_0}{0}{\X_0}\pc\ldots\pc\Poutend{r_{2^\m-1}}{0}{\X_{2^\m-1}})\Poutend{r_\pp}{0}{\X_\pp}\X_\ppr_\ppP_{\text{fft}} \APP  \mr_\ppnn\pp\begin{array}{ll}
& \Pi n.(\RECSEQ{(\RECSEQ{\End}{l}{\xx}{(\ldots)}\APP n) \\
& }{k}{\uuu}{\\
& \quad \Pifthenelse{\pp=k}{\Lout{k}{\U}{\Lin{k}{\U}{\uuu}}}{\uuu}})\\
& ~ 2^n\\
\end{array}\begin{array}{ll}
& \Pi n.\Lout{\pp}{\U}{\Lin{\pp}{\U}{(\RECSEQ{\End}{l}{\xx}{(\ldots)}\APP n)}} \APP 2^n\\
\end{array}\begin{array}{@{}l@{}l}
& \ldots \\
& \quad (\RECSEQ{\xx}{i}{\yy}{ \\
    & \qquad (\RECSEQ{\yy}{j}{\zz}{ \\
          & \quad \qquad \Pifthenelse{\pp=i*2^{n-l}+2^{n-l-1}+j=i*2^{n-l}+j}{\ldots\\
          & \quad \qquad }{\Pifthenelse{\pp=i*2^{n-l}+2^{n-l-1}+j}{\Lout{i*2^{n-l}+j}{\U}{\ldots}\\
          & \quad \qquad }{\Pifthenelse{\pp=i*2^{n-l}+j}{\Lin{i*2^{n-l}+2^{n-l-1}+j}{\U}{\ldots}\\
          & \quad \qquad }{\Pifthenelse{\ldots}{\ldots}{\ldots}}}}}\\
    & \qquad)\APP  2^{n-l-1}} \\
  & \quad) \APP 2^l \\
& \ldots \\
\end{array}\pp\begin{array}{@{}l@{}l}
& \ldots \\
&\Pifthenelse{\bit{n-l}(\pp)=0 \\
& }{\Lin{\pp+2^{n-l-1}}{\U}{\Lout{\pp+2^{n-l-1}}{\U}{\Lout{\pp}{\U}{\Lin{\pp}\U{\xx}}}}\\
& }{\Lout{\pp-2^{n-l-1}}{\U}{\Lin{\pp-2^{n-l-1}}{\U}{\Lout{\pp}{\U}{\Lin{\pp}\U{\xx}}}}}\\
& \ldots \\
\end{array}x_k\Lin{\pp}\U{}\Lin{\pp}\U{\End}\equiv
\begin{array}{ll}
\Pi n.\Lout{\pp}{\U}{} \\
 \ (\LR{\Lin{\pp}\U{\End}}{l}{\xx} {\1mm]
    \ } {\Lin{\pp}\U{\Lin{\pp+2^{n-l-1}}{\U}{\Lout{\pp+2^{n-l-1}}{\U}{\Lout{\pp}{\U}{\xx}}}}\1mm]
From this end-point type, it is straightforward to type 
and implement the processes defined in 
Figure~\ref{fig:fft}(d) in \S~\ref{subsec:fft}. 
Hence we conclude the proof. 
\end{proof}






\subsection{Web Service} \label{sec:applications}
\noindent 
This section demonstrates the expressiveness of our type theory. We program and type a real-world Web service usecase: Quote Request (C-U-002) is the most complex scenario 
described in \cite{CDLRequirements}, the
public document authored by the W3C Choreography Description Language Working
Group \cite{CDL}. 



\begin{figure}[ht]
\begin{center}
\begin{tabular}{c}
\xymatrix@C=25pt@R=1pt{
 & *+[F] {\Supp[0]}\ar@{<->}[r]\ar@{<->}[ddr]
 &  *+[F] {\Manu[0]}\ar@{}[r]|\equiv & \txt{\Manu[0][0]} \\
 &  &  \\
  *+[F]{\Buyer} \ar@{<->}[r]\ar@{<->}[uur]\ar@{<->}[ddr]
&  *+[F]{\Supp[1]} \ar@{<->}[ddr]
&  *+[F] {\Manu[1]}\ar@{}[r]|\equiv & \txt{\Manu[0][1]\\ \Manu[2][1]}\\
 &  &   \\
&  *+[F]{\Supp[2]} \ar@{<->}[r]\ar@{<->}[uur]
&  *+[F] {\Manu[2]}\ar@{}[r]|\equiv & \txt{\Manu[1][2]\\ \Manu[2][2]}\\
 & {:} & {:}  \\
}\\
\end{tabular}
\end{center}
\caption{The Quote Request usecase (C-U-002) \cite{CDLRequirements} \label{fig:CDL}}
\end{figure}

\paragraph{\bf Quote Request usecase}
The usecase is described below (as published in \cite{CDLRequirements}). 
A buyer interacts with multiple suppliers who in turn
interact with multiple manufacturers in order to obtain quotes for some
goods or services. 
The steps of the interaction are: 
\begin{enumerate}[(1)]
\item A buyer requests a quote from a set of suppliers.
All suppliers receive the request for quote and send requests
for a bill of material items to their respective manufacturers.

\item 
The suppliers interact with their manufacturers to build their quotes
for the buyer. The eventual quote is sent back to the buyer. 

\item EITHER
\begin{enumerate}
\item The buyer agrees with one or more of the quotes and places the order or orders. OR 
\item The buyer responds to one or more of the quotes by modifying 
and sending them back to the relevant suppliers.
\end{enumerate}
\item EITHER
\begin{enumerate}
\item The suppliers respond to a modified quote 
by agreeing to it and sending a confirmation message back to the buyer. OR

\item The supplier responds by modifying the quote and sending it back
to the buyer and the buyer goes back to STEP 3. OR 

\item 
The supplier responds to the buyer rejecting the modified quote. OR 

\item 
The quotes from the manufacturers need to be renegotiated by the supplier. Go to STEP 2. 
\end{enumerate}
\end{enumerate}
The usecase, depicted in figure~\ref{fig:CDL}, may seem simple, 
but it contains many challenges. 
The Requirements 
in Section 3.1.2.2 of \cite{CDLRequirements} include:  
{\bf [R1]} the ability to repeat the same set of interactions 
between different parties using a single definition
and to compose them;
{\bf [R2]} 
the number of participants 
may be bounded at design time or at runtime; and  
{\bf [R3]} 
the ability to {\em reference a global description from within a
global description} to support {\em recursive behaviour} as 
denoted in {\sc Step} 4(b, d).   
The following works through a parameterised 
global type specification that satisfies these requirements.   





\paragraph{\bf Modular programming using global types}
We develop the specification of the usecase program modularly, 
starting from smaller global types. Here, 
 stands for the buyer, 
 for a supplier, 
and  for a manufacturer. Then we alias manufacturers by  to identify that  
is connected to   (so a single  can have multiple
aliases , see figure~\ref{fig:CDL}). Then, using the idioms presented in \S~1, {\sc Step} 1 
is defined as:

For {\sc Step} 2, we compose a nested loop and the subsequent action
within the main loop ( gives all  connected
to ):  
{\small
1mm]
G_2[i]= \mathtt{foreach}({\jj}:{J_i})\{ & 
\GS{\texttt{Supp}[\ii]}{\texttt{Manu}[\ii][\jj]}{\mathsf{Item}}.\\
& \GS{\texttt{Manu}[\ii][\jj]}{\texttt{Supp}[\ii]}{\mathsf{Quote}}.\End\}
\end{array}

\begin{array}{rcl}
G_3 & = & \GR{\ \ty\ }{i}{\yy}{} \TO{\texttt{Buyer}}{\texttt{Supp}[i]} : \{ \\
& & \quad \begin{array}{llll}
\mathsf{ok}: & \End \\
\mathsf{modify}: & \multicolumn{3}{l}{\GS{\texttt{Buyer}}{\texttt{Supp}[i]}{\mathsf{Quote}}} \\
& \TO{\texttt{Supp}[i]}{\texttt{Buyer}}: \{
&  \mathsf{ok}: & \End \\
&& \mathsf{retryStep3}: & \yy\\
&&  \mathsf{reject}: & \End\}\}\ \ii
\end{array}
\end{array}

\lambda i.\lambda \VEC{J}.\MERGE{G_1,G_{23}} 

\begin{array}{lllll}
G_1\proj{\texttt{Supp}[\n]} = \Linn{\texttt{Buyer}}{\mathsf{Quote}} \
For , 
we use the branching injection and 
mergeability theory developed in 
\S~\ref{subsec:endpoint}. 
After the relevant application of \trule{TEq}, we can obtain 
the following projection:

where  is a type for the invocation 
from : 

To tell the other suppliers whether the loop is being reiterated 
or if it is finished, 
we can simply insert the following closing notification

before each , 
and a similar retry notification (with label ) before .
Finally, each end-point type is formed by the following composition: 

Following this specification, the projections can be implemented in various
end-point languages (such as CDL or BPEL).  














\section{Conclusion and related work}
\label{sec:related}
This paper studies a parameterised multiparty session type theory
which combines three well-known theories: indexed dependent types
\cite{DBLP:conf/popl/XiP99}, dependent types with
recursors \cite{DBLP:conf/mfps/Nelson91}
and multiparty session types \cite{BettiniCDLDY08LONG,CHY07}.
The resulting typing system is decidable (under
an appropriate assumption about the index arithmetic).
It offers great expressive power
for describing complex communication topologies
and guarantees safety properties of processes running under
such topologies.
We have explored the impact of
parameterised type structures for
communications
through implementations of the above web service usecases and of several parallel
algorithms in Java and C with session
types~\cite{HU07TYPE-SAFE,HKOYH10}, including
the N-body (with a ring topology),
the Jacobi method
(with sequence and mesh topologies)
and the FFT \cite{NYPHK11,NYH12}.
We observe (1) a clear coordination
of the communication behaviour of each party with the
construction of the whole multiparty protocol, thus reducing
programming errors and ensuring deadlock-freedom; and (2)
a performance benefit against the original binary session version,
reducing the overhead of multiple binary session
establishments (see also \cite{NYPHK11,NYH12}).
Full implementation and integration of our theory
into~\cite{HU07TYPE-SAFE,CorinDFBL09,HKOYH10} is on-going work.




\subsection{Related work}
We focus on the works on dependent types and other typed process
calculi which are related to multiparty session types; for further
comparisons of session types with other service-oriented calculi and
behaviour typing systems, see \cite{DL10} for a wide ranging survey of
the related literature.

\paragraph*{\bf Dependent types}
\noindent
The first use of primitive recursive functionals for dependent types
is in Nelson's ~\cite{DBLP:conf/mfps/Nelson91}
for the -calculus, which is a finite
representation of  by Tait and Martin L\"of
\cite{Tait,PerMartin}.
 can type functions previously untypable in ML, and the finite
representability of dependent types makes it possible to have a
type-reconstruction algorithm. We also use the ideas from DML's
dependent typing system in \cite{DBLP:conf/popl/XiP99,DependentBook}
where type dependency is only allowed for index sorts, so that
type-checking can be reduced to a constraint-solving problem over
indices.
Our design choice to combine both systems gives (1) the simplest formulation of sequences of global and end-point types and
processes described by the primitive recursor; (2) a precise specification
for parameters appearing in the participants based on index sorts; and (3) a
clear
integration with the full session types
and general recursion, whilst ensuring decidability of type-checking (if the
constraint-solving problem is decidable).
From the basis of these works,
our type equivalence
does not have to rely on
behavioural equivalence between processes, but only on the strongly
normalising {\em types} represented by recursors.

Dependent types have been also studied in the context
of process calculi, where the dependency centres
on locations (e.g.~\cite{Hennessy07}),
and channels (e.g.~\cite{Yoshida04}) for mobile agents or
higher-order processes.
An effect-based session typing system
for corresponding assertions to specify fine-grained
communication specifications is studied
in \cite{BAG05} where effects can appear both in types and
processes.
None of these works investigate families of global specifications using
dependent types.
Our main typing rules require a careful treatment for type
soundness not found in the previous works, due to the simultaneous instantiation
of terms and indices by the recursor, with reasoning by mathematical induction
(note that type soundness was left open in \cite{DBLP:conf/mfps/Nelson91}).

\paragraph*{\bf Types and contracts for multiparty interactions}
The first papers on multiparty session types were \cite{BC07} and
\cite{CHY07}. The former uses a distributed calculus where
each channel connects a master end-point to one or more slave
endpoints; instead of global types, they use only
local types.
Since the first
work \cite{CHY07} was proposed, this theory has been used in the
different contexts such as distributed protocol implementation and
optimisation~\cite{SivaramakrishnanNZE10},
security~\cite{CorinDFBL09,ccdr10},
design by contract~\cite{BHTY10},
parallel algorithms~\cite{NYPHK11,NYH12}, web services~\cite{YDBH10},
multicore programming~\cite{YoshidaVPH08},
an advanced progress guarantee~\cite{BettiniCDLDY08LONG},
messaging optimisation~\cite{esop09},
structured exceptions~\cite{CGY10},
buffer and channel size analysis for multiparty
interactions~\cite{Bufferfull},
medical guidelines~\cite{NYH09} and
communicating automata \cite{DY12},
some of which initiated industrial collaborations, cf.~\cite{HondaMBCY11}.
Our typing system can be smoothly integrated
with other works as no changes to the runtime typing components have been made
while expressiveness has been greatly improved.


The work \cite{carbone.honda.yoshida:esop07}
presented an {\emph{executable global processes}}
for web interactions
based on binary session types.
Our work provides flexible, programmable  global descriptions
as {\em types}, offering a progress for parameterised multiparty
session, which is not ensured in \cite{carbone.honda.yoshida:esop07}.


The work \cite{B10} provides a programming idiom of roles, defining
different classes of participants, and a different type system for
parameterised session types. There is no investigation of the system
expressivity for the 3D-Mesh pattern as we have presented in this
paper through the Fast Fourier Transformation example.  The static
type system follows the typing strategy and programming methodology of
multiparty session types: programmers first define the global type of
the intended pattern and then define each of the roles; the roles are then
validated through projection of the global type onto the principals by
type-checking.


Recent formalisms for typing multiparty interactions include
\cite{CP09,CairesV09}.
These works treat different aspects of dynamic session structures.
{\em Contracts} \cite{CP09} can type more processes
than session types, thanks to the flexibility of process syntax
for describing protocols.
However, typable processes themselves in \cite{CP09} may
not always satisfy the properties of session types such as progress: it is
proved later by checking whether the type meets a certain form.  Hence
proving progress with contracts effectively
requires an exploration of all possible paths (interleaving, choices)
of a protocol.  The most complex example of~\cite[\S~3]{CP09} (a group
key agreement protocol from~\cite{AST98}), which is typed as
-processes with delegations, can be specified and articulated
by a single parameterised
global session type as:
{\small

}
Once the end-point process conforms to this specification, we can
automatically guarantee communication safety and progress.




{\em  Conversation Calculus} \cite{CairesV09} supports the dynamic
joining and leaving of participants.
We also introduced a dynamic role-based multiparty session type
discipline in previous work \cite{DY11}, where an arbitrary number of participants can
interact in a running session via a universal polling operator. This
work was extended with simple relations between roles
in \cite{Poon11} to dynamically handle
the complex topologies presented in this paper.
Although the formalism in \S~\ref{subsec:semantics} can operationally capture some dynamic
features, the aim of the present work is
not
the type-abstraction
of dynamic interaction patterns. Our purpose is
to capture, in a single type description, a family
of protocols over arbitrary numbers of participants,
to be instantiated at runtime.
Parameterisation gives freedom not possible with previous session
types: once typed, a parametric process is ensured that its arbitrary
well-typed instantiations, in terms of both topologies and process
behaviours, satisfy the safety and progress properties of typed
processes, without the cost of complex runtime support (as in \cite{DY11}).
Parameterisation, composition and repetition are common idioms in
parallel algorithms and choreographic/conversational interactions, all
of which are uniformly treatable in our dependent type theory. Here
types offer a rigorous structuring principle which can economically
abstract rich interaction structures, including parameterised ones.


\section*{Acknowledgements}

We thank the reviewers,
Lasse Nielsen and Dimitris Mostrous for their useful comments for the
paper and  Kohei Honda for discussions, and
Michael Emmanuel, Yiannos Kryftis, Nicholas Ng, Olivier Pernet and Hok Shun Poon
for their implementation work of the examples presented
in this paper.
The work is partially supported by EPSRC EP/G015635/1 and EP/F003757/1, and the NSF Ocean Observatories Initiative. The last author was also supported by EPSRC PhD Plus and EPSRC Knowledge Transfer Secondment.



\bibliographystyle{abbrv}

\bibliography{session}

\appendix


\section{Kinding and typing rules}
In this Appendix section, we give the definitions of kinding rules and
typing rules 
that were omitted in the main sections.













\subsection{Kinding and subtyping}
\label{app:kind}
Figure~\ref{fig:localkindsystem} defines the kinding rules for local types.  
Figure~\ref{fig:subtyping}
presents the subtyping rules which are used for typing runtime processes. 
The rules for the type isomorphism can be given 
by replacing  by . 


















\begin{figure}
\centering
\begin{tabular}{c}
\begin{prooftree}
  {\Gamma \vdash \p \rhd \Nat \quad \Gamma \vdash \T \RHD \LType
  \quad \Gamma\vdash \U  \RHD \SType \text{ or } \LType }
\justifies
{\Gamma \vdash \Lout{\p}{\U}{\T}  \RHD \LType} \using\tfrule{KLOut}
\end{prooftree}\\
\\
\begin{prooftree}
{\Gamma \vdash \p \rhd \Nat \quad \Gamma \vdash \T \RHD \LType 
  \quad \Gamma \vdash \U  \RHD \SType \text{ or } \LType}
\justifies
{\Gamma \vdash \Lin{\p}{\U}{\T}  \RHD \LType} \using\tfrule{KLIn}
\end{prooftree}\\
\\
\begin{prooftree}
{\Gamma \vdash \T \RHD  \Pi\AT{\ii}{\II}.\K \quad \Gamma \models \tii : I}
\justifies
{\Gamma \vdash \T\APP\tii \RHD \K\sub{\tii}{\ii}} \using\tfrule{KLApp}
\end{prooftree}
\ 
\begin{prooftree}
{\Gamma \vdash \p \rhd \Nat \quad \forall k \in K, \Gamma \vdash \T_k \RHD \LType }
\justifies
{\Gamma \vdash \Lsel{\p}{T_k} \RHD \LType} \using\tfrule{KLSel}
\end{prooftree}\\
\\
\begin{prooftree}
{\Gamma \vdash \p \rhd \Nat \quad \forall k \in K, \Gamma \vdash \T_k \RHD \LType }
\justifies
{\Gamma \vdash \Lbranch{\p}{T_k} \RHD \LType} \using\tfrule{KLBra}
\end{prooftree}\\
\\
\begin{prooftree}
{\Gamma \vdash \T \RHD \K\subst{0}{j} \quad 
 \Gamma, \ii:\II^- \vdash \T' \RHD \K\subst{i+1}{j}}
\justifies
{\Gamma \vdash \LR{\T}{\AT{\ii}{\II^-}}{\xx}{\T'}  
\RHD \Pi\AT{\jj}{\II}.\K} \using\tfrule{KLRcr}
\end{prooftree}\\
\\ 
\begin{prooftree}
{\Gamma \vdash \kappa}
\justifies
{\Gamma \vdash \xx \RHD \kappa} \using\tfrule{KVar}
\end{prooftree}
\quad
\begin{prooftree}
{\Gamma \vdash \T \RHD \LType }
\justifies
{\Gamma \vdash \LM{\xx}{\T} \RHD \LType} \using\tfrule{KLRec}
\end{prooftree}
\quad
\begin{prooftree}
{\Gamma \vdash \Env }
\justifies
{\Gamma \vdash \End \RHD \LType} \using\tfrule{KLEnd}
\end{prooftree}\\
\\
\end{tabular}

\caption{Kinding rules for local types} \label{fig:localkindsystem}
\end{figure}
 
\begin{figure}
\centering 
\begin{tabular}{c}
\begin{prooftree}
{\Gamma \vdash \T \subT \T'}
\justifies
{\Gamma \vdash  \Lout{\p}{\U}{\T}\subT  \Lout{\p}{\U}{\T'}} \using\trule{TSubOut}
\end{prooftree}\quad 
\begin{prooftree}
{\Gamma \vdash \T \subT \T'}
\justifies
{\Gamma \vdash  \Lin{\p}{\U}{\T}\subT  \Lin{\p}{\U}{\T'}} \using\trule{TSubIn}
\end{prooftree}\\
\\
\begin{prooftree}
{\forall k\in K\subseteq J,\ \Gamma \vdash \T_k \subT \T_k'}
\justifies
{ \Gamma \vdash \LselI{\p}{\T_k}{k}{K}\subT  \LselI{\p}{\T_\jj'}{\jj}{J}} \using\trule{TSSel}
\end{prooftree}\\
\\
\begin{prooftree}
{\forall k\in J\subseteq K,\ \Gamma \vdash \T_k \subT \T_k'}
\justifies
{ \Gamma \vdash \LbranchI{\p}{\T_k}{k}{K} \subT \LbranchI{\p}{\T_\jj'}{\jj}{J}} \using\trule{TBra}
\end{prooftree}\\
\\
\begin{prooftree}
{\Gamma \vdash \T_1 \subT \T_2 \quad \Gamma,\ii:\II \vdash \T_1' \subT \T_2'}
\justifies
{\Gamma \vdash \LR{\T_1}{\AT{\ii}{\II}}{\xx}{\T_1'} \subT \LR{\T_2}{\AT{\ii}{\II}}{\xx}{\T_2'}} \using\trule{TSubPRec}
\end{prooftree}\\
\\
\begin{prooftree}
{\Gamma \vdash T\sub{\LM{\xx}{\T}}{\xx} \subT \T'}
\justifies
{\Gamma \vdash \LM{\xx}{\T} \subT  \T'} \using\trule{TLSubRec}
\end{prooftree}\quad 
\begin{prooftree}
{\Gamma \vdash T'\subT T\sub{\LM{\xx}{\T}}{\xx}}
\justifies
{\Gamma \vdash T'\subT  \LM{\xx}{\T }} \using\trule{TRSubRec}
\end{prooftree}\\
\\
\begin{prooftree}
{\Gamma \vdash \T \subT \T' \quad \Gamma \models \tii:I=\tii':I}
\justifies
{\Gamma \vdash \T\APP \tii \subT \T'\APP \tii'} \using\trule{TSubProj}
\end{prooftree}\\
\\
\begin{prooftree}
{\Gamma \vdash \Env}
\justifies
{\Gamma \vdash \End\subT \End} \using\trule{TSubEnd}
\end{prooftree} \quad 
\begin{prooftree}
{\Gamma \vdash \Env}
\justifies
{\Gamma \vdash \xx\subT \xx} \using\trule{TSubRVar}
\end{prooftree}
\end{tabular}
\caption{Subtyping} \label{fig:subtyping}
\end{figure}
 




\section{Typing system for runtime processes}
\label{app:runtime}
This appendix defines a typing system for runtime processes
(which contain queues).   
Most of the definitions are from \cite{BettiniCDLDY08LONG}. 


\begin{center}
\begin{tabular}{c}
\begin{tabular}{lrclr}
  Message &  & ::= &
         \oT\UT{\pv} & \emph{message send}\\
         &     & \sep  & \seltypes &\emph{message selection}\\
         &     & \sep  &  &\emph{message sequence}\\
\\
  Generalised \quad\quad\quad &  & ::= &
         \T
  & \emph{session}\\
         &     & \sep & \TQ &\ \emph{message}\\
         &     & \sep &  &\ \emph{continuation}\\equivT{\TQ}{\TQ'}\text{ implies }\equivT{\TQ;\TG}{\TQ';\TG}
\begin{array}{c}
 \begin{prooftree}
\der{\Ga}{\PP}{\D} \justifies \derqq{\Ga}{\emptyset}{\PP }{\D}
\using\trule{GInit}
\end{prooftree}
\ 
\begin{prooftree}
\derqq{\Ga}{\Sigma}{\PP}{\D}\quad \D \WB \D'
\justifies
\derqq{\Ga}{\Sigma}{\PP }{\D'}\using\trule{Equiv}
\end{prooftree}
\begin{prooftree}
\derqq{\Ga}{\Sigma}{\PP}{\D}\quad \D \subT \D'
\justifies
\derqq{\Ga}{\Sigma}{\PP }{\D'}\using\trule{Subs}
\end{prooftree}
\\\\
\begin{prooftree}
\derqq{\Ga}{\Sigma}{\PP}{\D}\quad \derqq{\Ga}{\Sigma'}{\Q}{\D'}
\quad \Sigma\cap\Sigma'=\emptyset
 \justifies
\derqq{\Ga}{\Sigma\cup\Sigma'}{\PP\Par \Q}{\D \Dcomp \D'}
 \using \trule{GPar}
 \end{prooftree}
\quad 
\begin{prooftree}
\derqq{\Ga}{\Sigma}{\PP}{\D}\quad \coe\D\s \justifies
\derqq{\Ga}{\Sigma\setminus\s}{(\nu\s)\PP }{\ms\D\s}
\using\trule{GSRes}
\end{prooftree}
\end{array}
-.2em]
    \TG'\Tcomp \TG   & \text{if  is a message type}, \
\begin{array}{rcl}
\pro{(\oT\UT{\pv};\TG')}\q&=&\begin{cases}
  !\UT;\pro{\TG'}\q  & \text{if }\q = \pv, \\
   \pro{\TG'}\q & \text{otherwise}.
\end{cases}\\
\pro{(\seltypes;\TG')}\q&=&\begin{cases}
  \oplus l;\pro{\TG'}\q  & \text{if }\q=\pv, \\
   \pro{\TG'}\q & \text{otherwise}.
\end{cases}\\
\pro{(\iT\UT{\p};\T)}\q&=&\begin{cases}
  ?\UT;\pro{\T}\q  & \text{if }\q=\p, \\
   \pro{\T}\q & \text{otherwise.}
\end{cases}\\
\pro{(\seltype)}\q&=&\begin{cases}
  \seltypeT  & \text{if }\q = \p, \\
  \sqcup_{i\in I}\pro{\T_i}\q & \text{otherwise.}
\end{cases}\\
\pro{(\branchtype)}\q&=&\begin{cases}
  \branchtypeT  & \text{if }\q=\p, \\
\sqcup_{i\in I}\pro{\T_i}\q 
&  \text{otherwise.}
\end{cases}\\
\pro{(\mu \xx.\T)}\q&=& \mu \xx.(\pro{\T}\q) \quad
\pro\xx\q=\xx\quad\pro\End\q=
         \End\\
       \end{array}
        
\begin{array}{lll}
\&\langle\{l_k:T_k\}_{i\in I}\rangle \ \mergecup 
\&\langle\{l_j:T_j'\}_{j\in J}\rangle \ = \\ 
\quad \&\langle\{l_k:T_k\mergecup T_k'\}_{k\in K\cap J}
\cup \{l_k:T_k\}_{k\in K\setminus J}
\cup \{l_j:T_j'\}_{j\in J\setminus K}\rangle\
\end{DEFINITION}

\begin{DEFINITION}\label{dd}
The {\em duality relation} between projections of generalised
types is the minimal symmetric relation which satisfies:

\begin{center}
 







\end{center}
\end{DEFINITION}

\end{document}
